//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <libintl.h>
#include <math.h>
#include <netdb.h>
#include <pwd.h>
#include <regex.h>
#include <setjmp.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF___sigset_t {
    int32_t e0[1];
};

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct __dirstream {
    int32_t e0;
};

struct __jmp_buf_tag {
    int32_t e0[8];
    int32_t e1;
    struct _TYPEDEF___sigset_t e2;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct passwd {
    char * e0;
    char * e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    char * e5;
    char * e6;
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t __i686_get_pc_thunk_bx(int32_t a1);
char __r_delete(int32_t * node, int32_t * query);
void __r_destroy_tree(int32_t * node);
void __r_insert_node(int32_t * node, int32_t * query, int32_t manage, char force);
int32_t __r_search(int32_t * node, int32_t * query, int32_t * arg);
void AddObjectToFlagUndoList(int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3);
void AddTextToElement(int32_t * Text, int32_t * PCBFont, int32_t X, int32_t Y, char Direction, char * TextString, int32_t Scale, int32_t Flags);
void adjust_bounds(int32_t * node);
void AdjustAttachedLine(void);
void AdjustAttachedObjects(void);
int32_t * AdjustInsertPoint(void);
void AdjustTwoLine(int32_t way);
char * alloc_buf(int32_t len);
void apply_default_hid(int32_t * d, int32_t * s);
char * c_dtostr(float64_t d);
float64_t c_strtod(char * s);
int32_t ChangeGroupVisibility(int32_t Layer2, char On, char ChangeStackOrder);
void ChangePCBSize(int32_t Width, int32_t Height);
void ClearFromPolygon(int32_t * Data, int32_t type, char * ptr1, char * ptr2);
int32_t clearPoly(int32_t * Data, int32_t * Layer2, int32_t * polygon, int32_t * here, int32_t expand);
void ClearUndoList(char Force);
char * common_flags_to_string(int32_t flags, int32_t object_type, int32_t * flagbits, int32_t n_flagbits);
int32_t common_string_to_flags(char * flagstring, int32_t (*error)(char *), int32_t * flagbits, int32_t n_flagbits);
char * Concat(char * first, ...);
void copyright(void);
void CreateDefaultFont(void);
int32_t * CreateNewArcInElement(int32_t * Element, int32_t X, int32_t Y, int32_t Width, int32_t Height, int32_t Angle, int32_t Delta, int32_t Thickness);
int32_t * CreateNewArcOnLayer(int32_t * Layer2, int32_t X1, int32_t Y1, int32_t width, int32_t height, int32_t sa, int32_t dir, int32_t Thickness, int32_t Clearance, int32_t Flags);
int32_t * CreateNewAttribute(int32_t * list, char * name, char * value);
int32_t * CreateNewBuffer(void);
int32_t * CreateNewConnection(int32_t * net, char * conn);
int32_t * CreateNewElement(int32_t * Data, int32_t * Element, int32_t * PCBFont, int32_t Flags, char * Description, char * NameOnPCB, char * Value, int32_t TextX, int32_t TextY, char Direction, int32_t TextScale, int32_t TextFlags, char uniqueName);
int32_t * CreateNewLineInElement(int32_t * Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness);
int32_t * CreateNewLineInSymbol(int32_t * Symbol2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness);
int32_t * CreateNewLineOnLayer(int32_t * Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Flags);
int32_t * CreateNewNet(int32_t * lib, char * name, char * style);
int32_t * CreateNewPad(int32_t * Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Mask, char * Name, char * Number, int32_t Flags);
int32_t * CreateNewPCB(char SetDefaultNames);
int32_t CreateNewPCBPost(int32_t * pcb, int32_t use_defaults);
int32_t * CreateNewPin(int32_t * Element, int32_t X, int32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, char * Number, int32_t Flags);
int32_t * CreateNewPointInPolygon(int32_t * Polygon2, int32_t X, int32_t Y);
int32_t * CreateNewPolygon(int32_t * Layer2, int32_t Flags);
int32_t * CreateNewPolygonFromRectangle(int32_t * Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Flags);
int32_t * CreateNewRat(int32_t * Data, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t group1, int32_t group2, int32_t Thickness, int32_t Flags);
int32_t * CreateNewText(int32_t * Layer2, int32_t * PCBFont, int32_t X, int32_t Y, char Direction, int32_t Scale, char * TextString, int32_t Flags);
int32_t * CreateNewVia(int32_t * Data, uint32_t X, uint32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, int32_t Flags);
void CreateQuotedString(int32_t * DS, char * S);
void CrosshairOff(char BlockToo);
void CrosshairOn(char BlockToo);
char * DestroyObject(int32_t * Target, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3);
void Draw(void);
void DrawArc(int32_t * Layer2, int32_t * Arc, int32_t unused);
void DrawArcLowLevel(int32_t * Arc);
void DrawAttached(char BlockToo);
void DrawLine(int32_t * Layer2, int32_t * Line, int32_t unused);
void DrawLineLowLevel(int32_t * Line, char HaveGathered);
void DrawMark(char ifvis);
void DrawPad(int32_t * Pad, int32_t unused);
void DrawPadLowLevel(int32_t * gc, int32_t * Pad, char clear, char mask);
void DrawPadNameLowLevel(int32_t * Pad);
void DrawPin(int32_t * Pin, int32_t unused);
void DrawPinOrViaLowLevel(int32_t * Ptr, char drawHole);
void DrawPinOrViaNameLowLevel(int32_t * Ptr);
void DrawPolygon(int32_t * Layer2, int32_t * Polygon2, int32_t unused);
void DrawRat(int32_t * Line, int32_t unused);
void DrawSpecialPolygon(int32_t * hid, int32_t * DrawGC, int32_t X, int32_t Y, int32_t Thickness);
void DrawTextLowLevel(int32_t * Text, int32_t min_line_width);
void DrawVia(int32_t * Via, int32_t unused);
float32_t drc_lines(int32_t * end, char way);
void DSAddCharacter(int32_t * Ptr, char Char);
void DSAddString(int32_t * Ptr, char * S);
void DSClearString(int32_t * Ptr);
void dump_actions(void);
void dump_string(char prefix, char * str);
void EmergencySave(void);
void EnableAutosave(void);
void EnforceLineDRC(void);
char * EvaluateFilename(char * Template, char * Path, char * Filename, char * Parameter);
int32_t * find_clusters(int32_t * node);
void FitCrosshairIntoGrid(int32_t X, int32_t Y);
char * flags_to_string(int32_t flags, int32_t object_type);
void FortyFiveLine(int32_t * Line);
void FreeAttributeListMemory(int32_t * list);
void FreeDataMemory(int32_t * Data);
void FreeElementMemory(int32_t * Element);
void FreeLibraryMemory(int32_t * lib);
void FreePCBMemory(int32_t * PCBPtr);
void FreePolygonMemory(int32_t * Polygon2);
int32_t function_805e978(int32_t a1);
int32_t function_805ecf8(void);
int32_t function_805edd8(int32_t * a1);
int32_t function_805ef38(int32_t a1, char * a2, int32_t * a3);
int32_t function_805efc8(int32_t a1, int32_t * a2);
int32_t function_805eff8(int32_t * a1);
int32_t function_805f098(int32_t a1);
int32_t function_805f2b8(int32_t a1, char * a2, int32_t a3, int32_t * a4);
int32_t function_805f448(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_805fc48(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_805fcf8(int32_t a1, char * a2, int32_t * a3, int32_t a4);
int32_t function_80600e8(int32_t a1);
int32_t function_8060118(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_8060718(int32_t * a1);
int32_t function_80607f8(int32_t a1, char * a2, int32_t * a3, float80_t a4);
int32_t function_8060908(int32_t a1, char * a2);
int32_t function_8060d88(float80_t a1);
int32_t * GetArcEnds(int32_t * Arc);
int32_t * GetArcMemory(int32_t * Layer2);
int32_t * GetDataBoundingBox(int32_t * Data);
int32_t * GetElementMemory(int32_t * Data);
int32_t GetGroupOfLayer(int32_t a1);
int32_t GetLayerGroupNumberByNumber(int32_t a1);
int32_t GetLayerNumber(int32_t a1, int32_t a2);
int32_t * GetLibraryEntryMemory(int32_t * Menu2);
int32_t * GetLibraryMenuMemory(int32_t * lib);
int32_t * GetLineMemory(int32_t * Layer2);
void GetNum(char ** s, int32_t * num);
int32_t * GetPadMemory(int32_t * Element);
int32_t * GetPinMemory(int32_t * Element);
int32_t * GetPointMemoryInPolygon(int32_t * Polygon2);
int32_t * GetPolygonMemory(int32_t * Layer2);
int32_t * GetRatMemory(int32_t * Data);
int32_t * GetTextMemory(int32_t * Layer2);
int32_t * GetUndoSlot(int32_t CommandType, int32_t ID2, int32_t Kind);
int32_t * GetViaMemory(int32_t * Data);
char * GetWorkingDirectory(char * path);
void grow_layer_list(int32_t num);
int32_t hid_action(char * name);
int32_t hid_actionl(char * name, ...);
int32_t hid_actionv(char * name, uint32_t argc, char ** argv);
void hid_bom_init(void);
int32_t ** hid_enumerate(void);
void hid_eps_init(void);
int32_t * hid_find_action(char * name, char ** context);
int32_t * hid_find_exporter(char * which);
int32_t * hid_find_flag(char * name);
int32_t * hid_find_gui(void);
int32_t * hid_find_printer(void);
void hid_gerber_init(void);
int32_t hid_get_flag(char * name);
void hid_gtk_init(void);
void hid_init(void);
void hid_load_dir(char * dirname);
void hid_load_settings(void);
void hid_load_settings_1(char * fname);
void hid_lpr_init(void);
void hid_nelma_init(void);
int32_t hid_parse_actions(char * rstr, int32_t (*function)(char *, int32_t, char **));
void hid_png_init(void);
void hid_ps_init(void);
void hid_register_actions(int32_t * a, int32_t n);
void hid_register_actions_context(int32_t * a, int32_t n, char * context, int32_t dynamic);
void hid_register_attributes(int32_t * a, int32_t n);
void hid_register_flags(int32_t * a, int32_t n);
void hid_register_hid(int32_t * hid);
void HideCrosshair(char BlockToo);
void IncrementUndoSerialNumber(void);
void InitBuffers(void);
int32_t InitClip(int32_t * Data, int32_t * layer, int32_t * p);
void InitCrosshair(void);
char IsDataEmpty(int32_t * Data);
char * LayerGroupsToString(int32_t * lg);
void LayerStringToLayerStack(char * s);
int32_t LoadPCB(char * Filename);
char * lrealpath(char * filename);
char * make_edge_tree(int32_t * pb);
int32_t MakeFlags(int32_t flags);
int32_t mem_any_set(char * ptr, int32_t bytes);
void Message(char * Format, ...);
void MoveCrosshairRelative(int32_t DeltaX, int32_t DeltaY);
void MoveElementLowLevel(int32_t * Data, int32_t * Element, int32_t DX, int32_t DY);
char * MyCalloc(int32_t Number, int32_t Size, char * Text);
void MyFatal(char * Format, ...);
char * MyRealloc(char * Ptr, int32_t Size, char * Text);
char * MyStrdup(char * S, char * Text);
char * ObjectOperation(int32_t * F, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3);
int32_t OldFlags(int32_t flags);
void OpendirErrorMessage(char * DirName);
void OpenErrorMessage(char * Filename);
int32_t * original_poly(int32_t * p);
int32_t Parse(char * Executable, char * Path, char * Filename, char * Parameter);
int32_t parse_number(float64_t scale);
int32_t ParseFont(int32_t * Ptr, char * Filename);
int32_t ParseGroupString(char * s, int32_t * LayerGroup, int32_t LayerN);
int32_t ParseLibraryTree(void);
int32_t ParsePCB(int32_t * Ptr, char * Filename);
int32_t ParseRouteString(char * s, int32_t * routeStyle, int32_t scale);
void pcb_colors_from_settings(int32_t * ptr);
void pcb_dbus_connection_finish_with_mainloop(int32_t * connection);
void pcb_dbus_connection_setup_with_mainloop(int32_t * connection);
void pcb_dbus_finish(void);
void pcb_dbus_setup(void);
char * pcbflags_to_string(int32_t flags);
int32_t PlowsPolygon(int32_t * Data, int32_t type, char * ptr1, char * ptr2, int32_t (*call_back)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *));
int32_t * poly_Create(void);
int32_t * poly_CreateNode(int32_t * v);
void poly_DelContour(int32_t ** c);
void poly_ExclVertex(int32_t * node);
void poly_Free(int32_t ** p);
void poly_FreeContours(int32_t ** pline);
int32_t poly_InclContour(int32_t * p, int32_t * c);
void poly_InclVertex(int32_t * after, int32_t * node);
void poly_InvContour(int32_t * c);
int32_t * poly_NewContour(int32_t * v);
void poly_PreContour(int32_t * C, int32_t optimize);
void PopenErrorMessage(char * Filename);
void PostLoadElementPCB(void);
void PreLoadElementPCB(void);
void print_actions(void);
void print_defaults_1(int32_t * a, char * value);
void print_version(void);
void PrintQuotedString(struct _IO_FILE * FP, char * S);
int32_t * r_create_tree(int32_t ** boxlist, int32_t N, int32_t manage);
char r_delete_entry(int32_t * rtree, int32_t * box);
void r_destroy_tree(int32_t ** rtree);
void r_insert_entry(int32_t * rtree, int32_t * which, int32_t man);
int32_t r_search(int32_t * rtree, int32_t * query, int32_t (*check_region)(int32_t *, char *), int32_t (*found_rectangle)(int32_t *, char *), char * cl);
int32_t ReadLibraryContents(void);
void register_action_action_list(void);
void register_command_action_list(void);
void register_djopt_action_list(void);
void register_djopt_flag_list(void);
void register_eps_attribute_list(void);
void register_flags_flag_list(void);
void register_fontmode_action_list(void);
void register_ghid_attribute_list(void);
void register_ghid_main_action_list(void);
void register_ghid_main_flag_list(void);
void register_ghid_menu_action_list(void);
void register_ghid_netlist_action_list(void);
void register_gtk_topwindow_action_list(void);
void register_main_attribute_list(void);
void register_move_action_list(void);
void register_nelma_attribute_list(void);
void register_netlist_action_list(void);
void register_pcbmenu_attr(void);
void register_png_attribute_list(void);
void register_ps_attribute_list(void);
void register_puller_action_list(void);
void register_report_action_list(void);
void register_rotate_action_list(void);
void register_toporouter_action_list(void);
void register_vendor_action_list(void);
void register_vendor_flag_list(void);
char rematch(char * re, char * s);
void RemovePCB(int32_t * Ptr);
void RemoveTMPData(void);
void ResetFoundLinesAndPolygons(char AndDraw);
void ResetFoundPinsViasAndPads(char AndDraw);
void ResetStackAndVisibility(void);
void RestoreCrosshair(char BlockToo);
void RestoreToPolygon(int32_t * Data, int32_t type, char * ptr1, char * ptr2);
void RestoreUndoSerialNumber(void);
void RightAngles(int32_t Angle, float32_t * cosa, float32_t * sina);
void RotateBoxLowLevel(int32_t * Box, int32_t X, int32_t Y, unsigned char Number);
void RotateLineLowLevel(int32_t * Line, int32_t X, int32_t Y, unsigned char Number);
void SaveFree(char * Ptr);
void SaveInTMP(void);
void SaveTMPData(void);
void SaveUndoSerialNumber(void);
char SearchArcByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Arc, int32_t ** Dummy);
char SearchElementByLocation(int32_t locked, int32_t ** Element, int32_t ** Dummy1, int32_t ** Dummy2, char BackToo);
char SearchElementNameByLocation(int32_t locked, int32_t ** Element, int32_t ** Text, int32_t ** Dummy, char BackToo);
char SearchLineByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Line, int32_t ** Dummy);
int32_t SearchObjectByID(int32_t * Base, char ** Result1, char ** Result2, char ** Result3, int32_t ID2, int32_t type);
int32_t SearchObjectByLocation(int32_t Type, char ** Result1, char ** Result2, char ** Result3, int32_t X, int32_t Y, int32_t Radius);
char SearchPadByLocation(int32_t locked, int32_t ** Element, int32_t ** Pad, int32_t ** Dummy, char BackToo);
char SearchPinByLocation(int32_t locked, int32_t ** Element, int32_t ** Pin, int32_t ** Dummy);
char SearchPolygonByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Polygon2, int32_t ** Dummy);
char SearchRatLineByLocation(int32_t locked, int32_t ** Line, int32_t ** Dummy1, int32_t ** Dummy2);
int32_t SearchScreen(int32_t X, int32_t Y, int32_t Type, char ** Result1, char ** Result2, char ** Result3);
char SearchTextByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Text, int32_t ** Dummy);
char SearchViaByLocation(int32_t locked, int32_t ** Via, int32_t ** Dummy1, int32_t ** Dummy2);
void SetArcBoundingBox(int32_t * Arc);
void SetBufferBoundingBox(int32_t * Buffer);
void SetChangedFlag(char New);
void SetCrosshairRange(int32_t MinX, int32_t MinY, int32_t MaxX, int32_t MaxY);
void SetCrosshairRangeToBuffer(void);
void SetElementBoundingBox(int32_t * Data, int32_t * Element, int32_t * Font);
void SetFontInfo(int32_t * Ptr);
void SetKeepawayWidth(uint32_t Width);
void SetLineBoundingBox(int32_t * Line);
void SetLineSize(int32_t Size);
void SetLocalRef(int32_t X, int32_t Y, char Showing);
void SetMode(int32_t Mode);
void SetPadBoundingBox(int32_t * Pad);
void SetPinBoundingBox(int32_t * Pin);
void SetPolygonBoundingBox(int32_t * Polygon2);
void SetPVColor(int32_t * Pin, int32_t Type);
void SetTextBoundingBox(int32_t * FontPtr, int32_t * Text);
void SetViaDrillingHole(uint32_t Size, char Force);
void SetViaSize(int32_t Size, char Force);
void sort_library(int32_t * lib);
int32_t string_to_flags(char * flagstring, int32_t (*error)(char *));
int32_t string_to_pcbflags(char * flagstring, int32_t (*error)(char *));
void u(char * fmt, ...);
char * UniqueElementName(int32_t * Data, char * Name);
void usage(void);
void usage_attr(int32_t * a);
void usage_hid(int32_t * h);
int32_t vendorDrillMap(int32_t in);
char vendorIsElementMappable(int32_t * element);
void WriteElementData(struct _IO_FILE * FP, int32_t * Data);
void WriteLayerData(struct _IO_FILE * FP, int32_t Number, int32_t * layer);
int32_t WritePCB(struct _IO_FILE * FP);
int32_t WritePCBFile(char * Filename);
void WritePCBInfoHeader(struct _IO_FILE * FP);
void WriteViaData(struct _IO_FILE * FP, int32_t * Data);
void XORDrawAttachedArc(int32_t thick);
void XORDrawAttachedLine(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t thick);
void XORDrawElement(int32_t * Element, int32_t DX, int32_t DY);
void XORPolygon(int32_t * polygon, int32_t dx, int32_t dy);
int32_t * yy_create_buffer(struct _IO_FILE * file, int32_t size);
void yy_delete_buffer(int32_t * b);
void yy_fatal_error(char * msg);
void yy_flush_buffer(int32_t * b);
void yy_init_buffer(int32_t * b, struct _IO_FILE * file);
int32_t yylex(void);
int32_t yyparse(void);
void yyrestart(struct _IO_FILE * input_file);
int32_t yywrap(void);

// --------------------- Global Variables ---------------------

int32_t Block = 0; // 0x816b988
int32_t Buffers = 0; // 0x8195780
char Bumped = 0; // 0x81958c0
int32_t Crosshair = 0; // 0x81958e0
char CrosshairStack[16]; // 0x816b874
int32_t CrosshairStackLocation = 0; // 0x816b870
int32_t DestroyFunctions = 0x80c1420; // 0x8167f00
int32_t * DestroyTarget = NULL; // 0x817ced8
char Gathering = 1; // 0x8164470
int32_t ID = 1; // 0x8164410
int32_t InsertedPoint = 0; // 0x816b500
int32_t * Layer = NULL; // 0x817cb74
char LayerFlag[18]; // 0x817cb88
int32_t LayerStack[16]; // 0x8195880
int32_t Library = 0; // 0x8195824
char Locked = 0; // 0x818d040
int32_t Marked = 0; // 0x81958c4
int32_t * Menu = NULL; // 0x817cb84
int32_t Output = 0; // 0x8195840
int32_t * PCB = NULL; // 0x8195834
int32_t * Polygon = NULL; // 0x817cb78
float32_t PosX = 0.0f; // 0x818cf40
float32_t PosY = 0.0f; // 0x818cf44
int32_t Progname = 0; // 0x819580c
int32_t RedoN = 0; // 0x818d054
int32_t * RemoveList = NULL; // 0x818d048
int32_t SavedSerial = 0; // 0x818d04c
int32_t SearchBox = 0; // 0x818cf4c
int32_t * SearchLayer = NULL; // 0x818cf5c
int32_t SearchRadius = 0; // 0x818cf48
int32_t Serial = 1; // 0x81682d0
int32_t Settings = 0; // 0x8194fe0
int32_t * Symbol = NULL; // 0x817cb7c
char TMPFilename[80]; // 0x816c100
int32_t TheFlag = 4; // 0x81660f4
int32_t * UndoList = NULL; // 0x818d044
int32_t UndoMax = 0; // 0x818d058
int32_t UndoN = 0; // 0x818d050
int32_t Xorig = 0; // 0x8195778
int32_t Yorig = 0; // 0x8195810
float64_t Zoom_Multiplier = 0.01; // 0x8164418
int32_t action_action_list = 0x813a183; // 0x8163a00
int32_t addedLines = 0; // 0x8194fc8
int32_t * all_actions = NULL; // 0x818d0a0
int32_t * all_flags = NULL; // 0x818d0c8
int32_t * attr_list = NULL; // 0x817cba0
int32_t backup_timer = 0; // 0x816c150
int32_t bindir = 0; // 0x816c740
int32_t bom_hid = 208; // 0x816a420
int32_t buffers = 0; // 0x818cfe0
int32_t bufptr = 0; // 0x818cfc0
int32_t cached_drill = -1; // 0x8168364
int32_t cached_map = -1; // 0x8168368
int32_t command_action_list = 0x81486b9; // 0x8164300
int32_t command_line_pcb = 0; // 0x816c848
int32_t djopt_action_list = 0x813ee77; // 0x8164440
int32_t djopt_flag_list = 0x813ee6b; // 0x8164420
int32_t do_dump_actions = 0; // 0x816c77c
int32_t doing_pinout = 0; // 0x816b920
char dont_save_any_more = 0; // 0x816c0d8
int32_t empty_flags = 0; // 0x818d030
int32_t eps_attribute_list = 0x815f5ec; // 0x816b3a0
int32_t eps_hid = 208; // 0x816b2c0
int32_t exec_prefix = 0; // 0x816c744
int32_t * exporter = NULL; // 0x818d0d8
int32_t flags_flag_list = 0x814762e; // 0x8166100
int32_t fontmode_action_list = 0x81483b7; // 0x8166460
int32_t gerber_hid = 208; // 0x816a5a0
int32_t ghid_attribute_list = 0x81560fa; // 0x81695a0
int32_t ghid_extents = 208; // 0x8168680
int32_t ghid_hid = 208; // 0x81685a0
int32_t ghid_main_action_list = 0x8152372; // 0x8168760
int32_t ghid_main_flag_list = 0x8152441; // 0x8168940
int32_t ghid_menu_action_list = 0x81556dc; // 0x8169640
int32_t ghid_netlist_action_list = 0x8139f65; // 0x8168cc0
int32_t ghid_port = 0; // 0x8195a80
float64_t * g1 = NULL; // 0x813f1e0
float64_t * g2 = (float64_t *)-0x66699f09; // 0x813f1e8
int32_t g3 = 0x20230073; // 0x814736c
char * g4 = "\t"; // 0x814741a
char * g5; // 0x814741b
char * g6 = "<"; // 0x8148545
int32_t g7 = 0x2d2d007c; // 0x8148547
char * g8 = "p"; // 0x81486bf
char * g9 = "\tTemplate: \x1b[33m%s\x1b[0m\n"; // 0x8149e51
char * g10 = "\tPath: \x1b[33m%s\x1b[0m\n"; // 0x8149e69
char * g11 = "\tFilename: \x1b[33m%s\x1b[0m\n"; // 0x8149e7d
char * g12 = "\tParameter: \x1b[33m%s\x1b[0m\n"; // 0x8149e95
char * g13 = "EvaluateFilename: \x1b[32m%s\x1b[0m\n"; // 0x814a2b8
char * g14; // 0x814aa80
int32_t g15 = 0xb30000; // 0x814ae80
char * g16; // 0x814b000
int32_t g17 = 0; // 0x814b0e0
int32_t g18 = 0x10000; // 0x814b260
int32_t g19 = 0x40000; // 0x814b4a0
int32_t g20 = 0x10000; // 0x814b6e0
int32_t g21 = 0x20001; // 0x814b6e2
int32_t g22 = 0x260000; // 0x814b860
int32_t g23 = -0x1a7fff5; // 0x814bf00
char * g24; // 0x814c3e0
int32_t g25 = 0xc30034; // 0x814c520
int32_t g26 = 0xf0004e; // 0x814c9c0
char * g27; // 0x814ce60
char * g28; // 0x814d0e0
char * g29; // 0x814d1c0
int32_t g30 = -0x1a701a8; // 0x814d2a0
int32_t g31 = 0x2ffff; // 0x814d380
char * g32 = "Action: \x1b[34m%s("; // 0x815012d
char * g33 = ")\x1b[0m\n"; // 0x815013e
int32_t g34 = 0x6370002c; // 0x815ca28
char ** g35 = (char **)0x2f0a002f; // 0x815d1de
int32_t g36 = 0x7573002e; // 0x815d403
int32_t g37 = 0; // 0x81664f8
char g38 = 1; // 0x8167eac
int32_t g39 = 1; // 0x8167eb0
int32_t g40 = 0x100000; // 0x81682d4
char g41 = 0; // 0x8168378
int32_t g42 = 0x80d7780; // 0x81683f4
int32_t ** g43 = NULL; // 0x816b4a0
struct _IO_FILE * g44 = NULL; // 0x816b4a4
struct _IO_FILE * g45 = NULL; // 0x816b4c0
int32_t g46 = 0; // 0x816b504
int32_t g47 = 0; // 0x816b508
int32_t g48 = 0; // 0x816b50c
int32_t g49 = 0; // 0x816b510
char g50 = 0; // 0x816b873
int32_t g51 = 0; // 0x816b940
int32_t g52 = 0; // 0x816b960
int32_t g53 = 0; // 0x816b980
int32_t g54 = 0; // 0x816b98c
int32_t g55 = 0; // 0x816b990
int32_t g56 = 0; // 0x816b994
int32_t g57 = 0; // 0x816c0c8
int32_t g58 = 0; // 0x816c0cc
char * g59; // 0x816c0d0
int32_t g60 = 0; // 0x816c0d4
float64_t g61 = 0.0; // 0x816c718
float64_t g62 = 0.0; // 0x816c71c
char * g63; // 0x816c780
char * g64; // 0x816c880
int32_t g65 = 0; // 0x816c881
char * g66; // 0x816c900
char * g67; // 0x816c960
int32_t g68 = 0; // 0x816ca60
int32_t g69 = 0; // 0x816ca64
int32_t g70 = 0; // 0x816ca68
int32_t g71 = 0; // 0x816ca6c
int32_t g72 = 0; // 0x816ca74
int32_t g73 = 0; // 0x816ca80
char * g74; // 0x816ca84
int32_t g75 = 0; // 0x816ca88
int32_t g76 = 0; // 0x816ca8c
int32_t g77 = 0; // 0x816ca90
int32_t g78 = 0; // 0x816ca94
struct _IO_FILE * g79 = NULL; // 0x816cb28
int32_t g80 = 0; // 0x816cb2c
int32_t g81 = 0; // 0x816cb30
int32_t g82 = 0; // 0x816cb34
char g83 = 0; // 0x816cb38
int32_t g84 = 0; // 0x816cb3c
int32_t g85 = 0; // 0x816cb40
int32_t g86 = 0; // 0x816cb60
int32_t g87 = 0; // 0x816cb64
struct _IO_FILE * g88 = NULL; // 0x817cb68
int32_t g89 = 0; // 0x817cb6c
int32_t g90 = 0; // 0x817cb70
char * g91; // 0x817cb87
int32_t g92 = 0; // 0x817cb89
int32_t g93 = 0; // 0x817cb94
int32_t g94 = 0; // 0x817cbb0
int32_t g95 = 0; // 0x817cbc4
int32_t g96 = 0; // 0x818cf50
int32_t g97 = 0; // 0x818cf54
int32_t g98 = 0; // 0x818cf58
int32_t g99 = 0; // 0x818cf60
int32_t g100 = 0; // 0x818cf64
float64_t g101 = 0.0; // 0x818cf68
float64_t g102 = 0.0; // 0x818cf6c
char g103 = 0; // 0x818cf70
int32_t g104 = 0; // 0x818cf90
int32_t g105 = 0; // 0x818cf94
int32_t g106 = 0; // 0x818cf98
int32_t g107 = 0; // 0x818cf9c
int32_t g108 = 0; // 0x818cfd0
char * g109; // 0x818cfd4
int32_t g110 = 0; // 0x818cfe4
int32_t g111 = 0; // 0x818d034
int32_t g112 = 0; // 0x818d038
int32_t g113 = 0; // 0x818d0c0
char * g114; // 0x818d0c4
int32_t g115 = 0; // 0x8194fe4
int32_t g116 = 0; // 0x8194ffc
int32_t g117 = 0; // 0x8195000
int32_t g118 = 0; // 0x8195004
int32_t g119 = 0; // 0x8195008
int32_t g120 = 0; // 0x819500c
int32_t g121 = 0; // 0x8195010
int32_t g122 = 0; // 0x8195014
int32_t g123 = 0; // 0x8195018
int32_t g124 = 0; // 0x819501c
int32_t g125 = 0; // 0x8195020
int32_t g126 = 0; // 0x8195024
int32_t g127 = 0; // 0x8195028
char * g128; // 0x8195030
int32_t g129 = 0; // 0x8195034
int32_t g130 = 0; // 0x8195070
int32_t g131 = 0; // 0x8195074
int32_t g132 = 0; // 0x81950b4
int32_t g133 = 0; // 0x81950b8
int32_t g134 = 0; // 0x81950bc
char * g135; // 0x81950c0
int32_t g136 = 0; // 0x81950c4
int32_t g137 = 0; // 0x81950c8
int32_t g138 = 0; // 0x81950cc
int32_t g139 = 0; // 0x81950d0
float64_t g140 = 0.0; // 0x81950d4
int32_t g141 = 0; // 0x81950e0
char * g142; // 0x81950e4
char * g143; // 0x81950e8
char * g144; // 0x81950ec
int64_t g145 = 0; // 0x81950f0
char * g146; // 0x81950f4
float64_t g147 = 0.0; // 0x8195148
int32_t g148 = 0; // 0x8195164
int64_t g149 = 0; // 0x8195168
int32_t g150 = 0; // 0x8195170
int32_t g151 = 0; // 0x8195174
int32_t g152 = 0; // 0x81951c4
char * g153; // 0x81951c8
char * g154; // 0x81951cc
char * g155; // 0x81951d0
char * g156; // 0x81951d8
char * g157; // 0x81951dc
int32_t g158 = 0; // 0x81951e0
int32_t g159 = 0; // 0x81951e4
char * g160; // 0x81951f4
char * g161; // 0x8195200
char * g162; // 0x8195214
char * g163; // 0x8195218
char * g164; // 0x8195220
int32_t g165 = 0; // 0x8195230
int32_t g166 = 0; // 0x8195234
int32_t g167 = 0; // 0x8195238
int32_t g168 = 0; // 0x819523c
int32_t g169 = 0; // 0x8195240
int32_t g170 = 0; // 0x8195244
int32_t g171 = 0; // 0x8195248
char * g172; // 0x8195298
char g173 = 0; // 0x8195758
char g174 = 0; // 0x8195759
char g175 = 0; // 0x819575a
char g176 = 0; // 0x819575b
char g177 = 0; // 0x819575c
char g178 = 0; // 0x819575f
char g179 = 0; // 0x8195762
char g180 = 0; // 0x8195763
char g181 = 0; // 0x8195764
char g182 = 0; // 0x8195765
char g183 = 0; // 0x8195766
char g184 = 0; // 0x8195767
char g185 = 0; // 0x8195768
char g186 = 0; // 0x819576a
int32_t g187 = 0; // 0x8195774
int32_t g188 = 0; // 0x8195798
int32_t g189 = 0; // 0x81957b4
int32_t g190 = 0; // 0x81957d0
int32_t g191 = 0; // 0x81957ec
int32_t g192 = 0; // 0x8195808
char g193 = 0; // 0x8195839
char * g194; // 0x8195844
char * g195; // 0x8195848
char * g196; // 0x819584c
char * g197; // 0x8195850
int64_t g198 = 0; // 0x8195854
char g199 = 0; // 0x8195855
int32_t g200 = 0; // 0x8195856
int32_t g201 = 0; // 0x8195857
int32_t g202 = 0; // 0x8195858
int32_t g203 = 0; // 0x8195859
int32_t g204 = 0; // 0x819585a
char g205 = 0; // 0x819585b
char g206 = 0; // 0x819585c
int32_t g207 = 0; // 0x8195898
int32_t g208 = 0; // 0x819589c
int32_t g209 = 0; // 0x81958a0
int32_t g210 = 0; // 0x81958a4
char * g211; // 0x81958a8
char * g212; // 0x81958ac
char * g213; // 0x81958b0
int64_t g214 = 0; // 0x81958b4
char * g215; // 0x81958b8
int32_t g216 = 0; // 0x81958bc
float64_t g217 = 0.0; // 0x81958c8
float64_t g218 = 0.0; // 0x81958cc
float64_t g219 = 0.0; // 0x81958d4
float64_t g220 = 0.0; // 0x81958dc
float64_t g221 = 0.0; // 0x81958e4
float64_t g222 = 0.0; // 0x81958e8
float64_t g223 = 0.0; // 0x81958ec
int32_t g224 = 0; // 0x81958f0
int32_t g225 = 0; // 0x81958f4
int32_t g226 = 0; // 0x81958f8
float64_t g227 = 0.0; // 0x81958fc
char g228 = 0; // 0x8195900
char * g229; // 0x8195904
float64_t g230 = 0.0; // 0x8195908
char * g231; // 0x8195918
float64_t g232 = 0.0; // 0x819591c
int32_t g233 = 0; // 0x819592c
char g234 = 0; // 0x8195930
char * g235; // 0x8195934
float64_t g236 = 0.0; // 0x8195938
char * g237; // 0x8195948
float64_t g238 = 0.0; // 0x819594c
int32_t g239 = 0; // 0x819595c
char g240 = 0; // 0x8195960
int32_t g241 = 0; // 0x8195988
int32_t g242 = 0; // 0x81959a4
int32_t g243 = 0; // 0x81959b8
int32_t g244 = 0; // 0x81959bc
char * g245; // 0x81959c0
int32_t g246 = 0; // 0x81959c4
float64_t g247 = 0.0; // 0x81959c8
int32_t g248 = 0; // 0x81959cc
char * g249; // 0x81959d4
int32_t g250 = 0; // 0x81959d8
int32_t g251 = 0; // 0x8195a30
int32_t g252 = 0; // 0x8195a34
int32_t g253 = 0; // 0x8195a70
int32_t g254 = 0; // 0x8195a74
int32_t g255 = 0; // 0x8195a7c
int32_t g256 = 0; // 0x8195a84
int32_t g257 = 0; // 0x8195a88
int32_t g258 = 0; // 0x8195a8c
int32_t g259 = 0; // 0x8195a90
int32_t g260 = 0; // 0x8195a94
int32_t g261 = 0; // 0x8195a98
int32_t g262 = 0; // 0x8195a9c
int32_t g263 = 0; // 0x8195aa0
int32_t g264 = 0; // 0x8195aa4
int32_t g265 = 0; // 0x8195aac
int32_t g266 = 0; // 0x8195ab4
int32_t g267 = 0; // 0x8195abc
int32_t g268 = 0; // 0x8195ac4
int32_t g269 = 0; // 0x8195af4
int32_t g270 = 0; // 0x8195af8
int32_t g271 = 0; // 0x8195b3c
int32_t gtk_topwindow_action_list = 0x813e434; // 0x8169600
int32_t * gui = (int32_t *)0x8168380; // 0x816836c
int32_t hid_action_context = 0; // 0x818d09c
int32_t * hid_action_nodes = NULL; // 0x818d098
int32_t * hid_attr_nodes = NULL; // 0x818d0dc
int32_t * hid_flag_nodes = NULL; // 0x818d0a8
int32_t ** hid_list = NULL; // 0x818d0d0
int32_t hid_nogui = 208; // 0x8168380
int32_t hid_num_hids = 0; // 0x818d0d4
int32_t homedir = 0; // 0x816c758
char ** ignore_descr = NULL; // 0x818d074
char ** ignore_refdes = NULL; // 0x818d064
char ** ignore_value = NULL; // 0x818d06c
char inhibit = 0; // 0x817cba4
int32_t layer_group_string = 0; // 0x817cb9c
int32_t layers = 0; // 0x818cfc4
int32_t lpr_hid = 208; // 0x816a300
int32_t main_attribute_list = 0x814873e; // 0x81664e0
int32_t max_layers = 0; // 0x818cfc8
int32_t move_action_list = 0x814a3e0; // 0x8167de0
int32_t n_actions = 0; // 0x818d0a4
int32_t n_descr = 0; // 0x818d078
int32_t n_flags = 0; // 0x818d0cc
int32_t n_refdes = 0; // 0x818d068
int32_t n_value = 0; // 0x818d070
int32_t n_vendor_drills = 0; // 0x818d07c
int32_t nelma_attribute_list = 0x815d391; // 0x816a720
int32_t nelma_hid = 208; // 0x816a820
int32_t netlist_action_list = 0x8154952; // 0x8167e80
int32_t netlist_sort_offset = 0; // 0x816c0c4
int32_t num_layers = 0; // 0x818cfcc
int32_t object_flagbits = 1; // 0x8168160
int32_t * pcb_dbus_conn = NULL; // 0x818d938
int32_t pcb_flagbits = 1; // 0x8168000
int32_t pcblibdir = 0; // 0x816c748
int32_t pcblibpath = 0; // 0x816c74c
int32_t pcbmenu_attr = 0x815615e; // 0x8169680
int32_t pcbtreedir = 0; // 0x816c750
int32_t pcbtreepath = 0; // 0x816c754
int32_t pin_num = 0; // 0x817cb80
int32_t pixel_slop = 1; // 0x8168370
int32_t png_attribute_list = 0x815d8ef; // 0x816a920
int32_t png_hid = 208; // 0x816ac60
int32_t program_basename = 0; // 0x816c760
int32_t program_directory = 0; // 0x816c764
int32_t program_name = 0; // 0x816c75c
int32_t ps_attribute_list = 0x815ea08; // 0x816ad60
int32_t ps_hid = 208; // 0x816b100
int32_t puller_action_list = 0x814d844; // 0x8167ec0
char render = 0; // 0x81959ec
int32_t report_action_list = 0x814e04d; // 0x8167f80
int32_t rotate_action_list = 0x813e1db; // 0x8163ea0
int32_t rounding_method = 0; // 0x818d084
int32_t show_actions = 0; // 0x816c778
int32_t show_copyright = 0; // 0x816c770
int32_t show_defaults = 0; // 0x816c774
int32_t show_help = 0; // 0x816c768
int32_t show_version = 0; // 0x816c76c
int32_t toporouter_action_list = 0x813a463; // 0x8168540
int32_t g272;
int32_t g273;
uint32_t g274;
int32_t g275;
int32_t g276;
int32_t g277;
int32_t g278;
int32_t g279;
char vendorMapEnable = 0; // 0x818d060
int32_t vendor_action_list = 0x814fece; // 0x81682e0
int32_t * vendor_drills = NULL; // 0x818d080
int32_t vendor_flag_list = 0x814ff1e; // 0x8168358
int32_t vyl = 0; // 0x8195838
int32_t * yyData = NULL; // 0x8195a20
int32_t * yyElement = NULL; // 0x8195a1c
int32_t * yyFont = NULL; // 0x8195a18
int32_t * yyPCB = NULL; // 0x8195a0c
int32_t yychar = 0; // 0x8195a28
int32_t yyfilename = 0; // 0x8195a24
int32_t * yyin = NULL; // 0x816cb20
int32_t yyleng = 0; // 0x8195a10
int32_t yylineno = 1; // 0x8167ea8
int32_t yylval = 0; // 0x8195a2c
int32_t yynerrs = 0; // 0x8195a38
int32_t * yyout = NULL; // 0x816cb24
int32_t yytext = 0; // 0x8195a14

// ------------------------ Functions -------------------------

// Address range: 0x805e978 - 0x805e97e
int32_t function_805e978(int32_t a1) {
    // 0x805e978
    return dbus_connection_unref();
}

// Address range: 0x805ecf8 - 0x805ecfe
int32_t function_805ecf8(void) {
    // 0x805ecf8
    return dbus_shutdown();
}

// Address range: 0x805edd8 - 0x805edde
int32_t function_805edd8(int32_t * a1) {
    // 0x805edd8
    return dbus_error_init();
}

// Address range: 0x805ef38 - 0x805ef3e
int32_t function_805ef38(int32_t a1, char * a2, int32_t * a3) {
    // 0x805ef38
    return dbus_bus_release_name();
}

// Address range: 0x805efc8 - 0x805efce
int32_t function_805efc8(int32_t a1, int32_t * a2) {
    // 0x805efc8
    return dbus_bus_get_private();
}

// Address range: 0x805eff8 - 0x805effe
int32_t function_805eff8(int32_t * a1) {
    // 0x805eff8
    return dbus_error_is_set();
}

// Address range: 0x805f098 - 0x805f09e
int32_t function_805f098(int32_t a1) {
    // 0x805f098
    return dbus_connection_flush();
}

// Address range: 0x805f2b8 - 0x805f2be
int32_t function_805f2b8(int32_t a1, char * a2, int32_t a3, int32_t * a4) {
    // 0x805f2b8
    return dbus_bus_request_name();
}

// Address range: 0x805f448 - 0x805f44e
int32_t function_805f448(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x805f448
    return dbus_connection_set_dispatch_status_function();
}

// Address range: 0x805fc48 - 0x805fc4e
int32_t function_805fc48(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x805fc48
    return dbus_connection_set_watch_functions();
}

// Address range: 0x805fcf8 - 0x805fcfe
int32_t function_805fcf8(int32_t a1, char * a2, int32_t * a3, int32_t a4) {
    // 0x805fcf8
    return dbus_connection_register_object_path();
}

// Address range: 0x80600e8 - 0x80600ee
int32_t function_80600e8(int32_t a1) {
    // 0x80600e8
    return dbus_connection_close();
}

// Address range: 0x8060118 - 0x806011e
int32_t function_8060118(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x8060118
    return dbus_connection_set_timeout_functions();
}

// Address range: 0x8060718 - 0x806071e
int32_t function_8060718(int32_t * a1) {
    // 0x8060718
    return dbus_error_free();
}

// Address range: 0x80607f8 - 0x80607fe
int32_t function_80607f8(int32_t a1, char * a2, int32_t * a3, float80_t a4) {
    // 0x80607f8
    return sscanf2();
}

// Address range: 0x8060908 - 0x806090e
int32_t function_8060908(int32_t a1, char * a2) {
    // 0x8060908
    return dbus_connection_unregister_object_path();
}

// Address range: 0x8060d88 - 0x8060d8e
int32_t function_8060d88(float80_t a1) {
    // 0x8060d88
    return sincos();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/action.c
// Address range: 0x8067930 - 0x806794c
// Line range:    6974 - 6974
void register_action_action_list(void) {
    // 0x8067930
    hid_register_actions(&action_action_list, 58);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/action.c
// Address range: 0x8067c50 - 0x8067d3f
// Line range:    811 - 852
void AdjustAttachedObjects(void) {
    // 0x8067c50
    if (g148 == 4) {
        // 0x8067cd2
        AdjustAttachedLine();
        return;
    }
    if (g148 > 4) {
        switch (g148) {
            case 109: {
                // 0x8067d30
                g240 = (int32_t)gui;
                return;
            }
            case 110: {
                goto lab_0x8067c9a;
            }
            case 106: {
                int32_t * v1 = AdjustInsertPoint(); // 0x8067ce8
                if (v1 == NULL) {
                    // 0x8067c77
                    return;
                }
                int32_t v2 = (int32_t)v1; // 0x8067ce8
                InsertedPoint = *v1;
                g46 = *(int32_t *)(v2 + 4);
                g47 = *(int32_t *)(v2 + 8);
                g48 = *(int32_t *)(v2 + 12);
                g49 = *(int32_t *)(v2 + 16);
                return;
            }
            default: {
                return;
            }
        }
    } else {
        if (g148 == 2) {
            // 0x8067cc0
            if (g206 != 0) {
                // 0x8067cd2
                AdjustAttachedLine();
                return;
            }
            // 0x8067ccb
            if (g209 != 0) {
                // 0x8067d20
                AdjustTwoLine(g209 - 1);
                return;
            }
            // 0x8067cd2
            AdjustAttachedLine();
            return;
        }
        if (g148 > 2) {
            // 0x8067cdd
            if (g239 != 1) {
                // 0x8067c77
                return;
            }
            // 0x8067ca4
            g237 = (char *)(int32_t)(float32_t)g222;
            g238 = g223;
            return;
        }
        if (g148 != 0) {
            // 0x8067c77
            return;
        }
        goto lab_0x8067c9a;
    }
  lab_0x8067c9a:
    // 0x8067c9a
    if (g239 == 0) {
        // 0x8067c77
        return;
    }
    // 0x8067ca4
    g237 = (char *)(int32_t)(float32_t)g222;
    g238 = g223;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/buffer.c
// Address range: 0x8075460 - 0x807547c
// Line range:    1375 - 1375
void register_rotate_action_list(void) {
    // 0x8075460
    hid_register_actions(&rotate_action_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/buffer.c
// Address range: 0x8076d00 - 0x8076d3a
// Line range:    1138 - 1144
void InitBuffers(void) {
    // 0x8076d00
    g188 = (int32_t)CreateNewBuffer();
    g189 = (int32_t)CreateNewBuffer();
    g190 = (int32_t)CreateNewBuffer();
    g191 = (int32_t)CreateNewBuffer();
    g192 = (int32_t)CreateNewBuffer();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/buffer.c
// Address range: 0x8077820 - 0x8077856
// Line range:    493 - 499
void SetBufferBoundingBox(int32_t * Buffer) {
    int32_t v1 = (int32_t)Buffer;
    int32_t * v2 = GetDataBoundingBox((int32_t *)*(int32_t *)(v1 + 24)); // 0x8077830
    if (v2 != NULL) {
        int32_t v3 = (int32_t)v2; // 0x8077830
        *(int32_t *)(v1 + 8) = *v2;
        *(int32_t *)(v1 + 12) = *(int32_t *)(v3 + 4);
        *(int32_t *)(v1 + 16) = *(int32_t *)(v3 + 8);
        *(int32_t *)(v1 + 20) = *(int32_t *)(v3 + 12);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/change.c
// Address range: 0x8079900 - 0x80799b4
// Line range:    2263 - 2272
void ChangePCBSize(int32_t Width, int32_t Height) {
    // 0x8079900
    Marked = Width;
    g217 = (int64_t)Height;
    if (g148 == 5) {
        int32_t v1 = 28 * (int32_t)g149; // 0x8079968
        int32_t v2 = *(int32_t *)(v1 + (int32_t)&Buffers); // 0x8079975
        int32_t v3 = *(int32_t *)(v1 + (int32_t)&Buffers + 4); // 0x807997b
        int32_t v4 = v3 - *(int32_t *)(v1 + (int32_t)&Buffers + 20) + Height; // 0x8079988
        int32_t v5 = v2 - *(int32_t *)(v1 + (int32_t)&Buffers + 16) + Width; // 0x8079997
        int32_t v6 = *(int32_t *)(v1 + (int32_t)&Buffers + 12); // 0x80799a0
        int32_t v7 = *(int32_t *)(v1 + (int32_t)&Buffers + 8); // 0x80799a7
        SetCrosshairRange(v2 - v7, v3 - v6, v5 > 0 ? v5 : 0, v4 > 0 ? v4 : 0);
    } else {
        // 0x8079930
        SetCrosshairRange(0, 0, Width, Height);
    }
    // 0x807994c
    hid_action("PCBChanged");
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/command.c
// Address range: 0x807db80 - 0x807db9c
// Line range:    417 - 417
void register_command_action_list(void) {
    // 0x807db80
    hid_register_actions(&command_action_list, 10);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ea50 - 0x807eb76
// Line range:    93 - 120
void pcb_colors_from_settings(int32_t * ptr) {
    int32_t v1 = (int32_t)ptr;
    *(int32_t *)(v1 + 88) = g127;
    *(int32_t *)(v1 + 64) = g121;
    *(int32_t *)(v1 + 68) = g122;
    *(int32_t *)(v1 + 72) = g123;
    *(int32_t *)(v1 + 76) = g124;
    *(int32_t *)(v1 + 80) = g125;
    *(int32_t *)(v1 + 84) = g126;
    *(int32_t *)(v1 + 52) = g118;
    *(int32_t *)(v1 + 56) = g119;
    *(int32_t *)(v1 + 60) = g120;
    *(int32_t *)(v1 + 44) = g116;
    *(int32_t *)(v1 + 48) = g117;
    *(int32_t *)(v1 + 92) = g132;
    *(int32_t *)(v1 + 96) = g133;
    int32_t v2 = *(int32_t *)(v1 + 0x220c); // 0x807eadd
    int32_t v3 = v2 + 148;
    int32_t v4 = v2 + 152;
    int32_t v5 = 0; // 0x807eae7
    int32_t v6 = 0; // 0x807eae7
    int32_t v7 = 4 * v5; // 0x807eae8
    int32_t v8 = *(int32_t *)(v7 + (int32_t)&g129); // 0x807eae8
    *(int32_t *)(v6 + v3) = v8;
    int32_t v9 = *(int32_t *)(v7 + (int32_t)&g131); // 0x807eaf6
    v5++;
    *(int32_t *)(v6 + v4) = v9;
    v6 += 92;
    while (v5 != 16) {
        // 0x807eae8
        v7 = 4 * v5;
        v8 = *(int32_t *)(v7 + (int32_t)&g129);
        *(int32_t *)(v6 + v3) = v8;
        v9 = *(int32_t *)(v7 + (int32_t)&g131);
        v5++;
        *(int32_t *)(v6 + v4) = v9;
        v6 += 92;
    }
    int32_t * v10 = (int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x807eb1a
    int32_t v11 = 92 * *v10;
    int32_t v12 = v11 + v2;
    int32_t * v13 = (int32_t *)(v12 + 240);
    int32_t v14; // 0x807ea50
    if (g177 == 0) {
        // 0x807eb60
        *v13 = g121;
        *(int32_t *)(v12 + 244) = g125;
        v14 = g123;
    } else {
        // 0x807eb2c
        *v13 = g123;
        *(int32_t *)(v12 + 244) = g125;
        v14 = g121;
    }
    // 0x807eb40
    *(int32_t *)(v11 + v3) = v14;
    *(int32_t *)(92 * *v10 + v4) = g125;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807eb80 - 0x807ec19
// Line range:    981 - 986
int32_t * CreateNewAttribute(int32_t * list, char * name, char * value) {
    int32_t v1 = (int32_t)list;
    int32_t v2 = *list; // 0x807eb92
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x807eb94
    int32_t v4 = *v3; // 0x807eb94
    char * v5; // 0x807eb80
    int32_t * v6; // 0x807eb80
    int32_t v7; // 0x807eb80
    int32_t v8; // 0x807eb80
    if (v2 < v4) {
        int32_t * v9 = (int32_t *)(v1 + 8);
        v6 = v9;
        v5 = name;
        v8 = v2;
        v7 = *v9;
    } else {
        int32_t v10 = v4 + 10; // 0x807ebf0
        *v3 = v10;
        int32_t * v11 = (int32_t *)(v1 + 8);
        int32_t v12 = (int32_t)MyRealloc((char *)*v11, 8 * v10, "CreateNewAttribute"); // 0x807ec0b
        *v11 = v12;
        v6 = v11;
        v5 = name;
        v8 = *list;
        v7 = v12;
    }
    char * v13 = MyStrdup(v5, "CreateNewAttribute"); // 0x807ebac
    *(int32_t *)(v7 + 8 * v8) = (int32_t)v13;
    char * v14 = MyStrdup(value, "CreateNewAttribute"); // 0x807ebca
    *(int32_t *)((8 * *list | 4) + *v6) = (int32_t)v14;
    int32_t v15 = *list; // 0x807ebd2
    *list = v15 + 1;
    return (int32_t *)(*v6 + 8 * v15);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ec20 - 0x807ec51
// Line range:    969 - 975
int32_t * CreateNewConnection(int32_t * net, char * conn) {
    int32_t * result = GetLibraryEntryMemory(net); // 0x807ec2d
    *result = (int32_t)MyStrdup(conn, "CreateNewConnection()");
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ec60 - 0x807ed30
// Line range:    949 - 963
int32_t * CreateNewNet(int32_t * lib, char * name, char * style) {
    int32_t v1 = __readgsdword(20); // 0x807ec69
    int32_t v2; // bp-96, 0x807ec60
    __sprintf_chk((char *)&v2, 1, 64, "  %s", name);
    int32_t * result = GetLibraryMenuMemory(lib); // 0x807ecb3
    int32_t v3 = (int32_t)result; // 0x807ecb3
    char * v4 = MyStrdup((char *)&v2, "CreateNewNet()"); // 0x807ecc5
    *(char *)(v3 + 24) = 1;
    *result = (int32_t)v4;
    if (style != NULL) {
        // 0x807ecd7
        bool v5; // 0x807ec60
        int32_t v6 = v5 ? -1 : 1; // 0x807ece3
        int32_t v7 = (int32_t)style; // 0x807ec60
        int32_t v8 = (int32_t)"(unknown)"; // 0x807ec60
        int32_t v9 = 10; // 0x807ece3
        while (*(char *)v8 == *(char *)v7) {
            v9--;
            v7 += v6;
            v8 += v6;
            if (v9 == 0) {
                // 0x807ed18
                *(int32_t *)(v3 + 8) = 0;
                goto lab_0x807ecfa;
            }
        }
    }
    // 0x807ece7
    *(int32_t *)(v3 + 8) = (int32_t)MyStrdup(style, "CreateNewNet()");
    goto lab_0x807ecfa;
  lab_0x807ecfa:
    // 0x807ecfa
    if (v1 == __readgsdword(20)) {
        // 0x807ed08
        return result;
    }
    // 0x807ed21
    __stack_chk_fail();
    return &g279;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ed60 - 0x807ed9f
// Line range:    920 - 924
void CreateDefaultFont(void) {
    int32_t v1 = ParseFont((int32_t *)(int32_t)(float32_t)(float64_t)(int64_t)(int32_t)&g223, g157); // 0x807ed7c
    if (v1 == 0) {
        // 0x807ed85
        return;
    }
    // 0x807ed88
    Message((char *)(int32_t)(float32_t)(float64_t)(int64_t)(int32_t)"Can't find font-symbol-file '%s'\n", g157);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807eda0 - 0x807ee94
// Line range:    888 - 86
int32_t * CreateNewLineInSymbol(int32_t * Symbol2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness) {
    int32_t v1 = (int32_t)Symbol2;
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x807edb2
    uint32_t v3 = *v2; // 0x807edb2
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x807edb5
    uint32_t v5 = *v4; // 0x807edb5
    int32_t v6 = *Symbol2; // 0x807edb8
    int32_t v7 = v3; // 0x807edbc
    int32_t v8 = v6; // 0x807edbc
    int32_t v9; // 0x807eda0
    int32_t v10; // 0x807ee15
    if (v3 >= v5) {
        int32_t v11 = v5 + 10; // 0x807edf8
        *v4 = v11;
        v10 = (int32_t)MyRealloc((char *)v6, 88 * v11, "CreateNewLineInSymbol()");
        int32_t v12 = 88 * *v2 + v10; // 0x807ee1e
        *Symbol2 = v10;
        int32_t v13 = 880; // 0x807ee2b
        int32_t v14 = v12; // 0x807ee2b
        if (v12 % 2 != 0) {
            // 0x807ee88
            *(char *)v12 = 0;
            v13 = 879;
            v14 = v12 + 1;
        }
        int32_t v15 = v13; // 0x807ee33
        int32_t v16 = v14; // 0x807ee33
        if ((v14 & 2) != 0) {
            // 0x807ee78
            *(int16_t *)v14 = 0;
            v15 = v13 - 2;
            v16 = v14 + 2;
        }
        uint32_t v17 = v15 / 4; // 0x807ee39
        __asm_rep_stosd_memset((char *)v16, 0, v17);
        bool v18; // 0x807eda0
        int32_t v19 = v17 * (v18 ? -4 : 4) + v16; // 0x807ee42
        if ((v15 & 2) != 0) {
            // 0x807ee68
            *(int16_t *)v19 = 0;
            v9 = v19 + 2;
            if (v15 % 2 == 0) {
                goto lab_0x807ee4b;
            } else {
                goto lab_0x807ee58;
            }
        } else {
            // 0x807ee46
            v9 = v19;
            if (v15 % 2 != 0) {
                goto lab_0x807ee58;
            } else {
                goto lab_0x807ee4b;
            }
        }
    } else {
        goto lab_0x807edbe;
    }
  lab_0x807edbe:
    // 0x807edbe
    *v2 = v7 + 1;
    int32_t v20 = v8 + 88 * v7; // 0x807edc7
    *(int32_t *)(v20 + 44) = X1;
    *(int32_t *)(v20 + 48) = Y1;
    *(int32_t *)(v20 + 64) = X2;
    *(int32_t *)(v20 + 68) = Y2;
    *(int32_t *)(v20 + 36) = Thickness;
    return (int32_t *)v20;
  lab_0x807ee4b:
    // 0x807ee4b
    v7 = *v2;
    v8 = v10;
    goto lab_0x807edbe;
  lab_0x807ee58:
    // 0x807ee58
    *(char *)v9 = 0;
    v7 = *v2;
    v8 = v10;
    goto lab_0x807edbe;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807eea0 - 0x807f042
// Line range:    671 - 86
int32_t * CreateNewArcInElement(int32_t * Element, int32_t X, int32_t Y, int32_t Width, int32_t Height, int32_t Angle, int32_t Delta, int32_t Thickness) {
    int32_t v1 = (int32_t)Element;
    int32_t * v2 = (int32_t *)(v1 + 268); // 0x807eeac
    int32_t * v3 = (int32_t *)(v1 + 248); // 0x807eeb2
    uint32_t v4 = *v3; // 0x807eeb2
    char * v5 = (char *)*v2; // bp-32, 0x807eeb8
    int32_t * v6 = (int32_t *)(v1 + 252); // 0x807eebb
    uint32_t v7 = *v6; // 0x807eebb
    int32_t v8 = v4; // 0x807eec3
    int32_t v9; // 0x807eea0
    if (v4 >= v7) {
        int32_t v10 = v7 + 5; // 0x807ef90
        *v6 = v10;
        char * v11 = MyRealloc(v5, 68 * v10, "CreateNewArcInElement()"); // 0x807efb3
        int32_t v12 = (int32_t)v11; // 0x807efb3
        v5 = v11;
        *v2 = v12;
        int32_t v13 = 68 * *v3 + v12; // 0x807efd4
        int32_t v14 = 340; // 0x807efdd
        int32_t v15 = v13; // 0x807efdd
        if (v13 % 2 != 0) {
            // 0x807f038
            *(char *)v13 = 0;
            v14 = 339;
            v15 = v13 + 1;
        }
        int32_t v16 = v14; // 0x807efe5
        int32_t v17 = v15; // 0x807efe5
        if ((v15 & 2) != 0) {
            // 0x807f028
            *(int16_t *)v15 = 0;
            v16 = v14 - 2;
            v17 = v15 + 2;
        }
        uint32_t v18 = v16 / 4; // 0x807efeb
        __asm_rep_stosd_memset((char *)v17, 0, v18);
        bool v19; // 0x807eea0
        int32_t v20 = v18 * (v19 ? -4 : 4) + v17; // 0x807eff1
        if ((v16 & 2) != 0) {
            // 0x807f018
            *(int16_t *)v20 = 0;
            v9 = v20 + 2;
            if (v16 % 2 == 0) {
                // 0x807effa
                v8 = *v3;
                goto lab_0x807eec9;
            } else {
                goto lab_0x807f008;
            }
        } else {
            // 0x807eff5
            v9 = v20;
            if (v16 % 2 != 0) {
                goto lab_0x807f008;
            } else {
                // 0x807effa
                v8 = *v3;
                goto lab_0x807eec9;
            }
        }
    } else {
        goto lab_0x807eec9;
    }
  lab_0x807eec9:;
    int32_t v21 = -360 * Delta / 94 + Delta; // 0x807eeed
    int32_t v22; // 0x807eea0
    int32_t v23; // 0x807eea0
    if (v21 != 0) {
        // 0x807ef80
        v23 = Angle;
        v22 = v21;
        if (v21 < 0) {
            // 0x807ef86
            v23 = v21 + Angle;
            v22 = -v21;
        }
    } else {
        // 0x807eefa
        v23 = Angle;
        v22 = v21 & -0x10000 | 360;
    }
    int32_t v24 = v23;
    int32_t v25 = -360 * ((v24 + (int32_t)(-0x49f49f49 * (int64_t)v24 / 0x100000000) >> 8) - (v24 >> 31)) + v24; // 0x807ef1f
    *v3 = v8 + 1;
    int32_t v26 = 68 * v8 + (int32_t)v5; // 0x807ef3f
    *(int32_t *)(v26 + 52) = X;
    *(int32_t *)(v26 + 60) = v25 >= 0 ? v25 : v25 + 360;
    *(int32_t *)(v26 + 64) = v22;
    *(int32_t *)(v26 + 56) = Y;
    *(int32_t *)(v26 + 44) = Width;
    *(int32_t *)(v26 + 36) = Thickness;
    *(int32_t *)(v26 + 48) = Height;
    *(int32_t *)(v26 + 16) = ID;
    ID++;
    return (int32_t *)v26;
  lab_0x807f008:
    // 0x807f008
    *(char *)v9 = 0;
    v8 = *v3;
    goto lab_0x807eec9;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f050 - 0x807f183
// Line range:    827 - 859
int32_t * CreateNewPad(int32_t * Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Mask, char * Name, char * Number, int32_t Flags) {
    int32_t * result = GetPadMemory(Element); // 0x807f097
    int32_t v1 = (int32_t)result; // 0x807f097
    if (X1 > X2) {
        goto lab_0x807f0d0;
    } else {
        if (Y1 <= Y2 || X1 != X2) {
            // 0x807f0ae
            *(int32_t *)(v1 + 44) = X1;
            *(int32_t *)(v1 + 48) = Y1;
            *(int32_t *)(v1 + 64) = X2;
            *(int32_t *)(v1 + 68) = Y2;
            goto lab_0x807f0e8;
        } else {
            goto lab_0x807f0d0;
        }
    }
  lab_0x807f0d0:
    // 0x807f0d0
    *(int32_t *)(v1 + 44) = X2;
    *(int32_t *)(v1 + 48) = Y2;
    *(int32_t *)(v1 + 64) = X1;
    *(int32_t *)(v1 + 68) = Y1;
    goto lab_0x807f0e8;
  lab_0x807f0e8:
    // 0x807f0e8
    *(int32_t *)(v1 + 36) = Thickness;
    *(int32_t *)(v1 + 40) = Clearance;
    *(int32_t *)(v1 + 84) = Mask;
    *(int32_t *)(v1 + 88) = (int32_t)MyStrdup(Name, "CreateNewPad()");
    *(int32_t *)(v1 + 92) = (int32_t)MyStrdup(Number, "CreateNewPad()");
    *(int32_t *)(v1 + 20) = Flags & -513;
    *(int32_t *)(v1 + 16) = ID;
    ID++;
    *(int32_t *)(v1 + 96) = (int32_t)Element;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f190 - 0x807f46e
// Line range:    751 - 821
int32_t * CreateNewPin(int32_t * Element, int32_t X, int32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, char * Number, int32_t Flags) {
    int32_t * result = GetPinMemory(Element); // 0x807f1e0
    int32_t v1 = (int32_t)result; // 0x807f1e0
    *(int32_t *)(v1 + 52) = X;
    *(int32_t *)(v1 + 56) = Y;
    int32_t * v2 = (int32_t *)(v1 + 36); // 0x807f1f6
    *v2 = Thickness;
    *(int32_t *)(v1 + 40) = Clearance;
    *(int32_t *)(v1 + 44) = Mask;
    *(int32_t *)(v1 + 60) = (int32_t)MyStrdup(Name, "CreateNewPin()");
    char * v3 = MyStrdup(Number, "CreateNewPin()"); // 0x807f229
    *(int32_t *)(v1 + 68) = (int32_t)Element;
    *(int32_t *)(v1 + 64) = (int32_t)v3;
    int32_t v4 = v1 + 20; // 0x807f275
    *(int32_t *)v4 = Flags & -514 | 1;
    *(int32_t *)(v1 + 16) = ID;
    ID++;
    int32_t v5 = vendorDrillMap(DrillingHole); // 0x807f28b
    int32_t * v6 = (int32_t *)(v1 + 48); // 0x807f290
    *v6 = v5;
    if (vendorIsElementMappable(Element) == 0) {
        // 0x807f310
        *v6 = DrillingHole;
        // 0x807f313
        return result;
    }
    int32_t v7 = (int32_t)Number;
    int32_t v8 = (int32_t)Name;
    int32_t v9 = *v6; // 0x807f29f
    int32_t v10; // 0x807f190
    int32_t v11; // 0x807f190
    int32_t v12; // 0x807f190
    if (v9 > 1999) {
        if (v9 < 0x989681) {
            // 0x807f390
            if ((*(char *)v4 & 8) != 0) {
                goto lab_0x807f430;
            } else {
                // 0x807f39a
                if (v9 < *v2 - 399) {
                    goto lab_0x807f430;
                } else {
                    if (Name == NULL) {
                        // 0x807f3ba
                        v12 = (int32_t)"(unknown)";
                        goto lab_0x807f3c1;
                    } else {
                        // 0x807f3b2
                        v12 = v8;
                        if (*Name != 0) {
                            goto lab_0x807f3c1;
                        } else {
                            // 0x807f3ba
                            v12 = (int32_t)"(unknown)";
                            goto lab_0x807f3c1;
                        }
                    }
                }
            }
        } else {
            if (Name == NULL) {
                // 0x807f336
                v11 = (int32_t)"(unknown)";
                goto lab_0x807f33d;
            } else {
                // 0x807f32e
                v11 = v8;
                if (*Name != 0) {
                    goto lab_0x807f33d;
                } else {
                    // 0x807f336
                    v11 = (int32_t)"(unknown)";
                    goto lab_0x807f33d;
                }
            }
        }
    } else {
        if (Name == NULL) {
            // 0x807f420
            v10 = (int32_t)"(unknown)";
            goto lab_0x807f2c0;
        } else {
            // 0x807f2b4
            v10 = v8;
            if (*Name == 0) {
                // 0x807f420
                v10 = (int32_t)"(unknown)";
                goto lab_0x807f2c0;
            } else {
                goto lab_0x807f2c0;
            }
        }
    }
  lab_0x807f430:
    if (v9 != DrillingHole) {
        // 0x807f438
        Message("Mapped pin drill hole to %.2f mils from %.2f mils per vendor table\n", (float64_t)(0.01L * (float80_t)v9), (float64_t)(0.01L * (float80_t)DrillingHole));
        return result;
    }
    // 0x807f313
    return result;
  lab_0x807f2c0:
    // 0x807f2c0
    if (Number != NULL) {
        // 0x807f2cb
        if (*Number != 0) {
            // 0x807f2d7
            Message("Did not map pin #%s (%s) drill hole because %6.2f mil is below the minimum allowed size\n", (char *)v7, (char *)v10, (float64_t)(0.01L * (float80_t)v9));
            *v6 = DrillingHole;
            return result;
        }
    }
    // 0x807f2d7
    Message("Did not map pin #%s (%s) drill hole because %6.2f mil is below the minimum allowed size\n", (char *)(int32_t)"(unknown)", (char *)v10, (float64_t)(0.01L * (float80_t)v9));
    *v6 = DrillingHole;
    return result;
  lab_0x807f33d:
    // 0x807f33d
    if (Number != NULL) {
        // 0x807f344
        if (*Number != 0) {
            // 0x807f353
            Message("Did not map pin #%s (%s) drill hole because %6.2f mil is above the maximum allowed size\n", (char *)v7, (char *)v11, (float64_t)(0.01L * (float80_t)v9));
            *v6 = DrillingHole;
            return result;
        }
    }
    // 0x807f353
    Message("Did not map pin #%s (%s) drill hole because %6.2f mil is above the maximum allowed size\n", (char *)(int32_t)"(unknown)", (char *)v11, (float64_t)(0.01L * (float80_t)v9));
    *v6 = DrillingHole;
    return result;
  lab_0x807f3c1:
    // 0x807f3c1
    if (Number != NULL) {
        // 0x807f3c8
        if (*Number != 0) {
            // 0x807f3d7
            Message("Did not map pin #%s (%s) drill hole because %6.2f mil does not leave enough copper\n", (char *)v7, (char *)v12, (float64_t)(0.01L * (float80_t)v9));
            *v6 = DrillingHole;
            // 0x807f313
            return result;
        }
    }
    // 0x807f3d7
    Message("Did not map pin #%s (%s) drill hole because %6.2f mil does not leave enough copper\n", (char *)(int32_t)"(unknown)", (char *)v12, (float64_t)(0.01L * (float80_t)v9));
    *v6 = DrillingHole;
    // 0x807f313
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f470 - 0x807f5ae
// Line range:    716 - 86
int32_t * CreateNewLineInElement(int32_t * Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness) {
    int32_t v1 = (int32_t)Element;
    int32_t * v2 = (int32_t *)(v1 + 264); // 0x807f489
    int32_t v3 = *v2; // 0x807f489
    if (Thickness == 0) {
        // 0x807f503
        return NULL;
    }
    int32_t * v4 = (int32_t *)(v1 + 240); // 0x807f491
    uint32_t v5 = *v4; // 0x807f491
    int32_t * v6 = (int32_t *)(v1 + 244); // 0x807f497
    uint32_t v7 = *v6; // 0x807f497
    int32_t v8 = v5; // 0x807f49f
    int32_t v9 = v3; // 0x807f49f
    if (v5 >= v7) {
        int32_t v10 = v7 + 10; // 0x807f518
        *v6 = v10;
        v9 = (int32_t)MyRealloc((char *)v3, 88 * v10, "CreateNewLineInElement()");
        int32_t v11 = 88 * *v4 + v9; // 0x807f546
        *v2 = v9;
        char v12 = 112; // 0x807f557
        int32_t v13 = v11; // 0x807f557
        if (v11 % 2 != 0) {
            // 0x807f590
            *(char *)v11 = 0;
            v12 = 111;
            v13 = v11 + 1;
        }
        char v14 = v12; // 0x807f55f
        int32_t v15 = v13; // 0x807f55f
        if ((v13 & 2) != 0) {
            // 0x807f5a0
            *(int16_t *)v13 = 0;
            v14 = v12 - 2;
            v15 = v13 + 2;
        }
        uint32_t v16 = (int32_t)v14 / 4; // 0x807f566
        __asm_rep_stosd_memset((char *)v15, 0, v16);
        bool v17; // 0x807f470
        int32_t v18 = v16 * (v17 ? -4 : 4) + v15; // 0x807f569
        int32_t v19 = v18; // 0x807f56f
        if ((v14 & 2) != 0) {
            // 0x807f571
            *(int16_t *)v18 = 0;
            v19 = v18 + 2;
        }
        if (v14 % 2 != 0) {
            // 0x807f57f
            *(char *)v19 = 0;
        }
        // 0x807f582
        v8 = *v4;
    }
    // 0x807f4a1
    *v4 = v8 + 1;
    int32_t v20 = v9 + 88 * v8; // 0x807f4b0
    *(int32_t *)(v20 + 44) = X1;
    *(int32_t *)(v20 + 48) = Y1;
    *(int32_t *)(v20 + 64) = X2;
    *(int32_t *)(v20 + 36) = Thickness;
    *(int32_t *)(v20 + 68) = Y2;
    int32_t v21; // bp-44, 0x807f470
    MakeFlags((int32_t)&v21);
    *(int32_t *)(v20 + 20) = v21;
    *(int32_t *)(v20 + 16) = ID;
    ID++;
    // 0x807f503
    return (int32_t *)v20;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f5b0 - 0x807f6ba
// Line range:    866 - 876
void AddTextToElement(int32_t * Text, int32_t * PCBFont, int32_t X, int32_t Y, char Direction, char * TextString, int32_t Scale, int32_t Flags) {
    // 0x807f5b0
    int32_t v1; // 0x807f5b0
    int32_t * v2 = (int32_t *)(v1 + 52); // 0x807f602
    SaveFree((char *)*v2);
    *v2 = 0;
    *(char *)(v1 + 48) = (char)(int32_t)PCBFont;
    *(int32_t *)(v1 + 44) = (int32_t)Text;
    *(char *)(v1 + 26) = (char)Flags;
    *(char *)(v1 + 25) = (char)Scale;
    *(char *)(v1 + 24) = (char)(int32_t)TextString;
    *(int32_t *)(v1 + 20) = (int32_t)Direction;
    *(int32_t *)(v1 + 36) = Y;
    int32_t v3 = 0; // 0x807f66e
    if (X != 0) {
        char * v4 = (char *)X; // 0x807f670
        v3 = 0;
        if (*v4 != 0) {
            // 0x807f6a8
            v3 = (int32_t)MyStrdup(v4, "AddTextToElement()");
        }
    }
    // 0x807f677
    *v2 = v3;
    SetTextBoundingBox((int32_t *)v1, (int32_t *)v1);
    *(int32_t *)(v1 + 16) = ID;
    ID++;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f6c0 - 0x807f879
// Line range:    639 - 647
int32_t * CreateNewElement(int32_t * Data, int32_t * Element, int32_t * PCBFont, int32_t Flags, char * Description, char * NameOnPCB, char * Value, int32_t TextX, int32_t TextY, char Direction, int32_t TextScale, int32_t TextFlags, char uniqueName) {
    // 0x807f6c0
    int32_t v1; // 0x807f6c0
    int32_t v2 = v1;
    int32_t * result = Element; // 0x807f71a
    if (Element == NULL) {
        // 0x807f860
        result = GetElementMemory(Data);
    }
    int32_t v3 = v2 < 10 == (9 - v2 & v2) < 0 ? v2 : 10; // 0x807f72b
    int32_t * v4 = (int32_t *)v1; // 0x807f761
    char v5; // 0x807f6c0
    int32_t * v6 = (int32_t *)(int32_t)v5; // 0x807f761
    char * v7; // 0x807f6c0
    AddTextToElement(v4, v6, (int32_t)uniqueName, v3, v5, v7, v1, (int32_t)&g279);
    char * v8; // 0x807f6c0
    if (v5 != 0) {
        // 0x807f76c
        v8 = UniqueElementName(Data, v7);
    }
    int32_t v9 = (int32_t)result;
    AddTextToElement(v4, v6, (int32_t)v8, v3, v5, v7, v1, (int32_t)&g279);
    AddTextToElement(v4, v6, v1, v3, v5, v7, v1, (int32_t)&g279);
    *(int32_t *)(v9 + 92) = v9;
    *(int32_t *)(v9 + 152) = v9;
    *(int32_t *)(v9 + 212) = v9;
    *(char *)(v9 + 31) = (char)TextFlags;
    *(char *)(v9 + 30) = (char)TextScale;
    *(char *)(v9 + 29) = Direction;
    *(char *)(v9 + 28) = (char)TextY;
    *(char *)(v9 + 27) = (char)TextX;
    *(char *)(v9 + 26) = (char)(int32_t)Value;
    *(char *)(v9 + 25) = (char)(int32_t)NameOnPCB;
    *(char *)(v9 + 24) = (char)(int32_t)Description;
    *(int32_t *)(v9 + 20) = Flags;
    *(int32_t *)(v9 + 16) = ID;
    ID++;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f880 - 0x807f8b0
// Line range:    622 - 632
int32_t * CreateNewPointInPolygon(int32_t * Polygon2, int32_t X, int32_t Y) {
    int32_t * result = GetPointMemoryInPolygon(Polygon2); // 0x807f88c
    int32_t v1 = (int32_t)result; // 0x807f88c
    *result = X;
    *(int32_t *)(v1 + 4) = Y;
    *(int32_t *)(v1 + 16) = ID;
    ID++;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f8b0 - 0x807f969
// Line range:    605 - 616
int32_t * CreateNewPolygon(int32_t * Layer2, int32_t Flags) {
    int32_t * result = GetPolygonMemory(Layer2); // 0x807f8fa
    int32_t v1 = (int32_t)result; // 0x807f8fa
    *(int32_t *)(v1 + 44) = 0;
    *(int32_t *)(v1 + 48) = 0;
    *(int32_t *)(v1 + 20) = Flags;
    *(int32_t *)(v1 + 16) = ID;
    ID++;
    *(int32_t *)(v1 + 52) = 0;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f970 - 0x807faa1
// Line range:    574 - 596
int32_t * CreateNewText(int32_t * Layer2, int32_t * PCBFont, int32_t X, int32_t Y, char Direction, int32_t Scale, char * TextString, int32_t Flags) {
    int32_t * result = GetTextMemory(Layer2); // 0x807f9c0
    if (result == NULL) {
        // 0x807fa74
        return result;
    }
    int32_t v1 = (int32_t)result; // 0x807f9c0
    *(int32_t *)(v1 + 40) = X;
    *(int32_t *)(v1 + 44) = Y;
    *(char *)(v1 + 48) = Direction;
    *(int32_t *)(v1 + 20) = Flags;
    *(int32_t *)(v1 + 36) = Scale;
    *(int32_t *)(v1 + 52) = (int32_t)MyStrdup(TextString, "CreateNewText()");
    SetTextBoundingBox(PCBFont, result);
    *(int32_t *)(v1 + 16) = ID;
    ID++;
    int32_t * v2 = (int32_t *)((int32_t)Layer2 + 56); // 0x807fa59
    int32_t v3 = *v2; // 0x807fa59
    int32_t v4 = v3; // 0x807fa5e
    if (v3 == 0) {
        // 0x807fa80
        v4 = (int32_t)r_create_tree(NULL, 0, 0);
        *v2 = v4;
    }
    // 0x807fa60
    r_insert_entry((int32_t *)v4, result, 0);
    // 0x807fa74
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fab0 - 0x807fb91
// Line range:    550 - 565
int32_t * CreateNewPolygonFromRectangle(int32_t * Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Flags) {
    int32_t * result = CreateNewPolygon(Layer2, Flags); // 0x807fadd
    if (result == NULL) {
        // 0x807fb5d
        return result;
    }
    // 0x807fae8
    CreateNewPointInPolygon(result, X1, Y1);
    CreateNewPointInPolygon(result, X2, Y1);
    CreateNewPointInPolygon(result, X2, Y2);
    CreateNewPointInPolygon(result, X1, Y2);
    SetPolygonBoundingBox(result);
    int32_t * v1 = (int32_t *)((int32_t)Layer2 + 60); // 0x807fb42
    int32_t v2 = *v1; // 0x807fb42
    int32_t v3 = v2; // 0x807fb47
    if (v2 == 0) {
        // 0x807fb70
        v3 = (int32_t)r_create_tree(NULL, 0, 0);
        *v1 = v3;
    }
    // 0x807fb49
    r_insert_entry((int32_t *)v3, result, 0);
    // 0x807fb5d
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fba0 - 0x807fd89
// Line range:    506 - 540
int32_t * CreateNewArcOnLayer(int32_t * Layer2, int32_t X1, int32_t Y1, int32_t width, int32_t height, int32_t sa, int32_t dir, int32_t Thickness, int32_t Clearance, int32_t Flags) {
    int32_t v1 = (int32_t)Layer2;
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x807fbed
    if (v2 != 0) {
        int32_t v3 = sa + 360; // 0x807fc0c
        int32_t v4 = -360 * ((v3 + (int32_t)(-0x49f49f49 * (int64_t)v3 / 0x100000000) >> 8) - (v3 >> 31)) + v3; // 0x807fc2b
        int32_t v5 = v2; // 0x807fc43
        int32_t v6 = 68 * v2 - 16 + *(int32_t *)(v1 + 48);
        int32_t v7; // 0x807fc67
        if (*(int32_t *)v6 == X1) {
            // 0x807fc57
            if (*(int32_t *)(v6 + 4) == Y1) {
                // 0x807fc5c
                if (*(int32_t *)(v6 - 8) == width) {
                    // 0x807fc64
                    v7 = *(int32_t *)(v6 + 8) + 360;
                    if (-360 * ((v7 + (int32_t)(-0x49f49f49 * (int64_t)v7 / 0x100000000) >> 8) - (v7 >> 31)) + v7 == v4) {
                        // 0x807fc95
                        if (*(int32_t *)(v6 + 12) == dir) {
                            // 0x807fd5b
                            return (int32_t *)0;
                        }
                    }
                }
            }
        }
        // 0x807fc48
        v5--;
        int32_t v8 = v6 - 68; // 0x807fc51
        while (v5 != 0) {
            // 0x807fc53
            v6 = v8;
            if (*(int32_t *)v6 == X1) {
                // 0x807fc57
                if (*(int32_t *)(v6 + 4) == Y1) {
                    // 0x807fc5c
                    if (*(int32_t *)(v6 - 8) == width) {
                        // 0x807fc64
                        v7 = *(int32_t *)(v6 + 8) + 360;
                        if (-360 * ((v7 + (int32_t)(-0x49f49f49 * (int64_t)v7 / 0x100000000) >> 8) - (v7 >> 31)) + v7 == v4) {
                            // 0x807fc95
                            if (*(int32_t *)(v6 + 12) == dir) {
                                // 0x807fd5b
                                return (int32_t *)0;
                            }
                        }
                    }
                }
            }
            // 0x807fc48
            v5--;
            v8 = v6 - 68;
        }
    }
    int32_t * v9 = GetArcMemory(Layer2); // 0x807fcae
    int32_t v10 = (int32_t)v9; // 0x807fcae
    if (v9 == NULL) {
        // 0x807fd5b
        return (int32_t *)v10;
    }
    // 0x807fcbd
    *(int32_t *)(v10 + 16) = ID;
    ID++;
    *(int32_t *)(v10 + 36) = Thickness;
    *(int32_t *)(v10 + 20) = Flags;
    *(int32_t *)(v10 + 52) = X1;
    *(int32_t *)(v10 + 56) = Y1;
    *(int32_t *)(v10 + 40) = Clearance;
    *(int32_t *)(v10 + 60) = sa;
    *(int32_t *)(v10 + 44) = width;
    *(int32_t *)(v10 + 48) = height;
    *(int32_t *)(v10 + 64) = dir;
    SetArcBoundingBox(v9);
    int32_t * v11 = (int32_t *)(v1 + 64); // 0x807fd40
    int32_t v12 = *v11; // 0x807fd40
    int32_t v13 = v12; // 0x807fd45
    if (v12 == 0) {
        // 0x807fd65
        v13 = (int32_t)r_create_tree(NULL, 0, 0);
        *v11 = v13;
    }
    // 0x807fd47
    r_insert_entry((int32_t *)v13, v9, 0);
    // 0x807fd5b
    return (int32_t *)v10;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fd90 - 0x807fec1
// Line range:    474 - 497
int32_t * CreateNewRat(int32_t * Data, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t group1, int32_t group2, int32_t Thickness, int32_t Flags) {
    int32_t * result = GetRatMemory(Data); // 0x807fdda
    if (result == NULL) {
        // 0x807fe91
        return result;
    }
    int32_t v1 = (int32_t)result; // 0x807fdda
    *(int32_t *)(v1 + 16) = ID;
    *(int32_t *)(v1 + 60) = ID + 1;
    *(int32_t *)(v1 + 80) = ID + 2;
    *(int32_t *)(v1 + 20) = Flags | 16;
    *(int32_t *)(v1 + 36) = Thickness;
    *(int32_t *)(v1 + 44) = X1;
    *(int32_t *)(v1 + 48) = Y1;
    *(int32_t *)(v1 + 64) = X2;
    *(int32_t *)(v1 + 68) = Y2;
    ID += 3;
    *(int32_t *)(v1 + 84) = group1;
    *(int32_t *)(v1 + 88) = group2;
    SetLineBoundingBox(result);
    int32_t * v2 = (int32_t *)((int32_t)Data + 68); // 0x807fe76
    int32_t v3 = *v2; // 0x807fe76
    int32_t v4 = v3; // 0x807fe7b
    if (v3 == 0) {
        // 0x807fea0
        v4 = (int32_t)r_create_tree(NULL, 0, 0);
        *v2 = v4;
    }
    // 0x807fe7d
    r_insert_entry((int32_t *)v4, result, 0);
    // 0x807fe91
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fed0 - 0x807fff9
// Line range:    441 - 465
int32_t * CreateNewLineOnLayer(int32_t * Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Flags) {
    int32_t * result = GetLineMemory(Layer2); // 0x807ff1a
    if (result == NULL) {
        // 0x807ffcb
        return result;
    }
    int32_t v1 = (int32_t)result; // 0x807ff1a
    *(int32_t *)(v1 + 16) = ID;
    *(int32_t *)(v1 + 60) = ID + 1;
    *(int32_t *)(v1 + 80) = ID + 2;
    *(int32_t *)(v1 + 20) = Flags & -17;
    *(int32_t *)(v1 + 36) = Thickness;
    *(int32_t *)(v1 + 40) = Clearance;
    *(int32_t *)(v1 + 44) = X1;
    *(int32_t *)(v1 + 48) = Y1;
    *(int32_t *)(v1 + 64) = X2;
    *(int32_t *)(v1 + 68) = Y2;
    ID += 3;
    SetLineBoundingBox(result);
    int32_t * v2 = (int32_t *)((int32_t)Layer2 + 52); // 0x807ffb0
    int32_t v3 = *v2; // 0x807ffb0
    int32_t v4 = v3; // 0x807ffb5
    if (v3 == 0) {
        // 0x807ffd8
        v4 = (int32_t)r_create_tree(NULL, 0, 0);
        *v2 = v4;
    }
    // 0x807ffb7
    r_insert_entry((int32_t *)v4, result, 0);
    // 0x807ffcb
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x8080400 - 0x80806ad
// Line range:    225 - 283
int32_t * CreateNewVia(int32_t * Data, uint32_t X, uint32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, int32_t Flags) {
    int32_t v1 = (int32_t)Data;
    uint32_t v2 = *Data; // 0x8080447
    int3_t v3; // 0x8080400
    if (v2 != 0) {
        int32_t v4 = (int32_t)(Thickness < 0) + Thickness >> 1; // 0x8080463
        int3_t v5 = v3 - 1; // 0x808048d
        int3_t v6 = v3 - 2;
        int3_t v7 = v3 - 3;
        int32_t v8 = *(int32_t *)(v1 + 28); // 0x808046d
        int32_t v9 = 0; // 0x808046d
        uint32_t v10 = *(int32_t *)(v8 + 52); // 0x808047f
        uint32_t v11 = *(int32_t *)(v8 + 56); // 0x808048a
        __frontend_reg_store_fpr(v5, (float80_t)(v10 - X));
        int32_t v12 = *(int32_t *)(v8 + 36); // 0x8080498
        __frontend_reg_store_fpr(v6, (float80_t)(v11 - Y));
        __frontend_reg_store_fpr(v7, (float80_t)((v12 + (int32_t)(v12 < 0) >> 1) + v4));
        float80_t v13 = __frontend_reg_load_fpr(v7); // 0x80804b1
        __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v5));
        __frontend_reg_store_fpr(v5, v13);
        __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v7) * __frontend_reg_load_fpr(v7));
        float80_t v14 = __frontend_reg_load_fpr(v7); // 0x80804b5
        __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v6));
        __frontend_reg_store_fpr(v6, v14);
        __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v7) * __frontend_reg_load_fpr(v7));
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v7) + __frontend_reg_load_fpr(v6));
        float80_t v15 = __frontend_reg_load_fpr(v6); // 0x80804bb
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v5));
        __frontend_reg_store_fpr(v5, v15);
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) * __frontend_reg_load_fpr(v6));
        float80_t v16 = __frontend_reg_load_fpr(v6); // 0x80804bf
        float80_t v17 = __frontend_reg_load_fpr(v5); // 0x80804bf
        while (v16 <= v17) {
            // 0x808047f
            __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
            if (v16 == v17) {
                // 0x80804c5
                Message("Dropping via at (%d, %d) because it would overlap with the viaat (%d, %d)\n", X / 100, Y / 100, v10 / 100, v11 / 100);
                return NULL;
            }
            // 0x8080470
            v9++;
            v8 += 76;
            if (v2 <= v9) {
                goto lab_0x8080530;
            }
            v10 = *(int32_t *)(v8 + 52);
            v11 = *(int32_t *)(v8 + 56);
            __frontend_reg_store_fpr(v5, (float80_t)(v10 - X));
            v12 = *(int32_t *)(v8 + 36);
            __frontend_reg_store_fpr(v6, (float80_t)(v11 - Y));
            __frontend_reg_store_fpr(v7, (float80_t)((v12 + (int32_t)(v12 < 0) >> 1) + v4));
            v13 = __frontend_reg_load_fpr(v7);
            __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v5));
            __frontend_reg_store_fpr(v5, v13);
            __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v7) * __frontend_reg_load_fpr(v7));
            v14 = __frontend_reg_load_fpr(v7);
            __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v6));
            __frontend_reg_store_fpr(v6, v14);
            __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v7) * __frontend_reg_load_fpr(v7));
            __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v7) + __frontend_reg_load_fpr(v6));
            v15 = __frontend_reg_load_fpr(v6);
            __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v5));
            __frontend_reg_store_fpr(v5, v15);
            __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) * __frontend_reg_load_fpr(v6));
            v16 = __frontend_reg_load_fpr(v6);
            v17 = __frontend_reg_load_fpr(v5);
        }
        // 0x80804c5
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
        // 0x80804c5
        Message("Dropping via at (%d, %d) because it would overlap with the viaat (%d, %d)\n", X / 100, Y / 100, v10 / 100, v11 / 100);
        return NULL;
    }
  lab_0x8080530:;
    int32_t * result = GetViaMemory(Data); // 0x8080536
    if (result == NULL) {
        // 0x8080643
        return result;
    }
    int32_t v18 = (int32_t)result; // 0x8080536
    int32_t * v19 = (int32_t *)(v18 + 52); // 0x808054b
    *v19 = X;
    int32_t * v20 = (int32_t *)(v18 + 56); // 0x8080551
    *v20 = Y;
    int32_t * v21 = (int32_t *)(v18 + 36); // 0x8080557
    *v21 = Thickness;
    *(int32_t *)(v18 + 40) = Clearance;
    *(int32_t *)(v18 + 44) = Mask;
    int32_t v22 = vendorDrillMap(DrillingHole); // 0x8080569
    int32_t * v23 = (int32_t *)(v18 + 48); // 0x8080571
    *v23 = v22;
    if (v22 != DrillingHole) {
        int3_t v24 = v3 - 1; // 0x8080576
        __frontend_reg_store_fpr(v24, (float80_t)DrillingHole);
        int3_t v25 = v3 - 2; // 0x8080579
        __frontend_reg_store_fpr(v25, 0.01L);
        __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v24) * __frontend_reg_load_fpr(v25));
        float80_t v26 = __frontend_reg_load_fpr(v25); // 0x8080581
        __frontend_reg_store_fpr(v25, __frontend_reg_load_fpr(v24));
        __frontend_reg_store_fpr(v24, v26);
        __frontend_reg_load_fpr(v25);
        __frontend_reg_store_fpr(v25, (float80_t)v22);
        __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v25) * __frontend_reg_load_fpr(v24));
        Message((char *)(int32_t)(float32_t)__frontend_reg_load_fpr(v24));
    }
    // 0x808059f
    *(int32_t *)(v18 + 60) = (int32_t)MyStrdup(Name, "CreateNewVia()");
    *(int32_t *)(v18 + 16) = ID;
    *(int32_t *)(v18 + 20) = Flags & -515 | 2;
    ID++;
    if ((Flags & 8) == 0) {
        int32_t v27 = *v23; // 0x808060f
        if (v27 + 399 >= *v21) {
            int3_t v28 = v3 - 1; // 0x808064d
            __frontend_reg_store_fpr(v28, (float80_t)*v20);
            int32_t v29 = v27 + 400; // 0x8080650
            int3_t v30 = v3 - 2; // 0x8080655
            __frontend_reg_store_fpr(v30, 0.01L);
            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v28) * __frontend_reg_load_fpr(v30));
            float80_t v31 = __frontend_reg_load_fpr(v30); // 0x808065d
            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v28));
            __frontend_reg_store_fpr(v28, v31);
            *v21 = v29;
            __frontend_reg_load_fpr(v30);
            __frontend_reg_store_fpr(v30, (float80_t)*v19);
            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v28));
            __frontend_reg_load_fpr(v30);
            __frontend_reg_store_fpr(v30, (float80_t)v29);
            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v28));
            Message((char *)(int32_t)(float32_t)__frontend_reg_load_fpr(v28));
        }
    }
    // 0x808061d
    SetPinBoundingBox(result);
    int32_t * v32 = (int32_t *)(v1 + 40); // 0x8080628
    int32_t v33 = *v32; // 0x8080628
    int32_t v34 = v33; // 0x808062d
    if (v33 == 0) {
        int32_t v35 = (int32_t)r_create_tree(NULL, 0, 0); // 0x80806a0
        *v32 = v35;
        v34 = v35;
    }
    // 0x808062f
    r_insert_entry((int32_t *)v34, result, 0);
    // 0x8080643
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x80806b0 - 0x8080772
// Line range:    203 - 215
int32_t CreateNewPCBPost(int32_t * pcb, int32_t use_defaults) {
    // 0x80806b0
    pcb_colors_from_settings(pcb);
    if (use_defaults == 0) {
        // 0x80806d3
        return 0;
    }
    int32_t v1 = (int32_t)pcb;
    int32_t result = 1; // 0x8080708
    if (ParseGroupString((char *)g158, (int32_t *)(v1 + 0x1cd4), 8) == 0) {
        int32_t * v2 = (int32_t *)(v1 + 0x220c); // 0x808070f
        int32_t v3 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x808071b
        *(int32_t *)(*v2 + 168 + 92 * v3) = (int32_t)MyStrdup("silk", "CreateNewPCB()");
        int32_t v4 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x808074d
        *(int32_t *)(*v2 + 76 + 92 * v4) = (int32_t)MyStrdup("silk", "CreateNewPCB()");
        result = 0;
    }
    // 0x80806d3
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x8080780 - 0x80807ad
// Line range:    80 - 86
int32_t * CreateNewBuffer(void) {
    char * v1 = MyCalloc(1, 1732, "CreateNewBuffer()"); // 0x808079d
    *(int32_t *)((int32_t)v1 + 72) = (int32_t)PCB;
    return (int32_t *)v1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x80807b0 - 0x80809f6
// Line range:    133 - 200
int32_t * CreateNewPCB(char SetDefaultNames) {
    char * v1 = MyCalloc(1, 0x2210, "CreateNewPCB()"); // 0x80807d0
    int32_t v2 = (int32_t)v1; // 0x80807d0
    int32_t v3 = (int32_t)CreateNewBuffer(); // 0x80807d7
    *(int32_t *)(v3 + 72) = v2;
    int32_t * v4 = (int32_t *)(v2 + 0x220c); // 0x80807e5
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v2 + 4); // 0x80807eb
    int32_t v6 = *v5; // 0x80807eb
    *(char *)(v2 + 32) = 4;
    *(float64_t *)(v2 + 168) = 2.0e+8;
    int32_t v7 = v6 | 64; // 0x80807fa
    *(char *)(v2 + 39) = 0;
    *(char *)(v2 + 40) = 0;
    *v5 = v7;
    int32_t v8 = v7; // 0x808080f
    if (g184 != 0) {
        // 0x8080811
        v8 = v6 | 65;
        *v5 = v8;
    }
    // 0x8080817
    if (g179 != 0) {
        // 0x8080820
        *v5 = v8 | 256;
    }
    // 0x8080827
    *(int32_t *)(v2 + 108) = 1;
    if (g180 != 0) {
        // 0x8080837
        *v5 = *v5 | 16;
    }
    // 0x808083b
    if (g181 != 0) {
        // 0x8080844
        *v5 = *v5 | 512;
    }
    // 0x808084b
    if (g175 != 0) {
        // 0x8080854
        *v5 = *v5 | 1024;
    }
    // 0x808085b
    if (g176 != 0) {
        // 0x8080864
        *v5 = *v5 | 0x1000;
    }
    // 0x808086b
    if (g173 != 0) {
        // 0x8080874
        *v5 = *v5 | 2048;
    }
    // 0x808087b
    if (g174 != 0) {
        // 0x8080884
        *v5 = *v5 | 0x100000;
    }
    // 0x808088b
    if (g185 != 0) {
        // 0x8080894
        *v5 = *v5 | 0x8000;
    }
    // 0x808089b
    if (g186 != 0) {
        // 0x80808a4
        *v5 = *v5 | 0x10000;
    }
    // 0x80808ab
    if (g182 != 0) {
        // 0x80808b4
        *v5 = *v5 | 8;
    }
    // 0x80808b8
    if (g183 != 0) {
        // 0x80808c1
        *v5 = *v5 | 128;
    }
    // 0x80808c8
    __asm_rep_movsd_memcpy((char *)(v2 + 0x1cd4), (char *)&g172, 304);
    float80_t v9; // 0x80807b0
    *(float64_t *)(v2 + 152) = (float64_t)v9;
    int32_t v10 = 0; // 0x80808e8
    int32_t v11 = 0; // 0x80808e8
    int32_t v12 = *(int32_t *)(v10 + (int32_t)&g167); // 0x80808ea
    int32_t v13 = v10 + v2;
    *(int32_t *)(v13 + 0x2194) = v12;
    int32_t v14 = *(int32_t *)(v10 + (int32_t)&g168); // 0x80808f7
    *(int32_t *)(v13 + 0x2198) = v14;
    int32_t v15 = *(int32_t *)(v10 + (int32_t)&g169); // 0x8080904
    *(int32_t *)(v13 + 0x219c) = v15;
    int32_t v16 = *(int32_t *)(v10 + (int32_t)&g170); // 0x8080911
    *(int32_t *)(v13 + 0x21a0) = v16;
    int32_t v17 = *(int32_t *)(v10 + (int32_t)&g171); // 0x808091e
    *(int32_t *)(v13 + 0x21a8) = v11;
    v11++;
    *(int32_t *)(v13 + 0x21a4) = v17;
    v10 += 24;
    while (v11 != 4) {
        // 0x80808ea
        v12 = *(int32_t *)(v10 + (int32_t)&g167);
        v13 = v10 + v2;
        *(int32_t *)(v13 + 0x2194) = v12;
        v14 = *(int32_t *)(v10 + (int32_t)&g168);
        *(int32_t *)(v13 + 0x2198) = v14;
        v15 = *(int32_t *)(v10 + (int32_t)&g169);
        *(int32_t *)(v13 + 0x219c) = v15;
        v16 = *(int32_t *)(v10 + (int32_t)&g170);
        *(int32_t *)(v13 + 0x21a0) = v16;
        v17 = *(int32_t *)(v10 + (int32_t)&g171);
        *(int32_t *)(v13 + 0x21a8) = v11;
        v11++;
        *(int32_t *)(v13 + 0x21a4) = v17;
        v10 += 24;
    }
    // 0x808093d
    hid_action("RouteStylesChanged");
    *(int32_t *)(v2 + 144) = g139;
    *(float64_t *)(v2 + 160) = g147;
    *(int32_t *)(v2 + 148) = (int32_t)(float32_t)g140;
    *(float64_t *)(v2 + 176) = 0.5;
    *(int32_t *)v1 = ID;
    ID++;
    *(int32_t *)(v2 + 112) = g141;
    *(int32_t *)(v2 + 116) = (int32_t)g142;
    *(int32_t *)(v2 + 120) = (int32_t)g143;
    *(int32_t *)(v2 + 124) = (int32_t)g144;
    *(int32_t *)(v2 + 128) = (int32_t)g145;
    *(int32_t *)(v2 + 132) = (int32_t)g146;
    int32_t v18 = 0;
    int32_t v19 = *(int32_t *)(4 * v18 + (int32_t)&g151); // 0x80809c0
    char * v20 = MyStrdup((char *)v19, "CreateNewPCB()"); // 0x80809d8
    int32_t v21 = v18 + 1; // 0x80809e0
    *(int32_t *)(92 * v18 + 76 + *v4) = (int32_t)v20;
    while (v21 != 16) {
        // 0x80809c0
        v18 = v21;
        v19 = *(int32_t *)(4 * v18 + (int32_t)&g151);
        v20 = MyStrdup((char *)v19, "CreateNewPCB()");
        v21 = v18 + 1;
        *(int32_t *)(92 * v18 + 76 + *v4) = (int32_t)v20;
    }
    // 0x80809ec
    return (int32_t *)v1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8080a00 - 0x8080abd
// Line range:    93 - 105
void XORPolygon(int32_t * polygon, int32_t dx, int32_t dy) {
    // 0x8080a00
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8080ac0 - 0x8080fe9
// Line range:    198 - 201
void XORDrawElement(int32_t * Element, int32_t DX, int32_t DY) {
    // 0x8080ac0
    int32_t v1; // 0x8080ac0
    int32_t v2 = *(int32_t *)(v1 + 248); // 0x8080acf
    int32_t v3 = *(int32_t *)(v1 + 240);
    if ((v3 || v2) != 0) {
        // 0x8080aeb
        if (v3 != 0) {
            int32_t v4 = v3 - 1;
            int32_t v5 = v4; // 0x8080b57
            while (v4 != 0) {
                // 0x8080b08
                v4 = v5 - 1;
                v5 = v4;
            }
        }
        // 0x8080b66
        if (v2 != 0) {
            int32_t v6 = v2 - 1;
            int32_t v7 = v6; // 0x8080bdc
            while (v6 != 0) {
                // 0x8080b88
                v6 = v7 - 1;
                v7 = v6;
            }
        }
    }
    uint32_t v8 = *(int32_t *)(v1 + 232); // 0x8080c6e
    uint32_t v9 = 0; // 0x8080c88
    while (v8 != 0 && v9 < v8) {
        // 0x8080d90
        v9++;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8080ff0 - 0x808108e
// Line range:    1021 - 1034
void DrawMark(char ifvis) {
    // 0x8080ff0
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081090 - 0x808115b
// Line range:    1042 - 1066
void InitCrosshair(void) {
    // 0x8081090
    Crosshair = (int32_t)gui;
    CrosshairStack[0] = 1;
    g228 = 0;
    g225 = 0;
    g224 = 0;
    CrosshairStackLocation = 1;
    g250 = 0;
    g226 = Marked;
    *(char *)&Marked = 0;
    g227 = g217;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081160 - 0x80818d1
// Line range:    782 - 953
void FitCrosshairIntoGrid(int32_t X, int32_t Y) {
    int32_t v1 = Marked; // 0x8081175
    float64_t v2 = g217; // 0x808117b
    int32_t v3 = g224; // 0x8081184
    int32_t v4 = X - v3; // 0x808118c
    int32_t v5 = v4 < 0 == ((v4 ^ X) & (v3 ^ X)) < 0 ? X : v3; // 0x808118e
    int32_t v6 = g226; // 0x8081191
    int32_t v7 = v5 - v6; // 0x8081196
    int32_t v8 = v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0 == (v7 != 0) ? v6 : v5; // 0x8081198
    int32_t v9 = g225; // 0x808119b
    g222 = (int64_t)v8;
    int32_t v10 = Y - v9; // 0x80811a6
    int32_t v11 = v10 < 0 == ((v10 ^ Y) & (v9 ^ Y)) < 0 ? Y : v9; // 0x80811a8
    float64_t v12 = g227; // 0x80811ab
    int32_t v13 = v11 - (int32_t)(float32_t)v12; // 0x80811b0
    int32_t v14 = v13 < 0 == ((v13 ^ v11) & (v11 ^ (int32_t)(float32_t)v12)) < 0 == (v13 != 0) ? (int32_t)(float32_t)v12 : v11; // 0x80811b2
    g223 = (int64_t)v14;
    int32_t v15; // 0x8081160
    char v16; // 0x8081160
    if (g206 != 0) {
        goto lab_0x8081418;
    } else {
        // 0x80811c5
        v15 = 0;
        v16 = 0;
        if ((g193 & 16) != 0) {
            goto lab_0x8081418;
        } else {
            goto lab_0x80811d3;
        }
    }
  lab_0x8081418:;
    // 0x8081418
    int32_t v17; // bp-32, 0x8081160
    int32_t v18; // bp-36, 0x8081160
    int32_t v19; // bp-40, 0x8081160
    int32_t v20 = SearchScreen((int32_t)(float32_t)(float64_t)(int64_t)v8, v14, 768, (char **)&v17, (char **)&v18, (char **)&v19); // 0x808143c
    int32_t v21 = v20; // 0x8081443
    if (v20 != 0) {
        goto lab_0x80814d5;
    } else {
        // 0x8081449
        v15 = v20;
        v16 = g206;
        if (g206 != 0) {
            goto lab_0x80811d3;
        } else {
            int32_t v22 = SearchScreen((int32_t)(float32_t)g222, (int32_t)(float32_t)g223, 0x1001, (char **)&v17, (char **)&v18, (char **)&v19); // 0x8081488
            v21 = v22;
            if (v22 != 0) {
                goto lab_0x80814d5;
            } else {
                // 0x8081491
                v15 = v22;
                v16 = g206;
                if (g206 != 0) {
                    goto lab_0x80811d3;
                } else {
                    int32_t v23 = SearchScreen((int32_t)(float32_t)g222, (int32_t)(float32_t)g223, 2, (char **)&v17, (char **)&v18, (char **)&v19); // 0x80814d0
                    v21 = v23;
                    goto lab_0x80814d5;
                }
            }
        }
    }
  lab_0x80814d5:;
    int32_t v24 = (int32_t)PCB; // 0x80814db
    int32_t v25 = g206; // 0x80814e4
    int32_t v26 = v21; // 0x80814e8
    int32_t v27 = g148; // 0x80814e8
    int32_t v28 = v24; // 0x80814e8
    int32_t v29 = v25; // 0x80814e8
    int32_t v30 = v21; // 0x80814e8
    int32_t v31 = g148; // 0x80814e8
    int32_t v32 = v24; // 0x80814e8
    int32_t v33 = v25; // 0x80814e8
    if (g148 != 104) {
        goto lab_0x80811e2;
    } else {
        goto lab_0x80814ee;
    }
  lab_0x80811d3:;
    int32_t v34 = v16;
    int32_t v35 = (int32_t)PCB;
    v26 = v15;
    v27 = g148;
    v28 = v35;
    v29 = v34;
    v30 = v15;
    v31 = 104;
    v32 = v35;
    v33 = v34;
    if (g148 == 104) {
        goto lab_0x80814ee;
    } else {
        goto lab_0x80811e2;
    }
  lab_0x80811e2:;
    int32_t v36 = v26 & 512; // 0x80811ea
    int32_t v37 = v26; // 0x80811ea
    int32_t v38 = v27; // 0x80811ea
    int32_t v39 = v28; // 0x80811ea
    int32_t v40 = v29; // 0x80811ea
    goto lab_0x80811ed;
  lab_0x80814ee:
    // 0x80814ee
    if (g243 == 1) {
        // 0x80817d8
        v26 = v30;
        v27 = v31;
        v28 = v32;
        v29 = v33;
        v36 = 0;
        v37 = 0;
        v38 = v31;
        v39 = v32;
        v40 = v33;
        if ((v30 & 257) != 0) {
            goto lab_0x80811ed;
        } else {
            goto lab_0x80811e2;
        }
    } else {
        // 0x80814fd
        v26 = v30;
        v27 = v31;
        v28 = v32;
        v29 = v33;
        if ((v30 & 768) == 0 || g243 != 2) {
            goto lab_0x80811e2;
        } else {
            // 0x808150f
            v26 = v30;
            v27 = v31;
            v28 = v32;
            v29 = v33;
            v36 = 0;
            v37 = 0;
            v38 = v31;
            v39 = v32;
            v40 = v33;
            if (v17 != (int32_t)g245) {
                goto lab_0x80811e2;
            } else {
                goto lab_0x80811ed;
            }
        }
    }
  lab_0x80811ed:;
    float64_t v41 = -NAN; // 0x80811fd
    int32_t v42 = -600; // 0x80811fd
    int3_t v43; // 0x8081160
    int3_t v44; // 0x8081160
    int3_t v45; // 0x8081160
    int32_t v46; // 0x8081160
    int32_t v47; // 0x8081160
    int32_t v48; // 0x8081160
    float64_t v49; // 0x8081203
    int32_t v50; // 0x8081160
    int32_t v51; // 0x8081160
    if ((char)v40 != 0) {
        goto lab_0x8081338;
    } else {
        // 0x8081203
        v49 = g222;
        int3_t v52; // 0x8081160
        if ((int32_t)(float32_t)v49 < 0 || v1 < (int32_t)(float32_t)v49) {
            int3_t v53 = v52 - 1; // 0x808161b
            __frontend_reg_store_fpr(v53, (float80_t)*(float64_t *)(v39 + 152));
            int3_t v54 = v52 - 2; // 0x8081627
            __frontend_reg_store_fpr(v54, (float80_t)(v1 + 1));
            if (__frontend_reg_load_fpr(v54) < __frontend_reg_load_fpr(v53)) {
                // 0x80817a0
                v46 = v1 + (int32_t)(v1 < 0) >> 1;
                v43 = v53;
                goto lab_0x8081274;
            } else {
                // 0x8081632
                __frontend_reg_store_fpr(v54, (float80_t)*(int32_t *)(v39 + 136));
                int3_t v55 = v52 - 3; // 0x8081638
                __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v53));
                __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v55) - __frontend_reg_load_fpr(v54));
                int3_t v56 = v52 ^ -4; // 0x808163f
                __frontend_reg_store_fpr(v56, 0.5L);
                int3_t v57 = v52 + 3; // 0x8081645
                __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v53));
                __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v57) * __frontend_reg_load_fpr(v56));
                __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v57) + __frontend_reg_load_fpr(v55));
                float80_t v58 = __frontend_reg_load_fpr(v56); // 0x8081655
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v55));
                __frontend_reg_store_fpr(v55, v58);
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v56) / __frontend_reg_load_fpr(v53));
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v56));
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v56) * __frontend_reg_load_fpr(v53));
                __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v56) + __frontend_reg_load_fpr(v55));
                __frontend_reg_store_fpr(v54, __frontend_reg_load_fpr(v55) + __frontend_reg_load_fpr(v54));
                int32_t v59 = __frontend_reg_load_fpr(v54); // 0x808167f
                v50 = (float32_t)g223;
                v47 = v59;
                v44 = v53;
                v51 = (float32_t)g223;
                v48 = v59;
                v45 = v53;
                if ((int32_t)(float32_t)g223 >= 0) {
                    goto lab_0x8081285;
                } else {
                    goto lab_0x8081690;
                }
            }
        } else {
            int32_t v60 = *(int32_t *)(v39 + 136); // 0x808121a
            int3_t v61 = v52 - 1; // 0x8081222
            __frontend_reg_store_fpr(v61, (float80_t)*(float64_t *)(v39 + 152));
            int3_t v62 = v52 - 2; // 0x8081234
            __frontend_reg_store_fpr(v62, (float80_t)((int32_t)(float32_t)v49 - v60));
            int3_t v63 = v52 - 3; // 0x8081237
            __frontend_reg_store_fpr(v63, 0.5L);
            int3_t v64 = v52 ^ -4; // 0x808123d
            __frontend_reg_store_fpr(v64, __frontend_reg_load_fpr(v61));
            __frontend_reg_store_fpr(v64, __frontend_reg_load_fpr(v64) * __frontend_reg_load_fpr(v63));
            __frontend_reg_store_fpr(v62, __frontend_reg_load_fpr(v64) + __frontend_reg_load_fpr(v62));
            float80_t v65 = __frontend_reg_load_fpr(v63); // 0x8081249
            __frontend_reg_store_fpr(v63, __frontend_reg_load_fpr(v62));
            __frontend_reg_store_fpr(v62, v65);
            __frontend_reg_store_fpr(v63, __frontend_reg_load_fpr(v63) / __frontend_reg_load_fpr(v61));
            __frontend_reg_store_fpr(v63, __frontend_reg_load_fpr(v63));
            __frontend_reg_store_fpr(v63, __frontend_reg_load_fpr(v63) * __frontend_reg_load_fpr(v61));
            __frontend_reg_store_fpr(v62, __frontend_reg_load_fpr(v63) + __frontend_reg_load_fpr(v62));
            __frontend_reg_store_fpr(v63, (float80_t)v60);
            __frontend_reg_store_fpr(v62, __frontend_reg_load_fpr(v63) + __frontend_reg_load_fpr(v62));
            v46 = __frontend_reg_load_fpr(v62);
            v43 = v61;
            goto lab_0x8081274;
        }
    }
  lab_0x8081338:;
    // 0x8081338
    int32_t v66; // 0x8081160
    int32_t v67; // 0x8081160
    int32_t v68; // 0x8081160
    int32_t v69; // 0x8081160
    int32_t v70; // 0x8081160
    int32_t v71; // 0x8081160
    int32_t v72; // 0x8081160
    int32_t v73; // 0x8081160
    int3_t v74; // 0x8081160
    int3_t v75; // 0x8081160
    if (v36 == 0) {
        if ((v37 & 257) != 0) {
            // 0x80817b8
            if (gui != NULL) {
                // 0x8081858
                __frontend_reg_store_fpr(v74 - 1, (float80_t)(v42 - (int32_t)(float32_t)g222));
                int32_t v76 = *(int32_t *)(v18 + 52); // 0x8081875
                __frontend_reg_store_fpr(v74 - 2, (float80_t)((int32_t)(float32_t)v41 - (int32_t)(float32_t)g223));
                int32_t v77 = *(int32_t *)(v18 + 56); // 0x8081882
                int3_t v78 = v74 - 3; // 0x8081885
                __frontend_reg_store_fpr(v78, (float80_t)(v76 - (int32_t)(float32_t)g222));
                v75 = v78;
                v66 = v77 - (int32_t)(float32_t)g223;
                v73 = v76;
                v70 = v77;
                goto lab_0x80815e6;
            } else {
                // 0x80817cb
                v71 = *(int32_t *)(v18 + 52);
                v68 = *(int32_t *)(v18 + 56);
                goto lab_0x80813be;
            }
        } else {
            if ((v37 & 0x1000) == 0) {
                if ((v37 & 2) == 0) {
                    // 0x8081730
                    goto lab_0x80815a7;
                } else {
                    int3_t v79 = v74 - 1; // 0x8081751
                    __frontend_reg_store_fpr(v79, (float80_t)(v42 - (int32_t)(float32_t)g222));
                    int32_t v80 = *(int32_t *)(v17 + 216); // 0x8081757
                    int3_t v81 = v74 - 2; // 0x808175d
                    __frontend_reg_store_fpr(v81, (float80_t)((int32_t)(float32_t)v41 - (int32_t)(float32_t)g223));
                    int32_t v82 = *(int32_t *)(v17 + 220); // 0x8081767
                    int3_t v83 = v74 - 3; // 0x808176d
                    __frontend_reg_store_fpr(v83, (float80_t)(v80 - (int32_t)(float32_t)g222));
                    int3_t v84 = v74 ^ -4; // 0x808177b
                    __frontend_reg_store_fpr(v84, (float80_t)(v82 - (int32_t)(float32_t)g223));
                    float80_t v85 = __frontend_reg_load_fpr(v84); // 0x808177e
                    __frontend_reg_store_fpr(v84, __frontend_reg_load_fpr(v79));
                    __frontend_reg_store_fpr(v79, v85);
                    __frontend_reg_store_fpr(v84, __frontend_reg_load_fpr(v84) * __frontend_reg_load_fpr(v84));
                    float80_t v86 = __frontend_reg_load_fpr(v84); // 0x8081782
                    __frontend_reg_store_fpr(v84, __frontend_reg_load_fpr(v81));
                    __frontend_reg_store_fpr(v81, v86);
                    __frontend_reg_store_fpr(v84, __frontend_reg_load_fpr(v84) * __frontend_reg_load_fpr(v84));
                    __frontend_reg_store_fpr(v81, __frontend_reg_load_fpr(v84) + __frontend_reg_load_fpr(v81));
                    __frontend_reg_store_fpr(v83, __frontend_reg_load_fpr(v83) * __frontend_reg_load_fpr(v83));
                    float80_t v87 = __frontend_reg_load_fpr(v83); // 0x808178a
                    __frontend_reg_store_fpr(v83, __frontend_reg_load_fpr(v79));
                    __frontend_reg_store_fpr(v79, v87);
                    __frontend_reg_store_fpr(v83, __frontend_reg_load_fpr(v83) * __frontend_reg_load_fpr(v83));
                    __frontend_reg_store_fpr(v79, __frontend_reg_load_fpr(v83) + __frontend_reg_load_fpr(v79));
                    float80_t v88 = __frontend_reg_load_fpr(v81); // 0x8081790
                    float80_t v89 = __frontend_reg_load_fpr(v79); // 0x8081790
                    bool v90 = false; // 0x8081790
                    bool v91 = false; // 0x8081790
                    if (v88 <= v89) {
                        v90 = true;
                        v91 = false;
                        if (v88 >= v89) {
                            v90 = v88 != v89;
                            v91 = true;
                        }
                    }
                    __frontend_reg_store_fpr(v79, __frontend_reg_load_fpr(v79));
                    v67 = v38;
                    v72 = v80;
                    v69 = v82;
                    if (v90 || v91) {
                        goto lab_0x80815a7;
                    } else {
                        goto lab_0x80813c4;
                    }
                }
            } else {
                int32_t v92 = v42 - (int32_t)(float32_t)g222; // 0x808154b
                int32_t v93 = (int32_t)(float32_t)v41 - (int32_t)(float32_t)g223; // 0x8081554
                int32_t v94 = *(int32_t *)v19; // 0x808155a
                int32_t v95 = *(int32_t *)(v19 + 4); // 0x808155c
                int32_t v96 = v94 - (int32_t)(float32_t)g222; // 0x8081567
                int32_t v97 = v95 - (int32_t)(float32_t)g223; // 0x8081572
                v67 = v38;
                v72 = v94;
                v69 = v95;
                if (v93 * v93 + v92 * v92 > v97 * v97 + v96 * v96) {
                    goto lab_0x80813c4;
                } else {
                    goto lab_0x80815a7;
                }
            }
        }
    } else {
        int32_t v98 = *(int32_t *)(v18 + 44); // 0x8081346
        int32_t v99 = *(int32_t *)(v18 + 48); // 0x8081354
        int3_t v100 = v74 - 1; // 0x8081357
        __frontend_reg_store_fpr(v100, (float80_t)(v98 - (int32_t)(float32_t)g222));
        int32_t v101 = *(int32_t *)(v18 + 64); // 0x8081365
        int32_t v102 = *(int32_t *)(v18 + 68); // 0x8081368
        int3_t v103 = v74 - 2; // 0x808136b
        __frontend_reg_store_fpr(v103, (float80_t)(v99 - (int32_t)(float32_t)g223));
        int3_t v104 = v74 - 3; // 0x8081381
        __frontend_reg_store_fpr(v104, (float80_t)(v101 - (int32_t)(float32_t)g222));
        int3_t v105 = v74 ^ -4; // 0x8081387
        __frontend_reg_store_fpr(v105, (float80_t)(v102 - (int32_t)(float32_t)g223));
        float80_t v106 = __frontend_reg_load_fpr(v105); // 0x808138a
        __frontend_reg_store_fpr(v105, __frontend_reg_load_fpr(v100));
        __frontend_reg_store_fpr(v100, v106);
        __frontend_reg_store_fpr(v105, __frontend_reg_load_fpr(v105) * __frontend_reg_load_fpr(v105));
        float80_t v107 = __frontend_reg_load_fpr(v105); // 0x808138e
        __frontend_reg_store_fpr(v105, __frontend_reg_load_fpr(v103));
        __frontend_reg_store_fpr(v103, v107);
        __frontend_reg_store_fpr(v105, __frontend_reg_load_fpr(v105) * __frontend_reg_load_fpr(v105));
        __frontend_reg_store_fpr(v103, __frontend_reg_load_fpr(v105) + __frontend_reg_load_fpr(v103));
        __frontend_reg_store_fpr(v104, __frontend_reg_load_fpr(v104) * __frontend_reg_load_fpr(v104));
        float80_t v108 = __frontend_reg_load_fpr(v104); // 0x8081396
        __frontend_reg_store_fpr(v104, __frontend_reg_load_fpr(v100));
        __frontend_reg_store_fpr(v100, v108);
        __frontend_reg_store_fpr(v104, __frontend_reg_load_fpr(v104) * __frontend_reg_load_fpr(v104));
        __frontend_reg_store_fpr(v100, __frontend_reg_load_fpr(v104) + __frontend_reg_load_fpr(v100));
        float80_t v109 = __frontend_reg_load_fpr(v103); // 0x808139c
        __frontend_reg_store_fpr(v103, __frontend_reg_load_fpr(v100));
        __frontend_reg_store_fpr(v100, v109);
        float80_t v110 = __frontend_reg_load_fpr(v103); // 0x808139e
        float80_t v111 = __frontend_reg_load_fpr(v100); // 0x808139e
        bool v112 = false; // 0x808139e
        bool v113 = false; // 0x808139e
        if (v110 <= v111) {
            v112 = true;
            v113 = false;
            if (v110 >= v111) {
                v112 = v110 != v111;
                v113 = true;
            }
        }
        __frontend_reg_store_fpr(v100, __frontend_reg_load_fpr(v100));
        bool v114 = v112 | v113; // 0x80813a2
        int32_t v115 = v114 ? v102 : v99; // 0x80813a2
        int32_t v116 = v114 ? v101 : v98; // 0x80813aa
        v71 = v116;
        v68 = v115;
        if (gui != NULL) {
            // 0x80815b8
            __frontend_reg_store_fpr(v100, (float80_t)(v42 - (int32_t)(float32_t)g222));
            __frontend_reg_store_fpr(v103, (float80_t)((int32_t)(float32_t)v41 - (int32_t)(float32_t)g223));
            __frontend_reg_store_fpr(v104, (float80_t)(v116 - (int32_t)(float32_t)g222));
            v75 = v104;
            v66 = v115 - (int32_t)(float32_t)g223;
            v73 = v116;
            v70 = v115;
            goto lab_0x80815e6;
        } else {
            goto lab_0x80813be;
        }
    }
  lab_0x80813be:
    // 0x80813be
    v67 = g148;
    v72 = v71;
    v69 = v68;
    goto lab_0x80813c4;
  lab_0x8081274:
    // 0x8081274
    v50 = (float32_t)g223;
    v47 = v46;
    v44 = v43;
    v51 = (float32_t)g223;
    v48 = v46;
    v45 = v43;
    if ((int32_t)(float32_t)g223 < 0) {
        goto lab_0x8081690;
    } else {
        goto lab_0x8081285;
    }
  lab_0x80815e6:;
    int3_t v161 = v75;
    int3_t v162 = v161 - 1; // 0x80815e9
    __frontend_reg_store_fpr(v162, (float80_t)v66);
    int3_t v163 = v161 + 2; // 0x80815ec
    float80_t v164 = __frontend_reg_load_fpr(v162); // 0x80815ec
    __frontend_reg_store_fpr(v162, __frontend_reg_load_fpr(v163));
    __frontend_reg_store_fpr(v163, v164);
    __frontend_reg_store_fpr(v162, __frontend_reg_load_fpr(v162) * __frontend_reg_load_fpr(v162));
    int3_t v165 = v161 + 1; // 0x80815f0
    float80_t v166 = __frontend_reg_load_fpr(v162); // 0x80815f0
    __frontend_reg_store_fpr(v162, __frontend_reg_load_fpr(v165));
    __frontend_reg_store_fpr(v165, v166);
    __frontend_reg_store_fpr(v162, __frontend_reg_load_fpr(v162) * __frontend_reg_load_fpr(v162));
    __frontend_reg_store_fpr(v165, __frontend_reg_load_fpr(v162) + __frontend_reg_load_fpr(v165));
    float80_t v167 = __frontend_reg_load_fpr(v161); // 0x80815f6
    __frontend_reg_store_fpr(v161, v167 * __frontend_reg_load_fpr(v161));
    float80_t v168 = __frontend_reg_load_fpr(v161); // 0x80815f8
    __frontend_reg_store_fpr(v161, __frontend_reg_load_fpr(v163));
    __frontend_reg_store_fpr(v163, v168);
    float80_t v169 = __frontend_reg_load_fpr(v161); // 0x80815fa
    __frontend_reg_store_fpr(v161, v169 * __frontend_reg_load_fpr(v161));
    __frontend_reg_store_fpr(v163, __frontend_reg_load_fpr(v161) + __frontend_reg_load_fpr(v163));
    float80_t v170 = __frontend_reg_load_fpr(v165); // 0x80815fe
    float80_t v171 = __frontend_reg_load_fpr(v163); // 0x80815fe
    bool v172 = false; // 0x80815fe
    bool v173 = false; // 0x80815fe
    if (v170 <= v171) {
        v172 = true;
        v173 = false;
        if (v170 >= v171) {
            v172 = v170 != v171;
            v173 = true;
        }
    }
    __frontend_reg_store_fpr(v163, __frontend_reg_load_fpr(v163));
    v71 = v73;
    v68 = v70;
    if (v172 || v173) {
        // 0x8081608
        v67 = g148;
        v72 = v42;
        v69 = (float32_t)v41;
        goto lab_0x80813c4;
    } else {
        goto lab_0x80813be;
    }
  lab_0x80813c4:
    // 0x80813c4
    if (v72 >= 0 && v69 >= 0) {
        // 0x80813cc
        g222 = (int64_t)v72;
        g223 = (int64_t)v69;
    }
    int32_t v117 = v67; // 0x80813db
    if (v67 == 110) {
        int32_t v118 = SearchScreen((int32_t)(float32_t)g222, (int32_t)(float32_t)g223, 0x1000, (char **)&v17, (char **)&v18, (char **)&v19); // 0x8081836
        if (v118 == 0) {
            // 0x8081898
            hid_action((char *)(int32_t)(float32_t)(float64_t)(int64_t)(int32_t)"PointCursor");
            v117 = g148;
        } else {
            // 0x808183f
            if ((*(char *)(v18 + 20) & 64) == 0) {
                // 0x80818b0
                hid_actionl((char *)(int32_t)(float32_t)(float64_t)(int64_t)(int32_t)"PointCursor");
            }
            // 0x8081848
            v117 = g148;
        }
    }
    // 0x80813e1
    if (v117 != 2 || g233 == 0) {
        // 0x80813ea
        return;
    }
    // 0x8081715
    if (*(char *)&vyl < 0) {
        // 0x8081724
        EnforceLineDRC();
    }
  lab_0x8081285:;
    int3_t v119 = v44;
    v51 = v50;
    v48 = v47;
    v45 = v119;
    int3_t v120; // 0x8081160
    int32_t v121; // 0x8081160
    int32_t v122; // 0x8081160
    int32_t v123; // 0x8081160
    if (v50 > (int32_t)(float32_t)v2) {
        goto lab_0x8081690;
    } else {
        int32_t v124 = *(int32_t *)(v39 + 140); // 0x808128e
        int3_t v125 = v119 - 1; // 0x80812a3
        __frontend_reg_store_fpr(v125, (float80_t)(v50 - v124));
        int3_t v126 = v119 - 2; // 0x80812a6
        __frontend_reg_store_fpr(v126, 0.5L);
        float80_t v127 = __frontend_reg_load_fpr(v119); // 0x80812ac
        int3_t v128 = v119 - 3; // 0x80812ac
        __frontend_reg_store_fpr(v128, v127);
        __frontend_reg_store_fpr(v128, __frontend_reg_load_fpr(v128) * __frontend_reg_load_fpr(v126));
        __frontend_reg_store_fpr(v125, __frontend_reg_load_fpr(v128) + __frontend_reg_load_fpr(v125));
        float80_t v129 = __frontend_reg_load_fpr(v126); // 0x80812b8
        __frontend_reg_store_fpr(v126, __frontend_reg_load_fpr(v125));
        __frontend_reg_store_fpr(v125, v129);
        __frontend_reg_store_fpr(v126, __frontend_reg_load_fpr(v126) / __frontend_reg_load_fpr(v119));
        __frontend_reg_store_fpr(v126, __frontend_reg_load_fpr(v126));
        float80_t v130 = __frontend_reg_load_fpr(v126); // 0x80812ce
        __frontend_reg_store_fpr(v119, v130 * __frontend_reg_load_fpr(v119));
        float80_t v131 = __frontend_reg_load_fpr(v125); // 0x80812d3
        __frontend_reg_store_fpr(v119, v131 + __frontend_reg_load_fpr(v119));
        __frontend_reg_store_fpr(v125, (float80_t)v124);
        float80_t v132 = __frontend_reg_load_fpr(v125); // 0x80812d8
        __frontend_reg_store_fpr(v119, v132 + __frontend_reg_load_fpr(v119));
        v122 = v50;
        v123 = __frontend_reg_load_fpr(v119);
        v121 = v47;
        v120 = v119;
        goto lab_0x80812e3;
    }
  lab_0x8081690:;
    int3_t v133 = v45;
    int3_t v134 = v133 - 1; // 0x8081699
    __frontend_reg_store_fpr(v134, (float80_t)((int32_t)(float32_t)v2 + 1));
    int3_t v135; // 0x8081160
    int3_t v136; // 0x8081160
    int32_t v137; // 0x8081160
    int32_t v138; // 0x8081160
    int32_t v139; // 0x8081160
    int32_t v140; // 0x8081160
    int32_t v141; // 0x8081160
    if (__frontend_reg_load_fpr(v134) < __frontend_reg_load_fpr(v133)) {
        // 0x80817f0
        __frontend_reg_store_fpr(v133, __frontend_reg_load_fpr(v133));
        v122 = v51;
        v123 = (int32_t)((int32_t)(float32_t)v2 < 0) + (int32_t)(float32_t)v2 >> 1;
        v121 = v48;
        v120 = v133;
        goto lab_0x80812e3;
    } else {
        // 0x80816a4
        __frontend_reg_store_fpr(v134, (float80_t)*(int32_t *)(v39 + 140));
        float80_t v142 = __frontend_reg_load_fpr(v133); // 0x80816aa
        int3_t v143 = v133 - 2; // 0x80816aa
        __frontend_reg_store_fpr(v143, v142);
        __frontend_reg_store_fpr(v143, __frontend_reg_load_fpr(v143) - __frontend_reg_load_fpr(v134));
        int3_t v144 = v133 - 3; // 0x80816b8
        __frontend_reg_store_fpr(v144, 0.5L);
        float80_t v145 = __frontend_reg_load_fpr(v133); // 0x80816be
        int3_t v146 = v133 ^ -4; // 0x80816be
        __frontend_reg_store_fpr(v146, v145);
        __frontend_reg_store_fpr(v146, __frontend_reg_load_fpr(v146) * __frontend_reg_load_fpr(v144));
        __frontend_reg_store_fpr(v143, __frontend_reg_load_fpr(v146) + __frontend_reg_load_fpr(v143));
        float80_t v147 = __frontend_reg_load_fpr(v144); // 0x80816ce
        __frontend_reg_store_fpr(v144, __frontend_reg_load_fpr(v143));
        __frontend_reg_store_fpr(v143, v147);
        __frontend_reg_store_fpr(v144, __frontend_reg_load_fpr(v144) / __frontend_reg_load_fpr(v133));
        __frontend_reg_store_fpr(v144, __frontend_reg_load_fpr(v144));
        float80_t v148 = __frontend_reg_load_fpr(v144); // 0x80816e4
        __frontend_reg_store_fpr(v133, v148 * __frontend_reg_load_fpr(v133));
        float80_t v149 = __frontend_reg_load_fpr(v143); // 0x80816e6
        __frontend_reg_store_fpr(v133, v149 + __frontend_reg_load_fpr(v133));
        float80_t v150 = __frontend_reg_load_fpr(v134); // 0x80816e8
        __frontend_reg_store_fpr(v133, v150 + __frontend_reg_load_fpr(v133));
        int32_t v151 = __frontend_reg_load_fpr(v133); // 0x80816ed
        int3_t v152 = v133 + 1; // 0x80816ed
        v139 = v51;
        v140 = v151;
        v137 = v48;
        v135 = v152;
        v141 = v151;
        v138 = v48;
        v136 = v152;
        if (*(char *)&Marked != 0) {
            goto lab_0x80812f0;
        } else {
            goto lab_0x80816f9;
        }
    }
  lab_0x80815a7:
    // 0x80815a7
    v67 = v38;
    v72 = v42;
    v69 = (float32_t)v41;
    goto lab_0x80813c4;
  lab_0x80812e3:;
    int3_t v153 = v120 + 1;
    v139 = v122;
    v140 = v123;
    v137 = v121;
    v135 = v153;
    v141 = v123;
    v138 = v121;
    v136 = v153;
    if (*(char *)&Marked == 0) {
        goto lab_0x80816f9;
    } else {
        goto lab_0x80812f0;
    }
  lab_0x80812f0:
    // 0x80812f0
    v141 = v140;
    v138 = v137;
    v136 = v135;
    if (*(int16_t *)(v39 + 4) >= 0) {
        goto lab_0x80816f9;
    } else {
        int32_t v154 = (int32_t)(float32_t)v49 - (int32_t)(float32_t)g217; // 0x8081307
        int32_t v155 = v154 < 0 ? -v154 : v154; // 0x8081313
        int32_t v156 = v139 - (int32_t)(float32_t)g218; // 0x8081318
        int32_t v157 = v156 < 0 ? -v156 : v156; // 0x8081322
        int32_t v158 = v155 - v157; // 0x8081327
        int32_t v159 = v158 < 0 == ((v158 ^ v155) & (v157 ^ v155)) < 0 == (v158 != 0) ? (int32_t)(float32_t)g218 : v140; // 0x8081329
        int32_t v160 = v158 < 0 == ((v158 ^ v155) & (v157 ^ v155)) < 0 == (v158 != 0) ? v137 : (int32_t)(float32_t)g217; // 0x808132d
        v41 = (int64_t)v159;
        v74 = v135;
        v42 = v160;
        goto lab_0x8081338;
    }
  lab_0x80816f9:
    // 0x80816f9
    v41 = (int64_t)v141;
    v74 = v136;
    v42 = v138;
    goto lab_0x8081338;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x80818e0 - 0x8081904
// Line range:    967 - 969
void MoveCrosshairRelative(int32_t DeltaX, int32_t DeltaY) {
    // 0x80818e0
    FitCrosshairIntoGrid((int32_t)(float32_t)g222 + DeltaX, (int32_t)(float32_t)g223 + DeltaY);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081910 - 0x8081974
// Line range:    1004 - 1013
void SetCrosshairRange(int32_t MinX, int32_t MinY, int32_t MaxX, int32_t MaxY) {
    // 0x8081910
    g225 = MinY >= 0 ? MinY : 0;
    g224 = MinX > 0 ? MinX : 0;
    int32_t v1 = Marked; // 0x808193d
    int32_t v2 = MaxX - v1; // 0x8081943
    g226 = v2 == 0 | v2 < 0 != ((v2 ^ MaxX) & (v1 ^ MaxX)) < 0 ? MaxX : v1;
    float64_t v3 = g217; // 0x808194e
    int32_t v4 = MaxY - (int32_t)(float32_t)v3; // 0x8081954
    int32_t v5 = v4 == 0 | v4 < 0 != ((v4 ^ MaxY) & ((int32_t)(float32_t)v3 ^ MaxY)) < 0 ? MaxY : (int32_t)(float32_t)v3; // 0x8081956
    g227 = (int64_t)v5;
    MoveCrosshairRelative(0, 0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081980 - 0x8081cb0
// Line range:    111 - 163
void XORDrawAttachedArc(int32_t thick) {
    int32_t v1 = __readgsdword(20); // 0x8081992
    if ((int32_t)(float32_t)g223 != (int32_t)(float32_t)g236 || (int32_t)(float32_t)g222 != (int32_t)g235) {
        // 0x80819bd
        int32_t v2; // bp-100, 0x8081980
        GetArcEnds(&v2);
    }
    // 0x8081a9b
    if (v1 == __readgsdword(20)) {
        // 0x8081aab
        return;
    }
    // 0x8081ca5
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081cb0 - 0x8081f06
// Line range:    169 - 181
void XORDrawAttachedLine(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t thick) {
    int32_t v1 = 0; // 0x8081cc2
    int32_t v2; // 0x8081cb0
    int32_t v3 = x1 - v2; // 0x8081cc7
    float80_t v4 = 0.0L; // 0x8081cc9
    float80_t v5 = 0.0L; // 0x8081cc9
    float80_t v6 = 0.0L; // 0x8081cc9
    float80_t v7 = 0.0L; // 0x8081cc9
    if ((v1 || v3) != 0) {
        // 0x8081cf0
        v7 = v1;
        float80_t v8 = v3; // 0x8081cfc
        v5 = 0.5L * (float80_t)y1 / sqrtl(v8 * v8 + v7 * v7);
        v6 = v3 < 1 ? v3 == 0 ? 0.0L : -0.5L : 0.5L;
        v4 = v5 * v8;
    }
    int32_t v9 = v4 + v6; // 0x8081d43
    if ((v9 < 0 ? -v9 : v9) >= pixel_slop) {
        // 0x8081dea
        atan2((float64_t)v7, (float64_t)(int64_t)(v2 + v9));
        // 0x8081ec4
        return;
    }
    int32_t v10 = -(((v1 < 1 ? v1 != 0 ? -0.5L : 0.0L : 0.5L) + v5 * v7)); // 0x8081d66
    if (pixel_slop > (v10 < 0 ? -v10 : v10)) {
        // 0x8081ec4
        return;
    }
    // 0x8081dea
    atan2((float64_t)v7, (float64_t)(int64_t)(v2 + v9));
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081f10 - 0x8082a86
// Line range:    580 - 484
void DrawAttached(char BlockToo) {
    // 0x8081f10
    int32_t v1; // 0x8081f10
    uint32_t v2 = v1;
    if (g148 == 5) {
        int32_t v3 = 28 * (int32_t)g149; // 0x80823a0
        int32_t v4 = (int32_t)PCB; // 0x80823bf
        int32_t v5 = *(int32_t *)(v4 + 0x220c); // 0x80823cb
        if (*(int32_t *)(v5 + 24) != -2) {
            int32_t * v6 = PCB;
            int32_t v7 = v5; // 0x80825bf
            int32_t v8 = v4;
            for (int32_t i = 0; i < *(int32_t *)(v7 + 24) + 2; i++) {
                int32_t * v9 = v6;
                int32_t v10 = 92 * i; // 0x80823e8
                int32_t * v11 = v9; // 0x80823f4
                int32_t v12 = v8; // 0x80823f4
                if (*(char *)(v7 + 144 + v10) != 0) {
                    int32_t v13 = *(int32_t *)(v3 + (int32_t)&Buffers + 24) + v10; // 0x8082400
                    int32_t v14 = *(int32_t *)(v13 + 80); // 0x8082402
                    int32_t v15 = v14; // 0x808240e
                    if (v14 != 0) {
                        int32_t v16 = v15 - 1;
                        v15 = v16;
                        while (v16 != 0) {
                            // 0x8082428
                            v16 = v15 - 1;
                            v15 = v16;
                        }
                    }
                    int32_t v17 = *(int32_t *)(v13 + 92); // 0x808247e
                    int32_t v18 = v17; // 0x8082487
                    if (v17 != 0) {
                        int32_t v19 = v18 - 1;
                        v18 = v19;
                        while (v19 != 0) {
                            // 0x80824a0
                            v19 = v18 - 1;
                            v18 = v19;
                        }
                    }
                    int32_t v20 = *(int32_t *)(v13 + 84); // 0x80824fc
                    int32_t v21 = v20; // 0x8082505
                    if (v20 != 0) {
                        int32_t v22 = v21 - 1;
                        v21 = v22;
                        while (v22 != 0) {
                            // 0x8082520
                            v22 = v21 - 1;
                            v21 = v22;
                        }
                    }
                    int32_t v23 = *(int32_t *)(v13 + 88); // 0x8082575
                    int32_t v24 = v23; // 0x808257e
                    int32_t * v25 = v9; // 0x808257e
                    if (v23 != 0) {
                        int32_t v26 = v24 - 1;
                        XORPolygon(&g279, (int32_t)&g279, (int32_t)&g279);
                        v24 = v26;
                        while (v26 != 0) {
                            // 0x8082598
                            v26 = v24 - 1;
                            XORPolygon(&g279, (int32_t)&g279, (int32_t)&g279);
                            v24 = v26;
                        }
                        // 0x80825b9
                        v25 = PCB;
                    }
                    // 0x80825b9
                    v11 = v25;
                    v12 = (int32_t)v11;
                }
                // 0x80825bf
                v8 = v12;
                v6 = v11;
                v7 = *(int32_t *)(v8 + 0x220c);
            }
        }
        // 0x80825d8
        if (*(char *)&g204 == 0 | *(char *)&g201 == 0) {
            // 0x8082090
            return;
        }
        int32_t * v27 = (int32_t *)(v3 + (int32_t)&Buffers + 24); // 0x80825eb
        int32_t v28 = *v27; // 0x80825eb
        int32_t v29 = *(int32_t *)(v28 + 8); // 0x80825ee
        if (v29 == 0) {
            // 0x8082090
            return;
        }
        int32_t v30 = v29; // 0x808260c
        int32_t v31 = 300 * v29; // 0x808260c
        v31 -= 300;
        uint32_t v32 = *(int32_t *)(*(int32_t *)(v28 + 32) + 20 + v31); // 0x8082623
        char v33 = *(char *)&g203; // 0x8082636
        if (v33 == 0 != v32 / 128 % 2 != (int32_t)g177) {
            // 0x808263c
            XORDrawElement(&g279, (int32_t)&g279, (int32_t)&g279);
        }
        // 0x8082646
        v30--;
        while (v30 != 0) {
            // 0x8082610
            v31 -= 300;
            v32 = *(int32_t *)(*(int32_t *)(*v27 + 32) + 20 + v31);
            v33 = *(char *)&g203;
            if (v33 == 0 != v32 / 128 % 2 != (int32_t)g177) {
                // 0x808263c
                XORDrawElement(&g279, (int32_t)&g279, (int32_t)&g279);
            }
            // 0x8082646
            v30--;
        }
        // 0x8082090
        return;
    }
    int32_t * v34 = (int32_t *)(v2 % 256); // 0x8081f19
    if (g148 <= 5) {
        if (g148 != 2) {
            // 0x8082079
            if (g148 == 4 && g241 >= 2) {
                // 0x808212b
                XORPolygon(v34, (int32_t)&g279, (int32_t)&g279);
            }
            // 0x8082090
            return;
        }
        // 0x808217c
        if (g233 == 0 || g234 == 0) {
            // 0x8082090
            return;
        }
        int32_t v35 = g206 == 0 ? g136 : 10; // 0x80821b3
        XORDrawAttachedLine((int32_t)(float32_t)g232, v35, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
        if (g209 != 0) {
            int32_t v36 = g206 == 0 ? g136 : 10; // 0x80821f1
            XORDrawAttachedLine((int32_t)(float32_t)g223, v36, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
        }
        // 0x808220e
        if ((*(char *)&vyl & 8) == 0) {
            // 0x8082090
            return;
        }
        int32_t v37 = 10; // 0x8082240
        if (g206 == 0) {
            // 0x8082242
            v37 = g136 + 2 + 2 * g210;
        }
        // 0x808224f
        XORDrawAttachedLine((int32_t)(float32_t)g232, v37, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
        if (g209 == 0) {
            // 0x8082090
            return;
        }
        int32_t v38 = 10; // 0x808228a
        if (g206 == 0) {
            // 0x808228c
            v38 = g136 + 2 + 2 * g210;
        }
        // 0x8082299
        XORDrawAttachedLine((int32_t)(float32_t)g223, v38, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
        // 0x8082090
        return;
    }
    if (g148 == 106) {
        // 0x8082090
        return;
    }
    if (g148 > 106) {
        // 0x80820b8
        if (g148 != 109 || g239 == 0) {
            // 0x8082090
            return;
        }
        // 0x80820c6
        XORDrawAttachedArc(0x1000000 * v2 / 0x1000000);
        if ((*(char *)&vyl & 8) != 0) {
            // 0x80820db
            XORDrawAttachedArc(Crosshair);
        }
        // 0x8082090
        return;
    }
    if (g148 < 104) {
        // 0x8082090
        return;
    }
    int32_t v39 = (int32_t)(float32_t)g223 - g242; // 0x8081f6f
    if (g243 == 256) {
        // 0x8082a2c
        XORDrawElement(v34, (int32_t)&g279, (int32_t)&g279);
        goto lab_0x8081fc8;
    } else {
        if (g243 > 256) {
            if (g243 == 2048) {
                goto lab_0x8081fc8;
            } else {
                if (g243 > 2048) {
                    if (g243 == 0x1000) {
                        int32_t v40 = *(int32_t *)(g246 + 36);
                        if (g246 + 44 == (int32_t)(float32_t)g247) {
                            int32_t v41 = *(int32_t *)(g246 + 68); // 0x8082a56
                            XORDrawAttachedLine(v41, v40, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
                        } else {
                            int32_t v42 = *(int32_t *)(g246 + 48); // 0x808292e
                            XORDrawAttachedLine(v42, v40, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
                        }
                    }
                    goto lab_0x8081fc8;
                } else {
                    if (g243 == 512) {
                        // 0x8082a2c
                        XORDrawElement(v34, (int32_t)&g279, (int32_t)&g279);
                        goto lab_0x8081fc8;
                    } else {
                        goto lab_0x8081fc8;
                    }
                }
            }
        } else {
            if (g243 == 4) {
                int32_t v43 = *(int32_t *)(g246 + 36); // 0x80828de
                int32_t v44 = *(int32_t *)(g246 + 68); // 0x80828ee
                XORDrawAttachedLine(v44 + v39, v43, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
                goto lab_0x8081fc8;
            } else {
                if (g243 > 4) {
                    if (g243 == 8) {
                        // 0x8082a17
                        XORPolygon(v34, (int32_t)&g279, (int32_t)&g279);
                    }
                    goto lab_0x8081fc8;
                } else {
                    if (g243 == 2) {
                        // 0x8082a2c
                        XORDrawElement(v34, (int32_t)&g279, (int32_t)&g279);
                        goto lab_0x8081fc8;
                    } else {
                        goto lab_0x8081fc8;
                    }
                }
            }
        }
    }
  lab_0x8081fc8:
    // 0x8081fc8
    if (g248 == 0) {
        // 0x8082090
        return;
    }
    int32_t v45 = (int32_t)g249;
    int32_t v46 = *(int32_t *)(v45 + 4); // 0x8082024
    int32_t v47 = *(int32_t *)(v46 + 20); // 0x8082027
    int32_t v48; // 0x8081fe0
    int32_t v49; // 0x8081ff6
    int32_t v50; // 0x8082009
    int32_t v51; // 0x808204a
    int32_t v52; // 0x8082057
    if ((v47 & 2) == 0) {
        if ((v47 & 512) != 0) {
            // 0x8081fe0
            v48 = *(int32_t *)(v45 + 8);
            v49 = *(int32_t *)(v46 + 36);
            v50 = *(int32_t *)((v48 == v46 + 44 ? v48 : v46 + 64) + 4);
            XORDrawAttachedLine(v50 + v39, v49, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
        } else {
            // 0x8082033
            if (*(int32_t *)(v45 + 8) == v46 + 44) {
                // 0x808203b
                v51 = *(int32_t *)(v46 + 36);
                v52 = *(int32_t *)(v46 + 68);
                XORDrawAttachedLine(v52 + v39, v51, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            }
        }
    }
    int32_t v53 = g248 - 1; // 0x808201c
    int32_t v54 = v45 + 12; // 0x808201f
    int32_t v55 = v53; // 0x808201f
    while (v53 != 0) {
        // 0x8082024
        v45 = v54;
        v46 = *(int32_t *)(v45 + 4);
        v47 = *(int32_t *)(v46 + 20);
        if ((v47 & 2) == 0) {
            if ((v47 & 512) != 0) {
                // 0x8081fe0
                v48 = *(int32_t *)(v45 + 8);
                v49 = *(int32_t *)(v46 + 36);
                v50 = *(int32_t *)((v48 == v46 + 44 ? v48 : v46 + 64) + 4);
                XORDrawAttachedLine(v50 + v39, v49, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            } else {
                // 0x8082033
                if (*(int32_t *)(v45 + 8) == v46 + 44) {
                    // 0x808203b
                    v51 = *(int32_t *)(v46 + 36);
                    v52 = *(int32_t *)(v46 + 68);
                    XORDrawAttachedLine(v52 + v39, v51, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
                }
            }
        }
        // 0x808201c
        v53 = v55 - 1;
        v54 = v45 + 12;
        v55 = v53;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082a90 - 0x8082ac4
// Line range:    715 - 721
void CrosshairOff(char BlockToo) {
    // 0x8082a90
    if (g228 == 0) {
        // 0x8082aa3
        return;
    }
    // 0x8082aa8
    g228 = 0;
    int32_t v1; // 0x8082a90
    DrawAttached((char)v1);
    DrawMark(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082b00 - 0x8082b57
// Line range:    738 - 751
void HideCrosshair(char BlockToo) {
    // 0x8082b00
    if (CrosshairStackLocation > 15) {
        // 0x8082b38
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Error: CrosshairStackLocation overflow\n");
        return;
    }
    // 0x8082b14
    CrosshairStack[0] = g228;
    CrosshairStackLocation++;
    int32_t v1; // 0x8082b00
    CrosshairOff((char)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082bf0 - 0x8082c24
// Line range:    701 - 707
void CrosshairOn(char BlockToo) {
    // 0x8082bf0
    if (g228 != 0) {
        // 0x8082c03
        return;
    }
    // 0x8082c08
    g228 = 1;
    int32_t v1; // 0x8082bf0
    DrawAttached((char)v1);
    DrawMark(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082c30 - 0x8082c97
// Line range:    757 - 776
void RestoreCrosshair(char BlockToo) {
    // 0x8082c30
    if (CrosshairStackLocation < 1) {
        // 0x8082c78
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Error: CrosshairStackLocation underflow\n");
        return;
    }
    // 0x8082c43
    int32_t v1; // 0x8082c30
    char v2 = v1; // 0x8082c30
    CrosshairStackLocation--;
    if (g50 != 0) {
        // 0x8082c68
        CrosshairOn(v2);
        return;
    }
    // 0x8082c55
    CrosshairOff(v2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/djopt.c
// Address range: 0x8086d30 - 0x8086d4c
// Line range:    3088 - 3088
void register_djopt_action_list(void) {
    // 0x8086d30
    hid_register_actions(&djopt_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/djopt.c
// Address range: 0x8086d50 - 0x8086d6c
// Line range:    154 - 154
void register_djopt_flag_list(void) {
    // 0x8086d50
    hid_register_flags(&djopt_flag_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8088fc0 - 0x808906d
// Line range:    121 - 146
void SetPVColor(int32_t * Pin, int32_t Type) {
    // 0x8088fc0
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089340 - 0x808949f
// Line range:    942 - 999
void DrawSpecialPolygon(int32_t * hid, int32_t * DrawGC, int32_t X, int32_t Y, int32_t Thickness) {
    int32_t v1 = (int32_t)DrawGC;
    if (g53 != v1) {
        // 0x8089360
        g53 = v1;
        float80_t v2 = v1; // 0x808936e
        int32_t v3 = 0;
        int32_t v4 = 4 * v3; // 0x8089380
        float64_t v5 = *(float64_t *)(v4 + (int32_t)&g1); // 0x8089380
        *(int32_t *)(v3 + (int32_t)&g52) = (int32_t)(v2 * (float80_t)v5);
        float64_t v6 = *(float64_t *)(v4 + (int32_t)&g2); // 0x8089395
        *(int32_t *)(v3 + (int32_t)&g51) = (int32_t)(v2 * (float80_t)v6);
        int32_t v7 = v3 + 4; // 0x80893b0
        while (v3 != 28) {
            // 0x8089380
            v3 = v7;
            v4 = 4 * v3;
            v5 = *(float64_t *)(v4 + (int32_t)&g1);
            *(int32_t *)(v3 + (int32_t)&g52) = (int32_t)(v2 * (float80_t)v5);
            v6 = *(float64_t *)(v4 + (int32_t)&g2);
            *(int32_t *)(v3 + (int32_t)&g51) = (int32_t)(v2 * (float80_t)v6);
            v7 = v3 + 4;
        }
    }
    // 0x80893b4
    int32_t v8; // bp-100, 0x8089340
    int32_t v9 = &v8; // 0x80893bc
    for (int32_t i = 0; i < 8; i++) {
        int32_t v10 = 4 * i; // 0x80893c0
        int32_t v11 = *(int32_t *)(v10 + (int32_t)&g52); // 0x80893c0
        int32_t v12; // bp-64, 0x8089340
        int32_t v13; // 0x8089340
        *(int32_t *)(v10 + (int32_t)&v12) = v11 + v13;
        int32_t v14 = *(int32_t *)(v10 + (int32_t)&g51); // 0x80893cc
        *(int32_t *)(v10 + v9) = v14 + (int32_t)hid;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x80894a0 - 0x80898d1
// Line range:    1005 - 1053
void DrawPinOrViaLowLevel(int32_t * Ptr, char drawHole) {
    // 0x80894a0
    int32_t v1; // 0x80894a0
    int32_t v2 = v1;
    if (Gathering == 0) {
        int32_t v3 = *(int32_t *)(v2 + 20); // 0x80894c0
        if ((v3 & 8) != 0) {
            // 0x80894cf
            return;
        }
        if ((v3 & 256) != 0) {
            // 0x80894cf
            return;
        }
        if ((v3 & 2048) != 0) {
            int32_t v4 = *(int32_t *)(v2 + 36); // 0x80898ac
            int32_t v5 = *(int32_t *)(v2 + 56); // 0x80898bc
            DrawSpecialPolygon((int32_t *)v5, (int32_t *)v4, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
        }
        // 0x80894cf
        return;
    }
    int32_t v6 = Block; // 0x80895ca
    int32_t v7 = v6 - v2; // 0x80895ca
    Block = v7 == 0 | v7 < 0 != ((v7 ^ v6) & (v6 ^ v2)) < 0 ? v6 : v2;
    int32_t v8 = *(int32_t *)(v2 + 8); // 0x80895dc
    int32_t v9 = g55; // 0x80895df
    int32_t v10 = v9 - v8; // 0x80895df
    g55 = v10 < 0 == ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
    int32_t v11 = *(int32_t *)(v2 + 4); // 0x80895f1
    int32_t v12 = g54; // 0x80895f4
    int32_t v13 = v12 - v11; // 0x80895f4
    g54 = v13 == 0 | v13 < 0 != ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
    int32_t v14 = *(int32_t *)(v2 + 12); // 0x8089606
    int32_t v15 = g56; // 0x8089609
    int32_t v16 = v15 - v14; // 0x8089609
    g56 = v16 < 0 == ((v16 ^ v15) & (v15 ^ v14)) < 0 ? v15 : v14;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089ca0 - 0x8089d9a
// Line range:    1569 - 1579
void DrawLineLowLevel(int32_t * Line, char HaveGathered) {
    // 0x8089ca0
    int32_t v1; // 0x8089ca0
    int32_t v2 = v1;
    if ((char)v1 != 0 || Gathering == 0) {
        // 0x8089d4a
        return;
    }
    int32_t v3 = Block; // 0x8089cb8
    int32_t v4 = v3 - v2; // 0x8089cb8
    Block = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0 ? v3 : v2;
    int32_t v5 = *(int32_t *)(v2 + 8); // 0x8089cca
    int32_t v6 = g55; // 0x8089ccd
    int32_t v7 = v6 - v5; // 0x8089ccd
    g55 = v7 < 0 == ((v7 ^ v6) & (v6 ^ v5)) < 0 ? v6 : v5;
    int32_t v8 = *(int32_t *)(v2 + 4); // 0x8089cdf
    int32_t v9 = g54; // 0x8089ce2
    int32_t v10 = v9 - v8; // 0x8089ce2
    g54 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
    int32_t v11 = *(int32_t *)(v2 + 12); // 0x8089cf4
    int32_t v12 = g56; // 0x8089cf7
    int32_t v13 = v12 - v11; // 0x8089cf7
    g56 = v13 < 0 == ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089da0 - 0x8089eb5
// Line range:    1699 - 1710
void DrawArcLowLevel(int32_t * Arc) {
    // 0x8089da0
    int32_t v1; // 0x8089da0
    int32_t v2 = *(int32_t *)(v1 + 36); // 0x8089da9
    if (v2 == 0 || Gathering == 0) {
        // 0x8089e2f
        return;
    }
    int32_t v3 = Block; // 0x8089e3a
    int32_t v4 = v3 - v2; // 0x8089e3a
    Block = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0 ? v3 : v2;
    int32_t v5 = *(int32_t *)(v1 + 8); // 0x8089e4c
    int32_t v6 = g55; // 0x8089e4f
    int32_t v7 = v6 - v5; // 0x8089e4f
    g55 = v7 < 0 == ((v7 ^ v6) & (v6 ^ v5)) < 0 ? v6 : v5;
    int32_t v8 = *(int32_t *)(v1 + 4); // 0x8089e61
    int32_t v9 = g54; // 0x8089e64
    int32_t v10 = v9 - v8; // 0x8089e64
    g54 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
    int32_t v11 = *(int32_t *)(v1 + 12); // 0x8089e76
    int32_t v12 = g56; // 0x8089e79
    int32_t v13 = v12 - v11; // 0x8089e79
    g56 = v13 < 0 == ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089ec0 - 0x8089f1d
// Line range:    1882 - 1894
void DrawLine(int32_t * Layer2, int32_t * Line, int32_t unused) {
    // 0x8089ec0
    int32_t v1; // 0x8089ec0
    DrawLineLowLevel((int32_t *)v1, (char)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089f50 - 0x808a0f5
// Line range:    1903 - 1915
void DrawRat(int32_t * Line, int32_t unused) {
    int32_t v1 = (int32_t)Line;
    if (g137 <= 19) {
        // 0x8089fa4
        *(int32_t *)(v1 + 36) = pixel_slop * g137;
    }
    // 0x8089fae
    if ((*(char *)(v1 + 20) & 2) == 0) {
        // 0x808a0a0
        int32_t v2; // 0x8089f50
        DrawLineLowLevel((int32_t *)v2, (char)v2);
        return;
    }
    // 0x8089fb8
    if (Gathering != 0) {
        int32_t v3 = *(int32_t *)(v1 + 36); // 0x8089fbf
        int32_t v4 = *(int32_t *)(v1 + 44); // 0x808a032
        int32_t v5 = *(int32_t *)(v1 + 48); // 0x808a042
        int32_t v6 = Block; // 0x808a045
        int32_t v7 = (v3 + (int32_t)(v3 < 0) >> 1) + 2 * v3;
        int32_t v8 = v4 - v7; // 0x808a052
        int32_t v9 = v8 - v6; // 0x808a055
        Block = v9 == 0 | v9 < 0 != ((v9 ^ v8) & (v6 ^ v8)) < 0 ? v8 : v6;
        int32_t v10 = g55; // 0x808a060
        int32_t v11 = v4 + v7; // 0x808a066
        int32_t v12 = v11 - v10; // 0x808a069
        int32_t v13 = v5 - v7; // 0x808a06e
        g55 = v12 < 0 == ((v12 ^ v11) & (v10 ^ v11)) < 0 ? v11 : v10;
        int32_t v14 = g54; // 0x808a076
        int32_t v15 = v5 + v7; // 0x808a07c
        int32_t v16 = v13 - v14; // 0x808a07f
        g54 = v16 < 0 == ((v16 ^ v13) & (v14 ^ v13)) < 0 == (v16 != 0) ? v14 : v13;
        int32_t v17 = g56; // 0x808a089
        int32_t v18 = v15 - v17; // 0x808a08e
        g56 = v18 < 0 == ((v18 ^ v15) & (v17 ^ v15)) < 0 ? v15 : v17;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808a120 - 0x808a18d
// Line range:    1952 - 1966
void DrawArc(int32_t * Layer2, int32_t * Arc, int32_t unused) {
    // 0x808a120
    if (*(int32_t *)((int32_t)Arc + 36) == 0) {
        // 0x808a178
        return;
    }
    // 0x808a134
    int32_t v1; // 0x808a120
    DrawArcLowLevel((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808af00 - 0x808b7e6
// Line range:    1341 - 1459
void DrawPadLowLevel(int32_t * gc, int32_t * Pad, char clear, char mask) {
    // 0x808af00
    int32_t v1; // 0x808af00
    int32_t v2 = v1;
    int3_t v3; // 0x808af00
    int3_t v4 = v3;
    int32_t v5; // 0x808af00
    int32_t v6; // 0x808af00
    if ((char)v1 == 0) {
        // 0x808af90
        v6 = *(int32_t *)(v2 + 36);
        goto lab_0x808af93;
    } else {
        if ((char)(int32_t)gc == 0) {
            // 0x808b2e8
            v6 = *(int32_t *)(v2 + 36) + *(int32_t *)(v2 + 40);
            goto lab_0x808af93;
        } else {
            // 0x808af20
            v5 = *(int32_t *)(v2 + 84);
            if (Gathering == 0) {
                goto lab_0x808af9c;
            } else {
                goto lab_0x808af2c;
            }
        }
    }
  lab_0x808af93:
    // 0x808af93
    v5 = v6;
    if (Gathering != 0) {
        goto lab_0x808af2c;
    } else {
        goto lab_0x808af9c;
    }
  lab_0x808af2c:;
    int32_t v7 = Block; // 0x808af2e
    int32_t v8 = v7 - v2; // 0x808af2e
    Block = v8 == 0 | v8 < 0 != ((v8 ^ v7) & (v7 ^ v2)) < 0 ? v7 : v2;
    int32_t v9 = *(int32_t *)(v2 + 8); // 0x808af40
    int32_t v10 = g55; // 0x808af43
    int32_t v11 = v10 - v9; // 0x808af43
    g55 = v11 < 0 == ((v11 ^ v10) & (v10 ^ v9)) < 0 ? v10 : v9;
    int32_t v12 = *(int32_t *)(v2 + 4); // 0x808af55
    int32_t v13 = g54; // 0x808af58
    int32_t v14 = v13 - v12; // 0x808af58
    g54 = v14 == 0 | v14 < 0 != ((v14 ^ v13) & (v13 ^ v12)) < 0 ? v13 : v12;
    int32_t v15 = *(int32_t *)(v2 + 12); // 0x808af6a
    int32_t v16 = g56; // 0x808af6d
    int32_t v17 = v16 - v15; // 0x808af6d
    g56 = v17 < 0 == ((v17 ^ v16) & (v16 ^ v15)) < 0 ? v16 : v15;
  lab_0x808af9c:;
    int32_t v18 = v5;
    if ((vyl & 0x4000) == 0) {
        if ((char)v1 == 0) {
            // 0x808b2d8
            return;
        }
        if ((vyl & 0x20000) == 0) {
            // 0x808b2d8
            return;
        }
    }
    int32_t v19 = *(int32_t *)(v2 + 64); // 0x808afb0
    int32_t v20 = *(int32_t *)(v2 + 44); // 0x808afb6
    int32_t v21 = v18 + (int32_t)(v18 < 0) >> 1; // 0x808afbb
    int32_t v22 = *(int32_t *)(v2 + 48); // 0x808afc2
    int32_t v23 = *(int32_t *)(v2 + 68); // 0x808afc8
    bool v24 = v20 > v19 | v22 > v23;
    int32_t v25 = v24 ? v22 : v23;
    int32_t v26 = v24 ? v20 : v19;
    int32_t v27 = v24 ? v23 : v22;
    int32_t v28 = v24 ? v19 : v20;
    if (*(char *)(v2 + 21) % 2 == 0) {
        if (v25 == v27 || v26 == v28) {
            // 0x808b2d8
            return;
        }
        int32_t v29 = v26 - v28; // 0x808b35a
        int3_t v30 = v4 - 1;
        __frontend_reg_store_fpr(v30, (float80_t)v29);
        int32_t v31 = v25 - v27; // 0x808b365
        int3_t v32 = v4 - 2;
        __frontend_reg_store_fpr(v32, (float80_t)v31);
        int3_t v33 = v4 - 3;
        __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v30));
        __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v33) * __frontend_reg_load_fpr(v30));
        int3_t v34 = v4 ^ -4; // 0x808b377
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v32));
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v34) * __frontend_reg_load_fpr(v32));
        __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v34) + __frontend_reg_load_fpr(v33));
        __frontend_reg_store_fpr(v33, sqrtl(__frontend_reg_load_fpr(v33)));
        __frontend_reg_store_fpr(v34, (float80_t)v21);
        __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v34) / __frontend_reg_load_fpr(v33));
        __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v33));
        if (v31 < 1) {
            if (v31 == 0) {
                // 0x808b700
                __frontend_reg_store_fpr(v34, 0.0L);
            } else {
                // 0x808b63e
                __frontend_reg_store_fpr(v34, -0.5L);
            }
        } else {
            // 0x808b390
            __frontend_reg_store_fpr(v34, 0.5L);
        }
        int3_t v35 = v4 + 3; // 0x808b399
        __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v32));
        __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v35) * __frontend_reg_load_fpr(v33));
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v35) + __frontend_reg_load_fpr(v34));
        float80_t v36 = __frontend_reg_load_fpr(v34); // 0x808b3b0
        if (v29 < 1) {
            if (v29 == 0) {
                // 0x808b6f0
                __frontend_reg_store_fpr(v34, 0.0L);
                float80_t v37 = __frontend_reg_load_fpr(v34); // 0x808b6f2
                __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v33));
                __frontend_reg_store_fpr(v33, v37);
            } else {
                // 0x808b626
                __frontend_reg_store_fpr(v34, -0.5L);
                float80_t v38 = __frontend_reg_load_fpr(v34); // 0x808b62c
                __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v33));
                __frontend_reg_store_fpr(v33, v38);
            }
        } else {
            // 0x808b3bf
            __frontend_reg_store_fpr(v34, 0.5L);
            float80_t v39 = __frontend_reg_load_fpr(v34); // 0x808b3c5
            __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v33));
            __frontend_reg_store_fpr(v33, v39);
        }
        int32_t v40 = v36; // 0x808b3b0
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v34) * __frontend_reg_load_fpr(v30));
        __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v34) + __frontend_reg_load_fpr(v33));
        __frontend_reg_store_fpr(v33, -__frontend_reg_load_fpr(v33));
        float80_t v41 = __frontend_reg_load_fpr(v33); // 0x808b3d0
        float80_t v42 = __frontend_reg_load_fpr(v32); // 0x808b3d6
        __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v30));
        __frontend_reg_store_fpr(v30, v42);
        float80_t v43 = __frontend_reg_load_fpr(v32); // 0x808b405
        float80_t v44 = __frontend_reg_load_fpr(v30); // 0x808b408
        __frontend_reg_store_fpr(v30, v43);
        __frontend_reg_store_fpr(v32, v44);
        if ((v40 < 0 ? -v40 : v40) < pixel_slop) {
            int32_t v45 = v41; // 0x808b3d0
            if (pixel_slop > (v45 < 0 ? -v45 : v45)) {
                // 0x808b2d0
                __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32));
                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30));
                // 0x808b2d8
                return;
            }
        }
        // 0x808b453
        __frontend_reg_load_fpr(v32);
        atan2((float64_t)__frontend_reg_load_fpr(v30), (float64_t)(int64_t)&g279);
        __frontend_reg_store_fpr(v4, 57.295779L * __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        // 0x808b2d8
        return;
    }
    if (v25 != v27 && v26 != v28) {
        int3_t v46 = v4 - 1; // 0x808b041
        __frontend_reg_store_fpr(v46, (float80_t)(v26 - v28));
        __frontend_reg_load_fpr(v46);
        __frontend_reg_store_fpr(v46, (float80_t)(v25 - v27));
        atan2((float64_t)__frontend_reg_load_fpr(v46), (float64_t)(int64_t)&g279);
        __frontend_reg_store_fpr(v46, (float80_t)v21);
        float80_t v47 = __frontend_reg_load_fpr(v46); // 0x808b06a
        __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v47);
        __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v46));
        int3_t v48 = v4 - 2; // 0x808b07a
        __frontend_reg_store_fpr(v48, 0.785398163397448278999L);
        __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v48) + __frontend_reg_load_fpr(v46));
        __frontend_reg_load_fpr(v46);
        float80_t v49 = __frontend_reg_load_fpr(v4); // 0x808b085
        function_8060d88(v49);
        float64_t v50; // 0x808af00
        __frontend_reg_store_fpr(v4, (float80_t)v50);
        __frontend_reg_store_fpr(v46, v49);
        __frontend_reg_store_fpr(v48, (float80_t)v50);
        __frontend_reg_store_fpr(v48, __frontend_reg_load_fpr(v48) * __frontend_reg_load_fpr(v46));
        int3_t v51 = v4 - 3; // 0x808b0ab
        __frontend_reg_store_fpr(v51, 1.41421356237309514547L);
        __frontend_reg_store_fpr(v48, __frontend_reg_load_fpr(v48) * __frontend_reg_load_fpr(v51));
        float80_t v52 = __frontend_reg_load_fpr(v51); // 0x808b0b3
        __frontend_reg_store_fpr(v51, __frontend_reg_load_fpr(v48));
        __frontend_reg_store_fpr(v48, v52);
        __frontend_reg_store_fpr(v51, __frontend_reg_load_fpr(v51));
        float80_t v53 = __frontend_reg_load_fpr(v51); // 0x808b0c1
        __frontend_reg_store_fpr(v51, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v53);
        __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v51) * __frontend_reg_load_fpr(v46));
        __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v48) * __frontend_reg_load_fpr(v46));
        __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v46));
        __frontend_reg_store_fpr(v48, (float80_t)v25);
        __frontend_reg_store_fpr(v51, __frontend_reg_load_fpr(v48));
        __frontend_reg_store_fpr(v51, __frontend_reg_load_fpr(v51) - __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v51);
        __frontend_reg_store_fpr(v51, (float80_t)v26);
        int3_t v54 = v4 ^ -4; // 0x808b0e3
        __frontend_reg_store_fpr(v54, __frontend_reg_load_fpr(v51));
        __frontend_reg_store_fpr(v54, __frontend_reg_load_fpr(v54) + __frontend_reg_load_fpr(v46));
        __frontend_reg_load_fpr(v54);
        __frontend_reg_store_fpr(v54, (float80_t)v27);
        int3_t v55 = v4 + 3; // 0x808b0f9
        __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v54));
        __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v55) - __frontend_reg_load_fpr(v46));
        __frontend_reg_load_fpr(v55);
        __frontend_reg_store_fpr(v55, (float80_t)v28);
        int3_t v56 = v4 + 2; // 0x808b10c
        __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v55));
        __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v56) - __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v56);
        float80_t v57 = __frontend_reg_load_fpr(v55); // 0x808b119
        __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v46));
        __frontend_reg_store_fpr(v46, v57);
        float80_t v58 = __frontend_reg_load_fpr(v55); // 0x808b134
        float80_t v59 = __frontend_reg_load_fpr(v54); // 0x808b137
        __frontend_reg_store_fpr(v54, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v59);
        float80_t v60 = __frontend_reg_load_fpr(v54); // 0x808b13e
        float80_t v61 = __frontend_reg_load_fpr(v51); // 0x808b141
        __frontend_reg_store_fpr(v51, __frontend_reg_load_fpr(v46));
        __frontend_reg_store_fpr(v46, v61);
        float80_t v62 = __frontend_reg_load_fpr(v51); // 0x808b143
        float80_t v63 = __frontend_reg_load_fpr(v48); // 0x808b149
        __frontend_reg_store_fpr(v48, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v63);
        float80_t v64 = __frontend_reg_load_fpr(v48); // 0x808b14b
        float80_t v65 = __frontend_reg_load_fpr(v46); // 0x808b151
        float80_t v66 = __frontend_reg_load_fpr(v4); // 0x808b157
        __frontend_reg_store_fpr(v4, v58);
        __frontend_reg_store_fpr(v46, v66);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v46) + __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        __frontend_reg_store_fpr(v4, v60);
        __frontend_reg_store_fpr(v46, v65);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v46) + __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        __frontend_reg_store_fpr(v4, v60);
        __frontend_reg_store_fpr(v46, v64);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v46) + __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        __frontend_reg_store_fpr(v4, v58);
        __frontend_reg_store_fpr(v46, v62);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v46) - __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
    }
    // 0x808b2d8
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808ba50 - 0x808bba9
// Line range:    2022 - 105
void DrawPolygon(int32_t * Layer2, int32_t * Polygon2, int32_t unused) {
    int32_t v1 = (int32_t)Polygon2;
    GetLayerNumber(*(int32_t *)((int32_t)PCB + 0x220c), (int32_t)Layer2);
    if (*(int32_t *)(v1 + 44) != 0) {
        // 0x808baab
        if (Gathering == 0) {
            // 0x808bb90
            __printf_chk(1, "DrawPolygonLowLevel: Called without Gathering set!\n");
        } else {
            int32_t v2 = *Polygon2; // 0x808bab8
            int32_t v3 = Block; // 0x808baba
            int32_t v4 = v3 - v2; // 0x808baba
            Block = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0 ? v3 : v2;
            int32_t v5 = *(int32_t *)(v1 + 8); // 0x808bacc
            int32_t v6 = g55; // 0x808bacf
            int32_t v7 = v6 - v5; // 0x808bacf
            g55 = v7 < 0 == ((v7 ^ v6) & (v6 ^ v5)) < 0 ? v6 : v5;
            int32_t v8 = *(int32_t *)(v1 + 4); // 0x808bae1
            int32_t v9 = g54; // 0x808bae4
            int32_t v10 = v9 - v8; // 0x808bae4
            g54 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
            int32_t v11 = *(int32_t *)(v1 + 12); // 0x808baf6
            int32_t v12 = g56; // 0x808baf9
            int32_t v13 = v12 - v11; // 0x808baf9
            g56 = v13 < 0 == ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
        }
    }
    // 0x808bb0b
    if ((*(char *)(v1 + 20) & 16) != 0) {
        int32_t v14 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48); // 0x808bb38
        r_search((int32_t *)v14, Polygon2, NULL, (int32_t (*)(int32_t *, char *))0x808a1c0, (char *)256);
        int32_t v15 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 40); // 0x808bb6a
        r_search((int32_t *)v15, Polygon2, NULL, (int32_t (*)(int32_t *, char *))0x808a1c0, (char *)1);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808bbb0 - 0x808bfa0
// Line range:    1592 - 1675
void DrawTextLowLevel(int32_t * Text, int32_t min_line_width) {
    int32_t v1 = (int32_t)Text;
    int32_t v2 = __readgsdword(20); // 0x808bbc5
    if (Gathering != 0) {
        int32_t v3 = *Text; // 0x808bf35
        int32_t v4 = Block; // 0x808bf37
        int32_t v5 = v4 - v3; // 0x808bf37
        Block = v5 == 0 | v5 < 0 != ((v5 ^ v4) & (v4 ^ v3)) < 0 ? v4 : v3;
        int32_t v6 = *(int32_t *)(v1 + 8); // 0x808bf49
        int32_t v7 = g55; // 0x808bf4c
        int32_t v8 = v7 - v6; // 0x808bf4c
        g55 = v8 < 0 == ((v8 ^ v7) & (v7 ^ v6)) < 0 ? v7 : v6;
        int32_t v9 = *(int32_t *)(v1 + 4); // 0x808bf5e
        int32_t v10 = g54; // 0x808bf61
        int32_t v11 = v10 - v9; // 0x808bf61
        g54 = v11 == 0 | v11 < 0 != ((v11 ^ v10) & (v10 ^ v9)) < 0 ? v10 : v9;
        int32_t v12 = *(int32_t *)(v1 + 12); // 0x808bf73
        int32_t v13 = g56; // 0x808bf76
        int32_t v14 = v13 - v12; // 0x808bf76
        g56 = v14 < 0 == ((v14 ^ v13) & (v13 ^ v12)) < 0 ? v13 : v12;
    } else {
        int32_t v15 = *(int32_t *)(v1 + 52); // 0x808bbd7
        if (v15 != 0) {
            char * v16 = (char *)v15; // 0x808bbe8
            char v17 = *v16; // 0x808bbf4
            if (v17 != 0) {
                int32_t v18 = (int32_t)PCB; // 0x808bbbf
                int32_t * v19 = (int32_t *)(v1 + 36);
                char * v20 = (char *)(v1 + 48);
                int32_t * v21 = (int32_t *)(v1 + 40);
                int64_t v22; // 0x808bbb0
                int32_t v23 = v22;
                int32_t v24 = 0;
                int32_t v25 = 28 * (int32_t)v17 + v18;
                int32_t v26; // 0x808bbb0
                int32_t v27; // 0x808bbb0
                int32_t v28; // bp-120, 0x808bbb0
                int32_t v29; // bp-136, 0x808bbb0
                int32_t v30; // 0x808bbb0
                int32_t v31; // 0x808bbb0
                int32_t v32; // 0x808bbb0
                int32_t v33; // 0x808bbb0
                int32_t v34; // 0x808bbb0
                int32_t v35; // 0x808bbb0
                int32_t v36; // 0x808bbb0
                int32_t v37; // 0x808bbb0
                int32_t v38; // 0x808bf1d
                int32_t v39; // 0x808bc37
                int32_t v40; // 0x808bdad
                int32_t v41; // 0x808bcb5
                int32_t v42; // 0x808bce8
                int32_t v43; // 0x808bc64
                int32_t v44; // 0x808bc6c
                int32_t v45; // 0x808bc82
                if (*(char *)(v25 + 212) == 0) {
                    // 0x808bdf0
                    v29 = g225;
                    v29 = *v19 * (g225 + v24) / 100;
                    RotateBoxLowLevel(&v29, 0, 0, *v20);
                    v29 += *v21;
                    v38 = 6 * ((int32_t)(float32_t)g227 - g225);
                    v36 = v33;
                    v32 = v23;
                    v37 = v24 + (int32_t)(v38 < 0) + ((int32_t)(0x66666667 * (int64_t)v38 / 0x100000000) >> 1);
                } else {
                    // 0x808bc31
                    v39 = *(int32_t *)(v25 + 216);
                    v26 = v25;
                    v35 = v33;
                    v31 = v23;
                    if (v39 != 0) {
                        // 0x808bc96
                        v27 = *(int32_t *)(v25 + 208);
                        v45 = v39;
                        __asm_rep_movsd_memcpy((char *)&v28, (char *)v27, 22);
                        v41 = *v19;
                        v42 = v41 * v23 / 100;
                        RotateLineLowLevel(&v28, 0, 0, *v20);
                        v43 = v41 * (v33 + v24) / 100 + *v21;
                        v44 = (*(char *)(v1 + 20) >= 0 ? v42 : -v42) + *(int32_t *)(v1 + 44);
                        DrawLineLowLevel((int32_t *)v43, (char)v44);
                        v45--;
                        v27 += 88;
                        v34 = v43;
                        v30 = v44;
                        while (v45 != 0) {
                            // 0x808bc96
                            __asm_rep_movsd_memcpy((char *)&v28, (char *)v27, 22);
                            v41 = *v19;
                            v42 = v41 * v30 / 100;
                            RotateLineLowLevel(&v28, 0, 0, *v20);
                            v43 = v41 * (v34 + v24) / 100 + *v21;
                            v44 = (*(char *)(v1 + 20) >= 0 ? v42 : -v42) + *(int32_t *)(v1 + 44);
                            DrawLineLowLevel((int32_t *)v43, (char)v44);
                            v45--;
                            v27 += 88;
                            v34 = v43;
                            v30 = v44;
                        }
                        // 0x808bd88
                        v26 = 28 * (int32_t)*v16 + v18;
                        v35 = v43;
                        v31 = v44;
                    }
                    // 0x808bd88
                    v40 = *(int32_t *)(v26 + 224);
                    v36 = v35;
                    v32 = v31;
                    v37 = *(int32_t *)(v26 + 232) + v24 + v40;
                }
                int32_t v46 = (int32_t)v16 + 1; // 0x808bdba
                while (v46 != 0) {
                    char * v47 = (char *)v46; // 0x808bdba
                    char v48 = *v47; // 0x808bdc9
                    if (v48 == 0) {
                        // break -> 0x808bdd4
                        break;
                    }
                    v23 = v32;
                    int32_t v49 = v36;
                    v24 = v37;
                    char * v50 = v47;
                    v25 = 28 * (int32_t)v48 + v18;
                    if (*(char *)(v25 + 212) == 0) {
                        // 0x808bdf0
                        v29 = g225;
                        v29 = *v19 * (g225 + v24) / 100;
                        RotateBoxLowLevel(&v29, 0, 0, *v20);
                        v29 += *v21;
                        v38 = 6 * ((int32_t)(float32_t)g227 - g225);
                        v36 = v49;
                        v32 = v23;
                        v37 = v24 + (int32_t)(v38 < 0) + ((int32_t)(0x66666667 * (int64_t)v38 / 0x100000000) >> 1);
                    } else {
                        // 0x808bc31
                        v39 = *(int32_t *)(v25 + 216);
                        v26 = v25;
                        v35 = v49;
                        v31 = v23;
                        if (v39 != 0) {
                            // 0x808bc96
                            v27 = *(int32_t *)(v25 + 208);
                            v45 = v39;
                            __asm_rep_movsd_memcpy((char *)&v28, (char *)v27, 22);
                            v41 = *v19;
                            v42 = v41 * v23 / 100;
                            RotateLineLowLevel(&v28, 0, 0, *v20);
                            v43 = v41 * (v49 + v24) / 100 + *v21;
                            v44 = (*(char *)(v1 + 20) >= 0 ? v42 : -v42) + *(int32_t *)(v1 + 44);
                            DrawLineLowLevel((int32_t *)v43, (char)v44);
                            v45--;
                            v27 += 88;
                            v34 = v43;
                            v30 = v44;
                            while (v45 != 0) {
                                // 0x808bc96
                                __asm_rep_movsd_memcpy((char *)&v28, (char *)v27, 22);
                                v41 = *v19;
                                v42 = v41 * v30 / 100;
                                RotateLineLowLevel(&v28, 0, 0, *v20);
                                v43 = v41 * (v34 + v24) / 100 + *v21;
                                v44 = (*(char *)(v1 + 20) >= 0 ? v42 : -v42) + *(int32_t *)(v1 + 44);
                                DrawLineLowLevel((int32_t *)v43, (char)v44);
                                v45--;
                                v27 += 88;
                                v34 = v43;
                                v30 = v44;
                            }
                            // 0x808bd88
                            v26 = 28 * (int32_t)*v50 + v18;
                            v35 = v43;
                            v31 = v44;
                        }
                        // 0x808bd88
                        v40 = *(int32_t *)(v26 + 224);
                        v36 = v35;
                        v32 = v31;
                        v37 = *(int32_t *)(v26 + 232) + v24 + v40;
                    }
                    // 0x808bdba
                    v46 = (int32_t)v50 + 1;
                }
            }
        }
    }
    // 0x808bdd4
    if (v2 == __readgsdword(20)) {
        // 0x808bde4
        return;
    }
    // 0x808bf8d
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c060 - 0x808c250
// Line range:    1277 - 1334
void DrawPinOrViaNameLowLevel(int32_t * Ptr) {
    int32_t v1 = __readgsdword(20); // 0x808c06c
    int32_t v2; // 0x808c060
    int32_t v3; // 0x808c060
    int32_t v4; // 0x808c060
    if ((*(int32_t *)(v4 + 20) & 0x4000) == 0) {
        int32_t v5 = *(int32_t *)(v4 + 48); // 0x808c138
        int32_t v6 = *(int32_t *)(v4 + 52); // 0x808c141
        int32_t v7 = *(int32_t *)(v4 + 36); // 0x808c156
        v2 = *(int32_t *)(v4 + 56) + g166 - (v7 + (int32_t)(v7 < 0) >> 1);
        v3 = v6 + g165 + (v5 + (int32_t)(v5 < 0) >> 1);
        if (Gathering != 0) {
            goto lab_0x808c0e2;
        } else {
            goto lab_0x808c175;
        }
    } else {
        int32_t v8 = *(int32_t *)(v4 + 36); // 0x808c0a6
        int32_t v9 = *(int32_t *)(v4 + 52); // 0x808c0af
        int32_t v10 = *(int32_t *)(v4 + 48); // 0x808c0be
        int32_t v11 = *(int32_t *)(v4 + 56); // 0x808c0d2
        v2 = v11 - g165 - (v10 + (int32_t)(v10 < 0) >> 1);
        v3 = v9 + g166 - (v8 + (int32_t)(v8 < 0) >> 1);
        if (Gathering == 0) {
            goto lab_0x808c175;
        } else {
            goto lab_0x808c0e2;
        }
    }
  lab_0x808c0e2:;
    int32_t v12 = v3;
    int32_t v13 = v2;
    int32_t v14 = Block; // 0x808c0e2
    int32_t v15 = v12 - v14; // 0x808c0e7
    int32_t v16 = v15 == 0 | v15 < 0 != ((v15 ^ v12) & (v14 ^ v12)) < 0 ? v12 : v14; // 0x808c0e9
    Block = v16;
    int32_t v17 = g55; // 0x808c0f1
    int32_t v18 = v12 - v17; // 0x808c0f6
    int32_t v19 = v18 < 0 == ((v18 ^ v12) & (v17 ^ v12)) < 0 ? v12 : v17; // 0x808c0f8
    int32_t v20 = g54; // 0x808c0fb
    g55 = v19;
    int32_t v21 = v13 - v20; // 0x808c106
    int32_t v22 = v21 == 0 | v21 < 0 != ((v21 ^ v13) & (v20 ^ v13)) < 0 ? v13 : v20; // 0x808c108
    g54 = v22;
    int32_t v23 = g56; // 0x808c110
    int32_t v24 = v13 - v23; // 0x808c115
    int32_t v25 = v24 < 0 == ((v24 ^ v13) & (v23 ^ v13)) < 0 ? v13 : v23; // 0x808c117
    g56 = v25;
    goto lab_0x808c120;
  lab_0x808c175:;
    // 0x808c175
    int32_t v26; // bp-108, 0x808c060
    MakeFlags((int32_t)&v26);
    if (g41 % 2 != 0) {
        int32_t v27 = doing_pinout; // 0x808c240
        doing_pinout = v27 + 1;
    }
    // 0x808c1d0
    int32_t v28; // bp-92, 0x808c060
    DrawTextLowLevel(&v28, 0);
    if (g41 % 2 != 0) {
        // 0x808c216
        doing_pinout--;
    }
    goto lab_0x808c120;
  lab_0x808c120:
    // 0x808c120
    if (v1 == __readgsdword(20)) {
        // 0x808c130
        return;
    }
    // 0x808c249
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c430 - 0x808c486
// Line range:    1787 - 1794
void DrawPin(int32_t * Pin, int32_t unused) {
    // 0x808c430
    if (Gathering == 0) {
        // 0x808c478
        int32_t v1; // 0x808c430
        SetPVColor((int32_t *)v1, v1);
    }
    // 0x808c443
    DrawPinOrViaLowLevel(&g279, (char)&g279);
    if ((*(int32_t *)((int32_t)Pin + 20) & 40) != 32 == doing_pinout == 0) {
        // 0x808c470
        return;
    }
    // 0x808c463
    DrawPinOrViaNameLowLevel(&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c4f0 - 0x808c53c
// Line range:    1742 - 1751
void DrawVia(int32_t * Via, int32_t unused) {
    // 0x808c4f0
    if (Gathering == 0) {
        // 0x808c520
        int32_t v1; // 0x808c4f0
        SetPVColor((int32_t *)v1, v1);
    }
    // 0x808c503
    DrawPinOrViaLowLevel(&g279, (char)&g279);
    if ((*(int32_t *)((int32_t)Via + 20) & 40) != 32) {
        // 0x808c51a
        return;
    }
    // 0x808c530
    DrawPinOrViaNameLowLevel(&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c5c0 - 0x808c780
// Line range:    1490 - 1554
void DrawPadNameLowLevel(int32_t * Pad) {
    int32_t v1 = __readgsdword(20); // 0x808c5cc
    int32_t v2; // 0x808c5c0
    int32_t v3 = *(int32_t *)(v2 + 44); // 0x808c5f2
    int32_t v4 = *(int32_t *)(v2 + 64); // 0x808c5f5
    int32_t v5 = *(int32_t *)(v2 + 36);
    int32_t v6; // 0x808c5c0
    int32_t v7; // 0x808c5c0
    int32_t v8; // bp-108, 0x808c5c0
    int32_t v9; // bp-92, 0x808c5c0
    if (v4 != v3) {
        int32_t v10 = v5 + (int32_t)(v5 < 0) >> 1; // 0x808c6a2
        int32_t v11 = v4 - v3; // 0x808c6a6
        int32_t v12 = v11 == 0 | v11 < 0 != ((v11 ^ v4) & (v4 ^ v3)) < 0 ? v4 : v3; // 0x808c6a8
        v7 = v12 - v10 + g165;
        v6 = g166 - v10 + *(int32_t *)(v2 + 48);
        if (Gathering != 0) {
            goto lab_0x808c63c;
        } else {
            // 0x808c6c9
            MakeFlags((int32_t)&v8);
            DrawTextLowLevel(&v9, 0);
            goto lab_0x808c67a;
        }
    } else {
        int32_t v13 = v5 + (int32_t)(v5 < 0) >> 1; // 0x808c616
        int32_t v14 = *(int32_t *)(v2 + 68); // 0x808c61a
        int32_t v15 = *(int32_t *)(v2 + 48); // 0x808c61d
        int32_t v16 = v15 - v14; // 0x808c61d
        v7 = v3 - v13 + g166;
        v6 = v13 - g165 + (v16 < 0 == ((v16 ^ v15) & (v15 ^ v14)) < 0 ? v15 : v14);
        if (Gathering == 0) {
            // 0x808c6c9
            MakeFlags((int32_t)&v8);
            DrawTextLowLevel(&v9, 0);
            goto lab_0x808c67a;
        } else {
            goto lab_0x808c63c;
        }
    }
  lab_0x808c63c:;
    int32_t v17 = v6;
    int32_t v18 = v7;
    int32_t v19 = Block; // 0x808c63c
    int32_t v20 = v18 - v19; // 0x808c641
    int32_t v21 = v20 == 0 | v20 < 0 != ((v20 ^ v18) & (v19 ^ v18)) < 0 ? v18 : v19; // 0x808c643
    Block = v21;
    int32_t v22 = g55; // 0x808c64b
    int32_t v23 = v18 - v22; // 0x808c650
    int32_t v24 = v23 < 0 == ((v23 ^ v18) & (v22 ^ v18)) < 0 ? v18 : v22; // 0x808c652
    int32_t v25 = g54; // 0x808c655
    g55 = v24;
    int32_t v26 = v17 - v25; // 0x808c660
    int32_t v27 = v26 == 0 | v26 < 0 != ((v26 ^ v17) & (v25 ^ v17)) < 0 ? v17 : v25; // 0x808c662
    g54 = v27;
    int32_t v28 = g56; // 0x808c66a
    int32_t v29 = v17 - v28; // 0x808c66f
    int32_t v30 = v29 < 0 == ((v29 ^ v17) & (v28 ^ v17)) < 0 ? v17 : v28; // 0x808c671
    g56 = v30;
    goto lab_0x808c67a;
  lab_0x808c67a:
    // 0x808c67a
    if (v1 == __readgsdword(20)) {
        // 0x808c68a
        return;
    }
    // 0x808c76d
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c9b0 - 0x808ca8a
// Line range:    1835 - 1844
void DrawPad(int32_t * Pad, int32_t unused) {
    // 0x808c9b0
    DrawPadLowLevel(NULL, &g279, (char)&g279, (char)&g279);
    if (doing_pinout != 0) {
        // 0x808ca4a
        DrawPadNameLowLevel(&g279);
        return;
    }
    // 0x808ca44
    if ((*(char *)((int32_t)Pad + 20) & 32) == 0) {
        // 0x808ca58
        return;
    }
    // 0x808ca4a
    DrawPadNameLowLevel(&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808d3d0 - 0x808d452
// Line range:    188 - 203
void Draw(void) {
    // 0x808d3d0
    render = 1;
    HideCrosshair(1);
    RestoreCrosshair(1);
    g56 = 0;
    g55 = 0;
    g54 = 0;
    Block = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090d00 - 0x8090d20
// Line range:    90 - 96
void Message(char * Format, ...) {
    // 0x8090d00
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090d20 - 0x8090d97
// Line range:    183 - 195
void MyFatal(char * Format, ...) {
    // 0x8090d20
    EmergencySave();
    __fprintf_chk((struct _IO_FILE *)g43, 1, "%s (%i): fatal, ", (char *)Progname, getpid());
    int32_t v1; // 0x8090d20
    __vfprintf_chk((struct _IO_FILE *)g43, 1, Format, (int32_t)&v1);
    fflush((struct _IO_FILE *)g43);
    exit(1);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090e20 - 0x8090e64
// Line range:    143 - 156
void OpendirErrorMessage(char * DirName) {
    char * v1 = __strdup(DirName); // 0x8090e2d
    int32_t err_num = *__errno_location(); // 0x8090e39
    Message("Can't scan directory\n   '%s'\nopendir() returned: '%s'\n", v1, strerror(err_num));
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090e70 - 0x8090eb4
// Line range:    123 - 136
void PopenErrorMessage(char * Filename) {
    char * v1 = __strdup(Filename); // 0x8090e7d
    int32_t err_num = *__errno_location(); // 0x8090e89
    Message("Can't execute command\n   '%s'\npopen() returned: '%s'\n", v1, strerror(err_num));
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090ec0 - 0x8090f04
// Line range:    103 - 116
void OpenErrorMessage(char * Filename) {
    char * v1 = __strdup(Filename); // 0x8090ecd
    int32_t err_num = *__errno_location(); // 0x8090ed9
    Message("Can't open file\n   '%s'\nfopen() returned: '%s'\n", v1, strerror(err_num));
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8090f10 - 0x8090f40
// Line range:    416 - 426
void PreLoadElementPCB(void) {
    // 0x8090f10
    if (yyPCB != NULL) {
        int32_t v1 = (int32_t)yyPCB; // 0x8090f10
        *(int32_t *)&yyFont = (int32_t)&g268;
        int32_t v2 = *(int32_t *)(v1 + 0x220c); // 0x8090f28
        *(int32_t *)&yyData = v2;
        *(int32_t *)(v2 + 72) = v1;
        *(int32_t *)(v2 + 24) = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8090f50 - 0x8090fcb
// Line range:    1008 - 1024
void EnableAutosave(void) {
    // 0x8090f50
    int32_t v1; // 0x8090f50
    backup_timer = g150 < 1 | g42 == 0 ? 0 : v1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8090fd0 - 0x8091040
// Line range:    191 - 198
void sort_library(int32_t * lib) {
    // 0x8090fd0
    int32_t nmemb; // 0x8090fd0
    int32_t * base = (int32_t *)(nmemb + 8); // 0x8090ff0
    qsort((int32_t *)*base, nmemb, 28, (int32_t (*)(int32_t *, int32_t *))0x8091820);
    uint32_t v1 = 0; // 0x8091005
    int32_t v2 = 28 * v1 + *base; // 0x809100e
    int32_t base2 = *(int32_t *)(v2 + 20); // 0x8091028
    qsort((int32_t *)base2, *(int32_t *)(v2 + 12), 24, (int32_t (*)(int32_t *, int32_t *))0x8091800);
    while (v1 != (int32_t)&g279 - 1 && v1 < (int32_t)&g279) {
        // 0x8091008
        v1++;
        v2 = 28 * v1 + *base;
        base2 = *(int32_t *)(v2 + 20);
        qsort((int32_t *)base2, *(int32_t *)(v2 + 12), 24, (int32_t (*)(int32_t *, int32_t *))0x8091800);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091850 - 0x8091864
// Line range:    1080 - 1083
void RemoveTMPData(void) {
    // 0x8091850
    unlink(TMPFilename);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091a90 - 0x8091bb0
// Line range:    478 - 513
void WritePCBInfoHeader(struct _IO_FILE * FP) {
    char hostname[256]; // bp-276, 0x8091a90
    char v1[256]; // 0x8091acd
    int32_t t = __readgsdword(20); // 0x8091aaa
    int32_t time_val = time((int32_t *)t); // 0x8091ab5
    v1[0] = time_val;
    hostname = v1;
    int32_t v2; // 0x8091a90
    struct _IO_FILE * v3 = (struct _IO_FILE *)v2;
    __fprintf_chk(v3, 1, "# release: %s 20091103\n", (char *)Progname);
    __fprintf_chk(v3, 1, "# date:    %s", asctime(localtime((int32_t *)&hostname)));
    struct passwd * v4 = getpwuid(getuid()); // 0x8091b1b
    int32_t v5 = *(int32_t *)((int32_t)v4 + 16); // 0x8091b20
    int32_t v6 = *(int32_t *)v4; // 0x8091b27
    __fprintf_chk(v3, 1, "# user:    %s (%s)\n", (char *)v6, (char *)v5);
    int32_t name; // bp-272, 0x8091a90
    int32_t v7; // 0x8091b9b
    if (gethostname((char *)&name, 255) == -1) {
        goto lab_0x8091b81;
    } else {
        // 0x8091b5a
        v7 = g58;
        if (g58 == 0) {
            struct hostent * v8 = gethostbyname((char *)&name); // 0x8091b9b
            v7 = (int32_t)v8;
            g58 = v7;
            if (v8 == NULL) {
                // 0x8091b65
                __fprintf_chk(v3, 1, "# host:    %s\n", (char *)(int32_t)&name);
                goto lab_0x8091b81;
            } else {
                goto lab_0x8091b63;
            }
        } else {
            goto lab_0x8091b63;
        }
    }
  lab_0x8091b81:
    // 0x8091b81
    if (t != __readgsdword(20)) {
        // 0x8091bab
        __stack_chk_fail();
        return;
    }
  lab_0x8091b63:
    // 0x8091b65
    __fprintf_chk(v3, 1, "# host:    %s\n", (char *)*(int32_t *)v7);
    goto lab_0x8091b81;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091bb0 - 0x8091be0
// Line range:    452 - 458
void PrintQuotedString(struct _IO_FILE * FP, char * S) {
    // 0x8091bb0
    int32_t stream; // 0x8091bb0
    CreateQuotedString((int32_t *)&g59, (char *)stream);
    fputs((char *)g60, (struct _IO_FILE *)stream);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091be0 - 0x8091cb4
// Line range:    613 - 626
void WriteViaData(struct _IO_FILE * FP, int32_t * Data) {
    // 0x8091be0
    int32_t v1; // 0x8091be0
    if (v1 == 0) {
        // 0x8091cac
        return;
    }
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x8091c3f
    int32_t v3 = 0; // 0x8091c5f
    int32_t v4 = 76 * v3 + *(int32_t *)(v1 + 28); // 0x8091c03
    int32_t v5 = *(int32_t *)(v4 + 48); // 0x8091c09
    int32_t v6 = *(int32_t *)(v4 + 44); // 0x8091c10
    int32_t v7 = *(int32_t *)(v4 + 40); // 0x8091c17
    int32_t v8 = *(int32_t *)(v4 + 36); // 0x8091c1e
    int32_t v9 = *(int32_t *)(v4 + 56); // 0x8091c25
    int32_t v10 = *(int32_t *)(v4 + 52); // 0x8091c2c
    __fprintf_chk(v2, 1, "Via[%i %i %i %i %i %i ", v10, v9, v8, v7, v6, v5);
    PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
    v3++;
    int32_t v11 = *(int32_t *)(v4 + 24); // 0x8091c70
    __fprintf_chk(v2, 1, " %s]\n", flags_to_string(*(int32_t *)(v4 + 20), v11));
    while (*(int32_t *)v1 > v3) {
        // 0x8091c00
        v4 = 76 * v3 + *(int32_t *)(v1 + 28);
        v5 = *(int32_t *)(v4 + 48);
        v6 = *(int32_t *)(v4 + 44);
        v7 = *(int32_t *)(v4 + 40);
        v8 = *(int32_t *)(v4 + 36);
        v9 = *(int32_t *)(v4 + 56);
        v10 = *(int32_t *)(v4 + 52);
        __fprintf_chk(v2, 1, "Via[%i %i %i %i %i %i ", v10, v9, v8, v7, v6, v5);
        PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
        v3++;
        v11 = *(int32_t *)(v4 + 24);
        __fprintf_chk(v2, 1, " %s]\n", flags_to_string(*(int32_t *)(v4 + 20), v11));
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091cc0 - 0x8092102
// Line range:    774 - 779
void WriteLayerData(struct _IO_FILE * FP, int32_t Number, int32_t * layer) {
    // 0x8091cc0
    int32_t v1; // 0x8091cc0
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v2 + 4); // 0x8091ccc
    if (*v3 == 0) {
        // 0x8091cd6
        if (*(int32_t *)(v2 + 16) == 0) {
            // 0x80920d9
            if (*(int32_t *)(v2 + 8) == 0) {
                // 0x80920e4
                if (*(int32_t *)(v2 + 12) == 0) {
                    if (v2 != 0 != (char)v2 != 0) {
                        // 0x80920d1
                        return;
                    }
                }
            }
        }
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)v1;
    __fprintf_chk(stream, 1, "Layer(%i ", v1 + 1);
    PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
    fwrite((int32_t *)")\n(\n", 1, 4, stream);
    int32_t * v4 = (int32_t *)(v2 + 80); // 0x8091d40
    if (*v4 >= 1) {
        int32_t v5 = 0;
        int32_t v6 = v5 + 1; // 0x8091d57
        int32_t v7 = 8 * v5 + *(int32_t *)(v2 + 88); // 0x8091d5a
        int32_t v8 = *(int32_t *)(v7 + 4); // 0x8091d5d
        int32_t v9 = *(int32_t *)v7; // 0x8091d64
        __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v9, (char *)v8);
        while (v6 < *v4) {
            // 0x8091d50
            v5 = v6;
            v6 = v5 + 1;
            v7 = 8 * v5 + *(int32_t *)(v2 + 88);
            v8 = *(int32_t *)(v7 + 4);
            v9 = *(int32_t *)v7;
            __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v9, (char *)v8);
        }
    }
    // 0x8091d8f
    if (*v3 != 0) {
        int32_t v10 = 0;
        int32_t v11 = v10 + 1; // 0x8091dab
        int32_t v12 = 88 * v10 + *(int32_t *)(v2 + 36); // 0x8091dae
        char * v13 = flags_to_string(*(int32_t *)(v12 + 20), *(int32_t *)(v12 + 24)); // 0x8091dcd
        int32_t v14 = *(int32_t *)(v12 + 40); // 0x8091dd6
        int32_t v15 = *(int32_t *)(v12 + 36); // 0x8091ddd
        int32_t v16 = *(int32_t *)(v12 + 68); // 0x8091de4
        int32_t v17 = *(int32_t *)(v12 + 64); // 0x8091deb
        int32_t v18 = *(int32_t *)(v12 + 48); // 0x8091df2
        int32_t v19 = *(int32_t *)(v12 + 44); // 0x8091df9
        __fprintf_chk(stream, 1, "\tLine[%i %i %i %i %i %i %s]\n", v19, v18, v17, v16, v15, v14, v13);
        while (*v3 > v11) {
            // 0x8091da8
            v10 = v11;
            v11 = v10 + 1;
            v12 = 88 * v10 + *(int32_t *)(v2 + 36);
            v13 = flags_to_string(*(int32_t *)(v12 + 20), *(int32_t *)(v12 + 24));
            v14 = *(int32_t *)(v12 + 40);
            v15 = *(int32_t *)(v12 + 36);
            v16 = *(int32_t *)(v12 + 68);
            v17 = *(int32_t *)(v12 + 64);
            v18 = *(int32_t *)(v12 + 48);
            v19 = *(int32_t *)(v12 + 44);
            __fprintf_chk(stream, 1, "\tLine[%i %i %i %i %i %i %s]\n", v19, v18, v17, v16, v15, v14, v13);
        }
    }
    int32_t * v20 = (int32_t *)(v2 + 16); // 0x8091e25
    if (*v20 != 0) {
        int32_t v21 = 0;
        int32_t v22 = v21 + 1; // 0x8091e3a
        int32_t v23 = 68 * v21 + *(int32_t *)(v2 + 48); // 0x8091e43
        char * v24 = flags_to_string(*(int32_t *)(v23 + 20), *(int32_t *)(v23 + 24)); // 0x8091e62
        int32_t v25 = *(int32_t *)(v23 + 64); // 0x8091e6e
        int32_t v26 = *(int32_t *)(v23 + 60); // 0x8091e75
        int32_t v27 = *(int32_t *)(v23 + 40); // 0x8091e7c
        int32_t v28 = *(int32_t *)(v23 + 36); // 0x8091e83
        int32_t v29 = *(int32_t *)(v23 + 48); // 0x8091e8a
        int32_t v30 = *(int32_t *)(v23 + 44); // 0x8091e91
        int32_t v31 = *(int32_t *)(v23 + 56); // 0x8091e98
        int32_t v32 = *(int32_t *)(v23 + 52); // 0x8091e9f
        __fprintf_chk(stream, 1, "\tArc[%i %i %i %i %i %i %i %i %s]\n", v32, v31, v30, v29, v28, v27, v26, v25, v24);
        while (*v20 > v22) {
            // 0x8091e38
            v21 = v22;
            v22 = v21 + 1;
            v23 = 68 * v21 + *(int32_t *)(v2 + 48);
            v24 = flags_to_string(*(int32_t *)(v23 + 20), *(int32_t *)(v23 + 24));
            v25 = *(int32_t *)(v23 + 64);
            v26 = *(int32_t *)(v23 + 60);
            v27 = *(int32_t *)(v23 + 40);
            v28 = *(int32_t *)(v23 + 36);
            v29 = *(int32_t *)(v23 + 48);
            v30 = *(int32_t *)(v23 + 44);
            v31 = *(int32_t *)(v23 + 56);
            v32 = *(int32_t *)(v23 + 52);
            __fprintf_chk(stream, 1, "\tArc[%i %i %i %i %i %i %i %i %s]\n", v32, v31, v30, v29, v28, v27, v26, v25, v24);
        }
    }
    int32_t * v33 = (int32_t *)(v2 + 8); // 0x8091ecc
    if (*v33 != 0) {
        int32_t v34 = 0; // 0x8091f2c
        int32_t v35 = *(int32_t *)(v2 + 40) + 60 * v34; // 0x8091ee9
        int32_t v36 = *(int32_t *)(v35 + 36); // 0x8091eec
        unsigned char v37 = *(char *)(v35 + 48); // 0x8091ef3
        int32_t v38 = *(int32_t *)(v35 + 44); // 0x8091efb
        int32_t v39 = *(int32_t *)(v35 + 40); // 0x8091f02
        __fprintf_chk(stream, 1, "\tText[%i %i %i %i ", v39, v38, (int32_t)v37, v36);
        v34++;
        PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
        int32_t v40 = *(int32_t *)(v35 + 24); // 0x8091f42
        __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v35 + 20), v40));
        while (*v33 > v34) {
            // 0x8091ee0
            v35 = *(int32_t *)(v2 + 40) + 60 * v34;
            v36 = *(int32_t *)(v35 + 36);
            v37 = *(char *)(v35 + 48);
            v38 = *(int32_t *)(v35 + 44);
            v39 = *(int32_t *)(v35 + 40);
            __fprintf_chk(stream, 1, "\tText[%i %i %i %i ", v39, v38, (int32_t)v37, v36);
            v34++;
            PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
            v40 = *(int32_t *)(v35 + 24);
            __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v35 + 20), v40));
        }
    }
    // 0x8091f82
    for (int32_t i = 0; i < *(int32_t *)(v2 + 12); i++) {
        int32_t v41 = 60 * i + *(int32_t *)(v2 + 44); // 0x8091fa6
        int32_t v42 = *(int32_t *)(v41 + 24); // 0x8091fb7
        __fprintf_chk(stream, 1, "\tPolygon(%s)\n\t(", flags_to_string(*(int32_t *)(v41 + 20), v42));
        int32_t * v43 = (int32_t *)(v41 + 36); // 0x8091fe9
        if (*v43 != 0) {
            int32_t v44 = 0; // 0x8092003
            if (v44 % 5 == 0) {
                // 0x8092052
                fwrite((int32_t *)"\n\t\t", 1, 3, stream);
            }
            int32_t v45 = 20 * v44 + *(int32_t *)(v41 + 56); // 0x8092044
            v44++;
            __fprintf_chk(stream, 1, "[%i %i] ", *(int32_t *)v45, *(int32_t *)(v45 + 4));
            while (*v43 > v44) {
                // 0x8092032
                if (v44 % 5 == 0) {
                    // 0x8092052
                    fwrite((int32_t *)"\n\t\t", 1, 3, stream);
                }
                // 0x8092000
                v45 = 20 * v44 + *(int32_t *)(v41 + 56);
                v44++;
                __fprintf_chk(stream, 1, "[%i %i] ", *(int32_t *)v45, *(int32_t *)(v45 + 4));
            }
        }
        // 0x8092078
        fwrite((int32_t *)"\n\t)\n", 1, 4, stream);
    }
    // 0x80920ae
    fwrite((int32_t *)")\n", 1, 2, stream);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8092110 - 0x8092623
// Line range:    684 - 768
void WriteElementData(struct _IO_FILE * FP, int32_t * Data) {
    // 0x8092110
    int32_t v1; // 0x8092110
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x809211b
    int32_t v3 = *v2; // 0x809211b
    if (v3 == 0) {
        // 0x809261b
        return;
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)v1;
    int32_t v4 = v3; // 0x8092110
    int32_t v5 = 0; // 0x809260b
    int32_t v6; // 0x8092110
    int32_t * v7; // 0x8092144
    int32_t v8; // 0x8092141
    while (true) {
      lab_0x8092138:
        // 0x8092138
        v8 = 300 * v5 + *(int32_t *)(v1 + 32);
        v7 = (int32_t *)(v8 + 240);
        if (*v7 != 0) {
            goto lab_0x809261b;
        } else {
            // 0x809214e
            if (*(int32_t *)(v8 + 224) != 0) {
                goto lab_0x809261b;
            } else {
                // 0x8092158
                if (*(int32_t *)(v8 + 248) != 0) {
                    goto lab_0x809261b;
                } else {
                    // 0x8092162
                    v6 = v4;
                    if (*(int32_t *)(v8 + 232) == 0) {
                        goto lab_0x8092608;
                    } else {
                        goto lab_0x809261b;
                    }
                }
            }
        }
    }
  lab_0x809261b:;
    int32_t v9 = *(int32_t *)(v8 + 24); // 0x809217e
    __fprintf_chk(stream, 1, "\nElement[%s ", flags_to_string(*(int32_t *)(v8 + 20), v9));
    PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
    fputc(32, stream);
    PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
    fputc(32, stream);
    PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
    char * v10 = flags_to_string(*(int32_t *)(v8 + 56), *(int32_t *)(v8 + 60)); // 0x809222b
    int32_t * v11 = (int32_t *)(v8 + 216); // 0x8092230
    int32_t v12 = *v11; // 0x8092230
    int32_t * v13 = (int32_t *)(v8 + 220); // 0x8092236
    int32_t v14 = *v13; // 0x8092236
    int32_t v15 = *(int32_t *)(v8 + 72); // 0x8092240
    unsigned char v16 = *(char *)(v8 + 84); // 0x8092247
    int32_t v17 = *(int32_t *)(v8 + 80); // 0x809224f
    int32_t v18 = *(int32_t *)(v8 + 76); // 0x8092258
    __fprintf_chk(stream, 1, " %i %i %i %i %i %i %s]\n(\n", v12, v14, v18 - v12, v17 - v14, (int32_t)v16, v15, v10);
    int32_t * v19 = (int32_t *)(v8 + 288); // 0x8092281
    if (*v19 >= 1) {
        int32_t v20 = 0;
        int32_t v21 = v20 + 1; // 0x8092297
        int32_t v22 = 8 * v20 + *(int32_t *)(v8 + 296); // 0x809229a
        int32_t v23 = *(int32_t *)(v22 + 4); // 0x80922a0
        int32_t v24 = *(int32_t *)v22; // 0x80922a7
        __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v24, (char *)v23);
        while (v21 < *v19) {
            // 0x8092290
            v20 = v21;
            v21 = v20 + 1;
            v22 = 8 * v20 + *(int32_t *)(v8 + 296);
            v23 = *(int32_t *)(v22 + 4);
            v24 = *(int32_t *)v22;
            __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v24, (char *)v23);
        }
    }
    int32_t * v25 = (int32_t *)(v8 + 224); // 0x80922d5
    if (*v25 != 0) {
        for (int32_t i = 0; i < *v25; i++) {
            int32_t v26 = 76 * i + *(int32_t *)(v8 + 256); // 0x80922eb
            int32_t v27 = *(int32_t *)(v26 + 48); // 0x80922f4
            int32_t v28 = *(int32_t *)(v26 + 44); // 0x80922fb
            int32_t v29 = *(int32_t *)(v26 + 40); // 0x8092302
            int32_t v30 = *(int32_t *)(v26 + 36); // 0x8092309
            int32_t v31 = *(int32_t *)(v26 + 56); // 0x8092310
            int32_t v32 = *(int32_t *)(v26 + 52); // 0x809231d
            __fprintf_chk(stream, 1, "\tPin[%i %i %i %i %i %i ", v32 - *v11, v31 - *v13, v30, v29, v28, v27);
            PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
            __fprintf_chk(stream, 1, " ");
            PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
            int32_t v33 = *(int32_t *)(v26 + 24); // 0x8092390
            __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v26 + 20), v33));
        }
    }
    int32_t * v34 = (int32_t *)(v8 + 232); // 0x80923d3
    if (*v34 != 0) {
        for (int32_t i = 0; i < *v34; i++) {
            int32_t v35 = *v11; // 0x80923e8
            int32_t v36 = *(int32_t *)(v8 + 260) + 104 * i; // 0x80923f1
            int32_t v37 = *v13; // 0x80923f7
            int32_t v38 = *(int32_t *)(v36 + 84); // 0x8092403
            int32_t v39 = *(int32_t *)(v36 + 40); // 0x809240a
            int32_t v40 = *(int32_t *)(v36 + 36); // 0x8092411
            int32_t v41 = *(int32_t *)(v36 + 68); // 0x8092418
            int32_t v42 = *(int32_t *)(v36 + 64); // 0x8092421
            int32_t v43 = *(int32_t *)(v36 + 48); // 0x809242b
            int32_t v44 = *(int32_t *)(v36 + 44); // 0x8092434
            __fprintf_chk(stream, 1, "\tPad[%i %i %i %i %i %i %i ", v44 - v35, v43 - v37, v42 - v35, v41 - v37, v40, v39, v38);
            PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
            __fprintf_chk(stream, 1, " ");
            PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
            int32_t v45 = *(int32_t *)(v36 + 24); // 0x80924a4
            __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v36 + 20), v45));
        }
    }
    // 0x80924e7
    if (*v7 != 0) {
        int32_t v46 = 0;
        int32_t v47 = *v13; // 0x80924fb
        int32_t v48 = v46 + 1; // 0x8092501
        int32_t v49 = *(int32_t *)(v8 + 264) + 88 * v46; // 0x8092504
        int32_t v50 = *v11; // 0x809250a
        int32_t v51 = *(int32_t *)(v49 + 36); // 0x8092510
        int32_t v52 = *(int32_t *)(v49 + 68); // 0x8092517
        int32_t v53 = *(int32_t *)(v49 + 64); // 0x8092520
        int32_t v54 = *(int32_t *)(v49 + 48); // 0x8092529
        int32_t v55 = *(int32_t *)(v49 + 44); // 0x8092532
        __fprintf_chk(stream, 1, "\tElementLine [%i %i %i %i %i]\n", v55 - v50, v54 - v47, v53 - v50, v52 - v47, v51);
        while (*v7 > v48) {
            // 0x80924f8
            v46 = v48;
            v47 = *v13;
            v48 = v46 + 1;
            v49 = *(int32_t *)(v8 + 264) + 88 * v46;
            v50 = *v11;
            v51 = *(int32_t *)(v49 + 36);
            v52 = *(int32_t *)(v49 + 68);
            v53 = *(int32_t *)(v49 + 64);
            v54 = *(int32_t *)(v49 + 48);
            v55 = *(int32_t *)(v49 + 44);
            __fprintf_chk(stream, 1, "\tElementLine [%i %i %i %i %i]\n", v55 - v50, v54 - v47, v53 - v50, v52 - v47, v51);
        }
    }
    int32_t * v56 = (int32_t *)(v8 + 248); // 0x8092563
    if (*v56 != 0) {
        int32_t v57 = 0;
        int32_t v58 = v57 + 1; // 0x809257a
        int32_t v59 = 68 * v57 + *(int32_t *)(v8 + 268); // 0x8092583
        int32_t v60 = *(int32_t *)(v59 + 36); // 0x8092589
        int32_t v61 = *(int32_t *)(v59 + 64); // 0x8092590
        int32_t v62 = *(int32_t *)(v59 + 60); // 0x8092597
        int32_t v63 = *(int32_t *)(v59 + 48); // 0x809259e
        int32_t v64 = *(int32_t *)(v59 + 44); // 0x80925a5
        int32_t v65 = *(int32_t *)(v59 + 56); // 0x80925ac
        int32_t v66 = *v13; // 0x80925af
        int32_t v67 = *(int32_t *)(v59 + 52); // 0x80925b9
        int32_t v68 = *v11; // 0x80925bc
        __fprintf_chk(stream, 1, "\tElementArc [%i %i %i %i %i %i %i]\n", v67 - v68, v65 - v66, v64, v63, v62, v61, v60);
        while (*v56 > v58) {
            // 0x8092578
            v57 = v58;
            v58 = v57 + 1;
            v59 = 68 * v57 + *(int32_t *)(v8 + 268);
            v60 = *(int32_t *)(v59 + 36);
            v61 = *(int32_t *)(v59 + 64);
            v62 = *(int32_t *)(v59 + 60);
            v63 = *(int32_t *)(v59 + 48);
            v64 = *(int32_t *)(v59 + 44);
            v65 = *(int32_t *)(v59 + 56);
            v66 = *v13;
            v67 = *(int32_t *)(v59 + 52);
            v68 = *v11;
            __fprintf_chk(stream, 1, "\tElementArc [%i %i %i %i %i %i %i]\n", v67 - v68, v65 - v66, v64, v63, v62, v61, v60);
        }
    }
    // 0x80925e8
    fwrite((int32_t *)"\n\t)\n", 1, 4, stream);
    v6 = *v2;
    goto lab_0x8092608;
  lab_0x8092608:
    // 0x8092608
    v5++;
    v4 = v6;
    if (v6 <= v5) {
        // break -> 0x809261b
        goto lab_0x809261b;
    }
    goto lab_0x8092138;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8092630 - 0x809308c
// Line range:    850 - 665
int32_t WritePCB(struct _IO_FILE * FP) {
    // 0x8092630
    int32_t v1; // 0x8092630
    struct _IO_FILE * stream = (struct _IO_FILE *)v1; // 0x8092639
    WritePCBInfoHeader(stream);
    __fprintf_chk(stream, 1, "\n# To read pcb files, the pcb version (or the cvs source date) must be >= the file version\n");
    __fprintf_chk(stream, 1, "FileVersion[%i]\n", 0x1324007);
    fwrite((int32_t *)"\nPCB[", 1, 5, stream);
    PrintQuotedString((struct _IO_FILE *)&g279, (char *)&g279);
    __fprintf_chk(stream, 1, " %i %i]\n\n", Marked, (int32_t)(float32_t)g217);
    int32_t v2 = *(int32_t *)&Bumped; // 0x80926fc
    __fprintf_chk(stream, 1, "Grid[%s %i %i %i]\n", c_dtostr(g218), g216, v2, (int32_t)g178);
    char * v3 = c_dtostr(g219); // 0x809274f
    int64_t v4 = g198;
    float80_t v5 = Zoom_Multiplier;
    int32_t v6 = (float80_t)(int32_t)((0x100000000 * (int64_t)((int32_t)v4 >> 31) | v4 & 0xffffffff) / 2) / v5;
    int32_t v7; // 0x8092630
    if (g177 == 0) {
        // 0x8092edc
        v7 = Yorig + v6;
    } else {
        // 0x8092763
        v7 = (int32_t)(float32_t)g217 - (Yorig + v6);
    }
    char * v8 = g197; // 0x80927b3
    __fprintf_chk(stream, 1, "Cursor[%i %i %s]\n", Xorig + (int32_t)((float80_t)((int32_t)(v8 < NULL) + (int32_t)v8 >> 1) / v5), v7, v3);
    __fprintf_chk(stream, 1, "PolyArea[%s]\n", c_dtostr(g220));
    __fprintf_chk(stream, 1, "Thermal[%s]\n", c_dtostr(g221));
    __fprintf_chk(stream, 1, "DRC[%i %i %i %i %i %i]\n", g210, (int32_t)g211, (int32_t)g212, (int32_t)g213, (int32_t)g214, (int32_t)g215);
    __fprintf_chk(stream, 1, "Flags(%s)\n", pcbflags_to_string(vyl));
    __fprintf_chk(stream, 1, "Groups(\"%s\")\n", LayerGroupsToString((int32_t *)((int32_t)PCB + 0x1cd4)));
    fwrite((int32_t *)"Styles[\"", 1, 8, stream);
    int32_t v9 = (int32_t)PCB; // 0x8092944
    int32_t v10 = *(int32_t *)(v9 + 0x21a0); // 0x8092949
    int32_t v11 = *(int32_t *)(v9 + 0x219c); // 0x8092953
    int32_t v12 = *(int32_t *)(v9 + 0x2198); // 0x809295d
    int32_t v13 = *(int32_t *)(v9 + 0x2194); // 0x8092967
    int32_t v14 = *(int32_t *)(v9 + 0x21a4); // 0x8092971
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i:", (char *)v14, v13, v12, v11, v10);
    int32_t v15 = (int32_t)PCB; // 0x8092996
    int32_t v16 = *(int32_t *)(v15 + 0x21b8); // 0x809299b
    int32_t v17 = *(int32_t *)(v15 + 0x21b4); // 0x80929a5
    int32_t v18 = *(int32_t *)(v15 + 0x21b0); // 0x80929af
    int32_t v19 = *(int32_t *)(v15 + 0x21ac); // 0x80929b9
    int32_t v20 = *(int32_t *)(v15 + 0x21bc); // 0x80929c6
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i:", (char *)v20, v19, v18, v17, v16);
    int32_t v21 = (int32_t)PCB; // 0x80929e8
    int32_t v22 = *(int32_t *)(v21 + 0x21d0); // 0x80929ed
    int32_t v23 = *(int32_t *)(v21 + 0x21cc); // 0x80929f7
    int32_t v24 = *(int32_t *)(v21 + 0x21c8); // 0x8092a01
    int32_t v25 = *(int32_t *)(v21 + 0x21c4); // 0x8092a0b
    int32_t v26 = *(int32_t *)(v21 + 0x21d4); // 0x8092a15
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i:", (char *)v26, v25, v24, v23, v22);
    int32_t v27 = (int32_t)PCB; // 0x8092a3a
    int32_t v28 = *(int32_t *)(v27 + 0x21e8); // 0x8092a3f
    int32_t v29 = *(int32_t *)(v27 + 0x21e4); // 0x8092a49
    int32_t v30 = *(int32_t *)(v27 + 0x21e0); // 0x8092a53
    int32_t v31 = *(int32_t *)(v27 + 0x21dc); // 0x8092a5d
    int32_t v32 = *(int32_t *)(v27 + 0x21ec); // 0x8092a6a
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i\"]\n\n", (char *)v32, v31, v30, v29, v28);
    char v33 = 0; // 0x8092a9c
    int32_t v34 = (int32_t)PCB; // 0x8092a9c
    int32_t v35; // 0x8092630
    int32_t v36; // 0x8092630
    int32_t v37; // 0x8092630
    int32_t v38; // 0x8092630
    int32_t v39; // 0x8092630
    int32_t v40; // 0x8092630
    int32_t v41; // 0x8092630
    int32_t v42; // 0x8092630
    int32_t v43; // 0x8092630
    int32_t v44; // 0x8092b67
    while (true) {
        int32_t v45 = v34;
        char v46 = v33;
        if (*(char *)(v45 + 212) != 0) {
            int16_t ** v47 = __ctype_b_loc(); // 0x8092ab0
            int32_t v48 = v46; // 0x8092ab5
            int32_t v49 = *(int32_t *)(v45 + 232);
            if ((*(char *)((2 * v48 | 1) + (int32_t)*v47) & 64) != 0) {
                int32_t v50 = v49 / 100; // 0x8092e78
                if (v49 == 100 * v50) {
                    // 0x8092eb0
                    __fprintf_chk(stream, 1, "Symbol('%c' %i)\n(\n", v46, v50);
                } else {
                    // 0x8092e81
                    __fprintf_chk(stream, 1, "Symbol['%c' %i]\n(\n", v46, v49);
                }
            } else {
                // 0x8092ac5
                __fprintf_chk(stream, 1, "Symbol[%i %i]\n(\n", v48, v49);
            }
            int32_t v51 = *(int32_t *)(v45 + 216); // 0x8092af7
            if (v51 != 0) {
                // 0x8092b67
                v39 = v51;
                v35 = *(int32_t *)(v45 + 208);
                while (true) {
                  lab_0x8092b67:
                    // 0x8092b67
                    v36 = v35;
                    v44 = *(int32_t *)(v36 + 44);
                    int32_t v52 = v44 / 100; // 0x8092b7b
                    if (v44 != 100 * v52) {
                        // 0x8092c00
                        v41 = *(int32_t *)(v36 + 64);
                        v38 = *(int32_t *)(v36 + 48);
                        goto lab_0x8092c09;
                    } else {
                        int32_t v53 = *(int32_t *)(v36 + 48); // 0x8092b84
                        int32_t v54 = v53 / 100; // 0x8092b96
                        int32_t v55 = *(int32_t *)(v36 + 64);
                        if (v53 != 100 * v54) {
                            // 0x8092b10
                            v40 = v55;
                            v42 = *(int32_t *)(v36 + 68);
                            v43 = *(int32_t *)(v36 + 36);
                            v37 = v53;
                            goto lab_0x8092b22;
                        } else {
                            int32_t v56 = v55 / 100; // 0x8092bbc
                            v41 = v55;
                            v38 = v53;
                            if (v55 != 100 * v56) {
                                goto lab_0x8092c09;
                            } else {
                                int32_t v57 = *(int32_t *)(v36 + 68); // 0x8092bc9
                                int32_t v58 = v57 / 100; // 0x8092be0
                                int32_t v59 = *(int32_t *)(v36 + 36);
                                v40 = v55;
                                v42 = v57;
                                v43 = v59;
                                v37 = v53;
                                if (v57 == 100 * v58) {
                                    int32_t v60 = v59 / 100; // 0x8092e0e
                                    v40 = v55;
                                    v42 = v57;
                                    v43 = v59;
                                    v37 = v53;
                                    if (v59 != 100 * v60) {
                                        goto lab_0x8092b22;
                                    } else {
                                        // 0x8092e1c
                                        __fprintf_chk(stream, 1, "\tSymbolLine(%i %i %i %i %i)\n", v52, v54, v56, v58, v60);
                                        goto lab_0x8092b5a;
                                    }
                                } else {
                                    goto lab_0x8092b22;
                                }
                            }
                        }
                    }
                }
            }
          lab_0x8092c20:
            // 0x8092c20
            fwrite((int32_t *)")\n", 1, 2, stream);
        }
        // 0x8092c43
        v33 = v46 + 1;
        v34 = v45 + 28;
    }
  lab_0x8092c09:
    // 0x8092c09
    v40 = v41;
    v42 = *(int32_t *)(v36 + 68);
    v43 = *(int32_t *)(v36 + 36);
    v37 = v38;
    goto lab_0x8092b22;
  lab_0x8092b22:
    // 0x8092b22
    __fprintf_chk(stream, 1, "\tSymbolLine[%i %i %i %i %i]\n", v44, v37, v40, v42, v43);
    goto lab_0x8092b5a;
  lab_0x8092b5a:;
    int32_t v61 = v39 - 1; // 0x8092b5a
    v39 = v61;
    v35 = v36 + 88;
    if (v61 == 0) {
        // break -> 0x8092c20
        goto lab_0x8092c20;
    }
    goto lab_0x8092b67;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093090 - 0x80930de
// Line range:    872 - 880
int32_t WritePCBFile(char * Filename) {
    // 0x8093090
    int32_t v1; // 0x8093090
    char * file_path = (char *)v1;
    struct _IO_FILE * file = fopen(file_path, "w"); // 0x80930a9
    int32_t result; // 0x8093090
    if (file == NULL) {
        // 0x80930cf
        OpenErrorMessage(file_path);
        result = -1;
    } else {
        int32_t v2 = WritePCB((struct _IO_FILE *)&g279); // 0x80930b4
        fclose(file);
        result = v2;
    }
    // 0x80930c3
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x80930e0 - 0x809311e
// Line range:    1070 - 1073
void SaveTMPData(void) {
    // 0x80930e0
    __sprintf_chk(TMPFilename, 1, 80, "PCB.%.8i.save", getpid());
    WritePCBFile((char *)&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093120 - 0x80931b0
// Line range:    951 - 962
void SaveInTMP(void) {
    int32_t v1 = __readgsdword(20); // 0x809312a
    if (PCB != NULL && g199 != 0) {
        // 0x8093144
        int32_t v2; // bp-96, 0x8093120
        __sprintf_chk((char *)&v2, 1, 80, "PCB.%.8i.save", getpid());
        Message("Trying to save your layout in '%s'\n", &v2);
        WritePCBFile((char *)&g279);
    }
    // 0x8093187
    if (v1 == __readgsdword(20)) {
        // 0x8093193
        return;
    }
    // 0x809319c
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x80931b0 - 0x80931d6
// Line range:    970 - 978
void EmergencySave(void) {
    // 0x80931b0
    if (dont_save_any_more != 0) {
        // 0x80931bf
        return;
    }
    // 0x80931c8
    SaveInTMP();
    dont_save_any_more = 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093330 - 0x80933d5
// Line range:    429 - 446
void PostLoadElementPCB(void) {
    // 0x8093330
    if (yyPCB != NULL) {
        // 0x809334b
        CreateNewPCBPost(yyPCB, 0);
        ParseGroupString("1,c:2,s", (int32_t *)((int32_t)yyPCB + 0x1cd4), yynerrs);
        int32_t v1 = (int32_t)yyPCB; // 0x8093381
        int32_t v2 = *(int32_t *)(v1 + 0x220c); // 0x8093386
        *(int32_t *)&PCB = v1;
        int32_t v3 = *(int32_t *)(v2 + 32); // 0x8093391
        int32_t * v4 = (int32_t *)v3; // 0x809339d
        MoveElementLowLevel((int32_t *)v2, v4, -*v4, -*(int32_t *)(v3 + 4));
        *(int32_t *)&PCB = (int32_t)PCB;
        g262 = *(int32_t *)(v3 + 8);
        g263 = *(int32_t *)(v3 + 12);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x80933e0 - 0x809364a
// Line range:    349 - 380
int32_t LoadPCB(char * Filename) {
    int32_t * v1 = CreateNewPCB(0); // 0x80933f3
    int32_t v2 = ParsePCB(v1, Filename); // 0x8093401
    if (v2 != 0) {
        // 0x80935a0
        hid_action("PCBChanged");
        RemovePCB(v1);
        return 1;
    }
    // 0x8093410
    RemovePCB(PCB);
    *(int32_t *)&PCB = (int32_t)v1;
    CreateNewPCBPost(v1, 0);
    ResetStackAndVisibility();
    int32_t v3 = Marked; // 0x809343d
    int32_t v4 = g207; // 0x8093443
    int32_t v5 = v4 - v3; // 0x8093443
    float80_t v6 = Zoom_Multiplier; // 0x8093446
    int32_t v7 = v5 == 0 | v5 < 0 != ((v5 ^ v4) & (v4 ^ v3)) < 0 ? v4 : v3; // 0x809344e
    int32_t v8 = v7 < 0 ? v2 : v7; // 0x8093454
    g222 = (int64_t)v8;
    float64_t v9 = g217; // 0x809345d
    int32_t v10 = g208; // 0x8093463
    int32_t v11 = v10 - (int32_t)(float32_t)v9; // 0x8093463
    int32_t v12 = v11 < 0 == ((v11 ^ v10) & (v10 ^ (int32_t)(float32_t)v9)) < 0 == (v11 != 0) ? (int32_t)(float32_t)v9 : v10; // 0x8093469
    int32_t v13 = v12 < 0 ? v2 : v12; // 0x809346e
    char * v14 = g197;
    g223 = (int64_t)v13;
    Xorig = v8 - (int32_t)((float80_t)((int32_t)(v14 < NULL) + (int32_t)v14 >> 1) / v6);
    int32_t v15 = g198; // 0x80934b0
    Yorig = v13 - (int32_t)((float80_t)((int32_t)(v15 < 0) + v15 >> 1) / v6);
    ChangePCBSize(v3, (int32_t)(float32_t)v9);
    if (*(char *)((int32_t)PCB + 0x1cd0) == 0) {
        // 0x8093630
        Message("File '%s' has no font information, using default font\n", Filename);
        CreateDefaultFont();
    }
    // 0x80934f9
    SetChangedFlag(0);
    g195 = MyStrdup(Filename, "LoadPCB()");
    float64_t v16 = g218; // 0x8093523
    *(char *)&Settings = (char)(v16 != v16 || 0.0 != 0.0);
    netlist_sort_offset = 2;
    sort_library((int32_t *)(int32_t)v16);
    netlist_sort_offset = 0;
    if (hid_get_flag("style") == 0) {
        // 0x80935c8
        SetLineSize(*(int32_t *)((int32_t)PCB + 0x2194));
        SetViaSize(*(int32_t *)((int32_t)PCB + 0x2198), 1);
        SetViaDrillingHole(*(int32_t *)((int32_t)PCB + 0x219c), 1);
        SetKeepawayWidth(*(int32_t *)((int32_t)PCB + 0x21a0));
    }
    // 0x8093588
    hid_action("PCBChanged");
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093910 - 0x8093ec0
// Line range:    1100 - 1220
int32_t ParseLibraryTree(void) {
    // 0x809396d
    int32_t str2; // bp-4129, 0x8093910
    int32_t v1 = &str2; // 0x809391b
    int32_t v2 = __readgsdword(20); // 0x8093924
    __asm_rep_stosd_memset((char *)&str2, 0, 1024);
    bool v3; // 0x8093910
    int32_t v4 = v3 ? -0x1000 : 0x1000;
    *(char *)(v4 + v1) = 0;
    int32_t path; // bp-8226, 0x8093910
    __asm_rep_stosd_memset((char *)&path, 0, 1024);
    *(char *)(v4 + (int32_t)&path) = 0;
    GetWorkingDirectory((char *)&path);
    char * str = MyStrdup(g155, "ParseLibraryTree"); // 0x80939c8
    char * next_token = strtok(str, ":"); // 0x80939de
    if (next_token != NULL) {
        // 0x80939eb
        if (*next_token != 0) {
            // 0x8093a00
            strncpy((char *)&str2, next_token, 0x1000);
            chdir((char *)&path);
            struct __dirstream * dirp = opendir((char *)&str2); // 0x8093a31
            struct dirent * v5; // 0x8093910
            struct dirent * v6; // 0x8093910
            int32_t * dir; // bp-8316, 0x8093910
            struct dirent * v7; // 0x8093a69
            int32_t v8; // 0x8093910
            char * name; // 0x8093910
            char v9; // 0x8093ab9
            struct dirent * v10; // 0x8093a69
            int32_t * v11; // 0x8093aff
            char * found_char_pos; // 0x8093b33
            char * v12; // 0x8093b47
            struct __dirstream * dirp2; // 0x8093b58
            struct dirent * v13; // 0x8093a69
            struct dirent * v14; // 0x8093b89
            char * str3; // 0x8093ba4
            struct dirent * v15; // 0x8093b89
            int32_t v16; // 0x8093910
            if (dirp == NULL) {
                // 0x8093e5b
                OpendirErrorMessage((char *)&str2);
            } else {
                // 0x8093a44
                chdir((char *)&str2);
                GetWorkingDirectory((char *)&str2);
                v7 = readdir(dirp);
                v6 = v7;
                if (v7 != NULL) {
                    v10 = v6;
                    while (true) {
                        // 0x8093a78
                        v8 = (int32_t)v10;
                        chdir((char *)&str2);
                        name = (char *)(v8 + 11);
                        if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                            // 0x8093ab9
                            v9 = *name;
                            if (v9 != 46) {
                                if (v9 != 67) {
                                    // break -> 0x8093af8
                                    break;
                                }
                                // 0x8093acb
                                if (*(char *)(v8 + 12) != 86) {
                                    // break -> 0x8093af8
                                    break;
                                }
                                // 0x8093ad7
                                if (*(char *)(v8 + 13) != 83) {
                                    // break -> 0x8093af8
                                    break;
                                }
                                // 0x8093ae3
                                if (*(char *)(v8 + 14) != 0) {
                                    // break -> 0x8093af8
                                    break;
                                }
                            }
                        }
                        // 0x8093a60
                        v10 = readdir(dirp);
                        if (v10 == NULL) {
                            // break (via goto) -> 0x8093de0
                            goto lab_0x8093de0;
                        }
                    }
                    // 0x8093af8
                    v11 = GetLibraryMenuMemory(&Library);
                    *v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                    found_char_pos = strrchr((char *)&str2, 47);
                    v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                    *(int32_t *)((int32_t)v11 + 4) = (int32_t)v12;
                    dirp2 = opendir(name);
                    chdir(name);
                    if (dirp2 != NULL) {
                        // 0x8093b80
                        v14 = readdir(dirp2);
                        v5 = v14;
                        if (v14 != NULL) {
                            str3 = (char *)((int32_t)v5 + 11);
                            strlen(str3);
                            __xstat(3, str3, (struct stat *)&dir);
                            v15 = readdir(dirp2);
                            while (v15 != NULL) {
                                // 0x8093b98
                                str3 = (char *)((int32_t)v15 + 11);
                                strlen(str3);
                                __xstat(3, str3, (struct stat *)&dir);
                                v15 = readdir(dirp2);
                            }
                        }
                    }
                    // 0x8093e48
                    closedir(dirp2);
                    v13 = readdir(dirp);
                    while (v13 != NULL) {
                        // 0x8093a78
                        v10 = v13;
                        while (true) {
                            // 0x8093a78
                            v8 = (int32_t)v10;
                            chdir((char *)&str2);
                            name = (char *)(v8 + 11);
                            if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                                // 0x8093ab9
                                v9 = *name;
                                if (v9 != 46) {
                                    if (v9 != 67) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093acb
                                    if (*(char *)(v8 + 12) != 86) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ad7
                                    if (*(char *)(v8 + 13) != 83) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ae3
                                    if (*(char *)(v8 + 14) != 0) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                }
                            }
                            // 0x8093a60
                            v10 = readdir(dirp);
                            if (v10 == NULL) {
                                // break (via goto) -> 0x8093de0
                                goto lab_0x8093de0;
                            }
                        }
                        // 0x8093af8
                        v11 = GetLibraryMenuMemory(&Library);
                        *v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                        found_char_pos = strrchr((char *)&str2, 47);
                        v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                        *(int32_t *)((int32_t)v11 + 4) = (int32_t)v12;
                        dirp2 = opendir(name);
                        chdir(name);
                        if (dirp2 != NULL) {
                            // 0x8093b80
                            v14 = readdir(dirp2);
                            v5 = v14;
                            if (v14 != NULL) {
                                str3 = (char *)((int32_t)v5 + 11);
                                strlen(str3);
                                __xstat(3, str3, (struct stat *)&dir);
                                v15 = readdir(dirp2);
                                while (v15 != NULL) {
                                    // 0x8093b98
                                    str3 = (char *)((int32_t)v15 + 11);
                                    strlen(str3);
                                    __xstat(3, str3, (struct stat *)&dir);
                                    v15 = readdir(dirp2);
                                }
                            }
                        }
                        // 0x8093e48
                        closedir(dirp2);
                        v13 = readdir(dirp);
                    }
                }
                // 0x8093de0
                closedir(dirp);
            }
            char * next_token2 = strtok(NULL, ":"); // 0x8093dfd
            while (next_token2 != NULL) {
                // 0x8093e06
                if (*next_token2 == 0) {
                    // break -> 0x8093e0f
                    break;
                }
                strncpy((char *)&str2, next_token2, 0x1000);
                chdir((char *)&path);
                dirp = opendir((char *)&str2);
                if (dirp == NULL) {
                    // 0x8093e5b
                    OpendirErrorMessage((char *)&str2);
                } else {
                    // 0x8093a44
                    chdir((char *)&str2);
                    GetWorkingDirectory((char *)&str2);
                    v7 = readdir(dirp);
                    v6 = v7;
                    if (v7 != NULL) {
                        v10 = v6;
                        while (true) {
                            // 0x8093a78
                            v8 = (int32_t)v10;
                            chdir((char *)&str2);
                            name = (char *)(v8 + 11);
                            if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                                // 0x8093ab9
                                v9 = *name;
                                if (v9 != 46) {
                                    if (v9 != 67) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093acb
                                    if (*(char *)(v8 + 12) != 86) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ad7
                                    if (*(char *)(v8 + 13) != 83) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ae3
                                    if (*(char *)(v8 + 14) != 0) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                }
                            }
                            // 0x8093a60
                            v10 = readdir(dirp);
                            if (v10 == NULL) {
                                // break (via goto) -> 0x8093de0
                                goto lab_0x8093de0;
                            }
                        }
                        // 0x8093af8
                        v11 = GetLibraryMenuMemory(&Library);
                        *v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                        found_char_pos = strrchr((char *)&str2, 47);
                        v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                        *(int32_t *)((int32_t)v11 + 4) = (int32_t)v12;
                        dirp2 = opendir(name);
                        chdir(name);
                        if (dirp2 != NULL) {
                            // 0x8093b80
                            v14 = readdir(dirp2);
                            v5 = v14;
                            if (v14 != NULL) {
                                str3 = (char *)((int32_t)v5 + 11);
                                strlen(str3);
                                __xstat(3, str3, (struct stat *)&dir);
                                v15 = readdir(dirp2);
                                while (v15 != NULL) {
                                    // 0x8093b98
                                    str3 = (char *)((int32_t)v15 + 11);
                                    strlen(str3);
                                    __xstat(3, str3, (struct stat *)&dir);
                                    v15 = readdir(dirp2);
                                }
                            }
                        }
                        // 0x8093e48
                        closedir(dirp2);
                        v13 = readdir(dirp);
                        while (v13 != NULL) {
                            // 0x8093a78
                            v10 = v13;
                            while (true) {
                                // 0x8093a78
                                v8 = (int32_t)v10;
                                chdir((char *)&str2);
                                name = (char *)(v8 + 11);
                                if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                                    // 0x8093ab9
                                    v9 = *name;
                                    if (v9 != 46) {
                                        if (v9 != 67) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                        // 0x8093acb
                                        if (*(char *)(v8 + 12) != 86) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                        // 0x8093ad7
                                        if (*(char *)(v8 + 13) != 83) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                        // 0x8093ae3
                                        if (*(char *)(v8 + 14) != 0) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                    }
                                }
                                // 0x8093a60
                                v10 = readdir(dirp);
                                if (v10 == NULL) {
                                    // break (via goto) -> 0x8093de0
                                    goto lab_0x8093de0;
                                }
                            }
                            // 0x8093af8
                            v11 = GetLibraryMenuMemory(&Library);
                            *v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                            found_char_pos = strrchr((char *)&str2, 47);
                            v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                            *(int32_t *)((int32_t)v11 + 4) = (int32_t)v12;
                            dirp2 = opendir(name);
                            chdir(name);
                            if (dirp2 != NULL) {
                                // 0x8093b80
                                v14 = readdir(dirp2);
                                v5 = v14;
                                if (v14 != NULL) {
                                    str3 = (char *)((int32_t)v5 + 11);
                                    strlen(str3);
                                    __xstat(3, str3, (struct stat *)&dir);
                                    v15 = readdir(dirp2);
                                    while (v15 != NULL) {
                                        // 0x8093b98
                                        str3 = (char *)((int32_t)v15 + 11);
                                        strlen(str3);
                                        __xstat(3, str3, (struct stat *)&dir);
                                        v15 = readdir(dirp2);
                                    }
                                }
                            }
                            // 0x8093e48
                            closedir(dirp2);
                            v13 = readdir(dirp);
                        }
                    }
                    // 0x8093de0
                    closedir(dirp);
                }
                // 0x8093dee
                next_token2 = strtok(NULL, ":");
            }
        }
    }
    // 0x8093e0f
    free((int32_t *)str);
    chdir((char *)&path);
    if (v2 == __readgsdword(20)) {
        // 0x8093e3d
        return 0;
    }
    // 0x8093eb6
    __stack_chk_fail();
    return &g279;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093ec0 - 0x8094290
// Line range:    1227 - 1314
int32_t ReadLibraryContents(void) {
    int32_t v1 = __readgsdword(20); // 0x8093ecc
    SaveFree((char *)g57);
    g57 = 0;
    char * command = EvaluateFilename(g154, g161, g156, NULL); // 0x8093f10
    g57 = (int32_t)command;
    int32_t * v2 = NULL; // 0x8093f1c
    int32_t * v3; // 0x8093ec0
    int32_t v4; // 0x8093ec0
    int32_t v5; // 0x8093ec0
    int32_t * v6; // 0x8093ec0
    int32_t * v7; // 0x8093ec0
    int32_t * v8; // 0x8093ec0
    int32_t str2; // bp-288, 0x8093ec0
    struct _IO_FILE * stream; // 0x8093f83
    int32_t * v9; // 0x8094207
    int32_t * v10; // 0x809405e
    int32_t v11; // 0x809405e
    if (command != NULL) {
        // 0x8093f1e
        v2 = NULL;
        if (*command != 0) {
            // 0x8093f78
            stream = popen(command, "r");
            if (stream == NULL) {
                // 0x8094272
                PopenErrorMessage((char *)g57);
                v2 = &stream->e0;
            } else {
                // 0x8093f96
                if (fgets((char *)&str2, 255, stream) != NULL) {
                    int32_t v12 = &str2; // 0x8093f9c
                    bool v13; // 0x8093ec0
                    int32_t v14 = v13 ? -1 : 1;
                    v6 = NULL;
                    while (true) {
                      lab_0x8093fdc:;
                        int32_t * v15 = v6;
                        int32_t v16 = v12;
                        int32_t v17 = *(int32_t *)v16; // 0x8093fdc
                        int32_t v18 = v16 + 4; // 0x8093fde
                        int32_t v19 = v17 - 0x1010101 & (v17 ^ -0x7f7f7f80); // 0x8093fe9
                        uint32_t v20 = v19 & -0x7f7f7f80; // 0x8093feb
                        while (v20 == 0) {
                            // 0x8093fdc
                            v16 = v18;
                            v17 = *(int32_t *)v16;
                            v18 = v16 + 4;
                            v19 = v17 - 0x1010101 & (v17 ^ -0x7f7f7f80);
                            v20 = v19 & -0x7f7f7f80;
                        }
                        unsigned char v21 = (char)((v19 & 0x8080) == 0 ? v20 / 0x10000 : v20); // 0x8094005
                        int32_t v22 = ((v19 & 0x8080) == 0 ? v16 + 6 : v18) - (-1 - v21 < v21 ? 4 : 3) - v12; // 0x809400a
                        if (v22 != 0) {
                            // 0x809400e
                            int32_t v23; // bp-4, 0x8093ec0
                            char * v24 = (char *)((int32_t)&v23 - 285 + v22); // 0x8094011
                            if (*v24 == 10) {
                                // 0x80941d8
                                *v24 = 0;
                            } else {
                                // 0x809401f
                                Message("linelength (%i) exceeded; following characters will be ignored\n", 255);
                            }
                        }
                        int32_t v25 = 5; // 0x809403f
                        int32_t v26 = v12;
                        int32_t v27 = (int32_t)"TYPE=";
                        while (*(char *)v26 == *(char *)v27) {
                            v25--;
                            int32_t v28 = v27 + v14; // 0x809403f
                            int32_t v29 = v26 + v14; // 0x809403f
                            if (v25 == 0) {
                                int32_t * v30 = GetLibraryMenuMemory(&Library); // 0x8094187
                                char v31; // bp-283, 0x8093ec0
                                char * v32 = v31 != 0 ? &v31 : "(unknown)"; // 0x80941b0
                                *v30 = (int32_t)MyStrdup(v32, "ReadLibraryDescription()");
                                *(int32_t *)((int32_t)v30 + 4) = (int32_t)__strdup(g156);
                                v7 = v30;
                                goto lab_0x8093fb8;
                            }
                            v26 = v29;
                            v27 = v28;
                        }
                        // 0x8094047
                        v9 = v15;
                        if (v15 == NULL) {
                            // 0x8094200
                            v9 = GetLibraryMenuMemory(&Library);
                            *v9 = (int32_t)MyStrdup("(unknown)", "ReadLibraryDescription()");
                            *(int32_t *)((int32_t)v9 + 4) = (int32_t)__strdup(g156);
                        }
                        // 0x8094055
                        v10 = GetLibraryEntryMemory(v9);
                        v11 = (int32_t)v10;
                        char * str3 = MyStrdup((char *)&str2, "ReadLibraryDescription()"); // 0x8094070
                        *(int32_t *)(v11 + 4) = (int32_t)str3;
                        char * next_token = strtok(str3, ":"); // 0x8094083
                        *(int32_t *)(v11 + 8) = (int32_t)next_token;
                        if (next_token == NULL) {
                            goto lab_0x8094178;
                        } else {
                            char * next_token2 = strtok(NULL, ":"); // 0x80940a2
                            *(int32_t *)(v11 + 12) = (int32_t)next_token2;
                            if (next_token2 == NULL) {
                                goto lab_0x8094178;
                            } else {
                                char * next_token3 = strtok(NULL, ":"); // 0x80940c1
                                int32_t * v33 = (int32_t *)(v11 + 16);
                                *v33 = (int32_t)next_token3;
                                if (next_token3 == NULL) {
                                    // 0x80941e8
                                    v8 = (int32_t *)4;
                                    v5 = *(int32_t *)(v11 + 20);
                                    goto lab_0x8094106;
                                } else {
                                    int32_t next_token4 = (int32_t)strtok(NULL, ":"); // 0x80940e0
                                    *(int32_t *)(v11 + 20) = next_token4;
                                    v3 = v33;
                                    v4 = next_token4;
                                    goto lab_0x80940ea;
                                }
                            }
                        }
                    }
                }
              lab_0x8094250:
                // 0x8094250
                pclose(stream);
                v2 = &stream->e0;
            }
        }
    }
    int32_t result = 1; // 0x8093f34
    if (ParseLibraryTree() > 0 || v2 != NULL) {
        // 0x8093f36
        sort_library(&g279);
        result = 0;
    }
    // 0x8093f42
    if (v1 != __readgsdword(20)) {
        // 0x8094284
        __stack_chk_fail();
        return &g279;
    }
    // 0x8093f52
    return result;
  lab_0x8094178:
    // 0x8094178
    v3 = (int32_t *)(v11 + 16);
    v4 = *(int32_t *)(v11 + 20);
    goto lab_0x80940ea;
  lab_0x80940ea:;
    int32_t v34 = v4;
    int32_t str4 = *v3; // 0x80940ea
    v8 = (int32_t *)4;
    v5 = v34;
    if (str4 != 0) {
        // 0x80940f5
        v8 = (int32_t *)(strlen((char *)str4) + 4);
        v5 = v34;
    }
    goto lab_0x8094106;
  lab_0x8094106:
    // 0x8094106
    if (v5 != 0) {
        // 0x809410c
        int32_t str5; // 0x8093ec0
        int32_t len = strlen((char *)str5); // 0x809410f
    }
    char * v35 = MyCalloc((int32_t)v8, 1, "ReadLibraryDescription()"); // 0x809412d
    int32_t v36 = *(int32_t *)(v11 + 20); // 0x8094132
    int32_t v37 = v36 == 0 ? (int32_t)&g5 : v36; // 0x809413c
    *v10 = (int32_t)v35;
    int32_t v38 = *(int32_t *)(v11 + 16); // 0x8094141
    int32_t v39 = v38 == 0 ? (int32_t)&g5 : v38; // 0x809415a
    __sprintf_chk(v35, 1, -1, "%s, %s", (char *)v39, (char *)v37);
    v7 = v9;
    goto lab_0x8093fb8;
  lab_0x8093fb8:;
    char * str = fgets((char *)&str2, 255, stream); // 0x8093fcd
    v6 = v7;
    if (str == NULL) {
        // break -> 0x8094250
        goto lab_0x8094250;
    }
    goto lab_0x8093fdc;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/find.c
// Address range: 0x8096d20 - 0x8097082
// Line range:    3439 - 3502
void ResetFoundLinesAndPolygons(char AndDraw) {
    int32_t v1 = (int32_t)PCB; // 0x8096d34
    int32_t v2 = *(int32_t *)(v1 + 0x220c); // 0x8096d39
    int32_t v3 = *(int32_t *)(v2 + 16); // 0x8096d3f
    char v4 = 0; // 0x8096d48
    int32_t v5 = v1; // 0x8096d48
    int32_t v6 = v2; // 0x8096d48
    char v7; // 0x8096d20
    char v8; // 0x8096d20
    char v9; // 0x8096d20
    int32_t v10; // 0x8096d20
    int32_t v11; // 0x8096d20
    int32_t v12; // 0x8096d20
    int32_t v13; // 0x8096d20
    int32_t v14; // 0x8096d20
    int32_t v15; // 0x8096d20
    int32_t v16; // 0x8096d20
    int32_t v17; // 0x8096d20
    int32_t v18; // 0x8096d20
    if (v3 != 0) {
        // 0x8096d4e
        v9 = 0;
        v11 = v1;
        v14 = v2;
        v18 = 92 * v3;
        v16 = v3;
        while (true) {
          lab_0x8096d74:
            // 0x8096d74
            v12 = v11;
            v15 = v16 - 1;
            v17 = v18 - 92;
            int32_t v19 = *(int32_t *)(v14 + 36) + v17; // 0x8096d7d
            int32_t * v20 = (int32_t *)(v19 + 20); // 0x8096d7f
            int32_t v21 = *v20; // 0x8096d7f
            v7 = v9;
            if ((v21 & TheFlag) == 0) {
                goto lab_0x8096d63;
            } else {
                if (AndDraw == 0) {
                    // 0x8096d58
                    *v20 = v21 & -1 - TheFlag;
                    v7 = 1;
                    goto lab_0x8096d63;
                } else {
                    char * v22 = (char *)v19; // 0x8096da5
                    AddObjectToFlagUndoList(32, v22, v22, v22);
                    *v20 = *v20 & -1 - TheFlag;
                    DrawRat((int32_t *)v19, 0);
                    int32_t v23 = (int32_t)PCB;
                    v8 = 1;
                    v10 = v23;
                    v4 = 1;
                    v13 = v23;
                    if (v15 == 0) {
                        // break -> 0x8096dd2
                        break;
                    }
                    goto lab_0x8096d6e;
                }
            }
        }
      lab_0x8096dd2:
        // 0x8096dd2
        v5 = v13;
        v6 = *(int32_t *)(v5 + 0x220c);
    }
    char v24 = v4; // 0x8096de0
    char v25; // 0x8096d20
    char v26; // 0x8096d20
    char v27; // 0x8096d20
    char v28; // 0x8096d20
    char v29; // 0x8096d20
    char v30; // 0x8096d20
    char v31; // 0x8096d20
    int32_t v32; // 0x8096d20
    int32_t v33; // 0x8096d20
    int32_t v34; // 0x8096d20
    int32_t v35; // 0x8096d20
    if (*(int32_t *)(v6 + 24) != 0) {
        int32_t v36 = 0; // 0x8096ded
        int32_t v37 = v6 + 76;
        char v38 = v4;
        int32_t v39 = *(int32_t *)(v37 + 4); // 0x8096df0
        char v40 = v38; // 0x8096df9
        int32_t v41 = v5; // 0x8096df9
        int32_t v42; // 0x8096d20
        char * v43; // 0x8096d20
        int32_t * v44; // 0x8096d20
        int32_t v45; // 0x8096e27
        int32_t * v46; // 0x8096e29
        int32_t v47; // 0x8096e29
        char * v48; // 0x8096e52
        if (v39 != 0) {
            // 0x8096dff
            v43 = (char *)v37;
            v44 = (int32_t *)v37;
            while (true) {
                // 0x8096e1e
                v42 = 88 * v39 - 88;
                v32 = v39 - 1;
                v45 = *(int32_t *)(v37 + 36) + v42;
                v46 = (int32_t *)(v45 + 20);
                v47 = *v46;
                v30 = v38;
                if ((v47 & TheFlag) == 0) {
                    goto lab_0x8096e13;
                } else {
                    if (AndDraw == 0) {
                        // 0x8096e08
                        *v46 = v47 & -1 - TheFlag;
                        v30 = 1;
                        goto lab_0x8096e13;
                    } else {
                        // 0x8096e36
                        v48 = (char *)v45;
                        AddObjectToFlagUndoList(4, v43, v48, v48);
                        *v46 = *v46 & -1 - TheFlag;
                        DrawLine(v44, (int32_t *)v45, 0);
                        v31 = 1;
                        if (v32 == 0) {
                            // break -> 0x8096e88
                            break;
                        }
                        goto lab_0x8096e1e_2;
                    }
                }
            }
            // 0x8096e88
            v40 = 1;
            v41 = (int32_t)PCB;
        }
        int32_t v49 = v41;
        char v50 = v40;
        int32_t v51 = *(int32_t *)(v49 + 0x220c); // 0x8096e8d
        v36++;
        uint32_t v52 = *(int32_t *)(v51 + 24); // 0x8096e97
        int32_t v53 = v37 + 92; // 0x8096e9d
        while (v52 > v36) {
            // 0x8096df0
            v37 = v53;
            v38 = v50;
            v39 = *(int32_t *)(v37 + 4);
            v40 = v38;
            v41 = v49;
            if (v39 != 0) {
                // 0x8096dff
                v43 = (char *)v37;
                v44 = (int32_t *)v37;
                while (true) {
                    // 0x8096e1e
                    v42 = 88 * v39 - 88;
                    v32 = v39 - 1;
                    v45 = *(int32_t *)(v37 + 36) + v42;
                    v46 = (int32_t *)(v45 + 20);
                    v47 = *v46;
                    v30 = v38;
                    if ((v47 & TheFlag) == 0) {
                        goto lab_0x8096e13;
                    } else {
                        if (AndDraw == 0) {
                            // 0x8096e08
                            *v46 = v47 & -1 - TheFlag;
                            v30 = 1;
                            goto lab_0x8096e13;
                        } else {
                            // 0x8096e36
                            v48 = (char *)v45;
                            AddObjectToFlagUndoList(4, v43, v48, v48);
                            *v46 = *v46 & -1 - TheFlag;
                            DrawLine(v44, (int32_t *)v45, 0);
                            v31 = 1;
                            if (v32 == 0) {
                                // break -> 0x8096e88
                                break;
                            }
                            goto lab_0x8096e1e_2;
                        }
                    }
                }
                // 0x8096e88
                v40 = 1;
                v41 = (int32_t)PCB;
            }
            // 0x8096e8d
            v49 = v41;
            v50 = v40;
            v51 = *(int32_t *)(v49 + 0x220c);
            v36++;
            v52 = *(int32_t *)(v51 + 24);
            v53 = v37 + 92;
        }
        // 0x8096eb9
        v24 = v50;
        if (v52 != 0) {
            int32_t v54 = 0; // 0x8096ec7
            int32_t v55 = v51 + 76;
            char v56 = v50;
            int32_t v57 = *(int32_t *)(v55 + 16); // 0x8096ec8
            char v58 = v56; // 0x8096ed1
            int32_t v59 = v49; // 0x8096ed1
            int32_t v60; // 0x8096d20
            char * v61; // 0x8096d20
            int32_t * v62; // 0x8096d20
            int32_t v63; // 0x8096f07
            int32_t * v64; // 0x8096f09
            int32_t v65; // 0x8096f09
            char * v66; // 0x8096f32
            if (v57 != 0) {
                // 0x8096ed7
                v61 = (char *)v55;
                v62 = (int32_t *)v55;
                while (true) {
                    // 0x8096efe
                    v60 = 68 * v57 - 68;
                    v33 = v57 - 1;
                    v63 = *(int32_t *)(v55 + 48) + v60;
                    v64 = (int32_t *)(v63 + 20);
                    v65 = *v64;
                    v25 = v56;
                    if ((v65 & TheFlag) == 0) {
                        goto lab_0x8096ef3;
                    } else {
                        if (AndDraw == 0) {
                            // 0x8096ee8
                            *v64 = v65 & -1 - TheFlag;
                            v25 = 1;
                            goto lab_0x8096ef3;
                        } else {
                            // 0x8096f16
                            v66 = (char *)v63;
                            AddObjectToFlagUndoList(0x4000, v61, v66, v66);
                            *v64 = *v64 & -1 - TheFlag;
                            DrawArc(v62, (int32_t *)v63, 0);
                            v26 = 1;
                            if (v33 == 0) {
                                // break -> 0x8096f68
                                break;
                            }
                            goto lab_0x8096efe_2;
                        }
                    }
                }
                // 0x8096f68
                v58 = 1;
                v59 = (int32_t)PCB;
            }
            int32_t v67 = v59;
            char v68 = v58;
            int32_t v69 = *(int32_t *)(v67 + 0x220c); // 0x8096f6d
            v54++;
            uint32_t v70 = *(int32_t *)(v69 + 24); // 0x8096f77
            int32_t v71 = v55 + 92; // 0x8096f7d
            while (v70 > v54) {
                // 0x8096ec8
                v55 = v71;
                v56 = v68;
                v57 = *(int32_t *)(v55 + 16);
                v58 = v56;
                v59 = v67;
                if (v57 != 0) {
                    // 0x8096ed7
                    v61 = (char *)v55;
                    v62 = (int32_t *)v55;
                    while (true) {
                        // 0x8096efe
                        v60 = 68 * v57 - 68;
                        v33 = v57 - 1;
                        v63 = *(int32_t *)(v55 + 48) + v60;
                        v64 = (int32_t *)(v63 + 20);
                        v65 = *v64;
                        v25 = v56;
                        if ((v65 & TheFlag) == 0) {
                            goto lab_0x8096ef3;
                        } else {
                            if (AndDraw == 0) {
                                // 0x8096ee8
                                *v64 = v65 & -1 - TheFlag;
                                v25 = 1;
                                goto lab_0x8096ef3;
                            } else {
                                // 0x8096f16
                                v66 = (char *)v63;
                                AddObjectToFlagUndoList(0x4000, v61, v66, v66);
                                *v64 = *v64 & -1 - TheFlag;
                                DrawArc(v62, (int32_t *)v63, 0);
                                v26 = 1;
                                if (v33 == 0) {
                                    // break -> 0x8096f68
                                    break;
                                }
                                goto lab_0x8096efe_2;
                            }
                        }
                    }
                    // 0x8096f68
                    v58 = 1;
                    v59 = (int32_t)PCB;
                }
                // 0x8096f6d
                v67 = v59;
                v68 = v58;
                v69 = *(int32_t *)(v67 + 0x220c);
                v54++;
                v70 = *(int32_t *)(v69 + 24);
                v71 = v55 + 92;
            }
            // 0x8096f87
            v24 = v68;
            if (v70 != 0) {
                int32_t v72 = v69 + 76;
                char v73 = v68;
                int32_t v74 = *(int32_t *)(v72 + 12); // 0x8096fa0
                char v75 = v73; // 0x8096fa9
                int32_t v76 = v67; // 0x8096fa9
                char * v77; // 0x8096d20
                int32_t * v78; // 0x8096d20
                int32_t v79; // 0x8096fd7
                int32_t * v80; // 0x8096fd9
                int32_t v81; // 0x8096fd9
                char * v82; // 0x8097002
                if (v74 != 0) {
                    // 0x8096faf
                    v77 = (char *)v72;
                    v78 = (int32_t *)v72;
                    while (true) {
                        // 0x8096fce
                        v35 = 60 * v74 - 60;
                        v34 = v74 - 1;
                        v79 = *(int32_t *)(v72 + 44) + v35;
                        v80 = (int32_t *)(v79 + 20);
                        v81 = *v80;
                        v27 = v73;
                        if ((v81 & TheFlag) == 0) {
                            goto lab_0x8096fc3;
                        } else {
                            if (AndDraw == 0) {
                                // 0x8096fb8
                                *v80 = v81 & -1 - TheFlag;
                                v27 = 1;
                                goto lab_0x8096fc3;
                            } else {
                                // 0x8096fe6
                                v82 = (char *)v79;
                                AddObjectToFlagUndoList(8, v77, v82, v82);
                                *v80 = *v80 & -1 - TheFlag;
                                DrawPolygon(v78, (int32_t *)v79, 0);
                                v28 = 1;
                                if (v34 == 0) {
                                    // break -> 0x8097038
                                    break;
                                }
                                goto lab_0x8096fce;
                            }
                        }
                    }
                    // 0x8097038
                    v75 = v29;
                    v76 = (int32_t)PCB;
                }
                int32_t v83 = v76;
                char v84 = v75;
                int32_t v85 = 1; // 0x8097043
                v24 = v84;
                int32_t v86 = v72 + 92; // 0x809704d
                while (*(int32_t *)(*(int32_t *)(v83 + 0x220c) + 24) > v85) {
                    // 0x8096fa0
                    v72 = v86;
                    int32_t v87 = v85;
                    v73 = v84;
                    v74 = *(int32_t *)(v72 + 12);
                    v75 = v73;
                    v76 = v83;
                    if (v74 != 0) {
                        // 0x8096faf
                        v77 = (char *)v72;
                        v78 = (int32_t *)v72;
                        while (true) {
                            // 0x8096fce
                            v35 = 60 * v74 - 60;
                            v34 = v74 - 1;
                            v79 = *(int32_t *)(v72 + 44) + v35;
                            v80 = (int32_t *)(v79 + 20);
                            v81 = *v80;
                            v27 = v73;
                            if ((v81 & TheFlag) == 0) {
                                goto lab_0x8096fc3;
                            } else {
                                if (AndDraw == 0) {
                                    // 0x8096fb8
                                    *v80 = v81 & -1 - TheFlag;
                                    v27 = 1;
                                    goto lab_0x8096fc3;
                                } else {
                                    // 0x8096fe6
                                    v82 = (char *)v79;
                                    AddObjectToFlagUndoList(8, v77, v82, v82);
                                    *v80 = *v80 & -1 - TheFlag;
                                    DrawPolygon(v78, (int32_t *)v79, 0);
                                    v28 = 1;
                                    if (v34 == 0) {
                                        // break -> 0x8097038
                                        break;
                                    }
                                    goto lab_0x8096fce;
                                }
                            }
                        }
                        // 0x8097038
                        v75 = v29;
                        v76 = (int32_t)PCB;
                    }
                    // 0x809703d
                    v83 = v76;
                    v84 = v75;
                    v85 = v87 + 1;
                    v24 = v84;
                    v86 = v72 + 92;
                }
            }
        }
    }
    // 0x8096ea7
    if (v24 == 0) {
        // 0x8096eb1
        return;
    }
    // 0x809705b
    SetChangedFlag(1);
    if (AndDraw == 0) {
        // 0x8096eb1
        return;
    }
    // 0x8097071
    IncrementUndoSerialNumber();
    Draw();
  lab_0x8096e13:
    // 0x8096e13
    v31 = v30;
    if (v32 == 0) {
        // break -> 0x8096e88
        goto lab_0x8096e88;
    }
    goto lab_0x8096e1e_2;
  lab_0x8096e1e:
    // 0x8096e1e
    goto lab_0x8096e1e_2;
  lab_0x8096ef3:
    // 0x8096ef3
    v26 = v25;
    if (v33 == 0) {
        // break -> 0x8096f68
        goto lab_0x8096f68;
    }
    goto lab_0x8096efe;
  lab_0x8096efe:
    // 0x8096efe
    goto lab_0x8096efe_2;
  lab_0x8096fc3:
    // 0x8096fc3
    v28 = v27;
    v29 = v27;
    if (v34 == 0) {
        // break -> 0x8097038
        goto lab_0x8097038;
    }
    goto lab_0x8096fce;
  lab_0x8096fce:;
    char v88 = v28; // 0x8096d20
    int32_t v89 = v34; // 0x8096d20
    int32_t v90 = v35; // 0x8096d20
    goto lab_0x8096fce_2;
  lab_0x8096d63:
    // 0x8096d63
    v8 = v7;
    v10 = v12;
    v4 = v7;
    v13 = v12;
    if (v15 == 0) {
        // break -> 0x8096dd2
        goto lab_0x8096dd2;
    }
    goto lab_0x8096d6e;
  lab_0x8096d6e:
    // 0x8096d6e
    v9 = v8;
    v11 = v10;
    v14 = *(int32_t *)(v10 + 0x220c);
    v18 = v17;
    v16 = v15;
    goto lab_0x8096d74;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/find.c
// Address range: 0x8097090 - 0x80972e4
// Line range:    3376 - 3430
void ResetFoundPinsViasAndPads(char AndDraw) {
    int32_t v1 = (int32_t)PCB; // 0x80970a4
    int32_t v2 = *(int32_t *)(v1 + 0x220c); // 0x80970a9
    int32_t v3 = *(int32_t *)v2; // 0x80970af
    char v4 = 0; // 0x80970b3
    int32_t v5 = v1; // 0x80970b3
    int32_t v6 = v2; // 0x80970b3
    char v7; // 0x8097090
    char v8; // 0x8097090
    char v9; // 0x8097090
    int32_t v10; // 0x8097090
    int32_t v11; // 0x8097090
    int32_t v12; // 0x8097090
    int32_t v13; // 0x8097090
    int32_t v14; // 0x8097090
    int32_t v15; // 0x8097090
    int32_t v16; // 0x8097090
    int32_t v17; // 0x8097090
    if (v3 != 0) {
        // 0x80970e3
        v9 = 0;
        v11 = v1;
        v17 = v2;
        v13 = 0;
        v15 = v3;
        while (true) {
          lab_0x80970e3:
            // 0x80970e3
            v12 = v11;
            int32_t v18 = *(int32_t *)(v17 + 28) + 76 * v13; // 0x80970ec
            int32_t * v19 = (int32_t *)(v18 + 20); // 0x80970ef
            int32_t v20 = *v19; // 0x80970ef
            v7 = v9;
            if ((v20 & TheFlag) == 0) {
                goto lab_0x80970cb;
            } else {
                if (AndDraw == 0) {
                    // 0x80970c0
                    *v19 = v20 & -1 - TheFlag;
                    v7 = 1;
                    goto lab_0x80970cb;
                } else {
                    char * v21 = (char *)v18; // 0x809710f
                    AddObjectToFlagUndoList(1, v21, v21, v21);
                    *v19 = *v19 & -1 - TheFlag;
                    DrawVia((int32_t *)v18, 0);
                    int32_t v22 = (int32_t)PCB;
                    int32_t v23 = *(int32_t *)(v22 + 0x220c); // 0x8097137
                    int32_t v24 = *(int32_t *)v23; // 0x809713d
                    v8 = 1;
                    v10 = v22;
                    v14 = v24;
                    v16 = v23;
                    v4 = 1;
                    v5 = v22;
                    v6 = v23;
                    if (v24 == 0) {
                        // break -> 0x8097143
                        break;
                    }
                    goto lab_0x80970d7;
                }
            }
        }
    }
  lab_0x8097143_2:;
    int32_t v25 = *(int32_t *)(v6 + 8); // 0x8097143
    char v26 = v4; // 0x809714f
    if (v25 != 0) {
        int32_t v27 = v25; // 0x8097164
        int32_t v28 = 300 * v25; // 0x8097164
        char v29 = v4;
        v28 -= 300;
        int32_t v30 = *(int32_t *)(*(int32_t *)(v5 + 0x220c) + 32) + v28; // 0x8097171
        int32_t * v31 = (int32_t *)(v30 + 224); // 0x8097174
        int32_t v32 = *v31; // 0x8097174
        char v33 = v29; // 0x809717f
        char v34; // 0x8097090
        char v35; // 0x8097090
        int32_t v36; // 0x8097090
        int32_t v37; // 0x8097090
        int32_t v38; // 0x8097090
        int32_t v39; // 0x8097090
        char * v40; // 0x8097090
        int32_t v41; // 0x80971b6
        int32_t * v42; // 0x80971bc
        int32_t v43; // 0x80971bc
        int32_t v44; // 0x80971a3
        char * v45; // 0x80971dc
        int32_t v46; // 0x80971fb
        if (v32 != 0) {
            // 0x80971ad
            v40 = (char *)v30;
            v38 = 0;
            v39 = v32;
            v41 = *(int32_t *)(v30 + 256) + 76 * v38;
            v42 = (int32_t *)(v41 + 20);
            v43 = *v42;
            v34 = v29;
            v36 = v39;
            if ((v43 & TheFlag) != 0) {
                if (AndDraw == 0) {
                    // 0x8097190
                    *v42 = v43 & -1 - TheFlag;
                    v34 = 1;
                    v36 = v39;
                } else {
                    // 0x80971c9
                    v45 = (char *)v41;
                    AddObjectToFlagUndoList(256, v40, v45, v45);
                    *v42 = *v42 & -1 - TheFlag;
                    DrawPin((int32_t *)v41, 0);
                    v46 = *v31;
                    v34 = 1;
                    v36 = v46;
                    if (v46 == 0) {
                        // break -> 0x8097210
                        break;
                    }
                }
            }
            // 0x809719f
            v37 = v36;
            v35 = v34;
            v44 = 1 - v39 + v38 + v37;
            v33 = v35;
            while (v37 > v44) {
                // 0x80971ad
                v38 = v44;
                v39 = v37;
                v41 = *(int32_t *)(v30 + 256) + 76 * v38;
                v42 = (int32_t *)(v41 + 20);
                v43 = *v42;
                v34 = v35;
                v36 = v39;
                if ((v43 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097190
                        *v42 = v43 & -1 - TheFlag;
                        v34 = 1;
                        v36 = v39;
                    } else {
                        // 0x80971c9
                        v45 = (char *)v41;
                        AddObjectToFlagUndoList(256, v40, v45, v45);
                        *v42 = *v42 & -1 - TheFlag;
                        DrawPin((int32_t *)v41, 0);
                        v46 = *v31;
                        v34 = 1;
                        v36 = v46;
                        v33 = 1;
                        if (v46 == 0) {
                            // break -> 0x8097210
                            break;
                        }
                    }
                }
                // 0x809719f
                v37 = v36;
                v35 = v34;
                v44 = 1 - v39 + v38 + v37;
                v33 = v35;
            }
        }
        char v47 = v33;
        int32_t * v48 = (int32_t *)(v30 + 232); // 0x8097210
        int32_t v49 = *v48; // 0x8097210
        char v50 = v47; // 0x8097237
        char v51; // 0x8097090
        char v52; // 0x8097090
        int32_t v53; // 0x8097090
        int32_t v54; // 0x8097090
        int32_t v55; // 0x8097090
        char * v56; // 0x8097090
        int32_t v57; // 0x8097246
        int32_t * v58; // 0x809724c
        int32_t v59; // 0x809724c
        int32_t v60; // 0x8097233
        char * v61; // 0x809726c
        if (v49 != 0) {
            // 0x809723d
            v56 = (char *)v30;
            v60 = 0;
            v55 = v49;
            v57 = *(int32_t *)(v30 + 260) + 104 * v60;
            v58 = (int32_t *)(v57 + 20);
            v59 = *v58;
            v51 = v47;
            v53 = v55;
            if ((v59 & TheFlag) != 0) {
                if (AndDraw == 0) {
                    // 0x8097220
                    *v58 = v59 & -1 - TheFlag;
                    v51 = 1;
                    v53 = v55;
                } else {
                    // 0x8097259
                    v61 = (char *)v57;
                    AddObjectToFlagUndoList(512, v56, v61, v61);
                    *v58 = *v58 & -1 - TheFlag;
                    DrawPad((int32_t *)v57, 0);
                    v51 = 1;
                    v53 = *v48;
                }
            }
            // 0x809722b
            v54 = v53;
            v52 = v51;
            v60 += (int32_t)(v49 == v54);
            v50 = v52;
            while (v54 > v60) {
                // 0x809723d
                v55 = v54;
                v57 = *(int32_t *)(v30 + 260) + 104 * v60;
                v58 = (int32_t *)(v57 + 20);
                v59 = *v58;
                v51 = v52;
                v53 = v55;
                if ((v59 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097220
                        *v58 = v59 & -1 - TheFlag;
                        v51 = 1;
                        v53 = v55;
                    } else {
                        // 0x8097259
                        v61 = (char *)v57;
                        AddObjectToFlagUndoList(512, v56, v61, v61);
                        *v58 = *v58 & -1 - TheFlag;
                        DrawPad((int32_t *)v57, 0);
                        v51 = 1;
                        v53 = *v48;
                    }
                }
                // 0x809722b
                v54 = v53;
                v52 = v51;
                v60 += (int32_t)(v49 == v54);
                v50 = v52;
            }
        }
        // 0x8097298
        v27--;
        char v62 = v50;
        v26 = v62;
        while (v27 != 0) {
            // 0x80972a9
            v29 = v62;
            v28 -= 300;
            v30 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 32) + v28;
            v31 = (int32_t *)(v30 + 224);
            v32 = *v31;
            v33 = v29;
            if (v32 != 0) {
                // 0x80971ad
                v40 = (char *)v30;
                v38 = 0;
                v39 = v32;
                v41 = *(int32_t *)(v30 + 256) + 76 * v38;
                v42 = (int32_t *)(v41 + 20);
                v43 = *v42;
                v34 = v29;
                v36 = v39;
                if ((v43 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097190
                        *v42 = v43 & -1 - TheFlag;
                        v34 = 1;
                        v36 = v39;
                    } else {
                        // 0x80971c9
                        v45 = (char *)v41;
                        AddObjectToFlagUndoList(256, v40, v45, v45);
                        *v42 = *v42 & -1 - TheFlag;
                        DrawPin((int32_t *)v41, 0);
                        v46 = *v31;
                        v34 = 1;
                        v36 = v46;
                        if (v46 == 0) {
                            // break -> 0x8097210
                            break;
                        }
                    }
                }
                // 0x809719f
                v37 = v36;
                v35 = v34;
                v44 = 1 - v39 + v38 + v37;
                v33 = v35;
                while (v37 > v44) {
                    // 0x80971ad
                    v38 = v44;
                    v39 = v37;
                    v41 = *(int32_t *)(v30 + 256) + 76 * v38;
                    v42 = (int32_t *)(v41 + 20);
                    v43 = *v42;
                    v34 = v35;
                    v36 = v39;
                    if ((v43 & TheFlag) != 0) {
                        if (AndDraw == 0) {
                            // 0x8097190
                            *v42 = v43 & -1 - TheFlag;
                            v34 = 1;
                            v36 = v39;
                        } else {
                            // 0x80971c9
                            v45 = (char *)v41;
                            AddObjectToFlagUndoList(256, v40, v45, v45);
                            *v42 = *v42 & -1 - TheFlag;
                            DrawPin((int32_t *)v41, 0);
                            v46 = *v31;
                            v34 = 1;
                            v36 = v46;
                            v33 = 1;
                            if (v46 == 0) {
                                // break -> 0x8097210
                                break;
                            }
                        }
                    }
                    // 0x809719f
                    v37 = v36;
                    v35 = v34;
                    v44 = 1 - v39 + v38 + v37;
                    v33 = v35;
                }
            }
            // 0x8097210
            v47 = v33;
            v48 = (int32_t *)(v30 + 232);
            v49 = *v48;
            v50 = v47;
            if (v49 != 0) {
                // 0x809723d
                v56 = (char *)v30;
                v60 = 0;
                v55 = v49;
                v57 = *(int32_t *)(v30 + 260) + 104 * v60;
                v58 = (int32_t *)(v57 + 20);
                v59 = *v58;
                v51 = v47;
                v53 = v55;
                if ((v59 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097220
                        *v58 = v59 & -1 - TheFlag;
                        v51 = 1;
                        v53 = v55;
                    } else {
                        // 0x8097259
                        v61 = (char *)v57;
                        AddObjectToFlagUndoList(512, v56, v61, v61);
                        *v58 = *v58 & -1 - TheFlag;
                        DrawPad((int32_t *)v57, 0);
                        v51 = 1;
                        v53 = *v48;
                    }
                }
                // 0x809722b
                v54 = v53;
                v52 = v51;
                v60 += (int32_t)(v49 == v54);
                v50 = v52;
                while (v54 > v60) {
                    // 0x809723d
                    v55 = v54;
                    v57 = *(int32_t *)(v30 + 260) + 104 * v60;
                    v58 = (int32_t *)(v57 + 20);
                    v59 = *v58;
                    v51 = v52;
                    v53 = v55;
                    if ((v59 & TheFlag) != 0) {
                        if (AndDraw == 0) {
                            // 0x8097220
                            *v58 = v59 & -1 - TheFlag;
                            v51 = 1;
                            v53 = v55;
                        } else {
                            // 0x8097259
                            v61 = (char *)v57;
                            AddObjectToFlagUndoList(512, v56, v61, v61);
                            *v58 = *v58 & -1 - TheFlag;
                            DrawPad((int32_t *)v57, 0);
                            v51 = 1;
                            v53 = *v48;
                        }
                    }
                    // 0x809722b
                    v54 = v53;
                    v52 = v51;
                    v60 += (int32_t)(v49 == v54);
                    v50 = v52;
                }
            }
            // 0x8097298
            v27--;
            v62 = v50;
            v26 = v62;
        }
    }
    // 0x80972b3
    if (v26 == 0) {
        // 0x80972b9
        return;
    }
    // 0x80972c1
    SetChangedFlag(1);
    if (AndDraw == 0) {
        // 0x80972b9
        return;
    }
    // 0x80972d3
    IncrementUndoSerialNumber();
    Draw();
  lab_0x80970cb:;
    int32_t v63 = *(int32_t *)(v12 + 0x220c); // 0x80970cb
    int32_t v64 = *(int32_t *)v63; // 0x80970d1
    v8 = v7;
    v10 = v12;
    v14 = v64;
    v16 = v63;
    v4 = v7;
    v5 = v12;
    v6 = v63;
    if (v64 == 0) {
        // break -> 0x8097143
        goto lab_0x8097143_2;
    }
    goto lab_0x80970d7;
  lab_0x80970d7:;
    int32_t v65 = v13 + 1 - v15 + v14; // 0x80970db
    v9 = v8;
    v11 = v10;
    v17 = v16;
    v13 = v65;
    v15 = v14;
    v4 = v8;
    v5 = v10;
    v6 = v16;
    if (v14 <= v65) {
        // break -> 0x8097143
        goto lab_0x8097143_2;
    }
    goto lab_0x80970e3;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/flags.c
// Address range: 0x809dbd0 - 0x809dbec
// Line range:    251 - 251
void register_flags_flag_list(void) {
    // 0x809dbd0
    hid_register_flags(&flags_flag_list, 70);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/fontmode.c
// Address range: 0x809e310 - 0x809e32c
// Line range:    246 - 246
void register_fontmode_action_list(void) {
    // 0x809e310
    hid_register_actions(&fontmode_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/insert.c
// Address range: 0x809e690 - 0x809e998
// Line range:    234 - 298
int32_t * AdjustInsertPoint(void) {
    // 0x809e690
    if (g244 == 0) {
        // 0x809e6b1
        return (int32_t *)0;
    }
    // 0x809e6c0
    g247 = (int64_t)(int32_t)&g61;
    int3_t v1; // 0x809e690
    if (gui != NULL) {
        int32_t * v2 = (int32_t *)(g246 + 64); // 0x809e6ea
        int32_t v3 = (int32_t)(float32_t)g222 - *v2; // 0x809e6ea
        int32_t v4 = g246 + 68; // 0x809e6ed
        int32_t v5 = (int32_t)(float32_t)g223 - *(int32_t *)v4; // 0x809e6ed
        int32_t * v6 = (int32_t *)(g246 + 44); // 0x809e6f0
        int32_t v7 = (int32_t)(float32_t)g222 - *v6; // 0x809e6f0
        int32_t v8 = g246 + 48; // 0x809e6f3
        int32_t v9 = (int32_t)(float32_t)g223 - *(int32_t *)v8; // 0x809e6f3
        int3_t v10 = v1 - 1; // 0x809e70b
        __frontend_reg_store_fpr(v10, (float80_t)(v5 * v5 + v3 * v3));
        int3_t v11 = v1 - 2; // 0x809e711
        __frontend_reg_store_fpr(v11, (float80_t)(v9 * v9 + v7 * v7));
        float80_t v12 = __frontend_reg_load_fpr(v11); // 0x809e714
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v10));
        __frontend_reg_store_fpr(v10, v12);
        float80_t v13 = __frontend_reg_load_fpr(v11); // 0x809e716
        float80_t v14 = __frontend_reg_load_fpr(v10); // 0x809e716
        bool v15 = false; // 0x809e716
        bool v16 = false; // 0x809e716
        if (v13 <= v14) {
            v15 = true;
            v16 = false;
            if (v13 >= v14) {
                v15 = v13 != v14;
                v16 = true;
            }
        }
        // 0x809e73b
        __frontend_reg_store_fpr(v10, __frontend_reg_load_fpr(v10));
        bool v17 = v15 | v16; // 0x809e71a
        int32_t v18 = *((v17 ? v2 : v6));
        int32_t v19 = v18; // bp-76, 0x809e747
        FortyFiveLine(&v19);
        g61 = (int64_t)v18;
        g62 = (int64_t)*(int32_t *)(v17 ? v4 : v8);
        // 0x809e6b1
        return (int32_t *)(int32_t)&g61;
    }
    // 0x809e778
    if (g193 % 2 != 0) {
        // 0x809e8f8
        g61 = g222;
        g62 = g223;
        // 0x809e6b1
        return (int32_t *)(int32_t)&g61;
    }
    int32_t v20 = *(int32_t *)(g246 + 48); // 0x809e787
    int32_t v21 = *(int32_t *)(g246 + 44); // 0x809e78f
    int32_t v22 = (int32_t)(float32_t)g222 - v21; // 0x809e79d
    int32_t v23; // 0x809e690
    if (v22 == 0) {
        // 0x809e7e8
        v23 = 2;
        goto lab_0x809e7f8;
    } else {
        int3_t v24 = v1 - 1; // 0x809e7a9
        __frontend_reg_store_fpr(v24, (float80_t)((int32_t)(float32_t)g223 - v20));
        int3_t v25 = v1 - 2; // 0x809e7af
        __frontend_reg_store_fpr(v25, (float80_t)v22);
        __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v24) / __frontend_reg_load_fpr(v25));
        __frontend_reg_store_fpr(v25, 0.57735027L);
        float80_t v26 = __frontend_reg_load_fpr(v25); // 0x809e7ba
        __frontend_reg_store_fpr(v25, __frontend_reg_load_fpr(v24));
        __frontend_reg_store_fpr(v24, v26);
        float80_t v27 = __frontend_reg_load_fpr(v25); // 0x809e7bc
        float80_t v28 = __frontend_reg_load_fpr(v24); // 0x809e7bc
        bool v29 = false; // 0x809e7bc
        bool v30 = false; // 0x809e7bc
        if (v27 <= v28) {
            v29 = true;
            v30 = false;
            if (v27 >= v28) {
                v29 = v27 != v28;
                v30 = true;
            }
        }
        __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v25));
        if (v29 || v30) {
            // 0x809e7c6
            __frontend_reg_store_fpr(v25, -0.57735027L);
            if (__frontend_reg_load_fpr(v25) <= __frontend_reg_load_fpr(v24)) {
                // 0x809e7f0
                __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v24));
                v23 = 0;
                goto lab_0x809e7f8;
            } else {
                // 0x809e7d2
                __frontend_reg_store_fpr(v25, -1.7320508L);
                float80_t v31 = __frontend_reg_load_fpr(v25); // 0x809e7dd
                float80_t v32 = __frontend_reg_load_fpr(v24); // 0x809e7dd
                bool v33 = false; // 0x809e7dd
                bool v34 = false; // 0x809e7dd
                if (v31 <= v32) {
                    v33 = true;
                    v34 = false;
                    if (v31 >= v32) {
                        v33 = v31 != v32;
                        v34 = true;
                    }
                }
                __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v24));
                v23 = -1;
                if (v33 || v34) {
                    goto lab_0x809e7f8;
                } else {
                    // 0x809e7e8
                    v23 = 2;
                    goto lab_0x809e7f8;
                }
            }
        } else {
            // 0x809e938
            __frontend_reg_store_fpr(v25, 1.7320508L);
            float80_t v35 = __frontend_reg_load_fpr(v25); // 0x809e93e
            __frontend_reg_store_fpr(v25, __frontend_reg_load_fpr(v24));
            __frontend_reg_store_fpr(v24, v35);
            float80_t v36 = __frontend_reg_load_fpr(v25); // 0x809e945
            float80_t v37 = __frontend_reg_load_fpr(v24); // 0x809e945
            bool v38 = false; // 0x809e945
            bool v39 = false; // 0x809e945
            if (v36 <= v37) {
                v38 = true;
                v39 = false;
                if (v36 >= v37) {
                    v38 = v36 != v37;
                    v39 = true;
                }
            }
            __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v24));
            v23 = 1;
            if (v38 || v39) {
                goto lab_0x809e7f8;
            } else {
                // 0x809e7e8
                v23 = 2;
                goto lab_0x809e7f8;
            }
        }
    }
  lab_0x809e7f8:;
    int32_t v40 = v23;
    int32_t v41 = *(int32_t *)(g246 + 64); // 0x809e7f8
    int32_t v42 = *(int32_t *)(g246 + 68); // 0x809e7fb
    int32_t v43 = (int32_t)(float32_t)g222 - v41; // 0x809e7fe
    int32_t v44; // 0x809e690
    if (v43 == 0) {
        // 0x809e848
        v44 = 2;
        goto lab_0x809e858;
    } else {
        int3_t v45 = v1 - 1; // 0x809e80a
        __frontend_reg_store_fpr(v45, (float80_t)((int32_t)(float32_t)g223 - v42));
        int3_t v46 = v1 - 2; // 0x809e810
        __frontend_reg_store_fpr(v46, (float80_t)v43);
        __frontend_reg_store_fpr(v45, __frontend_reg_load_fpr(v45) / __frontend_reg_load_fpr(v46));
        __frontend_reg_store_fpr(v46, 0.57735027L);
        float80_t v47 = __frontend_reg_load_fpr(v46); // 0x809e81b
        __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v45));
        __frontend_reg_store_fpr(v45, v47);
        float80_t v48 = __frontend_reg_load_fpr(v46); // 0x809e81d
        float80_t v49 = __frontend_reg_load_fpr(v45); // 0x809e81d
        bool v50 = false; // 0x809e81d
        bool v51 = false; // 0x809e81d
        if (v48 <= v49) {
            v50 = true;
            v51 = false;
            if (v48 >= v49) {
                v50 = v48 != v49;
                v51 = true;
            }
        }
        __frontend_reg_store_fpr(v45, __frontend_reg_load_fpr(v46));
        if (v50 || v51) {
            // 0x809e827
            __frontend_reg_store_fpr(v46, -0.57735027L);
            if (__frontend_reg_load_fpr(v46) <= __frontend_reg_load_fpr(v45)) {
                // 0x809e850
                __frontend_reg_store_fpr(v45, __frontend_reg_load_fpr(v45));
                v44 = 0;
                goto lab_0x809e858;
            } else {
                // 0x809e833
                __frontend_reg_store_fpr(v46, -1.7320508L);
                float80_t v52 = __frontend_reg_load_fpr(v46); // 0x809e83e
                float80_t v53 = __frontend_reg_load_fpr(v45); // 0x809e83e
                bool v54 = false; // 0x809e83e
                bool v55 = false; // 0x809e83e
                if (v52 <= v53) {
                    v54 = true;
                    v55 = false;
                    if (v52 >= v53) {
                        v54 = v52 != v53;
                        v55 = true;
                    }
                }
                __frontend_reg_store_fpr(v45, __frontend_reg_load_fpr(v45));
                v44 = -1;
                if (v54 || v55) {
                    goto lab_0x809e858;
                } else {
                    // 0x809e848
                    v44 = 2;
                    goto lab_0x809e858;
                }
            }
        } else {
            // 0x809e918
            __frontend_reg_store_fpr(v46, 1.7320508L);
            float80_t v56 = __frontend_reg_load_fpr(v46); // 0x809e91e
            __frontend_reg_store_fpr(v46, __frontend_reg_load_fpr(v45));
            __frontend_reg_store_fpr(v45, v56);
            float80_t v57 = __frontend_reg_load_fpr(v46); // 0x809e925
            float80_t v58 = __frontend_reg_load_fpr(v45); // 0x809e925
            bool v59 = false; // 0x809e925
            bool v60 = false; // 0x809e925
            if (v57 <= v58) {
                v59 = true;
                v60 = false;
                if (v57 >= v58) {
                    v59 = v57 != v58;
                    v60 = true;
                }
            }
            __frontend_reg_store_fpr(v45, __frontend_reg_load_fpr(v45));
            v44 = 1;
            if (v59 || v60) {
                goto lab_0x809e858;
            } else {
                // 0x809e848
                v44 = 2;
                goto lab_0x809e858;
            }
        }
    }
  lab_0x809e858:
    // 0x809e858
    if (v40 == v44) {
        // 0x809e980
        g61 = (int64_t)v21;
        g62 = (int64_t)v20;
        // 0x809e6b1
        return (int32_t *)(int32_t)&g61;
    }
    int32_t v61; // 0x809e690
    int32_t v62; // 0x809e690
    if (v40 == 2) {
        // 0x809e968
        v61 = v44 * (v21 - v41) + v42;
        v62 = v21;
    } else {
        if (v44 == 2) {
            // 0x809e958
            v61 = (v41 - v21) * v40 + v20;
            v62 = v41;
        } else {
            int32_t v63 = -1 * v41;
            int32_t v64 = v40 * v21 - v20 + v42 + v63 * v44; // 0x809e885
            int64_t v65 = v40 - v44; // 0x809e893
            int32_t v66 = v44 * ((v63 + v21) * v40 + -1 * v20) + v42 * v40; // 0x809e8b6
            v61 = (0x100000000 * (int64_t)(v66 >> 31) | (int64_t)v66) / v65;
            v62 = (0x100000000 * (int64_t)(v64 >> 31) | (int64_t)v64) / v65;
        }
    }
    // 0x809e8c0
    g62 = (int64_t)v61;
    g61 = (int64_t)v62;
    // 0x809e6b1
    return (int32_t *)(int32_t)&g61;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809f810 - 0x809f983
// Line range:    98 - 164
void FortyFiveLine(int32_t * Line) {
    int32_t v1 = (int32_t)Line;
    int32_t v2 = *Line; // 0x809f827
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x809f82c
    int32_t v4 = *v3; // 0x809f82c
    int32_t v5 = (int32_t)(float32_t)g223 - v4; // 0x809f83d
    int32_t v6 = (int32_t)(float32_t)g222 - v2; // 0x809f83f
    int32_t v7; // 0x809f810
    if (v6 != 0) {
        // 0x809f898
        int3_t v8; // 0x809f810
        int3_t v9 = v8 - 1; // 0x809f89b
        __frontend_reg_store_fpr(v9, (float80_t)v5);
        int3_t v10 = v8 - 2; // 0x809f8a1
        __frontend_reg_store_fpr(v10, (float80_t)v6);
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) / __frontend_reg_load_fpr(v10));
        __frontend_reg_store_fpr(v10, 0.57735027L);
        float80_t v11 = __frontend_reg_load_fpr(v10); // 0x809f8ac
        __frontend_reg_store_fpr(v10, __frontend_reg_load_fpr(v9));
        __frontend_reg_store_fpr(v9, v11);
        float80_t v12 = __frontend_reg_load_fpr(v10); // 0x809f8ae
        float80_t v13 = __frontend_reg_load_fpr(v9); // 0x809f8ae
        bool v14 = false; // 0x809f8ae
        bool v15 = false; // 0x809f8ae
        if (v12 <= v13) {
            v14 = true;
            v15 = false;
            if (v12 >= v13) {
                v14 = v12 != v13;
                v15 = true;
            }
        }
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v10));
        int32_t v16; // 0x809f810
        if (v14 || v15) {
            // 0x809f8d8
            __frontend_reg_store_fpr(v10, -0.57735027L);
            if (__frontend_reg_load_fpr(v10) <= __frontend_reg_load_fpr(v9)) {
                // 0x809f8c8
                __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9));
                v16 = 2;
            } else {
                // 0x809f8e7
                __frontend_reg_store_fpr(v10, -1.7320508L);
                float80_t v17 = __frontend_reg_load_fpr(v10); // 0x809f8ed
                float80_t v18 = __frontend_reg_load_fpr(v9); // 0x809f8ed
                bool v19 = false; // 0x809f8ed
                bool v20 = false; // 0x809f8ed
                if (v17 <= v18) {
                    v19 = true;
                    v20 = false;
                    if (v17 >= v18) {
                        v19 = v17 != v18;
                        v20 = true;
                    }
                }
                __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9));
                v16 = v19 | v20 ? 3 : 0;
            }
        } else {
            // 0x809f8b4
            __frontend_reg_store_fpr(v10, 1.7320508L);
            float80_t v21 = __frontend_reg_load_fpr(v10); // 0x809f8ba
            __frontend_reg_store_fpr(v10, __frontend_reg_load_fpr(v9));
            __frontend_reg_store_fpr(v9, v21);
            float80_t v22 = __frontend_reg_load_fpr(v10); // 0x809f8bc
            float80_t v23 = __frontend_reg_load_fpr(v9); // 0x809f8bc
            bool v24 = false; // 0x809f8bc
            bool v25 = false; // 0x809f8bc
            if (v22 <= v23) {
                v24 = true;
                v25 = false;
                if (v22 >= v23) {
                    v24 = v22 != v23;
                    v25 = true;
                }
            }
            __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9));
            v16 = v24 | v25;
        }
        int32_t v26 = v16;
        v7 = v6 >= 0 ? v26 : v26 | 4;
    } else {
        if (v5 == 0) {
            // 0x809f888
            return;
        }
        // 0x809f849
        v7 = 4 * (int32_t)(v5 < 1);
    }
    int32_t v27 = v5 < 0 ? -v5 : v5; // 0x809f858
    int32_t v28 = v6 < 0 ? -v6 : v6; // 0x809f861
    int32_t v29 = v27 - v28; // 0x809f863
    int32_t v30 = v29 < 0 == ((v29 ^ v27) & (v27 ^ v28)) < 0 == (v29 != 0) ? v28 : v27; // 0x809f865
    g274 = v7 % 256;
    uint32_t v31; // 0x809f810
    switch ((char)v31) {
        case 1: {
            // 0x809f958
            *(int32_t *)(v1 + 20) = v30 + v2;
            *(int32_t *)(v1 + 24) = *v3 + v30;
            // break -> 0x809f888
            break;
        }
        case 2: {
        }
        case 6: {
            // 0x809f940
            *(int32_t *)(v1 + 20) = (int32_t)(float32_t)g222;
            *(int32_t *)(v1 + 24) = v4;
            // break -> 0x809f888
            break;
        }
        case 3: {
            // 0x809f928
            *(int32_t *)(v1 + 20) = v30 + v2;
            *(int32_t *)(v1 + 24) = v4 - v30;
            // break -> 0x809f888
            break;
        }
        case 5: {
            // 0x809f910
            *(int32_t *)(v1 + 20) = v2 - v30;
            *(int32_t *)(v1 + 24) = v4 - v30;
            // break -> 0x809f888
            break;
        }
        case 7: {
            // 0x809f970
            *(int32_t *)(v1 + 20) = v2 - v30;
            *(int32_t *)(v1 + 24) = *v3 + v30;
            // break -> 0x809f888
            break;
        }
        default: {
            // 0x809f873
            *(int32_t *)(v1 + 20) = v2;
            *(int32_t *)(v1 + 24) = (int32_t)(float32_t)g223;
            // break -> 0x809f888
            break;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809f990 - 0x809f9fd
// Line range:    61 - 84
void AdjustAttachedLine(void) {
    // 0x809f990
    if (g233 == 0) {
        // 0x809f9d4
        return;
    }
    // 0x809f99f
    if (g148 == 2 && gui != NULL) {
        // 0x809f9f4
        g234 = 0;
        return;
    }
    // 0x809f9a8
    g234 = 1;
    if (g206 == 0) {
        // 0x809f9ba
        if (g193 % 2 == 0) {
            // 0x809f9d8
            FortyFiveLine((int32_t *)&g229);
            return;
        }
    }
    // 0x809f9c0
    g231 = (char *)(int32_t)(float32_t)g222;
    g232 = g223;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809fa00 - 0x809fb9b
// Line range:    173 - 222
void AdjustTwoLine(int32_t way) {
    // 0x809fa00
    if (g233 == 0) {
        // 0x809fa1c
        return;
    }
    // 0x809fa30
    if (gui != NULL) {
        // 0x809faf0
        g234 = 0;
        // 0x809fa1c
        return;
    }
    // 0x809fa40
    g234 = 1;
    if (g193 % 2 != 0) {
        // 0x809fa52
        g231 = (char *)(int32_t)(float32_t)g222;
        g232 = g223;
        // 0x809fa1c
        return;
    }
    int32_t v1 = (int32_t)g229; // 0x809fa87
    int32_t v2 = (int32_t)(float32_t)g222 - v1; // 0x809fa99
    int32_t v3 = (int32_t)(float32_t)g223 - (int32_t)(float32_t)g230; // 0x809fa9d
    int32_t v4 = v2 < 0 ? -v2 : v2;
    int32_t v5 = v3 < 0 ? -v3 : v3;
    if (way != 0) {
        if (v4 > v5) {
            int32_t v6 = v2 >= 0 == (v2 != 0) ? 1 : (int32_t)(v2 != 0);
            g232 = g223;
            g231 = (char *)(v6 * v5 + v1);
        } else {
            // 0x809fb70
            g231 = (char *)(int32_t)(float32_t)g222;
            int32_t v7 = v3 < 1 ? (int32_t)(v3 != 0) : 1;
            g232 = (int64_t)(v7 * v4 + (int32_t)(float32_t)g230);
        }
    } else {
        if (v4 > v5) {
            int32_t v8 = v2 >= 0 == (v2 != 0) ? v5 : v2 == 0 ? way : -v5;
            g231 = (char *)((int32_t)(float32_t)g222 - v8);
            g232 = g230;
        } else {
            // 0x809fb48
            g231 = g229;
            int32_t v9 = v3 >= 0 == (v3 != 0) ? v4 : v3 != 0 ? -v4 : way;
            g232 = (int64_t)((int32_t)(float32_t)g223 - v9);
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809fba0 - 0x80a0730
// Line range:    290 - 483
float32_t drc_lines(int32_t * end, char way) {
    int32_t v1[8]; // 0x809fba0
    struct __jmp_buf_tag v2; // 0x809fba0
    struct __jmp_buf_tag env[1]; // 0x809fba0
    int32_t v3 = __readgsdword(20); // 0x809fbb2
    int32_t v4; // bp-396, 0x809fba0
    MakeFlags((int32_t)&v4);
    int32_t v5; // 0x809fba0
    int32_t * v6 = (int32_t *)(v5 + 4); // 0x809fc51
    int32_t v7; // 0x809fba0
    if (g205 == 0) {
        // 0x80a06fe
        v7 = LayerStack[0];
    } else {
        int32_t v8 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x809fcb2
        v7 = v8 + (int32_t)(g177 == 0);
    }
    int32_t v9 = GetGroupOfLayer(v7); // 0x809fcb8
    int32_t v10 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x809fcce
    int32_t v11; // 0x809fba0
    char v12; // 0x809fba0
    if (GetLayerGroupNumberByNumber(v10) != v9) {
        int32_t v13 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80a06df
        v11 = GetLayerGroupNumberByNumber(*(int32_t *)(v13 + 24) + 1);
        v12 = 0;
    } else {
        // 0x809fce5
        v11 = v10 + 10;
        v12 = 1;
    }
    int32_t v14 = *v6 - (int32_t)(float32_t)g230; // 0x809fc57
    int32_t v15 = v14 < 0 ? -v14 : v14; // 0x809fc7d
    int32_t v16 = v15 > -1 ? v15 : 0;
    char * v17 = g229; // 0x809fd0e
    float64_t v18 = g230; // 0x809fd0e
    float32_t result = 0.0f; // 0x809fd0e
    char * v19; // 0x809fba0
    char * v20; // 0x809fba0
    float32_t v21; // 0x809fba0
    float32_t v22; // 0x809fba0
    int32_t v23; // 0x809fba0
    int32_t v24; // 0x809fba0
    int32_t v25; // 0x809fba0
    float32_t v26; // 0x809fba0
    float32_t v27; // 0x809fba0
    float32_t v28; // 0x809fba0
    float32_t v29; // 0x809fba0
    float32_t v30; // 0x809fba0
    float64_t v31; // 0x809fba0
    float64_t v32; // 0x809fba0
    int32_t v33; // 0x809fba0
    if (v16 == -1) {
        goto lab_0x80a061a;
    } else {
        // 0x809fd14
        v33 = (int32_t)g229;
        v19 = g229;
        v26 = v14;
        v32 = g230;
        v22 = 0.0f;
        v30 = 0.5f;
        v24 = v15;
        v28 = 1.0f;
        v20 = g229;
        v27 = 1.0f;
        v23 = 0;
        v29 = 0.5f;
        v21 = 0.0f;
        v31 = g230;
        v25 = 0;
        if (v15 > -1) {
            goto lab_0x80a009d;
        } else {
            goto lab_0x80a06a7;
        }
    }
  lab_0x809fe3c:;
    // 0x809fe3c
    float32_t v34; // 0x809fba0
    float32_t v35 = v34; // 0x809fe6a
    int32_t v36; // 0x809fba0
    int32_t v37 = v36; // 0x809fe6a
    char v38 = 1; // 0x809fe6a
    int32_t v39 = v36 + v33; // 0x809fe6a
    int32_t v40; // 0x809fba0
    int32_t v41 = v40; // 0x809fe6a
    goto lab_0x809fe70;
  lab_0x809fe70:;
    int32_t v42 = v41;
    int32_t v43 = v39;
    int32_t v44 = v37;
    float32_t v45 = v35;
    int32_t v46; // bp-120, 0x809fba0
    SetLineBoundingBox(&v46);
    int32_t v47; // bp-208, 0x809fba0
    SetLineBoundingBox(&v47);
    char * v48; // 0x809fba0
    char * v49; // 0x809fba0
    float32_t v50; // 0x809fba0
    float32_t v51; // 0x809fba0
    char v52; // 0x809fba0
    char v53; // 0x809fba0
    float32_t v54; // 0x809fba0
    float32_t v55; // 0x809fba0
    float32_t v56; // 0x809fba0
    float64_t v57; // 0x809fba0
    float64_t v58; // 0x809fba0
    int32_t v59; // 0x809fe70
    int32_t v60; // 0x809fba0
    int32_t v61; // 0x809fba0
    if (_setjmp(env) == 0) {
        char v62 = v38;
        int32_t v63 = v59; // bp-372, 0x80a00ed
        int32_t v64 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 40); // 0x80a0112
        r_search((int32_t *)v64, &v46, NULL, (int32_t (*)(int32_t *, char *))0x80a0960, (char *)&v63);
        int32_t v65 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48); // 0x80a0143
        r_search((int32_t *)v65, &v46, NULL, (int32_t (*)(int32_t *, char *))0x80a0960, (char *)&v63);
        if (v11 == v9 || v12 != 0) {
            int32_t v66 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52); // 0x80a0534
            r_search((int32_t *)v66, &v46, NULL, (int32_t (*)(int32_t *, char *))0x80a08f0, (char *)&v63);
        }
        if (v62 != 0) {
            // 0x80a0448
            v63 = v60;
            int32_t v67 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 40); // 0x80a047d
            r_search((int32_t *)v67, &v47, NULL, (int32_t (*)(int32_t *, char *))0x80a0960, (char *)&v63);
            int32_t v68 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48); // 0x80a04ab
            r_search((int32_t *)v68, &v47, NULL, (int32_t (*)(int32_t *, char *))0x80a0960, (char *)&v63);
            if (v11 != v9 != (v12 == 0)) {
                int32_t v69 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52); // 0x80a04f8
                r_search((int32_t *)v69, &v47, NULL, (int32_t (*)(int32_t *, char *))0x80a08f0, (char *)&v63);
            }
        }
        int32_t v70 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80a018a
        int32_t v71 = *(int32_t *)(v70 + 72); // 0x80a0196
        int32_t v72 = v70; // 0x80a019f
        int32_t v73 = v71; // 0x80a019f
        int32_t v74 = 0; // 0x80a019f
        if (*(int32_t *)(v71 + v61) != 0) {
            int32_t v75 = v72;
            uint32_t v76 = *(int32_t *)(v73 + 4 + 4 * (18 * v9 + 1860 + v74)); // 0x80a01d2
            int32_t v77; // 0x80a01f4
            int32_t * v78; // 0x80a020a
            int32_t v79; // 0x80a020a
            int32_t * v80; // 0x80a023f
            int32_t v81; // 0x80a023f
            int32_t v82; // 0x80a028a
            int32_t v83; // 0x80a02bc
            if (v76 < *(int32_t *)(v75 + 24)) {
                // 0x80a01db
                v63 = v59;
                v77 = 92 * v76 + v75;
                v78 = (int32_t *)(v77 + 128);
                v79 = *v78;
                r_search((int32_t *)v79, &v46, NULL, (int32_t (*)(int32_t *, char *))0x80a08a0, (char *)&v63);
                v80 = (int32_t *)(v77 + 140);
                v81 = *v80;
                r_search((int32_t *)v81, &v46, NULL, (int32_t (*)(int32_t *, char *))0x80a0850, (char *)&v63);
                if (v62 != 0) {
                    // 0x80a0260
                    v63 = v60;
                    v82 = *v78;
                    r_search((int32_t *)v82, &v47, NULL, (int32_t (*)(int32_t *, char *))0x80a08a0, (char *)&v63);
                    v83 = *v80;
                    r_search((int32_t *)v83, &v47, NULL, (int32_t (*)(int32_t *, char *))0x80a0850, (char *)&v63);
                }
            }
            int32_t v84 = v74 + 1; // 0x80a01b5
            int32_t v85 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80a01b8
            int32_t v86 = *(int32_t *)(v85 + 72); // 0x80a01be
            v74 = v84;
            while (*(int32_t *)(v86 + v61) > v84) {
                // 0x80a01cb
                v75 = v85;
                v76 = *(int32_t *)(v86 + 4 + 4 * (18 * v9 + 1860 + v74));
                if (v76 < *(int32_t *)(v75 + 24)) {
                    // 0x80a01db
                    v63 = v59;
                    v77 = 92 * v76 + v75;
                    v78 = (int32_t *)(v77 + 128);
                    v79 = *v78;
                    r_search((int32_t *)v79, &v46, NULL, (int32_t (*)(int32_t *, char *))0x80a08a0, (char *)&v63);
                    v80 = (int32_t *)(v77 + 140);
                    v81 = *v80;
                    r_search((int32_t *)v81, &v46, NULL, (int32_t (*)(int32_t *, char *))0x80a0850, (char *)&v63);
                    if (v62 != 0) {
                        // 0x80a0260
                        v63 = v60;
                        v82 = *v78;
                        r_search((int32_t *)v82, &v47, NULL, (int32_t (*)(int32_t *, char *))0x80a08a0, (char *)&v63);
                        v83 = *v80;
                        r_search((int32_t *)v83, &v47, NULL, (int32_t (*)(int32_t *, char *))0x80a0850, (char *)&v63);
                    }
                }
                // 0x80a01b0
                v84 = v74 + 1;
                v85 = *(int32_t *)((int32_t)PCB + 0x220c);
                v86 = *(int32_t *)(v85 + 72);
                v74 = v84;
            }
        }
        float32_t v87 = v56 + v55; // 0x80a02f6
        float80_t v88 = v43 - v33; // 0x80a0308
        float80_t v89 = v42; // 0x80a031b
        float80_t v90 = v89 * v89 + v88 * v88; // 0x80a0323
        v48 = v49;
        v57 = v58;
        v50 = v51;
        v54 = v87;
        v52 = 0;
        if (v90 > (float80_t)v51) {
            // 0x80a0337
            v48 = (char *)v43;
            v57 = (int64_t)(v42 + (int32_t)(float32_t)g230);
            v50 = v90;
            v54 = v87;
            v52 = 0;
        }
    } else {
        // 0x809fe9f
        v48 = v49;
        v57 = v58;
        v50 = v51;
        v54 = v55 - v56;
        v52 = v53;
    }
    char v91 = v52;
    float32_t v92 = v54;
    float32_t v93 = v50;
    float64_t v94 = v57;
    char * v95 = v48;
    float80_t v96; // 0x809fba0
    float80_t v97 = v96 * (float80_t)v92; // 0x809fecc
    int32_t v98; // 0x809fba0
    int32_t v99; // 0x809fba0
    int32_t v100; // 0x809fba0
    if (v97 >= v96) {
        // 0x809ffc0
        v99 = v100;
        if (v98 == v100) {
            // break -> 0x809fffc
            goto lab_0x809fffc_2;
        }
    } else {
        int32_t v101 = v97; // 0x809fef6
        v99 = v101;
        if (v98 == v101) {
            // break -> 0x809fffc
            goto lab_0x809fffc_2;
        }
    }
    char * v102 = v95; // 0x809ff26
    float32_t v103 = v45; // 0x809ff26
    int32_t v104 = v44; // 0x809ff26
    float64_t v105 = v94; // 0x809ff26
    float32_t v106 = v93; // 0x809ff26
    float32_t v107 = 0.5f * v56; // 0x809ff26
    int32_t v108 = v99; // 0x809ff26
    float32_t v109 = v92; // 0x809ff26
    char v110 = v91; // 0x809ff26
    goto lab_0x809ff2c;
  lab_0x80a061a:;
    int32_t v125 = __readgsdword(20); // 0x80a061d
    *(int32_t *)v5 = (int32_t)v17;
    *v6 = (int32_t)(float32_t)v18;
    if (v3 != v125) {
        // 0x80a0720
        __stack_chk_fail();
        return result;
    }
    // 0x80a0647
    return result;
  lab_0x80a009d:;
    int32_t v126 = v24;
    float32_t v127 = v26;
    int32_t v128 = v126; // 0x80a00ab
    if ((int32_t)v127 < 1) {
        // 0x80a06bd
        v128 = (int32_t)v127 != 0 ? -v126 : 0;
    }
    int32_t v129 = v128 - v33; // 0x80a00bf
    char * v130 = v19; // 0x80a00db
    int32_t v131 = v128; // 0x80a00db
    int32_t v132 = v129; // 0x80a00db
    float64_t v133 = v32; // 0x80a00db
    float32_t v134 = v22; // 0x80a00db
    float32_t v135 = v30; // 0x80a00db
    int32_t v136 = v126; // 0x80a00db
    float32_t v137 = v28; // 0x80a00db
    int32_t v138 = v129 < 0 ? -v129 : v129; // 0x80a00db
    goto lab_0x809fd95;
  lab_0x80a06a7:;
    char * v145 = v20; // 0x80a06b8
    float32_t v151 = v27; // 0x80a06b8
    int32_t v150 = v23; // 0x80a06b8
    float32_t v149 = v29; // 0x80a06b8
    float32_t v148 = v21; // 0x80a06b8
    float64_t v147 = v31; // 0x80a06b8
    int32_t v146 = v25 != 0 ? -v23 : 0; // 0x80a06b8
    goto lab_0x809fd6e;
  lab_0x809fd95:
    // 0x809fd95
    v100 = v138;
    float32_t v139 = v137;
    int32_t v140 = v136;
    float32_t v141 = v135;
    v96 = v100;
    v59 = &v46;
    int32_t v142; // bp-364, 0x809fba0
    v1[0] = &v142;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    v60 = &v47;
    v61 = 4 * v9 + 0x1cd4;
    v102 = v130;
    v103 = v131;
    v104 = v132;
    v105 = v133;
    v106 = v134;
    v107 = 0.5f;
    v108 = v100;
    v109 = 1.0f;
    v110 = 1;
    while (true) {
      lab_0x809ff2c:
        // 0x809ff2c
        v53 = v110;
        v55 = v109;
        v98 = v108;
        v56 = v107;
        v51 = v106;
        v58 = v105;
        int32_t v111 = v104;
        float32_t v112 = v103;
        v49 = v102;
        if (v15 <= -1) {
            int32_t v113; // 0x809fba0
            int32_t v114; // 0x809fba0
            if ((int32_t)v112 < 1) {
                // 0x80a03e8
                v113 = 0;
                v114 = 0;
                if ((int32_t)v112 != 0) {
                    int32_t v115 = -v98; // 0x80a0566
                    v113 = v115 < 0 ? v98 : v115;
                    v114 = v115;
                }
            } else {
                // 0x809fdd5
                v113 = v98 < 0 ? -v98 : v98;
                v114 = v98;
            }
            int32_t v116 = v114;
            int32_t v117 = v111 < 0 ? -v111 : v111; // 0x809fdff
            v40 = v116;
            v34 = v116;
            v36 = v111;
            if (v117 > v113) {
                goto lab_0x809fe3c;
            } else {
                int32_t v118 = v111 + v33; // 0x80a0369
                v35 = v116;
                v37 = v111;
                v38 = 0;
                v39 = v118;
                v41 = 0;
                if ((char)v5 != 0) {
                    // 0x80a05d0
                    v35 = v116;
                    v37 = v111;
                    v38 = 0;
                    v39 = v118;
                    v41 = v117;
                    if (v116 >= 0 != v116 != 0) {
                        // 0x80a05de
                        v35 = v116;
                        v37 = v111;
                        v38 = 0;
                        v39 = v118;
                        v41 = v116 != 0 ? -v117 : 0;
                    }
                }
                goto lab_0x809fe70;
            }
        } else {
            int32_t v119; // 0x809fba0
            int32_t v120; // 0x809fba0
            if (v111 < 1) {
                // 0x80a03d8
                v119 = 0;
                v120 = 0;
                if (v111 != 0) {
                    int32_t v121 = -v98; // 0x80a054e
                    v119 = v121;
                    v120 = v121 < 0 ? v98 : v121;
                }
            } else {
                // 0x809ff46
                v119 = v98;
                v120 = v98 < 0 ? -v98 : v98;
            }
            int32_t v122 = v119;
            int32_t v123 = (int32_t)v112 < 0 ? -(int32_t)v112 : (int32_t)v112; // 0x809ff70
            v40 = v112;
            v34 = v112;
            v36 = v122;
            if (v123 < v120) {
                int32_t v124 = 0; // 0x80a0436
                if ((char)v5 != 0) {
                    // 0x80a05a8
                    v124 = v123;
                    if (v122 >= 0 != v122 != 0) {
                        // 0x80a05b6
                        v124 = v122 != 0 ? -v123 : 0;
                    }
                }
                // 0x80a043e
                v35 = v112;
                v37 = v122;
                v38 = 0;
                v39 = v124 + v33;
                v41 = v112;
                goto lab_0x809fe70;
            } else {
                goto lab_0x809fe3c;
            }
        }
    }
  lab_0x809fffc_2:;
    float32_t v143; // 0x809fba0
    if (v91 != 0) {
        // 0x80a0028
        v143 = v139 - v141;
        goto lab_0x80a003a;
    } else {
        if (v15 <= -1) {
            if (v43 - v33 != v44) {
                // 0x80a0028
                v143 = v139 - v141;
                goto lab_0x80a003a;
            } else {
                // 0x80a0690
                v143 = v141 + v139;
                goto lab_0x80a003a;
            }
        } else {
            if (v42 == (int32_t)v45) {
                // 0x80a0690
                v143 = v141 + v139;
                goto lab_0x80a003a;
            } else {
                // 0x80a0028
                v143 = v139 - v141;
                goto lab_0x80a003a;
            }
        }
    }
  lab_0x809fd6e:;
    int32_t v144 = *v6 - (int32_t)(float32_t)g230; // 0x809fd7d
    v130 = v145;
    v131 = v144;
    v132 = v146;
    v133 = v147;
    v134 = v148;
    v135 = v149;
    v136 = v150;
    v137 = v151;
    v138 = v144 < 0 ? -v144 : v144;
    goto lab_0x809fd95;
  lab_0x80a003a:;
    float32_t v152 = v143;
    float80_t v153 = v16; // 0x80a003a
    float80_t v154 = v153 * (float80_t)v152; // 0x80a0046
    int32_t v155; // 0x809fba0
    if (v154 >= v153) {
        // 0x80a05f4
        v155 = v16;
        v17 = v95;
        v18 = v94;
        result = v93;
        if (v140 != v16) {
            goto lab_0x80a0078;
        } else {
            goto lab_0x80a061a;
        }
    } else {
        int32_t v156 = v154; // 0x80a005a
        v155 = v156;
        v17 = v95;
        v18 = v94;
        result = v93;
        if (v140 == v156) {
            goto lab_0x80a061a;
        } else {
            goto lab_0x80a0078;
        }
    }
  lab_0x80a0078:;
    int32_t v157 = v155;
    float32_t v158 = 0.5f * v141; // 0x80a0091
    v19 = v95;
    v26 = v45;
    v32 = v94;
    v22 = v93;
    v30 = v158;
    v24 = v157;
    v28 = v152;
    if (v15 <= -1) {
        // 0x809fd5a
        v145 = v95;
        v151 = v152;
        v150 = v157;
        v149 = v158;
        v148 = v93;
        v147 = v94;
        v146 = v157;
        v20 = v95;
        v27 = v152;
        v23 = v157;
        v29 = v158;
        v21 = v93;
        v31 = v94;
        v25 = v44;
        if (v44 < 1) {
            goto lab_0x80a06a7;
        } else {
            goto lab_0x809fd6e;
        }
    } else {
        goto lab_0x80a009d;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x80a0730 - 0x80a084f
// Line range:    486 - 526
void EnforceLineDRC(void) {
    // 0x80a0730
    if (gui != NULL || g206 != 0) {
        // 0x80a0742
        return;
    }
    int32_t v1 = *(int32_t *)((int32_t)PCB + 0x220c);
    int32_t v2; // 0x80a0730
    int32_t v3; // 0x80a0730
    if (g205 == 0) {
        // 0x80a0808
        v2 = *(int32_t *)(v1 + 24);
        v3 = LayerStack[0];
    } else {
        int32_t v4 = *(int32_t *)(v1 + 24); // 0x80a077b
        v2 = v4;
        v3 = v4 + (int32_t)(g177 == 0);
    }
    // 0x80a0783
    if (v3 >= v2) {
        // 0x80a0742
        return;
    }
    float64_t v5 = g222; // 0x80a0787
    float64_t v6 = g223; // 0x80a0794
    float32_t v7 = drc_lines((int32_t *)(int32_t)(float32_t)v5, (char)(int32_t)(float32_t)v6); // 0x80a07a2
    float32_t v8 = drc_lines((int32_t *)(int32_t)v7, (char)&g279); // 0x80a07b2
    bool v9 = false; // 0x80a07c8
    bool v10 = false; // 0x80a07c8
    if (v7 <= v8) {
        v9 = true;
        v10 = false;
        if (v7 >= v8) {
            v9 = v7 != v8;
            v10 = true;
        }
    }
    char v11 = (int32_t)gui; // 0x80a07cf
    if (v11 == 0) {
        if (!v9 && !v10) {
            goto lab_0x80a07d8;
        } else {
            goto lab_0x80a0824;
        }
    } else {
        if (!v9 && !v10) {
            goto lab_0x80a0824;
        } else {
            goto lab_0x80a07d8;
        }
    }
  lab_0x80a07d8:
    // 0x80a07d8
    if (g209 != 0) {
        // 0x80a07e5
        g209 = (int32_t)(v11 == 0) + 2;
    }
    // 0x80a07ef
    g222 = v5;
    g223 = v6;
  lab_0x80a0824:
    // 0x80a0824
    if (g209 != 0) {
        // 0x80a0831
        g209 = (int32_t)(v11 != 0) + 2;
    }
    // 0x80a083d
    g222 = v5;
    g223 = v6;
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/lrealpath.c
// Address range: 0x80a09b0 - 0x80a0a10
// Line range:    75 - 157
char * lrealpath(char * filename) {
    int32_t v1 = __readgsdword(20); // 0x80a09bd
    int32_t v2; // bp-4112, 0x80a09b0
    char * v3 = __realpath_chk(filename, (char *)&v2, 0x1000); // 0x80a09dd
    char * result = __strdup(v3 == NULL ? filename : v3); // 0x80a09ea
    if (v1 == __readgsdword(20)) {
        // 0x80a09fb
        return result;
    }
    // 0x80a0a04
    __stack_chk_fail();
    return (char *)&g279;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0a10 - 0x80a0bb5
// Line range:    280 - 291
void print_defaults_1(int32_t * a, char * value) {
    // 0x80a0a10
    int32_t v1; // 0x80a0a10
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x80a0a1c
    g275 = v2;
    int32_t v3; // 0x80a0a10
    int32_t v4; // 0x80a0a3f
    switch (v2) {
        case 1: {
            int32_t v5; // 0x80a0a10
            if (v1 == 0) {
                int32_t v6 = *(int32_t *)(v1 + 20); // 0x80a0ba8
                v3 = v6;
                v5 = v6;
            }
            // 0x80a0aba
            __fprintf_chk((struct _IO_FILE *)g43, 1, "%s %d\n", (char *)v1, v5);
            return;
        }
        case 2: {
            float64_t * v7 = v1 == 0 ? (float64_t *)(v1 + 28) : (float64_t *)&v3;
            __fprintf_chk((struct _IO_FILE *)g43, 1, "%s %g\n", (char *)v1, *v7);
            return;
        }
        case 3: {
        }
        case 7: {
            int32_t v8; // 0x80a0a10
            if (v1 == 0) {
                int32_t v9 = *(int32_t *)(v1 + 24); // 0x80a0b88
                v3 = v9;
                v8 = v9;
            }
            // 0x80a0b26
            __fprintf_chk((struct _IO_FILE *)g43, 1, "%s \"%s\"\n", (char *)v1, (char *)v8);
            return;
        }
        case 4: {
            int32_t v10; // 0x80a0a10
            if (v1 == 0) {
                // 0x80a0b80
                v10 = *(int32_t *)(v1 + 20);
            } else {
                // 0x80a0a30
                v10 = 0x1000000 * v1 >> 24;
            }
            // 0x80a0a33
            v4 = v10 != 0 ? (int32_t)"yes" : (int32_t)"no";
            // break -> 0x80a0a42
            break;
        }
        case 5: {
            int32_t v11 = *(int32_t *)(v1 + 36); // 0x80a0b56
            int32_t v12 = *(int32_t *)(v11 + 4 * *((v1 == 0 ? (int32_t *)(v1 + 20) : &v3))); // 0x80a0b59
            // 0x80a0a42
            v3 = v12;
            __fprintf_chk((struct _IO_FILE *)g43, 1, "%s %s\n", (char *)v1, (char *)v12);
            // 0x80a0a69
            return;
        }
        case 6: {
            int32_t v13; // 0x80a0a10
            float64_t * v14; // 0x80a0a10
            if (v1 == 0) {
                // 0x80a0b68
                v13 = *(int32_t *)(v1 + 20);
                v14 = (float64_t *)(v1 + 28);
            } else {
                // 0x80a0a78
                v14 = (float64_t *)&v3;
            }
            float64_t v15 = *v14;
            int32_t v16 = *(int32_t *)(*(int32_t *)(v1 + 36) + 4 * v13); // 0x80a0a7f
            __fprintf_chk((struct _IO_FILE *)g43, 1, "%s %g%s\n", (char *)v1, v15, (char *)v16);
            return;
        }
        default: {
            // 0x80a0a69
            return;
        }
    }
    // 0x80a0a42
    v3 = v4;
    __fprintf_chk((struct _IO_FILE *)g43, 1, "%s %s\n", (char *)v1, (char *)v4);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0bc0 - 0x80a0c00
// Line range:    136 - 143
void u(char * fmt, ...) {
    // 0x80a0bc0
    int32_t v1; // 0x80a0bc0
    __vfprintf_chk((struct _IO_FILE *)g43, 1, fmt, (int32_t)&v1);
    fputc(10, (struct _IO_FILE *)g43);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0c00 - 0x80a0ed9
// Line range:    146 - 146
void usage_attr(int32_t * a) {
    // 0x80a0c00
    int32_t v1; // 0x80a0c00
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80a0c0b
    int32_t v3 = *v2; // 0x80a0c0b
    if (v3 == 1) {
        // 0x80a0ca4
        return;
    }
    int32_t * v4 = (int32_t *)(v1 + 8); // 0x80a0cb0
    int32_t v5 = *v4; // 0x80a0cb0
    g276 = v5;
    int32_t v6 = v3; // 0x80a0cb3
    char * v7 = "--%s"; // 0x80a0cb3
    switch (v5) {
        case 0: {
            // 0x80a0ca4
            return;
        }
        case 1: {
        }
        case 2: {
            // 0x80a0e08
            v7 = "--%s <num>";
        }
        case 4: {
          lab_0x80a0dce:
            // 0x80a0dce
            __sprintf_chk((char *)&g63, 1, 200, v7, (char *)v5);
            v6 = *v2;
            // break -> 0x80a0c21
            break;
        }
        case 3: {
            // 0x80a0df8
            v7 = "--%s <string>";
            // branch (via goto) -> 0x80a0dce
            goto lab_0x80a0dce;
        }
        case 5: {
        }
        case 6: {
            // 0x80a0d00
            __sprintf_chk((char *)&g63, 1, 200, "--%s ", (char *)v5);
            if (*v4 == 6) {
                // 0x80a0eb8
                __strcat_chk((char *)&g63, " <val>", 200);
            }
            int32_t * v8 = (int32_t *)(v1 + 36); // 0x80a0d34
            int32_t v9 = (int32_t)&g6; // 0x80a0d3b
            if (*(int32_t *)*v8 != 0) {
                int32_t v10 = 1; // 0x80a0d50
                __strcat_chk((char *)&g63, (char *)v9, 200);
                int32_t v11 = *(int32_t *)*v8; // 0x80a0d6e
                int32_t v12 = 4 * v10; // 0x80a0d71
                __strcat_chk((char *)&g63, (char *)v11, 200);
                v9 = &g7;
                int32_t v13 = v10; // 0x80a0d95
                int32_t v14 = v12; // 0x80a0d95
                while (*(int32_t *)(*v8 + v12) != 0) {
                    // 0x80a0d48
                    v10 = v13 + 1;
                    __strcat_chk((char *)&g63, (char *)v9, 200);
                    v11 = *(int32_t *)(*v8 + v14);
                    v12 = 4 * v10;
                    __strcat_chk((char *)&g63, (char *)v11, 200);
                    v9 = &g7;
                    v13 = v10;
                    v14 = v12;
                }
            }
            // 0x80a0d97
            __strcat_chk((char *)&g63, ">", 200);
            v6 = *v2;
            // break -> 0x80a0c21
            break;
        }
        case 7: {
            // 0x80a0e18
            v7 = "--%s <path>";
            // branch (via goto) -> 0x80a0dce
            goto lab_0x80a0dce;
        }
    }
    int32_t v15 = (int32_t)&g63;
    int32_t v16 = *(int32_t *)v15; // 0x80a0c26
    int32_t v17 = v15 + 4; // 0x80a0c28
    int32_t v18 = v16 - 0x1010101 & (v16 ^ -0x7f7f7f80); // 0x80a0c33
    uint32_t v19 = v18 & -0x7f7f7f80; // 0x80a0c35
    while (v19 == 0) {
        // 0x80a0c26
        v15 = v17;
        v16 = *(int32_t *)v15;
        v17 = v15 + 4;
        v18 = v16 - 0x1010101 & (v16 ^ -0x7f7f7f80);
        v19 = v18 & -0x7f7f7f80;
    }
    int32_t v20 = (v18 & 0x8080) == 0 ? v15 + 6 : v17; // 0x80a0c4c
    unsigned char v21 = (char)((v18 & 0x8080) == 0 ? v19 / 0x10000 : v19); // 0x80a0c4f
    uint32_t v22 = v20 - (-1 - v21 < v21 ? 4 : 3) - (int32_t)&g63; // 0x80a0c54
    if (v22 < 31) {
        // 0x80a0cc0
        if (v6 != 0) {
            // 0x80a0cc8
            __fprintf_chk((struct _IO_FILE *)g43, 1, " %-30s\t%s\n", (char *)&g63, (char *)v6);
            return;
        }
        // 0x80a0e88
        __fprintf_chk((struct _IO_FILE *)g43, 1, " %-30s\n", (char *)&g63);
        // 0x80a0ca4
        return;
    }
    if (v6 == 0) {
        // 0x80a0e28
        __fprintf_chk((struct _IO_FILE *)g43, 1, " %s\n", (char *)&g63);
        // 0x80a0ca4
        return;
    }
    char * str = (char *)v6;
    if (strlen(str) + v22 < 72) {
        // 0x80a0e58
        __fprintf_chk((struct _IO_FILE *)g43, 1, " %s\t%s\n", (char *)&g63, str);
    } else {
        // 0x80a0c7b
        __fprintf_chk((struct _IO_FILE *)g43, 1, " %s\n\t\t\t%s\n", (char *)&g63, str);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0ee0 - 0x80a0ffc
// Line range:    201 - 230
void usage_hid(int32_t * h) {
    // 0x80a0ee0
    int32_t v1; // 0x80a0ee0
    if (*(char *)(v1 + 12) % 2 == 0) {
        // 0x80a0f95
        __fprintf_chk((struct _IO_FILE *)g43, 1, "\n%s options:\n", (char *)*(int32_t *)(v1 + 4));
        int32_t v2 = 0; // 0x80a0fd1
        if (v1 < 1) {
            // 0x80a0fea
            *(int32_t *)&exporter = 0;
            return;
        }
        v2++;
        usage_attr(&g279);
        while (v2 != v1) {
            // 0x80a0fd8
            v2++;
            usage_attr(&g279);
        }
        // 0x80a0fea
        *(int32_t *)&exporter = 0;
        return;
    }
    int32_t ** v3 = hid_enumerate(); // 0x80a0ef5
    __fprintf_chk((struct _IO_FILE *)g43, 1, "\ngui options:\n");
    if (hid_attr_nodes == NULL) {
        // 0x80a0f59
        return;
    }
    int32_t v4 = (int32_t)hid_attr_nodes; // 0x80a0ee0
    int32_t v5; // 0x80a0ee0
    while (true) {
      lab_0x80a0f28_2:
        // 0x80a0f28
        v5 = v4;
        int32_t * v6 = *v3;
        if (v6 != NULL) {
            int32_t v7 = (int32_t)v6; // 0x80a0f38
            int32_t v8 = (int32_t)v3; // 0x80a0f38
            while (*(int32_t *)(v5 + 4) != v7) {
                // 0x80a0f38
                v8 += 4;
                v7 = *(int32_t *)v8;
                if (v7 == 0) {
                    goto lab_0x80a0f68;
                }
            }
            goto lab_0x80a0f53;
        } else {
            goto lab_0x80a0f68;
        }
    }
  lab_0x80a0f68:;
    int32_t * v9 = (int32_t *)(v5 + 8); // 0x80a0f68
    if (*v9 < 1) {
        goto lab_0x80a0f53;
    } else {
        int32_t v10 = 1; // 0x80a0f7b
        usage_attr(&g279);
        int32_t v11 = v10; // 0x80a0f8b
        while (*v9 > v10) {
            // 0x80a0f78
            v10 = v11 + 1;
            usage_attr(&g279);
            v11 = v10;
        }
        int32_t v12 = *(int32_t *)v5; // 0x80a0f8d
        if (v12 == 0) {
            return;
        }
        // 0x80a0f28
        v4 = v12;
        goto lab_0x80a0f28_2;
    }
  lab_0x80a0f53:;
    int32_t v13 = *(int32_t *)v5; // 0x80a0f53
    if (v13 == 0) {
        return;
    }
    // 0x80a0f28
    v4 = v13;
    goto lab_0x80a0f28_2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1000 - 0x80a12f2
// Line range:    233 - 251
void usage(void) {
    int32_t ** v1 = hid_enumerate(); // 0x80a1009
    int32_t * v2 = *v1; // 0x80a1013
    int32_t v3; // 0x80a1000
    int32_t v4; // 0x80a1000
    int32_t v5; // 0x80a1000
    int32_t v6; // 0x80a1000
    int32_t v7; // 0x80a1000
    if (v2 == NULL) {
        // 0x80a12b3
        u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
        u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright", (char *)Progname);
        u("%s [gui options] <pcb file>\t\tto edit", (char *)Progname);
        v3 = 0;
        v5 = 0;
        goto lab_0x80a1094;
    } else {
        int32_t v8 = (int32_t)v1; // 0x80a1024
        unsigned char v9 = *(char *)((int32_t)v2 + 12); // 0x80a1028
        int32_t v10 = v9 % 2 != 0; // 0x80a1036
        int32_t v11 = (v9 & 2) != 0; // 0x80a103f
        v8 += 4;
        int32_t v12 = *(int32_t *)v8; // 0x80a1047
        int32_t v13 = (v9 & 4) != 0; // 0x80a104a
        int32_t v14 = v13; // 0x80a1052
        int32_t v15 = v11; // 0x80a1052
        int32_t v16 = v10; // 0x80a1052
        while (v12 != 0) {
            // 0x80a1028
            v9 = *(char *)(v12 + 12);
            v10 = v16 + (int32_t)(v9 % 2 != 0);
            v11 = v15 + (int32_t)((v9 & 2) != 0);
            v8 += 4;
            v12 = *(int32_t *)v8;
            v13 = v14 + (int32_t)((v9 & 4) != 0);
            v14 = v13;
            v15 = v11;
            v16 = v10;
        }
        // 0x80a1054
        u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
        u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright", (char *)Progname);
        u("%s [gui options] <pcb file>\t\tto edit", (char *)Progname);
        v3 = v13;
        v5 = v11;
        v4 = v13;
        v6 = v11;
        v7 = (int32_t)&g5;
        if (v10 == 1) {
            goto lab_0x80a1099;
        } else {
            goto lab_0x80a1094;
        }
    }
  lab_0x80a1094:
    // 0x80a1094
    v4 = v3;
    v6 = v5;
    v7 = &g3;
    goto lab_0x80a1099;
  lab_0x80a1099:
    // 0x80a1099
    u("Available GUI hid%s:", (char *)v7);
    int32_t * v17 = *v1; // 0x80a10ac
    if (v17 != NULL) {
        int32_t v18 = (int32_t)v17; // 0x80a10b4
        int32_t v19 = (int32_t)v1; // 0x80a10b4
        while (true) {
            int32_t v20 = v19;
            int32_t v21 = v18;
            int32_t v22; // 0x80a1000
            int32_t v23; // 0x80a1000
            if (*(char *)(v21 + 12) % 2 == 0) {
                int32_t v24 = v20 + 4; // 0x80a10b8
                int32_t v25 = *(int32_t *)v24; // 0x80a10b8
                v22 = v25;
                v23 = v24;
                if (v25 == 0) {
                    // break -> 0x80a10fd
                    break;
                }
            } else {
                int32_t v26 = *(int32_t *)(v21 + 8); // 0x80a10c8
                int32_t v27 = *(int32_t *)(v21 + 4); // 0x80a10cf
                __fprintf_chk((struct _IO_FILE *)g43, 1, "\t%s\t%s\n", (char *)v27, (char *)v26);
                int32_t v28 = v20 + 4; // 0x80a10f3
                int32_t v29 = *(int32_t *)v28; // 0x80a10f3
                v22 = v29;
                v23 = v28;
                if (v29 == 0) {
                    // break -> 0x80a10fd
                    break;
                }
            }
            // 0x80a10c2
            v18 = v22;
            v19 = v23;
        }
    }
    // 0x80a10fd
    u("%s -p [printing options] <pcb file>\tto print", (char *)Progname);
    int32_t v30 = v6 == 1 ? (int32_t)&g5 : (int32_t)&g3; // 0x80a111f
    u("Available printing hid%s:", (char *)v30);
    int32_t * v31 = *v1; // 0x80a1135
    int32_t v32; // 0x80a1000
    if (v31 == NULL) {
        // 0x80a10fd
        v32 = (int32_t)v1;
    } else {
        int32_t v33 = (int32_t)v1;
        int32_t v34 = (int32_t)v31; // 0x80a113d
        int32_t v35 = v33; // 0x80a113d
        while (true) {
            int32_t v36 = v35;
            int32_t v37 = v34;
            int32_t v38; // 0x80a1000
            int32_t v39; // 0x80a1000
            if ((*(char *)(v37 + 12) & 2) == 0) {
                int32_t v40 = v36 + 4; // 0x80a1140
                int32_t v41 = *(int32_t *)v40; // 0x80a1140
                v38 = v41;
                v39 = v40;
                v32 = v33;
                if (v41 == 0) {
                    // break -> 0x80a1185
                    break;
                }
            } else {
                int32_t v42 = *(int32_t *)(v37 + 8); // 0x80a1150
                int32_t v43 = *(int32_t *)(v37 + 4); // 0x80a1157
                __fprintf_chk((struct _IO_FILE *)g43, 1, "\t%s\t%s\n", (char *)v43, (char *)v42);
                int32_t v44 = v36 + 4; // 0x80a117b
                int32_t v45 = *(int32_t *)v44; // 0x80a117b
                v38 = v45;
                v39 = v44;
                v32 = v33;
                if (v45 == 0) {
                    // break -> 0x80a1185
                    break;
                }
            }
            // 0x80a114a
            v34 = v38;
            v35 = v39;
        }
    }
    // 0x80a1185
    u("%s -x hid [export options] <pcb file>\tto export", (char *)Progname);
    int32_t v46 = v4 == 1 ? (int32_t)&g5 : (int32_t)&g3; // 0x80a11a7
    u("Available export hid%s:", (char *)v46);
    int32_t * v47 = *v1; // 0x80a11bd
    if (v47 == NULL) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    int32_t v48 = (int32_t)v47; // 0x80a11cb
    int32_t v49 = v32; // 0x80a11cb
    while (true) {
        int32_t v50 = v49;
        int32_t v51 = v48;
        int32_t v52; // 0x80a1000
        int32_t v53; // 0x80a1000
        if ((*(char *)(v51 + 12) & 4) == 0) {
            int32_t v54 = v50 + 4; // 0x80a11d0
            int32_t v55 = *(int32_t *)v54; // 0x80a11d0
            v52 = v55;
            v53 = v54;
            if (v55 == 0) {
                // break -> 0x80a1215
                break;
            }
        } else {
            int32_t v56 = *(int32_t *)(v51 + 8); // 0x80a11e0
            int32_t v57 = *(int32_t *)(v51 + 4); // 0x80a11e7
            __fprintf_chk((struct _IO_FILE *)g43, 1, "\t%s\t%s\n", (char *)v57, (char *)v56);
            int32_t v58 = v50 + 4; // 0x80a120b
            int32_t v59 = *(int32_t *)v58; // 0x80a120b
            v52 = v59;
            v53 = v58;
            if (v59 == 0) {
                // break -> 0x80a1215
                break;
            }
        }
        // 0x80a11da
        v48 = v52;
        v49 = v53;
    }
    int32_t * v60 = *v1; // 0x80a1218
    if (v60 == NULL) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    int32_t v61 = (int32_t)v60; // 0x80a1224
    int32_t v62 = v32; // 0x80a1224
    while (true) {
        int32_t v63 = v62;
        int32_t v64; // 0x80a1000
        int32_t v65; // 0x80a1000
        if (*(char *)(v61 + 12) % 2 == 0) {
            int32_t v66 = v63 + 4; // 0x80a1228
            int32_t v67 = *(int32_t *)v66; // 0x80a1228
            v64 = v67;
            v65 = v66;
            if (v67 == 0) {
                // break -> 0x80a1247
                break;
            }
        } else {
            // 0x80a1238
            usage_hid(&g279);
            int32_t v68 = v63 + 4; // 0x80a123d
            int32_t v69 = *(int32_t *)v68; // 0x80a123d
            v64 = v69;
            v65 = v68;
            if (v69 == 0) {
                // break -> 0x80a1247
                break;
            }
        }
        // 0x80a1232
        v61 = v64;
        v62 = v65;
    }
    int32_t * v70 = *v1; // 0x80a124a
    if (v70 == NULL) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    int32_t v71 = (int32_t)v70; // 0x80a1252
    int32_t v72 = v32; // 0x80a1252
    while (true) {
        int32_t v73 = v72;
        int32_t v74; // 0x80a1000
        int32_t v75; // 0x80a1000
        if ((*(char *)(v71 + 12) & 2) == 0) {
            int32_t v76 = v73 + 4; // 0x80a1258
            int32_t v77 = *(int32_t *)v76; // 0x80a1258
            v74 = v77;
            v75 = v76;
            if (v77 == 0) {
                // break -> 0x80a1277
                break;
            }
        } else {
            // 0x80a1268
            usage_hid(&g279);
            int32_t v78 = v73 + 4; // 0x80a126d
            int32_t v79 = *(int32_t *)v78; // 0x80a126d
            v74 = v79;
            v75 = v78;
            if (v79 == 0) {
                // break -> 0x80a1277
                break;
            }
        }
        // 0x80a1262
        v71 = v74;
        v72 = v75;
    }
    int32_t * v80 = *v1; // 0x80a127a
    if (v80 == NULL) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    int32_t v81 = (int32_t)v80; // 0x80a1000
    int32_t v82 = v32; // 0x80a1000
    while (true) {
        int32_t v83 = v82;
        int32_t v84; // 0x80a1000
        int32_t v85; // 0x80a1000
        if ((*(char *)(v81 + 12) & 4) == 0) {
            int32_t v86 = v83 + 4; // 0x80a1288
            int32_t v87 = *(int32_t *)v86; // 0x80a1288
            v84 = v87;
            v85 = v86;
            if (v87 == 0) {
                // break -> 0x80a12a7
                break;
            }
        } else {
            // 0x80a1298
            usage_hid(&g279);
            int32_t v88 = v83 + 4; // 0x80a129d
            int32_t v89 = *(int32_t *)v88; // 0x80a129d
            v84 = v89;
            v85 = v88;
            if (v89 == 0) {
                // break -> 0x80a12a7
                break;
            }
        }
        // 0x80a1292
        v81 = v84;
        v82 = v85;
    }
    // 0x80a12a7
    exit(1);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1300 - 0x80a132e
// Line range:    602 - 605
void print_version(void) {
    // 0x80a1300
    __printf_chk(1, "PCB version %s\n", "20091103");
    exit(0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1330 - 0x80a1367
// Line range:    113 - 132
void copyright(void) {
    // 0x80a1330
    __printf_chk(1, "\n                COPYRIGHT for %s version %s\n\n    PCB, interactive printed circuit board design\n    Copyright (C) 1994,1995,1996,1997 Thomas Nau\n    Copyright (C) 1998, 1999, 2000 Harry Eaton\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n", (char *)Progname, "20091103");
    exit(0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1370 - 0x80a138c
// Line range:    555 - 555
void register_main_attribute_list(void) {
    // 0x80a1370
    hid_register_attributes(&main_attribute_list, 133);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1390 - 0x80a2132
// Line range:    834 - 928
int main(int argc, char ** argv) {
    int32_t v1 = __readgsdword(20); // 0x80a13ab
    register_action_action_list();
    register_rotate_action_list();
    register_command_action_list();
    register_djopt_flag_list();
    register_djopt_action_list();
    register_flags_flag_list();
    register_fontmode_action_list();
    register_main_attribute_list();
    register_move_action_list();
    register_netlist_action_list();
    register_puller_action_list();
    register_report_action_list();
    register_vendor_action_list();
    register_vendor_flag_list();
    register_toporouter_action_list();
    setbuf(g45, NULL);
    char * str = *argv;
    int32_t len = strlen(str); // 0x80a1428
    int32_t v2 = 0; // 0x80a1444
    int32_t v3 = 0; // 0x80a1444
    int32_t v4; // 0x80a1390
    if (len != 0) {
        v3 = *(char *)(v2 + (int32_t)str) == 47 ? 1 : v3;
        v2++;
        while (v2 != len) {
            // 0x80a1438
            v3 = *(char *)(v2 + (int32_t)str) == 47 ? 1 : v3;
            v2++;
        }
        if (v3 == 0) {
            goto lab_0x80a1c7f;
        } else {
            int32_t v5 = (int32_t)__strdup(lrealpath(str)); // 0x80a1459
            bindir = v5;
            v4 = v5;
            goto lab_0x80a1465;
        }
    } else {
        goto lab_0x80a1c7f;
    }
  lab_0x80a176a:;
    // 0x80a176a
    int32_t * v6; // 0x80a1724
    int32_t v7 = *v6; // 0x80a176a
    int32_t v8; // 0x80a1390
    *(int32_t *)(v8 + (int32_t)&g37) = pcblibpath;
    int32_t v9 = v7; // 0x80a177d
    int32_t v10; // 0x80a1390
    if (v7 != 0) {
        goto lab_0x80a1700;
    } else {
        if (v8 == 0x18c0) {
            // break -> 0x80a178a
            goto lab_0x80a178a_2;
        }
        // 0x80a1724
        v10 = v8 + 48;
        goto lab_0x80a1724_2;
    }
  lab_0x80a1719:
    if (v8 == 0x18c0) {
        // break -> 0x80a178a
        goto lab_0x80a178a_2;
    }
    // 0x80a1724
    v10 = v8 + 48;
    goto lab_0x80a1724_2;
  lab_0x80a174a:;
    int32_t v18 = 10; // 0x80a1390
    int32_t v11; // 0x80a1724
    int32_t v19 = v11;
    int32_t v20 = (int32_t)"font-path";
    unsigned char v21 = *(char *)v19; // 0x80a1756
    char v22 = *(char *)v20; // 0x80a1756
    char v23 = v22; // 0x80a1756
    bool v24 = false; // 0x80a1756
    int32_t v17; // 0x80a1390
    while (v21 == v22) {
        int32_t v25 = v18 - 1; // 0x80a1756
        int32_t v26 = v20 + v17; // 0x80a1756
        int32_t v27 = v19 + v17; // 0x80a1756
        v18 = v25;
        v23 = v21;
        v24 = true;
        if (v25 == 0) {
            // break -> 
            break;
        }
        v19 = v27;
        v20 = v26;
        v21 = *(char *)v19;
        v22 = *(char *)v20;
        v23 = v22;
        v24 = false;
    }
    unsigned char v28 = v23;
    int32_t v29 = v11; // 0x80a1764
    int32_t v30 = 13; // 0x80a1764
    if ((v21 >= v28 && !v24) != v21 < v28) {
        int32_t v31 = v29;
        int32_t v32 = (int32_t)"element-path";
        unsigned char v33 = *(char *)v31; // 0x80a16d4
        char v34 = *(char *)v32; // 0x80a16d4
        char v35 = v34; // 0x80a16d4
        bool v36 = false; // 0x80a16d4
        while (v33 == v34) {
            int32_t v37 = v30 - 1; // 0x80a16d4
            int32_t v38 = v32 + v17; // 0x80a16d4
            v29 = v31 + v17;
            v30 = v37;
            v35 = v33;
            v36 = true;
            if (v37 == 0) {
                // break -> 
                break;
            }
            v31 = v29;
            v32 = v38;
            v33 = *(char *)v31;
            v34 = *(char *)v32;
            v35 = v34;
            v36 = false;
        }
        unsigned char v39 = v35;
        int32_t v40 = v11; // 0x80a16e2
        int32_t v41 = 9; // 0x80a16e2
        if ((v33 >= v39 && !v36) == v33 < v39) {
            goto lab_0x80a176a;
        } else {
            int32_t v42 = v40;
            int32_t v43 = (int32_t)"lib-path"; // 0x80a1390
            while (*(char *)v42 == *(char *)v43) {
                int32_t v44 = v41 - 1; // 0x80a16f4
                v43 += v17;
                v40 = v42 + v17;
                v41 = v44;
                if (v44 == 0) {
                    goto lab_0x80a176a;
                }
                v42 = v40;
            }
            // 0x80a16f8
            v9 = *v6;
            goto lab_0x80a1700;
        }
    } else {
        goto lab_0x80a176a;
    }
  lab_0x80a1700:;
    int32_t v45 = 11; // 0x80a1390
    int32_t v46 = v9;
    int32_t v47 = (int32_t)"lib-newlib";
    while (*(char *)v46 == *(char *)v47) {
        int32_t v48 = v45 - 1; // 0x80a170a
        int32_t v49 = v47 + v17; // 0x80a170a
        int32_t v50 = v46 + v17; // 0x80a170a
        v45 = v48;
        if (v48 == 0) {
            // 0x80a170e
            *(int32_t *)(v8 + (int32_t)&g37) = pcbtreepath;
            goto lab_0x80a1719;
        }
        v46 = v50;
        v47 = v49;
    }
    goto lab_0x80a1719;
  lab_0x80a1c7f:;
    char * env_val = getenv("PATH"); // 0x80a1c86
    if (env_val != NULL) {
        char * str2 = __strdup(env_val); // 0x80a1c96
        char * next_token = strtok(str2, ":"); // 0x80a1caa
        if (next_token != NULL) {
            char * str3 = next_token;
            while (*str3 != 0) {
                int32_t * mem = calloc(1, strlen(str) + 2 + strlen(str3)); // 0x80a1ce1
                if (mem == NULL) {
                    // 0x80a20dd
                    __fprintf_chk((struct _IO_FILE *)g43, 1, "InitPaths():  malloc failed\n");
                    exit(1);
                    // UNREACHABLE
                }
                // 0x80a1cf0
                __sprintf_chk((char *)mem, 1, -1, "%s%s%s", str3, (char *)&g35, str);
                int32_t v51; // bp-148, 0x80a1390
                if (__xstat(3, (char *)mem, (struct stat *)&v51) == 0) {
                    // 0x80a207d
                    bindir = (int32_t)lrealpath((char *)mem);
                    free(mem);
                    free((int32_t *)str2);
                    v4 = bindir;
                    goto lab_0x80a1465;
                }
                // 0x80a1d40
                free(mem);
                char * next_token2 = strtok(NULL, ":"); // 0x80a1d57
                if (next_token2 == NULL) {
                    // break -> 0x80a1d6b
                    break;
                }
                str3 = next_token2;
            }
        }
        // 0x80a1d6b
        free((int32_t *)str2);
    }
    int32_t * mem2 = calloc(1, 9); // 0x80a1d86
    int32_t v52 = (int32_t)mem2; // 0x80a1d86
    if (mem2 != NULL) {
        // 0x80a1d91
        *mem2 = 0x7273752f;
        *(int32_t *)(v52 + 4) = 0x6e69622f;
        *(char *)(v52 + 8) = 0;
    }
    // 0x80a1da2
    bindir = v52;
    int32_t str4 = v52; // 0x80a1da7
    goto lab_0x80a14b4;
  lab_0x80a14b4:;
    int32_t * mem3 = calloc(1, strlen((char *)str4) + 4); // 0x80a14ca
    exec_prefix = (int32_t)mem3;
    if (mem3 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)g43, 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a14dc
    __sprintf_chk((char *)mem3, 1, -1, "%s%s%s", (char *)bindir, (char *)&g35, "..");
    int32_t * mem4 = calloc(1, strlen((char *)bindir) + 14); // 0x80a1531
    pcblibdir = (int32_t)mem4;
    if (mem4 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)g43, 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a1543
    __sprintf_chk((char *)mem4, 1, -1, "%s%s%s", (char *)bindir, (char *)&g35, "../share/pcb");
    int32_t * mem5 = calloc(1, strlen((char *)bindir) + 21); // 0x80a1598
    pcbtreedir = (int32_t)mem5;
    if (mem5 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)g43, 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a15aa
    __sprintf_chk((char *)mem5, 1, -1, "%s%s%s", (char *)bindir, (char *)&g35, "../share/pcb/newlib");
    int32_t * mem6 = calloc(1, strlen((char *)pcblibdir) + 3); // 0x80a15ff
    pcblibpath = (int32_t)mem6;
    if (mem6 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)g43, 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a1611
    __sprintf_chk((char *)mem6, 1, -1, ".%s%s", ":", (char *)pcblibdir);
    int32_t * mem7 = calloc(1, strlen((char *)pcblibdir) + 16 + strlen((char *)pcbtreedir)); // 0x80a166e
    pcbtreepath = (int32_t)mem7;
    if (mem7 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)g43, 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a1680
    __sprintf_chk((char *)mem7, 1, -1, "%s%s%s%spcblib-newlib", (char *)pcbtreedir, ":", (char *)pcblibdir, (char *)&g35);
    bool v53; // 0x80a1390
    v17 = v53 ? -1 : 1;
    v10 = 0;
    while (true) {
      lab_0x80a1724_2:
        // 0x80a1724
        v8 = v10;
        v6 = (int32_t *)(v8 + (int32_t)&main_attribute_list);
        v11 = *v6;
        int32_t v12 = v11; // 0x80a172c
        int32_t v13 = 16; // 0x80a172c
        if (v11 == 0) {
            goto lab_0x80a1719;
        } else {
            int32_t v14 = v12;
            int32_t v15 = (int32_t)"lib-command-dir"; // 0x80a1390
            while (*(char *)v14 == *(char *)v15) {
                int32_t v16 = v13 - 1; // 0x80a173a
                v15 += v17;
                v12 = v14 + v17;
                v13 = v16;
                if (v16 == 0) {
                    // 0x80a173e
                    *(int32_t *)(v8 + (int32_t)&g37) = pcblibdir;
                    goto lab_0x80a174a;
                }
                v14 = v12;
            }
            goto lab_0x80a174a;
        }
    }
  lab_0x80a178a_2:;
    char * env_val2 = getenv("HOME"); // 0x80a1791
    char * v54 = env_val2; // 0x80a1798
    int32_t v55; // 0x80a1390
    if (env_val2 == NULL) {
        char * env_val3 = getenv("USERPROFILE"); // 0x80a20b0
        v54 = env_val3;
        v55 = 0;
        if (env_val3 != NULL) {
            goto lab_0x80a179e;
        } else {
            goto lab_0x80a17ab;
        }
    } else {
        goto lab_0x80a179e;
    }
  lab_0x80a1465:;
    int32_t str5 = v4;
    char * found_char_pos = strchr((char *)str5, 47); // 0x80a1470
    str4 = str5;
    if (found_char_pos != NULL) {
        char * v56 = found_char_pos; // 0x80a147e
        str4 = str5;
        if (*found_char_pos != 0) {
            char * v57 = v56;
            char * found_char_pos2 = strchr((char *)((int32_t)v57 + 1), 47); // 0x80a14a2
            while (found_char_pos2 != NULL) {
                // 0x80a1488
                v56 = found_char_pos2;
                if (*found_char_pos2 == 0) {
                    // break -> 0x80a14ab
                    break;
                }
                v57 = v56;
                found_char_pos2 = strchr((char *)((int32_t)v57 + 1), 47);
            }
            // 0x80a14ab
            *v57 = 0;
            str4 = bindir;
        }
    }
    goto lab_0x80a14b4;
  lab_0x80a179e:
    // 0x80a179e
    v55 = (int32_t)__strdup(v54);
    goto lab_0x80a17ab;
  lab_0x80a17ab:
    // 0x80a17ab
    homedir = v55;
    bindtextdomain("pcb", "/usr/share/locale");
    bind_textdomain_codeset("pcb", "UTF-8");
    hid_init();
    hid_load_settings();
    char * str6 = *argv;
    int32_t v58 = (int32_t)str6;
    program_name = v58;
    char * found_char_pos3 = strrchr(str6, 47); // 0x80a17f4
    program_basename = (int32_t)found_char_pos3;
    int32_t v59; // 0x80a1390
    if (found_char_pos3 == NULL) {
        // 0x80a1fb4
        program_directory = &g36;
        v59 = v58;
    } else {
        char * str7 = __strdup(str6); // 0x80a1809
        program_directory = (int32_t)str7;
        *strrchr(str7, 47) = 0;
        v59 = program_basename + 1;
    }
    // 0x80a1835
    program_basename = v59;
    Progname = v59;
    int32_t v60; // 0x80a1390
    int32_t v61; // 0x80a1390
    char ** v62; // 0x80a1390
    int32_t v63; // 0x80a1841
    int32_t v64; // 0x80a1845
    char v65; // 0x80a1848
    char v66; // 0x80a1853
    if (argc < 2) {
        goto lab_0x80a18b2;
    } else {
        // 0x80a1841
        v63 = (int32_t)argv;
        int32_t v67 = v63 + 4; // 0x80a1845
        v64 = *(int32_t *)v67;
        v65 = *(char *)v64;
        if (v65 != 45) {
            goto lab_0x80a18b2;
        } else {
            // 0x80a1853
            v66 = *(char *)(v64 + 1);
            if (v66 == 104) {
                // 0x80a185f
                if (*(char *)(v64 + 2) == 0) {
                    // 0x80a186b
                    usage();
                    // UNREACHABLE
                }
            }
            if (v66 == 86) {
                // 0x80a1df9
                if (*(char *)(v64 + 2) == 0) {
                    // 0x80a1e09
                    print_version();
                    // UNREACHABLE
                }
            }
            // 0x80a1dac
            if (v66 != *(char *)&g8) {
                goto lab_0x80a189e;
            } else {
                // 0x80a1dbc
                if (*(char *)(v64 + 2) != 0) {
                    goto lab_0x80a189e;
                } else {
                    int32_t v68 = (int32_t)hid_find_printer(); // 0x80a1dcc
                    *(int32_t *)&gui = v68;
                    *(int32_t *)&exporter = v68;
                    v61 = argc - 1;
                    v62 = (char **)v67;
                    v60 = v68;
                    goto lab_0x80a18bc;
                }
            }
        }
    }
  lab_0x80a18b2:;
    int32_t v69 = (int32_t)hid_find_gui(); // 0x80a18b2
    *(int32_t *)&gui = v69;
    v61 = argc;
    v62 = argv;
    v60 = v69;
    goto lab_0x80a18bc;
  lab_0x80a18bc:
    // 0x80a18bc
    if (v60 == 0) {
        // 0x80a1fa8
        exit(1);
        // UNREACHABLE
    }
    int32_t v70 = 1; // 0x80a18d0
    int32_t v71; // bp-56, 0x80a1390
    __sprintf_chk((char *)&v71, 1, 20, "signal%d", v70);
    char * v72 = MyStrdup((char *)&v71, "DefaultLayerNames"); // 0x80a1902
    int32_t v73 = 4 * v70; // 0x80a190a
    *(int32_t *)(v73 + (int32_t)&g128) = (int32_t)"#c49350";
    *(int32_t *)(v73 + (int32_t)&g130) = (int32_t)"#00ffff";
    *(int32_t *)(v73 + (int32_t)&g150) = (int32_t)v72;
    int32_t v74 = v70; // 0x80a1927
    while (v70 != 16) {
        // 0x80a18d0
        v70 = v74 + 1;
        __sprintf_chk((char *)&v71, 1, 20, "signal%d", v70);
        v72 = MyStrdup((char *)&v71, "DefaultLayerNames");
        v73 = 4 * v70;
        *(int32_t *)(v73 + (int32_t)&g128) = (int32_t)"#c49350";
        *(int32_t *)(v73 + (int32_t)&g130) = (int32_t)"#00ffff";
        *(int32_t *)(v73 + (int32_t)&g150) = (int32_t)v72;
        v74 = v70;
    }
    // 0x80a1929
    if (show_help != 0) {
        // 0x80a1ef7
        usage();
        // UNREACHABLE
    }
    if (v61 >= 2) {
        char v75 = *(char *)*(int32_t *)((int32_t)v62 + 4); // 0x80a195a
        if (v75 == 45) {
            // 0x80a1ef7
            usage();
            // UNREACHABLE
        }
    }
    // 0x80a1963
    if (show_version != 0) {
        // 0x80a1f0b
        print_version();
        // UNREACHABLE
    }
    // 0x80a1971
    if (show_defaults != 0) {
        int32_t ** v76 = hid_enumerate(); // 0x80a1f1e
        int32_t * v77 = *v76; // 0x80a1f23
        if (v77 == NULL) {
            // 0x80a1fa8
            exit(1);
            // UNREACHABLE
        }
        int32_t v78 = (int32_t)v76; // 0x80a1f2d
        int32_t v79 = (int32_t)v77;
        int32_t v80; // 0x80a1390
        int32_t v81; // 0x80a1390
        int32_t v82; // 0x80a1fc9
        int32_t v83; // 0x80a2019
        int32_t * v84; // 0x80a1f68
        int32_t v85; // 0x80a1f90
        int32_t v86; // 0x80a1f7b
        int32_t v87; // 0x80a1390
        if (*(char *)(v79 + 12) % 2 == 0) {
            // 0x80a1fc9
            v82 = *(int32_t *)(v79 + 4);
            if (!((v87 < 1 | __fprintf_chk((struct _IO_FILE *)g43, 1, "\n%s defaults:\n", (char *)v82) == 0))) {
                print_defaults_1(&g279, (char *)&g279);
                v83 = 1;
                v81 = v83;
                while (v83 != v87) {
                    // 0x80a2010
                    print_defaults_1(&g279, (char *)&g279);
                    v83 = v81 + 1;
                    v81 = v83;
                }
            }
        } else {
            // 0x80a1f3a
            __fprintf_chk((struct _IO_FILE *)g43, 1, "\ngui defaults:\n");
            if (hid_attr_nodes != NULL) {
                // 0x80a1f68
                v85 = (int32_t)hid_attr_nodes;
                v84 = (int32_t *)(v85 + 8);
                if (*v84 >= 1) {
                    v86 = 1;
                    print_defaults_1(&g279, (char *)&g279);
                    v80 = v86;
                    while (v86 < *v84) {
                        // 0x80a1f78
                        v86 = v80 + 1;
                        print_defaults_1(&g279, (char *)&g279);
                        v80 = v86;
                    }
                }
                // 0x80a1f90
                v85 = *(int32_t *)v85;
                while (v85 != 0) {
                    // 0x80a1f68
                    v84 = (int32_t *)(v85 + 8);
                    if (*v84 >= 1) {
                        v86 = 1;
                        print_defaults_1(&g279, (char *)&g279);
                        v80 = v86;
                        while (v86 < *v84) {
                            // 0x80a1f78
                            v86 = v80 + 1;
                            print_defaults_1(&g279, (char *)&g279);
                            v80 = v86;
                        }
                    }
                    // 0x80a1f90
                    v85 = *(int32_t *)v85;
                }
            }
        }
        // 0x80a1f96
        v78 += 4;
        int32_t v88 = *(int32_t *)v78; // 0x80a1f9a
        while (v88 != 0) {
            // 0x80a1f30
            v79 = v88;
            if (*(char *)(v79 + 12) % 2 == 0) {
                // 0x80a1fc9
                v82 = *(int32_t *)(v79 + 4);
                if (!((v87 < 1 | __fprintf_chk((struct _IO_FILE *)g43, 1, "\n%s defaults:\n", (char *)v82) == 0))) {
                    print_defaults_1(&g279, (char *)&g279);
                    v83 = 1;
                    v81 = v83;
                    while (v83 != v87) {
                        // 0x80a2010
                        print_defaults_1(&g279, (char *)&g279);
                        v83 = v81 + 1;
                        v81 = v83;
                    }
                }
            } else {
                // 0x80a1f3a
                __fprintf_chk((struct _IO_FILE *)g43, 1, "\ngui defaults:\n");
                if (hid_attr_nodes != NULL) {
                    // 0x80a1f68
                    v85 = (int32_t)hid_attr_nodes;
                    v84 = (int32_t *)(v85 + 8);
                    if (*v84 >= 1) {
                        v86 = 1;
                        print_defaults_1(&g279, (char *)&g279);
                        v80 = v86;
                        while (v86 < *v84) {
                            // 0x80a1f78
                            v86 = v80 + 1;
                            print_defaults_1(&g279, (char *)&g279);
                            v80 = v86;
                        }
                    }
                    // 0x80a1f90
                    v85 = *(int32_t *)v85;
                    while (v85 != 0) {
                        // 0x80a1f68
                        v84 = (int32_t *)(v85 + 8);
                        if (*v84 >= 1) {
                            v86 = 1;
                            print_defaults_1(&g279, (char *)&g279);
                            v80 = v86;
                            while (v86 < *v84) {
                                // 0x80a1f78
                                v86 = v80 + 1;
                                print_defaults_1(&g279, (char *)&g279);
                                v80 = v86;
                            }
                        }
                        // 0x80a1f90
                        v85 = *(int32_t *)v85;
                    }
                }
            }
            // 0x80a1f96
            v78 += 4;
            v88 = *(int32_t *)v78;
        }
        // 0x80a1fa8
        exit(1);
        // UNREACHABLE
    }
    // 0x80a197f
    if (show_copyright != 0) {
        // 0x80a202d
        copyright();
        // UNREACHABLE
    }
    // 0x80a198d
    Output = (int32_t)gui;
    g194 = (char *)gui;
    g195 = (char *)gui;
    g196 = (char *)gui;
    if ((*g153 || 1) != 47) {
        // 0x80a19d1
        g153 = Concat((char *)g152);
    }
    // 0x80a19f7
    if ((*g154 || 1) != 47) {
        // 0x80a1a07
        g154 = Concat((char *)g152);
    }
    // 0x80a1a2d
    if (g136 >= 0x989681) {
        // 0x80a1a3c
        g136 = 1000;
    }
    int32_t v89 = g134; // 0x80a1a46
    char * v90 = g135;
    if (v89 < 0x989681) {
        // 0x80a1a5b
        if (v90 > NULL) {
            goto lab_0x80a1a69;
        } else {
            // 0x80a1e60
            g135 = (char *)(40 * v89 / 100);
            goto lab_0x80a1a69;
        }
    } else {
        // 0x80a1e48
        g134 = 4000;
        if (v90 >= NULL == (v90 != NULL)) {
            goto lab_0x80a1a69;
        } else {
            // 0x80a1e60
            g135 = (char *)1600;
            goto lab_0x80a1a69;
        }
    }
  lab_0x80a189e:
    if (v66 == 120 == argc > 2 == v65 == 45) {
        // 0x80a1e97
        if (*(char *)(v64 + 2) != 0) {
            goto lab_0x80a18b2;
        } else {
            int32_t v91 = v63 + 8; // 0x80a1ea7
            int32_t v92 = (int32_t)hid_find_exporter((char *)*(int32_t *)v91); // 0x80a1ead
            *(int32_t *)&gui = v92;
            *(int32_t *)&exporter = v92;
            v61 = argc - 2;
            v62 = (char **)v91;
            v60 = v92;
            goto lab_0x80a18bc;
        }
    } else {
        goto lab_0x80a18b2;
    }
  lab_0x80a1a69:;
    int32_t v93 = g139; // 0x80a1a73
    int32_t v94 = v93 < 1000 == (999 - v93 & v93) < 0 ? v93 : 1000; // 0x80a1a7f
    int32_t v95 = v94 - 0x989680; // 0x80a1a96
    float64_t v96 = g140; // 0x80a1a9f
    int32_t v97 = (int32_t)(float32_t)v96 < 1000 == (999 - (int32_t)(float32_t)v96 & (int32_t)(float32_t)v96) < 0 ? (int32_t)(float32_t)v96 : 1000; // 0x80a1aa9
    g139 = v95 < 0 == (0x98967f - v94 & v94) < 0 == (v95 != 0) ? 0x989680 : v94;
    int32_t v98 = v97 - 0x989680; // 0x80a1ab6
    float64_t v99 = v98 == 0 | v98 < 0 != (0x98967f - v97 & v97) < 0 ? (float64_t)(int64_t)v97 : 4.9406564584124654e-317; // 0x80a1abf
    g140 = v99;
    ParseRouteString((char *)g159, &g167, 1);
    if (show_actions != 0) {
        // 0x80a2121
        print_actions();
        exit(0);
        // UNREACHABLE
    }
    // 0x80a1adf
    if (do_dump_actions != 0) {
        // 0x80a20cc
        dump_actions();
        exit(0);
        // UNREACHABLE
    }
    int32_t v100 = (int32_t)CreateNewPCB(1); // 0x80a1af4
    *(int32_t *)&PCB = v100;
    *(int32_t *)(*(int32_t *)(v100 + 0x220c) + 24) = 8;
    ParseGroupString((char *)g158, (int32_t *)(v100 + 0x1cd4), 8);
    CreateNewPCBPost(PCB, 1);
    if (v61 >= 2) {
        // 0x80a1b44
        command_line_pcb = *(int32_t *)((int32_t)v62 + 4);
    }
    // 0x80a1b50
    ResetStackAndVisibility();
    CreateDefaultFont();
    if (g41 % 2 != 0) {
        // 0x80a203d
        InitCrosshair();
    }
    // 0x80a1b69
    signal(SIGPIPE, SIG_IGN);
    InitBuffers();
    SetMode(110);
    if (command_line_pcb != 0) {
        // 0x80a1b97
        if (LoadPCB((char *)command_line_pcb) != 0) {
            // 0x80a205a
            g195 = MyStrdup((char *)command_line_pcb, "main()");
        }
    }
    // 0x80a1ba7
    if (g164 != NULL) {
        // 0x80a1bb0
        if (*g164 != 0) {
            // 0x80a204d
            LayerStringToLayerStack(g164);
        }
    }
    // 0x80a1bb9
    if ((g41 & 6) != 0) {
        // 0x80a2106
        exit(0);
        // UNREACHABLE
    }
    // 0x80a1bc8
    atexit(0x80931b0);
    if (ReadLibraryContents() == 0 && Library != 0) {
        // 0x80a1e37
        hid_action("LibraryChanged");
    }
    // 0x80a1be1
    g187 = 0;
    if (g162 != NULL) {
        // 0x80a1bf4
        Message("Executing startup script file %s\n", g162);
        hid_actionl("ExecuteFile");
    }
    // 0x80a1c21
    if (g163 != NULL) {
        // 0x80a1c2a
        Message("Executing startup action %s\n", g163);
        hid_parse_actions(g163, NULL);
    }
    // 0x80a1c4f
    if (g187 == 0) {
        // 0x80a1eca
        g187 = 1;
        pcb_dbus_setup();
        EnableAutosave();
        pcb_dbus_finish();
    }
    // 0x80a1c5c
    if (v1 == __readgsdword(20)) {
        // 0x80a1c72
        return 0;
    }
    // 0x80a211c
    __stack_chk_fail();
    // 0x80a2121
    print_actions();
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a23a0 - 0x80a23f5
// Line range:    155 - 169
void SetPinBoundingBox(int32_t * Pin) {
    int32_t v1 = (int32_t)Pin;
    int32_t v2 = *(int32_t *)(v1 + 40) + 1 + *(int32_t *)(v1 + 36); // 0x80a23ad
    int32_t v3 = v2 + (int32_t)(v2 < 0) >> 1; // 0x80a23bb
    int32_t v4 = *(int32_t *)(v1 + 44) + 1; // 0x80a23bd
    int32_t v5 = v4 + (int32_t)(v4 < 0) >> 1; // 0x80a23c8
    int32_t v6 = v3 - v5; // 0x80a23ca
    int32_t v7 = v6 < 0 == ((v6 ^ v3) & (v5 ^ v3)) < 0 ? v3 : v5; // 0x80a23cc
    int32_t * v8 = (int32_t *)(v1 + 52); // 0x80a23cf
    *Pin = *v8 - v7;
    int32_t v9 = *(int32_t *)(v1 + 56); // 0x80a23d6
    *(int32_t *)(v1 + 4) = v9 - v7;
    int32_t v10 = v7 + 1;
    *(int32_t *)(v1 + 8) = v10 + *v8;
    *(int32_t *)(v1 + 12) = v10 + v9;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2400 - 0x80a2495
// Line range:    229 - 242
void SetLineBoundingBox(int32_t * Line) {
    int32_t v1 = (int32_t)Line;
    int32_t v2 = *(int32_t *)(v1 + 64); // 0x80a241a
    int32_t v3 = *(int32_t *)(v1 + 36) + 1 + *(int32_t *)(v1 + 40); // 0x80a241d
    int32_t v4 = v3 + (int32_t)(v3 < 0) >> 1; // 0x80a242c
    int32_t * v5 = (int32_t *)(v1 + 44); // 0x80a242e
    int32_t v6 = *v5; // 0x80a242e
    int32_t v7 = v6 - v2; // 0x80a242e
    *Line = (v7 == 0 | v7 < 0 != ((v7 ^ v6) & (v6 ^ v2)) < 0 ? v6 : v2) - v4;
    int32_t v8 = *(int32_t *)(v1 + 68); // 0x80a2439
    int32_t v9 = *v5; // 0x80a243c
    int32_t v10 = v9 - v2; // 0x80a243c
    int32_t v11 = v10 < 0 == ((v10 ^ v9) & (v9 ^ v2)) < 0 ? v9 : v2; // 0x80a243f
    int32_t * v12 = (int32_t *)(v1 + 48); // 0x80a2443
    int32_t v13 = *v12; // 0x80a2443
    int32_t v14 = v13 - v8; // 0x80a2443
    int32_t v15 = v14 == 0 | v14 < 0 != ((v14 ^ v13) & (v13 ^ v8)) < 0 ? v13 : v8; // 0x80a2448
    int32_t v16 = v4 + 1;
    *(int32_t *)(v1 + 8) = v11 + v16;
    *(int32_t *)(v1 + 4) = v15 - v4;
    int32_t v17 = *v12; // 0x80a245a
    int32_t v18 = v17 - v8; // 0x80a245a
    int32_t v19 = v18 < 0 == ((v18 ^ v17) & (v17 ^ v8)) < 0 ? v17 : v8; // 0x80a245d
    *(int32_t *)(v1 + 72) = v2 + 1;
    *(int32_t *)(v1 + 12) = v19 + v16;
    *(int32_t *)(v1 + 76) = v8 + 1;
    *(int32_t *)(v1 + 52) = *v5 + 1;
    *(int32_t *)(v1 + 56) = *v12 + 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a24a0 - 0x80a2530
// Line range:    248 - 262
void SetPolygonBoundingBox(int32_t * Polygon2) {
    int32_t v1 = (int32_t)Polygon2;
    int32_t v2 = *(int32_t *)(v1 + 36); // 0x80a24ac
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x80a24af
    *v3 = 0x989680;
    *Polygon2 = 0x989680;
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x80a24bc
    *v4 = 0;
    int32_t * v5 = (int32_t *)(v1 + 8); // 0x80a24c9
    *v5 = 0;
    if (v2 == 0) {
        // 0x80a2528
        return;
    }
    int32_t v6 = v2; // 0x80a24eb
    int32_t v7 = 20 * v2 - 20 + *(int32_t *)(v1 + 56); // 0x80a24eb
    int32_t v8 = 0;
    int32_t v9 = 0;
    int32_t v10 = *(int32_t *)v7; // 0x80a24f2
    if (v10 < 0x989680) {
        // 0x80a24f8
        *Polygon2 = v10;
    }
    int32_t v11 = *(int32_t *)(v7 + 4); // 0x80a24fa
    if (v11 < *v3) {
        // 0x80a2502
        *v3 = v11;
    }
    // 0x80a2505
    v6--;
    int32_t v12 = v10 - v8; // 0x80a2505
    int32_t v13 = v11 - v9; // 0x80a250a
    int32_t v14 = (v12 < 0 == ((v12 ^ v10) & (v10 ^ v8)) < 0 ? v10 : v8) + 1; // 0x80a250f
    int32_t v15 = (v13 < 0 == ((v13 ^ v11) & (v11 ^ v9)) < 0 ? v11 : v9) + 1; // 0x80a2516
    while (v6 != 0) {
        // 0x80a24f0
        v7 -= 20;
        v8 = v14;
        v9 = v15;
        v10 = *(int32_t *)v7;
        if (v10 < *Polygon2) {
            // 0x80a24f8
            *Polygon2 = v10;
        }
        // 0x80a24fa
        v11 = *(int32_t *)(v7 + 4);
        if (v11 < *v3) {
            // 0x80a2502
            *v3 = v11;
        }
        // 0x80a2505
        v6--;
        v12 = v10 - v8;
        v13 = v11 - v9;
        v14 = (v12 < 0 == ((v12 ^ v10) & (v10 ^ v8)) < 0 ? v10 : v8) + 1;
        v15 = (v13 < 0 == ((v13 ^ v11) & (v11 ^ v9)) < 0 ? v11 : v9) + 1;
    }
    // 0x80a2522
    *v5 = v14;
    *v4 = v15;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2530 - 0x80a259c
// Line range:    491 - 504
char IsDataEmpty(int32_t * Data) {
    int32_t v1 = (int32_t)Data;
    int32_t result = (*(int32_t *)(v1 + 8) | *Data) == 0; // 0x80a2546
    uint32_t v2 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24) + 2; // 0x80a2557
    int32_t v3 = result; // 0x80a255a
    int32_t v4 = v1; // 0x80a255a
    if (v2 == 0) {
        // 0x80a2599
        return result;
    }
    int32_t v5 = 0; // 0x80a255a
    int32_t v6; // 0x80a2530
    int32_t v7; // 0x80a2530
    int32_t v8; // 0x80a2530
    while (true) {
      lab_0x80a2582_2:
        // 0x80a2582
        v8 = v5;
        v7 = v4;
        v6 = v3;
        if ((char)v3 == 0) {
            goto lab_0x80a2578;
        } else {
            // 0x80a2586
            if (*(int32_t *)(v7 + 80) == 0) {
                // 0x80a2560
                if (*(int32_t *)(v7 + 92) != 0) {
                    goto lab_0x80a258d;
                } else {
                    // 0x80a2567
                    if (*(int32_t *)(v7 + 84) != 0) {
                        goto lab_0x80a258d;
                    } else {
                        // 0x80a256e
                        v6 = *(int32_t *)(v7 + 88) == 0;
                        goto lab_0x80a2578;
                    }
                }
            } else {
                goto lab_0x80a258d;
            }
        }
    }
  lab_0x80a2599_2:;
    // 0x80a2599
    int32_t result2; // 0x80a2530
    return result2;
  lab_0x80a2578:;
    int32_t v9 = v8 + 1; // 0x80a2578
    v3 = v6;
    v5 = v9;
    result2 = v6;
    if (v9 >= v2) {
        // break -> 0x80a2599
        goto lab_0x80a2599_2;
    }
    goto lab_0x80a2582;
  lab_0x80a2582:
    // 0x80a2582
    v4 = v7 + 92;
    goto lab_0x80a2582_2;
  lab_0x80a258d:;
    int32_t v10 = v8 + 1; // 0x80a258d
    v3 = 0;
    v5 = v10;
    result2 = 0;
    if (v10 >= v2) {
        // break -> 0x80a2599
        goto lab_0x80a2599_2;
    }
    goto lab_0x80a2582;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a25d0 - 0x80a2a20
// Line range:    521 - 582
int32_t * GetDataBoundingBox(int32_t * Data) {
    int32_t v1 = (int32_t)Data;
    g76 = 0x989680;
    g75 = 0x989680;
    g78 = -0x989680;
    g77 = -0x989680;
    int32_t v2 = *Data; // 0x80a2604
    int32_t v3 = -0x989680; // 0x80a260b
    int32_t v4 = -0x989680; // 0x80a260b
    int32_t v5 = 0x989680; // 0x80a260b
    int32_t v6 = 0x989680; // 0x80a260b
    if (v2 != 0) {
        int32_t v7 = 0; // 0x80a2634
        int32_t v8 = *(int32_t *)(v1 + 28); // 0x80a2634
        int32_t v9 = 0x989680;
        int32_t v10 = 0x989680;
        int32_t v11 = -0x989680;
        int32_t v12 = -0x989680;
        int32_t v13 = *(int32_t *)(v8 + 36); // 0x80a2638
        int32_t v14 = *(int32_t *)(v8 + 52); // 0x80a2647
        int32_t v15 = v13 + (int32_t)(v13 < 0) >> 1; // 0x80a264a
        int32_t v16 = v14 - v15; // 0x80a264e
        int32_t v17 = v9 - v16; // 0x80a2651
        v6 = v17 < 0 == ((v17 ^ v9) & (v16 ^ v9)) < 0 == (v17 != 0) ? v16 : v9;
        int32_t v18 = *(int32_t *)(v8 + 56); // 0x80a2659
        int32_t v19 = v18 - v15; // 0x80a2659
        int32_t v20 = v10 - v19; // 0x80a265c
        v5 = v20 < 0 == ((v20 ^ v10) & (v19 ^ v10)) < 0 == (v20 != 0) ? v19 : v10;
        int32_t v21 = v15 + v14; // 0x80a2666
        int32_t v22 = v11 - v21; // 0x80a2669
        v4 = v22 < 0 == ((v22 ^ v11) & (v21 ^ v11)) < 0 ? v11 : v21;
        int32_t v23 = v15 + v18; // 0x80a266e
        int32_t v24 = v12 - v23; // 0x80a2671
        v3 = v24 < 0 == ((v24 ^ v12) & (v23 ^ v12)) < 0 ? v12 : v23;
        v7++;
        v8 += 76;
        while (v7 != v2) {
            // 0x80a2638
            v9 = v6;
            v10 = v5;
            v11 = v4;
            v12 = v3;
            v13 = *(int32_t *)(v8 + 36);
            v14 = *(int32_t *)(v8 + 52);
            v15 = v13 + (int32_t)(v13 < 0) >> 1;
            v16 = v14 - v15;
            v17 = v9 - v16;
            v6 = v17 < 0 == ((v17 ^ v9) & (v16 ^ v9)) < 0 == (v17 != 0) ? v16 : v9;
            v18 = *(int32_t *)(v8 + 56);
            v19 = v18 - v15;
            v20 = v10 - v19;
            v5 = v20 < 0 == ((v20 ^ v10) & (v19 ^ v10)) < 0 == (v20 != 0) ? v19 : v10;
            v21 = v15 + v14;
            v22 = v11 - v21;
            v4 = v22 < 0 == ((v22 ^ v11) & (v21 ^ v11)) < 0 ? v11 : v21;
            v23 = v15 + v18;
            v24 = v12 - v23;
            v3 = v24 < 0 == ((v24 ^ v12) & (v23 ^ v12)) < 0 ? v12 : v23;
            v7++;
            v8 += 76;
        }
        // 0x80a268a
        g75 = v6;
        g76 = v5;
        g77 = v4;
        g78 = v3;
    }
    int32_t v25 = *(int32_t *)(v1 + 8); // 0x80a26a5
    int32_t v26 = v3; // 0x80a26b1
    int32_t v27 = v6; // 0x80a26b1
    int32_t v28 = v4; // 0x80a26b1
    int32_t v29 = v5; // 0x80a26b1
    if (v25 != 0) {
        int32_t v30 = v25; // 0x80a26dd
        int32_t v31 = 300 * v25 - 300 + *(int32_t *)(v1 + 32); // 0x80a26dd
        int32_t v32 = v3;
        int32_t v33 = v6;
        int32_t v34 = v4;
        int32_t v35 = v5;
        v30--;
        int32_t v36 = *(int32_t *)v31; // 0x80a26e0
        int32_t v37 = v33 - v36; // 0x80a26e2
        int32_t v38 = v37 < 0 == ((v37 ^ v33) & (v36 ^ v33)) < 0 == (v37 != 0) ? v36 : v33; // 0x80a26e4
        int32_t v39 = *(int32_t *)(v31 + 96); // 0x80a26e7
        int32_t v40 = *(int32_t *)(v31 + 4); // 0x80a26ea
        int32_t v41 = v40 - v35; // 0x80a26ea
        int32_t v42 = v41 == 0 | v41 < 0 != ((v41 ^ v40) & (v40 ^ v35)) < 0 ? v40 : v35; // 0x80a26ed
        int32_t v43 = *(int32_t *)(v31 + 8); // 0x80a26f1
        int32_t v44 = v43 - v34; // 0x80a26f1
        int32_t v45 = v44 < 0 == ((v44 ^ v43) & (v43 ^ v34)) < 0 ? v43 : v34; // 0x80a26f4
        int32_t v46 = v38 - v39; // 0x80a26f8
        v27 = v46 < 0 == ((v46 ^ v38) & (v38 ^ v39)) < 0 == (v46 != 0) ? v39 : v38;
        int32_t v47 = *(int32_t *)(v31 + 100); // 0x80a26fd
        int32_t v48 = v42 - v47; // 0x80a2700
        v29 = v48 < 0 == ((v48 ^ v42) & (v42 ^ v47)) < 0 == (v48 != 0) ? v47 : v42;
        int32_t v49 = *(int32_t *)(v31 + 104); // 0x80a2705
        int32_t v50 = v45 - v49; // 0x80a2708
        v28 = v50 < 0 == ((v50 ^ v45) & (v45 ^ v49)) < 0 ? v45 : v49;
        int32_t v51 = *(int32_t *)(v31 + 12); // 0x80a270d
        int32_t v52 = *(int32_t *)(v31 + 108); // 0x80a2710
        int32_t v53 = v52 - v51; // 0x80a2710
        int32_t v54 = v53 < 0 == ((v53 ^ v52) & (v52 ^ v51)) < 0 ? v52 : v51; // 0x80a2713
        int32_t v55 = v32 - v54; // 0x80a2717
        v26 = v55 < 0 == ((v55 ^ v32) & (v54 ^ v32)) < 0 ? v32 : v54;
        v31 -= 300;
        while (v30 != 0) {
            // 0x80a26e0
            v32 = v26;
            v33 = v27;
            v34 = v28;
            v35 = v29;
            v30--;
            v36 = *(int32_t *)v31;
            v37 = v33 - v36;
            v38 = v37 < 0 == ((v37 ^ v33) & (v36 ^ v33)) < 0 == (v37 != 0) ? v36 : v33;
            v39 = *(int32_t *)(v31 + 96);
            v40 = *(int32_t *)(v31 + 4);
            v41 = v40 - v35;
            v42 = v41 == 0 | v41 < 0 != ((v41 ^ v40) & (v40 ^ v35)) < 0 ? v40 : v35;
            v43 = *(int32_t *)(v31 + 8);
            v44 = v43 - v34;
            v45 = v44 < 0 == ((v44 ^ v43) & (v43 ^ v34)) < 0 ? v43 : v34;
            v46 = v38 - v39;
            v27 = v46 < 0 == ((v46 ^ v38) & (v38 ^ v39)) < 0 == (v46 != 0) ? v39 : v38;
            v47 = *(int32_t *)(v31 + 100);
            v48 = v42 - v47;
            v29 = v48 < 0 == ((v48 ^ v42) & (v42 ^ v47)) < 0 == (v48 != 0) ? v47 : v42;
            v49 = *(int32_t *)(v31 + 104);
            v50 = v45 - v49;
            v28 = v50 < 0 == ((v50 ^ v45) & (v45 ^ v49)) < 0 ? v45 : v49;
            v51 = *(int32_t *)(v31 + 12);
            v52 = *(int32_t *)(v31 + 108);
            v53 = v52 - v51;
            v54 = v53 < 0 == ((v53 ^ v52) & (v52 ^ v51)) < 0 ? v52 : v51;
            v55 = v32 - v54;
            v26 = v55 < 0 == ((v55 ^ v32) & (v54 ^ v32)) < 0 ? v32 : v54;
            v31 -= 300;
        }
        // 0x80a272b
        g75 = v27;
        g76 = v29;
        g77 = v28;
        g78 = v26;
    }
    int32_t v56 = v1 + 76; // 0x80a2746
    int32_t v57 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24) + 2; // 0x80a275a
    int32_t v58 = 0; // 0x80a2760
    char v59; // 0x80a285f
    if (v57 == 0) {
        // 0x80a2859
        v59 = IsDataEmpty(Data);
        return v59 == 0 ? &g75 : NULL;
    }
    int32_t v60 = *(int32_t *)(v56 + 4); // 0x80a2793
    int32_t v61 = v29; // 0x80a279f
    int32_t v62 = v26; // 0x80a279f
    int32_t v63 = v28; // 0x80a279f
    int32_t v64 = v27; // 0x80a279f
    int32_t v65; // 0x80a25d0
    int32_t v66; // 0x80a25d0
    int32_t v67; // 0x80a25d0
    int32_t v68; // 0x80a25d0
    int32_t v69; // 0x80a25d0
    int32_t v70; // 0x80a25d0
    int32_t v71; // 0x80a27b0
    int32_t v72; // 0x80a27bf
    int32_t v73; // 0x80a27c1
    int32_t v74; // 0x80a27c5
    int32_t v75; // 0x80a27c8
    int32_t v76; // 0x80a27ca
    int32_t v77; // 0x80a27cd
    int32_t v78; // 0x80a27d0
    int32_t v79; // 0x80a27d3
    int32_t v80; // 0x80a27d5
    int32_t v81; // 0x80a27d8
    int32_t v82; // 0x80a27db
    int32_t v83; // 0x80a27de
    int32_t v84; // 0x80a27de
    int32_t v85; // 0x80a27e1
    int32_t v86; // 0x80a27e3
    int32_t v87; // 0x80a27e8
    int32_t v88; // 0x80a27eb
    int32_t v89; // 0x80a27f7
    int32_t v90; // 0x80a27fa
    int32_t v91; // 0x80a27fc
    int32_t v92; // 0x80a2802
    int32_t v93; // 0x80a2805
    int32_t v94; // 0x80a2807
    int32_t v95; // 0x80a280d
    int32_t v96; // 0x80a2810
    int32_t v97; // 0x80a2813
    int32_t v98; // 0x80a2815
    int32_t v99; // 0x80a2818
    int32_t v100; // 0x80a281a
    if (v60 != 0) {
        // 0x80a27a5
        v69 = v60;
        v67 = 88 * v60 - 44 + *(int32_t *)(v56 + 36);
        v66 = v27;
        v68 = v28;
        v65 = v26;
        v70 = v29;
        v69--;
        v71 = *(int32_t *)(v67 - 8);
        v72 = *(int32_t *)v67;
        v73 = v71 + (int32_t)(v71 < 0) >> 1;
        v74 = v72 - v73;
        v75 = v66 - v74;
        v76 = v75 < 0 == ((v75 ^ v66) & (v74 ^ v66)) < 0 == (v75 != 0) ? v74 : v66;
        v77 = *(int32_t *)(v67 + 20);
        v78 = v77 - v73;
        v79 = v76 - v78;
        v80 = v79 < 0 == ((v79 ^ v76) & (v76 ^ v78)) < 0 == (v79 != 0) ? v78 : v76;
        v81 = *(int32_t *)(v67 + 24);
        v82 = v81 - v73;
        v83 = *(int32_t *)(v67 + 4);
        v84 = v83 - v73;
        v85 = v82 - v84;
        v86 = v85 < 0 == ((v85 ^ v82) & (v84 ^ v82)) < 0 == (v85 != 0) ? v84 : v82;
        v87 = v70 - v86;
        v88 = v87 == 0 | v87 < 0 != ((v87 ^ v70) & (v86 ^ v70)) < 0 ? v70 : v86;
        v89 = v73 + v72;
        v90 = v89 - v68;
        v91 = v90 < 0 == ((v90 ^ v89) & (v89 ^ v68)) < 0 ? v89 : v68;
        v92 = v73 + v77;
        v93 = v91 - v92;
        v94 = v93 < 0 == ((v93 ^ v91) & (v91 ^ v92)) < 0 ? v91 : v92;
        v95 = v73 + v81;
        v96 = v83 + v73;
        v97 = v95 - v96;
        v98 = v97 < 0 == ((v97 ^ v95) & (v96 ^ v95)) < 0 ? v95 : v96;
        v99 = v65 - v98;
        v100 = v99 < 0 == ((v99 ^ v65) & (v98 ^ v65)) < 0 ? v65 : v98;
        v67 -= 88;
        v61 = v88;
        v62 = v100;
        v63 = v94;
        v64 = v80;
        while (v69 != 0) {
            // 0x80a27b0
            v66 = v80;
            v68 = v94;
            v65 = v100;
            v70 = v88;
            v69--;
            v71 = *(int32_t *)(v67 - 8);
            v72 = *(int32_t *)v67;
            v73 = v71 + (int32_t)(v71 < 0) >> 1;
            v74 = v72 - v73;
            v75 = v66 - v74;
            v76 = v75 < 0 == ((v75 ^ v66) & (v74 ^ v66)) < 0 == (v75 != 0) ? v74 : v66;
            v77 = *(int32_t *)(v67 + 20);
            v78 = v77 - v73;
            v79 = v76 - v78;
            v80 = v79 < 0 == ((v79 ^ v76) & (v76 ^ v78)) < 0 == (v79 != 0) ? v78 : v76;
            v81 = *(int32_t *)(v67 + 24);
            v82 = v81 - v73;
            v83 = *(int32_t *)(v67 + 4);
            v84 = v83 - v73;
            v85 = v82 - v84;
            v86 = v85 < 0 == ((v85 ^ v82) & (v84 ^ v82)) < 0 == (v85 != 0) ? v84 : v82;
            v87 = v70 - v86;
            v88 = v87 == 0 | v87 < 0 != ((v87 ^ v70) & (v86 ^ v70)) < 0 ? v70 : v86;
            v89 = v73 + v72;
            v90 = v89 - v68;
            v91 = v90 < 0 == ((v90 ^ v89) & (v89 ^ v68)) < 0 ? v89 : v68;
            v92 = v73 + v77;
            v93 = v91 - v92;
            v94 = v93 < 0 == ((v93 ^ v91) & (v91 ^ v92)) < 0 ? v91 : v92;
            v95 = v73 + v81;
            v96 = v83 + v73;
            v97 = v95 - v96;
            v98 = v97 < 0 == ((v97 ^ v95) & (v96 ^ v95)) < 0 ? v95 : v96;
            v99 = v65 - v98;
            v100 = v99 < 0 == ((v99 ^ v65) & (v98 ^ v65)) < 0 ? v65 : v98;
            v67 -= 88;
            v61 = v88;
            v62 = v100;
            v63 = v94;
            v64 = v80;
        }
    }
    int32_t v101 = v64;
    int32_t v102 = v63;
    int32_t v103 = v62;
    int32_t v104 = v61;
    v58++;
    int32_t v105 = v56 + 92; // 0x80a2834
    while (v58 != v57) {
        int32_t v106 = v101;
        int32_t v107 = v102;
        int32_t v108 = v103;
        int32_t v109 = v105;
        int32_t v110 = v104;
        v60 = *(int32_t *)(v109 + 4);
        v61 = v110;
        v62 = v108;
        v63 = v107;
        v64 = v106;
        if (v60 != 0) {
            // 0x80a27a5
            v69 = v60;
            v67 = 88 * v60 - 44 + *(int32_t *)(v109 + 36);
            v66 = v106;
            v68 = v107;
            v65 = v108;
            v70 = v110;
            v69--;
            v71 = *(int32_t *)(v67 - 8);
            v72 = *(int32_t *)v67;
            v73 = v71 + (int32_t)(v71 < 0) >> 1;
            v74 = v72 - v73;
            v75 = v66 - v74;
            v76 = v75 < 0 == ((v75 ^ v66) & (v74 ^ v66)) < 0 == (v75 != 0) ? v74 : v66;
            v77 = *(int32_t *)(v67 + 20);
            v78 = v77 - v73;
            v79 = v76 - v78;
            v80 = v79 < 0 == ((v79 ^ v76) & (v76 ^ v78)) < 0 == (v79 != 0) ? v78 : v76;
            v81 = *(int32_t *)(v67 + 24);
            v82 = v81 - v73;
            v83 = *(int32_t *)(v67 + 4);
            v84 = v83 - v73;
            v85 = v82 - v84;
            v86 = v85 < 0 == ((v85 ^ v82) & (v84 ^ v82)) < 0 == (v85 != 0) ? v84 : v82;
            v87 = v70 - v86;
            v88 = v87 == 0 | v87 < 0 != ((v87 ^ v70) & (v86 ^ v70)) < 0 ? v70 : v86;
            v89 = v73 + v72;
            v90 = v89 - v68;
            v91 = v90 < 0 == ((v90 ^ v89) & (v89 ^ v68)) < 0 ? v89 : v68;
            v92 = v73 + v77;
            v93 = v91 - v92;
            v94 = v93 < 0 == ((v93 ^ v91) & (v91 ^ v92)) < 0 ? v91 : v92;
            v95 = v73 + v81;
            v96 = v83 + v73;
            v97 = v95 - v96;
            v98 = v97 < 0 == ((v97 ^ v95) & (v96 ^ v95)) < 0 ? v95 : v96;
            v99 = v65 - v98;
            v100 = v99 < 0 == ((v99 ^ v65) & (v98 ^ v65)) < 0 ? v65 : v98;
            v67 -= 88;
            v61 = v88;
            v62 = v100;
            v63 = v94;
            v64 = v80;
            while (v69 != 0) {
                // 0x80a27b0
                v66 = v80;
                v68 = v94;
                v65 = v100;
                v70 = v88;
                v69--;
                v71 = *(int32_t *)(v67 - 8);
                v72 = *(int32_t *)v67;
                v73 = v71 + (int32_t)(v71 < 0) >> 1;
                v74 = v72 - v73;
                v75 = v66 - v74;
                v76 = v75 < 0 == ((v75 ^ v66) & (v74 ^ v66)) < 0 == (v75 != 0) ? v74 : v66;
                v77 = *(int32_t *)(v67 + 20);
                v78 = v77 - v73;
                v79 = v76 - v78;
                v80 = v79 < 0 == ((v79 ^ v76) & (v76 ^ v78)) < 0 == (v79 != 0) ? v78 : v76;
                v81 = *(int32_t *)(v67 + 24);
                v82 = v81 - v73;
                v83 = *(int32_t *)(v67 + 4);
                v84 = v83 - v73;
                v85 = v82 - v84;
                v86 = v85 < 0 == ((v85 ^ v82) & (v84 ^ v82)) < 0 == (v85 != 0) ? v84 : v82;
                v87 = v70 - v86;
                v88 = v87 == 0 | v87 < 0 != ((v87 ^ v70) & (v86 ^ v70)) < 0 ? v70 : v86;
                v89 = v73 + v72;
                v90 = v89 - v68;
                v91 = v90 < 0 == ((v90 ^ v89) & (v89 ^ v68)) < 0 ? v89 : v68;
                v92 = v73 + v77;
                v93 = v91 - v92;
                v94 = v93 < 0 == ((v93 ^ v91) & (v91 ^ v92)) < 0 ? v91 : v92;
                v95 = v73 + v81;
                v96 = v83 + v73;
                v97 = v95 - v96;
                v98 = v97 < 0 == ((v97 ^ v95) & (v96 ^ v95)) < 0 ? v95 : v96;
                v99 = v65 - v98;
                v100 = v99 < 0 == ((v99 ^ v65) & (v98 ^ v65)) < 0 ? v65 : v98;
                v67 -= 88;
                v61 = v88;
                v62 = v100;
                v63 = v94;
                v64 = v80;
            }
        }
        // 0x80a282a
        v101 = v64;
        v102 = v63;
        v103 = v62;
        v104 = v61;
        v58++;
        v105 = v109 + 92;
    }
    // 0x80a287a
    g77 = v102;
    g75 = v101;
    g76 = v104;
    g78 = v103;
    int32_t v111 = 0; // 0x80a28a5
    int32_t v112 = *(int32_t *)(v56 + 16); // 0x80a28ab
    int32_t v113 = v103; // 0x80a28b9
    int32_t v114 = v102; // 0x80a28b9
    int32_t v115 = v104; // 0x80a28b9
    int32_t v116 = v101; // 0x80a28b9
    int32_t v117; // 0x80a25d0
    int32_t v118; // 0x80a25d0
    int32_t v119; // 0x80a25d0
    int32_t v120; // 0x80a25d0
    int32_t v121; // 0x80a25d0
    int32_t v122; // 0x80a25d0
    int32_t v123; // 0x80a28eb
    int32_t v124; // 0x80a28ee
    int32_t v125; // 0x80a28d8
    int32_t v126; // 0x80a28d8
    int32_t v127; // 0x80a28da
    int32_t v128; // 0x80a28dd
    int32_t v129; // 0x80a28dd
    int32_t v130; // 0x80a28e0
    int32_t v131; // 0x80a28e4
    int32_t v132; // 0x80a28e4
    int32_t v133; // 0x80a28e7
    int32_t v134; // 0x80a28eb
    if (v112 != 0) {
        // 0x80a28bb
        v122 = v112;
        v120 = 68 * v112 - 68 + *(int32_t *)(v56 + 48);
        v119 = v101;
        v121 = v104;
        v118 = v102;
        v117 = v103;
        v122--;
        v125 = *(int32_t *)v120;
        v126 = v119 - v125;
        v127 = v126 < 0 == ((v126 ^ v119) & (v125 ^ v119)) < 0 == (v126 != 0) ? v125 : v119;
        v128 = *(int32_t *)(v120 + 4);
        v129 = v121 - v128;
        v130 = v129 < 0 == ((v129 ^ v121) & (v128 ^ v121)) < 0 == (v129 != 0) ? v128 : v121;
        v131 = *(int32_t *)(v120 + 8);
        v132 = v118 - v131;
        v133 = v132 < 0 == ((v132 ^ v118) & (v131 ^ v118)) < 0 ? v118 : v131;
        v134 = *(int32_t *)(v120 + 12);
        v123 = v117 - v134;
        v124 = v123 < 0 == ((v123 ^ v117) & (v134 ^ v117)) < 0 ? v117 : v134;
        v120 -= 68;
        v113 = v124;
        v114 = v133;
        v115 = v130;
        v116 = v127;
        while (v122 != 0) {
            // 0x80a28d8
            v119 = v127;
            v121 = v130;
            v118 = v133;
            v117 = v124;
            v122--;
            v125 = *(int32_t *)v120;
            v126 = v119 - v125;
            v127 = v126 < 0 == ((v126 ^ v119) & (v125 ^ v119)) < 0 == (v126 != 0) ? v125 : v119;
            v128 = *(int32_t *)(v120 + 4);
            v129 = v121 - v128;
            v130 = v129 < 0 == ((v129 ^ v121) & (v128 ^ v121)) < 0 == (v129 != 0) ? v128 : v121;
            v131 = *(int32_t *)(v120 + 8);
            v132 = v118 - v131;
            v133 = v132 < 0 == ((v132 ^ v118) & (v131 ^ v118)) < 0 ? v118 : v131;
            v134 = *(int32_t *)(v120 + 12);
            v123 = v117 - v134;
            v124 = v123 < 0 == ((v123 ^ v117) & (v134 ^ v117)) < 0 ? v117 : v134;
            v120 -= 68;
            v113 = v124;
            v114 = v133;
            v115 = v130;
            v116 = v127;
        }
    }
    int32_t v135 = v116;
    int32_t v136 = v115;
    int32_t v137 = v114;
    int32_t v138 = v113;
    v111++;
    int32_t v139 = v56 + 92; // 0x80a290c
    while (v111 != v57) {
        int32_t v140 = v135;
        int32_t v141 = v136;
        int32_t v142 = v137;
        int32_t v143 = v139;
        int32_t v144 = v138;
        v112 = *(int32_t *)(v143 + 16);
        v113 = v144;
        v114 = v142;
        v115 = v141;
        v116 = v140;
        if (v112 != 0) {
            // 0x80a28bb
            v122 = v112;
            v120 = 68 * v112 - 68 + *(int32_t *)(v143 + 48);
            v119 = v140;
            v121 = v141;
            v118 = v142;
            v117 = v144;
            v122--;
            v125 = *(int32_t *)v120;
            v126 = v119 - v125;
            v127 = v126 < 0 == ((v126 ^ v119) & (v125 ^ v119)) < 0 == (v126 != 0) ? v125 : v119;
            v128 = *(int32_t *)(v120 + 4);
            v129 = v121 - v128;
            v130 = v129 < 0 == ((v129 ^ v121) & (v128 ^ v121)) < 0 == (v129 != 0) ? v128 : v121;
            v131 = *(int32_t *)(v120 + 8);
            v132 = v118 - v131;
            v133 = v132 < 0 == ((v132 ^ v118) & (v131 ^ v118)) < 0 ? v118 : v131;
            v134 = *(int32_t *)(v120 + 12);
            v123 = v117 - v134;
            v124 = v123 < 0 == ((v123 ^ v117) & (v134 ^ v117)) < 0 ? v117 : v134;
            v120 -= 68;
            v113 = v124;
            v114 = v133;
            v115 = v130;
            v116 = v127;
            while (v122 != 0) {
                // 0x80a28d8
                v119 = v127;
                v121 = v130;
                v118 = v133;
                v117 = v124;
                v122--;
                v125 = *(int32_t *)v120;
                v126 = v119 - v125;
                v127 = v126 < 0 == ((v126 ^ v119) & (v125 ^ v119)) < 0 == (v126 != 0) ? v125 : v119;
                v128 = *(int32_t *)(v120 + 4);
                v129 = v121 - v128;
                v130 = v129 < 0 == ((v129 ^ v121) & (v128 ^ v121)) < 0 == (v129 != 0) ? v128 : v121;
                v131 = *(int32_t *)(v120 + 8);
                v132 = v118 - v131;
                v133 = v132 < 0 == ((v132 ^ v118) & (v131 ^ v118)) < 0 ? v118 : v131;
                v134 = *(int32_t *)(v120 + 12);
                v123 = v117 - v134;
                v124 = v123 < 0 == ((v123 ^ v117) & (v134 ^ v117)) < 0 ? v117 : v134;
                v120 -= 68;
                v113 = v124;
                v114 = v133;
                v115 = v130;
                v116 = v127;
            }
        }
        // 0x80a2902
        v135 = v116;
        v136 = v115;
        v137 = v114;
        v138 = v113;
        v111++;
        v139 = v143 + 92;
    }
    // 0x80a2914
    g75 = v135;
    g76 = v136;
    g77 = v137;
    g78 = v138;
    int32_t v145 = 0; // 0x80a293e
    int32_t v146 = *(int32_t *)(v56 + 8); // 0x80a2943
    int32_t v147 = v138; // 0x80a294c
    int32_t v148 = v137; // 0x80a294c
    int32_t v149 = v136; // 0x80a294c
    int32_t v150 = v135; // 0x80a294c
    int32_t v151; // 0x80a25d0
    int32_t v152; // 0x80a25d0
    int32_t v153; // 0x80a25d0
    int32_t v154; // 0x80a25d0
    int32_t v155; // 0x80a25d0
    int32_t v156; // 0x80a25d0
    int32_t v157; // 0x80a2960
    int32_t v158; // 0x80a2960
    int32_t v159; // 0x80a2962
    int32_t v160; // 0x80a2965
    int32_t v161; // 0x80a2965
    int32_t v162; // 0x80a2968
    int32_t v163; // 0x80a296c
    int32_t v164; // 0x80a296c
    int32_t v165; // 0x80a296f
    int32_t v166; // 0x80a2973
    int32_t v167; // 0x80a2973
    int32_t v168; // 0x80a2976
    if (v146 != 0) {
        // 0x80a294e
        v156 = v146;
        v154 = 60 * v146 - 60 + *(int32_t *)(v56 + 40);
        v153 = v135;
        v155 = v136;
        v152 = v137;
        v151 = v138;
        v156--;
        v157 = *(int32_t *)v154;
        v158 = v153 - v157;
        v159 = v158 < 0 == ((v158 ^ v153) & (v157 ^ v153)) < 0 == (v158 != 0) ? v157 : v153;
        v160 = *(int32_t *)(v154 + 4);
        v161 = v155 - v160;
        v162 = v161 < 0 == ((v161 ^ v155) & (v160 ^ v155)) < 0 == (v161 != 0) ? v160 : v155;
        v163 = *(int32_t *)(v154 + 8);
        v164 = v152 - v163;
        v165 = v164 < 0 == ((v164 ^ v152) & (v163 ^ v152)) < 0 ? v152 : v163;
        v166 = *(int32_t *)(v154 + 12);
        v167 = v151 - v166;
        v168 = v167 < 0 == ((v167 ^ v151) & (v166 ^ v151)) < 0 ? v151 : v166;
        v154 -= 60;
        v147 = v168;
        v148 = v165;
        v149 = v162;
        v150 = v159;
        while (v156 != 0) {
            // 0x80a2960
            v153 = v159;
            v155 = v162;
            v152 = v165;
            v151 = v168;
            v156--;
            v157 = *(int32_t *)v154;
            v158 = v153 - v157;
            v159 = v158 < 0 == ((v158 ^ v153) & (v157 ^ v153)) < 0 == (v158 != 0) ? v157 : v153;
            v160 = *(int32_t *)(v154 + 4);
            v161 = v155 - v160;
            v162 = v161 < 0 == ((v161 ^ v155) & (v160 ^ v155)) < 0 == (v161 != 0) ? v160 : v155;
            v163 = *(int32_t *)(v154 + 8);
            v164 = v152 - v163;
            v165 = v164 < 0 == ((v164 ^ v152) & (v163 ^ v152)) < 0 ? v152 : v163;
            v166 = *(int32_t *)(v154 + 12);
            v167 = v151 - v166;
            v168 = v167 < 0 == ((v167 ^ v151) & (v166 ^ v151)) < 0 ? v151 : v166;
            v154 -= 60;
            v147 = v168;
            v148 = v165;
            v149 = v162;
            v150 = v159;
        }
    }
    int32_t v169 = v150;
    int32_t v170 = v149;
    int32_t v171 = v148;
    int32_t v172 = v147;
    v145++;
    int32_t v173 = v56 + 92; // 0x80a2994
    while (v145 != v57) {
        int32_t v174 = v169;
        int32_t v175 = v170;
        int32_t v176 = v171;
        int32_t v177 = v173;
        int32_t v178 = v172;
        v146 = *(int32_t *)(v177 + 8);
        v147 = v178;
        v148 = v176;
        v149 = v175;
        v150 = v174;
        if (v146 != 0) {
            // 0x80a294e
            v156 = v146;
            v154 = 60 * v146 - 60 + *(int32_t *)(v177 + 40);
            v153 = v174;
            v155 = v175;
            v152 = v176;
            v151 = v178;
            v156--;
            v157 = *(int32_t *)v154;
            v158 = v153 - v157;
            v159 = v158 < 0 == ((v158 ^ v153) & (v157 ^ v153)) < 0 == (v158 != 0) ? v157 : v153;
            v160 = *(int32_t *)(v154 + 4);
            v161 = v155 - v160;
            v162 = v161 < 0 == ((v161 ^ v155) & (v160 ^ v155)) < 0 == (v161 != 0) ? v160 : v155;
            v163 = *(int32_t *)(v154 + 8);
            v164 = v152 - v163;
            v165 = v164 < 0 == ((v164 ^ v152) & (v163 ^ v152)) < 0 ? v152 : v163;
            v166 = *(int32_t *)(v154 + 12);
            v167 = v151 - v166;
            v168 = v167 < 0 == ((v167 ^ v151) & (v166 ^ v151)) < 0 ? v151 : v166;
            v154 -= 60;
            v147 = v168;
            v148 = v165;
            v149 = v162;
            v150 = v159;
            while (v156 != 0) {
                // 0x80a2960
                v153 = v159;
                v155 = v162;
                v152 = v165;
                v151 = v168;
                v156--;
                v157 = *(int32_t *)v154;
                v158 = v153 - v157;
                v159 = v158 < 0 == ((v158 ^ v153) & (v157 ^ v153)) < 0 == (v158 != 0) ? v157 : v153;
                v160 = *(int32_t *)(v154 + 4);
                v161 = v155 - v160;
                v162 = v161 < 0 == ((v161 ^ v155) & (v160 ^ v155)) < 0 == (v161 != 0) ? v160 : v155;
                v163 = *(int32_t *)(v154 + 8);
                v164 = v152 - v163;
                v165 = v164 < 0 == ((v164 ^ v152) & (v163 ^ v152)) < 0 ? v152 : v163;
                v166 = *(int32_t *)(v154 + 12);
                v167 = v151 - v166;
                v168 = v167 < 0 == ((v167 ^ v151) & (v166 ^ v151)) < 0 ? v151 : v166;
                v154 -= 60;
                v147 = v168;
                v148 = v165;
                v149 = v162;
                v150 = v159;
            }
        }
        // 0x80a298a
        v169 = v150;
        v170 = v149;
        v171 = v148;
        v172 = v147;
        v145++;
        v173 = v177 + 92;
    }
    // 0x80a299c
    g75 = v169;
    g76 = v170;
    g77 = v171;
    g78 = v172;
    int32_t v179 = 0; // 0x80a29bd
    int32_t v180 = *(int32_t *)(v56 + 12); // 0x80a29c3
    int32_t v181 = v172; // 0x80a29cc
    int32_t v182 = v171; // 0x80a29cc
    int32_t v183 = v170; // 0x80a29cc
    int32_t v184 = v169; // 0x80a29cc
    int32_t v185; // 0x80a25d0
    int32_t v186; // 0x80a25d0
    int32_t v187; // 0x80a25d0
    int32_t v188; // 0x80a25d0
    int32_t v189; // 0x80a25d0
    int32_t v190; // 0x80a25d0
    int32_t v191; // 0x80a29e0
    int32_t v192; // 0x80a29e0
    int32_t v193; // 0x80a29e2
    int32_t v194; // 0x80a29e5
    int32_t v195; // 0x80a29e5
    int32_t v196; // 0x80a29e8
    int32_t v197; // 0x80a29ec
    int32_t v198; // 0x80a29ec
    int32_t v199; // 0x80a29ef
    int32_t v200; // 0x80a29f3
    int32_t v201; // 0x80a29f3
    int32_t v202; // 0x80a29f6
    if (v180 != 0) {
        // 0x80a29ce
        v190 = v180;
        v188 = 60 * v180 - 60 + *(int32_t *)(v56 + 44);
        v187 = v169;
        v189 = v170;
        v186 = v171;
        v185 = v172;
        v190--;
        v191 = *(int32_t *)v188;
        v192 = v187 - v191;
        v193 = v192 < 0 == ((v192 ^ v187) & (v191 ^ v187)) < 0 == (v192 != 0) ? v191 : v187;
        v194 = *(int32_t *)(v188 + 4);
        v195 = v189 - v194;
        v196 = v195 < 0 == ((v195 ^ v189) & (v194 ^ v189)) < 0 == (v195 != 0) ? v194 : v189;
        v197 = *(int32_t *)(v188 + 8);
        v198 = v186 - v197;
        v199 = v198 < 0 == ((v198 ^ v186) & (v197 ^ v186)) < 0 ? v186 : v197;
        v200 = *(int32_t *)(v188 + 12);
        v201 = v185 - v200;
        v202 = v201 < 0 == ((v201 ^ v185) & (v200 ^ v185)) < 0 ? v185 : v200;
        v188 -= 60;
        v181 = v202;
        v182 = v199;
        v183 = v196;
        v184 = v193;
        while (v190 != 0) {
            // 0x80a29e0
            v187 = v193;
            v189 = v196;
            v186 = v199;
            v185 = v202;
            v190--;
            v191 = *(int32_t *)v188;
            v192 = v187 - v191;
            v193 = v192 < 0 == ((v192 ^ v187) & (v191 ^ v187)) < 0 == (v192 != 0) ? v191 : v187;
            v194 = *(int32_t *)(v188 + 4);
            v195 = v189 - v194;
            v196 = v195 < 0 == ((v195 ^ v189) & (v194 ^ v189)) < 0 == (v195 != 0) ? v194 : v189;
            v197 = *(int32_t *)(v188 + 8);
            v198 = v186 - v197;
            v199 = v198 < 0 == ((v198 ^ v186) & (v197 ^ v186)) < 0 ? v186 : v197;
            v200 = *(int32_t *)(v188 + 12);
            v201 = v185 - v200;
            v202 = v201 < 0 == ((v201 ^ v185) & (v200 ^ v185)) < 0 ? v185 : v200;
            v188 -= 60;
            v181 = v202;
            v182 = v199;
            v183 = v196;
            v184 = v193;
        }
    }
    int32_t v203 = v184;
    int32_t v204 = v183;
    int32_t v205 = v182;
    int32_t v206 = v181;
    v179++;
    int32_t v207 = v56 + 92; // 0x80a2a14
    while (v179 != v57) {
        int32_t v208 = v203;
        int32_t v209 = v204;
        int32_t v210 = v205;
        int32_t v211 = v207;
        int32_t v212 = v206;
        v180 = *(int32_t *)(v211 + 12);
        v181 = v212;
        v182 = v210;
        v183 = v209;
        v184 = v208;
        if (v180 != 0) {
            // 0x80a29ce
            v190 = v180;
            v188 = 60 * v180 - 60 + *(int32_t *)(v211 + 44);
            v187 = v208;
            v189 = v209;
            v186 = v210;
            v185 = v212;
            v190--;
            v191 = *(int32_t *)v188;
            v192 = v187 - v191;
            v193 = v192 < 0 == ((v192 ^ v187) & (v191 ^ v187)) < 0 == (v192 != 0) ? v191 : v187;
            v194 = *(int32_t *)(v188 + 4);
            v195 = v189 - v194;
            v196 = v195 < 0 == ((v195 ^ v189) & (v194 ^ v189)) < 0 == (v195 != 0) ? v194 : v189;
            v197 = *(int32_t *)(v188 + 8);
            v198 = v186 - v197;
            v199 = v198 < 0 == ((v198 ^ v186) & (v197 ^ v186)) < 0 ? v186 : v197;
            v200 = *(int32_t *)(v188 + 12);
            v201 = v185 - v200;
            v202 = v201 < 0 == ((v201 ^ v185) & (v200 ^ v185)) < 0 ? v185 : v200;
            v188 -= 60;
            v181 = v202;
            v182 = v199;
            v183 = v196;
            v184 = v193;
            while (v190 != 0) {
                // 0x80a29e0
                v187 = v193;
                v189 = v196;
                v186 = v199;
                v185 = v202;
                v190--;
                v191 = *(int32_t *)v188;
                v192 = v187 - v191;
                v193 = v192 < 0 == ((v192 ^ v187) & (v191 ^ v187)) < 0 == (v192 != 0) ? v191 : v187;
                v194 = *(int32_t *)(v188 + 4);
                v195 = v189 - v194;
                v196 = v195 < 0 == ((v195 ^ v189) & (v194 ^ v189)) < 0 == (v195 != 0) ? v194 : v189;
                v197 = *(int32_t *)(v188 + 8);
                v198 = v186 - v197;
                v199 = v198 < 0 == ((v198 ^ v186) & (v197 ^ v186)) < 0 ? v186 : v197;
                v200 = *(int32_t *)(v188 + 12);
                v201 = v185 - v200;
                v202 = v201 < 0 == ((v201 ^ v185) & (v200 ^ v185)) < 0 ? v185 : v200;
                v188 -= 60;
                v181 = v202;
                v182 = v199;
                v183 = v196;
                v184 = v193;
            }
        }
        // 0x80a2a0a
        v203 = v184;
        v204 = v183;
        v205 = v182;
        v206 = v181;
        v179++;
        v207 = v211 + 92;
    }
    // 0x80a283f
    g75 = v203;
    g76 = v204;
    g77 = v205;
    g78 = v206;
    // 0x80a2859
    v59 = IsDataEmpty(Data);
    return v59 == 0 ? &g75 : NULL;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2a20 - 0x80a2bdf
// Line range:    625 - 687
void SetFontInfo(int32_t * Ptr) {
    int32_t v1 = (int32_t)Ptr;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80a2a3b
    *v2 = 50;
    *Ptr = 50;
    int32_t v3 = v1 + 24; // 0x80a2a48
    int32_t v4 = v1 + 28; // 0x80a2a56
    int32_t * v5 = NULL; // 0x80a2a4e
    int32_t v6 = 0x989680; // 0x80a2a4e
    int32_t v7; // 0x80a2a20
    int32_t v8; // 0x80a2a20
    int32_t v9; // 0x80a2a20
    int32_t v10; // 0x80a2a20
    int32_t * v11; // 0x80a2a20
    int32_t v12; // 0x80a2ab5
    int32_t v13; // 0x80a2ac7
    int32_t v14; // 0x80a2ad3
    int32_t v15; // 0x80a2adf
    int32_t v16; // 0x80a2a53
    int32_t v17; // 0x80a2a20
    while (true) {
      lab_0x80a2a50:
        // 0x80a2a50
        v9 = v6;
        v11 = v5;
        v16 = (int32_t)v11;
        v10 = v9;
        if (*(char *)(v4 + v16) == 0) {
            goto lab_0x80a2b5b;
        } else {
            // 0x80a2a61
            v17 = v16 + v1;
            int32_t v18 = *(int32_t *)(v17 + 32); // 0x80a2a61
            v10 = v9;
            if (v18 == 0) {
                goto lab_0x80a2b5b;
            } else {
                int32_t v19 = *(int32_t *)(v3 + v16); // 0x80a2a70
                int32_t v20 = 0; // 0x80a2a9c
                int32_t v21 = 0; // 0x80a2a9c
                int32_t v22 = v18; // 0x80a2a9c
                int32_t v23 = 0x989680; // 0x80a2a9c
                int32_t v24 = 0x989680; // 0x80a2a9c
                int32_t v25 = v19; // 0x80a2a9c
                while (true) {
                    int32_t v26 = v24;
                    int32_t v27 = v23;
                    int32_t v28 = v21;
                    int32_t v29 = v20;
                    int32_t v30 = *(int32_t *)(v25 + 44); // 0x80a2aa0
                    int32_t v31 = *(int32_t *)(v25 + 64); // 0x80a2aa3
                    int32_t v32 = *(int32_t *)(v25 + 48); // 0x80a2aa6
                    int32_t v33 = v31 - v30; // 0x80a2aab
                    int32_t v34 = v33 == 0 | v33 < 0 != ((v33 ^ v31) & (v31 ^ v30)) < 0 ? v31 : v30; // 0x80a2aad
                    int32_t v35 = v26 - v34; // 0x80a2ab2
                    v12 = v35 == 0 | v35 < 0 != ((v35 ^ v26) & (v34 ^ v26)) < 0 ? v26 : v34;
                    int32_t v36 = *(int32_t *)(v25 + 68); // 0x80a2abc
                    int32_t v37 = v36 - v32; // 0x80a2abf
                    int32_t v38 = v37 == 0 | v37 < 0 != ((v37 ^ v36) & (v36 ^ v32)) < 0 ? v36 : v32; // 0x80a2ac1
                    int32_t v39 = v27 - v38; // 0x80a2ac4
                    v13 = v39 == 0 | v39 < 0 != ((v39 ^ v27) & (v38 ^ v27)) < 0 ? v27 : v38;
                    int32_t v40 = v33 < 0 == ((v33 ^ v31) & (v31 ^ v30)) < 0 ? v31 : v30; // 0x80a2acd
                    int32_t v41 = v28 - v40; // 0x80a2ad0
                    v14 = v41 < 0 == ((v41 ^ v28) & (v40 ^ v28)) < 0 ? v28 : v40;
                    int32_t v42 = v37 < 0 == ((v37 ^ v36) & (v36 ^ v32)) < 0 ? v36 : v32; // 0x80a2ad9
                    int32_t v43 = v29 - v42; // 0x80a2adc
                    v15 = v43 < 0 == ((v43 ^ v29) & (v42 ^ v29)) < 0 ? v29 : v42;
                    v22--;
                    v20 = v15;
                    v21 = v14;
                    v23 = v13;
                    v24 = v12;
                    v25 += 88;
                    v7 = v19;
                    v8 = v18;
                    if (v22 == 0) {
                        goto lab_0x80a2b00;
                    }
                }
                goto lab_0x80a2b16;
            }
        }
    }
  lab_0x80a2b78:;
    int32_t v44; // 0x80a2a20
    while (true) {
        int32_t v45 = v44;
        if (*(char *)(v45 + v4) != 0) {
            int32_t v46 = v45 + v1;
            int32_t v47 = *(int32_t *)(v46 + 32); // 0x80a2b87
            int32_t * v48 = (int32_t *)(v46 + 44); // 0x80a2b8b
            *v48 = *v48 - v6;
            if (v47 != 0) {
                int32_t v49 = *(int32_t *)(v45 + v3); // 0x80a2a20
                int32_t v50 = v47; // 0x80a2ba9
                int32_t * v51 = (int32_t *)(v49 + 48); // 0x80a2b98
                *v51 = *v51 - v6;
                int32_t * v52 = (int32_t *)(v49 + 68); // 0x80a2b9b
                *v52 = *v52 - v6;
                SetLineBoundingBox((int32_t *)v49);
                v50--;
                v49 += 88;
                while (v50 != 0) {
                    // 0x80a2b98
                    v51 = (int32_t *)(v49 + 48);
                    *v51 = *v51 - v6;
                    v52 = (int32_t *)(v49 + 68);
                    *v52 = *v52 - v6;
                    SetLineBoundingBox((int32_t *)v49);
                    v50--;
                    v49 += 88;
                }
            }
        }
        // 0x80a2bae
        v44 = v45 + 28;
        if (v45 == 0x1be4) {
            // break -> 0x80a2bbb
            break;
        }
    }
    // 0x80a2bbb
    *(int32_t *)(v1 + 12) = 0;
    *(int32_t *)(v1 + 8) = 0;
    *(int32_t *)(v1 + 16) = *v2;
    *(int32_t *)(v1 + 20) = *Ptr;
  lab_0x80a2b00:;
    int32_t * v53 = (int32_t *)(v7 + 44); // 0x80a2b00
    *v53 = *v53 - v12;
    int32_t * v54 = (int32_t *)(v7 + 64); // 0x80a2b03
    *v54 = *v54 - v12;
    SetLineBoundingBox((int32_t *)v7);
    int32_t v55 = v8 - 1; // 0x80a2b11
    v7 += 88;
    v8 = v55;
    if (v55 != 0) {
        goto lab_0x80a2b00;
    } else {
        goto lab_0x80a2b16;
    }
  lab_0x80a2b5b:
    // 0x80a2b5b
    v6 = v10;
    v5 = (int32_t *)(v16 + 28);
    v44 = 0;
    if (v11 == (int32_t *)0x1be4) {
        // break -> 0x80a2b78
        goto lab_0x80a2b78;
    }
    goto lab_0x80a2a50;
  lab_0x80a2b16:;
    int32_t v56 = v14 + 1 - v12; // 0x80a2b25
    *(int32_t *)(v17 + 40) = v56;
    int32_t * v57 = (int32_t *)(v17 + 44); // 0x80a2b2e
    *v57 = v15 + 1;
    int32_t v58 = *v2; // 0x80a2b35
    int32_t v59 = v56 - v58; // 0x80a2b38
    *v2 = v59 < 0 == ((v59 ^ v56) & (v58 ^ v56)) < 0 ? v56 : v58;
    int32_t v60 = *v57; // 0x80a2b43
    int32_t v61 = *Ptr; // 0x80a2b47
    int32_t v62 = v61 - v60; // 0x80a2b47
    *Ptr = v62 < 0 == ((v62 ^ v61) & (v61 ^ v60)) < 0 ? v61 : v60;
    int32_t v63 = v9 - v13; // 0x80a2b51
    int32_t v64 = v63 == 0 | v63 < 0 != ((v63 ^ v9) & (v13 ^ v9)) < 0 ? v9 : v13; // 0x80a2b54
    v10 = v64;
    goto lab_0x80a2b5b;
}

// Address range: 0x80a2be0 - 0x80a2c06
int32_t GetLayerNumber(int32_t a1, int32_t a2) {
    int32_t v1 = 0;
    int32_t result = v1; // 0x80a2bf9
    while (a1 + 76 + 92 * v1 != a2) {
        int32_t v2 = v1 + 1; // 0x80a2bfb
        result = v2;
        if (v1 == 17) {
            // break -> 0x80a2c03
            break;
        }
        v1 = v2;
        result = v1;
    }
    // 0x80a2c03
    return result;
}

// Address range: 0x80a2c10 - 0x80a2ca6
int32_t GetGroupOfLayer(int32_t a1) {
    int32_t v1 = (int32_t)PCB; // 0x80a2c19
    int32_t v2 = *(int32_t *)(*(int32_t *)(v1 + 0x220c) + 24); // 0x80a2c2c
    int32_t result = v2; // 0x80a2c34
    if (v2 == a1 || v2 < 1) {
      lab_0x80a2c88:
        // 0x80a2c88
        return result;
    }
    int32_t v3 = 0;
    uint32_t v4 = *(int32_t *)(v1 + 0x1cd4 + 4 * v3); // 0x80a2c42
    int32_t v5; // 0x80a2c10
    int32_t v6; // 0x80a2c10
    int32_t v7; // 0x80a2c71
    if (v4 != 0) {
        // 0x80a2c4d
        if (*(int32_t *)(v1 + 0x1d14) == a1) {
            // break -> 0x80a2c88
            break;
        }
        // 0x80a2c58
        v7 = 0;
        v5 = v1 + 0x1d18 + 72 * v3;
        v7++;
        while (v4 > v7) {
            // 0x80a2c68
            v6 = v5;
            v5 = v6 + 4;
            result = v3;
            if (*(int32_t *)v6 == a1) {
                return result;
            }
            v7++;
        }
    }
    int32_t v8 = v3 + 1; // 0x80a2c78
    int32_t v9 = v1 + 72; // 0x80a2c82
    result = v2;
    while (v2 > v8) {
        // 0x80a2c3f
        v3 = v8;
        int32_t v10 = v9;
        v4 = *(int32_t *)(v1 + 0x1cd4 + 4 * v3);
        if (v4 != 0) {
            // 0x80a2c4d
            result = v3;
            if (*(int32_t *)(v10 + 0x1d14) == a1) {
                // break -> 0x80a2c88
                break;
            }
            // 0x80a2c58
            v7 = 0;
            v5 = v1 + 0x1d18 + 72 * v3;
            v7++;
            while (v4 > v7) {
                // 0x80a2c68
                v6 = v5;
                v5 = v6 + 4;
                result = v3;
                if (*(int32_t *)v6 == a1) {
                    return result;
                }
                v7++;
            }
        }
        // 0x80a2c78
        v8 = v3 + 1;
        v9 = v10 + 72;
        result = v2;
    }
    // 0x80a2c88
    return result;
}

// Address range: 0x80a2d50 - 0x80a2dd0
int32_t GetLayerGroupNumberByNumber(int32_t a1) {
    int32_t v1 = (int32_t)PCB; // 0x80a2d59
    uint32_t v2 = *(int32_t *)(*(int32_t *)(v1 + 0x220c) + 24); // 0x80a2d6f
    int32_t result = 0; // 0x80a2d7c
    if (v2 < 1) {
      lab_0x80a2dc8:
        // 0x80a2dc8
        return result;
    }
    int32_t v3 = 0;
    uint32_t v4 = *(int32_t *)(v1 + 0x1cd4 + 4 * v3); // 0x80a2d81
    int32_t v5; // 0x80a2d50
    int32_t v6; // 0x80a2d50
    int32_t v7; // 0x80a2db1
    if (v4 != 0) {
        // 0x80a2d8c
        if (*(int32_t *)(v1 + 0x1d14) == a1) {
            // break -> 0x80a2dc8
            break;
        }
        // 0x80a2d97
        v5 = v1 + 0x1d18 + 72 * v3;
        v7 = 0;
        while (v7 + 1 < v4) {
            // 0x80a2db1
            v7++;
            // 0x80a2da8
            v6 = v5;
            v5 = v6 + 4;
            result = v3;
            if (*(int32_t *)v6 == a1) {
                return result;
            }
        }
    }
    int32_t v8 = v3 + 1; // 0x80a2db8
    int32_t v9 = v1 + 72; // 0x80a2dc2
    result = v8;
    while (v8 < v2) {
        // 0x80a2d7e
        v3 = v8;
        int32_t v10 = v9;
        v4 = *(int32_t *)(v1 + 0x1cd4 + 4 * v3);
        if (v4 != 0) {
            // 0x80a2d8c
            result = v3;
            if (*(int32_t *)(v10 + 0x1d14) == a1) {
                // break -> 0x80a2dc8
                break;
            }
            // 0x80a2d97
            v5 = v1 + 0x1d18 + 72 * v3;
            v7 = 0;
            while (v7 + 1 < v4) {
                // 0x80a2db1
                v7++;
                // 0x80a2da8
                v6 = v5;
                v5 = v6 + 4;
                result = v3;
                if (*(int32_t *)v6 == a1) {
                    return result;
                }
            }
        }
        // 0x80a2db8
        v8 = v3 + 1;
        v9 = v10 + 72;
        result = v8;
    }
    // 0x80a2dc8
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2dd0 - 0x80a2df6
// Line range:    1711 - 1717
int32_t mem_any_set(char * ptr, int32_t bytes) {
    // 0x80a2dd0
    if (bytes == 0) {
        // 0x80a2df4
        return 0;
    }
    int32_t v1 = (int32_t)ptr; // 0x80a2dd0
    int32_t v2 = bytes; // 0x80a2de7
    int32_t result = 1; // 0x80a2ded
    while (*(char *)v1 == 0) {
        // 0x80a2de0
        v2--;
        v1++;
        result = 0;
        if (v2 == 0) {
            // break -> 0x80a2df4
            break;
        }
        result = 1;
    }
    // 0x80a2df4
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a35c0 - 0x80a3732
// Line range:    1902 - 1959
float64_t c_strtod(char * s) {
    int32_t v1 = (int32_t)s;
    unsigned char v2 = *s; // 0x80a35c9
    int32_t v3 = v2; // 0x80a35c9
    int32_t v4 = v1; // 0x80a35ce
    int32_t v5 = v3; // 0x80a35ce
    float80_t v6 = 0.0L; // 0x80a35ce
    float80_t v7 = 1.0L; // 0x80a35ce
    int32_t v8 = v1; // 0x80a35ce
    int32_t v9 = v3; // 0x80a35ce
    char v10; // 0x80a35c0
    int32_t v11; // 0x80a35c0
    int32_t v12; // 0x80a35c0
    int32_t v13; // 0x80a35c0
    float80_t v14; // 0x80a35c0
    float80_t v15; // 0x80a35c0
    float80_t v16; // 0x80a35c0
    float80_t v17; // 0x80a35c0
    if (v2 != 0) {
        int32_t v18; // 0x80a35c0
        char v19; // 0x80a35c0
        while (true) {
          lab_0x80a35e6:
            // 0x80a35e6
            v18 = v5;
            v11 = v4;
            v19 = v18;
            switch (v19) {
                case 9: {
                    goto lab_0x80a35d8;
                }
                case 32: {
                    goto lab_0x80a35d8;
                }
                default: {
                    goto lab_0x80a35f0;
                }
            }
        }
      lab_0x80a35f0:;
        int32_t v20; // 0x80a35c0
        int32_t v21; // 0x80a35c0
        float80_t v22; // 0x80a35c0
        if (v19 != 45) {
            // 0x80a36d0
            v22 = 1.0L;
            v20 = v11;
            v21 = v18;
            if (v19 == 43) {
                int32_t v23 = v11 + 1; // 0x80a36d5
                v22 = 1.0L;
                v20 = v23;
                v21 = (int32_t)*(char *)v23;
            }
        } else {
            int32_t v24 = v11 + 1; // 0x80a35f9
            v22 = -1.0L;
            v20 = v24;
            v21 = (int32_t)*(char *)v24;
        }
        char v25 = v21;
        char v26 = v25; // 0x80a3609
        float80_t v27 = 0.0L; // 0x80a3609
        int32_t v28 = v20; // 0x80a3609
        int32_t v29 = v21; // 0x80a3609
        if (v25 < 58) {
            int32_t v30 = v20 + 1; // 0x80a361b
            unsigned char v31 = *(char *)v30; // 0x80a3626
            int32_t v32 = v31; // 0x80a3626
            float80_t v33 = (0x1000000 * v21 >> 24) - 48; // 0x80a3632
            float80_t v34 = v33; // 0x80a3634
            int32_t v35 = v30; // 0x80a3634
            int32_t v36 = v32; // 0x80a3634
            v26 = v31;
            v27 = v33;
            v28 = v30;
            v29 = v32;
            while (v31 < 58) {
                // 0x80a3618
                v30 = v35 + 1;
                v31 = *(char *)v30;
                v32 = v31;
                v33 = 10.0L * v34 + (float80_t)((0x1000000 * v36 >> 24) - 48);
                v34 = v33;
                v35 = v30;
                v36 = v32;
                v26 = v31;
                v27 = v33;
                v28 = v30;
                v29 = v32;
            }
        }
        // 0x80a3638
        v6 = v27;
        v7 = v22;
        v8 = v28;
        v9 = v29;
        if (v26 != 46) {
            goto lab_0x80a36bc;
        } else {
            int32_t v37 = v28 + 1; // 0x80a363d
            unsigned char v38 = *(char *)v37; // 0x80a3640
            int32_t v39 = v38; // 0x80a3640
            float80_t v40 = 0.1L; // 0x80a3649
            v6 = v27;
            v7 = v22;
            v8 = v37;
            v9 = v39;
            if (v38 < 58) {
                int32_t v41 = v37 + 1; // 0x80a365b
                unsigned char v42 = *(char *)v41; // 0x80a3664
                float80_t v43 = v27 + v40 * (float80_t)((0x1000000 * v39 >> 24) - 48); // 0x80a3672
                v40 *= 0.1L;
                float80_t v44 = v43; // 0x80a3676
                int32_t v45 = v41; // 0x80a3676
                int32_t v46 = v42; // 0x80a3676
                while (v42 < 58) {
                    // 0x80a3658
                    v41 = v45 + 1;
                    v42 = *(char *)v41;
                    v43 = v44 + v40 * (float80_t)((0x1000000 * v46 >> 24) - 48);
                    v40 *= 0.1L;
                    v44 = v43;
                    v45 = v41;
                    v46 = v42;
                }
                // 0x80a3678
                v14 = v43;
                v16 = v22;
                v12 = v41;
                v10 = v42;
                v15 = v43;
                v17 = v22;
                v13 = v41;
                if (v42 != 101) {
                    goto lab_0x80a36c1;
                } else {
                    goto lab_0x80a3688;
                }
            } else {
                goto lab_0x80a36bc;
            }
        }
    } else {
        goto lab_0x80a36bc;
    }
  lab_0x80a35d8:
    // 0x80a35d8
    v4 = v11 + 1;
    unsigned char v47 = *(char *)v4; // 0x80a35db
    v5 = v47;
    if (v47 == 0) {
        // 0x80a36c6
        return 0.0L;
    }
    goto lab_0x80a35e6;
  lab_0x80a36bc:;
    char v48 = v9;
    v14 = v6;
    v16 = v7;
    v12 = v8;
    v10 = v48;
    v15 = v6;
    v17 = v7;
    v13 = v8;
    if (v48 == 101) {
        goto lab_0x80a3688;
    } else {
        goto lab_0x80a36c1;
    }
  lab_0x80a3688:;
    // 0x80a3688
    int32_t v49; // bp-16, 0x80a35c0
    if (function_80607f8(v12 + 1, "%d", &v49, v14) != 1) {
        // 0x80a36b3
        return v14 * v16;
    }
    // 0x80a36e8
    if (v49 >= 1) {
        int32_t v50 = v49 - 1; // 0x80a36f8
        float80_t v51 = 10.0L; // 0x80a36fb
        float80_t v52 = v51; // 0x80a36fd
        int32_t v53 = v50; // 0x80a36fd
        while (v50 != 0) {
            // 0x80a36f8
            v50 = v53 - 1;
            v51 = 10.0L * v52;
            v52 = v51;
            v53 = v50;
        }
        // 0x80a3708
        return v16 * v14 * v51;
    }
    // 0x80a370c
    if (v49 == 0) {
        // 0x80a3708
        return v16 * v14;
    }
    int32_t v54 = v49 + 1; // 0x80a3718
    float80_t v55 = 0.1L; // 0x80a371b
    float80_t v56 = v55; // 0x80a371d
    int32_t v57 = v54; // 0x80a371d
    while (v54 != 0) {
        // 0x80a3718
        v54 = v57 + 1;
        v55 = 0.1L * v56;
        v56 = v55;
        v57 = v54;
    }
    // 0x80a3708
    return v16 * v14 * v55;
  lab_0x80a36c1:
    // 0x80a36c1
    v14 = v15;
    v16 = v17;
    v12 = v13;
    if (v10 != 69) {
        // 0x80a36c6
        return v17 * v15;
    }
    goto lab_0x80a3688;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3740 - 0x80a381e
// Line range:    1878 - 1899
char * c_dtostr(float64_t d) {
    int32_t v1 = (int32_t)&g64; // 0x80a3752
    float80_t v2; // 0x80a3740
    if (d < 0.0) {
        // 0x80a3756
        *(char *)&g64 = 45;
        float80_t v3; // 0x80a3740
        v2 = -v3;
        v1 = &g65;
    }
    float80_t v4 = v2 + 5.0e-7L; // 0x80a3764
    floor((float64_t)v4);
    char * str = (char *)v1; // 0x80a3775
    __sprintf_chk(str, 1, 100, "%d", (int32_t)v4);
    int32_t v5 = strlen(str) + v1; // 0x80a37ba
    *(char *)v5 = 46;
    float80_t v6 = 0.0L; // 0x80a37cd
    floor((float64_t)v6);
    __sprintf_chk((char *)(v5 + 1), 1, -1, "%06d", (int32_t)v6);
    return (char *)&g64;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3820 - 0x80a398a
// Line range:    1796 - 1834
char * LayerGroupsToString(int32_t * lg) {
    int32_t v1 = (int32_t)PCB; // 0x80a382e
    int32_t v2 = 0; // 0x80a3840
    int32_t v3 = v1; // 0x80a3840
    int32_t v4 = v1; // 0x80a3840
    int32_t v5 = (int32_t)&g66; // 0x80a3840
    int32_t v6 = 0; // 0x80a3840
    if (*(int32_t *)(*(int32_t *)(v1 + 0x220c) + 24) < 1) {
        // 0x80a397a
        *(char *)(int32_t)&g66 = 0;
        return (char *)&g66;
    }
    int32_t v7; // 0x80a3820
    int32_t v8; // 0x80a3820
    int32_t v9; // 0x80a3820
    int32_t v10; // 0x80a3820
    int32_t v11; // 0x80a3820
    int32_t v12; // 0x80a3820
    int32_t v13; // 0x80a3820
    while (true) {
      lab_0x80a3872:;
        int32_t v14 = v6;
        int32_t v15 = v5;
        v11 = v4;
        v7 = v3;
        v12 = v2;
        v13 = 4 * v12 + 0x1cd4;
        int32_t * v16 = (int32_t *)(v13 + v11); // 0x80a387b
        v3 = v7;
        v10 = v7;
        v8 = v15;
        v6 = v14;
        if (*v16 == 0) {
            goto lab_0x80a385a;
        } else {
            // 0x80a3886
            v9 = v15;
            if ((char)v14 == 0) {
                goto lab_0x80a38b2;
            } else {
                // 0x80a3892
                *(char *)v15 = 58;
                int32_t v17 = v15 + 1; // 0x80a388f
                v3 = v7;
                v10 = v11;
                v8 = v17;
                v6 = 1;
                v9 = v17;
                if (*v16 == 0) {
                    goto lab_0x80a385a;
                } else {
                    goto lab_0x80a38b2;
                }
            }
        }
    }
  lab_0x80a397a:;
    // 0x80a397a
    int32_t v18; // 0x80a3820
    *(char *)v18 = 0;
    return (char *)&g66;
  lab_0x80a385a:
    // 0x80a385a
    v5 = v8;
    v4 = v10;
    v2 = v12 + 1;
    v18 = v5;
    if (*(int32_t *)(*(int32_t *)(v4 + 0x220c) + 24) <= v2) {
        // break -> 0x80a397a
        goto lab_0x80a397a;
    }
    goto lab_0x80a3872;
  lab_0x80a38b2:;
    int32_t v19 = 18 * v12 + 1860; // 0x80a38fb
    int32_t v20 = 0; // 0x80a38bf
    int32_t v21 = v9;
    int32_t v22 = v7;
    int32_t v23 = *(int32_t *)(v11 + 4 + 4 * (v19 + v20)); // 0x80a3902
    int32_t v24 = *(int32_t *)(*(int32_t *)(v11 + 0x220c) + 24); // 0x80a390c
    int32_t v25; // 0x80a3820
    int32_t v26; // 0x80a3820
    int32_t v27; // 0x80a3820
    int32_t v28; // 0x80a3948
    if (v24 + 1 == v23) {
        // 0x80a3960
        *(char *)v21 = 99;
        v25 = v22;
        v26 = v21 + 1;
    } else {
        if (v23 == v24) {
            // 0x80a38c8
            *(char *)v21 = 115;
            v25 = v22;
            v26 = v21 + 1;
        } else {
            // 0x80a391a
            __sprintf_chk((char *)v21, 1, 91, "%d", v23 + 1);
            v28 = v21 + 1;
            v27 = v28;
            while (*(char *)v28 != 0) {
                // 0x80a3948
                v28 = v27 + 1;
                v27 = v28;
            }
            // 0x80a3950
            v25 = (int32_t)PCB;
            v26 = v28;
        }
    }
    int32_t v29 = v26;
    int32_t * v30 = (int32_t *)(v25 + v13); // 0x80a38d3
    int32_t v31 = *v30; // 0x80a38d3
    int32_t v32 = v31; // 0x80a38dd
    int32_t v33 = v29; // 0x80a38dd
    if (v20 != v31 - 1) {
        // 0x80a38df
        *(char *)v29 = 44;
        v32 = *v30;
        v33 = v29 + 1;
    }
    int32_t v34 = v20 + 1; // 0x80a38ec
    v3 = v25;
    v10 = v25;
    v8 = v33;
    v6 = 1;
    v20 = v34;
    int32_t v35 = v25; // 0x80a38f4
    while (v32 > v34) {
        // 0x80a38f8
        v21 = v33;
        v22 = v25;
        v23 = *(int32_t *)(v35 + 4 + 4 * (v19 + v20));
        v24 = *(int32_t *)(*(int32_t *)(v35 + 0x220c) + 24);
        if (v24 + 1 == v23) {
            // 0x80a3960
            *(char *)v21 = 99;
            v25 = v22;
            v26 = v21 + 1;
        } else {
            if (v23 == v24) {
                // 0x80a38c8
                *(char *)v21 = 115;
                v25 = v22;
                v26 = v21 + 1;
            } else {
                // 0x80a391a
                __sprintf_chk((char *)v21, 1, 91, "%d", v23 + 1);
                v28 = v21 + 1;
                v27 = v28;
                while (*(char *)v28 != 0) {
                    // 0x80a3948
                    v28 = v27 + 1;
                    v27 = v28;
                }
                // 0x80a3950
                v25 = (int32_t)PCB;
                v26 = v28;
            }
        }
        // 0x80a38ce
        v29 = v26;
        v30 = (int32_t *)(v25 + v13);
        v31 = *v30;
        v32 = v31;
        v33 = v29;
        if (v20 != v31 - 1) {
            // 0x80a38df
            *(char *)v29 = 44;
            v32 = *v30;
            v33 = v29 + 1;
        }
        // 0x80a38ec
        v34 = v20 + 1;
        v3 = v25;
        v10 = v25;
        v8 = v33;
        v6 = 1;
        v20 = v34;
        v35 = v25;
    }
    goto lab_0x80a385a;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3a70 - 0x80a3af9
// Line range:    1686 - 1708
char * Concat(char * first, ...) {
    int32_t len = strlen(first); // 0x80a3a7f
    int32_t * mem = calloc(1, len + 1); // 0x80a3a94
    int32_t v1 = (int32_t)mem; // 0x80a3a94
    strcpy((char *)mem, first);
    char * v2; // 0x80a3a70
    if (v2 == NULL) {
        // 0x80a3aef
        return (char *)v1;
    }
    // 0x80a3ab8
    int32_t v3; // bp+12, 0x80a3a70
    int32_t v4 = &v3; // 0x80a3a70
    int32_t v5 = len; // 0x80a3ac6
    char * str = (char *)(int32_t)v2; // 0x80a3ab8
    v5 += strlen(str);
    int32_t * mem2 = realloc((int32_t *)v1, v5 + 1); // 0x80a3acf
    int32_t v6 = (int32_t)mem2;
    strcat((char *)mem2, str);
    int32_t v7 = *(int32_t *)v4; // 0x80a3ae8
    v4 += 4;
    while (v7 != 0) {
        // 0x80a3ab8
        str = (char *)v7;
        v5 += strlen(str);
        mem2 = realloc((int32_t *)v6, v5 + 1);
        v6 = (int32_t)mem2;
        strcat((char *)mem2, str);
        v7 = *(int32_t *)v4;
        v4 += 4;
    }
    // 0x80a3aef
    return (char *)v6;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3b30 - 0x80a3c59
// Line range:    1545 - 1554
char * UniqueElementName(int32_t * Data, char * Name) {
    int32_t v1 = (int32_t)Name;
    if (Name == NULL || *Name == 0) {
        // 0x80a3b92
        return (char *)v1;
    }
    int32_t v2 = (int32_t)Data;
    int32_t * v3 = (int32_t *)(v2 + 8); // 0x80a3b48
    int32_t v4 = *v3; // 0x80a3b48
    int32_t v5 = v1; // 0x80a3b51
    if (v4 == 0) {
      lab_0x80a3b92:
        // 0x80a3b92
        return (char *)v5;
    }
    char * str2 = (char *)v1;
    int32_t v6 = 300 * v4 - 152 + *(int32_t *)(v2 + 32); // 0x80a3b62
    int32_t v7 = v4; // 0x80a3b62
    int32_t v8; // 0x80a3b30
    int32_t v9; // 0x80a3b30
    int32_t str; // 0x80a3b68
    while (true) {
        // 0x80a3b68
        v8 = v7;
        v9 = v6;
        str = *(int32_t *)v9;
        if (str != 0) {
            // 0x80a3b6e
            if (strcmp((char *)str, str2) == 0) {
                // break -> 0x80a3ba0
                break;
            }
        }
        // 0x80a3b84
        v7 = v8 - 1;
        v6 = v9 - 300;
        v5 = v1;
        if (v7 == 0) {
            return (char *)v5;
        }
    }
    int32_t v10 = v1; // 0x80a3ba5
    int32_t v11; // 0x80a3b30
    int32_t v12; // 0x80a3ba8
    if (*str2 != 0) {
        v12 = v1 + 1;
        v11 = v12;
        v10 = v12;
        while (*(char *)v12 != 0) {
            // 0x80a3ba8
            v12 = v11 + 1;
            v11 = v12;
            v10 = v12;
        }
    }
    int16_t * v13 = *__ctype_b_loc(); // 0x80a3bb8
    int32_t v14 = v10;
    int32_t v15 = v14 - 1;
    char v16 = *(char *)v15; // 0x80a3bc3
    while ((*(char *)((int32_t)v13 + 1 + 2 * (int32_t)v16) & 8) != 0) {
        // 0x80a3bc3
        v14 = v15;
        v15 = v14 - 1;
        v16 = *(char *)v15;
    }
    char * str3 = (char *)v14; // 0x80a3bd4
    int32_t v17 = 1; // 0x80a3bdb
    char v18 = 0; // 0x80a3bdb
    int32_t str_as_l; // 0x80a3c43
    if (*str3 != 0) {
        // 0x80a3c2d
        str_as_l = strtol(str3, NULL, 10);
        v18 = *str3;
        v17 = str_as_l + 1;
    }
    // 0x80a3bdd
    *str3 = 0;
    __sprintf_chk((char *)&g67, 1, 256, "%s%d", str2, v17);
    char v19 = v18; // 0x80a3c1f
    if (v1 == (int32_t)&g67) {
        // 0x80a3c54
        v19 = *str3;
    }
    // 0x80a3c21
    *str3 = v19;
    int32_t v20 = *v3; // 0x80a3b48
    while (v20 != 0) {
        int32_t v21 = (int32_t)&g67;
        str2 = (char *)v21;
        v6 = 300 * v20 - 152 + *(int32_t *)(v2 + 32);
        v7 = v20;
        while (true) {
            // 0x80a3b68
            v8 = v7;
            v9 = v6;
            str = *(int32_t *)v9;
            if (str != 0) {
                // 0x80a3b6e
                if (strcmp((char *)str, str2) == 0) {
                    // break -> 0x80a3ba0
                    break;
                }
            }
            // 0x80a3b84
            v7 = v8 - 1;
            v6 = v9 - 300;
            v5 = v21;
            if (v7 == 0) {
                return (char *)v5;
            }
        }
        // 0x80a3ba0
        v11 = v21;
        v10 = v21;
        if (*str2 != 0) {
            v12 = v11 + 1;
            v11 = v12;
            v10 = v12;
            while (*(char *)v12 != 0) {
                // 0x80a3ba8
                v12 = v11 + 1;
                v11 = v12;
                v10 = v12;
            }
        }
        // 0x80a3bb0
        v13 = *__ctype_b_loc();
        v14 = v10;
        v15 = v14 - 1;
        v16 = *(char *)v15;
        while ((*(char *)((int32_t)v13 + 1 + 2 * (int32_t)v16) & 8) != 0) {
            // 0x80a3bc3
            v14 = v15;
            v15 = v14 - 1;
            v16 = *(char *)v15;
        }
        // 0x80a3bcd
        str3 = (char *)v14;
        v17 = 1;
        v18 = 0;
        if (*str3 != 0) {
            // 0x80a3c2d
            str_as_l = strtol(str3, NULL, 10);
            v18 = *str3;
            v17 = str_as_l + 1;
        }
        // 0x80a3bdd
        *str3 = 0;
        __sprintf_chk((char *)&g67, 1, 256, "%s%d", str2, v17);
        v19 = v18;
        if (v21 == (int32_t)&g67) {
            // 0x80a3c54
            v19 = *str3;
        }
        // 0x80a3c21
        *str3 = v19;
        v20 = *v3;
    }
    // 0x80a3b92
    return (char *)(int32_t)&g67;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3c60 - 0x80a3f59
// Line range:    778 - 802
int32_t ParseGroupString(char * s, int32_t * LayerGroup, int32_t LayerN) {
    // 0x80a3c60
    __asm_rep_stosd_memset((char *)LayerGroup, 0, 304);
    int32_t v1; // bp-4, 0x80a3c60
    int32_t v2 = (int32_t)&v1 - 96; // 0x80a3c80
    for (int32_t i = 0; i < 18; i++) {
        // 0x80a3c80
        *(int32_t *)(4 * i + v2) = -1;
    }
    int32_t v3 = (int32_t)LayerGroup;
    char * str; // 0x80a3c60
    int32_t v4; // 0x80a3c60
    char v5; // 0x80a3c60
    char v6; // 0x80a3c60
    char v7; // 0x80a3c60
    char v8; // 0x80a3c60
    char v9; // 0x80a3c60
    char v10; // 0x80a3c60
    int32_t v11; // 0x80a3c60
    int32_t v12; // 0x80a3c60
    int32_t v13; // 0x80a3c60
    bool v14; // 0x80a3c60
    bool v15; // 0x80a3c60
    int32_t v16; // 0x80a3c60
    int32_t v17; // 0x80a3c60
    int32_t v18; // 0x80a3c60
    int32_t v19; // 0x80a3c60
    int32_t v20; // 0x80a3c60
    int32_t v21; // 0x80a3c60
    int32_t v22; // 0x80a3c60
    int32_t v23; // 0x80a3c60
    char v24; // 0x80a3c60
    char v25; // 0x80a3c60
    char v26; // 0x80a3c60
    char v27; // 0x80a3c60
    char v28; // 0x80a3c60
    char v29; // 0x80a3c60
    int32_t v30; // 0x80a3c60
    int32_t v31; // 0x80a3c60
    int32_t v32; // 0x80a3c60
    int32_t v33; // 0x80a3c60
    int32_t v34; // 0x80a3c60
    bool v35; // 0x80a3c60
    int32_t result; // 0x80a3c60
    int16_t v36; // 0x80a3d31
    int32_t v37; // 0x80a3cc3
    int16_t ** v38; // 0x80a3cd4
    if (s == NULL) {
        // 0x80a3ebb
        v9 = 0;
        v33 = 0;
        v14 = LayerN >= 0 == (LayerN != 0);
        goto lab_0x80a3ecd;
    } else {
        char v39 = *s; // 0x80a3c9b
        v9 = 0;
        v33 = 0;
        v14 = LayerN >= 0 == (LayerN != 0);
        if (LayerN < 1 || v39 == 0) {
            goto lab_0x80a3ecd;
        } else {
            // 0x80a3cb1
            v37 = LayerN + 1;
            char v40 = 0; // 0x80a3cc6
            char v41 = 0; // 0x80a3cc6
            int32_t v42 = 0; // 0x80a3cc6
            char v43 = v39; // 0x80a3cc6
            int32_t v44 = (int32_t)s; // 0x80a3cc6
            char v45; // 0x80a3c60
            bool v46; // 0x80a3c60
            char v47; // 0x80a3c60
            int32_t v48; // 0x80a3de1
            while (true) {
                // 0x80a3cd1
                v32 = v42;
                char v49 = v41;
                char v50 = v40;
                v38 = __ctype_b_loc();
                int32_t v51 = (int32_t)*v38; // 0x80a3cdf
                int32_t v52 = v44;
                int32_t v53 = v43;
                while ((*(char *)(v51 + 1 + (0x1000000 * v53 >> 23)) & 32) != 0) {
                    int32_t v54 = v52 + 1; // 0x80a3ce8
                    char v55 = *(char *)v54; // 0x80a3ceb
                    v4 = v54;
                    v29 = v50;
                    v8 = v49;
                    v22 = 0;
                    if (v55 == 0) {
                        goto lab_0x80a3dd0_6;
                    }
                    v52 = v54;
                    v53 = v55;
                }
                // 0x80a3d0a
                v25 = v50;
                v5 = v49;
                v30 = v3 + 64 + 72 * v32;
                v11 = v53;
                v23 = v51;
                v16 = v52;
                v21 = 0;
                while (true) {
                  lab_0x80a3d2e:;
                    int32_t v56 = v23;
                    v31 = v30;
                    v6 = v5;
                    v26 = v25;
                    v17 = v16;
                    int32_t v57 = v11;
                    v36 = *(int16_t *)((0x1000000 * v57 >> 23) + v56);
                    while ((v36 & 0x2000) != 0) {
                        int32_t v58 = v17 + 1; // 0x80a3d20
                        char * v59 = (char *)v58;
                        unsigned char v60 = *v59; // 0x80a3d23
                        int32_t v61 = v60; // 0x80a3d28
                        int32_t v62 = v58; // 0x80a3d28
                        if (v60 == 0) {
                            // 0x80a3e60
                            str = v59;
                            v18 = v58;
                            if ((*(int16_t *)v56 & 2048) != 0) {
                                goto lab_0x80a3d68;
                            } else {
                                // 0x80a3e6c
                                __asm_rep_stosd_memset((char *)LayerGroup, 0, 304);
                                result = 1;
                                return result;
                            }
                        }
                        v17 = v62;
                        v57 = v61;
                        v36 = *(int16_t *)((0x1000000 * v57 >> 23) + v56);
                    }
                    char v63 = v57; // 0x80a3d3a
                    v27 = 1;
                    v12 = LayerN;
                    v19 = v17;
                    v35 = (v37 & (LayerN ^ -0x80000000)) < 0;
                    if (v63 == 83) {
                        goto lab_0x80a3d89;
                    } else {
                        if (v63 > 83) {
                            // 0x80a3e98
                            v28 = v26;
                            v7 = 1;
                            v13 = v37;
                            v20 = v17;
                            if (v63 == 99) {
                                goto lab_0x80a3d91;
                            } else {
                                // 0x80a3e9c
                                v27 = 1;
                                v12 = LayerN;
                                v19 = v17;
                                v35 = (v37 & (LayerN ^ -0x80000000)) < 0;
                                if (v63 != 115) {
                                    goto lab_0x80a3d56;
                                } else {
                                    goto lab_0x80a3d89;
                                }
                            }
                        } else {
                            // 0x80a3d48
                            v28 = v26;
                            v7 = 1;
                            v13 = v37;
                            v20 = v17;
                            if (v63 == 67) {
                                goto lab_0x80a3d91;
                            } else {
                                goto lab_0x80a3d56;
                            }
                        }
                    }
                }
              lab_0x80a3dd0_6:
                // 0x80a3dd0
                v45 = v8;
                v47 = v29;
                int32_t v64 = v4;
                *(int32_t *)(4 * v32 + v3) = v22;
                v48 = v32 + 1;
                v44 = v64 + (int32_t)(*(char *)v64 == 58);
                if (v44 == 0) {
                    // break -> 0x80a3f44
                    break;
                }
                // 0x80a3def
                v43 = *(char *)v44;
                int32_t v65 = LayerN - v48; // 0x80a3df2
                v40 = v47;
                v41 = v45;
                v42 = v48;
                v46 = v65 < 0 == ((v65 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v65 != 0);
                if (v65 < 0 == ((v65 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v65 != 0) != v43 != 0) {
                    goto lab_0x80a3e04;
                }
            }
            int32_t v66 = LayerN - v48; // 0x80a3f47
            v46 = v66 < 0 == ((v66 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v66 != 0);
          lab_0x80a3e04:
            // 0x80a3e04
            v10 = v45;
            v34 = v48;
            v15 = v46;
            v24 = 1;
            if (v47 != 0) {
                goto lab_0x80a3ee3;
            } else {
                int32_t v67 = LayerN - v48; // 0x80a3e16
                v9 = v45;
                v33 = v48;
                v14 = v67 < 0 == ((v67 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v67 != 0);
                goto lab_0x80a3ecd;
            }
        }
    }
  lab_0x80a3d89:
    // 0x80a3d89
    v28 = v27;
    v7 = v6;
    v13 = v12;
    v20 = v19;
    if (v35) {
        // 0x80a3e6c
        __asm_rep_stosd_memset((char *)LayerGroup, 0, 304);
        result = 1;
        return result;
    }
    goto lab_0x80a3d91;
  lab_0x80a3d91:
    if (v21 > LayerN) {
        // 0x80a3e6c
        __asm_rep_stosd_memset((char *)LayerGroup, 0, 304);
        result = 1;
        goto lab_0x80a3e7a;
    }
    char v68 = v7;
    char v69 = v28;
    int32_t v70 = v20 + 1; // 0x80a3d9d
    int32_t v71 = v21 + 1; // 0x80a3da0
    *(int32_t *)(4 * v13 + v2) = v32;
    *(int32_t *)v31 = v13;
    char v72 = *(char *)v70; // 0x80a3dac
    v4 = v70;
    v29 = v69;
    v8 = v68;
    v22 = v71;
    if (v72 == 0) {
        // break -> 0x80a3dd0
        goto lab_0x80a3dd0_6;
    }
    int32_t v73 = (int32_t)*v38;
    int32_t v74 = v70;
    char v75 = v72;
    int16_t v76 = *(int16_t *)((0x1000000 * (int32_t)v75 >> 23) + v73); // 0x80a3dbd
    while ((v76 & 2048) != 0) {
        int32_t v77 = v74 + 1; // 0x80a3dc6
        char v78 = *(char *)v77; // 0x80a3dc9
        char v79 = v78; // 0x80a3dce
        int32_t v80 = v77; // 0x80a3dce
        v4 = v77;
        v29 = v69;
        v8 = v68;
        v22 = v71;
        if (v78 == 0) {
            // break (via goto) -> 0x80a3dd0
            goto lab_0x80a3dd0_6;
        }
        v74 = v80;
        v75 = v79;
        v76 = *(int16_t *)((0x1000000 * (int32_t)v75 >> 23) + v73);
    }
    int32_t v81 = v74; // 0x80a3e3c
    char v82 = v75; // 0x80a3e3c
    int32_t v83 = v74; // 0x80a3e3c
    if ((v76 & 0x2000) != 0) {
        int32_t v84 = v81 + 1; // 0x80a3e28
        unsigned char v85 = *(char *)v84; // 0x80a3e2b
        v4 = v84;
        v29 = v69;
        v8 = v68;
        v22 = v71;
        if (v85 == 0) {
            // break (via goto) -> 0x80a3dd0
            goto lab_0x80a3dd0_6;
        }
        // 0x80a3e32
        v81 = v84;
        v82 = v85;
        v83 = v84;
        while ((*(int16_t *)((0x1000000 * (int32_t)v85 >> 23) + v73) & 0x2000) != 0) {
            // 0x80a3e28
            v84 = v81 + 1;
            v85 = *(char *)v84;
            v4 = v84;
            v29 = v69;
            v8 = v68;
            v22 = v71;
            if (v85 == 0) {
                // break (via goto) -> 0x80a3dd0
                goto lab_0x80a3dd0_6;
            }
            // 0x80a3e32
            v81 = v84;
            v82 = v85;
            v83 = v84;
        }
    }
    int32_t v86 = v83;
    char v87 = v82;
    v4 = v86;
    v29 = v69;
    v8 = v68;
    v22 = v71;
    if (v87 == 58) {
        // break -> 0x80a3dd0
        goto lab_0x80a3dd0_6;
    }
    if (v87 != 44) {
        // 0x80a3e6c
        __asm_rep_stosd_memset((char *)LayerGroup, 0, 304);
        result = 1;
        goto lab_0x80a3e7a;
    }
    int32_t v88 = v86 + 1; // 0x80a3e46
    unsigned char v89 = *(char *)v88; // 0x80a3e49
    v25 = v69;
    v5 = v68;
    v30 = v31 + 4;
    v11 = v89;
    v23 = v73;
    v16 = v88;
    v21 = v71;
    v4 = v88;
    v29 = v69;
    v8 = v68;
    v22 = v71;
    if (v89 == 0) {
        // break -> 0x80a3dd0
        goto lab_0x80a3dd0_6;
    }
    goto lab_0x80a3d2e;
  lab_0x80a3d56:
    if ((v36 & 2048) == 0) {
        // 0x80a3e6c
        __asm_rep_stosd_memset((char *)LayerGroup, 0, 304);
        result = 1;
        goto lab_0x80a3e7a;
    }
    // 0x80a3d56
    str = (char *)v17;
    v18 = v17;
    goto lab_0x80a3d68;
  lab_0x80a3d68:;
    int32_t v90 = strtol(str, NULL, 10) - 1; // 0x80a3d80
    int32_t v91 = v90 - v37; // 0x80a3d83
    v27 = v26;
    v12 = v90;
    v19 = v18;
    v35 = v91 < 0 == ((v91 ^ v90) & (v90 ^ v37)) < 0 == (v91 != 0);
    goto lab_0x80a3d89;
  lab_0x80a3ecd:;
    int32_t v92 = *LayerGroup; // 0x80a3ed3
    *(int32_t *)(v3 + 64 + 4 * v92) = LayerN;
    *LayerGroup = v92 + 1;
    v10 = v9;
    v34 = v33;
    v15 = v14;
    v24 = LayerN >= 0 == (LayerN != 0);
    goto lab_0x80a3ee3;
  lab_0x80a3ee3:
    // 0x80a3ee3
    if (v10 == 0) {
        int32_t * v93 = (int32_t *)(v3 + 4); // 0x80a3eef
        int32_t v94 = *v93; // 0x80a3eef
        *(int32_t *)(v3 + 136 + 4 * v94) = LayerN + 1;
        *v93 = v94 + 1;
    }
    // 0x80a3f02
    if (!v15 || v24 == 0) {
        // 0x80a3e7a
        return 0;
    }
    int32_t v95 = 0;
    int32_t v96 = v34; // 0x80a3f28
    if (*(int32_t *)(4 * v95 + v2) == -1) {
        // 0x80a3f2a
        *(int32_t *)(4 * v34 + v3) = 1;
        *(int32_t *)(v3 + 64 + 72 * v34) = v95;
        v96 = v34 + 1;
    }
    int32_t v97 = v95 + 1; // 0x80a3f18
    result = 0;
    while (v97 < LayerN == v96 < LayerN) {
        int32_t v98 = v96;
        v95 = v97;
        v96 = v98;
        if (*(int32_t *)(4 * v95 + v2) == -1) {
            // 0x80a3f2a
            *(int32_t *)(4 * v98 + v3) = 1;
            *(int32_t *)(v3 + 64 + 72 * v98) = v95;
            v96 = v98 + 1;
        }
        // 0x80a3f18
        v97 = v95 + 1;
        result = 0;
    }
  lab_0x80a3e7a:
    // 0x80a3e7a
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3f60 - 0x80a3fae
// Line range:    690 - 695
void GetNum(char ** s, int32_t * num) {
    // 0x80a3f60
    int32_t str; // 0x80a3f60
    *(int32_t *)str = strtol((char *)str, NULL, 10);
    int16_t ** v1 = __ctype_b_loc(); // 0x80a3f88
    int32_t v2 = (int32_t)*v1;
    int32_t v3 = v2 + 1; // 0x80a3fa0
    if ((*(char *)((0x1000000 * v2 >> 23) + v3) & 8) == 0) {
        // 0x80a3fa7
        return;
    }
    int32_t v4 = (int32_t)v1;
    v4++;
    *(int32_t *)str = v4;
    while ((*(char *)(2 * (int32_t)*(char *)v4 + v3) & 8) != 0) {
        // 0x80a3f98
        v4++;
        *(int32_t *)str = v4;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3fb0 - 0x80a3ff6
// Line range:    1471 - 1475
void RightAngles(int32_t Angle, float32_t * cosa, float32_t * sina) {
    // 0x80a3fb0
    int32_t v1; // 0x80a3fb0
    function_8060d88(0.0174532925199432954744L * (float80_t)v1);
    float64_t v2; // 0x80a3fb0
    *(float32_t *)v1 = (float32_t)v2;
    *(float32_t *)v1 = (float32_t)v2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4000 - 0x80a40b0
// Line range:    1478 - 1490
int32_t * GetArcEnds(int32_t * Arc) {
    int32_t v1 = (int32_t)Arc;
    int32_t v2; // 0x80a4000
    RightAngles(v2, (float32_t *)v2, (float32_t *)v2);
    int32_t * v3 = (int32_t *)(v1 + 52); // 0x80a4022
    int32_t v4 = *v3; // 0x80a4022
    int32_t * v5 = (int32_t *)(v1 + 44); // 0x80a4025
    int32_t v6 = *v5; // 0x80a4025
    float32_t v7; // 0x80a4000
    float80_t v8 = v7; // 0x80a4028
    g68 = (float80_t)v4 - v8 * (float80_t)v6;
    int32_t * v9 = (int32_t *)(v1 + 56); // 0x80a404c
    int32_t v10 = *v9; // 0x80a404c
    int32_t * v11 = (int32_t *)(v1 + 48); // 0x80a404f
    int32_t v12 = *v11; // 0x80a404f
    float80_t v13 = v7; // 0x80a4052
    g69 = v13 * (float80_t)v12 + (float80_t)v10;
    int16_t v14; // 0x80a4000
    RightAngles((int32_t)(v14 % 256 | 3072), (float32_t *)&g279, (float32_t *)&g279);
    int32_t v15 = *v3; // 0x80a4068
    int32_t v16 = *v5; // 0x80a406b
    g70 = (float80_t)v15 - v8 * (float80_t)v16;
    int32_t v17 = *v9; // 0x80a4091
    int32_t v18 = *v11; // 0x80a4094
    g71 = v13 * (float80_t)v18 + (float80_t)v17;
    return &g68;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a40b0 - 0x80a440b
// Line range:    1246 - 1283
void SetArcBoundingBox(int32_t * Arc) {
    int32_t v1 = (int32_t)Arc;
    int32_t * v2 = (int32_t *)(v1 + 64); // 0x80a40bc
    int32_t v3 = *v2; // 0x80a40bc
    int32_t v4 = *(int32_t *)(v1 + 60);
    int32_t v5; // 0x80a40b0
    int32_t v6; // 0x80a40b0
    int32_t v7; // 0x80a40b0
    int32_t v8; // 0x80a40b0
    int32_t v9; // 0x80a40b0
    if (v3 < 361) {
        int32_t v10 = v4 + v3; // 0x80a42c5
        v7 = v10;
        if (v3 >= 0) {
            goto lab_0x80a40da;
        } else {
            // 0x80a42ce
            v8 = v4;
            v5 = v10;
            v9 = v4;
            v6 = v10;
            if (v10 >= 0) {
                goto lab_0x80a40e2;
            } else {
                goto lab_0x80a42dc;
            }
        }
    } else {
        // 0x80a40ca
        *v2 = 360;
        v7 = v4 + 360;
        goto lab_0x80a40da;
    }
  lab_0x80a40da:
    // 0x80a40da
    v8 = v7;
    v5 = v4;
    v9 = v7;
    v6 = v4;
    if (v4 < 0) {
        goto lab_0x80a42dc;
    } else {
        goto lab_0x80a40e2;
    }
  lab_0x80a42dc:;
    int32_t v11 = v6 + 360; // 0x80a42dc
    int32_t v12 = v9 + 360; // 0x80a42e2
    int32_t v13 = 90; // 0x80a42eb
    int32_t v14 = v11; // 0x80a42eb
    int32_t v15 = v12; // 0x80a42eb
    int32_t v16 = v11; // 0x80a42eb
    int32_t v17 = v12; // 0x80a42eb
    int32_t v18 = v11; // 0x80a42eb
    if (v6 != -270) {
        goto lab_0x80a40eb;
    } else {
        goto lab_0x80a42f1;
    }
  lab_0x80a40e2:
    // 0x80a40e2
    v15 = v8;
    v16 = v5;
    v17 = v8;
    v18 = 90;
    if (v5 == 90) {
        goto lab_0x80a42f1;
    } else {
        goto lab_0x80a40eb;
    }
  lab_0x80a40eb:;
    // 0x80a40eb
    float80_t v19; // 0x80a40b0
    float80_t v20; // 0x80a40b0
    if (v14 > v13) {
        // 0x80a40f1
        v19 = 0.0L;
        v20 = -1.0L;
        switch (v16) {
            case 180: {
                // 0x80a4400
                v19 = -1.0L;
                v20 = 0.0L;
                goto lab_0x80a4136;
            }
            case 270: {
                goto lab_0x80a4136;
            }
            default: {
                goto lab_0x80a410e;
            }
        }
    } else {
        // 0x80a4340
        v19 = 1.0L;
        v20 = 0.0L;
        if (v16 != 0) {
            goto lab_0x80a410e;
        } else {
            goto lab_0x80a4136;
        }
    }
  lab_0x80a42f1:;
    int32_t v21 = v17; // 0x80a42f8
    int32_t v22 = 90; // 0x80a42f8
    float80_t v23 = 0.0L; // 0x80a42f8
    float80_t v24 = 1.0L; // 0x80a42f8
    int32_t v25 = v17; // 0x80a42f8
    int32_t v26 = v18; // 0x80a42f8
    float80_t v27 = 0.0L; // 0x80a42f8
    float80_t v28 = 1.0L; // 0x80a42f8
    int32_t v29 = v17; // 0x80a42f8
    int32_t v30 = v18; // 0x80a42f8
    if (v17 != 90) {
        goto lab_0x80a413f;
    } else {
        goto lab_0x80a42fe;
    }
  lab_0x80a413f:;
    // 0x80a413f
    float80_t v31; // 0x80a40b0
    float80_t v32; // 0x80a40b0
    if (v21 > v22) {
        // 0x80a43c0
        v31 = -1.0L;
        v32 = 0.0L;
        if (v25 == 180) {
            goto lab_0x80a4183;
        } else {
            // 0x80a43c8
            v31 = 0.0L;
            v32 = -1.0L;
            if (v25 != 270) {
                goto lab_0x80a414d;
            } else {
                goto lab_0x80a4183;
            }
        }
    } else {
        // 0x80a4145
        v31 = 1.0L;
        v32 = 0.0L;
        if (v25 == 0) {
            goto lab_0x80a4183;
        } else {
            goto lab_0x80a414d;
        }
    }
  lab_0x80a42fe:;
    int32_t v33 = *(int32_t *)(v1 + 52); // 0x80a4306
    int32_t v34 = *(int32_t *)(v1 + 44); // 0x80a430b
    float80_t v35 = v28; // 0x80a430e
    float80_t v36 = v27; // 0x80a430e
    float80_t v37 = 0.0L; // 0x80a430e
    float80_t v38 = 1.0L; // 0x80a430e
    int32_t v39 = v34; // 0x80a430e
    int32_t v40 = v33; // 0x80a430e
    int32_t v41 = v29; // 0x80a430e
    int32_t v42 = v30; // 0x80a430e
    float80_t v43 = 0.0L; // 0x80a430e
    float80_t v44 = v27; // 0x80a430e
    float80_t v45 = v28; // 0x80a430e
    float80_t v46 = 1.0L; // 0x80a430e
    int32_t v47 = v34; // 0x80a430e
    int32_t v48 = v33; // 0x80a430e
    int32_t v49 = v29; // 0x80a430e
    int32_t v50 = v30; // 0x80a430e
    if (v29 > 180) {
        goto lab_0x80a419e;
    } else {
        goto lab_0x80a432a;
    }
  lab_0x80a4136:
    // 0x80a4136
    v23 = v19;
    v24 = v20;
    v25 = v15;
    v26 = v16;
    v27 = v19;
    v28 = v20;
    v29 = 90;
    v30 = v16;
    if (v15 == 90) {
        goto lab_0x80a42fe;
    } else {
        goto lab_0x80a413f;
    }
  lab_0x80a410e:
    // 0x80a410e
    function_8060d88(0.0174532925199432954744L * (float80_t)v16);
    float64_t v51; // 0x80a40b0
    v19 = v51;
    v20 = v51;
    goto lab_0x80a4136;
  lab_0x80a419e:;
    float80_t v52 = -1.0L; // 0x80a41a4
    float80_t v53 = v35; // 0x80a41a4
    float80_t v54 = v36; // 0x80a41a4
    float80_t v55 = v37; // 0x80a41a4
    float80_t v56 = v38; // 0x80a41a4
    int32_t v57 = v39; // 0x80a41a4
    int32_t v58 = v40; // 0x80a41a4
    int32_t v59 = v41; // 0x80a41a4
    int32_t v60 = v42; // 0x80a41a4
    v43 = v37;
    v44 = v36;
    v45 = v35;
    v46 = v38;
    v47 = v39;
    v48 = v40;
    v49 = v41;
    v50 = v42;
    if (v42 > 179) {
        goto lab_0x80a432a;
    } else {
        goto lab_0x80a41ae;
    }
  lab_0x80a432a:;
    bool v61 = false; // 0x80a432a
    bool v62 = false; // 0x80a432a
    if (v43 <= v44) {
        v61 = true;
        v62 = false;
        if (v43 >= v44) {
            v61 = v43 != v44;
            v62 = true;
        }
    }
    v52 = v61 | v62 ? v43 : v44;
    v53 = v45;
    v54 = v44;
    v55 = v43;
    v56 = v46;
    v57 = v47;
    v58 = v48;
    v59 = v49;
    v60 = v50;
    goto lab_0x80a41ae;
  lab_0x80a4183:;
    int32_t v84 = *(int32_t *)(v1 + 52); // 0x80a4189
    int32_t v85 = *(int32_t *)(v1 + 44); // 0x80a418c
    v35 = v24;
    v36 = v23;
    v37 = v31;
    v38 = v32;
    v39 = v85;
    v40 = v84;
    v41 = v25;
    v42 = v26;
    v43 = v31;
    v44 = v23;
    v45 = v24;
    v46 = v32;
    v47 = v85;
    v48 = v84;
    v49 = v25;
    v50 = v26;
    if (v25 < 181) {
        goto lab_0x80a432a;
    } else {
        goto lab_0x80a419e;
    }
  lab_0x80a414d:
    // 0x80a414d
    function_8060d88(0.0174532925199432954744L * (float80_t)v25);
    v31 = v51;
    v32 = v51;
    goto lab_0x80a4183;
  lab_0x80a41ae:;
    float80_t v63 = v58; // 0x80a41b7
    float80_t v64 = v57; // 0x80a41c0
    int32_t v65 = v63 - v52 * v64; // 0x80a41d4
    int32_t * v66 = (int32_t *)(v1 + 8); // 0x80a41dd
    *v66 = v65;
    float80_t v67 = 1.0L; // 0x80a41e0
    if (v59 < 361 || v60 > 359) {
        bool v68 = false; // 0x80a4392
        bool v69 = false; // 0x80a4392
        if (v54 <= v55) {
            v68 = true;
            v69 = false;
            if (v54 >= v55) {
                v68 = v54 != v55;
                v69 = true;
            }
        }
        v67 = v68 | v69 ? v55 : v54;
    }
    int32_t v70 = v63 - v67 * v64; // 0x80a4214
    *Arc = v70;
    float80_t v71 = 1.0L; // 0x80a421f
    if (v59 < 91 || v60 > 89) {
        bool v72 = false; // 0x80a4378
        bool v73 = false; // 0x80a4378
        if (v53 <= v56) {
            v72 = true;
            v73 = false;
            if (v53 >= v56) {
                v72 = v53 != v56;
                v73 = true;
            }
        }
        v71 = v72 | v73 ? v56 : v53;
    }
    float80_t v74 = (float80_t)*(int32_t *)(v1 + 56); // 0x80a4239
    float80_t v75 = (float80_t)*(int32_t *)(v1 + 48); // 0x80a423f
    int32_t v76 = v71 * v75 + v74; // 0x80a4249
    int32_t * v77 = (int32_t *)(v1 + 12); // 0x80a4252
    *v77 = v76;
    float80_t v78 = -1.0L; // 0x80a4255
    if (v59 < 271 || v60 > 269) {
        bool v79 = false; // 0x80a4262
        bool v80 = false; // 0x80a4262
        if (v56 <= v53) {
            v79 = true;
            v80 = false;
            if (v56 >= v53) {
                v79 = v56 != v53;
                v80 = true;
            }
        }
        v78 = v79 | v80 ? v56 : v53;
    }
    int32_t v81 = *(int32_t *)(v1 + 36) + *(int32_t *)(v1 + 40); // 0x80a4287
    int32_t v82 = v81 + (int32_t)(v81 < 0) >> 1; // 0x80a4295
    *Arc = v70 - v82;
    int32_t v83 = v82 + 1; // 0x80a42a0
    *(int32_t *)(v1 + 4) = (int32_t)(v78 * v75 + v74) - v82;
    *v66 = v83 + v65;
    *v77 = v83 + v76;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a44e0 - 0x80a454d
// Line range:    1456 - 1466
void CreateQuotedString(int32_t * DS, char * S) {
    // 0x80a44e0
    DSClearString(DS);
    int32_t v1 = (int32_t)S; // 0x80a44fe
    char v2 = 34; // 0x80a44fe
    while (true) {
        // 0x80a450e
        DSAddCharacter(DS, v2);
        char * v3 = (char *)v1; // 0x80a4516
        char v4 = *v3; // 0x80a4516
        v2 = v4;
        switch (v4) {
            case 0: {
                // 0x80a4538
                DSAddCharacter(DS, 34);
                return;
            }
            case 92: {
            }
            case 34: {
                // 0x80a4521
                DSAddCharacter(DS, 92);
                v2 = *v3;
                // break -> 0x80a4504
                break;
            }
        }
        // 0x80a4504
        v1++;
    }
    // 0x80a4538
    DSAddCharacter(DS, 34);
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4550 - 0x80a456b
// Line range:    1440 - 1449
char * GetWorkingDirectory(char * path) {
    // 0x80a4550
    return getcwd(path, 0x1000);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4b70 - 0x80a4db4
// Line range:    1035 - 105
int32_t ChangeGroupVisibility(int32_t Layer2, char On, char ChangeStackOrder) {
    // 0x80a4b70
    if (g115 != 0) {
        // 0x80a4d88
        __printf_chk(1, "ChangeGroupVisibility(Layer=%d, On=%d, ChangeStackOrder=%d)\n", Layer2, (int32_t)On, (int32_t)ChangeStackOrder);
    }
    int32_t v1 = (int32_t)PCB; // 0x80a4b98
    int32_t * v2 = (int32_t *)(v1 + 0x220c); // 0x80a4b9e
    int32_t v3 = *v2; // 0x80a4b9e
    int32_t v4 = *(int32_t *)(v3 + 24); // 0x80a4ba7
    int32_t v5; // 0x80a4b70
    uint32_t v6; // 0x80a4bcb
    if (v4 != Layer2 && v4 >= 1) {
        // 0x80a4bc5
        v5 = 0;
        v6 = *(int32_t *)(v1 + 0x1cd4 + 4 * v5);
        int32_t v7; // 0x80a4b70
        int32_t v8; // 0x80a4b70
        int32_t v9; // 0x80a4c05
        if (v6 != 0) {
            // 0x80a4bd6
            if (*(int32_t *)(v1 + 0x1d14) == Layer2) {
                goto lab_0x80a4cb8_2;
            }
            // 0x80a4be5
            v9 = 0;
            v7 = v1 + 0x1d18 + 72 * v5;
            v9++;
            while (v6 > v9) {
                // 0x80a4bf8
                v8 = v7;
                v7 = v8 + 4;
                if (*(int32_t *)v8 == Layer2) {
                    goto lab_0x80a4cb8_2;
                }
                v9++;
            }
        }
        int32_t v10 = v5 + 1; // 0x80a4c0c
        int32_t v11 = v1 + 72; // 0x80a4c1a
        while (v4 > v10) {
            int32_t v12 = v11;
            v5 = v10;
            v6 = *(int32_t *)(v1 + 0x1cd4 + 4 * v5);
            if (v6 != 0) {
                // 0x80a4bd6
                if (*(int32_t *)(v12 + 0x1d14) == Layer2) {
                    goto lab_0x80a4cb8_2;
                }
                // 0x80a4be5
                v9 = 0;
                v7 = v1 + 0x1d18 + 72 * v5;
                v9++;
                while (v6 > v9) {
                    // 0x80a4bf8
                    v8 = v7;
                    v7 = v8 + 4;
                    if (*(int32_t *)v8 == Layer2) {
                        goto lab_0x80a4cb8_2;
                    }
                    v9++;
                }
            }
            // 0x80a4c0c
            v10 = v5 + 1;
            v11 = v12 + 72;
        }
    }
    goto lab_0x80a4c20;
  lab_0x80a4cb8_2:;
    int32_t v22; // 0x80a4b70
    int32_t v31; // 0x80a4b70
    int32_t v20; // 0x80a4b70
    int32_t v24; // 0x80a4b70
    if (v4 > v5) {
        // 0x80a4cc4
        v22 = 1;
        v31 = v6;
        v24 = v1 + 4 + 4 * (18 * v5 + 1859 + v6);
        v20 = v3;
        goto lab_0x80a4d0c;
    } else {
        goto lab_0x80a4c20;
    }
  lab_0x80a4c20:;
    int32_t result = 1; // 0x80a4c36
    int32_t v13 = v3; // 0x80a4c36
    goto lab_0x80a4c39;
  lab_0x80a4c39:
    // 0x80a4c39
    *(char *)(92 * Layer2 + 144 + v13) = On;
    if (On == 0 || ChangeStackOrder == 0) {
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    uint32_t v14 = *(int32_t *)(*v2 + 24); // 0x80a4c56
    if (v14 <= Layer2) {
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    if (v14 < 1) {
        // 0x80a4c97
        LayerStack[0] = Layer2;
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    // 0x80a4c61
    if (LayerStack[0] == Layer2) {
        // 0x80a4c97
        LayerStack[0] = Layer2;
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    int32_t v15 = 1; // 0x80a4c79
    int32_t v16 = 4 * v15 + (int32_t)&LayerStack;
    while (v14 > v15) {
        // 0x80a4c70
        if (*(int32_t *)v16 == Layer2) {
            // break -> 0x80a4c80
            break;
        }
        v15++;
        v16 = 4 * v15 + (int32_t)&LayerStack;
    }
    int32_t v17 = v16 - 4; // 0x80a4c88
    *(int32_t *)v16 = *(int32_t *)v17;
    int32_t v18 = v17; // 0x80a4c95
    while (v17 != (int32_t)&LayerStack) {
        // 0x80a4c88
        v17 = v18 - 4;
        *(int32_t *)v18 = *(int32_t *)v17;
        v18 = v17;
    }
    // 0x80a4c97
    LayerStack[0] = Layer2;
    // 0x80a4c9d
    hid_action("LayersChanged");
    return result;
  lab_0x80a4d0c:;
    int32_t v19 = v20;
    int32_t v21 = v22;
    int32_t v23 = *(int32_t *)v24; // 0x80a4d0c
    int32_t v25 = v21; // 0x80a4d14
    int32_t v26 = v19; // 0x80a4d14
    int32_t v27; // 0x80a4b70
    int32_t v28; // 0x80a4b70
    int32_t v29; // 0x80a4d38
    if (v23 == Layer2) {
        goto lab_0x80a4d05;
    } else {
        // 0x80a4d16
        v25 = v21;
        v26 = v19;
        if (v23 < *(int32_t *)(v19 + 24)) {
            // 0x80a4d1b
            *(char *)(v19 + 144 + 92 * v23) = On;
            v28 = *v2;
            if (On == 0 || ChangeStackOrder == 0) {
                // 0x80a4d01
                v25 = v21 + 1;
                v26 = v28;
                goto lab_0x80a4d05;
            } else {
                // 0x80a4d2f
                v29 = *(int32_t *)(v28 + 24);
                if (v23 < v29) {
                    if (v29 < 1) {
                        goto lab_0x80a4d77;
                    } else {
                        // 0x80a4d43
                        v27 = 0;
                        if (v23 != LayerStack[0]) {
                            goto lab_0x80a4d59;
                        } else {
                            goto lab_0x80a4d77;
                        }
                    }
                } else {
                    // 0x80a4d01
                    v25 = v21 + 1;
                    v26 = v28;
                    goto lab_0x80a4d05;
                }
            }
        } else {
            goto lab_0x80a4d05;
        }
    }
  lab_0x80a4d05:;
    int32_t v30 = v31 - 1; // 0x80a4d0e
    result = v25;
    v13 = v26;
    v22 = v25;
    v31 = v30;
    v24 -= 4;
    v20 = v26;
    if (v30 == 0) {
        goto lab_0x80a4c39;
    } else {
        goto lab_0x80a4d0c;
    }
  lab_0x80a4d77:
    // 0x80a4d77
    LayerStack[0] = v23;
    // 0x80a4d01
    v25 = v21 + 1;
    v26 = v28;
    goto lab_0x80a4d05;
  lab_0x80a4d59:;
    int32_t v32 = v27 + 1; // 0x80a4d59
    int32_t v33 = 4 * v32 + (int32_t)&LayerStack;
    int32_t v34; // 0x80a4b70
    if (v29 > v32) {
        // 0x80a4d50
        v27 = v32;
        if (v23 == *(int32_t *)v33) {
            // 0x80a4d60
            v34 = v33;
            goto lab_0x80a4d68;
        } else {
            goto lab_0x80a4d59;
        }
    } else {
        // 0x80a4d60
        v34 = v33;
        goto lab_0x80a4d68;
    }
  lab_0x80a4d68:;
    int32_t v35 = v34 - 4; // 0x80a4d68
    *(int32_t *)v34 = *(int32_t *)v35;
    v34 = v35;
    if (v35 != (int32_t)&LayerStack) {
        goto lab_0x80a4d68;
    } else {
        goto lab_0x80a4d77;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4dc0 - 0x80a4ec6
// Line range:    1341 - 1203
void ResetStackAndVisibility(void) {
    int32_t v1 = (int32_t)PCB; // 0x80a4dc9
    int32_t * v2 = (int32_t *)(v1 + 0x220c); // 0x80a4dcf
    int32_t v3 = *v2; // 0x80a4dcf
    int32_t * v4 = (int32_t *)(v3 + 24);
    uint32_t v5 = *v4; // 0x80a4dd5
    int32_t * v6 = v4; // 0x80a4ddb
    if (v5 != -2) {
        int32_t v7 = v3; // 0x80a4dc0
        uint32_t v8 = 0;
        if (v5 > v8) {
            // 0x80a4dec
            *(int32_t *)(4 * v8 + (int32_t)&LayerStack) = v8;
        }
        // 0x80a4df3
        *(char *)(v7 + 144) = 1;
        int32_t v9 = v8 + 1; // 0x80a4e02
        v7 += 92;
        while (v8 != v5 + 1) {
            // 0x80a4de8
            v8 = v9;
            if (v5 > v8) {
                // 0x80a4dec
                *(int32_t *)(4 * v8 + (int32_t)&LayerStack) = v8;
            }
            // 0x80a4df3
            *(char *)(v7 + 144) = 1;
            v9 = v8 + 1;
            v7 += 92;
        }
        // 0x80a4e04
        v6 = (int32_t *)(*v2 + 24);
    }
    // 0x80a4e0a
    *(char *)&g201 = 1;
    *(char *)&g203 = 1;
    *(char *)&g204 = 1;
    *(char *)&g200 = 1;
    *(char *)&g202 = 1;
    uint32_t v10 = *v6; // 0x80a4e1e
    if (v10 < 1) {
        // 0x80a4e98
        ChangeGroupVisibility(*(int32_t *)(v1 + 0x1d14), 1, 1);
        return;
    }
    int32_t v11 = v10 + 1; // 0x80a4e2d
    int32_t v12 = 0;
    uint32_t v13 = *(int32_t *)(v1 + 0x1cd4 + 4 * v12); // 0x80a4e3e
    int32_t v14; // 0x80a4dc0
    int32_t v15; // 0x80a4dc0
    int32_t v16; // 0x80a4dc0
    int32_t v17; // 0x80a4e4c
    int32_t v18; // 0x80a4e71
    if (v13 != 0) {
        // 0x80a4e49
        v17 = *(int32_t *)(v1 + 0x1d14);
        if (v11 == v17) {
            // 0x80a4e98
            ChangeGroupVisibility(v11, 1, 1);
            return;
        }
        // 0x80a4e59
        v18 = 0;
        v14 = v1 + 0x1d18 + 72 * v12;
        v18++;
        while (v13 > v18) {
            // 0x80a4e68
            v15 = v14;
            v14 = v15 + 4;
            v16 = v17;
            if (v11 == *(int32_t *)v15) {
                // 0x80a4e98
                ChangeGroupVisibility(v16, 1, 1);
                return;
            }
            v18++;
        }
    }
    int32_t v19 = v12 + 1; // 0x80a4e78
    int32_t v20 = v1 + 72; // 0x80a4e86
    while (v10 > v19) {
        // 0x80a4e3b
        v12 = v19;
        int32_t v21 = v20;
        v13 = *(int32_t *)(v1 + 0x1cd4 + 4 * v12);
        if (v13 != 0) {
            // 0x80a4e49
            v17 = *(int32_t *)(v21 + 0x1d14);
            if (v11 == v17) {
                // 0x80a4e98
                ChangeGroupVisibility(v11, 1, 1);
                return;
            }
            // 0x80a4e59
            v18 = 0;
            v14 = v1 + 0x1d18 + 72 * v12;
            v18++;
            while (v13 > v18) {
                // 0x80a4e68
                v15 = v14;
                v14 = v15 + 4;
                v16 = v17;
                if (v11 == *(int32_t *)v15) {
                    // 0x80a4e98
                    ChangeGroupVisibility(v16, 1, 1);
                    return;
                }
                v18++;
            }
        }
        // 0x80a4e78
        v19 = v12 + 1;
        v20 = v21 + 72;
    }
    // 0x80a4e98
    ChangeGroupVisibility(*(int32_t *)(v1 + 0x1d14 + 72 * v19), 1, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4ed0 - 0x80a5225
// Line range:    1081 - 1140
void LayerStringToLayerStack(char * s) {
    uint32_t len = strlen(s); // 0x80a4edf
    char * v1 = __strdup(s); // 0x80a4eee
    int32_t mem = (int32_t)calloc(1, 4 * len); // 0x80a4f07
    int32_t v2 = -1; // 0x80a4f11
    if (len >= 1) {
        int32_t v3 = 0; // 0x80a4f1e
        int32_t v4 = 0;
        int32_t v5 = (int32_t)v1;
        char * v6 = (char *)v5; // 0x80a4f20
        char v7 = *v6; // 0x80a4f20
        g277 = v7 - 9;
        int32_t v8; // 0x80a4ed0
        int32_t v9; // 0x80a4ed0
        switch (v7) {
            case 9: {
            }
            case 32: {
            }
            case 44: {
            }
            case 58: {
            }
            case 59: {
                // 0x80a4f40
                *v6 = 0;
                v8 = v4;
                v9 = 1;
                // break -> 0x80a4f48
                break;
            }
            default: {
                // 0x80a5020
                v8 = v4;
                v9 = 0;
                // 0x80a5028
                *(int32_t *)(4 * v4 + mem) = v5;
                v8 = v4 + 1;
                v9 = 0;
                // break -> 0x80a4f48
                break;
            }
        }
        int32_t v10 = v8;
        v3++;
        int32_t v11 = v5 + 1; // 0x80a4f50
        int32_t v12 = v9; // 0x80a4f50
        while (len != v3) {
            // 0x80a4f20
            v4 = v10;
            v5 = v11;
            v6 = (char *)v5;
            v7 = *v6;
            g277 = v7 - 9;
            switch (v7) {
                case 9: {
                }
                case 32: {
                }
                case 44: {
                }
                case 58: {
                }
                case 59: {
                    // 0x80a4f40
                    *v6 = 0;
                    v8 = v4;
                    v9 = 1;
                    // break -> 0x80a4f48
                    break;
                }
                default: {
                    // 0x80a5020
                    v8 = v4;
                    v9 = 0;
                    if (v12 != 0) {
                        // 0x80a5028
                        *(int32_t *)(4 * v4 + mem) = v5;
                        v8 = v4 + 1;
                        v9 = 0;
                    }
                    // break -> 0x80a4f48
                    break;
                }
            }
            // 0x80a4f48
            v10 = v8;
            v3++;
            v11 = v5 + 1;
            v12 = v9;
        }
        // 0x80a4f52
        v2 = v10 - 1;
    }
    int32_t * v13 = (int32_t *)((int32_t)PCB + 0x220c); // 0x80a4f5b
    int32_t v14 = *v13; // 0x80a4f5b
    uint32_t v15 = *(int32_t *)(v14 + 24); // 0x80a4f61
    if (v15 >= 0xffffffff) {
        int32_t v16 = 0;
        if (v16 < v15) {
            // 0x80a4f74
            *(int32_t *)(4 * v16 + (int32_t)&LayerStack) = v16;
        }
        int32_t v17 = v16 + 1; // 0x80a4f7e
        *(char *)(v14 + 144 + 92 * v16) = 0;
        int32_t v18 = *v13; // 0x80a4f89
        int32_t v19 = *(int32_t *)(v18 + 24); // 0x80a4f8f
        while (v19 + 1 >= v17) {
            // 0x80a4f70
            v16 = v17;
            if (v16 < v19) {
                // 0x80a4f74
                *(int32_t *)(4 * v16 + (int32_t)&LayerStack) = v16;
            }
            // 0x80a4f7b
            v17 = v16 + 1;
            *(char *)(v18 + 144 + 92 * v16) = 0;
            v18 = *v13;
            v19 = *(int32_t *)(v18 + 24);
        }
    }
    // 0x80a4f99
    *(char *)&g201 = 0;
    *(char *)&g203 = 0;
    *(char *)&g204 = 0;
    *(char *)&g200 = 0;
    *(char *)&g202 = 0;
    if (v2 == -1) {
        // 0x80a5012
        return;
    }
    int32_t v20 = v2; // 0x80a4fb8
    int32_t v21 = 4 * v2 + mem; // 0x80a4fb8
    int32_t v22; // 0x80a4ed0
    int32_t v23; // 0x80a4ed0
    while (true) {
      lab_0x80a4fd4_2:
        // 0x80a4fd4
        v23 = v21;
        v22 = v20;
        char * str = (char *)*(int32_t *)v23;
        if (strcasecmp(str, "rats") == 0) {
            // 0x80a4fc0
            *(char *)&g202 = 1;
            goto lab_0x80a4fc9;
        } else {
            // 0x80a4fea
            if (strcasecmp(str, "invisible") != 0) {
                // 0x80a5038
                if (strcasecmp(str, "pins") != 0) {
                    // 0x80a5060
                    if (strcasecmp(str, "vias") != 0) {
                        // 0x80a5088
                        if (strcasecmp(str, "elements") == 0) {
                            // 0x80a5128
                            *(char *)&g201 = 1;
                        } else {
                            int16_t * v24 = *__ctype_b_loc(); // 0x80a50a8
                            char v25 = *(char *)((int32_t)v24 + 1 + 2 * (int32_t)*str); // 0x80a50aa
                            if ((v25 & 8) != 0) {
                                // 0x80a51f0
                                ChangeGroupVisibility(strtol(str, NULL, 10), 1, 1);
                            } else {
                                int32_t v26 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80a50ba
                                uint32_t v27 = *(int32_t *)(v26 + 24); // 0x80a50c0
                                int32_t v28 = v26; // 0x80a50cd
                                if (v27 < 1) {
                                  lab_0x80a513c:
                                    // 0x80a513c
                                    __fprintf_chk((struct _IO_FILE *)g43, 1, "Warning: layer \"%s\" not known\n", str);
                                    if (g72 == 0) {
                                        // 0x80a516b
                                        __fprintf_chk((struct _IO_FILE *)g43, 1, "Named layers in this board are:\n");
                                        g72 = 1;
                                        int32_t v29 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80a5197
                                        int32_t v30 = v29; // 0x80a51a2
                                        int32_t v31 = 0; // 0x80a51a2
                                        if (*(int32_t *)(v29 + 24) >= 1) {
                                            int32_t v32 = v31 + 1; // 0x80a51b3
                                            int32_t v33 = *(int32_t *)(v30 + 76 + 92 * v31); // 0x80a51b6
                                            __fprintf_chk((struct _IO_FILE *)g43, 1, "\t%s\n", (char *)v33);
                                            int32_t v34 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80a51e0
                                            v31 = v32;
                                            while (*(int32_t *)(v34 + 24) > v32) {
                                                // 0x80a51b0
                                                v32 = v31 + 1;
                                                v33 = *(int32_t *)(v34 + 76 + 92 * v31);
                                                __fprintf_chk((struct _IO_FILE *)g43, 1, "\t%s\n", (char *)v33);
                                                v34 = *(int32_t *)((int32_t)PCB + 0x220c);
                                                v31 = v32;
                                            }
                                        }
                                    }
                                } else {
                                    int32_t v35 = 0;
                                    int32_t v36 = v28;
                                    while (strcasecmp(str, (char *)*(int32_t *)(v36 + 76)) != 0) {
                                        int32_t v37 = v35 + 1; // 0x80a50e0
                                        v28 = v36 + 92;
                                        int32_t v38 = v37; // 0x80a50e9
                                        if (v37 >= v27) {
                                            goto lab_0x80a513c;
                                        }
                                        v35 = v38;
                                        v36 = v28;
                                    }
                                    // 0x80a50fe
                                    ChangeGroupVisibility(v35, 1, 1);
                                }
                            }
                        }
                    } else {
                        // 0x80a5074
                        *(char *)&g200 = 1;
                    }
                } else {
                    // 0x80a504c
                    *(char *)&g204 = 1;
                }
                goto lab_0x80a4fc9;
            } else {
                // 0x80a4ffe
                *(char *)&g203 = 1;
                if (v22 == 0) {
                    // break -> 0x80a5012
                    break;
                }
                // 0x80a4fd4
                v20 = v22 - 1;
                v21 = v23 - 4;
                goto lab_0x80a4fd4_2;
            }
        }
    }
  lab_0x80a4fc9:
    if (v22 == 0) {
        return;
    }
    // 0x80a4fd4
    v20 = v22 - 1;
    v21 = v23 - 4;
    goto lab_0x80a4fd4_2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5390 - 0x80a553c
// Line range:    900 - 105
char * EvaluateFilename(char * Template, char * Path, char * Filename, char * Parameter) {
    // 0x80a5390
    if (g115 != 0) {
        // 0x80a54c0
        __printf_chk(1, "EvaluateFilename:\n");
        __printf_chk(1, (char *)&g9);
        __printf_chk(1, (char *)&g10);
        __printf_chk(1, (char *)&g11);
        __printf_chk(1, (char *)&g12);
    }
    // 0x80a53b6
    DSClearString(&g73);
    int32_t v1 = (int32_t)Template; // 0x80a53ca
    int32_t v2; // 0x80a5390
    if (Template != NULL) {
        while (true) {
          lab_0x80a53cc:;
            int32_t v3 = v1;
            char v4 = *(char *)v3; // 0x80a53cc
            if (v4 == 0) {
                // break (via goto) -> 0x80a5408
                goto lab_0x80a5408_3;
            }
            int32_t v5 = v3 + 1;
            while (v4 == 37) {
                char v6 = *(char *)v5; // 0x80a53de
                if (v6 != 112) {
                    if (v6 != 102) {
                        if (v6 != 97) {
                            // 0x80a5463
                            DSAddCharacter(&g73, v4);
                            v2 = v5;
                            goto lab_0x80a53c8;
                        } else {
                            // 0x80a54a5
                            DSAddString(&g73, Parameter);
                            v2 = v3 + 2;
                            goto lab_0x80a53c8;
                        }
                    } else {
                        // 0x80a5485
                        DSAddString(&g73, Filename);
                        v2 = v3 + 2;
                        goto lab_0x80a53c8;
                    }
                }
                int32_t v7 = v3 + 2; // 0x80a53ea
                DSAddString(&g73, Path);
                if (v7 == 0) {
                    // break (via goto) -> 0x80a5408
                    goto lab_0x80a5408_3;
                }
                v3 = v7;
                v4 = *(char *)v3;
                if (v4 == 0) {
                    // break (via goto) -> 0x80a5408
                    goto lab_0x80a5408_3;
                }
                // 0x80a53d3
                v5 = v3 + 1;
            }
            // 0x80a5463
            DSAddCharacter(&g73, v4);
            v2 = v5;
            goto lab_0x80a53c8;
        }
    }
  lab_0x80a5408_3:
    // 0x80a5408
    DSAddCharacter(&g73, 0);
    if (g115 != 0) {
        // 0x80a5426
        __printf_chk(1, (char *)&g13);
    }
    // 0x80a5443
    return MyStrdup(g74, "EvaluateFilename()");
  lab_0x80a53c8:
    // 0x80a53c8
    v1 = v2;
    if (v1 == 0) {
        // break -> 0x80a5408
        goto lab_0x80a5408_3;
    }
    goto lab_0x80a53cc;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5540 - 0x80a5930
// Line range:    704 - 771
int32_t ParseRouteString(char * s, int32_t * routeStyle, int32_t scale) {
    int32_t v1 = (int32_t)routeStyle;
    int32_t v2 = __readgsdword(20); // 0x80a5554
    __asm_rep_stosd_memset((char *)routeStyle, 0, 24);
    int16_t ** v3 = __ctype_b_loc(); // 0x80a556c
    char v4 = *s; // 0x80a5583
    int32_t * v5; // 0x80a5540
    int32_t * v6; // 0x80a5540
    int32_t v7; // 0x80a5540
    int32_t v8; // 0x80a5540
    int32_t v9; // 0x80a5540
    int32_t v10; // 0x80a5540
    char v11; // 0x80a5540
    char * v12; // 0x80a5540
    char * v13; // 0x80a5540
    int32_t v14; // 0x80a5540
    int32_t v15; // 0x80a5540
    if (v4 == 0) {
        // 0x80a5540
        v5 = (int32_t *)v3;
        v13 = s;
        v15 = 0;
        v10 = v1;
        goto lab_0x80a582e;
    } else {
        // 0x80a5540
        v7 = (int32_t)*v3 + 1;
        v6 = (int32_t *)v3;
        v12 = s;
        v14 = 0;
        v8 = (int32_t)s;
        v11 = v4;
        v9 = v1;
        goto lab_0x80a5594;
    }
  lab_0x80a582e:;
    int32_t * v16 = v5; // 0x80a5830
    char * v17 = v13; // 0x80a5830
    int32_t v18 = v15; // 0x80a5830
    int32_t v19 = 0; // 0x80a5830
    int32_t v20 = v10; // 0x80a5830
    goto lab_0x80a55fb_2;
  lab_0x80a56df:;
    // 0x80a56df
    int32_t * v22; // 0x80a5540
    int32_t v21; // 0x80a5540
    int16_t v40; // 0x80a5540
    int16_t v46; // 0x80a5540
    char * v39; // 0x80a5540
    char * v47; // 0x80a5540
    char * v48; // 0x80a5540
    int32_t result; // 0x80a5540
    int32_t v49; // 0x80a5717
    if ((v40 & 2048) == 0) {
        // 0x80a5861
        __asm_rep_stosd_memset((char *)v21, 0, 24);
        result = 1;
        goto lab_0x80a583a;
    } else {
        // 0x80a56e8
        GetNum((char **)v39, &g279);
        int32_t * v50 = (int32_t *)(v21 + 4); // 0x80a56f9
        *v50 = *v50 * scale;
        char v51 = *v39; // 0x80a5706
        if (v51 == 0) {
            // 0x80a5861
            __asm_rep_stosd_memset((char *)v21, 0, 24);
            result = 1;
            goto lab_0x80a583a;
        } else {
            // 0x80a5711
            v49 = *v22;
            unsigned char v52 = v51;
            int32_t v53 = (int32_t)v39;
            int32_t v54 = v53 + 1;
            while ((*(char *)(v49 + 1 + (0x1000000 * (int32_t)v52 >> 23)) & 32) != 0) {
                char v55 = *(char *)v54; // 0x80a5729
                if (v55 == 0) {
                    // 0x80a5861
                    __asm_rep_stosd_memset((char *)v21, 0, 24);
                    result = 1;
                    goto lab_0x80a583a;
                }
                v52 = v55;
                v53 = v54;
                v54 = v53 + 1;
            }
            if (v52 != 44) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v21, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v56 = (char *)v54; // 0x80a5744
                unsigned char v57 = *v56; // 0x80a5750
                v47 = v56;
                if (v57 == 0) {
                    goto lab_0x80a578c;
                } else {
                    // 0x80a5758
                    if ((*(int16_t *)((0x1000000 * (int32_t)v57 >> 23) + v49) & 0x2000) == 0) {
                        goto lab_0x80a578f;
                    } else {
                        int32_t v58 = v53 + 2;
                        char * v59 = (char *)v58;
                        unsigned char v60 = *v59; // 0x80a5785
                        v47 = v59;
                        while (v60 != 0) {
                            int16_t v61 = *(int16_t *)((0x1000000 * (int32_t)v60 >> 23) + v49); // 0x80a5776
                            int32_t v62 = v58 + 1; // 0x80a577d
                            v48 = v59;
                            v46 = v61;
                            if ((v61 & 0x2000) == 0) {
                                goto lab_0x80a578f;
                            }
                            v58 = v62;
                            v59 = (char *)v58;
                            v60 = *v59;
                            v47 = v59;
                        }
                        goto lab_0x80a578c;
                    }
                }
            }
        }
    }
  lab_0x80a578f:;
    // 0x80a578f
    char * v63; // 0x80a5540
    if ((v46 & 2048) == 0) {
        // 0x80a5861
        __asm_rep_stosd_memset((char *)v21, 0, 24);
        result = 1;
        goto lab_0x80a583a;
    } else {
        char * v64 = v48;
        GetNum((char **)v64, &g279);
        int32_t * v65 = (int32_t *)(v21 + 8); // 0x80a57a9
        *v65 = *v65 * scale;
        if (*v64 == 44) {
            int32_t v66 = (int32_t)v64; // 0x80a57b0
            char * v67 = (char *)(v66 + 1); // 0x80a5873
            unsigned char v68 = *v67; // 0x80a5879
            int16_t v69; // 0x80a5540
            char * v70; // 0x80a5540
            if (v68 == 0) {
                // 0x80a591b
                v70 = v67;
                v69 = *(int16_t *)*v22;
            } else {
                int32_t v71 = *v22; // 0x80a588e
                int16_t v72 = *(int16_t *)(v71 + (0x1000000 * (int32_t)v68 >> 23)); // 0x80a5890
                v70 = v67;
                v69 = v72;
                if ((v72 & 0x2000) != 0) {
                    int32_t v73 = v66 + 2;
                    char * v74 = (char *)v73;
                    unsigned char v75 = *v74; // 0x80a58b5
                    while (v75 != 0) {
                        int16_t v76 = *(int16_t *)((0x1000000 * (int32_t)v75 >> 23) + v71); // 0x80a58a6
                        int32_t v77 = v73 + 1; // 0x80a58ad
                        v70 = v74;
                        v69 = v76;
                        if ((v76 & 0x2000) == 0) {
                            goto lab_0x80a58bf;
                        }
                        v73 = v77;
                        v74 = (char *)v73;
                        v75 = *v74;
                    }
                    // 0x80a58bc
                    v70 = v74;
                    v69 = *(int16_t *)v71;
                }
            }
          lab_0x80a58bf:
            // 0x80a58bf
            if ((v69 & 2048) == 0) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v21, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v78 = v70;
                GetNum((char **)v78, &g279);
                int32_t * v79 = (int32_t *)(v21 + 12); // 0x80a58d5
                *v79 = *v79 * scale;
                unsigned char v80 = *v78; // 0x80a58e2
                v63 = v78;
                if (v80 != 0) {
                    int32_t v81 = *v22 + 1; // 0x80a590f
                    v63 = v78;
                    if ((*(char *)(v81 + (0x1000000 * (int32_t)v80 >> 23)) & 32) != 0) {
                        int32_t v82 = (int32_t)v78; // 0x80a58f8
                        v82++;
                        char * v83 = (char *)v82;
                        unsigned char v84 = *v83; // 0x80a5901
                        v63 = v83;
                        while (v84 != 0) {
                            // 0x80a590c
                            v63 = v83;
                            if ((*(char *)((0x1000000 * (int32_t)v84 >> 23) + v81) & 32) == 0) {
                                // break -> 0x80a57c6
                                break;
                            }
                            v82++;
                            v83 = (char *)v82;
                            v84 = *v83;
                            v63 = v83;
                        }
                    }
                }
                goto lab_0x80a57c6;
            }
        } else {
            // 0x80a57bf
            *(int32_t *)(v21 + 12) = 1000;
            v63 = v64;
            goto lab_0x80a57c6;
        }
    }
  lab_0x80a5594:;
    int32_t v85 = v9;
    int32_t v86 = v14;
    int32_t * v87 = v6;
    int32_t v88 = v7;
    char v89 = *(char *)((0x1000000 * (int32_t)v11 >> 23) + v88); // 0x80a55b7
    int32_t v90 = v8; // 0x80a55bc
    char v91 = v11; // 0x80a55bc
    char * v92 = v12; // 0x80a55bc
    if ((v89 & 32) != 0) {
        int32_t v93 = v90 + 1; // 0x80a55a0
        char * v94 = (char *)v93;
        unsigned char v95 = *v94; // 0x80a55a9
        v5 = v87;
        v13 = v94;
        v15 = v86;
        v10 = v85;
        if (v95 == 0) {
            goto lab_0x80a582e;
        }
        // 0x80a55b4
        v90 = v93;
        v91 = v95;
        v92 = v94;
        while ((*(char *)((0x1000000 * (int32_t)v95 >> 23) + v88) & 32) != 0) {
            // 0x80a55a0
            v93 = v90 + 1;
            v94 = (char *)v93;
            v95 = *v94;
            v5 = v87;
            v13 = v94;
            v15 = v86;
            v10 = v85;
            if (v95 == 0) {
                goto lab_0x80a582e;
            }
            // 0x80a55b4
            v90 = v93;
            v91 = v95;
            v92 = v94;
        }
    }
    char * v96 = v92;
    char v97 = v91; // 0x80a55c4
    v5 = v87;
    v13 = v96;
    v15 = v86;
    v10 = v85;
    int32_t v25; // bp-288, 0x80a5540
    switch (v97) {
        case 44: {
            goto lab_0x80a582e;
        }
        case 0: {
            goto lab_0x80a582e;
        }
        default: {
            int32_t v98 = (int32_t)v96; // 0x80a55e4
            int32_t v99 = 0; // 0x80a5540
            char v100 = v97; // 0x80a55f3
            int32_t v101; // 0x80a55ea
            char * v102; // 0x80a5540
            while (true) {
              lab_0x80a55e4:
                // 0x80a55e4
                v98++;
                *(char *)(v99 + (int32_t)&v25) = v100;
                v101 = v99 + 1;
                v102 = (char *)v98;
                v100 = *v102;
                v99 = v101;
                switch (v100) {
                    case 44: {
                        goto lab_0x80a55fb;
                    }
                    case 0: {
                        goto lab_0x80a55fb;
                    }
                    default: {
                        goto lab_0x80a55e4;
                    }
                }
            }
          lab_0x80a55fb:
            // 0x80a55fb
            v16 = v87;
            v17 = v102;
            v18 = v86;
            v19 = v101;
            v20 = v85;
            goto lab_0x80a55fb_2;
        }
    }
  lab_0x80a55fb_2:
    // 0x80a55fb
    v21 = v20;
    v22 = v16;
    int32_t v23; // bp-4, 0x80a5540
    *(char *)((int32_t)&v23 - 284 + v19) = 0;
    char * v24 = MyStrdup((char *)&v25, "ParseRouteString()"); // 0x80a560e
    *(int32_t *)(v21 + 16) = (int32_t)v24;
    int32_t v26 = (int32_t)v17 + 1; // 0x80a5624
    char * v27 = (char *)v26; // 0x80a5627
    char * v28; // 0x80a5540
    int32_t v29; // 0x80a5668
    if ((*(char *)(*v22 + 1 + 2 * (int32_t)*v27) & 8) == 0) {
        // 0x80a5861
        __asm_rep_stosd_memset((char *)v21, 0, 24);
        result = 1;
        goto lab_0x80a583a;
    } else {
        // 0x80a563c
        GetNum((char **)v26, &g279);
        int32_t * v30 = (int32_t *)v21; // 0x80a564c
        *v30 = *v30 * scale;
        char v31 = *v27; // 0x80a5657
        if (v31 == 0) {
            // 0x80a5861
            __asm_rep_stosd_memset((char *)v21, 0, 24);
            result = 1;
            goto lab_0x80a583a;
        } else {
            // 0x80a5662
            v29 = *v22;
            unsigned char v32 = v31;
            int32_t v33 = v26;
            int32_t v34 = v33 + 1;
            while ((*(char *)(v29 + 1 + (0x1000000 * (int32_t)v32 >> 23)) & 32) != 0) {
                char v35 = *(char *)v34; // 0x80a5679
                if (v35 == 0) {
                    // 0x80a5861
                    __asm_rep_stosd_memset((char *)v21, 0, 24);
                    result = 1;
                    goto lab_0x80a583a;
                }
                v32 = v35;
                v33 = v34;
                v34 = v33 + 1;
            }
            if (v32 != 44) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v21, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v36 = (char *)v34; // 0x80a5694
                unsigned char v37 = *v36; // 0x80a56a0
                v28 = v36;
                if (v37 == 0) {
                    goto lab_0x80a56dc;
                } else {
                    int16_t v38 = *(int16_t *)((0x1000000 * (int32_t)v37 >> 23) + v29); // 0x80a56ab
                    v39 = v36;
                    v40 = v38;
                    if ((v38 & 0x2000) == 0) {
                        goto lab_0x80a56df;
                    } else {
                        int32_t v41 = v33 + 2;
                        char * v42 = (char *)v41;
                        unsigned char v43 = *v42; // 0x80a56d5
                        v28 = v42;
                        while (v43 != 0) {
                            int16_t v44 = *(int16_t *)((0x1000000 * (int32_t)v43 >> 23) + v29); // 0x80a56c6
                            int32_t v45 = v41 + 1; // 0x80a56cd
                            v39 = v42;
                            v40 = v44;
                            if ((v44 & 0x2000) == 0) {
                                goto lab_0x80a56df;
                            }
                            v41 = v45;
                            v42 = (char *)v41;
                            v43 = *v42;
                            v28 = v42;
                        }
                        goto lab_0x80a56dc;
                    }
                }
            }
        }
    }
  lab_0x80a583a:
    // 0x80a583a
    if (v2 != __readgsdword(20)) {
        // 0x80a5928
        __stack_chk_fail();
        return &g279;
    }
    // 0x80a584a
    return result;
  lab_0x80a56dc:
    // 0x80a56dc
    v39 = v28;
    v40 = *(int16_t *)v29;
    goto lab_0x80a56df;
  lab_0x80a578c:
    // 0x80a578c
    v48 = v47;
    v46 = *(int16_t *)v49;
    goto lab_0x80a578f;
  lab_0x80a57c6:
    // 0x80a57c6
    result = 0;
    if (v18 == 3) {
        goto lab_0x80a583a;
    } else {
        char v103 = *v63; // 0x80a57d5
        if (v103 == 0) {
            // 0x80a5861
            __asm_rep_stosd_memset((char *)v21, 0, 24);
            result = 1;
            goto lab_0x80a583a;
        } else {
            int32_t v104 = *v22 + 1;
            unsigned char v105 = v103;
            int32_t v106 = (int32_t)v63 + 1;
            while ((*(char *)((0x1000000 * (int32_t)v105 >> 23) + v104) & 32) != 0) {
                char v107 = *(char *)v106; // 0x80a57f1
                if (v107 == 0) {
                    // 0x80a5861
                    __asm_rep_stosd_memset((char *)v21, 0, 24);
                    result = 1;
                    goto lab_0x80a583a;
                }
                v105 = v107;
                v106++;
            }
            if (v105 != 58) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v21, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v108 = (char *)v106; // 0x80a5808
                int32_t v109 = v18 + 1; // 0x80a5810
                char v110 = *v108; // 0x80a5820
                int32_t v111 = v21 + 24; // 0x80a5823
                v7 = v104;
                v6 = v22;
                v12 = v108;
                v14 = v109;
                v8 = v106;
                v11 = v110;
                v9 = v111;
                v5 = v22;
                v13 = v108;
                v15 = v109;
                v10 = v111;
                if (v110 != 0) {
                    goto lab_0x80a5594;
                } else {
                    goto lab_0x80a582e;
                }
            }
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5a10 - 0x80a5c3a
// Line range:    417 - 426
void SetTextBoundingBox(int32_t * FontPtr, int32_t * Text) {
    int32_t v1 = (int32_t)Text;
    int32_t v2 = *(int32_t *)(v1 + 52); // 0x80a5a1c
    int32_t v3 = 0; // 0x80a5a24
    int32_t v4 = 0; // 0x80a5a24
    int32_t v5 = 0; // 0x80a5a24
    if (v2 != 0) {
        char * v6 = (char *)v2; // 0x80a5a21
        char v7 = *v6; // 0x80a5a2a
        v3 = 0;
        v4 = 0;
        v5 = 0;
        if (v7 != 0) {
            int32_t v8 = (int32_t)FontPtr;
            int32_t v9 = 0;
            int32_t v10 = 0;
            int32_t v11 = 28 * (int32_t)v7 + v8; // 0x80a5a46
            int32_t v12; // 0x80a5a10
            int32_t v13; // 0x80a5a10
            int32_t v14; // 0x80a5a10
            int32_t v15; // 0x80a5a10
            int32_t v16; // 0x80a5a10
            int32_t v17; // 0x80a5a10
            int32_t v18; // 0x80a5bb9
            int32_t v19; // 0x80a5a56
            int32_t v20; // 0x80a5a84
            int32_t v21; // 0x80a5a87
            int32_t v22; // 0x80a5a90
            int32_t v23; // 0x80a5a92
            int32_t v24; // 0x80a5a68
            int32_t v25; // 0x80a5a6b
            int32_t v26; // 0x80a5a6d
            int32_t v27; // 0x80a5a70
            int32_t v28; // 0x80a5a10
            if (*(char *)(v11 + 28) == 0) {
                // 0x80a5ba8
                v18 = 6 * (*(int32_t *)(v8 + 16) - *(int32_t *)(v8 + 8));
                v28 = v10 + (int32_t)(v18 < 0) + ((int32_t)(0x66666667 * (int64_t)v18 / 0x100000000) >> 1);
                v15 = v9;
                v17 = *(int32_t *)(v8 + 20) - *(int32_t *)(v8 + 12);
            } else {
                // 0x80a5a56
                v16 = 0;
                v19 = *(int32_t *)(v11 + 32);
                v14 = v9;
                if (v19 != 0) {
                    // 0x80a5a60
                    v12 = *(int32_t *)(v11 + 24);
                    v27 = 0;
                    v13 = v9;
                    v24 = *(int32_t *)(v12 + 36);
                    v25 = v13 - v24;
                    v26 = v25 < 0 == ((v25 ^ v13) & (v24 ^ v13)) < 0 ? v13 : v24;
                    v27++;
                    v12 += 88;
                    v14 = v26;
                    while (v27 != v19) {
                        // 0x80a5a68
                        v13 = v26;
                        v24 = *(int32_t *)(v12 + 36);
                        v25 = v13 - v24;
                        v26 = v25 < 0 == ((v25 ^ v13) & (v24 ^ v13)) < 0 ? v13 : v24;
                        v27++;
                        v12 += 88;
                        v14 = v26;
                    }
                }
                // 0x80a5a7a
                v20 = *(int32_t *)(v11 + 40);
                v21 = *(int32_t *)(v11 + 44);
                v22 = v16 - v21;
                v23 = v22 < 0 == ((v22 ^ v16) & (v21 ^ v16)) < 0 ? v16 : v21;
                v28 = *(int32_t *)(v11 + 48) + v10 + v20;
                v15 = v14;
                v17 = v23;
            }
            int32_t v29 = v15;
            int32_t v30 = v28;
            int32_t v31 = (int32_t)v6 + 1; // 0x80a5a95
            v3 = v30;
            v4 = v29;
            v5 = v17;
            while (v31 != 0) {
                char * v32 = (char *)v31; // 0x80a5a95
                char v33 = *v32; // 0x80a5a9e
                int32_t v34 = v17; // 0x80a5aa3
                v3 = v30;
                v4 = v29;
                v5 = v17;
                if (v33 == 0) {
                    // break -> 0x80a5aa5
                    break;
                }
                v9 = v29;
                v10 = v30;
                v11 = 28 * (int32_t)v33 + v8;
                if (*(char *)(v11 + 28) == 0) {
                    // 0x80a5ba8
                    v18 = 6 * (*(int32_t *)(v8 + 16) - *(int32_t *)(v8 + 8));
                    v28 = v10 + (int32_t)(v18 < 0) + ((int32_t)(0x66666667 * (int64_t)v18 / 0x100000000) >> 1);
                    v15 = v9;
                    v17 = *(int32_t *)(v8 + 20) - *(int32_t *)(v8 + 12);
                } else {
                    // 0x80a5a56
                    v16 = v34;
                    v19 = *(int32_t *)(v11 + 32);
                    v14 = v9;
                    if (v19 != 0) {
                        // 0x80a5a60
                        v12 = *(int32_t *)(v11 + 24);
                        v27 = 0;
                        v13 = v9;
                        v24 = *(int32_t *)(v12 + 36);
                        v25 = v13 - v24;
                        v26 = v25 < 0 == ((v25 ^ v13) & (v24 ^ v13)) < 0 ? v13 : v24;
                        v27++;
                        v12 += 88;
                        v14 = v26;
                        while (v27 != v19) {
                            // 0x80a5a68
                            v13 = v26;
                            v24 = *(int32_t *)(v12 + 36);
                            v25 = v13 - v24;
                            v26 = v25 < 0 == ((v25 ^ v13) & (v24 ^ v13)) < 0 ? v13 : v24;
                            v27++;
                            v12 += 88;
                            v14 = v26;
                        }
                    }
                    // 0x80a5a7a
                    v20 = *(int32_t *)(v11 + 40);
                    v21 = *(int32_t *)(v11 + 44);
                    v22 = v16 - v21;
                    v23 = v22 < 0 == ((v22 ^ v16) & (v21 ^ v16)) < 0 ? v16 : v21;
                    v28 = *(int32_t *)(v11 + 48) + v10 + v20;
                    v15 = v14;
                    v17 = v23;
                }
                // 0x80a5a95
                v29 = v15;
                v30 = v28;
                v31 = (int32_t)v32 + 1;
                v3 = v30;
                v4 = v29;
                v5 = v17;
            }
        }
    }
    float80_t v35 = (float80_t)*(int32_t *)(v1 + 36); // 0x80a5aad
    float80_t v36 = v35 / 100.0L; // 0x80a5ab2
    int32_t v37 = v36 * (float80_t)v3; // 0x80a5ad0
    int32_t v38 = v36 * (float80_t)v5; // 0x80a5ade
    int32_t v39 = v35 / 200.0L * (float80_t)v4; // 0x80a5afa
    int32_t v40 = *(int32_t *)(v1 + 44); // 0x80a5b03
    int32_t v41 = v39 - 399; // 0x80a5b06
    int32_t v42 = v41 == 0 | v41 < 0 != (398 - v39 & v39) < 0 ? 400 : v39; // 0x80a5b0b
    int32_t v43 = *(int32_t *)(v1 + 40); // 0x80a5b0e
    int32_t * v44 = (int32_t *)(v1 + 4); // 0x80a5b15
    *v44 = v40;
    *Text = v43 - v42;
    int32_t * v45; // 0x80a5a10
    int32_t * v46; // 0x80a5a10
    if (*(char *)(v1 + 20) < 0) {
        int32_t v47 = v42 + v40; // 0x80a5bda
        *v44 = v47;
        int32_t * v48 = (int32_t *)(v1 + 8);
        *v48 = v43 + v37;
        int32_t * v49 = (int32_t *)(v1 + 12);
        *v49 = -2 * v42 - v38 + v47;
        RotateBoxLowLevel(Text, v43, v40, -*(char *)(v1 + 48) % 4);
        v46 = v49;
        v45 = v48;
    } else {
        int32_t v50 = v40 - v42; // 0x80a5b2e
        *v44 = v50;
        int32_t * v51 = (int32_t *)(v1 + 8);
        *v51 = v43 + v37;
        int32_t * v52 = (int32_t *)(v1 + 12);
        *v52 = 2 * v42 + v38 + v50;
        RotateBoxLowLevel(Text, v43, v40, *(char *)(v1 + 48));
        v46 = v52;
        v45 = v51;
    }
    int32_t * v53 = v46;
    *Text = *Text - g210;
    *v44 = *v44 - g210;
    int32_t v54 = *v45 + g210; // 0x80a5b81
    *v45 = v54;
    *v45 = v54 + 1;
    *v53 = g210 + 1 + *v53;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5c40 - 0x80a5df0
// Line range:    175 - 189
void SetPadBoundingBox(int32_t * Pad) {
    // 0x80a5c40
    int3_t v1; // 0x80a5c40
    int3_t v2 = v1;
    int32_t v3 = (int32_t)Pad;
    int32_t * v4 = (int32_t *)(v3 + 48); // 0x80a5c52
    int32_t * v5 = (int32_t *)(v3 + 44); // 0x80a5c55
    int32_t v6 = *v5; // 0x80a5c55
    int32_t v7 = *(int32_t *)(v3 + 36) + 1 + *(int32_t *)(v3 + 40); // 0x80a5c58
    int32_t v8 = v7 + (int32_t)(v7 < 0) >> 1; // 0x80a5c66
    int32_t v9 = *(int32_t *)(v3 + 84) + 1; // 0x80a5c6b
    int32_t * v10 = (int32_t *)(v3 + 68); // 0x80a5c76
    int32_t v11 = *v10; // 0x80a5c76
    int32_t v12 = v9 + (int32_t)(v9 < 0) >> 1; // 0x80a5c79
    int32_t v13 = v8 - v12; // 0x80a5c7b
    int32_t v14 = v13 < 0 == ((v13 ^ v8) & (v12 ^ v8)) < 0 ? v8 : v12; // 0x80a5c7d
    int32_t * v15 = (int32_t *)(v3 + 64); // 0x80a5c80
    int32_t v16 = *v15; // 0x80a5c80
    int32_t v17 = v16 - v6; // 0x80a5c85
    int32_t * v18; // 0x80a5c40
    int32_t * v19; // 0x80a5c40
    int32_t v20; // 0x80a5c40
    int32_t v21; // 0x80a5c40
    if (v17 == 0) {
        goto lab_0x80a5c92;
    } else {
        // 0x80a5c8c
        if (*(char *)(v3 + 21) % 2 != 0) {
            int32_t v22 = v11 - *v4; // 0x80a5cda
            if (v22 == 0) {
                goto lab_0x80a5c92;
            } else {
                int3_t v23 = v2 - 1; // 0x80a5ce2
                __frontend_reg_store_fpr(v23, (float80_t)v17);
                __frontend_reg_load_fpr(v23);
                __frontend_reg_store_fpr(v23, (float80_t)v22);
                atan2((float64_t)__frontend_reg_load_fpr(v23), (float64_t)(int64_t)&g279);
                __frontend_reg_store_fpr(v23, (float80_t)v14);
                float80_t v24 = __frontend_reg_load_fpr(v23); // 0x80a5d08
                __frontend_reg_store_fpr(v23, __frontend_reg_load_fpr(v2));
                __frontend_reg_store_fpr(v2, v24);
                __frontend_reg_store_fpr(v23, __frontend_reg_load_fpr(v23));
                int3_t v25 = v2 - 2; // 0x80a5d10
                __frontend_reg_store_fpr(v25, 0.785398163397448278999L);
                __frontend_reg_store_fpr(v23, __frontend_reg_load_fpr(v25) + __frontend_reg_load_fpr(v23));
                __frontend_reg_load_fpr(v23);
                float80_t v26 = __frontend_reg_load_fpr(v2); // 0x80a5d1b
                function_8060d88(v26);
                float64_t v27; // 0x80a5c40
                __frontend_reg_store_fpr(v2, (float80_t)v27);
                __frontend_reg_store_fpr(v23, v26);
                __frontend_reg_store_fpr(v25, (float80_t)v27);
                __frontend_reg_store_fpr(v25, __frontend_reg_load_fpr(v25) * __frontend_reg_load_fpr(v23));
                int3_t v28 = v2 - 3; // 0x80a5d35
                __frontend_reg_store_fpr(v28, 1.41421356237309514547L);
                __frontend_reg_store_fpr(v25, __frontend_reg_load_fpr(v25) * __frontend_reg_load_fpr(v28));
                float80_t v29 = __frontend_reg_load_fpr(v28); // 0x80a5d3d
                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v25));
                __frontend_reg_store_fpr(v25, v29);
                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v28));
                int32_t v30 = __frontend_reg_load_fpr(v28); // 0x80a5d4e
                float80_t v31 = __frontend_reg_load_fpr(v25); // 0x80a5d54
                __frontend_reg_store_fpr(v25, __frontend_reg_load_fpr(v2));
                __frontend_reg_store_fpr(v2, v31);
                __frontend_reg_store_fpr(v23, __frontend_reg_load_fpr(v25) * __frontend_reg_load_fpr(v23));
                __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v23) * __frontend_reg_load_fpr(v2));
                float80_t v32 = __frontend_reg_load_fpr(v2); // 0x80a5d5d
                int32_t v33 = *v15; // 0x80a5d60
                __frontend_reg_store_fpr(v2, v32);
                int32_t v34 = __frontend_reg_load_fpr(v2); // 0x80a5d69
                int32_t v35 = *v5; // 0x80a5d6f
                int32_t v36 = v33 + v30; // 0x80a5d72
                int32_t v37 = v33 + v34; // 0x80a5d74
                int32_t v38 = v36 - v37; // 0x80a5d79
                int32_t v39 = v38 == 0 | v38 < 0 != ((v38 ^ v36) & (v37 ^ v36)) < 0 ? v36 : v37; // 0x80a5d7d
                int32_t v40 = v35 - v34; // 0x80a5d80
                int32_t v41 = v39 - v40; // 0x80a5d83
                int32_t v42 = v41 < 0 == ((v41 ^ v39) & (v39 ^ v40)) < 0 == (v41 != 0) ? v40 : v39; // 0x80a5d85
                int32_t v43 = v35 - v30; // 0x80a5d88
                int32_t v44 = v42 - v43; // 0x80a5d8b
                int32_t v45 = v38 < 0 == ((v38 ^ v36) & (v37 ^ v36)) < 0 ? v36 : v37; // 0x80a5d92
                int32_t v46 = v45 - v40; // 0x80a5d95
                int32_t v47 = v46 < 0 == ((v46 ^ v45) & (v45 ^ v40)) < 0 ? v45 : v40; // 0x80a5d97
                int32_t v48 = *v10; // 0x80a5d9a
                int32_t v49 = v47 - v43; // 0x80a5d9d
                int32_t v50 = v49 < 0 == ((v49 ^ v47) & (v47 ^ v43)) < 0 ? v47 : v43; // 0x80a5d9f
                *Pad = v44 < 0 == ((v44 ^ v42) & (v42 ^ v43)) < 0 == (v44 != 0) ? v43 : v42;
                int32_t v51 = v48 + v34; // 0x80a5da9
                int32_t v52 = v48 - v30; // 0x80a5dac
                int32_t * v53 = (int32_t *)(v3 + 8);
                *v53 = v50;
                int32_t v54 = v52 - v51; // 0x80a5db4
                int32_t v55 = v54 == 0 | v54 < 0 != ((v54 ^ v52) & (v52 ^ v51)) < 0 ? v52 : v51; // 0x80a5db6
                int32_t v56 = *v4 - v34; // 0x80a5db9
                int32_t v57 = v55 - v56; // 0x80a5dbc
                int32_t v58 = v57 < 0 == ((v57 ^ v55) & (v55 ^ v56)) < 0 == (v57 != 0) ? v56 : v55; // 0x80a5dbe
                int32_t v59 = *v4 + v30; // 0x80a5dc7
                int32_t v60 = v58 - v59; // 0x80a5dcd
                int32_t v61 = v60 == 0 | v60 < 0 != ((v60 ^ v58) & (v58 ^ v59)) < 0 ? v58 : v59; // 0x80a5dd0
                int32_t v62 = v54 < 0 == ((v54 ^ v52) & (v52 ^ v51)) < 0 ? v52 : v51; // 0x80a5dd6
                int32_t v63 = v62 - v56; // 0x80a5dd9
                int32_t v64 = v63 < 0 == ((v63 ^ v62) & (v62 ^ v56)) < 0 ? v62 : v56; // 0x80a5ddb
                int32_t v65 = v64 - v59; // 0x80a5dde
                int32_t v66 = v65 < 0 == ((v65 ^ v64) & (v64 ^ v59)) < 0 ? v64 : v59; // 0x80a5de1
                *(int32_t *)(v3 + 4) = v61;
                int32_t * v67 = (int32_t *)(v3 + 12);
                *v67 = v66;
                v20 = v66;
                v19 = v53;
                v18 = v67;
                v21 = v50;
                goto lab_0x80a5cc2;
            }
        } else {
            goto lab_0x80a5c92;
        }
    }
  lab_0x80a5c92:;
    int32_t v68 = v6 - v16; // 0x80a5c92
    *Pad = (v68 < 0 == ((v68 ^ v6) & (v16 ^ v6)) < 0 == (v68 != 0) ? v16 : v6) - v14;
    int32_t v69 = *v5; // 0x80a5c9d
    int32_t v70 = v69 - v16; // 0x80a5c9d
    int32_t v71 = *v4; // 0x80a5ca4
    int32_t v72 = v71 - v11; // 0x80a5ca4
    int32_t v73 = v72 == 0 | v72 < 0 != ((v72 ^ v71) & (v71 ^ v11)) < 0 ? v71 : v11; // 0x80a5ca7
    int32_t v74 = (v70 < 0 == ((v70 ^ v69) & (v69 ^ v16)) < 0 ? v69 : v16) + v14; // 0x80a5cab
    int32_t * v75 = (int32_t *)(v3 + 8);
    *v75 = v74;
    int32_t v76 = *v4; // 0x80a5cb3
    int32_t v77 = v76 - v11; // 0x80a5cb3
    *(int32_t *)(v3 + 4) = v73 - v14;
    int32_t v78 = (v77 < 0 == ((v77 ^ v76) & (v76 ^ v11)) < 0 ? v76 : v11) + v14; // 0x80a5cbd
    int32_t * v79 = (int32_t *)(v3 + 12);
    *v79 = v78;
    v20 = v78;
    v19 = v75;
    v18 = v79;
    v21 = v74;
    goto lab_0x80a5cc2;
  lab_0x80a5cc2:
    // 0x80a5cc2
    *v18 = v20 + 1;
    *v19 = v21 + 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5df0 - 0x80a64a4
// Line range:    268 - 408
void SetElementBoundingBox(int32_t * Data, int32_t * Element, int32_t * Font) {
    int32_t v1 = (int32_t)Data;
    if (Data != NULL) {
        int32_t v2 = *(int32_t *)(v1 + 44); // 0x80a5e0c
        if (v2 != 0) {
            // 0x80a5e13
            r_delete_entry((int32_t *)v2, Element);
        }
    }
    int32_t v3 = (int32_t)Element;
    for (int32_t i = 2; i > -1; i--) {
        int32_t v4 = v3 + 36 + 60 * i; // 0x80a5e32
        if (Data == NULL) {
            // 0x80a6438
            SetTextBoundingBox(Font, (int32_t *)v4);
        } else {
            int32_t * v5 = (int32_t *)(v1 + 56 + 4 * i); // 0x80a5e3c
            int32_t v6 = *v5; // 0x80a5e3c
            int32_t * v7; // 0x80a5df0
            if (v6 == 0) {
                // 0x80a5e3c
                v7 = (int32_t *)v4;
            } else {
                int32_t * v8 = (int32_t *)v4;
                r_delete_entry((int32_t *)v6, v8);
                v7 = v8;
            }
            // 0x80a5e50
            SetTextBoundingBox(Font, v7);
            int32_t v9 = *v5; // 0x80a5e5f
            int32_t v10 = v9; // 0x80a5e65
            if (v9 == 0) {
                // 0x80a6458
                v10 = (int32_t)r_create_tree(NULL, 0, 0);
                *v5 = v10;
            }
            // 0x80a5e6b
            r_insert_entry((int32_t *)v10, v7, 0);
        }
    }
    int32_t v11 = *(int32_t *)(v3 + 240); // 0x80a5e8a
    int32_t * v12 = (int32_t *)(v3 + 4); // 0x80a5e90
    *v12 = 0x989680;
    *Element = 0x989680;
    int32_t * v13 = (int32_t *)(v3 + 12); // 0x80a5e9d
    *v13 = 0;
    int32_t * v14 = (int32_t *)(v3 + 8); // 0x80a5eaa
    *v14 = 0;
    if (v11 != 0) {
        int32_t v15 = 88 * v11; // 0x80a5ec4
        int32_t v16 = v11; // 0x80a5ec4
        v15 -= 88;
        int32_t v17 = *(int32_t *)(v3 + 264) + v15; // 0x80a5ecb
        SetLineBoundingBox((int32_t *)v17);
        int32_t v18 = *(int32_t *)(v17 + 44); // 0x80a5edc
        int32_t v19 = *(int32_t *)(v17 + 36) + 1; // 0x80a5edf
        int32_t v20 = v19 + (int32_t)(v19 < 0) >> 1; // 0x80a5ee9
        int32_t v21 = v18 - v20; // 0x80a5eed
        int32_t v22 = *Element; // 0x80a5ef0
        int32_t v23 = v22; // 0x80a5ef5
        if (v21 < v22) {
            // 0x80a5ef7
            *Element = v21;
            v23 = v21;
        }
        int32_t v24 = *(int32_t *)(v17 + 48); // 0x80a5ef9
        int32_t v25 = v24 - v20; // 0x80a5eff
        int32_t v26 = *v12; // 0x80a5f02
        int32_t v27 = v26; // 0x80a5f05
        int32_t v28 = v23; // 0x80a5f05
        if (v25 < v26) {
            // 0x80a5f07
            *v12 = v25;
            v27 = v25;
            v28 = *Element;
        }
        int32_t v29 = *(int32_t *)(v17 + 64); // 0x80a5f0a
        int32_t v30 = v29 - v20; // 0x80a5f0d
        int32_t v31 = v27; // 0x80a5f15
        if (v30 < v28) {
            // 0x80a5f17
            *Element = v30;
            v31 = *v12;
        }
        int32_t v32 = *(int32_t *)(v17 + 68); // 0x80a5f19
        int32_t v33 = v32 - v20; // 0x80a5f1c
        if (v33 < v31) {
            // 0x80a5f23
            *v12 = v33;
        }
        int32_t v34 = v20 + v18; // 0x80a5f33
        int32_t v35 = *v14; // 0x80a5f36
        int32_t v36 = v35; // 0x80a5f39
        if (v34 > v35) {
            // 0x80a5f3b
            *v14 = v34;
            v36 = v34;
        }
        int32_t v37 = v24 + v20; // 0x80a5f41
        int32_t v38 = *v13; // 0x80a5f44
        int32_t v39 = v38; // 0x80a5f47
        int32_t v40 = v36; // 0x80a5f47
        if (v37 > v38) {
            // 0x80a5f49
            *v13 = v37;
            v39 = v37;
            v40 = *v14;
        }
        int32_t v41 = v29 + v20; // 0x80a5f4c
        int32_t v42 = v39; // 0x80a5f52
        if (v41 > v40) {
            // 0x80a5f54
            *v14 = v41;
            v42 = *v13;
        }
        int32_t v43 = v32 + v20; // 0x80a5f57
        if (v43 > v42) {
            // 0x80a5f5e
            *v13 = v43;
        }
        while (v16 != 1) {
            // 0x80a5f61
            v16--;
            v15 -= 88;
            v17 = *(int32_t *)(v3 + 264) + v15;
            SetLineBoundingBox((int32_t *)v17);
            v18 = *(int32_t *)(v17 + 44);
            v19 = *(int32_t *)(v17 + 36) + 1;
            v20 = v19 + (int32_t)(v19 < 0) >> 1;
            v21 = v18 - v20;
            v22 = *Element;
            v23 = v22;
            if (v21 < v22) {
                // 0x80a5ef7
                *Element = v21;
                v23 = v21;
            }
            // 0x80a5ef9
            v24 = *(int32_t *)(v17 + 48);
            v25 = v24 - v20;
            v26 = *v12;
            v27 = v26;
            v28 = v23;
            if (v25 < v26) {
                // 0x80a5f07
                *v12 = v25;
                v27 = v25;
                v28 = *Element;
            }
            // 0x80a5f0a
            v29 = *(int32_t *)(v17 + 64);
            v30 = v29 - v20;
            v31 = v27;
            if (v30 < v28) {
                // 0x80a5f17
                *Element = v30;
                v31 = *v12;
            }
            // 0x80a5f19
            v32 = *(int32_t *)(v17 + 68);
            v33 = v32 - v20;
            if (v33 < v31) {
                // 0x80a5f23
                *v12 = v33;
            }
            // 0x80a5f26
            v34 = v20 + v18;
            v35 = *v14;
            v36 = v35;
            if (v34 > v35) {
                // 0x80a5f3b
                *v14 = v34;
                v36 = v34;
            }
            // 0x80a5f3e
            v37 = v24 + v20;
            v38 = *v13;
            v39 = v38;
            v40 = v36;
            if (v37 > v38) {
                // 0x80a5f49
                *v13 = v37;
                v39 = v37;
                v40 = *v14;
            }
            // 0x80a5f4c
            v41 = v29 + v20;
            v42 = v39;
            if (v41 > v40) {
                // 0x80a5f54
                *v14 = v41;
                v42 = *v13;
            }
            // 0x80a5f57
            v43 = v32 + v20;
            if (v43 > v42) {
                // 0x80a5f5e
                *v13 = v43;
            }
        }
    }
    int32_t v44 = *(int32_t *)(v3 + 248); // 0x80a5f73
    if (v44 != 0) {
        int32_t v45 = v44; // 0x80a5f8e
        int32_t v46 = 68 * v44; // 0x80a5f8e
        v46 -= 68;
        int32_t v47 = *(int32_t *)(v3 + 268) + v46; // 0x80a5f96
        int32_t * v48 = (int32_t *)v47; // 0x80a5f9e
        SetArcBoundingBox(v48);
        int32_t v49 = *v48; // 0x80a5fa3
        if (v49 < *Element) {
            // 0x80a5fac
            *Element = v49;
        }
        int32_t v50 = *(int32_t *)(v47 + 4); // 0x80a5fae
        if (v50 < *v12) {
            // 0x80a5fb6
            *v12 = v50;
        }
        int32_t v51 = *(int32_t *)(v47 + 8); // 0x80a5fb9
        if (v51 > *v14) {
            // 0x80a5fc1
            *v14 = v51;
        }
        int32_t v52 = *(int32_t *)(v47 + 12); // 0x80a5fc4
        if (v52 > *v13) {
            // 0x80a5fcc
            *v13 = v52;
        }
        // 0x80a5fcf
        v45--;
        while (v45 != 0) {
            // 0x80a5f90
            v46 -= 68;
            v47 = *(int32_t *)(v3 + 268) + v46;
            v48 = (int32_t *)v47;
            SetArcBoundingBox(v48);
            v49 = *v48;
            if (v49 < *Element) {
                // 0x80a5fac
                *Element = v49;
            }
            // 0x80a5fae
            v50 = *(int32_t *)(v47 + 4);
            if (v50 < *v12) {
                // 0x80a5fb6
                *v12 = v50;
            }
            // 0x80a5fb9
            v51 = *(int32_t *)(v47 + 8);
            if (v51 > *v14) {
                // 0x80a5fc1
                *v14 = v51;
            }
            // 0x80a5fc4
            v52 = *(int32_t *)(v47 + 12);
            if (v52 > *v13) {
                // 0x80a5fcc
                *v13 = v52;
            }
            // 0x80a5fcf
            v45--;
        }
    }
    int32_t * v53 = (int32_t *)(v3 + 272); // 0x80a5fdc
    *v53 = *Element;
    int32_t * v54 = (int32_t *)(v3 + 276); // 0x80a5fe5
    *v54 = *v12;
    int32_t * v55 = (int32_t *)(v3 + 280); // 0x80a5fee
    *v55 = *v14;
    int32_t * v56 = (int32_t *)(v3 + 284); // 0x80a5ff7
    *v56 = *v13;
    int32_t * v57 = (int32_t *)(v3 + 224); // 0x80a5ffd
    int32_t v58 = *v57; // 0x80a5ffd
    if (v58 != 0) {
        int32_t * v59 = (int32_t *)(v1 + 48);
        int32_t v60 = 0; // 0x80a60fa
        int32_t v61 = v58;
        int32_t v62 = 76 * v60 + *(int32_t *)(v3 + 256); // 0x80a610a
        int32_t * v63; // 0x80a5df0
        int32_t * v64; // 0x80a5df0
        int32_t v65; // 0x80a601b
        int32_t * v66; // 0x80a5df0
        int32_t * v67; // 0x80a5df0
        int32_t v68; // 0x80a6039
        int32_t v69; // 0x80a62cf
        if (Data != NULL) {
            // 0x80a6018
            v65 = *v59;
            if (v65 == 0) {
                // 0x80a6018
                v64 = (int32_t *)v62;
            } else {
                // 0x80a6022
                v67 = (int32_t *)v62;
                r_delete_entry((int32_t *)v65, v67);
                v64 = v67;
            }
            // 0x80a602e
            SetPinBoundingBox(v64);
            v68 = *v59;
            v69 = v68;
            if (v68 == 0) {
                // 0x80a62b8
                v69 = (int32_t)r_create_tree(NULL, 0, 0);
                *v59 = v69;
            }
            // 0x80a6044
            r_insert_entry((int32_t *)v69, v64, 0);
            v63 = v64;
        } else {
            // 0x80a6118
            v66 = (int32_t *)v62;
            SetPinBoundingBox(v66);
            v63 = v66;
        }
        int32_t v70 = *v63; // 0x80a6058
        if (v70 < *Element) {
            // 0x80a605e
            *Element = v70;
        }
        int32_t v71 = *(int32_t *)(v62 + 4); // 0x80a6060
        if (v71 < *v12) {
            // 0x80a6068
            *v12 = v71;
        }
        int32_t v72 = *(int32_t *)(v62 + 8); // 0x80a606b
        if (v72 > *v14) {
            // 0x80a6073
            *v14 = v72;
        }
        int32_t v73 = *(int32_t *)(v62 + 12); // 0x80a6076
        if (v73 > *v13) {
            // 0x80a607e
            *v13 = v73;
        }
        int32_t v74 = *(int32_t *)(v62 + 52); // 0x80a6081
        int32_t v75 = *(int32_t *)(v62 + 36); // 0x80a6084
        int32_t v76 = v75 + (int32_t)(v75 < 0) >> 1; // 0x80a6094
        int32_t v77 = v74 - v76; // 0x80a6098
        if (v77 < *v53) {
            // 0x80a60a5
            *v53 = v77;
        }
        int32_t v78 = *(int32_t *)(v62 + 56); // 0x80a60ab
        int32_t v79 = v78 - v76; // 0x80a60ae
        if (v79 < *v54) {
            // 0x80a60b8
            *v54 = v79;
        }
        int32_t v80 = v76 + v74; // 0x80a60cb
        if (v80 > *v55) {
            // 0x80a60d6
            *v55 = v80;
        }
        int32_t v81 = v78 + v76; // 0x80a60dc
        if (v81 > *v56) {
            // 0x80a60e6
            *v56 = v81;
        }
        uint32_t v82 = *v57; // 0x80a60ec
        while (v82 != 0) {
            // 0x80a60f6
            v60 = 1 - v61 + v60 + v82;
            if (v82 <= v60) {
                // break -> 0x80a6128
                break;
            }
            v61 = v82;
            v62 = 76 * v60 + *(int32_t *)(v3 + 256);
            if (Data != NULL) {
                // 0x80a6018
                v65 = *v59;
                if (v65 == 0) {
                    // 0x80a6018
                    v64 = (int32_t *)v62;
                } else {
                    // 0x80a6022
                    v67 = (int32_t *)v62;
                    r_delete_entry((int32_t *)v65, v67);
                    v64 = v67;
                }
                // 0x80a602e
                SetPinBoundingBox(v64);
                v68 = *v59;
                v69 = v68;
                if (v68 == 0) {
                    // 0x80a62b8
                    v69 = (int32_t)r_create_tree(NULL, 0, 0);
                    *v59 = v69;
                }
                // 0x80a6044
                r_insert_entry((int32_t *)v69, v64, 0);
                v63 = v64;
            } else {
                // 0x80a6118
                v66 = (int32_t *)v62;
                SetPinBoundingBox(v66);
                v63 = v66;
            }
            // 0x80a6058
            v70 = *v63;
            if (v70 < *Element) {
                // 0x80a605e
                *Element = v70;
            }
            // 0x80a6060
            v71 = *(int32_t *)(v62 + 4);
            if (v71 < *v12) {
                // 0x80a6068
                *v12 = v71;
            }
            // 0x80a606b
            v72 = *(int32_t *)(v62 + 8);
            if (v72 > *v14) {
                // 0x80a6073
                *v14 = v72;
            }
            // 0x80a6076
            v73 = *(int32_t *)(v62 + 12);
            if (v73 > *v13) {
                // 0x80a607e
                *v13 = v73;
            }
            // 0x80a6081
            v74 = *(int32_t *)(v62 + 52);
            v75 = *(int32_t *)(v62 + 36);
            v76 = v75 + (int32_t)(v75 < 0) >> 1;
            v77 = v74 - v76;
            if (v77 < *v53) {
                // 0x80a60a5
                *v53 = v77;
            }
            // 0x80a60ab
            v78 = *(int32_t *)(v62 + 56);
            v79 = v78 - v76;
            if (v79 < *v54) {
                // 0x80a60b8
                *v54 = v79;
            }
            // 0x80a60be
            v80 = v76 + v74;
            if (v80 > *v55) {
                // 0x80a60d6
                *v55 = v80;
            }
            // 0x80a60dc
            v81 = v78 + v76;
            if (v81 > *v56) {
                // 0x80a60e6
                *v56 = v81;
            }
            // 0x80a60ec
            v82 = *v57;
        }
    }
    int32_t * v83 = (int32_t *)(v3 + 232); // 0x80a6128
    int32_t v84 = *v83; // 0x80a6128
    int32_t * v85 = (int32_t *)(v3 + 260);
    int32_t * v86 = (int32_t *)(v1 + 52);
    int32_t v87 = 0; // 0x80a613c
    int32_t v88 = 0; // 0x80a613c
    int32_t v89; // 0x80a5df0
    uint32_t v90; // 0x80a5df0
    int32_t v91; // 0x80a5df0
    int32_t v92; // 0x80a63b8
    int32_t v93; // 0x80a63bb
    int32_t v94; // 0x80a63be
    int32_t v95; // 0x80a63c0
    while (true) {
        // 0x80a613f
        v90 = v84;
        if (v90 == 0) {
            // break (via goto) -> 0x80a62e0
            goto lab_0x80a62e0;
        }
        if (v90 <= v87) {
            // 0x80a63b8
            v92 = *v12;
            v93 = *v14;
            v94 = *Element;
            v95 = *v13;
            v91 = 0;
            v89 = *v85;
            goto lab_0x80a63e0;
        }
        int32_t v96 = *v85 + v88; // 0x80a6261
        int32_t * v97; // 0x80a5df0
        int32_t * v98; // 0x80a5df0
        int32_t * v99; // 0x80a5df0
        int32_t v100; // 0x80a6169
        int32_t v101; // 0x80a62a7
        int32_t v102; // 0x80a614b
        int32_t * v103; // 0x80a5df0
        if (Data != NULL) {
            // 0x80a6148
            v102 = *v86;
            if (v102 == 0) {
                // 0x80a6148
                v97 = (int32_t *)v96;
            } else {
                // 0x80a6152
                v99 = (int32_t *)v96;
                r_delete_entry((int32_t *)v102, v99);
                v97 = v99;
            }
            // 0x80a615e
            SetPadBoundingBox(v97);
            v100 = *v86;
            v101 = v100;
            if (v100 == 0) {
                // 0x80a6290
                v101 = (int32_t)r_create_tree(NULL, 0, 0);
                *v86 = v101;
            }
            // 0x80a6174
            r_insert_entry((int32_t *)v101, v97, 0);
            v98 = v97;
        } else {
            // 0x80a626f
            v103 = (int32_t *)v96;
            SetPadBoundingBox(v103);
            v98 = v103;
        }
        int32_t v104 = *v98; // 0x80a6188
        if (v104 < *Element) {
            // 0x80a618e
            *Element = v104;
        }
        int32_t v105 = *(int32_t *)(v96 + 4); // 0x80a6190
        if (v105 < *v12) {
            // 0x80a6198
            *v12 = v105;
        }
        int32_t v106 = *(int32_t *)(v96 + 8); // 0x80a619b
        if (v106 > *v14) {
            // 0x80a61a3
            *v14 = v106;
        }
        int32_t v107 = *(int32_t *)(v96 + 12); // 0x80a61a6
        if (v107 > *v13) {
            // 0x80a61ae
            *v13 = v107;
        }
        int32_t v108 = *(int32_t *)(v96 + 36); // 0x80a61b1
        int32_t v109 = *(int32_t *)(v96 + 64); // 0x80a61b4
        int32_t v110 = v108 + (int32_t)(v108 < 0) >> 1; // 0x80a61c1
        int32_t v111 = *(int32_t *)(v96 + 44); // 0x80a61c3
        int32_t v112 = v111 - v109; // 0x80a61cb
        int32_t v113 = v112 == 0 | v112 < 0 != ((v112 ^ v111) & (v111 ^ v109)) < 0 ? v111 : v109; // 0x80a61ce
        int32_t v114 = v113 - v110; // 0x80a61d1
        if (v114 < *v53) {
            // 0x80a61dc
            *v53 = v114;
        }
        int32_t v115 = *(int32_t *)(v96 + 68); // 0x80a61e2
        int32_t v116 = *(int32_t *)(v96 + 48); // 0x80a61e8
        int32_t v117 = v116 - v115; // 0x80a61ee
        int32_t v118 = v117 == 0 | v117 < 0 != ((v117 ^ v116) & (v116 ^ v115)) < 0 ? v116 : v115; // 0x80a61f1
        int32_t v119 = v118 - v110; // 0x80a61f4
        if (v119 < *v54) {
            // 0x80a61ff
            *v54 = v119;
        }
        int32_t v120 = (v112 < 0 == ((v112 ^ v111) & (v111 ^ v109)) < 0 ? v111 : v109) + v110; // 0x80a6216
        if (v120 > *v55) {
            // 0x80a6221
            *v55 = v120;
        }
        int32_t v121 = (v117 < 0 == ((v117 ^ v116) & (v116 ^ v115)) < 0 ? v116 : v115) + v110; // 0x80a622e
        if (v121 > *v56) {
            // 0x80a6239
            *v56 = v121;
        }
        int32_t v122 = *v83; // 0x80a623f
        while (v122 != v84) {
            // 0x80a624a
            v90 = v122;
            if (v90 == 0) {
                // break (via goto) -> 0x80a62e0
                goto lab_0x80a62e0;
            }
            if (v90 <= v87) {
                // 0x80a63b8
                v92 = *v12;
                v93 = *v14;
                v94 = *Element;
                v95 = *v13;
                v91 = 0;
                v89 = *v85;
                goto lab_0x80a63e0;
            }
            // 0x80a625b
            v96 = *v85 + v88;
            if (Data != NULL) {
                // 0x80a6148
                v102 = *v86;
                if (v102 == 0) {
                    // 0x80a6148
                    v97 = (int32_t *)v96;
                } else {
                    // 0x80a6152
                    v99 = (int32_t *)v96;
                    r_delete_entry((int32_t *)v102, v99);
                    v97 = v99;
                }
                // 0x80a615e
                SetPadBoundingBox(v97);
                v100 = *v86;
                v101 = v100;
                if (v100 == 0) {
                    // 0x80a6290
                    v101 = (int32_t)r_create_tree(NULL, 0, 0);
                    *v86 = v101;
                }
                // 0x80a6174
                r_insert_entry((int32_t *)v101, v97, 0);
                v98 = v97;
            } else {
                // 0x80a626f
                v103 = (int32_t *)v96;
                SetPadBoundingBox(v103);
                v98 = v103;
            }
            // 0x80a6188
            v104 = *v98;
            if (v104 < *Element) {
                // 0x80a618e
                *Element = v104;
            }
            // 0x80a6190
            v105 = *(int32_t *)(v96 + 4);
            if (v105 < *v12) {
                // 0x80a6198
                *v12 = v105;
            }
            // 0x80a619b
            v106 = *(int32_t *)(v96 + 8);
            if (v106 > *v14) {
                // 0x80a61a3
                *v14 = v106;
            }
            // 0x80a61a6
            v107 = *(int32_t *)(v96 + 12);
            if (v107 > *v13) {
                // 0x80a61ae
                *v13 = v107;
            }
            // 0x80a61b1
            v108 = *(int32_t *)(v96 + 36);
            v109 = *(int32_t *)(v96 + 64);
            v110 = v108 + (int32_t)(v108 < 0) >> 1;
            v111 = *(int32_t *)(v96 + 44);
            v112 = v111 - v109;
            v113 = v112 == 0 | v112 < 0 != ((v112 ^ v111) & (v111 ^ v109)) < 0 ? v111 : v109;
            v114 = v113 - v110;
            if (v114 < *v53) {
                // 0x80a61dc
                *v53 = v114;
            }
            // 0x80a61e2
            v115 = *(int32_t *)(v96 + 68);
            v116 = *(int32_t *)(v96 + 48);
            v117 = v116 - v115;
            v118 = v117 == 0 | v117 < 0 != ((v117 ^ v116) & (v116 ^ v115)) < 0 ? v116 : v115;
            v119 = v118 - v110;
            if (v119 < *v54) {
                // 0x80a61ff
                *v54 = v119;
            }
            // 0x80a6205
            v120 = (v112 < 0 == ((v112 ^ v111) & (v111 ^ v109)) < 0 ? v111 : v109) + v110;
            if (v120 > *v55) {
                // 0x80a6221
                *v55 = v120;
            }
            // 0x80a6227
            v121 = (v117 < 0 == ((v117 ^ v116) & (v116 ^ v115)) < 0 ? v116 : v115) + v110;
            if (v121 > *v56) {
                // 0x80a6239
                *v56 = v121;
            }
            // 0x80a623f
            v122 = *v83;
        }
        // 0x80a6280
        v87++;
        v88 += 104;
    }
  lab_0x80a62e0:;
    int32_t v123 = *Element; // 0x80a62f1
    int32_t v124 = *v14; // 0x80a62f1
    int32_t v125 = *v12; // 0x80a62f1
    int32_t v126 = *v13; // 0x80a62f1
    goto lab_0x80a62f4;
  lab_0x80a62f4:;
    int32_t v127 = *v57;
    if (v124 - v123 > v126 - v125) {
        if (v127 != 0) {
            int32_t v128 = *(int32_t *)(v3 + 256); // 0x80a630b
            int32_t * v129 = (int32_t *)(v128 + 20); // 0x80a6316
            *v129 = *v129 | 0x4000;
            int32_t v130 = v128; // 0x80a632f
            if (v127 != 1) {
                int32_t * v131 = (int32_t *)(v130 + 96); // 0x80a6320
                *v131 = *v131 | 0x4000;
                while (2 != v127) {
                    // 0x80a6320
                    v131 = (int32_t *)(v130 + 96);
                    *v131 = *v131 | 0x4000;
                    int32_t v132; // 0x80a5df0
                    int32_t v133 = v132 + 1; // 0x80a6327
                    v132 = v133;
                    v130 += 76;
                }
            }
        }
    } else {
        if (v127 != 0) {
            int32_t v134 = *(int32_t *)(v3 + 256); // 0x80a638a
            int32_t * v135 = (int32_t *)(v134 + 20); // 0x80a6395
            *v135 = *v135 & -0x4001;
            int32_t v136 = v134; // 0x80a63af
            if (v127 != 1) {
                int32_t * v137 = (int32_t *)(v136 + 96); // 0x80a63a0
                *v137 = *v137 & -0x4001;
                int32_t v138 = 2; // 0x80a63a7
                int32_t v139 = v138; // 0x80a63af
                v136 += 76;
                while (v138 != v127) {
                    // 0x80a63a0
                    v137 = (int32_t *)(v136 + 96);
                    *v137 = *v137 & -0x4001;
                    v138 = v139 + 1;
                    v139 = v138;
                    v136 += 76;
                }
            }
        }
    }
    // 0x80a6331
    *v13 = *v13 + 1;
    *v55 = *v55 + 1;
    *v56 = *v56 + 1;
    *v14 = v124 + 1;
    if (Data == NULL) {
        // 0x80a644c
        return;
    }
    int32_t * v140 = (int32_t *)(v1 + 44); // 0x80a635a
    int32_t v141 = *v140; // 0x80a635a
    int32_t v142 = v141; // 0x80a635f
    if (v141 == 0) {
        int32_t v143 = (int32_t)r_create_tree(NULL, 0, 0); // 0x80a6494
        *v140 = v143;
        v142 = v143;
    }
    // 0x80a6365
    r_insert_entry((int32_t *)v142, Element, 0);
  lab_0x80a63e0:;
    int32_t v144 = v89;
    int32_t v145 = *(int32_t *)(v144 + 48); // 0x80a63e0
    int32_t v146 = *(int32_t *)(v144 + 68); // 0x80a63e3
    if (v145 == v146) {
        int32_t v147 = *(int32_t *)(v144 + 64); // 0x80a641e
        if (v93 - v147 < *(int32_t *)(v144 + 44) - v94) {
            goto lab_0x80a63f4;
        } else {
            goto lab_0x80a6428;
        }
    } else {
        if (v95 - v146 < v145 - v92) {
            goto lab_0x80a63f4;
        } else {
            goto lab_0x80a6428;
        }
    }
  lab_0x80a63f4:;
    int32_t * v148 = (int32_t *)(v144 + 20); // 0x80a63f4
    *v148 = *v148 | 0x4000;
    goto lab_0x80a63fb;
  lab_0x80a6428:;
    int32_t * v150 = (int32_t *)(v144 + 20); // 0x80a6428
    *v150 = *v150 & -0x4001;
    goto lab_0x80a63fb;
  lab_0x80a63fb:;
    int32_t v149 = v91 + 1; // 0x80a63fb
    v123 = v94;
    v124 = v93;
    v125 = v92;
    v126 = v95;
    v91 = v149;
    v89 = v144 + 104;
    if (v149 < v90) {
        goto lab_0x80a63e0;
    } else {
        goto lab_0x80a62f4;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a65a0 - 0x80a6640
// Line range:    1731 - 1747
int32_t OldFlags(int32_t flags) {
    // 0x80a65a0
    int32_t v1; // 0x80a65a0
    uint32_t v2 = v1;
    int32_t v3 = __readgsdword(20); // 0x80a65b4
    int32_t v4 = 0x10000; // 0x80a65dc
    uint32_t v5 = 0;
    int32_t v6; // bp-4, 0x80a65a0
    char * v7; // 0x80a65fb
    if ((v4 & v2) != 0) {
        // 0x80a65e6
        v7 = (char *)((int32_t)&v6 - 36 + v5 / 2);
        *v7 = *v7 | (char)(1 << (4 * v5 & 4));
    }
    while (v5 != 7) {
        // 0x80a65e0
        v4 *= 2;
        v5++;
        if ((v4 & v2) != 0) {
            // 0x80a65e6
            v7 = (char *)((int32_t)&v6 - 36 + v5 / 2);
            *v7 = *v7 | (char)(1 << (4 * v5 & 4));
        }
    }
    int32_t v8 = __readgsdword(20); // 0x80a6610
    *(int32_t *)flags = v2 % 0x10000;
    *(int32_t *)(flags + 4) = 0;
    *(int32_t *)(flags + 8) = 0;
    if (v3 == v8) {
        // 0x80a6629
        return flags;
    }
    // 0x80a6633
    __stack_chk_fail();
    return &g279;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a6640 - 0x80a6690
// Line range:    1721 - 1727
int32_t MakeFlags(int32_t flags) {
    int32_t v1 = __readgsdword(20); // 0x80a6646
    int32_t v2 = __readgsdword(20); // 0x80a666e
    *(int32_t *)(flags + 4) = 0;
    *(int32_t *)(flags + 8) = 0;
    if (v1 == v2) {
        // 0x80a6685
        return flags;
    }
    // 0x80a6689
    __stack_chk_fail();
    return &g279;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/move.c
// Address range: 0x80a68a0 - 0x80a68bc
// Line range:    1168 - 1168
void register_move_action_list(void) {
    // 0x80a68a0
    hid_register_actions(&move_action_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/move.c
// Address range: 0x80a8490 - 0x80a8858
// Line range:    116 - 175
void MoveElementLowLevel(int32_t * Data, int32_t * Element, int32_t DX, int32_t DY) {
    int32_t v1 = (int32_t)Data;
    if (Data != NULL) {
        // 0x80a84ac
        r_delete_entry((int32_t *)*(int32_t *)(v1 + 44), Element);
    }
    int32_t v2 = (int32_t)Element;
    int32_t v3 = *(int32_t *)(v2 + 240); // 0x80a84c1
    if (v3 != 0) {
        int32_t v4 = 88 * v3; // 0x80a84da
        int32_t v5 = v3; // 0x80a84da
        v5--;
        v4 -= 88;
        int32_t v6 = *(int32_t *)(v2 + 264) + v4; // 0x80a84eb
        int32_t * v7 = (int32_t *)(v6 + 48); // 0x80a84f1
        *v7 = *v7 + DY;
        int32_t * v8 = (int32_t *)(v6 + 68); // 0x80a84f4
        *v8 = *v8 + DY;
        int32_t * v9 = (int32_t *)(v6 + 44); // 0x80a84f7
        *v9 = *v9 + DX;
        int32_t * v10 = (int32_t *)(v6 + 64); // 0x80a84fa
        *v10 = *v10 + DX;
        SetLineBoundingBox((int32_t *)v6);
        while (v5 != 0) {
            // 0x80a84e0
            v5--;
            v4 -= 88;
            v6 = *(int32_t *)(v2 + 264) + v4;
            v7 = (int32_t *)(v6 + 48);
            *v7 = *v7 + DY;
            v8 = (int32_t *)(v6 + 68);
            *v8 = *v8 + DY;
            v9 = (int32_t *)(v6 + 44);
            *v9 = *v9 + DX;
            v10 = (int32_t *)(v6 + 64);
            *v10 = *v10 + DX;
            SetLineBoundingBox((int32_t *)v6);
        }
    }
    int32_t * v11 = (int32_t *)(v2 + 224); // 0x80a8513
    int32_t v12 = *v11; // 0x80a8513
    if (v12 != 0) {
        int32_t * v13 = (int32_t *)(v1 + 48);
        int32_t v14 = 0; // 0x80a853c
        int32_t v15 = v12;
        int32_t v16 = 76 * v14 + *(int32_t *)(v2 + 256); // 0x80a8550
        int32_t * v17; // 0x80a8490
        int32_t * v18; // 0x80a8490
        if (Data == NULL) {
            // 0x80a854a
            v17 = (int32_t *)v16;
        } else {
            // 0x80a855a
            v18 = (int32_t *)v16;
            r_delete_entry((int32_t *)*v13, v18);
            RestoreToPolygon(Data, 256, (char *)Element, (char *)v16);
            v17 = v18;
        }
        int32_t * v19 = v17;
        int32_t * v20 = (int32_t *)(v16 + 52); // 0x80a8590
        *v20 = *v20 + DX;
        int32_t * v21 = (int32_t *)(v16 + 56); // 0x80a8593
        *v21 = *v21 + DY;
        *v19 = *v19 + DX;
        int32_t * v22 = (int32_t *)(v16 + 4); // 0x80a8598
        *v22 = *v22 + DY;
        int32_t * v23 = (int32_t *)(v16 + 8); // 0x80a859b
        *v23 = *v23 + DX;
        int32_t * v24 = (int32_t *)(v16 + 12); // 0x80a859e
        *v24 = *v24 + DY;
        if (Data != NULL) {
            // 0x80a85a5
            r_insert_entry((int32_t *)*v13, v19, 0);
            ClearFromPolygon(Data, 256, (char *)Element, (char *)v16);
        }
        uint32_t v25 = *v11; // 0x80a85e6
        while (v25 != 0) {
            // 0x80a8538
            v14 = 1 - v15 + v14 + v25;
            if (v25 <= v14) {
                // break -> 0x80a85fb
                break;
            }
            v15 = v25;
            v16 = 76 * v14 + *(int32_t *)(v2 + 256);
            if (Data == NULL) {
                // 0x80a854a
                v17 = (int32_t *)v16;
            } else {
                // 0x80a855a
                v18 = (int32_t *)v16;
                r_delete_entry((int32_t *)*v13, v18);
                RestoreToPolygon(Data, 256, (char *)Element, (char *)v16);
                v17 = v18;
            }
            // 0x80a8590
            v19 = v17;
            v20 = (int32_t *)(v16 + 52);
            *v20 = *v20 + DX;
            v21 = (int32_t *)(v16 + 56);
            *v21 = *v21 + DY;
            *v19 = *v19 + DX;
            v22 = (int32_t *)(v16 + 4);
            *v22 = *v22 + DY;
            v23 = (int32_t *)(v16 + 8);
            *v23 = *v23 + DX;
            v24 = (int32_t *)(v16 + 12);
            *v24 = *v24 + DY;
            if (Data != NULL) {
                // 0x80a85a5
                r_insert_entry((int32_t *)*v13, v19, 0);
                ClearFromPolygon(Data, 256, (char *)Element, (char *)v16);
            }
            // 0x80a85e3
            v25 = *v11;
        }
    }
    int32_t * v26 = (int32_t *)(v2 + 232); // 0x80a85fb
    uint32_t v27 = *v26; // 0x80a85fb
    if (v27 != 0 && v27 != 0) {
        int32_t * v28 = (int32_t *)(v1 + 52);
        uint32_t v29 = 0;
        int32_t v30; // 0x80a8490
        uint32_t v31; // 0x80a8490
        int32_t v32; // 0x80a86af
        int32_t * v33; // 0x80a8632
        char * v34; // 0x80a864a
        int32_t * v35; // 0x80a8655
        int32_t * v36; // 0x80a8658
        int32_t * v37; // 0x80a865b
        int32_t * v38; // 0x80a865e
        int32_t v39; // 0x80a8698
        int32_t * v40; // 0x80a86c3
        int32_t * v41; // 0x80a86c6
        int32_t * v42; // 0x80a86c9
        int32_t * v43; // 0x80a86cc
        int32_t v44; // 0x80a86d7
        while (true) {
            // 0x80a86ac
            v32 = *(int32_t *)(v2 + 260);
            if (Data != NULL) {
                // 0x80a8628
                v33 = (int32_t *)v32;
                r_delete_entry((int32_t *)*v28, v33);
                v34 = (char *)v32;
                RestoreToPolygon(Data, 512, (char *)Element, v34);
                v35 = (int32_t *)(v32 + 44);
                *v35 = *v35 + DX;
                v36 = (int32_t *)(v32 + 48);
                *v36 = *v36 + DY;
                v37 = (int32_t *)(v32 + 64);
                *v37 = *v37 + DX;
                v38 = (int32_t *)(v32 + 68);
                *v38 = *v38 + DY;
                SetPadBoundingBox(v33);
                r_insert_entry((int32_t *)*v28, v33, 0);
                ClearFromPolygon(Data, 512, (char *)Element, v34);
                v39 = *v26;
                v30 = v39;
                if (v39 == v27) {
                    // break -> 0x80a86e2
                    break;
                }
            } else {
                // 0x80a86bd
                v40 = (int32_t *)(v32 + 44);
                *v40 = *v40 + DX;
                v41 = (int32_t *)(v32 + 64);
                *v41 = *v41 + DX;
                v42 = (int32_t *)(v32 + 48);
                *v42 = *v42 + DY;
                v43 = (int32_t *)(v32 + 68);
                *v43 = *v43 + DY;
                SetPadBoundingBox((int32_t *)v32);
                v44 = *v26;
                v30 = v44;
                if (v44 == v27) {
                    // break -> 0x80a86e2
                    break;
                }
            }
            // 0x80a86a3
            v31 = v30;
            if (v31 == 0 || v29 >= v31) {
                // break (via goto) -> 0x80a86f0
                goto lab_0x80a86f0;
            }
        }
        int32_t v45 = v29 + 1; // 0x80a86e2
        int32_t v46 = 104 * v45; // 0x80a86a5
        while (v45 < v27) {
            // 0x80a86ac
            v29 = v45;
            while (true) {
                // 0x80a86ac
                v32 = *(int32_t *)(v2 + 260) + v46;
                if (Data != NULL) {
                    // 0x80a8628
                    v33 = (int32_t *)v32;
                    r_delete_entry((int32_t *)*v28, v33);
                    v34 = (char *)v32;
                    RestoreToPolygon(Data, 512, (char *)Element, v34);
                    v35 = (int32_t *)(v32 + 44);
                    *v35 = *v35 + DX;
                    v36 = (int32_t *)(v32 + 48);
                    *v36 = *v36 + DY;
                    v37 = (int32_t *)(v32 + 64);
                    *v37 = *v37 + DX;
                    v38 = (int32_t *)(v32 + 68);
                    *v38 = *v38 + DY;
                    SetPadBoundingBox(v33);
                    r_insert_entry((int32_t *)*v28, v33, 0);
                    ClearFromPolygon(Data, 512, (char *)Element, v34);
                    v39 = *v26;
                    v30 = v39;
                    if (v39 == v27) {
                        // break -> 0x80a86e2
                        break;
                    }
                } else {
                    // 0x80a86bd
                    v40 = (int32_t *)(v32 + 44);
                    *v40 = *v40 + DX;
                    v41 = (int32_t *)(v32 + 64);
                    *v41 = *v41 + DX;
                    v42 = (int32_t *)(v32 + 48);
                    *v42 = *v42 + DY;
                    v43 = (int32_t *)(v32 + 68);
                    *v43 = *v43 + DY;
                    SetPadBoundingBox((int32_t *)v32);
                    v44 = *v26;
                    v30 = v44;
                    if (v44 == v27) {
                        // break -> 0x80a86e2
                        break;
                    }
                }
                // 0x80a86a3
                v31 = v30;
                if (v31 == 0 || v29 >= v31) {
                    // break (via goto) -> 0x80a86f0
                    goto lab_0x80a86f0;
                }
            }
            // 0x80a86e2
            v45 = v29 + 1;
            v46 = 104 * v45;
        }
    }
  lab_0x80a86f0:;
    int32_t v47 = *(int32_t *)(v2 + 248); // 0x80a86f5
    if (v47 != 0) {
        int32_t v48 = v47; // 0x80a8715
        int32_t v49 = 68 * v47 - 68 + *(int32_t *)(v2 + 268); // 0x80a8715
        v48--;
        int32_t * v50 = (int32_t *)(v49 + 52); // 0x80a871b
        *v50 = *v50 + DX;
        int32_t * v51 = (int32_t *)(v49 + 56); // 0x80a871e
        *v51 = *v51 + DY;
        int32_t * v52 = (int32_t *)v49; // 0x80a8721
        *v52 = *v52 + DX;
        int32_t * v53 = (int32_t *)(v49 + 4); // 0x80a8723
        *v53 = *v53 + DY;
        int32_t * v54 = (int32_t *)(v49 + 8); // 0x80a8726
        *v54 = *v54 + DX;
        int32_t * v55 = (int32_t *)(v49 + 12); // 0x80a8729
        *v55 = *v55 + DY;
        v49 -= 68;
        while (v48 != 0) {
            // 0x80a8718
            v48--;
            v50 = (int32_t *)(v49 + 52);
            *v50 = *v50 + DX;
            v51 = (int32_t *)(v49 + 56);
            *v51 = *v51 + DY;
            v52 = (int32_t *)v49;
            *v52 = *v52 + DX;
            v53 = (int32_t *)(v49 + 4);
            *v53 = *v53 + DY;
            v54 = (int32_t *)(v49 + 8);
            *v54 = *v54 + DX;
            v55 = (int32_t *)(v49 + 12);
            *v55 = *v55 + DY;
            v49 -= 68;
        }
    }
    int32_t v56 = v1 + 56;
    int32_t v57 = v2; // 0x80a8743
    int32_t v58 = 2;
    int32_t v59 = v2 + 36 + 60 * v58; // 0x80a874e
    int32_t v60; // 0x80a8757
    int32_t v61; // 0x80a8768
    if (Data != NULL) {
        // 0x80a8757
        v60 = 4 * v58;
        if (*(int32_t *)(v60 + v56) != 0) {
            // 0x80a875f
            v61 = *(int32_t *)((int32_t)PCB + 0x220c);
            r_delete_entry((int32_t *)*(int32_t *)(v60 + 56 + v61), (int32_t *)v59);
        }
    }
    int32_t * v62 = (int32_t *)(v57 + 156); // 0x80a8783
    *v62 = *v62 + DX;
    int32_t * v63 = (int32_t *)(v57 + 160); // 0x80a8789
    *v63 = *v63 + DY;
    int32_t * v64 = (int32_t *)(v57 + 164); // 0x80a878f
    *v64 = *v64 + DX;
    int32_t * v65 = (int32_t *)(v57 + 168); // 0x80a8795
    *v65 = *v65 + DY;
    int32_t * v66 = (int32_t *)(v57 + 196); // 0x80a879b
    *v66 = *v66 + DX;
    int32_t * v67 = (int32_t *)(v57 + 200); // 0x80a87a1
    *v67 = *v67 + DY;
    int32_t v68; // 0x80a87cd
    int32_t v69; // 0x80a87ab
    if (Data != NULL) {
        // 0x80a87ab
        v69 = 4 * v58;
        if (*(int32_t *)(v69 + v56) != 0) {
            // 0x80a87b3
            v68 = *(int32_t *)(v69 + 56 + *(int32_t *)((int32_t)PCB + 0x220c));
            r_insert_entry((int32_t *)v68, (int32_t *)v59, 0);
        }
    }
    // 0x80a87df
    v57 -= 60;
    int32_t v70 = v58 - 1; // 0x80a87e8
    while (v58 != 0) {
        // 0x80a8746
        v58 = v70;
        v59 = v2 + 36 + 60 * v58;
        if (Data != NULL) {
            // 0x80a8757
            v60 = 4 * v58;
            if (*(int32_t *)(v60 + v56) != 0) {
                // 0x80a875f
                v61 = *(int32_t *)((int32_t)PCB + 0x220c);
                r_delete_entry((int32_t *)*(int32_t *)(v60 + 56 + v61), (int32_t *)v59);
            }
        }
        // 0x80a8780
        v62 = (int32_t *)(v57 + 156);
        *v62 = *v62 + DX;
        v63 = (int32_t *)(v57 + 160);
        *v63 = *v63 + DY;
        v64 = (int32_t *)(v57 + 164);
        *v64 = *v64 + DX;
        v65 = (int32_t *)(v57 + 168);
        *v65 = *v65 + DY;
        v66 = (int32_t *)(v57 + 196);
        *v66 = *v66 + DX;
        v67 = (int32_t *)(v57 + 200);
        *v67 = *v67 + DY;
        if (Data != NULL) {
            // 0x80a87ab
            v69 = 4 * v58;
            if (*(int32_t *)(v69 + v56) != 0) {
                // 0x80a87b3
                v68 = *(int32_t *)(v69 + 56 + *(int32_t *)((int32_t)PCB + 0x220c));
                r_insert_entry((int32_t *)v68, (int32_t *)v59, 0);
            }
        }
        // 0x80a87df
        v57 -= 60;
        v70 = v58 - 1;
    }
    int32_t * v71 = (int32_t *)(v2 + 4); // 0x80a87f4
    *v71 = *v71 + DY;
    int32_t * v72 = (int32_t *)(v2 + 12); // 0x80a87f7
    *v72 = *v72 + DY;
    int32_t * v73 = (int32_t *)(v2 + 276); // 0x80a87fa
    *v73 = *v73 + DY;
    int32_t * v74 = (int32_t *)(v2 + 284); // 0x80a8800
    *v74 = *v74 + DY;
    int32_t * v75 = (int32_t *)(v2 + 220); // 0x80a8806
    *v75 = *v75 + DY;
    *Element = *Element + DX;
    int32_t * v76 = (int32_t *)(v2 + 8); // 0x80a8811
    *v76 = *v76 + DX;
    int32_t * v77 = (int32_t *)(v2 + 272); // 0x80a8814
    *v77 = *v77 + DX;
    int32_t * v78 = (int32_t *)(v2 + 280); // 0x80a881a
    *v78 = *v78 + DX;
    int32_t * v79 = (int32_t *)(v2 + 216); // 0x80a8820
    *v79 = *v79 + DX;
    if (Data == NULL) {
        // 0x80a8850
        return;
    }
    // 0x80a882a
    r_insert_entry((int32_t *)*(int32_t *)(v1 + 44), Element, 0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa040 - 0x80aa052
// Line range:    1053 - 1057
void DSClearString(int32_t * Ptr) {
    int32_t v1 = *(int32_t *)((int32_t)Ptr + 4); // 0x80aa046
    if (v1 != 0) {
        // 0x80aa04d
        *(char *)v1 = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa060 - 0x80aa07a
// Line range:    996 - 1003
void SaveFree(char * Ptr) {
    // 0x80aa060
    if (Ptr == NULL) {
        // 0x80aa078
        return;
    }
    // 0x80aa06d
    int32_t v1; // 0x80aa060
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa080 - 0x80aa0e4
// Line range:    809 - 821
void FreeAttributeListMemory(int32_t * list) {
    // 0x80aa080
    int32_t v1; // 0x80aa080
    int32_t * v2 = (int32_t *)(v1 + 8);
    int32_t v3 = 0; // 0x80aa08f
    if (v1 < 1) {
        // 0x80aa0c3
        SaveFree((char *)*v2);
        *v2 = 0;
        *(int32_t *)(v1 + 4) = 0;
        return;
    }
    int32_t v4 = 8 * v3; // 0x80aa09b
    v3++;
    SaveFree((char *)*(int32_t *)(*v2 + v4));
    SaveFree((char *)*(int32_t *)(*v2 + (v4 | 4)));
    while (v3 < (int32_t)&g279) {
        // 0x80aa098
        v4 = 8 * v3;
        v3++;
        SaveFree((char *)*(int32_t *)(*v2 + v4));
        SaveFree((char *)*(int32_t *)(*v2 + (v4 | 4)));
    }
    // 0x80aa0c3
    SaveFree((char *)*v2);
    *v2 = 0;
    *(int32_t *)(v1 + 4) = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa0f0 - 0x80aa1be
// Line range:    970 - 988
void FreeLibraryMemory(int32_t * lib) {
    int32_t v1 = (int32_t)lib;
    int32_t v2 = *lib; // 0x80aa0fc
    int32_t * v3; // 0x80aa0f0
    if (v2 == 0) {
        // 0x80aa0f0
        v3 = (int32_t *)(v1 + 8);
    } else {
        int32_t * v4 = (int32_t *)(v1 + 8);
        int32_t v5 = v2; // 0x80aa116
        int32_t v6 = 28 * v2; // 0x80aa116
        v6 -= 28;
        int32_t v7 = v6 + *v4; // 0x80aa11e
        int32_t v8 = *(int32_t *)(v7 + 12); // 0x80aa121
        int32_t * v9; // 0x80aa0f0
        int32_t v10; // 0x80aa0f0
        int32_t v11; // 0x80aa0f0
        int32_t v12; // 0x80aa14b
        int32_t * v13; // 0x80aa0f0
        if (v8 == 0) {
            // 0x80aa118
            v9 = (int32_t *)(v7 + 20);
        } else {
            // 0x80aa12f
            v13 = (int32_t *)(v7 + 20);
            v10 = v8;
            v11 = 24 * v8;
            v11 -= 24;
            v10--;
            v12 = v11 + *v13;
            SaveFree((char *)*(int32_t *)(v12 + 4));
            SaveFree((char *)*(int32_t *)v12);
            v9 = v13;
            while (v10 != 0) {
                // 0x80aa140
                v11 -= 24;
                v10--;
                v12 = v11 + *v13;
                SaveFree((char *)*(int32_t *)(v12 + 4));
                SaveFree((char *)*(int32_t *)v12);
                v9 = v13;
            }
        }
        // 0x80aa168
        v5--;
        SaveFree((char *)*v9);
        SaveFree((char *)*(int32_t *)v7);
        v3 = v4;
        while (v5 != 0) {
            // 0x80aa118
            v6 -= 28;
            v7 = v6 + *v4;
            v8 = *(int32_t *)(v7 + 12);
            if (v8 == 0) {
                // 0x80aa118
                v9 = (int32_t *)(v7 + 20);
            } else {
                // 0x80aa12f
                v13 = (int32_t *)(v7 + 20);
                v10 = v8;
                v11 = 24 * v8;
                v11 -= 24;
                v10--;
                v12 = v11 + *v13;
                SaveFree((char *)*(int32_t *)(v12 + 4));
                SaveFree((char *)*(int32_t *)v12);
                v9 = v13;
                while (v10 != 0) {
                    // 0x80aa140
                    v11 -= 24;
                    v10--;
                    v12 = v11 + *v13;
                    SaveFree((char *)*(int32_t *)(v12 + 4));
                    SaveFree((char *)*(int32_t *)v12);
                    v9 = v13;
                }
            }
            // 0x80aa168
            v5--;
            SaveFree((char *)*v9);
            SaveFree((char *)*(int32_t *)v7);
            v3 = v4;
        }
    }
    // 0x80aa191
    SaveFree((char *)*v3);
    *lib = 0;
    *(int32_t *)(v1 + 4) = 0;
    *v3 = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa1c0 - 0x80aa33e
// Line range:    827 - 855
void FreeElementMemory(int32_t * Element) {
    if (Element == NULL) {
        // 0x80aa336
        return;
    }
    int32_t v1 = (int32_t)Element;
    SaveFree((char *)*(int32_t *)(v1 + 208));
    SaveFree((char *)*(int32_t *)(v1 + 148));
    SaveFree((char *)*(int32_t *)(v1 + 88));
    int32_t * v2 = (int32_t *)(v1 + 224); // 0x80aa1fb
    int32_t v3 = *v2; // 0x80aa1fb
    if (v3 != 0) {
        int32_t v4 = 0; // 0x80aa214
        int32_t v5 = v3;
        int32_t v6 = 76 * v4 + *(int32_t *)(v1 + 256); // 0x80aa221
        int32_t * v7 = (int32_t *)(v6 + 60); // 0x80aa227
        SaveFree((char *)*v7);
        int32_t * v8 = (int32_t *)(v6 + 64); // 0x80aa232
        *v7 = 0;
        SaveFree((char *)*v8);
        uint32_t v9 = *v2; // 0x80aa244
        *v8 = 0;
        while (v9 != 0) {
            // 0x80aa210
            v4 = 1 - v5 + v4 + v9;
            if (v9 <= v4) {
                // break -> 0x80aa255
                break;
            }
            v5 = v9;
            v6 = 76 * v4 + *(int32_t *)(v1 + 256);
            v7 = (int32_t *)(v6 + 60);
            SaveFree((char *)*v7);
            v8 = (int32_t *)(v6 + 64);
            *v7 = 0;
            SaveFree((char *)*v8);
            v9 = *v2;
            *v8 = 0;
        }
    }
    int32_t * v10 = (int32_t *)(v1 + 232); // 0x80aa255
    int32_t v11 = *v10; // 0x80aa255
    int32_t * v12 = (int32_t *)(v1 + 260);
    int32_t v13 = 0; // 0x80aa264
    int32_t v14 = 0; // 0x80aa264
    while (true) {
        uint32_t v15 = v11;
        if (v15 == 0 || v14 >= v15) {
            // break (via goto) -> 0x80aa2c0
            goto lab_0x80aa2c0;
        }
        int32_t v16 = *v12 + v13; // 0x80aa27b
        int32_t * v17 = (int32_t *)(v16 + 88); // 0x80aa281
        SaveFree((char *)*v17);
        int32_t * v18 = (int32_t *)(v16 + 92); // 0x80aa28c
        *v17 = 0;
        SaveFree((char *)*v18);
        int32_t v19 = *v10; // 0x80aa29e
        *v18 = 0;
        while (v19 != v11) {
            // 0x80aa270
            v15 = v19;
            if (v15 == 0 || v14 >= v15) {
                // break (via goto) -> 0x80aa2c0
                goto lab_0x80aa2c0;
            }
            // 0x80aa278
            v16 = *v12 + v13;
            v17 = (int32_t *)(v16 + 88);
            SaveFree((char *)*v17);
            v18 = (int32_t *)(v16 + 92);
            *v17 = 0;
            SaveFree((char *)*v18);
            v19 = *v10;
            *v18 = 0;
        }
        // 0x80aa2b0
        v13 += 104;
        v14++;
    }
  lab_0x80aa2c0:;
    int32_t * v20 = (int32_t *)(v1 + 256); // 0x80aa2c0
    SaveFree((char *)*v20);
    *v20 = 0;
    SaveFree((char *)*v12);
    int32_t * v21 = (int32_t *)(v1 + 264); // 0x80aa2e8
    *v12 = 0;
    SaveFree((char *)*v21);
    int32_t * v22 = (int32_t *)(v1 + 268); // 0x80aa300
    *v21 = 0;
    SaveFree((char *)*v22);
    *v22 = 0;
    FreeAttributeListMemory(&g279);
    __asm_rep_stosd_memset((char *)Element, 0, 75);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa4d0 - 0x80aa527
// Line range:    732 - 742
void FreePolygonMemory(int32_t * Polygon2) {
    if (Polygon2 == NULL) {
        // 0x80aa51d
        return;
    }
    int32_t v1 = (int32_t)Polygon2;
    int32_t * v2 = (int32_t *)(v1 + 56); // 0x80aa4e3
    SaveFree((char *)*v2);
    int32_t v3 = v1 + 44; // 0x80aa4ee
    *v2 = 0;
    if (*(int32_t *)v3 != 0) {
        // 0x80aa4fc
        poly_Free((int32_t **)v3);
    }
    // 0x80aa507
    poly_FreeContours((int32_t **)(v1 + 48));
    __asm_rep_stosd_memset((char *)Polygon2, 0, 15);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa530 - 0x80aa828
// Line range:    891 - 98
void FreeDataMemory(int32_t * Data) {
    if (Data == NULL) {
        // 0x80aa809
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Warning:  Tried to FreeDataMemory(null)\n");
        // 0x80aa801
        return;
    }
    int32_t v1 = (int32_t)Data;
    int32_t v2 = *Data; // 0x80aa547
    if (v2 != 0) {
        int32_t v3 = 0; // 0x80aa55c
        int32_t v4 = v2;
        int32_t * v5 = (int32_t *)(*(int32_t *)(v1 + 28) + 60 + 76 * v3); // 0x80aa56c
        SaveFree((char *)*v5);
        uint32_t v6 = *Data; // 0x80aa577
        *v5 = 0;
        while (v6 != 0) {
            // 0x80aa558
            v3 = 1 - v4 + v3 + v6;
            if (v6 <= v3) {
                // break -> 0x80aa584
                break;
            }
            v4 = v6;
            v5 = (int32_t *)(*(int32_t *)(v1 + 28) + 60 + 76 * v3);
            SaveFree((char *)*v5);
            v6 = *Data;
            *v5 = 0;
        }
    }
    int32_t v7 = *(int32_t *)(v1 + 8); // 0x80aa587
    if (v7 != 0) {
        int32_t v8 = v7; // 0x80aa59a
        int32_t v9 = 300 * v7; // 0x80aa59a
        v9 -= 300;
        v8--;
        FreeElementMemory((int32_t *)(*(int32_t *)(v1 + 32) + v9));
        while (v8 != 0) {
            // 0x80aa5a0
            v9 -= 300;
            v8--;
            FreeElementMemory((int32_t *)(*(int32_t *)(v1 + 32) + v9));
        }
    }
    int32_t v10 = 0; // 0x80aa5c5
    int32_t v11 = v1 + 76;
    FreeAttributeListMemory((int32_t *)v10);
    int32_t v12 = *(int32_t *)(v11 + 8); // 0x80aa5d0
    int32_t v13; // 0x80aa530
    int32_t v14; // 0x80aa530
    int32_t * v15; // 0x80aa5f6
    if (v12 != 0) {
        // 0x80aa5db
        v14 = v12;
        v13 = 60 * v12;
        v13 -= 60;
        v14--;
        v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
        SaveFree((char *)*v15);
        *v15 = 0;
        while (v14 != 0) {
            // 0x80aa5e8
            v13 -= 60;
            v14--;
            v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
            SaveFree((char *)*v15);
            *v15 = 0;
        }
    }
    int32_t * v16 = (int32_t *)v11; // 0x80aa610
    int32_t v17 = *v16; // 0x80aa610
    if (v17 != 0) {
        // 0x80aa616
        SaveFree((char *)v17);
        *v16 = 0;
    }
    int32_t v18 = *(int32_t *)(v11 + 4); // 0x80aa624
    int32_t * v19; // 0x80aa530
    int32_t v20; // 0x80aa530
    int32_t v21; // 0x80aa530
    int32_t v22; // 0x80aa530
    int32_t v23; // 0x80aa530
    int32_t * v24; // 0x80aa530
    int32_t * v25; // 0x80aa530
    int32_t * v26; // 0x80aa643
    int32_t v27; // 0x80aa643
    int32_t v28; // 0x80aa65c
    if (v18 == 0) {
        // 0x80aa73c
        v24 = (int32_t *)(v11 + 36);
        v19 = v24;
        v21 = *v24;
    } else {
        // 0x80aa633
        v25 = (int32_t *)(v11 + 36);
        v20 = *v25;
        v23 = v18;
        v22 = 88 * v18;
        v22 -= 88;
        v26 = (int32_t *)(v20 + 84 + v22);
        v27 = *v26;
        v28 = v20;
        if (v27 != 0) {
            // 0x80aa64a
            SaveFree((char *)v27);
            *v26 = 0;
            v28 = *v25;
        }
        // 0x80aa65f
        v23--;
        v20 = v28;
        v19 = v25;
        v21 = v20;
        while (v23 != 0) {
            // 0x80aa640
            v22 -= 88;
            v26 = (int32_t *)(v20 + 84 + v22);
            v27 = *v26;
            v28 = v20;
            if (v27 != 0) {
                // 0x80aa64a
                SaveFree((char *)v27);
                *v26 = 0;
                v28 = *v25;
            }
            // 0x80aa65f
            v23--;
            v20 = v28;
            v19 = v25;
            v21 = v20;
        }
    }
    // 0x80aa66d
    SaveFree((char *)v21);
    int32_t * v29 = (int32_t *)(v11 + 48); // 0x80aa675
    *v19 = 0;
    SaveFree((char *)*v29);
    int32_t * v30 = (int32_t *)(v11 + 40); // 0x80aa687
    *v29 = 0;
    SaveFree((char *)*v30);
    int32_t v31 = *(int32_t *)(v11 + 12); // 0x80aa699
    *v30 = 0;
    int32_t * v32; // 0x80aa530
    int32_t v33; // 0x80aa530
    int32_t v34; // 0x80aa530
    int32_t * v35; // 0x80aa530
    if (v31 == 0) {
        // 0x80aa66d
        v32 = (int32_t *)(v11 + 44);
    } else {
        // 0x80aa6ab
        v35 = (int32_t *)(v11 + 44);
        v34 = v31;
        v33 = 60 * v31;
        v33 -= 60;
        v34--;
        FreePolygonMemory((int32_t *)(*v35 + v33));
        v32 = v35;
        while (v34 != 0) {
            // 0x80aa6b8
            v33 -= 60;
            v34--;
            FreePolygonMemory((int32_t *)(*v35 + v33));
            v32 = v35;
        }
    }
    // 0x80aa6d0
    SaveFree((char *)*v32);
    int32_t v36 = v11 + 52; // 0x80aa6db
    *v32 = 0;
    if (*(int32_t *)v36 != 0) {
        // 0x80aa6e9
        r_destroy_tree((int32_t **)v36);
    }
    int32_t v37 = v11 + 64; // 0x80aa6f4
    if (*(int32_t *)v37 != 0) {
        // 0x80aa6fb
        r_destroy_tree((int32_t **)v37);
    }
    int32_t v38 = v11 + 56; // 0x80aa706
    if (*(int32_t *)v38 != 0) {
        // 0x80aa70d
        r_destroy_tree((int32_t **)v38);
    }
    int32_t v39 = v11 + 60; // 0x80aa718
    if (*(int32_t *)v39 != 0) {
        // 0x80aa71f
        r_destroy_tree((int32_t **)v39);
    }
    while (v10 != 17) {
        // 0x80aa734
        v10++;
        v11 += 92;
        FreeAttributeListMemory((int32_t *)v10);
        v12 = *(int32_t *)(v11 + 8);
        if (v12 != 0) {
            // 0x80aa5db
            v14 = v12;
            v13 = 60 * v12;
            v13 -= 60;
            v14--;
            v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
            SaveFree((char *)*v15);
            *v15 = 0;
            while (v14 != 0) {
                // 0x80aa5e8
                v13 -= 60;
                v14--;
                v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
                SaveFree((char *)*v15);
                *v15 = 0;
            }
        }
        // 0x80aa610
        v16 = (int32_t *)v11;
        v17 = *v16;
        if (v17 != 0) {
            // 0x80aa616
            SaveFree((char *)v17);
            *v16 = 0;
        }
        // 0x80aa624
        v18 = *(int32_t *)(v11 + 4);
        if (v18 == 0) {
            // 0x80aa73c
            v24 = (int32_t *)(v11 + 36);
            v19 = v24;
            v21 = *v24;
        } else {
            // 0x80aa633
            v25 = (int32_t *)(v11 + 36);
            v20 = *v25;
            v23 = v18;
            v22 = 88 * v18;
            v22 -= 88;
            v26 = (int32_t *)(v20 + 84 + v22);
            v27 = *v26;
            v28 = v20;
            if (v27 != 0) {
                // 0x80aa64a
                SaveFree((char *)v27);
                *v26 = 0;
                v28 = *v25;
            }
            // 0x80aa65f
            v23--;
            v20 = v28;
            v19 = v25;
            v21 = v20;
            while (v23 != 0) {
                // 0x80aa640
                v22 -= 88;
                v26 = (int32_t *)(v20 + 84 + v22);
                v27 = *v26;
                v28 = v20;
                if (v27 != 0) {
                    // 0x80aa64a
                    SaveFree((char *)v27);
                    *v26 = 0;
                    v28 = *v25;
                }
                // 0x80aa65f
                v23--;
                v20 = v28;
                v19 = v25;
                v21 = v20;
            }
        }
        // 0x80aa66d
        SaveFree((char *)v21);
        v29 = (int32_t *)(v11 + 48);
        *v19 = 0;
        SaveFree((char *)*v29);
        v30 = (int32_t *)(v11 + 40);
        *v29 = 0;
        SaveFree((char *)*v30);
        v31 = *(int32_t *)(v11 + 12);
        *v30 = 0;
        if (v31 == 0) {
            // 0x80aa66d
            v32 = (int32_t *)(v11 + 44);
        } else {
            // 0x80aa6ab
            v35 = (int32_t *)(v11 + 44);
            v34 = v31;
            v33 = 60 * v31;
            v33 -= 60;
            v34--;
            FreePolygonMemory((int32_t *)(*v35 + v33));
            v32 = v35;
            while (v34 != 0) {
                // 0x80aa6b8
                v33 -= 60;
                v34--;
                FreePolygonMemory((int32_t *)(*v35 + v33));
                v32 = v35;
            }
        }
        // 0x80aa6d0
        SaveFree((char *)*v32);
        v36 = v11 + 52;
        *v32 = 0;
        if (*(int32_t *)v36 != 0) {
            // 0x80aa6e9
            r_destroy_tree((int32_t **)v36);
        }
        // 0x80aa6f4
        v37 = v11 + 64;
        if (*(int32_t *)v37 != 0) {
            // 0x80aa6fb
            r_destroy_tree((int32_t **)v37);
        }
        // 0x80aa706
        v38 = v11 + 56;
        if (*(int32_t *)v38 != 0) {
            // 0x80aa70d
            r_destroy_tree((int32_t **)v38);
        }
        // 0x80aa718
        v39 = v11 + 60;
        if (*(int32_t *)v39 != 0) {
            // 0x80aa71f
            r_destroy_tree((int32_t **)v39);
        }
    }
    int32_t v40 = v1 + 44; // 0x80aa748
    if (*(int32_t *)v40 != 0) {
        // 0x80aa74f
        r_destroy_tree((int32_t **)v40);
    }
    int32_t v41 = v1 + 56; // 0x80aa75d
    if (*(int32_t *)v41 != 0) {
        // 0x80aa764
        r_destroy_tree((int32_t **)v41);
    }
    int32_t v42 = v1 + 60; // 0x80aa774
    if (*(int32_t *)v42 != 0) {
        // 0x80aa77b
        r_destroy_tree((int32_t **)v42);
    }
    int32_t v43 = v1 + 64; // 0x80aa789
    if (*(int32_t *)v43 != 0) {
        // 0x80aa790
        r_destroy_tree((int32_t **)v43);
    }
    int32_t v44 = v1 + 40; // 0x80aa7a0
    if (*(int32_t *)v44 != 0) {
        // 0x80aa7a7
        r_destroy_tree((int32_t **)v44);
    }
    int32_t v45 = v1 + 48; // 0x80aa7b5
    if (*(int32_t *)v45 != 0) {
        // 0x80aa7bc
        r_destroy_tree((int32_t **)v45);
    }
    int32_t v46 = v1 + 52; // 0x80aa7cc
    if (*(int32_t *)v46 != 0) {
        // 0x80aa7d3
        r_destroy_tree((int32_t **)v46);
    }
    int32_t v47 = v1 + 68; // 0x80aa7e1
    if (*(int32_t *)v47 != 0) {
        // 0x80aa7e8
        r_destroy_tree((int32_t **)v47);
    }
    // 0x80aa7f5
    __asm_rep_stosd_memset((char *)Data, 0, 433);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa830 - 0x80aa929
// Line range:    861 - 885
void FreePCBMemory(int32_t * PCBPtr) {
    if (PCBPtr == NULL) {
        // 0x80aa905
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Warning:  Tried to FreePCBMemory(null)\n");
        return;
    }
    int32_t v1 = (int32_t)PCBPtr;
    int32_t * v2 = (int32_t *)(v1 + 16); // 0x80aa843
    SaveFree((char *)*v2);
    int32_t * v3 = (int32_t *)(v1 + 20); // 0x80aa84e
    *v2 = 0;
    SaveFree((char *)*v3);
    int32_t * v4 = (int32_t *)(v1 + 24); // 0x80aa860
    *v3 = 0;
    SaveFree((char *)*v4);
    int32_t * v5 = (int32_t *)(v1 + 0x220c); // 0x80aa872
    int32_t v6 = *v5; // 0x80aa872
    *v4 = 0;
    char * v7 = NULL; // 0x80aa883
    if (v6 != 0) {
        // 0x80aa885
        FreeDataMemory((int32_t *)v6);
        v7 = (char *)*v5;
    }
    // 0x80aa893
    SaveFree(v7);
    *v5 = 0;
    for (int32_t i = 0; i < 0x1be5; i += 28) {
        int32_t * v8 = (int32_t *)(v1 + 208 + i); // 0x80aa8a8
        SaveFree((char *)*v8);
        *v8 = 0;
    }
    // 0x80aa8cd
    FreeLibraryMemory((int32_t *)(v1 + 0x21f4));
    FreeAttributeListMemory(&g279);
    memset(PCBPtr, 0, 0x2210);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa930 - 0x80aa97e
// Line range:    699 - 711
char * MyStrdup(char * S, char * Text) {
    // 0x80aa930
    if (S == NULL) {
        // 0x80aa94f
        return (char *)0;
    }
    char * v1 = __strdup(S); // 0x80aa946
    if (v1 != NULL) {
        // 0x80aa94f
        return (char *)(int32_t)v1;
    }
    // 0x80aa958
    MyFatal("out of memory during g_strdup() in '%s'\n", Text == NULL ? "(unknown)" : Text);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa980 - 0x80aa9f2
// Line range:    676 - 685
char * MyRealloc(char * Ptr, int32_t Size, char * Text) {
    int32_t size = Size == 0 ? 1 : Size; // 0x80aa997
    int32_t * mem; // 0x80aa980
    if (Ptr == NULL) {
        // 0x80aa9e0
        mem = calloc(1, size);
    } else {
        // 0x80aa99e
        mem = realloc((int32_t *)Ptr, size);
    }
    // 0x80aa9aa
    if (mem != NULL) {
        // 0x80aa9ae
        return (char *)mem;
    }
    // 0x80aa9b8
    MyFatal("out of memory during realloc() in '%s'()\n", Text == NULL ? "(unknown)" : Text);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aaab0 - 0x80aab83
// Line range:    1038 - 1017
void DSAddString(int32_t * Ptr, char * S) {
    int32_t * v1 = (int32_t *)((int32_t)Ptr + 4); // 0x80aaac7
    int32_t str = *v1; // 0x80aaac7
    int32_t len = 0; // 0x80aaacf
    if (str != 0) {
        // 0x80aaad1
        len = strlen((char *)str);
    }
    if (S == NULL || *S == 0) {
        // 0x80aab40
        return;
    }
    uint32_t v2 = len + 1 + strlen(S); // 0x80aaaf4
    if (str == 0) {
        int32_t v3 = v2 + 512; // 0x80aab50
        *Ptr = v3;
        char * v4 = MyRealloc(NULL, v3, "ReallocDS()"); // 0x80aab6d
        *v1 = (int32_t)v4;
        *v4 = 0;
        // 0x80aab25
        strcat((char *)(*v1 + len), S);
        return;
    }
    int32_t v5 = str; // 0x80aaafc
    if (v2 >= *Ptr) {
        int32_t v6 = v2 + 512; // 0x80aaafe
        *Ptr = v6;
        v5 = (int32_t)MyRealloc((char *)str, v6, "ReallocDS()");
        *v1 = v5;
    }
    // 0x80aab25
    strcat((char *)(v5 + len), S);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aab90 - 0x80aac3c
// Line range:    1025 - 1017
void DSAddCharacter(int32_t * Ptr, char Char) {
    int32_t * v1 = (int32_t *)((int32_t)Ptr + 4); // 0x80aaba6
    int32_t v2 = *v1; // 0x80aaba6
    int32_t v3; // 0x80aab90
    int32_t v4; // 0x80aab90
    int32_t v5; // 0x80aab90
    if (v2 == 0) {
        // 0x80aac08
        *Ptr = 513;
        char * v6 = MyRealloc(NULL, 513, "ReallocDS()"); // 0x80aac27
        *v1 = (int32_t)v6;
        *v6 = 0;
        v4 = 1;
        v5 = *v1;
        v3 = 0;
    } else {
        char * str = (char *)v2; // 0x80aabb0
        int32_t len = strlen(str); // 0x80aabb3
        int32_t v7 = len + 1; // 0x80aabb8
        v4 = v7;
        v5 = v2;
        v3 = len;
        if (v7 >= *Ptr) {
            int32_t v8 = len + 513; // 0x80aabc1
            *Ptr = v8;
            int32_t v9 = (int32_t)MyRealloc(str, v8, "ReallocDS()"); // 0x80aabda
            *v1 = v9;
            v4 = v7;
            v5 = v9;
            v3 = len;
        }
    }
    // 0x80aabe7
    *(char *)(v3 + v5) = Char;
    *(char *)(*v1 + v4) = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aaec0 - 0x80aaf94
// Line range:    539 - 86
int32_t * GetLibraryEntryMemory(int32_t * Menu2) {
    int32_t v1 = (int32_t)Menu2;
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x80aaed2
    uint32_t v3 = *v2; // 0x80aaed2
    int32_t * v4 = (int32_t *)(v1 + 16); // 0x80aaed5
    uint32_t v5 = *v4; // 0x80aaed5
    int32_t * v6 = (int32_t *)(v1 + 20); // 0x80aaed8
    int32_t v7 = *v6; // 0x80aaed8
    if (v3 < v5) {
        // 0x80aaedf
        *v2 = v3 + 1;
        return (int32_t *)(v7 + 24 * v3);
    }
    int32_t v8 = v5 + 20; // 0x80aaef8
    *v4 = v8;
    int32_t v9 = (int32_t)MyRealloc((char *)v7, 24 * v8, "GetLibraryEntryMemory()"); // 0x80aaf18
    *v6 = v9;
    int32_t v10 = 24 * *v2 + v9; // 0x80aaf28
    int32_t v11 = 480; // 0x80aaf31
    int32_t v12 = v10; // 0x80aaf31
    if (v10 % 2 != 0) {
        // 0x80aaf88
        *(char *)v10 = 0;
        v11 = 479;
        v12 = v10 + 1;
    }
    int32_t v13 = v11; // 0x80aaf39
    int32_t v14 = v12; // 0x80aaf39
    if ((v12 & 2) != 0) {
        // 0x80aaf78
        *(int16_t *)v12 = 0;
        v13 = v11 - 2;
        v14 = v12 + 2;
    }
    uint32_t v15 = v13 / 4; // 0x80aaf3f
    __asm_rep_stosd_memset((char *)v14, 0, v15);
    bool v16; // 0x80aaec0
    int32_t v17 = v15 * (v16 ? -4 : 4) + v14; // 0x80aaf48
    int32_t v18; // 0x80aaec0
    if ((v13 & 2) != 0) {
        // 0x80aaf68
        *(int16_t *)v17 = 0;
        v18 = v17 + 2;
        if (v13 % 2 == 0) {
            goto lab_0x80aaf51;
        } else {
            goto lab_0x80aaf58;
        }
    } else {
        // 0x80aaf4c
        v18 = v17;
        if (v13 % 2 != 0) {
            goto lab_0x80aaf58;
        } else {
            goto lab_0x80aaf51;
        }
    }
  lab_0x80aaf51:;
    int32_t v19 = *v2;
    *v2 = v19 + 1;
    return (int32_t *)(v9 + 24 * v19);
  lab_0x80aaf58:
    // 0x80aaf58
    *(char *)v18 = 0;
    // 0x80aaedf
    v19 = *v2;
    *v2 = v19 + 1;
    return (int32_t *)(v9 + 24 * v19);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aafa0 - 0x80ab064
// Line range:    518 - 86
int32_t * GetLibraryMenuMemory(int32_t * lib) {
    int32_t v1 = (int32_t)lib;
    uint32_t v2 = *lib; // 0x80aafb2
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x80aafb4
    uint32_t v4 = *v3; // 0x80aafb4
    int32_t * v5 = (int32_t *)(v1 + 8); // 0x80aafb7
    int32_t v6 = *v5; // 0x80aafb7
    if (v2 < v4) {
        // 0x80aafbe
        *lib = v2 + 1;
        return (int32_t *)(v6 + 28 * v2);
    }
    int32_t v7 = v4 + 10; // 0x80aafd8
    *v3 = v7;
    int32_t v8 = (int32_t)MyRealloc((char *)v6, 28 * v7, "GetLibraryMenuMemory()"); // 0x80aaff5
    int32_t v9 = 28 * *lib + v8; // 0x80aaffd
    *v5 = v8;
    int32_t v10 = 280; // 0x80ab00b
    int32_t v11 = v9; // 0x80ab00b
    if (v9 % 2 != 0) {
        // 0x80ab058
        *(char *)v9 = 0;
        v10 = 279;
        v11 = v9 + 1;
    }
    int32_t v12 = v10; // 0x80ab013
    int32_t v13 = v11; // 0x80ab013
    if ((v11 & 2) != 0) {
        // 0x80ab048
        *(int16_t *)v11 = 0;
        v12 = v10 - 2;
        v13 = v11 + 2;
    }
    uint32_t v14 = v12 / 4; // 0x80ab019
    __asm_rep_stosd_memset((char *)v13, 0, v14);
    bool v15; // 0x80aafa0
    int32_t v16 = v14 * (v15 ? -4 : 4) + v13; // 0x80ab022
    int32_t v17; // 0x80aafa0
    if ((v12 & 2) != 0) {
        // 0x80ab038
        *(int16_t *)v16 = 0;
        v17 = v16 + 2;
        if (v12 % 2 == 0) {
            goto lab_0x80ab02b;
        } else {
            goto lab_0x80ab030;
        }
    } else {
        // 0x80ab026
        v17 = v16;
        if (v12 % 2 != 0) {
            goto lab_0x80ab030;
        } else {
            goto lab_0x80ab02b;
        }
    }
  lab_0x80ab02b:;
    int32_t v18 = *lib;
    *lib = v18 + 1;
    return (int32_t *)(v8 + 28 * v18);
  lab_0x80ab030:
    // 0x80ab030
    *(char *)v17 = 0;
    // 0x80aafbe
    v18 = *lib;
    *lib = v18 + 1;
    return (int32_t *)(v8 + 28 * v18);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab070 - 0x80ab144
// Line range:    444 - 86
int32_t * GetPointMemoryInPolygon(int32_t * Polygon2) {
    int32_t v1 = (int32_t)Polygon2;
    int32_t * v2 = (int32_t *)(v1 + 36); // 0x80ab082
    uint32_t v3 = *v2; // 0x80ab082
    int32_t * v4 = (int32_t *)(v1 + 40); // 0x80ab085
    uint32_t v5 = *v4; // 0x80ab085
    int32_t * v6 = (int32_t *)(v1 + 56); // 0x80ab088
    int32_t v7 = *v6; // 0x80ab088
    if (v3 < v5) {
        // 0x80ab08f
        *v2 = v3 + 1;
        return (int32_t *)(v7 + 20 * v3);
    }
    int32_t v8 = v5 + 10; // 0x80ab0a8
    *v4 = v8;
    int32_t v9 = (int32_t)MyRealloc((char *)v7, 20 * v8, "GetPointMemoryInPolygon()"); // 0x80ab0c8
    *v6 = v9;
    int32_t v10 = 20 * *v2 + v9; // 0x80ab0d8
    int32_t v11 = 200; // 0x80ab0e1
    int32_t v12 = v10; // 0x80ab0e1
    if (v10 % 2 != 0) {
        // 0x80ab138
        *(char *)v10 = 0;
        v11 = 199;
        v12 = v10 + 1;
    }
    int32_t v13 = v11; // 0x80ab0e9
    int32_t v14 = v12; // 0x80ab0e9
    if ((v12 & 2) != 0) {
        // 0x80ab128
        *(int16_t *)v12 = 0;
        v13 = v11 - 2;
        v14 = v12 + 2;
    }
    uint32_t v15 = v13 / 4; // 0x80ab0ef
    __asm_rep_stosd_memset((char *)v14, 0, v15);
    bool v16; // 0x80ab070
    int32_t v17 = v15 * (v16 ? -4 : 4) + v14; // 0x80ab0f8
    int32_t v18; // 0x80ab070
    if ((v13 & 2) != 0) {
        // 0x80ab118
        *(int16_t *)v17 = 0;
        v18 = v17 + 2;
        if (v13 % 2 == 0) {
            goto lab_0x80ab101;
        } else {
            goto lab_0x80ab108;
        }
    } else {
        // 0x80ab0fc
        v18 = v17;
        if (v13 % 2 != 0) {
            goto lab_0x80ab108;
        } else {
            goto lab_0x80ab101;
        }
    }
  lab_0x80ab101:;
    int32_t v19 = *v2;
    *v2 = v19 + 1;
    return (int32_t *)(v9 + 20 * v19);
  lab_0x80ab108:
    // 0x80ab108
    *(char *)v18 = 0;
    // 0x80ab08f
    v19 = *v2;
    *v2 = v19 + 1;
    return (int32_t *)(v9 + 20 * v19);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab620 - 0x80ab67e
// Line range:    626 - 648
char * MyCalloc(int32_t Number, int32_t Size, char * Text) {
    int32_t * mem = calloc(Number == 0 ? 1 : Number, Size == 0 ? 1 : Size); // 0x80ab646
    if (mem != NULL) {
        // 0x80ab64f
        return (char *)mem;
    }
    // 0x80ab658
    MyFatal("out of memory during malloc() in '%s'()\n", Text == NULL ? "(unknown)" : Text);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab680 - 0x80ab860
// Line range:    465 - 512
int32_t * GetElementMemory(int32_t * Data) {
    int32_t v1 = (int32_t)Data;
    int32_t * v2 = (int32_t *)(v1 + 32); // 0x80ab68c
    int32_t v3 = *v2; // 0x80ab68c
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x80ab68f
    uint32_t v5 = *v4; // 0x80ab68f
    int32_t * v6 = (int32_t *)(v1 + 8); // 0x80ab695
    uint32_t v7 = *v6; // 0x80ab695
    if (v7 < v5) {
        // 0x80ab849
        *v6 = v7 + 1;
        return (int32_t *)(300 * v7 + (int32_t)(int32_t *)v3);
    }
    int32_t v8 = v1 + 44; // 0x80ab6a0
    int32_t * v9 = (int32_t *)v8; // 0x80ab6a0
    int32_t v10 = v5 + 50; // 0x80ab6a3
    *v4 = v10;
    int32_t v11 = v10; // 0x80ab6ab
    if (*v9 != 0) {
        // 0x80ab6ad
        r_destroy_tree((int32_t **)v8);
        v11 = *v4;
    }
    char * v12 = MyRealloc((char *)v3, 300 * v11, "GetElementMemory()"); // 0x80ab6d5
    int32_t v13 = (int32_t)v12; // 0x80ab6d5
    *v2 = v13;
    memset((int32_t *)(300 * *v6 + v13), 0, 0x3a98);
    *v9 = (int32_t)r_create_tree(NULL, 0, 0);
    int32_t v14 = v1 + 56; // 0x80ab721
    for (int32_t i = 0; i < 3; i++) {
        int32_t v15 = 4 * i + v14; // 0x80ab721
        int32_t * v16 = (int32_t *)v15; // 0x80ab721
        if (*v16 != 0) {
            // 0x80ab729
            r_destroy_tree((int32_t **)v15);
        }
        // 0x80ab735
        *v16 = (int32_t)r_create_tree(NULL, 0, 0);
    }
    int32_t v17 = *v6; // 0x80ab75d
    int32_t v18; // 0x80ab680
    if (v17 == 0) {
        // 0x80ab849
        v18 = 0;
        *v6 = v18 + 1;
        return (int32_t *)(300 * v18 + (int32_t)(int32_t *)v12);
    }
    int32_t v19 = v17; // 0x80ab77d
    int32_t v20 = 300 * v17; // 0x80ab77d
    v20 -= 300;
    int32_t v21 = *v2 + v20; // 0x80ab783
    r_insert_entry((int32_t *)*v9, (int32_t *)v21, 0);
    int32_t v22 = *(int32_t *)(v21 + 224); // 0x80ab79d
    int32_t v23; // 0x80ab680
    int32_t v24; // 0x80ab680
    int32_t v25; // 0x80ab7bf
    if (v22 != 0) {
        // 0x80ab7a7
        v24 = *(int32_t *)(v21 + 256) + 68;
        *(int32_t *)v24 = v21;
        v23 = 1;
        if (v22 != 1) {
            *(int32_t *)(76 * v23 + v24) = v21;
            v25 = v23 + 1;
            v23 = v25;
            while (v25 != v22) {
                // 0x80ab7b8
                *(int32_t *)(76 * v23 + v24) = v21;
                v25 = v23 + 1;
                v23 = v25;
            }
        }
    }
    int32_t v26 = *(int32_t *)(v21 + 232); // 0x80ab7c6
    int32_t v27; // 0x80ab680
    int32_t v28; // 0x80ab7de
    if (v26 != 0) {
        // 0x80ab7d8
        v27 = 0;
        v28 = 0;
        v28++;
        *(int32_t *)(v27 + 96 + *(int32_t *)(v21 + 260)) = v21;
        v27 += 104;
        while (v28 != v26) {
            // 0x80ab7d8
            v28++;
            *(int32_t *)(v27 + 96 + *(int32_t *)(v21 + 260)) = v21;
            v27 += 104;
        }
    }
    // 0x80ab7f9
    v19--;
    int32_t v29 = v21; // 0x80ab680
    int32_t v30 = 2;
    *(int32_t *)(v29 + 212) = v21;
    int32_t v31 = *(int32_t *)(4 * v30 + v14); // 0x80ab818
    r_insert_entry((int32_t *)v31, (int32_t *)(v21 + 36 + 60 * v30), 0);
    v29 -= 60;
    int32_t v32 = v30 - 1; // 0x80ab82d
    while (v30 != 0) {
        // 0x80ab7f9
        v30 = v32;
        *(int32_t *)(v29 + 212) = v21;
        v31 = *(int32_t *)(4 * v30 + v14);
        r_insert_entry((int32_t *)v31, (int32_t *)(v21 + 36 + 60 * v30), 0);
        v29 -= 60;
        v32 = v30 - 1;
    }
    while (v19 != 0) {
        // 0x80ab780
        v20 -= 300;
        v21 = *v2 + v20;
        r_insert_entry((int32_t *)*v9, (int32_t *)v21, 0);
        v22 = *(int32_t *)(v21 + 224);
        if (v22 != 0) {
            // 0x80ab7a7
            v24 = *(int32_t *)(v21 + 256) + 68;
            *(int32_t *)v24 = v21;
            v23 = 1;
            if (v22 != 1) {
                *(int32_t *)(76 * v23 + v24) = v21;
                v25 = v23 + 1;
                v23 = v25;
                while (v25 != v22) {
                    // 0x80ab7b8
                    *(int32_t *)(76 * v23 + v24) = v21;
                    v25 = v23 + 1;
                    v23 = v25;
                }
            }
        }
        // 0x80ab7c6
        v26 = *(int32_t *)(v21 + 232);
        if (v26 != 0) {
            // 0x80ab7d8
            v27 = 0;
            v28 = 0;
            v28++;
            *(int32_t *)(v27 + 96 + *(int32_t *)(v21 + 260)) = v21;
            v27 += 104;
            while (v28 != v26) {
                // 0x80ab7d8
                v28++;
                *(int32_t *)(v27 + 96 + *(int32_t *)(v21 + 260)) = v21;
                v27 += 104;
            }
        }
        // 0x80ab7f9
        v19--;
        v29 = v21;
        v30 = 2;
        *(int32_t *)(v29 + 212) = v21;
        v31 = *(int32_t *)(4 * v30 + v14);
        r_insert_entry((int32_t *)v31, (int32_t *)(v21 + 36 + 60 * v30), 0);
        v29 -= 60;
        v32 = v30 - 1;
        while (v30 != 0) {
            // 0x80ab7f9
            v30 = v32;
            *(int32_t *)(v29 + 212) = v21;
            v31 = *(int32_t *)(4 * v30 + v14);
            r_insert_entry((int32_t *)v31, (int32_t *)(v21 + 36 + 60 * v30), 0);
            v29 -= 60;
            v32 = v30 - 1;
        }
    }
    // 0x80ab849
    v18 = *v6;
    *v6 = v18 + 1;
    return (int32_t *)(300 * v18 + (int32_t)(int32_t *)v12);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab860 - 0x80ab9a8
// Line range:    414 - 86
int32_t * GetPolygonMemory(int32_t * Layer2) {
    int32_t v1 = (int32_t)Layer2;
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x80ab86c
    uint32_t v3 = *v2; // 0x80ab86c
    int32_t * v4 = (int32_t *)(v1 + 28); // 0x80ab86f
    uint32_t v5 = *v4; // 0x80ab86f
    int32_t * v6 = (int32_t *)(v1 + 44); // 0x80ab872
    int32_t v7 = *v6; // 0x80ab872
    if (v3 < v5) {
        // 0x80ab958
        *v2 = v3 + 1;
        return (int32_t *)(v7 + 60 * v3);
    }
    int32_t v8 = v1 + 60; // 0x80ab87d
    int32_t * v9 = (int32_t *)v8; // 0x80ab87d
    int32_t v10 = v5 + 10; // 0x80ab880
    *v4 = v10;
    int32_t v11 = v10; // 0x80ab888
    if (*v9 != 0) {
        // 0x80ab88a
        r_destroy_tree((int32_t **)v8);
        v11 = *v4;
    }
    int32_t v12 = (int32_t)MyRealloc((char *)v7, 60 * v11, "GetPolygonMemory()"); // 0x80ab8aa
    int32_t v13 = 60 * *v2 + v12; // 0x80ab8b8
    *v6 = v12;
    int32_t v14 = 600; // 0x80ab8c6
    int32_t v15 = v13; // 0x80ab8c6
    if (v13 % 2 != 0) {
        // 0x80ab99b
        *(char *)v13 = 0;
        v14 = 599;
        v15 = v13 + 1;
    }
    int32_t v16 = v14; // 0x80ab8d2
    int32_t v17 = v15; // 0x80ab8d2
    if ((v15 & 2) != 0) {
        // 0x80ab98b
        *(int16_t *)v15 = 0;
        v16 = v14 - 2;
        v17 = v15 + 2;
    }
    uint32_t v18 = v16 / 4; // 0x80ab8dc
    __asm_rep_stosd_memset((char *)v17, 0, v18);
    bool v19; // 0x80ab860
    int32_t v20 = v18 * (v19 ? -4 : 4) + v17; // 0x80ab8e2
    if ((v16 & 2) != 0) {
        // 0x80ab978
        *(int16_t *)v20 = 0;
        if (v16 % 2 == 0) {
            goto lab_0x80ab8f3;
        } else {
            // 0x80ab970
            *(char *)(v20 + 2) = 0;
            goto lab_0x80ab8f3;
        }
    } else {
        // 0x80ab8ea
        if (v16 % 2 != 0) {
            // 0x80ab970
            *(char *)v20 = 0;
            goto lab_0x80ab8f3;
        } else {
            goto lab_0x80ab8f3;
        }
    }
  lab_0x80ab8f3:;
    int32_t * v21 = r_create_tree(NULL, 0, 0); // 0x80ab90a
    int32_t v22 = *v2; // 0x80ab90f
    *v9 = (int32_t)v21;
    int32_t v23; // 0x80ab860
    if (v22 == 0) {
        // 0x80ab958
        v23 = 0;
        *v2 = v23 + 1;
        return (int32_t *)(v12 + 60 * v23);
    }
    int32_t v24 = v22 - 1;
    int32_t v25 = 60 * v22 - 60;
    r_insert_entry(v21, (int32_t *)(*v6 + v25), 0);
    if (v24 != 0) {
        int32_t v26 = v24 - 1;
        int32_t v27 = v25 - 60;
        r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v27), 0);
        int32_t v28 = v27; // 0x80ab953
        int32_t v29 = v26; // 0x80ab953
        while (v26 != 0) {
            // 0x80ab928
            v26 = v29 - 1;
            v27 = v28 - 60;
            r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v27), 0);
            v28 = v27;
            v29 = v26;
        }
    }
    // 0x80ab958
    v23 = *v2;
    *v2 = v23 + 1;
    return (int32_t *)(v12 + 60 * v23);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab9b0 - 0x80abaf8
// Line range:    386 - 86
int32_t * GetTextMemory(int32_t * Layer2) {
    int32_t v1 = (int32_t)Layer2;
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x80ab9bc
    uint32_t v3 = *v2; // 0x80ab9bc
    int32_t * v4 = (int32_t *)(v1 + 24); // 0x80ab9bf
    uint32_t v5 = *v4; // 0x80ab9bf
    int32_t * v6 = (int32_t *)(v1 + 40); // 0x80ab9c2
    int32_t v7 = *v6; // 0x80ab9c2
    if (v3 < v5) {
        // 0x80abaa8
        *v2 = v3 + 1;
        return (int32_t *)(v7 + 60 * v3);
    }
    int32_t v8 = v1 + 56; // 0x80ab9cd
    int32_t * v9 = (int32_t *)v8; // 0x80ab9cd
    int32_t v10 = v5 + 50; // 0x80ab9d0
    *v4 = v10;
    int32_t v11 = v10; // 0x80ab9d8
    if (*v9 != 0) {
        // 0x80ab9da
        r_destroy_tree((int32_t **)v8);
        v11 = *v4;
    }
    int32_t v12 = (int32_t)MyRealloc((char *)v7, 60 * v11, "GetTextMemory()"); // 0x80ab9fa
    int32_t v13 = 60 * *v2 + v12; // 0x80aba08
    *v6 = v12;
    int32_t v14 = 3000; // 0x80aba16
    int32_t v15 = v13; // 0x80aba16
    if (v13 % 2 != 0) {
        // 0x80abaeb
        *(char *)v13 = 0;
        v14 = 2999;
        v15 = v13 + 1;
    }
    int32_t v16 = v14; // 0x80aba22
    int32_t v17 = v15; // 0x80aba22
    if ((v15 & 2) != 0) {
        // 0x80abadb
        *(int16_t *)v15 = 0;
        v16 = v14 - 2;
        v17 = v15 + 2;
    }
    uint32_t v18 = v16 / 4; // 0x80aba2c
    __asm_rep_stosd_memset((char *)v17, 0, v18);
    bool v19; // 0x80ab9b0
    int32_t v20 = v18 * (v19 ? -4 : 4) + v17; // 0x80aba32
    if ((v16 & 2) != 0) {
        // 0x80abac8
        *(int16_t *)v20 = 0;
        if (v16 % 2 == 0) {
            goto lab_0x80aba43;
        } else {
            // 0x80abac0
            *(char *)(v20 + 2) = 0;
            goto lab_0x80aba43;
        }
    } else {
        // 0x80aba3a
        if (v16 % 2 != 0) {
            // 0x80abac0
            *(char *)v20 = 0;
            goto lab_0x80aba43;
        } else {
            goto lab_0x80aba43;
        }
    }
  lab_0x80aba43:;
    int32_t * v21 = r_create_tree(NULL, 0, 0); // 0x80aba5a
    int32_t v22 = *v2; // 0x80aba5f
    *v9 = (int32_t)v21;
    int32_t v23; // 0x80ab9b0
    if (v22 == 0) {
        // 0x80abaa8
        v23 = 0;
        *v2 = v23 + 1;
        return (int32_t *)(v12 + 60 * v23);
    }
    int32_t v24 = v22 - 1;
    int32_t v25 = 60 * v22 - 60;
    r_insert_entry(v21, (int32_t *)(*v6 + v25), 0);
    if (v24 != 0) {
        int32_t v26 = v24 - 1;
        int32_t v27 = v25 - 60;
        r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v27), 0);
        int32_t v28 = v27; // 0x80abaa3
        int32_t v29 = v26; // 0x80abaa3
        while (v26 != 0) {
            // 0x80aba78
            v26 = v29 - 1;
            v27 = v28 - 60;
            r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v27), 0);
            v28 = v27;
            v29 = v26;
        }
    }
    // 0x80abaa8
    v23 = *v2;
    *v2 = v23 + 1;
    return (int32_t *)(v12 + 60 * v23);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abb00 - 0x80abc01
// Line range:    358 - 380
int32_t * GetArcMemory(int32_t * Layer2) {
    int32_t v1 = (int32_t)Layer2;
    int32_t * v2 = (int32_t *)(v1 + 16); // 0x80abb0c
    uint32_t v3 = *v2; // 0x80abb0c
    int32_t * v4 = (int32_t *)(v1 + 32); // 0x80abb0f
    uint32_t v5 = *v4; // 0x80abb0f
    int32_t * v6 = (int32_t *)(v1 + 48); // 0x80abb12
    int32_t v7 = *v6; // 0x80abb12
    if (v3 < v5) {
        // 0x80abbe8
        *v2 = v3 + 1;
        return (int32_t *)(v7 + 68 * v3);
    }
    int32_t v8 = v1 + 64; // 0x80abb1d
    int32_t * v9 = (int32_t *)v8; // 0x80abb1d
    int32_t v10 = v5 + 1000; // 0x80abb20
    *v4 = v10;
    int32_t v11 = v10; // 0x80abb2a
    if (*v9 != 0) {
        // 0x80abb2c
        r_destroy_tree((int32_t **)v8);
        v11 = *v4;
    }
    int32_t v12 = (int32_t)MyRealloc((char *)v7, 68 * v11, "GetArcMemory()"); // 0x80abb51
    *v6 = v12;
    memset((int32_t *)(68 * *v2 + v12), 0, 0x109a0);
    int32_t * v13 = r_create_tree(NULL, 0, 0); // 0x80abb98
    int32_t v14 = *v2; // 0x80abb9d
    *v9 = (int32_t)v13;
    int32_t v15; // 0x80abb00
    if (v14 == 0) {
        // 0x80abbe8
        v15 = 0;
        *v2 = v15 + 1;
        return (int32_t *)(v12 + 68 * v15);
    }
    int32_t v16 = 68 * v14 - 68; // 0x80abbb0
    int32_t v17 = v14 - 1;
    r_insert_entry(v13, (int32_t *)(*v6 + v16), 0);
    int32_t v18 = v17; // 0x80abbe3
    int32_t v19 = v16; // 0x80abbe3
    if (v17 != 0) {
        v19 -= 68;
        v18--;
        r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v19), 0);
        while (v18 != 0) {
            // 0x80abbb8
            v19 -= 68;
            v18--;
            r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v19), 0);
        }
    }
    // 0x80abbe8
    v15 = *v2;
    *v2 = v15 + 1;
    return (int32_t *)(v12 + 68 * v15);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abc10 - 0x80abcfc
// Line range:    329 - 352
int32_t * GetLineMemory(int32_t * Layer2) {
    int32_t v1 = (int32_t)Layer2;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80abc1c
    uint32_t v3 = *v2; // 0x80abc1c
    int32_t * v4 = (int32_t *)(v1 + 20); // 0x80abc1f
    uint32_t v5 = *v4; // 0x80abc1f
    int32_t * v6 = (int32_t *)(v1 + 36); // 0x80abc22
    int32_t v7 = *v6; // 0x80abc22
    if (v3 < v5) {
        // 0x80abce8
        *v2 = v3 + 1;
        return (int32_t *)(v7 + 88 * v3);
    }
    int32_t v8 = v1 + 52; // 0x80abc2d
    int32_t * v9 = (int32_t *)v8; // 0x80abc2d
    int32_t v10 = v5 + 0x2710; // 0x80abc30
    *v4 = v10;
    int32_t v11 = v10; // 0x80abc3a
    if (*v9 != 0) {
        // 0x80abc3c
        r_destroy_tree((int32_t **)v8);
        v11 = *v4;
    }
    int32_t v12 = (int32_t)MyRealloc((char *)v7, 88 * v11, "GetLineMemory()"); // 0x80abc5c
    *v6 = v12;
    memset((int32_t *)(88 * *v2 + v12), 0, 0xd6d80);
    int32_t * v13 = r_create_tree(NULL, 0, 0); // 0x80abc9c
    int32_t v14 = *v2; // 0x80abca1
    *v9 = (int32_t)v13;
    int32_t v15; // 0x80abc10
    if (v14 == 0) {
        // 0x80abce8
        v15 = 0;
        *v2 = v15 + 1;
        return (int32_t *)(v12 + 88 * v15);
    }
    int32_t v16 = v14 - 1;
    int32_t v17 = 88 * v14 - 88;
    r_insert_entry(v13, (int32_t *)(*v6 + v17), 0);
    int32_t v18 = v17; // 0x80abce3
    int32_t v19 = v16; // 0x80abce3
    if (v16 != 0) {
        v19--;
        v18 -= 88;
        r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v18), 0);
        while (v19 != 0) {
            // 0x80abcb8
            v19--;
            v18 -= 88;
            r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v18), 0);
        }
    }
    // 0x80abce8
    v15 = *v2;
    *v2 = v15 + 1;
    return (int32_t *)(v12 + 88 * v15);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abd00 - 0x80abdec
// Line range:    300 - 323
int32_t * GetRatMemory(int32_t * Data) {
    int32_t v1 = (int32_t)Data;
    int32_t * v2 = (int32_t *)(v1 + 16); // 0x80abd0c
    uint32_t v3 = *v2; // 0x80abd0c
    int32_t * v4 = (int32_t *)(v1 + 20); // 0x80abd0f
    uint32_t v5 = *v4; // 0x80abd0f
    int32_t * v6 = (int32_t *)(v1 + 36); // 0x80abd12
    int32_t v7 = *v6; // 0x80abd12
    if (v3 < v5) {
        // 0x80abdd8
        *v2 = v3 + 1;
        return (int32_t *)(v7 + 92 * v3);
    }
    int32_t v8 = v1 + 68; // 0x80abd1d
    int32_t * v9 = (int32_t *)v8; // 0x80abd1d
    int32_t v10 = v5 + 2000; // 0x80abd20
    *v4 = v10;
    int32_t v11 = v10; // 0x80abd2a
    if (*v9 != 0) {
        // 0x80abd2c
        r_destroy_tree((int32_t **)v8);
        v11 = *v4;
    }
    int32_t v12 = (int32_t)MyRealloc((char *)v7, 92 * v11, "GetRatMemory()"); // 0x80abd4c
    *v6 = v12;
    memset((int32_t *)(92 * *v2 + v12), 0, 0x2cec0);
    int32_t * v13 = r_create_tree(NULL, 0, 0); // 0x80abd8c
    int32_t v14 = *v2; // 0x80abd91
    *v9 = (int32_t)v13;
    int32_t v15; // 0x80abd00
    if (v14 == 0) {
        // 0x80abdd8
        v15 = 0;
        *v2 = v15 + 1;
        return (int32_t *)(v12 + 92 * v15);
    }
    int32_t v16 = v14 - 1;
    int32_t v17 = 92 * v14 - 92;
    r_insert_entry(v13, (int32_t *)(*v6 + v17), 0);
    int32_t v18 = v17; // 0x80abdd3
    int32_t v19 = v16; // 0x80abdd3
    if (v16 != 0) {
        v19--;
        v18 -= 92;
        r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v18), 0);
        while (v19 != 0) {
            // 0x80abda8
            v19--;
            v18 -= 92;
            r_insert_entry((int32_t *)*v9, (int32_t *)(*v6 + v18), 0);
        }
    }
    // 0x80abdd8
    v15 = *v2;
    *v2 = v15 + 1;
    return (int32_t *)(v12 + 92 * v15);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abdf0 - 0x80abee4
// Line range:    272 - 294
int32_t * GetViaMemory(int32_t * Data) {
    int32_t v1 = (int32_t)Data;
    int32_t * v2 = (int32_t *)(v1 + 28); // 0x80abdfc
    int32_t v3 = *v2; // 0x80abdfc
    uint32_t v4 = *Data; // 0x80abdff
    int32_t * v5 = (int32_t *)(v1 + 4); // 0x80abe04
    uint32_t v6 = *v5; // 0x80abe04
    if (v4 < v6) {
        // 0x80abed2
        *Data = v4 + 1;
        return (int32_t *)(76 * v4 + (int32_t)(int32_t *)v3);
    }
    int32_t v7 = v1 + 40; // 0x80abe12
    int32_t * v8 = (int32_t *)v7; // 0x80abe12
    int32_t v9 = v6 + 2000; // 0x80abe15
    *v5 = v9;
    int32_t v10 = v9; // 0x80abe1f
    if (*v8 != 0) {
        // 0x80abe21
        r_destroy_tree((int32_t **)v7);
        v10 = *v5;
    }
    char * v11 = MyRealloc((char *)v3, 76 * v10, "GetViaMemory()"); // 0x80abe44
    int32_t v12 = (int32_t)v11; // 0x80abe44
    *v2 = v12;
    memset((int32_t *)(76 * *Data + v12), 0, 0x251c0);
    int32_t * v13 = r_create_tree(NULL, 0, 0); // 0x80abe84
    int32_t v14 = *Data; // 0x80abe89
    *v8 = (int32_t)v13;
    if (v14 == 0) {
        // 0x80abed2
        *Data = 1;
        return (int32_t *)(int32_t)(int32_t *)v11;
    }
    // 0x80abeaf
    r_insert_entry(v13, (int32_t *)*v2, 0);
    int32_t v15 = *Data; // 0x80abec9
    int32_t v16 = v15 + 1; // 0x80abecd
    int32_t v17 = v16; // 0x80abed0
    int32_t v18 = 0; // 0x80abed0
    if (v15 == 0) {
        // 0x80abed2
        *Data = v16;
        return (int32_t *)(76 * v15 + (int32_t)(int32_t *)v11);
    }
    int32_t v19 = v15;
    v18 += v17 - v14;
    int32_t v20 = v19; // 0x80abea8
    while (v19 > v18) {
        // 0x80abeaa
        r_insert_entry((int32_t *)*v8, (int32_t *)(*v2 + 76 * v18), 0);
        int32_t v21 = *Data; // 0x80abec9
        v17 = v21 + 1;
        v20 = v21;
        if (v21 == 0) {
            // break -> 0x80abed2
            break;
        }
        int32_t v22 = v19;
        v19 = v21;
        v18 += v17 - v22;
        v20 = v19;
    }
    // 0x80abed2
    *Data = v17;
    return (int32_t *)(76 * v20 + (int32_t)(int32_t *)v11);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abef0 - 0x80ac155
// Line range:    234 - 86
int32_t * GetPadMemory(int32_t * Element) {
    int32_t v1 = (int32_t)Element;
    int32_t * v2 = (int32_t *)(v1 + 260); // 0x80abefc
    int32_t v3 = *v2; // 0x80abefc
    int32_t * v4 = (int32_t *)(v1 + 232); // 0x80abf02
    uint32_t v5 = *v4; // 0x80abf02
    int32_t * v6 = (int32_t *)(v1 + 236); // 0x80abf0b
    uint32_t v7 = *v6; // 0x80abf0b
    if (v5 < v7) {
        // 0x80ac0de
        *v4 = v5 + 1;
        return (int32_t *)(104 * v5 + (int32_t)(int32_t *)v3);
    }
    // 0x80abf19
    int32_t v8; // 0x80abef0
    char v9; // 0x80abef0
    int32_t * v10; // 0x80abef0
    char * v11; // 0x80abfa9
    bool v12; // 0x80abef0
    if (*(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52) == 0) {
        int32_t v13 = v7 + 20; // 0x80ac068
        *v6 = v13;
        char * v14 = MyRealloc((char *)v3, 104 * v13, "GetPadMemory()"); // 0x80ac086
        int32_t v15 = (int32_t)v14; // 0x80ac086
        int32_t v16 = 104 * *v4 + v15; // 0x80ac097
        *v2 = v15;
        int32_t v17 = 2080; // 0x80ac0a8
        int32_t v18 = v16; // 0x80ac0a8
        if (v16 % 2 != 0) {
            // 0x80ac148
            *(char *)v16 = 0;
            v17 = 2079;
            v18 = v16 + 1;
        }
        int32_t v19 = v17; // 0x80ac0b4
        int32_t v20 = v18; // 0x80ac0b4
        if ((v18 & 2) != 0) {
            // 0x80ac138
            *(int16_t *)v18 = 0;
            v19 = v17 - 2;
            v20 = v18 + 2;
        }
        uint32_t v21 = v19 / 4; // 0x80ac0be
        __asm_rep_stosd_memset((char *)v20, 0, v21);
        int32_t v22 = v21 * (v12 ? -4 : 4) + v20; // 0x80ac0c4
        int32_t v23 = v22; // 0x80ac0c6
        if ((v19 & 2) != 0) {
            // 0x80ac0c8
            *(int16_t *)v22 = 0;
            v23 = v22 + 2;
        }
        // 0x80ac0d0
        v10 = (int32_t *)v14;
        if (v19 % 2 != 0) {
            // 0x80ac0d5
            *(char *)v23 = 0;
            v10 = (int32_t *)v14;
        }
        goto lab_0x80ac0d8;
    } else {
        int32_t v24 = 0; // 0x80abf83
        int32_t v25 = v7; // 0x80abf83
        v9 = 0;
        if (v5 != 0 && v5 != 0) {
            int32_t v26 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52); // 0x80abf5c
            int32_t v27 = r_delete_entry((int32_t *)v26, (int32_t *)(104 * v24 + v3)) != 0 ? 1 : 0; // 0x80abf6e
            uint32_t v28 = *v4; // 0x80abf71
            int32_t v29 = v24 + (int32_t)(v5 == v28); // 0x80abf7f
            while (v28 != 0 && v29 < v28) {
                int32_t v30 = *v2; // 0x80abef0
                v26 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52);
                v27 = r_delete_entry((int32_t *)v26, (int32_t *)(104 * v29 + v30)) != 0 ? 1 : v27;
                v28 = *v4;
                v29 += (int32_t)(v5 == v28);
            }
            // 0x80abf81
            v25 = *v6;
            v9 = v27;
        }
        int32_t v31 = v25 + 20; // 0x80abf8b
        *v6 = v31;
        v11 = MyRealloc((char *)v3, 104 * v31, "GetPadMemory()");
        int32_t v32 = (int32_t)v11; // 0x80abfa9
        int32_t v33 = 104 * *v4 + v32; // 0x80abfba
        *v2 = v32;
        int32_t v34 = 2080; // 0x80abfcb
        int32_t v35 = v33; // 0x80abfcb
        if (v33 % 2 != 0) {
            // 0x80ac12b
            *(char *)v33 = 0;
            v34 = 2079;
            v35 = v33 + 1;
        }
        int32_t v36 = v34; // 0x80abfd7
        int32_t v37 = v35; // 0x80abfd7
        if ((v35 & 2) != 0) {
            // 0x80ac11b
            *(int16_t *)v35 = 0;
            v36 = v34 - 2;
            v37 = v35 + 2;
        }
        uint32_t v38 = v36 / 4; // 0x80abfe1
        __asm_rep_stosd_memset((char *)v37, 0, v38);
        int32_t v39 = v38 * (v12 ? -4 : 4) + v37; // 0x80abfe7
        if ((v36 & 2) != 0) {
            // 0x80ac108
            *(int16_t *)v39 = 0;
            v8 = v39 + 2;
            if (v36 % 2 == 0) {
                goto lab_0x80abff8;
            } else {
                goto lab_0x80ac0f8;
            }
        } else {
            // 0x80abfef
            v8 = v39;
            if (v36 % 2 != 0) {
                goto lab_0x80ac0f8;
            } else {
                goto lab_0x80abff8;
            }
        }
    }
  lab_0x80ac0d8:;
    int32_t * v40 = v10; // 0x80ac0d8
    int32_t v41 = *v4; // 0x80ac0d8
  lab_0x80ac0de:
    // 0x80ac0de
    *v4 = v41 + 1;
    return (int32_t *)(104 * v41 + (int32_t)v40);
  lab_0x80abff8:
    // 0x80abff8
    v10 = (int32_t *)v11;
    if (v9 == 0) {
        goto lab_0x80ac0d8;
    } else {
        goto lab_0x80ac002;
    }
  lab_0x80ac0f8:
    // 0x80ac0f8
    *(char *)v8 = 0;
    v10 = (int32_t *)v11;
    if (v9 != 0) {
        goto lab_0x80ac002;
    } else {
        goto lab_0x80ac0d8;
    }
  lab_0x80ac002:;
    int32_t v42 = *v4; // 0x80ac002
    int32_t v43 = 0; // 0x80ac011
    int32_t v44 = 0; // 0x80ac011
    while (true) {
        int32_t v45 = v42;
        v40 = (int32_t *)v11;
        v41 = v45;
        if (v45 == 0 || v44 >= v45) {
            // break (via goto) -> 0x80ac0de
            goto lab_0x80ac0de;
        }
        int32_t v46 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52); // 0x80ac048
        r_insert_entry((int32_t *)v46, (int32_t *)(*v2 + v43), 0);
        int32_t v47 = *v4; // 0x80ac053
        while (v47 != v42) {
            // 0x80ac018
            v45 = v47;
            v40 = (int32_t *)v11;
            v41 = v45;
            if (v45 == 0 || v44 >= v45) {
                // break (via goto) -> 0x80ac0de
                goto lab_0x80ac0de;
            }
            // 0x80ac028
            v46 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52);
            r_insert_entry((int32_t *)v46, (int32_t *)(*v2 + v43), 0);
            v47 = *v4;
        }
        // 0x80ac05e
        v43 += 104;
        v44++;
    }
    int32_t v48 = v41;
    int32_t * v49 = v40;
    *v4 = v48 + 1;
    return (int32_t *)(104 * v48 + (int32_t)v49);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ac160 - 0x80ac3f0
// Line range:    196 - 86
int32_t * GetPinMemory(int32_t * Element) {
    int32_t v1 = (int32_t)Element;
    int32_t * v2 = (int32_t *)(v1 + 256); // 0x80ac16c
    int32_t v3 = *v2; // 0x80ac16c
    int32_t * v4 = (int32_t *)(v1 + 224); // 0x80ac172
    int32_t v5 = *v4; // 0x80ac172
    char * v6 = (char *)v3;
    char * v7 = v6; // bp-36, 0x80ac178
    int32_t * v8 = (int32_t *)(v1 + 228); // 0x80ac17b
    uint32_t v9 = *v8; // 0x80ac17b
    int32_t v10 = v5; // 0x80ac183
    if (v5 >= v9) {
        int32_t v11 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48); // 0x80ac195
        char * v12; // 0x80ac160
        int32_t v13; // 0x80ac160
        bool v14; // 0x80ac160
        if (v11 == 0) {
            int32_t v15 = v9 + 20; // 0x80ac2f8
            *v8 = v15;
            v12 = v6;
            v13 = v15;
        } else {
            if (v5 != 0) {
                char v16 = r_delete_entry((int32_t *)v11, (int32_t *)v3) != 0;
                int32_t v17 = *v4; // 0x80ac1f8
                char v18 = v16; // 0x80ac203
                char v19 = v16; // 0x80ac203
                if (v17 != 0) {
                    int32_t v20 = v17;
                    int32_t v21 = v20 + 1 - v5; // 0x80ac1bc
                    v19 = v18;
                    while (v20 > v21) {
                        int32_t v22 = *v2; // 0x80ac1ca
                        int32_t v23 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48); // 0x80ac1d6
                        char v24 = r_delete_entry((int32_t *)v23, (int32_t *)(v22 + 76 * v21)) == 0 ? v18 : 1;
                        int32_t v25 = *v4; // 0x80ac1f8
                        v18 = v24;
                        int32_t v26 = v20; // 0x80ac203
                        v19 = v24;
                        if (v25 == 0) {
                            // break -> 0x80ac205
                            break;
                        }
                        v20 = v25;
                        v21 += v20 + 1 - v26;
                        v19 = v18;
                    }
                }
                int32_t v27 = *v8 + 20; // 0x80ac20e
                *v8 = v27;
                char * v28 = MyRealloc(v6, 76 * v27, "GetPinMemory()"); // 0x80ac229
                int32_t v29 = (int32_t)v28; // 0x80ac229
                int32_t v30 = 76 * *v4 + v29; // 0x80ac23a
                *v2 = v29;
                int32_t v31 = 1520; // 0x80ac24b
                int32_t v32 = v30; // 0x80ac24b
                if (v30 % 2 != 0) {
                    // 0x80ac3b6
                    *(char *)v30 = 0;
                    v31 = 1519;
                    v32 = v30 + 1;
                }
                int32_t v33 = v31; // 0x80ac257
                int32_t v34 = v32; // 0x80ac257
                if ((v32 & 2) != 0) {
                    // 0x80ac3c3
                    *(int16_t *)v32 = 0;
                    v33 = v31 - 2;
                    v34 = v32 + 2;
                }
                uint32_t v35 = v33 / 4; // 0x80ac261
                __asm_rep_stosd_memset((char *)v34, 0, v35);
                int32_t v36 = v35 * (v14 ? -4 : 4) + v34; // 0x80ac267
                int32_t v37 = v36; // 0x80ac269
                if ((v33 & 2) != 0) {
                    // 0x80ac26b
                    *(int16_t *)v36 = 0;
                    v37 = v36 + 2;
                }
                if (v33 % 2 != 0) {
                    // 0x80ac278
                    *(char *)v37 = 0;
                }
                int32_t v38 = *v4;
                if (v19 == 0) {
                    // 0x80ac371
                    *v4 = v38 + 1;
                    return (int32_t *)(76 * v38 + (int32_t)v28);
                }
                int32_t v39 = v38; // 0x80ac29c
                int32_t v40 = 0; // 0x80ac29c
                if (v38 % 256 == 0) {
                    // 0x80ac371
                    *v4 = 1;
                    return (int32_t *)(int32_t)v28;
                }
                int32_t v41 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48); // 0x80ac2da
                r_insert_entry((int32_t *)v41, (int32_t *)(76 * v40 + *v2), 0);
                int32_t v42 = *v4; // 0x80ac2e5
                int32_t v43 = v42 + 1; // 0x80ac2ed
                int32_t v44 = 0; // 0x80ac2f0
                while (v42 != 0) {
                    // 0x80ac2a8
                    v40 += v43 - (0x1000000 * v39 >> 24);
                    v39 = v42;
                    v44 = v42;
                    if (v42 <= v40) {
                        // break -> 0x80ac371
                        break;
                    }
                    v41 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48);
                    r_insert_entry((int32_t *)v41, (int32_t *)(76 * v40 + *v2), 0);
                    v42 = *v4;
                    v43 = v42 + 1;
                    v44 = 0;
                }
                // 0x80ac371
                *v4 = v43;
                return (int32_t *)(76 * v44 + (int32_t)v28);
            }
            int32_t v45 = v9 + 20; // 0x80ac393
            *v8 = v45;
            v12 = v7;
            v13 = v45;
        }
        char * v46 = MyRealloc(v12, 76 * v13, "GetPinMemory()"); // 0x80ac316
        int32_t v47 = (int32_t)v46; // 0x80ac316
        int32_t v48 = 76 * *v4 + v47; // 0x80ac327
        v7 = v46;
        *v2 = v47;
        int32_t v49 = 1520; // 0x80ac338
        int32_t v50 = v48; // 0x80ac338
        if (v48 % 2 != 0) {
            // 0x80ac3e3
            *(char *)v48 = 0;
            v49 = 1519;
            v50 = v48 + 1;
        }
        int32_t v51 = v49; // 0x80ac344
        int32_t v52 = v50; // 0x80ac344
        if ((v50 & 2) != 0) {
            // 0x80ac3d3
            *(int16_t *)v50 = 0;
            v51 = v49 - 2;
            v52 = v50 + 2;
        }
        uint32_t v53 = v51 / 4; // 0x80ac34e
        __asm_rep_stosd_memset((char *)v52, 0, v53);
        int32_t v54 = v53 * (v14 ? -4 : 4) + v52; // 0x80ac354
        int32_t v55 = v54; // 0x80ac356
        if ((v51 & 2) != 0) {
            // 0x80ac358
            *(int16_t *)v54 = 0;
            v55 = v54 + 2;
        }
        if (v51 % 2 != 0) {
            // 0x80ac365
            *(char *)v55 = 0;
        }
        // 0x80ac368
        v10 = *v4;
    }
    // 0x80ac371
    *v4 = v10 + 1;
    return (int32_t *)(76 * v10 + (int32_t)v7);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/netlist.c
// Address range: 0x80ac9e0 - 0x80ac9fc
// Line range:    366 - 366
void register_netlist_action_list(void) {
    // 0x80ac9e0
    hid_register_actions(&netlist_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acbd0 - 0x80acc36
// Line range:    1723 - 1749
void yy_flush_buffer(int32_t * b) {
    if (b == NULL) {
        // 0x80acc0a
        return;
    }
    int32_t v1 = (int32_t)b;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80acbda
    int32_t * v3 = (int32_t *)(v1 + 16); // 0x80acbdd
    *v3 = 0;
    *(char *)*v2 = 0;
    *(char *)(*v2 + 1) = 0;
    int32_t v4 = *v2; // 0x80acbee
    *(int32_t *)(v1 + 28) = 1;
    *(int32_t *)(v1 + 36) = 0;
    *(int32_t *)(v1 + 8) = v4;
    if (&g79->e0 != b) {
        // 0x80acc0a
        return;
    }
    // 0x80acc10
    g81 = v4;
    yytext = v4;
    g84 = *v3;
    *(int32_t *)&yyin = *b;
    g83 = *(char *)v4;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acc40 - 0x80acc9e
// Line range:    1670 - 1686
void yy_delete_buffer(int32_t * b) {
    // 0x80acc40
    if (b == NULL) {
        // 0x80acc98
        return;
    }
    // 0x80acc4e
    if (&g79->e0 == b) {
        // 0x80acc88
        g79 = NULL;
    }
    int32_t v1 = (int32_t)b;
    if (*(int32_t *)(v1 + 20) == 0) {
        // 0x80acc5d
        int32_t v2; // 0x80acc40
        free((int32_t *)v2);
        return;
    }
    // 0x80acc70
    free((int32_t *)*(int32_t *)(v1 + 4));
    free(b);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acca0 - 0x80accd3
// Line range:    1914 - 1921
void yy_fatal_error(char * msg) {
    // 0x80acca0
    int32_t v1; // 0x80acca0
    __fprintf_chk((struct _IO_FILE *)g43, 1, "%s\n", (char *)v1);
    exit(2);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80ace50 - 0x80acea4
// Line range:    1696 - 1716
void yy_init_buffer(int32_t * b, struct _IO_FILE * file) {
    int32_t v1 = (int32_t)b;
    yy_flush_buffer(b);
    *b = (int32_t)file;
    *(int32_t *)(v1 + 32) = 1;
    if (file != NULL) {
        // 0x80ace77
        if (isatty(fileno(file)) >= 1) {
            // 0x80ace90
            *(int32_t *)(v1 + 24) = 1;
            return;
        }
    }
    // 0x80ace90
    *(int32_t *)(v1 + 24) = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80aceb0 - 0x80acf34
// Line range:    1639 - 1650
int32_t * yy_create_buffer(struct _IO_FILE * file, int32_t size) {
    int32_t * mem = calloc(1, 40); // 0x80aceca
    if (mem == NULL) {
        // 0x80acf28
        yy_fatal_error((char *)&g279);
        // UNREACHABLE
    }
    int32_t v1 = (int32_t)mem; // 0x80aceca
    *(int32_t *)(v1 + 12) = size;
    int32_t * mem2 = calloc(1, size + 2); // 0x80acee6
    *(int32_t *)(v1 + 4) = (int32_t)mem2;
    if (mem2 == NULL) {
        // 0x80acf18
        yy_fatal_error((char *)&g279);
        // UNREACHABLE
    }
    // 0x80acef2
    *(int32_t *)(v1 + 20) = 1;
    yy_init_buffer(mem, file);
    return mem;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acf40 - 0x80acfac
// Line range:    1581 - 1588
void yyrestart(struct _IO_FILE * input_file) {
    struct _IO_FILE * v1 = g79; // 0x80acf4d
    if (g79 == NULL) {
        int32_t * v2 = yy_create_buffer((struct _IO_FILE *)yyin, 0x4000); // 0x80acfa0
        g79 = (struct _IO_FILE *)v2;
        v1 = (struct _IO_FILE *)v2;
    }
    // 0x80acf4f
    yy_init_buffer(&v1->e0, input_file);
    int32_t v3 = (int32_t)g79; // 0x80acf5e
    g84 = *(int32_t *)(v3 + 16);
    int32_t v4 = *(int32_t *)(v3 + 8); // 0x80acf6c
    g81 = v4;
    yytext = v4;
    *(int32_t *)&yyin = g79->e0;
    g83 = *(char *)v4;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80acfb0 - 0x80ad223
// Line range:    203 - 225
int32_t Parse(char * Executable, char * Path, char * Filename, char * Parameter) {
    // 0x80acfb0
    int32_t v1; // 0x80acfb0
    int32_t str = v1;
    int32_t v2 = v1;
    int32_t * v3; // 0x80acfb0
    int32_t v4; // 0x80acfb0
    int32_t v5; // 0x80acfb0
    if (v2 == 0 || (char)v2 == 0) {
        int32_t v6 = 2; // 0x80ad0b7
        if (str != 0) {
            // 0x80ad0b9
            v6 = strlen((char *)str) + 2;
        }
        char * str2 = (char *)v1;
        int32_t * mem = calloc(1, strlen(str2) + v6); // 0x80ad0da
        if (mem == NULL) {
            // 0x80ad1fa
            __fprintf_chk((struct _IO_FILE *)g43, 1, "Parse():  malloc failed\n");
            exit(1);
            // UNREACHABLE
        }
        if ((char)str != 0 == (str != 0)) {
            // 0x80ad188
            __sprintf_chk((char *)mem, 1, -1, "%s%s%s", (char *)str, (char *)&g35, str2);
        } else {
            // 0x80ad0f6
            __sprintf_chk((char *)mem, 1, -1, "%s", str2);
        }
        struct _IO_FILE * file = fopen((char *)mem, "r"); // 0x80ad125
        *(int32_t *)&yyin = (int32_t)file;
        if (file == NULL) {
            // 0x80ad1e0
            Message("Can't open %s for reading\n", mem);
            // 0x80ad0a0
            return 1;
        }
        // 0x80ad137
        free(mem);
        v4 = 0;
        if (g38 != 0) {
            goto lab_0x80ad044;
        } else {
            // 0x80ad137
            v3 = yyin;
            v5 = 0;
            goto lab_0x80ad14e;
        }
    } else {
        int32_t v7 = g80; // 0x80acfce
        if (v7 != 0) {
            // 0x80acfd8
            SaveFree((char *)v7);
            g80 = 0;
        }
        char * command = EvaluateFilename((char *)v2, (char *)str, (char *)v1, Executable); // 0x80ad002
        int32_t v8 = (int32_t)command; // 0x80ad002
        g80 = v8;
        if (*command == 0) {
            // 0x80ad1c8
            PopenErrorMessage((char *)v8);
            return 1;
        }
        struct _IO_FILE * v9 = popen(command, "r"); // 0x80ad025
        *(int32_t *)&yyin = (int32_t)v9;
        if (v9 == NULL) {
            // 0x80ad1c8
            PopenErrorMessage((char *)g80);
            return 1;
        }
        // 0x80ad037
        v4 = 1;
        v3 = &v9->e0;
        v5 = 1;
        if (g38 == 0) {
            goto lab_0x80ad14e;
        } else {
            goto lab_0x80ad044;
        }
    }
  lab_0x80ad044:
    // 0x80ad044
    g38 = 0;
    yylineno = 1;
    if (PCB != NULL) {
        // 0x80ad065
        SaveTMPData();
    }
    int32_t result = yyparse(); // 0x80ad06a
    RemoveTMPData();
    yy_delete_buffer(&g79->e0);
    if (v4 == 0) {
        // 0x80ad160
        if (fclose((struct _IO_FILE *)yyin) == 0) {
            // 0x80ad0a0
            return result;
        }
        // 0x80ad0a0
        return 1;
    }
    // 0x80ad08b
    if (pclose((struct _IO_FILE *)yyin) == 0) {
        // 0x80ad0a0
        return result;
    }
    // 0x80ad0a0
    return 1;
  lab_0x80ad14e:
    // 0x80ad14e
    yyrestart((struct _IO_FILE *)v3);
    v4 = v5;
    goto lab_0x80ad044;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80ad230 - 0x80ad307
// Line range:    330 - 341
int32_t ParseFont(int32_t * Ptr, char * Filename) {
    // 0x80ad230
    *(int32_t *)&yyPCB = 0;
    *(int32_t *)&yyElement = 0;
    *(int32_t *)&yyFont = (int32_t)Ptr;
    char * str = __strdup(g160); // 0x80ad260
    char * next_token = strtok(str, ":"); // 0x80ad272
    if (next_token == NULL) {
        // 0x80ad2eb
        free((int32_t *)str);
        return 0;
    }
    // 0x80ad281
    if (*next_token == 0) {
        // 0x80ad2eb
        free((int32_t *)str);
        return 0;
    }
    char * v1 = next_token;
    Message("Looking for %s in %s\n", Filename, v1);
    int32_t result2 = Parse(NULL, (char *)&g279, (char *)&g279, (char *)&g279); // 0x80ad2cb
    while (result2 != 0) {
        char * next_token2 = strtok(NULL, ":"); // 0x80ad297
        int32_t result = result2; // 0x80ad2a0
        if (next_token2 == NULL) {
            // 0x80ad2eb
            free((int32_t *)str);
            return result;
        }
        // 0x80ad2a2
        result = result2;
        if (*next_token2 == 0) {
            // 0x80ad2eb
            free((int32_t *)str);
            return result;
        }
        v1 = next_token2;
        Message("Looking for %s in %s\n", Filename, v1);
        result2 = Parse(NULL, (char *)&g279, (char *)&g279, (char *)&g279);
    }
    // 0x80ad2d7
    Message("Found %s in %s\n", Filename, v1);
    // 0x80ad2eb
    free((int32_t *)str);
    return result2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80ad310 - 0x80ad357
// Line range:    318 - 324
int32_t ParsePCB(int32_t * Ptr, char * Filename) {
    // 0x80ad310
    *(int32_t *)&yyData = 0;
    *(int32_t *)&yyFont = 0;
    *(int32_t *)&yyElement = 0;
    *(int32_t *)&yyPCB = (int32_t)Ptr;
    return Parse(NULL, (char *)&g279, (char *)&g279, (char *)&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80ad400 - 0x80ad468
// Line range:    358 - 365
int32_t parse_number(float64_t scale) {
    // 0x80ad400
    float64_t val; // bp-20, 0x80ad400
    sscanf((char *)yytext, "%lf", &val);
    float80_t v1 = (float80_t)scale * (float80_t)val; // 0x80ad42b
    float80_t v2; // 0x80ad400
    if (v1 < 0.0L) {
        // 0x80ad43a
        yylval = v2 + (0 ? 0.49L : -0.49L);
        return 258;
    }
    bool v3 = true; // 0x80ad430
    bool v4 = false; // 0x80ad430
    if (v1 <= 0.0L) {
        v3 = v1 != 0.0L;
        v4 = true;
    }
    float80_t v5 = v3 | v4 ? 0.49L : -0.49L;
    yylval = v2 + v5;
    return 258;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80ad470 - 0x80adee1
// Line range:    753 - 1189
int32_t yylex(void) {
    // 0x80ad470
    char * v1; // 0x80ad470
    char v2; // 0x80ad470
    if (g39 == 0) {
        goto lab_0x80ad664_2;
    } else {
        int32_t v3 = g82;
        g39 = 0;
        g82 = v3 != 0 ? v3 : 1;
        int32_t * v4 = yyin; // 0x80ad4b2
        if (yyin == NULL) {
            // 0x80ad68c
            *(int32_t *)&yyin = (int32_t)g44;
            v4 = &g44->e0;
        }
        // 0x80ad4b8
        if (yyout == NULL) {
            // 0x80ad67d
            *(int32_t *)&yyout = (int32_t)g45;
        }
        int32_t v5 = (int32_t)g79; // 0x80ad4d0
        if (g79 == NULL) {
            int32_t * v6 = yy_create_buffer((struct _IO_FILE *)v4, 0x4000); // 0x80ad6ab
            g79 = (struct _IO_FILE *)v6;
            v5 = (int32_t)v6;
        }
        int32_t v7 = *(int32_t *)(v5 + 8); // 0x80ad4d9
        g84 = *(int32_t *)(v5 + 16);
        g81 = v7;
        yytext = v7;
        *(int32_t *)&yyin = *(int32_t *)v5;
        char * v8 = (char *)v7;
        char v9 = *v8; // 0x80ad4f4
        g83 = v9;
        v1 = v8;
        v2 = v9;
        goto lab_0x80ad4fc;
    }
  lab_0x80add22:;
    // 0x80add22
    int32_t v10; // 0x80ad470
    int32_t v11 = v10;
    g84 = v11;
    int32_t v12 = v11; // 0x80add28
    goto lab_0x80adbaa;
  lab_0x80adad7:
    // 0x80adad7
    g85 = 0;
    if (yywrap() == 0) {
        int32_t v265 = g85; // 0x80ade76
        if (v265 != 0) {
            goto lab_0x80ad664_2;
        } else {
            int32_t * v266 = yyin; // 0x80ade83
            yyrestart((struct _IO_FILE *)v266);
            goto lab_0x80ad664_2;
        }
    }
    int32_t v267 = g82; // 0x80adaee
    int32_t v268 = yytext; // 0x80adaf4
    int32_t v269 = v267 - 1; // 0x80adaf9
    g81 = v268;
    int32_t v52 = (int32_t)((0x100000000 * (int64_t)(v269 >> 31) | (int64_t)v269) / 2) + 47; // 0x80adb0b
    goto lab_0x80ad655;
  lab_0x80adbbe:;
    // 0x80adbbe
    struct _IO_FILE * v90; // bp-36, 0x80ad470
    struct _IO_FILE * v270 = v90; // 0x80adbbe
    int32_t v16; // 0x80ad470
    int32_t v17; // 0x80ad470
    int32_t v18; // 0x80ad470
    int32_t v19; // 0x80ad470
    if (v270 == NULL) {
        int32_t * v271 = yyin; // 0x80adeab
        yyrestart((struct _IO_FILE *)v271);
        int32_t v272 = g84; // 0x80adeb8
        struct _IO_FILE * v273 = g79; // 0x80adec3
        v17 = (int32_t)v273;
        v18 = v272;
        v19 = 1;
    } else {
        int32_t v274 = v16;
        int32_t v275 = g84; // 0x80adbc8
        *(int32_t *)(v274 + 36) = 2;
        v17 = v274;
        v18 = v275;
        v19 = 2;
    }
    goto lab_0x80adbda;
  lab_0x80adbda:;
    int32_t v276 = v19;
    int32_t v277 = v18;
    int32_t v278 = v17;
    int32_t v279 = *(int32_t *)(v278 + 4); // 0x80adbda
    struct _IO_FILE * v280 = v90; // 0x80adbdd
    int32_t v281 = v277 + (int32_t)v280; // 0x80adbdd
    g84 = v281;
    *(char *)(v281 + v279) = 0;
    struct _IO_FILE * v282 = g79; // 0x80adbed
    int32_t v283 = g84; // 0x80adbf2
    int32_t v284 = *(int32_t *)((int32_t)v282 + 4); // 0x80adbf8
    *(char *)(v283 + 1 + v284) = 0;
    struct _IO_FILE * v285 = g79; // 0x80adc00
    int32_t * v286 = (int32_t *)((int32_t)v285 + 4);
    int32_t v287 = *v286; // 0x80adc06
    yytext = v287;
    int32_t * v135; // 0x80ad470
    int32_t v190; // 0x80ad470
    int32_t v36; // 0x80ad470
    int32_t v136; // 0x80ad470
    int32_t v84; // 0x80ad7e9
    switch (v276) {
        case 1: {
            goto lab_0x80adad7;
        }
        case 2: {
            // 0x80add2d
            v90 = v285;
            v135 = v286;
            v136 = v287;
            goto lab_0x80ad88e_2;
        }
        default: {
            struct _IO_FILE * v288 = (struct _IO_FILE *)v287; // 0x80adc25
            v90 = v288;
            int32_t v289 = v36 + -1 - v84 + v287; // 0x80adc2b
            int32_t v290 = g82; // 0x80adc2d
            g81 = v289;
            g86 = v290;
            struct _IO_FILE * v291 = v288; // 0x80adc42
            int32_t v292 = v290; // 0x80adc42
            int32_t v293 = &g87; // 0x80adc42
            int32_t v294 = &g87; // 0x80adc42
            if (v289 > v287) {
                int32_t v295; // 0x80adca1
                while (true) {
                    int32_t v296 = v293;
                    int32_t v297 = v292;
                    struct _IO_FILE * v298 = v291; // 0x80adc9b
                    unsigned char v299 = *(char *)v298; // 0x80adc4c
                    int32_t v300 = 1; // 0x80adc51
                    if (v299 != 0) {
                        unsigned char v301 = *(char *)(4 * (int32_t)v299 + (int32_t)&g14); // 0x80adc56
                        v300 = v301;
                    }
                    int32_t v302 = v300;
                    int32_t v303 = v297; // 0x80ad470
                    int32_t v304 = v302; // 0x80ad470
                    int32_t v305; // 0x80ad470
                    while (true) {
                        int32_t v306 = v304;
                        int32_t v307 = v303;
                        int32_t v308 = v307; // 0x80ad470
                        int32_t v309 = v308;
                        int32_t v310 = 2 * v309;
                        int16_t v311 = *(int16_t *)(v310 + (int32_t)&g17); // 0x80adc5e
                        v305 = 2 * (v306 + (int32_t)v311);
                        int16_t v312 = *(int16_t *)(v305 + (int32_t)&g18); // 0x80adc6b
                        if (v309 == (int32_t)v312) {
                            // break (via goto) -> 0x80adc90
                            goto lab_0x80adc90;
                        }
                        uint16_t v313 = *(int16_t *)(v310 + (int32_t)&g15); // 0x80adc77
                        int32_t v314 = v313; // 0x80adc77
                        v308 = v314;
                        while (v313 < 180) {
                            // 0x80adc5e
                            v309 = v308;
                            v310 = 2 * v309;
                            v311 = *(int16_t *)(v310 + (int32_t)&g17);
                            v305 = 2 * (v306 + (int32_t)v311);
                            v312 = *(int16_t *)(v305 + (int32_t)&g18);
                            if (v309 == (int32_t)v312) {
                                // break (via goto) -> 0x80adc90
                                goto lab_0x80adc90;
                            }
                            // 0x80adc77
                            v313 = *(int16_t *)(v310 + (int32_t)&g15);
                            v314 = v313;
                            v308 = v314;
                        }
                        unsigned char v315 = *(char *)(4 * v306 + (int32_t)&g16); // 0x80adc86
                        v303 = v314;
                        v304 = v315;
                    }
                  lab_0x80adc90:;
                    int16_t v316 = *(int16_t *)(v305 + (int32_t)&g19); // 0x80adc93
                    int32_t v317 = v316; // 0x80adc93
                    v90 = (struct _IO_FILE *)((int32_t)v298 + 1);
                    *(int32_t *)v296 = v317;
                    v295 = v296 + 4;
                    struct _IO_FILE * v318 = v90; // 0x80adc3f
                    v291 = v318;
                    v292 = v317;
                    v293 = v295;
                    if (v289 <= (int32_t)v318) {
                        // break -> 0x80adc3f
                        break;
                    }
                }
                // 0x80adc3f
                v294 = v295;
            }
            int32_t v319 = v294;
            struct _IO_FILE * v320 = (struct _IO_FILE *)v319;
            g88 = v320;
            v190 = v319;
            goto lab_0x80adcba;
        }
    }
  lab_0x80adbaa:;
    int32_t v13 = v12; // 0x80adbaa
    struct _IO_FILE * v14 = g79; // 0x80adbb2
    int32_t v15 = (int32_t)v14; // 0x80adbb2
    *(int32_t *)(v15 + 16) = v13;
    v16 = v15;
    v17 = v15;
    v18 = v13;
    v19 = 0;
    if (v13 != 0) {
        goto lab_0x80adbda;
    } else {
        goto lab_0x80adbbe;
    }
  lab_0x80adacc:;
    // 0x80adacc
    int32_t v20; // 0x80ad470
    int32_t v21 = v20;
    int32_t v22; // 0x80ad470
    int32_t v23 = v22;
    struct _IO_FILE * v24; // 0x80ad470
    struct _IO_FILE * v25 = v24; // 0x80adacc
    struct _IO_FILE * v26 = v25; // 0x80adad2
    int32_t v27 = v23; // 0x80adad2
    int32_t v28 = v21; // 0x80adad2
    goto lab_0x80ad5a1;
  lab_0x80adcba:;
    int32_t v189 = v190;
    *(int32_t *)&v90 = v189;
    goto lab_0x80ad51c;
  lab_0x80ad664_2:
    // 0x80ad664
    v1 = (char *)g81;
    v2 = g83;
    goto lab_0x80ad4fc;
  lab_0x80ad4fc:
    // 0x80ad4fc
    *v1 = v2;
    g88 = (struct _IO_FILE *)&g87;
    v90 = (struct _IO_FILE *)&g87;
    g86 = g82;
    while (true) {
      lab_0x80ad51c:;
        // 0x80ad51c
        int32_t v191; // 0x80ad574
        struct _IO_FILE * v192; // 0x80ad470
        while (true) {
            // 0x80ad528
            int32_t v193; // 0x80ad470
            int32_t v194 = v193;
            int16_t v195; // 0x80ad470
            int16_t v196 = v195;
            int32_t v197; // 0x80ad470
            int32_t v198 = v197;
            struct _IO_FILE * v199; // 0x80ad470
            struct _IO_FILE * v200 = v199; // 0x80ad577
            unsigned char v201 = *(char *)v194; // 0x80ad528
            unsigned char v202 = *(char *)(4 * (int32_t)v201 + (int32_t)&g14); // 0x80ad52b
            int32_t v203 = v202; // 0x80ad52b
            int32_t v204 = 2 * (v203 + (int32_t)v196);
            int16_t v205 = *(int16_t *)(v204 + (int32_t)&g18); // 0x80ad560
            int32_t v206 = v203; // 0x80ad56a
            int32_t v207 = v203; // 0x80ad56a
            int32_t v208 = v198; // 0x80ad56a
            int32_t v209 = v204; // 0x80ad56a
            if (v198 != (int32_t)v205) {
                int32_t v210 = v208;
                int32_t v211 = v207;
                uint16_t v212 = *(int16_t *)(2 * v210 + (int32_t)&g15); // 0x80ad538
                int32_t v213 = v211; // 0x80ad545
                int32_t v214; // 0x80ad470
                unsigned char v215; // 0x80ad547
                if (v212 >= 180) {
                    // 0x80ad547
                    v214 = v206;
                    v215 = *(char *)(4 * v214 + (int32_t)&g16);
                    v213 = v215;
                }
                int32_t v216 = v212; // 0x80ad538
                int32_t v217 = v213;
                int16_t v218 = *(int16_t *)(2 * v216 + (int32_t)&g17); // 0x80ad54f
                int32_t v219 = v217 % 256; // 0x80ad557
                int32_t v220 = 2 * (v219 + (int32_t)v218);
                int16_t v221 = *(int16_t *)(v220 + (int32_t)&g18); // 0x80ad560
                v206 = v219;
                v207 = v217;
                v208 = v216;
                v209 = v220;
                while (v212 != v221) {
                    // 0x80ad538
                    v210 = v208;
                    v211 = v207;
                    v212 = *(int16_t *)(2 * v210 + (int32_t)&g15);
                    v213 = v211;
                    if (v212 >= 180) {
                        // 0x80ad547
                        v214 = v206;
                        v215 = *(char *)(4 * v214 + (int32_t)&g16);
                        v213 = v215;
                    }
                    // 0x80ad54f
                    v216 = v212;
                    v217 = v213;
                    v218 = *(int16_t *)(2 * v216 + (int32_t)&g17);
                    v219 = v217 % 256;
                    v220 = 2 * (v219 + (int32_t)v218);
                    v221 = *(int16_t *)(v220 + (int32_t)&g18);
                    v206 = v219;
                    v207 = v217;
                    v208 = v216;
                    v209 = v220;
                }
            }
            int32_t v222 = v209;
            int16_t v223 = *(int16_t *)(v222 + (int32_t)&g19); // 0x80ad56c
            int32_t v224 = v223; // 0x80ad56c
            v191 = v194 + 1;
            v200->e0 = v224;
            v192 = (struct _IO_FILE *)((int32_t)v200 + 4);
            v90 = v192;
            int16_t v225 = *(int16_t *)(2 * v224 + (int32_t)&g17); // 0x80ad582
            v199 = v192;
            v197 = v224;
            v195 = v225;
            v193 = v191;
            if (v225 == 232) {
                // break -> 0x80ad591
                break;
            }
        }
        // 0x80ad591
        g88 = v192;
        v26 = v192;
        v27 = v191;
        int32_t v226; // 0x80ad470
        v28 = v226;
        int32_t v186; // 0x80ade5e
        int32_t v188; // 0x80ad470
        while (true) {
          lab_0x80ad5a1:;
            int32_t v29 = v28;
            int32_t v30 = v27;
            struct _IO_FILE * v31 = v26;
            int32_t v32 = (int32_t)v31; // 0x80ad5af
            int32_t v33 = v30; // 0x80ad5af
            int32_t v34; // 0x80ad470
            int16_t v35; // 0x80ad470
            while (true) {
                // 0x80ad5c8
                v36 = v33;
                int32_t v37 = v32;
                v34 = v37 - 4;
                int32_t v38 = *(int32_t *)v34;
                int32_t v39 = 2 * v38;
                v35 = *(int16_t *)(v39 + (int32_t)&g20);
                if (v35 != 0) {
                    int16_t v40 = *(int16_t *)(v39 + (int32_t)&g21); // 0x80ad5cc
                    if (v35 < v40) {
                        // break -> 0x80ad5d8
                        break;
                    }
                }
                // 0x80ad5b8
                v32 = v34;
                v33 = v36 - 1;
            }
            int32_t v41 = v35;
            g88 = (struct _IO_FILE *)v34;
            int16_t v42 = *(int16_t *)(2 * v41 + (int32_t)&g22); // 0x80ad5e1
            g90 = v41;
            g89 = v36;
            yytext = v29;
            yyleng = v36 - v29;
            char * v43 = (char *)v36; // 0x80ad601
            char v44 = *v43; // 0x80ad601
            g83 = v44;
            *v43 = 0;
            g81 = v36;
            if (v42 != 46) {
                uint32_t v45 = yyleng; // 0x80ad618
                if (v45 >= 1) {
                    int32_t v46 = yytext; // 0x80ad622
                    int32_t v47 = 0; // 0x80ad62a
                    while (true) {
                        int32_t v48 = v47;
                        char v49 = *(char *)(v48 + v46); // 0x80ad637
                        int32_t v50 = v48 + 1;
                        if (v49 != 10) {
                            if (v50 == v45) {
                                // break -> 0x80ad650
                                break;
                            }
                        } else {
                            int32_t v51 = yylineno; // 0x80ad640
                            yylineno = v51 + 1;
                            if (v50 == v45) {
                                // break -> 0x80ad650
                                break;
                            }
                        }
                        // 0x80ad637
                        v47 = v50;
                    }
                }
            }
            // 0x80ad650
            v52 = v42;
            int32_t v53; // 0x80ad470
            while (true) {
              lab_0x80ad655:;
                int32_t v54 = v52;
                g273 = v54;
                int32_t v55 = 0; // 0x80ad676
                int32_t result; // 0x80ad470
                switch (v54) {
                    case 1: {
                        // 0x80ada05
                        v55 = 262;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 2: {
                        // 0x80ad913
                        v55 = 263;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 3: {
                        // 0x80ada0f
                        v55 = 275;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 4: {
                        // 0x80ad6e2
                        v55 = 279;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 5: {
                        // 0x80ad6d6
                        v55 = 289;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 6: {
                        // 0x80ad6cf
                        v55 = 288;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 7: {
                        // 0x80ad6c8
                        v55 = 290;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 8: {
                        // 0x80ad722
                        v55 = 276;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 9: {
                        // 0x80ad719
                        v55 = 264;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 10: {
                        // 0x80ad712
                        v55 = 273;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 11: {
                        // 0x80ad709
                        v55 = 274;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 12: {
                        // 0x80ad702
                        v55 = 265;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 13: {
                        // 0x80ad6f9
                        v55 = 267;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 14: {
                        // 0x80ad6f2
                        v55 = 266;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 15: {
                        // 0x80ad6e9
                        v55 = 269;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 16: {
                        // 0x80ada19
                        v55 = 270;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 17: {
                        // 0x80ad9a5
                        v55 = 271;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 18: {
                        // 0x80ad996
                        v55 = 280;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 19: {
                        // 0x80ad98c
                        v55 = 272;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 20: {
                        // 0x80ad982
                        v55 = 278;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 21: {
                        // 0x80ad9f9
                        v55 = 277;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 22: {
                        // 0x80ad9ef
                        v55 = 281;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 23: {
                        // 0x80ad9e5
                        v55 = 282;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 24: {
                        // 0x80ad9d9
                        v55 = 283;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 25: {
                        // 0x80ad9cf
                        v55 = 284;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 26: {
                        // 0x80ad9c5
                        v55 = 268;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 27: {
                        // 0x80ad9b9
                        v55 = 285;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 28: {
                        // 0x80ad9af
                        v55 = 286;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 29: {
                        // 0x80ad748
                        v55 = 287;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 30: {
                        // 0x80ad73e
                        v55 = 291;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 31: {
                        int32_t v56 = yytext; // 0x80ad729
                        char v57 = *(char *)(v56 + 1); // 0x80ad72e
                        yylval = v57;
                        v55 = 259;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 32: {
                        // 0x80ad79a
                        v55 = parse_number(5.7576694970416511e-315);
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 33: {
                        // 0x80ad787
                        v55 = parse_number(5.345129346743907e-315);
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 34: {
                        // 0x80ad774
                        v55 = parse_number(5.948463104172927e-315);
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 35: {
                        // 0x80ad761
                        v55 = parse_number(5.5355285709140466e-315);
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 36: {
                        // 0x80ad752
                        v55 = parse_number(5.2635442471208903e-315);
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 37: {
                        int32_t str = yytext; // 0x80ad95b
                        sscanf((char *)str, "%x", &yylval);
                        v55 = 258;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 38: {
                        int32_t v58 = yytext; // 0x80ad93e
                        yylval = (float32_t)c_strtod((char *)v58);
                        v55 = 260;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 39: {
                        int32_t v59 = yyleng; // 0x80ad91d
                        if (v59 == 2) {
                            // 0x80ad92b
                            yylval = 0;
                            v55 = v59 & -0x10000 | 261;
                            // 0x80ad6c0
                            result = v55;
                            return result;
                        }
                        // 0x80ada4e
                        yyleng = v59 - 2;
                        int32_t v60 = (int32_t)MyCalloc(v59 - 1, 1, "LEX"); // 0x80ada6d
                        int32_t v61 = yytext; // 0x80ada72
                        yylval = v60;
                        int32_t v62 = yyleng; // 0x80ada85
                        yyleng = v62 - 1;
                        int32_t v63 = v62; // 0x80ada96
                        int32_t v64 = v61; // 0x80ada96
                        int32_t v65 = v60; // 0x80ada96
                        int32_t v66 = v60; // 0x80ada96
                        if (v62 != 0) {
                            int32_t v67 = v65;
                            int32_t v68 = v64;
                            int32_t v69 = v68 + 1; // 0x80ada98
                            char v70 = *(char *)v69; // 0x80ada9b
                            int32_t v71 = v69; // 0x80adaa1
                            char v72 = v70; // 0x80adaa1
                            int32_t v73; // 0x80ad470
                            int32_t v74; // 0x80adaa6
                            char v75; // 0x80adaaf
                            if (v70 == 92) {
                                // 0x80adaa3
                                v73 = v63;
                                v74 = v68 + 2;
                                yyleng = v73 - 2;
                                v75 = *(char *)v74;
                                v71 = v74;
                                v72 = v75;
                            }
                            char v76 = v72;
                            int32_t v77 = v71;
                            *(char *)v67 = v76;
                            int32_t v78 = v67 + 1; // 0x80ada82
                            int32_t v79 = yyleng; // 0x80ada85
                            yyleng = v79 - 1;
                            v63 = v79;
                            v64 = v77;
                            v65 = v78;
                            v66 = v78;
                            while (v79 != 0) {
                                // 0x80ada98
                                v67 = v65;
                                v68 = v64;
                                v69 = v68 + 1;
                                v70 = *(char *)v69;
                                v71 = v69;
                                v72 = v70;
                                if (v70 == 92) {
                                    // 0x80adaa3
                                    v73 = v63;
                                    v74 = v68 + 2;
                                    yyleng = v73 - 2;
                                    v75 = *(char *)v74;
                                    v71 = v74;
                                    v72 = v75;
                                }
                                // 0x80ada80
                                v76 = v72;
                                v77 = v71;
                                *(char *)v67 = v76;
                                v78 = v67 + 1;
                                v79 = yyleng;
                                yyleng = v79 - 1;
                                v63 = v79;
                                v64 = v77;
                                v65 = v78;
                                v66 = v78;
                            }
                        }
                        int32_t v80 = v66;
                        *(char *)v80 = 0;
                        v55 = 261;
                      lab_0x80ad6c0:
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 40: {
                        goto lab_0x80ad664_2;
                    }
                    case 41: {
                        goto lab_0x80ad664_2;
                    }
                    case 42: {
                        goto lab_0x80ad664_2;
                    }
                    case 43: {
                        goto lab_0x80ad664_2;
                    }
                    case 44: {
                        int32_t v81 = yytext; // 0x80ad7ad
                        char v82 = *(char *)v81; // 0x80ad7b2
                        v55 = v82;
                        // 0x80ad6c0
                        result = v55;
                        return result;
                    }
                    case 45: {
                        int32_t * stream = yyout; // 0x80ad7ba
                        int32_t size = yyleng; // 0x80ad7cb
                        int32_t v83 = yytext; // 0x80ad7d4
                        fwrite(&((struct _IO_FILE *)v83)->e0, size, 1, (struct _IO_FILE *)stream);
                        goto lab_0x80ad664_2;
                    }
                    case 46: {
                        // 0x80ad7e6
                        v84 = yytext;
                        char v85 = g83; // 0x80ad7f4
                        *v43 = v85;
                        struct _IO_FILE * v86 = g79; // 0x80ad7fd
                        int32_t v87 = (int32_t)v86; // 0x80ad7fd
                        int32_t * v88 = (int32_t *)(v87 + 36);
                        int32_t v89 = *v88; // 0x80ad802
                        v90 = v86;
                        int32_t v91; // 0x80ad470
                        if (v89 != 0) {
                            int32_t v92 = g84; // 0x80ada43
                            v91 = v92;
                        } else {
                            int32_t v93 = *(int32_t *)(v87 + 16); // 0x80ad80f
                            int32_t * v94 = yyin; // 0x80ad812
                            g84 = v93;
                            v86->e0 = (int32_t)v94;
                            *v88 = 1;
                            v91 = v93;
                        }
                        int32_t v95 = v91;
                        int32_t v96 = *(int32_t *)(v87 + 4); // 0x80ad827
                        uint32_t v97 = g81; // 0x80ad830
                        uint32_t v98 = v96 + v95;
                        v53 = yytext;
                        if (v98 >= v97) {
                            // break -> 0x80add74
                            break;
                        }
                        if (v97 > v98 + 1) {
                            // 0x80ad857
                            yy_fatal_error((char *)v53);
                            // UNREACHABLE
                        }
                        int32_t v99 = *(int32_t *)(v87 + 32); // 0x80ad878
                        if (v99 != 0) {
                            uint32_t v100 = v97 + -1 - v53; // 0x80adb16
                            struct _IO_FILE * v101 = (struct _IO_FILE *)v100; // 0x80adb1a
                            v90 = v101;
                            int32_t v102 = 0; // 0x80adb1d
                            int32_t * v103 = v88; // 0x80adb1d
                            struct _IO_FILE * v104 = v101; // 0x80adb1d
                            int32_t v105 = v87; // 0x80adb1d
                            if (v100 >= 1) {
                                int32_t v106 = v102;
                                char v107 = *(char *)(v106 + v53); // 0x80adb27
                                *(char *)(v106 + v96) = v107;
                                int32_t v108 = v106 + 1; // 0x80adb2e
                                struct _IO_FILE * v109 = v90; // 0x80adb31
                                v102 = v108;
                                while (v108 != (int32_t)v109) {
                                    // 0x80adb27
                                    v106 = v102;
                                    v107 = *(char *)(v106 + v53);
                                    *(char *)(v106 + v96) = v107;
                                    v108 = v106 + 1;
                                    v109 = v90;
                                    v102 = v108;
                                }
                                struct _IO_FILE * v110 = g79; // 0x80adb36
                                int32_t v111 = (int32_t)v110; // 0x80adb36
                                v103 = (int32_t *)(v111 + 36);
                                v104 = v109;
                                v105 = v111;
                            }
                            int32_t v112 = v105;
                            int32_t * v113 = v103;
                            int32_t v114 = *v113; // 0x80adb3b
                            if (v114 == 2) {
                                // 0x80ade95
                                g84 = 0;
                                *(int32_t *)(v112 + 16) = 0;
                                v16 = v112;
                                goto lab_0x80adbbe;
                            } else {
                                struct _IO_FILE * v115 = v104; // 0x80adb45
                                int32_t v116 = (int32_t)v115; // 0x80adb45
                                int32_t v117 = *(int32_t *)(v112 + 12); // 0x80adb4a
                                int32_t v118 = v117 + -1 - v116; // 0x80adb4a
                                if (v118 >= 0 != v118 != 0) {
                                    // 0x80adb51
                                    yy_fatal_error((char *)&g279);
                                    // UNREACHABLE
                                }
                                int32_t v119 = v118 - 0x2000; // 0x80adb5d
                                uint32_t nmemb = v119 == 0 | v119 < 0 != (0x1fff - v118 & v118) < 0 ? v118 : 0x2000; // 0x80adb68
                                int32_t v120 = *(int32_t *)(v112 + 24); // 0x80adb6d
                                int32_t v121 = 0; // 0x80adb71
                                if (v120 != 0) {
                                    int32_t v122 = v121;
                                    int32_t * v123 = yyin; // 0x80adcf5
                                    int32_t v124 = _IO_getc((struct _IO_FILE *)v123); // 0x80adcfd
                                    while (v124 != -1) {
                                        struct _IO_FILE * v125 = g79;
                                        int32_t v126 = (int32_t)v125;
                                        if (v124 == 10) {
                                            struct _IO_FILE * v127 = v90; // 0x80add63
                                            int32_t v128 = *(int32_t *)(v126 + 4); // 0x80add66
                                            *(char *)(v122 + (int32_t)v127 + v128) = 10;
                                            v10 = v122 + 1;
                                            goto lab_0x80add22;
                                        }
                                        int32_t v129 = *(int32_t *)(v126 + 4); // 0x80adcdc
                                        struct _IO_FILE * v130 = v90; // 0x80adce2
                                        int32_t v131 = v122 + 1; // 0x80adcea
                                        *(char *)(v129 + v122 + (int32_t)v130) = (char)v124;
                                        v121 = v131;
                                        v10 = v131;
                                        if (nmemb <= v131) {
                                            goto lab_0x80add22;
                                        }
                                        v122 = v121;
                                        v123 = yyin;
                                        v124 = _IO_getc((struct _IO_FILE *)v123);
                                    }
                                    int32_t * stream2 = yyin; // 0x80add07
                                    v10 = v122;
                                    if (ferror((struct _IO_FILE *)stream2) != 0) {
                                        // 0x80add18
                                        yy_fatal_error((char *)&g279);
                                        // UNREACHABLE
                                    }
                                    goto lab_0x80add22;
                                } else {
                                    int32_t * stream3 = yyin; // 0x80adb77
                                    int32_t v132 = *(int32_t *)(v112 + 4); // 0x80adb8d
                                    int32_t items_read = fread(&((struct _IO_FILE *)(v132 + v116))->e0, 1, nmemb, (struct _IO_FILE *)stream3); // 0x80adb96
                                    g84 = items_read;
                                    v12 = items_read;
                                    if (items_read == 0) {
                                        int32_t * stream4 = yyin; // 0x80add38
                                        if (ferror((struct _IO_FILE *)stream4) != 0) {
                                            // 0x80add49
                                            yy_fatal_error((char *)&g279);
                                            // UNREACHABLE
                                        }
                                        int32_t v133 = g84; // 0x80add53
                                        v12 = v133;
                                    }
                                    goto lab_0x80adbaa;
                                }
                            }
                        } else {
                            if (v97 != v53 + 1) {
                                struct _IO_FILE * v134 = v90;
                                v135 = (int32_t *)((int32_t)v134 + 4);
                                v136 = v53;
                                goto lab_0x80ad88e_2;
                            }
                            goto lab_0x80adad7;
                        }
                    }
                    case 47: {
                        goto lab_0x80ad6c0;
                    }
                    default: {
                        goto lab_0x80ad65a;
                    }
                }
            }
            int32_t v137 = g82; // 0x80add84
            int32_t v138 = v36 + -1 - v84 + v53; // 0x80add89
            g81 = v138;
            g86 = v137;
            int32_t v139 = &g87; // 0x80adda1
            int32_t v140 = v53; // 0x80adda1
            int32_t v141 = v137; // 0x80adda1
            int32_t v142 = v137; // 0x80adda1
            int32_t v143 = &g87; // 0x80adda1
            if (v138 > v53) {
                while (true) {
                    int32_t v144 = v141;
                    int32_t v145 = v140;
                    int32_t v146 = v139;
                    unsigned char v147 = *(char *)v145; // 0x80adda3
                    v90 = (struct _IO_FILE *)1;
                    int32_t v148 = 1; // 0x80addae
                    if (v147 != 0) {
                        unsigned char v149 = *(char *)(4 * (int32_t)v147 + (int32_t)&g14); // 0x80addb6
                        v148 = v149;
                    }
                    int32_t v150 = v148;
                    int32_t v151 = v144; // 0x80ad470
                    int32_t v152 = v150; // 0x80ad470
                    int32_t v153; // 0x80ad470
                    while (true) {
                        int32_t v154 = v152;
                        int32_t v155 = v151;
                        struct _IO_FILE * v156 = (struct _IO_FILE *)v154; // 0x80addcc
                        int32_t v157 = v155; // 0x80ad470
                        int32_t v158 = v157;
                        int32_t v159 = 2 * v158;
                        int16_t v160 = *(int16_t *)(v159 + (int32_t)&g17); // 0x80addbe
                        v90 = v156;
                        v153 = 2 * (v154 + (int32_t)v160);
                        int16_t v161 = *(int16_t *)(v153 + (int32_t)&g18); // 0x80addd8
                        if (v158 == (int32_t)v161) {
                            // break (via goto) -> 0x80ade06
                            goto lab_0x80ade06;
                        }
                        uint16_t v162 = *(int16_t *)(v159 + (int32_t)&g15); // 0x80adde4
                        int32_t v163 = v162; // 0x80adde4
                        v157 = v163;
                        while (v162 < 180) {
                            // 0x80addbe
                            v158 = v157;
                            v159 = 2 * v158;
                            v160 = *(int16_t *)(v159 + (int32_t)&g17);
                            v90 = v156;
                            v153 = 2 * (v154 + (int32_t)v160);
                            v161 = *(int16_t *)(v153 + (int32_t)&g18);
                            if (v158 == (int32_t)v161) {
                                // break (via goto) -> 0x80ade06
                                goto lab_0x80ade06;
                            }
                            // 0x80adde4
                            v162 = *(int16_t *)(v159 + (int32_t)&g15);
                            v163 = v162;
                            v157 = v163;
                        }
                        unsigned char v164 = *(char *)(4 * v154 + (int32_t)&g16); // 0x80addf6
                        v151 = v163;
                        v152 = v164;
                    }
                  lab_0x80ade06:;
                    int32_t v165 = v146 + 4; // 0x80ade09
                    int32_t v166 = v145 + 1; // 0x80ade0c
                    int16_t v167 = *(int16_t *)(v153 + (int32_t)&g19); // 0x80ade0f
                    int32_t v168 = v167; // 0x80ade0f
                    *(int32_t *)v146 = v168;
                    v139 = v165;
                    v140 = v166;
                    v141 = v168;
                    v142 = v168;
                    v143 = v165;
                    if (v166 == v138) {
                        // break -> 0x80ade1d
                        break;
                    }
                }
            }
            int32_t v169 = v143;
            int32_t v170 = v142;
            struct _IO_FILE * v171 = (struct _IO_FILE *)v169; // 0x80ade1f
            g88 = v171;
            int16_t v172 = *(int16_t *)(2 * v170 + (int32_t)&g17); // 0x80ade2f
            int32_t v173 = 2 * (int32_t)v172 | 1;
            int16_t v174 = *(int16_t *)(v173 + 0x814b261); // 0x80ade3a
            int32_t v175 = v170; // 0x80ade44
            int32_t v176 = v173; // 0x80ade44
            if (v170 != (int32_t)v174) {
                int32_t v177 = v175;
                int16_t v178 = *(int16_t *)(2 * v177 + (int32_t)&g15); // 0x80ade27
                int32_t v179 = v178; // 0x80ade27
                int16_t v180 = *(int16_t *)(2 * v179 + (int32_t)&g17); // 0x80ade2f
                int32_t v181 = 2 * (int32_t)v180 | 1;
                int16_t v182 = *(int16_t *)(v181 + 0x814b261); // 0x80ade3a
                v175 = v179;
                v176 = v181;
                while (v178 != v182) {
                    // 0x80ade27
                    v177 = v175;
                    v178 = *(int16_t *)(2 * v177 + (int32_t)&g15);
                    v179 = v178;
                    v180 = *(int16_t *)(2 * v179 + (int32_t)&g17);
                    v181 = 2 * (int32_t)v180 | 1;
                    v182 = *(int16_t *)(v181 + 0x814b261);
                    v175 = v179;
                    v176 = v181;
                }
            }
            int32_t v183 = v176;
            int16_t v184 = *(int16_t *)(v183 + 0x814b4a1); // 0x80ade46
            v24 = v171;
            v22 = v138;
            v20 = v53;
            if (v184 != 179) {
                int32_t v185 = v184; // 0x80ade46
                *(int32_t *)v169 = v185;
                v186 = v169 + 4;
                struct _IO_FILE * v187 = (struct _IO_FILE *)v186;
                g88 = v187;
                v188 = g81;
                v24 = v187;
                v22 = v188;
                v20 = v53;
                if (v184 != 0) {
                    // break -> 0x80adecd
                    break;
                }
            }
            goto lab_0x80adacc;
        }
        int32_t v227 = v188 + 1; // 0x80aded3
        g81 = v227;
        v190 = v186;
        goto lab_0x80adcba;
    }
  lab_0x80ad65a:
    // 0x80ad65a
    yy_fatal_error((char *)&g279);
    // UNREACHABLE
  lab_0x80ad88e_2:;
    int32_t v228 = v136;
    int32_t * v229 = v135;
    int32_t v230 = g82; // 0x80ad899
    int32_t v231 = *v229; // 0x80ad8a1
    int32_t v232 = g84; // 0x80ad8a4
    int32_t v233 = v232 + v231; // 0x80ad8a4
    struct _IO_FILE * v234 = (struct _IO_FILE *)v228; // 0x80ad8aa
    v90 = v234;
    g86 = v230;
    g81 = v233;
    struct _IO_FILE * v235 = v234; // 0x80ad8bd
    int32_t v236 = v230; // 0x80ad8bd
    int32_t v237 = &g87; // 0x80ad8bd
    int32_t v238 = &g87; // 0x80ad8bd
    if (v233 > v228) {
        while (true) {
            int32_t v239 = v237;
            int32_t v240 = v236;
            struct _IO_FILE * v241 = v235; // 0x80ada30
            unsigned char v242 = *(char *)v241; // 0x80ad8cb
            int32_t v243 = 1; // 0x80ad8d0
            if (v242 != 0) {
                unsigned char v244 = *(char *)(4 * (int32_t)v242 + (int32_t)&g14); // 0x80ad8d5
                v243 = v244;
            }
            int32_t v245 = v243;
            int32_t v246 = v240; // 0x80ad470
            int32_t v247 = v245; // 0x80ad470
            int32_t v248; // 0x80ad470
            while (true) {
                int32_t v249 = v247;
                int32_t v250 = v246;
                int32_t v251 = v250; // 0x80ad470
                int32_t v252 = v251;
                int32_t v253 = 2 * v252;
                int16_t v254 = *(int16_t *)(v253 + (int32_t)&g17); // 0x80ad8dd
                v248 = 2 * (v249 + (int32_t)v254);
                int16_t v255 = *(int16_t *)(v248 + (int32_t)&g18); // 0x80ad8ea
                if (v252 == (int32_t)v255) {
                    // break (via goto) -> 0x80ada25
                    goto lab_0x80ada25;
                }
                uint16_t v256 = *(int16_t *)(v253 + (int32_t)&g15); // 0x80ad8fa
                int32_t v257 = v256; // 0x80ad8fa
                v251 = v257;
                while (v256 < 180) {
                    // 0x80ad8dd
                    v252 = v251;
                    v253 = 2 * v252;
                    v254 = *(int16_t *)(v253 + (int32_t)&g17);
                    v248 = 2 * (v249 + (int32_t)v254);
                    v255 = *(int16_t *)(v248 + (int32_t)&g18);
                    if (v252 == (int32_t)v255) {
                        // break (via goto) -> 0x80ada25
                        goto lab_0x80ada25;
                    }
                    // 0x80ad8fa
                    v256 = *(int16_t *)(v253 + (int32_t)&g15);
                    v257 = v256;
                    v251 = v257;
                }
                unsigned char v258 = *(char *)(4 * v249 + (int32_t)&g16); // 0x80ad909
                v246 = v257;
                v247 = v258;
            }
          lab_0x80ada25:;
            int16_t v259 = *(int16_t *)(v248 + (int32_t)&g19); // 0x80ada28
            int32_t v260 = v259; // 0x80ada28
            v90 = (struct _IO_FILE *)((int32_t)v241 + 1);
            int32_t v261 = v239 + 4; // 0x80ada36
            *(int32_t *)v239 = v260;
            struct _IO_FILE * v262 = v90; // 0x80ad8ba
            v235 = v262;
            v236 = v260;
            v237 = v261;
            v238 = v261;
            if (v233 <= (int32_t)v262) {
                // break -> 0x80adac1
                break;
            }
        }
    }
    int32_t v263 = v238;
    struct _IO_FILE * v264 = (struct _IO_FILE *)v263; // 0x80adac6
    g88 = v264;
    v24 = v264;
    v22 = v233;
    v20 = v228;
    goto lab_0x80adacc;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_y.y
// Address range: 0x80adef0 - 0x80adefa
// Line range:    1906 - 1909
int32_t yywrap(void) {
    // 0x80adef0
    return 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_y.c
// Address range: 0x80adf30 - 0x80b093b
// Line range:    1711 - 910
int32_t yyparse(void) {
    // 0x80adf30
    int32_t v1; // bp-3188, 0x80adf30
    int32_t v2 = &v1; // 0x80adf42
    int32_t v3 = __readgsdword(20); // 0x80adf4c
    int32_t v4; // bp-788, 0x80adf30
    int32_t v5 = &v4; // 0x80adf69
    yynerrs = 0;
    yychar = -2;
    int32_t v6; // bp-52, 0x80adf30
    int32_t v7 = &v6;
    int32_t v8; // bp-40, 0x80adf30
    int32_t v9 = &v8;
    int32_t v10; // bp-376, 0x80adf30
    int32_t v11 = &v10;
    int32_t v12; // bp-3212, 0x80adf30
    int32_t v13 = &v12;
    int32_t v14 = v2; // 0x80adfbb
    int32_t v15 = v5; // 0x80adfbb
    int32_t v16 = 200; // 0x80adfbb
    int32_t v17 = 0; // 0x80adfbb
    int32_t v18 = 199; // 0x80adfbb
    int32_t v19 = v5; // 0x80adfbb
    int32_t v20 = 0; // 0x80adfbb
    int32_t v21; // bp-3388, 0x80adf30
    int32_t v22 = &v21; // 0x80adfbb
    int32_t v23 = v2; // 0x80adfbb
    int32_t * v24; // 0x80adf30
    int32_t v25; // 0x80adf30
    int32_t v26; // 0x80adf30
    int32_t v27; // 0x80adf30
    int32_t v28; // 0x80adf30
    int32_t nmemb; // 0x80adf30
    int32_t v29; // 0x80adf30
    int32_t v30; // 0x80adf30
    int32_t v31; // 0x80adf30
    int32_t v32; // 0x80adf30
    int32_t v33; // 0x80adf30
    int32_t v34; // 0x80adf30
    int32_t v35; // 0x80adf30
    int32_t v36; // 0x80adf30
    int32_t v37; // 0x80adf30
    int32_t v38; // 0x80adf30
    int32_t v39; // 0x80adf30
    int32_t v40; // 0x80adf30
    int32_t v41; // 0x80adf30
    int32_t v42; // 0x80adf30
    int32_t v43; // 0x80adf30
    int32_t v44; // 0x80adf30
    int32_t v45; // 0x80adf30
    int32_t v46; // 0x80adf30
    int32_t v47; // 0x80adf30
    int32_t v48; // 0x80adf30
    int32_t v49; // 0x80adf30
    int32_t v50; // 0x80adf30
    int32_t v51; // 0x80adf30
    int32_t v52; // 0x80adf30
    int32_t v53; // 0x80adf30
    int32_t v54; // 0x80adf30
    int32_t v55; // 0x80adf30
    int32_t * v56; // 0x80adf30
    int32_t v57; // 0x80adf30
    int32_t v58; // 0x80adf30
    int32_t v59; // 0x80adf30
    int32_t v60; // 0x80adf30
    int32_t v61; // 0x80adf30
    int32_t v62; // 0x80adf30
    int32_t v63; // 0x80adf30
    while (true) {
      lab_0x80adfc1:
        // 0x80adfc1
        v28 = v23;
        v31 = v22;
        v26 = v20;
        nmemb = v19;
        v51 = v50;
        v54 = v53;
        v62 = v61;
        int32_t v64 = v38;
        v58 = v18;
        v57 = v17;
        int32_t v65 = v16;
        v35 = v15;
        v32 = v14;
        *(int16_t *)nmemb = (int16_t)v26;
        v33 = v32;
        v36 = v35;
        v42 = v65;
        v59 = v58;
        v45 = v28;
        v49 = v47;
        v39 = v64;
        v30 = nmemb;
        if (nmemb < 2 * v58 + v35) {
            goto lab_0x80ae11b;
        } else {
            // 0x80adfe1
            v56 = (int32_t *)v31;
            if (v65 < 0x2710) {
                // 0x80adff1
                *v56 = 1;
                uint32_t v66 = 2 * v65; // 0x80ae00e
                int32_t v67 = v66 < 0x2710 ? v66 : 0x2710; // 0x80ae015
                int32_t v68 = 2 * v67; // 0x80ae022
                int32_t * v69 = (int32_t *)(v31 + 4);
                *v69 = 14 * v67 + 11;
                int32_t * mem = calloc(nmemb, (int32_t)&g279); // 0x80ae040
                v24 = v69;
                v44 = v67;
                v41 = v68;
                if (mem == NULL) {
                    goto lab_0x80b06d2;
                } else {
                    int32_t v70 = (int32_t)mem; // 0x80ae040
                    int32_t v71 = nmemb - v35; // 0x80ae055
                    *v56 = v70;
                    int32_t v72 = v71 >> 1; // 0x80ae064
                    int32_t v73 = v72 + 1; // 0x80ae066
                    int32_t v74 = 2 * v73; // 0x80ae06b
                    int32_t * v75 = (int32_t *)(v31 + 8); // 0x80ae073
                    *v75 = v74;
                    *v69 = v35;
                    memcpy((int32_t *)v74, &g279, (int32_t)&g279);
                    *v69 = v28;
                    *v75 = 12 * v73;
                    int32_t v76 = 4 * (v68 + 11) / 12 + v70; // 0x80ae0b3
                    *v56 = v76;
                    memcpy((int32_t *)v76, &g279, (int32_t)&g279);
                    if (v35 != v5) {
                        // 0x80ae0d2
                        *v56 = v35;
                        free(&g279);
                    }
                    int32_t v77 = v67 - 1; // 0x80ae0e9
                    int32_t v78 = v71 & -2; // 0x80ae0ec
                    int32_t v79 = v78 + v70; // 0x80ae0ef
                    v34 = v73;
                    v37 = v70;
                    v43 = v67;
                    v60 = v77;
                    v46 = v76;
                    v48 = v74;
                    v40 = v68;
                    v63 = v62;
                    v55 = v54;
                    v52 = v51;
                    v25 = 0;
                    v29 = v79;
                    v27 = 1;
                    if (v79 >= 2 * v77 + v70) {
                        goto lab_0x80aece1;
                    } else {
                        // 0x80ae103
                        v33 = v76 + 4 * (v78 + v72);
                        v36 = v70;
                        v42 = v67;
                        v59 = v77;
                        v45 = v76;
                        v49 = v74;
                        v39 = v68;
                        v30 = v79;
                        goto lab_0x80ae11b;
                    }
                }
            } else {
                // 0x80adfe1
                v24 = (int32_t *)(v31 + 4);
                v44 = v65;
                v41 = v64;
                goto lab_0x80b06d2;
            }
        }
    }
  lab_0x80ae3cb:;
    // 0x80ae3cb
    int32_t result; // 0x80adf30
    return result;
  lab_0x80ae11b:;
    int32_t v80 = v30;
    int32_t v81 = v49;
    int32_t v82 = v45;
    int32_t v83 = v59;
    int32_t v84 = v42;
    int32_t v85 = v36;
    int32_t v86 = v33;
    int16_t v87 = *(int16_t *)(2 * v26 + (int32_t)&g23); // 0x80ae11b
    int32_t v88 = v87; // 0x80ae11b
    int32_t v89 = v81; // 0x80ae129
    int32_t v90; // 0x80adf30
    int32_t v91; // 0x80adf30
    int32_t v92; // 0x80adf30
    int32_t v93; // 0x80adf30
    int32_t v94; // 0x80adf30
    int32_t v95; // 0x80adf30
    int32_t v96; // 0x80adf30
    int32_t v97; // 0x80adf30
    int32_t v98; // 0x80adf30
    int32_t v99; // 0x80adf30
    int32_t v100; // 0x80adf30
    int32_t v101; // 0x80adf30
    int32_t v102; // 0x80adf30
    int32_t v103; // 0x80adf30
    int32_t v104; // 0x80adf30
    int32_t v105; // 0x80adf30
    int32_t v106; // 0x80adf30
    int32_t v107; // 0x80adf30
    if (v87 == -424) {
        goto lab_0x80ae16f;
    } else {
        int32_t v108 = v39;
        int32_t v109 = v81; // 0x80ae133
        int32_t v110 = yychar; // 0x80ae133
        if (yychar == -2) {
            // 0x80ae488
            v110 = yylex();
            yychar = v110;
            v109 = v80;
        }
        int32_t v111 = v110;
        int32_t v112 = v109;
        int32_t v113; // 0x80adf30
        int32_t v114; // 0x80adf30
        if (v111 < 1) {
            // 0x80ae420
            yychar = 0;
            v113 = 0;
            v114 = 0;
        } else {
            // 0x80ae141
            v113 = v111;
            v114 = 2;
            if (v111 < 292) {
                unsigned char v115 = *(char *)(v111 + (int32_t)&g24); // 0x80ae14d
                v113 = v111;
                v114 = v115;
            }
        }
        int32_t v116 = v114;
        uint32_t v117 = v116 + v88; // 0x80ae154
        v89 = v112;
        if (v117 < 590) {
            int32_t v118 = 2 * v117;
            int16_t v119 = *(int16_t *)(v118 + (int32_t)&g25); // 0x80ae15f
            v89 = v112;
            if (v116 == (int32_t)v119) {
                int16_t v120 = *(int16_t *)(v118 + (int32_t)&g26); // 0x80ae2c0
                int32_t v121 = v120; // 0x80ae2c0
                if (v120 >= 0 == (v120 != 0)) {
                    // 0x80ae4a3
                    v34 = v86;
                    v37 = v85;
                    v43 = v84;
                    v60 = v83;
                    v46 = v82;
                    v48 = v112;
                    v40 = v108;
                    v63 = v62;
                    v55 = v54;
                    v52 = v51;
                    v25 = 0;
                    v29 = v80;
                    v27 = 0;
                    if (v120 == 10) {
                        goto lab_0x80aece1;
                    } else {
                        int32_t v122 = v86 + 12; // 0x80ae4cd
                        yychar = v113 == 0 ? 0 : -2;
                        *(int32_t *)v122 = yylval;
                        *(int32_t *)(v86 + 16) = g251;
                        *(int32_t *)(v86 + 20) = g252;
                        v93 = v122;
                        v94 = v85;
                        v98 = v84;
                        v105 = v57 - 1 + (int32_t)(v57 == 0);
                        v106 = v83;
                        v99 = v82;
                        v101 = v112;
                        v96 = v108;
                        v107 = v62;
                        v104 = v54;
                        v103 = v51;
                        v91 = v80;
                        v90 = v121;
                        v92 = v31;
                        goto lab_0x80ae2ae;
                    }
                } else {
                    // 0x80ae2d0
                    v102 = v112;
                    v97 = v108;
                    switch (v120) {
                        case -93: {
                            goto lab_0x80ae2e0;
                        }
                        case 0: {
                            goto lab_0x80ae2e0;
                        }
                        default: {
                            // 0x80ae548
                            v100 = v112;
                            v95 = -v121;
                            goto lab_0x80ae184;
                        }
                    }
                }
            } else {
                goto lab_0x80ae16f;
            }
        } else {
            goto lab_0x80ae16f;
        }
    }
  lab_0x80ae16f:;
    unsigned char v123 = *(char *)(v26 + (int32_t)&g27); // 0x80ae16f
    v100 = v89;
    v95 = v123;
    v102 = v89;
    v97 = 0;
    if (v123 == 0) {
        goto lab_0x80ae2e0;
    } else {
        goto lab_0x80ae184;
    }
  lab_0x80ae2e0:;
    int32_t v124 = v97;
    int32_t v125 = v102;
    int32_t v126 = v125; // 0x80adf30
    switch (v57) {
        case 0: {
            // 0x80ae438
            yynerrs++;
            *(int32_t *)(v31 + 8) = yylineno;
            *(int32_t *)(v31 + 12) = (int32_t)"syntax error";
            *(int32_t *)v31 = (int32_t)"ERROR parsing file '%s'\n    line:        %i\n    description: '%s'\n";
            *(int32_t *)(v31 + 4) = yyfilename;
            Message((char *)v80);
            v126 = v80;
            goto lab_0x80ae329;
        }
        case 3: {
            int32_t v127 = yychar; // 0x80ae3f8
            if (v127 < 1) {
                // 0x80ae52b
                v126 = v125;
                v34 = v86;
                v37 = v85;
                v43 = v84;
                v60 = v83;
                v46 = v82;
                v48 = v125;
                v40 = v124;
                v63 = v62;
                v55 = v54;
                v52 = v51;
                v25 = 0;
                v29 = v80;
                v27 = 1;
                if (v127 != 0) {
                    goto lab_0x80ae329;
                } else {
                    goto lab_0x80aece1;
                }
            } else {
                // 0x80ae405
                yychar = -2;
                v126 = v125;
                goto lab_0x80ae329;
            }
        }
        default: {
            goto lab_0x80ae329;
        }
    }
  lab_0x80ae184:;
    int32_t v128 = v95;
    int32_t v129 = v100;
    unsigned char v130 = *(char *)(v128 + (int32_t)&g28); // 0x80ae195
    int32_t v131 = v130; // 0x80ae195
    int32_t v132 = 12 * (1 - v131) + v86;
    v6 = *(int32_t *)v132;
    int32_t v133 = *(int32_t *)(v132 + 4); // 0x80ae1b4
    int32_t v134 = *(int32_t *)(v132 + 8); // 0x80ae1bb
    g272 = v128 - 5;
    int32_t v135 = v86; // 0x80ae1d2
    int32_t v136 = v85; // 0x80ae1d2
    int32_t v137 = v84; // 0x80ae1d2
    int32_t v138 = v83; // 0x80ae1d2
    int32_t v139 = v82; // 0x80ae1d2
    int32_t v140 = v129; // 0x80ae1d2
    int32_t v141 = v128; // 0x80ae1d2
    int32_t v142 = v131; // 0x80ae1d2
    int32_t v143 = v133; // 0x80ae1d2
    int32_t v144 = v134; // 0x80ae1d2
    int32_t v145 = v80; // 0x80ae1d2
    int32_t v146 = v31; // 0x80ae1d2
    int32_t * v147; // 0x80adf30
    int32_t * v148; // 0x80adf30
    int32_t * v149; // 0x80adf30
    int32_t * v150; // 0x80adf30
    int32_t * v151; // 0x80adf30
    int32_t * v152; // 0x80adf30
    int32_t * v153; // 0x80adf30
    int32_t * v154; // 0x80adf30
    int32_t * v155; // 0x80adf30
    int32_t * v156; // 0x80adf30
    int32_t * v157; // 0x80adf30
    int32_t * v158; // 0x80adf30
    int32_t * v159; // 0x80adf30
    int32_t * v160; // 0x80adf30
    int32_t * v161; // 0x80adf30
    int32_t * v162; // 0x80adf30
    int32_t * v163; // 0x80adf30
    int32_t * v164; // 0x80adf30
    int32_t * v165; // 0x80adf30
    int32_t * v166; // 0x80adf30
    int32_t * v167; // 0x80adf30
    int32_t v168; // 0x80adf30
    int32_t v169; // 0x80adf30
    int32_t * v170; // 0x80adf30
    int32_t v171; // 0x80adf30
    int32_t v172; // 0x80adf30
    int32_t v173; // 0x80adf30
    int32_t v174; // 0x80adf30
    int32_t v175; // 0x80adf30
    int32_t v176; // 0x80adf30
    int32_t v177; // 0x80adf30
    int32_t v178; // 0x80adf30
    int32_t v179; // 0x80adf30
    int32_t v180; // 0x80adf30
    int32_t v181; // 0x80adf30
    int32_t v182; // 0x80adf30
    int32_t v183; // 0x80adf30
    int32_t v184; // 0x80adf30
    int32_t v185; // 0x80adf30
    int32_t v186; // 0x80adf30
    int32_t v187; // 0x80adf30
    int32_t v188; // 0x80adf30
    int32_t v189; // 0x80adf30
    int32_t v190; // 0x80adf30
    int32_t v191; // 0x80adf30
    int32_t v192; // 0x80adf30
    int32_t v193; // 0x80adf30
    int32_t v194; // 0x80adf30
    int32_t v195; // 0x80adf30
    int32_t v196; // 0x80adf30
    int32_t v197; // 0x80adf30
    int32_t v198; // 0x80adf30
    int32_t v199; // 0x80adf30
    int32_t v200; // 0x80adf30
    int32_t v201; // 0x80b0100
    int32_t * v202; // 0x80adf30
    int32_t v203; // 0x80adf30
    int32_t v204; // 0x80adf30
    int32_t v205; // 0x80adf30
    int32_t v206; // 0x80adf30
    switch (v128) {
        case 5: {
            goto lab_0x80aecd2;
        }
        case 6: {
            int32_t v207 = 0; // 0x80aec86
            if (yyPCB == NULL) {
                // 0x80b088f
                *(int32_t *)v31 = (int32_t)"illegal fileformat\n";
                // 0x80b0885
                Message((char *)&g279);
                goto lab_0x80af56c;
            } else {
                *(char *)(v207 + (int32_t)&LayerFlag) = 0;
                int32_t v208 = v207 + 1; // 0x80aec95
                v207 = v208;
                while (v208 != 18) {
                    // 0x80aec8e
                    *(char *)(v207 + (int32_t)&LayerFlag) = 0;
                    v208 = v207 + 1;
                    v207 = v208;
                }
                int32_t v209 = (int32_t)yyPCB; // 0x80aec9d
                layer_group_string = 0;
                *(int32_t *)&yyFont = (int32_t)&g268;
                int32_t v210 = *(int32_t *)(v209 + 0x220c); // 0x80aecb8
                *(int32_t *)&yyData = v210;
                *(int32_t *)(v210 + 72) = v209;
                *(int32_t *)(v210 + 24) = 0;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v129;
                v141 = 6;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            }
        }
        case 7: {
            // 0x80aeb80
            if (layer_group_string == 0) {
                // 0x80b0864
                layer_group_string = g158;
            }
            int32_t * v211 = (int32_t *)(v31 + 4); // 0x80aeba4
            *v211 = 0;
            int32_t * v212 = (int32_t *)v31; // 0x80aebac
            *v212 = (int32_t)yyPCB;
            CreateNewPCBPost((int32_t *)v80, (int32_t)&g279);
            int32_t * v213 = (int32_t *)(v31 + 8); // 0x80aebbc
            *v213 = yynerrs;
            *v211 = (int32_t)yyPCB + 0x1cd4;
            *v212 = layer_group_string;
            if (ParseGroupString((char *)&g279, &g279, (int32_t)&g279) != 0) {
                // 0x80b087e
                *v212 = (int32_t)"illegal layer-group string\n";
                // 0x80b0885
                Message((char *)&g279);
                goto lab_0x80af56c;
            } else {
                // 0x80aebe9
                *(int32_t *)&PCB = (int32_t)yyPCB;
                int32_t v214 = yynerrs; // 0x80aec02
                if (v214 >= 0xffffffff) {
                    int32_t v215 = v214; // 0x80aec08
                    int32_t v216 = (int32_t)yyData; // 0x80aec08
                    for (int32_t i = 0; i < 2 + v215; i++) {
                        int32_t v217 = 92 * i; // 0x80aec0e
                        int32_t v218 = v217 + 88;
                        int32_t v219 = v216; // 0x80aec1b
                        int32_t v220 = 0; // 0x80aec1b
                        int32_t v221 = v215; // 0x80aec1b
                        int32_t v222 = v216; // 0x80aec1b
                        if (*(int32_t *)(v218 + v216) != 0) {
                            int32_t v223 = v220 + 1; // 0x80aec2b
                            int32_t v224 = v219 + v217;
                            *v212 = v219;
                            *v213 = 60 * v220 + *(int32_t *)(v224 + 120);
                            *v211 = v224 + 76;
                            InitClip(&g279, &g279, &g279);
                            int32_t v225 = (int32_t)yyData;
                            v219 = v225;
                            v220 = v223;
                            while (*(int32_t *)(v218 + v225) > v223) {
                                // 0x80aec28
                                v223 = v220 + 1;
                                v224 = v219 + v217;
                                *v212 = v219;
                                *v213 = 60 * v220 + *(int32_t *)(v224 + 120);
                                *v211 = v224 + 76;
                                InitClip(&g279, &g279, &g279);
                                v225 = (int32_t)yyData;
                                v219 = v225;
                                v220 = v223;
                            }
                            // 0x80aec53
                            v221 = yynerrs;
                            v222 = v225;
                        }
                        // 0x80aec53
                        v216 = v222;
                        v215 = v221;
                    }
                }
                // 0x80aec6e
                *(int32_t *)&PCB = (int32_t)PCB;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v80;
                v141 = 7;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            }
        }
        case 8: {
            // 0x80aeb60
            PreLoadElementPCB();
            layer_group_string = 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 8;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 9: {
            // 0x80aeb30
            LayerFlag[0] = 1;
            *(char *)&g92 = 1;
            yynerrs = 2;
            PostLoadElementPCB();
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 9;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 10: {
            int32_t v226 = 0; // 0x80aeafb
            if (yyData == NULL || yyFont == NULL) {
                // 0x80b088f
                *(int32_t *)v31 = (int32_t)"illegal fileformat\n";
                // 0x80b0885
                Message((char *)&g279);
                goto lab_0x80af56c;
            } else {
                *(char *)(v226 + (int32_t)&LayerFlag) = 0;
                int32_t v227 = v226 + 1; // 0x80aeb17
                v226 = v227;
                while (v227 != 18) {
                    // 0x80aeb10
                    *(char *)(v226 + (int32_t)&LayerFlag) = 0;
                    v227 = v226 + 1;
                    v226 = v227;
                }
                // 0x80aeb1f
                yynerrs = 0;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v129;
                v141 = 10;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            }
        }
        case 14: {
            // 0x80aeabd
            if (yyFont == NULL) {
                // 0x80b089e
                *(int32_t *)v31 = (int32_t)"illegal fileformat\n";
                Message((char *)v80);
                goto lab_0x80af56c;
            } else {
                // 0x80aeaca
                *(char *)((int32_t)yyFont + 0x1c18) = 0;
                int32_t v228 = 0;
                int32_t v229 = v228 + 28;
                *(char *)(v229 + (int32_t)yyFont) = 0;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v129;
                v141 = 14;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                while (v228 != 0x1be4) {
                    // 0x80aeae0
                    v228 = v229;
                    v229 = v228 + 28;
                    *(char *)(v229 + (int32_t)yyFont) = 0;
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 14;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                }
                goto lab_0x80ae240;
            }
        }
        case 15: {
            // 0x80afd11
            *(char *)((int32_t)yyFont + 0x1c18) = 1;
            *(int32_t *)v31 = (int32_t)yyFont;
            SetFontInfo((int32_t *)v80);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 15;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 17: {
            int32_t v230 = *(int32_t *)(v86 - 12); // 0x80afcdc
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 17;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            if (v230 < 0x1324008) {
                goto lab_0x80ae240;
            } else {
                // 0x80afcea
                *(int32_t *)(v31 + 12) = 0x1324007;
                *(int32_t *)(v31 + 8) = v230;
                *(int32_t *)(v31 + 4) = v230;
                *(int32_t *)v31 = (int32_t)"ERROR:  The file you are attempting to load is in a format\nwhich is too new for this version of pcb.  To load this file\nyou need a version of pcb which is >= %d.  If you are\nusing a version built from cvs sources, the source date\nmust be >= %d.  This copy of pcb can only read files\nup to file version %d.\n";
                Message((char *)v80);
                goto lab_0x80af56c;
            }
        }
        case 18: {
            // 0x80afcac
            g262 = 0x989680;
            g263 = 0x989680;
            *(int32_t *)&yyElement = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 18;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 19: {
            // 0x80afc81
            *(int32_t *)&yyElement = *(int32_t *)(v86 - 36);
            g262 = 100 * *(int32_t *)(v86 - 24);
            g263 = 100 * *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 19;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 20: {
            // 0x80afc59
            *(int32_t *)&yyElement = *(int32_t *)(v86 - 36);
            g262 = *(int32_t *)(v86 - 24);
            g263 = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 20;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 25: {
            int32_t v231 = *(int32_t *)(v86 - 36); // 0x80afc2a
            *(float64_t *)&g264 = (float64_t)(float80_t)(100 * v231);
            g260 = 100 * *(int32_t *)(v86 - 24);
            g261 = 100 * *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 25;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 26: {
            int32_t v232 = *(int32_t *)(v86 - 48); // 0x80afbe4
            *(float64_t *)&g264 = (float64_t)(float80_t)(100 * v232);
            g260 = 100 * *(int32_t *)(v86 - 36);
            g261 = 100 * *(int32_t *)(v86 - 24);
            g178 = *(int32_t *)(v86 - 12) != 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 26;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 27: {
            float32_t v233 = *(float32_t *)(v86 - 48); // 0x80aee5d
            *(float64_t *)&g264 = 100.0 * (float64_t)v233;
            g260 = 100 * *(int32_t *)(v86 - 36);
            g261 = 100 * *(int32_t *)(v86 - 24);
            g178 = *(int32_t *)(v86 - 12) != 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 27;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 28: {
            float32_t v234 = *(float32_t *)(v86 - 48); // 0x80aee1e
            *(float64_t *)&g264 = (float64_t)v234;
            g260 = *(int32_t *)(v86 - 36);
            g261 = *(int32_t *)(v86 - 24);
            g178 = *(int32_t *)(v86 - 12) != 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 28;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 29: {
            // 0x80aeddd
            g253 = 100 * *(int32_t *)(v86 - 36);
            g254 = 100 * *(int32_t *)(v86 - 24);
            int32_t v235 = *(int32_t *)(v86 - 12); // 0x80aedf7
            *(float64_t *)&g265 = (float64_t)(float80_t)(2 * v235);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 29;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 30: {
            // 0x80aedb8
            g253 = *(int32_t *)(v86 - 36);
            g254 = *(int32_t *)(v86 - 24);
            int32_t v236 = *(int32_t *)(v86 - 12); // 0x80aedcf
            *(float64_t *)&g265 = (float64_t)(float80_t)v236;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 30;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 31: {
            // 0x80aed93
            g253 = *(int32_t *)(v86 - 36);
            g254 = *(int32_t *)(v86 - 24);
            float32_t v237 = *(float32_t *)(v86 - 12); // 0x80aedaa
            *(float64_t *)&g265 = (float64_t)v237;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 31;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 34: {
            float32_t v238 = *(float32_t *)(v86 - 12); // 0x80aed85
            *(float64_t *)&g266 = (float64_t)v238;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 34;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 36: {
            float32_t v239 = *(float32_t *)(v86 - 12); // 0x80aed6c
            *(float64_t *)&g267 = (float64_t)v239;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 36;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 41: {
            // 0x80aed36
            g255 = *(int32_t *)(v86 - 36);
            ghid_port = *(int32_t *)(v86 - 24);
            int32_t * v240 = (int32_t *)(v86 - 12); // 0x80aed4d
            g256 = *v240;
            g259 = *v240;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 41;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 42: {
            // 0x80aed05
            g255 = *(int32_t *)(v86 - 48);
            ghid_port = *(int32_t *)(v86 - 36);
            int32_t * v241 = (int32_t *)(v86 - 24); // 0x80aed1c
            g256 = *v241;
            g257 = *(int32_t *)(v86 - 12);
            g259 = *v241;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 42;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 43: {
            // 0x80aee8a
            g255 = *(int32_t *)(v86 - 72);
            ghid_port = *(int32_t *)(v86 - 60);
            g256 = *(int32_t *)(v86 - 48);
            g257 = *(int32_t *)(v86 - 36);
            g258 = *(int32_t *)(v86 - 24);
            g259 = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 43;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 44: {
            // 0x80af601
            *(int32_t *)v31 = v13;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 12) % 0x100000;
            MakeFlags(v80);
            v170 = yyPCB;
            goto lab_0x80af5e9;
        }
        case 45: {
            // 0x80af5ba
            *(int32_t *)(v31 + 8) = 0x80adf00;
            *(int32_t *)v31 = v13;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 12);
            string_to_pcbflags((char *)v80, (int32_t (*)(char *))&g279);
            v170 = yyPCB;
            goto lab_0x80af5e9;
        }
        case 47: {
            // 0x80af5a7
            layer_group_string = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 47;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 49: {
            // 0x80af586
            *(int32_t *)(v31 + 8) = 100;
            *(int32_t *)(v31 + 4) = (int32_t)yyPCB + 0x2194;
            goto lab_0x80af544;
        }
        case 50: {
            // 0x80af525
            *(int32_t *)(v31 + 8) = 1;
            *(int32_t *)(v31 + 4) = (int32_t)yyPCB + 0x2194;
            goto lab_0x80af544;
        }
        case 57: {
            // 0x80af511
            *(int32_t *)&attr_list = (int32_t)yyPCB + 0x2200;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 57;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 61: {
            // 0x80b06c3
            *(int32_t *)&yyElement = 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 61;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 63: {
            goto lab_0x80aecd2;
        }
        case 69: {
            // 0x80b0643
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)(v86 - 12), 3);
            int32_t * v242 = (int32_t *)(v86 - 24); // 0x80b065d
            *(int32_t *)(v31 + 28) = *v242;
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 84);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 96);
            int32_t * v243 = (int32_t *)v31; // 0x80b0699
            *v243 = (int32_t)yyData;
            CreateNewVia((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
            *v243 = *v242;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 69;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 70: {
            // 0x80b05db
            int32_t v244; // bp-64, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v244;
            int32_t * v245 = (int32_t *)(v31 + 4); // 0x80b05f0
            *v245 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v246 = v31 - 4; // 0x80b05fe
            int32_t * v247 = (int32_t *)v246;
            *v247 = v86;
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v244, 3);
            int32_t * v248 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v248;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 72);
            *v245 = 100 * *(int32_t *)(v86 - 84);
            v148 = v248;
            v151 = v247;
            v168 = v86 - 96;
            v172 = v246;
            goto lab_0x80b0547;
        }
        case 71: {
            // 0x80b055d
            int32_t v249; // bp-76, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v249;
            int32_t * v250 = (int32_t *)(v31 + 4); // 0x80b0572
            *v250 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v251 = v31 - 4; // 0x80b057b
            int32_t * v252 = (int32_t *)v251;
            *v252 = v133;
            int32_t v253 = *(int32_t *)(v86 - 60); // 0x80b057c
            int32_t v254 = *(int32_t *)(v86 - 48); // 0x80b058a
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v249, 3);
            int32_t * v255 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v255;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * (v254 + v253);
            *(int32_t *)(v31 + 12) = 100 * v254;
            *(int32_t *)(v31 + 8) = 100 * v253;
            *v250 = 100 * *(int32_t *)(v86 - 72);
            v148 = v255;
            v151 = v252;
            v168 = v86 - 84;
            v172 = v251;
            goto lab_0x80b0547;
        }
        case 72: {
            // 0x80b04e2
            int32_t v256; // bp-88, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v256;
            int32_t * v257 = (int32_t *)(v31 + 4); // 0x80b04f7
            *v257 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v258 = v31 - 4; // 0x80b0505
            int32_t * v259 = (int32_t *)v258;
            *v259 = v80;
            int32_t v260 = 100 * *(int32_t *)(v86 - 48); // 0x80b0506
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v256, 3);
            int32_t * v261 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v261;
            *(int32_t *)(v31 + 12) = 3000;
            *(int32_t *)(v31 + 8) = v260;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = v260 + 600;
            *v257 = 100 * *(int32_t *)(v86 - 60);
            v148 = v261;
            v151 = v259;
            v168 = v86 - 72;
            v172 = v258;
            goto lab_0x80b0547;
        }
        case 73: {
            int32_t * v262 = (int32_t *)(v86 - 36); // 0x80b0438
            int32_t v263 = *v262; // 0x80b0438
            int32_t v264 = 40 * v263; // 0x80b043e
            int32_t v265 = v264; // 0x80b044b
            if (-39 * v263 <= 399) {
                // 0x80b044d
                v265 = v263 < 401 == (400 - v263 & v263) < 0 ? v263 - 400 : v264;
            }
            int32_t * v266 = (int32_t *)v31; // 0x80b046d
            int32_t v267; // bp-100, 0x80adf30
            *v266 = (int32_t)&v267;
            int32_t * v268 = (int32_t *)(v31 + 4); // 0x80b0470
            *v268 = *(int32_t *)(v86 - 12);
            int32_t v269 = OldFlags(v80); // 0x80b0474
            int32_t v270 = v31 - 4; // 0x80b047e
            int32_t * v271 = (int32_t *)v270; // 0x80b047e
            *v271 = v269;
            int32_t v272 = 100 * *v262; // 0x80b047f
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v267, 3);
            int32_t * v273 = (int32_t *)(v86 - 24); // 0x80b048e
            *(int32_t *)(v31 + 20) = v265;
            *(int32_t *)(v31 + 12) = 3000;
            *(int32_t *)(v31 + 8) = v272;
            *(int32_t *)(v31 + 24) = *v273;
            *(int32_t *)(v31 + 16) = v272 + 600;
            *v268 = 100 * *(int32_t *)(v86 - 48);
            *v266 = 100 * *(int32_t *)(v86 - 60);
            *v271 = (int32_t)yyData;
            CreateNewVia(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
            *v271 = *v273;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 73;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v270;
            goto lab_0x80ae240;
        }
        case 74: {
            // 0x80b03c1
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)(v86 - 12), 3);
            *(int32_t *)(v31 + 28) = g137;
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 84);
            *(int32_t *)v31 = (int32_t)yyData;
            CreateNewRat((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 74;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 75: {
            int32_t * v274 = (int32_t *)v31; // 0x80b0354
            int32_t v275; // bp-112, 0x80adf30
            *v274 = (int32_t)&v275;
            int32_t * v276 = (int32_t *)(v31 + 4); // 0x80b0357
            *v276 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v277 = v31 - 4; // 0x80b0360
            int32_t * v278 = (int32_t *)v277; // 0x80b0360
            *v278 = v86;
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v275, 3);
            *(int32_t *)(v31 + 24) = g137;
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            *v276 = 100 * *(int32_t *)(v86 - 72);
            *v274 = 100 * *(int32_t *)(v86 - 84);
            *v278 = (int32_t)yyData;
            CreateNewRat(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 75;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v277;
            goto lab_0x80ae240;
        }
        case 76: {
            int32_t * v279 = (int32_t *)(v86 - 48); // 0x80ae1e5
            int32_t v280 = *v279; // 0x80ae1e5
            uint32_t v281 = v280 - 1; // 0x80ae1eb
            if (v281 < 18) {
                // 0x80ae1f7
                if (*(char *)(v280 + (int32_t)&g91) != 0) {
                    // 0x80b08f0
                    *(int32_t *)(v31 + 12) = (int32_t)"Layernumber used twice";
                    goto lab_0x80b08bd;
                } else {
                    int32_t v282 = 92 * v281 + 76 + (int32_t)yyData; // 0x80ae213
                    *(int32_t *)&Layer = v282;
                    *(int32_t *)v282 = *(int32_t *)(v86 - 36);
                    *(char *)(*v279 + (int32_t)&g91) = 1;
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 76;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                    if (yynerrs + 2 < *v279) {
                        // 0x80ae238
                        int32_t v283; // 0x80ae22c
                        yynerrs = v283 - 2;
                        v135 = v86;
                        v136 = v85;
                        v137 = v84;
                        v138 = v83;
                        v139 = v82;
                        v140 = v129;
                        v141 = 76;
                        v142 = v131;
                        v143 = v133;
                        v144 = v134;
                        v145 = v80;
                        v146 = v31;
                    }
                    goto lab_0x80ae240;
                }
            } else {
                // 0x80b08fa
                *(int32_t *)(v31 + 12) = (int32_t)"Layernumber out of range";
                goto lab_0x80b08bd;
            }
        }
        case 88: {
            int32_t * v284 = (int32_t *)v31; // 0x80b02cc
            int32_t v285; // bp-124, 0x80adf30
            *v284 = (int32_t)&v285;
            int32_t * v286 = (int32_t *)(v31 + 4); // 0x80b02cf
            *v286 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v287 = v31 - 4; // 0x80b02e3
            int32_t * v288 = (int32_t *)v287; // 0x80b02e3
            *v288 = v80;
            int32_t v289 = *(int32_t *)(v86 - 60); // 0x80b02e4
            int32_t v290 = *(int32_t *)(v86 - 48); // 0x80b02e7
            __asm_rep_movsd_memcpy((char *)(v31 + 16), (char *)&v285, 3);
            int32_t v291 = *(int32_t *)(v86 - 24); // 0x80b02fe
            *(int32_t *)(v31 + 12) = 100 * (v291 + v290);
            int32_t v292 = *(int32_t *)(v86 - 36); // 0x80b030e
            *(int32_t *)(v31 + 8) = 100 * (v292 + v289);
            *v286 = 100 * v290;
            *v284 = 100 * v289;
            *v288 = (int32_t)Layer;
            CreateNewPolygonFromRectangle(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 88;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v287;
            goto lab_0x80ae240;
        }
        case 92: {
            // 0x80b02a8
            *(int32_t *)&attr_list = (int32_t)&g95;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 92;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 94: {
            // 0x80b0271
            __asm_rep_movsd_memcpy((char *)(v31 + 4), (char *)(v86 - 24), 3);
            *(int32_t *)v31 = (int32_t)Layer;
            int32_t * v293 = CreateNewPolygon((int32_t *)v80, (int32_t)&g279); // 0x80b0293
            *(int32_t *)&Polygon = (int32_t)v293;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 94;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 95: {
            // 0x80b0212
            if (layer_group_string < 3) {
                int32_t * v294 = (int32_t *)v31; // 0x80b072d
                *v294 = (int32_t)"WARNING parsing file '%s'\n    line:        %i\n    description: 'ignored polygon (< 3 points)'\n";
                int32_t * v295 = (int32_t *)(v31 + 8); // 0x80b0734
                *v295 = yylineno;
                int32_t * v296 = (int32_t *)(v31 + 4); // 0x80b073d
                *v296 = yyfilename;
                Message((char *)v80);
                int32_t v297 = (int32_t)Polygon; // 0x80b0746
                *v296 = 8;
                *(int32_t *)(v31 + 16) = v297;
                *(int32_t *)(v31 + 12) = v297;
                *v295 = (int32_t)Layer;
                *v294 = (int32_t)yyData;
                DestroyObject(&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (char *)&g279);
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v80;
                v141 = 95;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            } else {
                int32_t * v298 = (int32_t *)v31;
                *v298 = (int32_t)Polygon;
                int32_t * v299 = (int32_t *)v80;
                SetPolygonBoundingBox(v299);
                v147 = v299;
                v167 = v298;
                v180 = v86;
                v182 = v85;
                v186 = v84;
                v204 = v83;
                v188 = v82;
                v189 = v80;
                v183 = 95;
                v206 = v131;
                v193 = v133;
                v191 = v134;
                v169 = (int32_t)Layer;
                if (g94 == 0) {
                    goto lab_0x80b0909;
                } else {
                    // 0x80b0221
                    v166 = (int32_t *)(v31 + 4);
                    v165 = (int32_t *)(v31 + 8);
                    v150 = v299;
                    v149 = v298;
                    v179 = v86;
                    v181 = v85;
                    v185 = v84;
                    v203 = v83;
                    v187 = v82;
                    v184 = 95;
                    v205 = v131;
                    v192 = v133;
                    v190 = v134;
                    v171 = v80;
                    goto lab_0x80b0246;
                }
            }
        }
        case 96: {
            // 0x80b01b0
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)(v86 - 12), 3);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 84);
            *(int32_t *)v31 = (int32_t)Layer;
            CreateNewLineOnLayer((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 96;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 97: {
            // 0x80b014f
            int32_t v300; // bp-136, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v300;
            int32_t * v301 = (int32_t *)(v31 + 4); // 0x80b0167
            *v301 = *(int32_t *)(v86 - 12);
            int32_t v302 = OldFlags(v80); // 0x80b016b
            int32_t v303 = v31 - 4; // 0x80b0175
            int32_t * v304 = (int32_t *)v303;
            *v304 = v302;
            __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v300, 3);
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 60);
            *v301 = 100 * *(int32_t *)(v86 - 72);
            v202 = v304;
            v201 = v303;
            v194 = v86 - 84;
            goto lab_0x80b0133;
        }
        case 98: {
            int32_t v305 = *(int32_t *)(v86 - 12); // 0x80b00d8
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 98;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            if ((v305 & 16) != 0) {
                goto lab_0x80ae240;
            } else {
                int32_t * v306 = (int32_t *)(v31 + 4); // 0x80b00e9
                *v306 = v305;
                int32_t v307; // bp-148, 0x80adf30
                *(int32_t *)v31 = (int32_t)&v307;
                OldFlags(v80);
                v201 = v31 - 4;
                v202 = (int32_t *)v201;
                *v202 = v131;
                __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v307, 3);
                *(int32_t *)(v31 + 20) = 3000;
                *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 24);
                *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
                *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
                *v306 = 100 * *(int32_t *)(v86 - 60);
                v194 = v86 - 72;
                goto lab_0x80b0133;
            }
        }
        case 99: {
            // 0x80b0062
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)(v86 - 12), 3);
            *(int32_t *)(v31 + 32) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 84);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 96);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 108);
            *(int32_t *)v31 = (int32_t)Layer;
            CreateNewArcOnLayer((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 99;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 100: {
            // 0x80afff0
            int32_t v308; // bp-160, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v308;
            int32_t * v309 = (int32_t *)(v31 + 4); // 0x80b0008
            *v309 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v310 = v31 - 4; // 0x80b0011
            int32_t * v311 = (int32_t *)v310;
            *v311 = v133;
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v308, 3);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 24) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 84);
            *v309 = 100 * *(int32_t *)(v86 - 96);
            v154 = v311;
            v178 = v310;
            v199 = v86 - 108;
            goto lab_0x80affd4;
        }
        case 101: {
            // 0x80aff65
            int32_t v312; // bp-172, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v312;
            int32_t * v313 = (int32_t *)(v31 + 4); // 0x80aff7d
            *v313 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v314 = v31 - 4; // 0x80aff91
            int32_t * v315 = (int32_t *)v314;
            *v315 = v80;
            int32_t v316 = 100 * *(int32_t *)(v86 - 72); // 0x80aff92
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v312, 3);
            *(int32_t *)(v31 + 28) = 3000;
            *(int32_t *)(v31 + 24) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = v316;
            *(int32_t *)(v31 + 8) = v316;
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
            *v313 = 100 * *(int32_t *)(v86 - 84);
            v154 = v315;
            v178 = v314;
            v199 = v86 - 96;
            goto lab_0x80affd4;
        }
        case 102: {
            int32_t * v317 = (int32_t *)v31; // 0x80afefa
            int32_t v318; // bp-184, 0x80adf30
            *v317 = (int32_t)&v318;
            int32_t * v319 = (int32_t *)(v31 + 4); // 0x80afefd
            *v319 = *(int32_t *)(v86 - 12);
            int32_t v320 = OldFlags(v80); // 0x80aff01
            int32_t v321 = v31 - 4; // 0x80aff0b
            int32_t * v322 = (int32_t *)v321; // 0x80aff0b
            *v322 = v320;
            __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v318, 3);
            int32_t * v323 = (int32_t *)(v86 - 24); // 0x80aff12
            *(int32_t *)(v31 + 16) = 100;
            *(int32_t *)(v31 + 20) = *v323;
            unsigned char v324 = *(char *)(v86 - 36); // 0x80aff21
            *(int32_t *)(v31 + 12) = (int32_t)v324;
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            *v319 = 100 * *(int32_t *)(v86 - 60);
            *v317 = (int32_t)yyFont;
            *v322 = (int32_t)Layer;
            CreateNewText(&g279, &g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
            *v322 = *v323;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 102;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v321;
            goto lab_0x80ae240;
        }
        case 103: {
            uint32_t v325 = *(int32_t *)(v86 - 12); // 0x80afe3d
            if ((v325 & 1024) == 0) {
                int32_t * v326 = (int32_t *)(v31 + 4); // 0x80b07ed
                *v326 = v325;
                int32_t * v327 = (int32_t *)v31; // 0x80b07f1
                int32_t v328; // bp-208, 0x80adf30
                *v327 = (int32_t)&v328;
                OldFlags(v80);
                int32_t v329 = v31 - 4; // 0x80b07fe
                int32_t * v330 = (int32_t *)v329;
                *v330 = v86;
                __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v328, 3);
                int32_t * v331 = (int32_t *)(v86 - 24);
                *(int32_t *)(v31 + 20) = *v331;
                *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
                unsigned char v332 = *(char *)(v86 - 48); // 0x80b0822
                *(int32_t *)(v31 + 12) = (int32_t)v332;
                *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 60);
                *v326 = 100 * *(int32_t *)(v86 - 72);
                *v327 = (int32_t)yyFont;
                *v330 = (int32_t)Layer;
                CreateNewText(&g279, &g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
                v156 = v330;
                v155 = v331;
                v177 = v329;
            } else {
                int32_t * v333 = (int32_t *)(v31 + 4); // 0x80afe6c
                *v333 = v325;
                int32_t * v334 = (int32_t *)v31; // 0x80afe70
                int32_t v335; // bp-196, 0x80adf30
                *v334 = (int32_t)&v335;
                OldFlags(v80);
                int32_t v336 = v31 - 4; // 0x80afe90
                int32_t * v337 = (int32_t *)v336;
                *v337 = v131;
                __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v335, 3);
                int32_t * v338 = (int32_t *)(v86 - 24);
                *(int32_t *)(v31 + 20) = *v338;
                *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
                unsigned char v339 = *(char *)(v86 - 48); // 0x80afeab
                *(int32_t *)(v31 + 12) = (int32_t)v339;
                *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 60);
                *v333 = 100 * *(int32_t *)(v86 - 72);
                *v334 = (int32_t)yyFont;
                *v337 = (int32_t)yyData + 76 + 92 * (yynerrs + (v325 / 128 % 2 ^ 1));
                CreateNewText(&g279, &g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
                v156 = v337;
                v155 = v338;
                v177 = v336;
            }
            goto lab_0x80afe1c;
        }
        case 104: {
            int32_t v340 = v86 - 12; // 0x80afd8d
            uint32_t v341 = *(int32_t *)v340; // 0x80afd8d
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)v340, 3);
            int32_t v342 = v86 - 24;
            if ((v341 & 1024) == 0) {
                int32_t * v343 = (int32_t *)v342;
                *(int32_t *)(v31 + 24) = *v343;
                *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
                unsigned char v344 = *(char *)(v86 - 48); // 0x80b07a4
                *(int32_t *)(v31 + 16) = (int32_t)v344;
                *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
                *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
                *(int32_t *)(v31 + 4) = (int32_t)yyFont;
                int32_t * v345 = (int32_t *)v31;
                *v345 = (int32_t)Layer;
                CreateNewText((int32_t *)v80, &g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
                v156 = v345;
                v155 = v343;
                v177 = v31;
            } else {
                int32_t * v346 = (int32_t *)v342;
                *(int32_t *)(v31 + 24) = *v346;
                *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
                unsigned char v347 = *(char *)(v86 - 48); // 0x80afdd0
                *(int32_t *)(v31 + 16) = (int32_t)v347;
                *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
                *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
                *(int32_t *)(v31 + 4) = (int32_t)yyFont;
                int32_t * v348 = (int32_t *)v31;
                *v348 = (int32_t)yyData + 76 + 92 * (yynerrs + (v341 / 128 % 2 ^ 1));
                CreateNewText((int32_t *)v80, &g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
                v156 = v348;
                v155 = v346;
                v177 = v31;
            }
            goto lab_0x80afe1c;
        }
        case 107: {
            // 0x80afd6d
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 12);
            v198 = 100 * *(int32_t *)(v86 - 24);
            goto lab_0x80afd4b;
        }
        case 108: {
            // 0x80afd3b
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 12);
            v198 = *(int32_t *)(v86 - 24);
            goto lab_0x80afd4b;
        }
        case 115: {
            int32_t * v349 = (int32_t *)v31; // 0x80ae882
            int32_t v350; // bp-220, 0x80adf30
            *v349 = (int32_t)&v350;
            int32_t v351 = v31 + 4; // 0x80ae885
            *(int32_t *)v351 = 0;
            MakeFlags(v80);
            int32_t * v352 = (int32_t *)(v31 - 4); // 0x80ae898
            *v352 = v133;
            int32_t v353 = (int32_t)*(char *)(v86 - 24); // 0x80ae899
            int32_t * v354 = (int32_t *)(v86 - 60); // 0x80ae8b7
            int32_t * v355 = (int32_t *)(v86 - 72); // 0x80ae8c6
            int32_t v356; // bp-232, 0x80adf30
            *v352 = (int32_t)&v356;
            *v349 = 0;
            MakeFlags(v353);
            int32_t v357 = v31 - 8; // 0x80ae8ea
            int32_t * v358 = (int32_t *)v357; // 0x80ae8ea
            *v358 = v80;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v350, 3);
            *(int32_t *)(v31 + 40) = 100;
            *(int32_t *)(v31 + 24) = 0;
            *(int32_t *)(v31 + 36) = v353;
            *(int32_t *)(v31 + 32) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = *v355;
            *(int32_t *)(v31 + 20) = *v354;
            __asm_rep_movsd_memcpy((char *)v351, (char *)&v356, 3);
            *v349 = (int32_t)yyFont;
            *v352 = (int32_t)yyElement;
            *v358 = (int32_t)yyData;
            int32_t * v359 = CreateNewElement(&g279, &g279, &g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279); // 0x80ae962
            *(int32_t *)&yyElement = (int32_t)v359;
            *v358 = *v355;
            SaveFree((char *)&g279);
            *v358 = *v354;
            SaveFree((char *)&g279);
            pin_num = 1;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 115;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v357;
            goto lab_0x80ae240;
        }
        case 116: {
            goto lab_0x80ae4fb;
        }
        case 117: {
            int32_t * v360 = (int32_t *)v31; // 0x80ae754
            int32_t v361; // bp-244, 0x80adf30
            *v360 = (int32_t)&v361;
            int32_t v362 = v31 + 4; // 0x80ae757
            *(int32_t *)v362 = *(int32_t *)(v86 - 24);
            int32_t v363 = OldFlags(v80); // 0x80ae75b
            int32_t * v364 = (int32_t *)(v31 - 4); // 0x80ae760
            *v364 = v363;
            unsigned char v365 = *(char *)(v86 - 48); // 0x80ae761
            int32_t v366 = *(int32_t *)(v86 - 36); // 0x80ae765
            int32_t * v367 = (int32_t *)(v86 - 84);
            int32_t * v368 = (int32_t *)(v86 - 96); // 0x80ae79d
            int32_t v369; // bp-256, 0x80adf30
            *v364 = (int32_t)&v369;
            *v360 = *(int32_t *)(v86 - 108);
            OldFlags(v366);
            int32_t v370 = v31 - 8; // 0x80ae7c6
            int32_t * v371 = (int32_t *)v370;
            *v371 = v86;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v361, 3);
            *(int32_t *)(v31 + 24) = 0;
            *(int32_t *)(v31 + 40) = v366;
            *(int32_t *)(v31 + 32) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 20) = *v367;
            *(int32_t *)(v31 + 36) = (int32_t)v365;
            *(int32_t *)(v31 + 16) = *v368;
            __asm_rep_movsd_memcpy((char *)v362, (char *)&v369, 3);
            *v360 = (int32_t)yyFont;
            *v364 = (int32_t)yyElement;
            *v371 = (int32_t)yyData;
            int32_t * v372 = CreateNewElement(&g279, &g279, &g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279); // 0x80ae840
            *(int32_t *)&yyElement = (int32_t)v372;
            *v371 = *v368;
            SaveFree((char *)&g279);
            v158 = v371;
            v157 = v367;
            v173 = v370;
            goto lab_0x80ae6d7;
        }
        case 118: {
            goto lab_0x80ae4fb;
        }
        case 119: {
            int32_t * v373 = (int32_t *)v31; // 0x80ae5b4
            int32_t v374; // bp-268, 0x80adf30
            *v373 = (int32_t)&v374;
            int32_t v375 = v31 + 4; // 0x80ae5b7
            *(int32_t *)v375 = *(int32_t *)(v86 - 24);
            OldFlags(v80);
            int32_t * v376 = (int32_t *)(v31 - 4); // 0x80ae5c0
            *v376 = v86;
            unsigned char v377 = *(char *)(v86 - 48); // 0x80ae5c1
            int32_t v378 = *(int32_t *)(v86 - 36); // 0x80ae5c5
            int32_t * v379 = (int32_t *)(v86 - 84);
            int32_t * v380 = (int32_t *)(v86 - 96); // 0x80ae5fd
            int32_t * v381 = (int32_t *)(v86 - 108); // 0x80ae606
            int32_t v382 = *(int32_t *)(v86 - 120); // 0x80ae61b
            int32_t v383; // bp-280, 0x80adf30
            *v376 = (int32_t)&v383;
            *v373 = v382;
            OldFlags(v378);
            int32_t v384 = v31 - 8; // 0x80ae630
            int32_t * v385 = (int32_t *)v384;
            *v385 = v382;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v374, 3);
            *(int32_t *)(v31 + 40) = v378;
            *(int32_t *)(v31 + 32) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 24) = *v379;
            *(int32_t *)(v31 + 36) = (int32_t)v377;
            *(int32_t *)(v31 + 16) = *v381;
            *(int32_t *)(v31 + 20) = *v380;
            __asm_rep_movsd_memcpy((char *)v375, (char *)&v383, 3);
            *v373 = (int32_t)yyFont;
            *v376 = (int32_t)yyElement;
            *v385 = (int32_t)yyData;
            int32_t * v386 = CreateNewElement(&g279, &g279, &g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279); // 0x80ae6b1
            *(int32_t *)&yyElement = (int32_t)v386;
            *v385 = *v381;
            SaveFree((char *)&g279);
            *v385 = *v380;
            SaveFree((char *)&g279);
            v158 = v385;
            v157 = v379;
            v173 = v384;
            goto lab_0x80ae6d7;
        }
        case 120: {
            goto lab_0x80ae4fb;
        }
        case 121: {
            int32_t * v387 = (int32_t *)v31; // 0x80af28b
            int32_t v388; // bp-292, 0x80adf30
            *v387 = (int32_t)&v388;
            int32_t v389 = v31 + 4; // 0x80af28e
            *(int32_t *)v389 = *(int32_t *)(v86 - 24);
            OldFlags(v80);
            int32_t * v390 = (int32_t *)(v31 - 4); // 0x80af297
            *v390 = v80;
            unsigned char v391 = *(char *)(v86 - 48); // 0x80af2a1
            int32_t v392 = *(int32_t *)(v86 - 60); // 0x80af2ab
            int32_t * v393 = (int32_t *)(v86 - 84); // 0x80af2ae
            int32_t * v394 = (int32_t *)(v86 - 108); // 0x80af2c0
            int32_t * v395 = (int32_t *)(v86 - 96); // 0x80af2c6
            int32_t * v396 = (int32_t *)(v86 - 120); // 0x80af2cf
            int32_t v397 = 100 * (*v395 + *(int32_t *)(v86 - 72)); // 0x80af2d8
            int32_t * v398 = (int32_t *)(v86 - 132); // 0x80af2e7
            int32_t v399; // bp-304, 0x80adf30
            *v390 = (int32_t)&v399;
            *v387 = *(int32_t *)(v86 - 144);
            int32_t v400 = OldFlags(v397); // 0x80af306
            int32_t v401 = v31 - 8; // 0x80af310
            int32_t * v402 = (int32_t *)v401; // 0x80af310
            *v402 = v400;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v388, 3);
            *(int32_t *)(v31 + 40) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 36) = (int32_t)v391;
            *(int32_t *)(v31 + 28) = v397;
            *(int32_t *)(v31 + 32) = 100 * (*v393 + v392);
            *(int32_t *)(v31 + 20) = *v396;
            *(int32_t *)(v31 + 16) = *v398;
            *(int32_t *)(v31 + 24) = *v394;
            __asm_rep_movsd_memcpy((char *)v389, (char *)&v399, 3);
            *v387 = (int32_t)yyFont;
            *v390 = (int32_t)yyElement;
            *v402 = (int32_t)yyData;
            int32_t * v403 = CreateNewElement(&g279, &g279, &g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279); // 0x80af38c
            int32_t v404 = (int32_t)v403; // 0x80af38c
            *(int32_t *)&yyElement = v404;
            *(int32_t *)(v404 + 216) = 100 * *v395;
            *(int32_t *)(v404 + 220) = 100 * *v393;
            *v402 = *v398;
            SaveFree((char *)&g279);
            *v402 = *v396;
            SaveFree((char *)&g279);
            *v402 = *v394;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 121;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v401;
            goto lab_0x80ae240;
        }
        case 122: {
            goto lab_0x80ae4fb;
        }
        case 123: {
            // 0x80af3e1
            *(int32_t *)(v31 + 64) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 52), (char *)(v86 - 24), 3);
            *(int32_t *)(v31 + 48) = *(int32_t *)(v86 - 36);
            unsigned char v405 = *(char *)(v86 - 48); // 0x80af416
            *(int32_t *)(v31 + 44) = (int32_t)v405;
            int32_t * v406 = (int32_t *)(v86 - 84); // 0x80af421
            int32_t v407 = *v406; // 0x80af421
            *(int32_t *)(v31 + 40) = v407 + *(int32_t *)(v86 - 60);
            int32_t * v408 = (int32_t *)(v86 - 96); // 0x80af42b
            int32_t v409 = *v408; // 0x80af42b
            *(int32_t *)(v31 + 36) = v409 + *(int32_t *)(v86 - 72);
            int32_t * v410 = (int32_t *)(v86 - 108); // 0x80af432
            *(int32_t *)(v31 + 32) = *v410;
            int32_t * v411 = (int32_t *)(v86 - 120); // 0x80af439
            *(int32_t *)(v31 + 28) = *v411;
            int32_t * v412 = (int32_t *)(v86 - 132); // 0x80af440
            *(int32_t *)(v31 + 24) = *v412;
            __asm_rep_movsd_memcpy((char *)(v31 + 12), (char *)(v86 - 144), 3);
            *(int32_t *)(v31 + 8) = (int32_t)yyFont;
            *(int32_t *)(v31 + 4) = (int32_t)yyElement;
            int32_t * v413 = (int32_t *)v31; // 0x80af46e
            *v413 = (int32_t)yyData;
            int32_t * v414 = CreateNewElement((int32_t *)v80, &g279, &g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279, (int32_t)&g279, (int32_t)&g279, (char)&g279); // 0x80af471
            int32_t v415 = (int32_t)v414; // 0x80af471
            *(int32_t *)&yyElement = v415;
            *(int32_t *)(v415 + 216) = *v408;
            *(int32_t *)(v415 + 220) = *v406;
            *v413 = *v412;
            SaveFree((char *)&g279);
            *v413 = *v411;
            SaveFree((char *)&g279);
            *v413 = *v410;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 123;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 124: {
            goto lab_0x80ae4fb;
        }
        case 132: {
            // 0x80afbb1
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 48);
            v197 = *(int32_t *)(v86 - 60);
            goto lab_0x80afb8f;
        }
        case 133: {
            // 0x80afb65
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            v197 = 100 * *(int32_t *)(v86 - 60);
            goto lab_0x80afb8f;
        }
        case 134: {
            // 0x80af1e9
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
            v196 = *(int32_t *)(v86 - 84);
            goto lab_0x80af1c7;
        }
        case 135: {
            // 0x80af18f
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 72);
            v196 = 100 * *(int32_t *)(v86 - 84);
            goto lab_0x80af1c7;
        }
        case 136: {
            // 0x80af16d
            g269 = *(int32_t *)(v86 - 24);
            g270 = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 136;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 137: {
            // 0x80af148
            g269 = 100 * *(int32_t *)(v86 - 24);
            g270 = 100 * *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 137;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 138: {
            goto lab_0x80ae555;
        }
        case 146: {
            // 0x80aeec4
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 24) + g270;
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 36) + g269;
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 48) + g270;
            *(int32_t *)v31 = (int32_t)yyElement;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 60) + g269;
            CreateNewLineInElement((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 146;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 147: {
            // 0x80af0e7
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 12);
            int32_t v416 = *(int32_t *)(v86 - 24); // 0x80af107
            *(int32_t *)(v31 + 16) = 100 * v416 + g270;
            int32_t v417 = *(int32_t *)(v86 - 36); // 0x80af111
            *(int32_t *)(v31 + 12) = 100 * v417 + g269;
            int32_t v418 = *(int32_t *)(v86 - 48); // 0x80af11b
            *(int32_t *)(v31 + 8) = 100 * v418 + g270;
            int32_t v419 = *(int32_t *)(v86 - 60); // 0x80af125
            *(int32_t *)v31 = (int32_t)yyElement;
            *(int32_t *)(v31 + 4) = 100 * v419 + g269;
            CreateNewLineInElement((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 147;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 148: {
            // 0x80af085
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
            int32_t v420 = *(int32_t *)(v86 - 72); // 0x80af0ba
            *(int32_t *)(v31 + 8) = v420 + g270;
            v195 = *(int32_t *)(v86 - 84) + g269;
            goto lab_0x80af0ca;
        }
        case 149: {
            // 0x80af4c2
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            int32_t v421 = *(int32_t *)(v86 - 72); // 0x80af4f4
            *(int32_t *)(v31 + 8) = 100 * v421 + g270;
            v195 = 100 * *(int32_t *)(v86 - 84) + g269;
            goto lab_0x80af0ca;
        }
        case 150: {
            goto lab_0x80ae555;
        }
        case 152: {
            // 0x80aeff2
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)(v86 - 12), 3);
            int32_t * v422 = (int32_t *)(v86 - 24); // 0x80af012
            *(int32_t *)(v31 + 32) = *v422;
            int32_t * v423 = (int32_t *)(v86 - 36); // 0x80af019
            *(int32_t *)(v31 + 28) = *v423;
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 84);
            int32_t v424 = *(int32_t *)(v86 - 96); // 0x80af042
            *(int32_t *)(v31 + 8) = v424 + g270;
            int32_t v425 = *(int32_t *)(v86 - 108); // 0x80af04f
            int32_t * v426 = (int32_t *)v31; // 0x80af058
            *v426 = (int32_t)yyElement;
            *(int32_t *)(v31 + 4) = v425 + g269;
            CreateNewPin((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            *v426 = *v423;
            SaveFree((char *)&g279);
            *v426 = *v422;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 152;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 153: {
            int32_t * v427 = (int32_t *)v31; // 0x80aef55
            int32_t v428; // bp-316, 0x80adf30
            *v427 = (int32_t)&v428;
            int32_t * v429 = (int32_t *)(v31 + 4); // 0x80aef5e
            *v429 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v430 = v31 - 4; // 0x80aef72
            int32_t * v431 = (int32_t *)v430;
            *v431 = v131;
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v428, 3);
            int32_t * v432 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 28) = *v432;
            int32_t * v433 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 24) = *v433;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 84);
            *v429 = 100 * *(int32_t *)(v86 - 96) + g270;
            *v431 = (int32_t)yyElement;
            *v427 = 100 * *(int32_t *)(v86 - 108) + g269;
            CreateNewPin(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            v161 = v432;
            v160 = v431;
            v159 = v433;
            v174 = v430;
            goto lab_0x80aefd1;
        }
        case 154: {
            int32_t * v434 = (int32_t *)v31; // 0x80afae9
            int32_t v435; // bp-328, 0x80adf30
            *v434 = (int32_t)&v435;
            int32_t * v436 = (int32_t *)(v31 + 4); // 0x80afaf2
            *v436 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v437 = v31 - 4; // 0x80afb00
            int32_t * v438 = (int32_t *)v437;
            *v438 = v86;
            int32_t v439 = 100 * *(int32_t *)(v86 - 60); // 0x80afb01
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v435, 3);
            int32_t * v440 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 28) = *v440;
            int32_t * v441 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 24) = *v441;
            *(int32_t *)(v31 + 8) = v439;
            *(int32_t *)(v31 + 12) = 3000;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = v439 + 600;
            *v436 = 100 * *(int32_t *)(v86 - 72);
            *v434 = 100 * *(int32_t *)(v86 - 84);
            *v438 = (int32_t)yyElement;
            CreateNewPin(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            v164 = v440;
            v163 = v438;
            v162 = v441;
            v175 = v437;
            goto lab_0x80af255;
        }
        case 155: {
            int32_t v442 = pin_num; // 0x80afa09
            int32_t * v443 = (int32_t *)v31; // 0x80afa12
            *v443 = v9;
            int32_t * v444 = (int32_t *)(v31 + 12); // 0x80afa1b
            *v444 = (int32_t)"%d";
            int32_t * v445 = (int32_t *)(v31 + 8); // 0x80afa23
            *v445 = 8;
            int32_t * v446 = (int32_t *)(v31 + 16); // 0x80afa2e
            *v446 = v442;
            int32_t * v447 = (int32_t *)(v31 + 4); // 0x80afa32
            *v447 = 1;
            pin_num = v442 + 1;
            __sprintf_chk((char *)v80, (int32_t)&g279, (int32_t)&g279, (char *)&g279);
            int32_t v448; // bp-340, 0x80adf30
            *v443 = (int32_t)&v448;
            *v447 = *(int32_t *)(v86 - 12);
            OldFlags((int32_t)&g279);
            int32_t v449 = v31 - 4; // 0x80afa62
            int32_t * v450 = (int32_t *)v449;
            *v450 = v442;
            int32_t v451 = 100 * *(int32_t *)(v86 - 48); // 0x80afa68
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v448, 3);
            *(int32_t *)(v31 + 28) = v9;
            int32_t * v452 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v452;
            *v444 = 3000;
            *v445 = v451;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *v446 = v451 + 600;
            *v447 = 100 * *(int32_t *)(v86 - 60);
            *v443 = 100 * *(int32_t *)(v86 - 72);
            *v450 = (int32_t)yyElement;
            CreateNewPin(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            v153 = v450;
            v152 = v452;
            v176 = v449;
            goto lab_0x80afabe;
        }
        case 156: {
            int32_t * v453 = (int32_t *)(v86 - 36); // 0x80af920
            int32_t v454 = *v453; // 0x80af920
            int32_t v455 = 40 * v454; // 0x80af926
            int32_t v456 = v455; // 0x80af933
            if (-39 * v454 <= 399) {
                // 0x80af935
                v456 = v454 < 401 == (400 - v454 & v454) < 0 ? v454 - 400 : v455;
            }
            int32_t v457 = pin_num; // 0x80af943
            int32_t * v458 = (int32_t *)(v31 + 12); // 0x80af955
            *v458 = (int32_t)"%d";
            int32_t * v459 = (int32_t *)(v31 + 8); // 0x80af95d
            *v459 = 8;
            pin_num = v457 + 1;
            int32_t * v460 = (int32_t *)(v31 + 16); // 0x80af970
            *v460 = v457;
            int32_t * v461 = (int32_t *)(v31 + 4); // 0x80af974
            *v461 = 1;
            int32_t * v462 = (int32_t *)v31; // 0x80af97c
            *v462 = v9;
            __sprintf_chk((char *)v80, (int32_t)&g279, (int32_t)&g279, (char *)&g279);
            int32_t v463; // bp-352, 0x80adf30
            *v462 = (int32_t)&v463;
            *v461 = *(int32_t *)(v86 - 12);
            OldFlags((int32_t)&g279);
            int32_t v464 = v31 - 4; // 0x80af99e
            int32_t * v465 = (int32_t *)v464; // 0x80af99e
            *v465 = v80;
            int32_t v466 = 100 * *v453; // 0x80af99f
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v463, 3);
            *(int32_t *)(v31 + 28) = v9;
            int32_t * v467 = (int32_t *)(v86 - 24); // 0x80af9b5
            *(int32_t *)(v31 + 20) = v456;
            *v458 = 3000;
            *v459 = v466;
            *(int32_t *)(v31 + 24) = *v467;
            *v460 = v466 + 600;
            *v461 = 100 * *(int32_t *)(v86 - 48);
            *v462 = 100 * *(int32_t *)(v86 - 60);
            *v465 = (int32_t)yyElement;
            CreateNewPin(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            *v465 = *v467;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 156;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v464;
            goto lab_0x80ae240;
        }
        case 157: {
            // 0x80af88c
            __asm_rep_movsd_memcpy((char *)(v31 + 40), (char *)(v86 - 12), 3);
            int32_t * v468 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 36) = *v468;
            int32_t * v469 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 32) = *v469;
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 84) + g270;
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 96) + g269;
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 108) + g270;
            int32_t * v470 = (int32_t *)v31;
            *v470 = (int32_t)yyElement;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 120) + g269;
            CreateNewPad((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            v161 = v468;
            v160 = v470;
            v159 = v469;
            v174 = v31;
            goto lab_0x80aefd1;
        }
        case 158: {
            int32_t * v471 = (int32_t *)v31; // 0x80af7d3
            int32_t v472; // bp-364, 0x80adf30
            *v471 = (int32_t)&v472;
            int32_t * v473 = (int32_t *)(v31 + 4); // 0x80af7dc
            *v473 = *(int32_t *)(v86 - 12);
            int32_t v474 = OldFlags(v80); // 0x80af7e0
            int32_t v475 = v31 - 4; // 0x80af7f0
            int32_t * v476 = (int32_t *)v475;
            *v476 = v474;
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)&v472, 3);
            int32_t * v477 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 32) = *v477;
            int32_t * v478 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 28) = *v478;
            *(int32_t *)(v31 + 24) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 72);
            int32_t v479 = *(int32_t *)(v86 - 84); // 0x80af841
            *(int32_t *)(v31 + 12) = 100 * v479 + g270;
            int32_t v480 = *(int32_t *)(v86 - 96); // 0x80af84f
            *(int32_t *)(v31 + 8) = 100 * v480 + g269;
            *v473 = 100 * *(int32_t *)(v86 - 108) + g270;
            *v476 = (int32_t)yyElement;
            *v471 = 100 * *(int32_t *)(v86 - 120) + g269;
            CreateNewPad(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            v164 = v477;
            v163 = v476;
            v162 = v478;
            v175 = v475;
            goto lab_0x80af255;
        }
        case 159: {
            int32_t * v481 = (int32_t *)v31; // 0x80af740
            *v481 = v11;
            int32_t * v482 = (int32_t *)(v31 + 4); // 0x80af749
            *v482 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v483 = v31 - 4; // 0x80af757
            int32_t * v484 = (int32_t *)v483;
            *v484 = v11;
            int32_t v485 = 100 * *(int32_t *)(v86 - 48); // 0x80af758
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)&v10, 3);
            int32_t * v486 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 32) = *v486;
            int32_t * v487 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 20) = 3000;
            *(int32_t *)(v31 + 16) = v485;
            *(int32_t *)(v31 + 28) = *v487;
            *(int32_t *)(v31 + 24) = v485 + 600;
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 72);
            *v482 = 100 * *(int32_t *)(v86 - 84);
            *v481 = 100 * *(int32_t *)(v86 - 96);
            *v484 = (int32_t)yyElement;
            CreateNewPad(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            v164 = v486;
            v163 = v484;
            v162 = v487;
            v175 = v483;
            goto lab_0x80af255;
        }
        case 160: {
            int32_t * v488 = (int32_t *)v31; // 0x80af667
            *v488 = v9;
            int32_t * v489 = (int32_t *)(v31 + 12); // 0x80af66a
            *v489 = (int32_t)"%d";
            int32_t * v490 = (int32_t *)(v31 + 16); // 0x80af675
            *v490 = pin_num;
            int32_t * v491 = (int32_t *)(v31 + 8); // 0x80af679
            *v491 = 8;
            int32_t * v492 = (int32_t *)(v31 + 4); // 0x80af681
            *v492 = 1;
            pin_num++;
            __sprintf_chk((char *)v80, (int32_t)&g279, (int32_t)&g279, (char *)&g279);
            *v492 = *(int32_t *)(v86 - 12);
            int32_t v493; // bp-388, 0x80adf30
            *v488 = (int32_t)&v493;
            OldFlags((int32_t)&g279);
            int32_t v494 = v31 - 4; // 0x80af6b9
            int32_t * v495 = (int32_t *)v494; // 0x80af6b9
            *v495 = v86;
            int32_t v496 = 100 * *(int32_t *)(v86 - 36); // 0x80af6ba
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)&v493, 3);
            *(int32_t *)(v31 + 32) = v9;
            int32_t * v497 = (int32_t *)(v86 - 24); // 0x80af6d1
            *(int32_t *)(v31 + 20) = 3000;
            *v490 = v496;
            *(int32_t *)(v31 + 28) = *v497;
            *(int32_t *)(v31 + 24) = v496 + 600;
            *v489 = 100 * *(int32_t *)(v86 - 48);
            *v491 = 100 * *(int32_t *)(v86 - 60);
            *v492 = 100 * *(int32_t *)(v86 - 72);
            *v488 = 100 * *(int32_t *)(v86 - 84);
            *v495 = (int32_t)yyElement;
            CreateNewPad(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (char *)&g279, (int32_t)&g279);
            *v495 = *v497;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 160;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v494;
            goto lab_0x80ae240;
        }
        case 161: {
            // 0x80af62f
            *(int32_t *)v31 = v7;
            *(int32_t *)(v31 + 4) = *(int32_t *)v86;
            OldFlags(v80);
            int32_t v498 = v31 - 4; // 0x80af652
            *(int32_t *)v498 = v133;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 161;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v498;
            goto lab_0x80ae240;
        }
        case 162: {
            // 0x80aea8c
            *(int32_t *)(v31 + 8) = 0x80adf00;
            *(int32_t *)v31 = v7;
            *(int32_t *)(v31 + 4) = *(int32_t *)v86;
            string_to_flags((char *)v80, (int32_t (*)(char *))&g279);
            int32_t v499 = v31 - 4; // 0x80aeab1
            *(int32_t *)v499 = v80;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 162;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v499;
            goto lab_0x80ae240;
        }
        case 165: {
            int32_t v500 = *(int32_t *)(v86 - 36); // 0x80aea41
            if (v500 < 256) {
                int32_t v501 = 28 * v500 + (int32_t)yyFont;
                *(int32_t *)&Symbol = v501 + 24;
                char * v502 = (char *)(v501 + 28); // 0x80aea68
                if (*v502 != 0) {
                    // 0x80b08b5
                    *(int32_t *)(v31 + 12) = (int32_t)"symbol ID used twice";
                    goto lab_0x80b08bd;
                } else {
                    // 0x80aea72
                    *v502 = 1;
                    g93 = *(int32_t *)(v86 - 24);
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 165;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                    goto lab_0x80ae240;
                }
            } else {
                // 0x80b08e6
                *(int32_t *)(v31 + 12) = (int32_t)"fontposition out of range";
                goto lab_0x80b08bd;
            }
        }
        case 167: {
            int32_t v503 = *(int32_t *)(v86 - 36); // 0x80ae9ef
            if (v503 < 256) {
                int32_t v504 = 28 * v503 + (int32_t)yyFont;
                *(int32_t *)&Symbol = v504 + 24;
                char * v505 = (char *)(v504 + 28); // 0x80aea16
                if (*v505 != 0) {
                    // 0x80b08b5
                    *(int32_t *)(v31 + 12) = (int32_t)"symbol ID used twice";
                    goto lab_0x80b08bd;
                } else {
                    // 0x80aea20
                    *v505 = 1;
                    g93 = 100 * *(int32_t *)(v86 - 24);
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 167;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                    goto lab_0x80ae240;
                }
            } else {
                // 0x80b08e6
                *(int32_t *)(v31 + 12) = (int32_t)"fontposition out of range";
                goto lab_0x80b08bd;
            }
        }
        case 176: {
            // 0x80ae99d
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            v200 = 100 * *(int32_t *)(v86 - 60);
            goto lab_0x80ae9c7;
        }
        case 177: {
            // 0x80aef1c
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 48);
            v200 = *(int32_t *)(v86 - 60);
            goto lab_0x80ae9c7;
        }
        case 185: {
            int32_t * v506 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 8) = *v506;
            int32_t * v507 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 4) = *v507;
            int32_t * v508 = (int32_t *)v31;
            *v508 = (int32_t)yyPCB + 0x21f4;
            int32_t * v509 = CreateNewNet((int32_t *)v80, (char *)&g279, (char *)&g279); // 0x80af245
            *(int32_t *)&Menu = (int32_t)v509;
            v164 = v506;
            v163 = v508;
            v162 = v507;
            v175 = v31;
            goto lab_0x80af255;
        }
        case 191: {
            int32_t * v510 = (int32_t *)(v86 - 12); // 0x80ae56f
            *(int32_t *)(v31 + 4) = *v510;
            int32_t * v511 = (int32_t *)v31; // 0x80ae581
            *v511 = (int32_t)Menu;
            CreateNewConnection((int32_t *)v80, (char *)&g279);
            *v511 = *v510;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 191;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 194: {
            int32_t * v512 = (int32_t *)(v86 - 12); // 0x80ae6fd
            *(int32_t *)(v31 + 8) = *v512;
            int32_t * v513 = (int32_t *)(v86 - 24); // 0x80ae704
            *(int32_t *)(v31 + 4) = *v513;
            int32_t * v514 = (int32_t *)v31; // 0x80ae716
            *v514 = (int32_t)attr_list;
            CreateNewAttribute((int32_t *)v80, (char *)&g279, (char *)&g279);
            *v514 = *v513;
            SaveFree((char *)&g279);
            *v514 = *v512;
            SaveFree((char *)&g279);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 194;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 195: {
            // 0x80ae866
            v6 = *(int32_t *)v86;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 195;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 196: {
            // 0x80b06b7
            v6 = 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 196;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        default: {
            goto lab_0x80ae240;
        }
    }
  lab_0x80b06d2:
    // 0x80b06d2
    *(int32_t *)(v31 + 12) = (int32_t)"memory exhausted";
    *v56 = (int32_t)"ERROR parsing file '%s'\n    line:        %i\n    description: '%s'\n";
    *(int32_t *)(v31 + 8) = yylineno;
    *v24 = yyfilename;
    Message((char *)nmemb);
    v34 = v32;
    v37 = v35;
    v43 = v44;
    v60 = v58;
    v46 = v28;
    v48 = nmemb;
    v40 = v41;
    v63 = v62;
    v55 = v54;
    v52 = v51;
    v25 = 0;
    v29 = nmemb;
    v27 = 2;
    goto lab_0x80aece1;
  lab_0x80ae329:;
    int32_t v566 = v88;
    int32_t v567 = v80;
    int32_t v568 = v86;
    int32_t v569; // 0x80adf30
    uint32_t v570; // 0x80ae331
    int32_t v571; // 0x80adf30
    uint16_t v572; // 0x80ae347
    int32_t v573; // 0x80ae362
    if (v566 != -424) {
        // 0x80ae331
        v570 = v566 + 1;
        if (v570 < 590) {
            // 0x80ae33c
            if (*(int16_t *)(v570 + v566 + 0x814c521) == 1) {
                // 0x80ae347
                if (*(int16_t *)(v571 + 0x814c9c1) >= 1) {
                    // 0x80ae353
                    v34 = v568;
                    v37 = v85;
                    v43 = v84;
                    v60 = v83;
                    v46 = v82;
                    v48 = v569;
                    v40 = v124;
                    v63 = v62;
                    v55 = v54;
                    v52 = v51;
                    v25 = 0;
                    v29 = v567;
                    v27 = 0;
                    if (v572 == 10) {
                        goto lab_0x80aece1;
                    } else {
                        // 0x80ae362
                        v573 = v568 + 12;
                        int32_t v574 = yylval; // 0x80ae36b
                        *(int32_t *)v573 = v574;
                        int32_t v575 = g251; // 0x80ae378
                        *(int32_t *)(v568 + 16) = v575;
                        int32_t v576 = g252; // 0x80ae380
                        *(int32_t *)(v568 + 20) = v576;
                        v93 = v573;
                        v94 = v85;
                        v98 = v84;
                        v105 = 3;
                        v106 = v83;
                        v99 = v82;
                        v101 = v569;
                        v96 = v124;
                        v107 = v62;
                        v104 = v54;
                        v103 = v51;
                        v91 = v567;
                        v90 = v572;
                        v92 = v31;
                        goto lab_0x80ae2ae;
                    }
                }
            }
        }
    }
    int32_t v527 = v86; // 0x80ae312
    int32_t v528 = v85; // 0x80ae312
    int32_t v529 = v84; // 0x80ae312
    int32_t v530 = v83; // 0x80ae312
    int32_t v531 = v82; // 0x80ae312
    int32_t v532 = v126; // 0x80ae312
    int32_t v533 = v124; // 0x80ae312
    int32_t v534 = v62; // 0x80ae312
    int32_t v535 = v54; // 0x80ae312
    int32_t v536 = v51; // 0x80ae312
    int32_t v537 = v85; // 0x80ae312
    int32_t v538 = 1; // 0x80ae312
    while (v567 != v85) {
        int32_t v577 = v567 - 2; // 0x80ae318
        int16_t v578 = *(int16_t *)v577; // 0x80ae31e
        int16_t v579 = *(int16_t *)(2 * (int32_t)v578 + (int32_t)&g23); // 0x80ae321
        v566 = v579;
        v567 = v577;
        v568 -= 12;
        if (v566 != -424) {
            // 0x80ae331
            v570 = v566 + 1;
            if (v570 < 590) {
                // 0x80ae33c
                if (*(int16_t *)(v570 + v566 + 0x814c521) == 1) {
                    // 0x80ae347
                    v572 = *(int16_t *)(v571 + 0x814c9c1);
                    if (v572 >= 1) {
                        // 0x80ae353
                        v34 = v568;
                        v37 = v85;
                        v43 = v84;
                        v60 = v83;
                        v46 = v82;
                        v48 = v569;
                        v40 = v124;
                        v63 = v62;
                        v55 = v54;
                        v52 = v51;
                        v25 = 0;
                        v29 = v567;
                        v27 = 0;
                        if (v572 == 10) {
                            goto lab_0x80aece1;
                        } else {
                            // 0x80ae362
                            v573 = v568 + 12;
                            *(int32_t *)v573 = yylval;
                            *(int32_t *)(v568 + 16) = g251;
                            *(int32_t *)(v568 + 20) = g252;
                            v93 = v573;
                            v94 = v85;
                            v98 = v84;
                            v105 = 3;
                            v106 = v83;
                            v99 = v82;
                            v101 = v569;
                            v96 = v124;
                            v107 = v62;
                            v104 = v54;
                            v103 = v51;
                            v91 = v567;
                            v90 = v572;
                            v92 = v31;
                            goto lab_0x80ae2ae;
                        }
                    }
                }
            }
        }
        // 0x80ae310
        v527 = v86;
        v528 = v85;
        v529 = v84;
        v530 = v83;
        v531 = v82;
        v532 = v126;
        v533 = v124;
        v534 = v62;
        v535 = v54;
        v536 = v51;
        v537 = v85;
        v538 = 1;
    }
    goto lab_0x80ae3a3;
  lab_0x80aecd2:
    // 0x80aecd2
    v34 = v86;
    v37 = v85;
    v43 = v84;
    v60 = v83;
    v46 = v82;
    v48 = v129;
    v40 = v128;
    v63 = v131;
    v55 = v133;
    v52 = v134;
    v25 = -((2 * v131));
    v29 = v80;
    v27 = 1;
    goto lab_0x80aece1;
  lab_0x80ae4fb:
    // 0x80ae4fb
    *(int32_t *)(v31 + 8) = (int32_t)yyFont;
    *(int32_t *)(v31 + 4) = (int32_t)yyElement;
    *(int32_t *)v31 = (int32_t)yyData;
    SetElementBoundingBox((int32_t *)v80, &g279, &g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80ae555:
    // 0x80ae555
    *(int32_t *)&attr_list = (int32_t)&g271;
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v129;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80ae240:;
    int32_t v556 = v146;
    int32_t v554 = v144;
    int32_t v553 = v143;
    int32_t v552 = v142;
    int32_t v551 = v141;
    int32_t v550 = v140;
    int32_t v549 = v139;
    int32_t v548 = v138;
    int32_t v547 = v137;
    int32_t v546 = v136;
    int32_t v555 = v145 - 2 * v552; // 0x80ae254
    int32_t v557 = -12 * v552 + v135; // 0x80ae25f
    int32_t v545 = v557 + 12; // 0x80ae261
    *(int32_t *)v545 = v6;
    *(int32_t *)(v557 + 16) = v553;
    *(int32_t *)(v557 + 20) = v554;
    int16_t v558 = *(int16_t *)v555; // 0x80ae27f
    unsigned char v559 = *(char *)(v551 + (int32_t)&g29); // 0x80ae282
    int32_t v544 = 2 * (int32_t)v559;
    int16_t v560 = *(int16_t *)(v544 + (int32_t)&g30 - 82); // 0x80ae28f
    uint32_t v561 = (int32_t)v560 + (int32_t)v558; // 0x80ae297
    if (v561 < 590) {
        int32_t v562 = 2 * v561;
        if (*(int16_t *)(v562 + (int32_t)&g25) != v558) {
            goto lab_0x80ae2a6;
        } else {
            int16_t v563 = *(int16_t *)(v562 + (int32_t)&g26); // 0x80ae3e6
            v93 = v545;
            v94 = v546;
            v98 = v547;
            v105 = v57;
            v106 = v548;
            v99 = v549;
            v101 = v550;
            v96 = v551;
            v107 = v552;
            v104 = v553;
            v103 = v554;
            v91 = v555;
            v90 = v563;
            v92 = v556;
            goto lab_0x80ae2ae;
        }
    } else {
        goto lab_0x80ae2a6;
    }
  lab_0x80aece1:;
    int32_t v515 = v27;
    int32_t v516 = v52;
    int32_t v517 = v55;
    int32_t v518 = v63;
    int32_t v519 = v40;
    int32_t v520 = v48;
    int32_t v521 = v46;
    int32_t v522 = v60;
    int32_t v523 = v43;
    int32_t v524 = v37;
    int32_t v525 = v34;
    int32_t v526 = v29 + v25; // 0x80aece1
    v527 = v525;
    v528 = v524;
    v529 = v523;
    v530 = v522;
    v531 = v521;
    v532 = v520;
    v533 = v519;
    v534 = v518;
    v535 = v517;
    v536 = v516;
    v537 = v524;
    v538 = v515;
    if (v524 != v526) {
        // 0x80aecf0
        v527 = v525;
        v528 = v524;
        v529 = v523;
        v530 = v522;
        v531 = v521;
        v532 = v520;
        v533 = v519;
        v534 = v518;
        v535 = v517;
        v536 = v516;
        v537 = (v524 + 1 - v526 & -2) + v526;
        v538 = v515;
    }
    goto lab_0x80ae3a3;
  lab_0x80ae3a3:
    // 0x80ae3a3
    result = v538;
    int32_t v539 = v528;
    if (v537 != v5) {
        // 0x80ae3ab
        *(int32_t *)v31 = v539;
        free(&g279);
    }
    // 0x80ae3b9
    if (v3 == __readgsdword(20)) {
        // break -> 0x80ae3cb
        goto lab_0x80ae3cb;
    }
    // 0x80b0904
    __stack_chk_fail();
    v147 = (int32_t *)v532;
    v167 = (int32_t *)v31;
    v180 = v527;
    v182 = v539;
    v186 = v529;
    v204 = v530;
    v188 = v531;
    v189 = v532;
    v183 = v533;
    v206 = v534;
    v193 = v535;
    v191 = v536;
    v169 = result;
    goto lab_0x80b0909;
  lab_0x80ae2a6:;
    int16_t v543 = *(int16_t *)(v544 + (int32_t)&g31 - 82); // 0x80ae2a6
    v93 = v545;
    v94 = v546;
    v98 = v547;
    v105 = v57;
    v106 = v548;
    v99 = v549;
    v101 = v550;
    v96 = v551;
    v107 = v552;
    v104 = v553;
    v103 = v554;
    v91 = v555;
    v90 = v543;
    v92 = v556;
    goto lab_0x80ae2ae;
  lab_0x80af5e9:
    // 0x80af5e9
    __asm_rep_movsd_memcpy((char *)((int32_t)v170 + 4), (char *)&v12, 3);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31 - 4;
    goto lab_0x80ae240;
  lab_0x80af544:;
    int32_t * v564 = (int32_t *)v31; // 0x80af54a
    *v564 = *(int32_t *)(v86 - 12);
    int32_t v565 = ParseRouteString((char *)v80, &g279, (int32_t)&g279); // 0x80af54d
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    if (v565 == 0) {
        goto lab_0x80ae240;
    } else {
        // 0x80af560
        *v564 = (int32_t)"illegal route-style string\n";
        Message((char *)&g279);
        goto lab_0x80af56c;
    }
  lab_0x80b0547:
    // 0x80b0547
    *(int32_t *)(v172 + 4) = 100 * *(int32_t *)v168;
    *v151 = (int32_t)yyData;
    CreateNewVia(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
    v153 = v151;
    v152 = v148;
    v176 = v172;
    goto lab_0x80afabe;
  lab_0x80b0133:
    // 0x80b0133
    *(int32_t *)(v201 + 4) = 100 * *(int32_t *)v194;
    *v202 = (int32_t)Layer;
    CreateNewLineOnLayer(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v201;
    goto lab_0x80ae240;
  lab_0x80affd4:
    // 0x80affd4
    *(int32_t *)(v178 + 4) = 100 * *(int32_t *)v199;
    *v154 = (int32_t)Layer;
    CreateNewArcOnLayer(&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v178;
    goto lab_0x80ae240;
  lab_0x80afe1c:
    // 0x80afe1c
    *v156 = *v155;
    SaveFree((char *)v80);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v177;
    goto lab_0x80ae240;
  lab_0x80afd4b:
    // 0x80afd4b
    *(int32_t *)(v31 + 4) = v198;
    *(int32_t *)v31 = (int32_t)Polygon;
    CreateNewPointInPolygon((int32_t *)v80, (int32_t)&g279, (int32_t)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80ae6d7:
    // 0x80ae6d7
    *v158 = *v157;
    SaveFree((char *)&g279);
    pin_num = 1;
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v173;
    goto lab_0x80ae240;
  lab_0x80afb8f:
    // 0x80afb8f
    *(int32_t *)(v31 + 4) = v197;
    *(int32_t *)v31 = (int32_t)yyElement;
    CreateNewLineInElement((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80af1c7:
    // 0x80af1c7
    *(int32_t *)(v31 + 4) = v196;
    *(int32_t *)v31 = (int32_t)yyElement;
    CreateNewArcInElement((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80af0ca:
    // 0x80af0ca
    *(int32_t *)(v31 + 4) = v195;
    *(int32_t *)v31 = (int32_t)yyElement;
    CreateNewArcInElement((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80aefd1:
    // 0x80aefd1
    *v160 = *v159;
    SaveFree((char *)&g279);
    *v160 = *v161;
    SaveFree((char *)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v174;
    goto lab_0x80ae240;
  lab_0x80af255:
    // 0x80af255
    *v163 = *v162;
    SaveFree((char *)&g279);
    *v163 = *v164;
    SaveFree((char *)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v175;
    goto lab_0x80ae240;
  lab_0x80afabe:
    // 0x80afabe
    *v153 = *v152;
    SaveFree((char *)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v176;
    goto lab_0x80ae240;
  lab_0x80ae9c7:
    // 0x80ae9c7
    *(int32_t *)(v31 + 4) = v200;
    *(int32_t *)v31 = (int32_t)Symbol;
    CreateNewLineInSymbol((int32_t *)v80, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279, (int32_t)&g279);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80b0909:;
    int32_t * v540 = (int32_t *)(v31 + 8);
    *v540 = 0;
    int32_t * v541 = (int32_t *)(v31 + 4);
    *v541 = 0;
    *v167 = 0;
    int32_t * v542 = r_create_tree((int32_t **)&g279, (int32_t)&g279, (int32_t)&g279); // 0x80b0920
    *(int32_t *)(v169 + 60) = (int32_t)v542;
    v166 = v541;
    v165 = v540;
    v150 = v147;
    v149 = v167;
    v179 = v180;
    v181 = v182;
    v185 = v186;
    v203 = v204;
    v187 = v188;
    v184 = v183;
    v205 = v206;
    v192 = v193;
    v190 = v191;
    v171 = v189;
    goto lab_0x80b0246;
  lab_0x80ae2ae:
    // 0x80ae2ae
    v14 = v93;
    v15 = v94;
    v16 = v98;
    v17 = v105;
    v18 = v106;
    v47 = v101;
    v38 = v96;
    v61 = v107;
    v53 = v104;
    v50 = v103;
    v19 = v91 + 2;
    v20 = v90;
    v22 = v92;
    v23 = v99;
    goto lab_0x80adfc1;
  lab_0x80af56c:
    // 0x80af56c
    v34 = v86;
    v37 = v85;
    v43 = v84;
    v60 = v83;
    v46 = v82;
    v48 = v80;
    v40 = v128;
    v63 = v131;
    v55 = v133;
    v52 = v134;
    v25 = -((2 * v131));
    v29 = v80;
    v27 = 1;
    goto lab_0x80aece1;
  lab_0x80b08bd:
    // 0x80b08bd
    *(int32_t *)v31 = (int32_t)"ERROR parsing file '%s'\n    line:        %i\n    description: '%s'\n";
    *(int32_t *)(v31 + 8) = yylineno;
    *(int32_t *)(v31 + 4) = yyfilename;
    Message((char *)v80);
    goto lab_0x80af56c;
  lab_0x80b0246:
    // 0x80b0246
    *v165 = 0;
    *v149 = g94;
    *v166 = (int32_t)Polygon;
    r_insert_entry(v150, &g279, (int32_t)&g279);
    v135 = v179;
    v136 = v181;
    v137 = v185;
    v138 = v203;
    v139 = v187;
    v140 = v171;
    v141 = v184;
    v142 = v205;
    v143 = v192;
    v144 = v190;
    v145 = v171;
    v146 = v31;
    goto lab_0x80ae240;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b11b0 - 0x80b12c5
// Line range:    204 - 229
int32_t * original_poly(int32_t * p) {
    // 0x80b11b0
    int32_t v1; // 0x80b11b0
    int32_t v2 = *(int32_t *)(v1 + 36); // 0x80b11be
    int32_t v3 = 0; // 0x80b11c7
    if (v2 != 0) {
        int32_t v4 = v2; // 0x80b11d4
        int32_t v5 = 20 * v2; // 0x80b11d4
        int32_t v6 = 0; // 0x80b11d4
        while (true) {
            int32_t v7 = v6;
            v5 -= 20;
            int32_t v8 = *(int32_t *)(*(int32_t *)(v1 + 56) + v5); // bp-36, 0x80b11e4
            int32_t v9; // 0x80b11b0
            if (v7 == 0) {
                int32_t * v10 = poly_NewContour(&v8); // 0x80b129e
                v9 = (int32_t)v10;
                if (v10 == NULL) {
                    // break -> 0x80b128c
                    break;
                }
            } else {
                int32_t * v11 = poly_CreateNode(&v8); // 0x80b11f9
                poly_InclVertex((int32_t *)*(int32_t *)(v7 + 24), v11);
                v9 = v7;
            }
            // 0x80b120d
            v4--;
            v6 = v9;
            v3 = v6;
            if (v4 == 0) {
                goto lab_0x80b1218;
            }
        }
        // 0x80b128c
        return (int32_t *)0;
    }
  lab_0x80b1218:;
    int32_t * v12 = (int32_t *)v3; // 0x80b1223
    poly_PreContour(v12, 1);
    if ((*(char *)(v3 + 68) & 8) == 0) {
        // 0x80b12b8
        poly_InvContour(v12);
    }
    int32_t * v13 = poly_Create(); // 0x80b1232
    if (v13 == NULL) {
        // 0x80b128c
        return (int32_t *)0;
    }
    int32_t v14 = (int32_t)v13; // 0x80b1232
    poly_InclContour(v13, v12);
    int32_t v15 = v14;
    float80_t v16 = (float80_t)*(float64_t *)(*(int32_t *)(v15 + 8) + 56); // 0x80b1265
    int32_t v17 = *(int32_t *)v15;
    int32_t v18; // 0x80b11b0
    while (-1.0L >= v16) {
        // 0x80b126c
        v18 = 0;
        if (v17 == v14) {
            // break (via goto) -> 0x80b127a
            goto lab_0x80b127a;
        }
        v15 = v17;
        v16 = (float80_t)*(float64_t *)(*(int32_t *)(v15 + 8) + 56);
        v17 = *(int32_t *)v15;
    }
    float80_t v19 = v16; // 0x80b1260
    v18 = v15;
    while (v17 != v14) {
        int32_t v20 = v15;
        v15 = v17;
        v16 = (float80_t)*(float64_t *)(*(int32_t *)(v15 + 8) + 56);
        v17 = *(int32_t *)v15;
        while (v19 >= v16) {
            // 0x80b126c
            v18 = v20;
            if (v17 == v14) {
                // break (via goto) -> 0x80b127a
                goto lab_0x80b127a;
            }
            v15 = v17;
            v16 = (float80_t)*(float64_t *)(*(int32_t *)(v15 + 8) + 56);
            v17 = *(int32_t *)v15;
        }
        // 0x80b1258
        v19 = v16;
        v18 = v15;
    }
  lab_0x80b127a:
    // 0x80b127a
    if (v18 != v14) {
        int32_t * v21 = (int32_t *)(v18 + 8); // 0x80b127e
        int32_t * v22 = (int32_t *)(v14 + 8); // 0x80b1281
        *v21 = *v22;
        *v22 = *v21;
    }
    // 0x80b128c
    return (int32_t *)v14;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b1eb0 - 0x80b23de
// Line range:    895 - 889
int32_t clearPoly(int32_t * Data, int32_t * Layer2, int32_t * polygon, int32_t * here, int32_t expand) {
    int32_t v1[8]; // 0x80b2072
    struct __jmp_buf_tag v2; // 0x80b2072
    struct __jmp_buf_tag env[1]; // 0x80b2072
    // 0x80b1eb0
    int32_t v3; // 0x80b1eb0
    if ((*(char *)(v3 + 20) & 16) == 0) {
        // 0x80b1ed4
        return 0;
    }
    uint32_t v4 = GetLayerNumber(v3, v3); // 0x80b1eef
    if (v4 >= *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
        // 0x80b1ed4
        return 0;
    }
    int32_t v5 = GetLayerNumber(v3, v3); // 0x80b1f18
    uint32_t v6 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x80b1f29
    int32_t v7 = 0; // 0x80b1f2e
    int32_t v8 = 0; // 0x80b1f2e
    if (v6 != 0) {
        int32_t v9 = *(int32_t *)(v3 + 72); // 0x80b1f44
        int32_t v10 = v9 + 0x1cd4;
        int32_t v11 = v9 + 0x1d18;
        int32_t v12 = 0;
        uint32_t v13 = *(int32_t *)(4 * v12 + v10); // 0x80b1f5f
        int32_t v14; // 0x80b1eb0
        int32_t v15; // 0x80b1eb0
        int32_t v16; // 0x80b1eb0
        int32_t v17; // 0x80b1f9d
        if (v13 != 0) {
            // 0x80b1f6a
            if (v5 == *(int32_t *)(v9 + 0x1d14)) {
                // break -> 0x80b20a0
                break;
            }
            // 0x80b1f7c
            v14 = 72 * v12 + v11;
            v17 = 0;
            while (v17 + 1 < v13) {
                // 0x80b1f9d
                v17++;
                // 0x80b1f90
                v15 = v14;
                v14 = v15 + 4;
                v16 = v12;
                if (v5 == *(int32_t *)v15) {
                    // break (via goto) -> 0x80b20a0
                    goto lab_0x80b20a0;
                }
            }
        }
        int32_t v18 = v12 + 1; // 0x80b1fa4
        int32_t v19 = v9 + 72; // 0x80b1fb8
        v16 = v18;
        while (v18 < v6) {
            int32_t v20 = v19;
            v12 = v18;
            v13 = *(int32_t *)(4 * v12 + v10);
            if (v13 != 0) {
                // 0x80b1f6a
                v16 = v12;
                if (v5 == *(int32_t *)(v20 + 0x1d14)) {
                    // break -> 0x80b20a0
                    break;
                }
                // 0x80b1f7c
                v14 = 72 * v12 + v11;
                v17 = 0;
                while (v17 + 1 < v13) {
                    // 0x80b1f9d
                    v17++;
                    // 0x80b1f90
                    v15 = v14;
                    v14 = v15 + 4;
                    v16 = v12;
                    if (v5 == *(int32_t *)v15) {
                        // break (via goto) -> 0x80b20a0
                        goto lab_0x80b20a0;
                    }
                }
            }
            // 0x80b1fa4
            v18 = v12 + 1;
            v19 = v20 + 72;
            v16 = v18;
        }
      lab_0x80b20a0:;
        int32_t v21 = 0;
        uint32_t v22 = *(int32_t *)(4 * v21 + v10); // 0x80b20bd
        int32_t v23; // 0x80b1eb0
        int32_t v24; // 0x80b1eb0
        int32_t v25; // 0x80b20f5
        if (v22 != 0) {
            // 0x80b20c8
            if (*(int32_t *)(v9 + 0x1d14) == v6) {
                // break -> 0x80b1fc8
                break;
            }
            // 0x80b20da
            v25 = 0;
            v23 = 72 * v21 + v11;
            v25++;
            while (v25 < v22) {
                // 0x80b20e8
                v24 = v23;
                v7 = v16;
                v8 = v21;
                v23 = v24 + 4;
                if (*(int32_t *)v24 == v6) {
                    // break (via goto) -> 0x80b1fc8
                    goto lab_0x80b1fc8;
                }
                v25++;
            }
        }
        int32_t v26 = v21 + 1; // 0x80b20fc
        v7 = v16;
        v8 = v26;
        int32_t v27 = v9 + 72; // 0x80b2108
        while (v26 < v6) {
            // 0x80b20b7
            v21 = v26;
            int32_t v28 = v27;
            v22 = *(int32_t *)(4 * v21 + v10);
            if (v22 != 0) {
                // 0x80b20c8
                v7 = v16;
                v8 = v21;
                if (*(int32_t *)(v28 + 0x1d14) == v6) {
                    // break -> 0x80b1fc8
                    break;
                }
                // 0x80b20da
                v25 = 0;
                v23 = 72 * v21 + v11;
                v25++;
                while (v25 < v22) {
                    // 0x80b20e8
                    v24 = v23;
                    v7 = v16;
                    v8 = v21;
                    v23 = v24 + 4;
                    if (*(int32_t *)v24 == v6) {
                        // break (via goto) -> 0x80b1fc8
                        goto lab_0x80b1fc8;
                    }
                    v25++;
                }
            }
            // 0x80b20fc
            v26 = v21 + 1;
            v7 = v16;
            v8 = v26;
            v27 = v28 + 72;
        }
    }
  lab_0x80b1fc8:;
    int32_t v29 = (int32_t)Data;
    int32_t v30; // 0x80b1eb0
    if (Data != NULL) {
        int32_t v31 = *Data; // 0x80b1fde
        int32_t v32 = v31 - v29; // 0x80b1fde
        v30 = v32 < 0 == ((v32 ^ v31) & (v31 ^ v29)) < 0 ? v31 : v29;
    }
    int32_t v33 = v30 - (int32_t)Layer2; // bp-44, 0x80b2018
    int32_t v34 = v29; // bp-220, 0x80b2050
    int32_t v35; // bp-200, 0x80b1eb0
    v1[0] = &v35;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80b2081
        *(int32_t *)(v3 + 52) = 0;
        return 0;
    }
    int32_t v36 = *(int32_t *)(v3 + 40); // 0x80b2137
    int32_t v37 = r_search((int32_t *)v36, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4560, (char *)&v34); // 0x80b213d
    int32_t v38 = *(int32_t *)(v3 + 48); // 0x80b2165
    int32_t v39 = r_search((int32_t *)v38, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4560, (char *)&v34); // 0x80b216b
    int32_t v40 = v39 + v37; // 0x80b2176
    int32_t * v41 = (int32_t *)(v3 + 72); // 0x80b2179
    int32_t v42 = *v41; // 0x80b2179
    int32_t v43 = 4 * v7 + 0x1cd4;
    int32_t v44 = v42; // 0x80b218e
    int32_t result = v40; // 0x80b218e
    if (*(int32_t *)(v42 + v43) != 0) {
        int32_t v45 = 0; // 0x80b21b3
        uint32_t v46 = *(int32_t *)(v42 + 4 + 4 * (18 * v7 + 1860 + v45)); // 0x80b21cf
        int32_t v47 = v42; // 0x80b21e1
        int32_t v48 = v40; // 0x80b21e1
        int32_t v49; // 0x80b21fb
        int32_t v50; // 0x80b2209
        int32_t v51; // 0x80b221e
        int32_t v52; // 0x80b224a
        int32_t v53; // 0x80b2253
        int32_t v54; // 0x80b228b
        int32_t v55; // 0x80b2294
        if (v46 < *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
            // 0x80b21e3
            v49 = 92 * v46 + v3;
            v50 = *(int32_t *)(v49 + 128);
            v51 = r_search((int32_t *)v50, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4460, (char *)&v34);
            v52 = *(int32_t *)(v49 + 140);
            v53 = r_search((int32_t *)v52, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4310, (char *)&v34);
            v54 = *(int32_t *)(v49 + 132);
            v55 = r_search((int32_t *)v54, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4630, (char *)&v34);
            v47 = *v41;
            v48 = v51 + v40 + v53 + v55;
        }
        int32_t v56 = v48;
        int32_t v57 = v47; // 0x80b21b8
        v45++;
        v44 = v57;
        result = v56;
        while (*(int32_t *)(v57 + v43) > v45) {
            int32_t v58 = v56;
            v46 = *(int32_t *)(v57 + 4 + 4 * (18 * v7 + 1860 + v45));
            v47 = v57;
            v48 = v58;
            if (v46 < *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
                // 0x80b21e3
                v49 = 92 * v46 + v3;
                v50 = *(int32_t *)(v49 + 128);
                v51 = r_search((int32_t *)v50, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4460, (char *)&v34);
                v52 = *(int32_t *)(v49 + 140);
                v53 = r_search((int32_t *)v52, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4310, (char *)&v34);
                v54 = *(int32_t *)(v49 + 132);
                v55 = r_search((int32_t *)v54, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b4630, (char *)&v34);
                v47 = *v41;
                v48 = v51 + v58 + v53 + v55;
            }
            // 0x80b21b8
            v56 = v48;
            v57 = v47;
            v45++;
            v44 = v57;
            result = v56;
        }
    }
    // 0x80b22be
    if (v8 != v7) {
        uint32_t v59 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x80b22e7
        int32_t v60 = 0; // 0x80b22f5
        if (v59 != 0) {
            int32_t v61 = v59 + 1; // 0x80b22ec
            int32_t v62 = 0;
            uint32_t v63 = *(int32_t *)(v44 + 0x1cd4 + 4 * v62); // 0x80b2303
            int32_t v64; // 0x80b1eb0
            int32_t v65; // 0x80b1eb0
            int32_t v66; // 0x80b2339
            if (v63 != 0) {
                // 0x80b230e
                if (v61 == *(int32_t *)(v44 + 0x1d14)) {
                    // break -> 0x80b2366
                    break;
                }
                // 0x80b231c
                v64 = v44 + 0x1d18 + 72 * v62;
                v66 = 0;
                while (v63 > v66 + 1) {
                    // 0x80b2339
                    v66++;
                    // 0x80b2330
                    v65 = v64;
                    v64 = v65 + 4;
                    v60 = v62;
                    if (v61 == *(int32_t *)v65) {
                        // break (via goto) -> 0x80b2366
                        goto lab_0x80b2366;
                    }
                }
            }
            int32_t v67 = v62 + 1; // 0x80b2340
            int32_t v68 = v44 + 72; // 0x80b235a
            v60 = v67;
            while (v59 > v67) {
                int32_t v69 = v68;
                v62 = v67;
                v63 = *(int32_t *)(v44 + 0x1cd4 + 4 * v62);
                if (v63 != 0) {
                    // 0x80b230e
                    v60 = v62;
                    if (v61 == *(int32_t *)(v69 + 0x1d14)) {
                        // break -> 0x80b2366
                        break;
                    }
                    // 0x80b231c
                    v64 = v44 + 0x1d18 + 72 * v62;
                    v66 = 0;
                    while (v63 > v66 + 1) {
                        // 0x80b2339
                        v66++;
                        // 0x80b2330
                        v65 = v64;
                        v64 = v65 + 4;
                        v60 = v62;
                        if (v61 == *(int32_t *)v65) {
                            // break (via goto) -> 0x80b2366
                            goto lab_0x80b2366;
                        }
                    }
                }
                // 0x80b2340
                v67 = v62 + 1;
                v68 = v69 + 72;
                v60 = v67;
            }
        }
      lab_0x80b2366:
        // 0x80b2366
        if (v60 != v7) {
            // 0x80b2081
            *(int32_t *)(v3 + 52) = 0;
            return result;
        }
    }
    int32_t v70 = *(int32_t *)(v3 + 52); // 0x80b239f
    int32_t v71 = r_search((int32_t *)v70, &v33, NULL, (int32_t (*)(int32_t *, char *))0x80b43c0, (char *)&v34); // 0x80b23a5
    // 0x80b2081
    *(int32_t *)(v3 + 52) = 0;
    return v71 + result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b24a0 - 0x80b290b
// Line range:    1383 - 1472
int32_t PlowsPolygon(int32_t * Data, int32_t type, char * ptr1, char * ptr2, int32_t (*call_back)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *)) {
    int32_t v1 = (int32_t)ptr2;
    int32_t v2 = (int32_t)ptr1;
    int32_t v3 = (int32_t)Data;
    int32_t v4 = *(int32_t *)ptr2; // bp-44, 0x80b24c3
    int32_t v5 = type; // bp-68, 0x80b24db
    int32_t result; // 0x80b24a0
    if (type == 16) {
        goto lab_0x80b2610;
    } else {
        if (type > 16) {
            switch (type) {
                case 512: {
                    int32_t v6 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24); // 0x80b27d0
                    int32_t v7 = GetLayerGroupNumberByNumber((*(int32_t *)(v1 + 20) / 128 % 2 ^ 1) + v6); // 0x80b27d6
                    int32_t * v8 = (int32_t *)(v3 + 72); // 0x80b27db
                    int32_t v9 = *v8; // 0x80b27db
                    int32_t v10 = 4 * v7; // 0x80b27de
                    int32_t v11 = v10 + 0x1cd4;
                    if (*(int32_t *)(v11 + v9) == 0) {
                        // 0x80b25ff
                        return 0;
                    }
                    int32_t (*v12)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *) = NULL;
                    int32_t v13 = v9 + 4; // 0x80b2821
                    int32_t * v14 = (int32_t *)(v10 + 0x1cd0 + v13);
                    int32_t v15 = 0;
                    uint32_t v16 = *(int32_t *)(4 * (18 * v7 + 1860 + v15) + v13); // 0x80b2821
                    int32_t (*v17)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *); // 0x80b24a0
                    int32_t v18; // 0x80b280b
                    while (v16 >= *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
                        // 0x80b2808
                        v18 = v15 + 1;
                        v17 = v12;
                        if (*v14 <= v18) {
                            return (int32_t)v17;
                        }
                        v15 = v18;
                        v16 = *(int32_t *)(4 * (18 * v7 + 1860 + v15) + v13);
                    }
                    int32_t v19 = v15 + 1; // 0x80b2833
                    int32_t v20 = *(int32_t *)(v3 + 136 + 92 * v16); // 0x80b285b
                    int32_t v21 = r_search((int32_t *)v20, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5); // 0x80b2865
                    int32_t v22 = *v8; // 0x80b286a
                    int32_t (*v23)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *) = (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))(v21 + (int32_t)v12);
                    v17 = v23;
                    while (*(int32_t *)(v22 + v11) > v19) {
                        // 0x80b2814
                        v12 = v23;
                        v13 = v22 + 4;
                        v14 = (int32_t *)(v10 + 0x1cd0 + v13);
                        v15 = v19;
                        v16 = *(int32_t *)(4 * (18 * v7 + 1860 + v15) + v13);
                        while (v16 >= *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
                            // 0x80b2808
                            v18 = v15 + 1;
                            v17 = v12;
                            if (*v14 <= v18) {
                                return (int32_t)v17;
                            }
                            v15 = v18;
                            v16 = *(int32_t *)(4 * (18 * v7 + 1860 + v15) + v13);
                        }
                        // 0x80b2830
                        v19 = v15 + 1;
                        v20 = *(int32_t *)(v3 + 136 + 92 * v16);
                        v21 = r_search((int32_t *)v20, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5);
                        v22 = *v8;
                        v23 = (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))(v21 + (int32_t)v12);
                        v17 = v23;
                    }
                  lab_0x80b2880:
                    // 0x80b2880
                    return (int32_t)v17;
                }
                case 0x4000: {
                    goto lab_0x80b2610;
                }
                default: {
                    // 0x80b2506
                    if (type != 256) {
                        // 0x80b25ff
                        return 0;
                    }
                    goto lab_0x80b2516;
                }
            }
        } else {
            // 0x80b25e8
            result = 0;
            switch (type) {
                case 2: {
                    int32_t * v24 = (int32_t *)(v2 + 224); // 0x80b26e8
                    int32_t v25 = *v24; // 0x80b26e8
                    if (v25 != 0) {
                        int32_t v26 = v25; // 0x80b24a0
                        int32_t v27 = 0; // 0x80b2704
                        PlowsPolygon(Data, 256, ptr1, (char *)(76 * v27 + *(int32_t *)(v2 + 256)), call_back);
                        uint32_t v28 = *v24; // 0x80b2737
                        while (v28 != 0) {
                            // 0x80b2700
                            v27 = 1 - v26 + v27 + v28;
                            v26 = v28;
                            if (v28 <= v27) {
                                // break -> 0x80b2747
                                break;
                            }
                            PlowsPolygon(Data, 256, ptr1, (char *)(76 * v27 + *(int32_t *)(v2 + 256)), call_back);
                            v28 = *v24;
                        }
                    }
                    int32_t * v29 = (int32_t *)(v2 + 232); // 0x80b2747
                    int32_t v30 = *v29; // 0x80b2747
                    int32_t v31 = 0; // 0x80b2759
                    while (true) {
                        // 0x80b275c
                        result = 0;
                        if (v30 <= v31) {
                            return result;
                        }
                        int32_t v32 = *(int32_t *)(v2 + 260); // 0x80b2780
                        PlowsPolygon(Data, 512, ptr1, (char *)(v32 + 104 * v31), call_back);
                        int32_t v33 = *v29; // 0x80b27a0
                        while (v33 != v30) {
                            // 0x80b2768
                            result = 0;
                            if (v33 <= v31) {
                                return result;
                            }
                            // 0x80b2779
                            v32 = *(int32_t *)(v2 + 260);
                            PlowsPolygon(Data, 512, ptr1, (char *)(v32 + 104 * v31), call_back);
                            v33 = *v29;
                        }
                        // 0x80b27ab
                        v31++;
                    }
                }
                case 4: {
                    goto lab_0x80b2610;
                }
                case 1: {
                    goto lab_0x80b2516;
                }
                default: {
                    return result;
                }
            }
        }
    }
  lab_0x80b2610:
    // 0x80b2610
    if ((*(char *)(v1 + 20) & 32) == 0) {
        // 0x80b25ff
        return 0;
    }
    uint32_t v34 = GetLayerNumber(v3, v2); // 0x80b261d
    if (v34 >= *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
        // 0x80b25ff
        return 0;
    }
    int32_t * v35 = (int32_t *)(v3 + 72); // 0x80b2646
    if (*(int32_t *)(*v35 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2))) == 0) {
        // 0x80b2880
        return (int32_t)NULL;
    }
    int32_t v36 = 0; // 0x80b24a0
    int32_t (*v37)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *) = NULL;
    int32_t v38 = GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2)); // 0x80b267f
    uint32_t v39 = *(int32_t *)(*v35 + 4 + 4 * (v36 + 1860 + 18 * v38)); // 0x80b269a
    int32_t (*v40)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *) = v37; // 0x80b26a1
    int32_t v41; // 0x80b26cb
    int32_t v42; // 0x80b26d5
    if (v39 < *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
        // 0x80b26a3
        v41 = *(int32_t *)(v3 + 136 + 92 * v39);
        v42 = r_search((int32_t *)v41, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5);
        v40 = (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))(v42 + (int32_t)v37);
    }
    int32_t v43 = v36 + 1; // 0x80b2640
    uint32_t v44 = *(int32_t *)(*v35 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2))); // 0x80b265d
    v36 = v43;
    while (v43 < v44) {
        // 0x80b266a
        v37 = v40;
        v38 = GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2));
        v39 = *(int32_t *)(*v35 + 4 + 4 * (v36 + 1860 + 18 * v38));
        v40 = v37;
        if (v39 < *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
            // 0x80b26a3
            v41 = *(int32_t *)(v3 + 136 + 92 * v39);
            v42 = r_search((int32_t *)v41, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5);
            v40 = (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))(v42 + (int32_t)v37);
        }
        // 0x80b2640
        v43 = v36 + 1;
        v44 = *(int32_t *)(*v35 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2)));
        v36 = v43;
    }
    // 0x80b2880
    return (int32_t)v40;
  lab_0x80b2516:
    if (ptr1 == NULL || type == 256 || ptr1 == ptr2) {
        // 0x80b2890
        if (*(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24) == 0) {
            // 0x80b25ff
            return 0;
        }
        int32_t v45 = v3; // 0x80b24a0
        int32_t v46 = 0; // 0x80b28b6
        int32_t v47 = 0; // 0x80b28ef
        v46++;
        int32_t v48 = *(int32_t *)(v45 + 136); // 0x80b28de
        int32_t v49 = r_search((int32_t *)v48, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5); // 0x80b28ea
        v47 += v49;
        result = v47;
        v45 += 92;
        while (*(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24) > v46) {
            // 0x80b28b0
            v46++;
            v48 = *(int32_t *)(v45 + 136);
            v49 = r_search((int32_t *)v48, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5);
            v47 += v49;
            result = v47;
            v45 += 92;
        }
      lab_0x80b25ff:
        // 0x80b25ff
        return result;
    }
    int32_t * v50 = (int32_t *)(v3 + 72); // 0x80b2546
    if (*(int32_t *)(*v50 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2))) == 0) {
        // 0x80b2880
        return (int32_t)NULL;
    }
    int32_t v51 = 0; // 0x80b24a0
    int32_t (*v52)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *) = NULL;
    int32_t v53 = GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2)); // 0x80b257f
    uint32_t v54 = *(int32_t *)(*v50 + 4 + 4 * (v51 + 1860 + 18 * v53)); // 0x80b259a
    int32_t (*v55)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *) = v52; // 0x80b25a1
    int32_t v56; // 0x80b25cb
    int32_t v57; // 0x80b25d5
    if (v54 < *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
        // 0x80b25a3
        v56 = *(int32_t *)(v3 + 136 + 92 * v54);
        v57 = r_search((int32_t *)v56, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5);
        v55 = (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))(v57 + (int32_t)v52);
    }
    int32_t v58 = v51 + 1; // 0x80b2540
    uint32_t v59 = *(int32_t *)(*v50 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2))); // 0x80b255d
    v51 = v58;
    while (v58 < v59) {
        // 0x80b256a
        v52 = v55;
        v53 = GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2));
        v54 = *(int32_t *)(*v50 + 4 + 4 * (v51 + 1860 + 18 * v53));
        v55 = v52;
        if (v54 < *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24)) {
            // 0x80b25a3
            v56 = *(int32_t *)(v3 + 136 + 92 * v54);
            v57 = r_search((int32_t *)v56, &v4, NULL, (int32_t (*)(int32_t *, char *))0x80b0bd0, (char *)&v5);
            v55 = (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))(v57 + (int32_t)v52);
        }
        // 0x80b2540
        v58 = v51 + 1;
        v59 = *(int32_t *)(*v50 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(v3, v2)));
        v51 = v58;
    }
    // 0x80b2880
    return (int32_t)v55;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b2aa0 - 0x80b2b2f
// Line range:    1054 - 1070
int32_t InitClip(int32_t * Data, int32_t * layer, int32_t * p) {
    // 0x80b2aa0
    if (inhibit != 0) {
        // 0x80b2b00
        return 0;
    }
    int32_t v1 = (int32_t)p;
    int32_t v2 = v1 + 44; // 0x80b2ab3
    int32_t * v3 = (int32_t *)v2; // 0x80b2ab3
    if (*v3 != 0) {
        // 0x80b2aba
        poly_Free((int32_t **)v2);
    }
    // 0x80b2ac5
    *v3 = (int32_t)original_poly(&g279);
    poly_FreeContours((int32_t **)(v1 + 48));
    if (*v3 == 0) {
        // 0x80b2b00
        return 0;
    }
    // 0x80b2ae1
    if ((*(char *)(v1 + 20) & 16) != 0) {
        // 0x80b2b08
        clearPoly(NULL, NULL, &g279, &g279, (int32_t)&g279);
        return 1;
    }
    // 0x80b2ae7
    *(int32_t *)(v1 + 52) = 0;
    return 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b2b30 - 0x80b2b8e
// Line range:    1484 - 1487
void ClearFromPolygon(int32_t * Data, int32_t type, char * ptr1, char * ptr2) {
    // 0x80b2b30
    if (type != 8) {
        // 0x80b2b48
        PlowsPolygon(Data, type, ptr1, ptr2, (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))0x80b4680);
        return;
    }
    int32_t v1 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80b2b7b
    int32_t v2; // 0x80b2b30
    InitClip((int32_t *)v2, (int32_t *)v2, (int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b2b90 - 0x80b2bee
// Line range:    1475 - 1478
void RestoreToPolygon(int32_t * Data, int32_t type, char * ptr1, char * ptr2) {
    // 0x80b2b90
    if (type != 8) {
        // 0x80b2ba8
        PlowsPolygon(Data, type, ptr1, ptr2, (int32_t (*)(int32_t *, int32_t *, int32_t *, int32_t, char *, char *))0x80b23e0);
        return;
    }
    int32_t v1 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80b2bdb
    int32_t v2; // 0x80b2b90
    InitClip((int32_t *)v2, (int32_t *)v2, (int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b4b60 - 0x80b4baa
// Line range:    2160 - 2182
int32_t poly_InclContour(int32_t * p, int32_t * c) {
    if (p == NULL || c == NULL) {
        // 0x80b4b97
        return 0;
    }
    int32_t v1 = (int32_t)c;
    int32_t * v2 = (int32_t *)((int32_t)p + 8);
    int32_t v3 = *v2;
    if ((*(char *)(v1 + 68) & 8) != 0) {
        if (v3 != 0) {
            // 0x80b4b97
            return 0;
        }
        // 0x80b4ba0
        *v2 = v1;
        return 1;
    }
    if (v3 == 0) {
        // 0x80b4b97
        return 0;
    }
    int32_t * v4 = (int32_t *)(v3 + 16); // 0x80b4b7e
    *v4 = v1;
    *(int32_t *)(v1 + 16) = *v4;
    return 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5530 - 0x80b55c9
// Line range:    2042 - 2063
void poly_InclVertex(int32_t * after, int32_t * node) {
    int32_t v1 = (int32_t)node;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80b5547
    *v2 = (int32_t)after;
    *node = *after;
    *after = v1;
    *(int32_t *)(*after + 4) = v1;
    int32_t v3 = *v2; // 0x80b5553
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x80b5556
    if (v4 == v1) {
        // 0x80b55a3
        return;
    }
    int32_t v5 = *(int32_t *)(v4 + 28); // 0x80b555d
    int32_t v6 = *(int32_t *)(v4 + 24); // 0x80b5568
    int3_t v7; // 0x80b5530
    int3_t v8 = v7 - 1; // 0x80b556e
    __frontend_reg_store_fpr(v8, (float80_t)(*(int32_t *)(v1 + 28) - v5));
    int3_t v9 = v7 - 2; // 0x80b5579
    __frontend_reg_store_fpr(v9, (float80_t)(*(int32_t *)(v1 + 24) - v6));
    int3_t v10 = v7 - 3; // 0x80b5584
    __frontend_reg_store_fpr(v10, (float80_t)(*(int32_t *)(v3 + 24) - v6));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v8));
    __frontend_reg_store_fpr(v10, (float80_t)(*(int32_t *)(v3 + 28) - v5));
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) - __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v8, fabsl(__frontend_reg_load_fpr(v8)));
    __frontend_reg_store_fpr(v9, 1.0e-8L);
    float80_t v11 = __frontend_reg_load_fpr(v9); // 0x80b559d
    float80_t v12 = __frontend_reg_load_fpr(v8); // 0x80b559d
    bool v13 = false; // 0x80b559d
    bool v14 = false; // 0x80b559d
    if (v11 <= v12) {
        v13 = false;
        v14 = true;
        if (v11 >= v12) {
            v13 = true;
            v14 = v11 != v12;
        }
    }
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8));
    if (v13 || v14) {
        // 0x80b55a3
        return;
    }
    // 0x80b55b0
    *(int32_t *)v4 = v1;
    *v2 = v4;
    free((int32_t *)v3);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b55d0 - 0x80b5606
// Line range:    2029 - 2039
void poly_ExclVertex(int32_t * node) {
    int32_t v1 = (int32_t)node;
    int32_t v2 = *(int32_t *)(v1 + 20); // 0x80b55da
    if (v2 != 0) {
        // 0x80b55e1
        free((int32_t *)v2);
        free((int32_t *)*(int32_t *)(v1 + 16));
    }
    int32_t v3 = *(int32_t *)(v1 + 4); // 0x80b55f4
    *(int32_t *)v3 = *node;
    *(int32_t *)(*node + 4) = v3;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5670 - 0x80b5694
// Line range:    2308 - 2315
int32_t * poly_Create(void) {
    int32_t * mem = malloc(12); // 0x80b567d
    if (mem != NULL) {
        int32_t v1 = (int32_t)mem; // 0x80b567d
        *(int32_t *)(v1 + 4) = v1;
        *mem = v1;
        *(int32_t *)(v1 + 8) = 0;
    }
    // 0x80b5692
    return mem;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5bf0 - 0x80b5c60
// Line range:    2005 - 2026
void poly_InvContour(int32_t * c) {
    int32_t v1 = (int32_t)c;
    int32_t v2 = v1 + 20; // 0x80b5bfb
    int32_t * v3 = (int32_t *)v2; // 0x80b5c00
    int32_t v4 = *v3; // 0x80b5c00
    int32_t * v5 = (int32_t *)(v2 + 4); // 0x80b5c02
    *v3 = *v5;
    *v5 = v4;
    while (v2 != v4) {
        int32_t v6 = v4;
        v3 = (int32_t *)v6;
        v4 = *v3;
        v5 = (int32_t *)(v6 + 4);
        *v3 = *v5;
        *v5 = v4;
    }
    char * v7 = (char *)(v1 + 68); // 0x80b5c10
    int32_t v8 = *(int32_t *)(v1 + 64); // 0x80b5c27
    *v7 = *v7 ^ 8;
    if (v8 != 0) {
        // 0x80b5c31
        r_search((int32_t *)v8, NULL, NULL, (int32_t (*)(int32_t *, char *))0x80b4b00, NULL);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5d80 - 0x80b5dec
// Line range:    1878 - 1895
int32_t * poly_NewContour(int32_t * v) {
    int32_t * mem = calloc(1, 72); // 0x80b5d99
    if (mem == NULL) {
        // 0x80b5de6
        return mem;
    }
    int32_t v1 = (int32_t)mem; // 0x80b5d99
    int32_t v2 = v1 + 20; // 0x80b5da2
    *(int32_t *)(v1 + 24) = v2;
    *(int32_t *)v2 = v2;
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x80b5dad
    *v3 = 0x7fffffff;
    *mem = 0x7fffffff;
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x80b5dba
    *v4 = -0x80000000;
    int32_t * v5 = (int32_t *)(v1 + 8); // 0x80b5dc1
    *v5 = -0x80000000;
    if (v != NULL) {
        int32_t v6 = *v; // 0x80b5dca
        *(int32_t *)(v1 + 44) = v6;
        int32_t v7 = *(int32_t *)((int32_t)v + 4); // 0x80b5dcf
        *mem = v6;
        *v5 = v6 + 1;
        *(int32_t *)(v1 + 48) = v7;
        *v3 = v7;
        *v4 = v7 + 1;
    }
    // 0x80b5de6
    return mem;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5df0 - 0x80b5e23
// Line range:    1850 - 1864
int32_t * poly_CreateNode(int32_t * v) {
    int32_t * mem = calloc(1, 32); // 0x80b5e09
    if (mem != NULL) {
        int32_t v1 = (int32_t)mem; // 0x80b5e09
        *(int32_t *)(v1 + 24) = *v;
        *(int32_t *)(v1 + 28) = *(int32_t *)((int32_t)v + 4);
    }
    // 0x80b5e1d
    return mem;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5ec0 - 0x80b5f7a
// Line range:    665 - 700
char * make_edge_tree(int32_t * pb) {
    int32_t * v1 = r_create_tree(NULL, 0, 0); // 0x80b5ee2
    int32_t v2; // 0x80b5ec0
    int32_t v3 = v2 + 20; // 0x80b5ee9
    int32_t v4 = v3; // 0x80b5ef1
    int32_t * v5; // 0x80b5ec0
    int32_t * v6; // 0x80b5ec0
    int32_t v7; // 0x80b5ec0
    int32_t v8; // 0x80b5ec0
    int32_t v9; // 0x80b5ec0
    int32_t * mem; // 0x80b5f3f
    int32_t v10; // 0x80b5f3f
    int32_t * v11; // 0x80b5f44
    while (true) {
      lab_0x80b5f38:
        // 0x80b5f38
        v7 = v4;
        mem = malloc(24);
        v10 = (int32_t)mem;
        v11 = (int32_t *)v7;
        int32_t v12 = *v11; // 0x80b5f44
        int32_t v13 = *(int32_t *)(v7 + 24); // 0x80b5f46
        int32_t * v14 = (int32_t *)(v12 + 24); // 0x80b5f49
        if (v13 < *v14) {
            // 0x80b5ef8
            *mem = v13;
            *(int32_t *)(v10 + 8) = *v14 + 1;
            int32_t v15 = *(int32_t *)(v7 + 28); // 0x80b5f03
            int32_t * v16 = (int32_t *)(v12 + 28);
            v5 = v16;
            v8 = v15;
            v6 = v16;
            v9 = v15;
            if (v15 < *v16) {
                goto lab_0x80b5f0b;
            } else {
                goto lab_0x80b5f61;
            }
        } else {
            // 0x80b5f4e
            *(int32_t *)(v10 + 8) = v13 + 1;
            *mem = *v14;
            int32_t v17 = *(int32_t *)(v7 + 28); // 0x80b5f59
            int32_t * v18 = (int32_t *)(v12 + 28);
            v5 = v18;
            v8 = v17;
            v6 = v18;
            v9 = v17;
            if (v17 < *v18) {
                goto lab_0x80b5f0b;
            } else {
                goto lab_0x80b5f61;
            }
        }
    }
  lab_0x80b5f70:
    // 0x80b5f70
    return (char *)v1;
  lab_0x80b5f0b:
    // 0x80b5f0b
    *(int32_t *)(v10 + 4) = v8;
    *(int32_t *)(v10 + 12) = *v5 + 1;
    goto lab_0x80b5f17;
  lab_0x80b5f61:
    // 0x80b5f61
    *(int32_t *)(v10 + 12) = v9 + 1;
    *(int32_t *)(v10 + 4) = *v6;
    goto lab_0x80b5f17;
  lab_0x80b5f17:
    // 0x80b5f17
    *(int32_t *)(v10 + 16) = v7;
    r_insert_entry(v1, mem, 1);
    v4 = *v11;
    if (v3 == v4) {
        // break -> 0x80b5f70
        goto lab_0x80b5f70;
    }
    goto lab_0x80b5f38;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b6190 - 0x80b632e
// Line range:    1943 - 1977
void poly_PreContour(int32_t * C, int32_t optimize) {
    int32_t v1 = (int32_t)C;
    int32_t v2 = v1 + 20; // 0x80b619f
    int3_t v3; // 0x80b6190
    if (optimize != 0) {
        int32_t v4 = *(int32_t *)v2; // 0x80b61ad
        if (v2 != v4) {
            int3_t v5 = v3 - 1; // 0x80b61ba
            __frontend_reg_store_fpr(v5, 0.0L);
            int3_t v6 = v3 - 2; // 0x80b61e4
            int3_t v7 = v3 - 3;
            int3_t v8 = v3 ^ -4;
            int32_t v9 = v4; // 0x80b61bf
            int32_t v10 = v2; // 0x80b61bf
            while (true) {
                int32_t v11 = v10;
                int32_t v12 = v9;
                int32_t v13 = *(int32_t *)(v12 + 24); // 0x80b61d1
                int32_t * v14 = (int32_t *)v12; // 0x80b61d4
                int32_t v15 = *v14; // 0x80b61d4
                int32_t v16 = *(int32_t *)(v12 + 28); // 0x80b61d6
                __frontend_reg_store_fpr(v6, (float80_t)(v13 - *(int32_t *)(v11 + 24)));
                __frontend_reg_store_fpr(v7, (float80_t)(*(int32_t *)(v15 + 28) - v16));
                __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v7) * __frontend_reg_load_fpr(v6));
                __frontend_reg_store_fpr(v7, (float80_t)(*(int32_t *)(v15 + 24) - v13));
                __frontend_reg_store_fpr(v8, (float80_t)(v16 - *(int32_t *)(v11 + 28)));
                __frontend_reg_store_fpr(v7, __frontend_reg_load_fpr(v8) * __frontend_reg_load_fpr(v7));
                __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) - __frontend_reg_load_fpr(v7));
                int32_t v17; // 0x80b6190
                int32_t v18; // 0x80b6190
                if (__frontend_reg_load_fpr(v6) != __frontend_reg_load_fpr(v5)) {
                    // 0x80b61c8
                    v17 = v15;
                    v18 = v12;
                    if (v2 == v15) {
                        // break -> 0x80b6238
                        break;
                    }
                } else {
                    float80_t v19 = __frontend_reg_load_fpr(v5); // 0x80b620f
                    poly_ExclVertex(v14);
                    free(v14);
                    int32_t v20 = *(int32_t *)v11; // 0x80b6224
                    __frontend_reg_store_fpr(v5, v19);
                    v17 = v20;
                    v18 = v11;
                    if (v2 == v20) {
                        // 0x80b6230
                        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
                        goto lab_0x80b623d;
                    }
                }
                // 0x80b61cf
                v9 = v17;
                v10 = v18;
            }
            // 0x80b6238
            __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
        }
    }
    goto lab_0x80b623d;
  lab_0x80b623d:;
    int32_t v21 = *(int32_t *)(v1 + 44); // 0x80b623d
    int32_t v22 = *(int32_t *)(v1 + 48); // 0x80b6240
    int32_t v23 = *(int32_t *)(v1 + 24); // 0x80b6243
    int32_t * v24 = (int32_t *)(v1 + 52); // 0x80b6249
    *v24 = 0;
    int32_t * v25 = (int32_t *)(v1 + 8); // 0x80b6250
    *v25 = v21;
    *C = v21;
    int32_t * v26 = (int32_t *)(v1 + 12); // 0x80b6255
    *v26 = v22;
    int32_t * v27 = (int32_t *)(v1 + 4); // 0x80b6258
    *v27 = v22;
    int3_t v28 = v3 - 1;
    __frontend_reg_store_fpr(v28, 0.0L);
    char v29 = 0; // 0x80b625e
    if (v2 != v23) {
        int3_t v30 = v3 - 2; // 0x80b6292
        int3_t v31 = v3 - 3;
        int32_t v32 = v21;
        int32_t v33 = v22;
        int32_t v34 = v21;
        int32_t v35 = v22;
        int32_t * v36 = (int32_t *)(v2 + 24); // 0x80b627a
        int32_t v37 = *v36; // 0x80b627a
        int32_t * v38 = (int32_t *)(v2 + 28); // 0x80b628f
        __frontend_reg_store_fpr(v30, (float80_t)(*(int32_t *)(v23 + 24) - v37));
        int32_t v39 = v34 - v37; // 0x80b62a1
        int32_t v40 = v39 == 0 | v39 < 0 != ((v39 ^ v34) & (v37 ^ v34)) < 0 ? v34 : v37; // 0x80b62a4
        __frontend_reg_store_fpr(v31, (float80_t)(*(int32_t *)(v23 + 28) + *v38));
        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v31) * __frontend_reg_load_fpr(v30));
        *C = v40;
        __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v28));
        int32_t v41 = *v36 + 1; // 0x80b62b7
        int32_t v42 = v41 - v32; // 0x80b62ba
        int32_t v43 = v42 < 0 == ((v42 ^ v41) & (v41 ^ v32)) < 0 ? v41 : v32; // 0x80b62bc
        *v25 = v43;
        int32_t v44 = *v38; // 0x80b62c2
        int32_t v45 = v44 - v33; // 0x80b62c2
        int32_t v46 = v45 == 0 | v45 < 0 != ((v45 ^ v44) & (v44 ^ v33)) < 0 ? v44 : v33; // 0x80b62c5
        *v27 = v46;
        int32_t v47 = *v38 + 1; // 0x80b62cf
        int32_t v48 = v47 - v35; // 0x80b62d2
        int32_t v49 = v48 < 0 == ((v48 ^ v47) & (v47 ^ v35)) < 0 ? v47 : v35; // 0x80b62d5
        *v24 = *v24 + 1;
        *v26 = v49;
        int32_t v50 = *(int32_t *)v2; // 0x80b62e3
        int32_t v51 = v2; // 0x80b62e8
        while (v2 != v50) {
            // 0x80b627a
            v32 = v43;
            v33 = v46;
            int32_t v52 = v50;
            v34 = v40;
            v35 = v49;
            v36 = (int32_t *)(v52 + 24);
            v37 = *v36;
            int32_t v53 = *(int32_t *)(v51 + 24); // 0x80b6283
            v38 = (int32_t *)(v52 + 28);
            __frontend_reg_store_fpr(v30, (float80_t)(v53 - v37));
            int32_t v54 = *(int32_t *)(v51 + 28); // 0x80b6298
            v39 = v34 - v37;
            v40 = v39 == 0 | v39 < 0 != ((v39 ^ v34) & (v37 ^ v34)) < 0 ? v34 : v37;
            __frontend_reg_store_fpr(v31, (float80_t)(v54 + *v38));
            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v31) * __frontend_reg_load_fpr(v30));
            *C = v40;
            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v28));
            v41 = *v36 + 1;
            v42 = v41 - v32;
            v43 = v42 < 0 == ((v42 ^ v41) & (v41 ^ v32)) < 0 ? v41 : v32;
            *v25 = v43;
            v44 = *v38;
            v45 = v44 - v33;
            v46 = v45 == 0 | v45 < 0 != ((v45 ^ v44) & (v44 ^ v33)) < 0 ? v44 : v33;
            *v27 = v46;
            v47 = *v38 + 1;
            v48 = v47 - v35;
            v49 = v48 < 0 == ((v48 ^ v47) & (v47 ^ v35)) < 0 ? v47 : v35;
            *v24 = *v24 + 1;
            *v26 = v49;
            v50 = *(int32_t *)v52;
            v51 = v52;
        }
        // 0x80b62ea
        __frontend_reg_store_fpr(v30, 0.0L);
        float80_t v55 = __frontend_reg_load_fpr(v30); // 0x80b62ec
        v29 = 0;
        if (v55 > __frontend_reg_load_fpr(v28)) {
            // 0x80b62f3
            __frontend_reg_store_fpr(v28, -__frontend_reg_load_fpr(v28));
            v29 = 8;
        }
    }
    // 0x80b62f5
    *(float64_t *)(v1 + 56) = (float64_t)__frontend_reg_load_fpr(v28);
    if (*v24 >= 3) {
        char * v56 = (char *)(v1 + 68); // 0x80b6308
        *v56 = (*v56 & -9 | v29) ^ 8;
    }
    // 0x80b6314
    *(int32_t *)(v1 + 64) = (int32_t)make_edge_tree(&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b6330 - 0x80b63cb
// Line range:    1912 - 1940
void poly_DelContour(int32_t ** c) {
    int32_t * v1 = *c; // 0x80b633c
    if (v1 == NULL) {
        // 0x80b63c3
        return;
    }
    int32_t v2 = (int32_t)v1; // 0x80b633c
    int32_t v3 = *(int32_t *)(v2 + 24); // 0x80b6346
    int32_t v4 = v2; // 0x80b634e
    if (v2 + 20 != v3) {
        int32_t v5 = *(int32_t *)(v3 + 20); // 0x80b6350
        int32_t v6 = *(int32_t *)(v3 + 4); // 0x80b6353
        if (v5 != 0) {
            // 0x80b635a
            free((int32_t *)v5);
            free((int32_t *)*(int32_t *)(v3 + 16));
        }
        // 0x80b636d
        free((int32_t *)v3);
        int32_t v7 = (int32_t)*c;
        v4 = v7;
        while (v7 + 20 != v6) {
            int32_t v8 = v6;
            v5 = *(int32_t *)(v8 + 20);
            v6 = *(int32_t *)(v8 + 4);
            if (v5 != 0) {
                // 0x80b635a
                free((int32_t *)v5);
                free((int32_t *)*(int32_t *)(v8 + 16));
            }
            // 0x80b636d
            free((int32_t *)v8);
            v7 = (int32_t)*c;
            v4 = v7;
        }
    }
    int32_t v9 = *(int32_t *)(v4 + 40); // 0x80b6380
    int32_t v10 = v4; // 0x80b6385
    if (v9 != 0) {
        // 0x80b6387
        free((int32_t *)v9);
        free((int32_t *)*(int32_t *)((int32_t)*c + 36));
        v10 = (int32_t)*c;
    }
    int32_t v11 = *(int32_t *)(v10 + 64); // 0x80b639e
    int32_t v12; // 0x80b6330
    if (v11 == 0) {
        // 0x80b639e
        v12 = v10;
    } else {
        int32_t v13 = v11; // bp-32, 0x80b63ab
        r_destroy_tree((int32_t **)&v13);
        v12 = (int32_t)*c;
    }
    // 0x80b63b5
    free((int32_t *)v12);
    *(int32_t *)c = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b63d0 - 0x80b6405
// Line range:    2318 - 2327
void poly_FreeContours(int32_t ** pline) {
    int32_t * v1 = *pline; // 0x80b63db
    int32_t v2 = (int32_t)v1; // 0x80b63db
    int32_t v3 = v2; // bp-16, 0x80b63df
    if (v1 == NULL) {
        // 0x80b63fe
        return;
    }
    // 0x80b63e8
    *(int32_t *)pline = *(int32_t *)(v2 + 16);
    poly_DelContour((int32_t **)&v3);
    int32_t * v4 = *pline;
    int32_t v5 = (int32_t)v4;
    v3 = v5;
    while (v4 != NULL) {
        // 0x80b63e8
        *(int32_t *)pline = *(int32_t *)(v5 + 16);
        poly_DelContour((int32_t **)&v3);
        v4 = *pline;
        v5 = (int32_t)v4;
        v3 = v5;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b6410 - 0x80b647c
// Line range:    2330 - 2345
void poly_Free(int32_t ** p) {
    int32_t * v1 = *p; // 0x80b641b
    if (v1 == NULL) {
        // 0x80b6475
        return;
    }
    int32_t v2 = *v1; // 0x80b6421
    int32_t v3 = v2; // 0x80b6425
    if (v2 != (int32_t)v1) {
        poly_FreeContours((int32_t **)(v2 + 8));
        int32_t * v4 = (int32_t *)v2; // 0x80b643d
        int32_t v5 = *v4; // 0x80b643d
        int32_t * v6 = (int32_t *)(v2 + 4); // 0x80b643f
        *(int32_t *)(v5 + 4) = *v6;
        *(int32_t *)*v6 = v5;
        free(v4);
        int32_t * v7 = *p;
        int32_t v8 = (int32_t)v7;
        int32_t v9 = *v7; // 0x80b6454
        v3 = v8;
        while (v9 != v8) {
            // 0x80b6432
            poly_FreeContours((int32_t **)(v9 + 8));
            v4 = (int32_t *)v9;
            v5 = *v4;
            v6 = (int32_t *)(v9 + 4);
            *(int32_t *)(v5 + 4) = *v6;
            *(int32_t *)*v6 = v5;
            free(v4);
            v7 = *p;
            v8 = (int32_t)v7;
            v9 = *v7;
            v3 = v8;
        }
    }
    // 0x80b645a
    poly_FreeContours((int32_t **)(v3 + 8));
    free(*p);
    *(int32_t *)p = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/puller.c
// Address range: 0x80bda50 - 0x80bda6c
// Line range:    2749 - 2749
void register_puller_action_list(void) {
    // 0x80bda50
    hid_register_actions(&puller_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/remove.c
// Address range: 0x80c0d90 - 0x80c0dab
// Line range:    610 - 614
char * DestroyObject(int32_t * Target, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3) {
    // 0x80c0d90
    *(int32_t *)&DestroyTarget = (int32_t)Target;
    char * result = ObjectOperation(&DestroyFunctions, (int32_t)&g279, (char *)&g279, (char *)&g279, (char *)&g279); // 0x80c0da6
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/remove.c
// Address range: 0x80c1de0 - 0x80c1e0b
// Line range:    118 - 122
void RemovePCB(int32_t * Ptr) {
    // 0x80c1de0
    ClearUndoList(1);
    FreePCBMemory(Ptr);
    SaveFree((char *)Ptr);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/report.c
// Address range: 0x80c45d0 - 0x80c45ec
// Line range:    837 - 837
void register_report_action_list(void) {
    // 0x80c45d0
    hid_register_actions(&report_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rotate.c
// Address range: 0x80c6110 - 0x80c6239
// Line range:    350 - 356
void RotateBoxLowLevel(int32_t * Box, int32_t X, int32_t Y, unsigned char Number) {
    int32_t v1 = (int32_t)Box;
    int32_t v2 = *Box; // 0x80c6122
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x80c6124
    int32_t v4 = *v3; // 0x80c6124
    int32_t * v5 = (int32_t *)(v1 + 8); // 0x80c6127
    int32_t v6 = *v5; // 0x80c6127
    int32_t * v7 = (int32_t *)(v1 + 12); // 0x80c612a
    int32_t v8 = *v7; // 0x80c612a
    int32_t v9 = v2 - X; // 0x80c612f
    int32_t v10 = v4 - Y; // 0x80c6137
    int32_t v11 = v4; // 0x80c6110
    int32_t v12 = v8; // 0x80c6110
    int32_t v13 = v6; // 0x80c6110
    int32_t v14 = v2; // 0x80c6110
    switch (Number % 4) {
        case 2: {
            // 0x80c61e8
            v11 = Y - v10;
            v12 = 2 * Y - v8;
            v13 = 2 * X - v6;
            v14 = X - v9;
            // break -> 0x80c61b4
            break;
        }
        case 3: {
            // 0x80c6210
            v11 = v9 + Y;
            v12 = Y - X + v6;
            v13 = Y + X - v8;
            v14 = X - v10;
            // break -> 0x80c61b4
            break;
        }
        case 1: {
            // 0x80c61a8
            v11 = Y - v9;
            v12 = Y + X - v6;
            v13 = X - Y + v8;
            v14 = v10 + X;
            // break -> 0x80c61b4
            break;
        }
    }
    int32_t v15 = v14;
    int32_t v16 = v13;
    int32_t v17 = v12;
    int32_t v18 = v11;
    int32_t v19 = v15 - v16; // 0x80c61b4
    int32_t v20 = v19 == 0 | v19 < 0 != ((v19 ^ v15) & (v15 ^ v16)) < 0 ? v15 : v16; // 0x80c61b8
    int32_t v21 = v18 - v17; // 0x80c61bb
    *Box = v20;
    int32_t v22 = v21 == 0 | v21 < 0 != ((v21 ^ v18) & (v17 ^ v18)) < 0 ? v18 : v17; // 0x80c61c1
    int32_t v23 = v19 < 0 == ((v19 ^ v15) & (v15 ^ v16)) < 0 ? v15 : v16; // 0x80c61c6
    int32_t v24 = v21 < 0 == ((v21 ^ v18) & (v17 ^ v18)) < 0 ? v18 : v17; // 0x80c61cb
    *v3 = v22;
    *v5 = v23;
    *v7 = v24;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rotate.c
// Address range: 0x80c64c0 - 0x80c6630
// Line range:    108 - 112
void RotateLineLowLevel(int32_t * Line, int32_t X, int32_t Y, unsigned char Number) {
    int32_t v1 = (int32_t)Line;
    int32_t * v2 = (int32_t *)(v1 + 48); // 0x80c64d8
    int32_t v3 = *v2; // 0x80c64d8
    int32_t * v4 = (int32_t *)(v1 + 44); // 0x80c64db
    int32_t v5 = *v4; // 0x80c64db
    int32_t v6 = v3 - Y; // 0x80c64e1
    int32_t v7 = v5 - X; // 0x80c64ec
    int32_t v8; // 0x80c64c0
    int32_t v9; // 0x80c64c0
    int32_t v10; // 0x80c64c0
    int32_t v11; // 0x80c64c0
    int32_t v12; // 0x80c64c0
    int32_t v13; // 0x80c64c0
    int32_t v14; // 0x80c64c0
    int32_t v15; // 0x80c64c0
    int32_t v16; // 0x80c64c0
    int32_t v17; // 0x80c64c0
    switch (Number % 4) {
        case 2: {
            int32_t * v18 = (int32_t *)(v1 + 64); // 0x80c6598
            int32_t v19 = X - v7; // 0x80c659d
            int32_t v20 = Y - v6; // 0x80c65a1
            *v4 = v19;
            int32_t * v21 = (int32_t *)(v1 + 68); // 0x80c65ac
            *v2 = v20;
            int32_t v22 = X - *v18 + X; // 0x80c65ba
            int32_t v23 = Y - *v21 + Y; // 0x80c65bd
            *v18 = v22;
            *v21 = v23;
            v16 = v20;
            v11 = v22;
            v13 = v23;
            v9 = v19;
            v17 = v20;
            v14 = v23;
            if (v19 != v22) {
                goto lab_0x80c657b;
            } else {
                goto lab_0x80c65d1;
            }
        }
        case 3: {
            int32_t * v24 = (int32_t *)(v1 + 64); // 0x80c65f8
            int32_t v25 = X - v6; // 0x80c65fd
            int32_t v26 = v7 + Y; // 0x80c6600
            *v2 = v26;
            int32_t * v27 = (int32_t *)(v1 + 68); // 0x80c660b
            *v4 = v25;
            int32_t v28 = Y - *v27 + X; // 0x80c6619
            int32_t v29 = *v24 - X + Y; // 0x80c661c
            *v24 = v28;
            *v27 = v29;
            v15 = v26;
            v10 = v28;
            v12 = v29;
            v8 = v25;
            goto lab_0x80c6576;
        }
        case 1: {
            int32_t v30 = Y - v7; // 0x80c6545
            *v2 = v30;
            int32_t * v31 = (int32_t *)(v1 + 64);
            int32_t v32 = v6 + X; // 0x80c654f
            *v4 = v32;
            int32_t * v33 = (int32_t *)(v1 + 68);
            int32_t v34 = *v33 - Y + X; // 0x80c6564
            int32_t v35 = X - *v31 + Y; // 0x80c6567
            *v31 = v34;
            *v33 = v35;
            v15 = v30;
            v10 = v34;
            v12 = v35;
            v8 = v32;
            goto lab_0x80c6576;
        }
        default: {
            // 0x80c6508
            v15 = v3;
            v10 = *(int32_t *)(v1 + 64);
            v12 = *(int32_t *)(v1 + 68);
            v8 = v5;
            goto lab_0x80c6576;
        }
    }
  lab_0x80c6576:
    // 0x80c6576
    v16 = v15;
    v11 = v10;
    v13 = v12;
    v9 = v8;
    v17 = v15;
    v14 = v12;
    if (v8 == v10) {
        goto lab_0x80c65d1;
    } else {
        goto lab_0x80c657b;
    }
  lab_0x80c657b:
    // 0x80c657b
    if (v16 == v13 == v9 > v11) {
        // 0x80c65ed
        *(int32_t *)(v1 + 64) = v9;
        *v4 = v11;
    }
    // 0x80c6583
    SetLineBoundingBox((int32_t *)v16);
  lab_0x80c65d1:
    // 0x80c65d1
    if (v17 > v14) {
        // 0x80c65d9
        *v2 = v14;
        *(int32_t *)(v1 + 68) = v17;
    }
    // 0x80c6583
    SetLineBoundingBox((int32_t *)v17);
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7130 - 0x80c71f1
// Line range:    406 - 438
void adjust_bounds(int32_t * node) {
    // 0x80c7130
    int32_t v1; // 0x80c7130
    if (*(char *)(v1 + 20) % 2 == 0) {
        int32_t v2 = v1 + 24; // 0x80c7198
        int32_t v3 = *(int32_t *)v2; // 0x80c7198
        int32_t * v4 = (int32_t *)v1; // 0x80c71a0
        *v4 = *(int32_t *)v3;
        int32_t * v5 = (int32_t *)(v1 + 4); // 0x80c71a5
        *v5 = *(int32_t *)(v3 + 4);
        int32_t * v6 = (int32_t *)(v1 + 8); // 0x80c71ab
        *v6 = *(int32_t *)(v3 + 8);
        int32_t * v7 = (int32_t *)(v1 + 12); // 0x80c71b3
        *v7 = *(int32_t *)(v3 + 12);
        int32_t v8; // 0x80c7130
        int32_t v9 = *(int32_t *)(v8 + 28); // 0x80c71b6
        while (v9 != 0) {
            int32_t v10 = *(int32_t *)v9; // 0x80c71bd
            if (v10 < v1) {
                // 0x80c71c3
                *v4 = v10;
            }
            int32_t v11 = *(int32_t *)(v9 + 8); // 0x80c71c5
            if (v11 > *v6) {
                // 0x80c71cd
                *v6 = v11;
            }
            int32_t v12 = *(int32_t *)(v9 + 4); // 0x80c71d0
            if (v12 < *v5) {
                // 0x80c71d8
                *v5 = v12;
            }
            int32_t v13 = *(int32_t *)(v9 + 12); // 0x80c71db
            if (v13 > *v7) {
                // 0x80c71e3
                *v7 = v13;
            }
            int32_t v14 = v8 + 4; // 0x80c71e6
            v8 = v14;
            if (v14 == v2) {
                // break -> 0x80c718f
                break;
            }
            v9 = *(int32_t *)(v8 + 28);
        }
    } else {
        int32_t * v15 = (int32_t *)v1; // 0x80c7141
        *v15 = *(int32_t *)(v1 + 28);
        int32_t * v16 = (int32_t *)(v1 + 4); // 0x80c7146
        *v16 = *(int32_t *)(v1 + 32);
        int32_t * v17 = (int32_t *)(v1 + 8); // 0x80c714c
        *v17 = *(int32_t *)(v1 + 36);
        int32_t * v18 = (int32_t *)(v1 + 12); // 0x80c7152
        *v18 = *(int32_t *)(v1 + 40);
        int32_t v19; // 0x80c7130
        int32_t v20 = v19;
        while (*(int32_t *)(v20 + 44) != 0) {
            int32_t v21 = *(int32_t *)(v20 + 48); // 0x80c715e
            if (v21 < v1) {
                // 0x80c7165
                *v15 = v21;
            }
            int32_t v22 = *(int32_t *)(v20 + 56); // 0x80c7167
            if (v22 > *v17) {
                // 0x80c716f
                *v17 = v22;
            }
            int32_t v23 = *(int32_t *)(v20 + 52); // 0x80c7172
            if (v23 < *v16) {
                // 0x80c717a
                *v16 = v23;
            }
            int32_t v24 = *(int32_t *)(v20 + 60); // 0x80c717d
            if (v24 > *v18) {
                // 0x80c7185
                *v18 = v24;
            }
            // 0x80c7188
            if (v20 == v1 + 100) {
                // break -> 0x80c718f
                break;
            }
            v20 += 20;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7200 - 0x80c73e3
// Line range:    517 - 590
int32_t __r_search(int32_t * node, int32_t * query, int32_t * arg) {
    int32_t v1 = (int32_t)query;
    int32_t v2 = (int32_t)node;
    if (*(char *)(v2 + 20) % 2 != 0) {
        int32_t v3 = *(int32_t *)(v2 + 24);
        if (*(int32_t *)((int32_t)arg + 4) == 0) {
            // 0x80c7318
            if (v3 == 0) {
                // 0x80c726a
                return 0;
            }
            int32_t v4 = 0;
            int32_t v5 = v2;
            int32_t v6 = v4; // 0x80c732b
            int32_t v7; // 0x80c733c
            int32_t v8; // 0x80c733f
            int32_t v9; // 0x80c733f
            if (*(int32_t *)(v5 + 28) < *(int32_t *)(v1 + 8)) {
                // 0x80c732d
                v6 = v4;
                if (*(int32_t *)(v5 + 36) > *query) {
                    // 0x80c7334
                    v6 = v4;
                    if (*(int32_t *)(v5 + 32) < *(int32_t *)(v1 + 12)) {
                        // 0x80c733c
                        v7 = *(int32_t *)(v5 + 40);
                        v8 = *(int32_t *)(v1 + 4);
                        v9 = v7 - v8;
                        v6 = v4 + (int32_t)(v9 < 0 == ((v9 ^ v7) & (v8 ^ v7)) < 0 == (v9 != 0));
                    }
                }
            }
            int32_t result = v6;
            int32_t v10 = v5 + 20; // 0x80c7358
            while (*(int32_t *)(v5 + 44) != 0) {
                // 0x80c7328
                v4 = result;
                v5 = v10;
                v6 = v4;
                if (*(int32_t *)(v5 + 28) < *(int32_t *)(v1 + 8)) {
                    // 0x80c732d
                    v6 = v4;
                    if (*(int32_t *)(v5 + 36) > *query) {
                        // 0x80c7334
                        v6 = v4;
                        if (*(int32_t *)(v5 + 32) < *(int32_t *)(v1 + 12)) {
                            // 0x80c733c
                            v7 = *(int32_t *)(v5 + 40);
                            v8 = *(int32_t *)(v1 + 4);
                            v9 = v7 - v8;
                            v6 = v4 + (int32_t)(v9 < 0 == ((v9 ^ v7) & (v8 ^ v7)) < 0 == (v9 != 0));
                        }
                    }
                }
                // 0x80c7350
                result = v6;
                v10 = v5 + 20;
            }
            // 0x80c726a
            return result;
        }
        // 0x80c7223
        if (v3 == 0) {
            // 0x80c726a
            return 0;
        }
        int32_t v11 = 0;
        int32_t v12 = v11; // 0x80c723e
        if (*(int32_t *)(v2 + 28) < *(int32_t *)(v1 + 8)) {
            // 0x80c7240
            v12 = v11;
            if (*(int32_t *)(v2 + 36) > *query) {
                // 0x80c7247
                v12 = v11;
                if (*(int32_t *)(v2 + 32) < *(int32_t *)(v1 + 12)) {
                    // 0x80c724f
                    v12 = v11;
                    if (*(int32_t *)(v2 + 40) > *(int32_t *)(v1 + 4)) {
                        // 0x80c73a8
                        v12 = v11 + (int32_t)(v3 != 0);
                    }
                }
            }
        }
        int32_t result2 = v12;
        int32_t v13 = *(int32_t *)(v2 + 44); // 0x80c7260
        int32_t v14 = v2 + 20; // 0x80c7268
        while (v13 != 0) {
            int32_t v15 = v14;
            v11 = result2;
            v12 = v11;
            if (*(int32_t *)(v15 + 28) < *(int32_t *)(v1 + 8)) {
                // 0x80c7240
                v12 = v11;
                if (*(int32_t *)(v15 + 36) > *query) {
                    // 0x80c7247
                    v12 = v11;
                    if (*(int32_t *)(v15 + 32) < *(int32_t *)(v1 + 12)) {
                        // 0x80c724f
                        v12 = v11;
                        if (*(int32_t *)(v15 + 40) > *(int32_t *)(v1 + 4)) {
                            // 0x80c73a8
                            v12 = v11 + (int32_t)(v13 != 0);
                        }
                    }
                }
            }
            // 0x80c7260
            result2 = v12;
            v13 = *(int32_t *)(v15 + 44);
            v14 = v15 + 20;
        }
        // 0x80c726a
        return result2;
    }
    int32_t v16 = v2 + 24;
    int32_t v17 = *(int32_t *)v16;
    if (*arg == 0) {
        // 0x80c72d0
        if (v17 == 0) {
            // 0x80c726a
            return 0;
        }
        int32_t v18 = v16; // 0x80c7308
        int32_t v19 = 0;
        int32_t * v20 = (int32_t *)v17; // 0x80c72e0
        int32_t v21 = v19; // 0x80c72e5
        if (*v20 < *(int32_t *)(v1 + 8)) {
            // 0x80c72e7
            v21 = v19;
            if (*(int32_t *)(v17 + 8) > *query) {
                // 0x80c72ee
                v21 = v19;
                if (*(int32_t *)(v17 + 4) < *(int32_t *)(v1 + 12)) {
                    // 0x80c72f6
                    v21 = v19;
                    if (*(int32_t *)(v17 + 12) > *(int32_t *)(v1 + 4)) {
                        // 0x80c73c6
                        v21 = __r_search(v20, query, arg) + v19;
                    }
                }
            }
        }
        int32_t result3 = v21;
        v18 += 4;
        int32_t v22 = *(int32_t *)v18; // 0x80c730b
        while (v22 != 0) {
            // 0x80c72e0
            v19 = result3;
            int32_t v23 = v22;
            v20 = (int32_t *)v23;
            v21 = v19;
            if (*v20 < *(int32_t *)(v1 + 8)) {
                // 0x80c72e7
                v21 = v19;
                if (*(int32_t *)(v23 + 8) > *query) {
                    // 0x80c72ee
                    v21 = v19;
                    if (*(int32_t *)(v23 + 4) < *(int32_t *)(v1 + 12)) {
                        // 0x80c72f6
                        v21 = v19;
                        if (*(int32_t *)(v23 + 12) > *(int32_t *)(v1 + 4)) {
                            // 0x80c73c6
                            v21 = __r_search(v20, query, arg) + v19;
                        }
                    }
                }
            }
            // 0x80c7308
            result3 = v21;
            v18 += 4;
            v22 = *(int32_t *)v18;
        }
        // 0x80c726a
        return result3;
    }
    // 0x80c727e
    if (v17 == 0) {
        // 0x80c726a
        return 0;
    }
    int32_t v24 = v16; // 0x80c72b8
    int32_t v25 = 0;
    int32_t v26 = v17; // 0x80c7382
    int32_t * v27 = (int32_t *)v26;
    int32_t v28 = v25; // 0x80c7295
    if (*v27 < *(int32_t *)(v1 + 8)) {
        // 0x80c7297
        v28 = v25;
        if (*(int32_t *)(v26 + 8) > *query) {
            // 0x80c729e
            v28 = v25;
            if (*(int32_t *)(v26 + 4) < *(int32_t *)(v1 + 12)) {
                // 0x80c72a6
                v28 = v25;
                if (!((v26 == 0 | *(int32_t *)(v26 + 12) <= *(int32_t *)(v1 + 4)))) {
                    // 0x80c737a
                    v28 = __r_search(v27, query, arg) + v25;
                }
            }
        }
    }
    int32_t result4 = v28;
    v24 += 4;
    int32_t v29 = *(int32_t *)v24; // 0x80c72bb
    while (v29 != 0) {
        // 0x80c7290
        v25 = result4;
        v26 = v29;
        v27 = (int32_t *)v26;
        v28 = v25;
        if (*v27 < *(int32_t *)(v1 + 8)) {
            // 0x80c7297
            v28 = v25;
            if (*(int32_t *)(v26 + 8) > *query) {
                // 0x80c729e
                v28 = v25;
                if (*(int32_t *)(v26 + 4) < *(int32_t *)(v1 + 12)) {
                    // 0x80c72a6
                    v28 = v25;
                    if (!((v26 == 0 | *(int32_t *)(v26 + 12) <= *(int32_t *)(v1 + 4)))) {
                        // 0x80c737a
                        v28 = __r_search(v27, query, arg) + v25;
                    }
                }
            }
        }
        // 0x80c72b8
        result4 = v28;
        v24 += 4;
        v29 = *(int32_t *)v24;
    }
    // 0x80c726a
    return result4;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c73f0 - 0x80c7490
// Line range:    603 - 636
int32_t r_search(int32_t * rtree, int32_t * query, int32_t (*check_region)(int32_t *, char *), int32_t (*found_rectangle)(int32_t *, char *), char * cl) {
    // 0x80c73f0
    if (rtree == NULL || *(int32_t *)((int32_t)rtree + 4) < 1) {
        // 0x80c7442
        return 0;
    }
    int32_t v1 = *rtree;
    int32_t (*v2)(int32_t *, char *); // bp-40, 0x80c73f0
    if (query == NULL) {
        // 0x80c7470
        v2 = check_region;
        int32_t * v3 = (int32_t *)v1; // 0x80c7489
        // 0x80c7442
        return __r_search(v3, v3, (int32_t *)&v2);
    }
    int32_t v4 = (int32_t)query;
    int32_t * v5 = (int32_t *)v1; // 0x80c741f
    if (*v5 >= *(int32_t *)(v4 + 8) || *(int32_t *)(v1 + 8) <= *query || *(int32_t *)(v1 + 4) >= *(int32_t *)(v4 + 12)) {
        // 0x80c7442
        return 0;
    }
    int32_t result = 0; // 0x80c743b
    if (*(int32_t *)(v1 + 12) > *(int32_t *)(v4 + 4)) {
        // 0x80c7450
        v2 = check_region;
        result = __r_search(v5, query, (int32_t *)&v2);
    }
    // 0x80c7442
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7600 - 0x80c789b
// Line range:    1042 - 1073
char __r_delete(int32_t * node, int32_t * query) {
    // 0x80c7600
    if (*query < *node) {
        // 0x80c7662
        return 0;
    }
    int32_t v1 = (int32_t)query;
    int32_t v2 = (int32_t)node;
    if (*(int32_t *)(v1 + 4) < *(int32_t *)(v2 + 4) || *(int32_t *)(v2 + 8) < *(int32_t *)(v1 + 8)) {
        // 0x80c7662
        return 0;
    }
    // 0x80c7625
    if (*(int32_t *)(v1 + 12) > *(int32_t *)(v2 + 12)) {
        // 0x80c7662
        return 0;
    }
    int32_t v3 = v2;
    int32_t v4 = v1;
    int32_t v5 = v3 + 20; // 0x80c762d
    char * v6 = (char *)v5;
    int32_t v7 = 0; // 0x80c7631
    int32_t v8 = v3; // 0x80c7631
    int32_t v9 = 1; // 0x80c7631
    int32_t v10 = 0; // 0x80c7631
    char result; // 0x80c7600
    int32_t v11; // 0x80c7600
    while (*v6 % 2 == 0) {
        int32_t v12 = v3 + 24; // 0x80c763c
        int32_t * v13 = (int32_t *)v4;
        int32_t v14 = 0;
        int32_t v15 = 4 * v14; // 0x80c763c
        int32_t * v16 = (int32_t *)(v15 + v12);
        int32_t v17 = *v16; // 0x80c763c
        while (v4 != v17) {
            // 0x80c7644
            if (v17 == 0) {
                // 0x80c7662
                return 0;
            }
            // 0x80c7648
            if (__r_delete((int32_t *)v17, v13) != 0) {
                // 0x80c7662
                return 1;
            }
            // 0x80c7658
            if (v14 == 5) {
                // 0x80c7662
                return 0;
            }
            v14++;
            v15 = 4 * v14;
            v16 = (int32_t *)(v15 + v12);
            v17 = *v16;
        }
        // 0x80c7690
        free(v13);
        if (v14 <= 5) {
            int32_t v18 = v15 + v3;
            int32_t v19 = *(int32_t *)(v18 + 28); // 0x80c769d
            *v16 = v19;
            if (v19 != 0) {
                int32_t v20 = v18 + 32; // 0x80c7600
                int32_t v21 = v14;
                while (v21 < 5) {
                    // 0x80c76c7
                    v21++;
                    int32_t v22 = *(int32_t *)v20; // 0x80c76b8
                    *(int32_t *)(v20 - 4) = v22;
                    v20 += 4;
                    if (v22 == 0) {
                        // break -> 0x80c76cc
                        break;
                    }
                }
            }
        }
        // 0x80c76cc
        v11 = v3;
        if (*(int32_t *)v12 != 0) {
            goto lab_0x80c766d;
        }
        int32_t v23 = *(int32_t *)(v3 + 16); // 0x80c76d3
        if (v23 == 0) {
            // 0x80c785d
            *v6 = *v6 | 1;
            *(int32_t *)(v3 + 44) = 0;
            *(int32_t *)(v3 + 64) = 0;
            *(int32_t *)(v3 + 84) = 0;
            *(int32_t *)(v3 + 104) = 0;
            *(int32_t *)(v3 + 124) = 0;
            *(int32_t *)(v3 + 144) = 0;
            result = 1;
            return result;
        }
        // 0x80c76de
        if (*(int32_t *)v3 < *(int32_t *)v23 || *(int32_t *)(v3 + 4) < *(int32_t *)(v23 + 4) || *(int32_t *)(v3 + 8) > *(int32_t *)(v23 + 8)) {
            // 0x80c7662
            return 0;
        }
        int32_t v24 = v3; // 0x80c770c
        if (*(int32_t *)(v3 + 12) > *(int32_t *)(v23 + 12)) {
            // 0x80c7662
            return 0;
        }
        v3 = v23;
        v4 = v24;
        v5 = v3 + 20;
        v6 = (char *)v5;
        v7 = 0;
        v8 = v3;
        v9 = 1;
        v10 = 0;
    }
    int32_t v25 = *(int32_t *)(v8 + 24); // 0x80c7729
    result = 0;
    int32_t v26; // 0x80c7600
    int32_t v27; // 0x80c7600
    int32_t v28; // 0x80c7600
    int32_t v29; // 0x80c7748
    while (v25 != 0) {
        int32_t v30 = v10;
        v28 = v7;
        v29 = v4;
        v27 = v9;
        v26 = v30;
        if (v4 == v25) {
            goto lab_0x80c7756;
        }
        int32_t v31 = v30 + 1; // 0x80c7738
        int32_t v32 = v9 | v7; // 0x80c773e
        int32_t v33 = 2 * v9; // 0x80c7741
        v7 = v32;
        v8 += 20;
        v9 = v33;
        v10 = v31;
        if (v30 == 5) {
            // 0x80c7748
            v29 = *(int32_t *)(v3 + 144);
            result = 0;
            v28 = v32;
            v27 = v33;
            v26 = v31;
            if (v29 == 0) {
                return result;
            } else {
                goto lab_0x80c7756;
            }
        }
        v25 = *(int32_t *)(v8 + 24);
        result = 0;
    }
  lab_0x80c7662:
    // 0x80c7662
    return result;
  lab_0x80c7756:;
    int32_t v34 = v28;
    int32_t * v35 = (int32_t *)v5; // 0x80c7756
    uint32_t v36 = *v35; // 0x80c7756
    int32_t v37 = v36 / 2; // 0x80c775b
    int32_t v38 = v37; // 0x80c775f
    int32_t v39 = v36; // 0x80c775f
    if ((v37 & v27) != 0) {
        // 0x80c781b
        free((int32_t *)v29);
        *(int32_t *)(v3 + 24 + 20 * v26) = 0;
        uint32_t v40 = *v35; // 0x80c7830
        v38 = v40 / 2;
        v39 = v40;
        goto lab_0x80c7765;
    } else {
        goto lab_0x80c7765;
    }
  lab_0x80c766d:
    // 0x80c766d
    adjust_bounds(&g279);
    int32_t v41 = *(int32_t *)(v11 + 16); // 0x80c7674
    result = 1;
    v11 = v41;
    if (v41 != 0) {
        goto lab_0x80c766d;
    } else {
        return result;
    }
  lab_0x80c7765:;
    int32_t v42 = v38;
    *v35 = 2 * (v42 & v34) | v42 & (2 * v34 ^ 0x7ffffffe) | v39 % 2;
    int32_t v43; // 0x80c7600
    int32_t v44; // 0x80c7600
    if (v26 > 5) {
        goto lab_0x80c77fc;
    } else {
        int32_t v45 = v26 + 1; // 0x80c7784
        int32_t v46 = 20 * v45; // 0x80c778d
        int32_t v47 = v3 + 16 + v46; // 0x80c7790
        int32_t v48 = 20 * v26 + v3; // 0x80c779a
        int32_t * v49 = (int32_t *)(v48 + 24); // 0x80c77a0
        *v49 = *(int32_t *)(v47 + 8);
        *(int32_t *)(v48 + 28) = *(int32_t *)(v47 + 12);
        *(int32_t *)(v48 + 32) = *(int32_t *)(v47 + 16);
        *(int32_t *)(v48 + 36) = *(int32_t *)(v47 + 20);
        *(int32_t *)(v48 + 40) = *(int32_t *)(v47 + 24);
        if (*v49 != 0) {
            // 0x80c77f7
            v43 = v3 + 24 + v46;
            v44 = v45;
            goto lab_0x80c77f7_2;
        } else {
            goto lab_0x80c77fc;
        }
    }
  lab_0x80c77fc:;
    int32_t v50 = v3; // 0x80c7801
    if (*(int32_t *)(v3 + 24) == 0) {
        int32_t v51 = *(int32_t *)(v3 + 16); // 0x80c783c
        result = 1;
        if (v51 == 0) {
            return result;
        } else {
            // 0x80c7847
            __r_delete((int32_t *)v51, (int32_t *)v3);
            result = 1;
            return result;
        }
    } else {
        goto lab_0x80c7808;
    }
  lab_0x80c7808:
    // 0x80c7808
    adjust_bounds(&g279);
    int32_t v52 = *(int32_t *)(v50 + 16); // 0x80c780f
    result = 1;
    v50 = v52;
    if (v52 != 0) {
        goto lab_0x80c7808;
    } else {
        return result;
    }
  lab_0x80c77f7_2:
    // 0x80c77f7
    if (v44 < 6) {
        int32_t v53 = v43;
        int32_t v54 = v53 + 20; // 0x80c77d6
        int32_t v55 = *(int32_t *)v54; // 0x80c77d6
        *(int32_t *)(v53 + 4) = *(int32_t *)(v53 + 24);
        *(int32_t *)v53 = v55;
        *(int32_t *)(v53 + 8) = *(int32_t *)(v53 + 28);
        *(int32_t *)(v53 + 12) = *(int32_t *)(v53 + 32);
        *(int32_t *)(v53 + 16) = *(int32_t *)(v53 + 36);
        v43 = v54;
        v44++;
        if (v55 == 0) {
            goto lab_0x80c77fc;
        } else {
            goto lab_0x80c77f7_2;
        }
    } else {
        goto lab_0x80c77fc;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c78a0 - 0x80c78c9
// Line range:    1149 - 1162
char r_delete_entry(int32_t * rtree, int32_t * box) {
    char result = __r_delete((int32_t *)*rtree, box); // 0x80c78b6
    if (result != 0) {
        int32_t * v1 = (int32_t *)((int32_t)rtree + 4); // 0x80c78bf
        *v1 = *v1 - 1;
    }
    // 0x80c78c3
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c78d0 - 0x80c7958
// Line range:    472 - 482
void __r_destroy_tree(int32_t * node) {
    // 0x80c78d0
    int32_t v1; // 0x80c78d0
    int32_t v2 = v1 + 20; // 0x80c78dd
    int32_t v3 = v1 + 24;
    if (*(char *)v2 % 2 == 0) {
        int32_t v4 = 0;
        while (*(int32_t *)(4 * v4 + v3) != 0) {
            // 0x80c7928
            __r_destroy_tree(&g279);
            if (v4 == 5) {
                // 0x80c7935
                free((int32_t *)v1);
                return;
            }
            v4++;
        }
        // 0x80c7910
        free((int32_t *)v1);
        return;
    }
    int32_t v5 = *(int32_t *)v3; // 0x80c78ea
    if (v5 == 0) {
        // 0x80c7910
        free((int32_t *)v1);
        return;
    }
    int32_t v6 = 1; // 0x80c78d0
    if ((*(int32_t *)v2 / 2 & v6) != 0) {
        // 0x80c7948
        free((int32_t *)v5);
    }
    int32_t v7; // 0x80c78d0
    while (v7 != v1 + 100) {
        int32_t v8 = *(int32_t *)(v7 + 44); // 0x80c7904
        int32_t v9 = v8; // 0x80c790b
        v7 += 20;
        v6 *= 2;
        if (v8 == 0) {
            // break -> 0x80c7910
            break;
        }
        if ((*(int32_t *)v2 / 2 & v6) != 0) {
            // 0x80c7948
            free((int32_t *)v9);
        }
    }
    // 0x80c7910
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7960 - 0x80c7989
// Line range:    497 - 503
void r_destroy_tree(int32_t ** rtree) {
    // 0x80c7960
    int32_t v1; // 0x80c7960
    __r_destroy_tree((int32_t *)v1);
    free(*rtree);
    *(int32_t *)rtree = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7990 - 0x80c8047
// Line range:    671 - 704
int32_t * find_clusters(int32_t * node) {
    int32_t v1 = (int32_t)node;
    float32_t v2; // bp-120, 0x80c7990
    int32_t v3 = &v2; // 0x80c799f
    int3_t v4; // 0x80c7990
    int3_t v5 = v4 - 1; // 0x80c79a2
    __frontend_reg_store_fpr(v5, 0.5L);
    int32_t v6 = v1 + 20; // 0x80c79a8
    char * v7 = (char *)v6; // 0x80c79a8
    int32_t v8 = v1 + 24;
    int3_t v9 = v4 - 2;
    int3_t v10 = v4 - 3;
    int32_t v11 = v3; // 0x80c79b7
    int32_t v12 = 0;
    int32_t v13 = v1 + 28 + 20 * v12; // 0x80c79c9
    if (*v7 % 2 == 0) {
        // 0x80c79cb
        v13 = *(int32_t *)(4 * v12 + v8);
    }
    int32_t v14 = *(int32_t *)v13; // 0x80c79cf
    int32_t v15 = v12 + 1; // 0x80c79d1
    int32_t v16 = *(int32_t *)(v13 + 8); // 0x80c79d4
    __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v16 + v14));
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) * __frontend_reg_load_fpr(v5));
    *(float32_t *)v11 = (float32_t)__frontend_reg_load_fpr(v9);
    int32_t v17 = *(int32_t *)(v13 + 4); // 0x80c79f6
    int32_t v18 = *(int32_t *)(v13 + 12); // 0x80c79f9
    __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v18 + v17));
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) * __frontend_reg_load_fpr(v5));
    *(float32_t *)(v11 + 4) = (float32_t)__frontend_reg_load_fpr(v9);
    __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v16 - v14));
    __frontend_reg_store_fpr(v10, (float80_t)(float32_t)(v18 - v17));
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) + 1.0L);
    *(float32_t *)(v11 + 8) = (float32_t)__frontend_reg_load_fpr(v9);
    v11 += 12;
    while (v15 != 7) {
        // 0x80c79b8
        v12 = v15;
        v13 = v1 + 28 + 20 * v12;
        if (*v7 % 2 == 0) {
            // 0x80c79cb
            v13 = *(int32_t *)(4 * v12 + v8);
        }
        // 0x80c79cf
        v14 = *(int32_t *)v13;
        v15 = v12 + 1;
        v16 = *(int32_t *)(v13 + 8);
        __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v16 + v14));
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) * __frontend_reg_load_fpr(v5));
        *(float32_t *)v11 = (float32_t)__frontend_reg_load_fpr(v9);
        v17 = *(int32_t *)(v13 + 4);
        v18 = *(int32_t *)(v13 + 12);
        __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v18 + v17));
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) * __frontend_reg_load_fpr(v5));
        *(float32_t *)(v11 + 4) = (float32_t)__frontend_reg_load_fpr(v9);
        __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v16 - v14));
        __frontend_reg_store_fpr(v10, (float80_t)(float32_t)(v18 - v17));
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v9));
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) + 1.0L);
        *(float32_t *)(v11 + 8) = (float32_t)__frontend_reg_load_fpr(v9);
        v11 += 12;
    }
    // 0x80c7a41
    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
    __frontend_reg_store_fpr(v5, (float80_t)v2);
    float80_t v19 = __frontend_reg_load_fpr(v5); // 0x80c7a46
    float32_t v20; // 0x80c7990
    __frontend_reg_store_fpr(v5, (float80_t)v20);
    float80_t v21 = __frontend_reg_load_fpr(v5); // 0x80c7a4f
    __frontend_reg_store_fpr(v5, (float80_t)v20);
    float80_t v22 = __frontend_reg_load_fpr(v5); // 0x80c7a58
    __frontend_reg_store_fpr(v9, (float80_t)v20);
    float80_t v23 = __frontend_reg_load_fpr(v9); // 0x80c7a61
    __frontend_reg_store_fpr(v10, v19);
    float80_t v24 = __frontend_reg_load_fpr(v10); // 0x80c7a6d
    __frontend_reg_store_fpr(v10, __frontend_reg_load_fpr(v5));
    __frontend_reg_store_fpr(v5, v24);
    float80_t v25 = __frontend_reg_load_fpr(v10); // 0x80c7a6f
    float80_t v26 = __frontend_reg_load_fpr(v5); // 0x80c7a6f
    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v9));
    float80_t v27; // 0x80c7990
    if (v25 == v26) {
        if (v25 != v26) {
            // 0x80c7a8f
            __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
            // 0x80c7a95
            __frontend_reg_store_fpr(v5, v21);
            v27 = v22;
            goto lab_0x80c7a9b;
        } else {
            // 0x80c7a77
            __frontend_reg_store_fpr(v9, v21);
            float80_t v28 = __frontend_reg_load_fpr(v9); // 0x80c7a7d
            __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v5));
            __frontend_reg_store_fpr(v5, v28);
            float80_t v29 = __frontend_reg_load_fpr(v9); // 0x80c7a7f
            float80_t v30 = __frontend_reg_load_fpr(v5); // 0x80c7a7f
            if (v29 == v30) {
                if (v29 != v30) {
                    // 0x80c7a93
                    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
                    // 0x80c7a95
                    __frontend_reg_store_fpr(v5, v21);
                    v27 = v22;
                    goto lab_0x80c7a9b;
                } else {
                    // 0x80c802c
                    __frontend_reg_store_fpr(v9, 1.0e+4L);
                    __frontend_reg_store_fpr(v10, v22);
                    __frontend_reg_store_fpr(v10, __frontend_reg_load_fpr(v10) + __frontend_reg_load_fpr(v9));
                    float80_t v31 = __frontend_reg_load_fpr(v10); // 0x80c803a
                    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5) - __frontend_reg_load_fpr(v9));
                    v27 = v31;
                    goto lab_0x80c7a9b;
                }
            } else {
                // 0x80c7a87
                __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
                // 0x80c7a95
                __frontend_reg_store_fpr(v5, v21);
                v27 = v22;
                goto lab_0x80c7a9b;
            }
        }
    } else {
        // 0x80c7a8b
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
        // 0x80c7a95
        __frontend_reg_store_fpr(v5, v21);
        v27 = v22;
        goto lab_0x80c7a9b;
    }
  lab_0x80c7b7a:;
    // 0x80c7b7a
    int3_t v32; // 0x80c7ac8
    __frontend_reg_store_fpr(v32, v21);
    int3_t v33; // 0x80c7ad3
    __frontend_reg_store_fpr(v33, v19);
    int3_t v34; // 0x80c7ae1
    __frontend_reg_store_fpr(v34, 0.0L);
    float80_t v35 = __frontend_reg_load_fpr(v34); // 0x80c7b9c
    float80_t v36 = __frontend_reg_load_fpr(v34); // 0x80c7ba2
    float80_t v37 = __frontend_reg_load_fpr(v34); // 0x80c7ba8
    int3_t v38; // 0x80c7990
    __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v34));
    int3_t v39; // 0x80c7990
    __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v34));
    float32_t v40 = v35; // 0x80c7bb2
    float32_t v41 = v37; // 0x80c7bb2
    float32_t v42 = v36; // 0x80c7bb2
    int3_t v43 = v39; // 0x80c7bb2
    int32_t v44 = v3; // 0x80c7bb2
    int32_t v45 = 0; // 0x80c7bb2
    float32_t v46; // 0x80c7990
    float32_t v47; // 0x80c7990
    float32_t v48; // 0x80c7990
    int3_t v49; // 0x80c7990
    int32_t v50; // 0x80c7990
    while (true) {
        int32_t v51 = v45;
        int32_t v52 = v44;
        int3_t v53 = v43;
        float32_t v54 = v42;
        float32_t v55 = v41;
        float32_t v56 = v40;
        int3_t v57 = v53 - 1;
        __frontend_reg_store_fpr(v57, (float80_t)*(float32_t *)(v52 + 8));
        int3_t v58 = v53 + 3;
        __frontend_reg_store_fpr(v58, __frontend_reg_load_fpr(v58) * __frontend_reg_load_fpr(v57));
        float80_t v59 = __frontend_reg_load_fpr(v57);
        __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v58));
        __frontend_reg_store_fpr(v58, v59);
        float80_t v60 = __frontend_reg_load_fpr(v57);
        float32_t v61; // 0x80c7990
        float32_t v62; // 0x80c7990
        float32_t v63; // 0x80c7990
        int3_t v64; // 0x80c7990
        if (*(char *)(v51 + v50) != 0) {
            // 0x80c7bb8
            __frontend_reg_store_fpr(v57, v60 + (float80_t)v55);
            float32_t v65 = __frontend_reg_load_fpr(v57); // 0x80c7bce
            int3_t v66 = v53 ^ -4; // 0x80c7bd4
            float80_t v67 = __frontend_reg_load_fpr(v53); // 0x80c7bd4
            __frontend_reg_store_fpr(v53, __frontend_reg_load_fpr(v66));
            __frontend_reg_store_fpr(v66, v67);
            float80_t v68 = __frontend_reg_load_fpr(v53); // 0x80c7bd6
            __frontend_reg_store_fpr(v53, v68 * __frontend_reg_load_fpr(v58));
            __frontend_reg_store_fpr(v53, __frontend_reg_load_fpr(v53) + (float80_t)v54);
            float32_t v69 = __frontend_reg_load_fpr(v53); // 0x80c7bde
            int3_t v70 = v53 + 1; // 0x80c7bde
            float80_t v71 = __frontend_reg_load_fpr(v70); // 0x80c7be4
            __frontend_reg_store_fpr(v70, __frontend_reg_load_fpr(v66));
            __frontend_reg_store_fpr(v66, v71);
            __frontend_reg_store_fpr(v58, __frontend_reg_load_fpr(v70) + __frontend_reg_load_fpr(v58));
            int3_t v72 = v53 + 2; // 0x80c7be6
            v63 = v56;
            v61 = v65;
            v62 = v69;
            v64 = v72;
            v48 = v56;
            v46 = v65;
            v47 = v69;
            v49 = v72;
            if (v51 == 6) {
                // break -> 0x80c7c34
                break;
            }
        } else {
            // 0x80c7c08
            __frontend_reg_store_fpr(v57, v60 + (float80_t)v56);
            float32_t v73 = __frontend_reg_load_fpr(v57); // 0x80c7c1e
            int3_t v74 = v53 ^ -4; // 0x80c7c24
            float80_t v75 = __frontend_reg_load_fpr(v53); // 0x80c7c24
            __frontend_reg_store_fpr(v53, __frontend_reg_load_fpr(v74));
            __frontend_reg_store_fpr(v74, v75);
            float80_t v76 = __frontend_reg_load_fpr(v53); // 0x80c7c26
            __frontend_reg_store_fpr(v53, v76 * __frontend_reg_load_fpr(v58));
            int3_t v77 = v53 + 2; // 0x80c7c28
            __frontend_reg_store_fpr(v77, __frontend_reg_load_fpr(v53) + __frontend_reg_load_fpr(v77));
            float80_t v78 = __frontend_reg_load_fpr(v53 + 1); // 0x80c7c2a
            __frontend_reg_store_fpr(v58, v78 + __frontend_reg_load_fpr(v58));
            float80_t v79 = __frontend_reg_load_fpr(v77);
            __frontend_reg_store_fpr(v77, __frontend_reg_load_fpr(v58));
            __frontend_reg_store_fpr(v58, v79);
            float80_t v80 = __frontend_reg_load_fpr(v77);
            __frontend_reg_store_fpr(v77, __frontend_reg_load_fpr(v74));
            __frontend_reg_store_fpr(v74, v80);
            float80_t v81 = __frontend_reg_load_fpr(v77);
            __frontend_reg_store_fpr(v77, __frontend_reg_load_fpr(v58));
            __frontend_reg_store_fpr(v58, v81);
            v63 = v73;
            v61 = v55;
            v62 = v54;
            v64 = v77;
            v48 = v73;
            v46 = v55;
            v47 = v54;
            v49 = v77;
            if (v51 == 6) {
                // break -> 0x80c7c34
                break;
            }
        }
        int32_t v82 = v52 + 12;
        int3_t v83 = v64 - 1; // 0x80c7bf6
        __frontend_reg_store_fpr(v83, (float80_t)*(float32_t *)v82);
        int3_t v84 = v64 - 2; // 0x80c7bf8
        __frontend_reg_store_fpr(v84, (float80_t)*(float32_t *)(v52 + 16));
        int3_t v85 = v64 + 2; // 0x80c7bfb
        float80_t v86 = __frontend_reg_load_fpr(v84); // 0x80c7bfb
        __frontend_reg_store_fpr(v84, __frontend_reg_load_fpr(v85));
        __frontend_reg_store_fpr(v85, v86);
        float80_t v87 = __frontend_reg_load_fpr(v84); // 0x80c7bfd
        __frontend_reg_store_fpr(v84, __frontend_reg_load_fpr(v83));
        __frontend_reg_store_fpr(v83, v87);
        int3_t v88 = v64 + 1; // 0x80c7bff
        float80_t v89 = __frontend_reg_load_fpr(v84); // 0x80c7bff
        __frontend_reg_store_fpr(v84, __frontend_reg_load_fpr(v88));
        __frontend_reg_store_fpr(v88, v89);
        v40 = v63;
        v41 = v61;
        v42 = v62;
        v43 = v84;
        v44 = v82;
        v45 = v51 + 1;
    }
    int3_t v90 = v49;
    int3_t v91 = v90 - 1; // 0x80c7c34
    __frontend_reg_store_fpr(v91, (float80_t)v46);
    int3_t v92 = v90 + 1; // 0x80c7c3a
    __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v91) / __frontend_reg_load_fpr(v92));
    float80_t v93 = __frontend_reg_load_fpr(v91); // 0x80c7c3c
    __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v92));
    __frontend_reg_store_fpr(v92, v93);
    __frontend_reg_store_fpr(v91, (float80_t)v47 / __frontend_reg_load_fpr(v91));
    int3_t v94 = v90 - 2; // 0x80c7c44
    __frontend_reg_store_fpr(v94, (float80_t)v48);
    int3_t v95 = v90 + 2;
    __frontend_reg_store_fpr(v94, __frontend_reg_load_fpr(v94) / __frontend_reg_load_fpr(v95));
    float80_t v96 = __frontend_reg_load_fpr(v94); // 0x80c7c4c
    __frontend_reg_store_fpr(v94, __frontend_reg_load_fpr(v90));
    __frontend_reg_store_fpr(v90, v96);
    __frontend_reg_store_fpr(v95, __frontend_reg_load_fpr(v94) / __frontend_reg_load_fpr(v95));
    float80_t v97 = __frontend_reg_load_fpr(v91); // 0x80c7c50
    __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v92));
    __frontend_reg_store_fpr(v92, v97);
    float80_t v98 = __frontend_reg_load_fpr(v91); // 0x80c7c55
    int3_t v99 = v90 + 3;
    float80_t v100 = __frontend_reg_load_fpr(v91); // 0x80c7c5e
    __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v99));
    __frontend_reg_store_fpr(v99, v100);
    float80_t v101 = __frontend_reg_load_fpr(v91); // 0x80c7c69
    float80_t v102 = __frontend_reg_load_fpr(v90);
    float80_t v103; // 0x80c7990
    float80_t v104; // 0x80c7990
    if ((int32_t)(float32_t)v98 == (int32_t)(float32_t)v101) {
        // 0x80c7ce8
        __frontend_reg_store_fpr(v90, __frontend_reg_load_fpr(v92));
        __frontend_reg_store_fpr(v92, v102);
        float80_t v105 = __frontend_reg_load_fpr(v90); // 0x80c7ced
        int3_t v106 = v90 ^ -4; // 0x80c7cf6
        float80_t v107 = __frontend_reg_load_fpr(v90); // 0x80c7cf6
        __frontend_reg_store_fpr(v90, __frontend_reg_load_fpr(v106));
        __frontend_reg_store_fpr(v106, v107);
        float80_t v108 = __frontend_reg_load_fpr(v90); // 0x80c7d01
        float80_t v109 = __frontend_reg_load_fpr(v92);
        if ((int32_t)(float32_t)v105 != (int32_t)(float32_t)v108) {
            // 0x80c7c88
            __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v95));
            __frontend_reg_store_fpr(v95, v109);
            float80_t v110 = __frontend_reg_load_fpr(v92); // 0x80c7c8a
            __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v99));
            __frontend_reg_store_fpr(v99, v110);
            float80_t v111 = __frontend_reg_load_fpr(v92); // 0x80c7c8c
            __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v106));
            __frontend_reg_store_fpr(v106, v111);
            float80_t v112 = __frontend_reg_load_fpr(v92); // 0x80c7c8e
            __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v95));
            __frontend_reg_store_fpr(v95, v112);
        } else {
            // 0x80c7d18
            __frontend_reg_store_fpr(v90, v104);
            float80_t v113 = __frontend_reg_load_fpr(v90); // 0x80c7d33
            float80_t v114 = __frontend_reg_load_fpr(v92);
            __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v95));
            __frontend_reg_store_fpr(v95, v114);
            float80_t v115 = __frontend_reg_load_fpr(v92);
            if ((int32_t)(float32_t)v109 != (int32_t)(float32_t)v113) {
                // 0x80c7c92
                __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v99));
                __frontend_reg_store_fpr(v99, v115);
                float80_t v116 = __frontend_reg_load_fpr(v92); // 0x80c7c96
                __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v106));
                __frontend_reg_store_fpr(v106, v116);
                float80_t v117 = __frontend_reg_load_fpr(v92); // 0x80c7c98
                __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v95));
                __frontend_reg_store_fpr(v95, v117);
            } else {
                // 0x80c7d4a
                __frontend_reg_store_fpr(v90, v103);
                float80_t v118 = __frontend_reg_load_fpr(v90); // 0x80c7d67
                float80_t v119 = __frontend_reg_load_fpr(v92);
                if ((int32_t)(float32_t)v115 == (int32_t)(float32_t)v118) {
                    // 0x80c7d7e
                    __frontend_reg_store_fpr(v92, v119);
                    __frontend_reg_store_fpr(v95, __frontend_reg_load_fpr(v95));
                    __frontend_reg_store_fpr(v99, __frontend_reg_load_fpr(v99));
                    __frontend_reg_store_fpr(v106, __frontend_reg_load_fpr(v106));
                    goto lab_0x80c7d90;
                }
                // 0x80c7c9c
                __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v99));
                __frontend_reg_store_fpr(v99, v119);
                float80_t v120 = __frontend_reg_load_fpr(v92); // 0x80c7c9e
                __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v106));
                __frontend_reg_store_fpr(v106, v120);
                float80_t v121 = __frontend_reg_load_fpr(v92); // 0x80c7ca0
                __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v95));
                __frontend_reg_store_fpr(v95, v121);
            }
        }
    } else {
        int3_t v122 = v90 ^ -4; // 0x80c7c7c
        __frontend_reg_store_fpr(v122, v102);
        float80_t v123 = __frontend_reg_load_fpr(v92); // 0x80c7c7e
        __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v95));
        __frontend_reg_store_fpr(v95, v123);
        float80_t v124 = __frontend_reg_load_fpr(v92); // 0x80c7c80
        __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v99));
        __frontend_reg_store_fpr(v99, v124);
        float80_t v125 = __frontend_reg_load_fpr(v92); // 0x80c7c82
        __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v122));
        __frontend_reg_store_fpr(v122, v125);
    }
    int32_t v126; // 0x80c7990
    if (v126 == 5) {
        // break -> 0x80c7d88
        goto lab_0x80c7d88;
    }
    float80_t v127 = __frontend_reg_load_fpr(v92); // 0x80c7cbc
    __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v99));
    __frontend_reg_store_fpr(v99, v127);
    float80_t v128 = __frontend_reg_load_fpr(v92); // 0x80c7cbe
    float80_t v129 = __frontend_reg_load_fpr(v95); // 0x80c7cc4
    __frontend_reg_store_fpr(v95, __frontend_reg_load_fpr(v99));
    __frontend_reg_store_fpr(v99, v129);
    float80_t v130 = __frontend_reg_load_fpr(v95); // 0x80c7cc6
    int3_t v131 = v90 ^ -4; // 0x80c7ccc
    float80_t v132 = __frontend_reg_load_fpr(v99); // 0x80c7ccc
    __frontend_reg_store_fpr(v99, __frontend_reg_load_fpr(v131));
    __frontend_reg_store_fpr(v131, v132);
    float80_t v133 = v130; // 0x80c7cce
    float80_t v134 = v128; // 0x80c7cce
    v126++;
    int3_t v135 = v99; // 0x80c7cce
    goto lab_0x80c7ac8;
  lab_0x80c7a9b:
    // 0x80c7a9b
    __frontend_reg_store_fpr(v9, v19);
    int32_t v164; // bp-36, 0x80c7990
    int32_t v162 = &v164; // 0x80c7aa7
    int32_t v165; // bp-4, 0x80c7990
    v50 = (int32_t)&v165 - 31;
    v133 = v27;
    v134 = v23;
    v126 = 0;
    v135 = v9;
    while (true) {
      lab_0x80c7ac8:
        // 0x80c7ac8
        v103 = v134;
        v104 = v133;
        v32 = v135 - 1;
        __frontend_reg_store_fpr(v32, v21);
        v33 = v135 - 2;
        __frontend_reg_store_fpr(v33, v19);
        v34 = v135 - 3;
        __frontend_reg_store_fpr(v34, v103);
        v38 = v135 ^ -4;
        v39 = v135 + 3;
        int3_t v136 = v135 + 2;
        int32_t v137; // bp-35, 0x80c7990
        int32_t v138 = &v137; // 0x80c7ae7
        int32_t v139; // bp-108, 0x80c7990
        int32_t v140 = &v139; // 0x80c7ae7
        int32_t v141 = 0; // 0x80c7ae7
        int32_t v142 = 0; // 0x80c7ae7
        while (true) {
            int32_t v143 = v142;
            int32_t v144 = v141;
            int32_t v145 = v140;
            int32_t v146 = v138;
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v135));
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v38) - __frontend_reg_load_fpr(v33));
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v135 + 1));
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v39) - __frontend_reg_load_fpr(v32));
            float80_t v147 = __frontend_reg_load_fpr(v39); // 0x80c7b1f
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v33));
            __frontend_reg_store_fpr(v33, v147);
            __frontend_reg_store_fpr(v39, v104 - __frontend_reg_load_fpr(v39));
            float80_t v148 = __frontend_reg_load_fpr(v39); // 0x80c7b27
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v32, v148);
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v34) - __frontend_reg_load_fpr(v39));
            __frontend_reg_store_fpr(v136, (float80_t)(float32_t)(v144 + 3));
            float80_t v149 = __frontend_reg_load_fpr(v136); // 0x80c7b31
            __frontend_reg_store_fpr(v136, __frontend_reg_load_fpr(v38));
            __frontend_reg_store_fpr(v38, v149);
            __frontend_reg_store_fpr(v136, __frontend_reg_load_fpr(v136) * __frontend_reg_load_fpr(v136));
            float80_t v150 = __frontend_reg_load_fpr(v136); // 0x80c7b35
            __frontend_reg_store_fpr(v136, __frontend_reg_load_fpr(v33));
            __frontend_reg_store_fpr(v33, v150);
            __frontend_reg_store_fpr(v136, __frontend_reg_load_fpr(v136) * __frontend_reg_load_fpr(v136));
            __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v136) + __frontend_reg_load_fpr(v33));
            float80_t v151 = __frontend_reg_load_fpr(v39); // 0x80c7b41
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v38));
            __frontend_reg_store_fpr(v38, v151);
            __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v39) * __frontend_reg_load_fpr(v33));
            __frontend_reg_store_fpr(v39, (float80_t)(float32_t)(v143 + 3));
            float80_t v152 = __frontend_reg_load_fpr(v39); // 0x80c7b4b
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v32, v152);
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v39) * __frontend_reg_load_fpr(v39));
            float80_t v153 = __frontend_reg_load_fpr(v39); // 0x80c7b4f
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v38));
            __frontend_reg_store_fpr(v38, v153);
            __frontend_reg_store_fpr(v39, __frontend_reg_load_fpr(v39) * __frontend_reg_load_fpr(v39));
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v39) + __frontend_reg_load_fpr(v38));
            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v38) * __frontend_reg_load_fpr(v32));
            float80_t v154 = __frontend_reg_load_fpr(v34); // 0x80c7b57
            __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v32, v154);
            float80_t v155 = __frontend_reg_load_fpr(v34); // 0x80c7b59
            float80_t v156 = __frontend_reg_load_fpr(v33); // 0x80c7b59
            bool v157 = false; // 0x80c7b59
            bool v158 = false; // 0x80c7b59
            if (v155 <= v156) {
                v157 = true;
                v158 = false;
                if (v155 >= v156) {
                    v157 = v155 != v156;
                    v158 = true;
                }
            }
            __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v33));
            char * v159 = (char *)v146;
            int32_t v160; // 0x80c7990
            int32_t v161; // 0x80c7990
            if (v157 || v158) {
                // 0x80c7b5f
                *v159 = 0;
                v160 = v144;
                v161 = v143 + 1;
                if (v145 == v162) {
                    // break -> 0x80c7b70
                    break;
                }
            } else {
                // 0x80c7af0
                *v159 = 1;
                v160 = v144 + 1;
                v161 = v143;
                if (v145 == v162) {
                    // 0x80c7b78
                    __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32));
                    goto lab_0x80c7b7a;
                }
            }
            // 0x80c7b01
            __frontend_reg_store_fpr(v33, (float80_t)*(float32_t *)v145);
            __frontend_reg_store_fpr(v34, (float80_t)*(float32_t *)(v145 + 4));
            float80_t v163 = __frontend_reg_load_fpr(v34); // 0x80c7b06
            __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v32, v163);
            v138 = v146 + 1;
            v140 = v145 + 12;
            v141 = v160;
            v142 = v161;
        }
        // 0x80c7b70
        __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32));
        goto lab_0x80c7b7a;
    }
  lab_0x80c7d88:
    // 0x80c7d88
    __frontend_reg_store_fpr(v92, __frontend_reg_load_fpr(v92));
    __frontend_reg_store_fpr(v95, __frontend_reg_load_fpr(v95));
    __frontend_reg_store_fpr(v99, __frontend_reg_load_fpr(v99));
    int3_t v166 = v90 ^ -4; // 0x80c7d8c
    __frontend_reg_store_fpr(v166, __frontend_reg_load_fpr(v166));
    goto lab_0x80c7d90;
  lab_0x80c7d90:;
    int32_t * mem = calloc(1, 164); // 0x80c7d9f
    int32_t v167 = (int32_t)mem; // 0x80c7d9f
    int32_t v168 = v1 + 16; // 0x80c7dac
    int32_t v169 = v167 + 16; // 0x80c7daf
    *(int32_t *)v169 = *(int32_t *)v168;
    int32_t v170 = v167 + 20;
    char * v171 = (char *)v170; // 0x80c7db2
    unsigned char v172 = *v7 % 2;
    *v171 = v172 | *v171 & -2;
    int32_t * v173; // 0x80c7990
    int32_t v174; // 0x80c7990
    int32_t v175; // 0x80c7990
    int32_t v176; // 0x80c7990
    int32_t v177; // 0x80c7990
    if (v172 == 0) {
        int32_t v178 = 0;
        int32_t v179 = 0;
        int32_t v180 = 0;
        int32_t v181 = *(int32_t *)(4 * v180 + v8);
        int32_t v182 = v180 + 1;
        int32_t v183; // 0x80c7990
        while (*(char *)(v180 + v50) == 0) {
            // 0x80c7fda
            *(int32_t *)(v167 + 24 + 4 * v179) = v181;
            *(int32_t *)(v181 + 16) = v167;
            v183 = v178;
            if (v180 == 6) {
                // break (via goto) -> 0x80c7ff0
                goto lab_0x80c7ff0;
            }
            v179++;
            v180 = v182;
            v181 = *(int32_t *)(4 * v180 + v8);
            v182 = v180 + 1;
        }
        // 0x80c7fc0
        *(int32_t *)(4 * v178 + v8) = v181;
        int32_t v184 = v178 + 1; // 0x80c7fcb
        v183 = v184;
        while (v180 != 6) {
            // 0x80c7fd3
            v178 = v184;
            v180 = v182;
            v181 = *(int32_t *)(4 * v180 + v8);
            v182 = v180 + 1;
            while (*(char *)(v180 + v50) == 0) {
                // 0x80c7fda
                *(int32_t *)(v167 + 24 + 4 * v179) = v181;
                *(int32_t *)(v181 + 16) = v167;
                v183 = v178;
                if (v180 == 6) {
                    // break (via goto) -> 0x80c7ff0
                    goto lab_0x80c7ff0;
                }
                v179++;
                v180 = v182;
                v181 = *(int32_t *)(4 * v180 + v8);
                v182 = v180 + 1;
            }
            // 0x80c7fc0
            *(int32_t *)(4 * v178 + v8) = v181;
            v184 = v178 + 1;
            v183 = v184;
        }
      lab_0x80c7ff0:;
        int32_t * v185 = (int32_t *)v6;
        v173 = v185;
        v174 = v183;
        v175 = 0;
        v176 = v182 & -256;
        v177 = *v185;
    } else {
        int32_t * v186 = (int32_t *)v6;
        float32_t v187 = 0.0f; // 0x80c7990
        float32_t v188 = 0.0f; // 0x80c7990
        int32_t v189 = 1; // 0x80c7990
        float32_t v190 = 0.0f; // 0x80c7990
        int32_t v191 = 1; // 0x80c7990
        int32_t v192 = 0; // 0x80c7990
        int32_t v193 = 0; // 0x80c7990
        int32_t v194 = v1; // 0x80c7990
        int32_t v195 = 1; // 0x80c7990
        float32_t v196; // 0x80c7990
        float32_t v197; // 0x80c7990
        int32_t v198; // 0x80c7990
        int32_t v199; // 0x80c7990
        while (true) {
            int32_t v200 = v195;
            int32_t v201 = v194;
            int32_t v202 = v193;
            int32_t v203 = v192;
            int32_t v204 = v191;
            float32_t v205 = v190;
            int32_t v206 = v189;
            float32_t v207 = v188;
            float32_t v208 = v187;
            float32_t v209; // 0x80c7990
            float32_t v210; // 0x80c7990
            float32_t v211; // 0x80c7990
            int32_t v212; // 0x80c7990
            int32_t v213; // 0x80c7990
            int32_t v214; // 0x80c7990
            if (*(char *)(v202 + v50) != 0) {
                int32_t v215 = 20 * v203 + v168; // 0x80c7e1e
                *(int32_t *)(v215 + 8) = *(int32_t *)(v201 + 24);
                *(int32_t *)(v215 + 12) = *(int32_t *)(v201 + 28);
                *(int32_t *)(v215 + 16) = *(int32_t *)(v201 + 32);
                *(int32_t *)(v215 + 20) = *(int32_t *)(v201 + 36);
                *(int32_t *)(v215 + 24) = *(int32_t *)(v201 + 40);
                uint32_t v216 = *v186; // 0x80c7e43
                int32_t v217 = v203 + 1; // 0x80c7e78
                float32_t v218 = (v216 / 2 & v200) != 0 ? (float32_t)(v204 | (int32_t)v207) : v207; // 0x80c7e87
                v211 = v208;
                v209 = v218;
                v213 = v206;
                v210 = v205;
                v214 = 2 * v204;
                v212 = v217;
                v196 = v218;
                v197 = v205;
                v198 = v217;
                v199 = v216;
                if (v202 == 6) {
                    // break -> 0x80c7f28
                    break;
                }
            } else {
                int32_t v219 = 20 * (int32_t)v208 + v169; // 0x80c7eaf
                *(int32_t *)(v219 + 8) = *(int32_t *)(v201 + 24);
                *(int32_t *)(v219 + 12) = *(int32_t *)(v201 + 28);
                *(int32_t *)(v219 + 16) = *(int32_t *)(v201 + 32);
                *(int32_t *)(v219 + 20) = *(int32_t *)(v201 + 36);
                *(int32_t *)(v219 + 24) = *(int32_t *)(v201 + 40);
                uint32_t v220 = *v186; // 0x80c7ed4
                float32_t v221 = (v220 / 2 & v200) != 0 ? (float32_t)(v206 | (int32_t)v205) : v205; // 0x80c7f1c
                v211 = (int32_t)v208 + 1;
                v209 = v207;
                v213 = 2 * v206;
                v210 = v221;
                v214 = v204;
                v212 = v203;
                v196 = v207;
                v197 = v221;
                v198 = v203;
                v199 = v220;
                if (v202 == 6) {
                    // break -> 0x80c7f28
                    break;
                }
            }
            // 0x80c7e93
            v187 = v211;
            v188 = v209;
            v189 = v213;
            v190 = v210;
            v191 = v214;
            v192 = v212;
            v193 = v202 + 1;
            v194 = v201 + 20;
            v195 = 2 * v200;
        }
        // 0x80c7f28
        v173 = v186;
        v174 = v198;
        v175 = 2 * (int32_t)v197;
        v176 = (int32_t)v196 % 0x80000000;
        v177 = v199;
    }
    // 0x80c7f46
    *v173 = v177 % 2 | 2 * v176;
    int32_t * v222 = (int32_t *)v170; // 0x80c7f55
    *v222 = *v222 % 2 | v175;
    if (*v7 % 2 != 0) {
        if (v174 > 6) {
            // 0x80c7f89
            adjust_bounds(&g279);
            adjust_bounds(&g279);
            return mem;
        }
        int32_t v223 = 20 * v174 + v8; // 0x80c800e
        int32_t v224 = v174;
        *(int32_t *)v223 = 0;
        int32_t v225 = v224 + 1; // 0x80c801f
        v223 += 20;
        while (v224 != 6) {
            // 0x80c8010
            v224 = v225;
            *(int32_t *)v223 = 0;
            v225 = v224 + 1;
            v223 += 20;
        }
        // 0x80c7f89
        adjust_bounds(&g279);
        adjust_bounds(&g279);
        return mem;
    }
    if (v174 > 6) {
        // 0x80c7f89
        adjust_bounds(&g279);
        adjust_bounds(&g279);
        return mem;
    }
    int32_t v226 = 4 * v174 + v8; // 0x80c7990
    int32_t v227 = v174;
    *(int32_t *)v226 = 0;
    int32_t v228 = v227 + 1; // 0x80c7f87
    v226 += 4;
    while (v227 != 6) {
        // 0x80c7f78
        v227 = v228;
        *(int32_t *)v226 = 0;
        v228 = v227 + 1;
        v226 += 4;
    }
    // 0x80c7f89
    adjust_bounds(&g279);
    adjust_bounds(&g279);
    return mem;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c8050 - 0x80c8478
// Line range:    902 - 838
void __r_insert_node(int32_t * node, int32_t * query, int32_t manage, char force) {
    int32_t v1 = (int32_t)node;
    int32_t v2; // 0x80c8050
    int32_t v3 = v2 + 20; // 0x80c8062
    int32_t v4; // 0x80c8050
    int32_t v5; // 0x80c8050
    int32_t v6; // 0x80c8218
    if (*(char *)v3 % 2 == 0) {
        int32_t * v7 = (int32_t *)(v2 + 8);
        int32_t * v8; // 0x80c8050
        int32_t * v9; // 0x80c8050
        if ((char)v1 != 0) {
            int32_t v10 = *v7; // 0x80c8270
            int32_t * v11 = (int32_t *)(v2 + 8); // 0x80c8273
            if (v10 > *v11) {
                // 0x80c8278
                *v11 = v10;
            }
            int32_t * v12 = (int32_t *)(v2 + 4);
            int32_t v13 = *v12; // 0x80c827b
            int32_t * v14 = (int32_t *)(v2 + 4); // 0x80c827e
            if (v13 < *v14) {
                // 0x80c8283
                *v14 = v13;
            }
            int32_t * v15 = (int32_t *)(v2 + 12);
            int32_t v16 = *v15; // 0x80c8286
            int32_t * v17 = (int32_t *)(v2 + 12); // 0x80c8289
            v9 = v15;
            v8 = v12;
            if (v16 > *v17) {
                // 0x80c828e
                *v17 = v16;
                v9 = v15;
                v8 = v12;
            }
        } else {
            // 0x80c8210
            v9 = (int32_t *)(v2 + 12);
            v8 = (int32_t *)(v2 + 4);
        }
        // 0x80c8214
        v6 = v2 + 24;
        uint32_t v18 = 0;
        int32_t * v19 = (int32_t *)(4 * v18 + v6);
        int32_t v20 = *v19; // 0x80c8218
        while (v20 != 0) {
            // 0x80c8224
            if (*(int32_t *)v20 <= v2) {
                // 0x80c822a
                if (*(int32_t *)(v20 + 8) >= *v7) {
                    // 0x80c8232
                    if (*(int32_t *)(v20 + 4) <= *v8) {
                        // 0x80c823a
                        if (*(int32_t *)(v20 + 12) >= *v9) {
                            // 0x80c8242
                            __r_insert_node(NULL, &g279, (int32_t)&g279, (char)&g279);
                            return;
                        }
                    }
                }
            }
            // 0x80c8258
            if (v18 == 5) {
                // 0x80c8260
                v5 = *(int32_t *)v6;
                goto lab_0x80c82b9;
            }
            v18++;
            v19 = (int32_t *)(4 * v18 + v6);
            v20 = *v19;
        }
        int32_t v21 = *(int32_t *)v6; // 0x80c82a8
        v5 = v21;
        if (v18 < 6) {
            // 0x80c83ec
            v5 = v21;
            if (*(char *)(v21 + 20) % 2 != 0) {
                int32_t mem = (int32_t)calloc(1, 164); // 0x80c8408
                int32_t v22 = mem + 20; // 0x80c840d
                char * v23 = (char *)v22; // 0x80c840d
                *v23 = *v23 | 1;
                *v19 = mem;
                int32_t v24 = *v8; // 0x80c8423
                *(int32_t *)(mem + 32) = v24;
                int32_t v25 = *v7; // 0x80c8429
                *(int32_t *)(mem + 36) = v25;
                int32_t v26 = *v9; // 0x80c842f
                *(int32_t *)(mem + 4) = v24;
                *(int32_t *)(mem + 8) = v25;
                *(int32_t *)(mem + 40) = v26;
                *(int32_t *)(mem + 12) = v26;
                if (v2 != 0) {
                    int32_t * v27 = (int32_t *)v22; // 0x80c844b
                    *v27 = *v27 % 2 | 2;
                }
                // 0x80c80e2
                return;
            }
        }
        goto lab_0x80c82b9;
    } else {
        int32_t v28 = 1; // 0x80c8075
        int32_t v29; // 0x80c8050
        if (v2 == 0) {
            int32_t v30 = 0;
            v29 = v30;
            int32_t v31; // 0x80c8050
            while (*(int32_t *)(v31 + 24) != 0) {
                int32_t v32 = v30 + 1; // 0x80c80f7
                v31 += 20;
                if (v30 == 5) {
                    // 0x80c8102
                    *(int32_t *)(v2 + 152) = *(int32_t *)(v2 + 4);
                    *(int32_t *)(v2 + 156) = *(int32_t *)(v2 + 8);
                    *(int32_t *)(v2 + 160) = *(int32_t *)(v2 + 12);
                    v4 = v32;
                    goto lab_0x80c812b;
                }
                v30 = v32;
                v29 = v30;
            }
        } else {
            int32_t v33 = 0;
            int32_t v34 = v33; // 0x80c8082
            int32_t v35 = v28; // 0x80c8082
            int32_t v36; // 0x80c8050
            while (*(int32_t *)(v36 + 24) != 0) {
                int32_t v37 = v33 + 1; // 0x80c8084
                int32_t v38 = 2 * v28; // 0x80c8087
                v28 = v38;
                v36 += 20;
                v34 = v37;
                v35 = v38;
                if (v33 == 5) {
                    // break -> 0x80c8091
                    break;
                }
                v33 = v37;
                v34 = v33;
                v35 = v28;
            }
            int32_t * v39 = (int32_t *)v3; // 0x80c8091
            uint32_t v40 = *v39; // 0x80c8091
            *v39 = v40 & -2 | 2 * v35 | v40 % 2;
            v29 = v34;
        }
        int32_t v41 = 20 * v29 + v2; // 0x80c80a8
        int32_t * v42 = (int32_t *)(v2 + 4); // 0x80c80b8
        *(int32_t *)(v41 + 32) = *v42;
        int32_t * v43 = (int32_t *)(v2 + 8); // 0x80c80be
        *(int32_t *)(v41 + 36) = *v43;
        int32_t * v44 = (int32_t *)(v2 + 12); // 0x80c80c4
        *(int32_t *)(v41 + 40) = *v44;
        v4 = v29;
        if (v29 == 0) {
            // 0x80c80cc
            *(int32_t *)(v2 + 4) = *v42;
            *(int32_t *)(v2 + 8) = *v43;
            *(int32_t *)(v2 + 12) = *v44;
            // 0x80c80e2
            return;
        }
        goto lab_0x80c812b;
    }
  lab_0x80c82b9:;
    int32_t v45 = *(int32_t *)(v5 + 4); // 0x80c82f1
    int32_t v46 = *(int32_t *)(v2 + 28); // 0x80c8349
    int32_t v47 = 1; // 0x80c834f
    int32_t v48; // 0x80c8050
    if (v46 == 0) {
        // 0x80c83d0
        v48 = *(int32_t *)(v5 + 12) - v45;
        __r_insert_node((int32_t *)1, (int32_t *)v48, (int32_t)&g279, (char)&g279);
        return;
    }
    int32_t v49 = v46;
    int32_t v50 = v47 + 1; // 0x80c83ba
    while (v47 != 5) {
        int32_t v51 = *(int32_t *)(4 * v50 + v6); // 0x80c8349
        v47 = v50;
        if (v51 == 0) {
            // break -> 0x80c83d0
            break;
        }
        v49 = v51;
        v50 = v47 + 1;
    }
    // 0x80c83d0
    v48 = *(int32_t *)(v49 + 12) - *(int32_t *)(v49 + 4);
    __r_insert_node((int32_t *)v50, (int32_t *)v48, (int32_t)&g279, (char)&g279);
  lab_0x80c812b:
    // 0x80c812b
    if ((char)v1 != 0) {
        if (v2 < v4) {
            // branch -> 0x80c8137
        }
        int32_t v52 = *(int32_t *)(v2 + 8); // 0x80c8137
        int32_t * v53 = (int32_t *)(v2 + 8); // 0x80c813a
        if (v52 > *v53) {
            // 0x80c813f
            *v53 = v52;
        }
        int32_t v54 = *(int32_t *)(v2 + 4); // 0x80c8142
        int32_t * v55 = (int32_t *)(v2 + 4); // 0x80c8145
        if (v54 < *v55) {
            // 0x80c814a
            *v55 = v54;
        }
        int32_t v56 = *(int32_t *)(v2 + 12); // 0x80c814d
        int32_t * v57 = (int32_t *)(v2 + 12); // 0x80c8150
        if (v56 > *v57) {
            // 0x80c8155
            *v57 = v56;
        }
    }
    if (v4 < 6) {
        // 0x80c80e2
        return;
    }
    int32_t v58 = (int32_t)find_clusters((int32_t *)v2); // 0x80c8160
    int32_t v59 = *(int32_t *)(v2 + 16); // 0x80c8165
    int32_t v60 = v58; // 0x80c816a
    int32_t v61 = v59; // 0x80c816a
    int32_t v62 = v58; // 0x80c816a
    int32_t v63; // 0x80c8050
    if (v59 != 0) {
        int32_t v64; // 0x80c8050
        int32_t * v65; // 0x80c8050
        while (true) {
            int32_t v66 = v61;
            v64 = v60;
            int32_t v67 = 0;
            v65 = (int32_t *)(v66 + 24 + 4 * v67);
            if (*v65 == 0) {
                // break (via goto) -> 0x80c8298
                goto lab_0x80c8298;
            }
            int32_t v68 = v67 + 1; // 0x80c8180
            while (v67 != 5) {
                // 0x80c816e
                v67 = v68;
                v65 = (int32_t *)(v66 + 24 + 4 * v67);
                if (*v65 == 0) {
                    // break (via goto) -> 0x80c8298
                    goto lab_0x80c8298;
                }
                // 0x80c817a
                v68 = v67 + 1;
            }
            // 0x80c8182
            *(int32_t *)(v66 + 48) = v64;
            int32_t v69 = (int32_t)find_clusters((int32_t *)v66);
            int32_t v70 = *(int32_t *)(v66 + 16); // 0x80c818f
            v60 = v69;
            v61 = v70;
            v62 = v69;
            v63 = v66;
            if (v70 == 0) {
                goto lab_0x80c8196;
            }
        }
      lab_0x80c8298:
        // 0x80c8298
        *v65 = v64;
        return;
    }
  lab_0x80c8196:;
    int32_t * mem2 = calloc(1, 164); // 0x80c81aa
    int32_t v71 = (int32_t)mem2; // 0x80c81aa
    __asm_rep_movsd_memcpy((char *)mem2, (char *)v63, 41);
    if (*(char *)(v71 + 20) % 2 == 0) {
        for (int32_t i = 0; i < 6; i++) {
            int32_t v72 = *(int32_t *)(v71 + 24 + 4 * i); // 0x80c8460
            if (v72 != 0) {
                // 0x80c8468
                *(int32_t *)(v72 + 16) = v71;
            }
        }
    }
    int32_t v73 = v63 + 20; // 0x80c81c5
    char * v74 = (char *)v73; // 0x80c81c5
    *v74 = *v74 & -2;
    int32_t * v75 = (int32_t *)v73; // 0x80c81c9
    *v75 = *v75 % 2;
    *(int32_t *)(v63 + 28) = v71;
    *(int32_t *)(v62 + 16) = v63;
    *(int32_t *)(v63 + 24) = v62;
    *(int32_t *)(v71 + 16) = v63;
    *(int32_t *)(v63 + 32) = 0;
    *(int32_t *)(v63 + 36) = 0;
    *(int32_t *)(v63 + 40) = 0;
    *(int32_t *)(v63 + 44) = 0;
    *(int32_t *)(v63 + 48) = 0;
    adjust_bounds(&g279);
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c8480 - 0x80c84d2
// Line range:    1026 - 1039
void r_insert_entry(int32_t * rtree, int32_t * which, int32_t man) {
    int32_t v1 = *rtree; // 0x80c848d
    int32_t * v2 = (int32_t *)1; // 0x80c8493
    if (*(int32_t *)v1 <= *which) {
        int32_t v3 = (int32_t)which;
        v2 = (int32_t *)1;
        if (*(int32_t *)(v1 + 8) >= *(int32_t *)(v3 + 8)) {
            // 0x80c849d
            v2 = (int32_t *)1;
            if (*(int32_t *)(v1 + 4) <= *(int32_t *)(v3 + 4)) {
                int32_t v4 = *(int32_t *)(v1 + 12); // 0x80c84a5
                int32_t v5 = *(int32_t *)(v3 + 12); // 0x80c84a8
                int32_t v6 = v4 - v5; // 0x80c84a8
                v2 = (int32_t *)(int32_t)(v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0);
            }
        }
    }
    // 0x80c84bd
    __r_insert_node(v2, &g279, (int32_t)&g279, (char)&g279);
    int32_t * v7 = (int32_t *)((int32_t)rtree + 4); // 0x80c84c8
    *v7 = *v7 + 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c84e0 - 0x80c855d
// Line range:    446 - 469
int32_t * r_create_tree(int32_t ** boxlist, int32_t N, int32_t manage) {
    int32_t * mem = calloc(1, 8); // 0x80c84fe
    int32_t mem2 = (int32_t)calloc(1, 164); // 0x80c8514
    char * v1 = (char *)(mem2 + 20); // 0x80c8519
    *v1 = *v1 | 1;
    *(int32_t *)(mem2 + 16) = 0;
    *mem = mem2;
    if (N < 1) {
        // 0x80c8553
        return mem;
    }
    int32_t v2 = 0; // 0x80c8528
    int32_t v3 = *(int32_t *)(4 * v2 + (int32_t)boxlist); // 0x80c853a
    r_insert_entry(mem, (int32_t *)v3, manage);
    v2++;
    while (v2 != N) {
        // 0x80c8530
        v3 = *(int32_t *)(4 * v2 + (int32_t)boxlist);
        r_insert_entry(mem, (int32_t *)v3, manage);
        v2++;
    }
    // 0x80c8553
    return mem;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80c9bc0 - 0x80ca380
// Line range:    1363 - 1527
int32_t SearchObjectByID(int32_t * Base, char ** Result1, char ** Result2, char ** Result3, int32_t ID2, int32_t type) {
    int32_t v1 = (int32_t)Base;
    int32_t * v2; // 0x80c9bc0
    int32_t * v3; // 0x80c9bc0
    switch (type) {
        case 0x1000: {
            goto lab_0x80c9d00;
        }
        case 4: {
            goto lab_0x80c9d00;
        }
        case 0x4000: {
            // 0x80c9bc0
            v2 = (int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24);
            goto lab_0x80c9da8;
        }
        case 16: {
            // 0x80c9bc0
            v3 = (int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24);
            goto lab_0x80ca010;
        }
        default: {
            goto lab_0x80c9bfe;
        }
    }
  lab_0x80c9fb0_2:;
    // 0x80c9fb0
    int32_t v4; // 0x80c9bc0
    *(int32_t *)Result1 = v4;
    int32_t v5; // 0x80c9bc0
    int32_t v6 = v5; // 0x80c9fb3
    goto lab_0x80c9fb5;
  lab_0x80c9fd0_2:
    // 0x80c9fd0
    *(int32_t *)Result1 = v4;
    int32_t v7; // 0x80c9bc0
    int32_t v8 = v7; // 0x80c9fd3
    goto lab_0x80c9fd5;
  lab_0x80ca2e4_2:;
    // 0x80ca2e4
    int32_t v9; // 0x80c9bc0
    *(int32_t *)Result1 = v9;
    int32_t v10; // 0x80c9bc0
    *(int32_t *)Result3 = v10;
    *(int32_t *)Result2 = v10;
    int32_t result = 0x2000; // 0x80ca2f8
    goto lab_0x80c9cf6;
  lab_0x80ca2fd_2:
    // 0x80ca2fd
    *(int32_t *)Result1 = v9;
    int32_t v11; // 0x80c9bc0
    *(int32_t *)Result3 = v11;
    *(int32_t *)Result2 = v11;
    result = 0x8000;
    goto lab_0x80c9cf6;
  lab_0x80ca34e_2:
    // 0x80ca34e
    *(int32_t *)Result1 = v9;
    int32_t v12; // 0x80c9bc0
    *(int32_t *)Result3 = v12;
    *(int32_t *)Result2 = v12;
    result = 256;
    goto lab_0x80c9cf6;
  lab_0x80ca1f0_2:
    // 0x80ca1f0
    *(int32_t *)Result1 = v9;
    int32_t v13; // 0x80c9bc0
    *(int32_t *)Result3 = v13;
    *(int32_t *)Result2 = v13;
    result = 512;
    goto lab_0x80c9cf6;
  lab_0x80ca1a8:
    if (type == 512) {
        uint32_t v14 = *(int32_t *)(v9 + 232); // 0x80ca1b2
        if (v14 != 0) {
            int32_t v15 = *(int32_t *)(v9 + 260); // 0x80ca1c3
            v13 = v15;
            if (*(int32_t *)(v15 + 16) == ID2) {
                goto lab_0x80ca1f0_2;
            }
            int32_t v16 = v15; // 0x80ca1de
            if (v14 > 1) {
                int32_t v17 = v16 + 104;
                v13 = v17;
                if (*(int32_t *)(v16 + 120) == ID2) {
                    goto lab_0x80ca1f0_2;
                }
                int32_t v18 = 2; // 0x80ca1d8
                v16 = v17;
                int32_t v19 = v18; // 0x80ca1de
                while (v14 > v18) {
                    // 0x80ca1e4
                    v17 = v16 + 104;
                    v13 = v17;
                    if (*(int32_t *)(v16 + 120) == ID2) {
                        goto lab_0x80ca1f0_2;
                    }
                    // 0x80ca1db
                    v18 = v19 + 1;
                    v16 = v17;
                    v19 = v18;
                }
            }
        }
    }
    goto lab_0x80ca128;
  lab_0x80ca128:;
    int32_t v20; // 0x80c9bc0
    if (v20 == 0) {
        // 0x80ca0e7
        Message("hace: Internal error, search for ID %d failed\n", ID2);
        // 0x80c9cf6
        return 0;
    }
    // 0x80ca132
    v20--;
    int32_t v21; // 0x80c9bc0
    int32_t v22 = v21 - 300; // 0x80ca141
    int32_t v23 = v21; // 0x80ca141
    int32_t v24 = v21; // 0x80ca141
    if (*(int32_t *)(v21 + 16) == ID2) {
        goto lab_0x80ca147;
    }
    goto lab_0x80c9f0d;
  lab_0x80ca090_2:;
    // 0x80ca090
    int32_t v46; // 0x80c9bc0
    *(int32_t *)Result1 = v46;
    int32_t v47; // 0x80c9bc0
    *(int32_t *)Result3 = v47;
    *(int32_t *)Result2 = v47;
    result = 16;
    goto lab_0x80c9cf6;
  lab_0x80ca2c5_2:;
    // 0x80ca2c5
    int32_t v48; // 0x80c9bc0
    *(int32_t *)Result1 = v48;
    int32_t v49; // 0x80c9bc0
    *(int32_t *)Result3 = v49;
    *(int32_t *)Result2 = v49;
    result = 8;
    goto lab_0x80c9cf6;
  lab_0x80c9cdc_2:
    // 0x80c9cdc
    *(int32_t *)Result1 = v48;
    int32_t v50; // 0x80c9bc0
    *(int32_t *)Result2 = v50;
    int32_t v51; // 0x80c9bc0
    *(int32_t *)Result3 = v51;
    result = 2048;
    goto lab_0x80c9cf6;
  lab_0x80c9e52:
    if (type != 0x1000) {
        goto lab_0x80c9ec2;
    } else {
        goto lab_0x80c9e58;
    }
  lab_0x80c9d00:;
    int32_t * v52 = (int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24);
    uint32_t v53 = *v52 + 2; // 0x80c9d15
    if (v53 != 0) {
        int32_t v54 = 0; // 0x80c9d21
        v4 = v1 + 76;
        int32_t v55 = *(int32_t *)(v4 + 4); // 0x80c9d28
        int32_t v56; // 0x80c9bc0
        int32_t v57; // 0x80c9bc0
        int32_t v58; // 0x80c9bc0
        int32_t v59; // 0x80c9bc0
        int32_t v60; // 0x80c9d2b
        int32_t v61; // 0x80c9d36
        int32_t v62; // 0x80c9d39
        if (v55 != 0) {
            // 0x80c9d33
            v60 = v55 - 1;
            v61 = *(int32_t *)(v4 + 36);
            v62 = v61 + 88 * v60;
            v59 = v62;
            if (*(int32_t *)(v62 + 16) == ID2) {
                // 0x80c9f90
                *(int32_t *)Result1 = v4;
                *(int32_t *)Result3 = v59;
                *(int32_t *)Result2 = v59;
                return 4;
            }
            // 0x80c9d45
            v5 = v62;
            if (*(int32_t *)(v62 + 60) == ID2) {
                goto lab_0x80c9fb0_2;
            }
            // 0x80c9d4e
            v7 = v62;
            if (*(int32_t *)(v62 + 80) == ID2) {
                goto lab_0x80c9fd0_2;
            }
            // 0x80c9d57
            v57 = 88 * v55 - 176 + v61;
            v56 = v60;
            while (v56 != 0) {
                // 0x80c9d68
                v58 = v57;
                v59 = v58;
                if (*(int32_t *)(v58 + 16) == ID2) {
                    // 0x80c9f90
                    *(int32_t *)Result1 = v4;
                    *(int32_t *)Result3 = v59;
                    *(int32_t *)Result2 = v59;
                    return 4;
                }
                // 0x80c9d73
                v5 = v58;
                if (*(int32_t *)(v58 + 60) == ID2) {
                    goto lab_0x80c9fb0_2;
                }
                // 0x80c9d7c
                v57 = v58 - 88;
                v7 = v58;
                if (*(int32_t *)(v58 + 80) == ID2) {
                    goto lab_0x80c9fd0_2;
                }
                v56--;
            }
        }
        // 0x80c9d92
        v54++;
        while (v54 < v53) {
            // 0x80c9da2
            v4 += 92;
            v55 = *(int32_t *)(v4 + 4);
            if (v55 != 0) {
                // 0x80c9d33
                v60 = v55 - 1;
                v61 = *(int32_t *)(v4 + 36);
                v62 = v61 + 88 * v60;
                v59 = v62;
                if (*(int32_t *)(v62 + 16) == ID2) {
                    // 0x80c9f90
                    *(int32_t *)Result1 = v4;
                    *(int32_t *)Result3 = v59;
                    *(int32_t *)Result2 = v59;
                    return 4;
                }
                // 0x80c9d45
                v5 = v62;
                if (*(int32_t *)(v62 + 60) == ID2) {
                    goto lab_0x80c9fb0_2;
                }
                // 0x80c9d4e
                v7 = v62;
                if (*(int32_t *)(v62 + 80) == ID2) {
                    goto lab_0x80c9fd0_2;
                }
                // 0x80c9d57
                v57 = 88 * v55 - 176 + v61;
                v56 = v60;
                while (v56 != 0) {
                    // 0x80c9d68
                    v58 = v57;
                    v59 = v58;
                    if (*(int32_t *)(v58 + 16) == ID2) {
                        // 0x80c9f90
                        *(int32_t *)Result1 = v4;
                        *(int32_t *)Result3 = v59;
                        *(int32_t *)Result2 = v59;
                        return 4;
                    }
                    // 0x80c9d73
                    v5 = v58;
                    if (*(int32_t *)(v58 + 60) == ID2) {
                        goto lab_0x80c9fb0_2;
                    }
                    // 0x80c9d7c
                    v57 = v58 - 88;
                    v7 = v58;
                    if (*(int32_t *)(v58 + 80) == ID2) {
                        goto lab_0x80c9fd0_2;
                    }
                    v56--;
                }
            }
            // 0x80c9d92
            v54++;
        }
    }
    // 0x80c9be7
    v2 = v52;
    v3 = v52;
    switch (type) {
        case 0x4000: {
            goto lab_0x80c9da8;
        }
        case 16: {
            goto lab_0x80ca010;
        }
        default: {
            goto lab_0x80c9bfe;
        }
    }
  lab_0x80c9bfe:
    switch (type) {
        case 2048: {
            goto lab_0x80c9c0f;
        }
        case 8: {
            goto lab_0x80c9c0f;
        }
        case 1: {
            goto lab_0x80ca209;
        }
        case 32: {
            goto lab_0x80c9e58;
        }
        default: {
            goto lab_0x80c9e52;
        }
    }
  lab_0x80c9c0f:;
    uint32_t v63 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 24) + 2; // 0x80c9c27
    if (v63 != 0) {
        int32_t v64 = 0; // 0x80c9c33
        v48 = v1 + 76;
        int32_t v65 = *(int32_t *)(v48 + 12); // 0x80c9c3d
        int32_t v66; // 0x80c9bc0
        int32_t v67; // 0x80c9bc0
        int32_t v68; // 0x80c9bc0
        int32_t v69; // 0x80c9bc0
        int32_t v70; // 0x80c9bc0
        int32_t v71; // 0x80c9bc0
        int32_t v72; // 0x80c9c40
        int32_t v73; // 0x80c9c4f
        int32_t v74; // 0x80c9c55
        int32_t v75; // 0x80c9c98
        int32_t v76; // 0x80c9c9b
        int32_t v77; // 0x80c9ca9
        int32_t v78; // 0x80c9cac
        if (v65 != 0) {
            // 0x80c9c4f
            v72 = v65 - 1;
            v73 = *(int32_t *)(v48 + 44);
            v74 = v73 + 60 * v72;
            v49 = v74;
            if (*(int32_t *)(v74 + 16) == ID2) {
                goto lab_0x80ca2c5_2;
            }
            // 0x80c9c64
            v71 = v74;
            v69 = 60 * v65 - 120 + v73;
            v70 = v72;
            if (type == 2048) {
                // 0x80c9c95
                v50 = v71;
                v75 = *(int32_t *)(v50 + 36);
                if (v75 != 0) {
                    // 0x80c9ca3
                    v76 = v75 - 1;
                    v77 = *(int32_t *)(v50 + 56);
                    v78 = v77 + 20 * v76;
                    v51 = v78;
                    if (*(int32_t *)(v78 + 16) == ID2) {
                        goto lab_0x80c9cdc_2;
                    }
                    // 0x80c9cb7
                    v67 = 20 * v75 - 40 + v77;
                    v66 = v76;
                    while (v66 != 0) {
                        // 0x80c9cd0
                        v68 = v67;
                        v67 = v68 - 20;
                        v51 = v68;
                        if (*(int32_t *)(v68 + 16) == ID2) {
                            goto lab_0x80c9cdc_2;
                        }
                        v66--;
                    }
                }
            }
            while (v70 != 0) {
                // 0x80c9c7e
                v71 = v69;
                v49 = v69;
                if (*(int32_t *)(v69 + 16) == ID2) {
                    goto lab_0x80ca2c5_2;
                }
                v69 -= 60;
                v70--;
                if (type == 2048) {
                    // 0x80c9c95
                    v50 = v71;
                    v75 = *(int32_t *)(v50 + 36);
                    if (v75 != 0) {
                        // 0x80c9ca3
                        v76 = v75 - 1;
                        v77 = *(int32_t *)(v50 + 56);
                        v78 = v77 + 20 * v76;
                        v51 = v78;
                        if (*(int32_t *)(v78 + 16) == ID2) {
                            goto lab_0x80c9cdc_2;
                        }
                        // 0x80c9cb7
                        v67 = 20 * v75 - 40 + v77;
                        v66 = v76;
                        while (v66 != 0) {
                            // 0x80c9cd0
                            v68 = v67;
                            v67 = v68 - 20;
                            v51 = v68;
                            if (*(int32_t *)(v68 + 16) == ID2) {
                                goto lab_0x80c9cdc_2;
                            }
                            v66--;
                        }
                    }
                }
            }
        }
        while (v64 + 1 < v63) {
            // 0x80ca2a9
            v64++;
            // 0x80ca2b9
            v48 += 92;
            v65 = *(int32_t *)(v48 + 12);
            if (v65 != 0) {
                // 0x80c9c4f
                v72 = v65 - 1;
                v73 = *(int32_t *)(v48 + 44);
                v74 = v73 + 60 * v72;
                v49 = v74;
                if (*(int32_t *)(v74 + 16) == ID2) {
                    goto lab_0x80ca2c5_2;
                }
                // 0x80c9c64
                v71 = v74;
                v69 = 60 * v65 - 120 + v73;
                v70 = v72;
                if (type == 2048) {
                    // 0x80c9c95
                    v50 = v71;
                    v75 = *(int32_t *)(v50 + 36);
                    if (v75 != 0) {
                        // 0x80c9ca3
                        v76 = v75 - 1;
                        v77 = *(int32_t *)(v50 + 56);
                        v78 = v77 + 20 * v76;
                        v51 = v78;
                        if (*(int32_t *)(v78 + 16) == ID2) {
                            goto lab_0x80c9cdc_2;
                        }
                        // 0x80c9cb7
                        v67 = 20 * v75 - 40 + v77;
                        v66 = v76;
                        while (v66 != 0) {
                            // 0x80c9cd0
                            v68 = v67;
                            v67 = v68 - 20;
                            v51 = v68;
                            if (*(int32_t *)(v68 + 16) == ID2) {
                                goto lab_0x80c9cdc_2;
                            }
                            v66--;
                        }
                    }
                }
                while (v70 != 0) {
                    // 0x80c9c7e
                    v71 = v69;
                    v49 = v69;
                    if (*(int32_t *)(v69 + 16) == ID2) {
                        goto lab_0x80ca2c5_2;
                    }
                    v69 -= 60;
                    v70--;
                    if (type == 2048) {
                        // 0x80c9c95
                        v50 = v71;
                        v75 = *(int32_t *)(v50 + 36);
                        if (v75 != 0) {
                            // 0x80c9ca3
                            v76 = v75 - 1;
                            v77 = *(int32_t *)(v50 + 56);
                            v78 = v77 + 20 * v76;
                            v51 = v78;
                            if (*(int32_t *)(v78 + 16) == ID2) {
                                goto lab_0x80c9cdc_2;
                            }
                            // 0x80c9cb7
                            v67 = 20 * v75 - 40 + v77;
                            v66 = v76;
                            while (v66 != 0) {
                                // 0x80c9cd0
                                v68 = v67;
                                v67 = v68 - 20;
                                v51 = v68;
                                if (*(int32_t *)(v68 + 16) == ID2) {
                                    goto lab_0x80c9cdc_2;
                                }
                                v66--;
                            }
                        }
                    }
                }
            }
        }
    }
    switch (type) {
        case 1: {
            goto lab_0x80ca209;
        }
        case 32: {
            goto lab_0x80c9e58;
        }
        default: {
            goto lab_0x80c9e52;
        }
    }
  lab_0x80ca209:;
    uint32_t v79 = *Base; // 0x80ca20c
    int32_t v80; // 0x80c9bc0
    if (v79 == 0) {
        goto lab_0x80c9e52;
    } else {
        int32_t v81 = *(int32_t *)(v1 + 28); // 0x80ca216
        v80 = v81;
        if (*(int32_t *)(v81 + 16) != ID2) {
            int32_t v82 = v81; // 0x80ca22d
            int32_t v83 = 1; // 0x80ca22d
            if (v79 > 1) {
                int32_t v84 = v82 + 76;
                v80 = v84;
                while (*(int32_t *)(v82 + 92) != ID2) {
                    int32_t v85 = v83 + 1; // 0x80ca228
                    v82 = v84;
                    v83 = v85;
                    if (v79 <= v85) {
                        goto lab_0x80c9e52;
                    }
                    v84 = v82 + 76;
                    v80 = v84;
                }
                goto lab_0x80ca23f;
            } else {
                goto lab_0x80c9e52;
            }
        } else {
            goto lab_0x80ca23f;
        }
    }
  lab_0x80c9e58:;
    int32_t v86 = *(int32_t *)(v1 + 16); // 0x80c9e5b
    if (v86 != 0) {
        int32_t v87 = v86 - 1; // 0x80c9e5e
        int32_t v88 = *(int32_t *)(v1 + 36); // 0x80c9e69
        int32_t v89 = v88 + 92 * v87; // 0x80c9e6c
        int32_t v90 = v89; // 0x80c9e72
        if (*(int32_t *)(v89 + 16) == ID2) {
          lab_0x80ca316:
            // 0x80ca316
            *(int32_t *)Result3 = v90;
            *(int32_t *)Result2 = v90;
            *(int32_t *)Result1 = v90;
            // 0x80c9cf6
            return 32;
        }
        int32_t v91 = v89; // 0x80c9e7b
        if (*(int32_t *)(v89 + 60) == ID2) {
          lab_0x80ca32f:
            // 0x80ca32f
            *(int32_t *)Result1 = 0;
            v6 = v91;
          lab_0x80c9fb5:
            // 0x80c9fb5
            *(int32_t *)Result2 = v6;
            *(int32_t *)Result3 = v6 + 44;
            return 0x1000;
        }
        int32_t v92 = v89; // 0x80c9e84
        if (*(int32_t *)(v89 + 80) == ID2) {
          lab_0x80ca33d:
            // 0x80ca33d
            *(int32_t *)Result1 = 0;
            v8 = v92;
          lab_0x80c9fd5:
            // 0x80c9fd5
            *(int32_t *)Result2 = v8;
            *(int32_t *)Result3 = v8 + 64;
            return 0x1000;
        }
        int32_t v93 = v87; // 0x80c9e94
        int32_t v94 = 92 * v86 - 184 + v88; // 0x80c9e94
        while (v93 != 0) {
            int32_t v95 = v94;
            v90 = v95;
            if (*(int32_t *)(v95 + 16) == ID2) {
                goto lab_0x80ca316;
            }
            // 0x80c9ea3
            v91 = v95;
            if (*(int32_t *)(v95 + 60) == ID2) {
                goto lab_0x80ca32f;
            }
            // 0x80c9eac
            v93--;
            v94 = v95 - 92;
            v92 = v95;
            if (*(int32_t *)(v95 + 80) == ID2) {
                goto lab_0x80ca33d;
            }
        }
    }
    goto lab_0x80c9ec2;
  lab_0x80c9da8:;
    uint32_t v100 = *v2 + 2; // 0x80c9dbd
    if (v100 != 0) {
        int32_t v101 = 0; // 0x80c9dc9
        int32_t v102 = v1 + 76;
        int32_t v103 = *(int32_t *)(v102 + 16); // 0x80c9dd0
        int32_t v104; // 0x80c9bc0
        int32_t v105; // 0x80c9bc0
        int32_t v106; // 0x80c9bc0
        int32_t v107; // 0x80c9bc0
        int32_t v108; // 0x80c9dd3
        int32_t v109; // 0x80c9ddb
        int32_t v110; // 0x80c9de6
        if (v103 != 0) {
            // 0x80c9ddb
            v108 = v103 - 1;
            v109 = *(int32_t *)(v102 + 48);
            v110 = v109 + 68 * v108;
            v107 = v110;
            if (*(int32_t *)(v110 + 16) == ID2) {
                // 0x80c9ff0
                *(int32_t *)Result1 = v102;
                *(int32_t *)Result3 = v107;
                *(int32_t *)Result2 = v107;
                return 0x4000;
            }
            // 0x80c9df2
            v105 = 68 * v103 - 136 + v109;
            v104 = v108;
            while (v104 != 0) {
                // 0x80c9e08
                v106 = v105;
                v105 = v106 - 68;
                v107 = v106;
                if (*(int32_t *)(v106 + 16) == ID2) {
                    // 0x80c9ff0
                    *(int32_t *)Result1 = v102;
                    *(int32_t *)Result3 = v107;
                    *(int32_t *)Result2 = v107;
                    return 0x4000;
                }
                v104--;
            }
        }
        // 0x80c9e20
        v101++;
        while (v101 < v100) {
            // 0x80c9e2c
            v102 += 92;
            v103 = *(int32_t *)(v102 + 16);
            if (v103 != 0) {
                // 0x80c9ddb
                v108 = v103 - 1;
                v109 = *(int32_t *)(v102 + 48);
                v110 = v109 + 68 * v108;
                v107 = v110;
                if (*(int32_t *)(v110 + 16) == ID2) {
                    // 0x80c9ff0
                    *(int32_t *)Result1 = v102;
                    *(int32_t *)Result3 = v107;
                    *(int32_t *)Result2 = v107;
                    return 0x4000;
                }
                // 0x80c9df2
                v105 = 68 * v103 - 136 + v109;
                v104 = v108;
                while (v104 != 0) {
                    // 0x80c9e08
                    v106 = v105;
                    v105 = v106 - 68;
                    v107 = v106;
                    if (*(int32_t *)(v106 + 16) == ID2) {
                        // 0x80c9ff0
                        *(int32_t *)Result1 = v102;
                        *(int32_t *)Result3 = v107;
                        *(int32_t *)Result2 = v107;
                        return 0x4000;
                    }
                    v104--;
                }
            }
            // 0x80c9e20
            v101++;
        }
    }
    goto lab_0x80c9e52;
  lab_0x80ca010:;
    uint32_t v111 = *v3 + 2; // 0x80ca025
    if (v111 != 0) {
        int32_t v112 = 0; // 0x80ca031
        v46 = v1 + 76;
        int32_t v113 = *(int32_t *)(v46 + 8); // 0x80ca038
        int32_t v114; // 0x80c9bc0
        int32_t v115; // 0x80c9bc0
        int32_t v116; // 0x80c9bc0
        int32_t v117; // 0x80ca03b
        int32_t v118; // 0x80ca046
        int32_t v119; // 0x80ca049
        if (v113 != 0) {
            // 0x80ca043
            v117 = v113 - 1;
            v118 = *(int32_t *)(v46 + 40);
            v119 = v118 + 60 * v117;
            v47 = v119;
            if (*(int32_t *)(v119 + 16) == ID2) {
                goto lab_0x80ca090_2;
            }
            // 0x80ca051
            v114 = v117;
            v115 = 60 * v113 - 120 + v118;
            while (v114 != 0) {
                // 0x80ca060
                v116 = v115;
                v114--;
                v115 = v116 - 60;
                if (*(int32_t *)(v116 + 16) == ID2) {
                    goto lab_0x80ca090_2;
                }
            }
        }
        // 0x80ca074
        v112++;
        while (v112 < v111) {
            // 0x80ca084
            v46 += 92;
            v113 = *(int32_t *)(v46 + 8);
            if (v113 != 0) {
                // 0x80ca043
                v117 = v113 - 1;
                v118 = *(int32_t *)(v46 + 40);
                v119 = v118 + 60 * v117;
                v47 = v119;
                if (*(int32_t *)(v119 + 16) == ID2) {
                    goto lab_0x80ca090_2;
                }
                // 0x80ca051
                v114 = v117;
                v115 = 60 * v113 - 120 + v118;
                while (v114 != 0) {
                    // 0x80ca060
                    v116 = v115;
                    v114--;
                    v115 = v116 - 60;
                    v47 = v116;
                    if (*(int32_t *)(v116 + 16) == ID2) {
                        goto lab_0x80ca090_2;
                    }
                }
            }
            // 0x80ca074
            v112++;
        }
    }
    goto lab_0x80c9e52;
  lab_0x80c9ec2:;
    int32_t v96; // 0x80c9ed6
    switch (type) {
        case 0x8000: {
        }
        case 0x2000: {
        }
        case 1024: {
        }
        case 512: {
        }
        case 256: {
        }
        case 2: {
            // 0x80c9ed3
            v96 = *(int32_t *)(v1 + 8);
            if (v96 == 0) {
                // 0x80ca0e7
                Message("hace: Internal error, search for ID %d failed\n", ID2);
                // 0x80c9cf6
                return 0;
            }
            // break -> 0x80c9ee8
            break;
        }
        default: {
            // 0x80ca0e7
            Message("hace: Internal error, search for ID %d failed\n", ID2);
            // 0x80c9cf6
            return 0;
        }
    }
    int32_t v97 = v96 - 1; // 0x80c9ed9
    int32_t v98 = *(int32_t *)(v1 + 32); // 0x80c9eee
    int32_t v99 = v98 + 300 * v97; // 0x80c9ef1
    v24 = v99;
    if (*(int32_t *)(v99 + 16) == ID2) {
      lab_0x80ca147:
        // 0x80ca147
        *(int32_t *)Result3 = v24;
        *(int32_t *)Result2 = v24;
        *(int32_t *)Result1 = v24;
        // 0x80c9cf6
        return 2;
    }
    // 0x80c9efd
    v20 = v97;
    v22 = 300 * v96 - 600 + v98;
    v23 = v99;
    int32_t v39; // 0x80c9bc0
    while (true) {
      lab_0x80c9f0d:
        // 0x80c9f0d
        v9 = v23;
        v21 = v22;
        switch (type) {
            case 0x2000: {
                int32_t v25 = *(int32_t *)(v9 + 240); // 0x80ca160
                if (v25 != 0) {
                    int32_t v26 = v25 - 1; // 0x80ca166
                    int32_t v27 = *(int32_t *)(v9 + 264); // 0x80ca171
                    int32_t v28 = v27 + 88 * v26; // 0x80ca177
                    v10 = v28;
                    if (*(int32_t *)(v28 + 16) == ID2) {
                        goto lab_0x80ca2e4_2;
                    }
                    int32_t v29 = 88 * v25 - 176 + v27; // 0x80ca18d
                    int32_t v30 = v26;
                    while (v30 != 0) {
                        int32_t v31 = v29;
                        v29 = v31 - 88;
                        v10 = v31;
                        if (*(int32_t *)(v31 + 16) == ID2) {
                            goto lab_0x80ca2e4_2;
                        }
                        v30--;
                    }
                }
                goto lab_0x80ca1a8;
            }
            case 0x8000: {
                int32_t v32 = *(int32_t *)(v9 + 248); // 0x80ca258
                if (v32 != 0) {
                    int32_t v33 = v32 - 1; // 0x80ca25e
                    int32_t v34 = *(int32_t *)(v9 + 268); // 0x80ca26a
                    int32_t v35 = v34 + 68 * v33; // 0x80ca278
                    v11 = v35;
                    if (*(int32_t *)(v35 + 16) == ID2) {
                        goto lab_0x80ca2fd_2;
                    }
                    int32_t v36 = 68 * v32 - 136 + v34; // 0x80ca28e
                    int32_t v37 = v33;
                    while (v37 != 0) {
                        int32_t v38 = v36;
                        v36 = v38 - 68;
                        v11 = v38;
                        if (*(int32_t *)(v38 + 16) == ID2) {
                            goto lab_0x80ca2fd_2;
                        }
                        v37--;
                    }
                }
                goto lab_0x80ca1a8;
            }
            case 1024: {
                // 0x80ca0fe
                if (*(int32_t *)(v9 + 172) == ID2) {
                    // break -> 0x80ca367
                    break;
                }
                // 0x80ca110
                if (*(int32_t *)(v9 + 112) == ID2) {
                    // 0x80ca367
                    v39 = v9 + 96;
                    goto lab_0x80ca367_3;
                }
                // 0x80ca11c
                if (*(int32_t *)(v9 + 52) == ID2) {
                    // 0x80ca367
                    v39 = v9 + 36;
                    goto lab_0x80ca367_3;
                }
                goto lab_0x80ca128;
            }
            default: {
                if (type != 256) {
                    goto lab_0x80ca1a8;
                } else {
                    uint32_t v40 = *(int32_t *)(v9 + 224); // 0x80c9f46
                    if (v40 != 0) {
                        int32_t v41 = *(int32_t *)(v9 + 256); // 0x80c9f54
                        v12 = v41;
                        if (*(int32_t *)(v41 + 16) == ID2) {
                            goto lab_0x80ca34e_2;
                        }
                        int32_t v42 = v41; // 0x80c9f85
                        if (v40 > 1) {
                            int32_t v43 = v42 + 76;
                            v12 = v43;
                            if (*(int32_t *)(v42 + 92) == ID2) {
                                goto lab_0x80ca34e_2;
                            }
                            int32_t v44 = 2; // 0x80c9f80
                            v42 = v43;
                            int32_t v45 = v44; // 0x80c9f85
                            while (v44 < v40) {
                                // 0x80c9f70
                                v43 = v42 + 76;
                                v12 = v43;
                                if (*(int32_t *)(v42 + 92) == ID2) {
                                    goto lab_0x80ca34e_2;
                                }
                                // 0x80c9f83
                                v44 = v45 + 1;
                                v42 = v43;
                                v45 = v44;
                            }
                        }
                    }
                    goto lab_0x80ca128;
                }
            }
        }
    }
    // 0x80ca367
    v39 = v9 + 156;
    goto lab_0x80ca367_3;
  lab_0x80ca367_3:
    // 0x80ca367
    *(int32_t *)Result1 = v9;
    *(int32_t *)Result3 = v39;
    *(int32_t *)Result2 = v39;
    // 0x80c9cf6
    return 1024;
  lab_0x80ca23f:
    // 0x80ca23f
    *(int32_t *)Result3 = v80;
    *(int32_t *)Result2 = v80;
    *(int32_t *)Result1 = v80;
    result = 1;
  lab_0x80c9cf6:
    // 0x80c9cf6
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca380 - 0x80ca40c
// Line range:    300 - 316
char SearchRatLineByLocation(int32_t locked, int32_t ** Line, int32_t ** Dummy1, int32_t ** Dummy2) {
    int32_t v1[8]; // 0x80ca3b9
    struct __jmp_buf_tag v2; // 0x80ca3b9
    struct __jmp_buf_tag env[1]; // 0x80ca3b9
    // 0x80ca380
    int32_t v3; // bp-172, 0x80ca380
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca3c9
        return 1;
    }
    int32_t v4 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 68); // 0x80ca3fd
    int32_t v5; // bp-192, 0x80ca380
    r_search((int32_t *)v4, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cb350, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca410 - 0x80ca4be
// Line range:    130 - 151
char SearchViaByLocation(int32_t locked, int32_t ** Via, int32_t ** Dummy1, int32_t ** Dummy2) {
    int32_t v1[8]; // 0x80ca459
    struct __jmp_buf_tag v2; // 0x80ca459
    struct __jmp_buf_tag env[1]; // 0x80ca459
    // 0x80ca410
    if (*(char *)&g200 == 0) {
        // 0x80ca467
        return 0;
    }
    // 0x80ca429
    int32_t v3; // bp-172, 0x80ca410
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca467
        return 1;
    }
    int32_t v4 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 40); // 0x80ca4a7
    int32_t v5; // bp-192, 0x80ca410
    r_search((int32_t *)v4, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cb410, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca4c0 - 0x80ca56e
// Line range:    158 - 177
char SearchPinByLocation(int32_t locked, int32_t ** Element, int32_t ** Pin, int32_t ** Dummy) {
    int32_t v1[8]; // 0x80ca509
    struct __jmp_buf_tag v2; // 0x80ca509
    struct __jmp_buf_tag env[1]; // 0x80ca509
    // 0x80ca4c0
    if (*(char *)&g204 == 0) {
        // 0x80ca517
        return 0;
    }
    // 0x80ca4d9
    int32_t v3; // bp-172, 0x80ca4c0
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca517
        return 1;
    }
    int32_t v4 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 48); // 0x80ca557
    int32_t v5; // bp-192, 0x80ca4c0
    r_search((int32_t *)v4, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cb410, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca570 - 0x80ca5f6
// Line range:    257 - 274
char SearchLineByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Line, int32_t ** Dummy) {
    int32_t v1[8]; // 0x80ca5aa
    struct __jmp_buf_tag v2; // 0x80ca5aa
    struct __jmp_buf_tag env[1]; // 0x80ca5aa
    // 0x80ca570
    int32_t v3; // 0x80ca570
    *(int32_t *)v3 = (int32_t)SearchLayer;
    int32_t v4; // bp-172, 0x80ca570
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca5ba
        return 1;
    }
    // 0x80ca5c0
    int32_t v5; // bp-184, 0x80ca570
    r_search((int32_t *)g104, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cbbd0, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca600 - 0x80ca686
// Line range:    347 - 363
char SearchArcByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Arc, int32_t ** Dummy) {
    int32_t v1[8]; // 0x80ca63a
    struct __jmp_buf_tag v2; // 0x80ca63a
    struct __jmp_buf_tag env[1]; // 0x80ca63a
    // 0x80ca600
    int32_t v3; // 0x80ca600
    *(int32_t *)v3 = (int32_t)SearchLayer;
    int32_t v4; // bp-172, 0x80ca600
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca64a
        return 1;
    }
    // 0x80ca650
    int32_t v5; // bp-180, 0x80ca600
    r_search((int32_t *)g107, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cb860, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca690 - 0x80ca719
// Line range:    386 - 403
char SearchTextByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Text, int32_t ** Dummy) {
    int32_t v1[8]; // 0x80ca6cc
    struct __jmp_buf_tag v2; // 0x80ca6cc
    struct __jmp_buf_tag env[1]; // 0x80ca6cc
    // 0x80ca690
    int32_t v3; // 0x80ca690
    *(int32_t *)v3 = (int32_t)SearchLayer;
    int32_t v4; // bp-172, 0x80ca690
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    char result = 1; // 0x80ca6da
    if (_setjmp(env) == 0) {
        // 0x80ca6dc
        int32_t v5; // bp-192, 0x80ca690
        r_search((int32_t *)g105, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cb4a0, (char *)&v5);
        result = 0;
    }
    // 0x80ca710
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca720 - 0x80ca7a9
// Line range:    427 - 444
char SearchPolygonByLocation(int32_t locked, int32_t ** Layer2, int32_t ** Polygon2, int32_t ** Dummy) {
    int32_t v1[8]; // 0x80ca75c
    struct __jmp_buf_tag v2; // 0x80ca75c
    struct __jmp_buf_tag env[1]; // 0x80ca75c
    // 0x80ca720
    int32_t v3; // 0x80ca720
    *(int32_t *)v3 = (int32_t)SearchLayer;
    int32_t v4; // bp-172, 0x80ca720
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    char result = 1; // 0x80ca76a
    if (_setjmp(env) == 0) {
        // 0x80ca76c
        int32_t v5; // bp-192, 0x80ca720
        r_search((int32_t *)g106, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cb530, (char *)&v5);
        result = 0;
    }
    // 0x80ca7a0
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca7b0 - 0x80ca88c
// Line range:    205 - 222
char SearchPadByLocation(int32_t locked, int32_t ** Element, int32_t ** Pad, int32_t ** Dummy, char BackToo) {
    int32_t v1[8]; // 0x80ca81e
    struct __jmp_buf_tag v2; // 0x80ca81e
    struct __jmp_buf_tag env[1]; // 0x80ca81e
    // 0x80ca7b0
    if (*(char *)&g204 == 0) {
        // 0x80ca82c
        return 0;
    }
    // 0x80ca7d4
    int32_t v3; // bp-188, 0x80ca7b0
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    char result = 1; // 0x80ca82a
    if (_setjmp(env) == 0) {
        int32_t v4 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 52); // 0x80ca87f
        int32_t v5; // bp-208, 0x80ca7b0
        r_search((int32_t *)v4, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80cbc60, (char *)&v5);
        result = 0;
    }
    // 0x80ca82c
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca890 - 0x80ca990
// Line range:    567 - 580
char SearchElementNameByLocation(int32_t locked, int32_t ** Element, int32_t ** Text, int32_t ** Dummy, char BackToo) {
    // 0x80ca890
    if (*(char *)&g201 == 0) {
        // 0x80ca95e
        return 0;
    }
    int32_t v1 = *(int32_t *)((int32_t)PCB + 0x220c); // 0x80ca8d8
    int32_t v2 = 4; // 0x80ca8f8
    if ((vyl & 64) == 0) {
        // 0x80ca970
        v2 = vyl / 4 & 8 ^ 8;
    }
    int32_t v3 = *(int32_t *)(v1 + 56 + v2); // 0x80ca903
    int32_t v4; // bp-208, 0x80ca890
    int32_t v5 = r_search((int32_t *)v3, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80c93f0, (char *)&v4); // 0x80ca952
    // 0x80ca95e
    return v5 != 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca990 - 0x80caa66
// Line range:    621 - 635
char SearchElementByLocation(int32_t locked, int32_t ** Element, int32_t ** Dummy1, int32_t ** Dummy2, char BackToo) {
    // 0x80ca990
    if (*(char *)&g201 == 0) {
        // 0x80ca9c0
        return 0;
    }
    char result = 0; // 0x80ca9bc
    if (*(char *)&g204 != 0) {
        int32_t v1 = *(int32_t *)(*(int32_t *)((int32_t)PCB + 0x220c) + 44); // 0x80caa43
        int32_t v2; // bp-208, 0x80ca990
        int32_t v3 = r_search((int32_t *)v1, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80c9500, (char *)&v2); // 0x80caa49
        result = v3 != 0;
    }
    // 0x80ca9c0
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80caa70 - 0x80cb2f1
// Line range:    1133 - 1330
int32_t SearchObjectByLocation(int32_t Type, char ** Result1, char ** Result2, char ** Result3, int32_t X, int32_t Y, int32_t Radius) {
    // 0x80caa70
    int3_t v1; // 0x80caa70
    int3_t v2 = v1 - 1; // 0x80caa91
    __frontend_reg_store_fpr(v2, (float80_t)X);
    PosX = __frontend_reg_load_fpr(v2);
    __frontend_reg_store_fpr(v2, (float80_t)Y);
    PosY = __frontend_reg_load_fpr(v2);
    SearchRadius = Radius;
    int32_t v3; // 0x80caa70
    int32_t v4; // 0x80caa70
    if (Radius == 0) {
        // 0x80cad88
        SearchBox = X;
        g96 = Y;
        v4 = X + 1;
        v3 = Y + 1;
    } else {
        // 0x80caac8
        SearchBox = X - Radius;
        g96 = Y - Radius;
        v4 = Radius + X;
        v3 = Radius + Y;
    }
    int32_t v5 = (int32_t)Result3;
    g97 = v4;
    g98 = v3;
    int32_t v6 = (vyl & 0x240000) == 0 ? Type : Type & -1041; // 0x80cab03
    int32_t v7 = (vyl & 0x80000) == 0 ? v6 : v6 & 1040; // 0x80cab16
    uint32_t v8 = (vyl & 0x24000) == 0 ? v7 : v7 & -9; // 0x80cab26
    if ((v8 & 32) != 0) {
        // 0x80cab32
        if (*(char *)&g202 != 0) {
            char v9 = SearchRatLineByLocation(v5, (int32_t **)&g279, (int32_t **)&g279, (int32_t **)&g279); // 0x80cadba
            if (v9 != 0) {
                // 0x80cad76
                return 32;
            }
        }
    }
    if (v8 % 2 != 0) {
        // 0x80cb04c
        if (SearchViaByLocation(v5, (int32_t **)&g279, (int32_t **)&g279, (int32_t **)&g279) != 0) {
            // 0x80cad76
            return 1;
        }
    }
    int32_t v10; // 0x80caa70
    int32_t v11; // bp-40, 0x80caa70
    if ((v8 & 256) != 0) {
        char v12 = SearchPinByLocation((int32_t)&v11, (int32_t **)&g279, (int32_t **)&g279, (int32_t **)&g279); // 0x80cb086
        v10 = 256;
        if (v12 == 0) {
            goto lab_0x80cab56;
        } else {
            goto lab_0x80cb09d;
        }
    } else {
        goto lab_0x80cab56;
    }
  lab_0x80cac3f:;
    // 0x80cac3f
    int32_t v13; // 0x80caa70
    int32_t v14 = v13;
    char ** v15; // 0x80caa70
    char ** v16 = v15; // 0x80cac49
    char ** v17; // 0x80caa70
    char ** v18 = v17; // 0x80cac49
    char ** v19; // 0x80cac94
    char ** v20 = v19; // 0x80cac49
    int32_t v21; // 0x80caa70
    int32_t v22 = v21; // 0x80cac49
    bool v23; // 0x80caa70
    int32_t result; // 0x80caa70
    int32_t v24; // 0x80caa70
    float80_t v25; // 0x80caa70
    char ** v26; // bp-288, 0x80caa70
    int3_t v27; // 0x80caa70
    int3_t v28; // 0x80caa70
    int3_t v29; // 0x80caa70
    int3_t v30; // 0x80caa70
    int32_t v31; // 0x80caa70
    bool v32; // 0x80caa70
    if (*(char *)(v14 + 68) != 0) {
        char ** v33 = v19; // 0x80cac57
        if ((v24 & 768) == 0) {
            char ** v34 = v17; // 0x80cac65
            if ((v8 & 2048) != 0) {
                int32_t v35 = *(int32_t *)(v14 + 12); // 0x80cac6b
                *(int32_t *)Result1 = v14;
                v34 = v17;
                if (v35 != 0) {
                    // 0x80cac8b
                    __frontend_reg_store_fpr(v2, (float80_t)SearchRadius);
                    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2) * __frontend_reg_load_fpr(v2));
                    __frontend_reg_store_fpr(v27, (float80_t)PosX);
                    __frontend_reg_store_fpr(v28, (float80_t)PosY);
                    int32_t v36 = v35; // 0x80cacb9
                    int32_t v37 = 60 * v35; // 0x80cacb9
                    int32_t v38 = 0;
                    v37 -= 60;
                    int32_t v39 = *(int32_t *)(v14 + 44) + v37; // 0x80cacd0
                    int32_t v40 = *(int32_t *)(v39 + 36); // 0x80cacd3
                    int32_t v41; // 0x80caa70
                    int32_t v42; // 0x80caa70
                    int32_t v43; // 0x80caa70
                    int32_t v44; // 0x80caa70
                    int32_t v45; // 0x80cacf7
                    float80_t v46; // 0x80cad02
                    float80_t v47; // 0x80cad06
                    float80_t v48; // 0x80cad0c
                    float80_t v49; // 0x80cad0e
                    float80_t v50; // 0x80cad0e
                    float80_t v51; // 0x80caa70
                    float80_t v52; // 0x80cad14
                    float80_t v53; // 0x80cad16
                    float80_t v54; // 0x80cad2a
                    float80_t v55; // 0x80cad2c
                    float80_t v56; // 0x80cacf0
                    float80_t v57; // 0x80cacf2
                    float80_t v58; // 0x80cad3b
                    float80_t v59; // 0x80cad3d
                    if (v40 == 0) {
                        // 0x80cad3b
                        v58 = __frontend_reg_load_fpr(v28);
                        __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                        __frontend_reg_store_fpr(v27, v58);
                        v59 = __frontend_reg_load_fpr(v28);
                        __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                        __frontend_reg_store_fpr(v2, v59);
                        v43 = v38;
                    } else {
                        // 0x80cacde
                        v41 = 20 * v40;
                        v44 = v40;
                        v42 = v38;
                        v41 -= 20;
                        v45 = *(int32_t *)(v39 + 56) + v41;
                        __frontend_reg_store_fpr(v29, (float80_t)*(int32_t *)v45);
                        __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v29) - __frontend_reg_load_fpr(v27));
                        __frontend_reg_store_fpr(v30, (float80_t)*(int32_t *)(v45 + 4));
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) - __frontend_reg_load_fpr(v28));
                        v46 = __frontend_reg_load_fpr(v30);
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                        __frontend_reg_store_fpr(v29, v46);
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                        v47 = __frontend_reg_load_fpr(v30);
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                        __frontend_reg_store_fpr(v29, v47);
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                        __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v29));
                        v48 = __frontend_reg_load_fpr(v29);
                        __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v2));
                        __frontend_reg_store_fpr(v2, v48);
                        v49 = __frontend_reg_load_fpr(v29);
                        v50 = __frontend_reg_load_fpr(v2);
                        v51 = __frontend_reg_load_fpr(v29);
                        if (v49 > v50) {
                            // 0x80cad12
                            __frontend_reg_store_fpr(v29, v51);
                            v52 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                            __frontend_reg_store_fpr(v27, v52);
                            v53 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v53);
                            *(int32_t *)v19 = v45;
                            *(int32_t *)Result2 = v39;
                        } else {
                            // 0x80cad28
                            __frontend_reg_store_fpr(v2, v51);
                            v54 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                            __frontend_reg_store_fpr(v27, v54);
                            v55 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v55);
                        }
                        // 0x80cad2e
                        v44--;
                        v43 = v42;
                        while (v44 != 0) {
                            // 0x80cacf0
                            v56 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v56);
                            v57 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                            __frontend_reg_store_fpr(v27, v57);
                            v41 -= 20;
                            v45 = *(int32_t *)(v39 + 56) + v41;
                            __frontend_reg_store_fpr(v29, (float80_t)*(int32_t *)v45);
                            __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v29) - __frontend_reg_load_fpr(v27));
                            __frontend_reg_store_fpr(v30, (float80_t)*(int32_t *)(v45 + 4));
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) - __frontend_reg_load_fpr(v28));
                            v46 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v46);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                            v47 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v47);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                            __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v29));
                            v48 = __frontend_reg_load_fpr(v29);
                            __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v48);
                            v49 = __frontend_reg_load_fpr(v29);
                            v50 = __frontend_reg_load_fpr(v2);
                            v51 = __frontend_reg_load_fpr(v29);
                            if (v49 > v50) {
                                // 0x80cad12
                                __frontend_reg_store_fpr(v29, v51);
                                v52 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                                __frontend_reg_store_fpr(v27, v52);
                                v53 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v53);
                                *(int32_t *)v19 = v45;
                                *(int32_t *)Result2 = v39;
                            } else {
                                // 0x80cad28
                                __frontend_reg_store_fpr(v2, v51);
                                v54 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                                __frontend_reg_store_fpr(v27, v54);
                                v55 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v55);
                            }
                            // 0x80cad2e
                            v44--;
                            v43 = v42;
                        }
                    }
                    // 0x80cad40
                    v36--;
                    int32_t v60 = v43;
                    float80_t v61 = __frontend_reg_load_fpr(v28);
                    while (v36 != 0) {
                        // 0x80cacc0
                        __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                        __frontend_reg_store_fpr(v2, v61);
                        float80_t v62 = __frontend_reg_load_fpr(v28); // 0x80cacc2
                        __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                        __frontend_reg_store_fpr(v27, v62);
                        v38 = v60;
                        v37 -= 60;
                        v39 = *(int32_t *)(v14 + 44) + v37;
                        v40 = *(int32_t *)(v39 + 36);
                        if (v40 == 0) {
                            // 0x80cad3b
                            v58 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                            __frontend_reg_store_fpr(v27, v58);
                            v59 = __frontend_reg_load_fpr(v28);
                            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v59);
                            v43 = v38;
                        } else {
                            // 0x80cacde
                            v41 = 20 * v40;
                            v44 = v40;
                            v42 = v38;
                            v41 -= 20;
                            v45 = *(int32_t *)(v39 + 56) + v41;
                            __frontend_reg_store_fpr(v29, (float80_t)*(int32_t *)v45);
                            __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v29) - __frontend_reg_load_fpr(v27));
                            __frontend_reg_store_fpr(v30, (float80_t)*(int32_t *)(v45 + 4));
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) - __frontend_reg_load_fpr(v28));
                            v46 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v46);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                            v47 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v47);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                            __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v29));
                            v48 = __frontend_reg_load_fpr(v29);
                            __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v48);
                            v49 = __frontend_reg_load_fpr(v29);
                            v50 = __frontend_reg_load_fpr(v2);
                            v51 = __frontend_reg_load_fpr(v29);
                            if (v49 > v50) {
                                // 0x80cad12
                                __frontend_reg_store_fpr(v29, v51);
                                v52 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                                __frontend_reg_store_fpr(v27, v52);
                                v53 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v53);
                                *(int32_t *)v19 = v45;
                                *(int32_t *)Result2 = v39;
                            } else {
                                // 0x80cad28
                                __frontend_reg_store_fpr(v2, v51);
                                v54 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                                __frontend_reg_store_fpr(v27, v54);
                                v55 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v55);
                            }
                            // 0x80cad2e
                            v44--;
                            v43 = v42;
                            while (v44 != 0) {
                                // 0x80cacf0
                                v56 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v56);
                                v57 = __frontend_reg_load_fpr(v28);
                                __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                                __frontend_reg_store_fpr(v27, v57);
                                v41 -= 20;
                                v45 = *(int32_t *)(v39 + 56) + v41;
                                __frontend_reg_store_fpr(v29, (float80_t)*(int32_t *)v45);
                                __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v29) - __frontend_reg_load_fpr(v27));
                                __frontend_reg_store_fpr(v30, (float80_t)*(int32_t *)(v45 + 4));
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) - __frontend_reg_load_fpr(v28));
                                v46 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v29, v46);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                                v47 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v29, v47);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v30) * __frontend_reg_load_fpr(v30));
                                __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v29));
                                v48 = __frontend_reg_load_fpr(v29);
                                __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v48);
                                v49 = __frontend_reg_load_fpr(v29);
                                v50 = __frontend_reg_load_fpr(v2);
                                v51 = __frontend_reg_load_fpr(v29);
                                if (v49 > v50) {
                                    // 0x80cad12
                                    __frontend_reg_store_fpr(v29, v51);
                                    v52 = __frontend_reg_load_fpr(v28);
                                    __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                                    __frontend_reg_store_fpr(v27, v52);
                                    v53 = __frontend_reg_load_fpr(v28);
                                    __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                                    __frontend_reg_store_fpr(v2, v53);
                                    *(int32_t *)v19 = v45;
                                    *(int32_t *)Result2 = v39;
                                } else {
                                    // 0x80cad28
                                    __frontend_reg_store_fpr(v2, v51);
                                    v54 = __frontend_reg_load_fpr(v28);
                                    __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v27));
                                    __frontend_reg_store_fpr(v27, v54);
                                    v55 = __frontend_reg_load_fpr(v28);
                                    __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v2));
                                    __frontend_reg_store_fpr(v2, v55);
                                }
                                // 0x80cad2e
                                v44--;
                                v43 = v42;
                            }
                        }
                        // 0x80cad40
                        v36--;
                        v60 = v43;
                        v61 = __frontend_reg_load_fpr(v28);
                    }
                    // 0x80cad5b
                    __frontend_reg_store_fpr(v28, v61);
                    __frontend_reg_store_fpr(v27, __frontend_reg_load_fpr(v27));
                    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2));
                    v26 = v19;
                    v34 = v19;
                    if ((char)v60 != 0) {
                        // 0x80cad76
                        return 2048;
                    }
                }
            }
            char ** v63 = v34; // 0x80caef8
            char ** v64 = v19; // 0x80caee4
            if ((v8 & 0x1000) != 0) {
                int32_t v65 = SearchRadius; // 0x80caef3
                *(int32_t *)Result1 = v14;
                *(int32_t *)v63 = 0;
                char ** v66 = Result2; // bp-212, 0x80caf0f
                __frontend_reg_store_fpr(v2, (float80_t)(v65 * v65));
                __frontend_reg_load_fpr(v2);
                int32_t v67 = *(int32_t *)(v14 + 52); // 0x80caf66
                int32_t v68 = r_search((int32_t *)v67, &SearchBox, NULL, (int32_t (*)(int32_t *, char *))0x80c9350, (char *)&v66); // 0x80caf6c
                v64 = v63;
                if (v68 != 0) {
                    // 0x80cad76
                    return 0x1000;
                }
            }
            char ** v69 = v64; // 0x80cadd8
            if ((v8 & 4) != 0) {
                // 0x80cb020
                v69 = v26;
                char v70 = SearchLineByLocation((int32_t)v69, (int32_t **)&g279, (int32_t **)&g279, (int32_t **)&g279); // 0x80cb035
                if (v70 != 0) {
                    // 0x80cad76
                    return 4;
                }
            }
            char ** v71 = v69; // 0x80cade5
            if ((v8 & 0x4000) != 0) {
                // 0x80caff0
                v71 = v26;
                char v72 = SearchArcByLocation((int32_t)v71, (int32_t **)&g279, (int32_t **)&g279, (int32_t **)&g279); // 0x80cb005
                if (v72 != 0) {
                    // 0x80cad76
                    return 0x4000;
                }
            }
            // 0x80cadeb
            v33 = v71;
            if ((v8 & 16) != 0) {
                char v73 = SearchTextByLocation((int32_t)v26, (int32_t **)&g279, (int32_t **)&g279, (int32_t **)&g279); // 0x80cae06
                v33 = v26;
                if (v73 != 0) {
                    // 0x80cad76
                    return 16;
                }
            }
        }
        char ** v74 = v33; // 0x80cae1b
        if ((v8 & 8) != 0) {
            // 0x80caf89
            v74 = v26;
            v31 = (int32_t)v74;
            char v75 = SearchPolygonByLocation(v31, (int32_t **)&g279, (int32_t **)&g279, (int32_t **)&g279); // 0x80caf9e
            if (v75 != 0) {
                // 0x80cafab
                result = 8;
                if (v24 == 0) {
                    return result;
                } else {
                    char * v76 = *Result2;
                    int32_t v77 = *(int32_t *)((int32_t)v76 + 8); // 0x80cafbf
                    __frontend_reg_store_fpr(v2, (float80_t)(v77 - *(int32_t *)v76));
                    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2) * __frontend_reg_load_fpr(v2));
                    __frontend_reg_store_fpr(v27, v25);
                    float80_t v78 = __frontend_reg_load_fpr(v27); // 0x80cafd8
                    __frontend_reg_store_fpr(v27, __frontend_reg_load_fpr(v2));
                    __frontend_reg_store_fpr(v2, v78);
                    float80_t v79 = __frontend_reg_load_fpr(v27); // 0x80cafda
                    float80_t v80 = __frontend_reg_load_fpr(v2); // 0x80cafda
                    v23 = false;
                    v32 = false;
                    if (v79 > v80) {
                        goto lab_dec_label_pc_unknown;
                    } else {
                        v23 = true;
                        v32 = false;
                        if (v79 < v80) {
                            goto lab_dec_label_pc_unknown;
                        } else {
                            v23 = v79 != v80;
                            v32 = true;
                            goto lab_dec_label_pc_unknown;
                        }
                    }
                }
            }
        }
        // 0x80cae21
        v16 = v74;
        v18 = v74;
        v20 = v74;
        v22 = (int32_t)PCB;
    }
    goto lab_0x80cae27;
  lab_0x80cae27:;
    char ** v81 = v16; // 0x80cae43
    int32_t v82 = *(int32_t *)(v22 + 0x220c); // 0x80cae27
    int32_t v83; // 0x80caa70
    int32_t v84 = v83 + 1; // 0x80cae2d
    int32_t v85 = *(int32_t *)(v82 + 24); // 0x80cae34
    char ** v86 = v81; // 0x80cae3d
    char ** v87 = v18; // 0x80cae3d
    char ** v88 = v20; // 0x80cae3d
    int32_t v89 = v84; // 0x80cae3d
    int32_t v90 = v85; // 0x80cae3d
    int32_t v91 = v22; // 0x80cae3d
    int32_t v92 = v82; // 0x80cae3d
    if (v85 < v84) {
        // break -> 0x80cae43
        goto lab_0x80cae43;
    }
    goto lab_0x80cac08;
  lab_0x80cab56:
    if ((v8 & 512) != 0) {
        char v99 = SearchPadByLocation((int32_t)&v11, NULL, (int32_t **)&g279, (int32_t **)&g279, (char)&g279); // 0x80cb0ef
        v10 = 512;
        if (v99 == 0) {
            goto lab_0x80cab66;
        } else {
            goto lab_0x80cb09d;
        }
    } else {
        goto lab_0x80cab66;
    }
  lab_0x80cb09d:
    // 0x80cb09d
    __frontend_reg_store_fpr(v2, 0.0L);
    v25 = __frontend_reg_load_fpr(v2);
    int32_t v100 = v10; // 0x80cb0a5
    goto lab_0x80cab92;
  lab_0x80cab66:;
    int32_t v110; // 0x80caa70
    if ((v8 & 1024) != 0) {
        char v113 = SearchElementNameByLocation((int32_t)&v11, NULL, (int32_t **)&g279, (int32_t **)&g279, (char)&g279); // 0x80cb1c9
        if (v113 == 0) {
            goto lab_0x80cab76;
        } else {
            int32_t v114 = *(int32_t *)v110; // 0x80cb1e6
            int32_t v115 = *(int32_t *)(v110 + 4); // 0x80cb1f1
            __frontend_reg_store_fpr(v2, (float80_t)(*(int32_t *)(v110 + 8) - v114));
            int3_t v116 = v1 - 2; // 0x80cb200
            __frontend_reg_store_fpr(v116, (float80_t)(*(int32_t *)(v110 + 12) - v115));
            __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v116) * __frontend_reg_load_fpr(v2));
            v25 = __frontend_reg_load_fpr(v2);
            v100 = 1024;
            goto lab_0x80cab92;
        }
    } else {
        goto lab_0x80cab76;
    }
  lab_0x80cab92:
    // 0x80cab92
    v24 = v100;
    int32_t v101 = (int32_t)PCB; // 0x80cab92
    int32_t v102 = *(int32_t *)(v101 + 0x220c); // 0x80cab98
    uint32_t v103 = *(int32_t *)(v102 + 24); // 0x80cab9e
    int32_t v104 = v5; // 0x80caba4
    if (v103 >= 0xffffffff) {
        // 0x80cabaa
        v26 = Result3;
        v27 = v1 - 2;
        v28 = v1 - 3;
        v29 = v1 ^ -4;
        v30 = v1 + 3;
        v86 = Result3;
        v87 = Result3;
        v88 = Result3;
        v89 = -1;
        v90 = v103;
        v91 = v101;
        v92 = v102;
        while (true) {
          lab_0x80cac08:;
            int32_t v93 = v92;
            v21 = v91;
            int32_t v94 = v90;
            v83 = v89;
            v19 = v88;
            v17 = v87;
            v15 = v86;
            if (v83 == -1) {
                int32_t v95 = v93 + 76 + 92 * (v94 + (int32_t)(g177 == 0)); // 0x80caec7
                *(int32_t *)&SearchLayer = v95;
                v13 = v95;
                goto lab_0x80cac3f;
            } else {
                if (v94 > v83) {
                    int32_t v96 = *(int32_t *)(4 * v83 + (int32_t)&LayerStack); // 0x80cac27
                    int32_t v97 = v93 + 76 + 92 * v96; // 0x80cac2f
                    *(int32_t *)&SearchLayer = v97;
                    v13 = v97;
                    goto lab_0x80cac3f;
                } else {
                    int32_t v98 = v93 + 76 + 92 * (v94 + (int32_t)(g177 != 0)); // 0x80cae8f
                    *(int32_t *)&SearchLayer = v98;
                    v13 = v98;
                    v16 = v15;
                    v18 = v17;
                    v20 = v19;
                    v22 = v21;
                    if (*(char *)&g203 == 0) {
                        goto lab_0x80cae27;
                    } else {
                        goto lab_0x80cac3f;
                    }
                }
            }
        }
      lab_0x80cae43:
        // 0x80cae43
        v104 = (int32_t)v81;
    }
    goto lab_0x80cae49;
  lab_0x80cab76:
    if ((v8 & 2) != 0) {
        char v108 = SearchElementByLocation((int32_t)&v11, NULL, (int32_t **)&g279, (int32_t **)&g279, (char)&g279); // 0x80cb15b
        if (v108 == 0) {
            goto lab_0x80cab80;
        } else {
            int32_t v109 = *(int32_t *)v110; // 0x80cb178
            int32_t v111 = *(int32_t *)(v110 + 4); // 0x80cb183
            __frontend_reg_store_fpr(v2, (float80_t)(*(int32_t *)(v110 + 8) - v109));
            float80_t v112 = __frontend_reg_load_fpr(v2); // 0x80cb18c
            __frontend_reg_store_fpr(v2, (float80_t)(*(int32_t *)(v110 + 12) - v111));
            __frontend_reg_store_fpr(v2, v112 * __frontend_reg_load_fpr(v2));
            v25 = __frontend_reg_load_fpr(v2);
            v100 = 2;
            goto lab_0x80cab92;
        }
    } else {
        goto lab_0x80cab80;
    }
  lab_0x80cae49:
    // 0x80cae49
    if ((v24 & 256) != 0) {
        // 0x80cae59
        *(int32_t *)v104 = v11;
        // 0x80cad76
        return 256;
    }
    if ((v24 & 512) != 0) {
        // 0x80cb0b6
        *(int32_t *)v104 = v11;
        // 0x80cad76
        return 512;
    }
    if ((v24 & 1024) != 0) {
        // 0x80cb118
        *(int32_t *)v104 = v11;
        // 0x80cad76
        return 1024;
    }
    if ((v24 & 2) != 0) {
        // 0x80cb21c
        *(int32_t *)v104 = v11;
        // 0x80cad76
        return 2;
    }
    // 0x80cb23b
    if (*(char *)&g203 == 0) {
        // 0x80cad76
        return 0;
    }
    if ((v8 & 512) != 0) {
        char v105 = SearchPadByLocation(v104, (int32_t **)1, (int32_t **)&g279, (int32_t **)&g279, (char)&g279); // 0x80cb2d8
        if (v105 != 0) {
            // 0x80cad76
            return 512;
        }
    }
    if ((v8 & 1024) != 0) {
        char v106 = SearchElementNameByLocation(v104, (int32_t **)1, (int32_t **)&g279, (int32_t **)&g279, (char)&g279); // 0x80cb2ac
        if (v106 != 0) {
            // 0x80cad76
            return 1024;
        }
    }
    if ((v8 & 2) == 0) {
        // 0x80cad76
        return 0;
    }
    char v107 = SearchElementByLocation(v104, (int32_t **)1, (int32_t **)&g279, (int32_t **)&g279, (char)&g279); // 0x80cb280
    result = 2;
    if (v107 == 0) {
        // 0x80cad76
        return 0;
    }
  lab_0x80cad76:
    // 0x80cad76
    return result;
  lab_0x80cab80:
    // 0x80cab80
    __frontend_reg_store_fpr(v2, 0.0L);
    v25 = __frontend_reg_load_fpr(v2);
    v100 = 0;
    goto lab_0x80cab92;
  lab_dec_label_pc_unknown:
    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2));
    result = 8;
    v104 = v31;
    if (v23 || v32) {
        goto lab_0x80cad76;
    } else {
        goto lab_0x80cae49;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80cb300 - 0x80cb342
// Line range:    1586 - 1594
int32_t SearchScreen(int32_t X, int32_t Y, int32_t Type, char ** Result1, char ** Result2, char ** Result3) {
    // 0x80cb300
    return SearchObjectByLocation(Type, Result1, Result2, Result3, X, Y, 5 * pixel_slop);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/select.c
// Address range: 0x80cc0c0 - 0x80cc29d
// Line range:    484 - 547
char * ObjectOperation(int32_t * F, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3) {
    int32_t v1 = (int32_t)F;
    if (Type == 32) {
        int32_t v2 = *(int32_t *)(v1 + 44); // 0x80cc288
        if (v2 != 0) {
            // 0x80cc1c9
            return (char *)v2;
        }
        // 0x80cc1a8
        return NULL;
    }
    if (Type <= 32) {
        if (Type == 4) {
            int32_t v3 = *F; // 0x80cc270
            if (v3 != 0) {
                // 0x80cc178
                return (char *)v3;
            }
            // 0x80cc1a8
            return NULL;
        }
        if (Type > 4) {
            if (Type == 8) {
                int32_t v4 = *(int32_t *)(v1 + 8); // 0x80cc1e8
                if (v4 != 0) {
                    // 0x80cc178
                    return (char *)v4;
                }
                // 0x80cc1a8
                return NULL;
            }
            if (Type != 16) {
                // 0x80cc1a8
                return NULL;
            }
            int32_t v5 = *(int32_t *)(v1 + 4); // 0x80cc16a
            if (v5 != 0) {
                // 0x80cc178
                return (char *)v5;
            }
            // 0x80cc1a8
            return NULL;
        }
        if (Type == 1) {
            int32_t v6 = *(int32_t *)(v1 + 12); // 0x80cc200
            if (v6 != 0) {
                // 0x80cc1c9
                return (char *)v6;
            }
            // 0x80cc1a8
            return NULL;
        }
        if (Type != 2) {
            // 0x80cc1a8
            return NULL;
        }
        int32_t v7 = *(int32_t *)(v1 + 16); // 0x80cc1c2
        if (v7 != 0) {
            // 0x80cc1c9
            return (char *)v7;
        }
        // 0x80cc1a8
        return NULL;
    }
    if (Type == 1024) {
        int32_t v8 = *(int32_t *)(v1 + 20); // 0x80cc1d8
        if (v8 != 0) {
            // 0x80cc1c9
            return (char *)v8;
        }
        // 0x80cc1a8
        return NULL;
    }
    if (Type <= 1024) {
        switch (Type) {
            case 256: {
                int32_t v9 = *(int32_t *)(v1 + 24); // 0x80cc258
                if (v9 != 0) {
                    // 0x80cc178
                    return (char *)v9;
                }
                // break -> 0x80cc1a8
                break;
            }
            case 512: {
                int32_t v10 = *(int32_t *)(v1 + 28); // 0x80cc240
                if (v10 != 0) {
                    // 0x80cc178
                    return (char *)v10;
                }
                // break -> 0x80cc1a8
                break;
            }
        }
        // 0x80cc1a8
        return NULL;
    }
    switch (Type) {
        case 0x1000: {
            int32_t v11 = *(int32_t *)(v1 + 32); // 0x80cc228
            if (v11 != 0) {
                // 0x80cc132
                return (char *)v11;
            }
            // 0x80cc1a8
            return NULL;
        }
        case 0x4000: {
            int32_t v12 = *(int32_t *)(v1 + 40); // 0x80cc210
            if (v12 != 0) {
                // 0x80cc178
                return (char *)v12;
            }
            // 0x80cc1a8
            return NULL;
        }
    }
    if (Type != 2048) {
        // 0x80cc1a8
        return NULL;
    }
    int32_t v13 = *(int32_t *)(v1 + 36); // 0x80cc129
    if (v13 != 0) {
        // 0x80cc132
        return (char *)v13;
    }
    // 0x80cc1a8
    return NULL;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cee10 - 0x80cee41
// Line range:    107 - 115
void SetViaSize(int32_t Size, char Force) {
    if (Force != 0) {
        // 0x80cee3a
        g134 = Size;
        // 0x80cee3f
        return;
    }
    if ((uint32_t)(Size - 2000) >= 0x988eb1 || (int32_t)g135 + 399 >= Size) {
        // 0x80cee3f
        return;
    }
    // 0x80cee3a
    g134 = Size;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cee50 - 0x80cee81
// Line range:    121 - 129
void SetViaDrillingHole(uint32_t Size, char Force) {
    if (Force != 0) {
        // 0x80cee7a
        g135 = (char *)Size;
        // 0x80cee7f
        return;
    }
    if (Size >= 0x989681 || g134 - 399 <= Size) {
        // 0x80cee7f
        return;
    }
    // 0x80cee7a
    g135 = (char *)Size;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80ceec0 - 0x80ceed4
// Line range:    144 - 150
void SetKeepawayWidth(uint32_t Width) {
    if (Width <= 0x989680) {
        // 0x80ceecd
        g138 = Width;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cef00 - 0x80cef15
// Line range:    168 - 175
void SetChangedFlag(char New) {
    // 0x80cef00
    if (g199 != New) {
        // 0x80cef10
        g199 = New;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cef50 - 0x80cf029
// Line range:    337 - 350
void SetLocalRef(int32_t X, int32_t Y, char Showing) {
    if (Showing == 0) {
        // 0x80cef68
        if (g99 < 1) {
            // 0x80cefc0
            return;
        }
        // 0x80cef71
        HideCrosshair(0);
        g99 = 0;
        Marked = g100;
        g217 = g101;
        g218 = g102;
        // 0x80cefa5
        RestoreCrosshair(0);
        return;
    }
    // 0x80cefd0
    HideCrosshair(1);
    if (g99 == 0) {
        // 0x80cefe5
        g100 = Marked;
        g101 = g217;
        g102 = g218;
    }
    // 0x80cf009
    g217 = (int64_t)X;
    g218 = (int64_t)Y;
    *(char *)&Marked = 1;
    g99++;
    // 0x80cefa5
    RestoreCrosshair(0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cf0e0 - 0x80cf16a
// Line range:    181 - 193
void SetCrosshairRangeToBuffer(void) {
    // 0x80cf0e0
    if (g148 != 5) {
        // 0x80cf0f5
        return;
    }
    // 0x80cf100
    SetBufferBoundingBox((int32_t *)(28 * (int32_t)g149 + (int32_t)&Buffers));
    int32_t v1 = 28 * (int32_t)g149; // 0x80cf11a
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&Buffers); // 0x80cf127
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&Buffers + 4); // 0x80cf12d
    int32_t v4 = *(int32_t *)(v1 + (int32_t)&Buffers + 20); // 0x80cf138
    int32_t v5 = *(int32_t *)(v1 + (int32_t)&Buffers + 16); // 0x80cf147
    int32_t v6 = *(int32_t *)(v1 + (int32_t)&Buffers + 12); // 0x80cf14e
    int32_t v7 = *(int32_t *)(v1 + (int32_t)&Buffers + 8); // 0x80cf155
    SetCrosshairRange(v2 - v7, v3 - v6, Marked + v2 - v5, v3 - v4 + (int32_t)(float32_t)g217);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cf170 - 0x80cf431
// Line range:    237 - 298
void SetMode(int32_t Mode) {
    // 0x80cf170
    if (g103 != 0) {
        // 0x80cf183
        return;
    }
    // 0x80cf190
    g103 = 1;
    HideCrosshair(1);
    addedLines = 0;
    g243 = 0;
    g244 = 0;
    g241 = 0;
    bool v1; // 0x80cf170
    int32_t v2; // 0x80cf170
    int32_t v3; // 0x80cf170
    int32_t v4; // 0x80cf170
    int32_t v5; // 0x80cf170
    char v6; // 0x80cf170
    int32_t v7; // 0x80cf2e2
    if (g206 != 0) {
        switch (Mode) {
            case 109: {
                goto lab_0x80cf2a8;
            }
            case 4: {
                goto lab_0x80cf2a8;
            }
            case 3: {
                goto lab_0x80cf2a8;
            }
            case 108: {
                goto lab_0x80cf2a8;
            }
            case 106: {
                goto lab_0x80cf2a8;
            }
            case 6: {
                goto lab_0x80cf2a8;
            }
            case 1: {
                goto lab_0x80cf2a8;
            }
            default: {
                // 0x80cf2e2
                v7 = g148;
                v4 = v7 == 2;
                goto lab_0x80cf1fa;
            }
        }
    } else {
        int32_t v8 = g148 == 2; // 0x80cf1e2
        v7 = g148;
        v4 = v8;
        if (Mode == 109 == g148 == 2) {
            // 0x80cf1ec
            v1 = false;
            v5 = v8;
            v6 = 0;
            v2 = 109;
            if (g233 != 0) {
                int32_t v9 = (int32_t)g229;
                g233 = 0;
                g239 = 1;
                *(int32_t *)&g237 = v9;
                *(int32_t *)&g235 = v9;
                g238 = g230;
                g236 = g230;
                AdjustAttachedObjects();
                v3 = 109;
                goto lab_0x80cf367;
            } else {
                goto lab_0x80cf223;
            }
        } else {
            goto lab_0x80cf1fa;
        }
    }
  lab_0x80cf2a8:
    // 0x80cf2a8
    Message("That mode is NOT allowed when drawing ratlines!\n");
    v1 = g148 == 109;
    v5 = g148 == 2;
    v6 = 0;
    v2 = 0;
    goto lab_0x80cf223;
  lab_0x80cf1fa:
    // 0x80cf1fa
    v1 = v7 == 109;
    v5 = v4;
    v6 = Mode == 2;
    v2 = Mode;
    int32_t v12; // 0x80cf170
    char v13; // 0x80cf170
    if (Mode == 2 == v7 == 109) {
        // 0x80cf20c
        v12 = 2;
        v13 = 1;
        if (g239 != 0) {
            int32_t v15 = (int32_t)g235;
            g239 = 0;
            g233 = 1;
            g148 = 2;
            *(int32_t *)&g231 = v15;
            *(int32_t *)&g229 = v15;
            g232 = g236;
            g230 = g236;
            AdjustAttachedObjects();
            v3 = 2;
            goto lab_0x80cf367;
        } else {
            goto lab_0x80cf330;
        }
    } else {
        goto lab_0x80cf223;
    }
  lab_0x80cf223:;
    int32_t v10 = v2; // 0x80cf225
    char v11 = v6; // 0x80cf225
    v12 = v2;
    v13 = v6;
    if (!v1 == (char)v5 == 0) {
        goto lab_0x80cf233;
    } else {
        goto lab_0x80cf330;
    }
  lab_0x80cf233:
    // 0x80cf233
    g239 = 0;
    g233 = 0;
    if (v11 != 0) {
        // 0x80cf358
        v3 = v10;
        if (*(char *)&vyl < 0) {
            // 0x80cf400
            SaveUndoSerialNumber();
            ResetFoundPinsViasAndPads(1);
            RestoreUndoSerialNumber();
            ResetFoundLinesAndPolygons(1);
            IncrementUndoSerialNumber();
            v3 = v10;
        }
        goto lab_0x80cf367;
    } else {
        // 0x80cf24f
        g148 = v10;
        if (v10 == 5) {
            // 0x80cf25e
            SetCrosshairRangeToBuffer();
            // 0x80cf263
            g103 = 0;
            MoveCrosshairRelative(0, 0);
            RestoreCrosshair(1);
            return;
        }
        // 0x80cf2f8
        goto lab_0x80cf2fd;
    }
  lab_0x80cf330:
    // 0x80cf330
    SetLocalRef(0, 0, 0);
    v10 = v12;
    v11 = v13;
    goto lab_0x80cf233;
  lab_0x80cf367:
    // 0x80cf367
    g148 = v3;
    goto lab_0x80cf2fd;
  lab_0x80cf2fd:;
    int32_t v14 = (int32_t)PCB;
    SetCrosshairRange(0, 0, *(int32_t *)(v14 + 144), *(int32_t *)(v14 + 148));
    // 0x80cf263
    g103 = 0;
    MoveCrosshairRelative(0, 0);
    RestoreCrosshair(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cf4a0 - 0x80cf4e0
// Line range:    93 - 101
void SetLineSize(int32_t Size) {
    if ((uint32_t)(Size - 1) >= 0x989680) {
        // 0x80cf4c4
        return;
    }
    // 0x80cf4b4
    g136 = Size;
    if (*(char *)&vyl >= 0) {
        // 0x80cf4c4
        return;
    }
    // 0x80cf4c8
    FitCrosshairIntoGrid((int32_t)(float32_t)g222, (int32_t)(float32_t)g223);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cf5c0 - 0x80cf651
// Line range:    158 - 168
char * alloc_buf(int32_t len) {
    // 0x80cf5c0
    int32_t v1; // 0x80cf5c0
    uint32_t size = v1 + 1; // 0x80cf5d3
    int32_t v2 = (bufptr + 1) % 10;
    int32_t v3 = 8 * v2;
    bufptr = v2;
    if (size <= *(int32_t *)(v3 + (int32_t)&g110)) {
        // 0x80cf62c
        return (char *)*(int32_t *)(v3 + (int32_t)&buffers);
    }
    int32_t * v4 = (int32_t *)(v3 + (int32_t)&buffers); // 0x80cf601
    int32_t v5 = *v4; // 0x80cf601
    int32_t * mem; // 0x80cf5c0
    if (v5 == 0) {
        // 0x80cf640
        mem = malloc(size);
    } else {
        // 0x80cf60c
        mem = realloc((int32_t *)v5, size);
    }
    // 0x80cf61f
    *v4 = (int32_t)mem;
    int32_t v6 = 8 * bufptr;
    *(int32_t *)(v6 + (int32_t)&g110) = size;
    // 0x80cf62c
    return (char *)*(int32_t *)(v6 + (int32_t)&buffers);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cf660 - 0x80cf6f4
// Line range:    186 - 190
void grow_layer_list(int32_t num) {
    // 0x80cf660
    int32_t v1; // 0x80cf660
    int32_t v2 = v1;
    int32_t v3 = layers; // 0x80cf669
    int32_t v4; // 0x80cf660
    if (v3 == 0) {
        int32_t mem = (int32_t)calloc(v2 >= 0 == (v2 != 0) ? v2 : 1, 1); // 0x80cf6e2
        layers = mem;
        v4 = mem;
    } else {
        // 0x80cf672
        v4 = v3;
        if (v2 > max_layers) {
            int32_t mem2 = (int32_t)realloc((int32_t *)v3, v2); // 0x80cf6bd
            layers = mem2;
            v4 = mem2;
        }
    }
    int32_t v5 = num_layers; // 0x80cf67a
    if (v2 > v5) {
        // 0x80cf683
        memset((int32_t *)(v5 + v4), 0, v2 + -1 - v5);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cf700 - 0x80cfd50
// Line range:    474 - 553
char * common_flags_to_string(int32_t flags, int32_t object_type, int32_t * flagbits, int32_t n_flagbits) {
    // 0x80cf700
    int32_t v1; // 0x80cf700
    char v2 = v1; // 0x80cf723
    int32_t v3 = __readgsdword(20); // 0x80cf751
    char v4 = v2; // bp-40, 0x80cf7bf
    int32_t v5; // 0x80cf700
    switch (flags) {
        case 32: {
            // 0x80cfd1d
            v5 = v1 & -17;
            // break -> 0x80cf7e0
            break;
        }
        case 256: {
            // 0x80cfd0e
            v5 = v1 & -2;
            // break -> 0x80cf7e0
            break;
        }
        case 1: {
            // 0x80cfc2d
            v5 = v1 & -3;
            // break -> 0x80cf7e0
            break;
        }
    }
    uint32_t v6 = (int32_t)flagbits;
    int32_t v7 = 0; // 0x80cf7ea
    if (flagbits >= (int32_t *)1) {
        int32_t v8 = v5; // 0x80cf803
        int32_t v9; // 0x80cf805
        if ((*(int32_t *)(object_type + 12) & flags) != 0) {
            // 0x80cf805
            v9 = *(int32_t *)object_type;
            v8 = v5;
            if ((v9 & v5) != 0) {
                // 0x80cf80c
                v8 = v5 & -1 - v9;
            }
        }
        // 0x80cf818
        v7++;
        int32_t v10 = object_type + 16; // 0x80cf821
        while (v7 != v6) {
            int32_t v11 = v10;
            int32_t v12 = v8;
            v8 = v12;
            if ((*(int32_t *)(v11 + 12) & flags) != 0) {
                // 0x80cf805
                v9 = *(int32_t *)v11;
                v8 = v12;
                if ((v9 & v12) != 0) {
                    // 0x80cf80c
                    v8 = v12 & -1 - v9;
                }
            }
            // 0x80cf818
            v7++;
            v10 = v11 + 16;
        }
    }
    // 0x80cf829
    mem_any_set(&v4, 8);
    char * result = alloc_buf((int32_t)&g279); // 0x80cf8a0
    *result = 34;
    int32_t v13 = (int32_t)result + 1; // 0x80cf8ab
    v4 = v2;
    int32_t v14 = 0; // 0x80cf903
    int32_t v15 = v13; // 0x80cf903
    if (flagbits >= (int32_t *)1) {
        int32_t v16 = v5; // 0x80cf91b
        int32_t v17 = v13; // 0x80cf91b
        int32_t str; // 0x80cf700
        int32_t * v18; // 0x80cf91d
        if ((*(int32_t *)(object_type + 12) & flags) != 0) {
            // 0x80cf91d
            v18 = (int32_t *)object_type;
            v16 = v5;
            v17 = v13;
            if ((*v18 & v5) != 0) {
                // 0x80cf924
                str = v13;
                // 0x80cf92f
                strcpy((char *)str, (char *)*(int32_t *)(object_type + 4));
                v16 = v5 & -1 - *v18;
                v17 = *(int32_t *)(object_type + 8) + str;
            }
        }
        int32_t v19 = v17;
        v14++;
        int32_t v20 = object_type + 16; // 0x80cf968
        v15 = v19;
        while (v14 < v6) {
            int32_t v21 = v20;
            int32_t v22 = v19;
            int32_t v23 = v16;
            v16 = v23;
            v17 = v22;
            if ((*(int32_t *)(v21 + 12) & flags) != 0) {
                // 0x80cf91d
                v18 = (int32_t *)v21;
                v16 = v23;
                v17 = v22;
                if ((*v18 & v23) != 0) {
                    // 0x80cf924
                    str = v13;
                    if (v22 != v13) {
                        // 0x80cf929
                        *(char *)v22 = 44;
                        str = v22 + 1;
                    }
                    // 0x80cf92f
                    strcpy((char *)str, (char *)*(int32_t *)(v21 + 4));
                    v16 = v23 & -1 - *v18;
                    v17 = *(int32_t *)(v21 + 8) + str;
                }
            }
            // 0x80cf960
            v19 = v17;
            v14++;
            v20 = v21 + 16;
            v15 = v19;
        }
    }
    int32_t v24 = mem_any_set(&v4, 8); // 0x80cf980
    int32_t v25 = v15; // 0x80cf98d
    char * str4; // 0x80cf700
    int32_t v26; // 0x80cf700
    int32_t v27; // 0x80cf700
    int32_t v28; // 0x80cf700
    int32_t v29; // 0x80cf700
    int32_t v30; // 0x80cf700
    int32_t v31; // 0x80cf700
    int32_t v32; // 0x80cf700
    int32_t v33; // 0x80cf700
    int32_t v34; // 0x80cf700
    char * v35; // 0x80cf700
    char * v36; // 0x80cf700
    int32_t v37; // 0x80cfb3e
    if (v24 != 0) {
        int32_t v38 = v13; // 0x80cf996
        if (v15 != v13) {
            // 0x80cf998
            *(char *)v15 = 44;
            v38 = v15 + 1;
        }
        // 0x80cf99e
        *(int32_t *)v38 = 0x72656874;
        *(int32_t *)(v38 + 4) = 0x6c616d;
        int32_t v39 = v38 + 7; // 0x80cf9af
        grow_layer_list(v39);
        int32_t v40 = num_layers; // 0x80cf9c9
        int32_t v41 = 0; // 0x80cf9c9
        int32_t v42; // 0x80cf700
        while (true) {
            int32_t v43 = v41;
            int32_t v44; // bp-4, 0x80cf700
            unsigned char v45 = *(char *)((int32_t)&v44 - 36 + (v43 >> 1)); // 0x80cf9e9
            uint32_t v46 = (int32_t)v45; // 0x80cf9e9
            uint32_t v47 = 4 * v43 & 4; // 0x80cf9ee
            int32_t v48; // 0x80cf700
            if ((15 << v47 & v46) == 0) {
                // 0x80cf9d0
                v48 = num_layers;
                v42 = num_layers;
                if (v43 == 15) {
                    // break -> 0x80cfa1d
                    break;
                }
            } else {
                int32_t v49 = v40; // 0x80cf9fe
                if (v43 >= v40) {
                    // 0x80cfa98
                    grow_layer_list(v47);
                    v49 = num_layers;
                }
                // 0x80cfa04
                *(char *)(layers + v43) = (char)(v46 >> v47) % 16;
                v48 = v49;
                v42 = v49;
                if (v43 == 15) {
                    // break -> 0x80cfa1d
                    break;
                }
            }
            // 0x80cf9e0
            v40 = v48;
            v41 = v43 + 1;
        }
        char v50 = 2; // 0x80cfa28
        if (v42 >= 1) {
            uint32_t v51 = 0;
            char v52 = 2;
            char v53 = v52; // 0x80cfa5c
            int32_t v54; // 0x80cf700
            int32_t v55; // 0x80cf700
            int32_t v56; // 0x80cf700
            int32_t v57; // 0x80cf700
            int32_t v58; // 0x80cf700
            int32_t v59; // 0x80cfa88
            if (*(char *)(v51 + layers) != 0) {
                // 0x80cfa5e
                v54 = 2;
                if (v51 >= 10) {
                    // 0x80cfa68
                    v54 = 3;
                    v55 = v51;
                    if (v51 >= 100) {
                        v58 = 1;
                        v56 = v55;
                        v59 = ((int32_t)(0x66666667 * (int64_t)v56 / 0x100000000) >> 2) - (int32_t)(v56 < 0);
                        v57 = v58 + 1;
                        while (v59 > 9) {
                            // 0x80cfa78
                            v58 = v57;
                            v56 = v59;
                            v59 = ((int32_t)(0x66666667 * (int64_t)v56 / 0x100000000) >> 2) - (int32_t)(v56 < 0);
                            v57 = v58 + 1;
                        }
                        // 0x80cfa91
                        v54 = v58 + 2;
                    }
                }
                // 0x80cfa40
                v53 = (int32_t)v52 + 1 + v54;
            }
            char v60 = v53;
            int32_t v61 = v51 + 1; // 0x80cfa4a
            v50 = v60;
            while (v61 != v42) {
                // 0x80cfa55
                v51 = v61;
                v52 = v60;
                v53 = v52;
                if (*(char *)(v51 + layers) != 0) {
                    // 0x80cfa5e
                    v54 = 2;
                    if (v51 >= 10) {
                        // 0x80cfa68
                        v54 = 3;
                        v55 = v51;
                        if (v51 >= 100) {
                            v58 = 1;
                            v56 = v55;
                            v59 = ((int32_t)(0x66666667 * (int64_t)v56 / 0x100000000) >> 2) - (int32_t)(v56 < 0);
                            v57 = v58 + 1;
                            while (v59 > 9) {
                                // 0x80cfa78
                                v58 = v57;
                                v56 = v59;
                                v59 = ((int32_t)(0x66666667 * (int64_t)v56 / 0x100000000) >> 2) - (int32_t)(v56 < 0);
                                v57 = v58 + 1;
                            }
                            // 0x80cfa91
                            v54 = v58 + 2;
                        }
                    }
                    // 0x80cfa40
                    v53 = (int32_t)v52 + 1 + v54;
                }
                // 0x80cfa4a
                v60 = v53;
                v61 = v51 + 1;
                v50 = v60;
            }
        }
        int32_t size = v50; // 0x80cfb12
        char * v62 = g109;
        int32_t v63 = (int32_t)v62; // 0x80cfb1b
        int32_t v64 = v42; // 0x80cfb1b
        if (g108 < size) {
            int32_t * mem; // 0x80cf700
            if (v62 == NULL) {
                // 0x80cfd2c
                mem = malloc(size);
            } else {
                // 0x80cfc05
                mem = realloc((int32_t *)v62, size);
            }
            // 0x80cfc19
            g109 = (char *)mem;
            v64 = num_layers;
            g108 = size;
            v63 = (int32_t)mem;
        }
        int32_t v65 = v63 + 1; // 0x80cfb26
        char * v66 = (char *)v63;
        *v66 = 40;
        char * str3 = v66; // 0x80cfb31
        int32_t v67 = v65; // 0x80cfb31
        v29 = v65;
        v26 = v64;
        v33 = 0;
        if (v64 >= 1) {
            while (true) {
              lab_0x80cfb38:
                // 0x80cfb38
                v34 = v33;
                v30 = v29;
                v37 = v34 + 1;
                int32_t v68 = layers + v34; // 0x80cfb41
                char v69 = *(char *)v68; // 0x80cfb44
                v31 = v30;
                v28 = v37;
                if (v69 == 0) {
                    goto lab_0x80cfbe3;
                } else {
                    int32_t v70 = v26;
                    int32_t v71 = v37; // 0x80cfb57
                    if (v70 > v37) {
                        int32_t v72 = v68; // 0x80cfb62
                        int32_t v73 = v37; // 0x80cfb62
                        v71 = v37;
                        if (*(char *)(v37 + layers) == 1) {
                            int32_t v74 = v73 + 1; // 0x80cfb7c
                            v71 = v74;
                            while (v70 > v74) {
                                int32_t v75 = v72;
                                v72 = v75 + 1;
                                v73 = v74;
                                v71 = v74;
                                if (*(char *)(v75 + 2) != 1) {
                                    // break -> 0x80cfb83
                                    break;
                                }
                                v74 = v73 + 1;
                                v71 = v74;
                            }
                        }
                    }
                    int32_t v76 = v71;
                    if (v34 + 2 < v76) {
                        char * v77 = (char *)v30;
                        __sprintf_chk(v77, 1, -1, "%d-%d,", v34, v76 - 1);
                        str4 = v77;
                        v27 = v76;
                        goto lab_0x80cfbd5;
                    } else {
                        // 0x80cfb8e
                        v36 = "%d+,";
                        if (v69 == 2) {
                            goto lab_0x80cfbba;
                        } else {
                            if (v69 > 2) {
                                if (v69 == 3) {
                                    char * v78 = (char *)v30;
                                    __sprintf_chk(v78, 1, -1, "%dS,", v34);
                                    str4 = v78;
                                    v27 = v37;
                                    goto lab_0x80cfbd5;
                                } else {
                                    // 0x80cfc7e
                                    v36 = "%dt,";
                                    v35 = "%dX,";
                                    if (v69 != 4) {
                                        goto lab_0x80cfbba;
                                    } else {
                                        goto lab_0x80cfc9a;
                                    }
                                }
                            } else {
                                // 0x80cfb9e
                                v36 = "%dt,";
                                v35 = "%d,";
                                if (v69 == 1) {
                                    goto lab_0x80cfc9a;
                                } else {
                                    goto lab_0x80cfbba;
                                }
                            }
                        }
                    }
                }
            }
          lab_0x80cfab8:
            // 0x80cfab8
            str3 = g109;
            v67 = v32;
        }
        // 0x80cfabd
        *(char *)(v67 - 1) = 41;
        *(char *)v67 = 0;
        char * str2 = (char *)v39; // 0x80cfad1
        strcpy(str2, str3);
        v25 = strlen(str2) + v39;
    }
    // 0x80cfae6
    *(char *)v25 = 34;
    *(char *)(v25 + 1) = 0;
    if (v3 != __readgsdword(20)) {
        // 0x80cfd41
        __stack_chk_fail();
        return (char *)&g279;
    }
    // 0x80cfb00
    return result;
  lab_0x80cfbe3:
    // 0x80cfbe3
    v32 = v31;
    v29 = v32;
    v26 = num_layers;
    v33 = v28;
    if (num_layers <= v28) {
        // break -> 0x80cfab8
        goto lab_0x80cfab8;
    }
    goto lab_0x80cfb38;
  lab_0x80cfbd5:
    // 0x80cfbd5
    v31 = strlen(str4) + v30;
    v28 = v27;
    goto lab_0x80cfbe3;
  lab_0x80cfbba:;
    char * v79 = (char *)v30;
    __sprintf_chk(v79, 1, -1, v36, v34);
    str4 = v79;
    v27 = v37;
    goto lab_0x80cfbd5;
  lab_0x80cfc9a:;
    char * v80 = (char *)v30;
    __sprintf_chk(v80, 1, -1, v35, v34);
    str4 = v80;
    v27 = v37;
    goto lab_0x80cfbd5;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cfd50 - 0x80cfd7d
// Line range:    565 - 571
char * pcbflags_to_string(int32_t flags) {
    char * result = common_flags_to_string(-1, (int32_t)&pcb_flagbits, (int32_t *)22, (int32_t)&g279); // 0x80cfd76
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cfd80 - 0x80cfdac
// Line range:    556 - 562
char * flags_to_string(int32_t flags, int32_t object_type) {
    // 0x80cfd80
    int32_t v1; // 0x80cfd80
    char * result = common_flags_to_string(v1, (int32_t)&object_flagbits, (int32_t *)23, (int32_t)&g279); // 0x80cfda5
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cfdb0 - 0x80d0243
// Line range:    379 - 439
int32_t common_string_to_flags(char * flagstring, int32_t (*error)(char *), int32_t * flagbits, int32_t n_flagbits) {
    // 0x80cfdb0
    int32_t result; // 0x80cfdb0
    int32_t v1 = result;
    int32_t v2 = __readgsdword(20); // 0x80cfdc5
    char v3; // 0x80cfdb0
    char v4; // 0x80cfdb0
    int32_t v5; // 0x80cfdb0
    int32_t v6; // 0x80cfdb0
    int32_t v7; // 0x80cfdb0
    int32_t v8; // 0x80cfdb0
    int32_t v9; // 0x80cfdb0
    if (result == 0) {
        // 0x80d021f
        __asm_rep_movsd_memcpy((char *)result, (char *)&empty_flags, 3);
        goto lab_0x80cff5a;
    } else {
        char v10 = result;
        char v11 = v10; // 0x80cfe0a
        int32_t v12; // 0x80cfdb0
        if (v10 == 34) {
            int32_t v13 = result + 1; // 0x80d0210
            v11 = *(char *)v13;
            v12 = v13;
        }
        // 0x80cfe10
        v5 = v12;
        v7 = 0;
        v3 = v11;
        v6 = v12;
        v8 = 0;
        v4 = 44;
        v9 = 0;
        switch (v11) {
            case 34: {
                goto lab_0x80cff40;
            }
            case 0: {
                goto lab_0x80cff40;
            }
            case 44: {
                goto lab_0x80cfef2;
            }
            default: {
                goto lab_0x80cfe38;
            }
        }
    }
  lab_0x80cfe91:;
    // 0x80cfe91
    int32_t v14; // 0x80cfdb0
    int32_t v15 = v14;
    if (error > NULL) {
        int32_t v16 = 0; // 0x80cfea0
        int32_t v17 = (int32_t)flagstring; // 0x80cfea0
        int32_t v18; // 0x80cfdb0
        int32_t v19; // 0x80cfdb0
        int32_t v20; // 0x80cfdb0
        int32_t v21; // 0x80cfdb0
        int32_t v22; // 0x80cfdb0
        int32_t v23; // 0x80cfdb0
        int32_t v24; // 0x80cfdb0
        int32_t v25; // 0x80cfdb0
        char v26; // 0x80cfec3
        if (*(int32_t *)(v17 + 8) == v15) {
            // 0x80cfebb
            if (v15 == 0) {
                // 0x80cfec7
                goto lab_0x80cfecc;
            }
            v23 = *(int32_t *)(v18 + 4);
            v26 = *(char *)v24;
            v19 = v15 - 1;
            v22 = v23 + v25;
            v21 = v24 + v25;
            while (*(char *)v23 == v26) {
                v20 = v19;
                if (v20 == 0) {
                    // 0x80cfec7
                    goto lab_0x80cfecc;
                }
                v26 = *(char *)v21;
                v19 = v20 - 1;
                v22 += v25;
                v21 += v25;
            }
        }
        // 0x80cfea8
        v16++;
        v17 += 16;
        while (v16 < (int32_t)error) {
            // 0x80cfeb3
            if (*(int32_t *)(v17 + 8) == v15) {
                // 0x80cfebb
                v20 = v15;
                if (v20 == 0) {
                    // 0x80cfec7
                    goto lab_0x80cfecc;
                }
                v23 = *(int32_t *)(v18 + 4);
                v26 = *(char *)v24;
                v19 = v20 - 1;
                v22 = v23 + v25;
                v21 = v24 + v25;
                while (*(char *)v23 == v26) {
                    v20 = v19;
                    if (v20 == 0) {
                        // 0x80cfec7
                        goto lab_0x80cfecc;
                    }
                    v26 = *(char *)v21;
                    v19 = v20 - 1;
                    v22 += v25;
                    v21 += v25;
                }
            }
            // 0x80cfea8
            v16++;
            v17 += 16;
        }
    }
    char * v27 = alloc_buf((int32_t)&g279); // 0x80cfefe
    int32_t v28; // 0x80cfdb0
    __sprintf_chk(v27, 1, -1, "Unknown flag: \"%.*s\" ignored", v15, (char *)v28);
    int32_t v29; // 0x80cfdb0
    char v30 = *(char *)v29; // 0x80cff39
    int32_t v31; // 0x80cfdb0
    int32_t v32 = v31; // 0x80cff3e
    int32_t v33 = v29; // 0x80cff3e
    char v34 = v30; // 0x80cff3e
    v9 = v31;
    if (v30 != 34) {
        goto lab_0x80cfed6;
    } else {
        goto lab_0x80cff40;
    }
  lab_0x80cfe88:;
    // 0x80cfe88
    int32_t v35; // 0x80cfdb0
    v28 = v35;
    int32_t v36; // 0x80cfdb0
    v31 = v36;
    int32_t v37; // 0x80cfdb0
    v29 = v37;
    int32_t v38; // 0x80cfdb0
    v14 = v38;
    int32_t v39 = v35; // 0x80cfe8b
    int32_t v40 = v36; // 0x80cfe8b
    int32_t v41 = v37; // 0x80cfe8b
    int32_t v42 = 7; // 0x80cfe8b
    if (v38 == 7) {
        goto lab_0x80cff89;
    } else {
        goto lab_0x80cfe91;
    }
  lab_0x80d00a9:;
    // 0x80d00a9
    int32_t v43; // 0x80d0078
    int32_t v44 = v43 + 1; // 0x80d00a9
    char v45 = *(char *)v44; // 0x80d00ac
    int32_t v46; // 0x80cfdb0
    v35 = v46;
    int32_t v47; // 0x80cfdb0
    v36 = v47;
    v37 = v44;
    int32_t v48; // 0x80cfdb0
    v38 = v48;
    int32_t v49 = v44; // 0x80d00b5
    int32_t v50; // 0x80cfdb0
    int32_t v51 = v50 + 1; // 0x80d00b5
    int32_t v52; // 0x80cfdb0
    int32_t v53 = v52; // 0x80d00b5
    int32_t v54; // 0x80cfdb0
    int32_t v55 = v54; // 0x80d00b5
    char v56 = v45; // 0x80d00b5
    int32_t v57; // 0x80cfdb0
    int32_t v58 = v57; // 0x80d00b5
    int32_t v59; // 0x80cfdb0
    int32_t v60 = v59; // 0x80d00b5
    if (v45 == 0) {
        goto lab_0x80cfe88;
    }
    goto lab_0x80d00bf;
  lab_0x80d00f8:;
    // 0x80d00f8
    int32_t v61; // 0x80cfdb0
    int32_t v76 = v61; // 0x80d00fb
    char v77; // 0x80cfdb0
    char v63; // 0x80d00e8
    int32_t v62; // 0x80cfdb0
    if (v62 == -1) {
        goto lab_0x80d0105;
    } else {
        // 0x80d0101
        v76 = v62;
        v77 = v63;
        if (v62 > v61) {
            goto lab_0x80d0147;
        } else {
            goto lab_0x80d0105;
        }
    }
  lab_0x80d00a0:;
    // 0x80d00a0
    int32_t v68; // 0x80cfdb0
    v52 = v68;
    int32_t v69; // 0x80cfdb0
    v54 = v69;
    int32_t v72; // 0x80cfdb0
    v59 = v72;
    int32_t v71; // 0x80cfdb0
    v57 = v71;
    char v70; // 0x80cfdb0
    if (v70 == 41) {
        // break -> 0x80d00d7
        goto lab_0x80d00d7;
    }
    goto lab_0x80d00a9;
  lab_0x80d0105:;
    int32_t v78 = v76; // 0x80d010d
    int32_t v65; // 0x80cfdb0
    int32_t v79 = v65 % 256; // 0x80d010d
    while (true) {
        int32_t v80 = v79;
        int32_t v81 = v78;
        int32_t v82 = v81 + 1; // 0x80d0125
        int32_t v83; // 0x80cfdb0
        if (num_layers > v81) {
            // 0x80d0110
            *(char *)(layers + v81) = (char)v80;
            v83 = v80;
            if (v82 > v61) {
                // break -> 0x80d0147
                break;
            }
        } else {
            uint32_t v84 = 0x1000000 * v80 >> 24; // 0x80d012c
            grow_layer_list(v84);
            *(char *)(layers + v81) = (char)v84;
            v83 = v84 % 256;
            if (v82 > v61) {
                // break -> 0x80d0147
                break;
            }
        }
        // 0x80d011d
        v78 = v82;
        v79 = v83;
    }
    // 0x80d0147
    v77 = *(char *)v43;
    goto lab_0x80d0147;
  lab_0x80d0147:
    // 0x80d0147
    v68 = 1;
    int32_t v64; // 0x80cfdb0
    v69 = v64;
    v70 = v77;
    v71 = -1;
    v72 = 0;
    v52 = 1;
    v54 = v64;
    v59 = 0;
    v57 = v61;
    if (v77 == 45) {
        goto lab_0x80d00a9;
    } else {
        goto lab_0x80d00a0;
    }
  lab_0x80cff5a:
    // 0x80cff5a
    if (v2 != __readgsdword(20)) {
        // 0x80d023c
        __stack_chk_fail();
        return string_to_pcbflags((char *)&g279, (int32_t (*)(char *))&g279);
    }
    // 0x80cff6d
    return result;
  lab_0x80cff40:
    // 0x80cff40
    *(int32_t *)result = v9;
    *(int32_t *)(result + 4) = g111;
    *(int32_t *)(result + 8) = g112;
    goto lab_0x80cff5a;
  lab_0x80cfef2:;
    int32_t v85 = v6; // 0x80cfef4
    int32_t v86 = v8; // 0x80cfef4
    int32_t v87 = v6; // 0x80cfef4
    char v88 = v4; // 0x80cfef4
    int32_t v89 = 0; // 0x80cfef4
    goto lab_0x80cfe80;
  lab_0x80cfe38:;
    char v118 = v3;
    int32_t v119 = v7;
    int32_t v120 = v5;
    v28 = v120;
    v31 = v119;
    v29 = v120;
    v14 = 0;
    v6 = v120;
    v8 = v119;
    v4 = 0;
    int32_t v93; // 0x80cfdb0
    int32_t v90; // 0x80cfdb0
    int32_t v92; // 0x80cfdb0
    int32_t v91; // 0x80cfdb0
    switch (v118) {
        case 0: {
            goto lab_0x80cfef2;
        }
        case 34: {
            goto lab_0x80cfe91;
        }
        default: {
            int32_t v121 = v120; // 0x80cfe4b
            v90 = v120;
            v91 = v119;
            v92 = v120;
            v93 = 0;
            if (v118 != 40) {
                int32_t v122; // 0x80cfe6e
                char v123; // 0x80cfe71
                while (true) {
                  lab_0x80cfe6e:
                    // 0x80cfe6e
                    v122 = v121 + 1;
                    v123 = *(char *)v122;
                    v121 = v122;
                    switch (v123) {
                        case 44: {
                            goto lab_0x80cfe78;
                        }
                        case 0: {
                            goto lab_0x80cfe78;
                        }
                        case 34: {
                            int32_t v124 = v122 - v120; // 0x80cff7a
                            v28 = v120;
                            v31 = v119;
                            v29 = v122;
                            v14 = v124;
                            v39 = v120;
                            v40 = v119;
                            v41 = v122;
                            v42 = v124;
                            if (v124 != 7) {
                                goto lab_0x80cfe91;
                            } else {
                                goto lab_0x80cff89;
                            }
                        }
                        case 40: {
                            // 0x80cfff0
                            v90 = v120;
                            v91 = v119;
                            v92 = v122;
                            v93 = v122 - v120;
                            goto lab_0x80cfff8;
                        }
                        default: {
                            goto lab_0x80cfe6e;
                        }
                    }
                }
              lab_0x80cfe78:
                // 0x80cfe78
                v85 = v120;
                v86 = v119;
                v87 = v122;
                v88 = v123;
                v89 = v122 - v120;
                goto lab_0x80cfe80;
            } else {
                goto lab_0x80cfff8;
            }
        }
    }
  lab_0x80cfe80:
    // 0x80cfe80
    v35 = v85;
    v36 = v86;
    v37 = v87;
    v38 = v89;
    v90 = v85;
    v91 = v86;
    v92 = v87;
    v93 = v89;
    if (v88 == 40) {
        goto lab_0x80cfff8;
    } else {
        goto lab_0x80cfe88;
    }
  lab_0x80cfff8:
    // 0x80cfff8
    v48 = v93;
    v47 = v91;
    v46 = v90;
    int32_t v94 = v92 + 1; // 0x80cfffa
    grow_layer_list(v94);
    char * str = (char *)v94; // 0x80d0006
    char v95 = *str; // 0x80d0006
    v35 = v46;
    v36 = v47;
    v37 = v94;
    v38 = v48;
    v49 = v94;
    v51 = 5;
    v53 = 1;
    v55 = v1 != 0 ? v1 : 0x80cf5b0;
    v56 = v95;
    v58 = -1;
    v60 = 0;
    if (v95 != 0) {
        while (true) {
          lab_0x80d00bf:
            // 0x80d00bf
            v61 = v60;
            v62 = v58;
            v63 = v56;
            v64 = v55;
            v50 = v51;
            v43 = v49;
            if (v63 != 43) {
                // 0x80d0040
                v65 = v53;
                v52 = 3;
                v54 = v64;
                v59 = v61;
                v57 = v62;
                switch (v63) {
                    case 83: {
                        goto lab_0x80d00a9;
                    }
                    case 88: {
                        // 0x80d0168
                        v52 = 4;
                        v54 = v64;
                        v59 = v61;
                        v57 = v62;
                        goto lab_0x80d00a9;
                    }
                    case 116: {
                        // 0x80d0178
                        v52 = 5;
                        v54 = v64;
                        v59 = v61;
                        v57 = v62;
                        goto lab_0x80d00a9;
                    }
                    case 44: {
                        goto lab_0x80d00f8;
                    }
                    case 41: {
                        goto lab_0x80d00f8;
                    }
                    case 45: {
                        goto lab_0x80d00f8;
                    }
                    default: {
                        int16_t * v66 = *__ctype_b_loc(); // 0x80d0086
                        char v67 = *(char *)((0x1000000 * (int32_t)v63 >> 23 | 1) + (int32_t)v66); // 0x80d0088
                        if ((v67 & 8) == 0) {
                            if (v64 == 0) {
                                // 0x80d0208
                                v68 = v65;
                                v69 = 0;
                                v70 = *(char *)v43;
                                v71 = v62;
                                v72 = v61;
                            } else {
                                // 0x80d018e
                                strlen(str);
                                char * v73 = alloc_buf((int32_t)&g279); // 0x80d019f
                                char * v74 = (char *)v43; // 0x80d01ac
                                char v75 = *v74; // 0x80d01ac
                                __sprintf_chk(v73, 1, -1, "Syntax error parsing layer list \"%.*s\" at %c", v50, str, v75);
                                v68 = v65;
                                v69 = 0;
                                v70 = *v74;
                                v71 = v62;
                                v72 = v61;
                            }
                        } else {
                            // 0x80d0093
                            v68 = v65;
                            v69 = v64;
                            v70 = *(char *)v43;
                            v71 = v62;
                            v72 = (int32_t)v63 - 48 + 10 * v61;
                        }
                        goto lab_0x80d00a0;
                    }
                }
            } else {
                // 0x80d00c8
                v52 = 2;
                v54 = v64;
                v59 = v61;
                v57 = v62;
                if (v63 == 41) {
                    // break -> 0x80d00d7
                    break;
                }
                goto lab_0x80d00a9;
            }
        }
      lab_0x80d00d7:
        // 0x80d00d7
        v35 = v46;
        v36 = v47;
        v37 = v43 + 1;
        v38 = v48;
    }
    goto lab_0x80cfe88;
  lab_0x80cfed6:
    // 0x80cfed6
    v9 = v32;
    if (v34 == 0) {
        goto lab_0x80cff40;
    } else {
        int32_t v96 = v33 + 1;
        char v97 = *(char *)v96; // 0x80cfee3
        v5 = v96;
        v7 = v32;
        v3 = v97;
        v6 = v96;
        v8 = v32;
        v4 = v97;
        if (v97 != 44) {
            goto lab_0x80cfe38;
        } else {
            goto lab_0x80cfef2;
        }
    }
  lab_0x80cff89:;
    int32_t v98 = v42;
    int32_t v99 = v41;
    int32_t v100 = v40;
    int32_t v101 = v39;
    bool v102; // 0x80cfdb0
    int32_t v103 = v102 ? -1 : 1; // 0x80cff96
    int32_t v104 = v101; // 0x80cff96
    int32_t v105 = (int32_t)"thermal"; // 0x80cff96
    int32_t v106 = 7;
    while (v106 != 0) {
        int32_t v107 = v104;
        char v108 = *(char *)v105; // 0x80cff96
        v28 = v101;
        v31 = v100;
        v29 = v99;
        v14 = v98;
        int32_t v109 = v106 - 1; // 0x80cff96
        v104 = v107 + v103;
        v105 += v103;
        if (*(char *)v107 != v108) {
            goto lab_0x80cfe91;
        }
        v106 = v109;
    }
    uint32_t v110 = 0;
    while (num_layers > v110) {
        unsigned char v111 = *(char *)(v110 + layers); // 0x80cffb9
        if (v111 != 0) {
            uint32_t v112 = 4 * v110 & 4; // 0x80cffcd
            int32_t v113; // bp-4, 0x80cfdb0
            char * v114 = (char *)((int32_t)&v113 - 36 + v110 / 2); // 0x80cffd6
            char v115 = *v114; // 0x80cffd6
            *v114 = v115 & -1 - (char)(15 << v112) | (char)((int32_t)v111 << v112);
        }
        int32_t v116 = v110 + 1; // 0x80cffe8
        if (v110 == 15) {
            // break -> 0x80cfecc
            break;
        }
        v110 = v116;
    }
    goto lab_0x80cfecc;
  lab_0x80cfecc:;
    char v117 = *(char *)v99; // 0x80cfecf
    v32 = v100;
    v33 = v99;
    v34 = v117;
    v9 = v100;
    if (v117 == 34) {
        goto lab_0x80cff40;
    } else {
        goto lab_0x80cfed6;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80d0250 - 0x80d0280
// Line range:    452 - 459
int32_t string_to_pcbflags(char * flagstring, int32_t (*error)(char *)) {
    // 0x80d0250
    common_string_to_flags((char *)&pcb_flagbits, (int32_t (*)(char *))22, &g279, (int32_t)&g279);
    return (int32_t)flagstring;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80d0280 - 0x80d02b0
// Line range:    442 - 449
int32_t string_to_flags(char * flagstring, int32_t (*error)(char *)) {
    // 0x80d0280
    common_string_to_flags((char *)&object_flagbits, (int32_t (*)(char *))23, &g279, (int32_t)&g279);
    return (int32_t)flagstring;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d18d0 - 0x80d18df
// Line range:    1079 - 1082
void RestoreUndoSerialNumber(void) {
    // 0x80d18d0
    Serial = SavedSerial;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d18e0 - 0x80d18f6
// Line range:    1088 - 1092
void SaveUndoSerialNumber(void) {
    // 0x80d18e0
    Bumped = 0;
    SavedSerial = Serial;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d1930 - 0x80d1ad0
// Line range:    202 - 230
int32_t * GetUndoSlot(int32_t CommandType, int32_t ID2, int32_t Kind) {
    uint32_t v1 = UndoMax; // 0x80d1939
    int32_t v2 = UndoN; // 0x80d194f
    if (UndoN >= v1) {
        int32_t v3 = v1 + 500; // 0x80d1a4d
        UndoMax = v3;
        uint32_t v4 = 32 * v3; // 0x80d1a59
        int32_t v5 = (int32_t)MyRealloc((char *)UndoList, v4, "AddCommandToUndoList()"); // 0x80d1a6b
        *(int32_t *)&UndoList = v5;
        memset((int32_t *)(32 * UndoN + v5), 0, 0x3e80);
        if (v4 > g40) {
            // 0x80d1aaa
            g40 = v4 + 0x100000 & -0x100000;
            Message("Size of 'undo-list' exceeds %li kb\n", v3 / 32 % 0x400000);
        }
        // 0x80d1aa0
        v2 = UndoN;
    }
    int32_t v6 = 32 * v2 + (int32_t)UndoList; // 0x80d1960
    int32_t v7 = v2; // 0x80d1968
    int32_t v8 = v6; // 0x80d1968
    if (RedoN != 0) {
        int32_t v9 = *(int32_t *)(v6 + 4); // 0x80d1991
        char * v10; // bp-32, 0x80d1930
        char * v11; // bp-36, 0x80d1930
        char * v12; // bp-40, 0x80d1930
        int32_t v13; // 0x80d19a8
        int32_t v14; // 0x80d19af
        int32_t v15; // 0x80d19cd
        if (v9 != 1) {
            if (v9 == 4) {
                // 0x80d19a8
                v13 = *(int32_t *)(v6 + 8);
                v14 = *(int32_t *)(v6 + 12);
                v15 = SearchObjectByID(RemoveList, &v10, &v11, &v12, v14, v13);
                if (v15 != 0) {
                    // 0x80d19d6
                    DestroyObject(RemoveList, v15, v10, v11, v12);
                }
            }
        } else {
            // 0x80d1999
            SaveFree((char *)*(int32_t *)(v6 + 16));
        }
        int32_t v16 = RedoN - 1; // 0x80d1982
        RedoN = v16;
        int32_t v17 = v6 + 32; // 0x80d198c
        while (v16 != 0) {
            int32_t v18 = v17;
            v9 = *(int32_t *)(v18 + 4);
            if (v9 != 1) {
                if (v9 == 4) {
                    // 0x80d19a8
                    v13 = *(int32_t *)(v18 + 8);
                    v14 = *(int32_t *)(v18 + 12);
                    v15 = SearchObjectByID(RemoveList, &v10, &v11, &v12, v14, v13);
                    if (v15 != 0) {
                        // 0x80d19d6
                        DestroyObject(RemoveList, v15, v10, v11, v12);
                    }
                }
            } else {
                // 0x80d1999
                SaveFree((char *)*(int32_t *)(v18 + 16));
            }
            // 0x80d197d
            v16 = RedoN - 1;
            RedoN = v16;
            v17 = v18 + 32;
        }
        // 0x80d1a08
        v7 = UndoN;
        v8 = 32 * v7 + (int32_t)UndoList;
    }
    // 0x80d1a18
    UndoN = v7 + 1;
    int32_t * result = (int32_t *)v8; // 0x80d1a37
    *result = Serial;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d1da0 - 0x80d1ddb
// Line range:    1327 - 1336
void AddObjectToFlagUndoList(int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3) {
    // 0x80d1da0
    if (Locked == 0) {
        int32_t v1 = (int32_t)Ptr1;
        int32_t v2; // 0x80d1da0
        int32_t v3 = (int32_t)GetUndoSlot(v2, v2, (int32_t)&g279); // 0x80d1dbe
        *(int32_t *)(v3 + 16) = *(int32_t *)(v1 + 20);
        *(int32_t *)(v3 + 20) = *(int32_t *)(v1 + 24);
        *(int32_t *)(v3 + 24) = *(int32_t *)(v1 + 28);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d23d0 - 0x80d24cf
// Line range:    1117 - 1125
void ClearUndoList(char Force) {
    // 0x80d23d0
    if (UndoN == 0 || Force == 0 == gui == NULL) {
        // 0x80d2486
        Serial = 1;
        return;
    }
    int32_t v1 = (int32_t)UndoList;
    if (*(int32_t *)(v1 + 4) == 1) {
        // 0x80d241a
        SaveFree((char *)*(int32_t *)(v1 + 16));
    }
    int32_t v2 = UndoN - 1; // 0x80d2405
    UndoN = v2;
    int32_t v3 = v1 + 32; // 0x80d240f
    while (v2 != 0) {
        // 0x80d2414
        v1 = v3;
        int32_t v4 = v2; // 0x80d2418
        if (*(int32_t *)(v1 + 4) == 1) {
            // 0x80d241a
            SaveFree((char *)*(int32_t *)(v1 + 16));
            v4 = UndoN;
        }
        // 0x80d2400
        v2 = v4 - 1;
        UndoN = v2;
        v3 = v1 + 32;
    }
    // 0x80d242e
    SaveFree((char *)UndoList);
    *(int32_t *)&UndoList = 0;
    if (RemoveList != NULL) {
        // 0x80d2449
        FreeDataMemory(RemoveList);
        free(RemoveList);
        *(int32_t *)&RemoveList = 0;
    }
    // 0x80d2468
    RedoN = 0;
    UndoMax = 0;
    UndoN = 0;
    // 0x80d2486
    Serial = 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d24d0 - 0x80d2525
// Line range:    1100 - 1111
void IncrementUndoSerialNumber(void) {
    // 0x80d24d0
    if (Locked != 0 || UndoN == 0) {
        // 0x80d24ff
        return;
    }
    int32_t v1 = *(int32_t *)(32 * UndoN - 32 + (int32_t)UndoList); // 0x80d24f4
    if (v1 != Serial) {
        // 0x80d24ff
        return;
    }
    // 0x80d2508
    Serial = v1 + 1;
    Bumped = 1;
    SetChangedFlag(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3d40 - 0x80d3d5c
// Line range:    981 - 981
void register_vendor_flag_list(void) {
    // 0x80d3d40
    hid_register_flags(&vendor_flag_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3d60 - 0x80d3d7c
// Line range:    971 - 971
void register_vendor_action_list(void) {
    // 0x80d3d60
    hid_register_actions(&vendor_action_list, 6);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3d80 - 0x80d3e87
// Line range:    623 - 653
int32_t vendorDrillMap(int32_t in) {
    // 0x80d3d80
    if (cached_drill == in) {
        // 0x80d3e18
        return cached_map;
    }
    // 0x80d3d98
    cached_drill = in;
    if (n_vendor_drills == 0 || vendor_drills == NULL || vendorMapEnable == 0) {
        // 0x80d3e08
        cached_map = in;
        // 0x80d3e10
        return in;
    }
    int32_t result = (int32_t)vendor_drills; // 0x80d3da8
    if (result >= in) {
        // 0x80d3dfb
        cached_map = result;
        return result;
    }
    int32_t v1 = n_vendor_drills - 1; // 0x80d3dc1
    int32_t v2 = 4 * v1 + result;
    int32_t v3 = *(int32_t *)v2; // 0x80d3dc6
    if (v3 < in) {
        // 0x80d3e45
        Message("Vendor drill list does not contain a drill >= %6.2f mil\nUsing %6.2f mil instead.\n", (float64_t)(0.01L * (float80_t)in), (float64_t)(0.01L * (float80_t)v3));
        int32_t result2 = *(int32_t *)((int32_t)vendor_drills - 4 + 4 * n_vendor_drills); // 0x80d3e7c
        cached_map = result2;
        // 0x80d3e10
        return result2;
    }
    int32_t v4 = v1; // 0x80d3ded
    int32_t v5 = 0; // 0x80d3ded
    int32_t v6 = v2; // 0x80d3ded
    if (v1 > 1) {
        int32_t v7 = v5 + v4; // 0x80d3dd0
        int32_t v8 = v7 + (int32_t)(v7 < 0) >> 1; // 0x80d3ddb
        int32_t v9 = *(int32_t *)(4 * v8 + result); // 0x80d3ddd
        int32_t v10 = in - v9; // 0x80d3ddd
        v5 = v10 < 0 == ((v10 ^ in) & (v9 ^ in)) < 0 == (v10 != 0) ? v8 : v5;
        v4 = v10 == 0 | v10 < 0 != ((v10 ^ in) & (v9 ^ in)) < 0 ? v8 : v4;
        while (v4 - v5 > 1) {
            // 0x80d3dd0
            v7 = v5 + v4;
            v8 = v7 + (int32_t)(v7 < 0) >> 1;
            v9 = *(int32_t *)(4 * v8 + result);
            v10 = in - v9;
            v5 = v10 < 0 == ((v10 ^ in) & (v9 ^ in)) < 0 == (v10 != 0) ? v8 : v5;
            v4 = v10 == 0 | v10 < 0 != ((v10 ^ in) & (v9 ^ in)) < 0 ? v8 : v4;
        }
        // 0x80d3de6
        v6 = 4 * v4 + result;
    }
    // 0x80d3def
    if (rounding_method != 1) {
        int32_t result3 = *(int32_t *)v6;
        cached_map = result3;
        return result3;
    }
    int32_t result4 = *(int32_t *)(v6 - 4); // 0x80d3e28
    int32_t result5 = *(int32_t *)v6; // 0x80d3e2e
    if (in - result4 <= result5 - in) {
        // 0x80d3dfb
        cached_map = result4;
        return result4;
    }
    // 0x80d3e3b
    cached_map = result5;
    // 0x80d3e10
    return result5;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3e90 - 0x80d3f60
// Line range:    884 - 949
char rematch(char * re, char * s) {
    struct _TYPEDEF_regmatch_t v1; // 0x80d3ee8
    struct _TYPEDEF_regmatch_t pmatch[1]; // 0x80d3ee8
    int32_t v2 = __readgsdword(20); // 0x80d3ea3
    int32_t preg; // bp-184, 0x80d3e90
    int32_t regex; // 0x80d3e90
    int32_t errcode = regcomp((struct re_pattern_buffer *)&preg, (char *)regex, 11); // 0x80d3ebe
    char result; // 0x80d3e90
    if (errcode != 0) {
        // 0x80d3f18
        int32_t errbuf; // bp-144, 0x80d3e90
        regerror(errcode, (struct re_pattern_buffer *)&preg, (char *)&errbuf, 128);
        Message("regexp error: %s\n", &errbuf);
        regfree((struct re_pattern_buffer *)&preg);
        result = 0;
    } else {
        // 0x80d3ec7
        v1 = (struct {int32_t e0; int32_t e1;}){
            .e0 = 0,
            .e1 = 0
        };
        int32_t v3; // bp-152, 0x80d3e90
        v1.e0 = &v3;
        pmatch[0] = v1;
        int32_t v4 = regexec((struct re_pattern_buffer *)&preg, (char *)regex, 1, pmatch, 0); // 0x80d3ee8
        regfree((struct re_pattern_buffer *)&preg);
        result = v4 == 0;
    }
    // 0x80d3efc
    if (v2 == __readgsdword(20)) {
        // 0x80d3f08
        return result;
    }
    // 0x80d3f52
    __stack_chk_fail();
    return &g279;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3f60 - 0x80d4200
// Line range:    821 - 881
char vendorIsElementMappable(int32_t * element) {
    // 0x80d3f60
    if (vendorMapEnable == 0) {
        // 0x80d403d
        return 0;
    }
    int32_t v1 = (int32_t)element;
    int32_t v2 = 1; // 0x80d3f89
    int32_t v3; // 0x80d3f60
    int32_t v4; // 0x80d3f60
    int32_t v5; // 0x80d3f60
    int32_t v6; // 0x80d3f60
    int32_t str3; // 0x80d3f60
    int32_t str4; // 0x80d3fa5
    int32_t v7; // 0x80d3f97
    int32_t * v8; // 0x80d3f97
    int32_t v9; // 0x80d3f90
    if (n_refdes >= 1) {
        // 0x80d3f90
        v8 = (int32_t *)(v1 + 148);
        v5 = 1;
        v3 = 0;
        while (true) {
          lab_0x80d3f90:
            // 0x80d3f90
            v4 = v3;
            v6 = v5;
            v9 = 4 * v4;
            str4 = *(int32_t *)(v9 + (int32_t)ignore_refdes);
            if (str4 == 0) {
                goto lab_0x80d3fd2;
            } else {
                // 0x80d3fac
                v7 = *v8;
                if (v7 == 0) {
                    // 0x80d3fb7
                    str3 = (int32_t)"(unknown)";
                    goto lab_0x80d3fbc;
                } else {
                    // 0x80d3fb0
                    str3 = v7;
                    if (*(char *)v7 != 0) {
                        goto lab_0x80d3fbc;
                    } else {
                        // 0x80d3fb7
                        str3 = (int32_t)"(unknown)";
                        goto lab_0x80d3fbc;
                    }
                }
            }
        }
      lab_0x80d4034:
        // 0x80d4034
        if (v2 == 0) {
            // 0x80d403d
            return 0;
        }
    }
    int32_t v10 = v2;
    int32_t v11 = v10; // 0x80d4050
    int32_t v12; // 0x80d3f60
    int32_t v13; // 0x80d3f60
    int32_t v14; // 0x80d3f60
    int32_t v15; // 0x80d3f60
    int32_t v16; // 0x80d4058
    int32_t str2; // 0x80d406d
    int32_t v17; // 0x80d405f
    int32_t * v18; // 0x80d405f
    if (n_value >= 1) {
        // 0x80d4058
        v18 = (int32_t *)(v1 + 208);
        v14 = v10;
        v12 = 0;
        while (true) {
          lab_0x80d4058:
            // 0x80d4058
            v13 = v12;
            v15 = v14;
            v16 = 4 * v13;
            str2 = *(int32_t *)(v16 + (int32_t)ignore_value);
            if (str2 == 0) {
                goto lab_0x80d409a;
            } else {
                // 0x80d4074
                v17 = *v18;
                if (v17 == 0) {
                    // 0x80d407f
                    goto lab_0x80d4084;
                } else {
                    // 0x80d4078
                    if (*(char *)v17 != 0) {
                        goto lab_0x80d4084;
                    } else {
                        // 0x80d407f
                        goto lab_0x80d4084;
                    }
                }
            }
        }
      lab_0x80d40fc:
        // 0x80d40fc
        if (v11 == 0) {
            // 0x80d403d
            return 0;
        }
    }
    // 0x80d4107
    int32_t v19; // 0x80d3f60
    int32_t v20; // 0x80d3f60
    int32_t v21; // 0x80d3f60
    int32_t v22; // 0x80d3f60
    int32_t v23; // 0x80d3f60
    int32_t * v24; // 0x80d411f
    int32_t v25; // 0x80d4118
    int32_t str; // 0x80d412a
    int32_t v26; // 0x80d411f
    if (n_descr >= 1) {
        // 0x80d4118
        v24 = (int32_t *)(v1 + 88);
        v21 = v11;
        v19 = 0;
        while (true) {
          lab_0x80d4118:
            // 0x80d4118
            v20 = v19;
            v22 = v21;
            v25 = 4 * v20;
            str = *(int32_t *)(v25 + (int32_t)ignore_descr);
            if (str == 0) {
                goto lab_0x80d4157;
            } else {
                // 0x80d4131
                v26 = *v24;
                if (v26 == 0) {
                    // 0x80d413c
                    goto lab_0x80d4141;
                } else {
                    // 0x80d4135
                    if (*(char *)v26 != 0) {
                        goto lab_0x80d4141;
                    } else {
                        // 0x80d413c
                        goto lab_0x80d4141;
                    }
                }
            }
        }
      lab_0x80d41b8:
        // 0x80d41b8
        if (v23 == 0) {
            // 0x80d403d
            return 0;
        }
    }
    // 0x80d41c3
    if ((*(char *)(v1 + 21) & 32) == 0) {
        // 0x80d403d
        return 1;
    }
    int32_t v27 = *(int32_t *)(v1 + 148); // 0x80d41d2
    if (v27 != 0) {
        // 0x80d41dc
        if (*(char *)v27 != 0) {
            // 0x80d41e6
            Message("Vendor mapping skipped because element %s is locked\n", (char *)v27);
            return 0;
        }
    }
    // 0x80d41e6
    Message("Vendor mapping skipped because element %s is locked\n", (char *)(int32_t)"(unknown)");
    return 0;
  lab_0x80d4157:;
    char v28 = rematch((char *)&g279, (char *)&g279); // 0x80d4169
    int32_t v29 = v22; // 0x80d4170
    int32_t v30; // 0x80d3f60
    int32_t v31; // 0x80d3f60
    if (v28 == 0) {
        goto lab_0x80d41a9;
    } else {
        // 0x80d4172
        v30 = *v24;
        v31 = *(int32_t *)(v25 + (int32_t)ignore_descr);
        goto lab_0x80d4180;
    }
  lab_0x80d41a9:
    // 0x80d41a9
    v23 = v29;
    int32_t v32 = v20 + 1; // 0x80d41a9
    v21 = v23;
    v19 = v32;
    if (n_descr <= v32) {
        // break -> 0x80d41b8
        goto lab_0x80d41b8;
    }
    goto lab_0x80d4118;
  lab_0x80d4180:;
    int32_t v33 = v30;
    int32_t v34; // 0x80d3f60
    if (v33 == 0) {
        // 0x80d4189
        v34 = (int32_t)"(unknown)";
        goto lab_0x80d418e;
    } else {
        // 0x80d4184
        v34 = v33;
        if (*(char *)v33 != 0) {
            goto lab_0x80d418e;
        } else {
            // 0x80d4189
            v34 = (int32_t)"(unknown)";
            goto lab_0x80d418e;
        }
    }
  lab_0x80d4141:;
    int32_t strcmp_rc = strcmp((char *)(int32_t)"(unknown)", (char *)str); // 0x80d414b
    v30 = v26;
    v31 = str;
    if (strcmp_rc == 0) {
        goto lab_0x80d4180;
    } else {
        goto lab_0x80d4157;
    }
  lab_0x80d418e:
    // 0x80d418e
    Message("Vendor mapping skipped because descr = %s matches %s\n", (char *)v34, (char *)v31);
    v29 = 0;
    goto lab_0x80d41a9;
  lab_0x80d409a:;
    char v35 = rematch((char *)&g279, (char *)&g279); // 0x80d40aa
    int32_t v36 = v15; // 0x80d40b1
    int32_t v37; // 0x80d3f60
    int32_t v38; // 0x80d3f60
    if (v35 == 0) {
        goto lab_0x80d40ed;
    } else {
        // 0x80d40b3
        v37 = *v18;
        v38 = *(int32_t *)(v16 + (int32_t)ignore_value);
        goto lab_0x80d40c4;
    }
  lab_0x80d40ed:
    // 0x80d40ed
    v11 = v36;
    int32_t v39 = v13 + 1; // 0x80d40ed
    v14 = v11;
    v12 = v39;
    if (n_value <= v39) {
        // break -> 0x80d40fc
        goto lab_0x80d40fc;
    }
    goto lab_0x80d4058;
  lab_0x80d40c4:;
    int32_t v40 = v37;
    int32_t v41; // 0x80d3f60
    if (v40 == 0) {
        // 0x80d40cd
        v41 = (int32_t)"(unknown)";
        goto lab_0x80d40d2;
    } else {
        // 0x80d40c8
        v41 = v40;
        if (*(char *)v40 != 0) {
            goto lab_0x80d40d2;
        } else {
            // 0x80d40cd
            v41 = (int32_t)"(unknown)";
            goto lab_0x80d40d2;
        }
    }
  lab_0x80d4084:;
    int32_t strcmp_rc2 = strcmp((char *)(int32_t)"(unknown)", (char *)str2); // 0x80d408e
    v37 = v17;
    v38 = str2;
    if (strcmp_rc2 == 0) {
        goto lab_0x80d40c4;
    } else {
        goto lab_0x80d409a;
    }
  lab_0x80d40d2:
    // 0x80d40d2
    Message("Vendor mapping skipped because value = %s matches %s\n", (char *)v41, (char *)v38);
    v36 = 0;
    goto lab_0x80d40ed;
  lab_0x80d3fd2:;
    char v42 = rematch((char *)&g279, (char *)&g279); // 0x80d3fe2
    int32_t v43 = v6; // 0x80d3fe9
    int32_t v44; // 0x80d3f60
    int32_t v45; // 0x80d3f60
    if (v42 == 0) {
        goto lab_0x80d4025;
    } else {
        // 0x80d3feb
        v44 = *v8;
        v45 = *(int32_t *)(v9 + (int32_t)ignore_refdes);
        goto lab_0x80d3ffc;
    }
  lab_0x80d4025:
    // 0x80d4025
    v2 = v43;
    int32_t v46 = v4 + 1; // 0x80d4025
    v5 = v2;
    v3 = v46;
    if (n_refdes <= v46) {
        // break -> 0x80d4034
        goto lab_0x80d4034;
    }
    goto lab_0x80d3f90;
  lab_0x80d3ffc:;
    int32_t v47 = v44;
    int32_t v48; // 0x80d3f60
    if (v47 == 0) {
        // 0x80d4005
        v48 = (int32_t)"(unknown)";
        goto lab_0x80d400a;
    } else {
        // 0x80d4000
        v48 = v47;
        if (*(char *)v47 != 0) {
            goto lab_0x80d400a;
        } else {
            // 0x80d4005
            v48 = (int32_t)"(unknown)";
            goto lab_0x80d400a;
        }
    }
  lab_0x80d3fbc:;
    int32_t strcmp_rc3 = strcmp((char *)str3, (char *)str4); // 0x80d3fc6
    v44 = v7;
    v45 = str4;
    if (strcmp_rc3 == 0) {
        goto lab_0x80d3ffc;
    } else {
        goto lab_0x80d3fd2;
    }
  lab_0x80d400a:
    // 0x80d400a
    Message("Vendor mapping skipped because refdes = %s matches %s\n", (char *)v48, (char *)v45);
    v43 = 0;
    goto lab_0x80d4025;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5220 - 0x80d54fd
// Line range:    320 - 358
int32_t hid_parse_actions(char * rstr, int32_t (*function)(char *, int32_t, char **)) {
    int32_t * mem = malloc(strlen(rstr) + 1); // 0x80d524b
    int32_t v1 = 0; // 0x80d525e
    char ** v2 = NULL; // 0x80d525e
    int32_t v3 = (int32_t)rstr; // 0x80d525e
    char v4 = *(char *)v3; // 0x80d5261
    char * v5 = (char *)mem; // 0x80d5266
    int32_t v6 = v1; // 0x80d5266
    char ** v7 = v2; // 0x80d5266
    char v8 = v4; // 0x80d5266
    int32_t v9 = v3; // 0x80d5266
    char ** v10 = v2; // 0x80d5266
    int32_t result = 0; // 0x80d5266
    char v11; // 0x80d5220
    int32_t v12; // 0x80d5220
    int32_t v13; // 0x80d5220
    int32_t v14; // 0x80d5220
    int32_t v15; // 0x80d5220
    int32_t v16; // 0x80d5220
    int32_t v17; // 0x80d5220
    int32_t v18; // 0x80d5220
    int32_t v19; // 0x80d5220
    char v20; // 0x80d53a0
    while (v4 != 0) {
        // 0x80d5261
        while (true) {
            // 0x80d526c
            v2 = v7;
            v1 = v6;
            int16_t ** v21 = __ctype_b_loc(); // 0x80d526f
            int32_t v22 = (int32_t)*v21 + 1; // 0x80d5291
            char v23 = v8; // 0x80d527d
            int32_t v24 = v9; // 0x80d527d
            int32_t v25 = v24;
            char v26 = v23;
            while ((*(char *)(v22 + (0x1000000 * (int32_t)v26 >> 23)) & 32) != 0) {
                // 0x80d5280
                v24 = v25 + 1;
                v23 = *(char *)v24;
                v10 = v2;
                result = 0;
                if (v23 == 0) {
                    // break (via goto) -> 0x80d547d
                    goto lab_0x80d547d_4;
                }
                v25 = v24;
                v26 = v23;
            }
            int32_t v27 = (int32_t)v5;
            char v28 = v26; // 0x80d529b
            int32_t v29 = v25; // 0x80d529b
            int32_t v30 = v27; // 0x80d529b
            char * v31; // 0x80d5220
            int32_t v32; // 0x80d5220
            int32_t v33; // 0x80d5220
            if (v26 != 40 == (v26 != 0)) {
                while (true) {
                    int32_t v34 = v29 + 1; // 0x80d52b4
                    *(char *)v30 = v28;
                    char * v35 = (char *)v34;
                    char v36 = *v35; // 0x80d52b9
                    int32_t v37 = v30 + 1; // 0x80d52bc
                    v28 = v36;
                    v29 = v34;
                    v30 = v37;
                    v31 = v35;
                    v32 = v34;
                    v33 = v37;
                    switch (v36) {
                        case 40: {
                            goto lab_0x80d52c4;
                        }
                        case 0: {
                            goto lab_0x80d52c4;
                        }
                        default: {
                            goto lab_0x80d52b4;
                        }
                    }
                }
            } else {
                // 0x80d54f5
                v31 = (char *)v25;
                v32 = v25;
                v33 = v27;
            }
            int32_t v38 = v33;
            int32_t v39 = v32;
            *(char *)v38 = 0;
            v3 = v39;
            if (*v31 == 0) {
                // break -> 0x80d52cc
                break;
            }
            int32_t v40 = v39 + 1; // 0x80d52f8
            unsigned char v41 = *(char *)v40; // 0x80d52fb
            v3 = v40;
            if (v41 == 0) {
                // break -> 0x80d52cc
                break;
            }
            int32_t v42 = v1; // 0x80d5448
            char ** v43 = v2; // 0x80d5448
            int32_t v44 = v40; // 0x80d5448
            if (v41 != 41) {
                int32_t v45 = v38 + 1; // 0x80d5220
                int32_t v46 = v40; // 0x80d5220
                int32_t v47 = v41; // 0x80d5220
                int32_t v48 = 0; // 0x80d5220
                int32_t v49 = 0; // 0x80d5220
                char ** v50 = v2; // 0x80d5220
                int32_t v51 = v1; // 0x80d5220
                int32_t v52 = v51; // 0x80d5220
                char ** v53 = v50; // 0x80d5220
                int32_t v54 = v49; // 0x80d5220
                int32_t v55 = v48; // 0x80d5220
                int32_t v56 = v47; // 0x80d5220
                bool v57 = false; // 0x80d5220
                int32_t v58 = v46; // 0x80d5220
                int32_t v59 = v45; // 0x80d5220
                char ** v60 = v53;
                v10 = v60;
                result = 0;
                if (v56 == 0 && !v57) {
                    // break (via goto) -> 0x80d547d
                    goto lab_0x80d547d_4;
                }
                int32_t v61 = v59;
                int32_t v62 = v58;
                int32_t v63 = v52;
                int32_t v64 = v63; // 0x80d5336
                char ** v65 = v60; // 0x80d5336
                int32_t v66 = v56; // 0x80d5336
                int32_t v67; // 0x80d533b
                int32_t size; // 0x80d5220
                int32_t * mem2; // 0x80d54db
                int32_t * mem3; // 0x80d5357
                if (v63 <= v55) {
                    // 0x80d5338
                    v67 = v63 + 10;
                    size = 4 * v67;
                    if (v60 == NULL) {
                        // 0x80d54d2
                        mem2 = malloc(size);
                        v64 = v67;
                        v65 = (char **)mem2;
                        v66 = (int32_t)*(char *)v62;
                    } else {
                        // 0x80d5347
                        mem3 = realloc((int32_t *)v60, size);
                        v64 = v67;
                        v65 = (char **)mem3;
                        v66 = (int32_t)*(char *)v62;
                    }
                }
                int32_t v68 = v66;
                char ** v69 = v65;
                int32_t v70 = v64;
                int32_t v71 = v62; // 0x80d5364
                int32_t v72; // 0x80d5220
                int32_t v73; // 0x80d5220
                char v74; // 0x80d537d
                int32_t v75; // 0x80d5370
                unsigned char v76; // 0x80d5373
                if ((char)v68 != 0) {
                    // 0x80d5366
                    v72 = v68;
                    v75 = v62;
                    v73 = v75;
                    v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                    v71 = v73;
                    while ((v74 & 32) != 0) {
                        // 0x80d5370
                        v75 = v73 + 1;
                        v76 = *(char *)v75;
                        v72 = v76;
                        v71 = v75;
                        if (v76 == 0) {
                            // break -> 0x80d5384
                            break;
                        }
                        v73 = v75;
                        v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                        v71 = v73;
                    }
                }
                int32_t v77 = v71;
                int32_t * v78 = (int32_t *)(v54 + (int32_t)v69); // 0x80d5390
                *v78 = v61;
                char * v79 = (char *)v77;
                unsigned char v80 = *v79; // 0x80d5392
                char * v81 = v79; // 0x80d5399
                int32_t v82 = 0; // 0x80d5399
                int32_t v83 = v77; // 0x80d5399
                int32_t v84 = v61; // 0x80d5399
                int32_t v85; // 0x80d5220
                int32_t v86; // 0x80d5220
                int32_t v87; // 0x80d5220
                if (v80 != 0) {
                    // 0x80d53a0
                    v12 = v80;
                    v16 = 0;
                    v14 = v77;
                    v18 = v61;
                    while (true) {
                        // 0x80d53a0
                        v19 = v18;
                        v15 = v14;
                        v17 = v16;
                        v13 = v12;
                        v20 = v17;
                        v11 = v13;
                        if (v20 != 0) {
                            goto lab_0x80d53ac;
                        } else {
                            // 0x80d53a4
                            switch (v11) {
                                case 41: {
                                    goto lab_0x80d53ed_2;
                                }
                                case 44: {
                                    goto lab_0x80d53ed_2;
                                }
                                default: {
                                    goto lab_0x80d53ac;
                                }
                            }
                        }
                    }
                    // 0x80d53ed
                    v83 = v86;
                    v81 = (char *)v83;
                    v82 = v85;
                    v84 = v87;
                }
                int32_t v88 = v83;
                *(char *)v84 = 0;
                int32_t v89 = 0; // 0x80d53ff
                int32_t v90 = v82; // 0x80d53ff
                int32_t v91 = v88; // 0x80d53ff
                if (*v81 == 44) {
                    // 0x80d54c0
                    v91 = v88 + 1;
                    v89 = 1;
                    v90 = (int32_t)*(char *)v91;
                }
                int32_t v92 = v91;
                int32_t v93 = v90;
                int32_t v94 = v84 - 1;
                char * v95 = (char *)v94; // 0x80d5422
                char v96 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v95); // 0x80d5427
                char * v97 = v95; // 0x80d542c
                int32_t v98 = v94; // 0x80d542c
                int32_t v99; // 0x80d5220
                uint32_t v100; // 0x80d5220
                char * v101; // 0x80d5422
                char v102; // 0x80d5427
                if ((v96 & 32) != 0) {
                    v100 = v98;
                    while (v100 >= *v78) {
                        // 0x80d541c
                        *v97 = 0;
                        v99 = v100 - 1;
                        v101 = (char *)v99;
                        v102 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v101);
                        v97 = v101;
                        v98 = v99;
                        if ((v102 & 32) == 0) {
                            // break -> 0x80d542e
                            break;
                        }
                        v100 = v98;
                    }
                }
                int32_t v103 = v55 + 1; // 0x80d538c
                int32_t v104 = v84 + 1; // 0x80d53f2
                int32_t v105 = v54 + 4; // 0x80d5431
                v52 = v70;
                v53 = v69;
                v54 = v105;
                v55 = v103;
                v56 = v93;
                v57 = true;
                v58 = v92;
                v59 = v104;
                while (v89 != 0) {
                    // 0x80d5328
                    v60 = v53;
                    v10 = v60;
                    result = 0;
                    if (v56 == 0 && !v57) {
                        // break (via goto) -> 0x80d547d
                        goto lab_0x80d547d_4;
                    }
                    // 0x80d5330
                    v61 = v59;
                    v62 = v58;
                    v63 = v52;
                    v64 = v63;
                    v65 = v60;
                    v66 = v56;
                    if (v63 <= v55) {
                        // 0x80d5338
                        v67 = v63 + 10;
                        size = 4 * v67;
                        if (v60 == NULL) {
                            // 0x80d54d2
                            mem2 = malloc(size);
                            v64 = v67;
                            v65 = (char **)mem2;
                            v66 = (int32_t)*(char *)v62;
                        } else {
                            // 0x80d5347
                            mem3 = realloc((int32_t *)v60, size);
                            v64 = v67;
                            v65 = (char **)mem3;
                            v66 = (int32_t)*(char *)v62;
                        }
                    }
                    // 0x80d5362
                    v68 = v66;
                    v69 = v65;
                    v70 = v64;
                    v71 = v62;
                    if ((char)v68 != 0) {
                        // 0x80d5366
                        v72 = v68;
                        v75 = v62;
                        v73 = v75;
                        v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                        v71 = v73;
                        while ((v74 & 32) != 0) {
                            // 0x80d5370
                            v75 = v73 + 1;
                            v76 = *(char *)v75;
                            v72 = v76;
                            v71 = v75;
                            if (v76 == 0) {
                                // break -> 0x80d5384
                                break;
                            }
                            v73 = v75;
                            v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                            v71 = v73;
                        }
                    }
                    // 0x80d5384
                    v77 = v71;
                    v78 = (int32_t *)(v54 + (int32_t)v69);
                    *v78 = v61;
                    v79 = (char *)v77;
                    v80 = *v79;
                    v81 = v79;
                    v82 = 0;
                    v83 = v77;
                    v84 = v61;
                    if (v80 != 0) {
                        // 0x80d53a0
                        v12 = v80;
                        v16 = 0;
                        v14 = v77;
                        v18 = v61;
                        while (true) {
                            // 0x80d53a0
                            v19 = v18;
                            v15 = v14;
                            v17 = v16;
                            v13 = v12;
                            v20 = v17;
                            v11 = v13;
                            if (v20 != 0) {
                                goto lab_0x80d53ac;
                            } else {
                                // 0x80d53a4
                                switch (v11) {
                                    case 41: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    case 44: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    default: {
                                        goto lab_0x80d53ac;
                                    }
                                }
                            }
                        }
                        // 0x80d53ed
                        v83 = v86;
                        v81 = (char *)v83;
                        v82 = v85;
                        v84 = v87;
                    }
                    // 0x80d53ed
                    v88 = v83;
                    *(char *)v84 = 0;
                    v89 = 0;
                    v90 = v82;
                    v91 = v88;
                    if (*v81 == 44) {
                        // 0x80d54c0
                        v91 = v88 + 1;
                        v89 = 1;
                        v90 = (int32_t)*(char *)v91;
                    }
                    // 0x80d5405
                    v92 = v91;
                    v93 = v90;
                    v94 = v84 - 1;
                    v95 = (char *)v94;
                    v96 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v95);
                    v97 = v95;
                    v98 = v94;
                    if ((v96 & 32) != 0) {
                        v100 = v98;
                        while (v100 >= *v78) {
                            // 0x80d541c
                            *v97 = 0;
                            v99 = v100 - 1;
                            v101 = (char *)v99;
                            v102 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v101);
                            v97 = v101;
                            v98 = v99;
                            if ((v102 & 32) == 0) {
                                // break -> 0x80d542e
                                break;
                            }
                            v100 = v98;
                        }
                    }
                    // 0x80d542e
                    v103 = v55 + 1;
                    v104 = v84 + 1;
                    v105 = v54 + 4;
                    v52 = v70;
                    v53 = v69;
                    v54 = v105;
                    v55 = v103;
                    v56 = v93;
                    v57 = true;
                    v58 = v92;
                    v59 = v104;
                }
                // 0x80d5446
                v45 = v104;
                v46 = v92;
                v47 = v93;
                v48 = v103;
                v49 = v105;
                v50 = v69;
                v51 = v70;
                v42 = v70;
                v43 = v69;
                v44 = v92;
                while ((char)v93 != 41) {
                    // 0x80d5328
                    v52 = v51;
                    v53 = v50;
                    v54 = v49;
                    v55 = v48;
                    v56 = v47;
                    v57 = false;
                    v58 = v46;
                    v59 = v45;
                    v60 = v53;
                    v10 = v60;
                    result = 0;
                    if (v56 == 0 && !v57) {
                        // break (via goto) -> 0x80d547d
                        goto lab_0x80d547d_4;
                    }
                    // 0x80d5330
                    v61 = v59;
                    v62 = v58;
                    v63 = v52;
                    v64 = v63;
                    v65 = v60;
                    v66 = v56;
                    if (v63 <= v55) {
                        // 0x80d5338
                        v67 = v63 + 10;
                        size = 4 * v67;
                        if (v60 == NULL) {
                            // 0x80d54d2
                            mem2 = malloc(size);
                            v64 = v67;
                            v65 = (char **)mem2;
                            v66 = (int32_t)*(char *)v62;
                        } else {
                            // 0x80d5347
                            mem3 = realloc((int32_t *)v60, size);
                            v64 = v67;
                            v65 = (char **)mem3;
                            v66 = (int32_t)*(char *)v62;
                        }
                    }
                    // 0x80d5362
                    v68 = v66;
                    v69 = v65;
                    v70 = v64;
                    v71 = v62;
                    if ((char)v68 != 0) {
                        // 0x80d5366
                        v72 = v68;
                        v75 = v62;
                        v73 = v75;
                        v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                        v71 = v73;
                        while ((v74 & 32) != 0) {
                            // 0x80d5370
                            v75 = v73 + 1;
                            v76 = *(char *)v75;
                            v72 = v76;
                            v71 = v75;
                            if (v76 == 0) {
                                // break -> 0x80d5384
                                break;
                            }
                            v73 = v75;
                            v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                            v71 = v73;
                        }
                    }
                    // 0x80d5384
                    v77 = v71;
                    v78 = (int32_t *)(v54 + (int32_t)v69);
                    *v78 = v61;
                    v79 = (char *)v77;
                    v80 = *v79;
                    v81 = v79;
                    v82 = 0;
                    v83 = v77;
                    v84 = v61;
                    if (v80 != 0) {
                        // 0x80d53a0
                        v12 = v80;
                        v16 = 0;
                        v14 = v77;
                        v18 = v61;
                        while (true) {
                            // 0x80d53a0
                            v19 = v18;
                            v15 = v14;
                            v17 = v16;
                            v13 = v12;
                            v20 = v17;
                            v11 = v13;
                            if (v20 != 0) {
                                goto lab_0x80d53ac;
                            } else {
                                // 0x80d53a4
                                switch (v11) {
                                    case 41: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    case 44: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    default: {
                                        goto lab_0x80d53ac;
                                    }
                                }
                            }
                        }
                        // 0x80d53ed
                        v83 = v86;
                        v81 = (char *)v83;
                        v82 = v85;
                        v84 = v87;
                    }
                    // 0x80d53ed
                    v88 = v83;
                    *(char *)v84 = 0;
                    v89 = 0;
                    v90 = v82;
                    v91 = v88;
                    if (*v81 == 44) {
                        // 0x80d54c0
                        v91 = v88 + 1;
                        v89 = 1;
                        v90 = (int32_t)*(char *)v91;
                    }
                    // 0x80d5405
                    v92 = v91;
                    v93 = v90;
                    v94 = v84 - 1;
                    v95 = (char *)v94;
                    v96 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v95);
                    v97 = v95;
                    v98 = v94;
                    if ((v96 & 32) != 0) {
                        v100 = v98;
                        while (v100 >= *v78) {
                            // 0x80d541c
                            *v97 = 0;
                            v99 = v100 - 1;
                            v101 = (char *)v99;
                            v102 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v101);
                            v97 = v101;
                            v98 = v99;
                            if ((v102 & 32) == 0) {
                                // break -> 0x80d542e
                                break;
                            }
                            v100 = v98;
                        }
                    }
                    // 0x80d542e
                    v103 = v55 + 1;
                    v104 = v84 + 1;
                    v105 = v54 + 4;
                    v52 = v70;
                    v53 = v69;
                    v54 = v105;
                    v55 = v103;
                    v56 = v93;
                    v57 = true;
                    v58 = v92;
                    v59 = v104;
                    while (v89 != 0) {
                        // 0x80d5328
                        v60 = v53;
                        v10 = v60;
                        result = 0;
                        if (v56 == 0 && !v57) {
                            // break (via goto) -> 0x80d547d
                            goto lab_0x80d547d_4;
                        }
                        // 0x80d5330
                        v61 = v59;
                        v62 = v58;
                        v63 = v52;
                        v64 = v63;
                        v65 = v60;
                        v66 = v56;
                        if (v63 <= v55) {
                            // 0x80d5338
                            v67 = v63 + 10;
                            size = 4 * v67;
                            if (v60 == NULL) {
                                // 0x80d54d2
                                mem2 = malloc(size);
                                v64 = v67;
                                v65 = (char **)mem2;
                                v66 = (int32_t)*(char *)v62;
                            } else {
                                // 0x80d5347
                                mem3 = realloc((int32_t *)v60, size);
                                v64 = v67;
                                v65 = (char **)mem3;
                                v66 = (int32_t)*(char *)v62;
                            }
                        }
                        // 0x80d5362
                        v68 = v66;
                        v69 = v65;
                        v70 = v64;
                        v71 = v62;
                        if ((char)v68 != 0) {
                            // 0x80d5366
                            v72 = v68;
                            v75 = v62;
                            v73 = v75;
                            v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                            v71 = v73;
                            while ((v74 & 32) != 0) {
                                // 0x80d5370
                                v75 = v73 + 1;
                                v76 = *(char *)v75;
                                v72 = v76;
                                v71 = v75;
                                if (v76 == 0) {
                                    // break -> 0x80d5384
                                    break;
                                }
                                v73 = v75;
                                v74 = *(char *)((int32_t)*v21 + 1 + (0x1000000 * v72 >> 23));
                                v71 = v73;
                            }
                        }
                        // 0x80d5384
                        v77 = v71;
                        v78 = (int32_t *)(v54 + (int32_t)v69);
                        *v78 = v61;
                        v79 = (char *)v77;
                        v80 = *v79;
                        v81 = v79;
                        v82 = 0;
                        v83 = v77;
                        v84 = v61;
                        if (v80 != 0) {
                            // 0x80d53a0
                            v12 = v80;
                            v16 = 0;
                            v14 = v77;
                            v18 = v61;
                            while (true) {
                                // 0x80d53a0
                                v19 = v18;
                                v15 = v14;
                                v17 = v16;
                                v13 = v12;
                                v20 = v17;
                                v11 = v13;
                                if (v20 != 0) {
                                    goto lab_0x80d53ac;
                                } else {
                                    // 0x80d53a4
                                    switch (v11) {
                                        case 41: {
                                            goto lab_0x80d53ed_2;
                                        }
                                        case 44: {
                                            goto lab_0x80d53ed_2;
                                        }
                                        default: {
                                            goto lab_0x80d53ac;
                                        }
                                    }
                                }
                            }
                            // 0x80d53ed
                            v83 = v86;
                            v81 = (char *)v83;
                            v82 = v85;
                            v84 = v87;
                        }
                        // 0x80d53ed
                        v88 = v83;
                        *(char *)v84 = 0;
                        v89 = 0;
                        v90 = v82;
                        v91 = v88;
                        if (*v81 == 44) {
                            // 0x80d54c0
                            v91 = v88 + 1;
                            v89 = 1;
                            v90 = (int32_t)*(char *)v91;
                        }
                        // 0x80d5405
                        v92 = v91;
                        v93 = v90;
                        v94 = v84 - 1;
                        v95 = (char *)v94;
                        v96 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v95);
                        v97 = v95;
                        v98 = v94;
                        if ((v96 & 32) != 0) {
                            v100 = v98;
                            while (v100 >= *v78) {
                                // 0x80d541c
                                *v97 = 0;
                                v99 = v100 - 1;
                                v101 = (char *)v99;
                                v102 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v101);
                                v97 = v101;
                                v98 = v99;
                                if ((v102 & 32) == 0) {
                                    // break -> 0x80d542e
                                    break;
                                }
                                v100 = v98;
                            }
                        }
                        // 0x80d542e
                        v103 = v55 + 1;
                        v104 = v84 + 1;
                        v105 = v54 + 4;
                        v52 = v70;
                        v53 = v69;
                        v54 = v105;
                        v55 = v103;
                        v56 = v93;
                        v57 = true;
                        v58 = v92;
                        v59 = v104;
                    }
                    // 0x80d5446
                    v45 = v104;
                    v46 = v92;
                    v47 = v93;
                    v48 = v103;
                    v49 = v105;
                    v50 = v69;
                    v51 = v70;
                    v42 = v70;
                    v43 = v69;
                    v44 = v92;
                }
            }
            // 0x80d544e
            v7 = v43;
            v10 = v7;
            result = 1;
            if (mem != NULL) {
                // break (via goto) -> 0x80d547d
                goto lab_0x80d547d_4;
            }
            // 0x80d546d
            v6 = v42;
            v9 = v44 + 1;
            v8 = *(char *)v9;
            v5 = (char *)mem;
            v10 = v7;
            result = 0;
            if (v8 == 0) {
                // break (via goto) -> 0x80d547d
                goto lab_0x80d547d_4;
            }
        }
        // 0x80d52cc
        v10 = v2;
        result = 1;
        if (mem != NULL) {
            // break -> 0x80d547d
            break;
        }
        v4 = *(char *)v3;
        v5 = NULL;
        v6 = v1;
        v7 = v2;
        v8 = v4;
        v9 = v3;
        v10 = v2;
        result = 0;
    }
  lab_0x80d547d_4:
    // 0x80d547d
    if (v10 != NULL) {
        // 0x80d5484
        free((int32_t *)v10);
    }
    if (mem != NULL) {
        // 0x80d5496
        free(mem);
    }
    // 0x80d54a1
    return result;
  lab_0x80d53ac:;
    int32_t v106; // 0x80d5220
    int32_t v107; // 0x80d5220
    int32_t v108; // 0x80d5220
    if (v11 != 39 == (v11 != 34)) {
        goto lab_0x80d53c6;
    } else {
        // 0x80d53b6
        v106 = v15;
        v107 = v19;
        v108 = v13;
        if (v20 == 0) {
            goto lab_0x80d53e4;
        } else {
            // 0x80d53be
            v106 = v15;
            v107 = v19;
            v108 = 0;
            if (v11 == v20) {
                goto lab_0x80d53e4;
            } else {
                goto lab_0x80d53c6;
            }
        }
    }
  lab_0x80d53c6:;
    char v109 = v11; // 0x80d53c8
    int32_t v110 = v15; // 0x80d53c8
    if (v13 == 92 && v20 != 39) {
        int32_t v111 = v15 + 1; // 0x80d53d2
        v109 = *(char *)v111;
        v110 = v111;
    }
    // 0x80d53d8
    *(char *)v19 = v109;
    v106 = v110;
    v107 = v19 + 1;
    v108 = v17;
    goto lab_0x80d53e4;
  lab_0x80d53e4:;
    int32_t v112 = v106 + 1;
    unsigned char v113 = *(char *)v112; // 0x80d53e4
    v12 = v113;
    v16 = v108;
    v14 = v112;
    v18 = v107;
    if (v113 == 0) {
        // break -> 0x80d53ed
        goto lab_0x80d53ed_2;
    }
    goto lab_0x80d53a0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5500 - 0x80d5580
// Line range:    226 - 243
void dump_string(char prefix, char * str) {
    // 0x80d5500
    int32_t v1; // 0x80d5500
    if ((char)v1 == 0) {
        // 0x80d5579
        return;
    }
    // 0x80d5548
    _IO_putc(0x1000000 * v1 >> 24, g45);
    // 0x80d5520
    int32_t v2; // 0x80d5500
    char * v3 = (char *)v2; // 0x80d5529
    _IO_putc((int32_t)*v3, g45);
    char v4 = *v3; // 0x80d5536
    int32_t v5 = v2 + 1; // 0x80d553c
    while (*(char *)v5 != 0) {
        // 0x80d5544
        if ((int32_t)(v4 == 10) != 0) {
            // 0x80d5548
            _IO_putc(0x1000000 * v1 >> 24, g45);
        }
        // 0x80d5520
        v3 = (char *)v5;
        _IO_putc((int32_t)*v3, g45);
        v4 = *v3;
        v5++;
    }
    if (v4 != 10) {
        // 0x80d5564
        _IO_putc(10, g45);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5660 - 0x80d5818
// Line range:    140 - 158
int32_t * hid_find_action(char * name, char ** context) {
    // 0x80d5660
    if (name == NULL) {
        // 0x80d5736
        return (int32_t *)0;
    }
    // 0x80d5676
    if (all_actions == NULL) {
        int32_t * mem = malloc(24 * n_actions); // 0x80d5775
        int32_t v1 = (int32_t)mem; // 0x80d5775
        char * v2 = (char *)mem; // bp-36, 0x80d5782
        *(int32_t *)&all_actions = v1;
        int32_t base = v1; // 0x80d578a
        if (hid_action_nodes != NULL) {
            int32_t v3 = (int32_t)hid_action_nodes;
            char * v4 = NULL;
            int32_t * v5 = (int32_t *)(v3 + 8); // 0x80d5790
            char * v6 = v4; // 0x80d5795
            int32_t v7; // 0x80d5660
            int32_t v8; // 0x80d5660
            int32_t v9; // 0x80d5660
            int32_t v10; // 0x80d57b3
            char * v11; // 0x80d5660
            if (*v5 >= 1) {
                // 0x80d5797
                v11 = v4;
                v7 = 24 * (int32_t)v4 + (int32_t)v2;
                v8 = 0;
                v10 = 0;
                v9 = v8 + *(int32_t *)(v3 + 4);
                v10++;
                v11 = (char *)((int32_t)v11 + 1);
                *(int32_t *)v7 = *(int32_t *)v9;
                *(int32_t *)(v7 + 4) = *(int32_t *)(v9 + 4);
                *(int32_t *)(v7 + 8) = *(int32_t *)(v9 + 8);
                *(int32_t *)(v7 + 12) = *(int32_t *)(v9 + 12);
                *(int32_t *)(v7 + 16) = *(int32_t *)(v9 + 16);
                *(int32_t *)(v7 + 20) = *(int32_t *)(v3 + 12);
                v7 += 24;
                v8 += 20;
                v6 = v11;
                while (*v5 > v10) {
                    // 0x80d57b0
                    v9 = v8 + *(int32_t *)(v3 + 4);
                    v10++;
                    v11 = (char *)((int32_t)v11 + 1);
                    *(int32_t *)v7 = *(int32_t *)v9;
                    *(int32_t *)(v7 + 4) = *(int32_t *)(v9 + 4);
                    *(int32_t *)(v7 + 8) = *(int32_t *)(v9 + 8);
                    *(int32_t *)(v7 + 12) = *(int32_t *)(v9 + 12);
                    *(int32_t *)(v7 + 16) = *(int32_t *)(v9 + 16);
                    *(int32_t *)(v7 + 20) = *(int32_t *)(v3 + 12);
                    v7 += 24;
                    v8 += 20;
                    v6 = v11;
                }
            }
            int32_t v12 = *(int32_t *)v3; // 0x80d57e9
            while (v12 != 0) {
                // 0x80d5790
                v3 = v12;
                v4 = v6;
                v5 = (int32_t *)(v3 + 8);
                v6 = v4;
                if (*v5 >= 1) {
                    // 0x80d5797
                    v11 = v4;
                    v7 = 24 * (int32_t)v4 + (int32_t)v2;
                    v8 = 0;
                    v10 = 0;
                    v9 = v8 + *(int32_t *)(v3 + 4);
                    v10++;
                    v11 = (char *)((int32_t)v11 + 1);
                    *(int32_t *)v7 = *(int32_t *)v9;
                    *(int32_t *)(v7 + 4) = *(int32_t *)(v9 + 4);
                    *(int32_t *)(v7 + 8) = *(int32_t *)(v9 + 8);
                    *(int32_t *)(v7 + 12) = *(int32_t *)(v9 + 12);
                    *(int32_t *)(v7 + 16) = *(int32_t *)(v9 + 16);
                    *(int32_t *)(v7 + 20) = *(int32_t *)(v3 + 12);
                    v7 += 24;
                    v8 += 20;
                    v6 = v11;
                    while (*v5 > v10) {
                        // 0x80d57b0
                        v9 = v8 + *(int32_t *)(v3 + 4);
                        v10++;
                        v11 = (char *)((int32_t)v11 + 1);
                        *(int32_t *)v7 = *(int32_t *)v9;
                        *(int32_t *)(v7 + 4) = *(int32_t *)(v9 + 4);
                        *(int32_t *)(v7 + 8) = *(int32_t *)(v9 + 8);
                        *(int32_t *)(v7 + 12) = *(int32_t *)(v9 + 12);
                        *(int32_t *)(v7 + 16) = *(int32_t *)(v9 + 16);
                        *(int32_t *)(v7 + 20) = *(int32_t *)(v3 + 12);
                        v7 += 24;
                        v8 += 20;
                        v6 = v11;
                    }
                }
                // 0x80d57e9
                v12 = *(int32_t *)v3;
            }
            // 0x80d57ef
            base = (int32_t)v2;
        }
        // 0x80d57ef
        qsort((int32_t *)base, n_actions, 24, (int32_t (*)(int32_t *, int32_t *))0x80d5580);
    }
    char * v13 = (char *)(n_actions - 1);
    char * v14 = v13; // 0x80d56ae
    int32_t v15 = n_actions; // 0x80d56ae
    char * v16 = (char *)-1; // 0x80d56ae
    int32_t v17; // 0x80d5660
    if (v13 > (char *)-1) {
        while (true) {
            uint32_t v18 = (int32_t)v14;
            int32_t v19 = v15 + (int32_t)v16; // 0x80d56b6
            int32_t v20 = v19 + (int32_t)(v19 < 0); // 0x80d56be
            v15 = v20 >> 1;
            int32_t str = 8 * (v15 + (v20 & 0x1ffffffe)) + (int32_t)all_actions; // 0x80d56c8
            int32_t strcmp_rc = strcmp((char *)*(int32_t *)str, name); // 0x80d56d7
            v17 = str;
            if (strcmp_rc == 0) {
                // break (via goto) -> 0x80d5725
                goto lab_0x80d5725;
            }
            while (strcmp_rc < 0) {
                // 0x80d56e3
                if (v15 >= v18) {
                    goto lab_0x80d56f0_2;
                }
                v16 = (char *)v15;
                v19 = v15 + (int32_t)v16;
                v20 = v19 + (int32_t)(v19 < 0);
                v15 = v20 >> 1;
                str = 8 * (v15 + (v20 & 0x1ffffffe)) + (int32_t)all_actions;
                strcmp_rc = strcmp((char *)*(int32_t *)str, name);
                v17 = str;
                if (strcmp_rc == 0) {
                    // break (via goto) -> 0x80d5725
                    goto lab_0x80d5725;
                }
            }
            // 0x80d56a8
            v14 = (char *)(v15 - 1);
            if (v16 >= v14) {
                goto lab_0x80d56f0_2;
            }
        }
    } else {
      lab_0x80d56f0_2:
        if (n_actions < 1) {
            // 0x80d5740
            __printf_chk(1, "unknown action `%s'\n", name);
            return NULL;
        }
        int32_t v21 = 0; // 0x80d5702
        int32_t str2 = (int32_t)all_actions; // 0x80d5702
        v17 = str2;
        while (strcasecmp((char *)*(int32_t *)str2, name) != 0) {
            // 0x80d5708
            v21++;
            str2 += 24;
            if (n_actions <= v21) {
                // 0x80d5740
                __printf_chk(1, "unknown action `%s'\n", name);
                return NULL;
            }
            v17 = str2;
        }
    }
  lab_0x80d5725:
    // 0x80d5725
    if (context != NULL) {
        // 0x80d572c
        *(int32_t *)context = *(int32_t *)(v17 + 20);
    }
    // 0x80d5736
    return (int32_t *)v17;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5820 - 0x80d593c
// Line range:    287 - 105
int32_t hid_actionv(char * name, uint32_t argc, char ** argv) {
    // 0x80d5820
    int32_t v1; // bp-40, 0x80d5820
    if (name == NULL || g115 == 0) {
        // 0x80d5844
        return hid_find_action(name, (char **)&v1) == NULL;
    }
    // 0x80d58cd
    __printf_chk(1, (char *)&g32);
    if (argc >= 1) {
        // 0x80d58ec
        __printf_chk(1, "%s%s", (char *)&g5, *argv);
        int32_t v2 = 1; // 0x80d5921
        if (argc == 1) {
            // 0x80d5923
            __printf_chk(1, (char *)&g33);
            // 0x80d5844
            return hid_find_action(name, (char **)&v1) == NULL;
        }
        int32_t v3 = *(int32_t *)(4 * v2 + (int32_t)argv);
        v2++;
        __printf_chk(1, "%s%s", (char *)&g34, (char *)v3);
        while (v2 != argc) {
            // 0x80d58f8
            v3 = *(int32_t *)(4 * v2 + (int32_t)argv);
            v2++;
            __printf_chk(1, "%s%s", (char *)&g34, (char *)v3);
        }
    }
    // 0x80d5923
    __printf_chk(1, (char *)&g33);
    // 0x80d5844
    return hid_find_action(name, (char **)&v1) == NULL;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5940 - 0x80d597e
// Line range:    272 - 284
int32_t hid_actionl(char * name, ...) {
    // 0x80d5940
    int32_t v1; // bp-92, 0x80d5940
    int32_t v2; // 0x80d5940
    if (v2 == 0) {
        // 0x80d5965
        return hid_actionv(name, 0, (char **)&v1);
    }
    int32_t v3 = 0; // 0x80d5954
    int32_t v4; // 0x80d5940
    *(int32_t *)(4 * v3 + (int32_t)&v1) = v4;
    v3++;
    int32_t v5; // 0x80d5940
    int32_t v6 = *(int32_t *)(4 * v3 + (int32_t)&v5); // 0x80d595e
    while (v6 != 0) {
        // 0x80d5958
        *(int32_t *)(4 * v3 + (int32_t)&v1) = v6;
        v3++;
        v6 = *(int32_t *)(4 * v3 + (int32_t)&v5);
    }
    // 0x80d5965
    return hid_actionv(name, v3, (char **)&v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5980 - 0x80d59a3
// Line range:    266 - 269
int32_t hid_action(char * name) {
    // 0x80d5980
    return hid_actionv(name, 0, NULL);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d59b0 - 0x80d5a50
// Line range:    246 - 263
void dump_actions(void) {
    // 0x80d59b0
    hid_find_action((char *)*(int32_t *)hid_action_context, NULL);
    int32_t v1 = 0; // 0x80d59db
    if (n_actions < 1) {
        // 0x80d5a48
        return;
    }
    int32_t v2 = 0; // 0x80d59db
    int32_t v3 = *(int32_t *)(v1 + (int32_t)all_actions); // 0x80d59fa
    v2++;
    __printf_chk(1, "A%s\n", (char *)v3);
    dump_string((char)&g279, (char *)&g279);
    dump_string((char)&g279, (char *)&g279);
    v1 += 24;
    while (n_actions > v2) {
        // 0x80d59e8
        v3 = *(int32_t *)(v1 + (int32_t)all_actions);
        v2++;
        __printf_chk(1, "A%s\n", (char *)v3);
        dump_string((char)&g279, (char *)&g279);
        dump_string((char)&g279, (char *)&g279);
        v1 += 24;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5a50 - 0x80d5bdf
// Line range:    193 - 98
void print_actions(void) {
    // 0x80d5a50
    hid_find_action((char *)*(int32_t *)hid_action_context, NULL);
    __fprintf_chk((struct _IO_FILE *)g43, 1, "Registered Actions:\n");
    int32_t v1 = 0; // 0x80d5a97
    if (n_actions < 1) {
        // 0x80d5baf
        return;
    }
    int32_t v2 = 0; // 0x80d5a97
    char v3; // 0x80d5a50
    int32_t v4; // 0x80d5a50
    int32_t v5; // 0x80d5a50
    while (true) {
      lab_0x80d5ab0:;
        int32_t v6 = v1 + (int32_t)all_actions; // 0x80d5ab3
        int32_t v7 = *(int32_t *)(v6 + 12); // 0x80d5ab9
        char * v8 = (char *)*(int32_t *)v6;
        if (v7 == 0) {
            // 0x80d5bb7
            __fprintf_chk((struct _IO_FILE *)g43, 1, "  %s\n", v8);
        } else {
            // 0x80d5ac4
            __fprintf_chk((struct _IO_FILE *)g43, 1, "  %s - %s\n", v8, (char *)v7);
        }
        int32_t v9 = *(int32_t *)(v1 + 16 + (int32_t)all_actions); // 0x80d5af3
        if (v9 == 0) {
            goto lab_0x80d5b98;
        } else {
            char v10 = *(char *)v9; // 0x80d5aff
            v3 = v10;
            v4 = v9;
            v5 = v9;
            if (v10 == 10) {
                goto lab_0x80d5b90;
            } else {
                goto lab_0x80d5b10;
            }
        }
    }
  lab_0x80d5b98:
    // 0x80d5b98
    v2++;
    v1 += 24;
    if (n_actions <= v2) {
        return;
    }
    goto lab_0x80d5ab0;
  lab_0x80d5b90:;
    int32_t v11 = v5; // 0x80d5b94
    int32_t data = v5; // 0x80d5b94
    int32_t size = 0; // 0x80d5b94
    goto lab_0x80d5b2a;
  lab_0x80d5b10:;
    int32_t v15 = v4;
    int32_t v16 = v15; // 0x80d5b14
    v5 = v15;
    if (v3 != 0) {
        int32_t v17; // 0x80d5b1c
        while (true) {
          lab_0x80d5b1c:
            // 0x80d5b1c
            v17 = v16 + 1;
            v16 = v17;
            switch (*(char *)v17) {
                case 10: {
                    goto lab_0x80d5b26;
                }
                case 0: {
                    goto lab_0x80d5b26;
                }
                default: {
                    goto lab_0x80d5b1c;
                }
            }
        }
      lab_0x80d5b26:
        // 0x80d5b26
        v11 = v17;
        data = v15;
        size = v17 - v15;
        goto lab_0x80d5b2a;
    } else {
        goto lab_0x80d5b90;
    }
  lab_0x80d5b2a:;
    int32_t v12 = v11;
    fwrite((int32_t *)"    ", 4, 1, (struct _IO_FILE *)g43);
    fwrite((int32_t *)data, size, 1, (struct _IO_FILE *)g43);
    fputc(10, (struct _IO_FILE *)g43);
    if (*(char *)v12 == 0) {
        goto lab_0x80d5b98;
    } else {
        int32_t v13 = v12 + 1; // 0x80d5b86
        char v14 = *(char *)v13; // 0x80d5b89
        v3 = v14;
        v4 = v13;
        v5 = v13;
        if (v14 != 10) {
            goto lab_0x80d5b10;
        } else {
            goto lab_0x80d5b90;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5be0 - 0x80d5c88
// Line range:    52 - 52
void hid_register_actions_context(int32_t * a, int32_t n, char * context, int32_t dynamic) {
    int32_t * mem = malloc(20); // 0x80d5bfd
    int32_t v1 = (int32_t)mem; // 0x80d5bfd
    *(int32_t *)&hid_action_nodes = v1;
    *mem = (int32_t)hid_action_nodes;
    int32_t v2; // 0x80d5be0
    if (a != NULL) {
        int32_t * mem2 = malloc(20); // 0x80d5c5f
        int32_t v3 = (int32_t)mem2; // 0x80d5c5f
        *(int32_t *)(v1 + 4) = v3;
        *mem2 = v3;
        *(int32_t *)(v3 + 4) = *(int32_t *)(v2 + 4);
        *(int32_t *)(v3 + 8) = *(int32_t *)(v2 + 8);
        *(int32_t *)(v3 + 12) = *(int32_t *)(v2 + 12);
        *(int32_t *)(v3 + 16) = *(int32_t *)(v2 + 16);
    }
    // 0x80d5c1e
    n_actions += v2;
    *(int32_t *)(v1 + 16) = (int32_t)a;
    if (all_actions != NULL) {
        // 0x80d5c39
        free(all_actions);
        *(int32_t *)&all_actions = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5cb0 - 0x80d5ccb
// Line range:    80 - 82
void hid_register_actions(int32_t * a, int32_t n) {
    // 0x80d5cb0
    hid_register_actions_context(NULL, (int32_t)&g279, (char *)&g279, (int32_t)&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/flags.c
// Address range: 0x80d5ef0 - 0x80d605a
// Line range:    63 - 75
int32_t * hid_find_flag(char * name) {
    // 0x80d5ef0
    if (all_flags == NULL) {
        int32_t * mem = calloc(1, 12 * n_flags); // 0x80d5fad
        int32_t v1 = (int32_t)mem; // 0x80d5fad
        char * v2 = (char *)mem; // bp-40, 0x80d5fc1
        *(int32_t *)&all_flags = v1;
        int32_t base = v1; // 0x80d5fc9
        if (hid_flag_nodes != NULL) {
            int32_t v3 = (int32_t)hid_flag_nodes;
            int32_t v4 = 0;
            int32_t * v5 = (int32_t *)(v3 + 8); // 0x80d5fd0
            int32_t v6 = v4; // 0x80d5fdb
            int32_t v7; // 0x80d5ef0
            int32_t v8; // 0x80d5ef0
            uint32_t v9; // 0x80d5ef0
            int32_t v10; // 0x80d5ef0
            int32_t v11; // 0x80d5ef0
            if (*v5 >= 1) {
                // 0x80d5fdd
                v7 = 0;
                v9 = 1;
                v10 = v7 + *(int32_t *)(v3 + 4);
                v11 = 12 * v4 + (int32_t)v2 + v7;
                *(int32_t *)v11 = *(int32_t *)v10;
                *(int32_t *)(v11 + 4) = *(int32_t *)(v10 + 4);
                *(int32_t *)(v11 + 8) = *(int32_t *)(v10 + 8);
                v7 += 12;
                v8 = v9 + 1;
                while (*v5 > v9) {
                    // 0x80d5ff8
                    v9 = v8;
                    v10 = v7 + *(int32_t *)(v3 + 4);
                    v11 = 12 * v4 + (int32_t)v2 + v7;
                    *(int32_t *)v11 = *(int32_t *)v10;
                    *(int32_t *)(v11 + 4) = *(int32_t *)(v10 + 4);
                    *(int32_t *)(v11 + 8) = *(int32_t *)(v10 + 8);
                    v7 += 12;
                    v8 = v9 + 1;
                }
                // 0x80d6023
                v6 = v9 + v4;
            }
            int32_t v12 = *(int32_t *)v3; // 0x80d6023
            while (v12 != 0) {
                // 0x80d5fd0
                v3 = v12;
                v4 = v6;
                v5 = (int32_t *)(v3 + 8);
                v6 = v4;
                if (*v5 >= 1) {
                    // 0x80d5fdd
                    v7 = 0;
                    v9 = 1;
                    v10 = v7 + *(int32_t *)(v3 + 4);
                    v11 = 12 * v4 + (int32_t)v2 + v7;
                    *(int32_t *)v11 = *(int32_t *)v10;
                    *(int32_t *)(v11 + 4) = *(int32_t *)(v10 + 4);
                    *(int32_t *)(v11 + 8) = *(int32_t *)(v10 + 8);
                    v7 += 12;
                    v8 = v9 + 1;
                    while (*v5 > v9) {
                        // 0x80d5ff8
                        v9 = v8;
                        v10 = v7 + *(int32_t *)(v3 + 4);
                        v11 = 12 * v4 + (int32_t)v2 + v7;
                        *(int32_t *)v11 = *(int32_t *)v10;
                        *(int32_t *)(v11 + 4) = *(int32_t *)(v10 + 4);
                        *(int32_t *)(v11 + 8) = *(int32_t *)(v10 + 8);
                        v7 += 12;
                        v8 = v9 + 1;
                    }
                    // 0x80d6023
                    v6 = v9 + v4;
                }
                // 0x80d6023
                v12 = *(int32_t *)v3;
            }
            // 0x80d6031
            base = (int32_t)v2;
        }
        // 0x80d6031
        qsort((int32_t *)base, n_flags, 12, (int32_t (*)(int32_t *, int32_t *))0x80d5ed0);
    }
    // 0x80d5f07
    if (n_flags <= 0xffffffff) {
        // 0x80d5f70
        __printf_chk(1, "unknown flag `%s'\n", name);
        // 0x80d5f8d
        return NULL;
    }
    int32_t v13 = n_flags; // 0x80d5f20
    int32_t v14 = n_flags + 1; // 0x80d5f40
    int32_t v15 = -1;
    while (true) {
        uint32_t v16 = v13;
        int32_t v17 = v15 + v14; // 0x80d5f36
        int32_t v18 = v17 + (int32_t)(v17 < 0); // 0x80d5f3e
        v14 = v18 >> 1;
        int32_t * str = (int32_t *)(4 * (v14 + (v18 & 0x3ffffffe)) + (int32_t)all_flags);
        int32_t strcmp_rc = strcmp((char *)*str, name); // 0x80d5f57
        int32_t * result = str; // 0x80d5f5f
        if (strcmp_rc == 0) {
            return result;
        }
        while (strcmp_rc < 0) {
            // 0x80d5f63
            if (v16 <= v14) {
                // 0x80d5f70
                __printf_chk(1, "unknown flag `%s'\n", name);
                // 0x80d5f8d
                return NULL;
            }
            v15 = v14;
            v17 = v15 + v14;
            v18 = v17 + (int32_t)(v17 < 0);
            v14 = v18 >> 1;
            str = (int32_t *)(4 * (v14 + (v18 & 0x3ffffffe)) + (int32_t)all_flags);
            strcmp_rc = strcmp((char *)*str, name);
            result = str;
            if (strcmp_rc == 0) {
                return result;
            }
        }
        // 0x80d5f20
        v13 = v14 - 1;
        if (v13 <= v15) {
            // 0x80d5f70
            __printf_chk(1, "unknown flag `%s'\n", name);
            // 0x80d5f8d
            return NULL;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/flags.c
// Address range: 0x80d6060 - 0x80d6163
// Line range:    98 - 127
int32_t hid_get_flag(char * name) {
    char * found_char_pos = strchr(name, 44); // 0x80d607d
    if (found_char_pos == NULL) {
        int32_t * v1 = hid_find_flag(name); // 0x80d6143
        if (v1 != NULL) {
            // 0x80d614c
            return *(int32_t *)((int32_t)v1 + 4);
        }
        // 0x80d60f5
        return 0;
    }
    int32_t v2 = (int32_t)found_char_pos; // 0x80d607d
    int32_t v3 = v2 - (int32_t)name; // 0x80d608e
    char * v4; // 0x80d6060
    if (v3 < g113) {
        // 0x80d6098
        v4 = g114;
    } else {
        int32_t v5 = v3 + 10; // 0x80d6110
        g113 = v5;
        char * v6 = MyRealloc(g114, v5, "hid_get_flag"); // 0x80d612c
        g114 = v6;
        v4 = v6;
    }
    // 0x80d609d
    memcpy((int32_t *)v4, (int32_t *)name, v3);
    *(char *)(v3 + (int32_t)g114) = 0;
    int32_t str_as_l = strtol((char *)(v2 + 1), NULL, 0); // 0x80d60cc
    int32_t * v7 = hid_find_flag(g114); // 0x80d60db
    int32_t result = 0; // 0x80d60e2
    if (v7 != NULL) {
        // 0x80d60e4
        result = str_as_l == (int32_t)v7;
    }
    // 0x80d60f5
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/flags.c
// Address range: 0x80d6170 - 0x80d61cb
// Line range:    36 - 52
void hid_register_flags(int32_t * a, int32_t n) {
    int32_t * mem = calloc(1, 12); // 0x80d6189
    int32_t v1 = (int32_t)mem; // 0x80d6189
    *mem = (int32_t)hid_flag_nodes;
    *(int32_t *)(v1 + 8) = n;
    *(int32_t *)&hid_flag_nodes = v1;
    n_flags += n;
    *(int32_t *)(v1 + 4) = (int32_t)a;
    if (all_flags != NULL) {
        // 0x80d61b3
        free(all_flags);
        *(int32_t *)&all_flags = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6200 - 0x80d6237
// Line range:    207 - 216
int32_t * hid_find_printer(void) {
    // 0x80d6200
    if (hid_num_hids < 1) {
        // 0x80d6234
        return (int32_t *)0;
    }
    int32_t v1 = (int32_t)hid_list; // 0x80d620e
    if ((*(char *)&hid_attr_nodes & 2) != 0) {
        // 0x80d6234
        return (int32_t *)v1;
    }
    int32_t v2 = 0; // 0x80d621c
    v2++;
    int32_t v3 = 0; // 0x80d6230
    while (hid_num_hids > v2) {
        int32_t v4 = *(int32_t *)(4 * v2 + v1); // 0x80d6220
        v3 = v4;
        if ((*(char *)(v4 + 12) & 2) != 0) {
            // break -> 0x80d6234
            break;
        }
        v2++;
        v3 = 0;
    }
    // 0x80d6234
    return (int32_t *)v3;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6240 - 0x80d624a
// Line range:    237 - 240
int32_t ** hid_enumerate(void) {
    // 0x80d6240
    return hid_list;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6250 - 0x80d6285
// Line range:    245 - 255
void hid_register_attributes(int32_t * a, int32_t n) {
    int32_t * mem = calloc(1, 12); // 0x80d6265
    int32_t v1 = (int32_t)mem; // 0x80d6265
    *mem = (int32_t)hid_attr_nodes;
    *(int32_t *)&hid_attr_nodes = v1;
    *(int32_t *)(v1 + 4) = (int32_t)a;
    *(int32_t *)(v1 + 8) = n;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d65c0 - 0x80d66b9
// Line range:    219 - 234
int32_t * hid_find_exporter(char * which) {
    // 0x80d65c0
    int32_t * result; // 0x80d65c0
    for (int32_t i = 0; i < (uint32_t)hid_num_hids; i++) {
        int32_t v1 = *(int32_t *)(4 * i + (int32_t)hid_list); // 0x80d65e0
        if ((*(char *)(v1 + 12) & 4) != 0) {
            // 0x80d65e9
            if (strcmp(which, (char *)*(int32_t *)(v1 + 4)) == 0) {
                // 0x80d66af
                result = (int32_t *)v1;
                return result;
            }
        }
    }
    // 0x80d6610
    __fprintf_chk((struct _IO_FILE *)g43, 1, "Invalid exporter %s, available ones:", which);
    int32_t v2 = hid_num_hids; // 0x80d663c
    int32_t v3 = 0; // 0x80d663c
    if (hid_num_hids >= 1) {
        while (true) {
            int32_t v4 = v3;
            int32_t v5 = *(int32_t *)(4 * v4 + (int32_t)hid_list); // 0x80d6658
            int32_t v6; // 0x80d65c0
            if ((*(char *)(v5 + 12) & 4) == 0) {
                int32_t v7 = v4 + 1; // 0x80d6648
                v6 = v2;
                v3 = v7;
                if (v2 <= v7) {
                    // break -> 0x80d6690
                    break;
                }
            } else {
                int32_t v8 = v4 + 1; // 0x80d6664
                __fprintf_chk((struct _IO_FILE *)g43, 1, " %s", (char *)*(int32_t *)(v5 + 4));
                v6 = hid_num_hids;
                v3 = v8;
                if (hid_num_hids <= v8) {
                    // break -> 0x80d6690
                    break;
                }
            }
            // 0x80d6653
            v2 = v6;
        }
    }
    // 0x80d6690
    __fprintf_chk((struct _IO_FILE *)g43, 1, "\n");
    result = NULL;
  lab_0x80d66af_2:
    // 0x80d66af
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d66c0 - 0x80d6727
// Line range:    194 - 203
int32_t * hid_find_gui(void) {
    // 0x80d66c0
    if (hid_num_hids < 1) {
        // 0x80d66fe
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Error: No GUI available.\n");
        exit(1);
        // UNREACHABLE
    }
    int32_t v1 = (int32_t)hid_list; // 0x80d66d1
    if ((*(char *)&hid_attr_nodes & 6) == 0) {
        // 0x80d66f8
        return (int32_t *)v1;
    }
    int32_t v2 = 0; // 0x80d66df
    v2++;
    while (hid_num_hids > v2) {
        int32_t v3 = *(int32_t *)(4 * v2 + v1); // 0x80d66ef
        int32_t v4 = v3; // 0x80d66f6
        if ((*(char *)(v3 + 12) & 6) == 0) {
            // 0x80d66f8
            return (int32_t *)v4;
        }
        v2++;
    }
    // 0x80d66fe
    __fprintf_chk((struct _IO_FILE *)g43, 1, "Error: No GUI available.\n");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6730 - 0x80d6a80
// Line range:    561 - 596
void hid_load_settings_1(char * fname) {
    int32_t v1 = __readgsdword(20); // 0x80d6746
    int32_t file_path; // 0x80d6730
    struct _IO_FILE * file = fopen((char *)file_path, (char *)&g279); // 0x80d6754
    free((int32_t *)file_path);
    if (file != NULL) {
        // 0x80d6770
        int32_t str; // bp-1056, 0x80d6730
        if (fgets((char *)&str, 1024, file) != NULL) {
            // 0x80d6798
            while (true) {
                // 0x80d6798
                if ((char)str != 0) {
                    int16_t * v2 = *__ctype_b_loc(); // 0x80d67bb
                    int32_t v3 = &str;
                    int32_t v4 = str % 256;
                    char v5 = *(char *)((int32_t)v2 + 1 + (0x1000000 * v4 >> 23)); // 0x80d67cd
                    while ((v5 & 32) != 0) {
                        int32_t v6 = v3 + 1; // 0x80d67c0
                        unsigned char v7 = *(char *)v6; // 0x80d67c3
                        int32_t v8 = v7; // 0x80d67c8
                        if (v7 == 0) {
                            goto lab_0x80d6770_3;
                        }
                        v3 = v6;
                        v4 = v8;
                        v5 = *(char *)((int32_t)v2 + 1 + (0x1000000 * v4 >> 23));
                    }
                    if (v4 != 35) {
                        char * str3 = (char *)v3; // 0x80d67d9
                        char v9 = *str3; // 0x80d67d9
                        if (v9 != 0) {
                            int16_t ** v10 = __ctype_b_loc(); // 0x80d67e6
                            int32_t v11 = (int32_t)*v10 + 1; // 0x80d6811
                            char v12 = v9; // 0x80d67f8
                            int32_t v13 = v3;
                            while ((*(char *)(v11 + (0x1000000 * (int32_t)v12 >> 23)) & 32) == 0) {
                                int32_t v14 = v13 + 1; // 0x80d6800
                                v12 = *(char *)v14;
                                if (v12 == 0) {
                                    goto lab_0x80d6770_3;
                                }
                                v13 = v14;
                            }
                            // 0x80d6818
                            *(char *)v13 = 0;
                            int32_t v15 = v13 + 1; // 0x80d681b
                            char v16 = *(char *)v15; // 0x80d681e
                            if (v16 != 0) {
                                int32_t v17 = (int32_t)*v10 + 1; // 0x80d6841
                                char v18 = v16; // 0x80d682c
                                uint32_t v19 = v15;
                                char v20 = *(char *)(v17 + (0x1000000 * (int32_t)v18 >> 23)); // 0x80d6841
                                while (v18 == 61 || (v20 & 32) != 0) {
                                    int32_t v21 = v19 + 1; // 0x80d6830
                                    v18 = *(char *)v21;
                                    if (v18 == 0) {
                                        goto lab_0x80d6770_3;
                                    }
                                    v19 = v21;
                                    v20 = *(char *)(v17 + (0x1000000 * (int32_t)v18 >> 23));
                                }
                                char * str2 = (char *)v19;
                                int32_t v22 = v19 - 1 + strlen(str2); // 0x80d6854
                                int32_t v23 = v22; // 0x80d685a
                                if (v22 >= v19) {
                                    int32_t v24 = v23;
                                    char * v25 = (char *)v24; // 0x80d686a
                                    char v26 = *(char *)((int32_t)*v10 + 1 + 2 * (int32_t)*v25); // 0x80d686f
                                    while ((v26 & 32) != 0) {
                                        // 0x80d6860
                                        *v25 = 0;
                                        int32_t v27 = v24 - 1; // 0x80d6863
                                        v23 = v27;
                                        if (v27 < v19) {
                                            // break -> 0x80d6876
                                            break;
                                        }
                                        v24 = v23;
                                        v25 = (char *)v24;
                                        v26 = *(char *)((int32_t)*v10 + 1 + 2 * (int32_t)*v25);
                                    }
                                }
                                // 0x80d6876
                                if (hid_attr_nodes != NULL) {
                                    int32_t v28 = (int32_t)hid_attr_nodes;
                                    int32_t * v29 = (int32_t *)(v28 + 8); // 0x80d689f
                                    int32_t v30; // 0x80d6730
                                    int32_t v31; // 0x80d6730
                                    int32_t v32; // 0x80d68b1
                                    char * str4; // 0x80d6730
                                    int32_t v33; // 0x80d690e
                                    int32_t v34; // 0x80d6938
                                    int32_t v35; // 0x80d693b
                                    int32_t v36; // 0x80d6968
                                    int32_t str5; // 0x80d696b
                                    if (*v29 >= 1) {
                                        // 0x80d68a8
                                        v31 = 0;
                                        v33 = 0;
                                        v32 = *(int32_t *)(v28 + 4) + v31;
                                        g278 = v32;
                                        str4 = (char *)*(int32_t *)v32;
                                        if (strcmp(str3, str4) == 0) {
                                            // 0x80d68d7
                                            switch (g278) {
                                                case 1: {
                                                    // 0x80d68e1
                                                    *(int32_t *)(v32 + 20) = strtol(str2, NULL, 0);
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 2: {
                                                    // 0x80d69d2
                                                    *(float64_t *)(v32 + 28) = strtod(str2, NULL);
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 3: {
                                                    // 0x80d69bc
                                                    *(int32_t *)(v32 + 24) = (int32_t)__strdup(str2);
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 4: {
                                                    // 0x80d69ab
                                                    *(int32_t *)(v32 + 20) = 1;
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 5: {
                                                    // 0x80d6938
                                                    v34 = *(int32_t *)(v32 + 36);
                                                    v35 = *(int32_t *)v34;
                                                    str5 = v35;
                                                    if (v35 == 0) {
                                                        // 0x80d6a29
                                                        __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                        exit(1);
                                                        // UNREACHABLE
                                                    }
                                                    v30 = 0;
                                                    while (strcmp((char *)str5, str2) != 0) {
                                                        // 0x80d6968
                                                        v36 = v30 + 1;
                                                        str5 = *(int32_t *)(4 * v36 + v34);
                                                        if (str5 == 0) {
                                                            // 0x80d6a29
                                                            __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                            exit(1);
                                                            // UNREACHABLE
                                                        }
                                                        v30 = v36;
                                                    }
                                                    // 0x80d6986
                                                    *(int32_t *)(v32 + 20) = v30;
                                                    *(int32_t *)(v32 + 24) = v19;
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 6: {
                                                    // 0x80d69b7
                                                    abort();
                                                    // UNREACHABLE
                                                }
                                                case 7: {
                                                    // 0x80d69f0
                                                    *(int32_t *)(v32 + 24) = v19;
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                            }
                                        }
                                        // 0x80d6908
                                        v33++;
                                        v31 += 48;
                                        while (v33 < *v29) {
                                            // 0x80d68a8
                                            v32 = *(int32_t *)(v28 + 4) + v31;
                                            g278 = v32;
                                            str4 = (char *)*(int32_t *)v32;
                                            if (strcmp(str3, str4) == 0) {
                                                // 0x80d68d7
                                                switch (g278) {
                                                    case 1: {
                                                        // 0x80d68e1
                                                        *(int32_t *)(v32 + 20) = strtol(str2, NULL, 0);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 2: {
                                                        // 0x80d69d2
                                                        *(float64_t *)(v32 + 28) = strtod(str2, NULL);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 3: {
                                                        // 0x80d69bc
                                                        *(int32_t *)(v32 + 24) = (int32_t)__strdup(str2);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 4: {
                                                        // 0x80d69ab
                                                        *(int32_t *)(v32 + 20) = 1;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 5: {
                                                        // 0x80d6938
                                                        v34 = *(int32_t *)(v32 + 36);
                                                        v35 = *(int32_t *)v34;
                                                        str5 = v35;
                                                        if (v35 == 0) {
                                                            // 0x80d6a29
                                                            __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                            exit(1);
                                                            // UNREACHABLE
                                                        }
                                                        v30 = 0;
                                                        while (strcmp((char *)str5, str2) != 0) {
                                                            // 0x80d6968
                                                            v36 = v30 + 1;
                                                            str5 = *(int32_t *)(4 * v36 + v34);
                                                            if (str5 == 0) {
                                                                // 0x80d6a29
                                                                __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                exit(1);
                                                                // UNREACHABLE
                                                            }
                                                            v30 = v36;
                                                        }
                                                        // 0x80d6986
                                                        *(int32_t *)(v32 + 20) = v30;
                                                        *(int32_t *)(v32 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 6: {
                                                        // 0x80d69b7
                                                        abort();
                                                        // UNREACHABLE
                                                    }
                                                    case 7: {
                                                        // 0x80d69f0
                                                        *(int32_t *)(v32 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                }
                                            }
                                            // 0x80d6908
                                            v33++;
                                            v31 += 48;
                                        }
                                    }
                                    int32_t v37 = *(int32_t *)v28; // 0x80d691f
                                    while (v37 != 0) {
                                        // 0x80d6895
                                        v28 = v37;
                                        v29 = (int32_t *)(v28 + 8);
                                        if (*v29 >= 1) {
                                            // 0x80d68a8
                                            v31 = 0;
                                            v33 = 0;
                                            v32 = *(int32_t *)(v28 + 4) + v31;
                                            g278 = v32;
                                            str4 = (char *)*(int32_t *)v32;
                                            if (strcmp(str3, str4) == 0) {
                                                // 0x80d68d7
                                                switch (g278) {
                                                    case 1: {
                                                        // 0x80d68e1
                                                        *(int32_t *)(v32 + 20) = strtol(str2, NULL, 0);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 2: {
                                                        // 0x80d69d2
                                                        *(float64_t *)(v32 + 28) = strtod(str2, NULL);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 3: {
                                                        // 0x80d69bc
                                                        *(int32_t *)(v32 + 24) = (int32_t)__strdup(str2);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 4: {
                                                        // 0x80d69ab
                                                        *(int32_t *)(v32 + 20) = 1;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 5: {
                                                        // 0x80d6938
                                                        v34 = *(int32_t *)(v32 + 36);
                                                        v35 = *(int32_t *)v34;
                                                        str5 = v35;
                                                        if (v35 == 0) {
                                                            // 0x80d6a29
                                                            __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                            exit(1);
                                                            // UNREACHABLE
                                                        }
                                                        v30 = 0;
                                                        while (strcmp((char *)str5, str2) != 0) {
                                                            // 0x80d6968
                                                            v36 = v30 + 1;
                                                            str5 = *(int32_t *)(4 * v36 + v34);
                                                            if (str5 == 0) {
                                                                // 0x80d6a29
                                                                __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                exit(1);
                                                                // UNREACHABLE
                                                            }
                                                            v30 = v36;
                                                        }
                                                        // 0x80d6986
                                                        *(int32_t *)(v32 + 20) = v30;
                                                        *(int32_t *)(v32 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 6: {
                                                        // 0x80d69b7
                                                        abort();
                                                        // UNREACHABLE
                                                    }
                                                    case 7: {
                                                        // 0x80d69f0
                                                        *(int32_t *)(v32 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                }
                                            }
                                            // 0x80d6908
                                            v33++;
                                            v31 += 48;
                                            while (v33 < *v29) {
                                                // 0x80d68a8
                                                v32 = *(int32_t *)(v28 + 4) + v31;
                                                g278 = v32;
                                                str4 = (char *)*(int32_t *)v32;
                                                if (strcmp(str3, str4) == 0) {
                                                    // 0x80d68d7
                                                    switch (g278) {
                                                        case 1: {
                                                            // 0x80d68e1
                                                            *(int32_t *)(v32 + 20) = strtol(str2, NULL, 0);
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 2: {
                                                            // 0x80d69d2
                                                            *(float64_t *)(v32 + 28) = strtod(str2, NULL);
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 3: {
                                                            // 0x80d69bc
                                                            *(int32_t *)(v32 + 24) = (int32_t)__strdup(str2);
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 4: {
                                                            // 0x80d69ab
                                                            *(int32_t *)(v32 + 20) = 1;
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 5: {
                                                            // 0x80d6938
                                                            v34 = *(int32_t *)(v32 + 36);
                                                            v35 = *(int32_t *)v34;
                                                            str5 = v35;
                                                            if (v35 == 0) {
                                                                // 0x80d6a29
                                                                __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                exit(1);
                                                                // UNREACHABLE
                                                            }
                                                            v30 = 0;
                                                            while (strcmp((char *)str5, str2) != 0) {
                                                                // 0x80d6968
                                                                v36 = v30 + 1;
                                                                str5 = *(int32_t *)(4 * v36 + v34);
                                                                if (str5 == 0) {
                                                                    // 0x80d6a29
                                                                    __fprintf_chk((struct _IO_FILE *)g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                    exit(1);
                                                                    // UNREACHABLE
                                                                }
                                                                v30 = v36;
                                                            }
                                                            // 0x80d6986
                                                            *(int32_t *)(v32 + 20) = v30;
                                                            *(int32_t *)(v32 + 24) = v19;
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 6: {
                                                            // 0x80d69b7
                                                            abort();
                                                            // UNREACHABLE
                                                        }
                                                        case 7: {
                                                            // 0x80d69f0
                                                            *(int32_t *)(v32 + 24) = v19;
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                    }
                                                }
                                                // 0x80d6908
                                                v33++;
                                                v31 += 48;
                                            }
                                        }
                                        // 0x80d6919
                                        v37 = *(int32_t *)v28;
                                    }
                                }
                            }
                        }
                    }
                }
              lab_0x80d6770_3:
                // 0x80d6770
                if (fgets((char *)&str, 1024, file) == NULL) {
                    // break -> 0x80d69fe
                    break;
                }
            }
        }
        // 0x80d69fe
        fclose(file);
    }
    // 0x80d6a0c
    if (v1 == __readgsdword(20)) {
        // 0x80d6a18
        return;
    }
    // 0x80d6a6a
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6a80 - 0x80d6b5d
// Line range:    599 - 612
void hid_load_settings(void) {
    // 0x80d6a80
    if (hid_attr_nodes != NULL) {
        int32_t v1 = (int32_t)hid_attr_nodes;
        int32_t * v2 = (int32_t *)(v1 + 8); // 0x80d6a93
        int32_t v3; // 0x80d6a80
        int32_t v4; // 0x80d6a80
        int32_t v5; // 0x80d6aba
        int32_t v6; // 0x80d6ac4
        unsigned char v7; // 0x80d6ab3
        int32_t v8; // 0x80d6ab7
        if (*v2 >= 1) {
            // 0x80d6a9a
            v4 = *(int32_t *)(v1 + 4);
            v6 = 0;
            v8 = 0;
            v3 = 0;
            v7 = *(char *)(v8 + v4);
            v8++;
            v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
            while (v8 != 44) {
                // 0x80d6aa8
                v3 = v5;
                v7 = *(char *)(v8 + v4);
                v8++;
                v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
            }
            // 0x80d6ac1
            *(int32_t *)(v4 + 44) = v5;
            v6++;
            v4 += 48;
            while (*v2 > v6) {
                // 0x80d6aa0
                v8 = 0;
                v3 = 0;
                v7 = *(char *)(v8 + v4);
                v8++;
                v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
                while (v8 != 44) {
                    // 0x80d6aa8
                    v3 = v5;
                    v7 = *(char *)(v8 + v4);
                    v8++;
                    v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
                }
                // 0x80d6ac1
                *(int32_t *)(v4 + 44) = v5;
                v6++;
                v4 += 48;
            }
        }
        int32_t v9 = *(int32_t *)v1; // 0x80d6acf
        while (v9 != 0) {
            // 0x80d6a93
            v1 = v9;
            v2 = (int32_t *)(v1 + 8);
            if (*v2 >= 1) {
                // 0x80d6a9a
                v4 = *(int32_t *)(v1 + 4);
                v6 = 0;
                v8 = 0;
                v3 = 0;
                v7 = *(char *)(v8 + v4);
                v8++;
                v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
                while (v8 != 44) {
                    // 0x80d6aa8
                    v3 = v5;
                    v7 = *(char *)(v8 + v4);
                    v8++;
                    v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
                }
                // 0x80d6ac1
                *(int32_t *)(v4 + 44) = v5;
                v6++;
                v4 += 48;
                while (*v2 > v6) {
                    // 0x80d6aa0
                    v8 = 0;
                    v3 = 0;
                    v7 = *(char *)(v8 + v4);
                    v8++;
                    v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
                    while (v8 != 44) {
                        // 0x80d6aa8
                        v3 = v5;
                        v7 = *(char *)(v8 + v4);
                        v8++;
                        v5 = v3 >> 16 ^ 13 * v3 ^ (int32_t)v7;
                    }
                    // 0x80d6ac1
                    *(int32_t *)(v4 + 44) = v5;
                    v6++;
                    v4 += 48;
                }
            }
            // 0x80d6acf
            v9 = *(int32_t *)v1;
        }
    }
    // 0x80d6ad5
    Concat((char *)pcblibdir);
    hid_load_settings_1((char *)&g279);
    if (homedir != 0) {
        // 0x80d6b08
        Concat((char *)homedir);
        hid_load_settings_1((char *)&g279);
    }
    // 0x80d6b3d
    Concat("pcb.settings");
    hid_load_settings_1((char *)&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d7300 - 0x80d73c4
// Line range:    153 - 165
void hid_register_hid(int32_t * hid) {
    int32_t v1 = (int32_t)hid;
    if (*hid != 208) {
        int32_t v2 = *(int32_t *)(v1 + 4); // 0x80d7378
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Warning: hid \"%s\" has an incompatible ABI.\n", (char *)v2);
        return;
    }
    uint32_t v3 = hid_num_hids; // 0x80d730a
    if (v3 >= 1) {
        // 0x80d7320
        if ((int32_t *)hid_list == hid) {
            // 0x80d7372
            return;
        }
        int32_t v4 = 0; // 0x80d732a
        v4++;
        while (v3 > v4) {
            // 0x80d7330
            if (*(int32_t *)(4 * v4 + (int32_t)hid_list) == v1) {
                // 0x80d7372
                return;
            }
            v4++;
        }
    }
    int32_t size = 4 * v3 + 8; // 0x80d733c
    hid_num_hids = v3 + 1;
    int32_t * mem; // 0x80d7300
    if (hid_list == NULL) {
        // 0x80d73a2
        mem = calloc(1, size);
    } else {
        // 0x80d7350
        mem = realloc((int32_t *)hid_list, size);
    }
    int32_t v5 = (int32_t)mem;
    *(int32_t *)&hid_list = v5;
    int32_t v6 = 4 * hid_num_hids + v5;
    *(int32_t *)(v6 - 4) = v1;
    *(int32_t *)v6 = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d73d0 - 0x80d75a2
// Line range:    56 - 108
void hid_load_dir(char * dirname) {
    // 0x80d73d0
    char v1; // 0x80d73d0
    char v2 = v1;
    int32_t v3; // 0x80d73d0
    char * name = (char *)v3;
    struct __dirstream * dirp = opendir(name); // 0x80d73e2
    if (dirp == NULL) {
        // 0x80d74e8
        free((int32_t *)v3);
        return;
    }
    struct dirent * v4 = readdir(dirp); // 0x80d7464
    if (v4 == NULL) {
        // 0x80d74e8
        free((int32_t *)v3);
        return;
    }
    char * str = __strdup((char *)((int32_t)v4 + 11)); // 0x80d7473
    uint32_t len = strlen(str); // 0x80d747d
    int32_t v5; // 0x80d73d0
    char * str2; // 0x80d73d0
    char * str3; // 0x80d73d0
    if (len >= 4) {
        // 0x80d748d
        v5 = len + (int32_t)str;
        str2 = (char *)(v5 - 3);
        if (strcasecmp(str2, ".so") == 0) {
            // 0x80d73f8
            *str2 = 0;
        } else {
            if (len != 4) {
                // 0x80d74be
                str3 = (char *)(v5 - 4);
                if (strcasecmp(str3, ".dll") == 0) {
                    // 0x80d74da
                    *str3 = 0;
                }
            }
        }
    }
    char * file_path = Concat(name); // 0x80d7415
    int32_t v6; // bp-116, 0x80d73d0
    int32_t v7 = __xstat(3, file_path, (struct stat *)&v6); // 0x80d742e
    int32_t * v8; // 0x80d750b
    char * v9; // 0x80d7531
    if (((int32_t)v2 & 0xf000) == 0x8000 && (v2 & 73) != 0 && v7 == 0) {
        // 0x80d7500
        v8 = dlopen(file_path, 258);
        if (v8 == NULL) {
            // 0x80d7561
            __fprintf_chk((struct _IO_FILE *)g43, 1, "dl_error: %s\n", dlerror());
        } else {
            // 0x80d7516
            v9 = Concat("hid_");
            if (dlsym(v8, v9) == NULL) {
                // 0x80d758c
                dlsym(v8, "pcb_plugin_init");
            }
            // 0x80d754e
            free((int32_t *)v9);
        }
    }
    // 0x80d744e
    free((int32_t *)str);
    free((int32_t *)file_path);
    struct dirent * v10 = readdir(dirp); // 0x80d7464
    while (v10 != NULL) {
        // 0x80d746d
        str = __strdup((char *)((int32_t)v10 + 11));
        len = strlen(str);
        if (len >= 4) {
            // 0x80d748d
            v5 = len + (int32_t)str;
            str2 = (char *)(v5 - 3);
            if (strcasecmp(str2, ".so") == 0) {
                // 0x80d73f8
                *str2 = 0;
            } else {
                if (len != 4) {
                    // 0x80d74be
                    str3 = (char *)(v5 - 4);
                    if (strcasecmp(str3, ".dll") == 0) {
                        // 0x80d74da
                        *str3 = 0;
                    }
                }
            }
        }
        // 0x80d73fb
        file_path = Concat(name);
        v7 = __xstat(3, file_path, (struct stat *)&v6);
        if (((int32_t)v2 & 0xf000) == 0x8000 && (v2 & 73) != 0 && v7 == 0) {
            // 0x80d7500
            v8 = dlopen(file_path, 258);
            if (v8 == NULL) {
                // 0x80d7561
                __fprintf_chk((struct _IO_FILE *)g43, 1, "dl_error: %s\n", dlerror());
            } else {
                // 0x80d7516
                v9 = Concat("hid_");
                if (dlsym(v8, v9) == NULL) {
                    // 0x80d758c
                    dlsym(v8, "pcb_plugin_init");
                }
                // 0x80d754e
                free((int32_t *)v9);
            }
        }
        // 0x80d744e
        free((int32_t *)str);
        free((int32_t *)file_path);
        v10 = readdir(dirp);
    }
    // 0x80d74e8
    free((int32_t *)v3);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d75b0 - 0x80d7754
// Line range:    123 - 149
void hid_init(void) {
    // 0x80d75b0
    *(int32_t *)&gui = (int32_t)&hid_nogui;
    hid_gtk_init();
    hid_lpr_init();
    hid_bom_init();
    hid_gerber_init();
    hid_nelma_init();
    hid_png_init();
    hid_ps_init();
    Concat((char *)exec_prefix);
    hid_load_dir((char *)&g279);
    Concat((char *)exec_prefix);
    hid_load_dir((char *)&g279);
    if (homedir != 0) {
        // 0x80d7692
        Concat((char *)homedir);
        hid_load_dir((char *)&g279);
        Concat((char *)homedir);
        hid_load_dir((char *)&g279);
    }
    // 0x80d7711
    Concat("plugins");
    hid_load_dir((char *)&g279);
    Concat("plugins");
    hid_load_dir((char *)&g279);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidnogui.c
// Address range: 0x80d77b0 - 0x80d7e91
// Line range:    412 - 458
void apply_default_hid(int32_t * d, int32_t * s) {
    int32_t v1 = (int32_t)d;
    int32_t v2 = s == NULL ? (int32_t)&hid_nogui : (int32_t)s; // 0x80d77c0
    int32_t * v3 = (int32_t *)(v1 + 16); // 0x80d77c3
    int32_t * v4; // 0x80d77b0
    if (*v3 == 0) {
        // 0x80d7a08
        *v3 = *(int32_t *)(v2 + 16);
        int32_t * v5 = (int32_t *)(v1 + 20);
        v4 = v5;
        if (*v5 != 0) {
            goto lab_0x80d77d9;
        } else {
            goto lab_0x80d7a20;
        }
    } else {
        int32_t * v6 = (int32_t *)(v1 + 20);
        v4 = v6;
        if (*v6 == 0) {
            goto lab_0x80d7a20;
        } else {
            goto lab_0x80d77d9;
        }
    }
  lab_0x80d77d9:;
    int32_t * v7 = (int32_t *)(v1 + 24);
    int32_t * v8 = v7; // 0x80d77de
    if (*v7 == 0) {
        goto lab_0x80d7a38;
    } else {
        goto lab_0x80d77e4;
    }
  lab_0x80d7a20:
    // 0x80d7a20
    *v4 = *(int32_t *)(v2 + 20);
    int32_t * v9 = (int32_t *)(v1 + 24);
    v8 = v9;
    if (*v9 != 0) {
        goto lab_0x80d77e4;
    } else {
        goto lab_0x80d7a38;
    }
  lab_0x80d7a38:
    // 0x80d7a38
    *v8 = *(int32_t *)(v2 + 24);
    int32_t * v10 = (int32_t *)(v1 + 28);
    int32_t * v11 = v10; // 0x80d7a43
    if (*v10 != 0) {
        goto lab_0x80d77ef;
    } else {
        goto lab_0x80d7a50;
    }
  lab_0x80d77e4:;
    int32_t * v12 = (int32_t *)(v1 + 28);
    v11 = v12;
    if (*v12 == 0) {
        goto lab_0x80d7a50;
    } else {
        goto lab_0x80d77ef;
    }
  lab_0x80d77ef:;
    int32_t * v13 = (int32_t *)(v1 + 32);
    int32_t * v14 = v13; // 0x80d77f4
    if (*v13 == 0) {
        goto lab_0x80d7a68;
    } else {
        goto lab_0x80d77fa;
    }
  lab_0x80d7a50:
    // 0x80d7a50
    *v11 = *(int32_t *)(v2 + 28);
    int32_t * v15 = (int32_t *)(v1 + 32);
    v14 = v15;
    if (*v15 != 0) {
        goto lab_0x80d77fa;
    } else {
        goto lab_0x80d7a68;
    }
  lab_0x80d7a68:
    // 0x80d7a68
    *v14 = *(int32_t *)(v2 + 32);
    int32_t * v16 = (int32_t *)(v1 + 36);
    int32_t * v17 = v16; // 0x80d7a73
    if (*v16 != 0) {
        goto lab_0x80d7805;
    } else {
        goto lab_0x80d7a80;
    }
  lab_0x80d77fa:;
    int32_t * v18 = (int32_t *)(v1 + 36);
    v17 = v18;
    if (*v18 == 0) {
        goto lab_0x80d7a80;
    } else {
        goto lab_0x80d7805;
    }
  lab_0x80d7805:;
    int32_t * v19 = (int32_t *)(v1 + 40);
    int32_t * v20 = v19; // 0x80d780a
    if (*v19 == 0) {
        goto lab_0x80d7a98;
    } else {
        goto lab_0x80d7810;
    }
  lab_0x80d7a80:
    // 0x80d7a80
    *v17 = *(int32_t *)(v2 + 36);
    int32_t * v21 = (int32_t *)(v1 + 40);
    v20 = v21;
    if (*v21 != 0) {
        goto lab_0x80d7810;
    } else {
        goto lab_0x80d7a98;
    }
  lab_0x80d7a98:
    // 0x80d7a98
    *v20 = *(int32_t *)(v2 + 40);
    int32_t * v22 = (int32_t *)(v1 + 44);
    int32_t * v23 = v22; // 0x80d7aa3
    if (*v22 != 0) {
        goto lab_0x80d781b;
    } else {
        goto lab_0x80d7ab0;
    }
  lab_0x80d7810:;
    int32_t * v24 = (int32_t *)(v1 + 44);
    v23 = v24;
    if (*v24 == 0) {
        goto lab_0x80d7ab0;
    } else {
        goto lab_0x80d781b;
    }
  lab_0x80d781b:;
    int32_t * v25 = (int32_t *)(v1 + 48);
    int32_t * v26 = v25; // 0x80d7820
    if (*v25 == 0) {
        goto lab_0x80d7ac8;
    } else {
        goto lab_0x80d7826;
    }
  lab_0x80d7ab0:
    // 0x80d7ab0
    *v23 = *(int32_t *)(v2 + 44);
    int32_t * v27 = (int32_t *)(v1 + 48);
    v26 = v27;
    if (*v27 != 0) {
        goto lab_0x80d7826;
    } else {
        goto lab_0x80d7ac8;
    }
  lab_0x80d7ac8:
    // 0x80d7ac8
    *v26 = *(int32_t *)(v2 + 48);
    int32_t * v28 = (int32_t *)(v1 + 52);
    int32_t * v29 = v28; // 0x80d7ad3
    if (*v28 != 0) {
        goto lab_0x80d7831;
    } else {
        goto lab_0x80d7ae0;
    }
  lab_0x80d7826:;
    int32_t * v30 = (int32_t *)(v1 + 52);
    v29 = v30;
    if (*v30 == 0) {
        goto lab_0x80d7ae0;
    } else {
        goto lab_0x80d7831;
    }
  lab_0x80d7831:;
    int32_t * v31 = (int32_t *)(v1 + 56);
    int32_t * v32 = v31; // 0x80d7836
    if (*v31 == 0) {
        goto lab_0x80d7af8;
    } else {
        goto lab_0x80d783c;
    }
  lab_0x80d7ae0:
    // 0x80d7ae0
    *v29 = *(int32_t *)(v2 + 52);
    int32_t * v33 = (int32_t *)(v1 + 56);
    v32 = v33;
    if (*v33 != 0) {
        goto lab_0x80d783c;
    } else {
        goto lab_0x80d7af8;
    }
  lab_0x80d7af8:
    // 0x80d7af8
    *v32 = *(int32_t *)(v2 + 56);
    int32_t * v34 = (int32_t *)(v1 + 60);
    int32_t * v35 = v34; // 0x80d7b03
    if (*v34 != 0) {
        goto lab_0x80d7847;
    } else {
        goto lab_0x80d7b10;
    }
  lab_0x80d783c:;
    int32_t * v36 = (int32_t *)(v1 + 60);
    v35 = v36;
    if (*v36 == 0) {
        goto lab_0x80d7b10;
    } else {
        goto lab_0x80d7847;
    }
  lab_0x80d7847:;
    int32_t * v37 = (int32_t *)(v1 + 64);
    int32_t * v38 = v37; // 0x80d784c
    if (*v37 == 0) {
        goto lab_0x80d7b28;
    } else {
        goto lab_0x80d7852;
    }
  lab_0x80d7b10:
    // 0x80d7b10
    *v35 = *(int32_t *)(v2 + 60);
    int32_t * v39 = (int32_t *)(v1 + 64);
    v38 = v39;
    if (*v39 != 0) {
        goto lab_0x80d7852;
    } else {
        goto lab_0x80d7b28;
    }
  lab_0x80d7b28:
    // 0x80d7b28
    *v38 = *(int32_t *)(v2 + 64);
    int32_t * v40 = (int32_t *)(v1 + 68);
    int32_t * v41 = v40; // 0x80d7b33
    if (*v40 != 0) {
        goto lab_0x80d785d;
    } else {
        goto lab_0x80d7b40;
    }
  lab_0x80d7852:;
    int32_t * v42 = (int32_t *)(v1 + 68);
    v41 = v42;
    if (*v42 == 0) {
        goto lab_0x80d7b40;
    } else {
        goto lab_0x80d785d;
    }
  lab_0x80d785d:;
    int32_t * v43 = (int32_t *)(v1 + 76);
    int32_t * v44 = v43; // 0x80d7862
    if (*v43 == 0) {
        goto lab_0x80d7b58;
    } else {
        goto lab_0x80d7868;
    }
  lab_0x80d7b40:
    // 0x80d7b40
    *v41 = *(int32_t *)(v2 + 68);
    int32_t * v45 = (int32_t *)(v1 + 76);
    v44 = v45;
    if (*v45 != 0) {
        goto lab_0x80d7868;
    } else {
        goto lab_0x80d7b58;
    }
  lab_0x80d7b58:
    // 0x80d7b58
    *v44 = *(int32_t *)(v2 + 76);
    int32_t * v46 = (int32_t *)(v1 + 80);
    int32_t * v47 = v46; // 0x80d7b63
    if (*v46 != 0) {
        goto lab_0x80d7873;
    } else {
        goto lab_0x80d7b70;
    }
  lab_0x80d7868:;
    int32_t * v48 = (int32_t *)(v1 + 80);
    v47 = v48;
    if (*v48 == 0) {
        goto lab_0x80d7b70;
    } else {
        goto lab_0x80d7873;
    }
  lab_0x80d7873:;
    int32_t * v49 = (int32_t *)(v1 + 84);
    int32_t * v50 = v49; // 0x80d7878
    if (*v49 == 0) {
        goto lab_0x80d7b88;
    } else {
        goto lab_0x80d787e;
    }
  lab_0x80d7b70:
    // 0x80d7b70
    *v47 = *(int32_t *)(v2 + 80);
    int32_t * v51 = (int32_t *)(v1 + 84);
    v50 = v51;
    if (*v51 != 0) {
        goto lab_0x80d787e;
    } else {
        goto lab_0x80d7b88;
    }
  lab_0x80d7b88:
    // 0x80d7b88
    *v50 = *(int32_t *)(v2 + 84);
    int32_t * v52 = (int32_t *)(v1 + 92);
    int32_t * v53 = v52; // 0x80d7b93
    if (*v52 != 0) {
        goto lab_0x80d7889;
    } else {
        goto lab_0x80d7ba0;
    }
  lab_0x80d787e:;
    int32_t * v54 = (int32_t *)(v1 + 92);
    v53 = v54;
    if (*v54 == 0) {
        goto lab_0x80d7ba0;
    } else {
        goto lab_0x80d7889;
    }
  lab_0x80d7889:;
    int32_t * v55 = (int32_t *)(v1 + 96);
    int32_t * v56 = v55; // 0x80d788e
    if (*v55 == 0) {
        goto lab_0x80d7bb8;
    } else {
        goto lab_0x80d7894;
    }
  lab_0x80d7ba0:
    // 0x80d7ba0
    *v53 = *(int32_t *)(v2 + 92);
    int32_t * v57 = (int32_t *)(v1 + 96);
    v56 = v57;
    if (*v57 != 0) {
        goto lab_0x80d7894;
    } else {
        goto lab_0x80d7bb8;
    }
  lab_0x80d7bb8:
    // 0x80d7bb8
    *v56 = *(int32_t *)(v2 + 96);
    int32_t * v58 = (int32_t *)(v1 + 100);
    int32_t * v59 = v58; // 0x80d7bc3
    if (*v58 != 0) {
        goto lab_0x80d789f;
    } else {
        goto lab_0x80d7bd0;
    }
  lab_0x80d7894:;
    int32_t * v60 = (int32_t *)(v1 + 100);
    v59 = v60;
    if (*v60 == 0) {
        goto lab_0x80d7bd0;
    } else {
        goto lab_0x80d789f;
    }
  lab_0x80d789f:;
    int32_t * v61 = (int32_t *)(v1 + 104);
    int32_t * v62 = v61; // 0x80d78a4
    if (*v61 == 0) {
        goto lab_0x80d7be8;
    } else {
        goto lab_0x80d78aa;
    }
  lab_0x80d7bd0:
    // 0x80d7bd0
    *v59 = *(int32_t *)(v2 + 100);
    int32_t * v63 = (int32_t *)(v1 + 104);
    v62 = v63;
    if (*v63 != 0) {
        goto lab_0x80d78aa;
    } else {
        goto lab_0x80d7be8;
    }
  lab_0x80d7be8:
    // 0x80d7be8
    *v62 = *(int32_t *)(v2 + 104);
    int32_t * v64 = (int32_t *)(v1 + 112);
    int32_t * v65 = v64; // 0x80d7bf3
    if (*v64 != 0) {
        goto lab_0x80d78b5;
    } else {
        goto lab_0x80d7c00;
    }
  lab_0x80d78aa:;
    int32_t * v66 = (int32_t *)(v1 + 112);
    v65 = v66;
    if (*v66 == 0) {
        goto lab_0x80d7c00;
    } else {
        goto lab_0x80d78b5;
    }
  lab_0x80d78b5:;
    int32_t * v67 = (int32_t *)(v1 + 116);
    int32_t * v68 = v67; // 0x80d78ba
    if (*v67 == 0) {
        goto lab_0x80d7c18;
    } else {
        goto lab_0x80d78c0;
    }
  lab_0x80d7c00:
    // 0x80d7c00
    *v65 = *(int32_t *)(v2 + 112);
    int32_t * v69 = (int32_t *)(v1 + 116);
    v68 = v69;
    if (*v69 != 0) {
        goto lab_0x80d78c0;
    } else {
        goto lab_0x80d7c18;
    }
  lab_0x80d7c18:
    // 0x80d7c18
    *v68 = *(int32_t *)(v2 + 116);
    int32_t * v70 = (int32_t *)(v1 + 120);
    int32_t * v71 = v70; // 0x80d7c23
    if (*v70 != 0) {
        goto lab_0x80d78cb;
    } else {
        goto lab_0x80d7c30;
    }
  lab_0x80d78c0:;
    int32_t * v72 = (int32_t *)(v1 + 120);
    v71 = v72;
    if (*v72 == 0) {
        goto lab_0x80d7c30;
    } else {
        goto lab_0x80d78cb;
    }
  lab_0x80d78cb:;
    int32_t * v73 = (int32_t *)(v1 + 124);
    int32_t * v74 = v73; // 0x80d78d0
    if (*v73 == 0) {
        goto lab_0x80d7c48;
    } else {
        goto lab_0x80d78d6;
    }
  lab_0x80d7c30:
    // 0x80d7c30
    *v71 = *(int32_t *)(v2 + 120);
    int32_t * v75 = (int32_t *)(v1 + 124);
    v74 = v75;
    if (*v75 != 0) {
        goto lab_0x80d78d6;
    } else {
        goto lab_0x80d7c48;
    }
  lab_0x80d7c48:
    // 0x80d7c48
    *v74 = *(int32_t *)(v2 + 124);
    int32_t * v76 = (int32_t *)(v1 + 128);
    int32_t * v77 = v76; // 0x80d7c56
    if (*v76 != 0) {
        goto lab_0x80d78e4;
    } else {
        goto lab_0x80d7c60;
    }
  lab_0x80d78d6:;
    int32_t * v78 = (int32_t *)(v1 + 128);
    v77 = v78;
    if (*v78 == 0) {
        goto lab_0x80d7c60;
    } else {
        goto lab_0x80d78e4;
    }
  lab_0x80d78e4:;
    int32_t * v79 = (int32_t *)(v1 + 132);
    int32_t * v80 = v79; // 0x80d78ec
    if (*v79 == 0) {
        goto lab_0x80d7c80;
    } else {
        goto lab_0x80d78f2;
    }
  lab_0x80d7c60:
    // 0x80d7c60
    *v77 = *(int32_t *)(v2 + 128);
    int32_t * v81 = (int32_t *)(v1 + 132);
    v80 = v81;
    if (*v81 != 0) {
        goto lab_0x80d78f2;
    } else {
        goto lab_0x80d7c80;
    }
  lab_0x80d7c80:
    // 0x80d7c80
    *v80 = *(int32_t *)(v2 + 132);
    int32_t * v82 = (int32_t *)(v1 + 136);
    int32_t * v83 = v82; // 0x80d7c94
    if (*v82 != 0) {
        goto lab_0x80d7900;
    } else {
        goto lab_0x80d7ca0;
    }
  lab_0x80d78f2:;
    int32_t * v84 = (int32_t *)(v1 + 136);
    v83 = v84;
    if (*v84 == 0) {
        goto lab_0x80d7ca0;
    } else {
        goto lab_0x80d7900;
    }
  lab_0x80d7900:;
    int32_t * v85 = (int32_t *)(v1 + 140);
    int32_t * v86 = v85; // 0x80d7908
    if (*v85 == 0) {
        goto lab_0x80d7cc0;
    } else {
        goto lab_0x80d790e;
    }
  lab_0x80d7ca0:
    // 0x80d7ca0
    *v83 = *(int32_t *)(v2 + 136);
    int32_t * v87 = (int32_t *)(v1 + 140);
    v86 = v87;
    if (*v87 != 0) {
        goto lab_0x80d790e;
    } else {
        goto lab_0x80d7cc0;
    }
  lab_0x80d7cc0:
    // 0x80d7cc0
    *v86 = *(int32_t *)(v2 + 140);
    int32_t * v88 = (int32_t *)(v1 + 144);
    int32_t * v89 = v88; // 0x80d7cd4
    if (*v88 != 0) {
        goto lab_0x80d791c;
    } else {
        goto lab_0x80d7ce0;
    }
  lab_0x80d790e:;
    int32_t * v90 = (int32_t *)(v1 + 144);
    v89 = v90;
    if (*v90 == 0) {
        goto lab_0x80d7ce0;
    } else {
        goto lab_0x80d791c;
    }
  lab_0x80d791c:;
    int32_t * v91 = (int32_t *)(v1 + 148);
    int32_t * v92 = v91; // 0x80d7924
    if (*v91 == 0) {
        goto lab_0x80d7d00;
    } else {
        goto lab_0x80d792a;
    }
  lab_0x80d7ce0:
    // 0x80d7ce0
    *v89 = *(int32_t *)(v2 + 144);
    int32_t * v93 = (int32_t *)(v1 + 148);
    v92 = v93;
    if (*v93 != 0) {
        goto lab_0x80d792a;
    } else {
        goto lab_0x80d7d00;
    }
  lab_0x80d7d00:
    // 0x80d7d00
    *v92 = *(int32_t *)(v2 + 148);
    int32_t * v94 = (int32_t *)(v1 + 152);
    int32_t * v95 = v94; // 0x80d7d14
    if (*v94 != 0) {
        goto lab_0x80d7938;
    } else {
        goto lab_0x80d7d20;
    }
  lab_0x80d792a:;
    int32_t * v96 = (int32_t *)(v1 + 152);
    v95 = v96;
    if (*v96 == 0) {
        goto lab_0x80d7d20;
    } else {
        goto lab_0x80d7938;
    }
  lab_0x80d7938:;
    int32_t * v97 = (int32_t *)(v1 + 156);
    int32_t * v98 = v97; // 0x80d7940
    if (*v97 == 0) {
        goto lab_0x80d7d40;
    } else {
        goto lab_0x80d7946;
    }
  lab_0x80d7d20:
    // 0x80d7d20
    *v95 = *(int32_t *)(v2 + 152);
    int32_t * v99 = (int32_t *)(v1 + 156);
    v98 = v99;
    if (*v99 != 0) {
        goto lab_0x80d7946;
    } else {
        goto lab_0x80d7d40;
    }
  lab_0x80d7d40:
    // 0x80d7d40
    *v98 = *(int32_t *)(v2 + 156);
    int32_t * v100 = (int32_t *)(v1 + 160);
    int32_t * v101 = v100; // 0x80d7d54
    if (*v100 != 0) {
        goto lab_0x80d7954;
    } else {
        goto lab_0x80d7d60;
    }
  lab_0x80d7946:;
    int32_t * v102 = (int32_t *)(v1 + 160);
    v101 = v102;
    if (*v102 == 0) {
        goto lab_0x80d7d60;
    } else {
        goto lab_0x80d7954;
    }
  lab_0x80d7954:;
    int32_t * v103 = (int32_t *)(v1 + 164);
    int32_t * v104 = v103; // 0x80d795c
    if (*v103 == 0) {
        goto lab_0x80d7d80;
    } else {
        goto lab_0x80d7962;
    }
  lab_0x80d7d60:
    // 0x80d7d60
    *v101 = *(int32_t *)(v2 + 160);
    int32_t * v105 = (int32_t *)(v1 + 164);
    v104 = v105;
    if (*v105 != 0) {
        goto lab_0x80d7962;
    } else {
        goto lab_0x80d7d80;
    }
  lab_0x80d7d80:
    // 0x80d7d80
    *v104 = *(int32_t *)(v2 + 164);
    int32_t * v106 = (int32_t *)(v1 + 168);
    int32_t * v107 = v106; // 0x80d7d94
    if (*v106 != 0) {
        goto lab_0x80d7970;
    } else {
        goto lab_0x80d7da0;
    }
  lab_0x80d7962:;
    int32_t * v108 = (int32_t *)(v1 + 168);
    v107 = v108;
    if (*v108 == 0) {
        goto lab_0x80d7da0;
    } else {
        goto lab_0x80d7970;
    }
  lab_0x80d7970:;
    int32_t * v109 = (int32_t *)(v1 + 172);
    int32_t * v110 = v109; // 0x80d7978
    if (*v109 == 0) {
        goto lab_0x80d7dc0;
    } else {
        goto lab_0x80d797e;
    }
  lab_0x80d7da0:
    // 0x80d7da0
    *v107 = *(int32_t *)(v2 + 168);
    int32_t * v111 = (int32_t *)(v1 + 172);
    v110 = v111;
    if (*v111 != 0) {
        goto lab_0x80d797e;
    } else {
        goto lab_0x80d7dc0;
    }
  lab_0x80d7dc0:
    // 0x80d7dc0
    *v110 = *(int32_t *)(v2 + 172);
    int32_t * v112 = (int32_t *)(v1 + 176);
    int32_t * v113 = v112; // 0x80d7dd4
    if (*v112 != 0) {
        goto lab_0x80d798c;
    } else {
        goto lab_0x80d7de0;
    }
  lab_0x80d797e:;
    int32_t * v114 = (int32_t *)(v1 + 176);
    v113 = v114;
    if (*v114 == 0) {
        goto lab_0x80d7de0;
    } else {
        goto lab_0x80d798c;
    }
  lab_0x80d798c:;
    int32_t * v115 = (int32_t *)(v1 + 180);
    int32_t * v116 = v115; // 0x80d7994
    if (*v115 == 0) {
        goto lab_0x80d7e00;
    } else {
        goto lab_0x80d799a;
    }
  lab_0x80d7de0:
    // 0x80d7de0
    *v113 = *(int32_t *)(v2 + 176);
    int32_t * v117 = (int32_t *)(v1 + 180);
    v116 = v117;
    if (*v117 != 0) {
        goto lab_0x80d799a;
    } else {
        goto lab_0x80d7e00;
    }
  lab_0x80d7e00:
    // 0x80d7e00
    *v116 = *(int32_t *)(v2 + 180);
    int32_t * v118 = (int32_t *)(v1 + 184);
    int32_t * v119 = v118; // 0x80d7e14
    if (*v118 != 0) {
        goto lab_0x80d79a8;
    } else {
        goto lab_0x80d7e20;
    }
  lab_0x80d799a:;
    int32_t * v120 = (int32_t *)(v1 + 184);
    v119 = v120;
    if (*v120 == 0) {
        goto lab_0x80d7e20;
    } else {
        goto lab_0x80d79a8;
    }
  lab_0x80d79a8:;
    int32_t * v121 = (int32_t *)(v1 + 188);
    int32_t * v122 = v121; // 0x80d79b0
    if (*v121 == 0) {
        goto lab_0x80d7e40;
    } else {
        goto lab_0x80d79b6;
    }
  lab_0x80d7e20:
    // 0x80d7e20
    *v119 = *(int32_t *)(v2 + 184);
    int32_t * v123 = (int32_t *)(v1 + 188);
    v122 = v123;
    if (*v123 != 0) {
        goto lab_0x80d79b6;
    } else {
        goto lab_0x80d7e40;
    }
  lab_0x80d7e40:
    // 0x80d7e40
    *v122 = *(int32_t *)(v2 + 188);
    int32_t * v124 = (int32_t *)(v1 + 192);
    int32_t * v125 = v124; // 0x80d7e54
    if (*v124 != 0) {
        goto lab_0x80d79c4;
    } else {
        goto lab_0x80d7e60;
    }
  lab_0x80d79b6:;
    int32_t * v126 = (int32_t *)(v1 + 192);
    v125 = v126;
    if (*v126 == 0) {
        goto lab_0x80d7e60;
    } else {
        goto lab_0x80d79c4;
    }
  lab_0x80d79c4:;
    int32_t * v127 = (int32_t *)(v1 + 196);
    int32_t * v128 = v127; // 0x80d79cc
    if (*v127 == 0) {
        goto lab_0x80d7e80;
    } else {
        goto lab_0x80d79d2;
    }
  lab_0x80d7e60:
    // 0x80d7e60
    *v125 = *(int32_t *)(v2 + 192);
    int32_t * v129 = (int32_t *)(v1 + 196);
    v128 = v129;
    if (*v129 != 0) {
        goto lab_0x80d79d2;
    } else {
        goto lab_0x80d7e80;
    }
  lab_0x80d7e80:
    // 0x80d7e80
    *v128 = *(int32_t *)(v2 + 196);
    goto lab_0x80d79d2;
  lab_0x80d79d2:;
    int32_t * v130 = (int32_t *)(v1 + 200); // 0x80d79d2
    if (*v130 == 0) {
        // 0x80d79f8
        *v130 = *(int32_t *)(v2 + 200);
    }
    int32_t * v131 = (int32_t *)(v1 + 204); // 0x80d79dc
    if (*v131 != 0) {
        // 0x80d79e6
        return;
    }
    // 0x80d79e8
    *v131 = *(int32_t *)(v2 + 204);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/toporouter.c
// Address range: 0x80da2c0 - 0x80da2dc
// Line range:    7497 - 7497
void register_toporouter_action_list(void) {
    // 0x80da2c0
    hid_register_actions(&toporouter_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus-pcbmain.c
// Address range: 0x80ebfe0 - 0x80ec09e
// Line range:    312 - 338
void pcb_dbus_connection_finish_with_mainloop(int32_t * connection) {
    int32_t v1 = (int32_t)connection;
    if (function_805fc48(v1, 0, 0, 0, 0, 0) == 0) {
        // 0x80ec052
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Not enough memory when cleaning up DBusConnection mainloop integration\n");
        return;
    }
    // 0x80ec01e
    if (function_8060118(v1, 0, 0, 0, 0, 0) != 0) {
        // 0x80ec078
        function_805f448(v1, 0, 0, 0);
        return;
    }
    // 0x80ec052
    __fprintf_chk((struct _IO_FILE *)g43, 1, "Not enough memory when cleaning up DBusConnection mainloop integration\n");
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus-pcbmain.c
// Address range: 0x80ec0a0 - 0x80ec17f
// Line range:    264 - 309
void pcb_dbus_connection_setup_with_mainloop(int32_t * connection) {
    int32_t v1 = (int32_t)connection;
    if (function_805fc48(v1, 0x80ec350, 0x80ec320, 0x80ec410, 0, 0) == 0) {
        // 0x80ec112
        __fprintf_chk((struct _IO_FILE *)g43, 1, "Not enough memory to set up DBusConnection for use with PCB\n");
        return;
    }
    // 0x80ec0de
    if (function_8060118(v1, 0x80ec1e0, 0x80ec1b0, 0x80ec270, 0, 0) != 0) {
        // 0x80ec138
        function_805f448(v1, 0x80ebfd0, 0, 0);
        return;
    }
    // 0x80ec112
    __fprintf_chk((struct _IO_FILE *)g43, 1, "Not enough memory to set up DBusConnection for use with PCB\n");
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus.c
// Address range: 0x80ec500 - 0x80ec587
// Line range:    378 - 406
void pcb_dbus_finish(void) {
    // 0x80ec500
    int32_t v1; // bp-28, 0x80ec500
    function_805edd8(&v1);
    function_805f098((int32_t)pcb_dbus_conn);
    function_8060908((int32_t)pcb_dbus_conn, "/org/seul/geda/pcb");
    function_805ef38((int32_t)pcb_dbus_conn, "org.seul.geda.pcb", &v1);
    function_8060718(&v1);
    pcb_dbus_connection_finish_with_mainloop(pcb_dbus_conn);
    function_80600e8((int32_t)pcb_dbus_conn);
    function_805e978((int32_t)pcb_dbus_conn);
    function_805ecf8();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus.c
// Address range: 0x80ec590 - 0x80ec734
// Line range:    322 - 374
void pcb_dbus_setup(void) {
    int32_t v1 = 0x80ec4f0; // bp-52, 0x80ec59b
    int32_t v2; // bp-28, 0x80ec590
    function_805edd8(&v2);
    int32_t v3 = function_805efc8(0, &v2); // 0x80ec5d8
    *(int32_t *)&pcb_dbus_conn = v3;
    char * v4; // 0x80ec590
    if (function_805eff8(&v2) != 0) {
        // 0x80ec698
        __fprintf_chk((struct _IO_FILE *)g43, 1, "pcb_dbus: DBus connection Error (%s)\n", v4);
        function_8060718(&v2);
    }
    // 0x80ec5f2
    if (pcb_dbus_conn == NULL) {
        // 0x80ec64e
        return;
    }
    int32_t v5 = function_805f2b8((int32_t)pcb_dbus_conn, "org.seul.geda.pcb", 2, &v2); // 0x80ec612
    if (function_805eff8(&v2) != 0) {
        // 0x80ec6d0
        __fprintf_chk((struct _IO_FILE *)g43, 1, "pcb_dbus: DBus name error (%s)\n", v4);
        function_8060718(&v2);
    }
    if (v5 >= 3) {
        // 0x80ec631
        __fprintf_chk((struct _IO_FILE *)g43, 1, "pcb_dbus: Couldn't gain ownership or queued ownership of the canonical DBus name\n");
        // 0x80ec64e
        return;
    }
    // 0x80ec658
    if (function_805fcf8((int32_t)pcb_dbus_conn, "/org/seul/geda/pcb", &v1, 0) == 0) {
        // 0x80ec708
        __fprintf_chk((struct _IO_FILE *)g43, 1, "pcb_dbus: Couldn't register DBUS handler for %s\n", "/org/seul/geda/pcb");
        return;
    }
    // 0x80ec684
    pcb_dbus_connection_setup_with_mainloop(pcb_dbus_conn);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gtkhid-main.c
// Address range: 0x80ee4f0 - 0x80ee50c
// Line range:    2718 - 2718
void register_ghid_main_flag_list(void) {
    // 0x80ee4f0
    hid_register_flags(&ghid_main_flag_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gtkhid-main.c
// Address range: 0x80ee510 - 0x80ee52c
// Line range:    2699 - 2699
void register_ghid_main_action_list(void) {
    // 0x80ee510
    hid_register_actions(&ghid_main_action_list, 24);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gtkhid-main.c
// Address range: 0x80ee530 - 0x80ee57b
// Line range:    2733 - 7
void hid_gtk_init(void) {
    // 0x80ee530
    hid_register_hid(&ghid_hid);
    apply_default_hid(&ghid_extents, &ghid_hid);
    register_ghid_main_action_list();
    register_ghid_main_flag_list();
    register_ghid_netlist_action_list();
    register_ghid_attribute_list();
    register_gtk_topwindow_action_list();
    register_pcbmenu_attr();
    register_ghid_menu_action_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-netlist-window.c
// Address range: 0x80fec50 - 0x80fec6c
// Line range:    1003 - 1003
void register_ghid_netlist_action_list(void) {
    // 0x80fec50
    hid_register_actions(&ghid_netlist_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f00 - 0x8103f1c
// Line range:    3889 - 3889
void register_ghid_menu_action_list(void) {
    // 0x8103f00
    hid_register_actions(&ghid_menu_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f20 - 0x8103f3c
// Line range:    2901 - 2901
void register_gtk_topwindow_action_list(void) {
    // 0x8103f20
    hid_register_actions(&gtk_topwindow_action_list, 3);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f40 - 0x8103f5c
// Line range:    2910 - 2910
void register_pcbmenu_attr(void) {
    // 0x8103f40
    hid_register_attributes(&pcbmenu_attr, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f60 - 0x8103f7c
// Line range:    2605 - 2605
void register_ghid_attribute_list(void) {
    // 0x8103f60
    hid_register_attributes(&ghid_attribute_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/lpr/lpr.c
// Address range: 0x810dd30 - 0x810dd6c
// Line range:    172 - 177
void hid_lpr_init(void) {
    // 0x810dd30
    apply_default_hid(&lpr_hid, &ps_hid);
    apply_default_hid(&lpr_hid, NULL);
    hid_register_hid(&lpr_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/bom/bom.c
// Address range: 0x810ee60 - 0x810ee88
// Line range:    595 - 599
void hid_bom_init(void) {
    // 0x810ee60
    apply_default_hid(&bom_hid, NULL);
    hid_register_hid(&bom_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gerber/gerber.c
// Address range: 0x810ef10 - 0x810ef38
// Line range:    1130 - 1134
void hid_gerber_init(void) {
    // 0x810ef10
    apply_default_hid(&gerber_hid, NULL);
    hid_register_hid(&gerber_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/nelma/nelma.c
// Address range: 0x8111e90 - 0x8111eac
// Line range:    176 - 176
void register_nelma_attribute_list(void) {
    // 0x8111e90
    hid_register_attributes(&nelma_attribute_list, 5);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/nelma/nelma.c
// Address range: 0x8111fc0 - 0x8111fec
// Line range:    1109 - 1
void hid_nelma_init(void) {
    // 0x8111fc0
    apply_default_hid(&nelma_hid, NULL);
    hid_register_hid(&nelma_hid);
    register_nelma_attribute_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/png/png.c
// Address range: 0x8114220 - 0x811423c
// Line range:    213 - 213
void register_png_attribute_list(void) {
    // 0x8114220
    hid_register_attributes(&png_attribute_list, 17);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/png/png.c
// Address range: 0x81144e0 - 0x811450c
// Line range:    1496 - 1
void hid_png_init(void) {
    // 0x81144e0
    apply_default_hid(&png_hid, NULL);
    hid_register_hid(&png_hid);
    register_png_attribute_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/ps.c
// Address range: 0x81172c0 - 0x81172dc
// Line range:    214 - 214
void register_ps_attribute_list(void) {
    // 0x81172c0
    hid_register_attributes(&ps_attribute_list, 18);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/ps.c
// Address range: 0x8117370 - 0x81173a6
// Line range:    1210 - 2
void hid_ps_init(void) {
    // 0x8117370
    apply_default_hid(&ps_hid, NULL);
    hid_register_hid(&ps_hid);
    hid_eps_init();
    register_ps_attribute_list();
    register_eps_attribute_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/eps.c
// Address range: 0x8117f90 - 0x8117fb8
// Line range:    669 - 673
void hid_eps_init(void) {
    // 0x8117f90
    apply_default_hid(&eps_hid, NULL);
    hid_register_hid(&eps_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/eps.c
// Address range: 0x81189c0 - 0x81189dc
// Line range:    69 - 69
void register_eps_attribute_list(void) {
    // 0x81189c0
    hid_register_attributes(&eps_attribute_list, 5);
}

// Address range: 0x8139cfa - 0x8139cfe
int32_t __i686_get_pc_thunk_bx(int32_t a1) {
    // 0x8139cfa
    int32_t result; // 0x8139cfa
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t atexit(int32_t a1);

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int * __errno_location(void);
// int __fprintf_chk(FILE * restrict stream, int flag, const char * restrict format, ...);
// int __printf_chk(int flag, const char * restrict format, ...);
// char * __realpath_chk(const char * restrict name, char * restrict resolved, size_t resolvedlen);
// int __sprintf_chk(char * restrict s, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// char * __strcat_chk(char * restrict s, const char * restrict append, size_t slen);
// char * __strdup(const char * string);
// int __vfprintf_chk(FILE * restrict stream, int flag, const char * restrict format, _G_va_list ap);
// int __xstat(int ver, const char * filename, struct stat * stat_buf);
// int _IO_getc(_IO_FILE * fp);
// int _IO_putc(int c, _IO_FILE * fp);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void abort(void);
// char * asctime(const struct tm * tp);
// double atan2(double, double);
// char * bind_textdomaincodeset(const char * domainname, const char * __codeset);
// char * bindtextdomain(const char * domainname, const char * dirname);
// void * calloc(size_t nmemb, size_t size);
// int chdir(const char * path);
// int closedir(DIR * dirp);
// int32_t dbus_bus_get_private(void);
// int32_t dbus_bus_release_name(void);
// int32_t dbus_bus_request_name(void);
// int32_t dbus_connection_close(void);
// int32_t dbus_connection_flush(void);
// int32_t dbus_connection_register_object_path(void);
// int32_t dbus_connection_set_dispatch_status_function(void);
// int32_t dbus_connection_set_timeout_functions(void);
// int32_t dbus_connection_set_watch_functions(void);
// int32_t dbus_connection_unref(void);
// int32_t dbus_connection_unregister_object_path(void);
// int32_t dbus_error_free(void);
// int32_t dbus_error_init(void);
// int32_t dbus_error_is_set(void);
// int32_t dbus_shutdown(void);
// char * dlerror(void);
// void * dlopen(const char * file, int mode);
// void * dlsym(void * restrict handle, const char * restrict name);
// void exit(int status);
// int fclose(FILE * stream);
// int ferror(FILE * stream);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// int fileno(FILE * stream);
// double floor(double);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int fputc(int c, FILE * stream);
// int fputs(const char * restrict s, FILE * restrict stream);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// char * getcwd(char * buf, size_t size);
// char * getenv(const char * name);
// struct hostent * gethostbyname(const char * name);
// int gethostname(char * name, size_t len);
// __pid_t getpid(void);
// struct passwd * getpwuid(__uid_t uid);
// __uid_t getuid(void);
// int isatty(int fd);
// struct tm * localtime(const time_t * timer);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// DIR * opendir(const char * name);
// int pclose(FILE * stream);
// FILE * popen(const char * command, const char * modes);
// void qsort(void * base, size_t nmemb, size_t size, __compar_fn_t compar);
// struct dirent * readdir(DIR * dirp);
// void * realloc(void * ptr, size_t size);
// int regcomp(regex_t * restrict preg, const char * restrict pattern, int cflags);
// size_t regerror(int errcode, const regex_t * restrict preg, char * restrict errbuf, size_t errbuf_size);
// int regexec(const regex_t * restrict preg, const char * restrict string, size_t nmatch, regmatch_t pmatch[__restrict_arr], int eflags);
// void regfree(regex_t * preg);
// void setbuf(FILE * restrict stream, char * restrict buf);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int32_t sincos(void);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// int32_t sscanf2(void);
// int strcasecmp(const char * s1, const char * s2);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// double strtod(const char * restrict nptr, char ** restrict endptr);
// char * strtok(char * restrict s, const char * restrict delim);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// time_t time(time_t * timer);
// int unlink(const char * name);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.5)
// Detected functions: 321

