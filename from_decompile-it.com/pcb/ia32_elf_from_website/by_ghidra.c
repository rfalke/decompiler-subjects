typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned int    dword;
typedef long double    longdouble;
typedef long long    longlong;
typedef unsigned long long    qword;
typedef long long    sqword;
typedef short    sword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined5;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char * _IO_read_ptr;
    char * _IO_read_end;
    char * _IO_read_base;
    char * _IO_write_base;
    char * _IO_write_ptr;
    char * _IO_write_end;
    char * _IO_buf_base;
    char * _IO_buf_end;
    char * _IO_save_base;
    char * _IO_backup_base;
    char * _IO_save_end;
    struct _IO_marker * _markers;
    struct _IO_FILE * _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t * _lock;
    __off64_t _offset;
    void * __pad1;
    void * __pad2;
    void * __pad3;
    void * __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[40];
};

struct _IO_marker {
    struct _IO_marker * _next;
    struct _IO_FILE * _sbuf;
    int _pos;
};

typedef struct stat stat, *Pstat;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    __ino_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    ulong __unused4;
    ulong __unused5;
};

typedef int BOOLp;

typedef sword yytype_int16;

typedef uchar yytype_uint8;

typedef uint gsize;


// WARNING! conflicting data type names: /DWARF/__blkcnt_t - /types.h/__blkcnt_t

typedef uint Cardinal;

typedef uint gulong;

typedef char yytype_int8;

typedef char gchar;

typedef uchar BYTE;

typedef int gint;


// WARNING! conflicting data type names: /DWARF/__off_t - /types.h/__off_t

typedef char Boolean;

typedef dword guint32;

typedef uchar guchar;

typedef int yy_state_type;

typedef double gdouble;

typedef short gshort;

typedef uint guint;

typedef uchar YY_CHAR;

typedef int BDimension;

typedef sqword gint64;

typedef word yytype_uint16;

typedef word guint16;

typedef short Dimension;

typedef uchar guint8;

typedef ushort gushort;

typedef double cost_t;


// WARNING! conflicting data type names: /DWARF/size_t - /stddef.h/size_t


// WARNING! conflicting data type names: /DWARF/__time_t - /types.h/__time_t

typedef dword dbus_uint32_t;

typedef int __suseconds_t;

typedef int regoff_t;

typedef int glong;


// WARNING! conflicting data type names: /DWARF/__blksize_t - /types.h/__blksize_t

typedef uint yy_size_t;

typedef float gfloat;

typedef char gint8;

typedef uint reg_syntax_t;

typedef int LocationType;

typedef sword gint16;


// WARNING! conflicting data type names: /DWARF/__ino_t - /types.h/__ino_t

typedef qword guint64;

typedef struct _GNode _GNode, *P_GNode;

typedef void * gpointer;

typedef struct _GNode GNode;

struct _GNode {
    gpointer data;
    GNode * next;
    GNode * prev;
    GNode * parent;
    GNode * children;
};

typedef struct rect_s rect_s, *Prect_s;

struct rect_s {
    int x1;
    int y1;
    int x2;
    int y2;
};

typedef struct corner_s corner_s, *Pcorner_s;

typedef struct PinType PinType, *PPinType;

typedef struct PadType PadType, *PPadType;

typedef struct line_s line_s, *Pline_s;

typedef struct BoxType BoxType, *PBoxType;

typedef struct FlagType FlagType, *PFlagType;

typedef struct LibraryEntryType LibraryEntryType, *PLibraryEntryType;

typedef struct PointType PointType, *PPointType;

typedef struct LineType LineType, *PLineType;

struct corner_s {
    int layer;
    struct corner_s * next;
    int x;
    int y;
    int net;
    struct PinType * via;
    struct PadType * pad;
    struct PinType * pin;
    int miter;
    int n_lines;
    struct line_s * * lines;
};

struct LibraryEntryType {
};

struct PointType {
    LocationType X;
    LocationType Y;
    LocationType X2;
    LocationType Y2;
    long ID;
};

struct BoxType {
    LocationType X1;
    LocationType Y1;
    LocationType X2;
    LocationType Y2;
};

struct FlagType {
    ulong f;
    uchar t[8];
};

struct PinType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    BDimension Mask;
    BDimension DrillingHole;
    LocationType X;
    LocationType Y;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

struct PadType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    BDimension Mask;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

struct LineType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    char * Number;
};

struct line_s {
    int layer;
    struct line_s * next;
    struct corner_s * s;
    struct corner_s * e;
    struct LineType * line;
};

typedef enum GdkVisualType {
    GDK_VISUAL_STATIC_GRAY=0,
    GDK_VISUAL_GRAYSCALE=1,
    GDK_VISUAL_STATIC_COLOR=2,
    GDK_VISUAL_PSEUDO_COLOR=3,
    GDK_VISUAL_TRUE_COLOR=4,
    GDK_VISUAL_DIRECT_COLOR=5
} GdkVisualType;

typedef struct _GtkArg _GtkArg, *P_GtkArg;

typedef struct _GtkArg GtkArg;

typedef gsize GType;

typedef union anon_union_8_13_04b58f70_for_d anon_union_8_13_04b58f70_for_d, *Panon_union_8_13_04b58f70_for_d;

typedef gint gboolean;

typedef struct _GtkObject _GtkObject, *P_GtkObject;

typedef struct _GtkObject GtkObject;

typedef struct anon_struct_8_2_94730fa3_for_signal_data anon_struct_8_2_94730fa3_for_signal_data, *Panon_struct_8_2_94730fa3_for_signal_data;

typedef struct _GObject _GObject, *P_GObject;

typedef struct _GObject GInitiallyUnowned;

typedef void (* GCallback)(void);

typedef struct _GTypeInstance _GTypeInstance, *P_GTypeInstance;

typedef struct _GTypeInstance GTypeInstance;

typedef struct _GData _GData, *P_GData;

typedef struct _GData GData;

typedef struct _GTypeClass _GTypeClass, *P_GTypeClass;

typedef struct _GTypeClass GTypeClass;

struct _GTypeClass {
    GType g_type;
};

struct _GData {
};

struct _GTypeInstance {
    GTypeClass * g_class;
};

struct _GObject {
    GTypeInstance g_type_instance;
    guint ref_count;
    GData * qdata;
};

struct _GtkObject {
    GInitiallyUnowned parent_instance;
    guint32 flags;
};

struct anon_struct_8_2_94730fa3_for_signal_data {
    GCallback f;
    gpointer d;
};

union anon_union_8_13_04b58f70_for_d {
    gchar char_data;
    guchar uchar_data;
    gboolean bool_data;
    gint int_data;
    guint uint_data;
    glong long_data;
    gulong ulong_data;
    gfloat float_data;
    gdouble double_data;
    gchar * string_data;
    GtkObject * object_data;
    gpointer pointer_data;
    struct anon_struct_8_2_94730fa3_for_signal_data signal_data;
};

struct _GtkArg {
    GType type;
    gchar * name;
    union anon_union_8_13_04b58f70_for_d d;
};

typedef struct _GObjectConstructParam _GObjectConstructParam, *P_GObjectConstructParam;

typedef struct _GParamSpec _GParamSpec, *P_GParamSpec;

typedef struct _GParamSpec GParamSpec;

typedef struct _GValue _GValue, *P_GValue;

typedef struct _GValue GValue;

typedef enum GParamFlags {
    G_PARAM_DEPRECATED=-2147483648,
    G_PARAM_READABLE=1,
    G_PARAM_WRITABLE=2,
    G_PARAM_CONSTRUCT=4,
    G_PARAM_CONSTRUCT_ONLY=8,
    G_PARAM_LAX_VALIDATION=16,
    G_PARAM_PRIVATE=32,
    G_PARAM_STATIC_NAME=32,
    G_PARAM_STATIC_NICK=64,
    G_PARAM_STATIC_BLURB=128
} GParamFlags;

typedef union anon_union_8_9_cc3fcca0 anon_union_8_9_cc3fcca0, *Panon_union_8_9_cc3fcca0;

struct _GObjectConstructParam {
    GParamSpec * pspec;
    GValue * value;
};

struct _GParamSpec {
    GTypeInstance g_type_instance;
    gchar * name;
    enum GParamFlags flags;
    GType value_type;
    GType owner_type;
    gchar * _nick;
    gchar * _blurb;
    GData * qdata;
    guint ref_count;
    guint param_id;
};

union anon_union_8_9_cc3fcca0 {
    gint v_int;
    guint v_uint;
    glong v_long;
    gulong v_ulong;
    gint64 v_int64;
    guint64 v_uint64;
    gfloat v_float;
    gdouble v_double;
    gpointer v_pointer;
};

struct _GValue {
    GType g_type;
    union anon_union_8_9_cc3fcca0 data[2];
};

typedef struct _GObjectConstructParam GObjectConstructParam;

typedef struct _GObjectClass _GObjectClass, *P_GObjectClass;

typedef struct _GObject GObject;

typedef struct _GObjectClass GInitiallyUnownedClass;

typedef struct _GSList _GSList, *P_GSList;

typedef struct _GSList GSList;

struct _GSList {
    gpointer data;
    GSList * next;
};

struct _GObjectClass {
    GTypeClass g_type_class;
    GSList * construct_properties;
    GObject * (* constructor)(GType, guint, GObjectConstructParam *);
    void (* set_property)(GObject *, guint, GValue *, GParamSpec *);
    void (* get_property)(GObject *, guint, GValue *, GParamSpec *);
    void (* dispose)(GObject *);
    void (* finalize)(GObject *);
    void (* dispatch_properties_changed)(GObject *, guint, GParamSpec * *);
    void (* notify)(GObject *, GParamSpec *);
    void (* constructed)(GObject *);
    gsize flags;
    gpointer pdummy[6];
};

typedef struct _GObjectClass GObjectClass;

typedef struct HID_AttrNode HID_AttrNode, *PHID_AttrNode;

typedef struct HID_Attribute HID_Attribute, *PHID_Attribute;

typedef enum anon_enum_32 {
    G_PARAM_DEPRECATED=-2147483648,
    GTK_RESPONSE_HELP=-11,
    GTK_RESPONSE_APPLY=-10,
    GTK_RESPONSE_NO=-9,
    GTK_RESPONSE_YES=-8,
    GTK_RESPONSE_CLOSE=-7,
    FL_SILK=-6,
    GTK_RESPONSE_CANCEL=-6,
    FL_PINS=-5,
    GTK_RESPONSE_OK=-5,
    FL_RATS=-4,
    GTK_RESPONSE_DELETE_EVENT=-4,
    G_LOG_LEVEL_MASK=-4,
    FL_VIAS=-3,
    GTK_RESPONSE_ACCEPT=-3,
    FL_BACK=-2,
    GTK_RESPONSE_REJECT=-2,
    FL_MASK=-1,
    GTK_RESPONSE_NONE=-1,
    CONFIG_NAME_COLUMN=0,
    DBUS_BUS_SESSION=0,
    DRC_VIOLATION_NUM_COL=0,
    FALSE=0,
    FIXED=0,
    GDK_CAP_NOT_LAST=0,
    GDK_COPY=0,
    GDK_JOIN_MITER=0,
    GDK_LINE_SOLID=0,
    GDK_RGB_DITHER_NONE=0,
    GTK_ARROW_UP=0,
    GTK_BUTTONS_NONE=0,
    GTK_FILE_CHOOSER_ACTION_OPEN=0,
    GTK_ICON_SIZE_INVALID=0,
    GTK_MESSAGE_INFO=0,
    GTK_POLICY_ALWAYS=0,
    GTK_RELIEF_NORMAL=0,
    GTK_SHADOW_NONE=0,
    GTK_STATE_NORMAL=0,
    GTK_WINDOW_TOPLEVEL=0,
    GTK_WIN_POS_NONE=0,
    G_TOKEN_EOF=0,
    HID_Label=0,
    MENU_NAME_COLUMN=0,
    NET_ENABLED_COLUMN=0,
    NODE_NAME_COLUMN=0,
    PAD=0,
    PANGO_STYLE_NORMAL=0,
    PANGO_UNDERLINE_NONE=0,
    SHIFT=0,
    __LC_CTYPE=0,
    err_ok=0,
    CONFIG_PAGE_COLUMN=1,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_READABLE=1,
    DRC_VIOLATION_OBJ_COL=1,
    GDK_CAP_BUTT=1,
    GDK_INVERT=1,
    GDK_JOIN_ROUND=1,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_RGB_DITHER_NORMAL=1,
    GTK_ARROW_DOWN=1,
    GTK_BUTTONS_OK=1,
    GTK_DIALOG_MODAL=1,
    GTK_FILE_CHOOSER_ACTION_SAVE=1,
    GTK_ICON_SIZE_MENU=1,
    GTK_MESSAGE_WARNING=1,
    GTK_POLICY_AUTOMATIC=1,
    GTK_RELIEF_HALF=1,
    GTK_SHADOW_IN=1,
    GTK_STATE_ACTIVE=1,
    GTK_WINDOW_POPUP=1,
    GTK_WIN_POS_CENTER=1,
    GTS_DESTROYED=1,
    GTS_USER_FLAG=1,
    G_CONNECT_AFTER=1,
    G_FILE_TEST_IS_REGULAR=1,
    G_LOG_FLAG_RECURSION=1,
    G_PARAM_READABLE=1,
    G_SIGNAL_RUN_FIRST=1,
    HID_Integer=1,
    MENU_LIBRARY_COLUMN=1,
    NET_NAME_COLUMN=1,
    NODE_LIBRARY_COLUMN=1,
    ODD=1,
    PANGO_STYLE_OBLIQUE=1,
    PANGO_UNDERLINE_SINGLE=1,
    PCB_WATCH_READABLE=1,
    PIN=1,
    PROP_ELEMENT_DATA=1,
    PROP_TITLE=1,
    PROP_VIOLATION=1,
    ROTATE=1,
    TRUE=1,
    _ISblank=1,
    __LC_NUMERIC=1,
    DBUS_BUS_STARTER=2,
    DBUS_WATCH_WRITABLE=2,
    EVEN=2,
    EXCHANGE=2,
    GDK_CAP_ROUND=2,
    GDK_EXPOSURE_MASK=2,
    GDK_JOIN_BEVEL=2,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_RGB_DITHER_MAX=2,
    GDK_XOR=2,
    GTK_ARROW_LEFT=2,
    GTK_BUTTONS_CLOSE=2,
    GTK_DIALOG_DESTROY_WITH_PARENT=2,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2,
    GTK_ICON_SIZE_SMALL_TOOLBAR=2,
    GTK_MESSAGE_QUESTION=2,
    GTK_POLICY_NEVER=2,
    GTK_RELIEF_NONE=2,
    GTK_SHADOW_OUT=2,
    GTK_STATE_PRELIGHT=2,
    GTK_WIN_POS_MOUSE=2,
    G_CONNECT_SWAPPED=2,
    G_FILE_TEST_IS_SYMLINK=2,
    G_LOG_FLAG_FATAL=2,
    G_PARAM_WRITABLE=2,
    G_SIGNAL_RUN_LAST=2,
    HID_Real=2,
    MENU_ENTRY_COLUMN=2,
    NET_LIBRARY_COLUMN=2,
    NUM_DRC_COLUMNS=2,
    N_CONFIG_COLUMNS=2,
    N_NODE_COLUMNS=2,
    PANGO_STYLE_ITALIC=2,
    PANGO_UNDERLINE_DOUBLE=2,
    PCB_WATCH_WRITABLE=2,
    PROP_EXPLANATION=2,
    VIA=2,
    _IScntrl=2,
    __LC_TIME=2,
    err_no_memory=2,
    GDK_CAP_PROJECTING=3,
    GDK_CLEAR=3,
    GTK_ARROW_RIGHT=3,
    GTK_BUTTONS_CANCEL=3,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3,
    GTK_ICON_SIZE_LARGE_TOOLBAR=3,
    GTK_MESSAGE_ERROR=3,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_STATE_SELECTED=3,
    GTK_WIN_POS_CENTER_ALWAYS=3,
    HID_String=3,
    N_MENU_COLUMNS=3,
    N_NET_COLUMNS=3,
    PANGO_UNDERLINE_LOW=3,
    PROP_X_COORD=3,
    VIA_SHADOW=3,
    __LC_COLLATE=3,
    err_bad_parm=3,
    DBUS_WATCH_ERROR=4,
    GDK_AND=4,
    GDK_POINTER_MOTION_MASK=4,
    GTK_ARROW_NONE=4,
    GTK_BUTTONS_YES_NO=4,
    GTK_DIALOG_NO_SEPARATOR=4,
    GTK_ICON_SIZE_BUTTON=4,
    GTK_MESSAGE_OTHER=4,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_STATE_INSENSITIVE=4,
    GTK_WIN_POS_CENTER_ON_PARENT=4,
    G_FILE_TEST_IS_DIR=4,
    G_LOG_LEVEL_ERROR=4,
    G_PARAM_CONSTRUCT=4,
    G_SIGNAL_RUN_CLEANUP=4,
    HID_Boolean=4,
    LINE=4,
    PANGO_UNDERLINE_ERROR=4,
    PCB_WATCH_ERROR=4,
    PROP_Y_COORD=4,
    _ISpunct=4,
    __LC_MONETARY=4,
    GDK_AND_REVERSE=5,
    GTK_BUTTONS_OK_CANCEL=5,
    GTK_ICON_SIZE_DND=5,
    HID_Enum=5,
    OTHER=5,
    PROP_ANGLE=5,
    __LC_MESSAGES=5,
    EXPANSION_AREA=6,
    GDK_AND_INVERT=6,
    GTK_ICON_SIZE_DIALOG=6,
    HID_Mixed=6,
    PROP_HAVE_MEASURED=6,
    __LC_ALL=6,
    GDK_NOOP=7,
    HID_Path=7,
    PLANE=7,
    PROP_MEASURED_VALUE=7,
    __LC_PAPER=7,
    DBUS_WATCH_HANGUP=8,
    GDK_OR=8,
    GDK_POINTER_MOTION_HINT_MASK=8,
    G_FILE_TEST_IS_EXECUTABLE=8,
    G_LOG_LEVEL_CRITICAL=8,
    G_PARAM_CONSTRUCT_ONLY=8,
    G_SIGNAL_NO_RECURSE=8,
    PCB_WATCH_HANGUP=8,
    PROP_REQUIRED_VALUE=8,
    THERMAL=8,
    _ISalnum=8,
    __LC_NAME=8,
    GDK_EQUIV=9,
    PROP_VALUE_DIGITS=9,
    __LC_ADDRESS=9,
    GDK_OR_REVERSE=10,
    PROP_VALUE_UNITS=10,
    __LC_TELEPHONE=10,
    GDK_COPY_INVERT=11,
    PROP_OBJECT_LIST=11,
    __LC_MEASUREMENT=11,
    GDK_OR_INVERT=12,
    PROP_PIXMAP=12,
    __LC_IDENTIFICATION=12,
    GDK_NAND=13,
    GDK_NOR=14,
    GDK_SET=15,
    GDK_BUTTON_MOTION_MASK=16,
    GTK_TOPLEVEL=16,
    G_FILE_TEST_EXISTS=16,
    G_LOG_LEVEL_WARNING=16,
    G_PARAM_LAX_VALIDATION=16,
    G_SIGNAL_DETAILED=16,
    GDK_BUTTON1_MOTION_MASK=32,
    GTK_NO_WINDOW=32,
    G_LOG_LEVEL_MESSAGE=32,
    G_PARAM_PRIVATE=32,
    G_PARAM_STATIC_NAME=32,
    G_SIGNAL_ACTION=32,
    G_TOKEN_LEFT_PAREN=40,
    G_TOKEN_RIGHT_PAREN=41,
    G_TOKEN_COMMA=44,
    G_TOKEN_EQUAL_SIGN=61,
    GDK_BUTTON2_MOTION_MASK=64,
    GTK_REALIZED=64,
    G_LOG_LEVEL_INFO=64,
    G_PARAM_STATIC_NICK=64,
    G_SIGNAL_NO_HOOKS=64,
    G_TOKEN_LEFT_BRACE=91,
    G_TOKEN_RIGHT_BRACE=93,
    PANGO_WEIGHT_THIN=100,
    G_TOKEN_LEFT_CURLY=123,
    G_TOKEN_RIGHT_CURLY=125,
    GDK_BUTTON3_MOTION_MASK=128,
    GTK_MAPPED=128,
    G_LOG_LEVEL_DEBUG=128,
    G_PARAM_STATIC_BLURB=128,
    PANGO_WEIGHT_ULTRALIGHT=200,
    GDK_BUTTON_PRESS_MASK=256,
    GTK_VISIBLE=256,
    G_TOKEN_NONE=256,
    _ISupper=256,
    G_TOKEN_ERROR=257,
    G_TOKEN_CHAR=258,
    G_TOKEN_BINARY=259,
    G_TOKEN_OCTAL=260,
    G_TOKEN_INT=261,
    G_TOKEN_HEX=262,
    G_TOKEN_FLOAT=263,
    G_TOKEN_STRING=264,
    G_TOKEN_SYMBOL=265,
    G_TOKEN_IDENTIFIER=266,
    G_TOKEN_IDENTIFIER_NULL=267,
    G_TOKEN_COMMENT_SINGLE=268,
    G_TOKEN_COMMENT_MULTI=269,
    G_TOKEN_LAST=270,
    PANGO_WEIGHT_LIGHT=300,
    PANGO_WEIGHT_BOOK=380,
    PANGO_WEIGHT_NORMAL=400,
    PANGO_WEIGHT_MEDIUM=500,
    GDK_BUTTON_RELEASE_MASK=512,
    GTK_SENSITIVE=512,
    _ISlower=512,
    PANGO_WEIGHT_SEMIBOLD=600,
    PANGO_WEIGHT_BOLD=700,
    PANGO_WEIGHT_ULTRABOLD=800,
    PANGO_WEIGHT_HEAVY=900,
    PANGO_WEIGHT_ULTRAHEAVY=1000,
    GDK_KEY_PRESS_MASK=1024,
    GTK_PARENT_SENSITIVE=1024,
    _ISalpha=1024,
    GDK_KEY_RELEASE_MASK=2048,
    GTK_CAN_FOCUS=2048,
    _ISdigit=2048,
    GDK_ENTER_NOTIFY_MASK=4096,
    GTK_HAS_FOCUS=4096,
    _ISxdigit=4096,
    GDK_LEAVE_NOTIFY_MASK=8192,
    GTK_CAN_DEFAULT=8192,
    _ISspace=8192,
    GDK_FOCUS_CHANGE_MASK=16384,
    GTK_HAS_DEFAULT=16384,
    _ISprint=16384,
    GDK_STRUCTURE_MASK=32768,
    GTK_HAS_GRAB=32768,
    _ISgraph=32768,
    GDK_PROPERTY_CHANGE_MASK=65536,
    GTK_RC_STYLE=65536,
    GDK_VISIBILITY_NOTIFY_MASK=131072,
    GTK_COMPOSITE_CHILD=131072,
    GDK_PROXIMITY_IN_MASK=262144,
    GTK_NO_REPARENT=262144,
    GDK_PROXIMITY_OUT_MASK=524288,
    GTK_APP_PAINTABLE=524288,
    GDK_SUBSTRUCTURE_MASK=1048576,
    GTK_RECEIVES_DEFAULT=1048576,
    GDK_SCROLL_MASK=2097152,
    GTK_DOUBLE_BUFFERED=2097152,
    GDK_ALL_EVENTS_MASK=4194302,
    GTK_NO_SHOW_ALL=4194304
} anon_enum_32;

typedef struct HID_Attr_Val HID_Attr_Val, *PHID_Attr_Val;

struct HID_Attr_Val {
    int int_value;
    char * str_value;
    double real_value;
};

struct HID_Attribute {
    char * name;
    char * help_text;
    enum anon_enum_32 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

struct HID_AttrNode {
    struct HID_AttrNode * next;
    struct HID_Attribute * attributes;
    int n;
};

typedef struct _GtkButton _GtkButton, *P_GtkButton;

typedef struct _GtkBin _GtkBin, *P_GtkBin;

typedef struct _GtkBin GtkBin;

typedef struct _GdkDrawable _GdkDrawable, *P_GdkDrawable;

typedef struct _GdkDrawable GdkWindow;

typedef struct _GtkContainer _GtkContainer, *P_GtkContainer;

typedef struct _GtkContainer GtkContainer;

typedef struct _GtkWidget _GtkWidget, *P_GtkWidget;

typedef struct _GtkWidget GtkWidget;

typedef struct _GtkStyle _GtkStyle, *P_GtkStyle;

typedef struct _GtkStyle GtkStyle;

typedef struct _GtkRequisition _GtkRequisition, *P_GtkRequisition;

typedef struct _GtkRequisition GtkRequisition;

typedef struct _GdkRectangle _GdkRectangle, *P_GdkRectangle;

typedef struct _GdkRectangle GdkRectangle;

typedef GdkRectangle GtkAllocation;

typedef struct _GdkColor _GdkColor, *P_GdkColor;

typedef struct _GdkColor GdkColor;

typedef struct _PangoFontDescription _PangoFontDescription, *P_PangoFontDescription;

typedef struct _PangoFontDescription PangoFontDescription;

typedef struct _GdkGC _GdkGC, *P_GdkGC;

typedef struct _GdkGC GdkGC;

typedef struct _GdkDrawable GdkPixmap;

typedef struct _GdkColormap _GdkColormap, *P_GdkColormap;

typedef struct _GdkColormap GdkColormap;

typedef struct _GdkFont _GdkFont, *P_GdkFont;

typedef struct _GdkFont GdkFont;

typedef struct _GtkRcStyle _GtkRcStyle, *P_GtkRcStyle;

typedef struct _GtkRcStyle GtkRcStyle;

typedef struct _GArray _GArray, *P_GArray;

typedef struct _GArray GArray;

typedef struct _GdkVisual _GdkVisual, *P_GdkVisual;

typedef struct _GdkVisual GdkVisual;

typedef enum GdkFontType {
    GDK_FONT_FONT=0,
    GDK_FONT_FONTSET=1
} GdkFontType;

typedef enum GtkRcFlags {
    GTK_RC_FG=1,
    GTK_RC_BG=2,
    GTK_RC_TEXT=4,
    GTK_RC_BASE=8
} GtkRcFlags;

typedef enum GdkByteOrder {
    GDK_LSB_FIRST=0,
    GDK_MSB_FIRST=1
} GdkByteOrder;

struct _GdkRectangle {
    gint x;
    gint y;
    gint width;
    gint height;
};

struct _GtkRequisition {
    gint width;
    gint height;
};

struct _GtkWidget {
    GtkObject object;
    guint16 private_flags;
    guint8 state;
    guint8 saved_state;
    gchar * name;
    GtkStyle * style;
    GtkRequisition requisition;
    GtkAllocation allocation;
    GdkWindow * window;
    GtkWidget * parent;
};

struct _GtkContainer {
    GtkWidget widget;
    GtkWidget * focus_child;
    guint border_width:16;
    guint need_resize:1;
    guint resize_mode:2;
    guint reallocate_redraws:1;
    guint has_focus_chain:1;
};

struct _GtkBin {
    GtkContainer container;
    GtkWidget * child;
};

struct _GdkVisual {
    GObject parent_instance;
    enum GdkVisualType type;
    gint depth;
    enum GdkByteOrder byte_order;
    gint colormap_size;
    gint bits_per_rgb;
    guint32 red_mask;
    gint red_shift;
    gint red_prec;
    guint32 green_mask;
    gint green_shift;
    gint green_prec;
    guint32 blue_mask;
    gint blue_shift;
    gint blue_prec;
};

struct _PangoFontDescription {
};

struct _GdkFont {
    enum GdkFontType type;
    gint ascent;
    gint descent;
};

struct _GdkColormap {
    GObject parent_instance;
    gint size;
    GdkColor * colors;
    GdkVisual * visual;
    gpointer windowing_data;
};

struct _GArray {
    gchar * data;
    guint len;
};

struct _GdkColor {
    guint32 pixel;
    guint16 red;
    guint16 green;
    guint16 blue;
};

struct _GtkRcStyle {
    GObject parent_instance;
    gchar * name;
    gchar * bg_pixmap_name[5];
    PangoFontDescription * font_desc;
    enum GtkRcFlags color_flags[5];
    GdkColor fg[5];
    GdkColor bg[5];
    GdkColor text[5];
    GdkColor base[5];
    gint xthickness;
    gint ythickness;
    GArray * rc_properties;
    GSList * rc_style_lists;
    GSList * icon_factories;
    guint engine_specified:1;
};

struct _GtkButton {
    GtkBin bin;
    GdkWindow * event_window;
    gchar * label_text;
    guint activate_timeout;
    guint constructed:1;
    guint in_button:1;
    guint button_down:1;
    guint relief:2;
    guint use_underline:1;
    guint use_stock:1;
    guint depressed:1;
    guint depress_on_activate:1;
    guint focus_on_click:1;
};

struct _GdkDrawable {
    GObject parent_instance;
};

struct _GtkStyle {
    GObject parent_instance;
    GdkColor fg[5];
    GdkColor bg[5];
    GdkColor light[5];
    GdkColor dark[5];
    GdkColor mid[5];
    GdkColor text[5];
    GdkColor base[5];
    GdkColor text_aa[5];
    GdkColor black;
    GdkColor white;
    PangoFontDescription * font_desc;
    gint xthickness;
    gint ythickness;
    GdkGC * fg_gc[5];
    GdkGC * bg_gc[5];
    GdkGC * light_gc[5];
    GdkGC * dark_gc[5];
    GdkGC * mid_gc[5];
    GdkGC * text_gc[5];
    GdkGC * base_gc[5];
    GdkGC * text_aa_gc[5];
    GdkGC * black_gc;
    GdkGC * white_gc;
    GdkPixmap * bg_pixmap[5];
    gint attach_count;
    gint depth;
    GdkColormap * colormap;
    GdkFont * private_font;
    PangoFontDescription * private_font_desc;
    GtkRcStyle * rc_style;
    GSList * styles;
    GArray * property_cache;
    GSList * icon_factories;
};

struct _GdkGC {
    GObject parent_instance;
    gint clip_x_origin;
    gint clip_y_origin;
    gint ts_x_origin;
    gint ts_y_origin;
    GdkColormap * colormap;
};

typedef struct _GtkButton GtkButton;

typedef struct _GtkTextMark _GtkTextMark, *P_GtkTextMark;

struct _GtkTextMark {
    GObject parent_instance;
    gpointer segment;
};

typedef struct _GtkTextMark GtkTextMark;

typedef struct rlp_info rlp_info, *Prlp_info;

typedef struct __jmp_buf_tag __jmp_buf_tag, *P__jmp_buf_tag;

typedef struct LineType * LineTypePtr;

typedef struct PointType * PointTypePtr;

typedef int __jmp_buf[6];

typedef struct __sigset_t __sigset_t, *P__sigset_t;

struct __sigset_t {
    ulong __val[32];
};

struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    struct __sigset_t __saved_mask;
};

struct rlp_info {
    jmp_buf env;
    LineTypePtr line;
    PointTypePtr point;
};

typedef struct __jmp_buf_tag jmp_buf[1];

typedef struct ggnfnn_task ggnfnn_task, *Pggnfnn_task;

typedef struct anon_struct_28_8_ad772bab anon_struct_28_8_ad772bab, *Panon_struct_28_8_ad772bab;

typedef struct anon_struct_28_8_ad772bab LibraryMenuType;

typedef struct _GtkTreeIter _GtkTreeIter, *P_GtkTreeIter;

typedef struct _GtkTreeIter GtkTreeIter;

typedef struct anon_struct_24_6_049bbb11 anon_struct_24_6_049bbb11, *Panon_struct_24_6_049bbb11;

typedef struct anon_struct_24_6_049bbb11 * LibraryEntryTypePtr;

struct anon_struct_28_8_ad772bab {
    char * Name;
    char * directory;
    char * Style;
    Cardinal EntryN;
    Cardinal EntryMax;
    LibraryEntryTypePtr Entry;
    char flag;
    char internal;
};

struct anon_struct_24_6_049bbb11 {
    char * ListEntry;
    char * AllocatedMemory;
    char * Template;
    char * Package;
    char * Value;
    char * Description;
};

struct _GtkTreeIter {
    gint stamp;
    gpointer user_data;
    gpointer user_data2;
    gpointer user_data3;
};

struct ggnfnn_task {
    gboolean enabled_only;
    gchar * node_name;
    LibraryMenuType * found_net;
    GtkTreeIter iter;
};

typedef struct _GtkMessageDialog _GtkMessageDialog, *P_GtkMessageDialog;

typedef struct _GtkDialog _GtkDialog, *P_GtkDialog;

typedef struct _GtkDialog GtkDialog;

typedef struct _GtkWindow _GtkWindow, *P_GtkWindow;

typedef struct _GtkWindow GtkWindow;

typedef struct _GtkWindowGeometryInfo _GtkWindowGeometryInfo, *P_GtkWindowGeometryInfo;

typedef struct _GtkWindowGeometryInfo GtkWindowGeometryInfo;

typedef struct _GtkWindowGroup _GtkWindowGroup, *P_GtkWindowGroup;

typedef struct _GtkWindowGroup GtkWindowGroup;

typedef enum GdkModifierType {
    GDK_SHIFT_MASK=1,
    GDK_LOCK_MASK=2,
    GDK_CONTROL_MASK=4,
    GDK_MOD1_MASK=8,
    GDK_MOD2_MASK=16,
    GDK_MOD3_MASK=32,
    GDK_MOD4_MASK=64,
    GDK_MOD5_MASK=128,
    GDK_BUTTON1_MASK=256,
    GDK_BUTTON2_MASK=512,
    GDK_BUTTON3_MASK=1024,
    GDK_BUTTON4_MASK=2048,
    GDK_BUTTON5_MASK=4096,
    GDK_SUPER_MASK=67108864,
    GDK_HYPER_MASK=134217728,
    GDK_META_MASK=268435456,
    GDK_RELEASE_MASK=1073741824,
    GDK_MODIFIER_MASK=1543512063
} GdkModifierType;

typedef struct _GdkScreen _GdkScreen, *P_GdkScreen;

typedef struct _GdkScreen GdkScreen;

typedef struct _cairo_font_options _cairo_font_options, *P_cairo_font_options;

typedef struct _cairo_font_options cairo_font_options_t;

struct _GtkWindow {
    GtkBin bin;
    gchar * title;
    gchar * wmclass_name;
    gchar * wmclass_class;
    gchar * wm_role;
    GtkWidget * focus_widget;
    GtkWidget * default_widget;
    GtkWindow * transient_parent;
    GtkWindowGeometryInfo * geometry_info;
    GdkWindow * frame;
    GtkWindowGroup * group;
    guint16 configure_request_count;
    guint allow_shrink:1;
    guint allow_grow:1;
    guint configure_notify_received:1;
    guint need_default_position:1;
    guint need_default_size:1;
    guint position:3;
    guint type:4;
    guint has_user_ref_count:1;
    guint has_focus:1;
    guint modal:1;
    guint destroy_with_parent:1;
    guint has_frame:1;
    guint iconify_initially:1;
    guint stick_initially:1;
    guint maximize_initially:1;
    guint decorated:1;
    guint type_hint:3;
    guint gravity:5;
    guint is_active:1;
    guint has_toplevel_focus:1;
    guint frame_left;
    guint frame_top;
    guint frame_right;
    guint frame_bottom;
    guint keys_changed_handler;
    enum GdkModifierType mnemonic_modifier;
    GdkScreen * screen;
};

struct _GtkDialog {
    GtkWindow window;
    GtkWidget * vbox;
    GtkWidget * action_area;
    GtkWidget * separator;
};

struct _GtkMessageDialog {
    GtkDialog parent_instance;
    GtkWidget * image;
    GtkWidget * label;
};

struct _GtkWindowGeometryInfo {
};

struct _cairo_font_options {
};

struct _GdkScreen {
    GObject parent_instance;
    guint closed:1;
    GdkGC * normal_gcs[32];
    GdkGC * exposure_gcs[32];
    GdkGC * subwindow_gcs[32];
    cairo_font_options_t * font_options;
    double resolution;
};

struct _GtkWindowGroup {
    GObject parent_instance;
    GSList * grabs;
};

typedef struct anon_struct_92_8_14040740 anon_struct_92_8_14040740, *Panon_struct_92_8_14040740;

struct anon_struct_92_8_14040740 {
    Boolean ElementOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean ViaOn;
    Boolean RatOn;
    int LayerStack[16];
    Boolean LayerOn[16];
    int cnt;
};

typedef struct _GPtrArray _GPtrArray, *P_GPtrArray;

typedef struct _GPtrArray GPtrArray;

struct _GPtrArray {
    gpointer * pdata;
    guint len;
};

typedef struct _GtkButtonBox _GtkButtonBox, *P_GtkButtonBox;

typedef struct _GtkBox _GtkBox, *P_GtkBox;

typedef struct _GtkBox GtkBox;

typedef enum GtkButtonBoxStyle {
    GTK_BUTTONBOX_DEFAULT_STYLE=0,
    GTK_BUTTONBOX_SPREAD=1,
    GTK_BUTTONBOX_EDGE=2,
    GTK_BUTTONBOX_START=3,
    GTK_BUTTONBOX_END=4,
    GTK_BUTTONBOX_CENTER=5
} GtkButtonBoxStyle;

typedef struct _GList _GList, *P_GList;

typedef struct _GList GList;

struct _GtkBox {
    GtkContainer container;
    GList * children;
    gint16 spacing;
    guint homogeneous:1;
};

struct _GtkButtonBox {
    GtkBox box;
    gint child_min_width;
    gint child_min_height;
    gint child_ipad_x;
    gint child_ipad_y;
    enum GtkButtonBoxStyle layout_style;
};

struct _GList {
    gpointer data;
    GList * next;
    GList * prev;
};

typedef void (* GtkCallback)(GtkWidget *, gpointer);

typedef struct _GtkTooltip _GtkTooltip, *P_GtkTooltip;

typedef struct _GtkTooltip GtkTooltip;

struct _GtkTooltip {
};

typedef struct _GtkWidgetClass _GtkWidgetClass, *P_GtkWidgetClass;

typedef enum GtkStateType {
    GTK_STATE_NORMAL=0,
    GTK_STATE_ACTIVE=1,
    GTK_STATE_PRELIGHT=2,
    GTK_STATE_SELECTED=3,
    GTK_STATE_INSENSITIVE=4
} GtkStateType;

typedef enum GtkTextDirection {
    GTK_TEXT_DIR_NONE=0,
    GTK_TEXT_DIR_LTR=1,
    GTK_TEXT_DIR_RTL=2
} GtkTextDirection;

typedef enum GtkDirectionType {
    GTK_DIR_TAB_FORWARD=0,
    GTK_DIR_TAB_BACKWARD=1,
    GTK_DIR_UP=2,
    GTK_DIR_DOWN=3,
    GTK_DIR_LEFT=4,
    GTK_DIR_RIGHT=5
} GtkDirectionType;

typedef union _GdkEvent _GdkEvent, *P_GdkEvent;

typedef union _GdkEvent GdkEvent;

typedef struct _GdkEventButton _GdkEventButton, *P_GdkEventButton;

typedef struct _GdkEventButton GdkEventButton;

typedef struct _GdkEventScroll _GdkEventScroll, *P_GdkEventScroll;

typedef struct _GdkEventScroll GdkEventScroll;

typedef struct _GdkEventMotion _GdkEventMotion, *P_GdkEventMotion;

typedef struct _GdkEventMotion GdkEventMotion;

typedef struct _GdkEventAny _GdkEventAny, *P_GdkEventAny;

typedef struct _GdkEventAny GdkEventAny;

typedef struct _GdkEventExpose _GdkEventExpose, *P_GdkEventExpose;

typedef struct _GdkEventExpose GdkEventExpose;

typedef struct _GdkEventKey _GdkEventKey, *P_GdkEventKey;

typedef struct _GdkEventKey GdkEventKey;

typedef struct _GdkEventCrossing _GdkEventCrossing, *P_GdkEventCrossing;

typedef struct _GdkEventCrossing GdkEventCrossing;

typedef struct _GdkEventConfigure _GdkEventConfigure, *P_GdkEventConfigure;

typedef struct _GdkEventConfigure GdkEventConfigure;

typedef struct _GdkEventFocus _GdkEventFocus, *P_GdkEventFocus;

typedef struct _GdkEventFocus GdkEventFocus;

typedef struct _GdkEventProperty _GdkEventProperty, *P_GdkEventProperty;

typedef struct _GdkEventProperty GdkEventProperty;

typedef struct _GdkEventSelection _GdkEventSelection, *P_GdkEventSelection;

typedef struct _GdkEventSelection GdkEventSelection;

typedef struct _GdkEventProximity _GdkEventProximity, *P_GdkEventProximity;

typedef struct _GdkEventProximity GdkEventProximity;

typedef struct _GdkEventVisibility _GdkEventVisibility, *P_GdkEventVisibility;

typedef struct _GdkEventVisibility GdkEventVisibility;

typedef struct _GdkEventClient _GdkEventClient, *P_GdkEventClient;

typedef struct _GdkEventClient GdkEventClient;

typedef struct _GdkEventWindowState _GdkEventWindowState, *P_GdkEventWindowState;

typedef struct _GdkEventWindowState GdkEventWindowState;

typedef struct _GtkSelectionData _GtkSelectionData, *P_GtkSelectionData;

typedef struct _GtkSelectionData GtkSelectionData;

typedef struct _GdkDragContext _GdkDragContext, *P_GdkDragContext;

typedef struct _GdkDragContext GdkDragContext;

typedef enum GtkWidgetHelpType {
    GTK_WIDGET_HELP_TOOLTIP=0,
    GTK_WIDGET_HELP_WHATS_THIS=1
} GtkWidgetHelpType;

typedef struct _AtkObject _AtkObject, *P_AtkObject;

typedef struct _AtkObject AtkObject;

typedef struct _GdkEventGrabBroken _GdkEventGrabBroken, *P_GdkEventGrabBroken;

typedef struct _GdkEventGrabBroken GdkEventGrabBroken;

typedef struct _GtkWidgetClass GtkWidgetClass;

typedef struct _GtkObjectClass _GtkObjectClass, *P_GtkObjectClass;

typedef struct _GtkObjectClass GtkObjectClass;

typedef enum GdkEventType {
    GDK_NOTHING=-1,
    GDK_DELETE=0,
    GDK_DESTROY=1,
    GDK_EXPOSE=2,
    GDK_MOTION_NOTIFY=3,
    GDK_BUTTON_PRESS=4,
    GDK_2BUTTON_PRESS=5,
    GDK_3BUTTON_PRESS=6,
    GDK_BUTTON_RELEASE=7,
    GDK_KEY_PRESS=8,
    GDK_KEY_RELEASE=9,
    GDK_ENTER_NOTIFY=10,
    GDK_LEAVE_NOTIFY=11,
    GDK_FOCUS_CHANGE=12,
    GDK_CONFIGURE=13,
    GDK_MAP=14,
    GDK_UNMAP=15,
    GDK_PROPERTY_NOTIFY=16,
    GDK_SELECTION_CLEAR=17,
    GDK_SELECTION_REQUEST=18,
    GDK_SELECTION_NOTIFY=19,
    GDK_PROXIMITY_IN=20,
    GDK_PROXIMITY_OUT=21,
    GDK_DRAG_ENTER=22,
    GDK_DRAG_LEAVE=23,
    GDK_DRAG_MOTION=24,
    GDK_DRAG_STATUS=25,
    GDK_DROP_START=26,
    GDK_DROP_FINISHED=27,
    GDK_CLIENT_EVENT=28,
    GDK_VISIBILITY_NOTIFY=29,
    GDK_NO_EXPOSE=30,
    GDK_SCROLL=31,
    GDK_WINDOW_STATE=32,
    GDK_SETTING=33,
    GDK_OWNER_CHANGE=34,
    GDK_GRAB_BROKEN=35,
    GDK_DAMAGE=36,
    GDK_EVENT_LAST=37
} GdkEventType;

typedef struct _GdkEventNoExpose _GdkEventNoExpose, *P_GdkEventNoExpose;

typedef struct _GdkEventNoExpose GdkEventNoExpose;

typedef struct _GdkEventOwnerChange _GdkEventOwnerChange, *P_GdkEventOwnerChange;

typedef struct _GdkEventOwnerChange GdkEventOwnerChange;

typedef struct _GdkEventDND _GdkEventDND, *P_GdkEventDND;

typedef struct _GdkEventDND GdkEventDND;

typedef struct _GdkEventSetting _GdkEventSetting, *P_GdkEventSetting;

typedef struct _GdkEventSetting GdkEventSetting;

typedef struct _GdkDevice _GdkDevice, *P_GdkDevice;

typedef struct _GdkDevice GdkDevice;

typedef enum GdkScrollDirection {
    GDK_SCROLL_UP=0,
    GDK_SCROLL_DOWN=1,
    GDK_SCROLL_LEFT=2,
    GDK_SCROLL_RIGHT=3
} GdkScrollDirection;

typedef struct _GdkRegion _GdkRegion, *P_GdkRegion;

typedef struct _GdkRegion GdkRegion;

typedef enum GdkCrossingMode {
    GDK_CROSSING_NORMAL=0,
    GDK_CROSSING_GRAB=1,
    GDK_CROSSING_UNGRAB=2,
    GDK_CROSSING_GTK_GRAB=3,
    GDK_CROSSING_GTK_UNGRAB=4,
    GDK_CROSSING_STATE_CHANGED=5
} GdkCrossingMode;

typedef enum GdkNotifyType {
    GDK_NOTIFY_ANCESTOR=0,
    GDK_NOTIFY_VIRTUAL=1,
    GDK_NOTIFY_INFERIOR=2,
    GDK_NOTIFY_NONLINEAR=3,
    GDK_NOTIFY_NONLINEAR_VIRTUAL=4,
    GDK_NOTIFY_UNKNOWN=5
} GdkNotifyType;

typedef struct _GdkAtom _GdkAtom, *P_GdkAtom;

typedef struct _GdkAtom * GdkAtom;

typedef guint32 GdkNativeWindow;

typedef enum GdkVisibilityState {
    GDK_VISIBILITY_UNOBSCURED=0,
    GDK_VISIBILITY_PARTIAL=1,
    GDK_VISIBILITY_FULLY_OBSCURED=2
} GdkVisibilityState;

typedef union anon_union_20_3_4e909d29_for_data anon_union_20_3_4e909d29_for_data, *Panon_union_20_3_4e909d29_for_data;

typedef enum GdkWindowState {
    GDK_WINDOW_STATE_WITHDRAWN=1,
    GDK_WINDOW_STATE_ICONIFIED=2,
    GDK_WINDOW_STATE_MAXIMIZED=4,
    GDK_WINDOW_STATE_STICKY=8,
    GDK_WINDOW_STATE_FULLSCREEN=16,
    GDK_WINDOW_STATE_ABOVE=32,
    GDK_WINDOW_STATE_BELOW=64
} GdkWindowState;

typedef struct _GdkDisplay _GdkDisplay, *P_GdkDisplay;

typedef struct _GdkDisplay GdkDisplay;

typedef enum GdkDragProtocol {
    GDK_DRAG_PROTO_MOTIF=0,
    GDK_DRAG_PROTO_XDND=1,
    GDK_DRAG_PROTO_ROOTWIN=2,
    GDK_DRAG_PROTO_NONE=3,
    GDK_DRAG_PROTO_WIN32_DROPFILES=4,
    GDK_DRAG_PROTO_OLE2=5,
    GDK_DRAG_PROTO_LOCAL=6
} GdkDragProtocol;

typedef enum GdkDragAction {
    GDK_ACTION_DEFAULT=1,
    GDK_ACTION_COPY=2,
    GDK_ACTION_MOVE=4,
    GDK_ACTION_LINK=8,
    GDK_ACTION_PRIVATE=16,
    GDK_ACTION_ASK=32
} GdkDragAction;

typedef enum AtkRole {
    ATK_ROLE_INVALID=0,
    ATK_ROLE_ACCEL_LABEL=1,
    ATK_ROLE_ALERT=2,
    ATK_ROLE_ANIMATION=3,
    ATK_ROLE_ARROW=4,
    ATK_ROLE_CALENDAR=5,
    ATK_ROLE_CANVAS=6,
    ATK_ROLE_CHECK_BOX=7,
    ATK_ROLE_CHECK_MENU_ITEM=8,
    ATK_ROLE_COLOR_CHOOSER=9,
    ATK_ROLE_COLUMN_HEADER=10,
    ATK_ROLE_COMBO_BOX=11,
    ATK_ROLE_DATE_EDITOR=12,
    ATK_ROLE_DESKTOP_ICON=13,
    ATK_ROLE_DESKTOP_FRAME=14,
    ATK_ROLE_DIAL=15,
    ATK_ROLE_DIALOG=16,
    ATK_ROLE_DIRECTORY_PANE=17,
    ATK_ROLE_DRAWING_AREA=18,
    ATK_ROLE_FILE_CHOOSER=19,
    ATK_ROLE_FILLER=20,
    ATK_ROLE_FONT_CHOOSER=21,
    ATK_ROLE_FRAME=22,
    ATK_ROLE_GLASS_PANE=23,
    ATK_ROLE_HTML_CONTAINER=24,
    ATK_ROLE_ICON=25,
    ATK_ROLE_IMAGE=26,
    ATK_ROLE_INTERNAL_FRAME=27,
    ATK_ROLE_LABEL=28,
    ATK_ROLE_LAYERED_PANE=29,
    ATK_ROLE_LIST=30,
    ATK_ROLE_LIST_ITEM=31,
    ATK_ROLE_MENU=32,
    ATK_ROLE_MENU_BAR=33,
    ATK_ROLE_MENU_ITEM=34,
    ATK_ROLE_OPTION_PANE=35,
    ATK_ROLE_PAGE_TAB=36,
    ATK_ROLE_PAGE_TAB_LIST=37,
    ATK_ROLE_PANEL=38,
    ATK_ROLE_PASSWORD_TEXT=39,
    ATK_ROLE_POPUP_MENU=40,
    ATK_ROLE_PROGRESS_BAR=41,
    ATK_ROLE_PUSH_BUTTON=42,
    ATK_ROLE_RADIO_BUTTON=43,
    ATK_ROLE_RADIO_MENU_ITEM=44,
    ATK_ROLE_ROOT_PANE=45,
    ATK_ROLE_ROW_HEADER=46,
    ATK_ROLE_SCROLL_BAR=47,
    ATK_ROLE_SCROLL_PANE=48,
    ATK_ROLE_SEPARATOR=49,
    ATK_ROLE_SLIDER=50,
    ATK_ROLE_SPLIT_PANE=51,
    ATK_ROLE_SPIN_BUTTON=52,
    ATK_ROLE_STATUSBAR=53,
    ATK_ROLE_TABLE=54,
    ATK_ROLE_TABLE_CELL=55,
    ATK_ROLE_TABLE_COLUMN_HEADER=56,
    ATK_ROLE_TABLE_ROW_HEADER=57,
    ATK_ROLE_TEAR_OFF_MENU_ITEM=58,
    ATK_ROLE_TERMINAL=59,
    ATK_ROLE_TEXT=60,
    ATK_ROLE_TOGGLE_BUTTON=61,
    ATK_ROLE_TOOL_BAR=62,
    ATK_ROLE_TOOL_TIP=63,
    ATK_ROLE_TREE=64,
    ATK_ROLE_TREE_TABLE=65,
    ATK_ROLE_UNKNOWN=66,
    ATK_ROLE_VIEWPORT=67,
    ATK_ROLE_WINDOW=68,
    ATK_ROLE_HEADER=69,
    ATK_ROLE_FOOTER=70,
    ATK_ROLE_PARAGRAPH=71,
    ATK_ROLE_RULER=72,
    ATK_ROLE_APPLICATION=73,
    ATK_ROLE_AUTOCOMPLETE=74,
    ATK_ROLE_EDITBAR=75,
    ATK_ROLE_EMBEDDED=76,
    ATK_ROLE_ENTRY=77,
    ATK_ROLE_CHART=78,
    ATK_ROLE_CAPTION=79,
    ATK_ROLE_DOCUMENT_FRAME=80,
    ATK_ROLE_HEADING=81,
    ATK_ROLE_PAGE=82,
    ATK_ROLE_SECTION=83,
    ATK_ROLE_REDUNDANT_OBJECT=84,
    ATK_ROLE_FORM=85,
    ATK_ROLE_LINK=86,
    ATK_ROLE_INPUT_METHOD_WINDOW=87,
    ATK_ROLE_LAST_DEFINED=88
} AtkRole;

typedef struct _AtkRelationSet _AtkRelationSet, *P_AtkRelationSet;

typedef struct _AtkRelationSet AtkRelationSet;

typedef enum AtkLayer {
    ATK_LAYER_INVALID=0,
    ATK_LAYER_BACKGROUND=1,
    ATK_LAYER_CANVAS=2,
    ATK_LAYER_WIDGET=3,
    ATK_LAYER_MDI=4,
    ATK_LAYER_POPUP=5,
    ATK_LAYER_OVERLAY=6,
    ATK_LAYER_WINDOW=7
} AtkLayer;

typedef enum GdkOwnerChange {
    GDK_OWNER_CHANGE_NEW_OWNER=0,
    GDK_OWNER_CHANGE_DESTROY=1,
    GDK_OWNER_CHANGE_CLOSE=2
} GdkOwnerChange;

typedef enum GdkSettingAction {
    GDK_SETTING_ACTION_NEW=0,
    GDK_SETTING_ACTION_CHANGED=1,
    GDK_SETTING_ACTION_DELETED=2
} GdkSettingAction;

typedef enum GdkInputSource {
    GDK_SOURCE_MOUSE=0,
    GDK_SOURCE_PEN=1,
    GDK_SOURCE_ERASER=2,
    GDK_SOURCE_CURSOR=3
} GdkInputSource;

typedef enum GdkInputMode {
    GDK_MODE_DISABLED=0,
    GDK_MODE_SCREEN=1,
    GDK_MODE_WINDOW=2
} GdkInputMode;

typedef struct _GdkDeviceAxis _GdkDeviceAxis, *P_GdkDeviceAxis;

typedef struct _GdkDeviceAxis GdkDeviceAxis;

typedef struct _GdkDeviceKey _GdkDeviceKey, *P_GdkDeviceKey;

typedef struct _GdkDeviceKey GdkDeviceKey;

typedef struct _GdkDisplayPointerHooks _GdkDisplayPointerHooks, *P_GdkDisplayPointerHooks;

typedef struct _GdkDisplayPointerHooks GdkDisplayPointerHooks;

typedef struct GdkKeyboardGrabInfo GdkKeyboardGrabInfo, *PGdkKeyboardGrabInfo;

typedef struct GdkPointerWindowInfo GdkPointerWindowInfo, *PGdkPointerWindowInfo;

typedef enum GdkAxisUse {
    GDK_AXIS_IGNORE=0,
    GDK_AXIS_X=1,
    GDK_AXIS_Y=2,
    GDK_AXIS_PRESSURE=3,
    GDK_AXIS_XTILT=4,
    GDK_AXIS_YTILT=5,
    GDK_AXIS_WHEEL=6,
    GDK_AXIS_LAST=7
} GdkAxisUse;

struct GdkKeyboardGrabInfo {
    GdkWindow * window;
    GdkWindow * native_window;
    gulong serial;
    gboolean owner_events;
    guint32 time;
};

struct GdkPointerWindowInfo {
    GdkWindow * toplevel_under_pointer;
    GdkWindow * window_under_pointer;
    gdouble toplevel_x;
    gdouble toplevel_y;
    guint32 state;
    guint32 button;
    gulong motion_hint_serial;
};

struct _GdkDisplay {
    GObject parent_instance;
    GList * queued_events;
    GList * queued_tail;
    guint32 button_click_time[2];
    GdkWindow * button_window[2];
    gint button_number[2];
    guint double_click_time;
    GdkDevice * core_pointer;
    GdkDisplayPointerHooks * pointer_hooks;
    guint closed:1;
    guint ignore_core_events:1;
    guint double_click_distance;
    gint button_x[2];
    gint button_y[2];
    GList * pointer_grabs;
    struct GdkKeyboardGrabInfo keyboard_grab;
    struct GdkPointerWindowInfo pointer_info;
    guint32 last_event_time;
};

struct _GdkEventScroll {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    guint32 time;
    gdouble x;
    gdouble y;
    guint state;
    enum GdkScrollDirection direction;
    GdkDevice * device;
    gdouble x_root;
    gdouble y_root;
};

struct _GdkEventCrossing {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    GdkWindow * subwindow;
    guint32 time;
    gdouble x;
    gdouble y;
    gdouble x_root;
    gdouble y_root;
    enum GdkCrossingMode mode;
    enum GdkNotifyType detail;
    gboolean focus;
    guint state;
};

struct _GdkEventGrabBroken {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    gboolean keyboard;
    gboolean implicit;
    GdkWindow * grab_window;
};

struct _GdkDragContext {
    GObject parent_instance;
    enum GdkDragProtocol protocol;
    gboolean is_source;
    GdkWindow * source_window;
    GdkWindow * dest_window;
    GList * targets;
    enum GdkDragAction actions;
    enum GdkDragAction suggested_action;
    enum GdkDragAction action;
    guint32 start_time;
    gpointer windowing_data;
};

struct _GdkDeviceKey {
    guint keyval;
    enum GdkModifierType modifiers;
};

struct _GdkEventMotion {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    guint32 time;
    gdouble x;
    gdouble y;
    gdouble * axes;
    guint state;
    gint16 is_hint;
    GdkDevice * device;
    gdouble x_root;
    gdouble y_root;
};

struct _GdkEventKey {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    guint32 time;
    guint state;
    guint keyval;
    gint length;
    gchar * string;
    guint16 hardware_keycode;
    guint8 group;
    guint is_modifier:1;
};

struct _GdkEventProperty {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    GdkAtom atom;
    guint32 time;
    guint state;
};

struct _GdkEventProximity {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    guint32 time;
    GdkDevice * device;
};

struct _GdkEventExpose {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    GdkRectangle area;
    GdkRegion * region;
    gint count;
};

struct _AtkObject {
    GObject parent;
    gchar * description;
    gchar * name;
    AtkObject * accessible_parent;
    enum AtkRole role;
    AtkRelationSet * relation_set;
    enum AtkLayer layer;
};

struct _GdkAtom {
};

struct _GdkEventWindowState {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    enum GdkWindowState changed_mask;
    enum GdkWindowState new_window_state;
};

struct _AtkRelationSet {
    GObject parent;
    GPtrArray * relations;
};

struct _GdkEventDND {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    GdkDragContext * context;
    guint32 time;
    gshort x_root;
    gshort y_root;
};

union anon_union_20_3_4e909d29_for_data {
    char b[20];
    short s[10];
    long l[5];
};

struct _GdkEventClient {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    GdkAtom message_type;
    gushort data_format;
    union anon_union_20_3_4e909d29_for_data data;
};

struct _GdkEventConfigure {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    gint x;
    gint y;
    gint width;
    gint height;
};

struct _GdkEventSelection {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    GdkAtom selection;
    GdkAtom target;
    GdkAtom property;
    guint32 time;
    GdkNativeWindow requestor;
};

struct _GdkEventOwnerChange {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    GdkNativeWindow owner;
    enum GdkOwnerChange reason;
    GdkAtom selection;
    guint32 time;
    guint32 selection_time;
};

struct _GdkEventFocus {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    gint16 in;
};

struct _GdkEventAny {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
};

struct _GdkEventVisibility {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    enum GdkVisibilityState state;
};

struct _GdkEventButton {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    guint32 time;
    gdouble x;
    gdouble y;
    gdouble * axes;
    guint state;
    guint button;
    GdkDevice * device;
    gdouble x_root;
    gdouble y_root;
};

struct _GdkEventSetting {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    enum GdkSettingAction action;
    char * name;
};

struct _GdkEventNoExpose {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
};

union _GdkEvent {
    enum GdkEventType type;
    GdkEventAny any;
    GdkEventExpose expose;
    GdkEventNoExpose no_expose;
    GdkEventVisibility visibility;
    GdkEventMotion motion;
    GdkEventButton button;
    GdkEventScroll scroll;
    GdkEventKey key;
    GdkEventCrossing crossing;
    GdkEventFocus focus_change;
    GdkEventConfigure configure;
    GdkEventProperty property;
    GdkEventSelection selection;
    GdkEventOwnerChange owner_change;
    GdkEventProximity proximity;
    GdkEventClient client;
    GdkEventDND dnd;
    GdkEventWindowState window_state;
    GdkEventSetting setting;
    GdkEventGrabBroken grab_broken;
};

struct _GdkDisplayPointerHooks {
    void (* get_pointer)(GdkDisplay *, GdkScreen * *, gint *, gint *, enum GdkModifierType *);
    GdkWindow * (* window_get_pointer)(GdkDisplay *, GdkWindow *, gint *, gint *, enum GdkModifierType *);
    GdkWindow * (* window_at_pointer)(GdkDisplay *, gint *, gint *);
};

struct _GtkObjectClass {
    GInitiallyUnownedClass parent_class;
    void (* set_arg)(GtkObject *, GtkArg *, guint);
    void (* get_arg)(GtkObject *, GtkArg *, guint);
    void (* destroy)(GtkObject *);
};

struct _GtkWidgetClass {
    GtkObjectClass parent_class;
    guint activate_signal;
    guint set_scroll_adjustments_signal;
    void (* dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec * *);
    void (* show)(GtkWidget *);
    void (* show_all)(GtkWidget *);
    void (* hide)(GtkWidget *);
    void (* hide_all)(GtkWidget *);
    void (* map)(GtkWidget *);
    void (* unmap)(GtkWidget *);
    void (* realize)(GtkWidget *);
    void (* unrealize)(GtkWidget *);
    void (* size_request)(GtkWidget *, GtkRequisition *);
    void (* size_allocate)(GtkWidget *, GtkAllocation *);
    void (* state_changed)(GtkWidget *, enum GtkStateType);
    void (* parent_set)(GtkWidget *, GtkWidget *);
    void (* hierarchy_changed)(GtkWidget *, GtkWidget *);
    void (* style_set)(GtkWidget *, GtkStyle *);
    void (* direction_changed)(GtkWidget *, enum GtkTextDirection);
    void (* grab_notify)(GtkWidget *, gboolean);
    void (* child_notify)(GtkWidget *, GParamSpec *);
    gboolean (* mnemonic_activate)(GtkWidget *, gboolean);
    void (* grab_focus)(GtkWidget *);
    gboolean (* focus)(GtkWidget *, enum GtkDirectionType);
    gboolean (* event)(GtkWidget *, GdkEvent *);
    gboolean (* button_press_event)(GtkWidget *, GdkEventButton *);
    gboolean (* button_release_event)(GtkWidget *, GdkEventButton *);
    gboolean (* scroll_event)(GtkWidget *, GdkEventScroll *);
    gboolean (* motion_notify_event)(GtkWidget *, GdkEventMotion *);
    gboolean (* delete_event)(GtkWidget *, GdkEventAny *);
    gboolean (* destroy_event)(GtkWidget *, GdkEventAny *);
    gboolean (* expose_event)(GtkWidget *, GdkEventExpose *);
    gboolean (* key_press_event)(GtkWidget *, GdkEventKey *);
    gboolean (* key_release_event)(GtkWidget *, GdkEventKey *);
    gboolean (* enter_notify_event)(GtkWidget *, GdkEventCrossing *);
    gboolean (* leave_notify_event)(GtkWidget *, GdkEventCrossing *);
    gboolean (* configure_event)(GtkWidget *, GdkEventConfigure *);
    gboolean (* focus_in_event)(GtkWidget *, GdkEventFocus *);
    gboolean (* focus_out_event)(GtkWidget *, GdkEventFocus *);
    gboolean (* map_event)(GtkWidget *, GdkEventAny *);
    gboolean (* unmap_event)(GtkWidget *, GdkEventAny *);
    gboolean (* property_notify_event)(GtkWidget *, GdkEventProperty *);
    gboolean (* selection_clear_event)(GtkWidget *, GdkEventSelection *);
    gboolean (* selection_request_event)(GtkWidget *, GdkEventSelection *);
    gboolean (* selection_notify_event)(GtkWidget *, GdkEventSelection *);
    gboolean (* proximity_in_event)(GtkWidget *, GdkEventProximity *);
    gboolean (* proximity_out_event)(GtkWidget *, GdkEventProximity *);
    gboolean (* visibility_notify_event)(GtkWidget *, GdkEventVisibility *);
    gboolean (* client_event)(GtkWidget *, GdkEventClient *);
    gboolean (* no_expose_event)(GtkWidget *, GdkEventAny *);
    gboolean (* window_state_event)(GtkWidget *, GdkEventWindowState *);
    void (* selection_get)(GtkWidget *, GtkSelectionData *, guint, guint);
    void (* selection_received)(GtkWidget *, GtkSelectionData *, guint);
    void (* drag_begin)(GtkWidget *, GdkDragContext *);
    void (* drag_end)(GtkWidget *, GdkDragContext *);
    void (* drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint);
    void (* drag_data_delete)(GtkWidget *, GdkDragContext *);
    void (* drag_leave)(GtkWidget *, GdkDragContext *, guint);
    gboolean (* drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint);
    gboolean (* drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint);
    void (* drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint);
    gboolean (* popup_menu)(GtkWidget *);
    gboolean (* show_help)(GtkWidget *, enum GtkWidgetHelpType);
    AtkObject * (* get_accessible)(GtkWidget *);
    void (* screen_changed)(GtkWidget *, GdkScreen *);
    gboolean (* can_activate_accel)(GtkWidget *, guint);
    gboolean (* grab_broken_event)(GtkWidget *, GdkEventGrabBroken *);
    void (* composited_changed)(GtkWidget *);
    gboolean (* query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *);
    void (* _gtk_reserved5)(void);
    void (* _gtk_reserved6)(void);
    void (* _gtk_reserved7)(void);
};

struct _GdkDevice {
    GObject parent_instance;
    gchar * name;
    enum GdkInputSource source;
    enum GdkInputMode mode;
    gboolean has_cursor;
    gint num_axes;
    GdkDeviceAxis * axes;
    gint num_keys;
    GdkDeviceKey * keys;
};

struct _GdkRegion {
};

struct _GtkSelectionData {
    GdkAtom selection;
    GdkAtom target;
    GdkAtom type;
    gint format;
    guchar * data;
    gint length;
    GdkDisplay * display;
};

struct _GdkDeviceAxis {
    enum GdkAxisUse use;
    gdouble min;
    gdouble max;
};

typedef char * __gnuc_va_list;

typedef struct DBusConnection DBusConnection, *PDBusConnection;

struct DBusConnection {
};

typedef struct DBusTimeout DBusTimeout, *PDBusTimeout;

struct DBusTimeout {
};

typedef enum DBusDispatchStatus {
    DBUS_DISPATCH_DATA_REMAINS=0,
    DBUS_DISPATCH_COMPLETE=1,
    DBUS_DISPATCH_NEED_MEMORY=2
} DBusDispatchStatus;

typedef enum DBusHandlerResult {
    DBUS_HANDLER_RESULT_HANDLED=0,
    DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1,
    DBUS_HANDLER_RESULT_NEED_MEMORY=2
} DBusHandlerResult;

typedef struct DBusMessage DBusMessage, *PDBusMessage;

typedef DBusHandlerResult (* DBusObjectPathMessageFunction)(struct DBusConnection *, struct DBusMessage *, void *);

struct DBusMessage {
};

typedef struct DBusWatch DBusWatch, *PDBusWatch;

struct DBusWatch {
};

typedef struct DBusObjectPathVTable DBusObjectPathVTable, *PDBusObjectPathVTable;

typedef void (* DBusObjectPathUnregisterFunction)(struct DBusConnection *, void *);

struct DBusObjectPathVTable {
    DBusObjectPathUnregisterFunction unregister_function;
    DBusObjectPathMessageFunction message_function;
    void (* dbus_internal_pad1)(void *);
    void (* dbus_internal_pad2)(void *);
    void (* dbus_internal_pad3)(void *);
    void (* dbus_internal_pad4)(void *);
};

typedef struct _StringList _StringList, *P_StringList;

typedef struct _StringList StringList;

struct _StringList {
    char * str;
    struct _StringList * next;
};

typedef struct _BomList _BomList, *P_BomList;

struct _BomList {
    char * descr;
    char * value;
    int num;
    StringList * refdes;
    struct _BomList * next;
};

typedef struct _BomList BomList;

typedef guint32 gunichar;

typedef struct _GtkTextPendingScroll _GtkTextPendingScroll, *P_GtkTextPendingScroll;

typedef struct _GtkTextPendingScroll GtkTextPendingScroll;

struct _GtkTextPendingScroll {
};

typedef struct _GtkTextView _GtkTextView, *P_GtkTextView;

typedef struct _GtkTextLayout _GtkTextLayout, *P_GtkTextLayout;

typedef struct _GtkTextBuffer _GtkTextBuffer, *P_GtkTextBuffer;

typedef struct _GtkTextBuffer GtkTextBuffer;

typedef enum GtkWrapMode {
    GTK_WRAP_NONE=0,
    GTK_WRAP_CHAR=1,
    GTK_WRAP_WORD=2,
    GTK_WRAP_WORD_CHAR=3
} GtkWrapMode;

typedef enum GtkJustification {
    GTK_JUSTIFY_LEFT=0,
    GTK_JUSTIFY_RIGHT=1,
    GTK_JUSTIFY_CENTER=2,
    GTK_JUSTIFY_FILL=3
} GtkJustification;

typedef struct _PangoTabArray _PangoTabArray, *P_PangoTabArray;

typedef struct _PangoTabArray PangoTabArray;

typedef struct _GtkTextWindow _GtkTextWindow, *P_GtkTextWindow;

typedef struct _GtkTextWindow GtkTextWindow;

typedef struct _GtkAdjustment _GtkAdjustment, *P_GtkAdjustment;

typedef struct _GtkAdjustment GtkAdjustment;

typedef struct _GtkIMContext _GtkIMContext, *P_GtkIMContext;

typedef struct _GtkIMContext GtkIMContext;

typedef struct _GtkTextTagTable _GtkTextTagTable, *P_GtkTextTagTable;

typedef struct _GtkTextTagTable GtkTextTagTable;

typedef struct _GtkTextBTree _GtkTextBTree, *P_GtkTextBTree;

typedef struct _GtkTextBTree GtkTextBTree;

typedef struct _GtkTextLogAttrCache _GtkTextLogAttrCache, *P_GtkTextLogAttrCache;

typedef struct _GtkTextLogAttrCache GtkTextLogAttrCache;

typedef struct _GHashTable _GHashTable, *P_GHashTable;

typedef struct _GHashTable GHashTable;

struct _GHashTable {
};

struct _GtkTextView {
    GtkContainer parent_instance;
    struct _GtkTextLayout * layout;
    GtkTextBuffer * buffer;
    guint selection_drag_handler;
    guint scroll_timeout;
    gint pixels_above_lines;
    gint pixels_below_lines;
    gint pixels_inside_wrap;
    enum GtkWrapMode wrap_mode;
    enum GtkJustification justify;
    gint left_margin;
    gint right_margin;
    gint indent;
    PangoTabArray * tabs;
    guint editable:1;
    guint overwrite_mode:1;
    guint cursor_visible:1;
    guint need_im_reset:1;
    guint accepts_tab:1;
    guint width_changed:1;
    guint onscreen_validated:1;
    guint mouse_cursor_obscured:1;
    GtkTextWindow * text_window;
    GtkTextWindow * left_window;
    GtkTextWindow * right_window;
    GtkTextWindow * top_window;
    GtkTextWindow * bottom_window;
    GtkAdjustment * hadjustment;
    GtkAdjustment * vadjustment;
    gint xoffset;
    gint yoffset;
    gint width;
    gint height;
    gint virtual_cursor_x;
    gint virtual_cursor_y;
    GtkTextMark * first_para_mark;
    gint first_para_pixels;
    GtkTextMark * dnd_mark;
    guint blink_timeout;
    guint first_validate_idle;
    guint incremental_validate_idle;
    GtkIMContext * im_context;
    GtkWidget * popup_menu;
    gint drag_start_x;
    gint drag_start_y;
    GSList * children;
    GtkTextPendingScroll * pending_scroll;
    gint pending_place_cursor_button;
};

struct _GtkTextLogAttrCache {
};

struct _GtkTextBTree {
};

struct _GtkTextBuffer {
    GObject parent_instance;
    GtkTextTagTable * tag_table;
    GtkTextBTree * btree;
    GSList * clipboard_contents_buffers;
    GSList * selection_clipboards;
    GtkTextLogAttrCache * log_attr_cache;
    guint user_action_count;
    guint modified:1;
    guint has_selection:1;
};

struct _GtkTextTagTable {
    GObject parent_instance;
    GHashTable * hash;
    GSList * anonymous;
    gint anon_count;
    GSList * buffers;
};

struct _GtkTextLayout {
};

struct _GtkAdjustment {
    GtkObject parent_instance;
    gdouble lower;
    gdouble upper;
    gdouble value;
    gdouble step_increment;
    gdouble page_increment;
    gdouble page_size;
};

struct _GtkIMContext {
    GObject parent_instance;
};

struct _PangoTabArray {
};

struct _GtkTextWindow {
};

typedef enum GIOStatus {
    G_IO_STATUS_ERROR=0,
    G_IO_STATUS_NORMAL=1,
    G_IO_STATUS_EOF=2,
    G_IO_STATUS_AGAIN=3
} GIOStatus;

typedef struct _GIOChannel _GIOChannel, *P_GIOChannel;

typedef struct _GIOFuncs _GIOFuncs, *P_GIOFuncs;

typedef struct _GIOChannel GIOChannel;

typedef struct _GError _GError, *P_GError;

typedef struct _GError GError;

typedef enum GSeekType {
    G_SEEK_CUR=0,
    G_SEEK_SET=1,
    G_SEEK_END=2
} GSeekType;

typedef struct _GSource _GSource, *P_GSource;

typedef struct _GSource GSource;

typedef enum GIOCondition {
    G_IO_IN=1,
    G_IO_PRI=2,
    G_IO_OUT=4,
    G_IO_ERR=8,
    G_IO_HUP=16,
    G_IO_NVAL=32
} GIOCondition;

typedef enum GIOFlags {
    G_IO_FLAG_APPEND=1,
    G_IO_FLAG_NONBLOCK=2,
    G_IO_FLAG_SET_MASK=3,
    G_IO_FLAG_IS_READABLE=4,
    G_IO_FLAG_IS_WRITEABLE=8,
    G_IO_FLAG_IS_SEEKABLE=16,
    G_IO_FLAG_GET_MASK=31,
    G_IO_FLAG_MASK=31
} GIOFlags;

typedef struct _GIOFuncs GIOFuncs;

typedef struct _GIConv _GIConv, *P_GIConv;

typedef struct _GIConv * GIConv;

typedef struct _GString _GString, *P_GString;

typedef struct _GString GString;

typedef guint32 GQuark;

typedef struct _GSourceCallbackFuncs _GSourceCallbackFuncs, *P_GSourceCallbackFuncs;

typedef gboolean (* GSourceFunc)(gpointer);

typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;

typedef struct _GSourceFuncs _GSourceFuncs, *P_GSourceFuncs;

typedef struct _GSourceFuncs GSourceFuncs;

typedef struct _GMainContext _GMainContext, *P_GMainContext;

typedef struct _GMainContext GMainContext;

typedef void (* GSourceDummyMarshal)(void);

struct _GMainContext {
};

struct _GSourceFuncs {
    gboolean (* prepare)(GSource *, gint *);
    gboolean (* check)(GSource *);
    gboolean (* dispatch)(GSource *, GSourceFunc, gpointer);
    void (* finalize)(GSource *);
    GSourceFunc closure_callback;
    GSourceDummyMarshal closure_marshal;
};

struct _GSource {
    gpointer callback_data;
    GSourceCallbackFuncs * callback_funcs;
    GSourceFuncs * source_funcs;
    guint ref_count;
    GMainContext * context;
    gint priority;
    guint flags;
    guint source_id;
    GSList * poll_fds;
    GSource * prev;
    GSource * next;
    char * name;
    gpointer reserved2;
};

struct _GString {
    gchar * str;
    gsize len;
    gsize allocated_len;
};

struct _GIConv {
};

struct _GIOChannel {
    gint ref_count;
    GIOFuncs * funcs;
    gchar * encoding;
    GIConv read_cd;
    GIConv write_cd;
    gchar * line_term;
    guint line_term_len;
    gsize buf_size;
    GString * read_buf;
    GString * encoded_read_buf;
    GString * write_buf;
    gchar partial_write_buf[6];
    guint use_buffer:1;
    guint do_encode:1;
    guint close_on_unref:1;
    guint is_readable:1;
    guint is_writeable:1;
    guint is_seekable:1;
    gpointer reserved1;
    gpointer reserved2;
};

struct _GError {
    GQuark domain;
    gint code;
    gchar * message;
};

struct _GSourceCallbackFuncs {
    void (* ref)(gpointer);
    void (* unref)(gpointer);
    void (* get)(gpointer, GSource *, GSourceFunc *, gpointer *);
};

struct _GIOFuncs {
    GIOStatus (* io_read)(GIOChannel *, gchar *, gsize, gsize *, GError * *);
    GIOStatus (* io_write)(GIOChannel *, gchar *, gsize, gsize *, GError * *);
    GIOStatus (* io_seek)(GIOChannel *, gint64, enum GSeekType, GError * *);
    GIOStatus (* io_close)(GIOChannel *, GError * *);
    GSource * (* io_create_watch)(GIOChannel *, enum GIOCondition);
    void (* io_free)(GIOChannel *);
    GIOStatus (* io_set_flags)(GIOChannel *, enum GIOFlags, GError * *);
    GIOFlags (* io_get_flags)(GIOChannel *);
};

typedef struct _GtkPanedPrivate _GtkPanedPrivate, *P_GtkPanedPrivate;

typedef struct _GtkPanedPrivate GtkPanedPrivate;

struct _GtkPanedPrivate {
};

typedef struct _GtkPaned _GtkPaned, *P_GtkPaned;

typedef enum GdkCursorType {
    GDK_BLANK_CURSOR=-2,
    GDK_CURSOR_IS_PIXMAP=-1,
    GDK_X_CURSOR=0,
    GDK_ARROW=2,
    GDK_BASED_ARROW_DOWN=4,
    GDK_BASED_ARROW_UP=6,
    GDK_BOAT=8,
    GDK_BOGOSITY=10,
    GDK_BOTTOM_LEFT_CORNER=12,
    GDK_BOTTOM_RIGHT_CORNER=14,
    GDK_BOTTOM_SIDE=16,
    GDK_BOTTOM_TEE=18,
    GDK_BOX_SPIRAL=20,
    GDK_CENTER_PTR=22,
    GDK_CIRCLE=24,
    GDK_CLOCK=26,
    GDK_COFFEE_MUG=28,
    GDK_CROSS=30,
    GDK_CROSS_REVERSE=32,
    GDK_CROSSHAIR=34,
    GDK_DIAMOND_CROSS=36,
    GDK_DOT=38,
    GDK_DOTBOX=40,
    GDK_DOUBLE_ARROW=42,
    GDK_DRAFT_LARGE=44,
    GDK_DRAFT_SMALL=46,
    GDK_DRAPED_BOX=48,
    GDK_EXCHANGE=50,
    GDK_FLEUR=52,
    GDK_GOBBLER=54,
    GDK_GUMBY=56,
    GDK_HAND1=58,
    GDK_HAND2=60,
    GDK_HEART=62,
    GDK_ICON=64,
    GDK_IRON_CROSS=66,
    GDK_LEFT_PTR=68,
    GDK_LEFT_SIDE=70,
    GDK_LEFT_TEE=72,
    GDK_LEFTBUTTON=74,
    GDK_LL_ANGLE=76,
    GDK_LR_ANGLE=78,
    GDK_MAN=80,
    GDK_MIDDLEBUTTON=82,
    GDK_MOUSE=84,
    GDK_PENCIL=86,
    GDK_PIRATE=88,
    GDK_PLUS=90,
    GDK_QUESTION_ARROW=92,
    GDK_RIGHT_PTR=94,
    GDK_RIGHT_SIDE=96,
    GDK_RIGHT_TEE=98,
    GDK_RIGHTBUTTON=100,
    GDK_RTL_LOGO=102,
    GDK_SAILBOAT=104,
    GDK_SB_DOWN_ARROW=106,
    GDK_SB_H_DOUBLE_ARROW=108,
    GDK_SB_LEFT_ARROW=110,
    GDK_SB_RIGHT_ARROW=112,
    GDK_SB_UP_ARROW=114,
    GDK_SB_V_DOUBLE_ARROW=116,
    GDK_SHUTTLE=118,
    GDK_SIZING=120,
    GDK_SPIDER=122,
    GDK_SPRAYCAN=124,
    GDK_STAR=126,
    GDK_TARGET=128,
    GDK_TCROSS=130,
    GDK_TOP_LEFT_ARROW=132,
    GDK_TOP_LEFT_CORNER=134,
    GDK_TOP_RIGHT_CORNER=136,
    GDK_TOP_SIDE=138,
    GDK_TOP_TEE=140,
    GDK_TREK=142,
    GDK_UL_ANGLE=144,
    GDK_UMBRELLA=146,
    GDK_UR_ANGLE=148,
    GDK_WATCH=150,
    GDK_XTERM=152,
    GDK_LAST_CURSOR=153
} GdkCursorType;

struct _GtkPaned {
    GtkContainer container;
    GtkWidget * child1;
    GtkWidget * child2;
    GdkWindow * handle;
    GdkGC * xor_gc;
    enum GdkCursorType cursor_type;
    GdkRectangle handle_pos;
    gint child1_size;
    gint last_allocation;
    gint min_position;
    gint max_position;
    guint position_set:1;
    guint in_drag:1;
    guint child1_shrink:1;
    guint child1_resize:1;
    guint child2_shrink:1;
    guint child2_resize:1;
    guint orientation:1;
    guint in_recursion:1;
    guint handle_prelit:1;
    GtkWidget * last_child1_focus;
    GtkWidget * last_child2_focus;
    GtkPanedPrivate * priv;
    gint drag_pos;
    gint original_position;
};

typedef struct _GtkFrame _GtkFrame, *P_GtkFrame;

struct _GtkFrame {
    GtkBin bin;
    GtkWidget * label_widget;
    gint16 shadow_type;
    gfloat label_xalign;
    gfloat label_yalign;
    GtkAllocation child_allocation;
};

typedef struct re_pattern_buffer re_pattern_buffer, *Pre_pattern_buffer;

struct re_pattern_buffer {
    uchar * buffer;
    ulong allocated;
    ulong used;
    reg_syntax_t syntax;
    char * fastmap;
    uchar * translate;
    size_t re_nsub;
    uint can_be_null:1;
    uint regs_allocated:2;
    uint fastmap_accurate:1;
    uint no_sub:1;
    uint not_bol:1;
    uint not_eol:1;
    uint newline_anchor:1;
};

typedef struct re_pattern_buffer regex_t;

typedef struct regmatch_t regmatch_t, *Pregmatch_t;

struct regmatch_t {
    regoff_t rm_so;
    regoff_t rm_eo;
};

typedef struct BlockHookSource BlockHookSource, *PBlockHookSource;

typedef union hidval hidval, *Phidval;

union hidval {
    long lval;
    void * ptr;
};

struct BlockHookSource {
    GSource source;
    void (* func)(union hidval);
    union hidval user_data;
};

typedef struct GuiTimer GuiTimer, *PGuiTimer;

struct GuiTimer {
    void (* func)(...);
    gint id;
    union hidval user_data;
};

typedef struct GuiWatch GuiWatch, *PGuiWatch;

struct GuiWatch {
    void (* func)(union hidval, int, uint, union hidval);
    union hidval user_data;
    int fd;
    GIOChannel * channel;
    gint id;
};

typedef struct ColorCache ColorCache, *PColorCache;

struct ColorCache {
    int color_set;
    GdkColor color;
    int xor_set;
    GdkColor xor_color;
};

typedef struct RemovedPointType RemovedPointType, *PRemovedPointType;

struct RemovedPointType {
    LocationType X;
    LocationType Y;
    int ID;
    Cardinal Index;
};

typedef struct LayerChangeType LayerChangeType, *PLayerChangeType;

typedef struct LayerChangeType * LayerChangeTypePtr;

struct LayerChangeType {
    int old_index;
    int new_index;
};

typedef struct anon_struct_32_5_d864926b anon_struct_32_5_d864926b, *Panon_struct_32_5_d864926b;

typedef union anon_union_16_10_9c3cddba_for_Data anon_union_16_10_9c3cddba_for_Data, *Panon_union_16_10_9c3cddba_for_Data;

typedef struct ChangeNameType ChangeNameType, *PChangeNameType;

typedef struct MoveType MoveType, *PMoveType;

typedef struct RotateType RotateType, *PRotateType;

typedef struct MoveToLayerType MoveToLayerType, *PMoveToLayerType;

typedef struct ClearPolyType ClearPolyType, *PClearPolyType;

typedef struct NetlistChangeType NetlistChangeType, *PNetlistChangeType;

typedef struct LayerType LayerType, *PLayerType;

typedef struct LayerType * LayerTypePtr;

typedef struct LibraryType LibraryType, *PLibraryType;

typedef struct LibraryType * LibraryTypePtr;

typedef struct TextType TextType, *PTextType;

typedef struct TextType * TextTypePtr;

typedef struct polygon_st polygon_st, *Ppolygon_st;

typedef struct polygon_st * PolygonTypePtr;

typedef struct anon_struct_68_12_8c6602fc anon_struct_68_12_8c6602fc, *Panon_struct_68_12_8c6602fc;

typedef struct anon_struct_68_12_8c6602fc * ArcTypePtr;

typedef struct rtree rtree, *Prtree;

typedef struct rtree rtree_t;

typedef struct AttributeListType AttributeListType, *PAttributeListType;

typedef struct anon_struct_28_8_ad772bab * LibraryMenuTypePtr;

typedef struct POLYAREA POLYAREA, *PPOLYAREA;

typedef struct PLINE PLINE, *PPLINE;

typedef struct rtree_node rtree_node, *Prtree_node;

typedef struct AttributeType AttributeType, *PAttributeType;

typedef struct VNODE VNODE, *PVNODE;

typedef struct anon_struct_4_2_a79f57ee_for_Flags anon_struct_4_2_a79f57ee_for_Flags, *Panon_struct_4_2_a79f57ee_for_Flags;

typedef struct anon_struct_4_2_4fa06cb1_for_flags anon_struct_4_2_4fa06cb1_for_flags, *Panon_struct_4_2_4fa06cb1_for_flags;

typedef union anon_union_140_2_50bed805_for_u anon_union_140_2_50bed805_for_u, *Panon_union_140_2_50bed805_for_u;

typedef struct anon_struct_4_2_143986a6_for_Flags anon_struct_4_2_143986a6_for_Flags, *Panon_struct_4_2_143986a6_for_Flags;

typedef struct CVCList CVCList, *PCVCList;

typedef int vertex[2];

typedef vertex Vector;

typedef struct Rentry Rentry, *PRentry;

struct POLYAREA {
    struct POLYAREA * f;
    struct POLYAREA * b;
    struct PLINE * contours;
};

struct anon_struct_4_2_143986a6_for_Flags {
    uint status:3;
    uint mark:1;
};

struct anon_struct_4_2_4fa06cb1_for_flags {
    uint is_leaf:1;
    uint manage:31;
};

struct Rentry {
    struct BoxType * bptr;
    struct BoxType bounds;
};

union anon_union_140_2_50bed805_for_u {
    struct rtree_node * kids[7];
    struct Rentry rects[7];
};

struct rtree_node {
    struct BoxType box;
    struct rtree_node * parent;
    struct anon_struct_4_2_4fa06cb1_for_flags flags;
    union anon_union_140_2_50bed805_for_u u;
};

struct anon_struct_4_2_a79f57ee_for_Flags {
    uint status:3;
    uint orient:1;
};

struct VNODE {
    struct VNODE * next;
    struct VNODE * prev;
    struct VNODE * shared;
    struct anon_struct_4_2_143986a6_for_Flags Flags;
    struct CVCList * cvc_prev;
    struct CVCList * cvc_next;
    Vector point;
};

struct PLINE {
    int xmin;
    int ymin;
    int xmax;
    int ymax;
    struct PLINE * next;
    struct VNODE head;
    uint Count;
    double area;
    rtree_t * tree;
    struct anon_struct_4_2_a79f57ee_for_Flags Flags;
};

struct AttributeListType {
    int Number;
    int Max;
    struct AttributeType * List;
};

struct AttributeType {
    char * name;
    char * value;
};

struct RotateType {
    LocationType CenterX;
    LocationType CenterY;
    BYTE Steps;
};

struct MoveType {
    LocationType DX;
    LocationType DY;
};

struct ChangeNameType {
    char * Name;
};

struct MoveToLayerType {
    Cardinal OriginalLayer;
};

struct NetlistChangeType {
    LibraryTypePtr old;
    LibraryTypePtr lib;
};

struct ClearPolyType {
    Boolean Clear;
    LayerTypePtr Layer;
};

union anon_union_16_10_9c3cddba_for_Data {
    struct ChangeNameType ChangeName;
    struct MoveType Move;
    struct RemovedPointType RemovedPoint;
    struct RotateType Rotate;
    struct MoveToLayerType MoveToLayer;
    struct FlagType Flags;
    BDimension Size;
    struct LayerChangeType LayerChange;
    struct ClearPolyType ClearPoly;
    struct NetlistChangeType NetlistChange;
};

struct anon_struct_32_5_d864926b {
    int Serial;
    int Type;
    int Kind;
    int ID;
    union anon_union_16_10_9c3cddba_for_Data Data;
};

struct LibraryType {
    Cardinal MenuN;
    Cardinal MenuMax;
    LibraryMenuTypePtr Menu;
};

struct anon_struct_68_12_8c6602fc {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    LocationType Width;
    LocationType Height;
    LocationType X;
    LocationType Y;
    long StartAngle;
    long Delta;
};

struct rtree {
    struct rtree_node * root;
    int size;
};

struct TextType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Scale;
    LocationType X;
    LocationType Y;
    BYTE Direction;
    char * TextString;
    void * Element;
};

struct LayerType {
    char * Name;
    Cardinal LineN;
    Cardinal TextN;
    Cardinal PolygonN;
    Cardinal ArcN;
    Cardinal LineMax;
    Cardinal TextMax;
    Cardinal PolygonMax;
    Cardinal ArcMax;
    LineTypePtr Line;
    TextTypePtr Text;
    PolygonTypePtr Polygon;
    ArcTypePtr Arc;
    rtree_t * line_tree;
    rtree_t * text_tree;
    rtree_t * polygon_tree;
    rtree_t * arc_tree;
    Boolean On;
    char * Color;
    char * SelectedColor;
    struct AttributeListType Attributes;
};

struct polygon_st {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    Cardinal PointN;
    Cardinal PointMax;
    struct POLYAREA * Clipped;
    struct PLINE * NoHoles;
    int NoHolesValid;
    PointTypePtr Points;
};

struct CVCList {
    double angle;
    struct VNODE * parent;
    struct CVCList * prev;
    struct CVCList * next;
    struct CVCList * head;
    char poly;
    char side;
};

typedef struct NetlistChangeType * NetlistChangeTypePtr;

typedef struct anon_struct_32_5_d864926b * UndoListTypePtr;

typedef struct _GtsVertex _GtsVertex, *P_GtsVertex;

typedef struct _GtsVertex GtsVertex;

typedef struct _GtsPoint _GtsPoint, *P_GtsPoint;

typedef struct _GtsPoint GtsPoint;

typedef struct _GtsObject _GtsObject, *P_GtsObject;

typedef struct _GtsObject GtsObject;

typedef struct _GtsObjectClass _GtsObjectClass, *P_GtsObjectClass;

typedef struct _GtsFile _GtsFile, *P_GtsFile;

typedef struct _GtsFile GtsFile;


// WARNING! conflicting data type names: /DWARF/stdio.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct _IO_FILE FILE;

typedef struct _GtsColor _GtsColor, *P_GtsColor;

typedef struct _GtsColor GtsColor;

typedef struct _GtsObjectClass GtsObjectClass;

typedef struct _GtsObjectClassInfo _GtsObjectClassInfo, *P_GtsObjectClassInfo;

typedef struct _GtsObjectClassInfo GtsObjectClassInfo;

typedef enum GtsTokenType {
    GTS_NONE=256,
    GTS_INT=512,
    GTS_UINT=1024,
    GTS_FLOAT=2048,
    GTS_DOUBLE=4096,
    GTS_STRING=8192,
    GTS_FILE=16384,
    GTS_ERROR=32768
} GtsTokenType;

typedef void (* GtsObjectClassInitFunc)(GtsObjectClass *);

typedef void (* GtsObjectInitFunc)(GtsObject *);

typedef void (* GtsArgSetFunc)(GtsObject *);

typedef void (* GtsArgGetFunc)(GtsObject *);

struct _GtsObject {
    GtsObjectClass * klass;
    gpointer reserved;
    guint32 flags;
};

struct _GtsPoint {
    GtsObject object;
    gdouble x;
    gdouble y;
    gdouble z;
};

struct _GtsColor {
    gfloat r;
    gfloat g;
    gfloat b;
};

struct _GtsObjectClassInfo {
    gchar name[40];
    guint object_size;
    guint class_size;
    GtsObjectClassInitFunc class_init_func;
    GtsObjectInitFunc object_init_func;
    GtsArgSetFunc arg_set_func;
    GtsArgGetFunc arg_get_func;
};

struct _GtsObjectClass {
    GtsObjectClassInfo info;
    GtsObjectClass * parent_class;
    void (* clone)(GtsObject *, GtsObject *);
    void (* destroy)(GtsObject *);
    void (* read)(GtsObject * *, GtsFile *);
    void (* write)(GtsObject *, FILE *);
    GtsColor (* color)(GtsObject *);
    void (* attributes)(GtsObject *, GtsObject *);
};

struct _GtsFile {
    FILE * fp;
    gchar * s;
    gchar * s1;
    guint line;
    guint pos;
    GString * token;
    enum GtsTokenType type;
    gchar * error;
    guint curline;
    guint curpos;
    guint scope;
    guint scope_max;
    gint next_token;
    gchar * delimiters;
    gchar * comments;
    gchar * tokens;
};

struct _GtsVertex {
    GtsPoint p;
    GSList * segments;
};

typedef GtsPoint * (* GtsBBoxClosestFunc)(GtsPoint *, gpointer);

typedef gdouble GtsVector4[4];

typedef GtsVector4 GtsMatrix;

typedef struct _GtsSurface _GtsSurface, *P_GtsSurface;

typedef struct _GtsSurface GtsSurface;

typedef struct _GtsFaceClass _GtsFaceClass, *P_GtsFaceClass;

typedef struct _GtsFaceClass GtsFaceClass;

typedef struct _GtsEdgeClass _GtsEdgeClass, *P_GtsEdgeClass;

typedef struct _GtsEdgeClass GtsEdgeClass;

typedef struct _GtsVertexClass _GtsVertexClass, *P_GtsVertexClass;

typedef struct _GtsVertexClass GtsVertexClass;

typedef struct _GtsTriangleClass _GtsTriangleClass, *P_GtsTriangleClass;

typedef struct _GtsTriangleClass GtsTriangleClass;

typedef struct _GtsSegmentClass _GtsSegmentClass, *P_GtsSegmentClass;

typedef struct _GtsSegmentClass GtsSegmentClass;

typedef struct _GtsPointClass _GtsPointClass, *P_GtsPointClass;

typedef struct _GtsPointClass GtsPointClass;

struct _GtsTriangleClass {
    GtsObjectClass parent_class;
};

struct _GtsFaceClass {
    GtsTriangleClass parent_class;
};

struct _GtsPointClass {
    GtsObjectClass parent_class;
    gboolean binary;
};

struct _GtsVertexClass {
    GtsPointClass parent_class;
    void (* intersection_attributes)(GtsVertex *, GtsObject *, GtsObject *);
};

struct _GtsSurface {
    GtsObject object;
    GHashTable * faces;
    GtsFaceClass * face_class;
    GtsEdgeClass * edge_class;
    GtsVertexClass * vertex_class;
    gboolean keep_faces;
};

struct _GtsSegmentClass {
    GtsObjectClass parent_class;
};

struct _GtsEdgeClass {
    GtsSegmentClass parent_class;
};

typedef gdouble GtsVector[3];

typedef struct _GtsFileVariable _GtsFileVariable, *P_GtsFileVariable;

typedef struct _GtsFileVariable GtsFileVariable;

struct _GtsFileVariable {
    enum GtsTokenType type;
    gchar name[30];
    gboolean unique;
    gpointer data;
    gboolean set;
    guint line;
    guint pos;
};

typedef struct _GtsTriangle _GtsTriangle, *P_GtsTriangle;

typedef struct _GtsEdge _GtsEdge, *P_GtsEdge;

typedef struct _GtsEdge GtsEdge;

typedef struct _GtsSegment _GtsSegment, *P_GtsSegment;

typedef struct _GtsSegment GtsSegment;

struct _GtsTriangle {
    GtsObject object;
    GtsEdge * e1;
    GtsEdge * e2;
    GtsEdge * e3;
};

struct _GtsSegment {
    GtsObject object;
    GtsVertex * v1;
    GtsVertex * v2;
};

struct _GtsEdge {
    GtsSegment segment;
    GSList * triangles;
};

typedef struct _GtsEHeapPair _GtsEHeapPair, *P_GtsEHeapPair;

struct _GtsEHeapPair {
    gpointer data;
    gdouble key;
    guint pos;
};

typedef struct _GtsSurfaceClass _GtsSurfaceClass, *P_GtsSurfaceClass;

typedef struct _GtsFace _GtsFace, *P_GtsFace;

typedef struct _GtsFace GtsFace;

typedef struct _GtsSurfaceClass GtsSurfaceClass;

typedef struct _GtsTriangle GtsTriangle;

struct _GtsFace {
    GtsTriangle triangle;
    GSList * surfaces;
};

struct _GtsSurfaceClass {
    GtsObjectClass parent_class;
    void (* add_face)(GtsSurface *, GtsFace *);
    void (* remove_face)(GtsSurface *, GtsFace *);
};

typedef struct _GtsConstraintClass _GtsConstraintClass, *P_GtsConstraintClass;

struct _GtsConstraintClass {
    GtsEdgeClass parent_class;
};

typedef struct _GtsSurfaceTraverse _GtsSurfaceTraverse, *P_GtsSurfaceTraverse;

typedef struct _GtsSurfaceTraverse GtsSurfaceTraverse;

typedef struct _GtsFifo _GtsFifo, *P_GtsFifo;

typedef struct _GtsFifo GtsFifo;

struct _GtsSurfaceTraverse {
    GtsFifo * q;
    GtsSurface * s;
};

struct _GtsFifo {
    GList * head;
    GList * tail;
};

typedef struct _GtsRange _GtsRange, *P_GtsRange;

typedef struct _GtsRange GtsRange;

struct _GtsRange {
    gdouble min;
    gdouble max;
    gdouble sum;
    gdouble sum2;
    gdouble mean;
    gdouble stddev;
    guint n;
};

typedef struct _GtsSurfaceStats _GtsSurfaceStats, *P_GtsSurfaceStats;

typedef struct _GtsSurfaceStats GtsSurfaceStats;

struct _GtsSurfaceStats {
    guint n_faces;
    guint n_incompatible_faces;
    guint n_duplicate_faces;
    guint n_duplicate_edges;
    guint n_boundary_edges;
    guint n_non_manifold_edges;
    GtsRange edges_per_vertex;
    GtsRange faces_per_edge;
    GtsSurface * parent;
};

typedef struct _GtsListFace _GtsListFace, *P_GtsListFace;

typedef struct _GtsListFace GtsListFace;

struct _GtsListFace {
    GtsFace parent;
    GSList * points;
};

typedef gdouble (* GtsBBoxDistFunc)(GtsPoint *, gpointer);

typedef struct _GtsBBox _GtsBBox, *P_GtsBBox;

struct _GtsBBox {
    GtsObject object;
    gpointer bounded;
    gdouble x1;
    gdouble y1;
    gdouble z1;
    gdouble x2;
    gdouble y2;
    gdouble z2;
};

typedef struct _GtsSurfaceQualityStats _GtsSurfaceQualityStats, *P_GtsSurfaceQualityStats;

struct _GtsSurfaceQualityStats {
    GtsRange face_quality;
    GtsRange face_area;
    GtsRange edge_length;
    GtsRange edge_angle;
    GtsSurface * parent;
};

typedef struct _GtsEHeapPair GtsEHeapPair;

typedef struct _GtsBBox GtsBBox;

typedef gboolean (* GtsStopFunc)(gdouble, guint, gpointer);

typedef struct _GtsConstraintClass GtsConstraintClass;

typedef struct _GtsEHeap _GtsEHeap, *P_GtsEHeap;

typedef struct _GtsEHeap GtsEHeap;

typedef gdouble (* GtsKeyFunc)(gpointer, gpointer);

struct _GtsEHeap {
    GPtrArray * elts;
    GtsKeyFunc func;
    gpointer data;
    gboolean frozen;
    gboolean randomized;
};

typedef struct _GtsConstraint _GtsConstraint, *P_GtsConstraint;

typedef struct _GtsConstraint GtsConstraint;

struct _GtsConstraint {
    GtsEdge edge;
};

typedef GtsVertex * (* GtsCoarsenFunc)(GtsEdge *, GtsVertexClass *, gpointer);

typedef struct _GtsBBoxClass _GtsBBoxClass, *P_GtsBBoxClass;

typedef struct _GtsBBoxClass GtsBBoxClass;

struct _GtsBBoxClass {
    GtsObjectClass parent_class;
};

typedef gint (* GtsFunc)(gpointer, gpointer);

typedef struct _GtsVertexNormal _GtsVertexNormal, *P_GtsVertexNormal;

struct _GtsVertexNormal {
    GtsVertex parent;
    GtsVector n;
};

typedef void (* GtsBBTreeTraverseFunc)(GtsBBox *, GtsBBox *, gpointer);

typedef GtsVertex * (* GtsRefineFunc)(GtsEdge *, GtsVertexClass *, gpointer);

typedef enum GtsIntersect {
    GTS_OUT=-1,
    GTS_ON=0,
    GTS_IN=1
} GtsIntersect;

typedef struct _GtsSurfaceQualityStats GtsSurfaceQualityStats;


// WARNING! conflicting data type names: /DWARF/libio.h/_IO_marker - /libio.h/_IO_marker

typedef struct DBusError DBusError, *PDBusError;

struct DBusError {
    char * name;
    char * message;
    uint dummy1:1;
    uint dummy2:1;
    uint dummy3:1;
    uint dummy4:1;
    uint dummy5:1;
    void * padding1;
};

typedef struct _GhidPinoutPreviewClass _GhidPinoutPreviewClass, *P_GhidPinoutPreviewClass;

typedef struct _GtkDrawingAreaClass _GtkDrawingAreaClass, *P_GtkDrawingAreaClass;

typedef struct _GtkDrawingAreaClass GtkDrawingAreaClass;

struct _GtkDrawingAreaClass {
    GtkWidgetClass parent_class;
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

struct _GhidPinoutPreviewClass {
    GtkDrawingAreaClass parent_class;
};

typedef struct _GhidPinoutPreviewClass GhidPinoutPreviewClass;

typedef struct _GhidPinoutPreview _GhidPinoutPreview, *P_GhidPinoutPreview;

typedef struct _GtkDrawingArea _GtkDrawingArea, *P_GtkDrawingArea;

typedef struct _GtkDrawingArea GtkDrawingArea;

typedef struct ElementType ElementType, *PElementType;

typedef struct anon_struct_76_14_398d8f56 anon_struct_76_14_398d8f56, *Panon_struct_76_14_398d8f56;

typedef struct anon_struct_76_14_398d8f56 * PinTypePtr;

typedef struct anon_struct_104_13_b50cebd7 anon_struct_104_13_b50cebd7, *Panon_struct_104_13_b50cebd7;

typedef struct anon_struct_104_13_b50cebd7 * PadTypePtr;

struct _GtkDrawingArea {
    GtkWidget widget;
    gpointer draw_data;
};

struct anon_struct_76_14_398d8f56 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    BDimension Mask;
    BDimension DrillingHole;
    LocationType X;
    LocationType Y;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

struct anon_struct_104_13_b50cebd7 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    BDimension Mask;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

struct ElementType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    PinTypePtr Pin;
    PadTypePtr Pad;
    LineTypePtr Line;
    ArcTypePtr Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

struct _GhidPinoutPreview {
    GtkDrawingArea parent_instance;
    struct ElementType element;
    gfloat zoom;
    gfloat scale;
    gint x_max;
    gint y_max;
    gint w_pixels;
    gint h_pixels;
};

typedef struct _GhidPinoutPreview GhidPinoutPreview;

typedef struct vector_struct vector_struct, *Pvector_struct;

typedef struct vector_struct vector_t;

typedef void * vector_element_t;

struct vector_struct {
    vector_element_t * element;
    int size;
    int max;
};

typedef struct _TimeoutHandler _TimeoutHandler, *P_TimeoutHandler;

typedef struct _TimeoutHandler TimeoutHandler;

struct _TimeoutHandler {
    struct DBusTimeout * dbus_timeout;
    union hidval pcb_timer;
    int interval;
};

typedef struct _IOWatchHandler _IOWatchHandler, *P_IOWatchHandler;

typedef struct _IOWatchHandler IOWatchHandler;

struct _IOWatchHandler {
    struct DBusWatch * dbus_watch;
    union hidval pcb_watch;
};

typedef struct HID_ActionContext HID_ActionContext, *PHID_ActionContext;

typedef struct HID_Action HID_Action, *PHID_Action;

struct HID_Action {
    char * name;
    char * need_coord_msg;
    int (* trigger_cb)(int, char * *, int, int);
    char * description;
    char * syntax;
};

struct HID_ActionContext {
    struct HID_Action action;
    void * context;
};

typedef struct HID_ActionNode HID_ActionNode, *PHID_ActionNode;

struct HID_ActionNode {
    struct HID_ActionNode * next;
    struct HID_Action * actions;
    int n;
    void * context;
    int dynamic;
};

typedef union yyalloc.conflict yyalloc.conflict, *Pyyalloc.conflict;

typedef union YYSTYPE.conflict YYSTYPE.conflict, *PYYSTYPE.conflict;

union YYSTYPE.conflict {
    int number;
    float floating;
    char * string;
    struct FlagType flagtype;
};

union yyalloc.conflict {
    yytype_int16 yyss;
    union YYSTYPE.conflict yyvs;
};

typedef struct _GtkWindowClass _GtkWindowClass, *P_GtkWindowClass;

typedef struct _GtkBinClass _GtkBinClass, *P_GtkBinClass;

typedef struct _GtkBinClass GtkBinClass;

typedef struct _GtkContainerClass _GtkContainerClass, *P_GtkContainerClass;

typedef struct _GtkContainerClass GtkContainerClass;

struct _GtkContainerClass {
    GtkWidgetClass parent_class;
    void (* add)(GtkContainer *, GtkWidget *);
    void (* remove)(GtkContainer *, GtkWidget *);
    void (* check_resize)(GtkContainer *);
    void (* forall)(GtkContainer *, gboolean, GtkCallback, gpointer);
    void (* set_focus_child)(GtkContainer *, GtkWidget *);
    GType (* child_type)(GtkContainer *);
    gchar * (* composite_name)(GtkContainer *, GtkWidget *);
    void (* set_child_property)(GtkContainer *, GtkWidget *, guint, GValue *, GParamSpec *);
    void (* get_child_property)(GtkContainer *, GtkWidget *, guint, GValue *, GParamSpec *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

struct _GtkBinClass {
    GtkContainerClass parent_class;
};

struct _GtkWindowClass {
    GtkBinClass parent_class;
    void (* set_focus)(GtkWindow *, GtkWidget *);
    gboolean (* frame_event)(GtkWindow *, GdkEvent *);
    void (* activate_focus)(GtkWindow *);
    void (* activate_default)(GtkWindow *);
    void (* move_focus)(GtkWindow *, enum GtkDirectionType);
    void (* keys_changed)(GtkWindow *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

typedef struct _GtkWindowClass GtkWindowClass;

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};


// WARNING! conflicting data type names: /DWARF/time.h/timespec - /time.h/timespec

typedef __time_t time_t;

typedef struct _GtkScale _GtkScale, *P_GtkScale;

typedef struct _GtkRange _GtkRange, *P_GtkRange;

typedef struct _GtkRange GtkRange;

typedef enum GtkUpdateType {
    GTK_UPDATE_CONTINUOUS=0,
    GTK_UPDATE_DISCONTINUOUS=1,
    GTK_UPDATE_DELAYED=2
} GtkUpdateType;

typedef enum GtkOrientation {
    GTK_ORIENTATION_HORIZONTAL=0,
    GTK_ORIENTATION_VERTICAL=1
} GtkOrientation;

typedef struct _GtkRangeLayout _GtkRangeLayout, *P_GtkRangeLayout;

typedef struct _GtkRangeLayout GtkRangeLayout;

typedef struct _GtkRangeStepTimer _GtkRangeStepTimer, *P_GtkRangeStepTimer;

typedef struct _GtkRangeStepTimer GtkRangeStepTimer;

struct _GtkRange {
    GtkWidget widget;
    GtkAdjustment * adjustment;
    enum GtkUpdateType update_policy;
    guint inverted:1;
    guint flippable:1;
    guint has_stepper_a:1;
    guint has_stepper_b:1;
    guint has_stepper_c:1;
    guint has_stepper_d:1;
    guint need_recalc:1;
    guint slider_size_fixed:1;
    gint min_slider_size;
    enum GtkOrientation orientation;
    GdkRectangle range_rect;
    gint slider_start;
    gint slider_end;
    gint round_digits;
    guint trough_click_forward:1;
    guint update_pending:1;
    GtkRangeLayout * layout;
    GtkRangeStepTimer * timer;
    gint slide_initial_slider_position;
    gint slide_initial_coordinate;
    guint update_timeout_id;
    GdkWindow * event_window;
};

struct _GtkScale {
    GtkRange range;
    gint digits;
    guint draw_value:1;
    guint value_pos:2;
};

struct _GtkRangeLayout {
};

struct _GtkRangeStepTimer {
};

typedef struct _GtkScrolledWindow _GtkScrolledWindow, *P_GtkScrolledWindow;

struct _GtkScrolledWindow {
    GtkBin container;
    GtkWidget * hscrollbar;
    GtkWidget * vscrollbar;
    guint hscrollbar_policy:2;
    guint vscrollbar_policy:2;
    guint hscrollbar_visible:1;
    guint vscrollbar_visible:1;
    guint window_placement:2;
    guint focus_out:1;
    guint16 shadow_type;
};

typedef struct _GtkTable _GtkTable, *P_GtkTable;

typedef struct _GtkTableRowCol _GtkTableRowCol, *P_GtkTableRowCol;

typedef struct _GtkTableRowCol GtkTableRowCol;

struct _GtkTable {
    GtkContainer container;
    GList * children;
    GtkTableRowCol * rows;
    GtkTableRowCol * cols;
    guint16 nrows;
    guint16 ncols;
    guint16 column_spacing;
    guint16 row_spacing;
    guint homogeneous:1;
};

struct _GtkTableRowCol {
    guint16 requisition;
    guint16 allocation;
    guint16 spacing;
    guint need_expand:1;
    guint need_shrink:1;
    guint expand:1;
    guint shrink:1;
    guint empty:1;
};

typedef struct _GtkToggleButton _GtkToggleButton, *P_GtkToggleButton;

typedef struct _GtkToggleButton GtkToggleButton;

struct _GtkToggleButton {
    GtkButton button;
    guint active:1;
    guint draw_indicator:1;
    guint inconsistent:1;
};

typedef struct _GtkTreePath _GtkTreePath, *P_GtkTreePath;

typedef struct _GtkTreePath GtkTreePath;

struct _GtkTreePath {
};

typedef struct _GtkTreeModel _GtkTreeModel, *P_GtkTreeModel;

typedef struct _GtkTreeModel GtkTreeModel;

struct _GtkTreeModel {
};

typedef struct _GtkTreeRowReference _GtkTreeRowReference, *P_GtkTreeRowReference;

typedef struct _GtkTreeRowReference GtkTreeRowReference;

struct _GtkTreeRowReference {
};

typedef struct _GtkToggleActionPrivate _GtkToggleActionPrivate, *P_GtkToggleActionPrivate;

typedef struct _GtkToggleActionPrivate GtkToggleActionPrivate;

struct _GtkToggleActionPrivate {
};

typedef struct _GtkToggleAction _GtkToggleAction, *P_GtkToggleAction;

typedef struct _GtkAction _GtkAction, *P_GtkAction;

typedef struct _GtkAction GtkAction;

typedef struct _GtkActionPrivate _GtkActionPrivate, *P_GtkActionPrivate;

typedef struct _GtkActionPrivate GtkActionPrivate;

struct _GtkAction {
    GObject object;
    GtkActionPrivate * private_data;
};

struct _GtkActionPrivate {
};

struct _GtkToggleAction {
    GtkAction parent;
    GtkToggleActionPrivate * private_data;
};

typedef struct _GtkToggleAction GtkToggleAction;

typedef struct _GtkTreeView _GtkTreeView, *P_GtkTreeView;

typedef struct _GtkTreeViewPrivate _GtkTreeViewPrivate, *P_GtkTreeViewPrivate;

typedef struct _GtkTreeViewPrivate GtkTreeViewPrivate;

struct _GtkTreeViewPrivate {
};

struct _GtkTreeView {
    GtkContainer parent;
    GtkTreeViewPrivate * priv;
};

typedef struct _GtkTreeView GtkTreeView;

typedef struct _GtkTreeSelection _GtkTreeSelection, *P_GtkTreeSelection;

typedef enum GtkSelectionMode {
    GTK_SELECTION_NONE=0,
    GTK_SELECTION_SINGLE=1,
    GTK_SELECTION_BROWSE=2,
    GTK_SELECTION_EXTENDED=3,
    GTK_SELECTION_MULTIPLE=3
} GtkSelectionMode;

typedef struct _GtkTreeSelection GtkTreeSelection;

typedef gboolean (* GtkTreeSelectionFunc)(GtkTreeSelection *, GtkTreeModel *, GtkTreePath *, gboolean, gpointer);

typedef void (* GDestroyNotify)(gpointer);

struct _GtkTreeSelection {
    GObject parent;
    GtkTreeView * tree_view;
    enum GtkSelectionMode type;
    GtkTreeSelectionFunc user_func;
    gpointer user_data;
    GDestroyNotify destroy;
};

typedef struct cheap_point cheap_point, *Pcheap_point;

typedef struct cheap_point CheapPointType;

struct cheap_point {
    LocationType X;
    LocationType Y;
};

typedef enum direction_t {
    NORTH=0,
    EAST=1,
    SOUTH=2,
    WEST=3,
    NE=4,
    SE=5,
    SW=6,
    NW=7,
    ALL=8
} direction_t;

typedef struct cpInfo cpInfo, *PcpInfo;

typedef struct DataType DataType, *PDataType;

typedef struct polygon_st PolygonType;

typedef struct anon_struct_300_21_d5c1b8b3 anon_struct_300_21_d5c1b8b3, *Panon_struct_300_21_d5c1b8b3;

typedef struct anon_struct_300_21_d5c1b8b3 * ElementTypePtr;

typedef struct anon_struct_92_10_e5772304 anon_struct_92_10_e5772304, *Panon_struct_92_10_e5772304;

typedef struct anon_struct_92_10_e5772304 * RatTypePtr;

typedef struct PCBType PCBType, *PPCBType;

typedef struct FontType FontType, *PFontType;

typedef struct LayerGroupType LayerGroupType, *PLayerGroupType;

typedef struct RouteStyleType RouteStyleType, *PRouteStyleType;

typedef struct anon_struct_1732_18_8225347a anon_struct_1732_18_8225347a, *Panon_struct_1732_18_8225347a;

typedef struct anon_struct_1732_18_8225347a * DataTypePtr;

typedef struct SymbolType SymbolType, *PSymbolType;

struct cpInfo {
    struct BoxType * other;
    struct DataType * data;
    struct LayerType * layer;
    PolygonType * polygon;
    Boolean solder;
    jmp_buf env;
};

struct anon_struct_300_21_d5c1b8b3 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    PinTypePtr Pin;
    PadTypePtr Pad;
    LineTypePtr Line;
    ArcTypePtr Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

struct RouteStyleType {
    BDimension Thick;
    BDimension Diameter;
    BDimension Hole;
    BDimension Keepaway;
    char * Name;
    int index;
};

struct anon_struct_92_10_e5772304 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    Cardinal group1;
    Cardinal group2;
};

struct LayerGroupType {
    Cardinal Number[16];
    Cardinal Entries[16][18];
};

struct SymbolType {
    LineTypePtr Line;
    Boolean Valid;
    Cardinal LineN;
    Cardinal LineMax;
    BDimension Width;
    BDimension Height;
    BDimension Delta;
};

struct FontType {
    LocationType MaxHeight;
    LocationType MaxWidth;
    struct BoxType DefaultSymbol;
    struct SymbolType Symbol[256];
    Boolean Valid;
};

struct PCBType {
    long ID;
    struct FlagType Flags;
    char * Name;
    char * Filename;
    char * PrintFilename;
    char * Netlistname;
    char ThermStyle;
    Boolean Changed;
    Boolean ViaOn;
    Boolean ElementOn;
    Boolean RatOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean SilkActive;
    Boolean RatDraw;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * WarnColor;
    char * MaskColor;
    long CursorX;
    long CursorY;
    long Clipping;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    int GridOffsetX;
    int GridOffsetY;
    int MaxWidth;
    int MaxHeight;
    double Grid;
    double Zoom;
    double IsleArea;
    double ThermScale;
    struct FontType Font;
    struct LayerGroupType LayerGroups;
    struct RouteStyleType RouteStyle[4];
    struct LibraryType NetlistLib;
    struct AttributeListType Attributes;
    DataTypePtr Data;
};

struct DataType {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    PinTypePtr Via;
    ElementTypePtr Element;
    RatTypePtr Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType Layer[18];
};

struct anon_struct_1732_18_8225347a {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    PinTypePtr Via;
    ElementTypePtr Element;
    RatTypePtr Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType Layer[18];
};

typedef struct plow_info plow_info, *Pplow_info;

struct plow_info {
    int type;
    void * ptr1;
    void * ptr2;
    LayerTypePtr layer;
    DataTypePtr data;
    int (* callback)(DataTypePtr, LayerTypePtr, PolygonTypePtr, int, void *, void *);
};


// WARNING! conflicting data type names: /DWARF/report.c/ReportAllNetLengths/anon_enum_32 - /DWARF/hid.h/anon_enum_32

typedef void (* GBaseFinalizeFunc)(gpointer);

typedef struct _GTypeValueTable _GTypeValueTable, *P_GTypeValueTable;

typedef union _GTypeCValue _GTypeCValue, *P_GTypeCValue;

typedef union _GTypeCValue GTypeCValue;

struct _GTypeValueTable {
    void (* value_init)(GValue *);
    void (* value_free)(GValue *);
    void (* value_copy)(GValue *, GValue *);
    gpointer (* value_peek_pointer)(GValue *);
    gchar * collect_format;
    gchar * (* collect_value)(GValue *, guint, GTypeCValue *, guint);
    gchar * lcopy_format;
    gchar * (* lcopy_value)(GValue *, guint, GTypeCValue *, guint);
};

union _GTypeCValue {
};

typedef struct _GTypeValueTable GTypeValueTable;

typedef void (* GClassFinalizeFunc)(gpointer, gpointer);

typedef struct _GTypeInfo _GTypeInfo, *P_GTypeInfo;

typedef struct _GTypeInfo GTypeInfo;

typedef void (* GBaseInitFunc)(gpointer);

typedef void (* GClassInitFunc)(gpointer, gpointer);

typedef void * gconstpointer;

typedef void (* GInstanceInitFunc)(GTypeInstance *, gpointer);

struct _GTypeInfo {
    guint16 class_size;
    GBaseInitFunc base_init;
    GBaseFinalizeFunc base_finalize;
    GClassInitFunc class_init;
    GClassFinalizeFunc class_finalize;
    gconstpointer class_data;
    guint16 instance_size;
    guint16 n_preallocs;
    GInstanceInitFunc instance_init;
    GTypeValueTable * value_table;
};

typedef struct _GtkRadioAction _GtkRadioAction, *P_GtkRadioAction;

typedef struct _GtkRadioActionPrivate _GtkRadioActionPrivate, *P_GtkRadioActionPrivate;

typedef struct _GtkRadioActionPrivate GtkRadioActionPrivate;

struct _GtkRadioActionPrivate {
};

struct _GtkRadioAction {
    GtkToggleAction parent;
    GtkRadioActionPrivate * private_data;
};

typedef struct _GtkRadioAction GtkRadioAction;

typedef struct drc_info drc_info, *Pdrc_info;

struct drc_info {
    LineTypePtr line;
    Boolean solder;
    jmp_buf env;
};

typedef struct _GMainLoop _GMainLoop, *P_GMainLoop;

typedef struct _GMainLoop GMainLoop;

struct _GMainLoop {
};

typedef struct _GtkToggleActionEntry _GtkToggleActionEntry, *P_GtkToggleActionEntry;

typedef struct _GtkToggleActionEntry GtkToggleActionEntry;

struct _GtkToggleActionEntry {
    gchar * name;
    gchar * stock_id;
    gchar * label;
    gchar * accelerator;
    gchar * tooltip;
    GCallback callback;
    gboolean is_active;
};

typedef struct _GtkActionGroup _GtkActionGroup, *P_GtkActionGroup;

typedef struct _GtkActionGroupPrivate _GtkActionGroupPrivate, *P_GtkActionGroupPrivate;

typedef struct _GtkActionGroupPrivate GtkActionGroupPrivate;

struct _GtkActionGroup {
    GObject parent;
    GtkActionGroupPrivate * private_data;
};

struct _GtkActionGroupPrivate {
};

typedef struct _GtkRadioActionEntry _GtkRadioActionEntry, *P_GtkRadioActionEntry;

typedef struct _GtkRadioActionEntry GtkRadioActionEntry;

struct _GtkRadioActionEntry {
    gchar * name;
    gchar * stock_id;
    gchar * label;
    gchar * accelerator;
    gchar * tooltip;
    gint value;
};

typedef struct _GtkActionEntry _GtkActionEntry, *P_GtkActionEntry;

struct _GtkActionEntry {
    gchar * name;
    gchar * stock_id;
    gchar * label;
    gchar * accelerator;
    gchar * tooltip;
    GCallback callback;
};

typedef struct _GtkActionGroup GtkActionGroup;

typedef struct _GtkActionEntry GtkActionEntry;

typedef struct ghid_file_history_struct ghid_file_history_struct, *Pghid_file_history_struct;

typedef struct ghid_file_history_struct ghid_file_history;

struct ghid_file_history_struct {
    char * id;
    char * history[8];
};

typedef struct _GtkTextIter _GtkTextIter, *P_GtkTextIter;

typedef struct _GtkTextIter GtkTextIter;

struct _GtkTextIter {
    gpointer dummy1;
    gpointer dummy2;
    gint dummy3;
    gint dummy4;
    gint dummy5;
    gint dummy6;
    gint dummy7;
    gint dummy8;
    gpointer dummy9;
    gpointer dummy10;
    gint dummy11;
    gint dummy12;
    gint dummy13;
    gpointer dummy14;
};

typedef struct anon_struct_8_2_43e616cc anon_struct_8_2_43e616cc, *Panon_struct_8_2_43e616cc;

struct anon_struct_8_2_43e616cc {
    char * ptr;
    int len;
};

typedef struct FlagHolder FlagHolder, *PFlagHolder;

struct FlagHolder {
    struct FlagType Flags;
};

typedef struct FlagBitsType FlagBitsType, *PFlagBitsType;

struct FlagBitsType {
    int mask;
    char * name;
    int nlen;
    int object_types;
};

typedef struct _GtkNotebookPage _GtkNotebookPage, *P_GtkNotebookPage;

typedef struct _GtkNotebookPage GtkNotebookPage;

struct _GtkNotebookPage {
};

typedef struct _GtkNotebook _GtkNotebook, *P_GtkNotebook;

struct _GtkNotebook {
    GtkContainer container;
    GtkNotebookPage * cur_page;
    GList * children;
    GList * first_tab;
    GList * focus_tab;
    GtkWidget * menu;
    GdkWindow * event_window;
    guint32 timer;
    guint16 tab_hborder;
    guint16 tab_vborder;
    guint show_tabs:1;
    guint homogeneous:1;
    guint show_border:1;
    guint tab_pos:2;
    guint scrollable:1;
    guint in_child:3;
    guint click_child:3;
    guint button:2;
    guint need_timer:1;
    guint child_has_focus:1;
    guint have_visible_child:1;
    guint focus_out:1;
    guint has_before_previous:1;
    guint has_before_next:1;
    guint has_after_previous:1;
    guint has_after_next:1;
};

typedef struct _GtkNotebook GtkNotebook;

typedef struct _PangoLayout _PangoLayout, *P_PangoLayout;

typedef struct _PangoLayout PangoLayout;

struct _PangoLayout {
};

typedef struct vetting vetting, *Pvetting;

typedef union heap_or_vector heap_or_vector, *Pheap_or_vector;

typedef struct heap_struct heap_struct, *Pheap_struct;

typedef struct heap_struct heap_t;

typedef struct heap_element heap_element, *Pheap_element;

union heap_or_vector {
    vector_t * v;
    heap_t * h;
};

struct vetting {
    union heap_or_vector untested;
    union heap_or_vector no_fix;
    union heap_or_vector no_hi;
    union heap_or_vector hi_candidate;
    BDimension radius;
    BDimension keepaway;
    CheapPointType desired;
};

struct heap_struct {
    struct heap_element * element;
    int size;
    int max;
};

struct heap_element {
    cost_t cost;
    void * data;
};

typedef struct mtspace mtspace, *Pmtspace;

typedef struct mtspace mtspace_t;

struct mtspace {
    rtree_t * ftree;
    rtree_t * etree;
    rtree_t * otree;
};

typedef enum mtspace_type_t {
    FIXED=0,
    ODD=1,
    EVEN=2
} mtspace_type_t;

typedef struct vetting vetting_t;

typedef struct _GtkTreeViewColumn _GtkTreeViewColumn, *P_GtkTreeViewColumn;

typedef struct _GtkTreeViewColumn GtkTreeViewColumn;

typedef struct _GtkCellEditable _GtkCellEditable, *P_GtkCellEditable;

typedef struct _GtkCellEditable GtkCellEditable;

typedef enum GtkTreeViewColumnSizing {
    GTK_TREE_VIEW_COLUMN_GROW_ONLY=0,
    GTK_TREE_VIEW_COLUMN_AUTOSIZE=1,
    GTK_TREE_VIEW_COLUMN_FIXED=2
} GtkTreeViewColumnSizing;

typedef enum GtkSortType {
    GTK_SORT_ASCENDING=0,
    GTK_SORT_DESCENDING=1
} GtkSortType;

struct _GtkTreeViewColumn {
    GtkObject parent;
    GtkWidget * tree_view;
    GtkWidget * button;
    GtkWidget * child;
    GtkWidget * arrow;
    GtkWidget * alignment;
    GdkWindow * window;
    GtkCellEditable * editable_widget;
    gfloat xalign;
    guint property_changed_signal;
    gint spacing;
    enum GtkTreeViewColumnSizing column_type;
    gint requested_width;
    gint button_request;
    gint resized_width;
    gint width;
    gint fixed_width;
    gint min_width;
    gint max_width;
    gint drag_x;
    gint drag_y;
    gchar * title;
    GList * cell_list;
    guint sort_clicked_signal;
    guint sort_column_changed_signal;
    gint sort_column_id;
    enum GtkSortType sort_order;
    guint visible:1;
    guint resizable:1;
    guint clickable:1;
    guint dirty:1;
    guint show_sort_indicator:1;
    guint maybe_reordered:1;
    guint reorderable:1;
    guint use_resized_width:1;
    guint expand:1;
};

struct _GtkCellEditable {
};

typedef struct query_closure query_closure, *Pquery_closure;

struct query_closure {
    struct BoxType * cbox;
    union heap_or_vector checking;
    union heap_or_vector touching;
    CheapPointType * desired;
    BDimension radius;
    BDimension keepaway;
    jmp_buf env;
    Boolean touch_is_vec;
};

typedef struct mtspacebox mtspacebox, *Pmtspacebox;

typedef struct mtspacebox mtspacebox_t;

struct mtspacebox {
    struct BoxType box;
    BDimension keepaway;
};

typedef struct mts_info mts_info, *Pmts_info;

struct mts_info {
    BDimension keepaway;
    struct BoxType box;
    rtree_t * tree;
    jmp_buf env;
};

typedef struct r_neighbor_info r_neighbor_info, *Pr_neighbor_info;

struct r_neighbor_info {
    struct BoxType * neighbor;
    struct BoxType trap;
    enum direction_t search_dir;
};

typedef struct PerturbationType PerturbationType, *PPerturbationType;

struct PerturbationType {
    ElementTypePtr element;
    enum anon_enum_32 which;
    LocationType DX;
    LocationType DY;
    BYTE rotate;
    ElementTypePtr other;
};

typedef struct anon_struct_60_15_9c9e11e7 anon_struct_60_15_9c9e11e7, *Panon_struct_60_15_9c9e11e7;

struct anon_struct_60_15_9c9e11e7 {
    float via_cost;
    float congestion_penalty;
    float overlap_penalty_min;
    float overlap_penalty_max;
    float out_of_bounds_penalty;
    float overall_area_penalty;
    float matching_neighbor_bonus;
    float aligned_neighbor_bonus;
    float oriented_neighbor_bonus;
    float m;
    float gamma;
    int good_ratio;
    Boolean fast;
    int large_grid_size;
    int small_grid_size;
};

typedef struct ebox ebox, *Pebox;

struct ebox {
    struct BoxType box;
    ElementTypePtr element;
};

typedef struct _SFindClosest _SFindClosest, *P_SFindClosest;

typedef struct _SFindClosest SFindClosest;

struct _SFindClosest {
    gdouble dmin;
    GtsFace * closest;
    GtsPoint * p;
    gint stop;
};

typedef struct ecache ecache, *Pecache;

struct ecache {
    struct ecache * next;
    char * name;
    union hidval val;
};

typedef struct ccache ccache, *Pccache;

struct ccache {
    struct ecache * colors[31];
    struct ecache * lru;
};

typedef struct anon_struct_8_2_ee4b987b anon_struct_8_2_ee4b987b, *Panon_struct_8_2_ee4b987b;

struct anon_struct_8_2_ee4b987b {
    size_t MaxLength;
    char * Data;
};

typedef struct DynamicStringType DynamicStringType, *PDynamicStringType;

struct DynamicStringType {
    size_t MaxLength;
    char * Data;
};

typedef struct DynamicStringType * DynamicStringTypePtr;

typedef struct _GtkTreeStore _GtkTreeStore, *P_GtkTreeStore;

typedef gint (* GtkTreeIterCompareFunc)(GtkTreeModel *, GtkTreeIter *, GtkTreeIter *, gpointer);

struct _GtkTreeStore {
    GObject parent;
    gint stamp;
    gpointer root;
    gpointer last;
    gint n_columns;
    gint sort_column_id;
    GList * sort_list;
    enum GtkSortType order;
    GType * column_headers;
    GtkTreeIterCompareFunc default_sort_func;
    gpointer default_sort_data;
    GDestroyNotify default_sort_destroy;
    guint columns_dirty:1;
};

typedef struct _GtkTreeStore GtkTreeStore;

typedef struct _GtkColorButton _GtkColorButton, *P_GtkColorButton;

typedef struct _GtkColorButtonPrivate _GtkColorButtonPrivate, *P_GtkColorButtonPrivate;

typedef struct _GtkColorButtonPrivate GtkColorButtonPrivate;

struct _GtkColorButtonPrivate {
};

struct _GtkColorButton {
    GtkButton button;
    GtkColorButtonPrivate * priv;
};

typedef enum GtkPolicyType {
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2
} GtkPolicyType;

typedef enum GtkPositionType {
    GTK_POS_LEFT=0,
    GTK_POS_RIGHT=1,
    GTK_POS_TOP=2,
    GTK_POS_BOTTOM=3
} GtkPositionType;

typedef enum GtkShadowType {
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_OUT=2,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4
} GtkShadowType;

typedef struct color_struct color_struct, *Pcolor_struct;

struct color_struct {
    int c;
    uint r;
    uint g;
    uint b;
};

typedef struct _GtkLabelSelectionInfo _GtkLabelSelectionInfo, *P_GtkLabelSelectionInfo;

typedef struct _GtkLabelSelectionInfo GtkLabelSelectionInfo;

struct _GtkLabelSelectionInfo {
};

typedef struct _GtkLabel _GtkLabel, *P_GtkLabel;

typedef struct _GtkMisc _GtkMisc, *P_GtkMisc;

typedef struct _GtkMisc GtkMisc;

typedef struct _PangoAttrList _PangoAttrList, *P_PangoAttrList;

typedef struct _PangoAttrList PangoAttrList;

struct _PangoAttrList {
};

struct _GtkMisc {
    GtkWidget widget;
    gfloat xalign;
    gfloat yalign;
    guint16 xpad;
    guint16 ypad;
};

struct _GtkLabel {
    GtkMisc misc;
    gchar * label;
    guint jtype:2;
    guint wrap:1;
    guint use_underline:1;
    guint use_markup:1;
    guint ellipsize:3;
    guint single_line_mode:1;
    guint have_transform:1;
    guint in_click:1;
    guint wrap_mode:3;
    guint pattern_set:1;
    guint track_links:1;
    guint mnemonic_keyval;
    gchar * text;
    PangoAttrList * attrs;
    PangoAttrList * effective_attrs;
    PangoLayout * layout;
    GtkWidget * mnemonic_widget;
    GtkWindow * mnemonic_window;
    GtkLabelSelectionInfo * select_info;
};

typedef union yyalloc yyalloc, *Pyyalloc;

typedef union YYSTYPE YYSTYPE, *PYYSTYPE;

typedef struct _pair_list _pair_list, *P_pair_list;

typedef struct _pair_list pair_list;

typedef struct _str_pair _str_pair, *P_str_pair;

typedef struct _str_pair str_pair;

union YYSTYPE {
    char * s;
    pair_list * pl;
    str_pair * ps;
};

union yyalloc {
    yytype_int16 yyss;
    union YYSTYPE yyvs;
};

struct _pair_list {
    char * name;
    str_pair * list;
};

struct _str_pair {
    char * str1;
    char * str2;
    struct _str_pair * next;
};

typedef struct MediaType MediaType, *PMediaType;

struct MediaType {
    char * name;
    long Width;
    long Height;
    long MarginX;
    long MarginY;
};

typedef struct Keyword Keyword, *PKeyword;

struct Keyword {
    struct Keyword * Next;
    char * String;
};

typedef struct Token Token, *PToken;

struct Token {
    char * Name;
    int Code;
    struct Token * Next;
};

typedef struct Binder Binder, *PBinder;

struct Binder {
    short * Follower;
    short Origin;
    short FollowerSize;
};

typedef struct Tie Tie, *PTie;

struct Tie {
    short * Enable;
    short Origin;
    short EnableSize;
};

typedef struct Context Context, *PContext;

typedef struct ContextCar ContextCar, *PContextCar;

typedef struct TokenCar TokenCar, *PTokenCar;

typedef union anon_union_4_2_eceedfd6_for_u anon_union_4_2_eceedfd6_for_u, *Panon_union_4_2_eceedfd6_for_u;

typedef struct UsedCar UsedCar, *PUsedCar;

union anon_union_4_2_eceedfd6_for_u {
    int Single;
    struct UsedCar * Used;
};

struct UsedCar {
    struct UsedCar * Next;
    short Code;
};

struct Context {
    char * Name;
    short Code;
    short Flags;
    struct ContextCar * Context;
    struct TokenCar * Token;
    struct Context * Next;
};

struct ContextCar {
    struct ContextCar * Next;
    struct Context * Context;
    union anon_union_4_2_eceedfd6_for_u u;
};

struct TokenCar {
    struct TokenCar * Next;
    struct Token * Token;
};

typedef struct Bucket Bucket, *PBucket;

struct Bucket {
    struct Bucket * Next;
    int Index;
    char Data[64];
};

typedef struct FindPairCallbackStruct FindPairCallbackStruct, *PFindPairCallbackStruct;

typedef struct Extra Extra, *PExtra;

typedef struct End End, *PEnd;

struct End {
    struct Extra * next;
    void * pin;
    uchar in_pin:1;
    uchar at_pin:1;
    uchar is_pad:1;
    uchar pending:1;
    int x;
    int y;
    struct End * waiting_for;
};

struct Extra {
    struct End start;
    struct End end;
    uchar found:1;
    uchar deleted:1;
    undefined field4_0x31;
    undefined field5_0x32;
    undefined field6_0x33;
};

struct FindPairCallbackStruct {
    void * me;
    int x;
    int y;
    int is_arc;
    struct Extra * * extra_ptr;
};

typedef struct _GtkTreeModelFilter _GtkTreeModelFilter, *P_GtkTreeModelFilter;

typedef struct _GtkTreeModelFilterPrivate _GtkTreeModelFilterPrivate, *P_GtkTreeModelFilterPrivate;

typedef struct _GtkTreeModelFilterPrivate GtkTreeModelFilterPrivate;

struct _GtkTreeModelFilter {
    GObject parent;
    GtkTreeModelFilterPrivate * priv;
};

struct _GtkTreeModelFilterPrivate {
};

typedef struct _GtkFileFilter _GtkFileFilter, *P_GtkFileFilter;

typedef struct _GtkFileFilter GtkFileFilter;

struct _GtkFileFilter {
};

typedef struct yy_buffer_state yy_buffer_state, *Pyy_buffer_state;

struct yy_buffer_state {
    FILE * yy_input_file;
    char * yy_ch_buf;
    char * yy_buf_pos;
    yy_size_t yy_buf_size;
    int yy_n_chars;
    int yy_is_our_buffer;
    int yy_is_interactive;
    int yy_at_bol;
    int yy_fill_buffer;
    int yy_buffer_status;
};

typedef struct yy_buffer_state * YY_BUFFER_STATE;

typedef struct __dirstream __dirstream, *P__dirstream;

typedef struct __dirstream DIR;

struct __dirstream {
};

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino_t d_ino;
    __off_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct _GtkTooltipsData _GtkTooltipsData, *P_GtkTooltipsData;

typedef struct _GtkTooltipsData GtkTooltipsData;

typedef struct _GtkTooltips _GtkTooltips, *P_GtkTooltips;

typedef struct _GtkTooltips GtkTooltips;

typedef struct _GTimeVal _GTimeVal, *P_GTimeVal;

typedef struct _GTimeVal GTimeVal;

struct _GtkTooltipsData {
    GtkTooltips * tooltips;
    GtkWidget * widget;
    gchar * tip_text;
    gchar * tip_private;
};

struct _GTimeVal {
    glong tv_sec;
    glong tv_usec;
};

struct _GtkTooltips {
    GtkObject parent_instance;
    GtkWidget * tip_window;
    GtkWidget * tip_label;
    GtkTooltipsData * active_tips_data;
    GList * tips_data_list;
    guint delay:30;
    guint enabled:1;
    guint have_grab:1;
    guint use_sticky_delay:1;
    gint timer_tag;
    GTimeVal last_popdown;
};

typedef struct routeall_status routeall_status, *Prouteall_status;

struct routeall_status {
    int total_subnets;
    int routed_subnets;
    int conflict_subnets;
    int failed;
    int ripped;
    int total_nets_routed;
};

typedef struct routeone_state routeone_state, *Prouteone_state;

typedef struct routebox routebox, *Proutebox;

typedef struct routebox routebox_t;

typedef union anon_union_4_7_c208ad69_for_parent anon_union_4_7_c208ad69_for_parent, *Panon_union_4_7_c208ad69_for_parent;

typedef struct anon_struct_8_16_88ec3562_for_flags anon_struct_8_16_88ec3562_for_flags, *Panon_struct_8_16_88ec3562_for_flags;

typedef struct routebox_list routebox_list, *Proutebox_list;

union anon_union_4_7_c208ad69_for_parent {
    PadTypePtr pad;
    PinTypePtr pin;
    PinTypePtr via;
    struct routebox * via_shadow;
    LineTypePtr line;
    void * generic;
    struct routebox * expansion_area;
};

struct routeone_state {
    heap_t * workheap;
    routebox_t * best_path;
    routebox_t * best_target;
    cost_t best_cost;
};

struct routebox_list {
    struct routebox * next;
    struct routebox * prev;
};

struct anon_struct_8_16_88ec3562_for_flags {
    uint nonstraight:1;
    uint fixed:1;
    uint source:1;
    uint target:1;
    uint nobloat:1;
    uint circular:1;
    uint homeless:1;
    uint is_odd:1;
    uint touched:1;
    uint subnet_processed:1;
    uint is_via:1;
    uint bl_to_ur:1;
    uint clear_poly:1;
    uint is_bad:1;
    uint inited:1;
    uint is_thermal;
};

struct routebox {
    struct BoxType box;
    struct BoxType sbox;
    union anon_union_4_7_c208ad69_for_parent parent;
    ushort group;
    ushort layer;
    enum anon_enum_32 type;
    struct anon_struct_8_16_88ec3562_for_flags flags;
    cost_t cost;
    CheapPointType cost_point;
    int refcount;
    vector_t * conflicts_with;
    struct RouteStyleType * style;
    uchar n;
    uchar e;
    uchar s;
    uchar w;
    uchar pass;
    enum direction_t came_from;
    struct routebox_list same_net;
    struct routebox_list same_subnet;
    struct routebox_list original_subnet;
    struct routebox_list different_net;
};

typedef struct broken_boxes broken_boxes, *Pbroken_boxes;

struct broken_boxes {
    struct BoxType left;
    struct BoxType center;
    struct BoxType right;
    Boolean is_valid_left;
    Boolean is_valid_center;
    Boolean is_valid_right;
};

typedef struct mincost_target_closure mincost_target_closure, *Pmincost_target_closure;

struct mincost_target_closure {
    CheapPointType * CostPoint;
    Cardinal CostPointLayer;
    routebox_t * nearest;
    cost_t nearest_cost;
};

typedef struct anon_struct_76_17_2a7357e9 anon_struct_76_17_2a7357e9, *Panon_struct_76_17_2a7357e9;

struct anon_struct_76_17_2a7357e9 {
    struct RouteStyleType * style;
    BDimension bloat;
    cost_t ViaCost;
    cost_t LastConflictPenalty;
    cost_t ConflictPenalty;
    cost_t JogPenalty;
    cost_t CongestionPenalty;
    cost_t NewLayerPenalty;
    cost_t MinPenalty;
    int hi_conflict;
    Boolean use_vias;
    Boolean is_odd;
    Boolean with_conflicts;
    Boolean is_smoothing;
    Boolean rip_always;
    Boolean last_smooth;
    uchar pass;
};

typedef struct routeone_via_site_state routeone_via_site_state, *Prouteone_via_site_state;

struct routeone_via_site_state {
    vector_t * free_space_vec;
    vector_t * lo_conflict_space_vec;
    vector_t * hi_conflict_space_vec;
};

typedef struct edge_struct edge_struct, *Pedge_struct;

typedef struct anon_struct_4_5_e392ff63_for_flags anon_struct_4_5_e392ff63_for_flags, *Panon_struct_4_5_e392ff63_for_flags;

typedef enum conflict_t {
    NO_CONFLICT=0,
    LO_CONFLICT=1,
    HI_CONFLICT=2
} conflict_t;

struct anon_struct_4_5_e392ff63_for_flags {
    uint is_via:1;
    enum conflict_t via_conflict_level:2;
    uint is_interior:1;
    uint via_search:1;
    uint in_plane:1;
};

struct edge_struct {
    routebox_t * rb;
    CheapPointType cost_point;
    cost_t cost_to_point;
    cost_t cost;
    routebox_t * mincost_target;
    vetting_t * work;
    enum direction_t expand_dir;
    struct anon_struct_4_5_e392ff63_for_flags flags;
};

typedef struct fpin_info fpin_info, *Pfpin_info;

struct fpin_info {
    PinTypePtr pin;
    LocationType X;
    LocationType Y;
    jmp_buf env;
};

typedef struct E_result E_result, *PE_result;

struct E_result {
    routebox_t * parent;
    routebox_t * n;
    routebox_t * e;
    routebox_t * s;
    routebox_t * w;
    BDimension keep;
    BDimension bloat;
    struct BoxType inflated;
    struct BoxType orig;
    int done;
};

typedef struct routeone_status routeone_status, *Prouteone_status;

struct routeone_status {
    Boolean found_route;
    int route_had_conflicts;
    cost_t best_route_cost;
    Boolean net_completely_routed;
};

typedef struct break_info break_info, *Pbreak_info;

struct break_info {
    heap_t * heap;
    routebox_t * parent;
    struct BoxType box;
    enum direction_t dir;
    Boolean ignore_source;
};

typedef struct foib_info foib_info, *Pfoib_info;

struct foib_info {
    struct BoxType * box;
    routebox_t * intersect;
    jmp_buf env;
};

typedef struct routedata routedata, *Proutedata;

typedef struct routedata routedata_t;

struct routedata {
    rtree_t * layergrouptree[16];
    routebox_t * first_net;
    struct RouteStyleType defaultstyle;
    struct RouteStyleType * styles[5];
    BDimension max_bloat;
    BDimension max_keep;
    mtspace_t * mtspace;
};

typedef struct rb_info rb_info, *Prb_info;

struct rb_info {
    struct BoxType query;
    routebox_t * winner;
    jmp_buf env;
};

typedef struct edge_struct edge_t;

typedef struct therm_info therm_info, *Ptherm_info;

struct therm_info {
    routebox_t * plane;
    struct BoxType query;
    jmp_buf env;
};

typedef enum boxlist {
    NET=0,
    SUBNET=1,
    ORIGINAL=2,
    DIFFERENT_NET=3
} boxlist;

typedef struct pin_info pin_info, *Ppin_info;

struct pin_info {
    Boolean arg;
    LayerTypePtr Layer;
};

typedef struct FloatPolyType FloatPolyType, *PFloatPolyType;

struct FloatPolyType {
    double X;
    double Y;
};

typedef struct HoleCountStruct HoleCountStruct, *PHoleCountStruct;

struct HoleCountStruct {
    int nplated;
    int nunplated;
};

typedef struct _GtkMenuShell _GtkMenuShell, *P_GtkMenuShell;

typedef struct _GtkMenuShell GtkMenuShell;

struct _GtkMenuShell {
    GtkContainer container;
    GList * children;
    GtkWidget * active_menu_item;
    GtkWidget * parent_menu_shell;
    guint button;
    guint32 activate_time;
    guint active:1;
    guint have_grab:1;
    guint have_xgrab:1;
    guint ignore_leave:1;
    guint menu_flag:1;
    guint ignore_enter:1;
    guint keyboard_mode:1;
};

typedef struct anon_struct_24_6_049bbb11 LibraryEntryType.conflict;

typedef void (* NFunc)(LibraryMenuType *, LibraryEntryType.conflict *);

typedef enum GdkInterpType {
    GDK_INTERP_NEAREST=0,
    GDK_INTERP_TILES=1,
    GDK_INTERP_BILINEAR=2,
    GDK_INTERP_HYPER=3
} GdkInterpType;

typedef void (* GFunc)(gpointer, gpointer);

typedef struct _GtkUIManager _GtkUIManager, *P_GtkUIManager;

typedef struct _GtkUIManager GtkUIManager;

typedef struct _GtkUIManagerPrivate _GtkUIManagerPrivate, *P_GtkUIManagerPrivate;

typedef struct _GtkUIManagerPrivate GtkUIManagerPrivate;

struct _GtkUIManagerPrivate {
};

struct _GtkUIManager {
    GObject parent;
    GtkUIManagerPrivate * private_data;
};

typedef struct HID_FlagNode HID_FlagNode, *PHID_FlagNode;

typedef struct HID_Flag HID_Flag, *PHID_Flag;

struct HID_Flag {
    char * name;
    int (* function)(int);
    int parm;
};

struct HID_FlagNode {
    struct HID_FlagNode * next;
    struct HID_Flag * flags;
    int n;
};

typedef struct _GtkComboBoxPrivate _GtkComboBoxPrivate, *P_GtkComboBoxPrivate;

typedef struct _GtkComboBoxPrivate GtkComboBoxPrivate;

struct _GtkComboBoxPrivate {
};

typedef struct _GtkComboBox _GtkComboBox, *P_GtkComboBox;

struct _GtkComboBox {
    GtkBin parent_instance;
    GtkComboBoxPrivate * priv;
};

typedef struct Resource Resource, *PResource;

typedef struct ResourceVal ResourceVal, *PResourceVal;

struct Resource {
    struct Resource * parent;
    void * user_ptr;
    int flags;
    int c;
    struct ResourceVal * v;
};

struct ResourceVal {
    char * name;
    char * value;
    struct Resource * subres;
};

typedef struct _GtkCellRendererClass _GtkCellRendererClass, *P_GtkCellRendererClass;

typedef struct _GtkCellRenderer _GtkCellRenderer, *P_GtkCellRenderer;

typedef struct _GtkCellRenderer GtkCellRenderer;

typedef struct _GdkDrawable GdkDrawable;

typedef enum GtkCellRendererState {
    GTK_CELL_RENDERER_SELECTED=1,
    GTK_CELL_RENDERER_PRELIT=2,
    GTK_CELL_RENDERER_INSENSITIVE=4,
    GTK_CELL_RENDERER_SORTED=8,
    GTK_CELL_RENDERER_FOCUSED=16
} GtkCellRendererState;

typedef struct _GtkCellRendererClass GtkCellRendererClass;

struct _GtkCellRenderer {
    GtkObject parent;
    gfloat xalign;
    gfloat yalign;
    gint width;
    gint height;
    guint16 xpad;
    guint16 ypad;
    guint mode:2;
    guint visible:1;
    guint is_expander:1;
    guint is_expanded:1;
    guint cell_background_set:1;
    guint sensitive:1;
    guint editing:1;
};

struct _GtkCellRendererClass {
    GtkObjectClass parent_class;
    void (* get_size)(GtkCellRenderer *, GtkWidget *, GdkRectangle *, gint *, gint *, gint *, gint *);
    void (* render)(GtkCellRenderer *, GdkDrawable *, GtkWidget *, GdkRectangle *, GdkRectangle *, GdkRectangle *, enum GtkCellRendererState);
    gboolean (* activate)(GtkCellRenderer *, GdkEvent *, GtkWidget *, gchar *, GdkRectangle *, GdkRectangle *, enum GtkCellRendererState);
    GtkCellEditable * (* start_editing)(GtkCellRenderer *, GdkEvent *, GtkWidget *, gchar *, GdkRectangle *, GdkRectangle *, enum GtkCellRendererState);
    void (* editing_canceled)(GtkCellRenderer *);
    void (* editing_started)(GtkCellRenderer *, GtkCellEditable *, gchar *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
};

typedef struct object_list object_list, *Pobject_list;

struct object_list {
    int count;
    long * id_list;
    int * type_list;
};

typedef __gnuc_va_list va_list;

typedef struct _GhidViolationRendererClass _GhidViolationRendererClass, *P_GhidViolationRendererClass;

typedef struct _GhidViolationRendererClass GhidViolationRendererClass;

typedef struct _GtkCellRendererTextClass _GtkCellRendererTextClass, *P_GtkCellRendererTextClass;

typedef struct _GtkCellRendererText _GtkCellRendererText, *P_GtkCellRendererText;

typedef struct _GtkCellRendererText GtkCellRendererText;

typedef struct _GtkCellRendererTextClass GtkCellRendererTextClass;

typedef struct _PangoColor _PangoColor, *P_PangoColor;

typedef struct _PangoColor PangoColor;

typedef enum PangoUnderline {
    PANGO_UNDERLINE_NONE=0,
    PANGO_UNDERLINE_SINGLE=1,
    PANGO_UNDERLINE_DOUBLE=2,
    PANGO_UNDERLINE_LOW=3,
    PANGO_UNDERLINE_ERROR=4
} PangoUnderline;

struct _GtkCellRendererTextClass {
    GtkCellRendererClass parent_class;
    void (* edited)(GtkCellRendererText *, gchar *, gchar *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

struct _GhidViolationRendererClass {
    GtkCellRendererTextClass parent_class;
};

struct _PangoColor {
    guint16 red;
    guint16 green;
    guint16 blue;
};

struct _GtkCellRendererText {
    GtkCellRenderer parent;
    gchar * text;
    PangoFontDescription * font;
    gdouble font_scale;
    PangoColor foreground;
    PangoColor background;
    PangoAttrList * extra_attrs;
    enum PangoUnderline underline_style;
    gint rise;
    gint fixed_height_rows;
    guint strikethrough:1;
    guint editable:1;
    guint scale_set:1;
    guint foreground_set:1;
    guint background_set:1;
    guint underline_set:1;
    guint rise_set:1;
    guint strikethrough_set:1;
    guint editable_set:1;
    guint calc_fixed_height:1;
};

typedef struct _GhidDrcViolation _GhidDrcViolation, *P_GhidDrcViolation;

struct _GhidDrcViolation {
    GObject parent_instance;
    char * title;
    char * explanation;
    int x_coord;
    int y_coord;
    int angle;
    int have_measured;
    double measured_value;
    double required_value;
    int value_digits;
    char * value_units;
    int object_count;
    long * object_id_list;
    int * object_type_list;
    GdkDrawable * pixmap;
};

typedef struct _GhidViolationRenderer _GhidViolationRenderer, *P_GhidViolationRenderer;

typedef struct _GhidDrcViolation GhidDrcViolation;

struct _GhidViolationRenderer {
    GtkCellRendererText parent_instance;
    GhidDrcViolation * violation;
};

typedef struct _GhidViolationRenderer GhidViolationRenderer;

typedef struct _GClosureNotifyData _GClosureNotifyData, *P_GClosureNotifyData;

typedef struct _GClosure _GClosure, *P_GClosure;

typedef struct _GClosure GClosure;

typedef void (* GClosureNotify)(gpointer, GClosure *);

typedef struct _GClosureNotifyData GClosureNotifyData;

struct _GClosureNotifyData {
    gpointer data;
    GClosureNotify notify;
};

struct _GClosure {
    guint ref_count:15;
    guint meta_marshal:1;
    guint n_guards:1;
    guint n_fnotifiers:2;
    guint n_inotifiers:8;
    guint in_inotify:1;
    guint floating:1;
    guint derivative_flag:1;
    guint in_marshal:1;
    guint is_invalid:1;
    void (* marshal)(GClosure *, GValue *, guint, GValue *, gpointer, gpointer);
    gpointer data;
    GClosureNotifyData * notifiers;
};

typedef struct HID_DRC_GUI HID_DRC_GUI, *PHID_DRC_GUI;

typedef struct drc_violation_st drc_violation_st, *Pdrc_violation_st;

typedef struct drc_violation_st DrcViolationType;

struct HID_DRC_GUI {
    int log_drc_overview;
    int log_drc_violations;
    void (* reset_drc_dialog_message)(void);
    void (* append_drc_violation)(DrcViolationType *);
    int (* throw_drc_dialog)(void);
};

struct drc_violation_st {
    char * title;
    char * explanation;
    int x;
    int y;
    int angle;
    int have_measured;
    double measured_value;
    double required_value;
    int value_digits;
    char * value_units;
    int object_count;
    long * object_id_list;
    int * object_type_list;
};

typedef struct hid_gc_struct.conflict hid_gc_struct.conflict, *Phid_gc_struct.conflict;

struct hid_gc_struct.conflict {
    int width;
};

typedef struct hid_gc_struct.conflict5 hid_gc_struct.conflict5, *Phid_gc_struct.conflict5;

typedef struct HID.conflict4 HID.conflict4, *PHID.conflict4;

typedef struct hid_gc_struct.conflict5 * hidGC.conflict5;

typedef enum EndCapStyle {
    Trace_Cap=0,
    Square_Cap=1,
    Round_Cap=2,
    Beveled_Cap=3
} EndCapStyle;

struct hid_gc_struct.conflict5 {
    struct HID.conflict4 * me_pointer;
    enum EndCapStyle cap;
    int width;
    uchar r;
    uchar g;
    uchar b;
    int erase;
    int faded;
};

struct HID.conflict4 {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC.conflict5 (* make_gc)(void);
    void (* destroy_gc)(hidGC.conflict5);
    void (* use_mask)(int);
    void (* set_color)(hidGC.conflict5, char *);
    void (* set_line_cap)(hidGC.conflict5, enum EndCapStyle);
    void (* set_line_width)(hidGC.conflict5, int);
    void (* set_draw_xor)(hidGC.conflict5, int);
    void (* set_draw_faded)(hidGC.conflict5, int);
    void (* set_line_cap_angle)(hidGC.conflict5, int, int, int, int);
    void (* draw_line)(hidGC.conflict5, int, int, int, int);
    void (* draw_arc)(hidGC.conflict5, int, int, int, int, int, int);
    void (* draw_rect)(hidGC.conflict5, int, int, int, int);
    void (* fill_circle)(hidGC.conflict5, int, int, int);
    void (* fill_polygon)(hidGC.conflict5, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC.conflict5, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC.conflict5, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC.conflict5, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

typedef struct hid_gc_struct.conflict3 hid_gc_struct.conflict3, *Phid_gc_struct.conflict3;

typedef struct HID.conflict3 HID.conflict3, *PHID.conflict3;

typedef struct hid_gc_struct.conflict3 * hidGC.conflict3;

typedef struct gdImageStruct gdImageStruct, *PgdImageStruct;

typedef struct gdImageStruct gdImage;

typedef gdImage * gdImagePtr;

struct gdImageStruct {
    uchar * * pixels;
    int sx;
    int sy;
    int colorsTotal;
    int red[256];
    int green[256];
    int blue[256];
    int open[256];
    int transparent;
    int * polyInts;
    int polyAllocated;
    struct gdImageStruct * brush;
    struct gdImageStruct * tile;
    int brushColorMap[256];
    int tileColorMap[256];
    int styleLength;
    int stylePos;
    int * style;
    int interlace;
    int thick;
    int alpha[256];
    int trueColor;
    int * * tpixels;
    int alphaBlendingFlag;
    int saveAlphaFlag;
    int AA;
    int AA_color;
    int AA_dont_blend;
    int cx1;
    int cy1;
    int cx2;
    int cy2;
};

struct hid_gc_struct.conflict3 {
    struct HID.conflict3 * me_pointer;
    enum EndCapStyle cap;
    int width;
    uchar r;
    uchar g;
    uchar b;
    int erase;
    int faded;
    struct color_struct * color;
    gdImagePtr brush;
};

struct HID.conflict3 {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC.conflict3 (* make_gc)(void);
    void (* destroy_gc)(hidGC.conflict3);
    void (* use_mask)(int);
    void (* set_color)(hidGC.conflict3, char *);
    void (* set_line_cap)(hidGC.conflict3, enum EndCapStyle);
    void (* set_line_width)(hidGC.conflict3, int);
    void (* set_draw_xor)(hidGC.conflict3, int);
    void (* set_draw_faded)(hidGC.conflict3, int);
    void (* set_line_cap_angle)(hidGC.conflict3, int, int, int, int);
    void (* draw_line)(hidGC.conflict3, int, int, int, int);
    void (* draw_arc)(hidGC.conflict3, int, int, int, int, int, int);
    void (* draw_rect)(hidGC.conflict3, int, int, int, int);
    void (* fill_circle)(hidGC.conflict3, int, int, int);
    void (* fill_polygon)(hidGC.conflict3, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC.conflict3, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC.conflict3, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC.conflict3, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

typedef struct HID.conflict HID.conflict, *PHID.conflict;

typedef struct hid_gc_struct.conflict * hidGC.conflict;

struct HID.conflict {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC.conflict (* make_gc)(void);
    void (* destroy_gc)(hidGC.conflict);
    void (* use_mask)(int);
    void (* set_color)(hidGC.conflict, char *);
    void (* set_line_cap)(hidGC.conflict, enum EndCapStyle);
    void (* set_line_width)(hidGC.conflict, int);
    void (* set_draw_xor)(hidGC.conflict, int);
    void (* set_draw_faded)(hidGC.conflict, int);
    void (* set_line_cap_angle)(hidGC.conflict, int, int, int, int);
    void (* draw_line)(hidGC.conflict, int, int, int, int);
    void (* draw_arc)(hidGC.conflict, int, int, int, int, int, int);
    void (* draw_rect)(hidGC.conflict, int, int, int, int);
    void (* fill_circle)(hidGC.conflict, int, int, int);
    void (* fill_polygon)(hidGC.conflict, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC.conflict, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC.conflict, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC.conflict, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

typedef struct hid_gc_struct.conflict1 hid_gc_struct.conflict1, *Phid_gc_struct.conflict1;

typedef struct HID.conflict1 HID.conflict1, *PHID.conflict1;

typedef struct hid_gc_struct.conflict1 * hidGC.conflict1;

struct hid_gc_struct.conflict1 {
    struct HID.conflict1 * me_pointer;
    GdkGC * gc;
    gchar * colorname;
    gint width;
    gint cap;
    gint join;
    gchar xor;
    gchar erase;
    gint mask_seq;
};

struct HID.conflict1 {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC.conflict1 (* make_gc)(void);
    void (* destroy_gc)(hidGC.conflict1);
    void (* use_mask)(int);
    void (* set_color)(hidGC.conflict1, char *);
    void (* set_line_cap)(hidGC.conflict1, enum EndCapStyle);
    void (* set_line_width)(hidGC.conflict1, int);
    void (* set_draw_xor)(hidGC.conflict1, int);
    void (* set_draw_faded)(hidGC.conflict1, int);
    void (* set_line_cap_angle)(hidGC.conflict1, int, int, int, int);
    void (* draw_line)(hidGC.conflict1, int, int, int, int);
    void (* draw_arc)(hidGC.conflict1, int, int, int, int, int, int);
    void (* draw_rect)(hidGC.conflict1, int, int, int, int);
    void (* fill_circle)(hidGC.conflict1, int, int, int);
    void (* fill_polygon)(hidGC.conflict1, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC.conflict1, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC.conflict1, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC.conflict1, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

typedef struct hid_gc_struct.conflict2 hid_gc_struct.conflict2, *Phid_gc_struct.conflict2;

struct hid_gc_struct.conflict2 {
    enum EndCapStyle cap;
    int width;
    int color;
    int erase;
    int drill;
};

typedef struct hid_gc_struct.conflict6 hid_gc_struct.conflict6, *Phid_gc_struct.conflict6;

struct hid_gc_struct.conflict6 {
    enum EndCapStyle cap;
    int width;
    int color;
    int erase;
};

typedef struct HID HID, *PHID;

typedef struct hid_gc_struct hid_gc_struct, *Phid_gc_struct;

typedef struct hid_gc_struct * hidGC;

struct hid_gc_struct {
    int nothing_interesting_here;
};

struct HID {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC (* make_gc)(void);
    void (* destroy_gc)(hidGC);
    void (* use_mask)(int);
    void (* set_color)(hidGC, char *);
    void (* set_line_cap)(hidGC, enum EndCapStyle);
    void (* set_line_width)(hidGC, int);
    void (* set_draw_xor)(hidGC, int);
    void (* set_draw_faded)(hidGC, int);
    void (* set_line_cap_angle)(hidGC, int, int, int, int);
    void (* draw_line)(hidGC, int, int, int, int);
    void (* draw_arc)(hidGC, int, int, int, int, int, int);
    void (* draw_rect)(hidGC, int, int, int, int);
    void (* fill_circle)(hidGC, int, int, int);
    void (* fill_polygon)(hidGC, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

typedef struct hid_gc_struct.conflict4 hid_gc_struct.conflict4, *Phid_gc_struct.conflict4;

typedef struct color_struct.conflict color_struct.conflict, *Pcolor_struct.conflict;

struct color_struct.conflict {
    int c;
    uint r;
    uint g;
    uint b;
    uint a;
};

struct hid_gc_struct.conflict4 {
    struct HID.conflict3 * me_pointer;
    enum EndCapStyle cap;
    int width;
    uchar r;
    uchar g;
    uchar b;
    int erase;
    int faded;
    struct color_struct.conflict * color;
    gdImagePtr brush;
};

typedef struct hid_gc_struct.conflict4 * hidGC.conflict4;

typedef struct hid_gc_struct.conflict2 * hidGC.conflict2;

typedef struct hid_gc_struct.conflict6 * hidGC.conflict6;

typedef struct HID.conflict5 HID.conflict5, *PHID.conflict5;

struct HID.conflict5 {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC.conflict6 (* make_gc)(void);
    void (* destroy_gc)(hidGC.conflict6);
    void (* use_mask)(int);
    void (* set_color)(hidGC.conflict6, char *);
    void (* set_line_cap)(hidGC.conflict6, enum EndCapStyle);
    void (* set_line_width)(hidGC.conflict6, int);
    void (* set_draw_xor)(hidGC.conflict6, int);
    void (* set_draw_faded)(hidGC.conflict6, int);
    void (* set_line_cap_angle)(hidGC.conflict6, int, int, int, int);
    void (* draw_line)(hidGC.conflict6, int, int, int, int);
    void (* draw_arc)(hidGC.conflict6, int, int, int, int, int, int);
    void (* draw_rect)(hidGC.conflict6, int, int, int, int);
    void (* fill_circle)(hidGC.conflict6, int, int, int);
    void (* fill_polygon)(hidGC.conflict6, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC.conflict6, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC.conflict6, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC.conflict6, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

typedef struct HID.conflict2 HID.conflict2, *PHID.conflict2;

struct HID.conflict2 {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC.conflict2 (* make_gc)(void);
    void (* destroy_gc)(hidGC.conflict2);
    void (* use_mask)(int);
    void (* set_color)(hidGC.conflict2, char *);
    void (* set_line_cap)(hidGC.conflict2, enum EndCapStyle);
    void (* set_line_width)(hidGC.conflict2, int);
    void (* set_draw_xor)(hidGC.conflict2, int);
    void (* set_draw_faded)(hidGC.conflict2, int);
    void (* set_line_cap_angle)(hidGC.conflict2, int, int, int, int);
    void (* draw_line)(hidGC.conflict2, int, int, int, int);
    void (* draw_arc)(hidGC.conflict2, int, int, int, int, int, int);
    void (* draw_rect)(hidGC.conflict2, int, int, int, int);
    void (* fill_circle)(hidGC.conflict2, int, int, int);
    void (* fill_polygon)(hidGC.conflict2, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC.conflict2, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC.conflict2, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC.conflict2, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

typedef struct SizesDialog SizesDialog, *PSizesDialog;

struct SizesDialog {
    GtkWidget * name_entry;
    GtkWidget * line_width_spin_button;
    GtkWidget * via_hole_spin_button;
    GtkWidget * via_size_spin_button;
    GtkWidget * clearance_spin_button;
    GtkWidget * set_temp1_button;
    GtkWidget * set_temp2_button;
    gboolean units_mm;
};

typedef struct pv_info pv_info, *Ppv_info;

struct pv_info {
    Cardinal layer;
    struct PinType pv;
    jmp_buf env;
};

typedef struct ListType ListType, *PListType;

struct ListType {
    void * * Data;
    Cardinal Location;
    Cardinal DrawLocation;
    Cardinal Number;
    Cardinal Size;
};

typedef struct rat_info rat_info, *Prat_info;

struct rat_info {
    Cardinal layer;
    PointTypePtr Point;
    jmp_buf env;
};

typedef struct lo_info lo_info, *Plo_info;

typedef struct ArcType ArcType, *PArcType;

typedef struct RatType RatType, *PRatType;

struct RatType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    Cardinal group1;
    Cardinal group2;
};

struct ArcType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    LocationType Width;
    LocationType Height;
    LocationType X;
    LocationType Y;
    long StartAngle;
    long Delta;
};

struct lo_info {
    Cardinal layer;
    struct LineType line;
    struct PadType pad;
    struct ArcType arc;
    PolygonType polygon;
    struct RatType rat;
    jmp_buf env;
};

typedef struct line_info.conflict line_info.conflict, *Pline_info.conflict;

struct line_info.conflict {
    LineTypePtr * Line;
    PointTypePtr * Point;
    float least;
    jmp_buf env;
    int locked;
};

typedef struct ans_info ans_info, *Pans_info;

struct ans_info {
    void * * ptr1;
    void * * ptr2;
    void * * ptr3;
    Boolean BackToo;
    float area;
    jmp_buf env;
    int locked;
};

typedef struct arc_info arc_info, *Parc_info;

struct arc_info {
    ArcTypePtr * Arc;
    ArcTypePtr * Dummy;
    jmp_buf env;
    int locked;
};

typedef struct anon_struct_12_3_0e963fe1 anon_struct_12_3_0e963fe1, *Panon_struct_12_3_0e963fe1;

typedef struct BoxType * BoxTypePtr;

struct anon_struct_12_3_0e963fe1 {
    Cardinal BoxN;
    Cardinal BoxMax;
    BoxTypePtr Box;
};

typedef struct anon_struct_36_4_c0f02585 anon_struct_36_4_c0f02585, *Panon_struct_36_4_c0f02585;

struct anon_struct_36_4_c0f02585 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
};

typedef struct DrillType DrillType, *PDrillType;

struct DrillType {
    BDimension DrillSize;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal PinCount;
    Cardinal ViaCount;
    Cardinal UnplatedCount;
    Cardinal PinN;
    Cardinal PinMax;
    PinTypePtr * Pin;
    ElementTypePtr * Element;
};

typedef struct RouteStyleType * RouteStyleTypePtr;

typedef struct anon_struct_48_12_ec857283 anon_struct_48_12_ec857283, *Panon_struct_48_12_ec857283;

typedef struct anon_struct_48_12_ec857283 * ObjectFunctionTypePtr;

struct anon_struct_48_12_ec857283 {
    void * (* Line)(LayerTypePtr, LineTypePtr);
    void * (* Text)(LayerTypePtr, TextTypePtr);
    void * (* Polygon)(LayerTypePtr, PolygonTypePtr);
    void * (* Via)(PinTypePtr);
    void * (* Element)(ElementTypePtr);
    void * (* ElementName)(ElementTypePtr);
    void * (* Pin)(ElementTypePtr, PinTypePtr);
    void * (* Pad)(ElementTypePtr, PadTypePtr);
    void * (* LinePoint)(LayerTypePtr, LineTypePtr, PointTypePtr);
    void * (* Point)(LayerTypePtr, PolygonTypePtr, PointTypePtr);
    void * (* Arc)(LayerTypePtr, ArcTypePtr);
    void * (* Rat)(RatTypePtr);
};

typedef char * String;

typedef struct anon_struct_40_10_5aa2f479 anon_struct_40_10_5aa2f479, *Panon_struct_40_10_5aa2f479;

struct anon_struct_40_10_5aa2f479 {
    BDimension DrillSize;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal PinCount;
    Cardinal ViaCount;
    Cardinal UnplatedCount;
    Cardinal PinN;
    Cardinal PinMax;
    PinTypePtr * Pin;
    ElementTypePtr * Element;
};

typedef struct anon_struct_76_14_398d8f56 * * PinTypeHandle;

typedef struct anon_struct_12_3_6cceedd6 anon_struct_12_3_6cceedd6, *Panon_struct_12_3_6cceedd6;

struct anon_struct_12_3_6cceedd6 {
    LayerTypePtr Layer;
    LineTypePtr Line;
    PointTypePtr MovedPoint;
};

typedef struct AttachedLineType AttachedLineType, *PAttachedLineType;

typedef struct AttachedLineType * AttachedLineTypePtr;

struct AttachedLineType {
    struct PointType Point1;
    struct PointType Point2;
    long State;
    Boolean draw;
};

typedef struct OutputType OutputType, *POutputType;

struct OutputType {
    hidGC bgGC;
    hidGC fgGC;
    hidGC pmGC;
    hidGC GridGC;
    int Width;
    int Height;
    int oldObjState;
    int oldLineState;
    int oldBoxState;
};

typedef struct anon_struct_12_3_8c03c973 anon_struct_12_3_8c03c973, *Panon_struct_12_3_8c03c973;

typedef struct anon_struct_16_4_a003c1eb anon_struct_16_4_a003c1eb, *Panon_struct_16_4_a003c1eb;

typedef struct anon_struct_16_4_a003c1eb * NetTypePtr;

typedef struct anon_struct_28_7_a511ee14 anon_struct_28_7_a511ee14, *Panon_struct_28_7_a511ee14;

typedef struct anon_struct_28_7_a511ee14 * ConnectionTypePtr;

struct anon_struct_16_4_a003c1eb {
    Cardinal ConnectionN;
    Cardinal ConnectionMax;
    ConnectionTypePtr Connection;
    RouteStyleTypePtr Style;
};

struct anon_struct_12_3_8c03c973 {
    Cardinal NetN;
    Cardinal NetMax;
    NetTypePtr Net;
};

struct anon_struct_28_7_a511ee14 {
    LocationType X;
    LocationType Y;
    long type;
    void * ptr1;
    void * ptr2;
    Cardinal group;
    LibraryMenuType * menu;
};

typedef struct anon_struct_12_3_93423931 anon_struct_12_3_93423931, *Panon_struct_12_3_93423931;

typedef struct anon_struct_12_3_93423931 * DrillInfoTypePtr;

typedef struct DrillType * DrillTypePtr;

struct anon_struct_12_3_93423931 {
    Cardinal DrillN;
    Cardinal DrillMax;
    DrillTypePtr Drill;
};

typedef struct anon_struct_12_3_0ec9a971 anon_struct_12_3_0ec9a971, *Panon_struct_12_3_0ec9a971;

typedef struct anon_struct_12_3_0ec9a971 * NetListListTypePtr;

typedef struct anon_struct_12_3_8c03c973 * NetListTypePtr;

struct anon_struct_12_3_0ec9a971 {
    Cardinal NetListN;
    Cardinal NetListMax;
    NetListTypePtr NetList;
};

typedef struct BufferType BufferType, *PBufferType;

typedef struct BufferType * BufferTypePtr;

struct BufferType {
    LocationType X;
    LocationType Y;
    struct BoxType BoundingBox;
    DataTypePtr Data;
};

typedef struct BoxListType BoxListType, *PBoxListType;

struct BoxListType {
    Cardinal BoxN;
    Cardinal BoxMax;
    BoxTypePtr Box;
};

typedef struct anon_struct_88_9_2b7d88e2 anon_struct_88_9_2b7d88e2, *Panon_struct_88_9_2b7d88e2;

struct anon_struct_88_9_2b7d88e2 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    char * Number;
};

typedef struct CrosshairType.conflict CrosshairType.conflict, *PCrosshairType.conflict;

typedef struct AttachedBoxType AttachedBoxType, *PAttachedBoxType;

typedef struct AttachedObjectType AttachedObjectType, *PAttachedObjectType;

typedef enum crosshair_shape {
    Basic_Crosshair_Shape=0,
    Union_Jack_Crosshair_Shape=1,
    Dozen_Crosshair_Shape=2,
    Crosshair_Shapes_Number=3
} crosshair_shape;

typedef struct anon_struct_12_3_6cceedd6 * RubberbandTypePtr;

struct AttachedBoxType {
    struct PointType Point1;
    struct PointType Point2;
    long State;
    Boolean otherway;
};

struct AttachedObjectType {
    LocationType X;
    LocationType Y;
    struct BoxType BoundingBox;
    long Type;
    long State;
    void * Ptr1;
    void * Ptr2;
    void * Ptr3;
    Cardinal RubberbandN;
    Cardinal RubberbandMax;
    RubberbandTypePtr Rubberband;
};

struct CrosshairType.conflict {
    hidGC.conflict1 GC;
    hidGC.conflict1 AttachGC;
    LocationType X;
    LocationType Y;
    LocationType MinX;
    LocationType MinY;
    LocationType MaxX;
    LocationType MaxY;
    Boolean On;
    struct AttachedLineType AttachedLine;
    struct AttachedBoxType AttachedBox;
    PolygonType AttachedPolygon;
    struct AttachedObjectType AttachedObject;
    enum crosshair_shape shape;
};

typedef struct BoxListType * BoxListTypePtr;

typedef struct AttributeType * AttributeTypePtr;

typedef struct MarkType MarkType, *PMarkType;

struct MarkType {
    Boolean status;
    long X;
    long Y;
};

typedef struct NetListListType NetListListType, *PNetListListType;

struct NetListListType {
    Cardinal NetListN;
    Cardinal NetListMax;
    NetListTypePtr NetList;
};

typedef struct AttributeListType * AttributeListTypePtr;

typedef struct PointerListType PointerListType, *PPointerListType;

struct PointerListType {
    Cardinal PtrN;
    Cardinal PtrMax;
    void * * Ptr;
};

typedef struct ObjectFunctionType ObjectFunctionType, *PObjectFunctionType;

struct ObjectFunctionType {
    void * (* Line)(LayerTypePtr, LineTypePtr);
    void * (* Text)(LayerTypePtr, TextTypePtr);
    void * (* Polygon)(LayerTypePtr, PolygonTypePtr);
    void * (* Via)(PinTypePtr);
    void * (* Element)(ElementTypePtr);
    void * (* ElementName)(ElementTypePtr);
    void * (* Pin)(ElementTypePtr, PinTypePtr);
    void * (* Pad)(ElementTypePtr, PadTypePtr);
    void * (* LinePoint)(LayerTypePtr, LineTypePtr, PointTypePtr);
    void * (* Point)(LayerTypePtr, PolygonTypePtr, PointTypePtr);
    void * (* Arc)(LayerTypePtr, ArcTypePtr);
    void * (* Rat)(RatTypePtr);
};

typedef struct anon_struct_12_3_1388f4a4 anon_struct_12_3_1388f4a4, *Panon_struct_12_3_1388f4a4;

struct anon_struct_12_3_1388f4a4 {
    Cardinal PtrN;
    Cardinal PtrMax;
    void * * Ptr;
};

typedef struct SymbolType * SymbolTypePtr;

typedef struct ConnectionType ConnectionType, *PConnectionType;

struct ConnectionType {
    LocationType X;
    LocationType Y;
    long type;
    void * ptr1;
    void * ptr2;
    Cardinal group;
    LibraryMenuType * menu;
};

typedef struct PointerListType * PointerListTypePtr;

typedef struct SettingType SettingType, *PSettingType;

struct SettingType {
    Boolean grid_units_mm;
    int verbose;
    char * BlackColor;
    char * WhiteColor;
    char * BackgroundColor;
    char * CrosshairColor;
    char * CrossColor;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * OffLimitColor;
    char * GridColor;
    char * LayerColor[16];
    char * LayerSelectedColor[16];
    char * WarnColor;
    char * MaskColor;
    int ViaThickness;
    int ViaDrillingHole;
    int LineThickness;
    int RatThickness;
    int Keepaway;
    int MaxWidth;
    int MaxHeight;
    int TextScale;
    int AlignmentDistance;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    double Grid;
    double IsleArea;
    double grid_increment_mm;
    double grid_increment_mil;
    double size_increment_mm;
    double size_increment_mil;
    double line_increment_mm;
    double line_increment_mil;
    double clear_increment_mm;
    double clear_increment_mil;
    double Zoom;
    double PinoutZoom;
    int PinoutNameLength;
    int Volume;
    int CharPerLine;
    int Mode;
    int BufferNumber;
    int GridFactor;
    int BackupInterval;
    char * DefaultLayerName[16];
    char * FontCommand;
    char * FileCommand;
    char * ElementCommand;
    char * PrintFile;
    char * LibraryCommandDir;
    char * LibraryCommand;
    char * LibraryContentsCommand;
    char * LibraryTree;
    char * SaveCommand;
    char * LibraryFilename;
    char * FontFile;
    char * Groups;
    char * Routes;
    char * FilePath;
    char * RatPath;
    char * RatCommand;
    char * FontPath;
    char * PinoutFont;
    char * ElementPath;
    char * LibraryPath;
    char * Size;
    char * Media;
    char * MenuFile;
    char * BackgroundImage;
    char * ScriptFilename;
    char * ActionString;
    char * FabAuthor;
    char * InitialLayerStack;
    Boolean DumpMenuFile;
    LocationType PinoutOffsetX;
    LocationType PinoutOffsetY;
    int PinoutTextOffsetX;
    int PinoutTextOffsetY;
    struct RouteStyleType RouteStyle[4];
    struct LayerGroupType LayerGroups;
    Boolean ClearLine;
    Boolean FullPoly;
    Boolean UniqueNames;
    Boolean SnapPin;
    Boolean ShowSolderSide;
    Boolean SaveLastCommand;
    Boolean SaveInTMP;
    Boolean DrawGrid;
    Boolean RatWarn;
    Boolean StipplePolygons;
    Boolean AllDirectionLines;
    Boolean RubberBandMode;
    Boolean SwapStartDirection;
    Boolean ShowDRC;
    Boolean AutoDRC;
    Boolean ShowNumber;
    Boolean OrthogonalMoves;
    Boolean ResetAfterElement;
    Boolean liveRouting;
    Boolean RingBellWhenFinished;
    Boolean AutoPlace;
    int HistorySize;
    int init_done;
};

typedef struct CrosshairType CrosshairType, *PCrosshairType;

struct CrosshairType {
    hidGC GC;
    hidGC AttachGC;
    LocationType X;
    LocationType Y;
    LocationType MinX;
    LocationType MinY;
    LocationType MaxX;
    LocationType MaxY;
    Boolean On;
    struct AttachedLineType AttachedLine;
    struct AttachedBoxType AttachedBox;
    PolygonType AttachedPolygon;
    struct AttachedObjectType AttachedObject;
    enum crosshair_shape shape;
};

typedef struct FontType * FontTypePtr;

typedef struct anon_struct_300_21_d5c1b8b3 * * ElementTypeHandle;

typedef struct OutputType.conflict OutputType.conflict, *POutputType.conflict;

struct OutputType.conflict {
    hidGC.conflict1 bgGC;
    hidGC.conflict1 fgGC;
    hidGC.conflict1 pmGC;
    hidGC.conflict1 GridGC;
    int Width;
    int Height;
    int oldObjState;
    int oldLineState;
    int oldBoxState;
};

typedef struct PCBType * PCBTypePtr;

typedef struct LayerGroupType * LayerGroupTypePtr;

typedef struct toporouter_heap_search_data_t toporouter_heap_search_data_t, *Ptoporouter_heap_search_data_t;

typedef struct _toporouter_vertex_t _toporouter_vertex_t, *P_toporouter_vertex_t;

typedef struct _toporouter_vertex_t toporouter_vertex_t;

typedef struct _toporouter_bbox_t _toporouter_bbox_t, *P_toporouter_bbox_t;

typedef struct _toporouter_edge_t _toporouter_edge_t, *P_toporouter_edge_t;

typedef struct _toporouter_edge_t toporouter_edge_t;

typedef struct _toporouter_arc_t _toporouter_arc_t, *P_toporouter_arc_t;

typedef struct _toporouter_oproute_t _toporouter_oproute_t, *P_toporouter_oproute_t;

typedef struct _toporouter_route_t _toporouter_route_t, *P_toporouter_route_t;

typedef enum toporouter_term_t {
    PAD=0,
    PIN=1,
    VIA=2,
    ARC=3,
    VIA_SHADOW=4,
    LINE=5,
    OTHER=6,
    BOARD=7,
    EXPANSION_AREA=8,
    POLYGON=9,
    TEMP=10
} toporouter_term_t;

typedef struct _toporouter_cluster_t _toporouter_cluster_t, *P_toporouter_cluster_t;

typedef struct _toporouter_oproute_t toporouter_oproute_t;

typedef struct _toporouter_serpintine_t _toporouter_serpintine_t, *P_toporouter_serpintine_t;

typedef struct _toporouter_serpintine_t toporouter_serpintine_t;

typedef struct _toporouter_netlist_t _toporouter_netlist_t, *P_toporouter_netlist_t;

typedef struct _toporouter_netlist_t toporouter_netlist_t;

struct _toporouter_serpintine_t {
    GList * arcs;
    gdouble x;
    gdouble y;
    gdouble x0;
    gdouble y0;
    gdouble x1;
    gdouble y1;
    gpointer start;
    gdouble halfa;
    gdouble radius;
    guint nhalfcycles;
};

struct _toporouter_route_t {
    struct _toporouter_netlist_t * netlist;
    struct _toporouter_cluster_t * src;
    struct _toporouter_cluster_t * dest;
    struct _toporouter_cluster_t * psrc;
    struct _toporouter_cluster_t * pdest;
    gdouble score;
    gdouble detourscore;
    toporouter_vertex_t * curpoint;
    GHashTable * alltemppoints;
    GList * path;
    guint flags;
    GList * destvertices;
    GList * srcvertices;
    GList * topopath;
    gdouble pscore;
    GList * ppath;
    gint * ppathindices;
};

struct _toporouter_arc_t {
    GtsObject object;
    gdouble x0;
    gdouble y0;
    gdouble x1;
    gdouble y1;
    toporouter_vertex_t * centre;
    toporouter_vertex_t * v;
    gdouble r;
    gint dir;
    GList * clearance;
    toporouter_oproute_t * oproute;
    toporouter_vertex_t * v1;
    toporouter_vertex_t * v2;
};

struct _toporouter_oproute_t {
    GList * arcs;
    toporouter_vertex_t * term1;
    toporouter_vertex_t * term2;
    char * style;
    char * netlist;
    guint layergroup;
    gdouble tof;
    GList * path;
    toporouter_serpintine_t * serp;
};

struct _toporouter_netlist_t {
    GPtrArray * clusters;
    GPtrArray * routes;
    char * netlist;
    char * style;
    GList * routed;
};

struct _toporouter_edge_t {
    GtsEdge e;
    guint flags;
    GList * routing;
};

struct _toporouter_bbox_t {
    GtsBBox b;
    enum toporouter_term_t type;
    void * data;
    int layer;
    GtsSurface * surface;
    GtsTriangle * enclosing;
    GList * constraints;
    GtsPoint * point;
    GtsPoint * realpoint;
    struct _toporouter_cluster_t * cluster;
};

struct toporouter_heap_search_data_t {
    toporouter_vertex_t * key;
    toporouter_vertex_t * result;
};

struct _toporouter_cluster_t {
    gint c;
    gint pc;
    GPtrArray * boxes;
    toporouter_netlist_t * netlist;
};

struct _toporouter_vertex_t {
    GtsVertex v;
    struct _toporouter_bbox_t * bbox;
    struct _toporouter_vertex_t * parent;
    struct _toporouter_vertex_t * child;
    toporouter_edge_t * routingedge;
    guint flags;
    gdouble gcost;
    gdouble hcost;
    guint gn;
    struct _toporouter_arc_t * arc;
    struct _toporouter_oproute_t * oproute;
    struct _toporouter_route_t * route;
    gdouble thickness;
};

typedef struct line_info line_info, *Pline_info;

struct line_info {
    LocationType X1;
    LocationType X2;
    LocationType Y1;
    LocationType Y2;
    BDimension Thickness;
    struct FlagType Flags;
    struct LineType test;
    struct LineType * ans;
    jmp_buf env;
};

typedef struct _toporouter_vertex_class_t _toporouter_vertex_class_t, *P_toporouter_vertex_class_t;

typedef struct _toporouter_vertex_class_t toporouter_vertex_class_t;

struct _toporouter_vertex_class_t {
    GtsVertexClass parent_class;
};

typedef struct _toporouter_cluster_t toporouter_cluster_t;

typedef struct _toporouter_bbox_t toporouter_bbox_t;

typedef struct _toporouter_constraint_t _toporouter_constraint_t, *P_toporouter_constraint_t;

typedef struct _toporouter_constraint_t toporouter_constraint_t;

struct _toporouter_constraint_t {
    GtsConstraint c;
    toporouter_bbox_t * box;
    GList * routing;
};

typedef struct toporouter_netscore_t toporouter_netscore_t, *Ptoporouter_netscore_t;

typedef struct _toporouter_route_t toporouter_route_t;

typedef struct _toporouter_t _toporouter_t, *P_toporouter_t;

typedef struct _toporouter_t toporouter_t;

typedef struct toporouter_layer_t toporouter_layer_t, *Ptoporouter_layer_t;

struct toporouter_layer_t {
    GtsSurface * surface;
    GList * vertices;
    GList * constraints;
    GList * edges;
};

struct toporouter_netscore_t {
    guint id;
    guint * pairwise_nodetour;
    gdouble pairwise_detour_sum;
    gdouble score;
    guint pairwise_fails;
    toporouter_route_t * routedata;
    toporouter_t * r;
};

struct _toporouter_t {
    GSList * bboxes;
    GNode * bboxtree;
    struct toporouter_layer_t * layers;
    GList * paths;
    GList * keepoutlayers;
    guint flags;
    GList * destboxes;
    GList * consumeddestboxes;
    guint viamax;
    gdouble viacost;
    gdouble stublength;
    gdouble serpintine_half_amplitude;
    gdouble wiring_score;
    GPtrArray * routes;
    GPtrArray * netlists;
    GList * routednets;
    GList * failednets;
    gint (* netsort)(struct toporouter_netscore_t * *, struct toporouter_netscore_t * *);
    struct timeval starttime;
    FILE * debug;
};

typedef struct _toporouter_edge_class_t _toporouter_edge_class_t, *P_toporouter_edge_class_t;

typedef struct _toporouter_edge_class_t toporouter_edge_class_t;

struct _toporouter_edge_class_t {
    GtsEdgeClass parent_class;
};

typedef struct toporouter_spoint_t toporouter_spoint_t, *Ptoporouter_spoint_t;

struct toporouter_spoint_t {
    gdouble x;
    gdouble y;
};

typedef struct _toporouter_bbox_class_t _toporouter_bbox_class_t, *P_toporouter_bbox_class_t;

struct _toporouter_bbox_class_t {
    GtsBBoxClass parent_class;
};

typedef struct _toporouter_constraint_class_t _toporouter_constraint_class_t, *P_toporouter_constraint_class_t;

typedef struct _toporouter_constraint_class_t toporouter_constraint_class_t;

struct _toporouter_constraint_class_t {
    GtsConstraintClass parent_class;
};

typedef struct _toporouter_arc_class_t _toporouter_arc_class_t, *P_toporouter_arc_class_t;

typedef struct _toporouter_arc_class_t toporouter_arc_class_t;

struct _toporouter_arc_class_t {
    GtsObjectClass parent_class;
    gboolean binary;
};

typedef struct _toporouter_rubberband_arc_t _toporouter_rubberband_arc_t, *P_toporouter_rubberband_arc_t;

struct _toporouter_rubberband_arc_t {
    toporouter_vertex_t * pathv;
    toporouter_vertex_t * arcv;
    gdouble r;
    gdouble d;
    gint wind;
    GList * list;
};

typedef struct drawing_context_t drawing_context_t, *Pdrawing_context_t;

struct drawing_context_t {
    double s;
    int mode;
    void * data;
    char * filename;
    double iw;
    double ih;
};

typedef struct toporouter_vertex_region_t toporouter_vertex_region_t, *Ptoporouter_vertex_region_t;

struct toporouter_vertex_region_t {
    GList * points;
    toporouter_vertex_t * v1;
    toporouter_vertex_t * v2;
    toporouter_vertex_t * origin;
};

typedef struct _toporouter_rubberband_arc_t toporouter_rubberband_arc_t;

typedef struct _toporouter_bbox_class_t toporouter_bbox_class_t;

typedef struct _toporouter_arc_t toporouter_arc_t;

typedef struct PendingDrills PendingDrills, *PPendingDrills;

struct PendingDrills {
    int diam;
    int x;
    int y;
};

typedef struct Apertures Apertures, *PApertures;

struct Apertures {
    int some_apertures;
    int aperture_used[2560];
};

typedef enum ApertureShape {
    ROUND=0,
    OCTAGON=1,
    SQUARE=2,
    ROUNDCLEAR=3,
    SQUARECLEAR=4,
    THERMAL=5
} ApertureShape;

typedef struct _GtkCheckButton _GtkCheckButton, *P_GtkCheckButton;

typedef struct _GtkCheckButton GtkCheckButton;

struct _GtkCheckButton {
    GtkToggleButton toggle_button;
};


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat

typedef union YYSTYPE.conflict1 YYSTYPE.conflict1, *PYYSTYPE.conflict1;

union YYSTYPE.conflict1 {
    int ival;
    char * sval;
    struct Resource * rval;
};

typedef struct rubber_info rubber_info, *Prubber_info;

struct rubber_info {
    int radius;
    LocationType X;
    LocationType Y;
    LineTypePtr line;
    struct BoxType box;
    LayerTypePtr layer;
};

typedef struct rinfo rinfo, *Prinfo;

struct rinfo {
    int type;
    Cardinal group;
    PinTypePtr pin;
    PadTypePtr pad;
    PointTypePtr point;
};

typedef enum PolygonBooleanOperation {
    PBO_UNITE=0,
    PBO_ISECT=1,
    PBO_SUB=2,
    PBO_XOR=3
} PolygonBooleanOperation;

typedef union yyalloc.conflict1 yyalloc.conflict1, *Pyyalloc.conflict1;

union yyalloc.conflict1 {
    yytype_int16 yyss;
    union YYSTYPE.conflict1 yyvs;
};

typedef struct _GtkDialogClass _GtkDialogClass, *P_GtkDialogClass;

struct _GtkDialogClass {
    GtkWindowClass parent_class;
    void (* response)(GtkDialog *, gint);
    void (* close)(GtkDialog *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

typedef struct _GtkDialogClass GtkDialogClass;

typedef struct passwd passwd, *Ppasswd;

struct passwd {
    char * pw_name;
    char * pw_passwd;
    __uid_t pw_uid;
    __gid_t pw_gid;
    char * pw_gecos;
    char * pw_dir;
    char * pw_shell;
};

typedef struct GHidPort GHidPort, *PGHidPort;

typedef struct _GdkCursor _GdkCursor, *P_GdkCursor;

typedef struct _GdkCursor GdkCursor;

struct GHidPort {
    GtkWidget * top_window;
    GtkWidget * drawing_area;
    GdkPixmap * pixmap;
    GdkPixmap * mask;
    GdkDrawable * drawable;
    gint width;
    gint height;
    GdkGC * bg_gc;
    GdkGC * offlimits_gc;
    GdkGC * mask_gc;
    GdkGC * u_gc;
    GdkGC * grid_gc;
    GdkColor bg_color;
    GdkColor offlimits_color;
    GdkColor grid_color;
    GdkColormap * colormap;
    GdkCursor * X_cursor;
    enum GdkCursorType X_cursor_shape;
    gboolean has_entered;
    gboolean panning;
    gdouble zoom;
    gint view_x0;
    gint view_y0;
    gint view_width;
    gint view_height;
    gint view_x;
    gint view_y;
    gint x_crosshair;
    gint y_crosshair;
};

struct _GdkCursor {
    enum GdkCursorType type;
    guint ref_count;
};

typedef struct GhidGui GhidGui, *PGhidGui;

typedef struct _GtkEntry _GtkEntry, *P_GtkEntry;

typedef struct _GtkEntry GtkEntry;

typedef struct _GdkPixbuf _GdkPixbuf, *P_GdkPixbuf;

typedef struct _GdkPixbuf GdkPixbuf;

struct _GdkPixbuf {
};

struct _GtkEntry {
    GtkWidget widget;
    gchar * text;
    guint editable:1;
    guint visible:1;
    guint overwrite_mode:1;
    guint in_drag:1;
    guint16 text_length;
    guint16 text_max_length;
    GdkWindow * text_area;
    GtkIMContext * im_context;
    GtkWidget * popup_menu;
    gint current_pos;
    gint selection_bound;
    PangoLayout * cached_layout;
    guint cache_includes_preedit:1;
    guint need_im_reset:1;
    guint has_frame:1;
    guint activates_default:1;
    guint cursor_visible:1;
    guint in_click:1;
    guint is_cell_renderer:1;
    guint editing_canceled:1;
    guint mouse_cursor_obscured:1;
    guint select_words:1;
    guint select_lines:1;
    guint resolved_dir:4;
    guint truncate_multiline:1;
    guint button;
    guint blink_timeout;
    guint recompute_idle;
    gint scroll_offset;
    gint ascent;
    gint descent;
    guint16 x_text_size;
    guint16 x_n_bytes;
    guint16 preedit_length;
    guint16 preedit_cursor;
    gint dnd_position;
    gint drag_start_x;
    gint drag_start_y;
    gunichar invisible_char;
    gint width_chars;
};

struct GhidGui {
    GtkUIManager * ui_manager;
    GtkActionGroup * main_actions;
    GtkActionGroup * grid_actions;
    GtkActionGroup * change_selected_actions;
    GtkActionGroup * displayed_name_actions;
    GtkWidget * name_label;
    GtkWidget * status_line_label;
    GtkWidget * cursor_position_relative_label;
    GtkWidget * cursor_position_absolute_label;
    GtkWidget * grid_units_label;
    GtkWidget * status_line_hbox;
    GtkWidget * command_combo_box;
    GtkEntry * command_entry;
    GtkWidget * top_hbox;
    GtkWidget * menu_hbox;
    GtkWidget * compact_vbox;
    GtkWidget * compact_hbox;
    GtkWidget * position_hbox;
    GtkWidget * label_hbox;
    GtkWidget * mode_buttons0_vbox;
    GtkWidget * mode_buttons1_hbox;
    GtkWidget * mode_buttons1_vbox;
    GtkWidget * mode_buttons0_frame;
    GtkWidget * mode_buttons1_frame;
    GtkWidget * mode_buttons0_frame_vbox;
    GtkWidget * h_range;
    GtkWidget * v_range;
    GtkObject * h_adjustment;
    GtkObject * v_adjustment;
    GdkPixbuf * bg_pixbuf;
    gchar * name_label_string;
    gboolean adjustment_changed_holdoff;
    gboolean toggle_holdoff;
    gboolean command_entry_status_line_active;
    gboolean auto_pan_on;
    gboolean in_popup;
    gboolean combine_adjustments;
    gboolean config_modified;
    gboolean small_label_markup;
    gboolean compact_horizontal;
    gboolean compact_vertical;
    gboolean ghid_title_window;
    gboolean use_command_window;
    gboolean need_restore_crosshair;
    gboolean creating;
    gint n_mode_button_columns;
    gint top_window_width;
    gint top_window_height;
    gint log_window_width;
    gint log_window_height;
    gint drc_window_width;
    gint drc_window_height;
    gint keyref_window_width;
    gint keyref_window_height;
    gint library_window_width;
    gint library_window_height;
    gint netlist_window_height;
    gint history_size;
    gint settings_mode;
    gint auto_pan_speed;
};

typedef enum ModifierKeysState {
    NONE_PRESSED=0,
    SHIFT_PRESSED=1,
    CONTROL_PRESSED=2,
    SHIFT_CONTROL_PRESSED=3,
    MOD1_PRESSED=4,
    SHIFT_MOD1_PRESSED=5,
    CONTROL_MOD1_PRESSED=6,
    SHIFT_CONTROL_MOD1_PRESSED=7
} ModifierKeysState;

typedef enum ButtonState {
    NO_BUTTON_PRESSED=0,
    BUTTON1_PRESSED=1,
    BUTTON2_PRESSED=2,
    BUTTON3_PRESSED=3
} ButtonState;

typedef struct ConfigColor ConfigColor, *PConfigColor;

typedef enum ColorTypes {
    MISC_COLOR=0,
    MISC_SELECTED_COLOR=1,
    LAYER_COLOR=2,
    LAYER_SELECTED_COLOR=3
} ColorTypes;

struct ConfigColor {
    struct HID_Attribute * attributes;
    enum ColorTypes type;
    GdkColor color;
    gboolean color_is_mapped;
};

typedef enum ConfigType {
    CONFIG_Boolean=0,
    CONFIG_Integer=1,
    CONFIG_Real=2,
    CONFIG_String=3,
    CONFIG_Unused=4
} ConfigType;

typedef struct ConfigAttribute ConfigAttribute, *PConfigAttribute;

struct ConfigAttribute {
    gchar * name;
    enum ConfigType type;
    void * value;
};

typedef struct DBusMessageIter DBusMessageIter, *PDBusMessageIter;

struct DBusMessageIter {
    void * dummy1;
    void * dummy2;
    dbus_uint32_t dummy3;
    int dummy4;
    int dummy5;
    int dummy6;
    int dummy7;
    int dummy8;
    int dummy9;
    int dummy10;
    int dummy11;
    int pad1;
    int pad2;
    void * pad3;
};

typedef struct _GtkFileChooser _GtkFileChooser, *P_GtkFileChooser;

struct _GtkFileChooser {
};

typedef struct _GtkEditable _GtkEditable, *P_GtkEditable;

struct _GtkEditable {
};

typedef struct _GtkMenu _GtkMenu, *P_GtkMenu;

typedef struct _GtkMenu GtkMenu;

typedef struct _GtkAccelGroup _GtkAccelGroup, *P_GtkAccelGroup;

typedef struct _GtkAccelGroup GtkAccelGroup;

typedef void (* GtkMenuPositionFunc)(GtkMenu *, gint *, gint *, gboolean *, gpointer);

typedef struct _GtkAccelGroupEntry _GtkAccelGroupEntry, *P_GtkAccelGroupEntry;

typedef struct _GtkAccelGroupEntry GtkAccelGroupEntry;

typedef struct _GtkAccelKey _GtkAccelKey, *P_GtkAccelKey;

typedef struct _GtkAccelKey GtkAccelKey;

struct _GtkAccelKey {
    guint accel_key;
    enum GdkModifierType accel_mods;
    guint accel_flags:16;
};

struct _GtkAccelGroupEntry {
    GtkAccelKey key;
    GClosure * closure;
    GQuark accel_path_quark;
};

struct _GtkMenu {
    GtkMenuShell menu_shell;
    GtkWidget * parent_menu_item;
    GtkWidget * old_active_menu_item;
    GtkAccelGroup * accel_group;
    gchar * accel_path;
    GtkMenuPositionFunc position_func;
    gpointer position_func_data;
    guint toggle_size;
    GtkWidget * toplevel;
    GtkWidget * tearoff_window;
    GtkWidget * tearoff_hbox;
    GtkWidget * tearoff_scrollbar;
    GtkAdjustment * tearoff_adjustment;
    GdkWindow * view_window;
    GdkWindow * bin_window;
    gint scroll_offset;
    gint saved_scroll_offset;
    gint scroll_step;
    guint timeout_id;
    GdkRegion * navigation_region;
    guint navigation_timeout;
    guint needs_destruction_ref_count:1;
    guint torn_off:1;
    guint tearoff_active:1;
    guint scroll_fast:1;
    guint upper_arrow_visible:1;
    guint lower_arrow_visible:1;
    guint upper_arrow_prelight:1;
    guint lower_arrow_prelight:1;
};

struct _GtkAccelGroup {
    GObject parent;
    guint lock_count;
    enum GdkModifierType modifier_mask;
    GSList * acceleratables;
    guint n_accels;
    GtkAccelGroupEntry * priv_accels;
};

typedef struct _GtkTreeSortable _GtkTreeSortable, *P_GtkTreeSortable;

struct _GtkTreeSortable {
};

typedef struct gdPoint gdPoint, *PgdPoint;

struct gdPoint {
    int x;
    int y;
};

typedef struct _GtkEditable GtkEditable;

typedef struct _GtkListStore _GtkListStore, *P_GtkListStore;

typedef struct _GtkListStore GtkListStore;

struct _GtkListStore {
    GObject parent;
    gint stamp;
    gpointer seq;
    gpointer _gtk_reserved1;
    GList * sort_list;
    gint n_columns;
    gint sort_column_id;
    enum GtkSortType order;
    GType * column_headers;
    gint length;
    GtkTreeIterCompareFunc default_sort_func;
    gpointer default_sort_data;
    GDestroyNotify default_sort_destroy;
    guint columns_dirty:1;
};

typedef struct _GtkViewport _GtkViewport, *P_GtkViewport;

struct _GtkViewport {
    GtkBin bin;
    enum GtkShadowType shadow_type;
    GdkWindow * view_window;
    GdkWindow * bin_window;
    GtkAdjustment * hadjustment;
    GtkAdjustment * vadjustment;
};

typedef struct _GtkRadioButton _GtkRadioButton, *P_GtkRadioButton;

struct _GtkRadioButton {
    GtkCheckButton check_button;
    GSList * group;
};

typedef struct _GdkPoint _GdkPoint, *P_GdkPoint;

typedef struct _GdkPoint GdkPoint;

struct _GdkPoint {
    gint x;
    gint y;
};

typedef struct hostent hostent, *Phostent;

struct hostent {
    char * h_name;
    char * * h_aliases;
    int h_addrtype;
    int h_length;
    char * * h_addr_list;
};

typedef struct _GhidLibraryWindowClass _GhidLibraryWindowClass, *P_GhidLibraryWindowClass;

typedef struct _GhidLibraryWindowClass GhidLibraryWindowClass;

struct _GhidLibraryWindowClass {
    GtkDialogClass parent_class;
};

typedef struct _GhidLibraryWindow _GhidLibraryWindow, *P_GhidLibraryWindow;

typedef struct _GhidLibraryWindow GhidLibraryWindow;

struct _GhidLibraryWindow {
    GtkDialog parent_instance;
    GtkWidget * hpaned;
    GtkTreeView * libtreeview;
    GtkNotebook * viewtabs;
    GtkWidget * preview;
    GtkEntry * entry_filter;
    GtkButton * button_clear;
    guint filter_timeout;
};

typedef struct mptlc mptlc, *Pmptlc;

struct mptlc {
    Cardinal snum;
    Cardinal dnum;
    int type;
    PolygonTypePtr polygon;
};

typedef struct via_info via_info, *Pvia_info;

struct via_info {
    LocationType X;
    LocationType Y;
    jmp_buf env;
};

typedef enum DIRECTION {
    FORW=0,
    BACKW=1
} DIRECTION;

typedef int (* S_Rule)(struct VNODE *, enum DIRECTION *);

typedef struct pip pip, *Ppip;

struct pip {
    int f;
    Vector p;
    jmp_buf env;
};

typedef struct seg seg, *Pseg;

struct seg {
    struct BoxType box;
    struct VNODE * v;
    struct PLINE * p;
};

typedef struct info info, *Pinfo;

struct info {
    double m;
    double b;
    rtree_t * tree;
    struct VNODE * v;
    struct seg * s;
    jmp_buf env;
    jmp_buf sego;
    jmp_buf * touch;
};

typedef int (* J_Rule)(char, struct VNODE *, enum DIRECTION *);

typedef struct ModeButton ModeButton, *PModeButton;

struct ModeButton {
    GtkWidget * button;
    GtkWidget * box0;
    GtkWidget * box1;
    gchar * name;
    gint mode;
    gchar * * xpm;
};

typedef struct LayerButtonSet LayerButtonSet, *PLayerButtonSet;

struct LayerButtonSet {
    GtkWidget * radio_select_button;
    GtkWidget * layer_enable_button;
    GtkWidget * layer_enable_ebox;
    GtkWidget * label;
    gchar * text;
    gint index;
};

typedef struct RouteStyleButton RouteStyleButton, *PRouteStyleButton;

struct RouteStyleButton {
    GtkWidget * button;
    struct RouteStyleType route_style;
    gboolean shown;
};

typedef struct KeyTable KeyTable, *PKeyTable;

struct KeyTable {
    char in;
    char * out;
};

typedef struct ToggleFlagType ToggleFlagType, *PToggleFlagType;

typedef enum MenuFlagType {
    GHID_FLAG_ACTIVE=0,
    GHID_FLAG_CHECKED=1,
    GHID_FLAG_VISIBLE=2
} MenuFlagType;

struct ToggleFlagType {
    char * actionname;
    char * flagname;
    enum MenuFlagType flagtype;
    int oldval;
    char * xres;
};


// WARNING! conflicting data type names: /DWARF/gui-top-window.c/add_resource_to_menu/lexical_block_0/anon_enum_32 - /DWARF/hid.h/anon_enum_32

typedef struct SegmentTree SegmentTree, *PSegmentTree;

typedef struct SegmentTreeNode SegmentTreeNode, *PSegmentTreeNode;

struct SegmentTree {
    struct SegmentTreeNode * nodes;
    int size;
};

struct SegmentTreeNode {
    LocationType left;
    LocationType right;
    int covered;
    int area;
};

typedef struct LocationList LocationList, *PLocationList;

struct LocationList {
    LocationType * p;
    int size;
};

typedef enum FunctionID {
    F_AddSelected=0,
    F_All=1,
    F_AllConnections=2,
    F_AllRats=3,
    F_AllUnusedPins=4,
    F_Arc=5,
    F_Arrow=6,
    F_Block=7,
    F_Description=8,
    F_Cancel=9,
    F_Center=10,
    F_Clear=11,
    F_ClearAndRedraw=12,
    F_ClearList=13,
    F_Close=14,
    F_Connection=15,
    F_Convert=16,
    F_Copy=17,
    F_CycleClip=18,
    F_CycleCrosshair=19,
    F_DeleteRats=20,
    F_Drag=21,
    F_DrillReport=22,
    F_Element=23,
    F_ElementByName=24,
    F_ElementConnections=25,
    F_ElementToBuffer=26,
    F_Escape=27,
    F_Find=28,
    F_FlipElement=29,
    F_FoundPins=30,
    F_Grid=31,
    F_InsertPoint=32,
    F_Layer=33,
    F_Layout=34,
    F_LayoutAs=35,
    F_LayoutToBuffer=36,
    F_Line=37,
    F_LineSize=38,
    F_Lock=39,
    F_Mirror=40,
    F_Move=41,
    F_NameOnPCB=42,
    F_Netlist=43,
    F_None=44,
    F_Notify=45,
    F_Object=46,
    F_ObjectByName=47,
    F_PasteBuffer=48,
    F_PadByName=49,
    F_PinByName=50,
    F_PinOrPadName=51,
    F_Pinout=52,
    F_Polygon=53,
    F_PreviousPoint=54,
    F_RatsNest=55,
    F_Rectangle=56,
    F_Redraw=57,
    F_Release=58,
    F_Revert=59,
    F_Remove=60,
    F_RemoveSelected=61,
    F_Report=62,
    F_Reset=63,
    F_ResetLinesAndPolygons=64,
    F_ResetPinsViasAndPads=65,
    F_Restore=66,
    F_Rotate=67,
    F_Save=68,
    F_Scroll=69,
    F_Selected=70,
    F_SelectedArcs=71,
    F_SelectedElements=72,
    F_SelectedLines=73,
    F_SelectedNames=74,
    F_SelectedObjects=75,
    F_SelectedPads=76,
    F_SelectedPins=77,
    F_SelectedTexts=78,
    F_SelectedVias=79,
    F_SelectedRats=80,
    F_Stroke=81,
    F_Text=82,
    F_TextByName=83,
    F_TextScale=84,
    F_Thermal=85,
    F_ToLayout=86,
    F_ToggleAllDirections=87,
    F_ToggleAutoDRC=88,
    F_ToggleClearLine=89,
    F_ToggleFullPoly=90,
    F_ToggleGrid=91,
    F_ToggleHideNames=92,
    F_ToggleMask=93,
    F_ToggleName=94,
    F_ToggleObject=95,
    F_ToggleShowDRC=96,
    F_ToggleLiveRoute=97,
    F_ToggleRubberBandMode=98,
    F_ToggleStartDirection=99,
    F_ToggleSnapPin=100,
    F_ToggleThindraw=101,
    F_ToggleLockNames=102,
    F_ToggleOnlyNames=103,
    F_ToggleThindrawPoly=104,
    F_ToggleOrthoMove=105,
    F_ToggleLocalRef=106,
    F_ToggleCheckPlanes=107,
    F_ToggleUniqueNames=108,
    F_Via=109,
    F_ViaByName=110,
    F_Value=111,
    F_ViaDrillingHole=112,
    F_ViaSize=113,
    F_Zoom=114
} FunctionID;

typedef struct anon_struct_32_9_d03d37f0 anon_struct_32_9_d03d37f0, *Panon_struct_32_9_d03d37f0;

struct anon_struct_32_9_d03d37f0 {
    int X;
    int Y;
    Cardinal Buffer;
    Boolean Click;
    Boolean Moving;
    int Hit;
    void * ptr1;
    void * ptr2;
    void * ptr3;
};

typedef struct FunctionType FunctionType, *PFunctionType;

struct FunctionType {
    char * Identifier;
    enum FunctionID ID;
};

typedef struct anon_struct_92_2_38da13c5 anon_struct_92_2_38da13c5, *Panon_struct_92_2_38da13c5;

struct anon_struct_92_2_38da13c5 {
    PolygonTypePtr poly;
    struct LineType line;
};

typedef struct _cnt_list _cnt_list, *P_cnt_list;

struct _cnt_list {
    char * name;
    uint cnt;
};

typedef struct centroid centroid, *Pcentroid;

struct centroid {
    float x;
    float y;
    float area;
};

typedef struct r_arg r_arg, *Pr_arg;

struct r_arg {
    int (* check_it)(struct BoxType *, void *);
    int (* found_it)(struct BoxType *, void *);
    void * closure;
};

typedef struct _GtkSpinButton _GtkSpinButton, *P_GtkSpinButton;

typedef enum GtkSpinButtonUpdatePolicy {
    GTK_UPDATE_ALWAYS=0,
    GTK_UPDATE_IF_VALID=1
} GtkSpinButtonUpdatePolicy;

struct _GtkSpinButton {
    GtkEntry entry;
    GtkAdjustment * adjustment;
    GdkWindow * panel;
    guint32 timer;
    gdouble climb_rate;
    gdouble timer_step;
    enum GtkSpinButtonUpdatePolicy update_policy;
    guint in_child:2;
    guint click_child:2;
    guint button:2;
    guint need_timer:1;
    guint timer_calls:3;
    guint digits:10;
    guint numeric:1;
    guint wrap:1;
    guint snap_to_ticks:1;
};

typedef struct _GtkSpinButton GtkSpinButton;

typedef dbus_uint32_t dbus_bool_t;


// WARNING! conflicting data type names: /time.h/timeval - /DWARF/time.h/timeval

typedef struct timezone timezone, *Ptimezone;

typedef struct timezone * __timezone_ptr_t;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char * tm_zone;
};


// WARNING! conflicting data type names: /time.h/time_t - /DWARF/time.h/time_t


// WARNING! conflicting data type names: /stdio.h/FILE - /DWARF/stdio.h/FILE

typedef int __pid_t;


// WARNING! conflicting data type names: /types.h/__suseconds_t - /DWARF/__suseconds_t

typedef int __int32_t;

typedef void (* __sighandler_t)(int);

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;


// WARNING! conflicting data type names: /dirent.h/__dirstream - /DWARF/_UNCATEGORIZED_/__dirstream


// WARNING! conflicting data type names: /dirent.h/DIR - /DWARF/dirent.h/DIR


// WARNING! conflicting data type names: /dirent.h/dirent - /DWARF/dirent.h/dirent


// WARNING! conflicting data type names: /regex.h/re_pattern_buffer - /DWARF/regex.h/re_pattern_buffer


// WARNING! conflicting data type names: /regex.h/regex_t - /DWARF/regex.h/regex_t


// WARNING! conflicting data type names: /regex.h/reg_syntax_t - /DWARF/reg_syntax_t

typedef int (* __compar_fn_t)(void *, void *);

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_x86 {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType_x86;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_x86 sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Dyn_x86 Elf32_Dyn_x86, *PElf32_Dyn_x86;

typedef enum Elf32_DynTag_x86 {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf32_DynTag_x86;

struct Elf32_Dyn_x86 {
    enum Elf32_DynTag_x86 d_tag;
    dword d_val;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

typedef enum Elf_ProgramHeaderType_x86 {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType_x86;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_x86 p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct NoteAbiTag NoteAbiTag, *PNoteAbiTag;

struct NoteAbiTag {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    dword abiType; // 0 == Linux
    dword requiredKernelVersion[3]; // Major.minor.patch
};

typedef struct Elf32_Rel Elf32_Rel, *PElf32_Rel;

struct Elf32_Rel {
    dword r_offset; // location to apply the relocation action
    dword r_info; // the symbol table index and the type of relocation
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iStack_c;
  
  __gmon_start__();
  frame_dummy();
  __do_global_ctors_aux();
  return iStack_c;
}



void FUN_0805e768(void)

{
                    // WARNING: Treating indirect jump as call
  (*(code *)(undefined *)0x0)();
  return;
}



void g_param_spec_object(void)

{
  g_param_spec_object();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



void g_utf8_validate(void)

{
  g_utf8_validate();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void abort(void)

{
                    // WARNING: Subroutine does not return
  abort();
}



void gtk_tree_view_get_model(void)

{
  gtk_tree_view_get_model();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



void g_free(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gdk_beep(void)

{
  gdk_beep();
  return;
}



void gdk_window_invalidate_rect(void)

{
  gdk_window_invalidate_rect();
  return;
}



void gtk_tree_view_column_set_attributes(void)

{
  gtk_tree_view_column_set_attributes();
  return;
}



void gdk_color_parse(void)

{
  gdk_color_parse();
  return;
}



void gtk_tree_row_reference_free(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_get_current_event_time(void)

{
  gtk_get_current_event_time();
  return;
}



void gtk_label_set_use_markup(void)

{
  gtk_label_set_use_markup();
  return;
}



void gdImageFillToBorder(void)

{
  gdImageFillToBorder();
  return;
}



void g_slist_remove(void)

{
  g_slist_remove();
  return;
}



void gdk_draw_polygon(void)

{
  gdk_draw_polygon();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * popen(char *__command,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = popen(__command,__modes);
  return pFVar1;
}



void g_value_unset(void)

{
  g_value_unset();
  return;
}



void gtk_text_view_get_type(void)

{
  gtk_text_view_get_type();
  return;
}



void gtk_tree_selection_select_path(void)

{
  gtk_tree_selection_select_path();
  return;
}



void g_io_channel_shutdown(void)

{
  g_io_channel_shutdown();
  return;
}



void g_path_get_dirname(void)

{
  g_path_get_dirname();
  return;
}



void gtk_tree_model_get_iter_first(void)

{
  gtk_tree_model_get_iter_first();
  return;
}



void gtk_table_attach_defaults(void)

{
  gtk_table_attach_defaults();
  return;
}



void gtk_entry_new(void)

{
  gtk_entry_new();
  return;
}



void g_param_spec_string(void)

{
  g_param_spec_string();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



void g_list_find(void)

{
  g_list_find();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int mkdir(char *__path,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = mkdir(__path,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



void dbus_connection_unref(void)

{
  dbus_connection_unref();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void setbuf(FILE *__stream,char *__buf)

{
  setbuf(__stream,__buf);
  return;
}



void __cxa_atexit(void)

{
  __cxa_atexit();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void regfree(regex_t *__preg)

{
  regfree(__preg);
  return;
}



void gtk_vbox_get_type(void)

{
  gtk_vbox_get_type();
  return;
}



void gtk_dialog_set_default_response(void)

{
  gtk_dialog_set_default_response();
  return;
}



void gtk_bin_get_child(void)

{
  gtk_bin_get_child();
  return;
}



void gdk_display_get_default(void)

{
  gdk_display_get_default();
  return;
}



void gtk_box_get_type(void)

{
  gtk_box_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



void g_direct_equal(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_scale_set_digits(void)

{
  gtk_scale_set_digits();
  return;
}



void gtk_window_new(void)

{
  gtk_window_new();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double asin(double __x)

{
  longdouble extraout_ST0;
  
  asin(__x);
  return (double)extraout_ST0;
}



void gdImageDestroy(void)

{
  gdImageDestroy();
  return;
}



void gdk_pixbuf_get_height(void)

{
  gdk_pixbuf_get_height();
  return;
}



void g_slist_free(void)

{
  g_slist_free();
  return;
}



void __longjmp_chk(void)

{
                    // WARNING: Subroutine does not return
  __longjmp_chk();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long random(void)

{
  long lVar1;
  
  lVar1 = random();
  return lVar1;
}



void g_value_dup_string(void)

{
  g_value_dup_string();
  return;
}



void gtk_scale_get_type(void)

{
  gtk_scale_get_type();
  return;
}



void g_hash_table_destroy(void)

{
  g_hash_table_destroy();
  return;
}



void g_str_hash(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_color_button_set_title(void)

{
  gtk_color_button_set_title();
  return;
}



void g_path_get_basename(void)

{
  g_path_get_basename();
  return;
}



void gtk_tree_view_expand_row(void)

{
  gtk_tree_view_expand_row();
  return;
}



void gdk_gc_copy(void)

{
  gdk_gc_copy();
  return;
}



void g_main_loop_quit(void)

{
  g_main_loop_quit();
  return;
}



void g_io_channel_unix_new(void)

{
  g_io_channel_unix_new();
  return;
}



void gtk_window_get_position(void)

{
  gtk_window_get_position();
  return;
}



void gdk_pixbuf_new_from_file(void)

{
  gdk_pixbuf_new_from_file();
  return;
}



void gtk_tree_sortable_get_type(void)

{
  gtk_tree_sortable_get_type();
  return;
}



void __fprintf_chk(void)

{
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

float sqrtf(float __x)

{
  longdouble extraout_ST0;
  
  sqrtf(__x);
  return (float)extraout_ST0;
}



void gtk_toggle_button_get_active(void)

{
  gtk_toggle_button_get_active();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  __sighandler_t p_Var1;
  
  p_Var1 = signal(__sig,__handler);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __xstat(int __ver,char *__filename,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat(__ver,__filename,__stat_buf);
  return iVar1;
}



void gtk_cell_renderer_text_new(void)

{
  gtk_cell_renderer_text_new();
  return;
}



void __gmon_start__(void)

{
  __gmon_start__();
  return;
}



void gtk_tooltips_new(void)

{
  gtk_tooltips_new();
  return;
}



void gtk_button_box_get_type(void)

{
  gtk_button_box_get_type();
  return;
}



void g_object_unref(void)

{
  g_object_unref();
  return;
}



void gtk_label_new(void)

{
  gtk_label_new();
  return;
}



void gtk_dialog_response(void)

{
  gtk_dialog_response();
  return;
}



void gtk_table_get_type(void)

{
  gtk_table_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



void g_slist_reverse(void)

{
  g_slist_reverse();
  return;
}



void gtk_window_remove_accel_group(void)

{
  gtk_window_remove_accel_group();
  return;
}



void gtk_file_filter_add_mime_type(void)

{
  gtk_file_filter_add_mime_type();
  return;
}



void gtk_signal_connect_full(void)

{
  gtk_signal_connect_full();
  return;
}



void gtk_vbox_new(void)

{
  gtk_vbox_new();
  return;
}



void gtk_range_set_increments(void)

{
  gtk_range_set_increments();
  return;
}



void __isoc99_sscanf(void)

{
  __isoc99_sscanf();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * localtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = localtime(__timer);
  return ptVar1;
}



void g_strdup(void)

{
  g_strdup();
  return;
}



void gdk_drawable_get_depth(void)

{
  gdk_drawable_get_depth();
  return;
}



void dbus_shutdown(void)

{
  dbus_shutdown();
  return;
}



void gtk_entry_set_text(void)

{
  gtk_entry_set_text();
  return;
}



void g_value_set_boolean(void)

{
  g_value_set_boolean();
  return;
}



void gtk_combo_box_new_text(void)

{
  gtk_combo_box_new_text();
  return;
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



void gtk_tree_view_insert_column_with_attributes(void)

{
  gtk_tree_view_insert_column_with_attributes();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __isinf(double __value)

{
  int iVar1;
  
  iVar1 = __isinf(__value);
  return iVar1;
}



void gtk_ui_manager_new(void)

{
  gtk_ui_manager_new();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  longdouble extraout_ST0;
  
  strtod(__nptr,__endptr);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



void dbus_message_new_method_return(void)

{
  dbus_message_new_method_return();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



void gtk_main(void)

{
  gtk_main();
  return;
}



void g_value_get_double(void)

{
  g_value_get_double();
  return;
}



void dbus_error_init(void)

{
  dbus_error_init();
  return;
}



void gdk_gc_set_function(void)

{
  gdk_gc_set_function();
  return;
}



void gtk_widget_get_type(void)

{
  gtk_widget_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



void gdk_drawable_get_type(void)

{
  gdk_drawable_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



void gtk_widget_modify_fg(void)

{
  gtk_widget_modify_fg();
  return;
}



void gtk_widget_destroy(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_button_new(void)

{
  gtk_button_new();
  return;
}



void dbus_watch_set_data(void)

{
  dbus_watch_set_data();
  return;
}



void dbus_watch_get_enabled(void)

{
  dbus_watch_get_enabled();
  return;
}



void g_list_foreach(void)

{
  g_list_foreach();
  return;
}



void g_hash_table_insert(void)

{
  g_hash_table_insert();
  return;
}



void g_list_free(void)

{
  g_list_free();
  return;
}



void gtk_image_new_from_stock(void)

{
  gtk_image_new_from_stock();
  return;
}



void gtk_combo_box_entry_new_text(void)

{
  gtk_combo_box_entry_new_text();
  return;
}



void g_ptr_array_remove_index(void)

{
  g_ptr_array_remove_index();
  return;
}



void gdk_flush(void)

{
  gdk_flush();
  return;
}



void g_strconcat(void)

{
  g_strconcat();
  return;
}



void gdk_cursor_new_from_pixmap(void)

{
  gdk_cursor_new_from_pixmap();
  return;
}



void gtk_ui_manager_insert_action_group(void)

{
  gtk_ui_manager_insert_action_group();
  return;
}



void dbus_watch_get_unix_fd(void)

{
  dbus_watch_get_unix_fd();
  return;
}



void dbus_bus_release_name(void)

{
  dbus_bus_release_name();
  return;
}



void gtk_label_set_justify(void)

{
  gtk_label_set_justify();
  return;
}



void g_node_prepend(void)

{
  g_node_prepend();
  return;
}



void gtk_tree_sortable_set_sort_column_id(void)

{
  gtk_tree_sortable_set_sort_column_id();
  return;
}



void gtk_notebook_get_nth_page(void)

{
  gtk_notebook_get_nth_page();
  return;
}



void gtk_file_chooser_get_type(void)

{
  gtk_file_chooser_get_type();
  return;
}



void gtk_toggle_action_set_active(void)

{
  gtk_toggle_action_set_active();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



void g_hash_table_find(void)

{
  g_hash_table_find();
  return;
}



void dbus_bus_get_private(void)

{
  dbus_bus_get_private();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int regexec(regex_t *__preg,char *__string,size_t __nmatch,regmatch_t *__pmatch,int __eflags)

{
  int iVar1;
  
  iVar1 = regexec(__preg,__string,__nmatch,__pmatch,__eflags);
  return iVar1;
}



void gtk_notebook_new(void)

{
  gtk_notebook_new();
  return;
}



void dbus_error_is_set(void)

{
  dbus_error_is_set();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



void gdk_cursor_new(void)

{
  gdk_cursor_new();
  return;
}



void dbus_watch_get_flags(void)

{
  dbus_watch_get_flags();
  return;
}



void dbus_connection_send(void)

{
  dbus_connection_send();
  return;
}



void gtk_file_filter_new(void)

{
  gtk_file_filter_new();
  return;
}



void gtk_label_set_text(void)

{
  gtk_label_set_text();
  return;
}



void gtk_dialog_get_type(void)

{
  gtk_dialog_get_type();
  return;
}



void gdk_colormap_free_colors(void)

{
  gdk_colormap_free_colors();
  return;
}



void gtk_scrolled_window_set_policy(void)

{
  gtk_scrolled_window_set_policy();
  return;
}



void dbus_connection_flush(void)

{
  dbus_connection_flush();
  return;
}



void gdk_draw_arc(void)

{
  gdk_draw_arc();
  return;
}



void gtk_tree_view_column_get_type(void)

{
  gtk_tree_view_column_get_type();
  return;
}



void g_object_class_install_property(void)

{
  g_object_class_install_property();
  return;
}



void gtk_hscrollbar_new(void)

{
  gtk_hscrollbar_new();
  return;
}



void gtk_text_buffer_create_tag(void)

{
  gtk_text_buffer_create_tag();
  return;
}



void gtk_editable_get_chars(void)

{
  gtk_editable_get_chars();
  return;
}



void gtk_widget_modify_bg(void)

{
  gtk_widget_modify_bg();
  return;
}



void __libc_start_main(void)

{
  __libc_start_main();
  return;
}



void gtk_tree_store_new(void)

{
  gtk_tree_store_new();
  return;
}



void gtk_table_new(void)

{
  gtk_table_new();
  return;
}



void g_ptr_array_foreach(void)

{
  g_ptr_array_foreach();
  return;
}



void gdImageGif(void)

{
  gdImageGif();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _IO_getc(_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_getc(__fp);
  return iVar1;
}



void g_malloc(void)

{
  g_malloc();
  return;
}



void gtk_dialog_new_with_buttons(void)

{
  gtk_dialog_new_with_buttons();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double floor(double __x)

{
  longdouble extraout_ST0;
  
  floor(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * stpcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = stpcpy(__dest,__src);
  return pcVar1;
}



void gdk_cursor_unref(void)

{
  gdk_cursor_unref();
  return;
}



void gdImageFilledEllipse(void)

{
  gdImageFilledEllipse();
  return;
}



void gtk_timeout_add(void)

{
  gtk_timeout_add();
  return;
}



void gtk_menu_get_type(void)

{
  gtk_menu_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



void dbus_message_unref(void)

{
  dbus_message_unref();
  return;
}



void g_string_new(void)

{
  g_string_new();
  return;
}



void gtk_notebook_append_page(void)

{
  gtk_notebook_append_page();
  return;
}



void g_hash_table_remove(void)

{
  g_hash_table_remove();
  return;
}



void gtk_file_chooser_get_current_folder(void)

{
  gtk_file_chooser_get_current_folder();
  return;
}



void gtk_message_dialog_new(void)

{
  gtk_message_dialog_new();
  return;
}



void gtk_file_chooser_set_current_folder(void)

{
  gtk_file_chooser_set_current_folder();
  return;
}



void gtk_viewport_new(void)

{
  gtk_viewport_new();
  return;
}



void gtk_spin_button_get_value_as_int(void)

{
  gtk_spin_button_get_value_as_int();
  return;
}



void g_list_copy(void)

{
  g_list_copy();
  return;
}



void bindtextdomain(void)

{
  bindtextdomain();
  return;
}



void dbus_bus_request_name(void)

{
  dbus_bus_request_name();
  return;
}



void gtk_entry_get_text(void)

{
  gtk_entry_get_text();
  return;
}



void gdk_pixbuf_render_to_drawable(void)

{
  gdk_pixbuf_render_to_drawable();
  return;
}



void gtk_message_dialog_set_markup(void)

{
  gtk_message_dialog_set_markup();
  return;
}



void gtk_frame_new(void)

{
  gtk_frame_new();
  return;
}



void gdk_display_get_default_screen(void)

{
  gdk_display_get_default_screen();
  return;
}



void __vsnprintf_chk(void)

{
  __vsnprintf_chk();
  return;
}



void gtk_tree_model_filter_set_visible_func(void)

{
  gtk_tree_model_filter_set_visible_func();
  return;
}



void g_source_new(void)

{
  g_source_new();
  return;
}



void gtk_widget_get_colormap(void)

{
  gtk_widget_get_colormap();
  return;
}



void g_main_loop_new(void)

{
  g_main_loop_new();
  return;
}



void gtk_list_store_clear(void)

{
  gtk_list_store_clear();
  return;
}



void gdk_color_white(void)

{
  gdk_color_white();
  return;
}



void g_param_spec_int(void)

{
  g_param_spec_int();
  return;
}



void gdImageArc(void)

{
  gdImageArc();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void perror(char *__s)

{
  perror(__s);
  return;
}



void gtk_text_view_set_editable(void)

{
  gtk_text_view_set_editable();
  return;
}



void g_io_channel_read_line(void)

{
  g_io_channel_read_line();
  return;
}



void gdk_bitmap_create_from_data(void)

{
  gdk_bitmap_create_from_data();
  return;
}



void __strcat_chk(void)

{
  __strcat_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double exp(double __x)

{
  longdouble extraout_ST0;
  
  exp(__x);
  return (double)extraout_ST0;
}



void g_strv_length(void)

{
  g_strv_length();
  return;
}



void gtk_box_pack_start_defaults(void)

{
  gtk_box_pack_start_defaults();
  return;
}



void gdImageLine(void)

{
  gdImageLine();
  return;
}



void dbus_connection_set_dispatch_status_function(void)

{
  dbus_connection_set_dispatch_status_function();
  return;
}



void gdk_color_alloc(void)

{
  gdk_color_alloc();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

dirent * readdir(DIR *__dirp)

{
  dirent *pdVar1;
  
  pdVar1 = readdir(__dirp);
  return pdVar1;
}



void gtk_text_view_new(void)

{
  gtk_text_view_new();
  return;
}



void g_ptr_array_add(void)

{
  g_ptr_array_add();
  return;
}



void gtk_combo_box_get_type(void)

{
  gtk_combo_box_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



void gdk_gc_new(void)

{
  gdk_gc_new();
  return;
}



void gtk_text_buffer_insert(void)

{
  gtk_text_buffer_insert();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



void g_malloc0_n(void)

{
  g_malloc0_n();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__int32_t ** __ctype_toupper_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_toupper_loc();
  return pp_Var1;
}



void gtk_widget_show_all(void)

{
  gtk_widget_show_all();
  return;
}



void gtk_tree_model_filter_get_type(void)

{
  gtk_tree_model_filter_get_type();
  return;
}



void gtk_range_get_type(void)

{
  gtk_range_get_type();
  return;
}



void gtk_widget_set_sensitive(void)

{
  gtk_widget_set_sensitive();
  return;
}



void gtk_frame_set_shadow_type(void)

{
  gtk_frame_set_shadow_type();
  return;
}



void gtk_action_group_add_actions(void)

{
  gtk_action_group_add_actions();
  return;
}



void gtk_tree_view_scroll_to_cell(void)

{
  gtk_tree_view_scroll_to_cell();
  return;
}



void g_assertion_message_expr(void)

{
                    // WARNING: Subroutine does not return
  g_assertion_message_expr();
}



void gtk_tree_view_new_with_model(void)

{
  gtk_tree_view_new_with_model();
  return;
}



void gtk_viewport_get_type(void)

{
  gtk_viewport_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void g_object_new(void)

{
  g_object_new();
  return;
}



void gtk_container_get_type(void)

{
  gtk_container_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double atan(double __x)

{
  longdouble extraout_ST0;
  
  atan(__x);
  return (double)extraout_ST0;
}



void g_list_length(void)

{
  g_list_length();
  return;
}



void g_object_ref(void)

{
  g_object_ref();
  return;
}



void g_slist_append(void)

{
  g_slist_append();
  return;
}



void gtk_tree_model_iter_has_child(void)

{
  gtk_tree_model_iter_has_child();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int scanf(char *__format,...)

{
  int iVar1;
  
  iVar1 = scanf(__format);
  return iVar1;
}



void gtk_action_group_set_translation_domain(void)

{
  gtk_action_group_set_translation_domain();
  return;
}



void dcgettext(void)

{
  dcgettext();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int access(char *__name,int __type)

{
  int iVar1;
  
  iVar1 = access(__name,__type);
  return iVar1;
}



void gdk_display_warp_pointer(void)

{
  gdk_display_warp_pointer();
  return;
}



void gdk_pixbuf_get_width(void)

{
  gdk_pixbuf_get_width();
  return;
}



void g_strdup_printf(void)

{
  g_strdup_printf();
  return;
}



void gtk_tree_view_new(void)

{
  gtk_tree_view_new();
  return;
}



void dlsym(void)

{
  dlsym();
  return;
}



void gdk_pixbuf_scale_simple(void)

{
  gdk_pixbuf_scale_simple();
  return;
}



void gtk_tree_view_expand_all(void)

{
  gtk_tree_view_expand_all();
  return;
}



void g_value_set_string(void)

{
  g_value_set_string();
  return;
}



void gtk_tree_view_append_column(void)

{
  gtk_tree_view_append_column();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



void g_string_free(void)

{
  g_string_free();
  return;
}



void gtk_set_locale(void)

{
  gtk_set_locale();
  return;
}



void gdk_draw_points(void)

{
  gdk_draw_points();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double sqrt(double __x)

{
  longdouble extraout_ST0;
  
  sqrt(__x);
  return (double)extraout_ST0;
}



void gtk_events_pending(void)

{
  gtk_events_pending();
  return;
}



void __vfprintf_chk(void)

{
  __vfprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int regcomp(regex_t *__preg,char *__pattern,int __cflags)

{
  int iVar1;
  
  iVar1 = regcomp(__preg,__pattern,__cflags);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



void g_type_check_class_cast(void)

{
  g_type_check_class_cast();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



void g_ptr_array_free(void)

{
  g_ptr_array_free();
  return;
}



void g_hash_table_size(void)

{
  g_hash_table_size();
  return;
}



void g_hash_table_new(void)

{
  g_hash_table_new();
  return;
}



void g_node_depth(void)

{
  g_node_depth();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



void gtk_window_set_title(void)

{
  gtk_window_set_title();
  return;
}



void gtk_window_set_default_size(void)

{
  gtk_window_set_default_size();
  return;
}



void g_hash_table_new_full(void)

{
  g_hash_table_new_full();
  return;
}



void __vsprintf_chk(void)

{
  __vsprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



void gtk_adjustment_get_type(void)

{
  gtk_adjustment_get_type();
  return;
}



void gdk_gc_set_line_attributes(void)

{
  gdk_gc_set_line_attributes();
  return;
}



void g_param_spec_pointer(void)

{
  g_param_spec_pointer();
  return;
}



void gtk_combo_box_set_active(void)

{
  gtk_combo_box_set_active();
  return;
}



void gdk_window_get_pointer(void)

{
  gdk_window_get_pointer();
  return;
}



void gtk_paned_pack2(void)

{
  gtk_paned_pack2();
  return;
}



void gtk_widget_set_events(void)

{
  gtk_widget_set_events();
  return;
}



void gtk_ui_manager_get_accel_group(void)

{
  gtk_ui_manager_get_accel_group();
  return;
}



void gtk_tree_view_collapse_row(void)

{
  gtk_tree_view_collapse_row();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _setjmp(__jmp_buf_tag *__env)

{
  int iVar1;
  
  iVar1 = _setjmp(__env);
  return iVar1;
}



void gdk_draw_rectangle(void)

{
  gdk_draw_rectangle();
  return;
}



void gtk_editable_get_type(void)

{
  gtk_editable_get_type();
  return;
}



void gtk_window_get_type(void)

{
  gtk_window_get_type();
  return;
}



void g_hash_table_foreach(void)

{
  g_hash_table_foreach();
  return;
}



void gdk_window_set_back_pixmap(void)

{
  gdk_window_set_back_pixmap();
  return;
}



void gtk_window_move(void)

{
  gtk_window_move();
  return;
}



void gtk_file_chooser_set_current_name(void)

{
  gtk_file_chooser_set_current_name();
  return;
}



void gtk_combo_box_remove_text(void)

{
  gtk_combo_box_remove_text();
  return;
}



void gtk_dialog_add_buttons(void)

{
  gtk_dialog_add_buttons();
  return;
}



void g_slist_prepend(void)

{
  g_slist_prepend();
  return;
}



void gtk_text_buffer_get_end_iter(void)

{
  gtk_text_buffer_get_end_iter();
  return;
}



void gtk_file_chooser_add_shortcut_folder(void)

{
  gtk_file_chooser_add_shortcut_folder();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double acos(double __x)

{
  longdouble extraout_ST0;
  
  acos(__x);
  return (double)extraout_ST0;
}



void gtk_hbox_get_type(void)

{
  gtk_hbox_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



void g_io_add_watch(void)

{
  g_io_add_watch();
  return;
}



void gtk_action_get_name(void)

{
  gtk_action_get_name();
  return;
}



void gdk_draw_drawable(void)

{
  gdk_draw_drawable();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void gtk_tree_view_insert_column(void)

{
  gtk_tree_view_insert_column();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



void g_strdup_vprintf(void)

{
  g_strdup_vprintf();
  return;
}



void gtk_signal_emit_by_name(void)

{
  gtk_signal_emit_by_name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double cos(double __x)

{
  longdouble extraout_ST0;
  
  cos(__x);
  return (double)extraout_ST0;
}



void gdImageColorTransparent(void)

{
  gdImageColorTransparent();
  return;
}



void gtk_tree_store_append(void)

{
  gtk_tree_store_append();
  return;
}



void dbus_message_get_interface(void)

{
  dbus_message_get_interface();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



void gtk_notebook_get_current_page(void)

{
  gtk_notebook_get_current_page();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

passwd * getpwuid(__uid_t __uid)

{
  passwd *ppVar1;
  
  ppVar1 = getpwuid(__uid);
  return ppVar1;
}



void dbus_timeout_handle(void)

{
  dbus_timeout_handle();
  return;
}



void gdImageGetPixel(void)

{
  gdImageGetPixel();
  return;
}



void gdImageColorAllocateAlpha(void)

{
  gdImageColorAllocateAlpha();
  return;
}



void gtk_editable_select_region(void)

{
  gtk_editable_select_region();
  return;
}



void gtk_spin_button_set_value(void)

{
  gtk_spin_button_set_value();
  return;
}



void gdk_window_get_geometry(void)

{
  gdk_window_get_geometry();
  return;
}



void g_return_if_fail_warning(void)

{
  g_return_if_fail_warning();
  return;
}



void g_list_concat(void)

{
  g_list_concat();
  return;
}



void g_type_register_static(void)

{
  g_type_register_static();
  return;
}



void g_value_get_pointer(void)

{
  g_value_get_pointer();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



void gtk_widget_grab_default(void)

{
  gtk_widget_grab_default();
  return;
}



void g_object_set(void)

{
  g_object_set();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fgetc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fgetc(__stream);
  return iVar1;
}



void gtk_hpaned_get_type(void)

{
  gtk_hpaned_get_type();
  return;
}



void g_list_insert(void)

{
  g_list_insert();
  return;
}



void g_list_remove_link(void)

{
  g_list_remove_link();
  return;
}



void gtk_paned_get_type(void)

{
  gtk_paned_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



void gtk_text_view_scroll_to_mark(void)

{
  gtk_text_view_scroll_to_mark();
  return;
}



void dlopen(void)

{
  dlopen();
  return;
}



void gtk_file_filter_add_pattern(void)

{
  gtk_file_filter_add_pattern();
  return;
}



void g_slist_find(void)

{
  g_slist_find();
  return;
}



void gtk_init(void)

{
  gtk_init();
  return;
}



void dbus_connection_set_watch_functions(void)

{
  dbus_connection_set_watch_functions();
  return;
}



void g_list_free_1(void)

{
  g_list_free_1();
  return;
}



void gtk_file_filter_set_name(void)

{
  gtk_file_filter_set_name();
  return;
}



void gtk_widget_hide(void)

{
  gtk_widget_hide();
  return;
}



void gtk_file_chooser_get_filename(void)

{
  gtk_file_chooser_get_filename();
  return;
}



void gtk_dialog_set_alternative_button_order(void)

{
  gtk_dialog_set_alternative_button_order();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int chdir(char *__path)

{
  int iVar1;
  
  iVar1 = chdir(__path);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * ctime(time_t *__timer)

{
  char *pcVar1;
  
  pcVar1 = ctime(__timer);
  return pcVar1;
}



void gtk_arrow_new(void)

{
  gtk_arrow_new();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__uid_t getuid(void)

{
  __uid_t _Var1;
  
  _Var1 = getuid();
  return _Var1;
}



void gtk_tree_model_get_type(void)

{
  gtk_tree_model_get_type();
  return;
}



void dbus_connection_register_object_path(void)

{
  dbus_connection_register_object_path();
  return;
}



void gtk_menu_popup(void)

{
  gtk_menu_popup();
  return;
}



void gtk_list_store_append(void)

{
  gtk_list_store_append();
  return;
}



void gtk_check_button_new(void)

{
  gtk_check_button_new();
  return;
}



void gtk_window_present(void)

{
  gtk_window_present();
  return;
}



void gtk_tree_selection_get_selected(void)

{
  gtk_tree_selection_get_selected();
  return;
}



void g_signal_handler_disconnect(void)

{
  g_signal_handler_disconnect();
  return;
}



void g_main_loop_is_running(void)

{
  g_main_loop_is_running();
  return;
}



void gtk_adjustment_new(void)

{
  gtk_adjustment_new();
  return;
}



void gtk_check_button_new_with_label(void)

{
  gtk_check_button_new_with_label();
  return;
}



void gtk_widget_realize(void)

{
  gtk_widget_realize();
  return;
}



void pango_layout_get_pixel_size(void)

{
  pango_layout_get_pixel_size();
  return;
}



void __strcpy_chk(void)

{
  __strcpy_chk();
  return;
}



void gtk_window_add_accel_group(void)

{
  gtk_window_add_accel_group();
  return;
}



void gdk_display_sync(void)

{
  gdk_display_sync();
  return;
}



void gtk_label_get_type(void)

{
  gtk_label_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}



void gtk_object_get_type(void)

{
  gtk_object_get_type();
  return;
}



void gtk_entry_set_width_chars(void)

{
  gtk_entry_set_width_chars();
  return;
}



void g_list_sort(void)

{
  g_list_sort();
  return;
}



void gtk_spin_button_set_numeric(void)

{
  gtk_spin_button_set_numeric();
  return;
}



void g_type_check_instance_is_a(void)

{
  g_type_check_instance_is_a();
  return;
}



void gtk_action_group_add_toggle_actions(void)

{
  gtk_action_group_add_toggle_actions();
  return;
}



void dbus_connection_get_dispatch_status(void)

{
  dbus_connection_get_dispatch_status();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t regerror(int __errcode,regex_t *__preg,char *__errbuf,size_t __errbuf_size)

{
  size_t sVar1;
  
  sVar1 = regerror(__errcode,__preg,__errbuf,__errbuf_size);
  return sVar1;
}



void gtk_button_get_type(void)

{
  gtk_button_get_type();
  return;
}



void g_list_last(void)

{
  g_list_last();
  return;
}



void gdImageColorResolve(void)

{
  gdImageColorResolve();
  return;
}



void g_list_index(void)

{
  g_list_index();
  return;
}



void g_list_append(void)

{
  g_list_append();
  return;
}



void g_slist_foreach(void)

{
  g_slist_foreach();
  return;
}



void gtk_tree_view_set_model(void)

{
  gtk_tree_view_set_model();
  return;
}



void gtk_widget_grab_focus(void)

{
  gtk_widget_grab_focus();
  return;
}



void gtk_tree_selection_get_tree_view(void)

{
  gtk_tree_selection_get_tree_view();
  return;
}



void gtk_tree_model_foreach(void)

{
  gtk_tree_model_foreach();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



void gtk_tree_store_get_type(void)

{
  gtk_tree_store_get_type();
  return;
}



void gtk_entry_set_activates_default(void)

{
  gtk_entry_set_activates_default();
  return;
}



void dbus_connection_dispatch(void)

{
  dbus_connection_dispatch();
  return;
}



void gtk_radio_button_new_with_label(void)

{
  gtk_radio_button_new_with_label();
  return;
}



void gtk_widget_set_size_request(void)

{
  gtk_widget_set_size_request();
  return;
}



void g_value_dup_object(void)

{
  g_value_dup_object();
  return;
}



void gtk_table_set_col_spacings(void)

{
  gtk_table_set_col_spacings();
  return;
}



void g_param_spec_double(void)

{
  g_param_spec_double();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



void gtk_alignment_get_type(void)

{
  gtk_alignment_get_type();
  return;
}



void g_type_name(void)

{
  g_type_name();
  return;
}



void gtk_tooltips_set_tip(void)

{
  gtk_tooltips_set_tip();
  return;
}



void gtk_button_box_set_layout(void)

{
  gtk_button_box_set_layout();
  return;
}



void gtk_button_set_label(void)

{
  gtk_button_set_label();
  return;
}



void gtk_main_quit(void)

{
  gtk_main_quit();
  return;
}



void gtk_entry_get_type(void)

{
  gtk_entry_get_type();
  return;
}



void g_source_remove(void)

{
  g_source_remove();
  return;
}



void gtk_scrolled_window_add_with_viewport(void)

{
  gtk_scrolled_window_add_with_viewport();
  return;
}



void g_signal_connect_data(void)

{
  g_signal_connect_data();
  return;
}



void gdk_gc_set_foreground(void)

{
  gdk_gc_set_foreground();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void gtk_window_set_resizable(void)

{
  gtk_window_set_resizable();
  return;
}



void gdk_pixbuf_new_from_xpm_data(void)

{
  gdk_pixbuf_new_from_xpm_data();
  return;
}



void g_strjoinv(void)

{
  g_strjoinv();
  return;
}



void gtk_text_buffer_create_mark(void)

{
  gtk_text_buffer_create_mark();
  return;
}



void dbus_connection_close(void)

{
  dbus_connection_close();
  return;
}



void g_slist_length(void)

{
  g_slist_length();
  return;
}



void gtk_tree_model_filter_refilter(void)

{
  gtk_tree_model_filter_refilter();
  return;
}



void dbus_connection_set_timeout_functions(void)

{
  dbus_connection_set_timeout_functions();
  return;
}



void gdk_draw_layout(void)

{
  gdk_draw_layout();
  return;
}



void gdImageRectangle(void)

{
  gdImageRectangle();
  return;
}



void gtk_tree_view_column_pack_start(void)

{
  gtk_tree_view_column_pack_start();
  return;
}



void gtk_file_chooser_add_filter(void)

{
  gtk_file_chooser_add_filter();
  return;
}



void g_type_check_instance_cast(void)

{
  g_type_check_instance_cast();
  return;
}



void gtk_widget_show(void)

{
  gtk_widget_show();
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void dbus_message_get_member(void)

{
  dbus_message_get_member();
  return;
}



void gdk_pixmap_new(void)

{
  gdk_pixmap_new();
  return;
}



void gtk_paned_pack1(void)

{
  gtk_paned_pack1();
  return;
}



void gtk_notebook_set_current_page(void)

{
  gtk_notebook_set_current_page();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gethostname(char *__name,size_t __len)

{
  int iVar1;
  
  iVar1 = gethostname(__name,__len);
  return iVar1;
}



void pango_layout_set_font_description(void)

{
  pango_layout_set_font_description();
  return;
}



void gtk_list_store_new(void)

{
  gtk_list_store_new();
  return;
}



void g_ptr_array_sort(void)

{
  g_ptr_array_sort();
  return;
}



void gtk_action_group_add_radio_actions(void)

{
  gtk_action_group_add_radio_actions();
  return;
}



void gtk_toggle_button_set_mode(void)

{
  gtk_toggle_button_set_mode();
  return;
}



void gtk_action_group_new(void)

{
  gtk_action_group_new();
  return;
}



void gtk_color_button_get_type(void)

{
  gtk_color_button_get_type();
  return;
}



void gtk_main_iteration(void)

{
  gtk_main_iteration();
  return;
}



void gtk_radio_action_get_current_value(void)

{
  gtk_radio_action_get_current_value();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double atan2(double __y,double __x)

{
  longdouble extraout_ST0;
  
  atan2(__y,__x);
  return (double)extraout_ST0;
}



void gtk_dialog_run(void)

{
  gtk_dialog_run();
  return;
}



void gdk_window_set_cursor(void)

{
  gdk_window_set_cursor();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



void gdImageColorResolveAlpha(void)

{
  gdImageColorResolveAlpha();
  return;
}



void gtk_radio_button_new(void)

{
  gtk_radio_button_new();
  return;
}



void gtk_tree_view_set_expander_column(void)

{
  gtk_tree_view_set_expander_column();
  return;
}



void gtk_scale_set_value_pos(void)

{
  gtk_scale_set_value_pos();
  return;
}



void gdk_draw_line(void)

{
  gdk_draw_line();
  return;
}



void g_locale_to_utf8(void)

{
  g_locale_to_utf8();
  return;
}



void dlerror(void)

{
  dlerror();
  return;
}



void g_list_reverse(void)

{
  g_list_reverse();
  return;
}



void g_slist_free_1(void)

{
  g_slist_free_1();
  return;
}



void gtk_tree_view_row_expanded(void)

{
  gtk_tree_view_row_expanded();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strtok(char *__s,char *__delim)

{
  char *pcVar1;
  
  pcVar1 = strtok(__s,__delim);
  return pcVar1;
}



void gtk_hbox_new(void)

{
  gtk_hbox_new();
  return;
}



void gtk_expander_new(void)

{
  gtk_expander_new();
  return;
}



void gtk_frame_get_type(void)

{
  gtk_frame_get_type();
  return;
}



void g_ascii_strup(void)

{
  g_ascii_strup();
  return;
}



void g_strsplit(void)

{
  g_strsplit();
  return;
}



void gtk_container_add(void)

{
  gtk_container_add();
  return;
}



void g_hash_table_lookup(void)

{
  g_hash_table_lookup();
  return;
}



void gtk_radio_button_get_group(void)

{
  gtk_radio_button_get_group();
  return;
}



void g_direct_hash(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gdImageFilledPolygon(void)

{
  gdImageFilledPolygon();
  return;
}



void gtk_text_view_get_buffer(void)

{
  gtk_text_view_get_buffer();
  return;
}



void dbus_message_get_args(void)

{
  dbus_message_get_args();
  return;
}



void gtk_timeout_remove(void)

{
  gtk_timeout_remove();
  return;
}



void gdImageJpeg(void)

{
  gdImageJpeg();
  return;
}



void gtk_event_box_new(void)

{
  gtk_event_box_new();
  return;
}



void gtk_toggle_button_set_active(void)

{
  gtk_toggle_button_set_active();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncasecmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncasecmp(__s1,__s2,__n);
  return iVar1;
}



void dbus_message_iter_append_basic(void)

{
  dbus_message_iter_append_basic();
  return;
}



void gtk_file_chooser_dialog_new(void)

{
  gtk_file_chooser_dialog_new();
  return;
}



void gtk_drawing_area_new(void)

{
  gtk_drawing_area_new();
  return;
}



void gtk_toggle_button_get_type(void)

{
  gtk_toggle_button_get_type();
  return;
}



void gtk_scrolled_window_new(void)

{
  gtk_scrolled_window_new();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



void g_malloc0(void)

{
  g_malloc0();
  return;
}



void gtk_list_store_set(void)

{
  gtk_list_store_set();
  return;
}



void gtk_box_pack_start(void)

{
  gtk_box_pack_start();
  return;
}



void g_ptr_array_sized_new(void)

{
  g_ptr_array_sized_new();
  return;
}



void gtk_cell_renderer_text_get_type(void)

{
  gtk_cell_renderer_text_get_type();
  return;
}



void g_value_init(void)

{
  g_value_init();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__int32_t ** __ctype_tolower_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_tolower_loc();
  return pp_Var1;
}



void dbus_watch_handle(void)

{
  dbus_watch_handle();
  return;
}



void g_list_prepend(void)

{
  g_list_prepend();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



void gtk_ui_manager_set_add_tearoffs(void)

{
  gtk_ui_manager_set_add_tearoffs();
  return;
}



void gtk_disable_setlocale(void)

{
  gtk_disable_setlocale();
  return;
}



void pango_layout_set_markup(void)

{
  pango_layout_set_markup();
  return;
}



void g_string_insert_c(void)

{
  g_string_insert_c();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getcwd(char *__buf,size_t __size)

{
  char *pcVar1;
  
  pcVar1 = getcwd(__buf,__size);
  return pcVar1;
}



void gtk_misc_get_type(void)

{
  gtk_misc_get_type();
  return;
}



void dbus_timeout_get_enabled(void)

{
  dbus_timeout_get_enabled();
  return;
}



void dbus_message_iter_init_append(void)

{
  dbus_message_iter_init_append();
  return;
}



void g_build_filename(void)

{
  g_build_filename();
  return;
}



void g_main_loop_unref(void)

{
  g_main_loop_unref();
  return;
}



void gtk_range_set_value(void)

{
  gtk_range_set_value();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * asctime(tm *__tp)

{
  char *pcVar1;
  
  pcVar1 = asctime(__tp);
  return pcVar1;
}



void gtk_cell_renderer_get_type(void)

{
  gtk_cell_renderer_get_type();
  return;
}



void gdk_display_get_pointer(void)

{
  gdk_display_get_pointer();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double log(double __x)

{
  longdouble extraout_ST0;
  
  log(__x);
  return (double)extraout_ST0;
}



void gdk_drawable_get_display(void)

{
  gdk_drawable_get_display();
  return;
}



void gtk_viewport_set_shadow_type(void)

{
  gtk_viewport_set_shadow_type();
  return;
}



void gtk_tree_view_get_type(void)

{
  gtk_tree_view_get_type();
  return;
}



void g_io_channel_unref(void)

{
  g_io_channel_unref();
  return;
}



void g_source_destroy(void)

{
  g_source_destroy();
  return;
}



void gtk_tree_model_get_path(void)

{
  gtk_tree_model_get_path();
  return;
}



void g_idle_add(void)

{
  g_idle_add();
  return;
}



void gtk_image_new_from_pixbuf(void)

{
  gtk_image_new_from_pixbuf();
  return;
}



void textdomain(void)

{
  textdomain();
  return;
}



void g_slist_concat(void)

{
  g_slist_concat();
  return;
}



void gtk_button_new_with_label(void)

{
  gtk_button_new_with_label();
  return;
}



void dbus_error_free(void)

{
  dbus_error_free();
  return;
}



void g_build_path(void)

{
  g_build_path();
  return;
}



void gtk_widget_is_ancestor(void)

{
  gtk_widget_is_ancestor();
  return;
}



void g_assertion_message(void)

{
                    // WARNING: Subroutine does not return
  g_assertion_message();
}



void gtk_notebook_get_type(void)

{
  gtk_notebook_get_type();
  return;
}



void gtk_widget_create_pango_layout(void)

{
  gtk_widget_create_pango_layout();
  return;
}



void gtk_tree_row_reference_new(void)

{
  gtk_tree_row_reference_new();
  return;
}



void gtk_tree_model_get(void)

{
  gtk_tree_model_get();
  return;
}



void g_list_nth_data(void)

{
  g_list_nth_data();
  return;
}



void gtk_button_new_from_stock(void)

{
  gtk_button_new_from_stock();
  return;
}



void gtk_color_button_get_color(void)

{
  gtk_color_button_get_color();
  return;
}



void gtk_combo_box_get_active(void)

{
  gtk_combo_box_get_active();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rand(void)

{
  int iVar1;
  
  iVar1 = rand();
  return iVar1;
}



void gtk_vscrollbar_new(void)

{
  gtk_vscrollbar_new();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sscanf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sscanf(__s,__format);
  return iVar1;
}



void g_source_attach(void)

{
  g_source_attach();
  return;
}



void gtk_adjustment_get_value(void)

{
  gtk_adjustment_get_value();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * gmtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = gmtime(__timer);
  return ptVar1;
}



void g_get_home_dir(void)

{
  g_get_home_dir();
  return;
}



void gdImageSetThickness(void)

{
  gdImageSetThickness();
  return;
}



void gtk_tree_selection_set_mode(void)

{
  gtk_tree_selection_set_mode();
  return;
}



void gtk_scrolled_window_get_type(void)

{
  gtk_scrolled_window_get_type();
  return;
}



void __sprintf_chk(void)

{
  __sprintf_chk();
  return;
}



void gdImageSetPixel(void)

{
  gdImageSetPixel();
  return;
}



void gtk_range_set_update_policy(void)

{
  gtk_range_set_update_policy();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



void __realpath_chk(void)

{
  __realpath_chk();
  return;
}



void g_node_new(void)

{
  g_node_new();
  return;
}



void gtk_tree_view_get_selection(void)

{
  gtk_tree_view_get_selection();
  return;
}



void __snprintf_chk(void)

{
  __snprintf_chk();
  return;
}



void g_error_free(void)

{
  g_error_free();
  return;
}



void dbus_connection_unregister_object_path(void)

{
  dbus_connection_unregister_object_path();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _IO_putc(int __c,_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_putc(__c,__fp);
  return iVar1;
}



void gtk_tree_model_get_iter(void)

{
  gtk_tree_model_get_iter();
  return;
}



void gdk_window_get_origin(void)

{
  gdk_window_get_origin();
  return;
}



void g_strfreev(void)

{
  g_strfreev();
  return;
}



void gtk_spin_button_new(void)

{
  gtk_spin_button_new();
  return;
}



void g_ptr_array_new(void)

{
  g_ptr_array_new();
  return;
}



void gtk_tree_view_column_new_with_attributes(void)

{
  gtk_tree_view_column_new_with_attributes();
  return;
}



void gtk_window_set_default_icon(void)

{
  gtk_window_set_default_icon();
  return;
}



void g_malloc_n(void)

{
  g_malloc_n();
  return;
}



void gtk_message_dialog_get_type(void)

{
  gtk_message_dialog_get_type();
  return;
}



void gtk_text_buffer_insert_with_tags_by_name(void)

{
  gtk_text_buffer_insert_with_tags_by_name();
  return;
}



void g_timeout_add(void)

{
  g_timeout_add();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



void gtk_action_group_get_action(void)

{
  gtk_action_group_get_action();
  return;
}



void g_value_get_int(void)

{
  g_value_get_int();
  return;
}



void gtk_tree_store_set(void)

{
  gtk_tree_store_set();
  return;
}



void gdImagePng(void)

{
  gdImagePng();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)

{
  size_t sVar1;
  
  sVar1 = strftime(__s,__maxsize,__format,__tp);
  return sVar1;
}



void gtk_table_set_row_spacings(void)

{
  gtk_table_set_row_spacings();
  return;
}



void g_object_set_property(void)

{
  g_object_set_property();
  return;
}



void gtk_hseparator_new(void)

{
  gtk_hseparator_new();
  return;
}



void gdImageCreate(void)

{
  gdImageCreate();
  return;
}



void g_list_insert_sorted_with_data(void)

{
  g_list_insert_sorted_with_data();
  return;
}



void bind_textdomain_codeset(void)

{
  bind_textdomain_codeset();
  return;
}



void gtk_window_set_wmclass(void)

{
  gtk_window_set_wmclass();
  return;
}



void gtk_tree_row_reference_get_path(void)

{
  gtk_tree_row_reference_get_path();
  return;
}



void gtk_combo_box_prepend_text(void)

{
  gtk_combo_box_prepend_text();
  return;
}



void g_hash_table_foreach_remove(void)

{
  g_hash_table_foreach_remove();
  return;
}



void gtk_vscale_new(void)

{
  gtk_vscale_new();
  return;
}



void gtk_toggle_action_get_type(void)

{
  gtk_toggle_action_get_type();
  return;
}



void gtk_notebook_set_show_tabs(void)

{
  gtk_notebook_set_show_tabs();
  return;
}



void gtk_ui_manager_add_ui_from_string(void)

{
  gtk_ui_manager_add_ui_from_string();
  return;
}



void gtk_container_remove(void)

{
  gtk_container_remove();
  return;
}



void gtk_tree_store_clear(void)

{
  gtk_tree_store_clear();
  return;
}



void dbus_free_string_array(void)

{
  dbus_free_string_array();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double sin(double __x)

{
  longdouble extraout_ST0;
  
  sin(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

hostent * gethostbyname(char *__name)

{
  hostent *phVar1;
  
  phVar1 = gethostbyname(__name);
  return phVar1;
}



void gtk_box_set_spacing(void)

{
  gtk_box_set_spacing();
  return;
}



void g_main_loop_run(void)

{
  g_main_loop_run();
  return;
}



void gtk_editable_set_editable(void)

{
  gtk_editable_set_editable();
  return;
}



void gdImageFilledRectangle(void)

{
  gdImageFilledRectangle();
  return;
}



void g_list_remove(void)

{
  g_list_remove();
  return;
}



void gtk_tree_model_iter_children(void)

{
  gtk_tree_model_iter_children();
  return;
}



void gtk_spin_button_get_type(void)

{
  gtk_spin_button_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



void gtk_bin_get_type(void)

{
  gtk_bin_get_type();
  return;
}



void gtk_widget_set_uposition(void)

{
  gtk_widget_set_uposition();
  return;
}



void gtk_combo_box_append_text(void)

{
  gtk_combo_box_append_text();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double rint(double __x)

{
  longdouble extraout_ST0;
  
  rint(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void gtk_widget_add_events(void)

{
  gtk_widget_add_events();
  return;
}



void dbus_timeout_set_data(void)

{
  dbus_timeout_set_data();
  return;
}



void g_node_destroy(void)

{
  g_node_destroy();
  return;
}



void g_type_class_peek_parent(void)

{
  g_type_class_peek_parent();
  return;
}



void __strdup(void)

{
  __strdup();
  return;
}



void gtk_radio_button_get_type(void)

{
  gtk_radio_button_get_type();
  return;
}



void gtk_label_set_markup(void)

{
  gtk_label_set_markup();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



void gtk_range_get_adjustment(void)

{
  gtk_range_get_adjustment();
  return;
}



void g_log(void)

{
  g_log();
  return;
}



void gtk_tree_view_set_rules_hint(void)

{
  gtk_tree_view_set_rules_hint();
  return;
}



void gdk_gc_set_clip_mask(void)

{
  gdk_gc_set_clip_mask();
  return;
}



void g_str_equal(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_container_set_border_width(void)

{
  gtk_container_set_border_width();
  return;
}



void dbus_message_get_type(void)

{
  dbus_message_get_type();
  return;
}



void gtk_hbutton_box_new(void)

{
  gtk_hbutton_box_new();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = pclose(__stream);
  return iVar1;
}



void g_file_test(void)

{
  g_file_test();
  return;
}



void gtk_ui_manager_get_widget(void)

{
  gtk_ui_manager_get_widget();
  return;
}



void __strncat_chk(void)

{
  __strncat_chk();
  return;
}



void gtk_drawing_area_get_type(void)

{
  gtk_drawing_area_get_type();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void sincos(double __x,double *__sinx,double *__cosx)

{
  sincos(__x,__sinx,__cosx);
  return;
}



void g_pattern_match_simple(void)

{
  g_pattern_match_simple();
  return;
}



void gtk_ui_manager_remove_action_group(void)

{
  gtk_ui_manager_remove_action_group();
  return;
}



void gtk_text_buffer_delete_mark(void)

{
  gtk_text_buffer_delete_mark();
  return;
}



void gtk_hscale_new(void)

{
  gtk_hscale_new();
  return;
}



void gtk_misc_set_alignment(void)

{
  gtk_misc_set_alignment();
  return;
}



void gtk_color_button_new_with_color(void)

{
  gtk_color_button_new_with_color();
  return;
}



void gtk_tree_model_iter_next(void)

{
  gtk_tree_model_iter_next();
  return;
}



void g_ascii_strcasecmp(void)

{
  g_ascii_strcasecmp();
  return;
}



void gdImageColorAllocate(void)

{
  gdImageColorAllocate();
  return;
}



void g_slist_nth(void)

{
  g_slist_nth();
  return;
}



void gtk_scale_set_draw_value(void)

{
  gtk_scale_set_draw_value();
  return;
}



void dbus_timeout_get_interval(void)

{
  dbus_timeout_get_interval();
  return;
}



void gtk_box_pack_end(void)

{
  gtk_box_pack_end();
  return;
}



void gtk_spin_button_get_value(void)

{
  gtk_spin_button_get_value();
  return;
}



void gdImageSetBrush(void)

{
  gdImageSetBrush();
  return;
}



void processEntry _start(undefined4 param_1,undefined4 param_2)

{
  undefined auStack_4 [4];
  
  __libc_start_main(main,param_2,&stack0x00000004,__libc_csu_init,__libc_csu_fini,param_1,auStack_4)
  ;
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x08060eea)
// WARNING: Removing unreachable block (ram,0x08060ef0)

void __do_global_dtors_aux(void)

{
  if (completed_7065 == '\0') {
    completed_7065 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x08060f2f)
// WARNING: Removing unreachable block (ram,0x08060f38)

void frame_dummy(void)

{
  return;
}



// WARNING: Unknown calling convention

int FlagHaveRegex(int parm)

{
  return 1;
}



// WARNING: Unknown calling convention

void ActionBell(char *volume)

{
                    // WARNING: Could not recover jumptable at 0x08060f72. Too many branches
                    // WARNING: Treating indirect jump as call
  (*gui->beep)();
  return;
}



// WARNING: Unknown calling convention

int ActionPSCalib(int argc,char **argv,int x,int y)

{
  HID *ps;
  HID *pHVar1;
  
  pHVar1 = hid_find_exporter("ps");
  (*pHVar1->calibrate)(0.0,0.0);
  return 0;
}



// WARNING: Unknown calling convention

void NotifyBlock(void)

{
  HideCrosshair('\x01');
  if (Crosshair.AttachedBox.State == 0) {
    Crosshair.AttachedBox.State = 1;
    Crosshair.AttachedBox.Point2.X = Crosshair.X;
    Crosshair.AttachedBox.Point1.X = Crosshair.X;
    Crosshair.AttachedBox.Point2.Y = Crosshair.Y;
    Crosshair.AttachedBox.Point1.Y = Crosshair.Y;
  }
  else if (Crosshair.AttachedBox.State == 1) {
    Crosshair.AttachedBox.State = 2;
    RestoreCrosshair('\x01');
    return;
  }
  RestoreCrosshair('\x01');
  return;
}



// WARNING: Unknown calling convention

int ActionNew(int argc,char **argv,int x,int y)

{
  PCBTypePtr pcb;
  int iVar1;
  char *pcVar2;
  char *name;
  
  pcVar2 = (char *)0x0;
  if (0 < argc) {
    pcVar2 = *argv;
  }
  HideCrosshair('\x01');
  if (PCB->Changed != '\0') {
    iVar1 = (*gui->confirm_dialog)("OK to clear layout data?",0);
    if (iVar1 == 0) goto LAB_080611a2;
  }
  if (pcVar2 == (char *)0x0) {
    pcVar2 = (*gui->prompt_for)("Enter the layout name:","");
  }
  else {
    pcVar2 = MyStrdup(pcVar2,"ActionNew");
  }
  if (pcVar2 != (char *)0x0) {
    if ((PCB->Changed != '\0') && (Settings.SaveInTMP != '\0')) {
      SaveInTMP();
    }
    RemovePCB(PCB);
    pcb = CreateNewPCB('\x01');
    PCB = pcb;
    pcb->Data->LayerN = 8;
    CreateNewPCBPost(pcb,1);
    PCB->Name = pcVar2;
    ResetStackAndVisibility();
    CreateDefaultFont();
    SetCrosshairRange(0,0,PCB->MaxWidth,PCB->MaxHeight);
    CenterDisplay(PCB->MaxWidth / 2,PCB->MaxHeight / 2,'\0');
    ClearAndRedrawOutput();
    hid_action("PCBChanged");
    RestoreCrosshair('\x01');
    return 0;
  }
LAB_080611a2:
  RestoreCrosshair('\x01');
  return 1;
}



// WARNING: Unknown calling convention

int hashfunc(String s)

{
  char cVar1;
  __int32_t **pp_Var2;
  uint uVar3;
  uint uVar4;
  int i;
  int __res;
  
  uVar3 = 0;
  uVar4 = 0;
  cVar1 = *s;
  if (cVar1 != '\0') {
    do {
      uVar3 = (uint)cVar1;
      if (uVar3 + 0x80 < 0x180) {
        pp_Var2 = __ctype_tolower_loc();
        uVar3 = (*pp_Var2)[uVar3];
      }
      s = s + 1;
      uVar4 = uVar3 & 0xff ^ ((int)uVar4 >> 0x10 ^ uVar4) * 0xd;
      cVar1 = *s;
    } while (cVar1 != '\0');
    uVar3 = uVar4 % 0x101;
  }
  return uVar3;
}



// WARNING: Unknown calling convention

int GetFunctionID(String Ident)

{
  char cVar1;
  int iVar2;
  int iVar3;
  int h;
  int i;
  int iVar4;
  
  if (Ident != (String)0x0) {
    if (hash_initted == 0) {
      hash_initted = 1;
      iVar3 = 0x73;
      do {
        iVar2 = hashfunc(*(String *)
                          (
                          "ChangeFlag(Object|Selected|SelectedObjects, flag, value)\nChangeFlag(SelectedLines|SelectedPins|SelectedVias, flag, value)\nChangeFlag(SelectedPads|SelectedTexts|SelectedNames, flag, value)\nChangeFlag(SelectedElements, flag, value)\nflag = square | octagon | thermal | join\nvalue = 0 | 1"
                          + iVar3 * 8 + 0x118));
        cVar1 = function_hash[iVar2];
        while (cVar1 != '\0') {
          iVar2 = (iVar2 + 1) % 0x101;
          cVar1 = function_hash[iVar2];
        }
        iVar4 = iVar3 + -1;
        function_hash[iVar2] = (char)iVar3;
        iVar3 = iVar4;
      } while (iVar4 != 0);
    }
    iVar3 = hashfunc(Ident);
    cVar1 = function_hash[iVar3];
    while (cVar1 != '\0') {
      iVar2 = strcasecmp(Ident,Functions[cVar1 + -1].Identifier);
      if (iVar2 == 0) {
        return Functions[cVar1 + -1].ID;
      }
      iVar3 = (iVar3 + 1) % 0x101;
      cVar1 = function_hash[iVar3];
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

int ActionMoveToCurrentLayer(int argc,char **argv,int x,int y)

{
  String Ident;
  Boolean BVar1;
  int iVar2;
  int type;
  LayerTypePtr pLVar3;
  void *pvVar4;
  char *function;
  void *local_18;
  void *local_14;
  void *local_10 [2];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  if ((iVar2 == 0x46) || (iVar2 == 0x4b)) {
    if (PCB->SilkActive == '\0') {
      pLVar3 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar3 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    BVar1 = MoveSelectedObjectsToLayer(pLVar3);
    if (BVar1 == '\0') goto LAB_080613b9;
  }
  else {
    if (iVar2 != 0x2e) goto LAB_080613b9;
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar2 = SearchScreen(x,y,0x403c,local_10,&local_14,&local_18);
    if (iVar2 == 0) goto LAB_080613b9;
    if (PCB->SilkActive == '\0') {
      pLVar3 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar3 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    pvVar4 = MoveObjectToLayer(iVar2,local_10[0],local_14,local_18,pLVar3,'\0');
    if (pvVar4 == (void *)0x0) goto LAB_080613b9;
  }
  SetChangedFlag('\x01');
LAB_080613b9:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionMessage(int argc,char **argv,int x,int y)

{
  char **ppcVar1;
  int iVar2;
  int i;
  
  iVar2 = 0;
  if (argc < 1) {
    Message("Syntax error.  Usage:\n%s\n","Message(message)");
    iVar2 = 1;
  }
  else {
    do {
      ppcVar1 = argv + iVar2;
      iVar2 = iVar2 + 1;
      Message(*ppcVar1);
      Message("\n");
    } while (iVar2 < argc);
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int ActionMoveObject(int argc,char **argv,int x,int y)

{
  int Type;
  int type;
  char *y_str;
  char *val;
  char *units_00;
  char *units;
  LocationType nx;
  int DX;
  char *x_str;
  LocationType ny;
  int DY;
  char *val_00;
  float fVar1;
  float fVar2;
  void *local_2c;
  void *local_28;
  void *local_24;
  char local_1e;
  char local_1d [13];
  
  if (argc < 1) {
    val_00 = (char *)0x0;
  }
  else {
    val_00 = *argv;
    if (argc != 1) {
      units_00 = (char *)0x0;
      val = argv[1];
      if (argc != 2) {
        units_00 = argv[2];
      }
      goto LAB_080615a2;
    }
  }
  val = (char *)0x0;
  units_00 = (char *)0x0;
LAB_080615a2:
  fVar1 = GetValue(val,units_00,local_1d);
  fVar2 = GetValue(val_00,units_00,&local_1e);
  Type = SearchScreen(x,y,0x5c1f,&local_24,&local_28,&local_2c);
  if (Type == 0) {
    Message("Nothing found under crosshair\n");
    return 1;
  }
  Crosshair.AttachedObject.RubberbandN = 0;
  DX = (int)ROUND(fVar2);
  if (local_1d[0] != '\0') {
    DX = (int)ROUND(fVar2) - x;
  }
  DY = (int)ROUND(fVar1);
  if (local_1e != '\0') {
    DY = (int)ROUND(fVar1) - y;
  }
  if ((*(byte *)&(PCB->Flags).f & 0x10) != 0) {
    LookupRubberbandLines(Type,local_24,local_28,local_2c);
  }
  if (Type == 2) {
    LookupRatLines(2,local_24,local_28,local_2c);
  }
  MoveObjectAndRubberband(Type,local_24,local_28,local_2c,DX,DY);
  SetChangedFlag('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionRouteStyle(int argc,char **argv,int x,int y)

{
  PCBTypePtr pPVar1;
  int number;
  char *str;
  long lVar2;
  
  if ((0 < argc) && (*argv != (char *)0x0)) {
    lVar2 = strtol(*argv,(char **)0x0,10);
    pPVar1 = PCB;
    if (lVar2 - 1U < 4) {
      SetLineSize(PCB->RouteStyle[lVar2 + -1].Thick);
      SetViaSize(pPVar1->RouteStyle[lVar2 + -1].Diameter,'\x01');
      SetViaDrillingHole(pPVar1->RouteStyle[lVar2 + -1].Hole,'\x01');
      SetKeepawayWidth(pPVar1->RouteStyle[lVar2 + -1].Keepaway);
      hid_action("RouteStylesChanged");
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int ActionPolygon(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  char *function;
  
  if (((0 < argc) && (Ident = *argv, Ident != (String)0x0)) && (Settings.Mode == 4)) {
    HideCrosshair('\x01');
    iVar1 = GetFunctionID(Ident);
    if (iVar1 == 0xe) {
      ClosePolygon();
    }
    else if (iVar1 == 0x36) {
      GoToPreviousPoint();
    }
    RestoreCrosshair('\x01');
    return 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

void ChangeFlag(char *what,char *flag_name,int value,char *cmd_name)

{
  char cVar1;
  int type;
  int iVar2;
  code *pcVar3;
  _func_Boolean_int *set_selected;
  char *pcVar4;
  code *pcVar5;
  _func_Boolean_int_void_ptr_void_ptr_void_ptr *set_object;
  char *pcVar6;
  bool bVar7;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  bVar7 = flag_name == (char *)0x0;
  if (bVar7) {
LAB_080619c0:
    Message("%s():  Flag \"%s\" is not valid\n",cmd_name,flag_name);
    return;
  }
  iVar2 = 7;
  pcVar4 = flag_name;
  pcVar6 = "square";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar7 = *pcVar4 == *pcVar6;
    pcVar4 = pcVar4 + 1;
    pcVar6 = pcVar6 + 1;
  } while (bVar7);
  if (bVar7) {
    pcVar3 = ClrSelectedSquare;
    pcVar5 = ClrObjectSquare;
    if (value != 0) {
      pcVar3 = SetSelectedSquare;
      pcVar5 = SetObjectSquare;
    }
  }
  else {
    iVar2 = 8;
    pcVar4 = flag_name;
    pcVar6 = "octagon";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar7 = *pcVar4 == *pcVar6;
      pcVar4 = pcVar4 + 1;
      pcVar6 = pcVar6 + 1;
    } while (bVar7);
    if (bVar7) {
      pcVar3 = ClrSelectedOctagon;
      pcVar5 = ClrObjectOctagon;
      if (value != 0) {
        pcVar3 = SetSelectedOctagon;
        pcVar5 = SetObjectOctagon;
      }
    }
    else {
      iVar2 = 5;
      pcVar4 = flag_name;
      pcVar6 = "join";
      do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        bVar7 = *pcVar4 == *pcVar6;
        pcVar4 = pcVar4 + 1;
        pcVar6 = pcVar6 + 1;
      } while (bVar7);
      if (!bVar7) goto LAB_080619c0;
      pcVar3 = SetSelectedJoin;
      pcVar5 = SetObjectJoin;
      if (value != 0) {
        pcVar3 = ClrSelectedJoin;
        pcVar5 = ClrObjectJoin;
      }
    }
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(what);
  switch(iVar2) {
  case 0x2e:
    iVar2 = SearchScreen(Crosshair.X,Crosshair.Y,0x471f,local_20,&local_24,&local_28);
    if ((iVar2 != 0) && ((*(byte *)((int)local_24 + 0x15) & 0x20) != 0)) {
      Message("Sorry, the object is locked\n");
    }
    cVar1 = (*pcVar5)(iVar2,local_20[0],local_24,local_28);
    break;
  default:
    goto switchD_080618d6_caseD_2f;
  case 0x46:
  case 0x4b:
    cVar1 = (*pcVar3)(0x471f);
    goto joined_r0x08061a28;
  case 0x48:
    cVar1 = (*pcVar3)(2);
joined_r0x08061a28:
    if (cVar1 == '\0') goto switchD_080618d6_caseD_2f;
    goto LAB_08061960;
  case 0x49:
    cVar1 = (*pcVar3)(4);
    break;
  case 0x4a:
    cVar1 = (*pcVar3)(0x400);
    break;
  case 0x4c:
    cVar1 = (*pcVar3)(0x200);
    break;
  case 0x4d:
    cVar1 = (*pcVar3)(0x100);
    break;
  case 0x4e:
    cVar1 = (*pcVar3)(0x10);
    break;
  case 0x4f:
    cVar1 = (*pcVar3)(1);
  }
  if (cVar1 != '\0') {
LAB_08061960:
    SetChangedFlag('\x01');
  }
switchD_080618d6_caseD_2f:
  RestoreCrosshair('\x01');
  return;
}



// WARNING: Unknown calling convention

int ActionChangeFlag(int argc,char **argv,int x,int y)

{
  char *what;
  char *flag_name;
  uint value_00;
  int value;
  char *function;
  char *flag;
  
  if (((0 < argc) && (what = *argv, argc != 1)) && (flag_name = argv[1], argc != 2)) {
    value_00 = strtol(argv[2],(char **)0x0,10);
    if (value_00 < 2) {
      ChangeFlag(what,flag_name,value_00,"ChangeFlag");
      return 0;
    }
  }
  Message("Syntax error.  Usage:\n%s\n",
          "ChangeFlag(Object|Selected|SelectedObjects, flag, value)\nChangeFlag(SelectedLines|SelectedPins|SelectedVias, flag, value)\nChangeFlag(SelectedPads|SelectedTexts|SelectedNames, flag, value)\nChangeFlag(SelectedElements, flag, value)\nflag = square | octagon | thermal | join\nvalue = 0 | 1"
         );
  return 1;
}



// WARNING: Unknown calling convention

int ActionClrFlag(int argc,char **argv,int x,int y)

{
  char *what;
  char *function;
  char *flag_name;
  char *flag;
  
  what = (char *)0x0;
  flag_name = (char *)0x0;
  if ((0 < argc) && (what = *argv, argc != 1)) {
    flag_name = argv[1];
  }
  ChangeFlag(what,flag_name,0,"ClrFlag");
  return 0;
}



// WARNING: Unknown calling convention

int ActionSetFlag(int argc,char **argv,int x,int y)

{
  char *what;
  char *function;
  char *flag_name;
  char *flag;
  
  what = (char *)0x0;
  flag_name = (char *)0x0;
  if ((0 < argc) && (what = *argv, argc != 1)) {
    flag_name = argv[1];
  }
  ChangeFlag(what,flag_name,1,"SetFlag");
  return 0;
}



// WARNING: Unknown calling convention

int ActionSetSquare(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  char *function;
  int type;
  int iVar3;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if (argc < 1) {
    type = 0;
    return type;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    type = 0;
    return type;
  }
  if (*Ident == '\0') {
    type = 0;
    return type;
  }
  iVar3 = GetFunctionID(Ident);
  switch(iVar3) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an object",&x,&y);
    iVar3 = SearchScreen(x,y,0x302,local_10,&local_14,&local_18);
    if (iVar3 == 0) {
      type = 0;
      return type;
    }
    BVar2 = SetObjectSquare(iVar3,local_10[0],local_14,local_18);
    if (BVar2 == '\0') {
      type = 0;
      return type;
    }
    goto LAB_08061c59;
  default:
    goto switchD_08061c40_caseD_2f;
  case 0x46:
  case 0x4b:
  case 0x4d:
    cVar1 = SetSelectedSquare(0x300);
    break;
  case 0x48:
    cVar1 = SetSelectedSquare(2);
  }
  if (cVar1 != '\0') {
LAB_08061c59:
    SetChangedFlag('\x01');
  }
switchD_08061c40_caseD_2f:
  type = 0;
  return type;
}



// WARNING: Unknown calling convention

int ActionClearSquare(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  char *function;
  int type;
  int iVar3;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if (argc < 1) {
    type = 0;
    return type;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    type = 0;
    return type;
  }
  if (*Ident == '\0') {
    type = 0;
    return type;
  }
  iVar3 = GetFunctionID(Ident);
  switch(iVar3) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar3 = SearchScreen(x,y,0x302,local_10,&local_14,&local_18);
    if (iVar3 == 0) {
      type = 0;
      return type;
    }
    BVar2 = ClrObjectSquare(iVar3,local_10[0],local_14,local_18);
    if (BVar2 == '\0') {
      type = 0;
      return type;
    }
    goto LAB_08061d59;
  default:
    goto switchD_08061d40_caseD_2f;
  case 0x46:
  case 0x4b:
  case 0x4d:
    cVar1 = ClrSelectedSquare(0x300);
    break;
  case 0x48:
    cVar1 = ClrSelectedSquare(2);
  }
  if (cVar1 != '\0') {
LAB_08061d59:
    SetChangedFlag('\x01');
  }
switchD_08061d40_caseD_2f:
  type = 0;
  return type;
}



// WARNING: Unknown calling convention

int ActionSetOctagon(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  char *function;
  int iVar3;
  int type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if ((0 < argc) && (*argv != (String)0x0)) {
    iVar3 = GetFunctionID(*argv);
    switch(iVar3) {
    case 0x2e:
    case 0x5f:
      (*gui->get_coords)("Select an object",&x,&y);
      iVar3 = SearchScreen(x,y,0x103,local_10,&local_14,&local_18);
      if (iVar3 == 0) {
        type = 0;
        return type;
      }
      BVar2 = SetObjectOctagon(iVar3,local_10[0],local_14,local_18);
      if (BVar2 == '\0') {
        type = 0;
        return type;
      }
      goto LAB_08061e82;
    default:
      goto switchD_08061e38_caseD_2f;
    case 0x46:
    case 0x4b:
      cVar1 = SetSelectedOctagon(0x101);
      break;
    case 0x48:
      cVar1 = SetSelectedOctagon(2);
      break;
    case 0x4d:
      cVar1 = SetSelectedOctagon(0x100);
      break;
    case 0x4f:
      cVar1 = SetSelectedOctagon(1);
    }
    if (cVar1 != '\0') {
LAB_08061e82:
      SetChangedFlag('\x01');
      return 0;
    }
  }
switchD_08061e38_caseD_2f:
  type = 0;
  return type;
}



// WARNING: Unknown calling convention

int ActionClearOctagon(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  char *function;
  int iVar3;
  int type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if ((0 < argc) && (*argv != (String)0x0)) {
    iVar3 = GetFunctionID(*argv);
    switch(iVar3) {
    case 0x2e:
    case 0x5f:
      (*gui->get_coords)("Select an Object",&x,&y);
      iVar3 = SearchScreen(Crosshair.X,Crosshair.Y,0x103,local_10,&local_14,&local_18);
      if (iVar3 == 0) {
        type = 0;
        return type;
      }
      BVar2 = ClrObjectOctagon(iVar3,local_10[0],local_14,local_18);
      if (BVar2 == '\0') {
        type = 0;
        return type;
      }
      goto LAB_08061fb2;
    default:
      goto switchD_08061f68_caseD_2f;
    case 0x46:
    case 0x4b:
      cVar1 = ClrSelectedOctagon(0x101);
      break;
    case 0x48:
      cVar1 = ClrSelectedOctagon(2);
      break;
    case 0x4d:
      cVar1 = ClrSelectedOctagon(0x100);
      break;
    case 0x4f:
      cVar1 = ClrSelectedOctagon(1);
    }
    if (cVar1 != '\0') {
LAB_08061fb2:
      SetChangedFlag('\x01');
      return 0;
    }
  }
switchD_08061f68_caseD_2f:
  type = 0;
  return type;
}



// WARNING: Unknown calling convention

int ActionSetSame(int argc,char **argv,int x,int y)

{
  int iVar1;
  int type;
  LayerTypePtr pLVar2;
  LayerTypePtr layer;
  void *ptr3;
  void *local_14;
  LayerTypePtr local_10 [2];
  
  if (PCB->SilkActive == '\0') {
    layer = PCB->Data->Layer + LayerStack[0];
  }
  else {
    layer = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  iVar1 = SearchScreen(x,y,0x400d,local_10,&local_14,&ptr3);
  if (iVar1 == 4) {
    HideCrosshair('\x01');
    Settings.LineThickness = *(int *)((int)local_14 + 0x24);
    Settings.Keepaway = *(int *)((int)local_14 + 0x28) / 2;
    if (Settings.Mode != 2) {
      SetMode(2);
    }
LAB_08062168:
    RestoreCrosshair('\x01');
    hid_action("RouteStylesChanged");
LAB_08062180:
    if (PCB->SilkActive == '\0') {
      pLVar2 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    iVar1 = 0;
    if (pLVar2 != local_10[0]) {
      iVar1 = GetLayerNumber(PCB->Data,local_10[0]);
      ChangeGroupVisibility(iVar1,'\x01','\x01');
      ClearAndRedrawOutput();
      return 0;
    }
  }
  else {
    if (iVar1 < 5) {
      if (iVar1 == 1) {
        HideCrosshair('\x01');
        Settings.ViaThickness = *(int *)((int)local_14 + 0x24);
        Settings.ViaDrillingHole = *(int *)((int)local_14 + 0x30);
        Settings.Keepaway = *(int *)((int)local_14 + 0x28) / 2;
        local_10[0] = layer;
        if (Settings.Mode != 1) {
          SetMode(1);
        }
        goto LAB_08062168;
      }
    }
    else {
      if (iVar1 == 8) goto LAB_08062180;
      if (iVar1 == 0x4000) {
        HideCrosshair('\x01');
        Settings.LineThickness = *(int *)((int)local_14 + 0x24);
        Settings.Keepaway = *(int *)((int)local_14 + 0x28) / 2;
        if (Settings.Mode != 0x6d) {
          SetMode(0x6d);
        }
        goto LAB_08062168;
      }
    }
    iVar1 = 1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int ActionRedo(int argc,char **argv,int x,int y)

{
  DataTypePtr paVar1;
  int iVar2;
  LayerType *pLVar3;
  LineTypePtr line;
  LineTypePtr pLVar4;
  
  if (((Settings.Mode != 4) || (Crosshair.AttachedPolygon.PointN == 0)) &&
     (Crosshair.AttachedLine.State != 1)) {
    HideCrosshair('\x01');
    iVar2 = Redo('\x01');
    if (iVar2 != 0) {
      SetChangedFlag('\x01');
      if ((Settings.Mode == 2) && (Crosshair.AttachedLine.State != 0)) {
        if (PCB->SilkActive == '\0') {
          pLVar3 = PCB->Data->Layer + LayerStack[0];
          pLVar4 = PCB->Data->Layer[LayerStack[0]].Line;
        }
        else {
          paVar1 = PCB->Data;
          iVar2 = (uint)(Settings.ShowSolderSide == '\0') + paVar1->LayerN;
          pLVar3 = paVar1->Layer + iVar2;
          pLVar4 = paVar1->Layer[iVar2].Line;
        }
        iVar2 = pLVar3->LineN - 1;
        Crosshair.AttachedLine.Point1.X = pLVar4[iVar2].Point2.X;
        Crosshair.AttachedLine.Point1.Y = pLVar4[iVar2].Point2.Y;
        addedLines = addedLines + 1;
        Crosshair.AttachedLine.Point2.X = Crosshair.AttachedLine.Point1.X;
        Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedLine.Point1.Y;
      }
    }
    RestoreCrosshair('\x01');
    return 0;
  }
  return 1;
}



// WARNING: Unknown calling convention

int ActionToggleHideName(int argc,char **argv,int x,int y)

{
  String Ident;
  uint uVar1;
  bool bVar2;
  int iVar3;
  int type;
  DataTypePtr paVar4;
  char *function;
  ElementTypePtr element;
  ElementTypePtr Element;
  Cardinal n;
  int iVar5;
  void *local_28;
  ElementTypePtr local_24;
  void *local_20 [4];
  
  if (((0 < argc) && (Ident = *argv, Ident != (String)0x0)) && (PCB->ElementOn != '\0')) {
    HideCrosshair('\x01');
    iVar3 = GetFunctionID(Ident);
    if ((iVar3 == 0x46) || (iVar3 == 0x48)) {
      paVar4 = PCB->Data;
      iVar3 = paVar4->ElementN - 1;
      if (iVar3 != -1) {
        bVar2 = false;
        iVar5 = paVar4->ElementN * 300;
        while( true ) {
          Element = (ElementTypePtr)(paVar4->Element[-1].Flags.t + iVar5 + -0x18);
          uVar1 = (Element->Flags).f;
          if ((((uVar1 & 0x40) != 0) || ((*(byte *)&Element->Name[1].Flags.f & 0x40) != 0)) &&
             (((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide || (PCB->InvisibleObjectsOn != '\0')
              ))) {
            AddObjectToFlagUndoList(2,Element,Element,Element);
            EraseElementName(Element);
            (Element->Flags).f = (Element->Flags).f ^ 0x10;
            DrawElementName(Element,0);
            bVar2 = true;
          }
          iVar3 = iVar3 + -1;
          if (iVar3 == -1) break;
          paVar4 = PCB->Data;
          iVar5 = iVar5 + -300;
        }
        if (bVar2) {
          Draw();
          IncrementUndoSerialNumber();
        }
      }
    }
    else if (iVar3 == 0x2e) {
      (*gui->get_coords)("Select an Object",&x,&y);
      iVar3 = SearchScreen(x,y,2,local_20,&local_24,&local_28);
      if (iVar3 != 0) {
        AddObjectToFlagUndoList(iVar3,local_20[0],local_24,local_28);
        EraseElementName(local_24);
        (local_24->Flags).f = (local_24->Flags).f ^ 0x10;
        DrawElementName(local_24,0);
        Draw();
        IncrementUndoSerialNumber();
      }
    }
    RestoreCrosshair('\x01');
    return 0;
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x08062974)
// WARNING: Removing unreachable block (ram,0x08062784)
// WARNING: Removing unreachable block (ram,0x080627c0)
// WARNING: Unknown calling convention

int ActionSetValue(int argc,char **argv,int x,int y)

{
  String Ident;
  char *val_00;
  float fVar1;
  int iVar2;
  char *val;
  char *units_00;
  char *units;
  char *function;
  float value;
  float fVar3;
  char local_1d [13];
  
  if ((argc < 1) || (Ident = *argv, argc == 1)) goto LAB_08062670;
  units_00 = (char *)0x0;
  val_00 = argv[1];
  if (argc != 2) {
    units_00 = argv[2];
  }
  if ((val_00 == (char *)0x0) || (Ident == (String)0x0)) goto LAB_08062670;
  HideCrosshair('\x01');
  fVar3 = GetValue(val_00,units_00,local_1d);
  iVar2 = GetFunctionID(Ident);
  if (iVar2 == 0x52) {
LAB_080626e8:
    fVar3 = fVar3 / 45.0;
    if (local_1d[0] == '\0') {
      fVar3 = (float)Settings.TextScale + fVar3;
    }
    SetTextScale((short)ROUND(fVar3));
    goto LAB_08062858;
  }
  if (iVar2 < 0x53) {
    if (iVar2 == 0x1f) {
      if (local_1d[0] == '\0') {
        if (fVar3 == (float)(int)ROUND(fVar3)) {
          fVar1 = (float)PCB->Grid;
          if (fVar1 != (float)(int)ROUND(fVar1)) goto LAB_08062788;
        }
        else {
          fVar1 = (float)PCB->Grid;
LAB_08062788:
          if (((fVar3 == (float)(int)ROUND(fVar3)) || (fVar1 == (float)(int)ROUND(fVar1))) &&
             (fVar1 != 1.0)) {
            Message("Don\'t combine metric/English grids like that!\n");
            goto LAB_08062858;
          }
        }
        if (fVar1 + fVar3 < 1.0) {
          SetGrid(1.0,'\0');
          goto LAB_08062858;
        }
        if (fVar1 != 1.0) {
          SetGrid(fVar1 + fVar3,'\0');
          goto LAB_08062858;
        }
      }
      SetGrid(fVar3,'\0');
LAB_08062858:
      RestoreCrosshair('\x01');
      return 0;
    }
    if ((0x1e < iVar2) && (iVar2 - 0x25U < 2)) {
      if (local_1d[0] == '\0') {
        fVar3 = (float)Settings.LineThickness + fVar3;
      }
      SetLineSize((int)ROUND(fVar3));
      hid_action("RouteStylesChanged");
      goto LAB_08062858;
    }
  }
  else {
    if (iVar2 == 0x6d) {
LAB_08062816:
      if (local_1d[0] == '\0') {
        fVar3 = (float)Settings.ViaThickness + fVar3;
      }
      SetViaSize((int)ROUND(fVar3),'\0');
      hid_action("RouteStylesChanged");
      goto LAB_08062858;
    }
    if (iVar2 < 0x6e) {
      if (iVar2 == 0x54) goto LAB_080626e8;
    }
    else {
      if (iVar2 == 0x70) {
        if (local_1d[0] == '\0') {
          fVar3 = (float)Settings.ViaDrillingHole + fVar3;
        }
        SetViaDrillingHole((int)ROUND(fVar3),'\0');
        hid_action("RouteStylesChanged");
        goto LAB_08062858;
      }
      if (iVar2 == 0x71) goto LAB_08062816;
    }
  }
  RestoreCrosshair('\x01');
LAB_08062670:
  Message("Syntax error.  Usage:\n%s\n",
          "SetValue(Grid|Line|LineSize|Text|TextScale|ViaDrillingHole|Via|ViaSize, delta)");
  return 1;
}



// WARNING: Unknown calling convention

int ActionSetThermal(int argc,char **argv,int x,int y)

{
  int therm_style;
  String Ident;
  int iVar1;
  int type;
  char *style;
  int kind;
  char *function;
  float fVar2;
  void *local_1c;
  void *local_18;
  void *local_14;
  char local_d;
  
  if (argc < 1) goto LAB_080629f8;
  Ident = *argv;
  if (argc == 1) {
    style = (char *)0x0;
  }
  else {
    style = argv[1];
  }
  if ((((Ident == (String)0x0) || (style == (char *)0x0)) || (*Ident == '\0')) || (*style == '\0'))
  goto LAB_080629f8;
  fVar2 = GetValue(style,(char *)0x0,&local_d);
  HideCrosshair('\x01');
  if (local_d == '\0') {
switchD_08062a8b_caseD_2f:
    RestoreCrosshair('\x01');
LAB_080629f8:
    Message("Syntax error.  Usage:\n%s\n",
            "SetThermal(Object|SelectedPins|SelectedVias|Selected, Style)");
    return 1;
  }
  therm_style = (int)ROUND(fVar2);
  iVar1 = GetFunctionID(Ident);
  switch(iVar1) {
  case 0x2e:
    iVar1 = SearchScreen(Crosshair.X,Crosshair.Y,0x101,&local_14,&local_18,&local_1c);
    if (iVar1 != 0) {
      ChangeObjectThermal(iVar1,local_14,local_18,local_1c,therm_style);
      IncrementUndoSerialNumber();
      Draw();
    }
    break;
  default:
    goto switchD_08062a8b_caseD_2f;
  case 0x46:
  case 0x48:
    ChangeSelectedThermals(0x101,therm_style);
    break;
  case 0x4d:
    ChangeSelectedThermals(0x100,therm_style);
    break;
  case 0x4f:
    ChangeSelectedThermals(1,therm_style);
  }
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionSaveTo(int argc,char **argv,int x,int y)

{
  char *S;
  PCBTypePtr pPVar1;
  int iVar2;
  char *pcVar3;
  FILE *pFVar4;
  char *function;
  FILE *fp;
  char *name;
  FILE *fp_2;
  ElementTypePtr local_14;
  Boolean result;
  
  pcVar3 = *argv;
  S = argv[1];
  iVar2 = strcasecmp(pcVar3,"Layout");
  if (iVar2 == 0) {
LAB_08062c58:
    SavePCB(PCB->Filename);
    return 0;
  }
  if (argc == 2) {
    iVar2 = strcasecmp(pcVar3,"LayoutAs");
    if (iVar2 == 0) {
      SaveFree(PCB->Filename);
      pPVar1 = PCB;
      PCB->Filename = (char *)0x0;
      pcVar3 = MyStrdup(S,"ActionSaveTo");
      pPVar1->Filename = pcVar3;
      goto LAB_08062c58;
    }
    iVar2 = strcasecmp(pcVar3,"AllConnections");
    if (iVar2 == 0) {
      pFVar4 = CheckAndOpenFile(S,'\x01','\0',&result,(Boolean *)0x0);
      if (pFVar4 != (FILE *)0x0) {
        LookupConnectionsToAllElements(pFVar4);
LAB_08062cb1:
        fclose((FILE *)pFVar4);
        SetChangedFlag('\x01');
        return 0;
      }
    }
    else {
      iVar2 = strcasecmp(pcVar3,"AllUnusedPins");
      if (iVar2 == 0) {
        pFVar4 = CheckAndOpenFile(S,'\x01','\0',&result,(Boolean *)0x0);
        if (pFVar4 != (FILE *)0x0) {
          LookupUnusedPins(pFVar4);
          goto LAB_08062cb1;
        }
      }
      else {
        iVar2 = strcasecmp(pcVar3,"ElementConnections");
        if (iVar2 != 0) {
          iVar2 = strcasecmp(pcVar3,"PasteBuffer");
          if (iVar2 == 0) {
            iVar2 = SaveBufferElements(S);
            return iVar2;
          }
          goto LAB_08062c08;
        }
        iVar2 = SearchScreen(Crosshair.X,Crosshair.Y,2,&local_14,&local_14,&local_14);
        if ((iVar2 != 0) &&
           (pFVar4 = CheckAndOpenFile(S,'\x01','\0',&result,(Boolean *)0x0), pFVar4 != (FILE *)0x0))
        {
          LookupElementConnections(local_14,pFVar4);
          fclose((FILE *)pFVar4);
          SetChangedFlag('\x01');
          return 0;
        }
      }
    }
    iVar2 = 0;
  }
  else {
LAB_08062c08:
    Message("Syntax error.  Usage:\n%s\n",
            "SaveTo(Layout|LayoutAs,filename)\nSaveTo(AllConnections|AllUnusedPins|ElementConnections,filename)\nSaveTo(PasteBuffer,filename)"
           );
    iVar2 = 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int ActionSaveSettings(int argc,char **argv,int x,int y)

{
  uint locally_00;
  int locally;
  int iVar1;
  
  locally_00 = 0;
  if (0 < argc) {
    iVar1 = strncasecmp(*argv,"local",5);
    locally_00 = (uint)(iVar1 == 0);
  }
  hid_save_settings(locally_00);
  return 0;
}



// WARNING: Unknown calling convention

int ActionUnselect(int argc,char **argv,int x,int y)

{
  String Ident;
  Boolean BVar1;
  int iVar2;
  char *Pattern;
  int type;
  char *function;
  char *pattern;
  BoxType box;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  if (iVar2 == 0x2f) {
    iVar2 = -1;
  }
  else {
    if (iVar2 < 0x30) {
      if (iVar2 == 7) {
        box.X1 = Crosshair.AttachedBox.Point2.X;
        if (Crosshair.AttachedBox.Point1.X <= Crosshair.AttachedBox.Point2.X) {
          box.X1 = Crosshair.AttachedBox.Point1.X;
        }
        box.Y1 = Crosshair.AttachedBox.Point2.Y;
        if (Crosshair.AttachedBox.Point1.Y <= Crosshair.AttachedBox.Point2.Y) {
          box.Y1 = Crosshair.AttachedBox.Point1.Y;
        }
        box.X2 = Crosshair.AttachedBox.Point2.X;
        if (Crosshair.AttachedBox.Point2.X <= Crosshair.AttachedBox.Point1.X) {
          box.X2 = Crosshair.AttachedBox.Point1.X;
        }
        box.Y2 = Crosshair.AttachedBox.Point2.Y;
        if (Crosshair.AttachedBox.Point2.Y <= Crosshair.AttachedBox.Point1.Y) {
          box.Y2 = Crosshair.AttachedBox.Point1.Y;
        }
        NotifyBlock();
        if ((Crosshair.AttachedBox.State == 2) && (BVar1 = SelectBlock(&box,'\0'), BVar1 != '\0')) {
          SetChangedFlag('\x01');
          Crosshair.AttachedBox.State = 0;
        }
        goto LAB_08062f36;
      }
      if (iVar2 < 8) {
        if (iVar2 != 1) {
LAB_08062e46:
          RestoreCrosshair('\x01');
          Message("Syntax error.  Usage:\n%s\n",
                  "Unselect(All|Block|Connection)\nUnselect(ElementByName|ObjectByName|PadByName|PinByName)\nUnselect(ElementByName|ObjectByName|PadByName|PinByName, Name)\nUnselect(TextByName|ViaByName)\nUnselect(TextByName|ViaByName, Name)\n"
                 );
          return 1;
        }
        box.X1 = -10000000;
        box.Y1 = -10000000;
        box.X2 = 10000000;
        box.Y2 = 10000000;
        BVar1 = SelectBlock(&box,'\0');
        if (BVar1 == '\0') goto LAB_08062f36;
      }
      else {
        if (iVar2 != 0xf) {
          if (iVar2 != 0x18) goto LAB_08062e46;
          iVar2 = 2;
          goto commonByName;
        }
        BVar1 = SelectConnection('\0');
        if (BVar1 == '\0') goto LAB_08062f36;
        IncrementUndoSerialNumber();
      }
      SetChangedFlag('\x01');
      goto LAB_08062f36;
    }
    if (iVar2 == 0x32) {
      iVar2 = 0x100;
    }
    else if (iVar2 < 0x33) {
      if (iVar2 != 0x31) goto LAB_08062e46;
      iVar2 = 0x200;
    }
    else if (iVar2 == 0x53) {
      iVar2 = 0x10;
    }
    else {
      if (iVar2 != 0x6e) goto LAB_08062e46;
      iVar2 = 1;
    }
  }
commonByName:
  if (((argc != 1) && (Pattern = argv[1], Pattern != (char *)0x0)) ||
     (Pattern = (*gui->prompt_for)("Enter pattern:",""), Pattern != (char *)0x0)) {
    BVar1 = SelectObjectByName(iVar2,Pattern,'\0');
    if (BVar1 != '\0') {
      SetChangedFlag('\x01');
    }
    if ((argc == 1) || (argv[1] == (char *)0x0)) {
      free(Pattern);
    }
  }
LAB_08062f36:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionRemoveSelected(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  
  HideCrosshair('\x01');
  BVar1 = RemoveSelected();
  if (BVar1 != '\0') {
    SetChangedFlag('\x01');
  }
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionAtomic(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  if (argc != 1) {
    Message("Syntax error.  Usage:\n%s\n","Atomic(Save|Restore|Close|Block)");
    return 1;
  }
  iVar1 = GetFunctionID(*argv);
  if (iVar1 == 0xe) {
    RestoreUndoSerialNumber();
    IncrementUndoSerialNumber();
    return 0;
  }
  if (iVar1 < 0xf) {
    if (iVar1 == 7) {
      RestoreUndoSerialNumber();
      if (Bumped != '\0') {
        IncrementUndoSerialNumber();
        return 0;
      }
    }
  }
  else {
    if (iVar1 == 0x42) {
      RestoreUndoSerialNumber();
      return 0;
    }
    if (iVar1 == 0x44) {
      SaveUndoSerialNumber();
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int ActionSelect(int argc,char **argv,int x,int y)

{
  double dVar1;
  String Ident;
  Boolean BVar2;
  char cVar3;
  int iVar4;
  char *Pattern;
  int type;
  char *function;
  char *pattern;
  BoxType box;
  int local_24;
  int local_20 [4];
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar4 = GetFunctionID(Ident);
  switch(iVar4) {
  default:
    RestoreCrosshair('\x01');
    Message("Syntax error.  Usage:\n%s\n",
            "Select(ToggleObject)\nSelect(All|Block|Connection)\nSelect(ElementByName|ObjectByName|PadByName|PinByName)\nSelect(ElementByName|ObjectByName|PadByName|PinByName, Name)\nSelect(TextByName|ViaByName)\nSelect(TextByName|ViaByName, Name)\nSelect(Convert)"
           );
    return 1;
  case 1:
    box.X1 = -10000000;
    box.Y1 = -10000000;
    box.X2 = 10000000;
    box.Y2 = 10000000;
    cVar3 = SelectBlock(&box,'\x01');
    goto joined_r0x080632b0;
  case 7:
    box.X1 = Crosshair.AttachedBox.Point2.X;
    if (Crosshair.AttachedBox.Point1.X <= Crosshair.AttachedBox.Point2.X) {
      box.X1 = Crosshair.AttachedBox.Point1.X;
    }
    box.Y1 = Crosshair.AttachedBox.Point2.Y;
    if (Crosshair.AttachedBox.Point1.Y <= Crosshair.AttachedBox.Point2.Y) {
      box.Y1 = Crosshair.AttachedBox.Point1.Y;
    }
    box.X2 = Crosshair.AttachedBox.Point2.X;
    if (Crosshair.AttachedBox.Point2.X <= Crosshair.AttachedBox.Point1.X) {
      box.X2 = Crosshair.AttachedBox.Point1.X;
    }
    box.Y2 = Crosshair.AttachedBox.Point2.Y;
    if (Crosshair.AttachedBox.Point2.Y <= Crosshair.AttachedBox.Point1.Y) {
      box.Y2 = Crosshair.AttachedBox.Point1.Y;
    }
    NotifyBlock();
    if ((Crosshair.AttachedBox.State == 2) && (BVar2 = SelectBlock(&box,'\x01'), BVar2 != '\0')) {
      SetChangedFlag('\x01');
      Crosshair.AttachedBox.State = 0;
    }
    goto LAB_08063266;
  case 0xf:
    BVar2 = SelectConnection('\x01');
    if (BVar2 == '\0') goto LAB_08063266;
    IncrementUndoSerialNumber();
    goto LAB_080632b2;
  case 0x10:
    Note.Buffer = Settings.BufferNumber;
    SetBufferNumber(4);
    ClearBuffer(Buffers + Settings.BufferNumber);
    (*gui->get_coords)("Select the Element\'s Mark Location",local_20,&local_24);
    dVar1 = PCB->Grid;
    local_20[0] = (int)ROUND((double)PCB->GridOffsetX +
                             (double)(int)ROUND(((double)(local_20[0] - PCB->GridOffsetX) +
                                                dVar1 * 0.5) / dVar1) * dVar1 + 0.5);
    local_24 = (int)ROUND((double)PCB->GridOffsetY +
                          (double)(int)ROUND(((double)(local_24 - PCB->GridOffsetY) + dVar1 * 0.5) /
                                             dVar1) * dVar1 + 0.5);
    AddSelectedToBuffer(Buffers + Settings.BufferNumber,local_20[0],local_24,'\x01');
    SaveUndoSerialNumber();
    RemoveSelected();
    ConvertBufferToElement(Buffers + Settings.BufferNumber);
    RestoreUndoSerialNumber();
    CopyPastebufferToLayout(local_20[0],local_24);
    SetBufferNumber(Note.Buffer);
    goto LAB_08063266;
  case 0x18:
    iVar4 = 2;
    break;
  case 0x2e:
  case 0x5f:
    cVar3 = SelectObject();
joined_r0x080632b0:
    if (cVar3 != '\0') {
LAB_080632b2:
      SetChangedFlag('\x01');
    }
    goto LAB_08063266;
  case 0x2f:
    iVar4 = -1;
    break;
  case 0x31:
    iVar4 = 0x200;
    break;
  case 0x32:
    iVar4 = 0x100;
    break;
  case 0x53:
    iVar4 = 0x10;
    break;
  case 0x6e:
    iVar4 = 1;
  }
  if (((argc != 1) && (Pattern = argv[1], Pattern != (char *)0x0)) ||
     (Pattern = (*gui->prompt_for)("Enter pattern:",""), Pattern != (char *)0x0)) {
    BVar2 = SelectObjectByName(iVar4,Pattern,'\x01');
    if (BVar2 != '\0') {
      SetChangedFlag('\x01');
    }
    if ((argc == 1) || (argv[1] == (char *)0x0)) {
      free(Pattern);
    }
  }
LAB_08063266:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int ActionRipUp(int argc,char **argv,int x,int y)

{
  String Ident;
  uint uVar1;
  bool bVar2;
  Boolean changed;
  int iVar3;
  PCBTypePtr pPVar4;
  Cardinal l;
  uint uVar5;
  DataTypePtr paVar6;
  PinTypePtr via_1;
  LineTypePtr line;
  uchar *puVar7;
  PinTypePtr via;
  PinTypePtr paVar8;
  LineTypePtr line_1;
  DataTypePtr paVar9;
  char *function;
  Cardinal n_1;
  Cardinal n;
  Cardinal n_2;
  uint uVar10;
  LayerTypePtr layer;
  int iVar11;
  LayerTypePtr layer_1;
  LayerType *pLVar12;
  uint local_30;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar3 = GetFunctionID(Ident);
  if (iVar3 == 0x17) {
    iVar3 = SearchScreen(Crosshair.X,Crosshair.Y,2,local_20,&local_24,&local_28);
    if (iVar3 != 0) {
      Note.Buffer = Settings.BufferNumber;
      SetBufferNumber(4);
      ClearBuffer(Buffers + Settings.BufferNumber);
      CopyObjectToBuffer(Buffers[Settings.BufferNumber].Data,PCB->Data,2,local_20[0],local_24,
                         local_28);
      SmashBufferElement(Buffers + Settings.BufferNumber);
      iVar3 = Settings.BufferNumber;
      Buffers[Settings.BufferNumber].X = 0;
      Buffers[iVar3].Y = 0;
      SaveUndoSerialNumber();
      EraseObject(2,local_20[0],local_20[0]);
      MoveObjectToRemoveUndoList(2,local_20[0],local_24,local_28);
      RestoreUndoSerialNumber();
      CopyPastebufferToLayout(0,0);
      SetBufferNumber(Note.Buffer);
      SetChangedFlag('\x01');
    }
  }
  else {
    if (iVar3 == 0x46) {
      bVar2 = false;
      paVar9 = PCB->Data;
      pLVar12 = paVar9->Layer;
      pPVar4 = PCB;
      if (paVar9->LayerN != -2) {
        uVar5 = 0;
        do {
          if (pLVar12->On != '\0') {
            iVar3 = pLVar12->LineN - 1;
            if (iVar3 != -1) {
              iVar11 = pLVar12->LineN * 0x58 + -0x58;
              do {
                while (puVar7 = (pLVar12->Line->Flags).t + iVar11 + -0x18,
                      (*(uint *)(puVar7 + 0x14) & 0x20c0) == 0xc0) {
                  iVar3 = iVar3 + -1;
                  iVar11 = iVar11 + -0x58;
                  RemoveObject(4,pLVar12,puVar7,puVar7);
                  bVar2 = true;
                  pPVar4 = PCB;
                  if (iVar3 == -1) goto LAB_08063678;
                }
                iVar3 = iVar3 + -1;
                iVar11 = iVar11 + -0x58;
                pPVar4 = PCB;
              } while (iVar3 != -1);
            }
          }
LAB_08063678:
          paVar9 = pPVar4->Data;
          uVar5 = uVar5 + 1;
          if (paVar9->LayerN + 2U <= uVar5) break;
          pLVar12 = pLVar12 + 1;
        } while( true );
      }
      if (pPVar4->ViaOn != '\0') {
        paVar6 = pPVar4->Data;
        if (paVar6->ViaN != 0) {
          uVar10 = 0;
          uVar5 = paVar9->ViaN;
          do {
            paVar8 = paVar6->Via + uVar10;
            if (((paVar8->Flags).f & 0x20c0) == 0xc0) {
              RemoveObject(1,paVar8,paVar8,paVar8);
              bVar2 = true;
              pPVar4 = PCB;
            }
            paVar6 = pPVar4->Data;
            uVar1 = paVar6->ViaN;
          } while ((uVar1 != 0) &&
                  (uVar10 = (uVar1 + 1 + uVar10) - uVar5, uVar5 = uVar1, uVar10 < uVar1));
        }
      }
    }
    else {
      if (iVar3 != 1) goto LAB_080635c6;
      local_30 = 0;
      bVar2 = false;
      paVar9 = PCB->Data;
      pLVar12 = paVar9->Layer;
      pPVar4 = PCB;
      if (paVar9->LayerN != -2) {
        bVar2 = false;
        do {
          iVar3 = pLVar12->LineN - 1;
          if (iVar3 != -1) {
            iVar11 = pLVar12->LineN * 0x58 + -0x58;
            do {
              while (puVar7 = (pLVar12->Line->Flags).t + iVar11 + -0x18,
                    (*(uint *)(puVar7 + 0x14) & 0x2080) == 0x80) {
                iVar3 = iVar3 + -1;
                iVar11 = iVar11 + -0x58;
                RemoveObject(4,pLVar12,puVar7,puVar7);
                bVar2 = true;
                pPVar4 = PCB;
                if (iVar3 == -1) goto LAB_080637b5;
              }
              iVar3 = iVar3 + -1;
              iVar11 = iVar11 + -0x58;
              pPVar4 = PCB;
            } while (iVar3 != -1);
          }
LAB_080637b5:
          paVar9 = pPVar4->Data;
          local_30 = local_30 + 1;
          if (paVar9->LayerN + 2U <= local_30) break;
          pLVar12 = pLVar12 + 1;
        } while( true );
      }
      if (paVar9->ViaN != 0) {
        uVar10 = 0;
        uVar5 = paVar9->ViaN;
        do {
          paVar8 = paVar9->Via + uVar10;
          if (((paVar8->Flags).f & 0x2080) == 0x80) {
            RemoveObject(1,paVar8,paVar8,paVar8);
            bVar2 = true;
            pPVar4 = PCB;
          }
          paVar9 = pPVar4->Data;
          uVar1 = paVar9->ViaN;
        } while ((uVar1 != 0) &&
                (uVar10 = (uVar1 + 1 + uVar10) - uVar5, uVar5 = uVar1, uVar10 < uVar1));
      }
    }
    if (bVar2) {
      IncrementUndoSerialNumber();
      SetChangedFlag('\x01');
    }
  }
LAB_080635c6:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionChangePinName(int argc,char **argv,int x,int y)

{
  void *pvVar1;
  char *__s1;
  char *__s1_00;
  char *pcVar2;
  ElementTypePtr paVar3;
  char *__s2;
  int iVar4;
  bool bVar5;
  DataTypePtr paVar6;
  int iVar7;
  Cardinal sn;
  uint uVar8;
  undefined4 uVar9;
  Cardinal n_1;
  uint uVar10;
  Cardinal n;
  uint uVar11;
  ElementTypePtr element;
  char *pinnum;
  Cardinal sn_1;
  PinTypePtr pin;
  int local_30;
  int local_2c;
  
  if (argc != 3) {
    Message("Syntax error.  Usage:\n%s\n","ChangePinName(ElementName,PinNumber,PinName)");
    return 1;
  }
  __s1 = *argv;
  __s1_00 = argv[1];
  pcVar2 = argv[2];
  paVar6 = PCB->Data;
  local_2c = paVar6->ElementN - 1;
  if (local_2c != -1) {
    bVar5 = false;
    iVar4 = paVar6->ElementN * 300;
    while( true ) {
      local_30 = iVar4 + -300;
      paVar3 = paVar6->Element;
      if (__s1 != (char *)0x0) {
        __s2 = *(char **)((int)(&paVar3[-1].Name[1].Flags + 2) + iVar4 + 8);
        if ((__s2 != (char *)0x0) && (iVar7 = strcmp(__s1,__s2), iVar7 == 0)) {
          uVar8 = *(uint *)((int)&paVar3[-1].PinN + iVar4);
          if (uVar8 != 0) {
            uVar10 = 0;
            do {
              uVar11 = uVar8;
              if (__s1_00 != (char *)0x0) {
                pvVar1 = (void *)(*(int *)((int)&paVar3[-1].Pin + iVar4) + uVar10 * 0x4c);
                if (*(char **)((int)pvVar1 + 0x40) != (char *)0x0) {
                  iVar7 = strcmp(__s1_00,*(char **)((int)pvVar1 + 0x40));
                  if (iVar7 == 0) {
                    AddObjectToChangeNameUndoList
                              (0x100,(void *)0x0,(void *)0x0,pvVar1,*(char **)((int)pvVar1 + 0x3c));
                    uVar9 = __strdup(pcVar2);
                    *(undefined4 *)((int)pvVar1 + 0x3c) = uVar9;
                    SetChangedFlag('\x01');
                    bVar5 = true;
                  }
                  uVar11 = *(uint *)((int)&paVar3[-1].PinN + iVar4);
                }
              }
            } while ((uVar11 != 0) &&
                    (uVar10 = (uVar10 + 1 + uVar11) - uVar8, uVar8 = uVar11, uVar10 < uVar11));
          }
          uVar8 = *(uint *)((int)&paVar3[-1].PadN + iVar4);
          uVar10 = uVar8;
          for (uVar11 = 0; (uVar10 != 0 && (uVar11 < uVar10)); uVar11 = uVar11 + (uVar8 == uVar10))
          {
            if (__s1_00 != (char *)0x0) {
              pvVar1 = (void *)(*(int *)((int)&paVar3[-1].Pad + iVar4) + uVar11 * 0x68);
              if ((*(char **)((int)pvVar1 + 0x5c) != (char *)0x0) &&
                 (iVar7 = strcmp(__s1_00,*(char **)((int)pvVar1 + 0x5c)), iVar7 == 0)) {
                AddObjectToChangeNameUndoList
                          (0x200,(void *)0x0,(void *)0x0,pvVar1,*(char **)((int)pvVar1 + 0x58));
                uVar9 = __strdup(pcVar2);
                *(undefined4 *)((int)pvVar1 + 0x58) = uVar9;
                SetChangedFlag('\x01');
                bVar5 = true;
                uVar10 = *(uint *)((int)&paVar3[-1].PadN + iVar4);
              }
            }
          }
        }
      }
      local_2c = local_2c + -1;
      if (local_2c == -1) break;
      paVar6 = PCB->Data;
      iVar4 = local_30;
    }
    if (bVar5) {
      IncrementUndoSerialNumber();
      (*gui->invalidate_all)();
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int ActionRenumber(int argc,char **argv,int x,int y)

{
  char cVar1;
  Cardinal CVar2;
  FILE *pFVar3;
  FILE *out;
  int iVar4;
  ElementTypePtr *__ptr;
  void *__ptr_00;
  void *pvVar5;
  void *pvVar6;
  uint uVar7;
  char *pcVar8;
  size_t sVar9;
  undefined4 uVar10;
  size_t sVar11;
  void *pvVar12;
  int iVar13;
  ElementTypePtr *ppaVar14;
  ElementTypePtr paVar15;
  size_t sz;
  char *pcVar16;
  uint j;
  uint uVar17;
  ElementTypePtr *ppaVar18;
  size_t cnt_list_sz;
  PCBTypePtr pPVar19;
  char *name;
  ElementTypePtr element;
  uint k;
  ElementTypePtr *element_list;
  uint tmpi;
  char **ppcVar20;
  uint i;
  ElementTypePtr *ppaVar21;
  _cnt_list *cnt_list;
  int iVar22;
  bool bVar23;
  uint local_58;
  uint local_4c;
  char **local_44;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  PCBTypePtr local_28;
  int local_24;
  
  if (argc < 1) {
    name = (*gui->fileselect)("Save Renumber Annotation File As ...",
                              "Choose a file to record the renumbering to.\nThis file may be used to back annotate the\nchange to the schematics.\n"
                              ,ActionRenumber::default_file,".eco","eco",0);
    bVar23 = name != (char *)0x0;
  }
  else {
    bVar23 = false;
    name = *argv;
  }
  if (ActionRenumber::default_file != (char *)0x0) {
    free(ActionRenumber::default_file);
    ActionRenumber::default_file = (char *)0x0;
  }
  if ((name != (char *)0x0) && (*name != '\0')) {
    ActionRenumber::default_file = (char *)__strdup(name);
  }
  pFVar3 = fopen(name,"r");
  if (pFVar3 != (FILE *)0x0) {
    fclose(pFVar3);
    iVar4 = (*gui->confirm_dialog)("File exists!  Ok to overwrite?",0);
    if (iVar4 == 0) {
      if (!bVar23) {
        return 0;
      }
      free(name);
      return 0;
    }
  }
  pFVar3 = fopen(name,"w");
  if (pFVar3 == (FILE *)0x0) {
    Message("Could not open %s\n",name);
    if (!bVar23) {
      return 1;
    }
    free(name);
    return 1;
  }
  if (bVar23) {
    free(name);
  }
  __fprintf_chk(pFVar3,1,"*COMMENT* PCB Annotation File\n");
  __fprintf_chk(pFVar3,1,"*FILEVERSION* 20061031\n");
  __ptr = (ElementTypePtr *)calloc(PCB->Data->ElementN,4);
  __ptr_00 = calloc(PCB->Data->ElementN,4);
  pvVar5 = calloc(PCB->Data->ElementN,4);
  pvVar6 = calloc(PCB->Data->ElementN,4);
  if ((((__ptr_00 == (void *)0x0) || (__ptr == (ElementTypePtr *)0x0)) || (pvVar6 == (void *)0x0))
     || (pvVar5 == (void *)0x0)) {
    pcVar8 = "calloc() failed in %s\n";
LAB_080646b7:
    __fprintf_chk(stderr,1,pcVar8,"ActionRenumber");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  local_28 = PCB;
  CVar2 = PCB->Data->ElementN;
  local_24 = CVar2 - 1;
  if (local_24 != -1) {
    local_4c = 0;
    local_30 = 0;
    local_2c = CVar2 * 300 + -300;
    element = PCB->Data->Element + (CVar2 - 1);
    if ((*(byte *)((int)&element->Name[0].Flags.f + 1) & 0x20) != 0) goto LAB_08063ec8;
    do {
      if ((*(byte *)((int)&(element->Flags).f + 1) & 0x20) != 0) goto LAB_08063ec8;
      uVar7 = 0;
      paVar15 = *__ptr;
      ppaVar18 = __ptr;
      if (paVar15 != (ElementTypePtr)0x0) {
        iVar4 = element->MarkY;
        iVar22 = paVar15->MarkY;
        if (iVar22 < iVar4) {
          uVar7 = 0;
          do {
            ppaVar18 = ppaVar18 + 1;
            paVar15 = *ppaVar18;
            uVar7 = uVar7 + 1;
            if (paVar15 == (ElementTypePtr)0x0) goto LAB_08063e5f;
            iVar22 = paVar15->MarkY;
          } while (iVar22 < iVar4);
        }
        else {
          uVar7 = 0;
        }
        if ((iVar4 == iVar22) && (paVar15->MarkX < element->MarkX)) {
          uVar7 = uVar7 + 1;
          ppaVar18 = __ptr + uVar7;
          while (((paVar15 = *ppaVar18, paVar15 != (ElementTypePtr)0x0 && (paVar15->MarkY == iVar4))
                 && (paVar15->MarkX < element->MarkX))) {
            uVar7 = uVar7 + 1;
            ppaVar18 = ppaVar18 + 1;
          }
        }
      }
LAB_08063e5f:
      if (uVar7 < local_4c) {
        ppaVar21 = __ptr + (local_4c - 1);
        ppaVar14 = __ptr + local_4c;
        uVar17 = local_4c;
        do {
          paVar15 = *ppaVar21;
          uVar17 = uVar17 - 1;
          ppaVar21 = ppaVar21 + -1;
          *ppaVar14 = paVar15;
          ppaVar14 = ppaVar14 + -1;
        } while (uVar7 < uVar17);
      }
      local_4c = local_4c + 1;
      *ppaVar18 = element;
      while( true ) {
        uVar7 = local_30;
        local_24 = local_24 + -1;
        iVar4 = local_2c + -300;
        if (local_24 == -1) {
          local_58 = (local_28->Flags).f;
          (local_28->Flags).f = local_58 & 0xfffffbff;
          local_58 = local_58 & 0x400;
          local_44 = (char **)calloc(100,8);
          if (local_4c == 0) goto LAB_08064697;
          local_2c = 0;
          local_30 = 100;
          local_38 = 0;
          bVar23 = false;
          goto LAB_08063ff0;
        }
        element = (ElementTypePtr)(local_28->Data->Element[-1].Flags.t + local_2c + -0x18);
        local_2c = iVar4;
        if ((*(byte *)((int)&element->Name[0].Flags.f + 1) & 0x20) == 0) break;
LAB_08063ec8:
        pcVar8 = element->Name[1].TextString;
        if ((pcVar8 == (char *)0x0) || (*pcVar8 == '\0')) {
          pcVar8 = "(unknown)";
        }
        __fprintf_chk(pFVar3,1,
                      "*WARN* Element \"%s\" at (%d,%d) is locked and will not be renumbered.\n",
                      pcVar8,element->MarkX,element->MarkY);
        *(ElementTypePtr *)((int)__ptr_00 + local_30 * 4) = element;
        local_28 = PCB;
        local_30 = local_30 + 1;
      }
    } while( true );
  }
  local_58 = (PCB->Flags).f;
  (PCB->Flags).f = local_58 & 0xfffffbff;
  local_58 = local_58 & 0x400;
  local_44 = (char **)calloc(100,8);
LAB_08064697:
  local_2c = 0;
  bVar23 = false;
LAB_0806428f:
  fclose(pFVar3);
  if (local_58 != 0) {
    (PCB->Flags).f = (PCB->Flags).f | 0x400;
  }
  if (bVar23) {
    AddNetlistLibToUndoList(&PCB->NetlistLib);
    if ((PCB->NetlistLib).MenuN != 0) {
      local_28 = (PCBTypePtr)0x0;
      local_38 = 0;
      pPVar19 = PCB;
      do {
        iVar22 = 0;
        iVar4 = (int)&((pPVar19->NetlistLib).Menu)->Name + (int)local_28;
        local_34 = 0;
        if (*(int *)(iVar4 + 0xc) != 0) {
          do {
            pcVar8 = (char *)__strdup(*(undefined4 *)(*(int *)(iVar4 + 0x14) + iVar22));
            if ((*pcVar8 == '\0') || (iVar4 = 0, *pcVar8 == '-')) {
              iVar13 = 1;
              pcVar16 = pcVar8;
            }
            else {
              do {
                iVar13 = iVar4;
                iVar4 = iVar13 + 1;
                pcVar16 = pcVar8 + iVar4;
                if (pcVar8[iVar4] == '-') break;
              } while (pcVar8[iVar4] != '\0');
              iVar13 = iVar13 + 2;
            }
            *pcVar16 = '\0';
            if (local_2c != 0) {
              uVar7 = 0;
              do {
                while( true ) {
                  iVar4 = strcmp(pcVar8,*(char **)((int)pvVar5 + uVar7 * 4));
                  if (iVar4 != 0) break;
                  free(*(void **)(*(int *)((int)&((PCB->NetlistLib).Menu)->Entry + (int)local_28) +
                                 iVar22));
                  iVar4 = *(int *)((int)&((PCB->NetlistLib).Menu)->Entry + (int)local_28);
                  ppcVar20 = (char **)((int)pvVar6 + uVar7 * 4);
                  sVar9 = strlen(*ppcVar20);
                  sVar11 = strlen(pcVar8 + iVar13);
                  pvVar12 = calloc(1,sVar9 + 2 + sVar11);
                  *(void **)(iVar22 + iVar4) = pvVar12;
                  __sprintf_chk(*(undefined4 *)
                                 (*(int *)((int)&((PCB->NetlistLib).Menu)->Entry + (int)local_28) +
                                 iVar22),1,0xffffffff,"%s-%s",*ppcVar20,pcVar8 + iVar13);
                  uVar7 = local_2c + 1;
                  if (local_2c <= uVar7) goto LAB_08064551;
                }
                uVar7 = uVar7 + 1;
              } while (uVar7 < local_2c);
            }
LAB_08064551:
            iVar22 = iVar22 + 0x18;
            free(pcVar8);
            local_34 = local_34 + 1;
            iVar4 = (int)&((PCB->NetlistLib).Menu)->Name + (int)local_28;
            pPVar19 = PCB;
          } while (local_34 <= *(uint *)(iVar4 + 0xc) && *(uint *)(iVar4 + 0xc) != local_34);
        }
        local_38 = local_38 + 1;
        local_28 = (PCBTypePtr)((int)local_28 + 0x1c);
      } while (local_38 <= (pPVar19->NetlistLib).MenuN && (pPVar19->NetlistLib).MenuN != local_38);
    }
    if (local_2c != 0) {
      uVar7 = 0;
      do {
        free(*(void **)((int)pvVar5 + uVar7 * 4));
        iVar4 = uVar7 * 4;
        uVar7 = uVar7 + 1;
        free(*(void **)((int)pvVar6 + iVar4));
      } while (uVar7 < local_2c);
    }
    hid_action("NetlistChanged");
    IncrementUndoSerialNumber();
    SetChangedFlag('\x01');
  }
  free(__ptr_00);
  free(__ptr);
  free(local_44);
  return 0;
LAB_08063ff0:
  do {
    paVar15 = __ptr[local_38];
    pcVar8 = paVar15->Name[1].TextString;
    if (pcVar8 == (char *)0x0) {
      __fprintf_chk(pFVar3,1,"*WARN* Element at (%d,%d) has no name.\n",paVar15->MarkX,
                    paVar15->MarkY);
    }
    else {
      local_28 = (PCBTypePtr)__strdup(pcVar8);
      cVar1 = *(char *)local_28;
      pcVar8 = (char *)local_28;
      if ((9 < (byte)(cVar1 - 0x30U)) && (cVar1 != '\0')) {
        while (cVar1 != '?') {
          pcVar8 = pcVar8 + 1;
          cVar1 = *pcVar8;
          if (((byte)(cVar1 - 0x30U) < 10) || (cVar1 == '\0')) break;
        }
      }
      *pcVar8 = '\0';
      local_24 = 0;
      uVar17 = 0;
      pcVar8 = *local_44;
      if (pcVar8 != (char *)0x0) {
        local_24 = 0;
        do {
          iVar4 = strcmp(pcVar8,(char *)local_28);
          if ((iVar4 == 0) || (local_30 <= uVar17)) break;
          uVar17 = uVar17 + 1;
          pcVar8 = local_44[uVar17 * 2];
          local_24 = uVar17 * 8;
        } while (pcVar8 != (char *)0x0);
      }
      if (uVar17 == local_30) {
        local_30 = local_30 + 100;
        local_44 = (char **)realloc(local_44,local_30);
        if (local_44 == (char **)0x0) {
          pcVar8 = "realloc failed() in %s\n";
          goto LAB_080646b7;
        }
        ppcVar20 = local_44 + uVar17 * 2;
        if (local_30 <= uVar17) goto LAB_080640b0;
        do {
          uVar17 = uVar17 + 1;
          *ppcVar20 = (char *)0x0;
          ppcVar20[1] = (char *)0x0;
          ppcVar20 = ppcVar20 + 2;
        } while (uVar17 < local_30);
        ppcVar20 = (char **)((int)local_44 + local_24);
        pcVar8 = *ppcVar20;
      }
      else {
LAB_080640b0:
        ppcVar20 = (char **)((int)local_44 + local_24);
        pcVar8 = *ppcVar20;
      }
      if (pcVar8 == (char *)0x0) {
        pcVar8 = (char *)__strdup(local_28);
        ppcVar20[1] = (char *)0x0;
        *ppcVar20 = pcVar8;
        pcVar8 = (char *)0x0;
        goto LAB_080640c3;
      }
      while( true ) {
        pcVar8 = ppcVar20[1];
LAB_080640c3:
        ppcVar20[1] = pcVar8 + 1;
        free(local_28);
        sVar9 = strlen(*ppcVar20);
        sVar9 = sVar9 + 2;
        for (pcVar8 = ppcVar20[1]; (char *)0xa < pcVar8; pcVar8 = (char *)((uint)pcVar8 / 10)) {
          sVar9 = sVar9 + 1;
        }
        local_28 = (PCBTypePtr)calloc(1,sVar9);
        __sprintf_chk(local_28,1,0xffffffff,&DAT_08139f46,*ppcVar20,ppcVar20[1]);
        if (uVar7 == 0) break;
        uVar17 = 0;
        while( true ) {
          pcVar8 = *(char **)(*(int *)((int)__ptr_00 + uVar17 * 4) + 0x94);
          if ((pcVar8 == (char *)0x0) || (*pcVar8 == '\0')) {
            pcVar8 = "(unknown)";
          }
          iVar4 = strcmp(pcVar8,(char *)local_28);
          if (iVar4 == 0) break;
          uVar17 = uVar17 + 1;
          if (uVar7 <= uVar17) goto LAB_08064198;
        }
      }
LAB_08064198:
      pcVar8 = __ptr[local_38]->Name[1].TextString;
      iVar4 = strcmp((char *)local_28,pcVar8);
      if (iVar4 == 0) {
        free(local_28);
      }
      else {
        __fprintf_chk(pFVar3,1,"*RENAME* \"%s\" \"%s\"\n",pcVar8,local_28);
        uVar10 = __strdup(__ptr[local_38]->Name[1].TextString);
        *(undefined4 *)((int)pvVar5 + local_2c * 4) = uVar10;
        uVar10 = __strdup(local_28);
        *(undefined4 *)((int)pvVar6 + local_2c * 4) = uVar10;
        local_2c = local_2c + 1;
        AddObjectToChangeNameUndoList
                  (2,(void *)0x0,(void *)0x0,__ptr[local_38],__ptr[local_38]->Name[1].TextString);
        ChangeObjectName(2,__ptr[local_38],(void *)0x0,(void *)0x0,(char *)local_28);
        bVar23 = true;
      }
    }
    local_38 = local_38 + 1;
  } while (local_38 < local_4c);
  goto LAB_0806428f;
}



// WARNING: Unknown calling convention

int ActionQuit(int argc,char **argv,int x,int y)

{
  char *force;
  int iVar1;
  
  if ((0 < argc) && (*argv != (char *)0x0)) {
    iVar1 = strcasecmp(*argv,"force");
    if (iVar1 == 0) {
      PCB->Changed = '\0';
                    // WARNING: Subroutine does not return
      exit(0);
    }
  }
  if (PCB->Changed != '\0') {
    iVar1 = (*gui->close_confirm_dialog)();
    if (iVar1 != 1) {
      return 1;
    }
  }
  QuitApplication();
  return 1;
}



// WARNING: Unknown calling convention

int ActionPasteBuffer(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  int iVar2;
  int y_1;
  int number;
  long lVar3;
  char *__filename;
  FILE *__stream;
  FILE *exist;
  char *pcVar4;
  char *name;
  char *function;
  int x_1;
  String Ident;
  int iVar5;
  bool bVar6;
  float fVar7;
  char *local_38;
  char local_1d [13];
  
  if (argc == 0) {
    Ident = "";
    HideCrosshair('\x01');
    local_38 = "";
    iVar2 = GetFunctionID("");
    iVar5 = iVar2 + -0x28;
    bVar6 = iVar5 == 0;
    if (bVar6) {
LAB_08064944:
      MirrorBuffer(Buffers + Settings.BufferNumber);
      goto LAB_08064900;
    }
  }
  else {
    Ident = *argv;
    if (argc < 2) {
      local_38 = "";
    }
    else {
      local_38 = argv[1];
    }
    HideCrosshair('\x01');
    if (Ident == (String)0x0) goto LAB_08064900;
    iVar2 = GetFunctionID(Ident);
    iVar5 = iVar2 + -0x28;
    bVar6 = iVar2 == 0x28;
    if (bVar6) goto LAB_08064944;
  }
  if (bVar6 || SBORROW4(iVar2,0x28) != iVar5 < 0) {
    if (iVar2 == 0xb) {
      ClearBuffer(Buffers + Settings.BufferNumber);
      goto LAB_08064900;
    }
    if (iVar2 == 0x10) {
      ConvertBufferToElement(Buffers + Settings.BufferNumber);
      goto LAB_08064900;
    }
    if (iVar2 == 0) {
      AddSelectedToBuffer(Buffers + Settings.BufferNumber,0,0,'\0');
      goto LAB_08064900;
    }
    goto LAB_080649b1;
  }
  if (iVar2 == 0x43) {
    if (local_38 != (char *)0x0) {
      lVar3 = strtol(local_38,(char **)0x0,10);
      RotateBuffer(Buffers + Settings.BufferNumber,(BYTE)lVar3);
      SetCrosshairRangeToBuffer();
    }
    goto LAB_08064900;
  }
  if (iVar2 < 0x44) {
    if (iVar2 == 0x42) {
      SmashBufferElement(Buffers + Settings.BufferNumber);
      goto LAB_08064900;
    }
  }
  else {
    if (iVar2 == 0x44) {
      if ((Buffers[Settings.BufferNumber].Data)->ElementN == 0) {
        Message("Buffer has no elements!\n");
        goto LAB_08064900;
      }
      if (argc < 2) {
        pcVar4 = (*gui->fileselect)("Save Paste Buffer As ...",
                                    "Choose a file to save the contents of the\npaste buffer to.\n",
                                    ActionPasteBuffer::default_file,".fp","footprint",0);
        if (ActionPasteBuffer::default_file != (char *)0x0) {
          free(ActionPasteBuffer::default_file);
          ActionPasteBuffer::default_file = (char *)0x0;
        }
        bVar6 = false;
        __filename = (char *)0x0;
        if ((pcVar4 != (char *)0x0) && (bVar6 = true, __filename = pcVar4, *pcVar4 != '\0')) {
          ActionPasteBuffer::default_file = (char *)__strdup(pcVar4);
        }
      }
      else {
        pcVar4 = argv[1];
        bVar6 = false;
        __filename = pcVar4;
      }
      __stream = fopen(__filename,"r");
      if (__stream == (FILE *)0x0) {
LAB_08064b48:
        SaveBufferElements(pcVar4);
      }
      else {
        fclose(__stream);
        iVar5 = (*gui->confirm_dialog)("File exists!  Ok to overwrite?",0);
        if (iVar5 != 0) goto LAB_08064b48;
      }
      if (bVar6) {
        free(pcVar4);
      }
      goto LAB_08064900;
    }
    if (iVar2 == 0x56) {
      if (argc == 1) {
        ActionPasteBuffer::lexical_block_0::oldy = 0;
        iVar5 = 0;
      }
      else {
        if (1 < argc - 3U) {
          RestoreCrosshair('\x01');
          Message("Syntax error.  Usage:\n%s\n",
                  "PasteBuffer(AddSelected|Clear|1..MAX_BUFFER)\nPasteBuffer(Rotate, 1..3)\nPasteBuffer(Convert|Save|Restore|Mirror)\nPasteBuffer(ToLayout, X, Y, units)"
                 );
          return 1;
        }
        pcVar4 = (char *)0x0;
        if (argc == 4) {
          pcVar4 = argv[3];
        }
        fVar7 = GetValue(argv[1],pcVar4,local_1d);
        iVar5 = (int)ROUND(fVar7);
        if (local_1d[0] == '\0') {
          iVar5 = ActionPasteBuffer::lexical_block_0::oldx + (int)ROUND(fVar7);
        }
        pcVar4 = (char *)0x0;
        if (argc == 4) {
          pcVar4 = argv[3];
        }
        fVar7 = GetValue(argv[2],pcVar4,local_1d);
        iVar2 = ActionPasteBuffer::lexical_block_0::oldy + (int)ROUND(fVar7);
        ActionPasteBuffer::lexical_block_0::oldy = (int)ROUND(fVar7);
        if (local_1d[0] == '\0') {
          ActionPasteBuffer::lexical_block_0::oldy = iVar2;
        }
      }
      ActionPasteBuffer::lexical_block_0::oldx = iVar5;
      BVar1 = CopyPastebufferToLayout(iVar5,ActionPasteBuffer::lexical_block_0::oldy);
      if (BVar1 != '\0') {
        SetChangedFlag('\x01');
      }
      goto LAB_08064900;
    }
  }
LAB_080649b1:
  lVar3 = strtol(Ident,(char **)0x0,10);
  if (lVar3 != 0) {
    SetBufferNumber(lVar3 + -1);
  }
LAB_08064900:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionMorphPolygon(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  int type;
  PolygonTypePtr polygon;
  PolygonTypePtr poly;
  PCBTypePtr pPVar2;
  char *function;
  Cardinal n;
  int iVar3;
  LayerTypePtr layer;
  LayerTypePtr layer_00;
  uint local_30;
  PolygonTypePtr local_28;
  void *ptr2;
  LayerTypePtr local_20 [4];
  
  if ((0 < argc) && (Ident = *argv, Ident != (String)0x0)) {
    HideCrosshair('\x01');
    iVar1 = GetFunctionID(Ident);
    if ((iVar1 == 0x46) || (iVar1 == 0x4b)) {
      layer_00 = PCB->Data->Layer;
      if (PCB->Data->LayerN == -2) {
LAB_08064d5c:
        Draw();
        IncrementUndoSerialNumber();
        return 0;
      }
      local_30 = 0;
      pPVar2 = PCB;
      do {
        iVar1 = layer_00->PolygonN - 1;
        if (iVar1 != -1) {
          iVar3 = layer_00->PolygonN * 0x3c + -0x3c;
          do {
            while (poly = (PolygonTypePtr)((layer_00->Polygon->Flags).t + iVar3 + -0x18),
                  (*(byte *)&(poly->Flags).f & 0x40) == 0) {
              iVar1 = iVar1 + -1;
              iVar3 = iVar3 + -0x3c;
              pPVar2 = PCB;
              if (iVar1 == -1) goto LAB_08064cca;
            }
            iVar1 = iVar1 + -1;
            iVar3 = iVar3 + -0x3c;
            MorphPolygon(layer_00,poly);
            pPVar2 = PCB;
          } while (iVar1 != -1);
        }
LAB_08064cca:
        local_30 = local_30 + 1;
        if (pPVar2->Data->LayerN + 2U <= local_30) goto LAB_08064d5c;
        layer_00 = layer_00 + 1;
      } while( true );
    }
    if (iVar1 == 0x2e) {
      (*gui->get_coords)("Select an Object",&x,&y);
      iVar1 = SearchScreen(x,y,8,local_20,&ptr2,&local_28);
      if (iVar1 != 0) {
        MorphPolygon(local_20[0],local_28);
        Draw();
        IncrementUndoSerialNumber();
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void click_cb(hidval hv)

{
  Boolean BVar1;
  int iVar2;
  BoxType box;
  
  if (Note.Click != '\0') {
    Note.Click = '\0';
    if (Note.Moving != '\0') {
      iVar2 = (*gui->shift_is_pressed)();
      if (iVar2 == 0) {
        HideCrosshair('\x01');
        Note.Buffer = Settings.BufferNumber;
        SetBufferNumber(4);
        ClearBuffer(Buffers + Settings.BufferNumber);
        AddSelectedToBuffer(Buffers + Settings.BufferNumber,Note.X,Note.Y,'\x01');
        SaveUndoSerialNumber();
        RemoveSelected();
        SaveMode();
        saved_mode = '\x01';
        SetMode(5);
        RestoreCrosshair('\x01');
        return;
      }
    }
    if (Note.Hit != 0) {
      iVar2 = (*gui->shift_is_pressed)();
      if (iVar2 == 0) {
        HideCrosshair('\x01');
        SaveMode();
        saved_mode = '\x01';
        iVar2 = (*gui->control_is_pressed)();
        SetMode(0x69 - (uint)(iVar2 == 0));
        Crosshair.AttachedObject.Ptr1 = Note.ptr1;
        Crosshair.AttachedObject.Ptr2 = Note.ptr2;
        Crosshair.AttachedObject.Ptr3 = Note.ptr3;
        Crosshair.AttachedObject.Type = Note.Hit;
        AttachForCopy(Note.X,Note.Y);
        RestoreCrosshair('\x01');
        return;
      }
    }
    Note.Hit = 0;
    Note.Moving = '\0';
    HideCrosshair('\x01');
    SaveUndoSerialNumber();
    box.X1 = -10000000;
    box.Y1 = -10000000;
    box.X2 = 10000000;
    box.Y2 = 10000000;
    iVar2 = (*gui->shift_is_pressed)();
    if (iVar2 == 0) {
      BVar1 = SelectBlock(&box,'\0');
      if (BVar1 != '\0') {
        SetChangedFlag('\x01');
      }
    }
    NotifyBlock();
    Crosshair.AttachedBox.Point1.X = Note.X;
    Crosshair.AttachedBox.Point1.Y = Note.Y;
    RestoreCrosshair('\x01');
  }
  return;
}



// WARNING: Unknown calling convention

void ClearWarnings(void)

{
  ElementTypePtr paVar1;
  uint uVar2;
  int iVar3;
  PinTypePtr pin;
  PinTypePtr Pin;
  Cardinal sn_1;
  DataTypePtr paVar4;
  PCBTypePtr pPVar5;
  uint uVar6;
  PadTypePtr pad;
  PadTypePtr Pad;
  Cardinal n;
  uint uVar7;
  ElementTypePtr element_1;
  Cardinal sn;
  Cardinal n_1;
  uint uVar8;
  ElementTypePtr element;
  int iVar9;
  int local_28;
  int local_24;
  int local_20;
  
  Settings.RatWarn = '\0';
  paVar4 = PCB->Data;
  local_20 = paVar4->ElementN - 1;
  if (local_20 != -1) {
    pPVar5 = PCB;
    iVar3 = paVar4->ElementN * 300;
    while( true ) {
      local_24 = iVar3 + -300;
      paVar1 = paVar4->Element;
      uVar6 = *(uint *)((int)&paVar1[-1].PinN + iVar3);
      if (uVar6 != 0) {
        uVar7 = 0;
        do {
          Pin = (PinTypePtr)(uVar7 * 0x4c + *(int *)((int)&paVar1[-1].Pin + iVar3));
          uVar8 = (Pin->Flags).f;
          uVar2 = uVar6;
          pPVar5 = PCB;
          if ((uVar8 & 0x200) != 0) {
            (Pin->Flags).f = uVar8 & 0xfffffdff;
            DrawPin(Pin,0);
            uVar2 = *(uint *)((int)&paVar1[-1].PinN + iVar3);
            pPVar5 = PCB;
          }
          PCB = pPVar5;
        } while ((uVar2 != 0) && (uVar7 = (uVar7 + 1 + uVar2) - uVar6, uVar6 = uVar2, uVar7 < uVar2)
                );
        paVar4 = pPVar5->Data;
      }
      local_20 = local_20 + -1;
      if (local_20 == -1) break;
      paVar4 = pPVar5->Data;
      iVar3 = local_24;
    }
    local_24 = paVar4->ElementN - 1;
    if (local_24 != -1) {
      iVar3 = paVar4->ElementN * 300;
      while( true ) {
        local_28 = iVar3 + -300;
        iVar9 = 0;
        uVar8 = 0;
        paVar1 = paVar4->Element;
        uVar6 = *(uint *)((int)&paVar1[-1].PadN + iVar3);
        uVar7 = uVar6;
        while ((uVar7 != 0 && (uVar8 < uVar7))) {
          Pad = (PadTypePtr)(*(int *)((int)&paVar1[-1].Pad + iVar3) + iVar9);
          uVar2 = (Pad->Flags).f;
          if ((uVar2 & 0x200) != 0) {
            (Pad->Flags).f = uVar2 & 0xfffffdff;
            DrawPad(Pad,0);
            uVar7 = *(uint *)((int)&paVar1[-1].PadN + iVar3);
          }
          if (uVar6 == uVar7) {
            uVar8 = uVar8 + 1;
            iVar9 = iVar9 + 0x68;
            uVar7 = uVar6;
          }
        }
        local_24 = local_24 + -1;
        if (local_24 == -1) break;
        paVar4 = PCB->Data;
        iVar3 = local_28;
      }
    }
  }
  Draw();
  return;
}



// WARNING: Unknown calling convention

void NotifyLine(void)

{
  int iVar1;
  PadTypePtr pad;
  int type;
  longdouble lVar2;
  longdouble lVar3;
  longdouble lVar4;
  longdouble lVar5;
  void *ptr3;
  void *local_14;
  void *ptr1;
  
  if ((Marked.status == '\0') || ((*(byte *)&(PCB->Flags).f & 2) != 0)) {
    SetLocalRef(Crosshair.X,Crosshair.Y,'\x01');
    if (Crosshair.AttachedLine.State != 0) goto LAB_080651bf;
  }
  else if (Crosshair.AttachedLine.State != 0) {
LAB_080651bf:
    if (Crosshair.AttachedLine.State == 1) {
      if (PCB->SilkActive == '\0') {
        lastLayer = PCB->Data->Layer + LayerStack[0];
      }
      else {
        lastLayer = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
    }
    Crosshair.AttachedLine.State = 2;
    return;
  }
  if (PCB->RatDraw != '\0') {
    iVar1 = SearchScreen(Crosshair.X,Crosshair.Y,0x300,&ptr1,&ptr1,&ptr1);
    if (iVar1 == 0) {
      (*gui->beep)();
      return;
    }
  }
  if ((*(char *)&(PCB->Flags).f < '\0') && (Settings.Mode == 2)) {
    iVar1 = SearchScreen(Crosshair.X,Crosshair.Y,0x301,&ptr1,&local_14,&ptr3);
    LookupConnection(Crosshair.X,Crosshair.Y,'\x01',(int)ROUND(1.0 / Zoom_Multiplier),4);
    if ((iVar1 == 1) || (iVar1 == 0x100)) {
      Crosshair.AttachedLine.Point1.X = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point1.Y = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.State = 1;
      return;
    }
    if (iVar1 == 0x200) {
      lVar2 = (longdouble)(Crosshair.X - *(int *)((int)local_14 + 0x2c));
      lVar3 = (longdouble)(Crosshair.Y - *(int *)((int)local_14 + 0x30));
      lVar4 = (longdouble)(Crosshair.X - *(int *)((int)local_14 + 0x40));
      lVar5 = (longdouble)(Crosshair.Y - *(int *)((int)local_14 + 0x44));
      if (lVar5 * lVar5 + lVar4 * lVar4 < lVar3 * lVar3 + lVar2 * lVar2) {
        Crosshair.AttachedLine.Point1.X = *(LocationType *)((int)local_14 + 0x40);
        Crosshair.AttachedLine.Point1.Y = *(LocationType *)((int)local_14 + 0x44);
        Crosshair.AttachedLine.Point1.X2 = *(LocationType *)((int)local_14 + 0x48);
        Crosshair.AttachedLine.Point1.Y2 = *(LocationType *)((int)local_14 + 0x4c);
        Crosshair.AttachedLine.Point1.ID = *(long *)((int)local_14 + 0x50);
        Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)local_14 + 0x40);
        Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)local_14 + 0x44);
        Crosshair.AttachedLine.Point2.X2 = *(LocationType *)((int)local_14 + 0x48);
        Crosshair.AttachedLine.Point2.Y2 = *(LocationType *)((int)local_14 + 0x4c);
        Crosshair.AttachedLine.Point2.ID = *(long *)((int)local_14 + 0x50);
        Crosshair.AttachedLine.State = 1;
        return;
      }
      Crosshair.AttachedLine.Point1.X = *(LocationType *)((int)local_14 + 0x2c);
      Crosshair.AttachedLine.Point1.Y = *(LocationType *)((int)local_14 + 0x30);
      Crosshair.AttachedLine.Point1.X2 = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point1.Y2 = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.Point1.ID = *(long *)((int)local_14 + 0x3c);
      Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)local_14 + 0x2c);
      Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)local_14 + 0x30);
      Crosshair.AttachedLine.Point2.X2 = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point2.Y2 = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.Point2.ID = *(long *)((int)local_14 + 0x3c);
      Crosshair.AttachedLine.State = 1;
      return;
    }
  }
  Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
  Crosshair.AttachedLine.Point2.X = Crosshair.X;
  Crosshair.AttachedLine.State = 1;
  Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
  Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
  return;
}



// WARNING: Unknown calling convention

int ActionMinClearGap(int argc,char **argv,int x,int y)

{
  uint uVar1;
  int iVar2;
  PinTypePtr pin;
  void *pvVar3;
  Cardinal sn;
  LineTypePtr line;
  ArcTypePtr arc;
  PCBTypePtr pPVar4;
  LayerTypePtr layer;
  PinTypePtr via;
  PinTypePtr Ptr1;
  LayerType *pLVar5;
  char *delta;
  char *val;
  Cardinal sn_1;
  uint uVar6;
  PadTypePtr pad;
  LayerTypePtr layer_1;
  DataTypePtr paVar7;
  char *pcVar8;
  uint uVar9;
  int flags;
  char *function;
  uint uVar10;
  Cardinal n;
  int iVar11;
  Cardinal n_1;
  Cardinal n_2;
  char *__s1;
  char *units_00;
  char *units;
  ElementTypePtr element;
  uchar *puVar12;
  Cardinal sn_2;
  int iVar13;
  float fVar14;
  int local_48;
  int local_44;
  uint local_38;
  Boolean r;
  
  if (argc < 1) {
    __s1 = (char *)0x0;
LAB_0806580b:
    pcVar8 = (char *)0x0;
    units_00 = (char *)0x0;
  }
  else {
    __s1 = *argv;
    if (argc == 1) goto LAB_0806580b;
    units_00 = (char *)0x0;
    pcVar8 = argv[1];
    if (argc != 2) {
      units_00 = argv[2];
    }
  }
  if (__s1 == (char *)0x0) {
    return 1;
  }
  uVar9 = 0x40;
  iVar2 = strcasecmp(__s1,"Selected");
  val = pcVar8;
  if (iVar2 != 0) {
    uVar9 = 0;
    val = __s1;
    units_00 = pcVar8;
  }
  fVar14 = GetValue(val,units_00,&r);
  iVar2 = (int)ROUND(fVar14 + fVar14);
  HideCrosshair('\x01');
  SaveUndoSerialNumber();
  paVar7 = PCB->Data;
  local_44 = paVar7->ElementN - 1;
  if (local_44 != -1) {
    iVar11 = paVar7->ElementN * 300;
    while( true ) {
      local_48 = iVar11 + -300;
      puVar12 = paVar7->Element[-1].Flags.t + iVar11 + -0x18;
      if (*(uint *)(puVar12 + 0xe0) != 0) {
        uVar10 = 0;
        uVar6 = *(uint *)(puVar12 + 0xe0);
        do {
          pvVar3 = (void *)(uVar10 * 0x4c + *(int *)(puVar12 + 0x100));
          uVar1 = uVar6;
          if (((*(uint *)((int)pvVar3 + 0x14) & uVar9) == uVar9) &&
             (*(int *)((int)pvVar3 + 0x28) < iVar2)) {
            ChangeObjectClearSize(0x100,puVar12,pvVar3,(void *)0x0,iVar2,'\x01');
            RestoreUndoSerialNumber();
            uVar1 = *(uint *)(puVar12 + 0xe0);
          }
        } while ((uVar1 != 0) &&
                (uVar10 = (uVar10 + 1 + uVar1) - uVar6, uVar6 = uVar1, uVar10 < uVar1));
      }
      uVar6 = *(uint *)(puVar12 + 0xe8);
      local_38 = 0;
      iVar11 = 0;
      uVar10 = uVar6;
      while ((uVar10 != 0 && (local_38 < uVar10))) {
        pvVar3 = (void *)(*(int *)(puVar12 + 0x104) + iVar11);
        if ((uVar9 == (*(uint *)((int)pvVar3 + 0x14) & uVar9)) &&
           (*(int *)((int)pvVar3 + 0x28) < iVar2)) {
          ChangeObjectClearSize(0x200,puVar12,pvVar3,(void *)0x0,iVar2,'\x01');
          RestoreUndoSerialNumber();
          uVar10 = *(uint *)(puVar12 + 0xe8);
        }
        if (uVar6 == uVar10) {
          local_38 = local_38 + 1;
          iVar11 = iVar11 + 0x68;
          uVar10 = uVar6;
        }
      }
      local_44 = local_44 + -1;
      if (local_44 == -1) break;
      paVar7 = PCB->Data;
      iVar11 = local_48;
    }
    paVar7 = PCB->Data;
  }
  pPVar4 = PCB;
  if (paVar7->ViaN != 0) {
    uVar10 = 0;
    uVar6 = paVar7->ViaN;
    do {
      Ptr1 = paVar7->Via + uVar10;
      if ((((Ptr1->Flags).f & uVar9) == uVar9) && (Ptr1->Clearance < iVar2)) {
        ChangeObjectClearSize(1,Ptr1,(void *)0x0,(void *)0x0,iVar2,'\x01');
        RestoreUndoSerialNumber();
        paVar7 = PCB->Data;
        uVar1 = paVar7->ViaN;
        pPVar4 = PCB;
      }
      else {
        paVar7 = pPVar4->Data;
        uVar1 = paVar7->ViaN;
      }
    } while ((uVar1 != 0) && (uVar10 = (uVar1 + 1 + uVar10) - uVar6, uVar6 = uVar1, uVar10 < uVar1))
    ;
  }
  pLVar5 = paVar7->Layer;
  if (paVar7->LayerN != -2) {
    local_38 = 0;
    do {
      iVar11 = pLVar5->LineN - 1;
      if (iVar11 != -1) {
        iVar13 = pLVar5->LineN * 0x58 + -0x58;
        do {
          while ((puVar12 = (pLVar5->Line->Flags).t + iVar13 + -0x18,
                 (*(uint *)(puVar12 + 0x14) & uVar9) == uVar9 && (*(int *)(puVar12 + 0x28) < iVar2))
                ) {
            iVar11 = iVar11 + -1;
            iVar13 = iVar13 + -0x58;
            ChangeObjectClearSize(4,pLVar5,puVar12,(void *)0x0,iVar2,'\x01');
            RestoreUndoSerialNumber();
            pPVar4 = PCB;
            if (iVar11 == -1) goto LAB_0806572d;
          }
          iVar11 = iVar11 + -1;
          iVar13 = iVar13 + -0x58;
          pPVar4 = PCB;
        } while (iVar11 != -1);
      }
LAB_0806572d:
      local_38 = local_38 + 1;
      iVar11 = pPVar4->Data->LayerN;
      if (iVar11 + 2U <= local_38) goto LAB_0806574a;
      pLVar5 = pLVar5 + 1;
    } while( true );
  }
LAB_080655f9:
  RestoreUndoSerialNumber();
  IncrementUndoSerialNumber();
  return 0;
LAB_0806574a:
  pLVar5 = pPVar4->Data->Layer;
  if (iVar11 != -2) {
    local_38 = 0;
    do {
      iVar11 = pLVar5->ArcN - 1;
      if (iVar11 != -1) {
        iVar13 = pLVar5->ArcN * 0x44 + -0x44;
        do {
          while ((puVar12 = (pLVar5->Arc->Flags).t + iVar13 + -0x18,
                 (*(uint *)(puVar12 + 0x14) & uVar9) == uVar9 && (*(int *)(puVar12 + 0x28) < iVar2))
                ) {
            iVar11 = iVar11 + -1;
            iVar13 = iVar13 + -0x44;
            ChangeObjectClearSize(0x4000,pLVar5,puVar12,(void *)0x0,iVar2,'\x01');
            RestoreUndoSerialNumber();
            pPVar4 = PCB;
            if (iVar11 == -1) goto LAB_080657dd;
          }
          iVar11 = iVar11 + -1;
          iVar13 = iVar13 + -0x44;
          pPVar4 = PCB;
        } while (iVar11 != -1);
      }
LAB_080657dd:
      local_38 = local_38 + 1;
      if (pPVar4->Data->LayerN + 2U <= local_38) break;
      pLVar5 = pLVar5 + 1;
    } while( true );
  }
  goto LAB_080655f9;
}



// WARNING: Unknown calling convention

int ActionMinMaskGap(int argc,char **argv,int x,int y)

{
  uint uVar1;
  int iVar2;
  PinTypePtr pin;
  void *pvVar3;
  Cardinal sn;
  DataTypePtr paVar4;
  int iVar5;
  int Difference;
  PCBTypePtr pPVar6;
  char *delta;
  char *val;
  PadTypePtr pad;
  uint uVar7;
  PinTypePtr via;
  PinTypePtr Ptr1;
  char *pcVar8;
  char *function;
  uint uVar9;
  Cardinal n;
  Cardinal n_1;
  char *__s1;
  uint uVar10;
  int flags;
  char *units_00;
  char *units;
  ElementTypePtr element;
  uchar *Ptr1_00;
  Cardinal sn_2;
  float fVar11;
  int local_48;
  int local_44;
  uint local_38;
  Boolean r;
  
  if (argc < 1) {
    __s1 = (char *)0x0;
  }
  else {
    __s1 = *argv;
    if (argc != 1) {
      units_00 = (char *)0x0;
      pcVar8 = argv[1];
      if (argc != 2) {
        units_00 = argv[2];
      }
      goto LAB_0806584f;
    }
  }
  pcVar8 = (char *)0x0;
  units_00 = (char *)0x0;
LAB_0806584f:
  iVar2 = 1;
  if (__s1 != (char *)0x0) {
    uVar10 = 0x40;
    iVar2 = strcasecmp(__s1,"Selected");
    val = pcVar8;
    if (iVar2 != 0) {
      uVar10 = 0;
      val = __s1;
      units_00 = pcVar8;
    }
    fVar11 = GetValue(val,units_00,&r);
    iVar2 = (int)ROUND(fVar11 + fVar11);
    HideCrosshair('\x01');
    SaveUndoSerialNumber();
    paVar4 = PCB->Data;
    local_44 = paVar4->ElementN - 1;
    if (local_44 != -1) {
      iVar5 = paVar4->ElementN * 300;
      while( true ) {
        local_48 = iVar5 + -300;
        Ptr1_00 = paVar4->Element[-1].Flags.t + iVar5 + -0x18;
        if (*(uint *)(Ptr1_00 + 0xe0) != 0) {
          uVar9 = 0;
          uVar7 = *(uint *)(Ptr1_00 + 0xe0);
          do {
            pvVar3 = (void *)(uVar9 * 0x4c + *(int *)(Ptr1_00 + 0x100));
            uVar1 = uVar7;
            if (((*(uint *)((int)pvVar3 + 0x14) & uVar10) == uVar10) &&
               (iVar5 = iVar2 + *(int *)((int)pvVar3 + 0x24), *(int *)((int)pvVar3 + 0x2c) < iVar5))
            {
              ChangeObjectMaskSize(0x100,Ptr1_00,pvVar3,(void *)0x0,iVar5,'\x01');
              RestoreUndoSerialNumber();
              uVar1 = *(uint *)(Ptr1_00 + 0xe0);
            }
          } while ((uVar1 != 0) &&
                  (uVar9 = (uVar9 + 1 + uVar1) - uVar7, uVar7 = uVar1, uVar9 < uVar1));
        }
        uVar7 = *(uint *)(Ptr1_00 + 0xe8);
        iVar5 = 0;
        local_38 = 0;
        uVar9 = uVar7;
        while ((uVar9 != 0 && (local_38 < uVar9))) {
          pvVar3 = (void *)(*(int *)(Ptr1_00 + 0x104) + iVar5);
          if ((uVar10 == (*(uint *)((int)pvVar3 + 0x14) & uVar10)) &&
             (Difference = iVar2 + *(int *)((int)pvVar3 + 0x24),
             *(int *)((int)pvVar3 + 0x54) < Difference)) {
            ChangeObjectMaskSize(0x200,Ptr1_00,pvVar3,(void *)0x0,Difference,'\x01');
            RestoreUndoSerialNumber();
            uVar9 = *(uint *)(Ptr1_00 + 0xe8);
          }
          if (uVar7 == uVar9) {
            local_38 = local_38 + 1;
            iVar5 = iVar5 + 0x68;
            uVar9 = uVar7;
          }
        }
        local_44 = local_44 + -1;
        if (local_44 == -1) break;
        paVar4 = PCB->Data;
        iVar5 = local_48;
      }
      paVar4 = PCB->Data;
    }
    if (paVar4->ViaN != 0) {
      uVar9 = 0;
      pPVar6 = PCB;
      uVar7 = paVar4->ViaN;
      do {
        Ptr1 = paVar4->Via + uVar9;
        if (((((Ptr1->Flags).f & uVar10) == uVar10) && (Ptr1->Mask != 0)) &&
           (iVar5 = iVar2 + Ptr1->Thickness, Ptr1->Mask < iVar5)) {
          ChangeObjectMaskSize(1,Ptr1,(void *)0x0,(void *)0x0,iVar5,'\x01');
          RestoreUndoSerialNumber();
          pPVar6 = PCB;
        }
        paVar4 = pPVar6->Data;
        uVar1 = paVar4->ViaN;
      } while ((uVar1 != 0) && (uVar9 = (uVar1 + 1 + uVar9) - uVar7, uVar7 = uVar1, uVar9 < uVar1));
    }
    RestoreUndoSerialNumber();
    IncrementUndoSerialNumber();
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int ActionMarkCrosshair(int argc,char **argv,int x,int y)

{
  String Ident;
  char *function;
  int iVar1;
  
  if (((argc < 1) || (Ident = *argv, Ident == (String)0x0)) || (*Ident == '\0')) {
    if (Marked.status != '\0') {
      DrawMark('\x01');
      Marked.status = '\0';
      return 0;
    }
  }
  else {
    iVar1 = GetFunctionID(Ident);
    if (iVar1 != 10) {
      return 0;
    }
    DrawMark('\x01');
  }
  Marked.status = '\x01';
  Marked.X = Crosshair.X;
  Marked.Y = Crosshair.Y;
  DrawMark('\0');
  return 0;
}



// WARNING: Unknown calling convention

int ActionLoadFrom(int argc,char **argv,int x,int y)

{
  int iVar1;
  char *Name;
  PCBTypePtr pPVar2;
  char cVar3;
  int iVar4;
  char *pcVar5;
  char *function;
  char *name;
  int in_GS_OFFSET;
  char fname [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (argc < 2) {
    Message("Syntax error.  Usage:\n%s\n",
            "LoadFrom(Layout|LayoutToBuffer|ElementToBuffer|Netlist|Revert,filename)");
    iVar4 = 1;
    goto LAB_08065c0e;
  }
  pcVar5 = *argv;
  Name = argv[1];
  HideCrosshair('\x01');
  iVar4 = strcasecmp(pcVar5,"ElementToBuffer");
  if (iVar4 == 0) {
    cVar3 = LoadElementToBuffer(Buffers + Settings.BufferNumber,Name,'\x01');
joined_r0x08065c4a:
    if (cVar3 != '\0') {
      SetMode(5);
    }
  }
  else {
    iVar4 = strcasecmp(pcVar5,"LayoutToBuffer");
    if (iVar4 == 0) {
      cVar3 = LoadLayoutToBuffer(Buffers + Settings.BufferNumber,Name);
      goto joined_r0x08065c4a;
    }
    iVar4 = strcasecmp(pcVar5,"Layout");
    if (iVar4 == 0) {
      if ((PCB->Changed == '\0') ||
         (iVar4 = (*gui->confirm_dialog)("OK to override layout data?",0), iVar4 != 0)) {
        LoadPCB(Name);
      }
    }
    else {
      iVar4 = strcasecmp(pcVar5,"Netlist");
      if (iVar4 == 0) {
        if (PCB->Netlistname != (char *)0x0) {
          SaveFree(PCB->Netlistname);
        }
        pPVar2 = PCB;
        pcVar5 = StripWhiteSpaceAndDup(Name);
        pPVar2->Netlistname = pcVar5;
        FreeLibraryMemory(&PCB->NetlistLib);
        iVar4 = ImportNetlist(PCB->Netlistname);
        if (iVar4 == 0) {
          hid_action("NetlistChanged");
        }
      }
      else {
        iVar4 = strcasecmp(pcVar5,"Revert");
        if ((iVar4 == 0) && (pcVar5 = PCB->Filename, pcVar5 != (char *)0x0)) {
          if (PCB->Changed != '\0') {
            iVar4 = (*gui->confirm_dialog)("OK to override changes?",0);
            if (iVar4 == 0) goto LAB_08065c00;
            pcVar5 = PCB->Filename;
          }
          __strcpy_chk(fname,pcVar5,0x100);
          LoadPCB(fname);
        }
      }
    }
  }
LAB_08065c00:
  RestoreCrosshair('\x01');
  iVar4 = 0;
LAB_08065c0e:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int ActionFlip(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  char *function;
  ElementTypePtr local_10 [2];
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
LAB_08065e25:
    Message("Syntax error.  Usage:\n%s\n","Flip(Object|Selected|SelectedElements)");
    iVar1 = 1;
  }
  else {
    HideCrosshair('\x01');
    iVar1 = GetFunctionID(Ident);
    if ((iVar1 == 0x46) || (iVar1 == 0x48)) {
      ChangeSelectedElementSide();
    }
    else {
      if (iVar1 != 0x2e) {
        RestoreCrosshair('\x01');
        goto LAB_08065e25;
      }
      iVar1 = SearchScreen(x,y,2,local_10,local_10,local_10);
      if (iVar1 != 0) {
        ChangeElementSide(local_10[0],Crosshair.Y * 2 - PCB->MaxHeight);
        IncrementUndoSerialNumber();
        Draw();
      }
    }
    RestoreCrosshair('\x01');
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int ActionExecuteFile(int argc,char **argv,int x,int y)

{
  char *__filename;
  char cVar1;
  int iVar2;
  FILE *__stream;
  char *pcVar3;
  char *sp;
  int n;
  FILE *fp;
  int in_GS_OFFSET;
  char line [256];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (argc == 1) {
    __filename = *argv;
    __stream = fopen(__filename,"r");
    if (__stream == (FILE *)0x0) {
      __fprintf_chk(stderr,1,"Could not open actions file \"%s\".\n",__filename);
      iVar2 = 1;
    }
    else {
      iVar2 = 0;
LAB_08065f40:
      pcVar3 = fgets(line,0x100,__stream);
      if (pcVar3 != (char *)0x0) {
        iVar2 = iVar2 + 1;
        pcVar3 = line;
        if ((line[0] != '\r') && (cVar1 = line[0], line[0] != '\0')) {
          while (cVar1 != '\n') {
            pcVar3 = pcVar3 + 1;
            cVar1 = *pcVar3;
            if ((cVar1 == '\r') || (cVar1 == '\0')) break;
          }
        }
        *pcVar3 = '\0';
        if (line[0] != '\0') {
          pcVar3 = line;
          if ((line[0] == ' ') || (cVar1 = line[0], line[0] == '\t')) {
            do {
              pcVar3 = pcVar3 + 1;
              cVar1 = *pcVar3;
              if (cVar1 == '\0') goto LAB_08065f40;
            } while ((cVar1 == '\t') || (cVar1 == ' '));
          }
          if ((cVar1 != '#') && (cVar1 != '\0')) {
            Message("%s : line %-3d : \"%s\"\n",__filename,iVar2,pcVar3);
            hid_parse_actions(pcVar3,(_func_int_char_ptr_int_char_ptr_ptr *)0x0);
          }
        }
        goto LAB_08065f40;
      }
      fclose(__stream);
      iVar2 = 0;
    }
  }
  else {
    Message("Syntax error.  Usage:\n%s\n","ExecuteFile(filename)");
    iVar2 = 1;
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int ActionDumpLibrary(int argc,char **argv,int x,int y)

{
  char *pcVar1;
  char *pcVar2;
  LibraryEntryTypePtr paVar3;
  char *pcVar4;
  int j;
  uint uVar5;
  char *pcVar6;
  char *pcVar7;
  uint local_24;
  
  __printf_chk(1,"**** Do not count on this format.  It will change ****\n\n");
  __printf_chk(1,"MenuN   = %d\n",Library.MenuN);
  __printf_chk(1,"MenuMax = %d\n",Library.MenuMax);
  if (Library.MenuN != 0) {
    local_24 = 0;
    do {
      __printf_chk(1,"Library #%d:\n",local_24);
      __printf_chk(1,"    EntryN    = %d\n",Library.Menu[local_24].EntryN);
      __printf_chk(1,"    EntryMax  = %d\n",Library.Menu[local_24].EntryMax);
      pcVar1 = Library.Menu[local_24].Name;
      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
        pcVar1 = "(unknown)";
      }
      __printf_chk(1,"    Name      = \"%s\"\n",pcVar1);
      pcVar1 = Library.Menu[local_24].directory;
      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
        pcVar1 = "(unknown)";
      }
      __printf_chk(1,"    directory = \"%s\"\n",pcVar1);
      pcVar1 = Library.Menu[local_24].Style;
      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
        pcVar1 = "(unknown)";
      }
      __printf_chk(1,"    Style     = \"%s\"\n",pcVar1);
      __printf_chk(1,"    flag      = %d\n",(int)Library.Menu[local_24].flag);
      if (Library.Menu[local_24].EntryN != 0) {
        uVar5 = 0;
        do {
          __printf_chk(1,"    #%4d: ",uVar5);
          paVar3 = Library.Menu[local_24].Entry + uVar5;
          pcVar1 = paVar3->Template;
          if (pcVar1 == (char *)0xffffffff) {
            pcVar1 = paVar3->ListEntry;
            if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
              pcVar1 = "(unknown)";
            }
            __printf_chk(1,"newlib: \"%s\"\n",pcVar1);
          }
          else {
            pcVar7 = paVar3->Description;
            if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\0')) {
              pcVar7 = "(unknown)";
            }
            pcVar6 = paVar3->Value;
            if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\0')) {
              pcVar6 = "(unknown)";
            }
            pcVar4 = paVar3->Package;
            if ((pcVar4 == (char *)0x0) || (*pcVar4 == '\0')) {
              pcVar4 = "(unknown)";
            }
            if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
              pcVar1 = "(unknown)";
            }
            pcVar2 = paVar3->ListEntry;
            if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
              pcVar2 = "(unknown)";
            }
            __printf_chk(1,"\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"\n",pcVar2,pcVar1,pcVar4,pcVar6,
                         pcVar7);
          }
          uVar5 = uVar5 + 1;
        } while (uVar5 <= Library.Menu[local_24].EntryN && Library.Menu[local_24].EntryN != uVar5);
      }
      local_24 = local_24 + 1;
    } while (local_24 < Library.MenuN);
  }
  return 0;
}



// WARNING: Unknown calling convention

int ActionDRCheck(int argc,char **argv,int x,int y)

{
  int iVar1;
  int count;
  
  if ((gui->drc_gui == (HID_DRC_GUI *)0x0) || (gui->drc_gui->log_drc_overview != 0)) {
    iVar1 = PCB->Bloat + 1;
    Message("Rules are minspace %d.%02d, minoverlap %d.%d minwidth %d.%02d, minsilk %d.%02d\nmin drill %d.%02d, min annular ring %d.%02d\n"
            ,iVar1 / 100,iVar1 % 100,PCB->Shrink / 100,PCB->Shrink % 100,PCB->minWid / 100,
            PCB->minWid % 100,PCB->minSlk / 100,PCB->minSlk % 100,PCB->minDrill / 100,
            PCB->minDrill % 100,PCB->minRing / 100,PCB->minRing % 100);
  }
  HideCrosshair('\x01');
  iVar1 = DRCAll();
  if ((gui->drc_gui == (HID_DRC_GUI *)0x0) || (gui->drc_gui->log_drc_overview != 0)) {
    if (iVar1 == 0) {
      Message("No DRC problems found.\n");
    }
    else if (iVar1 < 1) {
      Message("Aborted DRC after %d design rule errors.\n",-iVar1);
    }
    else {
      Message("Found %d design rule errors.\n",iVar1);
    }
  }
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionConnection(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  char *function;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    Message("Syntax error.  Usage:\n%s\n",
            "Connection(Find|ResetLinesAndPolygons|ResetPinsAndVias|Reset)");
    return 1;
  }
  HideCrosshair('\x01');
  iVar1 = GetFunctionID(Ident);
  if (iVar1 == 0x3f) {
    SaveUndoSerialNumber();
    ResetFoundPinsViasAndPads('\x01');
    RestoreUndoSerialNumber();
  }
  else {
    if (iVar1 < 0x40) {
      if (iVar1 == 0x1c) {
        (*gui->get_coords)("Click on a connection",&x,&y);
        LookupConnection(x,y,'\x01',1,4);
      }
      goto LAB_08066560;
    }
    if (iVar1 != 0x40) {
      if (iVar1 == 0x41) {
        ResetFoundPinsViasAndPads('\x01');
      }
      goto LAB_08066560;
    }
  }
  ResetFoundLinesAndPolygons('\x01');
LAB_08066560:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionDisperseElements(int argc,char **argv,int x,int y)

{
  String Ident;
  uint uVar1;
  bool bVar2;
  char *function;
  int iVar3;
  long maxy;
  long dx;
  long dy;
  int iVar4;
  int iVar5;
  int iVar6;
  ElementTypePtr element;
  ElementTypePtr Element;
  DataTypePtr Data;
  int local_4c;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_2c;
  
  if (((0 < argc) && (Ident = *argv, Ident != (String)0x0)) && (*Ident != '\0')) {
    iVar3 = GetFunctionID(Ident);
    if (iVar3 == 1) {
      bVar2 = true;
    }
    else {
      bVar2 = false;
      if (iVar3 != 0x46) goto LAB_080665fe;
    }
    Data = PCB->Data;
    local_2c = Data->ElementN - 1;
    if (local_2c != -1) {
      local_34 = 10000;
      local_4c = 10000;
      local_40 = 10000;
      iVar3 = Data->ElementN * 300;
      do {
        Element = (ElementTypePtr)(Data->Element[-1].Flags.t + iVar3 + -0x18);
        uVar1 = (Element->Flags).f;
        if (((uVar1 & 0x2000) == 0) && ((bVar2 || ((uVar1 & 0x40) != 0)))) {
          iVar5 = (Element->BoundingBox).X1;
          local_3c = local_40 - iVar5;
          local_38 = local_3c + Element->MarkX;
          iVar4 = (int)ROUND(PCB->Grid);
          if (PCB->MaxWidth <
              (iVar4 + 10000 + (Element->BoundingBox).X2 + local_3c) - local_38 % iVar4) {
            local_3c = 10000 - iVar5;
            local_40 = 10000;
            local_4c = local_34 + 10000;
            local_38 = local_3c + Element->MarkX;
          }
          iVar6 = local_4c - (Element->BoundingBox).Y1;
          iVar5 = (local_3c + iVar4) - local_38 % iVar4;
          dy = iVar6 + iVar4;
          iVar4 = dy - (iVar6 + Element->MarkY) % iVar4;
          MoveElementLowLevel(Data,Element,iVar5,iVar4);
          AddObjectToMoveUndoList(2,(void *)0x0,(void *)0x0,Element,iVar5,iVar4);
          local_40 = local_40 + (((Element->BoundingBox).X2 + 10000) - (Element->BoundingBox).X1);
          iVar4 = (Element->BoundingBox).Y2;
          if (iVar4 <= local_34) goto LAB_080667c8;
        }
        else {
LAB_080667c8:
          iVar4 = local_34;
        }
        local_2c = local_2c + -1;
        if (local_2c == -1) break;
        Data = PCB->Data;
        iVar3 = iVar3 + -300;
        local_34 = iVar4;
      } while( true );
    }
    IncrementUndoSerialNumber();
    ClearAndRedrawOutput();
    SetChangedFlag('\x01');
    return 0;
  }
LAB_080665fe:
  Message("Syntax error.  Usage:\n%s\n","DisperseElements(All|Selected)");
  return 1;
}



// WARNING: Unknown calling convention

int ActionDeleteRats(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int iVar2;
  char *function;
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  if (Settings.RatWarn != '\0') {
    ClearWarnings();
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  if ((iVar2 == 0x46) || (iVar2 == 0x50)) {
    cVar1 = DeleteRats('\x01');
  }
  else {
    if (iVar2 != 3) goto LAB_08066852;
    cVar1 = DeleteRats('\0');
  }
  if (cVar1 != '\0') {
    SetChangedFlag('\x01');
  }
LAB_08066852:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionChangeOctagon(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  char *function;
  int iVar3;
  int type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if ((0 < argc) && (*argv != (String)0x0)) {
    iVar3 = GetFunctionID(*argv);
    switch(iVar3) {
    case 0x2e:
    case 0x5f:
      (*gui->get_coords)("Select an Object",&x,&y);
      iVar3 = SearchScreen(x,y,0x103,local_10,&local_14,&local_18);
      if (iVar3 == 0) {
        type = 0;
        return type;
      }
      BVar2 = ChangeObjectOctagon(iVar3,local_10[0],local_14,local_18);
      if (BVar2 == '\0') {
        type = 0;
        return type;
      }
      goto LAB_08066922;
    default:
      goto switchD_080668d8_caseD_2f;
    case 0x46:
    case 0x4b:
      cVar1 = ChangeSelectedOctagon(0x101);
      break;
    case 0x48:
      cVar1 = ChangeSelectedOctagon(2);
      break;
    case 0x4d:
      cVar1 = ChangeSelectedOctagon(0x100);
      break;
    case 0x4f:
      cVar1 = ChangeSelectedOctagon(1);
    }
    if (cVar1 != '\0') {
LAB_08066922:
      SetChangedFlag('\x01');
      return 0;
    }
  }
switchD_080668d8_caseD_2f:
  type = 0;
  return type;
}



// WARNING: Unknown calling convention

int ActionChangeSquare(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  int iVar3;
  int type;
  char *function;
  void *local_18;
  void *local_14;
  void *local_10 [2];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar3 = GetFunctionID(Ident);
  switch(iVar3) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar3 = SearchScreen(x,y,0x302,local_10,&local_14,&local_18);
    if ((iVar3 == 0) ||
       (BVar2 = ChangeObjectSquare(iVar3,local_10[0],local_14,local_18), BVar2 == '\0'))
    goto switchD_08066a28_caseD_2f;
    goto LAB_08066a42;
  default:
    goto switchD_08066a28_caseD_2f;
  case 0x46:
  case 0x4b:
  case 0x4d:
    cVar1 = ChangeSelectedSquare(0x300);
    break;
  case 0x48:
    cVar1 = ChangeSelectedSquare(2);
  }
  if (cVar1 != '\0') {
LAB_08066a42:
    SetChangedFlag('\x01');
  }
switchD_08066a28_caseD_2f:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int ActionChangeSize(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int iVar2;
  int type;
  char *delta;
  char *units_00;
  char *units;
  char *function;
  float value;
  float fVar3;
  void *local_2c;
  void *local_28;
  void *local_24;
  Boolean local_1d [13];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    return 0;
  }
  units_00 = (char *)0x0;
  if (argc != 2) {
    units_00 = argv[2];
  }
  if (argv[1] == (char *)0x0) {
    return 0;
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  fVar3 = GetValue(argv[1],units_00,local_1d);
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  switch(iVar2) {
  case 0x2e:
    iVar2 = SearchScreen(Crosshair.X,Crosshair.Y,0x471f,&local_24,&local_28,&local_2c);
    if ((iVar2 != 0) && ((*(byte *)((int)local_28 + 0x15) & 0x20) != 0)) {
      Message("Sorry, the object is locked\n");
    }
    cVar1 = ChangeObjectSize(iVar2,local_24,local_28,local_2c,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x2f:
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
  case 0x34:
  case 0x35:
  case 0x36:
  case 0x37:
  case 0x38:
  case 0x39:
  case 0x3a:
  case 0x3b:
  case 0x3c:
  case 0x3d:
  case 0x3e:
  case 0x3f:
  case 0x40:
  case 0x41:
  case 0x42:
  case 0x43:
  case 0x44:
  case 0x45:
    goto switchD_08066b98_caseD_22;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelectedSize(0x471f,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x47:
    cVar1 = ChangeSelectedSize(0x4000,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x48:
    cVar1 = ChangeSelectedSize(2,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x49:
    cVar1 = ChangeSelectedSize(4,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4a:
    cVar1 = ChangeSelectedSize(0x400,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4c:
    cVar1 = ChangeSelectedSize(0x200,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4d:
    cVar1 = ChangeSelectedSize(0x100,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4e:
    cVar1 = ChangeSelectedSize(0x10,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4f:
    cVar1 = ChangeSelectedSize(1,(int)ROUND(fVar3),local_1d[0]);
    break;
  default:
    goto switchD_08066b98_caseD_22;
  }
  if (cVar1 == '\0') {
switchD_08066b98_caseD_22:
    RestoreCrosshair('\x01');
  }
  else {
    SetChangedFlag('\x01');
    RestoreCrosshair('\x01');
  }
  return 0;
}



// WARNING: Unknown calling convention

int ActionChangePaste(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  char *function;
  int iVar2;
  int type;
  PadTypePtr local_18;
  void *ptr2;
  void *ptr1;
  
  if (argc < 1) {
    return 0;
  }
  if (*argv == (String)0x0) {
    return 0;
  }
  iVar2 = GetFunctionID(*argv);
  if (iVar2 == 0x46) {
code_r0x08066f29:
    BVar1 = ChangeSelectedPaste();
    if (BVar1 != '\0') {
      SetChangedFlag('\x01');
      return 0;
    }
  }
  else {
    if (iVar2 < 0x47) {
      if (iVar2 != 0x2e) {
        return 0;
      }
    }
    else {
      if (iVar2 == 0x4c) goto code_r0x08066f29;
      if (iVar2 != 0x5f) {
        return 0;
      }
    }
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar2 = SearchScreen(x,y,0x200,&ptr1,&ptr2,&local_18);
    if ((iVar2 != 0) && (BVar1 = ChangePaste(local_18), BVar1 != '\0')) {
      IncrementUndoSerialNumber();
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int ActionChangeJoin(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int iVar2;
  int type;
  char *function;
  void *local_18;
  void *local_14;
  void *local_10 [2];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  switch(iVar2) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar2 = SearchScreen(x,y,0x4014,local_10,&local_14,&local_18);
    if (iVar2 == 0) goto switchD_08066f98_caseD_2f;
    cVar1 = ChangeObjectJoin(iVar2,local_10[0],local_14,local_18);
    break;
  default:
    goto switchD_08066f98_caseD_2f;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelectedJoin(0x4014);
    break;
  case 0x47:
    cVar1 = ChangeSelectedJoin(0x4000);
    goto joined_r0x08066fb0;
  case 0x49:
    cVar1 = ChangeSelectedJoin(4);
joined_r0x08066fb0:
    if (cVar1 == '\0') goto switchD_08066f98_caseD_2f;
    goto LAB_08066fb2;
  }
  if (cVar1 != '\0') {
LAB_08066fb2:
    SetChangedFlag('\x01');
  }
switchD_08066f98_caseD_2f:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionChangeHole(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  char *function;
  int iVar2;
  int type;
  PinTypePtr local_18;
  void *ptr2;
  void *ptr1;
  
  if (argc < 1) {
    return 0;
  }
  if (*argv == (String)0x0) {
    return 0;
  }
  iVar2 = GetFunctionID(*argv);
  if (iVar2 == 0x46) {
code_r0x08067149:
    BVar1 = ChangeSelectedHole();
    if (BVar1 != '\0') {
      SetChangedFlag('\x01');
      return 0;
    }
  }
  else {
    if (iVar2 < 0x47) {
      if (iVar2 != 0x2e) {
        return 0;
      }
    }
    else {
      if (iVar2 == 0x4f) goto code_r0x08067149;
      if (iVar2 != 0x5f) {
        return 0;
      }
    }
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar2 = SearchScreen(x,y,1,&ptr1,&ptr2,&local_18);
    if ((iVar2 != 0) && (BVar1 = ChangeHole(local_18), BVar1 != '\0')) {
      IncrementUndoSerialNumber();
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int ActionChange2ndSize(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int iVar2;
  int type;
  char *delta;
  char *units_00;
  char *units;
  char *function;
  float fVar3;
  void *local_2c;
  void *local_28;
  void *local_24;
  Boolean local_1d [13];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    return 0;
  }
  units_00 = (char *)0x0;
  if (argc != 2) {
    units_00 = argv[2];
  }
  if (argv[1] == (char *)0x0) {
    return 0;
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  fVar3 = GetValue(argv[1],units_00,local_1d);
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  switch(iVar2) {
  case 0x2e:
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar2 = SearchScreen(x,y,0x103,&local_24,&local_28,&local_2c);
    if (iVar2 == 0) goto switchD_080671f8_caseD_2f;
    cVar1 = ChangeObject2ndSize(iVar2,local_24,local_28,local_2c,(int)ROUND(fVar3),local_1d[0],
                                '\x01');
    break;
  default:
    goto switchD_080671f8_caseD_2f;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelected2ndSize(0x101,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4d:
    cVar1 = ChangeSelected2ndSize(0x100,(int)ROUND(fVar3),local_1d[0]);
    goto joined_r0x08067230;
  case 0x4f:
    cVar1 = ChangeSelected2ndSize(1,(int)ROUND(fVar3),local_1d[0]);
joined_r0x08067230:
    if (cVar1 == '\0') goto switchD_080671f8_caseD_2f;
    goto LAB_08067232;
  }
  if (cVar1 != '\0') {
LAB_08067232:
    SetChangedFlag('\x01');
  }
switchD_080671f8_caseD_2f:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionChangeClearSize(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  int iVar3;
  int type;
  char *delta;
  char *units_00;
  char *units;
  char *function;
  float value;
  float fVar4;
  void *local_2c;
  void *local_28;
  void *local_24;
  Boolean local_1d [13];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    return 0;
  }
  units_00 = (char *)0x0;
  if (argc != 2) {
    units_00 = argv[2];
  }
  if (argv[1] == (char *)0x0) {
    return 0;
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  fVar4 = GetValue(argv[1],units_00,local_1d);
  fVar4 = fVar4 + fVar4;
  HideCrosshair('\x01');
  iVar3 = GetFunctionID(Ident);
  switch(iVar3) {
  case 0x2e:
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar3 = SearchScreen(x,y,0x4305,&local_24,&local_28,&local_2c);
    if ((iVar3 == 0) ||
       (BVar2 = ChangeObjectClearSize
                          (iVar3,local_24,local_28,local_2c,(int)ROUND(fVar4),local_1d[0]),
       BVar2 == '\0')) goto switchD_08067410_caseD_22;
    goto LAB_08067448;
  case 0x2f:
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
  case 0x34:
  case 0x35:
  case 0x36:
  case 0x37:
  case 0x38:
  case 0x39:
  case 0x3a:
  case 0x3b:
  case 0x3c:
  case 0x3d:
  case 0x3e:
  case 0x3f:
  case 0x40:
  case 0x41:
  case 0x42:
  case 0x43:
  case 0x44:
  case 0x45:
  case 0x48:
  case 0x4a:
  case 0x4e:
    goto switchD_08067410_caseD_22;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelectedClearSize(0x4305,(int)ROUND(fVar4),local_1d[0]);
    break;
  case 0x47:
    cVar1 = ChangeSelectedClearSize(0x4000,(int)ROUND(fVar4),local_1d[0]);
    break;
  case 0x49:
    cVar1 = ChangeSelectedClearSize(4,(int)ROUND(fVar4),local_1d[0]);
    break;
  case 0x4c:
    cVar1 = ChangeSelectedClearSize(0x200,(int)ROUND(fVar4),local_1d[0]);
    break;
  case 0x4d:
    cVar1 = ChangeSelectedClearSize(0x100,(int)ROUND(fVar4),local_1d[0]);
    break;
  case 0x4f:
    cVar1 = ChangeSelectedClearSize(1,(int)ROUND(fVar4),local_1d[0]);
    break;
  default:
    goto switchD_08067410_caseD_22;
  }
  if (cVar1 != '\0') {
LAB_08067448:
    SetChangedFlag('\x01');
  }
switchD_08067410_caseD_22:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionAutoRoute(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int iVar2;
  char *function;
  
  if (argc < 1) {
    hid_action("Busy");
    return 0;
  }
  Ident = *argv;
  hid_action("Busy");
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  if ((iVar2 == 0x46) || (iVar2 == 0x50)) {
    cVar1 = AutoRoute('\x01');
  }
  else {
    if (iVar2 != 3) goto LAB_08067667;
    cVar1 = AutoRoute('\0');
  }
  if (cVar1 != '\0') {
    SetChangedFlag('\x01');
  }
LAB_08067667:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionAutoPlaceSelected(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  int iVar2;
  
  hid_action("Busy");
  iVar2 = (*gui->confirm_dialog)
                    ("Auto-placement can NOT be undone.\nDo you want to continue anyway?\n",0);
  if (iVar2 == 0) {
    return 0;
  }
  HideCrosshair('\x01');
  BVar1 = AutoPlaceSelected();
  if (BVar1 != '\0') {
    SetChangedFlag('\x01');
  }
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionAddRats(int argc,char **argv,int x,int y)

{
  String Ident;
  Cardinal CVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  char cVar5;
  int iVar6;
  RatTypePtr paVar7;
  Cardinal n;
  char *function;
  RatTypePtr shorty;
  RatTypePtr Line;
  float len;
  float small;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    return 0;
  }
  if (Settings.RatWarn != '\0') {
    ClearWarnings();
  }
  HideCrosshair('\x01');
  iVar6 = GetFunctionID(Ident);
  if (iVar6 == 0xe) {
    CVar1 = PCB->Data->RatN;
    iVar6 = CVar1 - 1;
    if (iVar6 != -1) {
      fVar2 = 1e+14;
      Line = (RatTypePtr)0x0;
      paVar7 = PCB->Data->Rat + (CVar1 - 1);
      do {
        if (((*(byte *)&(paVar7->Flags).f & 0x40) == 0) &&
           (fVar3 = (float)((paVar7->Point1).X - (paVar7->Point2).X),
           fVar4 = (float)((paVar7->Point1).Y - (paVar7->Point2).Y),
           fVar3 = fVar4 * fVar4 + fVar3 * fVar3, fVar3 < fVar2)) {
          Line = paVar7;
          fVar2 = fVar3;
        }
        iVar6 = iVar6 + -1;
        paVar7 = paVar7 + -1;
      } while (iVar6 != -1);
      if (Line != (RatTypePtr)0x0) {
        AddObjectToFlagUndoList(0x20,Line,Line,Line);
        (Line->Flags).f = (Line->Flags).f | 0x40;
        DrawRat(Line,0);
        Draw();
        CenterDisplay(((Line->Point1).X + (Line->Point2).X) / 2,
                      ((Line->Point1).Y + (Line->Point2).Y) / 2,'\0');
      }
    }
  }
  else {
    if (iVar6 < 0xf) {
      if (iVar6 != 3) goto LAB_080677f5;
      cVar5 = AddAllRats('\0',(_func_void_varargs *)0x0);
    }
    else {
      if ((iVar6 != 0x46) && (iVar6 != 0x50)) goto LAB_080677f5;
      cVar5 = AddAllRats('\x01',(_func_void_varargs *)0x0);
    }
    if (cVar5 != '\0') {
      SetChangedFlag('\x01');
      RestoreCrosshair('\x01');
      return 0;
    }
  }
LAB_080677f5:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

void register_action_action_list(void)

{
  hid_register_actions(action_action_list,0x3a);
  return;
}



// WARNING: Unknown calling convention

int ActionChangeName(int argc,char **argv,int x,int y)

{
  String Ident;
  LineTypePtr Ptr1;
  char cVar1;
  int iVar2;
  char *name;
  void *pvVar3;
  LayerType *pLVar4;
  char *pcVar5;
  LayerTypePtr Layer;
  char *function;
  int type;
  RubberbandTypePtr paVar6;
  int i;
  uint uVar7;
  void *local_18;
  void *local_14;
  void *local_10;
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  if (iVar2 == 0x22) {
    pcVar5 = PCB->Name;
    if (pcVar5 == (char *)0x0) {
      pcVar5 = "";
    }
    pcVar5 = (*gui->prompt_for)("Enter the layout name:",pcVar5);
    if (pcVar5 == (char *)0x0) goto LAB_08067996;
    cVar1 = ChangeLayoutName(pcVar5);
  }
  else {
    if (iVar2 == 0x2e) {
      (*gui->get_coords)("Select an Object",&x,&y);
      iVar2 = SearchScreen(x,y,0x717,&local_10,&local_14,&local_18);
      if (iVar2 != 0) {
        SaveUndoSerialNumber();
        pvVar3 = QueryInputAndChangeObjectName(iVar2,local_10,local_14,local_18);
        if ((pvVar3 != (void *)0x0) && (SetChangedFlag('\x01'), iVar2 == 2)) {
          RestoreUndoSerialNumber();
          Crosshair.AttachedObject.RubberbandN = 0;
          LookupRatLines(2,local_10,local_14,local_18);
          if (Crosshair.AttachedObject.RubberbandN != 0) {
            uVar7 = 0;
            paVar6 = Crosshair.AttachedObject.Rubberband;
            while( true ) {
              if (PCB->RatOn != '\0') {
                EraseRat((RatTypePtr)paVar6->Line);
              }
              Ptr1 = paVar6->Line;
              uVar7 = uVar7 + 1;
              MoveObjectToRemoveUndoList(0x20,Ptr1,Ptr1,Ptr1);
              if (Crosshair.AttachedObject.RubberbandN <= uVar7) break;
              paVar6 = paVar6 + 1;
            }
          }
          IncrementUndoSerialNumber();
          Draw();
        }
      }
      goto LAB_08067996;
    }
    if (iVar2 != 0x21) goto LAB_08067996;
    if (PCB->SilkActive == '\0') {
      pLVar4 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    pcVar5 = "";
    if (pLVar4->Name != (char *)0x0) {
      if (PCB->SilkActive == '\0') {
        pLVar4 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      pcVar5 = pLVar4->Name;
    }
    pcVar5 = (*gui->prompt_for)("Enter the layer name:",pcVar5);
    if (pcVar5 == (char *)0x0) goto LAB_08067996;
    if (PCB->SilkActive == '\0') {
      Layer = PCB->Data->Layer + LayerStack[0];
    }
    else {
      Layer = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = ChangeLayerName(Layer,pcVar5);
  }
  if (cVar1 != '\0') {
    SetChangedFlag('\x01');
  }
LAB_08067996:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

void AdjustAttachedObjects(void)

{
  PointTypePtr pnt;
  PointTypePtr pPVar1;
  int iVar2;
  
  if (Settings.Mode == 4) {
LAB_08067cd2:
    AdjustAttachedLine();
    return;
  }
  if (Settings.Mode < 5) {
    if (Settings.Mode == 2) {
      if ((PCB->RatDraw == '\0') && (PCB->Clipping != 0)) {
        AdjustTwoLine(PCB->Clipping + -1);
        return;
      }
      goto LAB_08067cd2;
    }
    if (2 < Settings.Mode) {
      if (Settings.Mode != 0x6d) {
        if (Crosshair.AttachedBox.State == 1) {
          Crosshair.AttachedBox.Point2.X = Crosshair.X;
          Crosshair.AttachedBox.Point2.Y = Crosshair.Y;
          return;
        }
        return;
      }
      goto LAB_08067d30;
    }
    if (Settings.Mode != 0) {
      return;
    }
  }
  else {
    if (Settings.Mode == 0x6d) {
LAB_08067d30:
      iVar2 = (*gui->shift_is_pressed)();
      Crosshair.AttachedBox.otherway = (Boolean)iVar2;
      return;
    }
    if (Settings.Mode != 0x6e) {
      if (Settings.Mode != 0x6a) {
        return;
      }
      pPVar1 = AdjustInsertPoint();
      if (pPVar1 == (PointTypePtr)0x0) {
        return;
      }
      InsertedPoint.X = pPVar1->X;
      InsertedPoint.Y = pPVar1->Y;
      InsertedPoint.X2 = pPVar1->X2;
      InsertedPoint.Y2 = pPVar1->Y2;
      InsertedPoint.ID = pPVar1->ID;
      return;
    }
  }
  if (Crosshair.AttachedBox.State == 0) {
    return;
  }
  Crosshair.AttachedBox.Point2.X = Crosshair.X;
  Crosshair.AttachedBox.Point2.Y = Crosshair.Y;
  return;
}



// WARNING: Unknown calling convention

int ActionUndo(int argc,char **argv,int x,int y)

{
  String Ident;
  PCBTypePtr pPVar1;
  char *function;
  int iVar2;
  void *ptr1;
  LineTypePtr ptr2;
  uint uVar3;
  int type;
  BoxTypePtr pBVar4;
  BoxTypePtr bx;
  LayerTypePtr Layer;
  void *ptr3_1;
  void *ptr3;
  void *ptr1_1;
  
  if (((argc < 1) || (Ident = *argv, Ident == (String)0x0)) || (*Ident == '\0')) {
    if ((Crosshair.AttachedObject.State != 0) ||
       ((Crosshair.AttachedBox.State != 0 && (Settings.Mode != 0x6d)))) {
      return 1;
    }
    HideCrosshair('\x01');
    if (Settings.Mode == 4) {
      if (Crosshair.AttachedPolygon.PointN != 0) {
        GoToPreviousPoint();
        RestoreCrosshair('\x01');
        return 0;
      }
    }
    else if (Settings.Mode == 2) {
      if (Crosshair.AttachedLine.State == 1) {
        if (*(char *)&(PCB->Flags).f < '\0') {
          Undo('\x01');
        }
        Crosshair.AttachedLine.State = 0;
        SetLocalRef(0,0,'\0');
        RestoreCrosshair('\x01');
        return 0;
      }
      if (Crosshair.AttachedLine.State == 2) {
        SearchObjectByLocation
                  (0x24,&ptr3_1,&ptr1_1,&ptr3,Crosshair.AttachedLine.Point1.X,
                   Crosshair.AttachedLine.Point1.Y,0);
        Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)ptr1_1 + 0x2c);
        Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)ptr1_1 + 0x30);
        uVar3 = Undo('\x01');
        if ((uVar3 == 0) || (SetChangedFlag('\x01'), (uVar3 & 0x40) == 0)) {
          Crosshair.AttachedLine.Point2.X = Crosshair.AttachedLine.Point1.X;
          Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedLine.Point1.Y;
          RestoreCrosshair('\x01');
          return 0;
        }
        Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
        Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
        if ((uVar3 & 4) != 0) {
          SearchObjectByLocation
                    (0x24,&ptr3_1,&ptr1_1,&ptr3,Crosshair.AttachedLine.Point2.X,
                     Crosshair.AttachedLine.Point2.Y,0);
          pPVar1 = PCB;
          if (*(char *)&(PCB->Flags).f < '\0') {
            *(uint *)((int)ptr1_1 + 0x14) = *(uint *)((int)ptr1_1 + 0x14) | 4;
            if (pPVar1->SilkActive == '\0') {
              Layer = pPVar1->Data->Layer + LayerStack[0];
            }
            else {
              Layer = pPVar1->Data->Layer +
                      (uint)(Settings.ShowSolderSide == '\0') + pPVar1->Data->LayerN;
            }
            DrawLine(Layer,(LineTypePtr)ptr1_1,0);
          }
          Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)ptr1_1 + 0x40);
          Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)ptr1_1 + 0x44);
        }
        Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
        Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
        FitCrosshairIntoGrid(Crosshair.X,Crosshair.Y);
        AdjustAttachedObjects();
        addedLines = addedLines + -1;
        if (addedLines == 0) {
          Crosshair.AttachedLine.State = 1;
          if (PCB->SilkActive == '\0') {
            lastLayer = PCB->Data->Layer + LayerStack[0];
          }
          else {
            lastLayer = PCB->Data->Layer +
                        (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
          }
        }
        else {
          SearchObjectByLocation
                    (0x24,&ptr3_1,&ptr1_1,&ptr3,Crosshair.AttachedLine.Point1.X,
                     Crosshair.AttachedLine.Point1.Y,0);
          lastLayer = (LayerTypePtr)ptr3_1;
        }
        goto LAB_08067d76;
      }
    }
    else if (Settings.Mode == 0x6d) {
      if (Crosshair.AttachedBox.State == 1) {
        Crosshair.AttachedBox.State = 0;
        goto LAB_08067d76;
      }
      if (Crosshair.AttachedBox.State == 2) {
        SearchObjectByLocation
                  (0x4000,&ptr1_1,&ptr3,&ptr3_1,Crosshair.AttachedBox.Point1.X,
                   Crosshair.AttachedBox.Point1.Y,0);
        pBVar4 = GetArcEnds((ArcTypePtr)ptr3);
        Crosshair.AttachedBox.Point1.X = pBVar4->X1;
        Crosshair.AttachedBox.Point1.Y = pBVar4->Y1;
        Crosshair.AttachedBox.Point2.X = Crosshair.AttachedBox.Point1.X;
        Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedBox.Point1.Y;
        AdjustAttachedObjects();
        addedLines = addedLines + -1;
        if (addedLines == 0) {
          Crosshair.AttachedBox.State = 1;
        }
      }
    }
    iVar2 = Undo('\x01');
    if (iVar2 != 0) {
      SetChangedFlag('\x01');
    }
  }
  else {
    iVar2 = GetFunctionID(Ident);
    if (iVar2 == 0xd) {
      ClearUndoList('\0');
    }
  }
LAB_08067d76:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionDisplay(int argc,char **argv,int childX,int childY)

{
  double dVar1;
  String Ident;
  PCBTypePtr pPVar2;
  Boolean BVar3;
  int iVar4;
  int id;
  long lVar5;
  DataTypePtr paVar6;
  Cardinal sn_1;
  uint uVar7;
  char *str_dir;
  crosshair_shape cVar8;
  Cardinal n_1;
  Cardinal n;
  int iVar9;
  PinTypePtr Pin;
  PadTypePtr Pad;
  Cardinal n_3;
  int iVar10;
  uint uVar11;
  Cardinal n_2;
  uint uVar12;
  char *function;
  Cardinal sn;
  BoxType area;
  void *local_30;
  PadTypePtr local_2c;
  void *local_28;
  LocationType local_24;
  LocationType local_20 [4];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    str_dir = (char *)0x0;
  }
  else {
    str_dir = argv[1];
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  if ((str_dir != (char *)0x0) && (*str_dir != '\0')) {
    iVar4 = GetFunctionID(Ident);
    pPVar2 = PCB;
    if (iVar4 == 0x5b) {
      if (argc < 3) {
        return 0;
      }
      lVar5 = strtol(argv[1],(char **)0x0,10);
      pPVar2->GridOffsetX = lVar5;
      pPVar2 = PCB;
      lVar5 = strtol(argv[2],(char **)0x0,10);
      pPVar2->GridOffsetY = lVar5;
      if (Settings.DrawGrid == '\0') {
        return 0;
      }
      UpdateAll();
      return 0;
    }
LAB_080681e8:
    Message("Syntax error.  Usage:\n%s\n",
            "Display(NameOnPCB|Description|Value)\nDisplay(Grid|Redraw)\nDisplay(CycleClip|CycleCrosshair|Toggle45Degree|ToggleStartDirection)\nDisplay(ToggleGrid|ToggleRubberBandMode|ToggleUniqueNames)\nDisplay(ToggleMask|ToggleName|ToggleClearLine|ToggleFullPoly|ToggleSnapPin)\nDisplay(ToggleThindraw|ToggleThindrawPoly|ToggleOrthoMove|ToggleLocalRef)\nDisplay(ToggleCheckPlanes|ToggleShowDRC|ToggleAutoDRC)\nDisplay(ToggleLiveRoute|LockNames|OnlyNames)\nDisplay(Pinout|PinOrPadName)\nDisplay(Scroll, Direction)"
           );
    return 1;
  }
  HideCrosshair('\x01');
  iVar4 = GetFunctionID(Ident);
  pPVar2 = PCB;
  switch(iVar4) {
  case 8:
  case 0x2a:
  case 0x6f:
    paVar6 = PCB->Data;
    iVar9 = paVar6->ElementN - 1;
    if (iVar9 != -1) {
      iVar10 = paVar6->ElementN * 300;
      while( true ) {
        iVar9 = iVar9 + -1;
        EraseElementName((ElementTypePtr)(paVar6->Element[-1].Flags.t + iVar10 + -0x18));
        if (iVar9 == -1) break;
        paVar6 = PCB->Data;
        iVar10 = iVar10 + -300;
      }
    }
    pPVar2 = PCB;
    (PCB->Flags).f = (PCB->Flags).f & 0xffffff9f;
    if (iVar4 == 8) {
      (pPVar2->Flags).f = (pPVar2->Flags).f | 0x20;
    }
    else if (iVar4 == 0x2a) {
      (pPVar2->Flags).f = (pPVar2->Flags).f | 0x40;
    }
    paVar6 = pPVar2->Data;
    iVar4 = paVar6->ElementN - 1;
    if (iVar4 != -1) {
      iVar9 = paVar6->ElementN * 300;
      while( true ) {
        iVar4 = iVar4 + -1;
        DrawElementName((ElementTypePtr)(paVar6->Element[-1].Flags.t + iVar9 + -0x18),0);
        if (iVar4 == -1) break;
        paVar6 = PCB->Data;
        iVar9 = iVar9 + -300;
      }
    }
    goto LAB_0806835f;
  default:
    RestoreCrosshair('\x01');
    goto LAB_080681e8;
  case 0xc:
    (*gui->invalidate_all)();
    break;
  case 0x12:
    uVar7 = (PCB->Flags).f;
    if ((uVar7 & 0x100) == 0) {
      PCB->Clipping = (PCB->Clipping + 1) % 3;
    }
    else {
      (PCB->Flags).f = uVar7 ^ 0x100;
      pPVar2->Clipping = 0;
    }
    AdjustAttachedObjects();
    break;
  case 0x13:
    cVar8 = Crosshair.shape + Union_Jack_Crosshair_Shape;
    Crosshair.shape = Basic_Crosshair_Shape;
    if (cVar8 != Crosshair_Shapes_Number) {
      Crosshair.shape = cVar8;
    }
    break;
  case 0x1f:
    Settings.DrawGrid = Settings.DrawGrid == '\0';
    UpdateAll();
    break;
  case 0x33:
    iVar4 = SearchScreen(Crosshair.X,Crosshair.Y,0x303,&local_28,&local_2c,&local_30);
    if (iVar4 == 2) {
      if (*(uint *)((int)local_28 + 0xe0) != 0) {
        uVar11 = 0;
        uVar7 = *(uint *)((int)local_28 + 0xe0);
        do {
          Pin = (PinTypePtr)(uVar11 * 0x4c + *(int *)((int)local_28 + 0x100));
          if ((*(byte *)&(Pin->Flags).f & 0x20) == 0) {
            DrawPinName(Pin,0);
          }
          else {
            ErasePinName(Pin);
          }
          AddObjectToFlagUndoList(0x100,local_28,Pin,Pin);
          (Pin->Flags).f = (Pin->Flags).f ^ 0x20;
          uVar12 = *(uint *)((int)local_28 + 0xe0);
        } while ((uVar12 != 0) &&
                (uVar11 = (uVar12 + 1 + uVar11) - uVar7, uVar7 = uVar12, uVar11 < uVar12));
      }
      uVar7 = *(uint *)((int)local_28 + 0xe8);
      iVar4 = 0;
      uVar12 = 0;
      uVar11 = uVar7;
      while ((uVar11 != 0 && (uVar12 < uVar11))) {
        Pad = (PadTypePtr)(*(int *)((int)local_28 + 0x104) + iVar4);
        if ((*(byte *)&(Pad->Flags).f & 0x20) == 0) {
          DrawPadName(Pad,0);
        }
        else {
          ErasePadName(Pad);
        }
        AddObjectToFlagUndoList(0x200,local_28,Pad,Pad);
        (Pad->Flags).f = (Pad->Flags).f ^ 0x20;
        uVar11 = *(uint *)((int)local_28 + 0xe8);
        if (uVar11 == uVar7) {
          uVar12 = uVar12 + 1;
          iVar4 = iVar4 + 0x68;
        }
      }
    }
    else {
      if (iVar4 < 3) {
        if (iVar4 != 1) break;
        if ((*(byte *)&(local_2c->Flags).f & 0x20) == 0) {
          DrawViaName((PinTypePtr)local_2c,0);
        }
        else {
          EraseViaName((PinTypePtr)local_2c);
        }
        iVar4 = 1;
      }
      else {
        if (iVar4 == 0x100) {
          if ((*(byte *)&(local_2c->Flags).f & 0x20) == 0) {
            DrawPinName((PinTypePtr)local_2c,0);
          }
          else {
            ErasePinName((PinTypePtr)local_2c);
          }
          AddObjectToFlagUndoList(0x100,local_28,local_2c,local_30);
          (local_2c->Flags).f = (local_2c->Flags).f ^ 0x20;
          goto LAB_08068466;
        }
        if (iVar4 != 0x200) break;
        if ((*(byte *)&(local_2c->Flags).f & 0x20) == 0) {
          DrawPadName(local_2c,0);
        }
        else {
          ErasePadName(local_2c);
        }
        iVar4 = 0x200;
      }
      AddObjectToFlagUndoList(iVar4,local_28,local_2c,local_30);
      (local_2c->Flags).f = (local_2c->Flags).f ^ 0x20;
    }
LAB_08068466:
    SetChangedFlag('\x01');
    IncrementUndoSerialNumber();
LAB_0806835f:
    Draw();
    break;
  case 0x34:
    (*gui->get_coords)("Click on an element",local_20,&local_24);
    iVar4 = SearchScreen(local_20[0],local_24,2,&local_28,&local_28,&local_28);
    if (iVar4 != 0) {
      (*gui->show_item)(local_28);
    }
    break;
  case 0x39:
    area.X1 = 0;
    area.Y1 = 0;
    area.X2 = Output.Width;
    area.Y2 = Output.Height;
    RedrawOutput(&area);
    break;
  case 0x57:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x100;
    AdjustAttachedObjects();
    break;
  case 0x58:
    uVar7 = (PCB->Flags).f ^ 0x80;
    (PCB->Flags).f = uVar7;
    if (((char)uVar7 < '\0') && (Settings.Mode == 2)) {
      SaveUndoSerialNumber();
      ResetFoundPinsViasAndPads('\x01');
      RestoreUndoSerialNumber();
      ResetFoundLinesAndPolygons('\x01');
      if (Crosshair.AttachedLine.State != 0) {
        LookupConnection(Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,'\x01',1,4)
        ;
      }
    }
    break;
  case 0x59:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x800;
    break;
  case 0x5a:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x100000;
    break;
  case 0x5b:
    dVar1 = PCB->Grid;
    PCB->Grid = 1.0;
    BVar3 = MoveCrosshairAbsolute(childX,childY);
    if (BVar3 != '\0') {
      RestoreCrosshair('\0');
    }
    SetGrid((float)dVar1,'\x01');
    break;
  case 0x5c:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x200000;
    ClearAndRedrawOutput();
    break;
  case 0x5d:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x2000;
    UpdateAll();
    break;
  case 0x5e:
    (PCB->Flags).f = (PCB->Flags).f ^ 1;
    UpdateAll();
    break;
  case 0x60:
    (PCB->Flags).f = (PCB->Flags).f ^ 8;
    break;
  case 0x61:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x10000;
    break;
  case 0x62:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x10;
    break;
  case 99:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x200;
    break;
  case 100:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x1000;
    break;
  case 0x65:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x4000;
    ClearAndRedrawOutput();
    break;
  case 0x66:
    (PCB->Flags).f = ((PCB->Flags).f ^ 0x40000) & 0xfff7ffff;
    break;
  case 0x67:
    (PCB->Flags).f = ((PCB->Flags).f ^ 0x80000) & 0xfffbffff;
    break;
  case 0x68:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x20000;
    ClearAndRedrawOutput();
    break;
  case 0x69:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x8000;
    break;
  case 0x6a:
    (PCB->Flags).f = (PCB->Flags).f ^ 2;
    break;
  case 0x6b:
    (PCB->Flags).f = (PCB->Flags).f ^ 4;
    ClearAndRedrawOutput();
    break;
  case 0x6c:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x400;
  }
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

void EventMoveCrosshair(int ev_x,int ev_y)

{
  Boolean BVar1;
  
  if (IgnoreMotionEvents == '\0') {
    BVar1 = MoveCrosshairAbsolute(ev_x,ev_y);
    if (BVar1 != '\0') {
      AdjustAttachedObjects();
      RestoreCrosshair('\0');
      return;
    }
  }
  else {
    IgnoreMotionEvents = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

void ActionMovePointer(char *deltax,char *deltay)

{
  int DeltaX;
  LocationType LVar1;
  LocationType LVar2;
  long lVar3;
  LocationType dy;
  int DeltaY;
  int DeltaY_00;
  LocationType dx;
  LocationType y;
  LocationType x;
  
  LVar2 = Crosshair.Y;
  LVar1 = Crosshair.X;
  lVar3 = strtol(deltax,(char **)0x0,10);
  DeltaX = (int)ROUND((double)lVar3 * PCB->Grid);
  lVar3 = strtol(deltay,(char **)0x0,10);
  DeltaY = (int)ROUND((double)lVar3 * PCB->Grid);
  DeltaY_00 = DeltaY;
  if (Settings.ShowSolderSide != '\0') {
    DeltaY_00 = -DeltaY;
  }
  MoveCrosshairRelative(DeltaX,DeltaY_00);
  FitCrosshairIntoGrid(Crosshair.X,Crosshair.Y);
  Crosshair.X = LVar1;
  Crosshair.Y = LVar2;
  HideCrosshair('\0');
  if (Settings.ShowSolderSide != '\0') {
    DeltaY = -DeltaY;
  }
  MoveCrosshairRelative(DeltaX,DeltaY);
  AdjustAttachedObjects();
  RestoreCrosshair('\0');
  return;
}



// WARNING: Unknown calling convention

void NotifyMode(void)

{
  char cVar1;
  FlagType Flags;
  FlagType Flags_00;
  FlagType Flags_01;
  FlagType Flags_02;
  FlagType Flags_03;
  FlagType Flags_04;
  FlagType Flags_05;
  Boolean BVar2;
  LineTypePtr pLVar3;
  LineTypePtr line;
  LayerTypePtr pLVar4;
  LayerType *pLVar5;
  int type_2;
  int iVar6;
  PolygonTypePtr Polygon;
  int type_1;
  BYTE Steps;
  char *TextString;
  TextTypePtr Text;
  PointTypePtr pPVar7;
  LocationType wy;
  ArcTypePtr Arc;
  BoxTypePtr pBVar8;
  BoxTypePtr bx;
  RatTypePtr Line;
  Cardinal CVar9;
  PinTypePtr paVar10;
  TextTypePtr thing;
  int iVar11;
  PinTypePtr pin;
  int tstyle;
  LocationType wx;
  uint uVar12;
  uint uVar13;
  int types;
  uint uVar14;
  Cardinal n_1;
  Cardinal n_2;
  PinTypePtr via;
  Cardinal n;
  PinTypePtr via_1;
  ElementTypePtr Element;
  BoxType *box;
  uint uVar15;
  RubberbandTypePtr paVar16;
  undefined *puVar17;
  PointTypePtr points;
  int i;
  TextType *pTVar18;
  int type;
  TextType *pTVar19;
  Cardinal sn;
  int in_GS_OFFSET;
  byte bVar20;
  uint local_148;
  LayerTypePtr local_144;
  undefined local_140 [12];
  TextType estr [3];
  void *local_80;
  ElementTypePtr local_7c;
  ElementTypePtr local_78;
  undefined4 local_74;
  undefined4 local_70;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  bVar20 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (Settings.RatWarn != '\0') {
    ClearWarnings();
  }
  pPVar7 = Crosshair.AttachedPolygon.Points;
  CVar9 = Crosshair.AttachedPolygon.PointN;
  puVar17 = &stack0xfffffe74;
  switch(Settings.Mode) {
  case 1:
    if (PCB->ViaOn == '\0') {
      Message("You must turn via visibility on before\nyou can place vias\n");
      puVar17 = &stack0xfffffe74;
    }
    else {
      MakeFlags(0);
      Flags_03.t[0] = (undefined)local_28;
      Flags_03.t[1] = local_28._1_1_;
      Flags_03.t[2] = local_28._2_1_;
      Flags_03.t[3] = local_28._3_1_;
      Flags_03.f = local_2c;
      Flags_03.t[4] = (undefined)local_24;
      Flags_03.t[5] = local_24._1_1_;
      Flags_03.t[6] = local_24._2_1_;
      Flags_03.t[7] = local_24._3_1_;
      paVar10 = CreateNewVia(PCB->Data,Note.X,Note.Y,Settings.ViaThickness,Settings.Keepaway * 2,0,
                             Settings.ViaDrillingHole,(char *)0x0,Flags_03);
      puVar17 = &stack0xfffffe74;
      if (paVar10 != (PinTypePtr)0x0) {
        AddObjectToCreateUndoList(1,paVar10,paVar10,paVar10);
        iVar6 = (*gui->shift_is_pressed)();
        if (iVar6 != 0) {
          ChangeObjectThermal(1,paVar10,paVar10,paVar10,(int)PCB->ThermStyle);
        }
        IncrementUndoSerialNumber();
        DrawVia(paVar10,0);
        Draw();
        puVar17 = &stack0xfffffe74;
      }
    }
    break;
  case 2:
    NotifyLine();
    puVar17 = &stack0xfffffe74;
    if (Crosshair.AttachedLine.State != 2) break;
    if ((Crosshair.X == Crosshair.AttachedLine.Point1.X) &&
       (Crosshair.Y == Crosshair.AttachedLine.Point1.Y)) {
      SetMode(2);
      puVar17 = &stack0xfffffe74;
      break;
    }
    if (PCB->RatDraw != '\0') {
      Line = AddNet();
      puVar17 = &stack0xfffffe74;
      if (Line != (RatTypePtr)0x0) {
        addedLines = addedLines + 1;
        AddObjectToCreateUndoList(0x20,Line,Line,Line);
        IncrementUndoSerialNumber();
        DrawRat(Line,0);
        Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
        Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
        Draw();
        puVar17 = &stack0xfffffe74;
      }
      break;
    }
    if (PCB->Clipping == 0) {
LAB_08068b66:
      if ((Crosshair.AttachedLine.Point1.X != Crosshair.AttachedLine.Point2.X) ||
         (Crosshair.AttachedLine.Point1.Y != Crosshair.AttachedLine.Point2.Y)) {
LAB_08068b6e:
        uVar15 = (PCB->Flags).f;
        MakeFlags(~-(uint)((uVar15 & 0x800) == 0) & 0x20 | ~-(uint)((uVar15 & 0x80) == 0) & 4);
        if (PCB->SilkActive == '\0') {
          pLVar4 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        Flags_00.t[0] = (undefined)local_40;
        Flags_00.t[1] = local_40._1_1_;
        Flags_00.t[2] = local_40._2_1_;
        Flags_00.t[3] = local_40._3_1_;
        Flags_00.f = local_44;
        Flags_00.t[4] = (undefined)local_3c;
        Flags_00.t[5] = local_3c._1_1_;
        Flags_00.t[6] = local_3c._2_1_;
        Flags_00.t[7] = local_3c._3_1_;
        pLVar3 = CreateDrawnLineOnLayer
                           (pLVar4,Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,
                            Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                            Settings.LineThickness,Settings.Keepaway * 2,Flags_00);
        if (pLVar3 != (LineTypePtr)0x0) {
          addedLines = addedLines + 1;
          if (PCB->SilkActive == '\0') {
            pLVar5 = PCB->Data->Layer + LayerStack[0];
          }
          else {
            pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
          }
          AddObjectToCreateUndoList(4,pLVar5,pLVar3,pLVar3);
          if (PCB->SilkActive == '\0') {
            pLVar4 = PCB->Data->Layer + LayerStack[0];
          }
          else {
            pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
          }
          DrawLine(pLVar4,pLVar3,0);
          if (PCB->ViaOn != '\0') {
            if (PCB->SilkActive == '\0') {
              pLVar4 = PCB->Data->Layer + LayerStack[0];
            }
            else {
              pLVar4 = PCB->Data->Layer +
                       (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
            }
            iVar6 = GetLayerGroupNumberByPointer(pLVar4);
            iVar11 = GetLayerGroupNumberByPointer(lastLayer);
            if ((iVar6 != iVar11) &&
               (iVar6 = SearchObjectByLocation
                                  (0x101,&local_78,&local_7c,&local_80,
                                   Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,
                                   Settings.ViaThickness / 2), iVar6 == 0)) {
              MakeFlags(0);
              Flags_04.t[0] = (undefined)local_4c;
              Flags_04.t[1] = local_4c._1_1_;
              Flags_04.t[2] = local_4c._2_1_;
              Flags_04.t[3] = local_4c._3_1_;
              Flags_04.f = local_50;
              Flags_04.t[4] = (undefined)local_48;
              Flags_04.t[5] = local_48._1_1_;
              Flags_04.t[6] = local_48._2_1_;
              Flags_04.t[7] = local_48._3_1_;
              paVar10 = CreateNewVia(PCB->Data,Crosshair.AttachedLine.Point1.X,
                                     Crosshair.AttachedLine.Point1.Y,Settings.ViaThickness,
                                     Settings.Keepaway * 2,0,Settings.ViaDrillingHole,(char *)0x0,
                                     Flags_04);
              if (paVar10 != (PinTypePtr)0x0) {
                AddObjectToCreateUndoList(1,paVar10,paVar10,paVar10);
                DrawVia(paVar10,0);
              }
            }
          }
          Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
          Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
          IncrementUndoSerialNumber();
          if (PCB->SilkActive == '\0') {
            lastLayer = PCB->Data->Layer + LayerStack[0];
          }
          else {
            lastLayer = PCB->Data->Layer +
                        (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
          }
        }
      }
      if (PCB->Clipping == 0) goto LAB_08068f75;
    }
    else {
      if ((Crosshair.AttachedLine.Point1.X != Crosshair.AttachedLine.Point2.X) ||
         (Crosshair.AttachedLine.Point1.Y != Crosshair.AttachedLine.Point2.Y)) goto LAB_08068b6e;
      if ((Crosshair.AttachedLine.Point1.X != Note.X) || (Crosshair.AttachedLine.Point1.Y != Note.Y)
         ) {
        Crosshair.AttachedLine.Point2.Y = Note.Y;
        Crosshair.AttachedLine.Point2.X = Note.X;
        goto LAB_08068b66;
      }
    }
    if ((Note.X != Crosshair.AttachedLine.Point2.X) || (Note.Y != Crosshair.AttachedLine.Point2.Y))
    {
      uVar15 = (PCB->Flags).f;
      MakeFlags(~-(uint)((uVar15 & 0x800) == 0) & 0x20 | ~-(uint)((uVar15 & 0x80) == 0) & 4);
      if (PCB->SilkActive == '\0') {
        pLVar4 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      Flags_01.t[0] = (undefined)local_58;
      Flags_01.t[1] = local_58._1_1_;
      Flags_01.t[2] = local_58._2_1_;
      Flags_01.t[3] = local_58._3_1_;
      Flags_01.f = local_5c;
      Flags_01.t[4] = (undefined)local_54;
      Flags_01.t[5] = local_54._1_1_;
      Flags_01.t[6] = local_54._2_1_;
      Flags_01.t[7] = local_54._3_1_;
      pLVar3 = CreateDrawnLineOnLayer
                         (pLVar4,Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                          Note.X,Note.Y,Settings.LineThickness,Settings.Keepaway * 2,Flags_01);
      if (pLVar3 != (LineTypePtr)0x0) {
        addedLines = addedLines + 1;
        if (PCB->SilkActive == '\0') {
          pLVar5 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        AddObjectToCreateUndoList(4,pLVar5,pLVar3,pLVar3);
        IncrementUndoSerialNumber();
        if (PCB->SilkActive == '\0') {
          pLVar4 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        DrawLine(pLVar4,pLVar3,0);
        Crosshair.AttachedLine.Point1.Y = Note.Y;
        Crosshair.AttachedLine.Point2.Y = Note.Y;
        Crosshair.AttachedLine.Point1.X = Note.X;
        Crosshair.AttachedLine.Point2.X = Note.X;
        if ((*(byte *)((int)&(PCB->Flags).f + 1) & 2) != 0) {
          PCB->Clipping = PCB->Clipping ^ 3;
        }
      }
    }
LAB_08068f75:
    Draw();
    puVar17 = &stack0xfffffe74;
    break;
  case 3:
    NotifyBlock();
    puVar17 = &stack0xfffffe74;
    if (((Crosshair.AttachedBox.State == 2) &&
        (puVar17 = &stack0xfffffe74,
        Crosshair.AttachedBox.Point1.X != Crosshair.AttachedBox.Point2.X)) &&
       (puVar17 = &stack0xfffffe74, Crosshair.AttachedBox.Point1.Y != Crosshair.AttachedBox.Point2.Y
       )) {
      MakeFlags((-(uint)(((PCB->Flags).f & 0x100000) == 0) & 0xffffffe0) + 0x30);
      if (PCB->SilkActive == '\0') {
        pLVar4 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      Flags.t[0] = (undefined)local_64;
      Flags.t[1] = local_64._1_1_;
      Flags.t[2] = local_64._2_1_;
      Flags.t[3] = local_64._3_1_;
      Flags.f = local_68;
      Flags.t[4] = (undefined)local_60;
      Flags.t[5] = local_60._1_1_;
      Flags.t[6] = local_60._2_1_;
      Flags.t[7] = local_60._3_1_;
      Polygon = CreateNewPolygonFromRectangle
                          (pLVar4,Crosshair.AttachedBox.Point1.X,Crosshair.AttachedBox.Point1.Y,
                           Crosshair.AttachedBox.Point2.X,Crosshair.AttachedBox.Point2.Y,Flags);
      if (Polygon != (PolygonTypePtr)0x0) {
        if (PCB->SilkActive == '\0') {
          pLVar5 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        AddObjectToCreateUndoList(8,pLVar5,Polygon,Polygon);
        IncrementUndoSerialNumber();
        if (PCB->SilkActive == '\0') {
          pLVar4 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        DrawPolygon(pLVar4,Polygon,0);
        Draw();
      }
      Crosshair.AttachedBox.State = 0;
      puVar17 = &stack0xfffffe74;
    }
    break;
  case 4:
    NotifyLine();
    iVar6 = Crosshair.AttachedLine.Point2.X;
    if (CVar9 < 3) {
      if (CVar9 != 0) goto LAB_080692d7;
    }
    else {
      if ((pPVar7->X == Crosshair.AttachedLine.Point2.X) &&
         (iVar6 = pPVar7->X, pPVar7->Y == Crosshair.AttachedLine.Point2.Y)) {
        CopyAttachedPolygonToLayer();
        goto LAB_08068f75;
      }
LAB_080692d7:
      if ((iVar6 == pPVar7[CVar9 - 1].X) &&
         (puVar17 = &stack0xfffffe74, Crosshair.AttachedLine.Point2.Y == pPVar7[CVar9 - 1].Y))
      break;
    }
    CreateNewPointInPolygon(&Crosshair.AttachedPolygon,iVar6,Crosshair.AttachedLine.Point2.Y);
    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
    Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
    puVar17 = &stack0xfffffe74;
    break;
  case 5:
    iVar6 = (*gui->shift_is_pressed)();
    if ((iVar6 == 0) ||
       (iVar6 = SearchScreen(Note.X,Note.Y,2,&local_78,&local_7c,&local_80), Element = local_78,
       iVar6 != 2)) {
      Element = (ElementTypePtr)0x0;
    }
    else if (local_78 != (ElementTypePtr)0x0) {
      pTVar18 = local_78->Name;
      pTVar19 = estr;
      for (iVar6 = 0x2d; iVar6 != 0; iVar6 = iVar6 + -1) {
        (pTVar19->BoundingBox).X1 = (pTVar18->BoundingBox).X1;
        pTVar18 = (TextType *)((int)pTVar18 + (uint)bVar20 * -8 + 4);
        pTVar19 = (TextType *)((int)pTVar19 + (uint)bVar20 * -8 + 4);
      }
      estr[0].TextString = (char *)__strdup();
      estr[1].TextString = (char *)__strdup();
      estr[2].TextString = (char *)__strdup();
      RemoveElement(Element);
    }
    BVar2 = CopyPastebufferToLayout(Note.X,Note.Y);
    if (BVar2 != '\0') {
      SetChangedFlag('\x01');
    }
    puVar17 = &stack0xfffffe74;
    if (((Element != (ElementTypePtr)0x0) &&
        (iVar6 = SearchScreen(Note.X,Note.Y,2,&local_78,&local_7c,&local_80),
        puVar17 = &stack0xfffffe74, iVar6 == 2)) &&
       (puVar17 = &stack0xfffffe74, local_78 != (ElementTypePtr)0x0)) {
      local_148 = 1;
      uVar15 = (PCB->Flags).f;
      if ((uVar15 & 0x40) == 0) {
        local_148 = -(uint)((uVar15 & 0x20) == 0) & 2;
      }
      uVar15 = 0;
      box = (BoxType *)local_78->Name;
      local_144 = (LayerTypePtr)0x0;
      do {
        if (uVar15 == local_148) {
          EraseElementName(local_78);
        }
        r_delete_entry(PCB->Data->name_tree[uVar15],box);
        box->X1 = *(LocationType *)(estr[0].Flags.t + (int)local_144 + -0x18);
        box->Y1 = *(LocationType *)(estr[0].Flags.t + (int)local_144 + -0x14);
        box->X2 = *(LocationType *)((int)(&estr[0].Flags + -1) + (int)local_144);
        box->Y2 = *(LocationType *)(estr[0].Flags.t + (int)local_144 + -0xc);
        box[1].X1 = *(LocationType *)(estr[0].Flags.t + (int)local_144 + -8);
        box[1].Y1 = *(LocationType *)(estr[0].Flags.t + (int)local_144 + -4);
        box[1].X2 = *(LocationType *)(estr[0].Flags.t + (int)local_144);
        box[1].Y2 = *(LocationType *)(estr[0].Flags.t + (int)local_144 + 4);
        box[2].X1 = *(LocationType *)((int)(&estr[0].Flags + 1) + (int)local_144);
        box[2].Y1 = *(LocationType *)((int)(&estr[0].Flags + 1) + (int)local_144 + 4);
        box[2].X2 = *(LocationType *)((int)(&estr[0].Flags + 1) + (int)local_144 + 8);
        box[2].Y2 = *(LocationType *)((int)(&estr[0].Flags + 2) + (int)local_144);
        box[3].X1 = *(LocationType *)((int)(&estr[0].Flags + 2) + (int)local_144 + 4);
        box[3].Y1 = *(LocationType *)((int)(&estr[0].Flags + 2) + (int)local_144 + 8);
        box[3].X2 = *(LocationType *)((int)(&estr[0].Flags + 3) + (int)local_144);
        *(ElementTypePtr *)((int)(&local_78->Name[0].Flags + 3) + (int)local_144) = local_78;
        SetTextBoundingBox(&PCB->Font,local_78->Name + uVar15);
        r_insert_entry(PCB->Data->name_tree[uVar15],box,0);
        if (uVar15 == local_148) {
          DrawElementName(local_78,0);
        }
        uVar15 = uVar15 + 1;
        box = (BoxType *)&box[3].Y2;
        local_144 = (LayerTypePtr)((int)local_144 + 0x3c);
        puVar17 = &stack0xfffffe74;
      } while (uVar15 != 3);
    }
    break;
  case 6:
    TextString = (*gui->prompt_for)("Enter text:","");
    puVar17 = &stack0xfffffe74;
    if (TextString != (char *)0x0) {
      if (*TextString != '\0') {
        CVar9 = LayerStack[0];
        if (PCB->SilkActive != '\0') {
          CVar9 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        iVar6 = GetLayerGroupNumberByNumber(CVar9);
        iVar11 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
        uVar15 = 0x80;
        if (iVar6 != iVar11) {
          uVar15 = 0;
        }
        MakeFlags(uVar15);
        if (PCB->SilkActive == '\0') {
          local_144 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          local_144 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN
          ;
        }
        Flags_02.t[0] = (undefined)local_70;
        Flags_02.t[1] = local_70._1_1_;
        Flags_02.t[2] = local_70._2_1_;
        Flags_02.t[3] = local_70._3_1_;
        Flags_02.f = local_74;
        Flags_02.t[4] = (undefined)local_6c;
        Flags_02.t[5] = local_6c._1_1_;
        Flags_02.t[6] = local_6c._2_1_;
        Flags_02.t[7] = local_6c._3_1_;
        Text = CreateNewText(local_144,&PCB->Font,Note.X,Note.Y,'\0',Settings.TextScale,TextString,
                             Flags_02);
        if (Text != (TextTypePtr)0x0) {
          if (PCB->SilkActive == '\0') {
            pLVar5 = PCB->Data->Layer + LayerStack[0];
          }
          else {
            pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
          }
          AddObjectToCreateUndoList(0x10,pLVar5,Text,Text);
          IncrementUndoSerialNumber();
          if (PCB->SilkActive == '\0') {
            pLVar4 = PCB->Data->Layer + LayerStack[0];
          }
          else {
            pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
          }
          DrawText(pLVar4,Text,0);
          Draw();
        }
      }
      free(TextString);
      puVar17 = &stack0xfffffe74;
    }
    break;
  case 0x66:
    (*gui->shift_is_pressed)();
    if (Settings.ShowSolderSide == '\0') {
      Steps = '\x03';
    }
    else {
      Steps = '\x01';
    }
    RotateScreenObject(Note.X,Note.Y,Steps);
    puVar17 = &stack0xfffffe74;
    break;
  case 0x67:
    iVar6 = SearchScreen(Note.X,Note.Y,0x583f,&local_78,&local_7c,&local_80);
    puVar17 = &stack0xfffffe74;
    if (iVar6 != 0) {
      if ((*(byte *)((int)&(local_7c->Flags).f + 1) & 0x20) == 0) {
        if (iVar6 == 2) {
          uVar15 = 0;
          Crosshair.AttachedObject.RubberbandN = 0;
          LookupRatLines(2,local_78,local_7c,local_80);
          paVar16 = Crosshair.AttachedObject.Rubberband;
          if (Crosshair.AttachedObject.RubberbandN != 0) {
            while( true ) {
              if (PCB->RatOn != '\0') {
                EraseRat((RatTypePtr)paVar16->Line);
              }
              pLVar3 = paVar16->Line;
              uVar14 = (pLVar3->Flags).f;
              if ((uVar14 & 0x200) == 0) {
                (pLVar3->Flags).f = uVar14 ^ 0x200;
              }
              else {
                MoveObjectToRemoveUndoList(0x20,pLVar3,pLVar3,pLVar3);
              }
              uVar15 = uVar15 + 1;
              if (Crosshair.AttachedObject.RubberbandN <= uVar15) break;
              paVar16 = paVar16 + 1;
            }
          }
        }
        RemoveObject(iVar6,local_78,local_7c,local_80);
        IncrementUndoSerialNumber();
        SetChangedFlag('\x01');
        puVar17 = &stack0xfffffe74;
      }
      else {
        Message("Sorry, the object is locked\n");
        puVar17 = &stack0xfffffe74;
      }
    }
    break;
  case 0x68:
  case 0x69:
    if (Crosshair.AttachedObject.State != 0) {
      puVar17 = &stack0xfffffe74;
      if (Crosshair.AttachedObject.State != 1) break;
      if (Settings.Mode == 0x69) {
        CopyObject(Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3,
                   Note.X - Crosshair.AttachedObject.X,Note.Y - Crosshair.AttachedObject.Y);
      }
      else {
        MoveObjectAndRubberband
                  (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3,
                   Note.X - Crosshair.AttachedObject.X,Note.Y - Crosshair.AttachedObject.Y);
        SetLocalRef(0,0,'\0');
      }
LAB_08069d2f:
      SetChangedFlag('\x01');
      Crosshair.AttachedObject.Type = 0;
      Crosshair.AttachedObject.State = 0;
      puVar17 = &stack0xfffffe74;
      break;
    }
    iVar6 = 0x5c1f;
    if (Settings.Mode == 0x69) {
      iVar6 = 0x441f;
    }
    Crosshair.AttachedObject.Type =
         SearchScreen(Note.X,Note.Y,iVar6,&Crosshair.AttachedObject.Ptr1,
                      &Crosshair.AttachedObject.Ptr2,&Crosshair.AttachedObject.Ptr3);
    puVar17 = &stack0xfffffe74;
    if (Crosshair.AttachedObject.Type == 0) break;
    if ((Settings.Mode != 0x68) ||
       ((*(byte *)((int)Crosshair.AttachedObject.Ptr2 + 0x15) & 0x20) == 0)) {
      AttachForCopy(Note.X,Note.Y);
      puVar17 = &stack0xfffffe74;
      break;
    }
    goto LAB_0806a437;
  case 0x6a:
    if (Crosshair.AttachedObject.State != 0) {
      puVar17 = &stack0xfffffe74;
      if (Crosshair.AttachedObject.State != 1) break;
      if (Crosshair.AttachedObject.Type == 8) {
        InsertPointIntoObject
                  (8,Crosshair.AttachedObject.Ptr1,fake.poly,&polyIndex,InsertedPoint.X,
                   InsertedPoint.Y,'\0');
      }
      else {
        InsertPointIntoObject
                  (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,&polyIndex,InsertedPoint.X,InsertedPoint.Y,'\0');
      }
      goto LAB_08069d2f;
    }
    Crosshair.AttachedObject.Type =
         SearchScreen(Note.X,Note.Y,0x2c,&Crosshair.AttachedObject.Ptr1,
                      &Crosshair.AttachedObject.Ptr2,&Crosshair.AttachedObject.Ptr3);
    puVar17 = &stack0xfffffe74;
    if (Crosshair.AttachedObject.Type == 0) break;
    if ((*(byte *)((int)Crosshair.AttachedObject.Ptr2 + 0x15) & 0x20) == 0) {
      if (Crosshair.AttachedObject.Type == 8) {
        fake.poly = (PolygonTypePtr)Crosshair.AttachedObject.Ptr2;
        polyIndex = GetLowestDistancePolygonPoint
                              ((PolygonTypePtr)Crosshair.AttachedObject.Ptr2,Note.X,Note.Y);
        pPVar7 = (fake.poly)->Points;
        fake.line.Point1.X = pPVar7[polyIndex].X;
        fake.line.Point1.Y = pPVar7[polyIndex].Y;
        fake.line.Point1.X2 = pPVar7[polyIndex].X2;
        fake.line.Point1.Y2 = pPVar7[polyIndex].Y2;
        fake.line.Point1.ID = pPVar7[polyIndex].ID;
        CVar9 = polyIndex;
        if (polyIndex == 0) {
          CVar9 = (fake.poly)->PointN;
        }
        fake.line.Point2.X = pPVar7[CVar9 - 1].X;
        Crosshair.AttachedObject.Ptr2 = &fake.line;
        fake.line.Point2.Y = pPVar7[CVar9 - 1].Y;
        fake.line.Point2.X2 = pPVar7[CVar9 - 1].X2;
        fake.line.Point2.Y2 = pPVar7[CVar9 - 1].Y2;
        fake.line.Point2.ID = pPVar7[CVar9 - 1].ID;
      }
      Crosshair.AttachedObject.State = 1;
      pPVar7 = AdjustInsertPoint();
      InsertedPoint.X = pPVar7->X;
      InsertedPoint.Y = pPVar7->Y;
      InsertedPoint.X2 = pPVar7->X2;
      InsertedPoint.Y2 = pPVar7->Y2;
      InsertedPoint.ID = pPVar7->ID;
      puVar17 = &stack0xfffffe74;
      break;
    }
LAB_0806a437:
    Message("Sorry, the object is locked\n");
    Crosshair.AttachedObject.Type = 0;
    puVar17 = &stack0xfffffe74;
    break;
  case 0x6c:
    iVar6 = SearchScreen(Note.X,Note.Y,0x101,&local_78,&local_7c,&local_80);
    puVar17 = &stack0xfffffe74;
    if ((iVar6 != 0) && (puVar17 = &stack0xfffffe74, (*(byte *)((int)local_80 + 0x14) & 8) == 0)) {
      iVar11 = (*gui->shift_is_pressed)();
      if (iVar11 == 0) {
        iVar11 = LayerStack[0];
        if (PCB->SilkActive != '\0') {
          iVar11 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        cVar1 = (char)(iVar11 >> 0x1f);
        if (((int)(uint)*(byte *)((int)local_80 + iVar11 / 2 + 0x18) >>
             ((((char)iVar11 - cVar1 & 1U) + cVar1) * '\x04' & 0x1f) & 0xfU) == 0) {
          uVar15 = (uint)PCB->ThermStyle;
        }
        else {
          uVar15 = 0;
        }
      }
      else {
        iVar11 = LayerStack[0];
        if (PCB->SilkActive != '\0') {
          iVar11 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        cVar1 = (char)(iVar11 >> 0x1f);
        uVar15 = ((int)(uint)*(byte *)((int)local_80 + iVar11 / 2 + 0x18) >>
                  ((((char)iVar11 - cVar1 & 1U) + cVar1) * '\x04' & 0x1f) & 0xfU) + 1;
        if (5 < uVar15) {
          uVar15 = 1;
        }
      }
      ChangeObjectThermal(iVar6,local_78,local_7c,local_80,uVar15);
      puVar17 = &stack0xfffffe74;
    }
    break;
  case 0x6d:
    if (Crosshair.AttachedBox.State == 0) {
      Crosshair.AttachedBox.Point1.X = Note.X;
      Crosshair.AttachedBox.State = 1;
      Crosshair.AttachedBox.Point1.Y = Note.Y;
      puVar17 = &stack0xfffffe74;
      Crosshair.AttachedBox.Point2.X = Crosshair.AttachedBox.Point1.X;
      Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedBox.Point1.Y;
      break;
    }
    puVar17 = &stack0xfffffe74;
    if ((Crosshair.AttachedBox.State < 0) ||
       (puVar17 = &stack0xfffffe74, 2 < Crosshair.AttachedBox.State)) break;
    uVar12 = Note.X - Crosshair.AttachedBox.Point1.X;
    uVar15 = Note.Y - Crosshair.AttachedBox.Point1.Y;
    uVar14 = (int)uVar15 >> 0x1f;
    uVar13 = (int)uVar12 >> 0x1f;
    if (Crosshair.AttachedBox.otherway == '\0') {
      iVar6 = (uVar14 ^ uVar15) - uVar14;
      iVar11 = (uVar13 ^ uVar12) - uVar13;
      if (iVar6 <= iVar11) goto LAB_0806a053;
LAB_080698ed:
      iVar11 = iVar6;
      if ((int)uVar12 < 0) {
        iVar6 = -iVar11;
        uVar15 = 0xffffffff;
        local_144 = (LayerTypePtr)0xb4;
      }
      else {
        uVar15 = 1;
        local_144 = (LayerTypePtr)0x0;
        iVar6 = iVar11;
      }
      Crosshair.AttachedBox.Point2.X = iVar6 + Crosshair.AttachedBox.Point1.X;
      iVar6 = -0x5a;
      if (uVar15 == (uVar14 | 1)) {
        iVar6 = 0x5a;
      }
    }
    else {
      iVar6 = (uVar14 ^ uVar15) - uVar14;
      iVar11 = (uVar13 ^ uVar12) - uVar13;
      if (iVar6 <= iVar11) goto LAB_080698ed;
LAB_0806a053:
      if ((int)uVar15 < 0) {
        iVar6 = -iVar11;
        local_144 = (LayerTypePtr)0x5a;
      }
      else {
        local_144 = (LayerTypePtr)0xffffffa6;
        iVar6 = iVar11;
      }
      Crosshair.AttachedBox.Point2.Y = iVar6 + Crosshair.AttachedBox.Point1.Y;
      iVar6 = 0x5a;
      if ((uVar13 | 1) == (uVar14 | 1)) {
        iVar6 = -0x5a;
      }
    }
    puVar17 = &stack0xfffffe74;
    if (iVar11 != 0) {
      MakeFlags(~-(uint)(((PCB->Flags).f & 0x800) == 0) & 0x20);
      if (PCB->SilkActive == '\0') {
        pLVar4 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      Flags_05.t[0] = (undefined)local_34;
      Flags_05.t[1] = local_34._1_1_;
      Flags_05.t[2] = local_34._2_1_;
      Flags_05.t[3] = local_34._3_1_;
      Flags_05.f = local_38;
      Flags_05.t[4] = (undefined)local_30;
      Flags_05.t[5] = local_30._1_1_;
      Flags_05.t[6] = local_30._2_1_;
      Flags_05.t[7] = local_30._3_1_;
      Arc = CreateNewArcOnLayer(pLVar4,Crosshair.AttachedBox.Point2.X,Crosshair.AttachedBox.Point2.Y
                                ,iVar11,iVar11,(int)local_144,iVar6,Settings.LineThickness,
                                Settings.Keepaway * 2,Flags_05);
      puVar17 = &stack0xfffffe74;
      if (Arc != (ArcTypePtr)0x0) {
        pBVar8 = GetArcEnds(Arc);
        Crosshair.AttachedBox.Point1.X = pBVar8->X2;
        Crosshair.AttachedBox.Point1.Y = pBVar8->Y2;
        if (PCB->SilkActive == '\0') {
          pLVar5 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        Crosshair.AttachedBox.Point2.X = Crosshair.AttachedBox.Point1.X;
        Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedBox.Point1.Y;
        AddObjectToCreateUndoList(0x4000,pLVar5,Arc,Arc);
        IncrementUndoSerialNumber();
        addedLines = addedLines + 1;
        if (PCB->SilkActive == '\0') {
          pLVar4 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar4 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        DrawArc(pLVar4,Arc,0);
        Draw();
        Crosshair.AttachedBox.State = 2;
        puVar17 = &stack0xfffffe74;
      }
    }
    break;
  case 0x6e:
    uVar15 = 0x5f1f;
    Note.Click = '\x01';
    (*gui->add_timer)((_func_void_hidval *)local_140,(ulong)click_cb,(hidval)0xc8);
    do {
      uVar14 = SearchScreen(Note.X,Note.Y,uVar15,&local_78,&local_7c,&local_80);
      if (((Note.Hit == 0) && ((uVar14 & 0x5c1f) != 0)) &&
         ((*(byte *)((int)&(local_7c->Flags).f + 1) & 0x20) == 0)) {
        Note.ptr2 = local_7c;
        Note.ptr1 = local_78;
        Note.ptr3 = local_80;
        Note.Hit = uVar14;
      }
      if (((Note.Moving == '\0') && ((uVar14 & 0x473f) != 0)) &&
         ((*(byte *)&(local_7c->Flags).f & 0x40) != 0)) {
        Note.Moving = '\x01';
      }
    } while (((Note.Hit == 0) || (puVar17 = &stack0xfffffe70, Note.Moving == '\0')) &&
            ((puVar17 = &stack0xfffffe70, uVar14 != 0 &&
             (uVar15 = uVar15 & ~uVar14, puVar17 = &stack0xfffffe70, uVar15 != 0))));
    break;
  case 0x6f:
    iVar6 = SearchScreen(Note.X,Note.Y,0x1441f,&local_78,&local_7c,&local_80);
    if (iVar6 == 2) {
      uVar15 = local_7c->PinN;
      (local_7c->Flags).f = (local_7c->Flags).f ^ 0x2000;
      if (uVar15 != 0) {
        paVar10 = local_7c->Pin;
        uVar14 = 0;
        (paVar10->Flags).f = ((paVar10->Flags).f ^ 0x2000) & 0xffffffbf;
        while (uVar14 = uVar14 + 1, uVar14 < uVar15) {
          paVar10[uVar14].Flags.f = (paVar10[uVar14].Flags.f ^ 0x2000) & 0xffffffbf;
        }
      }
      uVar15 = local_7c->PadN;
      iVar6 = 0;
      for (uVar14 = 0; (uVar15 != 0 && (uVar14 < uVar15)); uVar14 = uVar14 + 1) {
        *(uint *)((local_7c->Pad->Flags).t + iVar6 + -4) =
             (*(uint *)((local_7c->Pad->Flags).t + iVar6 + -4) ^ 0x2000) & 0xffffffbf;
        iVar6 = iVar6 + 0x68;
      }
      (local_7c->Flags).f = (local_7c->Flags).f & 0xffffffbf;
      DrawElement(local_7c,0);
      Draw();
      hid_actionl("Report");
      puVar17 = &stack0xfffffe74;
    }
    else {
      puVar17 = &stack0xfffffe74;
      if (iVar6 != 0) {
        uVar15 = *(uint *)((int)local_80 + 0x14) ^ 0x2000;
        *(uint *)((int)local_80 + 0x14) = uVar15;
        if ((uVar15 & 0x2040) == 0x2040) {
          *(uint *)((int)local_80 + 0x14) = uVar15 & 0xffffffbf;
          DrawObject(iVar6,local_78,local_7c,0);
          Draw();
        }
        hid_actionl("Report");
        puVar17 = &stack0xfffffe74;
      }
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    *(undefined4 *)(puVar17 + -4) = 0x806a6a2;
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

int ActionMode(int argc,char **argv,int x,int y)

{
  String Ident;
  Boolean BVar1;
  int iVar2;
  int iVar3;
  char *function;
  int saved_mode;
  BoxType box_1;
  BoxType box;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    Message("Syntax error.  Usage:\n%s\n",
            "Mode(Arc|Arrow|Copy|InsertPoint|Line|Lock|Move|None|PasteBuffer)\nMode(Polygon|Rectangle|Remove|Rotate|Text|Thermal|Via)\nMode(Notify|Release|Cancel|Stroke)\nMode(Save|Restore)"
           );
    return 1;
  }
  Note.X = Crosshair.X;
  Note.Y = Crosshair.Y;
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  iVar3 = Settings.Mode;
  switch(iVar2) {
  case 5:
switchD_0806a728_caseD_5:
    SetMode(0x6d);
    break;
  case 6:
    goto switchD_0806a728_caseD_6;
  case 9:
    SetMode(0);
    SetMode(iVar3);
    break;
  case 0x11:
    SetMode(0x69);
    break;
  case 0x1b:
    if (Settings.Mode < 7) {
      if (4 < Settings.Mode) goto LAB_0806a797;
      if (Settings.Mode == 2) {
        if (Crosshair.AttachedLine.State != 0) {
          SetMode(0);
          SetMode(2);
          break;
        }
      }
      else {
        if (Settings.Mode < 3) {
          if (Settings.Mode != 1) break;
          goto LAB_0806a797;
        }
        if (Settings.Mode == 3) {
          if (Crosshair.AttachedBox.State != 0) {
            SetMode(0);
            SetMode(3);
            break;
          }
        }
        else {
          if (Settings.Mode != 4) break;
          if (Crosshair.AttachedLine.State != 0) {
            SetMode(0);
            SetMode(4);
            break;
          }
        }
      }
    }
    else {
      if (Settings.Mode == 0x6d) {
        if (Crosshair.AttachedBox.State == 0) goto switchD_0806a728_caseD_6;
        SetMode(0);
        goto switchD_0806a728_caseD_5;
      }
      if (Settings.Mode < 0x6e) {
        if (Settings.Mode < 0x66) break;
      }
      else if (Settings.Mode != 0x6f) break;
LAB_0806a797:
      SetMode(0);
    }
switchD_0806a728_caseD_6:
    SetMode(0x6e);
    break;
  case 0x20:
    SetMode(0x6a);
    break;
  case 0x25:
switchD_0806a728_caseD_25:
    SetMode(2);
    break;
  case 0x27:
    SetMode(0x6f);
    break;
  case 0x29:
    SetMode(0x68);
    break;
  case 0x2c:
    SetMode(0);
    break;
  case 0x30:
    SetMode(5);
    break;
  case 0x35:
switchD_0806a728_caseD_35:
    SetMode(4);
    break;
  case 0x38:
switchD_0806a728_caseD_38:
    SetMode(3);
    break;
  case 0x3a:
    if (Note.Click == '\0') {
      if (Note.Moving == '\0') {
        if (Note.Hit == 0) {
          if (Settings.Mode == 0x6e) {
            box.X1 = Crosshair.AttachedBox.Point2.X;
            if (Crosshair.AttachedBox.Point1.X <= Crosshair.AttachedBox.Point2.X) {
              box.X1 = Crosshair.AttachedBox.Point1.X;
            }
            box.Y1 = Crosshair.AttachedBox.Point2.Y;
            if (Crosshair.AttachedBox.Point1.Y <= Crosshair.AttachedBox.Point2.Y) {
              box.Y1 = Crosshair.AttachedBox.Point1.Y;
            }
            box.X2 = Crosshair.AttachedBox.Point2.X;
            if (Crosshair.AttachedBox.Point2.X <= Crosshair.AttachedBox.Point1.X) {
              box.X2 = Crosshair.AttachedBox.Point1.X;
            }
            box.Y2 = Crosshair.AttachedBox.Point2.Y;
            if (Crosshair.AttachedBox.Point2.Y <= Crosshair.AttachedBox.Point1.Y) {
              box.Y2 = Crosshair.AttachedBox.Point1.Y;
            }
            RestoreUndoSerialNumber();
            BVar1 = SelectBlock(&box,'\x01');
            if (BVar1 == '\0') {
              if (Bumped != '\0') {
                IncrementUndoSerialNumber();
              }
            }
            else {
              SetChangedFlag('\x01');
            }
            Crosshair.AttachedBox.State = 0;
          }
        }
        else {
          NotifyMode();
          Note.Hit = 0;
        }
      }
      else {
        RestoreUndoSerialNumber();
        NotifyMode();
        ClearBuffer(Buffers + Settings.BufferNumber);
        SetBufferNumber(Note.Buffer);
        Note.Moving = '\0';
        Note.Hit = 0;
      }
    }
    else {
      box_1.X1 = -10000000;
      box_1.Y1 = -10000000;
      box_1.X2 = 10000000;
      box_1.Y2 = 10000000;
      Note.Click = '\0';
      SaveUndoSerialNumber();
      iVar3 = (*gui->shift_is_pressed)();
      if (iVar3 == 0) {
        BVar1 = SelectBlock(&box_1,'\0');
        if (BVar1 != '\0') {
          SetChangedFlag('\x01');
        }
        if (Note.Moving != '\0') {
          Note.Moving = '\0';
          Note.Hit = 0;
          break;
        }
      }
      RestoreUndoSerialNumber();
      BVar1 = SelectObject();
      if (BVar1 != '\0') {
        SetChangedFlag('\x01');
      }
      Note.Hit = 0;
      Note.Moving = '\0';
    }
    if (::saved_mode != '\0') {
      RestoreMode();
    }
    ::saved_mode = '\0';
    break;
  case 0x3c:
    SetMode(0x67);
    break;
  case 0x42:
    RestoreMode();
    break;
  case 0x43:
    SetMode(0x66);
    break;
  case 0x44:
    SaveMode();
    break;
  case 0x51:
    if (Settings.Mode == 2) {
      if (Crosshair.AttachedLine.State != 0) goto switchD_0806a728_caseD_25;
    }
    else if (Settings.Mode == 0x6d) {
      if (Crosshair.AttachedBox.State != 0) goto switchD_0806a728_caseD_5;
    }
    else if (Settings.Mode == 3) {
      if (Crosshair.AttachedBox.State != 0) goto switchD_0806a728_caseD_38;
    }
    else if ((Settings.Mode == 4) && (Crosshair.AttachedLine.State != 0))
    goto switchD_0806a728_caseD_35;
    SaveMode();
    ::saved_mode = '\x01';
    SetMode(0x6e);
  case 0x2d:
    NotifyMode();
    break;
  case 0x52:
    SetMode(6);
    break;
  case 0x55:
    SetMode(0x6c);
    break;
  case 0x6d:
    SetMode(1);
  }
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int ActionDelete(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  String Ident;
  char *function;
  int iVar3;
  int id;
  
  Ident = (String)0x0;
  if (0 < argc) {
    Ident = *argv;
  }
  iVar3 = GetFunctionID(Ident);
  Note.X = Crosshair.X;
  Note.Y = Crosshair.Y;
  if (iVar3 == -1) {
    BVar2 = RemoveSelected();
    if (BVar2 != '\0') {
      HideCrosshair('\x01');
      goto LAB_0806ad50;
    }
    HideCrosshair('\x01');
  }
  else {
    HideCrosshair('\x01');
    if (iVar3 != 0x2e) {
      if (iVar3 < 0x2f) {
        if (iVar3 != 3) goto LAB_0806ad50;
        cVar1 = DeleteRats('\0');
      }
      else {
        if (iVar3 == 0x46) {
          RemoveSelected();
          goto LAB_0806ad50;
        }
        if (iVar3 != 0x50) goto LAB_0806ad50;
        cVar1 = DeleteRats('\x01');
      }
      if (cVar1 != '\0') {
        SetChangedFlag('\x01');
      }
      goto LAB_0806ad50;
    }
  }
  SaveMode();
  SetMode(0x67);
  NotifyMode();
  RestoreMode();
LAB_0806ad50:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Unknown calling convention

int __r_find_neighbor_reg_in_sea(BoxType *region,void *cl)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int local_18;
  int local_14;
  
  iVar5 = *(int *)((int)cl + 0x14);
  iVar1 = region->Y2;
  local_14 = region->X2;
  iVar2 = region->Y1;
  local_18 = region->X1;
  if (iVar5 == 2) {
    iVar5 = -local_14;
    local_14 = -local_18;
    iVar4 = -iVar2;
    iVar6 = -iVar1;
    local_18 = iVar5;
  }
  else if (iVar5 == 3) {
    iVar4 = local_14;
    iVar6 = local_18;
    local_18 = -iVar1;
    local_14 = -iVar2;
  }
  else {
    iVar4 = iVar1;
    iVar6 = iVar2;
    if (iVar5 == 1) {
      iVar4 = -local_18;
      iVar6 = -local_14;
      local_18 = iVar2;
      local_14 = iVar1;
    }
  }
  if (((*(int *)((int)cl + 8) < iVar4) && (iVar5 = *(int *)((int)cl + 0x10), iVar6 < iVar5)) &&
     (*(int *)((int)cl + 4) + iVar6 < local_14 + iVar5)) {
    uVar3 = (uint)(iVar6 + local_18 < iVar5 + *(int *)((int)cl + 0xc));
  }
  else {
    uVar3 = 0;
  }
  return uVar3;
}



// WARNING: Unknown calling convention

int __r_find_neighbor_rect_in_reg(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  int r;
  int iVar3;
  int iVar4;
  int iVar5;
  int local_1c;
  int local_18;
  
  local_18 = box->X2;
  iVar1 = box->Y2;
  iVar2 = box->Y1;
  local_1c = box->X1;
  iVar5 = *(int *)((int)cl + 0x14);
  if (iVar5 == 2) {
    iVar5 = -local_1c;
    local_1c = -local_18;
    iVar3 = -iVar1;
    iVar4 = -iVar2;
    local_18 = iVar5;
  }
  else if (iVar5 == 3) {
    iVar3 = local_1c;
    iVar4 = local_18;
    local_1c = -iVar1;
    local_18 = -iVar2;
  }
  else {
    iVar3 = iVar2;
    iVar4 = iVar1;
    if (iVar5 == 1) {
      iVar3 = -local_18;
      iVar4 = -local_1c;
      local_1c = iVar2;
      local_18 = iVar1;
    }
  }
  if ((((*(int *)((int)cl + 8) < iVar4) && (iVar1 = *(int *)((int)cl + 0x10), iVar3 < iVar1)) &&
      (*(int *)((int)cl + 4) + iVar3 < local_18 + iVar1)) &&
     ((iVar3 + local_1c < *(int *)((int)cl + 0xc) + iVar1 && (iVar4 <= iVar1)))) {
    *(BoxType **)cl = box;
    r = 1;
    *(int *)((int)cl + 8) = iVar4;
  }
  else {
    r = 0;
  }
  return r;
}



// WARNING: Removing unreachable block (ram,0x0806b3bd)
// WARNING: Removing unreachable block (ram,0x0806b438)
// WARNING: Removing unreachable block (ram,0x0806b418)
// WARNING: Removing unreachable block (ram,0x0806b044)
// WARNING: Removing unreachable block (ram,0x0806b34c)
// WARNING: Removing unreachable block (ram,0x0806b458)
// WARNING: Removing unreachable block (ram,0x0806b478)
// WARNING: Removing unreachable block (ram,0x0806b270)
// WARNING: Removing unreachable block (ram,0x0806b265)
// WARNING: Removing unreachable block (ram,0x0806b272)
// WARNING: Removing unreachable block (ram,0x0806b472)
// WARNING: Removing unreachable block (ram,0x0806b47a)
// WARNING: Removing unreachable block (ram,0x0806b452)
// WARNING: Removing unreachable block (ram,0x0806b45a)
// WARNING: Removing unreachable block (ram,0x0806b352)
// WARNING: Removing unreachable block (ram,0x0806b358)
// WARNING: Removing unreachable block (ram,0x0806b048)
// WARNING: Removing unreachable block (ram,0x0806b050)
// WARNING: Removing unreachable block (ram,0x0806b414)
// WARNING: Removing unreachable block (ram,0x0806b41a)
// WARNING: Removing unreachable block (ram,0x0806b42f)
// WARNING: Removing unreachable block (ram,0x0806b43a)
// WARNING: Removing unreachable block (ram,0x0806b3c2)
// WARNING: Removing unreachable block (ram,0x0806b3c8)
// WARNING: Unknown calling convention

PerturbationType * createPerturbation(PointerListTypePtr selected,double T)

{
  void **ppvVar1;
  ElementTypePtr paVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  uint uVar6;
  long lVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  ElementTypePtr paVar12;
  int iVar13;
  uint uVar14;
  anon_enum_32 aVar15;
  int grid;
  double scaleY;
  PerturbationType *in_stack_00000004;
  uint local_38;
  double local_34;
  byte local_2c;
  
  ppvVar1 = selected->Ptr;
  uVar6 = random();
  paVar2 = (ElementTypePtr)ppvVar1[uVar6 % selected->PtrN];
  lVar7 = random();
  iVar11 = lVar7 % (int)(3 - (uint)(selected->PtrN < 2));
  if (iVar11 == 1) {
    if (paVar2->PadN == 0) {
      lVar7 = random();
      aVar15 = CONFIG_PAGE_COLUMN;
      paVar12 = (ElementTypePtr)0x0;
      iVar11 = 0;
      local_2c = (char)lVar7 + (char)(lVar7 / 3) * -3 + 1;
      iVar10 = 0;
    }
    else {
      lVar7 = random();
      aVar15 = CONFIG_PAGE_COLUMN;
      iVar10 = 0;
      paVar12 = (ElementTypePtr)0x0;
      local_2c = (byte)lVar7 & 3;
      iVar11 = 0;
    }
  }
  else if (iVar11 == 2) {
    ppvVar1 = selected->Ptr;
    uVar6 = random();
    uVar14 = selected->PtrN - 1;
    paVar12 = (ElementTypePtr)ppvVar1[uVar6 % uVar14];
    if (paVar2 == paVar12) {
      paVar12 = (ElementTypePtr)selected->Ptr[uVar14];
    }
    if (((paVar2->PinN != 0) && (*(char *)&(paVar12->Flags).f < '\0')) ||
       ((paVar12->PinN != 0 && (*(char *)&(paVar2->Flags).f < '\0')))) {
      createPerturbation(selected,T);
      return in_stack_00000004;
    }
    aVar15 = DBUS_BUS_STARTER;
    iVar10 = 0;
    iVar11 = 0;
    local_2c = 0;
  }
  else if (iVar11 == 0) {
    dVar3 = SQRT(T);
    dVar4 = (double)(PCB->MaxWidth / 3);
    dVar5 = dVar3;
    if (dVar4 <= dVar3) {
      dVar5 = dVar4;
    }
    if (250.0 <= dVar5) {
      iVar11 = PCB->MaxWidth / 3;
      local_34 = (double)iVar11;
      if (dVar3 < (double)iVar11) {
        local_34 = dVar3;
      }
    }
    else {
      local_34 = 250.0;
    }
    dVar4 = (double)(PCB->MaxHeight / 3);
    dVar5 = dVar3;
    if (dVar4 <= dVar3) {
      dVar5 = dVar4;
    }
    if (250.0 <= dVar5) {
      dVar4 = (double)(PCB->MaxHeight / 3);
      if (dVar3 < dVar4) {
        dVar4 = dVar3;
      }
    }
    else {
      dVar4 = 250.0;
    }
    iVar11 = 10;
    lVar7 = random();
    iVar10 = (int)ROUND((local_34 + local_34) * ((double)lVar7 / 2147483647.0 - 0.5));
    lVar7 = random();
    uVar6 = 1;
    iVar13 = (int)ROUND(((double)lVar7 / 2147483647.0 - 0.5) * (dVar4 + dVar4));
    if (1000.0 < (float)T) {
      iVar11 = 100;
    }
    if (iVar10 < 1) {
      uVar6 = ~-(uint)(iVar10 == 0);
    }
    local_38 = 1;
    if (iVar13 < 1) {
      local_38 = ~-(uint)(iVar13 == 0);
    }
    local_2c = 0;
    iVar9 = (paVar2->VBox).X1;
    iVar10 = (uVar6 + iVar10 / iVar11) * iVar11;
    iVar8 = -iVar9;
    if (SBORROW4(iVar10,iVar8) != iVar10 + iVar9 < 0) {
      iVar10 = iVar8;
    }
    iVar9 = PCB->MaxWidth - (paVar2->VBox).X2;
    if (iVar9 < iVar10) {
      iVar10 = iVar9;
    }
    iVar9 = (paVar2->VBox).Y1;
    iVar8 = -iVar9;
    iVar11 = (iVar13 / iVar11 + local_38) * iVar11;
    if (SBORROW4(iVar11,iVar8) != iVar11 + iVar9 < 0) {
      iVar11 = iVar8;
    }
    iVar13 = PCB->MaxHeight - (paVar2->VBox).Y2;
    if (iVar13 < iVar11) {
      iVar11 = iVar13;
    }
    aVar15 = CONFIG_NAME_COLUMN;
    paVar12 = (ElementTypePtr)0x0;
  }
  else {
    aVar15 = CONFIG_NAME_COLUMN;
    iVar10 = 0;
    iVar11 = 0;
    paVar12 = (ElementTypePtr)0x0;
    local_2c = 0;
  }
  in_stack_00000004->other = paVar12;
  in_stack_00000004->DY = iVar11;
  in_stack_00000004->DX = iVar10;
  in_stack_00000004->which = aVar15;
  in_stack_00000004->rotate = local_2c;
  in_stack_00000004->element = paVar2;
  return in_stack_00000004;
}



// WARNING: Removing unreachable block (ram,0x0806c420)
// WARNING: Removing unreachable block (ram,0x0806c41b)
// WARNING: Removing unreachable block (ram,0x0806c422)
// WARNING: Unknown calling convention

double ComputeCost(NetListTypePtr Nets,double T0,double T)

{
  Cardinal *pCVar1;
  LocationType *pLVar2;
  ElementTypePtr paVar3;
  undefined4 uVar4;
  direction_t dVar5;
  char *__s1;
  Cardinal CVar6;
  double dVar7;
  BoxListTypePtr Boxes;
  bool bVar8;
  bool bVar9;
  int iVar10;
  int iVar11;
  ConnectionTypePtr c;
  NetTypePtr paVar12;
  NetTypePtr n;
  ConnectionTypePtr paVar13;
  BoxTypePtr pBVar14;
  BoxTypePtr box;
  BoxListTypePtr thisside;
  BoxListTypePtr Boxes_00;
  BoxTypePtr box_1;
  Cardinal sn_2;
  BoxTypePtr pBVar15;
  DataTypePtr paVar16;
  PointerListTypePtr list;
  void **ppvVar17;
  undefined4 *puVar18;
  rtree_t *rt_s;
  rtree_t *rt_c;
  BoxType *pBVar19;
  bool bVar20;
  Cardinal j;
  Cardinal n_1;
  int factor;
  LocationType t;
  LocationType LVar21;
  LocationType maxY;
  bool bVar22;
  Cardinal sn_1;
  Cardinal sn;
  int iVar23;
  PinTypePtr pin;
  PadTypePtr pad;
  ebox *boxp;
  LocationType LVar24;
  LocationType minY;
  Cardinal SLayer;
  int iVar25;
  LocationType minx;
  int iVar26;
  PinTypePtr pin_1;
  int iVar27;
  uint uVar28;
  ElementTypePtr element_2;
  uchar *puVar29;
  ElementTypePtr element_1;
  Cardinal n_4;
  Cardinal j_1;
  uint uVar30;
  LocationType maxy;
  ElementTypePtr element;
  int iVar31;
  int iVar32;
  uint uVar33;
  Cardinal n_3;
  LocationType LVar34;
  LocationType minX;
  LocationType miny;
  Cardinal n_2;
  int iVar35;
  LocationType LVar36;
  LocationType maxX;
  double delta1;
  double delta5;
  double delta2;
  double dVar37;
  double dVar38;
  double dVar39;
  double local_f4;
  double local_ec;
  BoxListTypePtr local_e0;
  BoxListTypePtr local_dc;
  int local_d4;
  int local_d0;
  uint local_cc;
  uint local_c8;
  int local_b8;
  double local_b4;
  rtree_t *local_a8;
  uint local_a4;
  int local_a0;
  int local_9c;
  r_neighbor_info ni;
  direction_t dir [4];
  PointerListType ceboxes;
  PointerListType seboxes;
  BoxListType componentside;
  BoxListType solderside;
  BoxListType bounds;
  rtree_t *local_24;
  rtree_t *local_20 [4];
  
  bounds.BoxN = 0;
  bounds.BoxMax = 0;
  solderside.BoxN = 0;
  solderside.BoxMax = 0;
  componentside.BoxN = 0;
  componentside.BoxMax = 0;
  bounds.Box = (BoxTypePtr)0x0;
  solderside.Box = (BoxTypePtr)0x0;
  componentside.Box = (BoxTypePtr)0x0;
  iVar10 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar11 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  local_a4 = 0;
  if (Nets->NetN == 0) {
LAB_0806c42f:
    local_ec = 0.0;
  }
  else {
    do {
      iVar25 = 0;
      uVar30 = 0;
      paVar12 = Nets->Net + local_a4;
      if (paVar12->ConnectionN != 0) {
        do {
          puVar18 = (undefined4 *)((int)&paVar12->Connection->X + iVar25);
          if (puVar18[2] == 0x100) {
            puVar18[5] = iVar10;
            *puVar18 = *(undefined4 *)(puVar18[4] + 0x34);
            puVar18[1] = *(undefined4 *)(puVar18[4] + 0x38);
          }
          else if (puVar18[2] == 0x200) {
            iVar35 = iVar11;
            if (*(char *)(puVar18[3] + 0x14) < '\0') {
              iVar35 = iVar10;
            }
            puVar18[5] = iVar35;
            *puVar18 = *(undefined4 *)(puVar18[4] + 0x2c);
            puVar18[1] = *(undefined4 *)(puVar18[4] + 0x30);
          }
          else {
            Message("Odd connection type encountered in UpdateXY");
          }
          uVar30 = uVar30 + 1;
          iVar25 = iVar25 + 0x1c;
          paVar12 = Nets->Net + local_a4;
        } while (uVar30 < paVar12->ConnectionN);
      }
      local_a4 = local_a4 + 1;
    } while (local_a4 < Nets->NetN);
    if (Nets->NetN == 0) goto LAB_0806c42f;
    local_c8 = 0;
    local_ec = 0.0;
    do {
      uVar30 = Nets->Net[local_c8].ConnectionN;
      if (1 < uVar30) {
        paVar13 = Nets->Net[local_c8].Connection;
        local_cc = 1;
        pCVar1 = &paVar13->group;
        iVar10 = paVar13->X;
        LVar34 = paVar13->Y;
        iVar25 = LVar34;
        iVar11 = iVar10;
        bVar8 = true;
        bVar9 = paVar13->type == 0x200;
        do {
          iVar35 = paVar13[1].X;
          if (iVar35 < iVar10) {
            iVar10 = iVar35;
          }
          if (iVar35 <= iVar11) {
            iVar35 = iVar11;
          }
          iVar11 = paVar13[1].Y;
          if (iVar11 < iVar25) {
            iVar25 = iVar11;
          }
          if (LVar34 < iVar11) {
            LVar34 = iVar11;
          }
          bVar22 = false;
          if (paVar13[1].type == 0x200) {
            bVar22 = bVar9;
          }
          bVar20 = false;
          if (paVar13[1].group == *pCVar1) {
            bVar20 = bVar8;
          }
          paVar13 = paVar13 + 1;
          local_cc = local_cc + 1;
          iVar11 = iVar35;
          bVar8 = bVar20;
          bVar9 = bVar22;
        } while (local_cc != uVar30);
        pBVar14 = GetBoxMemory(&bounds);
        pBVar14->X1 = iVar10;
        pBVar14->Y1 = iVar25;
        pBVar14->X2 = iVar35;
        pBVar14->Y2 = LVar34;
        if ((bVar20) || (!bVar22)) {
          dVar37 = 0.0;
        }
        else {
          dVar37 = 3000.0;
        }
        local_ec = local_ec + (double)((LVar34 - iVar25) / 100 + (iVar35 - iVar10) / 100) + dVar37;
      }
      local_c8 = local_c8 + 1;
    } while (local_c8 <= Nets->NetN && Nets->NetN != local_c8);
  }
  dVar37 = ComputeIntersectionArea(&bounds);
  FreeBoxListMemory(&bounds);
  paVar16 = PCB->Data;
  local_d0 = paVar16->ElementN - 1;
  if (local_d0 != -1) {
    local_f4 = 0.0;
    iVar10 = paVar16->ElementN * 300;
    do {
      local_d4 = iVar10 + -300;
      paVar3 = paVar16->Element;
      Boxes_00 = &componentside;
      Boxes = &solderside;
      if ((*(uint *)(paVar3[-1].Flags.t + iVar10 + -4) & 0x80) != 0) {
        Boxes_00 = &solderside;
        Boxes = &componentside;
      }
      pBVar14 = GetBoxMemory(Boxes_00);
      if ((*(int *)((int)&paVar3[-1].PinN + iVar10) != 0) ||
         (*(int *)((int)&paVar3[-1].PadN + iVar10) != 0)) {
        pBVar14->X1 = 10000000;
        pBVar14->Y1 = 10000000;
        pBVar14->X2 = -10000000;
        pBVar14->Y2 = -10000000;
        local_b4._0_4_ = *(uint *)((int)&paVar3[-1].PinN + iVar10);
        if (local_b4._0_4_ != 0) {
          iVar11 = *(int *)((int)&paVar3[-1].Pin + iVar10);
          uVar30 = 0;
          iVar35 = -10000000;
          local_a0 = 10000000;
          local_a4 = -10000000;
          iVar25 = 10000000;
          do {
            iVar23 = uVar30 * 0x4c + iVar11;
            iVar26 = *(int *)(iVar23 + 0x24) / 2 + *(int *)(iVar23 + 0x28) * 2;
            iVar31 = *(int *)(iVar23 + 0x34) - iVar26;
            if (iVar25 <= iVar31) {
              iVar31 = iVar25;
            }
            pBVar14->X1 = iVar31;
            iVar25 = *(int *)(iVar23 + 0x38) - iVar26;
            if (local_a0 < iVar25) {
              iVar25 = local_a0;
            }
            pBVar14->Y1 = iVar25;
            iVar32 = *(int *)(iVar23 + 0x34) + iVar26;
            if (iVar32 < (int)local_a4) {
              iVar32 = local_a4;
            }
            pBVar14->X2 = iVar32;
            iVar26 = iVar26 + *(int *)(iVar23 + 0x38);
            if (iVar35 <= iVar26) {
              iVar35 = iVar26;
            }
            pBVar14->Y2 = iVar35;
            uVar33 = *(uint *)((int)&paVar3[-1].PinN + iVar10);
          } while ((uVar33 != 0) &&
                  (uVar30 = (uVar33 + 1 + uVar30) - local_b4._0_4_, local_a4 = iVar32,
                  local_a0 = iVar25, local_b4._0_4_ = uVar33, iVar25 = iVar31, uVar30 < uVar33));
        }
        uVar33 = *(uint *)((int)&paVar3[-1].PadN + iVar10);
        local_a0 = 0;
        uVar30 = 0;
        uVar28 = uVar33;
        while ((uVar28 != 0 && (uVar30 < uVar28))) {
          pad = (PadTypePtr)(local_a0 + *(int *)((int)&paVar3[-1].Pad + iVar10));
          iVar11 = pad->Thickness / 2 + pad->Clearance * 2;
          iVar25 = (pad->Point2).X;
          if ((pad->Point1).X == iVar25 || (pad->Point1).X < iVar25) {
            iVar25 = (pad->Point1).X;
          }
          iVar35 = iVar25 - iVar11;
          if (pBVar14->X1 < iVar25 - iVar11) {
            iVar35 = pBVar14->X1;
          }
          pBVar14->X1 = iVar35;
          iVar25 = (pad->Point2).Y;
          pLVar2 = &(pad->Point1).Y;
          if (*pLVar2 == iVar25 || *pLVar2 < iVar25) {
            iVar25 = (pad->Point1).Y;
          }
          iVar35 = iVar25 - iVar11;
          if (pBVar14->Y1 < iVar25 - iVar11) {
            iVar35 = pBVar14->Y1;
          }
          pBVar14->Y1 = iVar35;
          iVar25 = (pad->Point2).X;
          if (iVar25 <= (pad->Point1).X) {
            iVar25 = (pad->Point1).X;
          }
          iVar35 = pBVar14->X2;
          if (pBVar14->X2 <= iVar11 + iVar25) {
            iVar35 = iVar11 + iVar25;
          }
          pBVar14->X2 = iVar35;
          iVar25 = (pad->Point2).Y;
          if (iVar25 <= (pad->Point1).Y) {
            iVar25 = (pad->Point1).Y;
          }
          iVar35 = iVar11 + iVar25;
          if (iVar11 + iVar25 < pBVar14->Y2) {
            iVar35 = pBVar14->Y2;
          }
          pBVar14->Y2 = iVar35;
          uVar28 = *(uint *)((int)&paVar3[-1].PadN + iVar10);
          if (uVar28 == uVar33) {
            uVar30 = uVar30 + 1;
            local_a0 = local_a0 + 0x68;
            uVar28 = uVar33;
          }
        }
        local_b4._0_4_ = *(uint *)((int)&paVar3[-1].PinN + iVar10);
        if (local_b4._0_4_ != 0) {
          uVar30 = 0;
          pBVar14 = (BoxTypePtr)0x0;
          do {
            iVar26 = uVar30 * 0x4c + *(int *)((int)&paVar3[-1].Pin + iVar10);
            pBVar15 = GetBoxMemory(Boxes);
            iVar11 = *(int *)(iVar26 + 0x28);
            iVar35 = *(int *)(iVar26 + 0x24) / 2;
            iVar25 = *(int *)(iVar26 + 0x34) - iVar35;
            pBVar15->X1 = iVar25;
            iVar31 = *(int *)(iVar26 + 0x38) - iVar35;
            pBVar15->Y1 = iVar31;
            iVar23 = *(int *)(iVar26 + 0x34) + iVar35;
            pBVar15->X2 = iVar23;
            iVar35 = iVar35 + *(int *)(iVar26 + 0x38);
            pBVar15->Y2 = iVar35;
            if (pBVar14 != (BoxTypePtr)0x0) {
              iVar26 = pBVar14->X1;
              iVar11 = iVar11 * 2;
              if (iVar25 == iVar26) {
                if (iVar23 != pBVar14->X2) {
                  local_a8 = (rtree_t *)pBVar14->Y1;
                  if ((rtree_t *)iVar31 != local_a8) goto LAB_0806bb6f;
                  goto LAB_0806bc59;
                }
                local_a8 = (rtree_t *)pBVar14->Y1;
                uVar33 = (int)local_a8 - iVar35 >> 0x1f;
                iVar27 = ((int)local_a8 - iVar35 ^ uVar33) - uVar33;
                uVar33 = iVar31 - pBVar14->Y2;
                uVar28 = (int)uVar33 >> 0x1f;
                iVar32 = (uVar33 ^ uVar28) - uVar28;
                if (iVar27 <= iVar32) {
                  iVar32 = iVar27;
                }
                if (iVar11 <= iVar32) goto LAB_0806bb57;
LAB_0806bcc4:
                if (iVar26 < iVar25) {
                  iVar25 = iVar26;
                }
                pBVar14->X1 = iVar25;
                if (iVar31 <= (int)local_a8) {
                  local_a8 = (rtree_t *)iVar31;
                }
                iVar11 = pBVar14->X2;
                if (pBVar14->X2 <= iVar23) {
                  iVar11 = iVar23;
                }
                pBVar14->Y1 = (LocationType)local_a8;
                pBVar14->X2 = iVar11;
                if (iVar35 < pBVar14->Y2) {
                  iVar35 = pBVar14->Y2;
                }
                pBVar14->Y2 = iVar35;
                Boxes->BoxN = Boxes->BoxN - 1;
                pBVar15 = pBVar14;
              }
              else {
                local_a8 = (rtree_t *)pBVar14->Y1;
LAB_0806bb57:
                if ((rtree_t *)iVar31 == local_a8) {
LAB_0806bc59:
                  if (iVar35 == pBVar14->Y2) {
                    uVar33 = iVar26 - iVar23 >> 0x1f;
                    iVar27 = (iVar26 - iVar23 ^ uVar33) - uVar33;
                    uVar33 = iVar25 - pBVar14->X2;
                    uVar28 = (int)uVar33 >> 0x1f;
                    iVar32 = (uVar33 ^ uVar28) - uVar28;
                    if (iVar27 <= iVar32) {
                      iVar32 = iVar27;
                    }
                    if (iVar32 < iVar11) goto LAB_0806bcc4;
                  }
                }
              }
            }
LAB_0806bb6f:
            uVar33 = *(uint *)((int)&paVar3[-1].PinN + iVar10);
          } while ((uVar33 != 0) &&
                  (uVar30 = (uVar33 + 1 + uVar30) - local_b4._0_4_, local_b4._0_4_ = uVar33,
                  pBVar14 = pBVar15, uVar30 < uVar33));
        }
        if ((*(int *)((int)&paVar3[-1].VBox.X1 + iVar10) < 0) ||
           (((*(int *)((int)&paVar3[-1].VBox.Y1 + iVar10) < 0 ||
             (PCB->MaxWidth < *(int *)((int)&paVar3[-1].VBox.X2 + iVar10))) ||
            (PCB->MaxHeight < *(int *)((int)&paVar3[-1].VBox.Y2 + iVar10))))) {
          local_f4 = local_f4 + 1000.0;
        }
      }
      local_d0 = local_d0 + -1;
      if (local_d0 == -1) goto LAB_0806bda2;
      paVar16 = PCB->Data;
      iVar10 = local_d4;
    } while( true );
  }
  local_f4 = 0.0;
LAB_0806bda2:
  local_dc = &componentside;
  local_e0 = &solderside;
  dVar38 = ComputeIntersectionArea(local_e0);
  dVar39 = ComputeIntersectionArea(local_dc);
  FreeBoxListMemory(local_e0);
  FreeBoxListMemory(local_dc);
  seboxes.PtrN = 0;
  seboxes.PtrMax = 0;
  ceboxes.PtrN = 0;
  paVar16 = PCB->Data;
  ceboxes.PtrMax = 0;
  seboxes.Ptr = (void **)0x0;
  ceboxes.Ptr = (void **)0x0;
  dir[0] = NORTH;
  dir[1] = EAST;
  dir[2] = SOUTH;
  iVar10 = paVar16->ElementN - 1;
  dir[3] = WEST;
  if (iVar10 != -1) {
    iVar11 = paVar16->ElementN * 300;
    while( true ) {
      puVar29 = paVar16->Element[-1].Flags.t + iVar11 + -0x18;
      list = &ceboxes;
      if ((char)puVar29[0x14] < '\0') {
        list = &seboxes;
      }
      ppvVar17 = GetPointerMemory(list);
      puVar18 = (undefined4 *)calloc(1,0x14);
      *ppvVar17 = puVar18;
      if (puVar18 == (undefined4 *)0x0) {
        __fprintf_chk(stderr,1,"malloc() failed in %s\n","ComputeCost");
                    // WARNING: Subroutine does not return
        exit(1);
      }
      uVar4 = *(undefined4 *)(puVar29 + 0x110);
      iVar10 = iVar10 + -1;
      puVar18[4] = puVar29;
      *puVar18 = uVar4;
      puVar18[1] = *(undefined4 *)(puVar29 + 0x114);
      puVar18[2] = *(undefined4 *)(puVar29 + 0x118);
      puVar18[3] = *(undefined4 *)(puVar29 + 0x11c);
      if (iVar10 == -1) break;
      paVar16 = PCB->Data;
      iVar11 = iVar11 + -300;
    }
  }
  local_20[0] = r_create_tree((BoxType **)seboxes.Ptr,seboxes.PtrN,1);
  local_24 = r_create_tree((BoxType **)ceboxes.Ptr,ceboxes.PtrN,1);
  FreePointerListMemory(&seboxes);
  FreePointerListMemory(&ceboxes);
  local_b8 = 0;
  local_b4 = 0.0;
  do {
    paVar16 = PCB->Data;
    local_a0 = paVar16->ElementN - 1;
    if (local_a0 != -1) {
      dVar5 = dir[local_b8];
      iVar10 = paVar16->ElementN * 300;
      do {
        local_a4 = iVar10 + -300;
        paVar3 = paVar16->Element;
        if ((char)paVar3[-1].Flags.t[iVar10 + -4] < '\0') {
          local_a8 = local_20[0];
        }
        else {
          local_a8 = local_24;
        }
        iVar11 = *(int *)((int)&paVar3[-1].VBox.X1 + iVar10);
        ni.neighbor = (BoxType *)0x0;
        iVar25 = *(int *)((int)&paVar3[-1].VBox.Y1 + iVar10);
        iVar35 = *(int *)((int)&paVar3[-1].VBox.X2 + iVar10);
        iVar26 = *(int *)((int)&paVar3[-1].VBox.Y2 + iVar10);
        if (dVar5 == EAST) {
          ni.trap.Y1 = -PCB->MaxWidth;
LAB_0806c1f8:
          ni.trap.Y2 = -iVar35;
          ni.trap.X1 = iVar25;
          ni.trap.X2 = iVar26;
        }
        else if (dVar5 == SOUTH) {
          ni.trap.X2 = -iVar11;
          ni.trap.Y1 = -PCB->MaxHeight;
          ni.trap.Y2 = -iVar26;
          ni.trap.X1 = -iVar35;
        }
        else if (dVar5 == WEST) {
          ni.trap.X1 = -iVar26;
          ni.trap.X2 = -iVar25;
          ni.trap.Y1 = 0;
          ni.trap.Y2 = iVar11;
        }
        else {
          ni.trap.Y1 = 0;
          ni.trap.Y2 = iVar25;
          ni.trap.X1 = iVar11;
          ni.trap.X2 = iVar35;
          if (dVar5 == EAST) goto LAB_0806c1f8;
        }
        ni.search_dir = dVar5;
        r_search(local_a8,(BoxType *)0x0,__r_find_neighbor_reg_in_sea,__r_find_neighbor_rect_in_reg,
                 &ni);
        if (ni.neighbor != (BoxType *)0x0) {
          __s1 = *(char **)((int)(&paVar3[-1].Name[0].Flags + 2) + iVar10 + 8);
          if (__s1 == (char *)0x0) {
            iVar11 = ni.neighbor[1].X1;
            iVar25 = 1;
LAB_0806c0c0:
            if (*(char *)((int)(&paVar3[-1].Name[0].Flags + 2) + iVar10 + 4) ==
                *(char *)(iVar11 + 0x54)) {
LAB_0806c1b2:
              local_b4 = (double)iVar25 + local_b4;
            }
          }
          else {
            iVar11 = ni.neighbor[1].X1;
            if ((*(char **)(iVar11 + 0x58) != (char *)0x0) &&
               (iVar25 = strcmp(__s1,*(char **)(iVar11 + 0x58)), iVar25 == 0)) {
              iVar25 = 2;
              local_b4 = local_b4 + 1.0;
              goto LAB_0806c0c0;
            }
            iVar25 = 1;
            if (*(char *)((int)(&paVar3[-1].Name[0].Flags + 2) + iVar10 + 4) ==
                *(char *)(iVar11 + 0x54)) goto LAB_0806c1b2;
          }
          iVar35 = *(int *)((int)&paVar3[-1].VBox.X1 + iVar10);
          if (((iVar35 != *(int *)(iVar11 + 0x110)) && (iVar35 != *(int *)(iVar11 + 0x118))) &&
             ((iVar35 = *(int *)((int)&paVar3[-1].VBox.X2 + iVar10),
              *(int *)(iVar11 + 0x110) != iVar35 && (*(int *)(iVar11 + 0x118) != iVar35)))) {
            iVar35 = *(int *)((int)&paVar3[-1].VBox.Y1 + iVar10);
            if ((((iVar35 != *(int *)(iVar11 + 0x114)) && (iVar35 != *(int *)(iVar11 + 0x11c))) &&
                (iVar10 = *(int *)((int)&paVar3[-1].VBox.Y2 + iVar10),
                *(int *)(iVar11 + 0x114) != iVar10)) && (*(int *)(iVar11 + 0x11c) != iVar10))
            goto LAB_0806c130;
          }
          local_b4 = (double)iVar25 + local_b4;
        }
LAB_0806c130:
        local_a0 = local_a0 + -1;
        if (local_a0 == -1) break;
        paVar16 = PCB->Data;
        iVar10 = local_a4;
      } while( true );
    }
    local_b8 = local_b8 + 1;
  } while (local_b8 != 4);
  r_destroy_tree(local_20);
  r_destroy_tree(&local_24);
  CVar6 = PCB->Data->ElementN;
  local_9c = CVar6 - 1;
  if (local_9c != -1) {
    LVar21 = -10000000;
    LVar36 = -10000000;
    LVar24 = 10000000;
    LVar34 = 10000000;
    pBVar19 = &PCB->Data->Element[CVar6 - 1].VBox;
    do {
      if (pBVar19->X1 < LVar34) {
        LVar34 = pBVar19->X1;
      }
      if (pBVar19->Y1 < LVar24) {
        LVar24 = pBVar19->Y1;
      }
      if (LVar36 < pBVar19->X2) {
        LVar36 = pBVar19->X2;
      }
      if (LVar21 < pBVar19->Y2) {
        LVar21 = pBVar19->Y2;
      }
      pBVar19 = (BoxType *)((int)(pBVar19 + -0x13) + 4);
      local_9c = local_9c + -1;
    } while (local_9c != -1);
    if ((LVar24 < LVar21) && (LVar34 < LVar36)) {
      dVar7 = SQRT((double)(LVar21 - LVar24) * (double)(LVar36 - LVar34) * 0.0001);
      goto LAB_0806c2d5;
    }
  }
  dVar7 = 0.0;
LAB_0806c2d5:
  dVar37 = SQRT(ABS(dVar37)) * 0.01999999955296516;
  dVar38 = ((1.0 - T / T0) * 100.0 + 0.009999999776482582) * SQRT(ABS(dVar39 + dVar38));
  if ((float)T == 5.0) {
    dVar39 = ((local_ec + dVar37 + dVar38 + local_f4) - local_b4) + dVar7;
    __printf_chk(1,"cost components are %.3f %.3f %.3f %.3f %.3f %.3f\n",local_ec / dVar39,
                 dVar37 / dVar39,dVar38 / dVar39,local_f4 / dVar39,-local_b4 / dVar39,dVar7 / dVar39
                );
  }
  return ((dVar38 + dVar37 + local_f4) - local_b4) + dVar7 + local_ec;
}



// WARNING: Unknown calling convention

void doPerturb(PerturbationType *pt,Boolean undo)

{
  anon_enum_32 aVar1;
  int iVar2;
  int iVar3;
  BYTE b;
  ElementTypePtr Element;
  byte Number;
  LocationType DX;
  int iVar4;
  LocationType DY;
  int iVar5;
  PerturbationType mypt;
  
  Element = pt->element;
  iVar4 = (Element->VBox).X1;
  iVar5 = (Element->VBox).Y1;
  aVar1 = pt->which;
  if (aVar1 == CONFIG_PAGE_COLUMN) {
    Number = pt->rotate;
    if (undo != '\0') {
      Number = -Number & 3;
    }
    if (Number != 0) {
      RotateElementLowLevel
                (PCB->Data,Element,(iVar4 + (Element->VBox).X2) / 2,(iVar5 + (Element->VBox).Y2) / 2
                 ,Number);
      return;
    }
    MirrorElementCoordinates(PCB->Data,Element,0);
    Element = pt->element;
    iVar5 = iVar5 - (Element->VBox).Y1;
    iVar4 = 0;
  }
  else {
    if (aVar1 != CONFIG_NAME_COLUMN) {
      if (aVar1 != DBUS_BUS_STARTER) {
        return;
      }
      iVar2 = (pt->other->BoundingBox).X1;
      iVar3 = (pt->other->BoundingBox).Y1;
      MoveElementLowLevel(PCB->Data,Element,iVar2 - iVar4,iVar3 - iVar5);
      MoveElementLowLevel(PCB->Data,pt->other,iVar4 - iVar2,iVar5 - iVar3);
      mypt.element = pt->element;
      if (((((mypt.element)->Flags).f ^ (pt->other->Flags).f) & 0x80) == 0) {
        return;
      }
      mypt.which = CONFIG_PAGE_COLUMN;
      mypt.rotate = '\0';
      doPerturb(&mypt,undo);
      mypt.element = pt->other;
      doPerturb(&mypt,undo);
      return;
    }
    iVar4 = pt->DX;
    iVar5 = pt->DY;
    if (undo != '\0') {
      iVar4 = -iVar4;
      iVar5 = -iVar5;
    }
  }
  MoveElementLowLevel(PCB->Data,Element,iVar4,iVar5);
  return;
}



// WARNING: Unknown calling convention

Boolean AutoPlaceSelected(void)

{
  float fVar1;
  double __x;
  ulonglong uVar2;
  Boolean changed;
  NetListTypePtr Nets_00;
  DataTypePtr paVar3;
  uchar **ppuVar4;
  long lVar5;
  Boolean BVar6;
  Cardinal n;
  int iVar7;
  int i;
  int moves;
  NetListTypePtr Nets;
  int good_moves;
  int iVar8;
  ElementTypePtr element;
  uchar *puVar9;
  double Cprime;
  double dVar10;
  double dVar11;
  double dVar12;
  PointerListTypePtr local_a8;
  int local_98;
  double local_94;
  double local_8c;
  PerturbationType pt;
  PointerListType list;
  PointerListType Selected;
  
  Selected.PtrN = 0;
  Selected.PtrMax = 0;
  Selected.Ptr = (void **)0x0;
  Nets_00 = ProcNetlist(&PCB->NetlistLib);
  if (Nets_00 == (NetListTypePtr)0x0) {
    Message("Can\'t add rat lines because no netlist is loaded.\n");
  }
  else {
    list.PtrN = 0;
    list.PtrMax = 0;
    list.Ptr = (void **)0x0;
    paVar3 = PCB->Data;
    iVar7 = paVar3->ElementN - 1;
    if (iVar7 == -1) {
      Selected.Ptr = (void **)0x0;
      Selected.PtrMax = 0;
      Selected.PtrN = 0;
    }
    else {
      iVar8 = paVar3->ElementN * 300;
      while( true ) {
        puVar9 = paVar3->Element[-1].Flags.t + iVar8 + -0x18;
        if ((puVar9[0x14] & 0x40) != 0) {
          ppuVar4 = (uchar **)GetPointerMemory(&list);
          *ppuVar4 = puVar9;
        }
        if (iVar7 == 0) break;
        iVar7 = iVar7 + -1;
        paVar3 = PCB->Data;
        iVar8 = iVar8 + -300;
      }
      Selected.PtrN = list.PtrN;
      Selected.PtrMax = list.PtrMax;
      Selected.Ptr = list.Ptr;
      if (list.PtrN != 0) {
        iVar7 = 0;
        dVar10 = ComputeCost(Nets_00,300000.0,300000.0);
        local_8c = 0.0;
        do {
          iVar7 = iVar7 + 1;
          createPerturbation(&Selected,1000000.0);
          doPerturb(&pt,'\0');
          dVar11 = ComputeCost(Nets_00,300000.0,300000.0);
          local_8c = ABS(dVar11 - dVar10) + local_8c;
          doPerturb(&pt,'\x01');
        } while (iVar7 != 10);
        iVar7 = 0;
        dVar10 = (local_8c / -10.0) / -0.05129329438755058;
        __printf_chk(1,"Initial T: %f\n",dVar10);
        uVar2 = (ulonglong)Selected.PtrN;
        dVar11 = ComputeCost(Nets_00,dVar10,5.0);
        __printf_chk(1,"Starting cost is %.0f\n",dVar11);
        local_94 = ComputeCost(Nets_00,dVar10,dVar10);
        local_98 = 0;
        iVar8 = 0;
        local_8c = dVar10;
        while( true ) {
          do {
            createPerturbation(&Selected,local_8c);
            doPerturb(&pt,'\0');
            dVar11 = ComputeCost(Nets_00,dVar10,local_8c);
            if (local_94 <= dVar11) {
              lVar5 = random();
              dVar12 = (local_94 - dVar11) / local_8c;
              __x = -20.0;
              if ((-20.0 <= dVar12) && (__x = 20.0, dVar12 <= 20.0 || dVar12 != 20.0)) {
                __x = dVar12;
              }
              dVar12 = exp(__x);
              if (dVar12 <= (double)lVar5 / 2147483647.0) {
                doPerturb(&pt,'\x01');
              }
              else {
                local_98 = local_98 + 1;
                local_94 = dVar11;
              }
            }
            else {
              local_98 = local_98 + 1;
              iVar8 = iVar8 + 1;
              local_94 = dVar11;
            }
            iVar7 = iVar7 + 1;
          } while ((iVar8 < (int)ROUND((float)uVar2 * 20.0)) &&
                  (iVar7 < (int)ROUND((float)uVar2 * 20.0) * 2));
          __printf_chk(1,"END OF STAGE: COST %.0f\tGOOD_MOVES %d\tMOVES %d\tT: %.1f\n",local_94,
                       iVar8,iVar7,local_8c);
          if (((float)local_8c < 5.0) || (iVar8 < iVar7 / 0x28)) break;
          fVar1 = (float)local_8c * 0.75;
          iVar7 = 0;
          iVar8 = 0;
          local_8c = (double)fVar1;
          local_94 = ComputeCost(Nets_00,dVar10,(double)fVar1);
        }
        BVar6 = '\0';
        if (0 < local_98) {
          BVar6 = '\x01';
          DeleteRats('\0');
          AddAllRats('\0',(_func_void_varargs *)0x0);
          ClearAndRedrawOutput();
        }
        goto LAB_0806ca47;
      }
    }
    list.PtrN = Selected.PtrN;
    list.PtrMax = Selected.PtrMax;
    list.Ptr = Selected.Ptr;
    Message("No elements selected to autoplace.\n");
  }
  BVar6 = '\0';
LAB_0806ca47:
  local_a8 = &Selected;
  FreePointerListMemory(local_a8);
  return BVar6;
}



// WARNING: Unknown calling convention

void InitLists(routebox_t *r)

{
  int iVar1;
  int iVar2;
  routebox_list *prVar3;
  routebox_list *rl;
  
  iVar2 = 0;
  do {
    iVar1 = *(int *)((int)InitLists::all + iVar2);
    prVar3 = &r->original_subnet;
    if (((iVar1 != 2) && (prVar3 = &r->different_net, iVar1 != 3)) &&
       (prVar3 = &r->same_net, iVar1 == 1)) {
      prVar3 = &r->same_subnet;
    }
    iVar2 = iVar2 + 4;
    prVar3->next = r;
    prVar3->prev = r;
  } while (iVar2 != 0x10);
  InitLists::p = (boxlist *)&RD_DrawLine::qX1;
  return;
}



// WARNING: Unknown calling convention

void MergeNets(routebox_t *a,routebox_t *b,boxlist which)

{
  routebox_list *bnl;
  routebox_list *prVar1;
  routebox_t *bn;
  routebox *prVar2;
  routebox_t *an;
  routebox *prVar3;
  routebox_list *local_1c;
  routebox_list *local_18;
  routebox_list *local_14;
  
  if (which == ORIGINAL) {
    local_1c = &a->original_subnet;
LAB_0806ccae:
    local_18 = &b->original_subnet;
    prVar3 = local_1c->next;
    prVar2 = (b->original_subnet).next;
LAB_0806ccbc:
    local_14 = &prVar3->original_subnet;
  }
  else {
    if (which == DIFFERENT_NET) {
      local_1c = &a->different_net;
LAB_0806ccce:
      local_18 = &b->different_net;
      prVar2 = (b->different_net).next;
      prVar3 = local_1c->next;
LAB_0806ccdc:
      local_14 = &prVar3->different_net;
LAB_0806cce2:
      prVar1 = &prVar2->different_net;
      goto LAB_0806cc85;
    }
    if (which == SUBNET) {
      local_1c = &a->same_subnet;
LAB_0806cc6e:
      local_18 = &b->same_subnet;
      prVar2 = (b->same_subnet).next;
      prVar3 = local_1c->next;
LAB_0806cc7c:
      local_14 = &prVar3->same_subnet;
LAB_0806cc82:
      prVar1 = &prVar2->same_subnet;
      goto LAB_0806cc85;
    }
    local_1c = &a->same_net;
    if (which == ORIGINAL) goto LAB_0806ccae;
    if (which == DIFFERENT_NET) goto LAB_0806ccce;
    if (which == SUBNET) goto LAB_0806cc6e;
    local_18 = &b->same_net;
    prVar3 = (a->same_net).next;
    prVar2 = (b->same_net).next;
    if (which == ORIGINAL) goto LAB_0806ccbc;
    if (which == DIFFERENT_NET) goto LAB_0806ccdc;
    if (which == SUBNET) goto LAB_0806cc7c;
    local_14 = &prVar3->same_net;
    if (which != ORIGINAL) {
      if (which != DIFFERENT_NET) {
        if (which != SUBNET) {
          prVar1 = &prVar2->same_net;
          goto LAB_0806cc85;
        }
        goto LAB_0806cc82;
      }
      goto LAB_0806cce2;
    }
  }
  prVar1 = &prVar2->original_subnet;
LAB_0806cc85:
  local_18->next = prVar3;
  local_14->prev = b;
  local_1c->next = prVar2;
  prVar1->prev = a;
  return;
}



// WARNING: Unknown calling convention

void RemoveFromNet(routebox_t *a,boxlist which)

{
  routebox_t *prVar1;
  routebox *prVar2;
  routebox_list *al;
  routebox_list *prVar3;
  routebox_list *apl;
  routebox_list *prVar4;
  routebox_t *ap;
  routebox_t *an;
  routebox_list *anl;
  routebox_list *prVar5;
  
  prVar3 = &a->original_subnet;
  if ((which != ORIGINAL) && (prVar3 = &a->different_net, which != DIFFERENT_NET)) {
    prVar3 = &a->same_net;
    if (which == SUBNET) {
      prVar3 = &a->same_subnet;
    }
  }
  prVar1 = prVar3->prev;
  prVar2 = prVar3->next;
  if (prVar1 == a) {
    return;
  }
  if (prVar2 == a) {
    return;
  }
  if (which == ORIGINAL) {
    prVar5 = &prVar2->original_subnet;
LAB_0806cd73:
    prVar4 = &prVar1->original_subnet;
  }
  else {
    if (which == DIFFERENT_NET) {
      prVar5 = &prVar2->different_net;
LAB_0806cd93:
      prVar4 = &prVar1->different_net;
      goto LAB_0806cd76;
    }
    if (which == SUBNET) {
      prVar5 = &prVar2->same_subnet;
    }
    else {
      prVar5 = &prVar2->same_net;
      if (which == ORIGINAL) goto LAB_0806cd73;
      if (which == DIFFERENT_NET) goto LAB_0806cd93;
      if (which != SUBNET) {
        (prVar2->same_net).prev = prVar1;
        (prVar1->same_net).next = prVar2;
        prVar3->prev = a;
        prVar3->next = a;
        return;
      }
    }
    prVar4 = &prVar1->same_subnet;
  }
LAB_0806cd76:
  prVar5->prev = prVar1;
  prVar4->next = prVar2;
  prVar3->prev = a;
  prVar3->next = a;
  return;
}



// WARNING: Unknown calling convention

Boolean TargetPoint(CheapPointType *nextpoint,routebox_t *target)

{
  char *pcVar1;
  int iVar2;
  void *pvVar3;
  Boolean BVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  char *pcVar9;
  
  if (target->type == CONFIG_PAGE_COLUMN) {
    nextpoint->X = (((target->parent).pad)->Point1).X2;
    nextpoint->Y = (((target->parent).pad)->Point1).Y2;
    BVar4 = '\x01';
  }
  else if (target->type == CONFIG_NAME_COLUMN) {
    pcVar9 = (char *)((target->parent).pin)->Mask;
    pcVar1 = ((target->parent).pin)->Number;
    uVar8 = (int)pcVar9 - nextpoint->X;
    uVar5 = (int)uVar8 >> 0x1f;
    uVar6 = (int)pcVar1 - nextpoint->X;
    uVar7 = (int)uVar6 >> 0x1f;
    if ((int)((uVar6 ^ uVar7) - uVar7) <= (int)((uVar8 ^ uVar5) - uVar5)) {
      pcVar9 = pcVar1;
    }
    nextpoint->X = (LocationType)pcVar9;
    iVar2 = ((target->parent).pin)->DrillingHole;
    pvVar3 = ((target->parent).pin)->Element;
    uVar5 = iVar2 - nextpoint->Y;
    uVar6 = (int)uVar5 >> 0x1f;
    uVar7 = (int)pvVar3 - nextpoint->Y;
    uVar8 = (int)uVar7 >> 0x1f;
    if ((int)((uVar5 ^ uVar6) - uVar6) < (int)((uVar7 ^ uVar8) - uVar8)) {
      nextpoint->Y = iVar2;
      BVar4 = '\x01';
    }
    else {
      nextpoint->Y = (LocationType)pvVar3;
      BVar4 = '\x01';
    }
  }
  else {
    iVar2 = (target->sbox).X1;
    nextpoint->X = ((target->sbox).X2 - iVar2) / 2 + iVar2;
    iVar2 = (target->sbox).Y1;
    nextpoint->Y = ((target->sbox).Y2 - iVar2) / 2 + iVar2;
    BVar4 = '\0';
  }
  return BVar4;
}



// WARNING: Unknown calling convention

cost_t cost_to_routebox(CheapPointType *p,Cardinal point_layer,routebox_t *rb)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  cost_t trial;
  uint local_24;
  int local_20;
  uint local_18;
  
  iVar2 = p->X;
  iVar8 = (rb->sbox).X1;
  if (iVar2 < iVar8) {
LAB_0806cf7b:
    local_24 = iVar8 - iVar2;
  }
  else {
    iVar3 = (rb->sbox).X2;
    local_24 = 0;
    iVar8 = iVar2;
    if (iVar3 <= iVar2) {
      iVar8 = iVar3 + -1;
      goto LAB_0806cf7b;
    }
  }
  iVar3 = p->Y;
  local_20 = (rb->sbox).Y1;
  if (local_20 <= iVar3) {
    local_20 = (rb->sbox).Y2;
    if (iVar3 < local_20) {
      iVar5 = 0;
      local_18 = 0;
      local_20 = iVar3;
      goto LAB_0806cefb;
    }
    local_20 = local_20 + -1;
  }
  local_18 = local_20 - iVar3;
  iVar5 = (iVar8 - iVar2) * local_18;
LAB_0806cefb:
  dVar4 = AutoRouteParameters.NewLayerPenalty;
  if ((usedGroup[point_layer] != '\0') && (usedGroup[rb->group] != '\0')) {
    dVar4 = 0.0;
  }
  if (iVar5 != 0) {
    dVar4 = dVar4 + AutoRouteParameters.JogPenalty;
  }
  piVar1 = &PCB->Data->LayerN;
  uVar6 = (int)local_18 >> 0x1f;
  uVar7 = (int)local_24 >> 0x1f;
  if ((point_layer < (uint)*piVar1 || point_layer == *piVar1) && (rb->group != point_layer)) {
    if ((iVar2 != iVar8) || (iVar3 != local_20)) {
      return (double)(((local_18 ^ uVar6) - uVar6) + ((local_24 ^ uVar7) - uVar7)) +
             dVar4 + AutoRouteParameters.ViaCost;
    }
    dVar4 = dVar4 + 1.0;
  }
  else {
    dVar4 = (double)((local_18 ^ uVar6) - uVar6) + (double)((local_24 ^ uVar7) - uVar7) + dVar4;
  }
  return dVar4;
}



// WARNING: Unknown calling convention

BoxType * bloat_routebox(routebox_t *rb)

{
  int iVar1;
  int iVar2;
  int iVar3;
  BoxType *in_EAX;
  int iVar4;
  
  if ((*(byte *)&rb->flags & 0x10) == 0) {
    iVar4 = rb->style->Keepaway;
    if (iVar4 <= (AutoRouteParameters.style)->Keepaway) {
      iVar4 = (AutoRouteParameters.style)->Keepaway;
    }
    iVar1 = (rb->sbox).X2;
    iVar4 = ((AutoRouteParameters.style)->Thick + 1) / 2 + iVar4;
    iVar2 = (rb->sbox).Y2;
    in_EAX->Y1 = (rb->sbox).Y1 + -iVar4;
    iVar3 = (rb->sbox).X1;
    in_EAX->X2 = iVar1 + iVar4;
    in_EAX->Y2 = iVar2 + iVar4;
    in_EAX->X1 = -iVar4 + iVar3;
  }
  else {
    in_EAX->X1 = (rb->sbox).X1;
    in_EAX->Y1 = (rb->sbox).Y1;
    in_EAX->X2 = (rb->sbox).X2;
    in_EAX->Y2 = (rb->sbox).Y2;
  }
  return in_EAX;
}



// WARNING: Unknown calling convention

int __region_within_guess(BoxType *region,void *cl)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  double dVar4;
  double dVar5;
  int iVar6;
  cost_t c1;
  cost_t c2;
  cost_t cost_to_region;
  
  if (*(int *)((int)cl + 8) == 0) {
    return 1;
  }
                    // WARNING: Load size is inaccurate
  iVar6 = region->X1;
  iVar1 = **cl;
  if (iVar6 <= iVar1) {
    if (iVar1 < region->X2) {
      dVar5 = 0.0;
      bVar2 = false;
      goto LAB_0806d0c5;
    }
    iVar6 = region->X2 + -1;
  }
  dVar5 = (double)(iVar6 - iVar1);
  bVar2 = dVar5 < 0.0;
LAB_0806d0c5:
  iVar6 = (*cl)[1];
  if (iVar6 < region->Y1) {
    dVar4 = (double)(region->Y1 - iVar6);
    bVar3 = dVar4 < 0.0;
  }
  else if (iVar6 < region->Y2) {
    dVar4 = 0.0;
    bVar3 = false;
  }
  else {
    dVar4 = (double)((region->Y2 + -1) - iVar6);
    bVar3 = dVar4 < 0.0;
  }
  if (bVar2) {
    dVar5 = -dVar5;
  }
  if (bVar3) {
    dVar4 = -dVar4;
  }
  if (dVar4 <= dVar5) {
    dVar4 = AutoRouteParameters.MinPenalty * dVar4 + dVar5;
  }
  else {
    dVar4 = dVar4 + AutoRouteParameters.MinPenalty * dVar5;
  }
  return (uint)(dVar4 < *(double *)((int)cl + 0xc));
}



// WARNING: Unknown calling convention

int __found_new_guess(BoxType *box,void *cl)

{
  double dVar1;
  cost_t cost_to_guess;
  cost_t cVar2;
  
                    // WARNING: Load size is inaccurate
  cVar2 = cost_to_routebox(*cl,*(Cardinal *)((int)cl + 4),(routebox_t *)box);
  dVar1 = *(double *)((int)cl + 0xc);
  if (cVar2 < dVar1) {
    *(BoxType **)((int)cl + 8) = box;
    *(cost_t *)((int)cl + 0xc) = cVar2;
  }
  return (uint)(cVar2 < dVar1);
}



// WARNING: Unknown calling convention

cost_t edge_cost(edge_t *e,cost_t too_big)

{
  double dVar1;
  routebox_t *prVar2;
  cost_t penalty;
  cost_t cVar3;
  
  prVar2 = e->rb;
  dVar1 = e->cost_to_point;
  if ((((prVar2->flags).is_thermal == 0) && (prVar2->type != GDK_NOOP)) && (dVar1 <= too_big)) {
    cVar3 = cost_to_routebox(&e->cost_point,(uint)prVar2->group,e->mincost_target);
    return dVar1 + cVar3;
  }
  return dVar1;
}



// WARNING: Unknown calling convention

broken_boxes * break_box_edge(BoxType *original,direction_t which_edge,routebox_t *breaker)

{
  broken_boxes *in_EAX;
  int iVar1;
  int iVar2;
  LocationType local_58;
  LocationType local_54;
  int local_50;
  bool local_4b;
  bool local_4a;
  bool local_49;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  LocationType local_30;
  int local_2c;
  int local_28;
  int local_24;
  BoxType breakbox;
  
  local_2c = original->Y2;
  iVar2 = original->X2;
  local_34 = original->Y1;
  local_40 = original->X1;
  bloat_routebox(breaker);
  local_28 = breakbox.X1;
  if (which_edge == SOUTH) {
    iVar1 = -iVar2;
    iVar2 = -local_40;
    local_30 = -local_2c;
    local_40 = iVar1;
LAB_0806d45a:
    local_28 = -breakbox.X2;
    local_38 = local_30 + 1;
    breakbox.X2 = -breakbox.X1;
    local_54 = local_28;
    if (local_28 <= local_40) {
      local_54 = local_40;
    }
    local_58 = breakbox.X2;
    if (iVar2 == breakbox.X2 || SBORROW4(iVar2,breakbox.X2) != iVar2 + breakbox.X1 < 0) {
      local_58 = iVar2;
    }
    local_4b = local_40 < local_28;
    local_4a = local_54 < local_58;
    local_49 = breakbox.X2 < iVar2;
LAB_0806d499:
    iVar1 = -local_40;
    local_40 = -local_28;
    local_34 = -local_38;
    local_3c = -local_30;
    local_2c = local_3c;
    local_28 = iVar1;
    local_24 = local_34;
LAB_0806d4c2:
    iVar1 = -local_54;
    local_54 = -local_58;
    local_48 = local_2c;
    local_44 = local_24;
    local_58 = iVar1;
  }
  else {
    if (which_edge == WEST) {
      iVar2 = -local_34;
      local_3c = -local_2c;
      local_30 = local_40;
LAB_0806d4f5:
      local_28 = -breakbox.Y2;
      breakbox.X2 = -breakbox.Y1;
      local_38 = local_30 + 1;
      local_54 = local_28;
      if (SBORROW4(local_3c,local_28) == local_3c + breakbox.Y2 < 0) {
        local_54 = local_3c;
      }
      local_58 = breakbox.X2;
      if (iVar2 == breakbox.X2 || SBORROW4(iVar2,breakbox.X2) != iVar2 + breakbox.Y1 < 0) {
        local_58 = iVar2;
      }
      local_4b = local_3c < local_28;
      local_4a = local_54 < local_58;
      local_49 = breakbox.X2 < iVar2;
LAB_0806d52d:
      local_3c = -local_3c;
      local_34 = -local_28;
      local_40 = local_30;
      local_28 = local_38;
LAB_0806d546:
      local_48 = -local_54;
      local_44 = -local_58;
      local_58 = local_38;
      local_54 = local_30;
LAB_0806d55c:
      local_24 = -iVar2;
      local_50 = local_38;
      local_2c = -breakbox.X2;
      goto LAB_0806d3e9;
    }
    if (which_edge == EAST) {
      local_30 = -iVar2;
      local_40 = local_34;
LAB_0806d36b:
      local_38 = local_30 + 1;
      local_28 = breakbox.Y1;
      local_54 = breakbox.Y1;
      if (breakbox.Y1 <= local_40) {
        local_54 = local_40;
      }
      local_58 = breakbox.Y2;
      if (local_2c <= breakbox.Y2) {
        local_58 = local_2c;
      }
      local_4b = local_40 < breakbox.Y1;
      local_4a = local_54 < local_58;
      local_49 = breakbox.Y2 < local_2c;
      breakbox.X2 = breakbox.Y2;
LAB_0806d3a6:
      local_50 = -local_30;
      local_3c = local_28;
      local_44 = local_54;
      local_54 = -local_38;
      iVar2 = -local_38;
      local_34 = local_40;
      local_28 = local_50;
LAB_0806d3cb:
      local_40 = iVar2;
      local_48 = local_58;
      local_58 = local_50;
      local_30 = local_54;
      local_24 = breakbox.X2;
      goto LAB_0806d3e9;
    }
    local_30 = local_34;
    if (which_edge == SOUTH) goto LAB_0806d45a;
    local_3c = local_40;
    if (which_edge == WEST) goto LAB_0806d4f5;
    local_2c = iVar2;
    if (which_edge == EAST) goto LAB_0806d36b;
    local_48 = local_34 + 1;
    local_54 = breakbox.X1;
    if (breakbox.X1 < local_40) {
      local_54 = local_40;
    }
    local_58 = iVar2;
    if (breakbox.X2 <= iVar2) {
      local_58 = breakbox.X2;
    }
    local_4b = local_40 < breakbox.X1;
    local_4a = local_54 < local_58;
    local_49 = breakbox.X2 < iVar2;
    local_38 = local_48;
    if (which_edge == SOUTH) goto LAB_0806d499;
    if (which_edge == WEST) goto LAB_0806d52d;
    if (which_edge == EAST) goto LAB_0806d3a6;
    local_3c = local_48;
    if (which_edge == SOUTH) {
      local_24 = -local_48;
      local_2c = -local_34;
      goto LAB_0806d4c2;
    }
    if (which_edge == WEST) goto LAB_0806d546;
    if (which_edge == EAST) {
      local_50 = -local_34;
      local_44 = local_54;
      local_54 = -local_48;
      iVar2 = local_40;
      goto LAB_0806d3cb;
    }
    local_44 = local_34;
    if (which_edge != SOUTH) {
      if (which_edge != WEST) {
        local_30 = breakbox.X2;
        local_50 = iVar2;
        local_2c = local_48;
        local_24 = local_34;
        if (which_edge == EAST) {
          local_30 = -local_48;
          local_50 = -local_34;
          local_2c = iVar2;
          local_24 = breakbox.X2;
        }
        goto LAB_0806d3e9;
      }
      goto LAB_0806d55c;
    }
    local_24 = -local_48;
    local_2c = -local_34;
  }
  local_30 = -iVar2;
  local_50 = -breakbox.X2;
LAB_0806d3e9:
  (in_EAX->center).X1 = local_54;
  (in_EAX->right).X2 = local_50;
  in_EAX->is_valid_right = local_49;
  in_EAX->is_valid_center = local_4a;
  (in_EAX->center).Y2 = local_48;
  (in_EAX->right).X1 = local_30;
  in_EAX->is_valid_left = local_4b;
  (in_EAX->right).Y2 = local_2c;
  (in_EAX->left).X1 = local_40;
  (in_EAX->right).Y1 = local_24;
  (in_EAX->center).X2 = local_58;
  (in_EAX->center).Y1 = local_44;
  (in_EAX->left).X2 = local_28;
  (in_EAX->left).Y2 = local_3c;
  (in_EAX->left).Y1 = local_34;
  return in_EAX;
}



// WARNING: Unknown calling convention

int __Expand_this_rect(BoxType *box,void *cl)

{
  byte bVar1;
  BoxType *pBVar2;
  uint uVar3;
  bool bVar4;
  bool bVar5;
  int iVar6;
  int iVar7;
  BDimension dw;
  int local_30;
  int local_28;
  int local_24;
  LocationType local_20;
  LocationType local_1c;
  int local_18;
  int local_14;
  
  bVar1 = *(byte *)((int)&box[2].Y2 + 1);
  if ((bVar1 & 1) == 0) {
    if ((*(byte *)&box[2].Y2 & 0x10) == 0) {
      local_30 = *(int *)(box[4].Y2 + 0xc);
      if (*(int *)((int)cl + 0x14) < local_30) {
        local_30 = *(int *)((int)cl + 0x14) - local_30;
        local_1c = local_30 + box[1].X1;
        local_20 = local_30 + box[1].Y1;
        iVar6 = box[1].X2 - local_30;
        local_30 = box[1].Y2 - local_30;
      }
      else {
        local_30 = box[1].Y2;
        local_20 = box[1].Y1;
        local_1c = box[1].X1;
        iVar6 = box[1].X2;
      }
      if (iVar6 <= *(int *)((int)cl + 0x1c)) {
        return 0;
      }
      if (*(int *)((int)cl + 0x24) == local_1c || *(int *)((int)cl + 0x24) < local_1c) {
        return 0;
      }
      if (*(int *)((int)cl + 0x28) == local_20 || *(int *)((int)cl + 0x28) < local_20) {
        return 0;
      }
      if (local_30 <= *(int *)((int)cl + 0x20)) {
        return 0;
      }
      local_18 = 0;
    }
    else {
      local_30 = box[1].Y2;
      local_20 = box[1].Y1;
      local_1c = box[1].X1;
      local_18 = *(int *)((int)cl + 0x18);
      iVar6 = box[1].X2;
      if (iVar6 <= local_18 + *(int *)((int)cl + 0x1c)) {
        return 0;
      }
      if (*(int *)((int)cl + 0x24) - local_18 <= local_1c) {
        return 0;
      }
      if (*(int *)((int)cl + 0x28) - local_18 <= local_20) {
        return 0;
      }
      if (local_30 <= local_18 + *(int *)((int)cl + 0x20)) {
        return 0;
      }
    }
                    // WARNING: Load size is inaccurate
    pBVar2 = *cl;
    if ((pBVar2 != box) && (pBVar2 != (BoxType *)box[2].X1)) {
      if ((*(byte *)&pBVar2[2].Y2 & 4) == 0) {
        iVar7 = box[2].X2;
      }
      else {
        if ((*(byte *)&box[2].Y2 & 4) != 0) {
          return 0;
        }
        iVar7 = box[2].X2;
        if ((iVar7 == 6) && ((*(byte *)&((BoxType *)box[2].X1)[2].Y2 & 4) != 0)) {
          return 0;
        }
      }
      if (((bVar1 & 4) == 0) || (iVar7 != 6)) {
        if (((iVar7 == 7) &&
            (((local_1c < *(int *)((int)cl + 0x2c) && (*(int *)((int)cl + 0x34) < iVar6)) &&
             (local_20 < *(int *)((int)cl + 0x30))))) && (*(int *)((int)cl + 0x38) < local_30)) {
          iVar6 = *(int *)((int)cl + 0x18);
          *(int *)((int)cl + 0x1c) = -iVar6 + *(int *)((int)cl + 0x2c);
          *(int *)((int)cl + 0x24) = *(int *)((int)cl + 0x34) + iVar6;
          *(int *)((int)cl + 0x28) = *(int *)((int)cl + 0x38) + iVar6;
          *(int *)((int)cl + 0x20) = -iVar6 + *(int *)((int)cl + 0x30);
          return 1;
        }
        uVar3 = *(uint *)((int)cl + 0x3c);
        if ((((uVar3 & 1) == 0) && (local_20 <= *(int *)((int)cl + 0x30))) &&
           (*(int *)((int)cl + 0x20) < local_30)) {
          local_14 = *(int *)((int)cl + 0x30) - local_30;
          bVar4 = local_14 < 1;
        }
        else {
          bVar4 = true;
          local_14 = 0;
        }
        if ((((uVar3 & 2) == 0) && (*(int *)((int)cl + 0x34) <= iVar6)) &&
           (*(int *)((int)cl + 0x24) != local_1c && local_1c <= *(int *)((int)cl + 0x24))) {
          local_28 = local_1c - *(int *)((int)cl + 0x34);
          bVar5 = local_28 < 1;
        }
        else {
          bVar5 = true;
          local_28 = 0;
        }
        if ((((uVar3 & 4) == 0) && (*(int *)((int)cl + 0x38) <= local_30)) &&
           (*(int *)((int)cl + 0x28) != local_20 && local_20 <= *(int *)((int)cl + 0x28))) {
          local_24 = local_20 - *(int *)((int)cl + 0x38);
        }
        else {
          local_24 = 0;
        }
        if ((((uVar3 & 8) == 0) && (local_1c <= *(int *)((int)cl + 0x2c))) &&
           (*(int *)((int)cl + 0x1c) < iVar6)) {
          iVar7 = *(int *)((int)cl + 0x2c) - iVar6;
        }
        else {
          iVar7 = 0;
        }
        if (((bVar5) && (bVar4)) && ((iVar7 < 1 && (local_24 < 1)))) {
          return 1;
        }
        if (((local_24 <= local_14) && (local_28 <= local_14)) && (iVar7 <= local_14)) {
          *(BoxType **)((int)cl + 4) = box;
          *(int *)((int)cl + 0x20) = local_30 - local_18;
          return 1;
        }
        if ((iVar7 <= local_28) && (local_24 <= local_28)) {
          *(BoxType **)((int)cl + 8) = box;
          *(LocationType *)((int)cl + 0x24) = local_1c + local_18;
          return 1;
        }
        if (iVar7 <= local_24) {
          *(BoxType **)((int)cl + 0xc) = box;
          *(LocationType *)((int)cl + 0x28) = local_20 + local_18;
          return 1;
        }
        *(BoxType **)((int)cl + 0x10) = box;
        *(int *)((int)cl + 0x1c) = iVar6 - local_18;
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void InitAutoRouteParameters
               (int pass,RouteStyleType *style,Boolean with_conflicts,Boolean is_smoothing,
               Boolean lastpass)

{
  float fVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int i;
  
  AutoRouteParameters.style = style;
  AutoRouteParameters.bloat = (style->Thick + 1) / 2 + style->Keepaway;
  if (is_smoothing == '\0') {
    iVar4 = style->Diameter * 0x1e;
    iVar5 = ((pass * 400) / 0xc + 2) / (pass + 1);
    fVar1 = 4000.0;
  }
  else {
    iVar4 = style->Diameter * 0x50;
    iVar5 = ((pass * 400) / 0xc + 2) / (pass + 1);
    fVar1 = 20000.0;
  }
  AutoRouteParameters.LastConflictPenalty = (cost_t)iVar5;
  AutoRouteParameters.ConflictPenalty = AutoRouteParameters.LastConflictPenalty * 4.0;
  AutoRouteParameters.ViaCost = (cost_t)(iVar4 + 350000);
  AutoRouteParameters.JogPenalty = (cost_t)fVar1;
  AutoRouteParameters.CongestionPenalty = 1000000.0;
  dVar2 = 3e+28;
  AutoRouteParameters.MinPenalty = 3e+28;
  iVar5 = PCB->Data->LayerN;
  if (0 < iVar5) {
    iVar6 = 0;
    do {
      if (is_layer_group_active[iVar6] != '\0') {
        dVar3 = (double)x_cost[iVar6];
        if (dVar3 <= dVar2 || dVar2 != dVar3) {
          dVar2 = dVar3;
        }
        dVar3 = (double)y_cost[iVar6];
        if (dVar3 <= dVar2 || dVar2 != dVar3) {
          dVar2 = dVar3;
        }
      }
      iVar6 = iVar6 + 1;
      AutoRouteParameters.MinPenalty = dVar2;
    } while (iVar6 != iVar5);
  }
  if (is_smoothing == '\0') {
    fVar1 = (float)(iVar4 + 350000) * 10.0;
  }
  else {
    fVar1 = 1.5e+28;
  }
  iVar4 = (0xd - pass) * 8;
  AutoRouteParameters.hi_conflict = 6;
  if (5 < iVar4) {
    AutoRouteParameters.hi_conflict = iVar4;
  }
  AutoRouteParameters.is_odd = (byte)pass & 1;
  AutoRouteParameters.pass = (byte)pass + 1;
  AutoRouteParameters.NewLayerPenalty = (cost_t)fVar1;
  AutoRouteParameters.with_conflicts = with_conflicts;
  AutoRouteParameters.is_smoothing = is_smoothing;
  AutoRouteParameters.rip_always = is_smoothing;
  AutoRouteParameters.last_smooth = '\0';
  return;
}



// WARNING: Unknown calling convention

routebox_t *
AddPad(PointerListType *layergroupboxes,ElementTypePtr element,PadTypePtr pad,RouteStyleType *style)

{
  LocationType *pLVar1;
  undefined *puVar2;
  routebox_t **pprVar3;
  routebox_t *prVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int layergroup;
  int iVar10;
  routebox_t **rbpp;
  byte bVar11;
  
  bVar11 = 0;
  layergroup = back;
  if (-1 < *(char *)&(pad->Flags).f) {
    layergroup = front;
  }
  pprVar3 = (routebox_t **)GetPointerMemory(layergroupboxes + layergroup);
  prVar4 = (routebox_t *)calloc(1,0x7c);
  *pprVar3 = prVar4;
  for (iVar5 = 0x1f; iVar5 != 0; iVar5 = iVar5 + -1) {
    (prVar4->box).X1 = 0;
    prVar4 = (routebox_t *)((int)prVar4 + (uint)bVar11 * -8 + 4);
  }
  prVar4 = *pprVar3;
  prVar4->group = (ushort)layergroup;
  iVar10 = (pad->Thickness + 1) / 2;
  iVar5 = style->Keepaway;
  iVar6 = (pad->Point2).Y;
  if (iVar6 <= (pad->Point1).Y) {
    iVar6 = (pad->Point1).Y;
  }
  iVar7 = (pad->Point2).X;
  if (iVar7 <= (pad->Point1).X) {
    iVar7 = (pad->Point1).X;
  }
  iVar8 = (pad->Point2).Y;
  pLVar1 = &(pad->Point1).Y;
  if (*pLVar1 == iVar8 || *pLVar1 < iVar8) {
    iVar8 = (pad->Point1).Y;
  }
  iVar9 = (pad->Point2).X;
  if ((pad->Point1).X == iVar9 || (pad->Point1).X < iVar9) {
    iVar9 = (pad->Point1).X;
  }
  (prVar4->box).X1 = (iVar9 - iVar10) - iVar5;
  (prVar4->sbox).X1 = iVar9 - iVar10;
  (prVar4->box).Y1 = (iVar8 - iVar10) - iVar5;
  (prVar4->box).X2 = iVar10 + iVar7 + iVar5;
  (prVar4->box).Y2 = iVar5 + iVar10 + iVar6;
  (prVar4->sbox).Y1 = iVar8 - iVar10;
  puVar2 = &(prVar4->flags).field_0x1;
  *puVar2 = *puVar2 | 0x40;
  (prVar4->sbox).X2 = iVar10 + iVar7;
  (prVar4->sbox).Y2 = iVar10 + iVar6;
  if (((pad->Point1).X != (pad->Point2).X) && ((pad->Point1).Y != (pad->Point2).Y)) {
    *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 1;
  }
  prVar4 = *pprVar3;
  (prVar4->parent).pad = pad;
  prVar4->type = CONFIG_NAME_COLUMN;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 2;
  prVar4 = *pprVar3;
  prVar4->came_from = ALL;
  prVar4->style = style;
  InitLists(prVar4);
  return *pprVar3;
}



// WARNING: Unknown calling convention

routebox_t *
AddPin(PointerListType *layergroupboxes,PinTypePtr pin,Boolean is_via,RouteStyleType *style)

{
  int *piVar1;
  undefined *puVar2;
  uint uVar3;
  int iVar4;
  routebox_t **pprVar5;
  routebox_t *prVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  routebox_t **rbpp;
  int iVar10;
  byte bVar11;
  PointerListTypePtr local_2c;
  int local_28;
  routebox_t *local_24;
  
  bVar11 = 0;
  local_24 = (routebox_t *)0x0;
  if (0 < PCB->Data->LayerN) {
    local_28 = 0;
    local_2c = layergroupboxes;
    do {
      pprVar5 = (routebox_t **)GetPointerMemory(local_2c);
      prVar6 = (routebox_t *)calloc(1,0x7c);
      *pprVar5 = prVar6;
      for (iVar7 = 0x1f; iVar7 != 0; iVar7 = iVar7 + -1) {
        (prVar6->box).X1 = 0;
        prVar6 = (routebox_t *)((int)prVar6 + (uint)bVar11 * -8 + 4);
      }
      iVar7 = pin->DrillingHole;
      prVar6 = *pprVar5;
      if (iVar7 <= pin->Thickness) {
        iVar7 = pin->Thickness;
      }
      prVar6->group = (ushort)local_28;
      iVar4 = style->Keepaway;
      iVar10 = (iVar7 + 1) / 2;
      iVar7 = pin->Y + iVar10;
      iVar8 = pin->X + iVar10;
      iVar9 = pin->Y - iVar10;
      iVar10 = pin->X - iVar10;
      (prVar6->box).X1 = iVar10 - iVar4;
      (prVar6->sbox).X1 = iVar10;
      (prVar6->box).Y1 = iVar9 - iVar4;
      (prVar6->box).X2 = iVar8 + iVar4;
      (prVar6->box).Y2 = iVar4 + iVar7;
      (prVar6->sbox).X2 = iVar8;
      (prVar6->sbox).Y1 = iVar9;
      puVar2 = &(prVar6->flags).field_0x1;
      *puVar2 = *puVar2 | 0x40;
      (prVar6->sbox).Y2 = iVar7;
      if (is_via == '\0') {
        prVar6 = *pprVar5;
        prVar6->type = CONFIG_PAGE_COLUMN;
        (prVar6->parent).pin = pin;
      }
      else {
        prVar6 = *pprVar5;
        prVar6->type = DBUS_BUS_STARTER;
        (prVar6->parent).pin = pin;
      }
      *(byte *)&(*pprVar5)->flags = *(byte *)&(*pprVar5)->flags | 2;
      prVar6 = *pprVar5;
      prVar6->style = style;
      uVar3 = (pin->Flags).f;
      prVar6->came_from = ALL;
      *(byte *)&prVar6->flags = *(byte *)&prVar6->flags & 0xdf | (byte)(((uVar3 >> 8 ^ 1) & 1) << 5)
      ;
      InitLists(*pprVar5);
      if (local_24 != (routebox_t *)0x0) {
        MergeNets(*pprVar5,local_24,NET);
        MergeNets(*pprVar5,local_24,SUBNET);
        MergeNets(*pprVar5,local_24,ORIGINAL);
      }
      local_28 = local_28 + 1;
      local_24 = *pprVar5;
      local_2c = local_2c + 1;
      piVar1 = &PCB->Data->LayerN;
    } while (*piVar1 != local_28 && local_28 <= *piVar1);
  }
  return local_24;
}



// WARNING: Unknown calling convention

routebox_t *
AddLine(PointerListType *layergroupboxes,int layergroup,LineTypePtr line,LineTypePtr ptr,
       RouteStyleType *style)

{
  LocationType *pLVar1;
  undefined *puVar2;
  routebox_t **pprVar3;
  routebox_t *prVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  routebox_t **rbpp;
  int iVar10;
  byte bVar11;
  
  bVar11 = 0;
  pprVar3 = (routebox_t **)GetPointerMemory(layergroupboxes + layergroup);
  prVar4 = (routebox_t *)calloc(1,0x7c);
  *pprVar3 = prVar4;
  for (iVar5 = 0x1f; iVar5 != 0; iVar5 = iVar5 + -1) {
    (prVar4->box).X1 = 0;
    prVar4 = (routebox_t *)((int)prVar4 + (uint)bVar11 * -8 + 4);
  }
  prVar4 = *pprVar3;
  prVar4->group = (ushort)layergroup;
  iVar5 = style->Keepaway;
  iVar10 = (line->Point2).Y;
  iVar6 = (line->Thickness + 1) / 2;
  if (iVar10 <= (line->Point1).Y) {
    iVar10 = (line->Point1).Y;
  }
  iVar9 = (line->Point2).X;
  if (iVar9 <= (line->Point1).X) {
    iVar9 = (line->Point1).X;
  }
  iVar7 = (line->Point2).Y;
  pLVar1 = &(line->Point1).Y;
  if (*pLVar1 == iVar7 || *pLVar1 < iVar7) {
    iVar7 = (line->Point1).Y;
  }
  iVar7 = -iVar6 + iVar7;
  iVar8 = (line->Point2).X;
  if ((line->Point1).X == iVar8 || (line->Point1).X < iVar8) {
    iVar8 = (line->Point1).X;
  }
  iVar8 = -iVar6 + iVar8;
  (prVar4->box).X1 = iVar8 - iVar5;
  (prVar4->sbox).X1 = iVar8;
  (prVar4->box).Y1 = iVar7 - iVar5;
  (prVar4->box).X2 = iVar6 + iVar9 + iVar5;
  (prVar4->box).Y2 = iVar5 + iVar6 + iVar10;
  (prVar4->sbox).Y1 = iVar7;
  puVar2 = &(prVar4->flags).field_0x1;
  *puVar2 = *puVar2 | 0x40;
  (prVar4->sbox).X2 = iVar6 + iVar9;
  (prVar4->sbox).Y2 = iVar6 + iVar10;
  if (((line->Point1).X != (line->Point2).X) && ((line->Point1).Y != (line->Point2).Y)) {
    *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 1;
    iVar5 = (line->Point1).Y;
    iVar10 = (line->Point2).Y;
    iVar6 = (line->Point1).X;
    iVar9 = (line->Point2).X;
    if (iVar5 <= iVar10) {
      iVar10 = iVar5;
    }
    if (iVar6 <= iVar9) {
      iVar9 = iVar6;
    }
    ((*pprVar3)->flags).field_0x1 =
         ((*pprVar3)->flags).field_0x1 & 0xf7 | ((iVar5 == iVar10) != (iVar6 == iVar9)) << 3;
  }
  prVar4 = *pprVar3;
  prVar4->type = DBUS_WATCH_ERROR;
  (prVar4->parent).line = ptr;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 2;
  prVar4 = *pprVar3;
  prVar4->came_from = ALL;
  prVar4->style = style;
  InitLists(prVar4);
  return *pprVar3;
}



// WARNING: Unknown calling convention

routebox_t *
AddIrregularObstacle
          (PointerListType *layergroupboxes,LocationType X1,LocationType Y1,LocationType X2,
          LocationType Y2,Cardinal layergroup,void *parent,RouteStyleType *style)

{
  undefined *puVar1;
  int iVar2;
  routebox_t **pprVar3;
  routebox_t *prVar4;
  int iVar5;
  LocationType keep;
  byte bVar6;
  
  bVar6 = 0;
  iVar2 = style->Keepaway;
  pprVar3 = (routebox_t **)GetPointerMemory(layergroupboxes + layergroup);
  prVar4 = (routebox_t *)calloc(1,0x7c);
  *pprVar3 = prVar4;
  for (iVar5 = 0x1f; iVar5 != 0; iVar5 = iVar5 + -1) {
    (prVar4->box).X1 = 0;
    prVar4 = (routebox_t *)((int)prVar4 + (uint)bVar6 * -8 + 4);
  }
  prVar4 = *pprVar3;
  prVar4->group = (ushort)layergroup;
  (prVar4->box).X1 = X1 - iVar2;
  (prVar4->box).Y1 = Y1 - iVar2;
  (prVar4->box).X2 = X2 + iVar2;
  (prVar4->sbox).X1 = X1;
  (prVar4->sbox).Y1 = Y1;
  puVar1 = &(prVar4->flags).field_0x1;
  *puVar1 = *puVar1 | 0x40;
  (prVar4->box).Y2 = iVar2 + Y2;
  (prVar4->sbox).X2 = X2;
  (prVar4->sbox).Y2 = Y2;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 1;
  prVar4 = *pprVar3;
  prVar4->type = GDK_AND_REVERSE;
  (prVar4->parent).generic = parent;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 2;
  prVar4 = *pprVar3;
  prVar4->style = style;
  InitLists(prVar4);
  return *pprVar3;
}



// WARNING: Unknown calling convention

routebox_t *
AddPolygon(PointerListType *layergroupboxes,Cardinal layer,PolygonTypePtr polygon,
          RouteStyleType *style)

{
  undefined *puVar1;
  PointTypePtr pPVar2;
  bool bVar3;
  Cardinal layergroup_00;
  int layergroup;
  routebox_t *prVar4;
  routebox_t *rb;
  byte bVar5;
  int is_not_rectangle;
  
  layergroup_00 = GetLayerGroupNumberByNumber(layer);
  prVar4 = AddIrregularObstacle
                     (layergroupboxes,(polygon->BoundingBox).X1,(polygon->BoundingBox).Y1,
                      (polygon->BoundingBox).X2,(polygon->BoundingBox).Y2,layergroup_00,polygon,
                      style);
  if (polygon->PointN == 4) {
    pPVar2 = polygon->Points;
    if ((pPVar2->X == pPVar2[1].X) || (pPVar2->Y == pPVar2[1].Y)) {
      if ((pPVar2[1].X == pPVar2[2].X) || (pPVar2[1].Y == pPVar2[2].Y)) {
        if (((pPVar2[2].X == pPVar2[3].X) || (pPVar2[2].Y == pPVar2[3].Y)) &&
           ((pPVar2->X == pPVar2[3].X || (pPVar2[3].Y == pPVar2->Y)))) {
          bVar5 = 0;
          bVar3 = false;
          goto LAB_0806e10f;
        }
      }
    }
  }
  bVar5 = 1;
  bVar3 = true;
LAB_0806e10f:
  prVar4->layer = (ushort)layer;
  prVar4->came_from = ALL;
  *(byte *)&prVar4->flags = *(byte *)&prVar4->flags & 0xfe | bVar5;
  if (((*(byte *)&(polygon->Flags).f & 0x10) != 0) &&
     (puVar1 = &(prVar4->flags).field_0x1, *puVar1 = *puVar1 | 0x10, !bVar3)) {
    prVar4->type = GDK_NOOP;
  }
  return prVar4;
}



// WARNING: Unknown calling convention

void RB_down_count(routebox_t *rb)

{
  int iVar1;
  
  iVar1 = rb->refcount + -1;
  rb->refcount = iVar1;
  if (iVar1 == 0) {
    if ((*(byte *)&((routebox_t *)(rb->parent).pad)->flags & 0x40) != 0) {
      RB_down_count((routebox_t *)(rb->parent).pad);
    }
    free(rb);
  }
  return;
}



// WARNING: Unknown calling convention

void best_path_candidate(routeone_state *s,edge_t *e,routebox_t *best_target)

{
  routebox_t *prVar1;
  cost_t cVar2;
  
  cVar2 = edge_cost(e,3e+28);
  prVar1 = s->best_path;
  e->cost = cVar2;
  if (prVar1 != (routebox_t *)0x0) {
    if (s->best_cost <= cVar2) {
      return;
    }
    if ((*(byte *)&prVar1->flags & 0x40) != 0) {
      RB_down_count(prVar1);
      cVar2 = e->cost;
    }
  }
  prVar1 = e->rb;
  s->best_cost = cVar2;
  s->best_target = best_target;
  s->best_path = prVar1;
  if ((*(byte *)&prVar1->flags & 0x40) != 0) {
    prVar1->refcount = prVar1->refcount + 1;
  }
  return;
}



// WARNING: Unknown calling convention

int blocker_to_heap(heap_t *heap,routebox_t *rb,BoxType *box,direction_t dir)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_24;
  
  local_24 = (rb->sbox).Y2;
  iVar3 = (rb->sbox).X1;
  iVar1 = (rb->sbox).Y1;
  iVar2 = (rb->sbox).X2;
  iVar4 = rb->style->Keepaway;
  if ((AutoRouteParameters.style)->Keepaway < iVar4) {
    iVar4 = (AutoRouteParameters.style)->Keepaway - iVar4;
    local_24 = local_24 - iVar4;
    iVar3 = iVar3 + iVar4;
    iVar1 = iVar1 + iVar4;
    iVar2 = iVar2 - iVar4;
  }
  iVar4 = box->X1;
  if (box->X1 <= iVar3) {
    iVar4 = iVar3;
  }
  if (box->X2 < iVar2) {
    iVar2 = box->X2;
  }
  if (iVar1 < box->Y1) {
    iVar1 = box->Y1;
  }
  iVar3 = box->Y2;
  if (local_24 <= box->Y2) {
    iVar3 = local_24;
  }
  if (dir == EAST) {
    heap_insert(heap,(double)((float)iVar1 - (float)iVar1 / ((float)iVar3 + 1.0)),rb);
  }
  else if (dir == NORTH) {
    heap_insert(heap,(double)((float)iVar4 - (float)iVar4 / ((float)iVar2 + 1.0)),rb);
  }
  else if (dir == SOUTH) {
    heap_insert(heap,(double)-((float)iVar4 / ((float)iVar2 + 1.0) + (float)iVar2),rb);
  }
  else if (dir == WEST) {
    heap_insert(heap,(double)-((float)iVar1 / ((float)iVar3 + 1.0) + (float)iVar3),rb);
  }
  return (uint)((*(byte *)&rb->flags & 0xe) == 2);
}



// WARNING: Unknown calling convention

int __GatherBlockers(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int local_24;
  int local_20;
  
  if ((((*(BoxType **)((int)cl + 4) != box) && ((*(byte *)((int)&box[2].Y2 + 1) & 1) == 0)) &&
      ((BoxType *)(*(BoxType **)((int)cl + 4))[2].X1 != box)) &&
     (((*(byte *)&box[2].Y2 & 4) == 0 || (*(char *)((int)cl + 0x1c) == '\0')))) {
    local_24 = box[1].Y2;
    local_20 = box[1].Y1;
    iVar1 = box[1].X1;
    iVar2 = box[1].X2;
    iVar3 = *(int *)(box[4].Y2 + 0xc);
    if ((AutoRouteParameters.style)->Keepaway < iVar3) {
      iVar3 = (AutoRouteParameters.style)->Keepaway - iVar3;
      iVar1 = iVar1 + iVar3;
      iVar2 = iVar2 - iVar3;
      local_20 = local_20 + iVar3;
      local_24 = local_24 - iVar3;
    }
    if (((*(int *)((int)cl + 8) < iVar2) &&
        (*(int *)((int)cl + 0x10) != iVar1 && iVar1 <= *(int *)((int)cl + 0x10))) &&
       ((*(int *)((int)cl + 0x14) != local_20 && local_20 <= *(int *)((int)cl + 0x14) &&
        (*(int *)((int)cl + 0xc) < local_24)))) {
                    // WARNING: Load size is inaccurate
      iVar1 = blocker_to_heap(*cl,(routebox_t *)box,(BoxType *)((int)cl + 8),
                              *(direction_t *)((int)cl + 0x18));
      return iVar1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void RD_DrawThermal(routedata_t *rd,LocationType X,LocationType Y,Cardinal group,Cardinal layer,
                   routebox_t *subnet,Boolean is_bad)

{
  routebox_t *r;
  int iVar1;
  routebox_t *rb;
  byte bVar2;
  
  bVar2 = 0;
  r = (routebox_t *)calloc(1,0x7c);
  rb = r;
  for (iVar1 = 0x1f; iVar1 != 0; iVar1 = iVar1 + -1) {
    rb = (routebox_t *)((int)rb + (uint)bVar2 * -8 + 4);
    (rb->box).X1 = 0;
    rb = rb;
  }
  (r->box).X1 = X;
  (r->box).X2 = X + 1;
  (r->sbox).X1 = X;
  (r->sbox).X2 = X + 1;
  r->type = DBUS_WATCH_HANGUP;
  (r->box).Y2 = Y + 1;
  (r->sbox).Y2 = Y + 1;
  (r->box).Y1 = Y;
  (r->sbox).Y1 = Y;
  r->group = (ushort)group;
  r->layer = (ushort)layer;
  (r->flags).field_0x1 = (byte)(((byte)is_bad & 1) << 5) | 0x40;
  *(Boolean *)&r->flags = AutoRouteParameters.is_odd << 7;
  r->style = AutoRouteParameters.style;
  InitLists(r);
  MergeNets(r,subnet,NET);
  MergeNets(r,subnet,SUBNET);
  r_insert_entry(rd->layergrouptree[r->group],(BoxType *)r,1);
  *(byte *)&r->flags = *(byte *)&r->flags & 0xbf;
  return;
}



// WARNING: Unknown calling convention

void RD_DrawLine(routedata_t *rd,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
                BDimension halfthick,Cardinal group,routebox_t *subnet,Boolean is_bad,Boolean is_45)

{
  int iVar1;
  DataTypePtr paVar2;
  Cardinal CVar3;
  LocationType LVar4;
  routebox_t *b;
  Boolean BVar5;
  LocationType LVar6;
  LocationType LVar7;
  Boolean BVar8;
  routebox_t *r;
  LocationType LVar9;
  LocationType LVar10;
  int iVar11;
  int iVar12;
  uint uVar13;
  byte bVar14;
  routebox_t *rb;
  
  bVar14 = 0;
  iVar1 = (AutoRouteParameters.style)->Keepaway;
  if ((Y1 == Y2) && (X1 == X2)) {
    return;
  }
  if (RD_DrawLine::qX1 == -1) {
    RD_DrawLine::qX1 = X1;
    RD_DrawLine::qY1 = Y1;
    RD_DrawLine::qX2 = X2;
    RD_DrawLine::qY2 = Y2;
    RD_DrawLine::qhthick = halfthick;
    RD_DrawLine::qgroup = group;
    RD_DrawLine::qis_45 = is_45;
    RD_DrawLine::qis_bad = is_bad;
    RD_DrawLine::qsn = subnet;
    return;
  }
  if ((((X1 == RD_DrawLine::qX2) && (Y1 == RD_DrawLine::qY2)) && (RD_DrawLine::qhthick == halfthick)
      ) && (RD_DrawLine::qgroup == group)) {
    if ((X1 == X2) && (X1 == RD_DrawLine::qX1)) {
      RD_DrawLine::qY2 = Y2;
      return;
    }
    if ((Y1 == Y2) && (Y1 == RD_DrawLine::qY1)) {
      RD_DrawLine::qX2 = X2;
      return;
    }
  }
  r = (routebox_t *)calloc(1,0x7c);
  rb = r;
  for (iVar11 = 0x1f; iVar11 != 0; iVar11 = iVar11 + -1) {
    rb = (routebox_t *)((int)rb + (uint)bVar14 * -8 + 4);
    (rb->box).X1 = 0;
    rb = rb;
  }
  r->type = DBUS_WATCH_ERROR;
  LVar7 = RD_DrawLine::qY1;
  LVar6 = RD_DrawLine::qY2;
  LVar4 = RD_DrawLine::qX1;
  iVar11 = RD_DrawLine::qhthick + 1;
  LVar9 = RD_DrawLine::qY2;
  if (RD_DrawLine::qY2 <= RD_DrawLine::qY1) {
    LVar9 = RD_DrawLine::qY1;
  }
  (r->sbox).Y2 = iVar11 + LVar9;
  LVar9 = RD_DrawLine::qX2;
  LVar10 = RD_DrawLine::qX2;
  if (RD_DrawLine::qX2 <= LVar4) {
    LVar10 = LVar4;
  }
  (r->sbox).X2 = LVar10 + iVar11;
  LVar10 = LVar6;
  if (LVar7 <= LVar6) {
    LVar10 = LVar7;
  }
  iVar11 = LVar10 - RD_DrawLine::qhthick;
  LVar10 = LVar9;
  if (LVar4 <= LVar9) {
    LVar10 = LVar4;
  }
  iVar12 = LVar10 - RD_DrawLine::qhthick;
  (r->sbox).Y1 = iVar11;
  (r->sbox).X1 = iVar12;
  (r->box).X1 = iVar12 - iVar1;
  (r->box).Y1 = iVar11 - iVar1;
  (r->box).X2 = (r->sbox).X2 + iVar1;
  (r->box).Y2 = (r->sbox).Y2 + iVar1;
  r->group = (ushort)RD_DrawLine::qgroup;
  BVar8 = AutoRouteParameters.is_odd;
  bVar14 = (byte)(((byte)RD_DrawLine::qis_bad & 1) << 5) | 0x40;
  (r->flags).field_0x1 = bVar14;
  BVar5 = RD_DrawLine::qis_45;
  r->came_from = ALL;
  *(byte *)&r->flags = BVar8 << 7 | BVar5 & 1U;
  if (LVar9 < LVar4) {
    uVar13 = (uint)(LVar7 <= LVar6);
  }
  else {
    uVar13 = 1;
    if (LVar7 < LVar6) {
      uVar13 = (uint)(LVar9 <= LVar4);
    }
  }
  (r->flags).field_0x1 = (byte)(uVar13 << 3) | bVar14;
  r->style = AutoRouteParameters.style;
  r->pass = AutoRouteParameters.pass;
  InitLists(r);
  b = RD_DrawLine::qsn;
  MergeNets(r,RD_DrawLine::qsn,NET);
  MergeNets(r,b,SUBNET);
  r_insert_entry(rd->layergrouptree[r->group],(BoxType *)r,1);
  if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
    paVar2 = PCB->Data;
    CVar3 = (PCB->LayerGroups).Entries[r->group][0];
    (*gui->set_line_width)(ar_gc,RD_DrawLine::qhthick * 2);
    (*gui->set_color)(ar_gc,paVar2->Layer[CVar3].Color);
    (*gui->draw_line)(ar_gc,RD_DrawLine::qX1,RD_DrawLine::qY1,RD_DrawLine::qX2,RD_DrawLine::qY2);
  }
  if (AutoRouteParameters.use_vias != '\0') {
    mtspace_add(rd->mtspace,(BoxType *)r,~-(uint)((*(byte *)&r->flags & 0x80) == 0) + EVEN,
                r->style->Keepaway);
  }
  RD_DrawLine::qX1 = X1;
  usedGroup[r->group] = '\x01';
  RD_DrawLine::qY1 = Y1;
  RD_DrawLine::qX2 = X2;
  RD_DrawLine::qY2 = Y2;
  RD_DrawLine::qhthick = halfthick;
  RD_DrawLine::qgroup = group;
  RD_DrawLine::qis_45 = is_45;
  RD_DrawLine::qis_bad = is_bad;
  RD_DrawLine::qsn = subnet;
  return;
}



// WARNING: Unknown calling convention

Boolean RD_DrawManhattanLine
                  (routedata_t *rd,BoxType *box1,BoxType *box2,CheapPointType start,
                  CheapPointType end,BDimension halfthick,Cardinal group,routebox_t *subnet,
                  Boolean is_bad,Boolean last_was_x)

{
  Boolean local_2a;
  LocationType local_24;
  LocationType local_20;
  
  local_20 = end.X;
  local_24 = start.Y;
  if (end.X == start.X) {
    RD_DrawLine(rd,end.X,start.Y,end.X,end.Y,halfthick,group,subnet,is_bad,'\0');
    local_2a = '\0';
  }
  else if (end.Y == start.Y) {
    RD_DrawLine(rd,start.X,end.Y,end.X,end.Y,halfthick,group,subnet,is_bad,'\0');
    local_2a = '\x01';
  }
  else {
    if ((((((end.X < box1->X1) || (box1->Y1 != start.Y && start.Y <= box1->Y1)) ||
          (box1->X2 == end.X || box1->X2 < end.X)) || (box1->Y2 == start.Y || box1->Y2 < start.Y))
        && (((box2->X1 != end.X && end.X <= box2->X1 || (box2->Y1 != start.Y && start.Y <= box2->Y1)
             ) || ((box2->X2 == end.X || box2->X2 < end.X ||
                   (box2->Y2 == start.Y || box2->Y2 < start.Y)))))) ||
       ((last_was_x == '\0' &&
        ((((box1->X1 <= start.X && (box1->Y1 == end.Y || box1->Y1 < end.Y)) &&
          ((box1->X2 != start.X && start.X <= box1->X2 && (box1->Y2 != end.Y && end.Y <= box1->Y2)))
          ) || ((((box2->X1 == start.X || box2->X1 < start.X &&
                  (box2->Y1 == end.Y || box2->Y1 < end.Y)) &&
                 (box2->X2 != start.X && start.X <= box2->X2)) &&
                (box2->Y2 != end.Y && end.Y <= box2->Y2)))))))) {
      local_20 = start.X;
      local_24 = end.Y;
      local_2a = '\x01';
    }
    else {
      local_2a = '\0';
    }
    RD_DrawLine(rd,start.X,start.Y,local_20,local_24,halfthick,group,subnet,is_bad,'\0');
    RD_DrawLine(rd,local_20,local_24,end.X,end.Y,halfthick,group,subnet,is_bad,'\0');
  }
  return local_2a;
}



// WARNING: Unknown calling convention

routebox_t *
mincost_target_to_point
          (CheapPointType *CostPoint,Cardinal CostPointLayer,rtree_t *targets,
          routebox_t *target_guess)

{
  mincost_target_closure mtc;
  
  mtc.nearest = target_guess;
  mtc.CostPoint = CostPoint;
  mtc.CostPointLayer = CostPointLayer;
  if (target_guess == (routebox_t *)0x0) {
    mtc.nearest_cost = 3e+28;
  }
  else {
    mtc.nearest_cost = cost_to_routebox(CostPoint,CostPointLayer,target_guess);
  }
  r_search(targets,(BoxType *)0x0,__region_within_guess,__found_new_guess,&mtc);
  return mtc.nearest;
}



// WARNING: Unknown calling convention

edge_t * CreateEdge(routebox_t *rb,LocationType CostPointX,LocationType CostPointY,
                   cost_t cost_to_point,routebox_t *mincost_target_guess,direction_t expand_dir,
                   rtree_t *targets)

{
  edge_t *peVar1;
  routebox_t *prVar2;
  int iVar3;
  edge_t *e;
  byte bVar4;
  
  bVar4 = 0;
  peVar1 = (edge_t *)calloc(1,0x2c);
  e = peVar1;
  for (iVar3 = 0xb; iVar3 != 0; iVar3 = iVar3 + -1) {
    e = (edge_t *)((int)e + (uint)bVar4 * -8 + 4);
    e->rb = (routebox_t *)0x0;
    e = e;
  }
  peVar1->rb = rb;
  if ((*(byte *)&rb->flags & 0x40) != 0) {
    rb->refcount = rb->refcount + 1;
  }
  peVar1->cost_to_point = cost_to_point;
  *(byte *)&peVar1->flags = *(byte *)&peVar1->flags & 0xef;
  (peVar1->cost_point).X = CostPointX;
  (peVar1->cost_point).Y = CostPointY;
  if (targets == (rtree_t *)0x0) {
    peVar1->mincost_target = mincost_target_guess;
  }
  else {
    prVar2 = mincost_target_to_point
                       (&peVar1->cost_point,(uint)rb->group,targets,mincost_target_guess);
    peVar1->mincost_target = prVar2;
  }
  peVar1->expand_dir = expand_dir;
  return peVar1;
}



// WARNING: Unknown calling convention

vector_t * path_conflicts(routebox_t *rb,routebox_t *conflictor,Boolean branch)

{
  vector_t *vector;
  
  if (branch == '\0') {
    vector = rb->conflicts_with;
    if (vector == (vector_t *)0x0) {
      vector = vector_create();
      rb->conflicts_with = vector;
    }
  }
  else {
    vector = vector_duplicate(rb->conflicts_with);
    rb->conflicts_with = vector;
  }
  vector_append(vector,conflictor);
  return rb->conflicts_with;
}



// WARNING: Unknown calling convention

routebox_t * FindOneInBox(rtree_t *rtree,routebox_t *rb)

{
  int iVar1;
  foib_info foib;
  BoxType r;
  
  r.X1 = (rb->sbox).X1;
  foib.intersect = (routebox_t *)0x0;
  r.Y1 = (rb->sbox).Y1;
  r.X2 = (rb->sbox).X2;
  r.Y2 = (rb->sbox).Y2;
  foib.box = &r;
  iVar1 = _setjmp((__jmp_buf_tag *)foib.env);
  if (iVar1 == 0) {
    r_search(rtree,&r,(_func_int_BoxType_ptr_void_ptr *)0x0,foib_rect_in_reg,&foib);
  }
  return foib.intersect;
}



// WARNING: Unknown calling convention

routebox_t *
FindRouteBoxOnLayerGroup(routedata_t *rd,LocationType X,LocationType Y,Cardinal layergroup)

{
  int iVar1;
  rb_info info;
  
  info.query.X2 = X + 1;
  info.query.Y2 = Y + 1;
  info.winner = (routebox_t *)0x0;
  info.query.X1 = X;
  info.query.Y1 = Y;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(rd->layergrouptree[layergroup],&info.query,(_func_int_BoxType_ptr_void_ptr *)0x0,
             __found_one_on_lg,&info);
  }
  return info.winner;
}



// WARNING: Unknown calling convention

int FindPin(BoxType *box,PinTypePtr *pin)

{
  int iVar1;
  fpin_info info;
  
  info.X = box->X1;
  info.pin = (PinTypePtr)0x0;
  info.Y = box->Y1;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    *pin = info.pin;
    return 0x100;
  }
  r_search(PCB->Data->pin_tree,box,(_func_int_BoxType_ptr_void_ptr *)0x0,fpin_rect,&info);
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    *pin = info.pin;
    return 1;
  }
  r_search(PCB->Data->via_tree,box,(_func_int_BoxType_ptr_void_ptr *)0x0,fpin_rect,&info);
  *pin = (PinTypePtr)0x0;
  return 0;
}



// WARNING: Unknown calling convention

routebox_t * FindThermable(rtree_t *rtree,routebox_t *rb)

{
  int iVar1;
  therm_info info;
  
  info.query.X2 = (rb->sbox).X2;
  info.query.Y1 = (rb->sbox).Y1;
  info.query.X1 = (rb->sbox).X1;
  info.plane = rb;
  info.query.Y2 = (rb->sbox).Y2;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(rtree,&info.query,(_func_int_BoxType_ptr_void_ptr *)0x0,ftherm_rect_in_reg,&info);
    info.plane = (routebox_t *)0x0;
  }
  return info.plane;
}



// WARNING: Unknown calling convention

int foib_rect_in_reg(BoxType *box,void *cl)

{
  int *piVar1;
  BoxType rbox;
  
  if ((*(byte *)((int)&box[2].Y2 + 1) & 1) == 0) {
    bloat_routebox((routebox_t *)box);
                    // WARNING: Load size is inaccurate
    piVar1 = *cl;
    if ((((rbox.X1 < piVar1[2]) && (*piVar1 < rbox.X2)) && (rbox.Y1 < piVar1[3])) &&
       (piVar1[1] < rbox.Y2)) {
      *(BoxType **)((int)cl + 4) = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int __found_one_on_lg(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  
  if ((*(byte *)&box[2].Y2 & 1) == 0) {
    iVar1 = *(int *)(box[4].Y2 + 0xc);
                    // WARNING: Load size is inaccurate
    if ((((*cl < box->X2 - iVar1) &&
         (iVar2 = box->X1 + iVar1, *(int *)((int)cl + 8) != iVar2 && iVar2 <= *(int *)((int)cl + 8))
         ) && (*(int *)((int)cl + 4) < box->Y2 - iVar1)) &&
       (iVar1 = iVar1 + box->Y1,
       *(int *)((int)cl + 0xc) != iVar1 && iVar1 <= *(int *)((int)cl + 0xc))) {
      iVar1 = box[2].X2;
      *(BoxType **)((int)cl + 0x10) = box;
      if (iVar1 == 7) {
        return 1;
      }
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int fpin_rect(BoxType *b,void *cl)

{
  if ((b[3].Y1 == *(int *)((int)cl + 4)) && (b[3].X2 == *(int *)((int)cl + 8))) {
    *(BoxType **)cl = b;
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0xc,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int ftherm_rect_in_reg(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int local_40;
  int local_30;
  int local_2c;
  int local_24;
  int local_20;
  
  iVar1 = box[2].X2;
                    // WARNING: Load size is inaccurate
  if ((iVar1 - 1U < 3) && (*(short *)&box[2].Y1 == *(short *)(*cl + 0x24))) {
    iVar2 = box[1].X2;
    iVar3 = box[1].Y1;
    local_20 = box[1].X1;
    if (iVar1 == 2) {
      if ((*(byte *)&box[2].Y2 & 2) == 0) {
        local_24 = *(int *)(box[4].Y2 + 4);
        local_2c = local_24 + *(int *)((int)cl + 4);
        local_30 = local_24 + *(int *)((int)cl + 8);
        local_40 = *(int *)((int)cl + 0xc) - local_24;
        local_24 = *(int *)((int)cl + 0x10) - local_24;
        local_20 = local_20 + (iVar2 - local_20) / 2;
        iVar3 = (box[1].Y2 - iVar3) / 2 + iVar3;
      }
      else {
        iVar1 = box[2].X1;
        local_2c = *(int *)(iVar1 + 0x24) + *(int *)((int)cl + 4);
        local_30 = *(int *)(iVar1 + 0x24) + *(int *)((int)cl + 8);
        local_40 = *(int *)((int)cl + 0xc) - *(int *)(iVar1 + 0x24);
        local_24 = *(int *)((int)cl + 0x10) - *(int *)(iVar1 + 0x24);
        local_20 = *(int *)(iVar1 + 0x34);
        iVar3 = *(int *)(iVar1 + 0x38);
      }
      if (local_40 <= local_20) {
        return 0;
      }
      if (iVar2 <= local_2c) {
        return 0;
      }
      if (local_24 <= iVar3) {
        return 0;
      }
    }
    else {
      if (iVar1 == 3) {
        local_30 = *(int *)(box[4].Y2 + 4);
      }
      else {
        local_30 = *(int *)(box[2].X1 + 0x24);
      }
      if (*(int *)((int)cl + 0xc) - local_30 <= local_20) {
        return 0;
      }
      if (iVar2 <= *(int *)((int)cl + 4) + local_30) {
        return 0;
      }
      if (*(int *)((int)cl + 0x10) - local_30 <= iVar3) {
        return 0;
      }
      local_30 = *(int *)((int)cl + 8) + local_30;
    }
    if (local_30 < box[1].Y2) {
      *(BoxType **)cl = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void touch_conflicts(vector_t *conflicts,int touch)

{
  vector_element_t *ppvVar1;
  vector_t *pvVar2;
  int iVar3;
  routebox_t *rb;
  vector_element_t pvVar4;
  vector_element_t pvVar5;
  int i;
  int N;
  routebox_t *__next_one__;
  byte local_28;
  
  N = 0;
  pvVar2 = touch_conflicts::last;
  if (touch != 0) {
    if ((touch_conflicts::last != (vector_t *)0x0) && (touch_conflicts::last != conflicts)) {
      touch_conflicts(touch_conflicts::last,0);
    }
    N = touch_conflicts::last_size;
    pvVar2 = conflicts;
    if (conflicts == (vector_t *)0x0) {
      return;
    }
  }
  touch_conflicts::last = pvVar2;
  iVar3 = vector_size(conflicts);
  if (N < iVar3) {
    local_28 = (byte)touch;
    do {
      pvVar4 = vector_element(conflicts,N);
      pvVar5 = pvVar4;
      if (pvVar4 != (vector_element_t)0x0) {
        do {
          ppvVar1 = (vector_element_t *)((int)pvVar5 + 0x5c);
          if ((*(byte *)((int)pvVar5 + 0x2c) & 2) == 0) {
            *(byte *)((int)pvVar5 + 0x2d) = *(byte *)((int)pvVar5 + 0x2d) & 0xfe | local_28 & 1;
          }
          pvVar5 = *ppvVar1;
        } while (pvVar4 != *ppvVar1);
      }
      N = N + 1;
    } while (N < iVar3);
  }
  if (touch != 0) {
    touch_conflicts::last_size = iVar3;
    return;
  }
  touch_conflicts::last = (vector_t *)0x0;
  touch_conflicts::last_size = 0;
  return;
}



// WARNING: Unknown calling convention

int __conflict_source(BoxType *box,void *cl)

{
  bool bVar1;
  
  bVar1 = (*(ushort *)&box[2].Y2 & 0x102) == 0;
  if (bVar1) {
    path_conflicts((routebox_t *)cl,(routebox_t *)box,'\0');
    touch_conflicts(*(vector_t **)((int)cl + 0x48),1);
  }
  return (uint)bVar1;
}



// WARNING: Unknown calling convention

void KillEdge(void *edge)

{
  edge_t *e;
  
                    // WARNING: Load size is inaccurate
  if ((*(byte *)&(*edge)->flags & 0x40) != 0) {
    RB_down_count(*edge);
  }
  if ((*(byte *)((int)edge + 0x28) & 0x10) != 0) {
    mtsFreeWork((vetting_t **)((int)edge + 0x20));
  }
  free(edge);
  return;
}



// WARNING: Unknown calling convention

void add_or_destroy_edge(routeone_state *s,edge_t *e)

{
  cost_t cost;
  
  cost = edge_cost(e,s->best_cost);
  e->cost = cost;
  if (s->best_cost <= cost) {
    KillEdge(e);
    return;
  }
  heap_insert(s->workheap,cost,e);
  return;
}



// WARNING: Unknown calling convention

void CreateSearchEdge(routeone_state *s,vetting_t *work,edge_t *parent,routebox_t *rb,
                     conflict_t conflict,rtree_t *targets,Boolean in_plane)

{
  routebox_t *prVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  LocationType LVar5;
  LocationType LVar6;
  bool bVar7;
  bool bVar8;
  double dVar9;
  double dVar10;
  byte bVar11;
  edge_t *data;
  int iVar12;
  int iVar13;
  routebox_t *target;
  edge_t *ne;
  cost_t cost;
  cost_t c1;
  cost_t c2;
  vetting_t *local_20 [4];
  
  bVar11 = 0;
  prVar1 = parent->mincost_target;
  iVar13 = (prVar1->sbox).Y2;
  iVar2 = (prVar1->sbox).X2;
  iVar3 = (rb->cost_point).X;
  iVar4 = (prVar1->sbox).X1;
  iVar12 = (prVar1->sbox).Y1;
  if (iVar3 < iVar4) {
    dVar9 = (double)(iVar4 - iVar3);
    bVar7 = dVar9 < 0.0;
  }
  else if (iVar3 < iVar2) {
    dVar9 = 0.0;
    bVar7 = false;
  }
  else {
    dVar9 = (double)((iVar2 + -1) - iVar3);
    bVar7 = dVar9 < 0.0;
  }
  iVar2 = (rb->cost_point).Y;
  if (iVar12 <= iVar2) {
    if (iVar2 < iVar13) {
      dVar10 = 0.0;
      bVar8 = false;
      goto LAB_0806f4bb;
    }
    iVar12 = iVar13 + -1;
  }
  dVar10 = (double)(iVar12 - iVar2);
  bVar8 = dVar10 < 0.0;
LAB_0806f4bb:
  if (bVar7) {
    dVar9 = -dVar9;
  }
  if (bVar8) {
    dVar10 = -dVar10;
  }
  if (dVar10 <= dVar9) {
    dVar9 = AutoRouteParameters.MinPenalty * dVar10 + dVar9;
  }
  else {
    dVar9 = dVar10 + AutoRouteParameters.MinPenalty * dVar9;
  }
  dVar9 = dVar9 + AutoRouteParameters.ViaCost + parent->cost_to_point;
  local_20[0] = work;
  if (dVar9 < s->best_cost) {
    data = (edge_t *)calloc(1,0x2c);
    ne = data;
    for (iVar13 = 0xb; iVar13 != 0; iVar13 = iVar13 + -1) {
      ne = (edge_t *)((int)ne + (uint)bVar11 * -8 + 4);
      ne->rb = (routebox_t *)0x0;
      ne = ne;
    }
    bVar11 = (byte)(((byte)in_plane & 1) << 5) | 0x10;
    *(byte *)&data->flags = bVar11;
    data->rb = rb;
    if ((*(byte *)&rb->flags & 0x40) != 0) {
      rb->refcount = rb->refcount + 1;
    }
    data->mincost_target = prVar1;
    data->work = local_20[0];
    *(byte *)&data->flags = ((byte)conflict & 3) * '\x02' | bVar11;
    LVar5 = (parent->cost_point).Y;
    LVar6 = (parent->cost_point).X;
    data->cost_to_point = parent->cost_to_point;
    data->cost = dVar9;
    (data->cost_point).Y = LVar5;
    (data->cost_point).X = LVar6;
    heap_insert(s->workheap,dVar9,data);
    return;
  }
  mtsFreeWork(local_20);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

Boolean IronDownAllUnfixedPaths(routedata_t *rd)

{
  char cVar1;
  routebox *prVar2;
  routebox *prVar3;
  uint uVar4;
  DataTypePtr paVar5;
  Cardinal CVar6;
  anon_union_4_7_c208ad69_for_parent aVar7;
  routebox *prVar8;
  int iVar9;
  RouteStyleType *pRVar10;
  FlagType Flags;
  FlagType Flags_00;
  float fVar11;
  float fVar12;
  Cardinal *pCVar13;
  uint uVar14;
  int i;
  anon_enum_32 aVar15;
  int iVar16;
  int iVar17;
  LineTypePtr Ptr2;
  PinTypePtr paVar18;
  sbyte sVar19;
  ushort uVar20;
  int iVar21;
  routebox_t *__next_one__;
  LayerTypePtr layer;
  LayerTypePtr Layer;
  routebox_t *prVar22;
  routebox *prVar23;
  int iVar24;
  int iVar25;
  int in_GS_OFFSET;
  double th;
  Boolean local_5d;
  int local_58;
  routebox_t *local_54;
  routebox_t *local_48;
  PinTypePtr local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_5d = '\0';
  local_54 = rd->first_net;
  if (rd->first_net != (routebox_t *)0x0) {
    do {
      prVar2 = (local_54->different_net).next;
      local_48 = local_54;
      do {
        while (prVar3 = (local_48->same_net).next, prVar23 = prVar3,
              (*(byte *)&local_48->flags & 2) != 0) {
LAB_0806f6ca:
          local_48 = prVar3;
          if (prVar3 == local_54) goto LAB_0806f743;
        }
        Layer = (LayerTypePtr)0x0;
        uVar20 = local_48->group;
        uVar4 = (PCB->LayerGroups).Number[uVar20];
        if (uVar4 != 0) {
          paVar5 = PCB->Data;
          CVar6 = (PCB->LayerGroups).Entries[uVar20][0];
          pCVar13 = (PCB->LayerGroups).Entries[uVar20];
          uVar14 = 0;
          cVar1 = paVar5->Layer[CVar6].On;
          Layer = paVar5->Layer + CVar6;
          while ((pCVar13 = pCVar13 + 1, cVar1 == '\0' && (uVar14 = uVar14 + 1, uVar14 < uVar4))) {
            cVar1 = paVar5->Layer[*pCVar13].On;
            Layer = paVar5->Layer + *pCVar13;
          }
        }
        aVar15 = local_48->type;
        if (aVar15 == DBUS_WATCH_ERROR) {
          iVar17 = (local_48->style->Thick + 1) / 2;
          iVar25 = (local_48->sbox).Y2;
          iVar16 = (local_48->sbox).X1;
          iVar21 = (local_48->sbox).X2;
          iVar9 = (local_48->sbox).Y1;
          fVar12 = (float)(iVar17 * 2 + 1);
          iVar24 = iVar21 - iVar17;
          local_58 = iVar17 + iVar16;
          fVar11 = (float)(iVar21 - iVar16) - fVar12;
          iVar16 = iVar17 + iVar9;
          fVar12 = (float)(iVar25 - iVar9) - fVar12;
          iVar25 = iVar25 - iVar17;
          if (local_58 + 1 == iVar24) {
            iVar24 = local_58;
          }
          if (iVar16 + 1 == iVar25) {
            iVar25 = iVar16;
          }
          total_wire_length = SQRT(fVar12 * fVar12 + fVar11 * fVar11) + total_wire_length;
          iVar21 = iVar24;
          if (((local_48->flags).field_0x1 & 8) != 0) {
            iVar21 = local_58;
            local_58 = iVar24;
          }
          MakeFlags((-(uint)(((PCB->Flags).f & 0x800) == 0) & 0xffffffe0) + 0xa0);
          Flags.t[0] = (undefined)local_28;
          Flags.t[1] = local_28._1_1_;
          Flags.t[2] = local_28._2_1_;
          Flags.t[3] = local_28._3_1_;
          Flags.f = local_2c;
          Flags.t[4] = (undefined)local_24;
          Flags.t[5] = local_24._1_1_;
          Flags.t[6] = local_24._2_1_;
          Flags.t[7] = local_24._3_1_;
          Ptr2 = CreateDrawnLineOnLayer
                           (Layer,local_58,iVar16,iVar21,iVar25,local_48->style->Thick,
                            local_48->style->Keepaway * 2,Flags);
          (local_48->parent).generic = Ptr2;
          if (Ptr2 != (LineTypePtr)0x0) {
            AddObjectToCreateUndoList(4,Layer,Ptr2,Ptr2);
            local_5d = '\x01';
          }
          goto LAB_0806f6ca;
        }
        if (1 < (uint)(aVar15 + FL_BACK)) goto LAB_0806f6ca;
        prVar22 = local_48;
        if (aVar15 == GDK_CAP_PROJECTING) {
          prVar22 = (local_48->parent).via_shadow;
        }
        iVar16 = (local_48->sbox).X1;
        iVar25 = (local_48->sbox).Y1;
        total_via_count = total_via_count + 1;
        if ((prVar22->parent).pad == (PadTypePtr)0x0) {
          iVar21 = (prVar22->style->Diameter + 1) / 2;
          MakeFlags(0x80);
          pRVar10 = prVar22->style;
          Flags_00.t[0] = (undefined)local_34;
          Flags_00.t[1] = local_34._1_1_;
          Flags_00.t[2] = local_34._2_1_;
          Flags_00.t[3] = local_34._3_1_;
          Flags_00.f = local_38;
          Flags_00.t[4] = (undefined)local_30;
          Flags_00.t[5] = local_30._1_1_;
          Flags_00.t[6] = local_30._2_1_;
          Flags_00.t[7] = local_30._3_1_;
          paVar18 = CreateNewVia(PCB->Data,iVar21 + iVar16,iVar21 + iVar25,pRVar10->Diameter,
                                 pRVar10->Keepaway * 2,0,pRVar10->Hole,(char *)0x0,Flags_00);
          (prVar22->parent).generic = paVar18;
          if (paVar18 == (PinTypePtr)0x0) {
            aVar15 = local_48->type;
          }
          else {
            AddObjectToCreateUndoList(1,paVar18,paVar18,paVar18);
            local_5d = '\x01';
            aVar15 = local_48->type;
          }
        }
        if (aVar15 != GDK_CAP_PROJECTING) goto LAB_0806f6ca;
        aVar7 = prVar22->parent;
        local_48->type = DBUS_BUS_STARTER;
        local_48->parent = aVar7;
        local_48 = prVar3;
      } while (prVar3 != local_54);
LAB_0806f743:
      do {
        prVar8 = (prVar23->same_net).next;
        if (prVar23->type != DBUS_WATCH_HANGUP) {
LAB_0806f738:
          prVar23 = prVar8;
          if (prVar3 == prVar8) break;
          goto LAB_0806f743;
        }
        local_3c = (PinTypePtr)0x0;
        iVar16 = FindPin(&prVar23->box,&local_3c);
        if (local_3c == (PinTypePtr)0x0) goto LAB_0806f738;
        paVar18 = (PinTypePtr)local_3c->Element;
        if ((PinTypePtr)local_3c->Element == (PinTypePtr)0x0) {
          paVar18 = local_3c;
        }
        AddObjectToClearPolyUndoList(iVar16,paVar18,local_3c,local_3c,'\0');
        RestoreToPolygon((DataType *)PCB->Data,1,((DataType *)PCB->Data)->Layer + prVar23->layer,
                         local_3c);
        paVar18 = (PinTypePtr)local_3c->Element;
        if ((PinTypePtr)local_3c->Element == (PinTypePtr)0x0) {
          paVar18 = local_3c;
        }
        AddObjectToFlagUndoList(iVar16,paVar18,local_3c,local_3c);
        uVar20 = prVar23->layer >> 1;
        sVar19 = (sbyte)((prVar23->layer & 1) << 2);
        (local_3c->Flags).t[uVar20] =
             ~(byte)(0xf << sVar19) & (local_3c->Flags).t[uVar20] |
             (byte)((int)PCB->ThermStyle << sVar19);
        paVar18 = (PinTypePtr)local_3c->Element;
        if ((PinTypePtr)local_3c->Element == (PinTypePtr)0x0) {
          paVar18 = local_3c;
        }
        AddObjectToClearPolyUndoList(iVar16,paVar18,local_3c,local_3c,'\x01');
        ClearFromPolygon((DataType *)PCB->Data,1,((DataType *)PCB->Data)->Layer + prVar23->layer,
                         local_3c);
        local_5d = '\x01';
        prVar23 = prVar8;
      } while (prVar3 != prVar8);
      local_54 = prVar2;
    } while (prVar2 != rd->first_net);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_5d;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void add_via_sites(routeone_state *s,routeone_via_site_state *vss,mtspace_t *mtspace,
                  routebox_t *within,conflict_t within_conflict_level,edge_t *parent_edge,
                  rtree_t *targets,BDimension shrink,Boolean in_plane)

{
  vetting_t *work_00;
  vetting_t *work;
  BoxType region;
  
  region.X1 = (within->sbox).X1;
  region.Y1 = (within->sbox).Y1;
  region.X2 = (within->sbox).X2;
  region.Y2 = (within->sbox).Y2;
  work_00 = mtspace_query_rect(mtspace,&region,((AutoRouteParameters.style)->Diameter + 1) / 2,
                               (AutoRouteParameters.style)->Keepaway,(vetting_t *)0x0,
                               vss->free_space_vec,vss->lo_conflict_space_vec,
                               vss->hi_conflict_space_vec,AutoRouteParameters.is_odd,
                               AutoRouteParameters.with_conflicts,&parent_edge->cost_point);
  if (work_00 != (vetting_t *)0x0) {
    CreateSearchEdge(s,work_00,parent_edge,within,within_conflict_level,targets,in_plane);
  }
  return;
}



// WARNING: Unknown calling convention

void DestroyRouteData(routedata_t **rd)

{
  int *piVar1;
  int i;
  int iVar2;
  int iVar3;
  
  if (0 < PCB->Data->LayerN) {
    iVar2 = 0;
    do {
      iVar3 = iVar2 + 1;
      r_destroy_tree((*rd)->layergrouptree + iVar2);
      piVar1 = &PCB->Data->LayerN;
      iVar2 = iVar3;
    } while (*piVar1 != iVar3 && iVar3 <= *piVar1);
  }
  if (AutoRouteParameters.use_vias != '\0') {
    mtspace_destroy(&(*rd)->mtspace);
  }
  free(*rd);
  *rd = (routedata_t *)0x0;
  return;
}



Boolean __regparm3 boink_box(routebox_t *rb,E_result *res,direction_t dir)

{
  LocationType *pLVar1;
  int iVar2;
  LocationType bloat;
  int iVar3;
  
  iVar2 = rb->style->Keepaway;
  iVar3 = 0;
  if (Expand::ans.keep < iVar2) {
    iVar3 = Expand::ans.keep - iVar2;
  }
  if ((*(byte *)&rb->flags & 0x10) != 0) {
    iVar3 = Expand::ans.bloat;
  }
  if (res != (E_result *)&DAT_00000001) {
    if ((res == (E_result *)0x0) || (res == (E_result *)0x2)) {
      pLVar1 = &(rb->sbox).X2;
      if (*pLVar1 == Expand::ans.inflated.X1 + iVar3 || *pLVar1 < Expand::ans.inflated.X1 + iVar3) {
        return '\0';
      }
      return (rb->sbox).X1 < Expand::ans.inflated.X2 - iVar3;
    }
    if (res != (E_result *)0x3) {
      return '\0';
    }
  }
  if (Expand::ans.inflated.Y2 - iVar3 <= (rb->sbox).Y1) {
    return '\0';
  }
  pLVar1 = &(rb->sbox).Y2;
  return *pLVar1 != iVar3 + Expand::ans.inflated.Y1 && iVar3 + Expand::ans.inflated.Y1 <= *pLVar1;
}



// WARNING: Unknown calling convention

E_result * Expand(rtree_t *rtree,edge_t *e,BoxType *box)

{
  ushort uVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  Boolean BVar6;
  direction_t dir;
  direction_t extraout_ECX;
  direction_t extraout_ECX_00;
  direction_t extraout_ECX_01;
  direction_t dVar7;
  uint uVar8;
  
  Expand::ans.w = (routebox_t *)0x0;
  Expand::ans.s = (routebox_t *)0x0;
  Expand::ans.bloat = AutoRouteParameters.bloat;
  Expand::ans.orig.X1 = box->X1;
  Expand::ans.e = (routebox_t *)0x0;
  Expand::ans.n = (routebox_t *)0x0;
  Expand::ans.orig.Y1 = box->Y1;
  Expand::ans.orig.X2 = box->X2;
  Expand::ans.orig.Y2 = box->Y2;
  if (ALL < e->expand_dir) {
    Expand::ans.done = 0;
    goto LAB_0806fd2a;
  }
  switch(e->expand_dir) {
  case NORTH:
    Expand::ans.done = 0xe;
    bVar3 = false;
    bVar2 = false;
    Expand::ans.inflated.Y1 = 0;
    bVar5 = false;
    bVar4 = true;
    Expand::ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.X2 = AutoRouteParameters.bloat + box->X2;
    Expand::ans.inflated.Y2 = box->Y2;
    Expand::ans.parent = e->rb;
    break;
  case EAST:
    Expand::ans.done = 0xd;
    bVar3 = false;
    bVar2 = false;
    bVar5 = true;
    bVar4 = false;
    Expand::ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
    Expand::ans.inflated.X1 = box->X1;
    Expand::ans.inflated.X2 = PCB->MaxWidth;
    Expand::ans.parent = e->rb;
    break;
  case SOUTH:
    Expand::ans.done = 0xb;
    bVar3 = false;
    bVar2 = true;
    bVar5 = false;
    bVar4 = false;
    Expand::ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.X2 = AutoRouteParameters.bloat + box->X2;
    Expand::ans.inflated.Y1 = box->Y1;
    Expand::ans.inflated.Y2 = PCB->MaxHeight;
    Expand::ans.parent = e->rb;
    break;
  case WEST:
    Expand::ans.done = 7;
    bVar3 = true;
    bVar2 = false;
    Expand::ans.inflated.X1 = 0;
    bVar5 = false;
    bVar4 = false;
    Expand::ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
    Expand::ans.inflated.X2 = box->X2;
    Expand::ans.parent = e->rb;
    break;
  case NE:
    Expand::ans.done = 0xc;
    Expand::ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
    Expand::ans.inflated.X2 = PCB->MaxWidth;
    Expand::ans.inflated.Y1 = 0;
    goto LAB_0806fd2a;
  case SE:
    Expand::ans.done = 9;
    Expand::ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.X2 = PCB->MaxWidth;
    Expand::ans.inflated.Y2 = PCB->MaxHeight;
    goto LAB_0806fd2a;
  case SW:
    Expand::ans.done = 3;
    Expand::ans.inflated.X1 = 0;
    Expand::ans.inflated.X2 = box->X2 + AutoRouteParameters.bloat;
    Expand::ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    Expand::ans.inflated.Y2 = PCB->MaxHeight;
    goto LAB_0806fd2a;
  case NW:
    Expand::ans.done = 6;
    Expand::ans.inflated.X1 = 0;
    Expand::ans.inflated.Y1 = 0;
    Expand::ans.inflated.X2 = box->X2 + AutoRouteParameters.bloat;
    Expand::ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
LAB_0806fd2a:
    Expand::ans.parent = e->rb;
    bVar3 = false;
    bVar2 = false;
    bVar5 = false;
    bVar4 = false;
    break;
  case ALL:
    Expand::ans.parent = e->rb;
    dVar7 = (Expand::ans.parent)->came_from;
    if (dVar7 == EAST) {
      bVar3 = false;
      bVar2 = false;
      Expand::ans.inflated.Y1 = 0;
      bVar5 = true;
      bVar4 = false;
      Expand::ans.inflated.X2 = PCB->MaxWidth;
      Expand::ans.inflated.Y2 = PCB->MaxHeight;
      Expand::ans.done = 8;
      Expand::ans.inflated.X1 = Expand::ans.orig.X1;
      break;
    }
    Expand::ans.inflated.X1 = 0;
    if (dVar7 == SOUTH) {
      Expand::ans.inflated.X2 = PCB->MaxWidth;
      Expand::ans.inflated.Y2 = PCB->MaxHeight;
      Expand::ans.inflated.Y1 = Expand::ans.orig.Y1;
LAB_08070226:
      Expand::ans.done = 1;
      bVar3 = false;
      bVar2 = true;
      bVar5 = false;
      bVar4 = false;
    }
    else {
      Expand::ans.inflated.Y1 = 0;
      if (dVar7 == WEST) {
        Expand::ans.inflated.Y2 = PCB->MaxHeight;
        Expand::ans.inflated.X2 = Expand::ans.orig.X2;
      }
      else {
        Expand::ans.inflated.X2 = PCB->MaxWidth;
        if (dVar7 == NORTH) {
          bVar3 = false;
          bVar2 = false;
          Expand::ans.done = 4;
          bVar5 = false;
          bVar4 = true;
          Expand::ans.inflated.Y2 = Expand::ans.orig.Y2;
          break;
        }
        Expand::ans.inflated.Y2 = PCB->MaxHeight;
        if (dVar7 == SOUTH) goto LAB_08070226;
        if (dVar7 != WEST) {
          Expand::ans.done = 0;
          bVar3 = false;
          bVar2 = false;
          bVar5 = false;
          bVar4 = false;
          break;
        }
      }
      Expand::ans.done = 2;
      bVar3 = true;
      bVar2 = false;
      bVar5 = false;
      bVar4 = false;
    }
  }
  Expand::ans.keep = (Expand::ans.parent)->style->Keepaway;
  uVar1 = *(ushort *)&((Expand::ans.parent)->flags).field_0x0;
  while (((uVar1 & 0x440) == 0x40 && (((Expand::ans.parent)->flags).is_thermal == 0))) {
    Expand::ans.parent = (routebox_t *)((Expand::ans.parent)->parent).pad;
    uVar1 = *(ushort *)&((PointType *)&(Expand::ans.parent)->flags)->X;
  }
  r_search(rtree,&Expand::ans.inflated,(_func_int_BoxType_ptr_void_ptr *)0x0,__Expand_this_rect,
           &Expand::ans);
  dVar7 = dir;
  if ((Expand::ans.n == (routebox_t *)0x0) ||
     (BVar6 = boink_box(Expand::ans.n,(E_result *)0x0,dir), dVar7 = extraout_ECX, BVar6 != '\0')) {
    Expand::ans.done = Expand::ans.done | 1;
  }
  else {
    Expand::ans.inflated.Y1 = 0;
  }
  uVar8 = Expand::ans.done;
  if ((Expand::ans.e == (routebox_t *)0x0) ||
     (BVar6 = boink_box(Expand::ans.e,(E_result *)&DAT_00000001,dVar7), dVar7 = extraout_ECX_00,
     BVar6 != '\0')) {
    uVar8 = uVar8 | 2;
    Expand::ans.done = uVar8;
  }
  else {
    Expand::ans.inflated.X2 = PCB->MaxWidth;
  }
  if ((Expand::ans.s == (routebox_t *)0x0) ||
     (BVar6 = boink_box(Expand::ans.s,(E_result *)0x2,dVar7), dVar7 = extraout_ECX_01, BVar6 != '\0'
     )) {
    uVar8 = uVar8 | 4;
    Expand::ans.done = uVar8;
  }
  else {
    Expand::ans.inflated.Y2 = PCB->MaxHeight;
  }
  if ((Expand::ans.w == (routebox_t *)0x0) ||
     (BVar6 = boink_box(Expand::ans.w,(E_result *)0x3,dVar7), BVar6 != '\0')) {
    uVar8 = uVar8 | 8;
    Expand::ans.done = uVar8;
  }
  else {
    Expand::ans.inflated.X1 = 0;
  }
  if (uVar8 != 0xf) {
    r_search(rtree,&Expand::ans.inflated,(_func_int_BoxType_ptr_void_ptr *)0x0,__Expand_this_rect,
             &Expand::ans);
  }
  if (!bVar2) {
    Expand::ans.inflated.Y1 = Expand::ans.inflated.Y1 + Expand::ans.bloat;
  }
  if (!bVar3) {
    Expand::ans.inflated.X2 = Expand::ans.inflated.X2 - Expand::ans.bloat;
  }
  if (!bVar4) {
    Expand::ans.inflated.Y2 = Expand::ans.inflated.Y2 - Expand::ans.bloat;
  }
  if (!bVar5) {
    Expand::ans.inflated.X1 = Expand::ans.inflated.X1 + Expand::ans.bloat;
  }
  return &Expand::ans;
}



// WARNING: Unknown calling convention

routebox_t *
CreateExpansionArea(BoxType *area,Cardinal group,routebox_t *parent,Boolean relax_edge_requirements,
                   edge_t *src_edge)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  double dVar5;
  double dVar6;
  RouteStyleType *pRVar7;
  routebox_t *prVar8;
  routebox *prVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  routebox_t *rb;
  byte bVar13;
  cost_t r;
  ushort local_28;
  
  bVar13 = 0;
  prVar8 = (routebox_t *)calloc(1,0x7c);
  rb = prVar8;
  for (iVar10 = 0x1f; iVar10 != 0; iVar10 = iVar10 + -1) {
    rb = (routebox_t *)((int)rb + (uint)bVar13 * -8 + 4);
    (rb->box).X1 = 0;
    rb = rb;
  }
  prVar8->type = EXPANSION_AREA;
  local_28 = (ushort)group;
  iVar10 = area->Y2;
  iVar2 = area->X2;
  iVar12 = area->Y1;
  iVar11 = area->X1;
  prVar8->group = local_28;
  puVar1 = &(prVar8->flags).field_0x1;
  *puVar1 = *puVar1 | 0x40;
  (prVar8->box).X1 = iVar11;
  (prVar8->box).Y1 = iVar12;
  (prVar8->box).X2 = iVar2;
  (prVar8->box).Y2 = iVar10;
  (prVar8->sbox).X1 = iVar11;
  (prVar8->sbox).Y1 = iVar12;
  (prVar8->sbox).X2 = iVar2;
  (prVar8->sbox).Y2 = iVar10;
  prVar9 = parent;
  if ((*(ushort *)&parent->flags & 0x440) == 0x40) {
    uVar3 = (parent->flags).is_thermal;
    while ((uVar3 == 0 &&
           (prVar9 = (prVar9->parent).via_shadow, (*(ushort *)&prVar9->flags & 0x440) == 0x40))) {
      uVar3 = (prVar9->flags).is_thermal;
    }
  }
  iVar4 = (prVar9->cost_point).X;
  (prVar8->parent).via_shadow = prVar9;
  if ((iVar11 <= iVar4) && (iVar11 = iVar4, iVar2 <= iVar4)) {
    iVar11 = iVar2 + -1;
  }
  iVar2 = (prVar9->cost_point).Y;
  if ((iVar12 <= iVar2) && (iVar12 = iVar2, iVar10 <= iVar2)) {
    iVar12 = iVar10 + -1;
  }
  (prVar8->cost_point).X = iVar11;
  iVar10 = (prVar9->cost_point).X;
  (prVar8->cost_point).Y = iVar12;
  iVar2 = (prVar9->cost_point).Y;
  dVar6 = (double)x_cost[group & 0xffff] * (double)(iVar10 - iVar11);
  dVar5 = (double)y_cost[group & 0xffff] * (double)(iVar2 - iVar12);
  if (dVar6 < 0.0) {
    dVar6 = -dVar6;
  }
  if (dVar5 < 0.0) {
    dVar5 = -dVar5;
  }
  dVar5 = dVar5 + dVar6;
  if ((iVar11 != iVar10) && (iVar12 != iVar2)) {
    dVar5 = dVar5 + AutoRouteParameters.JogPenalty;
  }
  prVar8->cost = dVar5 + prVar9->cost;
  if ((*(byte *)&prVar9->flags & 0x40) != 0) {
    prVar9->refcount = prVar9->refcount + 1;
  }
  pRVar7 = AutoRouteParameters.style;
  *(byte *)&prVar8->flags = *(byte *)&prVar8->flags | 0x50;
  prVar8->style = pRVar7;
  prVar8->conflicts_with = parent->conflicts_with;
  prVar8->came_from = src_edge->expand_dir;
  return prVar8;
}



// WARNING: Unknown calling convention

routebox_t * CreateBridge(BoxType *area,routebox_t *parent,direction_t dir)

{
  undefined *puVar1;
  double dVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  RouteStyleType *pRVar7;
  double dVar8;
  double dVar9;
  routebox_t *prVar10;
  int iVar11;
  routebox_t *prVar12;
  int iVar13;
  int iVar14;
  routebox_t *rb;
  byte bVar15;
  cost_t r;
  
  bVar15 = 0;
  prVar10 = (routebox_t *)calloc(1,0x7c);
  rb = prVar10;
  for (iVar13 = 0x1f; iVar13 != 0; iVar13 = iVar13 + -1) {
    rb = (routebox_t *)((int)rb + (uint)bVar15 * -8 + 4);
    (rb->box).X1 = 0;
    rb = rb;
  }
  prVar10->type = EXPANSION_AREA;
  iVar13 = area->Y2;
  iVar4 = area->X2;
  iVar14 = area->Y1;
  iVar11 = area->X1;
  puVar1 = &(prVar10->flags).field_0x1;
  *puVar1 = *puVar1 | 0x40;
  (prVar10->box).X1 = iVar11;
  (prVar10->box).Y2 = iVar13;
  (prVar10->sbox).Y2 = iVar13;
  uVar3 = parent->group;
  (prVar10->box).Y1 = iVar14;
  (prVar10->box).X2 = iVar4;
  (prVar10->sbox).X1 = iVar11;
  prVar10->group = uVar3;
  (prVar10->sbox).Y1 = iVar14;
  (prVar10->sbox).X2 = iVar4;
  prVar10->came_from = dir;
  iVar5 = (parent->cost_point).X;
  if ((iVar11 <= iVar5) && (iVar11 = iVar4 + -1, iVar5 < iVar4)) {
    iVar11 = iVar5;
  }
  iVar4 = (parent->cost_point).Y;
  if ((iVar14 <= iVar4) && (iVar14 = iVar13 + -1, iVar4 < iVar13)) {
    iVar14 = iVar4;
  }
  dVar2 = parent->cost;
  (prVar10->cost_point).X = iVar11;
  (prVar10->cost_point).Y = iVar14;
  dVar9 = (double)x_cost[uVar3] * (double)(iVar5 - iVar11);
  dVar8 = (double)y_cost[uVar3] * (double)(iVar4 - iVar14);
  if (dVar9 < 0.0) {
    dVar9 = -dVar9;
  }
  if (dVar8 < 0.0) {
    dVar8 = -dVar8;
  }
  dVar8 = dVar8 + dVar9;
  if ((iVar11 != iVar5) && (iVar14 != iVar4)) {
    dVar8 = dVar8 + AutoRouteParameters.JogPenalty;
  }
  uVar3 = *(ushort *)&parent->flags;
  prVar10->cost = dVar8 + dVar2;
  prVar12 = parent;
  if ((uVar3 & 0x440) == 0x40) {
    uVar6 = (parent->flags).is_thermal;
    while ((uVar6 == 0 &&
           (prVar12 = (routebox_t *)(prVar12->parent).pin,
           (*(ushort *)&prVar12->flags & 0x440) == 0x40))) {
      uVar6 = (prVar12->flags).is_thermal;
    }
  }
  (prVar10->parent).pin = (PinTypePtr)prVar12;
  if ((*(byte *)&prVar12->flags & 0x40) != 0) {
    prVar12->refcount = (int)((int)prVar12->refcount + 1);
  }
  pRVar7 = parent->style;
  *(byte *)&prVar10->flags = *(byte *)&prVar10->flags | 0x50;
  prVar10->style = pRVar7;
  prVar10->conflicts_with = parent->conflicts_with;
  return prVar10;
}



edge_t * __regparm3
CreateEdge2(routebox_t *rb,direction_t expand_dir,edge_t *previous_edge,rtree_t *targets,
           routebox_t *guess)

{
  double dVar1;
  double dVar2;
  edge_t *peVar3;
  int CostPointY;
  int CostPointX;
  cost_t d;
  int local_34;
  int local_30;
  int local_2c;
  LocationType local_28;
  int local_24;
  
  local_2c = (rb->sbox).X2;
  local_34 = (rb->sbox).Y2;
  CostPointX = (rb->sbox).X1;
  CostPointY = (rb->sbox).Y1;
  if (expand_dir == EAST) {
    local_28 = (previous_edge->cost_point).Y;
    local_24 = (previous_edge->cost_point).X;
    CostPointX = local_2c + -1;
    if (CostPointX <= local_24) goto LAB_08070769;
LAB_08070682:
    local_30 = local_24 - CostPointX;
  }
  else {
    if (expand_dir == NORTH) {
      local_34 = CostPointY + 1;
    }
    else if (expand_dir == SOUTH) {
      CostPointY = local_34 + -1;
    }
    else if (expand_dir == WEST) {
      local_2c = CostPointX + 1;
    }
    local_28 = (previous_edge->cost_point).Y;
    local_24 = (previous_edge->cost_point).X;
    if (local_24 < CostPointX) goto LAB_08070682;
LAB_08070769:
    local_30 = 0;
    CostPointX = local_24;
    if (local_2c <= local_24) {
      CostPointX = local_2c + -1;
      local_30 = local_24 - CostPointX;
    }
  }
  if (CostPointY <= local_28) {
    local_2c = 0;
    CostPointY = local_28;
    if (local_28 < local_34) goto LAB_080706a3;
    CostPointY = local_34 + -1;
  }
  local_2c = local_28 - CostPointY;
LAB_080706a3:
  dVar2 = (double)x_cost[rb->group] * (double)local_30;
  dVar1 = (double)y_cost[rb->group] * (double)local_2c;
  if (dVar2 < 0.0) {
    dVar2 = -dVar2;
  }
  if (dVar1 < 0.0) {
    dVar1 = -dVar1;
  }
  dVar1 = dVar1 + dVar2;
  if ((CostPointX != local_24) && (CostPointY != local_28)) {
    dVar1 = dVar1 + AutoRouteParameters.JogPenalty;
  }
  if (expand_dir != previous_edge->expand_dir) {
    dVar1 = dVar1 + AutoRouteParameters.JogPenalty;
  }
  if (targets == (rtree_t *)0x0) {
    targets = (rtree_t *)previous_edge->mincost_target;
  }
  peVar3 = CreateEdge(rb,CostPointX,CostPointY,dVar1 + previous_edge->cost_to_point,
                      (routebox_t *)targets,expand_dir,(rtree_t *)0x0);
  return peVar3;
}



// WARNING: Unknown calling convention

void do_via_search(edge_t *search,routeone_state *s,routeone_via_site_state *vss,mtspace_t *mtspace,
                  rtree_t *targets)

{
  undefined *puVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  routebox_t *rb_00;
  int iVar5;
  int iVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  byte bVar10;
  vetting_t *work;
  int iVar11;
  int *piVar12;
  routebox_t *rb_01;
  uint uVar13;
  edge_t *ne;
  routebox_t *prVar14;
  int iVar15;
  int iVar16;
  PCBTypePtr pPVar17;
  int iVar18;
  int j;
  Cardinal group;
  routebox_t *rb;
  cost_t y_dist;
  cost_t x_dist;
  cost_t r;
  cost_t r_1;
  vector_t *local_78;
  int local_6c;
  int local_68;
  int local_64;
  cost_t scale [3];
  BoxType cliparea;
  CheapPointType pnt;
  
  iVar3 = (AutoRouteParameters.style)->Diameter;
  iVar4 = (AutoRouteParameters.style)->Keepaway;
  work = mtspace_query_rect(mtspace,(BoxType *)0x0,0,0,search->work,vss->free_space_vec,
                            vss->lo_conflict_space_vec,vss->hi_conflict_space_vec,
                            AutoRouteParameters.is_odd,AutoRouteParameters.with_conflicts,
                            (CheapPointType *)0x0);
  rb_00 = search->rb;
  local_6c = 0;
  bVar10 = *(byte *)&search->flags >> 1 & 3;
LAB_08070882:
  if (local_6c == 0) {
    local_78 = vss->free_space_vec;
  }
  else if (local_6c == 1) {
    local_78 = vss->lo_conflict_space_vec;
  }
  else {
    local_78 = vss->hi_conflict_space_vec;
  }
  iVar16 = (iVar3 + 1) / 2 + iVar4;
  do {
    do {
      iVar11 = vector_is_empty(local_78);
      while( true ) {
        if (iVar11 != 0) {
          local_6c = local_6c + 1;
          if (local_6c == 3) {
            bVar2 = *(byte *)&search->flags;
            *(byte *)&search->flags = bVar2 & 0xef;
            if (work != (vetting_t *)0x0) {
              CreateSearchEdge(s,work,search,rb_00,(uint)bVar10,targets,bVar2 >> 5 & 1);
            }
            return;
          }
          goto LAB_08070882;
        }
        piVar12 = (int *)vector_remove_last(local_78);
        if ((local_6c == 0) || (AutoRouteParameters.with_conflicts != '\0')) break;
        free(piVar12);
        iVar11 = vector_is_empty(local_78);
      }
      cliparea.Y1 = iVar16 + piVar12[1];
      cliparea.X1 = iVar16 + *piVar12;
      cliparea.Y2 = (piVar12[3] + 1) - iVar16;
      cliparea.X2 = (piVar12[2] + 1) - iVar16;
      free(piVar12);
    } while (PCB->Data->LayerN < 1);
    group = 0;
    pPVar17 = PCB;
    do {
      if ((rb_00->group != group) && (is_layer_group_active[group] != '\0')) {
        scale[0] = 1.0;
        scale[1] = AutoRouteParameters.LastConflictPenalty;
        scale[2] = AutoRouteParameters.ConflictPenalty;
        rb_01 = CreateExpansionArea(&cliparea,group,rb_00,'\x01',search);
        puVar1 = &(rb_01->flags).field_0x1;
        *puVar1 = *puVar1 | 4;
        rb_01->came_from = ALL;
        if ((*(byte *)&search->flags & 0x20) == 0) {
          iVar18 = (search->cost_point).X;
          iVar11 = (rb_01->sbox).X1;
          prVar14 = search->mincost_target;
          if (iVar18 < iVar11) {
            local_68 = iVar11 - iVar18;
          }
          else {
            iVar15 = (rb_01->sbox).X2;
            local_68 = 0;
            iVar11 = iVar18;
            if (iVar15 <= iVar18) {
              iVar11 = iVar15 + -1;
              local_68 = iVar11 - iVar18;
            }
          }
          iVar5 = (search->cost_point).Y;
          iVar15 = (rb_01->sbox).Y1;
          if (iVar5 < iVar15) {
LAB_080709c9:
            local_64 = iVar15 - iVar5;
          }
          else {
            iVar6 = (rb_01->sbox).Y2;
            local_64 = 0;
            iVar15 = iVar5;
            if (iVar6 <= iVar5) {
              iVar15 = iVar6 + -1;
              goto LAB_080709c9;
            }
          }
          uVar13 = (uint)search->rb->group;
          dVar8 = (double)x_cost[uVar13] * (double)local_68;
          dVar7 = (double)y_cost[uVar13] * (double)local_64;
          if (dVar8 < 0.0) {
            dVar8 = -dVar8;
          }
          if (dVar7 < 0.0) {
            dVar7 = -dVar7;
          }
          dVar7 = dVar7 + dVar8;
          if ((iVar18 != iVar11) && (iVar5 != iVar15)) {
            dVar7 = dVar7 + AutoRouteParameters.JogPenalty;
          }
          dVar9 = (double)x_cost[group] * 0.0;
          dVar8 = (double)y_cost[group] * 0.0;
          if (dVar9 < 0.0) {
            dVar9 = -dVar9;
          }
          if (dVar8 < 0.0) {
            dVar8 = -dVar8;
          }
          dVar8 = dVar8 + dVar9;
          if (uVar13 != group) {
            dVar8 = dVar8 + AutoRouteParameters.ViaCost;
          }
          dVar7 = scale[local_6c] * dVar8 + dVar7 * scale[bVar10];
          if (prVar14->group == group) {
            if (((((prVar14->sbox).X1 <= iVar11) && ((prVar14->sbox).Y1 <= iVar15)) &&
                (iVar11 < (prVar14->sbox).X2)) && (iVar15 < (prVar14->sbox).Y2)) {
              dVar7 = AutoRouteParameters.ViaCost * -0.5 + dVar7;
            }
          }
          ne = CreateEdge(rb_01,iVar11,iVar15,dVar7 + search->cost_to_point,prVar14,ALL,targets);
        }
        else {
          pnt.X = (cliparea.X2 - cliparea.X1) / 2 + cliparea.X1;
          pnt.Y = (cliparea.Y2 - cliparea.Y1) / 2 + cliparea.Y1;
          prVar14 = mincost_target_to_point(&pnt,(uint)rb_01->group,targets,search->mincost_target);
          iVar11 = (prVar14->box).X1;
          pnt.X = ((prVar14->box).X2 - iVar11) / 2 + iVar11;
          iVar11 = (prVar14->box).Y1;
          iVar18 = (rb_01->sbox).X1;
          pnt.Y = ((prVar14->box).Y2 - iVar11) / 2 + iVar11;
          if ((iVar18 <= pnt.X) && (iVar11 = (rb_01->sbox).X2, iVar18 = iVar11 + -1, pnt.X < iVar11)
             ) {
            iVar18 = pnt.X;
          }
          iVar11 = (rb_01->sbox).Y1;
          if ((iVar11 <= pnt.Y) && (iVar15 = (rb_01->sbox).Y2, iVar11 = iVar15 + -1, pnt.Y < iVar15)
             ) {
            iVar11 = pnt.Y;
          }
          dVar8 = (double)x_cost[group] * 0.0;
          dVar7 = (double)y_cost[group] * 0.0;
          if (dVar8 < 0.0) {
            dVar8 = -dVar8;
          }
          if (dVar7 < 0.0) {
            dVar7 = -dVar7;
          }
          dVar7 = dVar7 + dVar8;
          if (search->rb->group != group) {
            dVar7 = dVar7 + AutoRouteParameters.ViaCost;
          }
          ne = CreateEdge(rb_01,iVar18,iVar11,dVar7 * scale[local_6c] + search->cost_to_point,
                          prVar14,ALL,(rtree_t *)0x0);
          ne->mincost_target = prVar14;
        }
        *(byte *)&ne->flags = *(byte *)&ne->flags & 0xf9 | 1 | bVar10 * '\x02';
        add_or_destroy_edge(s,ne);
        pPVar17 = PCB;
      }
      group = group + 1;
      piVar12 = &pPVar17->Data->LayerN;
    } while (*piVar12 != group && (int)group <= *piVar12);
  } while( true );
}



// WARNING: Unknown calling convention

void moveable_edge(vector_t *result,BoxType *box,direction_t dir,routebox_t *rb,routebox_t *blocker,
                  edge_t *e,rtree_t *targets,routeone_state *s,rtree_t *tree,vector_t *area_vec)

{
  double dVar1;
  cost_t cost_to_point;
  ushort uVar2;
  char *pcVar3;
  char *pcVar4;
  int iVar5;
  routebox_t *prVar6;
  int iVar7;
  double dVar8;
  double dVar9;
  routebox_t *prVar10;
  routebox_t *nrb;
  edge_t *peVar11;
  edge_t *ne;
  int iVar12;
  int iVar13;
  routebox_t *nrb_2;
  edge_t *ne_2;
  char *CostPointY;
  int iVar14;
  LocationType LVar15;
  char *CostPointX;
  LocationType LVar16;
  routebox_t *nrb_1;
  edge_t *ne_1;
  cost_t r_2;
  cost_t r;
  cost_t r_1;
  int local_40;
  int local_3c;
  int local_34;
  BoxType b;
  
  b.X1 = box->X1;
  b.Y1 = box->Y1;
  b.X2 = box->X2;
  b.Y2 = box->Y2;
  switch(dir) {
  case NORTH:
    iVar12 = b.Y1 + -1;
    b.Y2 = b.Y1;
    iVar13 = iVar12;
    goto joined_r0x080711b2;
  case EAST:
    iVar12 = b.X2 + 1;
    b.X1 = b.X2;
    b.X2 = iVar12;
    if (PCB->MaxWidth - AutoRouteParameters.bloat <= iVar12) {
      return;
    }
    break;
  case SOUTH:
    iVar12 = b.Y2 + 1;
    b.Y1 = b.Y2;
    b.Y2 = iVar12;
    if (PCB->MaxHeight - AutoRouteParameters.bloat <= iVar12) {
      return;
    }
    break;
  case WEST:
    iVar13 = b.X1 + -1;
    b.X2 = b.X1;
    iVar12 = b.Y1;
    b.X1 = iVar13;
joined_r0x080711b2:
    b.Y1 = iVar12;
    if (iVar13 <= AutoRouteParameters.bloat) {
      return;
    }
    break;
  case NE:
    if (AutoRouteParameters.bloat + 1 < b.Y1) {
      if (~AutoRouteParameters.bloat + PCB->MaxWidth <= b.X2) {
        dir = NORTH;
      }
      break;
    }
    iVar12 = ~AutoRouteParameters.bloat + PCB->MaxWidth;
    goto joined_r0x0807121e;
  case SE:
    if (b.Y2 < ~AutoRouteParameters.bloat + PCB->MaxHeight) {
      if (b.X2 < ~AutoRouteParameters.bloat + PCB->MaxWidth) break;
LAB_08071261:
      dir = SOUTH;
      break;
    }
    iVar12 = ~AutoRouteParameters.bloat + PCB->MaxWidth;
joined_r0x0807121e:
    if (iVar12 <= b.X2) {
      return;
    }
    dir = EAST;
    break;
  case SW:
    if (b.Y2 < ~AutoRouteParameters.bloat + PCB->MaxHeight) {
      if (AutoRouteParameters.bloat + 1 < b.X1) break;
      goto LAB_08071261;
    }
    goto joined_r0x08071114;
  case NW:
    if (AutoRouteParameters.bloat + 1 < b.Y1) {
      if (b.X1 <= AutoRouteParameters.bloat + 1) {
        dir = NORTH;
      }
      break;
    }
joined_r0x08071114:
    if (b.X1 <= AutoRouteParameters.bloat + 1) {
      return;
    }
    dir = WEST;
  }
  if (blocker == (routebox_t *)0x0) {
    prVar10 = CreateBridge(&b,rb,dir);
    if (dir + ~WEST < 4) {
      iVar12 = (prVar10->cost_point).X;
      prVar6 = e->mincost_target;
      iVar13 = (prVar6->sbox).X1;
      if ((iVar13 <= iVar12) && (iVar5 = (prVar6->sbox).X2, iVar13 = iVar5 + -1, iVar12 < iVar5)) {
        iVar13 = iVar12;
      }
      iVar5 = (prVar10->cost_point).Y;
      iVar14 = (prVar6->sbox).Y1;
      if ((iVar14 <= iVar5) && (iVar7 = (prVar6->sbox).Y2, iVar14 = iVar5, iVar7 <= iVar5)) {
        iVar14 = iVar7 + -1;
      }
      LVar16 = b.X1;
      if ((b.X1 <= iVar13) && (LVar16 = iVar13, b.X2 <= iVar13)) {
        LVar16 = b.X2 + -1;
      }
      LVar15 = b.Y1;
      if ((b.Y1 <= iVar14) && (LVar15 = iVar14, b.Y2 <= iVar14)) {
        LVar15 = b.Y2 + -1;
      }
      dVar8 = (double)x_cost[prVar10->group] * (double)(LVar16 - iVar12);
      dVar1 = (double)y_cost[prVar10->group] * (double)(LVar15 - iVar5);
      if (dVar8 < 0.0) {
        dVar8 = -dVar8;
      }
      if (dVar1 < 0.0) {
        dVar1 = -dVar1;
      }
      dVar1 = dVar1 + dVar8;
      if ((iVar12 != LVar16) && (iVar5 != LVar15)) {
        dVar1 = dVar1 + AutoRouteParameters.JogPenalty;
      }
      cost_to_point = dVar1 + prVar10->cost;
      (prVar10->cost_point).Y = LVar15;
      (prVar10->cost_point).X = LVar16;
      prVar10->cost = cost_to_point;
    }
    else {
      cost_to_point = prVar10->cost;
      LVar15 = (prVar10->cost_point).Y;
      LVar16 = (prVar10->cost_point).X;
    }
    peVar11 = CreateEdge(prVar10,LVar16,LVar15,cost_to_point,(routebox_t *)0x0,dir,targets);
    vector_append(result,peVar11);
  }
  else {
    if ((AutoRouteParameters.with_conflicts == '\0') || ((*(ushort *)&blocker->flags & 0x10e) != 0))
    {
      if (blocker->type != EXPANSION_AREA) {
        if ((*(byte *)&blocker->flags & 8) == 0) {
          return;
        }
        local_3c = b.Y1 + -1;
        iVar12 = b.X1 + -1;
        local_40 = b.Y2 + 1;
        local_34 = b.X2 + 1;
        if (((((blocker->sbox).X2 <= iVar12) || (local_34 <= (blocker->sbox).X1)) ||
            ((blocker->sbox).Y2 <= local_3c)) || (local_40 <= (blocker->sbox).Y1)) {
          if (dir == EAST) {
            local_34 = b.X2 + 2 + AutoRouteParameters.bloat;
          }
          else if (dir == NORTH) {
            local_3c = local_3c + ~AutoRouteParameters.bloat;
          }
          else if (dir == SOUTH) {
            local_40 = b.Y2 + 2 + AutoRouteParameters.bloat;
          }
          else if (dir == WEST) {
            iVar12 = iVar12 + ~AutoRouteParameters.bloat;
          }
        }
        b.X1 = iVar12 + 1;
        b.X2 = local_34 + -1;
        b.Y1 = local_3c + 1;
        b.Y2 = local_40 + -1;
        prVar10 = CreateBridge(&b,rb,dir);
        r_insert_entry(tree,&prVar10->box,1);
        vector_append(area_vec,prVar10);
        LVar15 = (prVar10->cost_point).Y;
        LVar16 = (prVar10->cost_point).X;
        *(byte *)&prVar10->flags = *(byte *)&prVar10->flags & 0xbf;
        peVar11 = CreateEdge(prVar10,LVar16,LVar15,prVar10->cost,blocker,dir,(rtree_t *)0x0);
        best_path_candidate(s,peVar11,blocker);
        KillEdge(peVar11);
        return;
      }
    }
    else if (blocker->type != EXPANSION_AREA) {
      if (dir == EAST) {
        b.X2 = (blocker->sbox).X1 + 1;
      }
      else if (dir == NORTH) {
        b.Y1 = (blocker->sbox).Y2 + -1;
      }
      else if (dir == SOUTH) {
        b.Y2 = (blocker->sbox).Y1 + 1;
      }
      else if (dir == WEST) {
        b.X1 = (blocker->sbox).X2 + -1;
      }
      if (b.X2 <= b.X1) {
        return;
      }
      if (b.Y2 <= b.Y1) {
        return;
      }
      prVar10 = CreateBridge(&b,rb,dir);
      r_insert_entry(tree,&prVar10->box,1);
      vector_append(area_vec,prVar10);
      *(byte *)&prVar10->flags = *(byte *)&prVar10->flags & 0xbf;
      path_conflicts(prVar10,blocker,'\x01');
      pcVar3 = (char *)(prVar10->cost_point).X;
      CostPointX = (char *)(blocker->sbox).X1;
      if (((int)CostPointX <= (int)pcVar3) &&
         (iVar12 = (blocker->sbox).X2, CostPointX = pcVar3, iVar12 <= (int)pcVar3)) {
        CostPointX = (char *)(iVar12 + -1);
      }
      pcVar3 = (char *)(prVar10->cost_point).Y;
      CostPointY = (char *)(blocker->sbox).Y1;
      if (((int)CostPointY <= (int)pcVar3) &&
         (iVar12 = (blocker->sbox).Y2, CostPointY = pcVar3, iVar12 <= (int)pcVar3)) {
        CostPointY = (char *)(iVar12 + -1);
      }
      uVar2 = prVar10->group;
      (prVar10->cost_point).X = (LocationType)CostPointX;
      dVar1 = prVar10->cost;
      (prVar10->cost_point).Y = (LocationType)CostPointY;
      pcVar3 = ((prVar10->parent).pin)->Name;
      pcVar4 = ((prVar10->parent).pin)->Number;
      dVar9 = (double)x_cost[uVar2] * (double)((int)pcVar3 - (int)CostPointX);
      dVar8 = (double)y_cost[uVar2] * (double)((int)pcVar4 - (int)CostPointY);
      if (dVar9 < 0.0) {
        dVar9 = -dVar9;
      }
      if (dVar8 < 0.0) {
        dVar8 = -dVar8;
      }
      dVar8 = dVar8 + dVar9;
      if ((CostPointX != pcVar3) && (CostPointY != pcVar4)) {
        dVar8 = dVar8 + AutoRouteParameters.JogPenalty;
      }
      dVar9 = AutoRouteParameters.ConflictPenalty;
      if ((uint)(*(byte *)&blocker->flags >> 7) != (int)AutoRouteParameters.is_odd) {
        dVar9 = AutoRouteParameters.LastConflictPenalty;
      }
      dVar1 = (double)(uint)blocker->pass * dVar9 * dVar8 + dVar1;
      prVar10->cost = dVar1;
      peVar11 = CreateEdge(prVar10,(LocationType)CostPointX,(LocationType)CostPointY,dVar1,
                           (routebox_t *)0x0,ALL,targets);
      *(byte *)&peVar11->flags = *(byte *)&peVar11->flags | 8;
      vector_append(result,peVar11);
      return;
    }
    if (rb->cost <= blocker->cost) {
      iVar12 = (blocker->cost_point).X;
      iVar13 = (rb->cost_point).X;
      iVar5 = (blocker->cost_point).Y;
      iVar14 = (rb->cost_point).Y;
      dVar8 = (double)x_cost[rb->group] * (double)(iVar12 - iVar13);
      dVar1 = (double)y_cost[rb->group] * (double)(iVar5 - iVar14);
      if (dVar8 < 0.0) {
        dVar8 = -dVar8;
      }
      if (dVar1 < 0.0) {
        dVar1 = -dVar1;
      }
      dVar1 = dVar1 + dVar8;
      if ((iVar12 != iVar13) && (iVar5 != iVar14)) {
        dVar1 = dVar1 + AutoRouteParameters.JogPenalty;
      }
      if (((dVar1 + rb->cost < blocker->cost) && (blocker->conflicts_with == (vector_t *)0x0)) &&
         (rb->conflicts_with == (vector_t *)0x0)) {
        if ((*(byte *)&((routebox_t *)(blocker->parent).pad)->flags & 0x40) != 0) {
          RB_down_count((routebox_t *)(blocker->parent).pad);
        }
        (blocker->parent).pad = (PadTypePtr)rb;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

vector_t *
BreakManyEdges(routeone_state *s,rtree_t *targets,rtree_t *tree,vector_t *area_vec,E_result *ans,
              routebox_t *rb,edge_t *e)

{
  LocationType LVar1;
  int iVar2;
  int iVar3;
  LocationType LVar4;
  LocationType LVar5;
  LocationType LVar6;
  LocationType LVar7;
  LocationType LVar8;
  LocationType LVar9;
  vector_t *result;
  uint uVar10;
  int iVar11;
  int iVar12;
  routebox_t *prVar13;
  int iVar14;
  direction_t dVar15;
  direction_t dir;
  direction_t dVar16;
  heap_t **heap_00;
  direction_t dVar17;
  LocationType LVar18;
  LocationType last;
  int iVar19;
  routebox_t *blk;
  byte bVar20;
  LocationType local_170;
  direction_t local_164;
  LocationType local_15c;
  LocationType local_158;
  LocationType local_154;
  LocationType local_150;
  LocationType local_13c;
  LocationType local_138;
  LocationType local_134;
  LocationType local_130;
  undefined4 local_12c;
  routebox_t fake;
  broken_boxes broke;
  break_info bi;
  BoxType db;
  BoxType b;
  heap_t *heap [4];
  heap_t *local_1c [3];
  
  bVar20 = 0;
  result = vector_create();
  bi.parent = rb;
  bi.ignore_source = *(byte *)&(((rb->parent).pad)->Point1).X >> 2 & 1;
  uVar10 = AutoRouteParameters.bloat + 2;
  dVar16 = e->expand_dir;
  if (dVar16 + ~WEST < 4) {
    prVar13 = &fake;
    for (iVar11 = 0x1f; iVar11 != 0; iVar11 = iVar11 + -1) {
      (prVar13->box).X1 = 0;
      prVar13 = (routebox_t *)((int)prVar13 + (uint)bVar20 * -8 + 4);
    }
    fake.type = DBUS_WATCH_ERROR;
    prVar13 = e->rb;
    fake.sbox.X1 = (prVar13->sbox).X1;
    fake.sbox.Y1 = (prVar13->sbox).Y1;
    fake.sbox.X2 = (prVar13->sbox).X2;
    fake.sbox.Y2 = (prVar13->sbox).Y2;
    fake.flags._0_1_ = fake.flags._0_1_ | 2;
    fake.style = AutoRouteParameters.style;
  }
  dVar17 = SOUTH;
  dVar15 = NORTH;
  do {
    if ((dVar17 & WEST) == dVar16) {
      heap[dVar15] = (heap_t *)0x0;
    }
    else {
      bi.heap = heap_create();
      bi.box.X1 = -uVar10 + (rb->sbox).X1;
      bi.box.Y1 = -uVar10 + (rb->sbox).Y1;
      iVar11 = (rb->sbox).X2;
      heap[dVar15] = bi.heap;
      bi.box.X2 = iVar11 + uVar10;
      bi.box.Y2 = (rb->sbox).Y2 + uVar10;
      bi.dir = dVar15;
      if (dVar15 == SOUTH) {
        bi.box.Y1 = bi.box.Y2 + ~uVar10;
        dVar16 = e->expand_dir;
        if ((dVar16 == NW) || (dVar16 == NE)) {
          blocker_to_heap(bi.heap,&fake,&bi.box,SOUTH);
          dVar16 = e->expand_dir;
          if (dVar16 != NE) goto LAB_08071da1;
          bi.box.X1 = (e->rb->sbox).X2;
        }
        else {
LAB_08071da1:
          if (dVar16 == NW) {
            bi.box.X2 = (e->rb->sbox).X1;
          }
        }
        iVar11 = r_search(tree,&bi.box,(_func_int_BoxType_ptr_void_ptr *)0x0,__GatherBlockers,&bi);
        rb->s = (uchar)iVar11;
      }
      else {
        if (dVar15 != WEST) {
          if (dVar15 == EAST) {
            bi.box.X1 = bi.box.X2 + ~uVar10;
            dVar16 = e->expand_dir;
            if (dVar16 + ~SE < 2) {
              blocker_to_heap(bi.heap,&fake,&bi.box,EAST);
              dVar16 = e->expand_dir;
              if (dVar16 != SW) goto LAB_08071ce1;
              bi.box.Y1 = (e->rb->sbox).Y2;
            }
            else {
LAB_08071ce1:
              if (dVar16 == NW) {
                bi.box.Y2 = (e->rb->sbox).Y1;
              }
            }
            iVar11 = r_search(tree,&bi.box,(_func_int_BoxType_ptr_void_ptr *)0x0,__GatherBlockers,
                              &bi);
            rb->e = (uchar)iVar11;
            goto joined_r0x080718a1;
          }
          bi.box.Y2 = bi.box.Y1 + 1 + uVar10;
          dVar16 = e->expand_dir;
          if (dVar16 + ~NE < 2) {
            blocker_to_heap(bi.heap,&fake,&bi.box,NORTH);
            dVar16 = e->expand_dir;
            if (dVar16 != SE) goto LAB_080715ae;
            bi.box.X1 = (e->rb->sbox).X2;
          }
          else {
LAB_080715ae:
            if (dVar16 == SW) {
              bi.box.X2 = (e->rb->sbox).X1;
            }
          }
          iVar11 = r_search(tree,&bi.box,(_func_int_BoxType_ptr_void_ptr *)0x0,__GatherBlockers,&bi)
          ;
          rb->n = (uchar)iVar11;
          goto joined_r0x080718a1;
        }
        bi.box.X2 = bi.box.X1 + 1 + uVar10;
        dVar16 = e->expand_dir;
        if (dVar16 + ~WEST < 2) {
          blocker_to_heap(bi.heap,&fake,&bi.box,WEST);
          dVar16 = e->expand_dir;
          if (dVar16 != SE) goto LAB_08071d45;
          bi.box.Y1 = (e->rb->sbox).Y2;
        }
        else {
LAB_08071d45:
          if (dVar16 == NE) {
            bi.box.Y2 = (e->rb->sbox).Y1;
          }
        }
        iVar11 = r_search(tree,&bi.box,(_func_int_BoxType_ptr_void_ptr *)0x0,__GatherBlockers,&bi);
        rb->w = (uchar)iVar11;
      }
    }
joined_r0x080718a1:
    if (dVar17 == SE) break;
    dVar17 = dVar17 + EAST;
    dVar15 = dVar15 + EAST;
    dVar16 = e->expand_dir;
  } while( true );
  dVar16 = NORTH;
  LVar18 = -1;
  local_164 = ~NORTH;
  local_170 = -1;
  rb->cost = ((double)((uint)rb->e + (uint)rb->n + (uint)rb->s + (uint)rb->w) *
             AutoRouteParameters.CongestionPenalty) /
             ((double)((rb->sbox).Y2 - (rb->sbox).Y1) * (double)((rb->sbox).X2 - (rb->sbox).X1)) +
             rb->cost;
  do {
    if ((heap[dVar16] == (heap_t *)0x0) || (iVar11 = heap_is_empty(heap[dVar16]), iVar11 != 0)) {
      dVar15 = e->expand_dir;
      if (dVar15 == ALL) {
        dVar15 = e->rb->came_from;
      }
      if (dVar15 != (local_164 + WEST & WEST)) {
        moveable_edge(result,&rb->sbox,dVar16,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                      (vector_t *)0x0);
      }
      if (LVar18 < 1) goto LAB_080718c8;
      iVar11 = (rb->sbox).X2;
      LVar1 = (rb->sbox).Y2;
      iVar2 = (rb->sbox).Y1;
      iVar3 = (rb->sbox).X1;
      iVar12 = iVar3;
      iVar14 = LVar18;
      iVar19 = iVar11;
      if (((dVar16 != SOUTH) && (iVar14 = iVar2, iVar19 = LVar18, dVar16 != WEST)) &&
         (iVar12 = LVar18, iVar19 = iVar11, dVar16 != EAST)) {
        Message("previous edge bogus direction!");
        iVar12 = iVar3;
      }
      LVar18 = -1;
      db.X1 = iVar12;
      db.Y1 = iVar14;
      db.X2 = iVar19;
      db.Y2 = LVar1;
      moveable_edge(result,&db,local_164,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                    (vector_t *)0x0);
    }
    else {
      prVar13 = (routebox_t *)heap_remove_smallest(heap[dVar16]);
      b.X1 = (rb->sbox).X1;
      b.Y1 = (rb->sbox).Y1;
      b.X2 = (rb->sbox).X2;
      b.Y2 = (rb->sbox).Y2;
      break_box_edge(&b,dVar16,prVar13);
      if (broke.is_valid_left == '\0') {
        if (0 < LVar18) {
          LVar1 = (rb->sbox).X2;
          LVar4 = (rb->sbox).Y2;
          LVar5 = (rb->sbox).Y1;
          LVar6 = (rb->sbox).X1;
          dVar15 = local_164;
          LVar7 = LVar6;
          LVar8 = LVar18;
          LVar9 = LVar1;
          if (((dVar16 != SOUTH) && (LVar8 = LVar5, LVar9 = LVar18, dVar16 != WEST)) &&
             (LVar7 = LVar18, LVar9 = LVar1, dVar16 != EAST)) {
            Message("previous edge bogus direction!");
            LVar7 = LVar6;
          }
          goto LAB_08071a96;
        }
      }
      else if (LVar18 < 1) {
        if (dVar16 == NORTH) {
          local_170 = broke.left.X2;
          if (broke.left.X2 <= b.X1) {
            local_170 = b.X1;
          }
        }
        else {
          moveable_edge(result,&broke.left,dVar16,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                        (vector_t *)0x0);
        }
      }
      else {
        db.X1 = b.X1;
        db.Y1 = b.Y1;
        db.X2 = b.X2;
        db.Y2 = b.Y2;
        if (dVar16 == SOUTH) {
          db.X1 = broke.left.X1;
          db.Y1 = LVar18;
          if (broke.left.X1 <= b.X1) {
            db.X1 = b.X1;
          }
        }
        else if (dVar16 == WEST) {
          db.Y1 = broke.left.Y1;
          db.X2 = LVar18;
          if (broke.left.Y1 <= b.Y1) {
            db.Y1 = b.Y1;
          }
        }
        else if ((dVar16 == EAST) && (db.X1 = LVar18, db.Y2 = broke.left.Y2, b.Y2 <= broke.left.Y2))
        {
          db.Y2 = b.Y2;
        }
        dVar15 = local_164 + NE;
        LVar7 = db.X1;
        LVar8 = db.Y1;
        LVar9 = db.X2;
        LVar4 = db.Y2;
LAB_08071a96:
        db.Y2 = LVar4;
        db.X2 = LVar9;
        db.Y1 = LVar8;
        db.X1 = LVar7;
        moveable_edge(result,&db,dVar15,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                      (vector_t *)0x0);
      }
      if (broke.is_valid_center != '\0') {
        bVar20 = *(byte *)&prVar13->flags;
        goto joined_r0x08071abb;
      }
      while (broke.is_valid_right != '\0') {
        if (dVar16 == SOUTH) {
          LVar18 = b.X2;
          if (broke.right.X2 <= b.X2) {
            LVar18 = broke.right.X2;
            b.X2 = broke.right.X2;
          }
        }
        else if (dVar16 == WEST) {
          LVar18 = b.Y2;
          if (broke.right.Y2 <= b.Y2) {
            LVar18 = broke.right.Y2;
            b.Y2 = broke.right.Y2;
          }
        }
        else if (dVar16 == EAST) {
          LVar18 = b.Y1;
          if (b.Y1 <= broke.right.Y1) {
            LVar18 = broke.right.Y1;
            b.Y1 = broke.right.Y1;
          }
        }
        else {
          LVar18 = b.X1;
          if (b.X1 <= broke.right.X1) {
            LVar18 = broke.right.X1;
            b.X1 = broke.right.X1;
          }
        }
        iVar11 = heap_is_empty(heap[dVar16]);
        if (iVar11 != 0) {
          if (broke.is_valid_right != '\0') goto LAB_080717bf;
          break;
        }
        prVar13 = (routebox_t *)heap_remove_smallest(heap[dVar16]);
        break_box_edge(&b,dVar16,prVar13);
        broke.left.X1 = local_15c;
        broke.left.Y1 = local_158;
        broke.left.X2 = local_154;
        broke.left.Y2 = local_150;
        broke.right.X1 = local_13c;
        broke.right.Y1 = local_138;
        broke.right.X2 = local_134;
        broke.right.Y2 = local_130;
        broke._48_4_ = local_12c;
        if ((char)local_12c != '\0') {
          moveable_edge(result,&broke.left,dVar16,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                        (vector_t *)0x0);
        }
        if (broke.is_valid_center != '\0') {
          bVar20 = *(byte *)&prVar13->flags;
joined_r0x08071abb:
          if ((bVar20 & 4) == 0) {
            moveable_edge(result,&broke.center,dVar16,rb,prVar13,e,targets,s,tree,area_vec);
          }
        }
      }
LAB_080718c8:
      LVar18 = -1;
    }
LAB_080717bf:
    local_164 = local_164 + EAST;
    dVar16 = dVar16 + EAST;
    if (local_164 == WEST) {
      if (LVar18 < 1) {
        if (0 < local_170) {
          db.X1 = (rb->sbox).X1;
          db.Y1 = (rb->sbox).Y1;
          db.Y2 = (rb->sbox).Y2;
          db.X2 = local_170;
          moveable_edge(result,&db,NORTH,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                        (vector_t *)0x0);
        }
      }
      else {
        if (0 < local_170) {
          db.X1 = (rb->sbox).X1;
          db.Y1 = (rb->sbox).Y1;
          db.X2 = local_170;
          dVar16 = NW;
        }
        else {
          db.X1 = (rb->sbox).X1;
          db.Y1 = (rb->sbox).Y1;
          db.X2 = (rb->sbox).X2;
          dVar16 = WEST;
        }
        db.Y2 = LVar18;
        moveable_edge(result,&db,dVar16,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                      (vector_t *)0x0);
      }
      heap_00 = heap;
      iVar11 = 0;
      do {
        if (heap[iVar11] != (heap_t *)0x0) {
          heap_destroy(heap_00);
        }
        heap_00 = heap_00 + 1;
        iVar11 = iVar11 + 1;
      } while (heap_00 != local_1c);
      return result;
    }
  } while( true );
}



// WARNING: Unknown calling convention

routeone_status * RouteOne(routedata_t *rd,routebox_t *from,routebox_t *to,int max_edges)

{
  undefined *puVar1;
  LocationType *pLVar2;
  anon_struct_8_16_88ec3562_for_flags *paVar3;
  ushort uVar4;
  routebox *prVar5;
  routebox *prVar6;
  direction_t dVar7;
  anon_enum_32 aVar8;
  CheapPointType start;
  CheapPointType start_00;
  CheapPointType start_01;
  CheapPointType end;
  CheapPointType end_00;
  CheapPointType end_01;
  RouteStyleType *pRVar9;
  byte bVar10;
  routeone_status *in_EAX;
  BoxType **boxlist;
  routebox_t *__next_one___3;
  rtree_t *targets;
  vector_t *source_vec;
  routebox_t *__next_one___4;
  int iVar12;
  edge_t *peVar13;
  routebox_t *__next_one___6;
  routebox *prVar14;
  vector_t *edge_vec;
  int iVar15;
  routebox_t *prVar16;
  routebox_t *__next_one___7;
  E_result *ans;
  routebox_t *prVar17;
  edge_t *ne_1;
  BoxType *pBVar18;
  vector_element_t pvVar19;
  vector_t *vector;
  routebox_t *prVar20;
  routebox_t *prVar21;
  routebox_t *nrb_3;
  Boolean BVar11;
  uint uVar22;
  routebox_t *nrb;
  int iVar23;
  edge_t *e;
  int iVar24;
  int iVar25;
  routebox_t *__next_one__;
  routebox_t *__next_one___1;
  routebox_t *__next_one___2;
  routebox_t *__next_one___9;
  int i;
  int iVar26;
  LocationType LVar27;
  PCBTypePtr pPVar28;
  int iVar29;
  int num_targets;
  routebox_t *__next_one___5;
  edge_t *e_1;
  int iVar30;
  int seen;
  routebox_t *pin;
  routebox_t *nrb_1;
  routebox_t *__next_one___8;
  edge_t *ne_2;
  int i_1;
  int iVar31;
  routebox_t *nrb_2;
  edge_t *ne;
  routebox_t *rb;
  BoxType *pBVar32;
  routebox_t *first_via;
  byte bVar33;
  cost_t cVar34;
  BDimension BVar35;
  Boolean local_ad;
  uint local_a0;
  routebox_t *local_8c;
  routebox_t *local_84;
  routeone_state s;
  BoxType b;
  routeone_via_site_state vss;
  CheapPointType nextpoint;
  CheapPointType lastpoint;
  vector_t *local_2c;
  vector_t *local_28;
  vector_t *local_24;
  rtree_t *local_20 [4];
  
  bVar33 = 0;
  prVar16 = from;
  if (from != (routebox_t *)0x0) {
    do {
      prVar20 = (prVar16->same_net).next;
      *(byte *)&prVar16->flags = *(byte *)&prVar16->flags | 0x10;
      prVar21 = from;
      prVar16 = prVar20;
    } while (from != prVar20);
    do {
      prVar16 = (prVar21->same_subnet).next;
      if ((*(byte *)&prVar21->flags & 1) == 0) {
        *(byte *)&prVar21->flags = *(byte *)&prVar21->flags | 4;
      }
      prVar21 = prVar16;
    } while (prVar20 != prVar16);
  }
  if (to == (routebox_t *)0x0) {
    if (from == (routebox_t *)0x0) goto LAB_0807249d;
    iVar29 = 0;
    prVar16 = from;
    do {
      bVar10 = *(byte *)&prVar16->flags;
      prVar5 = (prVar16->same_net).next;
      if ((((bVar10 & 4) == 0) && (is_layer_group_active[prVar16->group] != '\0')) &&
         ((bVar10 & 1) == 0)) {
        iVar29 = iVar29 + 1;
        *(byte *)&prVar16->flags = bVar10 | 8;
      }
      prVar16 = prVar5;
    } while (from != prVar5);
LAB_080721ae:
    if (iVar29 != 0) {
      boxlist = (BoxType **)calloc(1,iVar29 << 2);
      if (from == (routebox_t *)0x0) {
        local_20[0] = r_create_tree(boxlist,0,0);
        free(boxlist);
        local_24 = vector_create();
      }
      else {
        iVar29 = 0;
        prVar16 = from;
        do {
          prVar5 = (prVar16->same_net).next;
          if ((*(byte *)&prVar16->flags & 8) != 0) {
            boxlist[iVar29] = &prVar16->box;
            iVar29 = iVar29 + 1;
          }
          prVar16 = prVar5;
        } while (from != prVar5);
        local_20[0] = r_create_tree(boxlist,iVar29,0);
        free(boxlist);
        local_24 = vector_create();
        prVar16 = from;
        do {
          prVar6 = (prVar16->same_subnet).next;
          puVar1 = &(prVar16->flags).field_0x1;
          *puVar1 = *puVar1 | 1;
          prVar16 = prVar6;
          prVar14 = prVar6;
        } while (prVar5 != prVar6);
        do {
          while ((prVar5 = (prVar14->same_subnet).next, (*(byte *)&prVar14->flags & 4) == 0 ||
                 (is_layer_group_active[prVar14->group] == '\0'))) {
            prVar14 = prVar5;
            if (prVar6 == prVar5) goto LAB_0807236a;
          }
          iVar29 = (prVar14->sbox).Y1;
          iVar15 = (prVar14->sbox).X1;
          iVar23 = (prVar14->sbox).Y2;
          iVar25 = (prVar14->sbox).X2;
          iVar12 = (iVar25 - iVar15) / 2 + iVar15;
          iVar30 = (iVar23 - iVar29) / 2 + iVar29;
          peVar13 = CreateEdge(prVar14,iVar12,iVar30,0.0,(routebox_t *)0x0,ALL,local_20[0]);
          prVar16 = peVar13->mincost_target;
          iVar26 = (prVar16->sbox).X1;
          if (iVar12 < iVar26) {
            iVar12 = (prVar16->sbox).Y1;
          }
          else {
            iVar26 = iVar12;
            if ((prVar16->sbox).X2 <= iVar12) {
              iVar26 = (prVar16->sbox).X2 + -1;
            }
            iVar12 = (prVar16->sbox).Y1;
          }
          if ((iVar12 <= iVar30) && (iVar31 = (prVar16->sbox).Y2, iVar12 = iVar30, iVar31 <= iVar30)
             ) {
            iVar12 = iVar31 + -1;
          }
          if ((iVar15 <= iVar26) && (iVar15 = iVar25 + -1, iVar26 < iVar25)) {
            iVar15 = iVar26;
          }
          if ((iVar29 <= iVar12) && (iVar29 = iVar12, iVar23 <= iVar12)) {
            iVar29 = iVar23 + -1;
          }
          (peVar13->cost_point).Y = iVar29;
          (prVar14->cost_point).Y = iVar29;
          (peVar13->cost_point).X = iVar15;
          (prVar14->cost_point).X = iVar15;
          if (AutoRouteParameters.with_conflicts != '\0') {
            r_search(rd->layergrouptree[prVar14->group],&prVar14->sbox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,__conflict_source,prVar14);
            touch_conflicts((vector_t *)0x0,1);
          }
          vector_append(local_24,peVar13);
          prVar14 = prVar5;
        } while (prVar6 != prVar5);
LAB_0807236a:
        do {
          prVar6 = (prVar14->same_subnet).next;
          puVar1 = &(prVar14->flags).field_0x1;
          *puVar1 = *puVar1 & 0xfe;
          prVar14 = prVar6;
        } while (prVar5 != prVar6);
      }
      s.workheap = heap_create();
      while (iVar29 = vector_is_empty(local_24), iVar29 == 0) {
        peVar13 = (edge_t *)vector_remove_last(local_24);
        cVar34 = edge_cost(peVar13,3e+28);
        peVar13->cost = cVar34;
        heap_insert(s.workheap,cVar34,peVar13);
      }
      vector_destroy(&local_24);
      s.best_path = (routebox_t *)0x0;
      s.best_cost = 3e+28;
      area_vec = vector_create();
      local_28 = vector_create();
      edge_vec = vector_create();
      vss.free_space_vec = edge_vec;
      vss.lo_conflict_space_vec = vector_create();
      vss.hi_conflict_space_vec = vector_create();
      iVar29 = 0;
      while (iVar15 = heap_is_empty(s.workheap), iVar15 == 0) {
        prVar16 = (routebox_t *)heap_remove_smallest(s.workheap);
        if ((s.best_path == (routebox_t *)0x0) || (*(double *)&(prVar16->sbox).Y1 < s.best_cost)) {
          iVar15 = iVar29 + 1;
          if (iVar29 <= max_edges) {
            touch_conflicts(((routebox_t *)(prVar16->box).X1)->conflicts_with,1);
            bVar10 = *(byte *)&prVar16->type;
            if ((bVar10 & 0x10) == 0) {
              prVar20 = (routebox_t *)(prVar16->box).X1;
              if ((prVar20->flags).is_thermal == 0) {
                if (prVar20->type == GDK_NOOP) {
                  prVar20 = FindThermable(local_20[0],prVar20);
                  if (prVar20 == (routebox_t *)0x0) {
                    if ((AutoRouteParameters.use_vias != '\0') &&
                       (*(double *)&(prVar16->sbox).Y1 + AutoRouteParameters.ViaCost < s.best_cost))
                    {
                      prVar20 = (routebox_t *)(prVar16->box).X1;
                      prVar21 = prVar16;
                      prVar17 = CreateExpansionArea(&prVar20->sbox,(uint)prVar20->group,prVar20,
                                                    '\x01',(edge_t *)prVar16);
                      prVar20 = (routebox_t *)
                                CreateEdge2(prVar17,*(direction_t *)&prVar16->group,
                                            (edge_t *)prVar16,(rtree_t *)(prVar16->sbox).Y2,prVar21)
                      ;
                      (prVar17->flags).is_thermal = 1;
                      BVar11 = '\x01';
                      BVar35 = ((routebox_t *)(prVar16->box).X1)->style->Diameter;
                      goto LAB_080726cd;
                    }
                  }
                  else {
                    b.X1 = (prVar20->sbox).X1;
                    prVar21 = (routebox_t *)(prVar16->box).X1;
                    b.Y1 = (prVar20->sbox).Y1;
                    b.X2 = (prVar20->sbox).X2;
                    b.Y2 = (prVar20->sbox).Y2;
                    prVar17 = prVar16;
                    prVar21 = CreateExpansionArea(&b,(uint)prVar21->group,prVar21,'\x01',
                                                  (edge_t *)prVar16);
                    (prVar21->flags).is_thermal = 1;
                    ((CheapPointType *)&(prVar16->box).Y1)->X = b.X1;
                    (prVar16->box).X2 = b.Y1;
                    peVar13 = CreateEdge2(prVar21,*(direction_t *)&prVar16->group,(edge_t *)prVar16,
                                          (rtree_t *)prVar20,prVar17);
                    best_path_candidate(&s,peVar13,prVar20);
                    KillEdge(peVar13);
                  }
                }
                else {
                  if ((bVar10 & 1) != 0) {
                    prVar20 = FindOneInBox(rd->layergrouptree[prVar20->group],prVar20);
                    if (prVar20 != (routebox_t *)0x0) {
                      if (((*(byte *)&prVar20->flags & 8) != 0) && (prVar20->type == GDK_NOOP)) {
                        prVar21 = (routebox_t *)(prVar16->box).X1;
                        uVar4 = prVar21->group;
                        pBVar18 = &prVar21->sbox;
                        pBVar32 = &b;
                        for (iVar29 = 4; iVar29 != 0; iVar29 = iVar29 + -1) {
                          pBVar32->X1 = pBVar18->X1;
                          pBVar18 = (BoxType *)((int)pBVar18 + (uint)bVar33 * -8 + 4);
                          pBVar32 = (BoxType *)((int)pBVar32 + (uint)bVar33 * -8 + 4);
                        }
                        prVar17 = prVar16;
                        prVar21 = CreateExpansionArea(&b,(uint)uVar4,prVar21,'\x01',
                                                      (edge_t *)prVar16);
                        dVar7 = *(direction_t *)&prVar16->group;
                        (prVar21->flags).is_thermal = 1;
                        peVar13 = CreateEdge2(prVar21,dVar7,(edge_t *)prVar16,(rtree_t *)prVar20,
                                              prVar17);
                        best_path_candidate(&s,peVar13,prVar20);
                        KillEdge(peVar13);
                      }
                      goto LAB_0807242a;
                    }
                    prVar20 = (routebox_t *)(prVar16->box).X1;
                    r_insert_entry(rd->layergrouptree[*(ushort *)(&prVar20->parent + 1)],
                                   (BoxType *)prVar20,1);
                    paVar3 = &((routebox_t *)(prVar16->box).X1)->flags;
                    *(byte *)paVar3 = *(byte *)paVar3 & 0xbf;
                    vector_append(area_vec,(routebox_t *)(prVar16->box).X1);
                    prVar20 = (routebox_t *)(prVar16->box).X1;
                    prVar20->refcount = 0;
                    bVar10 = *(byte *)&prVar16->type;
                  }
                  if ((bVar10 & 8) == 0) {
                    if ((*(byte *)&prVar20->flags & 4) == 0) {
                      b.X1 = (prVar20->sbox).X1;
                      b.Y1 = (prVar20->sbox).Y1;
                      b.X2 = (prVar20->sbox).X2;
                      b.Y2 = (prVar20->sbox).Y2;
                    }
                    else {
                      iVar29 = (prVar20->sbox).X1;
                      iVar23 = (prVar20->sbox).Y1;
                      b.X1 = ((prVar20->sbox).X2 - iVar29) / 2 + iVar29;
                      b.X2 = b.X1 + 1;
                      b.Y1 = ((prVar20->sbox).Y2 - iVar23) / 2 + iVar23;
                      b.Y2 = b.Y1 + 1;
                    }
                  }
                  else {
                    b.X1 = (prVar20->sbox).X1;
                    b.Y1 = (prVar20->sbox).Y1;
                    b.X2 = (prVar20->sbox).X2;
                    b.Y2 = (prVar20->sbox).Y2;
                    dVar7 = prVar20->came_from;
                    if (dVar7 == EAST) {
                      b.X1 = b.X2 + -1;
LAB_08072974:
                      b.Y1 = (b.Y2 - b.Y1) / 2 + b.Y1;
                      b.Y2 = b.Y1 + 1;
                    }
                    else {
                      if (dVar7 == NORTH) {
                        b.Y2 = b.Y1 + 1;
                      }
                      else {
                        if (dVar7 != SOUTH) {
                          if (dVar7 != WEST) goto LAB_08072551;
                          b.X2 = b.X1 + 1;
                          goto LAB_08072974;
                        }
                        b.Y1 = b.Y2 + -1;
                      }
                      b.X1 = (b.X2 - b.X1) / 2 + b.X1;
                      b.X2 = b.X1 + 1;
                    }
                  }
LAB_08072551:
                  ans = Expand(rd->layergrouptree[prVar20->group],(edge_t *)prVar16,&b);
                  iVar29 = (ans->inflated).X1;
                  if (((((iVar29 < (ans->orig).X2) &&
                        (iVar23 = (ans->inflated).X2, (ans->orig).X1 < iVar23)) &&
                       (iVar25 = (ans->inflated).Y1, iVar25 < (ans->orig).Y2)) &&
                      ((iVar26 = (ans->inflated).Y2, (ans->orig).Y1 < iVar26 && (iVar29 < iVar23))))
                     && (iVar25 < iVar26)) {
                    prVar20 = (routebox_t *)(prVar16->box).X1;
                    prVar17 = CreateExpansionArea(&ans->inflated,(uint)prVar20->group,prVar20,'\x01'
                                                  ,(edge_t *)prVar16);
                    r_insert_entry(rd->layergrouptree[prVar17->group],&prVar17->box,1);
                    vector_append(area_vec,prVar17);
                    *(byte *)&prVar17->flags = *(byte *)&prVar17->flags & 0xbf;
                    local_2c = BreakManyEdges(&s,local_20[0],rd->layergrouptree[prVar17->group],
                                              area_vec,ans,prVar17,(edge_t *)prVar16);
                    while (iVar29 = vector_is_empty(local_2c), iVar29 == 0) {
                      peVar13 = (edge_t *)vector_remove_last(local_2c);
                      add_or_destroy_edge(&s,peVar13);
                    }
                    vector_destroy(&local_2c);
                    if (((AutoRouteParameters.use_vias != '\0') &&
                        (((((routebox_t *)(prVar16->box).X1)->flags).field_0x1 & 4) == 0)) &&
                       (*(double *)&(prVar16->sbox).Y1 + AutoRouteParameters.ViaCost < s.best_cost))
                    {
                      BVar11 = '\0';
                      BVar35 = 0;
                      prVar20 = prVar16;
LAB_080726cd:
                      add_via_sites(&s,&vss,rd->mtspace,prVar17,NO_CONFLICT,(edge_t *)prVar20,
                                    local_20[0],BVar35,BVar11);
                    }
                  }
                }
              }
              else {
                best_path_candidate(&s,(edge_t *)prVar16,(routebox_t *)(prVar16->sbox).Y2);
              }
            }
            else {
              do_via_search((edge_t *)prVar16,&s,&vss,rd->mtspace,local_20[0]);
            }
          }
        }
        else {
          heap_free(s.workheap,KillEdge);
          iVar15 = iVar29;
        }
LAB_0807242a:
        KillEdge(prVar16);
        iVar29 = iVar15;
      }
      touch_conflicts((vector_t *)0x0,1);
      heap_destroy(&s.workheap);
      r_destroy_tree(local_20);
      vector_destroy(&local_28);
      cVar34 = s.best_cost;
      if (s.best_path == (routebox_t *)0x0) {
        BVar11 = '\0';
        local_a0 = 0;
        goto LAB_080727ac;
      }
      if (AutoRouteParameters.with_conflicts == '\0') {
LAB_08072746:
        local_a0 = 0;
      }
      else {
        vector = (s.best_path)->conflicts_with;
        local_a0 = 0;
        if (vector == (vector_t *)0x0) goto LAB_08072746;
        while( true ) {
          iVar29 = vector_is_empty(vector);
          if (iVar29 != 0) break;
          pvVar19 = vector_remove_last((s.best_path)->conflicts_with);
          *(byte *)((int)pvVar19 + 0x2d) = *(byte *)((int)pvVar19 + 0x2d) | 0x20;
          vector = (s.best_path)->conflicts_with;
          local_a0 = local_a0 + 1;
        }
      }
      prVar16 = s.best_target;
      local_84 = s.best_path;
      BVar11 = '\0';
      if ((int)local_a0 < AutoRouteParameters.hi_conflict) {
        iVar15 = ((AutoRouteParameters.style)->Diameter + 1) / 2;
        iVar29 = ((AutoRouteParameters.style)->Thick + 1) / 2;
        if (((s.best_path)->flags).is_thermal == 0) {
          iVar23 = ((s.best_target)->sbox).X1;
          lastpoint.X = (((s.best_target)->sbox).X2 - iVar23) / 2 + iVar23;
          iVar23 = ((s.best_target)->sbox).Y1;
          lastpoint.Y = (((s.best_target)->sbox).Y2 - iVar23) / 2 + iVar23;
          TargetPoint(&lastpoint,s.best_target);
          if ((((AutoRouteParameters.last_smooth != '\0') &&
               ((local_84->sbox).X1 <= (prVar16->sbox).X1)) &&
              ((prVar16->sbox).X2 <= (local_84->sbox).X2)) &&
             (((local_84->sbox).Y1 <= (prVar16->sbox).Y1 &&
              ((prVar16->sbox).Y2 <= (local_84->sbox).Y2)))) {
            local_84 = (local_84->parent).via_shadow;
          }
          b.X1 = (local_84->sbox).X1;
          b.Y1 = (local_84->sbox).Y1;
          b.X2 = (local_84->sbox).X2;
          b.Y2 = (local_84->sbox).Y2;
          if ((*(byte *)&local_84->flags & 0x20) != 0) {
            iVar23 = b.Y2 - b.Y1;
            if (b.X2 - b.X1 <= b.Y2 - b.Y1) {
              iVar23 = b.X2 - b.X1;
            }
            iVar23 = iVar23 / 5;
            b.X1 = iVar23 + b.X1;
            b.Y1 = b.Y1 + iVar23;
            b.X2 = b.X2 - iVar23;
            b.Y2 = b.Y2 - iVar23;
          }
          nextpoint.X = b.X1;
          if ((b.X1 <= lastpoint.X) && (nextpoint.X = b.X2 + -1, lastpoint.X < b.X2)) {
            nextpoint.X = lastpoint.X;
          }
          nextpoint.Y = b.Y1;
          if ((b.Y1 <= lastpoint.Y) && (nextpoint.Y = b.Y2 + -1, lastpoint.Y < b.Y2)) {
            nextpoint.Y = lastpoint.Y;
          }
          if (AutoRouteParameters.last_smooth == '\0') {
            start_00.Y = lastpoint.Y;
            start_00.X = lastpoint.X;
            end_00.Y = nextpoint.Y;
            end_00.X = nextpoint.X;
            local_ad = RD_DrawManhattanLine
                                 (rd,&prVar16->sbox,&local_84->sbox,start_00,end_00,iVar29,
                                  (uint)local_84->group,from,(Boolean)local_a0,'\0');
          }
          else {
            RD_DrawLine(rd,lastpoint.X,lastpoint.Y,nextpoint.X,nextpoint.Y,iVar29,
                        (uint)local_84->group,from,(Boolean)local_a0,'\x01');
            local_ad = '\0';
          }
        }
        else {
          iVar23 = ((s.best_path)->sbox).X1;
          nextpoint.X = (((s.best_path)->sbox).X2 - iVar23) / 2 + iVar23;
          iVar23 = ((s.best_path)->sbox).Y1;
          nextpoint.Y = (((s.best_path)->sbox).Y2 - iVar23) / 2 + iVar23;
          prVar16 = (routebox_t *)((s.best_path)->parent).pad;
          if (((prVar16->flags).field_0x1 & 4) == 0) {
            TargetPoint(&nextpoint,s.best_target);
            LVar27 = nextpoint.Y;
          }
          else {
            prVar20 = s.best_path;
            if ((*(byte *)&(s.best_path)->flags & 4) == 0) {
              for (; (prVar20 = prVar16, prVar16 != (routebox_t *)0x0 &&
                     ((*(byte *)&prVar16->flags & 4) == 0));
                  prVar16 = (routebox_t *)(prVar16->parent).pad) {
              }
            }
            TargetPoint(&nextpoint,prVar20);
            prVar5 = (local_84->parent).via_shadow;
            b.X1 = (prVar5->sbox).X1;
            b.X2 = (prVar5->sbox).X2;
            if (b.X1 <= (local_84->sbox).X1) {
              b.X1 = (local_84->sbox).X1;
            }
            pLVar2 = &(local_84->sbox).X2;
            if (*pLVar2 == b.X2 || *pLVar2 < b.X2) {
              b.X2 = (local_84->sbox).X2;
            }
            b.Y1 = (prVar5->sbox).Y1;
            b.Y2 = (prVar5->sbox).Y2;
            if (b.Y1 <= (local_84->sbox).Y1) {
              b.Y1 = (local_84->sbox).Y1;
            }
            pLVar2 = &(local_84->sbox).Y2;
            if (*pLVar2 == b.Y2 || *pLVar2 < b.Y2) {
              b.Y2 = (local_84->sbox).Y2;
            }
            LVar27 = b.X1;
            if ((b.X1 <= nextpoint.X) && (LVar27 = nextpoint.X, b.X2 <= nextpoint.X)) {
              LVar27 = b.X2 + -1;
            }
            nextpoint.X = LVar27;
            LVar27 = b.Y1;
            if ((b.Y1 <= nextpoint.Y) && (LVar27 = nextpoint.Y, b.Y2 <= nextpoint.Y)) {
              LVar27 = b.Y2 + -1;
            }
          }
          nextpoint.Y = LVar27;
          RD_DrawThermal(rd,nextpoint.X,nextpoint.Y,(uint)local_84->group,(uint)local_84->layer,from
                         ,(Boolean)local_a0);
          local_ad = '\0';
        }
        do {
          lastpoint.X = nextpoint.X;
          lastpoint.Y = nextpoint.Y;
          prVar16 = (local_84->parent).via_shadow;
          b.X1 = (prVar16->sbox).X1;
          b.Y1 = (prVar16->sbox).Y1;
          b.X2 = (prVar16->sbox).X2;
          b.Y2 = (prVar16->sbox).Y2;
          if ((*(byte *)&prVar16->flags & 0x20) != 0) {
            iVar23 = b.X2 - b.X1;
            if (b.Y2 - b.Y1 < b.X2 - b.X1) {
              iVar23 = b.Y2 - b.Y1;
            }
            iVar23 = iVar23 / 5;
            b.X1 = iVar23 + b.X1;
            b.X2 = b.X2 - iVar23;
            b.Y1 = iVar23 + b.Y1;
            b.Y2 = b.Y2 - iVar23;
          }
          iVar23 = b.X1;
          if ((b.X1 <= nextpoint.X) && (iVar23 = nextpoint.X, b.X2 <= nextpoint.X)) {
            iVar23 = b.X2 + -1;
          }
          nextpoint.X = iVar23;
          iVar23 = b.Y1;
          if ((b.Y1 <= nextpoint.Y) && (iVar23 = nextpoint.Y, b.Y2 <= nextpoint.Y)) {
            iVar23 = b.Y2 + -1;
          }
          nextpoint.Y = iVar23;
          if (((*(byte *)&prVar16->flags & 4) != 0) && (prVar16->type != GDK_NOOP)) {
            TargetPoint(&nextpoint,prVar16);
          }
          if (AutoRouteParameters.last_smooth == '\0') {
            start.Y = lastpoint.Y;
            start.X = lastpoint.X;
            end.Y = nextpoint.Y;
            end.X = nextpoint.X;
            local_ad = RD_DrawManhattanLine
                                 (rd,&local_84->sbox,&prVar16->sbox,start,end,iVar29,
                                  (uint)prVar16->group,from,(Boolean)local_a0,local_ad);
            bVar10 = (prVar16->flags).field_0x1;
            pPVar28 = PCB;
            iVar23 = nextpoint.X;
            iVar25 = nextpoint.Y;
          }
          else {
            RD_DrawLine(rd,lastpoint.X,lastpoint.Y,nextpoint.X,nextpoint.Y,iVar29,
                        (uint)prVar16->group,from,(Boolean)local_a0,'\x01');
            bVar10 = (prVar16->flags).field_0x1;
            pPVar28 = PCB;
            iVar23 = nextpoint.X;
            iVar25 = nextpoint.Y;
          }
          PCB = pPVar28;
          nextpoint.X = iVar23;
          nextpoint.Y = iVar25;
          if (((bVar10 & 4) != 0) &&
             (iVar26 = (AutoRouteParameters.style)->Keepaway, 0 < pPVar28->Data->LayerN)) {
            iVar31 = 0;
            local_8c = (routebox_t *)0x0;
            iVar12 = iVar25 + 1 + iVar15;
            iVar30 = iVar23 + 1 + iVar15;
            do {
              if (is_layer_group_active[iVar31] != '\0') {
                prVar20 = (routebox_t *)calloc(1,0x7c);
                first_via = prVar20;
                for (iVar24 = 0x1f; iVar24 != 0; iVar24 = iVar24 + -1) {
                  first_via = (routebox_t *)((int)first_via + (uint)bVar33 * -8 + 4);
                  (first_via->box).X1 = 0;
                  first_via = first_via;
                }
                prVar20->group = (ushort)iVar31;
                (prVar20->sbox).Y1 = iVar25 - iVar15;
                (prVar20->sbox).X1 = iVar23 - iVar15;
                (prVar20->box).X1 = (iVar23 - iVar15) - iVar26;
                (prVar20->sbox).X2 = iVar30;
                (prVar20->box).Y1 = (iVar25 - iVar15) - iVar26;
                (prVar20->sbox).Y2 = iVar12;
                (prVar20->box).X2 = iVar30 + iVar26;
                (prVar20->box).Y2 = iVar12 + iVar26;
                uVar22 = (uint)(byte)AutoRouteParameters.is_odd;
                (prVar20->flags).field_0x1 = (byte)((local_a0 & 1) << 5) | 0x40;
                prVar20->came_from = ALL;
                *(byte *)&prVar20->flags = (byte)(uVar22 << 7) | 0x20;
                pRVar9 = AutoRouteParameters.style;
                prVar20->style = AutoRouteParameters.style;
                prVar20->pass = AutoRouteParameters.pass;
                if (local_8c == (routebox_t *)0x0) {
                  (prVar20->parent).pad = (PadTypePtr)0x0;
                  BVar35 = pRVar9->Keepaway;
                  prVar20->type = DBUS_BUS_STARTER;
                  mtspace_add(rd->mtspace,(BoxType *)prVar20,
                              ~-(uint)((uVar22 << 7 & 0x80) == 0) + EVEN,BVar35);
                  local_8c = prVar20;
                }
                else {
                  prVar20->type = GDK_CAP_PROJECTING;
                  (prVar20->parent).pad = (PadTypePtr)local_8c;
                }
                InitLists(prVar20);
                MergeNets(prVar20,from,NET);
                MergeNets(prVar20,from,SUBNET);
                r_insert_entry(rd->layergrouptree[prVar20->group],(BoxType *)prVar20,1);
                *(byte *)&prVar20->flags = *(byte *)&prVar20->flags & 0xbf;
                pPVar28 = PCB;
                if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
                  (*gui->set_color)(ar_gc,PCB->ViaColor);
                  (*gui->fill_circle)(ar_gc,iVar23,iVar25,iVar15);
                  pPVar28 = PCB;
                }
              }
              iVar31 = iVar31 + 1;
            } while (iVar31 < pPVar28->Data->LayerN);
          }
          if (((prVar16->flags).is_thermal != 0) || (aVar8 = prVar16->type, aVar8 == GDK_NOOP)) {
            RD_DrawThermal(rd,lastpoint.X,lastpoint.Y,(uint)prVar16->group,(uint)prVar16->layer,from
                           ,(Boolean)local_a0);
            aVar8 = prVar16->type;
          }
          if ((((aVar8 == EXPANSION_AREA) &&
               (prVar20 = (routebox_t *)(prVar16->parent).pad, (*(byte *)&prVar20->flags & 4) != 0))
              && (prVar20->type != GDK_NOOP)) &&
             (BVar11 = TargetPoint(&lastpoint,prVar20), BVar11 != '\0')) {
            iVar23 = (prVar16->sbox).X1;
            if ((iVar23 <= lastpoint.X) &&
               (iVar25 = (prVar16->sbox).X2, iVar23 = lastpoint.X, iVar25 <= lastpoint.X)) {
              iVar23 = iVar25 + -1;
            }
            iVar25 = (prVar16->sbox).Y1;
            if ((iVar25 <= lastpoint.Y) &&
               (iVar26 = (prVar16->sbox).Y2, iVar25 = lastpoint.Y, iVar26 <= lastpoint.Y)) {
              iVar25 = iVar26 + -1;
            }
            b.X2 = (prVar16->sbox).X2;
            b.Y1 = (prVar16->sbox).Y1;
            b.X1 = (prVar16->sbox).X1;
            b.Y2 = (prVar16->sbox).Y2;
            lastpoint.X = iVar23;
            lastpoint.Y = iVar25;
            if (AutoRouteParameters.last_smooth == '\0') {
              start_01.Y = nextpoint.Y;
              start_01.X = nextpoint.X;
              end_01.Y = iVar25;
              end_01.X = iVar23;
              local_ad = RD_DrawManhattanLine
                                   (rd,&b,&b,start_01,end_01,iVar29,(uint)prVar16->group,from,
                                    (Boolean)local_a0,local_ad);
            }
            else {
              RD_DrawLine(rd,iVar23,iVar25,nextpoint.X,nextpoint.Y,iVar29,(uint)prVar16->group,from,
                          (Boolean)local_a0,'\x01');
            }
            nextpoint.X = lastpoint.X;
            nextpoint.Y = lastpoint.Y;
          }
          local_84 = prVar16;
        } while ((*(byte *)&prVar16->flags & 4) == 0);
        RD_DrawLine(rd,-1,0,0,0,0,0,(routebox_t *)0x0,'\0','\0');
        if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
          (*gui->use_mask)(6);
        }
        BVar11 = '\x01';
        MergeNets(from,s.best_target,SUBNET);
      }
LAB_080727ac:
      while (iVar29 = vector_is_empty(area_vec), iVar29 == 0) {
        pBVar18 = (BoxType *)vector_remove_last(area_vec);
        if ((pBVar18[4].X2 != 0) && (pBVar18[4].X2 != *(int *)(pBVar18[2].X1 + 0x48))) {
          vector_destroy((vector_t **)&pBVar18[4].X2);
        }
        r_delete_entry(rd->layergrouptree[*(ushort *)&pBVar18[2].Y1],pBVar18);
      }
      vector_destroy(&area_vec);
      prVar16 = from;
      if (from != (routebox_t *)0x0) {
        do {
          bVar33 = *(byte *)&prVar16->flags;
          prVar20 = (prVar16->same_net).next;
          if (((bVar33 & 4) != 0) && (prVar16->conflicts_with != (vector_t *)0x0)) {
            vector_destroy(&prVar16->conflicts_with);
            bVar33 = *(byte *)&prVar16->flags;
          }
          puVar1 = &(prVar16->flags).field_0x1;
          *puVar1 = *puVar1 & 0xfe;
          *(byte *)&prVar16->flags = bVar33 & 0xe3;
          prVar16 = prVar20;
        } while (from != prVar20);
      }
      vector_destroy(&vss.free_space_vec);
      vector_destroy(&vss.lo_conflict_space_vec);
      vector_destroy(&vss.hi_conflict_space_vec);
      in_EAX->net_completely_routed = '\0';
      in_EAX->best_route_cost = cVar34;
      in_EAX->found_route = BVar11;
      in_EAX->route_had_conflicts = local_a0;
      return in_EAX;
    }
  }
  else {
    bVar10 = *(byte *)&to->flags;
    if ((bVar10 & 4) == 0) {
      iVar29 = 0;
      prVar16 = to;
      while( true ) {
        prVar5 = (prVar16->same_subnet).next;
        if (((bVar10 & 1) == 0) && (is_layer_group_active[prVar16->group] != '\0')) {
          *(byte *)&prVar16->flags = *(byte *)&prVar16->flags | 8;
          iVar29 = iVar29 + 1;
        }
        if (to == prVar5) break;
        bVar10 = *(byte *)&prVar5->flags;
        prVar16 = prVar5;
      }
      goto LAB_080721ae;
    }
  }
  prVar16 = from;
  if (from != (routebox_t *)0x0) {
    do {
      prVar20 = (prVar16->same_net).next;
      *(byte *)&prVar16->flags = *(byte *)&prVar16->flags & 0xe3;
      prVar16 = prVar20;
    } while (from != prVar20);
  }
LAB_0807249d:
  in_EAX->best_route_cost = 0.0;
  in_EAX->net_completely_routed = '\x01';
  in_EAX->found_route = '\0';
  in_EAX->route_had_conflicts = 0;
  return in_EAX;
}



// WARNING: Unknown calling convention

routeall_status * RouteAll(routedata_t *rd)

{
  undefined *puVar1;
  int iVar2;
  routebox *prVar3;
  routebox *prVar4;
  float fVar5;
  bool bVar6;
  anon_struct_8_16_88ec3562_for_flags *paVar7;
  heap_t *phVar8;
  heap_t *phVar9;
  heap_t *this_pass;
  heap_t *next_pass;
  heap_t *net_heap;
  routebox_t *__next_one__;
  int iVar10;
  routebox *prVar11;
  routebox_t *__next_one___1;
  routebox *prVar12;
  routebox *prVar13;
  routebox_t *__next_one___8;
  routebox_t *from;
  routebox_t *prVar14;
  int iVar15;
  BDimension thick;
  routebox_t *__next_one___5;
  routebox *prVar16;
  LocationType Y2;
  int iVar17;
  heap_t *tmp;
  routebox_t *__next_one___4;
  routebox_t *__next_one___9;
  int iVar18;
  routebox_t *p;
  routebox_t *__next_one___2;
  char cVar19;
  routebox_t *net;
  routeall_status *in_stack_00000004;
  int local_74;
  int local_70;
  int local_6c;
  int local_68;
  int local_64;
  int local_60;
  LocationType local_5c;
  routebox_t *local_58;
  int local_54;
  int local_50;
  double local_4c;
  routeone_status ros;
  heap_t *local_28;
  heap_t *local_24;
  heap_t *local_20 [4];
  
  local_24 = heap_create();
  local_28 = heap_create();
  next_pass = heap_create();
  local_58 = rd->first_net;
  if (rd->first_net != (routebox_t *)0x0) {
    do {
      prVar16 = (local_58->different_net).next;
      iVar10 = (local_58->sbox).Y2;
      iVar17 = (local_58->sbox).X2;
      iVar15 = (local_58->sbox).Y1;
      iVar18 = (local_58->sbox).X1;
      prVar11 = local_58;
      local_5c = iVar18;
      local_54 = iVar10;
      local_50 = iVar17;
      iVar2 = iVar15;
      while( true ) {
        prVar11 = (prVar11->same_net).next;
        if (local_5c < iVar18) {
          iVar18 = local_5c;
        }
        if (iVar2 < iVar15) {
          iVar15 = iVar2;
        }
        if (iVar17 < local_50) {
          iVar17 = local_50;
        }
        if (iVar10 < local_54) {
          iVar10 = local_54;
        }
        if (prVar11 == local_58) break;
        local_5c = (prVar11->sbox).X1;
        iVar2 = (prVar11->sbox).Y1;
        local_50 = (prVar11->sbox).X2;
        local_54 = (prVar11->sbox).Y2;
      }
      heap_insert(local_24,(double)(iVar10 - iVar15) * (double)(iVar17 - iVar18),local_58);
      local_58 = prVar16;
    } while (prVar16 != rd->first_net);
  }
  local_60 = 0;
  local_58 = (routebox_t *)0x0;
  phVar8 = local_28;
  phVar9 = local_24;
LAB_080737e8:
  do {
    local_24 = phVar9;
    local_28 = phVar8;
    local_70 = 0;
    local_74 = 0;
    local_50 = 0;
    local_54 = 0;
    local_64 = 0;
    iVar10 = heap_is_empty(local_24);
    while (iVar10 == 0) {
      prVar11 = (routebox *)heap_remove_smallest(local_24);
      InitAutoRouteParameters(local_60,prVar11->style,local_60 < 0xc,0xc < local_60,local_60 == 0xd)
      ;
      prVar16 = prVar11;
      if (local_60 == 0) {
LAB_080739d8:
        do {
          prVar16 = (prVar16->same_net).next;
          prVar13 = prVar16;
        } while (prVar11 != prVar16);
        do {
          prVar11 = (prVar13->same_net).next;
          prVar12 = prVar13;
          if (((prVar13->flags).field_0x1 & 2) == 0) {
            do {
              prVar3 = (prVar12->same_subnet).next;
              puVar1 = &(prVar12->flags).field_0x1;
              *puVar1 = *puVar1 | 2;
              prVar12 = prVar3;
            } while (prVar3 != prVar13);
            local_64 = local_64 + 1;
          }
          prVar13 = prVar11;
        } while (prVar16 != prVar11);
        do {
          prVar16 = (prVar13->same_net).next;
          puVar1 = &(prVar13->flags).field_0x1;
          *puVar1 = *puVar1 & 0xfd;
          prVar13 = prVar16;
        } while (prVar11 != prVar16);
        local_64 = local_64 + -1;
        prVar11 = prVar16;
        if (local_64 == 0) {
          heap_insert(local_28,0.0,prVar16);
        }
        else {
          do {
            prVar13 = (prVar11->same_net).next;
            if (prVar11->type == GDK_NOOP) {
              fVar5 = -1.0;
            }
            else {
              fVar5 = 10.0;
              if (prVar11->type == CONFIG_NAME_COLUMN) {
                fVar5 = 1.0;
              }
            }
            heap_insert(next_pass,
                        (double)((float)((prVar11->sbox).Y2 - (prVar11->sbox).Y1) *
                                 (float)((prVar11->sbox).X2 - (prVar11->sbox).X1) * fVar5),prVar11);
            prVar11 = prVar13;
          } while (prVar16 != prVar13);
          local_4c = 0.0;
          cVar19 = '\0';
LAB_08073bb8:
          iVar10 = heap_is_empty(next_pass);
          if (iVar10 == 0) {
LAB_08073bcb:
            from = (routebox_t *)heap_remove_smallest(next_pass);
            if ((((*(ushort *)&from->flags & 0x202) == 2) && (from->type != GDK_AND_REVERSE)) &&
               (cVar19 == '\0')) {
              while( true ) {
                RouteOne(rd,from,(routebox_t *)0x0,
                         routing_layers * (local_60 + 1) *
                         ((-(uint)(AutoRouteParameters.is_smoothing == '\0') & 0xfffffb50) + 2000));
                local_4c = local_4c + ros.best_route_cost;
                cVar19 = ros.net_completely_routed;
                if (ros.found_route == '\0') break;
                if (ros.route_had_conflicts == 0) {
                  local_54 = local_54 + 1;
                  local_58 = (routebox_t *)((int)local_58 + 1);
                }
                else {
                  local_50 = local_50 + 1;
                }
                if (ros.net_completely_routed != '\0') goto LAB_08073c64;
              }
              local_74 = local_74 + (uint)(ros.net_completely_routed == '\0');
              prVar14 = from;
              do {
                prVar11 = (prVar14->same_subnet).next;
                puVar1 = &(prVar14->flags).field_0x1;
                *puVar1 = *puVar1 | 2;
                prVar14 = prVar11;
              } while (prVar11 != from);
            }
            goto LAB_08073bb8;
          }
LAB_08073c80:
          if (cVar19 == '\0') {
            puVar1 = &(prVar13->flags).field_0x1;
            *puVar1 = *puVar1 | 0x20;
          }
          heap_insert(local_28,local_4c,prVar13);
          prVar11 = prVar16;
        }
        do {
          prVar13 = (prVar11->same_net).next;
          puVar1 = &(prVar11->flags).field_0x1;
          *puVar1 = *puVar1 & 0xfd;
          prVar11 = prVar13;
        } while (prVar16 != prVar13);
      }
      else {
        prVar13 = prVar11;
        prVar12 = prVar11;
        if (AutoRouteParameters.rip_always == '\0') {
          do {
            paVar7 = &prVar13->flags;
            prVar13 = (prVar13->same_net).next;
            if ((paVar7->field_0x1 & 0x20) != 0) goto LAB_08073893;
          } while (prVar11 != prVar13);
          bVar6 = false;
        }
        else {
LAB_08073893:
          bVar6 = true;
        }
        do {
          puVar1 = &(prVar12->flags).field_0x1;
          *puVar1 = *puVar1 & 0xdf;
          prVar13 = (prVar12->same_net).next;
          if ((*(byte *)&prVar12->flags & 2) == 0) {
            if (bVar6) {
              RemoveFromNet(prVar12,NET);
              RemoveFromNet(prVar12,SUBNET);
            }
            if (((AutoRouteParameters.use_vias == '\0') || (prVar12->type == GDK_CAP_PROJECTING)) ||
               (prVar12->type == GDK_NOOP)) {
              if (!bVar6) goto LAB_08073919;
            }
            else {
              mtspace_remove(rd->mtspace,&prVar12->box,
                             ~-(uint)((*(byte *)&prVar12->flags & 0x80) == 0) + EVEN,
                             prVar12->style->Keepaway);
              if (!bVar6) {
                mtspace_add(rd->mtspace,&prVar12->box,
                            EVEN - ((*(byte *)&prVar12->flags & 0x80) == 0),prVar12->style->Keepaway
                           );
LAB_08073919:
                *(byte *)&prVar12->flags =
                     *(byte *)&prVar12->flags & 0x7f | AutoRouteParameters.is_odd << 7;
                goto joined_r0x08073931;
              }
            }
            if (((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) &&
               ((prVar12->type == DBUS_BUS_STARTER || (prVar12->type == DBUS_WATCH_ERROR)))) {
              local_6c = (prVar12->box).X1;
              iVar10 = (prVar12->box).X2;
              iVar17 = (prVar12->box).Y1;
              iVar15 = iVar10 - local_6c;
              local_68 = (prVar12->box).Y2;
              iVar18 = local_68 - iVar17;
              if (iVar15 < iVar18) {
                local_6c = (local_6c + iVar10) / 2;
                iVar17 = iVar17 + iVar15 / 2;
                local_68 = local_68 - iVar15 / 2;
                local_5c = local_6c;
              }
              else {
                iVar17 = (iVar17 + local_68) / 2;
                local_6c = local_6c + iVar18 / 2;
                local_5c = iVar10 - iVar18 / 2;
                iVar15 = iVar18;
                local_68 = iVar17;
              }
              (*gui->set_line_width)(ar_gc,iVar15);
              (*gui->set_color)(ar_gc,Settings.BackgroundColor);
              (*gui->draw_line)(ar_gc,local_6c,iVar17,local_5c,local_68);
            }
            r_delete_entry(rd->layergrouptree[prVar12->group],&prVar12->box);
          }
joined_r0x08073931:
          prVar12 = prVar13;
        } while (prVar11 != prVar13);
        if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
          (*gui->use_mask)(6);
        }
        if (bVar6) {
          do {
            prVar3 = (prVar12->same_net).next;
            prVar4 = (prVar12->original_subnet).prev;
            (prVar12->same_subnet).next = (prVar12->original_subnet).next;
            (prVar12->same_subnet).prev = prVar4;
            prVar12 = prVar3;
          } while (prVar13 != prVar3);
          local_70 = local_70 + 1;
          goto LAB_080739d8;
        }
        heap_insert(local_28,0.0,prVar13);
      }
      iVar10 = heap_is_empty(local_24);
    }
    ro = 0;
    phVar8 = local_24;
    if ((local_50 == 0) && (local_64 == local_54)) {
      if (local_60 == 0xd) goto LAB_08073b37;
      local_60 = 0xd;
      phVar9 = local_28;
      goto LAB_080737e8;
    }
    local_60 = local_60 + 1;
    phVar9 = local_28;
    if (local_60 == 0xe) {
LAB_08073b37:
      phVar8 = local_28;
      local_28 = local_24;
      local_24 = phVar8;
      Message("%d of %d nets successfully routed.\n",local_54,local_64);
      heap_destroy(&local_24);
      heap_destroy(&local_28);
      heap_destroy(local_20);
      in_stack_00000004->total_subnets = local_64;
      in_stack_00000004->routed_subnets = local_54;
      in_stack_00000004->conflict_subnets = local_50;
      in_stack_00000004->failed = local_74;
      in_stack_00000004->ripped = local_70;
      in_stack_00000004->total_nets_routed = (int)local_58;
      return in_stack_00000004;
    }
  } while( true );
LAB_08073c64:
  iVar10 = heap_is_empty(next_pass);
  if (iVar10 != 0) goto LAB_08073c80;
  goto LAB_08073bcb;
}



// WARNING: Unknown calling convention

Boolean AutoRoute(Boolean selected)

{
  void ***pppvVar1;
  undefined *puVar2;
  uchar *puVar3;
  routebox *prVar4;
  routebox *prVar5;
  routebox_t *prVar6;
  BoxType *box;
  Boolean BVar7;
  PCBTypePtr pPVar8;
  int i;
  uint uVar9;
  Cardinal CVar10;
  Cardinal entry;
  int j;
  int *piVar11;
  int iVar12;
  int iVar13;
  Cardinal CVar14;
  Cardinal sn_1;
  TextTypePtr text;
  ArcTypePtr arc;
  rtree_t *prVar15;
  routedata_t *rd;
  routebox *prVar16;
  routebox_t *__next_one___4;
  routebox *prVar17;
  DataTypePtr paVar18;
  routebox_t *b_1;
  routebox_t *prVar19;
  uint uVar20;
  routebox_t *__next_one___6;
  routebox_t *__next_one___9;
  mtspace_t *pmVar21;
  routebox_t *rb;
  int iVar22;
  Cardinal number;
  PCBType *pPVar23;
  int dx;
  PadTypePtr line_00;
  PadTypePtr pad;
  int dx_1;
  PolygonTypePtr polygon;
  PolygonTypePtr polygon_00;
  Cardinal n_8;
  routebox_t *__next_one___5;
  routebox_t *__next_one___2;
  PadTypePtr paVar24;
  routebox_t *__next_one___7;
  PinTypePtr pin;
  PinTypePtr paVar25;
  PinTypePtr via;
  routebox_t *__next_one__;
  routebox_t *__next_one___3;
  Boolean changed;
  int group;
  int *piVar26;
  int iVar27;
  int segs;
  Cardinal n;
  uint uVar28;
  ElementTypePtr element_1;
  Cardinal n_2;
  LineTypePtr line_1;
  LineTypePtr line_01;
  Cardinal n_6;
  FlagType *pFVar29;
  RatTypePtr line_2;
  routebox_t *__next_one___1;
  routebox *prVar30;
  RatTypePtr line_3;
  ElementTypePtr paVar31;
  RatTypePtr paVar32;
  routebox_t *b;
  routebox_t *__next_one___8;
  Cardinal sn_2;
  Cardinal *pCVar33;
  routebox_t *last_net;
  routebox_t *prVar34;
  LineType *line;
  int qq;
  routebox_t *net;
  Cardinal sn;
  int segs_1;
  LineTypePtr pLVar35;
  Cardinal n_3;
  Cardinal n_4;
  PointerListType *pPVar36;
  Cardinal n_7;
  routebox *prVar37;
  routebox *prVar38;
  routebox_t *last;
  routedata_t *prVar39;
  NetListListType *pNVar40;
  int dy;
  ElementTypePtr element;
  Cardinal n_1;
  LineType *pLVar41;
  int dy_1;
  uint uVar42;
  int in_GS_OFFSET;
  bool bVar43;
  byte bVar44;
  RouteStyleType *pRVar45;
  routebox_t *local_1d8;
  int local_1cc;
  int local_1c8;
  int local_1c0;
  int local_1bc;
  Cardinal local_1b0;
  routebox_t *local_1a8;
  int local_1a4;
  int local_1a0;
  void ***local_19c;
  uint local_198;
  routebox_t *local_194;
  int local_190;
  Cardinal local_18c [6];
  PointerListType layergroupboxes [16];
  int local_a0;
  char local_9c;
  NetListListType Nets;
  routedata_t *local_7c;
  LineType fake_line;
  char *local_20;
  
  bVar44 = 0;
  local_20 = *(char **)(in_GS_OFFSET + 0x14);
  total_wire_length = 0.0;
  total_via_count = 0;
  if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
    (*gui->use_mask)(4);
  }
  if (ar_gc == (hidGC)0x0) {
    ar_gc = (*gui->make_gc)();
    (*gui->set_line_cap)(ar_gc,Round_Cap);
  }
  pPVar8 = PCB;
  do {
    if ((((pPVar8->RouteStyle[0].Thick == 0) || (PCB->RouteStyle[1].Diameter == 0)) ||
        (PCB->RouteStyle[1].Hole == 0)) || (pPVar8->RouteStyle[0].Keepaway == 0)) {
      BVar7 = '\0';
      Message("You must define proper routing styles\nbefore auto-routing.\n");
      goto LAB_08073ebd;
    }
    pPVar8 = (PCBTypePtr)&pPVar8->PrintFilename;
  } while (pPVar8 != (PCBTypePtr)&PCB->MaskColor);
  BVar7 = '\0';
  if (PCB->Data->RatN == 0) goto LAB_08073ebd;
  SaveFindFlag(0x1000);
  pPVar8 = PCB;
  routing_layers = 0;
  paVar18 = PCB->Data;
  local_198 = paVar18->LayerN;
  if ((int)local_198 < 1) {
LAB_0807407c:
    AutoRouteParameters.use_vias = '\0';
  }
  else {
    local_194 = (routebox_t *)0x0;
    group = 0;
    do {
      if ((pPVar8->LayerGroups).Number[group] != 0) {
        uVar9 = 0;
        while( true ) {
          uVar28 = (pPVar8->LayerGroups).Entries[group][uVar9];
          if ((uVar28 < local_198) && (paVar18->Layer[uVar28].On != '\0')) {
            is_layer_group_active[group] = '\x01';
            paVar18 = pPVar8->Data;
            local_194 = (routebox_t *)((int)local_194 + 1);
            local_198 = paVar18->LayerN;
            goto LAB_08073fad;
          }
          is_layer_group_active[group] = '\0';
          uVar9 = uVar9 + 1;
          pCVar33 = (pPVar8->LayerGroups).Number + group;
          if (*pCVar33 < uVar9 || *pCVar33 == uVar9) break;
          paVar18 = pPVar8->Data;
          local_198 = paVar18->LayerN;
        }
        paVar18 = pPVar8->Data;
        local_198 = paVar18->LayerN;
      }
LAB_08073fad:
      group = group + 1;
    } while (group < (int)local_198);
    routing_layers = (int)local_194;
    if (((int)local_194 < 2) || (AutoRouteParameters.use_vias = '\x01', pPVar8->ViaOn == '\0'))
    goto LAB_0807407c;
  }
  front = GetLayerGroupNumberByNumber(pPVar8->Data->LayerN + 1);
  CVar10 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  CVar14 = front;
  paVar18 = PCB->Data;
  back = CVar10;
  if (0 < paVar18->LayerN) {
    uVar9 = 0;
    do {
      if (CVar10 == uVar9) {
        x_cost[CVar10] = 4;
        y_cost[CVar10] = 2;
      }
      else if (CVar14 == uVar9) {
        x_cost[CVar14] = 2;
        y_cost[CVar14] = 2;
      }
      else {
        if ((uVar9 & 1) == 0) {
          x_cost[uVar9] = 1;
          iVar22 = 2;
        }
        else {
          x_cost[uVar9] = 2;
          iVar22 = 1;
        }
        y_cost[uVar9] = iVar22;
      }
      uVar9 = uVar9 + 1;
    } while ((int)uVar9 < paVar18->LayerN);
  }
  local_7c = (routedata_t *)calloc(1,0x7c);
  prVar39 = local_7c;
  for (iVar22 = 0x1f; iVar12 = Settings.LineThickness, iVar22 != 0; iVar22 = iVar22 + -1) {
    prVar39->layergrouptree[0] = (rtree_t *)0x0;
    prVar39 = (routedata_t *)((int)prVar39 + (uint)bVar44 * -8 + 4);
  }
  (local_7c->defaultstyle).Thick = Settings.LineThickness;
  (local_7c->defaultstyle).Diameter = Settings.ViaThickness;
  (local_7c->defaultstyle).Hole = Settings.ViaDrillingHole;
  iVar22 = Settings.Keepaway;
  (local_7c->defaultstyle).Keepaway = Settings.Keepaway;
  local_7c->max_keep = iVar22;
  pPVar8 = PCB;
  local_7c->max_bloat = (iVar12 + 1) / 2 + iVar22;
  local_7c->styles[0] = pPVar8->RouteStyle;
  local_7c->styles[1] = pPVar8->RouteStyle + 1;
  local_7c->styles[2] = pPVar8->RouteStyle + 2;
  local_7c->styles[3] = pPVar8->RouteStyle + 3;
  local_7c->styles[4] = &local_7c->defaultstyle;
  paVar18 = pPVar8->Data;
  if (0 < paVar18->LayerN) {
    local_19c = &layergroupboxes[0].Ptr;
    local_190 = 0;
    do {
      pPVar23 = paVar18->pcb;
      ((PointerListType *)(local_19c + -2))->PtrN = 0;
      local_19c[-1] = (void **)0x0;
      *local_19c = (void **)0x0;
      if ((pPVar23->LayerGroups).Number[local_190] != 0) {
        uVar9 = 0;
LAB_08074214:
        do {
          uVar28 = (pPVar23->LayerGroups).Entries[local_190][uVar9];
          if (uVar28 < (uint)paVar18->LayerN) {
            if ((paVar18->Layer[uVar28].LineN != 0) || (paVar18->Layer[uVar28].ArcN != 0)) {
              uVar9 = uVar9 + 1;
              usedGroup[local_190] = '\x01';
              paVar18 = pPVar8->Data;
              pPVar23 = paVar18->pcb;
              if ((pPVar23->LayerGroups).Number[local_190] <= uVar9) break;
              goto LAB_08074214;
            }
            usedGroup[local_190] = '\0';
            paVar18 = pPVar8->Data;
          }
          pPVar23 = paVar18->pcb;
          uVar9 = uVar9 + 1;
        } while (uVar9 < (pPVar23->LayerGroups).Number[local_190]);
      }
      local_190 = local_190 + 1;
      local_19c = local_19c + 3;
    } while (local_190 < paVar18->LayerN);
  }
  usedGroup[front] = '\x01';
  usedGroup[back] = '\x01';
  ResetFoundPinsViasAndPads('\0');
  ResetFoundLinesAndPolygons('\0');
  CollectSubnets('\0');
  pCVar33 = local_18c;
  pNVar40 = &Nets;
  for (iVar22 = 3; iVar22 != 0; iVar22 = iVar22 + -1) {
    pNVar40->NetListN = *pCVar33;
    pCVar33 = pCVar33 + (uint)bVar44 * -2 + 1;
    pNVar40 = (NetListListType *)((int)pNVar40 + (uint)bVar44 * -8 + 4);
  }
  local_1a8 = (routebox_t *)0x0;
  local_1c8 = Nets.NetListN - 1;
  if (local_1c8 != -1) {
    local_1d8 = (routebox_t *)0x0;
    iVar22 = Nets.NetListN * 0xc;
    do {
      local_1cc = iVar22 + -0xc;
      piVar26 = (int *)((int)&Nets.NetList[-1].NetN + iVar22);
      iVar22 = *piVar26;
      local_1c0 = iVar22 + -1;
      local_1a8 = (routebox_t *)0x0;
      if (local_1c0 != -1) {
        local_1bc = (iVar22 + 0xfffffff) * 0x10;
        local_1a8 = (routebox_t *)0x0;
        do {
          piVar11 = (int *)(local_1bc + piVar26[2]);
          pRVar45 = (RouteStyleType *)piVar11[3];
          iVar22 = 0;
          if (((pRVar45 != local_7c->styles[0]) && (iVar22 = 1, pRVar45 != local_7c->styles[1])) &&
             (iVar22 = 2, pRVar45 != local_7c->styles[2])) {
            iVar22 = (pRVar45 != local_7c->styles[3]) + 3;
          }
          local_194 = (routebox_t *)0x0;
          local_1a0 = *piVar11 + -1;
          if (local_1a0 == -1) {
            bVar43 = local_1a8 != (routebox_t *)0x0;
          }
          else {
            do {
              iVar27 = local_1a0 * 0x1c + piVar11[2];
              paVar24 = *(PadTypePtr *)(iVar27 + 0x10);
              (paVar24->Flags).f = (paVar24->Flags).f | 0x1000;
              iVar12 = *(int *)(iVar27 + 8);
              if (iVar12 == 4) {
                local_1a0 = local_1a0 + -1;
                if (((paVar24->Point1).X == (paVar24->Point2).X) ||
                   ((paVar24->Point1).Y == (paVar24->Point2).Y)) {
                  iVar12 = *(int *)(iVar27 + 0x14);
                  pRVar45 = local_7c->styles[iVar22];
                  line_00 = paVar24;
                }
                else {
                  line = (LineType *)paVar24;
                  pLVar41 = &fake_line;
                  for (iVar12 = 0x16; iVar12 != 0; iVar12 = iVar12 + -1) {
                    line = (LineType *)((int)line + (uint)bVar44 * -8 + 4);
                    (pLVar41->BoundingBox).X1 = (line->BoundingBox).X1;
                    line = line;
                    pLVar41 = (LineType *)((int)pLVar41 + (uint)bVar44 * -8 + 4);
                  }
                  dx = (paVar24->Point2).X - (paVar24->Point1).X;
                  dy = (paVar24->Point2).Y - (paVar24->Point1).Y;
                  iVar12 = (dx >> 0x1f ^ dx) - (dx >> 0x1f);
                  iVar13 = (dy >> 0x1f ^ dy) - (dy >> 0x1f);
                  if (iVar12 < iVar13) {
                    iVar12 = iVar13;
                  }
                  iVar12 = iVar12 / (((local_7c->styles[iVar22]->Thick + 1) / 2 +
                                     local_7c->styles[iVar22]->Keepaway) * 4 + 1);
                  if (0 < iVar12) {
                    iVar13 = 0x20;
                    if (iVar12 < 0x21) {
                      iVar13 = iVar12;
                    }
                    if (iVar13 != 1) {
                      iVar12 = 0;
                      prVar34 = local_1a8;
                      do {
                        fake_line.Point2.X = dx / iVar13 + fake_line.Point1.X;
                        fake_line.Point2.Y = dy / iVar13 + fake_line.Point1.Y;
                        if ((fake_line.Point2.X == (paVar24->Point2).X) &&
                           (local_1a8 = prVar34, fake_line.Point2.Y == (paVar24->Point2).Y)) break;
                        local_1a8 = AddLine(layergroupboxes,*(int *)(iVar27 + 0x14),&fake_line,
                                            (LineTypePtr)paVar24,local_7c->styles[iVar22]);
                        if ((local_1a8 != local_194) && (local_194 != (routebox_t *)0x0)) {
                          MergeNets(local_194,local_1a8,ORIGINAL);
                        }
                        if ((local_1a8 != prVar34) && (prVar34 != (routebox_t *)0x0)) {
                          MergeNets(prVar34,local_1a8,NET);
                        }
                        iVar12 = iVar12 + 1;
                        fake_line.Point1.X = fake_line.Point2.X;
                        fake_line.Point1.Y = fake_line.Point2.Y;
                        fake_line.Point1.X2 = fake_line.Point2.X2;
                        fake_line.Point1.Y2 = fake_line.Point2.Y2;
                        fake_line.Point1.ID = fake_line.Point2.ID;
                        prVar34 = local_1a8;
                        local_194 = local_1a8;
                      } while (iVar12 < iVar13 + -1);
                    }
                  }
                  fake_line.Point2.X = (paVar24->Point2).X;
                  fake_line.Point2.Y = (paVar24->Point2).Y;
                  fake_line.Point2.X2 = (paVar24->Point2).X2;
                  fake_line.Point2.Y2 = (paVar24->Point2).Y2;
                  fake_line.Point2.ID = (paVar24->Point2).ID;
                  pRVar45 = local_7c->styles[iVar22];
                  iVar12 = *(int *)(iVar27 + 0x14);
                  line_00 = (PadTypePtr)&fake_line;
                }
                prVar34 = AddLine(layergroupboxes,iVar12,(LineTypePtr)line_00,(LineTypePtr)paVar24,
                                  pRVar45);
                bVar43 = prVar34 != (routebox_t *)0x0;
              }
              else if (iVar12 == 8) {
                pRVar45 = local_7c->styles[iVar22];
                CVar14 = GetLayerNumber(PCB->Data,*(LayerTypePtr *)(iVar27 + 0xc));
                prVar34 = AddPolygon(layergroupboxes,CVar14,(PolygonTypePtr)paVar24,pRVar45);
                bVar43 = prVar34 != (routebox_t *)0x0;
              }
              else if (iVar12 < 9) {
                if (iVar12 == 1) {
                  pRVar45 = local_7c->styles[iVar22];
                  BVar7 = '\x01';
LAB_08074775:
                  prVar34 = AddPin(layergroupboxes,(PinTypePtr)paVar24,BVar7,pRVar45);
                  bVar43 = prVar34 != (routebox_t *)0x0;
                }
                else {
LAB_08074466:
                  bVar43 = false;
                  prVar34 = (routebox_t *)0x0;
                }
              }
              else {
                if (iVar12 == 0x100) {
                  BVar7 = '\0';
                  pRVar45 = local_7c->styles[iVar22];
                  goto LAB_08074775;
                }
                if (iVar12 != 0x200) goto LAB_08074466;
                prVar34 = AddPad(layergroupboxes,*(ElementTypePtr *)(iVar27 + 0xc),paVar24,
                                 local_7c->styles[iVar22]);
                bVar43 = prVar34 != (routebox_t *)0x0;
              }
              if ((local_194 != prVar34) && (local_194 != (routebox_t *)0x0)) {
                MergeNets(local_194,prVar34,ORIGINAL);
              }
              if ((prVar34 != local_1a8) && (local_1a8 != (routebox_t *)0x0)) {
                MergeNets(local_1a8,prVar34,NET);
              }
              pRVar45 = prVar34->style;
              iVar12 = (pRVar45->Thick + 1) / 2 + pRVar45->Keepaway;
              if (iVar12 < local_7c->max_bloat) {
                iVar12 = local_7c->max_bloat;
              }
              local_7c->max_bloat = iVar12;
              iVar12 = pRVar45->Keepaway;
              if (iVar12 <= local_7c->max_keep) {
                iVar12 = local_7c->max_keep;
              }
              local_1a0 = local_1a0 + -1;
              local_7c->max_keep = iVar12;
              local_1a8 = prVar34;
              local_194 = prVar34;
            } while (local_1a0 != -1);
          }
          local_1c0 = local_1c0 + -1;
          local_1bc = local_1bc + -0x10;
        } while (local_1c0 != -1);
        if ((bVar43) && (local_1d8 != (routebox_t *)0x0)) {
          MergeNets(local_1d8,local_1a8,DIFFERENT_NET);
        }
      }
      local_1c8 = local_1c8 + -1;
      local_1d8 = local_1a8;
      iVar22 = local_1cc;
    } while (local_1c8 != -1);
  }
  local_7c->first_net = local_1a8;
  FreeNetListListMemory((NetListListTypePtr)&Nets);
  prVar34 = local_7c->first_net;
  if (local_7c->first_net != (routebox_t *)0x0) {
    do {
      prVar37 = (prVar34->different_net).next;
      prVar19 = prVar34;
      do {
        prVar4 = (prVar19->same_net).next;
        prVar30 = (prVar19->original_subnet).prev;
        (prVar19->same_subnet).next = (prVar19->original_subnet).next;
        (prVar19->same_subnet).prev = prVar30;
        prVar19 = prVar4;
      } while (prVar4 != prVar34);
      prVar34 = prVar37;
    } while (prVar37 != local_7c->first_net);
  }
  paVar18 = PCB->Data;
  local_190 = paVar18->ElementN - 1;
  pPVar8 = PCB;
  if (local_190 != -1) {
    iVar22 = paVar18->ElementN * 300;
    while( true ) {
      local_194 = (routebox_t *)(iVar22 + -300);
      paVar31 = paVar18->Element;
      uVar9 = *(uint *)((int)&paVar31[-1].PinN + iVar22);
      if (uVar9 != 0) {
        uVar28 = 0;
        do {
          paVar25 = (PinTypePtr)(uVar28 * 0x4c + *(int *)((int)&paVar31[-1].Pin + iVar22));
          uVar20 = (paVar25->Flags).f;
          if ((uVar20 & 0x1000) == 0) {
            AddPin(layergroupboxes,paVar25,'\0',local_7c->styles[4]);
            uVar20 = *(uint *)((int)&paVar31[-1].PinN + iVar22);
            pPVar8 = PCB;
          }
          else {
            (paVar25->Flags).f = uVar20 & 0xffffefff;
            uVar20 = uVar9;
            pPVar8 = PCB;
          }
          PCB = pPVar8;
        } while ((uVar20 != 0) &&
                (uVar28 = (uVar28 + 1 + uVar20) - uVar9, uVar9 = uVar20, uVar28 < uVar20));
        paVar18 = pPVar8->Data;
      }
      local_190 = local_190 + -1;
      if (local_190 == -1) break;
      paVar18 = pPVar8->Data;
      iVar22 = (int)local_194;
    }
    local_194 = (routebox_t *)(paVar18->ElementN - 1);
    if (local_194 != (routebox_t *)0xffffffff) {
      iVar22 = paVar18->ElementN * 300;
      while( true ) {
        local_19c = (void ***)(iVar22 + -300);
        iVar12 = 0;
        uVar42 = 0;
        paVar31 = (ElementTypePtr)(paVar18->Element[-1].Flags.t + iVar22 + -0x18);
        uVar9 = paVar31->PadN;
        uVar20 = uVar9;
        uVar28 = uVar9;
        while ((uVar20 != 0 && (uVar42 < uVar20))) {
          paVar24 = (PadTypePtr)((paVar31->Pad->Flags).t + iVar12 + -0x18);
          uVar20 = (paVar24->Flags).f;
          if ((uVar20 & 0x1000) == 0) {
            AddPad(layergroupboxes,paVar31,paVar24,local_7c->styles[4]);
            uVar28 = paVar31->PadN;
          }
          else {
            (paVar24->Flags).f = uVar20 & 0xffffefff;
          }
          uVar20 = uVar28;
          if (uVar9 == uVar28) {
            uVar42 = uVar42 + 1;
            iVar12 = iVar12 + 0x68;
            uVar20 = uVar9;
          }
        }
        local_194 = (routebox_t *)((int)local_194 + -1);
        if (local_194 == (routebox_t *)0xffffffff) break;
        paVar18 = PCB->Data;
        iVar22 = (int)local_19c;
      }
      paVar18 = PCB->Data;
      pPVar8 = PCB;
    }
  }
  if (paVar18->ViaN != 0) {
    uVar28 = 0;
    uVar9 = paVar18->ViaN;
    do {
      paVar25 = paVar18->Via + uVar28;
      uVar20 = (paVar25->Flags).f;
      if ((uVar20 & 0x1000) == 0) {
        AddPin(layergroupboxes,paVar25,'\x01',local_7c->styles[4]);
        pPVar8 = PCB;
      }
      else {
        (paVar25->Flags).f = uVar20 & 0xffffefff;
      }
      paVar18 = pPVar8->Data;
      uVar20 = paVar18->ViaN;
    } while ((uVar20 != 0) &&
            (uVar28 = (uVar20 + 1 + uVar28) - uVar9, uVar9 = uVar20, uVar28 < uVar20));
  }
  if (0 < paVar18->LayerN) {
    local_1b0 = 0;
LAB_08074a72:
    CVar10 = GetLayerGroupNumberByNumber(local_1b0);
    paVar18 = PCB->Data;
    CVar14 = paVar18->Layer[local_1b0].LineN;
    local_1a4 = CVar14 - 1;
    pPVar8 = PCB;
    if (local_1a4 != -1) {
      iVar22 = CVar14 * 0x58;
      do {
        local_1a8 = (routebox_t *)(iVar22 + -0x58);
        line_01 = (LineTypePtr)(paVar18->Layer[local_1b0].Line[-1].Flags.t + iVar22 + -0x18);
        uVar9 = (line_01->Flags).f;
        if ((uVar9 & 0x1000) == 0) {
          if (((line_01->Point1).X == (line_01->Point2).X) ||
             ((line_01->Point1).Y == (line_01->Point2).Y)) {
            AddLine(layergroupboxes,CVar10,line_01,line_01,local_7c->styles[4]);
            pPVar8 = PCB;
          }
          else {
            pLVar35 = line_01;
            pLVar41 = &fake_line;
            for (iVar22 = 0x16; iVar22 != 0; iVar22 = iVar22 + -1) {
              (pLVar41->BoundingBox).X1 = (pLVar35->BoundingBox).X1;
              pLVar35 = (LineTypePtr)((int)pLVar35 + (uint)bVar44 * -8 + 4);
              pLVar41 = (LineType *)((int)pLVar41 + (uint)bVar44 * -8 + 4);
            }
            dx_1 = (line_01->Point2).X - (line_01->Point1).X;
            dy_1 = (line_01->Point2).Y - (line_01->Point1).Y;
            iVar22 = (dx_1 >> 0x1f ^ dx_1) - (dx_1 >> 0x1f);
            iVar12 = (dy_1 >> 0x1f ^ dy_1) - (dy_1 >> 0x1f);
            if (iVar22 < iVar12) {
              iVar22 = iVar12;
            }
            iVar22 = iVar22 / (local_7c->max_bloat * 4 + 1);
            if (0 < iVar22) {
              iVar12 = 0x20;
              if (iVar22 < 0x21) {
                iVar12 = iVar22;
              }
              if (iVar12 != 1) {
                iVar22 = 0;
                do {
                  fake_line.Point2.X = dx_1 / iVar12 + fake_line.Point1.X;
                  fake_line.Point2.Y = dy_1 / iVar12 + fake_line.Point1.Y;
                  if ((fake_line.Point2.X == (line_01->Point2).X) &&
                     (fake_line.Point2.Y == (line_01->Point2).Y)) break;
                  iVar22 = iVar22 + 1;
                  AddLine(layergroupboxes,CVar10,&fake_line,line_01,local_7c->styles[4]);
                  fake_line.Point1.X = fake_line.Point2.X;
                  fake_line.Point1.Y = fake_line.Point2.Y;
                  fake_line.Point1.X2 = fake_line.Point2.X2;
                  fake_line.Point1.Y2 = fake_line.Point2.Y2;
                  fake_line.Point1.ID = fake_line.Point2.ID;
                } while (iVar22 < iVar12 + -1);
              }
            }
            fake_line.Point2.X = (line_01->Point2).X;
            fake_line.Point2.Y = (line_01->Point2).Y;
            fake_line.Point2.X2 = (line_01->Point2).X2;
            fake_line.Point2.Y2 = (line_01->Point2).Y2;
            fake_line.Point2.ID = (line_01->Point2).ID;
            AddLine(layergroupboxes,CVar10,&fake_line,line_01,local_7c->styles[4]);
            pPVar8 = PCB;
          }
        }
        else {
          (line_01->Flags).f = uVar9 & 0xffffefff;
        }
        local_1a4 = local_1a4 + -1;
        if (local_1a4 == -1) goto LAB_08074c8e;
        paVar18 = pPVar8->Data;
        iVar22 = (int)local_1a8;
      } while( true );
    }
    goto LAB_08074c94;
  }
LAB_08074e8d:
  if (AutoRouteParameters.use_vias == '\0') {
    iVar22 = pPVar8->Data->LayerN;
LAB_08074ea3:
    if (0 < iVar22) {
      iVar22 = 0;
      pPVar36 = layergroupboxes;
      do {
        iVar22 = iVar22 + 1;
        FreePointerListMemory(pPVar36);
        pPVar36 = pPVar36 + 1;
        pPVar8 = PCB;
      } while (iVar22 < PCB->Data->LayerN);
    }
  }
  else {
    pmVar21 = mtspace_create();
    pPVar8 = PCB;
    local_7c->mtspace = pmVar21;
    if (0 < pPVar8->Data->LayerN) {
      pPVar36 = layergroupboxes;
      local_190 = 0;
      do {
        iVar22 = pPVar36->PtrN - 1;
        if (iVar22 != -1) {
          iVar12 = pPVar36->PtrN * 4 + -4;
          do {
            while (box = *(BoxType **)((int)pPVar36->Ptr + iVar12),
                  (*(byte *)((int)&box[2].Y2 + 1) & 0x10) == 0) {
              iVar22 = iVar22 + -1;
              iVar12 = iVar12 + -4;
              mtspace_add(local_7c->mtspace,box,FIXED,*(BDimension *)(box[4].Y2 + 0xc));
              pPVar8 = PCB;
              if (iVar22 == -1) goto LAB_080753d6;
            }
            iVar22 = iVar22 + -1;
            iVar12 = iVar12 + -4;
            pPVar8 = PCB;
          } while (iVar22 != -1);
        }
LAB_080753d6:
        pPVar36 = pPVar36 + 1;
        local_190 = local_190 + 1;
        iVar22 = pPVar8->Data->LayerN;
      } while (local_190 < iVar22);
      goto LAB_08074ea3;
    }
  }
  paVar18 = pPVar8->Data;
  local_190 = paVar18->RatN - 1;
  if (local_190 == -1) {
LAB_080750a3:
    BVar7 = '\0';
  }
  else {
    iVar12 = 0;
    paVar32 = paVar18->Rat + (paVar18->RatN - 1);
    pFVar29 = &paVar32->Flags;
    iVar22 = local_190;
    do {
      if ((selected == '\0') || ((*(byte *)&pFVar29->f & 0x40) != 0)) {
        iVar12 = iVar12 + 1;
      }
      iVar22 = iVar22 + -1;
      pFVar29 = (FlagType *)((int)(pFVar29 + -8) + 4);
    } while (iVar22 != -1);
    if (iVar12 == 0) goto LAB_080750a3;
    if (iVar12 == 1) {
      iVar22 = local_190;
      if (selected != '\0') {
        do {
          if (((paVar32->Flags).f & 0x40) != 0) goto LAB_08075214;
          iVar22 = iVar22 + -1;
          paVar32 = paVar32 + -1;
        } while (iVar22 != -1);
        goto LAB_08074f29;
      }
LAB_08075214:
      prVar34 = FindRouteBoxOnLayerGroup
                          (local_7c,(paVar32->Point1).X,(paVar32->Point1).Y,paVar32->group1);
      prVar19 = FindRouteBoxOnLayerGroup
                          (local_7c,(paVar32->Point2).X,(paVar32->Point2).Y,paVar32->group2);
      InitAutoRouteParameters(0,prVar34->style,'\0','\x01','\x01');
      RouteOne(local_7c,prVar34,prVar19,150000);
      BVar7 = local_9c != '\0';
    }
    else {
LAB_08074f29:
      if (local_7c->first_net == (routebox_t *)0x0) {
LAB_0807500a:
        iVar22 = local_190 * 0x5c;
        while( true ) {
          paVar32 = paVar18->Rat;
          if ((selected == '\0') || (((paVar32->Flags).t[iVar22 + -4] & 0x40) != 0)) {
            prVar34 = FindRouteBoxOnLayerGroup
                                (local_7c,*(LocationType *)
                                           ((int)&((PointType *)(&paVar32->Flags + 2))->Y +
                                           iVar22 + -4),
                                 *(LocationType *)
                                  ((int)&((PointType *)(&paVar32->Flags + 2))->Y + iVar22),
                                 *(Cardinal *)((int)(&paVar32->Flags + 5) + iVar22 + 4));
            prVar19 = FindRouteBoxOnLayerGroup
                                (local_7c,*(LocationType *)((int)(&paVar32->Flags + 3) + iVar22 + 8)
                                 ,*(LocationType *)((int)(&paVar32->Flags + 4) + iVar22),
                                 *(Cardinal *)((int)(&paVar32->Flags + 5) + iVar22 + 8));
            if ((prVar19 == (routebox_t *)0x0) || (prVar34 == (routebox_t *)0x0)) {
              Message("The rats nest is stale! Aborting autoroute...\n");
              goto LAB_080750a3;
            }
            MergeNets(prVar34,prVar19,NET);
          }
          local_190 = local_190 + -1;
          iVar22 = iVar22 + -0x5c;
          if (local_190 == -1) break;
          paVar18 = PCB->Data;
        }
      }
      else {
        prVar37 = (routebox *)0x0;
        prVar34 = local_7c->first_net;
        do {
          prVar4 = (prVar34->different_net).next;
          prVar30 = prVar34;
          do {
            prVar30 = (prVar30->same_net).next;
            prVar17 = prVar30;
            prVar38 = prVar37;
          } while (prVar30 != prVar34);
          do {
            prVar5 = (prVar17->same_net).next;
            prVar16 = prVar17;
            prVar37 = prVar38;
            if (((prVar17->flags).field_0x1 & 2) == 0) {
              do {
                prVar37 = (prVar16->same_subnet).next;
                puVar2 = &(prVar16->flags).field_0x1;
                *puVar2 = *puVar2 | 2;
                prVar16 = prVar37;
              } while (prVar37 != prVar17);
              prVar37 = prVar17;
              if (prVar38 != (routebox *)0x0) {
                (prVar38->different_net).next = prVar17;
                (prVar17->different_net).prev = prVar38;
              }
            }
            prVar17 = prVar5;
            prVar38 = prVar37;
          } while (prVar30 != prVar5);
          do {
            prVar30 = (prVar17->same_net).next;
            puVar2 = &(prVar17->flags).field_0x1;
            *puVar2 = *puVar2 & 0xfd;
            prVar17 = prVar30;
          } while (prVar5 != prVar30);
          do {
            prVar38 = (prVar17->same_net).next;
            prVar5 = (prVar17->same_subnet).prev;
            (prVar17->same_net).next = (prVar17->same_subnet).next;
            (prVar17->same_net).prev = prVar5;
            prVar17 = prVar38;
          } while (prVar30 != prVar38);
          prVar34 = prVar4;
        } while (prVar4 != local_7c->first_net);
        if (prVar37 != (routebox *)0x0) {
          (prVar37->different_net).next = prVar4;
          (local_7c->first_net->different_net).prev = prVar37;
        }
        paVar18 = PCB->Data;
        local_190 = paVar18->RatN - 1;
        if (local_190 != -1) goto LAB_0807500a;
      }
      prVar34 = local_7c->first_net;
      if (local_7c->first_net != (routebox_t *)0x0) {
        do {
          __next_one___8 = (prVar34->different_net).next;
          prVar19 = prVar34;
          if (((prVar34->flags).field_0x1 & 1) == 0) {
            do {
              prVar6 = (prVar19->same_net).next;
              puVar2 = &(prVar19->flags).field_0x1;
              *puVar2 = *puVar2 | 1;
              prVar19 = prVar6;
            } while (prVar6 != prVar34);
          }
          else {
            RemoveFromNet(prVar34,DIFFERENT_NET);
          }
          prVar34 = __next_one___8;
        } while (__next_one___8 != local_7c->first_net);
        if (__next_one___8 != (routebox_t *)0x0) {
          do {
            prVar34 = (__next_one___8->different_net).next;
            prVar19 = __next_one___8;
            do {
              prVar37 = (prVar19->same_net).next;
              puVar2 = &(prVar19->flags).field_0x1;
              *puVar2 = *puVar2 & 0xfe;
              prVar19 = prVar37;
            } while (prVar37 != __next_one___8);
            __next_one___8 = prVar34;
          } while (prVar34 != local_7c->first_net);
        }
      }
      RouteAll(local_7c);
      BVar7 = 0 < local_a0;
    }
    if ((bool)BVar7 != false) {
      BVar7 = IronDownAllUnfixedPaths(local_7c);
    }
  }
  Message("Total added wire length = %f inches, %d vias added\n",
          (double)(total_wire_length / 100000.0),total_via_count);
  DestroyRouteData(&local_7c);
  if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
    (*gui->use_mask)(5);
  }
  if (BVar7 != '\0') {
    SaveUndoSerialNumber();
    DeleteRats('\0');
    RestoreUndoSerialNumber();
    AddAllRats('\0',(_func_void_varargs *)0x0);
    RestoreUndoSerialNumber();
    IncrementUndoSerialNumber();
    ClearAndRedrawOutput();
  }
  RestoreFindFlag();
LAB_08073ebd:
  if (local_20 == *(char **)(in_GS_OFFSET + 0x14)) {
    return BVar7;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_08074c8e:
  paVar18 = pPVar8->Data;
LAB_08074c94:
  CVar14 = paVar18->Layer[local_1b0].PolygonN;
  iVar22 = CVar14 - 1;
  if (iVar22 != -1) {
    iVar12 = CVar14 * 0x3c;
    while( true ) {
      polygon_00 = (PolygonTypePtr)(paVar18->Layer[local_1b0].Polygon[-1].Flags.t + iVar12 + -0x18);
      uVar9 = (polygon_00->Flags).f;
      if ((uVar9 & 0x1000) == 0) {
        AddPolygon(layergroupboxes,local_1b0,polygon_00,local_7c->styles[4]);
        pPVar8 = PCB;
      }
      else {
        (polygon_00->Flags).f = uVar9 & 0xffffefff;
      }
      if (iVar22 == 0) break;
      iVar22 = iVar22 + -1;
      paVar18 = pPVar8->Data;
      iVar12 = iVar12 + -0x3c;
    }
    paVar18 = pPVar8->Data;
  }
  CVar14 = paVar18->Layer[local_1b0].TextN;
  iVar22 = CVar14 - 1;
  if (iVar22 != -1) {
    iVar12 = CVar14 * 0x3c;
    while( true ) {
      iVar22 = iVar22 + -1;
      puVar3 = paVar18->Layer[local_1b0].Text[-1].Flags.t + iVar12 + -0x18;
      AddIrregularObstacle
                (layergroupboxes,*(LocationType *)puVar3,*(LocationType *)(puVar3 + 4),
                 *(LocationType *)(puVar3 + 8),*(LocationType *)(puVar3 + 0xc),CVar10,puVar3,
                 local_7c->styles[4]);
      if (iVar22 == -1) break;
      paVar18 = PCB->Data;
      iVar12 = iVar12 + -0x3c;
    }
    paVar18 = PCB->Data;
    pPVar8 = PCB;
  }
  CVar14 = paVar18->Layer[local_1b0].ArcN;
  iVar22 = CVar14 - 1;
  if (iVar22 != -1) {
    iVar12 = CVar14 * 0x44;
    while( true ) {
      iVar22 = iVar22 + -1;
      puVar3 = paVar18->Layer[local_1b0].Arc[-1].Flags.t + iVar12 + -0x18;
      AddIrregularObstacle
                (layergroupboxes,*(LocationType *)puVar3,*(LocationType *)(puVar3 + 4),
                 *(LocationType *)(puVar3 + 8),*(LocationType *)(puVar3 + 0xc),CVar10,puVar3,
                 local_7c->styles[4]);
      if (iVar22 == -1) break;
      paVar18 = PCB->Data;
      iVar12 = iVar12 + -0x44;
    }
    paVar18 = PCB->Data;
    pPVar8 = PCB;
  }
  local_1b0 = local_1b0 + 1;
  if (paVar18->LayerN <= (int)local_1b0) goto code_r0x08074e47;
  goto LAB_08074a72;
code_r0x08074e47:
  if (0 < paVar18->LayerN) {
    pPVar36 = layergroupboxes;
    iVar22 = 0;
    do {
      pCVar33 = &pPVar36->PtrN;
      pppvVar1 = &pPVar36->Ptr;
      pPVar36 = pPVar36 + 1;
      prVar15 = r_create_tree((BoxType **)*pppvVar1,*pCVar33,1);
      local_7c->layergrouptree[iVar22] = prVar15;
      iVar22 = iVar22 + 1;
      pPVar8 = PCB;
    } while (iVar22 < PCB->Data->LayerN);
  }
  goto LAB_08074e8d;
}



// WARNING: Unknown calling convention

void register_rotate_action_list(void)

{
  hid_register_actions(rotate_action_list,1);
  return;
}



// WARNING: Unknown calling convention

void * CopyObjectToBuffer(DataTypePtr Destination,DataTypePtr Src,int Type,void *Ptr1,void *Ptr2,
                         void *Ptr3)

{
  void *pvVar1;
  
  Dest = Destination;
  Source = Src;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&AddBufferFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * MoveObjectToBuffer(DataTypePtr Destination,DataTypePtr Src,int Type,void *Ptr1,void *Ptr2,
                         void *Ptr3)

{
  void *pvVar1;
  
  Dest = Destination;
  Source = Src;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&MoveBufferFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * AddRatToBuffer(RatTypePtr Rat)

{
  int iVar1;
  FlagType Flags;
  RatTypePtr paVar2;
  int in_GS_OFFSET;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags(Rat->Flags,ExtraFlag | 4);
  Flags.t._0_4_ = local_18;
  Flags.f = local_1c;
  Flags.t._4_4_ = local_14;
  paVar2 = CreateNewRat(Dest,(Rat->Point1).X,(Rat->Point1).Y,(Rat->Point2).X,(Rat->Point2).Y,
                        Rat->group1,Rat->group2,Rat->Thickness,Flags);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return paVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * AddArcToBuffer(LayerTypePtr Layer,ArcTypePtr Arc)

{
  int iVar1;
  FlagType Flags;
  DataTypePtr paVar2;
  int iVar3;
  ArcTypePtr paVar4;
  int in_GS_OFFSET;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  paVar2 = Dest;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = GetLayerNumber(Source,Layer);
  MaskFlags(Arc->Flags,ExtraFlag | 4);
  Flags.t._0_4_ = local_28;
  Flags.f = local_2c;
  Flags.t._4_4_ = local_24;
  paVar4 = CreateNewArcOnLayer(paVar2->Layer + iVar3,Arc->X,Arc->Y,Arc->Width,Arc->Height,
                               Arc->StartAngle,Arc->Delta,Arc->Thickness,Arc->Clearance,Flags);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return paVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * AddElementToBuffer(ElementTypePtr Element)

{
  FlagType *pFVar1;
  int iVar2;
  ElementTypePtr Dest;
  uint uVar3;
  PinTypePtr paVar4;
  PadTypePtr paVar5;
  Cardinal n_1;
  Cardinal n;
  uint uVar6;
  ElementTypePtr element;
  Cardinal sn_1;
  Cardinal sn;
  
  Dest = GetElementMemory(::Dest);
  CopyElementLowLevel(::Dest,Dest,Element,'\0',0,0);
  iVar2 = ExtraFlag;
  uVar3 = ~ExtraFlag;
  (Dest->Flags).f = (Dest->Flags).f & uVar3;
  if (iVar2 != 0) {
    uVar6 = Dest->PinN;
    pFVar1 = &Dest->Name[2].Flags;
    pFVar1->f = pFVar1->f & uVar3;
    pFVar1 = &Dest->Name[1].Flags;
    pFVar1->f = pFVar1->f & uVar3;
    pFVar1 = &Dest->Name[0].Flags;
    pFVar1->f = pFVar1->f & uVar3;
    if (uVar6 != 0) {
      paVar4 = Dest->Pin;
      pFVar1 = &paVar4->Flags;
      pFVar1->f = pFVar1->f & ~(iVar2 | 4U);
      for (uVar3 = 1; uVar3 < uVar6; uVar3 = uVar3 + 1) {
        paVar4[1].Flags.f = paVar4[1].Flags.f & ~(iVar2 | 4U);
        paVar4 = paVar4 + 1;
      }
    }
    uVar3 = Dest->PadN;
    if (uVar3 != 0) {
      paVar5 = Dest->Pad;
      pFVar1 = &paVar5->Flags;
      pFVar1->f = pFVar1->f & ~(iVar2 | 4U);
      for (uVar6 = 1; uVar6 < uVar3; uVar6 = uVar6 + 1) {
        paVar5[1].Flags.f = paVar5[1].Flags.f & ~(iVar2 | 4U);
        paVar5 = paVar5 + 1;
      }
    }
  }
  return Dest;
}



// WARNING: Unknown calling convention

void * AddViaToBuffer(PinTypePtr Via)

{
  int iVar1;
  FlagType Flags;
  PinTypePtr paVar2;
  int in_GS_OFFSET;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags(Via->Flags,ExtraFlag | 4);
  Flags.t._0_4_ = local_18;
  Flags.f = local_1c;
  Flags.t._4_4_ = local_14;
  paVar2 = CreateNewVia(Dest,Via->X,Via->Y,Via->Thickness,Via->Clearance,Via->Mask,Via->DrillingHole
                        ,Via->Name,Flags);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return paVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * AddPolygonToBuffer(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  DataTypePtr paVar1;
  int iVar2;
  PolygonTypePtr Dest;
  PolygonTypePtr polygon;
  
  paVar1 = ::Dest;
  iVar2 = GetLayerNumber(Source,Layer);
  Dest = GetPolygonMemory(paVar1->Layer + iVar2);
  CopyPolygonLowLevel(Dest,Polygon);
  (Dest->Flags).f = (Dest->Flags).f & ~(ExtraFlag | 4U);
  return Dest;
}



// WARNING: Unknown calling convention

void * AddTextToBuffer(LayerTypePtr Layer,TextTypePtr Text)

{
  int iVar1;
  FlagType Flags;
  DataTypePtr paVar2;
  int iVar3;
  TextTypePtr pTVar4;
  int in_GS_OFFSET;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  paVar2 = Dest;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = GetLayerNumber(Source,Layer);
  MaskFlags(Text->Flags,ExtraFlag);
  Flags.t._0_4_ = local_28;
  Flags.f = local_2c;
  Flags.t._4_4_ = local_24;
  pTVar4 = CreateNewText(paVar2->Layer + iVar3,&PCB->Font,Text->X,Text->Y,Text->Direction,
                         Text->Scale,Text->TextString,Flags);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pTVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * AddLineToBuffer(LayerTypePtr Layer,LineTypePtr Line)

{
  int iVar1;
  FlagType Flags;
  DataTypePtr paVar2;
  int iVar3;
  LineTypePtr pLVar4;
  LineTypePtr line;
  char *pcVar5;
  int in_GS_OFFSET;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  paVar2 = Dest;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = GetLayerNumber(Source,Layer);
  MaskFlags(Line->Flags,ExtraFlag | 4);
  Flags.t._0_4_ = local_28;
  Flags.f = local_2c;
  Flags.t._4_4_ = local_24;
  pLVar4 = CreateNewLineOnLayer
                     (paVar2->Layer + iVar3,(Line->Point1).X,(Line->Point1).Y,(Line->Point2).X,
                      (Line->Point2).Y,Line->Thickness,Line->Clearance,Flags);
  if ((pLVar4 != (LineTypePtr)0x0) && (Line->Number != (char *)0x0)) {
    pcVar5 = MyStrdup(Line->Number,"AddLineToBuffer");
    pLVar4->Number = pcVar5;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pLVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * MoveRatToBuffer(RatTypePtr Rat)

{
  RatTypePtr *ppaVar1;
  RatTypePtr which;
  RatTypePtr rat;
  DataTypePtr paVar2;
  rtree_t *prVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  RatTypePtr paVar7;
  Cardinal CVar8;
  RatTypePtr paVar9;
  undefined4 *puVar10;
  bool bVar11;
  byte bVar12;
  
  bVar12 = 0;
  r_delete_entry(Source->rat_tree,&Rat->BoundingBox);
  which = GetRatMemory(Dest);
  paVar7 = Rat;
  paVar9 = which;
  for (iVar4 = 0x17; iVar4 != 0; iVar4 = iVar4 + -1) {
    (paVar9->BoundingBox).X1 = (paVar7->BoundingBox).X1;
    paVar7 = (RatTypePtr)((int)paVar7 + (uint)bVar12 * -8 + 4);
    paVar9 = (RatTypePtr)((int)paVar9 + (uint)bVar12 * -8 + 4);
  }
  (which->Flags).f = (which->Flags).f & 0xfffffffb;
  paVar2 = Source;
  ppaVar1 = &Source->Rat;
  CVar8 = Source->RatN - 1;
  Source->RatN = CVar8;
  if (*ppaVar1 + CVar8 != Rat) {
    paVar7 = *ppaVar1 + CVar8;
    paVar9 = Rat;
    for (iVar4 = 0x17; iVar4 != 0; iVar4 = iVar4 + -1) {
      (paVar9->BoundingBox).X1 = (paVar7->BoundingBox).X1;
      paVar7 = (RatTypePtr)((int)paVar7 + (uint)bVar12 * -8 + 4);
      paVar9 = (RatTypePtr)((int)paVar9 + (uint)bVar12 * -8 + 4);
    }
    r_substitute(paVar2->rat_tree,&paVar2->Rat[paVar2->RatN].BoundingBox,&Rat->BoundingBox);
    CVar8 = Source->RatN;
    paVar2 = Source;
  }
  puVar10 = (undefined4 *)((int)&paVar2->Rat->Flags + CVar8 * 0x5c + -0x14);
  uVar6 = 0x5c;
  bVar11 = ((uint)puVar10 & 1) != 0;
  if (bVar11) {
    *(undefined *)puVar10 = 0;
    puVar10 = (undefined4 *)((int)puVar10 + 1);
    uVar6 = 0x5b;
  }
  if (((uint)puVar10 & 2) != 0) {
    *(undefined2 *)puVar10 = 0;
    uVar6 = uVar6 - 2;
    puVar10 = (undefined4 *)((int)puVar10 + 2);
  }
  for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
    *puVar10 = 0;
    puVar10 = puVar10 + (uint)bVar12 * -2 + 1;
  }
  if ((uVar6 & 2) != 0) {
    *(undefined2 *)puVar10 = 0;
    puVar10 = (undefined4 *)((int)puVar10 + 2);
  }
  if (bVar11) {
    *(undefined *)puVar10 = 0;
  }
  paVar2 = Dest;
  prVar3 = Dest->rat_tree;
  if (prVar3 == (rtree_t *)0x0) {
    prVar3 = r_create_tree((BoxType **)0x0,0,0);
    paVar2->rat_tree = prVar3;
    prVar3 = Dest->rat_tree;
  }
  r_insert_entry(prVar3,&which->BoundingBox,0);
  return which;
}



// WARNING: Unknown calling convention

void * MovePolygonToBuffer(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PointTypePtr pPVar1;
  PolygonTypePtr ppVar2;
  DataTypePtr paVar3;
  int iVar4;
  PolygonTypePtr which;
  Cardinal CVar5;
  rtree_t *rtree;
  uint uVar6;
  uint uVar7;
  PolygonTypePtr polygon;
  uchar *puVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  r_delete_entry(Layer->polygon_tree,&Polygon->BoundingBox);
  paVar3 = Dest;
  iVar4 = GetLayerNumber(Source,Layer);
  which = GetPolygonMemory(paVar3->Layer + iVar4);
  (which->BoundingBox).X1 = (Polygon->BoundingBox).X1;
  (which->BoundingBox).Y1 = (Polygon->BoundingBox).Y1;
  (which->BoundingBox).X2 = (Polygon->BoundingBox).X2;
  (which->BoundingBox).Y2 = (Polygon->BoundingBox).Y2;
  which->ID = Polygon->ID;
  (which->Flags).f = (Polygon->Flags).f;
  *(undefined4 *)(which->Flags).t = *(undefined4 *)(Polygon->Flags).t;
  *(undefined4 *)((which->Flags).t + 4) = *(undefined4 *)((Polygon->Flags).t + 4);
  which->net = Polygon->net;
  which->PointN = Polygon->PointN;
  which->PointMax = Polygon->PointMax;
  which->Clipped = Polygon->Clipped;
  which->NoHoles = Polygon->NoHoles;
  which->NoHolesValid = Polygon->NoHolesValid;
  pPVar1 = Polygon->Points;
  (which->Flags).f = (which->Flags).f & 0xfffffffb;
  which->Points = pPVar1;
  ppVar2 = Layer->Polygon;
  CVar5 = Layer->PolygonN - 1;
  Layer->PolygonN = CVar5;
  if (ppVar2 + CVar5 != Polygon) {
    (Polygon->BoundingBox).X1 = ppVar2[CVar5].BoundingBox.X1;
    (Polygon->BoundingBox).Y1 = ppVar2[CVar5].BoundingBox.Y1;
    (Polygon->BoundingBox).X2 = ppVar2[CVar5].BoundingBox.X2;
    (Polygon->BoundingBox).Y2 = ppVar2[CVar5].BoundingBox.Y2;
    Polygon->ID = ppVar2[CVar5].ID;
    (Polygon->Flags).f = ppVar2[CVar5].Flags.f;
    *(undefined4 *)(Polygon->Flags).t = *(undefined4 *)ppVar2[CVar5].Flags.t;
    *(undefined4 *)((Polygon->Flags).t + 4) = *(undefined4 *)(ppVar2[CVar5].Flags.t + 4);
    Polygon->net = ppVar2[CVar5].net;
    Polygon->PointN = ppVar2[CVar5].PointN;
    Polygon->PointMax = ppVar2[CVar5].PointMax;
    Polygon->Clipped = ppVar2[CVar5].Clipped;
    Polygon->NoHoles = ppVar2[CVar5].NoHoles;
    Polygon->NoHolesValid = ppVar2[CVar5].NoHolesValid;
    Polygon->Points = ppVar2[CVar5].Points;
    r_substitute(Layer->polygon_tree,&Layer->Polygon[Layer->PolygonN].BoundingBox,
                 &Polygon->BoundingBox);
    CVar5 = Layer->PolygonN;
  }
  puVar8 = (&Layer->Polygon->Flags)[CVar5 * 5 + -2].t;
  uVar7 = 0x3c;
  bVar9 = ((uint)puVar8 & 1) != 0;
  if (bVar9) {
    uVar7 = 0x3b;
    *puVar8 = '\0';
    puVar8 = puVar8 + 1;
  }
  if (((uint)puVar8 & 2) != 0) {
    *(undefined2 *)puVar8 = 0;
    uVar7 = uVar7 - 2;
    puVar8 = puVar8 + 2;
  }
  for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
    *(undefined4 *)puVar8 = 0;
    puVar8 = puVar8 + ((uint)bVar10 * -2 + 1) * 4;
  }
  if ((uVar7 & 2) != 0) {
    *(undefined2 *)puVar8 = 0;
    puVar8 = puVar8 + 2;
  }
  if (bVar9) {
    *puVar8 = '\0';
  }
  rtree = paVar3->Layer[iVar4].polygon_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    paVar3->Layer[iVar4].polygon_tree = rtree;
  }
  r_insert_entry(rtree,&which->BoundingBox,0);
  return which;
}



// WARNING: Unknown calling convention

void * MoveArcToBuffer(LayerTypePtr Layer,ArcTypePtr Arc)

{
  DataTypePtr paVar1;
  int iVar2;
  ArcTypePtr which;
  Cardinal CVar3;
  rtree_t *rtree;
  int iVar4;
  uint uVar5;
  uint uVar6;
  ArcTypePtr paVar7;
  ArcTypePtr arc;
  ArcTypePtr paVar8;
  undefined4 *puVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  RestoreToPolygon((DataType *)Source,0x4000,Layer,Arc);
  r_delete_entry(Layer->arc_tree,&Arc->BoundingBox);
  paVar1 = Dest;
  iVar2 = GetLayerNumber(Source,Layer);
  which = GetArcMemory(paVar1->Layer + iVar2);
  paVar7 = Arc;
  arc = which;
  for (iVar4 = 0x11; iVar4 != 0; iVar4 = iVar4 + -1) {
    arc = (ArcTypePtr)((int)arc + (uint)bVar11 * -8 + 4);
    (arc->BoundingBox).X1 = (paVar7->BoundingBox).X1;
    paVar7 = (ArcTypePtr)((int)paVar7 + (uint)bVar11 * -8 + 4);
    arc = arc;
  }
  (which->Flags).f = (which->Flags).f & 0xfffffffb;
  CVar3 = Layer->ArcN - 1;
  Layer->ArcN = CVar3;
  if (Layer->Arc + CVar3 != Arc) {
    paVar7 = Layer->Arc + CVar3;
    paVar8 = Arc;
    for (iVar4 = 0x11; iVar4 != 0; iVar4 = iVar4 + -1) {
      (paVar8->BoundingBox).X1 = (paVar7->BoundingBox).X1;
      paVar7 = (ArcTypePtr)((int)paVar7 + (uint)bVar11 * -8 + 4);
      paVar8 = (ArcTypePtr)((int)paVar8 + (uint)bVar11 * -8 + 4);
    }
    r_substitute(Layer->arc_tree,&Layer->Arc[Layer->ArcN].BoundingBox,&Arc->BoundingBox);
    CVar3 = Layer->ArcN;
  }
  puVar9 = (undefined4 *)((int)&Layer->Arc->Flags + CVar3 * 0x44 + -0x14);
  uVar6 = 0x44;
  bVar10 = ((uint)puVar9 & 1) != 0;
  if (bVar10) {
    *(undefined *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 1);
    uVar6 = 0x43;
  }
  if (((uint)puVar9 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    uVar6 = uVar6 - 2;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
    *puVar9 = 0;
    puVar9 = puVar9 + (uint)bVar11 * -2 + 1;
  }
  if ((uVar6 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  if (bVar10) {
    *(undefined *)puVar9 = 0;
  }
  rtree = paVar1->Layer[iVar2].arc_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    paVar1->Layer[iVar2].arc_tree = rtree;
  }
  r_insert_entry(rtree,&which->BoundingBox,0);
  ClearFromPolygon((DataType *)Dest,0x4000,paVar1->Layer + iVar2,which);
  return which;
}



// WARNING: Unknown calling convention

void * MoveElementToBuffer(ElementTypePtr Element)

{
  ElementTypePtr *ppaVar1;
  rtree_t **pprVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  PCBTypePtr pPVar6;
  ElementTypePtr Element_00;
  ElementTypePtr element;
  Cardinal sn;
  Cardinal sn_1;
  Cardinal sn_3;
  Cardinal CVar7;
  Cardinal n_4;
  Cardinal n_5;
  DataTypePtr paVar8;
  int iVar9;
  Cardinal sn_4;
  PinTypePtr pin;
  PinTypePtr paVar10;
  PadTypePtr pad;
  uint uVar11;
  Cardinal n_2;
  Cardinal n_3;
  ElementTypePtr paVar12;
  int i;
  Cardinal sn_5;
  uint uVar13;
  Cardinal n;
  Cardinal n_1;
  Cardinal sn_2;
  Cardinal CVar14;
  ElementTypePtr paVar15;
  int iVar16;
  uchar *puVar17;
  bool bVar18;
  byte bVar19;
  uint local_20;
  
  bVar19 = 0;
  r_delete_element((DataType *)Source,(ElementType *)Element);
  Element_00 = GetElementMemory(Dest);
  paVar12 = Element;
  paVar15 = Element_00;
  for (iVar9 = 0x4b; iVar9 != 0; iVar9 = iVar9 + -1) {
    (paVar15->BoundingBox).X1 = (paVar12->BoundingBox).X1;
    paVar12 = (ElementTypePtr)((int)paVar12 + (uint)bVar19 * -8 + 4);
    paVar15 = (ElementTypePtr)((int)paVar15 + (uint)bVar19 * -8 + 4);
  }
  if (Element_00->PinN != 0) {
    uVar13 = 0;
    local_20 = Element_00->PinN;
    do {
      paVar10 = Element_00->Pin + uVar13;
      RestoreToPolygon((DataType *)Source,0x100,Element,paVar10);
      uVar11 = Element_00->PinN;
      (paVar10->Flags).f = (paVar10->Flags).f & 0xfffffdfb;
      paVar10->Element = Element_00;
      if (uVar11 == 0) break;
      uVar13 = (uVar11 + 1 + uVar13) - local_20;
      local_20 = uVar11;
    } while (uVar13 < uVar11);
  }
  CVar14 = Element_00->PadN;
  uVar13 = 0;
  local_20 = 0;
  CVar7 = CVar14;
  while ((pPVar6 = PCB, CVar7 != 0 && (uVar13 < CVar7))) {
    puVar17 = (Element_00->Pad->Flags).t + local_20 + -0x18;
    RestoreToPolygon((DataType *)Source,0x200,Element,puVar17);
    CVar7 = Element_00->PadN;
    *(uint *)(puVar17 + 0x14) = *(uint *)(puVar17 + 0x14) & 0xfffffdfb;
    *(ElementTypePtr *)(puVar17 + 0x60) = Element_00;
    if (CVar7 == CVar14) {
      uVar13 = uVar13 + 1;
      local_20 = local_20 + 0x68;
      CVar7 = CVar14;
    }
  }
  uVar11 = 0;
  Element_00->Name[2].Element = Element_00;
  Element_00->Name[1].Element = Element_00;
  Element_00->Name[0].Element = Element_00;
  SetElementBoundingBox(Dest,Element_00,&pPVar6->Font);
  uVar13 = Element_00->PinN;
  if (Element_00->PinN != 0) {
    do {
      ClearFromPolygon((DataType *)Dest,0x100,Element_00,Element_00->Pin + uVar11);
      uVar3 = Element_00->PinN;
      if (uVar3 == 0) break;
      uVar11 = (uVar3 + 1 + uVar11) - uVar13;
      uVar13 = uVar3;
    } while (uVar11 < uVar3);
  }
  CVar14 = Element_00->PadN;
  iVar9 = 0;
  uVar13 = 0;
  CVar7 = CVar14;
  while ((paVar8 = Source, CVar7 != 0 && (uVar13 < CVar7))) {
    ClearFromPolygon((DataType *)Dest,0x200,Element_00,(Element_00->Pad->Flags).t + iVar9 + -0x18);
    CVar7 = Element_00->PadN;
    if (Element_00->PadN == CVar14) {
      uVar13 = uVar13 + 1;
      iVar9 = iVar9 + 0x68;
      CVar7 = CVar14;
    }
  }
  ppaVar1 = &Source->Element;
  CVar14 = Source->ElementN - 1;
  Source->ElementN = CVar14;
  if (*ppaVar1 + CVar14 != Element) {
    paVar12 = *ppaVar1 + CVar14;
    paVar15 = Element;
    for (iVar9 = 0x4b; iVar9 != 0; iVar9 = iVar9 + -1) {
      (paVar15->BoundingBox).X1 = (paVar12->BoundingBox).X1;
      paVar12 = (ElementTypePtr)((int)paVar12 + (uint)bVar19 * -8 + 4);
      paVar15 = (ElementTypePtr)((int)paVar15 + (uint)bVar19 * -8 + 4);
    }
    iVar16 = 0;
    iVar9 = 0;
    r_substitute(paVar8->element_tree,&paVar8->Element[paVar8->ElementN].BoundingBox,
                 &Element->BoundingBox);
    do {
      iVar4 = iVar16 + -0x18;
      iVar5 = iVar16 + -0x18;
      iVar16 = iVar16 + 0x3c;
      pprVar2 = Source->name_tree + iVar9;
      iVar9 = iVar9 + 1;
      r_substitute(*pprVar2,(BoxType *)(Source->Element[Source->ElementN].Name[0].Flags.t + iVar5),
                   (BoxType *)(Element->Name[0].Flags.t + iVar4));
    } while (iVar9 != 3);
    uVar13 = Element->PinN;
    Element->Name[2].Element = Element;
    Element->Name[1].Element = Element;
    Element->Name[0].Element = Element;
    if (uVar13 != 0) {
      paVar10 = Element->Pin;
      paVar10->Element = Element;
      uVar11 = 0;
      while (uVar11 = uVar11 + 1, uVar11 < uVar13) {
        paVar10[uVar11].Element = Element;
      }
    }
    uVar13 = Element->PadN;
    iVar9 = 0;
    for (uVar11 = 0; (uVar13 != 0 && (uVar11 < uVar13)); uVar11 = uVar11 + 1) {
      *(ElementTypePtr *)((int)(&Element->Pad->Flags + 6) + iVar9 + 4) = Element;
      iVar9 = iVar9 + 0x68;
    }
    CVar14 = Source->ElementN;
    paVar8 = Source;
  }
  puVar17 = (&paVar8->Element->Flags)[CVar14 * 0x19 + -2].t;
  uVar13 = 300;
  bVar18 = ((uint)puVar17 & 1) != 0;
  if (bVar18) {
    *puVar17 = '\0';
    uVar13 = 299;
    puVar17 = puVar17 + 1;
  }
  if (((uint)puVar17 & 2) != 0) {
    *(undefined2 *)puVar17 = 0;
    uVar13 = uVar13 - 2;
    puVar17 = puVar17 + 2;
  }
  for (uVar11 = uVar13 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
    *(undefined4 *)puVar17 = 0;
    puVar17 = puVar17 + ((uint)bVar19 * -2 + 1) * 4;
  }
  if ((uVar13 & 2) != 0) {
    *(undefined2 *)puVar17 = 0;
    puVar17 = puVar17 + 2;
  }
  if (bVar18) {
    *puVar17 = '\0';
  }
  return Element_00;
}



// WARNING: Unknown calling convention

void * MoveViaToBuffer(PinTypePtr Via)

{
  PinTypePtr *ppaVar1;
  PinTypePtr which;
  PinTypePtr via;
  DataTypePtr paVar2;
  rtree_t *prVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  PinTypePtr paVar7;
  Cardinal CVar8;
  PinTypePtr paVar9;
  undefined4 *puVar10;
  bool bVar11;
  byte bVar12;
  
  bVar12 = 0;
  RestoreToPolygon((DataType *)Source,1,Via,Via);
  r_delete_entry(Source->via_tree,&Via->BoundingBox);
  which = GetViaMemory(Dest);
  paVar7 = Via;
  paVar9 = which;
  for (iVar4 = 0x13; iVar4 != 0; iVar4 = iVar4 + -1) {
    (paVar9->BoundingBox).X1 = (paVar7->BoundingBox).X1;
    paVar7 = (PinTypePtr)((int)paVar7 + (uint)bVar12 * -8 + 4);
    paVar9 = (PinTypePtr)((int)paVar9 + (uint)bVar12 * -8 + 4);
  }
  (which->Flags).f = (which->Flags).f & 0xfffffdfb;
  paVar2 = Source;
  ppaVar1 = &Source->Via;
  CVar8 = Source->ViaN - 1;
  Source->ViaN = CVar8;
  if (*ppaVar1 + CVar8 != Via) {
    paVar7 = *ppaVar1 + CVar8;
    paVar9 = Via;
    for (iVar4 = 0x13; iVar4 != 0; iVar4 = iVar4 + -1) {
      (paVar9->BoundingBox).X1 = (paVar7->BoundingBox).X1;
      paVar7 = (PinTypePtr)((int)paVar7 + (uint)bVar12 * -8 + 4);
      paVar9 = (PinTypePtr)((int)paVar9 + (uint)bVar12 * -8 + 4);
    }
    r_substitute(paVar2->via_tree,&paVar2->Via[paVar2->ViaN].BoundingBox,&Via->BoundingBox);
    CVar8 = Source->ViaN;
    paVar2 = Source;
  }
  puVar10 = (undefined4 *)((int)&paVar2->Via->Flags + CVar8 * 0x4c + -0x14);
  uVar6 = 0x4c;
  bVar11 = ((uint)puVar10 & 1) != 0;
  if (bVar11) {
    *(undefined *)puVar10 = 0;
    puVar10 = (undefined4 *)((int)puVar10 + 1);
    uVar6 = 0x4b;
  }
  if (((uint)puVar10 & 2) != 0) {
    *(undefined2 *)puVar10 = 0;
    uVar6 = uVar6 - 2;
    puVar10 = (undefined4 *)((int)puVar10 + 2);
  }
  for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
    *puVar10 = 0;
    puVar10 = puVar10 + (uint)bVar12 * -2 + 1;
  }
  if ((uVar6 & 2) != 0) {
    *(undefined2 *)puVar10 = 0;
    puVar10 = (undefined4 *)((int)puVar10 + 2);
  }
  if (bVar11) {
    *(undefined *)puVar10 = 0;
  }
  paVar2 = Dest;
  prVar3 = Dest->via_tree;
  if (prVar3 == (rtree_t *)0x0) {
    prVar3 = r_create_tree((BoxType **)0x0,0,0);
    paVar2->via_tree = prVar3;
    prVar3 = Dest->via_tree;
  }
  r_insert_entry(prVar3,&which->BoundingBox,0);
  ClearFromPolygon((DataType *)Dest,1,which,which);
  return which;
}



// WARNING: Unknown calling convention

void * MoveTextToBuffer(LayerTypePtr Layer,TextTypePtr Text)

{
  TextTypePtr pTVar1;
  undefined3 uVar2;
  DataTypePtr paVar3;
  int iVar4;
  TextTypePtr which;
  Cardinal CVar5;
  rtree_t *rtree;
  uint uVar6;
  uint uVar7;
  TextTypePtr text;
  uchar *puVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  r_delete_entry(Layer->text_tree,&Text->BoundingBox);
  RestoreToPolygon((DataType *)Source,0x10,Layer,Text);
  paVar3 = Dest;
  iVar4 = GetLayerNumber(Source,Layer);
  which = GetTextMemory(paVar3->Layer + iVar4);
  (which->BoundingBox).X1 = (Text->BoundingBox).X1;
  (which->BoundingBox).Y1 = (Text->BoundingBox).Y1;
  (which->BoundingBox).X2 = (Text->BoundingBox).X2;
  (which->BoundingBox).Y2 = (Text->BoundingBox).Y2;
  which->ID = Text->ID;
  (which->Flags).f = (Text->Flags).f;
  *(undefined4 *)(which->Flags).t = *(undefined4 *)(Text->Flags).t;
  *(undefined4 *)((which->Flags).t + 4) = *(undefined4 *)((Text->Flags).t + 4);
  which->net = Text->net;
  which->Scale = Text->Scale;
  which->X = Text->X;
  which->Y = Text->Y;
  uVar2 = *(undefined3 *)&Text->field_0x31;
  which->Direction = Text->Direction;
  *(undefined3 *)&which->field_0x31 = uVar2;
  which->TextString = Text->TextString;
  which->Element = Text->Element;
  pTVar1 = Layer->Text;
  CVar5 = Layer->TextN - 1;
  Layer->TextN = CVar5;
  if (pTVar1 + CVar5 != Text) {
    (Text->BoundingBox).X1 = pTVar1[CVar5].BoundingBox.X1;
    (Text->BoundingBox).Y1 = pTVar1[CVar5].BoundingBox.Y1;
    (Text->BoundingBox).X2 = pTVar1[CVar5].BoundingBox.X2;
    (Text->BoundingBox).Y2 = pTVar1[CVar5].BoundingBox.Y2;
    Text->ID = pTVar1[CVar5].ID;
    (Text->Flags).f = pTVar1[CVar5].Flags.f;
    *(undefined4 *)(Text->Flags).t = *(undefined4 *)pTVar1[CVar5].Flags.t;
    *(undefined4 *)((Text->Flags).t + 4) = *(undefined4 *)(pTVar1[CVar5].Flags.t + 4);
    Text->net = pTVar1[CVar5].net;
    Text->Scale = pTVar1[CVar5].Scale;
    Text->X = pTVar1[CVar5].X;
    Text->Y = pTVar1[CVar5].Y;
    uVar2 = *(undefined3 *)&pTVar1[CVar5].field_0x31;
    Text->Direction = pTVar1[CVar5].Direction;
    *(undefined3 *)&Text->field_0x31 = uVar2;
    Text->TextString = pTVar1[CVar5].TextString;
    Text->Element = pTVar1[CVar5].Element;
    r_substitute(Layer->text_tree,&Layer->Text[Layer->TextN].BoundingBox,&Text->BoundingBox);
    CVar5 = Layer->TextN;
  }
  puVar8 = (&Layer->Text->Flags)[CVar5 * 5 + -2].t;
  uVar7 = 0x3c;
  bVar9 = ((uint)puVar8 & 1) != 0;
  if (bVar9) {
    uVar7 = 0x3b;
    *puVar8 = '\0';
    puVar8 = puVar8 + 1;
  }
  if (((uint)puVar8 & 2) != 0) {
    *(undefined2 *)puVar8 = 0;
    uVar7 = uVar7 - 2;
    puVar8 = puVar8 + 2;
  }
  for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
    *(undefined4 *)puVar8 = 0;
    puVar8 = puVar8 + ((uint)bVar10 * -2 + 1) * 4;
  }
  if ((uVar7 & 2) != 0) {
    *(undefined2 *)puVar8 = 0;
    puVar8 = puVar8 + 2;
  }
  if (bVar9) {
    *puVar8 = '\0';
  }
  rtree = paVar3->Layer[iVar4].text_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    paVar3->Layer[iVar4].text_tree = rtree;
  }
  r_insert_entry(rtree,&which->BoundingBox,0);
  ClearFromPolygon((DataType *)Dest,0x10,paVar3->Layer + iVar4,which);
  return which;
}



// WARNING: Unknown calling convention

void * MoveLineToBuffer(LayerTypePtr Layer,LineTypePtr Line)

{
  DataTypePtr paVar1;
  int iVar2;
  LineTypePtr which;
  rtree_t *rtree;
  int iVar3;
  uint uVar4;
  uint uVar5;
  LineTypePtr pLVar6;
  LineTypePtr line;
  Cardinal CVar7;
  LineTypePtr pLVar8;
  undefined4 *puVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  RestoreToPolygon((DataType *)Source,4,Layer,Line);
  r_delete_entry(Layer->line_tree,&Line->BoundingBox);
  paVar1 = Dest;
  iVar2 = GetLayerNumber(Source,Layer);
  which = GetLineMemory(paVar1->Layer + iVar2);
  pLVar6 = Line;
  line = which;
  for (iVar3 = 0x16; iVar3 != 0; iVar3 = iVar3 + -1) {
    line = (LineTypePtr)((int)line + (uint)bVar11 * -8 + 4);
    (line->BoundingBox).X1 = (pLVar6->BoundingBox).X1;
    pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar11 * -8 + 4);
    line = line;
  }
  CVar7 = Layer->LineN;
  pLVar6 = Layer->Line;
  (which->Flags).f = (which->Flags).f & 0xfffffffb;
  CVar7 = CVar7 - 1;
  Layer->LineN = CVar7;
  if (pLVar6 + CVar7 != Line) {
    pLVar6 = pLVar6 + CVar7;
    pLVar8 = Line;
    for (iVar3 = 0x16; iVar3 != 0; iVar3 = iVar3 + -1) {
      (pLVar8->BoundingBox).X1 = (pLVar6->BoundingBox).X1;
      pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar11 * -8 + 4);
      pLVar8 = (LineTypePtr)((int)pLVar8 + (uint)bVar11 * -8 + 4);
    }
    r_substitute(Layer->line_tree,&Layer->Line[Layer->LineN].BoundingBox,&Line->BoundingBox);
    CVar7 = Layer->LineN;
  }
  puVar9 = (undefined4 *)((int)&Layer->Line->Flags + CVar7 * 0x58 + -0x14);
  uVar5 = 0x58;
  bVar10 = ((uint)puVar9 & 1) != 0;
  if (bVar10) {
    *(undefined *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 1);
    uVar5 = 0x57;
  }
  if (((uint)puVar9 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    uVar5 = uVar5 - 2;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
    *puVar9 = 0;
    puVar9 = puVar9 + (uint)bVar11 * -2 + 1;
  }
  if ((uVar5 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  if (bVar10) {
    *(undefined *)puVar9 = 0;
  }
  rtree = paVar1->Layer[iVar2].line_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    paVar1->Layer[iVar2].line_tree = rtree;
  }
  r_insert_entry(rtree,&which->BoundingBox,0);
  ClearFromPolygon((DataType *)Dest,4,paVar1->Layer + iVar2,which);
  return which;
}



// WARNING: Unknown calling convention

void FreeRotateElementLowLevel
               (DataTypePtr Data,ElementTypePtr Element,LocationType X,LocationType Y,double cosa,
               double sina,double Angle)

{
  int iVar1;
  double dVar2;
  double dVar3;
  LineTypePtr line;
  LineTypePtr Line;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar4;
  FontType *Font;
  Cardinal n;
  LocationType *pLVar5;
  Cardinal n_1;
  uint uVar6;
  int iVar7;
  int iVar8;
  PinTypePtr pin;
  PinTypePtr Pin;
  PadTypePtr pad;
  PadTypePtr Line_00;
  Cardinal n_2;
  double local_54;
  uint local_4c;
  double local_44;
  
  iVar7 = Element->LineN - 1;
  if (iVar7 != -1) {
    iVar8 = Element->LineN * 0x58;
    do {
      iVar7 = iVar7 + -1;
      Line = (LineTypePtr)(Element->Line[-1].Flags.t + iVar8 + -0x18);
      dVar2 = (double)((Line->Point1).X - X);
      dVar3 = (double)((Line->Point1).Y - Y);
      iVar1 = (Line->Point2).X;
      (Line->Point1).X = (int)ROUND(sina * dVar3 + cosa * dVar2 + (double)X);
      (Line->Point1).Y = (int)ROUND((dVar3 * cosa - dVar2 * sina) + (double)Y);
      dVar2 = (double)(iVar1 - X);
      dVar3 = (double)((Line->Point2).Y - Y);
      (Line->Point2).X = (int)ROUND(sina * dVar3 + cosa * dVar2 + (double)X);
      (Line->Point2).Y = (int)ROUND((dVar3 * cosa - dVar2 * sina) + (double)Y);
      SetLineBoundingBox(Line);
      iVar8 = iVar8 + -0x58;
    } while (iVar7 != -1);
  }
  local_44 = (double)X;
  local_54 = (double)Y;
  if (Element->PinN != 0) {
    uVar6 = 0;
    local_4c = Element->PinN;
    do {
      Pin = Element->Pin + uVar6;
      if (Data != (DataTypePtr)0x0) {
        r_delete_entry(Data->pin_tree,&Pin->BoundingBox);
      }
      RestoreToPolygon((DataType *)Data,0x100,Element,Pin);
      dVar3 = (double)(Pin->X - X);
      dVar2 = (double)(Pin->Y - Y);
      Pin->X = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
      Pin->Y = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
      SetPinBoundingBox(Pin);
      uVar4 = Element->PinN;
    } while ((uVar4 != 0) &&
            (uVar6 = (uVar4 + 1 + uVar6) - local_4c, local_4c = uVar4, uVar6 < uVar4));
  }
  uVar6 = Element->PadN;
  local_4c = 0;
  uVar4 = uVar6;
  while ((uVar4 != 0 && (local_4c < uVar4))) {
    Line_00 = Element->Pad + local_4c;
    if (Data != (DataTypePtr)0x0) {
      r_delete_entry(Data->pad_tree,&Line_00->BoundingBox);
    }
    RestoreToPolygon((DataType *)Data,0x200,Element,Line_00);
    dVar3 = (double)((Line_00->Point1).X - X);
    dVar2 = (double)((Line_00->Point1).Y - Y);
    iVar7 = (Line_00->Point2).X;
    (Line_00->Point1).X = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
    (Line_00->Point1).Y = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
    dVar3 = (double)(iVar7 - X);
    dVar2 = (double)((Line_00->Point2).Y - Y);
    (Line_00->Point2).X = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
    (Line_00->Point2).Y = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
    SetLineBoundingBox((LineTypePtr)Line_00);
    uVar4 = Element->PadN;
    if (Element->PadN == uVar6) {
      local_4c = local_4c + 1;
      uVar4 = uVar6;
    }
  }
  iVar7 = Element->ArcN - 1;
  if (iVar7 != -1) {
    pLVar5 = &Element->Arc[Element->ArcN - 1].X;
    do {
      iVar8 = *pLVar5;
      iVar7 = iVar7 + -1;
      *pLVar5 = (int)ROUND(sina * (double)(pLVar5[1] - Y) + cosa * (double)(iVar8 - X) + local_44);
      pLVar5[1] = (int)ROUND(((double)(pLVar5[1] - Y) * cosa - (double)(iVar8 - X) * sina) +
                             local_54);
      pLVar5[2] = (int)ROUND((double)pLVar5[2] + Angle) % 0x168;
      pLVar5 = pLVar5 + -0x11;
    } while (iVar7 != -1);
  }
  dVar3 = (double)(Element->MarkX - X);
  dVar2 = (double)(Element->MarkY - Y);
  Font = &PCB->Font;
  Element->MarkX = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
  Element->MarkY = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
  SetElementBoundingBox(Data,Element,Font);
  ClearFromPolygon((DataType *)Data,2,Element,Element);
  return;
}



// WARNING: Unknown calling convention

void InitBuffers(void)

{
  Buffers[0].Data = CreateNewBuffer();
  Buffers[1].Data = CreateNewBuffer();
  Buffers[2].Data = CreateNewBuffer();
  Buffers[3].Data = CreateNewBuffer();
  Buffers[4].Data = CreateNewBuffer();
  return;
}



// WARNING: Unknown calling convention

void RotateBuffer(BufferTypePtr Buffer,BYTE Number)

{
  uint uVar1;
  LocationType dx;
  int iVar2;
  DataTypePtr Data;
  PCBTypePtr pPVar3;
  Cardinal n_5;
  byte bVar4;
  LocationType dy;
  Cardinal sn;
  int iVar5;
  Cardinal n_2;
  Cardinal n_3;
  Cardinal n_4;
  int iVar6;
  PinTypePtr via;
  PinTypePtr Pin;
  Cardinal n_1;
  LineTypePtr line;
  LineTypePtr Line;
  ArcTypePtr arc;
  ArcTypePtr Arc;
  TextTypePtr Text;
  PolygonTypePtr Polygon;
  uint uVar7;
  Cardinal n;
  int iVar8;
  LayerTypePtr layer;
  LayerTypePtr layer_3;
  LayerTypePtr layer_1;
  LayerType *pLVar9;
  uint local_2c;
  uint local_24;
  
  Data = Buffer->Data;
  if (Data->ViaN != 0) {
    uVar7 = 0;
    bVar4 = Number & 3;
    local_2c = Data->ViaN;
    do {
      Pin = Data->Via + uVar7;
      r_delete_entry(Data->via_tree,&Pin->BoundingBox);
      iVar8 = Buffer->Y;
      iVar6 = Buffer->X;
      iVar5 = Pin->Y - iVar8;
      iVar2 = Pin->X - iVar6;
      if (bVar4 == 2) {
        Pin->X = iVar6 - iVar2;
        Pin->Y = iVar8 - iVar5;
      }
      else if (bVar4 == 3) {
        Pin->X = iVar6 - iVar5;
        Pin->Y = iVar2 + iVar8;
      }
      else if (bVar4 == 1) {
        Pin->X = iVar5 + iVar6;
        Pin->Y = iVar8 - iVar2;
      }
      SetPinBoundingBox(Pin);
      r_insert_entry(Buffer->Data->via_tree,&Pin->BoundingBox,0);
      Data = Buffer->Data;
      uVar1 = Data->ViaN;
    } while ((uVar1 != 0) &&
            (uVar7 = (uVar1 + 1 + uVar7) - local_2c, local_2c = uVar1, uVar7 < uVar1));
  }
  iVar8 = Data->ElementN - 1;
  if (iVar8 != -1) {
    iVar6 = Data->ElementN * 300;
    while( true ) {
      iVar8 = iVar8 + -1;
      RotateElementLowLevel
                (Data,(ElementTypePtr)(Data->Element[-1].Flags.t + iVar6 + -0x18),Buffer->X,
                 Buffer->Y,Number);
      if (iVar8 == -1) break;
      Data = Buffer->Data;
      iVar6 = iVar6 + -300;
    }
    Data = Buffer->Data;
  }
  pLVar9 = Data->Layer;
  if (PCB->Data->LayerN != -2) {
    local_24 = 0;
    pPVar3 = PCB;
    while( true ) {
      iVar8 = pLVar9->LineN - 1;
      if (iVar8 != -1) {
        iVar6 = pLVar9->LineN * 0x58;
        do {
          Line = (LineTypePtr)(pLVar9->Line[-1].Flags.t + iVar6 + -0x18);
          r_delete_entry(pLVar9->line_tree,(BoxType *)Line);
          RotateLineLowLevel(Line,Buffer->X,Buffer->Y,Number);
          r_insert_entry(pLVar9->line_tree,(BoxType *)Line,0);
          iVar8 = iVar8 + -1;
          pPVar3 = PCB;
          iVar6 = iVar6 + -0x58;
        } while (iVar8 != -1);
      }
      local_24 = local_24 + 1;
      iVar8 = pPVar3->Data->LayerN;
      if (iVar8 + 2U <= local_24) break;
      pLVar9 = pLVar9 + 1;
    }
    pLVar9 = Buffer->Data->Layer;
    if (iVar8 != -2) {
      local_24 = 0;
      while( true ) {
        iVar8 = pLVar9->ArcN - 1;
        if (iVar8 != -1) {
          iVar6 = pLVar9->ArcN * 0x44;
          do {
            Arc = (ArcTypePtr)(pLVar9->Arc[-1].Flags.t + iVar6 + -0x18);
            r_delete_entry(pLVar9->arc_tree,(BoxType *)Arc);
            RotateArcLowLevel(Arc,Buffer->X,Buffer->Y,Number);
            r_insert_entry(pLVar9->arc_tree,(BoxType *)Arc,0);
            iVar8 = iVar8 + -1;
            pPVar3 = PCB;
            iVar6 = iVar6 + -0x44;
          } while (iVar8 != -1);
        }
        local_24 = local_24 + 1;
        iVar8 = pPVar3->Data->LayerN;
        if (iVar8 + 2U <= local_24) break;
        pLVar9 = pLVar9 + 1;
      }
      pLVar9 = Buffer->Data->Layer;
      if (iVar8 != -2) {
        local_24 = 0;
        while( true ) {
          iVar8 = pLVar9->TextN - 1;
          if (iVar8 != -1) {
            iVar6 = pLVar9->TextN * 0x3c;
            do {
              Text = (TextTypePtr)(pLVar9->Text[-1].Flags.t + iVar6 + -0x18);
              r_delete_entry(pLVar9->text_tree,(BoxType *)Text);
              RotateTextLowLevel(Text,Buffer->X,Buffer->Y,Number);
              r_insert_entry(pLVar9->text_tree,(BoxType *)Text,0);
              iVar8 = iVar8 + -1;
              pPVar3 = PCB;
              iVar6 = iVar6 + -0x3c;
            } while (iVar8 != -1);
          }
          local_24 = local_24 + 1;
          iVar8 = pPVar3->Data->LayerN;
          if (iVar8 + 2U <= local_24) break;
          pLVar9 = pLVar9 + 1;
        }
        pLVar9 = Buffer->Data->Layer;
        if (iVar8 != -2) {
          local_24 = 0;
          while( true ) {
            iVar8 = pLVar9->PolygonN - 1;
            if (iVar8 != -1) {
              iVar6 = pLVar9->PolygonN * 0x3c;
              do {
                Polygon = (PolygonTypePtr)(pLVar9->Polygon[-1].Flags.t + iVar6 + -0x18);
                r_delete_entry(pLVar9->polygon_tree,(BoxType *)Polygon);
                RotatePolygonLowLevel(Polygon,Buffer->X,Buffer->Y,Number);
                r_insert_entry(pLVar9->polygon_tree,(BoxType *)Polygon,0);
                iVar8 = iVar8 + -1;
                pPVar3 = PCB;
                iVar6 = iVar6 + -0x3c;
              } while (iVar8 != -1);
            }
            local_24 = local_24 + 1;
            if (pPVar3->Data->LayerN + 2U <= local_24) break;
            pLVar9 = pLVar9 + 1;
          }
        }
      }
    }
  }
  RotateBoxLowLevel(&Buffer->BoundingBox,Buffer->X,Buffer->Y,Number);
  return;
}



// WARNING: Unknown calling convention

void AddSelectedToBuffer(BufferTypePtr Buffer,LocationType X,LocationType Y,Boolean LeaveSelected)

{
  if (LeaveSelected == '\0') {
    ExtraFlag = 0x40;
  }
  HideCrosshair('\x01');
  Source = PCB->Data;
  Dest = Buffer->Data;
  SelectedOperation((ObjectFunctionTypePtr)&AddBufferFunctions,'\0',-1);
  if ((Y == 0) && (X == 0)) {
    Buffer->X = Crosshair.X;
    Buffer->Y = Crosshair.Y;
  }
  else {
    Buffer->X = X;
    Buffer->Y = Y;
  }
  RestoreCrosshair('\x01');
  ExtraFlag = 0;
  return;
}



// WARNING: Unknown calling convention

void ClearBuffer(BufferTypePtr Buffer)

{
  if ((Buffer != (BufferTypePtr)0x0) && (Buffer->Data != (DataTypePtr)0x0)) {
    FreeDataMemory(Buffer->Data);
    Buffer->Data->pcb = PCB;
  }
  return;
}



// WARNING: Unknown calling convention

Boolean LoadLayoutToBuffer(BufferTypePtr Buffer,char *Filename)

{
  PCBTypePtr Ptr;
  int iVar1;
  PCBTypePtr newPCB;
  
  Ptr = CreateNewPCB('\0');
  iVar1 = ParsePCB(Ptr,Filename);
  if (iVar1 != 0) {
    RemovePCB(Ptr);
    Buffer->Data->pcb = PCB;
    return '\0';
  }
  ClearBuffer(Buffer);
  SaveFree(Buffer->Data);
  Buffer->Data = Ptr->Data;
  Ptr->Data = (DataTypePtr)0x0;
  Buffer->X = Ptr->CursorX;
  Buffer->Y = Ptr->CursorY;
  RemovePCB(Ptr);
  Buffer->Data->pcb = PCB;
  return '\x01';
}



// WARNING: Unknown calling convention

Boolean SmashBufferElement(BufferTypePtr Buffer)

{
  int iVar1;
  DataTypePtr paVar2;
  ElementTypePtr Element;
  ArcTypePtr paVar3;
  uint uVar4;
  PinTypePtr paVar5;
  Cardinal CVar6;
  Cardinal CVar7;
  DataTypePtr paVar8;
  PadTypePtr paVar9;
  int iVar10;
  FlagType flag;
  FlagType flag_00;
  FlagType Flags;
  FlagType Flags_00;
  FlagType Flags_01;
  FlagType Flags_02;
  Boolean BVar11;
  Cardinal n;
  char *pcVar12;
  ArcTypePtr arc;
  Cardinal sn;
  PinTypePtr pin;
  Cardinal CVar13;
  Cardinal sn_1;
  Cardinal CVar14;
  LayerTypePtr Layer;
  LineTypePtr pLVar15;
  PadTypePtr pad;
  LineTypePtr line;
  Cardinal n_1;
  uint uVar16;
  Cardinal n_2;
  ElementTypePtr element;
  int iVar17;
  LineTypePtr line_1;
  int in_GS_OFFSET;
  LayerTypePtr slayer;
  int local_80;
  uint local_7c;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  FlagType f;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  paVar2 = Buffer->Data;
  if (paVar2->ElementN == 1) {
    Element = paVar2->Element;
    paVar2->ElementN = 0;
    ClearBuffer(Buffer);
    iVar17 = Element->LineN - 1;
    if (iVar17 != -1) {
      iVar10 = Element->LineN * 0x58;
      do {
        pLVar15 = Element->Line;
        MakeFlags(0);
        iVar17 = iVar17 + -1;
        Flags.t._0_4_ = local_34;
        Flags.f = local_38;
        Flags.t._4_4_ = local_30;
        CreateNewLineOnLayer
                  (Buffer->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN
                   ,*(LocationType *)
                     ((int)&((PointType *)(&pLVar15[-1].Flags + 2))->Y + iVar10 + -4),
                   *(LocationType *)((int)&((PointType *)(&pLVar15[-1].Flags + 2))->Y + iVar10),
                   *(LocationType *)((int)(&pLVar15[-1].Flags + 3) + iVar10 + 8),
                   *(LocationType *)((int)(&pLVar15[-1].Flags + 4) + iVar10),
                   *(BDimension *)((int)(&pLVar15[-1].Flags + 1) + iVar10 + 4),0,Flags);
        pcVar12 = MyStrdup(Element->Name[1].TextString,"SmashBuffer");
        *(char **)((int)(&pLVar15[-1].Flags + 5) + iVar10 + 4) = pcVar12;
        iVar10 = iVar10 + -0x58;
      } while (iVar17 != -1);
    }
    iVar17 = Element->ArcN - 1;
    if (iVar17 != -1) {
      iVar10 = Element->ArcN * 0x44;
      do {
        paVar3 = Element->Arc;
        MakeFlags(0);
        iVar17 = iVar17 + -1;
        Flags_02.t._0_4_ = local_40;
        Flags_02.f = local_44;
        Flags_02.t._4_4_ = local_3c;
        CreateNewArcOnLayer(Buffer->Data->Layer +
                            (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN,
                            *(LocationType *)((int)(&paVar3[-1].Flags + 2) + iVar10 + 8),
                            *(LocationType *)((int)(&paVar3[-1].Flags + 3) + iVar10),
                            *(BDimension *)((int)(&paVar3[-1].Flags + 2) + iVar10),
                            *(BDimension *)((int)(&paVar3[-1].Flags + 2) + iVar10 + 4),
                            *(int *)((int)(&paVar3[-1].Flags + 3) + iVar10 + 4),
                            *(int *)((int)(&paVar3[-1].Flags + 3) + iVar10 + 8),
                            *(BDimension *)((int)(&paVar3[-1].Flags + 1) + iVar10 + 4),0,Flags_02);
        iVar10 = iVar10 + -0x44;
      } while (iVar17 != -1);
    }
    if (Element->PinN != 0) {
      uVar16 = 0;
      CVar13 = Element->PinN;
      do {
        paVar5 = Element->Pin;
        MakeFlags(0);
        flag.t._0_4_ = f.t._0_4_;
        flag.f = f.f;
        flag.t._4_4_ = f.t._4_4_;
        AddFlags(flag,2);
        if ((*(byte *)&paVar5[uVar16].Flags.f & 8) != 0) {
          flag_00.t._0_4_ = f.t._0_4_;
          flag_00.f = f.f;
          flag_00.t._4_4_ = f.t._4_4_;
          AddFlags(flag_00,8);
        }
        Flags_01.t._0_4_ = f.t._0_4_;
        Flags_01.f = f.f;
        Flags_01.t._4_4_ = f.t._4_4_;
        CreateNewVia(Buffer->Data,paVar5[uVar16].X,paVar5[uVar16].Y,paVar5[uVar16].Thickness,
                     paVar5[uVar16].Clearance,paVar5[uVar16].Mask,paVar5[uVar16].DrillingHole,
                     paVar5[uVar16].Number,Flags_01);
        uVar4 = Element->PinN;
      } while ((uVar4 != 0) &&
              (uVar16 = (uVar4 + 1 + uVar16) - CVar13, CVar13 = uVar4, uVar16 < uVar4));
    }
    iVar17 = GetLayerGroupNumberByNumber
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN);
    paVar2 = Buffer->Data;
    CVar13 = (PCB->LayerGroups).Entries[iVar17][0];
    iVar17 = GetLayerGroupNumberByNumber
                       ((uint)(Settings.ShowSolderSide != '\0') + PCB->Data->LayerN);
    CVar6 = Element->PadN;
    local_80 = 0;
    local_7c = 0;
    CVar7 = (PCB->LayerGroups).Entries[iVar17][0];
    paVar8 = Buffer->Data;
    CVar14 = CVar6;
    while ((CVar14 != 0 && (local_7c < CVar14))) {
      paVar9 = Element->Pad;
      MakeFlags(0);
      Layer = paVar8->Layer + CVar7;
      if (-1 < (char)(paVar9->Flags).t[local_80 + -4]) {
        Layer = paVar2->Layer + CVar13;
      }
      Flags_00.t._0_4_ = local_4c;
      Flags_00.f = local_50;
      Flags_00.t._4_4_ = local_48;
      pLVar15 = CreateNewLineOnLayer
                          (Layer,*(LocationType *)
                                  ((int)&((PointType *)(&paVar9->Flags + 2))->Y + local_80 + -4),
                           *(LocationType *)
                            ((int)&((PointType *)(&paVar9->Flags + 2))->Y + local_80),
                           *(LocationType *)((int)(&paVar9->Flags + 3) + local_80 + 8),
                           *(LocationType *)((int)(&paVar9->Flags + 4) + local_80),
                           *(BDimension *)((int)(&paVar9->Flags + 1) + local_80 + 4),
                           *(BDimension *)((int)(&paVar9->Flags + 1) + local_80 + 8),Flags_00);
      if (pLVar15 != (LineTypePtr)0x0) {
        pcVar12 = MyStrdup(*(char **)((int)(&paVar9->Flags + 6) + local_80),"SmashBuffer");
        pLVar15->Number = pcVar12;
      }
      CVar14 = Element->PadN;
      if (Element->PadN == CVar6) {
        local_7c = local_7c + 1;
        local_80 = local_80 + 0x68;
        CVar14 = CVar6;
      }
    }
    FreeElementMemory(Element);
    SaveFree(Element);
    BVar11 = '\x01';
  }
  else {
    Message("Error!  Buffer doesn\'t contain a single element\n");
    BVar11 = '\0';
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar11;
}



// WARNING: Unknown calling convention

void SetBufferBoundingBox(BufferTypePtr Buffer)

{
  BoxTypePtr pBVar1;
  BoxTypePtr box;
  
  pBVar1 = GetDataBoundingBox(Buffer->Data);
  if (pBVar1 != (BoxTypePtr)0x0) {
    (Buffer->BoundingBox).X1 = pBVar1->X1;
    (Buffer->BoundingBox).Y1 = pBVar1->Y1;
    (Buffer->BoundingBox).X2 = pBVar1->X2;
    (Buffer->BoundingBox).Y2 = pBVar1->Y2;
  }
  return;
}



// WARNING: Unknown calling convention

void MirrorBuffer(BufferTypePtr Buffer)

{
  DataTypePtr paVar1;
  Cardinal CVar2;
  int iVar3;
  int i;
  PinTypePtr paVar4;
  LayerTypePtr layer;
  PointType *pPVar5;
  ArcTypePtr arc;
  ArcTypePtr Arc;
  PointTypePtr pPVar6;
  PCBTypePtr pPVar7;
  DataTypePtr paVar8;
  uint uVar9;
  Cardinal n;
  Cardinal n_1;
  int iVar10;
  DataTypePtr paVar11;
  Cardinal n_3;
  LayerType *pLVar12;
  Cardinal n_2;
  Cardinal l_1;
  int iVar13;
  PolygonTypePtr polygon;
  PolygonTypePtr Polygon;
  uint uVar14;
  Cardinal l;
  LayerTypePtr layer_1;
  LayerType *pLVar15;
  uint local_28;
  LayerType *local_24;
  PCBTypePtr local_20;
  
  pPVar7 = PCB;
  paVar1 = Buffer->Data;
  if (paVar1->ElementN == 0) {
    paVar11 = PCB->Data;
    iVar13 = paVar11->LayerN;
    if (iVar13 + 1 < 0) {
LAB_080778c8:
      iVar3 = PCB->MaxHeight;
      Buffer->Y = iVar3 - Buffer->Y;
      uVar14 = paVar1->ViaN;
      if (uVar14 != 0) {
        paVar4 = paVar1->Via;
        paVar4->Y = iVar3 - paVar4->Y;
        for (uVar9 = 1; uVar9 < uVar14; uVar9 = uVar9 + 1) {
          paVar4[1].Y = iVar3 - paVar4[1].Y;
          paVar4 = paVar4 + 1;
        }
      }
      pLVar15 = paVar1->Layer;
      if (iVar13 != -2) {
        uVar14 = 0;
        pLVar12 = pLVar15;
        while( true ) {
          iVar10 = pLVar12->LineN - 1;
          if (iVar10 != -1) {
            pPVar5 = &pLVar12->Line[pLVar12->LineN - 1].Point1;
            do {
              iVar10 = iVar10 + -1;
              pPVar5->Y = iVar3 - pPVar5->Y;
              pPVar5[1].Y = iVar3 - pPVar5[1].Y;
              pPVar5 = (PointType *)((int)(pPVar5 + -5) + 0xc);
            } while (iVar10 != -1);
          }
          uVar14 = uVar14 + 1;
          if (iVar13 + 2U <= uVar14) break;
          pLVar12 = pLVar12 + 1;
        }
      }
      if (iVar13 != -2) {
        uVar14 = 0;
        local_20 = pPVar7;
        while( true ) {
          iVar13 = pLVar15->ArcN - 1;
          if (iVar13 != -1) {
            iVar3 = pLVar15->ArcN * 0x44;
            do {
              iVar13 = iVar13 + -1;
              iVar10 = pPVar7->MaxHeight;
              Arc = (ArcTypePtr)(pLVar15->Arc[-1].Flags.t + iVar3 + -0x18);
              Arc->StartAngle = -Arc->StartAngle;
              Arc->Delta = -Arc->Delta;
              Arc->Y = iVar10 - Arc->Y;
              SetArcBoundingBox(Arc);
              pPVar7 = PCB;
              iVar3 = iVar3 + -0x44;
            } while (iVar13 != -1);
            paVar11 = PCB->Data;
            local_20 = PCB;
          }
          uVar14 = uVar14 + 1;
          if (paVar11->LayerN + 2U <= uVar14) break;
          pLVar15 = pLVar15 + 1;
        }
        local_24 = Buffer->Data->Layer;
        if (paVar11->LayerN != -2) {
          local_28 = 0;
          while( true ) {
            iVar13 = local_24->PolygonN - 1;
            if (iVar13 != -1) {
              iVar3 = local_24->PolygonN * 0x3c;
              do {
                local_20 = (PCBTypePtr)iVar13;
                Polygon = (PolygonTypePtr)(local_24->Polygon[-1].Flags.t + iVar3 + -0x18);
                iVar13 = Polygon->PointN - 1;
                if (iVar13 != -1) {
                  pPVar6 = Polygon->Points + (Polygon->PointN - 1);
                  iVar10 = PCB->MaxHeight;
                  do {
                    iVar13 = iVar13 + -1;
                    pPVar6->Y = iVar10 - pPVar6->Y;
                    pPVar6 = pPVar6 + -1;
                  } while (iVar13 != -1);
                }
                SetPolygonBoundingBox(Polygon);
                iVar13 = (int)local_20 + -1;
                local_20 = PCB;
                iVar3 = iVar3 + -0x3c;
              } while (iVar13 != -1);
            }
            local_28 = local_28 + 1;
            if (local_20->Data->LayerN + 2U <= local_28) break;
            local_24 = local_24 + 1;
          }
        }
      }
      SetBufferBoundingBox(Buffer);
      return;
    }
    iVar3 = 0;
    CVar2 = paVar1->Layer[0].TextN;
    paVar8 = paVar1;
    while (CVar2 == 0) {
      iVar3 = iVar3 + 1;
      if (iVar13 + 1 < iVar3) goto LAB_080778c8;
      pLVar15 = paVar8->Layer;
      paVar8 = (DataTypePtr)&paVar8->Layer[0].ArcN;
      CVar2 = pLVar15[1].TextN;
    }
    Buffer = (BufferTypePtr)s_You_can_t_mirror_a_buffer_that_h_0813e250;
  }
  else {
    Buffer = (BufferTypePtr)s_You_can_t_mirror_a_buffer_that_h_0813e220;
  }
  Message((char *)Buffer);
  return;
}



// WARNING: Unknown calling convention

void SwapBuffer(BufferTypePtr Buffer)

{
  byte bVar1;
  int iVar2;
  Cardinal CVar3;
  Cardinal CVar4;
  DataTypePtr paVar5;
  PointTypePtr pPVar6;
  Cardinal cgroup;
  uint uVar7;
  sbyte sVar8;
  int iVar9;
  PCBTypePtr pPVar10;
  int k;
  Cardinal n_1;
  Cardinal n_4;
  DataTypePtr paVar11;
  Cardinal *pCVar12;
  uint uVar13;
  uchar *puVar14;
  Cardinal n;
  int iVar15;
  PinTypePtr via;
  PinTypePtr Pin;
  LineTypePtr line;
  LineTypePtr Line;
  LayerTypePtr layer_1;
  PolygonTypePtr polygon;
  PolygonTypePtr Polygon;
  LayerTypePtr layer_3;
  LayerType *pLVar16;
  Cardinal cnumber;
  uchar *puVar17;
  Cardinal sn;
  uint uVar18;
  LayerTypePtr layer;
  ArcTypePtr arc;
  ArcTypePtr Arc;
  LayerTypePtr layer_2;
  TextTypePtr text;
  TextTypePtr Text;
  ElementTypePtr element;
  ElementType *element_00;
  Cardinal n_2;
  Cardinal n_3;
  Cardinal n_5;
  Cardinal n_6;
  LayerType *pLVar19;
  uint uVar20;
  byte bVar21;
  int local_c4;
  Cardinal local_c0;
  Cardinal (*local_bc) [18];
  uint local_b8;
  int local_a0;
  Cardinal *local_9c;
  byte local_94;
  byte local_90;
  uint local_88;
  int local_84;
  DataTypePtr local_80;
  LayerType swap;
  
  bVar21 = 0;
  paVar5 = Buffer->Data;
  iVar15 = paVar5->ElementN - 1;
  if (iVar15 != -1) {
    iVar9 = paVar5->ElementN * 300;
    while( true ) {
      iVar15 = iVar15 + -1;
      element_00 = (ElementType *)(((DataType *)paVar5)->Element[-1].Flags.t + iVar9 + -0x18);
      r_delete_element((DataType *)paVar5,element_00);
      MirrorElementCoordinates(Buffer->Data,(ElementTypePtr)element_00,0);
      if (iVar15 == -1) break;
      paVar5 = Buffer->Data;
      iVar9 = iVar9 + -300;
    }
    paVar5 = Buffer->Data;
  }
  pPVar10 = PCB;
  Buffer->Y = PCB->MaxHeight - Buffer->Y;
  if (paVar5->ViaN != 0) {
    uVar18 = 0;
    local_80 = (DataTypePtr)paVar5->ViaN;
    do {
      Pin = paVar5->Via + uVar18;
      r_delete_entry(paVar5->via_tree,&Pin->BoundingBox);
      Pin->Y = PCB->MaxHeight - Pin->Y;
      SetPinBoundingBox(Pin);
      r_insert_entry(Buffer->Data->via_tree,&Pin->BoundingBox,0);
      paVar5 = Buffer->Data;
      uVar13 = paVar5->ViaN;
      pPVar10 = PCB;
      if (uVar13 == 0) break;
      uVar18 = (uVar13 + 1 + uVar18) - (int)local_80;
      local_80 = (DataTypePtr)uVar13;
    } while (uVar18 < uVar13);
  }
  pLVar16 = paVar5->Layer;
  if (pPVar10->Data->LayerN != -2) {
    local_80 = (DataTypePtr)0x0;
    while( true ) {
      iVar15 = pLVar16->LineN - 1;
      if (iVar15 != -1) {
        iVar9 = pLVar16->LineN * 0x58;
        do {
          iVar15 = iVar15 + -1;
          Line = (LineTypePtr)(pLVar16->Line[-1].Flags.t + iVar9 + -0x18);
          r_delete_entry(pLVar16->line_tree,(BoxType *)Line);
          iVar2 = PCB->MaxHeight;
          (Line->Point2).Y = iVar2 - (Line->Point2).Y;
          (Line->Point1).Y = iVar2 - (Line->Point1).Y;
          SetLineBoundingBox(Line);
          r_insert_entry(pLVar16->line_tree,(BoxType *)Line,0);
          pPVar10 = PCB;
          iVar9 = iVar9 + -0x58;
        } while (iVar15 != -1);
      }
      local_80 = (DataTypePtr)((int)local_80 + 1);
      iVar15 = pPVar10->Data->LayerN;
      if (iVar15 + 2U <= local_80) break;
      pLVar16 = pLVar16 + 1;
    }
    paVar5 = Buffer->Data;
    pLVar16 = paVar5->Layer;
    if (iVar15 != -2) {
      local_80 = (DataTypePtr)0x0;
      while( true ) {
        iVar15 = pLVar16->ArcN - 1;
        if (iVar15 != -1) {
          iVar9 = pLVar16->ArcN * 0x44;
          do {
            iVar15 = iVar15 + -1;
            Arc = (ArcTypePtr)(pLVar16->Arc[-1].Flags.t + iVar9 + -0x18);
            r_delete_entry(pLVar16->arc_tree,(BoxType *)Arc);
            pPVar10 = PCB;
            Arc->StartAngle = -Arc->StartAngle;
            Arc->Delta = -Arc->Delta;
            Arc->Y = pPVar10->MaxHeight - Arc->Y;
            SetArcBoundingBox(Arc);
            r_insert_entry(pLVar16->arc_tree,(BoxType *)Arc,0);
            pPVar10 = PCB;
            iVar9 = iVar9 + -0x44;
          } while (iVar15 != -1);
        }
        paVar11 = pPVar10->Data;
        local_80 = (DataTypePtr)((int)local_80 + 1);
        iVar15 = paVar11->LayerN;
        if (iVar15 + 2U <= local_80) break;
        pLVar16 = pLVar16 + 1;
      }
      layer_2 = Buffer->Data->Layer;
      local_80 = Buffer->Data;
      if (iVar15 != -2) {
        local_88 = 0;
        while( true ) {
          local_80 = (DataTypePtr)(layer_2->PolygonN - 1);
          if (local_80 != (DataTypePtr)0xffffffff) {
            iVar15 = layer_2->PolygonN * 0x3c;
            do {
              local_84 = iVar15 + -0x3c;
              Polygon = (PolygonTypePtr)(layer_2->Polygon[-1].Flags.t + iVar15 + -0x18);
              r_delete_entry(layer_2->polygon_tree,(BoxType *)Polygon);
              iVar15 = Polygon->PointN - 1;
              if (iVar15 != -1) {
                pPVar6 = Polygon->Points + (Polygon->PointN - 1);
                iVar9 = PCB->MaxHeight;
                do {
                  iVar15 = iVar15 + -1;
                  pPVar6->Y = iVar9 - pPVar6->Y;
                  pPVar6 = pPVar6 + -1;
                } while (iVar15 != -1);
              }
              SetPolygonBoundingBox(Polygon);
              r_insert_entry(layer_2->polygon_tree,(BoxType *)Polygon,0);
              local_80 = (DataTypePtr)((int)local_80 + -1);
              pPVar10 = PCB;
              iVar15 = local_84;
            } while (local_80 != (DataTypePtr)0xffffffff);
          }
          paVar11 = pPVar10->Data;
          local_88 = local_88 + 1;
          iVar15 = paVar11->LayerN;
          if (iVar15 + 2U <= local_88) break;
          layer_2 = layer_2 + 1;
        }
        pLVar16 = Buffer->Data->Layer;
        local_80 = Buffer->Data;
        if (iVar15 != -2) {
          local_80 = (DataTypePtr)0x0;
          while( true ) {
            iVar15 = pLVar16->TextN - 1;
            if (iVar15 != -1) {
              iVar9 = pLVar16->TextN * 0x3c;
              do {
                iVar15 = iVar15 + -1;
                Text = (TextTypePtr)(pLVar16->Text[-1].Flags.t + iVar9 + -0x18);
                r_delete_entry(pLVar16->text_tree,(BoxType *)Text);
                pPVar10 = PCB;
                (Text->Flags).f = (Text->Flags).f ^ 0x80;
                Text->Y = pPVar10->MaxHeight - Text->Y;
                SetTextBoundingBox(&pPVar10->Font,Text);
                r_insert_entry(pLVar16->text_tree,(BoxType *)Text,0);
                pPVar10 = PCB;
                iVar9 = iVar9 + -0x3c;
              } while (iVar15 != -1);
            }
            paVar11 = pPVar10->Data;
            local_80 = (DataTypePtr)((int)local_80 + 1);
            iVar15 = paVar11->LayerN;
            if (iVar15 + 2U <= local_80) break;
            pLVar16 = pLVar16 + 1;
          }
          local_80 = Buffer->Data;
        }
      }
      goto LAB_08077e81;
    }
  }
  paVar11 = pPVar10->Data;
  iVar15 = paVar11->LayerN;
  local_80 = paVar5;
LAB_08077e81:
  pLVar16 = local_80->Layer + iVar15;
  pLVar19 = &swap;
  for (iVar9 = 0x17; iVar9 != 0; iVar9 = iVar9 + -1) {
    pLVar19->Name = pLVar16->Name;
    pLVar16 = (LayerType *)((int)pLVar16 + ((uint)bVar21 * -2 + 1) * 4);
    pLVar19 = (LayerType *)((int)pLVar19 + (uint)bVar21 * -8 + 4);
  }
  CVar3 = paVar11->LayerN;
  pLVar16 = local_80->Layer + iVar15 + 1;
  pLVar19 = local_80->Layer + iVar15;
  for (iVar9 = 0x17; iVar9 != 0; iVar9 = iVar9 + -1) {
    pLVar19->Name = pLVar16->Name;
    pLVar16 = (LayerType *)((int)pLVar16 + (uint)bVar21 * -8 + 4);
    pLVar19 = (LayerType *)((int)pLVar19 + ((uint)bVar21 * -2 + 1) * 4);
  }
  pLVar16 = &swap;
  pLVar19 = local_80->Layer + CVar3 + 1;
  for (iVar15 = 0x17; iVar15 != 0; iVar15 = iVar15 + -1) {
    pLVar19->Name = pLVar16->Name;
    pLVar16 = (LayerType *)((int)pLVar16 + (uint)bVar21 * -8 + 4);
    pLVar19 = (LayerType *)((int)pLVar19 + (uint)bVar21 * -8 + 4);
  }
  iVar15 = GetLayerGroupNumberByNumber(CVar3);
  iVar9 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  pPVar10 = PCB;
  CVar3 = (PCB->LayerGroups).Number[iVar9];
  if ((CVar3 == (PCB->LayerGroups).Number[iVar15]) && (CVar3 != 0)) {
    paVar5 = PCB->Data;
    local_c4 = 0;
    local_bc = (PCB->LayerGroups).Entries[iVar15];
    local_c0 = 0;
    do {
      local_b8 = (pPVar10->LayerGroups).Entries[iVar9][local_c4];
      uVar18 = (*local_bc)[0];
      uVar13 = paVar5->LayerN;
      if (uVar18 < uVar13) {
        paVar11 = Buffer->Data;
        pLVar16 = paVar11->Layer + uVar18;
        pLVar19 = &swap;
        for (iVar15 = 0x17; iVar15 != 0; iVar15 = iVar15 + -1) {
          pLVar19->Name = pLVar16->Name;
          pLVar16 = (LayerType *)((int)pLVar16 + (uint)bVar21 * -8 + 4);
          pLVar19 = (LayerType *)((int)pLVar19 + (uint)bVar21 * -8 + 4);
        }
        if (uVar13 <= local_b8) {
          pCVar12 = (pPVar10->LayerGroups).Entries[iVar9] + local_c4 + 1;
          do {
            local_b8 = *pCVar12;
            local_c4 = local_c4 + 1;
            pCVar12 = pCVar12 + 1;
          } while (uVar13 <= local_b8);
        }
        pLVar16 = paVar11->Layer + local_b8;
        pLVar19 = paVar11->Layer + uVar18;
        for (iVar15 = 0x17; iVar15 != 0; iVar15 = iVar15 + -1) {
          pLVar19->Name = pLVar16->Name;
          pLVar16 = (LayerType *)((int)pLVar16 + ((uint)bVar21 * -2 + 1) * 4);
          pLVar19 = (LayerType *)((int)pLVar19 + (uint)bVar21 * -8 + 4);
        }
        CVar4 = paVar11->ElementN;
        pLVar16 = &swap;
        pLVar19 = paVar11->Layer + local_b8;
        for (iVar15 = 0x17; iVar15 != 0; iVar15 = iVar15 + -1) {
          pLVar19->Name = pLVar16->Name;
          pLVar16 = (LayerType *)((int)pLVar16 + (uint)bVar21 * -8 + 4);
          pLVar19 = (LayerType *)((int)pLVar19 + ((uint)bVar21 * -2 + 1) * 4);
        }
        local_a0 = CVar4 - 1;
        local_c4 = local_c4 + 1;
        if (local_a0 != -1) {
          local_88._0_1_ = (sbyte)((uVar18 & 1) << 2);
          sVar8 = (sbyte)((local_b8 & 1) << 2);
          uVar13 = 0xf << sVar8;
          local_94 = (byte)(0xf << (sbyte)local_88);
          local_90 = (byte)uVar13;
          local_9c = &paVar11->Element[CVar4 - 1].PinN;
          do {
            uVar7 = *local_9c;
            if (uVar7 != 0) {
              uVar20 = 0;
              puVar17 = (((PinTypePtr)local_9c[8])->Flags).t + (uVar18 >> 1);
              puVar14 = (((PinTypePtr)local_9c[8])->Flags).t + (local_b8 >> 1);
              do {
                bVar1 = *puVar17;
                *puVar17 = ((uVar13 & *puVar14) != 0) << (sbyte)local_88 | ~local_94 & bVar1;
                uVar20 = uVar20 + 1;
                puVar17 = puVar17 + 0x4c;
                *puVar14 = ((0xf << (sbyte)local_88 & (uint)bVar1) != 0) << sVar8 |
                           ~local_90 & *puVar14;
                puVar14 = puVar14 + 0x4c;
              } while (uVar20 < uVar7);
            }
            local_a0 = local_a0 + -1;
            local_9c = local_9c + -0x4b;
          } while (local_a0 != -1);
        }
        uVar13 = paVar11->ViaN;
        if (uVar13 != 0) {
          uVar20 = 0;
          local_88._0_1_ = (sbyte)((uVar18 & 1) << 2);
          sVar8 = (sbyte)((local_b8 & 1) << 2);
          uVar7 = 0xf << sVar8;
          puVar17 = (paVar11->Via->Flags).t + (uVar18 >> 1);
          puVar14 = (paVar11->Via->Flags).t + (local_b8 >> 1);
          do {
            bVar1 = *puVar17;
            *puVar17 = ((uVar7 & *puVar14) != 0) << (sbyte)local_88 |
                       ~(byte)(0xf << (sbyte)local_88) & bVar1;
            uVar20 = uVar20 + 1;
            puVar17 = puVar17 + 0x4c;
            *puVar14 = ((0xf << (sbyte)local_88 & (uint)bVar1) != 0) << sVar8 |
                       ~(byte)uVar7 & *puVar14;
            puVar14 = puVar14 + 0x4c;
          } while (uVar20 < uVar13);
        }
      }
      local_c0 = local_c0 + 1;
      local_bc = (Cardinal (*) [18])(*local_bc + 1);
    } while (local_c0 != CVar3);
  }
  SetBufferBoundingBox(Buffer);
  return;
}



// WARNING: Unknown calling convention

void SwapBuffers(void)

{
  BufferType *Buffer;
  BufferTypePtr pBVar1;
  
  Buffer = Buffers;
  do {
    pBVar1 = Buffer + 1;
    SwapBuffer(Buffer);
    Buffer = pBVar1;
  } while (pBVar1 != (BufferTypePtr)&Progname);
  SetCrosshairRangeToBuffer();
  return;
}



// WARNING: Unknown calling convention

void FreeRotateBuffer(BufferTypePtr Buffer,double Angle)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  double dVar5;
  int iVar6;
  PointTypePtr pPVar7;
  PCBTypePtr pPVar8;
  Cardinal n_2;
  int iVar9;
  DataTypePtr Data;
  PinTypePtr via;
  PinTypePtr Pin;
  Cardinal n_1;
  int iVar10;
  LineTypePtr line;
  LineTypePtr Line;
  PolygonTypePtr polygon;
  ArcTypePtr arc;
  BoxType *box;
  PolygonTypePtr Polygon;
  uint uVar11;
  Cardinal n;
  LayerTypePtr layer;
  LayerTypePtr layer_1;
  LayerType *pLVar12;
  Cardinal sn;
  uint local_68;
  uint local_4c;
  LayerType *local_3c;
  double local_2c;
  double local_24 [2];
  
  sincos((Angle * 3.141592653589793) / 180.0,local_24,&local_2c);
  Data = Buffer->Data;
  if (Data->ViaN != 0) {
    uVar11 = 0;
    local_4c = Data->ViaN;
    do {
      Pin = Data->Via + uVar11;
      r_delete_entry(Data->via_tree,&Pin->BoundingBox);
      iVar10 = Buffer->Y;
      dVar5 = (double)(Pin->X - Buffer->X);
      dVar4 = (double)(Pin->Y - iVar10);
      Pin->X = (int)ROUND((double)Buffer->X + local_24[0] * dVar4 + local_2c * dVar5);
      Pin->Y = (int)ROUND((double)iVar10 + (dVar4 * local_2c - dVar5 * local_24[0]));
      SetPinBoundingBox(Pin);
      r_insert_entry(Buffer->Data->via_tree,&Pin->BoundingBox,0);
      Data = Buffer->Data;
      uVar1 = Data->ViaN;
      if (uVar1 == 0) break;
      uVar11 = (uVar1 + 1 + uVar11) - local_4c;
      local_4c = uVar1;
    } while (uVar11 < uVar1);
  }
  iVar10 = Data->ElementN - 1;
  if (iVar10 != -1) {
    iVar6 = Data->ElementN * 300;
    while( true ) {
      iVar10 = iVar10 + -1;
      FreeRotateElementLowLevel
                (Data,(ElementTypePtr)(Data->Element[-1].Flags.t + iVar6 + -0x18),Buffer->X,
                 Buffer->Y,local_2c,local_24[0],Angle);
      if (iVar10 == -1) break;
      Data = Buffer->Data;
      iVar6 = iVar6 + -300;
    }
    Data = Buffer->Data;
  }
  pLVar12 = Data->Layer;
  if (PCB->Data->LayerN != -2) {
    uVar11 = 0;
    pPVar8 = PCB;
    while( true ) {
      iVar10 = pLVar12->LineN - 1;
      if (iVar10 != -1) {
        iVar6 = pLVar12->LineN * 0x58;
        do {
          Line = (LineTypePtr)(pLVar12->Line[-1].Flags.t + iVar6 + -0x18);
          r_delete_entry(pLVar12->line_tree,(BoxType *)Line);
          iVar9 = Buffer->Y;
          iVar2 = Buffer->X;
          dVar4 = (double)((Line->Point1).X - iVar2);
          dVar5 = (double)((Line->Point1).Y - iVar9);
          (Line->Point1).X = (int)ROUND(local_24[0] * dVar5 + local_2c * dVar4 + (double)iVar2);
          iVar3 = (Line->Point2).X;
          (Line->Point1).Y = (int)ROUND((dVar5 * local_2c - dVar4 * local_24[0]) + (double)iVar9);
          dVar5 = (double)(iVar3 - iVar2);
          dVar4 = (double)((Line->Point2).Y - iVar9);
          (Line->Point2).X = (int)ROUND(local_24[0] * dVar4 + local_2c * dVar5 + (double)iVar2);
          (Line->Point2).Y = (int)ROUND((double)iVar9 + (dVar4 * local_2c - dVar5 * local_24[0]));
          SetLineBoundingBox(Line);
          r_insert_entry(pLVar12->line_tree,(BoxType *)Line,0);
          iVar10 = iVar10 + -1;
          pPVar8 = PCB;
          iVar6 = iVar6 + -0x58;
        } while (iVar10 != -1);
      }
      uVar11 = uVar11 + 1;
      iVar10 = pPVar8->Data->LayerN;
      if (iVar10 + 2U <= uVar11) break;
      pLVar12 = pLVar12 + 1;
    }
    pLVar12 = Buffer->Data->Layer;
    if (iVar10 != -2) {
      local_68 = 0;
      while( true ) {
        iVar10 = pLVar12->ArcN - 1;
        if (iVar10 != -1) {
          iVar6 = pLVar12->ArcN * 0x44;
          do {
            box = (BoxType *)(pLVar12->Arc[-1].Flags.t + iVar6 + -0x18);
            r_delete_entry(pLVar12->arc_tree,box);
            iVar9 = Buffer->Y;
            dVar5 = (double)(box[3].Y1 - Buffer->X);
            dVar4 = (double)(box[3].X2 - iVar9);
            box[3].Y1 = (int)ROUND((double)Buffer->X + local_24[0] * dVar4 + local_2c * dVar5);
            box[3].X2 = (int)ROUND((double)iVar9 + (dVar4 * local_2c - dVar5 * local_24[0]));
            box[3].Y2 = (int)ROUND((double)box[3].Y2 + Angle) % 0x168;
            r_insert_entry(pLVar12->arc_tree,box,0);
            iVar10 = iVar10 + -1;
            pPVar8 = PCB;
            iVar6 = iVar6 + -0x44;
          } while (iVar10 != -1);
        }
        local_68 = local_68 + 1;
        iVar10 = pPVar8->Data->LayerN;
        if (iVar10 + 2U <= local_68) break;
        pLVar12 = pLVar12 + 1;
      }
      local_3c = Buffer->Data->Layer;
      if (iVar10 != -2) {
        local_68 = 0;
        while( true ) {
          iVar10 = local_3c->PolygonN - 1;
          if (iVar10 != -1) {
            iVar6 = local_3c->PolygonN * 0x3c;
            do {
              Polygon = (PolygonTypePtr)(local_3c->Polygon[-1].Flags.t + iVar6 + -0x18);
              r_delete_entry(local_3c->polygon_tree,(BoxType *)Polygon);
              iVar9 = Polygon->PointN - 1;
              if (iVar9 != -1) {
                pPVar7 = Polygon->Points + (Polygon->PointN - 1);
                iVar2 = Buffer->Y;
                iVar3 = Buffer->X;
                do {
                  iVar9 = iVar9 + -1;
                  dVar4 = (double)(pPVar7->X - iVar3);
                  dVar5 = (double)(pPVar7->Y - iVar2);
                  pPVar7->X = (int)ROUND(local_24[0] * dVar5 + local_2c * dVar4 + (double)iVar3);
                  pPVar7->Y = (int)ROUND((dVar5 * local_2c - dVar4 * local_24[0]) + (double)iVar2);
                  pPVar7 = pPVar7 + -1;
                } while (iVar9 != -1);
              }
              SetPolygonBoundingBox(Polygon);
              r_insert_entry(local_3c->polygon_tree,(BoxType *)Polygon,0);
              iVar10 = iVar10 + -1;
              pPVar8 = PCB;
              iVar6 = iVar6 + -0x3c;
            } while (iVar10 != -1);
          }
          local_68 = local_68 + 1;
          if (pPVar8->Data->LayerN + 2U <= local_68) break;
          local_3c = local_3c + 1;
        }
      }
    }
  }
  SetBufferBoundingBox(Buffer);
  return;
}



// WARNING: Unknown calling convention

int ActionFreeRotateBuffer(int argc,char **argv,int x,int y)

{
  double Angle;
  
  HideCrosshair('\0');
  Angle = strtod(*argv,(char **)0x0);
  FreeRotateBuffer(Buffers + Settings.BufferNumber,Angle);
  RestoreCrosshair('\0');
  return 0;
}



// WARNING: Unknown calling convention

Boolean ConvertBufferToElement(BufferTypePtr Buffer)

{
  Cardinal *pCVar1;
  LocationType TextY;
  LocationType TextX;
  PinTypePtr paVar2;
  uint uVar3;
  Cardinal CVar4;
  LineTypePtr pLVar5;
  PolygonTypePtr ppVar6;
  ArcTypePtr paVar7;
  FlagType Flags;
  FlagType Flags_00;
  FlagType Flags_01;
  FlagType Flags_02;
  FlagType Flags_03;
  FlagType Flags_04;
  FlagType TextFlags;
  bool bVar8;
  bool bVar9;
  bool bVar10;
  Boolean BVar11;
  ElementTypePtr Element_00;
  DataTypePtr paVar12;
  PCBType *pPVar13;
  int *piVar14;
  ArcTypePtr arc;
  char *pcVar15;
  Cardinal sn;
  Cardinal group;
  uint uVar16;
  PointType *pPVar17;
  int x1;
  PolygonTypePtr polygon;
  int iVar18;
  Cardinal number;
  PinTypePtr via;
  LineTypePtr line;
  int y1;
  int *piVar19;
  int iVar20;
  LineTypePtr line_1;
  Cardinal n_3;
  uint uVar21;
  Cardinal n;
  int iVar22;
  Cardinal n_1;
  int t;
  int best;
  int iVar23;
  int iVar24;
  Cardinal n_4;
  Cardinal n_2;
  int iVar25;
  Cardinal pin_n;
  LineTypePtr line_2;
  ElementTypePtr Element;
  int in_GS_OFFSET;
  byte bVar26;
  int local_fc;
  DataTypePtr local_ec;
  uint local_e4;
  int local_d4;
  DataTypePtr local_d0;
  PointType temp [4];
  undefined local_7c [4];
  undefined4 local_78;
  undefined4 local_74;
  LocationType local_70;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  char num [8];
  int local_20;
  
  bVar26 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (Buffer->Data->pcb == (PCBType *)0x0) {
    Buffer->Data->pcb = PCB;
  }
  MakeFlags(~-(uint)(Settings.ShowSolderSide == '\0') & 0x80);
  TextY = Buffers[Settings.BufferNumber].Y;
  TextX = Buffers[Settings.BufferNumber].X;
  MakeFlags(0);
  Flags.t[0] = (undefined)local_3c;
  Flags.t[1] = local_3c._1_1_;
  Flags.t[2] = local_3c._2_1_;
  Flags.t[3] = local_3c._3_1_;
  Flags.f = local_40;
  Flags.t[4] = (undefined)local_38;
  Flags.t[5] = local_38._1_1_;
  Flags.t[6] = local_38._2_1_;
  Flags.t[7] = local_38._3_1_;
  TextFlags.t[0] = (undefined)local_30;
  TextFlags.t[1] = local_30._1_1_;
  TextFlags.t[2] = local_30._2_1_;
  TextFlags.t[3] = local_30._3_1_;
  TextFlags.f = local_34;
  TextFlags.t[4] = (undefined)local_2c;
  TextFlags.t[5] = local_2c._1_1_;
  TextFlags.t[6] = local_2c._2_1_;
  TextFlags.t[7] = local_2c._3_1_;
  Element_00 = CreateNewElement(PCB->Data,(ElementTypePtr)0x0,&PCB->Font,Flags,(char *)0x0,
                                (char *)0x0,(char *)0x0,TextX,TextY,'\0',100,TextFlags,'\0');
  BVar11 = '\0';
  if (Element_00 != (ElementTypePtr)0x0) {
    iVar25 = 1;
    bVar8 = false;
    local_fc = 1;
    paVar12 = Buffer->Data;
    uVar21 = 0;
    local_d0 = (DataTypePtr)paVar12->ViaN;
    if (paVar12->ViaN != 0) {
      do {
        paVar2 = paVar12->Via;
        if (paVar2[uVar21].Mask < paVar2[uVar21].Thickness) {
          paVar2[uVar21].Mask = paVar2[uVar21].Thickness + 600;
        }
        if (paVar2[uVar21].Name == (char *)0x0) {
          __sprintf_chk(num,1,8,&DAT_081538d1,iVar25);
          MaskFlags(paVar2[uVar21].Flags,0x246);
          Flags_01.t[0] = (undefined)local_54;
          Flags_01.t[1] = local_54._1_1_;
          Flags_01.t[2] = local_54._2_1_;
          Flags_01.t[3] = local_54._3_1_;
          Flags_01.f = local_58;
          Flags_01.t[4] = (undefined)local_50;
          Flags_01.t[5] = local_50._1_1_;
          Flags_01.t[6] = local_50._2_1_;
          Flags_01.t[7] = local_50._3_1_;
          CreateNewPin(Element_00,paVar2[uVar21].X,paVar2[uVar21].Y,paVar2[uVar21].Thickness,
                       paVar2[uVar21].Clearance,paVar2[uVar21].Mask,paVar2[uVar21].DrillingHole,
                       (char *)0x0,num,Flags_01);
          paVar12 = Buffer->Data;
          uVar3 = paVar12->ViaN;
          iVar25 = iVar25 + 1;
        }
        else {
          MaskFlags(paVar2[uVar21].Flags,0x246);
          Flags_00.t[0] = (undefined)local_48;
          Flags_00.t[1] = local_48._1_1_;
          Flags_00.t[2] = local_48._2_1_;
          Flags_00.t[3] = local_48._3_1_;
          Flags_00.f = local_4c;
          Flags_00.t[4] = (undefined)local_44;
          Flags_00.t[5] = local_44._1_1_;
          Flags_00.t[6] = local_44._2_1_;
          Flags_00.t[7] = local_44._3_1_;
          CreateNewPin(Element_00,paVar2[uVar21].X,paVar2[uVar21].Y,paVar2[uVar21].Thickness,
                       paVar2[uVar21].Clearance,paVar2[uVar21].Mask,paVar2[uVar21].DrillingHole,
                       (char *)0x0,paVar2[uVar21].Name,Flags_00);
          paVar12 = Buffer->Data;
          uVar3 = paVar12->ViaN;
        }
      } while ((uVar3 != 0) &&
              (uVar21 = (uVar3 + 1 + uVar21) - (int)local_d0, local_d0 = (DataTypePtr)uVar3,
              uVar21 < uVar3));
      bVar8 = true;
      local_fc = iVar25;
    }
    iVar25 = GetLayerGroupNumberByNumber
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN);
    local_ec = Buffer->Data;
    pPVar13 = local_ec->pcb;
    if ((pPVar13->LayerGroups).Number[iVar25] == 0) {
      bVar10 = false;
      uVar21 = PCB->Data->LayerN;
    }
    else {
      local_e4 = 0;
      bVar10 = false;
      uVar21 = PCB->Data->LayerN;
      do {
        uVar3 = (pPVar13->LayerGroups).Entries[iVar25][local_e4];
        if (uVar3 < uVar21) {
          CVar4 = local_ec->Layer[uVar3].LineN;
          iVar22 = CVar4 - 1;
          if (iVar22 != -1) {
            iVar20 = local_fc;
            iVar24 = CVar4 * 0x58;
            do {
              pLVar5 = local_ec->Layer[uVar3].Line;
              __sprintf_chk(num,1,8,&DAT_081538d1,iVar20);
              MakeFlags(~-(uint)(Settings.ShowSolderSide == '\0') & 0x80);
              iVar18 = *(int *)((int)(&pLVar5[-1].Flags + 1) + iVar24 + 8);
              pcVar15 = *(char **)((int)(&pLVar5[-1].Flags + 5) + iVar24 + 4);
              iVar23 = *(int *)((int)(&pLVar5[-1].Flags + 1) + iVar24 + 4);
              if (pcVar15 == (char *)0x0) {
                pcVar15 = num;
              }
              iVar22 = iVar22 + -1;
              Flags_02.t[0] = (undefined)local_60;
              Flags_02.t[1] = local_60._1_1_;
              Flags_02.t[2] = local_60._2_1_;
              Flags_02.t[3] = local_60._3_1_;
              Flags_02.f = local_64;
              Flags_02.t[4] = (undefined)local_5c;
              Flags_02.t[5] = local_5c._1_1_;
              Flags_02.t[6] = local_5c._2_1_;
              Flags_02.t[7] = local_5c._3_1_;
              CreateNewPad(Element_00,
                           *(LocationType *)
                            ((int)&((PointType *)(&pLVar5[-1].Flags + 2))->Y + iVar24 + -4),
                           *(LocationType *)
                            ((int)&((PointType *)(&pLVar5[-1].Flags + 2))->Y + iVar24),
                           *(LocationType *)((int)(&pLVar5[-1].Flags + 3) + iVar24 + 8),
                           *(LocationType *)((int)(&pLVar5[-1].Flags + 4) + iVar24),iVar23,iVar18,
                           iVar18 + iVar23,(char *)0x0,pcVar15,Flags_02);
              iVar20 = iVar20 + 1;
              iVar24 = iVar24 + -0x58;
            } while (iVar22 != -1);
            local_fc = local_fc + CVar4;
            bVar8 = true;
          }
          CVar4 = local_ec->Layer[uVar3].PolygonN;
          local_d0 = (DataTypePtr)(CVar4 - 1);
          if (local_d0 == (DataTypePtr)0xffffffff) {
            uVar21 = PCB->Data->LayerN;
            local_ec = Buffer->Data;
          }
          else {
            iVar22 = CVar4 * 0x3c;
            do {
              local_d4 = iVar22 + -0x3c;
              ppVar6 = local_ec->Layer[uVar3].Polygon;
              if (*(int *)((int)(&ppVar6[-1].Flags + 1) + iVar22 + 4) == 4) {
                piVar14 = *(int **)((int)(&ppVar6[-1].Flags + 3) + iVar22);
                uVar21 = 0;
                uVar16 = 1;
                piVar19 = piVar14;
                do {
                  if ((piVar19[5] < piVar14[uVar21 * 5]) || (piVar19[6] < (piVar14 + uVar21 * 5)[1])
                     ) {
                    uVar21 = uVar16;
                  }
                  uVar16 = uVar16 + 1;
                  piVar19 = piVar19 + 5;
                } while (uVar16 != 4);
                pPVar17 = temp;
                do {
                  uVar16 = uVar21 & 3;
                  pPVar17->X = piVar14[uVar16 * 5];
                  pPVar17->Y = piVar14[uVar16 * 5 + 1];
                  pPVar17->X2 = piVar14[uVar16 * 5 + 2];
                  pPVar17->Y2 = piVar14[uVar16 * 5 + 3];
                  pPVar17->ID = piVar14[uVar16 * 5 + 4];
                  pPVar17 = pPVar17 + 1;
                  uVar21 = uVar21 + 1;
                } while (pPVar17 != (PointType *)local_7c);
                if (temp[0].X == temp[1].X) {
                  pPVar17 = temp;
                  for (iVar20 = 0x14; iVar20 != 0; iVar20 = iVar20 + -1) {
                    *piVar14 = pPVar17->X;
                    pPVar17 = (PointType *)((int)pPVar17 + (uint)bVar26 * -8 + 4);
                    piVar14 = piVar14 + (uint)bVar26 * -2 + 1;
                  }
                  piVar14 = *(int **)((int)(&ppVar6[-1].Flags + 3) + iVar22);
                }
                else {
                  *piVar14 = temp[0].X;
                  piVar14[1] = temp[0].Y;
                  piVar14[2] = temp[0].X2;
                  piVar14[3] = temp[0].Y2;
                  piVar14[4] = temp[0].ID;
                  piVar14[5] = temp[3].X;
                  piVar14[6] = temp[3].Y;
                  piVar14[7] = temp[3].X2;
                  piVar14[8] = temp[3].Y2;
                  piVar14[9] = temp[3].ID;
                  piVar14[10] = temp[2].X;
                  piVar14[0xb] = temp[2].Y;
                  piVar14[0xc] = temp[2].X2;
                  piVar14[0xd] = temp[2].Y2;
                  piVar14[0xe] = temp[2].ID;
                  piVar14[0xf] = temp[1].X;
                  piVar14[0x10] = temp[1].Y;
                  piVar14[0x11] = temp[1].X2;
                  piVar14[0x12] = temp[1].Y2;
                  piVar14[0x13] = temp[1].ID;
                }
                iVar22 = *piVar14;
                if ((((iVar22 != piVar14[5]) || (piVar14[6] != piVar14[0xb])) ||
                    (piVar14[10] != piVar14[0xf])) || (iVar20 = piVar14[0x10], iVar20 != piVar14[1])
                   ) goto LAB_08078f08;
                iVar18 = piVar14[6] - iVar20;
                iVar23 = piVar14[10] - iVar22;
                iVar24 = iVar23;
                if (iVar18 <= iVar23) {
                  iVar24 = iVar18;
                }
                iVar22 = iVar22 + iVar24 / 2;
                iVar20 = iVar20 + iVar24 / 2;
                __sprintf_chk(num,1,8,&DAT_081538d1,local_fc);
                local_fc = local_fc + 1;
                MakeFlags((-(uint)(Settings.ShowSolderSide == '\0') & 0xffffff80) + 0x180);
                Flags_03.t[0] = (undefined)local_6c;
                Flags_03.t[1] = local_6c._1_1_;
                Flags_03.t[2] = local_6c._2_1_;
                Flags_03.t[3] = local_6c._3_1_;
                Flags_03.f = local_70;
                Flags_03.t[4] = (undefined)local_68;
                Flags_03.t[5] = local_68._1_1_;
                Flags_03.t[6] = local_68._2_1_;
                Flags_03.t[7] = local_68._3_1_;
                CreateNewPad(Element_00,iVar22,iVar20,(iVar23 - iVar24) + iVar22,
                             (iVar18 - iVar24) + iVar20,iVar24,Settings.Keepaway * 2,
                             iVar24 + Settings.Keepaway,(char *)0x0,num,Flags_03);
                bVar8 = true;
              }
              else {
LAB_08078f08:
                bVar10 = true;
              }
              local_d0 = (DataTypePtr)((int)local_d0 + -1);
              iVar22 = local_d4;
            } while (local_d0 != (DataTypePtr)0xffffffff);
            local_ec = Buffer->Data;
            uVar21 = PCB->Data->LayerN;
          }
        }
        local_e4 = local_e4 + 1;
        pPVar13 = local_ec->pcb;
        pCVar1 = (pPVar13->LayerGroups).Number + iVar25;
      } while (local_e4 <= *pCVar1 && *pCVar1 != local_e4);
    }
    iVar25 = GetLayerGroupNumberByNumber(uVar21 + (Settings.ShowSolderSide != '\0'));
    local_ec = Buffer->Data;
    pPVar13 = local_ec->pcb;
    if ((pPVar13->LayerGroups).Number[iVar25] == 0) {
      local_d0 = PCB->Data;
      uVar21 = local_d0->LayerN;
    }
    else {
      local_d0 = PCB->Data;
      local_e4 = 0;
      uVar21 = local_d0->LayerN;
      do {
        uVar3 = (pPVar13->LayerGroups).Entries[iVar25][local_e4];
        if (uVar3 < uVar21) {
          CVar4 = local_ec->Layer[uVar3].LineN;
          n_2 = CVar4 - 1;
          if (n_2 != 0xffffffff) {
            bVar9 = false;
            iVar22 = local_fc;
            iVar20 = CVar4 * 0x58;
            do {
              pLVar5 = local_ec->Layer[uVar3].Line;
              __sprintf_chk(num,1,8,&DAT_081538d1,iVar22);
              MakeFlags(-(uint)(Settings.ShowSolderSide == '\0') & 0x80);
              iVar24 = *(int *)((int)(&pLVar5[-1].Flags + 1) + iVar20 + 8);
              pcVar15 = *(char **)((int)(&pLVar5[-1].Flags + 5) + iVar20 + 4);
              iVar18 = *(int *)((int)(&pLVar5[-1].Flags + 1) + iVar20 + 4);
              if (pcVar15 == (char *)0x0) {
                pcVar15 = num;
              }
              Flags_04.t[0] = (undefined)local_78;
              Flags_04.t[1] = local_78._1_1_;
              Flags_04.t[2] = local_78._2_1_;
              Flags_04.t[3] = local_78._3_1_;
              Flags_04.f = (ulong)local_7c;
              Flags_04.t[4] = (undefined)local_74;
              Flags_04.t[5] = local_74._1_1_;
              Flags_04.t[6] = local_74._2_1_;
              Flags_04.t[7] = local_74._3_1_;
              CreateNewPad(Element_00,
                           *(LocationType *)
                            ((int)&((PointType *)(&pLVar5[-1].Flags + 2))->Y + iVar20 + -4),
                           *(LocationType *)
                            ((int)&((PointType *)(&pLVar5[-1].Flags + 2))->Y + iVar20),
                           *(LocationType *)((int)(&pLVar5[-1].Flags + 3) + iVar20 + 8),
                           *(LocationType *)((int)(&pLVar5[-1].Flags + 4) + iVar20),iVar18,iVar24,
                           iVar24 + iVar18,(char *)0x0,pcVar15,Flags_04);
              if ((!bVar9) && (!bVar8)) {
                Message(
                       "Warning: All of the pads are on the opposite\nside from the component - that\'s probably not what\nyou wanted\n"
                       );
                bVar9 = true;
              }
              n_2 = n_2 - 1;
              bVar8 = true;
              iVar22 = iVar22 + 1;
              iVar20 = iVar20 + -0x58;
            } while (n_2 != 0xffffffff);
            local_fc = local_fc + CVar4;
            local_d0 = PCB->Data;
            local_ec = Buffer->Data;
            uVar21 = local_d0->LayerN;
          }
        }
        pPVar13 = local_ec->pcb;
        local_e4 = local_e4 + 1;
        pCVar1 = (pPVar13->LayerGroups).Number + iVar25;
      } while (local_e4 <= *pCVar1 && *pCVar1 != local_e4);
    }
    iVar22 = uVar21 + (Settings.ShowSolderSide == '\0');
    CVar4 = local_ec->Layer[iVar22].LineN;
    iVar25 = CVar4 - 1;
    if (iVar25 != -1) {
      iVar22 = CVar4 * 0x58;
      while( true ) {
        pLVar5 = local_ec->Layer[(Settings.ShowSolderSide == '\0') + uVar21].Line;
        pcVar15 = *(char **)((int)(&pLVar5->Flags + -2) + iVar22);
        if ((pcVar15 != (char *)0x0) && (Element_00->Name[1].TextString == (char *)0x0)) {
          pcVar15 = MyStrdup(pcVar15,"ConvertBufferToElement");
          Element_00->Name[1].TextString = pcVar15;
        }
        iVar25 = iVar25 + -1;
        CreateNewLineInElement
                  (Element_00,*(LocationType *)((pLVar5->Flags).t + iVar22 + -0x44),
                   *(LocationType *)((int)(&pLVar5->Flags + -5) + iVar22),
                   *(LocationType *)((pLVar5->Flags).t + iVar22 + -0x30),
                   *(LocationType *)((pLVar5->Flags).t + iVar22 + -0x2c),
                   *(BDimension *)((int)(&pLVar5->Flags + -6) + iVar22));
        if (iVar25 == -1) break;
        local_ec = Buffer->Data;
        uVar21 = PCB->Data->LayerN;
        iVar22 = iVar22 + -0x58;
      }
      bVar8 = true;
      local_d0 = PCB->Data;
      uVar21 = local_d0->LayerN;
      iVar22 = (Settings.ShowSolderSide == '\0') + uVar21;
      local_ec = Buffer->Data;
    }
    CVar4 = local_ec->Layer[iVar22].ArcN;
    iVar25 = CVar4 - 1;
    if (iVar25 == -1) {
      if (!bVar8) {
        DestroyObject(local_d0,2,Element_00,Element_00,Element_00);
        Message("There was nothing to convert!\nElements must have some silk, pads or pins.\n");
        BVar11 = '\0';
        goto LAB_080791ee;
      }
    }
    else {
      iVar22 = CVar4 * 0x44;
      while( true ) {
        iVar25 = iVar25 + -1;
        paVar7 = local_ec->Layer[(Settings.ShowSolderSide == '\0') + uVar21].Arc;
        CreateNewArcInElement
                  (Element_00,*(LocationType *)((int)(&paVar7->Flags + -3) + iVar22),
                   *(LocationType *)((paVar7->Flags).t + iVar22 + -0x24),
                   *(BDimension *)((paVar7->Flags).t + iVar22 + -0x30),
                   *(BDimension *)((paVar7->Flags).t + iVar22 + -0x2c),
                   *(int *)((paVar7->Flags).t + iVar22 + -0x20),
                   *(int *)((int)(&paVar7->Flags + -2) + iVar22),
                   *(BDimension *)((paVar7->Flags).t + iVar22 + -0x38));
        if (iVar25 == -1) break;
        local_ec = Buffer->Data;
        uVar21 = PCB->Data->LayerN;
        iVar22 = iVar22 + -0x44;
      }
    }
    if (bVar10) {
      Message(
             "There were polygons that can\'t be made into pins!\nSo they were not included in the element\n"
             );
    }
    Element_00->MarkX = Buffer->X;
    Element_00->MarkY = Buffer->Y;
    if (Settings.ShowSolderSide != '\0') {
      (Element_00->Flags).f = (Element_00->Flags).f | 0x80;
    }
    SetElementBoundingBox(PCB->Data,Element_00,&PCB->Font);
    ClearBuffer(Buffer);
    MoveObjectToBuffer(Buffer->Data,PCB->Data,2,Element_00,Element_00,Element_00);
    SetBufferBoundingBox(Buffer);
    BVar11 = '\x01';
  }
LAB_080791ee:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar11;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean LoadElementToBuffer(BufferTypePtr Buffer,char *Name,Boolean FromFile)

{
  ElementTypePtr paVar1;
  int iVar2;
  DataTypePtr Data;
  ElementTypePtr element;
  
  ClearBuffer(Buffer);
  if (FromFile == '\0') {
    iVar2 = ParseLibraryEntry(Buffer->Data,Name);
    if ((iVar2 == 0) && (Data = Buffer->Data, Data->ElementN != 0)) {
      paVar1 = Data->Element;
      if (Settings.ShowSolderSide != '\0') {
        MirrorElementCoordinates(Data,paVar1,0);
        Data = Buffer->Data;
      }
      SetElementBoundingBox(Data,paVar1,&PCB->Font);
      Buffer->X = paVar1->MarkX;
      Buffer->Y = paVar1->MarkY;
      SetBufferBoundingBox(Buffer);
      return '\x01';
    }
  }
  else {
    iVar2 = ParseElementFile(Buffer->Data,Name);
    if (iVar2 == 0) {
      if (Settings.ShowSolderSide != '\0') {
        SwapBuffer(Buffer);
      }
      SetBufferBoundingBox(Buffer);
      if (Buffer->Data->ElementN != 0) {
        paVar1 = Buffer->Data->Element;
        Buffer->X = paVar1->MarkX;
        Buffer->Y = paVar1->MarkY;
        return '\x01';
      }
      Buffer->X = 0;
      Buffer->Y = 0;
      return '\x01';
    }
  }
  ClearBuffer(Buffer);
  return '\0';
}



// WARNING: Unknown calling convention

void * ChangeLineName(LayerTypePtr Layer,LineTypePtr Line)

{
  char *pcVar1;
  char *old;
  
  pcVar1 = Line->Number;
  Line->Number = NewName;
  return pcVar1;
}



// WARNING: Unknown calling convention

void ChangePCBSize(BDimension Width,BDimension Height)

{
  PCBTypePtr pPVar1;
  LocationType MaxX;
  LocationType MaxY;
  
  pPVar1 = PCB;
  PCB->MaxWidth = Width;
  pPVar1->MaxHeight = Height;
  if (Settings.Mode == 5) {
    MaxY = Height + (Buffers[Settings.BufferNumber].Y -
                    Buffers[Settings.BufferNumber].BoundingBox.Y2);
    if (MaxY < 0) {
      MaxY = 0;
    }
    MaxX = Width + (Buffers[Settings.BufferNumber].X - Buffers[Settings.BufferNumber].BoundingBox.X2
                   );
    if (MaxX < 0) {
      MaxX = 0;
    }
    SetCrosshairRange(Buffers[Settings.BufferNumber].X -
                      Buffers[Settings.BufferNumber].BoundingBox.X1,
                      Buffers[Settings.BufferNumber].Y -
                      Buffers[Settings.BufferNumber].BoundingBox.Y1,MaxX,MaxY);
  }
  else {
    SetCrosshairRange(0,0,Width,Height);
  }
  hid_action("PCBChanged");
  return;
}



// WARNING: Unknown calling convention

Boolean ChangeLayerName(LayerTypePtr Layer,char *Name)

{
  LayerType *pLVar1;
  
  if (PCB->SilkActive == '\0') {
    pLVar1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  pLVar1->Name = Name;
  hid_action("LayersChanged");
  return '\x01';
}



// WARNING: Unknown calling convention

Boolean ChangeLayoutName(char *Name)

{
  PCB->Name = Name;
  hid_action("PCBChanged");
  return '\x01';
}



// WARNING: Unknown calling convention

Boolean ClrObjectOctagon(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ClrOctagonFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean SetObjectOctagon(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&SetOctagonFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean ChangeObjectOctagon(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeOctagonFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean ClrObjectSquare(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ClrSquareFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean SetObjectSquare(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&SetSquareFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean ChangeObjectSquare(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeSquareFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean ClrObjectJoin(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ClrJoinFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean SetObjectJoin(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&SetJoinFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean ChangeObjectJoin(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeJoinFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangeObjectName(int Type,void *Ptr1,void *Ptr2,void *Ptr3,char *Name)

{
  void *pvVar1;
  void *result;
  
  NewName = Name;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeNameFunctions,Type,Ptr1,Ptr2,Ptr3);
  Draw();
  return pvVar1;
}



// WARNING: Unknown calling convention

void * QueryInputAndChangeObjectName(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  int iVar1;
  uint uVar2;
  void *pvVar3;
  char *name;
  char *pcVar4;
  undefined1 *puVar5;
  uint uVar6;
  void *pvVar7;
  int in_GS_OFFSET;
  char *local_23c;
  char *local_238;
  _func_char_ptr_char_ptr_char_ptr *local_234;
  char msg [513];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pvVar3 = Ptr1;
  pvVar7 = Ptr1;
  if (Type == 0x400) {
LAB_08079e18:
    Ptr2 = pvVar3;
    uVar2 = (PCB->Flags).f;
    if ((uVar2 & 0x40) == 0) {
      uVar6 = -(uint)((uVar2 & 0x20) == 0) & 2;
    }
    else {
      uVar6 = 1;
    }
    pcVar4 = "";
    if (*(int *)((int)Ptr2 + uVar6 * 0x3c + 0x58) != 0) {
      uVar6 = 1;
      if ((uVar2 & 0x40) == 0) {
        uVar6 = -(uint)((uVar2 & 0x20) == 0) & 2;
      }
      pcVar4 = *(char **)((int)Ptr2 + uVar6 * 0x3c + 0x58);
    }
    pcVar4 = (*gui->prompt_for)("Elementname:",pcVar4);
    Type = 2;
    Ptr3 = pvVar7;
LAB_08079efd:
    if (pcVar4 != (char *)0x0) {
      pcVar4 = (char *)ChangeObjectName(Type,Ptr1,Ptr2,Ptr3,pcVar4);
      if (pcVar4 != (char *)0xffffffff) {
        AddObjectToChangeNameUndoList(Type,Ptr1,Ptr2,Ptr3,pcVar4);
        IncrementUndoSerialNumber();
      }
      Draw();
      goto LAB_08079dd9;
    }
  }
  else {
    if (Type == 4) {
      pcVar4 = *(char **)((int)Ptr2 + 0x54);
      if (pcVar4 == (char *)0x0) {
        pcVar4 = "";
      }
      pcVar4 = (*gui->prompt_for)("Linename:",pcVar4);
      goto LAB_08079efd;
    }
    if (4 < Type) {
      if (Type == 0x100) {
        puVar5 = *(undefined1 **)((int)Ptr2 + 0x40);
        if (puVar5 == (undefined1 *)0x0) {
          puVar5 = &DAT_0814741b;
        }
        __sprintf_chk(msg,1,0x201,"%s Pin Name:",puVar5);
        local_234 = gui->prompt_for;
        pcVar4 = *(char **)((int)Ptr2 + 0x3c);
      }
      else {
        if (Type != 0x200) {
          if (Type != 0x10) goto LAB_08079dd7;
          pcVar4 = *(char **)((int)Ptr2 + 0x34);
          if (pcVar4 == (char *)0x0) {
            pcVar4 = "";
          }
          pcVar4 = (*gui->prompt_for)("Enter text:",pcVar4);
          goto LAB_08079efd;
        }
        puVar5 = *(undefined1 **)((int)Ptr2 + 0x5c);
        if (puVar5 == (undefined1 *)0x0) {
          puVar5 = &DAT_0814741b;
        }
        __sprintf_chk(msg,1,0x201,"%s Pad Name:",puVar5);
        local_234 = gui->prompt_for;
        pcVar4 = *(char **)((int)Ptr2 + 0x58);
      }
      local_238 = msg;
      local_23c = "";
      if (pcVar4 == (char *)0x0) {
        pcVar4 = local_23c;
      }
      pcVar4 = (*local_234)(local_238,pcVar4);
      goto LAB_08079efd;
    }
    if (Type == 1) {
      pcVar4 = *(char **)((int)Ptr2 + 0x3c);
      if (pcVar4 == (char *)0x0) {
        pcVar4 = "";
      }
      pcVar4 = (*gui->prompt_for)("Vianame:",pcVar4);
      goto LAB_08079efd;
    }
    pvVar3 = Ptr2;
    pvVar7 = Ptr3;
    if (Type == 2) goto LAB_08079e18;
  }
LAB_08079dd7:
  Ptr3 = (void *)0x0;
LAB_08079dd9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return Ptr3;
}



// WARNING: Unknown calling convention

Boolean ChangeObjectMaskSize
                  (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,Boolean fixIt)

{
  void *pvVar1;
  Boolean change;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeMaskSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean ChangeObject2ndSize(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,
                           Boolean fixIt,Boolean incundo)

{
  Boolean change;
  void *pvVar1;
  bool bVar2;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&Change2ndSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  bVar2 = pvVar1 != (void *)0x0;
  if (bVar2) {
    Draw();
    if (incundo != '\0') {
      IncrementUndoSerialNumber();
      return bVar2;
    }
  }
  return bVar2;
}



// WARNING: Unknown calling convention

Boolean ChangeObjectThermal(int Type,void *Ptr1,void *Ptr2,void *Ptr3,int therm_type)

{
  void *pvVar1;
  Boolean change;
  
  Absolute = therm_type;
  Delta = therm_type;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeThermalFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean ChangeObjectClearSize
                  (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,Boolean fixIt)

{
  void *pvVar1;
  Boolean change;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x20) == 0) {
    pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeClearSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  }
  else {
    pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeMaskSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  }
  change = pvVar1 != (void *)0x0;
  if ((bool)change) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return change;
}



// WARNING: Unknown calling convention

Boolean ChangeObjectSize(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,
                        Boolean fixIt)

{
  void *pvVar1;
  Boolean change;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&ChangeSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return pvVar1 != (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangePinOctagon(ElementTypePtr Element,PinTypePtr Pin)

{
  PinTypePtr paVar1;
  
  paVar1 = (PinTypePtr)0x0;
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 0x20) == 0) {
    ErasePin(Pin);
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    AddObjectToFlagUndoList(0x100,Element,Pin,Pin);
    (Pin->Flags).f = (Pin->Flags).f ^ 0x800;
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    DrawPin(Pin,0);
    paVar1 = Pin;
  }
  return paVar1;
}



// WARNING: Unknown calling convention

void * ClrPinOctagon(ElementTypePtr Element,PinTypePtr Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2800) != 0x800) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinOctagon(Element,Pin);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ClrElementOctagon(ElementTypePtr Element)

{
  uint uVar1;
  void *result;
  uint uVar2;
  Cardinal n;
  Cardinal sn;
  uint uVar3;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar2 = 0;
    uVar3 = Element->PinN;
    do {
      ClrPinOctagon(Element,Element->Pin + uVar2);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return Element;
      }
      uVar2 = (uVar1 + 1 + uVar2) - uVar3;
      uVar3 = uVar1;
    } while (uVar2 < uVar1);
    return Element;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * SetPinOctagon(ElementTypePtr Element,PinTypePtr Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2800) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinOctagon(Element,Pin);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetElementOctagon(ElementTypePtr Element)

{
  uint uVar1;
  void *result;
  uint uVar2;
  Cardinal n;
  Cardinal sn;
  uint uVar3;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar2 = 0;
    uVar3 = Element->PinN;
    do {
      SetPinOctagon(Element,Element->Pin + uVar2);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return Element;
      }
      uVar2 = (uVar1 + 1 + uVar2) - uVar3;
      uVar3 = uVar1;
    } while (uVar2 < uVar1);
    return Element;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangeElementOctagon(ElementTypePtr Element)

{
  uint uVar1;
  void *result;
  uint uVar2;
  Cardinal n;
  Cardinal sn;
  uint uVar3;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar2 = 0;
    uVar3 = Element->PinN;
    do {
      ChangePinOctagon(Element,Element->Pin + uVar2);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return Element;
      }
      uVar2 = (uVar1 + 1 + uVar2) - uVar3;
      uVar3 = uVar1;
    } while (uVar2 < uVar1);
    return Element;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangePinSquare(ElementTypePtr Element,PinTypePtr Pin)

{
  PinTypePtr paVar1;
  
  paVar1 = (PinTypePtr)0x0;
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 0x20) == 0) {
    ErasePin(Pin);
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    AddObjectToFlagUndoList(0x100,Element,Pin,Pin);
    (Pin->Flags).f = (Pin->Flags).f ^ 0x100;
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    DrawPin(Pin,0);
    paVar1 = Pin;
  }
  return paVar1;
}



// WARNING: Unknown calling convention

void * ClrPinSquare(ElementTypePtr Element,PinTypePtr Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2100) != 0x100) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinSquare(Element,Pin);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetPinSquare(ElementTypePtr Element,PinTypePtr Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2100) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinSquare(Element,Pin);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ChangePinThermal(ElementTypePtr element,PinTypePtr Pin)

{
  char cVar1;
  DataTypePtr paVar2;
  byte bVar3;
  int iVar4;
  LayerType *pLVar5;
  
  AddObjectToClearPolyUndoList(0x100,element,Pin,Pin,'\0');
  if (PCB->SilkActive == '\0') {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + LayerStack[0];
  }
  else {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar2->LayerN;
  }
  RestoreToPolygon((DataType *)paVar2,1,pLVar5,Pin);
  AddObjectToFlagUndoList(0x100,element,Pin,Pin);
  if (Delta == 0) {
    iVar4 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar4 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = (char)(iVar4 >> 0x1f);
    (Pin->Flags).t[iVar4 / 2] =
         ~(byte)(0xf << ((((char)iVar4 - cVar1 & 1U) + cVar1) * '\x04' & 0x1f)) &
         (Pin->Flags).t[iVar4 / 2];
  }
  else {
    iVar4 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar4 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    bVar3 = (char)(iVar4 % 2) * '\x04';
    (Pin->Flags).t[iVar4 / 2] =
         (byte)(Delta << (bVar3 & 0x1f)) |
         ~(byte)(0xf << (bVar3 & 0x1f)) & (Pin->Flags).t[iVar4 / 2];
  }
  AddObjectToClearPolyUndoList(0x100,element,Pin,Pin,'\x01');
  if (PCB->SilkActive == '\0') {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + LayerStack[0];
  }
  else {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar2->LayerN;
  }
  ClearFromPolygon((DataType *)paVar2,1,pLVar5,Pin);
  DrawPin(Pin,0);
  return Pin;
}



// WARNING: Unknown calling convention

void * ChangeViaOctagon(PinTypePtr Via)

{
  PinTypePtr paVar1;
  
  paVar1 = (PinTypePtr)0x0;
  if ((*(byte *)((int)&(Via->Flags).f + 1) & 0x20) == 0) {
    EraseVia(Via);
    AddObjectToClearPolyUndoList(1,Via,Via,Via,'\0');
    RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
    AddObjectToFlagUndoList(1,Via,Via,Via);
    (Via->Flags).f = (Via->Flags).f ^ 0x800;
    AddObjectToClearPolyUndoList(1,Via,Via,Via,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
    DrawVia(Via,0);
    paVar1 = Via;
  }
  return paVar1;
}



// WARNING: Unknown calling convention

void * ClrViaOctagon(PinTypePtr Via)

{
  void *pvVar1;
  
  if (((Via->Flags).f & 0x2800) != 0x800) {
    return (void *)0x0;
  }
  pvVar1 = ChangeViaOctagon(Via);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetViaOctagon(PinTypePtr Via)

{
  void *pvVar1;
  
  if (((Via->Flags).f & 0x2800) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeViaOctagon(Via);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ChangeViaThermal(PinTypePtr Via)

{
  char cVar1;
  DataTypePtr paVar2;
  byte bVar3;
  int iVar4;
  LayerType *pLVar5;
  
  AddObjectToClearPolyUndoList(1,Via,Via,Via,'\0');
  if (PCB->SilkActive == '\0') {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + LayerStack[0];
  }
  else {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar2->LayerN;
  }
  RestoreToPolygon((DataType *)paVar2,1,pLVar5,Via);
  AddObjectToFlagUndoList(1,Via,Via,Via);
  if (Delta == 0) {
    iVar4 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar4 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = (char)(iVar4 >> 0x1f);
    (Via->Flags).t[iVar4 / 2] =
         (Via->Flags).t[iVar4 / 2] &
         ~(byte)(0xf << ((((char)iVar4 - cVar1 & 1U) + cVar1) * '\x04' & 0x1f));
  }
  else {
    iVar4 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar4 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = (char)(iVar4 >> 0x1f);
    bVar3 = (((char)iVar4 - cVar1 & 1U) + cVar1) * '\x04';
    (Via->Flags).t[iVar4 / 2] =
         (byte)(Delta << (bVar3 & 0x1f)) |
         ~(byte)(0xf << (bVar3 & 0x1f)) & (Via->Flags).t[iVar4 / 2];
  }
  AddObjectToClearPolyUndoList(1,Via,Via,Via,'\x01');
  if (PCB->SilkActive == '\0') {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + LayerStack[0];
  }
  else {
    paVar2 = PCB->Data;
    pLVar5 = paVar2->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar2->LayerN;
  }
  ClearFromPolygon((DataType *)paVar2,1,pLVar5,Via);
  DrawVia(Via,0);
  return Via;
}



// WARNING: Unknown calling convention

void * ChangePadSquare(ElementTypePtr Element,PadTypePtr Pad)

{
  PadTypePtr paVar1;
  
  paVar1 = (PadTypePtr)0x0;
  if ((*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0) {
    ErasePad(Pad);
    AddObjectToClearPolyUndoList(0x200,Element,Pad,Pad,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    AddObjectToFlagUndoList(0x200,Element,Pad,Pad);
    (Pad->Flags).f = (Pad->Flags).f ^ 0x100;
    AddObjectToClearPolyUndoList(0x200,Element,Pad,Pad,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    DrawPad(Pad,0);
    paVar1 = Pad;
  }
  return paVar1;
}



// WARNING: Unknown calling convention

void * ClrPadSquare(ElementTypePtr Element,PadTypePtr Pad)

{
  void *pvVar1;
  
  if (((Pad->Flags).f & 0x2100) != 0x100) {
    return (void *)0x0;
  }
  pvVar1 = ChangePadSquare(Element,Pad);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ClrElementSquare(ElementTypePtr Element)

{
  void *pvVar1;
  void *ans;
  uint uVar2;
  Cardinal n;
  uint uVar3;
  Cardinal n_1;
  Cardinal sn;
  uint uVar4;
  Cardinal sn_1;
  
  pvVar1 = (void *)0x0;
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (Element->PinN != 0) {
      uVar2 = 0;
      uVar4 = Element->PinN;
      do {
        pvVar1 = ClrPinSquare(Element,Element->Pin + uVar2);
        uVar3 = Element->PinN;
        if (uVar3 == 0) break;
        uVar2 = (uVar3 + 1 + uVar2) - uVar4;
        uVar4 = uVar3;
      } while (uVar2 < uVar3);
    }
    uVar4 = Element->PadN;
    uVar2 = uVar4;
    for (uVar3 = 0; (uVar2 != 0 && (uVar3 < uVar2)); uVar3 = uVar3 + (uVar2 == uVar4)) {
      pvVar1 = ClrPadSquare(Element,Element->Pad + uVar3);
      uVar2 = Element->PadN;
    }
  }
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetPadSquare(ElementTypePtr Element,PadTypePtr Pad)

{
  void *pvVar1;
  
  if (((Pad->Flags).f & 0x2100) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangePadSquare(Element,Pad);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetElementSquare(ElementTypePtr Element)

{
  void *pvVar1;
  void *ans;
  uint uVar2;
  Cardinal n;
  uint uVar3;
  Cardinal n_1;
  Cardinal sn;
  uint uVar4;
  Cardinal sn_1;
  
  pvVar1 = (void *)0x0;
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (Element->PinN != 0) {
      uVar2 = 0;
      uVar4 = Element->PinN;
      do {
        pvVar1 = SetPinSquare(Element,Element->Pin + uVar2);
        uVar3 = Element->PinN;
        if (uVar3 == 0) break;
        uVar2 = (uVar3 + 1 + uVar2) - uVar4;
        uVar4 = uVar3;
      } while (uVar2 < uVar3);
    }
    uVar4 = Element->PadN;
    uVar2 = uVar4;
    for (uVar3 = 0; (uVar2 != 0 && (uVar3 < uVar2)); uVar3 = uVar3 + (uVar2 == uVar4)) {
      pvVar1 = SetPadSquare(Element,Element->Pad + uVar3);
      uVar2 = Element->PadN;
    }
  }
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ChangeElementSquare(ElementTypePtr Element)

{
  void *pvVar1;
  void *ans;
  uint uVar2;
  Cardinal n;
  uint uVar3;
  Cardinal n_1;
  Cardinal sn;
  uint uVar4;
  Cardinal sn_1;
  
  pvVar1 = (void *)0x0;
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (Element->PinN != 0) {
      uVar2 = 0;
      uVar4 = Element->PinN;
      do {
        pvVar1 = ChangePinSquare(Element,Element->Pin + uVar2);
        uVar3 = Element->PinN;
        if (uVar3 == 0) break;
        uVar2 = (uVar3 + 1 + uVar2) - uVar4;
        uVar4 = uVar3;
      } while (uVar2 < uVar3);
    }
    uVar4 = Element->PadN;
    uVar2 = uVar4;
    for (uVar3 = 0; (uVar2 != 0 && (uVar3 < uVar2)); uVar3 = uVar3 + (uVar2 == uVar4)) {
      pvVar1 = ChangePadSquare(Element,Element->Pad + uVar3);
      uVar2 = Element->PadN;
    }
  }
  return pvVar1;
}



// WARNING: Unknown calling convention

Boolean ChangePaste(PadTypePtr Pad)

{
  bool bVar1;
  
  bVar1 = (*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0;
  if (bVar1) {
    ErasePad(Pad);
    AddObjectToFlagUndoList(0x200,Pad,Pad,Pad);
    (Pad->Flags).f = (Pad->Flags).f ^ 8;
    DrawPad(Pad,0);
    Draw();
  }
  return bVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedPaste(void)

{
  ElementTypePtr paVar1;
  uint uVar2;
  int iVar3;
  byte bVar4;
  DataTypePtr paVar5;
  PadTypePtr pad;
  PadTypePtr Pad;
  Cardinal sn;
  uint uVar6;
  Cardinal n;
  uint uVar7;
  ElementTypePtr element;
  int local_28;
  int local_24;
  byte local_1d;
  
  local_1d = 0;
  paVar5 = PCB->Data;
  local_24 = paVar5->ElementN - 1;
  if (local_24 != -1) {
    iVar3 = paVar5->ElementN * 300;
    while( true ) {
      local_28 = iVar3 + -300;
      paVar1 = paVar5->Element;
      uVar2 = *(uint *)((int)&paVar1[-1].PadN + iVar3);
      uVar6 = uVar2;
      for (uVar7 = 0; (uVar6 != 0 && (uVar7 < uVar6)); uVar7 = uVar7 + (uVar2 == uVar6)) {
        Pad = (PadTypePtr)(uVar7 * 0x68 + *(int *)((int)&paVar1[-1].Pad + iVar3));
        if ((*(byte *)&(Pad->Flags).f & 0x40) != 0) {
          bVar4 = ChangePaste(Pad);
          uVar6 = *(uint *)((int)&paVar1[-1].PadN + iVar3);
          local_1d = local_1d | bVar4;
        }
      }
      local_24 = local_24 + -1;
      if (local_24 == -1) break;
      paVar5 = PCB->Data;
      iVar3 = local_28;
    }
    if (local_1d != 0) {
      Draw();
      IncrementUndoSerialNumber();
    }
  }
  return local_1d;
}



// WARNING: Unknown calling convention

void * ChangeArcJoin(LayerTypePtr Layer,ArcTypePtr Arc)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Arc->Flags).f + 1) & 0x20) != 0) {
    return (void *)0x0;
  }
  EraseArc(Arc);
  if ((*(byte *)&(Arc->Flags).f & 0x20) != 0) {
    RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    AddObjectToClearPolyUndoList(0x4000,Layer,Arc,Arc,'\0');
  }
  AddObjectToFlagUndoList(0x4000,Layer,Arc,Arc);
  uVar1 = (Arc->Flags).f ^ 0x20;
  (Arc->Flags).f = uVar1;
  if ((uVar1 & 0x20) != 0) {
    ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    AddObjectToClearPolyUndoList(0x4000,Layer,Arc,Arc,'\x01');
  }
  DrawArc(Layer,Arc,0);
  return Arc;
}



// WARNING: Unknown calling convention

void * ClrArcJoin(LayerTypePtr Layer,ArcTypePtr Arc)

{
  void *pvVar1;
  
  if (((Arc->Flags).f & 0x2020) != 0x20) {
    return (void *)0x0;
  }
  pvVar1 = ChangeArcJoin(Layer,Arc);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetArcJoin(LayerTypePtr Layer,ArcTypePtr Arc)

{
  void *pvVar1;
  
  if (((Arc->Flags).f & 0x2020) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeArcJoin(Layer,Arc);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ChangeTextJoin(LayerTypePtr Layer,TextTypePtr Text)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) != 0) {
    return (void *)0x0;
  }
  EraseText(Layer,Text);
  if ((*(byte *)&(Text->Flags).f & 0x20) != 0) {
    AddObjectToClearPolyUndoList(0x10,Layer,Text,Text,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  }
  AddObjectToFlagUndoList(4,Layer,Text,Text);
  uVar1 = (Text->Flags).f ^ 0x20;
  (Text->Flags).f = uVar1;
  if ((uVar1 & 0x20) != 0) {
    AddObjectToClearPolyUndoList(0x10,Layer,Text,Text,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  }
  DrawText(Layer,Text,0);
  return Text;
}



// WARNING: Unknown calling convention

void * ClrTextJoin(LayerTypePtr Layer,TextTypePtr Text)

{
  void *pvVar1;
  
  if (((Text->Flags).f & 0x2020) != 0x20) {
    return (void *)0x0;
  }
  pvVar1 = ChangeTextJoin(Layer,Text);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetTextJoin(LayerTypePtr Layer,TextTypePtr Text)

{
  void *pvVar1;
  
  if (((Text->Flags).f & 0x2020) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeTextJoin(Layer,Text);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ChangeLineJoin(LayerTypePtr Layer,LineTypePtr Line)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Line->Flags).f + 1) & 0x20) != 0) {
    return (void *)0x0;
  }
  EraseLine(Line);
  if ((*(byte *)&(Line->Flags).f & 0x20) != 0) {
    AddObjectToClearPolyUndoList(4,Layer,Line,Line,'\0');
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
  }
  AddObjectToFlagUndoList(4,Layer,Line,Line);
  uVar1 = (Line->Flags).f ^ 0x20;
  (Line->Flags).f = uVar1;
  if ((uVar1 & 0x20) != 0) {
    AddObjectToClearPolyUndoList(4,Layer,Line,Line,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
  }
  DrawLine(Layer,Line,0);
  return Line;
}



// WARNING: Unknown calling convention

void * ClrLineJoin(LayerTypePtr Layer,LineTypePtr Line)

{
  void *pvVar1;
  
  if (((Line->Flags).f & 0x2020) != 0x20) {
    return (void *)0x0;
  }
  pvVar1 = ChangeLineJoin(Layer,Line);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * SetLineJoin(LayerTypePtr Layer,LineTypePtr Line)

{
  void *pvVar1;
  
  if (((Line->Flags).f & 0x2020) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeLineJoin(Layer,Line);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * ChangePadName(ElementTypePtr Element,PadTypePtr Pad)

{
  char *pcVar1;
  char *old;
  
  pcVar1 = Pad->Name;
  if ((*(byte *)&(Pad->Flags).f & 0x20) == 0) {
    Pad->Name = NewName;
    return pcVar1;
  }
  ErasePadName(Pad);
  Pad->Name = NewName;
  DrawPadName(Pad,0);
  return pcVar1;
}



// WARNING: Unknown calling convention

void * ChangePinName(ElementTypePtr Element,PinTypePtr Pin)

{
  char *pcVar1;
  char *old;
  
  pcVar1 = Pin->Name;
  if ((*(byte *)&(Pin->Flags).f & 0x20) == 0) {
    Pin->Name = NewName;
    return pcVar1;
  }
  ErasePinName(Pin);
  Pin->Name = NewName;
  DrawPinName(Pin,0);
  return pcVar1;
}



// WARNING: Unknown calling convention

void * ChangeViaName(PinTypePtr Via)

{
  char *pcVar1;
  char *old;
  
  pcVar1 = Via->Name;
  if ((*(byte *)&(Via->Flags).f & 0x20) == 0) {
    Via->Name = NewName;
    return pcVar1;
  }
  ErasePinName(Via);
  Via->Name = NewName;
  DrawPinName(Via,0);
  return pcVar1;
}



// WARNING: Unknown calling convention

void * ChangeTextName(LayerTypePtr Layer,TextTypePtr Text)

{
  char *pcVar1;
  char *pcVar2;
  char *old;
  
  pcVar1 = Text->TextString;
  pcVar2 = (char *)0x0;
  if ((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) == 0) {
    EraseText(Layer,Text);
    RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    Text->TextString = NewName;
    SetTextBoundingBox(&PCB->Font,Text);
    ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    DrawText(Layer,Text,0);
    pcVar2 = pcVar1;
  }
  return pcVar2;
}



// WARNING: Unknown calling convention

void * ChangeElementName(ElementTypePtr Element)

{
  uint uVar1;
  char *pcVar2;
  PCBTypePtr pPVar3;
  uint uVar4;
  int iVar5;
  char *pcVar6;
  DataTypePtr paVar7;
  BoxType *box;
  BoxType *local_20;
  
  uVar4 = 1;
  uVar1 = (PCB->Flags).f;
  if ((uVar1 & 0x40) == 0) {
    uVar4 = -(uint)((uVar1 & 0x20) == 0) & 2;
  }
  pcVar2 = Element->Name[uVar4].TextString;
  pcVar6 = (char *)0x0;
  if ((*(byte *)((int)&Element->Name[0].Flags.f + 1) & 0x20) == 0) {
    if (((uVar1 & 0x440) == 0x440) &&
       (pcVar6 = UniqueElementName(PCB->Data,NewName), pcVar6 != NewName)) {
      Message("Error: The name \"%s\" is not unique!\n",NewName);
      return (void *)0xffffffff;
    }
    local_20 = (BoxType *)Element->Name;
    EraseElementName(Element);
    uVar1 = (PCB->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      if ((uVar1 & 0x20) == 0) {
        paVar7 = PCB->Data;
        box = (BoxType *)(Element->Name + 2);
        iVar5 = 2;
      }
      else {
        paVar7 = PCB->Data;
        iVar5 = 0;
        box = local_20;
      }
    }
    else {
      paVar7 = PCB->Data;
      iVar5 = 1;
      box = (BoxType *)(Element->Name + 1);
    }
    r_delete_entry(paVar7->name_tree[iVar5],box);
    pPVar3 = PCB;
    uVar4 = 1;
    uVar1 = (PCB->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      uVar4 = -(uint)((uVar1 & 0x20) == 0) & 2;
    }
    Element->Name[uVar4].TextString = NewName;
    uVar4 = 0x3c;
    if ((uVar1 & 0x40) == 0) {
      uVar4 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
    }
    SetTextBoundingBox(&pPVar3->Font,
                       (TextTypePtr)((int)&(((TextType *)local_20)->BoundingBox).X1 + uVar4));
    uVar1 = (PCB->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      if ((uVar1 & 0x20) == 0) {
        local_20 = (BoxType *)(Element->Name + 2);
        paVar7 = PCB->Data;
        iVar5 = 2;
      }
      else {
        paVar7 = PCB->Data;
        iVar5 = 0;
      }
    }
    else {
      local_20 = (BoxType *)(Element->Name + 1);
      paVar7 = PCB->Data;
      iVar5 = 1;
    }
    r_insert_entry(paVar7->name_tree[iVar5],local_20,0);
    DrawElementName(Element,0);
    pcVar6 = pcVar2;
  }
  return pcVar6;
}



// WARNING: Unknown calling convention

void * ChangePadMaskSize(ElementTypePtr Element,PadTypePtr Pad)

{
  PCBTypePtr pPVar1;
  int iVar2;
  BDimension value;
  int iVar3;
  
  if (Absolute == 0) {
    iVar2 = Pad->Mask;
    iVar3 = 0;
    if (-1 < Delta + iVar2) {
      iVar3 = Delta + iVar2;
    }
    if (iVar2 != iVar3) goto LAB_0807b8a7;
  }
  else {
    iVar2 = Pad->Mask;
    iVar3 = 0;
    if (-1 < Absolute) {
      iVar3 = Absolute;
    }
    if (iVar2 != iVar3) goto LAB_0807b8a7;
  }
  if ((Absolute != 0) || (iVar3 = Pad->Thickness, iVar2 == iVar3)) {
    return (void *)0x0;
  }
LAB_0807b8a7:
  AddObjectToMaskSizeUndoList(0x200,Element,Pad,Pad);
  ErasePad(Pad);
  r_delete_entry(PCB->Data->pad_tree,&Pad->BoundingBox);
  pPVar1 = PCB;
  Pad->Mask = iVar3;
  SetElementBoundingBox(pPVar1->Data,Element,&pPVar1->Font);
  DrawPad(Pad,0);
  return Pad;
}



// WARNING: Unknown calling convention

void * ChangePinMaskSize(ElementTypePtr Element,PinTypePtr Pin)

{
  PCBTypePtr pPVar1;
  int iVar2;
  BDimension value;
  int iVar3;
  
  if (Absolute == 0) {
    iVar2 = Pin->Mask;
    iVar3 = 0;
    if (-1 < Delta + iVar2) {
      iVar3 = Delta + iVar2;
    }
    if (iVar2 != iVar3) goto LAB_0807b997;
  }
  else {
    iVar2 = Pin->Mask;
    iVar3 = 0;
    if (-1 < Absolute) {
      iVar3 = Absolute;
    }
    if (iVar2 != iVar3) goto LAB_0807b997;
  }
  if ((Absolute != 0) || (iVar3 = Pin->Thickness, iVar2 == iVar3)) {
    return (void *)0x0;
  }
LAB_0807b997:
  AddObjectToMaskSizeUndoList(0x100,Element,Pin,Pin);
  ErasePin(Pin);
  r_delete_entry(PCB->Data->pin_tree,&Pin->BoundingBox);
  pPVar1 = PCB;
  Pin->Mask = iVar3;
  SetElementBoundingBox(pPVar1->Data,Element,&pPVar1->Font);
  DrawPin(Pin,0);
  return Pin;
}



// WARNING: Unknown calling convention

void * ChangeViaMaskSize(PinTypePtr Via)

{
  BDimension value;
  PinTypePtr paVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if (Absolute == 0) {
    iVar3 = Via->Mask;
    iVar2 = Delta + iVar3;
  }
  else {
    iVar3 = Via->Mask;
    iVar2 = Absolute;
  }
  iVar4 = 0;
  if (-1 < iVar2) {
    iVar4 = iVar2;
  }
  paVar1 = (PinTypePtr)0x0;
  if (iVar4 != iVar3) {
    AddObjectToMaskSizeUndoList(1,Via,Via,Via);
    EraseVia(Via);
    r_delete_entry(PCB->Data->via_tree,&Via->BoundingBox);
    Via->Mask = iVar4;
    SetPinBoundingBox(Via);
    r_insert_entry(PCB->Data->via_tree,&Via->BoundingBox,0);
    DrawVia(Via,0);
    paVar1 = Via;
  }
  return paVar1;
}



// WARNING: Unknown calling convention

void * ChangePin2ndSize(ElementTypePtr Element,PinTypePtr Pin)

{
  uint uVar1;
  PCBTypePtr pPVar2;
  BDimension value;
  int iVar3;
  
  iVar3 = Absolute;
  if (Absolute == 0) {
    iVar3 = Delta + Pin->DrillingHole;
  }
  uVar1 = (Pin->Flags).f;
  if (((((uVar1 & 0x2000) == 0) && (iVar3 - 400U < 0x9894f1)) &&
      (((uVar1 & 8) != 0 || (iVar3 < Pin->Thickness + -399)))) && (iVar3 != Pin->DrillingHole)) {
    AddObjectTo2ndSizeUndoList(0x100,Element,Pin,Pin);
    ErasePin(Pin);
    Pin->DrillingHole = iVar3;
    DrawPin(Pin,0);
    if ((*(byte *)&(Pin->Flags).f & 8) != 0) {
      RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
      AddObjectToSizeUndoList(0x100,Element,Pin,Pin);
      pPVar2 = PCB;
      Pin->Thickness = iVar3;
      ClearFromPolygon((DataType *)pPVar2->Data,0x100,Element,Pin);
    }
  }
  else {
    Pin = (PinTypePtr)0x0;
  }
  return Pin;
}



// WARNING: Unknown calling convention

void * ChangeElement2ndSize(ElementTypePtr Element)

{
  bool bVar1;
  PCBTypePtr pPVar2;
  Cardinal sn;
  uint uVar3;
  uint uVar4;
  PinTypePtr pin;
  PinTypePtr Pin;
  Cardinal n;
  uint uVar5;
  BDimension value;
  int iVar6;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar5 = 0;
    bVar1 = false;
    uVar4 = Element->PinN;
    do {
      Pin = Element->Pin + uVar5;
      iVar6 = Absolute;
      if (Absolute == 0) {
        iVar6 = Delta + Pin->DrillingHole;
      }
      uVar3 = uVar4;
      if ((iVar6 - 400U < 0x9894f1) &&
         ((((*(byte *)&(Pin->Flags).f & 8) != 0 || (iVar6 < Pin->Thickness + -399)) &&
          (iVar6 != Pin->DrillingHole)))) {
        AddObjectTo2ndSizeUndoList(0x100,Element,Pin,Pin);
        ErasePin(Pin);
        Pin->DrillingHole = iVar6;
        DrawPin(Pin,0);
        if ((*(byte *)&(Pin->Flags).f & 8) == 0) {
          uVar3 = Element->PinN;
          bVar1 = true;
        }
        else {
          RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
          AddObjectToSizeUndoList(0x100,Element,Pin,Pin);
          pPVar2 = PCB;
          Pin->Thickness = iVar6;
          ClearFromPolygon((DataType *)pPVar2->Data,0x100,Element,Pin);
          bVar1 = true;
          uVar3 = Element->PinN;
        }
      }
    } while ((uVar3 != 0) && (uVar5 = (uVar5 + 1 + uVar3) - uVar4, uVar4 = uVar3, uVar5 < uVar3));
    if (bVar1) {
      return Element;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangeVia2ndSize(PinTypePtr Via)

{
  byte bVar1;
  uint uVar2;
  PCBTypePtr pPVar3;
  BDimension value;
  int iVar4;
  
  iVar4 = Absolute;
  if (Absolute == 0) {
    iVar4 = Delta + Via->DrillingHole;
  }
  uVar2 = (Via->Flags).f;
  if (((((uVar2 & 0x2000) == 0) && (iVar4 - 400U < 0x9894f1)) &&
      (((uVar2 & 8) != 0 || (iVar4 < Via->Thickness + -399)))) && (iVar4 != Via->DrillingHole)) {
    AddObjectTo2ndSizeUndoList(1,Via,Via,Via);
    EraseVia(Via);
    bVar1 = *(byte *)&(Via->Flags).f;
    Via->DrillingHole = iVar4;
    if ((bVar1 & 8) != 0) {
      RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
      AddObjectToSizeUndoList(1,Via,Via,Via);
      pPVar3 = PCB;
      Via->Thickness = iVar4;
      ClearFromPolygon((DataType *)pPVar3->Data,1,Via,Via);
    }
    DrawVia(Via,0);
  }
  else {
    Via = (PinTypePtr)0x0;
  }
  return Via;
}



// WARNING: Unknown calling convention

void * ChangePadSize(ElementTypePtr Element,PadTypePtr Pad)

{
  int iVar1;
  BDimension value;
  int iVar2;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Pad->Thickness;
  }
  if ((((*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0) && (iVar2 - 100U < 0x98961d)) &&
     (iVar2 != Pad->Thickness)) {
    AddObjectToSizeUndoList(0x200,Element,Pad,Pad);
    AddObjectToMaskSizeUndoList(0x200,Element,Pad,Pad);
    RestoreToPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    ErasePad(Pad);
    r_delete_entry(PCB->Data->pad_tree,&Pad->BoundingBox);
    iVar1 = Pad->Thickness;
    Pad->Thickness = iVar2;
    Pad->Mask = (Pad->Mask + iVar2) - iVar1;
    SetElementBoundingBox(PCB->Data,Element,&PCB->Font);
    ClearFromPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    DrawPad(Pad,0);
  }
  else {
    Pad = (PadTypePtr)0x0;
  }
  return Pad;
}



// WARNING: Unknown calling convention

void * ChangePinSize(ElementTypePtr Element,PinTypePtr Pin)

{
  uint uVar1;
  int iVar2;
  BDimension value;
  int iVar3;
  
  iVar3 = Absolute;
  if (Absolute == 0) {
    iVar3 = Delta + Pin->Thickness;
  }
  uVar1 = (Pin->Flags).f;
  if (((((uVar1 & 0x2000) == 0) && (iVar3 < 0x989681)) && ((uVar1 & 8) == 0)) &&
     (((1999 < iVar3 && (Pin->DrillingHole + 399 < iVar3)) && (iVar3 != Pin->Thickness)))) {
    AddObjectToSizeUndoList(0x100,Element,Pin,Pin);
    AddObjectToMaskSizeUndoList(0x100,Element,Pin,Pin);
    ErasePin(Pin);
    r_delete_entry(PCB->Data->pin_tree,&Pin->BoundingBox);
    RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    iVar2 = Pin->Thickness;
    Pin->Thickness = iVar3;
    Pin->Mask = (Pin->Mask + iVar3) - iVar2;
    SetElementBoundingBox(PCB->Data,Element,&PCB->Font);
    ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    DrawPin(Pin,0);
  }
  else {
    Pin = (PinTypePtr)0x0;
  }
  return Pin;
}



// WARNING: Unknown calling convention

void * ChangeElementNameSize(ElementTypePtr Element)

{
  TextTypePtr Text;
  byte bVar1;
  BDimension value;
  TextTypePtr text;
  int iVar2;
  Cardinal n;
  int iVar3;
  int iVar4;
  ElementTypePtr local_20;
  
  if (Absolute == 0) {
    iVar2 = Delta / 0x2d + Element->Name[0].Scale;
    bVar1 = *(byte *)((int)&Element->Name[0].Flags.f + 1);
  }
  else {
    iVar2 = Absolute / 0x2d;
    bVar1 = *(byte *)((int)&Element->Name[0].Flags.f + 1);
  }
  if (((bVar1 & 0x20) == 0) && (iVar2 - 10U < 0x2707)) {
    EraseElementName(Element);
    local_20 = Element;
    iVar3 = 2;
    do {
      iVar4 = iVar3 + -1;
      Text = Element->Name + iVar3;
      AddObjectToSizeUndoList(0x400,Element,Text,Text);
      r_delete_entry(PCB->Data->name_tree[iVar3],&Text->BoundingBox);
      local_20->Name[2].Scale = iVar2;
      SetTextBoundingBox(&PCB->Font,Text);
      r_insert_entry(PCB->Data->name_tree[iVar3],&Text->BoundingBox,0);
      local_20 = (ElementTypePtr)&local_20[-1].LineN;
      iVar3 = iVar4;
    } while (iVar4 != -1);
    DrawElementName(Element,0);
  }
  else {
    Element = (ElementTypePtr)0x0;
  }
  return Element;
}



// WARNING: Unknown calling convention

void * ChangeViaSize(PinTypePtr Via)

{
  uint uVar1;
  BDimension value;
  int iVar2;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Via->Thickness;
  }
  uVar1 = (Via->Flags).f;
  if (((((uVar1 & 0x2000) == 0) && (iVar2 < 0x989681)) && ((uVar1 & 8) == 0)) &&
     (((1999 < iVar2 && (Via->DrillingHole + 399 < iVar2)) && (iVar2 != Via->Thickness)))) {
    AddObjectToSizeUndoList(1,Via,Via,Via);
    EraseVia(Via);
    r_delete_entry(PCB->Data->via_tree,&Via->BoundingBox);
    RestoreToPolygon((DataType *)PCB->Data,0x100,Via,Via);
    if (Via->Mask != 0) {
      AddObjectToMaskSizeUndoList(1,Via,Via,Via);
      Via->Mask = (Via->Mask + iVar2) - Via->Thickness;
    }
    Via->Thickness = iVar2;
    SetPinBoundingBox(Via);
    r_insert_entry(PCB->Data->via_tree,&Via->BoundingBox,0);
    ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
    DrawVia(Via,0);
  }
  else {
    Via = (PinTypePtr)0x0;
  }
  return Via;
}



// WARNING: Unknown calling convention

void * ChangeTextSize(LayerTypePtr Layer,TextTypePtr Text)

{
  byte bVar1;
  PCBTypePtr pPVar2;
  BDimension value;
  int iVar3;
  
  if (Absolute == 0) {
    iVar3 = Delta / 0x2d + Text->Scale;
    bVar1 = *(byte *)((int)&(Text->Flags).f + 1);
  }
  else {
    iVar3 = Absolute / 0x2d;
    bVar1 = *(byte *)((int)&(Text->Flags).f + 1);
  }
  if ((((bVar1 & 0x20) == 0) && (iVar3 - 10U < 0x2707)) && (iVar3 != Text->Scale)) {
    AddObjectToSizeUndoList(0x10,Layer,Text,Text);
    EraseText(Layer,Text);
    r_delete_entry(Layer->text_tree,&Text->BoundingBox);
    RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    pPVar2 = PCB;
    Text->Scale = iVar3;
    SetTextBoundingBox(&pPVar2->Font,Text);
    r_insert_entry(Layer->text_tree,&Text->BoundingBox,0);
    ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    DrawText(Layer,Text,0);
  }
  else {
    Text = (TextTypePtr)0x0;
  }
  return Text;
}



// WARNING: Unknown calling convention

Boolean ChangeHole(PinTypePtr Via)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Via->Flags).f + 1) & 0x20) != 0) {
    return '\0';
  }
  EraseVia(Via);
  AddObjectToFlagUndoList(1,Via,Via,Via);
  uVar1 = (Via->Flags).f ^ 8;
  (Via->Flags).f = uVar1;
  if ((uVar1 & 8) == 0) {
    AddObjectTo2ndSizeUndoList(1,Via,Via,Via);
    Via->DrillingHole = Via->Thickness + -400;
  }
  else {
    RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
    AddObjectToSizeUndoList(1,Via,Via,Via);
    Via->Mask = Via->DrillingHole;
    Via->Thickness = Via->DrillingHole;
    ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
  }
  DrawVia(Via,0);
  Draw();
  return '\x01';
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedHole(void)

{
  uint uVar1;
  byte bVar2;
  PinTypePtr via;
  PCBTypePtr pPVar3;
  DataTypePtr paVar4;
  uint uVar5;
  Cardinal n;
  Cardinal sn;
  uint uVar6;
  Boolean change;
  byte bVar7;
  
  if (PCB->ViaOn != '\0') {
    paVar4 = PCB->Data;
    if (paVar4->ViaN != 0) {
      uVar5 = 0;
      bVar7 = 0;
      pPVar3 = PCB;
      uVar6 = paVar4->ViaN;
      do {
        if ((*(byte *)&paVar4->Via[uVar5].Flags.f & 0x40) == 0) {
          paVar4 = pPVar3->Data;
          uVar1 = paVar4->ViaN;
        }
        else {
          bVar2 = ChangeHole(paVar4->Via + uVar5);
          paVar4 = PCB->Data;
          bVar7 = bVar7 | bVar2;
          uVar1 = paVar4->ViaN;
          pPVar3 = PCB;
        }
      } while ((uVar1 != 0) && (uVar5 = (uVar1 + 1 + uVar5) - uVar6, uVar6 = uVar1, uVar5 < uVar1));
      if (bVar7 == 0) {
        return '\0';
      }
      Draw();
      IncrementUndoSerialNumber();
      return bVar7;
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

void * ChangePadClearSize(ElementTypePtr Element,PadTypePtr Pad)

{
  PCBTypePtr pPVar1;
  BDimension value;
  int iVar2;
  int iVar3;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Pad->Clearance;
  }
  if ((*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0) {
    iVar3 = PCB->Bloat * 2 + 2;
    if (iVar2 < iVar3) {
      iVar2 = iVar3;
    }
    iVar3 = 10000000;
    if (iVar2 < 0x989681) {
      iVar3 = iVar2;
    }
    if ((iVar3 - 100U < 0x98961d) && (Pad->Clearance != iVar3)) {
      AddObjectToClearSizeUndoList(0x200,Element,Pad,Pad);
      RestoreToPolygon((DataType *)PCB->Data,0x200,Element,Pad);
      ErasePad(Pad);
      r_delete_entry(PCB->Data->pad_tree,&Pad->BoundingBox);
      pPVar1 = PCB;
      Pad->Clearance = iVar3;
      SetElementBoundingBox(pPVar1->Data,Element,&pPVar1->Font);
      ClearFromPolygon((DataType *)PCB->Data,0x200,Element,Pad);
      DrawPad(Pad,0);
      return Pad;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangePinClearSize(ElementTypePtr Element,PinTypePtr Pin)

{
  PCBTypePtr pPVar1;
  BDimension value;
  int iVar2;
  int iVar3;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Pin->Clearance;
  }
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 0x20) == 0) {
    iVar3 = PCB->Bloat * 2 + 2;
    if (iVar2 < iVar3) {
      iVar2 = iVar3;
    }
    iVar3 = 10000000;
    if (iVar2 < 0x989681) {
      iVar3 = iVar2;
    }
    if (Pin->Clearance != iVar3) {
      RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
      AddObjectToClearSizeUndoList(0x100,Element,Pin,Pin);
      ErasePin(Pin);
      r_delete_entry(PCB->Data->pin_tree,&Pin->BoundingBox);
      pPVar1 = PCB;
      Pin->Clearance = iVar3;
      SetElementBoundingBox(pPVar1->Data,Element,&pPVar1->Font);
      ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
      DrawPin(Pin,0);
      return Pin;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangeViaClearSize(PinTypePtr Via)

{
  BDimension value;
  int iVar1;
  int iVar2;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Via->Clearance;
  }
  if (((Via->Flags).f & 0x2000) != 0) {
    return (void *)0x0;
  }
  iVar2 = 10000000;
  if (iVar1 < 0x989681) {
    iVar2 = iVar1;
  }
  if (iVar2 < 0) {
    iVar2 = 0;
  }
  if (Delta < 0) {
    if (SBORROW4(iVar2,PCB->Bloat * 2) != iVar2 + PCB->Bloat * -2 < 0) {
      iVar2 = 0;
    }
LAB_0807ca50:
    if (Absolute == 0) goto LAB_0807c96a;
  }
  else if (Delta == 0) goto LAB_0807ca50;
  if (iVar2 < PCB->Bloat * 2) {
    iVar2 = PCB->Bloat * 2 + 2;
  }
LAB_0807c96a:
  if (Via->Clearance == iVar2) {
    return (void *)0x0;
  }
  RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
  AddObjectToClearSizeUndoList(1,Via,Via,Via);
  EraseVia(Via);
  r_delete_entry(PCB->Data->via_tree,&Via->BoundingBox);
  Via->Clearance = iVar2;
  SetPinBoundingBox(Via);
  r_insert_entry(PCB->Data->via_tree,&Via->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
  DrawVia(Via,0);
  Via->Element = (void *)0x0;
  return Via;
}



// WARNING: Unknown calling convention

void * ChangeArcClearSize(LayerTypePtr Layer,ArcTypePtr Arc)

{
  BDimension value;
  int iVar1;
  int iVar2;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Arc->Clearance;
  }
  if (((Arc->Flags).f & 0x2020) == 0x20) {
    iVar2 = PCB->Bloat * 2 + 2;
    if (iVar1 < iVar2) {
      iVar1 = iVar2;
    }
    iVar2 = 10000000;
    if (iVar1 < 0x989681) {
      iVar2 = iVar1;
    }
    if (Arc->Clearance != iVar2) {
      AddObjectToClearSizeUndoList(0x4000,Layer,Arc,Arc);
      EraseArc(Arc);
      r_delete_entry(Layer->arc_tree,&Arc->BoundingBox);
      RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
      Arc->Clearance = iVar2;
      if (iVar2 == 0) {
        (Arc->Flags).f = (Arc->Flags).f & 0xffffffdf;
        Arc->Clearance = 1000;
      }
      SetArcBoundingBox(Arc);
      r_insert_entry(Layer->arc_tree,&Arc->BoundingBox,0);
      ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
      DrawArc(Layer,Arc,0);
      return Arc;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangeArcSize(LayerTypePtr Layer,ArcTypePtr Arc)

{
  BDimension value;
  int iVar1;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Arc->Thickness;
  }
  if ((((*(byte *)((int)&(Arc->Flags).f + 1) & 0x20) == 0) && (iVar1 - 1U < 10000000)) &&
     (iVar1 != Arc->Thickness)) {
    AddObjectToSizeUndoList(0x4000,Layer,Arc,Arc);
    EraseArc(Arc);
    r_delete_entry(Layer->arc_tree,&Arc->BoundingBox);
    RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    Arc->Thickness = iVar1;
    SetArcBoundingBox(Arc);
    r_insert_entry(Layer->arc_tree,&Arc->BoundingBox,0);
    ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    DrawArc(Layer,Arc,0);
  }
  else {
    Arc = (ArcTypePtr)0x0;
  }
  return Arc;
}



// WARNING: Unknown calling convention

void * ChangeLineClearSize(LayerTypePtr Layer,LineTypePtr Line)

{
  BDimension value;
  int iVar1;
  int iVar2;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Line->Clearance;
  }
  if (((Line->Flags).f & 0x2020) == 0x20) {
    iVar2 = PCB->Bloat * 2 + 2;
    if (iVar1 < iVar2) {
      iVar1 = iVar2;
    }
    iVar2 = 10000000;
    if (iVar1 < 0x989681) {
      iVar2 = iVar1;
    }
    if (Line->Clearance != iVar2) {
      AddObjectToClearSizeUndoList(4,Layer,Line,Line);
      RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
      EraseLine(Line);
      r_delete_entry(Layer->line_tree,&Line->BoundingBox);
      Line->Clearance = iVar2;
      if (iVar2 == 0) {
        (Line->Flags).f = (Line->Flags).f & 0xffffffdf;
        Line->Clearance = 1000;
      }
      SetLineBoundingBox(Line);
      r_insert_entry(Layer->line_tree,&Line->BoundingBox,0);
      ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
      DrawLine(Layer,Line,0);
      return Line;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangeLineSize(LayerTypePtr Layer,LineTypePtr Line)

{
  BDimension value;
  int iVar1;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Line->Thickness;
  }
  if ((((*(byte *)((int)&(Line->Flags).f + 1) & 0x20) == 0) && (iVar1 - 1U < 10000000)) &&
     (iVar1 != Line->Thickness)) {
    AddObjectToSizeUndoList(4,Layer,Line,Line);
    EraseLine(Line);
    r_delete_entry(Layer->line_tree,&Line->BoundingBox);
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    Line->Thickness = iVar1;
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,&Line->BoundingBox,0);
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
    DrawLine(Layer,Line,0);
  }
  else {
    Line = (LineTypePtr)0x0;
  }
  return Line;
}



// WARNING: Unknown calling convention

void * ChangeElementSize(ElementTypePtr Element)

{
  int iVar1;
  bool bVar2;
  LineTypePtr line;
  uchar *puVar3;
  ArcTypePtr arc;
  BDimension value;
  int iVar4;
  int iVar5;
  Cardinal n_1;
  Cardinal n;
  
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (PCB->ElementOn != '\0') {
      EraseElement(Element);
    }
    bVar2 = false;
    iVar5 = Element->LineN - 1;
    if (iVar5 != -1) {
      iVar1 = Element->LineN * 0x58;
      do {
        puVar3 = Element->Line[-1].Flags.t + iVar1 + -0x18;
        iVar4 = Absolute;
        if (Absolute == 0) {
          iVar4 = Delta + *(int *)(puVar3 + 0x24);
        }
        if ((iVar4 - 1U < 10000000) && (iVar4 != *(int *)(puVar3 + 0x24))) {
          AddObjectToSizeUndoList(0x2000,Element,puVar3,puVar3);
          bVar2 = true;
          *(int *)(puVar3 + 0x24) = iVar4;
        }
        iVar5 = iVar5 + -1;
        iVar1 = iVar1 + -0x58;
      } while (iVar5 != -1);
    }
    iVar5 = Element->ArcN - 1;
    if (iVar5 != -1) {
      iVar1 = Element->ArcN * 0x44;
      do {
        puVar3 = Element->Arc[-1].Flags.t + iVar1 + -0x18;
        iVar4 = Absolute;
        if (Absolute == 0) {
          iVar4 = Delta + *(int *)(puVar3 + 0x24);
        }
        if ((iVar4 - 1U < 10000000) && (iVar4 != *(int *)(puVar3 + 0x24))) {
          AddObjectToSizeUndoList(0x8000,Element,puVar3,puVar3);
          bVar2 = true;
          *(int *)(puVar3 + 0x24) = iVar4;
        }
        iVar5 = iVar5 + -1;
        iVar1 = iVar1 + -0x44;
      } while (iVar5 != -1);
    }
    if (PCB->ElementOn != '\0') {
      DrawElement(Element,0);
    }
    if (bVar2) {
      return Element;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * ChangePolyClear(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PCBTypePtr pPVar1;
  PolygonTypePtr ppVar2;
  
  ppVar2 = (PolygonTypePtr)0x0;
  if ((*(byte *)((int)&(Polygon->Flags).f + 1) & 0x20) == 0) {
    AddObjectToClearPolyUndoList(8,Layer,Polygon,Polygon,'\x01');
    AddObjectToFlagUndoList(8,Layer,Polygon,Polygon);
    pPVar1 = PCB;
    (Polygon->Flags).f = (Polygon->Flags).f ^ 0x10;
    InitClip(pPVar1->Data,Layer,Polygon);
    DrawPolygon(Layer,Polygon,0);
    ppVar2 = Polygon;
  }
  return ppVar2;
}



// WARNING: Unknown calling convention

Boolean ClrSelectedOctagon(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ClrOctagonFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean SetSelectedOctagon(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&SetOctagonFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedOctagon(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ChangeOctagonFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ClrSelectedSquare(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ClrSquareFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean SetSelectedSquare(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&SetSquareFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedSquare(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ChangeSquareFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ClrSelectedJoin(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ClrJoinFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean SetSelectedJoin(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&SetJoinFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedJoin(int types)

{
  Boolean BVar1;
  Boolean change;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ChangeJoinFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelected2ndSize(int types,LocationType Difference,Boolean fixIt)

{
  Boolean BVar1;
  Boolean change;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&Change2ndSizeFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedClearSize(int types,LocationType Difference,Boolean fixIt)

{
  char cVar1;
  Boolean change;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x20) == 0) {
    cVar1 = SelectedOperation((ObjectFunctionTypePtr)&ChangeClearSizeFunctions,'\0',types);
  }
  else {
    cVar1 = SelectedOperation((ObjectFunctionTypePtr)&ChangeMaskSizeFunctions,'\0',types);
  }
  if (cVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return cVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedSize(int types,LocationType Difference,Boolean fixIt)

{
  Boolean BVar1;
  Boolean change;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ChangeSizeFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedThermals(int types,int therm_style)

{
  Boolean BVar1;
  Boolean change;
  
  Delta = therm_style;
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&ChangeThermalFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeElementSide(ElementTypePtr Element,LocationType yoff)

{
  bool bVar1;
  
  bVar1 = (*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0;
  if (bVar1) {
    EraseElement(Element);
    AddObjectToMirrorUndoList(2,Element,Element,Element,yoff);
    MirrorElementCoordinates(PCB->Data,Element,yoff);
    DrawElement(Element,0);
  }
  return bVar1;
}



// WARNING: Unknown calling convention

Boolean ChangeSelectedElementSide(void)

{
  ElementTypePtr Element;
  byte bVar1;
  ElementTypePtr element;
  DataTypePtr paVar2;
  Cardinal n;
  int iVar3;
  int iVar4;
  Boolean change;
  byte bVar5;
  
  if ((PCB->PinOn != '\0') && (PCB->ElementOn != '\0')) {
    paVar2 = PCB->Data;
    iVar3 = paVar2->ElementN - 1;
    if (iVar3 != -1) {
      bVar5 = 0;
      iVar4 = paVar2->ElementN * 300;
      while( true ) {
        Element = (ElementTypePtr)(paVar2->Element[-1].Flags.t + iVar4 + -0x18);
        if ((*(byte *)&(Element->Flags).f & 0x40) != 0) {
          bVar1 = ChangeElementSide(Element,0);
          bVar5 = bVar5 | bVar1;
        }
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        paVar2 = PCB->Data;
        iVar4 = iVar4 + -300;
      }
      if (bVar5 == 0) {
        return '\0';
      }
      Draw();
      IncrementUndoSerialNumber();
      return bVar5;
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean ClipLine(double minx,double miny,double maxx,double maxy,double *x1,double *y1,double *x2,
                double *y2,double margin)

{
  double dVar1;
  double dVar2;
  double dVar3;
  Boolean BVar4;
  
  dVar3 = minx - margin;
  dVar1 = *x1;
  if (dVar3 <= dVar1) {
LAB_0807d67c:
    dVar2 = *x2;
    if (dVar2 < dVar3) {
      *x2 = dVar3;
      *y2 = ((dVar3 - dVar2) / (dVar1 - dVar2)) * (*y1 - *y2) + *y2;
      dVar2 = *x2;
      dVar1 = *x1;
    }
    dVar3 = maxx + margin;
    if (dVar3 < dVar1) {
      if (dVar3 < dVar2) goto LAB_0807d808;
      *x1 = dVar3;
      *y1 = (*y2 - *y1) * ((dVar2 - dVar1) / (dVar3 - dVar1)) + *y1;
      dVar2 = *x2;
    }
    if (dVar3 < dVar2) {
      dVar1 = *x1;
      *x2 = dVar3;
      dVar1 = *y2 + (*y1 - *y2) * ((dVar3 - dVar2) / (dVar1 - dVar2));
      *y2 = dVar1;
    }
    else {
      dVar1 = *y2;
    }
    dVar2 = miny - margin;
    dVar3 = *y1;
    if (dVar3 < dVar2) {
      if (dVar1 < dVar2) goto LAB_0807d808;
      *y1 = dVar2;
      *x1 = (*x2 - *x1) * ((dVar1 - dVar3) / (dVar2 - dVar3)) + *x1;
      dVar3 = *y1;
      dVar1 = *y2;
    }
    if (dVar1 < dVar2) {
      *y2 = dVar2;
      *x2 = (*x1 - *x2) * ((dVar3 - dVar1) / (dVar2 - dVar1)) + *x2;
      dVar1 = *y2;
      dVar3 = *y1;
    }
    dVar2 = margin + maxy;
    if (dVar2 < dVar3) {
      if (dVar2 < dVar1) goto LAB_0807d808;
      *y1 = dVar2;
      *x1 = (*x2 - *x1) * ((dVar1 - dVar3) / (dVar2 - dVar3)) + *x1;
      dVar1 = *y2;
    }
    BVar4 = '\x01';
    if (dVar2 < dVar1) {
      dVar3 = *y1;
      *y2 = dVar2;
      *x2 = *x2 + (*x1 - *x2) * ((dVar2 - dVar1) / (dVar3 - dVar1));
      return '\x01';
    }
  }
  else {
    dVar2 = *x2;
    if (dVar3 <= dVar2) {
      *x1 = dVar3;
      *y1 = (*y2 - *y1) * ((dVar2 - dVar1) / (dVar3 - dVar1)) + *y1;
      dVar1 = *x1;
      goto LAB_0807d67c;
    }
LAB_0807d808:
    BVar4 = '\0';
  }
  return BVar4;
}



// WARNING: Unknown calling convention

int CommandSaveLayout(int argc,char **argv,int x,int y)

{
  if (argc == 0) {
    if (PCB->Filename == (char *)0x0) {
      Message("No filename to save to yet\n");
      return 0;
    }
    SavePCB(PCB->Filename);
  }
  else {
    if (argc != 1) {
      Message("Usage: s [name] | w [name]\n  saves layout data\n");
      return 1;
    }
    SavePCB(*argv);
  }
  return 0;
}



// WARNING: Unknown calling convention

int CommandHelp(int argc,char **argv,int x,int y)

{
  Message(
         "following commands are supported:\n  Command()   execute an action command (too numerous to list)\n              see the manual for the list of action commands\n  h           display this help message\n  l  [file]   load layout\n  le [file]   load element to buffer\n  m  [file]   load layout to buffer (merge)\n  q           quits the application\n  q!          quits without save warning\n  rn [file]   read in a net-list file\n  s  [file]   save layout\n  w  [file]   save layout\n  wq [file]   save layout and quit\n"
         );
  return 0;
}



// WARNING: Unknown calling convention

int CommandLoadNetlist(int argc,char **argv,int x,int y)

{
  PCBTypePtr pPVar1;
  char *pcVar2;
  char *filename;
  
  if (argc != 1) {
    Message("Usage: rn [name]\n  reads in a netlist file\n");
    return 1;
  }
  pcVar2 = *argv;
  if (PCB->Netlistname != (char *)0x0) {
    SaveFree(PCB->Netlistname);
  }
  pPVar1 = PCB;
  pcVar2 = StripWhiteSpaceAndDup(pcVar2);
  pPVar1->Netlistname = pcVar2;
  free((void *)0x0);
  return 0;
}



// WARNING: Unknown calling convention

int CommandReallyQuit(int argc,char **argv,int x,int y)

{
  QuitApplication();
  return 0;
}



// WARNING: Unknown calling convention

int CommandQuit(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  if (PCB->Changed != '\0') {
    iVar1 = (*gui->close_confirm_dialog)();
    if (iVar1 != 1) {
      return 0;
    }
  }
  QuitApplication();
  return 0;
}



// WARNING: Unknown calling convention

int CommandSaveLayoutAndQuit(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  iVar1 = CommandSaveLayout(argc,argv,x,y);
  if (iVar1 != 0) {
    return 1;
  }
  iVar1 = CommandQuit(0,(char **)0x0,0,0);
  return iVar1;
}



// WARNING: Unknown calling convention

int CommandLoadLayoutToBuffer(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  char *filename;
  
  if (argc != 1) {
    Message("Usage: m [name]\n  loads layout data to buffer\n");
    return 1;
  }
  if (*argv != (char *)0x0) {
    BVar1 = LoadLayoutToBuffer(Buffers + Settings.BufferNumber,*argv);
    if (BVar1 != '\0') {
      SetMode(5);
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int CommandLoadElementToBuffer(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  char *filename;
  
  if (argc != 1) {
    Message((char *)0x0,"Usage: le [name]\n  loads element data to buffer\n");
    return 1;
  }
  if (*argv != (char *)0x0) {
    BVar1 = LoadElementToBuffer(Buffers + Settings.BufferNumber,*argv,'\x01');
    if (BVar1 != '\0') {
      SetMode(5);
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int CommandLoadLayout(int argc,char **argv,int x,int y)

{
  char *Filename;
  int iVar1;
  char *filename;
  
  if (argc == 1) {
    Filename = *argv;
    if ((PCB->Changed == '\0') ||
       (iVar1 = (*gui->confirm_dialog)("OK to override layout data?",0), iVar1 != 0)) {
      LoadPCB(Filename);
    }
    free((void *)0x0);
    return 0;
  }
  Message("Usage: l [name]\n  loads layout data\n");
  return 1;
}



// WARNING: Unknown calling convention

void register_command_action_list(void)

{
  hid_register_actions(command_action_list,10);
  return;
}



// WARNING: Unknown calling convention

void * CopyObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  void *pvVar1;
  void *ptr;
  
  DeltaX = DX;
  DeltaY = DY;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&CopyFunctions,Type,Ptr1,Ptr2,Ptr3);
  IncrementUndoSerialNumber();
  return pvVar1;
}



// WARNING: Unknown calling convention

void * CopyArc(LayerTypePtr Layer,ArcTypePtr Arc)

{
  int iVar1;
  FlagType Flags;
  ArcTypePtr Arc_00;
  ArcTypePtr paVar2;
  ArcTypePtr arc;
  int in_GS_OFFSET;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags(Arc->Flags,4);
  Flags.t._0_4_ = local_18;
  Flags.f = local_1c;
  Flags.t._4_4_ = local_14;
  Arc_00 = CreateNewArcOnLayer(Layer,DeltaX + Arc->X,DeltaY + Arc->Y,Arc->Width,Arc->Height,
                               Arc->StartAngle,Arc->Delta,Arc->Thickness,Arc->Clearance,Flags);
  paVar2 = (ArcTypePtr)0x0;
  if (Arc_00 != (ArcTypePtr)0x0) {
    DrawArc(Layer,Arc_00,0);
    AddObjectToCreateUndoList(0x4000,Layer,Arc_00,Arc_00);
    paVar2 = Arc_00;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return paVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * CopyVia(PinTypePtr Via)

{
  int iVar1;
  FlagType Flags;
  PinTypePtr Via_00;
  PinTypePtr paVar2;
  PinTypePtr via;
  int in_GS_OFFSET;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags(Via->Flags,4);
  Flags.t._0_4_ = local_18;
  Flags.f = local_1c;
  Flags.t._4_4_ = local_14;
  Via_00 = CreateNewVia(PCB->Data,DeltaX + Via->X,DeltaY + Via->Y,Via->Thickness,Via->Clearance,
                        Via->Mask,Via->DrillingHole,Via->Name,Flags);
  paVar2 = (PinTypePtr)0x0;
  if (Via_00 != (PinTypePtr)0x0) {
    DrawVia(Via_00,0);
    AddObjectToCreateUndoList(1,Via_00,Via_00,Via_00);
    paVar2 = Via_00;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return paVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * CopyText(LayerTypePtr Layer,TextTypePtr Text)

{
  int iVar1;
  FlagType Flags;
  TextTypePtr Text_00;
  TextTypePtr text;
  int in_GS_OFFSET;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags(Text->Flags,4);
  Flags.t._0_4_ = local_18;
  Flags.f = local_1c;
  Flags.t._4_4_ = local_14;
  Text_00 = CreateNewText(Layer,&PCB->Font,DeltaX + Text->X,DeltaY + Text->Y,Text->Direction,
                          Text->Scale,Text->TextString,Flags);
  DrawText(Layer,Text_00,0);
  AddObjectToCreateUndoList(0x10,Layer,Text_00,Text_00);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return Text_00;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * CopyLine(LayerTypePtr Layer,LineTypePtr Line)

{
  int iVar1;
  FlagType Flags;
  LineTypePtr Line_00;
  char *pcVar2;
  LineTypePtr pLVar3;
  LineTypePtr line;
  int in_GS_OFFSET;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags(Line->Flags,4);
  Flags.t._0_4_ = local_28;
  Flags.f = local_2c;
  Flags.t._4_4_ = local_24;
  Line_00 = CreateDrawnLineOnLayer
                      (Layer,DeltaX + (Line->Point1).X,DeltaY + (Line->Point1).Y,
                       (Line->Point2).X + DeltaX,(Line->Point2).Y + DeltaY,Line->Thickness,
                       Line->Clearance,Flags);
  pLVar3 = (LineTypePtr)0x0;
  if (Line_00 != (LineTypePtr)0x0) {
    if (Line->Number != (char *)0x0) {
      pcVar2 = MyStrdup(Line->Number,"CopyLine");
      Line_00->Number = pcVar2;
    }
    DrawLine(Layer,Line_00,0);
    AddObjectToCreateUndoList(4,Layer,Line_00,Line_00);
    pLVar3 = Line_00;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pLVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

ElementTypePtr
CopyElementLowLevel(DataTypePtr Data,ElementTypePtr Dest,ElementTypePtr Src,Boolean uniqueName,
                   LocationType dx,LocationType dy)

{
  BYTE Direction;
  int iVar1;
  int iVar2;
  char *Value;
  char *NameOnPCB;
  char *Description;
  LineTypePtr pLVar3;
  PinTypePtr paVar4;
  uint uVar5;
  PadTypePtr paVar6;
  ArcTypePtr paVar7;
  FlagType Flags;
  FlagType Flags_00;
  FlagType Flags_01;
  FlagType TextFlags;
  ElementTypePtr Element;
  Cardinal n;
  LineTypePtr line;
  Cardinal sn;
  uint uVar8;
  PinTypePtr pin;
  Cardinal sn_1;
  PadTypePtr pad;
  ArcTypePtr arc;
  AttributeType *pAVar9;
  Cardinal n_2;
  Cardinal n_1;
  int i;
  int iVar10;
  uint uVar11;
  int iVar12;
  int in_GS_OFFSET;
  uint local_60;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Dest != (ElementTypePtr)0x0) {
    FreeElementMemory(Dest);
  }
  MaskFlags(Src->Name[0].Flags,4);
  iVar10 = Src->Name[0].Scale;
  iVar12 = Src->Name[0].Y;
  Direction = Src->Name[0].Direction;
  iVar2 = Src->Name[0].X;
  Value = Src->Name[2].TextString;
  NameOnPCB = Src->Name[1].TextString;
  Description = Src->Name[0].TextString;
  MaskFlags(Src->Flags,4);
  Flags.t._0_4_ = local_34;
  Flags.f = local_38;
  Flags.t._4_4_ = local_30;
  TextFlags.t._0_4_ = local_28;
  TextFlags.f = local_2c;
  TextFlags.t._4_4_ = local_24;
  Element = CreateNewElement(Data,Dest,&PCB->Font,Flags,Description,NameOnPCB,Value,iVar2 + dx,
                             iVar12 + dy,Direction,iVar10,TextFlags,uniqueName);
  if (Element != (ElementTypePtr)0x0) {
    iVar10 = Src->LineN - 1;
    if (iVar10 != -1) {
      iVar12 = Src->LineN * 0x58;
      do {
        iVar10 = iVar10 + -1;
        pLVar3 = Src->Line;
        CreateNewLineInElement
                  (Element,dx + *(int *)((int)&((PointType *)(&pLVar3[-1].Flags + 2))->Y +
                                        iVar12 + -4),
                   *(int *)((int)&((PointType *)(&pLVar3[-1].Flags + 2))->Y + iVar12) + dy,
                   *(int *)((int)(&pLVar3[-1].Flags + 3) + iVar12 + 8) + dx,
                   *(int *)((int)(&pLVar3[-1].Flags + 4) + iVar12) + dy,
                   *(BDimension *)((int)(&pLVar3[-1].Flags + 1) + iVar12 + 4));
        iVar12 = iVar12 + -0x58;
      } while (iVar10 != -1);
    }
    if (Src->PinN != 0) {
      uVar11 = 0;
      uVar8 = Src->PinN;
      do {
        paVar4 = Src->Pin;
        MaskFlags(paVar4[uVar11].Flags,4);
        Flags_00.t._0_4_ = local_40;
        Flags_00.f = local_44;
        Flags_00.t._4_4_ = local_3c;
        CreateNewPin(Element,paVar4[uVar11].X + dx,dy + paVar4[uVar11].Y,paVar4[uVar11].Thickness,
                     paVar4[uVar11].Clearance,paVar4[uVar11].Mask,paVar4[uVar11].DrillingHole,
                     paVar4[uVar11].Name,paVar4[uVar11].Number,Flags_00);
        uVar5 = Src->PinN;
        if (uVar5 == 0) break;
        uVar11 = (uVar5 + 1 + uVar11) - uVar8;
        uVar8 = uVar5;
      } while (uVar11 < uVar5);
    }
    uVar8 = Src->PadN;
    local_60 = 0;
    uVar11 = uVar8;
    while ((uVar11 != 0 && (local_60 < uVar11))) {
      paVar6 = Src->Pad;
      MaskFlags(paVar6[local_60].Flags,4);
      Flags_01.t._0_4_ = local_4c;
      Flags_01.f = local_50;
      Flags_01.t._4_4_ = local_48;
      CreateNewPad(Element,dx + paVar6[local_60].Point1.X,paVar6[local_60].Point1.Y + dy,
                   paVar6[local_60].Point2.X + dx,paVar6[local_60].Point2.Y + dy,
                   paVar6[local_60].Thickness,paVar6[local_60].Clearance,paVar6[local_60].Mask,
                   paVar6[local_60].Name,paVar6[local_60].Number,Flags_01);
      uVar11 = Src->PadN;
      if (Src->PadN == uVar8) {
        local_60 = local_60 + 1;
        uVar11 = uVar8;
      }
    }
    iVar10 = Src->ArcN - 1;
    if (iVar10 != -1) {
      iVar12 = Src->ArcN * 0x44;
      do {
        iVar10 = iVar10 + -1;
        paVar7 = Src->Arc;
        CreateNewArcInElement
                  (Element,dx + *(int *)((int)(&paVar7[-1].Flags + 2) + iVar12 + 8),
                   dy + *(int *)((int)(&paVar7[-1].Flags + 3) + iVar12),
                   *(BDimension *)((int)(&paVar7[-1].Flags + 2) + iVar12),
                   *(BDimension *)((int)(&paVar7[-1].Flags + 2) + iVar12 + 4),
                   *(int *)((int)(&paVar7[-1].Flags + 3) + iVar12 + 4),
                   *(int *)((int)(&paVar7[-1].Flags + 3) + iVar12 + 8),
                   *(BDimension *)((int)(&paVar7[-1].Flags + 1) + iVar12 + 4));
        iVar12 = iVar12 + -0x44;
      } while (iVar10 != -1);
    }
    if (0 < (Src->Attributes).Number) {
      iVar10 = 0;
      do {
        iVar12 = iVar10 + 1;
        pAVar9 = (Src->Attributes).List + iVar10;
        CreateNewAttribute(&Element->Attributes,pAVar9->name,pAVar9->value);
        iVar10 = iVar12;
      } while ((Src->Attributes).Number != iVar12 && iVar12 <= (Src->Attributes).Number);
    }
    iVar10 = Src->MarkY;
    Element->MarkX = dx + Src->MarkX;
    Element->MarkY = dy + iVar10;
    SetElementBoundingBox(Data,Element,&PCB->Font);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return Element;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * CopyElement(ElementTypePtr Element)

{
  ElementTypePtr Element_00;
  ElementTypePtr element;
  
  Element_00 = CopyElementLowLevel(PCB->Data,(ElementTypePtr)0x0,Element,
                                   (byte)((PCB->Flags).f >> 10) & 1,DeltaX,DeltaY);
  AddObjectToCreateUndoList(2,Element_00,Element_00,Element_00);
  if ((PCB->ElementOn != '\0') &&
     ((((Element_00->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (PCB->InvisibleObjectsOn != '\0')))) {
    DrawElementName(Element_00,0);
    DrawElementPackage(Element_00,0);
  }
  if (PCB->PinOn != '\0') {
    DrawElementPinsAndPads(Element_00,0);
  }
  return Element_00;
}



// WARNING: Unknown calling convention

PolygonTypePtr CopyPolygonLowLevel(PolygonTypePtr Dest,PolygonTypePtr Src)

{
  undefined4 uVar1;
  int iVar2;
  PointTypePtr point;
  LocationType *pLVar3;
  Cardinal n;
  int iVar4;
  
  iVar4 = Src->PointN - 1;
  if (iVar4 != -1) {
    iVar2 = Src->PointN * 0x14;
    do {
      iVar4 = iVar4 + -1;
      pLVar3 = (LocationType *)((int)&Src->Points[-1].X + iVar2);
      CreateNewPointInPolygon(Dest,*pLVar3,pLVar3[1]);
      iVar2 = iVar2 + -0x14;
    } while (iVar4 != -1);
  }
  SetPolygonBoundingBox(Dest);
  (Dest->Flags).f = (Src->Flags).f;
  *(undefined4 *)(Dest->Flags).t = *(undefined4 *)(Src->Flags).t;
  uVar1 = *(undefined4 *)((Src->Flags).t + 4);
  (Dest->Flags).f = (Dest->Flags).f & 0xfffffffb;
  *(undefined4 *)((Dest->Flags).t + 4) = uVar1;
  return Dest;
}



// WARNING: Unknown calling convention

void * CopyPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  int iVar1;
  FlagType Flags;
  PolygonTypePtr Dest;
  rtree_t *rtree;
  PolygonTypePtr polygon;
  int in_GS_OFFSET;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags(0);
  Flags.t._0_4_ = local_28;
  Flags.f = local_2c;
  Flags.t._4_4_ = local_24;
  Dest = CreateNewPolygon(Layer,Flags);
  CopyPolygonLowLevel(Dest,Polygon);
  MovePolygonLowLevel(Dest,DeltaX,DeltaY);
  rtree = Layer->polygon_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Layer->polygon_tree = rtree;
  }
  r_insert_entry(rtree,&Dest->BoundingBox,0);
  InitClip(PCB->Data,Layer,Dest);
  DrawPolygon(Layer,Dest,0);
  AddObjectToCreateUndoList(8,Layer,Dest,Dest);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return Dest;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

Boolean CopyPastebufferToLayout(LocationType X,LocationType Y)

{
  LayerTypePtr Layer;
  DataTypePtr paVar1;
  uint uVar2;
  Cardinal CVar3;
  DataTypePtr paVar4;
  ElementTypePtr element;
  ElementTypePtr Element;
  PCBTypePtr pPVar5;
  LayerTypePtr destlayer;
  Cardinal n_4;
  uint uVar6;
  Cardinal n_5;
  Cardinal n;
  Cardinal n_3;
  Cardinal n_2;
  int iVar7;
  Cardinal n_1;
  Cardinal sn;
  uint uVar8;
  Boolean changed;
  int iVar9;
  bool bVar10;
  uint local_24;
  
  bVar10 = false;
  DeltaY = Y - Buffers[Settings.BufferNumber].Y;
  DeltaX = X - Buffers[Settings.BufferNumber].X;
  paVar4 = PCB->Data;
  pPVar5 = PCB;
  if (paVar4->LayerN != -2) {
    local_24 = 0;
    do {
      paVar1 = Buffers[Settings.BufferNumber].Data;
      if (paVar4->Layer[local_24].On != '\0') {
        Layer = paVar4->Layer + local_24;
        if (bVar10) {
          CVar3 = paVar1->Layer[local_24].LineN;
LAB_0807e8bf:
          iVar7 = CVar3 - 1;
          if (iVar7 == -1) {
LAB_0807e7c5:
            CVar3 = paVar1->Layer[local_24].ArcN;
          }
          else {
            iVar9 = CVar3 * 0x58;
            do {
              iVar7 = iVar7 + -1;
              CopyLine(Layer,(LineTypePtr)(paVar1->Layer[local_24].Line[-1].Flags.t + iVar9 + -0x18)
                      );
              iVar9 = iVar9 + -0x58;
            } while (iVar7 != -1);
            CVar3 = paVar1->Layer[local_24].ArcN;
          }
          iVar7 = CVar3 - 1;
          if (iVar7 != -1) {
            iVar9 = CVar3 * 0x44;
            do {
              iVar7 = iVar7 + -1;
              CopyArc(Layer,(ArcTypePtr)(paVar1->Layer[local_24].Arc[-1].Flags.t + iVar9 + -0x18));
              iVar9 = iVar9 + -0x44;
            } while (iVar7 != -1);
          }
          bVar10 = true;
        }
        else {
          CVar3 = paVar1->Layer[local_24].LineN;
          if (CVar3 != 0) goto LAB_0807e8bf;
          if ((paVar1->Layer[local_24].ArcN != 0) || (paVar1->Layer[local_24].PolygonN != 0))
          goto LAB_0807e7c5;
          bVar10 = paVar1->Layer[local_24].TextN != 0;
        }
        CVar3 = paVar1->Layer[local_24].TextN;
        iVar7 = CVar3 - 1;
        if (iVar7 != -1) {
          iVar9 = CVar3 * 0x3c;
          do {
            iVar7 = iVar7 + -1;
            CopyText(Layer,(TextTypePtr)(paVar1->Layer[local_24].Text[-1].Flags.t + iVar9 + -0x18));
            iVar9 = iVar9 + -0x3c;
          } while (iVar7 != -1);
        }
        CVar3 = paVar1->Layer[local_24].PolygonN;
        iVar7 = CVar3 - 1;
        pPVar5 = PCB;
        if (iVar7 != -1) {
          iVar9 = CVar3 * 0x3c;
          do {
            iVar7 = iVar7 + -1;
            CopyPolygon(Layer,(PolygonTypePtr)
                              (paVar1->Layer[local_24].Polygon[-1].Flags.t + iVar9 + -0x18));
            pPVar5 = PCB;
            iVar9 = iVar9 + -0x3c;
          } while (iVar7 != -1);
        }
      }
      paVar4 = pPVar5->Data;
      local_24 = local_24 + 1;
    } while (local_24 < paVar4->LayerN + 2U);
  }
  if ((pPVar5->PinOn != '\0') && (pPVar5->ElementOn != '\0')) {
    paVar4 = Buffers[Settings.BufferNumber].Data;
    iVar7 = paVar4->ElementN - 1;
    if (iVar7 != -1) {
      iVar9 = paVar4->ElementN * 300;
      while( true ) {
        Element = (ElementTypePtr)(paVar4->Element[-1].Flags.t + iVar9 + -0x18);
        if ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide) ||
           (PCB->InvisibleObjectsOn != '\0')) {
          bVar10 = true;
          CopyElement(Element);
        }
        iVar7 = iVar7 + -1;
        pPVar5 = PCB;
        if (iVar7 == -1) break;
        paVar4 = Buffers[Settings.BufferNumber].Data;
        iVar9 = iVar9 + -300;
      }
    }
  }
  if (pPVar5->ViaOn != '\0') {
    paVar4 = Buffers[Settings.BufferNumber].Data;
    uVar8 = paVar4->ViaN;
    bVar10 = (bool)(bVar10 | uVar8 != 0);
    if (uVar8 != 0) {
      uVar6 = 0;
      do {
        CopyVia(paVar4->Via + uVar6);
        paVar4 = Buffers[Settings.BufferNumber].Data;
        uVar2 = paVar4->ViaN;
        if (uVar2 == 0) break;
        uVar6 = (uVar2 + 1 + uVar6) - uVar8;
        uVar8 = uVar2;
      } while (uVar6 < uVar2);
    }
  }
  if (bVar10 != false) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return bVar10;
}



// WARNING: Unknown calling convention

void pcb_colors_from_settings(PCBTypePtr ptr)

{
  char **ppcVar1;
  DataTypePtr paVar2;
  DataTypePtr paVar3;
  char *pcVar4;
  char *pcVar5;
  int iVar6;
  int i;
  int iVar7;
  char *pcVar8;
  
  ptr->ConnectedColor = Settings.ConnectedColor;
  pcVar4 = Settings.ElementColor;
  ptr->ElementColor = Settings.ElementColor;
  ptr->RatColor = Settings.RatColor;
  pcVar8 = Settings.InvisibleObjectsColor;
  ptr->InvisibleObjectsColor = Settings.InvisibleObjectsColor;
  ptr->InvisibleMarkColor = Settings.InvisibleMarkColor;
  pcVar5 = Settings.ElementSelectedColor;
  ptr->ElementSelectedColor = Settings.ElementSelectedColor;
  ptr->RatSelectedColor = Settings.RatSelectedColor;
  ptr->PinColor = Settings.PinColor;
  ptr->PinSelectedColor = Settings.PinSelectedColor;
  ptr->PinNameColor = Settings.PinNameColor;
  ptr->ViaColor = Settings.ViaColor;
  ptr->ViaSelectedColor = Settings.ViaSelectedColor;
  ptr->WarnColor = Settings.WarnColor;
  ptr->MaskColor = Settings.MaskColor;
  paVar2 = ptr->Data;
  iVar7 = 0;
  iVar6 = 0;
  do {
    *(char **)((int)&paVar2->Layer[0].Color + iVar7) = Settings.LayerColor[iVar6];
    ppcVar1 = Settings.LayerSelectedColor + iVar6;
    iVar6 = iVar6 + 1;
    *(char **)((int)&paVar2->Layer[0].SelectedColor + iVar7) = *ppcVar1;
    iVar7 = iVar7 + 0x5c;
  } while (iVar6 != 0x10);
  paVar3 = PCB->Data;
  iVar6 = paVar3->LayerN;
  if (Settings.ShowSolderSide == '\0') {
    paVar2->Layer[iVar6 + 1].Color = pcVar4;
    paVar2->Layer[iVar6 + 1].SelectedColor = pcVar5;
  }
  else {
    paVar2->Layer[iVar6 + 1].Color = pcVar8;
    paVar2->Layer[iVar6 + 1].SelectedColor = pcVar5;
    pcVar8 = pcVar4;
  }
  paVar2->Layer[iVar6].Color = pcVar8;
  paVar2->Layer[paVar3->LayerN].SelectedColor = pcVar5;
  return;
}



// WARNING: Unknown calling convention

AttributeTypePtr CreateNewAttribute(AttributeListTypePtr list,char *name,char *value)

{
  char *pcVar1;
  int iVar2;
  AttributeType *pAVar3;
  
  iVar2 = list->Number;
  if (iVar2 < list->Max) {
    pAVar3 = list->List;
  }
  else {
    iVar2 = list->Max + 10;
    list->Max = iVar2;
    pAVar3 = (AttributeType *)MyRealloc(list->List,iVar2 * 8,"CreateNewAttribute");
    iVar2 = list->Number;
    list->List = pAVar3;
  }
  pcVar1 = MyStrdup(name,"CreateNewAttribute");
  pAVar3[iVar2].name = pcVar1;
  iVar2 = list->Number;
  pAVar3 = list->List;
  pcVar1 = MyStrdup(value,"CreateNewAttribute");
  pAVar3[iVar2].value = pcVar1;
  iVar2 = list->Number;
  list->Number = iVar2 + 1;
  return list->List + iVar2;
}



// WARNING: Unknown calling convention

LibraryEntryTypePtr CreateNewConnection(LibraryMenuTypePtr net,char *conn)

{
  LibraryEntryTypePtr paVar1;
  char *pcVar2;
  LibraryEntryTypePtr entry;
  
  paVar1 = GetLibraryEntryMemory(net);
  pcVar2 = MyStrdup(conn,"CreateNewConnection()");
  paVar1->ListEntry = pcVar2;
  return paVar1;
}



// WARNING: Unknown calling convention

LibraryMenuTypePtr CreateNewNet(LibraryTypePtr lib,char *name,char *style)

{
  int iVar1;
  LibraryMenuTypePtr paVar2;
  char *pcVar3;
  int iVar4;
  LibraryMenuTypePtr menu;
  char *pcVar5;
  int in_GS_OFFSET;
  bool bVar6;
  byte bVar7;
  char temp [64];
  
  bVar7 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __sprintf_chk(temp,1,0x40,"  %s",name);
  paVar2 = GetLibraryMenuMemory(lib);
  pcVar3 = MyStrdup(temp,"CreateNewNet()");
  paVar2->flag = '\x01';
  bVar6 = style == (char *)0x0;
  paVar2->Name = pcVar3;
  if (!bVar6) {
    iVar4 = 10;
    pcVar3 = "(unknown)";
    pcVar5 = style;
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      bVar6 = *pcVar3 == *pcVar5;
      pcVar3 = pcVar3 + (uint)bVar7 * -2 + 1;
      pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
    } while (bVar6);
    if (bVar6) {
      paVar2->Style = (char *)0x0;
      goto LAB_0807ecfa;
    }
  }
  pcVar3 = MyStrdup(style,"CreateNewNet()");
  paVar2->Style = pcVar3;
LAB_0807ecfa:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return paVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

RubberbandTypePtr
CreateNewRubberbandEntry(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr MovedPoint)

{
  RubberbandTypePtr ptr;
  RubberbandTypePtr paVar1;
  
  paVar1 = GetRubberbandMemory();
  (Line->Flags).f = (Line->Flags).f ^ 0x200;
  paVar1->Layer = Layer;
  paVar1->Line = Line;
  paVar1->MovedPoint = MovedPoint;
  return paVar1;
}



// WARNING: Unknown calling convention

void CreateDefaultFont(void)

{
  int iVar1;
  
  iVar1 = ParseFont(&PCB->Font,Settings.FontFile);
  if (iVar1 == 0) {
    return;
  }
  Message("Can\'t find font-symbol-file \'%s\'\n",Settings.FontFile);
  return;
}



// WARNING: Unknown calling convention

LineTypePtr
CreateNewLineInSymbol
          (SymbolTypePtr Symbol,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness)

{
  Cardinal CVar1;
  LineTypePtr pLVar2;
  uint uVar3;
  LineTypePtr line;
  uint uVar4;
  LineTypePtr pLVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  uVar4 = Symbol->LineN;
  pLVar2 = Symbol->Line;
  if (Symbol->LineMax <= uVar4) {
    CVar1 = Symbol->LineMax + 10;
    uVar4 = 0x370;
    Symbol->LineMax = CVar1;
    pLVar2 = (LineTypePtr)MyRealloc(pLVar2,CVar1 * 0x58,"CreateNewLineInSymbol()");
    pLVar5 = pLVar2 + Symbol->LineN;
    bVar6 = ((uint)pLVar5 & 1) != 0;
    Symbol->Line = pLVar2;
    if (bVar6) {
      *(undefined *)&(pLVar5->BoundingBox).X1 = 0;
      uVar4 = 0x36f;
      pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 1);
    }
    if (((uint)pLVar5 & 2) != 0) {
      *(undefined2 *)&(pLVar5->BoundingBox).X1 = 0;
      uVar4 = uVar4 - 2;
      pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 2);
    }
    for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
      (pLVar5->BoundingBox).X1 = 0;
      pLVar5 = (LineTypePtr)((int)pLVar5 + ((uint)bVar7 * -2 + 1) * 4);
    }
    if ((uVar4 & 2) != 0) {
      *(undefined2 *)&(pLVar5->BoundingBox).X1 = 0;
      pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 2);
    }
    if (bVar6) {
      *(undefined *)&(pLVar5->BoundingBox).X1 = 0;
      uVar4 = Symbol->LineN;
    }
    else {
      uVar4 = Symbol->LineN;
    }
  }
  Symbol->LineN = uVar4 + 1;
  pLVar2 = pLVar2 + uVar4;
  (pLVar2->Point1).X = X1;
  (pLVar2->Point1).Y = Y1;
  (pLVar2->Point2).X = X2;
  (pLVar2->Point2).Y = Y2;
  pLVar2->Thickness = Thickness;
  return pLVar2;
}



// WARNING: Unknown calling convention

ArcTypePtr
CreateNewArcInElement
          (ElementTypePtr Element,LocationType X,LocationType Y,BDimension Width,BDimension Height,
          int Angle,int Delta,BDimension Thickness)

{
  int iVar1;
  int iVar2;
  ArcTypePtr arc;
  Cardinal CVar3;
  uint uVar4;
  uint uVar5;
  ArcTypePtr paVar6;
  bool bVar7;
  byte bVar8;
  ArcTypePtr local_20;
  
  bVar8 = 0;
  local_20 = Element->Arc;
  uVar5 = Element->ArcN;
  if (Element->ArcMax <= uVar5) {
    CVar3 = Element->ArcMax + 5;
    Element->ArcMax = CVar3;
    local_20 = (ArcTypePtr)MyRealloc(local_20,CVar3 * 0x44,"CreateNewArcInElement()");
    Element->Arc = local_20;
    uVar5 = 0x154;
    paVar6 = local_20 + Element->ArcN;
    bVar7 = ((uint)paVar6 & 1) != 0;
    if (bVar7) {
      *(undefined *)&(paVar6->BoundingBox).X1 = 0;
      uVar5 = 0x153;
      paVar6 = (ArcTypePtr)((int)&(paVar6->BoundingBox).X1 + 1);
    }
    if (((uint)paVar6 & 2) != 0) {
      *(undefined2 *)&(paVar6->BoundingBox).X1 = 0;
      uVar5 = uVar5 - 2;
      paVar6 = (ArcTypePtr)((int)&(paVar6->BoundingBox).X1 + 2);
    }
    for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
      (paVar6->BoundingBox).X1 = 0;
      paVar6 = (ArcTypePtr)((int)paVar6 + (uint)bVar8 * -8 + 4);
    }
    if ((uVar5 & 2) != 0) {
      *(undefined2 *)&(paVar6->BoundingBox).X1 = 0;
      paVar6 = (ArcTypePtr)((int)&(paVar6->BoundingBox).X1 + 2);
    }
    if (bVar7) {
      *(undefined *)&(paVar6->BoundingBox).X1 = 0;
      uVar5 = Element->ArcN;
    }
    else {
      uVar5 = Element->ArcN;
    }
  }
  iVar1 = Delta % 0x168;
  if (iVar1 == 0) {
    iVar1 = 0x168;
  }
  else if (iVar1 < 0) {
    Angle = Angle + iVar1;
    iVar1 = -iVar1;
  }
  iVar2 = Angle % 0x168;
  if (iVar2 < 0) {
    iVar2 = iVar2 + 0x168;
  }
  Element->ArcN = uVar5 + 1;
  local_20 = local_20 + uVar5;
  local_20->X = X;
  local_20->StartAngle = iVar2;
  local_20->Delta = iVar1;
  local_20->Y = Y;
  local_20->Width = Width;
  local_20->Thickness = Thickness;
  local_20->Height = Height;
  local_20->ID = ID;
  ID = ID + 1;
  return local_20;
}



// WARNING: Unknown calling convention

PadTypePtr
CreateNewPad(ElementTypePtr Element,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
            BDimension Thickness,BDimension Clearance,BDimension Mask,char *Name,char *Number,
            FlagType Flags)

{
  PadTypePtr paVar1;
  char *pcVar2;
  PadTypePtr pad;
  
  paVar1 = GetPadMemory(Element);
  if ((X2 < X1) || ((Y2 < Y1 && (X1 == X2)))) {
    (paVar1->Point1).X = X2;
    (paVar1->Point1).Y = Y2;
    (paVar1->Point2).X = X1;
    (paVar1->Point2).Y = Y1;
  }
  else {
    (paVar1->Point1).X = X1;
    (paVar1->Point1).Y = Y1;
    (paVar1->Point2).X = X2;
    (paVar1->Point2).Y = Y2;
  }
  paVar1->Thickness = Thickness;
  paVar1->Clearance = Clearance;
  paVar1->Mask = Mask;
  pcVar2 = MyStrdup(Name,"CreateNewPad()");
  paVar1->Name = pcVar2;
  pcVar2 = MyStrdup(Number,"CreateNewPad()");
  paVar1->Number = pcVar2;
  (paVar1->Flags).t[7] = Flags.t[7];
  (paVar1->Flags).t[6] = Flags.t[6];
  (paVar1->Flags).t[5] = Flags.t[5];
  (paVar1->Flags).t[4] = Flags.t[4];
  (paVar1->Flags).t[3] = Flags.t[3];
  (paVar1->Flags).t[2] = Flags.t[2];
  (paVar1->Flags).t[1] = Flags.t[1];
  (paVar1->Flags).t[0] = Flags.t[0];
  (paVar1->Flags).f = Flags.f & 0xfffffdff;
  paVar1->ID = ID;
  ID = ID + 1;
  paVar1->Element = Element;
  return paVar1;
}



// WARNING: Unknown calling convention

PinTypePtr
CreateNewPin(ElementTypePtr Element,LocationType X,LocationType Y,BDimension Thickness,
            BDimension Clearance,BDimension Mask,BDimension DrillingHole,char *Name,char *Number,
            FlagType Flags)

{
  Boolean BVar1;
  PinTypePtr paVar2;
  char *pcVar3;
  int iVar4;
  PinTypePtr pin;
  
  paVar2 = GetPinMemory(Element);
  paVar2->X = X;
  paVar2->Y = Y;
  paVar2->Thickness = Thickness;
  paVar2->Clearance = Clearance;
  paVar2->Mask = Mask;
  pcVar3 = MyStrdup(Name,"CreateNewPin()");
  paVar2->Name = pcVar3;
  pcVar3 = MyStrdup(Number,"CreateNewPin()");
  paVar2->Element = Element;
  (paVar2->Flags).t[7] = Flags.t[7];
  paVar2->Number = pcVar3;
  (paVar2->Flags).t[6] = Flags.t[6];
  (paVar2->Flags).t[5] = Flags.t[5];
  (paVar2->Flags).t[4] = Flags.t[4];
  (paVar2->Flags).t[3] = Flags.t[3];
  (paVar2->Flags).t[2] = Flags.t[2];
  (paVar2->Flags).t[1] = Flags.t[1];
  (paVar2->Flags).t[0] = Flags.t[0];
  (paVar2->Flags).f = Flags.f & 0xfffffdff | 1;
  paVar2->ID = ID;
  ID = ID + 1;
  iVar4 = vendorDrillMap(DrillingHole);
  paVar2->DrillingHole = iVar4;
  BVar1 = vendorIsElementMappable(Element);
  if (BVar1 == '\0') {
    paVar2->DrillingHole = DrillingHole;
  }
  else {
    iVar4 = paVar2->DrillingHole;
    if (iVar4 < 2000) {
      if ((Name == (char *)0x0) || (*Name == '\0')) {
        Name = "(unknown)";
      }
      if ((Number == (char *)0x0) || (*Number == '\0')) {
        Number = "(unknown)";
      }
      Message("Did not map pin #%s (%s) drill hole because %6.2f mil is below the minimum allowed size\n"
              ,Number,Name,(double)iVar4 * 0.01);
      paVar2->DrillingHole = DrillingHole;
      return paVar2;
    }
    if (10000000 < iVar4) {
      if ((Name == (char *)0x0) || (*Name == '\0')) {
        Name = "(unknown)";
      }
      if ((Number == (char *)0x0) || (*Number == '\0')) {
        Number = "(unknown)";
      }
      Message("Did not map pin #%s (%s) drill hole because %6.2f mil is above the maximum allowed size\n"
              ,Number,Name,(double)iVar4 * 0.01);
      paVar2->DrillingHole = DrillingHole;
      return paVar2;
    }
    if (((*(byte *)&(paVar2->Flags).f & 8) == 0) && (paVar2->Thickness + -399 <= iVar4)) {
      if ((Name == (char *)0x0) || (*Name == '\0')) {
        Name = "(unknown)";
      }
      if ((Number == (char *)0x0) || (*Number == '\0')) {
        Number = "(unknown)";
      }
      Message("Did not map pin #%s (%s) drill hole because %6.2f mil does not leave enough copper\n"
              ,Number,Name,(double)iVar4 * 0.01);
      paVar2->DrillingHole = DrillingHole;
    }
    else if (DrillingHole != iVar4) {
      Message("Mapped pin drill hole to %.2f mils from %.2f mils per vendor table\n",
              (double)iVar4 * 0.01,(double)DrillingHole * 0.01);
      return paVar2;
    }
  }
  return paVar2;
}



// WARNING: Unknown calling convention

LineTypePtr
CreateNewLineInElement
          (ElementTypePtr Element,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness)

{
  LineTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  LineTypePtr pLVar3;
  LineTypePtr line;
  bool bVar4;
  byte bVar5;
  uint local_30;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  bVar5 = 0;
  pLVar3 = (LineTypePtr)0x0;
  Ptr = Element->Line;
  if (Thickness != 0) {
    uVar2 = Element->LineN;
    if (Element->LineMax <= uVar2) {
      CVar1 = Element->LineMax + 10;
      Element->LineMax = CVar1;
      Ptr = (LineTypePtr)MyRealloc(Ptr,CVar1 * 0x58,"CreateNewLineInElement()");
      local_30 = 0x370;
      pLVar3 = Ptr + Element->LineN;
      bVar4 = ((uint)pLVar3 & 1) != 0;
      Element->Line = Ptr;
      if (bVar4) {
        *(undefined *)&(pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)&(pLVar3->BoundingBox).X1 + 1);
        local_30 = 0x36f;
      }
      if (((uint)pLVar3 & 2) != 0) {
        *(undefined2 *)&(pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)&(pLVar3->BoundingBox).X1 + 2);
        local_30 = local_30 - 2;
      }
      for (uVar2 = local_30 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
        (pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)pLVar3 + (uint)bVar5 * -8 + 4);
      }
      if ((local_30 & 2) != 0) {
        *(undefined2 *)&(pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)&(pLVar3->BoundingBox).X1 + 2);
      }
      if (bVar4) {
        *(undefined *)&(pLVar3->BoundingBox).X1 = 0;
      }
      uVar2 = Element->LineN;
    }
    Element->LineN = uVar2 + 1;
    pLVar3 = Ptr + uVar2;
    (pLVar3->Point1).X = X1;
    (pLVar3->Point1).Y = Y1;
    (pLVar3->Point2).X = X2;
    pLVar3->Thickness = Thickness;
    (pLVar3->Point2).Y = Y2;
    MakeFlags(0);
    (pLVar3->Flags).f = local_2c;
    *(undefined4 *)(pLVar3->Flags).t = local_28;
    *(undefined4 *)((pLVar3->Flags).t + 4) = local_24;
    pLVar3->ID = ID;
    ID = ID + 1;
  }
  return pLVar3;
}



// WARNING: Unknown calling convention

void AddTextToElement(TextTypePtr Text,FontTypePtr PCBFont,LocationType X,LocationType Y,
                     BYTE Direction,char *TextString,int Scale,FlagType Flags)

{
  char *pcVar1;
  
  SaveFree(Text->TextString);
  Text->TextString = (char *)0x0;
  (Text->Flags).t[7] = Flags.t[7];
  Text->Direction = Direction;
  (Text->Flags).t[6] = Flags.t[6];
  Text->X = X;
  (Text->Flags).t[5] = Flags.t[5];
  (Text->Flags).t[4] = Flags.t[4];
  Text->Y = Y;
  (Text->Flags).t[3] = Flags.t[3];
  (Text->Flags).t[2] = Flags.t[2];
  (Text->Flags).t[1] = Flags.t[1];
  (Text->Flags).t[0] = Flags.t[0];
  (Text->Flags).f = Flags.f;
  Text->Scale = Scale;
  if ((TextString == (char *)0x0) || (*TextString == '\0')) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = MyStrdup(TextString,"AddTextToElement()");
  }
  Text->TextString = pcVar1;
  SetTextBoundingBox(PCBFont,Text);
  Text->ID = ID;
  ID = ID + 1;
  return;
}



// WARNING: Unknown calling convention

ElementTypePtr
CreateNewElement(DataTypePtr Data,ElementTypePtr Element,FontTypePtr PCBFont,FlagType Flags,
                char *Description,char *NameOnPCB,char *Value,LocationType TextX,LocationType TextY,
                BYTE Direction,int TextScale,FlagType TextFlags,Boolean uniqueName)

{
  int Scale;
  
  if (Element == (ElementTypePtr)0x0) {
    Element = GetElementMemory(Data);
  }
  Scale = 10;
  if (9 < TextScale) {
    Scale = TextScale;
  }
  AddTextToElement(Element->Name,PCBFont,TextX,TextY,Direction,Description,Scale,TextFlags);
  if (uniqueName != '\0') {
    NameOnPCB = UniqueElementName(Data,NameOnPCB);
  }
  AddTextToElement(Element->Name + 1,PCBFont,TextX,TextY,Direction,NameOnPCB,Scale,TextFlags);
  AddTextToElement(Element->Name + 2,PCBFont,TextX,TextY,Direction,Value,Scale,TextFlags);
  Element->Name[0].Element = Element;
  Element->Name[1].Element = Element;
  Element->Name[2].Element = Element;
  (Element->Flags).t[7] = Flags.t[7];
  (Element->Flags).t[6] = Flags.t[6];
  (Element->Flags).t[5] = Flags.t[5];
  (Element->Flags).t[4] = Flags.t[4];
  (Element->Flags).t[3] = Flags.t[3];
  (Element->Flags).t[2] = Flags.t[2];
  (Element->Flags).t[1] = Flags.t[1];
  (Element->Flags).t[0] = Flags.t[0];
  (Element->Flags).f = Flags.f;
  Element->ID = ID;
  ID = ID + 1;
  return Element;
}



// WARNING: Unknown calling convention

PointTypePtr CreateNewPointInPolygon(PolygonTypePtr Polygon,LocationType X,LocationType Y)

{
  PointTypePtr point;
  PointTypePtr pPVar1;
  
  pPVar1 = GetPointMemoryInPolygon(Polygon);
  pPVar1->X = X;
  pPVar1->Y = Y;
  pPVar1->ID = ID;
  ID = ID + 1;
  return pPVar1;
}



// WARNING: Unknown calling convention

PolygonTypePtr CreateNewPolygon(LayerTypePtr Layer,FlagType Flags)

{
  PolygonTypePtr polygon;
  PolygonTypePtr ppVar1;
  
  ppVar1 = GetPolygonMemory(Layer);
  (ppVar1->Flags).t[7] = Flags.t[7];
  (ppVar1->Flags).t[6] = Flags.t[6];
  (ppVar1->Flags).t[5] = Flags.t[5];
  (ppVar1->Flags).t[4] = Flags.t[4];
  ppVar1->Clipped = (POLYAREA *)0x0;
  ppVar1->NoHoles = (PLINE *)0x0;
  (ppVar1->Flags).t[3] = Flags.t[3];
  (ppVar1->Flags).t[2] = Flags.t[2];
  (ppVar1->Flags).t[1] = Flags.t[1];
  (ppVar1->Flags).t[0] = Flags.t[0];
  (ppVar1->Flags).f = Flags.f;
  ppVar1->ID = ID;
  ID = ID + 1;
  ppVar1->NoHolesValid = 0;
  return ppVar1;
}



// WARNING: Unknown calling convention

TextTypePtr
CreateNewText(LayerTypePtr Layer,FontTypePtr PCBFont,LocationType X,LocationType Y,BYTE Direction,
             int Scale,char *TextString,FlagType Flags)

{
  TextTypePtr Text;
  TextTypePtr text;
  char *pcVar1;
  rtree_t *rtree;
  
  Text = GetTextMemory(Layer);
  if (Text != (TextTypePtr)0x0) {
    Text->X = X;
    Text->Y = Y;
    Text->Direction = Direction;
    (Text->Flags).t[7] = Flags.t[7];
    (Text->Flags).t[6] = Flags.t[6];
    (Text->Flags).t[5] = Flags.t[5];
    (Text->Flags).t[4] = Flags.t[4];
    (Text->Flags).t[3] = Flags.t[3];
    (Text->Flags).t[2] = Flags.t[2];
    (Text->Flags).t[1] = Flags.t[1];
    (Text->Flags).t[0] = Flags.t[0];
    (Text->Flags).f = Flags.f;
    Text->Scale = Scale;
    pcVar1 = MyStrdup(TextString,"CreateNewText()");
    Text->TextString = pcVar1;
    SetTextBoundingBox(PCBFont,Text);
    Text->ID = ID;
    ID = ID + 1;
    rtree = Layer->text_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->text_tree = rtree;
    }
    r_insert_entry(rtree,&Text->BoundingBox,0);
  }
  return Text;
}



// WARNING: Unknown calling convention

PolygonTypePtr
CreateNewPolygonFromRectangle
          (LayerTypePtr Layer,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          FlagType Flags)

{
  PolygonTypePtr Polygon;
  PolygonTypePtr polygon;
  rtree_t *rtree;
  
  Polygon = CreateNewPolygon(Layer,Flags);
  if (Polygon != (PolygonTypePtr)0x0) {
    CreateNewPointInPolygon(Polygon,X1,Y1);
    CreateNewPointInPolygon(Polygon,X2,Y1);
    CreateNewPointInPolygon(Polygon,X2,Y2);
    CreateNewPointInPolygon(Polygon,X1,Y2);
    SetPolygonBoundingBox(Polygon);
    rtree = Layer->polygon_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->polygon_tree = rtree;
    }
    r_insert_entry(rtree,&Polygon->BoundingBox,0);
  }
  return Polygon;
}



// WARNING: Unknown calling convention

ArcTypePtr
CreateNewArcOnLayer(LayerTypePtr Layer,LocationType X1,LocationType Y1,BDimension width,
                   BDimension height,int sa,int dir,BDimension Thickness,BDimension Clearance,
                   FlagType Flags)

{
  ArcTypePtr Arc_00;
  rtree_t *rtree;
  LocationType *pLVar1;
  Cardinal n;
  ArcTypePtr Arc;
  
  n = Layer->ArcN - 1;
  if (n != 0xffffffff) {
    pLVar1 = &Layer->Arc[Layer->ArcN - 1].X;
    do {
      if ((((*pLVar1 == X1) && (pLVar1[1] == Y1)) && (pLVar1[-2] == width)) &&
         (((pLVar1[2] + 0x168) % 0x168 == (sa + 0x168) % 0x168 && (pLVar1[3] == dir)))) {
        return (ArcTypePtr)0x0;
      }
      n = n - 1;
      pLVar1 = pLVar1 + -0x11;
    } while (n != 0xffffffff);
  }
  Arc_00 = GetArcMemory(Layer);
  if (Arc_00 != (ArcTypePtr)0x0) {
    Arc_00->ID = ID;
    ID = ID + 1;
    (Arc_00->Flags).t[7] = Flags.t[7];
    (Arc_00->Flags).t[6] = Flags.t[6];
    (Arc_00->Flags).t[5] = Flags.t[5];
    (Arc_00->Flags).t[4] = Flags.t[4];
    (Arc_00->Flags).t[3] = Flags.t[3];
    (Arc_00->Flags).t[2] = Flags.t[2];
    (Arc_00->Flags).t[1] = Flags.t[1];
    (Arc_00->Flags).t[0] = Flags.t[0];
    Arc_00->Thickness = Thickness;
    (Arc_00->Flags).f = Flags.f;
    Arc_00->X = X1;
    Arc_00->Y = Y1;
    Arc_00->Clearance = Clearance;
    Arc_00->StartAngle = sa;
    Arc_00->Width = width;
    Arc_00->Height = height;
    Arc_00->Delta = dir;
    SetArcBoundingBox(Arc_00);
    rtree = Layer->arc_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->arc_tree = rtree;
    }
    r_insert_entry(rtree,&Arc_00->BoundingBox,0);
  }
  return Arc_00;
}



// WARNING: Unknown calling convention

RatTypePtr
CreateNewRat(DataTypePtr Data,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
            Cardinal group1,Cardinal group2,BDimension Thickness,FlagType Flags)

{
  int iVar1;
  RatTypePtr Line_00;
  RatTypePtr Line;
  rtree_t *rtree;
  
  Line_00 = GetRatMemory(Data);
  if (Line_00 != (RatTypePtr)0x0) {
    (Line_00->Flags).t[7] = Flags.t[7];
    (Line_00->Flags).t[6] = Flags.t[6];
    Line_00->ID = ID;
    (Line_00->Point1).ID = ID + 1;
    iVar1 = ID + 2;
    ID = ID + 3;
    (Line_00->Point2).ID = iVar1;
    (Line_00->Flags).t[5] = Flags.t[5];
    (Line_00->Flags).t[4] = Flags.t[4];
    (Line_00->Flags).t[3] = Flags.t[3];
    (Line_00->Flags).t[2] = Flags.t[2];
    (Line_00->Flags).t[1] = Flags.t[1];
    (Line_00->Flags).t[0] = Flags.t[0];
    (Line_00->Flags).f = Flags.f | 0x10;
    Line_00->Thickness = Thickness;
    (Line_00->Point1).X = X1;
    (Line_00->Point1).Y = Y1;
    (Line_00->Point2).X = X2;
    (Line_00->Point2).Y = Y2;
    Line_00->group1 = group1;
    Line_00->group2 = group2;
    SetLineBoundingBox((LineTypePtr)Line_00);
    rtree = Data->rat_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Data->rat_tree = rtree;
    }
    r_insert_entry(rtree,&Line_00->BoundingBox,0);
  }
  return Line_00;
}



// WARNING: Unknown calling convention

LineTypePtr
CreateNewLineOnLayer
          (LayerTypePtr Layer,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness,BDimension Clearance,FlagType Flags)

{
  int iVar1;
  LineTypePtr Line_00;
  LineTypePtr Line;
  rtree_t *rtree;
  
  Line_00 = GetLineMemory(Layer);
  if (Line_00 != (LineTypePtr)0x0) {
    (Line_00->Flags).t[7] = Flags.t[7];
    (Line_00->Flags).t[6] = Flags.t[6];
    Line_00->ID = ID;
    (Line_00->Point1).ID = ID + 1;
    iVar1 = ID + 2;
    ID = ID + 3;
    (Line_00->Point2).ID = iVar1;
    (Line_00->Flags).t[5] = Flags.t[5];
    (Line_00->Flags).t[4] = Flags.t[4];
    (Line_00->Flags).t[3] = Flags.t[3];
    (Line_00->Flags).t[2] = Flags.t[2];
    (Line_00->Flags).t[1] = Flags.t[1];
    (Line_00->Flags).t[0] = Flags.t[0];
    (Line_00->Flags).f = Flags.f & 0xffffffef;
    Line_00->Thickness = Thickness;
    Line_00->Clearance = Clearance;
    (Line_00->Point1).X = X1;
    (Line_00->Point1).Y = Y1;
    (Line_00->Point2).X = X2;
    (Line_00->Point2).Y = Y2;
    SetLineBoundingBox(Line_00);
    rtree = Layer->line_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->line_tree = rtree;
    }
    r_insert_entry(rtree,&Line_00->BoundingBox,0);
  }
  return Line_00;
}



// WARNING: Unknown calling convention

LineTypePtr
CreateDrawnLineOnLayer
          (LayerTypePtr Layer,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness,BDimension Clearance,FlagType Flags)

{
  int iVar1;
  FlagType Flags_00;
  int iVar2;
  LineTypePtr pLVar3;
  int in_GS_OFFSET;
  BoxType search;
  line_info info;
  
  Flags_00 = Flags;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  search.X1 = X1;
  if (X2 <= X1) {
    search.X1 = X2;
  }
  search.X2 = X1;
  if (X1 <= X2) {
    search.X2 = X2;
  }
  search.Y1 = Y1;
  if (Y2 <= Y1) {
    search.Y1 = Y2;
  }
  search.Y2 = Y1;
  if (Y1 <= Y2) {
    search.Y2 = Y2;
  }
  if (search.Y1 == search.Y2) {
    search.Y2 = search.Y1 + 1;
  }
  if (search.X1 == search.X2) {
    search.X2 = search.X1 + 1;
  }
  info.test.Thickness = 0;
  info.X1 = X1;
  info.X2 = X2;
  info.Y1 = Y1;
  info.Y2 = Y2;
  info.Thickness = Thickness;
  info.Flags.f = Flags.f;
  info.Flags.t[0] = Flags.t[0];
  info.Flags.t[1] = Flags.t[1];
  info.Flags.t[2] = Flags.t[2];
  info.Flags.t[3] = Flags.t[3];
  info.Flags.t[4] = Flags.t[4];
  info.Flags.t[5] = Flags.t[5];
  info.Flags.t[6] = Flags.t[6];
  info.Flags.t[7] = Flags.t[7];
  MakeFlags(0);
  info.ans = (LineType *)0x0;
  iVar2 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar2 == 0) {
    r_search(Layer->line_tree,&search,(_func_int_BoxType_ptr_void_ptr *)0x0,line_callback,&info);
  }
  else {
    pLVar3 = (LineTypePtr)0x0;
    if (info.ans == (LineType *)0xffffffff) goto LAB_0808019b;
    if (info.ans != (LineType *)0x0) {
      MoveObjectToRemoveUndoList(4,Layer,info.ans,info.ans);
      X1 = info.test.Point1.X;
      X2 = info.test.Point2.X;
      Y1 = info.test.Point1.Y;
      Y2 = info.test.Point2.Y;
    }
  }
  pLVar3 = CreateNewLineOnLayer(Layer,X1,Y1,X2,Y2,Thickness,Clearance,Flags_00);
LAB_0808019b:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pLVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int line_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  Boolean BVar3;
  LocationType LVar4;
  int iVar5;
  
                    // WARNING: Load size is inaccurate
  iVar1 = *cl;
  iVar2 = b[2].Y2;
  if (iVar2 == iVar1) {
    iVar5 = b[4].X1;
    if (((iVar5 == *(int *)((int)cl + 4)) && (b[3].X1 == *(int *)((int)cl + 8))) &&
       (b[4].Y1 == *(int *)((int)cl + 0xc))) goto LAB_08080331;
  }
  else {
    iVar5 = b[4].X1;
  }
  if (((iVar1 == iVar5) && (iVar2 == *(int *)((int)cl + 4))) &&
     ((b[4].Y1 == *(int *)((int)cl + 8) && (b[3].X1 == *(int *)((int)cl + 0xc))))) {
LAB_08080331:
    *(undefined4 *)((int)cl + 0x78) = 0xffffffff;
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x7c,1);
  }
  if ((b[2].Y1 == *(int *)((int)cl + 0x10)) && (((b[1].Y1 ^ *(uint *)((int)cl + 0x14)) & 0x20) == 0)
     ) {
    if ((iVar2 == iVar1) && (b[3].X1 == *(int *)((int)cl + 8))) {
      LVar4 = b[4].Y1;
      *(int *)((int)cl + 0x4c) = iVar5;
    }
    else {
      if ((iVar1 != iVar5) || (b[4].Y1 != *(int *)((int)cl + 8))) {
        if ((iVar2 == *(int *)((int)cl + 4)) && (b[3].X1 == *(int *)((int)cl + 0xc))) {
          *(int *)((int)cl + 0x4c) = iVar5;
          LVar4 = b[4].Y1;
        }
        else {
          if (iVar5 != *(int *)((int)cl + 4)) {
            return 0;
          }
          if (b[4].Y1 != *(int *)((int)cl + 0xc)) {
            return 0;
          }
          *(int *)((int)cl + 0x4c) = iVar2;
          LVar4 = b[3].X1;
        }
        *(int *)((int)cl + 0x60) = iVar1;
        *(LocationType *)((int)cl + 0x50) = LVar4;
        *(undefined4 *)((int)cl + 100) = *(undefined4 *)((int)cl + 8);
        BVar3 = IsPointOnLine((float)*(int *)((int)cl + 4),(float)*(int *)((int)cl + 0xc),0.0,
                              (LineTypePtr)((int)cl + 0x20));
        if (BVar3 == '\0') {
          return 0;
        }
        goto LAB_080802f5;
      }
      *(int *)((int)cl + 0x4c) = iVar2;
      LVar4 = b[3].X1;
    }
    *(LocationType *)((int)cl + 0x50) = LVar4;
    *(undefined4 *)((int)cl + 0x60) = *(undefined4 *)((int)cl + 4);
    *(undefined4 *)((int)cl + 100) = *(undefined4 *)((int)cl + 0xc);
                    // WARNING: Load size is inaccurate
    BVar3 = IsPointOnLine((float)*cl,(float)*(int *)((int)cl + 8),0.0,(LineTypePtr)((int)cl + 0x20))
    ;
    if (BVar3 != '\0') {
LAB_080802f5:
      *(BoxType **)((int)cl + 0x78) = b;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x7c,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

PinTypePtr
CreateNewVia(DataTypePtr Data,LocationType X,LocationType Y,BDimension Thickness,
            BDimension Clearance,BDimension Mask,BDimension DrillingHole,char *Name,FlagType Flags)

{
  PinTypePtr paVar1;
  int iVar2;
  char *pcVar3;
  rtree_t *rtree;
  uint uVar4;
  Cardinal n;
  PinTypePtr Via;
  longdouble lVar5;
  longdouble lVar6;
  longdouble lVar7;
  
  if (Data->ViaN != 0) {
    paVar1 = Data->Via;
    uVar4 = 0;
    do {
      lVar5 = (longdouble)(paVar1->X - X);
      lVar6 = (longdouble)(paVar1->Y - Y);
      lVar7 = (longdouble)(paVar1->Thickness / 2 + Thickness / 2);
      if (lVar6 * lVar6 + lVar5 * lVar5 <= lVar7 * lVar7) {
        Message("Dropping via at (%d, %d) because it would overlap with the viaat (%d, %d)\n",
                X / 100,Y / 100,paVar1->X / 100,paVar1->Y / 100);
        return (PinTypePtr)0x0;
      }
      uVar4 = uVar4 + 1;
      paVar1 = paVar1 + 1;
    } while (uVar4 < Data->ViaN);
  }
  paVar1 = GetViaMemory(Data);
  if (paVar1 != (PinTypePtr)0x0) {
    paVar1->X = X;
    paVar1->Y = Y;
    paVar1->Thickness = Thickness;
    paVar1->Clearance = Clearance;
    paVar1->Mask = Mask;
    iVar2 = vendorDrillMap(DrillingHole);
    paVar1->DrillingHole = iVar2;
    if (DrillingHole != iVar2) {
      Message("Mapped via drill hole to %.2f mils from %.2f mils per vendor table\n",
              (double)iVar2 * 0.01,(double)DrillingHole * 0.01);
    }
    pcVar3 = MyStrdup(Name,"CreateNewVia()");
    paVar1->Name = pcVar3;
    (paVar1->Flags).t[7] = Flags.t[7];
    (paVar1->Flags).t[6] = Flags.t[6];
    (paVar1->Flags).t[5] = Flags.t[5];
    (paVar1->Flags).t[4] = Flags.t[4];
    (paVar1->Flags).t[3] = Flags.t[3];
    (paVar1->Flags).t[2] = Flags.t[2];
    (paVar1->Flags).t[1] = Flags.t[1];
    (paVar1->Flags).t[0] = Flags.t[0];
    paVar1->ID = ID;
    ID = ID + 1;
    (paVar1->Flags).f = Flags.f & 0xfffffdff | 2;
    if ((((undefined  [12])Flags & (undefined  [12])0x8) == (undefined  [12])0x0) &&
       (paVar1->Thickness <= paVar1->DrillingHole + 399)) {
      iVar2 = paVar1->DrillingHole + 400;
      paVar1->Thickness = iVar2;
      Message("Increased via thickness to %.2f mils to allow enough copper at (%.2f,%.2f).\n",
              (double)iVar2 * 0.01,(double)paVar1->X * 0.01,(double)paVar1->Y * 0.01);
    }
    SetPinBoundingBox(paVar1);
    rtree = Data->via_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Data->via_tree = rtree;
    }
    r_insert_entry(rtree,&paVar1->BoundingBox,0);
  }
  return paVar1;
}



// WARNING: Unknown calling convention

int CreateNewPCBPost(PCBTypePtr pcb,int use_defaults)

{
  DataTypePtr paVar1;
  DataTypePtr paVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  
  pcb_colors_from_settings(pcb);
  iVar3 = 0;
  if (use_defaults != 0) {
    iVar4 = ParseGroupString(Settings.Groups,&pcb->LayerGroups,8);
    iVar3 = 1;
    if (iVar4 == 0) {
      paVar1 = pcb->Data;
      iVar3 = PCB->Data->LayerN;
      pcVar5 = MyStrdup("silk","CreateNewPCB()");
      paVar2 = pcb->Data;
      paVar1->Layer[iVar3 + 1].Name = pcVar5;
      iVar3 = PCB->Data->LayerN;
      pcVar5 = MyStrdup("silk","CreateNewPCB()");
      paVar2->Layer[iVar3].Name = pcVar5;
      iVar3 = 0;
    }
  }
  return iVar3;
}



// WARNING: Unknown calling convention

DataTypePtr CreateNewBuffer(void)

{
  DataTypePtr paVar1;
  
  paVar1 = (DataTypePtr)MyCalloc(1,0x6c4,"CreateNewBuffer()");
  paVar1->pcb = PCB;
  return paVar1;
}



// WARNING: Unknown calling convention

PCBTypePtr CreateNewPCB(Boolean SetDefaultNames)

{
  uint uVar1;
  undefined4 uVar2;
  double dVar3;
  PCBType *pPVar4;
  DataTypePtr paVar5;
  int iVar6;
  char *pcVar7;
  int iVar8;
  Cardinal n;
  PCBTypePtr ptr;
  LayerGroupType *pLVar9;
  int i;
  LayerGroupType *pLVar10;
  byte bVar11;
  
  bVar11 = 0;
  pPVar4 = (PCBType *)MyCalloc(1,0x2210,"CreateNewPCB()");
  paVar5 = CreateNewBuffer();
  paVar5->pcb = pPVar4;
  pPVar4->Data = paVar5;
  uVar1 = (pPVar4->Flags).f;
  pPVar4->ThermStyle = '\x04';
  pPVar4->IsleArea = 200000000.0;
  pPVar4->SilkActive = '\0';
  pPVar4->RatDraw = '\0';
  (pPVar4->Flags).f = uVar1 | 0x40;
  if (Settings.ShowNumber != '\0') {
    (pPVar4->Flags).f = uVar1 | 0x41;
  }
  if (Settings.AllDirectionLines != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x100;
  }
  pPVar4->Clipping = 1;
  if (Settings.RubberBandMode != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x10;
  }
  if (Settings.SwapStartDirection != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x200;
  }
  if (Settings.UniqueNames != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x400;
  }
  if (Settings.SnapPin != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x1000;
  }
  if (Settings.ClearLine != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x800;
  }
  if (Settings.FullPoly != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x100000;
  }
  if (Settings.OrthogonalMoves != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x8000;
  }
  if (Settings.liveRouting != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x10000;
  }
  if (Settings.ShowDRC != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 8;
  }
  if (Settings.AutoDRC != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x80;
  }
  dVar3 = Settings.Grid;
  iVar6 = 0;
  pLVar9 = &Settings.LayerGroups;
  pLVar10 = &pPVar4->LayerGroups;
  for (iVar8 = 0x130; iVar8 != 0; iVar8 = iVar8 + -1) {
    pLVar10->Number[0] = pLVar9->Number[0];
    pLVar9 = (LayerGroupType *)((int)pLVar9 + ((uint)bVar11 * -2 + 1) * 4);
    pLVar10 = (LayerGroupType *)((int)pLVar10 + (uint)bVar11 * -8 + 4);
  }
  pPVar4->Grid = dVar3;
  n = 0;
  do {
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Thick + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Thick + iVar6);
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Diameter + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Diameter + iVar6);
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Hole + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Hole + iVar6);
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Keepaway + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Keepaway + iVar6);
    uVar2 = *(undefined4 *)((int)&Settings.RouteStyle[0].Name + iVar6);
    *(Cardinal *)((int)&pPVar4->RouteStyle[0].index + iVar6) = n;
    n = n + 1;
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Name + iVar6) = uVar2;
    iVar6 = iVar6 + 0x18;
  } while (n != 4);
  hid_action("RouteStylesChanged");
  pPVar4->MaxWidth = Settings.MaxWidth;
  iVar6 = Settings.MaxHeight;
  pPVar4->Zoom = Settings.Zoom;
  pPVar4->MaxHeight = iVar6;
  pPVar4->ThermScale = 0.5;
  pPVar4->ID = ID;
  ID = ID + 1;
  pPVar4->Bloat = Settings.Bloat;
  pPVar4->Shrink = Settings.Shrink;
  pPVar4->minWid = Settings.minWid;
  pPVar4->minSlk = Settings.minSlk;
  pPVar4->minDrill = Settings.minDrill;
  pPVar4->minRing = Settings.minRing;
  iVar6 = 0;
  do {
    paVar5 = pPVar4->Data;
    pcVar7 = MyStrdup(Settings.DefaultLayerName[iVar6],"CreateNewPCB()");
    iVar8 = iVar6 + 1;
    paVar5->Layer[iVar6].Name = pcVar7;
    iVar6 = iVar8;
  } while (iVar8 != 0x10);
  return pPVar4;
}



// WARNING: Unknown calling convention

void XORPolygon(PolygonTypePtr polygon,LocationType dx,LocationType dy)

{
  PointTypePtr pPVar1;
  PointTypePtr pPVar2;
  int i;
  uint uVar3;
  uint uVar4;
  
  if (polygon->PointN != 1) {
    uVar3 = 0;
    do {
      uVar4 = uVar3 + 1;
      pPVar2 = polygon->Points + uVar3 + 1;
      pPVar1 = polygon->Points + uVar3;
      (*gui->draw_line)(Crosshair.GC,dx + pPVar1->X,dy + pPVar1->Y,dx + pPVar2->X,dy + pPVar2->Y);
      uVar3 = uVar4;
    } while (uVar4 < polygon->PointN - 1);
    if (uVar4 != 1) {
      pPVar2 = polygon->Points;
      (*gui->draw_line)(Crosshair.GC,dx + pPVar2[uVar4].X,dy + pPVar2[uVar4].Y,dx + pPVar2->X,
                        pPVar2->Y + dy);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void XORDrawElement(ElementTypePtr Element,LocationType DX,LocationType DY)

{
  LineTypePtr pLVar1;
  ArcTypePtr paVar2;
  PinTypePtr paVar3;
  uint uVar4;
  PadTypePtr paVar5;
  LineTypePtr line;
  Cardinal CVar6;
  ArcTypePtr arc;
  Cardinal sn;
  uint uVar7;
  PinTypePtr pin;
  int iVar8;
  Cardinal n;
  int miny;
  int iVar9;
  Cardinal n_1;
  Cardinal n_2;
  Cardinal sn_1;
  int maxx;
  Cardinal CVar10;
  int iVar11;
  int iVar12;
  uint uVar13;
  PadTypePtr pad;
  int maxy;
  int iVar14;
  int iVar15;
  int local_50;
  int local_34;
  uint local_30;
  
  CVar6 = Element->ArcN;
  if (CVar6 == 0) {
    CVar10 = Element->LineN;
    if (CVar10 == 0) {
      iVar12 = (Element->BoundingBox).X1 + DX;
      (*gui->draw_line)(Crosshair.GC,iVar12,(Element->BoundingBox).Y1 + DY,iVar12,
                        (Element->BoundingBox).Y2 + DY);
      iVar12 = (Element->BoundingBox).Y2 + DY;
      (*gui->draw_line)(Crosshair.GC,(Element->BoundingBox).X1 + DX,iVar12,
                        (Element->BoundingBox).X2 + DX,iVar12);
      iVar12 = (Element->BoundingBox).X2 + DX;
      (*gui->draw_line)(Crosshair.GC,iVar12,(Element->BoundingBox).Y2 + DY,iVar12,
                        (Element->BoundingBox).Y1 + DY);
      iVar12 = (Element->BoundingBox).Y1 + DY;
      (*gui->draw_line)(Crosshair.GC,(Element->BoundingBox).X2 + DX,iVar12,
                        (Element->BoundingBox).X1 + DX,iVar12);
      goto LAB_08080be6;
    }
  }
  else {
    CVar10 = Element->LineN;
  }
  iVar12 = CVar10 - 1;
  if (iVar12 != -1) {
    iVar9 = CVar10 * 0x58;
    do {
      iVar12 = iVar12 + -1;
      pLVar1 = Element->Line;
      (*gui->draw_line)(Crosshair.GC,
                        DX + *(int *)((int)&((PointType *)(&pLVar1[-1].Flags + 2))->Y + iVar9 + -4),
                        *(int *)((int)&((PointType *)(&pLVar1[-1].Flags + 2))->Y + iVar9) + DY,
                        *(int *)((int)(&pLVar1[-1].Flags + 3) + iVar9 + 8) + DX,
                        *(int *)((int)(&pLVar1[-1].Flags + 4) + iVar9) + DY);
      iVar9 = iVar9 + -0x58;
    } while (iVar12 != -1);
    CVar6 = Element->ArcN;
  }
  iVar12 = CVar6 - 1;
  if (iVar12 != -1) {
    iVar9 = CVar6 * 0x44;
    do {
      iVar12 = iVar12 + -1;
      paVar2 = Element->Arc;
      (*gui->draw_arc)(Crosshair.GC,DX + *(int *)((int)(&paVar2[-1].Flags + 2) + iVar9 + 8),
                       DY + *(int *)((int)(&paVar2[-1].Flags + 3) + iVar9),
                       *(int *)((int)(&paVar2[-1].Flags + 2) + iVar9),
                       *(int *)((int)(&paVar2[-1].Flags + 2) + iVar9 + 4),
                       *(int *)((int)(&paVar2[-1].Flags + 3) + iVar9 + 4),
                       *(int *)((int)(&paVar2[-1].Flags + 3) + iVar9 + 8));
      iVar9 = iVar9 + -0x44;
    } while (iVar12 != -1);
  }
LAB_08080be6:
  if (Element->PinN != 0) {
    uVar13 = 0;
    uVar7 = Element->PinN;
    do {
      paVar3 = Element->Pin;
      iVar12 = paVar3[uVar13].Thickness / 2;
      (*gui->draw_arc)(Crosshair.GC,paVar3[uVar13].X + DX,DY + paVar3[uVar13].Y,iVar12,iVar12,0,
                       0x168);
      uVar4 = Element->PinN;
      if (uVar4 == 0) break;
      uVar13 = (uVar4 + 1 + uVar13) - uVar7;
      uVar7 = uVar4;
    } while (uVar13 < uVar4);
  }
  CVar6 = Element->PadN;
  local_34 = 0;
  local_30 = 0;
  CVar10 = CVar6;
  do {
    if ((CVar10 == 0) || (CVar10 <= local_30)) {
      iVar12 = Element->MarkX + DX;
      iVar9 = Element->MarkY + DY;
      (*gui->draw_line)(Crosshair.GC,iVar12 + -1000,iVar9,iVar12,iVar9 + -1000);
      iVar12 = Element->MarkX + DX;
      iVar9 = Element->MarkY + DY;
      (*gui->draw_line)(Crosshair.GC,iVar12 + 1000,iVar9,iVar12,iVar9 + -1000);
      iVar12 = Element->MarkX + DX;
      iVar9 = Element->MarkY + DY;
      (*gui->draw_line)(Crosshair.GC,iVar12 + -1000,iVar9,iVar12,iVar9 + 1000);
      iVar9 = DY + Element->MarkY;
      iVar12 = DX + Element->MarkX;
      (*gui->draw_line)(Crosshair.GC,iVar12 + 1000,iVar9,iVar12,iVar9 + 1000);
      return;
    }
    paVar5 = Element->Pad;
    if (((*(uint *)((paVar5->Flags).t + local_34 + -4) >> 7 & 1) == (int)Settings.ShowSolderSide) ||
       (PCB->InvisibleObjectsOn != '\0')) {
      iVar12 = *(int *)((int)&((PointType *)(&paVar5->Flags + 2))->Y + local_34 + -4);
      iVar9 = *(int *)((int)(&paVar5->Flags + 3) + local_34 + 8);
      if (iVar12 == iVar9) {
        iVar8 = *(int *)((int)&((PointType *)(&paVar5->Flags + 2))->Y + local_34);
        local_50 = *(int *)((int)(&paVar5->Flags + 4) + local_34);
LAB_08080c9b:
        iVar15 = *(int *)((int)(&paVar5->Flags + 1) + local_34 + 4);
        iVar14 = -(iVar15 / 2);
        iVar11 = iVar12;
        if (iVar9 <= iVar12) {
          iVar11 = iVar9;
        }
        iVar11 = iVar11 + iVar14 + DX;
        iVar15 = iVar15 / 2;
        if (iVar12 <= iVar9) {
          iVar12 = iVar9;
        }
        iVar9 = iVar12 + iVar15 + DX;
        iVar12 = local_50;
        if (iVar8 < local_50) {
          iVar12 = iVar8;
        }
        iVar12 = iVar12 + DY + iVar14;
        if (local_50 < iVar8) {
          local_50 = iVar8;
        }
        iVar8 = local_50 + DY + iVar15;
        (*gui->draw_line)(Crosshair.GC,iVar11,iVar12,iVar9,iVar12);
        (*gui->draw_line)(Crosshair.GC,iVar11,iVar12,iVar11,iVar8);
        (*gui->draw_line)(Crosshair.GC,iVar9,iVar12,iVar9,iVar8);
        iVar12 = iVar8;
      }
      else {
        iVar8 = *(int *)((int)&((PointType *)(&paVar5->Flags + 2))->Y + local_34);
        iVar15 = *(int *)((int)(&paVar5->Flags + 4) + local_34);
        local_50 = iVar8;
        if (iVar8 == iVar15) goto LAB_08080c9b;
        iVar9 = iVar9 + DX;
        iVar8 = iVar8 + DY;
        iVar11 = iVar12 + DX;
        iVar12 = iVar15 + DY;
      }
      (*gui->draw_line)(Crosshair.GC,iVar11,iVar8,iVar9,iVar12);
      CVar10 = Element->PadN;
    }
    if (CVar6 == CVar10) {
      local_30 = local_30 + 1;
      local_34 = local_34 + 0x68;
      CVar10 = CVar6;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void DrawMark(Boolean ifvis)

{
  if ((ifvis != '\0') && (Marked.status == '\0')) {
    return;
  }
  (*gui->draw_line)(Crosshair.GC,Marked.X + -5000,Marked.Y + -5000,Marked.X + 5000,Marked.Y + 5000);
  (*gui->draw_line)(Crosshair.GC,Marked.X + 5000,Marked.Y + -5000,Marked.X + -5000,Marked.Y + 5000);
  return;
}



// WARNING: Unknown calling convention

void InitCrosshair(void)

{
  Crosshair.GC = (*gui->make_gc)();
  (*gui->set_color)(Crosshair.GC,Settings.CrosshairColor);
  (*gui->set_draw_xor)(Crosshair.GC,1);
  (*gui->set_line_cap)(Crosshair.GC,Trace_Cap);
  (*gui->set_line_width)(Crosshair.GC,1);
  CrosshairStack[0] = '\x01';
  Crosshair.On = '\0';
  Crosshair.MinY = 0;
  Crosshair.MinX = 0;
  CrosshairStackLocation = 1;
  Crosshair.shape = Basic_Crosshair_Shape;
  Crosshair.MaxX = PCB->MaxWidth;
  Marked.status = '\0';
  Crosshair.MaxY = PCB->MaxHeight;
  return;
}



// WARNING: Unknown calling convention

void FitCrosshairIntoGrid(LocationType X,LocationType Y)

{
  double dVar1;
  void *pvVar2;
  uint uVar3;
  int ans;
  PadTypePtr pad;
  int iVar4;
  int iVar5;
  ElementTypePtr el;
  int iVar6;
  uint uVar7;
  LocationType px;
  uint uVar8;
  int iVar9;
  LocationType x0;
  int iVar10;
  char cVar11;
  LocationType py;
  LocationType y0;
  LocationType LVar12;
  PointTypePtr pnt;
  PinTypePtr pin;
  longdouble lVar13;
  longdouble lVar14;
  longdouble lVar15;
  longdouble lVar16;
  int local_50;
  int local_44;
  uint local_40;
  int *local_28;
  void *local_24;
  void *local_20 [4];
  
  local_44 = PCB->MaxWidth;
  iVar4 = PCB->MaxHeight;
  if (X < Crosshair.MinX) {
    X = Crosshair.MinX;
  }
  Crosshair.X = X;
  if (Crosshair.MaxX < X) {
    Crosshair.X = Crosshair.MaxX;
  }
  if (Y < Crosshair.MinY) {
    Y = Crosshair.MinY;
  }
  Crosshair.Y = Y;
  if (Crosshair.MaxY < Y) {
    Crosshair.Y = Crosshair.MaxY;
  }
  if (PCB->RatDraw == '\0') {
    cVar11 = '\0';
    uVar3 = 0;
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x10) != 0) goto LAB_08081418;
LAB_080811d3:
    if (Settings.Mode != 0x68) goto LAB_080811e2;
LAB_080814ee:
    if (Crosshair.AttachedObject.Type == 1) {
      if ((uVar3 & 0x101) == 0) goto LAB_080811e2;
    }
    else if (((Crosshair.AttachedObject.Type != 2) || ((uVar3 & 0x300) == 0)) ||
            (Crosshair.AttachedObject.Ptr1 != local_20[0])) goto LAB_080811e2;
    local_40 = 0;
    uVar3 = 0;
  }
  else {
LAB_08081418:
    uVar3 = SearchScreen(Crosshair.X,Crosshair.Y,0x300,local_20,&local_24,&local_28);
    if (uVar3 == 0) {
      cVar11 = PCB->RatDraw;
      if (cVar11 != '\0') goto LAB_080811d3;
      uVar3 = SearchScreen(Crosshair.X,Crosshair.Y,0x1001,local_20,&local_24,&local_28);
      if (uVar3 == 0) {
        cVar11 = PCB->RatDraw;
        if (cVar11 != '\0') goto LAB_080811d3;
        uVar3 = SearchScreen(Crosshair.X,Crosshair.Y,2,local_20,&local_24,&local_28);
      }
    }
    cVar11 = PCB->RatDraw;
    if (Settings.Mode == 0x68) goto LAB_080814ee;
LAB_080811e2:
    local_40 = uVar3 & 0x200;
  }
  pvVar2 = local_24;
  local_50 = -600;
  iVar10 = -600;
  if (cVar11 == '\0') {
    if ((Crosshair.X < 0) || (local_44 < Crosshair.X)) {
      dVar1 = PCB->Grid;
      if ((double)(local_44 + 1) < dVar1) {
        local_44 = local_44 / 2;
        goto LAB_08081274;
      }
      local_44 = (int)ROUND((double)(int)ROUND((dVar1 * 0.5 + (dVar1 - (double)PCB->GridOffsetX)) /
                                               dVar1) * dVar1 + 0.5 + (double)PCB->GridOffsetX);
      if (-1 < Crosshair.Y) goto LAB_08081285;
LAB_08081690:
      if ((double)(iVar4 + 1) < dVar1) {
        local_50 = iVar4 / 2;
      }
      else {
        local_50 = (int)ROUND((double)PCB->GridOffsetY +
                              (double)(int)ROUND((dVar1 * 0.5 + (dVar1 - (double)PCB->GridOffsetY))
                                                 / dVar1) * dVar1 + 0.5);
      }
    }
    else {
      dVar1 = PCB->Grid;
      local_44 = (int)ROUND((double)PCB->GridOffsetX +
                            (double)(int)ROUND((dVar1 * 0.5 +
                                               (double)(Crosshair.X - PCB->GridOffsetX)) / dVar1) *
                            dVar1 + 0.5);
LAB_08081274:
      if (Crosshair.Y < 0) goto LAB_08081690;
LAB_08081285:
      if (iVar4 < Crosshair.Y) goto LAB_08081690;
      local_50 = (int)ROUND((double)PCB->GridOffsetY +
                            (double)(int)ROUND((dVar1 * 0.5 +
                                               (double)(Crosshair.Y - PCB->GridOffsetY)) / dVar1) *
                            dVar1 + 0.5);
    }
    iVar10 = local_44;
    if (((Marked.status != '\0') && (*(short *)&(PCB->Flags).f < 0)) &&
       (uVar7 = Crosshair.X - Marked.X >> 0x1f, uVar8 = Crosshair.Y - Marked.Y >> 0x1f,
       iVar10 = Marked.X,
       (int)((Crosshair.Y - Marked.Y ^ uVar8) - uVar8) <
       (int)((Crosshair.X - Marked.X ^ uVar7) - uVar7))) {
      iVar10 = local_44;
      local_50 = Marked.Y;
    }
  }
  if (local_40 == 0) {
    if ((uVar3 & 0x101) == 0) {
      if ((uVar3 & 0x1000) == 0) {
        if ((uVar3 & 2) != 0) {
          lVar13 = (longdouble)(*(int *)((int)local_20[0] + 0xd8) - Crosshair.X);
          lVar14 = (longdouble)(*(int *)((int)local_20[0] + 0xdc) - Crosshair.Y);
          iVar4 = *(int *)((int)local_20[0] + 0xd8);
          LVar12 = *(int *)((int)local_20[0] + 0xdc);
          if (lVar14 * lVar14 + lVar13 * lVar13 <
              (longdouble)(local_50 - Crosshair.Y) * (longdouble)(local_50 - Crosshair.Y) +
              (longdouble)(iVar10 - Crosshair.X) * (longdouble)(iVar10 - Crosshair.X))
          goto LAB_080813c4;
        }
      }
      else {
        iVar6 = *local_28 - Crosshair.X;
        iVar9 = local_28[1] - Crosshair.Y;
        iVar4 = *local_28;
        LVar12 = local_28[1];
        if (iVar9 * iVar9 + iVar6 * iVar6 <
            (local_50 - Crosshair.Y) * (local_50 - Crosshair.Y) +
            (iVar10 - Crosshair.X) * (iVar10 - Crosshair.X)) goto LAB_080813c4;
      }
      iVar4 = iVar10;
      LVar12 = local_50;
      goto LAB_080813c4;
    }
    iVar4 = (*gui->shift_is_pressed)();
    if (iVar4 != 0) {
      iVar9 = *(int *)((int)pvVar2 + 0x34);
      iVar6 = iVar9 - Crosshair.X;
      y0 = *(int *)((int)pvVar2 + 0x38);
      iVar5 = y0 - Crosshair.Y;
      goto LAB_080815e6;
    }
    iVar9 = *(int *)((int)pvVar2 + 0x34);
    y0 = *(LocationType *)((int)pvVar2 + 0x38);
  }
  else {
    lVar13 = (longdouble)(*(int *)((int)local_24 + 0x2c) - Crosshair.X);
    lVar14 = (longdouble)(*(int *)((int)local_24 + 0x30) - Crosshair.Y);
    lVar15 = (longdouble)(*(int *)((int)local_24 + 0x40) - Crosshair.X);
    lVar16 = (longdouble)(*(int *)((int)local_24 + 0x44) - Crosshair.Y);
    iVar9 = *(int *)((int)local_24 + 0x2c);
    y0 = *(int *)((int)local_24 + 0x30);
    if (lVar16 * lVar16 + lVar15 * lVar15 <= lVar14 * lVar14 + lVar13 * lVar13) {
      iVar9 = *(int *)((int)local_24 + 0x40);
      y0 = *(int *)((int)local_24 + 0x44);
    }
    iVar4 = (*gui->shift_is_pressed)();
    if (iVar4 != 0) {
      iVar6 = iVar9 - Crosshair.X;
      iVar5 = y0 - Crosshair.Y;
LAB_080815e6:
      iVar4 = iVar10;
      LVar12 = local_50;
      if ((longdouble)(local_50 - Crosshair.Y) * (longdouble)(local_50 - Crosshair.Y) +
          (longdouble)(iVar10 - Crosshair.X) * (longdouble)(iVar10 - Crosshair.X) <=
          (longdouble)iVar5 * (longdouble)iVar5 + (longdouble)iVar6 * (longdouble)iVar6)
      goto LAB_080813c4;
    }
  }
  iVar4 = iVar9;
  LVar12 = y0;
LAB_080813c4:
  if ((-1 < LVar12) && (-1 < iVar4)) {
    Crosshair.X = iVar4;
    Crosshair.Y = LVar12;
  }
  if (Settings.Mode == 0x6e) {
    iVar4 = SearchScreen(Crosshair.X,Crosshair.Y,0x1000,local_20,&local_24,&local_28);
    if (iVar4 == 0) {
      hid_action("PointCursor");
    }
    else if ((*(byte *)((int)local_24 + 0x14) & 0x40) == 0) {
      hid_actionl("PointCursor",&DAT_0813ecf0,0);
    }
  }
  if (((Settings.Mode == 2) && (Crosshair.AttachedLine.State != 0)) &&
     (*(char *)&(PCB->Flags).f < '\0')) {
    EnforceLineDRC();
  }
  (*gui->set_crosshair)(Crosshair.X,Crosshair.Y,0);
  return;
}



// WARNING: Unknown calling convention

void MoveCrosshairRelative(LocationType DeltaX,LocationType DeltaY)

{
  FitCrosshairIntoGrid(DeltaX + Crosshair.X,DeltaY + Crosshair.Y);
  return;
}



// WARNING: Unknown calling convention

void SetCrosshairRange(LocationType MinX,LocationType MinY,LocationType MaxX,LocationType MaxY)

{
  if (MinX < 0) {
    MinX = 0;
  }
  Crosshair.MinY = 0;
  if (-1 < MinY) {
    Crosshair.MinY = MinY;
  }
  Crosshair.MaxX = PCB->MaxWidth;
  if (MaxX <= PCB->MaxWidth) {
    Crosshair.MaxX = MaxX;
  }
  Crosshair.MaxY = PCB->MaxHeight;
  if (MaxY <= PCB->MaxHeight) {
    Crosshair.MaxY = MaxY;
  }
  Crosshair.MinX = MinX;
  MoveCrosshairRelative(0,0);
  return;
}



// WARNING: Unknown calling convention

void XORDrawAttachedArc(BDimension thick)

{
  int iVar1;
  BoxTypePtr pBVar2;
  BoxTypePtr bx;
  int iVar3;
  LocationType wx;
  uint uVar4;
  uint uVar5;
  int iVar6;
  _func_void_hidGC_int_int_int_int_int_int *p_Var7;
  int iVar8;
  int sa;
  uint uVar9;
  uint uVar10;
  int iVar11;
  int dir;
  int in_GS_OFFSET;
  int local_70;
  ArcType arc;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  uVar4 = Crosshair.X - Crosshair.AttachedBox.Point1.X;
  uVar9 = Crosshair.Y - Crosshair.AttachedBox.Point1.Y;
  if ((uVar9 == 0) && (uVar4 == 0)) goto LAB_08081a9b;
  arc.X = Crosshair.AttachedBox.Point1.X;
  arc.Y = Crosshair.AttachedBox.Point1.Y;
  uVar5 = (int)uVar4 >> 0x1f;
  uVar10 = (int)uVar9 >> 0x1f;
  if (Crosshair.AttachedBox.otherway == '\0') {
    local_70 = (uVar9 ^ uVar10) - uVar10;
    iVar11 = (uVar5 ^ uVar4) - uVar5;
    if (local_70 <= iVar11) goto LAB_080819f9;
LAB_08081ae1:
    if ((int)uVar4 < 0) {
      iVar11 = -local_70;
      uVar4 = 0xffffffff;
      iVar8 = 0xb4;
    }
    else {
      uVar4 = 1;
      iVar8 = 0;
      iVar11 = local_70;
    }
    arc.X = iVar11 + Crosshair.AttachedBox.Point1.X;
    iVar11 = -0x5a;
    if (uVar4 == (uVar10 | 1)) {
      iVar11 = 0x5a;
    }
  }
  else {
    local_70 = (uVar9 ^ uVar10) - uVar10;
    iVar11 = (uVar5 ^ uVar4) - uVar5;
    if (local_70 <= iVar11) goto LAB_08081ae1;
LAB_080819f9:
    local_70 = iVar11;
    if ((int)uVar9 < 0) {
      iVar11 = -local_70;
      iVar8 = 0x5a;
    }
    else {
      iVar8 = -0x5a;
      iVar11 = local_70;
    }
    arc.Y = Crosshair.AttachedBox.Point1.Y + iVar11;
    iVar11 = 0x5a;
    if ((uVar5 | 1) == (uVar10 | 1)) {
      iVar11 = -0x5a;
    }
  }
  iVar6 = thick / 2;
  arc.Width = local_70;
  arc.Height = local_70;
  arc.StartAngle = iVar8;
  arc.Delta = iVar11;
  pBVar2 = GetArcEnds((ArcTypePtr)&arc);
  (*gui->draw_arc)(Crosshair.GC,arc.X,arc.Y,local_70 + iVar6,local_70 + iVar6,iVar8,iVar11);
  if (pixel_slop < iVar6) {
    (*gui->draw_arc)(Crosshair.GC,arc.X,arc.Y,local_70 - iVar6,local_70 - iVar6,iVar8,iVar11);
    p_Var7 = gui->draw_arc;
    if (iVar11 < 1) {
      if (iVar11 == 0) {
        (*p_Var7)(Crosshair.GC,pBVar2->X1,pBVar2->Y1,iVar6,iVar6,iVar8,0);
        p_Var7 = gui->draw_arc;
        iVar3 = 0;
      }
      else {
        (*p_Var7)(Crosshair.GC,pBVar2->X1,pBVar2->Y1,iVar6,iVar6,iVar8,0xb4);
        p_Var7 = gui->draw_arc;
        iVar3 = -0xb4;
      }
    }
    else {
      (*p_Var7)(Crosshair.GC,pBVar2->X1,pBVar2->Y1,iVar6,iVar6,iVar8,-0xb4);
      p_Var7 = gui->draw_arc;
      iVar3 = 0xb4;
    }
    (*p_Var7)(Crosshair.GC,pBVar2->X2,pBVar2->Y2,iVar6,iVar6,iVar11 + iVar8,iVar3);
  }
LAB_08081a9b:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void XORDrawAttachedLine(LocationType x1,LocationType y1,LocationType x2,LocationType y2,
                        BDimension thick)

{
  uint uVar1;
  uint uVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  LocationType dx;
  LocationType oy;
  LocationType dy;
  int iVar8;
  LocationType ox;
  float h;
  double dVar9;
  
  dx = x2 - x1;
  iVar8 = y2 - y1;
  if ((iVar8 == 0) && (dx == 0)) {
    fVar4 = 0.0;
    fVar5 = fVar4;
    fVar6 = fVar4;
    fVar7 = fVar4;
  }
  else {
    fVar5 = (float)dx;
    fVar7 = (float)iVar8;
    fVar6 = SQRT(fVar7 * fVar7 + fVar5 * fVar5) / ((float)thick * 0.5);
    fVar3 = 0.5;
    fVar4 = fVar7 * fVar6;
    if (0 < iVar8) goto LAB_08081d2c;
    if (iVar8 != 0) {
      fVar3 = -0.5;
      goto LAB_08081d2c;
    }
  }
  fVar3 = 0.0;
LAB_08081d2c:
  uVar1 = (uint)ROUND(fVar4 + fVar3);
  if (dx < 1) {
    if (dx == 0) {
      fVar3 = 0.0;
    }
    else {
      fVar3 = -0.5;
    }
  }
  else {
    fVar3 = 0.5;
  }
  uVar2 = (uint)ROUND(-(fVar6 * fVar5 + fVar3));
  (*gui->draw_line)(Crosshair.GC,uVar1 + x1,uVar2 + y1,uVar1 + x2,uVar2 + y2);
  if ((pixel_slop <= (int)(((int)uVar1 >> 0x1f ^ uVar1) - ((int)uVar1 >> 0x1f))) ||
     (pixel_slop <= (int)(((int)uVar2 >> 0x1f ^ uVar2) - ((int)uVar2 >> 0x1f)))) {
    dVar9 = atan2((double)fVar5,(double)fVar7);
    (*gui->draw_line)(Crosshair.GC,x1 - uVar1,y1 - uVar2,x2 - uVar1,y2 - uVar2);
    iVar8 = thick / 2;
    (*gui->draw_arc)(Crosshair.GC,x1,y1,iVar8,iVar8,(int)ROUND(dVar9 * 57.295779) + -0xb4,0xb4);
    (*gui->draw_arc)(Crosshair.GC,x2,y2,iVar8,iVar8,(int)ROUND(dVar9 * 57.295779),0xb4);
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void DrawAttached(Boolean BlockToo)

{
  ElementTypePtr Element;
  LineTypePtr pLVar1;
  ArcTypePtr paVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  void *pvVar6;
  void *pvVar7;
  int iVar8;
  PointTypePtr point1;
  PointType *pPVar9;
  ElementTypePtr element_1;
  BDimension BVar10;
  LineTypePtr line_2;
  ArcTypePtr arc;
  TextTypePtr text_1;
  uchar *puVar11;
  DataTypePtr paVar12;
  uint uVar13;
  PinTypePtr via_1;
  ElementTypePtr element;
  TextTypePtr text;
  ArcTypePtr Arc;
  LineTypePtr line;
  LineTypePtr line_1;
  int iVar14;
  PolygonTypePtr polygon;
  PointTypePtr previous;
  int *piVar15;
  int iVar16;
  Cardinal n_4;
  Cardinal n_3;
  PCBTypePtr pPVar17;
  PinTypePtr via;
  PointTypePtr point;
  PointTypePtr point_1;
  RubberbandTypePtr ptr;
  RubberbandTypePtr paVar18;
  BDimension s;
  PointTypePtr following;
  Cardinal i;
  Cardinal CVar19;
  LocationType x;
  int *piVar20;
  PointTypePtr point2;
  PointTypePtr pPVar21;
  Cardinal n_5;
  Cardinal n;
  Cardinal n_1;
  Cardinal n_2;
  int iVar22;
  uint uVar23;
  int iVar24;
  int iVar25;
  uint local_28;
  
  pvVar7 = Crosshair.AttachedObject.Ptr3;
  pvVar6 = Crosshair.AttachedObject.Ptr2;
  iVar8 = Settings.BufferNumber;
  if (Settings.Mode == 5) {
    iVar16 = Crosshair.Y - Buffers[Settings.BufferNumber].Y;
    iVar25 = Crosshair.X - Buffers[Settings.BufferNumber].X;
    paVar12 = PCB->Data;
    pPVar17 = PCB;
    if (paVar12->LayerN != -2) {
      local_28 = 0;
      do {
        if (paVar12->Layer[local_28].On != '\0') {
          paVar12 = Buffers[iVar8].Data;
          CVar19 = paVar12->Layer[local_28].LineN;
          iVar24 = CVar19 - 1;
          if (iVar24 != -1) {
            iVar22 = CVar19 * 0x58;
            do {
              iVar24 = iVar24 + -1;
              pLVar1 = paVar12->Layer[local_28].Line;
              (*gui->draw_line)(Crosshair.GC,
                                iVar25 + *(int *)((int)&((PointType *)(&pLVar1[-1].Flags + 2))->Y +
                                                 iVar22 + -4),
                                *(int *)((int)&((PointType *)(&pLVar1[-1].Flags + 2))->Y + iVar22) +
                                iVar16,*(int *)((int)(&pLVar1[-1].Flags + 3) + iVar22 + 8) + iVar25,
                                *(int *)((int)(&pLVar1[-1].Flags + 4) + iVar22) + iVar16);
              iVar22 = iVar22 + -0x58;
            } while (iVar24 != -1);
          }
          CVar19 = paVar12->Layer[local_28].ArcN;
          iVar24 = CVar19 - 1;
          if (iVar24 != -1) {
            iVar22 = CVar19 * 0x44;
            do {
              iVar24 = iVar24 + -1;
              paVar2 = paVar12->Layer[local_28].Arc;
              (*gui->draw_arc)(Crosshair.GC,
                               iVar25 + *(int *)((int)(&paVar2[-1].Flags + 2) + iVar22 + 8),
                               iVar16 + *(int *)((int)(&paVar2[-1].Flags + 3) + iVar22),
                               *(int *)((int)(&paVar2[-1].Flags + 2) + iVar22),
                               *(int *)((int)(&paVar2[-1].Flags + 2) + iVar22 + 4),
                               *(int *)((int)(&paVar2[-1].Flags + 3) + iVar22 + 4),
                               *(int *)((int)(&paVar2[-1].Flags + 3) + iVar22 + 8));
              iVar22 = iVar22 + -0x44;
            } while (iVar24 != -1);
          }
          CVar19 = paVar12->Layer[local_28].TextN;
          iVar24 = CVar19 - 1;
          if (iVar24 != -1) {
            iVar22 = CVar19 * 0x3c;
            do {
              iVar24 = iVar24 + -1;
              puVar11 = paVar12->Layer[local_28].Text[-1].Flags.t + iVar22 + -0x18;
              (*gui->draw_rect)(Crosshair.GC,iVar25 + *(int *)puVar11,*(int *)(puVar11 + 4) + iVar16
                                ,*(int *)(puVar11 + 8) + iVar25,*(int *)(puVar11 + 0xc) + iVar16);
              iVar22 = iVar22 + -0x3c;
            } while (iVar24 != -1);
          }
          CVar19 = paVar12->Layer[local_28].PolygonN;
          iVar24 = CVar19 - 1;
          pPVar17 = PCB;
          if (iVar24 != -1) {
            iVar22 = CVar19 * 0x3c;
            do {
              iVar24 = iVar24 + -1;
              XORPolygon((PolygonTypePtr)
                         (paVar12->Layer[local_28].Polygon[-1].Flags.t + iVar22 + -0x18),iVar25,
                         iVar16);
              pPVar17 = PCB;
              iVar22 = iVar22 + -0x3c;
            } while (iVar24 != -1);
          }
        }
        paVar12 = pPVar17->Data;
        local_28 = local_28 + 1;
      } while (local_28 < paVar12->LayerN + 2U);
    }
    if ((pPVar17->PinOn != '\0') && (pPVar17->ElementOn != '\0')) {
      paVar12 = Buffers[iVar8].Data;
      iVar24 = paVar12->ElementN - 1;
      if (iVar24 != -1) {
        iVar22 = paVar12->ElementN * 300;
        while( true ) {
          Element = (ElementTypePtr)(paVar12->Element[-1].Flags.t + iVar22 + -0x18);
          if ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide) ||
             (PCB->InvisibleObjectsOn != '\0')) {
            XORDrawElement(Element,iVar25,iVar16);
          }
          iVar24 = iVar24 + -1;
          pPVar17 = PCB;
          if (iVar24 == -1) break;
          paVar12 = Buffers[iVar8].Data;
          iVar22 = iVar22 + -300;
        }
      }
    }
    if (pPVar17->ViaOn != '\0') {
      paVar12 = Buffers[iVar8].Data;
      if (paVar12->ViaN != 0) {
        uVar23 = 0;
        uVar13 = paVar12->ViaN;
        do {
          via_1 = paVar12->Via + uVar23;
          iVar24 = via_1->Thickness / 2;
          (*gui->draw_arc)(Crosshair.GC,via_1->X + iVar25,via_1->Y + iVar16,iVar24,iVar24,0,0x168);
          paVar12 = Buffers[iVar8].Data;
          uVar3 = paVar12->ViaN;
          if (uVar3 == 0) break;
          uVar23 = (uVar3 + 1 + uVar23) - uVar13;
          uVar13 = uVar3;
        } while (uVar23 < uVar3);
      }
    }
LAB_08082090:
    if (Crosshair.AttachedBox.State == 1) goto LAB_08082140;
  }
  else {
    if (Settings.Mode < 6) {
      if (Settings.Mode == 2) {
        if ((Crosshair.AttachedLine.State != 0) && (Crosshair.AttachedLine.draw != '\0')) {
          BVar10 = 10;
          if (PCB->RatDraw == '\0') {
            BVar10 = Settings.LineThickness;
          }
          XORDrawAttachedLine(Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,
                              Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,BVar10
                             );
          if (PCB->Clipping != 0) {
            BVar10 = 10;
            if (PCB->RatDraw == '\0') {
              BVar10 = Settings.LineThickness;
            }
            XORDrawAttachedLine(Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                                Crosshair.X,Crosshair.Y,BVar10);
          }
          if ((*(byte *)&(PCB->Flags).f & 8) != 0) {
            (*gui->set_color)(Crosshair.GC,Settings.CrossColor);
            BVar10 = 10;
            if (PCB->RatDraw == '\0') {
              BVar10 = PCB->Bloat * 2 + 2 + Settings.LineThickness;
            }
            XORDrawAttachedLine(Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,
                                Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                                BVar10);
            if (PCB->Clipping != 0) {
              BVar10 = 10;
              if (PCB->RatDraw == '\0') {
                BVar10 = PCB->Bloat * 2 + 2 + Settings.LineThickness;
              }
              XORDrawAttachedLine(Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                                  Crosshair.X,Crosshair.Y,BVar10);
            }
            goto LAB_08082381;
          }
        }
      }
      else if (Settings.Mode == 4) {
        if (Crosshair.AttachedLine.State != 0) {
          (*gui->draw_line)(Crosshair.GC,Crosshair.AttachedLine.Point1.X,
                            Crosshair.AttachedLine.Point1.Y,Crosshair.AttachedLine.Point2.X,
                            Crosshair.AttachedLine.Point2.Y);
        }
        if (1 < Crosshair.AttachedPolygon.PointN) {
          XORPolygon(&Crosshair.AttachedPolygon,0,0);
        }
      }
      else if ((Settings.Mode == 1) &&
              ((*gui->draw_arc)(Crosshair.GC,Crosshair.X,Crosshair.Y,Settings.ViaThickness / 2,
                                Settings.ViaThickness / 2,0,0x168),
              (*(byte *)&(PCB->Flags).f & 8) != 0)) {
        iVar8 = PCB->Bloat + 1 + Settings.ViaThickness / 2;
        (*gui->set_color)(Crosshair.GC,Settings.CrossColor);
        (*gui->draw_arc)(Crosshair.GC,Crosshair.X,Crosshair.Y,iVar8,iVar8,0,0x168);
LAB_08082381:
        (*gui->set_color)(Crosshair.GC,Settings.CrosshairColor);
      }
      goto LAB_08082090;
    }
    if (Settings.Mode == 0x6a) {
      if (Crosshair.AttachedObject.Type != 0) {
                    // WARNING: Load size is inaccurate
        (*gui->draw_line)(Crosshair.GC,*Crosshair.AttachedObject.Ptr3,
                          *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4),
                          *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c),
                          *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30));
                    // WARNING: Load size is inaccurate
        (*gui->draw_line)(Crosshair.GC,*pvVar7,*(int *)((int)pvVar7 + 4),
                          *(int *)((int)pvVar6 + 0x40),*(int *)((int)pvVar6 + 0x44));
      }
      goto LAB_08082090;
    }
    if (Settings.Mode < 0x6b) {
      if (0x67 < Settings.Mode) {
        iVar16 = Crosshair.X - Crosshair.AttachedObject.X;
        iVar8 = Crosshair.Y - Crosshair.AttachedObject.Y;
        if (Crosshair.AttachedObject.Type == 0x100) {
LAB_08082a2c:
          XORDrawElement((ElementTypePtr)Crosshair.AttachedObject.Ptr2,iVar16,iVar8);
        }
        else if (Crosshair.AttachedObject.Type < 0x101) {
          if (Crosshair.AttachedObject.Type == 4) {
            XORDrawAttachedLine(iVar16 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c),
                                iVar8 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30),
                                iVar16 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x40),
                                *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x44) + iVar8,
                                *(BDimension *)((int)Crosshair.AttachedObject.Ptr2 + 0x24));
          }
          else if (Crosshair.AttachedObject.Type < 5) {
            if (Crosshair.AttachedObject.Type == 1) {
              iVar25 = 0x168;
              iVar24 = 0;
              iVar14 = *(int *)((int)Crosshair.AttachedObject.Ptr1 + 0x24) / 2;
              iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr1 + 0x38);
              iVar5 = *(int *)((int)Crosshair.AttachedObject.Ptr1 + 0x34);
              iVar22 = iVar14;
LAB_080828b7:
              (*gui->draw_arc)(Crosshair.GC,iVar16 + iVar5,iVar8 + iVar4,iVar14,iVar22,iVar24,iVar25
                              );
            }
            else if (Crosshair.AttachedObject.Type == 2) goto LAB_08082a2c;
          }
          else if (Crosshair.AttachedObject.Type == 8) {
            XORPolygon((PolygonTypePtr)Crosshair.AttachedObject.Ptr2,iVar16,iVar8);
          }
          else if (Crosshair.AttachedObject.Type == 0x10) {
LAB_080827c7:
                    // WARNING: Load size is inaccurate
            (*gui->draw_rect)(Crosshair.GC,*Crosshair.AttachedObject.Ptr2 + iVar16,
                              iVar8 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 4),
                              iVar16 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 8),
                              iVar8 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0xc));
          }
        }
        else if (Crosshair.AttachedObject.Type == 0x800) {
          piVar20 = *(int **)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
          if ((int *)Crosshair.AttachedObject.Ptr3 == piVar20) {
            piVar20 = (int *)((int)Crosshair.AttachedObject.Ptr3 + 0x14);
            piVar15 = (int *)((int)Crosshair.AttachedObject.Ptr3 +
                             (*(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x24) + -1) * 0x14);
          }
          else if ((int *)Crosshair.AttachedObject.Ptr3 ==
                   piVar20 + (*(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x24) + -1) * 5) {
            piVar15 = (int *)((int)Crosshair.AttachedObject.Ptr3 + -0x14);
          }
          else {
            piVar15 = (int *)((int)Crosshair.AttachedObject.Ptr3 + -0x14);
            piVar20 = (int *)((int)Crosshair.AttachedObject.Ptr3 + 0x14);
          }
                    // WARNING: Load size is inaccurate
          (*gui->draw_line)(Crosshair.GC,*piVar15,piVar15[1],iVar16 + *Crosshair.AttachedObject.Ptr3
                            ,iVar8 + *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4));
                    // WARNING: Load size is inaccurate
          (*gui->draw_line)(Crosshair.GC,iVar16 + *pvVar7,iVar8 + *(int *)((int)pvVar7 + 4),*piVar20
                            ,piVar20[1]);
        }
        else if (Crosshair.AttachedObject.Type < 0x801) {
          if (Crosshair.AttachedObject.Type == 0x200) goto LAB_08082a2c;
          if (Crosshair.AttachedObject.Type == 0x400) {
            (*gui->draw_line)(Crosshair.GC,*(int *)((int)Crosshair.AttachedObject.Ptr1 + 0xd8),
                              *(int *)((int)Crosshair.AttachedObject.Ptr1 + 0xdc),Crosshair.X,
                              Crosshair.Y);
            goto LAB_080827c7;
          }
        }
        else if (Crosshair.AttachedObject.Type == 0x1000) {
          if (Crosshair.AttachedObject.Ptr3 == (void *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c))
          {
                    // WARNING: Load size is inaccurate
            XORDrawAttachedLine(iVar16 + *Crosshair.AttachedObject.Ptr3,
                                iVar8 + *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4),
                                *(LocationType *)((int)Crosshair.AttachedObject.Ptr2 + 0x40),
                                *(LocationType *)((int)Crosshair.AttachedObject.Ptr2 + 0x44),
                                *(BDimension *)((int)Crosshair.AttachedObject.Ptr2 + 0x24));
          }
          else {
                    // WARNING: Load size is inaccurate
            XORDrawAttachedLine(iVar16 + *Crosshair.AttachedObject.Ptr3,
                                iVar8 + *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4),
                                *(LocationType *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c),
                                *(LocationType *)((int)Crosshair.AttachedObject.Ptr2 + 0x30),
                                *(BDimension *)((int)Crosshair.AttachedObject.Ptr2 + 0x24));
          }
        }
        else if (Crosshair.AttachedObject.Type == 0x4000) {
          iVar25 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x40);
          iVar24 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x3c);
          iVar22 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30);
          iVar14 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c);
          iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
          iVar5 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x34);
          goto LAB_080828b7;
        }
        paVar18 = Crosshair.AttachedObject.Rubberband;
        CVar19 = Crosshair.AttachedObject.RubberbandN;
        if (Crosshair.AttachedObject.RubberbandN != 0) {
          while( true ) {
            pLVar1 = paVar18->Line;
            uVar13 = (pLVar1->Flags).f;
            if ((uVar13 & 2) == 0) {
              if ((uVar13 & 0x200) == 0) {
                if (paVar18->MovedPoint == &pLVar1->Point1) {
                  XORDrawAttachedLine(iVar16 + (pLVar1->Point1).X,iVar8 + (pLVar1->Point1).Y,
                                      iVar16 + (pLVar1->Point2).X,(pLVar1->Point2).Y + iVar8,
                                      pLVar1->Thickness);
                }
              }
              else {
                pPVar21 = paVar18->MovedPoint;
                pPVar9 = &pLVar1->Point1;
                if (pPVar21 == pPVar9) {
                  pPVar9 = &pLVar1->Point2;
                }
                else {
                  pPVar21 = &pLVar1->Point2;
                }
                XORDrawAttachedLine(pPVar9->X,pPVar9->Y,iVar16 + pPVar21->X,iVar8 + pPVar21->Y,
                                    pLVar1->Thickness);
              }
            }
            CVar19 = CVar19 - 1;
            if (CVar19 == 0) break;
            paVar18 = paVar18 + 1;
          }
        }
      }
      goto LAB_08082090;
    }
    if (Settings.Mode != 0x6d) goto LAB_08082090;
    if (Crosshair.AttachedBox.State != 0) {
      XORDrawAttachedArc(Settings.LineThickness);
      if ((*(byte *)&(PCB->Flags).f & 8) != 0) {
        (*gui->set_color)(Crosshair.GC,Settings.CrossColor);
        XORDrawAttachedArc(PCB->Bloat * 2 + 2 + Settings.LineThickness);
        goto LAB_08082381;
      }
      goto LAB_08082090;
    }
  }
  if ((BlockToo == '\0') || (Crosshair.AttachedBox.State != 2)) {
    return;
  }
LAB_08082140:
  (*gui->draw_rect)(Crosshair.GC,Crosshair.AttachedBox.Point1.X,Crosshair.AttachedBox.Point1.Y,
                    Crosshair.AttachedBox.Point2.X,Crosshair.AttachedBox.Point2.Y);
  return;
}



// WARNING: Unknown calling convention

void CrosshairOff(Boolean BlockToo)

{
  if (Crosshair.On == '\0') {
    return;
  }
  Crosshair.On = '\0';
  DrawAttached(BlockToo);
  DrawMark('\x01');
  return;
}



// WARNING: Unknown calling convention

void DestroyCrosshair(void)

{
  CrosshairOff('\x01');
  FreePolygonMemory(&Crosshair.AttachedPolygon);
  (*gui->destroy_gc)(Crosshair.GC);
  return;
}



// WARNING: Unknown calling convention

void HideCrosshair(Boolean BlockToo)

{
  if (CrosshairStackLocation < 0x10) {
    CrosshairStack[CrosshairStackLocation] = Crosshair.On;
    CrosshairStackLocation = CrosshairStackLocation + 1;
    CrosshairOff(BlockToo);
    return;
  }
  __fprintf_chk(stderr,1,"Error: CrosshairStackLocation overflow\n");
  return;
}



// WARNING: Unknown calling convention

Boolean MoveCrosshairAbsolute(LocationType X,LocationType Y)

{
  LocationType LVar1;
  LocationType LVar2;
  LocationType LVar3;
  LocationType LVar4;
  Boolean BVar5;
  LocationType x;
  LocationType z;
  LocationType y;
  
  LVar3 = Crosshair.Y;
  LVar1 = Crosshair.X;
  FitCrosshairIntoGrid(X,Y);
  LVar4 = Crosshair.Y;
  LVar2 = Crosshair.X;
  if ((Crosshair.X != LVar1) || (BVar5 = '\0', Crosshair.Y != LVar3)) {
    Crosshair.X = LVar1;
    Crosshair.Y = LVar3;
    HideCrosshair('\0');
    BVar5 = '\x01';
  }
  Crosshair.X = LVar2;
  Crosshair.Y = LVar4;
  return BVar5;
}



// WARNING: Unknown calling convention

void CrosshairOn(Boolean BlockToo)

{
  if (Crosshair.On != '\0') {
    return;
  }
  Crosshair.On = '\x01';
  DrawAttached(BlockToo);
  DrawMark('\x01');
  return;
}



// WARNING: Unknown calling convention

void RestoreCrosshair(Boolean BlockToo)

{
  int iVar1;
  
  if (CrosshairStackLocation < 1) {
    __fprintf_chk(stderr,1,"Error: CrosshairStackLocation underflow\n");
    return;
  }
  iVar1 = CrosshairStackLocation + 3;
  CrosshairStackLocation = CrosshairStackLocation + -1;
  if (*(char *)((int)&CrosshairStackLocation + iVar1) == '\0') {
    CrosshairOff(BlockToo);
    return;
  }
  CrosshairOn(BlockToo);
  return;
}



// WARNING: Unknown calling convention

int djopt_set_auto_only(int argc,char **argv,int x,int y)

{
  autorouted_only = (uint)(autorouted_only == 0);
  return 0;
}



// WARNING: Unknown calling convention

int djopt_get_auto_only(int dummy)

{
  return autorouted_only;
}



// WARNING: Unknown calling convention

int sqr(int a)

{
  return a * a;
}



// WARNING: Unknown calling convention

void add_point_to_rect(rect_s *rect,int x,int y,int w)

{
  int iVar1;
  
  iVar1 = x - w;
  if (rect->x1 != iVar1 && iVar1 <= rect->x1) {
    rect->x1 = iVar1;
  }
  if (rect->x2 < w + x) {
    rect->x2 = w + x;
  }
  iVar1 = y - w;
  if (rect->y1 != iVar1 && iVar1 <= rect->y1) {
    rect->y1 = iVar1;
  }
  if (rect->y2 < w + y) {
    rect->y2 = w + y;
  }
  return;
}



// WARNING: Unknown calling convention

void add_line_to_rect(rect_s *rect,line_s *l)

{
  add_point_to_rect(rect,l->s->x,l->s->y,0);
  add_point_to_rect(rect,l->e->x,l->e->y,0);
  return;
}



// WARNING: Unknown calling convention

int corner_radius(corner_s *c)

{
  PinType *pPVar1;
  LineType *pLVar2;
  int iVar3;
  int iVar4;
  int i;
  BDimension BVar5;
  int diam;
  
  BVar5 = 0;
  pPVar1 = c->pin;
  if ((pPVar1 != (PinType *)0x0) && (-1 < pPVar1->Thickness)) {
    BVar5 = pPVar1->Thickness;
  }
  if ((c->via != (PinType *)0x0) && (iVar4 = c->via->Thickness, BVar5 < iVar4)) {
    BVar5 = iVar4;
  }
  if (0 < c->n_lines) {
    iVar4 = 0;
    do {
      pLVar2 = c->lines[iVar4]->line;
      if ((pLVar2 != (LineType *)0x0) && (iVar3 = pLVar2->Thickness, BVar5 < iVar3)) {
        BVar5 = iVar3;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 != c->n_lines);
  }
  return (BVar5 + 1) / 2;
}



// WARNING: Unknown calling convention

int simple_corner(corner_s *c)

{
  line_s *plVar1;
  corner_s *pcVar2;
  byte bVar3;
  int o2;
  int y2;
  int iVar4;
  byte bVar5;
  int o1;
  int x2_1;
  int x2;
  int iVar6;
  int iVar7;
  int x1_1;
  int x1;
  int y1_1;
  int y1;
  int iVar8;
  int local_14;
  
  if ((((c->pad == (PadType *)0x0) && (c->pin == (PinType *)0x0)) && (c->via == (PinType *)0x0)) &&
     (c->n_lines == 2)) {
    plVar1 = *c->lines;
    pcVar2 = plVar1->s;
    if (c == pcVar2) {
      iVar7 = c->x;
      iVar4 = c->y;
      iVar6 = plVar1->e->x;
      local_14 = plVar1->e->y;
    }
    else {
      iVar7 = plVar1->e->x;
      iVar4 = plVar1->e->y;
      iVar6 = pcVar2->x;
      local_14 = pcVar2->y;
    }
    if (iVar7 == iVar6) {
      bVar5 = (iVar4 < local_14) * '\x04' + 0x24;
    }
    else {
      bVar5 = 0xf0;
      if (iVar4 == local_14) {
        bVar5 = (iVar7 < iVar6) + 0x11;
      }
    }
    plVar1 = c->lines[1];
    pcVar2 = plVar1->s;
    if (c == pcVar2) {
      iVar6 = c->x;
      iVar8 = c->y;
      iVar7 = plVar1->e->x;
      iVar4 = plVar1->e->y;
    }
    else {
      iVar7 = pcVar2->x;
      iVar4 = pcVar2->y;
      iVar6 = plVar1->e->x;
      iVar8 = plVar1->e->y;
    }
    if (iVar6 == iVar7) {
      bVar3 = (iVar8 < iVar4) * '\x04' + 0x24;
    }
    else {
      bVar3 = 0xf0;
      if (iVar8 == iVar4) {
        bVar3 = (iVar6 < iVar7) + 0x11;
      }
    }
    if ((((bVar3 ^ bVar5) & 0xf0) != 0) && ((bVar5 & 0xf0) != 0xf0)) {
      return (uint)((bVar3 & 0xf0) != 0xf0);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

corner_s * find_corner(int x,int y,int l)

{
  int iVar1;
  corner_s *pcVar2;
  line_s **pplVar3;
  corner_s *c;
  
  pcVar2 = corners;
  if (corners != (corner_s *)0x0) {
    do {
      iVar1 = pcVar2->layer;
      if ((((iVar1 != -0x21524111) && (pcVar2->x == x)) && (pcVar2->y == y)) &&
         (((iVar1 == -1 || (l == -1)) ||
          ((iVar1 == l || (layer_groupings[iVar1] == layer_groupings[l])))))) {
        return pcVar2;
      }
      pcVar2 = pcVar2->next;
    } while (pcVar2 != (corner_s *)0x0);
  }
  pcVar2 = (corner_s *)malloc(0x2c);
  pcVar2->x = x;
  pcVar2->y = y;
  pcVar2->net = 0;
  pcVar2->next = corners;
  pcVar2->via = (PinType *)0x0;
  pcVar2->pad = (PadType *)0x0;
  pcVar2->pin = (PinType *)0x0;
  pcVar2->layer = l;
  pcVar2->n_lines = 0;
  corners = pcVar2;
  pplVar3 = (line_s **)malloc(0x1c);
  pcVar2->lines = pplVar3;
  return pcVar2;
}



// WARNING: Unknown calling convention

void remove_line(line_s *l)

{
  LineTypePtr Line;
  int iVar1;
  DataTypePtr paVar2;
  corner_s *pcVar3;
  line_s **pplVar4;
  corner_s *pcVar5;
  line_s *l2;
  line_s *plVar6;
  int iVar7;
  int i;
  int j;
  int iVar8;
  LineType *pLVar9;
  LineType *from;
  LineType *to;
  
  pLVar9 = (LineType *)0x0;
  Line = l->line;
  iVar1 = l->layer;
  paVar2 = PCB->Data;
  if (Line != (LineTypePtr)0x0) {
    pLVar9 = paVar2->Layer[iVar1].Line + (paVar2->Layer[iVar1].LineN - 1);
    RemoveLine(paVar2->Layer + iVar1,Line);
  }
  plVar6 = lines;
  l->layer = -0x21524111;
  for (; plVar6 != (line_s *)0x0; plVar6 = plVar6->next) {
    while ((plVar6->layer == -0x21524111 || (plVar6->line != pLVar9))) {
      plVar6 = plVar6->next;
      if (plVar6 == (line_s *)0x0) goto LAB_08083088;
    }
    plVar6->line = Line;
  }
LAB_08083088:
  pcVar3 = l->s;
  iVar8 = 0;
  iVar1 = pcVar3->n_lines;
  if (0 < iVar1) {
    iVar7 = 0;
    pplVar4 = pcVar3->lines;
    do {
      plVar6 = pplVar4[iVar7];
      if (plVar6 != l) {
        pplVar4[iVar8] = plVar6;
        iVar8 = iVar8 + 1;
      }
      iVar7 = iVar7 + 1;
    } while (iVar7 < iVar1);
  }
  pcVar5 = l->e;
  pcVar3->n_lines = iVar8;
  iVar8 = 0;
  iVar1 = pcVar5->n_lines;
  if (0 < iVar1) {
    pplVar4 = pcVar5->lines;
    iVar7 = 0;
    do {
      plVar6 = pplVar4[iVar7];
      if (plVar6 != l) {
        pplVar4[iVar8] = plVar6;
        iVar8 = iVar8 + 1;
      }
      iVar7 = iVar7 + 1;
    } while (iVar7 < iVar1);
  }
  pcVar5->n_lines = iVar8;
  return;
}



// WARNING: Unknown calling convention

void add_line_to_corner(line_s *l,corner_s *c)

{
  int iVar1;
  line_s **pplVar2;
  
  pplVar2 = (line_s **)realloc(c->lines,(c->n_lines + 8U & 0xfffffff8) << 2);
  iVar1 = c->n_lines;
  pplVar2[iVar1] = l;
  c->lines = pplVar2;
  c->n_lines = iVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

int dist(int x1,int y1,int x2,int y2)

{
  double dVar1;
  
  dVar1 = rint(SQRT(((double)y1 - (double)y2) * ((double)y1 - (double)y2) +
                    ((double)x1 - (double)x2) * ((double)x1 - (double)x2)));
  return (int)ROUND(dVar1);
}



// WARNING: Unknown calling convention

void add_corner_to_rect_if(rect_s *rect,corner_s *c,rect_s *e)

{
  int y2;
  int w;
  int x1;
  int iVar1;
  int y1;
  int local_28;
  int local_20;
  
  w = corner_radius(c);
  iVar1 = e->x1;
  y1 = c->y;
  x1 = c->x;
  if ((x1 < iVar1) && (w + x1 < iVar1)) {
    return;
  }
  local_20 = e->x2;
  if ((local_20 < x1) && (local_20 < x1 - w)) {
    return;
  }
  y2 = e->y1;
  if ((y1 < y2) && (w + y1 < y2)) {
    return;
  }
  if ((e->y2 < y1) && (e->y2 < y1 - w)) {
    return;
  }
  if ((x1 < iVar1) && (y1 < y2)) {
    iVar1 = dist(x1,y1,iVar1,y2);
    if (w < iVar1) {
      return;
    }
    local_20 = e->x2;
    y1 = c->y;
    x1 = c->x;
  }
  if (local_20 < x1) {
    if (y1 < e->y1) {
      iVar1 = dist(x1,y1,local_20,e->y1);
      if (w < iVar1) {
        return;
      }
      x1 = c->x;
      y1 = c->y;
      goto LAB_080832f0;
    }
    local_28 = e->x1;
    if (x1 < local_28) goto LAB_08083248;
LAB_08083301:
    iVar1 = e->x2;
    if (x1 <= iVar1) goto LAB_0808326c;
  }
  else {
LAB_080832f0:
    local_28 = e->x1;
    if (local_28 <= x1) goto LAB_08083301;
LAB_08083248:
    if (e->y2 < y1) {
      iVar1 = dist(x1,y1,local_28,e->y2);
      if (w < iVar1) {
        return;
      }
      y1 = c->y;
      x1 = c->x;
      goto LAB_08083301;
    }
    iVar1 = e->x2;
    if (x1 <= iVar1) goto LAB_0808326c;
  }
  if (e->y2 < y1) {
    iVar1 = dist(x1,y1,iVar1,e->y2);
    if (w < iVar1) {
      return;
    }
    y1 = c->y;
    x1 = c->x;
  }
LAB_0808326c:
  add_point_to_rect(rect,x1,y1,w);
  return;
}



// WARNING: Unknown calling convention

int line_length(line_s *l)

{
  corner_s *pcVar1;
  corner_s *pcVar2;
  int x2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  pcVar1 = l->s;
  pcVar2 = l->e;
  iVar3 = pcVar1->x;
  x2 = pcVar2->x;
  if (iVar3 == x2) {
    uVar4 = pcVar1->y - pcVar2->y;
    uVar5 = (int)uVar4 >> 0x1f;
    return (uVar4 ^ uVar5) - uVar5;
  }
  if (pcVar1->y != pcVar2->y) {
    iVar3 = dist(iVar3,pcVar1->y,x2,pcVar2->y);
    return iVar3;
  }
  uVar4 = iVar3 - x2 >> 0x1f;
  return (uVar4 ^ iVar3 - x2) - uVar4;
}



// WARNING: Unknown calling convention

int dist_ltp2(int dx,int y,int y1,int y2)

{
  int iVar1;
  
  iVar1 = y1;
  if (y2 < y1) {
    iVar1 = y2;
    y2 = y1;
  }
  if (iVar1 <= y) {
    if (y <= y2) {
      return (dx ^ dx >> 0x1f) - (dx >> 0x1f);
    }
    iVar1 = dist(dx,y,0,y2);
    return iVar1;
  }
  iVar1 = dist(dx,y,0,iVar1);
  return iVar1;
}



// WARNING: Unknown calling convention
// Local variable lp:line_s *[EDX:4] conflicts with parameter, skipped.

LineType * create_pcb_line(int layer,int x1,int y1,int x2,int y2,int thick,int clear,FlagType flags)

{
  DataTypePtr paVar1;
  LineType *pLVar2;
  LineType *pLVar3;
  LineType *pLVar4;
  LineTypePtr Ptr2;
  LineType *nl;
  char *to;
  line_s *plVar5;
  char *from;
  LayerType *lyr;
  
  paVar1 = PCB->Data;
  pLVar2 = paVar1->Layer[layer].Line;
  Ptr2 = CreateNewLineOnLayer(paVar1->Layer + layer,x1,y1,x2,y2,thick,clear,flags);
  AddObjectToCreateUndoList(4,paVar1->Layer + layer,Ptr2,Ptr2);
  pLVar3 = paVar1->Layer[layer].Line;
  if ((pLVar2 != pLVar3) && (lines != (line_s *)0x0)) {
    plVar5 = lines;
    do {
      if (((plVar5->layer != -0x21524111) && (pLVar4 = plVar5->line, pLVar2 <= pLVar4)) &&
         (pLVar4 <= pLVar2 + paVar1->Layer[layer].LineN)) {
        plVar5->line = (LineType *)((int)pLVar4 + ((int)pLVar3 - (int)pLVar2));
      }
      plVar5 = plVar5->next;
    } while (plVar5 != (line_s *)0x0);
  }
  return Ptr2;
}



// WARNING: Unknown calling convention

void dj_abort(char *msg,...)

{
  __vfprintf_chk(stdout,1,msg,&stack0x00000008);
  fflush(stdout);
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void new_line(corner_s *s,corner_s *e,int layer,LineType *example)

{
  int *piVar1;
  int y1;
  line_s *l;
  LineType *pLVar2;
  LineType *nl;
  
  piVar1 = &PCB->Data->LayerN;
  if (*piVar1 == layer || *piVar1 < layer) {
    dj_abort("layer %d\n",layer);
  }
  if (example == (LineType *)0x0) {
    dj_abort("NULL example passed to new_line()\n",layer);
  }
  if ((s->x == e->x) && (s->y == e->y)) {
    return;
  }
  l = (line_s *)malloc(0x14);
  l->layer = layer;
  y1 = s->y;
  l->s = s;
  l->e = e;
  l->next = lines;
  lines = l;
  pLVar2 = create_pcb_line(layer,s->x,y1,e->x,e->y,example->Thickness,example->Clearance,
                           example->Flags);
  if (pLVar2 == (LineType *)0x0) {
    dj_abort("can\'t create new line!");
  }
  l->line = pLVar2;
  add_line_to_corner(l,s);
  add_line_to_corner(l,e);
  return;
}



// WARNING: Unknown calling convention

corner_s * other_corner(line_s *l,corner_s *c)

{
  if (l->s == c) {
    return l->e;
  }
  if (l->e == c) {
    return l->s;
  }
  dj_abort("other_corner: neither corner passed\n");
  return (corner_s *)0x0;
}



// WARNING: Unknown calling convention

void classify_corner(corner_s *c,int this_net)

{
  line_s **pplVar1;
  corner_s *c_00;
  int iVar2;
  int i;
  
  if ((c->net != this_net) && (c->net = this_net, 0 < c->n_lines)) {
    iVar2 = 0;
    do {
      pplVar1 = c->lines + iVar2;
      iVar2 = iVar2 + 1;
      c_00 = other_corner(*pplVar1,c);
      classify_corner(c_00,this_net);
    } while (c->n_lines != iVar2 && iVar2 <= c->n_lines);
  }
  return;
}



// WARNING: Unknown calling convention

int split_line(line_s *l,corner_s *c)

{
  int iVar1;
  PadType *pPVar2;
  PadType *pPVar3;
  PadType *pPVar4;
  LineType *pLVar5;
  LineType *pcbline;
  line_s *l_00;
  line_s **pplVar6;
  int iVar7;
  int i;
  corner_s *pcVar8;
  
  iVar1 = c->layer;
  iVar7 = l->layer;
  if ((((iVar1 == -1) || (iVar7 == -1)) || (iVar1 == iVar7)) ||
     (layer_groupings[iVar7] == layer_groupings[iVar1])) {
    pPVar2 = (PadType *)l->line;
    pPVar3 = l->s->pad;
    if (pPVar2 != pPVar3) {
      pPVar4 = c->pad;
      if (pPVar4 == (PadType *)0x0) {
        pcVar8 = l->e;
      }
      else {
        if (pPVar3 == pPVar4) {
          return 0;
        }
        pcVar8 = l->e;
        if (pPVar4 == pcVar8->pad) {
          return 0;
        }
      }
      pLVar5 = create_pcb_line(iVar7,c->x,c->y,pcVar8->x,pcVar8->y,pPVar2->Thickness,
                               pPVar2->Clearance,pPVar2->Flags);
      if (pLVar5 != (LineType *)0x0) {
        l_00 = (line_s *)malloc(0x14);
        pcVar8 = l->e;
        l_00->next = lines;
        iVar1 = l->layer;
        l_00->line = pLVar5;
        lines = l_00;
        l_00->s = c;
        l_00->layer = iVar1;
        iVar1 = pcVar8->n_lines;
        l_00->e = pcVar8;
        if (0 < iVar1) {
          iVar7 = 0;
          do {
            while (pplVar6 = pcVar8->lines + iVar7, *pplVar6 == l) {
              iVar7 = iVar7 + 1;
              *pplVar6 = l_00;
              if (iVar1 <= iVar7) goto LAB_08083813;
            }
            iVar7 = iVar7 + 1;
          } while (iVar7 < iVar1);
        }
LAB_08083813:
        l->e = c;
        add_line_to_corner(l,c);
        add_line_to_corner(l_00,c);
        pLVar5 = l->line;
        MoveObject(0x1000,PCB->Data->Layer + l->layer,pLVar5,&pLVar5->Point2,
                   c->x - (pLVar5->Point2).X,c->y - (pLVar5->Point2).Y);
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention
// Local variable cc:corner_s *[EAX:4] conflicts with parameter, skipped.

void remove_via_at(corner_s *c)

{
  PinType *Ptr1;
  corner_s *pcVar1;
  PinType *from;
  PinType *to;
  
  Ptr1 = c->via;
  from = (PinType *)(PCB->Data->Via + (PCB->Data->ViaN - 1));
  RemoveObject(1,Ptr1,(void *)0x0,(void *)0x0);
  pcVar1 = corners;
  c->via = (PinType *)0x0;
  do {
    if (pcVar1 == (corner_s *)0x0) {
      return;
    }
    while ((pcVar1->layer == -0x21524111 || (pcVar1->via != from))) {
      pcVar1 = pcVar1->next;
      if (pcVar1 == (corner_s *)0x0) {
        return;
      }
    }
    pcVar1->via = Ptr1;
    pcVar1 = pcVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

void merge_corners(corner_s *c1,corner_s *c2)

{
  line_s *plVar1;
  int iVar2;
  corner_s *pcVar4;
  corner_s *pcVar5;
  line_s **pplVar6;
  corner_s *c;
  int iVar7;
  int i;
  int iVar3;
  
  if (c1 == c2) {
                    // WARNING: Subroutine does not return
    abort();
  }
  if (0 < c2->n_lines) {
    pplVar6 = c2->lines;
    iVar7 = 0;
    do {
      while( true ) {
        add_line_to_corner(pplVar6[iVar7],c1);
        pplVar6 = c2->lines;
        plVar1 = pplVar6[iVar7];
        if (plVar1->s == c2) break;
        if (plVar1->e != c2) goto LAB_0808395d;
LAB_08083990:
        iVar7 = iVar7 + 1;
        iVar2 = c2->n_lines;
        iVar3 = c2->n_lines;
        plVar1->e = c1;
        if (iVar3 == iVar7 || iVar2 < iVar7) goto LAB_080839a0;
      }
      plVar1->s = c1;
      if (plVar1->e == c2) goto LAB_08083990;
LAB_0808395d:
      iVar7 = iVar7 + 1;
    } while (c2->n_lines != iVar7 && iVar7 <= c2->n_lines);
  }
LAB_080839a0:
  if (c1->via == (PinType *)0x0) {
    if (c2->via != (PinType *)0x0) {
      c1->via = c2->via;
    }
  }
  else if (c2->via != (PinType *)0x0) {
    remove_via_at(c2);
  }
  if (c2->pad != (PadType *)0x0) {
    c1->pad = c2->pad;
  }
  if (c2->pin != (PinType *)0x0) {
    c1->pin = c2->pin;
  }
  if (c2->layer != c1->layer) {
    c1->layer = -1;
  }
  pcVar4 = corners;
  if (c2 == corners) {
    corners = c2->next;
    pcVar4 = corners;
  }
  while (pcVar5 = pcVar4, pcVar5 != (corner_s *)0x0) {
    if (pcVar5->layer == -0x21524111) {
      pcVar4 = pcVar5->next;
    }
    else {
      pcVar4 = pcVar5->next;
      if (c2 == pcVar5->next) {
        pcVar4 = c2->next;
        pcVar5->next = pcVar4;
      }
    }
  }
  if (c2 == next_corner) {
    next_corner = c2->next;
  }
  free(c2->lines);
  c2->lines = (line_s **)0x0;
  c2->layer = -0x21524111;
  return;
}



// WARNING: Unknown calling convention

void move_corner(corner_s *c,int x,int y)

{
  PinType *Ptr1;
  line_s *plVar1;
  LineType *Ptr2;
  int iVar2;
  PinType *via;
  LineTypePtr tl;
  corner_s *c2_00;
  PointType *Ptr3;
  int iVar3;
  corner_s *pad;
  corner_s *c2;
  int iVar4;
  int i;
  bool bVar5;
  
  if ((c->pad != (PadType *)0x0) || (c->pin != (PinType *)0x0)) {
    dj_abort("move_corner: has pin or pad\n");
  }
  iVar3 = c->layer;
  for (c2_00 = corners; c2_00 != (corner_s *)0x0; c2_00 = c2_00->next) {
    while (((iVar4 = c2_00->layer, iVar4 == -0x21524111 || (x != c2_00->x)) || (y != c2_00->y))) {
      c2_00 = c2_00->next;
      if (c2_00 == (corner_s *)0x0) goto LAB_08083c98;
    }
    if (((iVar4 == -1) || (iVar3 == -1)) ||
       ((iVar3 == iVar4 || (layer_groupings[iVar4] == layer_groupings[iVar3])))) {
      bVar5 = c != c2_00;
      goto LAB_08083b02;
    }
  }
LAB_08083c98:
  bVar5 = false;
LAB_08083b02:
  c->x = x;
  Ptr1 = c->via;
  c->y = y;
  if (Ptr1 != (PinType *)0x0) {
    MoveObject(1,Ptr1,Ptr1,Ptr1,x - Ptr1->X,y - Ptr1->Y);
  }
  iVar3 = c->n_lines;
  if (0 < iVar3) {
    iVar4 = 0;
    do {
      plVar1 = c->lines[iVar4];
      Ptr2 = plVar1->line;
      if (Ptr2 != (LineType *)0x0) {
        if (plVar1->s == c) {
          iVar3 = (Ptr2->Point1).Y;
          iVar2 = (Ptr2->Point1).X;
          Ptr3 = &Ptr2->Point1;
        }
        else {
          iVar3 = (Ptr2->Point2).Y;
          iVar2 = (Ptr2->Point2).X;
          Ptr3 = &Ptr2->Point2;
        }
        MoveObject(0x1000,PCB->Data->Layer + plVar1->layer,Ptr2,Ptr3,x - iVar2,y - iVar3);
        iVar3 = c->n_lines;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < iVar3);
  }
  if (bVar5) {
LAB_08083c36:
    merge_corners(c,c2_00);
  }
  else if (0 < iVar3) {
    iVar4 = 0;
    do {
      plVar1 = c->lines[iVar4];
      if ((plVar1->s->x == plVar1->e->x) && (plVar1->s->y == plVar1->e->y)) {
        c2_00 = other_corner(plVar1,c);
        remove_line(c->lines[iVar4]);
        if (c != c2_00) goto LAB_08083c36;
        break;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < iVar3);
  }
  (*gui->progress)(0,0,(char *)0x0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int connect_corners(corner_s *c1,corner_s *c2)

{
  bool bVar1;
  int li;
  corner_s *pcVar2;
  int ny;
  int iVar3;
  line_s *ex;
  int nx;
  int x;
  corner_s **ppcVar4;
  int layer;
  PadType *local_34;
  corner_s *c [2];
  
  ppcVar4 = c + 1;
  c[1] = c2;
  bVar1 = false;
  pcVar2 = c1;
  while( true ) {
    if (0 < pcVar2->n_lines) {
      li = 0;
      do {
        local_34 = (PadType *)pcVar2->lines[li]->line;
        if (local_34 != pcVar2->pad) {
          layer = pcVar2->lines[li]->layer;
          iVar3 = (*ppcVar4)->layer;
          if ((((iVar3 == -1) || (layer == -1)) || (iVar3 == layer)) ||
             (layer_groupings[layer] == layer_groupings[iVar3])) goto LAB_08083d26;
        }
        li = li + 1;
      } while (li < pcVar2->n_lines);
    }
    ppcVar4 = ppcVar4 + -1;
    if (bVar1) break;
    bVar1 = true;
    pcVar2 = c[1];
  }
  local_34 = _DAT_00000010;
  layer = _DAT_00000000;
LAB_08083d26:
  c[0] = c1;
  if (((c1->pin != (PinType *)0x0) || (c1->pad != (PadType *)0x0)) ||
     ((c1->via != (PinType *)0x0 || (c1->n_lines != 1)))) {
    pcVar2 = find_corner(c1->x,c2->y,layer);
    new_line(c1,pcVar2,layer,(LineType *)local_34);
    new_line(pcVar2,c2,layer,(LineType *)local_34);
    return 0;
  }
  if ((*c1->lines)->s->x == (*c1->lines)->e->x) {
    x = c1->x;
    iVar3 = c2->y;
    if (x == c2->x) goto LAB_08083e23;
  }
  else {
    iVar3 = c1->y;
    x = c2->x;
    if (iVar3 == c2->y) {
LAB_08083e23:
      move_corner(c1,x,iVar3);
      return 1;
    }
  }
  move_corner(c1,x,iVar3);
  new_line(c1,c2,layer,(LineType *)local_34);
  return 1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int orthopull_1(corner_s *c,int fdir,int rdir,int any_sel)

{
  line_s *plVar1;
  int iVar2;
  corner_s *pcVar3;
  bool bVar4;
  byte bVar5;
  int iVar6;
  int i;
  int r2;
  int iVar7;
  int iVar8;
  int sep;
  int x1_3;
  int iVar9;
  corner_s *pcVar10;
  corner_s *pcVar11;
  corner_s **ppcVar12;
  int iVar13;
  int x2;
  line_s *l;
  int iVar14;
  int x2_2;
  int o_2;
  byte bVar15;
  int o;
  int o_1;
  int iVar16;
  int y2_2;
  int iVar17;
  uint uVar18;
  uint uVar19;
  int x1;
  int pull;
  int li;
  int y1_2;
  line_s *l_1;
  int y2;
  int x2_1;
  int x1_2;
  corner_s *cb;
  int y1;
  int x1_1;
  int y1_1;
  uint uVar20;
  bool bVar21;
  bool bVar22;
  int local_84;
  size_t local_80;
  int local_74;
  int local_6c;
  int local_68;
  int local_64;
  int local_5c;
  line_s *local_58;
  int local_54;
  int local_50;
  int local_48;
  int local_40;
  corner_s *local_3c;
  corner_s **local_38;
  rect_s rr;
  
  if (orthopull_1::cs == (corner_s **)0x0) {
    orthopull_1::cs = (corner_s **)malloc(0x1b8);
    orthopull_1::cm = 10;
    orthopull_1::ls = (line_s **)malloc(200);
    orthopull_1::lm = 10;
  }
  if (0 < c->n_lines) {
    iVar6 = 0;
    do {
      plVar1 = c->lines[iVar6];
      pcVar11 = plVar1->s;
      if (c == pcVar11) {
        iVar14 = c->x;
        iVar8 = c->y;
        iVar16 = plVar1->e->x;
        iVar7 = plVar1->e->y;
      }
      else {
        iVar7 = pcVar11->y;
        iVar14 = plVar1->e->x;
        iVar8 = plVar1->e->y;
        iVar16 = pcVar11->x;
      }
      if (iVar14 == iVar16) {
        iVar13 = (uint)(iVar8 < iVar7) * 4 + 0x24;
      }
      else {
        iVar13 = 0xf0;
        if (iVar8 == iVar7) {
          iVar13 = (iVar14 < iVar16) + 0x11;
        }
      }
      if (rdir == iVar13) {
        return 0;
      }
      iVar6 = iVar6 + 1;
    } while (iVar6 < c->n_lines);
  }
  local_50 = 0x24;
  local_54 = 0x28;
  if (fdir != 0x12) {
    local_50 = 0x11;
    local_54 = 0x12;
    if (fdir != 0x28) {
      dj_abort("fdir not right or down\n");
      local_50 = 0;
      local_54 = 0;
    }
  }
  if (c->pad != (PadType *)0x0) {
    return 0;
  }
  if (c->pin != (PinType *)0x0) {
    return 0;
  }
  if (c->n_lines < 2) {
    return 0;
  }
  local_6c = 0;
  iVar6 = 0;
  local_80 = 200;
  local_74 = 10;
  local_64 = 0;
  local_68 = 0;
  bVar4 = false;
  bVar22 = false;
  local_3c = c;
  if (orthopull_1::cm < 1) goto LAB_08084190;
  while( true ) {
    *(corner_s **)((int)orthopull_1::cs + local_64) = local_3c;
    iVar14 = local_6c + 1;
    iVar7 = corner_radius(local_3c);
    if (iVar7 <= local_68) {
      iVar7 = local_68;
    }
    if (local_3c->n_lines < 1) break;
    local_58 = (line_s *)0x0;
    iVar8 = 0;
    do {
      plVar1 = local_3c->lines[iVar8];
      pcVar11 = plVar1->s;
      if (local_3c == pcVar11) {
        local_38 = (corner_s **)local_3c->y;
        iVar16 = local_3c->x;
        iVar13 = plVar1->e->x;
        iVar9 = plVar1->e->y;
      }
      else {
        iVar16 = plVar1->e->x;
        local_38 = (corner_s **)plVar1->e->y;
        iVar13 = pcVar11->x;
        iVar9 = pcVar11->y;
      }
      if (iVar16 == iVar13) {
        iVar16 = (uint)((int)local_38 < iVar9) * 4 + 0x24;
      }
      else {
        if (local_38 != (corner_s **)iVar9) {
          return 0;
        }
        iVar16 = (iVar16 < iVar13) + 0x11;
      }
      if ((fdir == iVar16) && (bVar21 = local_58 != (line_s *)0x0, local_58 = plVar1, bVar21)) {
        return 0;
      }
      if ((rdir == iVar16) && (plVar1 != *(line_s **)(local_64 + -4 + (int)orthopull_1::ls))) {
        return 0;
      }
      iVar8 = iVar8 + 1;
      iVar6 = (iVar6 + (uint)(local_54 == iVar16)) - (uint)(local_50 == iVar16);
    } while (iVar8 < local_3c->n_lines);
    if (local_58 == (line_s *)0x0) break;
    uVar18 = (local_58->line->Flags).f;
    bVar21 = true;
    if ((uVar18 & 0x40) == 0) {
      bVar21 = bVar22;
    }
    bVar22 = bVar21;
    bVar21 = true;
    if (-1 < (char)uVar18) {
      bVar21 = bVar4;
    }
    bVar4 = bVar21;
    if (orthopull_1::lm <= local_6c) {
      orthopull_1::lm = local_74;
      orthopull_1::ls = (line_s **)realloc(orthopull_1::ls,local_80);
    }
    *(line_s **)((int)orthopull_1::ls + local_64) = local_58;
    local_3c = other_corner(local_58,local_3c);
    local_6c = iVar14;
    if (local_3c == (corner_s *)0x0) break;
    if (local_3c->pad != (PadType *)0x0) {
      return 0;
    }
    if (local_3c->pin != (PinType *)0x0) {
      return 0;
    }
    local_64 = local_64 + 4;
    local_74 = local_74 + 1;
    local_80 = local_80 + 0x14;
    if (local_3c->n_lines < 2) {
      return 0;
    }
    local_68 = iVar7;
    if (orthopull_1::cm <= iVar14) {
LAB_08084190:
      orthopull_1::cm = local_74;
      orthopull_1::cs = (corner_s **)realloc(orthopull_1::cs,local_74 * 0x2c);
    }
  }
  if (iVar6 == 0) {
    return 0;
  }
  if (iVar14 < 2) {
    return 0;
  }
  if (bVar22) {
    if (any_sel == 0) goto LAB_08084245;
  }
  else {
    if (any_sel != 0) {
      return 0;
    }
LAB_08084245:
    if ((!bVar4) && (autorouted_only != 0)) {
      return 0;
    }
  }
  rr.y1 = 0x7fffffff;
  rr.x1 = 0x7fffffff;
  rr.y2 = -0x80000000;
  rr.x2 = -0x80000000;
  iVar8 = corner_radius(c);
  add_point_to_rect(&rr,c->x,c->y,iVar8);
  iVar8 = corner_radius(local_3c);
  add_point_to_rect(&rr,local_3c->x,local_3c->y,iVar8);
  bVar22 = fdir == 0x12;
  if (((((-1 < iVar6) || (bVar5 = 0x24, !bVar22)) && ((iVar6 < 1 || (bVar5 = 0x28, !bVar22)))) &&
      ((-1 < iVar6 || (bVar5 = 0x11, fdir != 0x28)))) &&
     ((iVar6 < 1 || (bVar5 = 0x12, fdir != 0x28)))) {
    bVar5 = 0;
  }
  local_58 = (line_s *)0x0;
  local_50 = 0;
  local_40 = -1;
  local_38 = orthopull_1::cs;
  do {
    pcVar11 = local_38[(int)local_58];
    iVar8 = 0;
    if (0 < pcVar11->n_lines) {
      do {
        plVar1 = pcVar11->lines[iVar8];
        pcVar3 = plVar1->s;
        if (pcVar11 == pcVar3) {
          iVar16 = pcVar11->x;
          iVar13 = pcVar11->y;
          iVar9 = plVar1->e->x;
          iVar17 = plVar1->e->y;
        }
        else {
          iVar16 = plVar1->e->x;
          iVar13 = plVar1->e->y;
          iVar9 = pcVar3->x;
          iVar17 = pcVar3->y;
        }
        if (iVar16 == iVar9) {
          bVar15 = (iVar13 < iVar17) * '\x04' + 0x24;
LAB_08084384:
          if (bVar5 == bVar15) {
            local_50 = line_length(plVar1);
            if ((local_50 < local_40) || (local_40 == -1)) {
              local_38 = orthopull_1::cs;
              local_40 = local_50;
            }
            else {
              local_38 = orthopull_1::cs;
            }
          }
        }
        else if (iVar13 == iVar17) {
          bVar15 = (iVar16 < iVar9) + 0x11;
          goto LAB_08084384;
        }
        iVar8 = iVar8 + 1;
        pcVar11 = local_38[(int)local_58];
      } while (pcVar11->n_lines != iVar8 && iVar8 <= pcVar11->n_lines);
    }
    local_58 = (line_s *)((int)local_58 + 1);
  } while ((int)local_58 < iVar14);
  if (bVar5 == 0x12) {
    rr.x2 = iVar7 + c->x + local_40;
  }
  else if (bVar5 < 0x13) {
    if (bVar5 == 0x11) {
      rr.x1 = (c->x - iVar7) - local_40;
    }
  }
  else if (bVar5 == 0x24) {
    rr.y1 = (c->y - iVar7) - local_40;
  }
  else if (bVar5 == 0x28) {
    rr.y2 = iVar7 + c->y + local_40;
  }
  bVar4 = false;
  rr.x1 = (rr.x1 - PCB->Bloat) + -2;
  rr.x2 = rr.x2 + PCB->Bloat + 2;
  rr.y1 = (rr.y1 + -2) - PCB->Bloat;
  rr.y2 = rr.y2 + PCB->Bloat + 2;
  ppcVar12 = local_38;
  for (pcVar11 = corners; plVar1 = lines, pcVar11 != (corner_s *)0x0; pcVar11 = pcVar11->next) {
    if ((pcVar11->layer != -0x21524111) &&
       ((iVar7 = corner_radius(pcVar11), pcVar11->net != c->net || (pcVar11->pad != (PadType *)0x0))
       )) {
      local_84 = pcVar11->x;
      local_48 = pcVar11->y;
      if (((rr.x1 <= local_84) || (rr.x1 <= iVar7 + local_84)) &&
         ((((local_84 <= rr.x2 || (local_84 - iVar7 <= rr.x2)) &&
           ((rr.y1 <= local_48 || (rr.y1 <= iVar7 + local_48)))) &&
          ((local_48 <= rr.y2 || (local_48 - iVar7 <= rr.y2)))))) {
        if (bVar5 == 0x12) {
          iVar8 = 0;
          ppcVar12 = orthopull_1::cs;
          do {
            iVar16 = pcVar11->layer;
            iVar13 = ppcVar12[iVar8]->layer;
            if ((((iVar16 == -1) || (iVar13 == -1)) || (iVar16 == iVar13)) ||
               (layer_groupings[iVar13] == layer_groupings[iVar16])) {
              iVar13 = corner_radius(ppcVar12[iVar8]);
              iVar16 = orthopull_1::cs[iVar8]->y;
              uVar18 = ~PCB->Bloat;
              local_48 = pcVar11->y;
              ppcVar12 = orthopull_1::cs;
              if (((int)((uVar18 + iVar16) - iVar13) <= iVar7 + local_48) &&
                 (local_48 - iVar7 <= (int)(PCB->Bloat + 1U + iVar16 + iVar13))) {
                iVar16 = orthopull_1::cs[iVar8]->x;
                if ((iVar16 < pcVar11->x) &&
                   (uVar19 = pcVar11->x - iVar16, uVar20 = (int)uVar19 >> 0x1f,
                   iVar13 = (((uVar18 - 1) + ((uVar19 ^ uVar20) - uVar20)) - iVar7) - iVar13,
                   iVar13 < local_40)) {
                  bVar4 = true;
                  local_40 = iVar13;
                }
              }
            }
            iVar8 = iVar8 + 1;
          } while (iVar8 < iVar14);
          if (local_6c != 0) {
            iVar8 = pcVar11->layer;
            iVar16 = 0;
            do {
              iVar13 = orthopull_1::ls[iVar16]->layer;
              if ((((iVar13 == -1) || (iVar8 == -1)) ||
                  ((iVar13 == iVar8 || (layer_groupings[iVar13] == layer_groupings[iVar8])))) &&
                 (((ppcVar12[iVar16]->y < local_48 && (local_48 < ppcVar12[iVar16 + 1]->y)) &&
                  (uVar18 = pcVar11->x - ppcVar12[iVar16]->x, uVar19 = (int)uVar18 >> 0x1f,
                  iVar13 = ((~PCB->Bloat - orthopull_1::ls[iVar16]->line->Thickness / 2) + -1 +
                           ((uVar18 ^ uVar19) - uVar19)) - iVar7, iVar13 < local_40)))) {
                bVar4 = true;
                local_40 = iVar13;
              }
              iVar16 = iVar16 + 1;
            } while (iVar16 != local_6c);
          }
        }
        else if (bVar5 < 0x13) {
          if (bVar5 == 0x11) {
            iVar8 = 0;
            ppcVar12 = orthopull_1::cs;
            do {
              iVar16 = pcVar11->layer;
              iVar13 = ppcVar12[iVar8]->layer;
              if (((iVar16 == -1) || (iVar13 == -1)) ||
                 ((iVar16 == iVar13 || (layer_groupings[iVar13] == layer_groupings[iVar16])))) {
                iVar13 = corner_radius(ppcVar12[iVar8]);
                iVar16 = orthopull_1::cs[iVar8]->y;
                uVar18 = ~PCB->Bloat;
                local_48 = pcVar11->y;
                ppcVar12 = orthopull_1::cs;
                if (((int)((uVar18 + iVar16) - iVar13) <= iVar7 + local_48) &&
                   (local_48 - iVar7 <= (int)(PCB->Bloat + 1U + iVar16 + iVar13))) {
                  iVar16 = orthopull_1::cs[iVar8]->x;
                  if ((pcVar11->x < iVar16) &&
                     (uVar19 = pcVar11->x - iVar16, uVar20 = (int)uVar19 >> 0x1f,
                     iVar13 = (((uVar18 - 1) + ((uVar19 ^ uVar20) - uVar20)) - iVar7) - iVar13,
                     iVar13 < local_40)) {
                    bVar4 = true;
                    local_40 = iVar13;
                  }
                }
              }
              iVar8 = iVar8 + 1;
            } while (iVar8 < iVar14);
            if (local_6c != 0) {
              iVar8 = pcVar11->layer;
              iVar16 = 0;
              do {
                iVar13 = orthopull_1::ls[iVar16]->layer;
                if (((((iVar13 == -1) || (iVar8 == -1)) || (iVar8 == iVar13)) ||
                    (layer_groupings[iVar13] == layer_groupings[iVar8])) &&
                   (((ppcVar12[iVar16]->y < local_48 && (local_48 < ppcVar12[iVar16 + 1]->y)) &&
                    (uVar18 = pcVar11->x - ppcVar12[iVar16]->x, uVar19 = (int)uVar18 >> 0x1f,
                    iVar13 = ((~PCB->Bloat - orthopull_1::ls[iVar16]->line->Thickness / 2) + -1 +
                             ((uVar18 ^ uVar19) - uVar19)) - iVar7, iVar13 < local_40)))) {
                  bVar4 = true;
                  local_40 = iVar13;
                }
                iVar16 = iVar16 + 1;
              } while (iVar16 != local_6c);
            }
          }
        }
        else if (bVar5 == 0x24) {
          iVar8 = 0;
          ppcVar12 = orthopull_1::cs;
          do {
            iVar16 = pcVar11->layer;
            iVar13 = ppcVar12[iVar8]->layer;
            if (((iVar16 == -1) || (iVar13 == -1)) ||
               ((iVar16 == iVar13 || (layer_groupings[iVar13] == layer_groupings[iVar16])))) {
              iVar13 = corner_radius(ppcVar12[iVar8]);
              iVar16 = orthopull_1::cs[iVar8]->x;
              uVar18 = ~PCB->Bloat;
              local_84 = pcVar11->x;
              ppcVar12 = orthopull_1::cs;
              if (((int)((uVar18 + iVar16) - iVar13) <= iVar7 + local_84) &&
                 (local_84 - iVar7 <= (int)(PCB->Bloat + 1U + iVar16 + iVar13))) {
                iVar16 = orthopull_1::cs[iVar8]->y;
                if ((pcVar11->y < iVar16) &&
                   (uVar19 = pcVar11->y - iVar16, uVar20 = (int)uVar19 >> 0x1f,
                   iVar13 = (((uVar18 - 1) + ((uVar19 ^ uVar20) - uVar20)) - iVar7) - iVar13,
                   iVar13 < local_40)) {
                  bVar4 = true;
                  local_40 = iVar13;
                }
              }
            }
            iVar8 = iVar8 + 1;
          } while (iVar8 < iVar14);
          if (local_6c != 0) {
            iVar8 = pcVar11->layer;
            iVar16 = 0;
            do {
              iVar13 = orthopull_1::ls[iVar16]->layer;
              if (((((iVar13 == -1) || (iVar8 == -1)) || (iVar13 == iVar8)) ||
                  (layer_groupings[iVar13] == layer_groupings[iVar8])) &&
                 (((ppcVar12[iVar16]->x < local_84 && (local_84 < ppcVar12[iVar16 + 1]->x)) &&
                  (uVar18 = pcVar11->y - ppcVar12[iVar16]->y, uVar19 = (int)uVar18 >> 0x1f,
                  iVar13 = ((~PCB->Bloat - orthopull_1::ls[iVar16]->line->Thickness / 2) + -1 +
                           ((uVar18 ^ uVar19) - uVar19)) - iVar7, iVar13 < local_40)))) {
                bVar4 = true;
                local_40 = iVar13;
              }
              iVar16 = iVar16 + 1;
            } while (iVar16 != local_6c);
          }
        }
        else if (bVar5 == 0x28) {
          iVar8 = 0;
          ppcVar12 = orthopull_1::cs;
          do {
            iVar16 = pcVar11->layer;
            iVar13 = ppcVar12[iVar8]->layer;
            if (((iVar16 == -1) || (iVar13 == -1)) ||
               ((iVar16 == iVar13 || (layer_groupings[iVar13] == layer_groupings[iVar16])))) {
              iVar13 = corner_radius(ppcVar12[iVar8]);
              local_84 = pcVar11->x;
              iVar16 = orthopull_1::cs[iVar8]->x;
              uVar18 = ~PCB->Bloat;
              ppcVar12 = orthopull_1::cs;
              if (((int)((uVar18 + iVar16) - iVar13) <= iVar7 + local_84) &&
                 (local_84 - iVar7 <= (int)(PCB->Bloat + 1U + iVar16 + iVar13))) {
                iVar16 = orthopull_1::cs[iVar8]->y;
                if ((iVar16 < pcVar11->y) &&
                   (uVar19 = pcVar11->y - iVar16, uVar20 = (int)uVar19 >> 0x1f,
                   iVar13 = (((uVar18 - 1) + ((uVar19 ^ uVar20) - uVar20)) - iVar7) - iVar13,
                   iVar13 < local_40)) {
                  bVar4 = true;
                  local_40 = iVar13;
                }
              }
            }
            iVar8 = iVar8 + 1;
          } while (iVar8 < iVar14);
          if (local_6c != 0) {
            iVar8 = pcVar11->layer;
            iVar16 = 0;
            do {
              iVar13 = orthopull_1::ls[iVar16]->layer;
              if ((((((iVar13 == -1) || (iVar8 == -1)) || (iVar8 == iVar13)) ||
                   (layer_groupings[iVar13] == layer_groupings[iVar8])) &&
                  ((ppcVar12[iVar16]->x < local_84 && (local_84 < ppcVar12[iVar16 + 1]->x)))) &&
                 (uVar18 = pcVar11->y - ppcVar12[iVar16]->y, uVar19 = (int)uVar18 >> 0x1f,
                 iVar13 = ((~PCB->Bloat - orthopull_1::ls[iVar16]->line->Thickness / 2) + -1 +
                          ((uVar18 ^ uVar19) - uVar19)) - iVar7, iVar13 < local_40)) {
                bVar4 = true;
                local_40 = iVar13;
              }
              iVar16 = iVar16 + 1;
            } while (iVar16 != local_6c);
          }
        }
      }
    }
    ppcVar12 = orthopull_1::cs;
  }
  for (; plVar1 != (line_s *)0x0; plVar1 = plVar1->next) {
    if ((plVar1->layer != -0x21524111) && (pcVar11 = plVar1->s, pcVar11->net != c->net)) {
      iVar7 = pcVar11->x;
      iVar8 = pcVar11->y;
      local_38 = (corner_s **)plVar1->e->x;
      local_5c = plVar1->e->y;
      if (local_38 == (corner_s **)iVar7) {
        iVar16 = (uint)(local_5c < iVar8) * 4 + 0x24;
      }
      else {
        iVar16 = 0xf0;
        if (local_5c == iVar8) {
          iVar16 = ((int)local_38 < iVar7) + 0x11;
        }
      }
      local_68 = iVar8;
      local_64 = iVar7;
      if (bVar22) {
        if ((iVar16 != 0x28) && (iVar16 != 0x24)) {
          if (iVar7 < (int)local_38) {
            local_68 = local_5c;
            local_64 = (int)local_38;
            local_5c = iVar8;
            local_38 = (corner_s **)iVar7;
          }
          if (!bVar22) goto LAB_08084592;
          if ((c->x <= local_64) && ((int)local_38 <= local_3c->x)) goto LAB_0808459c;
        }
      }
      else {
        if (fdir == 0x28) {
          if (iVar16 - 0x11U < 2) goto LAB_080846e1;
          iVar16 = local_5c;
          iVar13 = (int)local_38;
          if (local_5c <= iVar8) goto LAB_08084592;
LAB_08084900:
          local_38 = (corner_s **)iVar7;
          local_5c = iVar8;
          local_64 = iVar13;
          local_68 = iVar16;
          if ((c->y != local_68 && local_68 <= c->y) || (local_3c->y < local_5c)) goto LAB_080846e1;
        }
        else {
LAB_08084592:
          iVar16 = local_68;
          iVar13 = local_64;
          iVar8 = local_5c;
          iVar7 = (int)local_38;
          if (fdir == 0x28) goto LAB_08084900;
        }
LAB_0808459c:
        if (bVar5 == 0x24) {
          if ((c->y < local_5c) && (c->y < local_68)) goto LAB_080846e1;
LAB_08084991:
          if (local_5c < local_68) {
LAB_0808499d:
            local_5c = local_68;
          }
        }
        else if (bVar5 == 0x28) {
          if ((local_5c < c->y) && (local_68 < c->y)) goto LAB_080846e1;
LAB_08084c0a:
          if (local_68 < local_5c) goto LAB_0808499d;
        }
        else if (bVar5 == 0x11) {
          if ((c->x < (int)local_38) && (c->x < local_64)) goto LAB_080846e1;
LAB_080845ce:
          if ((int)local_38 < local_64) {
LAB_080845d6:
            local_38 = (corner_s **)local_64;
          }
        }
        else if (bVar5 == 0x12) {
          if (((int)local_38 < c->x) && (local_64 < c->x)) goto LAB_080846e1;
          if (local_64 < (int)local_38) goto LAB_080845d6;
        }
        else if (bVar5 < 0x13) {
          if (bVar5 == 0x11) goto LAB_080845ce;
        }
        else {
          if (bVar5 == 0x24) goto LAB_08084991;
          if (bVar5 == 0x28) goto LAB_08084c0a;
        }
        iVar7 = 0;
        do {
          iVar16 = plVar1->line->Thickness;
          iVar13 = PCB->Bloat;
          iVar9 = corner_radius(ppcVar12[iVar7]);
          iVar8 = local_40;
          if (bVar22) {
            pcVar11 = orthopull_1::cs[iVar7];
            if ((pcVar11->x <= local_64) && ((int)local_38 <= pcVar11->x)) goto LAB_0808464c;
          }
          else {
            if (fdir == 0x28) {
              pcVar11 = orthopull_1::cs[iVar7];
              if ((local_68 < pcVar11->y) || (pcVar11->y < local_5c)) goto LAB_08084600;
            }
            else {
              pcVar11 = orthopull_1::cs[iVar7];
            }
LAB_0808464c:
            iVar17 = plVar1->layer;
            iVar2 = pcVar11->layer;
            if ((((iVar17 == -1) || (iVar2 == -1)) || (iVar17 == iVar2)) ||
               (layer_groupings[iVar2] == layer_groupings[iVar17])) {
              if (bVar5 == 0x12) {
                iVar8 = (int)local_38 - c->x;
              }
              else if (bVar5 < 0x13) {
                if (bVar5 == 0x11) {
                  iVar8 = c->x - (int)local_38;
                }
                else {
LAB_08084672:
                  iVar8 = 0;
                }
              }
              else if (bVar5 == 0x24) {
                iVar8 = c->y - local_5c;
              }
              else {
                if (bVar5 != 0x28) goto LAB_08084672;
                iVar8 = local_5c - c->y;
              }
              iVar8 = (iVar8 - iVar9) + -2 + (-iVar16 - iVar13);
              if (iVar8 < 1) {
                return 0;
              }
              if (local_40 <= iVar8) {
                iVar8 = local_40;
              }
            }
          }
LAB_08084600:
          local_40 = iVar8;
          iVar7 = iVar7 + 1;
          ppcVar12 = orthopull_1::cs;
        } while (iVar7 < iVar14);
      }
    }
LAB_080846e1:
  }
  do {
    local_48 = 0;
    bVar21 = true;
    do {
      iVar7 = 0;
      pcVar11 = ppcVar12[local_48];
      if (0 < pcVar11->n_lines) {
        do {
          plVar1 = pcVar11->lines[iVar7];
          pcVar10 = other_corner(plVar1,pcVar11);
          pcVar3 = plVar1->s;
          pcVar11 = orthopull_1::cs[local_48];
          if (pcVar11 == pcVar3) {
            local_58 = (line_s *)pcVar11->y;
            local_3c = (corner_s *)pcVar11->x;
            local_38 = (corner_s **)plVar1->e->x;
            iVar8 = plVar1->e->y;
          }
          else {
            local_3c = (corner_s *)plVar1->e->x;
            local_58 = (line_s *)plVar1->e->y;
            local_38 = (corner_s **)pcVar3->x;
            iVar8 = pcVar3->y;
          }
          if (local_3c == (corner_s *)local_38) {
            bVar15 = ((int)local_58 < iVar8) * '\x04' + 0x24;
LAB_08084791:
            if (bVar5 == bVar15) {
              local_50 = line_length(plVar1);
              if ((pcVar10->pad == (PadType *)0x0) ||
                 (orthopull_1::cs[local_48]->via == (PinType *)0x0)) {
                pcVar11 = plVar1->s;
                if ((pcVar11->pin == (PinType *)0x0) &&
                   ((pcVar11->pad == (PadType *)0x0 && (pcVar11->via == (PinType *)0x0)))) {
                  pcVar11 = orthopull_1::cs[local_48];
                }
                else {
                  pcVar3 = plVar1->e;
                  if ((pcVar3->pin == (PinType *)0x0) &&
                     ((pcVar3->pad == (PadType *)0x0 && (pcVar3->via == (PinType *)0x0))))
                  goto LAB_08084d12;
                  if (local_40 != local_50) goto LAB_080847c5;
                  pcVar11 = orthopull_1::cs[local_48];
                  local_50 = local_40;
                }
              }
              else {
                pcVar11 = plVar1->s;
LAB_080847c5:
                iVar8 = corner_radius(pcVar11);
                iVar16 = corner_radius(plVar1->e);
                local_50 = ((local_50 + (-2 - PCB->Bloat)) - iVar8) - iVar16;
                if (local_50 < local_40) {
                  bVar21 = false;
                  pcVar11 = orthopull_1::cs[local_48];
                  local_40 = local_50;
                }
                else {
LAB_08084d12:
                  pcVar11 = orthopull_1::cs[local_48];
                }
              }
            }
          }
          else if (local_58 == (line_s *)iVar8) {
            bVar15 = ((int)local_3c < (int)local_38) + 0x11;
            goto LAB_08084791;
          }
          iVar7 = iVar7 + 1;
          ppcVar12 = orthopull_1::cs;
        } while (pcVar11->n_lines != iVar7 && iVar7 <= pcVar11->n_lines);
      }
      local_48 = local_48 + 1;
    } while (local_48 < iVar14);
  } while (!bVar21);
  if (local_40 < 1) {
    return 0;
  }
  if (bVar5 == 0x12) {
    local_50 = local_40 + c->x;
  }
  else if (bVar5 < 0x13) {
    if (bVar5 == 0x11) {
      local_50 = c->x - local_40;
    }
  }
  else if (bVar5 == 0x24) {
    local_50 = c->y - local_40;
  }
  else if (bVar5 == 0x28) {
    local_50 = local_40 + c->y;
  }
  if ((bVar4) && (Settings.Grid < (double)local_40)) {
    if (iVar6 < 0) {
      local_50 = (int)ROUND((Settings.Grid - 1.0) + (double)local_50);
    }
    local_50 = local_50 - local_50 % (int)ROUND(Settings.Grid);
  }
  if (bVar22) {
    iVar7 = (*ppcVar12)->y;
  }
  else {
    if (fdir != 0x28) goto LAB_08084a70;
    iVar7 = (*ppcVar12)->x;
  }
  if (iVar7 == local_50) {
    return 0;
  }
LAB_08084a70:
  iVar7 = 0;
  iVar8 = 0;
  do {
    if (bVar22) {
      pcVar11 = *(corner_s **)((int)ppcVar12 + iVar7);
      iVar16 = pcVar11->y;
      move_corner(pcVar11,pcVar11->x,local_50);
    }
    else {
      pcVar11 = *(corner_s **)((int)ppcVar12 + iVar7);
      iVar16 = pcVar11->x;
      move_corner(pcVar11,local_50,pcVar11->y);
    }
    local_38 = (corner_s **)(local_50 - iVar16);
    iVar8 = iVar8 + 1;
    iVar7 = iVar7 + 4;
    ppcVar12 = orthopull_1::cs;
  } while (iVar8 < iVar14);
  return (int)local_38 * iVar6;
}



// WARNING: Unknown calling convention

int canonicalize_line(line_s *l)

{
  corner_s **ppcVar1;
  corner_s *pcVar2;
  int iVar3;
  int iVar4;
  Boolean BVar5;
  int iVar6;
  PinType *PV;
  int y1;
  int x1_1;
  corner_s *c;
  corner_s *pcVar7;
  int iVar8;
  int x1;
  int iVar9;
  int th;
  int y1_1;
  corner_s *local_30;
  int local_28;
  int local_20;
  
  pcVar2 = l->e;
  local_30 = l->s;
  local_20 = pcVar2->x;
  iVar6 = local_30->x;
  pcVar7 = corners;
  if (iVar6 == local_20) {
    local_20 = pcVar2->y;
    iVar9 = local_30->y;
    iVar8 = l->line->Thickness / 2;
    iVar6 = iVar9;
    if (local_20 < iVar9) {
      iVar6 = local_20;
      local_20 = iVar9;
    }
    if (corners != (corner_s *)0x0) {
      do {
        iVar9 = pcVar7->layer;
        if ((((iVar9 != -0x21524111) && (iVar3 = pcVar7->y, iVar6 < iVar3)) && (iVar3 < local_20))
           && (((iVar4 = l->layer, iVar9 == -1 || (iVar4 == -1)) ||
               ((iVar9 == iVar4 || (layer_groupings[iVar4] == layer_groupings[iVar9])))))) {
          iVar9 = pcVar7->x;
          if (iVar9 == local_30->x) goto LAB_08085710;
          if (((iVar9 < iVar6 + iVar8) && (iVar6 - iVar8 < iVar9)) &&
             ((pcVar7->pad == (PadType *)0x0 && (pcVar7->pin == (PinType *)0x0)))) {
            move_corner(pcVar7,local_30->x,iVar3);
            local_30 = l->s;
            if (pcVar7->x == local_30->x) goto LAB_08085710;
          }
        }
        ppcVar1 = &pcVar7->next;
        pcVar7 = *ppcVar1;
      } while (*ppcVar1 != (corner_s *)0x0);
    }
  }
  else {
    local_28 = local_30->y;
    iVar9 = pcVar2->y;
    if (local_28 == iVar9) {
      iVar8 = l->line->Thickness / 2;
      iVar9 = iVar6;
      if (local_20 < iVar6) {
        iVar9 = local_20;
        local_20 = iVar6;
      }
      if (corners != (corner_s *)0x0) {
        do {
          iVar6 = pcVar7->layer;
          if ((((iVar6 != -0x21524111) && (iVar3 = pcVar7->x, iVar9 < iVar3)) && (iVar3 < local_20))
             && (((iVar4 = l->layer, iVar6 == -1 || (iVar4 == -1)) ||
                 ((iVar6 == iVar4 || (layer_groupings[iVar4] == layer_groupings[iVar6])))))) {
            iVar6 = pcVar7->y;
            if (iVar6 == local_30->y) goto LAB_08085710;
            if (((iVar6 < local_28 + iVar8) && (local_28 - iVar8 < iVar6)) &&
               ((pcVar7->pad == (PadType *)0x0 && (pcVar7->pin == (PinType *)0x0)))) {
              move_corner(pcVar7,iVar3,local_30->y);
              local_30 = l->s;
              if (pcVar7->y == local_30->y) goto LAB_08085710;
            }
          }
          ppcVar1 = &pcVar7->next;
          pcVar7 = *ppcVar1;
        } while (*ppcVar1 != (corner_s *)0x0);
      }
    }
    else {
      x1 = iVar6;
      if (local_20 < iVar6) {
        x1 = local_20;
        local_20 = iVar6;
      }
      local_30 = (corner_s *)iVar9;
      if (iVar9 < local_28) {
        local_30 = (corner_s *)local_28;
        local_28 = iVar9;
      }
      if (corners != (corner_s *)0x0) {
        do {
          while( true ) {
            iVar6 = pcVar7->layer;
            if (iVar6 == -0x21524111) goto LAB_080854a0;
            if ((pcVar7->via != (PinType *)0x0) || (pcVar7->pin != (PinType *)0x0)) break;
            pcVar7 = pcVar7->next;
joined_r0x080854c8:
            if (pcVar7 == (corner_s *)0x0) {
              return 0;
            }
          }
          iVar9 = pcVar7->x;
          if ((iVar9 <= x1) ||
             (((local_20 <= iVar9 || (iVar8 = pcVar7->y, iVar8 <= local_28)) ||
              ((int)local_30 <= iVar8)))) {
LAB_080854a0:
            pcVar7 = pcVar7->next;
            goto joined_r0x080854c8;
          }
          iVar3 = l->layer;
          if ((((iVar6 == -1) || (iVar3 == -1)) || (iVar6 == iVar3)) ||
             (layer_groupings[iVar3] == layer_groupings[iVar6])) {
            if (pcVar7->pin == (PinType *)0x0) {
              th = pcVar7->via->Thickness;
            }
            else {
              th = pcVar7->pin->Thickness;
            }
            iVar6 = dist(l->s->x,l->s->y,iVar9,iVar8);
            if ((th / 2 < iVar6) &&
               (iVar6 = dist(l->e->x,l->e->y,pcVar7->x,pcVar7->y), th / 2 < iVar6)) {
              PV = pcVar7->pin;
              if (PV == (PinType *)0x0) {
                PV = pcVar7->via;
              }
              BVar5 = PinLineIntersect((PinTypePtr)PV,l->line);
              if (BVar5 != '\0') {
LAB_08085710:
                iVar6 = split_line(l,pcVar7);
                return iVar6;
              }
            }
            goto LAB_080854a0;
          }
          pcVar7 = pcVar7->next;
        } while (pcVar7 != (corner_s *)0x0);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int simple_optimizations(void)

{
  LineType **ppLVar1;
  FlagType *pFVar2;
  line_s **pplVar3;
  corner_s *pcVar4;
  char cVar5;
  int i;
  int iVar6;
  int y2;
  int iVar7;
  corner_s *pcVar8;
  char cVar9;
  int o;
  int y1;
  line_s *plVar10;
  corner_s *c;
  corner_s *c_00;
  int iVar11;
  int rv;
  int rv_1;
  int iVar12;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  
  iVar11 = 0;
  c_00 = corners;
  if (corners != (corner_s *)0x0) {
    do {
      if (((c_00->layer != -0x21524111) && (c_00->pad == (PadType *)0x0)) &&
         (c_00->pin == (PinType *)0x0)) {
        if (((c_00->via == (PinType *)0x0) ||
            (iVar6 = mem_any_set((c_00->via->Flags).t,8), iVar6 != 0)) || (c_00->via->Mask != 0)) {
          iVar6 = c_00->n_lines;
          iVar12 = 0;
        }
        else {
          iVar6 = c_00->n_lines;
          local_28 = 1;
          if (iVar6 < 2) {
LAB_080857e0:
            if (local_28 == iVar6) {
              iVar12 = 1;
              remove_via_at(c_00);
              iVar6 = c_00->n_lines;
              goto LAB_080857ff;
            }
          }
          else {
            pplVar3 = c_00->lines;
            if (pplVar3[1]->layer == (*pplVar3)->layer) {
              local_28 = 1;
              do {
                local_28 = local_28 + 1;
                if (iVar6 <= local_28) goto LAB_080857e0;
              } while (pplVar3[local_28]->layer == pplVar3[1]->layer);
              goto LAB_08085750;
            }
          }
          iVar12 = 0;
        }
LAB_080857ff:
        if ((iVar6 == 2) && (c_00->via == (PinType *)0x0)) {
          plVar10 = *c_00->lines;
          pcVar4 = plVar10->s;
          if (c_00 == pcVar4) {
            local_24 = c_00->x;
            local_20 = plVar10->e->x;
            iVar7 = plVar10->e->y;
            iVar6 = c_00->y;
          }
          else {
            local_24 = plVar10->e->x;
            iVar6 = plVar10->e->y;
            local_20 = pcVar4->x;
            iVar7 = pcVar4->y;
          }
          if (local_24 == local_20) {
            cVar9 = (iVar6 < iVar7) * '\x04' + '$';
          }
          else {
            cVar9 = -0x10;
            if (iVar6 == iVar7) {
              cVar9 = (local_24 < local_20) + '\x11';
            }
          }
          pcVar8 = other_corner(c_00->lines[1],c_00);
          other_corner(*c_00->lines,c_00);
          pplVar3 = c_00->lines;
          plVar10 = pplVar3[1];
          pcVar4 = plVar10->s;
          if (pcVar8 == pcVar4) {
            local_34 = pcVar8->x;
            local_30 = pcVar8->y;
            local_2c = plVar10->e->x;
            local_28 = plVar10->e->y;
          }
          else {
            local_34 = plVar10->e->x;
            local_30 = plVar10->e->y;
            local_2c = pcVar4->x;
            local_28 = pcVar4->y;
          }
          if (local_34 == local_2c) {
            cVar5 = (local_30 < local_28) * '\x04' + '$';
          }
          else {
            cVar5 = -0x10;
            if (local_30 == local_28) {
              cVar5 = (local_34 < local_2c) + '\x11';
            }
          }
          if ((cVar9 == cVar5) && (cVar9 != -0x10)) {
            if ((*(byte *)&((*pplVar3)->line->Flags).f & 0x40) != 0) {
              ppLVar1 = &plVar10->line;
              plVar10 = pplVar3[1];
              pFVar2 = &(*ppLVar1)->Flags;
              pFVar2->f = pFVar2->f | 0x40;
            }
            if ((*(byte *)&(plVar10->line->Flags).f & 0x40) != 0) {
              pFVar2 = &(*pplVar3)->line->Flags;
              pFVar2->f = pFVar2->f | 0x40;
            }
            iVar11 = iVar11 + iVar12;
            move_corner(c_00,pcVar8->x,pcVar8->y);
            goto LAB_08085750;
          }
        }
        iVar11 = iVar11 + iVar12;
      }
LAB_08085750:
      c_00 = c_00->next;
    } while (c_00 != (corner_s *)0x0);
  }
  return iVar11;
}



// WARNING: Unknown calling convention

int debumpify(void)

{
  line_s **pplVar1;
  LineType *pLVar2;
  corner_s *pcVar3;
  int iVar4;
  line_s *plVar5;
  int step;
  int iVar6;
  corner_s *pcVar7;
  corner_s *pcVar8;
  byte bVar9;
  byte bVar10;
  line_s *l2;
  line_s *l_00;
  byte bVar11;
  int y2;
  int iVar12;
  int iVar13;
  line_s *l;
  int any_selected;
  int iVar14;
  int rv;
  bool bVar15;
  line_s *local_70;
  int local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  corner_s *local_50;
  int local_4c;
  int local_48;
  rect_s rp;
  rect_s rr;
  
  iVar14 = 0;
  plVar5 = lines;
  if (lines != (line_s *)0x0) {
    do {
      if (((plVar5->layer != -0x21524111) && (plVar5->line != (LineType *)0x0)) &&
         ((*(byte *)&(plVar5->line->Flags).f & 0x40) != 0)) {
        any_selected._0_1_ = true;
        goto LAB_08085a32;
      }
      pplVar1 = &plVar5->next;
      plVar5 = *pplVar1;
    } while (*pplVar1 != (line_s *)0x0);
    any_selected._0_1_ = false;
LAB_08085a32:
    iVar14 = 0;
    plVar5 = lines;
    do {
      while ((plVar5->layer == -0x21524111 || (pLVar2 = plVar5->line, pLVar2 == (LineType *)0x0))) {
LAB_08085a52:
        plVar5 = plVar5->next;
        if (plVar5 == (line_s *)0x0) goto LAB_08085a80;
      }
      if (!any_selected._0_1_) {
        if ((autorouted_only == 0) || (*(char *)&(pLVar2->Flags).f < '\0')) goto LAB_08085a48;
        goto LAB_08085a52;
      }
      if ((*(byte *)&(pLVar2->Flags).f & 0x40) != 0) {
LAB_08085a48:
        pcVar7 = plVar5->s;
        if ((((pcVar7->pin == (PinType *)0x0) && (pcVar7->pad == (PadType *)0x0)) &&
            (pcVar8 = plVar5->e, pcVar8->pin == (PinType *)0x0)) && (pcVar8->pad == (PadType *)0x0))
        {
          local_58 = pcVar8->x;
          local_60 = pcVar8->y;
          local_5c = pcVar7->x;
          local_64 = pcVar7->y;
          if (local_58 == local_5c) {
            bVar9 = (local_60 < local_64) * '\x04' + 0x24;
          }
          else {
            if (local_60 != local_64) goto LAB_08085a52;
            bVar9 = (local_58 < local_5c) + 0x11;
          }
          if (pcVar7->via == (PinType *)0x0) {
            local_50 = (corner_s *)0x0;
            for (local_4c = 0; local_4c < pcVar7->n_lines; local_4c = local_4c + 1) {
              local_70 = pcVar7->lines[local_4c];
              if (plVar5 == local_70) {
                local_70 = (line_s *)local_50;
              }
              else if (local_50 != (corner_s *)0x0) goto LAB_08085a52;
              local_50 = (corner_s *)local_70;
            }
            if (local_50 != (corner_s *)0x0) {
              pcVar3 = (corner_s *)local_50->x;
              if (pcVar7 == pcVar3) {
                local_68 = ((corner_s *)local_50->y)->x;
                y2 = ((corner_s *)local_50->y)->y;
              }
              else {
                local_5c = ((corner_s *)local_50->y)->x;
                local_64 = ((corner_s *)local_50->y)->y;
                local_68 = pcVar3->x;
                y2 = pcVar3->y;
              }
              if (local_5c == local_68) {
                bVar11 = (local_64 < y2) * '\x04' + 0x24;
              }
              else {
                bVar11 = 0xf0;
                if (local_64 == y2) {
                  bVar11 = (local_5c < local_68) + 0x11;
                }
              }
              if (pcVar8->via == (PinType *)0x0) {
                l_00 = (line_s *)0x0;
                for (local_5c = 0; local_5c < pcVar8->n_lines; local_5c = local_5c + 1) {
                  if ((plVar5 != pcVar8->lines[local_5c]) &&
                     (bVar15 = l_00 != (line_s *)0x0, l_00 = pcVar8->lines[local_5c], bVar15))
                  goto LAB_08085a52;
                }
                if (l_00 != (line_s *)0x0) {
                  pcVar7 = l_00->s;
                  if (pcVar8 == pcVar7) {
                    local_48 = l_00->e->x;
                    local_5c = l_00->e->y;
                  }
                  else {
                    local_58 = l_00->e->x;
                    local_60 = l_00->e->y;
                    local_48 = pcVar7->x;
                    local_5c = pcVar7->y;
                  }
                  if (local_58 == local_48) {
                    bVar10 = (local_60 < local_5c) * '\x04' + 0x24;
                  }
                  else {
                    bVar10 = 0xf0;
                    if (local_60 == local_5c) {
                      bVar10 = (local_58 < local_48) + 0x11;
                    }
                  }
                  if (((bVar11 == bVar10) && (((bVar11 ^ bVar9) & 0xf0) != 0)) && (bVar11 != 0xf0))
                  {
                    rr.y1 = 0x7fffffff;
                    rr.x1 = 0x7fffffff;
                    rr.y2 = -0x80000000;
                    rr.x2 = -0x80000000;
                    iVar6 = PCB->Bloat + 2 + pLVar2->Thickness / 2;
                    add_line_to_rect(&rr,(line_s *)local_50);
                    add_line_to_rect(&rr,l_00);
                    pcVar7 = plVar5->s;
                    if ((rr.x1 != pcVar7->x) && (rr.x1 != plVar5->e->x)) {
                      rr.x1 = rr.x1 - iVar6;
                    }
                    if ((pcVar7->x != rr.x2) && (rr.x2 != plVar5->e->x)) {
                      rr.x2 = iVar6 + rr.x2;
                    }
                    if ((rr.y1 != pcVar7->y) && (rr.y1 != plVar5->e->y)) {
                      rr.y1 = rr.y1 - iVar6;
                    }
                    if ((pcVar7->y != rr.y2) && (rr.y2 != plVar5->e->y)) {
                      rr.y2 = iVar6 + rr.y2;
                    }
                    pcVar7 = other_corner((line_s *)local_50,pcVar7);
                    pcVar8 = other_corner(l_00,plVar5->e);
                    rp.y1 = 0x7fffffff;
                    rp.x1 = 0x7fffffff;
                    rp.y2 = -0x80000000;
                    rp.x2 = -0x80000000;
                    for (local_50 = corners; local_50 != (corner_s *)0x0; local_50 = local_50->next)
                    {
                      iVar4 = local_50->layer;
                      if (((iVar4 != -0x21524111) && (local_50->net != plVar5->s->net)) &&
                         ((iVar12 = plVar5->s->layer, iVar12 == -1 ||
                          (((iVar4 == -1 || (iVar4 == iVar12)) ||
                           (layer_groupings[iVar4] == layer_groupings[iVar12])))))) {
                        add_corner_to_rect_if(&rp,local_50,&rr);
                      }
                    }
                    if (rp.x1 == 0x7fffffff) {
                      rp.x1 = rr.x2;
                      rp.x2 = rr.x1;
                      rp.y1 = rr.y2;
                      rp.y2 = rr.y1;
                    }
                    if (bVar11 == 0x12) {
                      pcVar3 = plVar5->s;
                      iVar4 = pcVar3->x;
                      iVar6 = (rp.x1 - iVar4) - iVar6;
                      local_48 = 0;
                      if (0 < iVar6) {
                        local_48 = iVar6 - iVar6 % (int)ROUND(Settings.Grid);
                      }
                      iVar6 = pcVar8->x - iVar4;
                      iVar12 = pcVar7->x - iVar4;
                      if (iVar12 < iVar6) {
                        iVar6 = iVar12;
                      }
                      if (local_48 < iVar6) {
                        iVar6 = local_48;
                      }
                      if (0 < iVar6) {
                        move_corner(pcVar3,iVar6 + iVar4,pcVar3->y);
                        pcVar7 = plVar5->e;
                        move_corner(pcVar7,iVar6 + pcVar7->x,pcVar7->y);
                        iVar14 = iVar14 + iVar6;
                      }
                    }
                    else if (bVar11 < 0x13) {
                      if (bVar11 == 0x11) {
                        pcVar3 = plVar5->s;
                        local_5c = 0;
                        iVar4 = pcVar3->x;
                        iVar6 = (iVar4 - rp.x2) - iVar6;
                        if (0 < iVar6) {
                          local_5c = iVar6 - iVar6 % (int)ROUND(Settings.Grid);
                        }
                        iVar6 = iVar4 - pcVar8->x;
                        iVar12 = iVar4 - pcVar7->x;
                        if (iVar12 < iVar6) {
                          iVar6 = iVar12;
                        }
                        if (local_5c < iVar6) {
                          iVar6 = local_5c;
                        }
                        if (0 < iVar6) {
                          move_corner(pcVar3,iVar4 - iVar6,pcVar3->y);
                          pcVar7 = plVar5->e;
                          move_corner(pcVar7,pcVar7->x - iVar6,pcVar7->y);
                          iVar14 = iVar14 + iVar6;
                        }
                      }
                    }
                    else if (bVar11 == 0x24) {
                      if (rp.y2 == -0x80000000) {
                        rp.y2 = rr.y1;
                      }
                      pcVar3 = plVar5->s;
                      iVar4 = pcVar3->y;
                      iVar12 = iVar4 - pcVar8->y;
                      iVar13 = iVar4 - pcVar7->y;
                      local_48 = (iVar4 - rp.y2) - iVar6;
                      iVar6 = iVar12;
                      if (iVar13 <= iVar12) {
                        iVar6 = iVar13;
                      }
                      if (iVar6 <= local_48) {
                        local_48 = iVar6;
                      }
                      if ((iVar12 != local_48) && (iVar13 != local_48)) {
                        if (local_48 < 1) goto LAB_08085a52;
                        local_48 = local_48 - local_48 % (int)ROUND(Settings.Grid);
                      }
                      if (0 < local_48) {
                        move_corner(pcVar3,pcVar3->x,iVar4 - local_48);
                        pcVar7 = plVar5->e;
                        move_corner(pcVar7,pcVar7->x,pcVar7->y - local_48);
                        iVar14 = iVar14 + local_48;
                      }
                    }
                    else if (bVar11 == 0x28) {
                      pcVar3 = plVar5->s;
                      iVar4 = pcVar3->y;
                      iVar6 = (rp.y1 - iVar4) - iVar6;
                      local_48 = 0;
                      if (0 < iVar6) {
                        local_48 = iVar6 - iVar6 % (int)ROUND(Settings.Grid);
                      }
                      iVar6 = pcVar8->y - iVar4;
                      iVar12 = pcVar7->y - iVar4;
                      if (iVar12 < iVar6) {
                        iVar6 = iVar12;
                      }
                      if (local_48 < iVar6) {
                        iVar6 = local_48;
                      }
                      if (0 < iVar6) {
                        move_corner(pcVar3,pcVar3->x,iVar4 + iVar6);
                        pcVar7 = plVar5->e;
                        move_corner(pcVar7,pcVar7->x,iVar6 + pcVar7->y);
                        iVar14 = iVar14 + iVar6;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        goto LAB_08085a52;
      }
      plVar5 = plVar5->next;
    } while (plVar5 != (line_s *)0x0);
  }
LAB_08085a80:
  iVar6 = simple_optimizations();
  iVar14 = iVar14 + iVar6;
  if (iVar14 != 0) {
    __printf_chk(1,"debumpify: %d mils saved\n",iVar14 / 0x32);
  }
  return iVar14;
}



// WARNING: Unknown calling convention

int unjaggy(void)

{
  line_s *plVar1;
  LineType *pLVar2;
  LineType *pLVar3;
  line_s **pplVar4;
  bool bVar5;
  bool bVar6;
  char cVar7;
  int j;
  line_s *l_1;
  int l;
  int iVar8;
  corner_s *c_00;
  int y2_1;
  corner_s *c_01;
  int x2;
  int iVar9;
  int iVar10;
  char *pcVar11;
  int x1_1;
  int y2;
  char cVar12;
  char cVar13;
  int x2_1;
  int iVar14;
  int x1;
  int o_1;
  int o;
  bool bVar15;
  corner_s *c;
  corner_s *c_02;
  corner_s *cc;
  int y1_1;
  int w;
  corner_s *pcVar16;
  int y1;
  int local_80;
  int local_74;
  int local_70;
  int local_68;
  int local_64;
  int local_5c;
  int local_4c;
  int local_48;
  int local_44;
  rect_s rp;
  rect_s rr;
  
  local_70 = 0;
  local_68 = 0;
  plVar1 = lines;
joined_r0x080861f7:
  do {
    if (plVar1 == (line_s *)0x0) {
      bVar5 = false;
    }
    else {
      if (((plVar1->layer == -0x21524111) || (plVar1->line == (LineType *)0x0)) ||
         ((*(byte *)&(plVar1->line->Flags).f & 0x40) == 0)) {
        plVar1 = plVar1->next;
        goto joined_r0x080861f7;
      }
      bVar5 = true;
    }
    local_64 = 0;
    c_02 = corners;
joined_r0x08086236:
    if (c_02 != (corner_s *)0x0) {
LAB_08086240:
      if ((c_02->layer != -0x21524111) && (iVar8 = simple_corner(c_02), iVar8 != 0)) {
        plVar1 = *c_02->lines;
        pLVar2 = plVar1->line;
        if ((pLVar2 == (LineType *)0x0) ||
           (pLVar3 = c_02->lines[1]->line, pLVar3 == (LineType *)0x0)) goto LAB_08086488;
        if (!bVar5) {
          if (((autorouted_only == 0) || (*(char *)&(pLVar2->Flags).f < '\0')) ||
             (*(char *)&(pLVar3->Flags).f < '\0')) goto LAB_08086298;
          c_02 = c_02->next;
          goto joined_r0x08086520;
        }
        if (((*(byte *)&(pLVar2->Flags).f & 0x40) == 0) &&
           ((*(byte *)&(pLVar3->Flags).f & 0x40) == 0)) goto LAB_08086488;
LAB_08086298:
        c_00 = other_corner(plVar1,c_02);
        pplVar4 = c_02->lines;
        plVar1 = *pplVar4;
        pcVar16 = plVar1->s;
        if (c_02 == pcVar16) {
          iVar8 = c_02->x;
          iVar10 = c_02->y;
          iVar14 = plVar1->e->x;
          y2_1 = plVar1->e->y;
        }
        else {
          iVar8 = plVar1->e->x;
          iVar10 = plVar1->e->y;
          iVar14 = pcVar16->x;
          y2_1 = pcVar16->y;
        }
        if (iVar8 == iVar14) {
          cVar7 = (iVar10 < y2_1) * '\x04' + '$';
        }
        else {
          cVar7 = -0x10;
          if (iVar10 == y2_1) {
            cVar7 = (iVar8 < iVar14) + '\x11';
          }
        }
        iVar8 = simple_corner(c_00);
        c_01 = other_corner(pplVar4[1],c_02);
        pplVar4 = c_02->lines;
        plVar1 = pplVar4[1];
        pcVar16 = plVar1->s;
        if (c_02 == pcVar16) {
          iVar10 = c_02->x;
          iVar14 = c_02->y;
          iVar9 = plVar1->e->x;
          y2 = plVar1->e->y;
        }
        else {
          iVar10 = plVar1->e->x;
          iVar14 = plVar1->e->y;
          iVar9 = pcVar16->x;
          y2 = pcVar16->y;
        }
        if (iVar10 == iVar9) {
          cVar13 = (iVar14 < y2) * '\x04' + '$';
        }
        else {
          cVar13 = -0x10;
          if (iVar14 == y2) {
            cVar13 = (iVar10 < iVar9) + '\x11';
          }
        }
        iVar10 = simple_corner(c_01);
        if ((iVar10 != 0) || (iVar8 != 0)) {
          bVar15 = true;
          iVar8 = c_00->n_lines;
          if (0 < iVar8) {
            iVar10 = 0;
            do {
              while ((plVar1 = c_00->lines[iVar10], plVar1 != *pplVar4 &&
                     (plVar1->layer == (*pplVar4)->layer))) {
                pcVar16 = plVar1->s;
                if (c_00 == pcVar16) {
                  local_48 = c_00->x;
                  local_5c = c_00->y;
                  local_80 = plVar1->e->x;
                  local_4c = plVar1->e->y;
                }
                else {
                  local_48 = plVar1->e->x;
                  local_5c = plVar1->e->y;
                  local_80 = pcVar16->x;
                  local_4c = pcVar16->y;
                }
                if (local_48 == local_80) {
                  cVar12 = (local_5c < local_4c) * '\x04' + '$';
                }
                else {
                  cVar12 = -0x10;
                  if (local_5c == local_4c) {
                    cVar12 = (local_48 < local_80) + '\x11';
                  }
                }
                bVar6 = false;
                if (cVar13 != cVar12) {
                  bVar6 = bVar15;
                }
                bVar15 = bVar6;
                iVar10 = iVar10 + 1;
                if (iVar10 == iVar8) goto LAB_080863df;
              }
              iVar10 = iVar10 + 1;
            } while (iVar10 != iVar8);
          }
LAB_080863df:
          iVar8 = c_01->n_lines;
          if (0 < iVar8) {
            iVar10 = 0;
            do {
              while ((plVar1 = c_01->lines[iVar10], plVar1 != *pplVar4 &&
                     (plVar1->layer == (*pplVar4)->layer))) {
                pcVar16 = plVar1->s;
                if (c_01 == pcVar16) {
                  local_44 = c_01->x;
                  local_4c = c_01->y;
                  local_74 = plVar1->e->x;
                  local_48 = plVar1->e->y;
                }
                else {
                  local_44 = plVar1->e->x;
                  local_4c = plVar1->e->y;
                  local_74 = pcVar16->x;
                  local_48 = pcVar16->y;
                }
                if (local_44 == local_74) {
                  cVar13 = (local_4c < local_48) * '\x04' + '$';
                }
                else {
                  cVar13 = -0x10;
                  if (local_4c == local_48) {
                    cVar13 = (local_44 < local_74) + '\x11';
                  }
                }
                bVar6 = false;
                if (cVar7 != cVar13) {
                  bVar6 = bVar15;
                }
                bVar15 = bVar6;
                iVar10 = iVar10 + 1;
                if (iVar10 == iVar8) goto LAB_08086477;
              }
              iVar10 = iVar10 + 1;
            } while (iVar10 != iVar8);
          }
LAB_08086477:
          if (bVar15) {
            rr.y1 = 0x7fffffff;
            rr.x1 = 0x7fffffff;
            rr.y2 = -0x80000000;
            iVar8 = PCB->Bloat + 2 + (*pplVar4)->line->Thickness / 2;
            rr.x2 = -0x80000000;
            add_line_to_rect(&rr,*pplVar4);
            add_line_to_rect(&rr,c_02->lines[1]);
            if (c_02->x == rr.x1) {
              rr.x2 = rr.x2 + iVar8;
            }
            else {
              rr.x1 = rr.x1 - iVar8;
            }
            if (c_02->y == rr.y1) {
              rr.y2 = rr.y2 + iVar8;
            }
            else {
              rr.y1 = rr.y1 - iVar8;
            }
            rp.y1 = 0x7fffffff;
            rp.x1 = 0x7fffffff;
            rp.y2 = -0x80000000;
            rp.x2 = -0x80000000;
            pcVar16 = corners;
            if (corners == (corner_s *)0x0) break;
            do {
              while (((iVar8 = pcVar16->layer, iVar8 != -0x21524111 && (pcVar16->net != c_02->net))
                     && ((iVar10 = c_02->layer, iVar10 == -1 ||
                         (((iVar8 == -1 || (iVar8 == iVar10)) ||
                          (layer_groupings[iVar8] == layer_groupings[iVar10]))))))) {
                add_corner_to_rect_if(&rp,pcVar16,&rr);
                pcVar16 = pcVar16->next;
                if (pcVar16 == (corner_s *)0x0) goto LAB_0808661d;
              }
              pcVar16 = pcVar16->next;
            } while (pcVar16 != (corner_s *)0x0);
LAB_0808661d:
            if (rp.x2 < rp.x1) break;
          }
        }
      }
LAB_08086488:
      c_02 = c_02->next;
joined_r0x08086520:
      if (c_02 == (corner_s *)0x0) goto LAB_08086493;
      goto LAB_08086240;
    }
LAB_08086493:
    iVar8 = simple_optimizations();
    if (iVar8 + local_64 == 0) goto LAB_080864ae;
    local_68 = local_68 + 1;
    local_70 = local_70 + iVar8 + local_64;
    plVar1 = lines;
    if (local_68 == 100) {
LAB_080864ae:
      if (local_70 != 0) {
        pcVar11 = "ies";
        if (local_70 == 1) {
          pcVar11 = "y";
        }
        __printf_chk(1,"%d unjagg%s    \n",local_70,pcVar11);
      }
      return local_70;
    }
  } while( true );
  if (c_02->x == c_00->x) {
    move_corner(c_02,c_01->x,c_00->y);
  }
  else {
    move_corner(c_02,c_00->x,c_01->y);
  }
  c_02 = c_02->next;
  local_64 = local_64 + 1;
  goto joined_r0x08086236;
}



// WARNING: Unknown calling convention

int viatrim(void)

{
  line_s **pplVar1;
  corner_s *pcVar2;
  corner_s *pcVar3;
  int iVar4;
  DataTypePtr paVar5;
  Cardinal CVar6;
  LineTypePtr pLVar7;
  LineType *Ptr2;
  LineType *pLVar8;
  Cardinal CVar9;
  LineTypePtr pLVar10;
  bool bVar11;
  line_s *plVar12;
  int i;
  int iVar13;
  LineType *pLVar14;
  line_s *l2_1;
  line_s *plVar15;
  LineType *to;
  LineType *pLVar16;
  LineType *oldbase;
  int iVar17;
  int other_layer;
  int vrm;
  line_s *l;
  line_s *l2;
  bool bVar18;
  int local_50;
  rect_s lr;
  rect_s r;
  
  plVar12 = lines;
  if (lines == (line_s *)0x0) {
    iVar17 = simple_optimizations();
    local_50 = 0;
  }
  else {
    do {
      if (((plVar12->layer != -0x21524111) && (plVar12->line != (LineType *)0x0)) &&
         ((*(byte *)&(plVar12->line->Flags).f & 0x40) != 0)) {
        bVar11 = true;
        goto LAB_08086827;
      }
      pplVar1 = &plVar12->next;
      plVar12 = *pplVar1;
    } while (*pplVar1 != (line_s *)0x0);
    bVar11 = false;
LAB_08086827:
    local_50 = 0;
    plVar12 = lines;
LAB_08086830:
    do {
      if (((plVar12->layer == -0x21524111) || (pcVar2 = plVar12->s, pcVar2->via == (PinType *)0x0))
         || (pcVar3 = plVar12->e, pcVar3->via == (PinType *)0x0)) {
LAB_08086a08:
        plVar12 = plVar12->next;
      }
      else {
        if (bVar11) {
          if ((*(byte *)&(plVar12->line->Flags).f & 0x40) == 0) {
            plVar12 = plVar12->next;
            if (plVar12 == (line_s *)0x0) break;
            goto LAB_08086830;
          }
        }
        else if ((autorouted_only != 0) && (-1 < *(char *)&(plVar12->line->Flags).f))
        goto LAB_08086a08;
        if (pcVar2->n_lines < 1) {
LAB_08086a70:
          if (pcVar3->n_lines < 1) {
            iVar17 = -1;
          }
          else {
            iVar17 = -1;
            iVar13 = 0;
            do {
              if (pcVar3->lines[iVar13] != plVar12) {
                if (iVar17 == -1) {
                  iVar17 = pcVar2->lines[iVar13]->layer;
                }
                else {
                  iVar4 = pcVar3->lines[iVar13]->layer;
                  bVar18 = iVar4 != iVar17;
                  iVar17 = iVar4;
                  if (bVar18) goto LAB_08086a08;
                }
              }
              iVar13 = iVar13 + 1;
            } while (iVar13 < pcVar3->n_lines);
          }
        }
        else {
          iVar17 = -1;
          iVar13 = 0;
          while( true ) {
            plVar15 = pcVar2->lines[iVar13];
            if (plVar15 != plVar12) {
              if (iVar17 == -1) {
                iVar17 = plVar15->layer;
              }
              else {
                bVar18 = plVar15->layer != iVar17;
                iVar17 = plVar15->layer;
                if (bVar18) goto LAB_08086a70;
              }
            }
            if (pcVar2->n_lines <= iVar13 + 1) break;
            iVar13 = iVar13 + 1;
          }
          if (iVar17 == -1) goto LAB_08086a70;
        }
        r.y1 = 0x7fffffff;
        r.x1 = 0x7fffffff;
        r.y2 = -0x80000000;
        r.x2 = -0x80000000;
        add_point_to_rect(&r,pcVar2->x,pcVar2->y,plVar12->line->Thickness);
        add_point_to_rect(&r,plVar12->e->x,plVar12->e->y,plVar12->line->Thickness);
        for (plVar15 = lines; plVar15 != (line_s *)0x0; plVar15 = plVar15->next) {
          if (((plVar15->layer != -0x21524111) &&
              (pcVar2 = plVar15->s, pcVar2->net != plVar12->s->net)) && (iVar17 == plVar15->layer))
          {
            lr.y1 = 0x7fffffff;
            lr.x1 = 0x7fffffff;
            lr.y2 = -0x80000000;
            lr.x2 = -0x80000000;
            add_point_to_rect(&lr,pcVar2->x,pcVar2->y,plVar15->line->Thickness / 2);
            add_point_to_rect(&lr,plVar15->e->x,plVar15->e->y,plVar15->line->Thickness / 2);
            if (lr.x1 < r.x1) {
              lr.x1 = r.x1;
            }
            if (r.x2 < lr.x2) {
              lr.x2 = r.x2;
            }
            if (lr.y1 < r.y1) {
              lr.y1 = r.y1;
            }
            if (r.y2 < lr.y2) {
              lr.y2 = r.y2;
            }
            if ((lr.x1 < lr.x2) && (lr.y1 < lr.y2)) goto LAB_08086a08;
          }
        }
        iVar13 = plVar12->layer;
        if (iVar13 == iVar17) goto LAB_08086a08;
        paVar5 = PCB->Data;
        CVar6 = paVar5->Layer[iVar13].LineN;
        pLVar7 = paVar5->Layer[iVar13].Line;
        Ptr2 = plVar12->line;
        pLVar8 = paVar5->Layer[iVar17].Line;
        CVar9 = paVar5->Layer[iVar17].LineN;
        pLVar14 = (LineType *)
                  MoveObjectToLayer(4,paVar5->Layer + iVar13,Ptr2,(void *)0x0,paVar5->Layer + iVar17
                                    ,'\0');
        pLVar10 = paVar5->Layer[iVar17].Line;
        if (lines != (line_s *)0x0) {
          plVar15 = lines;
          do {
            if (plVar15->layer != -0x21524111) {
              pLVar16 = plVar15->line;
              if (pLVar7 + (CVar6 - 1) == plVar15->line) {
                plVar15->line = Ptr2;
                pLVar16 = Ptr2;
              }
              if ((pLVar8 <= pLVar16) && (pLVar16 < pLVar8 + CVar9)) {
                plVar15->line =
                     (LineType *)
                     ((pLVar16->Flags).t + (((int)pLVar10 - (int)pLVar8 & 0xfffffff8U) - 0x18));
              }
            }
            plVar15 = plVar15->next;
          } while (plVar15 != (line_s *)0x0);
        }
        plVar12->layer = iVar17;
        local_50 = local_50 + 1;
        plVar12->line = pLVar14;
        plVar12 = plVar12->next;
      }
    } while (plVar12 != (line_s *)0x0);
    iVar17 = simple_optimizations();
    if (local_50 != 0) {
      __printf_chk(1,"viatrim: %d traces moved, %d vias removed\n",local_50,iVar17);
    }
  }
  return iVar17 + local_50;
}



// WARNING: Unknown calling convention

int orthopull(void)

{
  line_s **pplVar1;
  corner_s *pcVar2;
  corner_s *pcVar3;
  line_s *l;
  line_s *plVar4;
  int iVar5;
  corner_s *c;
  corner_s *c_00;
  int iVar6;
  int rv;
  int any_sel;
  
  plVar4 = lines;
  if (lines != (line_s *)0x0) {
    do {
      if (((plVar4->layer != -0x21524111) && (plVar4->line != (LineType *)0x0)) &&
         ((*(byte *)&(plVar4->line->Flags).f & 0x40) != 0)) {
        any_sel = 1;
        goto LAB_08086c4a;
      }
      pplVar1 = &plVar4->next;
      plVar4 = *pplVar1;
    } while (*pplVar1 != (line_s *)0x0);
  }
  any_sel = 0;
LAB_08086c4a:
  iVar6 = 0;
  pcVar3 = corners;
LAB_08086c62:
  c_00 = pcVar3;
  if (c_00 == (corner_s *)0x0) {
    if (iVar6 != 0) {
      __printf_chk(1,"orthopull: %d mils saved\n",iVar6 / 100);
    }
    return iVar6;
  }
  if (c_00->layer == -0x21524111) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if ((c_00->pin == (PinType *)0x0) && (c_00->pad == (PadType *)0x0)) goto code_r0x08086c82;
  goto LAB_08086c5f;
code_r0x08086c82:
  next_corner = c_00;
  iVar5 = orthopull_1(c_00,0x12,0x11,any_sel);
  pcVar2 = next_corner;
  iVar6 = iVar6 + iVar5;
  pcVar3 = next_corner;
  if (next_corner == c_00) {
    iVar5 = orthopull_1(c_00,0x28,0x24,any_sel);
    iVar6 = iVar6 + iVar5;
    pcVar3 = next_corner;
    c_00 = next_corner;
    if (pcVar2 == next_corner) {
LAB_08086c5f:
      pcVar3 = c_00->next;
    }
  }
  goto LAB_08086c62;
}



// WARNING: Unknown calling convention

void register_djopt_action_list(void)

{
  hid_register_actions(djopt_action_list,2);
  return;
}



// WARNING: Unknown calling convention

void register_djopt_flag_list(void)

{
  hid_register_flags(djopt_flag_list,1);
  return;
}



// WARNING: Removing unreachable block (ram,0x08086f34)
// WARNING: Removing unreachable block (ram,0x08086f30)
// WARNING: Unknown calling convention

int vianudge(void)

{
  corner_s **ppcVar1;
  corner_s *pcVar2;
  int y2;
  int x2_00;
  int x1;
  double dVar3;
  double dVar4;
  int iVar5;
  int iVar6;
  byte bVar7;
  uchar uVar8;
  int x2;
  byte bVar9;
  int i;
  int iVar10;
  corner_s *c;
  corner_s *c_00;
  corner_s *c3;
  line_s *plVar11;
  int iVar12;
  corner_s *pcVar13;
  int o;
  int in_GS_OFFSET;
  int local_78;
  int local_74;
  corner_s *local_70;
  int local_6c;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  uchar counts [16];
  uchar directions [16];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  directions[0] = '\0';
  directions[1] = '\0';
  directions[2] = '\0';
  directions[3] = '\0';
  directions[4] = '\0';
  directions[5] = '\0';
  directions[6] = '\0';
  directions[7] = '\0';
  directions[8] = '\0';
  directions[9] = '\0';
  directions[10] = '\0';
  directions[11] = '\0';
  directions[12] = '\0';
  directions[13] = '\0';
  directions[14] = '\0';
  directions[15] = '\0';
  counts[0] = '\0';
  counts[1] = '\0';
  counts[2] = '\0';
  counts[3] = '\0';
  counts[4] = '\0';
  counts[5] = '\0';
  counts[6] = '\0';
  counts[7] = '\0';
  counts[8] = '\0';
  counts[9] = '\0';
  counts[10] = '\0';
  counts[11] = '\0';
  counts[12] = '\0';
  counts[13] = '\0';
  counts[14] = '\0';
  counts[15] = '\0';
  local_6c = 0;
  c_00 = corners;
  if (corners != (corner_s *)0x0) {
    do {
      if ((c_00->layer != -0x21524111) && (c_00->via != (PinType *)0x0)) {
        directions[0] = '\0';
        directions[1] = '\0';
        directions[2] = '\0';
        directions[3] = '\0';
        directions[4] = '\0';
        directions[5] = '\0';
        directions[6] = '\0';
        directions[7] = '\0';
        directions[8] = '\0';
        directions[9] = '\0';
        directions[10] = '\0';
        directions[11] = '\0';
        directions[12] = '\0';
        directions[13] = '\0';
        directions[14] = '\0';
        directions[15] = '\0';
        counts[0] = '\0';
        counts[1] = '\0';
        counts[2] = '\0';
        counts[3] = '\0';
        counts[4] = '\0';
        counts[5] = '\0';
        counts[6] = '\0';
        counts[7] = '\0';
        counts[8] = '\0';
        counts[9] = '\0';
        counts[10] = '\0';
        counts[11] = '\0';
        counts[12] = '\0';
        counts[13] = '\0';
        counts[14] = '\0';
        counts[15] = '\0';
        if (0 < c_00->n_lines) {
          iVar12 = 0;
          do {
            plVar11 = c_00->lines[iVar12];
            pcVar13 = plVar11->s;
            if (c_00 == pcVar13) {
              local_58 = c_00->x;
              local_5c = c_00->y;
              local_64 = plVar11->e->x;
              local_60 = plVar11->e->y;
            }
            else {
              local_58 = plVar11->e->x;
              local_5c = plVar11->e->y;
              local_64 = pcVar13->x;
              local_60 = pcVar13->y;
            }
            if (local_58 == local_64) {
              bVar7 = (local_5c < local_60) * '\x04' + 0x24;
            }
            else {
              bVar7 = 0xf0;
              if (local_5c == local_60) {
                bVar7 = (local_58 < local_64) + 0x11;
              }
            }
            iVar5 = iVar12 + 1;
            counts[plVar11->layer] = counts[plVar11->layer] + '\x01';
            directions[c_00->lines[iVar12]->layer] = directions[c_00->lines[iVar12]->layer] | bVar7;
            iVar12 = iVar5;
          } while (c_00->n_lines != iVar5 && iVar5 <= c_00->n_lines);
        }
        iVar12 = PCB->Data->LayerN;
        if (0 < iVar12) {
          iVar5 = 0;
          uVar8 = counts[0];
          while (uVar8 != '\x01') {
            if (iVar12 <= iVar5 + 1) goto LAB_08087050;
            uVar8 = counts[iVar5 + 1];
            iVar5 = iVar5 + 1;
          }
          bVar7 = directions[iVar5];
          if (bVar7 == 0x24) {
LAB_08087173:
            bVar9 = 0x2c;
LAB_08087135:
            iVar5 = 0;
            uVar8 = counts[0];
            while( true ) {
              if (((uVar8 != '\0') && (bVar7 != directions[iVar5])) && (bVar9 != directions[iVar5]))
              goto LAB_08087050;
              if (iVar12 <= iVar5 + 1) break;
              uVar8 = counts[iVar5 + 1];
              iVar5 = iVar5 + 1;
            }
            if (c_00->n_lines < 1) {
              local_5c = 0;
              local_74 = 0;
              local_70 = (corner_s *)0x0;
            }
            else {
              local_5c = 0;
              iVar12 = 0;
              local_74 = 0;
              local_70 = (corner_s *)0x0;
              do {
                while( true ) {
                  iVar5 = line_length(c_00->lines[iVar12]);
                  plVar11 = c_00->lines[iVar12];
                  pcVar13 = plVar11->s;
                  if (c_00 == pcVar13) {
                    local_78 = c_00->x;
                    local_60 = c_00->y;
                    iVar6 = plVar11->e->x;
                    local_64 = plVar11->e->y;
                  }
                  else {
                    local_78 = plVar11->e->x;
                    local_60 = plVar11->e->y;
                    iVar6 = pcVar13->x;
                    local_64 = pcVar13->y;
                  }
                  if (local_78 == iVar6) break;
                  bVar9 = 0xf0;
                  if (local_60 == local_64) {
                    bVar9 = (local_78 < iVar6) + 0x11;
                  }
                  if (bVar7 == bVar9) goto LAB_08087216;
LAB_080871b6:
                  local_5c = local_5c + -1;
LAB_080871ba:
                  iVar12 = iVar12 + 1;
                  if (c_00->n_lines == iVar12 || c_00->n_lines < iVar12) goto LAB_08087241;
                }
                if (bVar7 != (byte)((local_60 < local_64) * '\x04' + 0x24U)) goto LAB_080871b6;
LAB_08087216:
                local_5c = local_5c + 1;
                if ((local_74 <= iVar5) && (local_70 != (corner_s *)0x0)) goto LAB_080871ba;
                iVar12 = iVar12 + 1;
                local_70 = other_corner(plVar11,c_00);
                local_74 = iVar5;
              } while (c_00->n_lines != iVar12 && iVar12 <= c_00->n_lines);
            }
LAB_08087241:
            if (((local_70->pad == (PadType *)0x0) && (local_70->pin == (PinType *)0x0)) &&
               (local_70->via == (PinType *)0x0)) {
              iVar12 = PCB->Bloat + 2 + c_00->via->Thickness / 2;
              for (pcVar13 = corners; plVar11 = lines, pcVar13 != (corner_s *)0x0;
                  pcVar13 = pcVar13->next) {
                if ((pcVar13->layer != -0x21524111) &&
                   (((pcVar13->net != c_00->net &&
                     ((pcVar13->pin != (PinType *)0x0 || (pcVar13->via != (PinType *)0x0)))) ||
                    (pcVar13->pad != (PadType *)0x0)))) {
                  iVar5 = corner_radius(pcVar13);
                  iVar6 = dist(local_70->x,local_70->y,pcVar13->x,pcVar13->y);
                  if (iVar6 < iVar5 + iVar12) goto LAB_08087050;
                }
              }
              for (; plVar11 != (line_s *)0x0; plVar11 = plVar11->next) {
                if ((plVar11->layer != -0x21524111) &&
                   (pcVar13 = plVar11->s, pcVar13->net != c_00->net)) {
                  pcVar2 = plVar11->e;
                  iVar5 = pcVar13->x;
                  iVar6 = pcVar2->x;
                  if (iVar5 == iVar6) {
                    iVar5 = dist_ltp2(iVar5 - local_70->x,local_70->y,pcVar13->y,pcVar2->y);
                  }
                  else {
                    iVar10 = pcVar13->y;
                    if (iVar10 == pcVar2->y) {
                      iVar5 = dist_ltp2(iVar10 - local_70->y,local_70->x,iVar5,iVar6);
                    }
                    else {
                      iVar10 = iVar10 - pcVar2->y;
                      dVar3 = SQRT((double)(iVar10 * iVar10 + (iVar5 - iVar6) * (iVar5 - iVar6)));
                      if (dVar3 == 0.0) {
                        iVar5 = dist(pcVar13->x,pcVar13->y,local_70->x,local_70->y);
                      }
                      else {
                        iVar5 = pcVar13->y;
                        iVar6 = pcVar13->x;
                        iVar10 = plVar11->e->y;
                        y2 = local_70->y;
                        x2_00 = local_70->x;
                        x1 = plVar11->e->x;
                        dVar4 = (double)((iVar6 - x1) * (iVar6 - x2_00) +
                                        (iVar5 - iVar10) * (iVar5 - y2)) / (dVar3 * dVar3);
                        if (dVar4 < 0.0) {
                          iVar5 = dist(iVar6,iVar5,x2_00,y2);
                        }
                        else if (1.0 < dVar4) {
                          iVar5 = dist(x1,iVar10,x2_00,y2);
                        }
                        else {
                          iVar5 = (int)ROUND((double)((y2 - iVar5) * (x1 - iVar6) +
                                                     iVar6 * x2_00 * (iVar10 - iVar5)) / dVar3);
                        }
                      }
                    }
                  }
                  if (iVar5 < plVar11->line->Thickness / 2 + iVar12) goto LAB_08087050;
                }
              }
              local_6c = local_6c + local_5c * local_74;
              move_corner(c_00,local_70->x,local_70->y);
            }
          }
          else if (bVar7 < 0x25) {
            if ((byte)(bVar7 - 0x11) < 2) {
              bVar9 = 0x13;
              goto LAB_08087135;
            }
          }
          else if (bVar7 == 0x28) goto LAB_08087173;
        }
      }
LAB_08087050:
      ppcVar1 = &c_00->next;
      c_00 = *ppcVar1;
    } while (*ppcVar1 != (corner_s *)0x0);
    if (local_6c != 0) {
      __printf_chk(1,"vianudge: %d mils saved\n",local_6c / 100);
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_6c;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int ActionDJopt(int argc,char **argv,int x,int y)

{
  Cardinal CVar1;
  ElementTypePtr paVar2;
  uint uVar3;
  PadTypePtr paVar4;
  line_s *plVar5;
  bool bVar6;
  bool bVar7;
  bool bVar8;
  byte bVar9;
  int i;
  int f;
  corner_s *pcVar10;
  corner_s *c;
  Cardinal sn_1;
  line_s *plVar11;
  corner_s *pcVar12;
  Cardinal sn_2;
  int iVar13;
  int iVar14;
  int dist;
  int x2;
  int iVar15;
  int iVar16;
  int iVar17;
  int iVar18;
  int iVar19;
  int l_2;
  DataTypePtr paVar20;
  int layerflag;
  line_s *l_6;
  corner_s *pcVar21;
  LineType *pLVar22;
  int x_1;
  Cardinal CVar23;
  int my;
  int top;
  int y2;
  int y2_2;
  Cardinal (*paCVar24) [18];
  int more;
  int x1;
  PCBTypePtr pPVar25;
  int x1_1;
  int y_1;
  PinTypePtr pin;
  PinType *pPVar26;
  line_s *l;
  corner_s *c_2;
  LineType *l_1;
  corner_s *c_1;
  int o2_1;
  int x1_2;
  int j;
  Cardinal CVar27;
  uint uVar28;
  Cardinal n;
  uint uVar29;
  PadType *pPVar30;
  PinTypePtr via;
  PinTypePtr paVar31;
  int count;
  line_s *t;
  int lt;
  int y1;
  int y2_3;
  int o1_1;
  int y1_2;
  Cardinal (*paCVar32) [18];
  Cardinal sn;
  Cardinal n_1;
  int changes;
  line_s *l_5;
  corner_s *c2;
  int ln;
  corner_s *c2_1;
  int y1_3;
  corner_s *c_00;
  char *local_e4;
  int local_e0;
  corner_s *local_d8;
  PCBTypePtr local_d4;
  corner_s *local_d0;
  corner_s *local_cc;
  int local_c8;
  PCBTypePtr local_c4;
  int local_c0;
  corner_s *best_c [17];
  int best_dist [17];
  rect_s r;
  
  local_e4 = (char *)0x0;
  if (0 < argc) {
    local_e4 = *argv;
  }
  hid_action("Busy");
  pPVar25 = PCB;
  lines = (line_s *)0x0;
  corners = (corner_s *)0x0;
  component_layer = -1;
  paVar20 = PCB->Data;
  local_d4 = PCB;
  solder_layer = -1;
  if (0 < paVar20->LayerN) {
    i = 0;
    do {
      layer_type[i] = '\0';
      paVar20 = pPVar25->Data;
      layer_groupings[i] = 0;
      i = i + 1;
      CVar23 = paVar20->LayerN;
    } while (i < (int)CVar23);
    if (0 < (int)CVar23) {
      local_c0 = 0;
      local_cc = (corner_s *)component_layer;
      local_d0 = (corner_s *)solder_layer;
      do {
        CVar1 = (pPVar25->LayerGroups).Number[local_c0];
        if (CVar1 != 0) {
          paCVar24 = (pPVar25->LayerGroups).Entries[local_c0];
          bVar9 = 0;
          CVar27 = 0;
          paCVar32 = paCVar24;
          do {
            if ((*paCVar32)[0] == CVar23) {
              bVar9 = bVar9 | 2;
            }
            if ((*paCVar32)[0] == CVar23 + 1) {
              bVar9 = bVar9 | 1;
            }
            CVar27 = CVar27 + 1;
            paCVar32 = (Cardinal (*) [18])(*paCVar32 + 1);
          } while (CVar27 != CVar1);
          uVar28 = 0;
          while( true ) {
            if ((*paCVar24)[0] < CVar23) {
              layer_type[(*paCVar24)[0]] = layer_type[(*paCVar24)[0]] | bVar9;
              layer_groupings[(*paCVar24)[0]] = local_c0;
              if ((local_d0 == (corner_s *)0xffffffff) && (bVar9 == 2)) {
                local_d0 = (corner_s *)(*paCVar24)[0];
              }
              if ((local_cc == (corner_s *)0xffffffff) && (bVar9 == 1)) {
                local_cc = (corner_s *)(*paCVar24)[0];
              }
              paVar20 = pPVar25->Data;
              CVar23 = paVar20->LayerN;
            }
            uVar28 = uVar28 + 1;
            paCVar24 = (Cardinal (*) [18])(*paCVar24 + 1);
            if ((pPVar25->LayerGroups).Number[local_c0] <= uVar28) break;
            paVar20 = pPVar25->Data;
            CVar23 = paVar20->LayerN;
          }
        }
        local_c0 = local_c0 + 1;
      } while (local_c0 < (int)CVar23);
      solder_layer = (int)local_d0;
      component_layer = (int)local_cc;
    }
  }
  local_d0 = (corner_s *)(paVar20->ElementN - 1);
  if (local_d0 != (corner_s *)0xffffffff) {
    iVar13 = paVar20->ElementN * 300;
    do {
      local_d4 = (PCBTypePtr)(iVar13 + -300);
      paVar2 = paVar20->Element;
      uVar28 = *(uint *)((int)&paVar2[-1].PinN + iVar13);
      if (uVar28 != 0) {
        uVar29 = 0;
        do {
          pPVar26 = (PinType *)(uVar29 * 0x4c + *(int *)((int)&paVar2[-1].Pin + iVar13));
          pcVar10 = find_corner(pPVar26->X,pPVar26->Y,-1);
          pcVar10->pin = pPVar26;
          uVar3 = *(uint *)((int)&paVar2[-1].PinN + iVar13);
          if (uVar3 == 0) break;
          uVar29 = (uVar3 + 1 + uVar29) - uVar28;
          uVar28 = uVar3;
        } while (uVar29 < uVar3);
      }
      local_c8 = 0;
      local_c4 = (PCBTypePtr)0x0;
      uVar28 = *(uint *)((int)&paVar2[-1].PadN + iVar13);
      uVar29 = uVar28;
      while ((uVar29 != 0 && (local_c4 < uVar29))) {
        pPVar30 = (PadType *)(local_c8 + *(int *)((int)&paVar2[-1].Pad + iVar13));
        iVar14 = solder_layer;
        if (-1 < *(char *)&(pPVar30->Flags).f) {
          iVar14 = component_layer;
        }
        plVar11 = (line_s *)malloc(0x14);
        iVar15 = (pPVar30->Point1).Y;
        plVar11->next = lines;
        lines = plVar11;
        pcVar10 = find_corner((pPVar30->Point1).X,iVar15,iVar14);
        iVar15 = (pPVar30->Point2).Y;
        plVar11->s = pcVar10;
        pcVar10->pad = pPVar30;
        pcVar12 = find_corner((pPVar30->Point2).X,iVar15,iVar14);
        pcVar10 = plVar11->s;
        plVar11->layer = iVar14;
        plVar11->line = (LineType *)pPVar30;
        plVar11->e = pcVar12;
        pcVar12->pad = pPVar30;
        add_line_to_corner(plVar11,pcVar10);
        plVar11->layer = iVar14;
        plVar11->line = (LineType *)pPVar30;
        add_line_to_corner(plVar11,plVar11->s);
        add_line_to_corner(plVar11,plVar11->e);
        uVar29 = *(uint *)((int)&paVar2[-1].PadN + iVar13);
        if (uVar29 == uVar28) {
          local_c4 = (PCBTypePtr)((int)local_c4 + 1);
          local_c8 = local_c8 + 0x68;
          uVar29 = uVar28;
        }
      }
      local_d0 = (corner_s *)((int)local_d0 + -1);
      if (local_d0 == (corner_s *)0xffffffff) goto LAB_080877e2;
      paVar20 = PCB->Data;
      iVar13 = (int)local_d4;
    } while( true );
  }
LAB_080877f4:
  if (paVar20->ViaN != 0) {
    uVar29 = 0;
    uVar28 = paVar20->ViaN;
    do {
      paVar31 = paVar20->Via + uVar29;
      pcVar10 = find_corner(paVar31->X,paVar31->Y,-1);
      local_d4 = PCB;
      paVar20 = PCB->Data;
      pcVar10->via = (PinType *)paVar31;
      uVar3 = paVar20->ViaN;
      if (uVar3 == 0) break;
      uVar29 = (uVar3 + 1 + uVar29) - uVar28;
      uVar28 = uVar3;
    } while (uVar29 < uVar3);
  }
  if ((local_e4 == (char *)0x0) || (iVar13 = strcmp(local_e4,"splitlines"), iVar13 != 0)) {
    local_c0 = 0;
    paVar20 = local_d4->Data;
    if (0 < paVar20->LayerN) {
      do {
        if (paVar20->Layer[local_c0].LineN != 0) {
          uVar28 = 0;
          do {
            l_1 = paVar20->Layer[local_c0].Line + uVar28;
            if ((*(byte *)((int)&(l_1->Flags).f + 1) & 4) == 0) {
              if (((l_1->Point1).X == (l_1->Point2).X) && ((l_1->Point1).Y == (l_1->Point2).Y)) {
                uVar28 = uVar28 - 1;
                RemoveLine(paVar20->Layer + local_c0,l_1);
              }
              else {
                plVar11 = (line_s *)malloc(0x14);
                iVar13 = (l_1->Point1).Y;
                plVar11->next = lines;
                lines = plVar11;
                pcVar10 = find_corner((l_1->Point1).X,iVar13,local_c0);
                iVar13 = (l_1->Point2).Y;
                plVar11->s = pcVar10;
                pcVar10 = find_corner((l_1->Point2).X,iVar13,local_c0);
                plVar11->line = l_1;
                plVar11->e = pcVar10;
                add_line_to_corner(plVar11,plVar11->s);
                add_line_to_corner(plVar11,plVar11->e);
                plVar11->layer = local_c0;
              }
            }
            uVar28 = uVar28 + 1;
            local_d4 = PCB;
          } while (uVar28 < paVar20->Layer[local_c0].LineN);
        }
        paVar20 = local_d4->Data;
        local_c0 = local_c0 + 1;
      } while (paVar20->LayerN != local_c0 && local_c0 <= paVar20->LayerN);
    }
    local_c0 = 0;
    local_d0 = (corner_s *)0x0;
    local_c8 = 0;
    local_c4 = (PCBTypePtr)0x0;
    local_cc = (corner_s *)0x0;
    pcVar12 = corners;
    pcVar10 = corners;
    do {
      if (pcVar10 == (corner_s *)0x0) goto LAB_08087a0f;
      bVar6 = false;
      pcVar21 = pcVar12;
      local_d8 = pcVar10;
      do {
        pcVar12 = local_d8;
        if (pcVar10->layer != -0x21524111) {
          local_d4 = (PCBTypePtr)pcVar10->pin;
          if ((local_d4 == (PCBTypePtr)0x0) &&
             (local_d4 = (PCBTypePtr)pcVar10->via, local_d4 == (PCBTypePtr)0x0)) {
            if (pcVar10->pad == (PadType *)0x0) goto LAB_08087d08;
            pPVar30 = pcVar10->pad;
            if (pPVar30 != (PadType *)0x0) {
              iVar13 = (pPVar30->Point1).X;
              local_c0 = pPVar30->Thickness / 2 + 1;
              iVar14 = (pPVar30->Point2).X;
              iVar15 = iVar14;
              if (iVar13 <= iVar14) {
                iVar15 = iVar13;
              }
              local_cc = (corner_s *)(iVar15 - local_c0);
              iVar15 = iVar14;
              if (iVar14 <= iVar13) {
                iVar15 = iVar13;
              }
              iVar15 = iVar15 + local_c0;
              iVar16 = (pPVar30->Point2).Y;
              iVar17 = (pPVar30->Point1).Y;
              iVar18 = iVar16;
              if (iVar17 <= iVar16) {
                iVar18 = iVar17;
              }
              local_d0 = (corner_s *)(iVar18 - local_c0);
              iVar18 = iVar16;
              if (iVar16 <= iVar17) {
                iVar18 = iVar17;
              }
              iVar18 = iVar18 + local_c0;
              local_c8 = iVar18;
              local_c4 = (PCBTypePtr)iVar15;
              if (iVar14 == iVar13) {
                local_c8 = (iVar17 + iVar16) / 2;
                if (local_c8 <= pcVar10->y) {
                  local_d0 = (corner_s *)(local_c8 + 1);
                  local_c8 = iVar18;
                }
              }
              else {
                local_c4 = (PCBTypePtr)((iVar13 + iVar14) / 2);
                if ((int)local_c4 <= pcVar10->x) {
                  local_cc = (corner_s *)((int)local_c4 + 1);
                  local_c4 = (PCBTypePtr)iVar15;
                }
              }
            }
          }
          else {
            local_c0 = *(int *)&local_d4->RatOn / 2;
            local_cc = (corner_s *)(pcVar10->x - local_c0);
            local_d0 = (corner_s *)(pcVar10->y - local_c0);
            local_c8 = pcVar10->y + local_c0;
            local_c4 = (PCBTypePtr)(pcVar10->x + local_c0);
          }
          iVar13 = PCB->Data->LayerN;
          if (-1 < iVar13) {
            iVar14 = 0;
            do {
              best_dist[iVar14] = local_c0 * 2;
              best_c[iVar14] = (corner_s *)0x0;
              iVar14 = iVar14 + 1;
            } while (iVar14 <= iVar13);
          }
          pcVar12 = pcVar21;
          if (local_d8 != (corner_s *)0x0) {
            local_d8 = (corner_s *)0x0;
            do {
              if (pcVar21->layer == -0x21524111) goto LAB_08087cf5;
              iVar13 = corner_radius(pcVar21);
              if ((((pcVar10 == pcVar21) || (pcVar21->n_lines == 0)) ||
                  (pcVar21->pin != (PinType *)0x0)) ||
                 ((pcVar21->pad != (PadType *)0x0 || (pcVar21->via != (PinType *)0x0)))) {
LAB_08087cd8:
                if (((local_d8 == (corner_s *)0x0) &&
                    (pcVar10->n_lines == (uint)(pcVar10->pad != (PadType *)0x0))) &&
                   (-1 < PCB->Data->LayerN)) {
                  iVar13 = 0;
                  pPVar25 = PCB;
                  do {
                    if (best_c[iVar13] != (corner_s *)0x0) {
                      connect_corners(best_c[iVar13],pcVar10);
                      bVar6 = true;
                      pPVar25 = PCB;
                    }
                    iVar13 = iVar13 + 1;
                  } while (iVar13 <= pPVar25->Data->LayerN);
                }
              }
              else {
                iVar14 = pcVar21->layer;
                iVar15 = pcVar10->layer;
                if ((((iVar14 != -1) && ((iVar15 != -1 && (iVar14 != iVar15)))) &&
                    (layer_groupings[iVar15] != layer_groupings[iVar14])) ||
                   ((((iVar14 = pcVar21->x, iVar14 < (int)local_cc - iVar13 ||
                      (iVar13 + (int)local_c4 < iVar14)) ||
                     (iVar15 = pcVar21->y, iVar15 < (int)local_d0 - iVar13)) ||
                    (iVar13 + local_c8 < iVar15)))) goto LAB_08087cd8;
                iVar14 = ::dist(pcVar10->x,pcVar10->y,iVar14,iVar15);
                if ((local_d4 == (PCBTypePtr)0x0) ||
                   (iVar14 <= iVar13 + *(int *)&local_d4->RatOn / 2)) {
                  iVar13 = pcVar21->n_lines;
                  if (iVar13 != 1) {
                    iVar15 = pcVar21->layer;
                    if (((best_c[iVar15] == (corner_s *)0x0) ||
                        (iVar16 = best_c[iVar15]->n_lines, iVar13 < iVar16)) ||
                       ((iVar14 < best_dist[iVar15] && (iVar13 <= iVar16)))) {
                      best_c[iVar15] = pcVar21;
                      best_dist[iVar15] = iVar14;
                    }
                    goto LAB_08087cd8;
                  }
                  local_d8 = (corner_s *)((int)local_d8 + 1);
                  connect_corners(pcVar10,pcVar21);
                  bVar6 = true;
                }
              }
LAB_08087cf5:
              pcVar21 = pcVar21->next;
            } while (pcVar21 != (corner_s *)0x0);
            local_d8 = corners;
            pcVar12 = corners;
          }
        }
LAB_08087d08:
        pcVar10 = pcVar10->next;
        pcVar21 = local_d8;
      } while (pcVar10 != (corner_s *)0x0);
      pcVar10 = local_d8;
      plVar11 = lines;
    } while (bVar6);
    for (; lines = plVar11, pcVar10 != (corner_s *)0x0; pcVar10 = pcVar10->next) {
      if (((pcVar10->layer != -0x21524111) && (pcVar10->pin == (PinType *)0x0)) &&
         ((pcVar10->via == (PinType *)0x0 &&
          ((pcVar10->pad == (PadType *)0x0 && (pcVar10->n_lines == 1)))))) {
        plVar5 = *pcVar10->lines;
        pcVar12 = plVar5->s;
        if (pcVar10 == pcVar12) {
          iVar13 = pcVar10->x;
          iVar14 = pcVar10->y;
          iVar15 = plVar5->e->x;
          iVar16 = plVar5->e->y;
        }
        else {
          iVar13 = plVar5->e->x;
          iVar14 = plVar5->e->y;
          iVar15 = pcVar12->x;
          iVar16 = pcVar12->y;
        }
        if (iVar13 == iVar15) {
          bVar9 = (iVar14 < iVar16) * '\x04' + 0x24;
        }
        else {
          bVar9 = 0xf0;
          if (iVar14 == iVar16) {
            bVar9 = (iVar13 < iVar15) + 0x11;
          }
        }
        for (; plVar11 != (line_s *)0x0; plVar11 = plVar11->next) {
          if ((plVar11->layer != -0x21524111) && (plVar11->layer == (*pcVar10->lines)->layer)) {
            if (bVar9 == 0x12) {
              pcVar12 = plVar11->e;
              local_c4 = (PCBTypePtr)plVar11->s->x;
              if (((local_c4 == (PCBTypePtr)pcVar12->x) && ((int)local_c4 < pcVar10->x)) &&
                 (pcVar10->x - (plVar11->line->Thickness + plVar5->line->Thickness) / 2 <
                  (int)local_c4)) {
                iVar14 = plVar11->s->y;
                iVar13 = pcVar10->y;
                if (((iVar14 < iVar13) && (iVar13 < pcVar12->y)) ||
                   ((pcVar12->y < iVar13 && (iVar13 < iVar14)))) {
LAB_08088b13:
                  move_corner(pcVar10,(int)local_c4,iVar13);
                }
              }
            }
            else if (bVar9 < 0x13) {
              if (bVar9 == 0x11) {
                pcVar12 = plVar11->e;
                local_c4 = (PCBTypePtr)plVar11->s->x;
                if (((local_c4 == (PCBTypePtr)pcVar12->x) && (pcVar10->x < (int)local_c4)) &&
                   ((int)local_c4 <
                    (plVar11->line->Thickness + plVar5->line->Thickness) / 2 + pcVar10->x)) {
                  iVar14 = plVar11->s->y;
                  iVar13 = pcVar10->y;
                  if (iVar14 < iVar13) {
                    iVar15 = pcVar12->y;
                    if (iVar13 < iVar15) goto LAB_08088b13;
                  }
                  else {
                    iVar15 = pcVar12->y;
                  }
                  if ((iVar15 < iVar13) && (iVar13 < iVar14)) goto LAB_08088b13;
                }
              }
            }
            else if (bVar9 == 0x24) {
              local_cc = plVar11->s;
              local_c4 = (PCBTypePtr)plVar11->e;
              local_d8 = (corner_s *)local_cc->y;
              if (((local_d8 == (corner_s *)((corner_s *)local_c4)->y) &&
                  (pcVar10->y < (int)local_d8)) &&
                 ((int)local_d8 <
                  (plVar11->line->Thickness + plVar5->line->Thickness) / 2 + pcVar10->y)) {
LAB_08088e57:
                iVar13 = pcVar10->x;
                if (((local_cc->x < iVar13) && (iVar13 < *(int *)&local_c4->Flags)) ||
                   ((*(int *)&local_c4->Flags < iVar13 && (iVar13 < local_cc->x)))) {
                  move_corner(pcVar10,iVar13,(int)local_d8);
                }
              }
            }
            else if (bVar9 == 0x28) {
              local_cc = plVar11->s;
              local_c4 = (PCBTypePtr)plVar11->e;
              local_d8 = (corner_s *)local_cc->y;
              if (((local_d8 == (corner_s *)((corner_s *)local_c4)->y) &&
                  ((int)local_d8 < pcVar10->y)) &&
                 (pcVar10->y - (plVar11->line->Thickness + plVar5->line->Thickness) / 2 <
                  (int)local_d8)) goto LAB_08088e57;
            }
          }
        }
      }
      plVar11 = lines;
    }
LAB_08087a0f:
    do {
      pcVar10 = corners;
      if (lines == (line_s *)0x0) break;
      iVar13 = 0;
      plVar11 = lines;
      do {
        if (plVar11->layer != -0x21524111) {
          iVar14 = canonicalize_line(plVar11);
          iVar13 = iVar13 + iVar14;
        }
        plVar11 = plVar11->next;
      } while (plVar11 != (line_s *)0x0);
      pcVar10 = corners;
    } while (iVar13 != 0);
    for (; pcVar10 != (corner_s *)0x0; pcVar10 = pcVar10->next) {
      while ((pcVar10->layer != -0x21524111 && (pcVar10->net == 0))) {
        classify_corner(pcVar10,classify_nets::this_net);
        pcVar10 = pcVar10->next;
        classify_nets::this_net = classify_nets::this_net + 1;
        if (pcVar10 == (corner_s *)0x0) goto LAB_08087a79;
      }
    }
LAB_08087a79:
    if (local_e4 == (char *)0x0) {
LAB_08088425:
      __printf_chk(1,"unknown command: %s\n",local_e4);
      return 1;
    }
    iVar13 = strcmp(local_e4,"debumpify");
    if (iVar13 == 0) {
      local_e0 = debumpify();
      plVar11 = lines;
    }
    else {
      iVar13 = strcmp(local_e4,"unjaggy");
      if (iVar13 == 0) {
        local_e0 = unjaggy();
        plVar11 = lines;
      }
      else {
        iVar13 = strcmp(local_e4,"simple");
        if (iVar13 == 0) {
          local_e0 = simple_optimizations();
          plVar11 = lines;
        }
        else {
          iVar13 = strcmp(local_e4,"vianudge");
          if (iVar13 == 0) {
            local_e0 = vianudge();
            plVar11 = lines;
          }
          else {
            iVar13 = strcmp(local_e4,"viatrim");
            if (iVar13 == 0) {
              local_e0 = viatrim();
              plVar11 = lines;
            }
            else {
              iVar13 = strcmp(local_e4,"orthopull");
              if (iVar13 == 0) {
                local_e0 = orthopull();
                plVar11 = lines;
              }
              else {
                iVar13 = strcmp(local_e4,"auto");
                if (iVar13 == 0) {
                  iVar14 = 99;
                  iVar13 = 1;
                  do {
                    iVar15 = debumpify();
                    iVar16 = unjaggy();
                    iVar17 = orthopull();
                    iVar18 = vianudge();
                    iVar19 = viatrim();
                    iVar15 = iVar16 + iVar15 + iVar17 + iVar18 + iVar19 + iVar13;
                    if (iVar15 == iVar13) break;
                    iVar14 = iVar14 + -1;
                    iVar13 = iVar15;
                  } while (iVar14 != 0);
                  local_e0 = iVar15 + -1;
                  plVar11 = lines;
                }
                else {
                  iVar13 = strcmp(local_e4,"miter");
                  pcVar10 = corners;
                  plVar11 = lines;
                  if (iVar13 != 0) goto LAB_08088425;
                  for (; pcVar12 = corners, plVar11 != (line_s *)0x0; plVar11 = plVar11->next) {
                    if (((plVar11->layer != -0x21524111) && (plVar11->line != (LineType *)0x0)) &&
                       ((*(byte *)&(plVar11->line->Flags).f & 0x40) != 0)) {
                      bVar6 = true;
                      goto LAB_0808848c;
                    }
                  }
                  bVar6 = false;
LAB_0808848c:
                  for (; pcVar12 != (corner_s *)0x0; pcVar12 = pcVar12->next) {
                    if (((pcVar12->layer != -0x21524111) &&
                        (pcVar12->miter = 0, pcVar12->n_lines == 2)) &&
                       ((pcVar12->via == (PinType *)0x0 && (pcVar12->pin == (PinType *)0x0)))) {
                      plVar11 = *pcVar12->lines;
                      pcVar21 = plVar11->s;
                      if (pcVar12 == pcVar21) {
                        iVar13 = pcVar12->x;
                        iVar14 = pcVar12->y;
                        local_c0 = plVar11->e->x;
                        y2_3 = plVar11->e->y;
                      }
                      else {
                        iVar13 = plVar11->e->x;
                        iVar14 = plVar11->e->y;
                        local_c0 = pcVar21->x;
                        y2_3 = pcVar21->y;
                      }
                      if (iVar13 == local_c0) {
                        bVar7 = true;
                        o1_1 = (uint)(iVar14 < y2_3) * 4 + 0x24;
                      }
                      else if (iVar14 == y2_3) {
                        bVar7 = true;
                        o1_1 = (iVar13 < local_c0) + 0x11;
                      }
                      else {
                        bVar7 = false;
                        o1_1 = 0xf0;
                      }
                      plVar5 = pcVar12->lines[1];
                      pcVar21 = plVar5->s;
                      if (pcVar12 == pcVar21) {
                        local_c8 = pcVar12->y;
                        local_cc = (corner_s *)pcVar12->x;
                        local_c4 = (PCBTypePtr)plVar5->e->x;
                        local_c0 = plVar5->e->y;
                      }
                      else {
                        local_cc = (corner_s *)plVar5->e->x;
                        local_c8 = plVar5->e->y;
                        local_c4 = (PCBTypePtr)pcVar21->x;
                        local_c0 = pcVar21->y;
                      }
                      if ((PCBTypePtr)local_cc == local_c4) {
                        uVar28 = (uint)(local_c8 < local_c0) * 4 + 0x24;
                      }
                      else {
                        uVar28 = 0xf0;
                        if (local_c8 == local_c0) {
                          uVar28 = ((int)local_cc < (int)local_c4) + 0x11;
                        }
                      }
                      if (((((o1_1 ^ uVar28) & 0xf0) != 0) && (bVar7)) &&
                         ((uVar28 != 0xf0 && (plVar11->line->Thickness == plVar5->line->Thickness)))
                         ) {
                        pcVar12->miter = -1;
                      }
                    }
                  }
                  local_e0 = 0;
                  do {
                    bVar7 = false;
                    bVar8 = true;
                    for (; pcVar10 != (corner_s *)0x0; pcVar10 = pcVar10->next) {
                      if ((pcVar10->layer != -0x21524111) && (pcVar10->miter == -1)) {
                        iVar13 = line_length(*pcVar10->lines);
                        iVar14 = line_length(pcVar10->lines[1]);
                        plVar11 = *pcVar10->lines;
                        pcVar12 = plVar11->s;
                        if (pcVar10 == pcVar12) {
                          iVar16 = pcVar10->x;
                          iVar17 = pcVar10->y;
                          local_c0 = plVar11->e->x;
                          iVar15 = plVar11->e->y;
                        }
                        else {
                          local_c0 = pcVar12->x;
                          iVar15 = pcVar12->y;
                          iVar16 = plVar11->e->x;
                          iVar17 = plVar11->e->y;
                        }
                        if (iVar16 == local_c0) {
                          uVar28 = (uint)(iVar17 < iVar15) * 4 + 0x24;
                        }
                        else {
                          uVar28 = 0xf0;
                          if (iVar17 == iVar15) {
                            uVar28 = (iVar16 < local_c0) + 0x11;
                          }
                        }
                        plVar5 = pcVar10->lines[1];
                        pcVar12 = plVar5->s;
                        if (pcVar10 == pcVar12) {
                          local_c4 = (PCBTypePtr)pcVar10->x;
                          local_c0 = plVar5->e->x;
                          iVar16 = plVar5->e->y;
                          iVar15 = pcVar10->y;
                        }
                        else {
                          local_c4 = (PCBTypePtr)plVar5->e->x;
                          iVar15 = plVar5->e->y;
                          local_c0 = pcVar12->x;
                          iVar16 = pcVar12->y;
                        }
                        if (local_c4 == (PCBTypePtr)local_c0) {
                          bVar9 = (iVar15 < iVar16) * '\x04' + 0x24;
                        }
                        else {
                          bVar9 = 0xf0;
                          if (iVar15 == iVar16) {
                            bVar9 = ((int)local_c4 < local_c0) + 0x11;
                          }
                        }
                        if (((pcVar10->pad == (PadType *)0x0) && (pcVar10->pin == (PinType *)0x0))
                           && (pcVar10->via == (PinType *)0x0)) {
                          pcVar12 = other_corner(plVar11,pcVar10);
                          pcVar21 = other_corner(pcVar10->lines[1],pcVar10);
                          if (bVar6) {
                            pLVar22 = (*pcVar10->lines)->line;
                            if (((*(byte *)&(pLVar22->Flags).f & 0x40) == 0) &&
                               ((*(byte *)&(pcVar10->lines[1]->line->Flags).f & 0x40) == 0))
                            goto LAB_0808878a;
                          }
                          else if (autorouted_only == 0) {
                            pLVar22 = (*pcVar10->lines)->line;
                          }
                          else {
                            pLVar22 = (*pcVar10->lines)->line;
                            if ((-1 < *(char *)&(pLVar22->Flags).f) &&
                               (-1 < *(char *)&(pcVar10->lines[1]->line->Flags).f))
                            goto LAB_0808878a;
                          }
                          uVar29 = uVar28 - 0x11;
                          if (uVar29 < 0x18) {
                            local_c4 = *(PCBTypePtr *)(CSWTCH_231 + uVar29 * 4);
                            local_d8 = *(corner_s **)(CSWTCH_232 + uVar29 * 4);
                          }
                          else {
                            local_d8 = (corner_s *)0x0;
                            local_c4 = (PCBTypePtr)0x0;
                          }
                          iVar15 = (int)local_d8;
                          if (bVar9 == 0x12) {
                            local_c4 = (PCBTypePtr)0x1;
                            iVar16 = (int)local_c4;
                          }
                          else {
                            iVar16 = (int)local_c4;
                            if (bVar9 < 0x13) {
                              iVar16 = -1;
                              if (bVar9 != 0x11) {
                                iVar16 = (int)local_c4;
                              }
                            }
                            else if (bVar9 == 0x24) {
                              local_d8 = (corner_s *)0xffffffff;
                              iVar15 = (int)local_d8;
                            }
                            else {
                              iVar15 = 1;
                              if (bVar9 != 0x28) {
                                iVar15 = (int)local_d8;
                              }
                            }
                          }
                          local_c4 = (PCBTypePtr)iVar16;
                          local_d8 = (corner_s *)iVar15;
                          local_c0 = iVar13;
                          if (iVar14 <= iVar13) {
                            local_c0 = iVar14;
                          }
                          iVar13 = pcVar10->y;
                          iVar14 = pLVar22->Thickness;
                          iVar15 = pcVar10->x;
                          iVar16 = PCB->Bloat;
                          local_d0 = (corner_s *)0x0;
                          for (c_00 = corners; c_00 != (corner_s *)0x0; c_00 = c_00->next) {
                            iVar17 = c_00->layer;
                            if (((((((iVar17 != -0x21524111) && (pcVar12 != c_00)) &&
                                   (pcVar10 != c_00)) &&
                                  ((pcVar21 != c_00 &&
                                   (iVar19 = (int)local_c4 * pcVar10->x,
                                   iVar18 = (int)local_c4 * c_00->x,
                                   iVar19 - iVar18 == 0 || iVar19 < iVar18)))) &&
                                 (iVar19 = pcVar10->y * (int)local_d8,
                                 iVar18 = c_00->y * (int)local_d8,
                                 iVar19 - iVar18 == 0 || iVar19 < iVar18)) &&
                                (pcVar10->net != c_00->net)) &&
                               (((iVar18 = pcVar10->layer, iVar17 == -1 || (iVar18 == -1)) ||
                                ((iVar17 == iVar18 ||
                                 (layer_groupings[iVar18] == layer_groupings[iVar17])))))) {
                              iVar18 = corner_radius(c_00);
                              iVar17 = (((c_00->y * (int)local_d8 + (int)local_c4 * c_00->x) -
                                        ((iVar16 + 2 + iVar14 / 2) * 3) / 2) +
                                       (-((int)local_c4 * iVar15) - (int)local_d8 * iVar13)) -
                                       iVar18;
                              if ((c_00->x != pcVar10->x) && (c_00->y != pcVar10->y)) {
                                iVar17 = iVar17 - iVar18;
                              }
                              if ((iVar17 < local_c0) ||
                                 ((iVar17 == local_c0 && (local_c0 = iVar17, pcVar10->miter != -1)))
                                 ) {
                                local_c0 = iVar17;
                                local_d0 = c_00;
                              }
                            }
                          }
                          if ((local_d0 == (corner_s *)0x0) || (local_d0->miter != -1)) {
                            if (local_c0 < 1) goto LAB_0808878a;
                            iVar13 = pcVar10->x;
                            iVar14 = pcVar10->y;
                            if (uVar28 == 0x12) {
                              iVar13 = iVar13 + local_c0;
                            }
                            else if (uVar28 < 0x13) {
                              if (uVar28 == 0x11) {
                                iVar13 = iVar13 - local_c0;
                              }
                            }
                            else if (uVar28 == 0x24) {
                              iVar14 = iVar14 - local_c0;
                            }
                            else if (uVar28 == 0x28) {
                              iVar14 = iVar14 + local_c0;
                            }
                            pcVar12 = find_corner(iVar13,iVar14,pcVar10->layer);
                            pcVar21 = other_corner(*pcVar10->lines,pcVar10);
                            if (pcVar12 != pcVar21) {
                              split_line(*pcVar10->lines,pcVar12);
                            }
                            iVar13 = pcVar10->x;
                            iVar14 = pcVar10->y;
                            if (bVar9 == 0x12) {
                              iVar13 = iVar13 + local_c0;
                            }
                            else if (bVar9 < 0x13) {
                              if (bVar9 == 0x11) {
                                iVar13 = iVar13 - local_c0;
                              }
                            }
                            else if (bVar9 == 0x24) {
                              iVar14 = iVar14 - local_c0;
                            }
                            else if (bVar9 == 0x28) {
                              iVar14 = iVar14 + local_c0;
                            }
                            move_corner(pcVar10,iVar13,iVar14);
                            pcVar10->miter = 0;
                            local_e0 = local_e0 + 1;
                            pcVar12->miter = 0;
                            bVar7 = true;
                          }
                          else {
                            bVar8 = false;
                          }
                        }
                        else {
LAB_0808878a:
                          pcVar10->miter = 0;
                          bVar7 = true;
                        }
                      }
                    }
                    plVar11 = lines;
                  } while ((bVar7) && (pcVar10 = corners, !bVar8));
                }
              }
            }
          }
        }
      }
    }
joined_r0x08087e63:
    plVar5 = plVar11;
    if (plVar5 != (line_s *)0x0) {
      plVar11 = plVar5->next;
      if ((plVar5->layer != -0x21524111) &&
         (((pPVar30 = plVar5->s->pad, pPVar30 == (PadType *)0x0 || (pPVar30 != plVar5->e->pad)) &&
          (paVar20 = PCB->Data, paVar20->ElementN != 0)))) {
        local_cc = (corner_s *)0x0;
        local_c4 = PCB;
        do {
          paVar2 = paVar20->Element;
          if (paVar2[(int)local_cc].PadN != 0) {
            uVar28 = 0;
LAB_08087ef1:
            do {
              paVar4 = paVar2[(int)local_cc].Pad;
              if ((int)layer_type[plVar5->layer] ==
                  2 - (uint)((paVar2[(int)local_cc].Flags.f & 0x80) == 0)) {
                r.y1 = 0x7fffffff;
                r.x1 = 0x7fffffff;
                r.y2 = -0x80000000;
                r.x2 = -0x80000000;
                iVar13 = paVar4[uVar28].Thickness / 2 + 1;
                add_point_to_rect(&r,paVar4[uVar28].Point1.X,paVar4[uVar28].Point1.Y,
                                  iVar13 - (local_c4->Bloat + 1) / 2);
                add_point_to_rect(&r,paVar4[uVar28].Point2.X,paVar4[uVar28].Point2.Y,
                                  iVar13 - (PCB->Bloat + 1) / 2);
                iVar13 = plVar5->s->y;
                iVar14 = plVar5->s->x;
                if (r.x1 <= iVar14) {
                  if (((iVar14 <= r.x2) && (r.y1 <= iVar13)) && (iVar13 <= r.y2)) {
                    iVar15 = plVar5->e->y;
                    iVar16 = plVar5->e->x;
                    if (r.x1 <= iVar16) {
                      if (((r.x2 < iVar16) || (iVar15 < r.y1)) || (r.y2 < iVar15))
                      goto LAB_08088170;
                      local_c4 = (PCBTypePtr)0x20;
                      if ((iVar14 != iVar16) && (local_c4 = (PCBTypePtr)0x10, iVar13 != iVar15)) {
                        local_c4 = (PCBTypePtr)0xf0;
                      }
                      iVar13 = 0x20;
                      if ((paVar4[uVar28].Point1.X != paVar4[uVar28].Point2.X) &&
                         (iVar13 = 0xf0, paVar4[uVar28].Point1.Y == paVar4[uVar28].Point2.Y)) {
                        iVar13 = 0x10;
                      }
                      if ((PCBTypePtr)iVar13 == local_c4) {
                        remove_line(plVar5);
                        goto joined_r0x08087e63;
                      }
                    }
                  }
                  local_c4 = PCB;
                  uVar28 = uVar28 + 1;
                  if (paVar2[(int)local_cc].PadN < uVar28 || paVar2[(int)local_cc].PadN == uVar28)
                  break;
                  goto LAB_08087ef1;
                }
LAB_08088170:
                local_c4 = PCB;
              }
              uVar28 = uVar28 + 1;
            } while (uVar28 <= paVar2[(int)local_cc].PadN && paVar2[(int)local_cc].PadN != uVar28);
          }
          local_cc = (corner_s *)((int)local_cc + 1);
          paVar20 = local_c4->Data;
        } while (local_cc <= paVar20->ElementN && (corner_s *)paVar20->ElementN != local_cc);
      }
      goto joined_r0x08087e63;
    }
  }
  else {
    local_e0 = 0;
    do {
      if (lines == (line_s *)0x0) break;
      iVar13 = 0;
      plVar11 = lines;
      do {
        if (plVar11->layer != -0x21524111) {
          iVar14 = canonicalize_line(plVar11);
          iVar13 = iVar13 + iVar14;
        }
        plVar11 = plVar11->next;
      } while (plVar11 != (line_s *)0x0);
      local_e0 = local_e0 + iVar13;
    } while (iVar13 != 0);
  }
  if (local_e0 != 0) {
    IncrementUndoSerialNumber();
  }
  return 0;
LAB_080877e2:
  paVar20 = PCB->Data;
  local_d4 = PCB;
  goto LAB_080877f4;
}



// WARNING: Unknown calling convention

void SetPVColor(PinTypePtr Pin,int Type)

{
  uint uVar1;
  char *color;
  
  if (Type == 1) {
    if ((doing_pinout != 0) || (uVar1 = (Pin->Flags).f, (uVar1 & 0x244) == 0)) {
      color = PCB->ViaColor;
      goto LAB_08088fdd;
    }
    if ((uVar1 & 0x200) != 0) goto LAB_08089060;
    if ((uVar1 & 0x40) != 0) {
      color = PCB->ViaSelectedColor;
      goto LAB_08088fdd;
    }
  }
  else {
    if ((doing_pinout != 0) || (uVar1 = (Pin->Flags).f, (uVar1 & 0x244) == 0)) {
      color = PCB->PinColor;
      goto LAB_08088fdd;
    }
    if ((uVar1 & 0x200) != 0) {
LAB_08089060:
      color = PCB->WarnColor;
      goto LAB_08088fdd;
    }
    if ((uVar1 & 0x40) != 0) {
      color = PCB->PinSelectedColor;
      goto LAB_08088fdd;
    }
  }
  color = PCB->ConnectedColor;
LAB_08088fdd:
  (*gui->set_color)(Output.fgGC,color);
  return;
}



// WARNING: Unknown calling convention

void UpdateAll(void)

{
                    // WARNING: Could not recover jumptable at 0x0808907f. Too many branches
                    // WARNING: Treating indirect jump as call
  (*gui->invalidate_all)();
  return;
}



// WARNING: Unknown calling convention

void RedrawOutput(BoxTypePtr area)

{
  (*gui->invalidate_all)();
  Gathering = '\x01';
  render = '\0';
  return;
}



// WARNING: Unknown calling convention

void ClearAndRedrawOutput(void)

{
  render = '\x01';
  Gathering = '\0';
                    // WARNING: Could not recover jumptable at 0x080890cd. Too many branches
                    // WARNING: Treating indirect jump as call
  (*gui->invalidate_all)();
  return;
}



// WARNING: Unknown calling convention

int hole_counting_callback(BoxType *b,void *cl)

{
  if ((*(byte *)&b[1].Y1 & 8) == 0) {
                    // WARNING: Load size is inaccurate
    *(int *)cl = *cl + 1;
    return 1;
  }
  *(int *)((int)cl + 4) = *(int *)((int)cl + 4) + 1;
  return 1;
}



// WARNING: Unknown calling convention

int EMark_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  bool bVar5;
  int local_20;
  
  iVar1 = b[0xd].Y2;
  iVar2 = b[0xd].X2;
  bVar5 = ((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide;
  if ((bVar5) && (PCB->InvisibleObjectsOn == '\0')) {
    return 1;
  }
  if ((b[0xe].X1 == 0) || (local_20 = *(int *)(b[0x10].X1 + 0x24), 1999 < local_20)) {
    local_20 = 1000;
  }
  else {
    local_20 = local_20 / 2;
  }
  iVar4 = local_20;
  if ((b[0xe].X2 != 0) && (iVar4 = *(int *)(b[0x10].Y1 + 0x24) / 2, local_20 <= iVar4)) {
    iVar4 = local_20;
  }
  local_20 = iVar4;
  if (bVar5) {
    pcVar3 = PCB->InvisibleMarkColor;
  }
  else {
    pcVar3 = PCB->ElementColor;
  }
  (*gui->set_color)(Output.fgGC,pcVar3);
  (*gui->set_line_cap)(Output.fgGC,Trace_Cap);
  (*gui->set_line_width)(Output.fgGC,0);
  (*gui->draw_line)(Output.fgGC,iVar2 - local_20,iVar1,iVar2,iVar1 - local_20);
  (*gui->draw_line)(Output.fgGC,local_20 + iVar2,iVar1,iVar2,iVar1 - local_20);
  (*gui->draw_line)(Output.fgGC,iVar2 - local_20,iVar1,iVar2,local_20 + iVar1);
  (*gui->draw_line)(Output.fgGC,local_20 + iVar2,iVar1,iVar2,local_20 + iVar1);
  if ((*(byte *)((int)&b[1].Y1 + 1) & 0x20) != 0) {
    (*gui->draw_line)(Output.fgGC,iVar2,iVar1,iVar2 + local_20 * 2,iVar1);
    (*gui->draw_line)(Output.fgGC,iVar2,iVar1,iVar2,iVar1 + local_20 * -4);
  }
  return 1;
}



// WARNING: Unknown calling convention

void DrawSpecialPolygon(HID *hid,hidGC DrawGC,LocationType X,LocationType Y,int Thickness)

{
  int iVar1;
  int i;
  int i_1;
  int iVar2;
  int iStack_68;
  int polygon_y [9];
  int polygon_x [9];
  
  if (Thickness != DrawSpecialPolygon::special_size) {
    DrawSpecialPolygon::special_size = Thickness;
    iVar1 = 0;
    do {
      *(int *)((int)DrawSpecialPolygon::scaled_x + iVar1) =
           (int)ROUND(*(double *)((int)&DrawSpecialPolygon::p[0].X + iVar1 * 4) * (double)Thickness)
      ;
      *(int *)((int)DrawSpecialPolygon::scaled_y + iVar1) =
           (int)ROUND(*(double *)((int)&DrawSpecialPolygon::p[0].Y + iVar1 * 4) * (double)Thickness)
      ;
      iVar1 = iVar1 + 4;
    } while (iVar1 != 0x20);
  }
  iVar1 = 0;
  do {
    polygon_x[iVar1] = DrawSpecialPolygon::scaled_x[iVar1] + X;
    polygon_y[iVar1] = DrawSpecialPolygon::scaled_y[iVar1] + Y;
    iVar1 = iVar1 + 1;
  } while (iVar1 != 8);
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
    (*hid->fill_polygon)(DrawGC,8,polygon_x,polygon_y);
    return;
  }
  (*hid->set_line_cap)(Output.fgGC,Round_Cap);
  (*hid->set_line_width)(Output.fgGC,0);
  polygon_y[8] = Y + DrawSpecialPolygon::scaled_y[0];
  polygon_x[8] = X + DrawSpecialPolygon::scaled_x[0];
  iVar1 = 0;
  do {
    iVar2 = iVar1 + 1;
    (*hid->draw_line)(DrawGC,polygon_y[iVar1 + 9],(&iStack_68)[iVar2],polygon_x[iVar2],
                      polygon_y[iVar2]);
    iVar1 = iVar2;
  } while (iVar2 != 8);
  return;
}



// WARNING: Unknown calling convention

void DrawPinOrViaLowLevel(PinTypePtr Ptr,Boolean drawHole)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int b;
  BDimension BVar5;
  int r;
  int l;
  int iVar6;
  
  if (Gathering != '\0') {
    iVar2 = (Ptr->BoundingBox).X1;
    if (Block.X1 <= iVar2) {
      iVar2 = Block.X1;
    }
    iVar3 = (Ptr->BoundingBox).X2;
    if (iVar3 <= Block.X2) {
      iVar3 = Block.X2;
    }
    iVar4 = (Ptr->BoundingBox).Y1;
    if (Block.Y1 <= iVar4) {
      iVar4 = Block.Y1;
    }
    iVar6 = (Ptr->BoundingBox).Y2;
    if (Block.Y2 < iVar6) {
      Block.X1 = iVar2;
      Block.Y1 = iVar4;
      Block.X2 = iVar3;
      Block.Y2 = iVar6;
      return;
    }
    Block.X1 = iVar2;
    Block.Y1 = iVar4;
    Block.X2 = iVar3;
    return;
  }
  uVar1 = (Ptr->Flags).f;
  if ((uVar1 & 8) == 0) {
    if ((uVar1 & 0x100) == 0) {
      if ((uVar1 & 0x800) == 0) {
        if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
          (*gui->fill_circle)(Output.fgGC,Ptr->X,Ptr->Y,Ptr->Thickness / 2);
        }
        else {
          (*gui->set_line_cap)(Output.fgGC,Round_Cap);
          (*gui->set_line_width)(Output.fgGC,0);
          iVar2 = Ptr->Thickness / 2;
          (*gui->draw_arc)(Output.fgGC,Ptr->X,Ptr->Y,iVar2,iVar2,0,0x168);
        }
      }
      else {
        (*gui->set_line_cap)(Output.fgGC,Round_Cap);
        (*gui->set_line_width)(Output.fgGC,(Ptr->Thickness - Ptr->DrillingHole) / 2);
        DrawSpecialPolygon(gui,Output.fgGC,Ptr->X,Ptr->Y,Ptr->Thickness);
      }
    }
    else {
      iVar3 = Ptr->Thickness;
      iVar6 = Ptr->X + -(iVar3 / 2);
      iVar4 = -(iVar3 / 2) + Ptr->Y;
      iVar2 = iVar6 + iVar3;
      iVar3 = iVar4 + iVar3;
      if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
        (*gui->fill_rect)(Output.fgGC,iVar6,iVar4,iVar2,iVar3);
      }
      else {
        (*gui->set_line_cap)(Output.fgGC,Round_Cap);
        (*gui->set_line_width)(Output.fgGC,0);
        (*gui->draw_line)(Output.fgGC,iVar2,iVar3,iVar2,iVar4);
        (*gui->draw_line)(Output.fgGC,iVar6,iVar3,iVar6,iVar4);
        (*gui->draw_line)(Output.fgGC,iVar2,iVar3,iVar6,iVar3);
        (*gui->draw_line)(Output.fgGC,iVar2,iVar4,iVar6,iVar4);
      }
    }
    if (drawHole == '\0') {
      return;
    }
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->fill_circle)(Output.bgGC,Ptr->X,Ptr->Y,Ptr->DrillingHole / 2);
      return;
    }
    (*gui->set_line_cap)(Output.fgGC,Round_Cap);
    (*gui->set_line_width)(Output.fgGC,0);
    BVar5 = Ptr->DrillingHole;
  }
  else {
    if (drawHole == '\0') {
      return;
    }
    (*gui->fill_circle)(Output.bgGC,Ptr->X,Ptr->Y,Ptr->Thickness / 2);
    (*gui->set_line_cap)(Output.fgGC,Round_Cap);
    (*gui->set_line_width)(Output.fgGC,0);
    BVar5 = Ptr->Thickness;
  }
  (*gui->draw_arc)(Output.fgGC,Ptr->X,Ptr->Y,BVar5 / 2,BVar5 / 2,0,0x168);
  return;
}



// WARNING: Unknown calling convention

int hole_callback(BoxType *b,void *cl)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  
  if (cl == (void *)0x0) {
LAB_08089905:
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) != 0) goto LAB_08089914;
LAB_080899e6:
    (*gui->fill_circle)(Output.bgGC,b[3].Y1,b[3].X2,b[3].X1 / 2);
  }
  else {
                    // WARNING: Load size is inaccurate
    if (*cl == 0) {
      if ((*(byte *)&b[1].Y1 & 8) == 0) {
        return 1;
      }
      goto LAB_08089905;
    }
    if (*cl != 1) goto LAB_08089905;
    if ((*(byte *)&b[1].Y1 & 8) != 0) {
      return 1;
    }
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) goto LAB_080899e6;
LAB_08089914:
    uVar1 = b[1].Y1;
    if ((uVar1 & 8) != 0) goto LAB_0808991f;
    (*gui->set_line_cap)(Output.fgGC,Round_Cap);
    (*gui->set_line_width)(Output.fgGC,0);
    iVar3 = b[3].X1 / 2;
    (*gui->draw_arc)(Output.fgGC,b[3].Y1,b[3].X2,iVar3,iVar3,0,0x168);
  }
  uVar1 = b[1].Y1;
  if ((uVar1 & 8) == 0) {
    return 1;
  }
LAB_0808991f:
  if ((uVar1 & 0x200) == 0) {
    pcVar2 = Settings.BlackColor;
    if ((uVar1 & 0x40) != 0) {
      pcVar2 = PCB->ViaSelectedColor;
    }
  }
  else {
    pcVar2 = PCB->WarnColor;
  }
  (*gui->set_color)(Output.fgGC,pcVar2);
  (*gui->set_line_cap)(Output.fgGC,Round_Cap);
  (*gui->set_line_width)(Output.fgGC,0);
  iVar3 = b[3].X1 / 2;
  (*gui->draw_arc)(Output.fgGC,b[3].Y1,b[3].X2,iVar3,iVar3,0,0x168);
  return 1;
}



// WARNING: Unknown calling convention

void ClearPin(PinTypePtr Pin,int Type,int unused)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  int l;
  int iVar4;
  int b;
  int iVar5;
  int iVar6;
  
  if (Gathering == '\0') {
    uVar2 = (Pin->Flags).f;
    iVar6 = (Pin->Clearance + Pin->Thickness) / 2;
    if ((uVar2 & 0x100) == 0) {
      if ((uVar2 & 0x800) == 0) {
        (*gui->fill_circle)(Output.pmGC,Pin->X,Pin->Y,iVar6);
      }
      else {
        (*gui->set_line_cap)(Output.pmGC,Round_Cap);
        (*gui->set_line_width)
                  (Output.pmGC,((Pin->Thickness + Pin->Clearance) - Pin->DrillingHole) / 2);
        DrawSpecialPolygon(gui,Output.pmGC,Pin->X,Pin->Y,iVar6 * 2);
      }
    }
    else {
      iVar4 = Pin->X - iVar6;
      iVar5 = Pin->Y - iVar6;
      (*gui->fill_rect)(Output.pmGC,iVar4,iVar5,iVar6 * 2 + iVar4,iVar6 * 2 + iVar5);
    }
    if ((*(byte *)&(Pin->Flags).f & 1) == 0) {
      cVar1 = PCB->ViaOn;
    }
    else {
      cVar1 = PCB->PinOn;
    }
    iVar3 = Block.Y2;
    if ((cVar1 != '\0') && ((Type == 1 || (Type == 0x100)))) {
      SetPVColor(Pin,Type);
      DrawPinOrViaLowLevel(Pin,'\x01');
      return;
    }
  }
  else {
    iVar6 = (Pin->BoundingBox).X1;
    if (Block.X1 <= iVar6) {
      iVar6 = Block.X1;
    }
    iVar4 = (Pin->BoundingBox).X2;
    if (iVar4 <= Block.X2) {
      iVar4 = Block.X2;
    }
    iVar5 = (Pin->BoundingBox).Y1;
    if (Block.Y1 <= iVar5) {
      iVar5 = Block.Y1;
    }
    iVar3 = (Pin->BoundingBox).Y2;
    Block.X1 = iVar6;
    Block.Y1 = iVar5;
    Block.X2 = iVar4;
    if (iVar3 <= Block.Y2) {
      iVar3 = Block.Y2;
    }
  }
  Block.Y2 = iVar3;
  return;
}



// WARNING: Unknown calling convention

void DrawLineLowLevel(LineTypePtr Line,Boolean HaveGathered)

{
  int iVar1;
  
  if ((HaveGathered == '\0') && (Gathering != '\0')) {
    iVar1 = (Line->BoundingBox).X1;
    if (Block.X1 <= iVar1) {
      iVar1 = Block.X1;
    }
    Block.X1 = iVar1;
    iVar1 = (Line->BoundingBox).X2;
    if (iVar1 <= Block.X2) {
      iVar1 = Block.X2;
    }
    Block.X2 = iVar1;
    iVar1 = (Line->BoundingBox).Y1;
    if (Block.Y1 <= iVar1) {
      iVar1 = Block.Y1;
    }
    Block.Y1 = iVar1;
    iVar1 = (Line->BoundingBox).Y2;
    if (iVar1 <= Block.Y2) {
      iVar1 = Block.Y2;
    }
    Block.Y2 = iVar1;
    return;
  }
  (*gui->set_line_cap)(Output.fgGC,Trace_Cap);
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
    (*gui->set_line_width)(Output.fgGC,Line->Thickness);
  }
  else {
    (*gui->set_line_width)(Output.fgGC,0);
  }
  (*gui->draw_line)(Output.fgGC,(Line->Point1).X,(Line->Point1).Y,(Line->Point2).X,(Line->Point2).Y)
  ;
  return;
}



// WARNING: Unknown calling convention

void DrawArcLowLevel(ArcTypePtr Arc)

{
  int iVar1;
  
  if (Arc->Thickness != 0) {
    if (Gathering != '\0') {
      iVar1 = (Arc->BoundingBox).X1;
      if (Block.X1 <= iVar1) {
        iVar1 = Block.X1;
      }
      Block.X1 = iVar1;
      iVar1 = (Arc->BoundingBox).X2;
      if (iVar1 <= Block.X2) {
        iVar1 = Block.X2;
      }
      Block.X2 = iVar1;
      iVar1 = (Arc->BoundingBox).Y1;
      if (Block.Y1 <= iVar1) {
        iVar1 = Block.Y1;
      }
      Block.Y1 = iVar1;
      iVar1 = (Arc->BoundingBox).Y2;
      if (iVar1 <= Block.Y2) {
        iVar1 = Block.Y2;
      }
      Block.Y2 = iVar1;
      return;
    }
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->set_line_width)(Output.fgGC,Arc->Thickness);
    }
    else {
      (*gui->set_line_width)(Output.fgGC,0);
    }
    (*gui->set_line_cap)(Output.fgGC,Trace_Cap);
    (*gui->draw_arc)(Output.fgGC,Arc->X,Arc->Y,Arc->Width,Arc->Height,Arc->StartAngle,Arc->Delta);
  }
  return;
}



// WARNING: Unknown calling convention

void DrawLine(LayerTypePtr Layer,LineTypePtr Line,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Gathering == '\0') {
    uVar1 = (Line->Flags).f;
    if ((uVar1 & 0x44) == 0) {
      pcVar2 = Layer->Color;
    }
    else if ((uVar1 & 0x40) == 0) {
      pcVar2 = PCB->ConnectedColor;
    }
    else {
      pcVar2 = Layer->SelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar2);
  }
  DrawLineLowLevel(Line,'\0');
  return;
}



// WARNING: Unknown calling convention

int line_callback(BoxType *b,void *cl)

{
  DrawLine((LayerTypePtr)cl,(LineTypePtr)b,0);
  return 1;
}



// WARNING: Unknown calling convention

void DrawRat(RatTypePtr Line,int unused)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  int iVar7;
  int w;
  
  if (Gathering == '\0') {
    uVar2 = (Line->Flags).f;
    if ((uVar2 & 0x44) == 0) {
      pcVar6 = PCB->RatColor;
    }
    else if ((uVar2 & 0x40) == 0) {
      pcVar6 = PCB->ConnectedColor;
    }
    else {
      pcVar6 = PCB->RatSelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar6);
  }
  if (Settings.RatThickness < 0x14) {
    Line->Thickness = Settings.RatThickness * pixel_slop;
  }
  if ((*(byte *)&(Line->Flags).f & 2) == 0) {
    DrawLineLowLevel((LineTypePtr)Line,'\0');
    return;
  }
  iVar3 = Line->Thickness;
  if (Gathering == '\0') {
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->set_line_width)(Output.fgGC,iVar3);
    }
    else {
      (*gui->set_line_width)(Output.fgGC,0);
    }
    (*gui->draw_arc)(Output.fgGC,(Line->Point1).X,(Line->Point1).Y,iVar3 * 2,iVar3 * 2,0,0x168);
  }
  else {
    iVar4 = (Line->Point1).X;
    iVar5 = (Line->Point1).Y;
    iVar7 = iVar3 * -2 - iVar3 / 2;
    iVar1 = iVar3 / 2 + iVar3 * 2;
    iVar3 = iVar7 + iVar4;
    if (iVar3 <= Block.X1) {
      Block.X1 = iVar3;
    }
    iVar4 = iVar1 + iVar4;
    if (Block.X2 <= iVar4) {
      Block.X2 = iVar4;
    }
    iVar7 = iVar7 + iVar5;
    iVar1 = iVar1 + iVar5;
    if (Block.Y1 < iVar7) {
      iVar7 = Block.Y1;
    }
    Block.Y1 = iVar7;
    if (Block.Y2 <= iVar1) {
      Block.Y2 = iVar1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

int rat_callback(BoxType *b,void *cl)

{
  DrawRat((RatTypePtr)b,0);
  return 1;
}



// WARNING: Unknown calling convention

void DrawArc(LayerTypePtr Layer,ArcTypePtr Arc,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Arc->Thickness != 0) {
    if (Gathering == '\0') {
      uVar1 = (Arc->Flags).f;
      if ((uVar1 & 0x44) == 0) {
        pcVar2 = Layer->Color;
      }
      else if ((uVar1 & 0x40) == 0) {
        pcVar2 = PCB->ConnectedColor;
      }
      else {
        pcVar2 = Layer->SelectedColor;
      }
      (*gui->set_color)(Output.fgGC,pcVar2);
    }
    DrawArcLowLevel(Arc);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int arc_callback(BoxType *b,void *cl)

{
  DrawArc((LayerTypePtr)cl,(ArcTypePtr)b,0);
  return 1;
}



// WARNING: Unknown calling convention

int cp_callback(BoxType *b,void *cl)

{
  ClearPin((PinTypePtr)b,(int)cl,0);
  return 1;
}



// WARNING: Unknown calling convention

int poly_callback(BoxType *b,void *cl)

{
  int iVar1;
  uint uVar2;
  LocationType LVar3;
  _func_void_hidGC_PolygonType_ptr_BoxType_ptr *p_Var4;
  int iVar5;
  int iVar6;
  int iVar7;
  int in_GS_OFFSET;
  PolygonType poly;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  LVar3 = Block.Y2;
  if (b[2].Y2 != 0) {
    if (Gathering == '\0') {
      if ((b[1].Y1 & 0x40U) == 0) {
        if ((b[1].Y1 & 4U) == 0) {
          DrawPlainPolygon::color = *(char **)(*(int *)((int)cl + 4) + 0x48);
        }
        else {
          DrawPlainPolygon::color = PCB->ConnectedColor;
        }
      }
      else {
        DrawPlainPolygon::color = *(char **)(*(int *)((int)cl + 4) + 0x4c);
      }
      (*gui->set_color)(Output.fgGC,DrawPlainPolygon::color);
      if ((gui->thindraw_pcb_polygon == (_func_void_hidGC_PolygonType_ptr_BoxType_ptr *)0x0) ||
         (((PCB->Flags).f & 0x24000) == 0)) {
        (*gui->fill_pcb_polygon)(Output.fgGC,(PolygonType *)b,clip_box);
      }
      else {
        (*gui->thindraw_pcb_polygon)(Output.fgGC,(PolygonType *)b,clip_box);
      }
      p_Var4 = gui->thindraw_pcb_polygon;
      LVar3 = Block.Y2;
      if (((p_Var4 != (_func_void_hidGC_PolygonType_ptr_BoxType_ptr *)0x0) &&
          ((*(byte *)&(PCB->Flags).f & 4) != 0)) && (uVar2 = b[1].Y1, (uVar2 & 0x20) == 0)) {
        poly.BoundingBox.X1 = b->X1;
        poly.BoundingBox.Y1 = b->Y1;
        poly.BoundingBox.X2 = b->X2;
        poly.BoundingBox.Y2 = b->Y2;
        poly.ID = b[1].X1;
        poly.Flags.t._0_4_ = b[1].X2;
        poly.Flags.t._4_4_ = b[1].Y2;
        poly.net = (LibraryEntryType *)b[2].X1;
        poly.PointN = b[2].Y1;
        poly.PointMax = b[2].X2;
        poly.NoHoles = (PLINE *)b[3].X1;
        poly.NoHolesValid = b[3].Y1;
        poly.Points = (PointTypePtr)b[3].X2;
        poly.Clipped = *(POLYAREA **)b[2].Y2;
        poly.Flags.f = uVar2;
        if (poly.Clipped != (POLYAREA *)b[2].Y2) {
          while( true ) {
            (*p_Var4)(Output.fgGC,&poly,clip_box);
            poly.Clipped = (poly.Clipped)->f;
            LVar3 = Block.Y2;
            if (poly.Clipped == (POLYAREA *)b[2].Y2) break;
            p_Var4 = gui->thindraw_pcb_polygon;
          }
        }
      }
    }
    else {
      iVar5 = b->X1;
      if (Block.X1 <= b->X1) {
        iVar5 = Block.X1;
      }
      iVar6 = b->X2;
      if (b->X2 <= Block.X2) {
        iVar6 = Block.X2;
      }
      iVar7 = b->Y1;
      if (Block.Y1 <= b->Y1) {
        iVar7 = Block.Y1;
      }
      Block.X1 = iVar5;
      Block.Y1 = iVar7;
      Block.X2 = iVar6;
      LVar3 = b->Y2;
      if (b->Y2 <= Block.Y2) {
        LVar3 = Block.Y2;
      }
    }
  }
  Block.Y2 = LVar3;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 1;
}



// WARNING: Unknown calling convention

void DrawElementPackage(ElementTypePtr Element,int unused)

{
  uint uVar1;
  char *pcVar2;
  Cardinal n;
  int iVar3;
  Cardinal n_1;
  int iVar4;
  
  if ((doing_pinout == 0) && (doing_assy == 0)) {
    uVar1 = (Element->Flags).f;
    if ((uVar1 & 0x40) != 0) {
      pcVar2 = PCB->ElementSelectedColor;
      goto LAB_0808a43b;
    }
    if ((uVar1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
      pcVar2 = PCB->InvisibleObjectsColor;
      goto LAB_0808a43b;
    }
  }
  pcVar2 = PCB->ElementColor;
LAB_0808a43b:
  (*gui->set_color)(Output.fgGC,pcVar2);
  iVar3 = Element->LineN - 1;
  if (iVar3 != -1) {
    iVar4 = Element->LineN * 0x58;
    do {
      iVar3 = iVar3 + -1;
      DrawLineLowLevel((LineTypePtr)(Element->Line[-1].Flags.t + iVar4 + -0x18),'\0');
      iVar4 = iVar4 + -0x58;
    } while (iVar3 != -1);
  }
  iVar3 = Element->ArcN - 1;
  if (iVar3 != -1) {
    iVar4 = Element->ArcN * 0x44;
    do {
      iVar3 = iVar3 + -1;
      DrawArcLowLevel((ArcTypePtr)(Element->Arc[-1].Flags.t + iVar4 + -0x18));
      iVar4 = iVar4 + -0x44;
    } while (iVar3 != -1);
  }
  return;
}



// WARNING: Unknown calling convention

int frontE_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    return 1;
  }
  DrawElementPackage((ElementTypePtr)b,0);
  return 1;
}



// WARNING: Unknown calling convention

int backE_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    DrawElementPackage((ElementTypePtr)b,0);
  }
  return 1;
}



// WARNING: Unknown calling convention

void EraseRat(RatTypePtr Rat)

{
  int iVar1;
  int w;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  if ((*(byte *)&(Rat->Flags).f & 2) != 0) {
    iVar1 = Rat->Thickness;
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->set_line_width)(Output.fgGC,iVar1);
    }
    else {
      (*gui->set_line_width)(Output.fgGC,0);
    }
    iVar1 = iVar1 * 2;
    (*gui->draw_arc)(Output.fgGC,(Rat->Point1).X,(Rat->Point1).Y,iVar1,iVar1,0,0x168);
    Erasing = Erasing + -1;
    return;
  }
  DrawLineLowLevel((LineTypePtr)Rat,'\0');
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void EraseLine(LineTypePtr Line)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawLineLowLevel(Line,'\0');
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void EraseArc(ArcTypePtr Arc)

{
  if (Arc->Thickness != 0) {
    Erasing = Erasing + 1;
    (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
    DrawArcLowLevel(Arc);
    Erasing = Erasing + -1;
  }
  return;
}



// WARNING: Unknown calling convention

void DrawMask(BoxType *screen)

{
  pin_info info;
  
  info.arg = '\x01';
  if (((PCB->Flags).f & 0x24000) == 0) {
    if ((gui->field_0xc & 8) != 0) {
      (*gui->use_mask)(1);
      (*gui->set_color)(Output.fgGC,PCB->MaskColor);
      (*gui->fill_rect)(Output.fgGC,0,0,PCB->MaxWidth,PCB->MaxHeight);
    }
    (*gui->use_mask)(2);
    r_search(PCB->Data->pin_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,
             &info);
    r_search(PCB->Data->via_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,
             &info);
    r_search(PCB->Data->pad_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,clearPad_callback,
             &info);
    if ((gui->field_0xc & 0x10) != 0) {
      (*gui->use_mask)(3);
      (*gui->set_color)(Output.fgGC,PCB->MaskColor);
      (*gui->fill_rect)(Output.fgGC,0,0,PCB->MaxWidth,PCB->MaxHeight);
    }
    (*gui->use_mask)(0);
    return;
  }
  (*gui->set_color)(Output.pmGC,PCB->MaskColor);
  r_search(PCB->Data->pin_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,&info)
  ;
  r_search(PCB->Data->via_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,&info)
  ;
  r_search(PCB->Data->pad_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,clearPad_callback,&info)
  ;
  (*gui->set_color)(Output.pmGC,"erase");
  return;
}



// WARNING: Unknown calling convention

void DrawTop(BoxType *screen)

{
  if ((PCB->PinOn != '\0') || (doing_assy != 0)) {
    r_search(PCB->Data->pin_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,pin_callback,
             (void *)0x0);
    r_search(PCB->Data->pad_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,pad_callback,
             (void *)0x0);
  }
  if ((PCB->ViaOn != '\0') || (doing_assy != 0)) {
    r_search(PCB->Data->via_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,via_callback,
             (void *)0x0);
    r_search(PCB->Data->via_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
             (void *)0x0);
  }
  if ((PCB->PinOn != '\0') || (doing_assy != 0)) {
    r_search(PCB->Data->pin_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
             (void *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void DrawLayer(LayerTypePtr Layer,BoxType *screen)

{
  pin_info info;
  
  info.arg = '\0';
  info.Layer = Layer;
  clip_box = screen;
  r_search(Layer->polygon_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,poly_callback,&info);
  r_search(Layer->line_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,line_callback,Layer);
  r_search(Layer->arc_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,arc_callback,Layer);
  r_search(Layer->text_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,text_callback,Layer);
  clip_box = (BoxType *)0x0;
  return;
}



// WARNING: Unknown calling convention

void DrawSilk(int new_swap,int layer,BoxTypePtr drawn_area)

{
  uint uVar1;
  Boolean BVar2;
  uint uVar3;
  
  BVar2 = Settings.ShowSolderSide;
  Settings.ShowSolderSide = (Boolean)new_swap;
  DrawLayer(PCB->Data->Layer + layer + PCB->Data->LayerN,drawn_area);
  r_search(PCB->Data->element_tree,drawn_area,(_func_int_BoxType_ptr_void_ptr *)0x0,frontE_callback,
           (void *)0x0);
  uVar1 = (PCB->Flags).f;
  uVar3 = 1;
  if ((uVar1 & 0x40) == 0) {
    uVar3 = -(uint)((uVar1 & 0x20) == 0) & 2;
  }
  r_search(PCB->Data->name_tree[uVar3],drawn_area,(_func_int_BoxType_ptr_void_ptr *)0x0,
           frontN_callback,(void *)0x0);
  Settings.ShowSolderSide = BVar2;
  return;
}



// WARNING: Unknown calling convention

int DrawLayerGroup(int group,BoxType *screen)

{
  LayerTypePtr cl;
  Cardinal CVar1;
  Cardinal CVar2;
  DataTypePtr paVar3;
  Cardinal *layers;
  int iVar4;
  LayerTypePtr Layer;
  char *pcVar5;
  char *pcVar6;
  char *pcVar7;
  bool bVar8;
  byte bVar9;
  int local_3c;
  PCBTypePtr local_38;
  Cardinal *local_34;
  int local_30;
  pin_info info;
  
  bVar9 = 0;
  local_3c = 1;
  CVar1 = (PCB->LayerGroups).Number[group];
  local_38 = PCB;
  local_30 = CVar1 - 1;
  clip_box = screen;
  if (local_30 < 0) {
LAB_0808ad46:
    iVar4 = 1;
    if ((int)CVar1 < 2) {
      iVar4 = local_3c;
    }
    return iVar4;
  }
  local_34 = (PCB->LayerGroups).Number + group * 0x12 + CVar1 + 0xf;
  do {
    bVar8 = local_30 == 0;
    CVar2 = *local_34;
    iVar4 = 8;
    paVar3 = local_38->Data;
    pcVar6 = paVar3->Layer[CVar2].Name;
    pcVar5 = pcVar6;
    pcVar7 = "outline";
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      bVar8 = *pcVar5 == *pcVar7;
      pcVar5 = pcVar5 + (uint)bVar9 * -2 + 1;
      pcVar7 = pcVar7 + (uint)bVar9 * -2 + 1;
    } while (bVar8);
    if (bVar8) {
LAB_0808ad01:
      local_3c = 0;
    }
    else {
      iVar4 = 6;
      pcVar5 = "route";
      do {
        if (iVar4 == 0) break;
        iVar4 = iVar4 + -1;
        bVar8 = *pcVar6 == *pcVar5;
        pcVar6 = pcVar6 + (uint)bVar9 * -2 + 1;
        pcVar5 = pcVar5 + (uint)bVar9 * -2 + 1;
      } while (bVar8);
      if (bVar8) goto LAB_0808ad01;
    }
    PCB = local_38;
    if ((int)CVar2 < paVar3->LayerN) {
      if (paVar3->Layer[CVar2].On != '\0') {
        cl = paVar3->Layer + CVar2;
        if (paVar3->Layer[CVar2].PolygonN != 0) {
          info.arg = '\x01';
          info.Layer = cl;
          r_search(paVar3->Layer[CVar2].polygon_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   poly_callback,&info);
          local_38 = PCB;
          info.arg = '\0';
        }
        PCB = local_38;
        if ((*(byte *)&(local_38->Flags).f & 4) == 0) {
          r_search(paVar3->Layer[CVar2].line_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   line_callback,cl);
          r_search(paVar3->Layer[CVar2].arc_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   arc_callback,cl);
          r_search(paVar3->Layer[CVar2].text_tree,screen,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   text_callback,cl);
        }
      }
    }
    local_34 = local_34 + -1;
    local_30 = local_30 + -1;
    if (local_30 < 0) goto LAB_0808ad46;
    local_38 = PCB;
  } while( true );
}



// WARNING: Unknown calling convention

void PrintAssembly(BoxType *drawn_area,int side_group,int swap_ident)

{
  Boolean BVar1;
  
  BVar1 = Settings.ShowSolderSide;
  (*gui->set_draw_faded)(Output.fgGC,1);
  Settings.ShowSolderSide = (Boolean)swap_ident;
  DrawLayerGroup(side_group,drawn_area);
  r_search(PCB->Data->via_tree,drawn_area,(_func_int_BoxType_ptr_void_ptr *)0x0,lowvia_callback,
           (void *)0x0);
  DrawTop(drawn_area);
  (*gui->set_draw_faded)(Output.fgGC,0);
  DrawSilk(swap_ident,(uint)(swap_ident == 0),drawn_area);
  Settings.ShowSolderSide = BVar1;
  return;
}



// WARNING: Unknown calling convention

void DrawPadLowLevel(hidGC gc,PadTypePtr Pad,Boolean clear,Boolean mask)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  int w;
  int iVar9;
  int y1;
  int iVar10;
  int y2;
  int iVar11;
  int b;
  LocationType dy;
  int iVar12;
  int x1;
  int l;
  LocationType ox;
  int iVar13;
  int iVar14;
  float ty;
  float tx;
  float h;
  double dVar15;
  int local_40;
  int local_3c;
  double local_2c;
  double local_24 [2];
  
  if (clear == '\0') {
    iVar9 = Pad->Thickness;
  }
  else if (mask == '\0') {
    iVar9 = Pad->Clearance + Pad->Thickness;
  }
  else {
    iVar9 = Pad->Mask;
  }
  if (Gathering == '\0') {
    uVar4 = (PCB->Flags).f;
    if (((uVar4 & 0x4000) == 0) && ((clear == '\0' || ((uVar4 & 0x20000) == 0)))) {
      iVar12 = (Pad->Point1).X;
      if ((iVar12 == (Pad->Point2).X) && (iVar11 = (Pad->Point1).Y, iVar11 == (Pad->Point2).Y)) {
        if ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0) {
          (*gui->fill_circle)(gc,iVar12,iVar11,iVar9 / 2);
        }
        else {
          iVar12 = iVar12 + -(iVar9 / 2);
          iVar11 = iVar11 + -(iVar9 / 2);
          (*gui->fill_rect)(gc,iVar12,iVar11,iVar12 + iVar9,iVar11 + iVar9);
        }
      }
      else {
        (*gui->set_line_cap)(gc,~-(uint)(((Pad->Flags).f & 0x100) == 0) + Round_Cap);
        (*gui->set_line_width)(gc,iVar9);
        (*gui->draw_line)(gc,(Pad->Point1).X,(Pad->Point1).Y,(Pad->Point2).X,(Pad->Point2).Y);
      }
    }
    else {
      local_3c = (Pad->Point2).X;
      iVar12 = (Pad->Point1).X;
      iVar14 = iVar9 / 2;
      iVar9 = iVar9 - iVar14;
      iVar11 = (Pad->Point1).Y;
      local_40 = (Pad->Point2).Y;
      if ((local_40 < iVar11) || (iVar10 = iVar11, iVar13 = iVar12, local_3c < iVar12)) {
        iVar10 = local_40;
        iVar13 = local_3c;
        local_40 = iVar11;
        local_3c = iVar12;
      }
      (*gui->set_line_cap)(gc,Round_Cap);
      (*gui->set_line_width)(gc,0);
      if ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0) {
        if (iVar10 == local_40) {
          if (iVar13 != local_3c) {
            (*gui->draw_line)(gc,iVar13,iVar10 - iVar14,local_3c,iVar10 - iVar14);
            (*gui->draw_line)(gc,iVar13,iVar10 + iVar9,local_3c,iVar10 + iVar9);
            (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,0x5a,-0xb4);
            (*gui->draw_arc)(gc,local_3c,iVar10,iVar14,iVar14,0x10e,-0xb4);
            return;
          }
          (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,0,0x168);
        }
        else if (iVar13 == local_3c) {
          (*gui->draw_line)(gc,iVar13 - iVar14,iVar10,iVar13 - iVar14,local_40);
          (*gui->draw_line)(gc,iVar13 + iVar9,iVar10,iVar13 + iVar9,local_40);
          (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,0,-0xb4);
          (*gui->draw_arc)(gc,iVar13,local_40,iVar14,iVar14,0xb4,-0xb4);
        }
        else {
          iVar9 = local_3c - iVar13;
          fVar6 = (float)iVar9;
          iVar12 = local_40 - iVar10;
          fVar7 = (float)iVar12;
          fVar5 = (float)iVar14 / SQRT(fVar7 * fVar7 + fVar6 * fVar6);
          if (iVar12 < 1) {
            if (iVar12 == 0) {
              fVar8 = 0.0;
            }
            else {
              fVar8 = -0.5;
            }
          }
          else {
            fVar8 = 0.5;
          }
          uVar4 = (uint)ROUND(fVar7 * fVar5 + fVar8);
          if (iVar9 < 1) {
            if (iVar9 == 0) {
              fVar7 = 0.0;
            }
            else {
              fVar7 = -0.5;
            }
          }
          else {
            fVar7 = 0.5;
          }
          uVar3 = (uint)ROUND(-(fVar5 * fVar6 + fVar7));
          (*gui->draw_line)(gc,uVar4 + iVar13,uVar3 + iVar10,uVar4 + local_3c,uVar3 + local_40);
          if ((pixel_slop <= (int)(((int)uVar4 >> 0x1f ^ uVar4) - ((int)uVar4 >> 0x1f))) ||
             (pixel_slop <= (int)(((int)uVar3 >> 0x1f ^ uVar3) - ((int)uVar3 >> 0x1f)))) {
            dVar15 = atan2((double)iVar9,(double)iVar12);
            (*gui->draw_line)(gc,iVar13 - uVar4,iVar10 - uVar3,local_3c - uVar4,local_40 - uVar3);
            (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,(int)ROUND(dVar15 * 57.295779) + -0xb4,
                             0xb4);
            (*gui->draw_arc)(gc,local_3c,local_40,iVar14,iVar14,(int)ROUND(dVar15 * 57.295779),0xb4)
            ;
          }
        }
      }
      else if ((iVar10 == local_40) || (iVar13 == local_3c)) {
        iVar10 = iVar10 - iVar14;
        iVar13 = iVar13 - iVar14;
        local_3c = local_3c + iVar9;
        y2 = local_40 + iVar9;
        (*gui->draw_line)(gc,iVar13,iVar10,iVar13,y2);
        (*gui->draw_line)(gc,iVar13,y2,local_3c,y2);
        (*gui->draw_line)(gc,local_3c,y2,local_3c,iVar10);
        (*gui->draw_line)(gc,local_3c,iVar10,iVar13,iVar10);
      }
      else {
        dVar15 = atan2((double)(local_40 - iVar10),(double)(local_3c - iVar13));
        sincos((double)((float)dVar15 + 0.7853982),local_24,&local_2c);
        fVar5 = (float)local_2c * (float)iVar14 * 1.414214;
        fVar6 = (float)local_24[0] * (float)iVar14 * 1.414214;
        iVar9 = (int)ROUND((float)local_40 - fVar5);
        iVar12 = (int)ROUND((float)local_3c + fVar6);
        iVar11 = (int)ROUND((float)iVar10 - fVar6);
        iVar14 = (int)ROUND((float)iVar13 - fVar5);
        (*gui->draw_line)(gc,iVar14,iVar11,iVar12,iVar9);
        iVar1 = (int)ROUND((float)local_40 + fVar6);
        iVar2 = (int)ROUND((float)local_3c + fVar5);
        (*gui->draw_line)(gc,iVar12,iVar9,iVar2,iVar1);
        iVar9 = (int)ROUND((float)iVar10 + fVar5);
        iVar12 = (int)ROUND((float)iVar13 - fVar6);
        (*gui->draw_line)(gc,iVar2,iVar1,iVar12,iVar9);
        (*gui->draw_line)(gc,iVar12,iVar9,iVar14,iVar11);
      }
    }
    return;
  }
  iVar9 = (Pad->BoundingBox).X1;
  if (Block.X1 <= iVar9) {
    iVar9 = Block.X1;
  }
  Block.X1 = iVar9;
  iVar9 = (Pad->BoundingBox).X2;
  if (iVar9 <= Block.X2) {
    iVar9 = Block.X2;
  }
  Block.X2 = iVar9;
  iVar9 = (Pad->BoundingBox).Y1;
  if (Block.Y1 <= iVar9) {
    iVar9 = Block.Y1;
  }
  Block.Y1 = iVar9;
  iVar9 = (Pad->BoundingBox).Y2;
  if (iVar9 <= Block.Y2) {
    iVar9 = Block.Y2;
  }
  Block.Y2 = iVar9;
  return;
}



// WARNING: Unknown calling convention

int clearPad_callback(BoxType *b,void *cl)

{
  if (*(char *)&b[1].Y1 < '\0') {
    if (Settings.ShowSolderSide == '\0') {
      return 1;
    }
  }
  else if (Settings.ShowSolderSide != '\0') {
    return 1;
  }
  DrawPadLowLevel(Output.pmGC,(PadTypePtr)b,'\x01','\x01');
  return 1;
}



// WARNING: Unknown calling convention

void ErasePolygon(PolygonTypePtr Polygon)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  iVar1 = Block.Y2;
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    if (Gathering == '\0') {
      __printf_chk(1,"DrawPolygonLowLevel: Called without Gathering set!\n");
      Erasing = Erasing + -1;
      return;
    }
    iVar2 = (Polygon->BoundingBox).X1;
    if (Block.X1 <= iVar2) {
      iVar2 = Block.X1;
    }
    iVar3 = (Polygon->BoundingBox).X2;
    if (iVar3 <= Block.X2) {
      iVar3 = Block.X2;
    }
    iVar4 = (Polygon->BoundingBox).Y1;
    if (Block.Y1 <= iVar4) {
      iVar4 = Block.Y1;
    }
    iVar1 = (Polygon->BoundingBox).Y2;
    Block.X1 = iVar2;
    Block.Y1 = iVar4;
    Block.X2 = iVar3;
    if (iVar1 <= Block.Y2) {
      iVar1 = Block.Y2;
    }
  }
  Block.Y2 = iVar1;
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

int thin_callback(PLINE *pl,LayerTypePtr lay,PolygonTypePtr poly)

{
  int *piVar1;
  int *__ptr;
  int *__ptr_00;
  int i;
  uint uVar2;
  uint uVar3;
  VNODE *v;
  VNODE *pVVar4;
  uint uVar5;
  
  __ptr = (int *)calloc(1,pl->Count << 2);
  __ptr_00 = (int *)calloc(1,pl->Count << 2);
  pVVar4 = &pl->head;
  if (pl->Count != 0) {
    uVar3 = 0;
    do {
      uVar2 = uVar3 + 1;
      __ptr[uVar3] = pVVar4->point[0];
      piVar1 = pVVar4->point;
      pVVar4 = pVVar4->next;
      __ptr_00[uVar3] = piVar1[1];
      uVar3 = uVar2;
    } while (uVar2 <= pl->Count && pl->Count != uVar2);
  }
  (*gui->set_line_cap)(Output.fgGC,Round_Cap);
  (*gui->set_line_width)(Output.fgGC,0);
  uVar3 = pl->Count - 1;
  if (pl->Count != 1) {
    uVar2 = 0;
    do {
      uVar5 = uVar2 + 1;
      (*gui->draw_line)(Output.fgGC,__ptr[uVar2],__ptr_00[uVar2],__ptr[uVar2 + 1],
                        __ptr_00[uVar2 + 1]);
      uVar3 = pl->Count - 1;
      uVar2 = uVar5;
    } while (uVar5 < uVar3);
  }
  (*gui->draw_line)(Output.fgGC,__ptr[uVar3],__ptr_00[uVar3],*__ptr,*__ptr_00);
  free(__ptr);
  free(__ptr_00);
  return 0;
}



// WARNING: Unknown calling convention

void DrawPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon,int unused)

{
  uint uVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  uVar1 = (Polygon->Flags).f;
  if ((uVar1 & 0x44) == 0) {
    pcVar3 = Layer->Color;
  }
  else if ((uVar1 & 0x40) == 0) {
    pcVar3 = PCB->ConnectedColor;
  }
  else {
    pcVar3 = Layer->SelectedColor;
  }
  (*gui->set_color)(Output.fgGC,pcVar3);
  GetLayerNumber(PCB->Data,Layer);
  iVar2 = Block.Y2;
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    if (Gathering == '\0') {
      __printf_chk(1,"DrawPolygonLowLevel: Called without Gathering set!\n");
      iVar2 = Block.Y2;
    }
    else {
      iVar4 = (Polygon->BoundingBox).X1;
      if (Block.X1 <= iVar4) {
        iVar4 = Block.X1;
      }
      iVar5 = (Polygon->BoundingBox).X2;
      if (iVar5 <= Block.X2) {
        iVar5 = Block.X2;
      }
      iVar6 = (Polygon->BoundingBox).Y1;
      if (Block.Y1 <= iVar6) {
        iVar6 = Block.Y1;
      }
      iVar2 = (Polygon->BoundingBox).Y2;
      Block.X1 = iVar4;
      Block.Y1 = iVar6;
      Block.X2 = iVar5;
      if (iVar2 <= Block.Y2) {
        iVar2 = Block.Y2;
      }
    }
  }
  Block.Y2 = iVar2;
  if ((*(byte *)&(Polygon->Flags).f & 0x10) != 0) {
    r_search(PCB->Data->pin_tree,&Polygon->BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
             cp_callback,(void *)0x100);
    r_search(PCB->Data->via_tree,&Polygon->BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
             cp_callback,&DAT_00000001);
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void DrawTextLowLevel(TextTypePtr Text,int min_line_width)

{
  int iVar1;
  PCBTypePtr pPVar2;
  byte bVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  LineTypePtr line;
  LineTypePtr pLVar8;
  LineType *pLVar9;
  int in_GS_OFFSET;
  byte bVar10;
  byte *local_a0;
  int local_9c;
  Cardinal local_98;
  LineTypePtr local_94;
  BoxType defaultsymbol;
  LineType newline;
  
  pPVar2 = PCB;
  bVar10 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_a0 = (byte *)Text->TextString;
  iVar7 = Block.Y2;
  if (Gathering == '\0') {
    if (local_a0 != (byte *)0x0) {
      bVar3 = *local_a0;
      local_9c = 0;
      if (bVar3 != 0) {
        do {
          if ((pPVar2->Font).Symbol[bVar3].Valid == '\0') {
            iVar7 = (PCB->Font).DefaultSymbol.X1;
            iVar4 = (PCB->Font).DefaultSymbol.X2;
            iVar5 = Text->Scale;
            defaultsymbol.X1 = ((local_9c + iVar7) * iVar5) / 100;
            defaultsymbol.Y1 = ((PCB->Font).DefaultSymbol.Y1 * iVar5) / 100;
            defaultsymbol.X2 = ((local_9c + iVar4) * iVar5) / 100;
            defaultsymbol.Y2 = ((PCB->Font).DefaultSymbol.Y2 * iVar5) / 100;
            RotateBoxLowLevel(&defaultsymbol,0,0,Text->Direction);
            defaultsymbol.X1 = defaultsymbol.X1 + Text->X;
            defaultsymbol.X2 = Text->X + defaultsymbol.X2;
            defaultsymbol.Y1 = defaultsymbol.Y1 + Text->Y;
            defaultsymbol.Y2 = Text->Y + defaultsymbol.Y2;
            (*gui->fill_rect)(Output.fgGC,defaultsymbol.X1,defaultsymbol.Y1,defaultsymbol.X2,
                              defaultsymbol.Y2);
            local_9c = local_9c + ((iVar4 - iVar7) * 6) / 5;
          }
          else {
            local_94 = (pPVar2->Font).Symbol[bVar3].Line;
            local_98 = (pPVar2->Font).Symbol[bVar3].LineN;
            if (local_98 != 0) {
              while( true ) {
                pLVar8 = local_94;
                pLVar9 = &newline;
                for (iVar7 = 0x16; iVar7 != 0; iVar7 = iVar7 + -1) {
                  (pLVar9->BoundingBox).X1 = (pLVar8->BoundingBox).X1;
                  pLVar8 = (LineTypePtr)((int)pLVar8 + ((uint)bVar10 * -2 + 1) * 4);
                  pLVar9 = (LineType *)((int)pLVar9 + (uint)bVar10 * -8 + 4);
                }
                iVar7 = Text->Scale;
                newline.Point1.X = ((local_9c + newline.Point1.X) * iVar7) / 100;
                newline.Point1.Y = (newline.Point1.Y * iVar7) / 100;
                newline.Point2.X = ((local_9c + newline.Point2.X) * iVar7) / 100;
                newline.Point2.Y = (newline.Point2.Y * iVar7) / 100;
                newline.Thickness = (iVar7 * newline.Thickness) / 200;
                if (newline.Thickness < min_line_width) {
                  newline.Thickness = min_line_width;
                }
                RotateLineLowLevel(&newline,0,0,Text->Direction);
                if (*(char *)&(Text->Flags).f < '\0') {
                  newline.Point1.Y = -newline.Point1.Y;
                  newline.Point2.Y = -newline.Point2.Y;
                }
                newline.Point1.X = newline.Point1.X + Text->X;
                newline.Point1.Y = newline.Point1.Y + Text->Y;
                newline.Point2.X = newline.Point2.X + Text->X;
                newline.Point2.Y = newline.Point2.Y + Text->Y;
                DrawLineLowLevel(&newline,'\x01');
                local_98 = local_98 - 1;
                if (local_98 == 0) break;
                local_94 = local_94 + 1;
              }
            }
            local_9c = local_9c + (pPVar2->Font).Symbol[*local_a0].Delta +
                       (pPVar2->Font).Symbol[*local_a0].Width;
          }
          local_a0 = local_a0 + 1;
          iVar7 = Block.Y2;
        } while ((local_a0 != (byte *)0x0) && (bVar3 = *local_a0, bVar3 != 0));
      }
    }
  }
  else {
    iVar4 = (Text->BoundingBox).X1;
    if (Block.X1 <= iVar4) {
      iVar4 = Block.X1;
    }
    iVar5 = (Text->BoundingBox).X2;
    if (iVar5 <= Block.X2) {
      iVar5 = Block.X2;
    }
    iVar6 = (Text->BoundingBox).Y1;
    if (Block.Y1 <= iVar6) {
      iVar6 = Block.Y1;
    }
    iVar7 = (Text->BoundingBox).Y2;
    Block.X1 = iVar4;
    Block.Y1 = iVar6;
    Block.X2 = iVar5;
    if (iVar7 <= Block.Y2) {
      iVar7 = Block.Y2;
    }
  }
  Block.Y2 = iVar7;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

int text_callback(BoxType *b,void *cl)

{
  DataTypePtr paVar1;
  char *pcVar2;
  int min_silk_line;
  
  if ((*(byte *)&b[1].Y1 & 0x40) == 0) {
    pcVar2 = *(char **)((int)cl + 0x48);
  }
  else {
    pcVar2 = *(char **)((int)cl + 0x4c);
  }
  (*gui->set_color)(Output.fgGC,pcVar2);
  paVar1 = PCB->Data;
  if (((LayerType *)cl == paVar1->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar1->LayerN)
     || ((LayerType *)cl == paVar1->Layer + (uint)(Settings.ShowSolderSide != '\0') + paVar1->LayerN
        )) {
    min_silk_line = PCB->minSlk;
  }
  else {
    min_silk_line = PCB->minWid;
  }
  DrawTextLowLevel((TextTypePtr)b,min_silk_line);
  return 1;
}



// WARNING: Unknown calling convention

void DrawPinOrViaNameLowLevel(PinTypePtr Ptr)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  char *name;
  char *pcVar4;
  int iVar5;
  int in_GS_OFFSET;
  TextType text;
  
  pcVar4 = Ptr->Name;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((((pcVar4 == (char *)0x0) || (*pcVar4 == '\0')) || ((*(byte *)&(PCB->Flags).f & 1) != 0)) &&
     (pcVar4 = Ptr->Number, pcVar4 == (char *)0x0)) {
    pcVar4 = "";
  }
  uVar2 = (Ptr->Flags).f >> 0xe & 1;
  if (uVar2 == 0) {
    iVar5 = Settings.PinoutTextOffsetX + Ptr->X + Ptr->DrillingHole / 2;
    iVar3 = (Settings.PinoutTextOffsetY + Ptr->Y) - Ptr->Thickness / 2;
  }
  else {
    iVar5 = (Settings.PinoutTextOffsetY + Ptr->X) - Ptr->Thickness / 2;
    iVar3 = (-Settings.PinoutTextOffsetX - Ptr->DrillingHole / 2) + Ptr->Y;
  }
  if (Gathering == '\0') {
    (*gui->set_color)(Output.fgGC,PCB->PinNameColor);
    MakeFlags(0);
    if ((gui->field_0xc & 1) != 0) {
      doing_pinout = doing_pinout + 1;
    }
    text.Scale = Ptr->Thickness / 0x50;
    text.X = iVar5;
    text.Y = iVar3;
    text.Direction = (BYTE)uVar2;
    text.TextString = pcVar4;
    DrawTextLowLevel(&text,0);
    iVar3 = Block.Y2;
    if ((gui->field_0xc & 1) != 0) {
      doing_pinout = doing_pinout + -1;
    }
  }
  else {
    if (iVar5 <= Block.X1) {
      Block.X1 = iVar5;
    }
    if (iVar5 < Block.X2) {
      iVar5 = Block.X2;
    }
    if (iVar3 <= Block.Y1) {
      Block.Y1 = iVar3;
    }
    Block.X2 = iVar5;
    if (iVar3 < Block.Y2) {
      iVar3 = Block.Y2;
    }
  }
  Block.Y2 = iVar3;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int pin_callback(BoxType *b,void *cl)

{
  if (Gathering == '\0') {
    SetPVColor((PinTypePtr)b,0x100);
  }
  DrawPinOrViaLowLevel((PinTypePtr)b,'\0');
  if ((b[1].Y1 & 0x28U) != 0x20) {
    return 1;
  }
  DrawPinOrViaNameLowLevel((PinTypePtr)b);
  return 1;
}



// WARNING: Unknown calling convention

void ErasePinName(PinTypePtr Pin)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaNameLowLevel(Pin);
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void ErasePin(PinTypePtr Pin)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaLowLevel(Pin,'\0');
  if ((*(byte *)&(Pin->Flags).f & 0x20) != 0) {
    DrawPinOrViaNameLowLevel(Pin);
  }
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void EraseViaName(PinTypePtr Via)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaNameLowLevel(Via);
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void EraseVia(PinTypePtr Via)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaLowLevel(Via,'\0');
  if ((*(byte *)&(Via->Flags).f & 0x20) != 0) {
    DrawPinOrViaNameLowLevel(Via);
  }
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void DrawPinName(PinTypePtr Pin,int unused)

{
  char *pcVar1;
  
  if (Gathering == '\0') {
    if ((*(byte *)&(Pin->Flags).f & 0x40) == 0) {
      pcVar1 = PCB->PinColor;
    }
    else {
      pcVar1 = PCB->PinSelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar1);
  }
  DrawPinOrViaNameLowLevel(Pin);
  return;
}



// WARNING: Unknown calling convention

void DrawPin(PinTypePtr Pin,int unused)

{
  if (Gathering == '\0') {
    SetPVColor(Pin,0x100);
  }
  DrawPinOrViaLowLevel(Pin,'\x01');
  if ((((Pin->Flags).f & 0x28) != 0x20) && (doing_pinout == 0)) {
    return;
  }
  DrawPinOrViaNameLowLevel(Pin);
  return;
}



// WARNING: Unknown calling convention

void DrawViaName(PinTypePtr Via,int unused)

{
  char *pcVar1;
  
  if (Gathering == '\0') {
    if ((*(byte *)&(Via->Flags).f & 0x40) == 0) {
      pcVar1 = PCB->ViaColor;
    }
    else {
      pcVar1 = PCB->ViaSelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar1);
  }
  DrawPinOrViaNameLowLevel(Via);
  return;
}



// WARNING: Unknown calling convention

void DrawVia(PinTypePtr Via,int unused)

{
  if (Gathering == '\0') {
    SetPVColor(Via,1);
  }
  DrawPinOrViaLowLevel(Via,'\x01');
  if (((Via->Flags).f & 0x28) != 0x20) {
    return;
  }
  DrawPinOrViaNameLowLevel(Via);
  return;
}



// WARNING: Unknown calling convention

void EraseElementName(ElementTypePtr Element)

{
  uint uVar1;
  uint uVar2;
  
  if ((*(byte *)&(Element->Flags).f & 0x10) != 0) {
    return;
  }
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  uVar1 = (PCB->Flags).f;
  uVar2 = 0x3c;
  if ((uVar1 & 0x40) == 0) {
    uVar2 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
  }
  DrawTextLowLevel((TextTypePtr)(Element->Name[0].Flags.t + (uVar2 - 0x18)),PCB->minSlk);
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void DrawPadNameLowLevel(PadTypePtr Pad)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  char *name;
  char *pcVar5;
  int iVar6;
  int iVar7;
  int in_GS_OFFSET;
  TextType text;
  
  pcVar5 = Pad->Name;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) || ((*(byte *)&(PCB->Flags).f & 1) != 0)) &&
     (pcVar5 = Pad->Number, pcVar5 == (char *)0x0)) {
    pcVar5 = "";
  }
  iVar2 = (Pad->Point1).X;
  iVar3 = (Pad->Point2).X;
  if (iVar2 == iVar3) {
    iVar4 = Pad->Thickness / 2;
    iVar6 = (iVar2 + Settings.PinoutTextOffsetY) - iVar4;
    iVar7 = (Pad->Point2).Y;
    if (iVar7 <= (Pad->Point1).Y) {
      iVar7 = (Pad->Point1).Y;
    }
    iVar4 = (iVar7 - Settings.PinoutTextOffsetX) + iVar4;
  }
  else {
    iVar7 = -(Pad->Thickness / 2);
    iVar4 = iVar2;
    if (iVar3 <= iVar2) {
      iVar4 = iVar3;
    }
    iVar6 = iVar4 + iVar7 + Settings.PinoutTextOffsetX;
    iVar4 = iVar7 + Settings.PinoutTextOffsetY + (Pad->Point1).Y;
  }
  if (Gathering == '\0') {
    (*gui->set_color)(Output.fgGC,PCB->PinNameColor);
    MakeFlags(0);
    text.Scale = Pad->Thickness / 0x32;
    text.X = iVar6;
    text.Y = iVar4;
    text.Direction = iVar2 == iVar3;
    text.TextString = pcVar5;
    DrawTextLowLevel(&text,0);
    iVar4 = Block.Y2;
  }
  else {
    if (iVar6 <= Block.X1) {
      Block.X1 = iVar6;
    }
    if (iVar6 < Block.X2) {
      iVar6 = Block.X2;
    }
    if (iVar4 <= Block.Y1) {
      Block.Y1 = iVar4;
    }
    Block.X2 = iVar6;
    if (iVar4 < Block.Y2) {
      iVar4 = Block.Y2;
    }
  }
  Block.Y2 = iVar4;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void EraseElementPinsAndPads(ElementTypePtr Element)

{
  Cardinal sn;
  Cardinal sn_1;
  uint uVar1;
  uint uVar2;
  Cardinal n;
  PadTypePtr pad;
  PadTypePtr Pad;
  PinTypePtr pin;
  PinTypePtr Ptr;
  int iVar3;
  uint local_20;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  if (Element->PinN != 0) {
    uVar2 = 0;
    local_20 = Element->PinN;
    do {
      Ptr = Element->Pin + uVar2;
      DrawPinOrViaLowLevel(Ptr,'\0');
      if ((*(byte *)&(Ptr->Flags).f & 0x20) == 0) {
        uVar1 = Element->PinN;
      }
      else {
        DrawPinOrViaNameLowLevel(Ptr);
        uVar1 = Element->PinN;
      }
    } while ((uVar1 != 0) &&
            (uVar2 = (uVar1 + 1 + uVar2) - local_20, local_20 = uVar1, uVar2 < uVar1));
  }
  uVar2 = Element->PadN;
  iVar3 = 0;
  local_20 = 0;
  uVar1 = uVar2;
LAB_0808c82b:
  do {
    if ((uVar1 == 0) || (uVar1 <= local_20)) {
      Erasing = Erasing + -1;
      return;
    }
    Pad = (PadTypePtr)((Element->Pad->Flags).t + iVar3 + -0x18);
    DrawPadLowLevel(Output.fgGC,Pad,'\0','\0');
    if ((*(byte *)&(Pad->Flags).f & 0x20) == 0) goto LAB_0808c820;
    DrawPadNameLowLevel(Pad);
    uVar1 = Element->PadN;
  } while (Element->PadN != uVar2);
  goto LAB_0808c869;
LAB_0808c820:
  uVar1 = Element->PadN;
  if (Element->PadN == uVar2) {
LAB_0808c869:
    local_20 = local_20 + 1;
    iVar3 = iVar3 + 0x68;
    uVar1 = uVar2;
  }
  goto LAB_0808c82b;
}



// WARNING: Unknown calling convention

void ErasePadName(PadTypePtr Pad)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPadNameLowLevel(Pad);
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void ErasePad(PadTypePtr Pad)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPadLowLevel(Output.fgGC,Pad,'\0','\0');
  if ((*(byte *)&(Pad->Flags).f & 0x20) != 0) {
    DrawPadNameLowLevel(Pad);
  }
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void DrawPadName(PadTypePtr Pad,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Gathering == '\0') {
    uVar1 = (Pad->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      if ((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) {
        pcVar2 = PCB->PinColor;
      }
      else {
        pcVar2 = PCB->InvisibleObjectsColor;
      }
    }
    else {
      pcVar2 = PCB->PinSelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar2);
  }
  DrawPadNameLowLevel(Pad);
  return;
}



// WARNING: Unknown calling convention

void DrawPad(PadTypePtr Pad,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Gathering != '\0') goto LAB_0808ca25;
  if (doing_pinout == 0) {
    uVar1 = (Pad->Flags).f;
    if ((uVar1 & 0x244) == 0) {
      if ((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) goto LAB_0808ca60;
      pcVar2 = PCB->InvisibleObjectsColor;
    }
    else if ((uVar1 & 0x200) == 0) {
      if ((uVar1 & 0x40) == 0) {
        pcVar2 = PCB->ConnectedColor;
      }
      else {
        pcVar2 = PCB->PinSelectedColor;
      }
    }
    else {
      pcVar2 = PCB->WarnColor;
    }
  }
  else {
LAB_0808ca60:
    pcVar2 = PCB->PinColor;
  }
  (*gui->set_color)(Output.fgGC,pcVar2);
LAB_0808ca25:
  DrawPadLowLevel(Output.fgGC,Pad,'\0','\0');
  if ((doing_pinout == 0) && ((*(byte *)&(Pad->Flags).f & 0x20) == 0)) {
    return;
  }
  DrawPadNameLowLevel(Pad);
  return;
}



// WARNING: Unknown calling convention

int pad_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    return 1;
  }
  DrawPad((PadTypePtr)b,0);
  return 1;
}



// WARNING: Unknown calling convention

int backPad_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    DrawPad((PadTypePtr)b,0);
  }
  return 1;
}



// WARNING: Unknown calling convention

void DrawElementPinsAndPads(ElementTypePtr Element,int unused)

{
  uint uVar1;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar2;
  PadTypePtr pad;
  PadTypePtr Pad;
  uint uVar3;
  Cardinal n;
  int local_24;
  uint local_20;
  
  local_24 = 0;
  local_20 = 0;
  uVar2 = Element->PadN;
  uVar3 = uVar2;
  while ((uVar3 != 0 && (local_20 < uVar3))) {
    Pad = (PadTypePtr)((Element->Pad->Flags).t + local_24 + -0x18);
    if ((doing_pinout != 0) ||
       (((doing_assy != 0 || (((Pad->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide)) ||
        (PCB->InvisibleObjectsOn != '\0')))) {
      DrawPad(Pad,unused);
      uVar3 = Element->PadN;
    }
    if (uVar2 == uVar3) {
      local_20 = local_20 + 1;
      local_24 = local_24 + 0x68;
      uVar3 = uVar2;
    }
  }
  if (Element->PinN != 0) {
    uVar3 = 0;
    uVar2 = Element->PinN;
    do {
      DrawPin(Element->Pin + uVar3,unused);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return;
      }
      uVar3 = (uVar1 + 1 + uVar3) - uVar2;
      uVar2 = uVar1;
    } while (uVar3 < uVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void EraseElement(ElementTypePtr Element)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  Cardinal n_1;
  Cardinal n;
  int iVar4;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  iVar4 = Element->LineN - 1;
  if (iVar4 != -1) {
    iVar3 = Element->LineN * 0x58;
    do {
      iVar4 = iVar4 + -1;
      DrawLineLowLevel((LineTypePtr)(Element->Line[-1].Flags.t + iVar3 + -0x18),'\0');
      iVar3 = iVar3 + -0x58;
    } while (iVar4 != -1);
  }
  iVar4 = Element->ArcN - 1;
  if (iVar4 != -1) {
    iVar3 = Element->ArcN * 0x44;
    do {
      iVar4 = iVar4 + -1;
      DrawArcLowLevel((ArcTypePtr)(Element->Arc[-1].Flags.t + iVar3 + -0x18));
      iVar3 = iVar3 + -0x44;
    } while (iVar4 != -1);
  }
  if ((*(byte *)&(Element->Flags).f & 0x10) == 0) {
    uVar1 = (PCB->Flags).f;
    uVar2 = 0x3c;
    if ((uVar1 & 0x40) == 0) {
      uVar2 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
    }
    DrawTextLowLevel((TextTypePtr)(Element->Name[0].Flags.t + (uVar2 - 0x18)),PCB->minSlk);
  }
  EraseElementPinsAndPads(Element);
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void EraseText(LayerTypePtr Layer,TextTypePtr Text)

{
  DataTypePtr paVar1;
  int min_silk_line;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  paVar1 = PCB->Data;
  if ((paVar1->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar1->LayerN == Layer) ||
     (paVar1->Layer + (uint)(Settings.ShowSolderSide != '\0') + paVar1->LayerN == Layer)) {
    min_silk_line = PCB->minSlk;
  }
  else {
    min_silk_line = PCB->minWid;
  }
  DrawTextLowLevel(Text,min_silk_line);
  Erasing = Erasing + -1;
  return;
}



// WARNING: Unknown calling convention

void EraseObject(int type,void *lptr,void *ptr)

{
  if (type == 0x20) {
LAB_0808cde8:
    EraseLine((LineTypePtr)ptr);
    return;
  }
  if (type < 0x21) {
    if (type == 4) goto LAB_0808cde8;
    if (type < 5) {
      if (type == 1) goto LAB_0808ce88;
      if (type == 2) {
        EraseElement((ElementTypePtr)ptr);
        return;
      }
    }
    else {
      if (type == 8) {
        ErasePolygon((PolygonTypePtr)ptr);
        return;
      }
      if (type == 0x10) goto LAB_0808ce12;
    }
  }
  else {
    if (type == 0x400) {
LAB_0808ce12:
      EraseText((LayerTypePtr)lptr,(TextTypePtr)ptr);
      return;
    }
    if (type < 0x401) {
      if (type == 0x100) {
LAB_0808ce88:
        ErasePin((PinTypePtr)ptr);
        return;
      }
      if (type == 0x200) {
        ErasePad((PadTypePtr)ptr);
        return;
      }
    }
    else {
      if ((type == 0x4000) || (type == 0x8000)) {
        EraseArc((ArcTypePtr)ptr);
        return;
      }
      if (type == 0x2000) goto LAB_0808cde8;
    }
  }
  Message("hace: Internal ERROR, trying to erase an unknown type\n");
  return;
}



// WARNING: Unknown calling convention

void DrawElementName(ElementTypePtr Element,int unused)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  if ((((gui->field_0xc & 1) == 0) || ((*(byte *)((int)&(PCB->Flags).f + 2) & 0x20) == 0)) &&
     (uVar1 = (Element->Flags).f, (uVar1 & 0x10) == 0)) {
    if ((doing_pinout == 0) && (doing_assy == 0)) {
      uVar3 = 0x3c;
      uVar2 = (PCB->Flags).f;
      if ((uVar2 & 0x40) == 0) {
        uVar3 = -(uint)((uVar2 & 0x20) == 0) & 0x78;
      }
      if ((Element->Name[0].Flags.t[uVar3 - 4] & 0x40) == 0) {
        if ((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) {
          (*gui->set_color)(Output.fgGC,PCB->ElementColor);
        }
        else {
          (*gui->set_color)(Output.fgGC,PCB->InvisibleObjectsColor);
        }
      }
      else {
        (*gui->set_color)(Output.fgGC,PCB->ElementSelectedColor);
      }
    }
    else {
      (*gui->set_color)(Output.fgGC,PCB->ElementColor);
    }
    uVar1 = (PCB->Flags).f;
    uVar2 = 0x3c;
    if ((uVar1 & 0x40) == 0) {
      uVar2 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
    }
    DrawTextLowLevel((TextTypePtr)(Element->Name[0].Flags.t + (uVar2 - 0x18)),PCB->minSlk);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int frontN_callback(BoxType *b,void *cl)

{
  uint uVar1;
  ElementTypePtr element;
  
  uVar1 = (((ElementTypePtr)b[3].X2)->Flags).f;
  if (((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) && ((uVar1 & 0x10) == 0)) {
    DrawElementName((ElementTypePtr)b[3].X2,0);
    return 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

int backN_callback(BoxType *b,void *cl)

{
  uint uVar1;
  ElementTypePtr element;
  
  uVar1 = (((ElementTypePtr)b[3].X2)->Flags).f;
  if (((uVar1 >> 7 & 1) != (int)Settings.ShowSolderSide) && ((uVar1 & 0x10) == 0)) {
    DrawElementName((ElementTypePtr)b[3].X2,0);
    return 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

void DrawElement(ElementTypePtr Element,int unused)

{
  DrawElementPackage(Element,unused);
  DrawElementName(Element,unused);
  DrawElementPinsAndPads(Element,unused);
  return;
}



// WARNING: Unknown calling convention

void DrawText(LayerTypePtr Layer,TextTypePtr Text,int unused)

{
  DataTypePtr paVar1;
  char *pcVar2;
  int min_silk_line;
  
  if (Layer->On != '\0') {
    if ((*(byte *)&(Text->Flags).f & 0x40) == 0) {
      pcVar2 = Layer->Color;
    }
    else {
      pcVar2 = Layer->SelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar2);
    paVar1 = PCB->Data;
    if ((paVar1->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar1->LayerN == Layer) ||
       (paVar1->Layer + (uint)(Settings.ShowSolderSide != '\0') + paVar1->LayerN == Layer)) {
      min_silk_line = PCB->minSlk;
    }
    else {
      min_silk_line = PCB->minWid;
    }
    DrawTextLowLevel(Text,min_silk_line);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void DrawObject(int type,void *ptr1,void *ptr2,int unused)

{
  if (type == 0x10) {
    if (*(char *)((int)ptr1 + 0x44) != '\0') {
      DrawText((LayerTypePtr)ptr1,(TextTypePtr)ptr2,0);
      return;
    }
  }
  else if (type < 0x11) {
    if (type == 2) {
      if ((PCB->ElementOn != '\0') &&
         (((*(uint *)((int)ptr2 + 0x14) >> 7 & 1) == (int)Settings.ShowSolderSide ||
          (PCB->InvisibleObjectsOn != '\0')))) {
        DrawElement((ElementTypePtr)ptr2,0);
        return;
      }
    }
    else if (type < 3) {
      if ((type == 1) && (PCB->ViaOn != '\0')) {
        DrawVia((PinTypePtr)ptr2,0);
        return;
      }
    }
    else if (type == 4) {
      if (*(char *)((int)ptr1 + 0x44) != '\0') {
        DrawLine((LayerTypePtr)ptr1,(LineTypePtr)ptr2,0);
        return;
      }
    }
    else if ((type == 8) && (*(char *)((int)ptr1 + 0x44) != '\0')) {
      DrawPolygon((LayerTypePtr)ptr1,(PolygonTypePtr)ptr2,0);
      return;
    }
  }
  else if (type == 0x200) {
    if (PCB->PinOn != '\0') {
      DrawPad((PadTypePtr)ptr2,0);
      return;
    }
  }
  else if (type < 0x201) {
    if (type == 0x20) {
      if (PCB->RatOn != '\0') {
        DrawRat((RatTypePtr)ptr2,0);
        return;
      }
    }
    else if ((type == 0x100) && (PCB->PinOn != '\0')) {
      DrawPin((PinTypePtr)ptr2,0);
      return;
    }
  }
  else if (type == 0x400) {
    if ((PCB->ElementOn != '\0') &&
       (((*(uint *)((int)ptr2 + 0x14) >> 7 & 1) == (int)Settings.ShowSolderSide ||
        (PCB->InvisibleObjectsOn != '\0')))) {
      DrawElementName((ElementTypePtr)ptr1,0);
      return;
    }
  }
  else if ((type == 0x4000) && (*(char *)((int)ptr1 + 0x44) != '\0')) {
    DrawArc((LayerTypePtr)ptr1,(ArcTypePtr)ptr2,0);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void Draw(void)

{
  render = '\x01';
  HideCrosshair('\x01');
  (*gui->invalidate_lr)(Block.X1,Block.X2,Block.Y1,Block.Y2,1);
  RestoreCrosshair('\x01');
  Block.Y2 = 0;
  Block.X2 = 0;
  Block.Y1 = 0;
  Block.X1 = 0;
  return;
}



// WARNING: Unknown calling convention

void hid_expose_callback(HID *hid,BoxType *region,void *item)

{
  Cardinal CVar1;
  ElementTypePtr paVar2;
  uint uVar3;
  HID *pHVar4;
  HID *pHVar5;
  Boolean BVar6;
  PCBTypePtr pPVar7;
  hidGC phVar8;
  hidGC phVar9;
  hidGC phVar10;
  int group;
  int iVar11;
  int iVar12;
  int doit;
  Cardinal sn_1;
  DataTypePtr paVar13;
  int iVar14;
  uint uVar15;
  PadTypePtr pad;
  Cardinal n;
  uint uVar16;
  PadTypePtr paVar17;
  int i;
  int iVar18;
  int *piVar19;
  int group_1;
  uint uVar20;
  byte bVar21;
  int local_c4;
  HID *local_c0;
  char local_b9;
  int local_b8;
  int local_b4;
  Cardinal *local_b0;
  int drawn_groups [16];
  int do_group [16];
  HoleCountStruct hcs;
  undefined4 local_20 [4];
  
  phVar10 = Output.pmGC;
  phVar9 = Output.fgGC;
  phVar8 = Output.bgGC;
  pHVar4 = gui;
  bVar21 = 0;
  gui = hid;
  Output.fgGC = (*hid->make_gc)();
  Output.bgGC = (*gui->make_gc)();
  Output.pmGC = (*gui->make_gc)();
  render = '\x01';
  Gathering = '\0';
  (*hid->set_color)(Output.pmGC,"erase");
  (*hid->set_color)(Output.bgGC,"drill");
  pPVar7 = PCB;
  if (item == (void *)0x0) {
    paVar13 = PCB->Data;
    paVar13->Layer[(uint)(Settings.ShowSolderSide == '\0') + paVar13->LayerN].Color =
         PCB->ElementColor;
    paVar13->Layer[(uint)(Settings.ShowSolderSide != '\0') + paVar13->LayerN].Color =
         pPVar7->InvisibleObjectsColor;
    piVar19 = do_group;
    for (iVar14 = 0x10; iVar14 != 0; iVar14 = iVar14 + -1) {
      *piVar19 = 0;
      piVar19 = piVar19 + (uint)bVar21 * -2 + 1;
    }
    local_b4 = -1;
    paVar13 = pPVar7->Data;
    iVar14 = paVar13->LayerN;
    if (0 < iVar14) {
      local_b4 = 0;
      iVar18 = 0;
      do {
        CVar1 = LayerStack[iVar18];
        iVar14 = GetLayerGroupNumberByNumber(CVar1);
        if ((paVar13->Layer[CVar1].On != '\0') && (do_group[iVar14] == 0)) {
          do_group[iVar14] = 1;
          drawn_groups[local_b4] = iVar14;
          local_b4 = local_b4 + 1;
        }
        iVar18 = iVar18 + 1;
        paVar13 = PCB->Data;
        iVar14 = paVar13->LayerN;
      } while (iVar18 < iVar14);
      local_b4 = local_b4 + -1;
    }
    iVar14 = GetLayerGroupNumberByNumber(iVar14 + 1);
    iVar18 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    if ((((*(byte *)&(PCB->Flags).f & 4) == 0) &&
        (iVar12 = (*gui->set_layer)("invisible",-4000,0), iVar12 != 0)) &&
       (r_search(PCB->Data->pad_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,backPad_callback,
                 (void *)0x0), PCB->ElementOn != '\0')) {
      r_search(PCB->Data->element_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,backE_callback,
               (void *)0x0);
      uVar16 = (PCB->Flags).f;
      uVar15 = 1;
      if ((uVar16 & 0x40) == 0) {
        uVar15 = -(uint)((uVar16 & 0x20) == 0) & 2;
      }
      r_search(PCB->Data->name_tree[uVar15],region,(_func_int_BoxType_ptr_void_ptr *)0x0,
               backN_callback,(void *)0x0);
      DrawLayer(PCB->Data->Layer + (uint)(Settings.ShowSolderSide != '\0') + PCB->Data->LayerN,
                region);
    }
    if (local_b4 != -1) {
      piVar19 = drawn_groups + local_b4;
      do {
        iVar12 = *piVar19;
        iVar11 = (*gui->set_layer)((char *)0x0,iVar12,0);
        if (((iVar11 != 0) &&
            (iVar11 = DrawLayerGroup(iVar12,region), BVar6 = Settings.ShowSolderSide,
            Settings.ShowSolderSide = BVar6, iVar11 != 0)) && ((gui->field_0xc & 1) == 0)) {
          r_search(PCB->Data->pin_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,pin_callback,
                   (void *)0x0);
          r_search(PCB->Data->via_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,pin_callback,
                   (void *)0x0);
          if ((iVar18 == iVar12) || (iVar14 == iVar12)) {
            Settings.ShowSolderSide = iVar18 == iVar12;
            r_search(PCB->Data->pad_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,pad_callback,
                     (void *)0x0);
          }
          Settings.ShowSolderSide = BVar6;
          if ((gui->field_0xc & 1) == 0) {
            local_20[0] = 0xffffffff;
            r_search(PCB->Data->pin_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
                     local_20);
            r_search(PCB->Data->via_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
                     local_20);
          }
        }
        local_b4 = local_b4 + -1;
        piVar19 = piVar19 + -1;
      } while (local_b4 != -1);
    }
    if (((*(byte *)&(PCB->Flags).f & 4) == 0) || ((gui->field_0xc & 1) == 0)) {
      if ((PCB->ViaOn != '\0') && ((gui->field_0xc & 1) != 0)) {
        r_search(PCB->Data->via_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,lowvia_callback,
                 (void *)0x0);
      }
      iVar12 = (*gui->set_layer)("componentmask",-0xfdf,0);
      BVar6 = Settings.ShowSolderSide;
      if (iVar12 != 0) {
        Settings.ShowSolderSide = '\0';
        DrawMask(region);
      }
      Settings.ShowSolderSide = BVar6;
      iVar12 = (*gui->set_layer)("soldermask",-0xfde,0);
      BVar6 = Settings.ShowSolderSide;
      if (iVar12 != 0) {
        Settings.ShowSolderSide = '\x01';
        DrawMask(region);
      }
      Settings.ShowSolderSide = BVar6;
      if ((gui->field_0xc & 1) == 0) {
        hcs.nunplated = 0;
        hcs.nplated = 0;
        r_search(PCB->Data->pin_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 hole_counting_callback,&hcs);
        r_search(PCB->Data->via_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 hole_counting_callback,&hcs);
        if ((hcs.nplated != 0) && (iVar12 = (*gui->set_layer)("plated-drill",-0xfd0,0), iVar12 != 0)
           ) {
          local_20[0] = 1;
          r_search(PCB->Data->pin_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
                   local_20);
          r_search(PCB->Data->via_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
                   local_20);
        }
        if ((hcs.nunplated != 0) &&
           (iVar12 = (*gui->set_layer)("unplated-drill",-0xfc0,0), iVar12 != 0)) {
          local_20[0] = 0;
          r_search(PCB->Data->pin_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
                   local_20);
          r_search(PCB->Data->via_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
                   local_20);
        }
      }
      else {
        DrawTop(region);
      }
      iVar12 = (*gui->set_layer)("topsilk",-0xfef,0);
      if (iVar12 != 0) {
        DrawSilk(0,1,region);
      }
      iVar12 = (*gui->set_layer)("bottomsilk",-0xfee,0);
      if (iVar12 != 0) {
        DrawSilk(1,0,region);
      }
      local_c0 = gui;
      if ((gui->field_0xc & 1) != 0) {
        if (PCB->PinOn != '\0') {
          r_search(PCB->Data->element_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   EMark_callback,(void *)0x0);
        }
        pPVar7 = PCB;
        pHVar5 = gui;
        local_c0 = gui;
        if (PCB->RatOn != '\0') {
          iVar12 = strcmp(gui->name,"lesstif");
          if (iVar12 == 0) {
            (*pHVar5->use_mask)(2);
            r_search(PCB->Data->rat_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,rat_callback,
                     (void *)0x0);
            (*gui->use_mask)(0);
            local_c0 = gui;
          }
          else {
            r_search(pPVar7->Data->rat_tree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,
                     rat_callback,(void *)0x0);
            local_c0 = gui;
          }
        }
      }
      local_b4 = 0;
      do {
        CVar1 = PCB->Data->ElementN;
        local_b8 = CVar1 - 1;
        iVar12 = 1;
        if (local_b8 != -1) {
          local_b9 = '\x01';
          local_b0 = &PCB->Data->Element[CVar1 - 1].PadN;
          do {
            if (*local_b0 != 0) {
              paVar17 = (PadTypePtr)local_b0[7];
              uVar16 = (paVar17->Flags).f & 0x80;
              if (((local_b4 == 0) && (uVar16 != 0)) || (((char)local_b4 != '\0' && (uVar16 == 0))))
              {
LAB_0808dbf0:
                local_b9 = '\0';
              }
              else {
                for (uVar16 = 1; uVar16 < *local_b0; uVar16 = uVar16 + 1) {
                  uVar15 = paVar17[1].Flags.f & 0x80;
                  if (((local_b4 == 0) && (uVar15 != 0)) ||
                     ((paVar17 = paVar17 + 1, (char)local_b4 != '\0' && (uVar15 == 0))))
                  goto LAB_0808dbf0;
                }
              }
            }
            local_b8 = local_b8 + -1;
            local_b0 = local_b0 + -0x4b;
          } while (local_b8 != -1);
          iVar12 = (int)local_b9;
        }
        gui = local_c0;
        if (local_b4 == 0) {
          iVar12 = (*local_c0->set_layer)("bottompaste",-0xfae,iVar12);
        }
        else {
          iVar12 = (*local_c0->set_layer)("toppaste",-0xfaf,iVar12);
        }
        if (iVar12 != 0) {
          (*gui->set_color)(Output.fgGC,PCB->ElementColor);
          paVar13 = PCB->Data;
          local_c0 = (HID *)(paVar13->ElementN - 1);
          if (local_c0 != (HID *)0xffffffff) {
            iVar12 = paVar13->ElementN * 300;
            while( true ) {
              local_c4 = iVar12 + -300;
              iVar11 = 0;
              paVar2 = paVar13->Element;
              local_b0 = (Cardinal *)0x0;
              uVar16 = *(uint *)((int)&paVar2[-1].PadN + iVar12);
              uVar15 = uVar16;
              while ((uVar15 != 0 && (local_b0 < uVar15))) {
                paVar17 = (PadTypePtr)(*(int *)((int)&paVar2[-1].Pad + iVar12) + iVar11);
                uVar3 = (paVar17->Flags).f;
                uVar20 = uVar3 & 0x80;
                if ((((local_b4 == 0) && (uVar20 != 0)) ||
                    (((char)local_b4 != '\0' && (uVar20 == 0)))) && ((uVar3 & 8) == 0)) {
                  DrawPadLowLevel(Output.fgGC,paVar17,'\0','\0');
                  uVar15 = *(uint *)((int)&paVar2[-1].PadN + iVar12);
                }
                if (uVar16 == uVar15) {
                  local_b0 = (Cardinal *)((int)local_b0 + 1);
                  iVar11 = iVar11 + 0x68;
                  uVar15 = uVar16;
                }
              }
              local_c0 = (HID *)((int)local_c0 + -1);
              if (local_c0 == (HID *)0xffffffff) break;
              paVar13 = PCB->Data;
              iVar12 = local_c4;
            }
          }
        }
        local_b4 = local_b4 + 1;
        if (local_b4 == 2) goto LAB_0808dd8e;
        local_c0 = gui;
      } while( true );
    }
  }
  else {
    doing_pinout = 1;
    DrawElement((ElementTypePtr)item,0);
    doing_pinout = 0;
  }
LAB_0808d529:
  (*gui->destroy_gc)(Output.fgGC);
  (*gui->destroy_gc)(Output.bgGC);
  (*gui->destroy_gc)(Output.pmGC);
  Output.bgGC = phVar8;
  Output.pmGC = phVar10;
  gui = pHVar4;
  Output.fgGC = phVar9;
  Gathering = '\x01';
  return;
LAB_0808dd8e:
  doing_assy = 1;
  iVar12 = (*gui->set_layer)("topassembly",-0xf7f,0);
  if (iVar12 != 0) {
    PrintAssembly(region,iVar14,0);
  }
  iVar14 = (*gui->set_layer)("bottomassembly",-0xf7e,0);
  if (iVar14 != 0) {
    PrintAssembly(region,iVar18,1);
  }
  doing_assy = 0;
  iVar14 = (*gui->set_layer)("fab",-0xf90,0);
  if (iVar14 != 0) {
    PrintFab();
  }
  goto LAB_0808d529;
}



void __regparm3 DrawPlainVia(PinTypePtr Via,Boolean holeToo)

{
  if (Gathering == '\0') {
    SetPVColor(Via,1);
  }
  DrawPinOrViaLowLevel(Via,'\0');
  if (((Via->Flags).f & 0x28) != 0x20) {
    return;
  }
  DrawPinOrViaNameLowLevel(Via);
  return;
}



// WARNING: Unknown calling convention

int lowvia_callback(BoxType *b,void *cl)

{
  if (b[2].Y2 == 0) {
    DrawPlainVia((PinTypePtr)b,'\0');
  }
  return 1;
}



// WARNING: Unknown calling convention

int via_callback(BoxType *b,void *cl)

{
  Boolean in_DL;
  
  if (b[2].Y2 != 0) {
    DrawPlainVia((PinTypePtr)b,in_DL);
  }
  return 1;
}



// WARNING: Unknown calling convention

int clearPin_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  int t;
  int b_1;
  int iVar3;
  int l;
  int iVar4;
  int r;
  
                    // WARNING: Load size is inaccurate
  if ((*cl != '\0') && (iVar2 = b[2].Y2 / 2, iVar2 != 0)) {
    if ((b[1].Y1 & 0x100U) == 0) {
      if ((b[1].Y1 & 0x800U) == 0) {
        if (((PCB->Flags).f & 0x24000) == 0) {
          (*gui->fill_circle)(Output.pmGC,b[3].Y1,b[3].X2,iVar2);
        }
        else {
          (*gui->draw_arc)(Output.pmGC,b[3].Y1,b[3].X2,iVar2,iVar2,0,0x168);
        }
      }
      else {
        (*gui->set_line_cap)(Output.pmGC,Round_Cap);
        (*gui->set_line_width)(Output.pmGC,(b[2].Y1 + b[2].X2) - b[3].X1);
        DrawSpecialPolygon(gui,Output.pmGC,b[3].Y1,b[3].X2,iVar2 * 2);
      }
    }
    else {
      iVar4 = b[3].Y1 - iVar2;
      iVar3 = b[3].X2 - iVar2;
      iVar1 = iVar2 * 2 + iVar4;
      iVar2 = iVar2 * 2 + iVar3;
      if (((PCB->Flags).f & 0x24000) == 0) {
        (*gui->fill_rect)(Output.pmGC,iVar4,iVar3,iVar1,iVar2);
      }
      else {
        (*gui->set_line_cap)(Output.pmGC,Round_Cap);
        (*gui->set_line_width)(Output.pmGC,0);
        (*gui->draw_line)(Output.pmGC,iVar1,iVar2,iVar1,iVar3);
        (*gui->draw_line)(Output.pmGC,iVar4,iVar2,iVar4,iVar3);
        (*gui->draw_line)(Output.pmGC,iVar1,iVar2,iVar4,iVar2);
        (*gui->draw_line)(Output.pmGC,iVar1,iVar3,iVar4,iVar3);
      }
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

int DrillQSort(void *va,void *vb)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return *va - *vb;
}



// WARNING: Unknown calling convention

void FreeDrillInfo(DrillInfoTypePtr Drills)

{
  DrillTypePtr pDVar1;
  DrillTypePtr drill;
  int iVar2;
  uint uVar3;
  Cardinal n;
  
  if (Drills->DrillN != 0) {
    iVar2 = 0;
    uVar3 = 0;
    do {
      pDVar1 = Drills->Drill;
      SaveFree(*(void **)((int)&pDVar1->Element + iVar2));
      *(undefined4 *)((int)&pDVar1->Element + iVar2) = 0;
      SaveFree(*(void **)((int)&pDVar1->Pin + iVar2));
      *(undefined4 *)((int)&pDVar1->Pin + iVar2) = 0;
      if (Drills->DrillN == 0) break;
      uVar3 = uVar3 + 1;
      iVar2 = iVar2 + 0x28;
    } while (uVar3 < Drills->DrillN);
  }
  SaveFree(Drills->Drill);
  Drills->Drill = (DrillTypePtr)0x0;
  SaveFree(Drills);
  return;
}



// WARNING: Unknown calling convention

void RoundDrillInfo(DrillInfoTypePtr d,int roundto)

{
  DrillTypePtr pDVar1;
  uint uVar2;
  int iVar3;
  DrillTypePtr pDVar4;
  PinTypePtr *ppaVar5;
  ElementTypePtr *ppaVar6;
  int ej;
  uint uVar7;
  uint i;
  uint uVar9;
  ElementTypePtr paVar10;
  Cardinal CVar11;
  int iVar12;
  int ei;
  uint uVar13;
  DrillTypePtr pDVar14;
  uint local_24;
  uint uVar8;
  
  local_24 = 0;
  CVar11 = d->DrillN;
  do {
    while( true ) {
      if ((CVar11 == 0) || (CVar11 - 1 <= local_24)) {
        return;
      }
      pDVar14 = d->Drill + local_24;
      uVar9 = local_24 + 1;
      pDVar4 = d->Drill + uVar9;
      iVar3 = ((roundto / 2 + pDVar14->DrillSize) / roundto) * roundto;
      if (iVar3 == ((roundto / 2 + pDVar4->DrillSize) / roundto) * roundto) break;
      pDVar14->DrillSize = iVar3;
      CVar11 = d->DrillN;
      local_24 = uVar9;
    }
    CVar11 = pDVar4->ElementN + pDVar14->ElementN;
    pDVar14->ElementMax = CVar11;
    if (CVar11 != 0) {
      ppaVar6 = (ElementTypePtr *)MyRealloc(pDVar14->Element,CVar11 * 4,"RoundDrillInfo");
      pDVar1 = d->Drill;
      pDVar14->Element = ppaVar6;
      pDVar4 = pDVar1 + uVar9;
      if (pDVar4->ElementN != 0) {
        uVar13 = 0;
        do {
          uVar2 = pDVar1[local_24].ElementN;
          if (uVar2 == 0) {
            ppaVar6 = pDVar1[local_24].Element;
            paVar10 = pDVar4->Element[uVar13];
            CVar11 = 1;
            iVar12 = 0;
LAB_0808e79a:
            *(ElementTypePtr *)((int)ppaVar6 + iVar12) = paVar10;
            pDVar1[local_24].ElementN = CVar11;
          }
          else {
            ppaVar6 = pDVar1[local_24].Element;
            paVar10 = pDVar4->Element[uVar13];
            uVar7 = 0;
            if (*ppaVar6 != paVar10) {
              do {
                uVar8 = uVar7;
                uVar7 = uVar8 + 1;
                if (uVar2 <= uVar7) break;
              } while (ppaVar6[uVar7] != paVar10);
              if (uVar7 == uVar2) {
                iVar12 = uVar7 * 4;
                CVar11 = uVar8 + 2;
                goto LAB_0808e79a;
              }
            }
          }
          uVar13 = uVar13 + 1;
        } while (uVar13 <= pDVar4->ElementN && pDVar4->ElementN != uVar13);
      }
    }
    SaveFree(pDVar4->Element);
    pDVar4 = d->Drill;
    pDVar4[uVar9].Element = (ElementTypePtr *)0x0;
    pDVar4[local_24].PinMax = pDVar4[uVar9].PinN + pDVar4[local_24].PinN;
    ppaVar5 = (PinTypePtr *)
              MyRealloc(pDVar4[local_24].Pin,pDVar4[local_24].PinMax << 2,"RoundDrillInfo");
    pDVar14 = d->Drill;
    pDVar4[local_24].Pin = ppaVar5;
    memcpy(pDVar14[local_24].Pin + pDVar14[local_24].PinN,pDVar14[uVar9].Pin,
           pDVar14[uVar9].PinN << 2);
    pDVar4 = d->Drill;
    pDVar4[local_24].PinN = pDVar4[local_24].PinN + pDVar4[uVar9].PinN;
    SaveFree(pDVar4[uVar9].Pin);
    pDVar4 = d->Drill;
    pDVar4[local_24].PinCount = pDVar4[local_24].PinCount + pDVar4[uVar9].PinCount;
    pDVar4[local_24].ViaCount = pDVar4[local_24].ViaCount + pDVar4[uVar9].ViaCount;
    pDVar4[local_24].UnplatedCount = pDVar4[local_24].UnplatedCount + pDVar4[uVar9].UnplatedCount;
    pDVar4[uVar9].Pin = (PinTypePtr *)0x0;
    pDVar4[local_24].DrillSize = iVar3;
    memmove(pDVar4 + uVar9,pDVar4 + local_24 + 2,(d->DrillN - local_24) * 0x28 - 0x50);
    CVar11 = d->DrillN - 1;
    d->DrillN = CVar11;
  } while( true );
}



// WARNING: Unknown calling convention

void InitializeDrill(DrillTypePtr drill,PinTypePtr pin,ElementTypePtr element)

{
  BDimension BVar1;
  PinTypeHandle ppaVar2;
  void *ptr;
  ElementTypeHandle ppaVar3;
  
  BVar1 = pin->DrillingHole;
  drill->Element = (ElementTypePtr *)0x0;
  drill->ElementN = 0;
  drill->ViaCount = 0;
  drill->DrillSize = BVar1;
  drill->PinCount = 0;
  drill->UnplatedCount = 0;
  drill->ElementMax = 0;
  drill->PinN = 0;
  drill->Pin = (PinTypePtr *)0x0;
  drill->PinMax = 0;
  ppaVar2 = GetDrillPinMemory(drill);
  *ppaVar2 = pin;
  if (element == (ElementTypePtr)0x0) {
    drill->ViaCount = 1;
  }
  else {
    ppaVar3 = GetDrillElementMemory(drill);
    drill->PinCount = 1;
    *ppaVar3 = element;
  }
  if ((*(byte *)&(pin->Flags).f & 8) != 0) {
    drill->UnplatedCount = 1;
  }
  return;
}



// WARNING: Unknown calling convention

void FillDrill(DrillTypePtr Drill,ElementTypePtr Element,PinTypePtr Pin)

{
  ElementTypePtr paVar1;
  ElementTypePtr *ppaVar2;
  PinTypeHandle ppaVar3;
  PinTypeHandle pin;
  Cardinal n;
  int iVar4;
  ElementTypeHandle ppaVar5;
  ElementTypeHandle ptr;
  
  ppaVar3 = GetDrillPinMemory(Drill);
  *ppaVar3 = Pin;
  if (Element == (ElementTypePtr)0x0) {
    Drill->ViaCount = Drill->ViaCount + 1;
  }
  else {
    Drill->PinCount = Drill->PinCount + 1;
    iVar4 = Drill->ElementN - 1;
    if (iVar4 == -1) {
LAB_0808e8c1:
      ppaVar5 = GetDrillElementMemory(Drill);
      *ppaVar5 = Element;
    }
    else {
      paVar1 = Drill->Element[iVar4];
      ppaVar2 = Drill->Element + (Drill->ElementN - 2);
      while (paVar1 != Element) {
        iVar4 = iVar4 + -1;
        if (iVar4 == -1) goto LAB_0808e8c1;
        paVar1 = *ppaVar2;
        ppaVar2 = ppaVar2 + -1;
      }
    }
  }
  if ((*(byte *)&(Pin->Flags).f & 8) != 0) {
    Drill->UnplatedCount = Drill->UnplatedCount + 1;
  }
  return;
}



// WARNING: Unknown calling convention

DrillInfoTypePtr GetDrillInfo(DataTypePtr top)

{
  ElementTypePtr *ppaVar1;
  PinTypePtr *ppaVar2;
  Cardinal CVar3;
  Cardinal CVar4;
  Cardinal CVar5;
  Cardinal CVar6;
  Cardinal CVar7;
  Cardinal CVar8;
  Cardinal CVar9;
  bool bVar10;
  bool bVar11;
  DrillInfoTypePtr DrillInfo;
  Cardinal sn;
  PinTypePtr paVar12;
  Cardinal CVar13;
  BDimension BVar14;
  DrillTypePtr pDVar15;
  DrillTypePtr Drill;
  Cardinal sn_1;
  Boolean NewDrill;
  ElementTypePtr element;
  int iVar16;
  uint uVar17;
  Cardinal n;
  DrillTypePtr drill;
  DrillTypePtr drill_1;
  DrillTypePtr Drill_00;
  DrillInfoTypePtr AllDrills;
  int iVar18;
  int local_90;
  int local_8c;
  uint local_84;
  DrillTypePtr local_80;
  uint local_78;
  uint local_58;
  uint local_50;
  DrillType swapdrill;
  
  DrillInfo = (DrillInfoTypePtr)MyCalloc(1,0xc,"GetAllDrillInfo()");
  bVar11 = false;
  local_80 = (DrillTypePtr)0x0;
  local_8c = top->ElementN - 1;
  if (local_8c != -1) {
    iVar16 = top->ElementN * 300;
    do {
      local_90 = iVar16 + -300;
      element = (ElementTypePtr)(top->Element[-1].Flags.t + iVar16 + -0x18);
      if (element->PinN != 0) {
        local_78 = 0;
        local_84 = element->PinN;
        do {
          paVar12 = element->Pin + local_78;
          if (bVar11) {
            iVar16 = paVar12->DrillingHole;
            if (local_80->DrillSize == iVar16) {
              FillDrill(local_80,element,paVar12);
            }
            else {
              CVar13 = 0;
              if (DrillInfo->DrillN == 0) {
LAB_0808eae6:
                if (DrillInfo->Drill[CVar13 - 1].DrillSize < iVar16) {
LAB_0808ec98:
                  local_80 = GetDrillInfoDrillMemory(DrillInfo);
                  InitializeDrill(local_80,paVar12,element);
                }
              }
              else {
                Drill_00 = DrillInfo->Drill;
                BVar14 = Drill_00->DrillSize;
                if (iVar16 != BVar14) {
                  iVar18 = 0x28;
                  bVar10 = false;
                  local_50 = 0;
                  do {
                    if (BVar14 <= iVar16) {
                      iVar16 = paVar12->DrillingHole;
                      CVar13 = DrillInfo->DrillN;
                      if (CVar13 != 0) goto LAB_0808e9f0;
LAB_0808eae0:
                      iVar16 = paVar12->DrillingHole;
                      goto LAB_0808eae6;
                    }
                    if (bVar10) {
                      iVar16 = paVar12->DrillingHole;
                    }
                    else {
                      InitializeDrill(&swapdrill,paVar12,element);
                      pDVar15 = GetDrillInfoDrillMemory(DrillInfo);
                      iVar16 = paVar12->DrillingHole;
                      pDVar15->DrillSize = iVar16 + 1;
                      BVar14 = Drill_00->DrillSize;
                      local_80 = Drill_00;
                    }
                    ppaVar1 = Drill_00->Element;
                    ppaVar2 = Drill_00->Pin;
                    CVar3 = Drill_00->PinMax;
                    CVar4 = Drill_00->PinN;
                    CVar5 = Drill_00->UnplatedCount;
                    CVar6 = Drill_00->ViaCount;
                    CVar7 = Drill_00->PinCount;
                    CVar8 = Drill_00->ElementMax;
                    CVar9 = Drill_00->ElementN;
                    Drill_00->DrillSize = swapdrill.DrillSize;
                    Drill_00->ElementN = swapdrill.ElementN;
                    Drill_00->ElementMax = swapdrill.ElementMax;
                    Drill_00->PinCount = swapdrill.PinCount;
                    Drill_00->ViaCount = swapdrill.ViaCount;
                    Drill_00->UnplatedCount = swapdrill.UnplatedCount;
                    Drill_00->PinN = swapdrill.PinN;
                    Drill_00->PinMax = swapdrill.PinMax;
                    Drill_00->Pin = swapdrill.Pin;
                    Drill_00->Element = swapdrill.Element;
                    CVar13 = DrillInfo->DrillN;
                    bVar10 = true;
                    swapdrill.DrillSize = BVar14;
                    swapdrill.ElementN = CVar9;
                    swapdrill.ElementMax = CVar8;
                    swapdrill.PinCount = CVar7;
                    swapdrill.ViaCount = CVar6;
                    swapdrill.UnplatedCount = CVar5;
                    swapdrill.PinN = CVar4;
                    swapdrill.PinMax = CVar3;
                    swapdrill.Pin = ppaVar2;
                    swapdrill.Element = ppaVar1;
                    if (CVar13 == 0) goto LAB_0808eae0;
LAB_0808e9f0:
                    local_50 = local_50 + 1;
                    if (CVar13 <= local_50) goto LAB_0808eae0;
                    Drill_00 = (DrillTypePtr)((int)&DrillInfo->Drill->DrillSize + iVar18);
                    iVar18 = iVar18 + 0x28;
                    BVar14 = Drill_00->DrillSize;
                  } while (iVar16 != BVar14);
                }
                FillDrill(Drill_00,element,paVar12);
                local_80 = Drill_00;
                if (DrillInfo->Drill[DrillInfo->DrillN - 1].DrillSize < paVar12->DrillingHole)
                goto LAB_0808ec98;
              }
            }
            uVar17 = element->PinN;
          }
          else {
            local_80 = GetDrillInfoDrillMemory(DrillInfo);
            InitializeDrill(local_80,paVar12,element);
            bVar11 = true;
            uVar17 = element->PinN;
          }
        } while ((uVar17 != 0) &&
                (local_78 = (uVar17 + 1 + local_78) - local_84, local_84 = uVar17, local_78 < uVar17
                ));
      }
      local_8c = local_8c + -1;
      iVar16 = local_90;
    } while (local_8c != -1);
  }
  if (top->ViaN != 0) {
    local_50 = 0;
    local_58 = top->ViaN;
    do {
      paVar12 = top->Via + local_50;
      if (bVar11) {
        iVar16 = paVar12->DrillingHole;
        if (local_80->DrillSize == iVar16) {
          FillDrill(local_80,(ElementTypePtr)0x0,paVar12);
        }
        else {
          if (DrillInfo->DrillN != 0) {
            local_80 = DrillInfo->Drill;
            uVar17 = 1;
            if (iVar16 == local_80->DrillSize) {
LAB_0808ed30:
              FillDrill(local_80,(ElementTypePtr)0x0,paVar12);
              if (local_80->DrillSize == paVar12->DrillingHole) goto LAB_0808ec3e;
            }
            else {
              for (; local_80 = local_80 + 1, uVar17 < DrillInfo->DrillN; uVar17 = uVar17 + 1) {
                if (iVar16 == local_80->DrillSize) goto LAB_0808ed30;
              }
            }
          }
          local_80 = GetDrillInfoDrillMemory(DrillInfo);
          local_80->DrillSize = paVar12->DrillingHole;
          FillDrill(local_80,(ElementTypePtr)0x0,paVar12);
        }
LAB_0808ec3e:
        uVar17 = top->ViaN;
      }
      else {
        local_80 = GetDrillInfoDrillMemory(DrillInfo);
        local_80->DrillSize = paVar12->DrillingHole;
        FillDrill(local_80,(ElementTypePtr)0x0,paVar12);
        bVar11 = true;
        uVar17 = top->ViaN;
      }
    } while ((uVar17 != 0) &&
            (local_50 = (uVar17 + 1 + local_50) - local_58, local_58 = uVar17, local_50 < uVar17));
  }
  qsort(DrillInfo->Drill,DrillInfo->DrillN,0x28,DrillQSort);
  return DrillInfo;
}



// WARNING: Unknown calling convention

Context * FindContext(int cod)

{
  Context *pCVar1;
  Context *wlk;
  Context *pCVar2;
  uint hsh;
  Context *pCVar3;
  
  pCVar2 = ContextHash[cod % 0x7f];
  if ((pCVar2 != (Context *)0x0) && (pCVar1 = pCVar2, pCVar2->Code != cod)) {
    while (pCVar3 = pCVar1, pCVar1 = pCVar3->Next, pCVar1 != (Context *)0x0) {
      if (pCVar1->Code == cod) {
        pCVar3->Next = pCVar1->Next;
        pCVar1->Next = pCVar2;
        ContextHash[cod % 0x7f] = pCVar1;
        return pCVar1;
      }
    }
    pCVar2 = (Context *)0x0;
  }
  return pCVar2;
}



// WARNING: Unknown calling convention

void EnterKeyword(char *str)

{
  Keyword *pKVar1;
  char cVar2;
  Keyword *pKVar3;
  uint uVar4;
  uint hsh;
  char *cp;
  char *pcVar5;
  uint uVar6;
  
  uVar4 = 0;
  uVar6 = 0;
  cVar2 = *str;
  pcVar5 = str;
  if (cVar2 != '\0') {
    do {
      pcVar5 = pcVar5 + 1;
      uVar4 = (int)cVar2 + uVar4 * 2;
      cVar2 = *pcVar5;
    } while (cVar2 != '\0');
    uVar6 = uVar4 % 0x7f;
  }
  pKVar3 = (Keyword *)malloc(8);
  pKVar1 = KeywordTable[uVar6];
  pKVar3->String = str;
  pKVar3->Next = pKVar1;
  KeywordTable[uVar6] = pKVar3;
  return;
}



// WARNING: Unknown calling convention

char * xmalloc(int siz)

{
  char *pcVar1;
  
  pcVar1 = (char *)malloc(siz);
  return pcVar1;
}



// WARNING: Unknown calling convention

pair_list * new_pair_list(str_pair *ps)

{
  pair_list *ppVar1;
  
  ppVar1 = (pair_list *)malloc(8);
  ppVar1->list = ps;
  ppVar1->name = (char *)0x0;
  return ppVar1;
}



// WARNING: Unknown calling convention

str_pair * new_str_pair(char *s1,char *s2)

{
  str_pair *psVar1;
  
  psVar1 = (str_pair *)malloc(0xc);
  psVar1->str1 = s1;
  psVar1->next = (_str_pair *)0x0;
  psVar1->str2 = s2;
  return psVar1;
}



// WARNING: Unknown calling convention

void str_pair_free(str_pair *ps)

{
  _str_pair *p_Var1;
  
  if (ps != (str_pair *)0x0) {
    do {
      free(ps->str1);
      free(ps->str2);
      p_Var1 = ps->next;
      free(ps);
      ps = p_Var1;
    } while (p_Var1 != (_str_pair *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void pair_list_free(pair_list *pl)

{
  str_pair_free(pl->list);
  free(pl->name);
  free(pl);
  return;
}



// WARNING: Unknown calling convention

void define_pcb_net(str_pair *name,pair_list *nodes)

{
  _str_pair *p_Var1;
  LibraryMenuTypePtr Menu;
  char *pcVar2;
  char *buf;
  size_t sVar3;
  size_t sVar4;
  int tl;
  __int32_t **pp_Var5;
  LibraryEntryTypePtr paVar6;
  char cVar7;
  int __res;
  char *p;
  char *pcVar8;
  LibraryEntryTypePtr entry;
  str_pair *node;
  _str_pair *ps;
  
  Menu = GetLibraryMenuMemory(&PCB->NetlistLib);
  if (name->str1 == (char *)0x0) {
    if (name->str2 != (char *)0x0) {
      free(name->str2);
    }
    free(name);
  }
  else {
    pcVar2 = (char *)__strdup(name->str1);
    Menu->Name = pcVar2;
    free(name->str1);
    if (name->str2 != (char *)0x0) {
      free(name->str2);
    }
    free(name);
    pcVar2 = (char *)malloc(0x100);
    if (pcVar2 != (char *)0x0) {
      ps = nodes->list;
      free(nodes->name);
      free(nodes);
      if (ps == (_str_pair *)0x0) {
        return;
      }
      pcVar8 = ps->str1;
      if (pcVar8 == (char *)0x0) goto LAB_0808f0d7;
      do {
        sVar3 = strlen(pcVar8);
        sVar4 = strlen(ps->str2);
        if (0xfd < (int)(sVar4 + sVar3)) {
          free(pcVar2);
          pcVar2 = (char *)malloc(sVar4 + sVar3 + 3);
          if (pcVar2 == (char *)0x0) {
            str_pair_free(ps);
            return;
          }
          pcVar8 = ps->str1;
        }
        strcpy(pcVar2,pcVar8);
        cVar7 = *pcVar2;
        pcVar8 = pcVar2;
        while (cVar7 != '\0') {
          if ((int)cVar7 + 0x80U < 0x180) {
            pp_Var5 = __ctype_toupper_loc();
            cVar7 = (char)(*pp_Var5)[cVar7];
          }
          *pcVar8 = cVar7;
          pcVar8 = pcVar8 + 1;
          cVar7 = *pcVar8;
        }
        sVar3 = strlen(ps->str1);
        pcVar2[sVar3] = '-';
        pcVar8 = ps->str2;
        if (*pcVar8 == '&') {
          sVar3 = strlen(ps->str1);
          strcpy(pcVar2 + sVar3 + 1,pcVar8 + 1);
        }
        else {
          sVar3 = strlen(ps->str1);
          strcpy(pcVar2 + sVar3 + 1,pcVar8);
        }
        free(ps->str1);
        free(ps->str2);
        paVar6 = GetLibraryEntryMemory(Menu);
        pcVar8 = (char *)__strdup(pcVar2);
        paVar6->ListEntry = pcVar8;
        p_Var1 = ps->next;
        free(ps);
        ps = p_Var1;
        while( true ) {
          if (ps == (_str_pair *)0x0) {
            return;
          }
          pcVar8 = ps->str1;
          if (pcVar8 != (char *)0x0) break;
LAB_0808f0d7:
          free(ps->str2);
          p_Var1 = ps->next;
          free(ps);
          ps = p_Var1;
        }
      } while( true );
    }
  }
  pair_list_free(nodes);
  return;
}



char * FindKeyword(char *str)

{
  Keyword *pKVar1;
  char *pcVar2;
  Keyword *pKVar3;
  char cVar4;
  __int32_t **pp_Var5;
  char *cp;
  ushort **ppuVar6;
  uint hsh;
  int __res;
  int iVar7;
  char *pcVar8;
  Keyword *owk;
  Keyword *pKVar9;
  int in_GS_OFFSET;
  uint local_134;
  Keyword *local_130;
  char lower [256];
  int local_20;
  
  pcVar8 = lower;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar2 = yytext;
  while( true ) {
    pcVar8 = pcVar8 + 1;
    cVar4 = *pcVar2;
    if (cVar4 == '\0') break;
    ppuVar6 = __ctype_b_loc();
    iVar7 = (int)cVar4;
    if (((*(byte *)((int)*ppuVar6 + iVar7 * 2 + 1) & 1) != 0) && (iVar7 + 0x80U < 0x180)) {
      pp_Var5 = __ctype_tolower_loc();
      cVar4 = (char)(*pp_Var5)[iVar7];
    }
    pcVar8[-1] = cVar4;
    pcVar2 = pcVar2 + 1;
  }
  pcVar8[-1] = '\0';
  local_134 = 0;
  if (lower[0] != '\0') {
    local_134 = 0;
    pcVar8 = lower;
    do {
      pcVar8 = pcVar8 + 1;
      local_134 = (int)lower[0] + local_134 * 2;
      lower[0] = *pcVar8;
    } while (lower[0] != '\0');
    local_134 = local_134 % 0x7f;
  }
  pKVar1 = KeywordTable[local_134];
  if (pKVar1 != (Keyword *)0x0) {
    local_130 = (Keyword *)0x0;
    pKVar3 = pKVar1;
    do {
      pKVar9 = pKVar3;
      pcVar8 = pKVar9->String;
      iVar7 = strcmp(pcVar8,lower);
      if (iVar7 == 0) {
        if (local_130 != (Keyword *)0x0) {
          pcVar8 = pKVar9->String;
          local_130->Next = pKVar9->Next;
          pKVar9->Next = pKVar1;
          KeywordTable[local_134] = pKVar9;
        }
        goto LAB_0808f2ba;
      }
      pKVar3 = pKVar9->Next;
      local_130 = pKVar9;
    } while (pKVar9->Next != (Keyword *)0x0);
  }
  pcVar8 = (char *)0x0;
LAB_0808f2ba:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar8;
}



// WARNING: Unknown calling convention

int edifparse(void)

{
  YYSTYPE *__dest;
  int yyn;
  uint yystacksize;
  short *psVar1;
  Bucket *bck_2;
  uint uVar2;
  int yytoken;
  Bucket *bck_1;
  Bucket *bck;
  ContextCar *csp;
  uint uVar3;
  UsedCar *usc_1;
  char *cp;
  UsedCar *usc;
  int yystate;
  yytype_int16 *yyssp;
  TokenCar *owk;
  YYSTYPE *yyvsp;
  YYSTYPE yyval;
  int iVar4;
  yytype_int16 *yyss;
  int yyresult;
  ContextCar *owk_1;
  YYSTYPE *yyvs;
  int l;
  uint uVar5;
  int yylen;
  int local_4f4;
  int local_4f0;
  YYSTYPE *local_4ec;
  short *local_4e4;
  uint local_4e0;
  uint local_4dc;
  YYSTYPE *local_4d8;
  short *local_4d4;
  YYSTYPE yyvsa [200];
  yytype_int16 yyssa [200];
  
  local_4ec = yyvsa;
  edifnerrs = 0;
  edifchar = -2;
  local_4e0 = 0;
  local_4dc = 200;
  local_4f4 = 0;
  local_4f0 = 199;
  local_4e4 = yyssa;
  local_4d8 = local_4ec;
  local_4d4 = yyssa;
  do {
    *local_4d4 = (short)local_4e0;
    if (local_4e4 + local_4f0 <= local_4d4) {
      if (local_4dc < 10000) {
        local_4dc = local_4dc * 2;
        if (10000 < local_4dc) {
          local_4dc = 10000;
        }
        psVar1 = (short *)malloc(local_4dc * 6 + 3);
        if (psVar1 == (short *)0x0) goto LAB_080907be;
        iVar4 = (int)local_4d4 - (int)local_4e4 >> 1;
        memcpy(psVar1,local_4e4,(iVar4 + 1) * 2);
        __dest = (YYSTYPE *)(psVar1 + local_4dc);
        memcpy(__dest,local_4ec,(iVar4 + 1) * 4);
        if (yyssa != local_4e4) {
          free(local_4e4);
        }
        local_4d4 = psVar1 + iVar4;
        local_4f0 = local_4dc - 1;
        local_4e4 = psVar1;
        if (local_4d4 < psVar1 + local_4f0) {
          local_4d8 = __dest + iVar4;
          local_4ec = __dest;
          goto yybackup;
        }
LAB_0808fc91:
        yyresult = 1;
      }
      else {
LAB_080907be:
        __fprintf_chk(Error,1,"%s, line %ld: %s\n",InFile,LineNumber,"memory exhausted");
        yyresult = 2;
      }
      goto LAB_0808fc9c;
    }
yybackup:
    iVar4 = (int)yypact[local_4e0];
    if (iVar4 == -0x535) {
yydefault:
      uVar2 = (uint)yydefact[local_4e0];
      if (uVar2 == 0) {
yyerrlab:
        if (local_4f4 == 0) {
          edifnerrs = edifnerrs + 1;
          __fprintf_chk(Error,1,"%s, line %ld: %s\n",InFile,LineNumber,"syntax error");
        }
        else if (local_4f4 == 3) {
          if (edifchar < 1) {
            if (edifchar == 0) goto LAB_0808fc91;
          }
          else {
            edifchar = -2;
          }
        }
        while ((((iVar4 == -0x535 || (uVar2 = iVar4 + 1, 0xa3b < uVar2)) ||
                (*(short *)(iVar4 + 0x8142661 + uVar2) != 1)) ||
               (local_4e0 = (uint)*(ushort *)(iVar4 + 0x8143ae1 + uVar2), local_4e0 == 0))) {
          if (local_4d4 == local_4e4) {
            yyresult = 1;
            psVar1 = local_4e4;
            goto LAB_0808fa4b;
          }
          local_4d4 = local_4d4 + -1;
          local_4d8 = local_4d8 + -1;
          iVar4 = (int)yypact[*local_4d4];
        }
        if (local_4e0 == 0xb) goto yyreturn;
        local_4d8 = local_4d8 + 1;
        local_4f4 = 3;
        *local_4d8 = ediflval;
      }
      else {
        uVar5 = (uint)""[uVar2];
        if (yydefact[local_4e0] < 0x46a) {
                    // WARNING: Could not recover jumptable at 0x0808f537. Too many branches
                    // WARNING: Treating indirect jump as call
          iVar4 = (*(code *)(&PTR_LAB_0813fcc0)[uVar2])();
          return iVar4;
        }
        local_4d4 = local_4d4 + -uVar5;
        uVar3 = (uint)yyr1[uVar2];
        local_4d8[1 - uVar5] = local_4d8[1 - uVar5];
        uVar2 = (int)*local_4d4 + (int)*(short *)(uVar3 + 0x8146858 + (uVar3 - 0x128));
        if ((uVar2 < 0xa3c) && (*local_4d4 == yycheck[uVar2])) {
          local_4e0 = (uint)yytable[uVar2];
          local_4d8 = local_4d8 + (1 - uVar5);
        }
        else {
          local_4e0 = (uint)*(short *)(uVar3 + 0x8146c18 + (uVar3 - 0x128));
          local_4d8 = local_4d8 + (1 - uVar5);
        }
      }
    }
    else {
      if (edifchar == -2) {
        iVar4 = _IO_getc((_IO_FILE *)Input);
        yytext[0] = (char)iVar4;
                    // WARNING: Could not recover jumptable at 0x0808f5be. Too many branches
                    // WARNING: Treating indirect jump as call
        iVar4 = (*(code *)&DAT_0808f600)();
        return iVar4;
      }
      if (edifchar < 1) {
        edifchar = 0;
        uVar2 = 0;
      }
      else {
        uVar2 = 2;
        if ((uint)edifchar < 0x226) {
          uVar2 = (uint)yytranslate[edifchar];
        }
      }
      uVar5 = uVar2 + iVar4;
      if ((0xa3b < uVar5) || ((int)yycheck[uVar5] != uVar2)) goto yydefault;
      local_4e0 = (uint)yytable[uVar5];
      if (local_4e0 == 0) goto yyerrlab;
      if (local_4e0 == 0xb) {
yyreturn:
        yyresult = 0;
LAB_0808fc9c:
        psVar1 = local_4e4;
        if (local_4e4 != local_4d4) {
          psVar1 = (short *)((int)local_4d4 +
                            (~((int)local_4d4 + (-2 - (int)local_4e4)) & 0xfffffffeU));
        }
LAB_0808fa4b:
        if (yyssa != psVar1) {
          free(local_4e4);
        }
        return yyresult;
      }
      local_4f4 = local_4f4 + -1 + (uint)(local_4f4 == 0);
      if (edifchar != 0) {
        edifchar = -2;
      }
      local_4d8 = local_4d8 + 1;
      *local_4d8 = ediflval;
    }
    local_4d4 = local_4d4 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void ParseEDIF(char *filename,FILE *err)

{
  ushort uVar1;
  Token *pTVar2;
  Context *pCVar3;
  Context *cxt;
  ContextCar *pCVar4;
  Context *pCVar5;
  TokenCar *pTVar6;
  int iVar7;
  short sVar8;
  uint hsh;
  uint hsh_1;
  uint uVar9;
  Token *pTVar10;
  int *piVar11;
  short *psVar12;
  int iVar13;
  int i;
  uint hsh_2;
  int iVar14;
  Token *owk;
  Token *pTVar15;
  Context *cxt_1;
  int local_28;
  short *local_20;
  
  InFile = filename;
  Input = (FILE *)fopen(filename,"r");
  Error = err;
  LineNumber = 1;
  if (ParseEDIF::ContextDefined != 0) {
    piVar11 = &TokenDef[0x36].Code;
    do {
      piVar11[1] = (int)TokenHash[*piVar11 % 0x33];
      TokenHash[*piVar11 % 0x33] = (Token *)(piVar11 + -1);
      pTVar15 = (Token *)(piVar11 + -1);
      piVar11 = piVar11 + -3;
      EnterKeyword(pTVar15->Name);
    } while (piVar11 != (int *)&DAT_08164478);
    psVar12 = &ContextDef[0xe8].Code;
    do {
      uVar1 = *psVar12;
      sVar8 = uVar1 + (((short)((uint)uVar1 + ((uint)((short)uVar1 * -0x7efd) >> 0x10)) >> 6) -
                      ((short)uVar1 >> 0xf)) * -0x7f;
      *(Context **)(psVar12 + 6) = ContextHash[sVar8];
      ContextHash[sVar8] = (Context *)(psVar12 + -2);
      pCVar3 = (Context *)(psVar12 + -2);
      psVar12 = psVar12 + -10;
      EnterKeyword(pCVar3->Name);
    } while ((Token **)psVar12 != &TokenDef[0x36].Next);
    iVar13 = 0xc4;
    while( true ) {
      pCVar3 = FindContext((int)BinderDef[iVar13].Origin);
      iVar14 = (int)BinderDef[iVar13].FollowerSize;
      if (iVar14 != 0) {
        iVar7 = 0;
        psVar12 = BinderDef[iVar13].Follower + iVar14 + -1;
        do {
          pCVar4 = (ContextCar *)malloc(0xc);
          pCVar4->Next = pCVar3->Context;
          sVar8 = *psVar12;
          pCVar3->Context = pCVar4;
          uVar9 = (int)sVar8 >> 0x1f;
          pCVar5 = FindContext(((int)sVar8 ^ uVar9) - uVar9);
          pCVar4->Context = pCVar5;
          sVar8 = *psVar12;
          psVar12 = psVar12 + -1;
          (pCVar4->u).Single = (uint)(int)sVar8 >> 0x1f;
          iVar7 = iVar7 + 1;
        } while (iVar7 != iVar14);
      }
      if (iVar13 == 0) break;
      iVar13 = iVar13 + -1;
    }
    iVar13 = 8;
    do {
      pCVar3 = FindContext((int)TieDef[iVar13].Origin);
      iVar14 = (int)TieDef[iVar13].EnableSize;
      if (iVar14 != 0) {
        local_28 = 0;
        local_20 = TieDef[iVar13].Enable + iVar14 + -1;
        do {
          pTVar6 = (TokenCar *)malloc(8);
          pTVar6->Next = pCVar3->Token;
          pCVar3->Token = pTVar6;
          iVar7 = (int)*local_20;
          pTVar15 = TokenHash[iVar7 % 0x33];
          if ((pTVar15 != (Token *)0x0) && (pTVar2 = pTVar15, iVar7 != pTVar15->Code)) {
            do {
              pTVar10 = pTVar2;
              pTVar2 = pTVar10->Next;
              if (pTVar2 == (Token *)0x0) {
                pTVar15 = (Token *)0x0;
                goto LAB_08090c54;
              }
            } while (iVar7 != pTVar2->Code);
            pTVar10->Next = pTVar2->Next;
            pTVar2->Next = pTVar15;
            TokenHash[iVar7 % 0x33] = pTVar2;
            pTVar15 = pTVar2;
          }
LAB_08090c54:
          local_28 = local_28 + 1;
          local_20 = local_20 + -1;
          pTVar6->Token = pTVar15;
        } while (iVar14 != local_28);
      }
      if (iVar13 == 0) goto LAB_08090c80;
      iVar13 = iVar13 + -1;
    } while( true );
  }
LAB_08090cb9:
  CurrentBucket = (Bucket *)malloc(0x48);
  CurrentBucket->Index = 0;
  CurrentBucket->Next = (Bucket *)0x0;
  edifparse();
  return;
LAB_08090c80:
  pCVar4 = (ContextCar *)malloc(0xc);
  CSP = pCVar4;
  pCVar4->Next = (ContextCar *)0x0;
  pCVar3 = FindContext(0);
  pCVar4->Context = pCVar3;
  (CSP->u).Single = 0;
  ParseEDIF::ContextDefined = 0;
  goto LAB_08090cb9;
}



// WARNING: Unknown calling convention

void Message(char *Format,...)

{
  (*gui->logv)(Format,&stack0x00000008);
  return;
}



// WARNING: Unknown calling convention

void MyFatal(char *Format,...)

{
  __pid_t _Var1;
  
  EmergencySave();
  _Var1 = getpid();
  __fprintf_chk(stderr,1,"%s (%i): fatal, ",Progname,_Var1);
  __vfprintf_chk(stderr,1,Format,&stack0x00000008);
  fflush(stderr);
                    // WARNING: Subroutine does not return
  exit(1);
}



// WARNING: Unknown calling convention

void CatchSignal(int Signal)

{
  char *pcVar1;
  char *s;
  
  pcVar1 = "unknown";
  if (Signal - 1U < 0xf) {
    pcVar1 = *(char **)(CSWTCH_44 + (Signal - 1U) * 4);
  }
  MyFatal("aborted by %s signal\n",pcVar1);
  return;
}



// WARNING: Unknown calling convention

void ChdirErrorMessage(char *DirName)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(DirName);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t change working directory to\n   \'%s\'\nchdir() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention

void OpendirErrorMessage(char *DirName)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(DirName);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t scan directory\n   \'%s\'\nopendir() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention

void PopenErrorMessage(char *Filename)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(Filename);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t execute command\n   \'%s\'\npopen() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention

void OpenErrorMessage(char *Filename)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(Filename);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t open file\n   \'%s\'\nfopen() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention

void PreLoadElementPCB(void)

{
  DataTypePtr paVar1;
  
  if (yyPCB != (PCBTypePtr)0x0) {
    yyFont = &yyPCB->Font;
    paVar1 = yyPCB->Data;
    yyData = paVar1;
    paVar1->pcb = yyPCB;
    paVar1->LayerN = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void DisableEmergencySave(void)

{
  dont_save_any_more = '\x01';
  return;
}



// WARNING: Unknown calling convention

void EnableAutosave(void)

{
  hidval local_10 [3];
  
  if ((backup_timer.lval != 0) && (gui->stop_timer != (_func_void_hidval *)0x0)) {
    (*gui->stop_timer)((hidval)backup_timer.lval);
  }
  backup_timer.lval = 0;
  if ((0 < Settings.BackupInterval) &&
     (gui->add_timer != (_func_hidval__func_void_hidval_ptr_ulong_hidval *)0x0)) {
    (*gui->add_timer)((_func_void_hidval *)local_10,(ulong)backup_cb,
                      (hidval)(Settings.BackupInterval * 1000));
    backup_timer = local_10[0];
  }
  return;
}



// WARNING: Unknown calling convention

void sort_library(LibraryTypePtr lib)

{
  int i;
  uint uVar1;
  uint uVar2;
  
  qsort(lib->Menu,lib->MenuN,0x1c,netlist_sort);
  if (lib->MenuN != 0) {
    uVar1 = 0;
    do {
      uVar2 = uVar1 + 1;
      qsort(lib->Menu[uVar1].Entry,lib->Menu[uVar1].EntryN,0x18,netnode_sort);
      uVar1 = uVar2;
    } while (uVar2 <= lib->MenuN && lib->MenuN != uVar2);
  }
  return;
}



// WARNING: Unknown calling convention

int ReadNetlist(char *filename)

{
  char cVar1;
  bool bVar2;
  char cVar3;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  LibraryEntryTypePtr paVar7;
  int i;
  size_t len;
  size_t sVar8;
  int iVar9;
  LibraryEntryTypePtr entry;
  char *pcVar10;
  int j;
  int iVar11;
  int in_GS_OFFSET;
  bool bVar12;
  FILE *local_23c;
  int local_238;
  LibraryMenuTypePtr local_234;
  int local_230;
  char temp [256];
  char inputline [256];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar9 = 1;
  if (filename == (char *)0x0) goto LAB_0809142d;
  Message("Importing PCB netlist %s\n",filename);
  if ((Settings.RatCommand == (char *)0x0) || (*Settings.RatCommand == '\0')) {
    local_23c = fopen(filename,"r");
    bVar2 = false;
    if (local_23c == (FILE *)0x0) {
      Message("Cannot open %s for reading",filename);
      iVar9 = 1;
      goto LAB_0809142d;
    }
LAB_080910ae:
    local_230 = 0;
    local_238 = 0;
    local_234 = (LibraryMenuTypePtr)0x0;
    while (pcVar4 = fgets(inputline,0xff,local_23c), pcVar4 != (char *)0x0) {
      pcVar4 = inputline;
      do {
        len = (size_t)pcVar4;
        uVar5 = *(uint *)len + 0xfefefeff & ~*(uint *)len;
        uVar6 = uVar5 & 0x80808080;
        pcVar4 = (char *)(len + 4);
      } while (uVar6 == 0);
      bVar12 = (uVar5 & 0x8080) == 0;
      if (bVar12) {
        uVar6 = uVar6 >> 0x10;
      }
      sVar8 = len + 4;
      if (bVar12) {
        sVar8 = len + 6;
      }
      iVar9 = ((sVar8 - 3) - (uint)CARRY1((byte)uVar6,(byte)uVar6)) - (int)inputline;
      if (iVar9 == 0) {
        iVar9 = -1;
      }
      else if (temp[iVar9 + 0xff] == '\n') {
        temp[iVar9 + 0xff] = '\0';
        iVar9 = iVar9 + -2;
      }
      else {
        iVar9 = iVar9 + -2;
        Message("Line length (%i) exceeded in netlist file.\nadditional characters will be ignored.\n"
                ,0xff);
      }
      cVar1 = inputline[iVar9];
      if (cVar1 == '\\') {
        inputline[iVar9] = '\0';
      }
      iVar9 = 0;
LAB_08091160:
      cVar3 = inputline[iVar9];
      if (cVar3 != '\0') {
        do {
          pcVar4 = inputline + iVar9 + 1;
          do {
            if (((cVar3 != '\t') && (cVar3 != ' ')) && (cVar3 != '\n')) {
              cVar3 = inputline[iVar9];
              goto LAB_08091198;
            }
            cVar3 = *pcVar4;
            iVar9 = iVar9 + 1;
            pcVar4 = pcVar4 + 1;
          } while (cVar3 != '\0');
          cVar3 = '\0';
LAB_08091198:
          iVar11 = 0;
          if (local_230 == 0) {
            temp[0] = ' ';
            iVar11 = 2;
            temp[1] = ' ';
          }
          if ((cVar3 == '\t') || (cVar3 == ' ')) {
LAB_08091213:
            temp[iVar11] = '\0';
            if (cVar3 != '\0') {
LAB_0809121f:
              pcVar4 = inputline + iVar9 + 1;
              do {
                if (((cVar3 != '\t') && (cVar3 != ' ')) && (cVar3 != '\n')) break;
                cVar3 = *pcVar4;
                iVar9 = iVar9 + 1;
                pcVar4 = pcVar4 + 1;
              } while (cVar3 != '\0');
            }
          }
          else {
            if (cVar3 == '\n') {
LAB_08091358:
              temp[iVar11] = '\0';
              cVar3 = '\n';
              goto LAB_0809121f;
            }
            if (cVar3 != '\0') {
              pcVar10 = temp + iVar11;
              pcVar4 = inputline + iVar9 + 1;
              do {
                iVar9 = iVar9 + 1;
                *pcVar10 = cVar3;
                cVar3 = *pcVar4;
                iVar11 = iVar11 + 1;
                if ((cVar3 == '\t') || (cVar3 == ' ')) goto LAB_08091213;
                if (cVar3 == '\n') goto LAB_08091358;
                pcVar10 = pcVar10 + 1;
                pcVar4 = pcVar4 + 1;
              } while (cVar3 != '\0');
            }
            temp[iVar11] = '\0';
          }
          if (local_230 == 0) {
            local_234 = GetLibraryMenuMemory(&PCB->NetlistLib);
            pcVar4 = MyStrdup(temp,"ReadNetlist()");
            local_234->flag = '\x01';
            local_230 = 1;
            local_234->Name = pcVar4;
            goto LAB_08091160;
          }
          if ((local_230 == 1) && (pcVar4 = strchr(temp,0x2d), pcVar4 == (char *)0x0))
          goto LAB_080913b6;
          paVar7 = GetLibraryEntryMemory(local_234);
          pcVar4 = MyStrdup(temp,"ReadNetlist()");
          paVar7->ListEntry = pcVar4;
          cVar3 = inputline[iVar9];
          if (cVar3 == '\0') break;
        } while( true );
      }
      iVar9 = 0;
      if (cVar1 == '\\') {
        iVar9 = local_230;
      }
      local_238 = local_238 + 1;
      local_230 = iVar9;
    }
    if (local_238 == 0) {
      Message("Empty netlist file!\n");
      pclose(local_23c);
      iVar9 = 1;
    }
    else {
      if (bVar2) {
        pclose(local_23c);
      }
      else {
        fclose(local_23c);
      }
      netlist_sort_offset = 2;
      sort_library(&PCB->NetlistLib);
      iVar9 = 0;
      netlist_sort_offset = 0;
    }
  }
  else {
    SaveFree(ReadNetlist::command);
    ReadNetlist::command = (char *)0x0;
    ReadNetlist::command =
         EvaluateFilename(Settings.RatCommand,Settings.RatPath,filename,(char *)0x0);
    if (*ReadNetlist::command != '\0') {
      local_23c = popen(ReadNetlist::command,"r");
      bVar2 = true;
      if (local_23c != (FILE *)0x0) goto LAB_080910ae;
    }
    PopenErrorMessage(ReadNetlist::command);
    iVar9 = 1;
  }
LAB_0809142d:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar9;
LAB_080913b6:
  pcVar4 = MyStrdup(temp,"ReadNetlist()");
  local_230 = 2;
  local_234->Style = pcVar4;
  goto LAB_08091160;
}



// WARNING: Unknown calling convention

int ImportNetlist(char *filename)

{
  FILE *__stream;
  FILE *fp;
  size_t sVar1;
  __int32_t **pp_Var2;
  int iVar3;
  int __res;
  char *p;
  char *pcVar4;
  int in_GS_OFFSET;
  char buf [16];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if ((filename == (char *)0x0) || (__stream = fopen(filename,"r"), __stream == (FILE *)0x0)) {
    iVar3 = 1;
  }
  else {
    sVar1 = fread(buf,1,0xf,__stream);
    fclose(__stream);
    buf[sVar1] = '\0';
    pcVar4 = buf;
    while (buf[0] != '\0') {
      if ((int)buf[0] + 0x80U < 0x180) {
        pp_Var2 = __ctype_tolower_loc();
        buf[0] = (char)(*pp_Var2)[buf[0]];
      }
      *pcVar4 = buf[0];
      pcVar4 = pcVar4 + 1;
      buf[0] = *pcVar4;
    }
    pcVar4 = strstr(buf,"edif");
    if (pcVar4 == (char *)0x0) {
      iVar3 = ReadNetlist(filename);
    }
    else {
      Message("Importing edif netlist %s\n",filename);
      ParseEDIF(filename,(FILE *)0x0);
      iVar3 = 0;
    }
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int string_cmp(char *a,char *b)

{
  byte bVar1;
  ushort **ppuVar2;
  __int32_t **pp_Var3;
  __int32_t _Var4;
  long lVar5;
  long lVar6;
  int ib;
  int __res_3;
  char cVar7;
  int __res_1;
  int iVar8;
  char cVar9;
  int __res;
  int __res_2;
  char *pcVar11;
  ushort *puVar12;
  int ia;
  __int32_t local_20;
  __int32_t _Var10;
  
  cVar9 = *a;
  if (cVar9 != '\0') {
    cVar7 = *b;
    if (cVar7 != '\0') {
      ppuVar2 = __ctype_b_loc();
      puVar12 = *ppuVar2;
      do {
        _Var10 = (__int32_t)cVar9;
        iVar8 = (int)cVar7;
        if (((*(byte *)((int)puVar12 + _Var10 * 2 + 1) & 8) == 0) ||
           ((*(byte *)((int)puVar12 + iVar8 * 2 + 1) & 8) == 0)) {
          local_20 = _Var10;
          if (_Var10 + 0x80U < 0x180) {
            pp_Var3 = __ctype_tolower_loc();
            local_20 = (*pp_Var3)[_Var10];
          }
          _Var4 = iVar8;
          if (iVar8 + 0x80U < 0x180) {
            pp_Var3 = __ctype_tolower_loc();
            _Var4 = (*pp_Var3)[iVar8];
          }
          if (local_20 != _Var4) {
            if (_Var10 + 0x80U < 0x180) {
              pp_Var3 = __ctype_tolower_loc();
              _Var10 = (*pp_Var3)[_Var10];
            }
            if (iVar8 + 0x80U < 0x180) {
              pp_Var3 = __ctype_tolower_loc();
              iVar8 = (*pp_Var3)[iVar8];
            }
            return _Var10 - iVar8;
          }
LAB_080916cf:
          a = a + 1;
          b = b + 1;
          cVar9 = *a;
        }
        else {
          lVar5 = strtol(a,(char **)0x0,10);
          lVar6 = strtol(b,(char **)0x0,10);
          if (lVar5 != lVar6) {
            return lVar5 - lVar6;
          }
          puVar12 = *ppuVar2;
          bVar1 = *(byte *)((int)puVar12 + *a * 2 + 1);
          while ((bVar1 & 8) != 0) {
            a = a + 1;
            bVar1 = *(byte *)((int)puVar12 + *a * 2 + 1);
          }
          if ((*(byte *)((int)puVar12 + *b * 2 + 1) & 8) == 0) goto LAB_080916cf;
          do {
            pcVar11 = b;
            b = pcVar11 + 1;
          } while ((*(byte *)((int)puVar12 + *b * 2 + 1) & 8) != 0);
          a = a + 1;
          b = pcVar11 + 2;
          cVar9 = *a;
        }
        if (cVar9 == '\0') goto LAB_08091790;
        cVar7 = *b;
      } while (cVar7 != '\0');
    }
    return 1;
  }
LAB_08091790:
  return ~-(uint)(*b == '\0');
}



// WARNING: Unknown calling convention

int netnode_sort(void *va,void *vb)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = string_cmp(*va,*vb);
  return iVar1;
}



// WARNING: Unknown calling convention

int netlist_sort(void *va,void *vb)

{
  char *a;
  int iVar1;
  char *b;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = string_cmp(*va + (**va == '~'),*vb + (**vb == '~'));
  return iVar1;
}



// WARNING: Unknown calling convention

void RemoveTMPData(void)

{
  unlink(TMPFilename);
  return;
}



// WARNING: Unknown calling convention

FILE * CheckAndOpenFile(char *Filename,Boolean Confirm,Boolean AllButton,Boolean *WasAllButton,
                       Boolean *WasCancelButton)

{
  int iVar1;
  FILE *fp;
  int iVar2;
  int response;
  int in_GS_OFFSET;
  stat buffer;
  char message [4176];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((Filename == (char *)0x0) || (*Filename == '\0')) {
    fp = (FILE *)0x0;
  }
  else {
    iVar2 = __xstat(3,Filename,(stat *)&buffer);
    if ((iVar2 == 0) && (Confirm != '\0')) {
      __sprintf_chk(message,1,0x1050,"File \'%s\' exists, use anyway?",Filename);
      if (WasAllButton != (Boolean *)0x0) {
        *WasAllButton = '\0';
      }
      if (WasCancelButton != (Boolean *)0x0) {
        *WasCancelButton = '\0';
      }
      iVar2 = (*gui->confirm_dialog)(message,"Cancel",&DAT_08147319,"Sequence OK");
      if (iVar2 == 0) {
        if (WasCancelButton != (Boolean *)0x0) {
          *WasCancelButton = '\x01';
        }
      }
      else if ((iVar2 == 2) && (WasAllButton != (Boolean *)0x0)) {
        *WasAllButton = '\x01';
      }
    }
    fp = (FILE *)fopen(Filename,"w");
    if (fp == (FILE *)0x0) {
      OpenErrorMessage(Filename);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return fp;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

FILE * OpenConnectionDataFile(void)

{
  char *Filename;
  char *fname;
  FILE *pFVar1;
  FILE *fp;
  Boolean result;
  
  pFVar1 = (FILE *)0x0;
  Filename = (*gui->fileselect)("Save Connection Data As ...",
                                "Choose a file to save all connection data to.",
                                OpenConnectionDataFile::default_file,".net","connection_data",0);
  if (Filename != (char *)0x0) {
    if (OpenConnectionDataFile::default_file != (char *)0x0) {
      free(OpenConnectionDataFile::default_file);
      OpenConnectionDataFile::default_file = (char *)0x0;
    }
    if (*Filename != '\0') {
      OpenConnectionDataFile::default_file = (char *)__strdup(Filename);
    }
    pFVar1 = CheckAndOpenFile(Filename,'\x01','\0',&result,(Boolean *)0x0);
    free(Filename);
  }
  return pFVar1;
}



// WARNING: Unknown calling convention

void WritePCBInfoHeader(FILE *FP)

{
  int iVar1;
  time_t currenttime;
  tm *__tp;
  char *pcVar2;
  __uid_t __uid;
  passwd *ppVar3;
  passwd *pwentry;
  int iVar4;
  char *__name;
  int in_GS_OFFSET;
  time_t local_114;
  char hostname [256];
  
  __name = hostname;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_114 = time((time_t *)0x0);
  __fprintf_chk(FP,1,"# release: %s 20091103\n",Progname);
  __tp = localtime(&local_114);
  pcVar2 = asctime(__tp);
  __fprintf_chk(FP,1,"# date:    %s",pcVar2);
  __uid = getuid();
  ppVar3 = getpwuid(__uid);
  pcVar2 = ppVar3->pw_gecos;
  __fprintf_chk(FP,1,"# user:    %s (%s)\n",ppVar3->pw_name,pcVar2);
  iVar4 = gethostname(__name,0xff);
  if (iVar4 != -1) {
    if ((WritePCBInfoHeader::hostentry != (hostent *)0x0) ||
       (WritePCBInfoHeader::hostentry = (hostent *)gethostbyname(__name),
       WritePCBInfoHeader::hostentry != (hostent *)0x0)) {
      __name = WritePCBInfoHeader::hostentry->h_name;
    }
    __fprintf_chk(FP,1,"# host:    %s\n",__name,pcVar2);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void PrintQuotedString(FILE *FP,char *S)

{
  CreateQuotedString(&PrintQuotedString::ds,S);
  fputs(PrintQuotedString::ds.Data,(FILE *)FP);
  return;
}



// WARNING: Unknown calling convention

void WriteViaData(FILE *FP,DataTypePtr Data)

{
  PinTypePtr paVar1;
  char *pcVar2;
  PinTypePtr via;
  int n;
  uint uVar3;
  uint uVar4;
  LocationType LVar5;
  BDimension BVar6;
  BDimension BVar7;
  BDimension BVar8;
  BDimension BVar9;
  
  if (Data->ViaN != 0) {
    uVar3 = 0;
    do {
      paVar1 = Data->Via;
      BVar9 = paVar1[uVar3].DrillingHole;
      BVar8 = paVar1[uVar3].Mask;
      BVar7 = paVar1[uVar3].Clearance;
      BVar6 = paVar1[uVar3].Thickness;
      LVar5 = paVar1[uVar3].Y;
      __fprintf_chk(FP,1,"Via[%i %i %i %i %i %i ",paVar1[uVar3].X,LVar5,BVar6,BVar7,BVar8,BVar9);
      pcVar2 = paVar1[uVar3].Name;
      if (pcVar2 == (char *)0x0) {
        pcVar2 = "";
      }
      PrintQuotedString(FP,pcVar2);
      uVar4 = uVar3 + 1;
      pcVar2 = flags_to_string(paVar1[uVar3].Flags,1);
      __fprintf_chk(FP,1," %s]\n",pcVar2,LVar5,BVar6,BVar7,BVar8,BVar9);
      uVar3 = uVar4;
    } while (uVar4 <= Data->ViaN && Data->ViaN != uVar4);
  }
  return;
}



// WARNING: Unknown calling convention

void WriteLayerData(FILE *FP,Cardinal Number,LayerTypePtr layer)

{
  LineTypePtr pLVar1;
  ArcTypePtr paVar2;
  TextTypePtr pTVar3;
  PolygonTypePtr ppVar4;
  AttributeType *pAVar5;
  char *pcVar6;
  int i;
  int iVar7;
  int iVar8;
  LineTypePtr line;
  ArcTypePtr arc;
  TextTypePtr text;
  int p;
  uint uVar9;
  int n;
  uint uVar10;
  uint uVar11;
  PointTypePtr point;
  PointTypePtr pPVar12;
  PolygonTypePtr polygon;
  LocationType LVar13;
  BDimension BVar14;
  uint local_28;
  
  if ((((layer->LineN != 0) || (layer->ArcN != 0)) || (layer->TextN != 0)) ||
     ((layer->PolygonN != 0 || ((layer->Name != (char *)0x0 && (*layer->Name != '\0')))))) {
    __fprintf_chk(FP,1,"Layer(%i ",Number + 1);
    pcVar6 = layer->Name;
    if (pcVar6 == (char *)0x0) {
      pcVar6 = "";
    }
    PrintQuotedString(FP,pcVar6);
    fwrite(")\n(\n",1,4,(FILE *)FP);
    if (0 < (layer->Attributes).Number) {
      iVar7 = 0;
      do {
        iVar8 = iVar7 + 1;
        pAVar5 = (layer->Attributes).List + iVar7;
        __fprintf_chk(FP,1,"%sAttribute(\"%s\" \"%s\")\n",&DAT_0814741a,pAVar5->name,pAVar5->value);
        iVar7 = iVar8;
      } while (iVar8 < (layer->Attributes).Number);
    }
    if (layer->LineN != 0) {
      uVar9 = 0;
      do {
        uVar10 = uVar9 + 1;
        pLVar1 = layer->Line;
        pcVar6 = flags_to_string(pLVar1[uVar9].Flags,4);
        __fprintf_chk(FP,1,"\tLine[%i %i %i %i %i %i %s]\n",pLVar1[uVar9].Point1.X,
                      pLVar1[uVar9].Point1.Y,pLVar1[uVar9].Point2.X,pLVar1[uVar9].Point2.Y,
                      pLVar1[uVar9].Thickness,pLVar1[uVar9].Clearance,pcVar6);
        uVar9 = uVar10;
      } while (uVar10 <= layer->LineN && layer->LineN != uVar10);
    }
    if (layer->ArcN != 0) {
      uVar9 = 0;
      do {
        uVar10 = uVar9 + 1;
        paVar2 = layer->Arc;
        pcVar6 = flags_to_string(paVar2[uVar9].Flags,0x4000);
        __fprintf_chk(FP,1,"\tArc[%i %i %i %i %i %i %i %i %s]\n",paVar2[uVar9].X,paVar2[uVar9].Y,
                      paVar2[uVar9].Width,paVar2[uVar9].Height,paVar2[uVar9].Thickness,
                      paVar2[uVar9].Clearance,paVar2[uVar9].StartAngle,paVar2[uVar9].Delta,pcVar6);
        uVar9 = uVar10;
      } while (uVar10 <= layer->ArcN && layer->ArcN != uVar10);
    }
    if (layer->TextN != 0) {
      uVar9 = 0;
      do {
        pTVar3 = layer->Text;
        BVar14 = pTVar3[uVar9].Scale;
        uVar10 = (uint)pTVar3[uVar9].Direction;
        LVar13 = pTVar3[uVar9].Y;
        __fprintf_chk(FP,1,"\tText[%i %i %i %i ",pTVar3[uVar9].X,LVar13,uVar10,BVar14);
        pcVar6 = pTVar3[uVar9].TextString;
        if (pcVar6 == (char *)0x0) {
          pcVar6 = "";
        }
        uVar11 = uVar9 + 1;
        PrintQuotedString(FP,pcVar6);
        pcVar6 = flags_to_string(pTVar3[uVar9].Flags,0x10);
        __fprintf_chk(FP,1," %s]\n",pcVar6,LVar13,uVar10,BVar14);
        uVar9 = uVar11;
      } while (uVar11 <= layer->TextN && layer->TextN != uVar11);
    }
    if (layer->PolygonN != 0) {
      local_28 = 0;
      do {
        ppVar4 = layer->Polygon;
        pcVar6 = flags_to_string(ppVar4[local_28].Flags,8);
        __fprintf_chk(FP,1,"\tPolygon(%s)\n\t(",pcVar6);
        if (ppVar4[local_28].PointN != 0) {
          uVar9 = 0;
          do {
            pPVar12 = ppVar4[local_28].Points + uVar9;
            if (uVar9 == ((int)uVar9 / 5) * 5) {
              fwrite(&DAT_08147418,1,3,(FILE *)FP);
            }
            uVar9 = uVar9 + 1;
            __fprintf_chk(FP,1,"[%i %i] ",pPVar12->X,pPVar12->Y);
          } while (uVar9 <= ppVar4[local_28].PointN && ppVar4[local_28].PointN != uVar9);
        }
        fwrite(&DAT_0814740a,1,4,(FILE *)FP);
        local_28 = local_28 + 1;
      } while (local_28 <= layer->PolygonN && layer->PolygonN != local_28);
    }
    fwrite(&DAT_0814740c,1,2,(FILE *)FP);
  }
  return;
}



// WARNING: Unknown calling convention

void WriteElementData(FILE *FP,DataTypePtr Data)

{
  ElementTypePtr paVar1;
  PinTypePtr paVar2;
  PadTypePtr paVar3;
  LineTypePtr pLVar4;
  ArcTypePtr paVar5;
  char *pcVar6;
  uint uVar7;
  int iVar8;
  AttributeType *pAVar9;
  int iVar10;
  int iVar11;
  LineTypePtr line;
  ArcTypePtr arc;
  char *pcVar12;
  ElementTypePtr element;
  int p;
  int i;
  int iVar13;
  PinTypePtr pin;
  PadTypePtr pad;
  uint uVar14;
  BDimension BVar15;
  BDimension BVar16;
  BDimension BVar17;
  BDimension BVar18;
  uint local_24;
  
  if (Data->ElementN != 0) {
    local_24 = 0;
    do {
      paVar1 = Data->Element;
      if ((((paVar1[local_24].LineN != 0) || (paVar1[local_24].PinN != 0)) ||
          (paVar1[local_24].ArcN != 0)) || (paVar1[local_24].PadN != 0)) {
        pcVar6 = flags_to_string(paVar1[local_24].Flags,2);
        __fprintf_chk(FP,1,"\nElement[%s ",pcVar6);
        pcVar6 = paVar1[local_24].Name[0].TextString;
        if (pcVar6 == (char *)0x0) {
          pcVar6 = "";
        }
        PrintQuotedString(FP,pcVar6);
        fputc(0x20,(FILE *)FP);
        pcVar6 = paVar1[local_24].Name[1].TextString;
        if (pcVar6 == (char *)0x0) {
          pcVar6 = "";
        }
        PrintQuotedString(FP,pcVar6);
        fputc(0x20,(FILE *)FP);
        pcVar6 = paVar1[local_24].Name[2].TextString;
        if (pcVar6 == (char *)0x0) {
          pcVar6 = "";
        }
        PrintQuotedString(FP,pcVar6);
        pcVar6 = flags_to_string(paVar1[local_24].Name[0].Flags,0x400);
        BVar18 = paVar1[local_24].Name[0].Scale;
        uVar7 = (uint)paVar1[local_24].Name[0].Direction;
        iVar8 = paVar1[local_24].Name[0].Y - paVar1[local_24].MarkY;
        __fprintf_chk(FP,1," %i %i %i %i %i %i %s]\n(\n",paVar1[local_24].MarkX,
                      paVar1[local_24].MarkY,paVar1[local_24].Name[0].X - paVar1[local_24].MarkX,
                      iVar8,uVar7,BVar18,pcVar6);
        if (0 < paVar1[local_24].Attributes.Number) {
          i = 0;
          do {
            iVar13 = i + 1;
            pAVar9 = paVar1[local_24].Attributes.List + i;
            __fprintf_chk(FP,1,"%sAttribute(\"%s\" \"%s\")\n",&DAT_0814741a,pAVar9->name,
                          pAVar9->value,iVar8,uVar7,BVar18,pcVar6);
            i = iVar13;
          } while (iVar13 < paVar1[local_24].Attributes.Number);
        }
        if (paVar1[local_24].PinN != 0) {
          uVar7 = 0;
          do {
            paVar2 = paVar1[local_24].Pin;
            BVar18 = paVar2[uVar7].DrillingHole;
            BVar17 = paVar2[uVar7].Mask;
            BVar16 = paVar2[uVar7].Clearance;
            BVar15 = paVar2[uVar7].Thickness;
            iVar8 = paVar2[uVar7].Y - paVar1[local_24].MarkY;
            iVar13 = paVar2[uVar7].X - paVar1[local_24].MarkX;
            __fprintf_chk(FP,1,"\tPin[%i %i %i %i %i %i ",iVar13,iVar8,BVar15,BVar16,BVar17,BVar18,
                          pcVar6);
            pcVar12 = paVar2[uVar7].Name;
            if (pcVar12 == (char *)0x0) {
              pcVar12 = "";
            }
            PrintQuotedString(FP,pcVar12);
            __fprintf_chk(FP,1,&DAT_08156730,iVar13,iVar8,BVar15,BVar16,BVar17,BVar18);
            pcVar12 = paVar2[uVar7].Number;
            if (pcVar12 == (char *)0x0) {
              pcVar12 = "";
            }
            PrintQuotedString(FP,pcVar12);
            pcVar12 = flags_to_string(paVar2[uVar7].Flags,0x100);
            __fprintf_chk(FP,1," %s]\n",pcVar12);
            uVar7 = uVar7 + 1;
          } while (uVar7 <= paVar1[local_24].PinN && paVar1[local_24].PinN != uVar7);
        }
        if (paVar1[local_24].PadN != 0) {
          uVar7 = 0;
          do {
            paVar3 = paVar1[local_24].Pad;
            BVar18 = paVar3[uVar7].Mask;
            BVar17 = paVar3[uVar7].Clearance;
            BVar16 = paVar3[uVar7].Thickness;
            iVar8 = paVar3[uVar7].Point2.Y - paVar1[local_24].MarkY;
            iVar13 = paVar3[uVar7].Point2.X - paVar1[local_24].MarkX;
            iVar10 = paVar3[uVar7].Point1.Y - paVar1[local_24].MarkY;
            iVar11 = paVar3[uVar7].Point1.X - paVar1[local_24].MarkX;
            __fprintf_chk(FP,1,"\tPad[%i %i %i %i %i %i %i ",iVar11,iVar10,iVar13,iVar8,BVar16,
                          BVar17,BVar18);
            pcVar6 = paVar3[uVar7].Name;
            if (pcVar6 == (char *)0x0) {
              pcVar6 = "";
            }
            PrintQuotedString(FP,pcVar6);
            __fprintf_chk(FP,1,&DAT_08156730,iVar11,iVar10,iVar13,iVar8,BVar16,BVar17,BVar18);
            pcVar6 = paVar3[uVar7].Number;
            if (pcVar6 == (char *)0x0) {
              pcVar6 = "";
            }
            PrintQuotedString(FP,pcVar6);
            pcVar6 = flags_to_string(paVar3[uVar7].Flags,0x200);
            __fprintf_chk(FP,1," %s]\n",pcVar6);
            uVar7 = uVar7 + 1;
          } while (uVar7 <= paVar1[local_24].PadN && paVar1[local_24].PadN != uVar7);
        }
        if (paVar1[local_24].LineN != 0) {
          uVar7 = 0;
          do {
            uVar14 = uVar7 + 1;
            pLVar4 = paVar1[local_24].Line;
            __fprintf_chk(FP,1,"\tElementLine [%i %i %i %i %i]\n",
                          pLVar4[uVar7].Point1.X - paVar1[local_24].MarkX,
                          pLVar4[uVar7].Point1.Y - paVar1[local_24].MarkY,
                          pLVar4[uVar7].Point2.X - paVar1[local_24].MarkX,
                          pLVar4[uVar7].Point2.Y - paVar1[local_24].MarkY,pLVar4[uVar7].Thickness);
            uVar7 = uVar14;
          } while (uVar14 <= paVar1[local_24].LineN && paVar1[local_24].LineN != uVar14);
        }
        if (paVar1[local_24].ArcN != 0) {
          uVar7 = 0;
          do {
            uVar14 = uVar7 + 1;
            paVar5 = paVar1[local_24].Arc;
            __fprintf_chk(FP,1,"\tElementArc [%i %i %i %i %i %i %i]\n",
                          paVar5[uVar7].X - paVar1[local_24].MarkX,
                          paVar5[uVar7].Y - paVar1[local_24].MarkY,paVar5[uVar7].Width,
                          paVar5[uVar7].Height,paVar5[uVar7].StartAngle,paVar5[uVar7].Delta,
                          paVar5[uVar7].Thickness);
            uVar7 = uVar14;
          } while (uVar14 <= paVar1[local_24].ArcN && paVar1[local_24].ArcN != uVar14);
        }
        fwrite(&DAT_0814740a,1,4,(FILE *)FP);
      }
      local_24 = local_24 + 1;
    } while (local_24 <= Data->ElementN && Data->ElementN != local_24);
  }
  return;
}



// WARNING: Unknown calling convention

int WritePCB(FILE *FP)

{
  int iVar1;
  RatTypePtr paVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  int iVar5;
  ushort **ppuVar6;
  AttributeType *pAVar7;
  DataTypePtr paVar8;
  Cardinal i_1;
  char *pcVar9;
  LibraryEntryTypePtr entry;
  LineTypePtr line;
  LineTypePtr pLVar10;
  int i_2;
  int iVar11;
  RatTypePtr line_1;
  Cardinal i;
  Cardinal Number;
  int p;
  uint uVar12;
  int n;
  uint uVar13;
  LibraryMenuTypePtr menu;
  int iVar14;
  FILE *pFVar15;
  int local_4c;
  PCBTypePtr local_48;
  int local_38;
  int local_34;
  int local_30;
  Cardinal local_2c;
  uint local_28;
  
  WritePCBInfoHeader(FP);
  __fprintf_chk(FP,1,
                "\n# To read pcb files, the pcb version (or the cvs source date) must be >= the file version\n"
               );
  __fprintf_chk(FP,1,"FileVersion[%i]\n",0x1324007);
  fwrite(&DAT_08147487,1,5,(FILE *)FP);
  pcVar9 = PCB->Name;
  if (pcVar9 == (char *)0x0) {
    pcVar9 = "";
  }
  PrintQuotedString(FP,pcVar9);
  __fprintf_chk(FP,1," %i %i]\n\n",PCB->MaxWidth,PCB->MaxHeight);
  iVar14 = (int)Settings.DrawGrid;
  iVar5 = PCB->GridOffsetY;
  iVar11 = PCB->GridOffsetX;
  pcVar9 = c_dtostr(PCB->Grid);
  __fprintf_chk(FP,1,"Grid[%s %i %i %i]\n",pcVar9,iVar11,iVar5,iVar14);
  pcVar9 = c_dtostr(PCB->Zoom);
  if (Settings.ShowSolderSide == '\0') {
    iVar5 = (int)ROUND((double)(Output.Height / 2) / Zoom_Multiplier) + Yorig;
  }
  else {
    iVar5 = (PCB->MaxHeight - (int)ROUND((double)(Output.Height / 2) / Zoom_Multiplier)) - Yorig;
  }
  __fprintf_chk(FP,1,"Cursor[%i %i %s]\n",
                (int)ROUND((double)(Output.Width / 2) / Zoom_Multiplier) + Xorig,iVar5,pcVar9,iVar14
               );
  pcVar9 = c_dtostr(PCB->IsleArea);
  __fprintf_chk(FP,1,"PolyArea[%s]\n",pcVar9);
  pcVar9 = c_dtostr(PCB->ThermScale);
  __fprintf_chk(FP,1,"Thermal[%s]\n",pcVar9);
  __fprintf_chk(FP,1,"DRC[%i %i %i %i %i %i]\n",PCB->Bloat,PCB->Shrink,PCB->minWid,PCB->minSlk,
                PCB->minDrill,PCB->minRing);
  pcVar9 = pcbflags_to_string(PCB->Flags);
  __fprintf_chk(FP,1,"Flags(%s)\n",pcVar9);
  pcVar9 = LayerGroupsToString(&PCB->LayerGroups);
  __fprintf_chk(FP,1,"Groups(\"%s\")\n",pcVar9);
  fwrite("Styles[\"",1,8,(FILE *)FP);
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i:",PCB->RouteStyle[0].Name,PCB->RouteStyle[0].Thick,
                PCB->RouteStyle[0].Diameter,PCB->RouteStyle[0].Hole,PCB->RouteStyle[0].Keepaway);
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i:",PCB->RouteStyle[1].Name,PCB->RouteStyle[1].Thick,
                PCB->RouteStyle[1].Diameter,PCB->RouteStyle[1].Hole,PCB->RouteStyle[1].Keepaway);
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i:",PCB->RouteStyle[2].Name,PCB->RouteStyle[2].Thick,
                PCB->RouteStyle[2].Diameter,PCB->RouteStyle[2].Hole,PCB->RouteStyle[2].Keepaway);
  local_38 = PCB->RouteStyle[3].Keepaway;
  local_34 = PCB->RouteStyle[3].Hole;
  local_30 = PCB->RouteStyle[3].Diameter;
  pFVar15 = (FILE *)PCB->RouteStyle[3].Name;
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i\"]\n\n",pFVar15,PCB->RouteStyle[3].Thick,local_30,local_34,
                local_38);
  local_4c = 0;
  local_48 = PCB;
  do {
    if ((local_48->Font).Symbol[0].Valid != '\0') {
      ppuVar6 = __ctype_b_loc();
      if ((*(byte *)((int)*ppuVar6 + local_4c * 2 + 1) & 0x40) == 0) {
        __fprintf_chk(FP,1,"Symbol[%i %i]\n(\n",local_4c,(local_48->Font).Symbol[0].Delta,local_30,
                      local_34,local_38);
      }
      else {
        iVar5 = (local_48->Font).Symbol[0].Delta;
        if (iVar5 == (iVar5 / 100) * 100) {
          __fprintf_chk(FP,1,"Symbol(\'%c\' %i)\n(\n",(int)(char)local_4c,iVar5 / 100,local_30,
                        local_34,local_38);
        }
        else {
          __fprintf_chk(FP,1,"Symbol[\'%c\' %i]\n(\n",(int)(char)local_4c,iVar5,local_30,local_34,
                        local_38);
        }
      }
      local_2c = (local_48->Font).Symbol[0].LineN;
      pLVar10 = (local_48->Font).Symbol[0].Line;
      if (local_2c != 0) {
        do {
          iVar5 = (pLVar10->Point1).X;
          if (iVar5 == (iVar5 / 100) * 100) {
            iVar11 = (pLVar10->Point1).Y;
            if (iVar11 != (iVar11 / 100) * 100) {
              iVar3 = pLVar10->Thickness;
              iVar1 = (pLVar10->Point2).Y;
              iVar14 = (pLVar10->Point2).X;
              goto LAB_08092b22;
            }
            iVar14 = (pLVar10->Point2).X;
            local_30 = iVar14 / 100;
            if (iVar14 != local_30 * 100) goto LAB_08092c09;
            iVar1 = (pLVar10->Point2).Y;
            local_34 = iVar1 / 100;
            if (iVar1 != local_34 * 100) {
              iVar3 = pLVar10->Thickness;
              goto LAB_08092b22;
            }
            iVar3 = pLVar10->Thickness;
            local_38 = iVar3 / 100;
            if (iVar3 != local_38 * 100) goto LAB_08092b22;
            __fprintf_chk(FP,1,"\tSymbolLine(%i %i %i %i %i)\n",iVar5 / 100,iVar11 / 100,local_30,
                          local_34,local_38);
          }
          else {
            iVar11 = (pLVar10->Point1).Y;
            iVar14 = (pLVar10->Point2).X;
LAB_08092c09:
            local_30 = iVar14;
            iVar3 = pLVar10->Thickness;
            iVar1 = (pLVar10->Point2).Y;
            iVar14 = local_30;
LAB_08092b22:
            local_30 = iVar14;
            local_34 = iVar1;
            local_38 = iVar3;
            __fprintf_chk(FP,1,"\tSymbolLine[%i %i %i %i %i]\n",iVar5,iVar11,local_30,local_34,
                          local_38);
          }
          local_2c = local_2c - 1;
          if (local_2c == 0) break;
          pLVar10 = pLVar10 + 1;
        } while( true );
      }
      pFVar15 = FP;
      fwrite(&DAT_0814740c,1,2,(FILE *)FP);
    }
    pPVar4 = PCB;
    local_4c = local_4c + 1;
    local_48 = (PCBTypePtr)&local_48->Netlistname;
    if (local_4c == 0x100) {
      if (0 < (PCB->Attributes).Number) {
        iVar5 = 0;
        do {
          iVar11 = iVar5 + 1;
          pAVar7 = (pPVar4->Attributes).List + iVar5;
          pFVar15 = (FILE *)&DAT_0814741b;
          __fprintf_chk(FP,1,"%sAttribute(\"%s\" \"%s\")\n",&DAT_0814741b,pAVar7->name,pAVar7->value
                        ,local_34,local_38);
          iVar5 = iVar11;
        } while (iVar11 < (pPVar4->Attributes).Number);
      }
      WriteViaData(FP,PCB->Data);
      WriteElementData(FP,PCB->Data);
      paVar8 = PCB->Data;
      if (paVar8->RatN != 0) {
        n = 0;
        do {
          uVar13 = n + 1;
          paVar2 = paVar8->Rat;
          __fprintf_chk(FP,1,"Rat[%i %i %i %i %i %i ",paVar2[n].Point1.X,paVar2[n].Point1.Y,
                        paVar2[n].group1,paVar2[n].Point2.X,paVar2[n].Point2.Y,paVar2[n].group2);
          pFVar15 = (FILE *)flags_to_string(paVar2[n].Flags,0x20);
          __fprintf_chk(FP,1," %s]\n",pFVar15);
          paVar8 = PCB->Data;
          n = uVar13;
        } while (uVar13 < paVar8->RatN);
      }
      if (paVar8->LayerN != -2) {
        Number = 0;
        do {
          uVar13 = Number + 1;
          WriteLayerData(FP,Number,paVar8->Layer + Number);
          paVar8 = PCB->Data;
          Number = uVar13;
        } while (uVar13 < paVar8->LayerN + 2U);
      }
      if ((PCB->NetlistLib).MenuN != 0) {
        __fprintf_chk(FP,1,"NetList()\n(\n",pFVar15);
        if ((PCB->NetlistLib).MenuN != 0) {
          local_28 = 0;
          do {
            menu = (PCB->NetlistLib).Menu + local_28;
            __fprintf_chk(FP,1,"\tNet(");
            PrintQuotedString(FP,menu->Name + 2);
            __fprintf_chk(FP,1,&DAT_08156730);
            pcVar9 = menu->Style;
            if (pcVar9 == (char *)0x0) {
              pcVar9 = "(unknown)";
            }
            else if (*pcVar9 == '\0') {
              pcVar9 = "(unknown)";
            }
            PrintQuotedString(FP,pcVar9);
            __fprintf_chk(FP,1,")\n\t(\n");
            if (menu->EntryN != 0) {
              uVar13 = 0;
              do {
                uVar12 = uVar13 + 1;
                entry = menu->Entry + uVar13;
                __fprintf_chk(FP,1,"\t\tConnect(");
                PrintQuotedString(FP,entry->ListEntry);
                __fprintf_chk(FP,1,&DAT_0814740c);
                uVar13 = uVar12;
              } while (uVar12 < menu->EntryN);
            }
            __fprintf_chk(FP,1,&DAT_0814740b);
            local_28 = local_28 + 1;
          } while (local_28 < (PCB->NetlistLib).MenuN);
        }
        __fprintf_chk(FP,1,&DAT_0814740c);
      }
      return 0;
    }
  } while( true );
}



// WARNING: Unknown calling convention

int WritePCBFile(char *Filename)

{
  FILE *FP;
  FILE *fp;
  int iVar1;
  int result;
  
  FP = fopen(Filename,"w");
  if (FP == (FILE *)0x0) {
    iVar1 = -1;
    OpenErrorMessage(Filename);
  }
  else {
    iVar1 = WritePCB((FILE *)FP);
    fclose(FP);
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void SaveTMPData(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  __sprintf_chk(TMPFilename,1,0x50,"PCB.%.8i.save",_Var1);
  WritePCBFile(TMPFilename);
  return;
}



// WARNING: Unknown calling convention

void SaveInTMP(void)

{
  int iVar1;
  __pid_t _Var2;
  int in_GS_OFFSET;
  char filename [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((PCB != (PCBTypePtr)0x0) && (PCB->Changed != '\0')) {
    _Var2 = getpid();
    __sprintf_chk(filename,1,0x50,"PCB.%.8i.save",_Var2);
    Message("Trying to save your layout in \'%s\'\n",filename);
    WritePCBFile(filename);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void EmergencySave(void)

{
  if (dont_save_any_more != '\0') {
    return;
  }
  SaveInTMP();
  dont_save_any_more = '\x01';
  return;
}



// WARNING: Unknown calling convention

void Backup(void)

{
  size_t sVar1;
  char *Filename;
  char *filename;
  __pid_t _Var2;
  
  if ((PCB == (PCBTypePtr)0x0) || (PCB->Filename == (char *)0x0)) {
    Filename = (char *)calloc(1,0x17);
    if (Filename == (char *)0x0) goto LAB_080932a5;
    _Var2 = getpid();
    __sprintf_chk(Filename,1,0x17,"PCB.%.8i.backup",_Var2);
  }
  else {
    sVar1 = strlen(PCB->Filename);
    Filename = (char *)calloc(1,sVar1 + 2);
    if (Filename == (char *)0x0) {
LAB_080932a5:
      __fprintf_chk(stderr,1,"Backup():  malloc failed\n");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    __sprintf_chk(Filename,1,0xffffffff,&DAT_08147608,PCB->Filename);
  }
  WritePCBFile(Filename);
  free(Filename);
  return;
}



// WARNING: Unknown calling convention

void backup_cb(hidval data)

{
  hidval local_10 [2];
  
  backup_timer.lval = 0;
  Backup();
  if ((0 < Settings.BackupInterval) &&
     (gui->add_timer != (_func_hidval__func_void_hidval_ptr_ulong_hidval *)0x0)) {
    (*gui->add_timer)((_func_void_hidval *)local_10,(ulong)backup_cb,
                      (hidval)(Settings.BackupInterval * 1000));
    backup_timer = local_10[0];
  }
  return;
}



// WARNING: Unknown calling convention

void PostLoadElementPCB(void)

{
  ElementTypePtr Element;
  PCBTypePtr pPVar1;
  PCBTypePtr pPVar2;
  PCBTypePtr pcb_save;
  ElementTypePtr e;
  
  pPVar1 = PCB;
  if (yyPCB != (PCBTypePtr)0x0) {
    CreateNewPCBPost(yyPCB,0);
    ParseGroupString("1,c:2,s",&yyPCB->LayerGroups,yyData->LayerN);
    PCB = yyPCB;
    Element = yyPCB->Data->Element;
    MoveElementLowLevel(yyPCB->Data,Element,-(Element->BoundingBox).X1,-(Element->BoundingBox).Y1);
    pPVar2 = yyPCB;
    PCB = pPVar1;
    yyPCB->MaxWidth = (Element->BoundingBox).X2;
    pPVar2->MaxHeight = (Element->BoundingBox).Y2;
  }
  return;
}



// WARNING: Unknown calling convention

int LoadPCB(char *Filename)

{
  int Height;
  PCBTypePtr pPVar1;
  int iVar2;
  char *pcVar3;
  PCBTypePtr newPCB;
  
  pPVar1 = CreateNewPCB('\0');
  iVar2 = ParsePCB(pPVar1,Filename);
  if (iVar2 == 0) {
    RemovePCB(PCB);
    PCB = pPVar1;
    CreateNewPCBPost(pPVar1,0);
    ResetStackAndVisibility();
    iVar2 = PCB->MaxWidth;
    Crosshair.X = iVar2;
    if (PCB->CursorX == iVar2 || PCB->CursorX < iVar2) {
      Crosshair.X = PCB->CursorX;
    }
    if (Crosshair.X < 0) {
      Crosshair.X = 0;
    }
    Height = PCB->MaxHeight;
    Crosshair.Y = PCB->CursorY;
    if (PCB->CursorY != Height && Height <= PCB->CursorY) {
      Crosshair.Y = Height;
    }
    if (Crosshair.Y < 0) {
      Crosshair.Y = 0;
    }
    Xorig = Crosshair.X - (int)ROUND((double)(Output.Width / 2) / Zoom_Multiplier);
    Yorig = Crosshair.Y - (int)ROUND((double)(Output.Height / 2) / Zoom_Multiplier);
    ChangePCBSize(iVar2,Height);
    if ((PCB->Font).Valid == '\0') {
      Message("File \'%s\' has no font information, using default font\n",Filename);
      CreateDefaultFont();
    }
    SetChangedFlag('\0');
    pPVar1 = PCB;
    pcVar3 = MyStrdup(Filename,"LoadPCB()");
    pPVar1->Filename = pcVar3;
    Settings.grid_units_mm = (double)(int)ROUND(PCB->Grid) != PCB->Grid;
    netlist_sort_offset = 2;
    sort_library(&PCB->NetlistLib);
    netlist_sort_offset = 0;
    iVar2 = hid_get_flag("style");
    if (iVar2 == 0) {
      SetLineSize(PCB->RouteStyle[0].Thick);
      SetViaSize(PCB->RouteStyle[0].Diameter,'\x01');
      SetViaDrillingHole(PCB->RouteStyle[0].Hole,'\x01');
      SetKeepawayWidth(PCB->RouteStyle[0].Keepaway);
    }
    hid_action("PCBChanged");
    return 0;
  }
  hid_action("PCBChanged");
  RemovePCB(pPVar1);
  return 1;
}



// WARNING: Unknown calling convention

int WritePipe(char *Filename,Boolean thePcb)

{
  bool bVar1;
  char Char;
  FILE *FP;
  FILE *fp;
  int iVar2;
  int iVar3;
  int result;
  Cardinal i;
  Cardinal Number;
  uint uVar4;
  char *p;
  char *pcVar5;
  int used_popen;
  
  if ((Settings.SaveCommand == (char *)0x0) || (*Settings.SaveCommand == '\0')) {
    FP = fopen(Filename,"w");
    if (FP == (FILE *)0x0) {
      Message("Unable to write to file %s\n",Filename);
      return -1;
    }
    bVar1 = false;
  }
  else {
    DSClearString(&WritePipe::command);
    for (pcVar5 = Settings.SaveCommand; Char = *pcVar5, Char != '\0'; pcVar5 = pcVar5 + 1) {
      while ((Char == '%' && (pcVar5[1] == 'f'))) {
        pcVar5 = pcVar5 + 2;
        DSAddString(&WritePipe::command,Filename);
        Char = *pcVar5;
        if (Char == '\0') goto LAB_080937c0;
      }
      DSAddCharacter(&WritePipe::command,Char);
    }
LAB_080937c0:
    DSAddCharacter(&WritePipe::command,'\0');
    __printf_chk(1,"write to pipe \"%s\"\n",WritePipe::command.Data);
    FP = popen(WritePipe::command.Data,"w");
    if (FP == (FILE *)0x0) {
      PopenErrorMessage(WritePipe::command.Data);
      return -1;
    }
    bVar1 = true;
  }
  if (thePcb == '\0') {
    WriteViaData((FILE *)FP,Buffers[Settings.BufferNumber].Data);
    WriteElementData((FILE *)FP,Buffers[Settings.BufferNumber].Data);
    if (PCB->Data->LayerN != -2) {
      Number = 0;
      do {
        uVar4 = Number + 1;
        WriteLayerData((FILE *)FP,Number,(Buffers[Settings.BufferNumber].Data)->Layer + Number);
        Number = uVar4;
      } while (uVar4 < PCB->Data->LayerN + 2U);
    }
    iVar2 = 0;
  }
  else {
    iVar2 = WritePCB((FILE *)FP);
  }
  if (bVar1) {
    iVar3 = pclose(FP);
  }
  else {
    iVar3 = fclose(FP);
  }
  if (iVar3 == 0) {
    return iVar2;
  }
  return -1;
}



// WARNING: Unknown calling convention

int SavePCB(char *Filename)

{
  int iVar1;
  int retcode;
  char *pcVar2;
  char *copy;
  
  iVar1 = WritePipe(Filename,'\x01');
  if (iVar1 == 0) {
    pcVar2 = MyStrdup(Filename,"SavePCB()");
    SaveFree(PCB->Filename);
    PCB->Filename = pcVar2;
    SetChangedFlag('\0');
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int SaveBufferElements(char *Filename)

{
  int result;
  int iVar1;
  
  if (Settings.ShowSolderSide != '\0') {
    SwapBuffers();
  }
  iVar1 = WritePipe(Filename,'\0');
  if (Settings.ShowSolderSide == '\0') {
    return iVar1;
  }
  SwapBuffers();
  return iVar1;
}



// WARNING: Unknown calling convention

int ParseLibraryTree(void)

{
  char cVar1;
  char *__s;
  char *pcVar2;
  char *p;
  DIR *__dirp;
  dirent *pdVar3;
  int iVar4;
  LibraryMenuTypePtr Menu;
  char *pcVar5;
  DIR *__dirp_00;
  size_t sVar6;
  LibraryEntryTypePtr paVar7;
  char *pcVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  dirent *e2;
  LibraryEntryTypePtr entry;
  dirent *direntry;
  undefined4 *puVar12;
  char *pcVar13;
  int in_GS_OFFSET;
  bool bVar14;
  byte bVar15;
  int local_209c;
  stat buffer;
  char working [4097];
  char path [4097];
  int local_20;
  
  bVar15 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  bVar14 = ((uint)path & 1) != 0;
  uVar11 = 0x1001;
  puVar12 = (undefined4 *)path;
  if (bVar14) {
    path[0] = '\0';
    puVar12 = (undefined4 *)(path + 1);
    uVar11 = 0x1000;
  }
  if (((uint)puVar12 & 2) != 0) {
    *(undefined2 *)puVar12 = 0;
    uVar11 = uVar11 - 2;
    puVar12 = (undefined4 *)((int)puVar12 + 2);
  }
  for (uVar9 = uVar11 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
    *puVar12 = 0;
    puVar12 = puVar12 + 1;
  }
  if ((uVar11 & 2) != 0) {
    *(undefined2 *)puVar12 = 0;
    puVar12 = (undefined4 *)((int)puVar12 + 2);
  }
  if (!bVar14) {
    *(undefined *)puVar12 = 0;
  }
  puVar12 = (undefined4 *)working;
  uVar11 = 0x1001;
  bVar14 = ((uint)puVar12 & 2) != 0;
  if (bVar14) {
    working[0] = '\0';
    working[1] = '\0';
    puVar12 = (undefined4 *)(working + 2);
    uVar11 = 0xfff;
  }
  for (uVar11 = uVar11 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
    *puVar12 = 0;
    puVar12 = puVar12 + 1;
  }
  if (bVar14) {
    *(undefined2 *)puVar12 = 0;
    puVar12 = (undefined4 *)((int)puVar12 + 2);
  }
  *(undefined *)puVar12 = 0;
  GetWorkingDirectory(working);
  __s = MyStrdup(Settings.LibraryTree,"ParseLibraryTree");
  pcVar2 = strtok(__s,":");
  if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
    local_209c = 0;
  }
  else {
    local_209c = 0;
    do {
      strncpy(path,pcVar2,0x1000);
      chdir(working);
      __dirp = opendir(path);
      if (__dirp == (DIR *)0x0) {
        OpendirErrorMessage(path);
      }
      else {
        chdir(path);
        GetWorkingDirectory(path);
        while (pdVar3 = readdir(__dirp), pdVar3 != (dirent *)0x0) {
          pcVar2 = pdVar3->d_name;
          chdir(path);
          iVar4 = __xstat(3,pcVar2,(stat *)&buffer);
          if ((((iVar4 == 0) && ((buffer.st_mode & 0xf000) == 0x4000)) && (pdVar3->d_name[0] != '.')
              ) && (((pdVar3->d_name[0] != 'C' || (pdVar3->d_name[1] != 'V')) ||
                    ((pdVar3->d_name[2] != 'S' || (pdVar3->d_name[3] != '\0')))))) {
            Menu = GetLibraryMenuMemory(&Library);
            pcVar5 = MyStrdup(pcVar2,"ParseLibraryTree()");
            Menu->Name = pcVar5;
            pcVar5 = strrchr(path,0x2f);
            puVar12 = (undefined4 *)(pcVar5 + 1);
            if (pcVar5 == (char *)0x0) {
              puVar12 = (undefined4 *)path;
            }
            pcVar5 = (char *)__strdup(puVar12);
            Menu->directory = pcVar5;
            __dirp_00 = opendir(pcVar2);
            chdir(pcVar2);
            if (__dirp_00 != (DIR *)0x0) {
              while (pdVar3 = readdir(__dirp_00), pdVar3 != (dirent *)0x0) {
                pcVar5 = pdVar3->d_name;
                sVar6 = strlen(pcVar5);
                iVar4 = __xstat(3,pcVar5,(stat *)&buffer);
                if (((iVar4 == 0) && ((buffer.st_mode & 0xf000) == 0x8000)) &&
                   ((pdVar3->d_name[0] != '.' &&
                    ((((bVar14 = pdVar3->d_name[0] == 'C', !bVar14 ||
                       (bVar14 = pdVar3->d_name[1] == 'V', !bVar14)) ||
                      (bVar14 = pdVar3->d_name[2] == 'S', !bVar14)) ||
                     (bVar14 = pdVar3->d_name[3] == '\0', !bVar14)))))) {
                  iVar4 = 9;
                  pcVar8 = pcVar5;
                  pcVar13 = "Makefile";
                  do {
                    if (iVar4 == 0) break;
                    iVar4 = iVar4 + -1;
                    bVar14 = *pcVar8 == *pcVar13;
                    pcVar8 = pcVar8 + (uint)bVar15 * -2 + 1;
                    pcVar13 = pcVar13 + (uint)bVar15 * -2 + 1;
                  } while (bVar14);
                  if (!bVar14) {
                    iVar4 = 0xc;
                    pcVar8 = pcVar5;
                    pcVar13 = "Makefile.am";
                    do {
                      if (iVar4 == 0) break;
                      iVar4 = iVar4 + -1;
                      bVar14 = *pcVar8 == *pcVar13;
                      pcVar8 = pcVar8 + (uint)bVar15 * -2 + 1;
                      pcVar13 = pcVar13 + (uint)bVar15 * -2 + 1;
                    } while (bVar14);
                    if (!bVar14) {
                      iVar4 = 0xc;
                      pcVar8 = pcVar5;
                      pcVar13 = "Makefile.in";
                      do {
                        if (iVar4 == 0) break;
                        iVar4 = iVar4 + -1;
                        bVar14 = *pcVar8 == *pcVar13;
                        pcVar8 = pcVar8 + (uint)bVar15 * -2 + 1;
                        pcVar13 = pcVar13 + (uint)bVar15 * -2 + 1;
                      } while (bVar14);
                      if ((!bVar14) &&
                         ((sVar6 < 4 ||
                          ((iVar4 = strcmp(pdVar3->d_name + (sVar6 - 4),".png"), iVar4 != 0 &&
                           ((sVar6 == 4 ||
                            (iVar4 = strcmp(pdVar3->d_name + (sVar6 - 5),".html"), iVar4 != 0)))))))
                         ) {
                        uVar11 = 0xffffffff;
                        puVar12 = (undefined4 *)path;
                        do {
                          if (uVar11 == 0) break;
                          uVar11 = uVar11 - 1;
                          cVar1 = *(char *)puVar12;
                          puVar12 = (undefined4 *)((int)puVar12 + (uint)bVar15 * -2 + 1);
                        } while (cVar1 != '\0');
                        uVar9 = 0xffffffff;
                        pcVar8 = pcVar5;
                        do {
                          if (uVar9 == 0) break;
                          uVar9 = uVar9 - 1;
                          cVar1 = *pcVar8;
                          pcVar8 = pcVar8 + (uint)bVar15 * -2 + 1;
                        } while (cVar1 != '\0');
                        uVar10 = 0xffffffff;
                        pcVar8 = pcVar2;
                        do {
                          if (uVar10 == 0) break;
                          uVar10 = uVar10 - 1;
                          cVar1 = *pcVar8;
                          pcVar8 = pcVar8 + (uint)bVar15 * -2 + 1;
                        } while (cVar1 != '\0');
                        local_209c = local_209c + 1;
                        paVar7 = GetLibraryEntryMemory(Menu);
                        pcVar8 = (char *)MyCalloc(1,~uVar9 + ~uVar11 + ~uVar10 + 1,
                                                  "ParseLibraryTree()");
                        paVar7->AllocatedMemory = pcVar8;
                        strcat(pcVar8,path);
                        strcat(paVar7->AllocatedMemory,"/");
                        strcat(paVar7->AllocatedMemory,pcVar2);
                        strcat(paVar7->AllocatedMemory,"/");
                        uVar11 = 0xffffffff;
                        pcVar8 = paVar7->AllocatedMemory;
                        do {
                          if (uVar11 == 0) break;
                          uVar11 = uVar11 - 1;
                          cVar1 = *pcVar8;
                          pcVar8 = pcVar8 + (uint)bVar15 * -2 + 1;
                        } while (cVar1 != '\0');
                        paVar7->ListEntry = paVar7->AllocatedMemory + (~uVar11 - 1);
                        strcat(paVar7->AllocatedMemory,pcVar5);
                        paVar7->Template = (char *)0xffffffff;
                      }
                    }
                  }
                }
              }
            }
            closedir(__dirp_00);
          }
        }
        closedir(__dirp);
      }
      pcVar2 = strtok((char *)0x0,":");
    } while ((pcVar2 != (char *)0x0) && (*pcVar2 != '\0'));
  }
  free(__s);
  chdir(working);
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_209c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int ReadLibraryContents(void)

{
  int iVar1;
  char *pcVar2;
  uint uVar3;
  uint uVar4;
  LibraryEntryTypePtr paVar5;
  char *pcVar6;
  size_t sVar7;
  size_t len;
  size_t sVar8;
  LibraryEntryTypePtr entry;
  char *pcVar9;
  int in_GS_OFFSET;
  bool bVar10;
  undefined uVar11;
  byte bVar12;
  FILE *local_138;
  int local_134;
  LibraryMenuTypePtr local_130;
  char inputline [256];
  int local_20;
  
  bVar12 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  SaveFree(ReadLibraryContents::command);
  ReadLibraryContents::command = (char *)0x0;
  ReadLibraryContents::command =
       EvaluateFilename(Settings.LibraryContentsCommand,Settings.LibraryPath,
                        Settings.LibraryFilename,(char *)0x0);
  if ((ReadLibraryContents::command == (char *)0x0) || (*ReadLibraryContents::command == '\0')) {
    local_138 = (FILE *)0x0;
  }
  else {
    local_138 = popen(ReadLibraryContents::command,"r");
    if (local_138 == (FILE *)0x0) {
      PopenErrorMessage(ReadLibraryContents::command);
    }
    else {
      local_130 = (LibraryMenuTypePtr)0x0;
      while (pcVar2 = fgets(inputline,0xff,local_138), pcVar6 = inputline, pcVar2 != (char *)0x0) {
        do {
          len = (size_t)pcVar6;
          uVar3 = *(uint *)len + 0xfefefeff & ~*(uint *)len;
          uVar4 = uVar3 & 0x80808080;
          pcVar6 = (char *)(len + 4);
        } while (uVar4 == 0);
        bVar10 = (uVar3 & 0x8080) == 0;
        if (bVar10) {
          uVar4 = uVar4 >> 0x10;
        }
        sVar8 = len + 4;
        if (bVar10) {
          sVar8 = len + 6;
        }
        iVar1 = ((sVar8 - 3) - (uint)CARRY1((byte)uVar4,(byte)uVar4)) - (int)inputline;
        uVar11 = iVar1 == 0;
        if (!(bool)uVar11) {
          uVar11 = (&stack0xfffffedc)[iVar1 + 3] == '\n';
          if ((bool)uVar11) {
            (&stack0xfffffedc)[iVar1 + 3] = '\0';
          }
          else {
            Message("linelength (%i) exceeded; following characters will be ignored\n",0xff);
          }
        }
        iVar1 = 5;
        pcVar6 = inputline;
        pcVar2 = "TYPE=";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          uVar11 = *pcVar6 == *pcVar2;
          pcVar6 = pcVar6 + (uint)bVar12 * -2 + 1;
          pcVar2 = pcVar2 + (uint)bVar12 * -2 + 1;
        } while ((bool)uVar11);
        if ((bool)uVar11) {
          local_130 = GetLibraryMenuMemory(&Library);
          pcVar6 = "(unknown)";
          if (inputline[5] != '\0') {
            pcVar6 = inputline + 5;
          }
          pcVar6 = MyStrdup(pcVar6,"ReadLibraryDescription()");
          local_130->Name = pcVar6;
          pcVar6 = (char *)__strdup(Settings.LibraryFilename);
          local_130->directory = pcVar6;
        }
        else {
          if (local_130 == (LibraryMenuTypePtr)0x0) {
            local_130 = GetLibraryMenuMemory(&Library);
            pcVar6 = MyStrdup("(unknown)","ReadLibraryDescription()");
            local_130->Name = pcVar6;
            pcVar6 = (char *)__strdup(Settings.LibraryFilename);
            local_130->directory = pcVar6;
          }
          paVar5 = GetLibraryEntryMemory(local_130);
          pcVar6 = MyStrdup(inputline,"ReadLibraryDescription()");
          paVar5->AllocatedMemory = pcVar6;
          pcVar6 = strtok(pcVar6,":");
          paVar5->Template = pcVar6;
          if (pcVar6 == (char *)0x0) {
LAB_08094178:
            pcVar6 = paVar5->Description;
LAB_080940ea:
            if (paVar5->Value == (char *)0x0) {
              local_134 = 4;
            }
            else {
              sVar7 = strlen(paVar5->Value);
              local_134 = sVar7 + 4;
            }
          }
          else {
            pcVar6 = strtok((char *)0x0,":");
            paVar5->Package = pcVar6;
            if (pcVar6 == (char *)0x0) goto LAB_08094178;
            pcVar6 = strtok((char *)0x0,":");
            paVar5->Value = pcVar6;
            if (pcVar6 != (char *)0x0) {
              pcVar6 = strtok((char *)0x0,":");
              paVar5->Description = pcVar6;
              goto LAB_080940ea;
            }
            pcVar6 = paVar5->Description;
            local_134 = 4;
          }
          sVar7 = 0;
          if (pcVar6 != (char *)0x0) {
            sVar7 = strlen(pcVar6);
          }
          pcVar2 = (char *)MyCalloc(sVar7 + local_134,1,"ReadLibraryDescription()");
          pcVar6 = paVar5->Description;
          if (pcVar6 == (char *)0x0) {
            pcVar6 = "";
          }
          paVar5->ListEntry = pcVar2;
          pcVar9 = paVar5->Value;
          if (pcVar9 == (char *)0x0) {
            pcVar9 = "";
          }
          __sprintf_chk(pcVar2,1,0xffffffff,"%s, %s",pcVar9,pcVar6);
        }
      }
      pclose(local_138);
    }
  }
  iVar1 = ParseLibraryTree();
  if ((0 < iVar1) || (iVar1 = 1, local_138 != (FILE *)0x0)) {
    sort_library(&Library);
    iVar1 = 0;
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



// WARNING: Unknown calling convention

Boolean BoxBoxIntersection(BoxTypePtr b1,BoxTypePtr b2)

{
  int *in_stack_00000004;
  
  if (((*in_stack_00000004 <= b2->X2) && (b2->X1 <= in_stack_00000004[2])) &&
     (in_stack_00000004[1] <= b2->Y2)) {
    return b2->Y1 <= in_stack_00000004[3];
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean PrepareNextLoop(FILE *FP)

{
  int iVar1;
  int iVar2;
  
  iVar1 = PCB->Data->LayerN;
  if (iVar1 != 0) {
    iVar2 = 0;
    do {
      *(undefined4 *)((int)&LineList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&LineList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Location + iVar2) = 0;
      iVar2 = iVar2 + 0x14;
    } while (iVar2 != iVar1 * 0x14);
  }
  PadList[0].Number = 0;
  PadList[0].Location = 0;
  PadList[1].Number = 0;
  PadList[1].Location = 0;
  PVList.Location = 0;
  PVList.Number = 0;
  RatList.Location = 0;
  RatList.Number = 0;
  return '\0';
}



// WARNING: Unknown calling convention

void DumpList(void)

{
  int iVar1;
  int iVar2;
  
  PadList[0].Number = 0;
  PadList[0].Location = 0;
  PadList[0].DrawLocation = 0;
  PadList[1].Number = 0;
  PadList[1].Location = 0;
  PadList[1].DrawLocation = 0;
  PVList.Number = 0;
  PVList.Location = 0;
  iVar1 = PCB->Data->LayerN;
  if (iVar1 != 0) {
    iVar2 = 0;
    do {
      *(undefined4 *)((int)&LineList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&LineList[0].DrawLocation + iVar2) = 0;
      *(undefined4 *)((int)&LineList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].DrawLocation + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].DrawLocation + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Number + iVar2) = 0;
      iVar2 = iVar2 + 0x14;
    } while (iVar2 != iVar1 * 0x14);
  }
  RatList.Number = 0;
  RatList.Location = 0;
  RatList.DrawLocation = 0;
  return;
}



// WARNING: Unknown calling convention

void SaveFindFlag(int NewFlag)

{
  OldFlag = TheFlag;
  TheFlag = NewFlag;
  return;
}



// WARNING: Unknown calling convention

void RestoreFindFlag(void)

{
  TheFlag = OldFlag;
  return;
}



// WARNING: Unknown calling convention

void LocateError(LocationType *x,LocationType *y)

{
  int *piVar1;
  void *pvVar2;
  int iVar3;
  PinTypePtr pin;
  PadTypePtr pad;
  ElementTypePtr element;
  PolygonTypePtr polygon;
  
  pvVar2 = thing_ptr3;
  if (thing_type == 8) {
    piVar1 = *(int **)(*(int *)((int)thing_ptr3 + 0x2c) + 8);
    *x = (piVar1[2] + *piVar1) / 2;
    iVar3 = piVar1[3] + piVar1[1];
  }
  else {
    if (thing_type < 9) {
      if (thing_type == 2) {
        *x = *(LocationType *)((int)thing_ptr3 + 0xd8);
        *y = *(LocationType *)((int)pvVar2 + 0xdc);
        return;
      }
      if (thing_type != 4) {
        if (thing_type != 1) {
          return;
        }
        goto LAB_080944fa;
      }
    }
    else if (thing_type != 0x200) {
      if ((thing_type != 0x4000) && (thing_type != 0x100)) {
        return;
      }
LAB_080944fa:
      *x = *(LocationType *)((int)thing_ptr3 + 0x34);
      *y = *(LocationType *)((int)pvVar2 + 0x38);
      return;
    }
    *x = (*(int *)((int)thing_ptr3 + 0x40) + *(int *)((int)thing_ptr3 + 0x2c)) / 2;
    iVar3 = *(int *)((int)pvVar2 + 0x44) + *(int *)((int)pvVar2 + 0x30);
  }
  *y = iVar3 / 2;
  return;
}



// WARNING: Unknown calling convention

Boolean ADD_PV_TO_LIST(PinTypePtr Pin)

{
  Boolean BVar1;
  PinTypePtr Ptr1;
  int Type;
  
  if (User != '\0') {
    Type = 0x100;
    Ptr1 = (PinTypePtr)Pin->Element;
    if ((PinTypePtr)Pin->Element == (PinTypePtr)0x0) {
      Type = 1;
      Ptr1 = Pin;
    }
    AddObjectToFlagUndoList(Type,Ptr1,Pin,Pin);
  }
  (Pin->Flags).f = (Pin->Flags).f | TheFlag;
  PVList.Data[PVList.Number] = Pin;
  PVList.Number = PVList.Number + 1;
  if ((drc == '\0') || ((*(byte *)&(Pin->Flags).f & 0x40) != 0)) {
    BVar1 = '\0';
  }
  else {
    thing_ptr1 = Pin->Element;
    BVar1 = '\x01';
    thing_type = 0x100;
    thing_ptr2 = Pin;
    thing_ptr3 = Pin;
    if (thing_ptr1 == (void *)0x0) {
      thing_type = 1;
      thing_ptr1 = Pin;
    }
  }
  return BVar1;
}



// WARNING: Unknown calling convention

Boolean ADD_RAT_TO_LIST(RatTypePtr Ptr)

{
  uint uVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(0x20,Ptr,Ptr,Ptr);
  }
  uVar1 = TheFlag | (Ptr->Flags).f;
  RatList.Data[RatList.Number] = Ptr;
  bVar2 = drc != '\0';
  (Ptr->Flags).f = uVar1;
  RatList.Number = RatList.Number + 1;
  if ((bVar2) && ((uVar1 & 0x40) == 0)) {
    thing_ptr1 = Ptr;
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 0x20;
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean ADD_LINE_TO_LIST(Cardinal L,LineTypePtr Ptr)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(4,PCB->Data->Layer + L,Ptr,Ptr);
  }
  (Ptr->Flags).f = (Ptr->Flags).f | TheFlag;
  CVar1 = LineList[L].Number;
  LineList[L].Data[CVar1] = Ptr;
  bVar2 = drc != '\0';
  LineList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Ptr->Flags).f & 0x40) == 0)) {
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 4;
    thing_ptr1 = PCB->Data->Layer + L;
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean ADD_ARC_TO_LIST(Cardinal L,ArcTypePtr Ptr)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(0x4000,PCB->Data->Layer + L,Ptr,Ptr);
  }
  (Ptr->Flags).f = (Ptr->Flags).f | TheFlag;
  CVar1 = ArcList[L].Number;
  ArcList[L].Data[CVar1] = Ptr;
  bVar2 = drc != '\0';
  ArcList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Ptr->Flags).f & 0x40) == 0)) {
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 0x4000;
    thing_ptr1 = PCB->Data->Layer + L;
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean ADD_POLYGON_TO_LIST(Cardinal L,PolygonTypePtr Ptr)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(8,PCB->Data->Layer + L,Ptr,Ptr);
  }
  (Ptr->Flags).f = (Ptr->Flags).f | TheFlag;
  CVar1 = PolygonList[L].Number;
  PolygonList[L].Data[CVar1] = Ptr;
  bVar2 = drc != '\0';
  PolygonList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Ptr->Flags).f & 0x40) == 0)) {
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 8;
    thing_ptr1 = PCB->Data->Layer + L;
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean ADD_PAD_TO_LIST(Cardinal L,PadTypePtr Pad)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(0x200,Pad->Element,Pad,Pad);
  }
  (Pad->Flags).f = (Pad->Flags).f | TheFlag;
  CVar1 = PadList[L].Number;
  PadList[L].Data[CVar1] = Pad;
  bVar2 = drc != '\0';
  PadList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Pad->Flags).f & 0x40) == 0)) {
    thing_type = 0x200;
    thing_ptr2 = Pad;
    thing_ptr3 = Pad;
    thing_ptr1 = Pad->Element;
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

void pcb_drc_violation_free(DrcViolationType *violation)

{
  free(violation->title);
  free(violation->explanation);
  free(violation);
  return;
}



// WARNING: Unknown calling convention

void BuildObjectList(int *object_count,long **object_id_list,int **object_type_list)

{
  long lVar1;
  long *plVar2;
  int *piVar3;
  
  *object_count = 0;
  *object_id_list = (long *)0x0;
  if (thing_type != 8) {
    if (thing_type < 9) {
      if (thing_type < 1) {
        return;
      }
      if ((2 < thing_type) && (thing_type != 4)) {
        return;
      }
    }
    else if (((thing_type != 0x200) && (thing_type != 0x4000)) && (thing_type != 0x100)) {
      return;
    }
  }
  *object_count = 1;
  plVar2 = (long *)calloc(1,4);
  *object_id_list = plVar2;
  piVar3 = (int *)calloc(1,4);
  plVar2 = *object_id_list;
  lVar1 = *(long *)((int)thing_ptr3 + 0x10);
  *object_type_list = piVar3;
  *plVar2 = lVar1;
  *piVar3 = thing_type;
  return;
}



// WARNING: Unknown calling convention
// Local variable layer:int[EAX:4] conflicts with parameter, skipped.
// Local variable layer_1:int[EAX:4] conflicts with parameter, skipped.
// Local variable layer_2:int[EAX:4] conflicts with parameter, skipped.

Boolean ListStart(int type,void *ptr1,void *ptr2,void *ptr3)

{
  Boolean BVar1;
  Cardinal CVar2;
  
  DumpList();
  if (type == 0x20) {
    BVar1 = ADD_RAT_TO_LIST((RatTypePtr)ptr1);
    return BVar1 != '\0';
  }
  if (type < 0x21) {
    if (type == 4) {
      CVar2 = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr1);
      BVar1 = ADD_LINE_TO_LIST(CVar2,(LineTypePtr)ptr2);
      return BVar1 != '\0';
    }
    if (type == 8) {
      CVar2 = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr1);
      BVar1 = ADD_POLYGON_TO_LIST(CVar2,(PolygonTypePtr)ptr2);
      return BVar1 != '\0';
    }
    if (type == 1) goto LAB_08094bc3;
  }
  else {
    if (type == 0x200) {
      BVar1 = ADD_PAD_TO_LIST((*(uint *)((int)ptr2 + 0x14) >> 7 ^ 1) & 1,(PadTypePtr)ptr2);
      return BVar1 != '\0';
    }
    if (type == 0x4000) {
      CVar2 = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr1);
      BVar1 = ADD_ARC_TO_LIST(CVar2,(ArcTypePtr)ptr2);
      return BVar1 != '\0';
    }
    if (type == 0x100) {
LAB_08094bc3:
      BVar1 = ADD_PV_TO_LIST((PinTypePtr)ptr2);
      return BVar1 != '\0';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean LookupPVConnectionsToPVList(void)

{
  int iVar1;
  LocationType LVar2;
  Cardinal CVar3;
  Boolean BVar4;
  Cardinal save_place;
  int iVar5;
  LocationType *pLVar6;
  PinType *pPVar7;
  int in_GS_OFFSET;
  byte bVar8;
  pv_info info;
  
  CVar3 = PVList.Location;
  bVar8 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (PVList.Location < PVList.Number) {
    do {
      LVar2 = Bloat;
      pLVar6 = (LocationType *)PVList.Data[PVList.Location];
      pPVar7 = &info.pv;
      for (iVar5 = 0x13; iVar5 != 0; iVar5 = iVar5 + -1) {
        (pPVar7->BoundingBox).X1 = *pLVar6;
        pLVar6 = pLVar6 + (uint)bVar8 * -2 + 1;
        pPVar7 = (PinType *)((int)pPVar7 + (uint)bVar8 * -8 + 4);
      }
      if (0 < LVar2) {
        info.pv.BoundingBox.X1 = info.pv.BoundingBox.X1 - LVar2;
        info.pv.BoundingBox.X2 = info.pv.BoundingBox.X2 + LVar2;
        info.pv.BoundingBox.Y1 = info.pv.BoundingBox.Y1 - LVar2;
        info.pv.BoundingBox.Y2 = info.pv.BoundingBox.Y2 + LVar2;
      }
      iVar5 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar5 != 0) {
LAB_08094dc3:
        BVar4 = '\x01';
        goto LAB_08094dc8;
      }
      r_search(PCB->Data->via_tree,&info.pv.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               pv_pv_callback,&info);
      iVar5 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar5 != 0) goto LAB_08094dc3;
      r_search(PCB->Data->pin_tree,&info.pv.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               pv_pv_callback,&info);
      PVList.Location = PVList.Location + 1;
    } while (PVList.Location < PVList.Number);
  }
  BVar4 = '\0';
  PVList.Location = CVar3;
LAB_08094dc8:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean LookupLOConnectionsToPVList(Boolean AndRats)

{
  int *piVar1;
  int iVar2;
  LocationType LVar3;
  Boolean BVar4;
  int iVar5;
  LocationType *pLVar6;
  PinType *pPVar7;
  int in_GS_OFFSET;
  byte bVar8;
  uint local_100;
  pv_info info;
  
  bVar8 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  if (PVList.Location < PVList.Number) {
    do {
      LVar3 = Bloat;
      pLVar6 = (LocationType *)PVList.Data[PVList.Location];
      pPVar7 = &info.pv;
      for (iVar5 = 0x13; iVar5 != 0; iVar5 = iVar5 + -1) {
        (pPVar7->BoundingBox).X1 = *pLVar6;
        pLVar6 = pLVar6 + (uint)bVar8 * -2 + 1;
        pPVar7 = (PinType *)((int)pPVar7 + (uint)bVar8 * -8 + 4);
      }
      if (0 < LVar3) {
        info.pv.BoundingBox.X1 = info.pv.BoundingBox.X1 - LVar3;
        info.pv.BoundingBox.X2 = info.pv.BoundingBox.X2 + LVar3;
        info.pv.BoundingBox.Y1 = info.pv.BoundingBox.Y1 - LVar3;
        info.pv.BoundingBox.Y2 = info.pv.BoundingBox.Y2 + LVar3;
      }
      iVar5 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar5 != 0) {
LAB_08095022:
        BVar4 = '\x01';
        goto LAB_08095027;
      }
      r_search(PCB->Data->pad_tree,&info.pv.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               LOCtoPVpad_callback,&info);
      if (PCB->Data->LayerN != 0) {
        local_100 = 0;
        do {
          info.layer = local_100;
          iVar5 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar5 != 0) goto LAB_08095022;
          r_search(PCB->Data->Layer[local_100].line_tree,&info.pv.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPVline_callback,&info);
          iVar5 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar5 != 0) goto LAB_08095022;
          r_search(PCB->Data->Layer[local_100].arc_tree,&info.pv.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPVarc_callback,&info);
          iVar5 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar5 != 0) goto LAB_08095022;
          r_search(PCB->Data->Layer[local_100].polygon_tree,&info.pv.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPVpoly_callback,&info);
          local_100 = local_100 + 1;
          piVar1 = &PCB->Data->LayerN;
        } while (local_100 <= (uint)*piVar1 && *piVar1 != local_100);
      }
      if (AndRats != '\0') {
        iVar5 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar5 != 0) goto LAB_08095022;
        r_search(PCB->Data->rat_tree,&info.pv.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 LOCtoPVrat_callback,&info);
      }
      PVList.Location = PVList.Location + 1;
    } while (PVList.Location < PVList.Number);
  }
  BVar4 = '\0';
LAB_08095027:
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean PVTouchesLine(LineTypePtr line)

{
  lo_info *plVar1;
  Boolean BVar2;
  int iVar3;
  LineType *pLVar4;
  int in_GS_OFFSET;
  lo_info info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  plVar1 = &info;
  for (iVar3 = 0x16; pLVar4 = &plVar1->line, iVar3 != 0; iVar3 = iVar3 + -1) {
    plVar1 = (lo_info *)&pLVar4->BoundingBox;
    (pLVar4->BoundingBox).X1 = (line->BoundingBox).X1;
    line = (LineTypePtr)&(line->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
    info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
    info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
    info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
  }
  iVar3 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar3 == 0) {
    r_search(PCB->Data->via_tree,&info.line.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
             pv_touch_callback,&info);
    iVar3 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar3 == 0) {
      r_search(PCB->Data->pin_tree,&info.line.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               pv_touch_callback,&info);
      BVar2 = '\0';
      goto LAB_0809511d;
    }
  }
  BVar2 = '\x01';
LAB_0809511d:
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int LOCtoPad_callback(BoxType *b,void *cl)

{
  int *piVar1;
  Boolean BVar2;
  
                    // WARNING: Load size is inaccurate
  if (((TheFlag & b[1].Y1) == 0) && (*cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    piVar1 = *(int **)((int)cl + 4);
    if ((((b[2].Y2 == *piVar1) && (b[3].X1 == piVar1[1])) ||
        ((*piVar1 == b[4].X1 && (b[4].Y1 == piVar1[1])))) &&
       (BVar2 = ADD_PAD_TO_LIST(*cl,(PadTypePtr)b), BVar2 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int PolygonToRat_callback(BoxType *b,void *cl)

{
  int iVar1;
  Boolean BVar2;
  
  if (((b[1].Y1 & TheFlag) == 0) && (b[2].Y2 != 0)) {
    iVar1 = *(int *)(b[2].Y2 + 8);
    if ((**(int **)((int)cl + 4) == *(int *)(iVar1 + 0x2c)) &&
       ((*(int **)((int)cl + 4))[1] == *(int *)(iVar1 + 0x30))) {
                    // WARNING: Load size is inaccurate
      BVar2 = ADD_POLYGON_TO_LIST(*cl,(PolygonTypePtr)b);
      if (BVar2 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 8,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoRat_callback(BoxType *b,void *cl)

{
  int iVar1;
  int *piVar2;
  Boolean BVar3;
  
  if ((b[1].Y1 & TheFlag) != 0) {
    return 0;
  }
  piVar2 = *(int **)((int)cl + 4);
  if (b[2].Y2 == *piVar2) {
    if (b[3].X1 == piVar2[1]) goto LAB_08095310;
    iVar1 = b[4].X1;
  }
  else {
    iVar1 = b[4].X1;
  }
  if (*piVar2 != iVar1) {
    return 0;
  }
  if (b[4].Y1 != piVar2[1]) {
    return 0;
  }
LAB_08095310:
                    // WARNING: Load size is inaccurate
  BVar3 = ADD_LINE_TO_LIST(*cl,(LineTypePtr)b);
  if (BVar3 == '\0') {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 8,1);
}



// WARNING: Unknown calling convention

int LOCtoLineRat_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
                    // WARNING: Load size is inaccurate
  if ((((b[1].Y1 & TheFlag) == 0) &&
      (((b[5].Y1 == *cl &&
        (((b[2].Y2 == *(int *)((int)cl + 0x30) && (b[3].X1 == *(int *)((int)cl + 0x34))) ||
         ((b[2].Y2 == *(int *)((int)cl + 0x44) && (b[3].X1 == *(int *)((int)cl + 0x48))))))) ||
       ((*cl == b[5].X2 &&
        (((b[4].X1 == *(int *)((int)cl + 0x30) && (b[4].Y1 == *(int *)((int)cl + 0x34))) ||
         ((b[4].X1 == *(int *)((int)cl + 0x44) && (b[4].Y1 == *(int *)((int)cl + 0x48))))))))))) &&
     (BVar1 = ADD_RAT_TO_LIST((RatTypePtr)b), BVar1 != '\0')) {
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x1a0,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPolyRat_callback(BoxType *b,void *cl)

{
  int iVar1;
  Boolean BVar2;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    iVar1 = *(int *)(*(int *)((int)cl + 0x134) + 8);
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
    if (((((b[2].Y2 == *(int *)(iVar1 + 0x2c)) && (b[3].X1 == *(int *)(iVar1 + 0x30))) &&
         (b[5].Y1 == *cl)) ||
        (((*(int *)(iVar1 + 0x2c) == b[4].X1 && (b[4].Y1 == *(int *)(iVar1 + 0x30))) &&
         (b[5].X2 == *cl)))) && (BVar2 = ADD_RAT_TO_LIST((RatTypePtr)b), BVar2 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPadRat_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
                    // WARNING: Load size is inaccurate
  if ((((b[1].Y1 & TheFlag) == 0) &&
      (((b[5].Y1 == *cl &&
        (((b[2].Y2 == *(int *)((int)cl + 0x88) && (b[3].X1 == *(int *)((int)cl + 0x8c))) ||
         ((b[2].Y2 == *(int *)((int)cl + 0x9c) && (b[3].X1 == *(int *)((int)cl + 0xa0))))))) ||
       ((*cl == b[5].X2 &&
        (((b[4].X1 == *(int *)((int)cl + 0x88) && (b[4].Y1 == *(int *)((int)cl + 0x8c))) ||
         ((b[4].X1 == *(int *)((int)cl + 0x9c) && (b[4].Y1 == *(int *)((int)cl + 0xa0))))))))))) &&
     (BVar1 = ADD_RAT_TO_LIST((RatTypePtr)b), BVar1 != '\0')) {
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x1a0,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int pv_pv_callback(BoxType *b,void *cl)

{
  float fVar1;
  float Radius;
  Boolean BVar2;
  uint uVar3;
  float t1;
  float local_2c;
  
  if ((b[1].Y1 & TheFlag) != 0) {
    return 0;
  }
  Radius = (float)*(int *)((int)cl + 0x28) * 0.5 + fBloat;
  if (Radius <= 0.0) {
    Radius = 0.0;
  }
  fVar1 = (float)b[2].Y1 * 0.5 + fBloat;
  local_2c = 0.0;
  if (fVar1 <= 0.0) {
    fVar1 = local_2c;
  }
  local_2c = fVar1;
  BVar2 = IsPointOnPin((float)*(int *)((int)cl + 0x38),(float)*(int *)((int)cl + 0x3c),Radius,
                       (PinTypePtr)b);
  if ((BVar2 == '\0') &&
     (BVar2 = IsPointOnPin((float)b[3].Y1,(float)b[3].X2,local_2c,(PinTypePtr)((int)cl + 4)),
     BVar2 == '\0')) {
    if ((*(byte *)((int)cl + 0x19) & 1) == 0) {
      return 0;
    }
    uVar3 = b[1].Y1;
    if ((uVar3 & 0x100) == 0) {
      return 0;
    }
    fVar1 = (float)b[2].Y1 * 0.5;
    if ((int)ROUND(fVar1 + (float)b[3].Y1) < (int)ROUND((float)*(int *)((int)cl + 0x38) - Radius)) {
      return 0;
    }
    if ((int)ROUND((float)*(int *)((int)cl + 0x38) + Radius) < (int)ROUND((float)b[3].Y1 - fVar1)) {
      return 0;
    }
    if ((int)ROUND(fVar1 + (float)b[3].X2) < (int)ROUND((float)*(int *)((int)cl + 0x3c) - Radius)) {
      return 0;
    }
    if ((int)ROUND(Radius + (float)*(int *)((int)cl + 0x3c)) < (int)ROUND((float)b[3].X2 - fVar1)) {
      return 0;
    }
  }
  else {
    uVar3 = b[1].Y1;
  }
  if ((uVar3 & 8) != 0) {
    b[1].Y1 = uVar3 | 0x200;
    Settings.RatWarn = '\x01';
    if (b[4].Y1 == 0) {
      Message("WARNING: Hole too close to via.\n");
    }
    else {
      Message("WARNING: Hole too close to pin.\n");
    }
  }
  BVar2 = ADD_PV_TO_LIST((PinTypePtr)b);
  if (BVar2 == '\0') {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0x50,1);
}



// WARNING: Unknown calling convention

int LOCtoPVrat_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = IsPointOnLineEnd(*(LocationType *)((int)cl + 0x38),*(LocationType *)((int)cl + 0x3c),
                             (RatTypePtr)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_RAT_TO_LIST((RatTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x50,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pv_rat_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = IsPointOnLineEnd(b[3].Y1,b[3].X2,(RatTypePtr)((int)cl + 0x144));
    if (BVar1 != '\0') {
      ADD_PV_TO_LIST((PinTypePtr)b);
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPVpoly_callback(BoxType *b,void *cl)

{
  float fVar1;
  Boolean BVar2;
  POLYAREA *a;
  POLYAREA *oct;
  int iVar3;
  float wide;
  
                    // WARNING: Load size is inaccurate
  if (((TheFlag & b[1].Y1) == 0) &&
     ((((0xf << (sbyte)((*cl & 1) << 2) & (uint)*(byte *)((int)cl + (*cl >> 1) + 0x1c)) != 0 ||
       ((b[1].Y1 & 0x10U) == 0)) || (*(int *)((int)cl + 0x2c) == 0)))) {
    iVar3 = *(int *)((int)cl + 0x28);
    fVar1 = (float)iVar3 * 0.5 + fBloat;
    if (fVar1 <= 0.0) {
      fVar1 = 0.0;
    }
    if ((*(uint *)((int)cl + 0x18) & 0x100) == 0) {
      if ((*(uint *)((int)cl + 0x18) & 0x800) == 0) {
        oct._0_1_ = IsPointInPolygon(*(LocationType *)((int)cl + 0x38),
                                     *(LocationType *)((int)cl + 0x3c),(int)ROUND(fVar1),
                                     (PolygonTypePtr)b);
      }
      else {
        a = OctagonPoly(*(LocationType *)((int)cl + 0x38),*(LocationType *)((int)cl + 0x3c),
                        iVar3 / 2);
        oct._0_1_ = isects(a,(PolygonTypePtr)b,'\x01');
      }
    }
    else {
      iVar3 = (iVar3 + Bloat + 1) / 2;
      oct._0_1_ = IsRectangleInPolygon
                            (-iVar3 + *(int *)((int)cl + 0x38),-iVar3 + *(int *)((int)cl + 0x3c),
                             iVar3 + *(int *)((int)cl + 0x38),iVar3 + *(int *)((int)cl + 0x3c),
                             (PolygonTypePtr)b);
    }
                    // WARNING: Load size is inaccurate
    if (((char)oct != '\0') && (BVar2 = ADD_POLYGON_TO_LIST(*cl,(PolygonTypePtr)b), BVar2 != '\0'))
    {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x50,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pv_poly_callback(BoxType *b,void *cl)

{
  uint uVar1;
  Boolean BVar2;
  POLYAREA *a;
  POLYAREA *oct;
  int iVar3;
  
  uVar1 = b[1].Y1;
                    // WARNING: Load size is inaccurate
  if (((TheFlag & uVar1) == 0) &&
     ((((0xf << (sbyte)((*cl & 1) << 2) & (uint)*(byte *)((int)&b[1].X2 + (*cl >> 1))) != 0 ||
       ((*(byte *)((int)cl + 0x11c) & 0x10) == 0)) || (b[2].X2 == 0)))) {
    if ((uVar1 & 0x100) == 0) {
      if ((uVar1 & 0x800) == 0) {
        oct._0_1_ = IsPointInPolygon(b[3].Y1,b[3].X2,(int)ROUND((float)b[2].Y1 * 0.5 + fBloat),
                                     (PolygonTypePtr)((int)cl + 0x108));
      }
      else {
        a = OctagonPoly(b[3].Y1,b[3].X2,b[2].Y1 / 2);
        oct._0_1_ = isects(a,(PolygonTypePtr)((int)cl + 0x108),'\x01');
      }
    }
    else {
      iVar3 = (b[2].Y1 + Bloat + 1) / 2;
      oct._0_1_ = IsRectangleInPolygon
                            (-iVar3 + b[3].Y1,-iVar3 + b[3].X2,iVar3 + b[3].Y1,iVar3 + b[3].X2,
                             (PolygonTypePtr)((int)cl + 0x108));
    }
    if (((char)oct != '\0') && (BVar2 = ADD_PV_TO_LIST((PinTypePtr)b), BVar2 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPVarc_callback(BoxType *b,void *cl)

{
  float fVar1;
  float Radius;
  char cVar2;
  Boolean BVar3;
  int iVar4;
  
  if ((TheFlag & b[1].Y1) == 0) {
    if ((*(byte *)((int)cl + 0x19) & 1) == 0) {
      fVar1 = (float)*(int *)((int)cl + 0x28) * 0.5 + fBloat;
      Radius = 0.0;
      if (0.0 < fVar1) {
        Radius = fVar1;
      }
      cVar2 = IsPointOnArc((float)*(int *)((int)cl + 0x38),(float)*(int *)((int)cl + 0x3c),Radius,
                           (ArcTypePtr)b);
    }
    else {
      iVar4 = (*(int *)((int)cl + 0x28) + 1) / 2 + Bloat;
      if (iVar4 < 0) {
        iVar4 = 0;
      }
      cVar2 = IsArcInRectangle(*(int *)((int)cl + 0x38) - iVar4,*(int *)((int)cl + 0x3c) - iVar4,
                               iVar4 + *(int *)((int)cl + 0x38),iVar4 + *(int *)((int)cl + 0x3c),
                               (ArcTypePtr)b);
    }
                    // WARNING: Load size is inaccurate
    if ((cVar2 != '\0') && (BVar3 = ADD_ARC_TO_LIST(*cl,(ArcTypePtr)b), BVar3 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x50,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pv_arc_callback(BoxType *b,void *cl)

{
  float fVar1;
  float Radius;
  char cVar2;
  Boolean BVar3;
  int iVar4;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    if ((b[1].Y1 & 0x100U) == 0) {
      fVar1 = (float)b[2].Y1 * 0.5 + fBloat;
      Radius = 0.0;
      if (0.0 < fVar1) {
        Radius = fVar1;
      }
      cVar2 = IsPointOnArc((float)b[3].Y1,(float)b[3].X2,Radius,(ArcTypePtr)((int)cl + 0xc4));
    }
    else {
      iVar4 = (b[2].Y1 + 1) / 2 + Bloat;
      if (iVar4 < 0) {
        iVar4 = 0;
      }
      cVar2 = IsArcInRectangle(b[3].Y1 - iVar4,b[3].X2 - iVar4,iVar4 + b[3].Y1,iVar4 + b[3].X2,
                               (ArcTypePtr)((int)cl + 0xc4));
    }
    if (cVar2 != '\0') {
      if ((b[1].Y1 & 8U) != 0) {
        b[1].Y1 = b[1].Y1 | 0x200;
        Settings.RatWarn = '\x01';
        Message("WARNING: Hole touches arc.\n");
      }
      BVar3 = ADD_PV_TO_LIST((PinTypePtr)b);
      if (BVar3 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPVpad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  BDimension Radius;
  
  if ((TheFlag & b[1].Y1) == 0) {
    Radius = *(int *)((int)cl + 0x28) / 2 + Bloat;
    if (Radius < 0) {
      Radius = 0;
    }
    BVar1 = IsPointInPad(*(LocationType *)((int)cl + 0x38),*(LocationType *)((int)cl + 0x3c),Radius,
                         (PadTypePtr)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_PAD_TO_LIST(((uint)b[1].Y1 >> 7 ^ 1) & 1,(PadTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x50,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pv_pad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  BDimension Radius;
  
  if ((TheFlag & b[1].Y1) == 0) {
    Radius = b[2].Y1 / 2 + Bloat;
    if (Radius < 0) {
      Radius = 0;
    }
    BVar1 = IsPointInPad(b[3].Y1,b[3].X2,Radius,(PadTypePtr)((int)cl + 0x5c));
    if (BVar1 != '\0') {
      if ((b[1].Y1 & 8U) != 0) {
        b[1].Y1 = b[1].Y1 | 0x200;
        Settings.RatWarn = '\x01';
        Message("WARNING: Hole too close to pad.\n");
      }
      BVar1 = ADD_PV_TO_LIST((PinTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x0809611d)
// WARNING: Removing unreachable block (ram,0x08096123)
// WARNING: Removing unreachable block (ram,0x08096128)
// WARNING: Unknown calling convention

int LOCtoArcArc_callback(BoxType *b,void *cl)

{
  ArcTypePtr Arc;
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  Boolean BVar14;
  int iVar15;
  BoxTypePtr pBVar16;
  BoxTypePtr box;
  LocationType pdx;
  int iVar17;
  LocationType pdy;
  int iVar18;
  float dy;
  float t;
  float t2;
  float x;
  float y;
  float a;
  
  iVar15 = b[2].Y1;
  if (iVar15 == 0) {
    return 0;
  }
  if ((b[1].Y1 & TheFlag) != 0) {
    return 0;
  }
  iVar18 = b[3].X2 - *(int *)((int)cl + 0xfc);
  iVar17 = b[3].Y1 - *(int *)((int)cl + 0xf8);
  fVar8 = (float)(iVar17 * iVar17 + iVar18 * iVar18);
  fVar6 = (float)*(int *)((int)cl + 0xe8) * 0.5 + fBloat;
  if (fVar6 <= 0.0) {
    fVar6 = 0.0;
  }
  fVar10 = (float)iVar15 * 0.5;
  if (fVar8 == 0.0) {
    fVar8 = (float)*(int *)((int)cl + 0xf0) - fVar6;
    fVar7 = (float)b[2].Y2;
    if ((fVar8 < fVar7 - fVar10) || (fVar10 + fVar7 < fVar8)) {
      fVar6 = fVar6 + (float)*(int *)((int)cl + 0xf0);
      if (fVar6 < fVar7 - fVar10) {
        return 0;
      }
      if (fVar10 + fVar7 < fVar6) {
        return 0;
      }
    }
    iVar15 = iVar15 + Bloat;
    if (iVar15 < 0) {
      iVar15 = 0;
    }
    if ((((iVar15 + b->X1 < *(int *)((int)cl + 0xc4)) || (*(int *)((int)cl + 0xcc) < b->X1)) ||
        (iVar15 + b->Y1 < *(int *)((int)cl + 200))) || (*(int *)((int)cl + 0xd0) < b->Y1)) {
      if (iVar15 + b->X2 < *(int *)((int)cl + 0xc4)) {
        return 0;
      }
      if (*(int *)((int)cl + 0xcc) < b->X2) {
        return 0;
      }
      if (iVar15 + b->Y2 < *(int *)((int)cl + 200)) {
        return 0;
      }
      if (*(int *)((int)cl + 0xd0) < b->Y2) {
        return 0;
      }
    }
  }
  else {
    fVar7 = (float)*(int *)((int)cl + 0xf0) + fVar6;
    fVar7 = fVar7 * fVar7;
    fVar9 = (float)b[2].Y2 + fVar10;
    fVar9 = (((fVar7 - fVar9 * fVar9) + fVar8) * 0.5) / fVar8;
    fVar8 = (fVar7 / fVar8 - fVar9 * fVar9) + 1e-05;
    if (fVar8 < 0.0) {
      return 0;
    }
    fVar8 = SQRT(fVar8);
    fVar12 = fVar9 * (float)iVar17 + (float)*(int *)((int)cl + 0xf8);
    fVar7 = fVar9 * (float)iVar18 + (float)*(int *)((int)cl + 0xfc);
    fVar13 = (float)iVar17 * fVar8;
    fVar8 = fVar8 * (float)iVar18;
    fVar9 = fVar12 + fVar8;
    if (((((fVar9 < (float)*(int *)((int)cl + 0xc4)) || ((float)*(int *)((int)cl + 0xcc) < fVar9))
         || (fVar11 = fVar7 - fVar13, fVar11 < (float)*(int *)((int)cl + 200))) ||
        ((((float)*(int *)((int)cl + 0xd0) < fVar11 || (fVar9 < (float)b->X1)) ||
         (((float)b->X2 < fVar9 || ((fVar11 < (float)b->Y1 || ((float)b->Y2 < fVar11)))))))) &&
       (((fVar12 = fVar12 - fVar8, fVar12 < (float)*(int *)((int)cl + 0xc4) ||
         ((((float)*(int *)((int)cl + 0xcc) < fVar12 ||
           (fVar7 = fVar7 + fVar13, fVar7 < (float)*(int *)((int)cl + 200))) ||
          ((float)*(int *)((int)cl + 0xd0) < fVar7)))) ||
        (((fVar12 < (float)b->X1 || ((float)b->X2 < fVar12)) ||
         ((fVar7 < (float)b->Y1 || ((float)b->Y2 < fVar7)))))))) {
      Arc = (ArcTypePtr)((int)cl + 0xc4);
      pBVar16 = GetArcEnds(Arc);
      iVar15 = pBVar16->X2;
      iVar17 = pBVar16->Y2;
      iVar18 = pBVar16->X1;
      iVar1 = pBVar16->Y1;
      pBVar16 = GetArcEnds((ArcTypePtr)b);
      iVar2 = pBVar16->X2;
      iVar3 = pBVar16->Y2;
      iVar4 = pBVar16->X1;
      iVar5 = pBVar16->Y1;
      BVar14 = IsPointOnArc((float)iVar18,(float)iVar1,fVar6,(ArcTypePtr)b);
      if ((BVar14 == '\0') &&
         (BVar14 = IsPointOnArc((float)iVar15,(float)iVar17,fVar6,(ArcTypePtr)b), BVar14 == '\0')) {
        fVar6 = fBloat + fVar10;
        if (fBloat + fVar10 <= 0.0) {
          fVar6 = 0.0;
        }
        BVar14 = IsPointOnArc((float)iVar4,(float)iVar5,fVar6,Arc);
        if (BVar14 == '\0') {
          fVar6 = fVar10 + fBloat;
          if (fVar10 + fBloat <= 0.0) {
            fVar6 = 0.0;
          }
          BVar14 = IsPointOnArc((float)iVar2,(float)iVar3,fVar6,Arc);
          if (BVar14 == '\0') {
            return 0;
          }
        }
      }
    }
  }
                    // WARNING: Load size is inaccurate
  BVar14 = ADD_ARC_TO_LIST(*cl,(ArcTypePtr)b);
  if (BVar14 == '\0') {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0x1a0,1);
}



// WARNING: Removing unreachable block (ram,0x080965ba)
// WARNING: Removing unreachable block (ram,0x080965c0)
// WARNING: Removing unreachable block (ram,0x080965c8)
// WARNING: Unknown calling convention

Boolean LineArcIntersect(LineTypePtr Line,ArcTypePtr Arc)

{
  float fVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  Boolean BVar11;
  int iVar12;
  BoxTypePtr pBVar13;
  BoxTypePtr box;
  float dy;
  float r2;
  float r;
  
  iVar2 = (Line->Point1).X;
  iVar3 = (Line->Point1).Y;
  fVar4 = (float)((Line->Point2).X - iVar2);
  iVar12 = (Line->Point2).Y - iVar3;
  fVar8 = (float)iVar12;
  fVar5 = (float)(iVar2 - Arc->X);
  fVar6 = (float)(iVar3 - Arc->Y);
  fVar7 = fVar8 * fVar8 + fVar4 * fVar4;
  fVar9 = (float)(Arc->Thickness + Line->Thickness) * 0.5 + fBloat;
  if (fVar9 <= 0.0) {
    fVar9 = 0.0;
  }
  fVar9 = (float)Arc->Width + fVar9;
  fVar8 = fVar4 * fVar6 - fVar5 * fVar8;
  fVar8 = fVar9 * fVar9 * fVar7 - fVar8 * fVar8;
  if (0.0 <= fVar8) {
    fVar9 = (float)Line->Thickness * 0.5 + fBloat;
    if (fVar9 <= 0.0) {
      fVar9 = 0.0;
    }
    fVar1 = (float)iVar12;
    BVar11 = IsPointOnArc((float)iVar2,(float)iVar3,fVar9,Arc);
    if (BVar11 != '\0') {
      return '\x01';
    }
    fVar9 = (float)Line->Thickness * 0.5 + fBloat;
    if (fVar9 <= 0.0) {
      fVar9 = 0.0;
    }
    BVar11 = IsPointOnArc((float)(Line->Point2).X,(float)(Line->Point2).Y,fVar9,Arc);
    if (BVar11 != '\0') {
      return '\x01';
    }
    if (fVar7 != 0.0) {
      fVar8 = SQRT(fVar8);
      fVar9 = -(fVar6 * fVar1 + fVar4 * fVar5);
      fVar5 = (fVar8 + fVar9) / fVar7;
      fVar6 = 0.0;
      if ((0.0 <= fVar5) && (fVar5 <= 1.0)) {
        fVar10 = (float)Line->Thickness * 0.5 + fBloat;
        if (0.0 < fVar10) {
          fVar6 = fVar10;
        }
        BVar11 = IsPointOnArc(fVar5 * fVar4 + (float)(Line->Point1).X,
                              fVar5 * fVar1 + (float)(Line->Point1).Y,fVar6,Arc);
        if (BVar11 != '\0') {
          return '\x01';
        }
      }
      fVar7 = (fVar9 - fVar8) / fVar7;
      fVar5 = 0.0;
      if ((0.0 <= fVar7) && (fVar7 <= 1.0)) {
        fVar6 = (float)Line->Thickness * 0.5 + fBloat;
        if (0.0 < fVar6) {
          fVar5 = fVar6;
        }
        BVar11 = IsPointOnArc(fVar7 * fVar4 + (float)(Line->Point1).X,
                              fVar1 * fVar7 + (float)(Line->Point1).Y,fVar5,Arc);
        if (BVar11 != '\0') {
          return '\x01';
        }
      }
      pBVar13 = GetArcEnds(Arc);
      BVar11 = IsPointInPad(pBVar13->X1,pBVar13->Y1,(int)ROUND((float)Arc->Thickness * 0.5 + fBloat)
                            ,(PadTypePtr)Line);
      if (BVar11 == '\0') {
        BVar11 = IsPointInPad(pBVar13->X2,pBVar13->Y2,
                              (int)ROUND((float)Arc->Thickness * 0.5 + fBloat),(PadTypePtr)Line);
        return BVar11 != '\0';
      }
      return '\x01';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

int LOCtoLineArc_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[2].Y1 != 0) && ((b[1].Y1 & TheFlag) == 0)) {
    BVar1 = LineArcIntersect((LineTypePtr)((int)cl + 4),(ArcTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_ARC_TO_LIST(*cl,(ArcTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoArcLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineArcIntersect((LineTypePtr)b,(ArcTypePtr)((int)cl + 0xc4));
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_LINE_TO_LIST(*cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOT_Arccallback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[2].Y1 != 0) && ((b[1].Y1 & TheFlag) == 0)) {
    BVar1 = LineArcIntersect((LineTypePtr)((int)cl + 4),(ArcTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean ArcPadIntersect(ArcTypePtr Arc,PadTypePtr Pad)

{
  Boolean BVar1;
  
  BVar1 = LineArcIntersect((LineTypePtr)Pad,Arc);
  return BVar1;
}



// WARNING: Unknown calling convention

int LOCtoArcPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
                    // WARNING: Load size is inaccurate
  if (((TheFlag & b[1].Y1) == 0) && (*cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineArcIntersect((LineTypePtr)b,(ArcTypePtr)((int)cl + 0xc4));
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_PAD_TO_LIST(*cl,(PadTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPadArc_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[2].Y1 != 0) && ((b[1].Y1 & TheFlag) == 0)) {
    BVar1 = LineArcIntersect((LineTypePtr)((int)cl + 0x5c),(ArcTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_ARC_TO_LIST(*cl,(ArcTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void append_drc_dialog_message(char *fmt,...)

{
  uint uVar1;
  uint uVar2;
  size_t len;
  uint *puVar3;
  uint *puVar4;
  int iVar5;
  bool bVar6;
  
  puVar4 = (uint *)drc_dialog_message;
  do {
    puVar3 = puVar4;
    uVar1 = *puVar3 + 0xfefefeff & ~*puVar3;
    uVar2 = uVar1 & 0x80808080;
    puVar4 = puVar3 + 1;
  } while (uVar2 == 0);
  bVar6 = (uVar1 & 0x8080) == 0;
  if (bVar6) {
    uVar2 = uVar2 >> 0x10;
  }
  if (bVar6) {
    puVar4 = (uint *)((int)puVar3 + 6);
  }
  iVar5 = (int)puVar4 + (-3 - (uint)CARRY1((byte)uVar2,(byte)uVar2));
  __vsnprintf_chk(iVar5,0x120 - (iVar5 + -0x816c180),1,0xffffffff,fmt,&stack0x00000008);
  return;
}



// WARNING: Unknown calling convention

int throw_drc_dialog(void)

{
  int iVar1;
  int r;
  
  if (gui->drc_gui != (HID_DRC_GUI *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08096aee. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*gui->drc_gui->throw_drc_dialog)();
    return iVar1;
  }
  append_drc_dialog_message("Press Next to continue DRC checking");
  iVar1 = (*gui->confirm_dialog)(drc_dialog_message,"Cancel",&DAT_08147eea);
  drc_dialog_message[0] = '\0';
  if (gui->drc_gui != (HID_DRC_GUI *)0x0) {
    (*gui->drc_gui->reset_drc_dialog_message)();
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void append_drc_violation(DrcViolationType *violation)

{
  float fVar1;
  float fVar2;
  undefined4 uVar3;
  int Layer;
  undefined4 uVar4;
  LocationType local_14;
  LocationType local_10 [2];
  
  if (gui->drc_gui == (HID_DRC_GUI *)0x0) {
    append_drc_dialog_message("%s\n",violation->title);
    if (Settings.grid_units_mm == '\0') {
      uVar4 = 2;
      uVar3 = 2;
      fVar2 = (float)violation->y / 100.0;
      fVar1 = (float)violation->x / 100.0;
    }
    else {
      uVar4 = 4;
      uVar3 = 4;
      fVar2 = ((float)violation->y / 100000.0) * 25.4;
      fVar1 = (100000.0 / (float)violation->x) * 25.4;
    }
    append_drc_dialog_message("near (%.*f, %.*f)\n",uVar3,(double)fVar1,uVar4,(double)fVar2);
    LocateError(local_10,&local_14);
    if (((thing_type == 8) || (thing_type == 0x4000)) || (thing_type == 4)) {
      Layer = GetLayerNumber(PCB->Data,(LayerTypePtr)thing_ptr1);
      ChangeGroupVisibility(Layer,'\x01','\x01');
    }
    CenterDisplay(local_10[0],local_14,'\0');
  }
  else {
    (*gui->drc_gui->append_drc_violation)(violation);
  }
  if ((gui->drc_gui == (HID_DRC_GUI *)0x0) || (gui->drc_gui->log_drc_violations != 0)) {
    Message("WARNING!  Design Rule error - %s\n",violation->title);
    if (Settings.grid_units_mm == '\0') {
      uVar4 = 2;
      uVar3 = 2;
      fVar1 = (float)violation->y / 100.0;
      fVar2 = (float)violation->x / 100.0;
    }
    else {
      uVar4 = 4;
      uVar3 = 4;
      fVar1 = ((float)violation->y / 100000.0) * 25.4;
      fVar2 = (100000.0 / (float)violation->x) * 25.4;
    }
    Message("near location (%.*f, %.*f)\n",uVar3,(double)fVar2,uVar4,(double)fVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void ResetFoundLinesAndPolygons(Boolean AndDraw)

{
  int *piVar1;
  uint uVar2;
  bool bVar3;
  PCBTypePtr pPVar4;
  DataTypePtr paVar5;
  LayerTypePtr layer_1;
  LayerTypePtr pLVar6;
  LayerTypePtr layer;
  RatTypePtr line;
  RatTypePtr Line;
  Cardinal n_1;
  int iVar7;
  Cardinal n_2;
  Cardinal n_3;
  int iVar8;
  Cardinal n;
  LineTypePtr line_1;
  LineTypePtr Line_00;
  ArcTypePtr arc;
  ArcTypePtr Arc;
  PolygonTypePtr Polygon;
  uint local_24;
  
  bVar3 = false;
  paVar5 = PCB->Data;
  iVar7 = paVar5->RatN - 1;
  pPVar4 = PCB;
  if (iVar7 != -1) {
    iVar8 = paVar5->RatN * 0x5c;
    while( true ) {
      Line = (RatTypePtr)(paVar5->Rat[-1].Flags.t + iVar8 + -0x18);
      uVar2 = (Line->Flags).f;
      if ((TheFlag & uVar2) != 0) {
        if (AndDraw == '\0') {
          (Line->Flags).f = ~TheFlag & uVar2;
          bVar3 = true;
        }
        else {
          AddObjectToFlagUndoList(0x20,Line,Line,Line);
          (Line->Flags).f = (Line->Flags).f & ~TheFlag;
          DrawRat(Line,0);
          bVar3 = true;
          pPVar4 = PCB;
        }
      }
      if (iVar7 == 0) break;
      iVar7 = iVar7 + -1;
      paVar5 = pPVar4->Data;
      iVar8 = iVar8 + -0x5c;
    }
    paVar5 = pPVar4->Data;
  }
  pLVar6 = paVar5->Layer;
  if (paVar5->LayerN != 0) {
    local_24 = 0;
    do {
      iVar7 = pLVar6->LineN - 1;
      if (iVar7 != -1) {
        iVar8 = pLVar6->LineN * 0x58 + -0x58;
        do {
          while( true ) {
            Line_00 = (LineTypePtr)((pLVar6->Line->Flags).t + iVar8 + -0x18);
            uVar2 = (Line_00->Flags).f;
            if ((TheFlag & uVar2) != 0) break;
LAB_08096e13:
            iVar7 = iVar7 + -1;
            iVar8 = iVar8 + -0x58;
            pPVar4 = PCB;
            if (iVar7 == -1) goto LAB_08096e8d;
          }
          if (AndDraw == '\0') {
            (Line_00->Flags).f = ~TheFlag & uVar2;
            bVar3 = true;
            goto LAB_08096e13;
          }
          iVar7 = iVar7 + -1;
          iVar8 = iVar8 + -0x58;
          AddObjectToFlagUndoList(4,pLVar6,Line_00,Line_00);
          (Line_00->Flags).f = (Line_00->Flags).f & ~TheFlag;
          DrawLine(pLVar6,Line_00,0);
          bVar3 = true;
          pPVar4 = PCB;
        } while (iVar7 != -1);
      }
LAB_08096e8d:
      local_24 = local_24 + 1;
      uVar2 = pPVar4->Data->LayerN;
      if (uVar2 <= local_24) goto LAB_08096eb9;
      pLVar6 = pLVar6 + 1;
    } while( true );
  }
  goto LAB_08096ea7;
LAB_08096eb9:
  pLVar6 = pPVar4->Data->Layer;
  if (uVar2 != 0) {
    local_24 = 0;
    do {
      iVar7 = pLVar6->ArcN - 1;
      if (iVar7 != -1) {
        iVar8 = pLVar6->ArcN * 0x44 + -0x44;
        do {
          while( true ) {
            Arc = (ArcTypePtr)((pLVar6->Arc->Flags).t + iVar8 + -0x18);
            uVar2 = (Arc->Flags).f;
            if ((TheFlag & uVar2) != 0) break;
LAB_08096ef3:
            iVar7 = iVar7 + -1;
            iVar8 = iVar8 + -0x44;
            pPVar4 = PCB;
            if (iVar7 == -1) goto LAB_08096f6d;
          }
          if (AndDraw == '\0') {
            (Arc->Flags).f = ~TheFlag & uVar2;
            bVar3 = true;
            goto LAB_08096ef3;
          }
          iVar7 = iVar7 + -1;
          iVar8 = iVar8 + -0x44;
          AddObjectToFlagUndoList(0x4000,pLVar6,Arc,Arc);
          (Arc->Flags).f = (Arc->Flags).f & ~TheFlag;
          DrawArc(pLVar6,Arc,0);
          bVar3 = true;
          pPVar4 = PCB;
        } while (iVar7 != -1);
      }
LAB_08096f6d:
      local_24 = local_24 + 1;
      uVar2 = pPVar4->Data->LayerN;
      if (uVar2 <= local_24) goto LAB_08096f87;
      pLVar6 = pLVar6 + 1;
    } while( true );
  }
  goto LAB_08096ea7;
LAB_08096f87:
  pLVar6 = pPVar4->Data->Layer;
  if (uVar2 != 0) {
    local_24 = 0;
    do {
      iVar7 = pLVar6->PolygonN - 1;
      if (iVar7 != -1) {
        iVar8 = pLVar6->PolygonN * 0x3c + -0x3c;
        do {
          while( true ) {
            Polygon = (PolygonTypePtr)((pLVar6->Polygon->Flags).t + iVar8 + -0x18);
            uVar2 = (Polygon->Flags).f;
            if ((TheFlag & uVar2) != 0) break;
LAB_08096fc3:
            iVar7 = iVar7 + -1;
            iVar8 = iVar8 + -0x3c;
            pPVar4 = PCB;
            if (iVar7 == -1) goto LAB_0809703d;
          }
          if (AndDraw == '\0') {
            (Polygon->Flags).f = ~TheFlag & uVar2;
            bVar3 = true;
            goto LAB_08096fc3;
          }
          iVar7 = iVar7 + -1;
          iVar8 = iVar8 + -0x3c;
          AddObjectToFlagUndoList(8,pLVar6,Polygon,Polygon);
          (Polygon->Flags).f = (Polygon->Flags).f & ~TheFlag;
          DrawPolygon(pLVar6,Polygon,0);
          bVar3 = true;
          pPVar4 = PCB;
        } while (iVar7 != -1);
      }
LAB_0809703d:
      local_24 = local_24 + 1;
      piVar1 = &pPVar4->Data->LayerN;
      if ((uint)*piVar1 < local_24 || *piVar1 == local_24) break;
      pLVar6 = pLVar6 + 1;
    } while( true );
  }
LAB_08096ea7:
  if ((bVar3) && (SetChangedFlag('\x01'), AndDraw != '\0')) {
    IncrementUndoSerialNumber();
    Draw();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void ResetFoundPinsViasAndPads(Boolean AndDraw)

{
  uint uVar1;
  bool bVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  Cardinal sn_1;
  uint uVar5;
  Cardinal sn_2;
  DataTypePtr paVar6;
  uint uVar7;
  Cardinal n;
  Cardinal n_1;
  PadTypePtr Pad;
  PinTypePtr via;
  Cardinal n_2;
  PinTypePtr pin;
  PinTypePtr paVar8;
  uint uVar9;
  Cardinal sn;
  ElementTypePtr element;
  uchar *Ptr1;
  int local_2c;
  int local_28;
  
  bVar2 = false;
  paVar6 = PCB->Data;
  pPVar4 = PCB;
  if (paVar6->ViaN != 0) {
    uVar7 = 0;
    uVar5 = paVar6->ViaN;
    do {
      paVar8 = paVar6->Via + uVar7;
      uVar9 = (paVar8->Flags).f;
      if ((TheFlag & uVar9) == 0) {
LAB_080970cb:
        paVar6 = pPVar4->Data;
        uVar9 = paVar6->ViaN;
      }
      else {
        if (AndDraw == '\0') {
          (paVar8->Flags).f = ~TheFlag & uVar9;
          bVar2 = true;
          goto LAB_080970cb;
        }
        AddObjectToFlagUndoList(1,paVar8,paVar8,paVar8);
        (paVar8->Flags).f = (paVar8->Flags).f & ~TheFlag;
        DrawVia(paVar8,0);
        bVar2 = true;
        paVar6 = PCB->Data;
        uVar9 = paVar6->ViaN;
        pPVar4 = PCB;
      }
    } while ((uVar9 != 0) && (uVar7 = (uVar9 + 1 + uVar7) - uVar5, uVar5 = uVar9, uVar7 < uVar9));
  }
  local_28 = paVar6->ElementN - 1;
  if (local_28 != -1) {
    iVar3 = paVar6->ElementN * 300;
    do {
      local_2c = iVar3 + -300;
      Ptr1 = pPVar4->Data->Element[-1].Flags.t + iVar3 + -0x18;
      if (*(uint *)(Ptr1 + 0xe0) != 0) {
        uVar7 = 0;
        uVar5 = *(uint *)(Ptr1 + 0xe0);
        do {
          paVar8 = (PinTypePtr)(uVar7 * 0x4c + *(int *)(Ptr1 + 0x100));
          uVar9 = (paVar8->Flags).f;
          uVar1 = uVar5;
          if ((TheFlag & uVar9) != 0) {
            if (AndDraw == '\0') {
              (paVar8->Flags).f = ~TheFlag & uVar9;
              bVar2 = true;
            }
            else {
              AddObjectToFlagUndoList(0x100,Ptr1,paVar8,paVar8);
              (paVar8->Flags).f = (paVar8->Flags).f & ~TheFlag;
              DrawPin(paVar8,0);
              bVar2 = true;
              uVar1 = *(uint *)(Ptr1 + 0xe0);
            }
          }
        } while ((uVar1 != 0) && (uVar7 = (uVar7 + 1 + uVar1) - uVar5, uVar5 = uVar1, uVar7 < uVar1)
                );
      }
      uVar5 = *(uint *)(Ptr1 + 0xe8);
      uVar7 = uVar5;
      for (uVar9 = 0; (uVar7 != 0 && (uVar9 < uVar7)); uVar9 = uVar9 + (uVar5 == uVar7)) {
        Pad = (PadTypePtr)(uVar9 * 0x68 + *(int *)(Ptr1 + 0x104));
        uVar1 = (Pad->Flags).f;
        if ((TheFlag & uVar1) != 0) {
          if (AndDraw == '\0') {
            (Pad->Flags).f = ~TheFlag & uVar1;
            bVar2 = true;
          }
          else {
            AddObjectToFlagUndoList(0x200,Ptr1,Pad,Pad);
            (Pad->Flags).f = (Pad->Flags).f & ~TheFlag;
            DrawPad(Pad,0);
            uVar7 = *(uint *)(Ptr1 + 0xe8);
            bVar2 = true;
          }
        }
      }
      local_28 = local_28 + -1;
      pPVar4 = PCB;
      iVar3 = local_2c;
    } while (local_28 != -1);
  }
  if ((bVar2) && (SetChangedFlag('\x01'), AndDraw != '\0')) {
    IncrementUndoSerialNumber();
    Draw();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void ResetConnections(Boolean AndDraw)

{
  if (AndDraw == '\0') {
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    return;
  }
  SaveUndoSerialNumber();
  ResetFoundPinsViasAndPads(AndDraw);
  RestoreUndoSerialNumber();
  ResetFoundLinesAndPolygons(AndDraw);
  return;
}



// WARNING: Unknown calling convention

void PrintElementNameList(ElementTypePtr Element,FILE *FP)

{
  char *pcVar1;
  
  pcVar1 = Element->Name[0].TextString;
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "";
  }
  CreateQuotedString(&PrintElementNameList::cname,pcVar1);
  pcVar1 = Element->Name[1].TextString;
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "";
  }
  CreateQuotedString(&PrintElementNameList::pname,pcVar1);
  pcVar1 = Element->Name[2].TextString;
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "";
  }
  CreateQuotedString(&PrintElementNameList::vname,pcVar1);
  __fprintf_chk(FP,1,"(%s %s %s)\n",PrintElementNameList::cname.Data,
                PrintElementNameList::pname.Data,PrintElementNameList::vname.Data);
  return;
}



// WARNING: Unknown calling convention

void PrintConnectionElementName(ElementTypePtr Element,FILE *FP)

{
  fwrite("Element",1,7,(FILE *)FP);
  PrintElementNameList(Element,FP);
  fwrite(&DAT_08147f2f,1,2,(FILE *)FP);
  return;
}



// WARNING: Unknown calling convention

void PrintConnectionListEntry(char *ObjName,ElementTypePtr Element,Boolean FirstOne,FILE *FP)

{
  CreateQuotedString(&PrintConnectionListEntry::oname,ObjName);
  if (FirstOne == '\0') {
    __fprintf_chk(FP,1,&DAT_08147f32,PrintConnectionListEntry::oname.Data);
    if (Element != (ElementTypePtr)0x0) {
      PrintElementNameList(Element,FP);
      return;
    }
    fwrite("(__VIA__)\n",1,10,(FILE *)FP);
  }
  else {
    __fprintf_chk(FP,1,&DAT_08147f2a,PrintConnectionListEntry::oname.Data);
  }
  return;
}



// WARNING: Unknown calling convention

void PrintPinConnections(FILE *FP,Boolean IsFirst)

{
  PinTypePtr pv;
  char *pcVar1;
  uint uVar2;
  Cardinal i;
  int iVar3;
  
  if (PVList.Number != 0) {
    if (IsFirst != '\0') {
      pcVar1 = *(char **)((int)*PVList.Data + 0x3c);
      if (pcVar1 == (char *)0x0) {
        pcVar1 = "";
      }
      PrintConnectionListEntry(pcVar1,(ElementTypePtr)0x0,'\x01',FP);
    }
    uVar2 = (uint)(IsFirst != '\0');
    if (uVar2 < PVList.Number) {
      iVar3 = uVar2 * 4;
      do {
        pcVar1 = *(char **)(*(int *)((int)PVList.Data + iVar3) + 0x3c);
        if (pcVar1 == (char *)0x0) {
          pcVar1 = "";
        }
        PrintConnectionListEntry
                  (pcVar1,*(ElementTypePtr *)(*(int *)((int)PVList.Data + iVar3) + 0x44),'\0',FP);
        uVar2 = uVar2 + 1;
        iVar3 = iVar3 + 4;
      } while (uVar2 < PVList.Number);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void PrintPadConnections(Cardinal Layer,FILE *FP,Boolean IsFirst)

{
  int iVar1;
  Cardinal CVar2;
  PadTypePtr ptr;
  char *pcVar3;
  uint uVar4;
  Cardinal i;
  int iVar5;
  
  CVar2 = PadList[Layer].Number;
  if (CVar2 != 0) {
    if (IsFirst != '\0') {
      if (*PadList[Layer].Data == (void *)0x0) {
        __printf_chk(1,"Skipping NULL ptr in 1st part of PrintPadConnections\n");
        CVar2 = PadList[Layer].Number;
      }
      else {
        pcVar3 = *(char **)((int)*PadList[Layer].Data + 0x58);
        if ((pcVar3 == (char *)0x0) || (*pcVar3 == '\0')) {
          pcVar3 = "(unknown)";
        }
        PrintConnectionListEntry(pcVar3,(ElementTypePtr)0x0,'\x01',FP);
        CVar2 = PadList[Layer].Number;
      }
    }
    uVar4 = (uint)(IsFirst != '\0');
    if (uVar4 < CVar2) {
      iVar5 = uVar4 * 4;
      do {
        iVar1 = *(int *)((int)PadList[Layer].Data + iVar5);
        if (iVar1 == 0) {
          __printf_chk(1,"Skipping NULL ptr in 2nd part of PrintPadConnections\n");
        }
        else {
          pcVar3 = *(char **)(iVar1 + 0x58);
          if (pcVar3 == (char *)0x0) {
            pcVar3 = "";
          }
          PrintConnectionListEntry(pcVar3,*(ElementTypePtr *)(iVar1 + 0x60),'\0',FP);
        }
        uVar4 = uVar4 + 1;
        iVar5 = iVar5 + 4;
      } while (uVar4 <= PadList[Layer].Number && PadList[Layer].Number != uVar4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

Boolean IsLineInPolygon(LineTypePtr Line,PolygonTypePtr Polygon)

{
  LocationType *pLVar1;
  int iVar2;
  PLINE *pPVar3;
  Boolean BVar4;
  POLYAREA *a;
  POLYAREA *lp;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  
  if ((((*(byte *)&(Polygon->Flags).f & 0x10) == 0) || ((*(byte *)&(Line->Flags).f & 0x20) == 0)) &&
     (Polygon->Clipped != (POLYAREA *)0x0)) {
    if ((*(byte *)((int)&(Line->Flags).f + 1) & 1) != 0) {
      iVar6 = (Line->Point1).X;
      iVar2 = (Line->Point2).X;
      if (iVar6 == iVar2) {
        iVar5 = (Line->Point2).Y;
        iVar9 = (Line->Point1).Y;
LAB_08097782:
        iVar10 = (Line->Thickness + Bloat + 1) / 2;
        iVar7 = iVar5;
        if (iVar5 <= iVar9) {
          iVar7 = iVar9;
        }
        iVar8 = iVar6;
        if (iVar6 <= iVar2) {
          iVar8 = iVar2;
        }
        if (iVar9 <= iVar5) {
          iVar5 = iVar9;
        }
        if (iVar2 <= iVar6) {
          iVar6 = iVar2;
        }
        BVar4 = IsRectangleInPolygon
                          (iVar6 - iVar10,iVar5 - iVar10,iVar10 + iVar8,iVar7 + iVar10,Polygon);
        return BVar4;
      }
      iVar5 = (Line->Point1).Y;
      iVar9 = iVar5;
      if (iVar5 == (Line->Point2).Y) goto LAB_08097782;
    }
    pPVar3 = Polygon->Clipped->contours;
    iVar6 = pPVar3->xmax + Bloat;
    if ((((Line->BoundingBox).X1 == iVar6 || (Line->BoundingBox).X1 < iVar6) &&
        (pPVar3->xmin - Bloat <= (Line->BoundingBox).X2)) &&
       ((iVar6 = pPVar3->ymax + Bloat, pLVar1 = &(Line->BoundingBox).Y1,
        *pLVar1 == iVar6 || *pLVar1 < iVar6 &&
        ((pPVar3->ymin - Bloat <= (Line->BoundingBox).Y2 &&
         (a = LinePoly(Line,Bloat + Line->Thickness), a != (POLYAREA *)0x0)))))) {
      BVar4 = isects(a,Polygon,'\x01');
      return BVar4;
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean LookupLOConnectionsToLine(LineTypePtr Line,Cardinal LayerGroup,Boolean PolysTo)

{
  Cardinal *pCVar1;
  uint L;
  lo_info *plVar2;
  Boolean BVar3;
  int iVar4;
  PolygonTypePtr polygon;
  PolygonTypePtr Polygon;
  LineTypePtr pLVar5;
  Cardinal i;
  uint uVar6;
  LineType *pLVar7;
  int in_GS_OFFSET;
  uint local_264;
  lo_info info;
  int local_20;
  
  plVar2 = &info;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pLVar5 = Line;
  for (iVar4 = 0x16; pLVar7 = &plVar2->line, iVar4 != 0; iVar4 = iVar4 + -1) {
    plVar2 = (lo_info *)&pLVar7->BoundingBox;
    (pLVar7->BoundingBox).X1 = (pLVar5->BoundingBox).X1;
    pLVar5 = (LineTypePtr)&(pLVar5->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
    info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
    info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
    info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
  }
  info.layer = LayerGroup;
  iVar4 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar4 == 0) {
    r_search(PCB->Data->rat_tree,&info.line.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
             LOCtoLineRat_callback,&info);
    if ((PCB->LayerGroups).Number[LayerGroup] != 0) {
      local_264 = 0;
      do {
        L = (PCB->LayerGroups).Entries[LayerGroup][local_264];
        uVar6 = PCB->Data->LayerN;
        if (L < uVar6) {
          info.layer = L;
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08097865;
          r_search(PCB->Data->Layer[L].line_tree,&info.line.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoLineLine_callback,&info);
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08097865;
          r_search(PCB->Data->Layer[L].arc_tree,&info.line.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoLineArc_callback,&info);
          if ((PolysTo != '\0') &&
             (Polygon = PCB->Data->Layer[L].Polygon, PCB->Data->Layer[L].PolygonN != 0)) {
            uVar6 = 0;
            while( true ) {
              if (((((Polygon->Flags).f & TheFlag) == 0) &&
                  (BVar3 = IsLineInPolygon(Line,Polygon), BVar3 != '\0')) &&
                 (BVar3 = ADD_POLYGON_TO_LIST(L,Polygon), BVar3 != '\0')) goto LAB_08097865;
              uVar6 = uVar6 + 1;
              pCVar1 = &PCB->Data->Layer[L].PolygonN;
              if (*pCVar1 < uVar6 || *pCVar1 == uVar6) break;
              Polygon = Polygon + 1;
            }
          }
        }
        else {
          info.layer = L - uVar6;
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08097865;
          r_search(PCB->Data->pad_tree,&info.line.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   LOCtoLinePad_callback,&info);
        }
        local_264 = local_264 + 1;
        pCVar1 = (PCB->LayerGroups).Number + LayerGroup;
      } while (local_264 <= *pCVar1 && *pCVar1 != local_264);
    }
    BVar3 = '\0';
  }
  else {
LAB_08097865:
    BVar3 = '\x01';
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar3;
}



// WARNING: Unknown calling convention

Boolean LookupLOConnectionsToPad(PadTypePtr Pad,Cardinal LayerGroup)

{
  Cardinal *pCVar1;
  uint uVar2;
  uint uVar3;
  Boolean BVar4;
  int iVar5;
  PadType *pPVar6;
  int in_GS_OFFSET;
  uint local_264;
  lo_info info;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0) {
    BVar4 = LookupLOConnectionsToLine((LineTypePtr)Pad,LayerGroup,'\0');
  }
  else {
    pPVar6 = &info.pad;
    for (iVar5 = 0x1a; iVar5 != 0; iVar5 = iVar5 + -1) {
      (pPVar6->BoundingBox).X1 = (Pad->BoundingBox).X1;
      Pad = (PadTypePtr)&(Pad->BoundingBox).Y1;
      pPVar6 = (PadType *)&(pPVar6->BoundingBox).Y1;
    }
    if (0 < Bloat) {
      info.pad.BoundingBox.X1 = info.pad.BoundingBox.X1 - Bloat;
      info.pad.BoundingBox.X2 = info.pad.BoundingBox.X2 + Bloat;
      info.pad.BoundingBox.Y1 = info.pad.BoundingBox.Y1 - Bloat;
      info.pad.BoundingBox.Y2 = info.pad.BoundingBox.Y2 + Bloat;
    }
    info.layer = LayerGroup;
    iVar5 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar5 == 0) {
      r_search(PCB->Data->rat_tree,&info.pad.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               LOCtoPadRat_callback,&info);
      if ((PCB->LayerGroups).Number[LayerGroup] != 0) {
        local_264 = 0;
        do {
          uVar2 = (PCB->LayerGroups).Entries[LayerGroup][local_264];
          uVar3 = PCB->Data->LayerN;
          if (uVar2 < uVar3) {
            info.layer = uVar2;
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(PCB->Data->Layer[uVar2].line_tree,&info.pad.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPadLine_callback,&info);
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(PCB->Data->Layer[uVar2].arc_tree,&info.pad.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPadArc_callback,&info);
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(PCB->Data->Layer[uVar2].polygon_tree,&info.pad.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPadPoly_callback,&info);
          }
          else {
            info.layer = uVar2 - uVar3;
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(PCB->Data->pad_tree,&info.pad.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0
                     ,LOCtoPadPad_callback,&info);
          }
          local_264 = local_264 + 1;
          pCVar1 = (PCB->LayerGroups).Number + LayerGroup;
        } while (local_264 <= *pCVar1 && *pCVar1 != local_264);
      }
      BVar4 = '\0';
    }
    else {
LAB_08097b76:
      BVar4 = '\x01';
    }
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int LOCtoPolyLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = IsLineInPolygon((LineTypePtr)b,(PolygonTypePtr)((int)cl + 0x108));
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_LINE_TO_LIST(*cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean LOTouchesLine(LineTypePtr Line,Cardinal LayerGroup)

{
  Cardinal *pCVar1;
  uint uVar2;
  lo_info *plVar3;
  Boolean BVar4;
  int iVar5;
  PolygonTypePtr polygon;
  PolygonTypePtr Polygon;
  LineTypePtr pLVar6;
  Cardinal i;
  uint uVar7;
  LineType *pLVar8;
  int in_GS_OFFSET;
  uint local_260;
  lo_info info;
  int local_20;
  
  plVar3 = &info;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pLVar6 = Line;
  for (iVar5 = 0x16; pLVar8 = &plVar3->line, iVar5 != 0; iVar5 = iVar5 + -1) {
    plVar3 = (lo_info *)&pLVar8->BoundingBox;
    (pLVar8->BoundingBox).X1 = (pLVar6->BoundingBox).X1;
    pLVar6 = (LineTypePtr)&(pLVar6->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
    info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
    info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
    info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
  }
  if ((PCB->LayerGroups).Number[LayerGroup] != 0) {
    local_260 = 0;
    do {
      uVar2 = (PCB->LayerGroups).Entries[LayerGroup][local_260];
      uVar7 = PCB->Data->LayerN;
      if (uVar2 < uVar7) {
        iVar5 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar5 == 0) {
          r_search(PCB->Data->Layer[uVar2].line_tree,&info.line.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOT_Linecallback,&info);
          iVar5 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar5 == 0) {
            r_search(PCB->Data->Layer[uVar2].arc_tree,&info.line.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,LOT_Arccallback,&info);
            Polygon = PCB->Data->Layer[uVar2].Polygon;
            if (PCB->Data->Layer[uVar2].PolygonN != 0) {
              uVar7 = 0;
              while( true ) {
                if (((Polygon->Flags).f & TheFlag) == 0) {
                  BVar4 = IsLineInPolygon(Line,Polygon);
                  if (BVar4 != '\0') goto LAB_0809805c;
                }
                uVar7 = uVar7 + 1;
                pCVar1 = &PCB->Data->Layer[uVar2].PolygonN;
                if (*pCVar1 < uVar7 || *pCVar1 == uVar7) break;
                Polygon = Polygon + 1;
              }
            }
            goto LAB_080980df;
          }
        }
LAB_0809805c:
        BVar4 = '\x01';
        goto LAB_08098061;
      }
      info.layer = uVar2 - uVar7;
      iVar5 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar5 != 0) goto LAB_0809805c;
      r_search(PCB->Data->pad_tree,&info.line.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               LOT_Padcallback,&info);
LAB_080980df:
      local_260 = local_260 + 1;
      pCVar1 = (PCB->LayerGroups).Number + LayerGroup;
    } while (local_260 <= *pCVar1 && *pCVar1 != local_260);
  }
  BVar4 = '\0';
LAB_08098061:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean lineClear(LineTypePtr line,Cardinal group)

{
  Boolean BVar1;
  bool bVar2;
  
  BVar1 = LOTouchesLine(line,group);
  bVar2 = false;
  if (BVar1 == '\0') {
    BVar1 = PVTouchesLine(line);
    bVar2 = BVar1 == '\0';
  }
  return bVar2;
}



// WARNING: Unknown calling convention

Boolean IsPolygonInPolygon(PolygonTypePtr P1,PolygonTypePtr P2)

{
  int iVar1;
  POLYAREA *a;
  PLINE *pPVar2;
  PLINE *pPVar3;
  VNODE *pVVar4;
  Boolean BVar5;
  PLINE *c;
  VNODE *v;
  int in_GS_OFFSET;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  a = P1->Clipped;
  if ((a != (POLYAREA *)0x0) && (P2->Clipped != (POLYAREA *)0x0)) {
    pPVar2 = a->contours;
    pPVar3 = P2->Clipped->contours;
    if ((pPVar2->xmin - Bloat <= pPVar3->xmax) &&
       (((pPVar3->xmin <= pPVar2->xmax + Bloat && (pPVar2->ymin - Bloat <= pPVar3->ymax)) &&
        (pPVar3->ymin <= Bloat + pPVar2->ymax)))) {
      BVar5 = isects(a,P2,'\0');
      if (BVar5 != '\0') {
LAB_080982f4:
        BVar5 = '\x01';
        goto LAB_0809823a;
      }
      if (0 < Bloat) {
        for (pPVar2 = P1->Clipped->contours; pPVar2 != (PLINE *)0x0; pPVar2 = pPVar2->next) {
          pPVar3 = P2->Clipped->contours;
          if (((pPVar2->xmin - Bloat <= pPVar3->xmax) && (pPVar3->xmin <= pPVar2->xmax + Bloat)) &&
             ((pPVar2->ymin - Bloat <= pPVar3->ymax && (pPVar3->ymin <= pPVar2->ymax + Bloat)))) {
            line.Point1.X = (pPVar2->head).point[0];
            line.Thickness = Bloat * 2;
            line.Point1.Y = (pPVar2->head).point[1];
            line.Clearance = 0;
            MakeFlags(0);
            for (pVVar4 = (pPVar2->head).next; &pPVar2->head != pVVar4; pVVar4 = pVVar4->next) {
              line.Point2.X = pVVar4->point[0];
              line.Point2.Y = pVVar4->point[1];
              SetLineBoundingBox(&line);
              BVar5 = IsLineInPolygon(&line,P2);
              if (BVar5 != '\0') goto LAB_080982f4;
              line.Point1.X = line.Point2.X;
              line.Point1.Y = line.Point2.Y;
            }
          }
        }
      }
    }
  }
  BVar5 = '\0';
LAB_0809823a:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar5;
}



// WARNING: Unknown calling convention

Boolean LookupLOConnectionsToPolygon(PolygonTypePtr Polygon,Cardinal LayerGroup)

{
  Cardinal *pCVar1;
  int iVar2;
  uint L;
  Boolean BVar3;
  int iVar4;
  PolygonTypePtr polygon;
  PolygonTypePtr P1;
  Cardinal i;
  uint uVar5;
  int in_GS_OFFSET;
  uint local_268;
  lo_info info;
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    info.polygon.BoundingBox.X1 = (Polygon->BoundingBox).X1;
    info.polygon.BoundingBox.Y1 = (Polygon->BoundingBox).Y1;
    info.polygon.BoundingBox.X2 = (Polygon->BoundingBox).X2;
    info.polygon.BoundingBox.Y2 = (Polygon->BoundingBox).Y2;
    info.polygon.ID = Polygon->ID;
    info.polygon.Flags.f = (Polygon->Flags).f;
    info.polygon.Flags.t._0_4_ = *(undefined4 *)(Polygon->Flags).t;
    info.polygon.Flags.t._4_4_ = *(undefined4 *)((Polygon->Flags).t + 4);
    info.polygon.net = Polygon->net;
    info.polygon.PointN = Polygon->PointN;
    info.polygon.PointMax = Polygon->PointMax;
    info.polygon.Clipped = Polygon->Clipped;
    info.polygon.NoHoles = Polygon->NoHoles;
    info.polygon.NoHolesValid = Polygon->NoHolesValid;
    info.polygon.Points = Polygon->Points;
    if (0 < Bloat) {
      info.polygon.BoundingBox.X1 = info.polygon.BoundingBox.X1 - Bloat;
      info.polygon.BoundingBox.X2 = info.polygon.BoundingBox.X2 + Bloat;
      info.polygon.BoundingBox.Y1 = info.polygon.BoundingBox.Y1 - Bloat;
      info.polygon.BoundingBox.Y2 = info.polygon.BoundingBox.Y2 + Bloat;
    }
    info.layer = LayerGroup;
    iVar4 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar4 != 0) {
LAB_08098409:
      BVar3 = '\x01';
      goto LAB_0809840e;
    }
    r_search(PCB->Data->rat_tree,&info.polygon.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
             LOCtoPolyRat_callback,&info);
    if ((PCB->LayerGroups).Number[LayerGroup] != 0) {
      local_268 = 0;
      do {
        L = (PCB->LayerGroups).Entries[LayerGroup][local_268];
        uVar5 = PCB->Data->LayerN;
        if (L < uVar5) {
          P1 = PCB->Data->Layer[L].Polygon;
          if (PCB->Data->Layer[L].PolygonN != 0) {
            uVar5 = 0;
            while( true ) {
              if (((((P1->Flags).f & TheFlag) == 0) &&
                  (BVar3 = IsPolygonInPolygon(P1,Polygon), BVar3 != '\0')) &&
                 (BVar3 = ADD_POLYGON_TO_LIST(L,P1), BVar3 != '\0')) goto LAB_08098409;
              uVar5 = uVar5 + 1;
              pCVar1 = &PCB->Data->Layer[L].PolygonN;
              if (*pCVar1 < uVar5 || *pCVar1 == uVar5) break;
              P1 = P1 + 1;
            }
          }
          info.layer = L;
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08098409;
          r_search(PCB->Data->Layer[L].line_tree,&info.polygon.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPolyLine_callback,&info);
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08098409;
          r_search(PCB->Data->Layer[L].arc_tree,&info.polygon.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPolyArc_callback,&info);
        }
        else if ((*(byte *)&(Polygon->Flags).f & 0x10) == 0) {
          info.layer = L - uVar5;
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08098409;
          r_search(PCB->Data->pad_tree,&info.polygon.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPolyPad_callback,&info);
        }
        local_268 = local_268 + 1;
        pCVar1 = (PCB->LayerGroups).Number + LayerGroup;
      } while (local_268 <= *pCVar1 && *pCVar1 != local_268);
    }
  }
  BVar3 = '\0';
LAB_0809840e:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar3;
}



// WARNING: Unknown calling convention

Boolean IsPadInPolygon(PadTypePtr pad,PolygonTypePtr polygon)

{
  Boolean BVar1;
  
  BVar1 = IsLineInPolygon((LineTypePtr)pad,polygon);
  return BVar1;
}



// WARNING: Unknown calling convention

int LOCtoPolyPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
                    // WARNING: Load size is inaccurate
  if (((TheFlag & b[1].Y1) == 0) && (*cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = IsLineInPolygon((LineTypePtr)b,(PolygonTypePtr)((int)cl + 0x108));
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_PAD_TO_LIST(*cl,(PadTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPadPoly_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if (((TheFlag & b[1].Y1) == 0) && ((b[1].Y1 & 0x10U) == 0)) {
    BVar1 = IsLineInPolygon((LineTypePtr)((int)cl + 0x5c),(PolygonTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_POLYGON_TO_LIST(*cl,(PolygonTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean IsArcInPolygon(ArcTypePtr Arc,PolygonTypePtr Polygon)

{
  LocationType *pLVar1;
  PLINE *pPVar2;
  Boolean BVar3;
  POLYAREA *a;
  POLYAREA *ap;
  int iVar4;
  
  if ((((((*(byte *)&(Polygon->Flags).f & 0x10) == 0) || ((*(byte *)&(Arc->Flags).f & 0x20) == 0))
       && (Polygon->Clipped != (POLYAREA *)0x0)) &&
      ((pPVar2 = Polygon->Clipped->contours, iVar4 = pPVar2->xmax + Bloat,
       (Arc->BoundingBox).X1 == iVar4 || (Arc->BoundingBox).X1 < iVar4 &&
       (pPVar2->xmin - Bloat <= (Arc->BoundingBox).X2)))) &&
     ((iVar4 = pPVar2->ymax + Bloat, pLVar1 = &(Arc->BoundingBox).Y1,
      *pLVar1 == iVar4 || *pLVar1 < iVar4 &&
      ((pPVar2->ymin - Bloat <= (Arc->BoundingBox).Y2 &&
       (a = ArcPoly((ArcType *)Arc,Bloat + Arc->Thickness), a != (POLYAREA *)0x0)))))) {
    BVar3 = isects(a,Polygon,'\x01');
    return BVar3;
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean LookupLOConnectionsToArc(ArcTypePtr Arc,Cardinal LayerGroup)

{
  Cardinal *pCVar1;
  uint L;
  Boolean BVar2;
  int iVar3;
  PolygonTypePtr polygon;
  PolygonTypePtr Polygon;
  ArcTypePtr paVar4;
  Cardinal i;
  uint uVar5;
  ArcType *pAVar6;
  int in_GS_OFFSET;
  uint local_264;
  lo_info info;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  paVar4 = Arc;
  pAVar6 = &info.arc;
  for (iVar3 = 0x11; iVar3 != 0; iVar3 = iVar3 + -1) {
    (pAVar6->BoundingBox).X1 = (paVar4->BoundingBox).X1;
    paVar4 = (ArcTypePtr)&(paVar4->BoundingBox).Y1;
    pAVar6 = (ArcType *)&(pAVar6->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.arc.BoundingBox.X1 = info.arc.BoundingBox.X1 - Bloat;
    info.arc.BoundingBox.X2 = info.arc.BoundingBox.X2 + Bloat;
    info.arc.BoundingBox.Y1 = info.arc.BoundingBox.Y1 - Bloat;
    info.arc.BoundingBox.Y2 = info.arc.BoundingBox.Y2 + Bloat;
  }
  if ((PCB->LayerGroups).Number[LayerGroup] != 0) {
    local_264 = 0;
    do {
      L = (PCB->LayerGroups).Entries[LayerGroup][local_264];
      uVar5 = PCB->Data->LayerN;
      if (L < uVar5) {
        info.layer = L;
        iVar3 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar3 == 0) {
          r_search(PCB->Data->Layer[L].line_tree,&info.arc.BoundingBox,
                   (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoArcLine_callback,&info);
          iVar3 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar3 == 0) {
            r_search(PCB->Data->Layer[L].arc_tree,&info.arc.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoArcArc_callback,&info);
            Polygon = PCB->Data->Layer[L].Polygon;
            if (PCB->Data->Layer[L].PolygonN != 0) {
              uVar5 = 0;
              while( true ) {
                if (((Polygon->Flags).f & TheFlag) == 0) {
                  BVar2 = IsArcInPolygon(Arc,Polygon);
                  if (BVar2 != '\0') {
                    BVar2 = ADD_POLYGON_TO_LIST(L,Polygon);
                    if (BVar2 != '\0') goto LAB_08098a35;
                  }
                }
                uVar5 = uVar5 + 1;
                pCVar1 = &PCB->Data->Layer[L].PolygonN;
                if (*pCVar1 < uVar5 || *pCVar1 == uVar5) break;
                Polygon = Polygon + 1;
              }
            }
            goto LAB_08098ab7;
          }
        }
LAB_08098a35:
        BVar2 = '\x01';
        goto LAB_08098a3a;
      }
      info.layer = L - uVar5;
      iVar3 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar3 != 0) goto LAB_08098a35;
      r_search(PCB->Data->pad_tree,&info.arc.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               LOCtoArcPad_callback,&info);
LAB_08098ab7:
      local_264 = local_264 + 1;
      pCVar1 = (PCB->LayerGroups).Number + LayerGroup;
    } while (local_264 <= *pCVar1 && *pCVar1 != local_264);
  }
  BVar2 = '\0';
LAB_08098a3a:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int LOCtoPolyArc_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[2].Y1 != 0) && ((b[1].Y1 & TheFlag) == 0)) {
    BVar1 = IsArcInPolygon((ArcTypePtr)b,(PolygonTypePtr)((int)cl + 0x108));
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_ARC_TO_LIST(*cl,(ArcTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void form_slanted_rectangle(PointType *p,LineTypePtr l)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int dY;
  int w;
  int iVar4;
  int dX;
  double dwx;
  longdouble lVar5;
  longdouble lVar6;
  longdouble lVar7;
  double dwy;
  
  iVar3 = (l->Point2).Y - (l->Point1).Y;
  iVar1 = (l->Point1).X;
  iVar2 = l->Thickness;
  if (iVar3 == 0) {
    lVar6 = (longdouble)(iVar2 / 2);
    lVar5 = (longdouble)0;
  }
  else {
    iVar4 = (l->Point2).X - iVar1;
    if (iVar4 == 0) {
      lVar5 = (longdouble)(iVar2 / 2);
      lVar6 = (longdouble)0;
    }
    else {
      lVar6 = (longdouble)iVar4;
      lVar7 = (longdouble)iVar3;
      lVar5 = SQRT(lVar7 * lVar7 + lVar6 * lVar6);
      lVar5 = (longdouble)iVar2 / (lVar5 + lVar5);
      lVar6 = lVar6 * lVar5;
      lVar5 = lVar5 * lVar7;
    }
  }
  p->X = (int)ROUND(((longdouble)iVar1 - lVar6) + lVar5);
  p->Y = (int)ROUND(((longdouble)(l->Point1).Y - lVar5) - lVar6);
  p[1].X = (int)ROUND(((longdouble)(l->Point1).X - lVar6) - lVar5);
  p[1].Y = (int)ROUND(((longdouble)(l->Point1).Y - lVar5) + lVar6);
  p[2].X = (int)ROUND(((longdouble)(l->Point2).X + lVar6) - lVar5);
  p[2].Y = (int)ROUND((longdouble)(l->Point2).Y + lVar5 + lVar6);
  p[3].X = (int)ROUND((longdouble)(l->Point2).X + lVar6 + lVar5);
  p[3].Y = (int)ROUND(((longdouble)(l->Point2).Y + lVar5) - lVar6);
  return;
}



// WARNING: Removing unreachable block (ram,0x08098d68)
// WARNING: Removing unreachable block (ram,0x08098d70)
// WARNING: Removing unreachable block (ram,0x08098dda)
// WARNING: Unknown calling convention

Boolean LineLineIntersect(LineTypePtr Line1,LineTypePtr Line2)

{
  int Y;
  int Y_00;
  int X;
  int Y_01;
  int Y_02;
  int X_00;
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  Boolean BVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  BDimension BVar10;
  float r;
  float s;
  float dx;
  float dy;
  float dx1;
  float dy1;
  PointType p [4];
  
  if ((*(byte *)((int)&(Line1->Flags).f + 1) & 1) != 0) {
    form_slanted_rectangle(p,Line1);
    BVar6 = IsLineInQuadrangle(p,Line2);
    return BVar6;
  }
  if (((Line2->Flags).f & 0x100) != 0) {
    form_slanted_rectangle(p,Line2);
    BVar6 = IsLineInQuadrangle(p,Line1);
    return BVar6;
  }
  iVar7 = (Line1->Point2).X;
  iVar8 = (Line1->Point1).X;
  Y = (Line1->Point2).Y;
  fVar5 = (float)(iVar7 - iVar8);
  Y_00 = (Line1->Point1).Y;
  X = (Line2->Point1).X;
  fVar4 = (float)(Y - Y_00);
  Y_01 = (Line2->Point1).Y;
  Y_02 = (Line2->Point2).Y;
  iVar9 = Y_02 - Y_01;
  X_00 = (Line2->Point2).X;
  fVar2 = (float)(Y_00 - Y_01) * fVar5 - (float)(iVar8 - X) * fVar4;
  fVar3 = (float)(X_00 - X);
  fVar1 = (float)iVar9 * fVar5 - fVar3 * fVar4;
  if (fVar1 == 0.0) {
    if ((fVar5 == 0.0) && (fVar4 == 0.0)) {
      BVar10 = Line1->Thickness / 2 + Bloat;
      if (BVar10 < 0) {
        BVar10 = 0;
      }
      BVar6 = IsPointInPad(iVar8,Y_00,BVar10,(PadTypePtr)Line2);
    }
    else {
      fVar1 = (float)(Line1->Thickness + Line2->Thickness) * 0.5 + fBloat;
      if (fVar1 <= 0.0) {
        fVar1 = 0.0;
      }
      BVar6 = '\0';
      if ((fVar4 * fVar4 + fVar5 * fVar5) / (fVar2 * fVar2) <= fVar1 * fVar1) {
        BVar10 = Line2->Thickness / 2 + Bloat;
        if (BVar10 < 0) {
          BVar10 = 0;
        }
        BVar6 = IsPointInPad(X,Y_01,BVar10,(PadTypePtr)Line1);
        if (BVar6 == '\0') {
          BVar10 = Line2->Thickness / 2 + Bloat;
          if (BVar10 < 0) {
            BVar10 = 0;
          }
          BVar6 = IsPointInPad((Line2->Point2).X,(Line2->Point2).Y,BVar10,(PadTypePtr)Line1);
          if (BVar6 == '\0') {
            BVar10 = Line1->Thickness / 2 + Bloat;
            if (BVar10 < 0) {
              BVar10 = 0;
            }
            BVar6 = IsPointInPad((Line1->Point1).X,(Line1->Point1).Y,BVar10,(PadTypePtr)Line2);
            if (BVar6 != '\0') {
              return '\x01';
            }
            BVar10 = Line1->Thickness / 2 + Bloat;
            if (BVar10 < 0) {
              BVar10 = 0;
            }
            BVar6 = IsPointInPad((Line1->Point2).X,(Line1->Point2).Y,BVar10,(PadTypePtr)Line2);
            return BVar6 != '\0';
          }
        }
        return '\x01';
      }
    }
  }
  else {
    fVar2 = fVar2 / fVar1;
    fVar1 = fVar1 / (fVar3 * (float)(Y_00 - Y_01) - (float)(iVar8 - X) * (float)iVar9);
    if ((fVar1 < 0.0) || (1.0 < fVar1)) {
      if ((fVar2 < 0.0) || (1.0 < fVar2)) {
        BVar6 = IsPointInPad(iVar8,Y_00,(int)ROUND((float)Line1->Thickness * 0.5 + fBloat),
                             (PadTypePtr)Line2);
        if (BVar6 != '\0') {
          return '\x01';
        }
        BVar6 = IsPointInPad((Line1->Point2).X,(Line1->Point2).Y,
                             (int)ROUND((float)Line1->Thickness * 0.5 + fBloat),(PadTypePtr)Line2);
        if (BVar6 != '\0') {
          return '\x01';
        }
        BVar6 = IsPointInPad((Line2->Point1).X,(Line2->Point1).Y,
                             (int)ROUND((float)Line2->Thickness * 0.5 + fBloat),(PadTypePtr)Line1);
        if (BVar6 != '\0') {
          return '\x01';
        }
        BVar6 = IsPointInPad((Line2->Point2).X,(Line2->Point2).Y,
                             (int)ROUND((float)Line2->Thickness * 0.5 + fBloat),(PadTypePtr)Line1);
      }
      else if (0.0 <= fVar1) {
        iVar8 = 0;
        fVar2 = (float)Line1->Thickness * 0.5 + fBloat;
        if (0.0 < fVar2) {
          iVar8 = (int)ROUND(fVar2);
        }
        BVar6 = IsPointInPad(iVar7,Y,iVar8,(PadTypePtr)Line2);
      }
      else {
        iVar7 = 0;
        fVar2 = (float)Line1->Thickness * 0.5 + fBloat;
        if (0.0 < fVar2) {
          iVar7 = (int)ROUND(fVar2);
        }
        BVar6 = IsPointInPad(iVar8,Y_00,iVar7,(PadTypePtr)Line2);
      }
    }
    else {
      if ((0.0 <= fVar2) && (fVar2 <= 1.0)) {
        return '\x01';
      }
      if (0.0 <= fVar2) {
        iVar7 = 0;
        fVar2 = (float)Line2->Thickness * 0.5 + fBloat;
        if (0.0 < fVar2) {
          iVar7 = (int)ROUND(fVar2);
        }
        BVar6 = IsPointInPad(X_00,Y_02,iVar7,(PadTypePtr)Line1);
      }
      else {
        iVar7 = 0;
        fVar2 = (float)Line2->Thickness * 0.5 + fBloat;
        if (0.0 < fVar2) {
          iVar7 = (int)ROUND(fVar2);
        }
        BVar6 = IsPointInPad(X,Y_01,iVar7,(PadTypePtr)Line1);
      }
    }
  }
  return BVar6;
}



// WARNING: Unknown calling convention

int LOCtoLineLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_LINE_TO_LIST(*cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOT_Linecallback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean LinePadIntersect(LineTypePtr Line,PadTypePtr Pad)

{
  Boolean BVar1;
  
  BVar1 = LineLineIntersect(Line,(LineTypePtr)Pad);
  return BVar1;
}



// WARNING: Unknown calling convention

int LOCtoLinePad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
                    // WARNING: Load size is inaccurate
  if (((TheFlag & b[1].Y1) == 0) && (*cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_PAD_TO_LIST(*cl,(PadTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPadPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
                    // WARNING: Load size is inaccurate
  if (((TheFlag & b[1].Y1) == 0) && (*cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineLineIntersect((LineTypePtr)b,(LineTypePtr)((int)cl + 0x5c));
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_PAD_TO_LIST(*cl,(PadTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOCtoPadLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineLineIntersect((LineTypePtr)b,(LineTypePtr)((int)cl + 0x5c));
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_LINE_TO_LIST(*cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int LOT_Padcallback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
                    // WARNING: Load size is inaccurate
  if (((TheFlag & b[1].Y1) == 0) && (*cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void InitLayoutLookup(void)

{
  size_t sVar1;
  PCBTypePtr pPVar2;
  void *pvVar3;
  char *Number;
  rtree_t **pprVar4;
  int iVar5;
  uint uVar6;
  Cardinal i;
  DataTypePtr paVar7;
  
  paVar7 = PCB->Data;
  if (paVar7->LayerN != 0) {
    iVar5 = 0;
    uVar6 = 0;
    do {
      sVar1 = paVar7->Layer[uVar6].LineN;
      if (sVar1 == 0) {
        pprVar4 = paVar7->name_tree + uVar6 * 0x17 + -0xe;
        Number = (char *)pprVar4[0x17];
        if (Number != (char *)0x0) goto LAB_080995ea;
LAB_08099518:
        pprVar4 = paVar7->name_tree + uVar6 * 0x17 + -0xe;
        sVar1 = (size_t)pprVar4[0x16];
      }
      else {
        pvVar3 = MyCalloc(sVar1,4,"InitLayoutLookup()");
        *(void **)((int)&LineList[0].Data + iVar5) = pvVar3;
        pprVar4 = paVar7->name_tree + uVar6 * 0x17 + -0xe;
        *(Cardinal *)((int)&LineList[0].Size + iVar5) = paVar7->Layer[uVar6].LineN;
        Number = (char *)pprVar4[0x17];
        if (Number == (char *)0x0) goto LAB_08099518;
LAB_080995ea:
        pvVar3 = MyCalloc((size_t)Number,4,"InitLayoutLookup()");
        *(void **)((int)&ArcList[0].Data + iVar5) = pvVar3;
        *(rtree_t **)((int)&ArcList[0].Size + iVar5) = pprVar4[0x17];
        pprVar4 = paVar7->name_tree + uVar6 * 0x17 + -0xe;
        sVar1 = (size_t)pprVar4[0x16];
      }
      if (sVar1 != 0) {
        pvVar3 = MyCalloc(sVar1,4,"InitLayoutLookup()");
        *(void **)((int)&PolygonList[0].Data + iVar5) = pvVar3;
        *(rtree_t **)((int)&PolygonList[0].Size + iVar5) = pprVar4[0x16];
      }
      pPVar2 = PCB;
      uVar6 = uVar6 + 1;
      *(undefined4 *)((int)&LineList[0].Location + iVar5) = 0;
      *(undefined4 *)((int)&LineList[0].DrawLocation + iVar5) = 0;
      *(undefined4 *)((int)&LineList[0].Number + iVar5) = 0;
      paVar7 = pPVar2->Data;
      *(undefined4 *)((int)&ArcList[0].Location + iVar5) = 0;
      *(undefined4 *)((int)&ArcList[0].DrawLocation + iVar5) = 0;
      *(undefined4 *)((int)&ArcList[0].Number + iVar5) = 0;
      *(undefined4 *)((int)&PolygonList[0].Location + iVar5) = 0;
      *(undefined4 *)((int)&PolygonList[0].DrawLocation + iVar5) = 0;
      *(undefined4 *)((int)&PolygonList[0].Number + iVar5) = 0;
      iVar5 = iVar5 + 0x14;
    } while (uVar6 <= (uint)paVar7->LayerN && paVar7->LayerN != uVar6);
  }
  if (paVar7->pin_tree == (rtree_t *)0x0) {
    TotalP = 0;
  }
  else {
    TotalP = paVar7->pin_tree->size;
  }
  if (paVar7->via_tree == (rtree_t *)0x0) {
    TotalV = 0;
  }
  else {
    TotalV = paVar7->via_tree->size;
  }
  PVList.Data = (void **)MyCalloc(TotalV + TotalP,4,"InitLayoutLookup()");
  PVList.Location = 0;
  PVList.DrawLocation = 0;
  PVList.Number = 0;
  PVList.Size = TotalV + TotalP;
  RatList.Data = (void **)MyCalloc(PCB->Data->RatN,4,"InitLayoutLookup()");
  RatList.Location = 0;
  RatList.DrawLocation = 0;
  RatList.Number = 0;
  RatList.Size = PCB->Data->RatN;
  return;
}



// WARNING: Unknown calling convention

void InitComponentLookup(void)

{
  Cardinal CVar1;
  PadTypePtr paVar2;
  Cardinal CVar3;
  Cardinal n;
  uint uVar4;
  Cardinal sn;
  Cardinal *pCVar5;
  int local_20;
  
  NumberOfPads[0] = 0;
  NumberOfPads[1] = 0;
  CVar1 = PCB->Data->ElementN;
  local_20 = CVar1 - 1;
  CVar3 = 0;
  if (local_20 != -1) {
    NumberOfPads[1] = 0;
    pCVar5 = &PCB->Data->Element[CVar1 - 1].PadN;
    do {
      if (*pCVar5 != 0) {
        paVar2 = (PadTypePtr)pCVar5[7];
        uVar4 = 0;
        do {
          if (*(char *)&(paVar2->Flags).f < '\0') {
            CVar3 = CVar3 + 1;
          }
          else {
            NumberOfPads[1] = NumberOfPads[1] + 1;
          }
          uVar4 = uVar4 + 1;
          paVar2 = paVar2 + 1;
        } while (uVar4 < *pCVar5);
      }
      local_20 = local_20 + -1;
      pCVar5 = pCVar5 + -0x4b;
      NumberOfPads[0] = CVar3;
    } while (local_20 != -1);
  }
  PadList[0].Data = (void **)MyCalloc(NumberOfPads[0],4,"InitComponentLookup()");
  PadList[0].Location = 0;
  PadList[0].DrawLocation = 0;
  PadList[0].Number = 0;
  PadList[0].Size = NumberOfPads[0];
  PadList[1].Data = (void **)MyCalloc(NumberOfPads[1],4,"InitComponentLookup()");
  PadList[1].Location = 0;
  PadList[1].DrawLocation = 0;
  PadList[1].Number = 0;
  PadList[1].Size = NumberOfPads[1];
  return;
}



// WARNING: Unknown calling convention

void InitConnectionLookup(void)

{
  InitComponentLookup();
  InitLayoutLookup();
  return;
}



// WARNING: Unknown calling convention

void FreeComponentLookupMemory(void)

{
  SaveFree(PadList[0].Data);
  PadList[0].Data = (void **)0x0;
  SaveFree(PadList[1].Data);
  PadList[1].Data = (void **)0x0;
  return;
}



// WARNING: Unknown calling convention

void FreeLayoutLookupMemory(void)

{
  int *piVar1;
  void *pvVar2;
  PCBTypePtr pPVar3;
  int iVar4;
  uint uVar5;
  Cardinal i;
  
  if (PCB->Data->LayerN != 0) {
    iVar4 = 0;
    uVar5 = 0;
    do {
      uVar5 = uVar5 + 1;
      SaveFree(*(void **)((int)&LineList[0].Data + iVar4));
      pvVar2 = *(void **)((int)&ArcList[0].Data + iVar4);
      *(undefined4 *)((int)&LineList[0].Data + iVar4) = 0;
      SaveFree(pvVar2);
      pvVar2 = *(void **)((int)&PolygonList[0].Data + iVar4);
      *(undefined4 *)((int)&ArcList[0].Data + iVar4) = 0;
      SaveFree(pvVar2);
      pPVar3 = PCB;
      *(undefined4 *)((int)&PolygonList[0].Data + iVar4) = 0;
      iVar4 = iVar4 + 0x14;
      piVar1 = &pPVar3->Data->LayerN;
    } while (uVar5 <= (uint)*piVar1 && *piVar1 != uVar5);
  }
  SaveFree(PVList.Data);
  PVList.Data = (void **)0x0;
  SaveFree(RatList.Data);
  RatList.Data = (void **)0x0;
  return;
}



// WARNING: Unknown calling convention

void FreeConnectionLookupMemory(void)

{
  FreeComponentLookupMemory();
  FreeLayoutLookupMemory();
  return;
}



// WARNING: Unknown calling convention

Boolean PinLineIntersect(PinTypePtr PV,LineTypePtr Line)

{
  float fVar1;
  Boolean BVar2;
  int iVar3;
  
  if ((*(byte *)((int)&(PV->Flags).f + 1) & 1) != 0) {
    iVar3 = (PV->Thickness + 1) / 2;
    BVar2 = IsLineInRectangle(-iVar3 + PV->X,-iVar3 + PV->Y,iVar3 + PV->X,iVar3 + PV->Y,Line);
    return BVar2;
  }
  iVar3 = 0;
  fVar1 = (float)PV->Thickness * 0.5 + fBloat;
  if (0.0 < fVar1) {
    iVar3 = (int)ROUND(fVar1);
  }
  BVar2 = IsPointInPad(PV->X,PV->Y,iVar3,(PadTypePtr)Line);
  return BVar2;
}



// WARNING: Unknown calling convention

int LOCtoPVline_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = PinLineIntersect((PinTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      BVar1 = ADD_LINE_TO_LIST(*cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x50,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pv_line_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = PinLineIntersect((PinTypePtr)b,(LineTypePtr)((int)cl + 4));
    if (BVar1 != '\0') {
      if ((b[1].Y1 & 8U) != 0) {
        b[1].Y1 = b[1].Y1 | 0x200;
        Settings.RatWarn = '\x01';
        Message("WARNING: Hole too close to line.\n");
      }
      BVar1 = ADD_PV_TO_LIST((PinTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pv_touch_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = PinLineIntersect((PinTypePtr)b,(LineTypePtr)((int)cl + 4));
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



DrcViolationType * __regparm3
pcb_drc_violation_new
          (char *title,char *explanation,int x,int y,int angle,int have_measured,
          double measured_value,double required_value,int value_digits,char *value_units,
          int object_count,long *object_id_list,int *object_type_list)

{
  DrcViolationType *pDVar1;
  char *pcVar2;
  
  pDVar1 = (DrcViolationType *)calloc(1,0x3c);
  pcVar2 = (char *)__strdup(title);
  pDVar1->title = pcVar2;
  pcVar2 = (char *)__strdup(explanation);
  pDVar1->angle = 0;
  pDVar1->x = x;
  pDVar1->explanation = pcVar2;
  pDVar1->measured_value = (double)CONCAT44(measured_value._0_4_,have_measured);
  pDVar1->y = y;
  pDVar1->required_value = (double)CONCAT44(required_value._0_4_,measured_value._4_4_);
  pDVar1->have_measured = angle;
  pDVar1->value_digits = required_value._4_4_;
  pDVar1->value_units = (char *)value_digits;
  pDVar1->object_count = (int)value_units;
  pDVar1->object_id_list = (long *)object_count;
  pDVar1->object_type_list = object_id_list;
  return pDVar1;
}



// WARNING: Unknown calling convention

int drc_callback(DataTypePtr data,LayerTypePtr layer,PolygonTypePtr polygon,int type,void *ptr1,
                void *ptr2)

{
  float fVar1;
  Boolean BVar2;
  undefined1 *value_digits;
  DrcViolationType *violation_00;
  int iVar3;
  undefined4 uVar4;
  DrcViolationType *violation;
  int *in_stack_ffffffb0;
  char *local_40;
  long *local_30;
  long *local_2c;
  char *local_28;
  int local_24;
  int local_20 [4];
  
  thing_type = type;
  thing_ptr1 = ptr1;
  thing_ptr2 = ptr2;
  thing_ptr3 = ptr2;
  if (type == 0x100) {
    if (SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
        *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) {
      AddObjectToFlagUndoList(0x100,ptr1,ptr2,ptr2);
      *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
      local_40 = "Pin with insufficient clearance inside polygon\n";
      goto doIsBad;
    }
  }
  else if (type < 0x101) {
    if (type == 1) {
      iVar3 = *(int *)((int)ptr2 + 0x28);
      if ((iVar3 != 0) && (SBORROW4(iVar3,PCB->Bloat * 2) != iVar3 + PCB->Bloat * -2 < 0)) {
        AddObjectToFlagUndoList(1,ptr1,ptr2,ptr2);
        *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
        local_40 = "Via with insufficient clearance inside polygon\n";
        goto doIsBad;
      }
    }
    else {
      if (type != 4) goto LAB_08099cc2;
      if (SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
          *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) {
        AddObjectToFlagUndoList(4,ptr1,ptr2,ptr2);
        *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
        local_40 = "Line with insufficient clearance inside polygon\n";
        goto doIsBad;
      }
    }
  }
  else if (type == 0x200) {
    if ((SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
         *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) &&
       (BVar2 = IsLineInPolygon((LineTypePtr)ptr2,polygon), BVar2 != '\0')) {
      AddObjectToFlagUndoList(0x200,ptr1,ptr2,ptr2);
      *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
      local_40 = "Pad with insufficient clearance inside polygon\n";
doIsBad:
      AddObjectToFlagUndoList(8,layer,polygon,polygon);
      (polygon->Flags).f = (polygon->Flags).f | 4;
      DrawPolygon(layer,polygon,0);
      DrawObject(type,ptr1,ptr2,0);
      drcerr_count = drcerr_count + 1;
      LocateError(local_20,&local_24);
      BuildObjectList((int *)&local_28,&local_2c,&local_30);
      if (Settings.grid_units_mm == '\0') {
        uVar4 = 2;
        value_digits = &DAT_08147f6c;
        fVar1 = (float)PCB->Bloat / 100.0;
      }
      else {
        uVar4 = 4;
        value_digits = &DAT_0815627e;
        fVar1 = ((float)PCB->Bloat / 100000.0) * 25.4;
      }
      violation_00 = pcb_drc_violation_new
                               (local_40,
                                "Circuits that are too close may bridge during imaging, etching,\nplating, or soldering processes resulting in a direct short."
                                ,local_20[0],local_24,0,0,(double)((longlong)(double)fVar1 << 0x20),
                                (double)CONCAT44(uVar4,(int)((ulonglong)(double)fVar1 >> 0x20)),
                                (int)value_digits,local_28,(int)local_2c,local_30,in_stack_ffffffb0)
      ;
      append_drc_violation(violation_00);
      pcb_drc_violation_free(violation_00);
      free(local_2c);
      free(local_30);
      iVar3 = throw_drc_dialog();
      if (iVar3 != 0) {
        IncrementUndoSerialNumber();
        Undo('\x01');
        return 0;
      }
      IsBad = '\x01';
      return 1;
    }
  }
  else {
    if (type != 0x4000) {
LAB_08099cc2:
      Message("hace: Bad Plow object in callback\n");
      return 0;
    }
    if (SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
        *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) {
      AddObjectToFlagUndoList(0x4000,ptr1,ptr2,ptr2);
      *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
      local_40 = "Arc with insufficient clearance inside polygon\n";
      goto doIsBad;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean LookupLOConnectionsToRatEnd(PointTypePtr Point,Cardinal LayerGroup)

{
  Cardinal *pCVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint local_d0;
  rat_info info;
  BoxType box;
  
  if ((PCB->LayerGroups).Number[LayerGroup] != 0) {
    local_d0 = 0;
    info.Point = Point;
    do {
      uVar2 = (PCB->LayerGroups).Entries[LayerGroup][local_d0];
      uVar3 = PCB->Data->LayerN;
      if (uVar2 < uVar3) {
        info.layer = uVar2;
        iVar4 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar4 != 0) {
          return '\x01';
        }
        box.X1 = Point->X + -1;
        box.X2 = Point->X + 1;
        box.Y1 = Point->Y + -1;
        box.Y2 = Point->Y + 1;
        r_search(PCB->Data->Layer[uVar2].line_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 LOCtoRat_callback,&info);
        iVar4 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar4 == 0) {
          box.X1 = Point->X + -1;
          box.X2 = Point->X + 1;
          box.Y1 = Point->Y + -1;
          box.Y2 = Point->Y + 1;
          r_search(PCB->Data->Layer[uVar2].polygon_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   PolygonToRat_callback,&info);
        }
      }
      else {
        info.layer = uVar2 - uVar3;
        iVar4 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar4 != 0) {
          return '\x01';
        }
        box.X1 = Point->X + -1;
        box.X2 = Point->X + 1;
        box.Y1 = Point->Y + -1;
        box.Y2 = Point->Y + 1;
        r_search(PCB->Data->pad_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,LOCtoPad_callback,
                 &info);
      }
      local_d0 = local_d0 + 1;
      pCVar1 = (PCB->LayerGroups).Number + LayerGroup;
    } while (local_d0 <= *pCVar1 && *pCVar1 != local_d0);
  }
  return '\0';
}



// WARNING: Unknown calling convention

Boolean LookupPVConnectionsToLOList(Boolean AndRats)

{
  uint *puVar1;
  int iVar2;
  int *piVar3;
  Boolean BVar4;
  uint uVar5;
  int iVar6;
  Cardinal CVar7;
  Cardinal CVar8;
  LocationType *pLVar9;
  LineType *pLVar10;
  PadType *pPVar11;
  ArcType *pAVar12;
  RatType *pRVar13;
  int in_GS_OFFSET;
  byte bVar14;
  int local_278;
  uint local_274;
  int local_270;
  BoxType box;
  lo_info info;
  
  bVar14 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  CVar7 = TotalV;
  CVar8 = TotalP;
  if (PCB->Data->LayerN != 0) {
    local_270 = 0;
    local_274 = 0;
    do {
      if (CVar8 + CVar7 == 0) {
        *(undefined4 *)((int)&LineList[0].Location + local_270) =
             *(undefined4 *)((int)&LineList[0].Number + local_270);
        *(undefined4 *)((int)&ArcList[0].Location + local_270) =
             *(undefined4 *)((int)&ArcList[0].Number + local_270);
        *(undefined4 *)((int)&PolygonList[0].Location + local_270) =
             *(undefined4 *)((int)&PolygonList[0].Number + local_270);
      }
      else {
        uVar5 = *(uint *)((int)&LineList[0].Location + local_270);
        if (uVar5 < *(uint *)((int)&LineList[0].Number + local_270)) {
          do {
            pLVar9 = *(LocationType **)(*(int *)((int)&LineList[0].Data + local_270) + uVar5 * 4);
            pLVar10 = &info.line;
            for (iVar6 = 0x16; iVar6 != 0; iVar6 = iVar6 + -1) {
              (pLVar10->BoundingBox).X1 = *pLVar9;
              pLVar9 = pLVar9 + (uint)bVar14 * -2 + 1;
              pLVar10 = (LineType *)((int)pLVar10 + (uint)bVar14 * -8 + 4);
            }
            if (0 < Bloat) {
              info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
              info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
              info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
              info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
            }
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->via_tree,&info.line.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,pv_line_callback,&info);
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->pin_tree,&info.line.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,pv_line_callback,&info);
            uVar5 = *(int *)((int)&LineList[0].Location + local_270) + 1;
            puVar1 = (uint *)((int)&LineList[0].Number + local_270);
            *(uint *)((int)&LineList[0].Location + local_270) = uVar5;
          } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        }
        uVar5 = *(uint *)((int)&ArcList[0].Location + local_270);
        if (uVar5 < *(uint *)((int)&ArcList[0].Number + local_270)) {
          do {
            pLVar9 = *(LocationType **)(*(int *)((int)&ArcList[0].Data + local_270) + uVar5 * 4);
            pAVar12 = &info.arc;
            for (iVar6 = 0x11; iVar6 != 0; iVar6 = iVar6 + -1) {
              (pAVar12->BoundingBox).X1 = *pLVar9;
              pLVar9 = pLVar9 + (uint)bVar14 * -2 + 1;
              pAVar12 = (ArcType *)((int)pAVar12 + (uint)bVar14 * -8 + 4);
            }
            if (0 < Bloat) {
              info.arc.BoundingBox.X1 = info.arc.BoundingBox.X1 - Bloat;
              info.arc.BoundingBox.X2 = info.arc.BoundingBox.X2 + Bloat;
              info.arc.BoundingBox.Y1 = info.arc.BoundingBox.Y1 - Bloat;
              info.arc.BoundingBox.Y2 = info.arc.BoundingBox.Y2 + Bloat;
            }
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->via_tree,&info.arc.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0
                     ,pv_arc_callback,&info);
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->pin_tree,&info.arc.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0
                     ,pv_arc_callback,&info);
            uVar5 = *(int *)((int)&ArcList[0].Location + local_270) + 1;
            puVar1 = (uint *)((int)&ArcList[0].Number + local_270);
            *(uint *)((int)&ArcList[0].Location + local_270) = uVar5;
          } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        }
        uVar5 = *(uint *)((int)&PolygonList[0].Location + local_270);
        info.layer = local_274;
        CVar7 = TotalV;
        CVar8 = TotalP;
        if (uVar5 < *(uint *)((int)&PolygonList[0].Number + local_270)) {
          do {
            piVar3 = *(int **)(*(int *)((int)&PolygonList[0].Data + local_270) + uVar5 * 4);
            info.polygon.BoundingBox.X1 = *piVar3;
            info.polygon.BoundingBox.Y1 = piVar3[1];
            info.polygon.BoundingBox.X2 = piVar3[2];
            info.polygon.BoundingBox.Y2 = piVar3[3];
            info.polygon.ID = piVar3[4];
            info.polygon.Flags.f = piVar3[5];
            info.polygon.Flags.t._0_4_ = piVar3[6];
            info.polygon.Flags.t._4_4_ = piVar3[7];
            info.polygon.net = (LibraryEntryType *)piVar3[8];
            info.polygon.PointN = piVar3[9];
            info.polygon.PointMax = piVar3[10];
            info.polygon.Clipped = (POLYAREA *)piVar3[0xb];
            info.polygon.NoHoles = (PLINE *)piVar3[0xc];
            info.polygon.NoHolesValid = piVar3[0xd];
            info.polygon.Points = (PointTypePtr)piVar3[0xe];
            if (0 < Bloat) {
              info.polygon.BoundingBox.X1 = info.polygon.BoundingBox.X1 - Bloat;
              info.polygon.BoundingBox.X2 = info.polygon.BoundingBox.X2 + Bloat;
              info.polygon.BoundingBox.Y1 = info.polygon.BoundingBox.Y1 - Bloat;
              info.polygon.BoundingBox.Y2 = info.polygon.BoundingBox.Y2 + Bloat;
            }
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->via_tree,&info.polygon.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,pv_poly_callback,&info);
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->pin_tree,&info.polygon.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,pv_poly_callback,&info);
            uVar5 = *(int *)((int)&PolygonList[0].Location + local_270) + 1;
            puVar1 = (uint *)((int)&PolygonList[0].Number + local_270);
            *(uint *)((int)&PolygonList[0].Location + local_270) = uVar5;
            CVar7 = TotalV;
            CVar8 = TotalP;
          } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        }
      }
      local_274 = local_274 + 1;
      local_270 = local_270 + 0x14;
      piVar3 = &PCB->Data->LayerN;
    } while (local_274 <= (uint)*piVar3 && *piVar3 != local_274);
  }
  local_278 = 0;
  do {
    iVar6 = CVar8 + CVar7;
    if (iVar6 == 0) {
      *(undefined4 *)((int)&PadList[0].Location + local_278) =
           *(undefined4 *)((int)&PadList[0].Number + local_278);
    }
    else {
      uVar5 = *(uint *)((int)&PadList[0].Location + local_278);
      if (uVar5 < *(uint *)((int)&PadList[0].Number + local_278)) {
        do {
          pLVar9 = *(LocationType **)(*(int *)((int)&PadList[0].Data + local_278) + uVar5 * 4);
          pPVar11 = &info.pad;
          for (iVar6 = 0x1a; iVar6 != 0; iVar6 = iVar6 + -1) {
            (pPVar11->BoundingBox).X1 = *pLVar9;
            pLVar9 = pLVar9 + (uint)bVar14 * -2 + 1;
            pPVar11 = (PadType *)((int)pPVar11 + (uint)bVar14 * -8 + 4);
          }
          if (0 < Bloat) {
            info.pad.BoundingBox.X1 = info.pad.BoundingBox.X1 - Bloat;
            info.pad.BoundingBox.X2 = info.pad.BoundingBox.X2 + Bloat;
            info.pad.BoundingBox.Y1 = info.pad.BoundingBox.Y1 - Bloat;
            info.pad.BoundingBox.Y2 = info.pad.BoundingBox.Y2 + Bloat;
          }
          iVar6 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar6 != 0) goto LAB_0809a3c8;
          r_search(PCB->Data->via_tree,&info.pad.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   pv_pad_callback,&info);
          iVar6 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar6 != 0) goto LAB_0809a3c8;
          r_search(PCB->Data->pin_tree,&info.pad.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   pv_pad_callback,&info);
          uVar5 = *(int *)((int)&PadList[0].Location + local_278) + 1;
          puVar1 = (uint *)((int)&PadList[0].Number + local_278);
          *(uint *)((int)&PadList[0].Location + local_278) = uVar5;
        } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        iVar6 = TotalV + TotalP;
        CVar7 = TotalV;
        CVar8 = TotalP;
      }
    }
    local_278 = local_278 + 0x14;
  } while (local_278 != 0x28);
  if (iVar6 == 0) {
    RatList.Location = RatList.Number;
  }
  if ((AndRats != '\0') && (RatList.Location < RatList.Number)) {
    do {
      pLVar9 = (LocationType *)RatList.Data[RatList.Location];
      pRVar13 = &info.rat;
      for (iVar6 = 0x17; iVar6 != 0; iVar6 = iVar6 + -1) {
        (pRVar13->BoundingBox).X1 = *pLVar9;
        pLVar9 = pLVar9 + (uint)bVar14 * -2 + 1;
        pRVar13 = (RatType *)((int)pRVar13 + (uint)bVar14 * -8 + 4);
      }
      box.X1 = info.rat.Point1.X + -1;
      box.X2 = info.rat.Point1.X + 1;
      box.Y1 = info.rat.Point1.Y + -1;
      box.Y2 = info.rat.Point1.Y + 1;
      r_search(PCB->Data->via_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,&info)
      ;
      box.X1 = info.rat.Point2.X + -1;
      box.X2 = info.rat.Point2.X + 1;
      box.Y1 = info.rat.Point2.Y + -1;
      box.Y2 = info.rat.Point2.Y + 1;
      r_search(PCB->Data->via_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,&info)
      ;
      box.X1 = info.rat.Point1.X + -1;
      box.X2 = info.rat.Point1.X + 1;
      box.Y1 = info.rat.Point1.Y + -1;
      box.Y2 = info.rat.Point1.Y + 1;
      r_search(PCB->Data->pin_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,&info)
      ;
      box.X1 = info.rat.Point2.X + -1;
      box.X2 = info.rat.Point2.X + 1;
      box.Y1 = info.rat.Point2.Y + -1;
      box.Y2 = info.rat.Point2.Y + 1;
      r_search(PCB->Data->pin_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,&info)
      ;
      RatList.Location = RatList.Location + 1;
    } while (RatList.Location < RatList.Number);
  }
  BVar4 = '\0';
LAB_0809a3cd:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar4;
LAB_0809a3c8:
  BVar4 = '\x01';
  goto LAB_0809a3cd;
}



// WARNING: Unknown calling convention

Boolean DoIt(Boolean AndRats,Boolean AndDraw)

{
  Cardinal *pCVar1;
  LineTypePtr *ppLVar2;
  ArcTypePtr *ppaVar3;
  PolygonTypePtr *pppVar4;
  PadTypePtr *ppaVar5;
  RatTypePtr *ppaVar6;
  PinTypePtr Pin;
  char cVar7;
  Boolean BVar8;
  int iVar9;
  PCBTypePtr pPVar10;
  PinTypePtr pv;
  Cardinal i_1;
  Cardinal layer;
  int i;
  int iVar11;
  Boolean empty;
  DataTypePtr paVar12;
  Cardinal position;
  uint uVar13;
  uint uVar14;
  Cardinal CVar15;
  Cardinal *position_1;
  uint *puVar16;
  Cardinal group;
  int iVar17;
  Cardinal CVar18;
  bool bVar19;
  int *local_fc;
  int local_f8;
  uint local_f4;
  uint local_f0;
  Cardinal arcposition [16];
  Cardinal polyposition [16];
  Cardinal lineposition [16];
  Cardinal padposition [2];
  
LAB_0809aaf8:
  cVar7 = LookupPVConnectionsToPVList();
  if ((cVar7 == '\0') && (cVar7 = LookupLOConnectionsToPVList(AndRats), cVar7 == '\0')) {
    iVar17 = PCB->Data->LayerN;
    if (iVar17 != 0) {
      iVar11 = 0;
      iVar9 = 0;
      do {
        lineposition[iVar9] = *(Cardinal *)((int)&LineList[0].Location + iVar11);
        polyposition[iVar9] = *(Cardinal *)((int)&PolygonList[0].Location + iVar11);
        pCVar1 = (Cardinal *)((int)&ArcList[0].Location + iVar11);
        iVar11 = iVar11 + 0x14;
        arcposition[iVar9] = *pCVar1;
        iVar9 = iVar9 + 1;
      } while (iVar9 != iVar17);
    }
    padposition[0] = PadList[0].Location;
    padposition[1] = PadList[1].Location;
    pPVar10 = PCB;
    CVar18 = RatList.Location;
    do {
      if ((AndRats != '\0') && (CVar18 < RatList.Number)) {
        iVar17 = CVar18 * 4;
        do {
          BVar8 = LookupLOConnectionsToRatEnd
                            ((PointTypePtr)(*(int *)((int)RatList.Data + iVar17) + 0x2c),
                             *(Cardinal *)(*(int *)((int)RatList.Data + iVar17) + 0x54));
          if ((BVar8 != '\0') ||
             (BVar8 = LookupLOConnectionsToRatEnd
                                ((PointTypePtr)(*(int *)((int)RatList.Data + iVar17) + 0x40),
                                 *(Cardinal *)(*(int *)((int)RatList.Data + iVar17) + 0x58)),
             BVar8 != '\0')) goto LAB_0809b090;
          CVar18 = CVar18 + 1;
          iVar17 = iVar17 + 4;
          pPVar10 = PCB;
        } while (CVar18 < RatList.Number);
      }
      uVar14 = pPVar10->Data->LayerN;
      if (uVar14 == 0) {
        local_f4 = 0;
      }
      else {
        CVar15 = 0;
        do {
          if ((pPVar10->LayerGroups).Number[CVar15] != 0) {
            local_f0 = 0;
            while( true ) {
              uVar13 = (pPVar10->LayerGroups).Entries[CVar15][local_f0];
              if (uVar13 < uVar14) {
                puVar16 = lineposition + uVar13;
                uVar14 = *puVar16;
                if (uVar14 < LineList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToLine
                                      ((LineTypePtr)LineList[uVar13].Data[uVar14],CVar15,'\x01');
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar16 + 1;
                    *puVar16 = uVar14;
                  } while (uVar14 < LineList[uVar13].Number);
                }
                puVar16 = arcposition + uVar13;
                uVar14 = *puVar16;
                if (uVar14 < ArcList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToArc
                                      ((ArcTypePtr)ArcList[uVar13].Data[uVar14],CVar15);
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar16 + 1;
                    *puVar16 = uVar14;
                  } while (uVar14 < ArcList[uVar13].Number);
                }
                puVar16 = polyposition + uVar13;
                uVar14 = *puVar16;
                pPVar10 = PCB;
                if (uVar14 < PolygonList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToPolygon
                                      ((PolygonTypePtr)PolygonList[uVar13].Data[uVar14],CVar15);
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar16 + 1;
                    *puVar16 = uVar14;
                    pPVar10 = PCB;
                  } while (uVar14 < PolygonList[uVar13].Number);
                }
              }
              else {
                uVar13 = uVar13 - uVar14;
                if (1 < uVar13) {
                  Message("bad layer number %d max_layer=%d in find.c\n",uVar13,uVar14);
                  goto LAB_0809b37f;
                }
                puVar16 = padposition + uVar13;
                uVar14 = *puVar16;
                if (uVar14 < PadList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToPad
                                      ((PadTypePtr)PadList[uVar13].Data[uVar14],CVar15);
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar16 + 1;
                    *puVar16 = uVar14;
                    pPVar10 = PCB;
                  } while (uVar14 < PadList[uVar13].Number);
                }
              }
              local_f0 = local_f0 + 1;
              if ((pPVar10->LayerGroups).Number[CVar15] <= local_f0) break;
              uVar14 = pPVar10->Data->LayerN;
            }
            uVar14 = pPVar10->Data->LayerN;
          }
          CVar15 = CVar15 + 1;
          local_f4 = uVar14;
        } while (CVar15 < uVar14);
      }
      bVar19 = AndRats == '\0' || RatList.Number <= CVar18;
      if (uVar14 != 0xfffffffe) {
        iVar17 = 0;
        puVar16 = padposition + -local_f4;
        uVar13 = 0;
        do {
          if (uVar13 < local_f4) {
            if (bVar19) {
              if ((lineposition[uVar13] < *(uint *)((int)&LineList[0].Number + iVar17)) ||
                 (arcposition[uVar13] < *(uint *)((int)&ArcList[0].Number + iVar17))) {
                bVar19 = false;
              }
              else {
                bVar19 = *(uint *)((int)&PolygonList[0].Number + iVar17) <= polyposition[uVar13];
              }
            }
          }
          else if (bVar19) {
            bVar19 = *(uint *)(local_f4 * -0x14 + 0x816c6cc + iVar17) <= *puVar16;
          }
          uVar13 = uVar13 + 1;
          puVar16 = puVar16 + 1;
          iVar17 = iVar17 + 0x14;
        } while (uVar13 < uVar14 + 2);
      }
    } while (!bVar19);
LAB_0809b37f:
    cVar7 = LookupPVConnectionsToLOList(AndRats);
  }
  goto LAB_0809ab0b;
LAB_0809b090:
  cVar7 = '\x01';
LAB_0809ab0b:
  CVar18 = RatList.DrawLocation;
  if (AndDraw != '\0') {
    paVar12 = PCB->Data;
    local_f8 = paVar12->LayerN + -1;
    pPVar10 = PCB;
    if (local_f8 != -1) {
      local_fc = LayerStack + local_f8;
      while( true ) {
        iVar17 = *local_fc;
        if (paVar12->Layer[iVar17].On != '\0') {
          uVar14 = LineList[iVar17].Number;
          uVar13 = LineList[iVar17].DrawLocation;
          if (uVar13 < uVar14) {
            iVar9 = uVar13 * 4;
            while( true ) {
              uVar13 = uVar13 + 1;
              ppLVar2 = (LineTypePtr *)((int)LineList[iVar17].Data + iVar9);
              iVar9 = iVar9 + 4;
              DrawLine(paVar12->Layer + iVar17,*ppLVar2,0);
              uVar14 = LineList[iVar17].Number;
              pPVar10 = PCB;
              if (uVar14 <= uVar13) break;
              paVar12 = PCB->Data;
            }
          }
          LineList[iVar17].DrawLocation = uVar14;
          uVar14 = ArcList[iVar17].DrawLocation;
          uVar13 = ArcList[iVar17].Number;
          if (uVar14 < uVar13) {
            iVar9 = uVar14 * 4;
            do {
              uVar14 = uVar14 + 1;
              ppaVar3 = (ArcTypePtr *)((int)ArcList[iVar17].Data + iVar9);
              iVar9 = iVar9 + 4;
              DrawArc(pPVar10->Data->Layer + iVar17,*ppaVar3,0);
              uVar13 = ArcList[iVar17].Number;
              pPVar10 = PCB;
            } while (uVar14 < uVar13);
          }
          uVar14 = PolygonList[iVar17].DrawLocation;
          ArcList[iVar17].DrawLocation = uVar13;
          uVar13 = PolygonList[iVar17].Number;
          if (uVar14 < uVar13) {
            iVar9 = uVar14 * 4;
            do {
              uVar14 = uVar14 + 1;
              pppVar4 = (PolygonTypePtr *)((int)PolygonList[iVar17].Data + iVar9);
              iVar9 = iVar9 + 4;
              DrawPolygon(pPVar10->Data->Layer + iVar17,*pppVar4,0);
              uVar13 = PolygonList[iVar17].Number;
              pPVar10 = PCB;
            } while (uVar14 < uVar13);
          }
          PolygonList[iVar17].DrawLocation = uVar13;
        }
        local_f8 = local_f8 + -1;
        local_fc = local_fc + -1;
        if (local_f8 == -1) break;
        paVar12 = pPVar10->Data;
      }
    }
    iVar17 = 0;
    if (pPVar10->PinOn == '\0') {
      if (PVList.DrawLocation < PVList.Number) {
LAB_0809ae93:
        do {
          Pin = (PinTypePtr)PVList.Data[PVList.DrawLocation];
          if ((*(byte *)&(Pin->Flags).f & 1) == 0) {
            if (pPVar10->ViaOn != '\0') {
              DrawVia(Pin,0);
              pPVar10 = PCB;
            }
          }
          else if (pPVar10->PinOn != '\0') {
            DrawPin(Pin,0);
            pPVar10 = PCB;
          }
          PVList.DrawLocation = PVList.DrawLocation + 1;
        } while (PVList.DrawLocation < PVList.Number);
      }
    }
    else {
      do {
        uVar14 = *(uint *)((int)&PadList[0].DrawLocation + iVar17);
        uVar13 = *(uint *)((int)&PadList[0].Number + iVar17);
        if (uVar14 < uVar13) {
          iVar9 = uVar14 * 4;
          do {
            uVar14 = uVar14 + 1;
            ppaVar5 = (PadTypePtr *)(*(int *)((int)&PadList[0].Data + iVar17) + iVar9);
            iVar9 = iVar9 + 4;
            DrawPad(*ppaVar5,0);
            uVar13 = *(uint *)((int)&PadList[0].Number + iVar17);
          } while (uVar14 < uVar13);
        }
        *(uint *)((int)&PadList[0].DrawLocation + iVar17) = uVar13;
        iVar17 = iVar17 + 0x14;
      } while (iVar17 != 0x28);
      pPVar10 = PCB;
      if (PVList.DrawLocation < PVList.Number) goto LAB_0809ae93;
    }
    CVar18 = RatList.DrawLocation;
    if ((pPVar10->RatOn != '\0') && (CVar18 = RatList.Number, RatList.DrawLocation < RatList.Number)
       ) {
      iVar17 = RatList.DrawLocation * 4;
      CVar15 = RatList.DrawLocation;
      do {
        CVar15 = CVar15 + 1;
        ppaVar6 = (RatTypePtr *)((int)RatList.Data + iVar17);
        iVar17 = iVar17 + 4;
        DrawRat(*ppaVar6,0);
        CVar18 = RatList.Number;
      } while (CVar15 < RatList.Number);
    }
  }
  RatList.DrawLocation = CVar18;
  if (cVar7 != '\0') goto LAB_0809ab99;
  bVar19 = PVList.Number <= PVList.Location;
  if (AndRats == '\0') {
    iVar17 = PCB->Data->LayerN;
    if (iVar17 < 1 || !bVar19) {
LAB_0809abf9:
      if (bVar19) {
LAB_0809ab99:
        if (AndDraw != '\0') {
          Draw();
        }
        return cVar7;
      }
      goto LAB_0809aaf8;
    }
  }
  else {
    if ((!bVar19) || (RatList.Location < RatList.Number)) goto LAB_0809aaf8;
    bVar19 = true;
    iVar17 = PCB->Data->LayerN;
    if (iVar17 < 1) goto LAB_0809abf9;
  }
  iVar9 = 0;
  iVar11 = 0;
  while (((*(uint *)((int)&LineList[0].Number + iVar9) <=
           *(uint *)((int)&LineList[0].Location + iVar9) &&
          (*(uint *)((int)&ArcList[0].Number + iVar9) <=
           *(uint *)((int)&ArcList[0].Location + iVar9))) &&
         (*(uint *)((int)&PolygonList[0].Number + iVar9) <=
          *(uint *)((int)&PolygonList[0].Location + iVar9)))) {
    iVar11 = iVar11 + 1;
    iVar9 = iVar9 + 0x14;
    if (iVar17 <= iVar11) goto LAB_0809ab99;
  }
  goto LAB_0809aaf8;
}



// WARNING: Unknown calling convention

Boolean DRCFind(int What,void *ptr1,void *ptr2,void *ptr3)

{
  float fVar1;
  Boolean BVar2;
  undefined4 uVar3;
  DrcViolationType *pDVar4;
  int iVar5;
  undefined1 *puVar6;
  DrcViolationType *violation;
  int *in_stack_ffffffb0;
  long *local_30;
  long *local_2c;
  char *local_28;
  int local_24;
  int local_20 [4];
  
  if (PCB->Shrink != 0) {
    Bloat = -PCB->Shrink;
    fBloat = (float)Bloat;
    TheFlag = 0x1040;
    ListStart(What,ptr1,ptr2,ptr3);
    DoIt('\x01','\0');
    DumpList();
    TheFlag = 4;
    ListStart(What,ptr1,ptr2,ptr3);
    Bloat = 0;
    fBloat = 0.0;
    drc = '\x01';
    BVar2 = DoIt('\x01','\0');
    if (BVar2 != '\0') {
      DumpList();
      TheFlag = 0x44;
      ResetConnections('\0');
      User = '\x01';
      drc = '\0';
      Bloat = -PCB->Shrink;
      fBloat = (float)Bloat;
      TheFlag = 0x40;
      RestoreUndoSerialNumber();
      ListStart(What,ptr1,ptr2,ptr3);
      DoIt('\x01','\x01');
      DumpList();
      ListStart(What,ptr1,ptr2,ptr3);
      TheFlag = 4;
      Bloat = 0;
      fBloat = 0.0;
      drc = '\x01';
      DoIt('\x01','\x01');
      DumpList();
      drcerr_count = drcerr_count + 1;
      User = '\0';
      drc = '\0';
      LocateError(local_20,&local_24);
      BuildObjectList((int *)&local_28,&local_2c,&local_30);
      if (Settings.grid_units_mm == '\0') {
        puVar6 = &DAT_08147f6c;
        uVar3 = 2;
        fVar1 = (float)PCB->Shrink / 100.0;
      }
      else {
        puVar6 = &DAT_0815627e;
        uVar3 = 4;
        fVar1 = ((float)PCB->Shrink / 100000.0) * 25.4;
      }
      pDVar4 = pcb_drc_violation_new
                         ("Potential for broken trace",
                          "Insufficient overlap between objects can lead to broken tracks\ndue to registration errors with old wheel style photo-plotters."
                          ,local_20[0],local_24,0,0,(double)((longlong)(double)fVar1 << 0x20),
                          (double)CONCAT44(uVar3,(int)((ulonglong)(double)fVar1 >> 0x20)),
                          (int)puVar6,local_28,(int)local_2c,local_30,in_stack_ffffffb0);
      append_drc_violation(pDVar4);
      pcb_drc_violation_free(pDVar4);
      free(local_2c);
      free(local_30);
      iVar5 = throw_drc_dialog();
      if (iVar5 == 0) {
        return '\x01';
      }
      IncrementUndoSerialNumber();
      Undo('\x01');
    }
    DumpList();
  }
  drc = '\0';
  ResetConnections('\0');
  TheFlag = 4;
  ListStart(What,ptr1,ptr2,ptr3);
  Bloat = PCB->Bloat;
  fBloat = (float)Bloat;
  drc = '\x01';
  while( true ) {
    BVar2 = DoIt('\x01','\0');
    if (BVar2 == '\0') {
      drc = '\0';
      DumpList();
      TheFlag = 0x44;
      ResetConnections('\0');
      return '\0';
    }
    DumpList();
    TheFlag = 0x44;
    ResetConnections('\0');
    User = '\x01';
    drc = '\0';
    Bloat = 0;
    fBloat = 0.0;
    RestoreUndoSerialNumber();
    TheFlag = 0x40;
    ListStart(What,ptr1,ptr2,ptr3);
    DoIt('\x01','\x01');
    DumpList();
    TheFlag = 4;
    ListStart(What,ptr1,ptr2,ptr3);
    Bloat = PCB->Bloat;
    fBloat = (float)Bloat;
    drc = '\x01';
    DoIt('\x01','\x01');
    DumpList();
    drcerr_count = drcerr_count + 1;
    LocateError(local_20,&local_24);
    BuildObjectList((int *)&local_28,&local_2c,&local_30);
    if (Settings.grid_units_mm == '\0') {
      uVar3 = 2;
      puVar6 = &DAT_08147f6c;
      fVar1 = (float)PCB->Bloat / 100.0;
    }
    else {
      uVar3 = 4;
      puVar6 = &DAT_0815627e;
      fVar1 = ((float)PCB->Bloat / 100000.0) * 25.4;
    }
    pDVar4 = pcb_drc_violation_new
                       ("Copper areas too close",
                        "Circuits that are too close may bridge during imaging, etching,\nplating, or soldering processes resulting in a direct short."
                        ,local_20[0],local_24,0,0,(double)((longlong)(double)fVar1 << 0x20),
                        (double)CONCAT44(uVar3,(int)((ulonglong)(double)fVar1 >> 0x20)),(int)puVar6,
                        local_28,(int)local_2c,local_30,in_stack_ffffffb0);
    append_drc_violation(pDVar4);
    pcb_drc_violation_free(pDVar4);
    free(local_2c);
    free(local_30);
    User = '\0';
    drc = '\0';
    iVar5 = throw_drc_dialog();
    if (iVar5 == 0) break;
    IncrementUndoSerialNumber();
    Undo('\x01');
    TheFlag = TheFlag | 0x40;
    Bloat = 0;
    fBloat = 0.0;
    ListStart(thing_type,thing_ptr1,thing_ptr2,thing_ptr3);
    DoIt('\x01','\x01');
    DumpList();
    drc = '\x01';
    Bloat = PCB->Bloat;
    fBloat = (float)Bloat;
    ListStart(What,ptr1,ptr2,ptr3);
  }
  return '\x01';
}



// WARNING: Unknown calling convention

int DRCAll(void)

{
  float fVar1;
  float fVar2;
  Boolean BVar3;
  Cardinal sn_1;
  undefined1 *puVar4;
  DrcViolationType *pDVar5;
  int iVar6;
  int iVar7;
  Cardinal sn_5;
  DataTypePtr paVar8;
  int iVar9;
  Cardinal n_6;
  char *pcVar10;
  size_t sVar11;
  char *title;
  PinTypePtr pin;
  void *pvVar12;
  undefined4 uVar13;
  PCBTypePtr pPVar14;
  Cardinal sn_3;
  BDimension *pBVar15;
  PinTypePtr via;
  Cardinal n_1;
  uint uVar16;
  Cardinal n;
  uint uVar17;
  Cardinal n_2;
  DrcViolationType *violation;
  LineTypePtr pLVar18;
  ArcTypePtr arc;
  PinTypePtr pin_1;
  PinTypePtr paVar19;
  PadTypePtr pad_1;
  PinTypePtr via_1;
  LineTypePtr line_1;
  int tmpcnt;
  ArcTypePtr Arc;
  PadTypePtr Pad;
  ElementTypePtr element;
  uchar *puVar20;
  Cardinal sn_2;
  LayerTypePtr layer;
  LayerTypePtr layer_1;
  Cardinal n_3;
  uint uVar21;
  ElementTypePtr element_3;
  Cardinal n_4;
  ElementTypePtr element_2;
  ElementTypePtr Element;
  LayerTypePtr pLVar22;
  Cardinal sn;
  ElementTypePtr element_1;
  Cardinal sn_4;
  Cardinal n_5;
  char *name;
  int *in_stack_ffffffa0;
  int local_58;
  uint local_54;
  int local_50;
  int local_4c;
  undefined1 *local_48;
  LayerTypePtr local_44;
  long *local_30;
  long *local_2c;
  char *local_28;
  int local_24;
  int local_20 [4];
  
  drc_dialog_message[0] = '\0';
  if (gui->drc_gui != (HID_DRC_GUI *)0x0) {
    (*gui->drc_gui->reset_drc_dialog_message)();
  }
  IsBad = '\0';
  drcerr_count = 0;
  SaveStackAndVisibility();
  ResetStackAndVisibility();
  hid_action("LayersChanged");
  InitConnectionLookup();
  TheFlag = 0x1044;
  ResetConnections('\x01');
  User = '\0';
  paVar8 = PCB->Data;
  local_48 = (undefined1 *)(paVar8->ElementN - 1);
  if (local_48 == (undefined1 *)0xffffffff) {
    local_4c = 0;
    if (IsBad != '\0') goto LAB_0809babf;
  }
  else {
    local_4c = 0;
    iVar7 = paVar8->ElementN * 300;
    while( true ) {
      local_50 = iVar7 + -300;
      puVar20 = paVar8->Element[-1].Flags.t + iVar7 + -0x18;
      if (*(uint *)(puVar20 + 0xe0) != 0) {
        uVar16 = 0;
        uVar21 = *(uint *)(puVar20 + 0xe0);
        do {
          pvVar12 = (void *)(uVar16 * 0x4c + *(int *)(puVar20 + 0x100));
          uVar17 = uVar21;
          if ((*(byte *)((int)pvVar12 + 0x15) & 0x10) == 0) {
            BVar3 = DRCFind(0x100,puVar20,pvVar12,pvVar12);
            if (BVar3 != '\0') goto LAB_0809bab8;
            uVar17 = *(uint *)(puVar20 + 0xe0);
          }
        } while ((uVar17 != 0) &&
                (uVar16 = (uVar16 + 1 + uVar17) - uVar21, uVar21 = uVar17, uVar16 < uVar17));
      }
      if (IsBad != '\0') goto LAB_0809babf;
      uVar21 = *(uint *)(puVar20 + 0xe8);
      uVar16 = uVar21;
      for (uVar17 = 0; (uVar16 != 0 && (uVar17 < uVar16)); uVar17 = uVar17 + (uVar21 == uVar16)) {
        pvVar12 = (void *)(uVar17 * 0x68 + *(int *)(puVar20 + 0x104));
        local_4c = (local_4c + 1) - (uint)((*(uint *)((int)pvVar12 + 0x14) & 8) == 0);
        if ((*(uint *)((int)pvVar12 + 0x14) & 0x1000) == 0) {
          BVar3 = DRCFind(0x200,puVar20,pvVar12,pvVar12);
          if (BVar3 != '\0') goto LAB_0809bab8;
          uVar16 = *(uint *)(puVar20 + 0xe8);
        }
      }
      if (IsBad != '\0') goto LAB_0809babf;
      local_48 = (undefined1 *)((int)local_48 + -1);
      if (local_48 == (undefined1 *)0xffffffff) break;
      paVar8 = PCB->Data;
      iVar7 = local_50;
    }
    paVar8 = PCB->Data;
  }
  if (paVar8->ViaN != 0) {
    uVar16 = 0;
    pPVar14 = PCB;
    uVar21 = paVar8->ViaN;
    do {
      paVar19 = paVar8->Via + uVar16;
      if ((*(byte *)((int)&(paVar19->Flags).f + 1) & 0x10) == 0) {
        BVar3 = DRCFind(1,paVar19,paVar19,paVar19);
        if (BVar3 != '\0') goto LAB_0809bab8;
        paVar8 = PCB->Data;
        uVar17 = paVar8->ViaN;
        pPVar14 = PCB;
      }
      else {
        paVar8 = pPVar14->Data;
        uVar17 = paVar8->ViaN;
      }
    } while ((uVar17 != 0) &&
            (uVar16 = (uVar17 + 1 + uVar16) - uVar21, uVar21 = uVar17, uVar16 < uVar17));
    if (IsBad != '\0') goto LAB_0809babf;
  }
  TheFlag = 0x1044;
LAB_0809bac4:
  ResetConnections('\0');
  TheFlag = 0x40;
  if (IsBad == '\0') {
    paVar8 = PCB->Data;
    pLVar22 = paVar8->Layer;
    if (paVar8->LayerN != 0) {
      local_54 = 0;
      do {
        local_44 = (LayerTypePtr)(pLVar22->LineN - 1);
        if (local_44 == (LayerTypePtr)0xffffffff) {
LAB_0809bcd5:
          uVar21 = paVar8->LayerN;
          if (uVar21 <= local_54 + 1) goto LAB_0809c7e6;
        }
        else {
          iVar7 = pLVar22->LineN * 0x58;
          while( true ) {
            pLVar18 = (LineTypePtr)(pLVar22->Line[-1].Flags.t + iVar7 + -0x18);
            PlowsPolygon((DataType *)paVar8,4,pLVar22,pLVar18,drc_callback);
            if (IsBad != '\0') break;
            if (pLVar18->Thickness < PCB->minWid) {
              AddObjectToFlagUndoList(4,pLVar22,pLVar18,pLVar18);
              (pLVar18->Flags).f = (pLVar18->Flags).f | TheFlag;
              DrawLine(pLVar22,pLVar18,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 4;
              thing_ptr1 = pLVar22;
              thing_ptr2 = pLVar18;
              thing_ptr3 = pLVar18;
              LocateError(local_20,&local_24);
              BuildObjectList((int *)&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                uVar13 = 2;
                puVar4 = &DAT_08147f6c;
                fVar2 = (float)PCB->minWid / 100.0;
                fVar1 = (float)pLVar18->Thickness / 100.0;
              }
              else {
                uVar13 = 4;
                puVar4 = &DAT_0815627e;
                fVar2 = ((float)PCB->minWid / 100000.0) * 25.4;
                fVar1 = (100000.0 / (float)pLVar18->Thickness) * 25.4;
              }
              pDVar5 = pcb_drc_violation_new
                                 ("Line width is too thin",
                                  "Process specifications dictate a minimum feature-width\nthat can reliably be reproduced"
                                  ,local_20[0],local_24,1,SUB84((double)fVar1,0),
                                  (double)CONCAT44(SUB84((double)fVar2,0),
                                                   (int)((ulonglong)(double)fVar1 >> 0x20)),
                                  (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                                  (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
              append_drc_violation(pDVar5);
              pcb_drc_violation_free(pDVar5);
              free(local_2c);
              free(local_30);
              iVar6 = throw_drc_dialog();
              if (iVar6 == 0) {
                IsBad = '\x01';
                break;
              }
              IncrementUndoSerialNumber();
              Undo('\0');
            }
            if (local_44 == (LayerTypePtr)0x0) {
              paVar8 = PCB->Data;
              goto LAB_0809bcd5;
            }
            local_44 = (LayerTypePtr)((int)local_44 + -1);
            paVar8 = PCB->Data;
            iVar7 = iVar7 + -0x58;
          }
          paVar8 = PCB->Data;
          uVar21 = paVar8->LayerN;
          if (uVar21 <= local_54 + 1) goto LAB_0809c7e6;
        }
        local_54 = local_54 + 1;
        pLVar22 = pLVar22 + 1;
      } while( true );
    }
LAB_0809bcfa:
    local_54 = paVar8->ElementN - 1;
    if (local_54 != -1) {
      iVar7 = paVar8->ElementN * 300;
      do {
        local_58 = iVar7 + -300;
        puVar20 = paVar8->Element[-1].Flags.t + iVar7 + -0x18;
        if (*(uint *)(puVar20 + 0xe0) != 0) {
          uVar21 = 0;
          local_44 = (LayerTypePtr)*(uint *)(puVar20 + 0xe0);
          while( true ) {
            paVar19 = (PinTypePtr)(uVar21 * 0x4c + *(int *)(puVar20 + 0x100));
            PlowsPolygon((DataType *)paVar8,0x100,puVar20,paVar19,drc_callback);
            if (IsBad != '\0') break;
            if ((*(byte *)&(paVar19->Flags).f & 8) == 0) {
              iVar7 = paVar19->DrillingHole;
              iVar6 = paVar19->Thickness - iVar7;
              if (SBORROW4(iVar6,PCB->minRing * 2) == iVar6 + PCB->minRing * -2 < 0) {
                if (PCB->minDrill == iVar7 || PCB->minDrill < iVar7) goto LAB_0809bd6a;
                goto LAB_0809bde6;
              }
              AddObjectToFlagUndoList(0x100,puVar20,paVar19,paVar19);
              (paVar19->Flags).f = (paVar19->Flags).f | TheFlag;
              DrawPin(paVar19,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 0x100;
              thing_ptr1 = puVar20;
              thing_ptr2 = paVar19;
              thing_ptr3 = paVar19;
              LocateError(local_20,&local_24);
              BuildObjectList((int *)&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                fVar2 = (float)PCB->minRing / 100.0;
                puVar4 = &DAT_08147f6c;
                uVar13 = 2;
                fVar1 = (float)((paVar19->Thickness - paVar19->DrillingHole) / 2) / 100.0;
              }
              else {
                puVar4 = &DAT_0815627e;
                uVar13 = 4;
                fVar2 = ((float)PCB->minRing / 100000.0) * 25.4;
                fVar1 = (100000.0 / (float)((paVar19->Thickness - paVar19->DrillingHole) / 2)) *
                        25.4;
              }
              pDVar5 = pcb_drc_violation_new
                                 ("Pin annular ring too small",
                                  "Annular rings that are too small may erode during etching,\nresulting in a broken connection"
                                  ,local_20[0],local_24,1,SUB84((double)fVar1,0),
                                  (double)CONCAT44(SUB84((double)fVar2,0),
                                                   (int)((ulonglong)(double)fVar1 >> 0x20)),
                                  (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                                  (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
              append_drc_violation(pDVar5);
              pcb_drc_violation_free(pDVar5);
              free(local_2c);
              free(local_30);
              iVar7 = throw_drc_dialog();
              if (iVar7 != 0) {
                IncrementUndoSerialNumber();
                Undo('\0');
                iVar7 = paVar19->DrillingHole;
                goto LAB_0809bdde;
              }
LAB_0809cbaa:
              IsBad = '\x01';
              break;
            }
            iVar7 = paVar19->DrillingHole;
LAB_0809bdde:
            if (PCB->minDrill == iVar7 || PCB->minDrill < iVar7) {
LAB_0809bd6a:
              uVar16 = *(uint *)(puVar20 + 0xe0);
            }
            else {
LAB_0809bde6:
              AddObjectToFlagUndoList(0x100,puVar20,paVar19,paVar19);
              (paVar19->Flags).f = (paVar19->Flags).f | TheFlag;
              DrawPin(paVar19,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 0x100;
              thing_ptr1 = puVar20;
              thing_ptr2 = paVar19;
              thing_ptr3 = paVar19;
              LocateError(local_20,&local_24);
              BuildObjectList((int *)&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                uVar13 = 2;
                puVar4 = &DAT_08147f6c;
                fVar2 = (float)PCB->minDrill / 100.0;
                fVar1 = (float)paVar19->DrillingHole / 100.0;
              }
              else {
                uVar13 = 4;
                puVar4 = &DAT_0815627e;
                fVar2 = ((float)PCB->minDrill / 100000.0) * 25.4;
                fVar1 = (100000.0 / (float)paVar19->DrillingHole) * 25.4;
              }
              pDVar5 = pcb_drc_violation_new
                                 ("Pin drill size is too small",
                                  "Process rules dictate the minimum drill size which can be used",
                                  local_20[0],local_24,1,SUB84((double)fVar1,0),
                                  (double)CONCAT44(SUB84((double)fVar2,0),
                                                   (int)((ulonglong)(double)fVar1 >> 0x20)),
                                  (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                                  (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
              append_drc_violation(pDVar5);
              pcb_drc_violation_free(pDVar5);
              free(local_2c);
              free(local_30);
              iVar7 = throw_drc_dialog();
              if (iVar7 == 0) goto LAB_0809cbaa;
              IncrementUndoSerialNumber();
              Undo('\0');
              uVar16 = *(uint *)(puVar20 + 0xe0);
            }
            if ((uVar16 == 0) || (uVar21 = (uVar16 + 1 + uVar21) - (int)local_44, uVar16 <= uVar21))
            break;
            paVar8 = PCB->Data;
            local_44 = (LayerTypePtr)uVar16;
          }
        }
        local_54 = local_54 + -1;
        if (local_54 == -1) goto LAB_0809cc35;
        paVar8 = PCB->Data;
        iVar7 = local_58;
      } while( true );
    }
LAB_0809bf6d:
    if (paVar8->ViaN != 0) {
      uVar16 = 0;
      uVar21 = paVar8->ViaN;
      while( true ) {
        paVar19 = ((DataType *)paVar8)->Via + uVar16;
        PlowsPolygon((DataType *)paVar8,1,paVar19,paVar19,drc_callback);
        if (IsBad != '\0') break;
        if ((*(byte *)&(paVar19->Flags).f & 8) == 0) {
          iVar7 = paVar19->DrillingHole;
          iVar6 = paVar19->Thickness - iVar7;
          if (SBORROW4(iVar6,PCB->minRing * 2) == iVar6 + PCB->minRing * -2 < 0) {
            if (PCB->minDrill == iVar7 || PCB->minDrill < iVar7) goto LAB_0809bfa9;
            goto LAB_0809c016;
          }
          AddObjectToFlagUndoList(1,paVar19,paVar19,paVar19);
          (paVar19->Flags).f = (paVar19->Flags).f | TheFlag;
          DrawVia(paVar19,0);
          drcerr_count = drcerr_count + 1;
          thing_type = 1;
          thing_ptr1 = paVar19;
          thing_ptr2 = paVar19;
          thing_ptr3 = paVar19;
          LocateError(local_20,&local_24);
          BuildObjectList((int *)&local_28,&local_2c,&local_30);
          if (Settings.grid_units_mm == '\0') {
            local_48 = &DAT_08147f6c;
            fVar2 = (float)PCB->minRing / 100.0;
            uVar13 = 2;
            fVar1 = (float)((paVar19->Thickness - paVar19->DrillingHole) / 2) / 100.0;
          }
          else {
            local_48 = &DAT_0815627e;
            uVar13 = 4;
            fVar2 = ((float)PCB->minRing / 100000.0) * 25.4;
            fVar1 = (100000.0 / (float)((paVar19->Thickness - paVar19->DrillingHole) / 2)) * 25.4;
          }
          pDVar5 = pcb_drc_violation_new
                             ("Via annular ring too small",
                              "Annular rings that are too small may erode during etching,\nresulting in a broken connection"
                              ,local_20[0],local_24,1,SUB84((double)fVar1,0),
                              (double)CONCAT44(SUB84((double)fVar2,0),
                                               (int)((ulonglong)(double)fVar1 >> 0x20)),
                              (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                              (int)local_48,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
          append_drc_violation(pDVar5);
          pcb_drc_violation_free(pDVar5);
          free(local_2c);
          free(local_30);
          iVar7 = throw_drc_dialog();
          if (iVar7 != 0) {
            IncrementUndoSerialNumber();
            Undo('\0');
            iVar7 = paVar19->DrillingHole;
            goto LAB_0809c00e;
          }
LAB_0809cf40:
          IsBad = '\x01';
          break;
        }
        iVar7 = paVar19->DrillingHole;
LAB_0809c00e:
        if (PCB->minDrill == iVar7 || PCB->minDrill < iVar7) {
LAB_0809bfa9:
          paVar8 = PCB->Data;
          uVar17 = paVar8->ViaN;
        }
        else {
LAB_0809c016:
          AddObjectToFlagUndoList(1,paVar19,paVar19,paVar19);
          (paVar19->Flags).f = (paVar19->Flags).f | TheFlag;
          DrawVia(paVar19,0);
          drcerr_count = drcerr_count + 1;
          thing_type = 1;
          thing_ptr1 = paVar19;
          thing_ptr2 = paVar19;
          thing_ptr3 = paVar19;
          LocateError(local_20,&local_24);
          BuildObjectList((int *)&local_28,&local_2c,&local_30);
          if (Settings.grid_units_mm == '\0') {
            puVar4 = &DAT_08147f6c;
            fVar2 = (float)PCB->minDrill / 100.0;
            uVar13 = 2;
            fVar1 = (float)paVar19->DrillingHole / 100.0;
          }
          else {
            puVar4 = &DAT_0815627e;
            fVar2 = ((float)PCB->minDrill / 100000.0) * 25.4;
            uVar13 = 4;
            fVar1 = (100000.0 / (float)paVar19->DrillingHole) * 25.4;
          }
          pDVar5 = pcb_drc_violation_new
                             ("Via drill size is too small",
                              "Process rules dictate the minimum drill size which can be used",
                              local_20[0],local_24,1,SUB84((double)fVar1,0),
                              (double)CONCAT44(SUB84((double)fVar2,0),
                                               (int)((ulonglong)(double)fVar1 >> 0x20)),
                              (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                              (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
          append_drc_violation(pDVar5);
          pcb_drc_violation_free(pDVar5);
          free(local_2c);
          free(local_30);
          iVar7 = throw_drc_dialog();
          if (iVar7 == 0) goto LAB_0809cf40;
          IncrementUndoSerialNumber();
          Undo('\0');
          paVar8 = PCB->Data;
          uVar17 = paVar8->ViaN;
        }
        if ((uVar17 == 0) ||
           (uVar16 = (uVar17 + 1 + uVar16) - uVar21, uVar21 = uVar17, uVar17 <= uVar16)) break;
      }
    }
  }
LAB_0809c15f:
  FreeConnectionLookupMemory();
  Bloat = 0;
  fBloat = 0.0;
  TheFlag = 0x40;
  if (IsBad == '\0') {
    local_54 = 0;
    local_44 = PCB->Data->Layer + PCB->Data->LayerN;
    do {
      iVar7 = local_44->LineN - 1;
      if (iVar7 != -1) {
        iVar6 = local_44->LineN * 0x58;
        do {
          pLVar18 = (LineTypePtr)(local_44->Line[-1].Flags.t + iVar6 + -0x18);
          if (pLVar18->Thickness < PCB->minSlk) {
            (pLVar18->Flags).f = (pLVar18->Flags).f | TheFlag;
            DrawLine(local_44,pLVar18,0);
            drcerr_count = drcerr_count + 1;
            thing_ptr1 = local_44;
            thing_type = 4;
            thing_ptr2 = pLVar18;
            thing_ptr3 = pLVar18;
            LocateError(local_20,&local_24);
            BuildObjectList((int *)&local_28,&local_2c,&local_30);
            if (Settings.grid_units_mm == '\0') {
              uVar13 = 2;
              puVar4 = &DAT_08147f6c;
              fVar2 = (float)PCB->minSlk / 100.0;
              fVar1 = (float)pLVar18->Thickness / 100.0;
            }
            else {
              uVar13 = 4;
              puVar4 = &DAT_0815627e;
              fVar2 = ((float)PCB->minSlk / 100000.0) * 25.4;
              fVar1 = (100000.0 / (float)pLVar18->Thickness) * 25.4;
            }
            pDVar5 = pcb_drc_violation_new
                               ("Silk line is too thin",
                                "Process specifications dictate a minimum silkscreen feature-width\nthat can reliably be reproduced"
                                ,local_20[0],local_24,1,SUB84((double)fVar1,0),
                                (double)CONCAT44(SUB84((double)fVar2,0),
                                                 (int)((ulonglong)(double)fVar1 >> 0x20)),
                                (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                                (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
            append_drc_violation(pDVar5);
            pcb_drc_violation_free(pDVar5);
            free(local_2c);
            free(local_30);
            iVar9 = throw_drc_dialog();
            if (iVar9 == 0) {
              IsBad = '\x01';
              break;
            }
          }
          iVar7 = iVar7 + -1;
          iVar6 = iVar6 + -0x58;
        } while (iVar7 != -1);
      }
      local_54 = local_54 + 1;
      if (local_54 == 2) break;
      local_44 = local_44 + 1;
    } while( true );
  }
  TheFlag = 0x40;
  if (IsBad == '\0') {
    paVar8 = PCB->Data;
    local_44 = (LayerTypePtr)(paVar8->ElementN - 1);
    if (local_44 == (LayerTypePtr)0xffffffff) goto LAB_0809c35f;
    iVar7 = paVar8->ElementN * 300;
    while( true ) {
      local_48 = (undefined1 *)(iVar7 + -300);
      Element = (ElementTypePtr)(paVar8->Element[-1].Flags.t + iVar7 + -0x18);
      iVar7 = Element->LineN - 1;
      if (iVar7 != -1) {
        iVar6 = 0;
        pBVar15 = &Element->Line[Element->LineN - 1].Thickness;
        do {
          iVar7 = iVar7 + -1;
          iVar6 = iVar6 + (uint)(*pBVar15 < PCB->minSlk);
          pBVar15 = pBVar15 + -0x16;
        } while (iVar7 != -1);
        if (iVar6 != 0) {
          (Element->Flags).f = (Element->Flags).f | TheFlag;
          DrawElement(Element,0);
          drcerr_count = drcerr_count + 1;
          thing_type = 2;
          thing_ptr1 = Element;
          thing_ptr2 = Element;
          thing_ptr3 = Element;
          LocateError(local_20,&local_24);
          BuildObjectList((int *)&local_28,&local_2c,&local_30);
          pcVar10 = Element->Name[1].TextString;
          if ((pcVar10 == (char *)0x0) || (*pcVar10 == '\0')) {
            sVar11 = 0x40;
            pcVar10 = "(unknown)";
          }
          else {
            sVar11 = strlen(pcVar10);
            sVar11 = sVar11 + 0x37;
          }
          title = (char *)calloc(1,sVar11);
          __snprintf_chk(title,sVar11,1,0xffffffff,"Element %s has %i silk lines which are too thin"
                         ,pcVar10,iVar6);
          if (Settings.grid_units_mm == '\0') {
            uVar13 = 2;
            puVar4 = &DAT_08147f6c;
            fVar1 = (float)PCB->minSlk / 100.0;
          }
          else {
            uVar13 = 4;
            puVar4 = &DAT_0815627e;
            fVar1 = ((float)PCB->minSlk / 100000.0) * 25.4;
          }
          pDVar5 = pcb_drc_violation_new
                             (title,
                              "Process specifications dictate a minimum silkscreen\nfeature-width that can reliably be reproduced"
                              ,local_20[0],local_24,0,0,
                              (double)CONCAT44(SUB84((double)fVar1,0),0x3ff00000),
                              (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar1 >> 0x20)),
                              (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
          free(title);
          append_drc_violation(pDVar5);
          pcb_drc_violation_free(pDVar5);
          free(local_2c);
          free(local_30);
          iVar7 = throw_drc_dialog();
          if (iVar7 == 0) {
            IsBad = '\x01';
            goto LAB_0809c35a;
          }
        }
      }
      local_44 = (LayerTypePtr)((int)local_44 + -1);
      if (local_44 == (LayerTypePtr)0xffffffff) break;
      paVar8 = PCB->Data;
      iVar7 = (int)local_48;
    }
    if (IsBad == '\0') goto LAB_0809c35f;
  }
LAB_0809c35a:
  IncrementUndoSerialNumber();
LAB_0809c35f:
  RestoreStackAndVisibility();
  hid_action("LayersChanged");
  (*gui->invalidate_all)();
  if (local_4c != 0) {
    pcVar10 = " has";
    if (local_4c != 1) {
      pcVar10 = "s have";
    }
    Message("Warning:  %d pad%s the nopaste flag set.\n",local_4c,pcVar10);
  }
  if (IsBad == '\0') {
    return drcerr_count;
  }
  return -drcerr_count;
LAB_0809bab8:
  IsBad = '\x01';
LAB_0809babf:
  TheFlag = 0x1000;
  goto LAB_0809bac4;
LAB_0809c7e6:
  if (IsBad == '\0') {
    pLVar22 = paVar8->Layer;
    if (uVar21 != 0) {
      local_54 = 0;
      do {
        local_44 = (LayerTypePtr)(pLVar22->ArcN - 1);
        if (local_44 != (LayerTypePtr)0xffffffff) {
          iVar7 = pLVar22->ArcN * 0x44;
          while( true ) {
            Arc = (ArcTypePtr)(pLVar22->Arc[-1].Flags.t + iVar7 + -0x18);
            PlowsPolygon((DataType *)paVar8,0x4000,pLVar22,Arc,drc_callback);
            if (IsBad != '\0') break;
            if (Arc->Thickness < PCB->minWid) {
              AddObjectToFlagUndoList(0x4000,pLVar22,Arc,Arc);
              (Arc->Flags).f = (Arc->Flags).f | TheFlag;
              DrawArc(pLVar22,Arc,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 0x4000;
              thing_ptr1 = pLVar22;
              thing_ptr2 = Arc;
              thing_ptr3 = Arc;
              LocateError(local_20,&local_24);
              BuildObjectList((int *)&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                uVar13 = 2;
                puVar4 = &DAT_08147f6c;
                fVar2 = (float)PCB->minWid / 100.0;
                fVar1 = (float)Arc->Thickness / 100.0;
              }
              else {
                uVar13 = 4;
                puVar4 = &DAT_0815627e;
                fVar2 = ((float)PCB->minWid / 100000.0) * 25.4;
                fVar1 = (100000.0 / (float)Arc->Thickness) * 25.4;
              }
              pDVar5 = pcb_drc_violation_new
                                 ("Arc width is too thin",
                                  "Process specifications dictate a minimum feature-width\nthat can reliably be reproduced"
                                  ,local_20[0],local_24,1,SUB84((double)fVar1,0),
                                  (double)CONCAT44(SUB84((double)fVar2,0),
                                                   (int)((ulonglong)(double)fVar1 >> 0x20)),
                                  (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                                  (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
              append_drc_violation(pDVar5);
              pcb_drc_violation_free(pDVar5);
              free(local_2c);
              free(local_30);
              iVar6 = throw_drc_dialog();
              if (iVar6 == 0) {
                IsBad = '\x01';
                break;
              }
              IncrementUndoSerialNumber();
              Undo('\0');
            }
            if (local_44 == (LayerTypePtr)0x0) {
              paVar8 = PCB->Data;
              goto LAB_0809c9d5;
            }
            local_44 = (LayerTypePtr)((int)local_44 + -1);
            paVar8 = PCB->Data;
            iVar7 = iVar7 + -0x44;
          }
          paVar8 = PCB->Data;
        }
LAB_0809c9d5:
        local_54 = local_54 + 1;
        if ((uint)paVar8->LayerN < local_54 || paVar8->LayerN == local_54) goto LAB_0809bced;
        pLVar22 = pLVar22 + 1;
      } while( true );
    }
    goto LAB_0809bcfa;
  }
  goto LAB_0809c15f;
LAB_0809bced:
  if (IsBad != '\0') goto LAB_0809c15f;
  goto LAB_0809bcfa;
LAB_0809cc35:
  if (IsBad == '\0') {
    paVar8 = PCB->Data;
    local_54 = paVar8->ElementN - 1;
    if (local_54 != -1) {
      local_58 = local_54 * 300;
      do {
        iVar7 = 0;
        puVar20 = (paVar8->Element->Flags).t + local_58 + -0x18;
        local_44 = (LayerTypePtr)0x0;
        uVar21 = *(uint *)(puVar20 + 0xe8);
        uVar16 = uVar21;
LAB_0809cc97:
        if ((uVar16 == 0) || (uVar16 <= local_44)) goto LAB_0809ce70;
        Pad = (PadTypePtr)(*(int *)(puVar20 + 0x104) + iVar7);
        PlowsPolygon((DataType *)PCB->Data,0x200,puVar20,Pad,drc_callback);
        if (IsBad != '\0') goto LAB_0809ce70;
        if (PCB->minWid <= Pad->Thickness) {
          uVar16 = *(uint *)(puVar20 + 0xe8);
joined_r0x0809ce2b:
          if (uVar16 == uVar21) {
            local_44 = (LayerTypePtr)((int)local_44 + 1);
            iVar7 = iVar7 + 0x68;
            uVar16 = uVar21;
          }
          goto LAB_0809cc97;
        }
        AddObjectToFlagUndoList(0x200,puVar20,Pad,Pad);
        (Pad->Flags).f = (Pad->Flags).f | TheFlag;
        DrawPad(Pad,0);
        drcerr_count = drcerr_count + 1;
        thing_type = 0x200;
        thing_ptr1 = puVar20;
        thing_ptr2 = Pad;
        thing_ptr3 = Pad;
        LocateError(local_20,&local_24);
        BuildObjectList((int *)&local_28,&local_2c,&local_30);
        if (Settings.grid_units_mm == '\0') {
          puVar4 = &DAT_08147f6c;
          fVar2 = (float)PCB->minWid / 100.0;
          uVar13 = 2;
          fVar1 = (float)Pad->Thickness / 100.0;
        }
        else {
          puVar4 = &DAT_0815627e;
          fVar2 = ((float)PCB->minWid / 100000.0) * 25.4;
          uVar13 = 4;
          fVar1 = (100000.0 / (float)Pad->Thickness) * 25.4;
        }
        pDVar5 = pcb_drc_violation_new
                           ("Pad is too thin",
                            "Pads which are too thin may erode during etching,\nresulting in a broken or unreliable connection"
                            ,local_20[0],local_24,1,SUB84((double)fVar1,0),
                            (double)CONCAT44(SUB84((double)fVar2,0),
                                             (int)((ulonglong)(double)fVar1 >> 0x20)),
                            (double)CONCAT44(uVar13,(int)((ulonglong)(double)fVar2 >> 0x20)),
                            (int)puVar4,local_28,(int)local_2c,local_30,in_stack_ffffffa0);
        append_drc_violation(pDVar5);
        pcb_drc_violation_free(pDVar5);
        free(local_2c);
        free(local_30);
        iVar6 = throw_drc_dialog();
        if (iVar6 != 0) {
          IncrementUndoSerialNumber();
          Undo('\0');
          uVar16 = *(uint *)(puVar20 + 0xe8);
          goto joined_r0x0809ce2b;
        }
        IsBad = '\x01';
LAB_0809ce70:
        local_54 = local_54 + -1;
        local_58 = local_58 + -300;
        if (local_54 == -1) goto LAB_0809bf55;
        paVar8 = PCB->Data;
      } while( true );
    }
    goto LAB_0809bf6d;
  }
  goto LAB_0809c15f;
LAB_0809bf55:
  if (IsBad != '\0') goto LAB_0809c15f;
  paVar8 = PCB->Data;
  goto LAB_0809bf6d;
}



// WARNING: Unknown calling convention

void LookupUnusedPins(FILE *FP)

{
  uint uVar1;
  uint uVar2;
  bool bVar3;
  Boolean BVar4;
  char cVar5;
  DataTypePtr paVar6;
  Cardinal sn;
  uint uVar7;
  int i;
  int i_1;
  char *pcVar8;
  Cardinal CVar9;
  Cardinal CVar10;
  Cardinal sn_1;
  ElementTypePtr Element;
  Cardinal number;
  int iVar11;
  Cardinal n;
  uint uVar12;
  PadTypePtr Pad;
  PinTypePtr pin;
  PinTypePtr Pin;
  int local_3c;
  int local_38;
  uint local_20;
  
  User = '\x01';
  SaveUndoSerialNumber();
  ResetConnections('\x01');
  RestoreUndoSerialNumber();
  InitConnectionLookup();
  paVar6 = PCB->Data;
  local_3c = paVar6->ElementN - 1;
  if (local_3c != -1) {
    iVar11 = paVar6->ElementN * 300;
    while( true ) {
      local_38 = iVar11 + -300;
      Element = (ElementTypePtr)(paVar6->Element[-1].Flags.t + iVar11 + -0x18);
      if (Element->PinN == 0) {
        bVar3 = true;
      }
      else {
        bVar3 = true;
        uVar12 = 0;
        uVar7 = Element->PinN;
        do {
          Pin = Element->Pin + uVar12;
          uVar1 = (Pin->Flags).f;
          uVar2 = uVar7;
          if ((((uVar1 & 8) == 0) && (FP != (FILE *)0x0)) && ((TheFlag & uVar1) == 0)) {
            BVar4 = ADD_PV_TO_LIST(Pin);
            if (BVar4 != '\0') goto LAB_0809d20b;
            DoIt('\x01','\x01');
            iVar11 = PadList[0].Number + PVList.Number + PadList[1].Number;
            if (PVList.Number != 0) {
              CVar9 = 0;
              do {
                iVar11 = iVar11 - (uint)(*(int *)((int)PVList.Data[CVar9] + 0x44) == 0);
                CVar9 = CVar9 + 1;
              } while (CVar9 != PVList.Number);
            }
            if (iVar11 == 1) {
              if (bVar3) {
                PrintConnectionElementName(Element,FP);
              }
              pcVar8 = Pin->Name;
              if (pcVar8 == (char *)0x0) {
                pcVar8 = "";
              }
              CreateQuotedString(&PrintAndSelectUnusedPinsAndPadsOfElement::oname,pcVar8);
              __fprintf_chk(FP,1,&DAT_08148576,PrintAndSelectUnusedPinsAndPadsOfElement::oname.Data)
              ;
              (Pin->Flags).f = (Pin->Flags).f | 0x40;
              DrawPin(Pin,0);
              bVar3 = false;
            }
            BVar4 = PrepareNextLoop(FP);
            if (BVar4 != '\0') goto LAB_0809d20b;
            uVar2 = Element->PinN;
          }
        } while ((uVar2 != 0) &&
                (uVar12 = (uVar12 + 1 + uVar2) - uVar7, uVar7 = uVar2, uVar12 < uVar2));
      }
      local_20 = 0;
      CVar9 = Element->PadN;
      CVar10 = CVar9;
      for (; (CVar10 != 0 && (local_20 < CVar10)); local_20 = local_20 + (CVar10 == CVar9)) {
        Pad = Element->Pad + local_20;
        uVar7 = (Pad->Flags).f;
        if ((FP != (FILE *)0x0) && ((TheFlag & uVar7) == 0)) {
          BVar4 = ADD_PAD_TO_LIST((uVar7 >> 7 ^ 1) & 1,Pad);
          if (BVar4 != '\0') goto LAB_0809d20b;
          DoIt('\x01','\x01');
          iVar11 = PadList[0].Number + PVList.Number + PadList[1].Number;
          if (PVList.Number != 0) {
            CVar10 = 0;
            do {
              iVar11 = iVar11 - (uint)(*(int *)((int)PVList.Data[CVar10] + 0x44) == 0);
              CVar10 = CVar10 + 1;
            } while (CVar10 != PVList.Number);
          }
          if (iVar11 == 1) {
            if (bVar3) {
              PrintConnectionElementName(Element,FP);
            }
            pcVar8 = Pad->Name;
            if (pcVar8 == (char *)0x0) {
              pcVar8 = "";
            }
            CreateQuotedString(&PrintAndSelectUnusedPinsAndPadsOfElement::oname,pcVar8);
            __fprintf_chk(FP,1,&DAT_08148576,PrintAndSelectUnusedPinsAndPadsOfElement::oname.Data);
            (Pad->Flags).f = (Pad->Flags).f | 0x40;
            DrawPad(Pad,0);
            bVar3 = false;
            cVar5 = PrepareNextLoop(FP);
          }
          else {
            cVar5 = PrepareNextLoop(FP);
          }
          if (cVar5 != '\0') goto LAB_0809d20b;
          CVar10 = Element->PadN;
        }
      }
      if (!bVar3) {
        fwrite(&DAT_08148070,1,3,(FILE *)FP);
        fputc(0x23,(FILE *)FP);
        for (iVar11 = Settings.CharPerLine; iVar11 != 0; iVar11 = iVar11 + -1) {
          fputc(0x3d,(FILE *)FP);
        }
        fputc(10,(FILE *)FP);
      }
      local_3c = local_3c + -1;
      if (local_3c == -1) break;
      paVar6 = PCB->Data;
      iVar11 = local_38;
    }
  }
LAB_0809d20b:
  if (Settings.RingBellWhenFinished != '\0') {
    (*gui->beep)();
  }
  FreeConnectionLookupMemory();
  IncrementUndoSerialNumber();
  User = '\0';
  Draw();
  return;
}



// WARNING: Unknown calling convention

void RatFindHook(int type,void *ptr1,void *ptr2,void *ptr3,Boolean undo,Boolean AndRats)

{
  User = undo;
  DumpList();
  ListStart(type,ptr1,ptr2,ptr3);
  DoIt(AndRats,'\0');
  User = '\0';
  return;
}



// WARNING: Unknown calling convention

Boolean PrintElementConnections(ElementTypePtr Element,FILE *FP,Boolean AndDraw)

{
  uint uVar1;
  Cardinal CVar2;
  Boolean BVar3;
  PinTypePtr pin;
  Cardinal sn;
  PinTypePtr Pin;
  Cardinal sn_1;
  char *pcVar4;
  Cardinal CVar5;
  PadTypePtr pad;
  PadTypePtr Pad;
  uint uVar6;
  Cardinal n;
  Cardinal layer;
  int local_24;
  uint local_20;
  
  PrintConnectionElementName(Element,FP);
  if (Element->PinN != 0) {
    uVar6 = 0;
    local_20 = Element->PinN;
    do {
      Pin = Element->Pin + uVar6;
      if (((Pin->Flags).f & TheFlag) == 0) {
        BVar3 = ADD_PV_TO_LIST(Pin);
        if (BVar3 != '\0') {
          return '\x01';
        }
        DoIt('\x01',AndDraw);
        PrintPinConnections(FP,'\x01');
        PrintPadConnections(1,FP,'\0');
        PrintPadConnections(0,FP,'\0');
        fwrite("\t}\n",1,3,(FILE *)FP);
        BVar3 = PrepareNextLoop(FP);
        if (BVar3 != '\0') {
          return '\x01';
        }
      }
      else {
        pcVar4 = Pin->Name;
        if (pcVar4 == (char *)0x0) {
          pcVar4 = "";
        }
        PrintConnectionListEntry(pcVar4,(ElementTypePtr)0x0,'\x01',FP);
        fwrite("\t\t__CHECKED_BEFORE__\n\t}\n",1,0x18,(FILE *)FP);
      }
      uVar1 = Element->PinN;
    } while ((uVar1 != 0) &&
            (uVar6 = (uVar1 + 1 + uVar6) - local_20, local_20 = uVar1, uVar6 < uVar1));
  }
  CVar2 = Element->PadN;
  local_24 = 0;
  local_20 = 0;
  CVar5 = CVar2;
  do {
    if ((CVar5 == 0) || (CVar5 <= local_20)) {
      fwrite(&DAT_08148070,1,3,(FILE *)FP);
      return '\0';
    }
    Pad = (PadTypePtr)((Element->Pad->Flags).t + local_24 + -0x18);
    uVar6 = (Pad->Flags).f;
    if ((TheFlag & uVar6) == 0) {
      uVar6 = (uVar6 >> 7 ^ 1) & 1;
      BVar3 = ADD_PAD_TO_LIST(uVar6,Pad);
      if (BVar3 != '\0') {
        return '\x01';
      }
      DoIt('\x01',AndDraw);
      PrintPadConnections(uVar6,FP,'\x01');
      PrintPadConnections(uVar6 ^ 1,FP,'\0');
      PrintPinConnections(FP,'\0');
      fwrite("\t}\n",1,3,(FILE *)FP);
      BVar3 = PrepareNextLoop(FP);
      if (BVar3 != '\0') {
        return '\x01';
      }
      CVar5 = Element->PadN;
    }
    else {
      pcVar4 = Pad->Name;
      if (pcVar4 == (char *)0x0) {
        pcVar4 = "";
      }
      PrintConnectionListEntry(pcVar4,(ElementTypePtr)0x0,'\x01',FP);
      fwrite("\t\t__CHECKED_BEFORE__\n\t}\n",1,0x18,(FILE *)FP);
      CVar5 = Element->PadN;
    }
    if (CVar5 == CVar2) {
      local_20 = local_20 + 1;
      local_24 = local_24 + 0x68;
      CVar5 = CVar2;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void LookupConnectionsToAllElements(FILE *FP)

{
  int iVar1;
  int iVar2;
  Boolean BVar3;
  DataTypePtr paVar4;
  Cardinal n;
  int iVar5;
  
  User = '\0';
  TheFlag = 4;
  ResetConnections('\0');
  InitConnectionLookup();
  paVar4 = PCB->Data;
  iVar5 = paVar4->ElementN - 1;
  if (iVar5 != -1) {
    iVar2 = paVar4->ElementN * 300;
    while( true ) {
      BVar3 = PrintElementConnections
                        ((ElementTypePtr)(paVar4->Element[-1].Flags.t + iVar2 + -0x18),FP,'\0');
      if (BVar3 != '\0') break;
      fputc(0x23,(FILE *)FP);
      for (iVar1 = Settings.CharPerLine; iVar1 != 0; iVar1 = iVar1 + -1) {
        fputc(0x3d,(FILE *)FP);
      }
      fputc(10,(FILE *)FP);
      if ((iVar5 != 1) && (Settings.ResetAfterElement != '\0')) {
        ResetConnections('\0');
      }
      if (iVar5 == 0) break;
      iVar5 = iVar5 + -1;
      paVar4 = PCB->Data;
      iVar2 = iVar2 + -300;
    }
  }
  if (Settings.RingBellWhenFinished != '\0') {
    (*gui->beep)();
  }
  ResetConnections('\0');
  FreeConnectionLookupMemory();
  ClearAndRedrawOutput();
  return;
}



// WARNING: Unknown calling convention

void LookupElementConnections(ElementTypePtr Element,FILE *FP)

{
  User = '\x01';
  TheFlag = 4;
  ResetConnections('\x01');
  InitConnectionLookup();
  PrintElementConnections(Element,FP,'\x01');
  SetChangedFlag('\x01');
  if (Settings.RingBellWhenFinished != '\0') {
    (*gui->beep)();
  }
  FreeConnectionLookupMemory();
  IncrementUndoSerialNumber();
  User = '\0';
  Draw();
  return;
}



// WARNING: Unknown calling convention

void LookupConnection(LocationType X,LocationType Y,Boolean AndDraw,BDimension Range,int which_flag)

{
  uint type_00;
  int type;
  int iVar1;
  int laynum;
  char *pcVar2;
  char *name;
  void *local_28;
  void *local_24;
  LayerTypePtr local_20 [4];
  
  type_00 = SearchObjectByLocation(0x300,local_20,&local_24,&local_28,X,Y,Range);
  if (type_00 == 0) {
    type_00 = SearchObjectByLocation(0x402d,local_20,&local_24,&local_28,X,Y,Range);
    if (type_00 == 0) {
      return;
    }
    if (((type_00 & 0x400c) != 0) &&
       (iVar1 = GetLayerNumber(PCB->Data,local_20[0]), PCB->Data->LayerN <= iVar1)) {
      return;
    }
  }
  else {
    pcVar2 = ConnectionName(type_00,local_20[0],local_24);
    hid_actionl("NetlistShow",pcVar2,0);
  }
  TheFlag = which_flag;
  User = AndDraw;
  InitConnectionLookup();
  ListStart(type_00,local_20[0],local_24,local_28);
  DoIt('\x01',AndDraw);
  if (User != '\0') {
    IncrementUndoSerialNumber();
  }
  User = '\0';
  if ((AndDraw != '\0') && (Draw(), Settings.RingBellWhenFinished != '\0')) {
    (*gui->beep)();
  }
  FreeConnectionLookupMemory();
  return;
}



// WARNING: Unknown calling convention

int FlagCurrentStyle(int dummy)

{
  PCBTypePtr pPVar1;
  Cardinal n;
  int iVar2;
  
  iVar2 = 0;
  pPVar1 = PCB;
  while ((((pPVar1->RouteStyle[0].Thick != Settings.LineThickness ||
           (pPVar1->RouteStyle[0].Diameter != Settings.ViaThickness)) ||
          (pPVar1->RouteStyle[0].Hole != Settings.ViaDrillingHole)) ||
         (pPVar1->RouteStyle[0].Keepaway != Settings.Keepaway))) {
    iVar2 = iVar2 + 1;
    pPVar1 = (PCBTypePtr)&pPVar1->PrintFilename;
    if (iVar2 == 4) {
      return 0;
    }
  }
  return iVar2 + 1;
}



// WARNING: Unknown calling convention

int FlagGrid(int dummy)

{
  return (uint)(1.0 < PCB->Grid);
}



// WARNING: Unknown calling convention

int FlagGridSize(int dummy)

{
  return (int)ROUND((float)PCB->Grid + 0.5);
}



// WARNING: Unknown calling convention

int FlagBuffer(int dummy)

{
  return Settings.BufferNumber + 1;
}



// WARNING: Unknown calling convention

int FlagElementName(int dummy)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = (PCB->Flags).f;
  iVar2 = 2;
  if ((uVar1 & 0x40) == 0) {
    iVar2 = (-(uint)((uVar1 & 0x20) == 0) & 2) + 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int FlagTESTFLAG(int bit)

{
  return (uint)(((PCB->Flags).f & bit) != 0);
}



// WARNING: Unknown calling convention

int FlagSETTINGS(int ofs)

{
  return (int)*(char *)((int)Settings.LayerColor + ofs + -0x54);
}



// WARNING: Unknown calling convention

int FlagMode(int x)

{
  if (x != -1) {
    return (uint)(Settings.Mode == x);
  }
  return Settings.Mode;
}



// WARNING: Unknown calling convention

int FlagHaveRegex(int x)

{
  return 1;
}



// WARNING: Unknown calling convention

int FlagLayerShown(int n)

{
  switch(n) {
  case -6:
    return (int)PCB->ElementOn;
  case -5:
    return (int)PCB->PinOn;
  case -4:
    return (int)PCB->RatOn;
  case -3:
    return (int)PCB->ViaOn;
  case -2:
    return (int)PCB->InvisibleObjectsOn;
  case -1:
    return (PCB->Flags).f >> 0xd & 1;
  }
  if ((-1 < n) && (n < PCB->Data->LayerN)) {
    return (int)PCB->Data->Layer[n].On;
  }
  return 0;
}



// WARNING: Unknown calling convention

int FlagLayerActive(int n)

{
  int iVar1;
  int current_layer;
  
  iVar1 = -4;
  if ((PCB->RatDraw == '\0') && (iVar1 = -6, PCB->SilkActive == '\0')) {
    return 0;
  }
  return (uint)(iVar1 == n);
}



// WARNING: Unknown calling convention

void register_flags_flag_list(void)

{
  hid_register_flags(flags_flag_list,0x46);
  return;
}



// WARNING: Unknown calling convention

int FontSave(int argc,char **argv,int Ux,int Uy)

{
  Cardinal *pCVar1;
  DataTypePtr paVar2;
  LineTypePtr pLVar3;
  int iVar4;
  int iVar5;
  Cardinal CVar6;
  PCBTypePtr pPVar7;
  PCBTypePtr pPVar8;
  int iVar9;
  int s;
  int s_1;
  LineTypePtr l;
  int iVar10;
  int iVar11;
  int x1;
  int iVar12;
  int ox;
  LineTypePtr l_1;
  int x2;
  int X2;
  int i;
  Cardinal CVar13;
  Cardinal CVar14;
  uint local_24;
  PCBTypePtr local_20;
  
  pPVar7 = PCB;
  paVar2 = PCB->Data;
  iVar9 = 0;
  do {
    *(undefined4 *)((int)&(pPVar7->Font).Symbol[0].LineN + iVar9) = 0;
    (&(pPVar7->Font).Symbol[0].Valid)[iVar9] = '\0';
    *(undefined4 *)((int)&(pPVar7->Font).Symbol[0].Width + iVar9) = 0;
    iVar9 = iVar9 + 0x1c;
  } while (iVar9 != 0x1c00);
  if (paVar2->Layer[0].LineN != 0) {
    local_20 = pPVar7;
    local_24 = 0;
    while( true ) {
      pLVar3 = paVar2->Layer[0].Line;
      iVar4 = pLVar3[local_24].Point1.Y;
      iVar5 = pLVar3[local_24].Point2.Y;
      iVar9 = ((iVar4 + 1000) / 10000) * 0x10 + -0x11 + (pLVar3[local_24].Point1.X + 1000) / 10000;
      iVar12 = iVar9 % 0x10 + 1;
      iVar10 = iVar9 + 0xf;
      if (-1 < iVar9) {
        iVar10 = iVar9;
      }
      iVar11 = (iVar10 >> 4) + 1;
      X2 = pLVar3[local_24].Point2.X + iVar12 * -10000;
      x1 = pLVar3[local_24].Point1.X + iVar12 * -10000;
      iVar10 = *(int *)((int)local_20 + iVar9 * 0x1c + 0xe0);
      if (iVar10 < x1) {
        *(int *)((int)local_20 + iVar9 * 0x1c + 0xe0) = x1;
        iVar10 = x1;
      }
      if (iVar10 < X2) {
        *(int *)((int)local_20 + iVar9 * 0x1c + 0xe0) = X2;
      }
      *(undefined *)((int)local_20 + iVar9 * 0x1c + 0xd4) = 1;
      CreateNewLineInSymbol
                ((SymbolTypePtr)((int)local_20 + iVar9 * 0x1c + 0xd0),x1,iVar4 + iVar11 * -10000,X2,
                 iVar5 + iVar11 * -10000,pLVar3[local_24].Thickness);
      local_24 = local_24 + 1;
      pCVar1 = &paVar2->Layer[0].LineN;
      if (*pCVar1 < local_24 || *pCVar1 == local_24) break;
      local_20 = PCB;
    }
  }
  pPVar8 = PCB;
  CVar6 = paVar2->Layer[2].LineN;
  if (CVar6 != 0) {
    pLVar3 = paVar2->Layer[2].Line;
    CVar14 = 0;
    do {
      CVar13 = CVar14 + 1;
      iVar4 = pLVar3[CVar14].Point1.X;
      iVar9 = ((pLVar3[CVar14].Point1.Y + 1000) / 10000) * 0x10 + -0x11 + (iVar4 + 1000) / 10000;
      *(int *)((int)pPVar8 + iVar9 * 0x1c + 0xe8) =
           (iVar4 + (iVar9 % 0x10 + 1) * -10000) - *(int *)((int)pPVar8 + iVar9 * 0x1c + 0xe0);
      CVar14 = CVar13;
    } while (CVar13 != CVar6);
  }
  SetFontInfo(&pPVar7->Font);
  return 0;
}



// WARNING: Unknown calling convention

int FontEdit(int argc,char **argv,int Ux,int Uy)

{
  Cardinal *pCVar1;
  int iVar2;
  DataTypePtr paVar3;
  LineTypePtr pLVar4;
  FlagType Flags;
  FlagType Flags_00;
  FlagType Flags_01;
  FlagType Flags_02;
  FlagType Flags_03;
  FontType *pFVar5;
  PCBTypePtr pPVar6;
  int iVar7;
  int iVar8;
  char *pcVar9;
  int maxx;
  PCBTypePtr pPVar10;
  int oy;
  int w;
  int iVar11;
  int ox;
  LayerTypePtr lgrid;
  int in_GS_OFFSET;
  uint local_74;
  int local_68;
  uint local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  iVar7 = hid_actionl("New","Font",0);
  iVar8 = 1;
  if (iVar7 == 0) {
    while (4 < PCB->Data->LayerN) {
      MoveLayer(4,-1);
    }
    MoveLayerToGroup(0,0);
    MoveLayerToGroup(1,1);
    MoveLayerToGroup(2,2);
    MoveLayerToGroup(3,3);
    pPVar6 = PCB;
    PCB->MaxWidth = 180000;
    paVar3 = pPVar6->Data;
    pPVar6->MaxHeight = 180000;
    pPVar6->Grid = 500.0;
    pcVar9 = MyStrdup("Font","FontEdit");
    paVar3->Layer[0].Name = pcVar9;
    paVar3 = PCB->Data;
    pcVar9 = MyStrdup("OrigFont","FontEdit");
    paVar3->Layer[1].Name = pcVar9;
    paVar3 = PCB->Data;
    pcVar9 = MyStrdup("Width","FontEdit");
    paVar3->Layer[2].Name = pcVar9;
    paVar3 = PCB->Data;
    pcVar9 = MyStrdup("Grid","FontEdit");
    paVar3->Layer[3].Name = pcVar9;
    hid_action("PCBChanged");
    hid_action("LayersChanged");
    pPVar6 = PCB;
    local_74 = 0;
    paVar3 = PCB->Data;
    pPVar10 = PCB;
    do {
      iVar7 = (pPVar6->Font).MaxHeight;
      iVar11 = ((local_74 & 0xf) + 1) * 10000;
      iVar8 = (((int)local_74 >> 4) + 1) * 10000;
      local_68 = 0;
      if ((pPVar10->Font).Symbol[0].LineN != 0) {
        local_60 = 0;
        do {
          MakeFlags(0);
          pLVar4 = (pPVar10->Font).Symbol[0].Line;
          Flags.t._0_4_ = local_28;
          Flags.f = local_2c;
          Flags.t._4_4_ = local_24;
          CreateDrawnLineOnLayer
                    (paVar3->Layer,iVar11 + pLVar4[local_60].Point1.X,
                     pLVar4[local_60].Point1.Y + iVar8,pLVar4[local_60].Point2.X + iVar11,
                     pLVar4[local_60].Point2.Y + iVar8,pLVar4[local_60].Thickness,
                     pLVar4[local_60].Thickness,Flags);
          MakeFlags(0);
          pLVar4 = (pPVar10->Font).Symbol[0].Line;
          Flags_00.t._0_4_ = local_34;
          Flags_00.f = local_38;
          Flags_00.t._4_4_ = local_30;
          CreateDrawnLineOnLayer
                    (paVar3->Layer + 1,iVar11 + pLVar4[local_60].Point1.X,
                     pLVar4[local_60].Point1.Y + iVar8,pLVar4[local_60].Point2.X + iVar11,
                     pLVar4[local_60].Point2.Y + iVar8,pLVar4[local_60].Thickness,
                     pLVar4[local_60].Thickness,Flags_00);
          pLVar4 = (pPVar10->Font).Symbol[0].Line;
          maxx = pLVar4[local_60].Point1.X;
          if (maxx <= pLVar4[local_60].Point2.X) {
            maxx = pLVar4[local_60].Point2.X;
          }
          if (maxx <= local_68) {
            maxx = local_68;
          }
          local_60 = local_60 + 1;
          pCVar1 = &(pPVar10->Font).Symbol[0].LineN;
          local_68 = maxx;
        } while (local_60 <= *pCVar1 && *pCVar1 != local_60);
      }
      pFVar5 = &pPVar10->Font;
      pPVar10 = (PCBTypePtr)&pPVar10->Netlistname;
      local_68 = iVar11 + pFVar5->Symbol[0].Delta + local_68;
      MakeFlags(0);
      Flags_01.t._0_4_ = local_40;
      Flags_01.f = local_44;
      Flags_01.t._4_4_ = local_3c;
      CreateDrawnLineOnLayer
                (paVar3->Layer + 2,local_68,iVar8 + 500,local_68,iVar8 + iVar7,100,100,Flags_01);
      local_74 = local_74 + 1;
    } while (local_74 != 0x100);
    iVar7 = 10000;
    do {
      MakeFlags(0);
      iVar8 = iVar7 + 10000;
      Flags_02.t._0_4_ = local_4c;
      Flags_02.f = local_50;
      Flags_02.t._4_4_ = local_48;
      CreateDrawnLineOnLayer(paVar3->Layer + 3,iVar7,0,iVar7,PCB->MaxHeight,100,100,Flags_02);
      iVar7 = iVar8;
    } while (iVar8 != 170000);
    iVar7 = 10000;
    do {
      MakeFlags(0);
      iVar8 = iVar7 + 10000;
      Flags_03.t._0_4_ = local_58;
      Flags_03.f = local_5c;
      Flags_03.t._4_4_ = local_54;
      CreateDrawnLineOnLayer(paVar3->Layer + 3,0,iVar7,PCB->MaxWidth,iVar7,100,100,Flags_03);
      iVar7 = iVar8;
    } while (iVar8 != 180000);
    iVar8 = 0;
  }
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar8;
}



// WARNING: Unknown calling convention

void register_fontmode_action_list(void)

{
  hid_register_actions(fontmode_action_list,2);
  return;
}



// WARNING: Unknown calling convention

void heap_free(heap_t *heap,_func_void_void_ptr *freefunc)

{
  void *pvVar1;
  int iVar2;
  
  iVar2 = heap->size;
  while (iVar2 != 0) {
    pvVar1 = heap->element[iVar2].data;
    if (pvVar1 != (void *)0x0) {
      (*freefunc)(pvVar1);
      iVar2 = heap->size;
    }
    iVar2 = iVar2 + -1;
    heap->size = iVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void __downheap(heap_t *heap,int k)

{
  int iVar1;
  double dVar2;
  double dVar3;
  heap_element *phVar4;
  int iVar5;
  void *pvVar6;
  int iVar7;
  int j;
  int iVar8;
  heap_element *phVar9;
  double *pdVar10;
  int local_2c;
  
  phVar4 = heap->element;
  phVar9 = phVar4 + k;
  iVar5 = heap->size;
  pvVar6 = phVar9->data;
  dVar2 = phVar9->cost;
  iVar7 = iVar5 / 2;
  if (k <= iVar7) {
    while (iVar8 = k * 2, iVar5 <= iVar8) {
      phVar9 = heap->element + k * 2;
      dVar3 = phVar9->cost;
LAB_0809e3c2:
      local_2c = k * 0x18;
      if (dVar2 < dVar3) goto LAB_0809e430;
LAB_0809e3c6:
      *(undefined4 *)&phVar4[k].cost = *(undefined4 *)&phVar9->cost;
      *(undefined4 *)((int)&phVar4[k].cost + 4) = *(undefined4 *)((int)&phVar9->cost + 4);
      phVar4[k].data = phVar9->data;
      k = iVar8;
      if (iVar7 < iVar8) {
        pdVar10 = (double *)((int)&heap->element->cost + local_2c);
        *(void **)(pdVar10 + 1) = pvVar6;
        *pdVar10 = dVar2;
        return;
      }
    }
    phVar9 = phVar4 + k * 2;
    iVar1 = iVar8 + 1;
    dVar3 = phVar9->cost;
    local_2c = iVar1 * 0xc;
    if (dVar3 <= phVar4[iVar1].cost) goto LAB_0809e3c2;
    phVar9 = phVar4 + iVar1;
    iVar8 = iVar1;
    if (phVar9->cost <= dVar2) goto LAB_0809e3c6;
LAB_0809e430:
    phVar9 = phVar4 + k;
  }
  phVar9->cost = dVar2;
  phVar9->data = pvVar6;
  return;
}



// WARNING: Unknown calling convention

void * heap_remove_smallest(heap_t *heap)

{
  heap_element *phVar1;
  void *pvVar2;
  int iVar3;
  undefined4 uVar4;
  
  phVar1 = heap->element;
  pvVar2 = phVar1[1].data;
  iVar3 = heap->size;
  uVar4 = *(undefined4 *)&phVar1[iVar3].cost;
  heap->size = iVar3 + -1;
  *(undefined4 *)&phVar1[1].cost = uVar4;
  *(undefined4 *)((int)&phVar1[1].cost + 4) = *(undefined4 *)((int)&phVar1[iVar3].cost + 4);
  phVar1[1].data = phVar1[iVar3].data;
  if (0 < iVar3 + -1) {
    __downheap(heap,1);
  }
  return pvVar2;
}



// WARNING: Unknown calling convention

void * heap_replace(heap_t *heap,cost_t cost,void *data)

{
  heap_element *phVar1;
  
  if (heap->size != 0) {
    phVar1 = heap->element;
    phVar1->data = data;
    phVar1->cost = cost;
    __downheap(heap,0);
    data = heap->element->data;
  }
  return data;
}



// WARNING: Unknown calling convention

int heap_is_empty(heap_t *heap)

{
  return (uint)(heap->size == 0);
}



// WARNING: Unknown calling convention

int heap_size(heap_t *heap)

{
  return heap->size;
}



// WARNING: Unknown calling convention

void heap_insert(heap_t *heap,cost_t cost,void *data)

{
  double dVar1;
  int iVar2;
  heap_element *phVar3;
  size_t __size;
  heap_element *phVar4;
  heap_element *phVar5;
  int iVar6;
  int iVar7;
  
  iVar2 = heap->max;
  iVar7 = heap->size + 1;
  if (iVar2 <= iVar7) {
    heap->max = iVar2 * 2;
    if (iVar2 * 2 == 0) {
      heap->max = 0x100;
      __size = 0xc00;
    }
    else {
      __size = iVar2 * 0x18;
    }
    phVar4 = (heap_element *)realloc(heap->element,__size);
    iVar7 = heap->size + 1;
    heap->element = phVar4;
  }
  phVar3 = heap->element;
  heap->size = iVar7;
  phVar3[iVar7].data = data;
  phVar3[iVar7].cost = cost;
  phVar3->cost = MIN_COST;
  phVar4 = phVar3 + iVar7;
  dVar1 = phVar4->cost;
  phVar5 = phVar3 + iVar7 / 2;
  iVar2 = iVar7 / 2;
  if (dVar1 < phVar5->cost) {
    do {
      iVar6 = iVar2;
      *(undefined4 *)&phVar3[iVar7].cost = *(undefined4 *)&phVar5->cost;
      *(undefined4 *)((int)&phVar3[iVar7].cost + 4) = *(undefined4 *)((int)&phVar5->cost + 4);
      phVar3[iVar7].data = phVar5->data;
      phVar5 = phVar3 + iVar6 / 2;
      iVar2 = iVar6 / 2;
      iVar7 = iVar6;
    } while (dVar1 < phVar5->cost);
    phVar4 = phVar3 + iVar6;
  }
  phVar4->cost = dVar1;
  phVar4->data = data;
  return;
}



// WARNING: Unknown calling convention

void heap_destroy(heap_t **heap)

{
  heap_t *__ptr;
  
  __ptr = *heap;
  if (__ptr->element != (heap_element *)0x0) {
    free(__ptr->element);
    __ptr = *heap;
  }
  free(__ptr);
  *heap = (heap_t *)0x0;
  return;
}



// WARNING: Unknown calling convention

heap_t * heap_create(void)

{
  heap_t *phVar1;
  
  if (MIN_COST == 0.0) {
    MIN_COST = -9.999999999999999e+22;
  }
  phVar1 = (heap_t *)calloc(1,0xc);
  return phVar1;
}



// WARNING: Unknown calling convention

PointTypePtr AdjustInsertPoint(void)

{
  double dVar1;
  void *pvVar2;
  int iVar3;
  int iVar4;
  LocationType y;
  LocationType x;
  int iVar5;
  LocationType dx;
  int iVar6;
  LocationType m1;
  int iVar7;
  LocationType m2;
  AttachedLineType myline;
  
  pvVar2 = Crosshair.AttachedObject.Ptr2;
  if (Crosshair.AttachedObject.State == 0) {
    return (PointTypePtr)0x0;
  }
  Crosshair.AttachedObject.Ptr3 = &AdjustInsertPoint::InsertedPoint;
  iVar3 = (*gui->shift_is_pressed)();
  if (iVar3 != 0) {
    iVar5 = Crosshair.X - *(int *)((int)pvVar2 + 0x40);
    iVar7 = Crosshair.Y - *(int *)((int)pvVar2 + 0x44);
    iVar3 = Crosshair.X - *(int *)((int)pvVar2 + 0x2c);
    iVar6 = Crosshair.Y - *(int *)((int)pvVar2 + 0x30);
    if ((longdouble)(iVar7 * iVar7 + iVar5 * iVar5) <= (longdouble)(iVar6 * iVar6 + iVar3 * iVar3))
    {
      myline.Point1.X = *(LocationType *)((int)pvVar2 + 0x40);
      myline.Point1.Y = *(LocationType *)((int)pvVar2 + 0x44);
      myline.Point1.X2 = *(LocationType *)((int)pvVar2 + 0x48);
      myline.Point1.Y2 = *(LocationType *)((int)pvVar2 + 0x4c);
      myline.Point1.ID = *(long *)((int)pvVar2 + 0x50);
    }
    else {
      myline.Point1.X = *(LocationType *)((int)pvVar2 + 0x2c);
      myline.Point1.Y = *(LocationType *)((int)pvVar2 + 0x30);
      myline.Point1.X2 = *(LocationType *)((int)pvVar2 + 0x34);
      myline.Point1.Y2 = *(LocationType *)((int)pvVar2 + 0x38);
      myline.Point1.ID = *(long *)((int)pvVar2 + 0x3c);
    }
    myline.Point2.X = myline.Point1.X;
    myline.Point2.Y = myline.Point1.Y;
    myline.Point2.X2 = myline.Point1.X2;
    myline.Point2.Y2 = myline.Point1.Y2;
    myline.Point2.ID = myline.Point1.ID;
    FortyFiveLine(&myline);
    AdjustInsertPoint::InsertedPoint.X = myline.Point2.X;
    AdjustInsertPoint::InsertedPoint.Y = myline.Point2.Y;
    return &AdjustInsertPoint::InsertedPoint;
  }
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) != 0) {
    AdjustInsertPoint::InsertedPoint.X = Crosshair.X;
    AdjustInsertPoint::InsertedPoint.Y = Crosshair.Y;
    return &AdjustInsertPoint::InsertedPoint;
  }
  AdjustInsertPoint::InsertedPoint.Y = *(int *)((int)pvVar2 + 0x30);
  AdjustInsertPoint::InsertedPoint.X = *(int *)((int)pvVar2 + 0x2c);
  dx = Crosshair.X - AdjustInsertPoint::InsertedPoint.X;
  if (dx == 0) {
LAB_0809e7e8:
    iVar3 = 2;
  }
  else {
    dVar1 = (double)(Crosshair.Y - AdjustInsertPoint::InsertedPoint.Y) / (double)dx;
    if (0.577350269 < dVar1) {
      iVar3 = 1;
      if (1.732050808 < dVar1) goto LAB_0809e7e8;
    }
    else {
      iVar3 = 0;
      if ((dVar1 < -0.577350269) && (iVar3 = -1, dVar1 < -1.732050808)) goto LAB_0809e7e8;
    }
  }
  iVar5 = *(int *)((int)pvVar2 + 0x40);
  iVar6 = *(int *)((int)pvVar2 + 0x44);
  if (Crosshair.X - iVar5 != 0) {
    dVar1 = (double)(Crosshair.Y - iVar6) / (double)(Crosshair.X - iVar5);
    if (0.577350269 < dVar1) {
      iVar7 = 1;
      if (dVar1 <= 1.732050808) goto LAB_0809e858;
    }
    else {
      if (-0.577350269 <= dVar1) {
        iVar7 = 0;
        goto LAB_0809e858;
      }
      iVar7 = -1;
      if (-1.732050808 <= dVar1) goto LAB_0809e858;
    }
  }
  iVar7 = 2;
LAB_0809e858:
  if (iVar3 != iVar7) {
    if (iVar3 == 2) {
      AdjustInsertPoint::InsertedPoint.Y =
           (AdjustInsertPoint::InsertedPoint.X - iVar5) * iVar7 + iVar6;
    }
    else if (iVar7 == 2) {
      AdjustInsertPoint::InsertedPoint.Y =
           (iVar5 - AdjustInsertPoint::InsertedPoint.X) * iVar3 + AdjustInsertPoint::InsertedPoint.Y
      ;
      AdjustInsertPoint::InsertedPoint.X = iVar5;
    }
    else {
      iVar4 = iVar6 - AdjustInsertPoint::InsertedPoint.Y;
      AdjustInsertPoint::InsertedPoint.Y =
           (((AdjustInsertPoint::InsertedPoint.X * iVar7 * iVar3 -
             iVar7 * AdjustInsertPoint::InsertedPoint.Y) + iVar6 * iVar3) - iVar7 * iVar3 * iVar5) /
           (iVar3 - iVar7);
      AdjustInsertPoint::InsertedPoint.X =
           ((iVar4 + iVar3 * AdjustInsertPoint::InsertedPoint.X) - iVar7 * iVar5) / (iVar3 - iVar7);
    }
  }
  return &AdjustInsertPoint::InsertedPoint;
}



// WARNING: Unknown calling convention

void * InsertPointIntoObject
                 (int Type,void *Ptr1,void *Ptr2,Cardinal *Ptr3,LocationType DX,LocationType DY,
                 Boolean Force)

{
  void *pvVar1;
  void *ptr;
  
  InsertX = DX;
  InsertY = DY;
  InsertAt = *Ptr3;
  Forcible = Force;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&InsertFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    IncrementUndoSerialNumber();
  }
  return pvVar1;
}



// WARNING: Unknown calling convention

void * InsertPointIntoRat(RatTypePtr Rat)

{
  LineTypePtr Line;
  LineTypePtr Line_00;
  LayerType *pLVar1;
  LayerTypePtr pLVar2;
  LineTypePtr new;
  
  if (PCB->SilkActive == '\0') {
    pLVar2 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  Line = CreateDrawnLineOnLayer
                   (pLVar2,(Rat->Point1).X,(Rat->Point1).Y,InsertX,InsertY,Settings.LineThickness,
                    Settings.Keepaway * 2,Rat->Flags);
  Line_00 = (LineTypePtr)0x0;
  if (Line != (LineTypePtr)0x0) {
    if (PCB->SilkActive == '\0') {
      pLVar1 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    AddObjectToCreateUndoList(4,pLVar1,Line,Line);
    EraseRat(Rat);
    if (PCB->SilkActive == '\0') {
      pLVar2 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    DrawLine(pLVar2,Line,0);
    if (PCB->SilkActive == '\0') {
      pLVar2 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    Line_00 = CreateDrawnLineOnLayer
                        (pLVar2,(Rat->Point2).X,(Rat->Point2).Y,InsertX,InsertY,
                         Settings.LineThickness,Settings.Keepaway * 2,Rat->Flags);
    if (Line_00 != (LineTypePtr)0x0) {
      if (PCB->SilkActive == '\0') {
        pLVar1 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      AddObjectToCreateUndoList(4,pLVar1,Line_00,Line_00);
      if (PCB->SilkActive == '\0') {
        pLVar2 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      DrawLine(pLVar2,Line_00,0);
    }
    MoveObjectToRemoveUndoList(0x20,Rat,Rat,Rat);
    Draw();
  }
  return Line_00;
}



// WARNING: Unknown calling convention

void * InsertPointIntoPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  int iVar1;
  long lVar2;
  LocationType LVar3;
  LocationType LVar4;
  LocationType LVar5;
  LocationType LVar6;
  Cardinal CVar7;
  int iVar8;
  Boolean BVar9;
  PointTypePtr pPVar10;
  Cardinal n;
  uint uVar11;
  int in_GS_OFFSET;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Forcible == '\0') {
    line.Thickness = 0;
    if (InsertAt == 0) {
      CVar7 = Polygon->PointN;
      pPVar10 = Polygon->Points;
    }
    else {
      pPVar10 = Polygon->Points;
      CVar7 = InsertAt;
    }
    line.Point1.X = pPVar10[CVar7 - 1].X;
    line.Point1.Y = pPVar10[CVar7 - 1].Y;
    line.Point1.X2 = pPVar10[CVar7 - 1].X2;
    line.Point1.Y2 = pPVar10[CVar7 - 1].Y2;
    line.Point1.ID = pPVar10[CVar7 - 1].ID;
    line.Point2.X = pPVar10[InsertAt].X;
    line.Point2.Y = pPVar10[InsertAt].Y;
    line.Point2.X2 = pPVar10[InsertAt].X2;
    line.Point2.Y2 = pPVar10[InsertAt].Y2;
    line.Point2.ID = pPVar10[InsertAt].ID;
    BVar9 = IsPointOnLine((float)InsertX,(float)InsertY,0.0,&line);
    pPVar10 = (PointTypePtr)0x0;
    if (BVar9 != '\0') goto LAB_0809eed3;
  }
  ErasePolygon(Polygon);
  r_delete_entry(Layer->polygon_tree,&Polygon->BoundingBox);
  pPVar10 = CreateNewPointInPolygon(Polygon,InsertX,InsertY);
  CVar7 = InsertAt;
  lVar2 = pPVar10->ID;
  LVar3 = pPVar10->Y2;
  LVar4 = pPVar10->X2;
  LVar5 = pPVar10->Y;
  LVar6 = pPVar10->X;
  uVar11 = Polygon->PointN - 1;
  if (InsertAt < uVar11) {
    pPVar10 = Polygon->Points;
    iVar8 = Polygon->PointN * 0x14;
    do {
      uVar11 = uVar11 - 1;
      *(undefined4 *)((int)&pPVar10[-1].X + iVar8) = *(undefined4 *)((int)&pPVar10[-2].X + iVar8);
      *(undefined4 *)((int)&pPVar10[-1].Y + iVar8) = *(undefined4 *)(iVar8 + -0x24 + (int)pPVar10);
      *(undefined4 *)((int)&pPVar10[-1].X2 + iVar8) = *(undefined4 *)(iVar8 + -0x20 + (int)pPVar10);
      *(undefined4 *)((int)&pPVar10[-1].Y2 + iVar8) = *(undefined4 *)(iVar8 + -0x1c + (int)pPVar10);
      *(undefined4 *)((int)&pPVar10[-1].ID + iVar8) = *(undefined4 *)(iVar8 + -0x18 + (int)pPVar10);
      iVar8 = iVar8 + -0x14;
    } while (CVar7 < uVar11);
  }
  pPVar10 = Polygon->Points + CVar7;
  pPVar10->ID = lVar2;
  pPVar10->Y2 = LVar3;
  pPVar10->X2 = LVar4;
  pPVar10->Y = LVar5;
  pPVar10->X = LVar6;
  SetChangedFlag('\x01');
  AddObjectToInsertPointUndoList(0x800,Layer,Polygon,Polygon->Points + InsertAt);
  SetPolygonBoundingBox(Polygon);
  r_insert_entry(Layer->polygon_tree,&Polygon->BoundingBox,0);
  InitClip(PCB->Data,Layer,Polygon);
  if ((Forcible != '\0') || (BVar9 = RemoveExcessPolygonPoints(Layer,Polygon), BVar9 == '\0')) {
    DrawPolygon(Layer,Polygon,0);
    Draw();
  }
  pPVar10 = Polygon->Points + InsertAt;
LAB_0809eed3:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pPVar10;
}



// WARNING: Unknown calling convention

void * InsertPointIntoLine(LayerTypePtr Layer,LineTypePtr Line)

{
  int X2;
  LineTypePtr Line_00;
  LineTypePtr line;
  int Y2;
  
  if (((Line->Point1).X == InsertX) && ((Line->Point1).Y == InsertY)) {
    Line_00 = (LineTypePtr)0x0;
  }
  else {
    X2 = (Line->Point2).X;
    if (InsertX == X2) {
      Y2 = (Line->Point2).Y;
      if (Y2 == InsertY) {
        return (void *)0x0;
      }
    }
    else {
      Y2 = (Line->Point2).Y;
    }
    AddObjectToMoveUndoList(0x1000,Layer,Line,&Line->Point2,InsertX - X2,InsertY - Y2);
    EraseLine(Line);
    r_delete_entry(Layer->line_tree,&Line->BoundingBox);
    (Line->Point2).X = InsertX;
    (Line->Point2).Y = InsertY;
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,&Line->BoundingBox,0);
    DrawLine(Layer,Line,0);
    Line_00 = CreateDrawnLineOnLayer
                        (Layer,InsertX,InsertY,X2,Y2,Line->Thickness,Line->Clearance,Line->Flags);
    if (Line_00 != (LineTypePtr)0x0) {
      AddObjectToCreateUndoList(4,Layer,Line_00,Line_00);
      DrawLine(Layer,Line_00,0);
    }
    Draw();
  }
  return Line_00;
}



// WARNING: Unknown calling convention

void insertSegment(SegmentTree *st,int n,LocationType Y1,LocationType Y2)

{
  SegmentTreeNode *pSVar1;
  SegmentTreeNode *pSVar2;
  LocationType discriminant;
  int iVar3;
  
  pSVar1 = st->nodes;
  pSVar2 = pSVar1 + n;
  if ((pSVar2->left < Y1) || (pSVar2->right != Y2 && Y2 <= pSVar2->right)) {
    iVar3 = pSVar1[n * 2 + 1].left;
    if (Y1 < iVar3) {
      insertSegment(st,n * 2,Y1,Y2);
    }
    if (iVar3 < Y2) {
      insertSegment(st,n * 2 + 1,Y1,Y2);
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
    else {
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
  }
  else {
    iVar3 = pSVar2->covered + 1;
    pSVar2->covered = iVar3;
  }
  if (iVar3 < 1) {
    iVar3 = 0;
    if (n < st->size / 2) {
      iVar3 = pSVar1[n * 2 + 1].area + pSVar1[n * 2].area;
    }
  }
  else {
    iVar3 = pSVar2->right - pSVar2->left;
  }
  pSVar2->area = iVar3;
  return;
}



// WARNING: Unknown calling convention

void deleteSegment(SegmentTree *st,int n,LocationType Y1,LocationType Y2)

{
  SegmentTreeNode *pSVar1;
  SegmentTreeNode *pSVar2;
  LocationType discriminant;
  int iVar3;
  
  pSVar1 = st->nodes;
  pSVar2 = pSVar1 + n;
  if ((pSVar2->left < Y1) || (pSVar2->right != Y2 && Y2 <= pSVar2->right)) {
    iVar3 = pSVar1[n * 2 + 1].left;
    if (Y1 < iVar3) {
      deleteSegment(st,n * 2,Y1,Y2);
    }
    if (iVar3 < Y2) {
      deleteSegment(st,n * 2 + 1,Y1,Y2);
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
    else {
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
  }
  else {
    iVar3 = pSVar2->covered + -1;
    pSVar2->covered = iVar3;
  }
  if (iVar3 < 1) {
    iVar3 = 0;
    if (n < st->size / 2) {
      iVar3 = pSVar1[n * 2 + 1].area + pSVar1[n * 2].area;
    }
  }
  else {
    iVar3 = pSVar2->right - pSVar2->left;
  }
  pSVar2->area = iVar3;
  return;
}



// WARNING: Unknown calling convention

int compareleft(void *ptr1,void *ptr2)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return **ptr1 - **ptr2;
}



// WARNING: Unknown calling convention

int compareright(void *ptr1,void *ptr2)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return *(int *)(*ptr1 + 8) - *(int *)(*ptr2 + 8);
}



// WARNING: Unknown calling convention

int comparepos(void *ptr1,void *ptr2)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return *ptr1 - *ptr2;
}



// WARNING: Unknown calling convention

double ComputeUnionArea(BoxListTypePtr boxlist)

{
  LocationType *pLVar1;
  BoxTypePtr pBVar2;
  size_t Number;
  int *piVar3;
  int i_1;
  uint uVar4;
  int iVar5;
  int iVar6;
  LocationType *pLVar7;
  int **__base;
  void *__base_00;
  Cardinal i;
  uint uVar8;
  int iVar9;
  LocationType last;
  int *piVar10;
  LocationType lastX;
  int r;
  SegmentTreeNode *pSVar11;
  int iVar12;
  Cardinal j;
  uint uVar13;
  int i_2;
  bool bVar14;
  size_t local_40;
  double local_3c;
  int local_34;
  SegmentTree segtree;
  
  if (boxlist->BoxN == 0) {
    return 0.0;
  }
  Number = boxlist->BoxN * 2;
  piVar3 = (int *)MyCalloc(Number,4,"createSortedYList");
  if (boxlist->BoxN != 0) {
    pBVar2 = boxlist->Box;
    uVar8 = 0;
    do {
      uVar4 = uVar8 + 1;
      piVar3[uVar8 * 2] = pBVar2[uVar8].Y1;
      piVar3[uVar8 * 2 + 1] = pBVar2[uVar8].Y2;
      uVar8 = uVar4;
    } while (uVar4 <= boxlist->BoxN && boxlist->BoxN != uVar4);
  }
  qsort(piVar3,Number,4,comparepos);
  if (0 < (int)Number) {
    iVar12 = 0;
    iVar9 = 0;
    iVar5 = 0;
    do {
      if (iVar5 == 0) {
        iVar6 = *piVar3;
LAB_0809f45a:
        piVar3[iVar12] = iVar6;
        iVar12 = iVar12 + 1;
        iVar9 = iVar6;
      }
      else {
        iVar6 = piVar3[iVar5];
        bVar14 = iVar6 != iVar9;
        iVar9 = iVar6;
        if (bVar14) goto LAB_0809f45a;
      }
      if (Number == iVar5 + 1U) goto LAB_0809f480;
      iVar5 = iVar5 + 1;
    } while( true );
  }
  segtree.nodes = (SegmentTreeNode *)MyCalloc(2,0x10,"createSegmentTree");
  local_40 = 2;
  segtree.nodes[1].left = 10;
  segtree.nodes[1].right = 0xb;
LAB_0809f56f:
  segtree.size = local_40;
  free(piVar3);
  __base = (int **)MyCalloc(boxlist->BoxN,4,"ComputeUnionArea(1)");
  __base_00 = MyCalloc(boxlist->BoxN,4,"ComputeUnionArea(2)");
  uVar8 = boxlist->BoxN;
  if (uVar8 != 0) {
    uVar4 = 0;
    do {
      pBVar2 = boxlist->Box;
      *(BoxTypePtr *)((int)__base_00 + uVar4 * 4) = pBVar2 + uVar4;
      __base[uVar4] = &pBVar2[uVar4].X1;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar8);
  }
  qsort(__base,uVar8,4,compareleft);
  qsort(__base_00,boxlist->BoxN,4,compareright);
  local_3c = 0.0;
  uVar4 = 0;
  uVar8 = boxlist->BoxN;
  if (uVar8 != 0) {
    uVar13 = 0;
    iVar12 = **__base;
    do {
      if (uVar4 == uVar8) {
        iVar9 = *(int *)((int)__base_00 + uVar13 * 4);
        iVar5 = *(int *)(iVar9 + 8);
LAB_0809f678:
        iVar6 = iVar5;
        if (iVar12 != iVar6) {
          local_3c = (double)segtree.nodes[1].area * (double)(iVar6 - iVar12) + local_3c;
        }
        uVar13 = uVar13 + 1;
        deleteSegment(&segtree,1,*(LocationType *)(iVar9 + 4),*(LocationType *)(iVar9 + 0xc));
      }
      else {
        iVar9 = *(int *)((int)__base_00 + uVar13 * 4);
        piVar3 = __base[uVar4];
        iVar6 = *piVar3;
        iVar5 = *(int *)(iVar9 + 8);
        if (*(int *)(iVar9 + 8) < iVar6) goto LAB_0809f678;
        if (iVar12 != iVar6) {
          local_3c = (double)segtree.nodes[1].area * (double)(iVar6 - iVar12) + local_3c;
        }
        uVar4 = uVar4 + 1;
        insertSegment(&segtree,1,piVar3[1],piVar3[3]);
      }
      uVar8 = boxlist->BoxN;
      iVar12 = iVar6;
    } while (uVar13 < uVar8);
  }
  free(__base);
  free(__base_00);
  free(segtree.nodes);
  return local_3c * 0.0001;
LAB_0809f480:
  if (iVar12 == 0) {
    iVar9 = 0;
    iVar5 = 0x10;
    local_40 = 2;
    local_34 = 1;
  }
  else {
    iVar9 = iVar12;
    local_34 = 1;
    do {
      iVar5 = local_34;
      local_34 = iVar5 * 2;
      iVar9 = iVar9 / 2;
    } while (iVar9 != 0);
    local_40 = iVar5 * 4;
    iVar5 = (local_40 - 1) * 0x10;
    iVar9 = local_40 - 2;
  }
  segtree.nodes = (SegmentTreeNode *)MyCalloc(local_40,0x10,"createSegmentTree");
  piVar10 = (int *)((int)&(segtree.nodes)->left + iVar5);
  iVar5 = 0xb;
  iVar6 = 10;
  if (iVar12 != 0) {
    iVar12 = iVar12 + -1;
    iVar6 = piVar3[iVar12];
    iVar5 = iVar6 + 1;
  }
  *piVar10 = iVar6;
  piVar10[1] = iVar5;
  if (local_34 <= iVar9) {
    pSVar11 = segtree.nodes + iVar9 + 1;
    pLVar7 = &segtree.nodes[iVar9].right;
    do {
      iVar5 = pSVar11->left;
      *pLVar7 = iVar5;
      if (iVar12 == 0) {
        iVar5 = iVar5 + -1;
      }
      else {
        iVar12 = iVar12 + -1;
        iVar5 = piVar3[iVar12];
      }
      ((SegmentTreeNode *)(pLVar7 + -1))->left = iVar5;
      iVar9 = iVar9 + -1;
      pSVar11 = pSVar11 + -1;
      pLVar7 = pLVar7 + -4;
    } while (local_34 <= iVar9);
    iVar9 = local_34 + -1;
  }
  if (0 < iVar9) {
    pLVar7 = &segtree.nodes[iVar9].right;
    iVar5 = 0;
    iVar12 = iVar9;
    do {
      *pLVar7 = *(LocationType *)((int)&segtree.nodes[iVar9 * 2 + 1].right + iVar5);
      pLVar1 = (LocationType *)((int)&segtree.nodes[iVar9 * 2].left + iVar5);
      iVar5 = iVar5 + -0x20;
      ((SegmentTreeNode *)(pLVar7 + -1))->left = *pLVar1;
      pLVar7 = pLVar7 + -4;
      iVar12 = iVar12 + -1;
    } while (iVar12 != 0);
  }
  goto LAB_0809f56f;
}



// WARNING: Unknown calling convention

double ComputeIntersectionArea(BoxListTypePtr boxlist)

{
  LocationType *pLVar1;
  LocationType *pLVar2;
  LocationType *pLVar3;
  double dVar4;
  LocationType *pLVar5;
  BoxTypePtr pBVar6;
  Cardinal i;
  double area;
  double dVar7;
  
  if (boxlist->BoxN == 0) {
    dVar4 = 0.0;
  }
  else {
    pBVar6 = boxlist->Box;
    dVar4 = 0.0;
    i = 0;
    do {
      pLVar1 = &pBVar6->X2;
      i = i + 1;
      pLVar5 = &pBVar6->X1;
      pLVar2 = &pBVar6->Y2;
      pLVar3 = &pBVar6->Y1;
      pBVar6 = pBVar6 + 1;
      dVar4 = (double)(*pLVar2 - *pLVar3) * (double)(*pLVar1 - *pLVar5) + dVar4;
    } while (i < boxlist->BoxN);
  }
  dVar7 = ComputeUnionArea(boxlist);
  return dVar4 * 0.0001 - dVar7;
}



// WARNING: Unknown calling convention

void FortyFiveLine(AttachedLineTypePtr Line)

{
  int iVar1;
  int iVar2;
  double dVar3;
  LocationType dy;
  uint uVar4;
  LocationType min;
  LocationType dx;
  uint uVar5;
  int iVar6;
  BYTE direction;
  uint uVar7;
  
  iVar1 = (Line->Point1).X;
  iVar2 = (Line->Point1).Y;
  uVar4 = Crosshair.Y - iVar2;
  uVar5 = Crosshair.X - iVar1;
  if (uVar5 == 0) {
    if (uVar4 == 0) {
      return;
    }
    uVar7 = (uint)((int)uVar4 < 1) << 2;
  }
  else {
    dVar3 = (double)uVar4 / (double)uVar5;
    if (dVar3 <= 0.577350269) {
      uVar7 = 2;
      if (dVar3 < -0.577350269) {
        uVar7 = (uint)(-1.732050808 <= dVar3) * 3;
      }
    }
    else {
      uVar7 = (uint)(dVar3 <= 1.732050808);
    }
    if ((int)uVar5 < 0) {
      uVar7 = uVar7 + 4;
    }
  }
  min = (uVar4 ^ (int)uVar4 >> 0x1f) - ((int)uVar4 >> 0x1f);
  iVar6 = (uVar5 ^ (int)uVar5 >> 0x1f) - ((int)uVar5 >> 0x1f);
  if (iVar6 < min) {
    min = iVar6;
  }
  switch(uVar7) {
  default:
    (Line->Point2).X = iVar1;
    (Line->Point2).Y = Crosshair.Y;
    break;
  case 1:
    iVar2 = (Line->Point1).Y;
    (Line->Point2).X = min + iVar1;
    (Line->Point2).Y = min + iVar2;
    break;
  case 2:
  case 6:
    (Line->Point2).X = Crosshair.X;
    (Line->Point2).Y = iVar2;
    break;
  case 3:
    (Line->Point2).X = min + iVar1;
    (Line->Point2).Y = iVar2 - min;
    break;
  case 5:
    (Line->Point2).X = iVar1 - min;
    (Line->Point2).Y = iVar2 - min;
    break;
  case 7:
    iVar2 = (Line->Point1).Y;
    (Line->Point2).X = iVar1 - min;
    (Line->Point2).Y = min + iVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void AdjustAttachedLine(void)

{
  int iVar1;
  
  if (Crosshair.AttachedLine.State != 0) {
    if (Settings.Mode == 2) {
      iVar1 = (*gui->control_is_pressed)();
      if (iVar1 != 0) {
        Crosshair.AttachedLine.draw = '\0';
        return;
      }
    }
    Crosshair.AttachedLine.draw = '\x01';
    if ((PCB->RatDraw == '\0') && ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) == 0)) {
      FortyFiveLine(&Crosshair.AttachedLine);
      return;
    }
    Crosshair.AttachedLine.Point2.X = Crosshair.X;
    Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
  }
  return;
}



// WARNING: Unknown calling convention

void AdjustTwoLine(int way)

{
  LocationType dx;
  int iVar1;
  uint uVar2;
  LocationType dy;
  uint uVar3;
  uint uVar4;
  int iVar6;
  int local_20;
  uint uVar5;
  
  if (Crosshair.AttachedLine.State != 0) {
    iVar1 = (*gui->control_is_pressed)();
    if (iVar1 == 0) {
      Crosshair.AttachedLine.draw = '\x01';
      if ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) == 0) {
        iVar1 = (*gui->shift_is_pressed)();
        if (iVar1 != 0) {
          way = (int)(way == 0);
        }
        uVar2 = Crosshair.X - Crosshair.AttachedLine.Point1.X;
        uVar3 = Crosshair.Y - Crosshair.AttachedLine.Point1.Y;
        uVar4 = (int)uVar2 >> 0x1f;
        uVar5 = (int)uVar3 >> 0x1f;
        if (way == 0) {
          iVar1 = (uVar4 ^ uVar2) - uVar4;
          iVar6 = (uVar5 ^ uVar3) - uVar5;
          if (iVar6 < iVar1) {
            if (((int)uVar2 < 1) && (iVar6 = -iVar6, uVar2 == 0)) {
              iVar6 = 0;
            }
            Crosshair.AttachedLine.Point2.X = Crosshair.X - iVar6;
            Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedLine.Point1.Y;
          }
          else {
            Crosshair.AttachedLine.Point2.X = Crosshair.AttachedLine.Point1.X;
            local_20 = iVar1;
            if ((int)uVar3 < 1) {
              local_20 = 0;
              if (uVar3 != 0) {
                local_20 = -iVar1;
              }
            }
            Crosshair.AttachedLine.Point2.Y = Crosshair.Y - local_20;
          }
        }
        else {
          iVar1 = (uVar4 ^ uVar2) - uVar4;
          iVar6 = (uVar5 ^ uVar3) - uVar5;
          if (iVar6 < iVar1) {
            uVar3 = 1;
            if ((int)uVar2 < 1) {
              uVar3 = ~-(uint)(uVar2 == 0);
            }
            Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
            Crosshair.AttachedLine.Point2.X = uVar3 * iVar6 + Crosshair.AttachedLine.Point1.X;
          }
          else {
            Crosshair.AttachedLine.Point2.X = Crosshair.X;
            uVar2 = 1;
            if ((int)uVar3 < 1) {
              uVar2 = ~-(uint)(uVar3 == 0);
            }
            Crosshair.AttachedLine.Point2.Y = uVar2 * iVar1 + Crosshair.AttachedLine.Point1.Y;
          }
        }
      }
      else {
        Crosshair.AttachedLine.Point2.X = Crosshair.X;
        Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
      }
    }
    else {
      Crosshair.AttachedLine.draw = '\0';
    }
  }
  return;
}



// WARNING: Unknown calling convention

float drc_lines(PointTypePtr end,Boolean way)

{
  Cardinal *pCVar1;
  int iVar2;
  Cardinal Layer;
  bool bVar3;
  float fVar4;
  uint uVar5;
  bool bVar6;
  uint uVar7;
  bool bVar8;
  LocationType length;
  uint uVar9;
  int iVar10;
  int iVar11;
  LocationType length2;
  LocationType dy;
  uint uVar12;
  DataTypePtr paVar13;
  PCBType *pPVar14;
  Cardinal entry;
  Cardinal number;
  int in_GS_OFFSET;
  uint local_1dc;
  LocationType local_1d8;
  LocationType local_1d4;
  float local_1cc;
  float local_1c8;
  int local_1c4;
  uint local_1c0;
  float local_1bc;
  uint local_1b0;
  float local_1a8;
  float local_1a4;
  uint local_1a0;
  uint local_19c;
  uint local_198;
  drc_info info;
  LineType line2;
  LineType line1;
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags(0);
  line2.Clearance = 0;
  line1.Clearance = 0;
  line1.Point1.Y = Crosshair.AttachedLine.Point1.Y;
  line2.Thickness = PCB->Bloat * 2 + 2 + Settings.LineThickness;
  line1.Point1.X = Crosshair.AttachedLine.Point1.X;
  local_1a0 = end->Y - Crosshair.AttachedLine.Point1.Y;
  local_19c = end->X - Crosshair.AttachedLine.Point1.X;
  uVar9 = (local_19c ^ (int)local_19c >> 0x1f) - ((int)local_19c >> 0x1f);
  local_1dc = (local_1a0 ^ (int)local_1a0 >> 0x1f) - ((int)local_1a0 >> 0x1f);
  bVar3 = (int)local_1dc < (int)uVar9;
  if (bVar3) {
    local_1dc = uVar9;
  }
  iVar10 = LayerStack[0];
  if (PCB->SilkActive != '\0') {
    iVar10 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  line1.Thickness = line2.Thickness;
  iVar10 = GetGroupOfLayer(iVar10);
  Layer = PCB->Data->LayerN;
  iVar11 = GetLayerGroupNumberByNumber(Layer);
  if (iVar11 == iVar10) {
    local_1c4 = Layer + 10;
    info.solder = '\x01';
  }
  else {
    info.solder = '\0';
    local_1c4 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  }
  local_1d4 = line1.Point1.X;
  local_1d8 = line1.Point1.Y;
  if (local_1dc == 0xffffffff) {
    local_1bc = 0.0;
LAB_080a061a:
    iVar10 = *(int *)(in_GS_OFFSET + 0x14);
    end->X = local_1d4;
    end->Y = local_1d8;
    if (iVar2 == iVar10) {
      return local_1bc;
    }
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  local_1bc = 0.0;
  local_1cc = 0.5;
  local_1c0 = local_1dc;
  local_1c8 = 1.0;
  if (!bVar3) goto LAB_080a009d;
LAB_0809fd5a:
  uVar9 = local_1c0;
  if ((int)local_19c < 1) {
    uVar9 = 0;
    if (local_19c != 0) {
      uVar9 = -local_1c0;
    }
  }
  local_1a0 = end->Y - line1.Point1.Y;
  local_1b0 = (local_1a0 ^ (int)local_1a0 >> 0x1f) - ((int)local_1a0 >> 0x1f);
  local_19c = uVar9;
LAB_0809fd95:
  local_1a8 = 0.5;
  local_198 = local_1b0;
  local_1a4 = 1.0;
  bVar8 = true;
  do {
    uVar9 = (int)local_198 >> 0x1f;
    if (bVar3) {
      if ((int)local_1a0 < 1) {
        if (local_1a0 == 0) {
          uVar12 = 0;
          local_1a0 = 0;
        }
        else {
          local_1a0 = -local_198;
          uVar12 = ((int)local_1a0 >> 0x1f ^ local_1a0) - ((int)local_1a0 >> 0x1f);
        }
      }
      else {
        uVar12 = (local_198 ^ uVar9) - uVar9;
        local_1a0 = local_198;
      }
      uVar9 = (local_19c ^ (int)local_19c >> 0x1f) - ((int)local_19c >> 0x1f);
      if ((int)uVar9 <= (int)uVar12) goto LAB_080a0356;
      if (way == '\0') {
        uVar9 = uVar12;
        if ((int)local_19c < 1) {
          uVar9 = 0;
          if (local_19c != 0) {
            uVar9 = -uVar12;
          }
        }
        line1.Point2.X = (line1.Point1.X + local_19c) - uVar9;
        uVar12 = 0;
      }
      else {
        uVar9 = uVar12;
        if ((int)local_19c < 1) {
          uVar9 = 0;
          if (local_19c != 0) {
            uVar9 = -uVar12;
          }
        }
        line1.Point2.X = uVar9 + line1.Point1.X;
        uVar12 = local_1a0;
      }
LAB_0809fe3c:
      line1.Point2.Y = line1.Point1.Y + uVar12;
      bVar6 = true;
      line2.Point2.X = local_19c + line1.Point1.X;
      line2.Point2.Y = local_1a0 + line1.Point1.Y;
    }
    else {
      if ((int)local_19c < 1) {
        if (local_19c == 0) {
          uVar9 = 0;
          local_19c = 0;
        }
        else {
          local_19c = -local_198;
          uVar9 = ((int)local_19c >> 0x1f ^ local_19c) - ((int)local_19c >> 0x1f);
        }
      }
      else {
        uVar9 = (local_198 ^ uVar9) - uVar9;
        local_19c = local_198;
      }
      uVar12 = (local_1a0 ^ (int)local_1a0 >> 0x1f) - ((int)local_1a0 >> 0x1f);
      if (((int)uVar9 <= (int)uVar12) && (!bVar3)) {
        if (way == '\0') {
          line1.Point2.X = line1.Point1.X;
          uVar12 = uVar9;
          if ((int)local_1a0 < 1) {
            uVar12 = 0;
            if (local_1a0 != 0) {
              uVar12 = -uVar9;
            }
          }
          uVar12 = local_1a0 - uVar12;
        }
        else {
          line1.Point2.X = line1.Point1.X + local_19c;
          uVar12 = uVar9;
          if ((int)local_1a0 < 1) {
            uVar12 = 0;
            if (local_1a0 != 0) {
              uVar12 = -uVar9;
            }
          }
        }
        goto LAB_0809fe3c;
      }
LAB_080a0356:
      if (bVar3) {
        uVar5 = local_19c;
        if (way == '\0') {
          uVar7 = 0;
        }
        else {
          uVar7 = uVar9;
          if ((int)local_1a0 < 1) {
            uVar7 = 0;
            if (local_1a0 != 0) {
              uVar7 = -uVar9;
            }
          }
        }
      }
      else {
        uVar7 = local_1a0;
        if (way == '\0') {
          uVar5 = 0;
        }
        else {
          uVar5 = uVar12;
          if ((int)local_19c < 1) {
            uVar5 = 0;
            if (local_19c != 0) {
              uVar5 = -uVar12;
            }
          }
        }
      }
      line2.Point2.Y = uVar7 + line1.Point1.Y;
      line2.Point2.X = uVar5 + line1.Point1.X;
      bVar6 = false;
      line1.Point2.X = line2.Point2.X;
      line1.Point2.Y = line2.Point2.Y;
    }
    line2.Point1.X = line1.Point2.X;
    line2.Point1.Y = line1.Point2.Y;
    SetLineBoundingBox(&line1);
    SetLineBoundingBox(&line2);
    iVar11 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar11 == 0) {
      info.line = &line1;
      r_search(PCB->Data->via_tree,&(info.line)->BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               drcVia_callback,&info);
      r_search(PCB->Data->pin_tree,&line1.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               drcVia_callback,&info);
      if ((local_1c4 == iVar10) || (info.solder != '\0')) {
        r_search(PCB->Data->pad_tree,&line1.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 drcPad_callback,&info);
      }
      if (bVar6) {
        info.line = &line2;
        r_search(PCB->Data->via_tree,&line2.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 drcVia_callback,&info);
        r_search(PCB->Data->pin_tree,&line2.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 drcVia_callback,&info);
        if ((local_1c4 == iVar10) || (info.solder != '\0')) {
          r_search(PCB->Data->pad_tree,&line2.BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   drcPad_callback,&info);
        }
      }
      paVar13 = PCB->Data;
      pPVar14 = paVar13->pcb;
      if ((pPVar14->LayerGroups).Number[iVar10] != 0) {
        uVar9 = 0;
        do {
          uVar12 = (pPVar14->LayerGroups).Entries[iVar10][uVar9];
          if (uVar12 < (uint)paVar13->LayerN) {
            info.line = &line1;
            r_search(paVar13->Layer[uVar12].line_tree,&line1.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,drcLine_callback,&info);
            r_search(paVar13->Layer[uVar12].arc_tree,&line1.BoundingBox,
                     (_func_int_BoxType_ptr_void_ptr *)0x0,drcArc_callback,&info);
            if (bVar6) {
              info.line = &line2;
              r_search(paVar13->Layer[uVar12].line_tree,&(info.line)->BoundingBox,
                       (_func_int_BoxType_ptr_void_ptr *)0x0,drcLine_callback,&info);
              r_search(paVar13->Layer[uVar12].arc_tree,&line2.BoundingBox,
                       (_func_int_BoxType_ptr_void_ptr *)0x0,drcArc_callback,&info);
            }
          }
          uVar9 = uVar9 + 1;
          paVar13 = PCB->Data;
          pPVar14 = paVar13->pcb;
          pCVar1 = (pPVar14->LayerGroups).Number + iVar10;
        } while (uVar9 <= *pCVar1 && *pCVar1 != uVar9);
      }
      local_1a4 = local_1a4 + local_1a8;
      bVar8 = false;
      fVar4 = (float)(line2.Point2.Y - line1.Point1.Y) * (float)(line2.Point2.Y - line1.Point1.Y) +
              (float)(line2.Point2.X - line1.Point1.X) * (float)(line2.Point2.X - line1.Point1.X);
      if (local_1bc < fVar4) {
        local_1d8 = line2.Point2.Y;
        local_1d4 = line2.Point2.X;
        local_1bc = fVar4;
      }
    }
    else {
      local_1a4 = local_1a4 - local_1a8;
    }
    fVar4 = (float)local_1b0;
    if (local_1a4 * fVar4 < fVar4) {
      fVar4 = local_1a4 * fVar4;
    }
    if ((int)ROUND(fVar4) == local_198) break;
    local_1a8 = local_1a8 * 0.5;
    local_198 = (int)ROUND(fVar4);
  } while( true );
  if (!bVar8) {
    if (bVar3) {
      if (line2.Point2.X - line1.Point1.X == local_19c) goto LAB_080a0690;
    }
    else if (line2.Point2.Y - line1.Point1.Y == local_1a0) {
LAB_080a0690:
      local_1c8 = local_1c8 + local_1cc;
      goto LAB_080a003a;
    }
  }
  local_1c8 = local_1c8 - local_1cc;
LAB_080a003a:
  fVar4 = (float)local_1dc;
  if (local_1c8 * fVar4 < fVar4) {
    fVar4 = local_1c8 * fVar4;
  }
  uVar9 = (uint)ROUND(fVar4);
  if (uVar9 == local_1c0) goto LAB_080a061a;
  local_1cc = local_1cc * 0.5;
  local_1c0 = uVar9;
  if (bVar3) goto LAB_0809fd5a;
LAB_080a009d:
  uVar9 = local_1c0;
  if ((int)local_1a0 < 1) {
    uVar9 = 0;
    if (local_1a0 != 0) {
      uVar9 = -local_1c0;
    }
  }
  local_19c = end->X - line1.Point1.X;
  local_1b0 = (local_19c ^ (int)local_19c >> 0x1f) - ((int)local_19c >> 0x1f);
  local_1a0 = uVar9;
  goto LAB_0809fd95;
}



// WARNING: Unknown calling convention

void EnforceLineDRC(void)

{
  char cVar1;
  Boolean shift;
  int iVar2;
  int iVar3;
  float r2;
  float r1;
  float fVar4;
  float fVar5;
  PointType rs;
  PointType r45;
  
  iVar2 = (*gui->mod1_is_pressed)();
  if (iVar2 == 0) {
    iVar2 = (*gui->control_is_pressed)();
    if ((iVar2 == 0) && (PCB->RatDraw == '\0')) {
      if (PCB->SilkActive == '\0') {
        iVar2 = PCB->Data->LayerN;
        iVar3 = LayerStack[0];
      }
      else {
        iVar2 = PCB->Data->LayerN;
        iVar3 = (uint)(Settings.ShowSolderSide == '\0') + iVar2;
      }
      if (iVar3 < iVar2) {
        r45.X = Crosshair.X;
        rs.X = Crosshair.X;
        r45.Y = Crosshair.Y;
        rs.Y = Crosshair.Y;
        fVar4 = drc_lines(&rs,'\0');
        fVar5 = drc_lines(&r45,'\x01');
        iVar2 = (*gui->shift_is_pressed)();
        cVar1 = (char)iVar2;
        if (cVar1 == '\0') {
          if (fVar5 >= fVar4) goto LAB_080a0824;
        }
        else if (fVar5 < fVar4) {
LAB_080a0824:
          if (PCB->Clipping != 0) {
            PCB->Clipping = ~-(uint)(cVar1 == '\0') + 2;
          }
          Crosshair.X = r45.X;
          Crosshair.Y = r45.Y;
          return;
        }
        if (PCB->Clipping != 0) {
          PCB->Clipping = 2 - (uint)(cVar1 == '\0');
        }
        Crosshair.X = rs.X;
        Crosshair.Y = rs.Y;
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int drcArc_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((*(byte *)&b[1].Y1 & 4) == 0) {
                    // WARNING: Load size is inaccurate
    BVar1 = LineArcIntersect(*cl,(ArcTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

int drcLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((*(byte *)&b[1].Y1 & 4) == 0) {
                    // WARNING: Load size is inaccurate
    BVar1 = LineLineIntersect((LineTypePtr)b,*cl);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

int drcPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((((uint)b[1].Y1 >> 7 & 1) == (int)*(char *)((int)cl + 4)) && ((b[1].Y1 & 4U) == 0)) {
                    // WARNING: Load size is inaccurate
    BVar1 = LinePadIntersect(*cl,(PadTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

int drcVia_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((*(byte *)&b[1].Y1 & 4) == 0) {
                    // WARNING: Load size is inaccurate
    BVar1 = PinLineIntersect((PinTypePtr)b,*cl);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

char * lrealpath(char *filename)

{
  int iVar1;
  char *pcVar2;
  char *rp;
  int in_GS_OFFSET;
  char buf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar2 = (char *)__realpath_chk(filename,buf,0x1000);
  if (pcVar2 == (char *)0x0) {
    pcVar2 = filename;
  }
  pcVar2 = (char *)__strdup(pcVar2);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pcVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void print_defaults_1(HID_Attribute *a,void *value)

{
  double dVar1;
  int i;
  int iVar2;
  char *pcVar3;
  char *s;
  double d;
  
  switch(a->type) {
  default:
    goto switchD_080a0a1f_caseD_0;
  case CONFIG_PAGE_COLUMN:
    if (value == (void *)0x0) {
      iVar2 = (a->default_val).int_value;
    }
    else {
                    // WARNING: Load size is inaccurate
      iVar2 = *value;
    }
    __fprintf_chk(stderr,1,"%s %d\n",a->name,iVar2);
    return;
  case DBUS_BUS_STARTER:
    if (value == (void *)0x0) {
      dVar1 = (a->default_val).real_value;
    }
    else {
                    // WARNING: Load size is inaccurate
      dVar1 = *value;
    }
    __fprintf_chk(stderr,1,"%s %g\n",a->name,dVar1);
    return;
  case GDK_CAP_PROJECTING:
  case GDK_NOOP:
    if (value == (void *)0x0) {
      s = (a->default_val).str_value;
    }
    else {
                    // WARNING: Load size is inaccurate
      s = *value;
    }
    __fprintf_chk(stderr,1,"%s \"%s\"\n",a->name,s);
    return;
  case DBUS_WATCH_ERROR:
    if (value == (void *)0x0) {
      i = (a->default_val).int_value;
    }
    else {
                    // WARNING: Load size is inaccurate
      i = (int)*value;
    }
    pcVar3 = "no";
    if (i != 0) {
      pcVar3 = "yes";
    }
    break;
  case GDK_AND_REVERSE:
    if (value == (void *)0x0) {
      iVar2 = (a->default_val).int_value;
    }
    else {
                    // WARNING: Load size is inaccurate
      iVar2 = *value;
    }
    pcVar3 = a->enumerations[iVar2];
    break;
  case EXPANSION_AREA:
    if (value == (void *)0x0) {
      iVar2 = (a->default_val).int_value;
      dVar1 = (a->default_val).real_value;
    }
    else {
                    // WARNING: Load size is inaccurate
      iVar2 = *value;
                    // WARNING: Load size is inaccurate
      dVar1 = *value;
    }
    __fprintf_chk(stderr,1,"%s %g%s\n",a->name,dVar1,a->enumerations[iVar2]);
    return;
  }
  __fprintf_chk(stderr,1,"%s %s\n",a->name,pcVar3);
switchD_080a0a1f_caseD_0:
  return;
}



// WARNING: Unknown calling convention

void u(char *fmt,...)

{
  __vfprintf_chk(stderr,1,fmt,&stack0x00000008);
  fputc(10,stderr);
  return;
}



// WARNING: Unknown calling convention

void usage_attr(HID_Attribute *a)

{
  undefined4 *puVar1;
  uint uVar2;
  uint uVar3;
  size_t sVar4;
  undefined *puVar5;
  uint *puVar6;
  uint *puVar7;
  char *pcVar8;
  int iVar9;
  int i;
  int iVar10;
  bool bVar11;
  char *pcVar12;
  
  pcVar8 = a->help_text;
  if (pcVar8 == &DAT_00000001) {
    return;
  }
  if ((uint)a->type < 8) {
    switch(a->type) {
    case CONFIG_NAME_COLUMN:
      goto switchD_080a0cb3_caseD_0;
    default:
      pcVar8 = a->name;
      pcVar12 = "--%s <num>";
      break;
    case GDK_CAP_PROJECTING:
      pcVar8 = a->name;
      pcVar12 = "--%s <string>";
      break;
    case DBUS_WATCH_ERROR:
      pcVar8 = a->name;
      pcVar12 = "--%s";
      break;
    case GDK_AND_REVERSE:
    case EXPANSION_AREA:
      __sprintf_chk(usage_attr::buf,1,200,"--%s ",a->name);
      if (a->type == EXPANSION_AREA) {
        __strcat_chk(usage_attr::buf," <val>",200);
      }
      if (*a->enumerations != (char *)0x0) {
        iVar10 = 0;
        iVar9 = 0;
        puVar5 = &DAT_08148545;
        do {
          iVar9 = iVar9 + 1;
          __strcat_chk(usage_attr::buf,puVar5,200);
          puVar1 = (undefined4 *)((int)a->enumerations + iVar10);
          iVar10 = iVar9 * 4;
          __strcat_chk(usage_attr::buf,*puVar1,200);
          puVar5 = &DAT_08148547;
        } while (a->enumerations[iVar9] != (char *)0x0);
      }
      __strcat_chk(usage_attr::buf,">",200);
      pcVar8 = a->help_text;
      goto LAB_080a0c21;
    case GDK_NOOP:
      pcVar8 = a->name;
      pcVar12 = "--%s <path>";
    }
    __sprintf_chk(usage_attr::buf,1,200,pcVar12,pcVar8);
    pcVar8 = a->help_text;
  }
LAB_080a0c21:
  puVar7 = (uint *)usage_attr::buf;
  do {
    puVar6 = puVar7;
    uVar2 = *puVar6 + 0xfefefeff & ~*puVar6;
    uVar3 = uVar2 & 0x80808080;
    puVar7 = puVar6 + 1;
  } while (uVar3 == 0);
  bVar11 = (uVar2 & 0x8080) == 0;
  if (bVar11) {
    uVar3 = uVar3 >> 0x10;
  }
  if (bVar11) {
    puVar7 = (uint *)((int)puVar6 + 6);
  }
  uVar3 = (int)puVar7 + (-0x816c783 - (uint)CARRY1((byte)uVar3,(byte)uVar3));
  if (uVar3 < 0x1f) {
    if (pcVar8 != (char *)0x0) {
      __fprintf_chk(stderr,1," %-30s\t%s\n",usage_attr::buf,pcVar8);
      return;
    }
    __fprintf_chk(stderr,1," %-30s\n",usage_attr::buf);
  }
  else if (pcVar8 == (char *)0x0) {
    __fprintf_chk(stderr,1," %s\n",usage_attr::buf);
  }
  else {
    sVar4 = strlen(pcVar8);
    if (sVar4 + uVar3 < 0x48) {
      __fprintf_chk(stderr,1," %s\t%s\n",usage_attr::buf,pcVar8);
    }
    else {
      __fprintf_chk(stderr,1,&DAT_08148570,usage_attr::buf,pcVar8);
    }
  }
switchD_080a0cb3_caseD_0:
  return;
}



// WARNING: Unknown calling convention

void usage_hid(HID *h)

{
  HID **ppHVar1;
  HID *pHVar2;
  HID **ppHVar3;
  HID_Attribute *pHVar4;
  HID_Attribute *e;
  HID_Attribute *pHVar5;
  int i;
  HID **ppHVar6;
  int iVar7;
  HID_AttrNode *ha;
  HID_AttrNode *pHVar8;
  int iVar9;
  int local_20 [4];
  
  if ((h->field_0xc & 1) == 0) {
    __fprintf_chk(stderr,1,"\n%s options:\n",h->name);
    exporter = h;
    pHVar5 = (*h->get_export_options)(local_20);
    if (pHVar5 != (HID_Attribute *)0x0) {
      if (0 < local_20[0]) {
        iVar7 = 0;
        do {
          iVar7 = iVar7 + 1;
          usage_attr(pHVar5);
          pHVar5 = pHVar5 + 1;
        } while (iVar7 < local_20[0]);
      }
      exporter = (HID *)0x0;
      return;
    }
  }
  else {
    ppHVar3 = hid_enumerate();
    __fprintf_chk(stderr,1,"\ngui options:\n");
    for (pHVar8 = hid_attr_nodes; pHVar8 != (HID_AttrNode *)0x0; pHVar8 = pHVar8->next) {
      while( true ) {
        pHVar2 = *ppHVar3;
        ppHVar6 = ppHVar3;
        while (pHVar2 != (HID *)0x0) {
          pHVar5 = pHVar8->attributes;
          pHVar4 = (*pHVar2->get_export_options)((int *)0x0);
          if (pHVar5 == pHVar4) goto skip_this_one;
          ppHVar1 = ppHVar6 + 1;
          ppHVar6 = ppHVar6 + 1;
          pHVar2 = *ppHVar1;
        }
        if (pHVar8->n < 1) break;
        iVar9 = 0;
        iVar7 = 0;
        do {
          iVar7 = iVar7 + 1;
          pHVar5 = (HID_Attribute *)((int)&pHVar8->attributes->name + iVar9);
          iVar9 = iVar9 + 0x30;
          usage_attr(pHVar5);
        } while (pHVar8->n != iVar7 && iVar7 <= pHVar8->n);
        pHVar8 = pHVar8->next;
        if (pHVar8 == (HID_AttrNode *)0x0) {
          return;
        }
      }
skip_this_one:
    }
  }
  return;
}



// WARNING: Unknown calling convention

void usage(void)

{
  HID **ppHVar1;
  byte bVar2;
  HID **ppHVar3;
  char *pcVar4;
  HID *pHVar5;
  HID **ppHVar6;
  int iVar7;
  int n_exporter;
  int n_printer;
  int iVar8;
  int iVar9;
  int n_gui;
  
  ppHVar3 = hid_enumerate();
  pHVar5 = *ppHVar3;
  if (pHVar5 == (HID *)0x0) {
    iVar8 = 0;
    iVar7 = 0;
    u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
    u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright",Progname);
    u("%s [gui options] <pcb file>\t\tto edit",Progname);
  }
  else {
    iVar7 = 0;
    iVar9 = 0;
    iVar8 = 0;
    ppHVar6 = ppHVar3;
    do {
      bVar2 = pHVar5->field_0xc;
      iVar9 = (iVar9 + 1) - (uint)((bVar2 & 1) == 0);
      iVar8 = (iVar8 + 1) - (uint)((bVar2 & 2) == 0);
      pHVar5 = ppHVar6[1];
      iVar7 = (iVar7 + 1) - (uint)((bVar2 & 4) == 0);
      ppHVar6 = ppHVar6 + 1;
    } while (pHVar5 != (HID *)0x0);
    u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
    u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright",Progname);
    u("%s [gui options] <pcb file>\t\tto edit",Progname);
    pcVar4 = "";
    if (iVar9 == 1) goto LAB_080a1099;
  }
  pcVar4 = "s";
LAB_080a1099:
  u("Available GUI hid%s:",pcVar4);
  pHVar5 = *ppHVar3;
  ppHVar6 = ppHVar3;
  while (pHVar5 != (HID *)0x0) {
    while ((pHVar5->field_0xc & 1) == 0) {
      pHVar5 = ppHVar6[1];
      ppHVar6 = ppHVar6 + 1;
      if (pHVar5 == (HID *)0x0) goto LAB_080a10fd;
    }
    __fprintf_chk(stderr,1,"\t%s\t%s\n",pHVar5->name,pHVar5->description);
    ppHVar1 = ppHVar6 + 1;
    ppHVar6 = ppHVar6 + 1;
    pHVar5 = *ppHVar1;
  }
LAB_080a10fd:
  u("%s -p [printing options] <pcb file>\tto print",Progname);
  pcVar4 = "s";
  if (iVar8 == 1) {
    pcVar4 = "";
  }
  u("Available printing hid%s:",pcVar4);
  pHVar5 = *ppHVar3;
  ppHVar6 = ppHVar3;
  while (pHVar5 != (HID *)0x0) {
    while ((pHVar5->field_0xc & 2) == 0) {
      pHVar5 = ppHVar6[1];
      ppHVar6 = ppHVar6 + 1;
      if (pHVar5 == (HID *)0x0) goto LAB_080a1185;
    }
    __fprintf_chk(stderr,1,"\t%s\t%s\n",pHVar5->name,pHVar5->description);
    ppHVar1 = ppHVar6 + 1;
    ppHVar6 = ppHVar6 + 1;
    pHVar5 = *ppHVar1;
  }
LAB_080a1185:
  u("%s -x hid [export options] <pcb file>\tto export",Progname);
  pcVar4 = "s";
  if (iVar7 == 1) {
    pcVar4 = "";
  }
  u("Available export hid%s:",pcVar4);
  pHVar5 = *ppHVar3;
  ppHVar6 = ppHVar3;
  if (pHVar5 != (HID *)0x0) {
    do {
      while ((pHVar5->field_0xc & 4) != 0) {
        __fprintf_chk(stderr,1,"\t%s\t%s\n",pHVar5->name,pHVar5->description);
        pHVar5 = ppHVar6[1];
        ppHVar6 = ppHVar6 + 1;
        if (pHVar5 == (HID *)0x0) goto LAB_080a1215;
      }
      pHVar5 = ppHVar6[1];
      ppHVar6 = ppHVar6 + 1;
    } while (pHVar5 != (HID *)0x0);
LAB_080a1215:
    pHVar5 = *ppHVar3;
    ppHVar6 = ppHVar3;
    if (pHVar5 != (HID *)0x0) {
      do {
        while ((pHVar5->field_0xc & 1) != 0) {
          usage_hid(pHVar5);
          pHVar5 = ppHVar6[1];
          ppHVar6 = ppHVar6 + 1;
          if (pHVar5 == (HID *)0x0) goto LAB_080a1247;
        }
        pHVar5 = ppHVar6[1];
        ppHVar6 = ppHVar6 + 1;
      } while (pHVar5 != (HID *)0x0);
LAB_080a1247:
      pHVar5 = *ppHVar3;
      ppHVar6 = ppHVar3;
      if (pHVar5 != (HID *)0x0) {
        do {
          while ((pHVar5->field_0xc & 2) != 0) {
            usage_hid(pHVar5);
            pHVar5 = ppHVar6[1];
            ppHVar6 = ppHVar6 + 1;
            if (pHVar5 == (HID *)0x0) goto LAB_080a1277;
          }
          pHVar5 = ppHVar6[1];
          ppHVar6 = ppHVar6 + 1;
        } while (pHVar5 != (HID *)0x0);
LAB_080a1277:
        pHVar5 = *ppHVar3;
        while (pHVar5 != (HID *)0x0) {
          while ((pHVar5->field_0xc & 4) == 0) {
            pHVar5 = ppHVar3[1];
            ppHVar3 = ppHVar3 + 1;
            if (pHVar5 == (HID *)0x0) goto LAB_080a12a7;
          }
          usage_hid(pHVar5);
          ppHVar6 = ppHVar3 + 1;
          ppHVar3 = ppHVar3 + 1;
          pHVar5 = *ppHVar6;
        }
      }
    }
  }
LAB_080a12a7:
                    // WARNING: Subroutine does not return
  exit(1);
}



// WARNING: Unknown calling convention

void print_version(void)

{
  __printf_chk(1,"PCB version %s\n","20091103");
                    // WARNING: Subroutine does not return
  exit(0);
}



// WARNING: Unknown calling convention

void copyright(void)

{
  __printf_chk(1,
               "\n                COPYRIGHT for %s version %s\n\n    PCB, interactive printed circuit board design\n    Copyright (C) 1994,1995,1996,1997 Thomas Nau\n    Copyright (C) 1998, 1999, 2000 Harry Eaton\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n"
               ,Progname,"20091103");
                    // WARNING: Subroutine does not return
  exit(0);
}



// WARNING: Unknown calling convention

void register_main_attribute_list(void)

{
  hid_register_attributes(main_attribute_list,0x85);
  return;
}



// WARNING: Unknown calling convention

int main(int argc,char **argv)

{
  HID **ppHVar1;
  HID *pHVar2;
  HID_AttrNode *pHVar3;
  PCBTypePtr pPVar4;
  size_t sVar5;
  char *pcVar6;
  char *t2;
  char *tmps;
  uchar *__s1;
  char *pcVar7;
  LayerGroupType *LayerGroup;
  char *tmps_1;
  char *__s;
  char *__filename;
  int r;
  undefined4 *__s_00;
  HID **ppHVar8;
  HID **hl;
  HID_Attribute *e;
  HID_Attribute *pHVar9;
  int haspath;
  int iVar10;
  char cVar11;
  size_t sVar12;
  int i_1;
  int iVar13;
  char *p;
  int i;
  int i_2;
  char *__retval;
  byte *pbVar14;
  byte *pbVar15;
  byte *pbVar16;
  HID_AttrNode *ha;
  int in_GS_OFFSET;
  bool bVar17;
  bool bVar18;
  bool bVar19;
  byte bVar20;
  char *path;
  stat sb;
  int n;
  char buf [20];
  char **local_a4 [4];
  stat local_94;
  int local_3c;
  char local_38 [20];
  int local_24;
  
  bVar20 = 0;
  local_a4[0] = argv;
  local_24 = *(int *)(in_GS_OFFSET + 0x14);
  register_action_action_list();
  register_rotate_action_list();
  register_command_action_list();
  register_djopt_flag_list();
  register_djopt_action_list();
  register_flags_flag_list();
  register_fontmode_action_list();
  register_main_attribute_list();
  register_move_action_list();
  register_netlist_action_list();
  register_puller_action_list();
  register_report_action_list();
  register_vendor_action_list();
  register_vendor_flag_list();
  register_toporouter_action_list();
  setbuf(stdout,(char *)0x0);
  pcVar6 = *local_a4[0];
  sVar5 = strlen(pcVar6);
  bVar17 = false;
  for (sVar12 = 0; sVar12 != sVar5; sVar12 = sVar12 + 1) {
    if (pcVar6[sVar12] == '/') {
      bVar17 = true;
    }
  }
  if (bVar17) {
    pcVar6 = lrealpath(pcVar6);
    bindir = (char *)__strdup(pcVar6);
LAB_080a1465:
    __s_00 = (undefined4 *)bindir;
    pcVar6 = strchr(bindir,0x2f);
    if ((pcVar6 != (char *)0x0) && (*pcVar6 != '\0')) {
      do {
        pcVar7 = pcVar6;
        pcVar6 = strchr(pcVar7 + 1,0x2f);
        if (pcVar6 == (char *)0x0) break;
      } while (*pcVar6 != '\0');
      *pcVar7 = '\0';
      __s_00 = (undefined4 *)bindir;
    }
  }
  else {
    pcVar7 = getenv("PATH");
    if (pcVar7 != (char *)0x0) {
      __s = (char *)__strdup(pcVar7);
      pcVar7 = strtok(__s,":");
      while ((pcVar7 != (char *)0x0 && (*pcVar7 != '\0'))) {
        sVar5 = strlen(pcVar6);
        sVar12 = strlen(pcVar7);
        __filename = (char *)calloc(1,sVar5 + 2 + sVar12);
        if (__filename == (char *)0x0) goto LAB_080a20dd;
        __sprintf_chk(__filename,1,0xffffffff,"%s%s%s",pcVar7,"/",pcVar6);
        iVar13 = __xstat(3,__filename,&local_94);
        if (iVar13 == 0) {
          bindir = lrealpath(__filename);
          free(__filename);
          free(__s);
          goto LAB_080a1465;
        }
        free(__filename);
        pcVar7 = strtok((char *)0x0,":");
      }
      free(__s);
    }
    __s_00 = (undefined4 *)calloc(1,9);
    bindir = (char *)__s_00;
    if (__s_00 != (undefined4 *)0x0) {
      *__s_00 = 0x7273752f;
      __s_00[1] = 0x6e69622f;
      *(undefined *)(__s_00 + 2) = 0;
    }
  }
  sVar5 = strlen((char *)__s_00);
  exec_prefix = (char *)calloc(1,sVar5 + 4);
  if (exec_prefix == (char *)0x0) {
LAB_080a20dd:
    __fprintf_chk(stderr,1,"InitPaths():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  __sprintf_chk(exec_prefix,1,0xffffffff,"%s%s%s",bindir,"/","..");
  sVar5 = strlen(bindir);
  pcblibdir = (char *)calloc(1,sVar5 + 0xe);
  if (pcblibdir == (char *)0x0) goto LAB_080a20dd;
  __sprintf_chk(pcblibdir,1,0xffffffff,"%s%s%s",bindir,"/","../share/pcb");
  sVar5 = strlen(bindir);
  pcbtreedir = (char *)calloc(1,sVar5 + 0x15);
  if (pcbtreedir == (char *)0x0) goto LAB_080a20dd;
  pcVar6 = "../share/pcb/newlib";
  __sprintf_chk(pcbtreedir,1,0xffffffff,"%s%s%s",bindir,"/","../share/pcb/newlib");
  sVar5 = strlen(pcblibdir);
  pcblibpath = (char *)calloc(1,sVar5 + 3);
  if (pcblibpath == (char *)0x0) goto LAB_080a20dd;
  __sprintf_chk(pcblibpath,1,0xffffffff,&DAT_08148643,&DAT_0814d79c,pcblibdir,pcVar6);
  sVar5 = strlen(pcblibdir);
  sVar12 = strlen(pcbtreedir);
  pcbtreepath = (char *)calloc(1,sVar5 + 0x10 + sVar12);
  if (pcbtreepath == (char *)0x0) goto LAB_080a20dd;
  __sprintf_chk(pcbtreepath,1,0xffffffff,"%s%s%s%spcblib-newlib",pcbtreedir,&DAT_0814d79c,pcblibdir,
                "/");
  iVar13 = 0;
  do {
    while( true ) {
      pbVar15 = *(byte **)((int)&main_attribute_list[0].name + iVar13);
      bVar17 = false;
      bVar19 = pbVar15 == (byte *)0x0;
      if (!bVar19) break;
LAB_080a1719:
      iVar13 = iVar13 + 0x30;
      if (iVar13 == 0x18f0) goto LAB_080a178a;
    }
    iVar10 = 0x10;
    pbVar14 = pbVar15;
    pbVar16 = (byte *)"lib-command-dir";
    do {
      if (iVar10 == 0) break;
      iVar10 = iVar10 + -1;
      bVar17 = *pbVar14 < *pbVar16;
      bVar19 = *pbVar14 == *pbVar16;
      pbVar14 = pbVar14 + (uint)bVar20 * -2 + 1;
      pbVar16 = pbVar16 + (uint)bVar20 * -2 + 1;
    } while (bVar19);
    if (bVar19) {
      *(char **)((int)&main_attribute_list[0].default_val.str_value + iVar13) = pcblibdir;
    }
    iVar10 = 10;
    pbVar14 = pbVar15;
    pbVar16 = (byte *)"font-path";
    do {
      if (iVar10 == 0) break;
      iVar10 = iVar10 + -1;
      bVar17 = *pbVar14 < *pbVar16;
      bVar19 = *pbVar14 == *pbVar16;
      pbVar14 = pbVar14 + (uint)bVar20 * -2 + 1;
      pbVar16 = pbVar16 + (uint)bVar20 * -2 + 1;
    } while (bVar19);
    bVar18 = (!bVar17 && !bVar19) < bVar17;
    bVar17 = (!bVar17 && !bVar19) == bVar17;
    if (!bVar17) {
      iVar10 = 0xd;
      pbVar14 = pbVar15;
      pbVar16 = (byte *)"element-path";
      do {
        if (iVar10 == 0) break;
        iVar10 = iVar10 + -1;
        bVar18 = *pbVar14 < *pbVar16;
        bVar17 = *pbVar14 == *pbVar16;
        pbVar14 = pbVar14 + (uint)bVar20 * -2 + 1;
        pbVar16 = pbVar16 + (uint)bVar20 * -2 + 1;
      } while (bVar17);
      bVar17 = (!bVar18 && !bVar17) == bVar18;
      if (bVar17) goto LAB_080a176a;
      iVar10 = 9;
      pbVar14 = (byte *)"lib-path";
      do {
        if (iVar10 == 0) break;
        iVar10 = iVar10 + -1;
        bVar17 = *pbVar15 == *pbVar14;
        pbVar15 = pbVar15 + (uint)bVar20 * -2 + 1;
        pbVar14 = pbVar14 + (uint)bVar20 * -2 + 1;
      } while (bVar17);
      if (bVar17) goto LAB_080a176a;
      pcVar6 = *(char **)((int)&main_attribute_list[0].name + iVar13);
LAB_080a1700:
      iVar10 = 0xb;
      pcVar7 = "lib-newlib";
      do {
        if (iVar10 == 0) break;
        iVar10 = iVar10 + -1;
        bVar17 = *pcVar6 == *pcVar7;
        pcVar6 = pcVar6 + (uint)bVar20 * -2 + 1;
        pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
      } while (bVar17);
      if (bVar17) {
        *(char **)((int)&main_attribute_list[0].default_val.str_value + iVar13) = pcbtreepath;
      }
      goto LAB_080a1719;
    }
LAB_080a176a:
    pcVar6 = *(char **)((int)&main_attribute_list[0].name + iVar13);
    bVar17 = pcVar6 == (char *)0x0;
    *(char **)((int)&main_attribute_list[0].default_val.str_value + iVar13) = pcblibpath;
    if (!bVar17) goto LAB_080a1700;
    iVar13 = iVar13 + 0x30;
  } while (iVar13 != 0x18f0);
LAB_080a178a:
  pcVar6 = getenv("HOME");
  if ((pcVar6 == (char *)0x0) && (pcVar6 = getenv("USERPROFILE"), pcVar6 == (char *)0x0)) {
    homedir = (char *)0x0;
  }
  else {
    homedir = (char *)__strdup(pcVar6);
  }
  bindtextdomain(&DAT_0815492c,"/usr/share/locale");
  bind_textdomain_codeset(&DAT_0815492c,"UTF-8");
  hid_init();
  hid_load_settings();
  pcVar6 = *local_a4[0];
  program_name = pcVar6;
  program_basename = strrchr(pcVar6,0x2f);
  if (program_basename == (char *)0x0) {
    program_directory = ".";
  }
  else {
    program_directory = (char *)__strdup(pcVar6);
    pcVar6 = strrchr(program_directory,0x2f);
    *pcVar6 = '\0';
    pcVar6 = program_basename + 1;
  }
  program_basename = pcVar6;
  Progname = pcVar6;
  if (1 < argc) {
    pcVar6 = local_a4[0][1];
    cVar11 = *pcVar6;
    if (((cVar11 == '-') && (pcVar6[1] == 'h')) && (pcVar6[2] == '\0')) {
      usage();
      if (argc < 2) goto LAB_080a18b2;
      pcVar6 = local_a4[0][1];
      cVar11 = *pcVar6;
    }
    if (((cVar11 == '-') && (pcVar6[1] == 'V')) && (pcVar6[2] == '\0')) {
      print_version();
      if (argc < 2) goto LAB_080a18b2;
      pcVar6 = local_a4[0][1];
      cVar11 = *pcVar6;
    }
    if (((cVar11 == '-') && (pcVar6[1] == 'p')) && (pcVar6[2] == '\0')) {
      gui = hid_find_printer();
      argc = argc + -1;
      local_a4[0] = local_a4[0] + 1;
      exporter = gui;
      goto LAB_080a18bc;
    }
    if ((((2 < argc) && (cVar11 == '-')) && (pcVar6[1] == 'x')) && (pcVar6[2] == '\0')) {
      gui = hid_find_exporter(local_a4[0][2]);
      argc = argc + -2;
      local_a4[0] = local_a4[0] + 2;
      exporter = gui;
      goto LAB_080a18bc;
    }
  }
LAB_080a18b2:
  gui = hid_find_gui();
LAB_080a18bc:
  if (gui != (HID *)0x0) {
    iVar13 = 0;
    do {
      iVar10 = iVar13 + 1;
      pcVar6 = "signal%d";
      __sprintf_chk(local_38,1,0x14,"signal%d",iVar10);
      pcVar7 = MyStrdup(local_38,"DefaultLayerNames");
      Settings.LayerColor[iVar13] = "#c49350";
      Settings.LayerSelectedColor[iVar13] = "#00ffff";
      Settings.DefaultLayerName[iVar13] = pcVar7;
      iVar13 = iVar10;
    } while (iVar10 != 0x10);
    (*gui->parse_arguments)(&argc,local_a4);
    if ((show_help != 0) || ((1 < argc && (*local_a4[0][1] == '-')))) {
      usage();
    }
    if (show_version != 0) {
      print_version();
    }
    if (show_defaults == 0) {
      if (show_copyright != 0) {
        copyright();
      }
      Output.bgGC = (*gui->make_gc)();
      Output.fgGC = (*gui->make_gc)();
      Output.pmGC = (*gui->make_gc)();
      Output.GridGC = (*gui->make_gc)();
      if (1 < (byte)(*Settings.LibraryCommand - 0x2eU)) {
        Settings.LibraryCommand = Concat(Settings.LibraryCommandDir,"/",Settings.LibraryCommand,0);
      }
      if (1 < (byte)(*Settings.LibraryContentsCommand - 0x2eU)) {
        Settings.LibraryContentsCommand =
             Concat(Settings.LibraryCommandDir,"/",Settings.LibraryContentsCommand,0);
      }
      if (9999999 < Settings.LineThickness - 1U) {
        Settings.LineThickness = 1000;
      }
      if (0x988eb0 < Settings.ViaThickness - 2000U) {
        Settings.ViaThickness = 4000;
      }
      if (Settings.ViaDrillingHole < 1) {
        Settings.ViaDrillingHole = (Settings.ViaThickness * 0x28) / 100;
      }
      iVar13 = 1000;
      if (999 < Settings.MaxWidth) {
        iVar13 = Settings.MaxWidth;
      }
      if (10000000 < iVar13) {
        iVar13 = 10000000;
      }
      iVar10 = 1000;
      if (999 < Settings.MaxHeight) {
        iVar10 = Settings.MaxHeight;
      }
      Settings.MaxHeight = 10000000;
      if (iVar10 < 0x989681) {
        Settings.MaxHeight = iVar10;
      }
      Settings.MaxWidth = iVar13;
      ParseRouteString(Settings.Routes,Settings.RouteStyle,1);
      if (show_actions != 0) {
        print_actions();
                    // WARNING: Subroutine does not return
        exit(0);
      }
      if (do_dump_actions != 0) {
        dump_actions();
                    // WARNING: Subroutine does not return
        exit(0);
      }
      PCB = CreateNewPCB('\x01');
      LayerGroup = &PCB->LayerGroups;
      PCB->Data->LayerN = 8;
      ParseGroupString(Settings.Groups,LayerGroup,8);
      CreateNewPCBPost(PCB,1);
      if (1 < argc) {
        command_line_pcb = local_a4[0][1];
      }
      ResetStackAndVisibility();
      CreateDefaultFont();
      if ((gui->field_0xc & 1) != 0) {
        InitCrosshair();
      }
      signal(0xd,(__sighandler_t)&DAT_00000001);
      InitBuffers();
      SetMode(0x6e);
      if ((command_line_pcb != (char *)0x0) &&
         (iVar13 = LoadPCB(command_line_pcb), pPVar4 = PCB, iVar13 != 0)) {
        pcVar6 = MyStrdup(command_line_pcb,"main()");
        pPVar4->Filename = pcVar6;
      }
      if ((Settings.InitialLayerStack != (char *)0x0) && (*Settings.InitialLayerStack != '\0')) {
        LayerStringToLayerStack(Settings.InitialLayerStack);
      }
      if ((gui->field_0xc & 6) != 0) {
        (*gui->do_export)((HID_Attr_Val *)0x0);
                    // WARNING: Subroutine does not return
        exit(0);
      }
      atexit(EmergencySave);
      iVar13 = ReadLibraryContents();
      if ((iVar13 == 0) && (Library.MenuN != 0)) {
        hid_action("LibraryChanged");
      }
      Settings.init_done = 0;
      if (Settings.ScriptFilename != (char *)0x0) {
        Message("Executing startup script file %s\n",Settings.ScriptFilename);
        hid_actionl("ExecuteFile",Settings.ScriptFilename,0);
      }
      if (Settings.ActionString != (char *)0x0) {
        Message("Executing startup action %s\n",Settings.ActionString);
        hid_parse_actions(Settings.ActionString,(_func_int_char_ptr_int_char_ptr_ptr *)0x0);
      }
      if (Settings.init_done == 0) {
        Settings.init_done = 1;
        pcb_dbus_setup();
        EnableAutosave();
        (*gui->do_export)((HID_Attr_Val *)0x0);
        pcb_dbus_finish();
      }
      if (local_24 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return 0;
    }
    ppHVar8 = hid_enumerate();
    pHVar2 = *ppHVar8;
    while (pHVar2 != (HID *)0x0) {
      if ((pHVar2->field_0xc & 1) == 0) {
        pcVar6 = pHVar2->name;
        __fprintf_chk(stderr,1,"\n%s defaults:\n",pcVar6);
        pHVar9 = (*pHVar2->get_export_options)(&local_3c);
        if ((pHVar9 != (HID_Attribute *)0x0) && (0 < local_3c)) {
          iVar13 = 0;
          do {
            print_defaults_1(pHVar9,(void *)0x0);
            iVar13 = iVar13 + 1;
            pHVar9 = pHVar9 + 1;
          } while (iVar13 < local_3c);
        }
      }
      else {
        __fprintf_chk(stderr,1,"\ngui defaults:\n",pcVar6);
        for (pHVar3 = hid_attr_nodes; pHVar3 != (HID_AttrNode *)0x0; pHVar3 = pHVar3->next) {
          iVar13 = 0;
          if (0 < pHVar3->n) {
            iVar10 = 0;
            do {
              iVar13 = iVar13 + 1;
              pHVar9 = (HID_Attribute *)((int)&pHVar3->attributes->name + iVar10);
              iVar10 = iVar10 + 0x30;
              print_defaults_1(pHVar9,pHVar9->value);
            } while (iVar13 < pHVar3->n);
          }
        }
      }
      ppHVar1 = ppHVar8 + 1;
      ppHVar8 = ppHVar8 + 1;
      pHVar2 = *ppHVar1;
    }
  }
                    // WARNING: Subroutine does not return
  exit(1);
}



// WARNING: Unknown calling convention

void MirrorElementCoordinates(DataTypePtr Data,ElementTypePtr Element,LocationType yoff)

{
  int iVar1;
  PCBTypePtr pPVar2;
  PointType *pPVar3;
  Cardinal n_1;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar4;
  LocationType *pLVar5;
  Cardinal n;
  int iVar6;
  Cardinal n_2;
  PinTypePtr pin;
  PinTypePtr ptr2;
  PadTypePtr pad;
  uchar *puVar7;
  int iVar8;
  uint uVar9;
  int local_24;
  uint local_20;
  
  r_delete_element((DataType *)Data,(ElementType *)Element);
  iVar6 = Element->LineN - 1;
  if (iVar6 != -1) {
    iVar8 = PCB->MaxHeight;
    pPVar3 = &Element->Line[Element->LineN - 1].Point1;
    do {
      iVar6 = iVar6 + -1;
      pPVar3->Y = (iVar8 - pPVar3->Y) + yoff;
      pPVar3[1].Y = (iVar8 - pPVar3[1].Y) + yoff;
      pPVar3 = (PointType *)((int)(pPVar3 + -5) + 0xc);
    } while (iVar6 != -1);
  }
  if (Element->PinN != 0) {
    uVar9 = 0;
    local_20 = Element->PinN;
    do {
      ptr2 = Element->Pin + uVar9;
      RestoreToPolygon((DataType *)Data,0x100,Element,ptr2);
      ptr2->Y = (PCB->MaxHeight + yoff) - ptr2->Y;
      uVar4 = Element->PinN;
      if (uVar4 == 0) break;
      uVar9 = (uVar4 + 1 + uVar9) - local_20;
      local_20 = uVar4;
    } while (uVar9 < uVar4);
  }
  uVar9 = Element->PadN;
  local_24 = 0;
  local_20 = 0;
  uVar4 = uVar9;
  while ((pPVar2 = PCB, uVar4 != 0 && (local_20 < uVar4))) {
    puVar7 = (Element->Pad->Flags).t + local_24 + -0x18;
    RestoreToPolygon((DataType *)Data,0x200,Element,puVar7);
    pPVar2 = PCB;
    *(uint *)(puVar7 + 0x14) = *(uint *)(puVar7 + 0x14) ^ 0x80;
    iVar6 = pPVar2->MaxHeight;
    *(int *)(puVar7 + 0x30) = (iVar6 - *(int *)(puVar7 + 0x30)) + yoff;
    *(int *)(puVar7 + 0x44) = (iVar6 - *(int *)(puVar7 + 0x44)) + yoff;
    uVar4 = Element->PadN;
    if (Element->PadN == uVar9) {
      local_20 = local_20 + 1;
      local_24 = local_24 + 0x68;
      uVar4 = uVar9;
    }
  }
  iVar6 = Element->ArcN - 1;
  if (iVar6 == -1) {
    iVar8 = PCB->MaxHeight;
  }
  else {
    iVar8 = PCB->MaxHeight;
    pLVar5 = &Element->Arc[Element->ArcN - 1].X;
    do {
      iVar6 = iVar6 + -1;
      pLVar5[2] = -pLVar5[2];
      pLVar5[3] = -pLVar5[3];
      pLVar5[1] = (iVar8 - pLVar5[1]) + yoff;
      pLVar5 = pLVar5 + -0x11;
    } while (iVar6 != -1);
  }
  iVar6 = 0;
  do {
    iVar1 = *(int *)((int)(&Element->Name[2].Flags + 2) + iVar6);
    puVar7 = Element->Name[2].Flags.t + iVar6 + -4;
    *(uint *)puVar7 = *(uint *)puVar7 ^ 0x80;
    *(LocationType *)((int)(&Element->Name[2].Flags + 2) + iVar6) = (yoff - iVar1) + iVar8;
    iVar6 = iVar6 + -0x3c;
  } while (iVar6 != -0xb4);
  iVar6 = Element->MarkY;
  (Element->Flags).f = (Element->Flags).f ^ 0x80;
  Element->MarkY = (yoff - iVar6) + iVar8;
  SetElementBoundingBox(Data,Element,&pPVar2->Font);
  ClearFromPolygon((DataType *)Data,2,Element,Element);
  return;
}



// WARNING: Unknown calling convention

void SetPointBoundingBox(PointTypePtr Pnt)

{
  Pnt->X2 = Pnt->X + 1;
  Pnt->Y2 = Pnt->Y + 1;
  return;
}



// WARNING: Unknown calling convention

void SetPinBoundingBox(PinTypePtr Pin)

{
  int iVar1;
  BDimension width;
  
  iVar1 = (Pin->Clearance + Pin->Thickness + 1) / 2;
  width = (Pin->Mask + 1) / 2;
  if (width <= iVar1) {
    width = iVar1;
  }
  (Pin->BoundingBox).X1 = Pin->X - width;
  iVar1 = Pin->Y;
  (Pin->BoundingBox).Y1 = iVar1 - width;
  (Pin->BoundingBox).X2 = Pin->X + width + 1;
  (Pin->BoundingBox).Y2 = width + 1 + iVar1;
  return;
}



// WARNING: Unknown calling convention

void SetLineBoundingBox(LineTypePtr Line)

{
  LocationType *pLVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  iVar2 = (Line->Point2).X;
  iVar4 = (Line->Thickness + Line->Clearance + 1) / 2;
  iVar3 = iVar2;
  if ((Line->Point1).X == iVar2 || (Line->Point1).X < iVar2) {
    iVar3 = (Line->Point1).X;
  }
  (Line->BoundingBox).X1 = iVar3 - iVar4;
  iVar3 = (Line->Point2).Y;
  iVar6 = iVar2;
  if (iVar2 <= (Line->Point1).X) {
    iVar6 = (Line->Point1).X;
  }
  pLVar1 = &(Line->Point1).Y;
  iVar5 = iVar3;
  if (*pLVar1 == iVar3 || *pLVar1 < iVar3) {
    iVar5 = (Line->Point1).Y;
  }
  (Line->BoundingBox).X2 = iVar4 + 1 + iVar6;
  (Line->BoundingBox).Y1 = iVar5 - iVar4;
  iVar6 = iVar3;
  if (iVar3 <= (Line->Point1).Y) {
    iVar6 = (Line->Point1).Y;
  }
  (Line->Point2).X2 = iVar2 + 1;
  (Line->BoundingBox).Y2 = iVar6 + 1 + iVar4;
  iVar2 = (Line->Point1).X;
  (Line->Point2).Y2 = iVar3 + 1;
  (Line->Point1).X2 = iVar2 + 1;
  (Line->Point1).Y2 = (Line->Point1).Y + 1;
  return;
}



// WARNING: Unknown calling convention

void SetPolygonBoundingBox(PolygonTypePtr Polygon)

{
  Cardinal CVar1;
  int iVar2;
  int iVar3;
  PointTypePtr pPVar4;
  int iVar5;
  int iVar6;
  int local_14;
  
  CVar1 = Polygon->PointN;
  (Polygon->BoundingBox).Y1 = 10000000;
  (Polygon->BoundingBox).X1 = 10000000;
  (Polygon->BoundingBox).Y2 = 0;
  local_14 = CVar1 - 1;
  (Polygon->BoundingBox).X2 = 0;
  if (local_14 != -1) {
    iVar5 = 0;
    iVar6 = 0;
    pPVar4 = Polygon->Points + (CVar1 - 1);
    iVar3 = 10000000;
    while( true ) {
      iVar2 = pPVar4->X;
      if (iVar2 < iVar3) {
        (Polygon->BoundingBox).X1 = iVar2;
      }
      iVar3 = pPVar4->Y;
      if (iVar3 < (Polygon->BoundingBox).Y1) {
        (Polygon->BoundingBox).Y1 = iVar3;
      }
      if (iVar6 <= iVar2) {
        iVar6 = iVar2;
      }
      if (iVar5 <= iVar3) {
        iVar5 = iVar3;
      }
      iVar6 = iVar6 + 1;
      local_14 = local_14 + -1;
      iVar5 = iVar5 + 1;
      pPVar4 = pPVar4 + -1;
      if (local_14 == -1) break;
      iVar3 = (Polygon->BoundingBox).X1;
    }
    (Polygon->BoundingBox).X2 = iVar6;
    (Polygon->BoundingBox).Y2 = iVar5;
  }
  return;
}



// WARNING: Unknown calling convention

Boolean IsDataEmpty(DataTypePtr Data)

{
  int iVar1;
  Boolean hasNoObjects;
  Cardinal i;
  uint uVar2;
  uint uVar3;
  bool bVar4;
  
  bVar4 = Data->ElementN == 0 && Data->ViaN == 0;
  iVar1 = PCB->Data->LayerN;
  uVar3 = iVar1 + 2;
  if (iVar1 != -2) {
    uVar2 = 0;
    do {
      while (bVar4 != false) {
        if (((Data->Layer[0].LineN == 0) && (Data->Layer[0].ArcN == 0)) &&
           (Data->Layer[0].TextN == 0)) {
          bVar4 = Data->Layer[0].PolygonN == 0;
          break;
        }
        uVar2 = uVar2 + 1;
        bVar4 = false;
        Data = (DataTypePtr)&Data->Layer[0].ArcN;
        if (uVar3 <= uVar2) {
          return '\0';
        }
      }
      uVar2 = uVar2 + 1;
      Data = (DataTypePtr)&Data->Layer[0].ArcN;
    } while (uVar2 < uVar3);
  }
  return bVar4;
}



// WARNING: Unknown calling convention

int FlagIsDataEmpty(int parm)

{
  Boolean BVar1;
  uint uVar2;
  int i;
  
  BVar1 = IsDataEmpty(PCB->Data);
  uVar2 = (uint)BVar1;
  if (parm != 0) {
    uVar2 = (uint)(uVar2 == 0);
  }
  return uVar2;
}



// WARNING: Unknown calling convention

BoxTypePtr GetDataBoundingBox(DataTypePtr Data)

{
  LocationType *pLVar1;
  Boolean BVar2;
  PinTypePtr paVar3;
  ElementTypePtr paVar4;
  uint uVar5;
  BoxType *pBVar6;
  LocationType LVar7;
  Cardinal n;
  Cardinal n_1;
  Cardinal n_2;
  int iVar8;
  PointType *pPVar9;
  ArcTypePtr paVar10;
  TextTypePtr pTVar11;
  PolygonTypePtr ppVar12;
  int iVar13;
  int iVar14;
  uint local_38;
  LayerType *local_34;
  LayerType *local_2c;
  LocationType local_24;
  uint local_1c;
  LayerType *local_18;
  int local_14;
  
  GetDataBoundingBox::box.Y1 = 10000000;
  GetDataBoundingBox::box.X1 = 10000000;
  GetDataBoundingBox::box.Y2 = -10000000;
  GetDataBoundingBox::box.X2 = -10000000;
  if (Data->ViaN != 0) {
    GetDataBoundingBox::box.Y1 = 10000000;
    GetDataBoundingBox::box.X2 = -10000000;
    local_14 = -10000000;
    local_18 = (LayerType *)0x0;
    paVar3 = Data->Via;
    GetDataBoundingBox::box.X1 = 10000000;
    do {
      iVar8 = -(paVar3->Thickness / 2);
      iVar13 = iVar8 + paVar3->X;
      if (iVar13 < GetDataBoundingBox::box.X1) {
        GetDataBoundingBox::box.X1 = iVar13;
      }
      iVar8 = iVar8 + paVar3->Y;
      if (iVar8 < GetDataBoundingBox::box.Y1) {
        GetDataBoundingBox::box.Y1 = iVar8;
      }
      iVar8 = paVar3->Thickness / 2;
      iVar13 = iVar8 + paVar3->X;
      if (GetDataBoundingBox::box.X2 < iVar13) {
        GetDataBoundingBox::box.X2 = iVar13;
      }
      GetDataBoundingBox::box.Y2 = iVar8 + paVar3->Y;
      if (GetDataBoundingBox::box.Y2 <= local_14) {
        GetDataBoundingBox::box.Y2 = local_14;
      }
      paVar3 = paVar3 + 1;
      local_18 = (LayerType *)((int)local_18 + 1);
      local_14 = GetDataBoundingBox::box.Y2;
    } while (local_18 < Data->ViaN);
  }
  local_14 = Data->ElementN - 1;
  if (local_14 != -1) {
    paVar4 = Data->Element + (Data->ElementN - 1);
    do {
      iVar13 = (paVar4->BoundingBox).X1;
      if (iVar13 < GetDataBoundingBox::box.X1) {
        GetDataBoundingBox::box.X1 = iVar13;
      }
      iVar13 = paVar4->Name[1].BoundingBox.X1;
      pLVar1 = &(paVar4->BoundingBox).Y1;
      if (*pLVar1 == GetDataBoundingBox::box.Y1 || *pLVar1 < GetDataBoundingBox::box.Y1) {
        GetDataBoundingBox::box.Y1 = (paVar4->BoundingBox).Y1;
      }
      if (GetDataBoundingBox::box.X2 <= (paVar4->BoundingBox).X2) {
        GetDataBoundingBox::box.X2 = (paVar4->BoundingBox).X2;
      }
      if (iVar13 < GetDataBoundingBox::box.X1) {
        GetDataBoundingBox::box.X1 = iVar13;
      }
      iVar13 = paVar4->Name[1].BoundingBox.Y1;
      if (iVar13 < GetDataBoundingBox::box.Y1) {
        GetDataBoundingBox::box.Y1 = iVar13;
      }
      iVar13 = paVar4->Name[1].BoundingBox.X2;
      if (GetDataBoundingBox::box.X2 < iVar13) {
        GetDataBoundingBox::box.X2 = iVar13;
      }
      iVar13 = (paVar4->BoundingBox).Y2;
      if (iVar13 <= paVar4->Name[1].BoundingBox.Y2) {
        iVar13 = paVar4->Name[1].BoundingBox.Y2;
      }
      if (GetDataBoundingBox::box.Y2 < iVar13) {
        GetDataBoundingBox::box.Y2 = iVar13;
      }
      paVar4 = paVar4 + -1;
      local_14 = local_14 + -1;
    } while (local_14 != -1);
  }
  local_2c = Data->Layer;
  iVar13 = PCB->Data->LayerN;
  uVar5 = iVar13 + 2;
  if (iVar13 != -2) {
    local_18 = (LayerType *)GetDataBoundingBox::box.Y1;
    local_38 = 0;
    local_34 = local_2c;
    while( true ) {
      local_14 = local_34->LineN - 1;
      if (local_14 != -1) {
        pPVar9 = &local_34->Line[local_34->LineN - 1].Point1;
        do {
          iVar8 = -(*(int *)((int)(pPVar9 + -1) + 0xc) / 2);
          iVar13 = iVar8 + pPVar9->X;
          if (iVar13 < GetDataBoundingBox::box.X1) {
            GetDataBoundingBox::box.X1 = iVar13;
          }
          iVar13 = iVar8 + pPVar9[1].X;
          if (iVar13 < GetDataBoundingBox::box.X1) {
            GetDataBoundingBox::box.X1 = iVar13;
          }
          iVar13 = iVar8 + pPVar9[1].Y;
          iVar8 = iVar8 + pPVar9->Y;
          if (iVar8 < iVar13) {
            iVar13 = iVar8;
          }
          if ((int)local_18 <= iVar13) {
            iVar13 = (int)local_18;
          }
          iVar14 = *(int *)((int)(pPVar9 + -1) + 0xc) / 2;
          iVar8 = iVar14 + pPVar9->X;
          if (iVar8 < GetDataBoundingBox::box.X2) {
            iVar8 = GetDataBoundingBox::box.X2;
          }
          GetDataBoundingBox::box.X2 = iVar14 + pPVar9[1].X;
          if (GetDataBoundingBox::box.X2 <= iVar8) {
            GetDataBoundingBox::box.X2 = iVar8;
          }
          iVar8 = iVar14 + pPVar9[1].Y;
          iVar14 = iVar14 + pPVar9->Y;
          if (iVar8 < iVar14) {
            iVar8 = iVar14;
          }
          if (GetDataBoundingBox::box.Y2 < iVar8) {
            GetDataBoundingBox::box.Y2 = iVar8;
          }
          pPVar9 = (PointType *)((int)(pPVar9 + -5) + 0xc);
          local_14 = local_14 + -1;
          local_18 = (LayerType *)iVar13;
        } while (local_14 != -1);
      }
      local_38 = local_38 + 1;
      if (uVar5 <= local_38) break;
      local_34 = local_34 + 1;
    }
    local_1c = 0;
    GetDataBoundingBox::box.Y1 = (LocationType)local_18;
    local_24 = GetDataBoundingBox::box.Y2;
    local_18 = local_2c;
    while( true ) {
      local_14 = local_18->ArcN - 1;
      if (local_14 != -1) {
        paVar10 = local_18->Arc + (local_18->ArcN - 1);
        do {
          if ((paVar10->BoundingBox).X1 < GetDataBoundingBox::box.X1) {
            GetDataBoundingBox::box.X1 = (paVar10->BoundingBox).X1;
          }
          if ((paVar10->BoundingBox).Y1 < GetDataBoundingBox::box.Y1) {
            GetDataBoundingBox::box.Y1 = (paVar10->BoundingBox).Y1;
          }
          if (GetDataBoundingBox::box.X2 < (paVar10->BoundingBox).X2) {
            GetDataBoundingBox::box.X2 = (paVar10->BoundingBox).X2;
          }
          if (local_24 < (paVar10->BoundingBox).Y2) {
            local_24 = (paVar10->BoundingBox).Y2;
          }
          paVar10 = paVar10 + -1;
          local_14 = local_14 + -1;
        } while (local_14 != -1);
      }
      local_1c = local_1c + 1;
      if (uVar5 <= local_1c) break;
      local_18 = local_18 + 1;
    }
    local_1c = 0;
    local_14 = local_24;
    local_18 = local_2c;
    while( true ) {
      iVar13 = local_18->TextN - 1;
      if (iVar13 != -1) {
        pTVar11 = local_18->Text + (local_18->TextN - 1);
        LVar7 = local_14;
        do {
          local_14 = iVar13;
          if ((pTVar11->BoundingBox).X1 < GetDataBoundingBox::box.X1) {
            GetDataBoundingBox::box.X1 = (pTVar11->BoundingBox).X1;
          }
          if ((pTVar11->BoundingBox).Y1 < GetDataBoundingBox::box.Y1) {
            GetDataBoundingBox::box.Y1 = (pTVar11->BoundingBox).Y1;
          }
          if (GetDataBoundingBox::box.X2 < (pTVar11->BoundingBox).X2) {
            GetDataBoundingBox::box.X2 = (pTVar11->BoundingBox).X2;
          }
          if (LVar7 < (pTVar11->BoundingBox).Y2) {
            LVar7 = (pTVar11->BoundingBox).Y2;
          }
          pTVar11 = pTVar11 + -1;
          iVar13 = local_14 + -1;
          local_14 = LVar7;
        } while (iVar13 != -1);
      }
      local_1c = local_1c + 1;
      if (uVar5 <= local_1c) break;
      local_18 = local_18 + 1;
    }
    local_18 = (LayerType *)0x0;
    while( true ) {
      iVar13 = local_2c->PolygonN - 1;
      if (iVar13 != -1) {
        ppVar12 = local_2c->Polygon + (local_2c->PolygonN - 1);
        LVar7 = local_14;
        do {
          local_14 = iVar13;
          if ((ppVar12->BoundingBox).X1 < GetDataBoundingBox::box.X1) {
            GetDataBoundingBox::box.X1 = (ppVar12->BoundingBox).X1;
          }
          if ((ppVar12->BoundingBox).Y1 < GetDataBoundingBox::box.Y1) {
            GetDataBoundingBox::box.Y1 = (ppVar12->BoundingBox).Y1;
          }
          if (GetDataBoundingBox::box.X2 < (ppVar12->BoundingBox).X2) {
            GetDataBoundingBox::box.X2 = (ppVar12->BoundingBox).X2;
          }
          if (LVar7 < (ppVar12->BoundingBox).Y2) {
            LVar7 = (ppVar12->BoundingBox).Y2;
          }
          ppVar12 = ppVar12 + -1;
          iVar13 = local_14 + -1;
          local_14 = LVar7;
        } while (iVar13 != -1);
      }
      local_18 = (LayerType *)((int)local_18 + 1);
      if (uVar5 <= local_18) break;
      local_2c = local_2c + 1;
    }
    GetDataBoundingBox::box.Y2 = local_14;
  }
  BVar2 = IsDataEmpty(Data);
  pBVar6 = (BoxTypePtr)0x0;
  if (BVar2 == '\0') {
    pBVar6 = &GetDataBoundingBox::box;
  }
  return pBVar6;
}



// WARNING: Unknown calling convention

void SetFontInfo(FontTypePtr Ptr)

{
  LocationType *pLVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  LocationType LVar5;
  LineTypePtr pLVar6;
  int iVar7;
  LocationType maxy;
  int iVar8;
  LineTypePtr line;
  LocationType maxx;
  int iVar9;
  LineTypePtr pLVar10;
  LocationType minx;
  int iVar11;
  LocationType totalminy;
  Cardinal j;
  LocationType miny;
  int iVar12;
  int local_34;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  
  local_28 = 0;
  local_34 = 10000000;
  Ptr->MaxWidth = 0x32;
  Ptr->MaxHeight = 0x32;
  do {
    iVar11 = local_34;
    if (((&Ptr->Symbol[0].Valid)[local_28] != '\0') &&
       (iVar12 = *(int *)((int)&Ptr->Symbol[0].LineN + local_28), iVar12 != 0)) {
      pLVar10 = *(LineTypePtr *)((int)&Ptr->Symbol[0].Line + local_28);
      local_18 = 0;
      local_1c = 0;
      local_14 = 10000000;
      local_20 = 10000000;
      pLVar6 = pLVar10;
      local_24 = iVar12;
      do {
        iVar9 = (pLVar6->Point1).X;
        iVar3 = (pLVar6->Point2).X;
        iVar8 = (pLVar6->Point1).Y;
        iVar7 = iVar9;
        if (iVar3 <= iVar9) {
          iVar7 = iVar3;
        }
        if (local_20 <= iVar7) {
          iVar7 = local_20;
        }
        iVar4 = (pLVar6->Point2).Y;
        iVar11 = iVar8;
        if (iVar4 <= iVar8) {
          iVar11 = iVar4;
        }
        if (local_14 <= iVar11) {
          iVar11 = local_14;
        }
        if (iVar9 <= iVar3) {
          iVar9 = iVar3;
        }
        if (iVar9 <= local_1c) {
          iVar9 = local_1c;
        }
        if (iVar8 <= iVar4) {
          iVar8 = iVar4;
        }
        if (iVar8 <= local_18) {
          iVar8 = local_18;
        }
        pLVar6 = pLVar6 + 1;
        local_24 = local_24 + -1;
        local_20 = iVar7;
        local_1c = iVar9;
        local_18 = iVar8;
        local_14 = iVar11;
      } while (local_24 != 0);
      do {
        (pLVar10->Point1).X = (pLVar10->Point1).X - iVar7;
        (pLVar10->Point2).X = (pLVar10->Point2).X - iVar7;
        SetLineBoundingBox(pLVar10);
        iVar12 = iVar12 + -1;
        pLVar10 = pLVar10 + 1;
      } while (iVar12 != 0);
      iVar7 = (iVar9 + 1) - iVar7;
      *(int *)((int)&Ptr->Symbol[0].Width + local_28) = iVar7;
      *(int *)((int)&Ptr->Symbol[0].Height + local_28) = iVar8 + 1;
      if (iVar7 < Ptr->MaxWidth) {
        iVar7 = Ptr->MaxWidth;
      }
      Ptr->MaxWidth = iVar7;
      iVar12 = *(int *)((int)&Ptr->Symbol[0].Height + local_28);
      if (iVar12 <= Ptr->MaxHeight) {
        iVar12 = Ptr->MaxHeight;
      }
      Ptr->MaxHeight = iVar12;
      if (local_34 <= iVar11) {
        iVar11 = local_34;
      }
    }
    local_34 = iVar11;
    local_28 = local_28 + 0x1c;
  } while (local_28 != 0x1c00);
  local_14 = 0;
  do {
    if ((&Ptr->Symbol[0].Valid)[local_14] != '\0') {
      iVar11 = *(int *)((int)&Ptr->Symbol[0].LineN + local_14);
      piVar2 = (int *)((int)&Ptr->Symbol[0].Height + local_14);
      *piVar2 = *piVar2 - local_34;
      pLVar10 = *(LineTypePtr *)((int)&Ptr->Symbol[0].Line + local_14);
      for (; iVar11 != 0; iVar11 = iVar11 + -1) {
        pLVar1 = &(pLVar10->Point1).Y;
        *pLVar1 = *pLVar1 - local_34;
        pLVar1 = &(pLVar10->Point2).Y;
        *pLVar1 = *pLVar1 - local_34;
        SetLineBoundingBox(pLVar10);
        pLVar10 = pLVar10 + 1;
      }
    }
    local_14 = local_14 + 0x1c;
  } while (local_14 != 0x1c00);
  LVar5 = Ptr->MaxWidth;
  (Ptr->DefaultSymbol).Y1 = 0;
  (Ptr->DefaultSymbol).X1 = 0;
  (Ptr->DefaultSymbol).X2 = LVar5;
  (Ptr->DefaultSymbol).Y2 = Ptr->MaxHeight;
  return;
}



// WARNING: Unknown calling convention

int GetLayerNumber(DataTypePtr Data,LayerTypePtr Layer)

{
  int iVar1;
  int i;
  
  iVar1 = 0;
  do {
    if (Data->Layer + iVar1 == Layer) {
      return iVar1;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x12);
  return 0x12;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int GetGroupOfLayer(int Layer)

{
  int iVar1;
  uint uVar2;
  int i;
  uint uVar3;
  Cardinal *pCVar4;
  int iVar5;
  int group;
  PCBTypePtr local_1c;
  
  iVar1 = PCB->Data->LayerN;
  if (iVar1 != Layer) {
    iVar5 = 0;
    local_1c = PCB;
    if (0 < iVar1) {
      do {
        uVar2 = (PCB->LayerGroups).Number[iVar5];
        if (uVar2 != 0) {
          if ((local_1c->LayerGroups).Entries[0] == Layer) {
            return iVar5;
          }
          pCVar4 = (PCB->LayerGroups).Entries[iVar5];
          uVar3 = 0;
          while( true ) {
            pCVar4 = pCVar4 + 1;
            uVar3 = uVar3 + 1;
            if (uVar2 <= uVar3) break;
            if (Layer == *pCVar4) {
              return iVar5;
            }
          }
        }
        iVar5 = iVar5 + 1;
        local_1c = (PCBTypePtr)&local_1c->InvisibleObjectsColor;
      } while (iVar5 < iVar1);
    }
  }
  return iVar1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int GetLayerGroupNumberByPointer(LayerTypePtr Layer)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int group;
  Cardinal *pCVar4;
  int entry;
  uint uVar5;
  Cardinal CVar6;
  int i;
  PCBTypePtr local_18;
  
  CVar6 = 0;
  do {
    if (Layer == PCB->Data->Layer + CVar6) break;
    CVar6 = CVar6 + 1;
  } while (CVar6 != 0x12);
  iVar1 = PCB->Data->LayerN;
  iVar3 = 0;
  local_18 = PCB;
  if (0 < iVar1) {
    do {
      uVar2 = (PCB->LayerGroups).Number[iVar3];
      if (uVar2 != 0) {
        if (CVar6 == (local_18->LayerGroups).Entries[0]) {
          return iVar3;
        }
        pCVar4 = (PCB->LayerGroups).Entries[iVar3];
        uVar5 = 0;
        while( true ) {
          pCVar4 = pCVar4 + 1;
          uVar5 = uVar5 + 1;
          if (uVar2 <= uVar5) break;
          if (CVar6 == *pCVar4) {
            return iVar3;
          }
        }
      }
      iVar3 = iVar3 + 1;
      local_18 = (PCBTypePtr)&local_18->InvisibleObjectsColor;
    } while (iVar3 < iVar1);
  }
  return iVar3;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int GetLayerGroupNumberByNumber(Cardinal Layer)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int group;
  Cardinal *pCVar4;
  int entry;
  uint uVar5;
  PCBTypePtr local_18;
  
  local_18 = PCB;
  iVar1 = PCB->Data->LayerN;
  iVar3 = 0;
  if (0 < iVar1) {
    do {
      uVar2 = (PCB->LayerGroups).Number[iVar3];
      if (uVar2 != 0) {
        if ((local_18->LayerGroups).Entries[0] == Layer) {
          return iVar3;
        }
        pCVar4 = (PCB->LayerGroups).Entries[iVar3];
        uVar5 = 0;
        while( true ) {
          pCVar4 = pCVar4 + 1;
          uVar5 = uVar5 + 1;
          if (uVar2 <= uVar5) break;
          if (*pCVar4 == Layer) {
            return iVar3;
          }
        }
      }
      iVar3 = iVar3 + 1;
      local_18 = (PCBTypePtr)&local_18->InvisibleObjectsColor;
    } while (iVar3 < iVar1);
  }
  return iVar3;
}



// WARNING: Unknown calling convention

int mem_any_set(uchar *ptr,int bytes)

{
  while( true ) {
    if (bytes == 0) {
      return 0;
    }
    bytes = bytes + -1;
    if (*ptr != '\0') break;
    ptr = ptr + 1;
  }
  return 1;
}



// WARNING: Unknown calling convention

FlagType * AddFlags(FlagType flag,uint flags)

{
  FlagType *in_stack_00000004;
  
  in_stack_00000004->t[7] = flag.t[7];
  in_stack_00000004->f = flags | flag.f;
  in_stack_00000004->t[6] = flag.t[6];
  in_stack_00000004->t[5] = flag.t[5];
  in_stack_00000004->t[4] = flag.t[4];
  in_stack_00000004->t[3] = flag.t[3];
  in_stack_00000004->t[2] = flag.t[2];
  in_stack_00000004->t[1] = flag.t[1];
  in_stack_00000004->t[0] = flag.t[0];
  return in_stack_00000004;
}



// WARNING: Unknown calling convention

FlagType * MaskFlags(FlagType flag,uint flags)

{
  FlagType *in_stack_00000004;
  
  in_stack_00000004->t[7] = flag.t[7];
  in_stack_00000004->t[6] = flag.t[6];
  in_stack_00000004->f = ~flags & flag.f;
  in_stack_00000004->t[5] = flag.t[5];
  in_stack_00000004->t[4] = flag.t[4];
  in_stack_00000004->t[3] = flag.t[3];
  in_stack_00000004->t[2] = flag.t[2];
  in_stack_00000004->t[1] = flag.t[1];
  in_stack_00000004->t[0] = flag.t[0];
  return in_stack_00000004;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int MoveLayerToGroup(int layer,int group)

{
  Cardinal CVar1;
  uint uVar2;
  PCBTypePtr pPVar3;
  int prev;
  Cardinal CVar4;
  int i;
  int entry_1;
  int entry_2;
  int entry;
  uint uVar5;
  Cardinal (*paCVar6) [18];
  Cardinal *pCVar7;
  int j;
  int iVar8;
  int group_1;
  int iVar9;
  PCBTypePtr local_24;
  PCBTypePtr local_1c;
  
  pPVar3 = PCB;
  if (-1 < layer) {
    CVar1 = PCB->Data->LayerN;
    CVar4 = CVar1 + 1;
    if (layer <= (int)CVar4) {
      prev = 0;
      local_1c = PCB;
      if (0 < (int)CVar1) {
        do {
          uVar2 = (PCB->LayerGroups).Number[prev];
          if (uVar2 != 0) {
            if (layer == (local_1c->LayerGroups).Entries[0]) break;
            pCVar7 = (PCB->LayerGroups).Entries[prev];
            uVar5 = 0;
            while( true ) {
              pCVar7 = pCVar7 + 1;
              uVar5 = uVar5 + 1;
              if (uVar2 <= uVar5) break;
              if (layer == *pCVar7) goto LAB_080a2f40;
            }
          }
          prev = prev + 1;
          local_1c = (PCBTypePtr)&local_1c->InvisibleObjectsColor;
        } while (prev < (int)CVar1);
      }
LAB_080a2f40:
      if (layer == CVar1) {
        local_1c = (PCBTypePtr)0x0;
        local_24 = PCB;
        if (0 < layer) {
          do {
            uVar2 = (PCB->LayerGroups).Number[(int)local_1c];
            if (uVar2 != 0) {
              if (CVar4 == (local_24->LayerGroups).Entries[0]) break;
              pCVar7 = (PCB->LayerGroups).Entries[(int)local_1c];
              uVar5 = 0;
              while( true ) {
                pCVar7 = pCVar7 + 1;
                uVar5 = uVar5 + 1;
                if (uVar2 <= uVar5) break;
                if (CVar4 == *pCVar7) goto LAB_080a307b;
              }
            }
            local_1c = (PCBTypePtr)((int)local_1c + 1);
            local_24 = (PCBTypePtr)&local_24->InvisibleObjectsColor;
          } while ((int)local_1c < layer);
        }
LAB_080a307b:
        if ((PCBTypePtr)group == local_1c) {
          return prev;
        }
      }
      if (layer == CVar4) {
        iVar9 = 0;
        local_1c = PCB;
        if (0 < (int)CVar1) {
          do {
            uVar2 = (PCB->LayerGroups).Number[iVar9];
            if (uVar2 != 0) {
              if (CVar1 == (local_1c->LayerGroups).Entries[0]) break;
              pCVar7 = (PCB->LayerGroups).Entries[iVar9];
              uVar5 = 0;
              while( true ) {
                pCVar7 = pCVar7 + 1;
                uVar5 = uVar5 + 1;
                if (uVar2 <= uVar5) break;
                if (CVar1 == *pCVar7) goto LAB_080a30fe;
              }
            }
            iVar9 = iVar9 + 1;
            local_1c = (PCBTypePtr)&local_1c->InvisibleObjectsColor;
          } while (iVar9 < (int)CVar1);
        }
LAB_080a30fe:
        if (group == iVar9) {
          return prev;
        }
      }
      if (group < 0) {
        return prev;
      }
      if ((int)CVar1 <= group) {
        return prev;
      }
      if (group == prev) {
        return prev;
      }
      uVar2 = (PCB->LayerGroups).Number[prev];
      if (uVar2 != 0) {
        uVar5 = 0;
        paCVar6 = (PCB->LayerGroups).Entries[prev];
        iVar9 = 0;
        do {
          iVar8 = iVar9;
          if (layer != (*paCVar6)[0]) {
            iVar8 = iVar9 + 1;
            (pPVar3->LayerGroups).Entries[prev][iVar9] = (*paCVar6)[0];
          }
          uVar5 = uVar5 + 1;
          paCVar6 = (Cardinal (*) [18])(*paCVar6 + 1);
          iVar9 = iVar8;
        } while (uVar5 < uVar2);
      }
      (pPVar3->LayerGroups).Number[prev] = uVar2 - 1;
      CVar1 = (pPVar3->LayerGroups).Number[group];
      (pPVar3->LayerGroups).Number[group] = CVar1 + 1;
      (pPVar3->LayerGroups).Entries[group][CVar1] = layer;
      prev = group;
      return prev;
    }
  }
  prev = -1;
  return prev;
}



// WARNING: Unknown calling convention

char * GetInfoString(void)

{
  HID **ppHVar1;
  HID **ppHVar2;
  HID *pHVar3;
  HID **ppHVar4;
  HID **hids;
  HID **ppHVar5;
  
  if (GetInfoString::first_time != 0) {
    GetInfoString::first_time = 0;
    DSAddString(&GetInfoString::info,"This is PCB, an interactive\n");
    DSAddString(&GetInfoString::info,"printed circuit board editor\n");
    DSAddString(&GetInfoString::info,"version ");
    DSAddString(&GetInfoString::info,"20091103");
    DSAddString(&GetInfoString::info,"\n\n");
    DSAddString(&GetInfoString::info,"Compiled on Mar 28 2011 at 02:42:45");
    DSAddString(&GetInfoString::info,"\n\nby harry eaton\n\n");
    DSAddString(&GetInfoString::info,"Copyright (C) Thomas Nau 1994, 1995, 1996, 1997\n");
    DSAddString(&GetInfoString::info,"Copyright (C) harry eaton 1998-2007\n");
    DSAddString(&GetInfoString::info,"Copyright (C) C. Scott Ananian 2001\n");
    DSAddString(&GetInfoString::info,"Copyright (C) DJ Delorie 2003, 2004, 2005, 2006, 2007, 2008\n"
               );
    DSAddString(&GetInfoString::info,
                "Copyright (C) Dan McMahill 2003, 2004, 2005, 2006, 2007, 2008\n\n");
    DSAddString(&GetInfoString::info,"It is licensed under the terms of the GNU\n");
    DSAddString(&GetInfoString::info,"General Public License version 2\n");
    DSAddString(&GetInfoString::info,"See the LICENSE file for more information\n\n");
    DSAddString(&GetInfoString::info,"For more information see:\n\n");
    DSAddString(&GetInfoString::info,"PCB homepage: http://pcb.gpleda.org\n");
    DSAddString(&GetInfoString::info,"gEDA homepage: http://www.gpleda.org\n");
    DSAddString(&GetInfoString::info,"gEDA Wiki: http://geda.seul.org/wiki/ \n\n");
    DSAddString(&GetInfoString::info,"----- Compile Time Options -----\n");
    ppHVar2 = hid_enumerate();
    DSAddString(&GetInfoString::info,"GUI:\n");
    pHVar3 = *ppHVar2;
    if (pHVar3 != (HID *)0x0) {
      ppHVar1 = ppHVar2 + 1;
      ppHVar5 = ppHVar2;
      do {
        while (ppHVar4 = ppHVar1, (pHVar3->field_0xc & 1) != 0) {
          DSAddString(&GetInfoString::info,"    ");
          DSAddString(&GetInfoString::info,(*ppHVar5)->name);
          DSAddString(&GetInfoString::info," : ");
          DSAddString(&GetInfoString::info,(*ppHVar5)->description);
          DSAddString(&GetInfoString::info,"\n");
          pHVar3 = *ppHVar4;
          ppHVar1 = ppHVar4 + 1;
          ppHVar5 = ppHVar4;
          if (pHVar3 == (HID *)0x0) goto LAB_080a337a;
        }
        pHVar3 = *ppHVar4;
        ppHVar1 = ppHVar4 + 1;
        ppHVar5 = ppHVar4;
      } while (pHVar3 != (HID *)0x0);
    }
LAB_080a337a:
    DSAddString(&GetInfoString::info,"Exporters:\n");
    pHVar3 = *ppHVar2;
    if (pHVar3 != (HID *)0x0) {
      ppHVar1 = ppHVar2 + 1;
      ppHVar5 = ppHVar2;
      do {
        while (ppHVar4 = ppHVar1, (pHVar3->field_0xc & 4) != 0) {
          DSAddString(&GetInfoString::info,"    ");
          DSAddString(&GetInfoString::info,(*ppHVar5)->name);
          DSAddString(&GetInfoString::info," : ");
          DSAddString(&GetInfoString::info,(*ppHVar5)->description);
          DSAddString(&GetInfoString::info,"\n");
          pHVar3 = *ppHVar4;
          ppHVar1 = ppHVar4 + 1;
          ppHVar5 = ppHVar4;
          if (pHVar3 == (HID *)0x0) goto LAB_080a3422;
        }
        pHVar3 = *ppHVar4;
        ppHVar1 = ppHVar4 + 1;
        ppHVar5 = ppHVar4;
      } while (pHVar3 != (HID *)0x0);
    }
LAB_080a3422:
    DSAddString(&GetInfoString::info,"Printers:\n");
    pHVar3 = *ppHVar2;
    while (pHVar3 != (HID *)0x0) {
      if ((pHVar3->field_0xc & 2) != 0) {
        DSAddString(&GetInfoString::info,"    ");
        DSAddString(&GetInfoString::info,(*ppHVar2)->name);
        DSAddString(&GetInfoString::info," : ");
        DSAddString(&GetInfoString::info,(*ppHVar2)->description);
        DSAddString(&GetInfoString::info,"\n");
      }
      pHVar3 = ppHVar2[1];
      ppHVar2 = ppHVar2 + 1;
    }
  }
  return GetInfoString::info.Data;
}



// WARNING: Unknown calling convention

void r_delete_element(DataType *data,ElementType *element)

{
  Cardinal sn;
  Cardinal sn_1;
  uint uVar1;
  uint uVar2;
  Cardinal n;
  uint uVar3;
  Cardinal n_1;
  uint local_20;
  
  r_delete_entry(data->element_tree,&element->BoundingBox);
  if (element->PinN != 0) {
    uVar2 = 0;
    local_20 = element->PinN;
    do {
      r_delete_entry(data->pin_tree,&element->Pin[uVar2].BoundingBox);
      uVar1 = element->PinN;
      if (uVar1 == 0) break;
      uVar2 = (uVar1 + 1 + uVar2) - local_20;
      local_20 = uVar1;
    } while (uVar2 < uVar1);
  }
  uVar2 = element->PadN;
  uVar3 = 0;
  local_20 = 0;
  uVar1 = uVar2;
  while ((uVar1 != 0 && (uVar3 < uVar1))) {
    r_delete_entry(data->pad_tree,(BoxType *)((element->Pad->Flags).t + local_20 + -0x18));
    uVar1 = element->PadN;
    if (element->PadN == uVar2) {
      uVar3 = uVar3 + 1;
      local_20 = local_20 + 0x68;
      uVar1 = uVar2;
    }
  }
  r_delete_entry(data->name_tree[2],(BoxType *)(element->Name + 2));
  r_delete_entry(data->name_tree[1],(BoxType *)(element->Name + 1));
  r_delete_entry(data->name_tree[0],&element->Name[0].BoundingBox);
  return;
}



// WARNING: Unknown calling convention

double c_strtod(char *s)

{
  double dVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  double dVar5;
  int iVar6;
  char cVar7;
  double rv;
  double scale;
  double sign;
  int local_10 [3];
  
  cVar7 = *s;
joined_r0x080a35ce:
  if (cVar7 != '\0') {
    if ((cVar7 == '\t') || (cVar7 == ' ')) goto LAB_080a35d8;
    if (cVar7 == '-') {
      s = s + 1;
      cVar7 = *s;
      fVar4 = -1.0;
    }
    else {
      if (cVar7 == '+') {
        s = s + 1;
        cVar7 = *s;
      }
      fVar4 = 1.0;
    }
    if ((byte)(cVar7 - 0x30U) < 10) {
      fVar2 = 0.0;
      do {
        iVar6 = (int)cVar7;
        s = s + 1;
        cVar7 = *s;
        fVar2 = (float)(iVar6 + -0x30) + fVar2 * 10.0;
      } while ((byte)(cVar7 - 0x30U) < 10);
    }
    else {
      fVar2 = 0.0;
    }
    if (cVar7 != '.') goto LAB_080a36bc;
    s = s + 1;
    cVar7 = *s;
    if (9 < (byte)(cVar7 - 0x30U)) goto LAB_080a36bc;
    fVar3 = 0.1;
    do {
      iVar6 = (int)cVar7;
      s = s + 1;
      cVar7 = *s;
      fVar2 = (float)(iVar6 + -0x30) * fVar3 + fVar2;
      fVar3 = fVar3 * 0.1;
    } while ((byte)(cVar7 - 0x30U) < 10);
    if (cVar7 == 'e') goto LAB_080a3688;
    goto LAB_080a36c1;
  }
  fVar4 = 1.0;
  fVar2 = 0.0;
LAB_080a36bc:
  if (cVar7 != 'e') {
LAB_080a36c1:
    if (cVar7 != 'E') {
      return (double)(fVar2 * fVar4);
    }
  }
LAB_080a3688:
  dVar1 = (double)fVar2;
  iVar6 = sscanf(s + 1,"%d",local_10);
  if (iVar6 != 1) {
    return (double)fVar4 * dVar1;
  }
  if (local_10[0] < 1) {
    if (local_10[0] == 0) {
      dVar1 = dVar1 * 1.0;
    }
    else {
      dVar5 = 1.0;
      do {
        local_10[0] = local_10[0] + 1;
        dVar5 = dVar5 * 0.1;
      } while (local_10[0] != 0);
      dVar1 = dVar5 * dVar1;
    }
  }
  else {
    dVar5 = 1.0;
    do {
      local_10[0] = local_10[0] + -1;
      dVar5 = dVar5 * 10.0;
    } while (local_10[0] != 0);
    dVar1 = dVar5 * dVar1;
  }
  return (double)fVar4 * dVar1;
LAB_080a35d8:
  s = s + 1;
  cVar7 = *s;
  goto joined_r0x080a35ce;
}



// WARNING: Unknown calling convention

char * c_dtostr(double d)

{
  size_t sVar1;
  char *__s;
  char *bufp;
  double dVar2;
  
  __s = c_dtostr::buf;
  if (d < 0.0) {
    c_dtostr::buf[0] = '-';
    d = -d;
    __s = c_dtostr::buf + 1;
  }
  dVar2 = floor(d + 5e-07);
  __sprintf_chk(__s,1,100,&DAT_081538d1,(int)ROUND(dVar2));
  sVar1 = strlen(__s);
  __s[sVar1] = '.';
  dVar2 = floor(((d + 5e-07) - (double)(int)ROUND(dVar2)) * 1000000.0);
  __sprintf_chk(__s + sVar1 + 1,1,0xffffffff,&DAT_08149df7,(int)ROUND(dVar2));
  return c_dtostr::buf;
}



// WARNING: Unknown calling convention

char * LayerGroupsToString(LayerGroupTypePtr lg)

{
  int *piVar1;
  Cardinal CVar2;
  bool bVar3;
  PCBTypePtr pPVar4;
  PCBTypePtr pPVar5;
  PCBTypePtr pPVar6;
  int layer;
  Cardinal CVar7;
  char *pcVar8;
  char *cp;
  int entry;
  char sep;
  int local_2c;
  uint local_20;
  
  pcVar8 = LayerGroupsToString::buf;
  if (0 < PCB->Data->LayerN) {
    bVar3 = false;
    local_2c = 0;
    pPVar4 = PCB;
    pPVar6 = PCB;
    do {
      pPVar5 = pPVar4;
      if ((pPVar6->LayerGroups).Number[local_2c] != 0) {
        if (bVar3) {
          *pcVar8 = ':';
          pcVar8 = pcVar8 + 1;
        }
        bVar3 = true;
        local_20 = 0;
        pPVar5 = pPVar6;
        if ((pPVar6->LayerGroups).Number[local_2c] != 0) {
          do {
            CVar7 = (pPVar6->LayerGroups).Entries[local_2c][local_20];
            CVar2 = pPVar6->Data->LayerN;
            if (CVar2 + 1 == CVar7) {
              *pcVar8 = 'c';
              pcVar8 = pcVar8 + 1;
            }
            else if (CVar7 == CVar2) {
              *pcVar8 = 's';
              pcVar8 = pcVar8 + 1;
            }
            else {
              __sprintf_chk(pcVar8,1,0x5b,&DAT_081538d1,CVar7 + 1);
              do {
                pcVar8 = pcVar8 + 1;
                pPVar4 = PCB;
              } while (*pcVar8 != '\0');
            }
            CVar7 = (pPVar4->LayerGroups).Number[local_2c];
            if (local_20 != CVar7 - 1) {
              *pcVar8 = ',';
              pcVar8 = pcVar8 + 1;
              CVar7 = (pPVar4->LayerGroups).Number[local_2c];
            }
            local_20 = local_20 + 1;
            pPVar6 = pPVar4;
          } while (local_20 < CVar7);
          bVar3 = true;
          pPVar5 = pPVar4;
        }
      }
      local_2c = local_2c + 1;
      piVar1 = &pPVar5->Data->LayerN;
      pPVar6 = pPVar5;
    } while (*piVar1 != local_2c && local_2c <= *piVar1);
  }
  *pcVar8 = '\0';
  return LayerGroupsToString::buf;
}



// WARNING: Unknown calling convention

char * pcb_author(void)

{
  __uid_t __uid;
  char *pcVar1;
  char *pcVar2;
  int len;
  char *gecos;
  
  pcVar2 = pcb_author::fab_author;
  if ((pcb_author::fab_author != (char *)0x0) ||
     ((Settings.FabAuthor != (char *)0x0 &&
      (pcVar2 = Settings.FabAuthor, *Settings.FabAuthor != '\0')))) {
    pcb_author::fab_author = pcVar2;
    return pcVar2;
  }
  __uid = getuid();
  pcb_author::pwentry = (passwd *)getpwuid(__uid);
  pcVar2 = ((passwd *)pcb_author::pwentry)->pw_gecos;
  pcVar1 = strchr(pcVar2,0x2c);
  if (pcVar1 == (char *)0x0) {
    len = strlen(pcVar2);
  }
  else {
    len = (int)pcVar1 - (int)pcVar2;
  }
  pcb_author::fab_author = (char *)calloc(1,len + 1);
  if (pcb_author::fab_author == (char *)0x0) {
    perror("pcb: out of memory.\n");
                    // WARNING: Subroutine does not return
    exit(-1);
  }
  memcpy(pcb_author::fab_author,pcVar2,len);
  pcVar2 = pcb_author::fab_author;
  pcb_author::fab_author[len] = '\0';
  return pcVar2;
}



// WARNING: Unknown calling convention

char * Concat(char *first,...)

{
  size_t sVar1;
  char *__dest;
  size_t sVar2;
  va_list a;
  char **ppcVar3;
  char *s;
  char *rv;
  int len;
  char *in_stack_00000008;
  
  sVar1 = strlen(first);
  __dest = (char *)calloc(1,sVar1 + 1);
  strcpy(__dest,first);
  ppcVar3 = (char **)&stack0x0000000c;
  if (in_stack_00000008 != (char *)0x0) {
    do {
      sVar2 = strlen(in_stack_00000008);
      sVar1 = sVar1 + sVar2;
      __dest = (char *)realloc(__dest,sVar1 + 1);
      strcat(__dest,in_stack_00000008);
      in_stack_00000008 = *ppcVar3;
      ppcVar3 = ppcVar3 + 1;
    } while (in_stack_00000008 != (char *)0x0);
  }
  return __dest;
}



// WARNING: Unknown calling convention

int FileExists(char *name)

{
  FILE *__stream;
  FILE *f;
  
  __stream = fopen(name,"r");
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
  }
  return (uint)(__stream != (FILE *)0x0);
}



// WARNING: Unknown calling convention

char * UniqueElementName(DataTypePtr Data,char *Name)

{
  int iVar1;
  ushort **ppuVar2;
  int num;
  long lVar3;
  char c;
  char cVar4;
  char **ppcVar5;
  Cardinal n;
  int iVar6;
  char *pcVar7;
  char *__nptr;
  
  if ((Name != (char *)0x0) && (*Name != '\0')) {
    while( true ) {
      iVar6 = Data->ElementN - 1;
      if (iVar6 == -1) break;
      ppcVar5 = &Data->Element[Data->ElementN - 1].Name[1].TextString;
      while ((*ppcVar5 == (char *)0x0 || (iVar1 = strcmp(*ppcVar5,Name), iVar1 != 0))) {
        iVar6 = iVar6 + -1;
        ppcVar5 = ppcVar5 + -0x4b;
        if (iVar6 == -1) {
          return Name;
        }
      }
      cVar4 = *Name;
      pcVar7 = Name;
      while (cVar4 != '\0') {
        pcVar7 = pcVar7 + 1;
        cVar4 = *pcVar7;
      }
      ppuVar2 = __ctype_b_loc();
      do {
        __nptr = pcVar7;
        pcVar7 = __nptr + -1;
      } while ((*(byte *)((int)*ppuVar2 + __nptr[-1] * 2 + 1) & 8) != 0);
      cVar4 = '\0';
      iVar6 = 1;
      if (*__nptr != '\0') {
        lVar3 = strtol(__nptr,(char **)0x0,10);
        cVar4 = *__nptr;
        iVar6 = lVar3 + 1;
      }
      *__nptr = '\0';
      __sprintf_chk(BumpName::temp,1,0x100,&DAT_08139f46,Name,iVar6);
      if (Name == BumpName::temp) {
        cVar4 = *__nptr;
      }
      *__nptr = cVar4;
      Name = BumpName::temp;
    }
  }
  return Name;
}



// WARNING: Unknown calling convention

int ParseGroupString(char *s,LayerGroupTypePtr LayerGroup,int LayerN)

{
  ushort uVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int layer;
  Cardinal CVar6;
  ushort **ppuVar7;
  long lVar8;
  Cardinal CVar9;
  char cVar10;
  int iVar11;
  ushort *puVar12;
  int group;
  LayerGroupTypePtr pLVar13;
  Cardinal CVar14;
  int member;
  byte bVar15;
  int local_74;
  Cardinal (*local_70) [18];
  int groupnum [18];
  
  bVar15 = 0;
  layer = 0;
  pLVar13 = LayerGroup;
  for (iVar11 = 0x130; iVar11 != 0; iVar11 = iVar11 + -1) {
    pLVar13->Number[0] = 0;
    pLVar13 = (LayerGroupTypePtr)(pLVar13->Number + 1);
  }
  do {
    groupnum[layer] = -1;
    layer = layer + 1;
  } while (layer != 0x12);
  if (((s != (char *)0x0) && (cVar10 = *s, 0 < LayerN)) && (cVar10 != '\0')) {
    bVar3 = false;
    bVar4 = false;
    local_74 = 0;
    CVar6 = LayerN + 1;
    do {
      if (cVar10 != '\0') {
        ppuVar7 = __ctype_b_loc();
        puVar12 = *ppuVar7;
        do {
          if ((*(byte *)((int)puVar12 + cVar10 * 2 + 1) & 0x20) == 0) {
            if (cVar10 != '\0') {
              local_70 = LayerGroup->Entries[local_74];
              CVar14 = 0;
              goto LAB_080a3d2e;
            }
            break;
          }
          s = s + 1;
          cVar10 = *s;
        } while (cVar10 != '\0');
      }
      CVar14 = 0;
LAB_080a3dd0:
      LayerGroup->Number[local_74] = CVar14;
      local_74 = local_74 + 1;
      s = s + (*s == ':');
      if (s == (char *)0x0) goto LAB_080a3e04;
      cVar10 = *s;
      if ((cVar10 == '\0') || (LayerN <= local_74)) goto LAB_080a3e04;
    } while( true );
  }
  bVar5 = 0 < LayerN;
  bVar4 = false;
  local_74 = 0;
LAB_080a3ecd:
  CVar6 = LayerGroup->Number[0];
  LayerGroup->Entries[CVar6] = LayerN;
  LayerGroup->Number[0] = CVar6 + 1;
  bVar2 = 0 < LayerN;
LAB_080a3ee3:
  if (!bVar4) {
    CVar6 = LayerGroup->Number[1];
    LayerGroup->Entries[1][CVar6] = LayerN + 1;
    LayerGroup->Number[1] = CVar6 + 1;
  }
  if ((bVar5) && (bVar2)) {
    CVar6 = 0;
    do {
      iVar11 = local_74;
      if (groupnum[CVar6] == -1) {
        LayerGroup->Number[local_74] = 1;
        iVar11 = local_74 + 1;
        LayerGroup->Entries[local_74][0] = CVar6;
      }
      CVar6 = CVar6 + 1;
    } while ((iVar11 < LayerN) && (local_74 = iVar11, (int)CVar6 < LayerN));
  }
  return 0;
LAB_080a3d2e:
  uVar1 = puVar12[cVar10];
  if ((uVar1 & 0x2000) != 0) {
    s = s + 1;
    cVar10 = *s;
    if (cVar10 == '\0') {
      uVar1 = *puVar12;
      goto joined_r0x080a3e66;
    }
    goto LAB_080a3d2e;
  }
  if (cVar10 == 'S') {
LAB_080a3ea6:
    bVar3 = true;
    bVar5 = (int)CVar6 < LayerN;
    CVar9 = LayerN;
LAB_080a3d89:
    if (bVar5) goto LAB_080a3e6c;
  }
  else {
    if (cVar10 < 'T') {
      if (cVar10 != 'C') {
joined_r0x080a3e66:
        if ((uVar1 & 0x800) == 0) goto LAB_080a3e6c;
        lVar8 = strtol(s,(char **)0x0,10);
        bVar5 = (int)CVar6 < (int)(lVar8 - 1U);
        CVar9 = lVar8 - 1U;
        goto LAB_080a3d89;
      }
    }
    else if (cVar10 != 'c') {
      if (cVar10 == 's') goto LAB_080a3ea6;
      goto joined_r0x080a3e66;
    }
    bVar4 = true;
    CVar9 = CVar6;
  }
  if (LayerN < (int)CVar14) {
LAB_080a3e6c:
    for (iVar11 = 0x130; iVar11 != 0; iVar11 = iVar11 + -1) {
      LayerGroup->Number[0] = 0;
      LayerGroup = (LayerGroupTypePtr)((int)LayerGroup + (uint)bVar15 * -8 + 4);
    }
    return 1;
  }
  s = s + 1;
  CVar14 = CVar14 + 1;
  groupnum[CVar9] = local_74;
  (*local_70)[0] = CVar9;
  cVar10 = *s;
  while( true ) {
    if (cVar10 == '\0') goto LAB_080a3dd0;
    puVar12 = *ppuVar7;
    uVar1 = puVar12[cVar10];
    if ((uVar1 & 0x800) == 0) break;
    s = s + 1;
    cVar10 = *s;
  }
  while ((uVar1 & 0x2000) != 0) {
    s = s + 1;
    cVar10 = *s;
    if (cVar10 == '\0') goto LAB_080a3dd0;
    uVar1 = puVar12[cVar10];
  }
  if (cVar10 == ':') goto LAB_080a3dd0;
  if (cVar10 != ',') goto LAB_080a3e6c;
  s = s + 1;
  cVar10 = *s;
  local_70 = (Cardinal (*) [18])(*local_70 + 1);
  if (cVar10 == '\0') goto LAB_080a3dd0;
  goto LAB_080a3d2e;
LAB_080a3e04:
  bVar5 = local_74 < LayerN;
  bVar2 = true;
  if (bVar3) goto LAB_080a3ee3;
  bVar5 = local_74 < LayerN;
  goto LAB_080a3ecd;
}



// WARNING: Unknown calling convention

void GetNum(char **s,BDimension *num)

{
  char cVar1;
  ushort *puVar2;
  long lVar3;
  ushort **ppuVar4;
  char *pcVar5;
  
  lVar3 = strtol(*s,(char **)0x0,10);
  *num = lVar3;
  ppuVar4 = __ctype_b_loc();
  puVar2 = *ppuVar4;
  pcVar5 = *s;
  while (cVar1 = *pcVar5, pcVar5 = pcVar5 + 1, (*(byte *)((int)puVar2 + cVar1 * 2 + 1) & 8) != 0) {
    *s = pcVar5;
  }
  return;
}



// WARNING: Unknown calling convention

void RightAngles(int Angle,float *cosa,float *sina)

{
  double local_1c;
  double local_14;
  
  sincos((double)Angle * 0.0174532925199433,&local_14,&local_1c);
  *cosa = (float)local_1c;
  *sina = (float)local_14;
  return;
}



// WARNING: Unknown calling convention

BoxTypePtr GetArcEnds(ArcTypePtr Arc)

{
  float local_24;
  float local_20 [4];
  
  RightAngles(Arc->StartAngle,local_20,&local_24);
  GetArcEnds::box.X1 = (LocationType)ROUND((float)Arc->X - (float)Arc->Width * local_20[0]);
  GetArcEnds::box.Y1 = (LocationType)ROUND((float)Arc->Height * local_24 + (float)Arc->Y);
  RightAngles(Arc->Delta + Arc->StartAngle,local_20,&local_24);
  GetArcEnds::box.X2 = (LocationType)ROUND((float)Arc->X - (float)Arc->Width * local_20[0]);
  GetArcEnds::box.Y2 = (LocationType)ROUND((float)Arc->Height * local_24 + (float)Arc->Y);
  return &GetArcEnds::box;
}



// WARNING: Unknown calling convention

void SetArcBoundingBox(ArcTypePtr Arc)

{
  int iVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  LocationType ang2;
  LocationType ang1;
  bool bVar10;
  double sa1;
  double sa2;
  double ca2;
  double ca1;
  double local_2c;
  double local_24 [2];
  
  iVar9 = Arc->Delta;
  if (iVar9 < 0x169) {
    ang2 = Arc->StartAngle;
    iVar7 = ang2 + iVar9;
    iVar8 = iVar7;
    if (-1 < iVar9) goto LAB_080a40da;
    if (-1 < iVar7) goto LAB_080a40e2;
LAB_080a42dc:
    iVar8 = iVar7 + 0x168;
    ang2 = ang2 + 0x168;
    iVar9 = iVar7 + 0x10e;
    bVar10 = iVar9 == 0;
    if (!bVar10) goto LAB_080a40eb;
LAB_080a42f1:
    dVar4 = 1.0;
    iVar9 = ang2 + -0x5a;
    bVar10 = iVar9 == 0;
    dVar5 = 0.0;
    if (!bVar10) goto LAB_080a413f;
LAB_080a42fe:
    local_24[0] = 1.0;
    iVar9 = Arc->X;
    local_2c = 0.0;
    iVar7 = Arc->Width;
    if (ang2 < 0xb5) {
      local_24[0] = 1.0;
      local_2c = 0.0;
    }
    else {
LAB_080a419e:
      if (iVar8 < 0xb4) {
        dVar6 = -1.0;
        goto LAB_080a41ae;
      }
    }
  }
  else {
    Arc->Delta = 0x168;
    iVar8 = Arc->StartAngle + 0x168;
    ang2 = Arc->StartAngle;
LAB_080a40da:
    iVar7 = ang2;
    ang2 = iVar8;
    if (iVar7 < 0) goto LAB_080a42dc;
LAB_080a40e2:
    iVar9 = iVar7 + -0x5a;
    bVar10 = iVar7 == 0x5a;
    iVar8 = iVar7;
    if (bVar10) goto LAB_080a42f1;
LAB_080a40eb:
    if (bVar10 || SBORROW4(iVar8,0x5a) != iVar9 < 0) {
      if (iVar8 == 0) {
        dVar4 = 0.0;
        dVar5 = 1.0;
      }
      else {
LAB_080a410e:
        sincos((double)iVar8 * 0.0174532925199433,local_24,&local_2c);
        dVar4 = local_24[0];
        dVar5 = local_2c;
      }
    }
    else if (iVar8 == 0xb4) {
      dVar4 = 0.0;
      dVar5 = -1.0;
    }
    else {
      if (iVar8 != 0x10e) goto LAB_080a410e;
      dVar4 = -1.0;
      dVar5 = 0.0;
    }
    iVar9 = ang2 + -0x5a;
    bVar10 = ang2 == 0x5a;
    if (bVar10) goto LAB_080a42fe;
LAB_080a413f:
    if (bVar10 || SBORROW4(ang2,0x5a) != iVar9 < 0) {
      if (ang2 == 0) {
        local_2c = 1.0;
        local_24[0] = 0.0;
      }
      else {
LAB_080a414d:
        sincos((double)ang2 * 0.0174532925199433,local_24,&local_2c);
      }
    }
    else if (ang2 == 0xb4) {
      local_2c = -1.0;
      local_24[0] = 0.0;
    }
    else {
      if (ang2 != 0x10e) goto LAB_080a414d;
      local_24[0] = -1.0;
      local_2c = 0.0;
    }
    iVar9 = Arc->X;
    iVar7 = Arc->Width;
    if (0xb4 < ang2) goto LAB_080a419e;
  }
  dVar6 = local_2c;
  if (dVar5 <= local_2c || local_2c != dVar5) {
    dVar6 = dVar5;
  }
LAB_080a41ae:
  iVar1 = (int)ROUND((double)iVar9 - (double)iVar7 * dVar6);
  (Arc->BoundingBox).X2 = iVar1;
  if ((ang2 < 0x169) || (0x167 < iVar8)) {
    if (dVar5 <= local_2c) {
      dVar5 = local_2c;
    }
  }
  else {
    dVar5 = 1.0;
  }
  iVar2 = Arc->Y;
  iVar3 = Arc->Height;
  iVar9 = (int)ROUND((double)iVar9 - (double)iVar7 * dVar5);
  (Arc->BoundingBox).X1 = iVar9;
  if ((ang2 < 0x5b) || (0x59 < iVar8)) {
    dVar5 = local_24[0];
    if (local_24[0] <= dVar4 || dVar4 != local_24[0]) {
      dVar5 = dVar4;
    }
  }
  else {
    dVar5 = 1.0;
  }
  iVar7 = (int)ROUND((double)iVar2 + (double)iVar3 * dVar5);
  (Arc->BoundingBox).Y2 = iVar7;
  if ((ang2 < 0x10f) || (0x10d < iVar8)) {
    if (dVar4 <= local_24[0] || local_24[0] != dVar4) {
      local_24[0] = dVar4;
    }
  }
  else {
    local_24[0] = -1.0;
  }
  iVar8 = (Arc->Clearance + Arc->Thickness) / 2;
  (Arc->BoundingBox).X1 = iVar9 - iVar8;
  (Arc->BoundingBox).Y1 = (int)ROUND((double)iVar2 + (double)iVar3 * local_24[0]) - iVar8;
  (Arc->BoundingBox).X2 = iVar1 + iVar8 + 1;
  (Arc->BoundingBox).Y2 = iVar8 + 1 + iVar7;
  return;
}



// WARNING: Unknown calling convention

void ChangeArcAngles(LayerTypePtr Layer,ArcTypePtr a,long new_sa,long new_da)

{
  if (0x167 < new_da) {
    new_da = 0x168;
    new_sa = 0;
  }
  RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,a);
  r_delete_entry(Layer->arc_tree,&a->BoundingBox);
  AddObjectToChangeAnglesUndoList(0x4000,a,a,a);
  a->Delta = new_da;
  a->StartAngle = new_sa;
  SetArcBoundingBox(a);
  r_insert_entry(Layer->arc_tree,&a->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,a);
  return;
}



// WARNING: Unknown calling convention

void CreateQuotedString(DynamicStringTypePtr DS,char *S)

{
  char cVar1;
  
  DSClearString(DS);
  cVar1 = '\"';
  while( true ) {
    DSAddCharacter(DS,cVar1);
    cVar1 = *S;
    if (cVar1 == '\0') break;
    if ((cVar1 == '\\') || (cVar1 == '\"')) {
      DSAddCharacter(DS,'\\');
    }
    cVar1 = *S;
    S = S + 1;
  }
  DSAddCharacter(DS,'\"');
  return;
}



// WARNING: Unknown calling convention

char * GetWorkingDirectory(char *path)

{
  char *pcVar1;
  
  pcVar1 = getcwd(path,0x1000);
  return pcVar1;
}



// WARNING: Unknown calling convention

void RestoreStackAndVisibility(void)

{
  PCBTypePtr pPVar1;
  Cardinal i;
  uint uVar2;
  uint uVar3;
  DataTypePtr paVar4;
  uint uVar5;
  int iVar6;
  
  if (SavedStack.cnt != 0) {
    iVar6 = 1;
    if (SavedStack.cnt != 1) {
      __fprintf_chk(stderr,1,
                    "RestoreStackAndVisibility()  layerstack save count is wrong.  cnt = %d\n",
                    SavedStack.cnt);
      iVar6 = SavedStack.cnt;
    }
    pPVar1 = PCB;
    paVar4 = PCB->Data;
    uVar5 = paVar4->LayerN;
    if (uVar5 != 0xfffffffe) {
      uVar2 = 0;
      do {
        if (uVar2 < uVar5) {
          LayerStack[uVar2] = SavedStack.LayerStack[uVar2];
        }
        uVar3 = uVar2 + 1;
        paVar4->Layer[uVar2].On = SavedStack.LayerOn[uVar2];
        paVar4 = pPVar1->Data;
        uVar5 = paVar4->LayerN;
        uVar2 = uVar3;
      } while (uVar3 < uVar5 + 2);
    }
    pPVar1->ElementOn = SavedStack.ElementOn;
    pPVar1->InvisibleObjectsOn = SavedStack.InvisibleObjectsOn;
    pPVar1->PinOn = SavedStack.PinOn;
    pPVar1->ViaOn = SavedStack.ViaOn;
    pPVar1->RatOn = SavedStack.RatOn;
    SavedStack.cnt = iVar6 + -1;
    return;
  }
  __fprintf_chk(stderr,1,"RestoreStackAndVisibility()  layerstack has not been saved.  cnt = %d\n",0
               );
  return;
}



// WARNING: Unknown calling convention

void SaveStackAndVisibility(void)

{
  uint uVar1;
  LayerType *pLVar2;
  PCBTypePtr pPVar3;
  uint uVar4;
  Cardinal i;
  DataTypePtr paVar5;
  int local_20;
  
  if (SaveStackAndVisibility::run == '\0') {
    SaveStackAndVisibility::run = '\x01';
    local_20 = 0;
  }
  else {
    local_20 = SavedStack.cnt;
    if (SavedStack.cnt != 0) {
      __fprintf_chk(stderr,1,
                    "SaveStackAndVisibility()  layerstack was already saved and notyet restored.  cnt = %d\n"
                    ,SavedStack.cnt);
      local_20 = SavedStack.cnt;
    }
  }
  pPVar3 = PCB;
  paVar5 = PCB->Data;
  uVar1 = paVar5->LayerN;
  if (uVar1 != 0xfffffffe) {
    uVar4 = 0;
    do {
      if (uVar4 < uVar1) {
        SavedStack.LayerStack[uVar4] = LayerStack[uVar4];
      }
      pLVar2 = paVar5->Layer;
      paVar5 = (DataTypePtr)&paVar5->Layer[0].ArcN;
      SavedStack.LayerOn[uVar4] = pLVar2->On;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar1 + 2);
  }
  SavedStack.ElementOn = pPVar3->ElementOn;
  SavedStack.InvisibleObjectsOn = pPVar3->InvisibleObjectsOn;
  SavedStack.PinOn = pPVar3->PinOn;
  SavedStack.ViaOn = pPVar3->ViaOn;
  SavedStack.RatOn = pPVar3->RatOn;
  SavedStack.cnt = local_20 + 1;
  return;
}



// WARNING: Unknown calling convention

BoxTypePtr GetObjectBoundingBox(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Type != 0x10) {
    if (Type < 0x11) {
      if (Type == 4) {
        return (BoxTypePtr)Ptr2;
      }
      if (Type < 5) {
        if (Type - 1U < 2) {
          return (BoxTypePtr)Ptr1;
        }
      }
      else if (Type == 8) {
        return (BoxTypePtr)Ptr2;
      }
    }
    else {
      if (Type == 0x800) {
        return (BoxTypePtr)Ptr3;
      }
      if (Type < 0x801) {
        if (Type == 0x100) {
          return (BoxTypePtr)Ptr2;
        }
        if (Type == 0x200) {
          return (BoxTypePtr)Ptr2;
        }
      }
      else {
        if (Type == 0x1000) {
          return (BoxTypePtr)Ptr3;
        }
        if (Type == 0x4000) {
          return (BoxTypePtr)Ptr2;
        }
      }
    }
    Message("Request for bounding box of unsupported type %d\n",Type);
  }
  return (BoxTypePtr)Ptr2;
}



// WARNING: Unknown calling convention

void AttachForCopy(LocationType PlaceX,LocationType PlaceY)

{
  double dVar1;
  BoxTypePtr pBVar2;
  BoxTypePtr box;
  BoxTypePtr box_1;
  int iVar3;
  LocationType mx;
  int iVar4;
  LocationType my;
  
  iVar4 = 0;
  iVar3 = 0;
  Crosshair.AttachedObject.RubberbandN = 0;
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x10) != 0) goto LAB_080a494d;
  if (Crosshair.AttachedObject.Type == 0x10) {
LAB_080a48a8:
    iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x28);
    iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c);
  }
  else if (Crosshair.AttachedObject.Type < 0x11) {
    if (Crosshair.AttachedObject.Type == 2) {
      iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0xd8);
      iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0xdc);
    }
    else if (Crosshair.AttachedObject.Type < 3) {
      if (Crosshair.AttachedObject.Type != 1) goto LAB_080a48a2;
      iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x34);
      iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
    }
    else if (Crosshair.AttachedObject.Type == 4) {
      iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c);
      iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30);
    }
    else {
      if (Crosshair.AttachedObject.Type != 8) goto LAB_080a48a2;
      iVar3 = **(int **)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
      iVar4 = (*(int **)((int)Crosshair.AttachedObject.Ptr2 + 0x38))[1];
    }
  }
  else if (Crosshair.AttachedObject.Type == 0x800) {
LAB_080a4b18:
                    // WARNING: Load size is inaccurate
    iVar3 = *Crosshair.AttachedObject.Ptr3;
    iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4);
  }
  else {
    if (Crosshair.AttachedObject.Type < 0x801) {
      if (Crosshair.AttachedObject.Type == 0x400) goto LAB_080a48a8;
    }
    else {
      if (Crosshair.AttachedObject.Type == 0x1000) goto LAB_080a4b18;
      if (Crosshair.AttachedObject.Type == 0x4000) {
        pBVar2 = GetArcEnds((ArcTypePtr)Crosshair.AttachedObject.Ptr2);
        iVar3 = pBVar2->X1;
        iVar4 = pBVar2->Y1;
        goto LAB_080a48b0;
      }
    }
LAB_080a48a2:
    iVar4 = 0;
    iVar3 = 0;
  }
LAB_080a48b0:
  dVar1 = PCB->Grid;
  iVar3 = (int)ROUND((double)PCB->GridOffsetX +
                     (double)(int)ROUND(((double)(iVar3 - PCB->GridOffsetX) + dVar1 * 0.5) / dVar1)
                     * dVar1 + 0.5) - iVar3;
  iVar4 = (int)ROUND((double)PCB->GridOffsetY +
                     (double)(int)ROUND(((double)(iVar4 - PCB->GridOffsetY) + dVar1 * 0.5) / dVar1)
                     * dVar1 + 0.5) - iVar4;
LAB_080a494d:
  Crosshair.AttachedObject.X = PlaceX - iVar3;
  Crosshair.AttachedObject.Y = PlaceY - iVar4;
  if ((Marked.status == '\0') || ((*(byte *)&(PCB->Flags).f & 2) != 0)) {
    SetLocalRef(Crosshair.AttachedObject.X,Crosshair.AttachedObject.Y,'\x01');
  }
  Crosshair.AttachedObject.State = 1;
  pBVar2 = GetObjectBoundingBox
                     (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                      Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3);
  SetCrosshairRange(Crosshair.AttachedObject.X - pBVar2->X1,Crosshair.AttachedObject.Y - pBVar2->Y1,
                    (PCB->MaxWidth + Crosshair.AttachedObject.X) - pBVar2->X2,
                    (PCB->MaxHeight + Crosshair.AttachedObject.Y) - pBVar2->Y2);
  if (((Settings.Mode != 0x69) &&
      (((*(byte *)&(PCB->Flags).f & 0x10) == 0 ||
       (LookupRubberbandLines
                  (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3),
       Settings.Mode != 0x69)))) &&
     ((Crosshair.AttachedObject.Type - 1U < 2 ||
      ((Crosshair.AttachedObject.Type == 4 || (Crosshair.AttachedObject.Type == 0x1000)))))) {
    LookupRatLines(Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3);
    return;
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int ChangeGroupVisibility(int Layer,Boolean On,Boolean ChangeStackOrder)

{
  int iVar1;
  Cardinal CVar2;
  bool bVar3;
  PCBTypePtr pPVar4;
  Cardinal CVar5;
  int i_1;
  uint uVar6;
  int i_3;
  int iVar7;
  int i_2;
  int iVar8;
  int *piVar9;
  int i;
  uint uVar10;
  int layer;
  Cardinal *pCVar11;
  DataTypePtr paVar12;
  PCBTypePtr local_28;
  int local_24;
  int local_20;
  
  if (Settings.verbose != 0) {
    __printf_chk(1,"ChangeGroupVisibility(Layer=%d, On=%d, ChangeStackOrder=%d)\n",Layer,(int)On,
                 (int)ChangeStackOrder);
  }
  pPVar4 = PCB;
  paVar12 = PCB->Data;
  iVar1 = paVar12->LayerN;
  if (Layer != iVar1) {
    local_20 = 0;
    local_28 = PCB;
    if (0 < iVar1) {
LAB_080a4bc5:
      uVar10 = (PCB->LayerGroups).Number[local_20];
      if (uVar10 == 0) goto LAB_080a4c0c;
      if ((local_28->LayerGroups).Entries[0] != Layer) {
        pCVar11 = (PCB->LayerGroups).Entries[local_20];
        uVar6 = 0;
        while (pCVar11 = pCVar11 + 1, uVar6 = uVar6 + 1, uVar6 < uVar10) {
          if (*pCVar11 == Layer) goto LAB_080a4cb8;
        }
        goto LAB_080a4c0c;
      }
LAB_080a4cb8:
      if (local_20 < iVar1) {
        local_24 = 1;
        bVar3 = ChangeStackOrder != '\0' && On != '\0';
        pCVar11 = (PCB->LayerGroups).Number + local_20 * 0x12 + uVar10 + 0xf;
        do {
          CVar2 = *pCVar11;
          uVar10 = uVar10 - 1;
          if ((CVar2 != Layer) && ((int)CVar2 < paVar12->LayerN)) {
            paVar12->Layer[CVar2].On = On;
            CVar5 = LayerStack[0];
            if (ChangeStackOrder != '\0' && On != '\0') {
              paVar12 = pPVar4->Data;
              iVar1 = paVar12->LayerN;
              if ((((int)CVar2 < iVar1) && (CVar5 = CVar2, 0 < iVar1)) &&
                 (iVar8 = 0, CVar2 != LayerStack[0])) {
                do {
                  iVar8 = iVar8 + 1;
                  if (iVar1 <= iVar8) break;
                } while (CVar2 != LayerStack[iVar8]);
                piVar9 = LayerStack + iVar8;
                do {
                  *piVar9 = piVar9[-1];
                  piVar9 = piVar9 + -1;
                } while (piVar9 != LayerStack);
              }
            }
            else {
              paVar12 = pPVar4->Data;
            }
            LayerStack[0] = CVar5;
            local_24 = local_24 + 1;
          }
          pCVar11 = pCVar11 + -1;
        } while (uVar10 != 0);
        goto LAB_080a4c39;
      }
    }
  }
LAB_080a4c20:
  local_24 = 1;
  bVar3 = ChangeStackOrder != '\0' && On != '\0';
LAB_080a4c39:
  paVar12->Layer[Layer].On = On;
  iVar1 = LayerStack[0];
  if (((bVar3) && (iVar8 = pPVar4->Data->LayerN, Layer < iVar8)) &&
     ((iVar1 = Layer, 0 < iVar8 && (iVar7 = 0, iVar1 = Layer, Layer != LayerStack[0])))) {
    do {
      iVar7 = iVar7 + 1;
      if (iVar8 <= iVar7) break;
    } while (Layer != LayerStack[iVar7]);
    piVar9 = LayerStack + iVar7;
    do {
      *piVar9 = piVar9[-1];
      piVar9 = piVar9 + -1;
      iVar1 = Layer;
    } while (piVar9 != LayerStack);
  }
  LayerStack[0] = iVar1;
  hid_action("LayersChanged");
  return local_24;
LAB_080a4c0c:
  local_20 = local_20 + 1;
  local_28 = (PCBTypePtr)&local_28->InvisibleObjectsColor;
  if (iVar1 <= local_20) goto LAB_080a4c20;
  goto LAB_080a4bc5;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void ResetStackAndVisibility(void)

{
  uint uVar1;
  int iVar2;
  PCBTypePtr pPVar3;
  int iVar4;
  uint uVar5;
  Cardinal i;
  int entry;
  DataTypePtr paVar6;
  Cardinal *pCVar7;
  Cardinal local_28;
  PCBTypePtr local_24;
  int local_20;
  
  pPVar3 = PCB;
  paVar6 = PCB->Data;
  uVar1 = paVar6->LayerN;
  if (uVar1 != 0xfffffffe) {
    uVar5 = 0;
    do {
      if (uVar5 < uVar1) {
        LayerStack[uVar5] = uVar5;
      }
      uVar5 = uVar5 + 1;
      paVar6->Layer[0].On = '\x01';
      paVar6 = (DataTypePtr)&paVar6->Layer[0].ArcN;
    } while (uVar5 < uVar1 + 2);
    paVar6 = pPVar3->Data;
  }
  pPVar3->ElementOn = '\x01';
  pPVar3->InvisibleObjectsOn = '\x01';
  pPVar3->PinOn = '\x01';
  pPVar3->ViaOn = '\x01';
  pPVar3->RatOn = '\x01';
  iVar2 = paVar6->LayerN;
  local_24 = pPVar3;
  local_20 = 0;
  iVar4 = local_20;
  if (iVar2 < 1) {
    local_28 = (pPVar3->LayerGroups).Entries[0];
  }
  else {
    do {
      local_20 = iVar4;
      uVar1 = (pPVar3->LayerGroups).Number[local_20];
      if (uVar1 != 0) {
        local_28 = (local_24->LayerGroups).Entries[0];
        if (iVar2 + 1U == local_28) goto LAB_080a4e98;
        pCVar7 = (pPVar3->LayerGroups).Entries[local_20];
        uVar5 = 0;
        while (pCVar7 = pCVar7 + 1, uVar5 = uVar5 + 1, uVar5 < uVar1) {
          if (iVar2 + 1U == *pCVar7) goto LAB_080a4e98;
        }
      }
      local_24 = (PCBTypePtr)&local_24->InvisibleObjectsColor;
      iVar4 = local_20 + 1;
    } while (local_20 + 1 < iVar2);
    local_28 = (pPVar3->LayerGroups).Entries[local_20 + 1][0];
  }
LAB_080a4e98:
  ChangeGroupVisibility(local_28,'\x01','\x01');
  return;
}



// WARNING: Unknown calling convention

void LayerStringToLayerStack(char *s)

{
  bool bVar1;
  PCBTypePtr pPVar2;
  size_t sVar3;
  undefined *puVar4;
  void *pvVar5;
  int iVar6;
  int iVar7;
  ushort **ppuVar8;
  DataTypePtr paVar9;
  long Layer;
  size_t sVar10;
  int iVar11;
  int i;
  int argn;
  int lno;
  int prev_sep;
  char **ppcVar12;
  int iVar13;
  char *__s1;
  
  sVar3 = strlen(s);
  iVar11 = -1;
  puVar4 = (undefined *)__strdup(s);
  pvVar5 = calloc(1,sVar3 * 4);
  if (0 < (int)sVar3) {
    iVar11 = 0;
    bVar1 = true;
    sVar10 = 0;
    do {
      switch(*puVar4) {
      case 9:
      case 0x20:
      case 0x2c:
      case 0x3a:
      case 0x3b:
        *puVar4 = 0;
        bVar1 = true;
        break;
      default:
        if (bVar1) {
          bVar1 = false;
          *(undefined **)((int)pvVar5 + iVar11 * 4) = puVar4;
          iVar11 = iVar11 + 1;
        }
      }
      sVar10 = sVar10 + 1;
      puVar4 = puVar4 + 1;
    } while (sVar3 != sVar10);
    iVar11 = iVar11 + -1;
  }
  pPVar2 = PCB;
  paVar9 = PCB->Data;
  iVar7 = paVar9->LayerN;
  if (-2 < iVar7) {
    iVar13 = 0;
    do {
      if (iVar13 < iVar7) {
        LayerStack[iVar13] = iVar13;
      }
      iVar6 = iVar13 + 1;
      paVar9->Layer[iVar13].On = '\0';
      paVar9 = pPVar2->Data;
      iVar7 = paVar9->LayerN;
      iVar13 = iVar6;
    } while (iVar6 <= iVar7 + 1);
  }
  pPVar2->ElementOn = '\0';
  pPVar2->InvisibleObjectsOn = '\0';
  pPVar2->PinOn = '\0';
  pPVar2->ViaOn = '\0';
  pPVar2->RatOn = '\0';
  if (iVar11 != -1) {
    ppcVar12 = (char **)((int)pvVar5 + iVar11 * 4);
    do {
      while( true ) {
        __s1 = *ppcVar12;
        iVar7 = strcasecmp(__s1,"rats");
        if (iVar7 != 0) break;
        PCB->RatOn = '\x01';
LAB_080a4fc9:
        iVar11 = iVar11 + -1;
        ppcVar12 = ppcVar12 + -1;
        if (iVar11 == -1) {
          return;
        }
      }
      iVar7 = strcasecmp(__s1,"invisible");
      if (iVar7 != 0) {
        iVar7 = strcasecmp(__s1,"pins");
        if (iVar7 == 0) {
          PCB->PinOn = '\x01';
        }
        else {
          iVar7 = strcasecmp(__s1,"vias");
          if (iVar7 == 0) {
            PCB->ViaOn = '\x01';
          }
          else {
            iVar7 = strcasecmp(__s1,"elements");
            if (iVar7 == 0) {
              PCB->ElementOn = '\x01';
            }
            else {
              ppuVar8 = __ctype_b_loc();
              if ((*(byte *)((int)*ppuVar8 + *__s1 * 2 + 1) & 8) == 0) {
                paVar9 = PCB->Data;
                iVar7 = paVar9->LayerN;
                if (0 < iVar7) {
                  iVar13 = 0;
                  do {
                    iVar6 = strcasecmp(__s1,paVar9->Layer[0].Name);
                    if (iVar6 == 0) {
                      ChangeGroupVisibility(iVar13,'\x01','\x01');
                      goto LAB_080a4fc9;
                    }
                    iVar13 = iVar13 + 1;
                    paVar9 = (DataTypePtr)&paVar9->Layer[0].ArcN;
                  } while (iVar13 < iVar7);
                }
                __fprintf_chk(stderr,1,"Warning: layer \"%s\" not known\n",__s1);
                if (LayerStringToLayerStack::listed_layers == 0) {
                  __fprintf_chk(stderr,1,"Named layers in this board are:\n",__s1);
                  LayerStringToLayerStack::listed_layers = 1;
                  paVar9 = PCB->Data;
                  if (0 < paVar9->LayerN) {
                    iVar7 = 0;
                    do {
                      iVar13 = iVar7 + 1;
                      __fprintf_chk(stderr,1,&DAT_08148576,paVar9->Layer[iVar7].Name);
                      paVar9 = PCB->Data;
                      iVar7 = iVar13;
                    } while (paVar9->LayerN != iVar13 && iVar13 <= paVar9->LayerN);
                  }
                }
              }
              else {
                Layer = strtol(__s1,(char **)0x0,10);
                ChangeGroupVisibility(Layer,'\x01','\x01');
              }
            }
          }
        }
        goto LAB_080a4fc9;
      }
      iVar11 = iVar11 + -1;
      ppcVar12 = ppcVar12 + -1;
      PCB->InvisibleObjectsOn = '\x01';
    } while (iVar11 != -1);
  }
  return;
}



// WARNING: Unknown calling convention

char * ExpandFilename(char *Dirname,char *Filename)

{
  size_t sVar1;
  size_t sVar2;
  char *pcVar3;
  FILE *__stream;
  FILE *pipe;
  int c;
  int iVar4;
  char *command;
  
  DSClearString(&ExpandFilename::answer);
  if (Dirname == (char *)0x0) {
    sVar1 = strlen(Filename);
    pcVar3 = (char *)MyCalloc(sVar1 + 6,1,"Expand()");
    __sprintf_chk(pcVar3,1,0xffffffff,"echo %s",Filename);
  }
  else {
    sVar1 = strlen(Filename);
    sVar2 = strlen(Dirname);
    pcVar3 = (char *)MyCalloc(sVar1 + 7 + sVar2,1,"ExpandFilename()");
    __sprintf_chk(pcVar3,1,0xffffffff,"echo %s/%s",Dirname,Filename);
  }
  __stream = popen(pcVar3,"r");
  if (__stream == (FILE *)0x0) {
    PopenErrorMessage(pcVar3);
    SaveFree(pcVar3);
    pcVar3 = (char *)0x0;
  }
  else {
    while( true ) {
      iVar4 = fgetc(__stream);
      if (((iVar4 == -1) || (iVar4 == 0xd)) || (iVar4 == 10)) break;
      DSAddCharacter(&ExpandFilename::answer,(char)iVar4);
    }
    SaveFree(pcVar3);
    iVar4 = pclose(__stream);
    pcVar3 = (char *)0x0;
    if (iVar4 == 0) {
      pcVar3 = ExpandFilename::answer.Data;
    }
  }
  return pcVar3;
}



// WARNING: Unknown calling convention

char * EvaluateFilename(char *Template,char *Path,char *Filename,char *Parameter)

{
  char Char;
  char cVar1;
  char *pcVar2;
  char *p;
  
  if (Settings.verbose != 0) {
    __printf_chk(1,"EvaluateFilename:\n");
    __printf_chk(1,&DAT_08149e51,Template);
    __printf_chk(1,&DAT_08149e69,Path);
    __printf_chk(1,&DAT_08149e7d,Filename);
    __printf_chk(1,&DAT_08149e95,Parameter);
  }
  DSClearString(&EvaluateFilename::command);
  while (Template != (char *)0x0) {
    while( true ) {
      Char = *Template;
      if (Char == '\0') goto LAB_080a5408;
      if (Char != '%') goto LAB_080a5463;
      cVar1 = Template[1];
      if (cVar1 != 'p') break;
      Template = Template + 2;
      DSAddString(&EvaluateFilename::command,Path);
      if (Template == (char *)0x0) goto LAB_080a5408;
    }
    if (cVar1 == 'f') {
      Template = Template + 2;
      DSAddString(&EvaluateFilename::command,Filename);
    }
    else if (cVar1 == 'a') {
      Template = Template + 2;
      DSAddString(&EvaluateFilename::command,Parameter);
    }
    else {
LAB_080a5463:
      Template = Template + 1;
      DSAddCharacter(&EvaluateFilename::command,Char);
    }
  }
LAB_080a5408:
  DSAddCharacter(&EvaluateFilename::command,'\0');
  if (Settings.verbose != 0) {
    __printf_chk(1,&DAT_0814a2b8,EvaluateFilename::command.Data);
  }
  pcVar2 = MyStrdup(EvaluateFilename::command.Data,"EvaluateFilename()");
  return pcVar2;
}



// WARNING: Unknown calling convention

int ParseRouteString(char *s,RouteStyleTypePtr routeStyle,int scale)

{
  ushort *puVar1;
  char *pcVar2;
  ushort **ppuVar3;
  char *pcVar4;
  int iVar5;
  int i;
  char cVar6;
  byte bVar7;
  RouteStyleTypePtr pRVar8;
  int in_GS_OFFSET;
  byte bVar9;
  int local_138;
  char *local_130 [4];
  char Name [256];
  int local_20;
  
  bVar9 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_130[0] = s;
  pRVar8 = routeStyle;
  for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {
    pRVar8->Thick = 0;
    pRVar8 = (RouteStyleTypePtr)&pRVar8->Diameter;
  }
  ppuVar3 = __ctype_b_loc();
  local_138 = 0;
  cVar6 = *s;
  if (cVar6 == '\0') goto LAB_080a582e;
LAB_080a5594:
  while ((*(byte *)((int)*ppuVar3 + cVar6 * 2 + 1) & 0x20) != 0) {
    s = s + 1;
    cVar6 = *s;
    local_130[0] = s;
    if (cVar6 == '\0') goto LAB_080a582e;
  }
  cVar6 = *local_130[0];
  if (cVar6 == ',') goto LAB_080a582e;
  if (cVar6 == '\0') goto LAB_080a582e;
  iVar5 = 0;
  do {
    local_130[0] = local_130[0] + 1;
    Name[iVar5] = cVar6;
    iVar5 = iVar5 + 1;
    cVar6 = *local_130[0];
    if (cVar6 == ',') break;
  } while (cVar6 != '\0');
  do {
    Name[iVar5] = '\0';
    pcVar4 = MyStrdup(Name,"ParseRouteString()");
    puVar1 = *ppuVar3;
    routeStyle->Name = pcVar4;
    pcVar4 = local_130[0] + 1;
    if ((*(byte *)((int)puVar1 + local_130[0][1] * 2 + 1) & 8) == 0) {
LAB_080a5861:
      local_130[0] = pcVar4;
      for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {
        routeStyle->Thick = 0;
        routeStyle = (RouteStyleTypePtr)((int)routeStyle + (uint)bVar9 * -8 + 4);
      }
      iVar5 = 1;
LAB_080a583a:
      if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return iVar5;
    }
    local_130[0] = local_130[0] + 1;
    GetNum(local_130,&routeStyle->Thick);
    routeStyle->Thick = scale * routeStyle->Thick;
    cVar6 = *local_130[0];
    if (cVar6 == '\0') {
LAB_080a5858:
      pcVar4 = local_130[0] + 1;
      goto LAB_080a5861;
    }
    puVar1 = *ppuVar3;
    while ((*(byte *)((int)puVar1 + cVar6 * 2 + 1) & 0x20) != 0) {
      local_130[0] = local_130[0] + 1;
      cVar6 = *local_130[0];
      if (cVar6 == '\0') goto LAB_080a5858;
    }
    pcVar4 = local_130[0] + 1;
    if (cVar6 != ',') goto LAB_080a5861;
    if (local_130[0][1] == '\0') {
LAB_080a56dc:
      local_130[0] = pcVar4;
      bVar7 = (byte)(*puVar1 >> 8);
      pcVar4 = local_130[0];
    }
    else {
      bVar7 = (byte)(puVar1[local_130[0][1]] >> 8);
      if ((puVar1[local_130[0][1]] & 0x2000) != 0) {
        pcVar2 = local_130[0] + 2;
        do {
          pcVar4 = pcVar2;
          if (*pcVar4 == '\0') goto LAB_080a56dc;
          bVar7 = (byte)(puVar1[*pcVar4] >> 8);
          pcVar2 = pcVar4 + 1;
        } while ((puVar1[*pcVar4] & 0x2000) != 0);
      }
    }
    local_130[0] = pcVar4;
    pcVar4 = local_130[0];
    if ((bVar7 & 8) == 0) goto LAB_080a5861;
    GetNum(local_130,&routeStyle->Diameter);
    routeStyle->Diameter = scale * routeStyle->Diameter;
    cVar6 = *local_130[0];
    if (cVar6 == '\0') goto LAB_080a5858;
    puVar1 = *ppuVar3;
    while ((*(byte *)((int)puVar1 + cVar6 * 2 + 1) & 0x20) != 0) {
      local_130[0] = local_130[0] + 1;
      cVar6 = *local_130[0];
      if (cVar6 == '\0') goto LAB_080a5858;
    }
    pcVar4 = local_130[0] + 1;
    if (cVar6 != ',') goto LAB_080a5861;
    if (local_130[0][1] == '\0') {
LAB_080a578c:
      local_130[0] = pcVar4;
      bVar7 = (byte)(*puVar1 >> 8);
      pcVar4 = local_130[0];
    }
    else {
      bVar7 = (byte)(puVar1[local_130[0][1]] >> 8);
      if ((puVar1[local_130[0][1]] & 0x2000) != 0) {
        pcVar2 = local_130[0] + 2;
        do {
          pcVar4 = pcVar2;
          if (*pcVar4 == '\0') goto LAB_080a578c;
          bVar7 = (byte)(puVar1[*pcVar4] >> 8);
          pcVar2 = pcVar4 + 1;
        } while ((puVar1[*pcVar4] & 0x2000) != 0);
      }
    }
    local_130[0] = pcVar4;
    pcVar4 = local_130[0];
    if ((bVar7 & 8) == 0) goto LAB_080a5861;
    GetNum(local_130,&routeStyle->Hole);
    routeStyle->Hole = scale * routeStyle->Hole;
    if (*local_130[0] == ',') {
      pcVar4 = local_130[0] + 1;
      if (local_130[0][1] == '\0') {
        bVar7 = (byte)(**ppuVar3 >> 8);
      }
      else {
        puVar1 = *ppuVar3;
        bVar7 = (byte)(puVar1[local_130[0][1]] >> 8);
        if ((puVar1[local_130[0][1]] & 0x2000) != 0) {
          pcVar2 = local_130[0] + 2;
          do {
            pcVar4 = pcVar2;
            if (*pcVar4 == '\0') {
              bVar7 = (byte)(*puVar1 >> 8);
              break;
            }
            bVar7 = (byte)(puVar1[*pcVar4] >> 8);
            pcVar2 = pcVar4 + 1;
          } while ((puVar1[*pcVar4] & 0x2000) != 0);
        }
      }
      local_130[0] = pcVar4;
      pcVar4 = local_130[0];
      if ((bVar7 & 8) == 0) goto LAB_080a5861;
      GetNum(local_130,&routeStyle->Keepaway);
      routeStyle->Keepaway = scale * routeStyle->Keepaway;
      cVar6 = *local_130[0];
      if (cVar6 != '\0') {
        do {
          if ((*(byte *)((int)*ppuVar3 + cVar6 * 2 + 1) & 0x20) == 0) break;
          local_130[0] = local_130[0] + 1;
          cVar6 = *local_130[0];
        } while (cVar6 != '\0');
      }
    }
    else {
      routeStyle->Keepaway = 1000;
    }
    if (local_138 == 3) {
LAB_080a5838:
      iVar5 = 0;
      goto LAB_080a583a;
    }
    cVar6 = *local_130[0];
    if (cVar6 == '\0') goto LAB_080a5858;
    while ((*(byte *)((int)*ppuVar3 + cVar6 * 2 + 1) & 0x20) != 0) {
      local_130[0] = local_130[0] + 1;
      cVar6 = *local_130[0];
      if (cVar6 == '\0') goto LAB_080a5858;
    }
    s = local_130[0] + 1;
    pcVar4 = s;
    if (cVar6 != ':') goto LAB_080a5861;
    local_138 = local_138 + 1;
    local_130[0] = s;
    if (local_138 == 4) goto LAB_080a5838;
    cVar6 = *s;
    routeStyle = routeStyle + 1;
    if (cVar6 != '\0') goto LAB_080a5594;
LAB_080a582e:
    iVar5 = 0;
  } while( true );
}



// WARNING: Unknown calling convention

void QuitApplication(void)

{
  if ((PCB->Changed == '\0') || (Settings.SaveInTMP == '\0')) {
    DisableEmergencySave();
  }
  else {
    EmergencySave();
  }
  if (Settings.init_done < 1) {
    Settings.init_done = -1;
    return;
  }
                    // WARNING: Subroutine does not return
  exit(0);
}



// WARNING: Unknown calling convention

void CenterDisplay(LocationType X,LocationType Y,Boolean Delta)

{
  double dVar1;
  Boolean BVar2;
  
  dVar1 = PCB->Grid;
  PCB->Grid = 1.0;
  if (Delta == '\0') {
    BVar2 = MoveCrosshairAbsolute(X,Y);
    if (BVar2 != '\0') {
      RestoreCrosshair('\0');
    }
  }
  else {
    MoveCrosshairRelative(X,Y);
  }
  (*gui->set_crosshair)(Crosshair.X,Crosshair.Y,1);
  PCB->Grid = dVar1;
  return;
}



// WARNING: Unknown calling convention

void SetTextBoundingBox(FontTypePtr FontPtr,TextTypePtr Text)

{
  LocationType *pLVar1;
  char cVar2;
  BYTE Number;
  Cardinal CVar3;
  int iVar4;
  int Y;
  int X;
  float fVar5;
  PCBTypePtr pPVar6;
  byte bVar7;
  LineTypePtr line;
  LineTypePtr pLVar8;
  int iVar9;
  BDimension maxThick;
  int i;
  Cardinal CVar10;
  int iVar11;
  LocationType height;
  int local_2c;
  byte *local_28;
  
  local_28 = (byte *)Text->TextString;
  if ((local_28 == (byte *)0x0) || (bVar7 = *local_28, bVar7 == 0)) {
    iVar9 = 0;
    iVar11 = 0;
    local_2c = 0;
  }
  else {
    iVar9 = 0;
    iVar11 = 0;
    local_2c = 0;
    do {
      if (FontPtr->Symbol[bVar7].Valid == '\0') {
        local_2c = local_2c + (((FontPtr->DefaultSymbol).X2 - (FontPtr->DefaultSymbol).X1) * 6) / 5;
        iVar11 = (FontPtr->DefaultSymbol).Y2 - (FontPtr->DefaultSymbol).Y1;
      }
      else {
        CVar3 = FontPtr->Symbol[bVar7].LineN;
        pLVar8 = FontPtr->Symbol[bVar7].Line;
        if (CVar3 != 0) {
          CVar10 = 0;
          do {
            if (iVar9 < pLVar8->Thickness) {
              iVar9 = pLVar8->Thickness;
            }
            CVar10 = CVar10 + 1;
            pLVar8 = pLVar8 + 1;
          } while (CVar10 != CVar3);
        }
        iVar4 = FontPtr->Symbol[bVar7].Height;
        local_2c = local_2c + FontPtr->Symbol[bVar7].Delta + FontPtr->Symbol[bVar7].Width;
        if (iVar11 < iVar4) {
          iVar11 = iVar4;
        }
      }
      local_28 = local_28 + 1;
    } while ((local_28 != (byte *)0x0) && (bVar7 = *local_28, bVar7 != 0));
  }
  fVar5 = (float)Text->Scale / 100.0;
  iVar4 = (int)ROUND((float)local_2c * fVar5);
  iVar11 = (int)ROUND((float)iVar11 * fVar5);
  iVar9 = (int)ROUND(((float)Text->Scale / 200.0) * (float)iVar9);
  Y = Text->Y;
  if (iVar9 < 400) {
    iVar9 = 400;
  }
  X = Text->X;
  cVar2 = *(char *)&(Text->Flags).f;
  (Text->BoundingBox).Y1 = Y;
  (Text->BoundingBox).X1 = X;
  if (cVar2 < '\0') {
    (Text->BoundingBox).X1 = X - iVar9;
    (Text->BoundingBox).Y1 = iVar9 + Y;
    (Text->BoundingBox).X2 = (X - iVar9) + iVar4 + iVar9;
    (Text->BoundingBox).Y2 = (iVar9 + Y + iVar9 * -2) - iVar11;
    RotateBoxLowLevel(&Text->BoundingBox,X,Y,4 - Text->Direction & 3);
  }
  else {
    (Text->BoundingBox).X1 = X - iVar9;
    (Text->BoundingBox).Y1 = Y - iVar9;
    (Text->BoundingBox).X2 = (X - iVar9) + iVar4 + iVar9;
    Number = Text->Direction;
    (Text->BoundingBox).Y2 = (Y - iVar9) + iVar9 * 2 + iVar11;
    RotateBoxLowLevel(&Text->BoundingBox,X,Y,Number);
  }
  pPVar6 = PCB;
  (Text->BoundingBox).X1 = (Text->BoundingBox).X1 - PCB->Bloat;
  pLVar1 = &(Text->BoundingBox).Y1;
  *pLVar1 = *pLVar1 - pPVar6->Bloat;
  iVar11 = pPVar6->Bloat + (Text->BoundingBox).X2;
  (Text->BoundingBox).X2 = iVar11;
  iVar9 = pPVar6->Bloat;
  (Text->BoundingBox).X2 = iVar11 + 1;
  (Text->BoundingBox).Y2 = iVar9 + (Text->BoundingBox).Y2 + 1;
  return;
}



// WARNING: Unknown calling convention

void SetPadBoundingBox(PadTypePtr Pad)

{
  LocationType *pLVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  BDimension width;
  int iVar6;
  int iVar7;
  int iVar8;
  double dVar9;
  double local_2c;
  double local_24 [2];
  
  iVar8 = (Pad->Point1).X;
  width = (Pad->Thickness + Pad->Clearance + 1) / 2;
  iVar5 = (Pad->Point2).Y;
  iVar2 = (Pad->Mask + 1) / 2;
  if (width < iVar2) {
    width = iVar2;
  }
  iVar2 = (Pad->Point2).X;
  if (((iVar2 - iVar8 == 0) || ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0)) ||
     (iVar7 = iVar5 - (Pad->Point1).Y, iVar7 == 0)) {
    if (iVar2 < iVar8) {
      iVar8 = iVar2;
    }
    (Pad->BoundingBox).X1 = iVar8 - width;
    if (iVar2 <= (Pad->Point1).X) {
      iVar2 = (Pad->Point1).X;
    }
    pLVar1 = &(Pad->Point1).Y;
    iVar8 = iVar5;
    if (*pLVar1 == iVar5 || *pLVar1 < iVar5) {
      iVar8 = (Pad->Point1).Y;
    }
    iVar2 = width + iVar2;
    (Pad->BoundingBox).X2 = iVar2;
    if (iVar5 <= (Pad->Point1).Y) {
      iVar5 = (Pad->Point1).Y;
    }
    (Pad->BoundingBox).Y1 = iVar8 - width;
    (Pad->BoundingBox).Y2 = width + iVar5;
  }
  else {
    dVar9 = atan2((double)iVar7,(double)(iVar2 - iVar8));
    sincos((double)((float)dVar9 + 0.7853982),local_24,&local_2c);
    iVar8 = (int)ROUND((float)local_2c * (float)width * 1.414214);
    iVar2 = (Pad->Point2).X;
    iVar5 = (int)ROUND((float)local_24[0] * (float)width * 1.414214);
    iVar7 = (Pad->Point1).X;
    iVar6 = iVar8 + iVar2;
    iVar2 = iVar2 + iVar5;
    iVar4 = iVar2;
    if (iVar6 <= iVar2) {
      iVar4 = iVar6;
    }
    iVar3 = iVar7 - iVar5;
    if (iVar3 < iVar4) {
      iVar4 = iVar3;
    }
    iVar7 = iVar7 - iVar8;
    if (iVar7 < iVar4) {
      iVar4 = iVar7;
    }
    if (iVar2 <= iVar6) {
      iVar2 = iVar6;
    }
    if (iVar2 < iVar3) {
      iVar2 = iVar3;
    }
    iVar6 = (Pad->Point2).Y;
    if (iVar2 < iVar7) {
      iVar2 = iVar7;
    }
    iVar7 = (Pad->Point1).Y;
    (Pad->BoundingBox).X1 = iVar4;
    iVar4 = iVar6 + iVar5;
    iVar6 = iVar6 - iVar8;
    (Pad->BoundingBox).X2 = iVar2;
    iVar3 = iVar4;
    if (iVar6 <= iVar4) {
      iVar3 = iVar6;
    }
    iVar7 = iVar7 - iVar5;
    if (iVar7 < iVar3) {
      iVar3 = iVar7;
    }
    iVar8 = iVar8 + (Pad->Point1).Y;
    iVar5 = iVar8;
    if (iVar3 <= iVar8) {
      iVar5 = iVar3;
    }
    if (iVar4 <= iVar6) {
      iVar4 = iVar6;
    }
    if (iVar7 <= iVar4) {
      iVar7 = iVar4;
    }
    if (iVar7 < iVar8) {
      iVar7 = iVar8;
    }
    (Pad->BoundingBox).Y1 = iVar5;
    (Pad->BoundingBox).Y2 = iVar7;
  }
  pLVar1 = &(Pad->BoundingBox).Y2;
  *pLVar1 = *pLVar1 + 1;
  (Pad->BoundingBox).X2 = iVar2 + 1;
  return;
}



// WARNING: Unknown calling convention

void SetElementBoundingBox(DataTypePtr Data,ElementTypePtr Element,FontTypePtr Font)

{
  FlagType *pFVar1;
  LocationType *pLVar2;
  TextTypePtr Text;
  Cardinal CVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  Cardinal sn;
  int iVar7;
  rtree_t *prVar8;
  PinTypePtr paVar9;
  PadTypePtr paVar10;
  Cardinal sn_2;
  Cardinal sn_3;
  int iVar11;
  int iVar12;
  Cardinal sn_1;
  int iVar13;
  uint uVar14;
  Cardinal n_3;
  Cardinal n_4;
  Cardinal n;
  LineTypePtr line;
  ArcTypePtr arc;
  ArcTypePtr Arc;
  PinTypePtr pin;
  PadTypePtr pad;
  Cardinal n_5;
  TextTypePtr text;
  Cardinal n_1;
  uint uVar15;
  Cardinal n_2;
  uint local_40;
  int local_30;
  uint local_2c;
  uint local_24;
  int local_20;
  
  if ((Data != (DataTypePtr)0x0) && (Data->element_tree != (rtree_t *)0x0)) {
    r_delete_entry(Data->element_tree,&Element->BoundingBox);
  }
  n = 2;
  do {
    Text = Element->Name + n;
    if (Data == (DataTypePtr)0x0) {
      SetTextBoundingBox(Font,Text);
    }
    else {
      if (Data->name_tree[n] != (rtree_t *)0x0) {
        r_delete_entry(Data->name_tree[n],&Text->BoundingBox);
      }
      SetTextBoundingBox(Font,Text);
      prVar8 = Data->name_tree[n];
      if (prVar8 == (rtree_t *)0x0) {
        prVar8 = r_create_tree((BoxType **)0x0,0,0);
        Data->name_tree[n] = prVar8;
      }
      r_insert_entry(prVar8,&Text->BoundingBox,0);
    }
    n = n - 1;
  } while (n != 0xffffffff);
  CVar3 = Element->LineN;
  (Element->BoundingBox).Y1 = 10000000;
  (Element->BoundingBox).X1 = 10000000;
  (Element->BoundingBox).Y2 = 0;
  local_20 = CVar3 - 1;
  (Element->BoundingBox).X2 = 0;
  if (local_20 != -1) {
    iVar6 = CVar3 * 0x58;
    do {
      local_24 = iVar6 + -0x58;
      line = (LineTypePtr)(Element->Line[-1].Flags.t + iVar6 + -0x18);
      SetLineBoundingBox(line);
      iVar12 = (line->Point1).X;
      iVar11 = line->Thickness + 1;
      iVar5 = -(iVar11 / 2);
      iVar6 = iVar5 + iVar12;
      if (iVar6 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar6;
      }
      iVar7 = (line->Point1).Y;
      iVar6 = iVar5 + iVar7;
      if (iVar6 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar6;
      }
      iVar13 = (line->Point2).X;
      iVar6 = iVar5 + iVar13;
      if (iVar6 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar6;
      }
      iVar6 = (line->Point2).Y;
      iVar5 = iVar5 + iVar6;
      if (iVar5 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar5;
      }
      iVar11 = iVar11 / 2;
      iVar12 = iVar11 + iVar12;
      if ((Element->BoundingBox).X2 < iVar12) {
        (Element->BoundingBox).X2 = iVar12;
      }
      iVar7 = iVar11 + iVar7;
      if ((Element->BoundingBox).Y2 < iVar7) {
        (Element->BoundingBox).Y2 = iVar7;
      }
      iVar13 = iVar11 + iVar13;
      if ((Element->BoundingBox).X2 < iVar13) {
        (Element->BoundingBox).X2 = iVar13;
      }
      iVar11 = iVar11 + iVar6;
      if ((Element->BoundingBox).Y2 < iVar11) {
        (Element->BoundingBox).Y2 = iVar11;
      }
      local_20 = local_20 + -1;
      iVar6 = local_24;
    } while (local_20 != -1);
  }
  iVar6 = Element->ArcN - 1;
  if (iVar6 != -1) {
    iVar12 = Element->ArcN * 0x44;
    do {
      Arc = (ArcTypePtr)(Element->Arc[-1].Flags.t + iVar12 + -0x18);
      SetArcBoundingBox(Arc);
      iVar5 = (Arc->BoundingBox).X1;
      if (iVar5 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar5;
      }
      iVar5 = (Arc->BoundingBox).Y1;
      if (iVar5 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar5;
      }
      iVar5 = (Arc->BoundingBox).X2;
      if ((Element->BoundingBox).X2 < iVar5) {
        (Element->BoundingBox).X2 = iVar5;
      }
      iVar5 = (Arc->BoundingBox).Y2;
      if ((Element->BoundingBox).Y2 < iVar5) {
        (Element->BoundingBox).Y2 = iVar5;
      }
      iVar6 = iVar6 + -1;
      iVar12 = iVar12 + -0x44;
    } while (iVar6 != -1);
  }
  (Element->VBox).X1 = (Element->BoundingBox).X1;
  (Element->VBox).Y1 = (Element->BoundingBox).Y1;
  (Element->VBox).X2 = (Element->BoundingBox).X2;
  (Element->VBox).Y2 = (Element->BoundingBox).Y2;
  if (Element->PinN != 0) {
    uVar15 = 0;
    local_24 = Element->PinN;
    do {
      paVar9 = Element->Pin + uVar15;
      if (Data == (DataTypePtr)0x0) {
        SetPinBoundingBox(paVar9);
      }
      else {
        if (Data->pin_tree != (rtree_t *)0x0) {
          r_delete_entry(Data->pin_tree,&paVar9->BoundingBox);
        }
        SetPinBoundingBox(paVar9);
        prVar8 = Data->pin_tree;
        if (prVar8 == (rtree_t *)0x0) {
          prVar8 = r_create_tree((BoxType **)0x0,0,0);
          Data->pin_tree = prVar8;
        }
        r_insert_entry(prVar8,&paVar9->BoundingBox,0);
      }
      iVar6 = (paVar9->BoundingBox).X1;
      if (iVar6 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar6;
      }
      iVar6 = (paVar9->BoundingBox).Y1;
      if (iVar6 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar6;
      }
      iVar6 = (paVar9->BoundingBox).X2;
      if ((Element->BoundingBox).X2 < iVar6) {
        (Element->BoundingBox).X2 = iVar6;
      }
      iVar6 = (paVar9->BoundingBox).Y2;
      if ((Element->BoundingBox).Y2 < iVar6) {
        (Element->BoundingBox).Y2 = iVar6;
      }
      iVar6 = paVar9->X;
      iVar12 = paVar9->Thickness;
      iVar5 = -(iVar12 / 2);
      iVar11 = iVar6 + iVar5;
      if (iVar11 < (Element->VBox).X1) {
        (Element->VBox).X1 = iVar11;
      }
      iVar11 = paVar9->Y;
      iVar5 = iVar5 + iVar11;
      if (iVar5 < (Element->VBox).Y1) {
        (Element->VBox).Y1 = iVar5;
      }
      iVar12 = iVar12 / 2;
      iVar6 = iVar12 + iVar6;
      if ((Element->VBox).X2 < iVar6) {
        (Element->VBox).X2 = iVar6;
      }
      iVar12 = iVar12 + iVar11;
      if ((Element->VBox).Y2 < iVar12) {
        (Element->VBox).Y2 = iVar12;
      }
      uVar14 = Element->PinN;
    } while ((uVar14 != 0) &&
            (uVar15 = (uVar14 + 1 + uVar15) - local_24, local_24 = uVar14, uVar15 < uVar14));
  }
  uVar15 = Element->PadN;
  local_30 = 0;
  local_2c = 0;
  uVar14 = uVar15;
  while (uVar14 != 0) {
    if (uVar14 <= local_2c) {
      local_30 = (Element->BoundingBox).Y1;
      local_20 = (Element->BoundingBox).X2;
      local_24 = (Element->BoundingBox).X1;
      iVar6 = (Element->BoundingBox).Y2;
      paVar10 = Element->Pad;
      local_40 = 0;
      goto LAB_080a63e0;
    }
    paVar10 = (PadTypePtr)((Element->Pad->Flags).t + local_30 + -0x18);
    if (Data == (DataTypePtr)0x0) {
      SetPadBoundingBox(paVar10);
    }
    else {
      if (Data->pad_tree != (rtree_t *)0x0) {
        r_delete_entry(Data->pad_tree,(BoxType *)paVar10);
      }
      SetPadBoundingBox(paVar10);
      prVar8 = Data->pad_tree;
      if (prVar8 == (rtree_t *)0x0) {
        prVar8 = r_create_tree((BoxType **)0x0,0,0);
        Data->pad_tree = prVar8;
      }
      r_insert_entry(prVar8,(BoxType *)paVar10,0);
    }
    iVar6 = (paVar10->BoundingBox).X1;
    if (iVar6 < (Element->BoundingBox).X1) {
      (Element->BoundingBox).X1 = iVar6;
    }
    iVar6 = (paVar10->BoundingBox).Y1;
    if (iVar6 < (Element->BoundingBox).Y1) {
      (Element->BoundingBox).Y1 = iVar6;
    }
    iVar6 = (paVar10->BoundingBox).X2;
    if ((Element->BoundingBox).X2 < iVar6) {
      (Element->BoundingBox).X2 = iVar6;
    }
    iVar6 = (paVar10->BoundingBox).Y2;
    if ((Element->BoundingBox).Y2 < iVar6) {
      (Element->BoundingBox).Y2 = iVar6;
    }
    iVar5 = paVar10->Thickness;
    iVar11 = (paVar10->Point2).X;
    iVar12 = (paVar10->Point1).X;
    iVar7 = -(iVar5 / 2);
    iVar6 = iVar11;
    if (iVar12 <= iVar11) {
      iVar6 = iVar12;
    }
    iVar6 = iVar7 + iVar6;
    if (iVar6 < (Element->VBox).X1) {
      (Element->VBox).X1 = iVar6;
    }
    iVar4 = (paVar10->Point2).Y;
    iVar13 = (paVar10->Point1).Y;
    iVar6 = iVar4;
    if (iVar13 <= iVar4) {
      iVar6 = iVar13;
    }
    iVar6 = iVar6 + iVar7;
    if (iVar6 < (Element->VBox).Y1) {
      (Element->VBox).Y1 = iVar6;
    }
    iVar5 = iVar5 / 2;
    if (iVar12 < iVar11) {
      iVar12 = iVar11;
    }
    iVar12 = iVar5 + iVar12;
    if ((Element->VBox).X2 < iVar12) {
      (Element->VBox).X2 = iVar12;
    }
    if (iVar13 < iVar4) {
      iVar13 = iVar4;
    }
    iVar13 = iVar13 + iVar5;
    if ((Element->VBox).Y2 < iVar13) {
      (Element->VBox).Y2 = iVar13;
    }
    uVar14 = Element->PadN;
    if (Element->PadN == uVar15) {
      local_2c = local_2c + 1;
      local_30 = local_30 + 0x68;
      uVar14 = uVar15;
    }
  }
  local_24 = (Element->BoundingBox).X1;
  local_30 = (Element->BoundingBox).Y1;
  local_20 = (Element->BoundingBox).X2;
  iVar6 = (Element->BoundingBox).Y2;
  goto LAB_080a62f4;
LAB_080a63e0:
  do {
    iVar12 = (paVar10->Point1).Y;
    iVar5 = (paVar10->Point2).Y;
    if (iVar12 == iVar5) {
      if (local_20 - (paVar10->Point2).X < (int)((paVar10->Point1).X - local_24)) goto LAB_080a63f4;
LAB_080a6428:
      (paVar10->Flags).f = (paVar10->Flags).f & 0xffffbfff;
    }
    else {
      if (iVar12 - local_30 <= iVar6 - iVar5) goto LAB_080a6428;
LAB_080a63f4:
      (paVar10->Flags).f = (paVar10->Flags).f | 0x4000;
    }
    local_40 = local_40 + 1;
    paVar10 = paVar10 + 1;
  } while (local_40 < uVar14);
LAB_080a62f4:
  if (iVar6 - local_30 < (int)(local_20 - local_24)) {
    uVar15 = Element->PinN;
    if (uVar15 != 0) {
      paVar9 = Element->Pin;
      pFVar1 = &paVar9->Flags;
      pFVar1->f = pFVar1->f | 0x4000;
      for (uVar14 = 1; uVar14 < uVar15; uVar14 = uVar14 + 1) {
        paVar9[1].Flags.f = paVar9[1].Flags.f | 0x4000;
        paVar9 = paVar9 + 1;
      }
    }
  }
  else {
    uVar15 = Element->PinN;
    if (uVar15 != 0) {
      paVar9 = Element->Pin;
      pFVar1 = &paVar9->Flags;
      pFVar1->f = pFVar1->f & 0xffffbfff;
      for (uVar14 = 1; uVar14 < uVar15; uVar14 = uVar14 + 1) {
        paVar9[1].Flags.f = paVar9[1].Flags.f & 0xffffbfff;
        paVar9 = paVar9 + 1;
      }
    }
  }
  pLVar2 = &(Element->BoundingBox).Y2;
  *pLVar2 = *pLVar2 + 1;
  pLVar2 = &(Element->VBox).X2;
  *pLVar2 = *pLVar2 + 1;
  pLVar2 = &(Element->VBox).Y2;
  *pLVar2 = *pLVar2 + 1;
  (Element->BoundingBox).X2 = local_20 + 1;
  if (Data == (DataTypePtr)0x0) {
    return;
  }
  prVar8 = Data->element_tree;
  if (prVar8 == (rtree_t *)0x0) {
    prVar8 = r_create_tree((BoxType **)0x0,0,0);
    Data->element_tree = prVar8;
  }
  r_insert_entry(prVar8,&Element->BoundingBox,0);
  return;
}



// WARNING: Unknown calling convention

float GetValue(char *val,char *units,Boolean *absolute)

{
  char cVar1;
  float fVar2;
  ushort **ppuVar3;
  int iVar4;
  float value;
  double dVar5;
  
  cVar1 = *val;
  if (cVar1 == '=') {
    *absolute = '\x01';
    dVar5 = strtod(val + 1,(char **)0x0);
  }
  else {
    ppuVar3 = __ctype_b_loc();
    *absolute = (*(byte *)((int)*ppuVar3 + cVar1 * 2 + 1) & 8) != 0;
    dVar5 = strtod(val,(char **)0x0);
  }
  fVar2 = (float)dVar5;
  if ((units != (char *)0x0) && (*units != '\0')) {
    iVar4 = strncasecmp(units,"mm",2);
    if (iVar4 == 0) {
      fVar2 = fVar2 * 3937.008;
    }
    else {
      iVar4 = strncasecmp(units,"mil",3);
      if (iVar4 == 0) {
        fVar2 = fVar2 * 100.0;
      }
    }
  }
  return fVar2;
}



// WARNING: Unknown calling convention

FlagType * OldFlags(uint flags)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int i;
  uint uVar4;
  int f;
  int in_GS_OFFSET;
  FlagType *in_stack_00000004;
  FlagType rv;
  
  uVar4 = 0x10000;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  rv.t[0] = '\0';
  rv.t[1] = '\0';
  rv.t[2] = '\0';
  rv.t[3] = '\0';
  rv.f = flags & 0xffff;
  uVar3 = 0;
  rv.t[4] = '\0';
  rv.t[5] = '\0';
  rv.t[6] = '\0';
  rv.t[7] = '\0';
  while( true ) {
    if ((uVar4 & flags) != 0) {
      rv.t[(int)uVar3 >> 1] = rv.t[(int)uVar3 >> 1] | (byte)(1 << (sbyte)((uVar3 & 1) << 2));
    }
    uVar3 = uVar3 + 1;
    if (uVar3 == 8) break;
    uVar4 = uVar4 * 2;
  }
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  in_stack_00000004->f = rv.f;
  *(undefined4 *)in_stack_00000004->t = rv.t._0_4_;
  *(undefined4 *)(in_stack_00000004->t + 4) = 0;
  if (iVar1 == iVar2) {
    return in_stack_00000004;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Variable defined which should be unmapped: rv
// WARNING: Unknown calling convention

FlagType * MakeFlags(uint flags)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  FlagType *in_stack_00000004;
  FlagType rv;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  in_stack_00000004->f = flags;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  *(undefined4 *)in_stack_00000004->t = 0;
  *(undefined4 *)(in_stack_00000004->t + 4) = 0;
  if (iVar1 == iVar2) {
    return in_stack_00000004;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail(flags,0,0);
}



// WARNING: Unknown calling convention

void MovePolygonLowLevel(PolygonTypePtr Polygon,LocationType DeltaX,LocationType DeltaY)

{
  LocationType *pLVar1;
  PointTypePtr pPVar2;
  Cardinal n;
  int iVar3;
  
  iVar3 = Polygon->PointN - 1;
  if (iVar3 != -1) {
    pPVar2 = Polygon->Points + (Polygon->PointN - 1);
    do {
      iVar3 = iVar3 + -1;
      pPVar2->X = pPVar2->X + DeltaX;
      pPVar2->Y = pPVar2->Y + DeltaY;
      pPVar2 = pPVar2 + -1;
    } while (iVar3 != -1);
  }
  (Polygon->BoundingBox).X1 = (Polygon->BoundingBox).X1 + DeltaX;
  pLVar1 = &(Polygon->BoundingBox).Y1;
  *pLVar1 = *pLVar1 + DeltaY;
  pLVar1 = &(Polygon->BoundingBox).X2;
  *pLVar1 = *pLVar1 + DeltaX;
  pLVar1 = &(Polygon->BoundingBox).Y2;
  *pLVar1 = *pLVar1 + DeltaY;
  return;
}



// WARNING: Unknown calling convention

void move_one_thermal(int old_index,int new_index,PinType *pin)

{
  uchar *puVar1;
  char cVar2;
  int iVar3;
  int i;
  int iVar4;
  int iVar5;
  byte bVar6;
  int oi;
  uint local_20;
  byte local_14;
  
  local_20 = 0;
  iVar5 = 0xf;
  if (old_index != -1) {
    cVar2 = (char)(old_index >> 0x1f);
    local_20 = (int)(uint)(pin->Flags).t[old_index / 2] >>
               ((((char)old_index - cVar2 & 1U) + cVar2) * '\x04' & 0x1f) & 0xf;
    iVar5 = old_index;
  }
  iVar3 = 0xf;
  if (new_index != -1) {
    iVar3 = new_index;
  }
  if (iVar5 < iVar3) {
    do {
      iVar4 = iVar5 + 1;
      local_14 = (char)(iVar5 % 2) * '\x04';
      cVar2 = (char)(iVar4 >> 0x1f);
      (pin->Flags).t[iVar5 / 2] =
           ~(byte)(0xf << (local_14 & 0x1f)) & (pin->Flags).t[iVar5 / 2] |
           (byte)(((int)(uint)(pin->Flags).t[iVar4 / 2] >>
                   ((((char)iVar4 - cVar2 & 1U) + cVar2) * '\x04' & 0x1f) & 0xfU) <<
                 (local_14 & 0x1f));
      iVar5 = iVar4;
    } while (iVar4 < iVar3);
  }
  else {
    while (iVar3 < iVar5) {
      iVar4 = iVar5 + -1;
      local_14 = (char)(iVar5 % 2) * '\x04';
      cVar2 = (char)(iVar4 >> 0x1f);
      (pin->Flags).t[iVar5 / 2] =
           ~(byte)(0xf << (local_14 & 0x1f)) & (pin->Flags).t[iVar5 / 2] |
           (byte)(((int)(uint)(pin->Flags).t[iVar4 / 2] >>
                   ((((char)iVar4 - cVar2 & 1U) + cVar2) * '\x04' & 0x1f) & 0xfU) <<
                 (local_14 & 0x1f));
      iVar5 = iVar4;
    }
  }
  if (new_index != -1) {
    cVar2 = (char)(new_index >> 0x1f);
    bVar6 = (((char)new_index - cVar2 & 1U) + cVar2) * '\x04';
    (pin->Flags).t[new_index / 2] =
         ~(byte)(0xf << (bVar6 & 0x1f)) & (pin->Flags).t[new_index / 2] |
         (byte)(local_20 << (bVar6 & 0x1f));
    return;
  }
  cVar2 = (char)(iVar3 >> 0x1f);
  puVar1 = (pin->Flags).t + iVar3 / 2;
  *puVar1 = *puVar1 & ~(byte)(0xf << ((((char)iVar3 - cVar2 & 1U) + cVar2) * '\x04' & 0x1f));
  return;
}



// WARNING: Unknown calling convention

void register_move_action_list(void)

{
  hid_register_actions(move_action_list,1);
  return;
}



// WARNING: Unknown calling convention

Boolean MoveSelectedObjectsToLayer(LayerTypePtr Target)

{
  Boolean changed;
  Boolean BVar1;
  
  Dest = Target;
  MoreToCome = '\x01';
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&MoveToLayerFunctions,'\x01',-1);
  return BVar1;
}



// WARNING: Unknown calling convention

void * MoveRatToLayer(RatTypePtr Rat)

{
  LineTypePtr Line;
  LineTypePtr pLVar1;
  LineTypePtr new;
  
  Line = CreateNewLineOnLayer
                   (Dest,(Rat->Point1).X,(Rat->Point1).Y,(Rat->Point2).X,(Rat->Point2).Y,
                    Settings.LineThickness,Settings.Keepaway * 2,Rat->Flags);
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 8) != 0) {
    (Line->Flags).f = (Line->Flags).f | 0x20;
  }
  pLVar1 = (LineTypePtr)0x0;
  if (Line != (LineTypePtr)0x0) {
    AddObjectToCreateUndoList(4,Dest,Line,Line);
    if (PCB->RatOn != '\0') {
      EraseRat(Rat);
    }
    MoveObjectToRemoveUndoList(0x20,Rat,Rat,Rat);
    DrawLine(Dest,Line,0);
    Draw();
    pLVar1 = Line;
  }
  return pLVar1;
}



// WARNING: Unknown calling convention

int moveline_callback(BoxType *b,void *cl)

{
  FlagType Flags;
  PinTypePtr Via;
  PinTypePtr via;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  MakeFlags(0);
                    // WARNING: Load size is inaccurate
  Flags.t._0_4_ = local_18;
  Flags.f = local_1c;
  Flags.t._4_4_ = local_14;
  Via = CreateNewVia(PCB->Data,*cl,*(LocationType *)((int)cl + 4),Settings.ViaThickness,
                     Settings.Keepaway * 2,0,Settings.ViaDrillingHole,(char *)0x0,Flags);
  if (Via != (PinTypePtr)0x0) {
    AddObjectToCreateUndoList(1,Via,Via,Via);
    DrawVia(Via,0);
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 8,1);
}



// WARNING: Unknown calling convention

void * MoveObjectToLayer(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LayerTypePtr Target,
                        Boolean enmasse)

{
  void *pvVar1;
  void *result;
  
  Dest = Target;
  MoreToCome = enmasse;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&MoveToLayerFunctions,Type,Ptr1,Ptr2,Ptr3);
  IncrementUndoSerialNumber();
  return pvVar1;
}



// WARNING: Unknown calling convention

void * MoveObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  void *pvVar1;
  
  DeltaX = DX;
  DeltaY = DY;
  AddObjectToMoveUndoList(Type,Ptr1,Ptr2,Ptr3,DX,DY);
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&MoveFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * MoveArc(LayerTypePtr Layer,ArcTypePtr Arc)

{
  LocationType *pLVar1;
  LocationType LVar2;
  LocationType LVar3;
  
  RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
  r_delete_entry(Layer->arc_tree,&Arc->BoundingBox);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  if (Layer->On == '\0') {
    Arc->X = Arc->X + DeltaX;
    Arc->Y = Arc->Y + LVar3;
    (Arc->BoundingBox).X1 = (Arc->BoundingBox).X1 + LVar2;
    pLVar1 = &(Arc->BoundingBox).Y1;
    *pLVar1 = *pLVar1 + LVar3;
    pLVar1 = &(Arc->BoundingBox).X2;
    *pLVar1 = *pLVar1 + LVar2;
    pLVar1 = &(Arc->BoundingBox).Y2;
    *pLVar1 = *pLVar1 + LVar3;
  }
  else {
    EraseArc(Arc);
    LVar3 = DeltaY;
    LVar2 = DeltaX;
    Arc->X = Arc->X + DeltaX;
    Arc->Y = Arc->Y + LVar3;
    (Arc->BoundingBox).X1 = (Arc->BoundingBox).X1 + LVar2;
    pLVar1 = &(Arc->BoundingBox).Y1;
    *pLVar1 = *pLVar1 + LVar3;
    pLVar1 = &(Arc->BoundingBox).X2;
    *pLVar1 = *pLVar1 + LVar2;
    pLVar1 = &(Arc->BoundingBox).Y2;
    *pLVar1 = *pLVar1 + LVar3;
    DrawArc(Layer,Arc,0);
    Draw();
  }
  r_insert_entry(Layer->arc_tree,&Arc->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
  return Arc;
}



// WARNING: Unknown calling convention

void * MovePolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
  }
  r_delete_entry(Layer->polygon_tree,&Polygon->BoundingBox);
  MovePolygonLowLevel(Polygon,DeltaX,DeltaY);
  r_insert_entry(Layer->polygon_tree,&Polygon->BoundingBox,0);
  InitClip(PCB->Data,Layer,Polygon);
  if (Layer->On != '\0') {
    DrawPolygon(Layer,Polygon,0);
    Draw();
  }
  return Polygon;
}



// WARNING: Unknown calling convention

void * MoveText(LayerTypePtr Layer,TextTypePtr Text)

{
  LocationType *pLVar1;
  LocationType LVar2;
  LocationType LVar3;
  
  RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  r_delete_entry(Layer->text_tree,&Text->BoundingBox);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  if (Layer->On == '\0') {
    (Text->BoundingBox).X1 = (Text->BoundingBox).X1 + DeltaX;
    pLVar1 = &(Text->BoundingBox).Y1;
    *pLVar1 = *pLVar1 + LVar3;
    pLVar1 = &(Text->BoundingBox).X2;
    *pLVar1 = *pLVar1 + LVar2;
    pLVar1 = &(Text->BoundingBox).Y2;
    *pLVar1 = *pLVar1 + LVar3;
    Text->X = Text->X + LVar2;
    Text->Y = Text->Y + LVar3;
  }
  else {
    EraseText(Layer,Text);
    LVar3 = DeltaY;
    LVar2 = DeltaX;
    (Text->BoundingBox).X1 = (Text->BoundingBox).X1 + DeltaX;
    pLVar1 = &(Text->BoundingBox).Y1;
    *pLVar1 = *pLVar1 + LVar3;
    pLVar1 = &(Text->BoundingBox).X2;
    *pLVar1 = *pLVar1 + LVar2;
    pLVar1 = &(Text->BoundingBox).Y2;
    *pLVar1 = *pLVar1 + LVar3;
    Text->X = Text->X + LVar2;
    Text->Y = Text->Y + LVar3;
    DrawText(Layer,Text,0);
    Draw();
  }
  r_insert_entry(Layer->text_tree,&Text->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  return Text;
}



// WARNING: Unknown calling convention

void * MovePolygonPoint(LayerTypePtr Layer,PolygonTypePtr Polygon,PointTypePtr Point)

{
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
  }
  r_delete_entry(Layer->polygon_tree,&Polygon->BoundingBox);
  Point->X = Point->X + DeltaX;
  Point->Y = Point->Y + DeltaY;
  SetPolygonBoundingBox(Polygon);
  r_insert_entry(Layer->polygon_tree,&Polygon->BoundingBox,0);
  RemoveExcessPolygonPoints(Layer,Polygon);
  InitClip(PCB->Data,Layer,Polygon);
  if (Layer->On != '\0') {
    DrawPolygon(Layer,Polygon,0);
    Draw();
  }
  return Point;
}



// WARNING: Unknown calling convention

void * MoveElementName(ElementTypePtr Element)

{
  LocationType *pLVar1;
  rtree_t *prVar2;
  LocationType LVar3;
  LocationType LVar4;
  rtree_t *prVar5;
  TextTypePtr text;
  TextTypePtr text_1;
  ElementTypePtr paVar6;
  int iVar7;
  Cardinal n;
  Cardinal n_1;
  
  if ((PCB->ElementOn != '\0') &&
     ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (PCB->InvisibleObjectsOn != '\0')))) {
    iVar7 = 2;
    EraseElementName(Element);
    paVar6 = Element;
    do {
      prVar5 = (rtree_t *)0x0;
      prVar2 = PCB->Data->name_tree[iVar7];
      if (prVar2 != (rtree_t *)0x0) {
        r_delete_entry(prVar2,(BoxType *)(Element->Name + iVar7));
        prVar5 = PCB->Data->name_tree[iVar7];
      }
      LVar4 = DeltaY;
      LVar3 = DeltaX;
      paVar6->Name[2].BoundingBox.X1 = paVar6->Name[2].BoundingBox.X1 + DeltaX;
      pLVar1 = &paVar6->Name[2].BoundingBox.Y1;
      *pLVar1 = *pLVar1 + LVar4;
      pLVar1 = &paVar6->Name[2].BoundingBox.X2;
      *pLVar1 = *pLVar1 + LVar3;
      pLVar1 = &paVar6->Name[2].BoundingBox.Y2;
      *pLVar1 = *pLVar1 + LVar4;
      pLVar1 = &paVar6->Name[2].X;
      *pLVar1 = *pLVar1 + LVar3;
      pLVar1 = &paVar6->Name[2].Y;
      *pLVar1 = *pLVar1 + LVar4;
      if (prVar5 != (rtree_t *)0x0) {
        r_insert_entry(prVar5,(BoxType *)(Element->Name + iVar7),0);
      }
      iVar7 = iVar7 + -1;
      paVar6 = (ElementTypePtr)&paVar6[-1].LineN;
    } while (iVar7 != -1);
    DrawElementName(Element,0);
    Draw();
    return Element;
  }
  iVar7 = 2;
  paVar6 = Element;
  do {
    prVar2 = PCB->Data->name_tree[iVar7];
    prVar5 = (rtree_t *)0x0;
    if (prVar2 != (rtree_t *)0x0) {
      r_delete_entry(prVar2,(BoxType *)(Element->Name + iVar7));
      prVar5 = PCB->Data->name_tree[iVar7];
    }
    LVar4 = DeltaY;
    LVar3 = DeltaX;
    paVar6->Name[2].BoundingBox.X1 = paVar6->Name[2].BoundingBox.X1 + DeltaX;
    pLVar1 = &paVar6->Name[2].BoundingBox.Y1;
    *pLVar1 = *pLVar1 + LVar4;
    pLVar1 = &paVar6->Name[2].BoundingBox.X2;
    *pLVar1 = *pLVar1 + LVar3;
    pLVar1 = &paVar6->Name[2].BoundingBox.Y2;
    *pLVar1 = *pLVar1 + LVar4;
    pLVar1 = &paVar6->Name[2].X;
    *pLVar1 = *pLVar1 + LVar3;
    pLVar1 = &paVar6->Name[2].Y;
    *pLVar1 = *pLVar1 + LVar4;
    if (prVar5 != (rtree_t *)0x0) {
      r_insert_entry(prVar5,(BoxType *)(Element->Name + iVar7),0);
    }
    iVar7 = iVar7 + -1;
    paVar6 = (ElementTypePtr)&paVar6[-1].LineN;
  } while (iVar7 != -1);
  return Element;
}



// WARNING: Unknown calling convention

void * MoveVia(PinTypePtr Via)

{
  LocationType *pLVar1;
  LocationType LVar2;
  LocationType LVar3;
  PCBTypePtr pPVar4;
  
  r_delete_entry(PCB->Data->via_tree,&Via->BoundingBox);
  RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  Via->Y = Via->Y + DeltaY;
  pLVar1 = &(Via->BoundingBox).Y1;
  *pLVar1 = *pLVar1 + LVar3;
  pLVar1 = &(Via->BoundingBox).Y2;
  *pLVar1 = *pLVar1 + LVar3;
  pPVar4 = PCB;
  Via->X = Via->X + LVar2;
  (Via->BoundingBox).X1 = (Via->BoundingBox).X1 + LVar2;
  pLVar1 = &(Via->BoundingBox).X2;
  *pLVar1 = *pLVar1 + LVar2;
  if (pPVar4->ViaOn != '\0') {
    EraseVia(Via);
    pPVar4 = PCB;
  }
  r_insert_entry(pPVar4->Data->via_tree,&Via->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
  if (PCB->ViaOn != '\0') {
    DrawVia(Via,0);
    Draw();
  }
  return Via;
}



// WARNING: Unknown calling convention

void * MoveLine(LayerTypePtr Layer,LineTypePtr Line)

{
  LocationType *pLVar1;
  LocationType LVar2;
  LocationType LVar3;
  
  if (Layer->On != '\0') {
    EraseLine(Line);
  }
  RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
  r_delete_entry(Layer->line_tree,&Line->BoundingBox);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  (Line->Point1).X = (Line->Point1).X + DeltaX;
  (Line->Point2).X = (Line->Point2).X + LVar2;
  pLVar1 = &(Line->Point1).Y;
  *pLVar1 = *pLVar1 + LVar3;
  pLVar1 = &(Line->Point2).Y;
  *pLVar1 = *pLVar1 + LVar3;
  SetLineBoundingBox(Line);
  r_insert_entry(Layer->line_tree,&Line->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
  if (Layer->On != '\0') {
    DrawLine(Layer,Line,0);
    Draw();
  }
  return Line;
}



// WARNING: Unknown calling convention

void * MoveLinePoint(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr Point)

{
  if (Layer == (LayerTypePtr)0x0) {
    if (PCB->RatOn != '\0') {
      EraseRat((RatTypePtr)Line);
    }
    r_delete_entry(PCB->Data->rat_tree,&Line->BoundingBox);
    Point->X = Point->X + DeltaX;
    Point->Y = Point->Y + DeltaY;
    SetLineBoundingBox(Line);
    r_insert_entry(PCB->Data->rat_tree,&Line->BoundingBox,0);
    if (PCB->RatOn != '\0') {
      DrawRat((RatTypePtr)Line,0);
      Draw();
    }
  }
  else {
    if (Layer->On != '\0') {
      EraseLine(Line);
    }
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    r_delete_entry(Layer->line_tree,&Line->BoundingBox);
    Point->X = Point->X + DeltaX;
    Point->Y = Point->Y + DeltaY;
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,&Line->BoundingBox,0);
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
    if (Layer->On != '\0') {
      DrawLine(Layer,Line,0);
      Draw();
    }
  }
  return Line;
}



// WARNING: Unknown calling convention

void * MoveObjectAndRubberband
                 (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  FlagType *pFVar1;
  void *pvVar2;
  void *ptr2;
  RubberbandTypePtr ptr;
  RubberbandTypePtr paVar3;
  
  DeltaX = DX;
  DeltaY = DY;
  if ((DY == 0) && (DX == 0)) {
    return (void *)0x0;
  }
  paVar3 = Crosshair.AttachedObject.Rubberband;
  if (Crosshair.AttachedObject.RubberbandN != 0) {
    do {
      pFVar1 = &paVar3->Line->Flags;
      pFVar1->f = pFVar1->f & 0xfffffdff;
      AddObjectToMoveUndoList(0x1000,paVar3->Layer,paVar3->Line,paVar3->MovedPoint,DX,DY);
      MoveLinePoint(paVar3->Layer,paVar3->Line,paVar3->MovedPoint);
      Crosshair.AttachedObject.RubberbandN = Crosshair.AttachedObject.RubberbandN - 1;
      paVar3 = paVar3 + 1;
    } while (Crosshair.AttachedObject.RubberbandN != 0);
  }
  AddObjectToMoveUndoList(Type,Ptr1,Ptr2,Ptr3,DX,DY);
  pvVar2 = ObjectOperation((ObjectFunctionTypePtr)&MoveFunctions,Type,Ptr1,Ptr2,Ptr3);
  IncrementUndoSerialNumber();
  return pvVar2;
}



// WARNING: Unknown calling convention

int mptl_pin_callback(BoxType *b,void *cl)

{
  byte *pbVar1;
  Boolean BVar2;
  sbyte sVar3;
  uint uVar4;
  byte local_20;
  
                    // WARNING: Load size is inaccurate
  if (((0xf << (sbyte)((*cl & 1) << 2) & (uint)*(byte *)((int)&b[1].X2 + (*cl >> 1))) != 0) &&
     (BVar2 = IsPointInPolygon(b[3].Y1,b[3].X2,b[2].Y1 + b[2].X2 + 2,
                               *(PolygonTypePtr *)((int)cl + 0xc)), BVar2 != '\0')) {
    if (*(int *)((int)cl + 8) == 0x100) {
      AddObjectToFlagUndoList(0x100,(void *)b[4].Y1,b,b);
    }
    else {
      AddObjectToFlagUndoList(1,b,b,b);
    }
                    // WARNING: Load size is inaccurate
    uVar4 = *(uint *)((int)cl + 4) >> 1;
    sVar3 = (sbyte)((*(uint *)((int)cl + 4) & 1) << 2);
    local_20 = (byte)(0xf << sVar3);
    *(byte *)((int)&b[1].X2 + uVar4) =
         ~local_20 & *(byte *)((int)&b[1].X2 + uVar4) |
         (byte)(((int)(uint)*(byte *)((int)&b[1].X2 + (*cl >> 1)) >> (sbyte)((*cl & 1) << 2) & 0xfU)
               << sVar3);
                    // WARNING: Load size is inaccurate
    pbVar1 = (byte *)((int)&b[1].X2 + (*cl >> 1));
    *pbVar1 = *pbVar1 & ~(byte)(0xf << (sbyte)((*cl & 1) << 2));
    return 1;
  }
  return 0;
}



// WARNING: Unknown calling convention

void * MovePolygonToLayerLowLevel
                 (LayerTypePtr Source,PolygonTypePtr Polygon,LayerTypePtr Destination)

{
  PolygonTypePtr which;
  rtree_t *rtree;
  uint uVar1;
  Cardinal CVar2;
  uint uVar3;
  PolygonTypePtr new;
  PolygonTypePtr ppVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  which = GetPolygonMemory(Destination);
  r_delete_entry(Source->polygon_tree,&Polygon->BoundingBox);
  (which->BoundingBox).X1 = (Polygon->BoundingBox).X1;
  (which->BoundingBox).Y1 = (Polygon->BoundingBox).Y1;
  (which->BoundingBox).X2 = (Polygon->BoundingBox).X2;
  (which->BoundingBox).Y2 = (Polygon->BoundingBox).Y2;
  which->ID = Polygon->ID;
  (which->Flags).f = (Polygon->Flags).f;
  *(undefined4 *)(which->Flags).t = *(undefined4 *)(Polygon->Flags).t;
  *(undefined4 *)((which->Flags).t + 4) = *(undefined4 *)((Polygon->Flags).t + 4);
  which->net = Polygon->net;
  which->PointN = Polygon->PointN;
  which->PointMax = Polygon->PointMax;
  which->Clipped = Polygon->Clipped;
  which->NoHoles = Polygon->NoHoles;
  which->NoHolesValid = Polygon->NoHolesValid;
  which->Points = Polygon->Points;
  ppVar4 = Source->Polygon;
  CVar2 = Source->PolygonN - 1;
  Source->PolygonN = CVar2;
  (Polygon->BoundingBox).X1 = ppVar4[CVar2].BoundingBox.X1;
  (Polygon->BoundingBox).Y1 = ppVar4[CVar2].BoundingBox.Y1;
  (Polygon->BoundingBox).X2 = ppVar4[CVar2].BoundingBox.X2;
  (Polygon->BoundingBox).Y2 = ppVar4[CVar2].BoundingBox.Y2;
  Polygon->ID = ppVar4[CVar2].ID;
  (Polygon->Flags).f = ppVar4[CVar2].Flags.f;
  *(undefined4 *)(Polygon->Flags).t = *(undefined4 *)ppVar4[CVar2].Flags.t;
  *(undefined4 *)((Polygon->Flags).t + 4) = *(undefined4 *)(ppVar4[CVar2].Flags.t + 4);
  Polygon->net = ppVar4[CVar2].net;
  Polygon->PointN = ppVar4[CVar2].PointN;
  Polygon->PointMax = ppVar4[CVar2].PointMax;
  Polygon->Clipped = ppVar4[CVar2].Clipped;
  Polygon->NoHoles = ppVar4[CVar2].NoHoles;
  Polygon->NoHolesValid = ppVar4[CVar2].NoHolesValid;
  Polygon->Points = ppVar4[CVar2].Points;
  r_substitute(Source->polygon_tree,&Source->Polygon[Source->PolygonN].BoundingBox,
               &Polygon->BoundingBox);
  uVar3 = 0x3c;
  ppVar4 = Source->Polygon + Source->PolygonN;
  bVar5 = ((uint)ppVar4 & 1) != 0;
  if (bVar5) {
    *(undefined *)&(ppVar4->BoundingBox).X1 = 0;
    ppVar4 = (PolygonTypePtr)((int)&(ppVar4->BoundingBox).X1 + 1);
    uVar3 = 0x3b;
  }
  if (((uint)ppVar4 & 2) != 0) {
    *(undefined2 *)&(ppVar4->BoundingBox).X1 = 0;
    uVar3 = uVar3 - 2;
    ppVar4 = (PolygonTypePtr)((int)&(ppVar4->BoundingBox).X1 + 2);
  }
  for (uVar1 = uVar3 >> 2; uVar1 != 0; uVar1 = uVar1 - 1) {
    (ppVar4->BoundingBox).X1 = 0;
    ppVar4 = (PolygonTypePtr)((int)ppVar4 + (uint)bVar6 * -8 + 4);
  }
  if ((uVar3 & 2) != 0) {
    *(undefined2 *)&(ppVar4->BoundingBox).X1 = 0;
    ppVar4 = (PolygonTypePtr)((int)&(ppVar4->BoundingBox).X1 + 2);
  }
  if (bVar5) {
    *(undefined *)&(ppVar4->BoundingBox).X1 = 0;
  }
  rtree = Destination->polygon_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->polygon_tree = rtree;
  }
  r_insert_entry(rtree,&which->BoundingBox,0);
  return which;
}



// WARNING: Unknown calling convention

void * MovePolygonToLayer(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PolygonTypePtr new;
  mptlc d;
  
  if ((*(byte *)((int)&(Polygon->Flags).f + 1) & 0x20) == 0) {
    if ((Dest != (LayerTypePtr)0xffffffff) && (Dest != Layer)) {
      AddObjectToMoveToLayerUndoList(8,Layer,Polygon,Polygon);
      if (Layer->On != '\0') {
        ErasePolygon(Polygon);
      }
      d.snum = GetLayerNumber(PCB->Data,Layer);
      d.dnum = GetLayerNumber(PCB->Data,Dest);
      d.polygon = Polygon;
      d.type = 0x100;
      r_search(PCB->Data->pin_tree,&Polygon->BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               mptl_pin_callback,&d);
      d.type = 1;
      r_search(PCB->Data->via_tree,&Polygon->BoundingBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               mptl_pin_callback,&d);
      Polygon = (PolygonTypePtr)MovePolygonToLayerLowLevel(Layer,Polygon,Dest);
      InitClip(PCB->Data,Dest,Polygon);
      if (Dest->On != '\0') {
        DrawPolygon(Dest,Polygon,0);
        Draw();
      }
    }
  }
  else {
    Message("Sorry, the object is locked\n");
    Polygon = (PolygonTypePtr)0x0;
  }
  return Polygon;
}



// WARNING: Unknown calling convention

void * MoveTextToLayerLowLevel(LayerTypePtr Source,TextTypePtr Text,LayerTypePtr Destination)

{
  undefined3 uVar1;
  TextTypePtr Text_00;
  int iVar2;
  int iVar3;
  rtree_t *rtree;
  Cardinal CVar4;
  uint uVar5;
  uint uVar6;
  TextTypePtr new;
  TextTypePtr pTVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  Text_00 = GetTextMemory(Destination);
  RestoreToPolygon((DataType *)PCB->Data,0x10,Source,Text);
  r_delete_entry(Source->text_tree,&Text->BoundingBox);
  (Text_00->BoundingBox).X1 = (Text->BoundingBox).X1;
  (Text_00->BoundingBox).Y1 = (Text->BoundingBox).Y1;
  (Text_00->BoundingBox).X2 = (Text->BoundingBox).X2;
  (Text_00->BoundingBox).Y2 = (Text->BoundingBox).Y2;
  Text_00->ID = Text->ID;
  (Text_00->Flags).f = (Text->Flags).f;
  *(undefined4 *)(Text_00->Flags).t = *(undefined4 *)(Text->Flags).t;
  *(undefined4 *)((Text_00->Flags).t + 4) = *(undefined4 *)((Text->Flags).t + 4);
  Text_00->net = Text->net;
  Text_00->Scale = Text->Scale;
  Text_00->X = Text->X;
  Text_00->Y = Text->Y;
  uVar1 = *(undefined3 *)&Text->field_0x31;
  Text_00->Direction = Text->Direction;
  *(undefined3 *)&Text_00->field_0x31 = uVar1;
  Text_00->TextString = Text->TextString;
  Text_00->Element = Text->Element;
  pTVar7 = Source->Text;
  CVar4 = Source->TextN - 1;
  Source->TextN = CVar4;
  (Text->BoundingBox).X1 = pTVar7[CVar4].BoundingBox.X1;
  (Text->BoundingBox).Y1 = pTVar7[CVar4].BoundingBox.Y1;
  (Text->BoundingBox).X2 = pTVar7[CVar4].BoundingBox.X2;
  (Text->BoundingBox).Y2 = pTVar7[CVar4].BoundingBox.Y2;
  Text->ID = pTVar7[CVar4].ID;
  (Text->Flags).f = pTVar7[CVar4].Flags.f;
  *(undefined4 *)(Text->Flags).t = *(undefined4 *)pTVar7[CVar4].Flags.t;
  *(undefined4 *)((Text->Flags).t + 4) = *(undefined4 *)(pTVar7[CVar4].Flags.t + 4);
  Text->net = pTVar7[CVar4].net;
  Text->Scale = pTVar7[CVar4].Scale;
  Text->X = pTVar7[CVar4].X;
  Text->Y = pTVar7[CVar4].Y;
  uVar1 = *(undefined3 *)&pTVar7[CVar4].field_0x31;
  Text->Direction = pTVar7[CVar4].Direction;
  *(undefined3 *)&Text->field_0x31 = uVar1;
  Text->TextString = pTVar7[CVar4].TextString;
  Text->Element = pTVar7[CVar4].Element;
  r_substitute(Source->text_tree,&Source->Text[Source->TextN].BoundingBox,&Text->BoundingBox);
  pTVar7 = Source->Text + Source->TextN;
  uVar6 = 0x3c;
  bVar8 = ((uint)pTVar7 & 1) != 0;
  if (bVar8) {
    *(undefined *)&(pTVar7->BoundingBox).X1 = 0;
    pTVar7 = (TextTypePtr)((int)&(pTVar7->BoundingBox).X1 + 1);
    uVar6 = 0x3b;
  }
  if (((uint)pTVar7 & 2) != 0) {
    *(undefined2 *)&(pTVar7->BoundingBox).X1 = 0;
    uVar6 = uVar6 - 2;
    pTVar7 = (TextTypePtr)((int)&(pTVar7->BoundingBox).X1 + 2);
  }
  for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
    (pTVar7->BoundingBox).X1 = 0;
    pTVar7 = (TextTypePtr)((int)pTVar7 + (uint)bVar9 * -8 + 4);
  }
  if ((uVar6 & 2) != 0) {
    *(undefined2 *)&(pTVar7->BoundingBox).X1 = 0;
    pTVar7 = (TextTypePtr)((int)&(pTVar7->BoundingBox).X1 + 2);
  }
  if (bVar8) {
    *(undefined *)&(pTVar7->BoundingBox).X1 = 0;
  }
  iVar2 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar3 = GetLayerGroupNumberByPointer(Destination);
  if (iVar2 == iVar3) {
    (Text_00->Flags).f = (Text_00->Flags).f | 0x80;
  }
  else {
    (Text_00->Flags).f = (Text_00->Flags).f & 0xffffff7f;
  }
  SetTextBoundingBox(&PCB->Font,Text_00);
  rtree = Destination->text_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->text_tree = rtree;
  }
  r_insert_entry(rtree,&Text_00->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,0x10,Destination,Text_00);
  return Text_00;
}



// WARNING: Unknown calling convention

void * MoveTextToLayer(LayerTypePtr Layer,TextTypePtr Text)

{
  char cVar1;
  TextTypePtr new;
  
  if ((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) == 0) {
    if (Dest != Layer) {
      AddObjectToMoveToLayerUndoList(0x10,Layer,Text,Text);
      if (Layer->On != '\0') {
        EraseText(Layer,Text);
      }
      Text = (TextTypePtr)MoveTextToLayerLowLevel(Layer,Text,Dest);
      if (Dest->On == '\0') {
        cVar1 = Layer->On;
      }
      else {
        DrawText(Dest,Text,0);
        cVar1 = Layer->On;
      }
      if ((cVar1 != '\0') || (Dest->On != '\0')) {
        Draw();
      }
    }
  }
  else {
    Message("Sorry, the object is locked\n");
    Text = (TextTypePtr)0x0;
  }
  return Text;
}



// WARNING: Unknown calling convention

void * MoveArcToLayerLowLevel(LayerTypePtr Source,ArcTypePtr Arc,LayerTypePtr Destination)

{
  ArcTypePtr which;
  Cardinal CVar1;
  rtree_t *rtree;
  int iVar2;
  uint uVar3;
  uint uVar4;
  ArcTypePtr paVar5;
  ArcTypePtr new;
  ArcTypePtr paVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  which = GetArcMemory(Destination);
  r_delete_entry(Source->arc_tree,&Arc->BoundingBox);
  paVar5 = Arc;
  paVar6 = which;
  for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {
    (paVar6->BoundingBox).X1 = (paVar5->BoundingBox).X1;
    paVar5 = (ArcTypePtr)((int)paVar5 + (uint)bVar8 * -8 + 4);
    paVar6 = (ArcTypePtr)((int)paVar6 + (uint)bVar8 * -8 + 4);
  }
  CVar1 = Source->ArcN - 1;
  Source->ArcN = CVar1;
  paVar5 = Source->Arc + CVar1;
  paVar6 = Arc;
  for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {
    (paVar6->BoundingBox).X1 = (paVar5->BoundingBox).X1;
    paVar5 = (ArcTypePtr)((int)paVar5 + (uint)bVar8 * -8 + 4);
    paVar6 = (ArcTypePtr)((int)paVar6 + (uint)bVar8 * -8 + 4);
  }
  r_substitute(Source->arc_tree,&Source->Arc[Source->ArcN].BoundingBox,&Arc->BoundingBox);
  uVar4 = 0x44;
  paVar5 = Source->Arc + Source->ArcN;
  bVar7 = ((uint)paVar5 & 1) != 0;
  if (bVar7) {
    *(undefined *)&(paVar5->BoundingBox).X1 = 0;
    paVar5 = (ArcTypePtr)((int)&(paVar5->BoundingBox).X1 + 1);
    uVar4 = 0x43;
  }
  if (((uint)paVar5 & 2) != 0) {
    *(undefined2 *)&(paVar5->BoundingBox).X1 = 0;
    uVar4 = uVar4 - 2;
    paVar5 = (ArcTypePtr)((int)&(paVar5->BoundingBox).X1 + 2);
  }
  for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
    (paVar5->BoundingBox).X1 = 0;
    paVar5 = (ArcTypePtr)((int)paVar5 + (uint)bVar8 * -8 + 4);
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)&(paVar5->BoundingBox).X1 = 0;
    paVar5 = (ArcTypePtr)((int)&(paVar5->BoundingBox).X1 + 2);
  }
  if (bVar7) {
    *(undefined *)&(paVar5->BoundingBox).X1 = 0;
  }
  rtree = Destination->arc_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->arc_tree = rtree;
  }
  r_insert_entry(rtree,&which->BoundingBox,0);
  return which;
}



// WARNING: Unknown calling convention

void * MoveArcToLayer(LayerTypePtr Layer,ArcTypePtr Arc)

{
  ArcTypePtr Arc_00;
  ArcTypePtr new;
  
  if ((*(byte *)((int)&(Arc->Flags).f + 1) & 0x20) == 0) {
    if ((Dest == Layer) && (Dest->On != '\0')) {
      DrawArc(Dest,Arc,0);
      Draw();
    }
    if ((Dest == (LayerTypePtr)0xffffffff) || (Layer == Dest)) {
      return Arc;
    }
    AddObjectToMoveToLayerUndoList(0x4000,Layer,Arc,Arc);
    RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    if (Layer->On != '\0') {
      EraseArc(Arc);
    }
    Arc_00 = (ArcTypePtr)MoveArcToLayerLowLevel(Layer,Arc,Dest);
    ClearFromPolygon((DataType *)PCB->Data,0x4000,Dest,Arc);
    if (Dest->On != '\0') {
      DrawArc(Dest,Arc_00,0);
    }
    Draw();
  }
  else {
    Message("Sorry, the object is locked\n");
    Arc_00 = (ArcTypePtr)0x0;
  }
  return Arc_00;
}



// WARNING: Unknown calling convention

void * MoveLineToLayerLowLevel(LayerTypePtr Source,LineTypePtr Line,LayerTypePtr Destination)

{
  LineTypePtr which;
  Cardinal CVar1;
  rtree_t *rtree;
  int iVar2;
  uint uVar3;
  uint uVar4;
  LineTypePtr pLVar5;
  LineTypePtr new;
  LineTypePtr pLVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  which = GetLineMemory(Destination);
  r_delete_entry(Source->line_tree,&Line->BoundingBox);
  pLVar5 = Line;
  pLVar6 = which;
  for (iVar2 = 0x16; iVar2 != 0; iVar2 = iVar2 + -1) {
    (pLVar6->BoundingBox).X1 = (pLVar5->BoundingBox).X1;
    pLVar5 = (LineTypePtr)((int)pLVar5 + (uint)bVar8 * -8 + 4);
    pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar8 * -8 + 4);
  }
  CVar1 = Source->LineN - 1;
  Source->LineN = CVar1;
  pLVar5 = Source->Line + CVar1;
  pLVar6 = Line;
  for (iVar2 = 0x16; iVar2 != 0; iVar2 = iVar2 + -1) {
    (pLVar6->BoundingBox).X1 = (pLVar5->BoundingBox).X1;
    pLVar5 = (LineTypePtr)((int)pLVar5 + (uint)bVar8 * -8 + 4);
    pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar8 * -8 + 4);
  }
  r_substitute(Source->line_tree,&Source->Line[Source->LineN].BoundingBox,&Line->BoundingBox);
  uVar4 = 0x58;
  pLVar5 = Source->Line + Source->LineN;
  bVar7 = ((uint)pLVar5 & 1) != 0;
  if (bVar7) {
    *(undefined *)&(pLVar5->BoundingBox).X1 = 0;
    pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 1);
    uVar4 = 0x57;
  }
  if (((uint)pLVar5 & 2) != 0) {
    *(undefined2 *)&(pLVar5->BoundingBox).X1 = 0;
    uVar4 = uVar4 - 2;
    pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 2);
  }
  for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
    (pLVar5->BoundingBox).X1 = 0;
    pLVar5 = (LineTypePtr)((int)pLVar5 + (uint)bVar8 * -8 + 4);
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)&(pLVar5->BoundingBox).X1 = 0;
    pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 2);
  }
  if (bVar7) {
    *(undefined *)&(pLVar5->BoundingBox).X1 = 0;
  }
  rtree = Destination->line_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->line_tree = rtree;
  }
  r_insert_entry(rtree,&which->BoundingBox,0);
  return which;
}



// WARNING: Unknown calling convention

void * MoveLineToLayer(LayerTypePtr Layer,LineTypePtr Line)

{
  char cVar1;
  LineTypePtr Line_00;
  int iVar2;
  int iVar3;
  int iVar4;
  via_info info;
  BoxType sb;
  void *ptr3;
  void *ptr2;
  void *ptr1;
  
  if ((*(byte *)((int)&(Line->Flags).f + 1) & 0x20) == 0) {
    if ((Dest == Layer) && (Dest->On != '\0')) {
      DrawLine(Dest,Line,0);
      Draw();
    }
    if ((Dest == (LayerTypePtr)0xffffffff) || (Layer == Dest)) {
      return Line;
    }
    AddObjectToMoveToLayerUndoList(4,Layer,Line,Line);
    if (Layer->On != '\0') {
      EraseLine(Line);
    }
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    Line_00 = (LineTypePtr)MoveLineToLayerLowLevel(Layer,Line,Dest);
    ClearFromPolygon((DataType *)PCB->Data,4,Dest,Line_00);
    if (Dest->On == '\0') {
      Draw();
      cVar1 = PCB->ViaOn;
    }
    else {
      DrawLine(Dest,Line_00,0);
      Draw();
      cVar1 = PCB->ViaOn;
    }
    if ((cVar1 != '\0') && (MoreToCome == '\0')) {
      iVar2 = GetLayerGroupNumberByPointer(Layer);
      iVar3 = GetLayerGroupNumberByPointer(Dest);
      if (iVar2 != iVar3) {
        iVar2 = GetLayerNumber(PCB->Data,Layer);
        if ((iVar2 < PCB->Data->LayerN) &&
           (iVar2 = GetLayerNumber(PCB->Data,Dest), iVar2 < PCB->Data->LayerN)) {
          iVar2 = (Line_00->Point1).X;
          iVar4 = Line_00->Thickness / 2;
          sb.X1 = -iVar4 + iVar2;
          sb.X2 = iVar4 + iVar2;
          iVar3 = (Line_00->Point1).Y;
          sb.Y1 = -iVar4 + iVar3;
          sb.Y2 = iVar4 + iVar3;
          iVar2 = SearchObjectByLocation
                            (0x101,&ptr1,&ptr2,&ptr3,iVar2,iVar3,Settings.ViaThickness / 2);
          if (iVar2 == 0) {
            info.X = (Line_00->Point1).X;
            info.Y = (Line_00->Point1).Y;
            iVar2 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar2 == 0) {
              r_search(Layer->line_tree,&sb,(_func_int_BoxType_ptr_void_ptr *)0x0,moveline_callback,
                       &info);
            }
          }
          iVar2 = (Line_00->Point2).X;
          iVar4 = Line_00->Thickness / 2;
          sb.X1 = -iVar4 + iVar2;
          sb.X2 = iVar4 + iVar2;
          iVar3 = (Line_00->Point2).Y;
          sb.Y1 = -iVar4 + iVar3;
          sb.Y2 = iVar4 + iVar3;
          iVar2 = SearchObjectByLocation
                            (0x101,&ptr1,&ptr2,&ptr3,iVar2,iVar3,Settings.ViaThickness / 2);
          if (iVar2 == 0) {
            info.X = (Line_00->Point2).X;
            info.Y = (Line_00->Point2).Y;
            iVar2 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar2 == 0) {
              r_search(Layer->line_tree,&sb,(_func_int_BoxType_ptr_void_ptr *)0x0,moveline_callback,
                       &info);
            }
          }
          Draw();
        }
      }
    }
  }
  else {
    Message("Sorry, the object is locked\n");
    Line_00 = (LineTypePtr)0x0;
  }
  return Line_00;
}



// WARNING: Unknown calling convention

void MoveElementLowLevel(DataTypePtr Data,ElementTypePtr Element,LocationType DX,LocationType DY)

{
  LocationType *pLVar1;
  LineTypePtr line;
  LineTypePtr Line;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar2;
  Cardinal n_2;
  Cardinal n;
  Cardinal n_1;
  ArcTypePtr paVar3;
  Cardinal n_3;
  int iVar4;
  PinTypePtr pin;
  PadTypePtr pad;
  PadTypePtr Pad;
  ElementTypePtr paVar5;
  int iVar6;
  uint uVar7;
  uint local_28;
  uint local_24;
  
  if (Data != (DataTypePtr)0x0) {
    r_delete_entry(Data->element_tree,&Element->BoundingBox);
  }
  iVar6 = Element->LineN - 1;
  if (iVar6 != -1) {
    iVar4 = Element->LineN * 0x58;
    do {
      iVar6 = iVar6 + -1;
      Line = (LineTypePtr)(Element->Line[-1].Flags.t + iVar4 + -0x18);
      pLVar1 = &(Line->Point1).Y;
      *pLVar1 = *pLVar1 + DY;
      pLVar1 = &(Line->Point2).Y;
      *pLVar1 = *pLVar1 + DY;
      (Line->Point1).X = (Line->Point1).X + DX;
      (Line->Point2).X = (Line->Point2).X + DX;
      SetLineBoundingBox(Line);
      iVar4 = iVar4 + -0x58;
    } while (iVar6 != -1);
  }
  if (Element->PinN != 0) {
    uVar7 = 0;
    local_24 = Element->PinN;
    do {
      pin = Element->Pin + uVar7;
      if (Data != (DataTypePtr)0x0) {
        r_delete_entry(Data->pin_tree,&pin->BoundingBox);
        RestoreToPolygon((DataType *)Data,0x100,Element,pin);
      }
      pin->X = pin->X + DX;
      pin->Y = pin->Y + DY;
      (pin->BoundingBox).X1 = (pin->BoundingBox).X1 + DX;
      pLVar1 = &(pin->BoundingBox).Y1;
      *pLVar1 = *pLVar1 + DY;
      pLVar1 = &(pin->BoundingBox).X2;
      *pLVar1 = *pLVar1 + DX;
      pLVar1 = &(pin->BoundingBox).Y2;
      *pLVar1 = *pLVar1 + DY;
      if (Data != (DataTypePtr)0x0) {
        r_insert_entry(Data->pin_tree,&pin->BoundingBox,0);
        ClearFromPolygon((DataType *)Data,0x100,Element,pin);
      }
      uVar2 = Element->PinN;
    } while ((uVar2 != 0) &&
            (uVar7 = (uVar2 + 1 + uVar7) - local_24, local_24 = uVar2, uVar7 < uVar2));
  }
  uVar7 = Element->PadN;
  local_28 = 0;
  uVar2 = uVar7;
LAB_080a86a3:
  do {
    if ((uVar2 == 0) || (uVar2 <= local_28)) {
      iVar6 = Element->ArcN - 1;
      if (iVar6 != -1) {
        paVar3 = Element->Arc + (Element->ArcN - 1);
        do {
          iVar6 = iVar6 + -1;
          paVar3->X = paVar3->X + DX;
          paVar3->Y = paVar3->Y + DY;
          (paVar3->BoundingBox).X1 = (paVar3->BoundingBox).X1 + DX;
          pLVar1 = &(paVar3->BoundingBox).Y1;
          *pLVar1 = *pLVar1 + DY;
          pLVar1 = &(paVar3->BoundingBox).X2;
          *pLVar1 = *pLVar1 + DX;
          pLVar1 = &(paVar3->BoundingBox).Y2;
          *pLVar1 = *pLVar1 + DY;
          paVar3 = paVar3 + -1;
        } while (iVar6 != -1);
      }
      iVar6 = 2;
      paVar5 = Element;
      do {
        if ((Data != (DataTypePtr)0x0) && (Data->name_tree[iVar6] != (rtree_t *)0x0)) {
          r_delete_entry(PCB->Data->name_tree[iVar6],(BoxType *)(Element->Name + iVar6));
        }
        paVar5->Name[2].BoundingBox.X1 = paVar5->Name[2].BoundingBox.X1 + DX;
        pLVar1 = &paVar5->Name[2].BoundingBox.Y1;
        *pLVar1 = *pLVar1 + DY;
        pLVar1 = &paVar5->Name[2].BoundingBox.X2;
        *pLVar1 = *pLVar1 + DX;
        pLVar1 = &paVar5->Name[2].BoundingBox.Y2;
        *pLVar1 = *pLVar1 + DY;
        pLVar1 = &paVar5->Name[2].X;
        *pLVar1 = *pLVar1 + DX;
        pLVar1 = &paVar5->Name[2].Y;
        *pLVar1 = *pLVar1 + DY;
        if ((Data != (DataTypePtr)0x0) && (Data->name_tree[iVar6] != (rtree_t *)0x0)) {
          r_insert_entry(PCB->Data->name_tree[iVar6],(BoxType *)(Element->Name + iVar6),0);
        }
        iVar6 = iVar6 + -1;
        paVar5 = (ElementTypePtr)&paVar5[-1].LineN;
      } while (iVar6 != -1);
      pLVar1 = &(Element->BoundingBox).Y1;
      *pLVar1 = *pLVar1 + DY;
      pLVar1 = &(Element->BoundingBox).Y2;
      *pLVar1 = *pLVar1 + DY;
      pLVar1 = &(Element->VBox).Y1;
      *pLVar1 = *pLVar1 + DY;
      pLVar1 = &(Element->VBox).Y2;
      *pLVar1 = *pLVar1 + DY;
      Element->MarkY = Element->MarkY + DY;
      (Element->BoundingBox).X1 = (Element->BoundingBox).X1 + DX;
      pLVar1 = &(Element->BoundingBox).X2;
      *pLVar1 = *pLVar1 + DX;
      (Element->VBox).X1 = (Element->VBox).X1 + DX;
      pLVar1 = &(Element->VBox).X2;
      *pLVar1 = *pLVar1 + DX;
      Element->MarkX = Element->MarkX + DX;
      if (Data != (DataTypePtr)0x0) {
        r_insert_entry(Data->element_tree,&Element->BoundingBox,0);
        return;
      }
      return;
    }
    Pad = Element->Pad + local_28;
    if (Data != (DataTypePtr)0x0) goto LAB_080a8628;
    (Pad->Point1).X = (Pad->Point1).X + DX;
    (Pad->Point2).X = (Pad->Point2).X + DX;
    pLVar1 = &(Pad->Point1).Y;
    *pLVar1 = *pLVar1 + DY;
    pLVar1 = &(Pad->Point2).Y;
    *pLVar1 = *pLVar1 + DY;
    SetPadBoundingBox(Pad);
    uVar2 = Element->PadN;
  } while (Element->PadN != uVar7);
  goto LAB_080a86e2;
LAB_080a8628:
  r_delete_entry(Data->pad_tree,&Pad->BoundingBox);
  RestoreToPolygon((DataType *)Data,0x200,Element,Pad);
  (Pad->Point1).X = (Pad->Point1).X + DX;
  pLVar1 = &(Pad->Point1).Y;
  *pLVar1 = *pLVar1 + DY;
  (Pad->Point2).X = (Pad->Point2).X + DX;
  pLVar1 = &(Pad->Point2).Y;
  *pLVar1 = *pLVar1 + DY;
  SetPadBoundingBox(Pad);
  r_insert_entry(Data->pad_tree,&Pad->BoundingBox,0);
  ClearFromPolygon((DataType *)Data,0x200,Element,Pad);
  uVar2 = Element->PadN;
  if (Element->PadN == uVar7) {
LAB_080a86e2:
    local_28 = local_28 + 1;
    uVar2 = uVar7;
  }
  goto LAB_080a86a3;
}



// WARNING: Unknown calling convention

void * MoveElement(ElementTypePtr Element)

{
  char cVar1;
  bool bVar2;
  Boolean didDraw;
  
  if ((PCB->ElementOn == '\0') ||
     ((((Element->Flags).f >> 7 & 1) != (int)Settings.ShowSolderSide &&
      (PCB->InvisibleObjectsOn == '\0')))) {
    if (PCB->PinOn != '\0') {
      EraseElementPinsAndPads(Element);
    }
    MoveElementLowLevel(PCB->Data,Element,DeltaX,DeltaY);
    bVar2 = false;
    cVar1 = PCB->PinOn;
  }
  else {
    EraseElement(Element);
    MoveElementLowLevel(PCB->Data,Element,DeltaX,DeltaY);
    DrawElementName(Element,0);
    DrawElementPackage(Element,0);
    bVar2 = true;
    cVar1 = PCB->PinOn;
  }
  if (cVar1 == '\0') {
    if (!bVar2) {
      return Element;
    }
  }
  else {
    DrawElementPinsAndPads(Element,0);
  }
  Draw();
  return Element;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int MoveLayer(int old_index,int new_index)

{
  uint uVar1;
  ElementTypePtr paVar2;
  char **ppcVar3;
  Cardinal *pCVar4;
  int iVar5;
  int l;
  Cardinal CVar6;
  int iVar7;
  char *pcVar8;
  Cardinal CVar9;
  PCBTypePtr pPVar10;
  int *piVar11;
  uint uVar12;
  Cardinal (*paCVar13) [18];
  uint uVar14;
  DataTypePtr paVar15;
  Cardinal n;
  int g;
  Cardinal n_1;
  ElementTypePtr element;
  Cardinal sn_1;
  Cardinal sn;
  int iVar16;
  LayerType *pLVar17;
  LayerType *pLVar18;
  bool bVar19;
  byte bVar20;
  int local_d8;
  int local_d4;
  LayerType saved_layer;
  int groups [18];
  
  bVar20 = 0;
  AddLayerChangeToUndoList(old_index,new_index);
  IncrementUndoSerialNumber();
  if (old_index < -1) {
    local_d4 = PCB->Data->LayerN;
  }
  else {
    paVar15 = PCB->Data;
    local_d4 = paVar15->LayerN;
    if (old_index < local_d4) {
      if (((new_index < -1) || (0xf < new_index)) || (local_d4 < new_index)) {
        Message("Invalid new layer %d for move: must be -1..%d\n",new_index,local_d4);
        iVar5 = 1;
      }
      else {
        iVar5 = 0;
        if (old_index != new_index) {
          iVar5 = 0;
          do {
            CVar9 = (PCB->LayerGroups).Number[iVar5];
            if (CVar9 != 0) {
              paCVar13 = (PCB->LayerGroups).Entries[iVar5];
              CVar6 = 0;
              do {
                pCVar4 = *paCVar13;
                CVar6 = CVar6 + 1;
                paCVar13 = (Cardinal (*) [18])(*paCVar13 + 1);
                groups[*pCVar4] = iVar5;
              } while (CVar6 != CVar9);
            }
            iVar5 = iVar5 + 1;
          } while (iVar5 != 0x10);
          if (old_index == -1) {
            if (local_d4 == 0x10) {
              Message("No room for new layers\n");
              return 1;
            }
            memmove(paVar15->Layer + new_index + 1,paVar15->Layer + new_index,
                    ((local_d4 + 2) - new_index) * 0x5c);
            memmove(groups + new_index + 1,groups + new_index,
                    (PCB->Data->LayerN - new_index) * 4 + 8);
            piVar11 = &PCB->Data->LayerN;
            *piVar11 = *piVar11 + 1;
            pLVar18 = paVar15->Layer + new_index;
            for (iVar5 = 0x17; iVar5 != 0; iVar5 = iVar5 + -1) {
              pLVar18->Name = (char *)0x0;
              pLVar18 = (LayerType *)((int)pLVar18 + (uint)bVar20 * -8 + 4);
            }
            paVar15->Layer[new_index].On = '\x01';
            pcVar8 = MyStrdup("New Layer","MoveLayer");
            paVar15->Layer[new_index].Name = pcVar8;
            paVar15->Layer[new_index].Color = Settings.LayerColor[new_index];
            paVar15->Layer[new_index].SelectedColor = Settings.LayerSelectedColor[new_index];
            pPVar10 = PCB;
            paVar15 = PCB->Data;
            iVar5 = paVar15->LayerN;
            if (0 < iVar5) {
              iVar7 = 0;
              do {
                if (new_index <= LayerStack[iVar7]) {
                  LayerStack[iVar7] = LayerStack[iVar7] + 1;
                }
                iVar7 = iVar7 + 1;
              } while (iVar7 != iVar5);
            }
            (&DAT_0819587c)[iVar5] = new_index;
          }
          else {
            if (new_index == -1) {
              memmove(paVar15->Layer + old_index,paVar15->Layer + old_index + 1,
                      ((local_d4 + 1) - old_index) * 0x5c);
              pLVar18 = PCB->Data->Layer + PCB->Data->LayerN + 1;
              bVar19 = ((uint)pLVar18 & 1) != 0;
              uVar14 = 0x5c;
              pLVar17 = pLVar18;
              if (bVar19) {
                pLVar17 = (LayerType *)((int)pLVar18 + (uint)bVar20 * -2 + 1);
                *(undefined *)&pLVar18->Name = 0;
                uVar14 = 0x5b;
              }
              pLVar18 = pLVar17;
              if (((uint)pLVar17 & 2) != 0) {
                pLVar18 = (LayerType *)((int)pLVar17 + (uint)bVar20 * -4 + 2);
                *(undefined2 *)&pLVar17->Name = 0;
                uVar14 = uVar14 - 2;
              }
              for (uVar12 = uVar14 >> 2; uVar12 != 0; uVar12 = uVar12 - 1) {
                pLVar18->Name = (char *)0x0;
                pLVar18 = (LayerType *)((int)pLVar18 + (uint)bVar20 * -8 + 4);
              }
              pLVar17 = pLVar18;
              if ((uVar14 & 2) != 0) {
                pLVar17 = (LayerType *)((int)pLVar18 + (uint)bVar20 * -4 + 2);
                *(undefined2 *)&pLVar18->Name = 0;
              }
              if (bVar19) {
                *(undefined *)&pLVar17->Name = 0;
              }
              memmove(groups + old_index,groups + old_index + 1,
                      (PCB->Data->LayerN - old_index) * 4 + 4);
              paVar15 = PCB->Data;
              iVar5 = paVar15->LayerN;
              pPVar10 = PCB;
              if (0 < iVar5) {
                iVar7 = 0;
                piVar11 = LayerStack;
                do {
                  if (*piVar11 == old_index) {
                    memmove(piVar11,piVar11 + 1,((iVar5 + -1) - iVar7) * 4);
                    pPVar10 = PCB;
                  }
                  paVar15 = pPVar10->Data;
                  iVar7 = iVar7 + 1;
                  iVar5 = paVar15->LayerN;
                  piVar11 = piVar11 + 1;
                } while (iVar7 < iVar5);
              }
              iVar5 = iVar5 + -1;
              iVar7 = 0;
              paVar15->LayerN = iVar5;
              if (0 < iVar5) {
                do {
                  if (old_index < LayerStack[iVar7]) {
                    LayerStack[iVar7] = LayerStack[iVar7] + -1;
                  }
                  iVar7 = iVar7 + 1;
                } while (iVar7 != iVar5);
              }
            }
            else {
              pLVar18 = paVar15->Layer + old_index;
              pLVar17 = &saved_layer;
              for (iVar5 = 0x17; iVar5 != 0; iVar5 = iVar5 + -1) {
                pLVar17->Name = pLVar18->Name;
                pLVar18 = (LayerType *)((int)pLVar18 + ((uint)bVar20 * -2 + 1) * 4);
                pLVar17 = (LayerType *)((int)pLVar17 + (uint)bVar20 * -8 + 4);
              }
              iVar5 = groups[old_index];
              if (old_index < new_index) {
                memmove(PCB->Data->Layer + old_index,PCB->Data->Layer + old_index + 1,
                        (new_index - old_index) * 0x5c);
                memmove(groups + old_index,groups + old_index + 1,(new_index - old_index) * 4);
              }
              else {
                memmove(PCB->Data->Layer + new_index + 1,PCB->Data->Layer + new_index,
                        (old_index - new_index) * 0x5c);
                memmove(groups + new_index + 1,groups + new_index,(old_index - new_index) * 4);
              }
              pLVar18 = &saved_layer;
              uVar14 = 0x5c;
              pLVar17 = PCB->Data->Layer + new_index;
              bVar19 = ((uint)pLVar17 & 1) != 0;
              if (bVar19) {
                pLVar18 = (LayerType *)((int)&saved_layer.Name + 1);
                uVar14 = 0x5b;
                *(undefined *)&pLVar17->Name = saved_layer.Name._0_1_;
                pLVar17 = (LayerType *)((int)&pLVar17->Name + 1);
              }
              if (((uint)pLVar17 & 2) != 0) {
                ppcVar3 = &pLVar18->Name;
                uVar14 = uVar14 - 2;
                pLVar18 = (LayerType *)((int)&pLVar18->Name + 2);
                *(undefined2 *)&pLVar17->Name = *(undefined2 *)ppcVar3;
                pLVar17 = (LayerType *)((int)&pLVar17->Name + 2);
              }
              iVar7 = 0;
              for (uVar12 = uVar14 >> 2; uVar12 != 0; uVar12 = uVar12 - 1) {
                pLVar17->Name = pLVar18->Name;
                pLVar18 = (LayerType *)((int)pLVar18 + (uint)bVar20 * -8 + 4);
                pLVar17 = (LayerType *)((int)pLVar17 + ((uint)bVar20 * -2 + 1) * 4);
              }
              if ((uVar14 & 2) != 0) {
                *(undefined2 *)&pLVar17->Name = *(undefined2 *)&pLVar18->Name;
                iVar7 = 2;
              }
              if (bVar19) {
                *(undefined *)((int)&pLVar17->Name + iVar7) =
                     *(undefined *)((int)&pLVar18->Name + iVar7);
              }
              groups[new_index] = iVar5;
              pPVar10 = PCB;
            }
            paVar15 = pPVar10->Data;
          }
          if (paVar15->ViaN != 0) {
            uVar12 = 0;
            uVar14 = paVar15->ViaN;
            do {
              move_one_thermal(old_index,new_index,(PinType *)(paVar15->Via + uVar12));
              paVar15 = PCB->Data;
              uVar1 = paVar15->ViaN;
              pPVar10 = PCB;
              if (uVar1 == 0) break;
              uVar12 = (uVar1 + 1 + uVar12) - uVar14;
              uVar14 = uVar1;
            } while (uVar12 < uVar1);
          }
          local_d4 = paVar15->ElementN - 1;
          if (local_d4 != -1) {
            iVar5 = paVar15->ElementN * 300;
            do {
              local_d8 = iVar5 + -300;
              paVar2 = paVar15->Element;
              uVar14 = *(uint *)((int)&paVar2[-1].PinN + iVar5);
              if (uVar14 != 0) {
                uVar12 = 0;
                do {
                  move_one_thermal(old_index,new_index,
                                   (PinType *)
                                   (uVar12 * 0x4c + *(int *)((int)&paVar2[-1].Pin + iVar5)));
                  uVar1 = *(uint *)((int)&paVar2[-1].PinN + iVar5);
                  pPVar10 = PCB;
                  if (uVar1 == 0) break;
                  uVar12 = (uVar1 + 1 + uVar12) - uVar14;
                  uVar14 = uVar1;
                } while (uVar12 < uVar1);
              }
              local_d4 = local_d4 + -1;
              if (local_d4 == -1) goto LAB_080a8dc3;
              paVar15 = pPVar10->Data;
              iVar5 = local_d8;
            } while( true );
          }
          goto LAB_080a8dc9;
        }
      }
      return iVar5;
    }
  }
  Message("Invalid old layer %d for move: must be -1..%d\n",old_index,local_d4 + -1);
  return 1;
LAB_080a8dc3:
  paVar15 = pPVar10->Data;
LAB_080a8dc9:
  iVar5 = 0;
  do {
    (pPVar10->LayerGroups).Number[iVar5] = 0;
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x10);
  if (-2 < paVar15->LayerN) {
    CVar9 = 0;
    do {
      iVar5 = groups[CVar9];
      CVar6 = (pPVar10->LayerGroups).Number[iVar5];
      (pPVar10->LayerGroups).Entries[iVar5][CVar6] = CVar9;
      CVar9 = CVar9 + 1;
      (pPVar10->LayerGroups).Number[iVar5] = CVar6 + 1;
    } while ((int)CVar9 <= paVar15->LayerN + 1);
  }
  iVar16 = 4;
  iVar7 = 0;
  iVar5 = 0;
  while( true ) {
    if ((pPVar10->LayerGroups).Number[iVar7] == 0) {
      memmove((pPVar10->LayerGroups).Number + iVar7,
              (void *)((int)(pPVar10->LayerGroups).Number + iVar16),0x40 - iVar16);
      memmove((void *)((int)(PCB->LayerGroups).Entries + iVar5),
              (void *)((int)(PCB->LayerGroups).Entries[1] + iVar5),0x438 - iVar5);
    }
    pPVar10 = PCB;
    PCB = pPVar10;
    if (iVar7 == 0xf) break;
    iVar16 = iVar16 + 4;
    iVar7 = iVar7 + 1;
    iVar5 = iVar5 + 0x48;
  }
  hid_action("LayersChanged");
  (*gui->invalidate_all)();
  return 0;
}



// WARNING: Unknown calling convention

int MoveLayerAction(int argc,char **argv,int x,int y)

{
  char *pcVar1;
  int iVar2;
  int old_index_00;
  DataTypePtr paVar3;
  int iVar4;
  int old_index;
  int new_index;
  char *pcVar5;
  int new_top;
  char *pcVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  if (argc != 2) {
    Message("Usage; MoveLayer(old,new)");
    return 1;
  }
  pcVar1 = *argv;
  if ((*pcVar1 == 'c') && (pcVar1[1] == '\0')) {
    old_index_00 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      old_index_00 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
  }
  else {
    old_index_00 = strtol(pcVar1,(char **)0x0,10);
  }
  pcVar1 = argv[1];
  if ((*pcVar1 == 'c') && (pcVar1[1] == '\0')) {
    new_index = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      new_index = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    if (new_index < 0) {
      new_index = 0;
    }
LAB_080a91c3:
    iVar4 = -1;
    iVar2 = MoveLayer(old_index_00,new_index);
  }
  else {
    bVar7 = *pcVar1 == 'u';
    if ((bVar7) && ((bVar7 = pcVar1[1] == 'p', bVar7 && (bVar7 = pcVar1[2] == '\0', bVar7)))) {
      if (PCB->SilkActive == '\0') {
        new_index = LayerStack[0] + -1;
      }
      else {
        new_index = PCB->Data->LayerN + -1 + (uint)(Settings.ShowSolderSide == '\0');
      }
      if (new_index < 0) {
        return 1;
      }
    }
    else {
      iVar4 = 5;
      pcVar5 = pcVar1;
      pcVar6 = "down";
      do {
        if (iVar4 == 0) break;
        iVar4 = iVar4 + -1;
        bVar7 = *pcVar5 == *pcVar6;
        pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
        pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
      } while (bVar7);
      if (!bVar7) {
        new_index = strtol(pcVar1,(char **)0x0,10);
        goto LAB_080a91c3;
      }
      if (PCB->SilkActive == '\0') {
        paVar3 = PCB->Data;
        new_index = LayerStack[0] + 1;
      }
      else {
        paVar3 = PCB->Data;
        new_index = paVar3->LayerN + 1 + (uint)(Settings.ShowSolderSide == '\0');
      }
      if (paVar3->LayerN <= new_index) {
        return 1;
      }
    }
    iVar2 = MoveLayer(old_index_00,new_index);
    iVar4 = new_index;
  }
  if (iVar2 != 0) {
    return 1;
  }
  if ((new_index == -1) &&
     (new_index = old_index_00, iVar4 = old_index_00, PCB->Data->LayerN <= old_index_00)) {
    new_index = old_index_00 + -1;
    iVar4 = new_index;
  }
  if (old_index_00 == -1) {
    iVar4 = new_index;
  }
  if (iVar4 != -1) {
    ChangeGroupVisibility(new_index,'\x01','\x01');
    return 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

rtree_t * which_tree(mtspace_t *mtspace,mtspace_type_t which)

{
  if (which == FIXED) {
    return mtspace->ftree;
  }
  if (which != EVEN) {
    return mtspace->otree;
  }
  return mtspace->etree;
}



// WARNING: Unknown calling convention

int mtsBoxCount(vetting_t *w)

{
  return 100;
}



// WARNING: Unknown calling convention

mtspacebox_t * mtspace_create_box(BoxType *box,BDimension keepaway)

{
  mtspacebox_t *pmVar1;
  
  pmVar1 = (mtspacebox_t *)malloc(0x14);
  (pmVar1->box).X1 = box->X1;
  (pmVar1->box).Y1 = box->Y1;
  (pmVar1->box).X2 = box->X2;
  (pmVar1->box).Y2 = box->Y2;
  pmVar1->keepaway = keepaway;
  return pmVar1;
}



// WARNING: Unknown calling convention

void append(query_closure *qc,BoxType *new)

{
  if (qc->desired != (CheapPointType *)0x0) {
    heap_insert((qc->checking).h,0.0,new);
    return;
  }
  vector_append((qc->checking).v,new);
  return;
}



void __regparm3 qloop(query_closure *qc,rtree_t *tree,heap_or_vector res,Boolean is_vec)

{
  BoxType *query;
  int iVar1;
  
  do {
    if (qc->desired == (CheapPointType *)0x0) {
      iVar1 = vector_is_empty((qc->checking).v);
    }
    else {
      iVar1 = heap_is_empty((qc->checking).h);
    }
    if (iVar1 != 0) {
      return;
    }
    if (qc->desired == (CheapPointType *)0x0) {
      query = (BoxType *)vector_remove_last((qc->checking).v);
      iVar1 = _setjmp((__jmp_buf_tag *)qc->env);
    }
    else {
      query = (BoxType *)heap_remove_smallest((qc->checking).h);
      iVar1 = _setjmp((__jmp_buf_tag *)qc->env);
    }
  } while (iVar1 != 0);
  qc->cbox = query;
  r_search(tree,query,(_func_int_BoxType_ptr_void_ptr *)0x0,query_one,qc);
  if (is_vec != '\0') {
    vector_append(res.v,query);
    return;
  }
  if (qc->desired == (CheapPointType *)0x0) {
    vector_append(res.v,query);
    return;
  }
  heap_insert(res.h,0.0,query);
  return;
}



// WARNING: Unknown calling convention

void mtspace_remove(mtspace_t *mtspace,BoxType *box,mtspace_type_t which,BDimension keepaway)

{
  int iVar1;
  mts_info cl;
  BoxType small_search;
  
  cl.keepaway = keepaway;
  cl.box.X1 = box->X1;
  cl.box.Y1 = box->Y1;
  cl.box.X2 = box->X2;
  cl.box.Y2 = box->Y2;
  if (which == FIXED) {
    cl.tree = mtspace->ftree;
  }
  else if (which == EVEN) {
    cl.tree = mtspace->etree;
  }
  else {
    cl.tree = mtspace->otree;
  }
  small_search.X1 = (box->X2 - box->X1) / 2 + box->X1;
  small_search.X2 = small_search.X1 + 1;
  small_search.Y1 = (box->Y2 - box->Y1) / 2 + box->Y1;
  small_search.Y2 = small_search.Y1 + 1;
  iVar1 = _setjmp((__jmp_buf_tag *)cl.env);
  if (iVar1 == 0) {
    r_search(cl.tree,&small_search,(_func_int_BoxType_ptr_void_ptr *)0x0,mts_remove_one,&cl);
  }
  return;
}



// WARNING: Unknown calling convention

int query_one(BoxType *box,void *cl)

{
  LocationType LVar1;
  LocationType *pLVar2;
  heap_t *heap;
  BoxType *pBVar3;
  int *__ptr;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int X1;
  BDimension shrink;
  int local_40;
  int local_30;
  int local_28;
  
                    // WARNING: Load size is inaccurate
  __ptr = *cl;
  iVar7 = *(int *)((int)cl + 0x14);
  iVar6 = iVar7;
  if (box[1].X1 == iVar7 || box[1].X1 < iVar7) {
    iVar6 = box[1].X1;
  }
  if ((*__ptr + iVar6 < box->X2) && (box->X1 < __ptr[2] - iVar6)) {
    iVar5 = __ptr[1];
    local_40 = box->Y2;
    if (iVar5 + iVar6 < local_40) {
      local_28 = __ptr[3];
      local_30 = local_28 - iVar6;
      iVar8 = box->Y1;
      if (iVar8 < local_30) {
        if ((iVar5 + iVar6 < iVar8) &&
           (iVar7 = iVar7 + *(int *)((int)cl + 0x10), iVar4 = (iVar8 + iVar6) - iVar5,
           SBORROW4(iVar4,iVar7 * 2) == iVar4 + iVar7 * -2 < 0)) {
          pBVar3 = (BoxType *)malloc(0x10);
                    // WARNING: Load size is inaccurate
          LVar1 = (*cl)[2];
          pBVar3->X1 = **cl;
          pBVar3->X2 = LVar1;
          pBVar3->Y2 = iVar8 + iVar6;
          pBVar3->Y1 = iVar5;
          append((query_closure *)cl,pBVar3);
          local_40 = box->Y2;
                    // WARNING: Load size is inaccurate
          __ptr = *cl;
          local_28 = __ptr[3];
          local_30 = local_28 - iVar6;
        }
        if ((local_40 < local_30) &&
           (local_28 = local_28 - (local_40 - iVar6),
           iVar7 = *(int *)((int)cl + 0x14) + *(int *)((int)cl + 0x10),
           SBORROW4(local_28,iVar7 * 2) == local_28 + iVar7 * -2 < 0)) {
          pBVar3 = (BoxType *)malloc(0x10);
                    // WARNING: Load size is inaccurate
          pLVar2 = *cl;
          pBVar3->X1 = *pLVar2;
          LVar1 = pLVar2[3];
          pBVar3->X2 = pLVar2[2];
          pBVar3->Y2 = LVar1;
          pBVar3->Y1 = local_40 - iVar6;
          append((query_closure *)cl,pBVar3);
                    // WARNING: Load size is inaccurate
          __ptr = *cl;
        }
        if ((iVar6 + *__ptr < box->X1) &&
           (iVar7 = box->X1 + iVar6, iVar5 = iVar7 - *__ptr,
           iVar8 = *(int *)((int)cl + 0x14) + *(int *)((int)cl + 0x10),
           SBORROW4(iVar5,iVar8 * 2) == iVar5 + iVar8 * -2 < 0)) {
          pBVar3 = (BoxType *)malloc(0x10);
                    // WARNING: Load size is inaccurate
          pLVar2 = *cl;
          pBVar3->Y1 = pLVar2[1];
          LVar1 = *pLVar2;
          pBVar3->Y2 = pLVar2[3];
          pBVar3->X1 = LVar1;
          pBVar3->X2 = iVar7;
          append((query_closure *)cl,pBVar3);
                    // WARNING: Load size is inaccurate
          __ptr = *cl;
        }
        if ((box->X2 < __ptr[2] - iVar6) &&
           (iVar6 = box->X2 - iVar6, iVar5 = *(int *)((int)cl + 0x14) + *(int *)((int)cl + 0x10),
           iVar7 = __ptr[2] - iVar6, SBORROW4(iVar7,iVar5 * 2) == iVar7 + iVar5 * -2 < 0)) {
          pBVar3 = (BoxType *)malloc(0x10);
                    // WARNING: Load size is inaccurate
          iVar7 = *cl;
          LVar1 = *(LocationType *)(iVar7 + 4);
          pBVar3->X1 = iVar6;
          pBVar3->Y1 = LVar1;
          LVar1 = *(LocationType *)(iVar7 + 8);
          pBVar3->Y2 = *(LocationType *)(iVar7 + 0xc);
          pBVar3->X2 = LVar1;
          append((query_closure *)cl,pBVar3);
                    // WARNING: Load size is inaccurate
          __ptr = *cl;
        }
        heap = *(heap_t **)((int)cl + 8);
        if (heap == (heap_t *)0x0) {
          free(__ptr);
        }
        else if ((*(char *)((int)cl + 0xb4) == '\0') && (*(int *)((int)cl + 0xc) != 0)) {
          heap_insert(heap,0.0,__ptr);
        }
        else {
          vector_append((vector_t *)heap,__ptr);
        }
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x18,1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void mtsFreeWork(vetting_t **w)

{
  vetting_t *heap;
  int iVar1;
  vector_element_t pvVar2;
  vetting_t *work;
  
  heap = *w;
  if (((heap->desired).X == -0xc8f75) && ((heap->desired).Y == -0xc8f75)) {
    while( true ) {
      iVar1 = vector_is_empty((vector_t *)(heap->untested).v);
      if (iVar1 != 0) break;
      pvVar2 = vector_remove_last((vector_t *)(heap->untested).v);
      free(pvVar2);
    }
    vector_destroy((vector_t **)heap);
    while( true ) {
      iVar1 = vector_is_empty((heap->no_fix).v);
      if (iVar1 != 0) break;
      pvVar2 = vector_remove_last((heap->no_fix).v);
      free(pvVar2);
    }
    vector_destroy(&(heap->no_fix).v);
    while( true ) {
      iVar1 = vector_is_empty((heap->no_hi).v);
      if (iVar1 != 0) break;
      pvVar2 = vector_remove_last((heap->no_hi).v);
      free(pvVar2);
    }
    vector_destroy(&(heap->no_hi).v);
    while( true ) {
      iVar1 = vector_is_empty((heap->hi_candidate).v);
      if (iVar1 != 0) break;
      pvVar2 = vector_remove_last((heap->hi_candidate).v);
      free(pvVar2);
    }
    vector_destroy(&(heap->hi_candidate).v);
  }
  else {
    heap_free((heap->untested).h,free);
    heap_destroy((heap_t **)heap);
    heap_free((heap->no_fix).h,free);
    heap_destroy(&(heap->no_fix).h);
    heap_free((heap->no_hi).h,free);
    heap_destroy(&(heap->no_hi).h);
    heap_free((heap->hi_candidate).h,free);
    heap_destroy(&(heap->hi_candidate).h);
  }
  free(heap);
  *w = (vetting_t *)0x0;
  return;
}



// WARNING: Unknown calling convention

vetting_t *
mtspace_query_rect(mtspace_t *mtspace,BoxType *region,BDimension radius,BDimension keepaway,
                  vetting_t *work,vector_t *free_space_vec,vector_t *lo_conflict_space_vec,
                  vector_t *hi_conflict_space_vec,Boolean is_odd,Boolean with_conflicts,
                  CheapPointType *desired)

{
  int iVar1;
  int iVar2;
  LocationType LVar3;
  vetting_t *pvVar4;
  vetting_t *pvVar5;
  Boolean BVar6;
  Boolean BVar7;
  int *data;
  int iVar8;
  heap_t *phVar9;
  int iVar10;
  vector_t *pvVar11;
  rtree_t *prVar12;
  heap_or_vector local_f0;
  query_closure *local_e0;
  query_closure qc;
  
  BVar7 = with_conflicts;
  BVar6 = is_odd;
  if (region == (BoxType *)0x0) {
    qc.keepaway = work->keepaway;
    qc.radius = work->radius;
    if (((work->desired).X == -0xc8f75) && ((work->desired).Y == -0xc8f75)) {
      qc.desired = (CheapPointType *)0x0;
    }
    else {
      qc.desired = &work->desired;
    }
    do {
      local_e0 = &qc;
      qc.checking = work->untested;
      qc.touching.v = (vector_t *)0x0;
      qloop(local_e0,mtspace->ftree,work->no_fix,'\0');
      qc.checking = work->no_fix;
      local_f0.v = (vector_t *)0x0;
      if (BVar7 != '\0') {
        local_f0 = work->hi_candidate;
      }
      if (BVar6 == '\0') {
        prVar12 = mtspace->etree;
      }
      else {
        prVar12 = mtspace->otree;
      }
      qc.touch_is_vec = '\0';
      qc.touching.v = local_f0.v;
      qloop(local_e0,prVar12,work->no_hi,'\0');
      qc.checking = work->no_hi;
      qc.touching.v = (vector_t *)0x0;
      if (BVar7 != '\0') {
        qc.touching.v = lo_conflict_space_vec;
      }
      if (BVar6 == '\0') {
        prVar12 = mtspace->otree;
      }
      else {
        prVar12 = mtspace->etree;
      }
      qc.touch_is_vec = '\x01';
      qloop(local_e0,prVar12,(heap_or_vector)free_space_vec,'\x01');
      iVar10 = vector_is_empty(free_space_vec);
      if (iVar10 == 0) {
        if (qc.desired == (CheapPointType *)0x0) {
          iVar10 = vector_is_empty((work->untested).v);
        }
        else {
          iVar10 = heap_is_empty((work->untested).h);
        }
        if (iVar10 == 0) {
          return work;
        }
        break;
      }
      if (BVar7 != '\0') {
        qc.checking = work->hi_candidate;
        if (BVar6 == '\0') {
          prVar12 = mtspace->otree;
        }
        else {
          prVar12 = mtspace->etree;
        }
        qc.touching.v = (vector_t *)0x0;
        qloop(local_e0,prVar12,(heap_or_vector)hi_conflict_space_vec,'\x01');
      }
      if (qc.desired == (CheapPointType *)0x0) {
        iVar10 = vector_is_empty((work->untested).v);
      }
      else {
        iVar10 = heap_is_empty((work->untested).h);
      }
    } while (iVar10 == 0);
    if (qc.desired == (CheapPointType *)0x0) {
      iVar10 = vector_is_empty((work->no_fix).v);
      if (iVar10 == 0) {
        return work;
      }
      iVar10 = vector_is_empty((work->no_hi).v);
      if (iVar10 == 0) {
        return work;
      }
      iVar10 = vector_is_empty((work->hi_candidate).v);
    }
    else {
      iVar10 = heap_is_empty((work->no_fix).h);
      if (iVar10 == 0) {
        return work;
      }
      iVar10 = heap_is_empty((work->no_hi).h);
      if (iVar10 == 0) {
        return work;
      }
      iVar10 = heap_is_empty((work->hi_candidate).h);
    }
    if (iVar10 == 0) {
      return work;
    }
    mtsFreeWork(&work);
    work = (vetting_t *)0x0;
  }
  else {
    work = (vetting_t *)malloc(0x20);
    work->keepaway = keepaway;
    work->radius = radius;
    data = (int *)malloc(0x10);
    pvVar4 = work;
    iVar10 = region->Y1;
    iVar8 = keepaway + radius;
    iVar1 = region->X2;
    data[3] = region->Y2 + iVar8;
    iVar2 = region->X1;
    data[1] = iVar10 + -iVar8;
    data[2] = iVar1 + iVar8;
    *data = -iVar8 + iVar2;
    if (desired == (CheapPointType *)0x0) {
      pvVar11 = vector_create();
      pvVar5 = work;
      (pvVar4->untested).v = pvVar11;
      pvVar11 = vector_create();
      pvVar4 = work;
      (pvVar5->no_fix).v = pvVar11;
      pvVar11 = vector_create();
      pvVar5 = work;
      (pvVar4->hi_candidate).v = pvVar11;
      pvVar11 = vector_create();
      (pvVar5->no_hi).v = pvVar11;
      vector_append((work->untested).v,data);
      (work->desired).Y = -0xc8f75;
      (work->desired).X = -0xc8f75;
      return work;
    }
    phVar9 = heap_create();
    pvVar5 = work;
    (pvVar4->untested).h = phVar9;
    phVar9 = heap_create();
    pvVar4 = work;
    (pvVar5->no_fix).h = phVar9;
    phVar9 = heap_create();
    pvVar5 = work;
    (pvVar4->hi_candidate).h = phVar9;
    phVar9 = heap_create();
    (pvVar5->no_hi).h = phVar9;
    heap_insert((work->untested).h,0.0,data);
    LVar3 = desired->Y;
    (work->desired).X = desired->X;
    (work->desired).Y = LVar3;
  }
  return work;
}



// WARNING: Unknown calling convention

int mts_remove_one(BoxType *b,void *cl)

{
                    // WARNING: Load size is inaccurate
  if ((((b->X1 == *(int *)((int)cl + 4)) && (b->X2 == *(int *)((int)cl + 0xc))) &&
      (b->Y1 == *(int *)((int)cl + 8))) && ((b->Y2 == *(int *)((int)cl + 0x10) && (b[1].X1 == *cl)))
     ) {
    r_delete_entry(*(rtree_t **)((int)cl + 0x14),b);
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x18,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

void mtspace_add(mtspace_t *mtspace,BoxType *box,mtspace_type_t which,BDimension keepaway)

{
  mtspacebox_t *which_00;
  mtspacebox_t *filler;
  rtree_t *rtree;
  
  which_00 = mtspace_create_box(box,keepaway);
  if (which == FIXED) {
    rtree = mtspace->ftree;
  }
  else if (which == EVEN) {
    rtree = mtspace->etree;
  }
  else {
    rtree = mtspace->otree;
  }
  r_insert_entry(rtree,&which_00->box,1);
  return;
}



// WARNING: Unknown calling convention

void mtspace_destroy(mtspace_t **mtspacep)

{
  r_destroy_tree(&(*mtspacep)->ftree);
  r_destroy_tree(&(*mtspacep)->etree);
  r_destroy_tree(&(*mtspacep)->otree);
  free(*mtspacep);
  *mtspacep = (mtspace_t *)0x0;
  return;
}



// WARNING: Unknown calling convention

mtspace_t * mtspace_create(void)

{
  mtspace_t *pmVar1;
  rtree_t *prVar2;
  
  pmVar1 = (mtspace_t *)malloc(0xc);
  prVar2 = r_create_tree((BoxType **)0x0,0,0);
  pmVar1->ftree = prVar2;
  prVar2 = r_create_tree((BoxType **)0x0,0,0);
  pmVar1->etree = prVar2;
  prVar2 = r_create_tree((BoxType **)0x0,0,0);
  pmVar1->otree = prVar2;
  return pmVar1;
}



// WARNING: Unknown calling convention

void DSClearString(DynamicStringTypePtr Ptr)

{
  if (Ptr->Data != (char *)0x0) {
    *Ptr->Data = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

void SaveFree(void *Ptr)

{
  if (Ptr != (void *)0x0) {
    free(Ptr);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void FreeAttributeListMemory(AttributeListTypePtr list)

{
  int i;
  int iVar1;
  int iVar2;
  
  if (0 < list->Number) {
    iVar1 = 0;
    do {
      iVar2 = iVar1 + 1;
      SaveFree(list->List[iVar1].name);
      SaveFree(list->List[iVar1].value);
      iVar1 = iVar2;
    } while (list->Number != iVar2 && iVar2 <= list->Number);
  }
  SaveFree(list->List);
  list->List = (AttributeType *)0x0;
  list->Max = 0;
  return;
}



// WARNING: Unknown calling convention

void FreeLibraryMemory(LibraryTypePtr lib)

{
  void *pvVar1;
  void **ppvVar2;
  Cardinal n;
  int iVar3;
  int iVar4;
  LibraryEntryTypePtr entry;
  int local_28;
  int local_24;
  
  local_24 = lib->MenuN - 1;
  if (local_24 != -1) {
    iVar3 = lib->MenuN * 0x1c;
    do {
      local_28 = iVar3 + -0x1c;
      ppvVar2 = (void **)((int)&lib->Menu[-1].Name + iVar3);
      iVar3 = (int)ppvVar2[3] + -1;
      if (iVar3 != -1) {
        iVar4 = (int)ppvVar2[3] * 0x18;
        do {
          iVar4 = iVar4 + -0x18;
          iVar3 = iVar3 + -1;
          pvVar1 = ppvVar2[5];
          SaveFree(((void **)(iVar4 + (int)pvVar1))[1]);
          SaveFree(*(void **)(iVar4 + (int)pvVar1));
        } while (iVar3 != -1);
      }
      SaveFree(ppvVar2[5]);
      SaveFree(*ppvVar2);
      local_24 = local_24 + -1;
      iVar3 = local_28;
    } while (local_24 != -1);
  }
  SaveFree(lib->Menu);
  lib->MenuN = 0;
  lib->MenuMax = 0;
  lib->Menu = (LibraryMenuTypePtr)0x0;
  return;
}



// WARNING: Unknown calling convention

void FreeElementMemory(ElementTypePtr Element)

{
  PinTypePtr paVar1;
  PadTypePtr paVar2;
  void *Ptr;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar3;
  int iVar4;
  uint uVar5;
  Cardinal n;
  uint uVar6;
  Cardinal n_1;
  PinTypePtr pin;
  PadTypePtr pad;
  byte bVar7;
  uint local_20;
  
  bVar7 = 0;
  if (Element != (ElementTypePtr)0x0) {
    SaveFree(Element->Name[2].TextString);
    SaveFree(Element->Name[1].TextString);
    SaveFree(Element->Name[0].TextString);
    if (Element->PinN != 0) {
      uVar5 = 0;
      local_20 = Element->PinN;
      do {
        paVar1 = Element->Pin;
        SaveFree(paVar1[uVar5].Name);
        paVar1[uVar5].Name = (char *)0x0;
        SaveFree(paVar1[uVar5].Number);
        uVar3 = Element->PinN;
        paVar1[uVar5].Number = (char *)0x0;
        if (uVar3 == 0) break;
        uVar5 = (uVar3 + 1 + uVar5) - local_20;
        local_20 = uVar3;
      } while (uVar5 < uVar3);
    }
    uVar5 = Element->PadN;
    uVar6 = 0;
    local_20 = 0;
    uVar3 = uVar5;
    while ((uVar3 != 0 && (uVar6 < uVar3))) {
      paVar2 = Element->Pad;
      SaveFree(*(void **)((int)(&paVar2->Flags + 5) + local_20 + 8));
      Ptr = *(void **)((int)(&paVar2->Flags + 6) + local_20);
      *(undefined4 *)((int)(&paVar2->Flags + 5) + local_20 + 8) = 0;
      SaveFree(Ptr);
      uVar3 = Element->PadN;
      *(undefined4 *)((int)(&paVar2->Flags + 6) + local_20) = 0;
      if (uVar3 == uVar5) {
        uVar6 = uVar6 + 1;
        local_20 = local_20 + 0x68;
        uVar3 = uVar5;
      }
    }
    SaveFree(Element->Pin);
    Element->Pin = (PinTypePtr)0x0;
    SaveFree(Element->Pad);
    Element->Pad = (PadTypePtr)0x0;
    SaveFree(Element->Line);
    Element->Line = (LineTypePtr)0x0;
    SaveFree(Element->Arc);
    Element->Arc = (ArcTypePtr)0x0;
    FreeAttributeListMemory(&Element->Attributes);
    for (iVar4 = 0x4b; iVar4 != 0; iVar4 = iVar4 + -1) {
      (Element->BoundingBox).X1 = 0;
      Element = (ElementTypePtr)((int)Element + (uint)bVar7 * -8 + 4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void FreeNetMemory(NetTypePtr Net)

{
  if (Net != (NetTypePtr)0x0) {
    SaveFree(Net->Connection);
    Net->ConnectionN = 0;
    Net->ConnectionMax = 0;
    Net->Connection = (ConnectionTypePtr)0x0;
    Net->Style = (RouteStyleTypePtr)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void FreeNetListMemory(NetListTypePtr Netlist)

{
  NetTypePtr Net;
  int iVar1;
  Cardinal n;
  int iVar2;
  
  if (Netlist != (NetListTypePtr)0x0) {
    iVar2 = Netlist->NetN - 1;
    if (iVar2 != -1) {
      iVar1 = (Netlist->NetN + 0xfffffff) * 0x10;
      do {
        iVar2 = iVar2 + -1;
        Net = (NetTypePtr)((int)&Netlist->Net->ConnectionN + iVar1);
        iVar1 = iVar1 + -0x10;
        FreeNetMemory(Net);
      } while (iVar2 != -1);
    }
    SaveFree(Netlist->Net);
    Netlist->NetN = 0;
    Netlist->NetMax = 0;
    Netlist->Net = (NetTypePtr)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void FreeNetListListMemory(NetListListTypePtr Netlistlist)

{
  int iVar1;
  Cardinal n;
  int iVar2;
  
  if (Netlistlist != (NetListListTypePtr)0x0) {
    iVar2 = Netlistlist->NetListN - 1;
    if (iVar2 != -1) {
      iVar1 = Netlistlist->NetListN * 0xc;
      do {
        iVar2 = iVar2 + -1;
        FreeNetListMemory((NetListTypePtr)((int)&Netlistlist->NetList[-1].NetN + iVar1));
        iVar1 = iVar1 + -0xc;
      } while (iVar2 != -1);
    }
    SaveFree(Netlistlist->NetList);
    Netlistlist->NetListN = 0;
    Netlistlist->NetListMax = 0;
    Netlistlist->NetList = (NetListTypePtr)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void FreeBoxListMemory(BoxListTypePtr Boxlist)

{
  if (Boxlist != (BoxListTypePtr)0x0) {
    SaveFree(Boxlist->Box);
    Boxlist->BoxN = 0;
    Boxlist->BoxMax = 0;
    Boxlist->Box = (BoxTypePtr)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void FreePointerListMemory(PointerListTypePtr list)

{
  SaveFree(list->Ptr);
  list->PtrN = 0;
  list->PtrMax = 0;
  list->Ptr = (void **)0x0;
  return;
}



// WARNING: Unknown calling convention

void FreePolygonMemory(PolygonTypePtr Polygon)

{
  int iVar1;
  byte bVar2;
  
  bVar2 = 0;
  if (Polygon != (PolygonTypePtr)0x0) {
    SaveFree(Polygon->Points);
    Polygon->Points = (PointTypePtr)0x0;
    if (Polygon->Clipped != (POLYAREA *)0x0) {
      poly_Free(&Polygon->Clipped);
    }
    poly_FreeContours(&Polygon->NoHoles);
    for (iVar1 = 0xf; iVar1 != 0; iVar1 = iVar1 + -1) {
      (Polygon->BoundingBox).X1 = 0;
      Polygon = (PolygonTypePtr)((int)Polygon + (uint)bVar2 * -8 + 4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void FreeDataMemory(DataTypePtr Data)

{
  PinTypePtr paVar1;
  uint uVar2;
  TextTypePtr pTVar3;
  void *Ptr;
  LineTypePtr Ptr_00;
  uint uVar4;
  Cardinal n;
  Cardinal n_1;
  int iVar5;
  LayerTypePtr layer;
  LayerType *pLVar6;
  TextTypePtr text;
  LineTypePtr line;
  PinTypePtr via;
  Cardinal n_2;
  Cardinal n_3;
  Cardinal n_4;
  Cardinal sn;
  int iVar7;
  byte bVar8;
  int local_24;
  uint local_20;
  
  bVar8 = 0;
  if (Data == (DataTypePtr)0x0) {
    __fprintf_chk(stderr,1,"Warning:  Tried to FreeDataMemory(null)\n");
  }
  else {
    if (Data->ViaN != 0) {
      uVar4 = 0;
      local_20 = Data->ViaN;
      do {
        paVar1 = Data->Via;
        SaveFree(paVar1[uVar4].Name);
        uVar2 = Data->ViaN;
        paVar1[uVar4].Name = (char *)0x0;
        if (uVar2 == 0) break;
        uVar4 = (uVar2 + 1 + uVar4) - local_20;
        local_20 = uVar2;
      } while (uVar4 < uVar2);
    }
    iVar5 = Data->ElementN - 1;
    if (iVar5 != -1) {
      iVar7 = Data->ElementN * 300;
      do {
        iVar5 = iVar5 + -1;
        FreeElementMemory((ElementTypePtr)(Data->Element[-1].Flags.t + iVar7 + -0x18));
        iVar7 = iVar7 + -300;
      } while (iVar5 != -1);
    }
    local_24 = 0;
    pLVar6 = Data->Layer;
    while( true ) {
      FreeAttributeListMemory(&pLVar6->Attributes);
      iVar5 = pLVar6->TextN - 1;
      if (iVar5 != -1) {
        iVar7 = pLVar6->TextN * 0x3c;
        do {
          iVar5 = iVar5 + -1;
          pTVar3 = pLVar6->Text;
          SaveFree(*(void **)((int)(&pTVar3[-1].Flags + 2) + iVar7 + 8));
          *(undefined4 *)((int)(&pTVar3[-1].Flags + 2) + iVar7 + 8) = 0;
          iVar7 = iVar7 + -0x3c;
        } while (iVar5 != -1);
      }
      if (pLVar6->Name != (char *)0x0) {
        SaveFree(pLVar6->Name);
        pLVar6->Name = (char *)0x0;
      }
      iVar5 = pLVar6->LineN - 1;
      if (iVar5 == -1) {
        Ptr_00 = pLVar6->Line;
      }
      else {
        Ptr_00 = pLVar6->Line;
        iVar7 = pLVar6->LineN * 0x58;
        do {
          Ptr = *(void **)((int)(&Ptr_00[-1].Flags + 5) + iVar7 + 4);
          if (Ptr != (void *)0x0) {
            SaveFree(Ptr);
            *(undefined4 *)((int)(&Ptr_00[-1].Flags + 5) + iVar7 + 4) = 0;
            Ptr_00 = pLVar6->Line;
          }
          iVar5 = iVar5 + -1;
          iVar7 = iVar7 + -0x58;
        } while (iVar5 != -1);
      }
      SaveFree(Ptr_00);
      pLVar6->Line = (LineTypePtr)0x0;
      SaveFree(pLVar6->Arc);
      pLVar6->Arc = (ArcTypePtr)0x0;
      SaveFree(pLVar6->Text);
      pLVar6->Text = (TextTypePtr)0x0;
      iVar5 = pLVar6->PolygonN - 1;
      if (iVar5 != -1) {
        iVar7 = pLVar6->PolygonN * 0x3c;
        do {
          iVar5 = iVar5 + -1;
          FreePolygonMemory((PolygonTypePtr)(pLVar6->Polygon[-1].Flags.t + iVar7 + -0x18));
          iVar7 = iVar7 + -0x3c;
        } while (iVar5 != -1);
      }
      SaveFree(pLVar6->Polygon);
      pLVar6->Polygon = (PolygonTypePtr)0x0;
      if (pLVar6->line_tree != (rtree_t *)0x0) {
        r_destroy_tree(&pLVar6->line_tree);
      }
      if (pLVar6->arc_tree != (rtree_t *)0x0) {
        r_destroy_tree(&pLVar6->arc_tree);
      }
      if (pLVar6->text_tree != (rtree_t *)0x0) {
        r_destroy_tree(&pLVar6->text_tree);
      }
      if (pLVar6->polygon_tree != (rtree_t *)0x0) {
        r_destroy_tree(&pLVar6->polygon_tree);
      }
      local_24 = local_24 + 1;
      if (local_24 == 0x12) break;
      pLVar6 = pLVar6 + 1;
    }
    if (Data->element_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->element_tree);
    }
    if (Data->name_tree[0] != (rtree_t *)0x0) {
      r_destroy_tree(Data->name_tree);
    }
    if (Data->name_tree[1] != (rtree_t *)0x0) {
      r_destroy_tree(Data->name_tree + 1);
    }
    if (Data->name_tree[2] != (rtree_t *)0x0) {
      r_destroy_tree(Data->name_tree + 2);
    }
    if (Data->via_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->via_tree);
    }
    if (Data->pin_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->pin_tree);
    }
    if (Data->pad_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->pad_tree);
    }
    if (Data->rat_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->rat_tree);
    }
    for (iVar5 = 0x1b1; iVar5 != 0; iVar5 = iVar5 + -1) {
      Data->ViaN = 0;
      Data = (DataTypePtr)((int)Data + (uint)bVar8 * -8 + 4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void FreePCBMemory(PCBTypePtr PCBPtr)

{
  DataTypePtr Ptr;
  int iVar1;
  
  if (PCBPtr != (PCBTypePtr)0x0) {
    SaveFree(PCBPtr->Name);
    PCBPtr->Name = (char *)0x0;
    SaveFree(PCBPtr->Filename);
    PCBPtr->Filename = (char *)0x0;
    SaveFree(PCBPtr->PrintFilename);
    Ptr = (DataTypePtr)0x0;
    PCBPtr->PrintFilename = (char *)0x0;
    if (PCBPtr->Data != (DataTypePtr)0x0) {
      FreeDataMemory(PCBPtr->Data);
      Ptr = PCBPtr->Data;
    }
    iVar1 = 0;
    SaveFree(Ptr);
    PCBPtr->Data = (DataTypePtr)0x0;
    do {
      SaveFree(*(void **)((int)&(PCBPtr->Font).Symbol[0].Line + iVar1));
      *(undefined4 *)((int)&(PCBPtr->Font).Symbol[0].Line + iVar1) = 0;
      iVar1 = iVar1 + 0x1c;
    } while (iVar1 != 0x1c00);
    FreeLibraryMemory(&PCBPtr->NetlistLib);
    FreeAttributeListMemory(&PCBPtr->Attributes);
    memset(PCBPtr,0,0x2210);
    return;
  }
  __fprintf_chk(stderr,1,"Warning:  Tried to FreePCBMemory(null)\n");
  return;
}



// WARNING: Unknown calling convention

char * MyStrdup(char *S,char *Text)

{
  char *pcVar1;
  char *p;
  
  pcVar1 = (char *)0x0;
  if (S != (char *)0x0) {
    pcVar1 = (char *)__strdup(S);
    if (pcVar1 == (char *)0x0) {
      if (Text == (char *)0x0) {
        Text = "(unknown)";
      }
      MyFatal("out of memory during g_strdup() in \'%s\'\n",Text);
      return (char *)0x0;
    }
  }
  return pcVar1;
}



// WARNING: Unknown calling convention

void * MyRealloc(void *Ptr,size_t Size,char *Text)

{
  void *pvVar1;
  void *p;
  
  if (Size == 0) {
    Size = 1;
  }
  if (Ptr == (void *)0x0) {
    pvVar1 = calloc(1,Size);
  }
  else {
    pvVar1 = realloc(Ptr,Size);
  }
  if (pvVar1 != (void *)0x0) {
    return pvVar1;
  }
  if (Text == (char *)0x0) {
    Text = "(unknown)";
  }
  MyFatal("out of memory during realloc() in \'%s\'()\n",Text);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

char * StripWhiteSpaceAndDup(char *S)

{
  ushort *puVar1;
  char *p2;
  ushort **ppuVar2;
  size_t __n;
  char *pcVar3;
  char cVar4;
  char *p1;
  size_t length;
  
  if ((S != (char *)0x0) && (cVar4 = *S, cVar4 != '\0')) {
    ppuVar2 = __ctype_b_loc();
    puVar1 = *ppuVar2;
    do {
      if ((*(byte *)((int)puVar1 + cVar4 * 2 + 1) & 0x20) == 0) break;
      S = S + 1;
      cVar4 = *S;
    } while (cVar4 != '\0');
    __n = strlen(S);
    pcVar3 = S + (__n - 1);
    if (__n != 0) {
      while( true ) {
        if ((*(byte *)((int)puVar1 + *pcVar3 * 2 + 1) & 0x20) == 0) {
          pcVar3 = (char *)MyRealloc((void *)0x0,__n + 1,"StripWhiteSpace()");
          strncpy(pcVar3,S,__n);
          pcVar3[__n] = '\0';
          return pcVar3;
        }
        __n = __n - 1;
        if (__n == 0) break;
        pcVar3 = pcVar3 + -1;
      }
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

void DSAddString(DynamicStringTypePtr Ptr,char *S)

{
  uint uVar1;
  size_t sVar2;
  char *pcVar3;
  size_t sVar4;
  size_t position;
  char *local_20;
  
  sVar4 = 0;
  local_20 = Ptr->Data;
  if (local_20 != (char *)0x0) {
    sVar4 = strlen(local_20);
  }
  if ((S != (char *)0x0) && (*S != '\0')) {
    sVar2 = strlen(S);
    uVar1 = sVar4 + 1 + sVar2;
    if (local_20 == (char *)0x0) {
      Ptr->MaxLength = uVar1 + 0x200;
      pcVar3 = (char *)MyRealloc((void *)0x0,uVar1 + 0x200,"ReallocDS()");
      Ptr->Data = pcVar3;
      *pcVar3 = '\0';
      local_20 = Ptr->Data;
    }
    else if (Ptr->MaxLength <= uVar1) {
      Ptr->MaxLength = uVar1 + 0x200;
      local_20 = (char *)MyRealloc(local_20,uVar1 + 0x200,"ReallocDS()");
      Ptr->Data = local_20;
    }
    strcat(local_20 + sVar4,S);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void DSAddCharacter(DynamicStringTypePtr Ptr,char Char)

{
  size_t sVar1;
  size_t position;
  char *pcVar2;
  uint uVar3;
  
  pcVar2 = Ptr->Data;
  if (pcVar2 == (char *)0x0) {
    Ptr->MaxLength = 0x201;
    sVar1 = 0;
    pcVar2 = (char *)MyRealloc((void *)0x0,0x201,"ReallocDS()");
    uVar3 = 1;
    Ptr->Data = pcVar2;
    *pcVar2 = '\0';
    pcVar2 = Ptr->Data;
  }
  else {
    sVar1 = strlen(pcVar2);
    uVar3 = sVar1 + 1;
    if (Ptr->MaxLength <= uVar3) {
      Ptr->MaxLength = sVar1 + 0x201;
      pcVar2 = (char *)MyRealloc(pcVar2,sVar1 + 0x201,"ReallocDS()");
      Ptr->Data = pcVar2;
    }
  }
  pcVar2[sVar1] = Char;
  Ptr->Data[uVar3] = '\0';
  return;
}



// WARNING: Unknown calling convention

DrillTypePtr GetDrillInfoDrillMemory(DrillInfoTypePtr DrillInfo)

{
  DrillTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  DrillTypePtr drill;
  uint uVar3;
  DrillTypePtr pDVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = DrillInfo->DrillN;
  Ptr = DrillInfo->Drill;
  if (DrillInfo->DrillMax <= uVar3) {
    CVar1 = DrillInfo->DrillMax + 0x1e;
    uVar3 = 0x4b0;
    DrillInfo->DrillMax = CVar1;
    Ptr = (DrillTypePtr)MyRealloc(Ptr,CVar1 * 0x28,"GetDrillInfoDrillMemory()");
    DrillInfo->Drill = Ptr;
    pDVar4 = Ptr + DrillInfo->DrillN;
    bVar5 = ((uint)pDVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&pDVar4->DrillSize = 0;
      uVar3 = 0x4af;
      pDVar4 = (DrillTypePtr)((int)&pDVar4->DrillSize + 1);
    }
    if (((uint)pDVar4 & 2) != 0) {
      *(undefined2 *)&pDVar4->DrillSize = 0;
      uVar3 = uVar3 - 2;
      pDVar4 = (DrillTypePtr)((int)&pDVar4->DrillSize + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      pDVar4->DrillSize = 0;
      pDVar4 = (DrillTypePtr)((int)pDVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pDVar4->DrillSize = 0;
      pDVar4 = (DrillTypePtr)((int)&pDVar4->DrillSize + 2);
    }
    if (bVar5) {
      *(undefined *)&pDVar4->DrillSize = 0;
      uVar3 = DrillInfo->DrillN;
    }
    else {
      uVar3 = DrillInfo->DrillN;
    }
  }
  DrillInfo->DrillN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

PinTypeHandle GetDrillPinMemory(DrillTypePtr Drill)

{
  PinTypePtr *Ptr;
  Cardinal CVar1;
  uint uVar2;
  PinTypePtr *pin;
  uint uVar3;
  PinTypePtr *ppaVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Drill->PinN;
  Ptr = Drill->Pin;
  if (Drill->PinMax <= uVar3) {
    CVar1 = Drill->PinMax + 100;
    uVar3 = 400;
    Drill->PinMax = CVar1;
    Ptr = (PinTypePtr *)MyRealloc(Ptr,CVar1 * 4,"GetDrillPinMemory()");
    Drill->Pin = Ptr;
    ppaVar4 = Ptr + Drill->PinN;
    bVar5 = ((uint)ppaVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)ppaVar4 = 0;
      uVar3 = 399;
      ppaVar4 = (PinTypePtr *)((int)ppaVar4 + 1);
    }
    if (((uint)ppaVar4 & 2) != 0) {
      *(undefined2 *)ppaVar4 = 0;
      uVar3 = uVar3 - 2;
      ppaVar4 = (PinTypePtr *)((int)ppaVar4 + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      *ppaVar4 = (PinTypePtr)0x0;
      ppaVar4 = ppaVar4 + (uint)bVar6 * -2 + 1;
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)ppaVar4 = 0;
      ppaVar4 = (PinTypePtr *)((int)ppaVar4 + 2);
    }
    if (bVar5) {
      *(undefined *)ppaVar4 = 0;
      uVar3 = Drill->PinN;
    }
    else {
      uVar3 = Drill->PinN;
    }
  }
  Drill->PinN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

ElementTypeHandle GetDrillElementMemory(DrillTypePtr Drill)

{
  ElementTypePtr *Ptr;
  Cardinal CVar1;
  uint uVar2;
  ElementTypePtr *element;
  uint uVar3;
  ElementTypePtr *ppaVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Drill->ElementN;
  Ptr = Drill->Element;
  if (Drill->ElementMax <= uVar3) {
    CVar1 = Drill->ElementMax + 0x32;
    uVar3 = 200;
    Drill->ElementMax = CVar1;
    Ptr = (ElementTypePtr *)MyRealloc(Ptr,CVar1 * 4,"GetDrillElementMemory()");
    Drill->Element = Ptr;
    ppaVar4 = Ptr + Drill->ElementN;
    bVar5 = ((uint)ppaVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)ppaVar4 = 0;
      uVar3 = 199;
      ppaVar4 = (ElementTypePtr *)((int)ppaVar4 + 1);
    }
    if (((uint)ppaVar4 & 2) != 0) {
      *(undefined2 *)ppaVar4 = 0;
      uVar3 = uVar3 - 2;
      ppaVar4 = (ElementTypePtr *)((int)ppaVar4 + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      *ppaVar4 = (ElementTypePtr)0x0;
      ppaVar4 = ppaVar4 + (uint)bVar6 * -2 + 1;
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)ppaVar4 = 0;
      ppaVar4 = (ElementTypePtr *)((int)ppaVar4 + 2);
    }
    if (bVar5) {
      *(undefined *)ppaVar4 = 0;
      uVar3 = Drill->ElementN;
    }
    else {
      uVar3 = Drill->ElementN;
    }
  }
  Drill->ElementN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

LibraryEntryTypePtr GetLibraryEntryMemory(LibraryMenuTypePtr Menu)

{
  LibraryEntryTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  LibraryEntryTypePtr entry;
  uint uVar3;
  LibraryEntryTypePtr paVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Menu->EntryN;
  Ptr = Menu->Entry;
  if (Menu->EntryMax <= uVar3) {
    CVar1 = Menu->EntryMax + 0x14;
    uVar3 = 0x1e0;
    Menu->EntryMax = CVar1;
    Ptr = (LibraryEntryTypePtr)MyRealloc(Ptr,CVar1 * 0x18,"GetLibraryEntryMemory()");
    Menu->Entry = Ptr;
    paVar4 = Ptr + Menu->EntryN;
    bVar5 = ((uint)paVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&paVar4->ListEntry = 0;
      uVar3 = 0x1df;
      paVar4 = (LibraryEntryTypePtr)((int)&paVar4->ListEntry + 1);
    }
    if (((uint)paVar4 & 2) != 0) {
      *(undefined2 *)&paVar4->ListEntry = 0;
      uVar3 = uVar3 - 2;
      paVar4 = (LibraryEntryTypePtr)((int)&paVar4->ListEntry + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      paVar4->ListEntry = (char *)0x0;
      paVar4 = (LibraryEntryTypePtr)((int)paVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&paVar4->ListEntry = 0;
      paVar4 = (LibraryEntryTypePtr)((int)&paVar4->ListEntry + 2);
    }
    if (bVar5) {
      *(undefined *)&paVar4->ListEntry = 0;
      uVar3 = Menu->EntryN;
    }
    else {
      uVar3 = Menu->EntryN;
    }
  }
  Menu->EntryN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

LibraryMenuTypePtr GetLibraryMenuMemory(LibraryTypePtr lib)

{
  LibraryMenuTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  LibraryMenuTypePtr menu;
  uint uVar3;
  LibraryMenuTypePtr paVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = lib->MenuN;
  Ptr = lib->Menu;
  if (lib->MenuMax <= uVar3) {
    CVar1 = lib->MenuMax + 10;
    uVar3 = 0x118;
    lib->MenuMax = CVar1;
    Ptr = (LibraryMenuTypePtr)MyRealloc(Ptr,CVar1 * 0x1c,"GetLibraryMenuMemory()");
    paVar4 = Ptr + lib->MenuN;
    bVar5 = ((uint)paVar4 & 1) != 0;
    lib->Menu = Ptr;
    if (bVar5) {
      *(undefined *)&paVar4->Name = 0;
      uVar3 = 0x117;
      paVar4 = (LibraryMenuTypePtr)((int)&paVar4->Name + 1);
    }
    if (((uint)paVar4 & 2) != 0) {
      *(undefined2 *)&paVar4->Name = 0;
      uVar3 = uVar3 - 2;
      paVar4 = (LibraryMenuTypePtr)((int)&paVar4->Name + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      paVar4->Name = (char *)0x0;
      paVar4 = (LibraryMenuTypePtr)((int)paVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&paVar4->Name = 0;
      paVar4 = (LibraryMenuTypePtr)((int)&paVar4->Name + 2);
    }
    if (bVar5) {
      *(undefined *)&paVar4->Name = 0;
      uVar3 = lib->MenuN;
    }
    else {
      uVar3 = lib->MenuN;
    }
  }
  lib->MenuN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

PointTypePtr GetPointMemoryInPolygon(PolygonTypePtr Polygon)

{
  PointTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  PointTypePtr points;
  uint uVar3;
  PointTypePtr pPVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Polygon->PointN;
  Ptr = Polygon->Points;
  if (Polygon->PointMax <= uVar3) {
    CVar1 = Polygon->PointMax + 10;
    uVar3 = 200;
    Polygon->PointMax = CVar1;
    Ptr = (PointTypePtr)MyRealloc(Ptr,CVar1 * 0x14,"GetPointMemoryInPolygon()");
    Polygon->Points = Ptr;
    pPVar4 = Ptr + Polygon->PointN;
    bVar5 = ((uint)pPVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&pPVar4->X = 0;
      uVar3 = 199;
      pPVar4 = (PointTypePtr)((int)&pPVar4->X + 1);
    }
    if (((uint)pPVar4 & 2) != 0) {
      *(undefined2 *)&pPVar4->X = 0;
      uVar3 = uVar3 - 2;
      pPVar4 = (PointTypePtr)((int)&pPVar4->X + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      pPVar4->X = 0;
      pPVar4 = (PointTypePtr)((int)pPVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pPVar4->X = 0;
      pPVar4 = (PointTypePtr)((int)&pPVar4->X + 2);
    }
    if (bVar5) {
      *(undefined *)&pPVar4->X = 0;
      uVar3 = Polygon->PointN;
    }
    else {
      uVar3 = Polygon->PointN;
    }
  }
  Polygon->PointN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

NetListTypePtr GetNetListMemory(NetListListTypePtr Netlistlist)

{
  NetListTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  NetListTypePtr netlist;
  uint uVar3;
  NetListTypePtr paVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Netlistlist->NetListN;
  Ptr = Netlistlist->NetList;
  if (Netlistlist->NetListMax <= uVar3) {
    CVar1 = Netlistlist->NetListMax + 100;
    uVar3 = 0x4b0;
    Netlistlist->NetListMax = CVar1;
    Ptr = (NetListTypePtr)MyRealloc(Ptr,CVar1 * 0xc,"GetNetListMemory()");
    Netlistlist->NetList = Ptr;
    paVar4 = Ptr + Netlistlist->NetListN;
    bVar5 = ((uint)paVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&paVar4->NetN = 0;
      uVar3 = 0x4af;
      paVar4 = (NetListTypePtr)((int)&paVar4->NetN + 1);
    }
    if (((uint)paVar4 & 2) != 0) {
      *(undefined2 *)&paVar4->NetN = 0;
      uVar3 = uVar3 - 2;
      paVar4 = (NetListTypePtr)((int)&paVar4->NetN + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      paVar4->NetN = 0;
      paVar4 = (NetListTypePtr)((int)paVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&paVar4->NetN = 0;
      paVar4 = (NetListTypePtr)((int)&paVar4->NetN + 2);
    }
    if (bVar5) {
      *(undefined *)&paVar4->NetN = 0;
      uVar3 = Netlistlist->NetListN;
    }
    else {
      uVar3 = Netlistlist->NetListN;
    }
  }
  Netlistlist->NetListN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

NetTypePtr GetNetMemory(NetListTypePtr Netlist)

{
  NetTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  NetTypePtr net;
  uint uVar3;
  NetTypePtr paVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Netlist->NetN;
  Ptr = Netlist->Net;
  if (Netlist->NetMax <= uVar3) {
    CVar1 = Netlist->NetMax + 100;
    uVar3 = 0x640;
    Netlist->NetMax = CVar1;
    Ptr = (NetTypePtr)MyRealloc(Ptr,CVar1 * 0x10,"GetNetMemory()");
    paVar4 = Ptr + Netlist->NetN;
    bVar5 = ((uint)paVar4 & 1) != 0;
    Netlist->Net = Ptr;
    if (bVar5) {
      *(undefined *)&paVar4->ConnectionN = 0;
      uVar3 = 0x63f;
      paVar4 = (NetTypePtr)((int)&paVar4->ConnectionN + 1);
    }
    if (((uint)paVar4 & 2) != 0) {
      *(undefined2 *)&paVar4->ConnectionN = 0;
      uVar3 = uVar3 - 2;
      paVar4 = (NetTypePtr)((int)&paVar4->ConnectionN + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      paVar4->ConnectionN = 0;
      paVar4 = (NetTypePtr)((int)paVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&paVar4->ConnectionN = 0;
      paVar4 = (NetTypePtr)((int)&paVar4->ConnectionN + 2);
    }
    if (bVar5) {
      *(undefined *)&paVar4->ConnectionN = 0;
      uVar3 = Netlist->NetN;
    }
    else {
      uVar3 = Netlist->NetN;
    }
  }
  Netlist->NetN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

ConnectionTypePtr GetConnectionMemory(NetTypePtr Net)

{
  ConnectionTypePtr Ptr;
  Cardinal CVar1;
  uint uVar2;
  ConnectionTypePtr con;
  uint uVar3;
  ConnectionTypePtr paVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Net->ConnectionN;
  Ptr = Net->Connection;
  if (Net->ConnectionMax <= uVar3) {
    CVar1 = Net->ConnectionMax + 100;
    uVar3 = 0xaf0;
    Net->ConnectionMax = CVar1;
    Ptr = (ConnectionTypePtr)MyRealloc(Ptr,CVar1 * 0x1c,"GetConnectionMemory()");
    paVar4 = Ptr + Net->ConnectionN;
    bVar5 = ((uint)paVar4 & 1) != 0;
    Net->Connection = Ptr;
    if (bVar5) {
      *(undefined *)&paVar4->X = 0;
      uVar3 = 0xaef;
      paVar4 = (ConnectionTypePtr)((int)&paVar4->X + 1);
    }
    if (((uint)paVar4 & 2) != 0) {
      *(undefined2 *)&paVar4->X = 0;
      uVar3 = uVar3 - 2;
      paVar4 = (ConnectionTypePtr)((int)&paVar4->X + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      paVar4->X = 0;
      paVar4 = (ConnectionTypePtr)((int)paVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&paVar4->X = 0;
      paVar4 = (ConnectionTypePtr)((int)&paVar4->X + 2);
    }
    if (bVar5) {
      *(undefined *)&paVar4->X = 0;
      uVar3 = Net->ConnectionN;
    }
    else {
      uVar3 = Net->ConnectionN;
    }
  }
  Net->ConnectionN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

BoxTypePtr GetBoxMemory(BoxListTypePtr Boxes)

{
  BoxTypePtr Ptr;
  uint uVar1;
  int iVar2;
  BoxTypePtr box;
  
  uVar1 = Boxes->BoxN;
  Ptr = Boxes->Box;
  if (Boxes->BoxMax <= uVar1) {
    iVar2 = Boxes->BoxMax + 0x32;
    Boxes->BoxMax = iVar2 * 2;
    Ptr = (BoxTypePtr)MyRealloc(Ptr,iVar2 * 0x20,"GetBoxMemory()");
    Boxes->Box = Ptr;
    memset(Ptr + Boxes->BoxN,0,(Boxes->BoxMax - Boxes->BoxN) * 0x10);
    uVar1 = Boxes->BoxN;
  }
  Boxes->BoxN = uVar1 + 1;
  return Ptr + uVar1;
}



// WARNING: Unknown calling convention

void ** GetPointerMemory(PointerListTypePtr list)

{
  void **Ptr;
  uint uVar1;
  int iVar2;
  void **ptr;
  
  uVar1 = list->PtrN;
  Ptr = list->Ptr;
  if (list->PtrMax <= uVar1) {
    iVar2 = list->PtrMax + 0x32;
    list->PtrMax = iVar2 * 2;
    Ptr = (void **)MyRealloc(Ptr,iVar2 * 8,"GetPointerMemory()");
    list->Ptr = Ptr;
    memset(Ptr + list->PtrN,0,(list->PtrMax - list->PtrN) * 4);
    uVar1 = list->PtrN;
  }
  list->PtrN = uVar1 + 1;
  return Ptr + uVar1;
}



// WARNING: Unknown calling convention

RubberbandTypePtr GetRubberbandMemory(void)

{
  Cardinal CVar1;
  RubberbandTypePtr paVar2;
  uint uVar3;
  RubberbandTypePtr ptr;
  uint uVar4;
  RubberbandTypePtr paVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  CVar1 = Crosshair.AttachedObject.RubberbandN;
  paVar2 = Crosshair.AttachedObject.Rubberband;
  if (Crosshair.AttachedObject.RubberbandMax <= Crosshair.AttachedObject.RubberbandN) {
    Crosshair.AttachedObject.RubberbandMax = Crosshair.AttachedObject.RubberbandMax + 100;
    uVar4 = 0x4b0;
    paVar2 = (RubberbandTypePtr)
             MyRealloc(Crosshair.AttachedObject.Rubberband,
                       Crosshair.AttachedObject.RubberbandMax * 0xc,"GetRubberbandMemory()");
    paVar5 = paVar2 + Crosshair.AttachedObject.RubberbandN;
    bVar6 = ((uint)paVar5 & 1) != 0;
    Crosshair.AttachedObject.Rubberband = paVar2;
    if (bVar6) {
      *(undefined *)&paVar5->Layer = 0;
      uVar4 = 0x4af;
      paVar5 = (RubberbandTypePtr)((int)&paVar5->Layer + 1);
    }
    if (((uint)paVar5 & 2) != 0) {
      *(undefined2 *)&paVar5->Layer = 0;
      uVar4 = uVar4 - 2;
      paVar5 = (RubberbandTypePtr)((int)&paVar5->Layer + 2);
    }
    for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
      paVar5->Layer = (LayerTypePtr)0x0;
      paVar5 = (RubberbandTypePtr)((int)paVar5 + (uint)bVar7 * -8 + 4);
    }
    CVar1 = Crosshair.AttachedObject.RubberbandN;
    if ((uVar4 & 2) != 0) {
      *(undefined2 *)&paVar5->Layer = 0;
      paVar5 = (RubberbandTypePtr)((int)&paVar5->Layer + 2);
      CVar1 = Crosshair.AttachedObject.RubberbandN;
    }
    if (bVar6) {
      Crosshair.AttachedObject.RubberbandN = CVar1;
      *(undefined *)&paVar5->Layer = 0;
      CVar1 = Crosshair.AttachedObject.RubberbandN;
    }
  }
  Crosshair.AttachedObject.RubberbandN = CVar1 + 1;
  return paVar2 + CVar1;
}



// WARNING: Unknown calling convention

void * MyMalloc(size_t Size,char *Text)

{
  void *pvVar1;
  void *p;
  
  if (Size == 0) {
    Size = 1;
  }
  pvVar1 = calloc(1,Size);
  if (pvVar1 != (void *)0x0) {
    return pvVar1;
  }
  if (Text == (char *)0x0) {
    Text = "(unknown)";
  }
  MyFatal("out of memory during malloc() in \'%s\'()\n",Text);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * MyCalloc(size_t Number,size_t Size,char *Text)

{
  void *pvVar1;
  void *p;
  
  if (Number == 0) {
    Number = 1;
  }
  if (Size == 0) {
    Size = 1;
  }
  pvVar1 = calloc(Number,Size);
  if (pvVar1 != (void *)0x0) {
    return pvVar1;
  }
  if (Text == (char *)0x0) {
    Text = "(unknown)";
  }
  MyFatal("out of memory during malloc() in \'%s\'()\n",Text);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

ElementTypePtr GetElementMemory(DataTypePtr Data)

{
  BoxType *which;
  rtree_t **pprVar1;
  PinTypePtr paVar2;
  rtree_t *prVar3;
  uint uVar4;
  Cardinal n;
  Cardinal n_1;
  uint uVar5;
  Cardinal sn;
  Cardinal CVar6;
  int iVar7;
  int i;
  ElementTypePtr element;
  ElementTypePtr paVar8;
  Cardinal n_2;
  Cardinal sn_1;
  ElementTypePtr local_28;
  int local_24;
  int local_20;
  
  local_28 = Data->Element;
  uVar5 = Data->ElementN;
  if (Data->ElementMax <= uVar5) {
    CVar6 = Data->ElementMax + 0x32;
    Data->ElementMax = CVar6;
    if (Data->element_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->element_tree);
      CVar6 = Data->ElementMax;
    }
    iVar7 = 0;
    local_28 = (ElementTypePtr)MyRealloc(local_28,CVar6 * 300,"GetElementMemory()");
    Data->Element = local_28;
    memset(local_28 + Data->ElementN,0,15000);
    prVar3 = r_create_tree((BoxType **)0x0,0,0);
    Data->element_tree = prVar3;
    do {
      if (Data->name_tree[iVar7] != (rtree_t *)0x0) {
        r_destroy_tree(Data->name_tree + iVar7);
      }
      prVar3 = r_create_tree((BoxType **)0x0,0,0);
      Data->name_tree[iVar7] = prVar3;
      iVar7 = iVar7 + 1;
    } while (iVar7 != 3);
    uVar5 = Data->ElementN;
    local_20 = uVar5 - 1;
    if (local_20 != -1) {
      iVar7 = uVar5 * 300;
      do {
        local_24 = iVar7 + -300;
        element = (ElementTypePtr)(Data->Element[-1].Flags.t + iVar7 + -0x18);
        r_insert_entry(Data->element_tree,(BoxType *)element,0);
        uVar5 = element->PinN;
        if (uVar5 != 0) {
          paVar2 = element->Pin;
          uVar4 = 0;
          paVar2->Element = element;
          while (uVar4 = uVar4 + 1, uVar4 < uVar5) {
            paVar2[uVar4].Element = element;
          }
        }
        uVar5 = element->PadN;
        iVar7 = 0;
        for (uVar4 = 0; (uVar5 != 0 && (uVar4 < uVar5)); uVar4 = uVar4 + 1) {
          *(ElementTypePtr *)((int)(&element->Pad->Flags + 6) + iVar7 + 4) = element;
          iVar7 = iVar7 + 0x68;
        }
        iVar7 = 2;
        paVar8 = element;
        do {
          paVar8->Name[2].Element = element;
          paVar8 = (ElementTypePtr)&paVar8[-1].LineN;
          which = (BoxType *)(element->Name + iVar7);
          pprVar1 = Data->name_tree + iVar7;
          iVar7 = iVar7 + -1;
          r_insert_entry(*pprVar1,which,0);
        } while (iVar7 != -1);
        local_20 = local_20 + -1;
        iVar7 = local_24;
      } while (local_20 != -1);
      uVar5 = Data->ElementN;
    }
  }
  Data->ElementN = uVar5 + 1;
  return local_28 + uVar5;
}



// WARNING: Unknown calling convention

PolygonTypePtr GetPolygonMemory(LayerTypePtr Layer)

{
  int iVar1;
  Cardinal CVar2;
  PolygonTypePtr Ptr;
  rtree_t *rtree;
  uint uVar3;
  uint uVar4;
  PolygonTypePtr polygon;
  PolygonTypePtr ppVar5;
  Cardinal n;
  int iVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  uVar4 = Layer->PolygonN;
  Ptr = Layer->Polygon;
  if (Layer->PolygonMax <= uVar4) {
    CVar2 = Layer->PolygonMax + 10;
    Layer->PolygonMax = CVar2;
    if (Layer->polygon_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->polygon_tree);
      CVar2 = Layer->PolygonMax;
    }
    Ptr = (PolygonTypePtr)MyRealloc(Ptr,CVar2 * 0x3c,"GetPolygonMemory()");
    uVar4 = 600;
    ppVar5 = Ptr + Layer->PolygonN;
    bVar7 = ((uint)ppVar5 & 1) != 0;
    Layer->Polygon = Ptr;
    if (bVar7) {
      *(undefined *)&(ppVar5->BoundingBox).X1 = 0;
      uVar4 = 599;
      ppVar5 = (PolygonTypePtr)((int)&(ppVar5->BoundingBox).X1 + 1);
    }
    if (((uint)ppVar5 & 2) != 0) {
      *(undefined2 *)&(ppVar5->BoundingBox).X1 = 0;
      uVar4 = uVar4 - 2;
      ppVar5 = (PolygonTypePtr)((int)&(ppVar5->BoundingBox).X1 + 2);
    }
    for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
      (ppVar5->BoundingBox).X1 = 0;
      ppVar5 = (PolygonTypePtr)((int)ppVar5 + (uint)bVar8 * -8 + 4);
    }
    if ((uVar4 & 2) != 0) {
      *(undefined2 *)&(ppVar5->BoundingBox).X1 = 0;
      ppVar5 = (PolygonTypePtr)((int)&(ppVar5->BoundingBox).X1 + 2);
    }
    if (bVar7) {
      *(undefined *)&(ppVar5->BoundingBox).X1 = 0;
    }
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar4 = Layer->PolygonN;
    iVar6 = uVar4 - 1;
    Layer->polygon_tree = rtree;
    if (iVar6 != -1) {
      iVar1 = uVar4 * 0x3c;
      while( true ) {
        iVar6 = iVar6 + -1;
        r_insert_entry(rtree,(BoxType *)(Layer->Polygon[-1].Flags.t + iVar1 + -0x18),0);
        if (iVar6 == -1) break;
        rtree = Layer->polygon_tree;
        iVar1 = iVar1 + -0x3c;
      }
      uVar4 = Layer->PolygonN;
    }
  }
  Layer->PolygonN = uVar4 + 1;
  return Ptr + uVar4;
}



// WARNING: Unknown calling convention

TextTypePtr GetTextMemory(LayerTypePtr Layer)

{
  int iVar1;
  Cardinal CVar2;
  TextTypePtr Ptr;
  rtree_t *rtree;
  uint uVar3;
  uint uVar4;
  TextTypePtr text;
  TextTypePtr pTVar5;
  Cardinal n;
  int iVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  uVar4 = Layer->TextN;
  Ptr = Layer->Text;
  if (Layer->TextMax <= uVar4) {
    CVar2 = Layer->TextMax + 0x32;
    Layer->TextMax = CVar2;
    if (Layer->text_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->text_tree);
      CVar2 = Layer->TextMax;
    }
    Ptr = (TextTypePtr)MyRealloc(Ptr,CVar2 * 0x3c,"GetTextMemory()");
    uVar4 = 3000;
    pTVar5 = Ptr + Layer->TextN;
    bVar7 = ((uint)pTVar5 & 1) != 0;
    Layer->Text = Ptr;
    if (bVar7) {
      *(undefined *)&(pTVar5->BoundingBox).X1 = 0;
      uVar4 = 2999;
      pTVar5 = (TextTypePtr)((int)&(pTVar5->BoundingBox).X1 + 1);
    }
    if (((uint)pTVar5 & 2) != 0) {
      *(undefined2 *)&(pTVar5->BoundingBox).X1 = 0;
      uVar4 = uVar4 - 2;
      pTVar5 = (TextTypePtr)((int)&(pTVar5->BoundingBox).X1 + 2);
    }
    for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
      (pTVar5->BoundingBox).X1 = 0;
      pTVar5 = (TextTypePtr)((int)pTVar5 + (uint)bVar8 * -8 + 4);
    }
    if ((uVar4 & 2) != 0) {
      *(undefined2 *)&(pTVar5->BoundingBox).X1 = 0;
      pTVar5 = (TextTypePtr)((int)&(pTVar5->BoundingBox).X1 + 2);
    }
    if (bVar7) {
      *(undefined *)&(pTVar5->BoundingBox).X1 = 0;
    }
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar4 = Layer->TextN;
    iVar6 = uVar4 - 1;
    Layer->text_tree = rtree;
    if (iVar6 != -1) {
      iVar1 = uVar4 * 0x3c;
      while( true ) {
        iVar6 = iVar6 + -1;
        r_insert_entry(rtree,(BoxType *)(Layer->Text[-1].Flags.t + iVar1 + -0x18),0);
        if (iVar6 == -1) break;
        rtree = Layer->text_tree;
        iVar1 = iVar1 + -0x3c;
      }
      uVar4 = Layer->TextN;
    }
  }
  Layer->TextN = uVar4 + 1;
  return Ptr + uVar4;
}



// WARNING: Unknown calling convention

ArcTypePtr GetArcMemory(LayerTypePtr Layer)

{
  int iVar1;
  Cardinal CVar2;
  ArcTypePtr Ptr;
  rtree_t *rtree;
  uint uVar3;
  ArcTypePtr arc;
  Cardinal n;
  int iVar4;
  
  uVar3 = Layer->ArcN;
  Ptr = Layer->Arc;
  if (Layer->ArcMax <= uVar3) {
    CVar2 = Layer->ArcMax + 1000;
    Layer->ArcMax = CVar2;
    if (Layer->arc_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->arc_tree);
      CVar2 = Layer->ArcMax;
    }
    Ptr = (ArcTypePtr)MyRealloc(Ptr,CVar2 * 0x44,"GetArcMemory()");
    Layer->Arc = Ptr;
    memset(Ptr + Layer->ArcN,0,68000);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Layer->ArcN;
    iVar4 = uVar3 - 1;
    Layer->arc_tree = rtree;
    if (iVar4 != -1) {
      iVar1 = uVar3 * 0x44;
      while( true ) {
        iVar4 = iVar4 + -1;
        r_insert_entry(rtree,(BoxType *)(Layer->Arc[-1].Flags.t + iVar1 + -0x18),0);
        if (iVar4 == -1) break;
        rtree = Layer->arc_tree;
        iVar1 = iVar1 + -0x44;
      }
      uVar3 = Layer->ArcN;
    }
  }
  Layer->ArcN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

LineTypePtr GetLineMemory(LayerTypePtr Layer)

{
  int iVar1;
  Cardinal CVar2;
  LineTypePtr Ptr;
  rtree_t *rtree;
  uint uVar3;
  LineTypePtr line;
  Cardinal n;
  int iVar4;
  
  uVar3 = Layer->LineN;
  Ptr = Layer->Line;
  if (Layer->LineMax <= uVar3) {
    CVar2 = Layer->LineMax + 10000;
    Layer->LineMax = CVar2;
    if (Layer->line_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->line_tree);
      CVar2 = Layer->LineMax;
    }
    Ptr = (LineTypePtr)MyRealloc(Ptr,CVar2 * 0x58,"GetLineMemory()");
    Layer->Line = Ptr;
    memset(Ptr + Layer->LineN,0,880000);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Layer->LineN;
    iVar4 = uVar3 - 1;
    Layer->line_tree = rtree;
    if (iVar4 != -1) {
      iVar1 = uVar3 * 0x58;
      while( true ) {
        iVar4 = iVar4 + -1;
        r_insert_entry(rtree,(BoxType *)(Layer->Line[-1].Flags.t + iVar1 + -0x18),0);
        if (iVar4 == -1) break;
        rtree = Layer->line_tree;
        iVar1 = iVar1 + -0x58;
      }
      uVar3 = Layer->LineN;
    }
  }
  Layer->LineN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

RatTypePtr GetRatMemory(DataTypePtr Data)

{
  int iVar1;
  Cardinal CVar2;
  RatTypePtr Ptr;
  rtree_t *rtree;
  uint uVar3;
  RatTypePtr rat;
  Cardinal n;
  int iVar4;
  
  uVar3 = Data->RatN;
  Ptr = Data->Rat;
  if (Data->RatMax <= uVar3) {
    CVar2 = Data->RatMax + 2000;
    Data->RatMax = CVar2;
    if (Data->rat_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->rat_tree);
      CVar2 = Data->RatMax;
    }
    Ptr = (RatTypePtr)MyRealloc(Ptr,CVar2 * 0x5c,"GetRatMemory()");
    Data->Rat = Ptr;
    memset(Ptr + Data->RatN,0,0x2cec0);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Data->RatN;
    iVar4 = uVar3 - 1;
    Data->rat_tree = rtree;
    if (iVar4 != -1) {
      iVar1 = uVar3 * 0x5c;
      while( true ) {
        iVar4 = iVar4 + -1;
        r_insert_entry(rtree,(BoxType *)(Data->Rat[-1].Flags.t + iVar1 + -0x18),0);
        if (iVar4 == -1) break;
        rtree = Data->rat_tree;
        iVar1 = iVar1 + -0x5c;
      }
      uVar3 = Data->RatN;
    }
  }
  Data->RatN = uVar3 + 1;
  return Ptr + uVar3;
}



// WARNING: Unknown calling convention

PinTypePtr GetViaMemory(DataTypePtr Data)

{
  Cardinal CVar1;
  rtree_t *rtree;
  Cardinal sn;
  uint uVar2;
  uint uVar3;
  Cardinal n;
  uint uVar4;
  PinTypePtr local_20;
  
  local_20 = Data->Via;
  uVar2 = Data->ViaN;
  CVar1 = uVar2 + 1;
  if (Data->ViaMax <= uVar2) {
    CVar1 = Data->ViaMax + 2000;
    Data->ViaMax = CVar1;
    if (Data->via_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->via_tree);
      CVar1 = Data->ViaMax;
    }
    local_20 = (PinTypePtr)MyRealloc(local_20,CVar1 * 0x4c,"GetViaMemory()");
    Data->Via = local_20;
    memset(local_20 + Data->ViaN,0,0x251c0);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar2 = Data->ViaN;
    CVar1 = 1;
    Data->via_tree = rtree;
    if (uVar2 != 0) {
      uVar3 = 0;
      uVar4 = uVar2;
      while( true ) {
        r_insert_entry(rtree,&Data->Via[uVar3].BoundingBox,0);
        uVar2 = Data->ViaN;
        CVar1 = uVar2 + 1;
        if ((uVar2 == 0) || (uVar3 = uVar3 + (CVar1 - uVar4), uVar2 <= uVar3)) break;
        rtree = Data->via_tree;
        uVar4 = uVar2;
      }
    }
  }
  Data->ViaN = CVar1;
  return local_20 + uVar2;
}



// WARNING: Unknown calling convention

PadTypePtr GetPadMemory(ElementTypePtr Element)

{
  Boolean BVar1;
  Cardinal CVar2;
  uint uVar3;
  Cardinal n;
  uint uVar4;
  Boolean onBoard;
  Cardinal n_1;
  Cardinal sn;
  uint uVar5;
  PadTypePtr paVar6;
  bool bVar7;
  bool bVar8;
  byte bVar9;
  PadTypePtr local_28;
  int local_20;
  
  bVar9 = 0;
  local_28 = Element->Pad;
  uVar4 = Element->PadN;
  if (Element->PadMax <= uVar4) {
    if (PCB->Data->pad_tree == (rtree_t *)0x0) {
      CVar2 = Element->PadMax + 0x14;
      Element->PadMax = CVar2;
      local_28 = (PadTypePtr)MyRealloc(local_28,CVar2 * 0x68,"GetPadMemory()");
      uVar4 = 0x820;
      paVar6 = local_28 + Element->PadN;
      bVar8 = ((uint)paVar6 & 1) != 0;
      Element->Pad = local_28;
      if (bVar8) {
        *(undefined *)&(paVar6->BoundingBox).X1 = 0;
        uVar4 = 0x81f;
        paVar6 = (PadTypePtr)((int)&(paVar6->BoundingBox).X1 + 1);
      }
      if (((uint)paVar6 & 2) != 0) {
        *(undefined2 *)&(paVar6->BoundingBox).X1 = 0;
        uVar4 = uVar4 - 2;
        paVar6 = (PadTypePtr)((int)&(paVar6->BoundingBox).X1 + 2);
      }
      for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
        (paVar6->BoundingBox).X1 = 0;
        paVar6 = (PadTypePtr)((int)paVar6 + (uint)bVar9 * -8 + 4);
      }
      if ((uVar4 & 2) != 0) {
        *(undefined2 *)&(paVar6->BoundingBox).X1 = 0;
        paVar6 = (PadTypePtr)((int)&(paVar6->BoundingBox).X1 + 2);
      }
      if (bVar8) {
        *(undefined *)&(paVar6->BoundingBox).X1 = 0;
      }
    }
    else {
      bVar8 = false;
      uVar3 = uVar4;
      for (uVar5 = 0; (uVar3 != 0 && (uVar5 < uVar3)); uVar5 = uVar5 + (uVar4 == uVar3)) {
        BVar1 = r_delete_entry(PCB->Data->pad_tree,&Element->Pad[uVar5].BoundingBox);
        if (BVar1 != '\0') {
          bVar8 = true;
        }
        uVar3 = Element->PadN;
      }
      CVar2 = Element->PadMax + 0x14;
      Element->PadMax = CVar2;
      local_28 = (PadTypePtr)MyRealloc(local_28,CVar2 * 0x68,"GetPadMemory()");
      uVar4 = 0x820;
      paVar6 = local_28 + Element->PadN;
      bVar7 = ((uint)paVar6 & 1) != 0;
      Element->Pad = local_28;
      if (bVar7) {
        *(undefined *)&(paVar6->BoundingBox).X1 = 0;
        uVar4 = 0x81f;
        paVar6 = (PadTypePtr)((int)&(paVar6->BoundingBox).X1 + 1);
      }
      if (((uint)paVar6 & 2) != 0) {
        *(undefined2 *)&(paVar6->BoundingBox).X1 = 0;
        uVar4 = uVar4 - 2;
        paVar6 = (PadTypePtr)((int)&(paVar6->BoundingBox).X1 + 2);
      }
      for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
        (paVar6->BoundingBox).X1 = 0;
        paVar6 = (PadTypePtr)((int)paVar6 + (uint)bVar9 * -8 + 4);
      }
      if ((uVar4 & 2) != 0) {
        *(undefined2 *)&(paVar6->BoundingBox).X1 = 0;
        paVar6 = (PadTypePtr)((int)&(paVar6->BoundingBox).X1 + 2);
      }
      if (bVar7) {
        *(undefined *)&(paVar6->BoundingBox).X1 = 0;
      }
      if (bVar8) {
        uVar3 = Element->PadN;
        uVar5 = 0;
        local_20 = 0;
        uVar4 = uVar3;
        while ((uVar4 != 0 && (uVar5 < uVar4))) {
          r_insert_entry(PCB->Data->pad_tree,(BoxType *)((Element->Pad->Flags).t + local_20 + -0x18)
                         ,0);
          uVar4 = Element->PadN;
          if (Element->PadN == uVar3) {
            uVar5 = uVar5 + 1;
            local_20 = local_20 + 0x68;
            uVar4 = uVar3;
          }
        }
        goto LAB_080ac0de;
      }
    }
    uVar4 = Element->PadN;
  }
LAB_080ac0de:
  Element->PadN = uVar4 + 1;
  return local_28 + uVar4;
}



// WARNING: Unknown calling convention

PinTypePtr GetPinMemory(ElementTypePtr Element)

{
  uint uVar1;
  bool bVar2;
  Boolean BVar3;
  Cardinal CVar4;
  PinTypePtr pin;
  PinTypePtr paVar5;
  uint uVar6;
  rtree_t *rtree;
  uint uVar7;
  Cardinal n;
  Cardinal n_1;
  Cardinal sn;
  Cardinal sn_1;
  bool bVar8;
  byte bVar9;
  PinTypePtr local_24;
  uint local_20;
  
  bVar9 = 0;
  local_24 = Element->Pin;
  uVar6 = Element->PinN;
  uVar7 = Element->PinMax;
  if (uVar7 <= uVar6) {
    rtree = PCB->Data->pin_tree;
    if (rtree == (rtree_t *)0x0) {
      Element->PinMax = uVar7 + 0x14;
    }
    else {
      if (uVar6 != 0) {
        uVar7 = 0;
        paVar5 = local_24;
        bVar8 = false;
        while( true ) {
          BVar3 = r_delete_entry(rtree,&paVar5[uVar7].BoundingBox);
          bVar2 = true;
          if (BVar3 == '\0') {
            bVar2 = bVar8;
          }
          uVar1 = Element->PinN;
          if ((uVar1 == 0) || (uVar7 = (uVar1 + 1 + uVar7) - uVar6, uVar1 <= uVar7)) break;
          paVar5 = Element->Pin;
          rtree = PCB->Data->pin_tree;
          uVar6 = uVar1;
          bVar8 = bVar2;
        }
        CVar4 = Element->PinMax + 0x14;
        Element->PinMax = CVar4;
        local_24 = (PinTypePtr)MyRealloc(local_24,CVar4 * 0x4c,"GetPinMemory()");
        uVar7 = 0x5f0;
        paVar5 = local_24 + Element->PinN;
        bVar8 = ((uint)paVar5 & 1) != 0;
        Element->Pin = local_24;
        if (bVar8) {
          *(undefined *)&(paVar5->BoundingBox).X1 = 0;
          uVar7 = 0x5ef;
          paVar5 = (PinTypePtr)((int)&(paVar5->BoundingBox).X1 + 1);
        }
        if (((uint)paVar5 & 2) != 0) {
          *(undefined2 *)&(paVar5->BoundingBox).X1 = 0;
          uVar7 = uVar7 - 2;
          paVar5 = (PinTypePtr)((int)&(paVar5->BoundingBox).X1 + 2);
        }
        for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
          (paVar5->BoundingBox).X1 = 0;
          paVar5 = (PinTypePtr)((int)paVar5 + (uint)bVar9 * -8 + 4);
        }
        if ((uVar7 & 2) != 0) {
          *(undefined2 *)&(paVar5->BoundingBox).X1 = 0;
          paVar5 = (PinTypePtr)((int)&(paVar5->BoundingBox).X1 + 2);
        }
        if (bVar8) {
          *(undefined *)&(paVar5->BoundingBox).X1 = 0;
        }
        if (bVar2) {
          uVar7 = 0;
          uVar6 = 0;
          CVar4 = 1;
          local_20 = Element->PinN;
          if (Element->PinN != 0) {
            do {
              r_insert_entry(PCB->Data->pin_tree,&Element->Pin[uVar7].BoundingBox,0);
              uVar6 = Element->PinN;
              CVar4 = uVar6 + 1;
              if (uVar6 == 0) {
                uVar6 = 0;
                break;
              }
              uVar7 = uVar7 + (CVar4 - local_20);
              local_20 = uVar6;
            } while (uVar7 < uVar6);
          }
        }
        else {
          uVar6 = Element->PinN;
          CVar4 = uVar6 + 1;
        }
        goto LAB_080ac371;
      }
      Element->PinMax = uVar7 + 0x14;
    }
    local_24 = (PinTypePtr)MyRealloc(local_24,(uVar7 + 0x14) * 0x4c,"GetPinMemory()");
    uVar7 = 0x5f0;
    paVar5 = local_24 + Element->PinN;
    bVar8 = ((uint)paVar5 & 1) != 0;
    Element->Pin = local_24;
    if (bVar8) {
      *(undefined *)&(paVar5->BoundingBox).X1 = 0;
      uVar7 = 0x5ef;
      paVar5 = (PinTypePtr)((int)&(paVar5->BoundingBox).X1 + 1);
    }
    if (((uint)paVar5 & 2) != 0) {
      *(undefined2 *)&(paVar5->BoundingBox).X1 = 0;
      uVar7 = uVar7 - 2;
      paVar5 = (PinTypePtr)((int)&(paVar5->BoundingBox).X1 + 2);
    }
    for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
      (paVar5->BoundingBox).X1 = 0;
      paVar5 = (PinTypePtr)((int)paVar5 + (uint)bVar9 * -8 + 4);
    }
    if ((uVar7 & 2) != 0) {
      *(undefined2 *)&(paVar5->BoundingBox).X1 = 0;
      paVar5 = (PinTypePtr)((int)&(paVar5->BoundingBox).X1 + 2);
    }
    if (bVar8) {
      *(undefined *)&(paVar5->BoundingBox).X1 = 0;
    }
    uVar6 = Element->PinN;
  }
  CVar4 = uVar6 + 1;
LAB_080ac371:
  Element->PinN = CVar4;
  return local_24 + uVar6;
}



// WARNING: Unknown calling convention

int Netlist(int argc,char **argv,int x,int y)

{
  int iVar1;
  LibraryMenuTypePtr paVar2;
  LibraryEntryTypePtr paVar3;
  char *__s1;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  int iVar7;
  size_t __n;
  int iVar8;
  int result;
  Cardinal CVar9;
  char *pcVar10;
  int use_re;
  PCBTypePtr pPVar11;
  Cardinal CVar12;
  int i;
  int net_found;
  int j;
  LibraryMenuType *net;
  int in_GS_OFFSET;
  code *local_e0;
  uint local_dc;
  regex_t elt_pattern;
  regmatch_t match;
  char errorstring [128];
  
  pPVar11 = PCB;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar7 = 1;
  if (PCB == (PCBTypePtr)0x0) goto LAB_080ac696;
  if (argc == 0) {
LAB_080ac71e:
    Message("Net(find|select|rats|norats[,net[,pin]])");
    iVar7 = 1;
    goto LAB_080ac696;
  }
  pcVar10 = *argv;
  iVar7 = strcasecmp(pcVar10,"find");
  local_e0 = netlist_find;
  if (iVar7 != 0) {
    iVar7 = strcasecmp(pcVar10,"select");
    local_e0 = netlist_select;
    if (iVar7 != 0) {
      iVar7 = strcasecmp(pcVar10,"rats");
      local_e0 = netlist_rats;
      if (iVar7 != 0) {
        iVar7 = strcasecmp(pcVar10,"norats");
        local_e0 = netlist_norats;
        if (iVar7 != 0) goto LAB_080ac71e;
      }
    }
  }
  if (argc < 2) {
    CVar9 = (pPVar11->NetlistLib).MenuN;
    bVar5 = false;
LAB_080ac7da:
    bVar4 = false;
    if (CVar9 != 0) goto LAB_080ac4f7;
LAB_080ac7e4:
    if (2 < argc) {
      (*gui->log)("Net %s has no pin %s\n",argv[1],argv[2]);
      iVar7 = 1;
      goto LAB_080ac696;
    }
  }
  else {
    CVar9 = (pPVar11->NetlistLib).MenuN;
    if (CVar9 == 0) {
      pcVar10 = argv[1];
LAB_080ac7a2:
      iVar7 = regcomp((regex_t *)&elt_pattern,pcVar10,0xb);
      if (iVar7 != 0) {
        regerror(iVar7,(regex_t *)&elt_pattern,errorstring,0x80);
        Message("regexp error: %s\n",errorstring);
        regfree((regex_t *)&elt_pattern);
        iVar7 = 1;
        goto LAB_080ac696;
      }
      bVar5 = true;
      CVar9 = (PCB->NetlistLib).MenuN;
      pPVar11 = PCB;
      goto LAB_080ac7da;
    }
    CVar12 = 0;
    paVar2 = (pPVar11->NetlistLib).Menu;
    bVar5 = true;
    pcVar10 = argv[1];
    do {
      iVar7 = strcasecmp(pcVar10,paVar2[CVar12].Name + 2);
      if (iVar7 == 0) {
        bVar5 = false;
      }
      CVar12 = CVar12 + 1;
    } while (CVar12 != CVar9);
    if (bVar5) goto LAB_080ac7a2;
LAB_080ac4f7:
    bVar4 = false;
    bVar6 = false;
    local_dc = 0;
    do {
      net = (pPVar11->NetlistLib).Menu + local_dc;
      if (argc < 2) {
LAB_080ac778:
        bVar4 = true;
        (*local_e0)(net,0);
        pPVar11 = PCB;
      }
      else {
        if (bVar5) {
          iVar7 = regexec((regex_t *)&elt_pattern,net->Name + 2,1,(regmatch_t *)&match,0);
          pPVar11 = PCB;
        }
        else {
          iVar7 = strcasecmp(net->Name + 2,argv[1]);
        }
        if (iVar7 == 0) {
          if (argc == 2) goto LAB_080ac778;
          pcVar10 = argv[2];
          __n = strlen(pcVar10);
          if (net->EntryN != 0) {
            iVar7 = 0;
            do {
              paVar3 = net->Entry;
              __s1 = paVar3[iVar7].ListEntry;
              iVar8 = strcasecmp(__s1,pcVar10);
              if ((iVar8 == 0) ||
                 ((iVar8 = strncasecmp(__s1,pcVar10,__n), iVar8 == 0 && (__s1[__n] == '-')))) {
                (*local_e0)(net,paVar3 + iVar7);
                bVar6 = true;
                if (net->EntryN < iVar7 + 1U || net->EntryN == iVar7 + 1U) break;
              }
              else if (net->EntryN < iVar7 + 1U || net->EntryN == iVar7 + 1U) break;
              iVar7 = iVar7 + 1;
              pcVar10 = argv[2];
            } while( true );
          }
          bVar4 = true;
          pPVar11 = PCB;
        }
      }
      local_dc = local_dc + 1;
    } while (local_dc <= (pPVar11->NetlistLib).MenuN && (pPVar11->NetlistLib).MenuN != local_dc);
    if (!bVar6) goto LAB_080ac7e4;
  }
  if (!bVar4) {
    (*gui->log)("No net named %s\n",argv[1]);
  }
  iVar7 = 0;
  if (bVar5) {
    regfree((regex_t *)&elt_pattern);
    iVar7 = 0;
  }
LAB_080ac696:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar7;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void netlist_norats(LibraryMenuType *net,LibraryEntryType_conflict *pin)

{
  *net->Name = '*';
  net->flag = '\0';
  hid_action("NetlistChanged");
  return;
}



// WARNING: Unknown calling convention

void netlist_rats(LibraryMenuType *net,LibraryEntryType_conflict *pin)

{
  *net->Name = ' ';
  net->flag = '\x01';
  hid_action("NetlistChanged");
  return;
}



// WARNING: Unknown calling convention

void netlist_select(LibraryMenuType *net,LibraryEntryType_conflict *pin)

{
  Boolean BVar1;
  int x;
  LocationType X;
  int y;
  ConnectionType conn;
  
  BVar1 = SeekPad(net->Entry,&conn,'\0');
  if (BVar1 == '\0') {
    return;
  }
  if (conn.type == 0x100) {
    X = *(LocationType *)((int)conn.ptr2 + 0x34);
    y = *(int *)((int)conn.ptr2 + 0x38);
  }
  else {
    if (conn.type != 0x200) {
      return;
    }
    X = *(LocationType *)((int)conn.ptr2 + 0x2c);
    y = *(int *)((int)conn.ptr2 + 0x30);
  }
  LookupConnection(X,y,'\x01',1,0x40);
  return;
}



// WARNING: Unknown calling convention

void netlist_find(LibraryMenuType *net,LibraryEntryType_conflict *pin)

{
  Boolean BVar1;
  int x;
  LocationType X;
  int y;
  ConnectionType conn;
  
  BVar1 = SeekPad(net->Entry,&conn,'\0');
  if (BVar1 == '\0') {
    return;
  }
  if (conn.type == 0x100) {
    X = *(LocationType *)((int)conn.ptr2 + 0x34);
    y = *(int *)((int)conn.ptr2 + 0x38);
  }
  else {
    if (conn.type != 0x200) {
      return;
    }
    X = *(LocationType *)((int)conn.ptr2 + 0x2c);
    y = *(int *)((int)conn.ptr2 + 0x30);
  }
  LookupConnection(X,y,'\x01',1,4);
  return;
}



// WARNING: Unknown calling convention

void register_netlist_action_list(void)

{
  hid_register_actions(netlist_action_list,2);
  return;
}



// WARNING: Unknown calling convention

LibraryMenuTypePtr netname_to_netname(char *netname)

{
  uint uVar1;
  LibraryMenuTypePtr paVar2;
  int iVar3;
  int i;
  uint uVar4;
  LibraryMenuTypePtr paVar5;
  
  if (((*netname == ' ') || (*netname == '*')) && (netname[1] == ' ')) {
    netname = netname + 2;
  }
  uVar1 = (PCB->NetlistLib).MenuN;
  if (uVar1 != 0) {
    paVar2 = (PCB->NetlistLib).Menu;
    uVar4 = 0;
    do {
      paVar5 = paVar2 + uVar4;
      iVar3 = strcmp(paVar5->Name + 2,netname);
      if (iVar3 == 0) {
        return paVar5;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar1);
  }
  return (LibraryMenuTypePtr)0x0;
}



// WARNING: Unknown calling convention

LibraryMenuTypePtr netnode_to_netname(char *nodename)

{
  uint uVar1;
  LibraryMenuTypePtr paVar2;
  uint uVar3;
  LibraryEntryTypePtr paVar4;
  LibraryMenuTypePtr paVar5;
  int iVar6;
  int j;
  uint uVar7;
  uint local_28;
  
  uVar1 = (PCB->NetlistLib).MenuN;
  if (uVar1 != 0) {
    paVar2 = (PCB->NetlistLib).Menu;
    local_28 = 0;
    do {
      paVar5 = paVar2 + local_28;
      uVar3 = paVar5->EntryN;
      if (uVar3 != 0) {
        paVar4 = paVar5->Entry;
        uVar7 = 0;
        do {
          iVar6 = strcmp(paVar4[uVar7].ListEntry,nodename);
          if (iVar6 == 0) {
            return paVar5;
          }
          uVar7 = uVar7 + 1;
        } while (uVar7 < uVar3);
      }
      local_28 = local_28 + 1;
    } while (local_28 < uVar1);
  }
  return (LibraryMenuTypePtr)0x0;
}



// WARNING: Unknown calling convention

void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)

{
  if (yy_current_buffer != new_buffer) {
    if (yy_current_buffer != (YY_BUFFER_STATE)0x0) {
      *yy_c_buf_p = yy_hold_char;
      yy_current_buffer->yy_buf_pos = yy_c_buf_p;
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }
    yy_n_chars = new_buffer->yy_n_chars;
    yy_current_buffer = new_buffer;
    yy_c_buf_p = new_buffer->yy_buf_pos;
    yyin = new_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    yy_did_buffer_switch_on_eof = 1;
    yytext = yy_c_buf_p;
  }
  return;
}



// WARNING: Unknown calling convention

void yy_load_buffer_state(void)

{
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  yytext = yy_c_buf_p;
  yyin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  return;
}



// WARNING: Unknown calling convention

void yy_flush_buffer(YY_BUFFER_STATE b)

{
  char *pcVar1;
  bool bVar2;
  
  if (b != (YY_BUFFER_STATE)0x0) {
    b->yy_n_chars = 0;
    *b->yy_ch_buf = '\0';
    b->yy_ch_buf[1] = '\0';
    pcVar1 = b->yy_ch_buf;
    bVar2 = b == yy_current_buffer;
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    b->yy_buf_pos = pcVar1;
    if (bVar2) {
      yy_c_buf_p = pcVar1;
      yytext = pcVar1;
      yy_n_chars = b->yy_n_chars;
      yyin = b->yy_input_file;
      yy_hold_char = *pcVar1;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void yy_delete_buffer(YY_BUFFER_STATE b)

{
  if (b == (YY_BUFFER_STATE)0x0) {
    return;
  }
  if (b == yy_current_buffer) {
    yy_current_buffer = (YY_BUFFER_STATE)0x0;
  }
  if (b->yy_is_our_buffer == 0) {
    free(b);
    return;
  }
  free(b->yy_ch_buf);
  free(b);
  return;
}



// WARNING: Unknown calling convention

void yy_fatal_error(char *msg)

{
  __fprintf_chk(stderr,1,&DAT_08148577,msg);
                    // WARNING: Subroutine does not return
  exit(2);
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE yy_scan_buffer(char *base,yy_size_t size)

{
  YY_BUFFER_STATE b;
  
  if (((size < 2) || (base[size - 2] != '\0')) || (base[size - 1] != '\0')) {
    b = (YY_BUFFER_STATE)0x0;
  }
  else {
    b = (YY_BUFFER_STATE)calloc(1,0x28);
    if (b == (YY_BUFFER_STATE)0x0) {
      yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
    b->yy_buf_size = size - 2;
    b->yy_ch_buf = base;
    b->yy_buf_pos = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = (FILE *)0x0;
    b->yy_n_chars = size - 2;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = 0;
    yy_switch_to_buffer(b);
  }
  return b;
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE yy_scan_bytes(char *bytes,yy_size_t len)

{
  char *base;
  uint uVar1;
  yy_size_t i;
  YY_BUFFER_STATE pyVar2;
  YY_BUFFER_STATE b;
  yy_size_t n;
  
  base = (char *)calloc(1,len + 2);
  if (base == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
  }
  if (len != 0) {
    uVar1 = 0;
    do {
      base[uVar1] = bytes[uVar1];
      uVar1 = uVar1 + 1;
    } while (uVar1 < len);
  }
  base[len + 1] = '\0';
  base[len] = '\0';
  pyVar2 = yy_scan_buffer(base,len + 2);
  if (pyVar2 == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("bad buffer in yy_scan_bytes()");
  }
  pyVar2->yy_is_our_buffer = 1;
  return pyVar2;
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE yy_scan_string(char *yy_str)

{
  char cVar1;
  yy_size_t len_00;
  yy_size_t len;
  YY_BUFFER_STATE pyVar2;
  
  len_00 = 0;
  cVar1 = *yy_str;
  while (cVar1 != '\0') {
    len_00 = len_00 + 1;
    cVar1 = yy_str[len_00];
  }
  pyVar2 = yy_scan_bytes(yy_str,len_00);
  return pyVar2;
}



// WARNING: Unknown calling convention

void yy_init_buffer(YY_BUFFER_STATE b,FILE *file)

{
  int iVar1;
  int iVar2;
  
  yy_flush_buffer(b);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  if (file != (FILE *)0x0) {
    iVar1 = fileno((FILE *)file);
    iVar1 = isatty(iVar1);
    iVar2 = 1;
    if (0 < iVar1) goto LAB_080ace90;
  }
  iVar2 = 0;
LAB_080ace90:
  b->yy_is_interactive = iVar2;
  return;
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE yy_create_buffer(FILE *file,int size)

{
  YY_BUFFER_STATE b;
  char *pcVar1;
  
  b = (YY_BUFFER_STATE)calloc(1,0x28);
  if (b == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_buf_size = size;
  pcVar1 = (char *)calloc(1,size + 2);
  b->yy_ch_buf = pcVar1;
  if (pcVar1 == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_is_our_buffer = 1;
  yy_init_buffer(b,file);
  return b;
}



// WARNING: Unknown calling convention

void yyrestart(FILE *input_file)

{
  if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
    yy_current_buffer = yy_create_buffer(yyin,0x4000);
  }
  yy_init_buffer(yy_current_buffer,input_file);
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  yytext = yy_c_buf_p;
  yyin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  return;
}



// WARNING: Unknown calling convention

int Parse(char *Executable,char *Path,char *Filename,char *Parameter)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  size_t sVar4;
  char *__filename;
  int returncode;
  int used_popen;
  size_t l;
  
  if ((Executable != (char *)0x0) && (*Executable != '\0')) {
    if (Parse::command != (char *)0x0) {
      SaveFree(Parse::command);
      Parse::command = (char *)0x0;
    }
    Parse::command = EvaluateFilename(Executable,Path,Filename,Parameter);
    if (*Parse::command != '\0') {
      bVar1 = true;
      yyin = (FILE *)popen(Parse::command,"r");
      if (yyin != (FILE *)0x0) goto joined_r0x080ad148;
      yyin = (FILE *)0x0;
    }
    PopenErrorMessage(Parse::command);
    return 1;
  }
  iVar2 = 2;
  if (Path != (char *)0x0) {
    sVar4 = strlen(Path);
    iVar2 = sVar4 + 2;
  }
  sVar4 = strlen(Filename);
  __filename = (char *)calloc(1,sVar4 + iVar2);
  if (__filename == (char *)0x0) {
    __fprintf_chk(stderr,1,"Parse():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  if ((Path == (char *)0x0) || (*Path == '\0')) {
    __sprintf_chk(__filename,1,0xffffffff,"%s",Filename);
  }
  else {
    __sprintf_chk(__filename,1,0xffffffff,"%s%s%s",Path,"/",Filename);
  }
  yyin = (FILE *)fopen(__filename,"r");
  if (yyin == (FILE *)0x0) {
    Message("Can\'t open %s for reading\n",__filename);
    return 1;
  }
  bVar1 = false;
  free(__filename);
joined_r0x080ad148:
  if (Parse::firsttime == '\0') {
    yyrestart(yyin);
  }
  Parse::firsttime = '\0';
  yylineno = 1;
  yyfilename = Filename;
  if (PCB != (PCBTypePtr)0x0) {
    SaveTMPData();
  }
  iVar2 = yyparse();
  RemoveTMPData();
  yy_delete_buffer(yy_current_buffer);
  if (bVar1) {
    iVar3 = pclose((FILE *)yyin);
  }
  else {
    iVar3 = fclose((FILE *)yyin);
  }
  if (iVar3 == 0) {
    return iVar2;
  }
  return 1;
}



// WARNING: Unknown calling convention

int ParseFont(FontTypePtr Ptr,char *Filename)

{
  char *__s;
  char *Path;
  char *p;
  char *path;
  int local_20;
  
  yyPCB = (PCBTypePtr)0x0;
  yyElement = (ElementTypePtr)0x0;
  yyFont = Ptr;
  __s = (char *)__strdup(Settings.FontPath);
  Path = strtok(__s,":");
  if ((Path == (char *)0x0) || (*Path == '\0')) {
    local_20 = 0;
  }
  else {
    while( true ) {
      Message("Looking for %s in %s\n",Filename,Path);
      local_20 = Parse(Settings.FontCommand,Path,Filename,(char *)0x0);
      if (local_20 == 0) break;
      Path = strtok((char *)0x0,":");
      if ((Path == (char *)0x0) || (*Path == '\0')) goto LAB_080ad2eb;
    }
    Message("Found %s in %s\n",Filename,Path);
  }
LAB_080ad2eb:
  free(__s);
  return local_20;
}



// WARNING: Unknown calling convention

int ParsePCB(PCBTypePtr Ptr,char *Filename)

{
  int iVar1;
  
  yyData = (DataTypePtr)0x0;
  yyFont = (FontTypePtr)0x0;
  yyElement = (ElementTypePtr)0x0;
  yyPCB = Ptr;
  iVar1 = Parse(Settings.FileCommand,Settings.FilePath,Filename,(char *)0x0);
  return iVar1;
}



// WARNING: Unknown calling convention

int ParseLibraryEntry(DataTypePtr Ptr,char *Template)

{
  int iVar1;
  
  yyPCB = (PCBTypePtr)0x0;
  yyElement = (ElementTypePtr)0x0;
  yyData = Ptr;
  yyFont = &PCB->Font;
  iVar1 = Parse(Settings.LibraryCommand,Settings.LibraryPath,Settings.LibraryFilename,Template);
  return iVar1;
}



// WARNING: Unknown calling convention

int ParseElementFile(DataTypePtr Ptr,char *Filename)

{
  int iVar1;
  
  yyPCB = (PCBTypePtr)0x0;
  yyElement = (ElementTypePtr)0x0;
  yyData = Ptr;
  yyFont = &PCB->Font;
  iVar1 = Parse((char *)0x0,(char *)0x0,Filename,(char *)0x0);
  return iVar1;
}



// WARNING: Unknown calling convention

int parse_number(double scale)

{
  double local_14 [2];
  
  __isoc99_sscanf(yytext,&DAT_0814a85d,local_14);
  local_14[0] = scale * local_14[0];
  if (local_14[0] < 0.0) {
    local_14[0] = local_14[0] - 0.49;
  }
  else {
    local_14[0] = local_14[0] + 0.49;
  }
  yylval.number = (int)ROUND(local_14[0]);
  return 0x102;
}



// WARNING: Unknown calling convention

int yylex(void)

{
  yy_state_type yy_current_state;
  yy_state_type yy_next_state;
  int iVar1;
  int yy_act;
  YY_CHAR yy_c;
  char *yy_cp_1;
  size_t Number;
  char *pcVar2;
  char *p2;
  char *pcVar3;
  int i;
  int c;
  short sVar4;
  char *source;
  size_t __n;
  char *yy_cp_2;
  YY_CHAR yy_c_3;
  byte *pbVar5;
  int yyl;
  byte bVar11;
  YY_CHAR yy_c_2;
  char cVar12;
  YY_CHAR yy_c_1;
  int iVar6;
  char *p1;
  char *pcVar7;
  int num_to_read;
  size_t sVar8;
  int iVar9;
  char *pcVar10;
  char *yy_cp;
  byte *pbVar13;
  int ret_val;
  char *yy_bp;
  char *dest;
  bool bVar14;
  double dVar15;
  yy_state_type *local_2c;
  yy_state_type *local_28;
  YY_BUFFER_STATE local_24;
  
  if (yy_init != 0) {
    yy_init = 0;
    iVar1 = 1;
    if (yy_start != 0) {
      iVar1 = yy_start;
    }
    if (yyin == (FILE *)0x0) {
      yyin = stdin;
    }
    if (yyout == (FILE *)0x0) {
      yyout = stdout;
    }
    yy_start = iVar1;
    if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
      yy_current_buffer = yy_create_buffer(yyin,0x4000);
    }
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
  }
LAB_080ad4fc:
  *yy_c_buf_p = yy_hold_char;
  local_24 = (YY_BUFFER_STATE)(yy_state_buf + 1);
  yy_state_buf[0] = yy_start;
  yy_next_state = yy_start;
  local_28 = (yy_state_type *)yy_c_buf_p;
LAB_080ad51c:
  sVar4 = yy_base[yy_next_state];
  do {
    bVar11 = *(byte *)(yy_ec + (byte)*yy_c_buf_p);
    while( true ) {
      iVar1 = (uint)bVar11 + (int)sVar4;
      if (yy_chk[iVar1] == yy_next_state) break;
      yy_next_state = (yy_state_type)yy_def[yy_next_state];
      if (0xb3 < yy_next_state) {
        bVar11 = *(byte *)(yy_meta + bVar11);
      }
      sVar4 = yy_base[yy_next_state];
    }
    yy_next_state = (yy_state_type)yy_nxt[iVar1];
    yy_c_buf_p = (char *)((byte *)yy_c_buf_p + 1);
    *(yy_state_type *)local_24 = yy_next_state;
    local_2c = (yy_state_type *)((int)local_24 + 4);
    sVar4 = yy_base[yy_next_state];
    pbVar13 = (byte *)yy_c_buf_p;
    local_24 = (YY_BUFFER_STATE)local_2c;
  } while (sVar4 != 0xe8);
LAB_080ad5a1:
  iVar1 = local_2c[-1];
  yy_state_ptr = local_2c + -1;
  sVar4 = yy_accept[iVar1];
  while ((yy_lp = (int)sVar4, yy_lp == 0 || (yy_accept[iVar1 + 1] <= yy_lp))) {
    yy_state_ptr = yy_state_ptr + -1;
    pbVar13 = pbVar13 + -1;
    iVar1 = *yy_state_ptr;
    sVar4 = yy_accept[iVar1];
  }
  yyleng = (int)pbVar13 - (int)local_28;
  iVar1 = (int)yy_acclist[yy_lp];
  yy_hold_char = *pbVar13;
  yy_full_match = (char *)pbVar13;
  yytext = (char *)local_28;
  *pbVar13 = 0;
  yy_c_buf_p = (char *)pbVar13;
  if ((iVar1 != 0x2e) && (0 < yyleng)) {
    iVar6 = 0;
    do {
      while (yytext[iVar6] != '\n') {
        iVar6 = iVar6 + 1;
        if (iVar6 == yyleng) goto LAB_080ad655;
      }
      iVar6 = iVar6 + 1;
      yylineno = yylineno + 1;
    } while (iVar6 != yyleng);
  }
LAB_080ad655:
  switch(iVar1) {
  default:
    yy_fatal_error("fatal flex scanner internal error--no action found");
    goto LAB_080ad4fc;
  case 1:
    return 0x106;
  case 2:
    return 0x107;
  case 3:
    return 0x113;
  case 4:
    return 0x117;
  case 5:
    return 0x121;
  case 6:
    return 0x120;
  case 7:
    return 0x122;
  case 8:
    return 0x114;
  case 9:
    return 0x108;
  case 10:
    return 0x111;
  case 0xb:
    return 0x112;
  case 0xc:
    return 0x109;
  case 0xd:
    return 0x10b;
  case 0xe:
    return 0x10a;
  case 0xf:
    return 0x10d;
  case 0x10:
    return 0x10e;
  case 0x11:
    return 0x10f;
  case 0x12:
    return 0x118;
  case 0x13:
    return 0x110;
  case 0x14:
    return 0x116;
  case 0x15:
    return 0x115;
  case 0x16:
    return 0x119;
  case 0x17:
    return 0x11a;
  case 0x18:
    return 0x11b;
  case 0x19:
    return 0x11c;
  case 0x1a:
    return 0x10c;
  case 0x1b:
    return 0x11d;
  case 0x1c:
    return 0x11e;
  case 0x1d:
    return 0x11f;
  case 0x1e:
    return 0x123;
  case 0x1f:
    yylval.number = (int)yytext[1];
    return 0x103;
  case 0x20:
    iVar1 = parse_number(3937.0079);
    return iVar1;
  case 0x21:
    iVar1 = parse_number(3.9370079);
    return iVar1;
  case 0x22:
    iVar1 = parse_number(100000.0);
    return iVar1;
  case 0x23:
    iVar1 = parse_number(100.0);
    return iVar1;
  case 0x24:
    iVar1 = parse_number(1.0);
    return iVar1;
  case 0x25:
    __isoc99_sscanf(yytext,&DAT_0814a861,&yylval);
    return 0x102;
  case 0x26:
    dVar15 = c_strtod(yytext);
    yylval.floating = (float)dVar15;
    return 0x104;
  case 0x27:
    if (yyleng == 2) {
      yylval.number = 0;
    }
    else {
      Number = yyleng - 1;
      yyleng = yyleng + -2;
      pcVar2 = (char *)MyCalloc(Number,1,"LEX");
      pcVar10 = yytext;
      yylval.string = pcVar2;
      while (yyleng != 0) {
        pcVar7 = pcVar10 + 1;
        cVar12 = *pcVar7;
        iVar1 = yyleng + -1;
        if (cVar12 == '\\') {
          pcVar7 = pcVar10 + 2;
          cVar12 = *pcVar7;
          iVar1 = yyleng + -2;
        }
        yyleng = iVar1;
        *pcVar2 = cVar12;
        pcVar2 = pcVar2 + 1;
        pcVar10 = pcVar7;
      }
      yyleng = yyleng + -1;
      *pcVar2 = '\0';
    }
    return 0x105;
  case 0x28:
  case 0x29:
  case 0x2a:
  case 0x2b:
    goto LAB_080ad4fc;
  case 0x2c:
    return (int)*yytext;
  case 0x2d:
    fwrite(yytext,yyleng,1,(FILE *)yyout);
    goto LAB_080ad4fc;
  case 0x2e:
    break;
  case 0x2f:
    return 0;
  }
  iVar6 = -1 - (int)yytext;
  *pbVar13 = yy_hold_char;
  local_24 = yy_current_buffer;
  iVar1 = yy_n_chars;
  if (yy_current_buffer->yy_buffer_status == 0) {
    iVar1 = yy_current_buffer->yy_n_chars;
    yy_n_chars = iVar1;
    yy_current_buffer->yy_input_file = yyin;
    local_24->yy_buffer_status = 1;
  }
  pcVar2 = yytext;
  pcVar10 = local_24->yy_ch_buf;
  if (pcVar10 + iVar1 < yy_c_buf_p) {
    if (pcVar10 + iVar1 + 1 < yy_c_buf_p) {
      yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
      local_24 = yy_current_buffer;
    }
    if (local_24->yy_fill_buffer == 0) {
      local_28 = (yy_state_type *)yytext;
      if ((int)yy_c_buf_p - (int)yytext != 1) goto LAB_080ad88e;
    }
    else {
      pcVar7 = yy_c_buf_p + (-1 - (int)yytext);
      if (0 < (int)pcVar7) {
        pcVar3 = (char *)0x0;
        do {
          pcVar10[(int)pcVar3] = pcVar2[(int)pcVar3];
          pcVar3 = pcVar3 + 1;
          local_24 = yy_current_buffer;
        } while (pcVar3 != pcVar7);
      }
      if (local_24->yy_buffer_status == 2) {
        yy_n_chars = 0;
        local_24->yy_n_chars = 0;
LAB_080adbbe:
        if (pcVar7 == (char *)0x0) {
          yyrestart(yyin);
          iVar9 = 1;
          local_24 = yy_current_buffer;
          iVar1 = yy_n_chars;
        }
        else {
          iVar9 = 2;
          local_24->yy_buffer_status = 2;
          iVar1 = yy_n_chars;
        }
      }
      else {
        num_to_read = ~(uint)pcVar7;
        sVar8 = num_to_read + local_24->yy_buf_size;
        if ((int)sVar8 < 1) {
          do {
            yy_fatal_error(
                          "input buffer overflow, can\'t enlarge buffer because scanner uses REJECT"
                          );
          } while( true );
        }
        __n = 0x2000;
        if ((int)sVar8 < 0x2001) {
          __n = sVar8;
        }
        sVar8 = 0;
        if (local_24->yy_is_interactive == 0) {
          yy_n_chars = fread(local_24->yy_ch_buf + (int)pcVar7,1,__n,(FILE *)yyin);
          sVar8 = yy_n_chars;
          if ((yy_n_chars == 0) && (iVar1 = ferror((FILE *)yyin), sVar8 = yy_n_chars, iVar1 != 0)) {
            yy_fatal_error("input in flex scanner failed");
            sVar8 = yy_n_chars;
          }
        }
        else {
          do {
            iVar1 = _IO_getc((_IO_FILE *)yyin);
            if (iVar1 == -1) {
              iVar1 = ferror((FILE *)yyin);
              if (iVar1 != 0) {
                yy_fatal_error("input in flex scanner failed");
              }
              break;
            }
            if (iVar1 == 10) {
              yy_current_buffer->yy_ch_buf[(int)(pcVar7 + sVar8)] = '\n';
              sVar8 = sVar8 + 1;
              break;
            }
            pcVar10 = pcVar7 + sVar8;
            sVar8 = sVar8 + 1;
            yy_current_buffer->yy_ch_buf[(int)pcVar10] = (char)iVar1;
          } while ((int)sVar8 < (int)__n);
        }
        yy_n_chars = sVar8;
        iVar1 = yy_n_chars;
        local_24 = yy_current_buffer;
        iVar9 = 0;
        bVar14 = yy_n_chars == 0;
        yy_current_buffer->yy_n_chars = yy_n_chars;
        if (bVar14) goto LAB_080adbbe;
      }
      yy_n_chars = (int)(pcVar7 + iVar1);
      local_24->yy_ch_buf[yy_n_chars] = '\0';
      yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = '\0';
      local_24 = yy_current_buffer;
      yytext = yy_current_buffer->yy_ch_buf;
      if (iVar9 != 1) {
        local_28 = (yy_state_type *)yytext;
        if (iVar9 != 2) {
          local_28 = yy_state_buf;
          yy_c_buf_p = (char *)(pbVar13 + iVar6 + (int)yytext);
          yy_state_buf[0] = yy_start;
          yy_next_state = yy_start;
          local_24 = (YY_BUFFER_STATE)yytext;
          while (local_28 = local_28 + 1, yy_state_ptr = local_28, local_24 < yy_c_buf_p) {
            bVar11 = 1;
            if (*(byte *)local_24 != 0) {
              bVar11 = *(byte *)(yy_ec + *(byte *)local_24);
            }
            while( true ) {
              iVar1 = (int)yy_base[yy_next_state] + (uint)bVar11;
              if (yy_next_state == yy_chk[iVar1]) break;
              yy_next_state = (yy_state_type)yy_def[yy_next_state];
              if (0xb3 < yy_next_state) {
                bVar11 = *(byte *)(yy_meta + bVar11);
              }
            }
            yy_next_state = (yy_state_type)yy_nxt[iVar1];
            local_24 = (YY_BUFFER_STATE)((int)local_24 + 1);
            *local_28 = yy_next_state;
          }
          local_28 = (yy_state_type *)yytext;
          goto LAB_080adcba;
        }
LAB_080ad88e:
        local_2c = yy_state_buf;
        pbVar13 = (byte *)(local_24->yy_ch_buf + yy_n_chars);
        local_24 = (YY_BUFFER_STATE)local_28;
        yy_state_buf[0] = yy_start;
        iVar1 = yy_start;
        while (local_2c = local_2c + 1, local_24 < pbVar13) {
          bVar11 = 1;
          if (*(byte *)local_24 != 0) {
            bVar11 = *(byte *)(yy_ec + *(byte *)local_24);
          }
          while( true ) {
            iVar6 = (int)yy_base[iVar1] + (uint)bVar11;
            if (iVar1 == yy_chk[iVar6]) break;
            iVar1 = (int)yy_def[iVar1];
            if (0xb3 < iVar1) {
              bVar11 = *(byte *)(yy_meta + bVar11);
            }
          }
          iVar1 = (int)yy_nxt[iVar6];
          local_24 = (YY_BUFFER_STATE)((int)local_24 + 1);
          *local_2c = iVar1;
        }
        goto LAB_080ad5a1;
      }
    }
    yy_did_buffer_switch_on_eof = 0;
    iVar1 = yywrap();
    if (iVar1 == 0) {
      if (yy_did_buffer_switch_on_eof == 0) {
        yyrestart(yyin);
      }
      goto LAB_080ad4fc;
    }
    yy_c_buf_p = yytext;
    iVar1 = (yy_start + -1) / 2 + 0x2f;
    goto LAB_080ad655;
  }
  local_28 = (yy_state_type *)yytext;
  local_2c = yy_state_buf;
  pbVar13 = pbVar13 + iVar6 + (int)yytext;
  yy_state_buf[0] = yy_start;
  iVar1 = yy_start;
  yy_c_buf_p = (char *)pbVar13;
  for (pbVar5 = (byte *)yytext; local_2c = local_2c + 1, pbVar5 < pbVar13; pbVar5 = pbVar5 + 1) {
    if (*pbVar5 == 0) {
      yy_c_3 = '\x01';
    }
    else {
      yy_c_3 = *(YY_CHAR *)(yy_ec + *pbVar5);
    }
    while( true ) {
      iVar6 = (int)yy_base[iVar1] + (uint)yy_c_3;
      if (iVar1 == yy_chk[iVar6]) break;
      iVar1 = (int)yy_def[iVar1];
      if (0xb3 < iVar1) {
        yy_c_3 = *(YY_CHAR *)(yy_meta + yy_c_3);
      }
    }
    iVar1 = (int)yy_nxt[iVar6];
    *local_2c = iVar1;
  }
  while( true ) {
    iVar6 = (int)yy_base[iVar1];
    if (iVar1 == *(short *)(iVar6 + 0x814b261 + iVar6 + 1)) break;
    iVar1 = (int)yy_def[iVar1];
  }
  yy_next_state = (yy_state_type)*(short *)(iVar6 + 0x814b4a1 + iVar6 + 1);
  if (yy_next_state == 0xb3) goto LAB_080ad5a1;
  *local_2c = yy_next_state;
  local_2c = local_2c + 1;
  pbVar13 = (byte *)yy_c_buf_p;
  if (yy_next_state != 0) goto LAB_080adecd;
  goto LAB_080ad5a1;
LAB_080adecd:
  yy_c_buf_p = yy_c_buf_p + 1;
  yy_state_ptr = local_2c;
LAB_080adcba:
  local_24 = (YY_BUFFER_STATE)yy_state_ptr;
  goto LAB_080ad51c;
}



// WARNING: Unknown calling convention

int yywrap(void)

{
  return 1;
}



// WARNING: Unknown calling convention

int yyerror(char *s)

{
  Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n",yyfilename,
          yylineno,s);
  return 0;
}



// WARNING: Unknown calling convention

int yyparse(void)

{
  FontTypePtr pFVar1;
  byte bVar2;
  int iVar3;
  Cardinal CVar4;
  Cardinal CVar5;
  LineTypePtr pLVar6;
  LineTypePtr pLVar7;
  FlagType Flags;
  FlagType Flags_00;
  FlagType Flags_01;
  FlagType Flags_02;
  FlagType Flags_03;
  FlagType Flags_04;
  FlagType Flags_05;
  FlagType Flags_06;
  FlagType Flags_07;
  FlagType Flags_08;
  FlagType Flags_09;
  FlagType Flags_10;
  FlagType Flags_11;
  FlagType Flags_12;
  FlagType Flags_13;
  FlagType Flags_14;
  FlagType Flags_15;
  FlagType Flags_16;
  FlagType Flags_17;
  FlagType Flags_18;
  FlagType Flags_19;
  FlagType Flags_20;
  FlagType Flags_21;
  FlagType Flags_22;
  FlagType Flags_23;
  FlagType Flags_24;
  FlagType Flags_25;
  FlagType Flags_26;
  FlagType Flags_27;
  FlagType Flags_28;
  PCBTypePtr pPVar8;
  PCBTypePtr pPVar9;
  uint yystacksize;
  short *psVar10;
  uint uVar11;
  int i;
  DataTypePtr paVar12;
  int i_1;
  ElementTypePtr paVar13;
  rtree_t *prVar14;
  int yytoken;
  uint uVar15;
  yytype_int16 *yyss;
  int iVar16;
  yytype_int16 *yyssp;
  int iVar17;
  int yystate;
  int yyn;
  int j;
  YYSTYPE_conflict *yyvsp;
  int yyresult;
  undefined4 *puVar18;
  SymbolType *pSVar19;
  ulong *puVar20;
  Cardinal *pCVar21;
  BDimension *pBVar22;
  YYSTYPE_conflict *yyvs;
  undefined4 *puVar23;
  LineTypePtr *ppLVar24;
  FlagType *pFVar25;
  Cardinal *pCVar26;
  BDimension *pBVar27;
  int in_GS_OFFSET;
  byte bVar28;
  char *pcVar29;
  FontTypePtr in_stack_fffff2c8;
  code *in_stack_fffff2cc;
  char *in_stack_fffff2d0;
  FontTypePtr in_stack_fffff2d4;
  LineTypePtr in_stack_fffff2d8;
  LineTypePtr in_stack_fffff2dc;
  LineTypePtr in_stack_fffff2e0;
  char *in_stack_fffff2e4;
  char *in_stack_fffff2e8;
  uchar *in_stack_fffff2ec;
  uchar *TextY;
  uint in_stack_fffff2f0;
  BDimension in_stack_fffff2f4;
  FlagType in_stack_fffff2f8;
  undefined4 uVar30;
  undefined4 *local_cec;
  undefined4 *local_ce8;
  undefined4 *local_ce4;
  short *local_ce0;
  char *local_cd0;
  short *local_ccc;
  LineTypePtr local_cc8;
  LineTypePtr local_cc4;
  LineTypePtr local_cc0;
  LineTypePtr local_cbc;
  uchar *local_cb8;
  LayerTypePtr local_cb4;
  int local_cb0;
  uint local_cac;
  int local_ca8;
  FontTypePtr local_ca4;
  uint local_ca0;
  uint local_c9c;
  short *local_c98;
  FontTypePtr local_c94;
  ulong local_c8c [6];
  YYSTYPE_conflict yyvsa [200];
  yytype_int16 yyssa [200];
  undefined4 local_184 [3];
  undefined4 local_178 [3];
  undefined4 local_16c [3];
  undefined4 local_160 [3];
  undefined4 local_154 [3];
  undefined4 local_148 [3];
  undefined4 local_13c [3];
  undefined4 local_130 [3];
  undefined4 local_124 [3];
  undefined4 local_118 [3];
  undefined4 local_10c [3];
  undefined4 local_100 [3];
  undefined4 local_f4 [3];
  undefined4 local_e8 [3];
  undefined4 local_dc [3];
  undefined4 local_d0 [3];
  undefined4 local_c4 [3];
  undefined4 local_b8 [3];
  undefined4 local_ac [3];
  undefined4 local_a0 [3];
  undefined4 local_94 [3];
  undefined4 local_88 [3];
  undefined4 local_7c [3];
  undefined4 local_70 [3];
  undefined4 local_64 [3];
  undefined4 local_58 [3];
  undefined4 local_4c [3];
  undefined4 local_40 [3];
  YYSTYPE_conflict yyval;
  char p_number [8];
  int local_20;
  
  bVar28 = 0;
  local_ccc = yyssa;
  local_ca4 = (FontTypePtr)yyvsa;
  yyn = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_cec = local_184;
  local_ce8 = local_178;
  local_ce4 = local_16c;
  yynerrs = 0;
  yychar = -2;
  local_ca0 = 200;
  local_cb0 = 0;
  local_ca8 = 199;
  local_cc0 = in_stack_fffff2dc;
  local_cc4 = in_stack_fffff2e0;
  local_cd0 = in_stack_fffff2e8;
  local_cc8 = (LineTypePtr)in_stack_fffff2ec;
  local_ce0 = local_ccc;
  local_c98 = local_ccc;
  local_c94 = local_ca4;
  do {
    *local_ccc = (short)yyn;
    if (local_c98 + local_ca8 <= local_ccc) {
      if (local_ca0 < 10000) {
        local_ca0 = local_ca0 * 2;
        if (10000 < local_ca0) {
          local_ca0 = 10000;
        }
        psVar10 = (short *)calloc(1,local_ca0 * 0xe + 0xb);
        if (psVar10 != (short *)0x0) {
          iVar17 = (int)local_ccc - (int)local_c98 >> 1;
          memcpy(psVar10,local_c98,(iVar17 + 1) * 2);
          in_stack_fffff2cc = (code *)((iVar17 + 1) * 0xc);
          pFVar1 = (FontTypePtr)(psVar10 + ((local_ca0 * 2 + 0xb) / 0xc) * 6);
          memcpy(pFVar1,local_ca4,(size_t)in_stack_fffff2cc);
          if (local_ce0 != local_c98) {
            free(local_c98);
          }
          local_ca8 = local_ca0 - 1;
          local_ccc = psVar10 + iVar17;
          local_c98 = psVar10;
          if (local_ccc < psVar10 + local_ca8) {
            local_c94 = (FontTypePtr)((int)pFVar1->Symbol + iVar17 * 0xc + -0x18);
            in_stack_fffff2c8 = local_ca4;
            local_ca4 = pFVar1;
            goto yybackup;
          }
          iVar17 = 0;
          yyresult = 1;
          goto LAB_080aece1;
        }
      }
      yyresult = 2;
      Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n");
      iVar17 = 0;
      goto LAB_080aece1;
    }
yybackup:
    pFVar1 = local_c94;
    iVar17 = (int)yypact[yyn];
    if (iVar17 != -0x1a8) {
      if (yychar == -2) {
        yychar = yylex();
      }
      if (yychar < 1) {
        yychar = 0;
        uVar15 = 0;
      }
      else {
        uVar15 = 2;
        if ((uint)yychar < 0x124) {
          uVar15 = (uint)""[yychar];
        }
      }
      uVar11 = uVar15 + iVar17;
      if ((0x24d < uVar11) || ((int)yycheck[uVar11] != uVar15)) goto yydefault;
      yyn = (int)yytable[uVar11];
      if (yyn < 1) {
        if ((yyn == -0x5d) || (yyn == 0)) goto yyerrlab;
        local_c9c = -yyn;
        goto yyreduce;
      }
      if (yyn != 10) {
        local_cb0 = local_cb0 + -1 + (uint)(local_cb0 == 0);
        iVar17 = -2;
        if (yychar == 0) {
          iVar17 = yychar;
        }
        pCVar21 = (Cardinal *)&(local_c94->DefaultSymbol).Y1;
        *pCVar21 = yylval.number;
        (local_c94->DefaultSymbol).X2 = yylval._4_4_;
        (local_c94->DefaultSymbol).Y2 = yylval._8_4_;
        yychar = iVar17;
        local_c94 = (FontTypePtr)pCVar21;
        goto yynewstate;
      }
yyreturn:
      iVar17 = 0;
      yyresult = 0;
LAB_080aece1:
      local_ccc = (short *)((int)local_ccc + iVar17);
      psVar10 = local_c98;
      if (local_c98 != local_ccc) {
        psVar10 = (short *)((int)local_ccc +
                           (~((int)local_ccc + (-2 - (int)local_c98)) & 0xfffffffeU));
      }
LAB_080ae3a3:
      if (local_ce0 != psVar10) {
        free(local_c98);
      }
      if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
        return yyresult;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
yydefault:
    local_c9c = (uint)""[yyn];
    if (local_c9c == 0) {
yyerrlab:
      if (local_cb0 == 0) {
        yynerrs = yynerrs + 1;
        in_stack_fffff2d0 = "syntax error";
        in_stack_fffff2c8 = (FontTypePtr)yyfilename;
        in_stack_fffff2cc = (code *)yylineno;
        Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n");
      }
      else if (local_cb0 == 3) {
        if (yychar < 1) {
          if (yychar == 0) {
            iVar17 = 0;
            yyresult = 1;
            goto LAB_080aece1;
          }
        }
        else {
          yychar = -2;
        }
      }
      while ((((iVar17 == -0x1a8 || (uVar15 = iVar17 + 1, 0x24d < uVar15)) ||
              (*(short *)(iVar17 + 0x814c521 + uVar15) != 1)) ||
             (yyn = (int)*(short *)(iVar17 + 0x814c9c1 + uVar15), yyn < 1))) {
        if (local_ccc == local_c98) {
          yyresult = 1;
          psVar10 = local_c98;
          goto LAB_080ae3a3;
        }
        local_ccc = local_ccc + -1;
        local_c94 = (FontTypePtr)&local_c94[-1].Symbol[0xff].Height;
        iVar17 = (int)yypact[*local_ccc];
      }
      if (yyn != 10) {
        pCVar21 = (Cardinal *)&(local_c94->DefaultSymbol).Y1;
        *pCVar21 = yylval.number;
        (local_c94->DefaultSymbol).X2 = yylval._4_4_;
        (local_c94->DefaultSymbol).Y2 = yylval._8_4_;
        local_cb0 = 3;
        local_c94 = (FontTypePtr)pCVar21;
        goto yynewstate;
      }
      goto yyreturn;
    }
yyreduce:
    paVar12 = yyData;
    paVar13 = yyElement;
    pPVar8 = yyPCB;
    pPVar9 = PCB;
    local_cac = (uint)""[local_c9c];
    iVar17 = (1 - local_cac) * 0xc;
    yyval.number = *(int *)((int)local_c94 + (1 - local_cac) * 0xc);
    yyval._4_4_ = *(undefined4 *)(iVar17 + 4 + (int)local_c94);
    yyval._8_4_ = *(undefined4 *)(iVar17 + 8 + (int)local_c94);
    switch(local_c9c) {
    case 5:
    case 0x3f:
      yyresult = 1;
      iVar17 = local_cac * -2;
      goto LAB_080aece1;
    case 6:
      if (yyPCB != (PCBTypePtr)0x0) {
        i_1 = 0;
        do {
          LayerFlag[i_1] = '\0';
          i_1 = i_1 + 1;
        } while (i_1 != 0x12);
        layer_group_string = (char *)0x0;
        yyFont = &yyPCB->Font;
        paVar12 = yyPCB->Data;
        yyData = paVar12;
        paVar12->pcb = yyPCB;
        paVar12->LayerN = 0;
        pPVar9 = PCB;
        break;
      }
LAB_080b088f:
      pcVar29 = "illegal fileformat\n";
LAB_080b0885:
      Message(pcVar29);
      goto LAB_080af56c;
    case 7:
      if (layer_group_string == (char *)0x0) {
        layer_group_string = Settings.Groups;
      }
      CreateNewPCBPost(yyPCB,0);
      in_stack_fffff2cc = (code *)yyData->LayerN;
      in_stack_fffff2c8 = (FontTypePtr)&yyPCB->LayerGroups;
      iVar17 = ParseGroupString(layer_group_string,(LayerGroupTypePtr)in_stack_fffff2c8,
                                (int)in_stack_fffff2cc);
      if (iVar17 != 0) {
        pcVar29 = "illegal layer-group string\n";
        goto LAB_080b0885;
      }
      local_cb4 = (LayerTypePtr)0x0;
      PCB = yyPCB;
      paVar12 = yyData;
      if (-2 < yyData->LayerN) {
        do {
          if (paVar12->Layer[(int)local_cb4].PolygonN != 0) {
            uVar15 = 0;
            do {
              uVar11 = uVar15 + 1;
              in_stack_fffff2cc = (code *)(paVar12->Layer[(int)local_cb4].Polygon + uVar15);
              in_stack_fffff2c8 = (FontTypePtr)(paVar12->Layer + (int)local_cb4);
              InitClip(paVar12,(LayerTypePtr)in_stack_fffff2c8,(PolygonType *)in_stack_fffff2cc);
              pCVar21 = &yyData->Layer[(int)local_cb4].PolygonN;
              paVar12 = yyData;
              uVar15 = uVar11;
            } while (uVar11 <= *pCVar21 && *pCVar21 != uVar11);
          }
          local_cb4 = (LayerTypePtr)((int)local_cb4 + 1);
        } while ((int)local_cb4 <= paVar12->LayerN + 1);
      }
      break;
    case 8:
      PreLoadElementPCB();
      layer_group_string = (char *)0x0;
      pPVar9 = PCB;
      break;
    case 9:
      LayerFlag[0] = '\x01';
      LayerFlag[1] = '\x01';
      yyData->LayerN = 2;
      PostLoadElementPCB();
      pPVar9 = PCB;
      break;
    case 10:
      if ((yyData == (DataTypePtr)0x0) || (yyFont == (FontTypePtr)0x0)) goto LAB_080b088f;
      i = 0;
      do {
        LayerFlag[i] = '\0';
        i = i + 1;
      } while (i != 0x12);
      yyData->LayerN = 0;
      pPVar9 = PCB;
      break;
    case 0xe:
      if (yyFont == (FontTypePtr)0x0) {
        Message("illegal fileformat\n");
        goto LAB_080af56c;
      }
      yyFont->Valid = '\0';
      pFVar1 = yyFont;
      iVar17 = 0;
      do {
        (&pFVar1->Symbol[0].Valid)[iVar17] = '\0';
        iVar17 = iVar17 + 0x1c;
        pPVar9 = PCB;
      } while (iVar17 != 0x1c00);
      break;
    case 0xf:
      yyFont->Valid = '\x01';
      SetFontInfo(yyFont);
      pPVar9 = PCB;
      break;
    case 0x11:
      if (0x1324007 < local_c94[-1].Symbol[0xff].Height) {
        Message(
               "ERROR:  The file you are attempting to load is in a format\nwhich is too new for this version of pcb.  To load this file\nyou need a version of pcb which is >= %d.  If you are\nusing a version built from cvs sources, the source date\nmust be >= %d.  This copy of pcb can only read files\nup to file version %d.\n"
               );
        goto LAB_080af56c;
      }
      break;
    case 0x12:
      pcVar29 = (char *)local_c94[-1].Symbol[0xff].Height;
      yyPCB->MaxWidth = 10000000;
      pPVar8->MaxHeight = 10000000;
      pPVar8->Name = pcVar29;
      pPVar9 = PCB;
      break;
    case 0x13:
      yyPCB->Name = (char *)local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->MaxWidth = local_c94[-1].Symbol[0xff].LineN * 100;
      pPVar8->MaxHeight = local_c94[-1].Symbol[0xff].Height * 100;
      pPVar9 = PCB;
      break;
    case 0x14:
      yyPCB->Name = (char *)local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->MaxWidth = local_c94[-1].Symbol[0xff].LineN;
      pPVar8->MaxHeight = local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x19:
      yyPCB->Grid = (double)(local_c94[-1].Symbol[0xfe].Delta * 100);
      pPVar8->GridOffsetX = local_c94[-1].Symbol[0xff].LineN * 100;
      pPVar8->GridOffsetY = local_c94[-1].Symbol[0xff].Height * 100;
      pPVar9 = PCB;
      break;
    case 0x1a:
      yyPCB->Grid = (double)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      pPVar8->GridOffsetX = local_c94[-1].Symbol[0xfe].Delta * 100;
      pPVar8->GridOffsetY = local_c94[-1].Symbol[0xff].LineN * 100;
      Settings.DrawGrid = local_c94[-1].Symbol[0xff].Height != 0;
      pPVar9 = PCB;
      break;
    case 0x1b:
      yyPCB->Grid = (double)((float)local_c94[-1].Symbol[0xfe].LineMax * 100.0);
      pPVar8->GridOffsetX = local_c94[-1].Symbol[0xfe].Delta * 100;
      pPVar8->GridOffsetY = local_c94[-1].Symbol[0xff].LineN * 100;
      Settings.DrawGrid = local_c94[-1].Symbol[0xff].Height != 0;
      pPVar9 = PCB;
      break;
    case 0x1c:
      yyPCB->Grid = (double)(float)local_c94[-1].Symbol[0xfe].LineMax;
      pPVar8->GridOffsetX = local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->GridOffsetY = local_c94[-1].Symbol[0xff].LineN;
      Settings.DrawGrid = local_c94[-1].Symbol[0xff].Height != 0;
      pPVar9 = PCB;
      break;
    case 0x1d:
      yyPCB->CursorX = local_c94[-1].Symbol[0xfe].Delta * 100;
      pPVar8->CursorY = local_c94[-1].Symbol[0xff].LineN * 100;
      pPVar8->Zoom = (double)(local_c94[-1].Symbol[0xff].Height * 2);
      pPVar9 = PCB;
      break;
    case 0x1e:
      yyPCB->CursorX = local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->CursorY = local_c94[-1].Symbol[0xff].LineN;
      pPVar8->Zoom = (double)local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x1f:
      yyPCB->CursorX = local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->CursorY = local_c94[-1].Symbol[0xff].LineN;
      pPVar8->Zoom = (double)(float)local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x22:
      yyPCB->IsleArea = (double)(float)local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x24:
      yyPCB->ThermScale = (double)(float)local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x29:
      yyPCB->Bloat = local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->Shrink = local_c94[-1].Symbol[0xff].LineN;
      pPVar8->minWid = local_c94[-1].Symbol[0xff].Height;
      pPVar8->minRing = local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x2a:
      yyPCB->Bloat = local_c94[-1].Symbol[0xfe].LineMax;
      pPVar8->Shrink = local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->minWid = local_c94[-1].Symbol[0xff].LineN;
      pPVar8->minSlk = local_c94[-1].Symbol[0xff].Height;
      pPVar8->minRing = local_c94[-1].Symbol[0xff].LineN;
      pPVar9 = PCB;
      break;
    case 0x2b:
      yyPCB->Bloat = local_c94[-1].Symbol[0xfd].Width;
      pPVar8->Shrink = (int)local_c94[-1].Symbol[0xfe].Line;
      pPVar8->minWid = local_c94[-1].Symbol[0xfe].LineMax;
      pPVar8->minSlk = local_c94[-1].Symbol[0xfe].Delta;
      pPVar8->minDrill = local_c94[-1].Symbol[0xff].LineN;
      pPVar8->minRing = local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x2c:
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xff].Height & 0xfffff);
      MakeFlags((uint)in_stack_fffff2c8);
      goto LAB_080af5e9;
    case 0x2d:
      in_stack_fffff2cc = yyerror;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xff].Height;
      string_to_pcbflags((char *)in_stack_fffff2c8,yyerror);
LAB_080af5e9:
      puVar20 = local_c8c;
      pFVar25 = &pPVar8->Flags;
      for (iVar17 = 3; pPVar9 = PCB, iVar17 != 0; iVar17 = iVar17 + -1) {
        pFVar25->f = *puVar20;
        puVar20 = puVar20 + (uint)bVar28 * -2 + 1;
        pFVar25 = (FlagType *)((int)pFVar25 + (uint)bVar28 * -8 + 4);
      }
      break;
    case 0x2f:
      layer_group_string = (char *)local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x31:
      in_stack_fffff2cc = (code *)0x64;
      pcVar29 = (char *)local_c94[-1].Symbol[0xff].Height;
      goto LAB_080af544;
    case 0x32:
      in_stack_fffff2cc = (code *)&DAT_00000001;
      pcVar29 = (char *)local_c94[-1].Symbol[0xff].Height;
LAB_080af544:
      in_stack_fffff2c8 = (FontTypePtr)yyPCB->RouteStyle;
      iVar17 = ParseRouteString(pcVar29,(RouteStyleTypePtr)in_stack_fffff2c8,(int)in_stack_fffff2cc)
      ;
      pPVar9 = PCB;
      if (iVar17 != 0) {
        Message("illegal route-style string\n");
LAB_080af56c:
        yyresult = 1;
        iVar17 = local_cac * -2;
        goto LAB_080aece1;
      }
      break;
    case 0x39:
      attr_list = &yyPCB->Attributes;
      break;
    case 0x3d:
      yyElement = (ElementTypePtr)0x0;
      break;
    case 0x45:
      pBVar22 = &local_c94[-1].Symbol[0xff].Height;
      pBVar27 = (BDimension *)&stack0xfffff2e4;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *pBVar27 = *pBVar22;
        pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
        pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
      }
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfd].Width;
      in_stack_fffff2cc = *(code **)&local_c94[-1].Symbol[0xfd].Valid;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xfc].Height;
      Flags_17.t._0_4_ = local_cd0;
      Flags_17.f = (ulong)in_stack_fffff2e4;
      Flags_17.t._4_4_ = local_cc8;
      CreateNewVia(yyData,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,(BDimension)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,(char *)local_cc4,Flags_17);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x46:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      puVar18 = local_40;
      puVar23 = (undefined4 *)&stack0xfffff2e4;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_cc0 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      in_stack_fffff2d8 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2d4 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2cc = (code *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].Height * 100);
      goto LAB_080b0547;
    case 0x47:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      local_cb4 = (LayerTypePtr)local_c94[-1].Symbol[0xfe].Line;
      CVar4 = local_c94[-1].Symbol[0xfe].LineMax;
      puVar18 = local_4c;
      puVar23 = (undefined4 *)&stack0xfffff2e4;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_cc0 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      in_stack_fffff2d8 =
           (LineTypePtr)((int)(((FlagType *)&local_cb4->LineMax)->t + (CVar4 - 0x18)) * 100);
      in_stack_fffff2d4 = (FontTypePtr)(CVar4 * 100);
      in_stack_fffff2d0 = (char *)((int)local_cb4 * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2c8 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      goto LAB_080b0547;
    case 0x48:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      puVar18 = local_58;
      puVar23 = (undefined4 *)&stack0xfffff2e4;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_cc0 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      in_stack_fffff2d4 = (FontTypePtr)0xbb8;
      in_stack_fffff2d8 = (LineTypePtr)&((SymbolType *)((int)in_stack_fffff2d0 + 0x18))[0x14].Width;
      in_stack_fffff2cc = (code *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
LAB_080b0547:
      Flags_16.t._0_4_ = local_cd0;
      Flags_16.f = (ulong)in_stack_fffff2e4;
      Flags_16.t._4_4_ = local_cc8;
      CreateNewVia(yyData,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,(BDimension)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,(char *)local_cc4,Flags_16);
LAB_080afabe:
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x49:
      iVar17 = local_c94[-1].Symbol[0xfe].Delta;
      local_cc0 = (LineTypePtr)(iVar17 * 0x28);
      if ((iVar17 * -0x27 < 400) && (400 < iVar17)) {
        local_cc0 = (LineTypePtr)(iVar17 + -400);
      }
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100);
      puVar18 = local_64;
      puVar23 = (undefined4 *)&stack0xfffff2e4;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d4 = (FontTypePtr)0xbb8;
      in_stack_fffff2d8 = (LineTypePtr)&((SymbolType *)((int)in_stack_fffff2d0 + 0x18))[0x14].Width;
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2c8 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      Flags_15.t._0_4_ = local_cd0;
      Flags_15.f = (ulong)in_stack_fffff2e4;
      Flags_15.t._4_4_ = local_cc8;
      CreateNewVia(yyData,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,3000,(BDimension)in_stack_fffff2d8,
                   (BDimension)local_cc0,(char *)local_cc4,Flags_15);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x4a:
      pBVar22 = &local_c94[-1].Symbol[0xff].Height;
      pBVar27 = (BDimension *)&stack0xfffff2e4;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *pBVar27 = *pBVar22;
        pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
        pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
      }
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfd].Width;
      in_stack_fffff2c8 = *(FontTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      Flags_14.t._0_4_ = local_cd0;
      Flags_14.f = (ulong)in_stack_fffff2e4;
      Flags_14.t._4_4_ = local_cc8;
      local_cc4 = (LineTypePtr)Settings.RatThickness;
      CreateNewRat(yyData,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                   (Cardinal)in_stack_fffff2d8,(Cardinal)local_cc0,Settings.RatThickness,Flags_14);
      pPVar9 = PCB;
      break;
    case 0x4b:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      puVar18 = local_70;
      puVar23 = (undefined4 *)&stack0xfffff2e4;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2c8 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      Flags_13.t._0_4_ = local_cd0;
      Flags_13.f = (ulong)in_stack_fffff2e4;
      Flags_13.t._4_4_ = local_cc8;
      local_cc4 = (LineTypePtr)Settings.RatThickness;
      CreateNewRat(yyData,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                   (Cardinal)in_stack_fffff2d8,(Cardinal)local_cc0,Settings.RatThickness,Flags_13);
      pPVar9 = PCB;
      break;
    case 0x4c:
      CVar4 = local_c94[-1].Symbol[0xfe].LineMax;
      pCVar21 = &local_c94[-1].Symbol[0xfe].LineMax;
      if ((0x11 < CVar4 - 1) || (*(char *)((int)&Menu + CVar4 + 3) != '\0')) goto LAB_080b08bd;
      Layer = (FontTypePtr)(yyData->Layer + (CVar4 - 1));
      yyData->Layer[CVar4 - 1].Name = (char *)local_c94[-1].Symbol[0xfe].Delta;
      *(undefined *)((int)&Menu + *pCVar21 + 3) = 1;
      CVar4 = *pCVar21;
      pPVar9 = PCB;
      if (paVar12->LayerN + 2 < (int)CVar4) {
        paVar12->LayerN = CVar4 - 2;
        pPVar9 = PCB;
      }
      break;
    case 0x58:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      local_cb4 = (LayerTypePtr)local_c94[-1].Symbol[0xfe].Line;
      CVar4 = local_c94[-1].Symbol[0xfe].LineMax;
      puVar18 = local_7c;
      puVar23 = (undefined4 *)&stack0xfffff2d8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2d4 = (FontTypePtr)((CVar4 + local_c94[-1].Symbol[0xff].LineN) * 100);
      in_stack_fffff2d0 =
           (char *)((int)(((FlagType *)&local_cb4->LineMax)->t +
                         local_c94[-1].Symbol[0xfe].Delta + -0x18) * 100);
      in_stack_fffff2cc = (code *)(CVar4 * 100);
      in_stack_fffff2c8 = (FontTypePtr)((int)local_cb4 * 100);
      Flags_05.t._0_4_ = local_cc0;
      Flags_05.f = (ulong)in_stack_fffff2d8;
      Flags_05.t._4_4_ = local_cc4;
      CreateNewPolygonFromRectangle
                ((LayerTypePtr)Layer,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc
                 ,(LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,Flags_05);
      pPVar9 = PCB;
      break;
    case 0x5c:
      attr_list = (AttributeListTypePtr)(Layer->Symbol + 2);
      break;
    case 0x5e:
      pCVar21 = &local_c94[-1].Symbol[0xff].LineN;
      pCVar26 = (Cardinal *)&stack0xfffff2c8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *pCVar26 = *pCVar21;
        pCVar21 = pCVar21 + (uint)bVar28 * -2 + 1;
        pCVar26 = pCVar26 + (uint)bVar28 * -2 + 1;
      }
      Flags.t._0_4_ = in_stack_fffff2cc;
      Flags.f = (ulong)in_stack_fffff2c8;
      Flags.t._4_4_ = in_stack_fffff2d0;
      Polygon = (FontTypePtr)CreateNewPolygon((LayerTypePtr)Layer,Flags);
      pPVar9 = PCB;
      break;
    case 0x5f:
      if ((LineTypePtr)Polygon->Symbol[0].LineMax < (LineTypePtr)0x3) {
        Message(
               "WARNING parsing file \'%s\'\n    line:        %i\n    description: \'ignored polygon (< 3 points)\'\n"
               );
        in_stack_fffff2c8 = (FontTypePtr)0x8;
        in_stack_fffff2cc = (code *)Layer;
        in_stack_fffff2d0 = (char *)Polygon;
        in_stack_fffff2d4 = Polygon;
        DestroyObject(yyData,8,Layer,Polygon,Polygon);
        pPVar9 = PCB;
      }
      else {
        SetPolygonBoundingBox((PolygonTypePtr)Polygon);
        pFVar1 = Layer;
        prVar14 = (rtree_t *)Layer->Symbol[1].LineN;
        if (prVar14 == (rtree_t *)0x0) {
          prVar14 = r_create_tree((BoxType **)0x0,0,0);
          pFVar1->Symbol[1].LineN = (Cardinal)prVar14;
          prVar14 = (rtree_t *)Layer->Symbol[1].LineN;
        }
        in_stack_fffff2cc = (code *)0x0;
        in_stack_fffff2c8 = Polygon;
        r_insert_entry(prVar14,(BoxType *)Polygon,0);
        pPVar9 = PCB;
      }
      break;
    case 0x60:
      pBVar22 = &local_c94[-1].Symbol[0xff].Height;
      pBVar27 = (BDimension *)&stack0xfffff2e0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *pBVar27 = *pBVar22;
        pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
        pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
      }
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfd].Width;
      in_stack_fffff2c8 = *(FontTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      Flags_10.t._0_4_ = in_stack_fffff2e4;
      Flags_10.f = (ulong)local_cc4;
      Flags_10.t._4_4_ = local_cd0;
      CreateNewLineOnLayer
                ((LayerTypePtr)Layer,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc
                 ,(LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                 (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,Flags_10);
      pPVar9 = PCB;
      break;
    case 0x61:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      puVar18 = local_88;
      puVar23 = (undefined4 *)&stack0xfffff2e0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc0 = (LineTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      CVar4 = local_c94[-1].Symbol[0xfe].Delta;
      CVar5 = local_c94[-1].Symbol[0xfe].LineMax;
      pLVar6 = local_c94[-1].Symbol[0xfe].Line;
      pLVar7 = (LineTypePtr)local_c94[-1].Symbol[0xfd].Width;
      iVar17 = *(int *)&local_c94[-1].Symbol[0xfd].Valid;
LAB_080b0133:
      in_stack_fffff2d8 = (LineTypePtr)(CVar4 * 100);
      in_stack_fffff2d4 = (FontTypePtr)(CVar5 * 100);
      in_stack_fffff2d0 = (char *)((int)pLVar6 * 100);
      in_stack_fffff2cc = (code *)((int)pLVar7 * 100);
      in_stack_fffff2c8 = (FontTypePtr)(iVar17 * 100);
      Flags_09.t._0_4_ = in_stack_fffff2e4;
      Flags_09.f = (ulong)local_cc4;
      Flags_09.t._4_4_ = local_cd0;
      CreateNewLineOnLayer
                ((LayerTypePtr)Layer,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc
                 ,(LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                 (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,Flags_09);
      pPVar9 = PCB;
      break;
    case 0x62:
      uVar15 = local_c94[-1].Symbol[0xff].Height;
      if ((uVar15 & 0x10) == 0) {
        OldFlags(uVar15);
        puVar18 = local_94;
        puVar23 = (undefined4 *)&stack0xfffff2e0;
        for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
          *puVar23 = *puVar18;
          puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
          puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
        }
        local_cc0 = (LineTypePtr)0xbb8;
        CVar4 = pFVar1[-1].Symbol[0xff].LineN;
        CVar5 = pFVar1[-1].Symbol[0xfe].Delta;
        pLVar6 = (LineTypePtr)pFVar1[-1].Symbol[0xfe].LineMax;
        pLVar7 = pFVar1[-1].Symbol[0xfe].Line;
        iVar17 = pFVar1[-1].Symbol[0xfd].Width;
        goto LAB_080b0133;
      }
      break;
    case 99:
      pBVar22 = &local_c94[-1].Symbol[0xff].Height;
      pBVar27 = (BDimension *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *pBVar27 = *pBVar22;
        pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
        pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xfe].LineMax;
      local_cc4 = local_c94[-1].Symbol[0xfe].Line;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xfd].Width;
      in_stack_fffff2d0 = *(char **)&local_c94[-1].Symbol[0xfd].Valid;
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfc].Height;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xfc].LineN;
      Flags_24.t._0_4_ = local_cc8;
      Flags_24.f = (ulong)local_cd0;
      Flags_24.t[4] = (char)in_stack_fffff2f0;
      Flags_24.t[5] = (char)(in_stack_fffff2f0 >> 8);
      Flags_24.t[6] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_24.t[7] = (char)(in_stack_fffff2f0 >> 0x18);
      CreateNewArcOnLayer((LayerTypePtr)Layer,(LocationType)in_stack_fffff2c8,
                          (LocationType)in_stack_fffff2cc,(BDimension)in_stack_fffff2d0,
                          (BDimension)in_stack_fffff2d4,(int)in_stack_fffff2d8,(int)local_cc0,
                          (BDimension)local_cc4,(BDimension)in_stack_fffff2e4,Flags_24);
      pPVar9 = PCB;
      break;
    case 100:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      puVar18 = local_a0;
      puVar23 = (undefined4 *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = (char *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_cc4 = local_c94[-1].Symbol[0xfe].Line;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2d0 = (char *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      iVar17 = local_c94[-1].Symbol[0xfc].Height;
      CVar4 = local_c94[-1].Symbol[0xfc].LineN;
      goto LAB_080affd4;
    case 0x65:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfd].Width * 100);
      puVar18 = local_ac;
      puVar23 = (undefined4 *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = (char *)0xbb8;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      iVar17 = *(int *)&local_c94[-1].Symbol[0xfd].Valid;
      CVar4 = local_c94[-1].Symbol[0xfc].Height;
      in_stack_fffff2d4 = (FontTypePtr)in_stack_fffff2d0;
LAB_080affd4:
      local_cc4 = (LineTypePtr)((int)local_cc4 * 100);
      in_stack_fffff2cc = (code *)(iVar17 * 100);
      in_stack_fffff2c8 = (FontTypePtr)(CVar4 * 100);
      Flags_23.t._0_4_ = local_cc8;
      Flags_23.f = (ulong)local_cd0;
      Flags_23.t[4] = (char)in_stack_fffff2f0;
      Flags_23.t[5] = (char)(in_stack_fffff2f0 >> 8);
      Flags_23.t[6] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_23.t[7] = (char)(in_stack_fffff2f0 >> 0x18);
      CreateNewArcOnLayer((LayerTypePtr)Layer,(LocationType)in_stack_fffff2c8,
                          (LocationType)in_stack_fffff2cc,(BDimension)in_stack_fffff2d0,
                          (BDimension)in_stack_fffff2d4,(int)in_stack_fffff2d8,(int)local_cc0,
                          (BDimension)local_cc4,(BDimension)in_stack_fffff2e4,Flags_23);
      pPVar9 = PCB;
      break;
    case 0x66:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      puVar18 = local_b8;
      puVar23 = (undefined4 *)&stack0xfffff2e0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc0 = (LineTypePtr)pFVar1[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)0x64;
      bVar2 = *(byte *)&pFVar1[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)(uint)bVar2;
      in_stack_fffff2d0 = (char *)(pFVar1[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2cc = (code *)((int)pFVar1[-1].Symbol[0xfe].Line * 100);
      Flags_08.t._0_4_ = in_stack_fffff2e4;
      Flags_08.f = (ulong)local_cc4;
      Flags_08.t._4_4_ = local_cd0;
      in_stack_fffff2c8 = yyFont;
      CreateNewText((LayerTypePtr)Layer,yyFont,(LocationType)in_stack_fffff2cc,
                    (LocationType)in_stack_fffff2d0,bVar2,100,(char *)local_cc0,Flags_08);
      SaveFree((void *)pFVar1[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x67:
      uVar15 = local_c94[-1].Symbol[0xff].Height;
      if ((uVar15 & 0x400) == 0) {
        OldFlags(uVar15);
        puVar18 = local_d0;
        puVar23 = (undefined4 *)&stack0xfffff2e0;
        for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
          *puVar23 = *puVar18;
          puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
          puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
        }
        local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
        in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        bVar2 = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        in_stack_fffff2d4 = (FontTypePtr)(uint)bVar2;
        in_stack_fffff2d0 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
        in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
        Flags_12.t._0_4_ = in_stack_fffff2e4;
        Flags_12.f = (ulong)local_cc4;
        Flags_12.t._4_4_ = local_cd0;
        in_stack_fffff2c8 = yyFont;
        CreateNewText((LayerTypePtr)Layer,yyFont,(LocationType)in_stack_fffff2cc,
                      (LocationType)in_stack_fffff2d0,bVar2,(int)in_stack_fffff2d8,(char *)local_cc0
                      ,Flags_12);
      }
      else {
        local_cb4 = yyData->Layer + ((uVar15 >> 7 ^ 1) & 1) + yyData->LayerN;
        OldFlags(uVar15);
        puVar18 = local_c4;
        puVar23 = (undefined4 *)&stack0xfffff2e0;
        for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
          *puVar23 = *puVar18;
          puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
          puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
        }
        local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
        in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        bVar2 = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        in_stack_fffff2d4 = (FontTypePtr)(uint)bVar2;
        in_stack_fffff2d0 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
        in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
        Flags_07.t._0_4_ = in_stack_fffff2e4;
        Flags_07.f = (ulong)local_cc4;
        Flags_07.t._4_4_ = local_cd0;
        in_stack_fffff2c8 = yyFont;
        CreateNewText(local_cb4,yyFont,(LocationType)in_stack_fffff2cc,
                      (LocationType)in_stack_fffff2d0,bVar2,(int)in_stack_fffff2d8,(char *)local_cc0
                      ,Flags_07);
      }
      goto LAB_080afe1c;
    case 0x68:
      local_cb8 = (uchar *)local_c94[-1].Symbol[0xff].Height;
      pBVar22 = &local_c94[-1].Symbol[0xff].Height;
      in_stack_fffff2c8 = yyFont;
      if (((uint)local_cb8 & 0x400) == 0) {
        pBVar27 = (BDimension *)&stack0xfffff2e0;
        for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
          *pBVar27 = *pBVar22;
          pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
          pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
        }
        local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
        in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        bVar2 = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        in_stack_fffff2d4 = (FontTypePtr)(uint)bVar2;
        in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].Line;
        in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfd].Width;
        Flags_11.t._0_4_ = in_stack_fffff2e4;
        Flags_11.f = (ulong)local_cc4;
        Flags_11.t._4_4_ = local_cd0;
        CreateNewText((LayerTypePtr)Layer,yyFont,(LocationType)in_stack_fffff2cc,
                      (LocationType)in_stack_fffff2d0,bVar2,(int)in_stack_fffff2d8,(char *)local_cc0
                      ,Flags_11);
      }
      else {
        pBVar27 = (BDimension *)&stack0xfffff2e0;
        for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
          *pBVar27 = *pBVar22;
          pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
          pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
        }
        local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
        in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        bVar2 = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        in_stack_fffff2d4 = (FontTypePtr)(uint)bVar2;
        in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].Line;
        in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfd].Width;
        Flags_06.t._0_4_ = in_stack_fffff2e4;
        Flags_06.f = (ulong)local_cc4;
        Flags_06.t._4_4_ = local_cd0;
        CreateNewText(yyData->Layer + (((uint)local_cb8 >> 7 ^ 1) & 1) + yyData->LayerN,yyFont,
                      (LocationType)in_stack_fffff2cc,(LocationType)in_stack_fffff2d0,bVar2,
                      (int)in_stack_fffff2d8,(char *)local_cc0,Flags_06);
      }
LAB_080afe1c:
      SaveFree((void *)pFVar1[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x6b:
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xff].Height * 100);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      goto LAB_080afd4b;
    case 0x6c:
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xff].Height;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
LAB_080afd4b:
      CreateNewPointInPolygon
                ((PolygonTypePtr)Polygon,(LocationType)in_stack_fffff2c8,
                 (LocationType)in_stack_fffff2cc);
      pPVar9 = PCB;
      break;
    case 0x73:
      MakeFlags(0);
      local_cd0 = (char *)(uint)*(byte *)&local_c94[-1].Symbol[0xff].LineN;
      local_cb8 = (uchar *)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_cb4 = (LayerTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_cc0 = local_c94[-1].Symbol[0xfe].Line;
      local_cbc = (LineTypePtr)local_c94[-1].Symbol[0xfd].Width;
      MakeFlags(0);
      uVar30 = 0;
      puVar18 = local_dc;
      puVar23 = (undefined4 *)&stack0xfffff2f8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2f4 = 100;
      in_stack_fffff2e4 = (char *)0x0;
      puVar18 = local_e8;
      puVar23 = (undefined4 *)&stack0xfffff2d0;
      local_cc4 = local_cc0;
      in_stack_fffff2f0 = (uint)local_cd0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      Flags_02.t._0_4_ = in_stack_fffff2d4;
      Flags_02.f = (ulong)in_stack_fffff2d0;
      Flags_02.t._4_4_ = in_stack_fffff2d8;
      in_stack_fffff2c8 = (FontTypePtr)yyElement;
      in_stack_fffff2cc = (code *)yyFont;
      yyElement = CreateNewElement(yyData,yyElement,yyFont,Flags_02,(char *)local_cbc,
                                   (char *)local_cc4,in_stack_fffff2e4,(LocationType)local_cb4,
                                   (LocationType)local_cb8,(BYTE)in_stack_fffff2f0,in_stack_fffff2f4
                                   ,in_stack_fffff2f8,(Boolean)uVar30);
      SaveFree((void *)local_c94[-1].Symbol[0xfd].Width);
      SaveFree(local_c94[-1].Symbol[0xfe].Line);
      pin_num = 1;
      pPVar9 = PCB;
      local_cc0 = local_cbc;
      local_cd0 = (char *)local_cb4;
      local_cc8 = (LineTypePtr)local_cb8;
      break;
    case 0x74:
    case 0x76:
    case 0x78:
    case 0x7a:
    case 0x7c:
      in_stack_fffff2c8 = (FontTypePtr)yyElement;
      in_stack_fffff2cc = (code *)yyFont;
      SetElementBoundingBox(yyData,yyElement,yyFont);
      pPVar9 = PCB;
      break;
    case 0x75:
      OldFlags(local_c94[-1].Symbol[0xff].LineN);
      local_cbc = (LineTypePtr)(uint)*(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
      local_cd0 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      local_cb8 = (uchar *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_cb4 = (LayerTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_cc4 = *(LineTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xfc].Height;
      OldFlags(local_c94[-1].Symbol[0xfc].LineN);
      uVar30 = 0;
      puVar18 = local_f4;
      puVar23 = (undefined4 *)&stack0xfffff2f8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = (char *)0x0;
      puVar18 = local_100;
      puVar23 = (undefined4 *)&stack0xfffff2d0;
      in_stack_fffff2f4 = (BDimension)local_cd0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      Flags_01.t._0_4_ = in_stack_fffff2d4;
      Flags_01.f = (ulong)in_stack_fffff2d0;
      Flags_01.t._4_4_ = in_stack_fffff2d8;
      in_stack_fffff2c8 = (FontTypePtr)yyElement;
      in_stack_fffff2cc = (code *)yyFont;
      yyElement = CreateNewElement(yyData,yyElement,yyFont,Flags_01,(char *)local_cc0,
                                   (char *)local_cc4,in_stack_fffff2e4,(LocationType)local_cb4,
                                   (LocationType)local_cb8,(BYTE)local_cbc,in_stack_fffff2f4,
                                   in_stack_fffff2f8,(Boolean)uVar30);
      SaveFree((void *)local_c94[-1].Symbol[0xfc].Height);
      local_cd0 = (char *)local_cb4;
      local_cc8 = (LineTypePtr)local_cb8;
      in_stack_fffff2f0 = (uint)local_cbc;
      goto LAB_080ae6d7;
    case 0x77:
      OldFlags(local_c94[-1].Symbol[0xff].LineN);
      local_cc4 = (LineTypePtr)(uint)*(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
      local_cd0 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      local_cc0 = (LineTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_cbc = (LineTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_cb8 = *(uchar **)&local_c94[-1].Symbol[0xfd].Valid;
      local_cb4 = (LayerTypePtr)local_c94[-1].Symbol[0xfc].Height;
      local_cc8 = (LineTypePtr)local_c94[-1].Symbol[0xfc].LineN;
      OldFlags(local_c94[-1].Symbol[0xfb].Delta);
      uVar30 = 0;
      puVar18 = local_10c;
      puVar23 = (undefined4 *)&stack0xfffff2f8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      puVar18 = local_118;
      puVar23 = (undefined4 *)&stack0xfffff2d0;
      TextY = (uchar *)local_cc0;
      in_stack_fffff2f0 = (uint)local_cc4;
      in_stack_fffff2f4 = (BDimension)local_cd0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      Flags_00.t._0_4_ = in_stack_fffff2d4;
      Flags_00.f = (ulong)in_stack_fffff2d0;
      Flags_00.t._4_4_ = in_stack_fffff2d8;
      in_stack_fffff2c8 = (FontTypePtr)yyElement;
      in_stack_fffff2cc = (code *)yyFont;
      yyElement = CreateNewElement(yyData,yyElement,yyFont,Flags_00,(char *)local_cc8,
                                   (char *)local_cb4,(char *)local_cb8,(LocationType)local_cbc,
                                   (LocationType)TextY,(BYTE)in_stack_fffff2f0,in_stack_fffff2f4,
                                   in_stack_fffff2f8,(Boolean)uVar30);
      SaveFree((void *)local_c94[-1].Symbol[0xfc].LineN);
      SaveFree((void *)local_c94[-1].Symbol[0xfc].Height);
      local_cc0 = local_cc8;
      local_cc4 = (LineTypePtr)local_cb4;
      in_stack_fffff2e4 = (char *)local_cb8;
      local_cd0 = (char *)local_cbc;
      local_cc8 = (LineTypePtr)TextY;
LAB_080ae6d7:
      SaveFree(*(void **)&local_c94[-1].Symbol[0xfd].Valid);
      pin_num = 1;
      pPVar9 = PCB;
      break;
    case 0x79:
      OldFlags(local_c94[-1].Symbol[0xff].LineN);
      local_cbc = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_cb8 = (uchar *)(uint)*(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
      local_cc8 = (LineTypePtr)
                  ((int)(((local_c94[-1].Symbol[0xfe].Line)->Flags).t +
                        *(int *)&local_c94[-1].Symbol[0xfd].Valid + -0x18) * 100);
      local_cb4 = (LayerTypePtr)local_c94[-1].Symbol[0xfc].LineN;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xfb].Delta;
      local_cd0 = (char *)((local_c94[-1].Symbol[0xfc].Height + local_c94[-1].Symbol[0xfd].Width) *
                          100);
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xfb].LineMax;
      OldFlags((uint)local_c94[-1].Symbol[0xfb].Line);
      uVar30 = 0;
      puVar18 = local_124;
      puVar23 = (undefined4 *)&stack0xfffff2f8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      puVar18 = local_130;
      puVar23 = (undefined4 *)&stack0xfffff2d0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      Flags_03.t._0_4_ = in_stack_fffff2d4;
      Flags_03.f = (ulong)in_stack_fffff2d0;
      Flags_03.t._4_4_ = in_stack_fffff2d8;
      in_stack_fffff2c8 = (FontTypePtr)yyElement;
      in_stack_fffff2cc = (code *)yyFont;
      paVar13 = CreateNewElement(yyData,yyElement,yyFont,Flags_03,(char *)local_cc0,
                                 (char *)local_cc4,(char *)local_cb4,(LocationType)local_cd0,
                                 (LocationType)local_cc8,(BYTE)local_cb8,(int)local_cbc,
                                 in_stack_fffff2f8,(Boolean)uVar30);
      yyElement = paVar13;
      paVar13->MarkX = local_c94[-1].Symbol[0xfc].Height * 100;
      paVar13->MarkY = *(int *)&local_c94[-1].Symbol[0xfd].Valid * 100;
      SaveFree((void *)local_c94[-1].Symbol[0xfb].LineMax);
      SaveFree((void *)local_c94[-1].Symbol[0xfb].Delta);
      SaveFree((void *)local_c94[-1].Symbol[0xfc].LineN);
      pPVar9 = PCB;
      in_stack_fffff2e4 = (char *)local_cb4;
      in_stack_fffff2f0 = (uint)local_cb8;
      in_stack_fffff2f4 = (BDimension)local_cbc;
      break;
    case 0x7b:
      uVar30 = 0;
      pCVar21 = &local_c94[-1].Symbol[0xff].LineN;
      pCVar26 = (Cardinal *)&stack0xfffff2f8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *pCVar26 = *pCVar21;
        pCVar21 = pCVar21 + (uint)bVar28 * -2 + 1;
        pCVar26 = pCVar26 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2f4 = local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2f0 = (uint)*(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
      local_cc8 = (LineTypePtr)
                  (((local_c94[-1].Symbol[0xfe].Line)->Flags).t +
                  *(int *)&local_c94[-1].Symbol[0xfd].Valid + -0x18);
      local_cd0 = (char *)(local_c94[-1].Symbol[0xfc].Height + local_c94[-1].Symbol[0xfd].Width);
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xfc].LineN;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xfb].Delta;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xfb].LineMax;
      pSVar19 = local_c94[-1].Symbol + 0xfb;
      ppLVar24 = (LineTypePtr *)&stack0xfffff2d0;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *ppLVar24 = pSVar19->Line;
        pSVar19 = (SymbolType *)((int)pSVar19 + (uint)bVar28 * -8 + 4);
        ppLVar24 = ppLVar24 + (uint)bVar28 * -2 + 1;
      }
      Flags_04.t._0_4_ = in_stack_fffff2d4;
      Flags_04.f = (ulong)in_stack_fffff2d0;
      Flags_04.t._4_4_ = in_stack_fffff2d8;
      in_stack_fffff2c8 = (FontTypePtr)yyElement;
      in_stack_fffff2cc = (code *)yyFont;
      paVar13 = CreateNewElement(yyData,yyElement,yyFont,Flags_04,(char *)local_cc0,
                                 (char *)local_cc4,in_stack_fffff2e4,(LocationType)local_cd0,
                                 (LocationType)local_cc8,(BYTE)in_stack_fffff2f0,in_stack_fffff2f4,
                                 in_stack_fffff2f8,(Boolean)uVar30);
      yyElement = paVar13;
      paVar13->MarkX = local_c94[-1].Symbol[0xfc].Height;
      paVar13->MarkY = *(LocationType *)&local_c94[-1].Symbol[0xfd].Valid;
      SaveFree((void *)local_c94[-1].Symbol[0xfb].LineMax);
      SaveFree((void *)local_c94[-1].Symbol[0xfb].Delta);
      SaveFree((void *)local_c94[-1].Symbol[0xfc].LineN);
      pPVar9 = PCB;
      break;
    case 0x84:
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Line;
      goto LAB_080afb8f;
    case 0x85:
      in_stack_fffff2d8 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2c8 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
LAB_080afb8f:
      CreateNewLineInElement
                (yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                 (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                 (BDimension)in_stack_fffff2d8);
      pPVar9 = PCB;
      break;
    case 0x86:
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfd].Width;
      in_stack_fffff2c8 = *(FontTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      goto LAB_080af1c7;
    case 0x87:
      local_cc4 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2d0 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2c8 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
LAB_080af1c7:
      CreateNewArcInElement
                (yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                 (BDimension)in_stack_fffff2d0,(BDimension)in_stack_fffff2d4,(int)in_stack_fffff2d8,
                 (int)local_cc0,(BDimension)local_cc4);
      pPVar9 = PCB;
      break;
    case 0x88:
      yyElement->MarkX = local_c94[-1].Symbol[0xff].LineN;
      paVar13->MarkY = local_c94[-1].Symbol[0xff].Height;
      pPVar9 = PCB;
      break;
    case 0x89:
      yyElement->MarkX = local_c94[-1].Symbol[0xff].LineN * 100;
      paVar13->MarkY = local_c94[-1].Symbol[0xff].Height * 100;
      pPVar9 = PCB;
      break;
    case 0x8a:
    case 0x96:
      attr_list = &yyElement->Attributes;
      break;
    case 0x92:
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN + yyElement->MarkY);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].Delta + yyElement->MarkX);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfe].LineMax + yyElement->MarkY);
      in_stack_fffff2c8 =
           (FontTypePtr)(((local_c94[-1].Symbol[0xfe].Line)->Flags).t + yyElement->MarkX + -0x18);
      CreateNewLineInElement
                (yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                 (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                 (BDimension)in_stack_fffff2d8);
      pPVar9 = PCB;
      break;
    case 0x93:
      in_stack_fffff2d8 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100 + yyElement->MarkY);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100 + yyElement->MarkX);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100 + yyElement->MarkY);
      in_stack_fffff2c8 =
           (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100 + yyElement->MarkX);
      CreateNewLineInElement
                (yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                 (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                 (BDimension)in_stack_fffff2d8);
      pPVar9 = PCB;
      break;
    case 0x94:
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2cc = (code *)(yyElement->MarkY + local_c94[-1].Symbol[0xfd].Width);
      in_stack_fffff2c8 =
           (FontTypePtr)(yyElement->MarkX + *(int *)&local_c94[-1].Symbol[0xfd].Valid);
      goto LAB_080af0ca;
    case 0x95:
      local_cc4 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2d0 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100 + yyElement->MarkY);
      in_stack_fffff2c8 =
           (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100 + yyElement->MarkX);
LAB_080af0ca:
      CreateNewArcInElement
                (yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                 (BDimension)in_stack_fffff2d0,(BDimension)in_stack_fffff2d4,(int)in_stack_fffff2d8,
                 (int)local_cc0,(BDimension)local_cc4);
      pPVar9 = PCB;
      break;
    case 0x98:
      pBVar22 = &local_c94[-1].Symbol[0xff].Height;
      pBVar27 = (BDimension *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *pBVar27 = *pBVar22;
        pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
        pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xff].LineN;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_cc0 = (LineTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2d8 = local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xfd].Width;
      in_stack_fffff2d0 = *(char **)&local_c94[-1].Symbol[0xfd].Valid;
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfc].Height + yyElement->MarkY);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].LineN + yyElement->MarkX);
      Flags_19.t._0_4_ = local_cc8;
      Flags_19.f = (ulong)local_cd0;
      Flags_19.t[4] = (char)in_stack_fffff2f0;
      Flags_19.t[5] = (char)(in_stack_fffff2f0 >> 8);
      Flags_19.t[6] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_19.t[7] = (char)(in_stack_fffff2f0 >> 0x18);
      CreateNewPin(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,(BDimension)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,(char *)local_cc4,
                   in_stack_fffff2e4,Flags_19);
      SaveFree((void *)local_c94[-1].Symbol[0xfe].Delta);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x99:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      puVar18 = local_13c;
      puVar23 = (undefined4 *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xff].LineN;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_cc0 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2d8 = (LineTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2d0 = (char *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfc].Height * 100 + yyElement->MarkY);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].LineN * 100 + yyElement->MarkX);
      Flags_18.t._0_4_ = local_cc8;
      Flags_18.f = (ulong)local_cd0;
      Flags_18.t[4] = (char)in_stack_fffff2f0;
      Flags_18.t[5] = (char)(in_stack_fffff2f0 >> 8);
      Flags_18.t[6] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_18.t[7] = (char)(in_stack_fffff2f0 >> 0x18);
      CreateNewPin(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,(BDimension)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,(char *)local_cc4,
                   in_stack_fffff2e4,Flags_18);
      goto LAB_080aefd1;
    case 0x9a:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2d0 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      puVar18 = local_148;
      puVar23 = (undefined4 *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xff].LineN;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_cc0 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2d4 = (FontTypePtr)0xbb8;
      in_stack_fffff2d8 = (LineTypePtr)&((SymbolType *)((int)in_stack_fffff2d0 + 0x18))[0x14].Width;
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2c8 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      Flags_22.t._0_4_ = local_cc8;
      Flags_22.f = (ulong)local_cd0;
      Flags_22.t[4] = (char)in_stack_fffff2f0;
      Flags_22.t[5] = (char)(in_stack_fffff2f0 >> 8);
      Flags_22.t[6] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_22.t[7] = (char)(in_stack_fffff2f0 >> 0x18);
      CreateNewPin(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,3000,(BDimension)in_stack_fffff2d8,
                   (BDimension)local_cc0,(char *)local_cc4,in_stack_fffff2e4,Flags_22);
      goto LAB_080af255;
    case 0x9b:
      pin_num = pin_num + 1;
      __sprintf_chk(p_number);
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2e4 = p_number;
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      puVar18 = local_154;
      puVar23 = (undefined4 *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_cc0 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      in_stack_fffff2d4 = (FontTypePtr)0xbb8;
      in_stack_fffff2d8 = (LineTypePtr)&((SymbolType *)((int)in_stack_fffff2d0 + 0x18))[0x14].Width;
      in_stack_fffff2cc = (code *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      Flags_21.t._0_4_ = local_cc8;
      Flags_21.f = (ulong)local_cd0;
      Flags_21.t[4] = (char)in_stack_fffff2f0;
      Flags_21.t[5] = (char)(in_stack_fffff2f0 >> 8);
      Flags_21.t[6] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_21.t[7] = (char)(in_stack_fffff2f0 >> 0x18);
      CreateNewPin(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,3000,(BDimension)in_stack_fffff2d8,
                   (BDimension)local_cc0,(char *)local_cc4,in_stack_fffff2e4,Flags_21);
      goto LAB_080afabe;
    case 0x9c:
      iVar17 = local_c94[-1].Symbol[0xfe].Delta;
      local_cc0 = (LineTypePtr)(iVar17 * 0x28);
      if ((iVar17 * -0x27 < 400) && (400 < iVar17)) {
        local_cc0 = (LineTypePtr)(iVar17 + -400);
      }
      pin_num = pin_num + 1;
      __sprintf_chk(p_number);
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100);
      puVar18 = local_160;
      puVar23 = (undefined4 *)&stack0xfffff2e8;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      in_stack_fffff2e4 = p_number;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d4 = (FontTypePtr)0xbb8;
      in_stack_fffff2d8 = (LineTypePtr)&((SymbolType *)((int)in_stack_fffff2d0 + 0x18))[0x14].Width;
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2c8 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      Flags_20.t._0_4_ = local_cc8;
      Flags_20.f = (ulong)local_cd0;
      Flags_20.t[4] = (char)in_stack_fffff2f0;
      Flags_20.t[5] = (char)(in_stack_fffff2f0 >> 8);
      Flags_20.t[6] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_20.t[7] = (char)(in_stack_fffff2f0 >> 0x18);
      CreateNewPin(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (BDimension)in_stack_fffff2d0,3000,(BDimension)in_stack_fffff2d8,
                   (BDimension)local_cc0,(char *)local_cc4,in_stack_fffff2e4,Flags_20);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x9d:
      iVar17 = yyElement->MarkY;
      iVar3 = yyElement->MarkX;
      pBVar22 = &local_c94[-1].Symbol[0xff].Height;
      pBVar27 = (BDimension *)&stack0xfffff2ec;
      for (iVar16 = 3; iVar16 != 0; iVar16 = iVar16 + -1) {
        *pBVar27 = *pBVar22;
        pBVar22 = pBVar22 + (uint)bVar28 * -2 + 1;
        pBVar27 = pBVar27 + (uint)bVar28 * -2 + 1;
      }
      local_cd0 = (char *)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      local_cc4 = (LineTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_cc0 = local_c94[-1].Symbol[0xfe].Line;
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xfd].Width;
      in_stack_fffff2d4 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid + iVar17);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfc].Height + iVar3);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfc].LineN + iVar17);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfb].Delta + iVar3);
      Flags_28.t[0] = (char)in_stack_fffff2f0;
      Flags_28.t[1] = (char)(in_stack_fffff2f0 >> 8);
      Flags_28.t[2] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_28.t[3] = (char)(in_stack_fffff2f0 >> 0x18);
      Flags_28.f = (ulong)local_cc8;
      Flags_28.t[4] = (char)in_stack_fffff2f4;
      Flags_28.t[5] = (char)((uint)in_stack_fffff2f4 >> 8);
      Flags_28.t[6] = (char)((uint)in_stack_fffff2f4 >> 0x10);
      Flags_28.t[7] = (char)((uint)in_stack_fffff2f4 >> 0x18);
      CreateNewPad(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,(BDimension)local_cc4,
                   in_stack_fffff2e4,local_cd0,Flags_28);
LAB_080aefd1:
      SaveFree((void *)local_c94[-1].Symbol[0xfe].Delta);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0x9e:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      local_cb8 = (uchar *)yyElement->MarkY;
      local_cb4 = (LayerTypePtr)yyElement->MarkX;
      puVar18 = local_ce4;
      puVar23 = (undefined4 *)&stack0xfffff2ec;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cd0 = (char *)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      local_cc4 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_cc0 = (LineTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2d8 = (LineTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2d4 =
           (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100 + (int)local_cb8);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfc].Height * 100 + (int)local_cb4);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfc].LineN * 100 + (int)local_cb8);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfb].Delta * 100 + (int)local_cb4);
      Flags_27.t[0] = (char)in_stack_fffff2f0;
      Flags_27.t[1] = (char)(in_stack_fffff2f0 >> 8);
      Flags_27.t[2] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_27.t[3] = (char)(in_stack_fffff2f0 >> 0x18);
      Flags_27.f = (ulong)local_cc8;
      Flags_27.t[4] = (char)in_stack_fffff2f4;
      Flags_27.t[5] = (char)((uint)in_stack_fffff2f4 >> 8);
      Flags_27.t[6] = (char)((uint)in_stack_fffff2f4 >> 0x10);
      Flags_27.t[7] = (char)((uint)in_stack_fffff2f4 >> 0x18);
      CreateNewPad(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,(BDimension)local_cc0,(BDimension)local_cc4,
                   in_stack_fffff2e4,local_cd0,Flags_27);
      goto LAB_080af255;
    case 0x9f:
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2d8 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      puVar18 = local_ce8;
      puVar23 = (undefined4 *)&stack0xfffff2ec;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cd0 = (char *)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      local_cc0 = (LineTypePtr)0xbb8;
      local_cc4 = (LineTypePtr)&in_stack_fffff2d8[6].Point2.X2;
      in_stack_fffff2d4 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2cc = (code *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      in_stack_fffff2c8 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].Height * 100);
      Flags_26.t[0] = (char)in_stack_fffff2f0;
      Flags_26.t[1] = (char)(in_stack_fffff2f0 >> 8);
      Flags_26.t[2] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_26.t[3] = (char)(in_stack_fffff2f0 >> 0x18);
      Flags_26.f = (ulong)local_cc8;
      Flags_26.t[4] = (char)in_stack_fffff2f4;
      Flags_26.t[5] = (char)((uint)in_stack_fffff2f4 >> 8);
      Flags_26.t[6] = (char)((uint)in_stack_fffff2f4 >> 0x10);
      Flags_26.t[7] = (char)((uint)in_stack_fffff2f4 >> 0x18);
      CreateNewPad(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,3000,(BDimension)local_cc4,in_stack_fffff2e4,
                   local_cd0,Flags_26);
      goto LAB_080af255;
    case 0xa0:
      pin_num = pin_num + 1;
      __sprintf_chk(p_number);
      OldFlags(local_c94[-1].Symbol[0xff].Height);
      in_stack_fffff2d8 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      puVar18 = local_cec;
      puVar23 = (undefined4 *)&stack0xfffff2ec;
      for (iVar17 = 3; iVar17 != 0; iVar17 = iVar17 + -1) {
        *puVar23 = *puVar18;
        puVar18 = puVar18 + (uint)bVar28 * -2 + 1;
        puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
      }
      local_cd0 = p_number;
      in_stack_fffff2e4 = (char *)local_c94[-1].Symbol[0xff].LineN;
      local_cc0 = (LineTypePtr)0xbb8;
      local_cc4 = (LineTypePtr)&in_stack_fffff2d8[6].Point2.X2;
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2d0 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      in_stack_fffff2c8 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      Flags_25.t[0] = (char)in_stack_fffff2f0;
      Flags_25.t[1] = (char)(in_stack_fffff2f0 >> 8);
      Flags_25.t[2] = (char)(in_stack_fffff2f0 >> 0x10);
      Flags_25.t[3] = (char)(in_stack_fffff2f0 >> 0x18);
      Flags_25.f = (ulong)local_cc8;
      Flags_25.t[4] = (char)in_stack_fffff2f4;
      Flags_25.t[5] = (char)((uint)in_stack_fffff2f4 >> 8);
      Flags_25.t[6] = (char)((uint)in_stack_fffff2f4 >> 0x10);
      Flags_25.t[7] = (char)((uint)in_stack_fffff2f4 >> 0x18);
      CreateNewPad(yyElement,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                   (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                   (BDimension)in_stack_fffff2d8,3000,(BDimension)local_cc4,in_stack_fffff2e4,
                   local_cd0,Flags_25);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0xa1:
      in_stack_fffff2c8 = (FontTypePtr)local_c94->MaxHeight;
      OldFlags((uint)in_stack_fffff2c8);
      pPVar9 = PCB;
      break;
    case 0xa2:
      in_stack_fffff2cc = yyerror;
      in_stack_fffff2c8 = (FontTypePtr)local_c94->MaxHeight;
      string_to_flags((char *)in_stack_fffff2c8,yyerror);
      pPVar9 = PCB;
      break;
    case 0xa5:
      iVar17 = local_c94[-1].Symbol[0xfe].Delta;
      if (iVar17 - 1U < 0xff) {
        Symbol = yyFont->Symbol + iVar17;
        if (yyFont->Symbol[iVar17].Valid == '\0') {
          yyFont->Symbol[iVar17].Valid = '\x01';
          Symbol->Delta = local_c94[-1].Symbol[0xff].LineN;
          pPVar9 = PCB;
          break;
        }
      }
      goto LAB_080b08bd;
    case 0xa7:
      iVar17 = local_c94[-1].Symbol[0xfe].Delta;
      if (iVar17 - 1U < 0xff) {
        Symbol = yyFont->Symbol + iVar17;
        if (yyFont->Symbol[iVar17].Valid == '\0') {
          yyFont->Symbol[iVar17].Valid = '\x01';
          Symbol->Delta = local_c94[-1].Symbol[0xff].LineN * 100;
          pPVar9 = PCB;
          break;
        }
      }
LAB_080b08bd:
      Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n");
      goto LAB_080af56c;
    case 0xb0:
      in_stack_fffff2d8 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      in_stack_fffff2d4 = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      in_stack_fffff2d0 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100);
      in_stack_fffff2cc = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      in_stack_fffff2c8 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      goto LAB_080ae9c7;
    case 0xb1:
      in_stack_fffff2d8 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      in_stack_fffff2d4 = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2d0 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xfe].LineMax;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Line;
LAB_080ae9c7:
      CreateNewLineInSymbol
                (Symbol,(LocationType)in_stack_fffff2c8,(LocationType)in_stack_fffff2cc,
                 (LocationType)in_stack_fffff2d0,(LocationType)in_stack_fffff2d4,
                 (BDimension)in_stack_fffff2d8);
      pPVar9 = PCB;
      break;
    case 0xb9:
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xff].LineN;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      Menu = CreateNewNet(&yyPCB->NetlistLib,(char *)in_stack_fffff2c8,(char *)in_stack_fffff2cc);
LAB_080af255:
      SaveFree((void *)local_c94[-1].Symbol[0xfe].Delta);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar9 = PCB;
      break;
    case 0xbf:
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xff].Height;
      CreateNewConnection(Menu,(char *)in_stack_fffff2c8);
      SaveFree((void *)local_c94[-1].Symbol[0xff].Height);
      pPVar9 = PCB;
      break;
    case 0xc2:
      in_stack_fffff2cc = (code *)local_c94[-1].Symbol[0xff].Height;
      in_stack_fffff2c8 = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
      CreateNewAttribute(attr_list,(char *)in_stack_fffff2c8,(char *)in_stack_fffff2cc);
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      SaveFree((void *)local_c94[-1].Symbol[0xff].Height);
      pPVar9 = PCB;
      break;
    case 0xc3:
      yyval.number = (int)local_c94->MaxHeight;
      break;
    case 0xc4:
      yyval.number = 0;
    }
    PCB = pPVar9;
    local_ccc = local_ccc + -local_cac;
    pFVar1 = (FontTypePtr)((int)local_c94 + local_cac * -0xc + 0xc);
    *(int *)((int)local_c94 + local_cac * -0xc + 0xc) = yyval.number;
    *(undefined4 *)((int)local_c94 + local_cac * -0xc + 0x10) = yyval._4_4_;
    *(undefined4 *)((int)local_c94 + local_cac * -0xc + 0x14) = yyval._8_4_;
    uVar11 = (uint)""[local_c9c];
    uVar15 = (int)*local_ccc + (int)*(short *)("" + (uVar11 - 0x29) + uVar11 + 0xb7);
    local_c94 = pFVar1;
    if ((uVar15 < 0x24e) && (*local_ccc == yycheck[uVar15])) {
      yyn = (int)yytable[uVar15];
    }
    else {
      yyn = (int)*(short *)(uVar11 + 0x814d357 + (uVar11 - 0x29));
    }
yynewstate:
    local_ccc = local_ccc + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void add_noholes_polyarea(PLINE *pline,void *user_data)

{
  pline->next = *(PLINE **)((int)user_data + 0x30);
  *(PLINE **)((int)user_data + 0x30) = pline;
  return;
}



// WARNING: Removing unreachable block (ram,0x080b0a22)
// WARNING: Unknown calling convention

Cardinal GetLowestDistancePolygonPoint(PolygonTypePtr Polygon,LocationType X,LocationType Y)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  PointTypePtr ptr2;
  PointTypePtr pPVar7;
  Cardinal n;
  PointTypePtr ptr1;
  Cardinal CVar8;
  int iVar9;
  double u;
  double dx;
  double dy;
  double mindistance;
  LocationType local_2c;
  Cardinal local_28;
  
  local_28 = 0;
  pPVar7 = Polygon->Points;
  uVar1 = Polygon->PointN;
  if (uVar1 != 0) {
    fVar6 = 1e+14;
    CVar8 = 0;
    iVar9 = pPVar7[uVar1 - 1].X;
    local_2c = pPVar7[uVar1 - 1].Y;
    while( true ) {
      iVar2 = pPVar7->X;
      iVar3 = pPVar7->Y;
      fVar5 = (float)(iVar2 - iVar9);
      fVar4 = (float)(iVar3 - local_2c);
      if ((fVar5 != 0.0) || (fVar4 != 0.0)) {
        fVar5 = ((float)(Y - local_2c) * fVar4 + (float)(X - iVar9) * fVar5) /
                (fVar4 * fVar4 + fVar5 * fVar5);
        if (fVar5 < 0.0) {
          fVar5 = (float)(X - iVar9);
          fVar4 = (float)(Y - local_2c);
          fVar5 = fVar4 * fVar4 + fVar5 * fVar5;
        }
        else if (fVar5 <= 1.0) {
          fVar4 = ((float)X - (float)iVar9 * (1.0 - fVar5)) - (float)iVar2 * fVar5;
          fVar5 = ((float)Y - (float)local_2c * (1.0 - fVar5)) - (float)iVar3 * fVar5;
          fVar5 = fVar5 * fVar5 + fVar4 * fVar4;
        }
        else {
          fVar5 = (float)(Y - iVar3) * (float)(Y - iVar3) + (float)(X - iVar2) * (float)(X - iVar2);
        }
        if (fVar5 < fVar6) {
          fVar6 = fVar5;
          local_28 = CVar8;
        }
      }
      CVar8 = CVar8 + 1;
      if (uVar1 <= CVar8) break;
      pPVar7 = pPVar7 + 1;
      iVar9 = iVar2;
      local_2c = iVar3;
    }
  }
  return local_28;
}



// WARNING: Unknown calling convention

void GoToPreviousPoint(void)

{
  PointTypePtr points;
  
  if (Crosshair.AttachedPolygon.PointN != 0) {
    if (Crosshair.AttachedPolygon.PointN == 1) {
      Crosshair.AttachedPolygon.PointN = 0;
      Crosshair.AttachedLine.State = 0;
      addedLines = 0;
      return;
    }
    Crosshair.AttachedLine.Point1.X =
         Crosshair.AttachedPolygon.Points[Crosshair.AttachedPolygon.PointN - 2].X;
    Crosshair.AttachedLine.Point1.Y =
         Crosshair.AttachedPolygon.Points[Crosshair.AttachedPolygon.PointN - 2].Y;
    Crosshair.AttachedPolygon.PointN = Crosshair.AttachedPolygon.PointN - 1;
  }
  return;
}



// WARNING: Unknown calling convention

int PolygonHoles(PolygonType *polygon,BoxType *range,_func_int_PLINE_ptr_void_ptr *callback,
                void *user_data)

{
  PLINE *pPVar1;
  POLYAREA *pa;
  int iVar2;
  PLINE *pl;
  
  if (polygon->Clipped != (POLYAREA *)0x0) {
    for (pPVar1 = polygon->Clipped->contours->next; pPVar1 != (PLINE *)0x0; pPVar1 = pPVar1->next) {
      if (((range == (BoxType *)0x0) ||
          ((((pPVar1->xmin <= range->X2 && (range->X1 <= pPVar1->xmax)) &&
            (pPVar1->ymin <= range->Y2)) && (range->Y1 <= pPVar1->ymax)))) &&
         (iVar2 = (*callback)(pPVar1,user_data), iVar2 != 0)) {
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int plow_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  if ((*(byte *)&b[1].Y1 & 0x10) == 0) {
    return 0;
  }
                    // WARNING: Load size is inaccurate
  iVar1 = (**(code **)((int)cl + 0x14))
                    (*(undefined4 *)((int)cl + 0x10),*(undefined4 *)((int)cl + 0xc),b,*cl,
                     *(undefined4 *)((int)cl + 4),*(undefined4 *)((int)cl + 8));
  return iVar1;
}



// WARNING: Unknown calling convention

void debug_pline(PLINE *pl)

{
  VNODE *pVVar1;
  VNODE *v;
  int iVar2;
  int iVar3;
  
  iVar3 = pl->ymax;
  iVar2 = pl->ymin;
  __fprintf_chk(stderr,1,"\txmin %d xmax %d ymin %d ymax %d\n",pl->xmin,pl->xmax,iVar2,iVar3);
  pVVar1 = &pl->head;
  do {
    __fprintf_chk(stderr,1,"\t\tvnode: %d,%d\n",pVVar1->point[0],pVVar1->point[1],iVar2,iVar3);
    pVVar1 = pVVar1->next;
    if (&pl->head == pVVar1) {
      return;
    }
  } while (pVVar1 != (VNODE *)0x0);
  return;
}



// WARNING: Unknown calling convention

void debug_polyarea(POLYAREA *p)

{
  PLINE *pl_00;
  PLINE *pl;
  
  __fprintf_chk(stderr,1,"POLYAREA %p\n",p);
  for (pl_00 = p->contours; pl_00 != (PLINE *)0x0; pl_00 = pl_00->next) {
    debug_pline(pl_00);
  }
  return;
}



// WARNING: Unknown calling convention

void debug_polygon(PolygonType *p)

{
  int i;
  uint uVar1;
  uint uVar2;
  POLYAREA *pa;
  POLYAREA *p_00;
  
  __fprintf_chk(stderr,1,"POLYGON %p  %d pts\n",p,p->PointN);
  if (p->PointN != 0) {
    uVar1 = 0;
    do {
      uVar2 = uVar1 + 1;
      __fprintf_chk(stderr,1,"\t%d: %d, %d\n",uVar1,p->Points[uVar1].X,p->Points[uVar1].Y);
      uVar1 = uVar2;
    } while (uVar2 <= p->PointN && p->PointN != uVar2);
  }
  p_00 = p->Clipped;
  do {
    if (p_00 == (POLYAREA *)0x0) {
      return;
    }
    debug_polyarea(p_00);
    p_00 = p_00->f;
  } while (p->Clipped != p_00);
  return;
}



// WARNING: Unknown calling convention

Boolean MorphPolygon(LayerTypePtr layer,PolygonTypePtr poly)

{
  int iVar1;
  POLYAREA *pPVar2;
  ulong uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  PLINE *pPVar6;
  POLYAREA *pPVar7;
  FlagType Flags;
  PolygonTypePtr Polygon;
  PolygonTypePtr new;
  PLINE *pPVar8;
  VNODE *v;
  VNODE *pVVar9;
  POLYAREA *p;
  POLYAREA *__ptr;
  Boolean many;
  Boolean BVar10;
  int in_GS_OFFSET;
  FlagType flags;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pPVar2 = poly->Clipped;
  if (((pPVar2 == (POLYAREA *)0x0) || ((*(byte *)((int)&(poly->Flags).f + 1) & 0x20) != 0)) ||
     (pPVar2 == pPVar2->f)) {
LAB_080b0f70:
    BVar10 = '\0';
  }
  else {
    ErasePolygon(poly);
    pPVar2 = poly->Clipped;
    poly->Clipped = (POLYAREA *)0x0;
    if (poly->NoHoles != (PLINE *)0x0) {
      __printf_chk(1,"Just leaked in MorpyPolygon\n");
    }
    uVar3 = (poly->Flags).f;
    BVar10 = '\0';
    poly->NoHoles = (PLINE *)0x0;
    uVar4 = *(undefined4 *)(poly->Flags).t;
    uVar5 = *(undefined4 *)((poly->Flags).t + 4);
    RemovePolygon(layer,poly);
    inhibit = '\x01';
    __ptr = pPVar2;
    do {
      if (__ptr->contours->area <= PCB->IsleArea) {
        pPVar7 = __ptr->f;
        poly_DelContour(&__ptr->contours);
        free(__ptr);
        __ptr = pPVar7;
      }
      else {
        Flags.t._0_4_ = uVar4;
        Flags.f = uVar3;
        Flags.t._4_4_ = uVar5;
        Polygon = CreateNewPolygon(layer,Flags);
        if (Polygon == (PolygonTypePtr)0x0) goto LAB_080b0f70;
        pPVar6 = __ptr->contours;
        CreateNewPointInPolygon(Polygon,(pPVar6->head).point[0],(pPVar6->head).point[1]);
        pPVar8 = __ptr->contours;
        pVVar9 = (pPVar6->head).next;
        if (pVVar9 != &pPVar8->head) {
          do {
            CreateNewPointInPolygon(Polygon,pVVar9->point[0],pVVar9->point[1]);
            pPVar8 = __ptr->contours;
            pVVar9 = pVVar9->next;
          } while (&pPVar8->head != pVVar9);
        }
        (Polygon->BoundingBox).X1 = pPVar8->xmin;
        (Polygon->BoundingBox).X2 = pPVar8->xmax + 1;
        (Polygon->BoundingBox).Y1 = pPVar8->ymin;
        (Polygon->BoundingBox).Y2 = pPVar8->ymax + 1;
        AddObjectToCreateUndoList(8,layer,Polygon,Polygon);
        Polygon->Clipped = __ptr;
        pPVar7 = __ptr->f;
        __ptr->b = __ptr;
        __ptr->f = __ptr;
        r_insert_entry(layer->polygon_tree,&Polygon->BoundingBox,0);
        BVar10 = '\x01';
        DrawPolygon(layer,Polygon,0);
        __ptr = pPVar7;
      }
    } while (__ptr != pPVar2);
    inhibit = '\0';
    IncrementUndoSerialNumber();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean IsPointInPolygonIgnoreHoles(LocationType X,LocationType Y,PolygonTypePtr p)

{
  int iVar1;
  Vector v;
  
  v[0] = X;
  v[1] = Y;
  iVar1 = poly_InsideContour(p->Clipped->contours,v);
  return (Boolean)iVar1;
}



// WARNING: Unknown calling convention

Boolean isects(POLYAREA *a,PolygonTypePtr p,Boolean fr)

{
  BOOLp BVar1;
  POLYAREA *local_10;
  
  BVar1 = Touching(a,p->Clipped);
  if (fr != '\0') {
    local_10 = a;
    poly_Free(&local_10);
  }
  return (Boolean)BVar1;
}



// WARNING: Unknown calling convention

void frac_circle(PLINE *c,LocationType X,LocationType Y,int *v,int range)

{
  float fVar1;
  float fVar2;
  float fVar3;
  VNODE *pVVar4;
  int i;
  int iVar5;
  double e2;
  double t1;
  double e1;
  int local_2c;
  
  pVVar4 = poly_CreateNode(v);
  poly_InclVertex((c->head).prev,pVVar4);
  fVar3 = (float)(v[1] - Y);
  if (range == 1) {
    local_2c = 0x23;
  }
  else {
    local_2c = (int)(0x24 / (longlong)range);
    if (local_2c < 1) {
      return;
    }
  }
  iVar5 = 0;
  fVar1 = (float)(*v - X);
  do {
    fVar2 = fVar1 * 0.9848077 - fVar3 * 0.1736482;
    fVar3 = fVar1 * 0.1736482 + fVar3 * 0.9848077;
    if (0.0 <= fVar2) {
      fVar1 = fVar2 + 0.5;
    }
    else {
      fVar1 = fVar2 - 0.5;
    }
    *v = (int)ROUND(fVar1) + X;
    if (fVar3 < 0.0) {
      fVar1 = fVar3 - 0.5;
    }
    else {
      fVar1 = fVar3 + 0.5;
    }
    iVar5 = iVar5 + 1;
    v[1] = (int)ROUND(fVar1) + Y;
    pVVar4 = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,pVVar4);
    fVar1 = fVar2;
  } while (iVar5 < local_2c);
  return;
}



// WARNING: Unknown calling convention

POLYAREA * original_poly(PolygonType *p)

{
  double dVar1;
  double dVar2;
  int iVar3;
  POLYAREA **ppPVar4;
  PointTypePtr point;
  VNODE *node;
  POLYAREA *p_00;
  POLYAREA *pPVar5;
  POLYAREA *pPVar6;
  PLINE *pl;
  Cardinal n;
  int iVar7;
  POLYAREA *np;
  PLINE *pPVar8;
  PLINE *contour;
  double big;
  Vector v;
  
  pPVar8 = (PLINE *)0x0;
  iVar7 = p->PointN - 1;
  if (iVar7 != -1) {
    iVar3 = p->PointN * 0x14;
    do {
      point = (PointTypePtr)((int)&p->Points[-1].X + iVar3);
      v[0] = point->X;
      v[1] = point->Y;
      if (pPVar8 == (PLINE *)0x0) {
        pPVar8 = poly_NewContour(v);
        if (pPVar8 == (PLINE *)0x0) {
          return (POLYAREA *)0x0;
        }
      }
      else {
        node = poly_CreateNode(v);
        poly_InclVertex((pPVar8->head).prev,node);
      }
      iVar7 = iVar7 + -1;
      iVar3 = iVar3 + -0x14;
    } while (iVar7 != -1);
  }
  poly_PreContour(pPVar8,1);
  if ((*(byte *)&pPVar8->Flags & 8) == 0) {
    poly_InvContour(pPVar8);
  }
  p_00 = poly_Create();
  pPVar5 = (POLYAREA *)0x0;
  if (p_00 != (POLYAREA *)0x0) {
    poly_InclContour(p_00,pPVar8);
    pPVar5 = (POLYAREA *)0x0;
    pPVar6 = p_00;
    dVar2 = -1.0;
    do {
      while (dVar1 = pPVar6->contours->area, dVar1 <= dVar2) {
        ppPVar4 = &pPVar6->f;
        pPVar6 = *ppPVar4;
        if (p_00 == *ppPVar4) goto LAB_080b127a;
      }
      ppPVar4 = &pPVar6->f;
      pPVar5 = pPVar6;
      pPVar6 = *ppPVar4;
      dVar2 = dVar1;
    } while (p_00 != *ppPVar4);
LAB_080b127a:
    if (p_00 != pPVar5) {
      pPVar8 = pPVar5->contours;
      pPVar5->contours = p_00->contours;
      p_00->contours = pPVar8;
      pPVar5 = p_00;
    }
  }
  return pPVar5;
}



// WARNING: Unknown calling convention

int Unsubtract(POLYAREA *np1,PolygonType *p)

{
  double dVar1;
  PLINE *pPVar2;
  double dVar3;
  POLYAREA **ppPVar4;
  POLYAREA *pPVar5;
  int iVar6;
  int x;
  PLINE *pl;
  POLYAREA *pPVar7;
  POLYAREA *p_1;
  int r;
  PLINE *pl_1;
  POLYAREA *pPVar8;
  double big;
  POLYAREA *local_14;
  POLYAREA *local_10;
  
  local_10 = (POLYAREA *)0x0;
  iVar6 = poly_Boolean_free(p->Clipped,np1,&local_10,0);
  if (iVar6 == 0) {
    pPVar7 = (POLYAREA *)0x0;
    if (local_10 != (POLYAREA *)0x0) {
      pPVar5 = local_10;
      dVar3 = -1.0;
      do {
        while (pPVar8 = pPVar5, dVar1 = pPVar8->contours->area, dVar3 < dVar1) {
          pPVar5 = pPVar8->f;
          pPVar7 = pPVar8;
          dVar3 = dVar1;
          if (local_10 == pPVar8->f) goto LAB_080b133a;
        }
        pPVar5 = pPVar8->f;
      } while (local_10 != pPVar8->f);
LAB_080b133a:
      if (local_10 != pPVar7) {
        pPVar2 = pPVar7->contours;
        pPVar7->contours = local_10->contours;
        local_10->contours = pPVar2;
        pPVar7 = local_10;
      }
    }
    p->Clipped = pPVar7;
    pPVar7 = original_poly(p);
    iVar6 = poly_Boolean_free(p->Clipped,pPVar7,&local_14,1);
    if (iVar6 == 0) {
      pPVar7 = (POLYAREA *)0x0;
      if (local_14 != (POLYAREA *)0x0) {
        pPVar5 = local_14;
        pPVar8 = (POLYAREA *)0x0;
        dVar3 = -1.0;
        do {
          while (pPVar7 = pPVar5, dVar1 = pPVar7->contours->area, dVar3 < dVar1) {
            pPVar5 = pPVar7->f;
            pPVar8 = pPVar7;
            dVar3 = dVar1;
            if (local_14 == pPVar7->f) goto LAB_080b13b2;
          }
          ppPVar4 = &pPVar7->f;
          pPVar5 = *ppPVar4;
          pPVar7 = pPVar8;
        } while (local_14 != *ppPVar4);
LAB_080b13b2:
        if (local_14 != pPVar7) {
          pPVar2 = pPVar7->contours;
          pPVar7->contours = local_14->contours;
          local_14->contours = pPVar2;
          pPVar7 = local_14;
        }
      }
      p->Clipped = pPVar7;
      return 1;
    }
    __fprintf_chk(stderr,1,"Error while clipping PBO_ISECT: %d\n",iVar6);
    poly_Free(&local_14);
    p->Clipped = (POLYAREA *)0x0;
    if (p->NoHoles != (PLINE *)0x0) {
      __printf_chk(1,"Just leaked in ClipOriginal\n");
    }
  }
  else {
    __fprintf_chk(stderr,1,"Error while clipping PBO_UNITE: %d\n",iVar6);
    poly_Free(&local_10);
    p->Clipped = (POLYAREA *)0x0;
    if (p->NoHoles != (PLINE *)0x0) {
      __printf_chk(1,"Just leaked in Unsubtract\n");
    }
  }
  p->NoHoles = (PLINE *)0x0;
  return 0;
}



// WARNING: Unknown calling convention

POLYAREA * ContourToPoly(PLINE *contour)

{
  POLYAREA *p_00;
  POLYAREA *p;
  
  poly_PreContour(contour,1);
  p_00 = poly_Create();
  if (p_00 != (POLYAREA *)0x0) {
    poly_InclContour(p_00,contour);
  }
  return p_00;
}



// WARNING: Unknown calling convention

POLYAREA * RoundRect(LocationType x1,LocationType x2,LocationType y1,LocationType y2,BDimension t)

{
  PLINE *c;
  POLYAREA *pPVar1;
  VNODE *pVVar2;
  PLINE *contour;
  Vector v;
  
  v[0] = x1 - t;
  v[1] = y1;
  c = poly_NewContour(v);
  pPVar1 = (POLYAREA *)0x0;
  if (c != (PLINE *)0x0) {
    frac_circle(c,x1,y1,v,4);
    v[0] = x2;
    v[1] = y1 - t;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,pVVar2);
    frac_circle(c,x2,y1,v,4);
    v[0] = t + x2;
    v[1] = y2;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,pVVar2);
    frac_circle(c,x2,y2,v,4);
    v[0] = x1;
    v[1] = t + y2;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,pVVar2);
    frac_circle(c,x1,y2,v,4);
    pPVar1 = ContourToPoly(c);
  }
  return pPVar1;
}



// WARNING: Unknown calling convention

POLYAREA * CirclePoly(LocationType x,LocationType y,BDimension radius)

{
  PLINE *contour;
  PLINE *c;
  POLYAREA *pPVar1;
  Vector v;
  
  if (0 < radius) {
    v[0] = radius + x;
    v[1] = y;
    c = poly_NewContour(v);
    if (c != (PLINE *)0x0) {
      frac_circle(c,x,y,v,1);
      pPVar1 = ContourToPoly(c);
      return pPVar1;
    }
  }
  return (POLYAREA *)0x0;
}



// WARNING: Unknown calling convention

Boolean IsPointInPolygon(LocationType X,LocationType Y,BDimension r,PolygonTypePtr p)

{
  Boolean BVar1;
  BOOLp BVar2;
  POLYAREA *a;
  POLYAREA *c;
  Vector v;
  
  v[0] = X;
  v[1] = Y;
  BVar2 = poly_CheckInside(p->Clipped,v);
  BVar1 = '\x01';
  if (BVar2 == 0) {
    if ((0 < r) && (a = CirclePoly(X,Y,r), a != (POLYAREA *)0x0)) {
      BVar1 = isects(a,p,'\x01');
      return BVar1;
    }
    BVar1 = '\0';
  }
  return BVar1;
}



// WARNING: Unknown calling convention

POLYAREA * OctagonPoly(LocationType x,LocationType y,BDimension radius)

{
  bool bVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  bool bVar5;
  float fVar6;
  PLINE *contour_00;
  POLYAREA *pPVar7;
  VNODE *pVVar8;
  int iVar9;
  PLINE *contour;
  int local_44;
  Vector v;
  
  fVar2 = (float)radius * 0.5;
  bVar1 = fVar2 < 0.0;
  if (bVar1) {
    fVar3 = fVar2 - 0.5;
  }
  else {
    fVar3 = fVar2 + 0.5;
  }
  fVar4 = (float)radius * 0.2071068;
  bVar5 = fVar4 >= 0.0;
  if (fVar4 < 0.0) {
    fVar6 = fVar4 - 0.5;
  }
  else {
    fVar6 = fVar4 + 0.5;
  }
  v[0] = (int)ROUND(fVar3) + x;
  v[1] = (int)ROUND(fVar6) + y;
  contour_00 = poly_NewContour(v);
  pPVar7 = (POLYAREA *)0x0;
  if (contour_00 != (PLINE *)0x0) {
    if (bVar5) {
      fVar3 = fVar4 + 0.5;
    }
    else {
      fVar3 = fVar4 - 0.5;
    }
    v[0] = (int)ROUND(fVar3) + x;
    if (bVar1) {
      iVar9 = (int)ROUND(fVar2 - 0.5);
      v[1] = iVar9 + y;
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
      v[0] = x * 2 - v[0];
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
    }
    else {
      iVar9 = (int)ROUND(fVar2 + 0.5);
      v[1] = iVar9 + y;
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
      v[0] = x * 2 - v[0];
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
    }
    local_44 = x * 2;
    v[0] = x - iVar9;
    if (bVar5) {
      iVar9 = (int)ROUND(fVar4 + 0.5);
      v[1] = iVar9 + y;
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
      v[1] = y * 2 - v[1];
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
    }
    else {
      iVar9 = (int)ROUND(fVar4 - 0.5);
      v[1] = iVar9 + y;
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
      v[1] = y * 2 - v[1];
      pVVar8 = poly_CreateNode(v);
      poly_InclVertex((contour_00->head).prev,pVVar8);
    }
    v[0] = x - iVar9;
    if (bVar1) {
      fVar2 = fVar2 - 0.5;
    }
    else {
      fVar2 = fVar2 + 0.5;
    }
    v[1] = y - (int)ROUND(fVar2);
    pVVar8 = poly_CreateNode(v);
    poly_InclVertex((contour_00->head).prev,pVVar8);
    v[0] = local_44 - v[0];
    pVVar8 = poly_CreateNode(v);
    poly_InclVertex((contour_00->head).prev,pVVar8);
    if (bVar5) {
      fVar4 = fVar4 + 0.5;
    }
    else {
      fVar4 = fVar4 - 0.5;
    }
    v[0] = (int)ROUND(fVar2) + x;
    v[1] = y - (int)ROUND(fVar4);
    pVVar8 = poly_CreateNode(v);
    poly_InclVertex((contour_00->head).prev,pVVar8);
    pPVar7 = ContourToPoly(contour_00);
  }
  return pPVar7;
}



// WARNING: Unknown calling convention

POLYAREA * PinPoly(PinType *pin,BDimension thick,BDimension clear)

{
  uint uVar1;
  POLYAREA *pPVar2;
  int iVar3;
  
  uVar1 = (pin->Flags).f;
  if ((uVar1 & 0x100) != 0) {
    iVar3 = (thick + 1) / 2;
    pPVar2 = RoundRect(pin->X - iVar3,iVar3 + pin->X,pin->Y - iVar3,iVar3 + pin->Y,(clear + 1) / 2);
    return pPVar2;
  }
  iVar3 = (thick + 1 + clear) / 2;
  if ((uVar1 & 0x800) == 0) {
    pPVar2 = CirclePoly(pin->X,pin->Y,iVar3);
    return pPVar2;
  }
  pPVar2 = OctagonPoly(pin->X,pin->Y,iVar3 * 2);
  return pPVar2;
}



// WARNING: Unknown calling convention

POLYAREA * RectPoly(LocationType x1,LocationType x2,LocationType y1,LocationType y2)

{
  PLINE *contour_00;
  POLYAREA *pPVar1;
  VNODE *pVVar2;
  PLINE *contour;
  Vector v;
  
  v[1] = y1;
  v[0] = x1;
  contour_00 = poly_NewContour(v);
  pPVar1 = (POLYAREA *)0x0;
  if (contour_00 != (PLINE *)0x0) {
    v[0] = x2;
    v[1] = y1;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((contour_00->head).prev,pVVar2);
    v[0] = x2;
    v[1] = y2;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((contour_00->head).prev,pVVar2);
    v[0] = x1;
    v[1] = y2;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((contour_00->head).prev,pVVar2);
    pPVar1 = ContourToPoly(contour_00);
  }
  return pPVar1;
}



// WARNING: Unknown calling convention

void r_NoHolesPolygonDicer(POLYAREA *pa,_func_void_PLINE_ptr_void_ptr *emit,void *user_data)

{
  PLINE *pPVar1;
  PLINE *pPVar2;
  POLYAREA *pPVar3;
  PLINE *p;
  POLYAREA *pPVar4;
  POLYAREA *poly2;
  POLYAREA *cur;
  POLYAREA *cur_1;
  POLYAREA *next;
  POLYAREA *next_1;
  POLYAREA *local_30 [3];
  POLYAREA *local_24;
  POLYAREA *local_20 [4];
  
  pPVar1 = pa->contours;
  pPVar2 = pPVar1->next;
  local_30[0] = pa;
  if (pPVar2 != (PLINE *)0x0) {
    pPVar4 = RectPoly(pPVar1->xmin,(pPVar2->xmax + pPVar2->xmin) / 2,pPVar1->ymin,pPVar1->ymax);
    poly_AndSubtract_free(local_30[0],pPVar4,local_20,&local_24);
    pPVar4 = local_20[0];
    if (local_20[0] != (POLYAREA *)0x0) {
      do {
        pPVar3 = pPVar4->f;
        pPVar4->b = pPVar4;
        pPVar4->f = pPVar4;
        r_NoHolesPolygonDicer(pPVar4,emit,user_data);
        pPVar4 = pPVar3;
      } while (pPVar3 != local_20[0]);
    }
    pPVar4 = local_24;
    if (local_24 != (POLYAREA *)0x0) {
      do {
        pPVar3 = pPVar4->f;
        pPVar4->b = pPVar4;
        pPVar4->f = pPVar4;
        r_NoHolesPolygonDicer(pPVar4,emit,user_data);
        pPVar4 = pPVar3;
      } while (pPVar3 != local_24);
    }
    return;
  }
  pa->contours = (PLINE *)0x0;
  (*emit)(pPVar1,user_data);
  poly_Free(local_30);
  return;
}



// WARNING: Unknown calling convention

void NoHolesPolygonDicer(PolygonTypePtr p,BoxType *clip,_func_void_PLINE_ptr_void_ptr *emit,
                        void *user_data)

{
  POLYAREA *pPVar1;
  POLYAREA *dst;
  POLYAREA *pPVar2;
  POLYAREA *cbox;
  int iVar3;
  int r;
  POLYAREA *cur;
  POLYAREA *next;
  POLYAREA *save;
  POLYAREA *local_20 [4];
  
  dst = poly_Create();
  local_20[0] = dst;
  poly_Copy1(dst,p->Clipped);
  if ((((clip == (BoxType *)0x0) ||
       (pPVar2 = RectPoly(clip->X1,clip->X2,clip->Y1,clip->Y2), pPVar2 == (POLYAREA *)0x0)) ||
      (iVar3 = poly_Boolean_free(dst,pPVar2,local_20,1), dst = local_20[0], iVar3 == 0)) &&
     (pPVar2 = dst, dst != (POLYAREA *)0x0)) {
    do {
      pPVar1 = pPVar2->f;
      pPVar2->b = pPVar2;
      pPVar2->f = pPVar2;
      r_NoHolesPolygonDicer(pPVar2,emit,user_data);
      pPVar2 = pPVar1;
    } while (dst != pPVar1);
  }
  return;
}



// WARNING: Unknown calling convention

Boolean IsRectangleInPolygon
                  (LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,PolygonTypePtr p)

{
  Boolean BVar1;
  LocationType x1;
  POLYAREA *a;
  POLYAREA *s;
  LocationType y1;
  
  y1 = Y1;
  if (Y2 <= Y1) {
    y1 = Y2;
  }
  if (Y1 <= Y2) {
    Y1 = Y2;
  }
  x1 = X1;
  if (X2 <= X1) {
    x1 = X2;
  }
  if (X1 <= X2) {
    X1 = X2;
  }
  a = RectPoly(x1,X1,y1,Y1);
  if (a != (POLYAREA *)0x0) {
    BVar1 = isects(a,p,'\x01');
    return BVar1;
  }
  return '\0';
}



// WARNING: Unknown calling convention

POLYAREA * BoxPolyBloated(BoxType *box,BDimension bloat)

{
  POLYAREA *pPVar1;
  
  pPVar1 = RectPoly(box->X1 - bloat,box->X2 + bloat,box->Y1 - bloat,box->Y2 + bloat);
  return pPVar1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int clearPoly(DataTypePtr Data,LayerTypePtr Layer,PolygonType *polygon,BoxType *here,
             BDimension expand)

{
  int iVar1;
  Cardinal CVar2;
  Cardinal j_1;
  uint uVar3;
  PCBType *pPVar4;
  int iVar5;
  int iVar6;
  Cardinal *pCVar7;
  Cardinal j;
  uint uVar8;
  Cardinal j_2;
  Cardinal entry;
  uint uVar9;
  int r;
  uint uVar10;
  Cardinal i;
  Cardinal number;
  PCBType *local_114;
  int local_110;
  uint local_10c;
  int local_100;
  PCBType *local_fc;
  PCBType *local_f8;
  uint local_e8;
  cpInfo info;
  BoxType region;
  
  if (((*(byte *)&(polygon->Flags).f & 0x10) == 0) ||
     (iVar1 = GetLayerNumber(Data,Layer), PCB->Data->LayerN <= iVar1)) {
    return 0;
  }
  CVar2 = GetLayerNumber(Data,Layer);
  uVar9 = PCB->Data->LayerN;
  if (uVar9 == 0) {
    local_e8 = 0;
  }
  else {
    local_e8 = 0;
    pPVar4 = Data->pcb;
    local_f8 = pPVar4;
    do {
      uVar10 = (pPVar4->LayerGroups).Number[local_e8];
      if (uVar10 != 0) {
        if (CVar2 == (local_f8->LayerGroups).Entries[0]) goto LAB_080b20a0;
        pCVar7 = (pPVar4->LayerGroups).Entries[local_e8];
        uVar8 = 0;
        while (pCVar7 = pCVar7 + 1, uVar8 = uVar8 + 1, uVar8 < uVar10) {
          if (CVar2 == *pCVar7) goto LAB_080b20a0;
        }
      }
      local_e8 = local_e8 + 1;
      local_f8 = (PCBType *)&local_f8->InvisibleObjectsColor;
    } while (local_e8 < uVar9);
  }
  uVar10 = 0;
  if (uVar9 != 0) {
LAB_080b20a0:
    uVar10 = 0;
    pPVar4 = Data->pcb;
    local_fc = pPVar4;
    do {
      uVar8 = (pPVar4->LayerGroups).Number[uVar10];
      if (uVar8 != 0) {
        if ((local_fc->LayerGroups).Entries[0] == uVar9) break;
        pCVar7 = (pPVar4->LayerGroups).Entries[uVar10];
        uVar3 = 0;
        while (pCVar7 = pCVar7 + 1, uVar3 = uVar3 + 1, uVar3 < uVar8) {
          if (*pCVar7 == uVar9) goto LAB_080b1fc8;
        }
      }
      uVar10 = uVar10 + 1;
      local_fc = (PCBType *)&local_fc->InvisibleObjectsColor;
    } while (uVar10 < uVar9);
  }
LAB_080b1fc8:
  if (here == (BoxType *)0x0) {
    local_110 = (polygon->BoundingBox).X2;
    iVar6 = (polygon->BoundingBox).Y2;
    iVar1 = (polygon->BoundingBox).X1;
    iVar5 = (polygon->BoundingBox).Y1;
  }
  else {
    iVar1 = (polygon->BoundingBox).X1;
    iVar5 = (polygon->BoundingBox).Y1;
    local_110 = (polygon->BoundingBox).X2;
    if (iVar1 <= here->X1) {
      iVar1 = here->X1;
    }
    if (here->X2 == local_110 || here->X2 < local_110) {
      local_110 = here->X2;
    }
    if (iVar5 <= here->Y1) {
      iVar5 = here->Y1;
    }
    iVar6 = (polygon->BoundingBox).Y2;
    if (here->Y2 == iVar6 || here->Y2 < iVar6) {
      iVar6 = here->Y2;
    }
  }
  region.X1 = iVar1 + -expand;
  region.Y2 = iVar6 + expand;
  region.Y1 = iVar5 + -expand;
  region.X2 = local_110 + expand;
  info.solder = uVar10 == local_e8;
  info.other = here;
  info.data = (DataType *)Data;
  info.layer = Layer;
  info.polygon = polygon;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  local_100 = 0;
  if (iVar1 == 0) {
    iVar1 = r_search(Data->via_tree,&region,(_func_int_BoxType_ptr_void_ptr *)0x0,pin_sub_callback,
                     &info);
    local_100 = r_search(Data->pin_tree,&region,(_func_int_BoxType_ptr_void_ptr *)0x0,
                         pin_sub_callback,&info);
    local_100 = local_100 + iVar1;
    pPVar4 = Data->pcb;
    if ((pPVar4->LayerGroups).Number[local_e8] != 0) {
      uVar9 = 0;
      do {
        uVar10 = (pPVar4->LayerGroups).Entries[local_e8][uVar9];
        if (uVar10 < (uint)PCB->Data->LayerN) {
          iVar1 = r_search(Data->Layer[uVar10].line_tree,&region,
                           (_func_int_BoxType_ptr_void_ptr *)0x0,line_sub_callback,&info);
          iVar5 = r_search(Data->Layer[uVar10].arc_tree,&region,
                           (_func_int_BoxType_ptr_void_ptr *)0x0,arc_sub_callback,&info);
          iVar6 = r_search(Data->Layer[uVar10].text_tree,&region,
                           (_func_int_BoxType_ptr_void_ptr *)0x0,text_sub_callback,&info);
          local_100 = iVar6 + iVar5 + iVar1 + local_100;
        }
        pPVar4 = Data->pcb;
        uVar9 = uVar9 + 1;
        pCVar7 = (pPVar4->LayerGroups).Number + local_e8;
      } while (uVar9 <= *pCVar7 && *pCVar7 != uVar9);
    }
    if (info.solder == '\0') {
      local_10c = 0;
      uVar9 = PCB->Data->LayerN;
      local_114 = pPVar4;
      if (uVar9 != 0) {
        do {
          uVar10 = (pPVar4->LayerGroups).Number[local_10c];
          if (uVar10 != 0) {
            if (uVar9 + 1 == (local_114->LayerGroups).Entries[0]) break;
            pCVar7 = (pPVar4->LayerGroups).Entries[local_10c];
            uVar8 = 0;
            while (pCVar7 = pCVar7 + 1, uVar8 = uVar8 + 1, uVar8 < uVar10) {
              if (uVar9 + 1 == *pCVar7) goto LAB_080b2366;
            }
          }
          local_10c = local_10c + 1;
          local_114 = (PCBType *)&local_114->InvisibleObjectsColor;
        } while (local_10c < uVar9);
      }
LAB_080b2366:
      if (local_10c != local_e8) goto LAB_080b2081;
    }
    iVar1 = r_search(Data->pad_tree,&region,(_func_int_BoxType_ptr_void_ptr *)0x0,pad_sub_callback,
                     &info);
    local_100 = local_100 + iVar1;
  }
LAB_080b2081:
  polygon->NoHolesValid = 0;
  return local_100;
}



// WARNING: Unknown calling convention

int add_plow(DataTypePtr Data,LayerTypePtr Layer,PolygonTypePtr Polygon,int type,void *ptr1,
            void *ptr2)

{
  POLYAREA *np;
  POLYAREA *np1;
  int iVar1;
  
  if (type == 0x10) {
LAB_080b2438:
    if ((*(byte *)((int)ptr2 + 0x14) & 0x20) == 0) goto LAB_080b2442;
  }
  else if (type < 0x11) {
    if (type != 1) {
      if (type != 4) {
        return 0;
      }
      goto LAB_080b2438;
    }
  }
  else if (type != 0x200) {
    if (type == 0x4000) goto LAB_080b2438;
    if (type != 0x100) {
      return 0;
    }
  }
  np1 = BoxPolyBloated((BoxType *)ptr2,10);
  if ((np1 != (POLYAREA *)0x0) && (iVar1 = Unsubtract(np1,Polygon), iVar1 != 0)) {
    clearPoly(PCB->Data,Layer,Polygon,(BoxType *)ptr2,0x14);
    return 1;
  }
LAB_080b2442:
  return (int)&DAT_00000001;
}



// WARNING: Unknown calling convention

int PlowsPolygon(DataType *Data,int type,void *ptr1,void *ptr2,
                _func_int_DataTypePtr_LayerTypePtr_PolygonTypePtr_int_void_ptr_void_ptr *call_back)

{
  int *piVar1;
  Cardinal *pCVar2;
  uint uVar3;
  LayerType *pLVar4;
  Cardinal number;
  Cardinal CVar5;
  int iVar6;
  Cardinal sn;
  Cardinal number_1;
  Cardinal sn_1;
  Cardinal number_2;
  int iVar7;
  Cardinal n;
  PCBType *pPVar8;
  DataType *pDVar9;
  Cardinal entry_2;
  Cardinal n_1;
  uint uVar10;
  int r;
  Cardinal entry;
  uint uVar11;
  Cardinal entry_1;
  int local_54;
  uint local_50;
  plow_info info;
  BoxType sb;
  
                    // WARNING: Load size is inaccurate
  sb.X1 = *ptr2;
  info.ptr2 = ptr2;
  info.ptr1 = ptr1;
  sb.Y1 = *(LocationType *)((int)ptr2 + 4);
  info.data = (DataTypePtr)Data;
  info.callback = call_back;
  sb.X2 = *(LocationType *)((int)ptr2 + 8);
  sb.Y2 = *(LocationType *)((int)ptr2 + 0xc);
  info.type = type;
  if (type == 0x10) {
LAB_080b2610:
    if (((*(byte *)((int)ptr2 + 0x14) & 0x20) != 0) &&
       (iVar6 = GetLayerNumber((DataTypePtr)Data,(LayerTypePtr)ptr1), iVar6 < PCB->Data->LayerN)) {
      uVar11 = 0;
      local_54 = 0;
      while( true ) {
        pPVar8 = Data->pcb;
        CVar5 = GetLayerNumber((DataTypePtr)Data,(LayerTypePtr)ptr1);
        iVar6 = GetLayerGroupNumberByNumber(CVar5);
        if ((pPVar8->LayerGroups).Number[iVar6] <= uVar11) break;
        pPVar8 = Data->pcb;
        CVar5 = GetLayerNumber((DataTypePtr)Data,(LayerTypePtr)ptr1);
        iVar6 = GetLayerGroupNumberByNumber(CVar5);
        uVar10 = (pPVar8->LayerGroups).Entries[iVar6][uVar11];
        if (uVar10 < (uint)PCB->Data->LayerN) {
          info.layer = Data->Layer + uVar10;
          iVar6 = r_search(Data->Layer[uVar10].polygon_tree,&sb,
                           (_func_int_BoxType_ptr_void_ptr *)0x0,plow_callback,&info);
          local_54 = local_54 + iVar6;
        }
        uVar11 = uVar11 + 1;
      }
      return local_54;
    }
  }
  else {
    if (type < 0x11) {
      if (type == 2) {
        if (*(uint *)((int)ptr1 + 0xe0) != 0) {
          uVar10 = 0;
          uVar11 = *(uint *)((int)ptr1 + 0xe0);
          do {
            PlowsPolygon(Data,0x100,ptr1,(void *)(uVar10 * 0x4c + *(int *)((int)ptr1 + 0x100)),
                         call_back);
            uVar3 = *(uint *)((int)ptr1 + 0xe0);
            if (uVar3 == 0) break;
            uVar10 = (uVar3 + 1 + uVar10) - uVar11;
            uVar11 = uVar3;
          } while (uVar10 < uVar3);
        }
        uVar11 = *(uint *)((int)ptr1 + 0xe8);
        local_50 = 0;
        do {
          uVar10 = uVar11;
          do {
            if (uVar10 == 0) {
              return 0;
            }
            if (uVar10 <= local_50) {
              return 0;
            }
            PlowsPolygon(Data,0x200,ptr1,(void *)(*(int *)((int)ptr1 + 0x104) + local_50 * 0x68),
                         call_back);
            uVar10 = *(uint *)((int)ptr1 + 0xe8);
          } while (uVar10 != uVar11);
          local_50 = local_50 + 1;
        } while( true );
      }
      if (type == 4) goto LAB_080b2610;
      if (type != 1) {
        return 0;
      }
    }
    else {
      if (type == 0x200) {
        iVar6 = GetLayerGroupNumberByNumber
                          (((*(uint *)((int)ptr2 + 0x14) >> 7 ^ 1) & 1) + PCB->Data->LayerN);
        pPVar8 = Data->pcb;
        if ((pPVar8->LayerGroups).Number[iVar6] == 0) {
          return 0;
        }
        uVar11 = 0;
        local_54 = 0;
        do {
          while (uVar10 = (pPVar8->LayerGroups).Entries[iVar6][uVar11],
                (uint)PCB->Data->LayerN <= uVar10) {
            uVar11 = uVar11 + 1;
            pCVar2 = (pPVar8->LayerGroups).Number + iVar6;
            if (*pCVar2 < uVar11 || *pCVar2 == uVar11) {
              return local_54;
            }
          }
          uVar11 = uVar11 + 1;
          info.layer = Data->Layer + uVar10;
          iVar7 = r_search(Data->Layer[uVar10].polygon_tree,&sb,
                           (_func_int_BoxType_ptr_void_ptr *)0x0,plow_callback,&info);
          pPVar8 = Data->pcb;
          local_54 = local_54 + iVar7;
          pCVar2 = (pPVar8->LayerGroups).Number + iVar6;
        } while (uVar11 <= *pCVar2 && *pCVar2 != uVar11);
        return local_54;
      }
      if (type == 0x4000) goto LAB_080b2610;
      if (type != 0x100) {
        return 0;
      }
    }
    if (((ptr1 != ptr2) && (type != 0x100)) && (ptr1 != (void *)0x0)) {
      entry = 0;
      local_54 = 0;
      while( true ) {
        pPVar8 = Data->pcb;
        CVar5 = GetLayerNumber((DataTypePtr)Data,(LayerTypePtr)ptr1);
        iVar6 = GetLayerGroupNumberByNumber(CVar5);
        if ((pPVar8->LayerGroups).Number[iVar6] <= entry) break;
        pPVar8 = Data->pcb;
        CVar5 = GetLayerNumber((DataTypePtr)Data,(LayerTypePtr)ptr1);
        iVar6 = GetLayerGroupNumberByNumber(CVar5);
        uVar11 = (pPVar8->LayerGroups).Entries[iVar6][entry];
        if (uVar11 < (uint)PCB->Data->LayerN) {
          info.layer = Data->Layer + uVar11;
          iVar6 = r_search(Data->Layer[uVar11].polygon_tree,&sb,
                           (_func_int_BoxType_ptr_void_ptr *)0x0,plow_callback,&info);
          local_54 = local_54 + iVar6;
        }
        entry = entry + 1;
      }
      return local_54;
    }
    if (PCB->Data->LayerN != 0) {
      iVar6 = 0;
      pDVar9 = Data;
      uVar11 = 0;
      do {
        uVar10 = uVar11 + 1;
        info.layer = Data->Layer + uVar11;
        pLVar4 = pDVar9->Layer;
        pDVar9 = (DataType *)&pDVar9->Layer[0].ArcN;
        iVar7 = r_search(pLVar4->polygon_tree,&sb,(_func_int_BoxType_ptr_void_ptr *)0x0,
                         plow_callback,&info);
        iVar6 = iVar6 + iVar7;
        piVar1 = &PCB->Data->LayerN;
        uVar11 = uVar10;
      } while (uVar10 <= (uint)*piVar1 && *piVar1 != uVar10);
      return iVar6;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean RemoveExcessPolygonPoints(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  int iVar1;
  Boolean BVar2;
  int iVar3;
  uint uVar4;
  PointTypePtr pt2;
  PointTypePtr Ptr3;
  PointTypePtr pt3;
  PointTypePtr pPVar5;
  PointTypePtr pt1;
  PointTypePtr pPVar6;
  int iVar7;
  Cardinal n;
  int in_GS_OFFSET;
  Boolean local_81;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  BVar2 = Undoing();
  if (BVar2 == '\0') {
    Ptr3 = Polygon->Points;
    if (Polygon->PointN != 0) {
      iVar3 = Polygon->PointN - 1;
      iVar7 = 0;
      pPVar6 = Ptr3 + iVar3;
      local_81 = '\0';
      pPVar5 = Ptr3;
      do {
        pPVar5 = pPVar5 + 1;
        if (iVar3 == iVar7) {
          pPVar5 = Polygon->Points;
        }
        line.Point1.X = pPVar6->X;
        line.Point1.Y = pPVar6->Y;
        line.Point1.X2 = pPVar6->X2;
        line.Point1.Y2 = pPVar6->Y2;
        line.Point1.ID = pPVar6->ID;
        line.Point2.X = pPVar5->X;
        line.Point2.Y = pPVar5->Y;
        line.Point2.X2 = pPVar5->X2;
        line.Point2.Y2 = pPVar5->Y2;
        line.Point2.ID = pPVar5->ID;
        line.Thickness = 0;
        BVar2 = IsPointOnLine((float)Ptr3->X,(float)Ptr3->Y,0.0,&line);
        if (BVar2 == '\0') {
          uVar4 = Polygon->PointN;
          if (uVar4 <= iVar7 + 1U) goto LAB_080b2a50;
        }
        else {
          RemoveObject(0x800,Layer,Polygon,Ptr3);
          local_81 = '\x01';
          uVar4 = Polygon->PointN;
          if (uVar4 <= iVar7 + 1U) goto LAB_080b2a50;
        }
        iVar7 = iVar7 + 1;
        if (iVar7 == 1) {
          pPVar6 = Polygon->Points;
        }
        else {
          pPVar6 = pPVar6 + 1;
        }
        Ptr3 = Ptr3 + 1;
        iVar3 = uVar4 - 1;
      } while( true );
    }
  }
  local_81 = '\0';
LAB_080b2a50:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_81;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int InitClip(DataTypePtr Data,LayerTypePtr layer,PolygonType *p)

{
  POLYAREA *pPVar1;
  
  if (inhibit == '\0') {
    if (p->Clipped != (POLYAREA *)0x0) {
      poly_Free(&p->Clipped);
    }
    pPVar1 = original_poly(p);
    p->Clipped = pPVar1;
    poly_FreeContours(&p->NoHoles);
    if (p->Clipped != (POLYAREA *)0x0) {
      if ((*(byte *)&(p->Flags).f & 0x10) == 0) {
        p->NoHolesValid = 0;
        return 1;
      }
      clearPoly(Data,layer,p,(BoxType *)0x0,0);
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void ClearFromPolygon(DataType *Data,int type,void *ptr1,void *ptr2)

{
  if (type != 8) {
    PlowsPolygon(Data,type,ptr1,ptr2,subtract_plow);
    return;
  }
  InitClip(PCB->Data,(LayerTypePtr)ptr1,(PolygonType *)ptr2);
  return;
}



// WARNING: Unknown calling convention

void RestoreToPolygon(DataType *Data,int type,void *ptr1,void *ptr2)

{
  if (type != 8) {
    PlowsPolygon(Data,type,ptr1,ptr2,add_plow);
    return;
  }
  InitClip(PCB->Data,(LayerTypePtr)ptr1,(PolygonType *)ptr2);
  return;
}



// WARNING: Unknown calling convention

void ComputeNoHoles(PolygonType *poly)

{
  poly_FreeContours(&poly->NoHoles);
  if (poly->Clipped != (POLYAREA *)0x0) {
    NoHolesPolygonDicer(poly,(BoxType *)0x0,add_noholes_polyarea,poly);
    poly->NoHolesValid = 1;
    return;
  }
  __printf_chk(1,"Compute_noholes caught poly->Clipped = NULL\n");
  poly->NoHolesValid = 1;
  return;
}



// WARNING: Removing unreachable block (ram,0x080b2d44)
// WARNING: Unknown calling convention

POLYAREA * SquarePadPoly(PadType *pad,BDimension clear)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  PLINE *c;
  POLYAREA *pPVar10;
  POLYAREA *np;
  VNODE *pVVar11;
  int iVar12;
  int iVar13;
  PadType *pPVar14;
  PadType *pPVar15;
  PLINE *contour;
  int in_GS_OFFSET;
  double tx;
  double ty;
  double cx;
  double cy;
  int local_118;
  int local_114;
  int local_110;
  Vector v;
  PadType _c;
  PadType _t;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pPVar14 = pad;
  pPVar15 = &_t;
  for (iVar12 = 0x1a; iVar12 != 0; iVar12 = iVar12 + -1) {
    (pPVar15->BoundingBox).X1 = (pPVar14->BoundingBox).X1;
    pPVar14 = (PadType *)&(pPVar14->BoundingBox).Y1;
    pPVar15 = (PadType *)&(pPVar15->BoundingBox).Y1;
  }
  local_110 = _t.Point2.X;
  pPVar14 = pad;
  pPVar15 = &_c;
  for (iVar12 = 0x1a; iVar12 != 0; iVar12 = iVar12 + -1) {
    (pPVar15->BoundingBox).X1 = (pPVar14->BoundingBox).X1;
    pPVar14 = (PadType *)&(pPVar14->BoundingBox).Y1;
    pPVar15 = (PadType *)&(pPVar15->BoundingBox).Y1;
  }
  iVar12 = (pad->Thickness + 1) / 2;
  iVar13 = (clear + 1) / 2;
  dVar5 = (double)((pad->Point1).X - (pad->Point2).X);
  dVar2 = (double)((pad->Point1).Y - (pad->Point2).Y);
  dVar2 = SQRT(dVar2 * dVar2 + dVar5 * dVar5);
  dVar5 = 0.0;
  if (dVar2 == 0.0) {
    dVar1 = (double)iVar12;
    dVar6 = (double)iVar13;
    dVar3 = (double)_t.Point1.Y + dVar1;
    dVar2 = (double)_t.Point2.Y - dVar1;
    dVar7 = (double)_c.Point1.Y + dVar6;
    dVar8 = (double)_c.Point2.Y - dVar6;
    dVar4 = 0.0;
  }
  else {
    dVar4 = (double)iVar12 / dVar2;
    dVar1 = (double)(_t.Point1.Y - _t.Point2.Y) * dVar4;
    dVar4 = (double)(_t.Point2.X - _t.Point1.X) * dVar4;
    dVar5 = dVar2 / (double)iVar13;
    dVar6 = (double)(_c.Point1.Y - _c.Point2.Y) * dVar5;
    dVar5 = (double)(_c.Point2.X - _c.Point1.X) * dVar5;
    _t.Point1.X = (LocationType)ROUND((double)_t.Point1.X - dVar4);
    dVar3 = (double)_t.Point1.Y + dVar1;
    local_110 = (int)ROUND((double)_t.Point2.X + dVar4);
    dVar2 = (double)_t.Point2.Y - dVar1;
    _c.Point1.X = (LocationType)ROUND((double)_c.Point1.X - dVar5);
    dVar7 = (double)_c.Point1.Y + dVar6;
    _c.Point2.X = (LocationType)ROUND((double)_c.Point2.X + dVar5);
    dVar8 = (double)_c.Point2.Y - dVar6;
  }
  local_114 = (int)ROUND(dVar2);
  local_118 = (int)ROUND(dVar3);
  v[0] = (int)ROUND((double)_c.Point1.X - dVar1);
  v[1] = (int)ROUND((double)(int)ROUND(dVar7) - dVar4);
  c = poly_NewContour(v);
  pPVar10 = (POLYAREA *)0x0;
  if (c != (PLINE *)0x0) {
    dVar2 = (double)local_118;
    dVar3 = (double)_t.Point1.X;
    frac_circle(c,(int)ROUND(dVar3 - dVar1),(int)ROUND(dVar2 - dVar4),v,4);
    dVar7 = (double)local_110;
    v[0] = (int)ROUND(dVar7 - dVar6);
    dVar9 = (double)local_114;
    v[1] = (int)ROUND(dVar9 - dVar5);
    pVVar11 = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,pVVar11);
    frac_circle(c,(int)ROUND(dVar7 - dVar1),(int)ROUND(dVar9 - dVar4),v,4);
    v[0] = (int)ROUND(dVar1 + (double)_c.Point2.X);
    v[1] = (int)ROUND(dVar4 + (double)(int)ROUND(dVar8));
    pVVar11 = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,pVVar11);
    frac_circle(c,(int)ROUND(dVar7 + dVar1),(int)ROUND(dVar9 + dVar4),v,4);
    v[0] = (int)ROUND(dVar6 + dVar3);
    v[1] = (int)ROUND(dVar2 + dVar5);
    pVVar11 = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,pVVar11);
    frac_circle(c,(int)ROUND(dVar1 + dVar3),(int)ROUND(dVar2 + dVar4),v,4);
    pPVar10 = ContourToPoly(c);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pPVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Removing unreachable block (ram,0x080b345e)
// WARNING: Unknown calling convention

POLYAREA * LinePoly(LineType *L,BDimension thick)

{
  double dVar1;
  double dVar2;
  double dVar3;
  long half;
  POLYAREA *np;
  PLINE *c;
  VNODE *pVVar4;
  int iVar5;
  uint uVar6;
  PLINE *contour;
  LineType *pLVar7;
  int in_GS_OFFSET;
  double dy;
  double dx;
  int local_b0;
  int local_ac;
  int local_a8;
  Vector v;
  LineType _l;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pLVar7 = &_l;
  for (iVar5 = 0x16; iVar5 != 0; iVar5 = iVar5 + -1) {
    (pLVar7->BoundingBox).X1 = (L->BoundingBox).X1;
    L = (LineType *)&(L->BoundingBox).Y1;
    pLVar7 = (LineType *)&(pLVar7->BoundingBox).Y1;
  }
  if (0 < thick) {
    iVar5 = thick + 1 >> 1;
    dVar3 = (double)(_l.Point1.Y - _l.Point2.Y);
    uVar6 = _l.Flags.f & 0x100;
    dVar3 = SQRT(dVar3 * dVar3 +
                 (double)(_l.Point1.X - _l.Point2.X) * (double)(_l.Point1.X - _l.Point2.X));
    if ((uVar6 == 0) && (dVar3 == 0.0)) {
      np = CirclePoly(_l.Point1.X,_l.Point1.Y,iVar5);
      goto LAB_080b3422;
    }
    dVar2 = 0.0;
    if (dVar3 == 0.0) {
      dVar1 = (double)iVar5;
    }
    else {
      dVar1 = (double)(_l.Point1.Y - _l.Point2.Y) * ((double)iVar5 / dVar3);
      dVar2 = (double)(_l.Point2.X - _l.Point1.X) * ((double)iVar5 / dVar3);
    }
    if (uVar6 == 0) {
      local_a8 = _l.Point1.X;
      local_ac = _l.Point2.X;
      local_b0 = _l.Point2.Y;
    }
    else {
      local_a8 = (int)ROUND((double)_l.Point1.X - dVar2);
      _l.Point1.Y = (LocationType)ROUND((double)_l.Point1.Y + dVar1);
      local_ac = (int)ROUND((double)_l.Point2.X + dVar2);
      local_b0 = (int)ROUND((double)_l.Point2.Y - dVar1);
    }
    v[0] = (int)ROUND((double)local_a8 - dVar1);
    v[1] = (int)ROUND((double)_l.Point1.Y - dVar2);
    c = poly_NewContour(v);
    if (c != (PLINE *)0x0) {
      v[0] = (int)ROUND((double)local_ac - dVar1);
      v[1] = (int)ROUND((double)local_b0 - dVar2);
      if (uVar6 == 0) {
        frac_circle(c,local_ac,local_b0,v,2);
      }
      else {
        pVVar4 = poly_CreateNode(v);
        poly_InclVertex((c->head).prev,pVVar4);
      }
      v[0] = (int)ROUND((double)local_ac + dVar1);
      v[1] = (int)ROUND((double)local_b0 + dVar2);
      pVVar4 = poly_CreateNode(v);
      poly_InclVertex((c->head).prev,pVVar4);
      v[0] = (int)ROUND(dVar1 + (double)local_a8);
      v[1] = (int)ROUND(dVar2 + (double)_l.Point1.Y);
      if (uVar6 == 0) {
        frac_circle(c,local_a8,_l.Point1.Y,v,2);
      }
      else {
        pVVar4 = poly_CreateNode(v);
        poly_InclVertex((c->head).prev,pVVar4);
      }
      np = ContourToPoly(c);
      goto LAB_080b3422;
    }
  }
  np = (POLYAREA *)0x0;
LAB_080b3422:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return np;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

POLYAREA * ArcPolyNoIntersect(ArcType *a,BDimension thick)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  POLYAREA *np;
  BoxTypePtr pBVar6;
  int iVar7;
  int iVar8;
  PLINE *c;
  VNODE *pVVar9;
  int iVar10;
  int i;
  PLINE *contour;
  double ang;
  double local_4c;
  double local_3c;
  double local_34 [2];
  Vector v;
  
  if (0 < thick) {
    if (a->Delta < 0) {
      a->StartAngle = a->StartAngle + a->Delta;
      a->Delta = -a->Delta;
    }
    iVar10 = thick + 1 >> 1;
    pBVar6 = GetArcEnds((ArcTypePtr)a);
    iVar7 = a->Width - iVar10;
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    iVar8 = a->Height - iVar10;
    dVar1 = (double)iVar7;
    if (iVar8 < 0) {
      iVar8 = 0;
    }
    iVar7 = a->Delta;
    dVar2 = (double)iVar8;
    dVar3 = (double)a->StartAngle;
    sincos(dVar3 * 0.0174532925199433,local_34,&local_3c);
    v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
    v[1] = (int)ROUND(local_34[0] * dVar2 + (double)a->Y);
    c = poly_NewContour(v);
    if (c != (PLINE *)0x0) {
      iVar8 = iVar7 / 5;
      dVar4 = (double)iVar7 / (double)iVar8;
      if (0 < iVar8 + -1) {
        iVar7 = 0;
        do {
          dVar3 = dVar3 + dVar4;
          iVar7 = iVar7 + 1;
          sincos(dVar3 * 0.0174532925199433,local_34,&local_3c);
          v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
          v[1] = (int)ROUND(local_34[0] * dVar2 + (double)a->Y);
          pVVar9 = poly_CreateNode(v);
          poly_InclVertex((c->head).prev,pVVar9);
        } while (iVar7 < iVar8 + -1);
      }
      local_4c = (double)(a->Delta + a->StartAngle);
      sincos(local_4c * 0.0174532925199433,local_34,&local_3c);
      dVar3 = local_34[0];
      dVar5 = local_3c;
      v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
      v[1] = (int)ROUND(dVar2 * local_34[0] + (double)a->Y);
      frac_circle(c,pBVar6->X2,pBVar6->Y2,v,2);
      dVar1 = (double)(iVar10 + a->Width);
      if (0 < iVar8) {
        iVar7 = 0;
        while( true ) {
          iVar7 = iVar7 + 1;
          v[0] = (int)ROUND((double)a->X - dVar5 * dVar1);
          v[1] = (int)ROUND(dVar3 * dVar1 + (double)a->Y);
          pVVar9 = poly_CreateNode(v);
          poly_InclVertex((c->head).prev,pVVar9);
          if (iVar8 <= iVar7) break;
          local_4c = local_4c + -dVar4;
          sincos(local_4c * 0.0174532925199433,local_34,&local_3c);
          dVar3 = local_34[0];
          dVar5 = local_3c;
        }
      }
      sincos((double)a->StartAngle * 0.0174532925199433,local_34,&local_3c);
      v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
      v[1] = (int)ROUND(local_34[0] * dVar1 + (double)a->Y);
      frac_circle(c,pBVar6->X1,pBVar6->Y1,v,2);
      np = ContourToPoly(c);
      return np;
    }
  }
  np = (POLYAREA *)0x0;
  return np;
}



// WARNING: Unknown calling convention

POLYAREA * ArcPoly(ArcType *a,BDimension thick)

{
  uint uVar1;
  POLYAREA *ai;
  POLYAREA *bi;
  POLYAREA *tmp2;
  int iVar2;
  POLYAREA *tmp1;
  ArcType *pAVar3;
  ArcType *pAVar4;
  int in_GS_OFFSET;
  POLYAREA *local_ac;
  ArcType seg2;
  ArcType seg1;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  uVar1 = a->Delta;
  if (((double)(((int)uVar1 >> 0x1f ^ uVar1) - ((int)uVar1 >> 0x1f)) / -360.0 + 1.0) *
      (double)a->Width * 6.283185307179586 - (double)thick < 10.0) {
    pAVar3 = &seg2;
    for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {
      (pAVar3->BoundingBox).X1 = (a->BoundingBox).X1;
      a = (ArcType *)&(a->BoundingBox).Y1;
      pAVar3 = (ArcType *)&(pAVar3->BoundingBox).Y1;
    }
    seg1.Delta = (int)uVar1 / 2;
    pAVar3 = &seg2;
    pAVar4 = &seg1;
    for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {
      (pAVar4->BoundingBox).X1 = (pAVar3->BoundingBox).X1;
      pAVar3 = (ArcType *)&(pAVar3->BoundingBox).Y1;
      pAVar4 = (ArcType *)&(pAVar4->BoundingBox).Y1;
    }
    seg2.Delta = seg2.Delta - seg1.Delta;
    seg2.StartAngle = seg2.StartAngle + seg1.Delta;
    ai = ArcPolyNoIntersect(&seg1,thick);
    bi = ArcPolyNoIntersect(&seg2,thick);
    poly_Boolean_free(ai,bi,&local_ac,0);
  }
  else {
    local_ac = ArcPolyNoIntersect(a,thick);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_ac;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void CopyAttachedPolygonToLayer(void)

{
  int iVar1;
  long lVar2;
  FlagType Flags;
  PCBTypePtr pPVar3;
  ulong uVar4;
  PointTypePtr pPVar5;
  PolygonTypePtr Polygon;
  DataTypePtr paVar6;
  LayerTypePtr pLVar7;
  LayerType *pLVar8;
  rtree_t *prVar9;
  int iVar10;
  char cVar11;
  int saveID;
  PolygonTypePtr polygon;
  PolygonType *pPVar12;
  int in_GS_OFFSET;
  byte bVar13;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  bVar13 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags(0);
  if (PCB->SilkActive == '\0') {
    pLVar7 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar7 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  Flags.t._0_4_ = local_18;
  Flags.f = local_1c;
  Flags.t._4_4_ = local_14;
  Polygon = CreateNewPolygon(pLVar7,Flags);
  lVar2 = Polygon->ID;
  (Polygon->BoundingBox).X1 = Crosshair.AttachedPolygon.BoundingBox.X1;
  (Polygon->BoundingBox).Y1 = Crosshair.AttachedPolygon.BoundingBox.Y1;
  (Polygon->BoundingBox).X2 = Crosshair.AttachedPolygon.BoundingBox.X2;
  (Polygon->BoundingBox).Y2 = Crosshair.AttachedPolygon.BoundingBox.Y2;
  Polygon->ID = Crosshair.AttachedPolygon.ID;
  uVar4 = Crosshair.AttachedPolygon.Flags.f;
  (Polygon->Flags).f = Crosshair.AttachedPolygon.Flags.f;
  *(undefined4 *)(Polygon->Flags).t = Crosshair.AttachedPolygon.Flags.t._0_4_;
  *(undefined4 *)((Polygon->Flags).t + 4) = Crosshair.AttachedPolygon.Flags.t._4_4_;
  Polygon->net = Crosshair.AttachedPolygon.net;
  Polygon->PointN = Crosshair.AttachedPolygon.PointN;
  Polygon->PointMax = Crosshair.AttachedPolygon.PointMax;
  Polygon->Clipped = Crosshair.AttachedPolygon.Clipped;
  Polygon->NoHoles = Crosshair.AttachedPolygon.NoHoles;
  Polygon->NoHolesValid = Crosshair.AttachedPolygon.NoHolesValid;
  pPVar5 = Crosshair.AttachedPolygon.Points;
  Polygon->ID = lVar2;
  (Polygon->Flags).f = uVar4 | 0x10;
  pPVar3 = PCB;
  Polygon->Points = pPVar5;
  if ((*(byte *)((int)&(pPVar3->Flags).f + 2) & 0x10) != 0) {
    (Polygon->Flags).f = uVar4 | 0x30;
  }
  pPVar12 = &Crosshair.AttachedPolygon;
  for (iVar10 = 0xf; iVar10 != 0; iVar10 = iVar10 + -1) {
    (pPVar12->BoundingBox).X1 = 0;
    pPVar12 = (PolygonType *)((int)pPVar12 + ((uint)bVar13 * -2 + 1) * 4);
  }
  SetPolygonBoundingBox(Polygon);
  cVar11 = PCB->SilkActive;
  if (cVar11 == '\0') {
    paVar6 = PCB->Data;
    prVar9 = paVar6->Layer[LayerStack[0]].polygon_tree;
  }
  else {
    paVar6 = PCB->Data;
    prVar9 = paVar6->Layer[(uint)(Settings.ShowSolderSide == '\0') + paVar6->LayerN].polygon_tree;
  }
  if (prVar9 == (rtree_t *)0x0) {
    if (cVar11 == '\0') {
      pLVar8 = paVar6->Layer + LayerStack[0];
    }
    else {
      pLVar8 = paVar6->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar6->LayerN;
    }
    prVar9 = r_create_tree((BoxType **)0x0,0,0);
    pLVar8->polygon_tree = prVar9;
    cVar11 = PCB->SilkActive;
    paVar6 = PCB->Data;
  }
  if (cVar11 == '\0') {
    pLVar8 = paVar6->Layer + LayerStack[0];
  }
  else {
    pLVar8 = paVar6->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar6->LayerN;
  }
  r_insert_entry(pLVar8->polygon_tree,&Polygon->BoundingBox,0);
  if (PCB->SilkActive == '\0') {
    paVar6 = PCB->Data;
    pLVar7 = paVar6->Layer + LayerStack[0];
  }
  else {
    paVar6 = PCB->Data;
    pLVar7 = paVar6->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar6->LayerN;
  }
  InitClip(paVar6,pLVar7,Polygon);
  if (PCB->SilkActive == '\0') {
    pLVar7 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar7 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  DrawPolygon(pLVar7,Polygon,0);
  SetChangedFlag('\x01');
  Crosshair.AttachedLine.State = 0;
  addedLines = 0;
  if (PCB->SilkActive == '\0') {
    pLVar8 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar8 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  AddObjectToCreateUndoList(8,pLVar8,Polygon,Polygon);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  IncrementUndoSerialNumber();
  return;
}



// WARNING: Unknown calling convention

void ClosePolygon(void)

{
  Cardinal n;
  uint uVar1;
  BDimension dy;
  uint uVar2;
  BDimension dx;
  uint uVar3;
  
  if (Crosshair.AttachedPolygon.PointN < 3) {
    Message("A polygon has to have at least 3 points\n");
    return;
  }
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) == 0) {
    uVar1 = Crosshair.AttachedPolygon.Points[Crosshair.AttachedPolygon.PointN - 1].X -
            (Crosshair.AttachedPolygon.Points)->X;
    uVar3 = (int)uVar1 >> 0x1f;
    dx = uVar3 ^ uVar1;
    uVar1 = Crosshair.AttachedPolygon.Points[Crosshair.AttachedPolygon.PointN - 1].Y -
            (Crosshair.AttachedPolygon.Points)->Y;
    uVar2 = (int)uVar1 >> 0x1f;
    uVar1 = uVar1 ^ uVar2;
    dy = uVar1 - uVar2;
    if (((uVar1 != uVar2) && (dx != uVar3)) && (dx - uVar3 != dy)) {
      Message("Cannot close polygon because 45 degree lines are requested.\n");
      return;
    }
  }
  CopyAttachedPolygonToLayer();
  Draw();
  return;
}



int __regparm3 Subtract(POLYAREA *np1,PolygonType *p,Boolean fnp)

{
  double dVar1;
  PLINE *pPVar2;
  PLINE *pPVar3;
  double dVar4;
  POLYAREA **ppPVar5;
  POLYAREA *pPVar6;
  int iVar7;
  int x;
  PLINE *pl;
  POLYAREA *pPVar8;
  POLYAREA *pPVar9;
  double big;
  POLYAREA *local_14;
  POLYAREA *local_10;
  
  local_10 = (POLYAREA *)0x0;
  local_14 = np1;
  if (p->Clipped == (POLYAREA *)0x0) {
    poly_Free(&local_14);
    iVar7 = 1;
  }
  else {
    iVar7 = poly_Boolean_free(p->Clipped,np1,&local_10,2);
    if (iVar7 == 0) {
      if (local_10 == (POLYAREA *)0x0) {
        p->Clipped = (POLYAREA *)0x0;
      }
      else {
        pPVar6 = local_10;
        pPVar8 = (POLYAREA *)0x0;
        dVar4 = -1.0;
        do {
          while (pPVar9 = pPVar6, dVar1 = pPVar9->contours->area, dVar4 < dVar1) {
            pPVar6 = pPVar9->f;
            pPVar8 = pPVar9;
            dVar4 = dVar1;
            if (local_10 == pPVar9->f) goto LAB_080b41d2;
          }
          ppPVar5 = &pPVar9->f;
          pPVar6 = *ppPVar5;
          pPVar9 = pPVar8;
        } while (local_10 != *ppPVar5);
LAB_080b41d2:
        if (local_10 != pPVar9) {
          pPVar2 = pPVar9->contours;
          pPVar3 = local_10->contours;
          p->Clipped = local_10;
          pPVar9->contours = pPVar3;
          local_10->contours = pPVar2;
          return 1;
        }
        p->Clipped = local_10;
        if (local_10 != (POLYAREA *)0x0) {
          return 1;
        }
      }
      Message("Polygon cleared out of existence near (%d, %d)\n",
              ((p->BoundingBox).X2 + (p->BoundingBox).X1) / 2,
              ((p->BoundingBox).Y2 + (p->BoundingBox).Y1) / 2);
      iVar7 = 1;
    }
    else {
      __fprintf_chk(stderr,1,"Error while clipping PBO_SUB: %d\n",iVar7);
      poly_Free(&local_10);
      p->Clipped = (POLYAREA *)0x0;
      if (p->NoHoles != (PLINE *)0x0) {
        __printf_chk(1,"Just leaked in Subtract\n");
      }
      p->NoHoles = (PLINE *)0x0;
      iVar7 = -1;
    }
  }
  return iVar7;
}



// WARNING: Unknown calling convention

int SubtractArc(ArcType *arc,PolygonType *p)

{
  int iVar1;
  POLYAREA *np1;
  POLYAREA *np;
  
  if ((*(byte *)&(arc->Flags).f & 0x20) == 0) {
    iVar1 = 0;
  }
  else {
    np1 = ArcPoly(arc,arc->Clearance + arc->Thickness);
    iVar1 = -1;
    if (np1 != (POLYAREA *)0x0) {
      iVar1 = Subtract(np1,p,(Boolean)np1);
      return iVar1;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int arc_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  if ((*cl != b) && ((*(byte *)&b[1].Y1 & 0x20) != 0)) {
    iVar1 = SubtractArc((ArcType *)b,*(PolygonType **)((int)cl + 0xc));
    if (-1 < iVar1) {
      return 1;
    }
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int SubtractPad(PadType *pad,PolygonType *p)

{
  Boolean fnp;
  POLYAREA *np1;
  POLYAREA *np;
  int iVar1;
  Boolean extraout_CL;
  Boolean extraout_CL_00;
  
  if ((*(byte *)((int)&(pad->Flags).f + 1) & 1) == 0) {
    np1 = LinePoly((LineType *)pad,pad->Clearance + pad->Thickness);
    fnp = extraout_CL_00;
  }
  else {
    np1 = SquarePadPoly(pad,pad->Clearance + pad->Thickness);
    fnp = extraout_CL;
  }
  if (np1 != (POLYAREA *)0x0) {
    iVar1 = Subtract(np1,p,fnp);
    return iVar1;
  }
  return -1;
}



// WARNING: Unknown calling convention

int pad_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  PolygonTypePtr polygon;
  
                    // WARNING: Load size is inaccurate
  if (*cl == b) {
    return 0;
  }
  if (*(char *)&b[1].Y1 < '\0') {
    if (*(char *)((int)cl + 0x10) == '\0') {
      return 0;
    }
  }
  else if (*(char *)((int)cl + 0x10) != '\0') {
    return 0;
  }
  iVar1 = SubtractPad((PadType *)b,*(PolygonType **)((int)cl + 0xc));
  if (iVar1 < 0) {
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 1;
}



// WARNING: Unknown calling convention

int SubtractLine(LineType *line,PolygonType *p)

{
  int iVar1;
  POLYAREA *np1;
  POLYAREA *np;
  
  if ((*(byte *)&(line->Flags).f & 0x20) == 0) {
    iVar1 = 0;
  }
  else {
    np1 = LinePoly(line,line->Clearance + line->Thickness);
    iVar1 = -1;
    if (np1 != (POLYAREA *)0x0) {
      iVar1 = Subtract(np1,p,(Boolean)np1);
      return iVar1;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int line_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  if ((*cl != b) && ((*(byte *)&b[1].Y1 & 0x20) != 0)) {
    iVar1 = SubtractLine((LineType *)b,*(PolygonType **)((int)cl + 0xc));
    if (-1 < iVar1) {
      return 1;
    }
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int SubtractPin(DataType *d,PinType *pin,LayerType *l,PolygonType *p)

{
  POLYAREA *np;
  uint laynum;
  POLYAREA *np1;
  int iVar1;
  Boolean extraout_CL;
  Boolean fnp;
  Boolean extraout_CL_00;
  
  if (pin->Clearance == 0) {
    return 0;
  }
  laynum = GetLayerNumber((DataTypePtr)d,l);
  if ((0xf << (sbyte)((laynum & 1) << 2) & (uint)(pin->Flags).t[laynum >> 1]) == 0) {
    np1 = PinPoly(pin,pin->Thickness,pin->Clearance);
    fnp = extraout_CL_00;
    if (np1 == (POLYAREA *)0x0) {
      return -1;
    }
  }
  else {
    np1 = ThermPoly(d->pcb,(PinTypePtr)pin,laynum);
    fnp = extraout_CL;
    if (np1 == (POLYAREA *)0x0) {
      return 0;
    }
  }
  iVar1 = Subtract(np1,p,fnp);
  return iVar1;
}



// WARNING: Unknown calling convention

int pin_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  if (*cl == b) {
    return 0;
  }
  iVar1 = SubtractPin(*(DataType **)((int)cl + 4),(PinType *)b,*(LayerType **)((int)cl + 8),
                      *(PolygonType **)((int)cl + 0xc));
  if (-1 < iVar1) {
    return 1;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0x14,1);
}



// WARNING: Unknown calling convention

int SubtractText(TextType *text,PolygonType *p)

{
  int iVar1;
  POLYAREA *np1;
  POLYAREA *np;
  
  if ((*(byte *)&(text->Flags).f & 0x20) == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = PCB->Bloat;
    np1 = RoundRect(iVar1 + (text->BoundingBox).X1,(text->BoundingBox).X2 - iVar1,
                    (text->BoundingBox).Y1 + iVar1,(text->BoundingBox).Y2 - iVar1,iVar1);
    iVar1 = -1;
    if (np1 != (POLYAREA *)0x0) {
      iVar1 = Subtract(np1,p,(Boolean)np1);
      return iVar1;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int text_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  if ((*cl != b) && ((*(byte *)&b[1].Y1 & 0x20) != 0)) {
    iVar1 = SubtractText((TextType *)b,*(PolygonType **)((int)cl + 0xc));
    if (-1 < iVar1) {
      return 1;
    }
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int subtract_plow(DataTypePtr Data,LayerTypePtr Layer,PolygonTypePtr Polygon,int type,void *ptr1,
                 void *ptr2)

{
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    if (type == 0x10) {
      SubtractText((TextType *)ptr2,Polygon);
      Polygon->NoHolesValid = 0;
      return 1;
    }
    if (type < 0x11) {
      if (type == 1) goto LAB_080b4718;
      if (type == 4) {
        SubtractLine((LineType *)ptr2,Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
    }
    else {
      if (type == 0x200) {
        SubtractPad((PadType *)ptr2,Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
      if (type == 0x4000) {
        SubtractArc((ArcType *)ptr2,Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
      if (type == 0x100) {
LAB_080b4718:
        SubtractPin((DataType *)Data,(PinType *)ptr2,Layer,Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int seg_in_region(BoxType *b,void *cl)

{
  double dVar1;
  double dVar2;
  double dVar3;
  uint uVar4;
  double y2;
  double y1;
  
  uVar4 = 1;
                    // WARNING: Load size is inaccurate
  dVar1 = *cl;
  if (dVar1 != 0.0) {
    dVar2 = (double)b->X1 * dVar1 + *(double *)((int)cl + 8);
    dVar1 = (double)b->X2 * dVar1 + *(double *)((int)cl + 8);
    dVar3 = dVar1;
    if (dVar2 <= dVar1 || dVar1 != dVar2) {
      dVar3 = dVar2;
    }
    uVar4 = 0;
    if (dVar3 < (double)b->Y2) {
      if (dVar2 <= dVar1) {
        dVar2 = dVar1;
      }
      uVar4 = (uint)((double)b->Y1 <= dVar2);
    }
  }
  return uVar4;
}



// WARNING: Unknown calling convention

int UniteS_Rule(VNODE *cur,DIRECTION *initdir)

{
  *initdir = FORW;
  return (uint)((byte)((*(byte *)&cur->Flags & 7) - 2) < 2);
}



// WARNING: Unknown calling convention

int IsectS_Rule(VNODE *cur,DIRECTION *initdir)

{
  byte bVar1;
  
  *initdir = FORW;
  bVar1 = *(byte *)&cur->Flags & 7;
  return (uint)(bVar1 == 3 || bVar1 == 1);
}



// WARNING: Unknown calling convention

int SubS_Rule(VNODE *cur,DIRECTION *initdir)

{
  byte bVar1;
  
  *initdir = FORW;
  bVar1 = *(byte *)&cur->Flags & 7;
  return (uint)(bVar1 == 4 || bVar1 == 2);
}



// WARNING: Unknown calling convention

int XorS_Rule(VNODE *cur,DIRECTION *initdir)

{
  byte bVar1;
  
  bVar1 = *(byte *)&cur->Flags & 7;
  if (bVar1 == 1) {
    *initdir = BACKW;
    return 1;
  }
  if (bVar1 != 2) {
    return 0;
  }
  *initdir = FORW;
  return 1;
}



// WARNING: Unknown calling convention

int IsectJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  byte bVar1;
  
  bVar1 = *(byte *)&v->Flags & 7;
  return (uint)(bVar1 == 3 || bVar1 == 1);
}



// WARNING: Unknown calling convention

int UniteJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  return (uint)((byte)((*(byte *)&v->Flags & 7) - 2) < 2);
}



// WARNING: Unknown calling convention

int XorJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  byte bVar1;
  
  bVar1 = *(byte *)&v->Flags & 7;
  if (bVar1 == 1) {
    *cdir = BACKW;
    return 1;
  }
  if (bVar1 != 2) {
    return 0;
  }
  *cdir = FORW;
  return 1;
}



// WARNING: Unknown calling convention

int SubJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  int iVar1;
  byte bVar2;
  
  if (p == 'B') {
    bVar2 = *(byte *)&v->Flags & 7;
    if (bVar2 == 1) goto LAB_080b4995;
  }
  else if (p == 'A') {
    bVar2 = *(byte *)&v->Flags & 7;
    if (bVar2 == 2) {
      *cdir = FORW;
      return 1;
    }
  }
  else {
    bVar2 = *(byte *)&v->Flags & 7;
  }
  iVar1 = 0;
  if (bVar2 == 4) {
    if (p != 'A') {
LAB_080b4995:
      *cdir = BACKW;
      return 1;
    }
    *cdir = FORW;
    iVar1 = 1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int jump(VNODE **cur,DIRECTION *cdir,J_Rule rule)

{
  VNODE *e;
  VNODE *pVVar1;
  int iVar2;
  DIRECTION DVar3;
  CVCList *pCVar4;
  CVCList *d;
  CVCList *pCVar5;
  DIRECTION local_20 [4];
  
  pVVar1 = *cur;
  if (pVVar1->cvc_prev == (CVCList *)0x0) {
    if (*cdir != FORW) {
      pVVar1 = pVVar1->prev;
    }
    return (uint)(*(byte *)&pVVar1->Flags >> 3 & 1 ^ 1);
  }
  local_20[0] = *cdir;
  if (local_20[0] == FORW) {
    pCVar4 = pVVar1->cvc_prev->prev;
    pCVar5 = pCVar4;
  }
  else {
    pCVar4 = pVVar1->cvc_next->prev;
    pCVar5 = pCVar4;
  }
  do {
    pVVar1 = pCVar4->parent;
    if (pCVar4->side == 'P') {
      pVVar1 = pVVar1->prev;
    }
    if (((*(byte *)&pVVar1->Flags & 8) == 0) &&
       (iVar2 = (*rule)(pCVar4->poly,pVVar1,local_20), iVar2 != 0)) {
      if (pCVar4->side == 'N') {
        if (local_20[0] == FORW) {
          DVar3 = FORW;
          goto LAB_080b4a8d;
        }
      }
      else if ((pCVar4->side == 'P') && (local_20[0] == BACKW)) {
        DVar3 = BACKW;
LAB_080b4a8d:
        pVVar1 = pCVar4->parent;
        *cdir = DVar3;
        *cur = pVVar1;
        return 1;
      }
    }
    pCVar4 = pCVar4->prev;
    if (pCVar5 == pCVar4) {
      return 0;
    }
    local_20[0] = *cdir;
  } while( true );
}



// WARNING: Unknown calling convention

void poly_IniContour(PLINE *c)

{
  if (c != (PLINE *)0x0) {
    (c->head).prev = &c->head;
    (c->head).next = &c->head;
    c->ymin = 0x7fffffff;
    c->xmin = 0x7fffffff;
    c->ymax = -0x80000000;
    c->xmax = -0x80000000;
  }
  return;
}



// WARNING: Unknown calling convention

int flip_cb(BoxType *b,void *cl)

{
  b[1].X1 = *(LocationType *)(b[1].X1 + 4);
  return 1;
}



// WARNING: Unknown calling convention

void poly_M_Incl(POLYAREA **list,POLYAREA *a)

{
  POLYAREA *pPVar1;
  
  if (*list != (POLYAREA *)0x0) {
    a->f = *list;
    a->b = (*list)->b;
    pPVar1 = (*list)->b;
    (*list)->b = a;
    pPVar1->f = a;
    return;
  }
  a->b = a;
  a->f = a;
  *list = a;
  return;
}



// WARNING: Unknown calling convention

BOOLp poly_InclContour(POLYAREA *p,PLINE *c)

{
  PLINE *pPVar1;
  PLINE *pPVar2;
  PLINE *tmp;
  
  if ((c != (PLINE *)0x0) && (p != (POLYAREA *)0x0)) {
    if ((*(byte *)&c->Flags & 8) == 0) {
      pPVar1 = p->contours;
      if (pPVar1 != (PLINE *)0x0) {
        pPVar2 = pPVar1->next;
        pPVar1->next = c;
        c->next = pPVar2;
        return 1;
      }
    }
    else if (p->contours == (PLINE *)0x0) {
      p->contours = c;
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void poly_Init(POLYAREA *p)

{
  p->b = p;
  p->f = p;
  p->contours = (PLINE *)0x0;
  return;
}



// WARNING: Unknown calling convention

BOOLp inside_sector(VNODE *pn,int *p2)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  longdouble lVar6;
  int n_c;
  uint uVar7;
  int p_n;
  int p_c;
  longdouble lVar8;
  longdouble lVar9;
  longdouble lVar10;
  longdouble lVar11;
  
  iVar1 = pn->point[0];
  iVar2 = pn->point[1];
  lVar8 = (longdouble)(iVar1 - pn->prev->point[0]);
  lVar9 = (longdouble)(iVar2 - pn->prev->point[1]);
  lVar6 = (longdouble)0;
  bVar3 = lVar6 <= lVar8 * (longdouble)(p2[1] - iVar2) - (longdouble)(*p2 - iVar1) * lVar9;
  lVar10 = (longdouble)(pn->next->point[0] - iVar1);
  lVar11 = (longdouble)(pn->next->point[1] - iVar2);
  bVar4 = lVar6 <= (longdouble)(p2[1] - iVar2) * lVar10 - (longdouble)(*p2 - iVar1) * lVar11;
  bVar5 = lVar6 <= lVar11 * lVar8 - lVar9 * lVar10;
  if ((bVar3) && (bVar5)) {
    return (uint)bVar4;
  }
  uVar7 = 0;
  if (!bVar5) {
    uVar7 = (uint)(bVar3 || bVar4);
  }
  return uVar7;
}



// WARNING: Unknown calling convention

void vect_init(int *v,double x,double y)

{
  *v = (int)ROUND(x);
  v[1] = (int)ROUND(y);
  return;
}



// WARNING: Unknown calling convention

int vect_equal(int *v1,int *v2)

{
  if (*v1 != *v2) {
    return 0;
  }
  return (uint)(v1[1] == v2[1]);
}



// WARNING: Unknown calling convention

void vect_sub(int *res,int *v1,int *v2)

{
  int *in_stack_00000004;
  int *in_stack_00000008;
  int *in_stack_0000000c;
  
  *in_stack_00000004 = *in_stack_00000008 - *in_stack_0000000c;
  in_stack_00000004[1] = in_stack_00000008[1] - in_stack_0000000c[1];
  return;
}



// WARNING: Unknown calling convention

void vect_min(int *v1,int *v2,int *v3)

{
  int iVar1;
  
  iVar1 = *v2;
  if (*v3 == iVar1 || *v3 < iVar1) {
    iVar1 = *v3;
  }
  *v1 = iVar1;
  iVar1 = v2[1];
  if (v3[1] == iVar1 || v3[1] < iVar1) {
    iVar1 = v3[1];
  }
  v1[1] = iVar1;
  return;
}



// WARNING: Unknown calling convention

void vect_max(int *v1,int *v2,int *v3)

{
  int iVar1;
  
  iVar1 = *v2;
  if (iVar1 <= *v3) {
    iVar1 = *v3;
  }
  *v1 = iVar1;
  iVar1 = v2[1];
  if (iVar1 <= v3[1]) {
    iVar1 = v3[1];
  }
  v1[1] = iVar1;
  return;
}



// WARNING: Unknown calling convention

double vect_len2(int *v)

{
  return (double)v[1] * (double)v[1] + (double)*v * (double)*v;
}



// WARNING: Unknown calling convention

double vect_dist2(int *v1,int *v2)

{
  return (double)(v1[1] - v2[1]) * (double)(v1[1] - v2[1]) +
         (double)(*v1 - *v2) * (double)(*v1 - *v2);
}



// WARNING: Unknown calling convention

double vect_det2(int *v1,int *v2)

{
  return (double)v2[1] * (double)*v1 - (double)v1[1] * (double)*v2;
}



// WARNING: Removing unreachable block (ram,0x080b50fc)
// WARNING: Removing unreachable block (ram,0x080b5084)
// WARNING: Unknown calling convention

int vect_inters2(int *p1,int *p2,int *q1,int *q2,int *S1,int *S2)

{
  int iVar1;
  int iVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  double deel;
  double s;
  double rqy;
  double rqx;
  double rpx;
  double t;
  int local_30;
  int local_20;
  
  local_30 = *p2;
  iVar8 = *p1;
  iVar10 = *q2;
  iVar1 = *q1;
  iVar13 = iVar8;
  if (iVar8 <= local_30) {
    iVar13 = local_30;
  }
  iVar11 = iVar1;
  if (iVar10 <= iVar1) {
    iVar11 = iVar10;
  }
  if (iVar11 <= iVar13) {
    iVar13 = iVar1;
    if (iVar1 <= iVar10) {
      iVar13 = iVar10;
    }
    iVar11 = iVar8;
    if (local_30 <= iVar8) {
      iVar11 = local_30;
    }
    if (iVar11 <= iVar13) {
      iVar13 = p2[1];
      iVar11 = p1[1];
      iVar2 = q2[1];
      local_20 = q1[1];
      iVar9 = iVar13;
      if (iVar13 < iVar11) {
        iVar9 = iVar11;
      }
      iVar12 = local_20;
      if (iVar2 <= local_20) {
        iVar12 = iVar2;
      }
      if (iVar12 <= iVar9) {
        iVar9 = local_20;
        if (local_20 <= iVar2) {
          iVar9 = iVar2;
        }
        iVar12 = iVar13;
        if (iVar11 < iVar13) {
          iVar12 = iVar11;
        }
        if (iVar12 <= iVar9) {
          dVar4 = (double)(iVar10 - iVar1);
          dVar5 = (double)(iVar2 - local_20);
          dVar6 = (double)(iVar13 - iVar11) * dVar4 - (double)(local_30 - iVar8) * dVar5;
          if (dVar6 == 0.0) {
            if ((double)(local_20 - iVar2) * (double)(iVar1 - iVar8) -
                (double)(local_20 - iVar11) * (double)(iVar1 - iVar10) == 0.0) {
              dVar6 = (double)(iVar8 - local_30);
              dVar4 = (double)(iVar11 - iVar13);
              dVar5 = dVar4 * dVar4 + dVar6 * dVar6;
              if ((dVar6 <= 0.0) && ((dVar6 < 0.0 || (dVar4 <= 0.0)))) {
                dVar5 = -dVar5;
              }
              dVar6 = (double)(iVar8 - iVar1);
              dVar3 = (double)(iVar11 - local_20);
              dVar4 = dVar3 * dVar3 + dVar6 * dVar6;
              if ((dVar6 <= 0.0) && ((dVar6 < 0.0 || (dVar3 <= 0.0)))) {
                dVar4 = -dVar4;
              }
              dVar3 = (double)(iVar8 - iVar10);
              dVar7 = (double)(iVar11 - iVar2);
              dVar6 = dVar7 * dVar7 + dVar3 * dVar3;
              if ((dVar3 <= 0.0) && ((dVar3 < 0.0 || (dVar7 <= 0.0)))) {
                dVar6 = -dVar6;
              }
              iVar9 = iVar8;
              iVar12 = iVar11;
              dVar3 = 0.0;
              if (dVar5 < 0.0) {
                iVar9 = local_30;
                iVar12 = iVar13;
                dVar3 = dVar5;
                dVar5 = 0.0;
                local_30 = iVar8;
                iVar13 = iVar11;
              }
              iVar8 = iVar1;
              iVar11 = iVar2;
              dVar7 = dVar6;
              if (dVar6 < dVar4) {
                iVar8 = iVar10;
                iVar10 = iVar1;
                iVar11 = local_20;
                dVar7 = dVar4;
                dVar4 = dVar6;
                local_20 = iVar2;
              }
              if (dVar4 <= dVar3) {
                if (dVar3 <= dVar7) {
                  if (dVar7 <= dVar5) {
                    *S1 = iVar9;
                    S1[1] = iVar12;
                    *S2 = iVar10;
                    S2[1] = iVar11;
                  }
                  else {
                    S1[1] = iVar12;
                    *S1 = iVar9;
                    S2[1] = iVar13;
                    *S2 = local_30;
                  }
                  goto LAB_080b5060;
                }
              }
              else if (dVar4 <= dVar5) {
                if (dVar7 <= dVar5) {
                  *S1 = iVar8;
                  S1[1] = local_20;
                  *S2 = iVar10;
                  S2[1] = iVar11;
                }
                else {
                  *S1 = local_30;
                  S1[1] = iVar13;
                  *S2 = iVar8;
                  S2[1] = local_20;
                }
LAB_080b5060:
                if ((*S1 == *S2) && (S1[1] == S2[1])) {
                  return 1;
                }
                return 2;
              }
            }
          }
          else {
            if (((iVar8 == iVar1) && (iVar11 == local_20)) ||
               ((local_30 == iVar1 && (iVar13 == local_20)))) {
              *S1 = iVar1;
              S1[1] = q1[1];
              return 1;
            }
            if (((iVar8 == iVar10) && (iVar11 == iVar2)) ||
               ((local_30 == iVar10 && (iVar13 == iVar2)))) {
              *S1 = iVar10;
              S1[1] = q2[1];
              return 1;
            }
            dVar3 = ((double)(local_20 - iVar11) * dVar4 + (double)(iVar8 - iVar1) * dVar5) / dVar6;
            if ((((0.0 <= dVar3) && (dVar3 <= 1.0)) &&
                (dVar6 = ((double)(local_30 - iVar8) * (double)(local_20 - iVar11) +
                         (double)(iVar13 - iVar11) * (double)(iVar8 - iVar1)) / dVar6, 0.0 <= dVar6)
                ) && (dVar6 <= 1.0)) {
              dVar4 = dVar4 * dVar6;
              if (dVar4 <= 0.0) {
                dVar4 = dVar4 - 0.5;
              }
              else {
                dVar4 = dVar4 + 0.5;
              }
              dVar5 = dVar5 * dVar6;
              *S1 = (int)ROUND(dVar4) + iVar1;
              if (dVar5 <= 0.0) {
                dVar5 = dVar5 - 0.5;
              }
              else {
                dVar5 = dVar5 + 0.5;
              }
              S1[1] = (int)ROUND(dVar5) + q1[1];
              return 1;
            }
          }
        }
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

BOOLp poly_ChkContour(PLINE *a)

{
  VNODE *pVVar1;
  double dVar2;
  double dVar3;
  VNODE *pVVar4;
  VNODE *pVVar5;
  VNODE *a1;
  int iVar6;
  int icnt;
  BOOLp BVar7;
  VNODE *hit1;
  VNODE *pVVar8;
  VNODE *hit2;
  VNODE *pVVar9;
  Vector i2;
  Vector i1;
  
  pVVar5 = &a->head;
  a1 = pVVar5;
  do {
    pVVar8 = a1->next;
    pVVar9 = pVVar8;
    while (pVVar4 = pVVar9, pVVar5 != pVVar4) {
      pVVar9 = pVVar8;
      if (a1 != pVVar4) {
        if (pVVar8 == pVVar4) {
          pVVar9 = pVVar8->next;
        }
        else {
          pVVar1 = pVVar4->next;
          pVVar9 = a1;
          if ((a1 != pVVar1) && (pVVar9 = pVVar8, pVVar8 != pVVar1)) {
            iVar6 = vect_inters2(a1->point,pVVar8->point,pVVar4->point,pVVar1->point,i1,i2);
            if ((0 < iVar6) &&
               ((((iVar6 != 1 ||
                  ((dVar2 = (double)(i1[0] - a1->point[0]), dVar3 = (double)(i1[1] - a1->point[1]),
                   pVVar8 = a1, 1e-08 <= dVar3 * dVar3 + dVar2 * dVar2 &&
                   (pVVar8 = a1->next, dVar2 = (double)(i1[0] - pVVar8->point[0]),
                   dVar3 = (double)(i1[1] - pVVar8->point[1]),
                   1e-08 <= dVar3 * dVar3 + dVar2 * dVar2)))) ||
                 ((dVar2 = (double)(i1[0] - pVVar4->point[0]),
                  dVar3 = (double)(i1[1] - pVVar4->point[1]), pVVar9 = pVVar4,
                  1e-08 <= dVar3 * dVar3 + dVar2 * dVar2 &&
                  (pVVar9 = pVVar4->next, dVar2 = (double)(i1[0] - pVVar9->point[0]),
                  dVar3 = (double)(i1[1] - pVVar9->point[1]), 1e-08 <= dVar3 * dVar3 + dVar2 * dVar2
                  )))) || ((((BVar7 = inside_sector(pVVar8,pVVar9->prev->point), BVar7 != 0 ||
                             (BVar7 = inside_sector(pVVar8,pVVar9->next->point), BVar7 != 0)) ||
                            (BVar7 = inside_sector(pVVar9,pVVar8->prev->point), BVar7 != 0)) ||
                           (BVar7 = inside_sector(pVVar9,pVVar8->next->point), BVar7 != 0)))))) {
              return 1;
            }
            pVVar8 = a1->next;
            pVVar9 = pVVar4->next;
          }
        }
      }
    }
    a1 = pVVar8;
    if (pVVar5 == pVVar8) {
      return 0;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void poly_InclVertex(VNODE *after,VNODE *node)

{
  VNODE *pVVar1;
  VNODE *pVVar2;
  double a;
  double b;
  
  pVVar1 = after->next;
  node->prev = after;
  node->next = pVVar1;
  pVVar1 = after->next;
  after->next = node;
  pVVar1->prev = node;
  pVVar1 = node->prev;
  pVVar2 = pVVar1->prev;
  if (pVVar2 != node) {
    if (ABS((double)(pVVar1->point[0] - pVVar2->point[0]) *
            (double)(node->point[1] - pVVar2->point[1]) -
            (double)(pVVar1->point[1] - pVVar2->point[1]) *
            (double)(node->point[0] - pVVar2->point[0])) < 1e-08) {
      pVVar2->next = node;
      node->prev = pVVar2;
      free(pVVar1);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void poly_ExclVertex(VNODE *node)

{
  VNODE *pVVar1;
  
  if (node->cvc_next != (CVCList *)0x0) {
    free(node->cvc_next);
    free(node->cvc_prev);
  }
  pVVar1 = node->prev;
  pVVar1->next = node->next;
  node->next->prev = pVVar1;
  return;
}



// WARNING: Unknown calling convention

void poly_ClrContour(PLINE *c)

{
  VNODE *node;
  VNODE *cur;
  
  node = (c->head).next;
  while (node != &c->head) {
    poly_ExclVertex(node);
    free(node);
    node = (c->head).next;
  }
  (c->head).prev = node;
  (c->head).next = node;
  c->ymin = 0x7fffffff;
  c->xmin = 0x7fffffff;
  c->ymax = -0x80000000;
  c->xmax = -0x80000000;
  return;
}



// WARNING: Unknown calling convention

POLYAREA * poly_Create(void)

{
  POLYAREA *pPVar1;
  
  pPVar1 = (POLYAREA *)malloc(0xc);
  if (pPVar1 != (POLYAREA *)0x0) {
    pPVar1->b = pPVar1;
    pPVar1->f = pPVar1;
    pPVar1->contours = (PLINE *)0x0;
  }
  return pPVar1;
}



// WARNING: Unknown calling convention

CVCList * insert_descriptor(VNODE *a,char poly,char side,CVCList *start)

{
  double dVar1;
  double dVar2;
  CVCList *pCVar3;
  double dVar4;
  CVCList *pCVar5;
  VNODE *pVVar6;
  int iVar7;
  int iVar8;
  CVCList *l;
  CVCList *pCVar9;
  VNODE *pVVar10;
  CVCList *small;
  CVCList *pCVar11;
  CVCList *pCVar12;
  int iVar13;
  CVCList *big;
  CVCList *pCVar14;
  CVCList *pCVar15;
  bool bVar16;
  double ang;
  
  pCVar5 = (CVCList *)malloc(0x1c);
  if (pCVar5 != (CVCList *)0x0) {
    pCVar5->poly = poly;
    pCVar5->head = (CVCList *)0x0;
    pCVar5->parent = a;
    pCVar5->side = side;
    pCVar5->prev = pCVar5;
    pCVar5->next = pCVar5;
    if (side == 'P') {
      pVVar6 = a->prev;
    }
    else {
      pVVar6 = a->next;
    }
    iVar13 = a->point[0];
    iVar7 = pVVar6->point[1] - a->point[1];
    iVar8 = pVVar6->point[0] - iVar13;
    if ((vect_zero[0] == iVar8) && (iVar8 = vect_zero[0], vect_zero[1] == iVar7)) {
      if (side == 'P') {
        pVVar6 = a->prev;
        if (pVVar6->cvc_prev == (CVCList *)0xffffffff) {
          pVVar6->cvc_next = (CVCList *)0x0;
          pVVar6->cvc_prev = (CVCList *)0x0;
        }
        poly_ExclVertex(pVVar6);
        iVar13 = a->point[0];
        iVar7 = a->prev->point[1] - a->point[1];
        iVar8 = a->prev->point[0] - iVar13;
      }
      else {
        pVVar6 = a->next;
        if (pVVar6->cvc_prev == (CVCList *)0xffffffff) {
          pVVar6->cvc_next = (CVCList *)0x0;
          pVVar6->cvc_prev = (CVCList *)0x0;
        }
        poly_ExclVertex(pVVar6);
        iVar13 = a->point[0];
        iVar7 = a->next->point[1] - a->point[1];
        iVar8 = a->next->point[0] - iVar13;
      }
    }
    dVar4 = ABS((double)iVar7) / (ABS((double)iVar8) + ABS((double)iVar7));
    if (iVar8 < 0) {
      if (iVar7 < 0) {
        dVar4 = dVar4 + 2.0;
      }
      else {
        dVar4 = 2.0 - dVar4;
      }
    }
    else if (iVar7 < 0) {
      dVar4 = 4.0 - dVar4;
    }
    pCVar5->angle = dVar4;
    if (start == (CVCList *)0x0) {
      pCVar5->head = pCVar5;
    }
    else {
      pVVar6 = start->parent;
      pCVar9 = start;
      pVVar10 = pVVar6;
      if (iVar13 == pVVar6->point[0]) goto LAB_080b5781;
      do {
        do {
          pCVar3 = pCVar9->head;
          pVVar10 = pCVar3->parent;
          if ((pVVar10->point[0] == pVVar6->point[0]) && (pVVar10->point[1] == pVVar6->point[1])) {
            while (pCVar5 != pCVar3) {
              pCVar9->head = pCVar5;
              pCVar9 = pCVar9->next;
              pCVar3 = pCVar9->head;
            }
            pCVar5->head = start;
            return pCVar5;
          }
          pCVar9 = pCVar3;
        } while (iVar13 != pVVar10->point[0]);
LAB_080b5781:
      } while (pVVar10->point[1] != a->point[1]);
      dVar1 = pCVar9->angle;
      pCVar5->head = pCVar9->head;
      pCVar3 = pCVar9;
      pCVar11 = pCVar9;
      pCVar14 = pCVar9;
      do {
        while( true ) {
          pCVar15 = pCVar3;
          pCVar12 = pCVar15->next;
          dVar2 = pCVar12->angle;
          pCVar3 = pCVar12;
          if (dVar1 <= dVar2) break;
          pCVar11 = pCVar12;
          pCVar14 = pCVar15;
          dVar1 = dVar2;
          if (pCVar9 == pCVar12) goto LAB_080b57d1;
        }
        if ((dVar1 <= dVar4) && (dVar4 <= dVar2)) {
          pCVar5->next = pCVar12;
          pCVar9 = pCVar15->next;
          pCVar5->prev = pCVar15;
          pCVar15->next = pCVar5;
          pCVar9->prev = pCVar5;
          return pCVar5;
        }
        bVar16 = pCVar9 != pCVar12;
        pCVar12 = pCVar11;
        pCVar15 = pCVar14;
        dVar1 = dVar2;
      } while (bVar16);
LAB_080b57d1:
      if (pCVar15->angle <= dVar4) {
        pCVar9 = pCVar15->next;
        pCVar5->prev = pCVar15;
        pCVar5->next = pCVar9;
        pCVar9 = pCVar15->next;
        pCVar15->next = pCVar5;
        pCVar9->prev = pCVar5;
        return pCVar5;
      }
      pCVar5->next = pCVar12;
      pCVar5->prev = pCVar12->prev;
      pCVar9 = pCVar12->prev;
      pCVar12->prev = pCVar5;
      pCVar9->next = pCVar5;
    }
  }
  return pCVar5;
}



// WARNING: Unknown calling convention

CVCList * add_descriptors(PLINE *pl,char poly,CVCList *list)

{
  CVCList *start;
  VNODE *a;
  VNODE *node;
  
  a = &pl->head;
  do {
    if (a->cvc_prev != (CVCList *)0x0) {
      start = insert_descriptor(a,poly,'P',list);
      a->cvc_prev = start;
      if (start == (CVCList *)0x0) {
        return (CVCList *)0x0;
      }
      list = insert_descriptor(a,poly,'N',start);
      a->cvc_next = list;
      if (list == (CVCList *)0x0) {
        return (CVCList *)0x0;
      }
    }
    a = a->next;
    if (&pl->head == a) {
      return list;
    }
  } while( true );
}



// WARNING: Unknown calling convention

int poly_InsideContour(PLINE *c,int *p)

{
  int iVar1;
  pip info;
  BoxType ray;
  
  info.p[0] = *p;
  if ((((c->xmin <= info.p[0]) && (info.p[1] = p[1], c->ymin <= info.p[1])) &&
      (info.p[0] <= c->xmax)) && (info.p[1] <= c->ymax)) {
    ray.Y2 = info.p[1] + 1;
    info.f = 0;
    ray.X2 = 0x7fffffff;
    ray.X1 = info.p[0];
    ray.Y1 = info.p[1];
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar1 == 0) {
      r_search(c->tree,&ray,(_func_int_BoxType_ptr_void_ptr *)0x0,crossing,&info);
    }
    return info.f;
  }
  return 0;
}



// WARNING: Unknown calling convention

int poly_ContourInContour(PLINE *poly,PLINE *inner)

{
  int iVar1;
  
  if ((((poly->xmin <= inner->xmin) && (poly->ymin <= inner->ymin)) && (inner->xmax <= poly->xmax))
     && (inner->ymax <= poly->ymax)) {
    iVar1 = poly_InsideContour(poly,(inner->head).point);
    return iVar1;
  }
  return 0;
}



// WARNING: Unknown calling convention

BOOLp poly_Valid(POLYAREA *p)

{
  PLINE *pPVar1;
  BOOLp BVar2;
  int iVar3;
  PLINE *c;
  
  if ((((p == (POLYAREA *)0x0) || (pPVar1 = p->contours, pPVar1 == (PLINE *)0x0)) ||
      ((*(byte *)&pPVar1->Flags & 8) == 0)) || (BVar2 = poly_ChkContour(pPVar1), BVar2 != 0)) {
LAB_080b5abc:
    BVar2 = 0;
  }
  else {
    for (pPVar1 = p->contours->next; pPVar1 != (PLINE *)0x0; pPVar1 = pPVar1->next) {
      if ((((*(byte *)&pPVar1->Flags & 8) != 0) || (BVar2 = poly_ChkContour(pPVar1), BVar2 != 0)) ||
         (iVar3 = poly_ContourInContour(p->contours,pPVar1), iVar3 == 0)) goto LAB_080b5abc;
    }
    BVar2 = 1;
  }
  return BVar2;
}



// WARNING: Unknown calling convention

BOOLp poly_CheckInside(POLYAREA *p,int *v0)

{
  int iVar1;
  PLINE *cur;
  PLINE *c;
  
  if ((((v0 != (int *)0x0) && (p != (POLYAREA *)0x0)) && (c = p->contours, c != (PLINE *)0x0)) &&
     (iVar1 = poly_InsideContour(c,v0), iVar1 != 0)) {
    do {
      c = c->next;
      if (c == (PLINE *)0x0) {
        return 1;
      }
      iVar1 = poly_InsideContour(c,v0);
    } while (iVar1 == 0);
  }
  return 0;
}



// WARNING: Unknown calling convention

BOOLp poly_M_CheckInside(POLYAREA *p,int *v0)

{
  POLYAREA **ppPVar1;
  BOOLp BVar2;
  POLYAREA *cur;
  POLYAREA *p_00;
  
  if ((v0 != (int *)0x0) && (p_00 = p, p != (POLYAREA *)0x0)) {
    do {
      BVar2 = poly_CheckInside(p_00,v0);
      if (BVar2 != 0) {
        return 1;
      }
      ppPVar1 = &p_00->f;
      p_00 = *ppPVar1;
    } while (*ppPVar1 != p);
  }
  return 0;
}



// WARNING: Unknown calling convention

void poly_InvContour(PLINE *c)

{
  VNODE *pVVar1;
  VNODE *pVVar2;
  VNODE *next;
  VNODE *cur;
  
  pVVar2 = &c->head;
  do {
    pVVar1 = pVVar2->next;
    pVVar2->next = pVVar2->prev;
    pVVar2->prev = pVVar1;
    pVVar2 = pVVar1;
  } while (&c->head != pVVar1);
  *(byte *)&c->Flags = *(byte *)&c->Flags & 0xf7 | (byte)((*(byte *)&c->Flags >> 3 & 1 ^ 1) << 3);
  if (c->tree != (rtree_t *)0x0) {
    r_search(c->tree,(BoxType *)0x0,(_func_int_BoxType_ptr_void_ptr *)0x0,flip_cb,(void *)0x0);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080b5d20)
// WARNING: Unknown calling convention

int crossing(BoxType *b,void *cl)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  longlong lVar5;
  
  piVar1 = (int *)b[1].X1;
  iVar2 = *(int *)((int)cl + 8);
  iVar3 = piVar1[7];
  if (iVar2 < iVar3) {
    iVar4 = *(int *)(*piVar1 + 0x1c);
    if (iVar4 <= iVar2) {
      lVar5 = (longlong)(iVar2 - iVar3) * (longlong)(*(int *)(*piVar1 + 0x18) - piVar1[6]) -
              (longlong)(*(int *)((int)cl + 4) - piVar1[6]) * (longlong)(iVar4 - iVar3);
      if (lVar5 == 0) goto LAB_080b5d2a;
      if (lVar5 < 0) {
                    // WARNING: Load size is inaccurate
        *(int *)cl = *cl + -1;
      }
    }
  }
  else {
    iVar4 = *(int *)(*piVar1 + 0x1c);
    if (iVar2 < iVar4) {
      lVar5 = (longlong)(iVar2 - iVar3) * (longlong)(*(int *)(*piVar1 + 0x18) - piVar1[6]) -
              (longlong)(*(int *)((int)cl + 4) - piVar1[6]) * (longlong)(iVar4 - iVar3);
      if (lVar5 == 0) {
LAB_080b5d2a:
        *(undefined4 *)cl = 1;
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0xc,1);
      }
      if (0 < lVar5) {
                    // WARNING: Load size is inaccurate
        *(int *)cl = *cl + 1;
      }
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

int get_seg(BoxType *b,void *cl)

{
  if (*(int *)((int)cl + 0x14) != b[1].X1) {
    return 0;
  }
  *(BoxType **)((int)cl + 0x18) = b;
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0xb8,1);
}



// WARNING: Unknown calling convention

PLINE * poly_NewContour(int *v)

{
  int iVar1;
  int iVar2;
  PLINE *pPVar3;
  
  pPVar3 = (PLINE *)calloc(1,0x48);
  if (pPVar3 != (PLINE *)0x0) {
    (pPVar3->head).prev = &pPVar3->head;
    (pPVar3->head).next = &pPVar3->head;
    pPVar3->ymin = 0x7fffffff;
    pPVar3->xmin = 0x7fffffff;
    pPVar3->ymax = -0x80000000;
    pPVar3->xmax = -0x80000000;
    if (v != (int *)0x0) {
      iVar1 = *v;
      (pPVar3->head).point[0] = iVar1;
      iVar2 = v[1];
      pPVar3->xmin = iVar1;
      pPVar3->xmax = iVar1 + 1;
      (pPVar3->head).point[1] = iVar2;
      pPVar3->ymin = iVar2;
      pPVar3->ymax = iVar2 + 1;
    }
  }
  return pPVar3;
}



// WARNING: Unknown calling convention

VNODE * poly_CreateNode(int *v)

{
  VNODE *pVVar1;
  
  pVVar1 = (VNODE *)calloc(1,0x20);
  if (pVVar1 != (VNODE *)0x0) {
    pVVar1->point[0] = *v;
    pVVar1->point[1] = v[1];
  }
  return pVVar1;
}



// WARNING: Unknown calling convention

VNODE * node_add(VNODE *dest,int *po,int *new_point)

{
  int iVar1;
  VNODE *pVVar2;
  VNODE *pVVar3;
  VNODE *p;
  
  if (*po == dest->point[0]) {
    if (po[1] == dest->point[1]) {
      return dest;
    }
    pVVar3 = dest->next;
    iVar1 = pVVar3->point[0];
  }
  else {
    pVVar3 = dest->next;
    iVar1 = pVVar3->point[0];
  }
  if ((*po == iVar1) && (po[1] == pVVar3->point[1])) {
    *new_point = *new_point + 4;
  }
  else {
    pVVar3 = poly_CreateNode(po);
    if (pVVar3 == (VNODE *)0x0) {
      pVVar3 = (VNODE *)0x0;
    }
    else {
      pVVar2 = dest->next;
      *new_point = *new_point + 5;
      *(byte *)&pVVar3->Flags = *(byte *)&pVVar3->Flags & 0xf8;
      pVVar3->next = pVVar2;
      pVVar2 = dest->next;
      pVVar3->prev = dest;
      dest->next = pVVar3;
      pVVar3->cvc_next = (CVCList *)0x0;
      pVVar3->cvc_prev = (CVCList *)0x0;
      pVVar2->prev = pVVar3;
    }
  }
  return pVVar3;
}



// WARNING: Unknown calling convention

void * make_edge_tree(PLINE *pb)

{
  VNODE *pVVar1;
  rtree_t *rtree;
  BoxType *which;
  int iVar2;
  VNODE *bv;
  VNODE *pVVar3;
  rtree_t *ans;
  
  rtree = r_create_tree((BoxType **)0x0,0,0);
  pVVar3 = &pb->head;
  do {
    which = (BoxType *)malloc(0x18);
    pVVar1 = pVVar3->next;
    iVar2 = pVVar3->point[0];
    if (iVar2 < pVVar1->point[0]) {
      which->X1 = iVar2;
      which->X2 = pVVar1->point[0] + 1;
      iVar2 = pVVar3->point[1];
      if (iVar2 < pVVar1->point[1]) goto LAB_080b5f0b;
LAB_080b5f61:
      which->Y2 = iVar2 + 1;
      which->Y1 = pVVar1->point[1];
    }
    else {
      which->X2 = iVar2 + 1;
      which->X1 = pVVar1->point[0];
      iVar2 = pVVar3->point[1];
      if (pVVar1->point[1] <= iVar2) goto LAB_080b5f61;
LAB_080b5f0b:
      which->Y1 = iVar2;
      which->Y2 = pVVar1->point[1] + 1;
    }
    which[1].X1 = (LocationType)pVVar3;
    which[1].Y1 = (LocationType)pb;
    r_insert_entry(rtree,which,1);
    pVVar3 = pVVar3->next;
    if (&pb->head == pVVar3) {
      return rtree;
    }
  } while( true );
}



// WARNING: Unknown calling convention

BOOLp poly_CopyContour(PLINE **dst,PLINE *src)

{
  int iVar1;
  PLINE *pPVar2;
  VNODE *newnode;
  VNODE *node;
  rtree_t *prVar3;
  VNODE *cur;
  VNODE *pVVar4;
  
  *dst = (PLINE *)0x0;
  pPVar2 = poly_NewContour((src->head).point);
  *dst = pPVar2;
  if (pPVar2 == (PLINE *)0x0) {
    return 0;
  }
  pPVar2->Count = src->Count;
  *(byte *)&pPVar2->Flags = *(byte *)&pPVar2->Flags & 0xf7 | *(byte *)&src->Flags & 8;
  pPVar2 = *dst;
  iVar1 = src->xmin;
  pVVar4 = (src->head).next;
  pPVar2->area = src->area;
  pPVar2->xmin = iVar1;
  pPVar2->xmax = src->xmax;
  pPVar2->ymin = src->ymin;
  pPVar2->ymax = src->ymax;
  if (pVVar4 != &src->head) {
    do {
      node = poly_CreateNode(pVVar4->point);
      if (node == (VNODE *)0x0) {
        return 0;
      }
      poly_InclVertex(((*dst)->head).prev,node);
      pVVar4 = pVVar4->next;
    } while (pVVar4 != &src->head);
    pPVar2 = *dst;
  }
  prVar3 = (rtree_t *)make_edge_tree(pPVar2);
  pPVar2->tree = prVar3;
  return 1;
}



// WARNING: Unknown calling convention

BOOLp poly_Copy1(POLYAREA *dst,POLYAREA *src)

{
  PLINE *src_00;
  BOOLp BVar1;
  PLINE *cur;
  PLINE **last;
  PLINE **dst_00;
  
  dst->contours = (PLINE *)0x0;
  dst_00 = &dst->contours;
  dst->b = dst;
  dst->f = dst;
  src_00 = src->contours;
  while( true ) {
    if (src_00 == (PLINE *)0x0) {
      return 1;
    }
    BVar1 = poly_CopyContour(dst_00,src_00);
    if (BVar1 == 0) break;
    src_00 = src_00->next;
    dst_00 = &(*dst_00)->next;
  }
  return 0;
}



// WARNING: Unknown calling convention

BOOLp poly_M_Copy0(POLYAREA **dst,POLYAREA *srcfst)

{
  POLYAREA *pPVar1;
  POLYAREA **ppPVar2;
  POLYAREA *dst_00;
  BOOLp BVar3;
  POLYAREA *di;
  POLYAREA *src;
  POLYAREA *src_00;
  
  *dst = (POLYAREA *)0x0;
  src_00 = srcfst;
  if (srcfst == (POLYAREA *)0x0) {
    return 0;
  }
  while( true ) {
    dst_00 = poly_Create();
    if (dst_00 == (POLYAREA *)0x0) {
      return 0;
    }
    BVar3 = poly_Copy1(dst_00,src_00);
    if (BVar3 == 0) break;
    if (*dst == (POLYAREA *)0x0) {
      dst_00->f = dst_00;
      dst_00->b = dst_00;
      *dst = dst_00;
      ppPVar2 = &src_00->f;
      src_00 = *ppPVar2;
      if (*ppPVar2 == srcfst) {
        return 1;
      }
    }
    else {
      dst_00->f = *dst;
      dst_00->b = (*dst)->b;
      pPVar1 = (*dst)->b;
      (*dst)->b = dst_00;
      pPVar1->f = dst_00;
      ppPVar2 = &src_00->f;
      src_00 = *ppPVar2;
      if (*ppPVar2 == srcfst) {
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

BOOLp poly_Copy0(POLYAREA **dst,POLYAREA *src)

{
  POLYAREA *dst_00;
  BOOLp BVar1;
  
  *dst = (POLYAREA *)0x0;
  if (src != (POLYAREA *)0x0) {
    dst_00 = (POLYAREA *)calloc(1,0xc);
    *dst = dst_00;
    if (dst_00 != (POLYAREA *)0x0) {
      BVar1 = poly_Copy1(dst_00,src);
      return BVar1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void poly_PreContour(PLINE *C,BOOLp optimize)

{
  VNODE *pVVar1;
  VNODE *pVVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  double dVar6;
  VNODE *pVVar7;
  bool bVar8;
  VNODE *pVVar9;
  rtree_t *prVar10;
  int iVar11;
  VNODE *c;
  VNODE *node;
  int iVar12;
  VNODE *p;
  int iVar13;
  int iVar14;
  double area;
  int local_40;
  VNODE *local_2c;
  int local_24;
  
  pVVar1 = &C->head;
  if (optimize != 0) {
    pVVar9 = pVVar1;
    pVVar2 = (C->head).next;
    while (node = pVVar2, pVVar7 = pVVar9, pVVar1 != node) {
      while (pVVar2 = node->next, pVVar9 = node,
            (double)(pVVar2->point[1] - node->point[1]) *
            (double)(node->point[0] - pVVar7->point[0]) -
            (double)(node->point[1] - pVVar7->point[1]) *
            (double)(pVVar2->point[0] - node->point[0]) == 0.0) {
        poly_ExclVertex(node);
        free(node);
        node = pVVar7->next;
        if (pVVar1 == node) goto LAB_080b623d;
      }
    }
  }
LAB_080b623d:
  iVar12 = (C->head).point[0];
  iVar11 = (C->head).point[1];
  local_2c = (C->head).prev;
  C->Count = 0;
  C->xmax = iVar12;
  C->xmin = iVar12;
  C->ymax = iVar11;
  C->ymin = iVar11;
  if (pVVar1 == local_2c) {
    bVar8 = false;
    dVar6 = 0.0;
  }
  else {
    dVar6 = 0.0;
    pVVar2 = pVVar1;
    local_40 = iVar12;
    local_24 = iVar11;
    do {
      pVVar9 = pVVar2;
      iVar14 = pVVar9->point[0];
      iVar3 = local_2c->point[0];
      iVar4 = pVVar9->point[1];
      iVar5 = local_2c->point[1];
      iVar13 = iVar14;
      if (local_40 <= iVar14) {
        iVar13 = local_40;
      }
      C->xmin = iVar13;
      dVar6 = (double)(iVar4 + iVar5) * (double)(iVar3 - iVar14) + dVar6;
      iVar14 = pVVar9->point[0] + 1;
      if (iVar12 <= iVar14) {
        iVar12 = iVar14;
      }
      C->xmax = iVar12;
      if (pVVar9->point[1] == iVar11 || pVVar9->point[1] < iVar11) {
        iVar11 = pVVar9->point[1];
      }
      C->ymin = iVar11;
      iVar14 = pVVar9->point[1] + 1;
      if (iVar14 < local_24) {
        iVar14 = local_24;
      }
      C->Count = C->Count + 1;
      C->ymax = iVar14;
      pVVar2 = pVVar9->next;
      local_40 = iVar13;
      local_2c = pVVar9;
      local_24 = iVar14;
    } while (pVVar1 != pVVar9->next);
    bVar8 = dVar6 < 0.0;
    if (dVar6 < 0.0) {
      dVar6 = -dVar6;
    }
  }
  C->area = dVar6;
  if (2 < C->Count) {
    *(byte *)&C->Flags = *(byte *)&C->Flags & 0xf7 | (bVar8 ^ 1U) * '\b';
  }
  prVar10 = (rtree_t *)make_edge_tree(C);
  C->tree = prVar10;
  return;
}



// WARNING: Unknown calling convention

void poly_DelContour(PLINE **c)

{
  VNODE *pVVar1;
  CVCList *__ptr;
  PLINE *__ptr_00;
  rtree_t *r;
  VNODE *cur;
  VNODE *__ptr_01;
  VNODE *prev;
  rtree_t *local_20 [4];
  
  __ptr_00 = *c;
  if (__ptr_00 != (PLINE *)0x0) {
    __ptr_01 = (__ptr_00->head).prev;
    if (&__ptr_00->head != __ptr_01) {
      do {
        pVVar1 = __ptr_01->prev;
        if (__ptr_01->cvc_next != (CVCList *)0x0) {
          free(__ptr_01->cvc_next);
          free(__ptr_01->cvc_prev);
        }
        free(__ptr_01);
        __ptr_00 = *c;
        __ptr_01 = pVVar1;
      } while (&__ptr_00->head != pVVar1);
    }
    __ptr = (__ptr_00->head).cvc_next;
    if (__ptr != (CVCList *)0x0) {
      free(__ptr);
      free(((*c)->head).cvc_prev);
      __ptr_00 = *c;
    }
    if (__ptr_00->tree != (rtree_t *)0x0) {
      local_20[0] = __ptr_00->tree;
      r_destroy_tree(local_20);
      __ptr_00 = *c;
    }
    free(__ptr_00);
    *c = (PLINE *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void poly_FreeContours(PLINE **pline)

{
  PLINE *pl;
  PLINE *local_10;
  
  local_10 = *pline;
  if (local_10 != (PLINE *)0x0) {
    do {
      *pline = local_10->next;
      poly_DelContour(&local_10);
      local_10 = *pline;
    } while (local_10 != (PLINE *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void poly_Free(POLYAREA **p)

{
  POLYAREA *pPVar1;
  POLYAREA *cur;
  POLYAREA *__ptr;
  POLYAREA *pPVar2;
  
  pPVar1 = *p;
  if (pPVar1 != (POLYAREA *)0x0) {
    __ptr = pPVar1->f;
    pPVar2 = __ptr;
    if (pPVar1 != __ptr) {
      do {
        poly_FreeContours(&__ptr->contours);
        pPVar1 = __ptr->f;
        pPVar1->b = __ptr->b;
        __ptr->b->f = pPVar1;
        free(__ptr);
        pPVar2 = *p;
        __ptr = pPVar2->f;
      } while (pPVar2 != __ptr);
    }
    poly_FreeContours(&pPVar2->contours);
    free(*p);
    *p = (POLYAREA *)0x0;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080b6664)
// WARNING: Unknown calling convention

int intersect(jmp_buf *jb,POLYAREA *b,POLYAREA *a,int add)

{
  PLINE *pPVar1;
  double dVar2;
  PLINE *pPVar3;
  PLINE *pb;
  PLINE *pPVar4;
  int iVar5;
  PLINE *pPVar6;
  PLINE *pa;
  double dx;
  VNODE *local_184;
  info info;
  BoxType box;
  
  info.touch = (jmp_buf *)0x0;
  if (add == 0) {
    info.touch = jb;
  }
  _setjmp((__jmp_buf_tag *)info.env);
  pPVar1 = a->contours;
  pPVar4 = b->contours;
  do {
    while( true ) {
      if (pPVar1 == (PLINE *)0x0) {
        return 0;
      }
      if (pPVar4 != (PLINE *)0x0) break;
LAB_080b650f:
      pPVar1 = pPVar1->next;
      pPVar4 = b->contours;
    }
    while ((((pPVar1->xmax < pPVar4->xmin || (pPVar4->xmax < pPVar1->xmin)) ||
            (pPVar1->ymax < pPVar4->ymin)) || (pPVar4->ymax < pPVar1->ymin))) {
      pPVar4 = pPVar4->next;
      if (pPVar4 == (PLINE *)0x0) goto LAB_080b650f;
    }
    pPVar6 = pPVar1;
    pPVar3 = pPVar4;
    if (pPVar1->Count < pPVar4->Count) {
      pPVar6 = pPVar4;
      pPVar3 = pPVar1;
    }
    local_184 = &pPVar3->head;
    do {
      info.v = local_184;
      box.X1 = local_184->point[0];
      dVar2 = (double)(local_184->next->point[0] - box.X1);
      if (dVar2 == 0.0) {
        box.Y1 = local_184->point[1];
        info.m = 0.0;
      }
      else {
        box.Y1 = local_184->point[1];
        info.m = (double)(local_184->next->point[1] - box.Y1) / dVar2;
        info.b = (double)box.Y1 - (double)box.X1 * info.m;
      }
      box.X2 = box.X1 + 1;
      box.Y2 = box.Y1 + 1;
      iVar5 = _setjmp((__jmp_buf_tag *)info.sego);
      if (iVar5 == 0) {
        r_search(pPVar3->tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,get_seg,&info);
      }
      info.tree = pPVar6->tree;
      if ((info.tree != (rtree_t *)0x0) &&
         (iVar5 = r_search(info.tree,&(info.s)->box,seg_in_region,seg_in_seg,&info), iVar5 != 0)) {
        return 2;
      }
      local_184 = local_184->next;
    } while (&pPVar3->head != local_184);
    pPVar4 = pPVar4->next;
  } while( true );
}



// WARNING: Unknown calling convention

void M_POLYAREA_intersect(jmp_buf *e,POLYAREA *afst,POLYAREA *bfst,int add)

{
  PLINE *pPVar1;
  int iVar2;
  PLINE *curcB;
  PLINE *curcA;
  PLINE *pPVar3;
  CVCList *the_list;
  CVCList *list;
  POLYAREA *a;
  POLYAREA *b;
  POLYAREA *local_20;
  
  if ((bfst == (POLYAREA *)0x0) || (afst == (POLYAREA *)0x0)) {
                    // WARNING: Subroutine does not return
    __longjmp_chk(e,3);
  }
  pPVar3 = bfst->contours;
  list = (CVCList *)0x0;
  b = afst;
  local_20 = bfst;
  do {
    pPVar1 = b->contours;
    if ((((pPVar3->xmin <= pPVar1->xmax) && (pPVar3->ymin <= pPVar1->ymax)) &&
        (pPVar1->xmin <= pPVar3->xmax)) && (pPVar1->ymin <= pPVar3->ymax)) {
      iVar2 = intersect(e,b,local_20,add);
      if (iVar2 != 0) {
LAB_080b6790:
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,2);
      }
      pPVar3 = local_20->contours;
    }
    if ((add == 0) || (b = b->f, b == afst)) {
      for (; pPVar3 != (PLINE *)0x0; pPVar3 = pPVar3->next) {
        if (((*(byte *)&pPVar3->Flags & 7) == 3) &&
           (list = add_descriptors(pPVar3,'B',list), list == (CVCList *)0x0)) goto LAB_080b6790;
      }
      if ((add == 0) || (local_20 = local_20->f, local_20 == bfst)) {
        do {
          for (pPVar3 = b->contours; pPVar3 != (PLINE *)0x0; pPVar3 = pPVar3->next) {
            while ((*(byte *)&pPVar3->Flags & 7) == 3) {
              list = add_descriptors(pPVar3,'A',list);
              if (list == (CVCList *)0x0) goto LAB_080b6790;
              pPVar3 = pPVar3->next;
              if (pPVar3 == (PLINE *)0x0) goto LAB_080b6838;
            }
          }
LAB_080b6838:
          if ((add == 0) || (b = b->f, b == afst)) {
            return;
          }
        } while( true );
      }
      pPVar3 = local_20->contours;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void PutContour(jmp_buf *e,PLINE *cntr,POLYAREA **contours,PLINE **holes,PLINE *parent)

{
  POLYAREA *pPVar1;
  POLYAREA *pPVar2;
  POLYAREA *pPVar3;
  POLYAREA *newp;
  
  cntr->next = (PLINE *)0x0;
  if ((*(byte *)&cntr->Flags & 8) == 0) {
    if (parent == (PLINE *)0x0) {
      cntr->next = *holes;
      *holes = cntr;
    }
    else {
      cntr->next = parent->next;
      parent->next = cntr;
    }
  }
  else {
    if (*contours == (POLYAREA *)0x0) {
      pPVar3 = (POLYAREA *)malloc(0xc);
      *contours = pPVar3;
      if (pPVar3 == (POLYAREA *)0x0) goto LAB_080b6908;
      pPVar3->b = pPVar3;
      pPVar3->f = pPVar3;
    }
    else {
      pPVar3 = (POLYAREA *)malloc(0xc);
      if (pPVar3 == (POLYAREA *)0x0) {
LAB_080b6908:
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,2);
      }
      pPVar1 = *contours;
      pPVar2 = pPVar1->b;
      pPVar3->f = pPVar1;
      pPVar3->b = pPVar2;
      pPVar2->f = pPVar3;
      pPVar1->b = pPVar3;
    }
    pPVar3->contours = cntr;
    cntr->next = (PLINE *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void Collect1(jmp_buf *e,VNODE *cur,DIRECTION dir,POLYAREA **contours,PLINE **holes,J_Rule j_rule)

{
  anon_struct_4_2_143986a6_for_Flags *paVar1;
  int iVar2;
  VNODE *pVVar3;
  VNODE *newn;
  DIRECTION local_28;
  VNODE *local_24;
  PLINE *local_20 [4];
  
  if (dir != FORW) {
    cur = cur->next;
  }
  local_20[0] = (PLINE *)0x0;
  local_28 = dir;
  local_24 = cur;
  do {
    iVar2 = jump(&local_24,&local_28,j_rule);
    if (iVar2 == 0) {
      if (local_20[0] != (PLINE *)0x0) {
        poly_PreContour(local_20[0],1);
        if (2 < local_20[0]->Count) {
          PutContour(e,local_20[0],contours,holes,(PLINE *)0x0);
          return;
        }
        poly_DelContour(local_20);
      }
      return;
    }
    if (local_20[0] == (PLINE *)0x0) {
      local_20[0] = poly_NewContour(local_24->point);
      if (local_20[0] == (PLINE *)0x0) goto LAB_080b6a52;
    }
    else {
      pVVar3 = poly_CreateNode(local_24->point);
      if (pVVar3 == (VNODE *)0x0) {
        if (local_20[0] != (PLINE *)0x0) {
          poly_DelContour(local_20);
        }
LAB_080b6a52:
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,2);
      }
      poly_InclVertex((local_20[0]->head).prev,pVVar3);
    }
    pVVar3 = local_24;
    if (local_28 != FORW) {
      pVVar3 = local_24->prev;
    }
    *(byte *)&pVVar3->Flags = *(byte *)&pVVar3->Flags | 8;
    if (pVVar3->shared != (VNODE *)0x0) {
      paVar1 = &pVVar3->shared->Flags;
      *(byte *)paVar1 = *(byte *)paVar1 | 8;
    }
    if (local_28 == FORW) {
      local_24 = local_24->next;
    }
    else {
      local_24 = local_24->prev;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void Collect(jmp_buf *e,PLINE *a,POLYAREA **contours,PLINE **holes,S_Rule s_rule,J_Rule j_rule)

{
  int iVar1;
  VNODE *cur_00;
  VNODE *cur;
  DIRECTION local_24;
  VNODE *local_20 [4];
  
  cur_00 = &a->head;
  do {
    iVar1 = (*s_rule)(cur_00,&local_24);
    if ((iVar1 != 0) && ((*(byte *)&cur_00->Flags & 8) == 0)) {
      Collect1(e,cur_00,local_24,contours,holes,j_rule);
    }
    local_20[0] = cur_00;
    if ((cur_00->cvc_prev == (CVCList *)0x0) ||
       (iVar1 = jump(local_20,&local_24,j_rule), iVar1 == 0)) {
      cur_00 = cur_00->next;
    }
    else {
      Collect1(e,local_20[0],local_24,contours,holes,j_rule);
      cur_00 = cur_00->next;
    }
  } while (&a->head != cur_00);
  return;
}



// WARNING: Unknown calling convention

void M_POLYAREA_Collect(jmp_buf *e,POLYAREA *afst,POLYAREA **contours,PLINE **holes,int action,
                       BOOLp maybe)

{
  byte bVar1;
  POLYAREA *a;
  POLYAREA *pPVar2;
  PLINE *parent_00;
  PLINE *a_00;
  PLINE *parent;
  PLINE *pPVar3;
  code *s_rule;
  code *j_rule;
  POLYAREA *local_24;
  PLINE **local_20;
  
  pPVar2 = afst;
  do {
    pPVar2 = pPVar2->f;
    local_24 = afst;
  } while (pPVar2 != afst);
  do {
    if ((maybe == 0) || (pPVar3 = local_24->contours, (*(byte *)&pPVar3->Flags & 7) == 3)) {
      pPVar3 = (PLINE *)0x0;
    }
    local_20 = &local_24->contours;
LAB_080b6b71:
    a_00 = *local_20;
    if (a_00 != (PLINE *)0x0) {
      do {
        parent_00 = (PLINE *)0x0;
        if (pPVar3 != a_00) {
          parent_00 = pPVar3;
        }
        bVar1 = *(byte *)&a_00->Flags & 7;
        if (bVar1 == 3) {
          if (action == 1) {
            Collect(e,a_00,contours,holes,IsectS_Rule,IsectJ_Rule);
          }
          else if (action < 2) {
            if (action == 0) {
              j_rule = UniteJ_Rule;
              s_rule = UniteS_Rule;
              goto LAB_080b6d18;
            }
          }
          else if (action == 2) {
            j_rule = SubJ_Rule;
            s_rule = SubS_Rule;
LAB_080b6d18:
            Collect(e,a_00,contours,holes,s_rule,j_rule);
          }
          else if (action == 3) {
            Collect(e,a_00,contours,holes,XorS_Rule,XorJ_Rule);
          }
        }
        else if (action == 1) {
          if (bVar1 == 1) {
            *local_20 = a_00->next;
            a_00->next = (PLINE *)0x0;
LAB_080b6c97:
            PutContour(e,a_00,contours,holes,(PLINE *)0x0);
            goto LAB_080b6b71;
          }
        }
        else {
          if (action < 2) {
            if (action != 0) goto LAB_080b6bb2;
          }
          else if (action != 2) {
            if (action != 3) goto LAB_080b6bb2;
            if (bVar1 == 1) {
              *local_20 = a_00->next;
              a_00->next = (PLINE *)0x0;
              poly_InvContour(a_00);
              goto LAB_080b6c97;
            }
          }
          if (bVar1 == 2) goto LAB_080b6bf4;
        }
LAB_080b6bb2:
        local_20 = &a_00->next;
        a_00 = *local_20;
        if (a_00 == (PLINE *)0x0) break;
      } while( true );
    }
    local_24 = local_24->f;
    if (afst == local_24) {
      return;
    }
  } while( true );
LAB_080b6bf4:
  *local_20 = a_00->next;
  a_00->next = (PLINE *)0x0;
  PutContour(e,a_00,contours,holes,parent_00);
  goto LAB_080b6b71;
}



// WARNING: Unknown calling convention

int adjust_tree(rtree_t *tree,seg *s)

{
  VNODE *pVVar1;
  PLINE *pPVar2;
  VNODE *pVVar3;
  BoxType *pBVar4;
  int iVar5;
  
  pBVar4 = (BoxType *)malloc(0x18);
  if (pBVar4 != (BoxType *)0x0) {
    pVVar1 = s->v;
    pPVar2 = s->p;
    pBVar4[1].X1 = (LocationType)pVVar1;
    pBVar4[1].Y1 = (LocationType)pPVar2;
    pVVar3 = pVVar1->next;
    iVar5 = pVVar3->point[0];
    if (pVVar1->point[0] == iVar5 || pVVar1->point[0] < iVar5) {
      iVar5 = pVVar1->point[0];
    }
    pBVar4->X1 = iVar5;
    iVar5 = pVVar3->point[0];
    if (iVar5 <= pVVar1->point[0]) {
      iVar5 = pVVar1->point[0];
    }
    pBVar4->X2 = iVar5 + 1;
    iVar5 = pVVar3->point[1];
    if (pVVar1->point[1] == iVar5 || pVVar1->point[1] < iVar5) {
      iVar5 = pVVar1->point[1];
    }
    pBVar4->Y1 = iVar5;
    iVar5 = pVVar3->point[1];
    if (iVar5 <= pVVar1->point[1]) {
      iVar5 = pVVar1->point[1];
    }
    pBVar4->Y2 = iVar5 + 1;
    r_insert_entry(tree,pBVar4,1);
    pBVar4 = (BoxType *)malloc(0x18);
    if (pBVar4 != (BoxType *)0x0) {
      pVVar1 = s->v->next;
      pBVar4[1].Y1 = (LocationType)s->p;
      pBVar4[1].X1 = (LocationType)pVVar1;
      pVVar3 = pVVar1->next;
      iVar5 = pVVar3->point[0];
      if (pVVar1->point[0] == iVar5 || pVVar1->point[0] < iVar5) {
        iVar5 = pVVar1->point[0];
      }
      pBVar4->X1 = iVar5;
      iVar5 = pVVar3->point[0];
      if (iVar5 <= pVVar1->point[0]) {
        iVar5 = pVVar1->point[0];
      }
      pBVar4->X2 = iVar5 + 1;
      iVar5 = pVVar3->point[1];
      if (pVVar1->point[1] == iVar5 || pVVar1->point[1] < iVar5) {
        iVar5 = pVVar1->point[1];
      }
      pBVar4->Y1 = iVar5;
      iVar5 = pVVar3->point[1];
      if (iVar5 <= pVVar1->point[1]) {
        iVar5 = pVVar1->point[1];
      }
      pBVar4->Y2 = iVar5 + 1;
      r_insert_entry(tree,pBVar4,1);
      r_delete_entry(tree,&s->box);
      return 0;
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

int seg_in_seg(BoxType *b,void *cl)

{
  seg *s;
  PLINE *pPVar1;
  int *piVar2;
  uint uVar3;
  VNODE *node_b;
  VNODE *pVVar4;
  VNODE *pVVar5;
  int iVar6;
  int *piVar7;
  int iVar8;
  int res;
  VNODE *node_a;
  int local_44;
  Vector s2;
  Vector s1;
  uint local_20 [4];
  
  local_44 = vect_inters2((int *)b[1].X1 + 6,(int *)(*(int *)b[1].X1 + 0x18),
                          *(int **)((int)cl + 0x14) + 6,(int *)(**(int **)((int)cl + 0x14) + 0x18),
                          s1,s2);
  if (local_44 != 0) {
    if (*(int *)((int)cl + 0x154) != 0) {
                    // WARNING: Subroutine does not return
      __longjmp_chk(*(int *)((int)cl + 0x154),99);
    }
    iVar6 = *(int *)(*(int *)((int)cl + 0x18) + 0x14);
    *(byte *)(iVar6 + 0x44) = *(byte *)(iVar6 + 0x44) & 0xf8 | 3;
    *(byte *)(b[1].Y1 + 0x44) = *(byte *)(b[1].Y1 + 0x44) & 0xf8 | 3;
    do {
      piVar7 = s1;
      if (1 < local_44) {
        piVar7 = s2;
      }
      pVVar5 = (VNODE *)b[1].X1;
      local_20[0] = 0;
      pVVar4 = node_add(*(VNODE **)((int)cl + 0x14),piVar7,(int *)local_20);
      local_20[0] = local_20[0] << 1;
      pVVar5 = node_add(pVVar5,piVar7,(int *)local_20);
      uVar3 = local_20[0];
      if ((pVVar5 == (VNODE *)0x0) || (pVVar4 == (VNODE *)0x0)) {
        return 1;
      }
      pVVar5->cvc_next = (CVCList *)0xffffffff;
      pVVar5->cvc_prev = (CVCList *)0xffffffff;
      pVVar4->cvc_next = (CVCList *)0xffffffff;
      pVVar4->cvc_prev = (CVCList *)0xffffffff;
      if ((int)local_20[0] < 0) {
        return 1;
      }
      if ((local_20[0] & 2) != 0) {
        s = *(seg **)((int)cl + 0x18);
        piVar7 = s1;
        if (1 < local_44) {
          piVar7 = s2;
        }
        pPVar1 = s->p;
        iVar6 = *piVar7;
        iVar8 = pPVar1->xmin;
        if (iVar6 <= pPVar1->xmin) {
          iVar8 = iVar6;
        }
        pPVar1->xmin = iVar8;
        iVar8 = pPVar1->xmax;
        if (pPVar1->xmax <= iVar6 + 1) {
          iVar8 = iVar6 + 1;
        }
        pPVar1->xmax = iVar8;
        iVar6 = pPVar1->ymin;
        if (piVar7[1] == iVar6 || piVar7[1] < iVar6) {
          iVar6 = piVar7[1];
        }
        pPVar1->ymin = iVar6;
        iVar6 = pPVar1->ymax;
        if (pPVar1->ymax <= piVar7[1] + 1) {
          iVar6 = piVar7[1] + 1;
        }
        pPVar1->ymax = iVar6;
        iVar6 = adjust_tree(pPVar1->tree,s);
        if (iVar6 != 0) {
          return 1;
        }
      }
      if ((uVar3 & 1) != 0) {
        piVar7 = s1;
        if (1 < local_44) {
          piVar7 = s2;
        }
        piVar2 = (int *)b[1].Y1;
        iVar6 = *piVar7;
        iVar8 = *piVar2;
        if (iVar6 <= *piVar2) {
          iVar8 = iVar6;
        }
        *piVar2 = iVar8;
        iVar8 = iVar6 + 1;
        if (iVar6 + 1 < piVar2[2]) {
          iVar8 = piVar2[2];
        }
        piVar2[2] = iVar8;
        iVar6 = piVar2[1];
        if (piVar7[1] == iVar6 || piVar7[1] < iVar6) {
          iVar6 = piVar7[1];
        }
        piVar2[1] = iVar6;
        iVar6 = piVar2[3];
        if (piVar2[3] <= piVar7[1] + 1) {
          iVar6 = piVar7[1] + 1;
        }
        piVar2[3] = iVar6;
        iVar6 = adjust_tree(*(rtree_t **)((int)cl + 0x10),(seg *)b);
        if (iVar6 != 0) {
          return 1;
        }
      }
      if ((uVar3 & 3) != 0) {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1c,1);
      }
      local_44 = local_44 + -1;
    } while (local_44 != 0);
  }
  return 0;
}



// WARNING: Unknown calling convention

int heap_it(BoxType *b,void *cl)

{
  if (b[3].Y1 == 0) {
    return 0;
  }
  heap_insert((heap_t *)cl,*(cost_t *)&b[3].X2,b);
  return 1;
}



// WARNING: Unknown calling convention

BOOLp M_POLYAREA_label(POLYAREA *afst,POLYAREA *b,BOOLp touch)

{
  CVCList **ppCVar1;
  char cVar2;
  PLINE *inner;
  CVCList *pCVar3;
  VNODE *pVVar4;
  PLINE *pPVar5;
  bool bVar6;
  uint uVar7;
  CVCList *l;
  CVCList *pCVar8;
  int iVar9;
  void *pvVar10;
  VNODE *cur;
  char this_poly;
  VNODE *pVVar11;
  VNODE *pVVar12;
  uint uVar13;
  int label;
  POLYAREA *data;
  PLINE *curc_1;
  byte bVar14;
  PLINE *curc;
  int region;
  VNODE *v;
  CVCList *pCVar15;
  VNODE *pVVar16;
  POLYAREA *local_48;
  heap_t *local_20 [4];
  
  local_48 = afst;
  do {
    inner = local_48->contours;
joined_r0x080b7100:
    if (inner != (PLINE *)0x0) {
      if ((*(byte *)&inner->Flags & 7) == 3) {
        pVVar11 = &inner->head;
        uVar13 = 0;
        bVar6 = false;
        pVVar12 = pVVar11;
LAB_080b7136:
        do {
          bVar14 = *(byte *)&pVVar12->Flags;
          uVar7 = bVar14 & 7;
          if ((bVar14 & 7) != 0) goto LAB_080b712b;
          if (pVVar12->cvc_next == (CVCList *)0x0) {
            uVar7 = uVar13;
            if (1 < uVar13 - 1) goto LAB_080b712b;
            *(byte *)&pVVar12->Flags = bVar14 & 0xf8 | (byte)uVar13;
          }
          else {
            pCVar3 = pVVar12->cvc_prev;
            bVar14 = 0;
            pCVar15 = pCVar3->prev;
            cVar2 = pCVar3->poly;
            pCVar8 = pCVar3;
            if (pCVar3 != pCVar15) {
              bVar14 = 0;
              do {
                if (cVar2 != pCVar15->poly) {
                  bVar14 = (pCVar15->side != 'P') + 1;
                }
                pCVar15 = pCVar15->prev;
              } while (pCVar3 != pCVar15);
            }
LAB_080b71c9:
            do {
              if (cVar2 == pCVar8->poly) {
                if (pCVar8->side == 'P') {
                  pVVar16 = pCVar8->parent->prev;
                }
                else {
                  pVVar16 = pCVar8->parent;
                }
                if (1 < (byte)((*(byte *)&pVVar16->Flags & 7) - 3)) {
                  *(byte *)&pVVar16->Flags = *(byte *)&pVVar16->Flags & 0xf8 | bVar14;
                  ppCVar1 = &pCVar8->prev;
                  pCVar8 = *ppCVar1;
                  if (pCVar3 == *ppCVar1) break;
                  goto LAB_080b71c9;
                }
              }
              else if (pCVar8->side == 'P') {
                pVVar16 = pVVar12->prev;
                pVVar4 = pCVar8->parent->prev;
                if ((pVVar4->point[0] == pVVar16->point[0]) &&
                   (pVVar4->point[1] == pVVar16->point[1])) {
                  *(byte *)&pVVar16->Flags = *(byte *)&pVVar16->Flags & 0xf8 | 3;
                  pVVar12->prev->shared = pCVar8->parent->prev;
                  bVar14 = 1;
                }
                else if ((pVVar4->point[0] == pVVar12->next->point[0]) &&
                        (pVVar4->point[1] == pVVar12->next->point[1])) {
                  bVar14 = 1;
                  *(byte *)&pVVar12->Flags = *(byte *)&pVVar12->Flags & 0xf8 | 4;
                  pVVar12->shared = pCVar8->parent->prev;
                }
                else {
                  bVar14 = 1;
                }
              }
              else {
                pVVar16 = pCVar8->parent->next;
                if ((pVVar16->point[0] == pVVar12->next->point[0]) &&
                   (pVVar16->point[1] == pVVar12->next->point[1])) {
                  bVar14 = 2;
                  *(byte *)&pVVar12->Flags = *(byte *)&pVVar12->Flags & 0xf8 | 3;
                  pVVar12->shared = pCVar8->parent;
                }
                else {
                  pVVar4 = pVVar12->prev;
                  if ((pVVar16->point[0] == pVVar4->point[0]) &&
                     (pVVar16->point[1] == pVVar4->point[1])) {
                    *(byte *)&pVVar4->Flags = *(byte *)&pVVar4->Flags & 0xf8 | 4;
                    pVVar12->prev->shared = pCVar8->parent;
                    bVar14 = 2;
                  }
                  else {
                    bVar14 = 2;
                  }
                }
              }
              ppCVar1 = &pCVar8->prev;
              pCVar8 = *ppCVar1;
            } while (pCVar3 != *ppCVar1);
            uVar13 = *(byte *)&pVVar12->Flags & 7;
            if ((((*(byte *)&pVVar12->Flags & 7) == 0) ||
                ((*(byte *)&pVVar12->prev->Flags & 7) == 0)) || (1 < (byte)((char)uVar13 - 1U))) {
              uVar13 = 0;
            }
          }
          pVVar12 = pVVar12->next;
          bVar6 = true;
        } while (pVVar11 != pVVar12);
        goto LAB_080b7232;
      }
      local_20[0] = heap_create();
      data = b;
      do {
        pPVar5 = data->contours;
        if (((pPVar5->xmin <= inner->xmin) && (pPVar5->ymin <= inner->ymin)) &&
           ((inner->xmax <= pPVar5->xmax && (inner->ymax <= pPVar5->ymax)))) {
          heap_insert(local_20[0],pPVar5->area,data);
        }
        if (touch != 0) goto LAB_080b73eb;
        data = data->f;
      } while (b != data);
      iVar9 = heap_is_empty(local_20[0]);
      while (iVar9 == 0) {
        pvVar10 = heap_remove_smallest(local_20[0]);
        iVar9 = poly_ContourInContour(*(PLINE **)((int)pvVar10 + 8),inner);
        if (iVar9 != 0) {
          pPVar5 = *(PLINE **)(*(int *)((int)pvVar10 + 8) + 0x10);
          goto joined_r0x080b7422;
        }
LAB_080b73eb:
        iVar9 = heap_is_empty(local_20[0]);
      }
      heap_destroy(local_20);
LAB_080b744a:
      if (touch == 0) {
        *(byte *)&inner->Flags = *(byte *)&inner->Flags & 0xf8 | 2;
      }
      goto LAB_080b7461;
    }
    if ((touch != 0) || (local_48 = local_48->f, local_48 == afst)) {
      return 0;
    }
  } while( true );
LAB_080b712b:
  uVar13 = uVar7;
  pVVar12 = pVVar12->next;
  if (pVVar11 == pVVar12) {
LAB_080b7232:
    if (bVar6) {
      bVar6 = false;
      goto LAB_080b7136;
    }
    goto LAB_080b7461;
  }
  goto LAB_080b7136;
joined_r0x080b7422:
  if (pPVar5 == (PLINE *)0x0) goto LAB_080b7490;
  iVar9 = poly_ContourInContour(pPVar5,inner);
  if (iVar9 != 0) {
    heap_destroy(local_20);
    goto LAB_080b744a;
  }
  pPVar5 = pPVar5->next;
  goto joined_r0x080b7422;
LAB_080b7490:
  heap_destroy(local_20);
  if (touch != 0) {
    return 1;
  }
  *(byte *)&inner->Flags = *(byte *)&inner->Flags & 0xf8 | 1;
LAB_080b7461:
  inner = inner->next;
  goto joined_r0x080b7100;
}



// WARNING: Unknown calling convention

BOOLp Touching(POLYAREA *a,POLYAREA *b)

{
  int iVar1;
  int code;
  uint uVar2;
  BOOLp BVar3;
  jmp_buf e;
  
  iVar1 = _setjmp((__jmp_buf_tag *)e);
  if (iVar1 == 0) {
    M_POLYAREA_intersect((jmp_buf *)e,a,b,0);
    BVar3 = M_POLYAREA_label(a,b,1);
    uVar2 = 1;
    if (BVar3 == 0) {
      BVar3 = M_POLYAREA_label(b,a,1);
      return (uint)(BVar3 != 0);
    }
  }
  else {
    uVar2 = (uint)(iVar1 == 99);
  }
  return uVar2;
}



// WARNING: Unknown calling convention

void InsertHoles(jmp_buf *e,POLYAREA *dest,PLINE **src)

{
  PLINE *pPVar1;
  PLINE *curh;
  int iVar2;
  PLINE *poly;
  POLYAREA *curc;
  POLYAREA *pPVar3;
  PLINE *tmp;
  rtree_t *local_28;
  heap_t *local_24;
  PLINE *local_20 [4];
  
  if (*src != (PLINE *)0x0) {
    if (dest == (POLYAREA *)0x0) {
LAB_080b76db:
                    // WARNING: Subroutine does not return
      __longjmp_chk(e,3);
    }
    local_28 = r_create_tree((BoxType **)0x0,0,0);
    pPVar3 = dest;
    do {
      r_insert_entry(local_28,(BoxType *)pPVar3->contours,0);
      pPVar3 = pPVar3->f;
    } while (pPVar3 != dest);
    local_20[0] = *src;
    while (local_20[0] != (PLINE *)0x0) {
      *src = local_20[0]->next;
      local_24 = heap_create();
      r_search(local_28,(BoxType *)local_20[0],(_func_int_BoxType_ptr_void_ptr *)0x0,heap_it,
               local_24);
      iVar2 = heap_is_empty(local_24);
      if (iVar2 != 0) {
        poly_DelContour(local_20);
        goto LAB_080b76db;
      }
      poly = (PLINE *)heap_remove_smallest(local_24);
      iVar2 = heap_is_empty(local_24);
      if (iVar2 == 0) {
        while (iVar2 = poly_ContourInContour(poly,local_20[0]), iVar2 == 0) {
          iVar2 = heap_is_empty(local_24);
          if (iVar2 != 0) {
            heap_destroy(&local_24);
            goto LAB_080b76ab;
          }
          poly = (PLINE *)heap_remove_smallest(local_24);
        }
      }
      heap_destroy(&local_24);
      if (poly == (PLINE *)0x0) {
LAB_080b76ab:
        local_20[0]->next = (PLINE *)0x0;
        poly_DelContour(local_20);
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,3);
      }
      pPVar1 = poly->next;
      poly->next = local_20[0];
      local_20[0]->next = pPVar1;
      local_20[0] = *src;
    }
    r_destroy_tree(&local_28);
  }
  return;
}



// WARNING: Unknown calling convention

int poly_AndSubtract_free(POLYAREA *ai,POLYAREA *bi,POLYAREA **aandb,POLYAREA **aminusb)

{
  PLINE *pPVar1;
  POLYAREA **ppPVar2;
  int iVar3;
  int code;
  VNODE *v;
  VNODE *v_1;
  VNODE *pVVar4;
  PLINE *c_1;
  POLYAREA *n;
  PLINE *c;
  POLYAREA *n_1;
  POLYAREA *pPVar5;
  POLYAREA *pPVar6;
  jmp_buf e;
  PLINE *local_2c;
  PLINE *local_28;
  POLYAREA *local_24;
  POLYAREA *local_20 [4];
  
  local_2c = (PLINE *)0x0;
  local_20[0] = ai;
  local_24 = bi;
  *aandb = (POLYAREA *)0x0;
  *aminusb = (POLYAREA *)0x0;
  iVar3 = _setjmp((__jmp_buf_tag *)e);
  if (iVar3 == 0) {
    M_POLYAREA_intersect((jmp_buf *)e,local_20[0],local_24,1);
    M_POLYAREA_label(local_20[0],local_24,0);
    M_POLYAREA_label(local_24,local_20[0],0);
    M_POLYAREA_Collect((jmp_buf *)e,local_20[0],aandb,&local_2c,1,0);
    InsertHoles((jmp_buf *)e,*aandb,&local_2c);
    local_28 = local_2c;
    pPVar5 = local_20[0];
    if (local_2c != (PLINE *)0x0) {
      do {
        local_28 = local_2c;
        local_2c = local_2c->next;
        poly_DelContour(&local_28);
        local_28 = local_2c;
        pPVar5 = local_20[0];
      } while (local_2c != (PLINE *)0x0);
    }
    do {
      for (pPVar1 = pPVar5->contours; pPVar1 != (PLINE *)0x0; pPVar1 = pPVar1->next) {
        pVVar4 = &pPVar1->head;
        do {
          *(byte *)&pVVar4->Flags = *(byte *)&pVVar4->Flags & 0xf7;
          pVVar4 = pVVar4->next;
        } while (&pPVar1->head != pVVar4);
      }
      ppPVar2 = &pPVar5->f;
      pPVar6 = local_24;
      pPVar5 = *ppPVar2;
    } while (local_20[0] != *ppPVar2);
    do {
      for (pPVar1 = pPVar6->contours; pPVar1 != (PLINE *)0x0; pPVar1 = pPVar1->next) {
        pVVar4 = &pPVar1->head;
        do {
          *(byte *)&pVVar4->Flags = *(byte *)&pVVar4->Flags & 0xf7;
          pVVar4 = pVVar4->next;
        } while (&pPVar1->head != pVVar4);
      }
      ppPVar2 = &pPVar6->f;
      pPVar6 = *ppPVar2;
    } while (local_24 != *ppPVar2);
    local_2c = (PLINE *)0x0;
    M_POLYAREA_Collect((jmp_buf *)e,local_20[0],aminusb,&local_2c,2,0);
    InsertHoles((jmp_buf *)e,*aminusb,&local_2c);
    poly_Free(local_20);
    poly_Free(&local_24);
  }
  if (local_2c != (PLINE *)0x0) {
    do {
      local_28 = local_2c;
      local_2c = local_2c->next;
      poly_DelContour(&local_28);
    } while (local_2c != (PLINE *)0x0);
  }
  if (iVar3 != 0) {
    local_28 = local_2c;
    poly_Free(aandb);
    poly_Free(aminusb);
  }
  return iVar3;
}



// WARNING: Unknown calling convention

int poly_Boolean_free(POLYAREA *ai,POLYAREA *bi,POLYAREA **res,int action)

{
  PLINE **ppPVar1;
  POLYAREA *pPVar2;
  byte bVar3;
  int iVar4;
  int code;
  PLINE *p;
  uint maybe;
  PLINE *c;
  PLINE **next;
  PLINE **ppPVar5;
  POLYAREA *b;
  jmp_buf e;
  PLINE *local_2c;
  PLINE *local_28;
  POLYAREA *local_24;
  POLYAREA *local_20 [4];
  
  local_2c = (PLINE *)0x0;
  local_20[0] = ai;
  local_24 = bi;
  *res = (POLYAREA *)0x0;
  if (ai == (POLYAREA *)0x0) {
    if (action < 3) {
      if (0 < action) {
        if (bi == (POLYAREA *)0x0) {
          return 0;
        }
        poly_Free(&local_24);
        return 0;
      }
      if (action == 0) {
LAB_080b7b85:
        *res = bi;
        return 0;
      }
    }
    else if (action == 3) goto LAB_080b7b85;
  }
  if (bi == (POLYAREA *)0x0) {
    if (action == 1) {
      if (ai == (POLYAREA *)0x0) {
        return 0;
      }
      poly_Free(local_20);
      return 0;
    }
    if (action < 2) {
      if (action == 0) goto LAB_080b799e;
    }
    else if (action < 4) {
LAB_080b799e:
      *res = ai;
      return 0;
    }
  }
  iVar4 = _setjmp((__jmp_buf_tag *)e);
  if (iVar4 != 0) {
LAB_080b792b:
    if (local_2c != (PLINE *)0x0) {
      do {
        local_28 = local_2c;
        local_2c = local_2c->next;
        poly_DelContour(&local_28);
      } while (local_2c != (PLINE *)0x0);
    }
    if (iVar4 != 0) {
      local_28 = local_2c;
      poly_Free(res);
      return iVar4;
    }
    return 0;
  }
  M_POLYAREA_intersect((jmp_buf *)e,local_20[0],local_24,1);
  M_POLYAREA_label(local_20[0],local_24,0);
  M_POLYAREA_label(local_24,local_20[0],0);
  if ((local_24 == local_24->f) && (local_24->contours->next == (PLINE *)0x0)) {
    maybe = (uint)((*(byte *)&local_24->contours->Flags & 7) != 3);
  }
  else {
    maybe = 0;
  }
  M_POLYAREA_Collect((jmp_buf *)e,local_20[0],res,&local_2c,action,maybe);
  poly_Free(local_20);
  pPVar2 = local_24;
  b = local_24;
LAB_080b7a28:
  ppPVar5 = &b->contours;
LAB_080b7a2b:
  c = *ppPVar5;
  do {
    if (c == (PLINE *)0x0) {
      b = b->f;
      if (pPVar2 != b) goto LAB_080b7a28;
      poly_Free(&local_24);
      InsertHoles((jmp_buf *)e,*res,&local_2c);
      goto LAB_080b792b;
    }
    ppPVar1 = &c->next;
    bVar3 = *(byte *)&c->Flags & 7;
    if (bVar3 != 3) {
      if (bVar3 == 1) {
        if (action != 1) {
          if ((action < 1) || (3 < action)) goto LAB_080b7a4d;
          poly_InvContour(c);
          c = *ppPVar5;
        }
        *ppPVar5 = c->next;
        *(byte *)&c->Flags = *(byte *)&c->Flags & 0xf8;
        c->next = (PLINE *)0x0;
        PutContour((jmp_buf *)e,c,res,&local_2c,(PLINE *)0x0);
        goto LAB_080b7a2b;
      }
      if ((bVar3 == 2) && ((action == 0 || (action == 3)))) break;
    }
LAB_080b7a4d:
    c = *ppPVar1;
    ppPVar5 = ppPVar1;
  } while( true );
  *ppPVar5 = c->next;
  *(byte *)&c->Flags = *(byte *)&c->Flags & 0xf8;
  c->next = (PLINE *)0x0;
  PutContour((jmp_buf *)e,c,res,&local_2c,(PLINE *)0x0);
  goto LAB_080b7a2b;
}



// WARNING: Unknown calling convention

int poly_Boolean(POLYAREA *a_org,POLYAREA *b_org,POLYAREA **res,int action)

{
  BOOLp BVar1;
  int iVar2;
  POLYAREA *local_14;
  POLYAREA *local_10 [3];
  
  local_10[0] = (POLYAREA *)0x0;
  local_14 = (POLYAREA *)0x0;
  BVar1 = poly_M_Copy0(local_10,a_org);
  if (BVar1 != 0) {
    BVar1 = poly_M_Copy0(&local_14,b_org);
    if (BVar1 != 0) {
      iVar2 = poly_Boolean_free(local_10[0],local_14,res,action);
      return iVar2;
    }
  }
  return 2;
}



// WARNING: Unknown calling convention

int find_pair_line_callback(BoxType *b,void *cl)

{
  int iVar1;
  Extra **ppEVar2;
  LayerType *pLVar3;
  
                    // WARNING: Load size is inaccurate
  if (*cl == b) {
    return 0;
  }
  iVar1 = *(int *)((int)cl + 4);
  if ((b[2].Y2 <= iVar1 + 2) && (iVar1 + -2 <= b[2].Y2)) {
    if ((b[3].X1 <= *(int *)((int)cl + 8) + 2) && (*(int *)((int)cl + 8) + -2 <= b[3].X1))
    goto LAB_080b7cb2;
  }
  if (iVar1 + 2 < b[4].X1) {
    return 0;
  }
  if (b[4].X1 < iVar1 + -2) {
    return 0;
  }
  if (*(int *)((int)cl + 8) + 2 < b[4].Y1) {
    return 0;
  }
  if (b[4].Y1 < *(int *)((int)cl + 8) + -2) {
    return 0;
  }
LAB_080b7cb2:
  ppEVar2 = *(Extra ***)((int)cl + 0x10);
  if (*ppEVar2 == (Extra *)0x0) {
    if (PCB->SilkActive == '\0') {
      pLVar3 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar3 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    *ppEVar2 = (Extra *)((int)lines + ((int)b - (int)pLVar3->Line >> 3) * -0x2e8ba2e4);
  }
  else {
    *ppEVar2 = &multi_next;
  }
  return 0;
}



// WARNING: Unknown calling convention

int find_pair_arc_callback(BoxType *b,void *cl)

{
  Extra *pEVar1;
  int iVar2;
  int iVar3;
  Extra *pEVar4;
  Extra *e;
  LayerType *pLVar5;
  
  if (PCB->SilkActive == '\0') {
    pLVar5 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
                    // WARNING: Load size is inaccurate
  if (*cl == b) {
    return 0;
  }
  iVar2 = *(int *)((int)cl + 4);
  pEVar1 = (Extra *)((int)arcs + ((int)b - (int)pLVar5->Arc >> 2) * -0xf0f0f0c);
  iVar3 = (pEVar1->start).x;
  if ((iVar3 <= iVar2 + 2) && (iVar2 + -2 <= iVar3)) {
    iVar3 = (pEVar1->start).y;
    if ((iVar3 <= *(int *)((int)cl + 8) + 2) && (*(int *)((int)cl + 8) + -2 <= iVar3))
    goto LAB_080b7dfa;
  }
  iVar3 = (pEVar1->end).x;
  if (iVar2 + 2 < iVar3) {
    return 0;
  }
  if (iVar3 < iVar2 + -2) {
    return 0;
  }
  iVar2 = (pEVar1->end).y;
  if (*(int *)((int)cl + 8) + 2 < iVar2) {
    return 0;
  }
  if (iVar2 < *(int *)((int)cl + 8) + -2) {
    return 0;
  }
LAB_080b7dfa:
  pEVar4 = &multi_next;
  if (**(Extra ***)((int)cl + 0x10) == (Extra *)0x0) {
    pEVar4 = pEVar1;
  }
  **(Extra ***)((int)cl + 0x10) = pEVar4;
  return 0;
}



// WARNING: Unknown calling convention

void adjust_pointers_1(Extra *old,Extra *new,int num,Extra *l,int n)

{
  Extra *pEVar1;
  int iVar2;
  Extra *pEVar3;
  int iVar4;
  int i;
  Extra *last;
  
  iVar2 = (int)new - (int)old;
  pEVar1 = old + num;
  if (0 < n) {
    iVar4 = 0;
    do {
      pEVar3 = (Extra *)(l->start).waiting_for;
      if (((pEVar3 != (Extra *)0x0) && (old < pEVar3)) && (pEVar3 < pEVar1 + 1)) {
        (l->start).waiting_for = (End *)((int)pEVar3 + iVar2);
      }
      pEVar3 = (Extra *)(l->end).waiting_for;
      if (((pEVar3 != (Extra *)0x0) && (old < pEVar3)) && (pEVar3 < pEVar1 + 1)) {
        (l->end).waiting_for = (End *)((int)pEVar3 + iVar2);
      }
      pEVar3 = (l->start).next;
      if ((old <= pEVar3) && (pEVar3 < pEVar1)) {
        (l->start).next = (Extra *)(&(pEVar3->start).next + (iVar2 >> 2));
      }
      pEVar3 = (l->end).next;
      if ((old <= pEVar3) && (pEVar3 < pEVar1)) {
        (l->end).next = (Extra *)(&(pEVar3->start).next + (iVar2 >> 2));
      }
      iVar4 = iVar4 + 1;
      l = l + 1;
    } while (iVar4 != n);
  }
  return;
}



// WARNING: Unknown calling convention

void adjust_pointers(Extra *old,Extra *new,int num)

{
  adjust_pointers_1(old,new,num,lines,nlines);
  adjust_pointers_1(old,new,num,arcs,narcs);
  return;
}



// WARNING: Unknown calling convention

void find_pairs_1(void *me,Extra **e,int x,int y)

{
  LayerType *pLVar1;
  FindPairCallbackStruct fpcs;
  BoxType b;
  
  if (*e == (Extra *)0x0) {
    if (PCB->SilkActive == '\0') {
      pLVar1 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    b.X1 = x + -10;
    b.X2 = x + 10;
    b.Y1 = y + -10;
    fpcs.y = y;
    b.Y2 = y + 10;
    fpcs.me = me;
    fpcs.x = x;
    fpcs.extra_ptr = e;
    r_search(pLVar1->line_tree,&b,(_func_int_BoxType_ptr_void_ptr *)0x0,find_pair_line_callback,
             &fpcs);
    if (PCB->SilkActive == '\0') {
      pLVar1 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    r_search(pLVar1->arc_tree,&b,(_func_int_BoxType_ptr_void_ptr *)0x0,find_pair_arc_callback,&fpcs)
    ;
  }
  return;
}



// WARNING: Unknown calling convention

int find_pair(int Px,int Py)

{
  int iVar1;
  LayerType *pLVar2;
  BoxType spot;
  
  multi = 0;
  arc_exact = 0;
  line_exact = 0;
  the_line = (LineTypePtr)0x0;
  the_arc = (ArcTypePtr)0x0;
  if (PCB->SilkActive == '\0') {
    pLVar2 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  spot.X1 = Px + -1;
  spot.Y1 = Py + -1;
  spot.X2 = Px + 1;
  spot.Y2 = Py + 1;
  x = Px;
  y = Py;
  r_search(pLVar2->line_tree,&spot,(_func_int_BoxType_ptr_void_ptr *)0x0,line_callback,pLVar2);
  if (PCB->SilkActive == '\0') {
    pLVar2 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  r_search(pLVar2->arc_tree,&spot,(_func_int_BoxType_ptr_void_ptr *)0x0,arc_callback,pLVar2);
  if (((the_line == (LineTypePtr)0x0) || (the_arc == (ArcTypePtr)0x0)) || (iVar1 = 1, multi != 0)) {
    iVar1 = 0;
    x = Px;
    y = Py;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void fix_arc_extra(ArcTypePtr a,Extra *e)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  double local_2c;
  double local_24 [2];
  
  iVar5 = a->StartAngle;
  iVar1 = a->X;
  iVar2 = a->Width;
  sincos(((double)iVar5 * 3.141592653589793) / 180.0,local_24,&local_2c);
  iVar6 = a->Delta;
  (e->start).x = (int)ROUND((double)iVar1 - ((double)iVar2 * local_2c + 0.5));
  iVar3 = a->Y;
  iVar4 = a->Height;
  (e->start).y = (int)ROUND(local_24[0] * (double)iVar4 + 0.5 + (double)iVar3);
  sincos(((double)(iVar5 + iVar6) * 3.141592653589793) / 180.0,local_24,&local_2c);
  (e->end).x = (int)ROUND((double)iVar1 - ((double)iVar2 * local_2c + 0.5));
  (e->end).y = (int)ROUND((double)iVar3 + (double)iVar4 * local_24[0] + 0.5);
  return;
}



// WARNING: Unknown calling convention

double dist(int x1,int y1,int x2,int y2)

{
  return SQRT((double)(y1 - y2) * (double)(y1 - y2) + (double)(x1 - x2) * (double)(x1 - x2));
}



// WARNING: Unknown calling convention

double dist_lsp(int x1,int y1,int x2,int y2,int px,int py)

{
  double d;
  double dVar1;
  
  if ((longdouble)(py - y1) * (longdouble)(y2 - y1) + (longdouble)(px - x1) * (longdouble)(x2 - x1)
      < (longdouble)0) {
    dVar1 = dist(x1,y1,px,py);
    return dVar1;
  }
  if ((longdouble)0 <=
      (longdouble)(py - y2) * (longdouble)(y1 - y2) + (longdouble)(px - x2) * (longdouble)(x1 - x2))
  {
    dVar1 = dist(x1,y1,x2,y2);
    return ABS(((double)x2 - (double)x1) * ((double)y1 - (double)py) -
               ((double)x1 - (double)px) * ((double)y2 - (double)y1)) / dVar1;
  }
  dVar1 = dist(x2,y2,px,py);
  return dVar1;
}



// WARNING: Unknown calling convention

int check_point_in_pin(PinTypePtr pin,int x,int y,End *e)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  
  iVar3 = (pin->Thickness + 1) / 2;
  if ((*(byte *)((int)&(pin->Flags).f + 1) & 1) == 0) {
    dVar4 = dist(pin->X,pin->Y,x,y);
    if (dVar4 <= (double)iVar3) {
      iVar2 = pin->X;
      goto LAB_080b84da;
    }
  }
  else {
    iVar2 = pin->X;
    if ((((iVar2 - iVar3 <= x) && (x <= iVar3 + iVar2)) && (pin->Y - iVar3 <= y)) &&
       (y <= iVar3 + pin->Y)) {
LAB_080b84da:
      bVar1 = e->field_0x8;
      e->field_0x8 = bVar1 | 1;
      if ((x == iVar2) && (pin->Y == y)) {
        e->field_0x8 = bVar1 | 3;
      }
      e->pin = pin;
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int find_pair_pinarc_callback(BoxType *b,void *cl)

{
  LayerType *pLVar1;
  End *e_00;
  Extra *e;
  
  if (PCB->SilkActive == '\0') {
    pLVar1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  e_00 = (End *)((int)arcs + ((int)b - (int)pLVar1->Arc >> 2) * -0xf0f0f0c);
  check_point_in_pin((PinTypePtr)cl,e_00->x,e_00->y,e_00);
  check_point_in_pin((PinTypePtr)cl,e_00[1].x,e_00[1].y,e_00 + 1);
  return 0;
}



// WARNING: Unknown calling convention

int find_pair_pinline_callback(BoxType *b,void *cl)

{
  LayerType *pLVar1;
  int iVar2;
  int iVar3;
  Extra *pEVar4;
  Extra *e_00;
  Extra *e;
  double dVar5;
  
  if (PCB->SilkActive == '\0') {
    pLVar1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  e_00 = (Extra *)((int)lines + ((int)b - (int)pLVar1->Line >> 3) * -0x2e8ba2e4);
  iVar2 = check_point_in_pin((PinTypePtr)cl,b[2].Y2,b[3].X1,(End *)e_00);
  iVar3 = check_point_in_pin((PinTypePtr)cl,b[4].X1,b[4].Y1,&e_00->end);
  if (iVar3 + iVar2 == 0) {
    dVar5 = dist_lsp(b[2].Y2,b[3].X1,b[4].X1,b[4].Y1,*(int *)((int)cl + 0x34),
                     *(int *)((int)cl + 0x38));
    if (dVar5 <= (double)(*(int *)((int)cl + 0x24) / 2)) {
      pEVar4 = (e_00->start).next;
      if (pEVar4 != (Extra *)0x0) {
        if (e_00 == (pEVar4->start).next) {
          (pEVar4->start).next = &multi_next;
          pEVar4 = (e_00->start).next;
        }
        if (e_00 == (pEVar4->end).next) {
          (pEVar4->end).next = &multi_next;
        }
      }
      pEVar4 = (e_00->end).next;
      (e_00->start).next = &multi_next;
      if (pEVar4 != (Extra *)0x0) {
        if (e_00 == (pEVar4->start).next) {
          (pEVar4->start).next = &multi_next;
        }
        if (e_00 == (pEVar4->end).next) {
          (pEVar4->end).next = &multi_next;
        }
      }
      (e_00->end).next = &multi_next;
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

double dist_lp(int x1,int y1,int x2,int y2,int px,int py)

{
  double den;
  double dVar1;
  
  dVar1 = dist(x1,y1,x2,y2);
  return ABS(((double)y1 - (double)py) * ((double)x2 - (double)x1) -
             ((double)x1 - (double)px) * ((double)y2 - (double)y1)) / dVar1;
}



// WARNING: Unknown calling convention

int line_callback(BoxType *b,void *cl)

{
  double dVar1;
  double d2;
  double d1;
  double t;
  double dVar2;
  double dVar3;
  
  dVar2 = dist(b[2].Y2,b[3].X1,x,y);
  dVar3 = dist(b[4].X1,b[4].Y1,x,y);
  if ((dVar2 < 2.0) || (dVar3 < 2.0)) {
    if (line_exact == 0) {
      line_exact = 1;
      the_line = (LineTypePtr)0x0;
    }
LAB_080b881c:
    dVar1 = 2.0;
    if (dVar2 < 2.0) goto LAB_080b87e4;
  }
  else {
    if (line_exact != 0) goto LAB_080b881c;
    dVar1 = (double)(b[2].Y1 / 2);
    if (dVar2 < dVar1) goto LAB_080b87e4;
  }
  if (dVar1 <= dVar3) {
    return 1;
  }
LAB_080b87e4:
  if (the_line != (LineTypePtr)0x0) {
    multi = 1;
  }
  the_line = (LineTypePtr)b;
  return 1;
}



// WARNING: Unknown calling convention

int arc_endpoint_is(ArcTypePtr a,int angle,int x,int y)

{
  uint uVar1;
  int ay;
  int y1;
  int local_38;
  double local_2c;
  double local_24 [2];
  
  local_38 = a->X;
  y1 = a->Y;
  if (angle == (angle / 0x5a) * 0x5a) {
    uVar1 = angle / 0x5a & 3;
    if (uVar1 == 2) {
      local_38 = local_38 + a->Width;
    }
    else if (uVar1 == 3) {
      y1 = y1 - a->Height;
    }
    else if (uVar1 == 1) {
      y1 = y1 + a->Height;
    }
    else {
      local_38 = local_38 - a->Width;
    }
  }
  else {
    sincos(((double)angle * 3.141592653589793) / 180.0,local_24,&local_2c);
    local_38 = (int)ROUND((double)local_38 - local_2c * (double)a->Width);
    y1 = (int)ROUND((double)a->Width * local_24[0] + (double)y1);
  }
  arc_dist = dist(local_38,y1,x,y);
  if (arc_exact == 0) {
    return (uint)(arc_dist < (double)(a->Thickness / 2));
  }
  return (uint)(arc_dist < 2.0);
}



// WARNING: Unknown calling convention

int arc_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  iVar1 = arc_endpoint_is((ArcTypePtr)b,b[3].Y2,x,y);
  if ((iVar1 == 0) && (iVar1 = arc_endpoint_is((ArcTypePtr)b,b[4].X1 + b[3].Y2,x,y), iVar1 == 0)) {
    return 1;
  }
  if (arc_dist < 2.0) {
    if (arc_exact == 0) {
      arc_exact = 1;
      the_arc = (ArcTypePtr)b;
      return 1;
    }
  }
  else if (arc_exact != 0) {
    return 1;
  }
  if (the_arc != (ArcTypePtr)0x0) {
    multi = 1;
  }
  the_arc = (ArcTypePtr)b;
  return 1;
}



// WARNING: Unknown calling convention

int within(int x1,int y1,int x2,int y2,int r)

{
  double dVar1;
  
  dVar1 = dist(x1,y1,x2,y2);
  return (uint)(dVar1 <= (double)(r / 2));
}



// WARNING: Unknown calling convention

void unlink_extras(Extra *e)

{
  Extra *pEVar1;
  Extra *pEVar2;
  
  pEVar1 = (e->start).next;
  if (pEVar1 == (Extra *)0x0) {
LAB_080b8aab:
    pEVar2 = (e->end).next;
  }
  else {
    if ((pEVar1->start).next != e) {
      pEVar2 = pEVar1;
      if ((pEVar1->end).next != e) goto LAB_080b8ae2;
      (pEVar1->end).next = (e->end).next;
      goto LAB_080b8aab;
    }
    pEVar2 = (e->end).next;
    (pEVar1->start).next = pEVar2;
  }
  if (pEVar2 != (Extra *)0x0) {
    if ((pEVar2->start).next == e) {
      (pEVar2->start).next = (e->start).next;
    }
    else {
      if ((pEVar2->end).next != e) {
LAB_080b8ae2:
        __fprintf_chk(stderr,1," - %p doesn\'t point to me!\n",pEVar2);
                    // WARNING: Subroutine does not return
        abort();
      }
      (pEVar2->end).next = (e->start).next;
    }
  }
  (e->end).next = (Extra *)0x0;
  (e->start).next = (Extra *)0x0;
  return;
}



// WARNING: Unknown calling convention

void mark_arc_for_deletion(ArcTypePtr a)

{
  undefined *puVar1;
  Extra *e_00;
  Extra *e;
  LayerType *pLVar2;
  
  if (PCB->SilkActive == '\0') {
    pLVar2 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  e_00 = (Extra *)((int)arcs + ((int)a - (int)pLVar2->Arc >> 2) * -0xf0f0f0c);
  puVar1 = &e_00->field_0x30;
  *puVar1 = *puVar1 | 2;
  unlink_extras(e_00);
  return;
}



// WARNING: Unknown calling convention

void mark_line_for_deletion(LineTypePtr l)

{
  Extra *e_00;
  Extra *e;
  LayerType *pLVar1;
  
  if (PCB->SilkActive == '\0') {
    pLVar1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  e_00 = (Extra *)((int)lines + ((int)l - (int)pLVar1->Line >> 3) * -0x2e8ba2e4);
  if ((e_00->field_0x30 & 2) == 0) {
    e_00->field_0x30 = e_00->field_0x30 | 2;
    unlink_extras(e_00);
    return;
  }
  __fprintf_chk(stderr,1,"double delete?\n");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

int check_point_in_pad(PadTypePtr pad,int x,int y,End *e)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int inside_p;
  double dVar9;
  LocationType LVar10;
  LocationType LVar11;
  LocationType LVar12;
  BDimension BVar13;
  int iVar14;
  
  BVar13 = pad->Thickness;
  LVar12 = (pad->Point2).Y;
  LVar11 = (pad->Point2).X;
  LVar10 = (pad->Point1).Y;
  iVar14 = x;
  iVar4 = y;
  __printf_chk(1,"pad %d,%d - %d,%d t %d  vs  %d,%d\n",(pad->Point1).X,LVar10,LVar11,LVar12,BVar13,x
               ,y);
  iVar8 = (pad->Thickness + 1) / 2;
  if ((*(byte *)((int)&(pad->Flags).f + 1) & 1) != 0) {
    iVar5 = (pad->Point2).X;
    iVar6 = (pad->Point1).X;
    iVar3 = iVar6 - iVar8;
    iVar7 = iVar5 - iVar8;
    if (iVar7 < iVar3) {
      iVar3 = iVar7;
    }
    if (x < iVar3) {
LAB_080b8ca4:
      __printf_chk(1," - inside_p = %d\n",0,LVar10,LVar11,LVar12,BVar13,iVar14,iVar4);
      return 0;
    }
    iVar6 = iVar8 + iVar6;
    iVar5 = iVar8 + iVar5;
    if (iVar6 < iVar5) {
      iVar6 = iVar5;
    }
    if (iVar6 < x) goto LAB_080b8ca4;
    iVar6 = (pad->Point1).Y;
    iVar5 = (pad->Point2).Y;
    iVar3 = iVar6 - iVar8;
    iVar7 = iVar5 - iVar8;
    if (iVar7 < iVar3) {
      iVar3 = iVar7;
    }
    if (y < iVar3) goto LAB_080b8ca4;
    iVar6 = iVar8 + iVar6;
    iVar8 = iVar8 + iVar5;
    if (iVar6 < iVar8) {
      iVar6 = iVar8;
    }
    __printf_chk(1," - inside_p = %d\n",y <= iVar6,LVar10,LVar11,LVar12,BVar13,iVar14,iVar4);
    if (y > iVar6) {
      return 0;
    }
    goto LAB_080b8d22;
  }
  iVar14 = (pad->Point1).X;
  iVar4 = (pad->Point2).X;
  if (iVar14 == iVar4) {
    if ((x < iVar14 - iVar8) || (iVar8 + iVar14 < x)) goto LAB_080b8de8;
    iVar6 = (pad->Point2).Y;
    iVar4 = (pad->Point1).Y;
    iVar5 = iVar6;
    if (iVar4 <= iVar6) {
      iVar5 = iVar4;
    }
    if (iVar5 <= y) {
      if (iVar6 <= iVar4) {
        iVar6 = iVar4;
      }
joined_r0x080b8e98:
      if (y <= iVar6) goto LAB_080b8d22;
    }
  }
  else {
    iVar6 = iVar14;
    if (iVar4 <= iVar14) {
      iVar6 = iVar4;
    }
    if (iVar6 <= x) {
      if (iVar4 < iVar14) {
        iVar4 = iVar14;
      }
      if (x <= iVar4) {
        iVar4 = (pad->Point1).Y;
        if (iVar4 - iVar8 <= y) {
          iVar6 = iVar8 + iVar4;
          goto joined_r0x080b8e98;
        }
        goto LAB_080b8deb;
      }
    }
LAB_080b8de8:
    iVar4 = (pad->Point1).Y;
  }
LAB_080b8deb:
  dVar9 = dist(iVar14,iVar4,x,y);
  if (((double)iVar8 < dVar9) &&
     (dVar9 = dist((pad->Point2).X,(pad->Point2).Y,x,y), (double)iVar8 < dVar9)) {
    return 0;
  }
LAB_080b8d22:
  bVar1 = e->field_0x8;
  bVar2 = bVar1 | 1;
  e->field_0x8 = bVar2;
  if (((pad->Point1).X == x) && ((pad->Point1).Y == y)) {
    bVar2 = bVar1 | 3;
    e->field_0x8 = bVar2;
  }
  if (((pad->Point2).X == x) && ((pad->Point2).Y == y)) {
    bVar2 = bVar2 | 2;
    e->field_0x8 = bVar2;
  }
  e->field_0x8 = bVar2 | 4;
  e->pin = pad;
  return 1;
}



// WARNING: Unknown calling convention

int find_pair_padarc_callback(BoxType *b,void *cl)

{
  End *e_00;
  LayerType *pLVar1;
  Extra *e;
  
  if (PCB->SilkActive == '\0') {
    pLVar1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  if (*(char *)((int)cl + 0x14) < '\0') {
    if (current_is_solder == 0) {
      return 0;
    }
  }
  else if (current_is_component == 0) {
    return 0;
  }
  e_00 = (End *)((int)arcs + ((int)b - (int)pLVar1->Arc >> 2) * -0xf0f0f0c);
  check_point_in_pad((PadTypePtr)cl,e_00->x,e_00->y,e_00);
  check_point_in_pad((PadTypePtr)cl,e_00[1].x,e_00[1].y,e_00 + 1);
  return 0;
}



// WARNING: Unknown calling convention

void print_extra(Extra *e,Extra *prev)

{
  byte bVar1;
  Extra *pEVar2;
  undefined *puVar3;
  int iVar4;
  LineTypePtr line;
  char *pcVar5;
  undefined *puVar6;
  undefined *puVar7;
  undefined *puVar8;
  DataTypePtr paVar9;
  DataTypePtr paVar10;
  undefined *puVar11;
  char *pcVar12;
  ArcTypePtr arc;
  undefined *puVar13;
  Extra *pEVar14;
  LocationType LVar15;
  
  pEVar2 = (e->start).next;
  if (pEVar2 == last_pextra) {
    pEVar14 = (e->end).next;
    __printf_chk(1,&DAT_0814d6d6,e,pEVar2,pEVar14);
  }
  else {
    pEVar14 = (e->end).next;
    if (last_pextra == pEVar14) {
      __printf_chk(1,&DAT_0814d784,e,pEVar2,last_pextra);
      pEVar14 = last_pextra;
    }
    else {
      __printf_chk(1,"%10p %10p %10p :",e,pEVar2,pEVar14);
    }
  }
  puVar11 = &DAT_08156000;
  puVar13 = &DAT_0815490f;
  last_pextra = e;
  __printf_chk(1," %c%c",(-(uint)((e->field_0x30 & 2) == 0) & 0xffffffc9) + 100,
               (-(uint)((e->field_0x30 & 1) == 0) & 0xffffffc7) + 0x66,pEVar14);
  bVar1 = (e->start).field_0x8;
  puVar6 = &DAT_08156000;
  if ((bVar1 & 8) != 0) {
    puVar6 = &DAT_081486bf;
  }
  puVar7 = &DAT_08156000;
  if ((bVar1 & 4) != 0) {
    puVar7 = &DAT_0815490f;
  }
  puVar8 = &DAT_0814d6f6;
  if ((bVar1 & 2) == 0) {
    puVar8 = &DAT_08156000;
  }
  puVar3 = &DAT_0814d6f8;
  if ((bVar1 & 1) == 0) {
    puVar3 = &DAT_08156000;
  }
  __printf_chk(1," s:%s%s%s%s",puVar3,puVar8,puVar7,puVar6);
  bVar1 = (e->end).field_0x8;
  puVar7 = &DAT_0814d6f6;
  puVar6 = &DAT_081486bf;
  if ((bVar1 & 8) == 0) {
    puVar6 = &DAT_08156000;
  }
  if ((bVar1 & 4) == 0) {
    puVar13 = &DAT_08156000;
  }
  if ((bVar1 & 2) == 0) {
    puVar7 = &DAT_08156000;
  }
  if ((bVar1 & 1) != 0) {
    puVar11 = &DAT_0814d6f8;
  }
  __printf_chk(1," e:%s%s%s%s ",puVar11,puVar7,puVar13,puVar6);
  iVar4 = (int)e - (int)lines >> 2;
  if ((uint)(iVar4 * -0x3b13b13b) < (uint)nlines) {
    if (PCB->SilkActive == '\0') {
      paVar9 = PCB->Data;
      paVar10 = (DataTypePtr)(LayerStack[0] * 0x5c);
    }
    else {
      paVar10 = PCB->Data;
      paVar9 = (DataTypePtr)(((uint)(Settings.ShowSolderSide == '\0') + paVar10->LayerN) * 0x5c);
    }
    line = (LineTypePtr)(iVar4 * -0x4ec4ec48 + *(int *)((int)&paVar9->Layer[0].Line + (int)paVar10))
    ;
    LVar15 = (line->Point2).Y;
    __printf_chk(1," %4d L %d,%d-%d,%d",
                 ((int)line - *(int *)((int)paVar10->name_tree + (int)paVar9->name_tree) >> 3) *
                 -0x45d1745d,(line->Point1).X,(line->Point1).Y,(line->Point2).X,LVar15);
    pcVar5 = "pin";
    pcVar12 = "pin";
    if (((e->end).field_0x8 & 4) != 0) {
      pcVar12 = "pad";
    }
    if (((e->start).field_0x8 & 4) != 0) {
      pcVar5 = "pad";
    }
    __printf_chk(1,"  %s %p %s %p\n",pcVar5,(e->start).pin,pcVar12,(e->end).pin,LVar15);
    return;
  }
  iVar4 = (int)e - (int)arcs >> 2;
  if ((uint)narcs <= (uint)(iVar4 * -0x3b13b13b)) {
    if (e == &multi_next) {
      __printf_chk(1,"-- Multi-next\n",puVar11,puVar7,puVar13,puVar6);
    }
    else {
      __printf_chk(1,"-- Unknown extra: %p\n",e,puVar7,puVar13,puVar6);
    }
    return;
  }
  if (PCB->SilkActive == '\0') {
    paVar9 = PCB->Data;
    paVar10 = (DataTypePtr)(LayerStack[0] * 0x5c);
  }
  else {
    paVar10 = PCB->Data;
    paVar9 = (DataTypePtr)(((uint)(Settings.ShowSolderSide == '\0') + paVar10->LayerN) * 0x5c);
  }
  iVar4 = iVar4 * 0x4ec4ec54 + *(int *)((int)&paVar9->Layer[0].Arc + (int)paVar10);
  __printf_chk(1," %4d A %d,%d-%d,%d",
               (iVar4 - *(int *)((int)&paVar10->Layer[0].Name + (int)(paVar9->name_tree + -2)) >> 2)
               * -0xf0f0f0f,(e->start).x,(e->start).y,(e->end).x,(e->end).y);
  __printf_chk(1," at %d,%d ang %ld,%ld\n",*(undefined4 *)(iVar4 + 0x34),
               *(undefined4 *)(iVar4 + 0x38),*(undefined4 *)(iVar4 + 0x3c),
               *(undefined4 *)(iVar4 + 0x40));
  return;
}



// WARNING: Unknown calling convention

void validate_pair(Extra *e,End *end)

{
  Extra *pEVar1;
  
  pEVar1 = end->next;
  if (((pEVar1 != (Extra *)0x0) && ((pEVar1->start).next != e)) && ((pEVar1->end).next != e)) {
    __fprintf_chk(stderr,1,"no backlink!\n");
    print_extra(e,(Extra *)0x0);
    print_extra(end->next,(Extra *)0x0);
                    // WARNING: Subroutine does not return
    abort();
  }
  return;
}



// WARNING: Unknown calling convention

void reverse_line(LineTypePtr line)

{
  DataTypePtr paVar1;
  LineTypePtr pLVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int iVar9;
  LayerType *Ptr1;
  undefined4 *puVar10;
  Extra *e;
  int y;
  LocationType LVar11;
  LocationType local_80;
  LayerType *local_54;
  LocationType local_50;
  End etmp;
  
  if (PCB->SilkActive == '\0') {
    LVar11 = (line->Point1).Y;
    pLVar2 = PCB->Data->Layer[LayerStack[0]].Line;
    local_54 = (LayerType *)(line->Point2).X;
    local_80 = (line->Point2).Y;
    local_50 = (line->Point1).X;
    Ptr1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    paVar1 = PCB->Data;
    LVar11 = (line->Point1).Y;
    iVar9 = (uint)(Settings.ShowSolderSide == '\0') + paVar1->LayerN;
    pLVar2 = paVar1->Layer[iVar9].Line;
    local_80 = (line->Point2).Y;
    local_50 = (line->Point1).X;
    Ptr1 = paVar1->Layer + iVar9;
    local_54 = (LayerType *)(line->Point2).X;
  }
  puVar10 = (undefined4 *)((int)lines + ((int)line - (int)pLVar2 >> 3) * -0x2e8ba2e4);
  MoveObject(0x1000,Ptr1,line,&line->Point1,(int)local_54 - local_50,local_80 - LVar11);
  if (PCB->SilkActive == '\0') {
    local_54 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    local_54 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  MoveObject(0x1000,local_54,line,&line->Point2,local_50 - (line->Point2).X,
             LVar11 - (line->Point2).Y);
  uVar3 = *puVar10;
  uVar4 = puVar10[1];
  uVar5 = puVar10[2];
  uVar6 = puVar10[3];
  uVar7 = puVar10[4];
  uVar8 = puVar10[5];
  *puVar10 = puVar10[6];
  puVar10[1] = puVar10[7];
  puVar10[2] = puVar10[8];
  puVar10[3] = puVar10[9];
  puVar10[4] = puVar10[10];
  puVar10[5] = puVar10[0xb];
  puVar10[6] = uVar3;
  puVar10[7] = uVar4;
  puVar10[8] = uVar5;
  puVar10[9] = uVar6;
  puVar10[10] = uVar7;
  puVar10[0xb] = uVar8;
  return;
}



// WARNING: Unknown calling convention

void reverse_arc(ArcTypePtr arc)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  Extra *e;
  DataTypePtr paVar8;
  DataTypePtr paVar9;
  End etmp;
  
  if (PCB->SilkActive == '\0') {
    paVar9 = PCB->Data;
    paVar8 = (DataTypePtr)(LayerStack[0] * 0x5c);
  }
  else {
    paVar8 = PCB->Data;
    paVar9 = (DataTypePtr)(((uint)(Settings.ShowSolderSide == '\0') + paVar8->LayerN) * 0x5c);
  }
  puVar1 = (undefined4 *)
           ((int)arcs +
           ((int)arc - *(int *)((int)&paVar9->Layer[0].Arc + (int)paVar8) >> 2) * -0xf0f0f0c);
  ChangeArcAngles((LayerTypePtr)((int)paVar8->name_tree + (int)(&paVar9->Layer[0].Name + -0xe)),arc,
                  arc->Delta + arc->StartAngle,-arc->Delta);
  uVar2 = *puVar1;
  uVar3 = puVar1[1];
  uVar4 = puVar1[2];
  uVar5 = puVar1[3];
  uVar6 = puVar1[4];
  uVar7 = puVar1[5];
  *puVar1 = puVar1[6];
  puVar1[1] = puVar1[7];
  puVar1[2] = puVar1[8];
  puVar1[3] = puVar1[9];
  puVar1[4] = puVar1[10];
  puVar1[5] = puVar1[0xb];
  puVar1[6] = uVar2;
  puVar1[7] = uVar3;
  puVar1[8] = uVar4;
  puVar1[9] = uVar5;
  puVar1[10] = uVar6;
  puVar1[0xb] = uVar7;
  return;
}



// WARNING: Removing unreachable block (ram,0x080b98ee)
// WARNING: Unknown calling convention

int gp_point_force(int x,int y,int t,End *e,int esa,int eda,int force,char *name)

{
  double dVar1;
  double dVar2;
  int sr;
  LocationType LVar3;
  double point_angle;
  longdouble lVar4;
  double a;
  double sa;
  double base_angle;
  double da;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  LocationType local_34;
  LocationType local_30;
  
  if (start_arc == (ArcTypePtr)0x0) {
    LVar3 = 0;
    local_34 = (start_line->Point1).X;
    local_30 = (start_line->Point1).Y;
  }
  else {
    local_34 = start_arc->X;
    LVar3 = start_arc->Width;
    local_30 = start_arc->Y;
  }
  dVar7 = (double)(t + thickness);
  dVar5 = dist(local_34,local_30,x,y);
  if (((double)LVar3 - dVar7 <= dVar5) && ((LVar3 != 0 || (dVar7 <= dVar5)))) {
    dVar6 = atan2((double)(y - local_30),(double)(x - local_34));
    dVar5 = ((double)LVar3 * sa_sign - dVar7) / dVar5;
    if ((dVar5 <= 1.0) && (-1.0 <= dVar5)) {
      dVar5 = asin(dVar5);
      dVar6 = dVar6 + dVar5 * se_sign;
      if (eda != 0) {
        dVar8 = ((double)(0xb4 - esa) * 3.141592653589793) / 180.0;
        dVar5 = ((double)-eda * 3.141592653589793) / 180.0;
        if (dVar5 < 0.0) {
          dVar8 = dVar8 + dVar5;
          dVar5 = -dVar5;
        }
        dVar1 = se_sign * 3.141592653589793 * -0.5 + dVar6;
        for (; dVar2 = dVar8 + dVar5, dVar2 < dVar1; dVar8 = dVar8 + 6.283185307179586) {
        }
        if (dVar1 < dVar8) {
          do {
            dVar8 = dVar8 - 6.283185307179586;
          } while (dVar1 < dVar8);
          dVar2 = dVar8 + dVar5;
        }
        if (dVar2 < dVar1) {
          return 0;
        }
      }
      for (dVar6 = dVar6 - start_angle; 3.141592653589793 < dVar6; dVar6 = dVar6 - 6.283185307179586
          ) {
      }
      for (; dVar6 < -3.141592653589793; dVar6 = dVar6 + 6.283185307179586) {
      }
      if ((force != 0) || (-0.007 <= dVar6 * se_sign)) {
        if (dVar6 * se_sign == se_sign * best_angle) {
          dVar5 = dist((start_line->Point1).X,(start_line->Point1).Y,fx,fy);
          dVar8 = dist((start_line->Point1).X,(start_line->Point1).Y,x,y);
          if (dVar8 <= dVar5) {
            return 1;
          }
        }
        else if (se_sign * best_angle <= dVar6 * se_sign) {
          return 1;
        }
        fp = 0;
        fr = (int)ROUND(dVar7);
        if (e != (End *)0x0) {
          fp = (byte)e->field_0x8 >> 3 & 1;
        }
        best_angle = dVar6;
        fx = x;
        fy = y;
        fp_end = e;
        fa = dVar6;
        return 1;
      }
      dVar7 = dist_lp((start_line->Point1).X,(start_line->Point1).Y,(start_line->Point2).X,
                      (start_line->Point2).Y,x,y);
      lVar4 = (longdouble)((int)ROUND(dVar7 - (double)thickness) + -1);
      if (lVar4 < (longdouble)t) {
        gp_point_force(x,y,(int)ROUND(lVar4),e,esa,eda,1,"gp_point_force");
        return 0;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int gp_point_2(int x,int y,int t,End *e,int esa,int eda,char *func)

{
  int x2;
  int iVar1;
  int iVar2;
  double dVar3;
  int iVar4;
  double sd;
  double dVar5;
  
  if ((x == sa_x) && (y == sa_y)) {
    return 0;
  }
  iVar4 = (end_line->Point2).Y;
  x2 = (end_line->Point2).X;
  iVar1 = (start_line->Point1).X;
  iVar2 = (start_line->Point1).Y;
  if (-1 < t) {
    dVar5 = (double)(y - iVar2);
    dVar3 = (double)(x - iVar1);
    if (((double)(x2 - iVar1) * dVar5 - (double)(iVar4 - iVar2) * dVar3) * se_sign < 0.0) {
      if (((double)((start_line->Point2).X - iVar1) * dVar5 -
          (double)((start_line->Point2).Y - iVar2) * dVar3) * se_sign < 0.0) {
        return 0;
      }
      iVar1 = (end_line->Point1).X;
      iVar2 = (end_line->Point1).Y;
      if (((double)(y - iVar2) * (double)(x2 - iVar1) -
          (double)(x - iVar1) * (double)(iVar4 - iVar2)) * se_sign < 0.0) {
        return 0;
      }
    }
    else if (((dVar5 * (double)(iVar4 - iVar2) + dVar3 * (double)(x2 - iVar1) <= 0.0) ||
             ((double)(y - iVar4) * (double)(iVar2 - iVar4) +
              (double)(x - x2) * (double)(iVar1 - x2) <= 0.0)) ||
            (dVar5 = dist_lp(iVar1,iVar2,x2,iVar4,x,y), (double)(t + thickness) < dVar5)) {
      return 0;
    }
  }
  iVar4 = gp_point_force(x,y,t,e,esa,eda,0,func);
  return iVar4;
}



// WARNING: Unknown calling convention

int gp_pad_cb(BoxType *b,void *cb)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int t;
  int x1;
  int y1;
  int iVar4;
  
  if ((b != (BoxType *)start_pinpad) && (b != (BoxType *)end_pinpad)) {
    if (*(char *)&b[1].Y1 < '\0') {
      if (current_is_solder == 0) {
        return 0;
      }
    }
    else if (current_is_component == 0) {
      return 0;
    }
    t = (b[2].Y1 + 1) / 2;
    if ((b[1].Y1 & 0x900U) == 0) {
      gp_point_2(b[2].Y2,b[3].X1,t,(End *)0x0,0,0,"gp_pad_cb");
      gp_point_2(b[4].X1,b[4].Y1,t,(End *)0x0,0,0,"gp_pad_cb");
    }
    else {
      iVar2 = b[2].Y2;
      iVar1 = b[4].X1;
      if (iVar2 == iVar1) {
        iVar1 = b[3].X1;
        iVar3 = b[4].Y1;
        iVar4 = iVar3;
        if (iVar1 <= iVar3) {
          iVar4 = iVar1;
        }
        if (iVar3 <= iVar1) {
          iVar3 = iVar1;
        }
        gp_point_2(iVar2 - t,iVar4 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(b[2].Y2 - t,t + iVar3,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(b[2].Y2 + t,iVar4 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(b[2].Y2 + t,t + iVar3,0,(End *)0x0,0,0,"gp_pad_cb");
      }
      else {
        iVar3 = iVar2;
        if (iVar1 <= iVar2) {
          iVar3 = iVar1;
        }
        if (iVar2 <= iVar1) {
          iVar2 = iVar1;
        }
        gp_point_2(iVar3 - t,b[3].X1 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(t + iVar2,b[3].X1 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(iVar3 - t,b[3].X1 + t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(t + iVar2,b[3].X1 + t,0,(End *)0x0,0,0,"gp_pad_cb");
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int gp_pin_cb(BoxType *b,void *cb)

{
  int t;
  
  if ((b != (BoxType *)start_pinpad) && (b != (BoxType *)end_pinpad)) {
    t = (b[2].Y1 + 1) / 2;
    if ((b[1].Y1 & 0x900U) != 0) {
      gp_point_2(b[3].Y1 - t,b[3].X2 - t,0,(End *)0x0,0,0,"gp_pin_cb");
      gp_point_2(b[3].Y1 - t,b[3].X2 + t,0,(End *)0x0,0,0,"gp_pin_cb");
      gp_point_2(b[3].Y1 + t,b[3].X2 + t,0,(End *)0x0,0,0,"gp_pin_cb");
      gp_point_2(b[3].Y1 + t,b[3].X2 - t,0,(End *)0x0,0,0,"gp_pin_cb");
      return 0;
    }
    gp_point_2(b[3].Y1,b[3].X2,t,(End *)0x0,0,0,"gp_pin_cb");
  }
  return 0;
}



// WARNING: Unknown calling convention

int gp_poly_cb(BoxType *b,void *cb)

{
  int iVar1;
  int *piVar2;
  uint uVar3;
  int i;
  
  if (b[2].Y1 != 0) {
    uVar3 = 0;
    do {
      iVar1 = uVar3 * 0x14;
      uVar3 = uVar3 + 1;
      piVar2 = (int *)(iVar1 + b[3].X2);
      gp_point_2(*piVar2,piVar2[1],0,(End *)0x0,0,0,"gp_poly_cb");
    } while (uVar3 <= (uint)b[2].Y1 && b[2].Y1 != uVar3);
  }
  return 0;
}



// WARNING: Unknown calling convention

int gp_text_cb(BoxType *b,void *cb)

{
  gp_point_2(b->X1,b->Y1,0,(End *)0x0,0,0,"gp_text_cb");
  gp_point_2(b->X1,b->Y2,0,(End *)0x0,0,0,"gp_text_cb");
  gp_point_2(b->X2,b->Y2,0,(End *)0x0,0,0,"gp_text_cb");
  gp_point_2(b->X2,b->Y1,0,(End *)0x0,0,0,"gp_text_cb");
  return 0;
}



// WARNING: Unknown calling convention

int gp_arc_cb(BoxType *b,void *cb)

{
  int *piVar1;
  LayerType *pLVar2;
  Extra *e;
  
  if (PCB->SilkActive == '\0') {
    pLVar2 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar2 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  if ((((((ArcTypePtr)b != start_arc) && ((ArcTypePtr)b != end_arc)) &&
       (piVar1 = (int *)((int)arcs + ((int)b - (int)pLVar2->Arc >> 2) * -0xf0f0f0c),
       (*(byte *)(piVar1 + 0xc) & 2) == 0)) &&
      (((gp_point_2(b[3].Y1,b[3].X2,b[2].Y1 / 2 + b[2].Y2,(End *)0x0,b[3].Y2,b[4].X1,"gp_arc_cb"),
        start_arc == (ArcTypePtr)0x0 || (b[3].Y1 != start_arc->X)) || (b[3].X2 != start_arc->Y))))
     && ((((end_arc == (ArcTypePtr)0x0 || (b[3].Y1 == end_arc->X)) || (b[3].X2 == end_arc->Y)) &&
         ((*piVar1 == 0 && (piVar1[6] == 0)))))) {
    gp_point_2(piVar1[3],piVar1[4],b[2].Y1 / 2,(End *)0x0,0,0,"gp_arc_cb");
    gp_point_2(piVar1[9],piVar1[10],b[2].Y1 / 2,(End *)0x0,0,0,"gp_arc_cb");
  }
  return 0;
}



// WARNING: Unknown calling convention

int gp_line_cb(BoxType *b,void *cb)

{
  End *e_00;
  LayerType *pLVar1;
  Extra *e;
  
  if (PCB->SilkActive == '\0') {
    pLVar1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  if ((((LineTypePtr)b != start_line) && ((LineTypePtr)b != end_line)) &&
     (e_00 = (End *)((int)lines + ((int)b - (int)pLVar1->Line >> 3) * -0x2e8ba2e4),
     (*(byte *)&e_00[2].next & 2) == 0)) {
    if ((e_00->next == (Extra *)0x0) ||
       ((uint)narcs <= (uint)(((int)e_00->next - (int)arcs >> 2) * -0x3b13b13b))) {
      gp_point_2(b[2].Y2,b[3].X1,b[2].Y1 / 2,e_00,0,0,"gp_line_cb");
    }
    if ((e_00[1].next == (Extra *)0x0) ||
       ((uint)narcs <= (uint)(((int)e_00[1].next - (int)arcs >> 2) * -0x3b13b13b))) {
      gp_point_2(b[4].X1,b[4].Y1,b[2].Y1 / 2,e_00 + 1,0,0,"gp_line_cb");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void maybe_pull_1(LineTypePtr line)

{
  undefined *puVar1;
  Extra *pEVar2;
  char cVar3;
  void *pvVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  double dVar9;
  LocationType LVar10;
  LineTypePtr pLVar11;
  LayerType *pLVar12;
  Extra *pEVar13;
  Extra *new_lextra;
  LayerTypePtr pLVar14;
  Extra *pEVar15;
  DataTypePtr paVar16;
  Extra *e;
  Extra *pEVar17;
  Extra *new_arcs;
  Extra *new_lines;
  int ex;
  int iVar18;
  LineTypePtr new_line;
  int iVar19;
  int iVar20;
  int iVar21;
  int iVar22;
  int pcb_fa;
  int end_change;
  int iVar23;
  int iVar24;
  undefined4 *puVar25;
  DataTypePtr paVar26;
  int end_angle;
  int ey;
  byte bVar27;
  double d;
  double new_delta;
  double dVar28;
  LayerType *local_50;
  int local_4c;
  ArcTypePtr local_48;
  double local_3c;
  double local_34;
  BoxType box;
  
  bVar27 = 0;
  if (PCB->SilkActive == '\0') {
    pLVar12 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  start_extra = (Extra *)((int)lines + ((int)line - (int)pLVar12->Line >> 3) * -0x2e8ba2e4);
  end_extra = (start_extra->end).next;
  if (PCB->SilkActive == '\0') {
    pLVar12 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  end_line = (LineTypePtr)(((int)end_extra - (int)lines >> 2) * -0x4ec4ec48 + (int)pLVar12->Line);
  start_line = line;
  if ((end_extra->field_0x30 & 2) != 0) {
    puVar1 = &(start_extra->end).field_0x8;
    *puVar1 = *puVar1 & 0xf7;
    return;
  }
  if (start_extra == (end_extra->end).next) {
    reverse_line(end_line);
  }
  sarc_extra = (start_extra->start).next;
  if ((sarc_extra == (Extra *)0x0) ||
     ((uint)narcs <= (uint)(((int)sarc_extra - (int)arcs >> 2) * -0x3b13b13b))) {
    start_arc = (ArcTypePtr)0x0;
    sarc_extra = (Extra *)0x0;
  }
  else {
    if (PCB->SilkActive == '\0') {
      pLVar12 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    start_arc = (ArcTypePtr)(((int)sarc_extra - (int)arcs >> 2) * 0x4ec4ec54 + (int)pLVar12->Arc);
    if ((sarc_extra->start).next == start_extra) {
      reverse_arc(start_arc);
    }
  }
  earc_extra = (end_extra->end).next;
  if ((earc_extra == (Extra *)0x0) ||
     ((uint)narcs <= (uint)(((int)earc_extra - (int)arcs >> 2) * -0x3b13b13b))) {
    end_arc = (ArcTypePtr)0x0;
    earc_extra = (Extra *)0x0;
  }
  else {
    if (PCB->SilkActive == '\0') {
      pLVar12 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    end_arc = (ArcTypePtr)(((int)earc_extra - (int)arcs >> 2) * 0x4ec4ec54 + (int)pLVar12->Arc);
    if ((earc_extra->start).next == end_extra) {
      reverse_arc(end_arc);
    }
  }
  if (((start_extra->end).field_0x8 & 8) == 0) {
    return;
  }
  if (start_line->Thickness != end_line->Thickness) {
    return;
  }
  thickness = (start_line->Thickness + 1) / 2 + PCB->Bloat;
  iVar18 = (start_line->Point1).X - thickness;
  iVar19 = (start_line->Point1).X + thickness;
  iVar23 = (start_line->Point1).Y - thickness;
  iVar20 = (start_line->Point1).Y + thickness;
  iVar24 = (start_line->Point2).Y;
  iVar22 = (start_line->Point2).X;
  iVar21 = iVar22 - thickness;
  if (iVar21 <= iVar18) {
    iVar18 = iVar21;
  }
  iVar22 = thickness + iVar22;
  if (iVar22 < iVar19) {
    iVar22 = iVar19;
  }
  iVar19 = iVar24 - thickness;
  if (iVar23 < iVar19) {
    iVar19 = iVar23;
  }
  iVar24 = iVar24 + thickness;
  if (iVar20 <= iVar24) {
    iVar20 = iVar24;
  }
  iVar21 = (end_line->Point2).Y;
  iVar24 = (end_line->Point2).X;
  iVar23 = iVar24 - thickness;
  if (iVar18 <= iVar23) {
    iVar23 = iVar18;
  }
  iVar24 = thickness + iVar24;
  if (iVar24 <= iVar22) {
    iVar24 = iVar22;
  }
  iVar22 = iVar21 - thickness;
  if (iVar19 <= iVar22) {
    iVar22 = iVar19;
  }
  iVar21 = thickness + iVar21;
  if (iVar20 < iVar21) {
    iVar20 = iVar21;
  }
  box.X1 = iVar23;
  box.Y1 = iVar22;
  box.X2 = iVar24;
  box.Y2 = iVar20;
  if (start_arc != (ArcTypePtr)0x0) {
    iVar21 = start_arc->Thickness / 2;
    iVar18 = (sarc_extra->start).y;
    iVar19 = (sarc_extra->start).x;
    box.X1 = iVar19 - iVar21;
    if (iVar23 <= box.X1) {
      box.X1 = iVar23;
    }
    box.X2 = iVar21 + iVar19;
    if (box.X2 <= iVar24) {
      box.X2 = iVar24;
    }
    box.Y1 = iVar18 - iVar21;
    if (iVar22 <= box.Y1) {
      box.Y1 = iVar22;
    }
    box.Y2 = iVar21 + iVar18;
    if (box.Y2 <= iVar20) {
      box.Y2 = iVar20;
    }
  }
  LVar10 = box.Y2;
  if (end_arc != (ArcTypePtr)0x0) {
    iVar20 = end_arc->Thickness / 2;
    iVar22 = (earc_extra->start).y;
    iVar24 = (earc_extra->start).x;
    iVar18 = iVar24 - iVar20;
    if (iVar18 <= box.X1) {
      box.X1 = iVar18;
    }
    iVar24 = iVar24 + iVar20;
    if (box.X2 <= iVar24) {
      box.X2 = iVar24;
    }
    iVar24 = iVar22 - iVar20;
    if (iVar24 <= box.Y1) {
      box.Y1 = iVar24;
    }
    LVar10 = iVar20 + iVar22;
    if (LVar10 < box.Y2) {
      LVar10 = box.Y2;
    }
  }
  box.Y2 = LVar10;
  iVar22 = (start_line->Point1).X;
  iVar24 = (start_line->Point1).Y;
  se_sign = 1.0;
  if ((longdouble)((end_line->Point2).Y - iVar24) * (longdouble)((start_line->Point2).X - iVar22) -
      (longdouble)((end_line->Point2).X - iVar22) * (longdouble)((start_line->Point2).Y - iVar24) <
      (longdouble)0) {
    se_sign = -1.0;
  }
  best_angle = se_sign * 3.141592653589793;
  if (start_arc == (ArcTypePtr)0x0) {
    sa_sign = 0.0;
  }
  else {
    dVar28 = 1.0;
    if ((longdouble)-start_arc->Delta < (longdouble)0) {
      dVar28 = -1.0;
    }
    sa_sign = dVar28 * se_sign;
  }
  if (end_arc == (ArcTypePtr)0x0) {
    ea_sign = 0.0;
  }
  else {
    dVar28 = 1.0;
    if ((longdouble)-end_arc->Delta < (longdouble)0) {
      dVar28 = -1.0;
    }
    ea_sign = -se_sign * dVar28;
  }
  start_angle = atan2((double)((start_line->Point2).Y - (start_line->Point1).Y),
                      (double)((start_line->Point2).X - (start_line->Point1).X));
  if (start_arc == (ArcTypePtr)0x0) {
    sa_x = (start_line->Point1).X;
    sa_y = (start_line->Point1).Y;
    sa_r = 0;
  }
  else {
    sa_x = start_arc->X;
    sa_y = start_arc->Y;
    if ((double)start_arc->Delta * se_sign < 0.0) {
      sa_r = start_arc->Width;
    }
    else {
      sa_r = -start_arc->Width;
    }
  }
  if (end_arc == (ArcTypePtr)0x0) {
    ea_r = 0;
LAB_080bbe6a:
    gp_point_force((end_line->Point2).X,(end_line->Point2).Y,-thickness,(End *)0x0,0,0,1,"end arc");
    LVar10 = (end_line->Point2).X;
    local_48 = (ArcTypePtr)(end_line->Point2).Y;
  }
  else {
    if (0.0 <= ea_sign) {
      ea_r = -end_arc->Width;
    }
    else {
      ea_r = end_arc->Width;
    }
    if (end_arc == (ArcTypePtr)0x0) goto LAB_080bbe6a;
    gp_point_force(end_arc->X,end_arc->Y,-thickness - ea_r,(End *)0x0,0,0,1,"end arc");
    LVar10 = end_arc->X;
    local_48 = (ArcTypePtr)end_arc->Y;
  }
  fy = (int)local_48;
  fx = LVar10;
  if (LVar10 < 0) {
    __fprintf_chk(stderr,1,"end line corrupt? f is %d,%d\n",LVar10,local_48);
    print_extra(end_extra,(Extra *)0x0);
    if (earc_extra != (Extra *)0x0) {
      print_extra(earc_extra,(Extra *)0x0);
    }
                    // WARNING: Subroutine does not return
    abort();
  }
  end_dist = dist((end_line->Point1).X,(end_line->Point1).Y,(end_line->Point2).X,
                  (end_line->Point2).Y);
  fp = 0;
  start_pinpad = (start_extra->start).pin;
  end_pinpad = (start_extra->end).pin;
  if (PCB->SilkActive == '\0') {
    pLVar12 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  r_search(pLVar12->line_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,gp_line_cb,(void *)0x0);
  if (PCB->SilkActive == '\0') {
    pLVar12 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  r_search(pLVar12->arc_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,gp_arc_cb,(void *)0x0);
  if (PCB->SilkActive == '\0') {
    pLVar12 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  r_search(pLVar12->text_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,gp_text_cb,(void *)0x0);
  if (PCB->SilkActive == '\0') {
    pLVar12 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  r_search(pLVar12->polygon_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,gp_poly_cb,(void *)0x0);
  r_search(PCB->Data->pin_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,gp_pin_cb,(void *)0x0);
  r_search(PCB->Data->via_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,gp_pin_cb,(void *)0x0);
  r_search(PCB->Data->pad_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,gp_pad_cb,(void *)0x0);
  dVar9 = fa;
  dVar28 = start_angle;
  if (fp != 0) {
    (start_extra->end).waiting_for = fp_end;
    return;
  }
  puVar1 = &(start_extra->end).field_0x8;
  *puVar1 = *puVar1 & 0xf7;
  if ((fx == LVar10) && ((ArcTypePtr)fy == local_48)) {
    if (start_arc == (ArcTypePtr)0x0) goto LAB_080bae20;
    if (((end_arc != (ArcTypePtr)0x0) && (start_arc->X == end_arc->X)) &&
       (start_arc->Y == end_arc->Y)) {
      iVar22 = end_arc->StartAngle - start_arc->StartAngle;
      if (start_arc->Delta < 1) {
        for (; iVar22 < -0x168; iVar22 = iVar22 + 0x168) {
        }
        for (; 0 < iVar22; iVar22 = iVar22 + -0x168) {
        }
      }
      else {
        for (; 0x168 < iVar22; iVar22 = iVar22 + -0x168) {
        }
        for (; iVar22 < 0; iVar22 = iVar22 + 0x168) {
        }
      }
      mark_arc_for_deletion(end_arc);
      mark_line_for_deletion(start_line);
      mark_line_for_deletion(end_line);
      if (PCB->SilkActive == '\0') {
        pLVar14 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      ChangeArcAngles(pLVar14,start_arc,start_arc->StartAngle,iVar22);
      fix_arc_extra(start_arc,sarc_extra);
      did_something = did_something + 1;
      return;
    }
  }
  else if (start_arc == (ArcTypePtr)0x0) goto LAB_080bae20;
  iVar22 = start_arc->Delta;
  dVar28 = 180.0 - ((dVar28 + dVar9) * 180.0) / 3.141592653589793;
  if (iVar22 < 0) {
    iVar24 = (int)ROUND(dVar28) + 0x5a;
  }
  else {
    iVar24 = (int)ROUND(dVar28) + -0x5a;
  }
  for (fVar5 = (float)iVar24 - (float)start_arc->StartAngle; (float)(iVar22 + 0xb4) < fVar5;
      fVar5 = fVar5 - 360.0) {
  }
  for (; fVar5 < (float)(iVar22 + -0xb4); fVar5 = fVar5 + 360.0) {
  }
  if (PCB->SilkActive == '\0') {
    pLVar14 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  ChangeArcAngles(pLVar14,start_arc,start_arc->StartAngle,(int)ROUND(fVar5));
  fix_arc_extra(start_arc,sarc_extra);
  if (PCB->SilkActive == '\0') {
    pLVar12 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  MoveObject(0x1000,pLVar12,start_line,&start_line->Point1,
             (sarc_extra->end).x - (start_line->Point1).X,
             (sarc_extra->end).y - (start_line->Point1).Y);
  if (0.0 <= fVar5 * (float)iVar22) {
    if (PCB->SilkActive == '\0') {
      pLVar12 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    MoveObject(0x1000,pLVar12,start_line,&start_line->Point1,
               (sarc_extra->start).x - (start_line->Point1).X,
               (sarc_extra->start).y - (start_line->Point1).Y);
    mark_arc_for_deletion(start_arc);
  }
LAB_080bae20:
  iVar24 = fy;
  iVar22 = fx;
  sincos(se_sign * -1.570796326794897 + start_angle + fa,&local_34,&local_3c);
  dVar28 = dist((int)ROUND((double)fr * local_3c + (double)iVar22),
                (int)ROUND(local_34 * (double)fr + (double)iVar24),(end_line->Point2).X,
                (end_line->Point2).Y);
  pLVar11 = start_line;
  if (dVar28 < (double)fr * 0.0174524064372835) {
    fy = (int)local_48;
    fx = LVar10;
  }
  else if ((fx != LVar10) || ((ArcTypePtr)fy != local_48)) {
    iVar20 = (start_line->Point1).X;
    sincos(start_angle + fa,&local_34,&local_3c);
    iVar18 = (pLVar11->Point1).Y;
    iVar22 = (int)ROUND((float)local_3c * 10000.0 + (float)iVar20);
    local_4c = (end_line->Point2).X;
    fVar6 = (float)iVar18;
    local_50 = (LayerType *)(end_line->Point2).Y;
    iVar19 = (end_line->Point1).Y;
    iVar21 = (end_line->Point1).X;
    iVar24 = (int)ROUND((float)local_34 * 10000.0 + fVar6);
    iVar18 = iVar18 - iVar24;
    fVar8 = (float)(iVar20 - iVar22);
    fVar5 = (float)(iVar19 - (int)local_50) * fVar8 - (float)iVar18 * (float)(iVar21 - local_4c);
    if (fVar5 != 0.0) {
      fVar7 = (float)iVar21 * (float)(int)local_50 - (float)iVar19 * (float)local_4c;
      fVar6 = (float)iVar24 * (float)iVar20 - (float)iVar22 * fVar6;
      local_4c = (int)ROUND(((float)(iVar21 - local_4c) * fVar6 - fVar8 * fVar7) / fVar5 + 0.5);
      local_50 = (LayerType *)
                 (int)ROUND(fVar5 / (fVar6 * (float)(iVar19 - (int)local_50) - fVar7 * (float)iVar18
                                    ) + 0.5);
    }
    if (PCB->SilkActive == '\0') {
      pLVar12 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    MoveObject(0x1000,pLVar12,end_line,&end_line->Point1,local_4c - iVar21,(int)local_50 - iVar19);
    iVar20 = fy;
    iVar24 = fx;
    pLVar11 = start_line;
    dVar28 = -se_sign;
    iVar22 = (int)ROUND(se_sign * 90.0 +
                        (double)(0xb4 - (int)ROUND(((start_angle + fa) * 180.0) / 3.141592653589793
                                                   + 0.5)));
    iVar19 = fr % 100;
    iVar18 = fr;
    if (iVar19 == 1) {
      iVar18 = fr + -1;
      iVar19 = iVar18 % 100;
    }
    iVar18 = iVar18 + (uint)(iVar19 == 99);
    if (PCB->SilkActive == '\0') {
      pLVar14 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    local_48 = CreateNewArcOnLayer(pLVar14,fx,fy,iVar18,iVar18,iVar22,(int)ROUND(dVar28),
                                   start_line->Thickness,start_line->Clearance,start_line->Flags);
    if (local_48 == (ArcTypePtr)0x0) {
      if (PCB->SilkActive == '\0') {
        pLVar14 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      local_48 = CreateNewArcOnLayer(pLVar14,iVar24,iVar20,iVar18,iVar18,iVar22,
                                     (int)ROUND(dVar28) * 2,pLVar11->Thickness,pLVar11->Clearance,
                                     pLVar11->Flags);
    }
    if (PCB->SilkActive == '\0') {
      pLVar12 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    AddObjectToCreateUndoList(0x4000,pLVar12,local_48,local_48);
    if (local_48 != (ArcTypePtr)0x0) {
      cVar3 = PCB->SilkActive;
      if (cVar3 == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      if ((uint)max_arcs <= pLVar12->ArcN) {
        max_arcs = max_arcs + 100;
        pEVar17 = (Extra *)realloc(arcs,max_arcs * 0x34);
        pEVar2 = arcs;
        if (pEVar17 != arcs) {
          arcs = pEVar17;
          adjust_pointers(pEVar2,pEVar17,narcs);
          pEVar17 = arcs;
        }
        memset(pEVar17 + narcs,0,(max_arcs - narcs) * 0x34);
        cVar3 = PCB->SilkActive;
      }
      if (cVar3 == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      narcs = pLVar12->ArcN;
      if (PCB->SilkActive == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      pEVar2 = (Extra *)((int)arcs + ((int)local_48 - (int)pLVar12->Arc >> 2) * -0xf0f0f0c);
      pEVar17 = pEVar2;
      for (iVar22 = 0xd; iVar22 != 0; iVar22 = iVar22 + -1) {
        (pEVar17->start).next = (Extra *)0x0;
        pEVar17 = (Extra *)((int)pEVar17 + (uint)bVar27 * -8 + 4);
      }
      fix_arc_extra(local_48,pEVar2);
      cVar3 = PCB->SilkActive;
      if (cVar3 == '\0') {
        paVar16 = PCB->Data;
        pLVar12 = paVar16->Layer + LayerStack[0];
      }
      else {
        paVar16 = PCB->Data;
        pLVar12 = paVar16->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar16->LayerN;
      }
      pEVar2 = (Extra *)((int)arcs + ((int)local_48 - (int)pLVar12->Arc >> 2) * -0xf0f0f0c);
      if (start_arc != (ArcTypePtr)0x0) {
        if (cVar3 == '\0') {
          pLVar12 = paVar16->Layer + LayerStack[0];
        }
        else {
          pLVar12 = paVar16->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar16->LayerN;
        }
        paVar16 = PCB->Data;
        sarc_extra = (Extra *)((int)arcs + ((int)start_arc - (int)pLVar12->Arc >> 2) * -0xf0f0f0c);
        cVar3 = PCB->SilkActive;
      }
      if (end_arc != (ArcTypePtr)0x0) {
        if (cVar3 == '\0') {
          pLVar12 = paVar16->Layer + LayerStack[0];
        }
        else {
          pLVar12 = paVar16->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar16->LayerN;
        }
        paVar16 = PCB->Data;
        earc_extra = (Extra *)((int)arcs + ((int)end_arc - (int)pLVar12->Arc >> 2) * -0xf0f0f0c);
        cVar3 = PCB->SilkActive;
      }
      if (cVar3 == '\0') {
        pLVar12 = paVar16->Layer + LayerStack[0];
      }
      else {
        pLVar12 = paVar16->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar16->LayerN;
      }
      MoveObject(0x1000,pLVar12,start_line,&start_line->Point2,
                 (pEVar2->start).x - (start_line->Point2).X,
                 (pEVar2->start).y - (start_line->Point2).Y);
      if (PCB->SilkActive == '\0') {
        pLVar14 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      pLVar11 = CreateNewLineOnLayer
                          (pLVar14,(pEVar2->end).x,(pEVar2->end).y,local_4c,(LocationType)local_50,
                           start_line->Thickness,start_line->Clearance,start_line->Flags);
      if (PCB->SilkActive == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      AddObjectToCreateUndoList(4,pLVar12,pLVar11,pLVar11);
      cVar3 = PCB->SilkActive;
      if (cVar3 == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      if ((uint)max_lines <= pLVar12->LineN) {
        max_lines = max_lines + 100;
        pEVar13 = (Extra *)realloc(lines,max_lines * 0x34);
        pEVar17 = lines;
        if (pEVar13 != lines) {
          lines = pEVar13;
          adjust_pointers(pEVar17,pEVar13,nlines);
          pEVar13 = lines;
        }
        memset(pEVar13 + nlines,0,(max_lines - nlines) * 0x34);
        cVar3 = PCB->SilkActive;
      }
      if (cVar3 == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      nlines = pLVar12->LineN;
      if (PCB->SilkActive == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      puVar25 = (undefined4 *)((int)lines + ((int)pLVar11 - (int)pLVar12->Line >> 3) * -0x2e8ba2e4);
      for (iVar22 = 0xd; iVar22 != 0; iVar22 = iVar22 + -1) {
        *puVar25 = 0;
        puVar25 = puVar25 + (uint)bVar27 * -2 + 1;
      }
      if (PCB->SilkActive == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      pEVar17 = (Extra *)(((int)start_line - (int)pLVar12->Line >> 3) * -0x2e8ba2e4 + (int)lines);
      if (PCB->SilkActive == '\0') {
        paVar26 = PCB->Data;
        paVar16 = (DataTypePtr)(LayerStack[0] * 0x5c);
      }
      else {
        paVar16 = PCB->Data;
        paVar26 = (DataTypePtr)(((uint)(Settings.ShowSolderSide == '\0') + paVar16->LayerN) * 0x5c);
      }
      pEVar13 = (Extra *)(((int)pLVar11 - *(int *)((int)&paVar26->Layer[0].Line + (int)paVar16) >> 3
                          ) * -0x2e8ba2e4 + (int)lines);
      pEVar15 = (Extra *)((int)lines +
                         ((int)end_line -
                          *(int *)((int)paVar16->name_tree + (int)paVar26->name_tree) >> 3) *
                         -0x2e8ba2e4);
      start_extra = pEVar17;
      end_extra = pEVar15;
      (pEVar13->start).pin = (pEVar17->start).pin;
      pvVar4 = (pEVar17->end).pin;
      puVar1 = &(pEVar13->start).field_0x8;
      *puVar1 = *puVar1 | 8;
      puVar1 = &(pEVar13->end).field_0x8;
      *puVar1 = *puVar1 | 8;
      did_something = did_something + 1;
      (pEVar17->end).next = pEVar2;
      (pEVar2->start).next = pEVar17;
      (pEVar2->end).next = pEVar13;
      (pEVar13->start).next = pEVar2;
      (pEVar13->end).pin = pvVar4;
      (pEVar13->end).next = pEVar15;
      (pEVar15->start).next = pEVar13;
      npulled = npulled + 1;
      __fprintf_chk(stderr,1,"%6d loops, %d pulled   \r",nloops,npulled);
      maybe_pull_1(pLVar11);
      return;
    }
                    // WARNING: Subroutine does not return
    __longjmp_chk(abort_buf,1);
  }
  if (end_arc == (ArcTypePtr)0x0) {
    if (PCB->SilkActive == '\0') {
      pLVar12 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    MoveObject(0x1000,pLVar12,start_line,&start_line->Point2,
               (end_line->Point2).X - (start_line->Point2).X,
               (end_line->Point2).Y - (start_line->Point2).Y);
  }
  else {
    iVar24 = end_arc->Delta;
    iVar22 = iVar24 + end_arc->StartAngle;
    if (iVar24 < 0) {
      iVar22 = iVar22 + -0x5a;
      dVar28 = -(((start_angle + fa) * 180.0) / 3.141592653589793);
    }
    else {
      iVar22 = iVar22 + 0x5a;
      dVar28 = 1.0 - ((start_angle + fa) * 180.0) / 3.141592653589793;
    }
    for (pcb_fa = (int)ROUND(dVar28) - iVar22; 0xb4 < pcb_fa; pcb_fa = pcb_fa + -0x168) {
    }
    for (; pcb_fa < -0xb4; pcb_fa = pcb_fa + 0x168) {
    }
    if (PCB->SilkActive == '\0') {
      pLVar14 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    ChangeArcAngles(pLVar14,end_arc,end_arc->StartAngle,pcb_fa + iVar24);
    fix_arc_extra(end_arc,earc_extra);
    if (PCB->SilkActive == '\0') {
      local_50 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      local_50 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    MoveObject(0x1000,local_50,start_line,&start_line->Point2,
               (earc_extra->end).x - (start_line->Point2).X,
               (earc_extra->end).y - (start_line->Point2).Y);
    if (iVar24 * (pcb_fa + iVar24) < 1) {
      if (PCB->SilkActive == '\0') {
        pLVar12 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar12 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      MoveObject(0x1000,pLVar12,start_line,&start_line->Point2,
                 (earc_extra->start).x - (start_line->Point2).X,
                 (earc_extra->start).y - (start_line->Point2).Y);
      mark_arc_for_deletion(end_arc);
    }
  }
  mark_line_for_deletion(end_line);
  puVar1 = &(start_extra->end).field_0x8;
  *puVar1 = *puVar1 | 8;
  did_something = did_something + 1;
  npulled = npulled + 1;
  __fprintf_chk(stderr,1,"%6d loops, %d pulled   \r",nloops,npulled);
  return;
}



// WARNING: Unknown calling convention

int GlobalPuller(int argc,char **argv,int x,int y)

{
  undefined *puVar1;
  int **ppiVar2;
  ArcTypePtr paVar3;
  byte bVar4;
  char *__s1;
  ElementTypePtr paVar5;
  Cardinal CVar6;
  PCBTypePtr pPVar7;
  int iVar8;
  int iVar9;
  ArcTypePtr arc_1;
  Cardinal sn_2;
  Cardinal sn_1;
  Cardinal sn;
  uint uVar10;
  Extra *pEVar11;
  int i;
  Extra *pEVar12;
  Extra *e_1;
  int *piVar13;
  LayerTypePtr pLVar14;
  DataTypePtr paVar15;
  int **ppiVar16;
  LayerType *pLVar17;
  char cVar18;
  int i_3;
  Extra *pEVar19;
  ArcTypePtr arc_2;
  int **ppiVar20;
  Extra **ppEVar21;
  int i_1;
  int iVar22;
  int **ppiVar23;
  Cardinal n_3;
  LineTypePtr line;
  Extra *e;
  PinTypePtr pin;
  void *pvVar24;
  PinTypePtr via;
  PinTypePtr cl;
  PadTypePtr pad;
  Extra *pEVar25;
  void *pinpad;
  Cardinal n_4;
  ArcTypePtr arc;
  uchar *puVar26;
  Cardinal n_1;
  uint uVar27;
  Cardinal n;
  ElementTypePtr element;
  int i_2;
  LineTypePtr line_1;
  LineTypePtr pLVar28;
  Cardinal n_2;
  ElementTypePtr element_1;
  Extra *pEVar29;
  char *pcVar30;
  Extra *local_c4;
  char local_bd;
  LayerType *local_a8;
  int local_a4;
  LineTypePtr local_a0;
  LayerType *local_84;
  uint local_78;
  int local_74;
  uint local_70;
  int local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  Extra *local_40;
  uint local_38;
  int local_34;
  uint local_30;
  BoxType box;
  
  setbuf(stdout,(char *)0x0);
  nloops = 0;
  npulled = 0;
  if (argc < 1) {
    pcVar30 = "";
    __printf_chk(1,"puller! %s\n",&DAT_0814741b);
    local_70 = 0;
  }
  else {
    pcVar30 = *argv;
    __printf_chk(1,"puller! %s\n",pcVar30);
    __s1 = *argv;
    iVar8 = strcasecmp(__s1,"selected");
    iVar9 = strcasecmp(__s1,"found");
    local_70 = 4;
    if (iVar9 != 0) {
      local_70 = -(uint)(iVar8 == 0) & 0x40;
    }
  }
  __printf_chk(1,"optimizing...\n",pcVar30);
  if (PCB->SilkActive == '\0') {
    pLVar14 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  iVar8 = GetLayerGroupNumberByPointer(pLVar14);
  iVar9 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  current_is_solder = (int)(iVar8 == iVar9);
  if (PCB->SilkActive == '\0') {
    pLVar14 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar14 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  iVar8 = GetLayerGroupNumberByPointer(pLVar14);
  iVar9 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  current_is_component = (int)(iVar8 == iVar9);
  if (PCB->SilkActive == '\0') {
    pLVar17 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  nlines = pLVar17->LineN;
  max_lines = nlines;
  lines = (Extra *)calloc(nlines,0x34);
  if (PCB->SilkActive == '\0') {
    pLVar17 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  narcs = pLVar17->ArcN;
  max_arcs = narcs;
  arcs = (Extra *)calloc(narcs,0x34);
  __printf_chk(1,"pairing...\n");
  cVar18 = PCB->SilkActive;
  if (cVar18 == '\0') {
    paVar15 = PCB->Data;
    pLVar17 = paVar15->Layer + LayerStack[0];
  }
  else {
    paVar15 = PCB->Data;
    pLVar17 = paVar15->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
  }
  iVar8 = pLVar17->ArcN - 1;
  if (iVar8 != -1) {
    iVar9 = pLVar17->ArcN * 0x44;
    while( true ) {
      iVar22 = LayerStack[0];
      if (cVar18 != '\0') {
        iVar22 = (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
      }
      iVar8 = iVar8 + -1;
      paVar3 = (ArcTypePtr)(paVar15->Layer[iVar22].Arc[-1].Flags.t + iVar9 + -0x18);
      fix_arc_extra(paVar3,(Extra *)((int)arcs +
                                    ((int)paVar3 - (int)paVar15->Layer[iVar22].Arc >> 2) *
                                    -0xf0f0f0c));
      if (iVar8 == -1) break;
      cVar18 = PCB->SilkActive;
      paVar15 = PCB->Data;
      iVar9 = iVar9 + -0x44;
    }
    cVar18 = PCB->SilkActive;
    paVar15 = PCB->Data;
  }
  if (cVar18 == '\0') {
    pLVar17 = paVar15->Layer + LayerStack[0];
  }
  else {
    pLVar17 = paVar15->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
  }
  iVar8 = pLVar17->LineN - 1;
  if (iVar8 != -1) {
    iVar9 = pLVar17->LineN * 0x58;
    while( true ) {
      iVar22 = LayerStack[0];
      if (cVar18 != '\0') {
        iVar22 = (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
      }
      puVar26 = paVar15->Layer[iVar22].Line[-1].Flags.t + iVar9 + -0x18;
      if (-1 < *(int *)(puVar26 + 0x2c)) {
        ppEVar21 = (Extra **)
                   (((int)puVar26 - (int)paVar15->Layer[iVar22].Line >> 3) * -0x2e8ba2e4 +
                   (int)lines);
        find_pairs_1(puVar26,ppEVar21,*(int *)(puVar26 + 0x2c),*(int *)(puVar26 + 0x30));
        find_pairs_1(puVar26,ppEVar21 + 6,*(int *)(puVar26 + 0x40),*(int *)(puVar26 + 0x44));
      }
      iVar8 = iVar8 + -1;
      if (iVar8 == -1) break;
      cVar18 = PCB->SilkActive;
      paVar15 = PCB->Data;
      iVar9 = iVar9 + -0x58;
    }
    paVar15 = PCB->Data;
    cVar18 = PCB->SilkActive;
  }
  if (cVar18 == '\0') {
    pLVar17 = paVar15->Layer + LayerStack[0];
  }
  else {
    pLVar17 = paVar15->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
  }
  local_44 = pLVar17->ArcN - 1;
  if (local_44 != -1) {
    iVar8 = pLVar17->ArcN * 0x44;
    while( true ) {
      iVar9 = LayerStack[0];
      if (cVar18 != '\0') {
        iVar9 = (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
      }
      puVar26 = paVar15->Layer[iVar9].Arc[-1].Flags.t + iVar8 + -0x18;
      ppEVar21 = (Extra **)
                 ((int)arcs + ((int)puVar26 - (int)paVar15->Layer[iVar9].Arc >> 2) * -0xf0f0f0c);
      if ((*(byte *)(ppEVar21 + 0xc) & 2) == 0) {
        find_pairs_1(puVar26,ppEVar21,(int)ppEVar21[3],(int)ppEVar21[4]);
        find_pairs_1(puVar26,ppEVar21 + 6,(int)ppEVar21[9],(int)ppEVar21[10]);
      }
      if (local_44 == 0) break;
      local_44 = local_44 + -1;
      cVar18 = PCB->SilkActive;
      paVar15 = PCB->Data;
      iVar8 = iVar8 + -0x44;
    }
    paVar15 = PCB->Data;
  }
  local_48 = paVar15->ElementN - 1;
  if (local_48 != -1) {
    iVar8 = paVar15->ElementN * 300;
    while( true ) {
      local_58 = iVar8 + -300;
      paVar5 = paVar15->Element;
      local_38 = *(uint *)((int)&paVar5[-1].PinN + iVar8);
      if (local_38 != 0) {
        uVar27 = 0;
        do {
          pvVar24 = (void *)(uVar27 * 0x4c + *(int *)((int)&paVar5[-1].Pin + iVar8));
          box.X1 = *(int *)((int)pvVar24 + 0x34) - *(int *)((int)pvVar24 + 0x24) / 2;
          box.Y1 = *(int *)((int)pvVar24 + 0x38) - *(int *)((int)pvVar24 + 0x24) / 2;
          box.X2 = *(int *)((int)pvVar24 + 0x24) / 2 + *(int *)((int)pvVar24 + 0x34);
          box.Y2 = *(int *)((int)pvVar24 + 0x24) / 2 + *(int *)((int)pvVar24 + 0x38);
          if (PCB->SilkActive == '\0') {
            pLVar17 = PCB->Data->Layer + LayerStack[0];
          }
          else {
            pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN
            ;
          }
          r_search(pLVar17->line_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   find_pair_pinline_callback,pvVar24);
          if (PCB->SilkActive == '\0') {
            pLVar17 = PCB->Data->Layer + LayerStack[0];
          }
          else {
            pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN
            ;
          }
          r_search(pLVar17->arc_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   find_pair_pinarc_callback,pvVar24);
          uVar10 = *(uint *)((int)&paVar5[-1].PinN + iVar8);
        } while ((uVar10 != 0) &&
                (uVar27 = (uVar10 + 1 + uVar27) - local_38, local_38 = uVar10, uVar27 < uVar10));
      }
      local_48 = local_48 + -1;
      if (local_48 == -1) break;
      paVar15 = PCB->Data;
      iVar8 = local_58;
    }
    paVar15 = PCB->Data;
  }
  if (paVar15->ViaN != 0) {
    uVar27 = 0;
    local_78 = paVar15->ViaN;
    do {
      cl = paVar15->Via + uVar27;
      box.X1 = cl->X - cl->Thickness / 2;
      box.Y1 = cl->Y - cl->Thickness / 2;
      box.X2 = cl->Thickness / 2 + cl->X;
      box.Y2 = cl->Thickness / 2 + cl->Y;
      if (PCB->SilkActive == '\0') {
        pLVar17 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      r_search(pLVar17->line_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
               find_pair_pinline_callback,cl);
      if (PCB->SilkActive == '\0') {
        pLVar17 = PCB->Data->Layer + LayerStack[0];
      }
      else {
        pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
      }
      r_search(pLVar17->arc_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
               find_pair_pinarc_callback,cl);
      paVar15 = PCB->Data;
      uVar10 = paVar15->ViaN;
    } while ((uVar10 != 0) &&
            (uVar27 = (uVar10 + 1 + uVar27) - local_78, local_78 = uVar10, uVar27 < uVar10));
  }
  local_4c = paVar15->ElementN - 1;
  if (local_4c != -1) {
    iVar8 = paVar15->ElementN * 300;
    do {
      local_5c = iVar8 + -300;
      local_34 = 0;
      local_30 = 0;
      paVar5 = PCB->Data->Element;
      uVar27 = *(uint *)((int)&paVar5[-1].PadN + iVar8);
      uVar10 = uVar27;
      while ((uVar10 != 0 && (local_30 < uVar10))) {
        pvVar24 = (void *)(local_34 + *(int *)((int)&paVar5[-1].Pad + iVar8));
        iVar9 = *(int *)((int)pvVar24 + 0x40);
        if (*(int *)((int)pvVar24 + 0x2c) == iVar9 || *(int *)((int)pvVar24 + 0x2c) < iVar9) {
          iVar9 = *(int *)((int)pvVar24 + 0x2c);
        }
        box.X1 = iVar9 - *(int *)((int)pvVar24 + 0x24) / 2;
        iVar9 = *(int *)((int)pvVar24 + 0x44);
        if (*(int *)((int)pvVar24 + 0x30) == iVar9 || *(int *)((int)pvVar24 + 0x30) < iVar9) {
          iVar9 = *(int *)((int)pvVar24 + 0x30);
        }
        box.Y1 = iVar9 - *(int *)((int)pvVar24 + 0x24) / 2;
        iVar9 = *(int *)((int)pvVar24 + 0x40);
        if (iVar9 <= *(int *)((int)pvVar24 + 0x2c)) {
          iVar9 = *(int *)((int)pvVar24 + 0x2c);
        }
        box.X2 = *(int *)((int)pvVar24 + 0x24) / 2 + iVar9;
        iVar9 = *(int *)((int)pvVar24 + 0x44);
        if (iVar9 <= *(int *)((int)pvVar24 + 0x30)) {
          iVar9 = *(int *)((int)pvVar24 + 0x30);
        }
        box.Y2 = *(int *)((int)pvVar24 + 0x24) / 2 + iVar9;
        if (PCB->SilkActive == '\0') {
          pLVar17 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        r_search(pLVar17->line_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 find_pair_padline_callback,pvVar24);
        if (PCB->SilkActive == '\0') {
          pLVar17 = PCB->Data->Layer + LayerStack[0];
        }
        else {
          pLVar17 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        r_search(pLVar17->arc_tree,&box,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 find_pair_padarc_callback,pvVar24);
        uVar10 = *(uint *)((int)&paVar5[-1].PadN + iVar8);
        if (uVar27 == uVar10) {
          local_30 = local_30 + 1;
          local_34 = local_34 + 0x68;
          uVar10 = uVar27;
        }
      }
      local_4c = local_4c + -1;
      iVar8 = local_5c;
    } while (local_4c != -1);
  }
  iVar8 = nlines;
  if (0 < nlines) {
    iVar9 = 0;
    pEVar11 = lines;
    pEVar12 = lines;
    do {
      while ((pEVar11->start).next != &multi_next) {
        pEVar25 = pEVar11;
        if ((pEVar11->end).next == &multi_next) goto LAB_080bcb51;
LAB_080bcb29:
        iVar9 = iVar9 + 1;
        pEVar11 = pEVar11 + 1;
        pEVar12 = pEVar12 + 1;
        if (iVar8 <= iVar9) goto LAB_080bcb65;
      }
      pEVar19 = (pEVar12->end).next;
      (pEVar11->start).next = (Extra *)0x0;
      pEVar25 = pEVar12;
      if (pEVar19 != &multi_next) goto LAB_080bcb29;
LAB_080bcb51:
      iVar9 = iVar9 + 1;
      pEVar11 = pEVar11 + 1;
      pEVar12 = pEVar12 + 1;
      (pEVar25->end).next = (Extra *)0x0;
    } while (iVar9 < iVar8);
  }
LAB_080bcb65:
  iVar8 = narcs;
  if (0 < narcs) {
    iVar9 = 0;
    pEVar11 = arcs;
    pEVar12 = arcs;
    do {
      while ((pEVar11->start).next != &multi_next) {
        pEVar25 = pEVar11;
        if ((pEVar11->end).next == &multi_next) goto LAB_080bcbb1;
LAB_080bcb89:
        iVar9 = iVar9 + 1;
        pEVar11 = pEVar11 + 1;
        pEVar12 = pEVar12 + 1;
        if (iVar8 <= iVar9) goto LAB_080bcbc5;
      }
      pEVar19 = (pEVar12->end).next;
      (pEVar11->start).next = (Extra *)0x0;
      pEVar25 = pEVar12;
      if (pEVar19 != &multi_next) goto LAB_080bcb89;
LAB_080bcbb1:
      iVar9 = iVar9 + 1;
      pEVar11 = pEVar11 + 1;
      pEVar12 = pEVar12 + 1;
      (pEVar25->end).next = (Extra *)0x0;
    } while (iVar9 < iVar8);
  }
LAB_080bcbc5:
  if (0 < nlines) {
    iVar8 = 0;
    iVar9 = 0;
    do {
      iVar9 = iVar9 + 1;
      pEVar11 = (Extra *)((int)&(lines->start).next + iVar8);
      validate_pair(pEVar11,(End *)pEVar11);
      pEVar11 = (Extra *)((int)&(lines->start).next + iVar8);
      iVar8 = iVar8 + 0x34;
      validate_pair(pEVar11,&pEVar11->end);
    } while (iVar9 < nlines);
  }
  if (0 < narcs) {
    iVar8 = 0;
    iVar9 = 0;
    do {
      iVar9 = iVar9 + 1;
      pEVar11 = (Extra *)((int)&(arcs->start).next + iVar8);
      validate_pair(pEVar11,(End *)pEVar11);
      pEVar11 = (Extra *)((int)&(arcs->start).next + iVar8);
      iVar8 = iVar8 + 0x34;
      validate_pair(pEVar11,&pEVar11->end);
    } while (iVar9 < narcs);
  }
  pPVar7 = PCB;
  iVar8 = nlines;
  if (0 < nlines) {
    iVar22 = 0;
    iVar9 = 0;
    local_c4 = lines;
    pEVar11 = lines;
    do {
      if (pPVar7->SilkActive == '\0') {
        uVar27 = *(uint *)(((pPVar7->Data->Layer[LayerStack[0]].Line)->Flags).t + iVar22 + -4);
      }
      else {
        uVar27 = *(uint *)(((pPVar7->Data->Layer
                             [(uint)(Settings.ShowSolderSide == '\0') + pPVar7->Data->LayerN].Line)
                           ->Flags).t + iVar22 + -4);
      }
      if ((uVar27 & local_70) == local_70) {
        puVar1 = &(local_c4->start).field_0x8;
        *puVar1 = *puVar1 | 8;
        puVar1 = &(pEVar11->end).field_0x8;
        *puVar1 = *puVar1 | 8;
      }
      iVar9 = iVar9 + 1;
      iVar22 = iVar22 + 0x58;
      local_c4 = local_c4 + 1;
      pEVar11 = pEVar11 + 1;
    } while (iVar9 < iVar8);
    local_74 = 0;
    iVar8 = 0;
    local_60 = 0;
    do {
      pPVar7 = PCB;
      ppiVar20 = (int **)((int)&(lines->start).next + iVar8);
      if ((*ppiVar20 != (int *)0x0) && (*ppiVar20 == ppiVar20[6])) {
        ppiVar20[6] = (int *)0x0;
        if (pPVar7->SilkActive == '\0') {
          pLVar17 = pPVar7->Data->Layer + LayerStack[0];
        }
        else {
          pLVar17 = pPVar7->Data->Layer +
                    (uint)(Settings.ShowSolderSide == '\0') + pPVar7->Data->LayerN;
        }
        mark_line_for_deletion((LineTypePtr)((pLVar17->Line->Flags).t + local_74 + -0x18));
        ppiVar20 = (int **)((int)&(lines->start).next + iVar8);
      }
      if ((((*(byte *)(ppiVar20 + 2) & 2) != 0) && ((*(byte *)(ppiVar20 + 8) & 1) != 0)) &&
         (ppiVar20[7] == ppiVar20[1])) {
        *(byte *)(ppiVar20 + 8) = *(byte *)(ppiVar20 + 8) & 0xfe;
        ppiVar23 = (int **)ppiVar20[6];
        if ((int **)ppiVar20[6] == (int **)0x0) {
LAB_080bd3b3:
          ppiVar20 = (int **)((int)&(lines->start).next + iVar8);
        }
        else {
          do {
            ppiVar16 = ppiVar23;
            if ((int **)*ppiVar16 == ppiVar20) {
              *(byte *)(ppiVar16 + 2) = *(byte *)(ppiVar16 + 2) & 0xfe;
              ppiVar2 = ppiVar16 + 6;
              bVar4 = *(byte *)(ppiVar16 + 8);
              ppiVar20 = ppiVar16;
            }
            else {
              *(byte *)(ppiVar16 + 8) = *(byte *)(ppiVar16 + 8) & 0xfe;
              bVar4 = *(byte *)(ppiVar16 + 2);
              ppiVar20 = ppiVar16 + 6;
              ppiVar2 = ppiVar16;
            }
            if ((bVar4 & 1) == 0) break;
            if (ppiVar2[1] != ppiVar20[1]) goto LAB_080bd3b3;
            *(byte *)(ppiVar2 + 2) = bVar4 & 0xfe;
            ppiVar23 = (int **)*ppiVar2;
            ppiVar20 = ppiVar16;
          } while ((int **)*ppiVar2 != (int **)0x0);
          ppiVar20 = (int **)((int)&(lines->start).next + iVar8);
        }
      }
      if ((((*(byte *)(ppiVar20 + 8) & 2) != 0) && ((*(byte *)(ppiVar20 + 2) & 1) != 0)) &&
         (ppiVar20[1] == ppiVar20[7])) {
        *(byte *)(ppiVar20 + 2) = *(byte *)(ppiVar20 + 2) & 0xfe;
        ppiVar23 = (int **)*ppiVar20;
        while (ppiVar16 = ppiVar23, ppiVar16 != (int **)0x0) {
          if ((int **)*ppiVar16 == ppiVar20) {
            ppiVar20 = ppiVar16;
            ppiVar23 = ppiVar16 + 6;
          }
          else {
            ppiVar20 = ppiVar16 + 6;
            ppiVar23 = ppiVar16;
          }
          *(byte *)(ppiVar20 + 2) = *(byte *)(ppiVar20 + 2) & 0xfe;
          if (((*(byte *)(ppiVar23 + 2) & 1) == 0) || (ppiVar23[1] != ppiVar20[1])) break;
          *(byte *)(ppiVar23 + 2) = *(byte *)(ppiVar23 + 2) & 0xfe;
          ppiVar23 = (int **)*ppiVar23;
          ppiVar20 = ppiVar16;
        }
      }
      iVar9 = nlines;
      local_60 = local_60 + 1;
      iVar8 = iVar8 + 0x34;
      local_74 = local_74 + 0x58;
    } while (local_60 < nlines);
    if (0 < nlines) {
      iVar8 = 0;
      pEVar11 = lines;
      pEVar12 = lines;
      do {
        pEVar25 = pEVar11;
        if (((pEVar11->start).field_0x8 & 1) != 0) {
          (pEVar11->start).next = (Extra *)0x0;
          pEVar25 = pEVar12;
        }
        if (((pEVar25->end).field_0x8 & 1) != 0) {
          (pEVar25->end).next = (Extra *)0x0;
        }
        iVar22 = nlines;
        pEVar25 = lines;
        iVar8 = iVar8 + 1;
        pEVar11 = pEVar11 + 1;
        pEVar12 = pEVar12 + 1;
      } while (iVar8 < iVar9);
      if (0 < iVar9) {
        local_68 = 0;
        local_50 = 0;
        local_40 = lines;
        do {
          pEVar11 = (local_40->start).next;
          pEVar12 = local_40;
          if (pEVar11 != (Extra *)0x0) {
            bVar4 = (local_40->end).field_0x8;
            pvVar24 = (local_40->end).pin;
            do {
              pEVar19 = pEVar11;
              pEVar29 = (Extra *)&pEVar11->end;
              if ((pEVar11->start).next != pEVar12) {
                pEVar19 = (Extra *)&pEVar11->end;
                pEVar29 = pEVar11;
              }
              if (pvVar24 == (pEVar19->start).pin) break;
              (pEVar19->start).pin = pvVar24;
              (pEVar19->start).field_0x8 = (pEVar19->start).field_0x8 & 0xfb | bVar4 & 4;
              pEVar19 = (pEVar29->start).next;
              pEVar12 = pEVar11;
              pEVar11 = pEVar19;
            } while (pEVar19 != (Extra *)0x0);
            pEVar12 = (Extra *)((int)&(pEVar25->start).next + local_68);
          }
          pEVar11 = (pEVar12->end).next;
          if (pEVar11 != (Extra *)0x0) {
            bVar4 = (pEVar12->start).field_0x8;
            pvVar24 = (pEVar12->start).pin;
            do {
              pEVar19 = pEVar11;
              pEVar29 = (Extra *)&pEVar11->end;
              if ((pEVar11->start).next != pEVar12) {
                pEVar19 = (Extra *)&pEVar11->end;
                pEVar29 = pEVar11;
              }
              if (pvVar24 == (pEVar19->start).pin) break;
              (pEVar19->start).pin = pvVar24;
              (pEVar19->start).field_0x8 = (pEVar19->start).field_0x8 & 0xfb | bVar4 & 4;
              pEVar19 = (pEVar29->start).next;
              pEVar12 = pEVar11;
              pEVar11 = pEVar19;
            } while (pEVar19 != (Extra *)0x0);
          }
          local_50 = local_50 + 1;
          local_68 = local_68 + 0x34;
          local_40 = local_40 + 1;
        } while (local_50 < iVar22);
      }
    }
  }
  __printf_chk(1,"pulling...\n");
  iVar8 = _setjmp((__jmp_buf_tag *)abort_buf);
  if (iVar8 != 0) {
LAB_080bceed:
    local_bd = PCB->SilkActive;
    if (local_bd == '\0') {
      paVar15 = PCB->Data;
      pLVar17 = paVar15->Layer + LayerStack[0];
    }
    else {
      paVar15 = PCB->Data;
      pLVar17 = paVar15->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
    }
    local_54 = pLVar17->LineN - 1;
    if (-1 < local_54) {
      iVar8 = pLVar17->LineN * 0x58;
      while( true ) {
        if (local_bd == '\0') {
          local_84 = paVar15->Layer + LayerStack[0];
          pLVar28 = paVar15->Layer[LayerStack[0]].Line;
        }
        else {
          iVar9 = (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
          local_84 = paVar15->Layer + iVar9;
          pLVar28 = paVar15->Layer[iVar9].Line;
        }
        pLVar28 = (LineTypePtr)(pLVar28[-1].Flags.t + iVar8 + -0x18);
        if ((*(byte *)((int)lines + ((int)pLVar28 - (int)local_84->Line >> 3) * -0x2e8ba2e4 + 0x30)
            & 2) != 0) {
          if (local_bd == '\0') {
            pLVar14 = paVar15->Layer + LayerStack[0];
          }
          else {
            pLVar14 = paVar15->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
          }
          RemoveLine(pLVar14,pLVar28);
        }
        local_54 = local_54 + -1;
        if (local_54 < 0) break;
        local_bd = PCB->SilkActive;
        paVar15 = PCB->Data;
        iVar8 = iVar8 + -0x58;
      }
      local_bd = PCB->SilkActive;
      paVar15 = PCB->Data;
    }
    if (local_bd == '\0') {
      pLVar17 = paVar15->Layer + LayerStack[0];
    }
    else {
      pLVar17 = paVar15->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
    }
    local_64 = pLVar17->ArcN - 1;
    if (-1 < local_64) {
      iVar8 = pLVar17->ArcN * 0x44;
      while( true ) {
        iVar9 = LayerStack[0];
        if (local_bd != '\0') {
          iVar9 = (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
        }
        paVar3 = (ArcTypePtr)(paVar15->Layer[iVar9].Arc[-1].Flags.t + iVar8 + -0x18);
        if ((*(byte *)((int)arcs +
                      ((int)paVar3 - (int)paVar15->Layer[iVar9].Arc >> 2) * -0xf0f0f0c + 0x30) & 2)
            != 0) {
          if (local_bd == '\0') {
            pLVar14 = paVar15->Layer + LayerStack[0];
          }
          else {
            pLVar14 = paVar15->Layer + (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
          }
          RemoveArc(pLVar14,paVar3);
        }
        local_64 = local_64 + -1;
        if (local_64 < 0) break;
        local_bd = PCB->SilkActive;
        paVar15 = PCB->Data;
        iVar8 = iVar8 + -0x44;
      }
    }
    free(lines);
    free(arcs);
    arcs = (Extra *)0x0;
    lines = (Extra *)0x0;
    max_arcs = 0;
    max_lines = 0;
    narcs = 0;
    nlines = 0;
    IncrementUndoSerialNumber();
    return 0;
  }
  did_something = 1;
LAB_080bce73:
  nloops = nloops + 1;
  __fprintf_chk(stderr,1,"%6d loops, %d pulled   \r",nloops,npulled);
  did_something = 0;
  cVar18 = PCB->SilkActive;
  if (cVar18 == '\0') {
    CVar6 = PCB->Data->Layer[LayerStack[0]].LineN;
  }
  else {
    CVar6 = PCB->Data->Layer[(uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN].LineN;
  }
  iVar8 = CVar6 - 1;
  if (iVar8 != -1) {
    iVar9 = CVar6 * 0x58;
    do {
      if (cVar18 == '\0') {
        local_a8 = PCB->Data->Layer + LayerStack[0];
        pLVar28 = PCB->Data->Layer[LayerStack[0]].Line;
      }
      else {
        paVar15 = PCB->Data;
        iVar22 = (uint)(Settings.ShowSolderSide == '\0') + paVar15->LayerN;
        local_a8 = paVar15->Layer + iVar22;
        pLVar28 = paVar15->Layer[iVar22].Line;
      }
      local_a0 = (LineTypePtr)(pLVar28[-1].Flags.t + iVar9 + -0x18);
      piVar13 = (int *)(((int)local_a0 - (int)local_a8->Line >> 3) * -0x2e8ba2e4 + (int)lines);
      if ((*(byte *)(piVar13 + 0xc) & 2) == 0) {
        if (*piVar13 == 0) {
          local_a4 = piVar13[6];
          if (local_a4 != 0) goto LAB_080bd0c3;
        }
        else {
          local_a4 = piVar13[6];
          if (local_a4 != 0) {
LAB_080bd0c3:
            if ((uint)((local_a4 - (int)lines >> 2) * -0x3b13b13b) < (uint)nlines) {
              maybe_pull_1(local_a0);
              goto LAB_080bd113;
            }
          }
          *(byte *)(piVar13 + 8) = *(byte *)(piVar13 + 8) & 0xf7;
          if ((*piVar13 == 0) ||
             ((uint)nlines <= (uint)((*piVar13 - (int)lines >> 2) * -0x3b13b13b))) {
            *(byte *)(piVar13 + 2) = *(byte *)(piVar13 + 2) & 0xf7;
          }
          else {
            reverse_line(local_a0);
            maybe_pull_1(local_a0);
          }
        }
      }
LAB_080bd113:
      iVar8 = iVar8 + -1;
      if (iVar8 == -1) goto code_r0x080bd122;
      cVar18 = PCB->SilkActive;
      iVar9 = iVar9 + -0x58;
    } while( true );
  }
  goto LAB_080bceed;
code_r0x080bd122:
  if (did_something == 0) goto LAB_080bceed;
  goto LAB_080bce73;
}



// WARNING: Unknown calling convention

int Puller(int argc,char **argv,int Ux,int Uy)

{
  LocationType LVar1;
  LineTypePtr pLVar2;
  ArcTypePtr paVar3;
  int iVar4;
  int new_delta_angle;
  LayerTypePtr pLVar5;
  LayerType *Ptr1;
  double tangent;
  double arc_angle;
  double dVar6;
  double dVar7;
  double local_2c;
  double local_24 [2];
  
  iVar4 = find_pair(Crosshair.X,Crosshair.Y);
  if ((iVar4 == 0) && (iVar4 = find_pair(Ux,Uy), iVar4 == 0)) {
    return 0;
  }
  iVar4 = within((the_line->Point1).X,(the_line->Point1).Y,x,y,the_line->Thickness);
  pLVar2 = the_line;
  if (iVar4 == 0) {
    iVar4 = within((the_line->Point2).X,(the_line->Point2).Y,x,y,the_line->Thickness);
    if (iVar4 == 0) {
      return 1;
    }
    ex = (the_line->Point1).X;
    ey = (the_line->Point1).Y;
  }
  else {
    ex = (the_line->Point2).X;
    ey = (the_line->Point2).Y;
    (the_line->Point2).X = (the_line->Point1).X;
    LVar1 = (pLVar2->Point1).Y;
    (pLVar2->Point1).X = ex;
    (pLVar2->Point1).Y = ey;
    (pLVar2->Point2).Y = LVar1;
  }
  cx = the_arc->X;
  cy = the_arc->Y;
  iVar4 = arc_endpoint_is(the_arc,the_arc->StartAngle,x,y);
  if (iVar4 == 0) {
    iVar4 = arc_endpoint_is(the_arc,the_arc->Delta + the_arc->StartAngle,x,y);
    if (iVar4 == 0) {
      return 1;
    }
  }
  else {
    if (PCB->SilkActive == '\0') {
      pLVar5 = PCB->Data->Layer + LayerStack[0];
    }
    else {
      pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    ChangeArcAngles(pLVar5,the_arc,the_arc->StartAngle + the_arc->Delta,-the_arc->Delta);
  }
  iVar4 = within(cx,cy,ex,ey,the_arc->Width * 2);
  if (iVar4 != 0) {
    return 1;
  }
  atan2((double)(ey - y),(double)(x - ex));
  dVar6 = atan2((double)(ey - cy),(double)(cx - ex));
  dVar6 = (dVar6 * 180.0) / 3.141592653589793;
  iVar4 = the_arc->Width;
  dVar7 = dist(cx,cy,ex,ey);
  dVar7 = acos((double)iVar4 / dVar7);
  dVar7 = (dVar7 * 180.0) / 3.141592653589793;
  if (the_arc->Delta < 1) {
    dVar6 = dVar6 + dVar7;
  }
  else {
    dVar6 = dVar6 - dVar7;
  }
  iVar4 = (int)ROUND(dVar6 - (double)the_arc->StartAngle);
  if (iVar4 < 0xb5) {
    if (iVar4 < -0xb4) {
      iVar4 = iVar4 + 0x168;
    }
  }
  else {
    iVar4 = iVar4 + -0x168;
  }
  if (PCB->SilkActive == '\0') {
    pLVar5 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar5 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  ChangeArcAngles(pLVar5,the_arc,the_arc->StartAngle,iVar4);
  paVar3 = the_arc;
  sincos(((double)(the_arc->Delta + the_arc->StartAngle) * 3.141592653589793) / 180.0,local_24,
         &local_2c);
  x = (int)ROUND(((double)paVar3->X - (double)paVar3->Width * local_2c) + 0.5);
  y = (int)ROUND((double)paVar3->Height * local_24[0] + (double)paVar3->Y + 0.5);
  if (PCB->SilkActive == '\0') {
    Ptr1 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    Ptr1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  MoveObject(0x1000,Ptr1,the_line,&the_line->Point2,x - (the_line->Point2).X,
             y - (the_line->Point2).Y);
  (*gui->invalidate_all)();
  IncrementUndoSerialNumber();
  return 1;
}



// WARNING: Unknown calling convention

void register_puller_action_list(void)

{
  hid_register_actions(puller_action_list,2);
  return;
}



// WARNING: Unknown calling convention

int find_pair_padline_callback(BoxType *b,void *cl)

{
  Extra *e_00;
  int y1;
  int x1;
  int py;
  int px;
  double dVar1;
  double dVar2;
  LayerType *pLVar3;
  int iVar4;
  int iVar5;
  Extra *pEVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  Extra *e;
  double p2_d;
  double t;
  double p1_d;
  double x;
  double dVar10;
  double dVar11;
  
  if (PCB->SilkActive == '\0') {
    pLVar3 = PCB->Data->Layer + LayerStack[0];
  }
  else {
    pLVar3 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  if (*(char *)((int)cl + 0x14) < '\0') {
    if (current_is_solder == 0) {
      return 0;
    }
  }
  else if (current_is_component == 0) {
    return 0;
  }
  e_00 = (Extra *)((int)lines + ((int)b - (int)pLVar3->Line >> 3) * -0x2e8ba2e4);
  iVar4 = check_point_in_pad((PadTypePtr)cl,b[2].Y2,b[3].X1,(End *)e_00);
  iVar5 = check_point_in_pad((PadTypePtr)cl,b[4].X1,b[4].Y1,&e_00->end);
  if (iVar5 + iVar4 == 0) {
    iVar4 = b[4].X1;
    iVar5 = b[4].Y1;
    y1 = b[3].X1;
    iVar9 = *(int *)((int)cl + 0x44);
    x1 = b[2].Y2;
    py = *(int *)((int)cl + 0x30);
    iVar8 = *(int *)((int)cl + 0x40);
    px = *(int *)((int)cl + 0x2c);
    dVar1 = (double)(y1 - iVar5) * (double)(px - iVar8) -
            (double)(py - iVar9) * (double)(x1 - iVar4);
    if (dVar1 != 0.0) {
      iVar7 = iVar8;
      if (px <= iVar8) {
        iVar7 = px;
      }
      dVar2 = (double)x1 * (double)iVar5 - (double)y1 * (double)iVar4;
      dVar11 = (double)px * (double)iVar9 - (double)py * (double)iVar8;
      dVar10 = ((double)(x1 - iVar4) * dVar11 - (double)(px - iVar8) * dVar2) / dVar1;
      if ((double)iVar7 <= dVar10) {
        if (iVar8 <= px) {
          iVar8 = px;
        }
        if (dVar10 <= (double)iVar8) {
          iVar8 = iVar9;
          if (py <= iVar9) {
            iVar8 = py;
          }
          dVar1 = (dVar11 * (double)(y1 - iVar5) - dVar2 * (double)(py - iVar9)) / dVar1;
          if ((double)iVar8 <= dVar1) {
            if (iVar9 <= py) {
              iVar9 = py;
            }
            if (dVar1 <= (double)iVar9) {
              iVar9 = iVar4;
              if (x1 <= iVar4) {
                iVar9 = x1;
              }
              if ((double)iVar9 <= dVar10) {
                iVar9 = iVar4;
                if (iVar4 <= x1) {
                  iVar9 = x1;
                }
                if (dVar10 <= (double)iVar9) {
                  iVar9 = iVar5;
                  if (y1 <= iVar5) {
                    iVar9 = y1;
                  }
                  if ((double)iVar9 <= dVar1) {
                    iVar9 = iVar5;
                    if (iVar5 <= y1) {
                      iVar9 = y1;
                    }
                    if (dVar1 <= (double)iVar9) {
                      dist_lsp(x1,y1,iVar4,iVar5,px,py);
                      dist_lsp(b[2].Y2,b[3].X1,b[4].X1,b[4].Y1,*(int *)((int)cl + 0x40),
                               *(int *)((int)cl + 0x44));
                      goto LAB_080bdd1c;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    dVar1 = (double)((*(int *)((int)cl + 0x24) + 1) / 2);
    dVar10 = dist_lsp(x1,y1,iVar4,iVar5,px,py);
    dVar11 = dist_lsp(b[2].Y2,b[3].X1,b[4].X1,b[4].Y1,*(int *)((int)cl + 0x40),
                      *(int *)((int)cl + 0x44));
    if ((dVar10 < dVar1) || (dVar11 < dVar1)) {
LAB_080bdd1c:
      pEVar6 = (e_00->start).next;
      if (pEVar6 != (Extra *)0x0) {
        if (e_00 == (pEVar6->start).next) {
          (pEVar6->start).next = &multi_next;
          pEVar6 = (e_00->start).next;
        }
        if (e_00 == (pEVar6->end).next) {
          (pEVar6->end).next = &multi_next;
        }
      }
      pEVar6 = (e_00->end).next;
      (e_00->start).next = &multi_next;
      if (pEVar6 != (Extra *)0x0) {
        if (e_00 == (pEVar6->start).next) {
          (pEVar6->start).next = &multi_next;
        }
        if (e_00 == (pEVar6->end).next) {
          (pEVar6->end).next = &multi_next;
        }
      }
      (e_00->end).next = &multi_next;
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void fab_line(int x1,int y1,int x2,int y2)

{
  (*gui->draw_line)(Output.fgGC,x1,y1,x2,y2);
  return;
}



// WARNING: Unknown calling convention

void fab_circle(int x,int y,int r)

{
  (*gui->draw_arc)(Output.fgGC,x,y,r,r,0,0xb4);
  (*gui->draw_arc)(Output.fgGC,x,y,r,r,0xb4,0xb4);
  return;
}



// WARNING: Unknown calling convention

void drill_sym(int idx,int x,int y)

{
  int iVar1;
  int size;
  int iVar2;
  int iVar3;
  int s2;
  int i;
  int iVar4;
  int local_24;
  int local_20;
  
  iVar2 = idx / 5;
  iVar4 = iVar2 + 1;
  iVar3 = iVar4 * 0x640;
  switch(idx % 5) {
  case 0:
    fab_line(x,y,x,iVar3 + y);
    iVar3 = y - (iVar3 >> 1);
    iVar1 = iVar4 * 0x5140 >> 0x1f;
    iVar4 = (iVar4 * 0x5140) / 0xf + iVar1;
    fab_line(x,y,(iVar4 - iVar1) + x,iVar3);
    fab_line(x,y,(iVar1 - iVar4) + x,iVar3);
    if (0 < iVar2) {
      iVar3 = 1;
      iVar4 = 0x640;
      do {
        iVar3 = iVar3 + 1;
        fab_circle(x,y,iVar4);
        iVar4 = iVar4 + 0x640;
      } while (iVar3 <= iVar2);
      return;
    }
    break;
  case 1:
    fab_line(x,y + iVar4 * -0x640,x,iVar3 + y);
    fab_line(x + iVar4 * -0x640,y,iVar3 + x,y);
    if (0 < iVar2) {
      local_20 = x + 0x640;
      local_24 = 1;
      iVar4 = y;
      do {
        iVar4 = iVar4 + -0x640;
        x = x + -0x640;
        y = y + 0x640;
        fab_line(x,iVar4,local_20,iVar4);
        fab_line(x,iVar4,x,y);
        fab_line(x,y,local_20,y);
        fab_line(local_20,iVar4,local_20,y);
        local_24 = local_24 + 1;
        local_20 = local_20 + 0x640;
      } while (local_24 <= iVar2);
      return;
    }
    break;
  case 2:
    iVar4 = iVar4 * 0x12c0;
    if (iVar4 < 0) {
      iVar4 = iVar4 + 3;
    }
    iVar4 = iVar4 >> 2;
    iVar3 = -iVar4 + y;
    iVar1 = -iVar4 + x;
    fab_line(iVar1,iVar3,x + iVar4,iVar4 + y);
    fab_line(iVar1,iVar4 + y,x + iVar4,iVar3);
    if (0 < iVar2) {
      local_20 = x + 0x640;
      local_24 = 1;
      iVar4 = y;
      do {
        iVar4 = iVar4 + -0x640;
        x = x + -0x640;
        y = y + 0x640;
        fab_line(x,iVar4,local_20,iVar4);
        fab_line(x,iVar4,x,y);
        fab_line(x,y,local_20,y);
        fab_line(local_20,iVar4,local_20,y);
        local_24 = local_24 + 1;
        local_20 = local_20 + 0x640;
      } while (local_24 <= iVar2);
      return;
    }
    break;
  case 3:
    iVar4 = 0;
    if (-1 < iVar2) {
      iVar3 = 800;
      do {
        iVar4 = iVar4 + 1;
        fab_circle(x,y,iVar3);
        iVar3 = iVar3 + 0x640;
      } while (iVar4 <= iVar2);
      return;
    }
    break;
  case 4:
    if (0 < iVar4) {
      local_20 = x + 0x640;
      local_24 = 1;
      iVar2 = y;
      do {
        x = x + -0x640;
        iVar2 = iVar2 + -0x640;
        y = y + 0x640;
        fab_line(x,iVar2,local_20,iVar2);
        fab_line(x,iVar2,x,y);
        fab_line(x,y,local_20,y);
        fab_line(local_20,iVar2,local_20,y);
        local_24 = local_24 + 1;
        local_20 = local_20 + 0x640;
      } while (local_24 <= iVar4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int PrintFab_overhang(void)

{
  DrillInfoTypePtr paVar1;
  DrillInfoTypePtr AllDrills;
  Cardinal *pCVar2;
  int ds;
  int iVar3;
  int n;
  
  paVar1 = GetDrillInfo(PCB->Data);
  n = paVar1->DrillN - 1;
  if (-1 < n) {
    pCVar2 = &paVar1->Drill[paVar1->DrillN - 1].ViaCount;
    iVar3 = 0;
    do {
      iVar3 = (iVar3 + (uint)(pCVar2[1] < *pCVar2 + pCVar2[-1]) + 1) - (uint)(pCVar2[1] == 0);
      pCVar2 = pCVar2 + -10;
      n = n + -1;
    } while (-1 < n);
    if (3 < iVar3) {
      return iVar3 * 15000 + 30000;
    }
  }
  return 90000;
}



// WARNING: Unknown calling convention

void text_at(int x,int y,int align,char *fmt,...)

{
  int iVar1;
  PCBTypePtr pPVar2;
  int iVar3;
  int iVar4;
  int w;
  char *pcVar5;
  int in_GS_OFFSET;
  char tmp [512];
  TextType t;
  
  pPVar2 = PCB;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  t.TextString = tmp;
  __vsprintf_chk(t.TextString,1,0x200,fmt,&stack0x00000014);
  t.Direction = '\0';
  t.Scale = 0x96;
  MakeFlags(0);
  if (tmp[0] == '\0') {
    iVar3 = 0;
    iVar4 = 0;
  }
  else {
    pcVar5 = tmp;
    iVar4 = 0;
    do {
      pcVar5 = pcVar5 + 1;
      iVar4 = iVar4 + (pPVar2->Font).Symbol[tmp[0]].Delta + (pPVar2->Font).Symbol[tmp[0]].Width;
      tmp[0] = *pcVar5;
    } while (tmp[0] != '\0');
    iVar4 = (iVar4 * 0x96) / 100;
    iVar3 = -((int)((align & 3U) * iVar4) / 2);
  }
  t.Y = y;
  t.X = 0;
  if (-1 < iVar3 + x) {
    t.X = iVar3 + x;
  }
  DrawTextLowLevel(&t,0);
  if ((align & 8U) != 0) {
    iVar3 = t.Y + 1000 + ((pPVar2->Font).MaxHeight * 0x96) / 100;
    fab_line(t.X,iVar3,iVar4 + t.X,iVar3);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void PrintFab(void)

{
  bool bVar1;
  int iVar2;
  DataTypePtr paVar3;
  Cardinal CVar4;
  LineTypePtr pLVar5;
  ArcTypePtr paVar6;
  DrillInfoTypePtr d;
  Cardinal *pCVar7;
  int unplated_sym;
  time_t currenttime;
  tm *__tp;
  int iVar8;
  LineTypePtr line;
  ArcTypePtr arc;
  char *pcVar9;
  int n;
  int ds;
  int iVar10;
  DrillTypePtr drill;
  int *piVar11;
  DataTypePtr paVar12;
  Cardinal n_1;
  Cardinal n_2;
  Cardinal n_3;
  int i;
  uint uVar13;
  int plated_sym;
  int iVar14;
  int in_GS_OFFSET;
  int local_98;
  int local_94;
  int local_8c;
  int local_88;
  int local_84;
  int local_80;
  time_t local_64;
  char utcTime [64];
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags(0);
  d = GetDrillInfo(PCB->Data);
  RoundDrillInfo(d,100);
  local_84 = -75000;
  local_8c = 0;
  n = d->DrillN - 1;
  if (-1 < n) {
    local_8c = 0;
    pCVar7 = &d->Drill[d->DrillN - 1].ViaCount;
    do {
      local_8c = (local_8c + (uint)(pCVar7[1] < *pCVar7 + pCVar7[-1]) + 1) - (uint)(pCVar7[1] == 0);
      pCVar7 = pCVar7 + -10;
      n = n + -1;
    } while (-1 < n);
    iVar10 = -30000;
    local_84 = -15000;
    if (3 < local_8c) goto LAB_080be586;
    local_84 = local_8c * 15000 + -75000;
  }
  iVar10 = local_84 + -15000;
LAB_080be586:
  (*gui->set_line_width)(Output.fgGC,800);
  local_88 = 0;
  local_98 = d->DrillN - 1;
  if (-1 < local_98) {
    iVar14 = local_84;
    iVar10 = d->DrillN * 0x28;
    do {
      local_84 = iVar14;
      local_94 = iVar10 + -0x28;
      iVar14 = -1;
      piVar11 = (int *)((int)&d->Drill[-1].DrillSize + iVar10);
      if ((uint)piVar11[5] < (uint)(piVar11[4] + piVar11[3])) {
        iVar14 = local_8c + -1;
        local_8c = iVar14;
      }
      bVar1 = false;
      local_80 = -1;
      if (piVar11[5] != 0) {
        local_8c = local_8c + -1;
        bVar1 = local_8c != -1 && iVar14 != -1;
        local_80 = local_8c;
      }
      (*gui->set_color)(Output.fgGC,PCB->PinColor);
      if (piVar11[6] != 0) {
        uVar13 = 0;
        do {
          iVar10 = *(int *)(piVar11[8] + uVar13 * 4);
          iVar8 = local_80;
          if ((*(byte *)(iVar10 + 0x14) & 8) == 0) {
            iVar8 = iVar14;
          }
          uVar13 = uVar13 + 1;
          drill_sym(iVar8,*(int *)(iVar10 + 0x34),*(int *)(iVar10 + 0x38));
        } while (uVar13 <= (uint)piVar11[6] && piVar11[6] != uVar13);
      }
      if (iVar14 == -1) {
        if (local_80 != -1) goto LAB_080be713;
      }
      else {
        drill_sym(iVar14,15000,local_84 + 0xea6);
        text_at(0x20f58,local_84,200,"YES");
        text_at(98000,local_84,200,"%d",(piVar11[4] + piVar11[3]) - piVar11[5]);
        if (local_80 != -1) {
          local_84 = local_84 + -15000;
LAB_080be713:
          drill_sym(local_80,15000,local_84 + 0xea6);
          text_at(140000,local_84,200,"NO");
          text_at(98000,local_84,200,"%d",piVar11[5]);
        }
      }
      (*gui->set_color)(Output.fgGC,PCB->ElementColor);
      text_at(45000,local_84,200,"%0.3f",(double)((float)*piVar11 / 100000.0 + 0.0004));
      if (bVar1) {
        text_at(45000,local_84 + 15000,200,"%0.3f",
                (double)*piVar11 / 100000.0 + 0.0003999999898951501);
      }
      local_88 = local_88 + piVar11[4] + piVar11[3];
      local_98 = local_98 + -1;
      iVar14 = local_84 + -15000;
      iVar10 = local_94;
    } while (-1 < local_98);
    iVar10 = local_84 + -30000;
    local_84 = local_84 + -15000;
  }
  iVar14 = 0;
  (*gui->set_color)(Output.fgGC,PCB->ElementColor);
  text_at(0,local_84,900,"Symbol");
  text_at(41000,local_84,900,"Diam. (Inch)");
  text_at(95000,local_84,900,"Count");
  text_at(130000,local_84,900,"Plated?");
  text_at(0,iVar10,0,"There are %d different drill sizes used in this layout, %d holes total",
          d->DrillN,local_88);
  local_64 = time((time_t *)0x0);
  __tp = gmtime(&local_64);
  strftime(utcTime,0x40,"%c UTC",__tp);
  paVar3 = PCB->Data;
  iVar10 = paVar3->LayerN;
  paVar12 = paVar3;
  if (0 < iVar10) {
    do {
      pcVar9 = paVar12->Layer[0].Name;
      if (((pcVar9 != (char *)0x0) &&
          ((paVar12->Layer[0].LineN != 0 || (paVar12->Layer[0].ArcN != 0)))) &&
         ((iVar8 = strcasecmp("route",pcVar9), iVar8 == 0 ||
          (iVar8 = strcasecmp("outline",pcVar9), iVar8 == 0)))) goto LAB_080bebdf;
      iVar14 = iVar14 + 1;
      paVar12 = (DataTypePtr)&paVar12->Layer[0].ArcN;
    } while (iVar14 < iVar10);
  }
  if (iVar14 == iVar10) {
    (*gui->set_line_width)(Output.fgGC,1000);
    (*gui->draw_line)(Output.fgGC,0,0,PCB->MaxWidth,0);
    (*gui->draw_line)(Output.fgGC,0,0,0,PCB->MaxHeight);
    (*gui->draw_line)(Output.fgGC,PCB->MaxWidth,0,PCB->MaxWidth,PCB->MaxHeight);
    (*gui->draw_line)(Output.fgGC,0,PCB->MaxHeight,PCB->MaxWidth,PCB->MaxHeight);
    (*gui->set_line_width)(Output.fgGC,800);
    text_at(200000,-15000,0,"Maximum Dimensions: %d mils wide, %d mils high",PCB->MaxWidth / 100,
            PCB->MaxHeight / 100);
    text_at(PCB->MaxWidth / 2,PCB->MaxHeight + 2000,1,
            "Board outline is the centerline of this 10 mil rectangle - 0,0 to %d,%d mils",
            PCB->MaxWidth / 100,PCB->MaxHeight / 100);
  }
  else {
LAB_080bebdf:
    (*gui->set_line_width)(Output.fgGC,1000);
    CVar4 = paVar3->Layer[iVar14].LineN;
    iVar10 = CVar4 - 1;
    if (iVar10 != -1) {
      iVar8 = CVar4 * 0x58;
      do {
        pLVar5 = paVar3->Layer[iVar14].Line;
        iVar10 = iVar10 + -1;
        (*gui->draw_line)(Output.fgGC,
                          *(int *)((int)&((PointType *)(&pLVar5[-1].Flags + 2))->Y + iVar8 + -4),
                          *(int *)((int)&((PointType *)(&pLVar5[-1].Flags + 2))->Y + iVar8),
                          *(int *)((int)(&pLVar5[-1].Flags + 3) + iVar8 + 8),
                          *(int *)((int)(&pLVar5[-1].Flags + 4) + iVar8));
        iVar8 = iVar8 + -0x58;
      } while (iVar10 != -1);
    }
    CVar4 = paVar3->Layer[iVar14].ArcN;
    iVar10 = CVar4 - 1;
    if (iVar10 != -1) {
      iVar8 = CVar4 * 0x44;
      do {
        paVar6 = paVar3->Layer[iVar14].Arc;
        iVar10 = iVar10 + -1;
        (*gui->draw_arc)(Output.fgGC,*(int *)((int)(&paVar6[-1].Flags + 2) + iVar8 + 8),
                         *(int *)((int)(&paVar6[-1].Flags + 3) + iVar8),
                         *(int *)((int)(&paVar6[-1].Flags + 2) + iVar8),
                         *(int *)((int)(&paVar6[-1].Flags + 2) + iVar8 + 4),
                         *(int *)((int)(&paVar6[-1].Flags + 3) + iVar8 + 4),
                         *(int *)((int)(&paVar6[-1].Flags + 3) + iVar8 + 8));
        iVar8 = iVar8 + -0x44;
      } while (iVar10 != -1);
    }
    CVar4 = paVar3->Layer[iVar14].TextN;
    iVar10 = CVar4 - 1;
    if (iVar10 != -1) {
      iVar8 = CVar4 * 0x3c;
      do {
        iVar10 = iVar10 + -1;
        DrawTextLowLevel((TextTypePtr)(paVar3->Layer[iVar14].Text[-1].Flags.t + iVar8 + -0x18),0);
        iVar8 = iVar8 + -0x3c;
      } while (iVar10 != -1);
    }
    (*gui->set_line_width)(Output.fgGC,800);
    text_at(PCB->MaxWidth / 2,PCB->MaxHeight + 2000,1,"Board outline is the centerline of this path"
           );
  }
  text_at(200000,-30000,0,"Date: %s",utcTime);
  pcVar9 = pcb_author();
  text_at(200000,-45000,0,"Author: %s",pcVar9);
  pcVar9 = PCB->Name;
  if ((pcVar9 == (char *)0x0) || (*pcVar9 == '\0')) {
    pcVar9 = "(unknown)";
  }
  text_at(200000,-60000,0,"Title: %s - Fabrication Drawing",pcVar9);
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

char * ConnectionName(int type,void *ptr1,void *ptr2)

{
  char *pcVar1;
  char *num;
  
  if (type == 0x100) {
    num = *(char **)((int)ptr2 + 0x40);
  }
  else {
    if (type != 0x200) {
      return (char *)0x0;
    }
    num = *(char **)((int)ptr2 + 0x5c);
  }
  pcVar1 = *(char **)((int)ptr1 + 0x94);
  if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
    pcVar1 = "(unknown)";
  }
  __strcpy_chk(ConnectionName::name,pcVar1,0x100);
  __strcat_chk(ConnectionName::name,&DAT_08156000,0x100);
  if ((num == (char *)0x0) || (*num == '\0')) {
    num = "(unknown)";
  }
  __strcat_chk(ConnectionName::name,num,0x100);
  return ConnectionName::name;
}



// WARNING: Unknown calling convention

RatTypePtr AddNet(void)

{
  int iVar1;
  Cardinal CVar2;
  FlagType Flags;
  PCBTypePtr pPVar3;
  int iVar4;
  int found;
  char *pcVar5;
  LibraryMenuTypePtr paVar6;
  LibraryMenuTypePtr menu;
  LibraryMenuTypePtr paVar7;
  LibraryEntryTypePtr paVar8;
  char *pcVar9;
  RatTypePtr paVar10;
  int iVar11;
  LibraryEntryTypePtr entry;
  Cardinal l;
  int in_GS_OFFSET;
  Cardinal local_158;
  Cardinal local_154;
  void *ptr3;
  void *local_148;
  void *local_144;
  char name1 [256];
  char ratname [20];
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((Crosshair.AttachedLine.Point1.X == Crosshair.AttachedLine.Point2.X) &&
     (paVar10 = (RatTypePtr)0x0, Crosshair.AttachedLine.Point1.Y == Crosshair.AttachedLine.Point2.Y)
     ) goto LAB_080bf175;
  iVar4 = SearchObjectByLocation
                    (0x300,&local_144,&local_148,&ptr3,Crosshair.AttachedLine.Point1.X,
                     Crosshair.AttachedLine.Point1.Y,5);
  if (iVar4 != 0) {
    if ((*(char **)((int)local_144 + 0x94) == (char *)0x0) ||
       (**(char **)((int)local_144 + 0x94) == '\0')) {
      Message("You must name the starting element first\n");
      paVar10 = (RatTypePtr)0x0;
      goto LAB_080bf175;
    }
    if (*(char *)((int)local_148 + 0x14) < '\0') {
      local_154 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    }
    else {
      local_154 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
    }
    pcVar5 = ConnectionName(iVar4,local_144,local_148);
    __strcpy_chk(name1,pcVar5,0x100);
    iVar4 = SearchObjectByLocation
                      (0x300,&local_144,&local_148,&ptr3,Crosshair.AttachedLine.Point2.X,
                       Crosshair.AttachedLine.Point2.Y,5);
    if (iVar4 != 0) {
      if ((*(char **)((int)local_144 + 0x94) == (char *)0x0) ||
         (**(char **)((int)local_144 + 0x94) == '\0')) {
        Message("You must name the ending element first\n");
        paVar10 = (RatTypePtr)0x0;
      }
      else {
        if (*(char *)((int)local_148 + 0x14) < '\0') {
          local_158 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
        }
        else {
          local_158 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
        }
        pcVar5 = ConnectionName(iVar4,local_144,local_148);
        paVar6 = netnode_to_netname(name1);
        if (paVar6 == (LibraryMenuTypePtr)0x0) {
          paVar6 = netnode_to_netname(pcVar5);
          if (paVar6 == (LibraryMenuTypePtr)0x0) {
            AddNet::ratDrawn = AddNet::ratDrawn + 1;
            __sprintf_chk(ratname,1,0x14,"  ratDrawn%i",AddNet::ratDrawn);
            while( true ) {
              pPVar3 = PCB;
              CVar2 = (PCB->NetlistLib).MenuN;
              iVar4 = CVar2 - 1;
              if (iVar4 == -1) break;
              paVar6 = (PCB->NetlistLib).Menu + (CVar2 - 1);
              while ((paVar6->Name == (char *)0x0 ||
                     (iVar11 = strcmp(paVar6->Name,ratname), iVar11 != 0))) {
                iVar4 = iVar4 + -1;
                paVar6 = paVar6 + -1;
                if (iVar4 == -1) goto LAB_080bf314;
              }
              AddNet::ratDrawn = AddNet::ratDrawn + 1;
              __sprintf_chk(ratname,1,0x14,"  ratDrawn%i",AddNet::ratDrawn);
            }
LAB_080bf314:
            paVar6 = GetLibraryMenuMemory(&pPVar3->NetlistLib);
            pcVar9 = MyStrdup(ratname,"AddNet");
            paVar6->Name = pcVar9;
            paVar8 = GetLibraryEntryMemory(paVar6);
            pcVar9 = MyStrdup(name1,"AddNet");
            paVar8->ListEntry = pcVar9;
            paVar8 = GetLibraryEntryMemory(paVar6);
            pcVar5 = MyStrdup(pcVar5,"AddNet");
            paVar8->ListEntry = pcVar5;
            paVar6->flag = '\x01';
          }
          else {
            paVar8 = GetLibraryEntryMemory(paVar6);
            pcVar5 = MyStrdup(name1,"AddNet");
            paVar8->ListEntry = pcVar5;
            netnode_to_netname(name1);
          }
        }
        else {
          paVar7 = netnode_to_netname(pcVar5);
          if (paVar7 != (LibraryMenuTypePtr)0x0) {
            Message("Both connections already in netlist - cannot merge nets\n");
            paVar10 = (RatTypePtr)0x0;
            goto LAB_080bf175;
          }
          paVar8 = GetLibraryEntryMemory(paVar6);
          pcVar9 = MyStrdup(pcVar5,"AddNet");
          paVar8->ListEntry = pcVar9;
          netnode_to_netname(pcVar5);
        }
        hid_action("NetlistChanged");
        MakeFlags(0);
        Flags.t._0_4_ = local_28;
        Flags.f = local_2c;
        Flags.t._4_4_ = local_24;
        paVar10 = CreateNewRat(PCB->Data,Crosshair.AttachedLine.Point1.X,
                               Crosshair.AttachedLine.Point1.Y,Crosshair.AttachedLine.Point2.X,
                               Crosshair.AttachedLine.Point2.Y,local_154,local_158,
                               Settings.RatThickness,Flags);
      }
      goto LAB_080bf175;
    }
  }
  Message("No pad/pin under rat line\n");
  paVar10 = (RatTypePtr)0x0;
LAB_080bf175:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return paVar10;
}



// WARNING: Unknown calling convention

void TransferNet(NetListTypePtr Netl,NetTypePtr SourceNet,NetTypePtr DestNet)

{
  int iVar1;
  ConnectionTypePtr paVar2;
  ConnectionTypePtr conn;
  NetTypePtr paVar3;
  Cardinal CVar4;
  int iVar5;
  ConnectionTypePtr connection;
  LocationType *pLVar6;
  Cardinal n;
  
  iVar5 = SourceNet->ConnectionN - 1;
  if (iVar5 != -1) {
    iVar1 = SourceNet->ConnectionN * 0x1c;
    do {
      iVar5 = iVar5 + -1;
      pLVar6 = (LocationType *)((int)&SourceNet->Connection[-1].X + iVar1);
      paVar2 = GetConnectionMemory(DestNet);
      paVar2->X = *pLVar6;
      paVar2->Y = pLVar6[1];
      paVar2->type = pLVar6[2];
      paVar2->ptr1 = (void *)pLVar6[3];
      paVar2->ptr2 = (void *)pLVar6[4];
      paVar2->group = pLVar6[5];
      paVar2->menu = (LibraryMenuType *)pLVar6[6];
      iVar1 = iVar1 + -0x1c;
    } while (iVar5 != -1);
  }
  DestNet->Style = SourceNet->Style;
  FreeNetMemory(SourceNet);
  paVar3 = Netl->Net;
  CVar4 = Netl->NetN - 1;
  Netl->NetN = CVar4;
  SourceNet->ConnectionN = paVar3[CVar4].ConnectionN;
  SourceNet->ConnectionMax = paVar3[CVar4].ConnectionMax;
  SourceNet->Connection = paVar3[CVar4].Connection;
  SourceNet->Style = paVar3[CVar4].Style;
  paVar3 = Netl->Net + Netl->NetN;
  paVar3->ConnectionN = 0;
  paVar3->ConnectionMax = 0;
  paVar3->Connection = (ConnectionTypePtr)0x0;
  paVar3->Style = (RouteStyleTypePtr)0x0;
  return;
}



// WARNING: Unknown calling convention

Boolean GatherSubnets(NetListTypePtr Netl,Boolean NoWarn,Boolean AndRats)

{
  uint *puVar1;
  NetTypePtr paVar2;
  void *pvVar3;
  LocationType LVar4;
  uint uVar5;
  LibraryMenuType *pLVar6;
  ElementTypePtr paVar7;
  NetTypePtr DestNet;
  ConnectionTypePtr paVar8;
  Cardinal CVar9;
  PCBTypePtr pPVar10;
  PointerListTypePtr list;
  LibraryMenuType **ppLVar11;
  void **menu;
  Cardinal n_6;
  Cardinal n_4;
  int iVar12;
  void **ppvVar13;
  char *pcVar14;
  LayerTypePtr layer_1;
  ConnectionTypePtr conn;
  LayerTypePtr pLVar15;
  DataTypePtr paVar16;
  Boolean warn;
  byte bVar17;
  NetTypePtr b;
  LayerTypePtr layer;
  char *ptr2;
  Cardinal m;
  uint uVar18;
  Cardinal n;
  LineTypePtr line;
  uchar *puVar19;
  uint uVar20;
  Cardinal n_2;
  Cardinal n_3;
  Cardinal n_5;
  uint uVar21;
  PadTypePtr pad;
  PinTypePtr via;
  Cardinal n_1;
  int iVar22;
  PinTypePtr paVar23;
  Cardinal sn;
  NetTypePtr a;
  int iVar24;
  PolygonTypePtr polygon;
  byte local_49;
  int local_38;
  int local_30;
  uint local_28;
  uint local_24;
  uint local_20;
  
  local_49 = 0;
  uVar21 = Netl->NetN;
  uVar20 = 0;
joined_r0x080bf4d2:
  if ((uVar21 == 0) || (uVar21 <= uVar20)) {
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    return local_49;
  }
  uVar18 = uVar20 + 1;
  DestNet = Netl->Net + uVar20;
  ResetFoundPinsViasAndPads('\0');
  ResetFoundLinesAndPolygons('\0');
  paVar8 = DestNet->Connection;
  ptr2 = (char *)paVar8->ptr2;
  RatFindHook(paVar8->type,paVar8->ptr1,ptr2,ptr2,'\0',AndRats);
  puVar1 = (uint *)((int)DestNet->Connection->ptr2 + 0x14);
  *puVar1 = *puVar1 & 0xffffefff;
  uVar21 = uVar18;
  if (uVar18 < Netl->NetN) {
    do {
      while( true ) {
        paVar2 = Netl->Net;
        pvVar3 = (paVar2[uVar21].Connection)->ptr2;
        uVar20 = *(uint *)((int)pvVar3 + 0x14);
        if ((uVar20 & 0x1000) == 0) break;
        *(uint *)((int)pvVar3 + 0x14) = uVar20 & 0xffffefff;
        TransferNet(Netl,paVar2 + uVar21,DestNet);
        if (Netl->NetN < uVar21 || Netl->NetN == uVar21) goto LAB_080bf596;
      }
      uVar21 = uVar21 + 1;
    } while (uVar21 <= Netl->NetN && Netl->NetN != uVar21);
  }
LAB_080bf596:
  paVar16 = PCB->Data;
  pLVar15 = paVar16->Layer;
  pPVar10 = PCB;
  if (paVar16->LayerN != -2) {
    local_24 = 0;
    do {
      iVar22 = pLVar15->LineN - 1;
      if (iVar22 != -1) {
        iVar24 = pLVar15->LineN * 0x58 + -0x58;
        do {
          while ((puVar19 = (pLVar15->Line->Flags).t + iVar24 + -0x18, (puVar19[0x15] & 0x10) == 0
                 || ((*(int *)(puVar19 + 0x2c) != *(int *)(puVar19 + 0x40) &&
                     (*(int *)(puVar19 + 0x30) != *(int *)(puVar19 + 0x44)))))) {
            iVar22 = iVar22 + -1;
            iVar24 = iVar24 + -0x58;
            pPVar10 = PCB;
            if (iVar22 == -1) goto LAB_080bf695;
          }
          iVar22 = iVar22 + -1;
          iVar24 = iVar24 + -0x58;
          paVar8 = GetConnectionMemory(DestNet);
          LVar4 = *(LocationType *)(puVar19 + 0x2c);
          paVar8->ptr1 = pLVar15;
          paVar8->type = 4;
          paVar8->ptr2 = puVar19;
          paVar8->X = LVar4;
          paVar8->Y = *(LocationType *)(puVar19 + 0x30);
          CVar9 = GetLayerGroupNumberByPointer(pLVar15);
          paVar8->menu = (LibraryMenuType *)0x0;
          paVar8->group = CVar9;
          paVar8 = GetConnectionMemory(DestNet);
          LVar4 = *(LocationType *)(puVar19 + 0x40);
          paVar8->ptr1 = pLVar15;
          paVar8->type = 4;
          paVar8->ptr2 = puVar19;
          paVar8->X = LVar4;
          paVar8->Y = *(LocationType *)(puVar19 + 0x44);
          CVar9 = GetLayerGroupNumberByPointer(pLVar15);
          paVar8->menu = (LibraryMenuType *)0x0;
          paVar8->group = CVar9;
          pPVar10 = PCB;
        } while (iVar22 != -1);
      }
LAB_080bf695:
      paVar16 = pPVar10->Data;
      local_24 = local_24 + 1;
      if (paVar16->LayerN + 2U <= local_24) goto LAB_080bf767;
      pLVar15 = pLVar15 + 1;
    } while( true );
  }
  goto LAB_080bf6b6;
LAB_080bf767:
  pLVar15 = paVar16->Layer;
  if (paVar16->LayerN != -2) {
    local_28 = 0;
    do {
      iVar22 = pLVar15->PolygonN - 1;
      if (iVar22 != -1) {
        iVar24 = pLVar15->PolygonN * 0x3c + -0x3c;
        do {
          while (puVar19 = (pLVar15->Polygon->Flags).t + iVar24 + -0x18, (puVar19[0x15] & 0x10) == 0
                ) {
            iVar22 = iVar22 + -1;
            iVar24 = iVar24 + -0x3c;
            pPVar10 = PCB;
            if (iVar22 == -1) goto LAB_080bf810;
          }
          iVar22 = iVar22 + -1;
          iVar24 = iVar24 + -0x3c;
          paVar8 = GetConnectionMemory(DestNet);
          iVar12 = *(int *)(puVar19 + 0x2c);
          paVar8->ptr1 = pLVar15;
          paVar8->type = 8;
          paVar8->ptr2 = puVar19;
          iVar12 = *(int *)(iVar12 + 8);
          paVar8->X = *(LocationType *)(iVar12 + 0x2c);
          paVar8->Y = *(LocationType *)(iVar12 + 0x30);
          CVar9 = GetLayerGroupNumberByPointer(pLVar15);
          paVar8->menu = (LibraryMenuType *)0x0;
          paVar8->group = CVar9;
          pPVar10 = PCB;
        } while (iVar22 != -1);
      }
LAB_080bf810:
      paVar16 = pPVar10->Data;
      local_28 = local_28 + 1;
      if (paVar16->LayerN + 2U <= local_28) break;
      pLVar15 = pLVar15 + 1;
    } while( true );
  }
LAB_080bf6b6:
  if (paVar16->ViaN != 0) {
    uVar20 = 0;
    uVar21 = paVar16->ViaN;
    do {
      paVar23 = paVar16->Via + uVar20;
      if ((*(byte *)((int)&(paVar23->Flags).f + 1) & 0x10) == 0) {
        paVar16 = pPVar10->Data;
        uVar5 = paVar16->ViaN;
      }
      else {
        paVar8 = GetConnectionMemory(DestNet);
        paVar8->X = paVar23->X;
        LVar4 = paVar23->Y;
        paVar8->type = 1;
        paVar8->ptr1 = paVar23;
        paVar8->ptr2 = paVar23;
        paVar8->Y = LVar4;
        paVar8->group = SLayer;
        paVar16 = PCB->Data;
        uVar5 = paVar16->ViaN;
        pPVar10 = PCB;
      }
    } while ((uVar5 != 0) &&
            (uVar20 = (uVar5 + 1 + uVar20) - uVar21, uVar21 = uVar5, uVar20 < uVar5));
  }
  if (NoWarn != '\0') goto LAB_080bf733;
  pLVar6 = DestNet->Connection->menu;
  list = (PointerListTypePtr)MyCalloc(1,0xc,"CheckShorts");
  ppLVar11 = (LibraryMenuType **)GetPointerMemory(list);
  *ppLVar11 = pLVar6;
  paVar16 = PCB->Data;
  local_30 = paVar16->ElementN - 1;
  bVar17 = 0;
  if (local_30 != -1) {
    bVar17 = 0;
    pPVar10 = PCB;
    iVar22 = paVar16->ElementN * 300;
    do {
      local_38 = iVar22 + -300;
      paVar7 = paVar16->Element;
      local_20 = *(uint *)((int)&paVar7[-1].PinN + iVar22);
      if (local_20 != 0) {
        uVar21 = 0;
        do {
          iVar24 = uVar21 * 0x4c + *(int *)((int)&paVar7[-1].Pin + iVar22);
          pPVar10 = PCB;
          uVar20 = local_20;
          if ((*(byte *)(iVar24 + 0x15) & 0x10) != 0) {
            if (*(void **)(iVar24 + 0x48) == (void *)0x0) {
              ptr2 = *(char **)(iVar24 + 0x40);
              if (ptr2 == (char *)0x0) {
                ptr2 = "(unknown)";
                pcVar14 = *(char **)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar22 + 8);
                if (pcVar14 != (char *)0x0) goto LAB_080bf9e7;
LAB_080bfa29:
                pcVar14 = "(unknown)";
              }
              else {
                if (*ptr2 == '\0') {
                  ptr2 = "(unknown)";
                }
                pcVar14 = *(char **)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar22 + 8);
                if (pcVar14 == (char *)0x0) goto LAB_080bfa29;
LAB_080bf9e7:
                if (*pcVar14 == '\0') {
                  pcVar14 = "(unknown)";
                }
              }
              Message("Warning! Net \"%s\" is shorted to %s pin %s\n",pLVar6->Name + 2,pcVar14,ptr2)
              ;
            }
            else {
              iVar12 = list->PtrN - 1;
              if (iVar12 != -1) {
                pvVar3 = list->Ptr[iVar12];
                ppvVar13 = list->Ptr + (list->PtrN - 2);
                while (*(void **)(iVar24 + 0x48) != pvVar3) {
                  iVar12 = iVar12 + -1;
                  if (iVar12 == -1) goto LAB_080bf919;
                  pvVar3 = *ppvVar13;
                  ppvVar13 = ppvVar13 + -1;
                }
                bVar17 = 1;
                goto joined_r0x080bf96a;
              }
LAB_080bf919:
              ppvVar13 = GetPointerMemory(list);
              *ppvVar13 = *(void **)(iVar24 + 0x48);
              Message("Warning! net \"%s\" is shorted to net \"%s\"\n",pLVar6->Name + 2,
                      **(int **)(iVar24 + 0x48) + 2);
            }
            bVar17 = 1;
            *(uint *)(iVar24 + 0x14) = *(uint *)(iVar24 + 0x14) | 0x200;
            uVar20 = *(uint *)((int)&paVar7[-1].PinN + iVar22);
            pPVar10 = PCB;
          }
joined_r0x080bf96a:
          PCB = pPVar10;
        } while ((uVar20 != 0) &&
                (uVar21 = (uVar21 + 1 + uVar20) - local_20, local_20 = uVar20, uVar21 < uVar20));
        paVar16 = pPVar10->Data;
      }
      local_30 = local_30 + -1;
      if (local_30 == -1) goto LAB_080bfa52;
      paVar16 = pPVar10->Data;
      iVar22 = local_38;
    } while( true );
  }
LAB_080bfa30:
  FreePointerListMemory(list);
  SaveFree(list);
  local_49 = local_49 | bVar17;
LAB_080bf733:
  uVar21 = Netl->NetN;
  uVar20 = uVar18;
  goto joined_r0x080bf4d2;
LAB_080bfa52:
  local_30 = paVar16->ElementN - 1;
  if (local_30 != -1) {
    iVar22 = paVar16->ElementN * 300;
    do {
      local_38 = iVar22 + -300;
      paVar7 = paVar16->Element;
      local_20 = 0;
      uVar21 = *(uint *)((int)&paVar7[-1].PadN + iVar22);
      uVar20 = uVar21;
      for (; (uVar20 != 0 && (local_20 < uVar20)); local_20 = local_20 + (uVar21 == uVar20)) {
        iVar24 = local_20 * 0x68 + *(int *)((int)&paVar7[-1].Pad + iVar22);
        if ((*(byte *)(iVar24 + 0x15) & 0x10) != 0) {
          if (*(void **)(iVar24 + 100) == (void *)0x0) {
            ptr2 = *(char **)(iVar24 + 0x5c);
            if (ptr2 == (char *)0x0) {
              ptr2 = "(unknown)";
              pcVar14 = *(char **)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar22 + 8);
              if (pcVar14 != (char *)0x0) goto LAB_080bfba7;
LAB_080bfbfe:
              pcVar14 = "(unknown)";
            }
            else {
              if (*ptr2 == '\0') {
                ptr2 = "(unknown)";
              }
              pcVar14 = *(char **)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar22 + 8);
              if (pcVar14 == (char *)0x0) goto LAB_080bfbfe;
LAB_080bfba7:
              if (*pcVar14 == '\0') {
                pcVar14 = "(unknown)";
              }
            }
            Message("Warning! Net \"%s\" is shorted  to %s pad %s\n",pLVar6->Name + 2,pcVar14,ptr2);
            bVar17 = 1;
            *(uint *)(iVar24 + 0x14) = *(uint *)(iVar24 + 0x14) | 0x200;
            uVar20 = *(uint *)((int)&paVar7[-1].PadN + iVar22);
          }
          else {
            iVar12 = list->PtrN - 1;
            if (iVar12 == -1) {
LAB_080bfafd:
              ppvVar13 = GetPointerMemory(list);
              *ppvVar13 = *(void **)(iVar24 + 100);
              Message("Warning! Net \"%s\" is shorted to net \"%s\"\n",pLVar6->Name + 2,
                      **(int **)(iVar24 + 100) + 2,ptr2);
              bVar17 = 1;
              *(uint *)(iVar24 + 0x14) = *(uint *)(iVar24 + 0x14) | 0x200;
              uVar20 = *(uint *)((int)&paVar7[-1].PadN + iVar22);
            }
            else {
              pvVar3 = list->Ptr[iVar12];
              ppvVar13 = list->Ptr + (list->PtrN - 2);
              while (*(void **)(iVar24 + 100) != pvVar3) {
                iVar12 = iVar12 + -1;
                if (iVar12 == -1) goto LAB_080bfafd;
                pvVar3 = *ppvVar13;
                ppvVar13 = ppvVar13 + -1;
              }
              bVar17 = 1;
            }
          }
        }
      }
      local_30 = local_30 + -1;
      if (local_30 == -1) break;
      paVar16 = PCB->Data;
      iVar22 = local_38;
    } while( true );
  }
  goto LAB_080bfa30;
}



// WARNING: Unknown calling convention

Boolean SeekPad(LibraryEntryType_conflict *entry,ConnectionType *conn,Boolean Same)

{
  char *pcVar1;
  PadTypePtr paVar2;
  PinTypePtr paVar3;
  uint uVar4;
  Boolean BVar5;
  int i;
  int iVar6;
  ElementTypePtr paVar7;
  int iVar8;
  Cardinal CVar9;
  LocationType LVar10;
  char cVar11;
  int iVar12;
  char *pcVar13;
  uchar *puVar14;
  char *pcVar15;
  int j;
  Cardinal i_1;
  int in_GS_OFFSET;
  uint local_250;
  uint local_230;
  char PinNum [256];
  char ElementName [256];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar1 = entry->ListEntry;
  cVar11 = *pcVar1;
  if ((cVar11 == '-') || (cVar11 == '\0')) {
    iVar6 = 0;
  }
  else {
    iVar12 = 0;
    do {
      iVar6 = iVar12 + 1;
      ElementName[iVar12] = cVar11;
      cVar11 = pcVar1[iVar6];
      if (cVar11 == '-') goto LAB_080bfc79;
      iVar12 = iVar6;
    } while (cVar11 != '\0');
  }
  if (cVar11 != '-') {
    ElementName[iVar6] = '\0';
    Message("Bad net-list format encountered near: \"%s\"\n",ElementName);
    BVar5 = '\0';
    goto LAB_080bfe3d;
  }
LAB_080bfc79:
  pcVar13 = ElementName;
  if ((iVar6 != 0) && (pcVar13 = ElementName + iVar6, '`' < PinNum[iVar6 + 0xff])) {
    pcVar15 = ElementName + iVar6;
    iVar12 = iVar6;
    do {
      iVar12 = iVar12 + -1;
      pcVar13 = ElementName;
      if (iVar12 == 0) goto LAB_080bfcb0;
      pcVar13 = pcVar15 + -2;
      pcVar15 = pcVar15 + -1;
    } while ('`' < *pcVar13);
    pcVar13 = ElementName + iVar12;
  }
LAB_080bfcb0:
  *pcVar13 = '\0';
  cVar11 = pcVar1[iVar6 + 1];
  pcVar13 = PinNum;
  if (cVar11 != '\0') {
    iVar12 = 0;
    do {
      iVar8 = iVar12;
      PinNum[iVar8] = cVar11;
      cVar11 = pcVar1[iVar8 + 1 + iVar6 + 1];
      iVar12 = iVar8 + 1;
    } while (cVar11 != '\0');
    pcVar13 = PinNum + iVar8 + 1;
  }
  *pcVar13 = '\0';
  if (PinNum[0] == '\0') {
    Message("Error! Netlist file is missing pin!\nwhite space after \"%s-\"\n",ElementName);
    badnet = '\x01';
  }
  else {
    iVar6 = 0;
    do {
      iVar12 = iVar6;
      iVar6 = iVar12 + 1;
    } while (PinNum[iVar12 + 1] != '\0');
    paVar7 = SearchElementByName(PCB->Data,ElementName);
    if (paVar7 != (ElementTypePtr)0x0) {
      local_230 = paVar7->PadN;
      if (local_230 != 0) {
        iVar6 = 0;
        local_250 = 0;
        paVar2 = paVar7->Pad;
        do {
          pcVar1 = *(char **)((int)(&paVar2->Flags + 6) + iVar6);
          if (((pcVar1 != (char *)0x0) && (iVar8 = strcmp(PinNum,pcVar1), iVar8 == 0)) &&
             ((Same == '\0' || (((paVar2->Flags).t[iVar6 + -3] & 0x10) == 0)))) {
            conn->type = 0x200;
            puVar14 = (paVar7->Pad->Flags).t + iVar6 + -0x18;
            conn->ptr2 = puVar14;
            paVar2 = paVar7->Pad;
            CVar9 = SLayer;
            if (-1 < (char)(paVar2->Flags).t[iVar6 + -4]) {
              CVar9 = CLayer;
            }
            conn->group = CVar9;
            if ((puVar14[0x15] & 0x40) == 0) {
              conn->X = *(LocationType *)(puVar14 + 0x2c);
              LVar10 = *(LocationType *)((int)&((PointType *)(&paVar2->Flags + 2))->Y + iVar6);
            }
            else {
              conn->X = *(LocationType *)(puVar14 + 0x40);
              LVar10 = *(LocationType *)((int)(&paVar2->Flags + 4) + iVar6);
            }
            conn->Y = LVar10;
            local_230 = paVar7->PadN;
            break;
          }
          local_250 = local_250 + 1;
          iVar6 = iVar6 + 0x68;
        } while (local_250 < local_230);
        if (local_230 == local_250) goto LAB_080bff48;
LAB_080bfdee:
        conn->ptr1 = paVar7;
        BVar5 = '\x01';
        goto LAB_080bfe3d;
      }
LAB_080bff48:
      local_230 = paVar7->PinN;
      if (local_230 != 0) {
        iVar6 = 0;
        local_250 = 0;
        paVar3 = paVar7->Pin;
        do {
          uVar4 = *(uint *)((paVar3->Flags).t + iVar6 + -4);
          if (((((uVar4 & 8) == 0) &&
               (pcVar1 = *(char **)((int)(&paVar3->Flags + 3) + iVar6 + 8), pcVar1 != (char *)0x0))
              && (iVar8 = strcmp(PinNum,pcVar1), iVar8 == 0)) &&
             ((Same == '\0' || ((uVar4 & 0x1000) == 0)))) {
            conn->type = 0x100;
            conn->ptr2 = (paVar7->Pin->Flags).t + iVar6 + -0x18;
            conn->group = SLayer;
            paVar3 = paVar7->Pin;
            conn->X = *(LocationType *)((int)(&paVar3->Flags + 2) + iVar6 + 8);
            conn->Y = *(LocationType *)((int)(&paVar3->Flags + 3) + iVar6);
            local_230 = paVar7->PinN;
            break;
          }
          local_250 = local_250 + 1;
          iVar6 = iVar6 + 0x4c;
        } while (local_250 < local_230);
        if (local_250 != local_230) goto LAB_080bfdee;
      }
    }
    BVar5 = '\0';
    if (Same != '\0') goto LAB_080bfe3d;
    if (9 < (byte)(PinNum[iVar12] - 0x30U)) {
      Message("WARNING! Pin number ending with \'%c\' encountered in netlist file\nProbably a bad netlist file format\n"
              ,(int)PinNum[iVar12]);
    }
  }
  Message("Can\'t find %s pin %s called for in netlist.\n",ElementName,PinNum);
  BVar5 = '\0';
LAB_080bfe3d:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar5;
}



// WARNING: Unknown calling convention

NetListTypePtr ProcNetlist(LibraryTypePtr net_menu)

{
  uint *puVar1;
  uint uVar2;
  ElementTypePtr paVar3;
  char *__s2;
  char *__s1;
  PCBTypePtr pPVar4;
  Boolean BVar5;
  ElementTypePtr element_1;
  uint uVar6;
  PadTypePtr pad_1;
  NetTypePtr Net;
  undefined4 uVar7;
  ConnectionTypePtr paVar8;
  ConnectionTypePtr connection;
  ElementTypePtr element_3;
  Cardinal n;
  int iVar9;
  PadTypePtr pad;
  int iVar10;
  PinTypePtr pin;
  Cardinal n_2;
  Cardinal sn_1;
  LibraryMenuType *pLVar11;
  PCBTypePtr pPVar12;
  Cardinal sn;
  ElementTypePtr element_2;
  int iVar13;
  LibraryEntryType_conflict *entry;
  ElementTypePtr element;
  int local_50;
  int local_4c;
  NetListTypePtr local_48;
  int local_44;
  DataTypePtr local_40;
  ConnectionType LastPoint;
  
  local_48 = (NetListTypePtr)0x0;
  if (net_menu->MenuN != 0) {
    FreeNetListMemory(ProcNetlist::Wantlist);
    SaveFree(ProcNetlist::Wantlist);
    badnet = '\0';
    SLayer = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    CLayer = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
    local_48 = (NetListTypePtr)MyCalloc(1,0xc,"ProcNetlist()");
    ProcNetlist::Wantlist = local_48;
    if (local_48 == (NetListTypePtr)0x0) {
      local_40 = PCB->Data;
    }
    else {
      local_40 = PCB->Data;
      local_44 = local_40->ElementN - 1;
      if (local_44 != -1) {
        iVar13 = local_40->ElementN * 300;
        do {
          uVar2 = *(uint *)((int)&local_40->Element[-1].PinN + iVar13);
          if (uVar2 != 0) {
            iVar9 = *(int *)((int)&local_40->Element[-1].Pin + iVar13);
            uVar6 = 0;
            *(undefined4 *)(iVar9 + 0x48) = 0;
            *(uint *)(iVar9 + 0x14) = *(uint *)(iVar9 + 0x14) & 0xffffefff;
            while (uVar6 = uVar6 + 1, uVar6 < uVar2) {
              iVar10 = iVar9 + uVar6 * 0x4c;
              puVar1 = (uint *)(iVar10 + 0x14);
              *puVar1 = *puVar1 & 0xffffefff;
              *(undefined4 *)(iVar10 + 0x48) = 0;
            }
          }
          local_44 = local_44 + -1;
          iVar13 = iVar13 + -300;
        } while (local_44 != -1);
        local_44 = local_40->ElementN - 1;
        if (local_44 != -1) {
          iVar13 = local_40->ElementN * 300;
          do {
            paVar3 = local_40->Element;
            iVar9 = 0;
            uVar2 = *(uint *)((int)&paVar3[-1].PadN + iVar13);
            for (uVar6 = 0; (uVar2 != 0 && (uVar6 < uVar2)); uVar6 = uVar6 + 1) {
              iVar10 = *(int *)((int)&paVar3[-1].Pad + iVar13) + iVar9;
              iVar9 = iVar9 + 0x68;
              puVar1 = (uint *)(iVar10 + 0x14);
              *puVar1 = *puVar1 & 0xffffefff;
              *(undefined4 *)(iVar10 + 100) = 0;
            }
            local_44 = local_44 + -1;
            iVar13 = iVar13 + -300;
          } while (local_44 != -1);
        }
      }
      local_4c = net_menu->MenuN - 1;
      if (local_4c != -1) {
        iVar13 = net_menu->MenuN * 0x1c;
        do {
          local_50 = iVar13 + -0x1c;
          pLVar11 = (LibraryMenuType *)((int)&net_menu->Menu[-1].Name + iVar13);
          if ((*pLVar11->Name == '*') || (pLVar11->flag == '\0')) {
            badnet = '\x01';
          }
          else {
            Net = GetNetMemory(local_48);
            pPVar4 = PCB;
            __s2 = pLVar11->Style;
            if (__s2 == (char *)0x0) {
              Net->Style = (RouteStyleTypePtr)0x0;
            }
            else {
              iVar13 = 0;
              pPVar12 = PCB;
              do {
                __s1 = pPVar12->RouteStyle[0].Name;
                if (__s1 != (char *)0x0) {
                  iVar9 = strcmp(__s1,__s2);
                  if (iVar9 == 0) {
                    Net->Style = pPVar4->RouteStyle + iVar13;
                    break;
                  }
                }
                iVar13 = iVar13 + 1;
                pPVar12 = (PCBTypePtr)&pPVar12->PrintFilename;
              } while (iVar13 != 4);
            }
            local_44 = pLVar11->EntryN - 1;
            if (local_44 != -1) {
              iVar13 = pLVar11->EntryN * 0x18;
              do {
                local_48 = (NetListTypePtr)(iVar13 + -0x18);
                entry = (LibraryEntryType_conflict *)((int)&pLVar11->Entry[-1].ListEntry + iVar13);
                BVar5 = SeekPad(entry,&LastPoint,'\0');
                if (BVar5 == '\0') {
                  badnet = '\x01';
                }
                else {
                  if ((*(byte *)((int)LastPoint.ptr2 + 0x15) & 0x10) == 0) goto LAB_080c0426;
                  if (LastPoint.type == 0x100) {
                    uVar7 = *(undefined4 *)((int)LastPoint.ptr2 + 0x40);
                  }
                  else {
                    uVar7 = *(undefined4 *)((int)LastPoint.ptr2 + 0x5c);
                  }
                  Message("Error! Element %s pin %s appears multiple times in the netlist file.\n",
                          *(undefined4 *)((int)LastPoint.ptr1 + 0x94),uVar7);
                }
                while (BVar5 = SeekPad(entry,&LastPoint,'\x01'), BVar5 != '\0') {
LAB_080c0426:
                  paVar8 = GetConnectionMemory(Net);
                  paVar8->X = LastPoint.X;
                  paVar8->Y = LastPoint.Y;
                  paVar8->type = LastPoint.type;
                  paVar8->ptr1 = LastPoint.ptr1;
                  paVar8->ptr2 = LastPoint.ptr2;
                  paVar8->menu = pLVar11;
                  paVar8->group = LastPoint.group;
                  *(uint *)((int)LastPoint.ptr2 + 0x14) =
                       *(uint *)((int)LastPoint.ptr2 + 0x14) | 0x1000;
                  if (LastPoint.type == 0x100) {
                    *(LibraryMenuType **)((int)LastPoint.ptr2 + 0x48) = pLVar11;
                  }
                  else {
                    *(LibraryMenuType **)((int)LastPoint.ptr2 + 100) = pLVar11;
                  }
                }
                local_44 = local_44 + -1;
                iVar13 = (int)local_48;
              } while (local_44 != -1);
            }
          }
          local_4c = local_4c + -1;
          local_48 = ProcNetlist::Wantlist;
          iVar13 = local_50;
        } while (local_4c != -1);
        local_40 = PCB->Data;
      }
    }
    local_44 = local_40->ElementN - 1;
    if (local_44 != -1) {
      iVar13 = local_40->ElementN * 300;
      do {
        uVar2 = *(uint *)((int)&local_40->Element[-1].PinN + iVar13);
        if (uVar2 != 0) {
          iVar9 = *(int *)((int)&local_40->Element[-1].Pin + iVar13);
          uVar6 = 0;
          puVar1 = (uint *)(iVar9 + 0x14);
          *puVar1 = *puVar1 & 0xffffefff;
          while (uVar6 = uVar6 + 1, uVar6 < uVar2) {
            puVar1 = (uint *)(iVar9 + 0x14 + uVar6 * 0x4c);
            *puVar1 = *puVar1 & 0xffffefff;
          }
        }
        local_44 = local_44 + -1;
        iVar13 = iVar13 + -300;
      } while (local_44 != -1);
      local_44 = local_40->ElementN - 1;
      if (local_44 != -1) {
        iVar13 = local_40->ElementN * 300;
        do {
          iVar9 = 0;
          paVar3 = local_40->Element;
          uVar2 = *(uint *)((int)&paVar3[-1].PadN + iVar13);
          for (uVar6 = 0; (uVar2 != 0 && (uVar6 < uVar2)); uVar6 = uVar6 + 1) {
            iVar10 = *(int *)((int)&paVar3[-1].Pad + iVar13) + iVar9;
            iVar9 = iVar9 + 0x68;
            puVar1 = (uint *)(iVar10 + 0x14);
            *puVar1 = *puVar1 & 0xffffefff;
          }
          local_44 = local_44 + -1;
          iVar13 = iVar13 + -300;
        } while (local_44 != -1);
        return local_48;
      }
    }
  }
  return local_48;
}



// WARNING: Unknown calling convention

NetListListType * CollectSubnets(Boolean SelectedOnly)

{
  NetListTypePtr paVar1;
  NetListTypePtr Netlist;
  NetTypePtr Net;
  ConnectionTypePtr paVar2;
  ConnectionTypePtr onepin;
  NetTypePtr net;
  ConnectionTypePtr connection;
  LocationType *pLVar3;
  Cardinal n;
  int iVar4;
  int iVar5;
  NetListListType *in_stack_00000004;
  int local_3c;
  int local_38;
  NetListListType result;
  
  result.NetListN = 0;
  result.NetListMax = 0;
  result.NetList = (NetListTypePtr)0x0;
  paVar1 = ProcNetlist(&PCB->NetlistLib);
  if (paVar1 == (NetListTypePtr)0x0) {
    Message("Can\'t add rat lines because no netlist is loaded.\n");
  }
  else {
    InitConnectionLookup();
    SaveFindFlag(0x1000);
    local_3c = paVar1->NetN - 1;
    if (local_3c != -1) {
      local_38 = (paVar1->NetN + 0xfffffff) * 0x10;
      do {
        net = (NetTypePtr)((int)&paVar1->Net->ConnectionN + local_38);
        Netlist = GetNetListMemory((NetListListTypePtr)&result);
        iVar4 = net->ConnectionN - 1;
        if (iVar4 != -1) {
          iVar5 = net->ConnectionN * 0x1c;
          do {
            pLVar3 = (LocationType *)((int)&net->Connection[-1].X + iVar5);
            if ((SelectedOnly == '\0') || ((*(byte *)(pLVar3[4] + 0x14) & 0x40) != 0)) {
              Net = GetNetMemory(Netlist);
              paVar2 = GetConnectionMemory(Net);
              paVar2->X = *pLVar3;
              paVar2->Y = pLVar3[1];
              paVar2->type = pLVar3[2];
              paVar2->ptr1 = (void *)pLVar3[3];
              paVar2->ptr2 = (void *)pLVar3[4];
              paVar2->group = pLVar3[5];
              paVar2->menu = (LibraryMenuType *)pLVar3[6];
              Net->Style = net->Style;
            }
            iVar4 = iVar4 + -1;
            iVar5 = iVar5 + -0x1c;
          } while (iVar4 != -1);
        }
        GatherSubnets(Netlist,SelectedOnly,'\0');
        local_3c = local_3c + -1;
        local_38 = local_38 + -0x10;
      } while (local_3c != -1);
    }
    FreeConnectionLookupMemory();
    RestoreFindFlag();
  }
  in_stack_00000004->NetListN = result.NetListN;
  in_stack_00000004->NetListMax = result.NetListMax;
  in_stack_00000004->NetList = result.NetList;
  return in_stack_00000004;
}



// WARNING: Unknown calling convention

Boolean AddAllRats(Boolean SelectedOnly,_func_void_varargs *funcp)

{
  float fVar1;
  Boolean BVar2;
  NetTypePtr paVar3;
  ConnectionTypePtr paVar4;
  ConnectionTypePtr onepin;
  uint uVar5;
  NetTypePtr subnet;
  RatTypePtr Line;
  int *piVar6;
  NetTypePtr net;
  int iVar7;
  char *pcVar8;
  RatTypePtr line;
  LocationType *pLVar9;
  int *piVar10;
  Cardinal n;
  int iVar11;
  int *piVar12;
  undefined4 *puVar13;
  Cardinal m;
  undefined4 *puVar14;
  int in_GS_OFFSET;
  byte bVar15;
  float distance;
  FlagType in_stack_ffffff54;
  undefined4 *local_90;
  int local_74;
  byte local_6d;
  _func_void_varargs *local_6c;
  NetListTypePtr local_68;
  Cardinal local_64;
  byte local_60;
  Boolean local_5f;
  byte local_5e;
  byte local_5d;
  int local_5c;
  NetListTypePtr local_58;
  uint local_54;
  NetTypePtr local_50;
  int local_4c;
  int local_48;
  NetTypePtr local_44;
  int *local_40;
  float local_34;
  undefined4 local_2c [3];
  int local_20;
  
  bVar15 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_6c = funcp;
  local_5f = SelectedOnly;
  local_68 = ProcNetlist(&PCB->NetlistLib);
  if (local_68 == (NetListTypePtr)0x0) {
    Message("Can\'t add rat lines because no netlist is loaded.\n");
    BVar2 = '\0';
    goto LAB_080c0c70;
  }
  InitConnectionLookup();
  SaveFindFlag(0x1000);
  local_58 = (NetListTypePtr)MyCalloc(1,0xc,"AddAllRats()");
  local_5e = 0;
  local_60 = 0;
  local_64 = local_68->NetN;
  local_90 = local_2c;
  local_5c = (local_64 + 0xfffffff) * 0x10;
  local_74 = (int)SelectedOnly;
  while (local_64 = local_64 - 1, local_64 != 0xffffffff) {
    net = (NetTypePtr)((int)&local_68->Net->ConnectionN + local_5c);
    iVar11 = net->ConnectionN - 1;
    if (iVar11 != -1) {
      iVar7 = net->ConnectionN * 0x1c;
      do {
        pLVar9 = (LocationType *)((int)&net->Connection[-1].X + iVar7);
        if ((local_5f == '\0') || ((*(byte *)(pLVar9[4] + 0x14) & 0x40) != 0)) {
          paVar3 = GetNetMemory(local_58);
          paVar4 = GetConnectionMemory(paVar3);
          paVar4->X = *pLVar9;
          paVar4->Y = pLVar9[1];
          paVar4->type = pLVar9[2];
          paVar4->ptr1 = (void *)pLVar9[3];
          paVar4->ptr2 = (void *)pLVar9[4];
          paVar4->group = pLVar9[5];
          paVar4->menu = (LibraryMenuType *)pLVar9[6];
          paVar3->Style = net->Style;
        }
        iVar11 = iVar11 + -1;
        iVar7 = iVar7 + -0x1c;
      } while (iVar11 != -1);
    }
    local_6d = GatherSubnets(local_58,(Boolean)local_74,'\x01');
    uVar5 = local_58->NetN;
    if (uVar5 != 0) {
      if (uVar5 < 2) {
        local_58->NetN = 0;
        FreeNetMemory(local_58->Net);
        local_5d = 0;
      }
      else {
        local_44 = (NetTypePtr)0x0;
        local_34 = 0.0;
        local_5d = 0;
        do {
          local_50 = local_58->Net;
          if (1 < uVar5) {
            local_40 = (int *)0x0;
            piVar6 = (int *)0x0;
            local_54 = 1;
            paVar3 = local_50;
            do {
              paVar3 = paVar3 + local_54;
              local_48 = local_50->ConnectionN - 1;
              if (local_48 != -1) {
                iVar11 = local_50->ConnectionN * 0x1c;
                do {
                  local_4c = iVar11 + -0x1c;
                  piVar12 = (int *)((int)&local_50->Connection[-1].X + iVar11);
                  iVar11 = paVar3->ConnectionN - 1;
                  if (iVar11 != -1) {
                    iVar7 = paVar3->ConnectionN * 0x1c + -0x1c;
LAB_080c0979:
                    do {
                      piVar10 = (int *)((int)&paVar3->Connection->X + iVar7);
                      if ((((piVar12[2] == 8) && ((PolygonTypePtr)piVar12[4] != (PolygonTypePtr)0x0)
                           ) && ((local_34 != 0.0 || ((piVar6 == (int *)0x0 || (piVar6[2] != 1))))))
                         && (BVar2 = IsPointInPolygonIgnoreHoles
                                               (*piVar10,piVar10[1],(PolygonTypePtr)piVar12[4]),
                            BVar2 != '\0')) {
                        local_34 = 0.0;
                        piVar6 = piVar10;
                        local_44 = paVar3;
                        local_40 = piVar12;
                      }
                      else if (((piVar10[2] == 8) &&
                               ((PolygonTypePtr)piVar10[4] != (PolygonTypePtr)0x0)) &&
                              (((local_34 != 0.0 || ((piVar6 == (int *)0x0 || (piVar6[2] != 1)))) &&
                               (BVar2 = IsPointInPolygonIgnoreHoles
                                                  (*piVar12,piVar12[1],(PolygonTypePtr)piVar10[4]),
                               BVar2 != '\0')))) {
                        local_34 = 0.0;
                        piVar6 = piVar12;
                        local_44 = paVar3;
                        local_40 = piVar10;
                      }
                      else {
                        fVar1 = (float)(piVar12[1] - piVar10[1]) * (float)(piVar12[1] - piVar10[1])
                                + (float)(*piVar12 - *piVar10) * (float)(*piVar12 - *piVar10);
                        if ((fVar1 < local_34) || (piVar6 == (int *)0x0)) {
                          iVar11 = iVar11 + -1;
                          iVar7 = iVar7 + -0x1c;
                          piVar6 = piVar12;
                          local_34 = fVar1;
                          local_44 = paVar3;
                          local_40 = piVar10;
                          if (iVar11 == -1) break;
                          goto LAB_080c0979;
                        }
                      }
                      iVar11 = iVar11 + -1;
                      iVar7 = iVar7 + -0x1c;
                    } while (iVar11 != -1);
                  }
                  local_48 = local_48 + -1;
                  iVar11 = local_4c;
                } while (local_48 != -1);
              }
              local_54 = local_54 + 1;
              if (local_58->NetN <= local_54) goto LAB_080c0b05;
              paVar3 = local_58->Net;
            } while( true );
          }
          local_40 = (int *)0x0;
          piVar6 = (int *)0x0;
LAB_080c0b05:
          if (local_6c == (_func_void_varargs *)0x0) {
            MakeFlags(0);
            puVar13 = local_90;
            puVar14 = (undefined4 *)&stack0xffffff54;
            for (iVar11 = 3; iVar11 != 0; iVar11 = iVar11 + -1) {
              *puVar14 = *puVar13;
              puVar13 = puVar13 + (uint)bVar15 * -2 + 1;
              puVar14 = puVar14 + (uint)bVar15 * -2 + 1;
            }
            Line = CreateNewRat(PCB->Data,*piVar6,piVar6[1],*local_40,local_40[1],piVar6[5],
                                local_40[5],Settings.RatThickness,in_stack_ffffff54);
            if (Line != (RatTypePtr)0x0) {
              if (local_34 == 0.0) {
                (Line->Flags).f = (Line->Flags).f | 2;
              }
              AddObjectToCreateUndoList(0x20,Line,Line,Line);
              DrawRat(Line,0);
              local_5d = 1;
            }
          }
          else {
            (*local_6c)(piVar6,local_40,local_50->Style);
          }
          TransferNet(local_58,local_44,local_50);
          uVar5 = local_58->NetN;
        } while (1 < uVar5);
        local_58->NetN = uVar5 - 1;
        FreeNetMemory(local_58->Net + (uVar5 - 1));
        if (local_5d != 0) {
          FreeConnectionLookupMemory();
          InitConnectionLookup();
          local_5d = 1;
        }
      }
      local_60 = local_60 | local_5d;
    }
    local_5e = local_5e | local_6d;
    local_5c = local_5c + -0x10;
  }
  FreeNetListMemory(local_58);
  SaveFree(local_58);
  FreeConnectionLookupMemory();
  RestoreFindFlag();
  if (local_6c == (_func_void_varargs *)0x0) {
    if ((local_5e == 0) && (local_60 == 0)) {
LAB_080c0cc9:
      if (local_5f == '\0') {
        if ((PCB->Data->RatN != 0) || (badnet != '\0')) {
          Message(
                 "Nothing more to add, but there are\neither rat-lines in the layout, disabled nets\nin the net-list, or missing components\n"
                 );
          BVar2 = '\0';
          goto LAB_080c0c70;
        }
        Message("Congratulations!!\nThe layout is complete and has no shorted nets.\n");
      }
    }
    else {
      Draw();
      if (local_5e != 0) {
        Settings.RatWarn = '\x01';
      }
      if (local_60 != 0) {
        IncrementUndoSerialNumber();
        uVar5 = PCB->Data->RatN;
        if (uVar5 != 0) {
          pcVar8 = "";
          if (1 < uVar5) {
            pcVar8 = "s";
          }
          Message("%d rat line%s remaining\n",uVar5,pcVar8);
          BVar2 = '\x01';
          goto LAB_080c0c70;
        }
        goto LAB_080c0caa;
      }
      if (local_5e == 0) goto LAB_080c0cc9;
    }
    BVar2 = '\0';
  }
  else {
LAB_080c0caa:
    BVar2 = '\x01';
  }
LAB_080c0c70:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void * DestroyObject(DataTypePtr Target,int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  DestroyTarget = Target;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&DestroyFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * RemoveObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *ptr;
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr)&RemoveFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



// WARNING: Unknown calling convention

void * DestroyRat(RatTypePtr Rat)

{
  RatTypePtr *ppaVar1;
  DataTypePtr paVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  RatTypePtr paVar6;
  Cardinal CVar7;
  RatTypePtr paVar8;
  undefined4 *puVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  if (DestroyTarget->rat_tree != (rtree_t *)0x0) {
    r_delete_entry(DestroyTarget->rat_tree,&Rat->BoundingBox);
  }
  paVar2 = DestroyTarget;
  ppaVar1 = &DestroyTarget->Rat;
  CVar7 = DestroyTarget->RatN - 1;
  DestroyTarget->RatN = CVar7;
  if (*ppaVar1 + CVar7 != Rat) {
    paVar6 = *ppaVar1 + CVar7;
    paVar8 = Rat;
    for (iVar3 = 0x17; iVar3 != 0; iVar3 = iVar3 + -1) {
      (paVar8->BoundingBox).X1 = (paVar6->BoundingBox).X1;
      paVar6 = (RatTypePtr)((int)paVar6 + (uint)bVar11 * -8 + 4);
      paVar8 = (RatTypePtr)((int)paVar8 + (uint)bVar11 * -8 + 4);
    }
    r_substitute(paVar2->rat_tree,&paVar2->Rat[paVar2->RatN].BoundingBox,&Rat->BoundingBox);
    CVar7 = DestroyTarget->RatN;
    paVar2 = DestroyTarget;
  }
  puVar9 = (undefined4 *)((int)&paVar2->Rat->Flags + CVar7 * 0x5c + -0x14);
  uVar5 = 0x5c;
  bVar10 = ((uint)puVar9 & 1) != 0;
  if (bVar10) {
    *(undefined *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 1);
    uVar5 = 0x5b;
  }
  if (((uint)puVar9 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    uVar5 = uVar5 - 2;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
    *puVar9 = 0;
    puVar9 = puVar9 + (uint)bVar11 * -2 + 1;
  }
  if ((uVar5 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  if (bVar10) {
    *(undefined *)puVar9 = 0;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * DestroyArc(LayerTypePtr Layer,ArcTypePtr Arc)

{
  Cardinal CVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  ArcTypePtr paVar5;
  ArcTypePtr paVar6;
  undefined4 *puVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  r_delete_entry(Layer->arc_tree,&Arc->BoundingBox);
  CVar1 = Layer->ArcN - 1;
  Layer->ArcN = CVar1;
  if (Layer->Arc + CVar1 != Arc) {
    paVar5 = Layer->Arc + CVar1;
    paVar6 = Arc;
    for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {
      (paVar6->BoundingBox).X1 = (paVar5->BoundingBox).X1;
      paVar5 = (ArcTypePtr)((int)paVar5 + (uint)bVar9 * -8 + 4);
      paVar6 = (ArcTypePtr)((int)paVar6 + (uint)bVar9 * -8 + 4);
    }
    r_substitute(Layer->arc_tree,&Layer->Arc[Layer->ArcN].BoundingBox,&Arc->BoundingBox);
    CVar1 = Layer->ArcN;
  }
  puVar7 = (undefined4 *)((int)&Layer->Arc->Flags + CVar1 * 0x44 + -0x14);
  uVar4 = 0x44;
  bVar8 = ((uint)puVar7 & 1) != 0;
  if (bVar8) {
    *(undefined *)puVar7 = 0;
    puVar7 = (undefined4 *)((int)puVar7 + 1);
    uVar4 = 0x43;
  }
  if (((uint)puVar7 & 2) != 0) {
    *(undefined2 *)puVar7 = 0;
    uVar4 = uVar4 - 2;
    puVar7 = (undefined4 *)((int)puVar7 + 2);
  }
  for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
    *puVar7 = 0;
    puVar7 = puVar7 + (uint)bVar9 * -2 + 1;
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)puVar7 = 0;
    puVar7 = (undefined4 *)((int)puVar7 + 2);
  }
  if (bVar8) {
    *(undefined *)puVar7 = 0;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * DestroyElement(ElementTypePtr Element)

{
  ElementTypePtr *ppaVar1;
  BoxType *after;
  rtree_t **pprVar2;
  PinTypePtr paVar3;
  DataTypePtr paVar4;
  rtree_t *prVar5;
  Cardinal sn_1;
  Cardinal CVar6;
  Cardinal n_3;
  Cardinal n_4;
  uint uVar7;
  uint uVar8;
  Cardinal n;
  uint uVar9;
  Cardinal n_1;
  Cardinal n_2;
  ElementTypePtr paVar10;
  Cardinal sn_2;
  Cardinal n_5;
  Cardinal sn;
  int iVar11;
  ElementTypePtr paVar12;
  Cardinal sn_3;
  bool bVar13;
  byte bVar14;
  
  bVar14 = 0;
  if (DestroyTarget->element_tree != (rtree_t *)0x0) {
    r_delete_entry(DestroyTarget->element_tree,&Element->BoundingBox);
  }
  prVar5 = DestroyTarget->pin_tree;
  if ((prVar5 != (rtree_t *)0x0) && (Element->PinN != 0)) {
    uVar8 = 0;
    uVar7 = Element->PinN;
    while( true ) {
      r_delete_entry(prVar5,&Element->Pin[uVar8].BoundingBox);
      uVar9 = Element->PinN;
      if ((uVar9 == 0) || (uVar8 = (uVar9 + 1 + uVar8) - uVar7, uVar9 <= uVar8)) break;
      prVar5 = DestroyTarget->pin_tree;
      uVar7 = uVar9;
    }
  }
  if (DestroyTarget->pad_tree != (rtree_t *)0x0) {
    uVar7 = Element->PadN;
    iVar11 = 0;
    uVar9 = 0;
    uVar8 = uVar7;
    while ((uVar8 != 0 && (uVar9 < uVar8))) {
      r_delete_entry(DestroyTarget->pad_tree,(BoxType *)((Element->Pad->Flags).t + iVar11 + -0x18));
      uVar8 = Element->PadN;
      if (uVar8 == uVar7) {
        uVar9 = uVar9 + 1;
        iVar11 = iVar11 + 0x68;
        uVar8 = uVar7;
      }
    }
  }
  prVar5 = DestroyTarget->name_tree[2];
  iVar11 = 2;
  while( true ) {
    if (prVar5 != (rtree_t *)0x0) {
      r_delete_entry(prVar5,(BoxType *)(Element->Name + iVar11));
    }
    if (iVar11 + -1 == -1) break;
    prVar5 = DestroyTarget->name_tree[iVar11 + -1];
    iVar11 = iVar11 + -1;
  }
  FreeElementMemory(Element);
  paVar4 = DestroyTarget;
  ppaVar1 = &DestroyTarget->Element;
  CVar6 = DestroyTarget->ElementN - 1;
  DestroyTarget->ElementN = CVar6;
  if (*ppaVar1 + CVar6 != Element) {
    paVar10 = *ppaVar1 + CVar6;
    paVar12 = Element;
    for (iVar11 = 0x4b; iVar11 != 0; iVar11 = iVar11 + -1) {
      (paVar12->BoundingBox).X1 = (paVar10->BoundingBox).X1;
      paVar10 = (ElementTypePtr)((int)paVar10 + (uint)bVar14 * -8 + 4);
      paVar12 = (ElementTypePtr)((int)paVar12 + (uint)bVar14 * -8 + 4);
    }
    r_substitute(paVar4->element_tree,&paVar4->Element[paVar4->ElementN].BoundingBox,
                 &Element->BoundingBox);
    paVar4 = DestroyTarget;
  }
  uVar7 = Element->PinN;
  if (uVar7 != 0) {
    paVar3 = Element->Pin;
    uVar8 = 0;
    paVar3->Element = Element;
    while (uVar8 = uVar8 + 1, uVar8 < uVar7) {
      paVar3[uVar8].Element = Element;
    }
  }
  uVar7 = Element->PadN;
  iVar11 = 0;
  for (uVar8 = 0; (uVar7 != 0 && (uVar8 < uVar7)); uVar8 = uVar8 + 1) {
    *(ElementTypePtr *)((int)(&Element->Pad->Flags + 6) + iVar11 + 4) = Element;
    iVar11 = iVar11 + 0x68;
  }
  iVar11 = 0x78;
  n_5 = 2;
  do {
    after = (BoxType *)(Element->Name + n_5);
    pprVar2 = paVar4->name_tree + n_5;
    n_5 = n_5 - 1;
    r_substitute(*pprVar2,(BoxType *)
                          (paVar4->Element[paVar4->ElementN].Name[0].Flags.t + iVar11 + -0x18),after
                );
    *(ElementTypePtr *)((int)(&Element->Name[0].Flags + 3) + iVar11) = Element;
    iVar11 = iVar11 + -0x3c;
    paVar4 = DestroyTarget;
  } while (n_5 != 0xffffffff);
  uVar7 = 300;
  paVar10 = DestroyTarget->Element + DestroyTarget->ElementN;
  bVar13 = ((uint)paVar10 & 1) != 0;
  if (bVar13) {
    *(undefined *)&(paVar10->BoundingBox).X1 = 0;
    paVar10 = (ElementTypePtr)((int)&(paVar10->BoundingBox).X1 + 1);
    uVar7 = 299;
  }
  if (((uint)paVar10 & 2) != 0) {
    *(undefined2 *)&(paVar10->BoundingBox).X1 = 0;
    uVar7 = uVar7 - 2;
    paVar10 = (ElementTypePtr)((int)&(paVar10->BoundingBox).X1 + 2);
  }
  for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
    (paVar10->BoundingBox).X1 = 0;
    paVar10 = (ElementTypePtr)((int)paVar10 + (uint)bVar14 * -8 + 4);
  }
  if ((uVar7 & 2) != 0) {
    *(undefined2 *)&(paVar10->BoundingBox).X1 = 0;
    paVar10 = (ElementTypePtr)((int)&(paVar10->BoundingBox).X1 + 2);
  }
  if (bVar13) {
    *(undefined *)&(paVar10->BoundingBox).X1 = 0;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * DestroyVia(PinTypePtr Via)

{
  DataTypePtr paVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  PinTypePtr paVar5;
  Cardinal CVar6;
  PinTypePtr paVar7;
  undefined4 *puVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  r_delete_entry(DestroyTarget->via_tree,&Via->BoundingBox);
  SaveFree(Via->Name);
  paVar1 = DestroyTarget;
  Via->Name = (char *)0x0;
  CVar6 = paVar1->ViaN - 1;
  paVar1->ViaN = CVar6;
  if (paVar1->Via + CVar6 != Via) {
    paVar5 = paVar1->Via + CVar6;
    paVar7 = Via;
    for (iVar2 = 0x13; iVar2 != 0; iVar2 = iVar2 + -1) {
      (paVar7->BoundingBox).X1 = (paVar5->BoundingBox).X1;
      paVar5 = (PinTypePtr)((int)paVar5 + (uint)bVar10 * -8 + 4);
      paVar7 = (PinTypePtr)((int)paVar7 + (uint)bVar10 * -8 + 4);
    }
    r_substitute(paVar1->via_tree,&paVar1->Via[paVar1->ViaN].BoundingBox,&Via->BoundingBox);
    CVar6 = DestroyTarget->ViaN;
    paVar1 = DestroyTarget;
  }
  puVar8 = (undefined4 *)((int)&paVar1->Via->Flags + CVar6 * 0x4c + -0x14);
  uVar4 = 0x4c;
  bVar9 = ((uint)puVar8 & 1) != 0;
  if (bVar9) {
    *(undefined *)puVar8 = 0;
    puVar8 = (undefined4 *)((int)puVar8 + 1);
    uVar4 = 0x4b;
  }
  if (((uint)puVar8 & 2) != 0) {
    *(undefined2 *)puVar8 = 0;
    uVar4 = uVar4 - 2;
    puVar8 = (undefined4 *)((int)puVar8 + 2);
  }
  for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
    *puVar8 = 0;
    puVar8 = puVar8 + (uint)bVar10 * -2 + 1;
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)puVar8 = 0;
    puVar8 = (undefined4 *)((int)puVar8 + 2);
  }
  if (bVar9) {
    *(undefined *)puVar8 = 0;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * DestroyText(LayerTypePtr Layer,TextTypePtr Text)

{
  TextTypePtr pTVar1;
  undefined3 uVar2;
  uint uVar3;
  uint uVar4;
  Cardinal CVar5;
  uchar *puVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  SaveFree(Text->TextString);
  Text->TextString = (char *)0x0;
  r_delete_entry(Layer->text_tree,&Text->BoundingBox);
  pTVar1 = Layer->Text;
  CVar5 = Layer->TextN - 1;
  Layer->TextN = CVar5;
  if (pTVar1 + CVar5 != Text) {
    (Text->BoundingBox).X1 = pTVar1[CVar5].BoundingBox.X1;
    (Text->BoundingBox).Y1 = pTVar1[CVar5].BoundingBox.Y1;
    (Text->BoundingBox).X2 = pTVar1[CVar5].BoundingBox.X2;
    (Text->BoundingBox).Y2 = pTVar1[CVar5].BoundingBox.Y2;
    Text->ID = pTVar1[CVar5].ID;
    (Text->Flags).f = pTVar1[CVar5].Flags.f;
    *(undefined4 *)(Text->Flags).t = *(undefined4 *)pTVar1[CVar5].Flags.t;
    *(undefined4 *)((Text->Flags).t + 4) = *(undefined4 *)(pTVar1[CVar5].Flags.t + 4);
    Text->net = pTVar1[CVar5].net;
    Text->Scale = pTVar1[CVar5].Scale;
    Text->X = pTVar1[CVar5].X;
    Text->Y = pTVar1[CVar5].Y;
    uVar2 = *(undefined3 *)&pTVar1[CVar5].field_0x31;
    Text->Direction = pTVar1[CVar5].Direction;
    *(undefined3 *)&Text->field_0x31 = uVar2;
    Text->TextString = pTVar1[CVar5].TextString;
    Text->Element = pTVar1[CVar5].Element;
    r_substitute(Layer->text_tree,&Layer->Text[Layer->TextN].BoundingBox,&Text->BoundingBox);
    CVar5 = Layer->TextN;
  }
  puVar6 = (&Layer->Text->Flags)[CVar5 * 5 + -2].t;
  uVar4 = 0x3c;
  bVar7 = ((uint)puVar6 & 1) != 0;
  if (bVar7) {
    *puVar6 = '\0';
    puVar6 = puVar6 + 1;
    uVar4 = 0x3b;
  }
  if (((uint)puVar6 & 2) != 0) {
    *(undefined2 *)puVar6 = 0;
    uVar4 = uVar4 - 2;
    puVar6 = puVar6 + 2;
  }
  for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
    *(undefined4 *)puVar6 = 0;
    puVar6 = puVar6 + ((uint)bVar8 * -2 + 1) * 4;
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)puVar6 = 0;
    puVar6 = puVar6 + 2;
  }
  if (bVar7) {
    *puVar6 = '\0';
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * DestroyLine(LayerTypePtr Layer,LineTypePtr Line)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  LineTypePtr pLVar4;
  Cardinal CVar5;
  LineTypePtr pLVar6;
  undefined4 *puVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  r_delete_entry(Layer->line_tree,&Line->BoundingBox);
  SaveFree(Line->Number);
  pLVar4 = Layer->Line;
  CVar5 = Layer->LineN - 1;
  Layer->LineN = CVar5;
  Line->Number = (char *)0x0;
  if (pLVar4 + CVar5 != Line) {
    pLVar4 = pLVar4 + CVar5;
    pLVar6 = Line;
    for (iVar1 = 0x16; iVar1 != 0; iVar1 = iVar1 + -1) {
      (pLVar6->BoundingBox).X1 = (pLVar4->BoundingBox).X1;
      pLVar4 = (LineTypePtr)((int)pLVar4 + (uint)bVar9 * -8 + 4);
      pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar9 * -8 + 4);
    }
    r_substitute(Layer->line_tree,&Layer->Line[Layer->LineN].BoundingBox,&Line->BoundingBox);
    CVar5 = Layer->LineN;
  }
  puVar7 = (undefined4 *)((int)&Layer->Line->Flags + CVar5 * 0x58 + -0x14);
  uVar3 = 0x58;
  bVar8 = ((uint)puVar7 & 1) != 0;
  if (bVar8) {
    *(undefined *)puVar7 = 0;
    puVar7 = (undefined4 *)((int)puVar7 + 1);
    uVar3 = 0x57;
  }
  if (((uint)puVar7 & 2) != 0) {
    *(undefined2 *)puVar7 = 0;
    uVar3 = uVar3 - 2;
    puVar7 = (undefined4 *)((int)puVar7 + 2);
  }
  for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
    *puVar7 = 0;
    puVar7 = puVar7 + (uint)bVar9 * -2 + 1;
  }
  if ((uVar3 & 2) != 0) {
    *(undefined2 *)puVar7 = 0;
    puVar7 = (undefined4 *)((int)puVar7 + 2);
  }
  if (bVar8) {
    *(undefined *)puVar7 = 0;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * DestroyPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PolygonTypePtr ppVar1;
  uint uVar2;
  uint uVar3;
  Cardinal CVar4;
  uchar *puVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  r_delete_entry(Layer->polygon_tree,&Polygon->BoundingBox);
  FreePolygonMemory(Polygon);
  ppVar1 = Layer->Polygon;
  CVar4 = Layer->PolygonN - 1;
  Layer->PolygonN = CVar4;
  if (ppVar1 + CVar4 != Polygon) {
    (Polygon->BoundingBox).X1 = ppVar1[CVar4].BoundingBox.X1;
    (Polygon->BoundingBox).Y1 = ppVar1[CVar4].BoundingBox.Y1;
    (Polygon->BoundingBox).X2 = ppVar1[CVar4].BoundingBox.X2;
    (Polygon->BoundingBox).Y2 = ppVar1[CVar4].BoundingBox.Y2;
    Polygon->ID = ppVar1[CVar4].ID;
    (Polygon->Flags).f = ppVar1[CVar4].Flags.f;
    *(undefined4 *)(Polygon->Flags).t = *(undefined4 *)ppVar1[CVar4].Flags.t;
    *(undefined4 *)((Polygon->Flags).t + 4) = *(undefined4 *)(ppVar1[CVar4].Flags.t + 4);
    Polygon->net = ppVar1[CVar4].net;
    Polygon->PointN = ppVar1[CVar4].PointN;
    Polygon->PointMax = ppVar1[CVar4].PointMax;
    Polygon->Clipped = ppVar1[CVar4].Clipped;
    Polygon->NoHoles = ppVar1[CVar4].NoHoles;
    Polygon->NoHolesValid = ppVar1[CVar4].NoHolesValid;
    Polygon->Points = ppVar1[CVar4].Points;
    r_substitute(Layer->polygon_tree,&Layer->Polygon[Layer->PolygonN].BoundingBox,
                 &Polygon->BoundingBox);
    CVar4 = Layer->PolygonN;
  }
  puVar5 = (&Layer->Polygon->Flags)[CVar4 * 5 + -2].t;
  uVar3 = 0x3c;
  bVar6 = ((uint)puVar5 & 1) != 0;
  if (bVar6) {
    *puVar5 = '\0';
    puVar5 = puVar5 + 1;
    uVar3 = 0x3b;
  }
  if (((uint)puVar5 & 2) != 0) {
    *(undefined2 *)puVar5 = 0;
    uVar3 = uVar3 - 2;
    puVar5 = puVar5 + 2;
  }
  for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
    *(undefined4 *)puVar5 = 0;
    puVar5 = puVar5 + ((uint)bVar7 * -2 + 1) * 4;
  }
  if ((uVar3 & 2) != 0) {
    *(undefined2 *)puVar5 = 0;
    puVar5 = puVar5 + 2;
  }
  if (bVar6) {
    *puVar5 = '\0';
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * RemoveRat(RatTypePtr Rat)

{
  if (PCB->RatOn != '\0') {
    EraseRat(Rat);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(0x20,Rat,Rat,Rat);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean DeleteRats(Boolean selected)

{
  RatTypePtr Rat;
  Boolean changed;
  char cVar1;
  RatTypePtr line;
  DataTypePtr paVar2;
  Cardinal n;
  int iVar3;
  int iVar4;
  
  Bulk = '\x01';
  paVar2 = PCB->Data;
  iVar3 = paVar2->RatN - 1;
  if (iVar3 == -1) {
    Bulk = '\0';
    cVar1 = '\0';
  }
  else {
    cVar1 = '\0';
    iVar4 = paVar2->RatN * 0x5c;
    while( true ) {
      Rat = (RatTypePtr)(paVar2->Rat[-1].Flags.t + iVar4 + -0x18);
      if ((selected == '\0') || ((*(byte *)&(Rat->Flags).f & 0x40) != 0)) {
        RemoveRat(Rat);
        cVar1 = '\x01';
      }
      iVar3 = iVar3 + -1;
      if (iVar3 == -1) break;
      paVar2 = PCB->Data;
      iVar4 = iVar4 + -0x5c;
    }
    Bulk = '\0';
    if (cVar1 != '\0') {
      Draw();
      IncrementUndoSerialNumber();
      cVar1 = '\x01';
    }
  }
  return cVar1;
}



// WARNING: Unknown calling convention

void * RemovePolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(8,Layer,Polygon,Polygon);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * DestroyPolygonPoint(LayerTypePtr Layer,PolygonTypePtr Polygon,PointTypePtr Point)

{
  Cardinal CVar1;
  PointTypePtr pPVar2;
  PointTypePtr pPVar3;
  PointTypePtr pPVar4;
  PointTypePtr ptr;
  void *pvVar5;
  
  if (3 < Polygon->PointN) {
    r_delete_entry(Layer->polygon_tree,&Polygon->BoundingBox);
    CVar1 = Polygon->PointN;
    pPVar2 = Polygon->Points;
    pPVar4 = Point + 1;
    while (pPVar3 = pPVar4, pPVar3 != pPVar2 + CVar1) {
      Point->X = pPVar3->X;
      Point->Y = pPVar3->Y;
      Point->X2 = pPVar3->X2;
      Point->Y2 = pPVar3->Y2;
      Point->ID = pPVar3->ID;
      Point = pPVar3;
      pPVar4 = pPVar3 + 1;
    }
    Polygon->PointN = CVar1 - 1;
    SetPolygonBoundingBox(Polygon);
    r_insert_entry(Layer->polygon_tree,&Polygon->BoundingBox,0);
    InitClip(PCB->Data,Layer,Polygon);
    return Polygon;
  }
  pvVar5 = RemovePolygon(Layer,Polygon);
  return pvVar5;
}



// WARNING: Unknown calling convention

void * RemovePolygonPoint(LayerTypePtr Layer,PolygonTypePtr Polygon,PointTypePtr Point)

{
  Cardinal CVar1;
  PointTypePtr pPVar2;
  PointTypePtr pPVar3;
  PointTypePtr pPVar4;
  void *pvVar5;
  Cardinal n;
  Cardinal index;
  PointTypePtr ptr;
  uint uVar6;
  
  uVar6 = Polygon->PointN;
  if (uVar6 < 4) {
    pvVar5 = RemovePolygon(Layer,Polygon);
    return pvVar5;
  }
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
    uVar6 = Polygon->PointN;
  }
  index = uVar6 - 1;
  if (index == 0xffffffff) {
LAB_080c18d6:
    index = 0;
  }
  else {
    pPVar4 = Polygon->Points + (uVar6 - 2);
    pPVar2 = Polygon->Points + index;
    while (pPVar3 = pPVar4, pPVar2 != Point) {
      index = index - 1;
      if (index == 0xffffffff) goto LAB_080c18d6;
      pPVar4 = pPVar3 + -1;
      pPVar2 = pPVar3;
    }
  }
  AddObjectToRemovePointUndoList(0x800,Layer,Polygon,index);
  r_delete_entry(Layer->polygon_tree,&Polygon->BoundingBox);
  CVar1 = Polygon->PointN;
  pPVar2 = Polygon->Points;
  pPVar4 = Point + 1;
  while (pPVar3 = pPVar4, pPVar3 != pPVar2 + CVar1) {
    Point->X = pPVar3->X;
    Point->Y = pPVar3->Y;
    Point->X2 = pPVar3->X2;
    Point->Y2 = pPVar3->Y2;
    Point->ID = pPVar3->ID;
    Point = pPVar3;
    pPVar4 = pPVar3 + 1;
  }
  Polygon->PointN = CVar1 - 1;
  SetPolygonBoundingBox(Polygon);
  r_insert_entry(Layer->polygon_tree,&Polygon->BoundingBox,0);
  RemoveExcessPolygonPoints(Layer,Polygon);
  InitClip(PCB->Data,Layer,Polygon);
  if ((Layer->On != '\0') && (DrawPolygon(Layer,Polygon,0), Bulk == '\0')) {
    Draw();
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

int remove_point(BoxType *b,void *cl)

{
  int *piVar1;
  
  if (*(BoxType **)((int)cl + 0x9c) != b) {
    piVar1 = *(int **)((int)cl + 0xa0);
    if ((b[2].Y2 == *piVar1) && (b[3].X1 == piVar1[1])) {
      *(BoxType **)((int)cl + 0x9c) = b;
      *(LocationType **)((int)cl + 0xa0) = &b[2].Y2;
                    // WARNING: Subroutine does not return
      __longjmp_chk(cl,1);
    }
    if ((*piVar1 == b[4].X1) && (b[4].Y1 == piVar1[1])) {
      *(BoxType **)((int)cl + 0x9c) = b;
      *(BoxType **)((int)cl + 0xa0) = b + 4;
                    // WARNING: Subroutine does not return
      __longjmp_chk(cl,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void * RemoveVia(PinTypePtr Via)

{
  if (PCB->ViaOn != '\0') {
    EraseVia(Via);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(1,Via,Via,Via);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean RemoveSelected(void)

{
  Boolean BVar1;
  
  Bulk = '\x01';
  BVar1 = SelectedOperation((ObjectFunctionTypePtr)&RemoveFunctions,'\0',-1);
  if (BVar1 == '\0') {
    Bulk = '\0';
    return '\0';
  }
  IncrementUndoSerialNumber();
  Draw();
  Bulk = '\0';
  return '\x01';
}



// WARNING: Unknown calling convention

void * RemoveElement(ElementTypePtr Element)

{
  if (((PCB->ElementOn != '\0') || (PCB->PinOn != '\0')) &&
     ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (PCB->InvisibleObjectsOn != '\0')))) {
    EraseElement(Element);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(2,Element,Element,Element);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * RemoveText(LayerTypePtr Layer,TextTypePtr Text)

{
  if (Layer->On != '\0') {
    EraseText(Layer,Text);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(0x10,Layer,Text,Text);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * RemoveArc(LayerTypePtr Layer,ArcTypePtr Arc)

{
  if (Layer->On != '\0') {
    EraseArc(Arc);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(0x4000,Layer,Arc,Arc);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * RemoveLine(LayerTypePtr Layer,LineTypePtr Line)

{
  if (Layer->On != '\0') {
    EraseLine(Line);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(4,Layer,Line,Line);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * RemoveLinePoint(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr Point)

{
  int iVar1;
  void *pvVar2;
  LocationType local_c4;
  LocationType local_c0;
  rlp_info info;
  
  if (&Line->Point1 == Point) {
    local_c4 = (Line->Point2).X;
    local_c0 = (Line->Point2).Y;
  }
  else {
    local_c4 = (Line->Point1).X;
    local_c0 = (Line->Point1).Y;
  }
  info.line = Line;
  info.point = Point;
  iVar1 = _setjmp((__jmp_buf_tag *)&info);
  if (iVar1 != 0) {
    MoveObject(0x1000,Layer,info.line,info.point,local_c4 - Point->X,local_c0 - Point->Y);
    pvVar2 = RemoveLine(Layer,Line);
    return pvVar2;
  }
  r_search(Layer->line_tree,(BoxType *)Point,(_func_int_BoxType_ptr_void_ptr *)0x0,remove_point,
           &info);
  pvVar2 = RemoveLine(Layer,Line);
  return pvVar2;
}



// WARNING: Unknown calling convention

void RemovePCB(PCBTypePtr Ptr)

{
  ClearUndoList('\x01');
  FreePCBMemory(Ptr);
  SaveFree(Ptr);
  return;
}



// WARNING: Unknown calling convention

double XYtoNetLength(int x,int y,int *found)

{
  LineTypePtr pLVar1;
  int iVar2;
  int iVar3;
  DataTypePtr paVar4;
  uint uVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  PCBTypePtr pPVar9;
  Cardinal n;
  int iVar10;
  FlagType *pFVar11;
  int iVar12;
  LineTypePtr line;
  Cardinal n_1;
  LayerTypePtr layer;
  LayerType *pLVar13;
  LayerTypePtr layer_1;
  double length;
  uint local_28;
  
  *found = 0;
  LookupConnection(x,y,'\x01',(int)ROUND(PCB->Grid),4);
  pPVar9 = PCB;
  pLVar13 = PCB->Data->Layer;
  if (PCB->Data->LayerN == -2) {
    return 0.0;
  }
  local_28 = 0;
  dVar6 = 0.0;
  do {
    iVar10 = pLVar13->LineN - 1;
    if (iVar10 != -1) {
      iVar12 = pLVar13->LineN * 0x58 + -0x58;
      do {
        while (pLVar1 = pLVar13->Line, ((pLVar1->Flags).t[iVar12 + -4] & 4) != 0) {
          iVar10 = iVar10 + -1;
          iVar2 = *(int *)((int)&((PointType *)(&pLVar1->Flags + 2))->Y + iVar12);
          iVar3 = *(int *)((int)(&pLVar1->Flags + 4) + iVar12);
          dVar7 = (double)(*(int *)((int)&((PointType *)(&pLVar1->Flags + 2))->Y + iVar12 + -4) -
                          *(int *)((int)(&pLVar1->Flags + 3) + iVar12 + 8));
          *found = 1;
          dVar8 = (double)(iVar2 - iVar3);
          dVar6 = SQRT(dVar8 * dVar8 + dVar7 * dVar7) + dVar6;
          iVar12 = iVar12 + -0x58;
          if (iVar10 == -1) goto LAB_080c1eed;
        }
        iVar10 = iVar10 + -1;
        iVar12 = iVar12 + -0x58;
      } while (iVar10 != -1);
    }
LAB_080c1eed:
    local_28 = local_28 + 1;
    paVar4 = pPVar9->Data;
    if (paVar4->LayerN + 2U <= local_28) {
      pLVar13 = paVar4->Layer;
      if (paVar4->LayerN == -2) {
        return dVar6;
      }
      local_28 = 0;
      while( true ) {
        iVar10 = pLVar13->ArcN - 1;
        if (iVar10 != -1) {
          pFVar11 = &pLVar13->Arc[pLVar13->ArcN - 1].Flags;
          do {
            if ((*(byte *)&pFVar11->f & 4) != 0) {
              iVar2 = *(long *)((int)(pFVar11 + 3) + 8);
              uVar5 = *(long *)((int)(pFVar11 + 3) + 8);
              iVar12 = *(int *)(pFVar11 + 2);
              *found = 1;
              dVar6 = ((double)((uVar5 ^ iVar2 >> 0x1f) - (iVar2 >> 0x1f)) *
                      (double)iVar12 * 6.283185307179586) / 360.0 + dVar6;
            }
            iVar10 = iVar10 + -1;
            pFVar11 = (FlagType *)((int)(pFVar11 + -6) + 4);
          } while (iVar10 != -1);
        }
        local_28 = local_28 + 1;
        if (paVar4->LayerN + 2U <= local_28) break;
        pLVar13 = pLVar13 + 1;
      }
      return dVar6;
    }
    pLVar13 = pLVar13 + 1;
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x080c3330)
// WARNING: Removing unreachable block (ram,0x080c3327)
// WARNING: Removing unreachable block (ram,0x080c3332)
// WARNING: Unknown calling convention

int ReportDialog(int argc,char **argv,int x,int y)

{
  int iVar1;
  undefined uVar2;
  BDimension BVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  LocationType LVar9;
  LocationType LVar10;
  LocationType LVar11;
  LocationType LVar12;
  LocationType LVar13;
  LocationType LVar14;
  long lVar15;
  LocationType LVar16;
  LocationType LVar17;
  float fVar18;
  float fVar19;
  double dVar20;
  float fVar21;
  float fVar22;
  float fVar23;
  float fVar24;
  int iVar25;
  int type;
  int iVar26;
  ArcTypePtr paVar27;
  char *pcVar28;
  BoxTypePtr pBVar29;
  char *pcVar30;
  Cardinal sn;
  Cardinal sn_1;
  ArcTypePtr paVar31;
  Cardinal n;
  int iVar32;
  char *pcVar33;
  char *pcVar34;
  undefined1 *puVar35;
  TextTypePtr pTVar36;
  Cardinal n_1;
  LineTypePtr line;
  RatTypePtr line_1;
  PinTypePtr via;
  PadTypePtr Pad;
  PinTypePtr Pin;
  PolygonTypePtr Polygon;
  ArcTypePtr Arc;
  ElementTypePtr element_2;
  PointTypePtr point;
  ElementTypePtr element;
  undefined1 *puVar37;
  ElementTypePtr element_1;
  undefined1 *puVar38;
  rtree_t *prVar39;
  BoxTypePtr box;
  int in_GS_OFFSET;
  bool bVar40;
  long lVar41;
  LocationType LVar42;
  LocationType LVar43;
  undefined8 uVar44;
  int iVar45;
  undefined1 *local_880;
  undefined1 *local_87c;
  undefined1 *local_878;
  undefined1 *local_874;
  undefined1 *local_870;
  undefined1 *local_86c;
  undefined1 *local_868;
  undefined1 *local_864;
  undefined1 *local_860;
  undefined1 *local_85c;
  undefined1 *local_858;
  void *ptr3;
  ArcTypePtr local_848;
  LayerTypePtr local_844;
  char report [2048];
  char laynum [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar25 = SearchScreen(x,y,0x5f3f,&local_844,&local_848,&ptr3);
  if (iVar25 == 0) {
    iVar25 = SearchScreen(x,y,0x15f3f,&local_844,&local_848,&ptr3);
    iVar26 = iVar25 + -0x20;
    bVar40 = iVar26 == 0;
    if (bVar40) goto LAB_080c22f1;
LAB_080c202e:
    if (!bVar40 && SBORROW4(iVar25,0x20) == iVar26 < 0) {
      if (iVar25 == 0x400) {
LAB_080c2558:
        if (iVar25 == 0x10) {
          iVar26 = GetLayerNumber(PCB->Data,local_844);
          __sprintf_chk(laynum,1,0x20,"is on layer %d",iVar26);
        }
        pcVar33 = "";
        LVar43 = (local_848->BoundingBox).Y2;
        if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
          pcVar33 = "It is LOCKED\n";
        }
        pcVar34 = "is an element name.";
        if (iVar25 == 0x10) {
          pcVar34 = laynum;
        }
        LVar42 = (local_848->BoundingBox).X2;
        LVar9 = (local_848->BoundingBox).Y1;
        LVar10 = (local_848->BoundingBox).X1;
        LVar11 = local_848->X;
        uVar2 = *(undefined *)&local_848->Height;
        if (Settings.grid_units_mm == '\0') {
          local_858 = &DAT_08147f6c;
          dVar20 = ((double)local_848->Thickness * 0.45 * 100.0) / 100.0;
        }
        else {
          local_858 = &DAT_0815627e;
          dVar20 = (((double)local_848->Thickness * 0.45 * 100.0) / 100000.0) * 25.4;
        }
        LVar12 = local_848->Width;
        BVar3 = local_848->Clearance;
        pcVar28 = flags_to_string(local_848->Flags,0x10);
        __sprintf_chk(report,1,0x800,
                      "TEXT ID# %ld   Flags:%s\nLocated at (X,Y) = (%d,%d)\nCharacters are %0.2f %s tall\nValue is \"%s\"\nDirection is %d\nThe bounding box is (%d,%d) (%d, %d)\nIt %s\n%s"
                      ,local_848->ID,pcVar28,BVar3,LVar12,dVar20,local_858,LVar11,uVar2,LVar10,LVar9
                      ,LVar42,LVar43,pcVar34,pcVar33);
      }
      else if (iVar25 < 0x401) {
        if (iVar25 == 0x100) {
          if (local_844[2].Text != (TextTypePtr)0x0) {
            paVar27 = (ArcTypePtr)local_844[2].Color;
            pTVar36 = (TextTypePtr)&DAT_00000001;
            if (local_848 != paVar27) {
              while ((pTVar36 < local_844[2].Text &&
                     (paVar27 = (ArcTypePtr)&paVar27[1].BoundingBox.X2, paVar27 != local_848))) {
                pTVar36 = (TextTypePtr)((int)&(pTVar36->BoundingBox).X1 + 1);
              }
            }
          }
          uVar8 = (local_848->Flags).f;
          if ((uVar8 & 8) == 0) {
            prVar39 = local_844[1].text_tree;
            pcVar33 = "It is LOCKED\n";
            puVar37 = (undefined1 *)local_848->StartAngle;
            if ((uVar8 & 0x2000) == 0) {
              pcVar33 = "";
            }
            puVar35 = (undefined1 *)local_848->Delta;
            if (puVar35 == (undefined1 *)0x0) {
              puVar35 = &DAT_0814741b;
            }
            if (prVar39 == (rtree_t *)0x0) {
              prVar39 = (rtree_t *)&DAT_0814741b;
            }
            if (puVar37 == (undefined1 *)0x0) {
              puVar37 = &DAT_0814741b;
            }
            if (Settings.grid_units_mm == '\0') {
              iVar25 = local_848->Thickness;
              local_868 = &DAT_08147f6c;
              local_86c = &DAT_08147f6c;
              local_870 = &DAT_08147f6c;
              local_874 = &DAT_08147f6c;
              fVar24 = (float)((local_848->Width - iVar25) / 2) / 100.0;
              local_864 = &DAT_08147f6c;
              local_860 = &DAT_08147f6c;
              fVar23 = (float)local_848->Width / 100.0;
              fVar22 = (float)((iVar25 - local_848->Height) / 2) / 100.0;
              fVar21 = ((float)local_848->Clearance * 0.5) / 100.0;
              fVar19 = (float)local_848->Height / 100.0;
              fVar18 = 100.0 / (float)iVar25;
            }
            else {
              iVar25 = local_848->Thickness;
              local_868 = &DAT_0815627e;
              local_86c = &DAT_0815627e;
              local_870 = &DAT_0815627e;
              local_874 = &DAT_0815627e;
              local_864 = &DAT_0815627e;
              local_860 = &DAT_0815627e;
              fVar24 = ((float)((local_848->Width - iVar25) / 2) / 100000.0) * 25.4;
              fVar23 = ((float)local_848->Width / 100000.0) * 25.4;
              fVar22 = ((float)((iVar25 - local_848->Height) / 2) / 100000.0) * 25.4;
              fVar21 = (((float)local_848->Clearance * 0.5) / 100000.0) * 25.4;
              fVar19 = ((float)local_848->Height / 100000.0) * 25.4;
              fVar18 = (100000.0 / (float)iVar25) * 25.4;
            }
            LVar43 = local_848->Y;
            LVar42 = local_848->X;
            pcVar34 = flags_to_string(local_848->Flags,0x100);
            __sprintf_chk(report,1,0x800,
                          "PIN ID# %ld   Flags:%s\n(X,Y) = (%d, %d)\nCopper width = %0.2f %s  Drill width = %0.2f %s\nClearance width to Polygon = %0.2f %s\nAnnulus = %0.2f %s\nSolder mask hole = %0.2f %s (gap = %0.2f %s)\nName = \"%s\"\nIt is owned by element %s\nAs pin number %s\n%s"
                          ,local_848->ID,pcVar34,LVar42,LVar43,(double)fVar18,local_860,
                          (double)fVar19,local_864,(double)fVar21,local_868,(double)fVar22,local_86c
                          ,(double)fVar23,local_870,(double)fVar24,local_874,puVar37,prVar39,puVar35
                          ,pcVar33);
          }
          else {
            prVar39 = local_844[1].text_tree;
            pcVar33 = "It is LOCKED\n";
            if ((uVar8 & 0x2000) == 0) {
              pcVar33 = "";
            }
            if (prVar39 == (rtree_t *)0x0) {
              prVar39 = (rtree_t *)&DAT_0814741b;
            }
            if (Settings.grid_units_mm == '\0') {
              fVar18 = (float)local_848->Height / 100.0;
              local_858 = &DAT_08147f6c;
            }
            else {
              local_858 = &DAT_0815627e;
              fVar18 = ((float)local_848->Height / 100000.0) * 25.4;
            }
            LVar43 = local_848->Y;
            LVar42 = local_848->X;
            pcVar34 = flags_to_string(local_848->Flags,0x100);
            lVar41 = local_848->ID;
            pcVar28 = 
            "PIN ID# %ld  Flags:%s\n(X,Y) = (%d, %d)\nIt is a mounting hole, Drill width = %0.2f %s\nIt is owned by element %s\n%s"
            ;
LAB_080c2b07:
            __sprintf_chk(report,1,0x800,pcVar28,lVar41,pcVar34,LVar42,LVar43,(double)fVar18,
                          local_858,prVar39,pcVar33);
          }
        }
        else {
          if (iVar25 != 0x200) goto LAB_080c206e;
          if (local_844[2].Arc != (ArcTypePtr)0x0) {
            paVar27 = (ArcTypePtr)local_844[2].SelectedColor;
            paVar31 = (ArcTypePtr)&DAT_00000001;
            if (local_848 != paVar27) {
              while ((paVar31 < local_844[2].Arc &&
                     (paVar27 = (ArcTypePtr)&paVar27[1].Thickness, paVar27 != local_848))) {
                paVar31 = (ArcTypePtr)((int)&(paVar31->BoundingBox).X1 + 1);
              }
            }
          }
          iVar26 = local_848->Delta;
          iVar45 = local_848->Width;
          iVar4 = local_848[1].BoundingBox.X1;
          iVar25 = iVar45 - iVar26;
          iVar5 = local_848->Height;
          iVar32 = iVar5 - iVar4;
          iVar6 = local_848[1].ID;
          iVar7 = local_848->Thickness;
          uVar8 = (local_848->Flags).f;
          iVar25 = (int)ROUND(SQRT((double)(iVar32 * iVar32 + iVar25 * iVar25)));
          iVar32 = (iVar6 - iVar7) / 2;
          pcVar33 = "It is LOCKED\n";
          if ((uVar8 & 0x2000) == 0) {
            pcVar33 = "";
          }
          prVar39 = local_844[1].text_tree;
          pcVar34 = "solder (bottom)";
          puVar37 = (undefined1 *)local_848[1].Flags.f;
          if (-1 < (char)uVar8) {
            pcVar34 = "component";
          }
          puVar35 = *(undefined1 **)local_848[1].Flags.t;
          if (puVar35 == (undefined1 *)0x0) {
            puVar35 = &DAT_0814741b;
          }
          if (prVar39 == (rtree_t *)0x0) {
            prVar39 = (rtree_t *)&DAT_0814741b;
          }
          if (puVar37 == (undefined1 *)0x0) {
            puVar37 = &DAT_0814741b;
          }
          if (Settings.grid_units_mm == '\0') {
            fVar18 = (float)iVar32 / 100.0;
            local_860 = &DAT_08147f6c;
            local_878 = &DAT_08147f6c;
            local_87c = &DAT_08147f6c;
            local_874 = &DAT_08147f6c;
            local_880 = &DAT_08147f6c;
            fVar19 = (float)(iVar25 + iVar6) / 100.0;
            fVar21 = (float)iVar6 / 100.0;
            fVar22 = ((float)local_848->Clearance * 0.5) / 100.0;
            fVar23 = (float)(iVar25 + iVar7) / 100.0;
            fVar24 = 100.0 / (float)iVar7;
          }
          else {
            local_860 = &DAT_0815627e;
            local_878 = &DAT_0815627e;
            local_87c = &DAT_0815627e;
            local_874 = &DAT_0815627e;
            local_880 = &DAT_0815627e;
            fVar18 = ((float)iVar32 / 100000.0) * 25.4;
            fVar19 = ((float)(iVar25 + iVar6) / 100000.0) * 25.4;
            fVar21 = ((float)iVar6 / 100000.0) * 25.4;
            fVar22 = (((float)local_848->Clearance * 0.5) / 100000.0) * 25.4;
            fVar23 = ((float)(iVar25 + iVar7) / 100000.0) * 25.4;
            fVar24 = (100000.0 / (float)iVar7) * 25.4;
          }
          LVar43 = local_848[1].BoundingBox.Y2;
          lVar41 = local_848->StartAngle;
          pcVar28 = flags_to_string(local_848->Flags,0x200);
          __sprintf_chk(report,1,0x800,
                        "PAD ID# %ld   Flags:%s\nFirstPoint(X,Y)  = (%d, %d)  ID = %ld\nSecondPoint(X,Y) = (%d, %d)  ID = %ld\nWidth = %0.2f %s.  Length = %0.2f %s.\nClearance width in polygons = %0.2f %s.\nSolder mask = %0.2f x %0.2f %s (gap = %0.2f %s).\nName = \"%s\"\nIt is owned by SMD element %s\nAs pin number %s and is on the %s\nside of the board.\n%s"
                        ,local_848->ID,pcVar28,iVar45,iVar5,lVar41,iVar26,iVar4,LVar43,
                        (double)fVar24,local_860,(double)fVar23,local_874,(double)fVar22,local_878,
                        (double)fVar21,(double)fVar19,local_87c,(double)fVar18,local_880,puVar37,
                        prVar39,puVar35,pcVar34,pcVar33);
        }
      }
      else {
        if (iVar25 != 0x1000) {
          if (iVar25 == 0x4000) {
            pcVar33 = "";
            pBVar29 = GetArcEnds(local_848);
            if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
              pcVar33 = "It is LOCKED\n";
            }
            iVar25 = GetLayerNumber(PCB->Data,local_844);
            LVar43 = pBVar29->X2;
            LVar42 = (local_848->BoundingBox).Y2;
            LVar9 = pBVar29->Y2;
            LVar10 = (local_848->BoundingBox).Y1;
            LVar11 = pBVar29->Y1;
            LVar12 = pBVar29->X1;
            lVar41 = local_848->Delta;
            LVar13 = (local_848->BoundingBox).X2;
            LVar14 = (local_848->BoundingBox).X1;
            lVar15 = local_848->StartAngle;
            if (Settings.grid_units_mm == '\0') {
              local_860 = &DAT_08147f6c;
              local_858 = &DAT_08147f6c;
              local_85c = &DAT_08147f6c;
              fVar18 = ((float)local_848->Clearance * 0.5) / 100.0;
              fVar19 = (float)local_848->Thickness / 100.0;
              fVar21 = 100.0 / (float)local_848->Width;
            }
            else {
              local_860 = &DAT_0815627e;
              local_858 = &DAT_0815627e;
              local_85c = &DAT_0815627e;
              fVar18 = (((float)local_848->Clearance * 0.5) / 100000.0) * 25.4;
              fVar19 = ((float)local_848->Thickness / 100000.0) * 25.4;
              fVar21 = (100000.0 / (float)local_848->Width) * 25.4;
            }
            LVar16 = local_848->Y;
            LVar17 = local_848->X;
            pcVar34 = flags_to_string(local_848->Flags,0x4000);
            __sprintf_chk(report,1,0x800,
                          "ARC ID# %ld   Flags:%s\nCenterPoint(X,Y) = (%d, %d)\nRadius = %0.2f %s, Thickness = %0.2f %s\nClearance width in polygons = %0.2f %s\nStartAngle = %ld degrees, DeltaAngle = %ld degrees\nBounding Box is (%d,%d), (%d,%d)\nThat makes the end points at (%d,%d) and (%d,%d)\nIt is on layer %d\n%s"
                          ,local_848->ID,pcVar34,LVar17,LVar16,(double)fVar21,local_858,
                          (double)fVar19,local_85c,(double)fVar18,local_860,lVar15,lVar41,LVar14,
                          LVar10,LVar13,LVar42,LVar12,LVar11,LVar43,LVar9,iVar25,pcVar33);
            goto LAB_080c2098;
          }
          if (iVar25 != 0x800) goto LAB_080c206e;
        }
        iVar26 = GetLayerNumber(PCB->Data,local_844);
        pcVar33 = "polygon";
        if (iVar25 == 0x1000) {
          pcVar33 = "line";
        }
        __sprintf_chk(report,1,0x800,
                      "POINT ID# %ld. Points don\'t have flags.\nLocated at (X,Y) = (%d,%d)\nIt belongs to a %s on layer %d\n"
                      ,local_848->ID,(local_848->BoundingBox).X1,(local_848->BoundingBox).Y1,pcVar33
                      ,iVar26);
      }
      goto LAB_080c2098;
    }
    if (iVar25 == 2) {
      pcVar34 = "";
      pcVar33 = "It is LOCKED\n";
      uVar8 = (local_848->Flags).f;
      if ((uVar8 & 0x2000) == 0) {
        pcVar33 = "";
      }
      pcVar28 = "component";
      if ((char)uVar8 < '\0') {
        pcVar28 = "solder (bottom)";
      }
      lVar41 = local_848[3].ID;
      if ((uVar8 & 0x10) != 0) {
        pcVar34 = "But it\'s hidden\n";
      }
      LVar43 = local_848[2].BoundingBox.Y1;
      LVar42 = local_848[2].BoundingBox.X1;
      LVar9 = local_848[3].BoundingBox.Y2;
      if (Settings.grid_units_mm == '\0') {
        local_868 = &DAT_08147f6c;
        dVar20 = ((double)local_848[1].Delta * 0.45 * 100.0) / 100.0;
      }
      else {
        local_868 = &DAT_0815627e;
        dVar20 = (((double)local_848[1].Delta * 0.45 * 100.0) / 100000.0) * 25.4;
      }
      puVar37 = (undefined1 *)local_848[3].BoundingBox.Y1;
      puVar35 = (undefined1 *)local_848[2].BoundingBox.Y2;
      puVar38 = (undefined1 *)local_848[1].Flags.f;
      if (puVar37 == (undefined1 *)0x0) {
        puVar37 = &DAT_0814741b;
      }
      if (puVar35 == (undefined1 *)0x0) {
        puVar35 = &DAT_0814741b;
      }
      if (puVar38 == (undefined1 *)0x0) {
        puVar38 = &DAT_0814741b;
      }
      LVar10 = (local_848->BoundingBox).Y2;
      LVar11 = (local_848->BoundingBox).X2;
      LVar12 = (local_848->BoundingBox).Y1;
      LVar13 = (local_848->BoundingBox).X1;
      pcVar30 = flags_to_string(local_848->Flags,2);
      __sprintf_chk(report,1,0x800,
                    "ELEMENT ID# %ld   Flags:%s\nBoundingBox (%d,%d) (%d,%d)\nDescriptive Name \"%s\"\nName on board \"%s\"\nPart number name \"%s\"\nIt is %0.2f %s tall and is located at (X,Y) = (%d,%d)\n%sMark located at point (X,Y) = (%d,%d)\nIt is on the %s side of the board.\n%s"
                    ,local_848->ID,pcVar30,LVar13,LVar12,LVar11,LVar10,puVar38,puVar35,puVar37,
                    SUB84(dVar20,0),(int)((ulonglong)dVar20 >> 0x20),local_868,LVar42,LVar43,pcVar34
                    ,LVar9,lVar41,pcVar28,pcVar33);
      goto LAB_080c2098;
    }
    if (2 < iVar25) {
      if (iVar25 != 8) {
        if (iVar25 == 0x10) goto LAB_080c2558;
        if (iVar25 != 4) goto LAB_080c206e;
        pcVar34 = "";
        pcVar33 = (char *)local_848[1].ID;
        if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
          pcVar34 = "It is LOCKED\n";
        }
        if ((pcVar33 == (char *)0x0) || (*pcVar33 == '\0')) {
          pcVar33 = "(unknown)";
        }
        iVar25 = GetLayerNumber(PCB->Data,local_844);
        if (Settings.grid_units_mm == '\0') {
          local_868 = &DAT_08147f6c;
          local_86c = &DAT_08147f6c;
          fVar18 = ((float)local_848->Clearance * 0.5) / 100.0;
          fVar19 = (float)local_848->Thickness / 100.0;
        }
        else {
          local_868 = &DAT_0815627e;
          local_86c = &DAT_0815627e;
          fVar18 = (((float)local_848->Clearance * 0.5) / 100000.0) * 25.4;
          fVar19 = (100000.0 / (float)local_848->Thickness) * 25.4;
        }
        lVar41 = local_848->Delta;
        LVar43 = local_848[1].BoundingBox.Y2;
        LVar42 = local_848[1].BoundingBox.X1;
        lVar15 = local_848->StartAngle;
        LVar9 = local_848->Height;
        LVar10 = local_848->Width;
        pcVar28 = flags_to_string(local_848->Flags,4);
        __sprintf_chk(report,1,0x800,
                      "LINE ID# %ld   Flags:%s\nFirstPoint(X,Y) = (%d, %d)  ID = %ld\nSecondPoint(X,Y) = (%d, %d)  ID = %ld\nWidth = %0.2f %s.\nClearance width in polygons = %0.2f %s.\nIt is on layer %d\nand has name %s\n%s"
                      ,local_848->ID,pcVar28,LVar10,LVar9,lVar15,lVar41,LVar42,LVar43,(double)fVar19
                      ,local_868,(double)fVar18,local_86c,iVar25,pcVar33,pcVar34);
        goto LAB_080c2098;
      }
      pcVar33 = "";
      if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
        pcVar33 = "It is LOCKED\n";
      }
      iVar26 = GetLayerNumber(PCB->Data,local_844);
      iVar45 = local_848->Thickness;
      iVar25 = local_848->Clearance - iVar45;
      uVar44._0_4_ = (local_848->BoundingBox).X2;
      uVar44._4_4_ = (local_848->BoundingBox).Y2;
      LVar43 = (local_848->BoundingBox).Y1;
      LVar42 = (local_848->BoundingBox).X1;
      pcVar34 = flags_to_string(local_848->Flags,8);
      lVar41 = local_848->ID;
      pcVar28 = 
      "POLYGON ID# %ld   Flags:%s\nIts bounding box is (%d,%d) (%d,%d)\nIt has %d points and could store %d more\nwithout using more memory.\nIt resides on layer %d\n%s"
      ;
      goto LAB_080c2c15;
    }
    if (iVar25 != 0) {
      if (iVar25 == 1) {
        uVar8 = (local_848->Flags).f;
        if ((uVar8 & 8) != 0) {
          prVar39 = (rtree_t *)local_848->StartAngle;
          pcVar33 = "It is LOCKED\n";
          if ((uVar8 & 0x2000) == 0) {
            pcVar33 = "";
          }
          if (prVar39 == (rtree_t *)0x0) {
            prVar39 = (rtree_t *)&DAT_0814741b;
          }
          if (Settings.grid_units_mm == '\0') {
            fVar18 = (float)local_848->Height / 100.0;
            local_858 = &DAT_08147f6c;
          }
          else {
            local_858 = &DAT_0815627e;
            fVar18 = ((float)local_848->Height / 100000.0) * 25.4;
          }
          LVar43 = local_848->Y;
          LVar42 = local_848->X;
          pcVar34 = flags_to_string(local_848->Flags,1);
          lVar41 = local_848->ID;
          pcVar28 = 
          "VIA ID# %ld  Flags:%s\n(X,Y) = (%d, %d)\nIt is a pure hole of diameter %0.2f %s\nName = \"%s\"%s"
          ;
          goto LAB_080c2b07;
        }
        puVar37 = (undefined1 *)local_848->StartAngle;
        pcVar33 = "It is LOCKED\n";
        if ((uVar8 & 0x2000) == 0) {
          pcVar33 = "";
        }
        if (puVar37 == (undefined1 *)0x0) {
          puVar37 = &DAT_0814741b;
        }
        if (Settings.grid_units_mm == '\0') {
          iVar25 = local_848->Thickness;
          local_85c = &DAT_08147f6c;
          local_860 = &DAT_08147f6c;
          fVar24 = (float)((local_848->Width - iVar25) / 2) / 100.0;
          local_864 = &DAT_08147f6c;
          local_868 = &DAT_08147f6c;
          local_86c = &DAT_08147f6c;
          local_870 = &DAT_08147f6c;
          fVar23 = (float)local_848->Width / 100.0;
          fVar22 = (float)((iVar25 - local_848->Height) / 2) / 100.0;
          fVar21 = ((float)local_848->Clearance * 0.5) / 100.0;
          fVar19 = (float)local_848->Height / 100.0;
          fVar18 = 100.0 / (float)iVar25;
        }
        else {
          iVar25 = local_848->Thickness;
          local_85c = &DAT_0815627e;
          local_860 = &DAT_0815627e;
          local_864 = &DAT_0815627e;
          local_868 = &DAT_0815627e;
          local_86c = &DAT_0815627e;
          local_870 = &DAT_0815627e;
          fVar24 = ((float)((local_848->Width - iVar25) / 2) / 100000.0) * 25.4;
          fVar23 = ((float)local_848->Width / 100000.0) * 25.4;
          fVar22 = ((float)((iVar25 - local_848->Height) / 2) / 100000.0) * 25.4;
          fVar21 = (((float)local_848->Clearance * 0.5) / 100000.0) * 25.4;
          fVar19 = ((float)local_848->Height / 100000.0) * 25.4;
          fVar18 = (100000.0 / (float)iVar25) * 25.4;
        }
        LVar43 = local_848->Y;
        LVar42 = local_848->X;
        pcVar34 = flags_to_string(local_848->Flags,1);
        __sprintf_chk(report,1,0x800,
                      "VIA ID# %ld   Flags:%s\n(X,Y) = (%d, %d)\nCopper width = %0.2f %s  Drill width = %0.2f %s\nClearance width in polygons = %0.2f %s\nAnnulus = %0.2f %s\nSolder mask hole = %0.2f %s (gap = %0.2f %s)\nName = \"%s\"%s"
                      ,local_848->ID,pcVar34,LVar42,LVar43,(double)fVar18,local_85c,(double)fVar19,
                      local_860,(double)fVar21,local_864,(double)fVar22,local_868,(double)fVar23,
                      local_86c,(double)fVar24,local_870,puVar37,pcVar33);
      }
      else {
LAB_080c206e:
        __sprintf_chk(report,1,0x800,"Unknown\n");
      }
      goto LAB_080c2098;
    }
    report[0] = '\0';
  }
  else {
    iVar26 = iVar25 + -0x20;
    bVar40 = iVar25 == 0x20;
    if (!bVar40) goto LAB_080c202e;
LAB_080c22f1:
    lVar41 = local_848[1].ID;
    pcVar33 = (char *)local_848[1].Flags.f;
    iVar25 = local_848[1].BoundingBox.X1;
    iVar45 = local_848->Delta;
    lVar15 = local_848->StartAngle;
    iVar26 = local_848[1].BoundingBox.Y2;
    LVar43 = local_848->Height;
    LVar42 = local_848->Width;
    pcVar34 = flags_to_string(local_848->Flags,4);
    uVar44 = CONCAT44(lVar41,lVar15);
    lVar41 = local_848->ID;
    pcVar28 = 
    "RAT-LINE ID# %ld   Flags:%s\nFirstPoint(X,Y) = (%d, %d) ID = %ld connects to layer group %d\nSecondPoint(X,Y) = (%d, %d) ID = %ld connects to layer group %d\n"
    ;
LAB_080c2c15:
    __sprintf_chk(report,1,0x800,pcVar28,lVar41,pcVar34,LVar42,LVar43,uVar44,iVar45,iVar25,iVar26,
                  pcVar33);
LAB_080c2098:
    if (report[0] != '\0') {
      HideCrosshair('\0');
      (*gui->report_dialog)("Report",report);
      RestoreCrosshair('\0');
      iVar25 = 0;
      goto LAB_080c20d5;
    }
  }
  Message("Nothing found to report on\n");
  iVar25 = 1;
LAB_080c20d5:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar25;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int Report(int argc,char **argv,int x,int y)

{
  Cardinal *pCVar1;
  Cardinal *pCVar2;
  Cardinal *pCVar3;
  int iVar4;
  char cVar5;
  Cardinal CVar6;
  ElementTypePtr paVar7;
  LibraryEntryTypePtr paVar8;
  int iVar9;
  Cardinal sn;
  undefined4 uVar10;
  Cardinal sn_1;
  DrillInfoTypePtr d;
  int *piVar11;
  LibraryMenuTypePtr paVar12;
  char *ename;
  char *pcVar13;
  char *pcVar14;
  char *es;
  DataTypePtr paVar15;
  PinTypePtr pin_1;
  int iVar16;
  LibraryMenuTypePtr paVar17;
  undefined1 *puVar18;
  Cardinal sn_2;
  PinTypePtr pin;
  int iVar19;
  Cardinal n_2;
  char *ename_2;
  char *ename_1;
  DrillTypePtr pDVar20;
  PadTypePtr pad_1;
  ElementTypePtr element;
  int total_drills;
  PinTypePtr paVar21;
  char *netname;
  char *pcVar22;
  PadTypePtr paVar23;
  int nei_1;
  uint uVar24;
  uint uVar25;
  Cardinal n_1;
  Cardinal n;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  LocationType x_00;
  int col;
  LocationType y_00;
  int in_GS_OFFSET;
  double length;
  double dVar29;
  uint local_98;
  uint local_94;
  int local_90;
  int local_8c;
  uint local_88;
  PCBTypePtr local_84;
  PCBTypePtr local_80;
  int local_7c;
  Cardinal *local_78;
  int found;
  int local_68;
  int local_64;
  char temp [64];
  
  iVar4 = *(int *)(in_GS_OFFSET + 0x14);
  if (argc < 1) {
    Message("Usage:\n%s\n","Report(Object|DrillReport|FoundPins|NetLength|AllNetLengths)");
    local_90 = 1;
  }
  else {
    pcVar22 = *argv;
    iVar9 = strcasecmp(pcVar22,"Object");
    if (iVar9 == 0) {
      (*gui->get_coords)("Click on an object",&x,&y);
      local_90 = ReportDialog(argc + -1,argv + 1,x,y);
    }
    else {
      iVar9 = strcasecmp(pcVar22,"DrillReport");
      if (iVar9 == 0) {
        iVar9 = 0;
        d = GetDrillInfo(PCB->Data);
        RoundDrillInfo(d,100);
        uVar27 = d->DrillN;
        if (uVar27 != 0) {
          pDVar20 = d->Drill;
          uVar28 = 0;
          do {
            pCVar1 = &pDVar20->ViaCount;
            uVar28 = uVar28 + 1;
            pCVar2 = &pDVar20->PinCount;
            pCVar3 = &pDVar20->UnplatedCount;
            pDVar20 = pDVar20 + 1;
            iVar9 = *pCVar1 + *pCVar2 + *pCVar3 + iVar9;
          } while (uVar28 < uVar27);
        }
        pcVar13 = (char *)calloc(1,(uVar27 + 8) * 0x40);
        __sprintf_chk(pcVar13,1,0xffffffff,
                      "There are %d different drill sizes used in this layout, %d holes total\n\nDrill Diam. (mils)\t# of Pins\t# of Vias\t# of Elements\t# Unplated\n"
                      ,d->DrillN,iVar9);
        cVar5 = *pcVar13;
        pcVar22 = pcVar13;
        while (cVar5 != '\0') {
          pcVar22 = pcVar22 + 1;
          cVar5 = *pcVar22;
        }
        if (d->DrillN != 0) {
          iVar9 = 0;
          uVar27 = 0;
          do {
            piVar11 = (int *)((int)&d->Drill->DrillSize + iVar9);
            __sprintf_chk(pcVar22,1,0xffffffff,"\t%d\t\t\t%d\t\t%d\t\t%d\t\t%d\n",
                          (*piVar11 + 0x32) / 100,piVar11[3],piVar11[4],piVar11[1],piVar11[5]);
            cVar5 = *pcVar22;
            while (cVar5 != '\0') {
              pcVar22 = pcVar22 + 1;
              cVar5 = *pcVar22;
            }
            uVar27 = uVar27 + 1;
            iVar9 = iVar9 + 0x28;
          } while (uVar27 < d->DrillN);
        }
        FreeDrillInfo(d);
        (*gui->report_dialog)("Drill Report",pcVar13);
        SaveFree(pcVar13);
        local_90 = 0;
      }
      else {
        iVar9 = strcasecmp(pcVar22,"FoundPins");
        if (iVar9 == 0) {
          DSClearString(&ReportFoundPins::list);
          DSAddString(&ReportFoundPins::list,"The following pins/pads are FOUND:\n");
          paVar15 = PCB->Data;
          local_78 = (Cardinal *)(paVar15->ElementN - 1);
          if (local_78 != (Cardinal *)0xffffffff) {
            iVar16 = 0;
            iVar9 = paVar15->ElementN * 300;
            while( true ) {
              local_7c = iVar9 + -300;
              paVar7 = paVar15->Element;
              uVar27 = *(uint *)((int)&paVar7[-1].PinN + iVar9);
              if (uVar27 != 0) {
                uVar28 = 0;
                do {
                  iVar19 = uVar28 * 0x4c + *(int *)((int)&paVar7[-1].Pin + iVar9);
                  uVar26 = uVar27;
                  if ((*(byte *)(iVar19 + 0x14) & 4) != 0) {
                    uVar10 = 0x20;
                    if (iVar16 % 9 == 8) {
                      uVar10 = 10;
                    }
                    iVar16 = iVar16 + 1;
                    __sprintf_chk(temp,1,0x40,&DAT_0814df86,
                                  *(undefined4 *)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar9 + 8),
                                  *(undefined4 *)(iVar19 + 0x40),uVar10);
                    DSAddString(&ReportFoundPins::list,temp);
                    uVar26 = *(uint *)((int)&paVar7[-1].PinN + iVar9);
                  }
                } while ((uVar26 != 0) &&
                        (uVar28 = (uVar28 + 1 + uVar26) - uVar27, uVar27 = uVar26, uVar28 < uVar26))
                ;
              }
              uVar27 = *(uint *)((int)&paVar7[-1].PadN + iVar9);
              uVar28 = uVar27;
              for (uVar26 = 0; (uVar28 != 0 && (uVar26 < uVar28));
                  uVar26 = uVar26 + (uVar27 == uVar28)) {
                iVar19 = uVar26 * 0x68 + *(int *)((int)&paVar7[-1].Pad + iVar9);
                if ((*(byte *)(iVar19 + 0x14) & 4) != 0) {
                  uVar10 = 0x20;
                  if (iVar16 % 9 == 8) {
                    uVar10 = 10;
                  }
                  iVar16 = iVar16 + 1;
                  __sprintf_chk(temp,1,0x40,&DAT_0814df86,
                                *(undefined4 *)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar9 + 8),
                                *(undefined4 *)(iVar19 + 0x5c),uVar10);
                  DSAddString(&ReportFoundPins::list,temp);
                  uVar28 = *(uint *)((int)&paVar7[-1].PadN + iVar9);
                }
              }
              local_78 = (Cardinal *)((int)local_78 + -1);
              if (local_78 == (Cardinal *)0xffffffff) break;
              paVar15 = PCB->Data;
              iVar9 = local_7c;
            }
          }
          HideCrosshair('\0');
          (*gui->report_dialog)("Report",ReportFoundPins::list.Data);
          RestoreCrosshair('\0');
          local_90 = 0;
        }
        else {
          iVar9 = strcasecmp(pcVar22,"NetLength");
          if (iVar9 == 0) {
            found = 0;
            local_64 = x;
            local_68 = y;
            SaveUndoSerialNumber();
            ResetFoundPinsViasAndPads('\x01');
            RestoreUndoSerialNumber();
            ResetFoundLinesAndPolygons('\x01');
            RestoreUndoSerialNumber();
            (*gui->get_coords)("Click on a connection",&local_64,&local_68);
            XYtoNetLength(local_64,local_68,&found);
            if (found == 0) {
              (*gui->log)("No net under cursor.\n");
              local_90 = 1;
            }
            else {
              paVar15 = PCB->Data;
              local_84 = PCB;
              local_8c = paVar15->ElementN - 1;
              if (local_8c != -1) {
                iVar9 = paVar15->ElementN * 300;
                do {
                  local_94 = iVar9 + -300;
                  paVar7 = paVar15->Element;
                  uVar27 = *(uint *)((int)&paVar7[-1].PinN + iVar9);
                  if (uVar27 != 0) {
                    uVar28 = 0;
                    do {
                      iVar16 = uVar28 * 0x4c + *(int *)((int)&paVar7[-1].Pin + iVar9);
                      uVar26 = uVar27;
                      if ((*(byte *)(iVar16 + 0x14) & 4) != 0) {
                        iVar16 = *(int *)(iVar16 + 0x40);
                        pcVar22 = *(char **)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar9 + 8);
                        if ((iVar16 != 0) && (pcVar22 != (char *)0x0)) {
                          pcVar22 = Concat(pcVar22,&DAT_08156000,iVar16,0);
                          uVar26 = (PCB->NetlistLib).MenuN;
                          local_84 = PCB;
                          if (uVar26 != 0) {
                            local_88 = 0;
                            paVar12 = (PCB->NetlistLib).Menu;
                            do {
                              paVar17 = paVar12 + local_88;
                              uVar25 = paVar17->EntryN;
                              if (uVar25 != 0) {
                                paVar8 = paVar17->Entry;
                                uVar24 = 0;
                                do {
                                  iVar16 = strcmp(paVar8[uVar24].ListEntry,pcVar22);
                                  if (iVar16 == 0) {
                                    pcVar22 = paVar17->Name;
                                    goto got_net_name;
                                  }
                                  uVar24 = uVar24 + 1;
                                } while (uVar24 < uVar25);
                              }
                              local_88 = local_88 + 1;
                            } while (local_88 < uVar26);
                          }
                          uVar26 = *(uint *)((int)&paVar7[-1].PinN + iVar9);
                        }
                      }
                    } while ((uVar26 != 0) &&
                            (uVar28 = (uVar28 + 1 + uVar26) - uVar27, uVar27 = uVar26,
                            uVar28 < uVar26));
                  }
                  local_7c = 0;
                  local_80 = (PCBTypePtr)0x0;
                  uVar27 = *(uint *)((int)&paVar7[-1].PadN + iVar9);
                  uVar28 = uVar27;
                  while ((uVar28 != 0 && (local_80 < uVar28))) {
                    iVar16 = local_7c + *(int *)((int)&paVar7[-1].Pad + iVar9);
                    if ((*(byte *)(iVar16 + 0x14) & 4) != 0) {
                      iVar16 = *(int *)(iVar16 + 0x5c);
                      pcVar22 = *(char **)((int)(&paVar7[-1].Name[1].Flags + 2) + iVar9 + 8);
                      if ((iVar16 != 0) && (pcVar22 != (char *)0x0)) {
                        pcVar22 = Concat(pcVar22,&DAT_08156000,iVar16,0);
                        local_84 = PCB;
                        uVar28 = (PCB->NetlistLib).MenuN;
                        if (uVar28 == 0) {
                          uVar28 = *(uint *)((int)&paVar7[-1].PadN + iVar9);
                        }
                        else {
                          local_98 = 0;
                          paVar12 = (PCB->NetlistLib).Menu;
                          do {
                            paVar17 = paVar12 + local_98;
                            uVar26 = paVar17->EntryN;
                            if (uVar26 != 0) {
                              paVar8 = paVar17->Entry;
                              uVar25 = 0;
LAB_080c44e2:
                              iVar16 = strcmp(paVar8[uVar25].ListEntry,pcVar22);
                              if (iVar16 != 0) goto LAB_080c44d8;
                              pcVar22 = paVar17->Name;
got_net_name:
                              HideCrosshair('\0');
                              if (pcVar22 + 2 == (char *)0x0) goto LAB_080c455d;
                              puVar18 = &DAT_08147f6c;
                              if (Settings.grid_units_mm != '\0') {
                                puVar18 = &DAT_0815627e;
                              }
                              (*gui->log)("Net %s length: %0.2f %s\n",pcVar22 + 2,0,0,puVar18);
                              goto LAB_080c4336;
                            }
LAB_080c4508:
                            local_98 = local_98 + 1;
                          } while (local_98 < uVar28);
                          uVar28 = *(uint *)((int)&paVar7[-1].PadN + iVar9);
                        }
                      }
                    }
                    if (uVar27 == uVar28) {
                      local_80 = (PCBTypePtr)((int)local_80 + 1);
                      local_7c = local_7c + 0x68;
                      uVar28 = uVar27;
                    }
                  }
                  local_8c = local_8c + -1;
                  if (local_8c == -1) break;
                  paVar15 = local_84->Data;
                  iVar9 = local_94;
                } while( true );
              }
              HideCrosshair('\0');
LAB_080c455d:
              puVar18 = &DAT_08147f6c;
              if (Settings.grid_units_mm != '\0') {
                puVar18 = &DAT_0815627e;
              }
              (*gui->log)("Net length: %0.2f %s\n",0,0,puVar18);
LAB_080c4336:
              RestoreCrosshair('\0');
              local_90 = 0;
            }
          }
          else {
            iVar9 = strcasecmp(pcVar22,"AllNetLengths");
            if (iVar9 == 0) {
              local_94 = ~-(uint)(Settings.grid_units_mm == '\0') + 2;
              if (argc != 1) {
                __printf_chk(1,"Units: %s\n",argv[1]);
                pcVar22 = argv[1];
                iVar9 = strcasecmp(pcVar22,"mm");
                local_94 = 1;
                if (iVar9 != 0) {
                  iVar9 = strcasecmp(pcVar22,"mil");
                  local_94 = 2;
                  if (iVar9 != 0) {
                    iVar9 = strcasecmp(pcVar22,"in");
                    local_94 = -(uint)(iVar9 == 0) & 3;
                  }
                }
              }
              local_80 = PCB;
              if ((PCB->NetlistLib).MenuN != 0) {
                local_84 = (PCBTypePtr)0x0;
                do {
                  paVar12 = (local_80->NetlistLib).Menu + (int)local_84;
                  pcVar22 = paVar12->Name;
                  pcVar13 = (char *)__strdup(paVar12->Entry->ListEntry);
                  pcVar14 = strchr(pcVar13,0x2d);
                  if (pcVar14 == (char *)0x0) {
                    free(pcVar13);
                    local_80 = PCB;
                  }
                  else {
                    *pcVar14 = '\0';
                    local_80 = PCB;
                    CVar6 = PCB->Data->ElementN;
                    local_7c = CVar6 - 1;
                    if (local_7c != -1) {
                      local_78 = &PCB->Data->Element[CVar6 - 1].PadN;
                      do {
                        if (((char *)local_78[-0x15] != (char *)0x0) &&
                           (iVar9 = strcmp((char *)local_78[-0x15],pcVar13), iVar9 == 0)) {
                          uVar27 = local_78[-2];
                          if (uVar27 != 0) {
                            paVar21 = (PinTypePtr)local_78[6];
                            uVar28 = 0;
                            do {
                              iVar9 = strcmp(paVar21->Number,pcVar14 + 1);
                              if (iVar9 == 0) {
                                x_00 = paVar21->X;
                                y_00 = paVar21->Y;
                                goto got_one;
                              }
                              uVar28 = uVar28 + 1;
                              paVar21 = paVar21 + 1;
                            } while (uVar28 < uVar27);
                          }
                          uVar27 = *local_78;
                          if (uVar27 != 0) {
                            uVar28 = 0;
                            paVar23 = (PadTypePtr)local_78[7];
LAB_080c3ffb:
                            iVar9 = strcmp(paVar23->Number,pcVar14 + 1);
                            if (iVar9 != 0) goto LAB_080c3ff0;
                            x_00 = ((paVar23->Point2).X + (paVar23->Point1).X) / 2;
                            y_00 = ((paVar23->Point2).Y + (paVar23->Point1).Y) / 2;
got_one:
                            SaveUndoSerialNumber();
                            ResetFoundPinsViasAndPads('\x01');
                            RestoreUndoSerialNumber();
                            pcVar22 = pcVar22 + 2;
                            ResetFoundLinesAndPolygons('\x01');
                            RestoreUndoSerialNumber();
                            dVar29 = XYtoNetLength(x_00,y_00,&found);
                            if (local_94 == 2) {
                              (*gui->log)("Net %s length %d mil\n",pcVar22,
                                          (int)ROUND(dVar29 / 100.0));
                              local_80 = PCB;
                            }
                            else if (local_94 == 3) {
                              (*gui->log)("Net %s length %.3f in\n",pcVar22,
                                          SUB84(dVar29 / 100000.0,0),
                                          (int)((ulonglong)(dVar29 / 100000.0) >> 0x20));
                              local_80 = PCB;
                            }
                            else if (local_94 == 1) {
                              (*gui->log)("Net %s length %.2f mm\n",pcVar22,
                                          SUB84(dVar29 * 0.000254,0),
                                          (int)((ulonglong)(dVar29 * 0.000254) >> 0x20));
                              local_80 = PCB;
                            }
                            else {
                              (*gui->log)("Net %s length %d\n",pcVar22,(int)ROUND(dVar29));
                              local_80 = PCB;
                            }
                            break;
                          }
                        }
LAB_080c3fc0:
                        local_7c = local_7c + -1;
                        local_78 = local_78 + -0x4b;
                      } while (local_7c != -1);
                    }
                  }
                  local_84 = (PCBTypePtr)((int)local_84 + 1);
                } while (local_84 < (local_80->NetlistLib).MenuN);
              }
            }
            else {
              Message("Syntax error.  Usage:\n%s\n",
                      "Report(Object|DrillReport|FoundPins|NetLength|AllNetLengths)");
              local_90 = 1;
            }
          }
        }
      }
    }
  }
  if (iVar4 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_90;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080c44d8:
  uVar25 = uVar25 + 1;
  if (uVar26 <= uVar25) goto LAB_080c4508;
  goto LAB_080c44e2;
LAB_080c3ff0:
  uVar28 = uVar28 + 1;
  paVar23 = paVar23 + 1;
  if (uVar27 <= uVar28) goto LAB_080c3fc0;
  goto LAB_080c3ffb;
}



// WARNING: Unknown calling convention

void register_report_action_list(void)

{
  hid_register_actions(report_action_list,2);
  return;
}



// WARNING: Unknown calling convention

void dump_res(Resource *n,int l)

{
  Resource **ppRVar1;
  undefined4 *puVar2;
  undefined1 *puVar3;
  undefined1 *puVar4;
  int iVar5;
  int iVar6;
  int i;
  
  if (0 < n->c) {
    iVar5 = 0;
    iVar6 = 0;
    do {
      while (puVar2 = (undefined4 *)((int)&n->v->name + iVar5), puVar2[2] == 0) {
        puVar4 = (undefined1 *)puVar2[1];
        puVar3 = (undefined1 *)*puVar2;
        if (puVar4 == (undefined1 *)0x0) {
          puVar4 = &DAT_0814741b;
        }
        if (puVar3 == (undefined1 *)0x0) {
          puVar3 = &DAT_0814741b;
        }
        iVar6 = iVar6 + 1;
        iVar5 = iVar5 + 0xc;
        __printf_chk(1,"%*cn[%s] = v[%s]\n",l,0x20,puVar3,puVar4);
        if (n->c == iVar6 || n->c < iVar6) {
          return;
        }
      }
      puVar4 = (undefined1 *)*puVar2;
      if (puVar4 == (undefined1 *)0x0) {
        puVar4 = &DAT_0814741b;
      }
      iVar6 = iVar6 + 1;
      __printf_chk(1,"%*cn[%s] = {\n",l,0x20,puVar4);
      ppRVar1 = (Resource **)((int)&n->v->subres + iVar5);
      iVar5 = iVar5 + 0xc;
      dump_res(*ppRVar1,l + 3);
      __printf_chk(1,"%*c}\n",l,0x20);
    } while (n->c != iVar6 && iVar6 <= n->c);
  }
  return;
}



// WARNING: Unknown calling convention

void resource_dump(Resource *r)

{
  dump_res(r,0);
  return;
}



// WARNING: Unknown calling convention

int reserror(char *str)

{
  char *pcVar1;
  
  pcVar1 = "internal strings";
  if (res_file != (FILE *)0x0) {
    pcVar1 = res_filename;
  }
  __fprintf_chk(stderr,1,"Error: %s around line %d: %s\n",pcVar1,res_lineno,str);
  return 0;
}



// WARNING: Unknown calling convention

Resource * resource_subres(Resource *res,char *name)

{
  int iVar1;
  Resource *pRVar2;
  int iVar3;
  ResourceVal *pRVar4;
  int i;
  int iVar5;
  
  if (((name != (char *)0x0) && (res != (Resource *)0x0)) && (iVar1 = res->c, 0 < iVar1)) {
    pRVar4 = res->v;
    iVar5 = 0;
    do {
      if (((pRVar4->name != (char *)0x0) && (pRVar2 = pRVar4->subres, pRVar2 != (Resource *)0x0)) &&
         (iVar3 = strcmp(pRVar4->name,name), iVar3 == 0)) {
        return pRVar2;
      }
      iVar5 = iVar5 + 1;
      pRVar4 = pRVar4 + 1;
    } while (iVar5 < iVar1);
  }
  return (Resource *)0x0;
}



// WARNING: Unknown calling convention

char * resource_value(Resource *res,char *name)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  ResourceVal *pRVar4;
  int i;
  int iVar5;
  
  if (((name != (char *)0x0) && (res != (Resource *)0x0)) && (iVar1 = res->c, 0 < iVar1)) {
    pRVar4 = res->v;
    iVar5 = 0;
    do {
      if (((pRVar4->name != (char *)0x0) && (pcVar2 = pRVar4->value, pcVar2 != (char *)0x0)) &&
         (iVar3 = strcmp(pRVar4->name,name), iVar3 == 0)) {
        return pcVar2;
      }
      iVar5 = iVar5 + 1;
      pRVar4 = pRVar4 + 1;
    } while (iVar5 < iVar1);
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

void resource_add_val(Resource *n,char *name,char *value,Resource *subres)

{
  int iVar1;
  ResourceVal *pRVar2;
  
  pRVar2 = (ResourceVal *)realloc(n->v,(n->c * 3 + 3) * 4);
  iVar1 = n->c;
  n->c = n->c + 1;
  pRVar2[iVar1].name = name;
  n->v = pRVar2;
  pRVar2[iVar1].subres = subres;
  pRVar2[iVar1].value = value;
  return;
}



// WARNING: Unknown calling convention

Resource * resource_create(Resource *parent)

{
  Resource *pRVar1;
  ResourceVal *pRVar2;
  
  pRVar1 = (Resource *)malloc(0x14);
  pRVar1->flags = 0;
  pRVar1->c = 0;
  pRVar1->parent = parent;
  pRVar2 = (ResourceVal *)malloc(0xc);
  pRVar1->v = pRVar2;
  return pRVar1;
}



// WARNING: Unknown calling convention

int res_parse_getchars(char *buf,int max_size)

{
  char cVar1;
  char **ppcVar2;
  int iVar3;
  int i;
  uint uVar4;
  
  ppcVar2 = res_strings;
  if (res_file == (FILE *)0x0) {
    uVar4 = 0;
    if (*res_strings != (char *)0x0) {
      cVar1 = (*res_strings)[res_string_idx];
      res_string_idx = res_string_idx + 1;
      *buf = cVar1;
      uVar4 = 1;
      if (cVar1 == '\0') {
        res_strings = ppcVar2 + 1;
        res_string_idx = 0;
        *buf = '\n';
        return uVar4;
      }
    }
  }
  else {
    iVar3 = fgetc((FILE *)res_file);
    i._0_1_ = (char)iVar3;
    *buf = (char)i;
    uVar4 = (uint)(iVar3 != -1);
  }
  return uVar4;
}



// WARNING: Unknown calling convention

uint yytnamerr(char *yyres,char *yystr)

{
  char cVar1;
  uint yyn;
  char *pcVar2;
  uint uVar3;
  char *yyp;
  char *pcVar4;
  
  if (*yystr == '\"') {
    uVar3 = 0;
    pcVar2 = yystr;
    while( true ) {
      pcVar4 = pcVar2 + 1;
      cVar1 = *pcVar4;
      if (cVar1 == '\'') break;
      if (cVar1 < '(') {
        if (cVar1 == '\"') {
          if (yyres == (char *)0x0) {
            return uVar3;
          }
          yyres[uVar3] = '\0';
          return uVar3;
        }
      }
      else if ((cVar1 == ',') || ((cVar1 == '\\' && (pcVar4 = pcVar2 + 2, *pcVar4 != '\\')))) break;
      if (yyres != (char *)0x0) {
        yyres[uVar3] = *pcVar4;
      }
      uVar3 = uVar3 + 1;
      pcVar2 = pcVar4;
    }
  }
  if (yyres == (char *)0x0) {
    uVar3 = strlen(yystr);
  }
  else {
    pcVar2 = stpcpy(yyres,yystr);
    uVar3 = (int)pcVar2 - (int)yyres;
  }
  return uVar3;
}



// WARNING: Unknown calling convention

uint yysyntax_error(char *yyresult,int yystate,int reschar)

{
  char **ppcVar1;
  byte bVar2;
  char *yystr;
  char cVar3;
  int yytype;
  uint uVar4;
  uint uVar5;
  uint yysize;
  int yyxend;
  int yyi;
  uint *puVar6;
  uint *puVar7;
  int iVar8;
  int yyx;
  char *yyf;
  int iVar9;
  int yycount;
  uint uVar10;
  char *yyp;
  int in_GS_OFFSET;
  bool bVar11;
  char *local_90;
  char *local_8c;
  uint local_80;
  char *yyarg [5];
  char yyformat [60];
  int local_20;
  
  uVar10 = (uint)yypact[yystate];
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  yysize = 0;
  if (uVar10 < 0x1a) {
    yytype = 2;
    if ((uint)reschar < 0x104) {
      yytype = (int)""[reschar];
    }
    yyarg[0] = yytname[yytype];
    iVar9 = 1;
    uVar4 = yytnamerr((char *)0x0,yyarg[0]);
    yyxend = 0x1a - uVar10;
    local_90 = yyformat + 0x1b;
    yyformat[0] = 's';
    yyformat[1] = 'y';
    yyformat[2] = 'n';
    yyformat[3] = 't';
    if (8 < yyxend) {
      yyxend = 8;
    }
    iVar8 = 0;
    yyformat[4] = 'a';
    yyformat[5] = 'x';
    yyformat[6] = ' ';
    yyformat[7] = 'e';
    yyformat[8] = 'r';
    yyformat[9] = 'r';
    yyformat[10] = 'o';
    yyformat[11] = 'r';
    yyformat[12] = ',';
    yyformat[13] = ' ';
    yyformat[14] = 'u';
    yyformat[15] = 'n';
    yyformat[16] = 'e';
    yyformat[17] = 'x';
    yyformat[18] = 'p';
    yyformat[19] = 'e';
    yyformat[20] = 'c';
    yyformat[21] = 't';
    yyformat[22] = 'e';
    yyformat[23] = 'd';
    yyformat[24] = ' ';
    yyformat[25] = '%';
    yyformat[26] = 's';
    yyformat[27] = '\0';
    local_8c = ", expecting %s";
    bVar2 = 0;
    local_80 = uVar4;
    do {
      if ((""[iVar8 + uVar10] == iVar8) && (iVar8 != 1)) {
        if (iVar9 == 5) {
          iVar9 = 1;
          yyformat._24_4_ = yyformat._24_4_ & 0xffffff;
          local_80 = uVar4;
          break;
        }
        yystr = yytname[iVar8];
        yyarg[iVar9] = yystr;
        iVar9 = iVar9 + 1;
        uVar5 = yytnamerr((char *)0x0,yystr);
        bVar11 = CARRY4(uVar5,local_80);
        local_80 = uVar5 + local_80;
        bVar2 = bVar2 | bVar11;
        local_90 = stpcpy(local_90,local_8c);
        local_8c = " or %s";
      }
      iVar8 = iVar8 + 1;
    } while (iVar8 < yyxend);
    puVar6 = (uint *)yyformat;
    do {
      puVar7 = puVar6;
      uVar4 = *puVar7 + 0xfefefeff & ~*puVar7;
      uVar10 = uVar4 & 0x80808080;
      puVar6 = puVar7 + 1;
    } while (uVar10 == 0);
    bVar11 = (uVar4 & 0x8080) == 0;
    if (bVar11) {
      uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
      puVar6 = (uint *)((int)puVar7 + 6);
    }
    uVar10 = (int)puVar6 + ((-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10)) - (int)yyformat);
    yysize = uVar10 + local_80;
    if ((CARRY4(uVar10,local_80)) || (bVar2 != 0)) {
      yysize = 0xffffffff;
    }
    else if (yyresult != (char *)0x0) {
      *yyresult = yyformat[0];
      if (yyformat[0] != '\0') {
        iVar8 = 0;
        puVar6 = (uint *)yyformat;
        cVar3 = yyformat[0];
        do {
          if (cVar3 == '%') {
            cVar3 = *(char *)((int)puVar6 + 1);
            if ((cVar3 != 's') || (iVar9 <= iVar8)) goto LAB_080c4be3;
            ppcVar1 = yyarg + iVar8;
            iVar8 = iVar8 + 1;
            uVar10 = yytnamerr(yyresult,*ppcVar1);
            puVar7 = (uint *)((int)puVar6 + 2);
            yyresult = yyresult + uVar10;
            cVar3 = *(char *)((int)puVar6 + 2);
          }
          else {
            cVar3 = *(char *)((int)puVar6 + 1);
LAB_080c4be3:
            puVar7 = (uint *)((int)puVar6 + 1);
            yyresult = yyresult + 1;
          }
          *yyresult = cVar3;
          puVar6 = puVar7;
        } while (cVar3 != '\0');
      }
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return yysize;
}



// WARNING: Unknown calling convention

int resparse(void)

{
  YYSTYPE_conflict1 *__dest;
  short sVar1;
  int yyn;
  uint yystacksize;
  short *__dest_00;
  uint yysize_1;
  YYSTYPE_conflict1 yyval;
  YYSTYPE_conflict1 YVar2;
  uint yyalloc;
  YYSTYPE_conflict1 *yyvs;
  uint uVar3;
  int yytoken;
  int yystate;
  int iVar4;
  yytype_int16 *yyssp;
  int iVar5;
  uint yysize;
  short *psVar6;
  yytype_int16 *yyss;
  uint uVar7;
  int yylen;
  int yyresult;
  YYSTYPE_conflict1 *yyvsp;
  YYSTYPE_conflict1 *pYVar8;
  int in_GS_OFFSET;
  Resource *value;
  Resource *subres;
  uint local_57c;
  int local_578;
  char *local_574;
  int local_570;
  short *local_56c;
  uint local_568;
  int local_564;
  YYSTYPE_conflict1 *local_560;
  YYSTYPE_conflict1 yyvsa [200];
  yytype_int16 yyssa [200];
  char yymsgbuf [128];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_560 = yyvsa;
  resnerrs = 0;
  reschar = -2;
  local_57c = 0x80;
  local_568 = 200;
  local_578 = 0;
  local_564 = 0;
  local_570 = 199;
  psVar6 = yyssa;
  local_56c = yyssa;
  pYVar8 = local_560;
  local_574 = yymsgbuf;
  do {
    *psVar6 = (short)local_564;
    if (local_56c + local_570 <= psVar6) {
      if (local_568 < 10000) {
        uVar3 = local_568 * 2;
        local_568 = 10000;
        if (uVar3 < 0x2711) {
          local_568 = uVar3;
        }
        __dest_00 = (short *)malloc(local_568 * 6 + 3);
        if (__dest_00 != (short *)0x0) {
          iVar5 = (int)psVar6 - (int)local_56c >> 1;
          memcpy(__dest_00,local_56c,(iVar5 + 1) * 2);
          __dest = (YYSTYPE_conflict1 *)(__dest_00 + local_568);
          memcpy(__dest,local_560,(iVar5 + 1) * 4);
          if (yyssa != local_56c) {
            free(local_56c);
          }
          psVar6 = __dest_00 + iVar5;
          local_570 = local_568 - 1;
          local_56c = __dest_00;
          if (psVar6 < __dest_00 + local_570) {
            pYVar8 = __dest + iVar5;
            local_560 = __dest;
            goto yybackup;
          }
LAB_080c5373:
          yyresult = 1;
          goto LAB_080c51da;
        }
      }
LAB_080c51c9:
      yyresult = 2;
      reserror("memory exhausted");
      goto LAB_080c51da;
    }
yybackup:
    iVar5 = (int)yypact[local_564];
    if (iVar5 != -1) {
      if (reschar == -2) {
        reschar = reslex();
      }
      if (reschar < 1) {
        reschar = 0;
        uVar3 = 0;
      }
      else {
        uVar3 = 2;
        if ((uint)reschar < 0x104) {
          uVar3 = (uint)""[reschar];
        }
      }
      uVar7 = uVar3 + iVar5;
      if ((0x19 < uVar7) || ((int)""[uVar7] != uVar3)) goto yydefault;
      iVar4 = (int)yytable[uVar7];
      if (iVar4 < 1) {
        if ((iVar4 == -8) || (iVar4 == 0)) goto yyerrlab;
        uVar3 = -iVar4;
        goto yyreduce;
      }
      if (iVar4 != 3) {
        local_578 = local_578 + -1 + (uint)(local_578 == 0);
        iVar5 = -2;
        if (reschar == 0) {
          iVar5 = reschar;
        }
        pYVar8 = pYVar8 + 1;
        *pYVar8 = reslval;
        reschar = iVar5;
        local_564 = iVar4;
        goto yynewstate;
      }
yyreturn:
      yyresult = 0;
LAB_080c51da:
      if (psVar6 != local_56c) {
        psVar6 = (short *)((int)psVar6 + (~((int)psVar6 + (-2 - (int)local_56c)) & 0xfffffffeU));
      }
LAB_080c4fdd:
      if (yyssa != psVar6) {
        free(local_56c);
      }
      if (yymsgbuf != local_574) {
        free(local_574);
      }
      if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
        return yyresult;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
yydefault:
    uVar3 = (uint)"\x02"[local_564];
    if (uVar3 == 0) {
yyerrlab:
      if (local_578 == 0) {
        resnerrs = resnerrs + 1;
        uVar3 = yysyntax_error((char *)0x0,local_564,reschar);
        if ((local_57c < uVar3) && (local_57c != 0xffffffff)) {
          local_57c = uVar3 * 2;
          if (local_57c < uVar3) {
            local_57c = 0xffffffff;
          }
          if (yymsgbuf != local_574) {
            free(local_574);
          }
          local_574 = (char *)malloc(local_57c);
          if (local_574 == (char *)0x0) {
            local_574 = yymsgbuf;
            local_57c = 0x80;
          }
        }
        if ((local_57c < uVar3) || (uVar3 == 0)) {
          reserror("syntax error");
          if (uVar3 != 0) goto LAB_080c51c9;
        }
        else {
          yysyntax_error(local_574,local_564,reschar);
          reserror(local_574);
        }
      }
      else if (local_578 == 3) {
        if (reschar < 1) {
          if (reschar == 0) goto LAB_080c5373;
        }
        else {
          reschar = -2;
        }
      }
      while ((((iVar5 == -1 || (0x19 < iVar5 + 1U)) || (""[iVar5 + 1] != '\x01')) ||
             (local_564 = (int)yytable[iVar5 + 1], local_564 < 1))) {
        if (psVar6 == local_56c) {
          yyresult = 1;
          goto LAB_080c4fdd;
        }
        psVar6 = psVar6 + -1;
        pYVar8 = pYVar8 + -1;
        iVar5 = (int)yypact[*psVar6];
      }
      if (local_564 != 3) {
        pYVar8 = pYVar8 + 1;
        local_578 = 3;
        *pYVar8 = reslval;
        goto yynewstate;
      }
      goto yyreturn;
    }
yyreduce:
    uVar7 = (uint)""[uVar3];
    YVar2 = pYVar8[1 - uVar7];
    switch(uVar3) {
    case 2:
      parsed_res = resource_create((Resource *)0x0);
      current_res = parsed_res;
      break;
    case 4:
      current_res = resource_create(current_res);
      break;
    case 5:
      YVar2.rval = current_res;
      current_res = current_res->parent;
      break;
    case 8:
      resource_add_val(current_res,(char *)0x0,(char *)pYVar8->sval,(Resource *)0x0);
      current_res->flags = current_res->flags | 1;
      break;
    case 9:
      resource_add_val(current_res,(char *)pYVar8[-2].sval,(char *)pYVar8->sval,(Resource *)0x0);
      current_res->flags = current_res->flags | 2;
      break;
    case 10:
      subres = (Resource *)0x0;
      value = (Resource *)pYVar8->sval;
      goto LAB_080c4e98;
    case 0xb:
      subres = pYVar8->rval;
      value = (Resource *)0x0;
LAB_080c4e98:
      resource_add_val(current_res,(char *)0x0,(char *)value,subres);
      current_res->flags = current_res->flags | 4;
      break;
    case 0xc:
      resource_add_val(current_res,(char *)pYVar8[-2].sval,(char *)0x0,pYVar8->rval);
      current_res->flags = current_res->flags | 8;
    }
    psVar6 = psVar6 + -uVar7;
    sVar1 = *psVar6;
    pYVar8[1 - uVar7] = YVar2;
    pYVar8 = pYVar8 + (1 - uVar7);
    uVar7 = (int)sVar1 + (int)(char)""[""[uVar3] + 6];
    if ((uVar7 < 0x1a) && (sVar1 == ""[uVar7])) {
      local_564 = (int)yytable[uVar7];
    }
    else {
      local_564 = (int)(char)""[""[uVar3] + 0xd];
    }
yynewstate:
    psVar6 = psVar6 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

Resource * resource_parse(char *filename,char **strings)

{
  int iVar1;
  
  res_lineno = 1;
  if (filename == (char *)0x0) {
    if (strings == (char **)0x0) {
      res_lineno = 1;
      return (Resource *)0x0;
    }
    res_filename = (char *)0x0;
    res_string_idx = 0;
    res_strings = strings;
  }
  else {
    res_filename = filename;
    res_file = (FILE *)fopen(filename,"r");
    if (res_file == (FILE *)0x0) {
      perror(filename);
      return (Resource *)0x0;
    }
  }
  iVar1 = resparse();
  if (iVar1 == 0) {
    if (filename == (char *)0x0) {
      res_strings = (char **)0x0;
    }
    else {
      fclose((FILE *)res_file);
    }
    return parsed_res;
  }
  return (Resource *)0x0;
}



// WARNING: Unknown calling convention

void res_switch_to_buffer(YY_BUFFER_STATE new_buffer)

{
  if (yy_current_buffer != new_buffer) {
    if (yy_current_buffer != (YY_BUFFER_STATE)0x0) {
      *yy_c_buf_p = yy_hold_char;
      yy_current_buffer->yy_buf_pos = yy_c_buf_p;
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }
    yy_n_chars = new_buffer->yy_n_chars;
    yy_current_buffer = new_buffer;
    yy_c_buf_p = new_buffer->yy_buf_pos;
    resin = new_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    yy_did_buffer_switch_on_eof = 1;
    restext = yy_c_buf_p;
  }
  return;
}



// WARNING: Unknown calling convention

void res_load_buffer_state(void)

{
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  restext = yy_c_buf_p;
  resin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  return;
}



// WARNING: Unknown calling convention

void res_flush_buffer(YY_BUFFER_STATE b)

{
  char *pcVar1;
  bool bVar2;
  
  if (b != (YY_BUFFER_STATE)0x0) {
    b->yy_n_chars = 0;
    *b->yy_ch_buf = '\0';
    b->yy_ch_buf[1] = '\0';
    pcVar1 = b->yy_ch_buf;
    bVar2 = b == yy_current_buffer;
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    b->yy_buf_pos = pcVar1;
    if (bVar2) {
      yy_c_buf_p = pcVar1;
      restext = pcVar1;
      yy_n_chars = b->yy_n_chars;
      resin = b->yy_input_file;
      yy_hold_char = *pcVar1;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void yy_fatal_error(char *msg)

{
  __fprintf_chk(stderr,1,&DAT_08148577,msg);
                    // WARNING: Subroutine does not return
  exit(2);
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE res_scan_buffer(char *base,yy_size_t size)

{
  YY_BUFFER_STATE b;
  
  if (((size < 2) || (base[size - 2] != '\0')) || (base[size - 1] != '\0')) {
    b = (YY_BUFFER_STATE)0x0;
  }
  else {
    b = (YY_BUFFER_STATE)malloc(0x28);
    if (b == (YY_BUFFER_STATE)0x0) {
      yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
    b->yy_buf_size = size - 2;
    b->yy_ch_buf = base;
    b->yy_buf_pos = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = (FILE *)0x0;
    b->yy_n_chars = size - 2;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = 0;
    res_switch_to_buffer(b);
  }
  return b;
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE res_scan_bytes(char *bytes,yy_size_t len)

{
  char *base;
  uint uVar1;
  yy_size_t i;
  YY_BUFFER_STATE pyVar2;
  YY_BUFFER_STATE b;
  yy_size_t n;
  
  base = (char *)malloc(len + 2);
  if (base == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
  }
  if (len != 0) {
    uVar1 = 0;
    do {
      base[uVar1] = bytes[uVar1];
      uVar1 = uVar1 + 1;
    } while (uVar1 < len);
  }
  base[len + 1] = '\0';
  base[len] = '\0';
  pyVar2 = res_scan_buffer(base,len + 2);
  if (pyVar2 == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("bad buffer in yy_scan_bytes()");
  }
  pyVar2->yy_is_our_buffer = 1;
  return pyVar2;
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE res_scan_string(char *yy_str)

{
  char cVar1;
  yy_size_t len_00;
  yy_size_t len;
  YY_BUFFER_STATE pyVar2;
  
  len_00 = 0;
  cVar1 = *yy_str;
  while (cVar1 != '\0') {
    len_00 = len_00 + 1;
    cVar1 = yy_str[len_00];
  }
  pyVar2 = res_scan_bytes(yy_str,len_00);
  return pyVar2;
}



// WARNING: Unknown calling convention

void res_init_buffer(YY_BUFFER_STATE b,FILE *file)

{
  int iVar1;
  int iVar2;
  
  res_flush_buffer(b);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  if (file != (FILE *)0x0) {
    iVar1 = fileno((FILE *)file);
    iVar1 = isatty(iVar1);
    iVar2 = 1;
    if (0 < iVar1) goto LAB_080c5770;
  }
  iVar2 = 0;
LAB_080c5770:
  b->yy_is_interactive = iVar2;
  return;
}



// WARNING: Unknown calling convention

YY_BUFFER_STATE res_create_buffer(FILE *file,int size)

{
  YY_BUFFER_STATE b;
  char *pcVar1;
  
  b = (YY_BUFFER_STATE)malloc(0x28);
  if (b == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_buf_size = size;
  pcVar1 = (char *)malloc(size + 2);
  b->yy_ch_buf = pcVar1;
  if (pcVar1 == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_is_our_buffer = 1;
  res_init_buffer(b,file);
  return b;
}



// WARNING: Unknown calling convention

void resrestart(FILE *input_file)

{
  if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
    yy_current_buffer = res_create_buffer(resin,0x4000);
  }
  res_init_buffer(yy_current_buffer,input_file);
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  restext = yy_c_buf_p;
  resin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  return;
}



// WARNING: Unknown calling convention

void res_delete_buffer(YY_BUFFER_STATE b)

{
  if (b == (YY_BUFFER_STATE)0x0) {
    return;
  }
  if (b == yy_current_buffer) {
    yy_current_buffer = (YY_BUFFER_STATE)0x0;
  }
  if (b->yy_is_our_buffer == 0) {
    free(b);
    return;
  }
  free(b->yy_ch_buf);
  free(b);
  return;
}



// WARNING: Unknown calling convention

int reslex(void)

{
  char *pcVar1;
  FILE *pFVar2;
  char *pcVar3;
  yy_state_type yy_current_state;
  yy_state_type yy_next_state;
  int iVar4;
  int yy_act;
  YYSTYPE_conflict1 __s;
  size_t sVar5;
  char *pcVar6;
  int i;
  short sVar7;
  char *yy_bp;
  YY_CHAR yy_c;
  YY_CHAR yy_c_2;
  int max_size;
  int yyl;
  YY_CHAR yy_c_1;
  int iVar8;
  char *source;
  int num_to_read;
  byte bVar9;
  char *yy_cp;
  YY_CHAR yy_c_3;
  byte *pbVar10;
  int ret_val;
  int number_to_move;
  char *pcVar11;
  YY_BUFFER_STATE local_28;
  byte *local_24;
  yy_state_type *local_20;
  
  if (yy_init != 0) {
    yy_init = 0;
    iVar4 = 1;
    if (yy_start != 0) {
      iVar4 = yy_start;
    }
    if (resin == (FILE *)0x0) {
      resin = stdin;
    }
    if (resout == (FILE *)0x0) {
      resout = stdout;
    }
    yy_start = iVar4;
    if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
      yy_current_buffer = res_create_buffer(resin,0x4000);
    }
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    resin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
  }
LAB_080c596c:
  *yy_c_buf_p = yy_hold_char;
  local_20 = yy_state_buf + 1;
  yy_state_buf[0] = yy_start;
  yy_next_state = yy_start;
  local_24 = (byte *)yy_c_buf_p;
LAB_080c598c:
  sVar7 = yy_base[yy_next_state];
  do {
    bVar9 = *(byte *)(yy_ec + (byte)*yy_c_buf_p);
    while( true ) {
      iVar4 = (uint)bVar9 + (int)sVar7;
      if (yy_chk[iVar4] == yy_next_state) break;
      yy_next_state = (yy_state_type)yy_def[yy_next_state];
      if (0x1b < yy_next_state) {
        bVar9 = *(byte *)(yy_meta + bVar9);
      }
      sVar7 = yy_base[yy_next_state];
    }
    yy_next_state = (yy_state_type)yy_nxt[iVar4];
    yy_c_buf_p = (char *)((byte *)yy_c_buf_p + 1);
    *local_20 = yy_next_state;
    yy_state_ptr = local_20 + 1;
    sVar7 = yy_base[yy_next_state];
    pbVar10 = (byte *)yy_c_buf_p;
    local_20 = yy_state_ptr;
  } while (sVar7 != 0x39);
LAB_080c5a0b:
  iVar4 = yy_state_ptr[-1];
  yy_state_ptr = yy_state_ptr + -1;
  sVar7 = yy_accept[iVar4];
  while ((yy_lp = (int)sVar7, yy_lp == 0 || (yy_accept[iVar4 + 1] <= yy_lp))) {
    yy_state_ptr = yy_state_ptr + -1;
    pbVar10 = pbVar10 + -1;
    iVar4 = *yy_state_ptr;
    sVar7 = yy_accept[iVar4];
  }
  iVar4 = (int)yy_acclist[yy_lp];
  restext = (char *)local_24;
  resleng = (int)pbVar10 - (int)local_24;
  yy_hold_char = *pbVar10;
  yy_full_match = (char *)pbVar10;
  *pbVar10 = 0;
  yy_c_buf_p = (char *)pbVar10;
  if ((iVar4 != 9) && (0 < resleng)) {
    iVar8 = 0;
    do {
      while (restext[iVar8] == '\n') {
        iVar8 = iVar8 + 1;
        reslineno = reslineno + 1;
        if (iVar8 == resleng) goto LAB_080c5abd;
      }
      iVar8 = iVar8 + 1;
    } while (iVar8 != resleng);
  }
LAB_080c5abd:
  switch(iVar4) {
  default:
    yy_fatal_error("fatal flex scanner internal error--no action found");
    goto LAB_080c596c;
  case 1:
  case 2:
    __s.ival = __strdup(restext + 1);
    reslval.ival = __s.ival;
    sVar5 = strlen(__s.sval);
    __s.sval[sVar5 - 1] = '\0';
    return 0x102;
  case 3:
    res_lineno = res_lineno + 1;
    goto LAB_080c596c;
  case 4:
    res_lineno = res_lineno + (uint)(*restext == '\n');
    goto LAB_080c596c;
  case 5:
    reslval.ival = __strdup(restext);
    return 0x103;
  case 6:
    reslval.ival = __strdup(restext);
    return 0x102;
  case 7:
    return (int)*restext;
  case 8:
    fwrite(restext,resleng,1,(FILE *)resout);
    goto LAB_080c596c;
  case 9:
    break;
  case 10:
    return 0;
  }
  iVar4 = -1 - (int)restext;
  *pbVar10 = yy_hold_char;
  local_28 = yy_current_buffer;
  pFVar2 = resin;
  if (yy_current_buffer->yy_buffer_status == 0) {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yy_current_buffer->yy_buffer_status = 1;
    local_28->yy_input_file = pFVar2;
  }
  pcVar3 = restext;
  pcVar1 = local_28->yy_ch_buf;
  if (pcVar1 + yy_n_chars < yy_c_buf_p) {
    if (pcVar1 + yy_n_chars + 1 < yy_c_buf_p) {
      yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
      local_28 = yy_current_buffer;
    }
    if (local_28->yy_fill_buffer == 0) {
      local_20 = (yy_state_type *)restext;
      if ((int)yy_c_buf_p - (int)restext != 1) goto LAB_080c5c47;
    }
    else {
      pcVar11 = yy_c_buf_p + (-1 - (int)restext);
      if (0 < (int)pcVar11) {
        pcVar6 = (char *)0x0;
        do {
          pcVar1[(int)pcVar6] = pcVar3[(int)pcVar6];
          pcVar6 = pcVar6 + 1;
          local_28 = yy_current_buffer;
        } while (pcVar6 != pcVar11);
      }
      if (local_28->yy_buffer_status == 2) {
        yy_n_chars = 0;
        local_28->yy_n_chars = 0;
      }
      else {
        num_to_read = ~(uint)pcVar11;
        iVar8 = num_to_read + local_28->yy_buf_size;
        if (iVar8 < 1) {
          do {
            yy_fatal_error(
                          "input buffer overflow, can\'t enlarge buffer because scanner uses REJECT"
                          );
          } while( true );
        }
        max_size = 0x2000;
        if (iVar8 < 0x2001) {
          max_size = iVar8;
        }
        yy_n_chars = res_parse_getchars(local_28->yy_ch_buf + (int)pcVar11,max_size);
        local_28 = yy_current_buffer;
        yy_current_buffer->yy_n_chars = yy_n_chars;
      }
      iVar8 = 0;
      if (yy_n_chars == 0) {
        if (pcVar11 == (char *)0x0) {
          resrestart(resin);
          iVar8 = 1;
          local_28 = yy_current_buffer;
        }
        else {
          local_28->yy_buffer_status = 2;
          iVar8 = 2;
        }
      }
      yy_n_chars = (int)(pcVar11 + yy_n_chars);
      local_28->yy_ch_buf[yy_n_chars] = '\0';
      yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = '\0';
      local_28 = yy_current_buffer;
      restext = yy_current_buffer->yy_ch_buf;
      local_20 = (yy_state_type *)restext;
      if (iVar8 != 1) {
        if (iVar8 != 2) {
          yy_c_buf_p = (char *)((byte *)restext + (int)(pbVar10 + iVar4));
          yy_state_ptr = yy_state_buf + 1;
          yy_state_buf[0] = yy_start;
          yy_next_state = yy_start;
          local_24 = (byte *)restext;
          if (restext < yy_c_buf_p) {
            local_20 = yy_state_buf + 1;
            do {
              bVar9 = 1;
              if (*local_24 != 0) {
                bVar9 = *(byte *)(yy_ec + *local_24);
              }
              while( true ) {
                iVar4 = (int)yy_base[yy_next_state] + (uint)bVar9;
                if (yy_next_state == yy_chk[iVar4]) break;
                yy_next_state = (yy_state_type)yy_def[yy_next_state];
                if (0x1b < yy_next_state) {
                  bVar9 = *(byte *)(yy_meta + bVar9);
                }
              }
              yy_next_state = (yy_state_type)yy_nxt[iVar4];
              local_24 = local_24 + 1;
              *local_20 = yy_next_state;
              yy_state_ptr = local_20 + 1;
              local_20 = yy_state_ptr;
            } while (local_24 < yy_c_buf_p);
            local_24 = (byte *)restext;
          }
          goto LAB_080c5eb8;
        }
LAB_080c5c47:
        yy_state_ptr = yy_state_buf + 1;
        pbVar10 = (byte *)(local_28->yy_ch_buf + yy_n_chars);
        yy_state_buf[0] = yy_start;
        local_24 = (byte *)local_20;
        if (local_20 < pbVar10) {
          local_28 = (YY_BUFFER_STATE)(yy_state_buf + 1);
          iVar4 = yy_start;
          do {
            bVar9 = 1;
            if (*local_24 != 0) {
              bVar9 = *(byte *)(yy_ec + *local_24);
            }
            while( true ) {
              iVar8 = (int)yy_base[iVar4] + (uint)bVar9;
              if (iVar4 == yy_chk[iVar8]) break;
              iVar4 = (int)yy_def[iVar4];
              if (0x1b < iVar4) {
                bVar9 = *(byte *)(yy_meta + bVar9);
              }
            }
            iVar4 = (int)yy_nxt[iVar8];
            local_24 = local_24 + 1;
            *(int *)local_28 = iVar4;
            yy_state_ptr = (yy_state_type *)((int)local_28 + 4);
            local_28 = (YY_BUFFER_STATE)yy_state_ptr;
          } while (local_24 < pbVar10);
          local_24 = (byte *)local_20;
        }
        goto LAB_080c5a0b;
      }
    }
    yy_did_buffer_switch_on_eof = 0;
    yy_c_buf_p = (char *)local_20;
    iVar4 = (yy_start + -1) / 2 + 10;
    restext = (char *)local_20;
    goto LAB_080c5abd;
  }
  pbVar10 = pbVar10 + iVar4 + (int)restext;
  local_24 = (byte *)restext;
  yy_state_ptr = yy_state_buf;
  yy_state_buf[0] = yy_start;
  iVar4 = yy_start;
  yy_c_buf_p = (char *)pbVar10;
  while (yy_state_ptr = yy_state_ptr + 1, local_24 < pbVar10) {
    bVar9 = 1;
    if (*local_24 != 0) {
      bVar9 = *(byte *)(yy_ec + *local_24);
    }
    while( true ) {
      iVar8 = (int)yy_base[iVar4] + (uint)bVar9;
      if (iVar4 == yy_chk[iVar8]) break;
      iVar4 = (int)yy_def[iVar4];
      if (0x1b < iVar4) {
        bVar9 = *(byte *)(yy_meta + bVar9);
      }
    }
    iVar4 = (int)yy_nxt[iVar8];
    local_24 = local_24 + 1;
    *yy_state_ptr = iVar4;
  }
  while( true ) {
    iVar8 = (int)yy_base[iVar4];
    if (iVar4 == *(short *)(iVar8 + 0x814f2e1 + iVar8 + 1)) break;
    iVar4 = (int)yy_def[iVar4];
  }
  yy_next_state = (yy_state_type)*(short *)(iVar8 + 0x814f381 + iVar8 + 1);
  local_24 = (byte *)restext;
  if (yy_next_state == 0x1b) goto LAB_080c5a0b;
  *yy_state_ptr = yy_next_state;
  yy_state_ptr = yy_state_ptr + 1;
  pbVar10 = (byte *)yy_c_buf_p;
  if (yy_next_state == 0) goto LAB_080c5a0b;
  yy_c_buf_p = yy_c_buf_p + 1;
LAB_080c5eb8:
  local_20 = yy_state_ptr;
  goto LAB_080c598c;
}



// WARNING: Unknown calling convention

void RotatePointLowLevel(PointTypePtr Point,LocationType X,LocationType Y,BYTE Number)

{
  byte bVar1;
  LocationType dx;
  int iVar2;
  LocationType dy;
  int iVar3;
  
  bVar1 = Number & 3;
  iVar2 = Point->X - X;
  iVar3 = Point->Y - Y;
  if (bVar1 == 2) {
    Point->X = X - iVar2;
    Point->Y = Y - iVar3;
  }
  else if (bVar1 == 3) {
    Point->X = X - iVar3;
    Point->Y = Y + iVar2;
  }
  else if (bVar1 == 1) {
    Point->X = iVar3 + X;
    Point->Y = Y - iVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void RotateBoxLowLevel(BoxTypePtr Box,LocationType X,LocationType Y,BYTE Number)

{
  LocationType y1;
  int iVar1;
  LocationType y2;
  int iVar2;
  LocationType x2;
  int iVar3;
  LocationType x1;
  int iVar4;
  byte bVar5;
  int iVar6;
  int iVar7;
  int local_18;
  int local_14;
  
  iVar4 = Box->X1;
  iVar1 = Box->Y1;
  iVar3 = Box->X2;
  iVar2 = Box->Y2;
  iVar6 = iVar4 - X;
  iVar7 = iVar1 - Y;
  bVar5 = Number & 3;
  if (bVar5 == 2) {
    local_18 = iVar3 - X;
    local_14 = iVar2 - Y;
    iVar4 = X - iVar6;
    iVar1 = Y - iVar7;
LAB_080c6200:
    iVar3 = X - local_18;
    iVar2 = Y - local_14;
  }
  else {
    if (bVar5 == 3) {
      local_18 = iVar3 - X;
      local_14 = iVar2 - Y;
      iVar4 = X - iVar7;
      iVar1 = Y + iVar6;
LAB_080c6228:
      iVar3 = X - local_14;
      iVar2 = local_18 + Y;
      goto LAB_080c61b4;
    }
    if (bVar5 == 1) {
      local_18 = iVar3 - X;
      local_14 = iVar2 - Y;
      iVar4 = iVar7 + X;
      iVar1 = Y - iVar6;
    }
    else {
      local_18 = iVar3 - X;
      local_14 = iVar2 - Y;
      if (bVar5 == 2) goto LAB_080c6200;
      if (bVar5 == 3) goto LAB_080c6228;
      if (bVar5 != 1) goto LAB_080c61b4;
    }
    iVar3 = local_14 + X;
    iVar2 = Y - local_18;
  }
LAB_080c61b4:
  iVar6 = iVar3;
  if (iVar4 <= iVar3) {
    iVar6 = iVar4;
  }
  Box->X1 = iVar6;
  iVar6 = iVar2;
  if (iVar1 <= iVar2) {
    iVar6 = iVar1;
  }
  if (iVar3 <= iVar4) {
    iVar3 = iVar4;
  }
  if (iVar2 <= iVar1) {
    iVar2 = iVar1;
  }
  Box->Y1 = iVar6;
  Box->X2 = iVar3;
  Box->Y2 = iVar2;
  return;
}



// WARNING: Unknown calling convention

void RotateArcLowLevel(ArcTypePtr Arc,LocationType X,LocationType Y,BYTE Number)

{
  LocationType LVar1;
  LocationType dx;
  int iVar2;
  BDimension save;
  LocationType dy;
  int iVar3;
  uint uVar4;
  
  iVar2 = Arc->X - X;
  Arc->StartAngle = (int)((uint)Number * 0x5a + Arc->StartAngle) % 0x168;
  uVar4 = Number & 3;
  iVar3 = Arc->Y - Y;
  if (uVar4 == 2) {
    Arc->X = X - iVar2;
    Arc->Y = Y - iVar3;
  }
  else if (uVar4 == 3) {
    Arc->Y = Y + iVar2;
    Arc->X = X - iVar3;
  }
  else if (uVar4 == 1) {
    Arc->X = iVar3 + X;
    Arc->Y = Y - iVar2;
  }
  if ((Number == '\x03') || (Number == '\x01')) {
    LVar1 = Arc->Height;
    Arc->Height = Arc->Width;
    Arc->Width = LVar1;
  }
  RotateBoxLowLevel(&Arc->BoundingBox,X,Y,Number);
  return;
}



// WARNING: Unknown calling convention

void RotatePolygonLowLevel(PolygonTypePtr Polygon,LocationType X,LocationType Y,BYTE Number)

{
  PointTypePtr pPVar1;
  LocationType dy;
  int iVar2;
  int iVar3;
  Cardinal n;
  int iVar4;
  byte bVar5;
  
  iVar4 = Polygon->PointN - 1;
  if (iVar4 != -1) {
    bVar5 = Number & 3;
    pPVar1 = Polygon->Points + (Polygon->PointN - 1);
    do {
      while( true ) {
        iVar2 = pPVar1->X - X;
        iVar3 = pPVar1->Y - Y;
        if (bVar5 != 2) break;
        iVar4 = iVar4 + -1;
        pPVar1->X = X - iVar2;
        pPVar1->Y = Y - iVar3;
        pPVar1 = pPVar1 + -1;
        if (iVar4 == -1) goto LAB_080c63c7;
      }
      if (bVar5 == 3) {
        pPVar1->X = X - iVar3;
        pPVar1->Y = Y + iVar2;
      }
      else if (bVar5 == 1) {
        pPVar1->X = iVar3 + X;
        pPVar1->Y = Y - iVar2;
      }
      iVar4 = iVar4 + -1;
      pPVar1 = pPVar1 + -1;
    } while (iVar4 != -1);
  }
LAB_080c63c7:
  RotateBoxLowLevel(&Polygon->BoundingBox,X,Y,Number);
  return;
}



// WARNING: Unknown calling convention

void RotateTextLowLevel(TextTypePtr Text,LocationType X,LocationType Y,BYTE Number)

{
  LocationType dx;
  int iVar1;
  byte bVar2;
  LocationType dy;
  BYTE number;
  
  number = Number;
  if (*(char *)&(Text->Flags).f < '\0') {
    number = -Number & 3;
  }
  RotateBoxLowLevel(&Text->BoundingBox,X,Y,Number);
  dy = Text->Y - Y;
  bVar2 = Number & 3;
  iVar1 = Text->X - X;
  if (bVar2 == 2) {
    Text->X = X - iVar1;
    Text->Y = Y - dy;
  }
  else if (bVar2 == 3) {
    Text->X = X - dy;
    Text->Y = iVar1 + Y;
  }
  else if (bVar2 == 1) {
    Text->X = dy + X;
    Text->Y = Y - iVar1;
  }
  Text->Direction = number + Text->Direction & 3;
  return;
}



// WARNING: Unknown calling convention

void RotateLineLowLevel(LineTypePtr Line,LocationType X,LocationType Y,BYTE Number)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  LocationType dx;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  
  local_30 = (Line->Point1).Y;
  iVar3 = (Line->Point1).X;
  iVar2 = local_30 - Y;
  dx = iVar3 - X;
  bVar1 = Number & 3;
  if (bVar1 == 2) {
    iVar3 = X - dx;
    local_30 = Y - iVar2;
    (Line->Point1).X = iVar3;
    local_28 = (Line->Point2).X - X;
    (Line->Point1).Y = local_30;
    local_24 = (Line->Point2).Y - Y;
LAB_080c65ba:
    local_20 = X - local_28;
    local_2c = Y - local_24;
    (Line->Point2).X = local_20;
    (Line->Point2).Y = local_2c;
    if (iVar3 == local_20) goto LAB_080c65d1;
  }
  else {
    if (bVar1 == 3) {
      local_28 = (Line->Point2).X;
      iVar3 = X - iVar2;
      local_30 = Y + dx;
      (Line->Point1).Y = local_30;
      local_28 = local_28 - X;
      local_24 = (Line->Point2).Y;
      (Line->Point1).X = iVar3;
      local_24 = local_24 - Y;
LAB_080c6619:
      local_20 = X - local_24;
      local_2c = Y + local_28;
      (Line->Point2).X = local_20;
      (Line->Point2).Y = local_2c;
    }
    else if (bVar1 == 1) {
      local_30 = Y - dx;
      (Line->Point1).Y = local_30;
      iVar3 = iVar2 + X;
      (Line->Point1).X = iVar3;
      local_28 = (Line->Point2).X - X;
      local_24 = (Line->Point2).Y - Y;
LAB_080c6564:
      local_20 = X + local_24;
      local_2c = Y - local_28;
      (Line->Point2).X = local_20;
      (Line->Point2).Y = local_2c;
    }
    else {
      local_20 = (Line->Point2).X;
      local_28 = local_20 - X;
      local_2c = (Line->Point2).Y;
      local_24 = local_2c - Y;
      if (bVar1 == 2) goto LAB_080c65ba;
      if (bVar1 == 3) goto LAB_080c6619;
      if (bVar1 == 1) goto LAB_080c6564;
    }
    if (iVar3 == local_20) {
LAB_080c65d1:
      if (local_2c < local_30) {
        (Line->Point1).Y = local_2c;
        (Line->Point2).Y = local_30;
      }
      goto LAB_080c6583;
    }
  }
  if ((local_30 == local_2c) && (local_20 < iVar3)) {
    (Line->Point2).X = iVar3;
    (Line->Point1).X = local_20;
  }
LAB_080c6583:
  SetLineBoundingBox(Line);
  return;
}



// WARNING: Unknown calling convention

void * RotateLinePoint(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr Point)

{
  EraseLine(Line);
  if (Layer != (LayerTypePtr)0x0) {
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    r_delete_entry(Layer->line_tree,&Line->BoundingBox);
    RotatePointLowLevel(Point,CenterX,CenterY,Number);
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,&Line->BoundingBox,0);
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
    DrawLine(Layer,Line,0);
    Draw();
    return Line;
  }
  r_delete_entry(PCB->Data->rat_tree,&Line->BoundingBox);
  RotatePointLowLevel(Point,CenterX,CenterY,Number);
  SetLineBoundingBox(Line);
  r_insert_entry(PCB->Data->rat_tree,&Line->BoundingBox,0);
  DrawRat((RatTypePtr)Line,0);
  Draw();
  return Line;
}



// WARNING: Unknown calling convention

void * RotateObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType X,LocationType Y,
                   BYTE Steps)

{
  FlagType *pFVar1;
  bool bVar2;
  LocationType CenterX;
  LocationType CenterY;
  void *pvVar3;
  void *ptr2;
  RubberbandTypePtr ptr;
  RubberbandTypePtr paVar4;
  Boolean changed;
  
  bVar2 = false;
  Number = Steps;
  ::CenterX = X;
  ::CenterY = Y;
  paVar4 = Crosshair.AttachedObject.Rubberband;
  if (Crosshair.AttachedObject.RubberbandN != 0) {
    while( true ) {
      CenterY = ::CenterY;
      CenterX = ::CenterX;
      pFVar1 = &paVar4->Line->Flags;
      pFVar1->f = pFVar1->f & 0xfffffdff;
      AddObjectToRotateUndoList
                (0x1000,paVar4->Layer,paVar4->Line,paVar4->MovedPoint,CenterX,CenterY,Steps);
      EraseLine(paVar4->Line);
      if (paVar4->Layer == (LayerTypePtr)0x0) {
        r_delete_entry(PCB->Data->rat_tree,&paVar4->Line->BoundingBox);
      }
      else {
        RestoreToPolygon((DataType *)PCB->Data,4,paVar4->Layer,paVar4->Line);
        r_delete_entry(paVar4->Layer->line_tree,&paVar4->Line->BoundingBox);
      }
      RotatePointLowLevel(paVar4->MovedPoint,::CenterX,::CenterY,Steps);
      SetLineBoundingBox(paVar4->Line);
      if (paVar4->Layer == (LayerTypePtr)0x0) {
        r_insert_entry(PCB->Data->rat_tree,&paVar4->Line->BoundingBox,0);
        DrawRat((RatTypePtr)paVar4->Line,0);
      }
      else {
        r_insert_entry(paVar4->Layer->line_tree,&paVar4->Line->BoundingBox,0);
        ClearFromPolygon((DataType *)PCB->Data,4,paVar4->Layer,paVar4->Line);
        DrawLine(paVar4->Layer,paVar4->Line,0);
      }
      Crosshair.AttachedObject.RubberbandN = Crosshair.AttachedObject.RubberbandN - 1;
      if (Crosshair.AttachedObject.RubberbandN == 0) break;
      paVar4 = paVar4 + 1;
    }
    bVar2 = true;
    Crosshair.AttachedObject.RubberbandN = 0;
  }
  AddObjectToRotateUndoList(Type,Ptr1,Ptr2,Ptr3,::CenterX,::CenterY,Number);
  pvVar3 = ObjectOperation((ObjectFunctionTypePtr)&RotateFunctions,Type,Ptr1,Ptr2,Ptr3);
  if ((pvVar3 == (void *)0x0) && (!bVar2)) {
    return (void *)0x0;
  }
  Draw();
  IncrementUndoSerialNumber();
  return pvVar3;
}



// WARNING: Unknown calling convention

void RotateScreenObject(LocationType X,LocationType Y,BYTE Steps)

{
  int Type;
  int type;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  Type = SearchScreen(X,Y,0x4412,local_20,&local_24,&local_28);
  if (Type != 0) {
    if ((*(byte *)((int)local_24 + 0x15) & 0x20) == 0) {
      Crosshair.AttachedObject.RubberbandN = 0;
      if ((*(byte *)&(PCB->Flags).f & 0x10) != 0) {
        LookupRubberbandLines(Type,local_20[0],local_24,local_28);
      }
      if (Type == 2) {
        LookupRatLines(2,local_20[0],local_24,local_28);
      }
      RotateObject(Type,local_20[0],local_24,local_28,X,Y,Steps);
      SetChangedFlag('\x01');
    }
    else {
      Message("Sorry, the object is locked\n");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void * RotateArc(LayerTypePtr Layer,ArcTypePtr Arc)

{
  EraseArc(Arc);
  r_delete_entry(Layer->arc_tree,&Arc->BoundingBox);
  RotateArcLowLevel(Arc,CenterX,CenterY,Number);
  r_insert_entry(Layer->arc_tree,&Arc->BoundingBox,0);
  DrawArc(Layer,Arc,0);
  Draw();
  return Arc;
}



// WARNING: Unknown calling convention

void * RotateElementName(ElementTypePtr Element)

{
  TextTypePtr Text;
  Cardinal n;
  int iVar1;
  int iVar2;
  TextTypePtr text;
  
  EraseElementName(Element);
  iVar1 = 2;
  do {
    iVar2 = iVar1 + -1;
    Text = Element->Name + iVar1;
    r_delete_entry(PCB->Data->name_tree[iVar1],&Text->BoundingBox);
    RotateTextLowLevel(Text,CenterX,CenterY,Number);
    r_insert_entry(PCB->Data->name_tree[iVar1],&Text->BoundingBox,0);
    iVar1 = iVar2;
  } while (iVar2 != -1);
  DrawElementName(Element,0);
  Draw();
  return Element;
}



// WARNING: Unknown calling convention

void * RotateText(LayerTypePtr Layer,TextTypePtr Text)

{
  EraseText(Layer,Text);
  RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  r_delete_entry(Layer->text_tree,&Text->BoundingBox);
  RotateTextLowLevel(Text,CenterX,CenterY,Number);
  r_insert_entry(Layer->text_tree,&Text->BoundingBox,0);
  ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  DrawText(Layer,Text,0);
  Draw();
  return Text;
}



// WARNING: Unknown calling convention

void RotateElementLowLevel
               (DataTypePtr Data,ElementTypePtr Element,LocationType X,LocationType Y,BYTE Number)

{
  TextTypePtr Text;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar1;
  LocationType dy_1;
  LocationType dy;
  int iVar2;
  byte bVar3;
  Cardinal n_2;
  LocationType dx;
  TextTypePtr text;
  uint uVar4;
  int iVar5;
  Cardinal n;
  Cardinal n_1;
  PinTypePtr pin;
  PinTypePtr box;
  PadTypePtr pad;
  PadTypePtr Line;
  Cardinal n_3;
  uint local_28;
  
  iVar5 = 2;
  do {
    Text = Element->Name + iVar5;
    if ((Data != (DataTypePtr)0x0) && (Data->name_tree[iVar5] != (rtree_t *)0x0)) {
      r_delete_entry(Data->name_tree[iVar5],&Text->BoundingBox);
    }
    iVar5 = iVar5 + -1;
    RotateTextLowLevel(Text,X,Y,Number);
  } while (iVar5 != -1);
  iVar5 = Element->LineN - 1;
  if (iVar5 != -1) {
    iVar2 = Element->LineN * 0x58;
    do {
      iVar5 = iVar5 + -1;
      RotateLineLowLevel((LineTypePtr)(Element->Line[-1].Flags.t + iVar2 + -0x18),X,Y,Number);
      iVar2 = iVar2 + -0x58;
    } while (iVar5 != -1);
  }
  if (Element->PinN != 0) {
    bVar3 = Number & 3;
    uVar4 = 0;
    local_28 = Element->PinN;
    do {
      box = Element->Pin + uVar4;
      if (Data != (DataTypePtr)0x0) {
        r_delete_entry(Data->pin_tree,&box->BoundingBox);
      }
      RestoreToPolygon((DataType *)Data,0x100,Element,box);
      iVar5 = box->X - X;
      iVar2 = box->Y - Y;
      if (bVar3 == 2) {
        box->X = X - iVar5;
        box->Y = Y - iVar2;
        uVar1 = Element->PinN;
      }
      else {
        if (bVar3 == 3) {
          box->X = X - iVar2;
          box->Y = iVar5 + Y;
        }
        else if (bVar3 == 1) {
          box->X = iVar2 + X;
          box->Y = Y - iVar5;
        }
        uVar1 = Element->PinN;
      }
    } while ((uVar1 != 0) &&
            (uVar4 = (uVar1 + 1 + uVar4) - local_28, local_28 = uVar1, uVar4 < uVar1));
  }
  bVar3 = Number & 3;
  uVar4 = Element->PadN;
  local_28 = 0;
  uVar1 = uVar4;
  while ((uVar1 != 0 && (local_28 < uVar1))) {
    Line = Element->Pad + local_28;
    if (Data != (DataTypePtr)0x0) {
      r_delete_entry(Data->pad_tree,&Line->BoundingBox);
    }
    RestoreToPolygon((DataType *)Data,0x200,Element,Line);
    RotateLineLowLevel((LineTypePtr)Line,X,Y,Number);
    uVar1 = Element->PadN;
    if (Element->PadN == uVar4) {
      local_28 = local_28 + 1;
      uVar1 = uVar4;
    }
  }
  iVar5 = Element->ArcN - 1;
  if (iVar5 != -1) {
    iVar2 = Element->ArcN * 0x44;
    do {
      iVar5 = iVar5 + -1;
      RotateArcLowLevel((ArcTypePtr)(Element->Arc[-1].Flags.t + iVar2 + -0x18),X,Y,Number);
      iVar2 = iVar2 + -0x44;
    } while (iVar5 != -1);
  }
  iVar2 = Element->MarkX - X;
  iVar5 = Element->MarkY - Y;
  if (bVar3 == 2) {
    Element->MarkX = X - iVar2;
    Element->MarkY = Y - iVar5;
  }
  else if (bVar3 == 3) {
    Element->MarkX = X - iVar5;
    Element->MarkY = iVar2 + Y;
  }
  else if (bVar3 == 1) {
    Element->MarkX = iVar5 + X;
    Element->MarkY = Y - iVar2;
  }
  SetElementBoundingBox(Data,Element,&PCB->Font);
  ClearFromPolygon((DataType *)Data,2,Element,Element);
  return;
}



// WARNING: Unknown calling convention

void * RotateElement(ElementTypePtr Element)

{
  EraseElement(Element);
  RotateElementLowLevel(PCB->Data,Element,CenterX,CenterY,Number);
  DrawElement(Element,0);
  Draw();
  return Element;
}



// WARNING: Unknown calling convention

void adjust_bounds(rtree_node *node)

{
  int iVar1;
  rtree_node *prVar2;
  rtree_node *prVar3;
  
  if ((*(byte *)&node->flags & 1) == 0) {
    prVar3 = (node->u).kids[0];
    (node->box).X1 = (prVar3->box).X1;
    (node->box).Y1 = (prVar3->box).Y1;
    (node->box).X2 = (prVar3->box).X2;
    (node->box).Y2 = (prVar3->box).Y2;
    prVar3 = node;
    while (prVar2 = (prVar3->u).kids[1], prVar2 != (rtree_node *)0x0) {
      iVar1 = (prVar2->box).X1;
      if (iVar1 < (node->box).X1) {
        (node->box).X1 = iVar1;
      }
      iVar1 = (prVar2->box).X2;
      if ((node->box).X2 < iVar1) {
        (node->box).X2 = iVar1;
      }
      iVar1 = (prVar2->box).Y1;
      if (iVar1 < (node->box).Y1) {
        (node->box).Y1 = iVar1;
      }
      iVar1 = (prVar2->box).Y2;
      if ((node->box).Y2 < iVar1) {
        (node->box).Y2 = iVar1;
      }
      prVar3 = (rtree_node *)&(prVar3->box).Y1;
      if (prVar3 == (rtree_node *)&node->u) {
        return;
      }
    }
  }
  else {
    (node->box).X1 = (LocationType)(node->u).kids[1];
    (node->box).Y1 = (LocationType)(node->u).kids[2];
    (node->box).X2 = (LocationType)(node->u).kids[3];
    (node->box).Y2 = (LocationType)(node->u).kids[4];
    prVar3 = node;
    do {
      if ((prVar3->u).kids[5] == (rtree_node *)0x0) {
        return;
      }
      iVar1 = (prVar3->u).rects[1].bounds.X1;
      if (iVar1 < (node->box).X1) {
        (node->box).X1 = iVar1;
      }
      iVar1 = (prVar3->u).rects[1].bounds.X2;
      if ((node->box).X2 < iVar1) {
        (node->box).X2 = iVar1;
      }
      iVar1 = (prVar3->u).rects[1].bounds.Y1;
      if (iVar1 < (node->box).Y1) {
        (node->box).Y1 = iVar1;
      }
      iVar1 = (prVar3->u).rects[1].bounds.Y2;
      if ((node->box).Y2 < iVar1) {
        (node->box).Y2 = iVar1;
      }
      prVar3 = (rtree_node *)&prVar3->flags;
    } while (prVar3 != (rtree_node *)((int)&node->u + 0x60));
  }
  return;
}



// WARNING: Unknown calling convention

int __r_search(rtree_node *node,BoxType *query,r_arg *arg)

{
  rtree_node *prVar1;
  int iVar2;
  int iVar3;
  int seen_1;
  int seen;
  int seen_2;
  rtree_node **n_1;
  anon_union_140_2_50bed805_for_u *paVar4;
  int seen_3;
  rtree_node **n;
  
  if ((*(byte *)&node->flags & 1) == 0) {
    if (arg->check_it == (_func_int_BoxType_ptr_void_ptr *)0x0) {
      prVar1 = (node->u).kids[0];
      paVar4 = &node->u;
      if (prVar1 != (rtree_node *)0x0) {
        iVar3 = 0;
        do {
          if ((((prVar1->box).X1 < query->X2) && (query->X1 < (prVar1->box).X2)) &&
             (((prVar1->box).Y1 < query->Y2 && (query->Y1 < (prVar1->box).Y2)))) {
            iVar2 = __r_search(prVar1,query,arg);
            iVar3 = iVar3 + iVar2;
          }
          paVar4 = (anon_union_140_2_50bed805_for_u *)(paVar4->kids + 1);
          prVar1 = paVar4->kids[0];
        } while (prVar1 != (rtree_node *)0x0);
        return iVar3;
      }
    }
    else {
      prVar1 = (node->u).kids[0];
      paVar4 = &node->u;
      if (prVar1 != (rtree_node *)0x0) {
        iVar3 = 0;
        do {
          if (((((prVar1->box).X1 < query->X2) && (query->X1 < (prVar1->box).X2)) &&
              ((prVar1->box).Y1 < query->Y2)) &&
             ((query->Y1 < (prVar1->box).Y2 &&
              (iVar2 = (*arg->check_it)(&prVar1->box,arg->closure), iVar2 != 0)))) {
            iVar2 = __r_search(paVar4->kids[0],query,arg);
            iVar3 = iVar3 + iVar2;
          }
          paVar4 = (anon_union_140_2_50bed805_for_u *)(paVar4->kids + 1);
          prVar1 = paVar4->kids[0];
        } while (prVar1 != (rtree_node *)0x0);
        return iVar3;
      }
    }
  }
  else if (arg->found_it == (_func_int_BoxType_ptr_void_ptr *)0x0) {
    if ((node->u).kids[0] != (rtree_node *)0x0) {
      iVar3 = 0;
      do {
        if ((((node->u).rects[0].bounds.X1 < query->X2) &&
            (query->X1 < (node->u).rects[0].bounds.X2)) &&
           ((node->u).rects[0].bounds.Y1 < query->Y2)) {
          iVar3 = iVar3 + (uint)(query->Y1 < (node->u).rects[0].bounds.Y2);
        }
        paVar4 = &node->u;
        node = (rtree_node *)&node->flags;
      } while (paVar4->kids[5] != (rtree_node *)0x0);
      return iVar3;
    }
  }
  else {
    prVar1 = (node->u).kids[0];
    if (prVar1 != (rtree_node *)0x0) {
      iVar3 = 0;
      do {
        if ((((node->u).rects[0].bounds.X1 < query->X2) &&
            (query->X1 < (node->u).rects[0].bounds.X2)) &&
           (((node->u).rects[0].bounds.Y1 < query->Y2 && (query->Y1 < (node->u).rects[0].bounds.Y2))
           )) {
          iVar2 = (*arg->found_it)(&prVar1->box,arg->closure);
          iVar3 = (iVar3 + 1) - (uint)(iVar2 == 0);
        }
        prVar1 = (rtree_node *)(node->u).rects[1].bptr;
        node = (rtree_node *)&node->flags;
      } while (prVar1 != (rtree_node *)0x0);
      return iVar3;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int r_search(rtree_t *rtree,BoxType *query,_func_int_BoxType_ptr_void_ptr *check_region,
            _func_int_BoxType_ptr_void_ptr *found_rectangle,void *cl)

{
  rtree_node *node;
  int iVar1;
  r_arg arg;
  
  if ((rtree != (rtree_t *)0x0) && (0 < rtree->size)) {
    if (query == (BoxType *)0x0) {
      arg.check_it = check_region;
      arg.found_it = found_rectangle;
      arg.closure = cl;
      iVar1 = __r_search(rtree->root,&rtree->root->box,&arg);
      return iVar1;
    }
    node = rtree->root;
    if (((((node->box).X1 < query->X2) && (query->X1 < (node->box).X2)) &&
        ((node->box).Y1 < query->Y2)) && (query->Y1 < (node->box).Y2)) {
      arg.closure = cl;
      arg.check_it = check_region;
      arg.found_it = found_rectangle;
      iVar1 = __r_search(node,query,&arg);
      return iVar1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int r_region_is_empty(rtree_t *rtree,BoxType *region)

{
  int iVar1;
  jmp_buf env;
  
  iVar1 = _setjmp((__jmp_buf_tag *)env);
  if (iVar1 != 0) {
    return 0;
  }
  r_search(rtree,region,(_func_int_BoxType_ptr_void_ptr *)0x0,__r_region_is_empty_rect_in_reg,env);
  return 1;
}



// WARNING: Unknown calling convention

int __r_sub(rtree_node *node,BoxType *b,BoxType *a,jmp_buf *e)

{
  int iVar1;
  rtree_node *prVar2;
  int iVar3;
  int i;
  
  iVar3 = 0;
  if ((*(byte *)&node->flags & 1) == 0) {
    do {
      prVar2 = *(rtree_node **)((int)&node->u + iVar3 * 4);
      if ((prVar2 != (rtree_node *)0x0) && (iVar1 = __r_sub(prVar2,b,a,e), iVar1 != 0)) {
        return 1;
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 != 6);
  }
  else {
    iVar3 = 0;
    prVar2 = node;
    do {
      if ((prVar2->u).kids[0] == (rtree_node *)b) {
        *(BoxType **)((int)&node->u + iVar3 * 0x14) = a;
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,1);
      }
      iVar3 = iVar3 + 1;
      prVar2 = (rtree_node *)&prVar2->flags;
    } while (iVar3 != 6);
  }
  return 0;
}



// WARNING: Unknown calling convention

void r_substitute(rtree_t *rtree,BoxType *before,BoxType *after)

{
  int iVar1;
  jmp_buf env;
  
  if (before != after) {
    iVar1 = _setjmp((__jmp_buf_tag *)env);
    if (iVar1 == 0) {
      __r_sub(rtree->root,before,after,(jmp_buf *)env);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

int __r_region_is_empty_rect_in_reg(BoxType *box,void *cl)

{
                    // WARNING: Subroutine does not return
  __longjmp_chk(cl,1);
}



// WARNING: Unknown calling convention

Boolean __r_delete(rtree_node *node,BoxType *query)

{
  int iVar1;
  BoxType *pBVar2;
  Boolean BVar3;
  int *piVar4;
  rtree_node *__ptr;
  rtree_node *prVar5;
  uint uVar6;
  int a;
  uint uVar7;
  anon_struct_4_2_4fa06cb1_for_flags aVar8;
  int i;
  int iVar9;
  uint local_20;
  
  if (query->X1 < (node->box).X1) {
    return '\0';
  }
  if (query->Y1 < (node->box).Y1) {
    return '\0';
  }
  if ((node->box).X2 < query->X2) {
    return '\0';
  }
  if ((node->box).Y2 < query->Y2) {
    return '\0';
  }
  while ((*(byte *)&node->flags & 1) == 0) {
    iVar9 = 0;
    while (prVar5 = *(rtree_node **)((int)&node->u + iVar9 * 4), (rtree_node *)query != prVar5) {
      if (prVar5 == (rtree_node *)0x0) {
        return '\0';
      }
      BVar3 = __r_delete(prVar5,query);
      if (BVar3 != '\0') {
        return '\x01';
      }
      iVar9 = iVar9 + 1;
      if (iVar9 == 6) {
        return '\0';
      }
    }
    free(query);
    if (iVar9 < 6) {
      iVar1 = *(int *)((int)&node->u + iVar9 * 4 + 4);
      piVar4 = (int *)((int)&node->u + iVar9 * 4 + 8);
      *(int *)((int)&node->u + iVar9 * 4) = iVar1;
      while ((iVar1 != 0 && (iVar9 = iVar9 + 1, iVar9 < 6))) {
        iVar1 = *piVar4;
        piVar4[-1] = iVar1;
        piVar4 = piVar4 + 1;
      }
    }
    if ((node->u).kids[0] != (rtree_node *)0x0) {
      do {
        adjust_bounds(node);
        node = node->parent;
      } while (node != (rtree_node *)0x0);
      return '\x01';
    }
    prVar5 = node->parent;
    if (prVar5 == (rtree_node *)0x0) {
      *(byte *)&node->flags = *(byte *)&node->flags | 1;
      (node->u).kids[5] = (rtree_node *)0x0;
      (node->u).kids[10] = (rtree_node *)0x0;
      (node->u).kids[0xf] = (rtree_node *)0x0;
      (node->u).kids[0x14] = (rtree_node *)0x0;
      (node->u).kids[0x19] = (rtree_node *)0x0;
      (node->u).kids[0x1e] = (rtree_node *)0x0;
      return '\x01';
    }
    if ((node->box).X1 < (prVar5->box).X1) {
      return '\0';
    }
    if ((node->box).Y1 < (prVar5->box).Y1) {
      return '\0';
    }
    if ((prVar5->box).X2 < (node->box).X2) {
      return '\0';
    }
    pBVar2 = &node->box;
    query = &node->box;
    node = prVar5;
    if ((prVar5->box).Y2 < pBVar2->Y2) {
      return '\0';
    }
  }
  uVar7 = 1;
  local_20 = 0;
  iVar9 = 0;
  prVar5 = node;
  do {
    __ptr = (prVar5->u).kids[0];
    if (__ptr == (rtree_node *)0x0) {
      return '\0';
    }
    if ((rtree_node *)query == __ptr) goto LAB_080c7756;
    iVar9 = iVar9 + 1;
    prVar5 = (rtree_node *)&prVar5->flags;
    local_20 = local_20 | uVar7;
    uVar7 = uVar7 * 2;
  } while (iVar9 != 6);
  __ptr = (node->u).kids[0x1e];
  if (__ptr == (rtree_node *)0x0) {
    return '\0';
  }
LAB_080c7756:
  aVar8 = node->flags;
  uVar6 = (uint)aVar8 >> 1;
  if ((uVar7 & uVar6) != 0) {
    free(__ptr);
    *(undefined4 *)((int)&node->u + iVar9 * 0x14) = 0;
    aVar8 = node->flags;
    uVar6 = (uint)aVar8 >> 1;
  }
  node->flags = (anon_struct_4_2_4fa06cb1_for_flags)
                ((uint)aVar8 & 1 | ((int)(~local_20 * 2 & uVar6) >> 1 | uVar6 & local_20) * 2);
  if (iVar9 < 6) {
    iVar1 = iVar9 * 0x14;
    *(undefined4 *)((int)&node->u + iVar9 * 0x14) = *(undefined4 *)((int)&node->u + iVar1 + 0x14);
    *(undefined4 *)((int)&node->u + iVar9 * 0x14 + 4) =
         *(undefined4 *)((int)&node->u + iVar1 + 0x18);
    *(undefined4 *)((int)&node->u + iVar9 * 0x14 + 8) =
         *(undefined4 *)((int)&node->u + iVar1 + 0x1c);
    *(undefined4 *)((int)&node->u + iVar9 * 0x14 + 0xc) =
         *(undefined4 *)((int)&node->u + iVar1 + 0x20);
    *(undefined4 *)((int)&node->u + iVar9 * 0x14 + 0x10) =
         *(undefined4 *)((int)&node->u + iVar1 + 0x24);
    piVar4 = (int *)((int)&node->u + iVar1 + 0x14);
    iVar1 = *(int *)((int)&node->u + iVar9 * 0x14);
    while ((iVar9 = iVar9 + 1, iVar1 != 0 && (iVar9 < 6))) {
      iVar1 = piVar4[5];
      piVar4[1] = piVar4[6];
      *piVar4 = iVar1;
      piVar4[2] = piVar4[7];
      piVar4[3] = piVar4[8];
      piVar4[4] = piVar4[9];
      piVar4 = piVar4 + 5;
    }
  }
  if ((node->u).kids[0] != (rtree_node *)0x0) {
    do {
      adjust_bounds(node);
      node = node->parent;
    } while (node != (rtree_node *)0x0);
    return '\x01';
  }
  if (node->parent == (rtree_node *)0x0) {
    return '\x01';
  }
  __r_delete(node->parent,&node->box);
  return '\x01';
}



// WARNING: Unknown calling convention

Boolean r_delete_entry(rtree_t *rtree,BoxType *box)

{
  Boolean BVar1;
  Boolean r;
  
  BVar1 = __r_delete(rtree->root,box);
  if (BVar1 != '\0') {
    rtree->size = rtree->size + -1;
  }
  return BVar1;
}



// WARNING: Unknown calling convention

void __r_destroy_tree(rtree_node *node)

{
  rtree_node *prVar1;
  rtree_node *prVar2;
  int iVar3;
  int i;
  uint uVar4;
  int flag;
  
  iVar3 = 0;
  if ((*(byte *)&node->flags & 1) == 0) {
    while (prVar1 = *(rtree_node **)((int)&node->u + iVar3 * 4), prVar1 != (rtree_node *)0x0) {
      iVar3 = iVar3 + 1;
      __r_destroy_tree(prVar1);
      if (iVar3 == 6) {
        free(node);
        return;
      }
    }
  }
  else {
    uVar4 = 1;
    prVar1 = (node->u).kids[0];
    prVar2 = node;
    while (prVar1 != (rtree_node *)0x0) {
      if ((uVar4 & (uint)node->flags >> 1) != 0) {
        free(prVar1);
      }
      if (&prVar2->flags == (anon_struct_4_2_4fa06cb1_for_flags *)((int)&node->u + 0x60)) break;
      uVar4 = uVar4 * 2;
      prVar1 = (prVar2->u).kids[5];
      prVar2 = (rtree_node *)&prVar2->flags;
    }
  }
  free(node);
  return;
}



// WARNING: Unknown calling convention

void r_destroy_tree(rtree_t **rtree)

{
  __r_destroy_tree((*rtree)->root);
  free(*rtree);
  *rtree = (rtree_t *)0x0;
  return;
}



// WARNING: Removing unreachable block (ram,0x080c7a93)
// WARNING: Removing unreachable block (ram,0x080c7a8f)
// WARNING: Unknown calling convention

rtree_node * find_clusters(rtree_node *node)

{
  float fVar1;
  float fVar2;
  float fVar3;
  int iVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  int iVar10;
  int i;
  centroid *pcVar11;
  rtree_node *node_00;
  Boolean *pBVar12;
  byte bVar13;
  rtree_node *prVar14;
  uint uVar15;
  int iVar16;
  undefined4 *puVar17;
  BoxType *b;
  int *piVar18;
  int clust_a;
  int clust_b;
  int iVar19;
  anon_struct_4_2_4fa06cb1_for_flags aVar20;
  int iVar21;
  uint uVar22;
  int flag;
  float b_Y;
  float total_b;
  float total_a;
  float local_a8;
  uint local_9c;
  float local_98;
  float local_94;
  float local_90;
  float local_8c;
  centroid center [7];
  undefined local_24;
  Boolean belong [7];
  
  pcVar11 = center;
  bVar13 = *(byte *)&node->flags;
  iVar10 = 0;
  do {
    piVar18 = (int *)((int)&node->u + iVar10 * 0x14 + 4);
    if ((bVar13 & 1) == 0) {
      piVar18 = *(int **)((int)&node->u + iVar10 * 4);
    }
    iVar19 = *piVar18;
    iVar10 = iVar10 + 1;
    iVar21 = piVar18[2];
    pcVar11->x = (float)(iVar21 + iVar19) * 0.5;
    iVar16 = piVar18[1];
    iVar4 = piVar18[3];
    pcVar11->y = (float)(iVar4 + iVar16) * 0.5;
    pcVar11->area = (float)(iVar4 - iVar16) * (float)(iVar21 - iVar19) + 1.0;
    pcVar11 = pcVar11 + 1;
  } while (iVar10 != 7);
  local_98 = center[6].x;
  local_a8 = center[6].y;
  fVar5 = center[0].y;
  if ((center[6].x == center[0].x) && (center[6].y == center[0].y)) {
    local_98 = center[6].x + 10000.0;
    fVar5 = center[0].y - 10000.0;
  }
  local_9c = 0;
  fVar6 = center[0].x;
  do {
    pcVar11 = center;
    iVar19 = 0;
    pBVar12 = belong;
    iVar10 = 0;
    fVar1 = center[0].x;
    fVar2 = center[0].y;
    while( true ) {
      pcVar11 = pcVar11 + 1;
      if ((float)(iVar10 + 3) *
          ((fVar5 - fVar2) * (fVar5 - fVar2) + (fVar6 - fVar1) * (fVar6 - fVar1)) <
          ((local_a8 - fVar2) * (local_a8 - fVar2) + (local_98 - fVar1) * (local_98 - fVar1)) *
          (float)(iVar19 + 3)) {
        *pBVar12 = '\x01';
        iVar10 = iVar10 + 1;
      }
      else {
        *pBVar12 = '\0';
        iVar19 = iVar19 + 1;
      }
      if (pcVar11 == (centroid *)&local_24) break;
      pBVar12 = pBVar12 + 1;
      fVar1 = pcVar11->x;
      fVar2 = pcVar11->y;
    }
    if (iVar10 == 7) {
      belong[3] = '\0';
    }
    else if (iVar19 == 7) {
      belong[3] = '\x01';
    }
    iVar10 = 0;
    fVar8 = 0.0;
    fVar9 = 0.0;
    local_8c = 0.0;
    local_90 = 0.0;
    local_94 = 0.0;
    fVar7 = 0.0;
    pcVar11 = center;
    fVar1 = center[0].x;
    fVar2 = center[0].y;
    while( true ) {
      if (belong[iVar10] == '\0') {
        fVar3 = pcVar11->area;
        local_8c = fVar1 * fVar3 + local_8c;
        fVar8 = fVar2 * fVar3 + fVar8;
        fVar9 = fVar9 + fVar3;
      }
      else {
        fVar3 = pcVar11->area;
        local_94 = fVar1 * fVar3 + local_94;
        local_90 = fVar2 * fVar3 + local_90;
        fVar7 = fVar7 + fVar3;
      }
      if (iVar10 == 6) break;
      iVar10 = iVar10 + 1;
      fVar1 = pcVar11[1].x;
      fVar2 = pcVar11[1].y;
      pcVar11 = pcVar11 + 1;
    }
  } while ((((((int)ROUND(local_94 / fVar7) != (int)ROUND(fVar6)) ||
             ((int)ROUND(local_90 / fVar7) != (int)ROUND(fVar5))) ||
            ((int)ROUND(local_8c / fVar9) != (int)ROUND(local_98))) ||
           ((int)ROUND(fVar9 / fVar8) != (int)ROUND(local_a8))) &&
          (local_9c = local_9c + 1, fVar5 = local_90 / fVar7, fVar6 = local_94 / fVar7,
          local_a8 = fVar9 / fVar8, local_98 = local_8c / fVar9, local_9c != 6));
  node_00 = (rtree_node *)calloc(1,0xa4);
  node_00->parent = node->parent;
  bVar13 = *(byte *)&node->flags & 1;
  *(byte *)&node_00->flags = *(byte *)&node_00->flags & 0xfe | bVar13;
  if (bVar13 == 0) {
    iVar21 = 0;
    iVar10 = 0;
    iVar19 = 0;
    do {
      while (iVar16 = iVar19, belong[iVar16] == '\0') {
        iVar19 = *(int *)((int)&node->u + iVar16 * 4);
        *(int *)((int)&node_00->u + iVar21 * 4) = iVar19;
        iVar21 = iVar21 + 1;
        *(rtree_node **)(iVar19 + 0x10) = node_00;
        iVar19 = iVar16 + 1;
        if (iVar16 + 1 == 7) goto LAB_080c7ff0;
      }
      *(undefined4 *)((int)&node->u + iVar10 * 4) = *(undefined4 *)((int)&node->u + iVar16 * 4);
      iVar10 = iVar10 + 1;
      iVar19 = iVar16 + 1;
    } while (iVar16 + 1 != 7);
LAB_080c7ff0:
    uVar22 = 0;
    uVar15 = iVar16 + 1U & 0xffffff00;
    aVar20 = node->flags;
  }
  else {
    uVar22 = 1;
    local_98 = 1.401298e-45;
    iVar19 = 0;
    iVar10 = 0;
    local_9c = 1;
    local_90 = 0.0;
    local_94 = 0.0;
    local_8c = 0.0;
    prVar14 = node;
    while( true ) {
      if (belong[iVar19] == '\0') {
        iVar21 = (int)local_8c * 0x14;
        *(rtree_node **)((int)&node_00->u + iVar21) = (prVar14->u).kids[0];
        *(rtree_node **)((int)&node_00->u + iVar21 + 4) = (prVar14->u).kids[1];
        *(rtree_node **)((int)&node_00->u + iVar21 + 8) = (prVar14->u).kids[2];
        *(rtree_node **)((int)&node_00->u + iVar21 + 0xc) = (prVar14->u).kids[3];
        *(rtree_node **)((int)&node_00->u + iVar21 + 0x10) = (prVar14->u).kids[4];
        aVar20 = node->flags;
        if (((uint)aVar20 >> 1 & uVar22) != 0) {
          local_90 = (float)((uint)local_90 | (uint)local_98);
        }
        local_8c = (float)((int)local_8c + 1);
        local_98 = (float)((int)local_98 << 1);
      }
      else {
        iVar21 = iVar10 * 0x14;
        *(rtree_node **)((int)&node->u + iVar21) = (prVar14->u).kids[0];
        *(rtree_node **)((int)&node->u + iVar21 + 4) = (prVar14->u).kids[1];
        *(rtree_node **)((int)&node->u + iVar21 + 8) = (prVar14->u).kids[2];
        *(rtree_node **)((int)&node->u + iVar21 + 0xc) = (prVar14->u).kids[3];
        *(rtree_node **)((int)&node->u + iVar21 + 0x10) = (prVar14->u).kids[4];
        aVar20 = node->flags;
        if (((uint)aVar20 >> 1 & uVar22) != 0) {
          local_94 = (float)((uint)local_94 | local_9c);
        }
        iVar10 = iVar10 + 1;
        local_9c = local_9c << 1;
      }
      if (iVar19 == 6) break;
      prVar14 = (rtree_node *)&prVar14->flags;
      iVar19 = iVar19 + 1;
      uVar22 = uVar22 * 2;
    }
    uVar15 = (uint)local_94 & 0x7fffffff;
    uVar22 = (uint)local_90 & 0x7fffffff;
  }
  node->flags = (anon_struct_4_2_4fa06cb1_for_flags)((uint)aVar20 & 1 | uVar15 * 2);
  node_00->flags = (anon_struct_4_2_4fa06cb1_for_flags)((uint)node_00->flags & 1 | uVar22 * 2);
  if ((*(byte *)&node->flags & 1) == 0) {
    puVar17 = (undefined4 *)((int)&node->u + iVar10 * 4);
    if (iVar10 < 7) {
      do {
        iVar10 = iVar10 + 1;
        *puVar17 = 0;
        puVar17 = puVar17 + 1;
      } while (iVar10 != 7);
    }
  }
  else if (iVar10 < 7) {
    puVar17 = (undefined4 *)((int)&node->u + iVar10 * 0x14);
    do {
      iVar10 = iVar10 + 1;
      *puVar17 = 0;
      puVar17 = puVar17 + 5;
    } while (iVar10 != 7);
  }
  adjust_bounds(node);
  adjust_bounds(node_00);
  return node_00;
}



// WARNING: Unknown calling convention

void __r_insert_node(rtree_node *node,BoxType *query,int manage,Boolean force)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  LocationType LVar7;
  LocationType LVar8;
  LocationType LVar9;
  LocationType LVar10;
  int iVar11;
  int i;
  rtree_node *prVar12;
  rtree_node *new_node;
  rtree_node *prVar13;
  int iVar14;
  int iVar15;
  rtree_node *best_node;
  LocationType *pLVar16;
  int iVar17;
  int i_1;
  int flag;
  rtree_node *prVar18;
  int i_2;
  int iVar19;
  int iVar20;
  rtree_node *second;
  byte bVar21;
  double score;
  longdouble lVar22;
  longdouble lVar23;
  double best_score;
  rtree_node *local_3c;
  int local_24;
  
  bVar21 = 0;
code_r0x080c8050:
  if ((*(byte *)&node->flags & 1) == 0) {
    if (force != '\0') {
      if (query->X1 < (node->box).X1) {
        (node->box).X1 = query->X1;
      }
      if ((node->box).X2 < query->X2) {
        (node->box).X2 = query->X2;
      }
      if (query->Y1 < (node->box).Y1) {
        (node->box).Y1 = query->Y1;
      }
      if ((node->box).Y2 < query->Y2) {
        (node->box).Y2 = query->Y2;
      }
    }
    iVar11 = 0;
    do {
      prVar12 = *(rtree_node **)((int)&node->u + iVar11 * 4);
      if (prVar12 == (rtree_node *)0x0) {
        local_3c = (node->u).kids[0];
        if ((iVar11 < 6) && ((*(byte *)&local_3c->flags & 1) != 0)) {
          pLVar16 = (LocationType *)calloc(1,0xa4);
          *(byte *)(pLVar16 + 5) = *(byte *)(pLVar16 + 5) | 1;
          *(LocationType **)((int)&node->u + iVar11 * 4) = pLVar16;
          pLVar16[4] = (LocationType)node;
          pLVar16[6] = (LocationType)query;
          LVar7 = query->X1;
          pLVar16[7] = LVar7;
          LVar8 = query->Y1;
          pLVar16[8] = LVar8;
          LVar9 = query->X2;
          pLVar16[9] = LVar9;
          LVar10 = query->Y2;
          pLVar16[1] = LVar8;
          *pLVar16 = LVar7;
          pLVar16[2] = LVar9;
          pLVar16[10] = LVar10;
          pLVar16[3] = LVar10;
          if (manage == 0) {
            return;
          }
          pLVar16[5] = pLVar16[5] & 1U | 2;
          return;
        }
        iVar17 = query->X1;
        goto LAB_080c82b9;
      }
      iVar17 = query->X1;
      if (((((prVar12->box).X1 == iVar17 || (prVar12->box).X1 < iVar17) &&
           (query->X2 <= (prVar12->box).X2)) && ((prVar12->box).Y1 <= query->Y1)) &&
         (query->Y2 <= (prVar12->box).Y2)) {
        force = '\0';
        node = prVar12;
        goto code_r0x080c8050;
      }
      iVar11 = iVar11 + 1;
    } while (iVar11 != 6);
    local_3c = (node->u).kids[0];
LAB_080c82b9:
    iVar11 = query->X2;
    iVar1 = (local_3c->box).X2;
    iVar2 = (local_3c->box).X1;
    iVar14 = iVar11;
    if (iVar11 <= iVar1) {
      iVar14 = iVar1;
    }
    iVar20 = iVar2;
    if (iVar17 <= iVar2) {
      iVar20 = iVar17;
    }
    iVar3 = query->Y2;
    iVar4 = (local_3c->box).Y2;
    iVar5 = (local_3c->box).Y1;
    iVar6 = query->Y1;
    iVar15 = iVar3;
    if (iVar3 <= iVar4) {
      iVar15 = iVar4;
    }
    iVar19 = iVar6;
    if (iVar5 <= iVar6) {
      iVar19 = iVar5;
    }
    local_24 = 1;
    lVar22 = (longdouble)(iVar15 - iVar19) * (longdouble)(iVar14 - iVar20) -
             (longdouble)(iVar4 - iVar5) * (longdouble)(iVar1 - iVar2);
    do {
      prVar12 = *(rtree_node **)((int)&node->u + local_24 * 4);
      if (prVar12 == (rtree_node *)0x0) break;
      iVar1 = (prVar12->box).X2;
      iVar2 = (prVar12->box).X1;
      iVar14 = iVar11;
      if (iVar11 <= iVar1) {
        iVar14 = iVar1;
      }
      iVar20 = iVar17;
      if (iVar2 < iVar17) {
        iVar20 = iVar2;
      }
      iVar4 = (prVar12->box).Y1;
      iVar5 = (prVar12->box).Y2;
      iVar15 = iVar3;
      if (iVar3 <= iVar5) {
        iVar15 = iVar5;
      }
      iVar19 = iVar6;
      if (iVar4 <= iVar6) {
        iVar19 = iVar4;
      }
      lVar23 = (longdouble)(iVar15 - iVar19) * (longdouble)(iVar14 - iVar20) -
               (longdouble)(iVar5 - iVar4) * (longdouble)(iVar1 - iVar2);
      if (lVar23 < lVar22) {
        lVar22 = lVar23;
        local_3c = prVar12;
      }
      local_24 = local_24 + 1;
    } while (local_24 != 6);
    force = '\x01';
    node = local_3c;
    goto code_r0x080c8050;
  }
  iVar11 = 0;
  prVar12 = node;
  if (manage == 0) {
    do {
      if ((prVar12->u).kids[0] == (rtree_node *)0x0) goto LAB_080c80a5;
      iVar11 = iVar11 + 1;
      prVar12 = (rtree_node *)&prVar12->flags;
    } while (iVar11 != 6);
    (node->u).rects[6].bptr = query;
    (node->u).kids[0x1f] = (rtree_node *)query->X1;
    (node->u).kids[0x20] = (rtree_node *)query->Y1;
    (node->u).kids[0x21] = (rtree_node *)query->X2;
    (node->u).kids[0x22] = (rtree_node *)query->Y2;
  }
  else {
    flag = 1;
    do {
      if ((prVar12->u).kids[0] == (rtree_node *)0x0) break;
      iVar11 = iVar11 + 1;
      flag = flag * 2;
      prVar12 = (rtree_node *)&prVar12->flags;
    } while (iVar11 != 6);
    node->flags = (anon_struct_4_2_4fa06cb1_for_flags)
                  ((uint)node->flags & 1 | ((uint)node->flags >> 1 | flag) * 2);
LAB_080c80a5:
    *(BoxType **)((int)&node->u + iVar11 * 0x14) = query;
    *(LocationType *)((int)&node->u + iVar11 * 0x14 + 4) = query->X1;
    *(LocationType *)((int)&node->u + iVar11 * 0x14 + 8) = query->Y1;
    *(LocationType *)((int)&node->u + iVar11 * 0x14 + 0xc) = query->X2;
    *(LocationType *)((int)&node->u + iVar11 * 0x14 + 0x10) = query->Y2;
    if (iVar11 == 0) {
      (node->box).X1 = query->X1;
      (node->box).Y1 = query->Y1;
      (node->box).X2 = query->X2;
      (node->box).Y2 = query->Y2;
      return;
    }
  }
  if (force != '\0') {
    if (query->X1 < (node->box).X1) {
      (node->box).X1 = query->X1;
    }
    if ((node->box).X2 < query->X2) {
      (node->box).X2 = query->X2;
    }
    if (query->Y1 < (node->box).Y1) {
      (node->box).Y1 = query->Y1;
    }
    if ((node->box).Y2 < query->Y2) {
      (node->box).Y2 = query->Y2;
    }
  }
  if (iVar11 < 6) {
    return;
  }
  prVar12 = find_clusters(node);
  prVar18 = node->parent;
  do {
    prVar13 = prVar18;
    if (prVar13 == (rtree_node *)0x0) {
      prVar13 = (rtree_node *)calloc(1,0xa4);
      prVar18 = node;
      second = prVar13;
      for (iVar11 = 0x29; iVar11 != 0; iVar11 = iVar11 + -1) {
        second = (rtree_node *)((int)second + (uint)bVar21 * -8 + 4);
        (second->box).X1 = (prVar18->box).X1;
        prVar18 = (rtree_node *)((int)prVar18 + (uint)bVar21 * -8 + 4);
        second = second;
      }
      iVar11 = 0;
      if ((*(byte *)&prVar13->flags & 1) == 0) {
        do {
          iVar17 = *(int *)((int)&prVar13->u + iVar11 * 4);
          if (iVar17 != 0) {
            *(rtree_node **)(iVar17 + 0x10) = prVar13;
          }
          iVar11 = iVar11 + 1;
        } while (iVar11 != 6);
      }
      *(byte *)&node->flags = *(byte *)&node->flags & 0xfe;
      node->flags = (anon_struct_4_2_4fa06cb1_for_flags)((uint)node->flags & 1);
      (node->u).kids[1] = prVar13;
      prVar12->parent = node;
      (node->u).kids[0] = prVar12;
      prVar13->parent = node;
      (node->u).kids[2] = (rtree_node *)0x0;
      (node->u).kids[3] = (rtree_node *)0x0;
      (node->u).kids[4] = (rtree_node *)0x0;
      (node->u).kids[5] = (rtree_node *)0x0;
      (node->u).kids[6] = (rtree_node *)0x0;
      adjust_bounds(node);
      return;
    }
    i_1 = 0;
    do {
      if (*(int *)((int)&prVar13->u + i_1 * 4) == 0) {
        *(rtree_node **)((int)&prVar13->u + i_1 * 4) = prVar12;
        return;
      }
      i_1 = i_1 + 1;
    } while (i_1 != 6);
    (prVar13->u).kids[6] = prVar12;
    prVar12 = find_clusters(prVar13);
    prVar18 = prVar13->parent;
    node = prVar13;
  } while( true );
}



// WARNING: Unknown calling convention

void r_insert_entry(rtree_t *rtree,BoxType *which,int man)

{
  rtree_node *node;
  bool force;
  
  node = rtree->root;
  if (((which->X1 < (node->box).X1) || ((node->box).X2 < which->X2)) || (which->Y1 < (node->box).Y1)
     ) {
    force = true;
  }
  else {
    force = (node->box).Y2 < which->Y2;
  }
  __r_insert_node(node,which,man,force);
  rtree->size = rtree->size + 1;
  return;
}



// WARNING: Unknown calling convention

rtree_t * r_create_tree(BoxType **boxlist,int N,int manage)

{
  rtree_t *rtree;
  rtree_node *prVar1;
  int iVar2;
  int i;
  
  rtree = (rtree_t *)calloc(1,8);
  prVar1 = (rtree_node *)calloc(1,0xa4);
  *(byte *)&prVar1->flags = *(byte *)&prVar1->flags | 1;
  prVar1->parent = (rtree_node *)0x0;
  rtree->root = prVar1;
  if (0 < N) {
    iVar2 = 0;
    do {
      r_insert_entry(rtree,boxlist[iVar2],manage);
      iVar2 = iVar2 + 1;
    } while (iVar2 < N);
  }
  return rtree;
}



// WARNING: Unknown calling convention

void CheckPinForRubberbandConnection(PinTypePtr Pin)

{
  int iVar1;
  int iVar2;
  DataTypePtr paVar3;
  Cardinal n;
  uint uVar4;
  uint uVar5;
  rubber_info info;
  
  iVar1 = Pin->X;
  info.line = (LineTypePtr)0x0;
  info.radius = Pin->Thickness / 2;
  info.box.X1 = iVar1 - info.radius;
  info.box.X2 = info.radius + iVar1;
  iVar2 = Pin->Y;
  info.box.Y1 = iVar2 - info.radius;
  info.box.Y2 = info.radius + iVar2;
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 1) != 0) {
    info.radius = 0;
    iVar1 = info.X;
    iVar2 = info.Y;
  }
  info.Y = iVar2;
  info.X = iVar1;
  paVar3 = PCB->Data;
  if (paVar3->LayerN != 0) {
    uVar4 = 0;
    do {
      uVar5 = uVar4 + 1;
      info.layer = paVar3->Layer + uVar4;
      r_search(paVar3->Layer[uVar4].line_tree,&info.box,(_func_int_BoxType_ptr_void_ptr *)0x0,
               rubber_callback,&info);
      paVar3 = PCB->Data;
      uVar4 = uVar5;
    } while (uVar5 <= (uint)paVar3->LayerN && paVar3->LayerN != uVar5);
  }
  return;
}



// WARNING: Unknown calling convention

int rubber_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  bool bVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  int found;
  int iVar13;
  int iVar14;
  float dist1;
  float dist2;
  float rad;
  
  if (((*(byte *)((int)&b[1].Y1 + 1) & 0x20) != 0) || (*(BoxType **)((int)cl + 0xc) == b)) {
    return 0;
  }
                    // WARNING: Load size is inaccurate
  iVar13 = *cl;
  iVar14 = b[2].Y1 / 2;
  if (iVar13 != 0) {
    if (iVar13 < 0) {
      fVar4 = 0.0;
    }
    else {
      fVar4 = (float)(iVar14 + iVar13) * (float)(iVar14 + iVar13);
    }
    fVar5 = (float)(*(int *)((int)cl + 4) - b[2].Y2);
    fVar6 = (float)(*(int *)((int)cl + 8) - b[3].X1);
    fVar5 = (fVar6 * fVar6 + fVar5 * fVar5) - fVar4;
    fVar6 = (float)(*(int *)((int)cl + 4) - b[4].X1);
    fVar7 = (float)(*(int *)((int)cl + 8) - b[4].Y1);
    fVar4 = (fVar7 * fVar7 + fVar6 * fVar6) - fVar4;
    if ((0.0 < fVar5) && (0.0 < fVar4)) {
      return 0;
    }
    if (fVar5 <= 0.0) {
      CreateNewRubberbandEntry
                (*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)&b[2].Y2);
    }
    if (fVar4 <= 0.0) {
      CreateNewRubberbandEntry
                (*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)(b + 4));
      return 1;
    }
    return 1;
  }
  iVar13 = b[2].Y2;
  iVar9 = *(int *)((int)cl + 0x10);
  if ((iVar9 <= iVar14 + iVar13) && (iVar11 = *(int *)((int)cl + 0x18), iVar13 - iVar14 <= iVar11))
  {
    iVar12 = b[3].X1;
    iVar1 = *(int *)((int)cl + 0x14);
    if ((iVar1 <= iVar12 + iVar14) && (iVar2 = *(int *)((int)cl + 0x1c), iVar12 - iVar14 <= iVar2))
    {
      if (((iVar13 < iVar9) || (iVar11 < iVar13)) && ((iVar12 < iVar1 || (iVar2 < iVar12)))) {
        uVar10 = iVar9 - iVar13 >> 0x1f;
        iVar3 = (uVar10 ^ iVar9 - iVar13) - uVar10;
        uVar10 = iVar11 - iVar13 >> 0x1f;
        iVar13 = (iVar11 - iVar13 ^ uVar10) - uVar10;
        if (iVar3 <= iVar13) {
          iVar13 = iVar3;
        }
        uVar10 = iVar1 - iVar12 >> 0x1f;
        iVar11 = (iVar1 - iVar12 ^ uVar10) - uVar10;
        uVar10 = iVar2 - iVar12 >> 0x1f;
        iVar12 = (iVar2 - iVar12 ^ uVar10) - uVar10;
        if (iVar12 < iVar11) {
          iVar11 = iVar12;
        }
        if ((longdouble)0 <
            ((longdouble)iVar11 * (longdouble)iVar11 + (longdouble)iVar13 * (longdouble)iVar13) -
            (longdouble)(iVar14 * iVar14)) goto LAB_080c8870;
      }
      CreateNewRubberbandEntry
                (*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)&b[2].Y2);
      iVar9 = *(int *)((int)cl + 0x10);
      iVar13 = 1;
      bVar8 = true;
      goto LAB_080c8879;
    }
  }
LAB_080c8870:
  iVar13 = 0;
  bVar8 = false;
LAB_080c8879:
  iVar11 = b[4].X1;
  if (iVar11 + iVar14 < iVar9) {
    return iVar13;
  }
  iVar12 = *(int *)((int)cl + 0x18);
  if (iVar12 < iVar11 - iVar14) {
    return iVar13;
  }
  iVar1 = b[4].Y1;
  iVar2 = *(int *)((int)cl + 0x14);
  if (iVar1 + iVar14 < iVar2) {
    return iVar13;
  }
  iVar3 = *(int *)((int)cl + 0x1c);
  if (iVar1 - iVar14 <= iVar3) {
    if (((iVar11 < iVar9) || (iVar12 < iVar11)) && ((iVar1 < iVar2 || (iVar3 < iVar1)))) {
      uVar10 = iVar9 - iVar11 >> 0x1f;
      iVar9 = (iVar9 - iVar11 ^ uVar10) - uVar10;
      uVar10 = iVar12 - iVar11 >> 0x1f;
      iVar11 = (iVar12 - iVar11 ^ uVar10) - uVar10;
      if (iVar11 < iVar9) {
        iVar9 = iVar11;
      }
      uVar10 = iVar2 - iVar1 >> 0x1f;
      iVar11 = (iVar2 - iVar1 ^ uVar10) - uVar10;
      uVar10 = iVar3 - iVar1 >> 0x1f;
      iVar12 = (iVar3 - iVar1 ^ uVar10) - uVar10;
      if (iVar12 < iVar11) {
        iVar11 = iVar12;
      }
      if (((longdouble)0 <
           ((longdouble)iVar11 * (longdouble)iVar11 + (longdouble)iVar9 * (longdouble)iVar9) -
           (longdouble)(iVar14 * iVar14)) && (!bVar8)) {
        return iVar13;
      }
    }
    CreateNewRubberbandEntry(*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)(b + 4))
    ;
    return iVar13 + 1;
  }
  return iVar13;
}



// WARNING: Unknown calling convention

int rat_callback(BoxType *box,void *cl)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  iVar1 = *cl;
  if (iVar1 == 0x200) {
    iVar1 = *(int *)((int)cl + 0xc);
    if (((box[2].Y2 == *(int *)(iVar1 + 0x2c)) && (box[3].X1 == *(int *)(iVar1 + 0x30))) &&
       (box[5].Y1 == *(int *)((int)cl + 4))) goto LAB_080c8b40;
    if (((*(int *)(iVar1 + 0x2c) != box[4].X1) || (box[4].Y1 != *(int *)(iVar1 + 0x30))) ||
       (box[5].X2 != *(int *)((int)cl + 4))) {
      if (((box[2].Y2 == *(int *)(iVar1 + 0x40)) && (box[3].X1 == *(int *)(iVar1 + 0x44))) &&
         (box[5].Y1 == *(int *)((int)cl + 4))) goto LAB_080c8b40;
      if (box[4].X1 != *(int *)(iVar1 + 0x40)) {
        return 0;
      }
      if (box[4].Y1 != *(int *)(iVar1 + 0x44)) {
        return 0;
      }
      if (box[5].X2 != *(int *)((int)cl + 4)) {
        return 0;
      }
    }
  }
  else if (iVar1 == 0x1000) {
    if (((box[5].Y1 == *(int *)((int)cl + 4)) && (box[2].Y2 == **(int **)((int)cl + 0x10))) &&
       (box[3].X1 == (*(int **)((int)cl + 0x10))[1])) goto LAB_080c8b40;
    if (*(int *)((int)cl + 4) != box[5].X2) {
      return 0;
    }
    if (box[4].X1 != **(int **)((int)cl + 0x10)) {
      return 0;
    }
    if (box[4].Y1 != (*(int **)((int)cl + 0x10))[1]) {
      return 0;
    }
  }
  else {
    if (iVar1 != 0x100) {
      Message("hace: bad rubber-rat lookup callback\n");
      return 0;
    }
    iVar1 = *(int *)((int)cl + 8);
    if ((box[2].Y2 == *(int *)(iVar1 + 0x34)) && (box[3].X1 == *(int *)(iVar1 + 0x38))) {
LAB_080c8b40:
      CreateNewRubberbandEntry((LayerTypePtr)0x0,(LineTypePtr)box,(PointTypePtr)&box[2].Y2);
      return 0;
    }
    if (*(int *)(iVar1 + 0x34) != box[4].X1) {
      return 0;
    }
    if (box[4].Y1 != *(int *)(iVar1 + 0x38)) {
      return 0;
    }
  }
  CreateNewRubberbandEntry((LayerTypePtr)0x0,(LineTypePtr)box,(PointTypePtr)(box + 4));
  return 0;
}



// WARNING: Unknown calling convention

void CheckLinePointForRat(LayerTypePtr Layer,PointTypePtr Point)

{
  rinfo info;
  
  info.group = GetLayerGroupNumberByPointer(Layer);
  info.type = 0x1000;
  info.point = Point;
  r_search(PCB->Data->rat_tree,(BoxType *)Point,(_func_int_BoxType_ptr_void_ptr *)0x0,rat_callback,
           &info);
  return;
}



// WARNING: Unknown calling convention

void LookupRatLines(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  Cardinal sn_1;
  PinTypePtr pin;
  Cardinal n;
  uint uVar1;
  PadTypePtr query;
  Cardinal n_1;
  Cardinal sn;
  uint uVar2;
  uint uVar3;
  int local_40;
  rinfo info;
  
  if (Type == 2) {
    if (*(uint *)((int)Ptr1 + 0xe0) != 0) {
      uVar1 = 0;
      uVar2 = *(uint *)((int)Ptr1 + 0xe0);
      do {
        pin = (PinTypePtr)(uVar1 * 0x4c + *(int *)((int)Ptr1 + 0x100));
        info.type = 0x100;
        info.pin = pin;
        r_search(PCB->Data->rat_tree,(BoxType *)pin,(_func_int_BoxType_ptr_void_ptr *)0x0,
                 rat_callback,&info);
        uVar3 = *(uint *)((int)Ptr1 + 0xe0);
        if (uVar3 == 0) break;
        uVar1 = (uVar3 + 1 + uVar1) - uVar2;
        uVar2 = uVar3;
      } while (uVar1 < uVar3);
    }
    uVar2 = *(uint *)((int)Ptr1 + 0xe8);
    uVar3 = 0;
    local_40 = 0;
    uVar1 = uVar2;
    while ((uVar1 != 0 && (uVar3 < uVar1))) {
      query = (PadTypePtr)(local_40 + *(int *)((int)Ptr1 + 0x104));
      info.group = GetLayerGroupNumberByNumber
                             ((((query->Flags).f >> 7 ^ 1) & 1) + PCB->Data->LayerN);
      info.type = 0x200;
      info.pad = query;
      r_search(PCB->Data->rat_tree,(BoxType *)query,(_func_int_BoxType_ptr_void_ptr *)0x0,
               rat_callback,&info);
      uVar1 = *(uint *)((int)Ptr1 + 0xe8);
      if (*(uint *)((int)Ptr1 + 0xe8) == uVar2) {
        uVar3 = uVar3 + 1;
        local_40 = local_40 + 0x68;
        uVar1 = uVar2;
      }
    }
  }
  else if (Type < 3) {
    if (Type == 1) {
      info.type = 0x100;
      info.pin = (PinTypePtr)Ptr1;
      r_search(PCB->Data->rat_tree,(BoxType *)Ptr1,(_func_int_BoxType_ptr_void_ptr *)0x0,
               rat_callback,&info);
    }
  }
  else {
    if (Type == 4) {
      CheckLinePointForRat((LayerTypePtr)Ptr1,(PointTypePtr)((int)Ptr2 + 0x2c));
      CheckLinePointForRat((LayerTypePtr)Ptr1,(PointTypePtr)((int)Ptr2 + 0x40));
      return;
    }
    if (Type == 0x1000) {
      CheckLinePointForRat((LayerTypePtr)Ptr1,(PointTypePtr)Ptr3);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void CheckLinePointForRubberbandConnection
               (LayerTypePtr Layer,LineTypePtr Line,PointTypePtr LinePoint,Boolean Exact)

{
  Cardinal *pCVar1;
  uint uVar2;
  Cardinal group;
  Cardinal number;
  PCBType *pPVar3;
  DataTypePtr paVar4;
  int iVar5;
  uint uVar6;
  Cardinal entry;
  BDimension t;
  PCBTypePtr pPVar7;
  rubber_info info;
  
  iVar5 = Line->Thickness / 2;
  info.radius = -1;
  if ((Exact == '\0') && (info.radius = 1, 3 < Line->Thickness)) {
    info.radius = iVar5;
  }
  info.X = LinePoint->X;
  info.box.X1 = info.X - iVar5;
  info.box.X2 = iVar5 + info.X;
  info.Y = LinePoint->Y;
  info.box.Y1 = info.Y - iVar5;
  info.box.Y2 = iVar5 + info.Y;
  info.line = Line;
  iVar5 = GetLayerGroupNumberByPointer(Layer);
  paVar4 = PCB->Data;
  pPVar3 = paVar4->pcb;
  if ((pPVar3->LayerGroups).Number[iVar5] != 0) {
    uVar6 = 0;
    pPVar7 = PCB;
    do {
      uVar2 = (pPVar3->LayerGroups).Entries[iVar5][uVar6];
      if (uVar2 < (uint)paVar4->LayerN) {
        if (paVar4->Layer[uVar2].On != '\0') {
          info.layer = paVar4->Layer + uVar2;
          r_search(paVar4->Layer[uVar2].line_tree,&info.box,(_func_int_BoxType_ptr_void_ptr *)0x0,
                   rubber_callback,&info);
          pPVar7 = PCB;
        }
      }
      paVar4 = pPVar7->Data;
      uVar6 = uVar6 + 1;
      pPVar3 = paVar4->pcb;
      pCVar1 = (pPVar3->LayerGroups).Number + iVar5;
    } while (uVar6 <= *pCVar1 && *pCVar1 != uVar6);
  }
  return;
}



// WARNING: Unknown calling convention

void LookupRubberbandLines(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  uint uVar1;
  int iVar2;
  Cardinal CVar3;
  Boolean BVar4;
  Cardinal sn;
  PadTypePtr pad;
  Cardinal group;
  Cardinal number;
  int iVar5;
  DataTypePtr paVar6;
  PCBType *pPVar7;
  Cardinal number_1;
  Cardinal entry_1;
  int iVar8;
  uint uVar9;
  int iVar10;
  Cardinal entry;
  uint uVar11;
  Cardinal n_1;
  int iVar12;
  Cardinal sn_1;
  int iVar13;
  PCBTypePtr pPVar14;
  LineTypePtr line;
  int iVar15;
  LineTypePtr Line;
  int local_5c;
  uint local_58;
  rubber_info info;
  
  if (Type == 4) {
    iVar5 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1);
    if (iVar5 < PCB->Data->LayerN) {
      CheckLinePointForRubberbandConnection
                ((LayerTypePtr)Ptr1,(LineTypePtr)Ptr2,(PointTypePtr)((int)Ptr2 + 0x2c),'\0');
      CheckLinePointForRubberbandConnection
                ((LayerTypePtr)Ptr1,(LineTypePtr)Ptr2,(PointTypePtr)((int)Ptr2 + 0x40),'\0');
    }
  }
  else if (Type < 5) {
    if (Type == 1) {
      CheckPinForRubberbandConnection((PinTypePtr)Ptr1);
      return;
    }
    if (Type == 2) {
      if (*(uint *)((int)Ptr1 + 0xe0) != 0) {
        uVar11 = 0;
        uVar9 = *(uint *)((int)Ptr1 + 0xe0);
        do {
          CheckPinForRubberbandConnection((PinTypePtr)(uVar11 * 0x4c + *(int *)((int)Ptr1 + 0x100)))
          ;
          uVar1 = *(uint *)((int)Ptr1 + 0xe0);
          if (uVar1 == 0) break;
          uVar11 = (uVar1 + 1 + uVar11) - uVar9;
          uVar9 = uVar1;
        } while (uVar11 < uVar1);
      }
      local_5c = 0;
      local_58 = 0;
      uVar9 = *(uint *)((int)Ptr1 + 0xe8);
      uVar11 = uVar9;
      while ((uVar11 != 0 && (local_58 < uVar11))) {
        info.line = (LineTypePtr)0x0;
        iVar10 = local_5c + *(int *)((int)Ptr1 + 0x104);
        iVar5 = *(int *)(iVar10 + 0x2c);
        iVar12 = *(int *)(iVar10 + 0x40);
        iVar8 = *(int *)(iVar10 + 0x24) / 2;
        iVar13 = iVar12;
        if (iVar5 <= iVar12) {
          iVar13 = iVar5;
        }
        info.box.X1 = iVar13 - iVar8;
        iVar13 = *(int *)(iVar10 + 0x30);
        iVar2 = *(int *)(iVar10 + 0x44);
        info.radius = 0;
        iVar15 = iVar2;
        if (iVar13 <= iVar2) {
          iVar15 = iVar13;
        }
        info.box.Y1 = iVar15 - iVar8;
        if (iVar12 <= iVar5) {
          iVar12 = iVar5;
        }
        info.box.X2 = iVar12 + iVar8;
        if (iVar13 < iVar2) {
          iVar13 = iVar2;
        }
        info.box.Y2 = iVar13 + iVar8;
        iVar5 = GetLayerGroupNumberByNumber
                          (((*(uint *)(iVar10 + 0x14) >> 7 ^ 1) & 1) + PCB->Data->LayerN);
        paVar6 = PCB->Data;
        pPVar7 = paVar6->pcb;
        if ((pPVar7->LayerGroups).Number[iVar5] != 0) {
          uVar11 = 0;
          pPVar14 = PCB;
          do {
            uVar1 = (pPVar7->LayerGroups).Entries[iVar5][uVar11];
            if (uVar1 < (uint)paVar6->LayerN) {
              info.layer = paVar6->Layer + uVar1;
              if (paVar6->Layer[uVar1].On != '\0') {
                r_search(paVar6->Layer[uVar1].line_tree,&info.box,
                         (_func_int_BoxType_ptr_void_ptr *)0x0,rubber_callback,&info);
                pPVar14 = PCB;
              }
            }
            paVar6 = pPVar14->Data;
            uVar11 = uVar11 + 1;
            pPVar7 = paVar6->pcb;
          } while (uVar11 < (pPVar7->LayerGroups).Number[iVar5]);
        }
        uVar11 = *(uint *)((int)Ptr1 + 0xe8);
        if (*(uint *)((int)Ptr1 + 0xe8) == uVar9) {
          local_58 = local_58 + 1;
          local_5c = local_5c + 0x68;
          uVar11 = uVar9;
        }
      }
    }
  }
  else if (Type == 8) {
    iVar5 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1);
    if (iVar5 < PCB->Data->LayerN) {
      iVar5 = GetLayerGroupNumberByPointer((LayerTypePtr)Ptr1);
      paVar6 = PCB->Data;
      pPVar7 = paVar6->pcb;
      if ((pPVar7->LayerGroups).Number[iVar5] != 0) {
        uVar9 = 0;
        pPVar14 = PCB;
        do {
          uVar11 = (pPVar7->LayerGroups).Entries[iVar5][uVar9];
          if (uVar11 < (uint)paVar6->LayerN) {
            if (paVar6->Layer[uVar11].On != '\0') {
              CVar3 = paVar6->Layer[uVar11].LineN;
              iVar12 = CVar3 - 1;
              if (iVar12 != -1) {
                iVar13 = CVar3 * 0x58 + -0x58;
                do {
                  while (Line = (LineTypePtr)
                                (((paVar6->Layer[uVar11].Line)->Flags).t + iVar13 + -0x18),
                        ((Line->Flags).f & 0x2020) != 0) {
LAB_080c91e0:
                    iVar12 = iVar12 + -1;
                    iVar13 = iVar13 + -0x58;
                    pPVar14 = PCB;
                    if (iVar12 == -1) goto LAB_080c9299;
                  }
                  iVar10 = (Line->Thickness + 1) / 2;
                  BVar4 = IsPointInPolygon((Line->Point1).X,(Line->Point1).Y,iVar10,
                                           (PolygonTypePtr)Ptr2);
                  if (BVar4 != '\0') {
                    CreateNewRubberbandEntry(paVar6->Layer + uVar11,Line,&Line->Point1);
                  }
                  BVar4 = IsPointInPolygon((Line->Point2).X,(Line->Point2).Y,iVar10,
                                           (PolygonTypePtr)Ptr2);
                  if (BVar4 == '\0') goto LAB_080c91e0;
                  iVar12 = iVar12 + -1;
                  iVar13 = iVar13 + -0x58;
                  CreateNewRubberbandEntry(paVar6->Layer + uVar11,Line,&Line->Point2);
                  pPVar14 = PCB;
                } while (iVar12 != -1);
              }
            }
          }
LAB_080c9299:
          paVar6 = pPVar14->Data;
          uVar9 = uVar9 + 1;
          pPVar7 = paVar6->pcb;
        } while (uVar9 < (pPVar7->LayerGroups).Number[iVar5]);
      }
    }
  }
  else if ((Type == 0x1000) &&
          (iVar5 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1), iVar5 < PCB->Data->LayerN)) {
    CheckLinePointForRubberbandConnection
              ((LayerTypePtr)Ptr1,(LineTypePtr)Ptr2,(PointTypePtr)Ptr3,'\x01');
  }
  return;
}



// WARNING: Unknown calling convention

int linepoint_callback(BoxType *b,void *cl)

{
  float fVar1;
  bool bVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  uint uVar6;
  int ret_val;
  float d;
  
  fVar5 = PosY;
  fVar3 = PosX;
  uVar6 = 0;
  if ((b[1].Y1 & *(uint *)((int)cl + 0xa8)) == 0) {
    fVar1 = PosX - (float)b[2].Y2;
    fVar4 = PosY - (float)b[3].X1;
    fVar4 = fVar4 * fVar4 + fVar1 * fVar1;
    fVar1 = *(float *)((int)cl + 8);
    bVar2 = fVar4 < fVar1;
    if (bVar2) {
                    // WARNING: Load size is inaccurate
      *(float *)((int)cl + 8) = fVar4;
      **cl = b;
      **(LocationType ***)((int)cl + 4) = &b[2].Y2;
      fVar1 = fVar4;
    }
    uVar6 = (uint)bVar2;
    fVar3 = fVar3 - (float)b[4].X1;
    fVar5 = fVar5 - (float)b[4].Y1;
    fVar3 = fVar5 * fVar5 + fVar3 * fVar3;
    if (fVar3 < fVar1) {
                    // WARNING: Load size is inaccurate
      *(float *)((int)cl + 8) = fVar3;
      **cl = b;
      **(BoxType ***)((int)cl + 4) = b + 4;
      uVar6 = 1;
    }
  }
  return uVar6;
}



// WARNING: Unknown calling convention

int name_callback(BoxType *box,void *cl)

{
  int iVar1;
  uint uVar2;
  BoxType **ppBVar3;
  float fVar4;
  int iVar5;
  float newarea;
  
  iVar1 = box[3].X2;
  if (((((box[1].Y1 & *(uint *)((int)cl + 0xb0)) != 0) ||
       (((uVar2 = *(uint *)(iVar1 + 0x14), (uVar2 >> 7 & 1) != (int)Settings.ShowSolderSide &&
         (*(char *)((int)cl + 0xc) == '\0')) || ((uVar2 & 0x10) != 0)))) ||
      (((PosX < (float)box->X1 || ((float)box->X2 < PosX)) || (PosY < (float)box->Y1)))) ||
     ((float)box->Y2 < PosY)) {
    iVar5 = 0;
  }
  else {
    iVar5 = 1;
    fVar4 = (float)(box->Y2 - box->Y1) * (float)(box->X2 - box->X1);
    if (fVar4 < *(float *)((int)cl + 0x10)) {
                    // WARNING: Load size is inaccurate
      *(float *)((int)cl + 0x10) = fVar4;
      **cl = iVar1;
      ppBVar3 = *(BoxType ***)((int)cl + 4);
      **(BoxType ***)((int)cl + 8) = box;
      *ppBVar3 = box;
      iVar5 = 1;
    }
  }
  return iVar5;
}



// WARNING: Unknown calling convention

int element_callback(BoxType *box,void *cl)

{
  BoxType **ppBVar1;
  BoxType **ppBVar2;
  float fVar3;
  int iVar4;
  float newarea;
  
  if (((((*(uint *)((int)cl + 0xb0) & box[1].Y1) != 0) ||
       (((((uint)box[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide &&
         (*(char *)((int)cl + 0xc) == '\0')) || (PosX < (float)box[0x11].X1)))) ||
      ((((float)box[0x11].X2 < PosX || (PosY < (float)box[0x11].Y1)) || ((float)box[0x11].Y2 < PosY)
       ))) || (fVar3 = (float)(box[0x11].Y2 - box[0x11].Y1) * (float)(box[0x11].X2 - box[0x11].X1),
              *(float *)((int)cl + 0x10) <= fVar3)) {
    iVar4 = 0;
  }
  else {
                    // WARNING: Load size is inaccurate
    ppBVar1 = *cl;
    *(float *)((int)cl + 0x10) = fVar3;
    ppBVar2 = *(BoxType ***)((int)cl + 4);
    **(BoxType ***)((int)cl + 8) = box;
    *ppBVar2 = box;
    *ppBVar1 = box;
    iVar4 = 1;
  }
  return iVar4;
}



// WARNING: Unknown calling convention

Boolean IsPointOnLineEnd(LocationType X,LocationType Y,RatTypePtr Line)

{
  int iVar1;
  
  if ((Line->Point1).X == X) {
    if ((Line->Point1).Y == Y) {
      return '\x01';
    }
    iVar1 = (Line->Point2).X;
  }
  else {
    iVar1 = (Line->Point2).X;
  }
  if (iVar1 != X) {
    return '\0';
  }
  return Y == (Line->Point2).Y;
}



// WARNING: Unknown calling convention

Boolean IsPointOnLine(float X,float Y,float Radius,LineTypePtr Line)

{
  int iVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  int iVar11;
  float dy1;
  float dx1;
  float l;
  float dy;
  float dx;
  
  fVar10 = ((float)Line->Thickness + 1.0) * 0.5 + Radius;
  iVar1 = (Line->Point2).Y;
  iVar2 = (Line->Point1).Y;
  iVar11 = iVar1;
  if (iVar2 <= iVar1) {
    iVar11 = iVar2;
  }
  if ((float)iVar11 <= Y + fVar10) {
    iVar11 = iVar1;
    if (iVar1 <= iVar2) {
      iVar11 = iVar2;
    }
    if (Y - fVar10 <= (float)iVar11) {
      iVar11 = (Line->Point2).X;
      iVar3 = (Line->Point1).X;
      fVar5 = (float)(iVar11 - iVar3);
      fVar8 = (float)(iVar1 - iVar2);
      fVar9 = (float)iVar3 - X;
      fVar4 = (float)iVar2 - Y;
      fVar10 = fVar10 * fVar10;
      fVar7 = fVar8 * fVar8 + fVar5 * fVar5;
      if (fVar7 != 0.0) {
        fVar6 = fVar5 * fVar4 - fVar8 * fVar9;
        if (fVar10 * fVar7 < fVar6 * fVar6) {
          return '\0';
        }
        fVar5 = -(fVar8 * fVar4 + fVar5 * fVar9);
        if ((0.0 <= fVar5) && (fVar5 <= fVar7)) {
          return '\x01';
        }
        if (0.0 <= fVar5) {
          fVar4 = (float)iVar11 - X;
          return ((float)iVar1 - Y) * ((float)iVar1 - Y) + fVar4 * fVar4 <= fVar10;
        }
      }
      return fVar4 * fVar4 + fVar9 * fVar9 <= fVar10;
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

int IsPointInQuadrangle(PointType *p,PointTypePtr l)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  bool bVar6;
  float prod0;
  longdouble lVar7;
  longdouble lVar8;
  float prod1;
  longdouble lVar9;
  uint local_18;
  
  iVar1 = p[1].X;
  iVar2 = p[1].Y;
  iVar3 = l->X;
  iVar4 = l->Y;
  local_18 = 0xffffffff;
  lVar7 = (longdouble)(iVar1 - p->X);
  lVar8 = (longdouble)(iVar2 - p->Y);
  lVar9 = (longdouble)(iVar4 - p->Y) * lVar8 + (longdouble)(iVar3 - p->X) * lVar7;
  lVar7 = lVar8 * (longdouble)(iVar4 - iVar2) + lVar7 * (longdouble)(iVar3 - iVar1);
  if ((longdouble)0 <= lVar9) {
    local_18 = (uint)((longdouble)0 < lVar9);
  }
  uVar5 = 0xffffffff;
  if ((longdouble)0 <= lVar7) {
    uVar5 = (uint)((longdouble)0 < lVar7);
  }
  if (local_18 * uVar5 == 1) {
    return 0;
  }
  lVar7 = (longdouble)(iVar1 - p[2].X);
  uVar5 = 0xffffffff;
  lVar8 = (longdouble)(iVar2 - p[2].Y);
  lVar9 = (longdouble)(iVar4 - iVar2) * lVar8 + (longdouble)(iVar3 - iVar1) * lVar7;
  lVar7 = (longdouble)(iVar3 - p[2].X) * lVar7 + (longdouble)(iVar4 - p[2].Y) * lVar8;
  if ((longdouble)0 <= lVar9) {
    uVar5 = (uint)((longdouble)0 < lVar9);
  }
  if ((longdouble)0 <= lVar7) {
    bVar6 = uVar5 * ((longdouble)0 < lVar7) != 1;
  }
  else {
    bVar6 = uVar5 != 0xffffffff;
  }
  return (uint)bVar6;
}



// WARNING: Unknown calling convention

Boolean IsPointInBox(LocationType X,LocationType Y,BoxTypePtr box,BDimension Radius)

{
  BDimension height;
  int iVar1;
  int iVar2;
  int iVar3;
  BDimension range;
  int iVar4;
  BDimension width;
  longdouble lVar5;
  
  iVar2 = X - box->X1;
  iVar3 = Y - box->Y1;
  iVar1 = box->Y2 - box->Y1;
  if (iVar2 < 1) {
    if (iVar3 < 0) {
      if (Radius < 0) {
        return '\0';
      }
    }
    else {
      if (iVar3 <= iVar1) {
        range = -iVar2;
        goto LAB_080c99d3;
      }
      if (Radius < 0) {
        return '\0';
      }
      iVar3 = iVar3 - iVar1;
    }
    lVar5 = (longdouble)iVar3;
  }
  else {
    iVar4 = box->X2 - box->X1;
    if (iVar2 < iVar4) {
      if (iVar3 < 0) {
        range = -iVar3;
      }
      else {
        if (iVar3 <= iVar1) {
          return '\x01';
        }
        range = iVar3 - iVar1;
      }
LAB_080c99d3:
      return range < Radius;
    }
    if (iVar3 < 0) {
      if (Radius < 0) {
        return '\0';
      }
      iVar2 = iVar2 - iVar4;
      lVar5 = (longdouble)iVar3;
    }
    else {
      if (iVar3 <= iVar1) {
        range = iVar2 - iVar4;
        goto LAB_080c99d3;
      }
      if (Radius < 0) {
        return '\0';
      }
      iVar2 = iVar2 - iVar4;
      lVar5 = (longdouble)(iVar3 - iVar1);
    }
  }
  return (longdouble)iVar2 * (longdouble)iVar2 + lVar5 * lVar5 <
         (longdouble)Radius * (longdouble)Radius;
}



// WARNING: Unknown calling convention

Boolean IsPointOnPin(float X,float Y,float Radius,PinTypePtr pin)

{
  float fVar1;
  float fVar2;
  float fVar3;
  Boolean BVar4;
  int iVar5;
  BoxType b;
  
  if ((*(byte *)((int)&(pin->Flags).f + 1) & 1) == 0) {
    fVar1 = (float)pin->X - X;
    fVar3 = (float)pin->Y - Y;
    fVar2 = (float)(pin->Thickness / 2) + Radius;
    return fVar3 * fVar3 + fVar1 * fVar1 <= fVar2 * fVar2;
  }
  iVar5 = pin->Thickness / 2;
  b.X1 = pin->X - iVar5;
  b.X2 = iVar5 + pin->X;
  b.Y1 = pin->Y - iVar5;
  b.Y2 = iVar5 + pin->Y;
  BVar4 = IsPointInBox((int)ROUND(X),(int)ROUND(Y),&b,(int)ROUND(Radius));
  return BVar4 != '\0';
}



// WARNING: Unknown calling convention

ElementTypePtr SearchElementByName(DataTypePtr Base,char *Name)

{
  char *__s1;
  int iVar1;
  ElementTypePtr result;
  ElementTypePtr paVar2;
  Cardinal n;
  int iVar3;
  
  iVar3 = Base->ElementN - 1;
  if (iVar3 != -1) {
    paVar2 = Base->Element + (Base->ElementN - 1);
    do {
      __s1 = paVar2->Name[1].TextString;
      if ((__s1 != (char *)0x0) && (Name != (char *)0x0)) {
        iVar1 = strcmp(__s1,Name);
        if (iVar1 == 0) {
          return paVar2;
        }
      }
      iVar3 = iVar3 + -1;
      paVar2 = paVar2 + -1;
    } while (iVar3 != -1);
  }
  return (ElementTypePtr)0x0;
}



// WARNING: Unknown calling convention

int SearchObjectByID(DataTypePtr Base,void **Result1,void **Result2,void **Result3,int ID,int type)

{
  PinTypePtr paVar1;
  PadTypePtr paVar2;
  PointTypePtr pPVar3;
  ArcTypePtr paVar4;
  LineTypePtr pLVar5;
  RatTypePtr paVar6;
  TextTypePtr pTVar7;
  PolygonTypePtr ppVar8;
  ElementTypePtr paVar9;
  Cardinal n_1;
  Cardinal n;
  int iVar10;
  Cardinal n_4;
  Cardinal n_2;
  Cardinal n_8;
  Cardinal n_3;
  int iVar11;
  uint uVar12;
  TextTypePtr text;
  TextType *pTVar13;
  ElementTypePtr element;
  ElementTypePtr paVar14;
  LineTypePtr line;
  PolygonTypePtr ppVar15;
  ArcTypePtr arc;
  RatTypePtr paVar16;
  ArcTypePtr paVar17;
  TextTypePtr pTVar18;
  PadTypePtr paVar19;
  PinTypePtr paVar20;
  LayerTypePtr layer;
  LayerTypePtr layer_1;
  PointTypePtr point;
  PointTypePtr pPVar21;
  LineTypePtr line_2;
  LayerType *pLVar22;
  LineTypePtr pLVar23;
  uint local_38;
  LayerType *local_34;
  ElementTypePtr local_28;
  PolygonTypePtr local_24;
  uint local_20;
  
  if ((type == 0x1000) || (type == 4)) {
    pLVar22 = Base->Layer;
    iVar11 = PCB->Data->LayerN;
    if (iVar11 != -2) {
      local_20 = 0;
      do {
        iVar10 = pLVar22->LineN - 1;
        if (iVar10 != -1) {
          paVar16 = (RatTypePtr)(pLVar22->Line + iVar10);
          if (paVar16->ID == ID) {
LAB_080c9f90:
            *Result1 = pLVar22;
            *Result3 = paVar16;
            *Result2 = paVar16;
            return 4;
          }
          if ((paVar16->Point1).ID == ID) {
LAB_080c9fb0:
            *Result1 = pLVar22;
            goto LAB_080c9fb5;
          }
          if ((paVar16->Point2).ID == ID) {
LAB_080c9fd0:
            *Result1 = pLVar22;
            goto LAB_080c9fd5;
          }
          paVar6 = (RatTypePtr)(pLVar22->Line + (pLVar22->LineN - 2));
          while (paVar16 = paVar6, iVar10 = iVar10 + -1, iVar10 != -1) {
            if (paVar16->ID == ID) goto LAB_080c9f90;
            if ((paVar16->Point1).ID == ID) goto LAB_080c9fb0;
            paVar6 = (RatTypePtr)&paVar16[-1].BoundingBox.Y1;
            if ((paVar16->Point2).ID == ID) goto LAB_080c9fd0;
          }
        }
        local_20 = local_20 + 1;
        if (iVar11 + 2U <= local_20) break;
        pLVar22 = pLVar22 + 1;
      } while( true );
    }
  }
  if (type == 0x4000) {
    pLVar22 = Base->Layer;
    iVar11 = PCB->Data->LayerN;
    if (iVar11 != -2) {
      local_20 = 0;
      do {
        iVar10 = pLVar22->ArcN - 1;
        if (iVar10 != -1) {
          paVar17 = pLVar22->Arc + iVar10;
          if (paVar17->ID == ID) {
LAB_080c9ff0:
            *Result1 = pLVar22;
            *Result3 = paVar17;
            *Result2 = paVar17;
            return 0x4000;
          }
          paVar4 = pLVar22->Arc + (pLVar22->ArcN - 2);
          while (paVar17 = paVar4, iVar10 = iVar10 + -1, iVar10 != -1) {
            paVar4 = paVar17 + -1;
            if (paVar17->ID == ID) goto LAB_080c9ff0;
          }
        }
        local_20 = local_20 + 1;
        if (iVar11 + 2U <= local_20) goto LAB_080c9e52;
        pLVar22 = pLVar22 + 1;
      } while( true );
    }
  }
  else if (type == 0x10) {
    pLVar22 = Base->Layer;
    iVar11 = PCB->Data->LayerN;
    if (iVar11 != -2) {
      local_20 = 0;
      do {
        iVar10 = pLVar22->TextN - 1;
        if (iVar10 != -1) {
          pTVar18 = pLVar22->Text + iVar10;
          if (pTVar18->ID == ID) {
LAB_080ca090:
            *Result1 = pLVar22;
            *Result3 = pTVar18;
            *Result2 = pTVar18;
            return 0x10;
          }
          pTVar7 = pLVar22->Text + (pLVar22->TextN - 2);
          while (pTVar18 = pTVar7, iVar10 = iVar10 + -1, iVar10 != -1) {
            pTVar7 = pTVar18 + -1;
            if (pTVar18->ID == ID) goto LAB_080ca090;
          }
        }
        local_20 = local_20 + 1;
        if (iVar11 + 2U <= local_20) goto LAB_080c9e52;
        pLVar22 = pLVar22 + 1;
      } while( true );
    }
  }
  if ((type == 0x800) || (type == 8)) {
    local_34 = Base->Layer;
    iVar11 = PCB->Data->LayerN;
    if (iVar11 != -2) {
      local_38 = 0;
      do {
        local_20 = local_34->PolygonN - 1;
        if (local_20 != -1) {
          local_24 = local_34->Polygon + local_20;
          if (local_24->ID == ID) {
LAB_080ca2c5:
            *Result1 = local_34;
            *Result3 = local_24;
            *Result2 = local_24;
            return 8;
          }
          ppVar8 = local_34->Polygon + (local_34->PolygonN - 2);
          do {
            ppVar15 = ppVar8;
            if (type == 0x800) {
              iVar10 = local_24->PointN - 1;
              if (iVar10 != -1) {
                pPVar21 = local_24->Points + iVar10;
                if (pPVar21->ID == ID) {
LAB_080c9cdc:
                  *Result1 = local_34;
                  *Result2 = local_24;
                  *Result3 = pPVar21;
                  return 0x800;
                }
                pPVar3 = local_24->Points + (local_24->PointN - 2);
                while (pPVar21 = pPVar3, iVar10 = iVar10 + -1, iVar10 != -1) {
                  pPVar3 = pPVar21 + -1;
                  if (pPVar21->ID == ID) goto LAB_080c9cdc;
                }
              }
            }
            local_20 = local_20 + -1;
            if (local_20 == -1) break;
            ppVar8 = ppVar15 + -1;
            local_24 = ppVar15;
            if (ppVar15->ID == ID) goto LAB_080ca2c5;
          } while( true );
        }
        local_38 = local_38 + 1;
        if (iVar11 + 2U <= local_38) break;
        local_34 = local_34 + 1;
      } while( true );
    }
  }
  if (type == 1) {
    if (Base->ViaN != 0) {
      paVar20 = Base->Via;
      uVar12 = 1;
      paVar1 = paVar20;
      if (paVar20->ID == ID) {
LAB_080ca23f:
        *Result3 = paVar20;
        *Result2 = paVar20;
        *Result1 = paVar20;
        return 1;
      }
      for (; paVar20 = paVar1 + 1, uVar12 < Base->ViaN; uVar12 = uVar12 + 1) {
        if (paVar1[1].ID == ID) goto LAB_080ca23f;
        paVar1 = paVar20;
      }
    }
LAB_080c9e52:
    if (type != 0x1000) goto LAB_080c9ec2;
  }
  else if (type != 0x20) goto LAB_080c9e52;
  iVar11 = Base->RatN - 1;
  if (iVar11 != -1) {
    paVar16 = Base->Rat + iVar11;
    if (paVar16->ID == ID) {
LAB_080ca316:
      *Result3 = paVar16;
      *Result2 = paVar16;
      *Result1 = paVar16;
      return 0x20;
    }
    if ((paVar16->Point1).ID == ID) {
LAB_080ca32f:
      *Result1 = (void *)0x0;
LAB_080c9fb5:
      *Result2 = paVar16;
      *Result3 = &paVar16->Point1;
      return 0x1000;
    }
    if ((paVar16->Point2).ID != ID) {
      paVar6 = Base->Rat + (Base->RatN - 2);
      do {
        paVar16 = paVar6;
        iVar11 = iVar11 + -1;
        if (iVar11 == -1) goto LAB_080c9ec2;
        if (paVar16->ID == ID) goto LAB_080ca316;
        if ((paVar16->Point1).ID == ID) goto LAB_080ca32f;
        paVar6 = paVar16 + -1;
      } while ((paVar16->Point2).ID != ID);
    }
    *Result1 = (void *)0x0;
LAB_080c9fd5:
    *Result2 = paVar16;
    *Result3 = &paVar16->Point2;
    return 0x1000;
  }
LAB_080c9ec2:
  if (((((type == 0x200) || (type == 2)) || (type == 0x2000)) ||
      ((type == 0x100 || (type == 0x8000)))) || (type == 0x400)) {
    local_20 = Base->ElementN - 1;
    if (local_20 != -1) {
      local_28 = Base->Element + local_20;
      if (local_28->ID != ID) {
        paVar14 = local_28;
        paVar9 = Base->Element + (Base->ElementN - 2);
        do {
          local_28 = paVar9;
          if (type == 0x2000) {
            iVar11 = paVar14->LineN - 1;
            if (iVar11 != -1) {
              pLVar23 = paVar14->Line + iVar11;
              if (pLVar23->ID == ID) {
LAB_080ca2e4:
                *Result1 = paVar14;
                *Result3 = pLVar23;
                *Result2 = pLVar23;
                return 0x2000;
              }
              pLVar5 = paVar14->Line + (paVar14->LineN - 2);
              while (pLVar23 = pLVar5, iVar11 = iVar11 + -1, iVar11 != -1) {
                pLVar5 = pLVar23 + -1;
                if (pLVar23->ID == ID) goto LAB_080ca2e4;
              }
            }
LAB_080ca1a8:
            if ((type == 0x200) && (paVar14->PadN != 0)) {
              paVar19 = paVar14->Pad;
              if (paVar19->ID == ID) {
LAB_080ca1f0:
                *Result1 = paVar14;
                *Result3 = paVar19;
                *Result2 = paVar19;
                return 0x200;
              }
              paVar2 = paVar19;
              for (uVar12 = 1; paVar19 = paVar2 + 1, uVar12 < paVar14->PadN; uVar12 = uVar12 + 1) {
                if (paVar2[1].ID == ID) goto LAB_080ca1f0;
                paVar2 = paVar19;
              }
            }
          }
          else {
            if (type == 0x8000) {
              iVar11 = paVar14->ArcN - 1;
              if (iVar11 != -1) {
                paVar17 = paVar14->Arc + iVar11;
                if (paVar17->ID == ID) {
LAB_080ca2fd:
                  *Result1 = paVar14;
                  *Result3 = paVar17;
                  *Result2 = paVar17;
                  return 0x8000;
                }
                paVar4 = paVar14->Arc + (paVar14->ArcN - 2);
                while (paVar17 = paVar4, iVar11 = iVar11 + -1, iVar11 != -1) {
                  paVar4 = paVar17 + -1;
                  if (paVar17->ID == ID) goto LAB_080ca2fd;
                }
              }
              goto LAB_080ca1a8;
            }
            if (type == 0x400) {
              pTVar13 = paVar14->Name + 2;
              if (((paVar14->Name[2].ID == ID) ||
                  (pTVar13 = paVar14->Name + 1, paVar14->Name[1].ID == ID)) ||
                 (pTVar13 = paVar14->Name, paVar14->Name[0].ID == ID)) {
                *Result1 = paVar14;
                *Result3 = pTVar13;
                *Result2 = pTVar13;
                return 0x400;
              }
            }
            else {
              if (type != 0x100) goto LAB_080ca1a8;
              if (paVar14->PinN != 0) {
                paVar20 = paVar14->Pin;
                if (paVar20->ID == ID) {
LAB_080ca34e:
                  *Result1 = paVar14;
                  *Result3 = paVar20;
                  *Result2 = paVar20;
                  return 0x100;
                }
                paVar1 = paVar20;
                for (uVar12 = 1; paVar20 = paVar1 + 1, uVar12 < paVar14->PinN; uVar12 = uVar12 + 1)
                {
                  if (paVar1[1].ID == ID) goto LAB_080ca34e;
                  paVar1 = paVar20;
                }
              }
            }
          }
          local_20 = local_20 + -1;
          if (local_20 == -1) goto LAB_080ca0e7;
          paVar14 = local_28;
          paVar9 = local_28 + -1;
        } while (local_28->ID != ID);
      }
      *Result3 = local_28;
      *Result2 = local_28;
      *Result1 = local_28;
      return 2;
    }
  }
LAB_080ca0e7:
  Message("hace: Internal error, search for ID %d failed\n",ID);
  return 0;
}



// WARNING: Unknown calling convention

Boolean SearchRatLineByLocation(int locked,RatTypePtr *Line,RatTypePtr *Dummy1,RatTypePtr *Dummy2)

{
  int iVar1;
  ans_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  info.ptr3 = Dummy2;
  info.ptr1 = Line;
  info.ptr2 = Dummy1;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    return '\x01';
  }
  r_search(PCB->Data->rat_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,rat_callback,&info);
  return '\0';
}



// WARNING: Unknown calling convention

Boolean SearchViaByLocation(int locked,PinTypePtr *Via,PinTypePtr *Dummy1,PinTypePtr *Dummy2)

{
  int iVar1;
  Boolean BVar2;
  ans_info info;
  
  BVar2 = '\0';
  if (PCB->ViaOn != '\0') {
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    info.ptr3 = Dummy2;
    info.ptr1 = Via;
    info.ptr2 = Dummy1;
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    BVar2 = '\x01';
    if (iVar1 == 0) {
      r_search(PCB->Data->via_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               pinorvia_callback,&info);
      return '\0';
    }
  }
  return BVar2;
}



// WARNING: Unknown calling convention

Boolean SearchPinByLocation(int locked,ElementTypePtr *Element,PinTypePtr *Pin,PinTypePtr *Dummy)

{
  int iVar1;
  Boolean BVar2;
  ans_info info;
  
  BVar2 = '\0';
  if (PCB->PinOn != '\0') {
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    info.ptr3 = Dummy;
    info.ptr1 = Element;
    info.ptr2 = Pin;
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    BVar2 = '\x01';
    if (iVar1 == 0) {
      r_search(PCB->Data->pin_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
               pinorvia_callback,&info);
      return '\0';
    }
  }
  return BVar2;
}



// WARNING: Unknown calling convention

Boolean SearchLineByLocation(int locked,LayerTypePtr *Layer,LineTypePtr *Line,LineTypePtr *Dummy)

{
  int iVar1;
  line_info_conflict info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  *Layer = SearchLayer;
  info.Point = (PointTypePtr *)Dummy;
  info.Line = Line;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    return '\x01';
  }
  r_search(SearchLayer->line_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,line_callback,
           &info);
  return '\0';
}



// WARNING: Unknown calling convention

Boolean SearchArcByLocation(int locked,LayerTypePtr *Layer,ArcTypePtr *Arc,ArcTypePtr *Dummy)

{
  int iVar1;
  arc_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  *Layer = SearchLayer;
  info.Dummy = Dummy;
  info.Arc = Arc;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    return '\x01';
  }
  r_search(SearchLayer->arc_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,arc_callback,&info
          );
  return '\0';
}



// WARNING: Unknown calling convention

Boolean SearchTextByLocation(int locked,LayerTypePtr *Layer,TextTypePtr *Text,TextTypePtr *Dummy)

{
  int iVar1;
  ans_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  *Layer = SearchLayer;
  info.ptr3 = Dummy;
  info.ptr2 = Text;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(SearchLayer->text_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,text_callback,
             &info);
  }
  return iVar1 != 0;
}



// WARNING: Unknown calling convention

Boolean SearchPolygonByLocation
                  (int locked,LayerTypePtr *Layer,PolygonTypePtr *Polygon,PolygonTypePtr *Dummy)

{
  int iVar1;
  ans_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  *Layer = SearchLayer;
  info.ptr3 = Dummy;
  info.ptr2 = Polygon;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(SearchLayer->polygon_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
             polygon_callback,&info);
  }
  return iVar1 != 0;
}



// WARNING: Unknown calling convention

Boolean SearchPadByLocation(int locked,ElementTypePtr *Element,PadTypePtr *Pad,PadTypePtr *Dummy,
                           Boolean BackToo)

{
  int iVar1;
  Boolean BVar2;
  bool local_dd;
  ans_info info;
  
  BVar2 = '\0';
  if (PCB->PinOn != '\0') {
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    local_dd = false;
    if (BackToo != '\0') {
      local_dd = PCB->InvisibleObjectsOn != '\0';
    }
    info.BackToo = local_dd;
    info.ptr3 = Dummy;
    info.ptr1 = Element;
    info.ptr2 = Pad;
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    BVar2 = '\x01';
    if (iVar1 == 0) {
      BVar2 = '\0';
      r_search(PCB->Data->pad_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,pad_callback,
               &info);
    }
  }
  return BVar2;
}



// WARNING: Unknown calling convention

Boolean SearchElementNameByLocation
                  (int locked,ElementTypePtr *Element,TextTypePtr *Text,TextTypePtr *Dummy,
                  Boolean BackToo)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  bool bVar4;
  bool local_dd;
  ans_info info;
  
  bVar4 = false;
  if (PCB->ElementOn != '\0') {
    local_dd = false;
    if (BackToo != '\0') {
      local_dd = PCB->InvisibleObjectsOn != '\0';
    }
    uVar1 = (PCB->Flags).f;
    uVar3 = 1;
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    if ((uVar1 & 0x40) == 0) {
      uVar3 = -(uint)((uVar1 & 0x20) == 0) & 2;
    }
    info.ptr3 = Dummy;
    info.area = 1e+14;
    info.BackToo = local_dd;
    info.ptr1 = Element;
    info.ptr2 = Text;
    iVar2 = r_search(PCB->Data->name_tree[uVar3],&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                     name_callback,&info);
    bVar4 = iVar2 != 0;
  }
  return bVar4;
}



// WARNING: Unknown calling convention

Boolean SearchElementByLocation
                  (int locked,ElementTypePtr *Element,ElementTypePtr *Dummy1,ElementTypePtr *Dummy2,
                  Boolean BackToo)

{
  int iVar1;
  bool bVar2;
  ans_info info;
  
  if ((PCB->ElementOn == '\0') || (PCB->PinOn == '\0')) {
    bVar2 = false;
  }
  else {
    info.BackToo = false;
    if (BackToo != '\0') {
      info.BackToo = PCB->InvisibleObjectsOn != '\0';
    }
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    info.ptr3 = Dummy2;
    info.area = 1e+14;
    info.ptr1 = Element;
    info.ptr2 = Dummy1;
    iVar1 = r_search(PCB->Data->element_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0,
                     element_callback,&info);
    bVar2 = iVar1 != 0;
  }
  return bVar2;
}



// WARNING: Unknown calling convention

int SearchObjectByLocation
              (int Type,void **Result1,void **Result2,void **Result3,LocationType X,LocationType Y,
              BDimension Radius)

{
  uint uVar1;
  Cardinal CVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  bool bVar6;
  float fVar7;
  BDimension BVar8;
  Boolean BVar9;
  PointTypePtr point;
  int *piVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  PCBTypePtr pPVar14;
  DataTypePtr paVar15;
  Cardinal n;
  int iVar16;
  uint locked;
  PolygonTypePtr polygon;
  uchar *puVar17;
  Boolean found;
  float least;
  float local_110;
  uint local_104;
  int local_f0;
  int local_ec;
  LayerTypePtr local_e8;
  int local_e4;
  line_info_conflict info;
  ElementTypePtr local_28;
  ElementTypePtr local_24;
  ElementTypePtr local_20 [4];
  
  PosX = (float)X;
  locked = Type & 0x10000;
  PosY = (float)Y;
  SearchRadius = Radius;
  if (Radius == 0) {
    SearchBox.X1 = X;
    SearchBox.X2 = X + 1;
    SearchBox.Y1 = Y;
    SearchBox.Y2 = Y + 1;
  }
  else {
    SearchBox.X1 = X - Radius;
    SearchBox.Y1 = Y - Radius;
    SearchBox.X2 = Radius + X;
    SearchBox.Y2 = Radius + Y;
  }
  uVar1 = (PCB->Flags).f;
  uVar12 = Type & 0xfffffbef;
  if ((uVar1 & 0x240000) == 0) {
    uVar12 = Type;
  }
  uVar11 = uVar12 & 0x410;
  if ((uVar1 & 0x80000) == 0) {
    uVar11 = uVar12;
  }
  uVar12 = uVar11 & 0xfffffff7;
  if ((uVar1 & 0x24000) == 0) {
    uVar12 = uVar11;
  }
  if ((((uVar12 & 0x20) != 0) && (PCB->RatOn != '\0')) &&
     (BVar9 = SearchRatLineByLocation
                        (locked,(RatTypePtr *)Result1,(RatTypePtr *)Result2,(RatTypePtr *)Result3),
     BVar9 != '\0')) {
    return 0x20;
  }
  if (((uVar12 & 1) != 0) &&
     (BVar9 = SearchViaByLocation(locked,(PinTypePtr *)Result1,(PinTypePtr *)Result2,
                                  (PinTypePtr *)Result3), BVar9 != '\0')) {
    return 1;
  }
  if ((uVar12 & 0x100) == 0) {
LAB_080cab56:
    if (((uVar12 & 0x200) == 0) ||
       (BVar9 = SearchPadByLocation(locked,local_20,(PadTypePtr *)&local_24,(PadTypePtr *)&local_28,
                                    '\0'), BVar9 == '\0')) {
      if (((uVar12 & 0x400) == 0) ||
         (BVar9 = SearchElementNameByLocation
                            (locked,local_20,(TextTypePtr *)&local_24,(TextTypePtr *)&local_28,'\0')
         , BVar9 == '\0')) {
        if (((uVar12 & 2) == 0) ||
           (BVar9 = SearchElementByLocation(locked,local_20,&local_24,&local_28,'\0'), BVar9 == '\0'
           )) {
          local_104 = 0;
          local_110 = 0.0;
        }
        else {
          local_104 = 2;
          local_110 = (float)((local_20[0]->BoundingBox).Y2 - (local_20[0]->BoundingBox).Y1) *
                      (float)((local_20[0]->BoundingBox).X2 - (local_20[0]->BoundingBox).X1);
        }
      }
      else {
        local_104 = 0x400;
        local_110 = (float)((local_24->BoundingBox).Y2 - (local_24->BoundingBox).Y1) *
                    (float)((local_24->BoundingBox).X2 - (local_24->BoundingBox).X1);
      }
      goto LAB_080cab92;
    }
    local_104 = 0x200;
  }
  else {
    BVar9 = SearchPinByLocation(locked,local_20,(PinTypePtr *)&local_24,(PinTypePtr *)&local_28);
    local_104 = 0x100;
    if (BVar9 == '\0') goto LAB_080cab56;
  }
  local_110 = 0.0;
LAB_080cab92:
  paVar15 = PCB->Data;
  iVar16 = paVar15->LayerN;
  if (-2 < iVar16) {
    local_e4 = -1;
    pPVar14 = PCB;
    do {
      BVar8 = SearchRadius;
      if (local_e4 == -1) {
        local_e8 = paVar15->Layer + iVar16 + (uint)(Settings.ShowSolderSide == '\0');
LAB_080cac3f:
        SearchLayer = local_e8;
        if (local_e8->On != '\0') {
          if ((local_104 & 0x300) == 0) {
            if ((uVar12 & 0x800) != 0) {
              CVar2 = local_e8->PolygonN;
              local_ec = CVar2 - 1;
              *Result1 = local_e8;
              fVar7 = PosY;
              fVar3 = PosX;
              if (local_ec != -1) {
                bVar6 = false;
                fVar5 = (float)BVar8 * (float)BVar8;
                iVar16 = CVar2 * 0x3c;
                do {
                  local_f0 = iVar16 + -0x3c;
                  puVar17 = local_e8->Polygon[-1].Flags.t + iVar16 + -0x18;
                  iVar16 = *(int *)(puVar17 + 0x24) + -1;
                  if (iVar16 != -1) {
                    iVar13 = *(int *)(puVar17 + 0x24) * 0x14;
                    do {
                      iVar13 = iVar13 + -0x14;
                      piVar10 = (int *)(*(int *)(puVar17 + 0x38) + iVar13);
                      fVar4 = ((float)piVar10[1] - fVar7) * ((float)piVar10[1] - fVar7) +
                              ((float)*piVar10 - fVar3) * ((float)*piVar10 - fVar3);
                      if (fVar4 < fVar5) {
                        *Result3 = piVar10;
                        *Result2 = puVar17;
                        bVar6 = true;
                        fVar5 = fVar4;
                      }
                      iVar16 = iVar16 + -1;
                    } while (iVar16 != -1);
                  }
                  local_ec = local_ec + -1;
                  iVar16 = local_f0;
                } while (local_ec != -1);
                if (bVar6) {
                  return 0x800;
                }
              }
            }
            BVar8 = SearchRadius;
            if ((uVar12 & 0x1000) != 0) {
              *Result1 = local_e8;
              *Result3 = (void *)0x0;
              info.Line = (LineTypePtr *)Result2;
              info.locked = -(uint)(locked == 0) & 0x2000;
              info.Point = (PointTypePtr *)Result3;
              info.least = (float)(BVar8 * BVar8);
              iVar16 = r_search(local_e8->line_tree,&SearchBox,(_func_int_BoxType_ptr_void_ptr *)0x0
                                ,linepoint_callback,&info);
              if (iVar16 != 0) {
                return 0x1000;
              }
            }
            if (((uVar12 & 4) != 0) &&
               (BVar9 = SearchLineByLocation
                                  (locked,(LayerTypePtr *)Result1,(LineTypePtr *)Result2,
                                   (LineTypePtr *)Result3), BVar9 != '\0')) {
              return 4;
            }
            if (((uVar12 & 0x4000) != 0) &&
               (BVar9 = SearchArcByLocation(locked,(LayerTypePtr *)Result1,(ArcTypePtr *)Result2,
                                            (ArcTypePtr *)Result3), BVar9 != '\0')) {
              return 0x4000;
            }
            if (((uVar12 & 0x10) != 0) &&
               (BVar9 = SearchTextByLocation
                                  (locked,(LayerTypePtr *)Result1,(TextTypePtr *)Result2,
                                   (TextTypePtr *)Result3), BVar9 != '\0')) {
              return 0x10;
            }
          }
          pPVar14 = PCB;
          if (((uVar12 & 8) != 0) &&
             (BVar9 = SearchPolygonByLocation
                                (locked,(LayerTypePtr *)Result1,(PolygonTypePtr *)Result2,
                                 (PolygonTypePtr *)Result3), pPVar14 = PCB, BVar9 != '\0')) {
                    // WARNING: Load size is inaccurate
            if ((local_104 == 0) ||
               (fVar3 = (float)(*(int *)((int)*Result2 + 8) - **Result2), fVar3 * fVar3 <= local_110
               )) {
              return 8;
            }
            break;
          }
        }
      }
      else {
        if (local_e4 < iVar16) {
          local_e8 = paVar15->Layer + LayerStack[local_e4];
          goto LAB_080cac3f;
        }
        SearchLayer = paVar15->Layer + iVar16 + (uint)(Settings.ShowSolderSide != '\0');
        local_e8 = SearchLayer;
        if (pPVar14->InvisibleObjectsOn != '\0') goto LAB_080cac3f;
      }
      paVar15 = pPVar14->Data;
      local_e4 = local_e4 + 1;
      iVar16 = paVar15->LayerN;
    } while (local_e4 <= iVar16);
  }
  if ((local_104 & 0x100) == 0) {
    if ((local_104 & 0x200) == 0) {
      if ((local_104 & 0x400) == 0) {
        if ((local_104 & 2) == 0) {
          if (PCB->InvisibleObjectsOn != '\0') {
            if (((uVar12 & 0x200) != 0) &&
               (BVar9 = SearchPadByLocation(locked,(ElementTypePtr *)Result1,(PadTypePtr *)Result2,
                                            (PadTypePtr *)Result3,'\x01'), BVar9 != '\0')) {
              return 0x200;
            }
            if (((uVar12 & 0x400) != 0) &&
               (BVar9 = SearchElementNameByLocation
                                  (locked,(ElementTypePtr *)Result1,(TextTypePtr *)Result2,
                                   (TextTypePtr *)Result3,'\x01'), BVar9 != '\0')) {
              return 0x400;
            }
            if (((uVar12 & 2) != 0) &&
               (BVar9 = SearchElementByLocation
                                  (locked,(ElementTypePtr *)Result1,(ElementTypePtr *)Result2,
                                   (ElementTypePtr *)Result3,'\x01'), BVar9 != '\0')) {
              return 2;
            }
          }
          iVar16 = 0;
        }
        else {
          *Result1 = local_20[0];
          *Result2 = local_24;
          *Result3 = local_28;
          iVar16 = 2;
        }
      }
      else {
        *Result1 = local_20[0];
        *Result2 = local_24;
        *Result3 = local_28;
        iVar16 = 0x400;
      }
    }
    else {
      *Result1 = local_20[0];
      *Result2 = local_24;
      *Result3 = local_28;
      iVar16 = 0x200;
    }
  }
  else {
    *Result1 = local_20[0];
    *Result2 = local_24;
    *Result3 = local_28;
    iVar16 = 0x100;
  }
  return iVar16;
}



// WARNING: Unknown calling convention

int SearchScreen(LocationType X,LocationType Y,int Type,void **Result1,void **Result2,void **Result3
                )

{
  int ans;
  int iVar1;
  
  iVar1 = SearchObjectByLocation(Type,Result1,Result2,Result3,X,Y,pixel_slop * 5);
  return iVar1;
}



// WARNING: Unknown calling convention

int rat_callback(BoxType *box,void *cl)

{
  BoxType **ppBVar1;
  BoxType **ppBVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  Boolean BVar6;
  bool bVar7;
  
  if ((*(uint *)((int)cl + 0xb0) & box[1].Y1) == 0) {
    if ((box[1].Y1 & 2U) == 0) {
      BVar6 = IsPointOnLine(PosX,PosY,(float)SearchRadius,(LineTypePtr)box);
      bVar7 = BVar6 != '\0';
    }
    else {
      fVar3 = (float)box[2].Y2 - PosX;
      fVar5 = (float)box[3].X1 - PosY;
      fVar4 = (float)(box[2].Y1 * 2 + SearchRadius);
      bVar7 = fVar5 * fVar5 + fVar3 * fVar3 <= fVar4 * fVar4;
    }
    if (bVar7) {
                    // WARNING: Load size is inaccurate
      ppBVar1 = *cl;
      ppBVar2 = *(BoxType ***)((int)cl + 4);
      **(BoxType ***)((int)cl + 8) = box;
      *ppBVar2 = box;
      *ppBVar1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pinorvia_callback(BoxType *box,void *cl)

{
  BoxType **ppBVar1;
  Boolean BVar2;
  BoxType *pBVar3;
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xb0)) == 0) {
    BVar2 = IsPointOnPin(PosX,PosY,(float)SearchRadius,(PinTypePtr)box);
    if (BVar2 != '\0') {
                    // WARNING: Load size is inaccurate
      pBVar3 = (BoxType *)box[4].Y1;
      if ((BoxType *)box[4].Y1 == (BoxType *)0x0) {
        pBVar3 = box;
      }
      **cl = pBVar3;
      ppBVar1 = *(BoxType ***)((int)cl + 4);
      **(BoxType ***)((int)cl + 8) = box;
      *ppBVar1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int text_callback(BoxType *box,void *cl)

{
  BoxType **ppBVar1;
  
  if (((((box[1].Y1 & *(uint *)((int)cl + 0xb0)) == 0) && ((float)box->X1 <= PosX)) &&
      (PosX <= (float)box->X2)) && (((float)box->Y1 <= PosY && (PosY <= (float)box->Y2)))) {
    ppBVar1 = *(BoxType ***)((int)cl + 4);
    **(BoxType ***)((int)cl + 8) = box;
    *ppBVar1 = box;
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int polygon_callback(BoxType *box,void *cl)

{
  BoxType **ppBVar1;
  Boolean BVar2;
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xb0)) == 0) {
    BVar2 = IsPointInPolygon((int)ROUND(PosX),(int)ROUND(PosY),SearchRadius,(PolygonTypePtr)box);
    if (BVar2 != '\0') {
      ppBVar1 = *(BoxType ***)((int)cl + 4);
      **(BoxType ***)((int)cl + 8) = box;
      *ppBVar1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x080cb682)
// WARNING: Removing unreachable block (ram,0x080cb686)
// WARNING: Removing unreachable block (ram,0x080cb688)
// WARNING: Unknown calling convention

Boolean IsPointOnArc(float X,float Y,float Radius,ArcTypePtr Arc)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  int ang2;
  int iVar6;
  int delta;
  int iVar7;
  int startAngle;
  int iVar8;
  int ang1;
  int iVar9;
  int arcDelta;
  int iVar10;
  float l;
  float dx;
  float pdx;
  float y;
  float dy;
  float x;
  double dVar11;
  
  fVar4 = X - (float)Arc->X;
  fVar5 = Y - (float)Arc->Y;
  fVar2 = fVar5 * fVar5 + fVar4 * fVar4;
  if (fVar2 == 0.0) {
    return (float)Arc->Width <= (float)Arc->Thickness * 0.5 + Radius;
  }
  fVar3 = (float)Arc->Width * (float)Arc->Width;
  fVar1 = (float)Arc->Thickness * 0.5 + Radius;
  fVar1 = (((fVar3 - fVar1 * fVar1) + fVar2) * 0.5) / fVar2;
  fVar2 = (fVar2 / fVar3 - fVar1 * fVar1) + 1e-05;
  if (fVar2 < 0.0) {
    return '\0';
  }
  fVar2 = SQRT(fVar2);
  iVar9 = Arc->Delta;
  fVar3 = -fVar2 * fVar4;
  fVar2 = fVar5 * fVar2;
  for (iVar8 = Arc->StartAngle; iVar8 < 0; iVar8 = iVar8 + 0x168) {
  }
  iVar10 = iVar9;
  if (iVar9 < 0) {
    iVar10 = -iVar9;
    for (iVar9 = iVar8 + iVar9; (iVar8 = iVar9, iVar9 < 0 && (iVar8 = iVar9 + 0x168, iVar8 < 0));
        iVar9 = iVar9 + 0x2d0) {
    }
  }
  dVar11 = atan2((double)(fVar1 * fVar5 + fVar3),(double)-(fVar1 * fVar4 + fVar2));
  iVar9 = (int)ROUND(dVar11 * 57.29577951308232);
  if (iVar9 < 0) {
    iVar9 = iVar9 + 0x168;
  }
  dVar11 = atan2((double)(fVar1 * fVar5 - fVar3),(double)-(fVar1 * fVar4 - fVar2));
  iVar6 = (int)ROUND(dVar11 * 57.29577951308232);
  if (iVar6 < 0) {
    iVar6 = iVar6 + 0x168;
  }
  iVar6 = iVar6 - iVar9;
  if (iVar6 < 0xb5) {
    if (iVar6 < -0xb4) {
      iVar6 = iVar6 + 0x168;
    }
  }
  else {
    iVar6 = iVar6 + -0x168;
  }
  iVar7 = iVar6;
  if (iVar6 < 0) {
    iVar7 = -iVar6;
    for (iVar6 = iVar9 + iVar6; (iVar9 = iVar6, iVar6 < 0 && (iVar9 = iVar6 + 0x168, iVar9 < 0));
        iVar6 = iVar6 + 0x2d0) {
    }
  }
  if (iVar8 <= iVar9) {
    if (iVar9 <= iVar10 + iVar8) {
      return '\x01';
    }
    if (iVar8 < iVar9) goto LAB_080cb7a3;
  }
  if (iVar8 <= iVar7 + iVar9) {
    return '\x01';
  }
LAB_080cb7a3:
  if ((0x167 < iVar10 + iVar8) && (iVar9 < iVar10 + iVar8 + -0x167)) {
    return '\x01';
  }
  if (iVar7 + iVar9 < 0x168) {
    return '\0';
  }
  return iVar8 < iVar7 + iVar9 + -0x167;
}



// WARNING: Unknown calling convention

int arc_callback(BoxType *box,void *cl)

{
  Boolean BVar1;
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xa4)) == 0) {
    BVar1 = IsPointOnArc(PosX,PosY,(float)SearchRadius,(ArcTypePtr)box);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      **cl = box;
      **(BoxType ***)((int)cl + 4) = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean IsPointInPad(LocationType X,LocationType Y,BDimension Radius,PadTypePtr Pad)

{
  uint uVar1;
  int iVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  bool bVar6;
  uint uVar7;
  int iVar8;
  BDimension range;
  int iVar9;
  PadTypePtr paVar10;
  int iVar11;
  PadType *pPVar12;
  int in_GS_OFFSET;
  double Cos;
  double r;
  double Sin;
  int local_90;
  PadType pad;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = Pad->Thickness;
  paVar10 = Pad;
  pPVar12 = &pad;
  for (iVar8 = 0x1a; iVar8 != 0; iVar8 = iVar8 + -1) {
    (pPVar12->BoundingBox).X1 = (paVar10->BoundingBox).X1;
    paVar10 = (PadTypePtr)&(paVar10->BoundingBox).Y1;
    pPVar12 = (PadType *)&(pPVar12->BoundingBox).Y1;
  }
  iVar8 = (iVar2 + 1) / 2;
  dVar4 = (double)(pad.Point2.X - pad.Point1.X);
  dVar3 = (double)(pad.Point2.Y - pad.Point1.Y);
  dVar5 = SQRT(dVar3 * dVar3 + dVar4 * dVar4);
  if (0.1 <= dVar5) {
    dVar3 = dVar3 / dVar5;
    dVar4 = dVar4 / dVar5;
  }
  else {
    dVar4 = 1.0;
    dVar3 = 0.0;
  }
  iVar9 = (int)ROUND((double)(Y - pad.Point1.Y) * dVar3 + (double)(X - pad.Point1.X) * dVar4);
  uVar1 = (uint)ROUND((double)(Y - pad.Point1.Y) * dVar4 - (double)(X - pad.Point1.X) * dVar3);
  uVar7 = (int)uVar1 >> 0x1f;
  if ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0) {
    local_90 = (uVar1 ^ uVar7) - uVar7;
    if (iVar9 < 1) {
      bVar6 = false;
      Radius = iVar8 + Radius;
      if (Radius < 0) goto LAB_080cba48;
LAB_080cbb2b:
      bVar6 = (longdouble)local_90 * (longdouble)local_90 + (longdouble)iVar9 * (longdouble)iVar9 <
              (longdouble)Radius * (longdouble)Radius;
      goto LAB_080cba48;
    }
    if (dVar5 <= (double)iVar9) {
      bVar6 = false;
      if (-1 < iVar8 + Radius) {
        dVar3 = (double)(iVar8 + Radius);
        dVar5 = (double)iVar9 - dVar5;
        bVar6 = (double)local_90 * (double)local_90 + dVar5 * dVar5 < dVar3 * dVar3;
      }
      goto LAB_080cba48;
    }
LAB_080cba2c:
    range = local_90 - iVar8;
  }
  else {
    iVar11 = iVar9 + iVar8;
    local_90 = (uVar1 ^ uVar7) - uVar7;
    if (iVar11 < 1) {
      if (iVar8 < local_90) {
        bVar6 = false;
        if (Radius < 0) goto LAB_080cba48;
        iVar9 = iVar8 - local_90;
        local_90 = iVar11;
        goto LAB_080cbb2b;
      }
      range = -iVar11;
    }
    else {
      dVar5 = (double)iVar2 + dVar5;
      dVar3 = (double)iVar11;
      if (dVar3 < dVar5) goto LAB_080cba2c;
      if (iVar8 < local_90) {
        bVar6 = false;
        if (-1 < Radius) {
          bVar6 = (dVar3 - dVar5) * (dVar3 - dVar5) +
                  (double)(iVar8 - local_90) * (double)(iVar8 - local_90) <
                  (double)Radius * (double)Radius;
        }
        goto LAB_080cba48;
      }
      range = (BDimension)ROUND(dVar3 - dVar5);
    }
  }
  bVar6 = range < Radius;
LAB_080cba48:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return bVar6;
}



// WARNING: Unknown calling convention

int line_callback(BoxType *box,void *cl)

{
  Boolean BVar1;
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xa8)) == 0) {
    BVar1 = IsPointInPad((int)ROUND(PosX),(int)ROUND(PosY),SearchRadius,(PadTypePtr)box);
    if (BVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      **cl = box;
      **(BoxType ***)((int)cl + 4) = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0xc,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int pad_callback(BoxType *b,void *cl)

{
  BoxType **ppBVar1;
  Boolean BVar2;
  
  if (((*(uint *)((int)cl + 0xb0) & b[1].Y1) == 0) &&
     ((((uint)b[1].Y1 >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (*(char *)((int)cl + 0xc) != '\0')))) {
    BVar2 = IsPointInPad((int)ROUND(PosX),(int)ROUND(PosY),SearchRadius,(PadTypePtr)b);
    if (BVar2 != '\0') {
                    // WARNING: Load size is inaccurate
      **cl = b[6].X1;
      ppBVar1 = *(BoxType ***)((int)cl + 4);
      **(BoxType ***)((int)cl + 8) = b;
      *ppBVar1 = b;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean IsArcInRectangle(LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
                        ArcTypePtr Arc)

{
  int iVar1;
  Boolean BVar2;
  int in_GS_OFFSET;
  bool bVar3;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  line.Thickness = 0;
  MakeFlags(0);
  line.Point2.Y = Y1;
  line.Point1.Y = Y1;
  line.Point2.X = X2;
  line.Point1.X = X1;
  BVar2 = LineArcIntersect(&line,Arc);
  if (BVar2 == '\0') {
    line.Point2.X = X2;
    line.Point1.X = X2;
    line.Point1.Y = Y1;
    line.Point2.Y = Y2;
    BVar2 = LineArcIntersect(&line,Arc);
    if (BVar2 == '\0') {
      line.Point2.X = X2;
      line.Point2.Y = Y2;
      line.Point1.Y = Y2;
      line.Point1.X = X1;
      BVar2 = LineArcIntersect(&line,Arc);
      if (BVar2 == '\0') {
        line.Point1.Y = Y1;
        line.Point2.X = X1;
        line.Point1.X = X1;
        line.Point2.Y = Y2;
        BVar2 = LineArcIntersect(&line,Arc);
        bVar3 = BVar2 != '\0';
        goto LAB_080cbd9c;
      }
    }
  }
  bVar3 = true;
LAB_080cbd9c:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return bVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean IsLineInQuadrangle(PointType *p,LineTypePtr Line)

{
  int iVar1;
  Boolean BVar2;
  int iVar3;
  int in_GS_OFFSET;
  bool bVar4;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = IsPointInQuadrangle(p,&Line->Point1);
  if (iVar3 == 0) {
    iVar3 = IsPointInQuadrangle(p,&Line->Point2);
    if (iVar3 == 0) {
      line.Thickness = 0;
      MakeFlags(0);
      line.Point1.X = p->X;
      line.Point1.Y = p->Y;
      line.Point2.X = p[1].X;
      line.Point2.Y = p[1].Y;
      BVar2 = LineLineIntersect(&line,Line);
      if (BVar2 == '\0') {
        line.Point1.X = p[2].X;
        line.Point1.Y = p[2].Y;
        BVar2 = LineLineIntersect(&line,Line);
        if (BVar2 == '\0') {
          line.Point2.X = p[3].X;
          line.Point2.Y = p[3].Y;
          BVar2 = LineLineIntersect(&line,Line);
          if (BVar2 == '\0') {
            line.Point1.X = p->X;
            line.Point1.Y = p->Y;
            BVar2 = LineLineIntersect(&line,Line);
            bVar4 = BVar2 != '\0';
            goto LAB_080cbe76;
          }
        }
      }
    }
  }
  bVar4 = true;
LAB_080cbe76:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return bVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean IsLineInRectangle(LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
                         LineTypePtr Line)

{
  int iVar1;
  int iVar2;
  Boolean BVar3;
  int in_GS_OFFSET;
  bool bVar4;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = (Line->Point1).X;
  if ((((iVar2 <= X1) || (X2 <= iVar2)) || (iVar2 = (Line->Point1).Y, iVar2 <= Y1)) || (Y2 <= iVar2)
     ) {
    line.Thickness = 0;
    MakeFlags(0);
    line.Point2.Y = Y1;
    line.Point1.Y = Y1;
    line.Point1.X = X1;
    line.Point2.X = X2;
    BVar3 = LineLineIntersect(&line,Line);
    if (BVar3 == '\0') {
      line.Point1.X = X2;
      line.Point1.Y = Y1;
      line.Point2.Y = Y2;
      BVar3 = LineLineIntersect(&line,Line);
      if (BVar3 == '\0') {
        line.Point2.X = X2;
        line.Point1.Y = Y2;
        line.Point1.X = X1;
        BVar3 = LineLineIntersect(&line,Line);
        if (BVar3 == '\0') {
          line.Point1.Y = Y1;
          line.Point2.X = X1;
          line.Point2.Y = Y2;
          BVar3 = LineLineIntersect(&line,Line);
          bVar4 = BVar3 != '\0';
          goto LAB_080cc00b;
        }
      }
    }
  }
  bVar4 = true;
LAB_080cc00b:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return bVar4;
}



// WARNING: Unknown calling convention

void * ObjectOperation(ObjectFunctionTypePtr F,int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  _func_void_ptr_LayerTypePtr_LineTypePtr_PointTypePtr *UNRECOVERED_JUMPTABLE_01;
  _func_void_ptr_ElementTypePtr *UNRECOVERED_JUMPTABLE;
  _func_void_ptr_ElementTypePtr_PadTypePtr *UNRECOVERED_JUMPTABLE_00;
  void *pvVar1;
  
  if (Type == 0x20) {
    UNRECOVERED_JUMPTABLE = (_func_void_ptr_ElementTypePtr *)F->Rat;
joined_r0x080cc205:
    if (UNRECOVERED_JUMPTABLE != (_func_void_ptr_ElementTypePtr *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080cc1d6. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar1 = (*UNRECOVERED_JUMPTABLE)((ElementTypePtr)Ptr1);
      return pvVar1;
    }
  }
  else {
    if (Type < 0x21) {
      if (Type == 4) {
        UNRECOVERED_JUMPTABLE_00 = (_func_void_ptr_ElementTypePtr_PadTypePtr *)F->Line;
      }
      else {
        if (Type < 5) {
          if (Type == 1) {
            UNRECOVERED_JUMPTABLE = (_func_void_ptr_ElementTypePtr *)F->Via;
          }
          else {
            if (Type != 2) {
              return (void *)0x0;
            }
            UNRECOVERED_JUMPTABLE = F->Element;
          }
          goto joined_r0x080cc205;
        }
        if (Type == 8) {
          UNRECOVERED_JUMPTABLE_00 = (_func_void_ptr_ElementTypePtr_PadTypePtr *)F->Polygon;
        }
        else {
          if (Type != 0x10) {
            return (void *)0x0;
          }
          UNRECOVERED_JUMPTABLE_00 = (_func_void_ptr_ElementTypePtr_PadTypePtr *)F->Text;
        }
      }
    }
    else {
      if (Type == 0x400) {
        UNRECOVERED_JUMPTABLE = F->ElementName;
        goto joined_r0x080cc205;
      }
      if (Type < 0x401) {
        if (Type == 0x100) {
          UNRECOVERED_JUMPTABLE_00 = (_func_void_ptr_ElementTypePtr_PadTypePtr *)F->Pin;
        }
        else {
          if (Type != 0x200) {
            return (void *)0x0;
          }
          UNRECOVERED_JUMPTABLE_00 = F->Pad;
        }
      }
      else {
        if (Type == 0x1000) {
          UNRECOVERED_JUMPTABLE_01 = F->LinePoint;
joined_r0x080cc230:
          if (UNRECOVERED_JUMPTABLE_01 ==
              (_func_void_ptr_LayerTypePtr_LineTypePtr_PointTypePtr *)0x0) {
            return (void *)0x0;
          }
                    // WARNING: Could not recover jumptable at 0x080cc145. Too many branches
                    // WARNING: Treating indirect jump as call
          pvVar1 = (*UNRECOVERED_JUMPTABLE_01)
                             ((LayerTypePtr)Ptr1,(LineTypePtr)Ptr2,(PointTypePtr)Ptr3);
          return pvVar1;
        }
        if (Type != 0x4000) {
          if (Type != 0x800) {
            return (void *)0x0;
          }
          UNRECOVERED_JUMPTABLE_01 =
               (_func_void_ptr_LayerTypePtr_LineTypePtr_PointTypePtr *)F->Point;
          goto joined_r0x080cc230;
        }
        UNRECOVERED_JUMPTABLE_00 = (_func_void_ptr_ElementTypePtr_PadTypePtr *)F->Arc;
      }
    }
    if (UNRECOVERED_JUMPTABLE_00 != (_func_void_ptr_ElementTypePtr_PadTypePtr *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080cc188. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar1 = (*UNRECOVERED_JUMPTABLE_00)((ElementTypePtr)Ptr1,(PadTypePtr)Ptr2);
      return pvVar1;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

Boolean SelectedOperation(ObjectFunctionTypePtr F,Boolean Reset,int type)

{
  RatTypePtr Ptr1;
  Boolean changed;
  char cVar1;
  TextType *pTVar2;
  uint uVar3;
  Cardinal sn_1;
  DataTypePtr paVar4;
  LineTypePtr line;
  LineTypePtr Ptr2;
  ArcTypePtr arc;
  ArcTypePtr Ptr2_00;
  TextTypePtr text;
  TextTypePtr Ptr2_01;
  PolygonTypePtr polygon;
  PolygonTypePtr Ptr2_02;
  ElementTypePtr element;
  uint uVar5;
  PinTypePtr pin;
  PadTypePtr pad;
  PadTypePtr Ptr2_03;
  PCBTypePtr pPVar6;
  RatTypePtr line_1;
  Cardinal n;
  int iVar7;
  Cardinal n_1;
  Cardinal n_2;
  Cardinal n_3;
  Cardinal n_5;
  Cardinal n_6;
  Cardinal n_7;
  uint uVar8;
  Cardinal n_8;
  LayerTypePtr layer;
  LayerTypePtr layer_1;
  LayerTypePtr layer_3;
  LayerTypePtr pLVar9;
  Cardinal n_4;
  ElementTypePtr element_1;
  ElementTypePtr paVar10;
  ElementTypePtr element_2;
  ElementTypePtr element_3;
  Cardinal sn_2;
  Cardinal n_9;
  int iVar11;
  LayerTypePtr layer_2;
  Cardinal sn;
  PinTypePtr via;
  PinTypePtr paVar12;
  TextType *local_28;
  uint local_24;
  
  if ((((type & 4U) == 0) || (F->Line == (_func_void_ptr_LayerTypePtr_LineTypePtr *)0x0)) ||
     (pLVar9 = PCB->Data->Layer, PCB->Data->LayerN == -2)) {
    cVar1 = '\0';
  }
  else {
    local_24 = 0;
    cVar1 = '\0';
    pPVar6 = PCB;
    while( true ) {
      if (pLVar9->On != '\0') {
        iVar7 = pLVar9->LineN - 1;
        if (iVar7 != -1) {
          iVar11 = pLVar9->LineN * 0x58;
          do {
            Ptr2 = (LineTypePtr)(pLVar9->Line[-1].Flags.t + iVar11 + -0x18);
            if ((*(byte *)&(Ptr2->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(4,pLVar9,Ptr2,Ptr2);
                (Ptr2->Flags).f = (Ptr2->Flags).f & 0xffffffbf;
              }
              (*F->Line)(pLVar9,Ptr2);
              cVar1 = '\x01';
            }
            iVar7 = iVar7 + -1;
            pPVar6 = PCB;
            iVar11 = iVar11 + -0x58;
          } while (iVar7 != -1);
        }
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      pLVar9 = pLVar9 + 1;
    }
  }
  if ((((type & 0x4000U) != 0) && (F->Arc != (_func_void_ptr_LayerTypePtr_ArcTypePtr *)0x0)) &&
     (pLVar9 = PCB->Data->Layer, PCB->Data->LayerN != -2)) {
    local_24 = 0;
    pPVar6 = PCB;
    while( true ) {
      if (pLVar9->On != '\0') {
        iVar7 = pLVar9->ArcN - 1;
        if (iVar7 != -1) {
          iVar11 = pLVar9->ArcN * 0x44;
          do {
            Ptr2_00 = (ArcTypePtr)(pLVar9->Arc[-1].Flags.t + iVar11 + -0x18);
            if ((*(byte *)&(Ptr2_00->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(0x4000,pLVar9,Ptr2_00,Ptr2_00);
                (Ptr2_00->Flags).f = (Ptr2_00->Flags).f & 0xffffffbf;
              }
              (*F->Arc)(pLVar9,Ptr2_00);
              cVar1 = '\x01';
            }
            iVar7 = iVar7 + -1;
            pPVar6 = PCB;
            iVar11 = iVar11 + -0x44;
          } while (iVar7 != -1);
        }
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      pLVar9 = pLVar9 + 1;
    }
  }
  if ((((type & 0x10U) != 0) && (F->Text != (_func_void_ptr_LayerTypePtr_TextTypePtr *)0x0)) &&
     (pLVar9 = PCB->Data->Layer, PCB->Data->LayerN != -2)) {
    local_24 = 0;
    pPVar6 = PCB;
    while( true ) {
      iVar7 = pLVar9->TextN - 1;
      if (iVar7 != -1) {
        iVar11 = pLVar9->TextN * 0x3c;
        do {
          Ptr2_01 = (TextTypePtr)(pLVar9->Text[-1].Flags.t + iVar11 + -0x18);
          if (((*(byte *)&(Ptr2_01->Flags).f & 0x40) != 0) && (pLVar9->On != '\0')) {
            if (Reset != '\0') {
              AddObjectToFlagUndoList(0x10,pLVar9,Ptr2_01,Ptr2_01);
              (Ptr2_01->Flags).f = (Ptr2_01->Flags).f & 0xffffffbf;
            }
            (*F->Text)(pLVar9,Ptr2_01);
            cVar1 = '\x01';
          }
          iVar7 = iVar7 + -1;
          pPVar6 = PCB;
          iVar11 = iVar11 + -0x3c;
        } while (iVar7 != -1);
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      pLVar9 = pLVar9 + 1;
    }
  }
  if ((((type & 8U) != 0) && (F->Polygon != (_func_void_ptr_LayerTypePtr_PolygonTypePtr *)0x0)) &&
     (pLVar9 = PCB->Data->Layer, PCB->Data->LayerN != -2)) {
    local_24 = 0;
    pPVar6 = PCB;
    while( true ) {
      if (pLVar9->On != '\0') {
        iVar7 = pLVar9->PolygonN - 1;
        if (iVar7 != -1) {
          iVar11 = pLVar9->PolygonN * 0x3c;
          do {
            Ptr2_02 = (PolygonTypePtr)(pLVar9->Polygon[-1].Flags.t + iVar11 + -0x18);
            if ((*(byte *)&(Ptr2_02->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(8,pLVar9,Ptr2_02,Ptr2_02);
                (Ptr2_02->Flags).f = (Ptr2_02->Flags).f & 0xffffffbf;
              }
              (*F->Polygon)(pLVar9,Ptr2_02);
              cVar1 = '\x01';
            }
            iVar7 = iVar7 + -1;
            pPVar6 = PCB;
            iVar11 = iVar11 + -0x3c;
          } while (iVar7 != -1);
        }
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      pLVar9 = pLVar9 + 1;
    }
  }
  if ((((type & 2U) != 0) && (PCB->ElementOn != '\0')) &&
     (F->Element != (_func_void_ptr_ElementTypePtr *)0x0)) {
    paVar4 = PCB->Data;
    iVar7 = paVar4->ElementN - 1;
    if (iVar7 != -1) {
      iVar11 = paVar4->ElementN * 300;
      while( true ) {
        paVar10 = (ElementTypePtr)(paVar4->Element[-1].Flags.t + iVar11 + -0x18);
        if ((*(byte *)&(paVar10->Flags).f & 0x40) != 0) {
          if (Reset != '\0') {
            AddObjectToFlagUndoList(2,paVar10,paVar10,paVar10);
            (paVar10->Flags).f = (paVar10->Flags).f & 0xffffffbf;
          }
          (*F->Element)(paVar10);
          cVar1 = '\x01';
        }
        iVar7 = iVar7 + -1;
        if (iVar7 == -1) break;
        paVar4 = PCB->Data;
        iVar11 = iVar11 + -300;
      }
    }
  }
  if ((((type & 0x400U) != 0) && (PCB->ElementOn != '\0')) &&
     (F->ElementName != (_func_void_ptr_ElementTypePtr *)0x0)) {
    paVar4 = PCB->Data;
    iVar7 = paVar4->ElementN - 1;
    if (iVar7 != -1) {
      iVar11 = paVar4->ElementN * 300;
      while( true ) {
        uVar3 = (PCB->Flags).f;
        paVar10 = (ElementTypePtr)(paVar4->Element[-1].Flags.t + iVar11 + -0x18);
        pTVar2 = paVar10->Name;
        if ((uVar3 & 0x40) == 0) {
          uVar5 = -(uint)((uVar3 & 0x20) == 0) & 0x78;
        }
        else {
          uVar5 = 0x3c;
        }
        if (((pTVar2->Flags).t[uVar5 - 4] & 0x40) != 0) {
          if (Reset != '\0') {
            if ((uVar3 & 0x40) == 0) {
              local_28 = pTVar2;
              if ((uVar3 & 0x20) == 0) {
                local_28 = paVar10->Name + 2;
              }
            }
            else {
              local_28 = paVar10->Name + 1;
            }
            AddObjectToFlagUndoList(0x400,paVar10,local_28,local_28);
            uVar3 = (PCB->Flags).f;
            if ((uVar3 & 0x40) == 0) {
              if ((uVar3 & 0x20) == 0) {
                pTVar2 = paVar10->Name + 2;
              }
            }
            else {
              pTVar2 = paVar10->Name + 1;
            }
            (pTVar2->Flags).f = (pTVar2->Flags).f & 0xffffffbf;
          }
          (*F->ElementName)(paVar10);
          cVar1 = '\x01';
        }
        iVar7 = iVar7 + -1;
        if (iVar7 == -1) break;
        paVar4 = PCB->Data;
        iVar11 = iVar11 + -300;
      }
    }
  }
  if ((((type & 0x100U) != 0) && (PCB->PinOn != '\0')) &&
     (F->Pin != (_func_void_ptr_ElementTypePtr_PinTypePtr *)0x0)) {
    paVar4 = PCB->Data;
    local_24 = paVar4->ElementN - 1;
    if (local_24 != -1) {
      iVar7 = paVar4->ElementN * 300;
      while( true ) {
        local_28 = (TextType *)(iVar7 + -300);
        paVar10 = (ElementTypePtr)(paVar4->Element[-1].Flags.t + iVar7 + -0x18);
        if (paVar10->PinN != 0) {
          uVar5 = 0;
          uVar3 = paVar10->PinN;
          do {
            paVar12 = paVar10->Pin + uVar5;
            uVar8 = uVar3;
            if ((*(byte *)&(paVar12->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(0x100,paVar10,paVar12,paVar12);
                (paVar12->Flags).f = (paVar12->Flags).f & 0xffffffbf;
              }
              (*F->Pin)(paVar10,paVar12);
              uVar8 = paVar10->PinN;
              cVar1 = '\x01';
            }
          } while ((uVar8 != 0) &&
                  (uVar5 = (uVar5 + 1 + uVar8) - uVar3, uVar3 = uVar8, uVar5 < uVar8));
        }
        local_24 = local_24 + -1;
        if (local_24 == -1) break;
        paVar4 = PCB->Data;
        iVar7 = (int)local_28;
      }
    }
  }
  if ((((type & 0x200U) != 0) && (PCB->PinOn != '\0')) &&
     (F->Pad != (_func_void_ptr_ElementTypePtr_PadTypePtr *)0x0)) {
    paVar4 = PCB->Data;
    local_24 = paVar4->ElementN - 1;
    if (local_24 != -1) {
      iVar7 = paVar4->ElementN * 300;
      while( true ) {
        local_28 = (TextType *)(iVar7 + -300);
        paVar10 = (ElementTypePtr)(paVar4->Element[-1].Flags.t + iVar7 + -0x18);
        uVar3 = paVar10->PadN;
        uVar5 = uVar3;
        for (uVar8 = 0; (uVar5 != 0 && (uVar8 < uVar5)); uVar8 = uVar8 + (uVar3 == uVar5)) {
          Ptr2_03 = paVar10->Pad + uVar8;
          if ((*(byte *)&(Ptr2_03->Flags).f & 0x40) != 0) {
            if (Reset != '\0') {
              AddObjectToFlagUndoList(0x200,paVar10,Ptr2_03,Ptr2_03);
              (Ptr2_03->Flags).f = (Ptr2_03->Flags).f & 0xffffffbf;
            }
            (*F->Pad)(paVar10,Ptr2_03);
            uVar5 = paVar10->PadN;
            cVar1 = '\x01';
          }
        }
        local_24 = local_24 + -1;
        if (local_24 == -1) break;
        paVar4 = PCB->Data;
        iVar7 = (int)local_28;
      }
    }
  }
  if ((((type & 1U) != 0) && (PCB->ViaOn != '\0')) && (F->Via != (_func_void_ptr_PinTypePtr *)0x0))
  {
    paVar4 = PCB->Data;
    if (paVar4->ViaN != 0) {
      uVar5 = 0;
      pPVar6 = PCB;
      uVar3 = paVar4->ViaN;
      do {
        paVar12 = paVar4->Via + uVar5;
        if ((*(byte *)&(paVar12->Flags).f & 0x40) != 0) {
          if (Reset != '\0') {
            AddObjectToFlagUndoList(1,paVar12,paVar12,paVar12);
            (paVar12->Flags).f = (paVar12->Flags).f & 0xffffffbf;
          }
          (*F->Via)(paVar12);
          cVar1 = '\x01';
          pPVar6 = PCB;
        }
        paVar4 = pPVar6->Data;
        uVar8 = paVar4->ViaN;
      } while ((uVar8 != 0) && (uVar5 = (uVar8 + 1 + uVar5) - uVar3, uVar3 = uVar8, uVar5 < uVar8));
    }
  }
  if (((type & 0x20U) != 0) &&
     ((PCB->RatOn != '\0' && (F->Rat != (_func_void_ptr_RatTypePtr *)0x0)))) {
    paVar4 = PCB->Data;
    iVar7 = paVar4->RatN - 1;
    if (iVar7 != -1) {
      iVar11 = paVar4->RatN * 0x5c;
      while( true ) {
        Ptr1 = (RatTypePtr)(paVar4->Rat[-1].Flags.t + iVar11 + -0x18);
        if ((*(byte *)&(Ptr1->Flags).f & 0x40) != 0) {
          if (Reset != '\0') {
            AddObjectToFlagUndoList(0x20,Ptr1,Ptr1,Ptr1);
            (Ptr1->Flags).f = (Ptr1->Flags).f & 0xffffffbf;
          }
          (*F->Rat)(Ptr1);
          cVar1 = '\x01';
        }
        iVar7 = iVar7 + -1;
        if (iVar7 == -1) break;
        paVar4 = PCB->Data;
        iVar11 = iVar11 + -0x5c;
      }
    }
  }
  if ((cVar1 != '\0') && (Reset != '\0')) {
    IncrementUndoSerialNumber();
    return cVar1;
  }
  return cVar1;
}



// WARNING: Unknown calling convention

int regexec_match_all(regex_t *preg,char *string)

{
  int iVar1;
  size_t sVar2;
  regmatch_t match;
  
  iVar1 = regexec((regex_t *)preg,string,1,(regmatch_t *)&match,0);
  if ((iVar1 == 0) && (match.rm_so == 0)) {
    sVar2 = strlen(string);
    return (uint)(match.rm_eo == sVar2);
  }
  return 0;
}



// WARNING: Unknown calling convention

Boolean SelectObjectByName(int Type,char *Pattern,Boolean Flag)

{
  PadTypePtr Pad;
  int iVar1;
  char *string;
  Cardinal CVar2;
  uint uVar3;
  bool bVar4;
  int iVar5;
  int result;
  int iVar6;
  int iVar7;
  PCBTypePtr pPVar8;
  Cardinal sn_3;
  Cardinal sn;
  Cardinal sn_1;
  TextTypePtr text_1;
  LayerTypePtr layer;
  LayerTypePtr Layer;
  PinTypePtr pin_1;
  String name;
  uint uVar9;
  DataTypePtr paVar10;
  Cardinal n_1;
  ElementTypePtr element;
  ElementTypePtr Element;
  Cardinal n_4;
  Cardinal n_5;
  uint uVar11;
  PinTypePtr via;
  PinTypePtr paVar12;
  TextTypePtr text;
  TextTypePtr Text;
  ElementTypePtr element_1;
  uchar *puVar13;
  ElementTypePtr element_2;
  Cardinal n_6;
  PinTypePtr pin;
  PadTypePtr pad;
  Cardinal n;
  Cardinal sn_2;
  Cardinal sn_4;
  uint uVar14;
  Cardinal n_2;
  Cardinal n_3;
  ElementTypePtr paVar15;
  int in_GS_OFFSET;
  int local_e8;
  int local_e4;
  uint local_d4;
  uint local_d0;
  regex_t compiled;
  char errorstring [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar5 = regcomp((regex_t *)&compiled,Pattern,3);
  if (iVar5 != 0) {
    regerror(iVar5,(regex_t *)&compiled,errorstring,0x80);
    Message("regexp error: %s\n",errorstring);
    regfree((regex_t *)&compiled);
    bVar4 = false;
    goto LAB_080cd1e9;
  }
  pPVar8 = PCB;
  if ((Type & 0x10U) == 0) {
    bVar4 = false;
  }
  else {
    bVar4 = false;
    Layer = PCB->Data->Layer;
    if (PCB->Data->LayerN != -2) {
      local_d0 = 0;
      while( true ) {
        iVar5 = Layer->TextN - 1;
        if (iVar5 != -1) {
          iVar7 = Layer->TextN * 0x3c;
          do {
            Text = (TextTypePtr)(Layer->Text[-1].Flags.t + iVar7 + -0x18);
            if (((((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) == 0) && (Layer->On != '\0')) &&
                (Text->TextString != (char *)0x0)) &&
               ((iVar6 = regexec_match_all(&compiled,Text->TextString), iVar6 != 0 &&
                (((Text->Flags).f >> 6 & 1) != (int)Flag)))) {
              AddObjectToFlagUndoList(0x10,Layer,Text,Text);
              (Text->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Text->Flags).f & 0xffffffbf;
              DrawText(Layer,Text,0);
              bVar4 = true;
            }
            iVar5 = iVar5 + -1;
            pPVar8 = PCB;
            iVar7 = iVar7 + -0x3c;
          } while (iVar5 != -1);
        }
        local_d0 = local_d0 + 1;
        if (pPVar8->Data->LayerN + 2U <= local_d0) break;
        Layer = Layer + 1;
      }
    }
  }
  if ((pPVar8->ElementOn != '\0') && ((Type & 2U) != 0)) {
    paVar10 = pPVar8->Data;
    local_d0 = paVar10->ElementN - 1;
    if (local_d0 != -1) {
      iVar5 = paVar10->ElementN * 300;
      do {
        Element = (ElementTypePtr)(paVar10->Element[-1].Flags.t + iVar5 + -0x18);
        uVar14 = (Element->Flags).f;
        if (((uVar14 & 0x2000) == 0) &&
           ((((uVar14 >> 7 & 1) == (int)Settings.ShowSolderSide ||
             (pPVar8->InvisibleObjectsOn != '\0')) && ((uVar14 >> 6 & 1) != (int)Flag)))) {
          uVar14 = (pPVar8->Flags).f;
          uVar9 = 1;
          if ((uVar14 & 0x40) == 0) {
            uVar9 = -(uint)((uVar14 & 0x20) == 0) & 2;
          }
          string = Element->Name[uVar9].TextString;
          if ((string != (char *)0x0) &&
             (iVar7 = regexec_match_all(&compiled,string), pPVar8 = PCB, iVar7 != 0)) {
            AddObjectToFlagUndoList(2,Element,Element,Element);
            (Element->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Element->Flags).f & 0xffffffbf;
            if (Element->PinN != 0) {
              uVar14 = 0;
              local_d4 = Element->PinN;
              do {
                paVar12 = Element->Pin + uVar14;
                AddObjectToFlagUndoList(0x100,Element,paVar12,paVar12);
                (paVar12->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar12->Flags).f & 0xffffffbf
                ;
                uVar9 = Element->PinN;
                if (uVar9 == 0) break;
                uVar14 = (uVar9 + 1 + uVar14) - local_d4;
                local_d4 = uVar9;
              } while (uVar14 < uVar9);
            }
            uVar14 = Element->PadN;
            uVar11 = 0;
            local_d4 = 0;
            uVar9 = uVar14;
            while ((uVar9 != 0 && (uVar11 < uVar9))) {
              puVar13 = (Element->Pad->Flags).t + local_d4 + -0x18;
              AddObjectToFlagUndoList(0x200,Element,puVar13,puVar13);
              *(uint *)(puVar13 + 0x14) =
                   ~-(uint)(Flag == '\0') & 0x40 | *(uint *)(puVar13 + 0x14) & 0xffffffbf;
              uVar9 = Element->PadN;
              if (Element->PadN == uVar14) {
                uVar11 = uVar11 + 1;
                local_d4 = local_d4 + 0x68;
                uVar9 = uVar14;
              }
            }
            iVar7 = 2;
            paVar15 = Element;
            do {
              AddObjectToFlagUndoList(0x400,Element,Element->Name + iVar7,Element->Name + iVar7);
              iVar7 = iVar7 + -1;
              paVar15->Name[2].Flags.f =
                   ~-(uint)(Flag == '\0') & 0x40 | paVar15->Name[2].Flags.f & 0xffffffbf;
              paVar15 = (ElementTypePtr)&paVar15[-1].LineN;
            } while (iVar7 != -1);
            DrawElementName(Element,0);
            DrawElement(Element,0);
            bVar4 = true;
            pPVar8 = PCB;
          }
        }
        local_d0 = local_d0 + -1;
        if (local_d0 == -1) break;
        paVar10 = pPVar8->Data;
        iVar5 = iVar5 + -300;
      } while( true );
    }
  }
  if (pPVar8->PinOn != '\0') {
    if ((Type & 0x100U) != 0) {
      paVar10 = pPVar8->Data;
      local_d0 = paVar10->ElementN - 1;
      if (local_d0 != -1) {
        iVar5 = paVar10->ElementN * 300;
        while( true ) {
          local_d4 = iVar5 + -300;
          puVar13 = paVar10->Element[-1].Flags.t + iVar5 + -0x18;
          if (*(uint *)(puVar13 + 0xe0) != 0) {
            uVar9 = 0;
            uVar14 = *(uint *)(puVar13 + 0xe0);
            do {
              uVar11 = uVar14;
              if ((puVar13[0x15] & 0x20) == 0) {
                paVar12 = (PinTypePtr)(*(int *)(puVar13 + 0x100) + uVar9 * 0x4c);
                if (paVar12->Name != (char *)0x0) {
                  iVar5 = regexec_match_all(&compiled,paVar12->Name);
                  if ((iVar5 != 0) && (((paVar12->Flags).f >> 6 & 1) != (int)Flag)) {
                    AddObjectToFlagUndoList(0x100,puVar13,paVar12,paVar12);
                    (paVar12->Flags).f =
                         ~-(uint)(Flag == '\0') & 0x40 | (paVar12->Flags).f & 0xffffffbf;
                    DrawPin(paVar12,0);
                    bVar4 = true;
                  }
                  uVar11 = *(uint *)(puVar13 + 0xe0);
                }
              }
              pPVar8 = PCB;
            } while ((uVar11 != 0) &&
                    (uVar9 = (uVar9 + 1 + uVar11) - uVar14, uVar14 = uVar11, uVar9 < uVar11));
          }
          local_d0 = local_d0 + -1;
          if (local_d0 == -1) break;
          paVar10 = pPVar8->Data;
          iVar5 = local_d4;
        }
        if (pPVar8->PinOn == '\0') goto LAB_080cd0ef;
      }
    }
    if ((Type & 0x200U) != 0) {
      CVar2 = pPVar8->Data->ElementN;
      local_e4 = CVar2 - 1;
      if (local_e4 != -1) {
        iVar5 = CVar2 * 300;
        do {
          local_e8 = iVar5 + -300;
          puVar13 = pPVar8->Data->Element[-1].Flags.t + iVar5 + -0x18;
          uVar14 = *(uint *)(puVar13 + 0xe8);
          uVar9 = uVar14;
          for (uVar11 = 0; (uVar9 != 0 && (uVar11 < uVar9)); uVar11 = uVar11 + (uVar14 == uVar9)) {
            if ((puVar13[0x15] & 0x20) == 0) {
              Pad = (PadTypePtr)(*(int *)(puVar13 + 0x104) + uVar11 * 0x68);
              uVar3 = (Pad->Flags).f;
              if (((((uVar3 >> 7 & 1) == (int)Settings.ShowSolderSide) ||
                   (PCB->InvisibleObjectsOn != '\0')) && ((uVar3 >> 6 & 1) != (int)Flag)) &&
                 (Pad->Name != (char *)0x0)) {
                iVar5 = regexec_match_all(&compiled,Pad->Name);
                if (iVar5 == 0) {
                  uVar9 = *(uint *)(puVar13 + 0xe8);
                }
                else {
                  AddObjectToFlagUndoList(0x200,puVar13,Pad,Pad);
                  (Pad->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pad->Flags).f & 0xffffffbf;
                  DrawPad(Pad,0);
                  uVar9 = *(uint *)(puVar13 + 0xe8);
                  bVar4 = true;
                }
              }
            }
          }
          local_e4 = local_e4 + -1;
          pPVar8 = PCB;
          iVar5 = local_e8;
        } while (local_e4 != -1);
      }
    }
  }
LAB_080cd0ef:
  if ((pPVar8->ViaOn != '\0') && ((Type & 1U) != 0)) {
    paVar10 = pPVar8->Data;
    if (paVar10->ViaN != 0) {
      uVar9 = 0;
      uVar14 = paVar10->ViaN;
      do {
        paVar12 = paVar10->Via + uVar9;
        if ((((*(byte *)((int)&(paVar12->Flags).f + 1) & 0x20) == 0) &&
            (paVar12->Name != (char *)0x0)) &&
           ((iVar5 = regexec_match_all(&compiled,paVar12->Name), pPVar8 = PCB, iVar5 != 0 &&
            (((paVar12->Flags).f >> 6 & 1) != (int)Flag)))) {
          AddObjectToFlagUndoList(1,paVar12,paVar12,paVar12);
          (paVar12->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar12->Flags).f & 0xffffffbf;
          DrawVia(paVar12,0);
          bVar4 = true;
          pPVar8 = PCB;
        }
        paVar10 = pPVar8->Data;
        uVar11 = paVar10->ViaN;
      } while ((uVar11 != 0) &&
              (uVar9 = (uVar11 + 1 + uVar9) - uVar14, uVar14 = uVar11, uVar9 < uVar11));
    }
  }
  regfree((regex_t *)&compiled);
  if (bVar4) {
    IncrementUndoSerialNumber();
    Draw();
  }
LAB_080cd1e9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return bVar4;
}



// WARNING: Unknown calling convention

Boolean SelectConnection(Boolean Flag)

{
  PadTypePtr Pad;
  LayerTypePtr layer;
  LayerTypePtr layer_2;
  LayerTypePtr layer_1;
  LayerTypePtr pLVar1;
  DataTypePtr paVar2;
  Boolean changed;
  uint uVar3;
  Cardinal l;
  Cardinal sn_1;
  PinTypePtr pin;
  PinTypePtr paVar4;
  PCBTypePtr pPVar5;
  Cardinal n;
  int iVar6;
  Cardinal n_1;
  uint uVar7;
  Cardinal n_2;
  uint uVar8;
  Cardinal n_3;
  Cardinal n_4;
  Cardinal n_5;
  Cardinal n_6;
  int iVar9;
  ElementTypePtr element;
  uchar *puVar10;
  ElementTypePtr element_1;
  Cardinal sn_2;
  RatTypePtr line_1;
  LineTypePtr line;
  LineTypePtr Line;
  ArcTypePtr arc;
  Cardinal sn;
  PadTypePtr pad;
  PinTypePtr via;
  ArcTypePtr Arc;
  PolygonTypePtr Polygon;
  RatTypePtr Line_00;
  int local_28;
  Boolean local_22;
  uint local_20;
  
  pPVar5 = PCB;
  if (PCB->RatOn == '\0') {
    paVar2 = PCB->Data;
    local_22 = '\0';
  }
  else {
    paVar2 = PCB->Data;
    local_22 = '\0';
    iVar6 = paVar2->RatN - 1;
    if (iVar6 != -1) {
      local_22 = '\0';
      iVar9 = paVar2->RatN * 0x5c;
      while( true ) {
        Line_00 = (RatTypePtr)(paVar2->Rat[-1].Flags.t + iVar9 + -0x18);
        if ((*(byte *)&(Line_00->Flags).f & 4) != 0) {
          AddObjectToFlagUndoList(0x20,Line_00,Line_00,Line_00);
          (Line_00->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Line_00->Flags).f & 0xffffffbf;
          DrawRat(Line_00,0);
          local_22 = '\x01';
          pPVar5 = PCB;
        }
        if (iVar6 == 0) break;
        iVar6 = iVar6 + -1;
        paVar2 = pPVar5->Data;
        iVar9 = iVar9 + -0x5c;
      }
      paVar2 = pPVar5->Data;
    }
  }
  pLVar1 = paVar2->Layer;
  if (paVar2->LayerN != -2) {
    uVar3 = 0;
    do {
      if (pLVar1->On != '\0') {
        iVar6 = pLVar1->LineN - 1;
        if (iVar6 != -1) {
          iVar9 = pLVar1->LineN * 0x58 + -0x58;
          do {
            while (Line = (LineTypePtr)((pLVar1->Line->Flags).t + iVar9 + -0x18),
                  ((Line->Flags).f & 0x2004) == 4) {
              AddObjectToFlagUndoList(4,pLVar1,Line,Line);
              iVar6 = iVar6 + -1;
              iVar9 = iVar9 + -0x58;
              (Line->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Line->Flags).f & 0xffffffbf;
              DrawLine(pLVar1,Line,0);
              local_22 = '\x01';
              pPVar5 = PCB;
              if (iVar6 == -1) goto LAB_080cd579;
            }
            iVar6 = iVar6 + -1;
            iVar9 = iVar9 + -0x58;
            pPVar5 = PCB;
          } while (iVar6 != -1);
        }
      }
LAB_080cd579:
      paVar2 = pPVar5->Data;
      uVar3 = uVar3 + 1;
      if (paVar2->LayerN + 2U <= uVar3) goto LAB_080cd818;
      pLVar1 = pLVar1 + 1;
    } while( true );
  }
  goto LAB_080cd59b;
LAB_080cd818:
  pLVar1 = paVar2->Layer;
  if (paVar2->LayerN != -2) {
    local_20 = 0;
    do {
      if (pLVar1->On != '\0') {
        iVar6 = pLVar1->ArcN - 1;
        if (iVar6 != -1) {
          iVar9 = pLVar1->ArcN * 0x44 + -0x44;
          do {
            while (Arc = (ArcTypePtr)((pLVar1->Arc->Flags).t + iVar9 + -0x18),
                  ((Arc->Flags).f & 0x2004) == 4) {
              AddObjectToFlagUndoList(0x4000,pLVar1,Arc,Arc);
              iVar6 = iVar6 + -1;
              iVar9 = iVar9 + -0x44;
              (Arc->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Arc->Flags).f & 0xffffffbf;
              DrawArc(pLVar1,Arc,0);
              local_22 = '\x01';
              pPVar5 = PCB;
              if (iVar6 == -1) goto LAB_080cd8d6;
            }
            iVar6 = iVar6 + -1;
            iVar9 = iVar9 + -0x44;
            pPVar5 = PCB;
          } while (iVar6 != -1);
        }
      }
LAB_080cd8d6:
      paVar2 = pPVar5->Data;
      local_20 = local_20 + 1;
      if (paVar2->LayerN + 2U <= local_20) goto LAB_080cd8f8;
      pLVar1 = pLVar1 + 1;
    } while( true );
  }
  goto LAB_080cd59b;
LAB_080cd8f8:
  pLVar1 = paVar2->Layer;
  if (paVar2->LayerN != -2) {
    local_20 = 0;
    do {
      if (pLVar1->On != '\0') {
        iVar6 = pLVar1->PolygonN - 1;
        if (iVar6 != -1) {
          iVar9 = pLVar1->PolygonN * 0x3c + -0x3c;
          do {
            while (Polygon = (PolygonTypePtr)((pLVar1->Polygon->Flags).t + iVar9 + -0x18),
                  ((Polygon->Flags).f & 0x2004) == 4) {
              AddObjectToFlagUndoList(8,pLVar1,Polygon,Polygon);
              iVar6 = iVar6 + -1;
              iVar9 = iVar9 + -0x3c;
              (Polygon->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Polygon->Flags).f & 0xffffffbf;
              DrawPolygon(pLVar1,Polygon,0);
              local_22 = '\x01';
              pPVar5 = PCB;
              if (iVar6 == -1) goto LAB_080cd9be;
            }
            iVar6 = iVar6 + -1;
            iVar9 = iVar9 + -0x3c;
            pPVar5 = PCB;
          } while (iVar6 != -1);
        }
      }
LAB_080cd9be:
      paVar2 = pPVar5->Data;
      local_20 = local_20 + 1;
      if (paVar2->LayerN + 2U <= local_20) break;
      pLVar1 = pLVar1 + 1;
    } while( true );
  }
LAB_080cd59b:
  if ((pPVar5->PinOn != '\0') && (pPVar5->ElementOn != '\0')) {
    local_20 = paVar2->ElementN - 1;
    if (local_20 != -1) {
      iVar6 = paVar2->ElementN * 300;
      do {
        local_28 = iVar6 + -300;
        puVar10 = paVar2->Element[-1].Flags.t + iVar6 + -0x18;
        if (*(uint *)(puVar10 + 0xe0) != 0) {
          uVar7 = 0;
          uVar3 = *(uint *)(puVar10 + 0xe0);
          do {
            uVar8 = uVar3;
            pPVar5 = PCB;
            if (((puVar10[0x15] & 0x20) == 0) &&
               (paVar4 = (PinTypePtr)(*(int *)(puVar10 + 0x100) + uVar7 * 0x4c),
               (*(byte *)&(paVar4->Flags).f & 4) != 0)) {
              AddObjectToFlagUndoList(0x100,puVar10,paVar4,paVar4);
              (paVar4->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar4->Flags).f & 0xffffffbf;
              DrawPin(paVar4,0);
              local_22 = '\x01';
              uVar8 = *(uint *)(puVar10 + 0xe0);
              pPVar5 = PCB;
            }
            PCB = pPVar5;
          } while ((uVar8 != 0) &&
                  (uVar7 = (uVar7 + 1 + uVar8) - uVar3, uVar3 = uVar8, uVar7 < uVar8));
          paVar2 = pPVar5->Data;
        }
        local_20 = local_20 + -1;
        iVar6 = local_28;
      } while (local_20 != -1);
    }
    local_20 = paVar2->ElementN - 1;
    if (local_20 != -1) {
      iVar6 = paVar2->ElementN * 300;
      while( true ) {
        local_28 = iVar6 + -300;
        puVar10 = paVar2->Element[-1].Flags.t + iVar6 + -0x18;
        uVar3 = *(uint *)(puVar10 + 0xe8);
        uVar7 = uVar3;
        for (uVar8 = 0; (uVar7 != 0 && (uVar8 < uVar7)); uVar8 = uVar8 + (uVar3 == uVar7)) {
          if (((puVar10[0x15] & 0x20) == 0) &&
             (Pad = (PadTypePtr)(*(int *)(puVar10 + 0x104) + uVar8 * 0x68),
             (*(byte *)&(Pad->Flags).f & 4) != 0)) {
            AddObjectToFlagUndoList(0x200,puVar10,Pad,Pad);
            (Pad->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pad->Flags).f & 0xffffffbf;
            DrawPad(Pad,0);
            uVar7 = *(uint *)(puVar10 + 0xe8);
            local_22 = '\x01';
          }
        }
        local_20 = local_20 + -1;
        pPVar5 = PCB;
        if (local_20 == -1) break;
        paVar2 = PCB->Data;
        iVar6 = local_28;
      }
    }
  }
  if (pPVar5->ViaOn != '\0') {
    paVar2 = pPVar5->Data;
    if (paVar2->ViaN != 0) {
      uVar7 = 0;
      uVar3 = paVar2->ViaN;
      do {
        paVar4 = paVar2->Via + uVar7;
        if (((paVar4->Flags).f & 0x2004) == 4) {
          AddObjectToFlagUndoList(1,paVar4,paVar4,paVar4);
          (paVar4->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar4->Flags).f & 0xffffffbf;
          DrawVia(paVar4,0);
          local_22 = '\x01';
          paVar2 = PCB->Data;
          uVar8 = paVar2->ViaN;
          pPVar5 = PCB;
        }
        else {
          paVar2 = pPVar5->Data;
          uVar8 = paVar2->ViaN;
        }
      } while ((uVar8 != 0) && (uVar7 = (uVar8 + 1 + uVar7) - uVar3, uVar3 = uVar8, uVar7 < uVar8));
    }
  }
  Draw();
  return local_22;
}



// WARNING: Unknown calling convention

Boolean SelectBlock(BoxTypePtr Box,Boolean Flag)

{
  LayerTypePtr Layer;
  Cardinal CVar1;
  int iVar2;
  bool bVar3;
  ArcTypePtr arc;
  ArcTypePtr Arc;
  TextTypePtr text;
  TextTypePtr Text;
  PolygonTypePtr polygon;
  PolygonTypePtr Polygon;
  PCBTypePtr pPVar4;
  Cardinal sn;
  TextTypePtr text_1;
  bool bVar5;
  Cardinal n_4;
  uint uVar6;
  Cardinal sn_1;
  DataTypePtr paVar7;
  RatTypePtr line_1;
  LineTypePtr line;
  LineTypePtr Line;
  ElementTypePtr element;
  Boolean gotElement;
  RatTypePtr Line_00;
  PinTypePtr via;
  Cardinal sn_2;
  Cardinal CVar8;
  Cardinal n;
  Cardinal n_1;
  int iVar9;
  Cardinal n_2;
  Cardinal n_3;
  uint uVar10;
  PadTypePtr paVar11;
  ElementTypePtr paVar12;
  PinTypePtr pin;
  Cardinal n_9;
  uint uVar13;
  PadTypePtr pad_1;
  int iVar14;
  Cardinal n_6;
  PinTypePtr pin_1;
  PinTypePtr paVar15;
  uint uVar16;
  Cardinal n_5;
  Cardinal sn_3;
  bool bVar17;
  char local_41;
  uint local_3c;
  uint local_2c;
  PCBTypePtr local_28;
  DataTypePtr local_24;
  int local_20;
  
  bVar17 = Flag == '\0';
  pPVar4 = PCB;
  if ((bVar17) || (PCB->RatOn != '\0')) {
    local_24 = PCB->Data;
    local_41 = '\0';
    iVar9 = local_24->RatN - 1;
    if (iVar9 != -1) {
      local_28 = PCB;
      iVar14 = local_24->RatN * 0x5c;
      while( true ) {
        Line_00 = (RatTypePtr)(local_24->Rat[-1].Flags.t + iVar14 + -0x18);
        iVar2 = (Line_00->Point1).X;
        if ((Box->X1 <= iVar2) && (iVar2 <= Box->X2)) {
          iVar2 = (Line_00->Point1).Y;
          if ((((Box->Y1 <= iVar2) &&
               ((((iVar2 <= Box->Y2 && (iVar2 = (Line_00->Point2).X, Box->X1 <= iVar2)) &&
                 (iVar2 <= Box->X2)) &&
                ((iVar2 = (Line_00->Point2).Y, Box->Y1 <= iVar2 && (iVar2 <= Box->Y2)))))) &&
              (uVar6 = (Line_00->Flags).f, (uVar6 & 0x2000) == 0)) &&
             ((uVar6 >> 6 & 1) != (int)Flag)) {
            AddObjectToFlagUndoList(0x20,Line_00,Line_00,Line_00);
            (Line_00->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Line_00->Flags).f & 0xffffffbf;
            local_28 = PCB;
            if (PCB->RatOn == '\0') {
              local_24 = PCB->Data;
              local_41 = '\x01';
            }
            else {
              DrawRat(Line_00,0);
              local_28 = PCB;
              local_41 = '\x01';
              local_24 = PCB->Data;
            }
          }
        }
        iVar9 = iVar9 + -1;
        pPVar4 = local_28;
        if (iVar9 == -1) break;
        local_24 = local_28->Data;
        iVar14 = iVar14 + -0x5c;
      }
    }
  }
  else {
    local_24 = PCB->Data;
    local_41 = '\0';
  }
  if (local_24->LayerN != -2) {
    uVar6 = (uint)Flag;
    local_28 = (PCBTypePtr)0x0;
    local_3c = (uint)(Flag != '\0');
    do {
      if ((Flag == '\0') || (local_24->Layer[(int)local_28].On != '\0')) {
        Layer = local_24->Layer + (int)local_28;
        CVar1 = local_24->Layer[(int)local_28].LineN;
        iVar9 = CVar1 - 1;
        if (iVar9 != -1) {
          iVar14 = CVar1 * 0x58;
          do {
            Line = (LineTypePtr)(local_24->Layer[(int)local_28].Line[-1].Flags.t + iVar14 + -0x18);
            iVar2 = (Line->Point1).X;
            if ((Box->X1 <= iVar2) && (iVar2 <= Box->X2)) {
              iVar2 = (Line->Point1).Y;
              if (((Box->Y1 <= iVar2) &&
                  (((iVar2 <= Box->Y2 && (iVar2 = (Line->Point2).X, Box->X1 <= iVar2)) &&
                   (iVar2 <= Box->X2)))) &&
                 ((((iVar2 = (Line->Point2).Y, Box->Y1 <= iVar2 && (iVar2 <= Box->Y2)) &&
                   (uVar13 = (Line->Flags).f, (uVar13 & 0x2000) == 0)) &&
                  ((uVar13 >> 6 & 1) != uVar6)))) {
                AddObjectToFlagUndoList(4,Layer,Line,Line);
                local_41 = '\x01';
                (Line->Flags).f =
                     (int)(local_3c << 0x1f) >> 0x1f & 0x40U | (Line->Flags).f & 0xffffffbf;
                if (local_24->Layer[(int)local_28].On != '\0') {
                  DrawLine(Layer,Line,0);
                  local_41 = '\x01';
                }
              }
            }
            iVar9 = iVar9 + -1;
            iVar14 = iVar14 + -0x58;
          } while (iVar9 != -1);
        }
        CVar1 = local_24->Layer[(int)local_28].ArcN;
        iVar9 = CVar1 - 1;
        if (iVar9 != -1) {
          iVar14 = CVar1 * 0x44;
          do {
            Arc = (ArcTypePtr)(local_24->Layer[(int)local_28].Arc[-1].Flags.t + iVar14 + -0x18);
            if (((Box->X1 <= (Arc->BoundingBox).X1) && ((Arc->BoundingBox).X2 <= Box->X2)) &&
               ((Box->Y1 <= (Arc->BoundingBox).Y1 &&
                ((((Arc->BoundingBox).Y2 <= Box->Y2 &&
                  (uVar13 = (Arc->Flags).f, (uVar13 & 0x2000) == 0)) && ((uVar13 >> 6 & 1) != uVar6)
                 ))))) {
              AddObjectToFlagUndoList(0x4000,Layer,Arc,Arc);
              local_41 = '\x01';
              (Arc->Flags).f = (int)(local_3c << 0x1f) >> 0x1f & 0x40U | (Arc->Flags).f & 0xffffffbf
              ;
              if (local_24->Layer[(int)local_28].On != '\0') {
                DrawArc(Layer,Arc,0);
                local_41 = '\x01';
              }
            }
            iVar9 = iVar9 + -1;
            iVar14 = iVar14 + -0x44;
          } while (iVar9 != -1);
        }
        CVar1 = local_24->Layer[(int)local_28].TextN;
        iVar9 = CVar1 - 1;
        if (iVar9 != -1) {
          iVar14 = CVar1 * 0x3c;
          do {
            if (((bVar17) || (local_24->Layer[(int)local_28].On != '\0')) &&
               ((((Text = (TextTypePtr)
                          (local_24->Layer[(int)local_28].Text[-1].Flags.t + iVar14 + -0x18),
                  Box->X1 <= (Text->BoundingBox).X1 &&
                  (((Text->BoundingBox).X2 <= Box->X2 && (Box->Y1 <= (Text->BoundingBox).Y1)))) &&
                 ((Text->BoundingBox).Y2 <= Box->Y2)) &&
                ((uVar13 = (Text->Flags).f, (uVar13 & 0x2000) == 0 && ((uVar13 >> 6 & 1) != uVar6)))
                ))) {
              AddObjectToFlagUndoList(0x10,Layer,Text,Text);
              local_41 = '\x01';
              (Text->Flags).f =
                   (int)(local_3c << 0x1f) >> 0x1f & 0x40U | (Text->Flags).f & 0xffffffbf;
              if (local_24->Layer[(int)local_28].On != '\0') {
                DrawText(Layer,Text,0);
                local_41 = '\x01';
              }
            }
            iVar9 = iVar9 + -1;
            iVar14 = iVar14 + -0x3c;
          } while (iVar9 != -1);
        }
        CVar1 = local_24->Layer[(int)local_28].PolygonN;
        iVar9 = CVar1 - 1;
        pPVar4 = PCB;
        if (iVar9 != -1) {
          iVar14 = CVar1 * 0x3c;
          do {
            Polygon = (PolygonTypePtr)
                      (local_24->Layer[(int)local_28].Polygon[-1].Flags.t + iVar14 + -0x18);
            if (((((Box->X1 <= (Polygon->BoundingBox).X1) && ((Polygon->BoundingBox).X2 <= Box->X2))
                 && (Box->Y1 <= (Polygon->BoundingBox).Y1)) &&
                (((Polygon->BoundingBox).Y2 <= Box->Y2 &&
                 (uVar13 = (Polygon->Flags).f, (uVar13 & 0x2000) == 0)))) &&
               ((uVar13 >> 6 & 1) != uVar6)) {
              AddObjectToFlagUndoList(8,Layer,Polygon,Polygon);
              local_41 = '\x01';
              (Polygon->Flags).f =
                   (int)(local_3c << 0x1f) >> 0x1f & 0x40U | (Polygon->Flags).f & 0xffffffbf;
              if (local_24->Layer[(int)local_28].On != '\0') {
                DrawPolygon(Layer,Polygon,0);
                local_41 = '\x01';
              }
            }
            iVar9 = iVar9 + -1;
            pPVar4 = PCB;
            iVar14 = iVar14 + -0x3c;
          } while (iVar9 != -1);
        }
      }
      local_24 = pPVar4->Data;
      local_28 = (PCBTypePtr)((int)local_28 + 1);
    } while (local_28 < local_24->LayerN + 2U);
  }
  CVar1 = local_24->ElementN;
  local_28 = (PCBTypePtr)(CVar1 - 1);
  if (local_28 == (PCBTypePtr)0xffffffff) {
LAB_080ce4e8:
    if ((bVar17) || (pPVar4->ViaOn != '\0')) {
      paVar7 = pPVar4->Data;
      if (paVar7->ViaN != 0) {
        uVar13 = 0;
        uVar6 = paVar7->ViaN;
        do {
          via = paVar7->Via + uVar13;
          if (((((Box->X1 <= via->X) && (via->X <= Box->X2)) && (Box->Y1 <= via->Y)) &&
              ((via->Y <= Box->Y2 && (uVar10 = (via->Flags).f, (uVar10 & 0x2000) == 0)))) &&
             ((uVar10 >> 6 & 1) != (int)Flag)) {
            AddObjectToFlagUndoList(1,via,via,via);
            local_41 = '\x01';
            (via->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (via->Flags).f & 0xffffffbf;
            pPVar4 = PCB;
            if (PCB->ViaOn != '\0') {
              DrawVia(via,0);
              local_41 = '\x01';
              pPVar4 = PCB;
            }
          }
          paVar7 = pPVar4->Data;
          uVar10 = paVar7->ViaN;
        } while ((uVar10 != 0) &&
                (uVar13 = (uVar10 + 1 + uVar13) - uVar6, uVar6 = uVar10, uVar13 < uVar10));
      }
    }
    if (local_41 != '\0') {
      Draw();
      IncrementUndoSerialNumber();
    }
    return local_41;
  }
  local_20 = CVar1 * 300 + -300;
  uVar6 = (uint)Flag;
  element = local_24->Element + (CVar1 - 1);
  if (bVar17) goto LAB_080ce10a;
LAB_080cdef8:
  if (pPVar4->ElementOn != '\0') goto LAB_080ce10a;
  bVar3 = false;
  bVar5 = pPVar4->PinOn != '\0';
LAB_080cdf0b:
  do {
    if (!bVar5) goto LAB_080ce0df;
    if (bVar3) goto LAB_080ce0df;
    do {
      if ((*(byte *)((int)&(element->Flags).f + 1) & 0x20) == 0) {
        if (element->PinN != 0) {
          uVar10 = 0;
          uVar13 = element->PinN;
          do {
            paVar15 = element->Pin + uVar10;
            uVar16 = uVar13;
            if (((Box->X1 <= paVar15->X) && (paVar15->X <= Box->X2)) &&
               ((Box->Y1 <= paVar15->Y &&
                ((paVar15->Y <= Box->Y2 && (((paVar15->Flags).f >> 6 & 1) != uVar6)))))) {
              AddObjectToFlagUndoList(0x100,element,paVar15,paVar15);
              (paVar15->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar15->Flags).f & 0xffffffbf;
              if (PCB->PinOn == '\0') {
                local_41 = '\x01';
                uVar16 = element->PinN;
              }
              else {
                DrawPin(paVar15,0);
                local_41 = '\x01';
                uVar16 = element->PinN;
              }
            }
          } while ((uVar16 != 0) &&
                  (uVar10 = (uVar10 + 1 + uVar16) - uVar13, uVar13 = uVar16, uVar10 < uVar16));
        }
        uVar13 = element->PadN;
        uVar10 = uVar13;
        pPVar4 = PCB;
        for (uVar16 = 0; (PCB = pPVar4, uVar10 != 0 && (uVar16 < uVar10));
            uVar16 = uVar16 + (uVar13 == uVar10)) {
          paVar11 = element->Pad + uVar16;
          iVar9 = (paVar11->Point1).X;
          if ((Box->X1 <= iVar9) && (iVar9 <= Box->X2)) {
            iVar9 = (paVar11->Point1).Y;
            if (((((Box->Y1 <= iVar9) && (iVar9 <= Box->Y2)) &&
                 (iVar9 = (paVar11->Point2).X, Box->X1 <= iVar9)) &&
                (((iVar9 <= Box->X2 && (iVar9 = (paVar11->Point2).Y, Box->Y1 <= iVar9)) &&
                 (iVar9 <= Box->Y2)))) && (((paVar11->Flags).f >> 6 & 1) != uVar6)) {
              AddObjectToFlagUndoList(0x200,element,paVar11,paVar11);
              (paVar11->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar11->Flags).f & 0xffffffbf;
              if (PCB->PinOn == '\0') {
                local_41 = '\x01';
                uVar10 = element->PadN;
              }
              else {
                DrawPad(paVar11,0);
                local_41 = '\x01';
                uVar10 = element->PadN;
              }
            }
          }
          pPVar4 = PCB;
        }
      }
LAB_080ce0df:
      do {
        local_28 = (PCBTypePtr)((int)local_28 + -1);
        iVar9 = local_20 + -300;
        if (local_28 == (PCBTypePtr)0xffffffff) goto LAB_080ce4e8;
        element = (ElementTypePtr)(pPVar4->Data->Element[-1].Flags.t + local_20 + -0x18);
        local_20 = iVar9;
        if (!bVar17) goto LAB_080cdef8;
LAB_080ce10a:
        uVar13 = (element->Flags).f;
        if (((uVar13 & 0x2000) != 0) ||
           (((uVar13 >> 7 & 1) != (int)Settings.ShowSolderSide &&
            (pPVar4->InvisibleObjectsOn == '\0')))) {
          bVar3 = false;
          bVar5 = pPVar4->PinOn != '\0' || bVar17;
          goto LAB_080cdf0b;
        }
        uVar13 = (pPVar4->Flags).f;
        uVar10 = uVar13 & 0x40;
        if (uVar10 == 0) {
          uVar16 = -(uint)((uVar13 & 0x20) == 0) & 2;
        }
        else {
          uVar16 = 1;
        }
        if (Box->X1 <= element->Name[uVar16].BoundingBox.X1) {
          if (uVar10 == 0) {
            if (element->Name[-(uint)((uVar13 & 0x20) == 0) & 2].BoundingBox.X2 <= Box->X2)
            goto LAB_080ce176;
          }
          else if (element->Name[1].BoundingBox.X2 <= Box->X2) {
LAB_080ce176:
            uVar16 = 1;
            if (uVar10 == 0) {
              uVar16 = -(uint)((uVar13 & 0x20) == 0) & 2;
            }
            if (Box->Y1 <= element->Name[uVar16].BoundingBox.Y1) {
              if (uVar10 == 0) {
                if (element->Name[-(uint)((uVar13 & 0x20) == 0) & 2].BoundingBox.Y2 <= Box->Y2)
                goto LAB_080ce1bf;
              }
              else if (element->Name[1].BoundingBox.Y2 <= Box->Y2) {
LAB_080ce1bf:
                local_2c = 0x3c;
                if (uVar10 == 0) {
                  local_2c = -(uint)((uVar13 & 0x20) == 0) & 0x78;
                }
                if ((element->Name[0].Flags.t[local_2c - 3] & 0x20) == 0) {
                  uVar16 = 0x3c;
                  if (uVar10 == 0) {
                    uVar16 = -(uint)((uVar13 & 0x20) == 0) & 0x78;
                  }
                  if ((*(uint *)(element->Name[0].Flags.t + (uVar16 - 4)) >> 6 & 1) != uVar6) {
                    iVar9 = 2;
                    paVar12 = element;
                    do {
                      AddObjectToFlagUndoList
                                (0x400,element,element->Name + iVar9,element->Name + iVar9);
                      iVar9 = iVar9 + -1;
                      paVar12->Name[2].Flags.f =
                           ~-(uint)(Flag == '\0') & 0x40 | paVar12->Name[2].Flags.f & 0xffffffbf;
                      paVar12 = (ElementTypePtr)&paVar12[-1].LineN;
                    } while (iVar9 != -1);
                    local_41 = '\x01';
                    pPVar4 = PCB;
                    if (PCB->ElementOn != '\0') {
                      DrawElementName(element,0);
                      local_41 = '\x01';
                      pPVar4 = PCB;
                    }
                  }
                }
              }
            }
          }
        }
      } while ((!bVar17) && (pPVar4->PinOn == '\0'));
    } while ((((element->BoundingBox).X1 < Box->X1) ||
             (((Box->X2 < (element->BoundingBox).X2 || ((element->BoundingBox).Y1 < Box->Y1)) ||
              (Box->Y2 < (element->BoundingBox).Y2)))) || (((element->Flags).f >> 6 & 1) == uVar6));
    AddObjectToFlagUndoList(2,element,element,element);
    (element->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (element->Flags).f & 0xffffffbf;
    if (element->PinN != 0) {
      uVar10 = 0;
      uVar13 = element->PinN;
      do {
        paVar15 = element->Pin + uVar10;
        uVar16 = uVar13;
        if (uVar6 != ((paVar15->Flags).f >> 6 & 1)) {
          AddObjectToFlagUndoList(0x100,element,paVar15,paVar15);
          (paVar15->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar15->Flags).f & 0xffffffbf;
          if (PCB->PinOn != '\0') {
            DrawPin(paVar15,0);
          }
          uVar16 = element->PinN;
        }
      } while ((uVar16 != 0) &&
              (uVar10 = (uVar10 + 1 + uVar16) - uVar13, uVar13 = uVar16, uVar10 < uVar16));
    }
    CVar1 = element->PadN;
    local_24 = (DataTypePtr)0x0;
    iVar9 = 0;
    CVar8 = CVar1;
    while ((CVar8 != 0 && (local_24 < CVar8))) {
      paVar11 = (PadTypePtr)((element->Pad->Flags).t + iVar9 + -0x18);
      if (uVar6 != ((paVar11->Flags).f >> 6 & 1)) {
        AddObjectToFlagUndoList(0x200,element,paVar11,paVar11);
        (paVar11->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (paVar11->Flags).f & 0xffffffbf;
        if (PCB->PinOn != '\0') {
          DrawPad(paVar11,0);
        }
        CVar8 = element->PadN;
      }
      if (CVar1 == CVar8) {
        local_24 = (DataTypePtr)((int)local_24 + 1);
        iVar9 = iVar9 + 0x68;
        CVar8 = CVar1;
      }
    }
    if (PCB->PinOn == '\0') {
      bVar3 = true;
      local_41 = '\x01';
      pPVar4 = PCB;
      bVar5 = bVar17;
    }
    else {
      bVar3 = true;
      DrawElement(element,0);
      local_41 = '\x01';
      bVar5 = PCB->PinOn != '\0' || bVar17;
      pPVar4 = PCB;
    }
  } while( true );
}



// WARNING: Unknown calling convention

Boolean SelectObject(void)

{
  FlagType *pFVar1;
  Boolean changed;
  int iVar2;
  int type;
  TextTypePtr text;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar3;
  TextTypePtr text_1;
  PCBTypePtr pPVar4;
  Cardinal n;
  int iVar5;
  Cardinal n_3;
  ElementTypePtr paVar6;
  PinTypePtr pin;
  PinTypePtr Ptr2;
  PadTypePtr pad;
  uchar *Ptr2_00;
  ElementTypePtr element;
  uint uVar7;
  Cardinal n_1;
  uint uVar8;
  Cardinal n_2;
  uint local_30;
  void *ptr3;
  PadTypePtr local_24;
  ElementTypePtr local_20 [4];
  
  iVar2 = SearchScreen(Crosshair.X,Crosshair.Y,0x473f,local_20,&local_24,&ptr3);
  if ((iVar2 == 0) || ((*(byte *)((int)&(local_24->Flags).f + 1) & 0x20) != 0)) {
    return '\0';
  }
  if (iVar2 == 0x10) {
    AddObjectToFlagUndoList(0x10,local_20[0],local_24,local_24);
    (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
    DrawText((LayerTypePtr)local_20[0],(TextTypePtr)local_24,0);
  }
  else if (iVar2 < 0x11) {
    if (iVar2 == 2) {
      if (local_20[0]->PinN != 0) {
        uVar7 = 0;
        local_30 = local_20[0]->PinN;
        do {
          Ptr2 = local_20[0]->Pin + uVar7;
          AddObjectToFlagUndoList(0x100,local_20[0],Ptr2,Ptr2);
          uVar3 = local_20[0]->PinN;
          (Ptr2->Flags).f = (Ptr2->Flags).f ^ 0x40;
          if (uVar3 == 0) break;
          uVar7 = (uVar3 + 1 + uVar7) - local_30;
          local_30 = uVar3;
        } while (uVar7 < uVar3);
      }
      uVar7 = local_20[0]->PadN;
      uVar8 = 0;
      local_30 = 0;
      uVar3 = uVar7;
      while ((uVar3 != 0 && (uVar8 < uVar3))) {
        Ptr2_00 = (local_20[0]->Pad->Flags).t + local_30 + -0x18;
        AddObjectToFlagUndoList(0x200,local_20[0],Ptr2_00,Ptr2_00);
        uVar3 = local_20[0]->PadN;
        *(uint *)(Ptr2_00 + 0x14) = *(uint *)(Ptr2_00 + 0x14) ^ 0x40;
        if (uVar3 == uVar7) {
          uVar8 = uVar8 + 1;
          local_30 = local_30 + 0x68;
          uVar3 = uVar7;
        }
      }
      iVar2 = 2;
      paVar6 = local_20[0];
      do {
        iVar5 = iVar2 + -1;
        AddObjectToFlagUndoList
                  (0x400,local_20[0],local_20[0]->Name + iVar2,local_20[0]->Name + iVar2);
        pFVar1 = &paVar6->Name[2].Flags;
        pFVar1->f = pFVar1->f ^ 0x40;
        paVar6 = (ElementTypePtr)&paVar6[-1].LineN;
        iVar2 = iVar5;
      } while (iVar5 != -1);
      AddObjectToFlagUndoList(2,local_20[0],local_20[0],local_20[0]);
      pPVar4 = PCB;
      uVar7 = (local_20[0]->Flags).f;
      (local_20[0]->Flags).f = uVar7 ^ 0x40;
      if ((pPVar4->ElementOn != '\0') &&
         (((uVar7 >> 7 & 1) == (int)Settings.ShowSolderSide || (pPVar4->InvisibleObjectsOn != '\0'))
         )) {
        DrawElementName(local_20[0],0);
        DrawElementPackage(local_20[0],0);
        pPVar4 = PCB;
      }
      if (pPVar4->PinOn != '\0') {
        DrawElementPinsAndPads(local_20[0],0);
      }
    }
    else if (iVar2 < 3) {
      if (iVar2 == 1) {
        AddObjectToFlagUndoList(1,local_20[0],local_20[0],local_20[0]);
        (local_20[0]->Flags).f = (local_20[0]->Flags).f ^ 0x40;
        DrawVia((PinTypePtr)local_20[0],0);
      }
    }
    else if (iVar2 == 4) {
      AddObjectToFlagUndoList(4,local_20[0],local_24,local_24);
      (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
      DrawLine((LayerTypePtr)local_20[0],(LineTypePtr)local_24,0);
    }
    else if (iVar2 == 8) {
      AddObjectToFlagUndoList(8,local_20[0],local_24,local_24);
      (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
      DrawPolygon((LayerTypePtr)local_20[0],(PolygonTypePtr)local_24,0);
    }
  }
  else if (iVar2 == 0x200) {
    AddObjectToFlagUndoList(0x200,local_20[0],local_24,local_24);
    (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
    DrawPad(local_24,0);
  }
  else if (iVar2 < 0x201) {
    if (iVar2 == 0x20) {
      AddObjectToFlagUndoList(0x20,local_20[0],local_20[0],local_20[0]);
      (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
      DrawRat((RatTypePtr)local_24,0);
    }
    else if (iVar2 == 0x100) {
      AddObjectToFlagUndoList(0x100,local_20[0],local_24,local_24);
      (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
      DrawPin((PinTypePtr)local_24,0);
    }
  }
  else if (iVar2 == 0x400) {
    iVar2 = 2;
    paVar6 = local_20[0];
    do {
      iVar5 = iVar2 + -1;
      AddObjectToFlagUndoList(0x400,local_20[0],local_20[0]->Name + iVar2,local_20[0]->Name + iVar2)
      ;
      pFVar1 = &paVar6->Name[2].Flags;
      pFVar1->f = pFVar1->f ^ 0x40;
      paVar6 = (ElementTypePtr)&paVar6[-1].LineN;
      iVar2 = iVar5;
    } while (iVar5 != -1);
    DrawElementName(local_20[0],0);
  }
  else if (iVar2 == 0x4000) {
    AddObjectToFlagUndoList(0x4000,local_20[0],local_24,local_24);
    (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
    DrawArc((LayerTypePtr)local_20[0],(ArcTypePtr)local_24,0);
  }
  Draw();
  IncrementUndoSerialNumber();
  return '\x01';
}



// WARNING: Unknown calling convention

void SelectPin(LibraryEntryTypePtr entry,Boolean toggle)

{
  Boolean BVar1;
  PinTypePtr pin;
  PadTypePtr pad;
  ConnectionType conn;
  
  BVar1 = SeekPad(entry,&conn,'\0');
  if (BVar1 != '\0') {
    if (conn.type == 0x100) {
      AddObjectToFlagUndoList(0x100,conn.ptr1,conn.ptr2,conn.ptr2);
      if (toggle == '\0') {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) | 0x40;
      }
      else {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) ^ 0x40;
        CenterDisplay(*(LocationType *)((int)conn.ptr2 + 0x34),
                      *(LocationType *)((int)conn.ptr2 + 0x38),'\0');
      }
      DrawPin((PinTypePtr)conn.ptr2,0);
      return;
    }
    if (conn.type == 0x200) {
      AddObjectToFlagUndoList(0x200,conn.ptr1,conn.ptr2,conn.ptr2);
      if (toggle == '\0') {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) | 0x40;
      }
      else {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) ^ 0x40;
        CenterDisplay(*(LocationType *)((int)conn.ptr2 + 0x2c),
                      *(LocationType *)((int)conn.ptr2 + 0x30),'\0');
      }
      DrawPad((PadTypePtr)conn.ptr2,0);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void SetViaSize(BDimension Size,Boolean Force)

{
  if ((Force != '\0') || ((Size - 2000U < 0x988eb1 && (Settings.ViaDrillingHole + 399 < Size)))) {
    Settings.ViaThickness = Size;
  }
  return;
}



// WARNING: Unknown calling convention

void SetViaDrillingHole(BDimension Size,Boolean Force)

{
  if ((Force != '\0') || ((Size - 400U < 0x9894f1 && (Size < Settings.ViaThickness + -399)))) {
    Settings.ViaDrillingHole = Size;
  }
  return;
}



// WARNING: Unknown calling convention

void pcb_use_route_style(RouteStyleType *rst)

{
  Settings.LineThickness = rst->Thick;
  Settings.ViaThickness = rst->Diameter;
  Settings.ViaDrillingHole = rst->Hole;
  Settings.Keepaway = rst->Keepaway;
  return;
}



// WARNING: Unknown calling convention

void SetKeepawayWidth(BDimension Width)

{
  if (Width < 0x989681) {
    Settings.Keepaway = Width;
  }
  return;
}



// WARNING: Unknown calling convention

void SetTextScale(Dimension Scale)

{
  if ((ushort)(Scale - 10U) < 0x2707) {
    Settings.TextScale = (int)Scale;
  }
  return;
}



// WARNING: Unknown calling convention

void SetChangedFlag(Boolean New)

{
  if (PCB->Changed != New) {
    PCB->Changed = New;
  }
  return;
}



// WARNING: Unknown calling convention

void SaveMode(void)

{
  int iVar1;
  
  iVar1 = mode_position;
  mode_stack[mode_position] = Settings.Mode;
  if (iVar1 < 0xf) {
    mode_position = iVar1 + 1;
  }
  return;
}



// WARNING: Unknown calling convention

void SetLocalRef(LocationType X,LocationType Y,Boolean Showing)

{
  if (Showing == '\0') {
    if (SetLocalRef::count < 1) {
      return;
    }
    HideCrosshair('\0');
    SetLocalRef::count = 0;
    Marked.status = SetLocalRef::old.status;
    Marked._1_3_ = SetLocalRef::old._1_3_;
    Marked.X = SetLocalRef::old.X;
    Marked.Y = SetLocalRef::old.Y;
  }
  else {
    HideCrosshair('\x01');
    if (SetLocalRef::count == 0) {
      SetLocalRef::old.status = Marked.status;
      SetLocalRef::old._1_3_ = Marked._1_3_;
      SetLocalRef::old.X = Marked.X;
      SetLocalRef::old.Y = Marked.Y;
    }
    SetLocalRef::count = SetLocalRef::count + 1;
    Marked.status = 1;
    Marked.X = X;
    Marked.Y = Y;
  }
  RestoreCrosshair('\0');
  return;
}



// WARNING: Unknown calling convention

void SetRouteStyle(char *name)

{
  int iVar1;
  char *__s2;
  int iVar2;
  int iVar3;
  Cardinal n;
  PCBTypePtr pPVar4;
  int in_GS_OFFSET;
  char num [10];
  
  iVar3 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pPVar4 = PCB;
  do {
    if ((name != (char *)0x0) && (__s2 = pPVar4->RouteStyle[0].Name, __s2 != (char *)0x0)) {
      iVar2 = strcmp(name,__s2);
      if (iVar2 == 0) {
        __sprintf_chk(num,1,10,&DAT_081538d1,iVar3 + 1);
        hid_actionl("RouteStyle",num,0);
        break;
      }
    }
    iVar3 = iVar3 + 1;
    pPVar4 = (PCBTypePtr)&pPVar4->PrintFilename;
  } while (iVar3 != 4);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void SetCrosshairRangeToBuffer(void)

{
  if (Settings.Mode != 5) {
    return;
  }
  SetBufferBoundingBox(Buffers + Settings.BufferNumber);
  SetCrosshairRange(Buffers[Settings.BufferNumber].X - Buffers[Settings.BufferNumber].BoundingBox.X1
                    ,Buffers[Settings.BufferNumber].Y -
                     Buffers[Settings.BufferNumber].BoundingBox.Y1,
                    (PCB->MaxWidth + Buffers[Settings.BufferNumber].X) -
                    Buffers[Settings.BufferNumber].BoundingBox.X2,
                    (PCB->MaxHeight + Buffers[Settings.BufferNumber].Y) -
                    Buffers[Settings.BufferNumber].BoundingBox.Y2);
  return;
}



// WARNING: Unknown calling convention

void SetMode(int Mode)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  
  if (SetMode::recursing != '\0') {
    return;
  }
  SetMode::recursing = '\x01';
  HideCrosshair('\x01');
  addedLines = 0;
  Crosshair.AttachedObject.Type = 0;
  Crosshair.AttachedObject.State = 0;
  Crosshair.AttachedPolygon.PointN = 0;
  if (PCB->RatDraw == '\0') {
    if (((Settings.Mode != 2) || (Mode != 0x6d)) || (Crosshair.AttachedLine.State == 0)) {
LAB_080cf1fa:
      bVar4 = Settings.Mode == 2;
      bVar2 = Settings.Mode == 0x6d;
      bVar3 = Mode == 2;
      if ((bVar3) && (bVar2)) {
        bVar3 = true;
        bVar2 = true;
        if (Crosshair.AttachedBox.State != 0) {
          Crosshair.AttachedBox.State = 0;
          Crosshair.AttachedLine.State = 1;
          Settings.Mode = 2;
          Crosshair.AttachedLine.Point2.X = Crosshair.AttachedBox.Point1.X;
          Crosshair.AttachedLine.Point1.X = Crosshair.AttachedBox.Point1.X;
          Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedBox.Point1.Y;
          Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedBox.Point1.Y;
          AdjustAttachedObjects();
          iVar1 = Mode;
          goto LAB_080cf2fd;
        }
      }
      goto LAB_080cf223;
    }
    Crosshair.AttachedLine.State = 0;
    Crosshair.AttachedBox.State = 1;
    Crosshair.AttachedBox.Point2.X = Crosshair.AttachedLine.Point1.X;
    Crosshair.AttachedBox.Point1.X = Crosshair.AttachedLine.Point1.X;
    Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedLine.Point1.Y;
    Crosshair.AttachedBox.Point1.Y = Crosshair.AttachedLine.Point1.Y;
    AdjustAttachedObjects();
    iVar1 = Mode;
  }
  else {
    if (((((Mode != 3) && (Mode != 0x6d)) && (Mode != 4)) && ((Mode != 1 && (Mode != 0x6a)))) &&
       ((Mode != 6 && (Mode != 0x6c)))) goto LAB_080cf1fa;
    Message("That mode is NOT allowed when drawing ratlines!\n");
    bVar4 = Settings.Mode == 2;
    bVar2 = Settings.Mode == 0x6d;
    Mode = 0;
    bVar3 = false;
LAB_080cf223:
    if ((bVar4) || (bVar2)) {
      SetLocalRef(0,0,'\0');
    }
    Crosshair.AttachedBox.State = 0;
    Crosshair.AttachedLine.State = 0;
    if (bVar3) {
      iVar1 = Mode;
      if (*(char *)&(PCB->Flags).f < '\0') {
        SaveUndoSerialNumber();
        ResetFoundPinsViasAndPads('\x01');
        RestoreUndoSerialNumber();
        ResetFoundLinesAndPolygons('\x01');
        IncrementUndoSerialNumber();
        iVar1 = Mode;
      }
    }
    else {
      iVar1 = Mode;
      if (Mode == 5) {
        Settings.Mode = Mode;
        SetCrosshairRangeToBuffer();
        goto LAB_080cf263;
      }
    }
  }
LAB_080cf2fd:
  Settings.Mode = iVar1;
  SetCrosshairRange(0,0,PCB->MaxWidth,PCB->MaxHeight);
LAB_080cf263:
  SetMode::recursing = '\0';
  MoveCrosshairRelative(0,0);
  RestoreCrosshair('\x01');
  return;
}



// WARNING: Unknown calling convention

void RestoreMode(void)

{
  if (mode_position != 0) {
    mode_position = mode_position + -1;
    SetMode(mode_stack[mode_position]);
    return;
  }
  Message("hace: underflow of restore mode\n");
  return;
}



// WARNING: Unknown calling convention

void SetBufferNumber(int Number)

{
  if (4 < (uint)Number) {
    return;
  }
  Settings.BufferNumber = Number;
  SetCrosshairRangeToBuffer();
  return;
}



// WARNING: Unknown calling convention

void SetLineSize(BDimension Size)

{
  if ((Size - 1U < 10000000) && (Settings.LineThickness = Size, *(char *)&(PCB->Flags).f < '\0')) {
    FitCrosshairIntoGrid(Crosshair.X,Crosshair.Y);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void SetGrid(float Grid,Boolean align)

{
  PCBTypePtr pPVar1;
  
  pPVar1 = PCB;
  if ((1.0 <= Grid) && (Grid <= 100000.0)) {
    if (align != '\0') {
      PCB->GridOffsetX =
           (int)ROUND(((float)Crosshair.X - (float)(int)ROUND((float)Crosshair.X / Grid) * Grid) +
                      0.5);
      pPVar1->GridOffsetY =
           (int)ROUND(((float)Crosshair.Y - (float)(int)ROUND((float)Crosshair.Y / Grid) * Grid) +
                      0.5);
    }
    pPVar1->Grid = (double)Grid;
    if (Settings.DrawGrid != '\0') {
      UpdateAll();
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

int error_ignore(char *msg)

{
  return 0;
}



// WARNING: Unknown calling convention

char * alloc_buf(int len)

{
  size_t __size;
  char *pcVar1;
  int iVar2;
  
  __size = len + 1;
  iVar2 = (bufptr + 1) % 10;
  bufptr = iVar2;
  if (buffers[iVar2].len < (int)__size) {
    if (buffers[iVar2].ptr == (char *)0x0) {
      pcVar1 = (char *)malloc(__size);
      buffers[iVar2].ptr = pcVar1;
    }
    else {
      pcVar1 = (char *)realloc(buffers[iVar2].ptr,__size);
      buffers[iVar2].ptr = pcVar1;
    }
    iVar2 = bufptr;
    buffers[bufptr].len = __size;
  }
  return buffers[iVar2].ptr;
}



// WARNING: Unknown calling convention

void grow_layer_list(int num)

{
  size_t __nmemb;
  
  if (layers == (char *)0x0) {
    __nmemb = 1;
    if (0 < num) {
      __nmemb = num;
    }
    layers = (char *)calloc(__nmemb,1);
    max_layers = num;
  }
  else if (max_layers < num) {
    max_layers = num;
    layers = (char *)realloc(layers,num);
  }
  if (num_layers < num) {
    memset(layers + num_layers,0,~num_layers + num);
  }
  num_layers = num;
  return;
}



char * __regparm3
common_flags_to_string(FlagType flags,int object_type,FlagBitsType *flagbits,int n_flagbits)

{
  char cVar1;
  char cVar2;
  int iVar3;
  uchar uVar4;
  ulong uVar5;
  int iVar6;
  uchar uVar7;
  uint *puVar8;
  uint uVar9;
  char *pcVar10;
  undefined4 *puVar11;
  int iVar12;
  char *pcVar13;
  size_t sVar14;
  uchar uVar15;
  uchar uVar16;
  uchar uVar17;
  sbyte sVar18;
  int i_1;
  uchar uVar19;
  uchar uVar20;
  uchar uVar21;
  int iVar22;
  int i;
  uint uVar23;
  char *bp;
  char *__dest;
  undefined4 *__dest_00;
  int iVar24;
  int iVar25;
  int len;
  int rv;
  int in_GS_OFFSET;
  undefined *puVar26;
  char *local_40;
  size_t local_3c;
  FlagType flags_local;
  FlagHolder fh;
  
  uVar19 = (uchar)flagbits;
  uVar4 = (uchar)((uint)n_flagbits >> 8);
  uVar20 = (uchar)n_flagbits;
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  uVar7 = (uchar)((uint)n_flagbits >> 0x10);
  uVar21 = (uchar)((uint)n_flagbits >> 0x18);
  uVar15 = (uchar)((uint)flagbits >> 8);
  uVar16 = (uchar)((uint)flagbits >> 0x10);
  uVar17 = (uchar)((uint)flagbits >> 0x18);
  if (flags.f == 0x20) {
    fh.Flags.f = object_type & 0xffffffef;
  }
  else if (flags.f == 0x100) {
    fh.Flags.f = object_type & 0xfffffffe;
  }
  else {
    fh.Flags.f = object_type;
    if (flags.f == 1) {
      fh.Flags.f = object_type & 0xfffffffd;
    }
  }
  uVar5 = fh.Flags.f;
  iVar25 = 3;
  if (0 < (int)flags.t._4_4_) {
    iVar22 = 0;
    local_40 = (char *)fh.Flags.f;
    iVar25 = 3;
    puVar8 = (uint *)flags.t._0_4_;
    do {
      if (((puVar8[3] & flags.f) != 0) && (((uint)local_40 & *puVar8) != 0)) {
        local_40 = (char *)((uint)local_40 & ~*puVar8);
        iVar25 = iVar25 + 1 + puVar8[2];
      }
      iVar22 = iVar22 + 1;
      puVar8 = puVar8 + 4;
    } while (iVar22 != flags.t._4_4_);
    fh.Flags.f = (ulong)local_40;
  }
  fh.Flags.t[0] = uVar19;
  fh.Flags.t[1] = uVar15;
  fh.Flags.t[2] = uVar16;
  fh.Flags.t[3] = uVar17;
  fh.Flags.t[4] = uVar20;
  fh.Flags.t[5] = uVar4;
  fh.Flags.t[6] = uVar7;
  fh.Flags.t[7] = uVar21;
  iVar22 = mem_any_set(fh.Flags.t,8);
  if (iVar22 != 0) {
    iVar25 = iVar25 + 10;
    uVar9 = 0;
    do {
      uVar23 = (uint)fh.Flags.t[(int)uVar9 >> 1];
      sVar18 = (sbyte)((uVar9 & 1) << 2);
      if ((0xf << sVar18 & uVar23) != 0) {
        uVar23 = (int)uVar23 >> sVar18 & 0xf;
        if ((int)uVar9 < 10) {
          iVar22 = 1;
          if (uVar23 != 0) {
LAB_080cf851:
            iVar22 = 2;
          }
        }
        else {
          iVar22 = 3;
          if (uVar23 == 0) goto LAB_080cf851;
        }
        iVar25 = iVar22 + 1 + iVar25;
      }
      uVar9 = uVar9 + 1;
    } while (uVar9 != 0x10);
  }
  pcVar10 = alloc_buf(iVar25 + 2);
  *pcVar10 = '\"';
  puVar11 = (undefined4 *)(pcVar10 + 1);
  __dest_00 = puVar11;
  fh.Flags.f = uVar5;
  fh.Flags.t[0] = uVar19;
  fh.Flags.t[1] = uVar15;
  fh.Flags.t[2] = uVar16;
  fh.Flags.t[3] = uVar17;
  fh.Flags.t[4] = uVar20;
  fh.Flags.t[5] = uVar4;
  fh.Flags.t[6] = uVar7;
  fh.Flags.t[7] = uVar21;
  if (0 < (int)flags.t._4_4_) {
    iVar25 = 0;
    do {
      if (((*(uint *)(flags.t._0_4_ + 0xc) & flags.f) != 0) &&
         ((fh.Flags.f & *(uint *)flags.t._0_4_) != 0)) {
        if (__dest_00 != puVar11) {
          *(undefined *)__dest_00 = 0x2c;
          __dest_00 = (undefined4 *)((int)__dest_00 + 1);
        }
        strcpy((char *)__dest_00,*(char **)(flags.t._0_4_ + 4));
        __dest_00 = (undefined4 *)((int)__dest_00 + *(uint *)(flags.t._0_4_ + 8));
        fh.Flags.f = fh.Flags.f & ~*(uint *)flags.t._0_4_;
      }
      iVar25 = iVar25 + 1;
      flags.t._0_4_ = flags.t._0_4_ + 0x10;
    } while (iVar25 < (int)flags.t._4_4_);
  }
  iVar25 = mem_any_set(fh.Flags.t,8);
  if (iVar25 != 0) {
    if (__dest_00 != puVar11) {
      *(undefined *)__dest_00 = 0x2c;
      __dest_00 = (undefined4 *)((int)__dest_00 + 1);
    }
    *__dest_00 = 0x72656874;
    uVar9 = 0;
    __dest_00[1] = 0x6c616d;
    __dest = (char *)((int)__dest_00 + 7);
    grow_layer_list(0);
    iVar22 = 1;
    iVar25 = num_layers;
    do {
      while( true ) {
        uVar23 = (uint)fh.Flags.t[(int)uVar9 >> 1];
        sVar18 = (sbyte)((uVar9 & 1) << 2);
        if ((0xf << sVar18 & uVar23) == 0) break;
        if (iVar25 <= (int)uVar9) {
          grow_layer_list(iVar22);
          iVar25 = num_layers;
        }
        iVar22 = iVar22 + 1;
        layers[uVar9] = (byte)((int)uVar23 >> sVar18) & 0xf;
        uVar9 = uVar9 + 1;
        if (uVar9 == 0x10) goto LAB_080cfa1d;
      }
      uVar9 = uVar9 + 1;
      iVar22 = iVar22 + 1;
      iVar25 = num_layers;
    } while (uVar9 != 0x10);
LAB_080cfa1d:
    local_3c = 2;
    if (0 < iVar25) {
      iVar22 = 0;
      do {
        if (layers[iVar22] != '\0') {
          iVar12 = 2;
          if (9 < iVar22) {
            iVar12 = 3;
            iVar24 = iVar22;
            iVar6 = 1;
            if (99 < iVar22) {
              do {
                iVar12 = iVar6;
                iVar24 = iVar24 / 10;
                iVar6 = iVar12 + 1;
              } while (9 < iVar24);
              iVar12 = iVar12 + 2;
            }
          }
          local_3c = local_3c + 1 + iVar12;
        }
        iVar22 = iVar22 + 1;
      } while (iVar22 != iVar25);
    }
    if (print_layer_list::buflen < (int)local_3c) {
      if (print_layer_list::buf == (char *)0x0) {
        print_layer_list::buf = (char *)malloc(local_3c);
      }
      else {
        print_layer_list::buf = (char *)realloc(print_layer_list::buf,local_3c);
      }
      print_layer_list::buflen = local_3c;
      iVar25 = num_layers;
    }
    pcVar13 = print_layer_list::buf;
    local_40 = print_layer_list::buf + 1;
    *print_layer_list::buf = '(';
    if (0 < iVar25) {
      iVar22 = 0;
      do {
        pcVar13 = layers + iVar22;
        cVar1 = *pcVar13;
        iVar12 = iVar22 + 1;
        if (cVar1 != '\0') {
          iVar24 = iVar22 + 1;
          iVar12 = iVar24;
          if (iVar24 < iVar25) {
            cVar2 = layers[iVar22 + 1];
            while ((cVar2 == '\x01' && (iVar12 = iVar12 + 1, iVar12 < iVar25))) {
              cVar2 = pcVar13[2];
              pcVar13 = pcVar13 + 1;
            }
          }
          if (iVar22 + 2 < iVar12) {
            __sprintf_chk(local_40,1,0xffffffff,&DAT_0814f555,iVar22,iVar12 + -1);
          }
          else if (cVar1 == '\x02') {
            puVar26 = &DAT_0814f55c;
LAB_080cfbba:
            __sprintf_chk(local_40,1,0xffffffff,puVar26,iVar22);
            iVar12 = iVar24;
          }
          else {
            if (cVar1 < '\x03') {
              if (cVar1 != '\x01') {
LAB_080cfbae:
                puVar26 = &DAT_0814f56b;
                goto LAB_080cfbba;
              }
              puVar26 = &DAT_0814f558;
            }
            else {
              if (cVar1 == '\x03') {
                __sprintf_chk(local_40,1,0xffffffff,&DAT_0814f561,iVar22);
                iVar12 = iVar24;
                goto LAB_080cfbd5;
              }
              if (cVar1 != '\x04') goto LAB_080cfbae;
              puVar26 = &DAT_0814f566;
            }
            __sprintf_chk(local_40,1,0xffffffff,puVar26,iVar22);
            iVar12 = iVar24;
          }
LAB_080cfbd5:
          sVar14 = strlen(local_40);
          local_40 = local_40 + sVar14;
        }
        iVar22 = iVar12;
        pcVar13 = print_layer_list::buf;
        iVar25 = num_layers;
      } while (iVar22 < num_layers);
    }
    local_40[-1] = ')';
    *local_40 = '\0';
    strcpy(__dest,pcVar13);
    sVar14 = strlen(__dest);
    __dest_00 = (undefined4 *)(__dest + sVar14);
  }
  *(undefined *)__dest_00 = 0x22;
  *(undefined *)((int)__dest_00 + 1) = 0;
  if (iVar3 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pcVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

char * pcbflags_to_string(FlagType flags)

{
  FlagType flags_00;
  char *pcVar1;
  
  flags_00.t[4] = '\x16';
  flags_00.t[5] = '\0';
  flags_00.t[6] = '\0';
  flags_00.t[7] = '\0';
  flags_00.f = 0xffffffff;
  flags_00.t[0] = '\0';
  flags_00.t[1] = 0x80;
  flags_00.t[2] = '\x16';
  flags_00.t[3] = '\b';
  pcVar1 = common_flags_to_string(flags_00,flags.f,(FlagBitsType *)flags.t._0_4_,flags.t._4_4_);
  return pcVar1;
}



// WARNING: Unknown calling convention

char * flags_to_string(FlagType flags,int object_type)

{
  FlagType flags_00;
  char *pcVar1;
  
  flags_00.t._0_4_ = object_flagbits;
  flags_00.f = object_type;
  flags_00.t[4] = '\x17';
  flags_00.t[5] = '\0';
  flags_00.t[6] = '\0';
  flags_00.t[7] = '\0';
  pcVar1 = common_flags_to_string(flags_00,flags.f,(FlagBitsType *)flags.t._0_4_,flags.t._4_4_);
  return pcVar1;
}



// WARNING: Unknown calling convention

FlagType *
common_string_to_flags
          (char *flagstring,_func_int_char_ptr *error,FlagBitsType *flagbits,int n_flagbits)

{
  char cVar1;
  int iVar2;
  char cVar3;
  FlagType *in_EAX;
  code *pcVar4;
  FlagBitsType *pFVar5;
  char *pcVar6;
  uint uVar7;
  ushort **ppuVar8;
  int iVar9;
  size_t sVar10;
  char *pcVar11;
  sbyte sVar12;
  int iVar13;
  char *ep;
  int i;
  char cVar14;
  int flen;
  int iVar15;
  char *msg;
  char *msg_1;
  int iVar16;
  FlagType *pFVar17;
  int range;
  char *fp;
  FlagType *pFVar18;
  int in_GS_OFFSET;
  bool bVar19;
  byte bVar20;
  _func_int_char_ptr *local_50;
  uint local_48;
  int local_38;
  char *local_34;
  char *local_30;
  FlagHolder rv;
  
  bVar20 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  rv.Flags.f = empty_flags.f;
  rv.Flags.t._0_4_ = empty_flags.t._0_4_;
  rv.Flags.t._4_4_ = empty_flags.t._4_4_;
  pcVar4 = error_ignore;
  if (error != (_func_int_char_ptr *)0x0) {
    pcVar4 = error;
  }
  if (flagstring == (char *)0x0) {
    pFVar17 = &empty_flags;
    pFVar18 = in_EAX;
    for (iVar15 = 3; iVar15 != 0; iVar15 = iVar15 + -1) {
      pFVar18->f = pFVar17->f;
      pFVar17 = (FlagType *)pFVar17->t;
      pFVar18 = (FlagType *)pFVar18->t;
    }
  }
  else {
    cVar14 = *flagstring;
    local_30 = flagstring;
    if (cVar14 == '\"') {
      local_30 = flagstring + 1;
      cVar14 = flagstring[1];
    }
    if ((cVar14 != '\"') && (cVar14 != '\0')) {
      local_48 = 0;
      if (cVar14 == ',') goto LAB_080cfef2;
LAB_080cfe38:
      if (cVar14 == '\0') goto LAB_080cfef2;
      iVar15 = 0;
      local_34 = local_30;
      if (cVar14 == '\"') goto LAB_080cfe91;
      if (cVar14 != '(') {
        do {
          local_34 = local_34 + 1;
          cVar14 = *local_34;
          if ((cVar14 == ',') || (cVar14 == '\0')) {
            iVar15 = (int)local_34 - (int)local_30;
            goto LAB_080cfe80;
          }
          if (cVar14 == '\"') {
            iVar15 = (int)local_34 - (int)local_30;
            bVar19 = iVar15 == 7;
            if (!bVar19) goto LAB_080cfe91;
            goto LAB_080cff89;
          }
        } while (cVar14 != '(');
        iVar15 = (int)local_34 - (int)local_30;
      }
      do {
        pcVar6 = local_34 + 1;
        grow_layer_list(0);
        cVar14 = *pcVar6;
        local_34 = pcVar6;
        if (cVar14 != '\0') {
          iVar16 = -1;
          local_38 = 5;
          cVar3 = '\x01';
          iVar13 = 0;
          local_50 = pcVar4;
          do {
            iVar9 = iVar13;
            if (cVar14 == '+') {
              cVar1 = *local_34;
              cVar3 = '\x02';
joined_r0x080d00a3:
              if (cVar1 == ')') {
                local_34 = local_34 + 1;
                break;
              }
            }
            else {
              if (cVar14 == 'S') {
                cVar1 = *local_34;
                cVar3 = '\x03';
                goto joined_r0x080d00a3;
              }
              if (cVar14 == 'X') {
                cVar1 = *local_34;
                cVar3 = '\x04';
                goto joined_r0x080d00a3;
              }
              if (cVar14 == 't') {
                cVar1 = *local_34;
                cVar3 = '\x05';
                goto joined_r0x080d00a3;
              }
              if (((cVar14 != ',') && (cVar14 != ')')) && (cVar14 != '-')) {
                ppuVar8 = __ctype_b_loc();
                if ((*(byte *)((int)*ppuVar8 + cVar14 * 2 + 1) & 8) == 0) {
                  if (local_50 == (_func_int_char_ptr *)0x0) {
                    cVar1 = *local_34;
                  }
                  else {
                    sVar10 = strlen(pcVar6);
                    pcVar11 = alloc_buf(sVar10 + 0x2c);
                    __sprintf_chk(pcVar11,1,0xffffffff,
                                  "Syntax error parsing layer list \"%.*s\" at %c",local_38,pcVar6,
                                  (int)*local_34);
                    (*local_50)(pcVar11);
                    cVar1 = *local_34;
                    local_50 = (_func_int_char_ptr *)0x0;
                  }
                }
                else {
                  cVar1 = *local_34;
                  iVar9 = cVar14 + -0x30 + iVar13 * 10;
                }
                goto joined_r0x080d00a3;
              }
              if (iVar16 == -1) goto LAB_080d011f;
              while (iVar9 = iVar16, iVar16 <= iVar13) {
LAB_080d011f:
                iVar16 = iVar9 + 1;
                if (iVar9 < num_layers) {
                  layers[iVar9] = cVar3;
                }
                else {
                  grow_layer_list(iVar16);
                  layers[iVar9] = cVar3;
                }
              }
              cVar1 = *local_34;
              iVar9 = 0;
              cVar3 = '\x01';
              iVar16 = iVar13;
              if (cVar1 != '-') {
                iVar16 = -1;
                iVar9 = 0;
                goto joined_r0x080d00a3;
              }
            }
            local_34 = local_34 + 1;
            cVar14 = *local_34;
            local_38 = local_38 + 1;
            iVar13 = iVar9;
          } while (cVar14 != '\0');
        }
        do {
          bVar19 = iVar15 == 7;
          if (bVar19) {
LAB_080cff89:
            iVar16 = 7;
            pcVar6 = local_30;
            pcVar11 = "thermal";
            do {
              if (iVar16 == 0) break;
              iVar16 = iVar16 + -1;
              bVar19 = *pcVar6 == *pcVar11;
              pcVar6 = pcVar6 + (uint)bVar20 * -2 + 1;
              pcVar11 = pcVar11 + (uint)bVar20 * -2 + 1;
            } while (bVar19);
            if (!bVar19) goto LAB_080cfe91;
            uVar7 = 0;
            do {
              if (num_layers <= (int)uVar7) break;
              if (layers[uVar7] != '\0') {
                sVar12 = (sbyte)((uVar7 & 1) << 2);
                rv.Flags.t[(int)uVar7 >> 1] =
                     layers[uVar7] << sVar12 | ~(byte)(0xf << sVar12) & rv.Flags.t[(int)uVar7 >> 1];
              }
              uVar7 = uVar7 + 1;
            } while (uVar7 != 0x10);
LAB_080cfecc:
            cVar14 = *local_34;
          }
          else {
LAB_080cfe91:
            iVar16 = 0;
            pFVar5 = flagbits;
            if (0 < n_flagbits) {
              do {
                if (pFVar5->nlen == iVar15) {
                  bVar19 = true;
                  iVar13 = iVar15;
                  pcVar6 = pFVar5->name;
                  fp = local_30;
                  do {
                    if (iVar13 == 0) break;
                    iVar13 = iVar13 + -1;
                    fp = fp + (uint)bVar20 * -2 + 1;
                    bVar19 = *pcVar6 == *fp;
                    pcVar6 = pcVar6 + (uint)bVar20 * -2 + 1;
                    fp = fp;
                  } while (bVar19);
                  if (bVar19) {
                    local_48 = local_48 | pFVar5->mask;
                    goto LAB_080cfecc;
                  }
                }
                iVar16 = iVar16 + 1;
                pFVar5 = pFVar5 + 1;
              } while (iVar16 < n_flagbits);
            }
            pcVar6 = alloc_buf(iVar15 + 0x1c);
            __sprintf_chk(pcVar6,1,0xffffffff,"Unknown flag: \"%.*s\" ignored",iVar15,local_30);
            (*pcVar4)(pcVar6);
            cVar14 = *local_34;
          }
          if ((cVar14 == '\"') || (cVar14 == '\0')) goto LAB_080cff40;
          local_30 = local_34 + 1;
          cVar14 = local_34[1];
          if (cVar14 != ',') goto LAB_080cfe38;
LAB_080cfef2:
          iVar15 = 0;
          local_34 = local_30;
LAB_080cfe80:
        } while (cVar14 != '(');
      } while( true );
    }
    local_48 = 0;
LAB_080cff40:
    rv.Flags.f = local_48;
    in_EAX->f = local_48;
    *(undefined4 *)in_EAX->t = rv.Flags.t._0_4_;
    *(undefined4 *)(in_EAX->t + 4) = rv.Flags.t._4_4_;
  }
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return in_EAX;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

FlagType * string_to_pcbflags(char *flagstring,_func_int_char_ptr *error)

{
  FlagType *in_stack_00000004;
  
  common_string_to_flags(flagstring,error,pcb_flagbits,0x16);
  return in_stack_00000004;
}



// WARNING: Unknown calling convention

FlagType * string_to_flags(char *flagstring,_func_int_char_ptr *error)

{
  FlagType *in_stack_00000004;
  
  common_string_to_flags(flagstring,error,object_flagbits,0x17);
  return in_stack_00000004;
}



// WARNING: Unknown calling convention

POLYAREA * diag_line(LocationType X,LocationType Y,BDimension l,BDimension w,Boolean rt)

{
  PLINE *contour;
  POLYAREA *pPVar1;
  VNODE *pVVar2;
  PLINE *c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  Vector v;
  
  if (rt == '\0') {
    local_40 = (int)ROUND((double)(w - l) * 0.7071067811865476);
    local_3c = (int)ROUND((double)-(w + l) * 0.7071067811865476);
    local_48 = -local_3c;
    local_44 = -local_40;
  }
  else {
    local_48 = (int)ROUND((double)(l - w) * 0.7071067811865476);
    local_44 = (int)ROUND((double)(w + l) * 0.7071067811865476);
    local_40 = local_44;
    local_3c = local_48;
  }
  v[0] = local_3c + X;
  v[1] = local_44 + Y;
  contour = poly_NewContour(v);
  pPVar1 = (POLYAREA *)0x0;
  if (contour != (PLINE *)0x0) {
    v[0] = X - local_40;
    v[1] = Y - local_48;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,pVVar2);
    v[0] = X - local_3c;
    v[1] = Y - local_44;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,pVVar2);
    v[0] = local_40 + X;
    v[1] = Y + local_48;
    pVVar2 = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,pVVar2);
    pPVar1 = ContourToPoly(contour);
  }
  return pPVar1;
}



// WARNING: Unknown calling convention

POLYAREA * square_therm(PinTypePtr pin,Cardinal style)

{
  int iVar1;
  int iVar2;
  PLINE *pPVar3;
  PLINE *c;
  POLYAREA *p2;
  POLYAREA *pPVar4;
  VNODE *pVVar5;
  POLYAREA *pPVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  POLYAREA *p;
  BDimension d;
  int in_GS_OFFSET;
  Vector v;
  LineType l;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (style == 1) {
    iVar8 = pin->Clearance;
    iVar9 = pin->Thickness;
    iVar7 = iVar9 / 2;
    iVar2 = (int)ROUND((double)iVar8 * pcb->ThermScale * 0.7071067811865476);
    v[0] = (iVar2 - iVar7) + pin->X;
    v[1] = pin->Y + iVar7;
    pPVar3 = poly_NewContour(v);
    if (pPVar3 != (PLINE *)0x0) {
      v[0] = (pin->X + iVar7) - iVar2;
      iVar8 = (iVar9 + iVar8) / 2;
      pVVar5 = poly_CreateNode(v);
      poly_InclVertex((pPVar3->head).prev,pVVar5);
      v[0] = (iVar8 + pin->X) - iVar2;
      v[1] = iVar8 + pin->Y;
      pVVar5 = poly_CreateNode(v);
      poly_InclVertex((pPVar3->head).prev,pVVar5);
      v[0] = (iVar2 - iVar8) + pin->X;
      pVVar5 = poly_CreateNode(v);
      poly_InclVertex((pPVar3->head).prev,pVVar5);
      p = ContourToPoly(pPVar3);
      v[0] = pin->X + iVar7;
      v[1] = (pin->Y + iVar7) - iVar2;
      pPVar3 = poly_NewContour(v);
      if (pPVar3 != (PLINE *)0x0) {
        v[1] = (iVar2 - iVar7) + pin->Y;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        v[0] = iVar8 + pin->X;
        v[1] = (iVar2 - iVar8) + pin->Y;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        v[1] = (iVar8 + pin->Y) - iVar2;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        pPVar6 = ContourToPoly(pPVar3);
        p->f = pPVar6;
        pPVar6->b = p;
        v[0] = pin->X - iVar7;
        v[1] = (iVar2 - iVar7) + pin->Y;
        pPVar3 = poly_NewContour(v);
        if (pPVar3 != (PLINE *)0x0) {
          v[1] = (pin->Y + iVar7) - iVar2;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
          v[0] = pin->X - iVar8;
          v[1] = (iVar8 + pin->Y) - iVar2;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
          v[1] = (iVar2 - iVar8) + pin->Y;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
          pPVar6 = ContourToPoly(pPVar3);
          p->f->f = pPVar6;
          pPVar6->b = p->f;
          v[0] = (pin->X + iVar7) - iVar2;
          v[1] = pin->Y - iVar7;
          pPVar3 = poly_NewContour(v);
          if (pPVar3 != (PLINE *)0x0) {
            v[0] = pin->X + (iVar2 - iVar7);
            pVVar5 = poly_CreateNode(v);
            poly_InclVertex((pPVar3->head).prev,pVVar5);
            v[0] = (iVar2 - iVar8) + pin->X;
            v[1] = pin->Y - iVar8;
            pVVar5 = poly_CreateNode(v);
            poly_InclVertex((pPVar3->head).prev,pVVar5);
            v[0] = (iVar8 + pin->X) - iVar2;
            pVVar5 = poly_CreateNode(v);
            poly_InclVertex((pPVar3->head).prev,pVVar5);
LAB_080d103b:
            pPVar6 = ContourToPoly(pPVar3);
            p->f->f->f = pPVar6;
            pPVar6->f = p;
            pPVar6->b = p->f->f;
            p->b = pPVar6;
            goto LAB_080d0502;
          }
        }
      }
    }
  }
  else {
    if (style == 4) {
      iVar2 = pin->Clearance;
      iVar9 = pin->Thickness / 2;
      iVar8 = iVar2 + 3;
      if (-1 < iVar2) {
        iVar8 = iVar2;
      }
      iVar7 = (iVar8 >> 2) + iVar9;
      iVar8 = (int)ROUND((double)iVar9 - (double)iVar2 * pcb->ThermScale);
      iVar2 = iVar2 / 2;
      l.Point1.X = pin->X - iVar8;
      l.Point2.X = iVar8 + pin->X;
      l.Point1.Y = iVar7 + pin->Y;
      l.Point2.Y = l.Point1.Y;
      p = LinePoly(&l,iVar2);
      l.Point1.X = iVar7 + pin->X;
      l.Point1.Y = pin->Y - iVar8;
      l.Point2.Y = iVar8 + pin->Y;
      l.Point2.X = l.Point1.X;
      pPVar6 = LinePoly(&l,iVar2);
      iVar9 = pin->X;
      p->f = pPVar6;
      pPVar6->b = p;
      l.Point1.X = iVar9 - iVar8;
      l.Point1.Y = pin->Y - iVar7;
      l.Point2.X = iVar8 + iVar9;
      l.Point2.Y = l.Point1.Y;
      pPVar6 = LinePoly(&l,iVar2);
      p->f->f = pPVar6;
      pPVar6->b = p->f;
      l.Point1.X = pin->X - iVar7;
      l.Point1.Y = pin->Y - iVar8;
      l.Point2.Y = iVar8 + pin->Y;
      l.Point2.X = l.Point1.X;
      pPVar4 = LinePoly(&l,iVar2);
      p->f->f->f = pPVar4;
      pPVar6 = p->f->f;
      pPVar4->f = p;
      pPVar4->b = pPVar6;
      p->b = pPVar4;
      goto LAB_080d0502;
    }
    iVar8 = pin->Clearance;
    iVar2 = (int)ROUND((float)iVar8 * (float)pcb->ThermScale * 0.5);
    iVar9 = pin->Thickness;
    iVar7 = iVar2 * 2;
    if (style != 5) {
      iVar7 = iVar2;
    }
    iVar2 = iVar9 / 2;
    v[0] = iVar2 + pin->X;
    v[1] = iVar2 + pin->Y;
    pPVar3 = poly_NewContour(v);
    if (pPVar3 != (PLINE *)0x0) {
      v[1] = iVar7 + pin->Y;
      iVar8 = (iVar9 + iVar8) / 2;
      pVVar5 = poly_CreateNode(v);
      poly_InclVertex((pPVar3->head).prev,pVVar5);
      if (style == 2) {
        v[0] = iVar8 + pin->X;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
      }
      else {
        iVar9 = pin->Clearance;
        if (iVar9 < 0) {
          iVar9 = iVar9 + 3;
        }
        frac_circle(pPVar3,(iVar9 >> 2) + v[0],v[1],v,2);
      }
      v[1] = iVar2 + pin->Y;
      pVVar5 = poly_CreateNode(v);
      poly_InclVertex((pPVar3->head).prev,pVVar5);
      frac_circle(pPVar3,iVar2 + pin->X,iVar2 + pin->Y,v,4);
      v[0] = iVar7 + pin->X;
      pVVar5 = poly_CreateNode(v);
      poly_InclVertex((pPVar3->head).prev,pVVar5);
      if (style == 2) {
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        v[1] = iVar2 + pin->Y;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
      }
      else {
        iVar9 = pin->Clearance;
        if (iVar9 < 0) {
          iVar9 = iVar9 + 3;
        }
        frac_circle(pPVar3,v[0],v[1] - (iVar9 >> 2),v,2);
      }
      p = ContourToPoly(pPVar3);
      v[0] = iVar2 + pin->X;
      v[1] = pin->Y - iVar7;
      pPVar3 = poly_NewContour(v);
      if (pPVar3 != (PLINE *)0x0) {
        v[1] = pin->Y - iVar2;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        v[0] = iVar7 + pin->X;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        if (style == 2) {
          v[1] = pin->Y - iVar8;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
        }
        else {
          iVar9 = pin->Clearance;
          if (iVar9 < 0) {
            iVar9 = iVar9 + 3;
          }
          frac_circle(pPVar3,v[0],v[1] - (iVar9 >> 2),v,2);
        }
        v[0] = iVar2 + pin->X;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        frac_circle(pPVar3,iVar2 + pin->X,pin->Y - iVar2,v,4);
        v[1] = pin->Y - iVar7;
        pVVar5 = poly_CreateNode(v);
        poly_InclVertex((pPVar3->head).prev,pVVar5);
        if (style == 5) {
          iVar9 = pin->Clearance;
          if (iVar9 < 0) {
            iVar9 = iVar9 + 3;
          }
          frac_circle(pPVar3,v[0] - (iVar9 >> 2),v[1],v,2);
        }
        pPVar6 = ContourToPoly(pPVar3);
        p->f = pPVar6;
        pPVar6->b = p;
        v[0] = pin->X - iVar7;
        v[1] = pin->Y - iVar2;
        pPVar3 = poly_NewContour(v);
        if (pPVar3 != (PLINE *)0x0) {
          v[0] = pin->X - iVar2;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
          v[1] = pin->Y - iVar7;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
          if (style == 2) {
            v[0] = pin->X - iVar8;
            pVVar5 = poly_CreateNode(v);
            poly_InclVertex((pPVar3->head).prev,pVVar5);
          }
          else {
            iVar9 = pin->Clearance;
            if (iVar9 < 0) {
              iVar9 = iVar9 + 3;
            }
            frac_circle(pPVar3,v[0] - (iVar9 >> 2),v[1],v,2);
          }
          v[1] = pin->Y - iVar2;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
          frac_circle(pPVar3,pin->X - iVar2,pin->Y - iVar2,v,4);
          v[0] = pin->X - iVar7;
          pVVar5 = poly_CreateNode(v);
          poly_InclVertex((pPVar3->head).prev,pVVar5);
          if (style == 5) {
            frac_circle(pPVar3,v[0],pin->Clearance / 4 + v[1],v,2);
          }
          pPVar6 = ContourToPoly(pPVar3);
          p->f->f = pPVar6;
          pPVar6->b = p->f;
          v[1] = iVar8 + pin->Y;
          v[0] = pin->X - iVar7;
          pPVar3 = poly_NewContour(v);
          if (pPVar3 != (PLINE *)0x0) {
            v[0] = pin->X - iVar2;
            pVVar5 = poly_CreateNode(v);
            poly_InclVertex((pPVar3->head).prev,pVVar5);
            frac_circle(pPVar3,pin->X - iVar2,iVar2 + pin->Y,v,4);
            v[1] = iVar7 + pin->Y;
            pVVar5 = poly_CreateNode(v);
            poly_InclVertex((pPVar3->head).prev,pVVar5);
            if (style == 2) {
              v[0] = pin->X - iVar2;
              pVVar5 = poly_CreateNode(v);
              poly_InclVertex((pPVar3->head).prev,pVVar5);
              v[1] = iVar2 + pin->Y;
              pVVar5 = poly_CreateNode(v);
              poly_InclVertex((pPVar3->head).prev,pVVar5);
              v[0] = pin->X - iVar7;
              pVVar5 = poly_CreateNode(v);
              poly_InclVertex((pPVar3->head).prev,pVVar5);
            }
            else {
              iVar8 = pin->Clearance;
              if (iVar8 < 0) {
                iVar8 = iVar8 + 3;
              }
              frac_circle(pPVar3,(iVar8 >> 2) + v[0],v[1],v,2);
              v[1] = iVar2 + pin->Y;
              pVVar5 = poly_CreateNode(v);
              poly_InclVertex((pPVar3->head).prev,pVVar5);
              v[0] = pin->X - iVar7;
              pVVar5 = poly_CreateNode(v);
              poly_InclVertex((pPVar3->head).prev,pVVar5);
              if (style == 5) {
                frac_circle(pPVar3,v[0],pin->Clearance / 4 + v[1],v,2);
              }
            }
            goto LAB_080d103b;
          }
        }
      }
    }
  }
  p = (POLYAREA *)0x0;
LAB_080d0502:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return p;
}



// WARNING: Unknown calling convention

POLYAREA * ThermPoly(PCBTypePtr p,PinTypePtr pin,Cardinal laynum)

{
  int iVar1;
  uint uVar2;
  POLYAREA *pPVar3;
  POLYAREA *pPVar4;
  POLYAREA *arc;
  POLYAREA *pPVar5;
  POLYAREA *q;
  POLYAREA *pa;
  int iVar6;
  Cardinal style;
  uint style_00;
  int iVar7;
  BDimension w;
  int in_GS_OFFSET;
  POLYAREA *local_74;
  POLYAREA *local_70;
  POLYAREA *local_6c;
  POLYAREA *local_68;
  ArcType a;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  style = (int)(uint)(pin->Flags).t[laynum >> 1] >> (sbyte)((laynum & 1) << 2);
  style_00 = style & 0xf;
  if (style_00 != 3) {
    uVar2 = (pin->Flags).f;
    pcb = p;
    if ((uVar2 & 0x100) != 0) {
      pPVar4 = square_therm(pin,style_00);
      goto LAB_080d1423;
    }
    if ((uVar2 & 0x800) != 0) {
      iVar7 = pin->Clearance + pin->Thickness;
      iVar6 = (int)ROUND((float)pin->Clearance * (float)p->ThermScale * 0.5);
      local_6c = OctagonPoly(pin->X,pin->Y,iVar7);
      local_70 = OctagonPoly(pin->X,pin->Y,pin->Thickness);
      poly_Boolean_free(local_6c,local_70,&local_74,2);
      if (style_00 == 2) {
        local_6c = RectPoly(pin->X - iVar6,iVar6 + pin->X,pin->Y - iVar7,iVar7 + pin->Y);
        poly_Boolean_free(local_74,local_6c,&local_70,2);
        local_6c = RectPoly(pin->X - iVar7,iVar7 + pin->X,pin->Y - iVar6,iVar6 + pin->Y);
      }
      else {
        if (style_00 == 5) {
          iVar6 = pin->Thickness;
          local_6c = square_therm(pin,5);
          iVar6 = iVar6 / 2;
          pPVar4 = RectPoly(pin->X - iVar6,iVar6 + pin->X,pin->Y - iVar6,iVar6 + pin->Y);
          poly_Boolean_free(local_6c,pPVar4,&local_70,0);
          poly_Boolean_free(local_74,local_70,&local_6c,1);
          pPVar4 = local_6c;
          goto LAB_080d1423;
        }
        local_6c = diag_line(pin->X,pin->Y,iVar7,iVar6,'\x01');
        poly_Boolean_free(local_74,local_6c,&local_70,2);
        local_6c = diag_line(pin->X,pin->Y,iVar7,iVar6,'\0');
      }
      poly_Boolean_free(local_70,local_6c,&local_74,2);
      pPVar4 = local_74;
      goto LAB_080d1423;
    }
    if (style_00 - 1 < 2) {
      iVar7 = (pin->Thickness + pin->Clearance) / 2;
      iVar6 = (int)ROUND((float)pin->Clearance * (float)p->ThermScale * 0.5);
      pPVar4 = CirclePoly(pin->X,pin->Y,iVar7);
      local_68 = CirclePoly(pin->X,pin->Y,pin->Thickness / 2);
      poly_Boolean_free(pPVar4,local_68,&local_6c,2);
      if (style_00 == 2) {
        pPVar4 = RectPoly(pin->X - iVar7,iVar7 + pin->X,pin->Y - iVar6,iVar6 + pin->Y);
        poly_Boolean_free(local_6c,pPVar4,&local_68,2);
        pPVar4 = RectPoly(pin->X - iVar6,iVar6 + pin->X,pin->Y - iVar7,iVar7 + pin->Y);
      }
      else {
        pPVar4 = diag_line(pin->X,pin->Y,iVar7,iVar6,'\x01');
        poly_Boolean_free(local_6c,pPVar4,&local_68,2);
        pPVar4 = diag_line(pin->X,pin->Y,iVar7,iVar6,'\0');
      }
      poly_Boolean_free(local_68,pPVar4,&local_6c,2);
      pPVar4 = local_6c;
      goto LAB_080d1423;
    }
    a.X = pin->X;
    a.Y = pin->Y;
    iVar6 = pin->Clearance;
    a.Thickness = 1;
    iVar7 = iVar6 + 3;
    if (-1 < iVar6) {
      iVar7 = iVar6;
    }
    a.Width = (iVar7 >> 2) + pin->Thickness / 2;
    a.Clearance = iVar6 / 2;
    a.Height = a.Width;
    MakeFlags(0);
    iVar6 = 0x2d;
    if (style_00 == 4) {
      iVar6 = 0;
    }
    a.Delta = (long)ROUND(((pcb->ThermScale + pcb->ThermScale + 1.0) * (double)a.Clearance * 180.0)
                          / ((double)a.Width * -3.141592653589793) + 90.0);
    a.StartAngle = (iVar6 + 0x5a) - a.Delta / 2;
    pPVar4 = ArcPoly(&a,a.Clearance);
    if (pPVar4 == (POLYAREA *)0x0) goto LAB_080d1423;
    a.StartAngle = a.StartAngle + 0x5a;
    pPVar5 = ArcPoly(&a,a.Clearance);
    if (pPVar5 != (POLYAREA *)0x0) {
      pPVar4->f = pPVar5;
      pPVar5->b = pPVar4;
      a.StartAngle = a.StartAngle + 0x5a;
      local_68 = pPVar5;
      pPVar5 = ArcPoly(&a,a.Clearance);
      if (pPVar5 != (POLYAREA *)0x0) {
        a.StartAngle = a.StartAngle + 0x5a;
        pPVar4->f->f = pPVar5;
        pPVar5->b = pPVar4->f;
        local_68 = pPVar5;
        pPVar5 = ArcPoly(&a,a.Clearance);
        if (pPVar5 != (POLYAREA *)0x0) {
          pPVar4->f->f->f = pPVar5;
          pPVar3 = pPVar4->f->f;
          pPVar5->f = pPVar4;
          pPVar5->b = pPVar3;
          pPVar4->b = pPVar5;
          goto LAB_080d1423;
        }
      }
    }
  }
  pPVar4 = (POLYAREA *)0x0;
LAB_080d1423:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pPVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void RestoreUndoSerialNumber(void)

{
  Serial = SavedSerial;
  return;
}



// WARNING: Unknown calling convention

void SaveUndoSerialNumber(void)

{
  Bumped = '\0';
  SavedSerial = Serial;
  return;
}



// WARNING: Unknown calling convention

void LockUndo(void)

{
  Locked = '\x01';
  return;
}



// WARNING: Unknown calling convention

void UnlockUndo(void)

{
  Locked = '\0';
  return;
}



// WARNING: Unknown calling convention

Boolean Undoing(void)

{
  return Locked;
}



// WARNING: Unknown calling convention

UndoListTypePtr GetUndoSlot(int CommandType,int ID,int Kind)

{
  int type;
  int Type;
  size_t size;
  UndoListTypePtr ptr;
  UndoListTypePtr paVar1;
  uint Size;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  if (UndoMax <= UndoN) {
    UndoMax = UndoMax + 500;
    Size = UndoMax * 0x20;
    UndoList = (UndoListTypePtr)MyRealloc(UndoList,Size,"AddCommandToUndoList()");
    memset(UndoList + UndoN,0,16000);
    if (GetUndoSlot::limit <= Size && Size - GetUndoSlot::limit != 0) {
      GetUndoSlot::limit = (Size & 0xfff00000) + 0x100000;
      Message("Size of \'undo-list\' exceeds %li kb\n",Size >> 10);
    }
  }
  ptr = (UndoListTypePtr)(UndoN * 0x20);
  paVar1 = (UndoListTypePtr)((int)&UndoList->Serial + (int)&ptr->Serial);
  if (RedoN != 0) {
    while( true ) {
      if (paVar1->Type == 1) {
        SaveFree((paVar1->Data).NetlistChange.old);
      }
      else if ((paVar1->Type == 4) &&
              (Type = SearchObjectByID(RemoveList,local_20,&local_24,&local_28,paVar1->ID,
                                       paVar1->Kind), Type != 0)) {
        DestroyObject(RemoveList,Type,local_20[0],local_24,local_28);
      }
      RedoN = RedoN - 1;
      if (RedoN == 0) break;
      paVar1 = paVar1 + 1;
    }
    paVar1 = UndoList + UndoN;
    RedoN = 0;
  }
  UndoN = UndoN + 1;
  paVar1->Type = CommandType;
  paVar1->Kind = Kind;
  paVar1->ID = ID;
  paVar1->Serial = Serial;
  return paVar1;
}



// WARNING: Unknown calling convention

void AddLayerChangeToUndoList(int old_index,int new_index)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked != '\0') {
    return;
  }
  paVar1 = GetUndoSlot(0x8000,0,0);
  (paVar1->Data).LayerChange.old_index = old_index;
  (paVar1->Data).LayerChange.new_index = new_index;
  return;
}



// WARNING: Unknown calling convention

void AddObjectToChangeAnglesUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked == '\0') {
    paVar1 = GetUndoSlot(0x4000,*(int *)((int)Ptr3 + 0x10),Type);
    (paVar1->Data).ChangeName.Name = *(char **)((int)Ptr3 + 0x3c);
    (paVar1->Data).Move.DY = *(LocationType *)((int)Ptr3 + 0x40);
  }
  return;
}



// WARNING: Unknown calling convention

void AddObjectTo2ndSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr paVar1;
  UndoListTypePtr undo;
  
  if ((Locked == '\0') &&
     ((paVar1 = GetUndoSlot(0x400,*(int *)((int)ptr2 + 0x10),Type), Type == 1 || (Type == 0x100))))
  {
    (paVar1->Data).ChangeName.Name = *(char **)((int)ptr2 + 0x30);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void AddObjectToMaskSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr paVar1;
  UndoListTypePtr undo;
  
  if (Locked != '\0') {
    return;
  }
  paVar1 = GetUndoSlot(0x2000,*(int *)((int)ptr2 + 0x10),Type);
  if (Type != 0x100) {
    if (Type == 0x200) {
      (paVar1->Data).ChangeName.Name = *(char **)((int)ptr2 + 0x54);
      return;
    }
    if (Type != 1) {
      return;
    }
  }
  (paVar1->Data).ChangeName.Name = *(char **)((int)ptr2 + 0x2c);
  return;
}



// WARNING: Unknown calling convention

void AddObjectToClearSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr paVar1;
  UndoListTypePtr undo;
  
  if (Locked != '\0') {
    return;
  }
  paVar1 = GetUndoSlot(0x1000,*(int *)((int)ptr2 + 0x10),Type);
  if (Type != 0x100) {
    if (Type < 0x101) {
      if ((Type != 1) && (Type != 4)) {
        return;
      }
    }
    else if ((Type != 0x200) && (Type != 0x4000)) {
      return;
    }
  }
  (paVar1->Data).ChangeName.Name = *(char **)((int)ptr2 + 0x28);
  return;
}



// WARNING: Unknown calling convention

void AddObjectToSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr paVar1;
  UndoListTypePtr undo;
  
  if (Locked != '\0') {
    return;
  }
  paVar1 = GetUndoSlot(0x200,*(int *)((int)ptr2 + 0x10),Type);
  if (Type != 0x200) {
    if (Type < 0x201) {
      if (Type != 4) {
        if (Type < 5) {
          if (Type != 1) {
            return;
          }
        }
        else if ((Type != 0x10) && (Type != 0x100)) {
          return;
        }
      }
    }
    else if (Type != 0x2000) {
      if (Type < 0x2001) {
        if (Type != 0x400) {
          return;
        }
      }
      else if ((Type != 0x4000) && (Type != 0x8000)) {
        return;
      }
    }
  }
  (paVar1->Data).ChangeName.Name = *(char **)((int)ptr2 + 0x24);
  return;
}



// WARNING: Unknown calling convention

void AddObjectToFlagUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked == '\0') {
    paVar1 = GetUndoSlot(0x100,*(int *)((int)Ptr2 + 0x10),Type);
    (paVar1->Data).ChangeName.Name = *(char **)((int)Ptr2 + 0x14);
    (paVar1->Data).Move.DY = *(LocationType *)((int)Ptr2 + 0x18);
    (paVar1->Data).RemovedPoint.ID = *(int *)((int)Ptr2 + 0x1c);
  }
  return;
}



// WARNING: Unknown calling convention

void AddObjectToChangeNameUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3,char *OldName)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked != '\0') {
    return;
  }
  paVar1 = GetUndoSlot(1,*(int *)((int)Ptr3 + 0x10),Type);
  (paVar1->Data).NetlistChange.old = (LibraryTypePtr)OldName;
  return;
}



// WARNING: Unknown calling convention

void AddObjectToMoveUndoList
               (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked != '\0') {
    return;
  }
  paVar1 = GetUndoSlot(2,*(int *)((int)Ptr3 + 0x10),Type);
  (paVar1->Data).Move.DX = DX;
  (paVar1->Data).Move.DY = DY;
  return;
}



// WARNING: Unknown calling convention

void AddObjectToInsertPointUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Locked != '\0') {
    return;
  }
  GetUndoSlot(0x10,*(int *)((int)Ptr3 + 0x10),Type);
  return;
}



// WARNING: Unknown calling convention

void AddObjectToRemovePointUndoList(int Type,void *Ptr1,void *Ptr2,Cardinal index)

{
  char *pcVar1;
  UndoListTypePtr undo;
  UndoListTypePtr paVar2;
  char **ppcVar3;
  
  if ((Locked == '\0') && (Type == 0x800)) {
    paVar2 = GetUndoSlot(8,*(int *)((int)Ptr2 + 0x10),8);
    ppcVar3 = (char **)(index * 0x14 + *(int *)((int)Ptr2 + 0x38));
    (paVar2->Data).ChangeName.Name = *ppcVar3;
    (paVar2->Data).Move.DY = (LocationType)ppcVar3[1];
    pcVar1 = ppcVar3[4];
    (paVar2->Data).RemovedPoint.Index = index;
    (paVar2->Data).RemovedPoint.ID = (int)pcVar1;
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void AddObjectToRotateUndoList
               (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType CenterX,LocationType CenterY,
               BYTE Steps)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked == '\0') {
    paVar1 = GetUndoSlot(0x20,*(int *)((int)Ptr3 + 0x10),Type);
    (paVar1->Data).Move.DX = CenterX;
    (paVar1->Data).Rotate.Steps = Steps;
    (paVar1->Data).Move.DY = CenterY;
  }
  return;
}



// WARNING: Unknown calling convention

void AddObjectToMirrorUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType yoff)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked != '\0') {
    return;
  }
  paVar1 = GetUndoSlot(0x800,*(int *)((int)Ptr3 + 0x10),Type);
  (paVar1->Data).Move.DY = yoff;
  return;
}



// WARNING: Unknown calling convention

void AddObjectToClearPolyUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3,Boolean clear)

{
  UndoListTypePtr undo;
  UndoListTypePtr paVar1;
  
  if (Locked == '\0') {
    paVar1 = GetUndoSlot(0x10000,*(int *)((int)Ptr3 + 0x10),Type);
    (paVar1->Data).ClearPoly.Clear = clear;
    (paVar1->Data).ClearPoly.Layer = (LayerTypePtr)Ptr1;
  }
  return;
}



// WARNING: Unknown calling convention

void AddNetlistLibToUndoList(LibraryTypePtr lib)

{
  Cardinal CVar1;
  UndoListTypePtr paVar2;
  LibraryTypePtr pLVar3;
  LibraryMenuTypePtr paVar4;
  undefined4 uVar5;
  void *pvVar6;
  int iVar7;
  int iVar8;
  LibraryMenuTypePtr paVar9;
  UndoListTypePtr undo;
  int iVar10;
  int iVar11;
  LibraryMenuTypePtr paVar12;
  uint local_2c;
  uint local_28;
  
  if (Locked == '\0') {
    paVar2 = GetUndoSlot(0x20000,0,0);
    (paVar2->Data).NetlistChange.lib = lib;
    pLVar3 = (LibraryTypePtr)calloc(1,4);
    (paVar2->Data).NetlistChange.old = pLVar3;
    pLVar3->MenuN = lib->MenuN;
    CVar1 = lib->MenuMax;
    pLVar3->MenuMax = CVar1;
    paVar4 = (LibraryMenuTypePtr)calloc(1,CVar1 * 0x1c);
    pLVar3->Menu = paVar4;
    if (paVar4 == (LibraryMenuTypePtr)0x0) {
LAB_080d2266:
      __fprintf_chk(stderr,1,"malloc() failed in %s\n","AddNetlistLibToUndoList");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    if (lib->MenuN != 0) {
      iVar11 = 0;
      local_2c = 0;
      while( true ) {
        paVar9 = lib->Menu;
        *(undefined4 *)((int)&paVar4->EntryN + iVar11) =
             *(undefined4 *)((int)&paVar9->EntryN + iVar11);
        iVar8 = *(int *)((int)&paVar9->Name + iVar11);
        *(undefined4 *)((int)&paVar4->EntryMax + iVar11) =
             *(undefined4 *)((int)&paVar9->EntryMax + iVar11);
        uVar5 = 0;
        paVar12 = paVar4;
        if (iVar8 != 0) {
          uVar5 = __strdup(iVar8);
          paVar9 = lib->Menu;
          paVar12 = pLVar3->Menu;
        }
        iVar8 = *(int *)((int)&paVar9->directory + iVar11);
        *(undefined4 *)((int)&paVar4->Name + iVar11) = uVar5;
        uVar5 = 0;
        paVar4 = paVar12;
        if (iVar8 != 0) {
          uVar5 = __strdup(iVar8);
          paVar9 = lib->Menu;
          paVar4 = pLVar3->Menu;
        }
        iVar8 = *(int *)((int)&paVar9->Style + iVar11);
        *(undefined4 *)((int)&paVar12->directory + iVar11) = uVar5;
        uVar5 = 0;
        if (iVar8 != 0) {
          uVar5 = __strdup(iVar8);
        }
        *(undefined4 *)((int)&paVar4->Style + iVar11) = uVar5;
        paVar4 = pLVar3->Menu;
        pvVar6 = calloc(1,*(int *)((int)&paVar4->EntryMax + iVar11) * 0x18);
        paVar12 = pLVar3->Menu;
        *(void **)((int)&paVar4->Entry + iVar11) = pvVar6;
        iVar8 = *(int *)((int)&paVar12->Entry + iVar11);
        if (iVar8 == 0) goto LAB_080d2266;
        iVar10 = 0;
        local_28 = 0;
        iVar7 = (int)&lib->Menu->Name + iVar11;
        if (*(int *)(iVar7 + 0xc) != 0) {
          while( true ) {
            iVar7 = *(int *)(*(int *)(iVar7 + 0x14) + iVar10);
            uVar5 = 0;
            if (iVar7 != 0) {
              uVar5 = __strdup(iVar7);
              paVar12 = pLVar3->Menu;
            }
            *(undefined4 *)(iVar8 + iVar10) = uVar5;
            iVar8 = *(int *)((int)&paVar12->Entry + iVar11);
            paVar4 = lib->Menu;
            iVar7 = *(int *)(*(int *)((int)&paVar4->Entry + iVar11) + 4 + iVar10);
            uVar5 = 0;
            if (iVar7 != 0) {
              uVar5 = __strdup(iVar7);
              paVar4 = lib->Menu;
              paVar12 = pLVar3->Menu;
            }
            *(undefined4 *)(iVar8 + 4 + iVar10) = uVar5;
            iVar8 = *(int *)((int)&paVar12->Entry + iVar11);
            iVar7 = *(int *)(*(int *)((int)&paVar4->Entry + iVar11) + 8 + iVar10);
            uVar5 = 0;
            if (iVar7 != 0) {
              uVar5 = __strdup(iVar7);
              paVar4 = lib->Menu;
              paVar12 = pLVar3->Menu;
            }
            *(undefined4 *)(iVar8 + 8 + iVar10) = uVar5;
            iVar8 = *(int *)((int)&paVar12->Entry + iVar11);
            iVar7 = *(int *)(*(int *)((int)&paVar4->Entry + iVar11) + 0xc + iVar10);
            uVar5 = 0;
            if (iVar7 != 0) {
              uVar5 = __strdup(iVar7);
              paVar4 = lib->Menu;
              paVar12 = pLVar3->Menu;
            }
            *(undefined4 *)(iVar8 + 0xc + iVar10) = uVar5;
            iVar8 = *(int *)((int)&paVar12->Entry + iVar11);
            iVar7 = *(int *)(*(int *)((int)&paVar4->Entry + iVar11) + 0x10 + iVar10);
            uVar5 = 0;
            if (iVar7 != 0) {
              uVar5 = __strdup(iVar7);
              paVar4 = lib->Menu;
              paVar12 = pLVar3->Menu;
            }
            iVar7 = *(int *)((int)&paVar12->Entry + iVar11);
            *(undefined4 *)(iVar8 + 0x10 + iVar10) = uVar5;
            iVar8 = *(int *)(*(int *)((int)&paVar4->Entry + iVar11) + 0x14 + iVar10);
            uVar5 = 0;
            if (iVar8 != 0) {
              uVar5 = __strdup(iVar8);
            }
            *(undefined4 *)(iVar7 + 0x14 + iVar10) = uVar5;
            iVar10 = iVar10 + 0x18;
            local_28 = local_28 + 1;
            iVar7 = (int)&lib->Menu->Name + iVar11;
            if (*(uint *)(iVar7 + 0xc) < local_28 || *(uint *)(iVar7 + 0xc) == local_28) break;
            paVar12 = pLVar3->Menu;
            iVar8 = *(int *)((int)&paVar12->Entry + iVar11);
          }
        }
        iVar11 = iVar11 + 0x1c;
        local_2c = local_2c + 1;
        if (lib->MenuN < local_2c || lib->MenuN == local_2c) break;
        paVar4 = pLVar3->Menu;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void AddObjectToCreateUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Locked == '\0') {
    GetUndoSlot(0x40,*(int *)((int)Ptr3 + 0x10),Type);
  }
  ClearFromPolygon((DataType *)PCB->Data,Type,Ptr1,Ptr2);
  return;
}



// WARNING: Unknown calling convention

void AddObjectToMoveToLayerUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  UndoListTypePtr paVar1;
  int iVar2;
  UndoListTypePtr undo;
  
  if (Locked == '\0') {
    paVar1 = GetUndoSlot(0x80,*(int *)((int)Ptr3 + 0x10),Type);
    iVar2 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1);
    (paVar1->Data).LayerChange.old_index = iVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void MoveObjectToRemoveUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Locked == '\0') {
    if (RemoveList == (DataTypePtr)0x0) {
      RemoveList = CreateNewBuffer();
    }
    GetUndoSlot(4,*(int *)((int)Ptr3 + 0x10),Type);
    MoveObjectToBuffer(RemoveList,PCB->Data,Type,Ptr1,Ptr2,Ptr3);
  }
  return;
}



// WARNING: Unknown calling convention

void ClearUndoList(Boolean Force)

{
  int iVar1;
  UndoListTypePtr undo;
  UndoListTypePtr paVar2;
  
  if (UndoN == 0) {
    Serial = 1;
    return;
  }
  paVar2 = UndoList;
  if (Force == '\0') {
    iVar1 = (*gui->confirm_dialog)("OK to clear \'undo\' buffer?",0);
    if (iVar1 == 0) {
      Serial = 1;
      return;
    }
    paVar2 = UndoList;
    if (UndoN == 0) goto LAB_080d242e;
  }
  while( true ) {
    if (paVar2->Type == 1) {
      SaveFree((paVar2->Data).NetlistChange.old);
    }
    UndoN = UndoN - 1;
    if (UndoN == 0) break;
    paVar2 = paVar2 + 1;
  }
  UndoN = 0;
LAB_080d242e:
  SaveFree(UndoList);
  UndoList = (UndoListTypePtr)0x0;
  if (RemoveList != (DataTypePtr)0x0) {
    FreeDataMemory(RemoveList);
    free(RemoveList);
    RemoveList = (DataTypePtr)0x0;
  }
  UndoMax = 0;
  RedoN = 0;
  UndoN = 0;
  Serial = 1;
  return;
}



// WARNING: Unknown calling convention

void IncrementUndoSerialNumber(void)

{
  if (((Locked == '\0') && (UndoN != 0)) && (UndoList[UndoN - 1].Serial == Serial)) {
    Serial = UndoList[UndoN - 1].Serial + 1;
    Bumped = '\x01';
    SetChangedFlag('\x01');
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int PerformUndo(UndoListTypePtr ptr)

{
  LocationType *pLVar1;
  int iVar2;
  uchar uVar3;
  uchar uVar4;
  uchar uVar5;
  BYTE BVar6;
  uchar uVar7;
  uchar uVar8;
  uchar uVar9;
  uchar uVar10;
  LayerTypePtr pLVar11;
  DataTypePtr paVar12;
  LocationType LVar13;
  PointTypePtr pPVar14;
  PointTypePtr pPVar15;
  PointTypePtr pPVar16;
  int type;
  Cardinal CVar17;
  Cardinal n;
  LibraryTypePtr pLVar18;
  int tmp;
  uint uVar19;
  int iVar20;
  void **ppvVar21;
  void *ptr2_1;
  int iVar22;
  int iVar23;
  ElementTypePtr element;
  BDimension swap_2;
  FlagType *pFVar24;
  void *pvVar25;
  BDimension swap;
  char *pcVar26;
  FlagType *pFVar27;
  int in_GS_OFFSET;
  bool bVar28;
  byte bVar29;
  void *local_90;
  char *local_7c;
  void *local_78;
  void *ptr1;
  void *ptr2;
  void *ptr3;
  PointTypePtr local_44;
  PolygonTypePtr local_40;
  LayerTypePtr local_3c;
  FlagType f2;
  FlagType f1;
  
  bVar29 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  iVar23 = ptr->Type;
  if (iVar23 == 0x100) {
    iVar23 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
    pvVar25 = ptr2;
    if (iVar23 == 0) {
      Message("hace Internal error: Can\'t find ID %d type %08x\n");
      flags_to_string((ptr->Data).Flags,0);
      Message("for UndoFlag Operation. Previous flags: %s\n");
      iVar22 = 0;
      goto LAB_080d27c2;
    }
    uVar19 = *(uint *)((int)ptr2 + 0x14);
    if ((uVar19 & 0x2000) == 0) {
      uVar3 = *(uchar *)((int)ptr2 + 0x1f);
      uVar4 = *(uchar *)((int)ptr2 + 0x1e);
      uVar5 = *(uchar *)((int)ptr2 + 0x1d);
      BVar6 = *(BYTE *)((int)ptr2 + 0x1c);
      uVar7 = *(uchar *)((int)ptr2 + 0x1b);
      uVar8 = *(uchar *)((int)ptr2 + 0x1a);
      uVar9 = *(uchar *)((int)ptr2 + 0x19);
      uVar10 = *(uchar *)((int)ptr2 + 0x18);
      MaskFlags(*(FlagType *)((int)ptr2 + 0x14),0xfffff683);
      MaskFlags((ptr->Data).Flags,0xfffff683);
      iVar22 = 0xc;
      bVar28 = &stack0x00000000 == (undefined *)0xbc;
      pFVar24 = &f1;
      pFVar27 = &f2;
      do {
        if (iVar22 == 0) break;
        iVar22 = iVar22 + -1;
        bVar28 = *(char *)&pFVar24->f == *(char *)&pFVar27->f;
        pFVar24 = (FlagType *)((int)pFVar24 + (uint)bVar29 * -2 + 1);
        pFVar27 = (FlagType *)((int)pFVar27 + (uint)bVar29 * -2 + 1);
      } while (bVar28);
      if (bVar28) {
        *(char **)((int)pvVar25 + 0x14) = (ptr->Data).ChangeName.Name;
        *(LocationType *)((int)pvVar25 + 0x18) = (ptr->Data).Move.DY;
        *(int *)((int)pvVar25 + 0x1c) = (ptr->Data).RemovedPoint.ID;
        (ptr->Data).Flags.t[7] = uVar3;
        (ptr->Data).Flags.t[6] = uVar4;
        (ptr->Data).Flags.t[5] = uVar5;
        (ptr->Data).Rotate.Steps = BVar6;
        (ptr->Data).Flags.t[3] = uVar7;
        (ptr->Data).Flags.t[2] = uVar8;
        (ptr->Data).Flags.t[1] = uVar9;
        iVar22 = 0x100;
        (ptr->Data).Flags.t[0] = uVar10;
        (ptr->Data).Flags.f = uVar19;
      }
      else {
        if (andDraw != '\0') {
          EraseObject(iVar23,ptr1,ptr2);
        }
        *(char **)((int)pvVar25 + 0x14) = (ptr->Data).ChangeName.Name;
        *(LocationType *)((int)pvVar25 + 0x18) = (ptr->Data).Move.DY;
        *(int *)((int)pvVar25 + 0x1c) = (ptr->Data).RemovedPoint.ID;
        (ptr->Data).Flags.t[7] = uVar3;
        (ptr->Data).Flags.t[6] = uVar4;
        (ptr->Data).Flags.t[5] = uVar5;
        (ptr->Data).Rotate.Steps = BVar6;
        (ptr->Data).Flags.t[3] = uVar7;
        (ptr->Data).Flags.t[2] = uVar8;
        (ptr->Data).Flags.t[1] = uVar9;
        (ptr->Data).Flags.t[0] = uVar10;
        iVar22 = 0x100;
        (ptr->Data).Flags.f = uVar19;
        if (andDraw != '\0') {
          DrawObject(iVar23,ptr1,ptr2,0);
          iVar22 = 0x100;
        }
      }
      goto LAB_080d27c2;
    }
  }
  else if (iVar23 < 0x101) {
    if (iVar23 == 8) {
      iVar23 = SearchObjectByID(PCB->Data,&local_3c,&local_40,&ptr3,ptr->ID,ptr->Kind);
      if ((iVar23 == 8) && ((*(byte *)((int)&(local_40->Flags).f + 1) & 0x20) == 0)) {
        if ((andDraw != '\0') && (local_3c->On != '\0')) {
          ErasePolygon(local_40);
        }
        InsertPointIntoObject
                  (8,local_3c,local_40,&(ptr->Data).RemovedPoint.Index,(ptr->Data).Move.DX,
                   (ptr->Data).Move.DY,'\x01');
        bVar28 = andDraw != '\0';
        local_40->Points[(ptr->Data).RemovedPoint.Index].ID = (ptr->Data).RemovedPoint.ID;
        if ((bVar28) && (local_3c->On != '\0')) {
          DrawPolygon(local_3c,local_40,0);
        }
        iVar23 = (ptr->Data).RemovedPoint.ID;
        ptr->Type = 0x10;
        ptr->Kind = 0x800;
        ptr->ID = iVar23;
        iVar22 = 8;
        goto LAB_080d27c2;
      }
    }
    else if (iVar23 < 9) {
      if (iVar23 == 2) {
        iVar23 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
        if ((iVar23 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
          MoveObject(iVar23,ptr1,ptr2,ptr3,-(ptr->Data).Move.DX,-(ptr->Data).Move.DY);
          iVar22 = 2;
          (ptr->Data).Move.DX = -(ptr->Data).Move.DX;
          pLVar1 = &(ptr->Data).Move.DY;
          *pLVar1 = -*pLVar1;
          goto LAB_080d27c2;
        }
      }
      else if (iVar23 == 4) {
        uVar19 = SearchObjectByID(RemoveList,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
        pvVar25 = ptr2;
        if (uVar19 != 0) {
          if (andDraw != '\0') {
            if ((uVar19 & 0x401c) == 0) {
              DrawObject(uVar19,ptr3,ptr2,0);
            }
            else {
              paVar12 = PCB->Data;
              iVar23 = GetLayerNumber(RemoveList,(LayerTypePtr)ptr3);
              DrawObject(uVar19,paVar12->Layer + iVar23,pvVar25,0);
            }
          }
          MoveObjectToBuffer(PCB->Data,RemoveList,uVar19,ptr3,ptr2,ptr1);
          iVar22 = 4;
          ptr->Type = 0x40;
          goto LAB_080d27c2;
        }
      }
      else if (((iVar23 == 1) &&
               (iVar23 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind),
               iVar23 != 0)) && ((*(byte *)((int)ptr3 + 0x15) & 0x20) == 0)) {
        pLVar18 = (LibraryTypePtr)
                  ChangeObjectName(iVar23,ptr1,ptr2,ptr3,(char *)(ptr->Data).NetlistChange.old);
        (ptr->Data).NetlistChange.old = pLVar18;
        iVar22 = 1;
        goto LAB_080d27c2;
      }
    }
    else if (iVar23 == 0x20) {
      iVar23 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
      if ((iVar23 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
        RotateObject(iVar23,ptr3,ptr2,ptr1,(ptr->Data).Move.DX,(ptr->Data).Move.DY,
                     4 - (ptr->Data).Rotate.Steps & 3);
        (ptr->Data).Rotate.Steps = 4 - (ptr->Data).Rotate.Steps & 3;
        iVar22 = 0x20;
        goto LAB_080d27c2;
      }
    }
    else if (iVar23 < 0x21) {
      if (((iVar23 == 0x10) &&
          (iVar23 = SearchObjectByID(PCB->Data,&local_3c,&local_40,&local_44,ptr->ID,ptr->Kind),
          iVar23 == 0x800)) && ((*(byte *)((int)&(local_40->Flags).f + 1) & 0x20) == 0)) {
        if ((andDraw != '\0') && (local_3c->On != '\0')) {
          ErasePolygon(local_40);
        }
        (ptr->Data).ChangeName.Name = (char *)local_44->X;
        LVar13 = local_44->Y;
        ptr->Kind = 8;
        ptr->Type = 8;
        (ptr->Data).Move.DY = LVar13;
        (ptr->Data).RemovedPoint.ID = local_44->ID;
        ptr->ID = local_40->ID;
        CVar17 = local_40->PointN - 1;
        if (CVar17 != 0xffffffff) {
          pPVar16 = local_40->Points + (local_40->PointN - 2);
          pPVar15 = local_40->Points + CVar17;
          while (pPVar14 = pPVar16, pPVar15 != local_44) {
            CVar17 = CVar17 - 1;
            if (CVar17 == 0xffffffff) goto LAB_080d29ee;
            pPVar16 = pPVar14 + -1;
            pPVar15 = pPVar14;
          }
          (ptr->Data).RemovedPoint.Index = CVar17;
        }
LAB_080d29ee:
        DestroyObject(PCB->Data,0x800,local_3c,local_40,local_44);
        if ((andDraw == '\0') || (local_3c->On == '\0')) {
          iVar22 = 0x10;
        }
        else {
          DrawPolygon(local_3c,local_40,0);
          iVar22 = 0x10;
        }
        goto LAB_080d27c2;
      }
    }
    else if (iVar23 == 0x40) {
      iVar23 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
      if ((iVar23 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
        if (RemoveList == (DataTypePtr)0x0) {
          RemoveList = CreateNewBuffer();
        }
        if (andDraw != '\0') {
          EraseObject(iVar23,ptr3,ptr2);
        }
        MoveObjectToBuffer(RemoveList,PCB->Data,iVar23,ptr3,ptr2,ptr1);
        iVar22 = 0x40;
        ptr->Type = 4;
        goto LAB_080d27c2;
      }
    }
    else if (((iVar23 == 0x80) &&
             (iVar23 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind), iVar23 != 0)
             ) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
      iVar20 = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr3);
      MoveObjectToLayer(iVar23,ptr3,ptr2,ptr1,PCB->Data->Layer + (ptr->Data).Move.DX,'\x01');
      iVar22 = 0x80;
      (ptr->Data).LayerChange.old_index = iVar20;
      goto LAB_080d27c2;
    }
  }
  else if (iVar23 == 0x2000) {
    uVar19 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
    if (((uVar19 & 0x301) != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
      if (uVar19 == 0x200) {
        pcVar26 = *(char **)((int)ptr2 + 0x54);
      }
      else {
        pcVar26 = *(char **)((int)ptr2 + 0x2c);
      }
      if (andDraw != '\0') {
        EraseObject(uVar19,ptr1,ptr2);
      }
      if (uVar19 == 0x200) {
        *(char **)((int)ptr2 + 0x54) = (ptr->Data).ChangeName.Name;
      }
      else {
        *(char **)((int)ptr2 + 0x2c) = (ptr->Data).ChangeName.Name;
      }
      (ptr->Data).ChangeName.Name = pcVar26;
      iVar22 = 0x2000;
      if (andDraw != '\0') {
        DrawObject(uVar19,ptr1,ptr2,0);
        iVar22 = 0x2000;
      }
      goto LAB_080d27c2;
    }
  }
  else if (iVar23 < 0x2001) {
    if (iVar23 == 0x400) {
      iVar23 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
      if ((iVar23 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
        pcVar26 = *(char **)((int)ptr2 + 0x30);
        if (andDraw != '\0') {
          EraseObject(iVar23,ptr3,ptr2);
        }
        *(char **)((int)ptr2 + 0x30) = (ptr->Data).ChangeName.Name;
        (ptr->Data).ChangeName.Name = pcVar26;
        DrawObject(iVar23,ptr3,ptr2,0);
        iVar22 = 0x400;
        goto LAB_080d27c2;
      }
    }
    else if (iVar23 < 0x401) {
      if (((iVar23 == 0x200) &&
          (iVar23 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind), iVar23 != 0))
         && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
        pcVar26 = *(char **)((int)ptr2 + 0x24);
        RestoreToPolygon((DataType *)PCB->Data,iVar23,ptr3,ptr2);
        if (andDraw != '\0') {
          EraseObject(iVar23,ptr3,ptr2);
        }
        *(char **)((int)ptr2 + 0x24) = (ptr->Data).ChangeName.Name;
        (ptr->Data).ChangeName.Name = pcVar26;
        ClearFromPolygon((DataType *)PCB->Data,iVar23,ptr3,ptr2);
        iVar22 = 0x200;
        if (andDraw != '\0') {
          DrawObject(iVar23,ptr3,ptr2,0);
          iVar22 = 0x200;
        }
        goto LAB_080d27c2;
      }
    }
    else if (iVar23 == 0x800) {
      iVar23 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
      if (iVar23 != 2) {
        Message("hace Internal error: UndoMirror on object type %d\n");
        iVar22 = 0;
        goto LAB_080d27c2;
      }
      if ((*(byte *)((int)ptr3 + 0x15) & 0x20) == 0) {
        if (andDraw != '\0') {
          EraseElement((ElementTypePtr)ptr3);
        }
        MirrorElementCoordinates(PCB->Data,(ElementTypePtr)ptr3,(ptr->Data).Move.DY);
        iVar22 = 0x800;
        if (andDraw != '\0') {
          DrawElement((ElementTypePtr)ptr3,0);
          iVar22 = 0x800;
        }
        goto LAB_080d27c2;
      }
    }
    else if (((iVar23 == 0x1000) &&
             (iVar23 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind), iVar23 != 0)
             ) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
      pcVar26 = *(char **)((int)ptr2 + 0x28);
      RestoreToPolygon((DataType *)PCB->Data,iVar23,ptr1,ptr2);
      if (andDraw != '\0') {
        EraseObject(iVar23,ptr1,ptr2);
      }
      *(char **)((int)ptr2 + 0x28) = (ptr->Data).ChangeName.Name;
      ClearFromPolygon((DataType *)PCB->Data,iVar23,ptr1,ptr2);
      iVar22 = 0x1000;
      (ptr->Data).ChangeName.Name = pcVar26;
      if (andDraw != '\0') {
        DrawObject(iVar23,ptr1,ptr2,0);
        iVar22 = 0x1000;
      }
      goto LAB_080d27c2;
    }
  }
  else if (iVar23 == 0x8000) {
    iVar23 = (ptr->Data).LayerChange.old_index;
    iVar22 = (ptr->Data).LayerChange.new_index;
    (ptr->Data).LayerChange.new_index = iVar23;
    (ptr->Data).LayerChange.old_index = iVar22;
    iVar23 = MoveLayer(iVar22,iVar23);
    iVar22 = 0x8000;
    if (iVar23 == 0) goto LAB_080d27c2;
  }
  else if (iVar23 < 0x8001) {
    if (((iVar23 == 0x4000) &&
        (iVar23 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind), pvVar25 = ptr3,
        iVar23 == 0x4000)) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
      r_delete_entry(*(rtree_t **)((int)ptr3 + 0x40),(BoxType *)ptr2);
      pcVar26 = *(char **)((int)ptr2 + 0x3c);
      LVar13 = *(LocationType *)((int)ptr2 + 0x40);
      if (andDraw != '\0') {
        EraseObject(0x4000,pvVar25,ptr2);
      }
      *(char **)((int)ptr2 + 0x3c) = (ptr->Data).ChangeName.Name;
      *(LocationType *)((int)ptr2 + 0x40) = (ptr->Data).Move.DY;
      SetArcBoundingBox((ArcTypePtr)ptr2);
      r_insert_entry(*(rtree_t **)((int)pvVar25 + 0x40),(BoxType *)ptr2,0);
      (ptr->Data).ChangeName.Name = pcVar26;
      (ptr->Data).Move.DY = LVar13;
      DrawObject(0x4000,ptr3,ptr2,0);
      iVar22 = 0x4000;
      goto LAB_080d27c2;
    }
  }
  else if (iVar23 == 0x10000) {
    iVar23 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
    if (iVar23 != 0) {
      if ((ptr->Data).ClearPoly.Clear == '\0') {
        ClearFromPolygon((DataType *)PCB->Data,iVar23,(ptr->Data).ClearPoly.Layer,ptr3);
      }
      else {
        RestoreToPolygon((DataType *)PCB->Data,iVar23,(ptr->Data).ClearPoly.Layer,ptr3);
      }
      iVar22 = 0x10000;
      (ptr->Data).ClearPoly.Clear = (ptr->Data).ClearPoly.Clear == '\0';
      goto LAB_080d27c2;
    }
  }
  else if (iVar23 == 0x20000) {
    pLVar11 = (ptr->Data).ClearPoly.Layer;
    pLVar18 = (ptr->Data).NetlistChange.old;
    if (pLVar11->Name == (char *)0x0) {
      pvVar25 = (void *)pLVar11->TextN;
    }
    else {
      local_7c = (char *)0x0;
      local_90 = (void *)pLVar11->TextN;
      iVar23 = 0;
      pvVar25 = local_90;
      do {
        ppvVar21 = (void **)((int)local_90 + iVar23);
        if (*ppvVar21 != (void *)0x0) {
          free(*ppvVar21);
          local_90 = (void *)pLVar11->TextN;
          ppvVar21 = (void **)((int)local_90 + iVar23);
          pvVar25 = local_90;
        }
        if (ppvVar21[1] != (void *)0x0) {
          free(ppvVar21[1]);
          local_90 = (void *)pLVar11->TextN;
          ppvVar21 = (void **)((int)local_90 + iVar23);
          pvVar25 = local_90;
        }
        if (ppvVar21[2] != (void *)0x0) {
          free(ppvVar21[2]);
          local_90 = (void *)pLVar11->TextN;
          ppvVar21 = (void **)((int)local_90 + iVar23);
          pvVar25 = local_90;
        }
        if (ppvVar21[3] != (void *)0x0) {
          iVar22 = 0;
          local_78 = (void *)0x0;
          do {
            if (*(void **)((int)ppvVar21[5] + iVar22) != (void *)0x0) {
              free(*(void **)((int)ppvVar21[5] + iVar22));
              local_90 = (void *)pLVar11->TextN;
            }
            ppvVar21 = (void **)((int)local_90 + iVar23);
            iVar20 = (int)ppvVar21[5] + iVar22;
            if (*(void **)(iVar20 + 4) != (void *)0x0) {
              free(*(void **)(iVar20 + 4));
              local_90 = (void *)pLVar11->TextN;
              ppvVar21 = (void **)((int)local_90 + iVar23);
              iVar20 = (int)ppvVar21[5] + iVar22;
            }
            if (*(void **)(iVar20 + 8) != (void *)0x0) {
              free(*(void **)(iVar20 + 8));
              local_90 = (void *)pLVar11->TextN;
              ppvVar21 = (void **)((int)local_90 + iVar23);
              iVar20 = (int)ppvVar21[5] + iVar22;
            }
            if (*(void **)(iVar20 + 0xc) != (void *)0x0) {
              free(*(void **)(iVar20 + 0xc));
              local_90 = (void *)pLVar11->TextN;
              ppvVar21 = (void **)((int)local_90 + iVar23);
              iVar20 = (int)ppvVar21[5] + iVar22;
            }
            if (*(void **)(iVar20 + 0x10) != (void *)0x0) {
              free(*(void **)(iVar20 + 0x10));
              local_90 = (void *)pLVar11->TextN;
              ppvVar21 = (void **)((int)local_90 + iVar23);
              iVar20 = (int)ppvVar21[5] + iVar22;
            }
            if (*(void **)(iVar20 + 0x14) != (void *)0x0) {
              free(*(void **)(iVar20 + 0x14));
              local_90 = (void *)pLVar11->TextN;
              ppvVar21 = (void **)((int)local_90 + iVar23);
            }
            local_78 = (void *)((int)local_78 + 1);
            iVar22 = iVar22 + 0x18;
            pvVar25 = local_90;
          } while (local_78 < ppvVar21[3]);
        }
        iVar23 = iVar23 + 0x1c;
        local_7c = local_7c + 1;
      } while (local_7c < pLVar11->Name);
    }
    if (pvVar25 != (void *)0x0) {
      free(pvVar25);
    }
    pLVar11->Name = (char *)pLVar18->MenuN;
    pLVar11->LineN = pLVar18->MenuMax;
    pLVar11->TextN = (Cardinal)pLVar18->Menu;
    hid_action("NetlistChanged");
    iVar22 = 0x20000;
    goto LAB_080d27c2;
  }
  iVar22 = 0;
LAB_080d27c2:
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar22;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int Redo(Boolean draw)

{
  uint uVar1;
  UndoListTypePtr ptr;
  UndoListTypePtr ptr_00;
  int Types;
  uint uVar2;
  
  andDraw = draw;
  do {
    if (RedoN == 0) {
      Message("Nothing to redo. Perhaps changes have been made since last undo\n");
      return 0;
    }
    uVar2 = 0;
    Locked = '\x01';
    ptr_00 = UndoList + UndoN;
    Serial = ptr_00->Serial;
    do {
      uVar1 = PerformUndo(ptr_00);
      UndoN = UndoN + 1;
      uVar2 = uVar2 | uVar1;
      RedoN = RedoN - 1;
      if (RedoN == 0) break;
      ptr_00 = ptr_00 + 1;
    } while (ptr_00->Serial == Serial);
    Serial = Serial + 1;
    Locked = '\0';
    if (uVar2 != 0) {
      if (andDraw != '\0') {
        Draw();
        return uVar2;
      }
      return uVar2;
    }
  } while( true );
}



// WARNING: Unknown calling convention

int Undo(Boolean draw)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  UndoListTypePtr ptr;
  UndoListTypePtr ptr_00;
  int Types;
  uint uVar4;
  
  uVar1 = (PCB->Flags).f;
  (PCB->Flags).f = uVar1 & 0xfffffbff;
  andDraw = draw;
  do {
    if (UndoN == 0) {
      if (Serial == 0) {
        Message("Nothing to undo - buffer is empty\n");
        return 0;
      }
      Serial = Serial + -1;
      return 0;
    }
    ptr_00 = UndoList + (UndoN - 1);
    iVar2 = ptr_00->Serial;
    if (iVar2 != Serial + -1) {
      Message("Undo bad serial number %d expecting %d\n",iVar2,Serial + -1);
      Serial = ptr_00->Serial + 1;
      return 0;
    }
    Locked = '\x01';
    uVar4 = 0;
    Serial = iVar2;
    do {
      uVar3 = PerformUndo(ptr_00);
      RedoN = RedoN + 1;
      uVar4 = uVar4 | uVar3;
      UndoN = UndoN - 1;
      if (UndoN == 0) break;
      ptr_00 = ptr_00 + -1;
    } while (ptr_00->Serial == Serial);
    Locked = '\0';
    if (uVar4 != 0) {
      if (andDraw != '\0') {
        Draw();
      }
      if ((uVar1 & 0x400) != 0) {
        (PCB->Flags).f = (PCB->Flags).f | 0x400;
      }
      return uVar4;
    }
  } while( true );
}



// WARNING: Unknown calling convention

int vector_is_empty(vector_t *vector)

{
  return (uint)(vector->size == 0);
}



// WARNING: Unknown calling convention

int vector_size(vector_t *vector)

{
  return vector->size;
}



// WARNING: Unknown calling convention

vector_element_t vector_element(vector_t *vector,int N)

{
  return vector->element[N];
}



// WARNING: Unknown calling convention

vector_element_t vector_element_first(vector_t *vector)

{
  return *vector->element;
}



// WARNING: Unknown calling convention

vector_element_t vector_element_last(vector_t *vector)

{
  return vector->element[vector->size + -1];
}



// WARNING: Unknown calling convention

vector_element_t vector_replace(vector_t *vector,vector_element_t data,int N)

{
  vector_element_t pvVar1;
  vector_element_t old;
  
  pvVar1 = vector->element[N];
  vector->element[N] = data;
  return pvVar1;
}



// WARNING: Unknown calling convention

vector_element_t vector_remove(vector_t *vector,int N)

{
  vector_element_t *__dest;
  vector_element_t pvVar1;
  vector_element_t old;
  
  __dest = vector->element + N;
  pvVar1 = *__dest;
  memmove(__dest,vector->element + N + 1,(~N + vector->size) * 4);
  vector->size = vector->size + -1;
  return pvVar1;
}



// WARNING: Unknown calling convention

vector_element_t vector_remove_last(vector_t *vector)

{
  vector_element_t pvVar1;
  
  pvVar1 = vector_remove(vector,vector->size + -1);
  return pvVar1;
}



// WARNING: Unknown calling convention

void vector_insert_many(vector_t *vector,int N,vector_element_t *data,int count)

{
  int iVar1;
  int iVar2;
  vector_element_t *ppvVar3;
  
  if (count != 0) {
    iVar2 = vector->size;
    iVar1 = count + iVar2;
    if (vector->max < iVar1) {
      iVar2 = vector->max * 2;
      if (iVar2 < 0x20) {
        iVar2 = 0x20;
      }
      if (iVar2 < iVar1) {
        iVar2 = iVar1;
      }
      vector->max = iVar2;
      ppvVar3 = (vector_element_t *)realloc(vector->element,iVar2 << 2);
      iVar2 = vector->size;
      vector->element = ppvVar3;
    }
    else {
      ppvVar3 = vector->element;
    }
    memmove(ppvVar3 + count + N,ppvVar3 + N,(iVar2 - N) * 4);
    memmove(vector->element + N,data,count * 4);
    vector->size = vector->size + count;
  }
  return;
}



// WARNING: Unknown calling convention

void vector_insert(vector_t *vector,int N,vector_element_t data)

{
  vector_insert_many(vector,N,&data,1);
  return;
}



// WARNING: Unknown calling convention

void vector_append_many(vector_t *vector,vector_element_t *data,int count)

{
  vector_insert_many(vector,vector->size,data,count);
  return;
}



// WARNING: Unknown calling convention

void vector_append_vector(vector_t *vector,vector_t *other_vector)

{
  vector_append_many(vector,other_vector->element,other_vector->size);
  return;
}



// WARNING: Unknown calling convention

void vector_append(vector_t *vector,vector_element_t data)

{
  vector_insert_many(vector,vector->size,&data,1);
  return;
}



// WARNING: Unknown calling convention

void vector_destroy(vector_t **vector)

{
  vector_t *__ptr;
  
  __ptr = *vector;
  if (__ptr->element != (vector_element_t *)0x0) {
    free(__ptr->element);
    __ptr = *vector;
  }
  free(__ptr);
  *vector = (vector_t *)0x0;
  return;
}



// WARNING: Unknown calling convention

vector_t * vector_create(void)

{
  vector_t *pvVar1;
  
  pvVar1 = (vector_t *)calloc(1,0xc);
  return pvVar1;
}



// WARNING: Unknown calling convention

vector_t * vector_duplicate(vector_t *orig)

{
  int iVar1;
  vector_t *pvVar2;
  vector_element_t *__dest;
  vector_t *new;
  
  pvVar2 = vector_create();
  if (orig != (vector_t *)0x0) {
    __dest = (vector_element_t *)malloc(orig->max << 2);
    pvVar2->max = orig->max;
    iVar1 = orig->size;
    pvVar2->element = __dest;
    pvVar2->size = iVar1;
    memcpy(__dest,orig->element,orig->size << 2);
  }
  return pvVar2;
}



// WARNING: Unknown calling convention

int ActionToggleVendor(int argc,char **argv,int x,int y)

{
  vendorMapEnable = vendorMapEnable == '\0';
  return 0;
}



// WARNING: Unknown calling convention

int ActionEnableVendor(int argc,char **argv,int x,int y)

{
  vendorMapEnable = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int ActionDisableVendor(int argc,char **argv,int x,int y)

{
  vendorMapEnable = '\0';
  return 0;
}



// WARNING: Unknown calling convention

int vendor_get_enabled(int unused)

{
  return (int)vendorMapEnable;
}



// WARNING: Unknown calling convention

void register_vendor_flag_list(void)

{
  hid_register_flags(vendor_flag_list,1);
  return;
}



// WARNING: Unknown calling convention

void register_vendor_action_list(void)

{
  hid_register_actions(vendor_action_list,6);
  return;
}



// WARNING: Unknown calling convention

int vendorDrillMap(int in)

{
  int iVar1;
  int iVar2;
  int min;
  int iVar3;
  int max;
  int iVar4;
  
  if (in == cached_drill) {
    return cached_map;
  }
  cached_drill = in;
  if (((n_vendor_drills != 0) && (vendor_drills != (int *)0x0)) && (vendorMapEnable != '\0')) {
    iVar2 = *vendor_drills;
    if (iVar2 < in) {
      iVar2 = 0;
      iVar4 = n_vendor_drills + -1;
      if (vendor_drills[n_vendor_drills + -1] < in) {
        Message("Vendor drill list does not contain a drill >= %6.2f mil\nUsing %6.2f mil instead.\n"
                ,(double)in * 0.01,(double)vendor_drills[n_vendor_drills + -1] * 0.01);
        cached_map = vendor_drills[n_vendor_drills + -1];
        return vendor_drills[n_vendor_drills + -1];
      }
      while (iVar3 = iVar2, 1 < iVar4 - iVar3) {
        iVar1 = (iVar3 + iVar4) / 2;
        iVar2 = iVar1;
        if (in <= vendor_drills[iVar1]) {
          iVar2 = iVar3;
          iVar4 = iVar1;
        }
      }
      if (rounding_method == 1) {
        iVar2 = vendor_drills[iVar4 + -1];
        cached_map = vendor_drills[iVar4];
        if (cached_map - in < in - iVar2) {
          return cached_map;
        }
      }
      else {
        iVar2 = vendor_drills[iVar4];
      }
    }
    cached_map = iVar2;
    return iVar2;
  }
  cached_map = in;
  return in;
}



// WARNING: Unknown calling convention

Boolean rematch(char *re,char *s)

{
  int iVar1;
  int iVar2;
  int result;
  int in_GS_OFFSET;
  bool bVar3;
  regex_t compiled;
  regmatch_t match;
  char errorstring [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = regcomp((regex_t *)&compiled,re,0xb);
  if (iVar2 == 0) {
    iVar2 = regexec((regex_t *)&compiled,s,1,(regmatch_t *)&match,0);
    regfree((regex_t *)&compiled);
    bVar3 = iVar2 == 0;
  }
  else {
    regerror(iVar2,(regex_t *)&compiled,errorstring,0x80);
    Message("regexp error: %s\n",errorstring);
    regfree((regex_t *)&compiled);
    bVar3 = false;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return bVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

Boolean vendorIsElementMappable(ElementTypePtr element)

{
  bool bVar1;
  Boolean BVar2;
  char *pcVar3;
  int iVar4;
  char *pcVar5;
  int iVar6;
  int i;
  char *pcVar7;
  
  if (vendorMapEnable == '\0') {
LAB_080d403b:
    BVar2 = '\0';
  }
  else {
    iVar6 = 0;
    bVar1 = true;
    if (0 < n_refdes) {
      do {
        pcVar5 = element->Name[1].TextString;
        pcVar7 = ignore_refdes[iVar6];
        if (pcVar7 == (char *)0x0) {
LAB_080d3fd2:
          if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
            pcVar5 = "(unknown)";
          }
          BVar2 = rematch(pcVar7,pcVar5);
          if (BVar2 != '\0') {
            pcVar7 = ignore_refdes[iVar6];
            pcVar5 = element->Name[1].TextString;
            goto LAB_080d3ffc;
          }
        }
        else {
          if ((pcVar5 == (char *)0x0) || (pcVar3 = pcVar5, *pcVar5 == '\0')) {
            pcVar3 = "(unknown)";
          }
          iVar4 = strcmp(pcVar3,pcVar7);
          if (iVar4 != 0) goto LAB_080d3fd2;
LAB_080d3ffc:
          if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
            pcVar5 = "(unknown)";
          }
          Message("Vendor mapping skipped because refdes = %s matches %s\n",pcVar5,pcVar7);
          bVar1 = false;
        }
        iVar6 = iVar6 + 1;
      } while (iVar6 < n_refdes);
      if (!bVar1) goto LAB_080d403b;
    }
    if (0 < n_value) {
      iVar6 = 0;
      do {
        pcVar5 = element->Name[2].TextString;
        pcVar7 = ignore_value[iVar6];
        if (pcVar7 == (char *)0x0) {
LAB_080d409a:
          if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
            pcVar5 = "(unknown)";
          }
          BVar2 = rematch(pcVar7,pcVar5);
          if (BVar2 != '\0') {
            pcVar7 = ignore_value[iVar6];
            pcVar5 = element->Name[2].TextString;
            goto LAB_080d40c4;
          }
        }
        else {
          if ((pcVar5 == (char *)0x0) || (pcVar3 = pcVar5, *pcVar5 == '\0')) {
            pcVar3 = "(unknown)";
          }
          iVar4 = strcmp(pcVar3,pcVar7);
          if (iVar4 != 0) goto LAB_080d409a;
LAB_080d40c4:
          if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
            pcVar5 = "(unknown)";
          }
          Message("Vendor mapping skipped because value = %s matches %s\n",pcVar5,pcVar7);
          bVar1 = false;
        }
        iVar6 = iVar6 + 1;
      } while (iVar6 < n_value);
      if (!bVar1) goto LAB_080d403b;
    }
    if (0 < n_descr) {
      iVar6 = 0;
      do {
        pcVar5 = element->Name[0].TextString;
        pcVar7 = ignore_descr[iVar6];
        if (pcVar7 == (char *)0x0) {
LAB_080d4157:
          if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
            pcVar5 = "(unknown)";
          }
          BVar2 = rematch(pcVar7,pcVar5);
          if (BVar2 != '\0') {
            pcVar7 = ignore_descr[iVar6];
            pcVar5 = element->Name[0].TextString;
            goto LAB_080d4180;
          }
        }
        else {
          if ((pcVar5 == (char *)0x0) || (pcVar3 = pcVar5, *pcVar5 == '\0')) {
            pcVar3 = "(unknown)";
          }
          iVar4 = strcmp(pcVar3,pcVar7);
          if (iVar4 != 0) goto LAB_080d4157;
LAB_080d4180:
          if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
            pcVar5 = "(unknown)";
          }
          Message("Vendor mapping skipped because descr = %s matches %s\n",pcVar5,pcVar7);
          bVar1 = false;
        }
        iVar6 = iVar6 + 1;
      } while (iVar6 < n_descr);
      if (!bVar1) goto LAB_080d403b;
    }
    BVar2 = '\x01';
    if ((*(byte *)((int)&(element->Flags).f + 1) & 0x20) != 0) {
      pcVar5 = element->Name[1].TextString;
      if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
        pcVar5 = "(unknown)";
      }
      Message("Vendor mapping skipped because element %s is locked\n",pcVar5);
      return '\0';
    }
  }
  return BVar2;
}



// WARNING: Unknown calling convention

int ActionUnloadVendor(int argc,char **argv,int x,int y)

{
  cached_drill = -1;
  n_vendor_drills = 0;
  n_refdes = 0;
  n_value = 0;
  n_descr = 0;
  if (vendor_drills != (int *)0x0) {
    free(vendor_drills);
    vendor_drills = (int *)0x0;
  }
  if (ignore_refdes != (char **)0x0) {
    free(ignore_refdes);
    ignore_refdes = (char **)0x0;
  }
  if (ignore_value != (char **)0x0) {
    free(ignore_value);
    ignore_value = (char **)0x0;
  }
  if (ignore_descr != (char **)0x0) {
    free(ignore_descr);
    ignore_descr = (char **)0x0;
  }
  return 0;
}



// WARNING: Unknown calling convention

void apply_vendor_map(void)

{
  uint uVar1;
  double dVar2;
  double dVar3;
  Boolean BVar4;
  PCBTypePtr pPVar5;
  Boolean BVar6;
  int iVar7;
  Cardinal sn_1;
  int iVar8;
  char *pcVar9;
  Cardinal sn;
  char *pcVar10;
  DataTypePtr paVar11;
  char *pcVar12;
  PinTypePtr via;
  PinTypePtr paVar13;
  PinTypePtr pin;
  int i;
  uint uVar14;
  Cardinal n;
  Cardinal n_1;
  ElementTypePtr element;
  ElementTypePtr element_00;
  char *pcVar15;
  int local_3c;
  int local_38;
  int local_34;
  char *local_30;
  uint local_2c;
  int local_28;
  uint local_24;
  
  BVar4 = vendorMapEnable;
  vendorMapEnable = '\x01';
  if (0 < n_vendor_drills) {
    local_28 = 0;
    local_38 = 0;
    paVar11 = PCB->Data;
    if (paVar11->ViaN != 0) {
      uVar14 = 0;
      local_24 = paVar11->ViaN;
      do {
        paVar13 = paVar11->Via + uVar14;
        local_28 = local_28 + 1;
        iVar8 = paVar13->DrillingHole;
        iVar7 = vendorDrillMap(iVar8);
        if (iVar8 != iVar7) {
          if ((*(byte *)((int)&(paVar13->Flags).f + 1) & 0x20) == 0) {
            iVar8 = vendorDrillMap(paVar13->DrillingHole);
            BVar6 = ChangeObject2ndSize(1,paVar13,(void *)0x0,(void *)0x0,iVar8,'\x01','\0');
            if (BVar6 == '\0') {
              dVar2 = (double)paVar13->Y * 0.01;
              dVar3 = (double)paVar13->X * 0.01;
              Message("Via at %.2f, %.2f not changed.  Possible reasons:\n\t- pad size too small\n\t- new size would be too large or too small\n"
                      ,SUB84(dVar3,0),(int)((ulonglong)dVar3 >> 0x20),SUB84(dVar2,0),
                      (int)((ulonglong)dVar2 >> 0x20));
            }
            else {
              local_38 = local_38 + 1;
            }
          }
          else {
            dVar2 = (double)paVar13->Y * 0.01;
            dVar3 = (double)paVar13->X * 0.01;
            Message("Locked via at %.2f, %.2f not changed.\n",SUB84(dVar3,0),
                    (int)((ulonglong)dVar3 >> 0x20),SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20));
          }
        }
        paVar11 = PCB->Data;
        uVar1 = paVar11->ViaN;
      } while ((uVar1 != 0) &&
              (uVar14 = (uVar1 + 1 + uVar14) - local_24, local_24 = uVar1, uVar14 < uVar1));
    }
    local_34 = paVar11->ElementN - 1;
    if (local_34 != -1) {
      iVar8 = paVar11->ElementN * 300;
      do {
        local_3c = iVar8 + -300;
        element_00 = (ElementTypePtr)(PCB->Data->Element[-1].Flags.t + iVar8 + -0x18);
        BVar6 = vendorIsElementMappable(element_00);
        if ((BVar6 != '\0') && (element_00->PinN != 0)) {
          uVar14 = 0;
          local_2c = element_00->PinN;
          do {
            local_28 = local_28 + 1;
            paVar13 = element_00->Pin + uVar14;
            iVar8 = paVar13->DrillingHole;
            iVar7 = vendorDrillMap(iVar8);
            if (iVar8 == iVar7) {
LAB_080d45ca:
              uVar1 = element_00->PinN;
            }
            else {
              if ((*(byte *)((int)&(paVar13->Flags).f + 1) & 0x20) == 0) {
                iVar8 = vendorDrillMap(paVar13->DrillingHole);
                BVar6 = ChangeObject2ndSize(0x100,element_00,paVar13,(void *)0x0,iVar8,'\x01','\0');
                if (BVar6 == '\0') {
                  pcVar9 = element_00->Name[0].TextString;
                  if ((pcVar9 == (char *)0x0) || (*pcVar9 == '\0')) {
                    pcVar9 = "(unknown)";
                  }
                  pcVar10 = element_00->Name[2].TextString;
                  if ((pcVar10 == (char *)0x0) || (*pcVar10 == '\0')) {
                    pcVar10 = "(unknown)";
                  }
                  pcVar15 = element_00->Name[1].TextString;
                  if ((pcVar15 == (char *)0x0) || (*pcVar15 == '\0')) {
                    pcVar15 = "(unknown)";
                  }
                  local_30 = paVar13->Name;
                  if ((local_30 == (char *)0x0) || (*local_30 == '\0')) {
                    local_30 = "(unknown)";
                  }
                  pcVar12 = paVar13->Number;
                  if ((pcVar12 == (char *)0x0) || (*pcVar12 == '\0')) {
                    pcVar12 = "(unknown)";
                  }
                  dVar2 = (double)paVar13->X * 0.01;
                  Message("Pin %s (%s) at %.2f, %.2f (element %s, %s, %s) not changed.\n\tPossible reasons:\n\t- pad size too small\n\t- new size would be too large or too small\n"
                          ,pcVar12,local_30,SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20),
                          (double)paVar13->Y * 0.01,pcVar15,pcVar10,pcVar9);
                }
                else {
                  local_38 = local_38 + 1;
                }
                goto LAB_080d45ca;
              }
              dVar2 = (double)paVar13->Y * 0.01;
              dVar3 = (double)paVar13->X * 0.01;
              Message("Locked pin at %-6.2f, %-6.2f not changed.\n",SUB84(dVar3,0),
                      (int)((ulonglong)dVar3 >> 0x20),SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20)
                     );
              uVar1 = element_00->PinN;
            }
          } while ((uVar1 != 0) &&
                  (uVar14 = (uVar1 + 1 + uVar14) - local_2c, local_2c = uVar1, uVar14 < uVar1));
        }
        local_34 = local_34 + -1;
        iVar8 = local_3c;
      } while (local_34 != -1);
    }
    Message("Updated %d drill sizes out of %d total\n",local_38,local_28);
    iVar8 = Settings.ViaDrillingHole;
    iVar7 = vendorDrillMap(Settings.ViaDrillingHole);
    if (iVar8 != iVar7) {
      local_38 = local_38 + 1;
      Settings.ViaDrillingHole = vendorDrillMap(Settings.ViaDrillingHole);
      Message("Adjusted active via hole size to be %6.2f mils\n",
              SUB84((double)Settings.ViaDrillingHole * 0.01,0),
              (int)((ulonglong)((double)Settings.ViaDrillingHole * 0.01) >> 0x20));
    }
    i = 0;
    do {
      iVar8 = PCB->RouteStyle[i].Hole;
      iVar7 = vendorDrillMap(iVar8);
      pPVar5 = PCB;
      if (iVar8 != iVar7) {
        local_38 = local_38 + 1;
        iVar8 = vendorDrillMap(PCB->RouteStyle[i].Hole);
        pPVar5->RouteStyle[i].Hole = iVar8;
        dVar2 = (double)PCB->RouteStyle[i].Hole * 0.01;
        Message("Adjusted %s routing style via hole size to be %6.2f mils\n",PCB->RouteStyle[i].Name
                ,SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20));
        pPVar5 = PCB;
        iVar8 = PCB->RouteStyle[i].Hole;
        if (PCB->RouteStyle[i].Diameter <= iVar8 + 399) {
          iVar8 = iVar8 + 400;
          PCB->RouteStyle[i].Diameter = iVar8;
          dVar2 = (double)iVar8 * 0.01;
          Message("Increased %s routing style via diameter to %6.2f mils\n",
                  pPVar5->RouteStyle[i].Name,SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20));
        }
      }
      i = i + 1;
    } while (i != 4);
    if (local_38 != 0) {
      SetChangedFlag('\x01');
      ClearAndRedrawOutput();
      IncrementUndoSerialNumber();
    }
  }
  vendorMapEnable = BVar4;
  return;
}



// WARNING: Unknown calling convention

int ActionLoadVendorFrom(int argc,char **argv,int x,int y)

{
  undefined4 *puVar1;
  char cVar2;
  undefined4 uVar3;
  PCBTypePtr pPVar4;
  PCBTypePtr pPVar5;
  Resource *pRVar6;
  char *pcVar7;
  char *sval;
  Resource *res;
  Resource *pRVar8;
  int iVar9;
  char **ppcVar10;
  int k_1;
  int iVar11;
  int type;
  char *pcVar12;
  int iVar13;
  int j;
  int *piVar14;
  int *cnt;
  int iVar15;
  Resource *drcres;
  char *sval_1;
  byte *pbVar16;
  byte *pbVar17;
  int iVar18;
  char *pcVar19;
  int k;
  byte *pbVar20;
  bool bVar21;
  bool bVar22;
  bool bVar23;
  byte bVar24;
  double dVar25;
  int *local_48;
  char *local_44;
  int local_38;
  int local_30;
  char ***local_2c;
  int local_28;
  
  bVar24 = 0;
  cached_drill = -1;
  if (((argc == 0) || (local_44 = *argv, local_44 == (char *)0x0)) || (*local_44 == '\0')) {
    local_44 = (*gui->fileselect)("Load Vendor Resource File...",
                                  "Picks a vendor resource file to load.\nThis file can contain drc settings for a\nparticular vendor as well as a list of\npredefined drills which are allowed."
                                  ,ActionLoadVendorFrom::default_file,".res","vendor",1);
    if (local_44 == (char *)0x0) {
      Message("Syntax error.  Usage:\n%s\n","LoadVendorFrom(filename)");
      return 1;
    }
    if (ActionLoadVendorFrom::default_file != (char *)0x0) {
      free(ActionLoadVendorFrom::default_file);
      ActionLoadVendorFrom::default_file = (char *)0x0;
    }
    if (*local_44 != '\0') {
      ActionLoadVendorFrom::default_file = (char *)__strdup(local_44);
    }
  }
  n_vendor_drills = 0;
  n_refdes = 0;
  n_value = 0;
  n_descr = 0;
  if (vendor_drills != (int *)0x0) {
    free(vendor_drills);
    vendor_drills = (int *)0x0;
  }
  if (ignore_refdes != (char **)0x0) {
    free(ignore_refdes);
    ignore_refdes = (char **)0x0;
  }
  if (ignore_value != (char **)0x0) {
    free(ignore_value);
    ignore_value = (char **)0x0;
  }
  if (ignore_descr != (char **)0x0) {
    free(ignore_descr);
    ignore_descr = (char **)0x0;
  }
  pRVar6 = resource_parse(local_44,(char **)0x0);
  if (pRVar6 == (Resource *)0x0) {
    Message("Could not load vendor resource file \"%s\"\n",local_44);
    return 1;
  }
  pcVar7 = resource_value(pRVar6,"vendor");
  if ((pcVar7 == (char *)0x0) || (pcVar7 = resource_value(pRVar6,"vendor"), *pcVar7 == '\0')) {
    vendor_name = "(unknown)";
  }
  else {
    vendor_name = resource_value(pRVar6,"vendor");
  }
  pcVar7 = resource_value(pRVar6,"units");
  if (pcVar7 == (char *)0x0) {
LAB_080d49e7:
    sf = 100.0;
  }
  else {
    cVar2 = *pcVar7;
    bVar22 = cVar2 == 'm';
    if (((bVar22) && (bVar22 = pcVar7[1] == 'i', bVar22)) &&
       ((bVar22 = pcVar7[2] == 'l', bVar22 && (bVar22 = pcVar7[3] == '\0', bVar22))))
    goto LAB_080d49e7;
    iVar11 = 5;
    pcVar12 = pcVar7;
    pcVar19 = "mils";
    do {
      if (iVar11 == 0) break;
      iVar11 = iVar11 + -1;
      bVar22 = *pcVar12 == *pcVar19;
      pcVar12 = pcVar12 + (uint)bVar24 * -2 + 1;
      pcVar19 = pcVar19 + (uint)bVar24 * -2 + 1;
    } while (bVar22);
    if (bVar22) goto LAB_080d49e7;
    iVar11 = 5;
    pcVar12 = pcVar7;
    pcVar19 = "inch";
    do {
      if (iVar11 == 0) break;
      iVar11 = iVar11 + -1;
      bVar22 = *pcVar12 == *pcVar19;
      pcVar12 = pcVar12 + (uint)bVar24 * -2 + 1;
      pcVar19 = pcVar19 + (uint)bVar24 * -2 + 1;
    } while (bVar22);
    if ((bVar22) || (iVar11 = strcmp(pcVar7,"inches"), iVar11 == 0)) {
LAB_080d5136:
      sf = 100000.0;
    }
    else {
      if ((cVar2 != 'm') || ((pcVar7[1] != 'm' || (pcVar7[2] != '\0')))) {
        Message("\"%s\" is not a supported units.  Defaulting to inch\n",pcVar7);
        goto LAB_080d5136;
      }
      sf = 3937.007874015748;
    }
  }
  rounding_method = 0;
  res = resource_subres(pRVar6,"drillmap");
  if (res == (Resource *)0x0) {
    Message("No drillmap resource found\n");
    goto LAB_080d4dd8;
  }
  pcVar7 = resource_value(res,"round");
  if (pcVar7 != (char *)0x0) {
    bVar22 = *pcVar7 == 'u';
    if (((!bVar22) || (bVar22 = pcVar7[1] == 'p', !bVar22)) || (bVar22 = pcVar7[2] == '\0', !bVar22)
       ) {
      iVar11 = 8;
      pcVar12 = pcVar7;
      pcVar19 = "nearest";
      do {
        if (iVar11 == 0) break;
        iVar11 = iVar11 + -1;
        bVar22 = *pcVar12 == *pcVar19;
        pcVar12 = pcVar12 + (uint)bVar24 * -2 + 1;
        pcVar19 = pcVar19 + (uint)bVar24 * -2 + 1;
      } while (bVar22);
      if (bVar22) {
        rounding_method = 1;
        goto LAB_080d4a83;
      }
      Message("\"%s\" is not a valid rounding type.  Defaulting to up\n",pcVar7);
    }
    rounding_method = 0;
  }
LAB_080d4a83:
  pcVar7 = "skips";
  pRVar8 = resource_subres(res,"skips");
  if ((pRVar8 != (Resource *)0x0) && (0 < pRVar8->c)) {
    local_30 = 0;
    local_38 = 0;
    do {
      piVar14 = (int *)((int)&pRVar8->v->name + local_30);
      iVar11 = piVar14[2];
      pcVar12 = (char *)((~-(uint)(*piVar14 == 0) & 100) + (uint)(iVar11 != 0) +
                        (~-(uint)(piVar14[1] == 0) & 10));
      if (pcVar12 == (char *)0x1) {
        iVar9 = *(int *)(iVar11 + 0x10);
        pbVar17 = *(byte **)(iVar9 + 4);
        bVar22 = false;
        bVar23 = pbVar17 == (byte *)0x0;
        if (bVar23) {
          Message("Error:  null skip value\n",pcVar7);
          pcVar12 = pcVar7;
        }
        else {
          iVar13 = 7;
          pbVar16 = pbVar17;
          pbVar20 = (byte *)"refdes";
          do {
            if (iVar13 == 0) break;
            iVar13 = iVar13 + -1;
            bVar22 = *pbVar16 < *pbVar20;
            bVar23 = *pbVar16 == *pbVar20;
            pbVar16 = pbVar16 + (uint)bVar24 * -2 + 1;
            pbVar20 = pbVar20 + (uint)bVar24 * -2 + 1;
          } while (bVar23);
          local_2c = &ignore_refdes;
          local_48 = &n_refdes;
          bVar21 = (!bVar22 && !bVar23) < bVar22;
          bVar22 = (!bVar22 && !bVar23) == bVar22;
          pcVar12 = pcVar7;
          if (!bVar22) {
            iVar13 = 6;
            pbVar16 = pbVar17;
            pbVar20 = (byte *)0x8156226;
            do {
              if (iVar13 == 0) break;
              iVar13 = iVar13 + -1;
              bVar21 = *pbVar16 < *pbVar20;
              bVar22 = *pbVar16 == *pbVar20;
              pbVar16 = pbVar16 + (uint)bVar24 * -2 + 1;
              pbVar20 = pbVar20 + (uint)bVar24 * -2 + 1;
            } while (bVar22);
            local_2c = &ignore_value;
            local_48 = &n_value;
            bVar22 = (!bVar21 && !bVar22) == bVar21;
            if (!bVar22) {
              iVar13 = 6;
              pbVar16 = (byte *)"descr";
              do {
                if (iVar13 == 0) break;
                iVar13 = iVar13 + -1;
                bVar22 = *pbVar17 == *pbVar16;
                pbVar17 = pbVar17 + (uint)bVar24 * -2 + 1;
                pbVar16 = pbVar16 + (uint)bVar24 * -2 + 1;
              } while (bVar22);
              if (!bVar22) goto LAB_080d4ad0;
              local_2c = &ignore_descr;
              local_48 = &n_descr;
            }
          }
          if (1 < *(int *)(iVar11 + 0xc)) {
            iVar11 = 0xc;
            iVar13 = 1;
            while( true ) {
              uVar3 = *(undefined4 *)(iVar9 + 4 + iVar11);
              iVar9 = *local_48;
              *local_48 = iVar9 + 1;
              pcVar12 = (char *)((iVar9 + 1) * 4);
              ppcVar10 = (char **)realloc(*local_2c,(size_t)pcVar12);
              *local_2c = ppcVar10;
              if (ppcVar10 == (char **)0x0) {
                __fprintf_chk(stderr,1,"realloc() failed\n");
                    // WARNING: Subroutine does not return
                exit(-1);
              }
              iVar9 = *local_48;
              iVar13 = iVar13 + 1;
              iVar11 = iVar11 + 0xc;
              pcVar7 = (char *)__strdup(uVar3);
              ppcVar10[iVar9 + -1] = pcVar7;
              iVar9 = *(int *)((int)&pRVar8->v->subres + local_30);
              if (*(int *)(iVar9 + 0xc) <= iVar13) break;
              iVar9 = *(int *)(iVar9 + 0x10);
            }
          }
        }
      }
      else {
        Message("Ignored resource type = %d in skips= section\n",pcVar12);
      }
LAB_080d4ad0:
      local_38 = local_38 + 1;
      local_30 = local_30 + 0xc;
      pcVar7 = pcVar12;
    } while (local_38 < pRVar8->c);
  }
  if (0 < res->c) {
    local_2c = (char ***)0x0;
    local_28 = 0;
    do {
      piVar14 = (int *)((int)&res->v->name + (int)local_2c);
      pcVar7 = (char *)piVar14[1];
      if ((~-(uint)(*piVar14 == 0) & 100) + (uint)(piVar14[2] != 0) +
          (~-(uint)(pcVar7 == (char *)0x0) & 10) == 10) {
        n_vendor_drills = n_vendor_drills + 1;
        vendor_drills = (int *)realloc(vendor_drills,n_vendor_drills * 4);
        if (vendor_drills == (int *)0x0) {
          __fprintf_chk(stderr,1,"realloc() failed to allocate %ld bytes\n",n_vendor_drills << 2);
        }
        else {
          dVar25 = strtod(pcVar7,(char **)0x0);
          dVar25 = floor(dVar25 * sf + 0.5);
          piVar14 = vendor_drills;
          iVar11 = n_vendor_drills + -1;
          iVar9 = (int)ROUND(dVar25);
          if (iVar11 < 1) {
            iVar13 = 0;
LAB_080d4d7a:
            if (iVar13 == iVar11) {
              vendor_drills[iVar13] = iVar9;
              goto LAB_080d4c78;
            }
            local_38 = iVar13 * 4;
          }
          else if (*vendor_drills < iVar9) {
            iVar13 = 0;
            do {
              iVar13 = iVar13 + 1;
              if (iVar11 <= iVar13) goto LAB_080d4d7a;
              local_38 = iVar13 * 4;
            } while (vendor_drills[iVar13] < iVar9);
          }
          else {
            local_38 = 0;
            iVar13 = 0;
          }
          if (iVar13 < iVar11) {
            iVar18 = iVar11 * 4;
            iVar15 = n_vendor_drills * 4 + -8;
            do {
              puVar1 = (undefined4 *)((int)piVar14 + iVar15);
              iVar11 = iVar11 + -1;
              iVar15 = iVar15 + -4;
              *(undefined4 *)((int)piVar14 + iVar18) = *puVar1;
              iVar18 = iVar18 + -4;
            } while (iVar11 != iVar13);
          }
          *(int *)((int)piVar14 + local_38) = iVar9;
        }
      }
LAB_080d4c78:
      local_28 = local_28 + 1;
      local_2c = (char ***)((int)local_2c + 0xc);
    } while (res->c != local_28 && local_28 <= res->c);
  }
LAB_080d4dd8:
  pRVar6 = resource_subres(pRVar6,"drc");
  pcVar7 = resource_value(pRVar6,"copper_space");
  pPVar4 = PCB;
  if (pcVar7 != (char *)0x0) {
    dVar25 = strtod(pcVar7,(char **)0x0);
    dVar25 = floor(dVar25 * sf + 0.5);
    pPVar5 = PCB;
    pPVar4->Bloat = (int)ROUND(dVar25);
    dVar25 = (double)pPVar5->Bloat * 0.01;
    Message("Set DRC minimum copper spacing to %.2f mils\n",SUB84(dVar25,0),
            (int)((ulonglong)dVar25 >> 0x20));
  }
  pcVar7 = resource_value(pRVar6,"copper_overlap");
  pPVar4 = PCB;
  if (pcVar7 != (char *)0x0) {
    dVar25 = strtod(pcVar7,(char **)0x0);
    dVar25 = floor(dVar25 * sf + 0.5);
    pPVar5 = PCB;
    pPVar4->Shrink = (int)ROUND(dVar25);
    dVar25 = (double)pPVar5->Shrink * 0.01;
    Message("Set DRC minimum copper overlap to %.2f mils\n",SUB84(dVar25,0),
            (int)((ulonglong)dVar25 >> 0x20));
  }
  pcVar7 = resource_value(pRVar6,"copper_width");
  pPVar4 = PCB;
  if (pcVar7 != (char *)0x0) {
    dVar25 = strtod(pcVar7,(char **)0x0);
    dVar25 = floor(dVar25 * sf + 0.5);
    pPVar5 = PCB;
    pPVar4->minWid = (int)ROUND(dVar25);
    dVar25 = (double)pPVar5->minWid * 0.01;
    Message("Set DRC minimum copper spacing to %.2f mils\n",SUB84(dVar25,0),
            (int)((ulonglong)dVar25 >> 0x20));
  }
  pcVar7 = resource_value(pRVar6,"silk_width");
  pPVar4 = PCB;
  if (pcVar7 != (char *)0x0) {
    dVar25 = strtod(pcVar7,(char **)0x0);
    dVar25 = floor(dVar25 * sf + 0.5);
    pPVar5 = PCB;
    pPVar4->minSlk = (int)ROUND(dVar25);
    dVar25 = (double)pPVar5->minSlk * 0.01;
    Message("Set DRC minimum silk width to %.2f mils\n",SUB84(dVar25,0),
            (int)((ulonglong)dVar25 >> 0x20));
  }
  pcVar7 = resource_value(pRVar6,"min_drill");
  pPVar4 = PCB;
  if (pcVar7 != (char *)0x0) {
    dVar25 = strtod(pcVar7,(char **)0x0);
    dVar25 = floor(dVar25 * sf + 0.5);
    pPVar5 = PCB;
    pPVar4->minDrill = (int)ROUND(dVar25);
    dVar25 = (double)pPVar5->minDrill * 0.01;
    Message("Set DRC minimum drill diameter to %.2f mils\n",SUB84(dVar25,0),
            (int)((ulonglong)dVar25 >> 0x20));
  }
  pcVar7 = resource_value(pRVar6,"min_ring");
  pPVar4 = PCB;
  if (pcVar7 != (char *)0x0) {
    dVar25 = strtod(pcVar7,(char **)0x0);
    dVar25 = floor(dVar25 * sf + 0.5);
    pPVar5 = PCB;
    pPVar4->minRing = (int)ROUND(dVar25);
    dVar25 = (double)pPVar5->minRing * 0.01;
    Message("Set DRC minimum annular ring to %.2f mils\n",SUB84(dVar25,0),
            (int)((ulonglong)dVar25 >> 0x20));
  }
  Message("Loaded %d vendor drills from %s\n",n_vendor_drills,local_44);
  Message("Loaded %d RefDes skips, %d Value skips, %d Descr skips\n",n_refdes,n_value,n_descr);
  vendorMapEnable = '\x01';
  apply_vendor_map();
  free((void *)0x0);
  return 0;
}



// WARNING: Unknown calling convention

int ActionApplyVendor(int argc,char **argv,int x,int y)

{
  hid_action("Busy");
  apply_vendor_map();
  return 0;
}



// WARNING: Unknown calling convention

int hid_parse_actions(char *rstr,_func_int_char_ptr_int_char_ptr_ptr *function)

{
  char cVar1;
  char cVar2;
  code *pcVar3;
  size_t sVar4;
  char *__ptr;
  ushort **ppuVar5;
  int iVar6;
  char cVar7;
  char in_quotes;
  char *cp2;
  char *sp;
  int retcode;
  char *cp;
  char *pcVar8;
  char *pcVar9;
  bool bVar10;
  int local_2c;
  char **local_28;
  int local_24;
  int local_20;
  
  pcVar3 = hid_actionv;
  if (function != (_func_int_char_ptr_int_char_ptr_ptr *)0x0) {
    pcVar3 = function;
  }
  sVar4 = strlen(rstr);
  __ptr = (char *)malloc(sVar4 + 1);
  local_2c = 0;
  local_28 = (char **)0x0;
  sp = rstr;
LAB_080d5261:
  cVar7 = *sp;
  do {
    if (cVar7 == '\0') {
cleanup:
      iVar6 = 0;
      goto LAB_080d547d;
    }
    ppuVar5 = __ctype_b_loc();
    while (pcVar8 = __ptr, (*(byte *)((int)*ppuVar5 + cVar7 * 2 + 1) & 0x20) != 0) {
      sp = sp + 1;
      cVar7 = *sp;
      if (cVar7 == '\0') goto cleanup;
    }
    while ((cVar7 != '(' && (cVar7 != '\0'))) {
      sp = sp + 1;
      *pcVar8 = cVar7;
      pcVar8 = pcVar8 + 1;
      cVar7 = *sp;
    }
    *pcVar8 = '\0';
    if (*sp == '\0') break;
    sp = sp + 1;
    cVar7 = *sp;
    if (cVar7 == '\0') break;
    pcVar8 = pcVar8 + 1;
    local_20 = 0;
    local_24 = 0;
    bVar10 = true;
    while (cVar7 != ')') {
      do {
        if ((cVar7 == '\0') && (bVar10)) goto cleanup;
        if (local_2c <= local_24) {
          local_2c = local_2c + 10;
          if (local_28 == (char **)0x0) {
            local_28 = (char **)malloc(local_2c * 4);
            cVar7 = *sp;
          }
          else {
            local_28 = (char **)realloc(local_28,local_2c * 4);
            cVar7 = *sp;
          }
        }
        if (cVar7 != '\0') {
          do {
            if ((*(byte *)((int)*ppuVar5 + cVar7 * 2 + 1) & 0x20) == 0) break;
            sp = sp + 1;
            cVar7 = *sp;
          } while (cVar7 != '\0');
        }
        local_24 = local_24 + 1;
        *(char **)((int)local_28 + local_20) = pcVar8;
        cVar2 = *sp;
        pcVar9 = pcVar8;
        cVar1 = '\0';
        while ((cVar7 = cVar2, cVar7 != '\0' &&
               ((cVar1 != '\0' || ((cVar7 != ')' && (cVar7 != ','))))))) {
          if ((cVar7 == '\'') || (cVar7 == '\"')) {
            if (cVar1 != '\0') {
              if (cVar1 != cVar7) goto LAB_080d53c6;
              cVar7 = '\0';
            }
          }
          else {
LAB_080d53c6:
            if ((cVar7 == '\\') && (cVar1 != '\'')) {
              sp = sp + 1;
              cVar7 = *sp;
            }
            *pcVar9 = cVar7;
            pcVar9 = pcVar9 + 1;
            cVar7 = cVar1;
          }
          sp = sp + 1;
          cVar1 = cVar7;
          cVar2 = *sp;
        }
        *pcVar9 = '\0';
        pcVar8 = pcVar9 + 1;
        cVar1 = *sp;
        if (cVar1 == ',') {
          sp = sp + 1;
          cVar7 = *sp;
        }
        while ((pcVar9 = pcVar9 + -1, (*(byte *)((int)*ppuVar5 + *pcVar9 * 2 + 1) & 0x20) != 0 &&
               (*(char **)((int)local_28 + local_20) <= pcVar9))) {
          *pcVar9 = '\0';
        }
        local_20 = local_20 + 4;
        bVar10 = cVar1 != ',';
      } while (!bVar10);
    }
    iVar6 = (*pcVar3)(__ptr,local_24,local_28);
    if (iVar6 != 0) goto LAB_080d52ed;
    sp = sp + 1;
    cVar7 = *sp;
  } while( true );
  iVar6 = (*pcVar3)(__ptr,0,(char **)0x0);
  if (iVar6 != 0) {
LAB_080d52ed:
    iVar6 = 1;
LAB_080d547d:
    if (local_28 != (char **)0x0) {
      free(local_28);
    }
    if (__ptr != (char *)0x0) {
      free(__ptr);
    }
    return iVar6;
  }
  goto LAB_080d5261;
}



// WARNING: Unknown calling convention

void dump_string(char prefix,char *str)

{
  int eol;
  bool bVar1;
  
  if (*str != '\0') {
    bVar1 = true;
    do {
      if (bVar1) {
        _IO_putc((int)prefix,stdout);
      }
      _IO_putc((int)*str,stdout);
      bVar1 = *str == '\n';
      str = str + 1;
    } while (*str != '\0');
    if (!bVar1) {
      _IO_putc(10,stdout);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int action_sort(void *va,void *vb)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = strcmp(*va,*vb);
  return iVar1;
}



// WARNING: Unknown calling convention

void hid_deregister_action(char *name,void **context)

{
  HID_ActionNode *pHVar1;
  int iVar2;
  HID_ActionNode *ha;
  HID_ActionNode *__ptr;
  HID_ActionNode *prev;
  HID_ActionNode *pHVar3;
  
  if (context != (void **)0x0) {
    *context = (void *)0x0;
  }
  if (hid_action_nodes != (HID_ActionNode *)0x0) {
    pHVar1 = hid_action_nodes;
    pHVar3 = (HID_ActionNode *)0x0;
    do {
      __ptr = pHVar1;
      if ((__ptr->dynamic != 0) && (iVar2 = strcmp(__ptr->actions->name,name), iVar2 == 0)) {
        if (context != (void **)0x0) {
          *context = __ptr->context;
        }
        if (pHVar3 == (HID_ActionNode *)0x0) {
          hid_action_nodes = __ptr->next;
        }
        else {
          pHVar3->next = __ptr->next;
        }
        free(__ptr->actions);
        free(__ptr);
        if (all_actions != (HID_ActionContext *)0x0) {
          free(all_actions);
          all_actions = (HID_ActionContext *)0x0;
        }
        n_actions = n_actions + -1;
        return;
      }
      pHVar1 = __ptr->next;
      pHVar3 = __ptr;
    } while (__ptr->next != (HID_ActionNode *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

HID_Action * hid_find_action(char *name,void **context)

{
  char **ppcVar1;
  HID_Action *pHVar2;
  int iVar3;
  int iVar4;
  HID_ActionContext *pHVar5;
  HID_ActionContext *pHVar6;
  int iVar7;
  int i;
  int iVar8;
  HID_ActionNode *ha;
  HID_ActionNode *pHVar9;
  int n;
  int upper;
  int local_24;
  int local_20;
  
  if (name == (char *)0x0) {
    return (HID_Action *)0x0;
  }
  if (all_actions == (HID_ActionContext *)0x0) {
    pHVar5 = (HID_ActionContext *)malloc(n_actions * 0x18);
    all_actions = pHVar5;
    if (hid_action_nodes != (HID_ActionNode *)0x0) {
      local_20 = 0;
      pHVar9 = hid_action_nodes;
      do {
        if (0 < pHVar9->n) {
          iVar8 = 0;
          pHVar2 = pHVar9->actions;
          pHVar6 = pHVar5 + local_20;
          iVar7 = 0;
          do {
            iVar8 = iVar8 + 1;
            local_20 = local_20 + 1;
            (pHVar6->action).name = *(char **)((int)&pHVar2->name + iVar7);
            (pHVar6->action).need_coord_msg = *(char **)((int)&pHVar2->need_coord_msg + iVar7);
            (pHVar6->action).trigger_cb =
                 *(_func_int_int_char_ptr_ptr_int_int **)((int)&pHVar2->trigger_cb + iVar7);
            (pHVar6->action).description = *(char **)((int)&pHVar2->description + iVar7);
            ppcVar1 = (char **)((int)&pHVar2->syntax + iVar7);
            iVar7 = iVar7 + 0x14;
            (pHVar6->action).syntax = *ppcVar1;
            pHVar6->context = pHVar9->context;
            pHVar6 = pHVar6 + 1;
          } while (pHVar9->n != iVar8 && iVar8 <= pHVar9->n);
        }
        pHVar9 = pHVar9->next;
      } while (pHVar9 != (HID_ActionNode *)0x0);
    }
    qsort(pHVar5,n_actions,0x18,action_sort);
  }
  iVar7 = n_actions;
  local_20 = -1;
  iVar8 = n_actions;
  while (iVar4 = iVar8, local_24 = iVar4 + -1, local_20 < local_24) {
    while( true ) {
      iVar8 = (iVar4 + local_20) / 2;
      pHVar5 = all_actions + iVar8;
      iVar3 = strcmp((pHVar5->action).name,name);
      if (iVar3 == 0) goto LAB_080d5725;
      if (0 < iVar3) break;
      local_20 = iVar8;
      if (local_24 <= iVar8) goto LAB_080d56f0;
    }
  }
LAB_080d56f0:
  if (0 < iVar7) {
    iVar8 = 0;
    pHVar5 = all_actions;
    do {
      iVar4 = strcasecmp((pHVar5->action).name,name);
      if (iVar4 == 0) {
LAB_080d5725:
        if (context == (void **)0x0) {
          return &pHVar5->action;
        }
        *context = pHVar5->context;
        return &pHVar5->action;
      }
      iVar8 = iVar8 + 1;
      pHVar5 = pHVar5 + 1;
    } while (iVar8 < iVar7);
  }
  __printf_chk(1,"unknown action `%s\'\n",name);
  return (HID_Action *)0x0;
}



// WARNING: Unknown calling convention

int hid_actionv(char *name,int argc,char **argv)

{
  void *pvVar1;
  HID_Action *pHVar2;
  int iVar3;
  int ret;
  char *pcVar4;
  HID_Action *a;
  char *pcVar5;
  int i;
  void *old_context;
  void *local_28;
  int local_24;
  int local_20 [4];
  
  local_20[0] = 0;
  local_24 = 0;
  if ((name != (char *)0x0) && (Settings.verbose != 0)) {
    pcVar4 = name;
    __printf_chk(1,&DAT_0815012d,name);
    if (0 < argc) {
      pcVar5 = *argv;
      iVar3 = 0;
      pcVar4 = "";
      while( true ) {
        iVar3 = iVar3 + 1;
        __printf_chk(1,&DAT_08148644,pcVar4,pcVar5);
        if (argc <= iVar3) break;
        pcVar5 = argv[iVar3];
        pcVar4 = ",";
      }
    }
    __printf_chk(1,&DAT_0815013e,pcVar4);
  }
  pHVar2 = hid_find_action(name,&local_28);
  iVar3 = 1;
  if (pHVar2 != (HID_Action *)0x0) {
    if (pHVar2->need_coord_msg != (char *)0x0) {
      (*gui->get_coords)(pHVar2->need_coord_msg,local_20,&local_24);
    }
    pvVar1 = hid_action_context;
    hid_action_context = local_28;
    iVar3 = (*pHVar2->trigger_cb)(argc,argv,local_20[0],local_24);
    hid_action_context = pvVar1;
  }
  return iVar3;
}



// WARNING: Unknown calling convention

int hid_actionl(char *name,...)

{
  int iVar1;
  int argc;
  char *arg;
  char *pcVar2;
  char *in_stack_00000008;
  char *argv [20];
  
  iVar1 = 0;
  pcVar2 = in_stack_00000008;
  if (in_stack_00000008 != (char *)0x0) {
    do {
      argv[iVar1] = pcVar2;
      iVar1 = iVar1 + 1;
      pcVar2 = (&stack0x00000008)[iVar1];
    } while (pcVar2 != (char *)0x0);
  }
  iVar1 = hid_actionv(name,iVar1,argv);
  return iVar1;
}



// WARNING: Unknown calling convention

int hid_action(char *name)

{
  int iVar1;
  
  iVar1 = hid_actionv(name,0,(char **)0x0);
  return iVar1;
}



// WARNING: Unknown calling convention

void dump_actions(void)

{
  undefined4 *puVar1;
  char *desc;
  char *str;
  char *synt;
  char *str_00;
  int iVar2;
  int iVar3;
  int i;
  
  hid_find_action(hid_action_nodes->actions->name,(void **)0x0);
  if (0 < n_actions) {
    iVar3 = 0;
    iVar2 = 0;
    do {
      puVar1 = (undefined4 *)((int)&(all_actions->action).name + iVar2);
      str = (char *)puVar1[3];
      str_00 = (char *)puVar1[4];
      if (str == (char *)0x0) {
        str = "";
      }
      if (str_00 == (char *)0x0) {
        str_00 = "";
      }
      iVar3 = iVar3 + 1;
      iVar2 = iVar2 + 0x18;
      __printf_chk(1,&DAT_08150145,*puVar1);
      dump_string('D',str);
      dump_string('S',str_00);
    } while (iVar3 < n_actions);
  }
  return;
}



// WARNING: Unknown calling convention

void print_actions(void)

{
  char cVar1;
  undefined4 *puVar2;
  char *eb;
  char *pcVar3;
  char *bb;
  char *__ptr;
  size_t __size;
  int local_24;
  int local_20;
  
  hid_find_action(hid_action_nodes->actions->name,(void **)0x0);
  __fprintf_chk(stderr,1,"Registered Actions:\n");
  if (0 < n_actions) {
    local_20 = 0;
    local_24 = 0;
    do {
      puVar2 = (undefined4 *)((int)&(all_actions->action).name + local_20);
      if (puVar2[3] == 0) {
        __fprintf_chk(stderr,1,"  %s\n",*puVar2);
      }
      else {
        __fprintf_chk(stderr,1,"  %s - %s\n",*puVar2,puVar2[3]);
      }
      __ptr = *(char **)((int)&(all_actions->action).syntax + local_20);
      if (__ptr != (char *)0x0) {
        cVar1 = *__ptr;
        pcVar3 = __ptr;
        if (cVar1 == '\n') goto LAB_080d5b90;
        do {
          pcVar3 = __ptr;
          if (cVar1 == '\0') goto LAB_080d5b90;
          do {
            pcVar3 = pcVar3 + 1;
            if (*pcVar3 == '\n') break;
          } while (*pcVar3 != '\0');
          __size = (int)pcVar3 - (int)__ptr;
          while( true ) {
            fwrite(&DAT_0815672d,4,1,stderr);
            fwrite(__ptr,__size,1,stderr);
            fputc(10,stderr);
            if (*pcVar3 == '\0') goto LAB_080d5b98;
            __ptr = pcVar3 + 1;
            cVar1 = *__ptr;
            pcVar3 = __ptr;
            if (cVar1 != '\n') break;
LAB_080d5b90:
            __size = 0;
            __ptr = pcVar3;
          }
        } while( true );
      }
LAB_080d5b98:
      local_24 = local_24 + 1;
      local_20 = local_20 + 0x18;
    } while (local_24 < n_actions);
  }
  return;
}



// WARNING: Unknown calling convention

void hid_register_actions_context(HID_Action *a,int n,void *context,int dynamic)

{
  char *pcVar1;
  HID_ActionContext *__ptr;
  HID_ActionNode *pHVar2;
  HID_ActionNode *pHVar3;
  HID_Action *pHVar4;
  
  pHVar3 = (HID_ActionNode *)malloc(0x14);
  pHVar2 = pHVar3;
  pHVar3->next = hid_action_nodes;
  hid_action_nodes = pHVar2;
  if (dynamic == 0) {
    pHVar3->actions = a;
  }
  else {
    pHVar4 = (HID_Action *)malloc(0x14);
    pcVar1 = a->name;
    pHVar3->actions = pHVar4;
    pHVar4->name = pcVar1;
    pHVar4->need_coord_msg = a->need_coord_msg;
    pHVar4->trigger_cb = a->trigger_cb;
    pHVar4->description = a->description;
    pHVar4->syntax = a->syntax;
  }
  n_actions = n_actions + n;
  pHVar3->n = n;
  pHVar3->dynamic = dynamic;
  __ptr = all_actions;
  pHVar3->context = context;
  if (__ptr != (HID_ActionContext *)0x0) {
    free(__ptr);
    all_actions = (HID_ActionContext *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void hid_register_action(HID_Action *a,void *context)

{
  hid_register_actions_context(a,1,context,1);
  return;
}



// WARNING: Unknown calling convention

void hid_register_actions(HID_Action *a,int n)

{
  hid_register_actions_context(a,n,(void *)0x0,0);
  return;
}



// WARNING: Unknown calling convention

void hid_save_and_show_layer_ons(int *save_array)

{
  DataTypePtr paVar1;
  int i;
  int iVar2;
  DataTypePtr paVar3;
  
  paVar1 = PCB->Data;
  if (-2 < paVar1->LayerN) {
    iVar2 = 0;
    paVar3 = paVar1;
    do {
      save_array[iVar2] = (int)paVar1->Layer[iVar2].On;
      iVar2 = iVar2 + 1;
      paVar3->Layer[0].On = '\x01';
      paVar3 = (DataTypePtr)&paVar3->Layer[0].ArcN;
    } while (iVar2 <= paVar1->LayerN + 1);
  }
  return;
}



// WARNING: Unknown calling convention

void hid_restore_layer_ons(int *save_array)

{
  int *piVar1;
  int iVar2;
  int i;
  int iVar3;
  DataTypePtr paVar4;
  
  paVar4 = PCB->Data;
  iVar2 = paVar4->LayerN;
  if (-2 < iVar2) {
    iVar3 = 0;
    do {
      piVar1 = save_array + iVar3;
      iVar3 = iVar3 + 1;
      paVar4->Layer[0].On = (Boolean)*piVar1;
      paVar4 = (DataTypePtr)&paVar4->Layer[0].ArcN;
    } while (iVar3 <= iVar2 + 1);
  }
  return;
}



// WARNING: Unknown calling convention

char * layer_type_to_file_name(int idx)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  int group;
  
  switch(idx) {
  case -0xfef:
    pcVar3 = "frontsilk";
    break;
  case -0xfee:
    pcVar3 = "backsilk";
    break;
  default:
    iVar1 = GetLayerGroupNumberByNumber(idx);
    iVar2 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
    pcVar3 = "front";
    if (iVar1 != iVar2) {
      iVar2 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
      pcVar3 = "back";
      if (iVar1 != iVar2) {
        if ((PCB->LayerGroups).Number[iVar1] == 1) {
          pcVar3 = PCB->Data->Layer[idx].Name;
          iVar2 = strcasecmp(pcVar3,"route");
          if ((iVar2 == 0) || (iVar2 = strcasecmp(pcVar3,"outline"), iVar2 == 0)) {
            return "outline";
          }
        }
        __sprintf_chk(layer_type_to_file_name::lexical_block_0::buf,1,0x14,"group%d",iVar1);
        pcVar3 = layer_type_to_file_name::lexical_block_0::buf;
      }
    }
    break;
  case -0xfdf:
    pcVar3 = "frontmask";
    break;
  case -0xfde:
    pcVar3 = "backmask";
    break;
  case -0xfd0:
    pcVar3 = "plated-drill";
    break;
  case -0xfc0:
    pcVar3 = "unplated-drill";
    break;
  case -0xfaf:
    pcVar3 = "frontpaste";
    break;
  case -0xfae:
    pcVar3 = "backpaste";
    break;
  case -4000:
    pcVar3 = "invisible";
    break;
  case -0xf90:
    pcVar3 = "fab";
    break;
  case -0xf7f:
    pcVar3 = "frontassembly";
    break;
  case -0xf7e:
    pcVar3 = "backassembly";
  }
  return pcVar3;
}



// WARNING: Unknown calling convention

int flag_sort(void *va,void *vb)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = strcmp(*va,*vb);
  return iVar1;
}



// WARNING: Unknown calling convention

HID_Flag * hid_find_flag(char *name)

{
  HID_Flag *pHVar1;
  bool bVar2;
  int n;
  int iVar3;
  HID_Flag *pHVar4;
  int iVar5;
  int iVar6;
  int i;
  HID_FlagNode *hf;
  int upper;
  HID_FlagNode *pHVar7;
  bool bVar8;
  int local_24;
  int local_20;
  
  if (all_flags == (HID_Flag *)0x0) {
    pHVar4 = (HID_Flag *)calloc(1,n_flags * 0xc);
    local_20 = 0;
    pHVar7 = hid_flag_nodes;
    all_flags = pHVar4;
    if (hid_flag_nodes != (HID_FlagNode *)0x0) {
      while( true ) {
        local_24 = local_20;
        if (0 < pHVar7->n) {
          iVar3 = 0;
          pHVar1 = pHVar7->flags;
          iVar5 = 1;
          do {
            *(undefined4 *)((int)&pHVar4[local_20].name + iVar3) =
                 *(undefined4 *)((int)&pHVar1->name + iVar3);
            *(undefined4 *)((int)&pHVar4[local_20].function + iVar3) =
                 *(undefined4 *)((int)&pHVar1->function + iVar3);
            *(undefined4 *)((int)&pHVar4[local_20].parm + iVar3) =
                 *(undefined4 *)((int)&pHVar1->parm + iVar3);
            iVar3 = iVar3 + 0xc;
            local_24 = local_20 + iVar5;
            bVar8 = pHVar7->n != iVar5;
            bVar2 = iVar5 <= pHVar7->n;
            iVar5 = iVar5 + 1;
          } while (bVar8 && bVar2);
        }
        if (pHVar7->next == (HID_FlagNode *)0x0) break;
        local_20 = local_24;
        pHVar7 = pHVar7->next;
      }
    }
    qsort(pHVar4,n_flags,0xc,flag_sort);
  }
  local_20 = -1;
  local_24 = n_flags;
  iVar5 = n_flags + 1;
  while (local_20 < local_24) {
    while( true ) {
      iVar6 = (iVar5 + local_20) / 2;
      pHVar4 = all_flags + iVar6;
      iVar3 = strcmp(pHVar4->name,name);
      if (iVar3 == 0) {
        return pHVar4;
      }
      if (0 < iVar3) break;
      local_20 = iVar6;
      if (local_24 <= iVar6) goto LAB_080d5f70;
    }
    iVar5 = iVar6;
    local_24 = iVar6 + -1;
  }
LAB_080d5f70:
  __printf_chk(1,"unknown flag `%s\'\n",name);
  return (HID_Flag *)0x0;
}



// WARNING: Unknown calling convention

int hid_get_flag(char *name)

{
  char *pcVar1;
  long lVar2;
  HID_Flag *pHVar3;
  HID_Flag *f;
  int iVar4;
  size_t __n;
  int wv;
  
  pcVar1 = strchr(name,0x2c);
  if (pcVar1 == (char *)0x0) {
    pHVar3 = hid_find_flag(name);
    if (pHVar3 != (HID_Flag *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080d6161. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar4 = (*pHVar3->function)(pHVar3->parm);
      return iVar4;
    }
  }
  else {
    __n = (int)pcVar1 - (int)name;
    if (hid_get_flag::nbuf <= (int)__n) {
      hid_get_flag::nbuf = __n + 10;
      hid_get_flag::buf = (char *)MyRealloc(hid_get_flag::buf,hid_get_flag::nbuf,"hid_get_flag");
    }
    memcpy(hid_get_flag::buf,name,__n);
    hid_get_flag::buf[__n] = '\0';
    lVar2 = strtol(pcVar1 + 1,(char **)0x0,0);
    pHVar3 = hid_find_flag(hid_get_flag::buf);
    if (pHVar3 != (HID_Flag *)0x0) {
      iVar4 = (*pHVar3->function)(pHVar3->parm);
      return (uint)(lVar2 == iVar4);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void hid_register_flags(HID_Flag *a,int n)

{
  HID_FlagNode *pHVar1;
  
  pHVar1 = (HID_FlagNode *)calloc(1,0xc);
  pHVar1->next = hid_flag_nodes;
  pHVar1->n = n;
  n_flags = n_flags + n;
  hid_flag_nodes = pHVar1;
  pHVar1->flags = a;
  if (all_flags != (HID_Flag *)0x0) {
    free(all_flags);
    all_flags = (HID_Flag *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void hid_register_gui(HID *Pgui,_func_void_int_ptr_char_ptr_ptr_ptr *func)

{
  if (gui_start != (_func_void_int_ptr_char_ptr_ptr_ptr *)0x0) {
    return;
  }
  default_gui = Pgui;
  gui_start = func;
  return;
}



// WARNING: Unknown calling convention

HID * hid_find_printer(void)

{
  byte bVar1;
  HID *pHVar2;
  int i;
  int iVar3;
  
  if (hid_num_hids < 1) {
LAB_080d6232:
    pHVar2 = (HID *)0x0;
  }
  else {
    iVar3 = 0;
    pHVar2 = *hid_list;
    bVar1 = pHVar2->field_0xc;
    while ((bVar1 & 2) == 0) {
      iVar3 = iVar3 + 1;
      if (hid_num_hids <= iVar3) goto LAB_080d6232;
      pHVar2 = hid_list[iVar3];
      bVar1 = pHVar2->field_0xc;
    }
  }
  return pHVar2;
}



// WARNING: Unknown calling convention

HID ** hid_enumerate(void)

{
  return hid_list;
}



// WARNING: Unknown calling convention

void hid_register_attributes(HID_Attribute *a,int n)

{
  HID_AttrNode *pHVar1;
  
  pHVar1 = (HID_AttrNode *)calloc(1,0xc);
  pHVar1->next = hid_attr_nodes;
  hid_attr_nodes = pHVar1;
  pHVar1->attributes = a;
  pHVar1->n = n;
  return;
}



// WARNING: Unknown calling convention

void copy_color(int set,hidval *cval,hidval *aval)

{
  if (set == 0) {
    *aval = *cval;
    return;
  }
  *cval = *aval;
  return;
}



// WARNING: Unknown calling convention

int hid_cache_color(int set,char *name,hidval *val,void **vcache)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  uint uVar6;
  ulong hash;
  char *cp;
  byte *pbVar7;
  ecache *e;
  uint uVar8;
  void *local_20;
  
  local_20 = *vcache;
  if (local_20 == (void *)0x0) {
    local_20 = calloc(0x80,1);
    *vcache = local_20;
  }
  iVar3 = *(int *)((int)local_20 + 0x7c);
  if ((iVar3 != 0) && (iVar2 = strcmp(*(char **)(iVar3 + 4),name), iVar2 == 0)) {
    copy_color(set,(hidval *)(iVar3 + 8),val);
    return 1;
  }
  bVar1 = *name;
  uVar6 = 0;
  uVar8 = 0;
  pbVar7 = (byte *)name;
  if (bVar1 != 0) {
    do {
      uVar6 = uVar6 * 0x21 + (uint)bVar1;
      bVar1 = pbVar7[1];
      pbVar7 = pbVar7 + 1;
    } while (bVar1 != 0);
    uVar8 = uVar6 % 0x1f;
  }
  puVar4 = *(undefined4 **)((int)local_20 + uVar8 * 4);
  while( true ) {
    if (puVar4 == (undefined4 *)0x0) {
      if (set == 0) {
        return 0;
      }
      puVar4 = (undefined4 *)calloc(1,0xc);
      *puVar4 = *(undefined4 *)((int)local_20 + uVar8 * 4);
      *(undefined4 **)((int)local_20 + uVar8 * 4) = puVar4;
      uVar5 = __strdup(name);
      puVar4[1] = uVar5;
      *(hidval *)(puVar4 + 2) = *val;
      *(undefined4 **)((int)local_20 + 0x7c) = puVar4;
      return 1;
    }
    iVar3 = strcmp((char *)puVar4[1],name);
    if (iVar3 == 0) break;
    puVar4 = (undefined4 *)*puVar4;
  }
  copy_color(set,(hidval *)(puVar4 + 2),val);
  *(undefined4 **)((int)local_20 + 0x7c) = puVar4;
  return 1;
}



// WARNING: Unknown calling convention

void derive_default_filename
               (char *pcbfile,HID_Attribute *filename_attrib,char *suffix,char **memory)

{
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  char *pf;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  byte bVar7;
  char *local_20;
  
  bVar7 = 0;
  if (pcbfile == (char *)0x0) {
    pf = (char *)calloc(1,0xc);
    if ((undefined4 *)pf == (undefined4 *)0x0) {
      return;
    }
    *(undefined4 *)pf = 0x6e6b6e75;
    *(undefined4 *)((int)pf + 4) = 0x2e6e776f;
    *(undefined4 *)((int)pf + 8) = 0x626370;
  }
  else {
    pf = (char *)__strdup(pcbfile);
  }
  if (pf == (char *)0x0) {
    return;
  }
  if (memory == (char **)0x0) {
    sVar1 = strlen(pf);
    sVar2 = strlen(suffix);
    local_20 = (char *)calloc(1,sVar1 + 1 + sVar2);
  }
  else {
    if ((filename_attrib->default_val).str_value != *memory) {
      return;
    }
    sVar1 = strlen(pf);
    sVar2 = strlen(suffix);
    local_20 = (char *)calloc(1,sVar1 + 1 + sVar2);
    *memory = local_20;
  }
  if (local_20 != (char *)0x0) {
    strcpy(local_20,pf);
    sVar1 = strlen(local_20);
    bVar6 = sVar1 == 4;
    if (4 < sVar1) {
      iVar3 = 5;
      pcVar4 = local_20 + (sVar1 - 4);
      pcVar5 = ".pcb";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar6 = *pcVar4 == *pcVar5;
        pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
        pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
      } while (bVar6);
      if (bVar6) {
        local_20[sVar1 - 4] = '\0';
      }
    }
    strcat(local_20,suffix);
    pcVar4 = (filename_attrib->default_val).str_value;
    if (pcVar4 != (char *)0x0) {
      free(pcVar4);
    }
    (filename_attrib->default_val).str_value = local_20;
  }
  free(pf);
  return;
}



// WARNING: Unknown calling convention

HID * hid_find_exporter(char *which)

{
  HID *pHVar1;
  HID **ppHVar2;
  int iVar3;
  int iVar4;
  int i;
  int iVar5;
  
  iVar5 = hid_num_hids;
  ppHVar2 = hid_list;
  if (0 < hid_num_hids) {
    iVar4 = 0;
    do {
      pHVar1 = ppHVar2[iVar4];
      if (((pHVar1->field_0xc & 4) != 0) && (iVar3 = strcmp(which,pHVar1->name), iVar3 == 0)) {
        return pHVar1;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < iVar5);
  }
  __fprintf_chk(stderr,1,"Invalid exporter %s, available ones:",which);
  if (0 < hid_num_hids) {
    iVar5 = 0;
    do {
      while ((hid_list[iVar5]->field_0xc & 4) == 0) {
        iVar5 = iVar5 + 1;
        if (hid_num_hids <= iVar5) goto LAB_080d6690;
      }
      which = hid_list[iVar5]->name;
      iVar5 = iVar5 + 1;
      __fprintf_chk(stderr,1," %s",which);
    } while (iVar5 < hid_num_hids);
  }
LAB_080d6690:
  __fprintf_chk(stderr,1,"\n",which);
  return (HID *)0x0;
}



// WARNING: Unknown calling convention

HID * hid_find_gui(void)

{
  byte bVar1;
  HID *pHVar2;
  int iVar3;
  int i;
  
  if (0 < hid_num_hids) {
    iVar3 = 0;
    pHVar2 = *hid_list;
    bVar1 = pHVar2->field_0xc;
    while( true ) {
      if ((bVar1 & 6) == 0) {
        return pHVar2;
      }
      iVar3 = iVar3 + 1;
      if (hid_num_hids <= iVar3) break;
      pHVar2 = hid_list[iVar3];
      bVar1 = pHVar2->field_0xc;
    }
  }
  __fprintf_chk(stderr,1,"Error: No GUI available.\n");
                    // WARNING: Subroutine does not return
  exit(1);
}



// WARNING: Unknown calling convention

void hid_load_settings_1(char *fname)

{
  char **ppcVar1;
  HID_AttrNode *pHVar2;
  FILE *__stream;
  char *pcVar3;
  ushort **ppuVar4;
  size_t sVar5;
  char *cp;
  char *pcVar6;
  int iVar7;
  char *__s1;
  char cVar8;
  int e;
  char *namep;
  char **ppcVar9;
  char *pcVar10;
  char *valp;
  char *__s;
  int iVar11;
  int i;
  int iVar12;
  int in_GS_OFFSET;
  double dVar13;
  char line [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen(fname,"r");
  if (__stream == (FILE *)0x0) {
    free(fname);
  }
  else {
    free(fname);
LAB_080d6770:
    pcVar3 = fgets(line,0x400,__stream);
    cVar8 = line[0];
    if (pcVar3 != (char *)0x0) {
      if (line[0] != '\0') {
        pcVar3 = line;
        ppuVar4 = __ctype_b_loc();
        do {
          if ((*(byte *)((int)*ppuVar4 + cVar8 * 2 + 1) & 0x20) == 0) {
            if ((cVar8 != '#') && (cVar8 = *pcVar3, cVar8 != '\0')) {
              ppuVar4 = __ctype_b_loc();
              pcVar6 = pcVar3;
              goto LAB_080d680e;
            }
            break;
          }
          pcVar3 = pcVar3 + 1;
          cVar8 = *pcVar3;
        } while (cVar8 != '\0');
      }
      goto LAB_080d6770;
    }
    fclose(__stream);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
  while( true ) {
    pcVar6 = pcVar6 + 1;
    cVar8 = *pcVar6;
    if (cVar8 == '\0') break;
LAB_080d680e:
    if ((*(byte *)((int)*ppuVar4 + cVar8 * 2 + 1) & 0x20) != 0) {
      *pcVar6 = '\0';
      __s = pcVar6 + 1;
      cVar8 = pcVar6[1];
      if (cVar8 != '\0') {
        goto LAB_080d683e;
      }
      break;
    }
  }
  goto LAB_080d6770;
LAB_080d683e:
  if (((*(byte *)((int)*ppuVar4 + cVar8 * 2 + 1) & 0x20) != 0) || (cVar8 == '=')) {
    __s = __s + 1;
    cVar8 = *__s;
    if (cVar8 == '\0') goto LAB_080d6770;
    goto LAB_080d683e;
  }
  sVar5 = strlen(__s);
  pcVar6 = __s + (sVar5 - 1);
  while ((pHVar2 = hid_attr_nodes, __s <= pcVar6 &&
         ((*(byte *)((int)*ppuVar4 + *pcVar6 * 2 + 1) & 0x20) != 0))) {
    *pcVar6 = '\0';
    pcVar6 = pcVar6 + -1;
  }
  for (; pHVar2 != (HID_AttrNode *)0x0; pHVar2 = pHVar2->next) {
    iVar11 = 0;
    iVar12 = 0;
    if (0 < pHVar2->n) {
      do {
        ppcVar9 = (char **)((int)&pHVar2->attributes->name + iVar11);
        pcVar6 = *ppcVar9;
        iVar7 = strcmp(pcVar3,pcVar6);
        if (iVar7 == 0) {
          switch(ppcVar9[2]) {
          case (char *)0x1:
            pcVar6 = (char *)strtol(__s,(char **)0x0,0);
            ppcVar9[5] = pcVar6;
            break;
          case (char *)0x2:
            dVar13 = strtod(__s,(char **)0x0);
            *(double *)(ppcVar9 + 7) = dVar13;
            break;
          case (char *)0x3:
            pcVar6 = (char *)__strdup(__s);
            ppcVar9[6] = pcVar6;
            break;
          case (char *)0x4:
            ppcVar9[5] = &DAT_00000001;
            break;
          case (char *)0x5:
            ppcVar1 = (char **)ppcVar9[9];
            __s1 = *ppcVar1;
            if (__s1 == (char *)0x0) {
LAB_080d6a29:
              __fprintf_chk(stderr,1,"ERROR:  \"%s\" is an unknown value for the %s option\n",__s,
                            pcVar6);
                    // WARNING: Subroutine does not return
              exit(1);
            }
            pcVar10 = (char *)0x0;
            while (iVar7 = strcmp(__s1,__s), iVar7 != 0) {
              pcVar10 = pcVar10 + 1;
              __s1 = ppcVar1[(int)pcVar10];
              if (__s1 == (char *)0x0) goto LAB_080d6a29;
            }
            ppcVar9[5] = pcVar10;
            ppcVar9[6] = __s;
            break;
          case (char *)0x6:
                    // WARNING: Subroutine does not return
            abort();
          case (char *)0x7:
            ppcVar9[6] = __s;
          }
        }
        iVar12 = iVar12 + 1;
        iVar11 = iVar11 + 0x30;
      } while (iVar12 < pHVar2->n);
    }
  }
  goto LAB_080d6770;
}



// WARNING: Unknown calling convention

void hid_load_settings(void)

{
  byte *pbVar1;
  int rv;
  uint uVar2;
  char *pcVar3;
  int i_1;
  int iVar4;
  HID_Attribute *pHVar5;
  int i;
  int iVar6;
  HID_AttrNode *ha;
  HID_AttrNode *pHVar7;
  char *pcVar8;
  char *pcVar9;
  
  pHVar7 = hid_attr_nodes;
  if (hid_attr_nodes != (HID_AttrNode *)0x0) {
    do {
      if (0 < pHVar7->n) {
        pHVar5 = pHVar7->attributes;
        iVar6 = 0;
        do {
          iVar4 = 0;
          uVar2 = 0;
          do {
            pbVar1 = (byte *)((int)&pHVar5->name + iVar4);
            iVar4 = iVar4 + 1;
            uVar2 = (int)uVar2 >> 0x10 ^ uVar2 * 0xd ^ (uint)*pbVar1;
          } while (iVar4 != 0x2c);
          pHVar5->hash = uVar2;
          iVar6 = iVar6 + 1;
          pHVar5 = pHVar5 + 1;
        } while (pHVar7->n != iVar6 && iVar6 <= pHVar7->n);
      }
      pHVar7 = pHVar7->next;
    } while (pHVar7 != (HID_AttrNode *)0x0);
  }
  pcVar9 = (char *)0x0;
  pcVar8 = "settings";
  pcVar3 = Concat(pcblibdir,"/","settings",0);
  hid_load_settings_1(pcVar3);
  if (homedir != (char *)0x0) {
    pcVar9 = "/";
    pcVar8 = ".pcb";
    pcVar3 = Concat(homedir,"/",&DAT_0815492b,"/","settings",0);
    hid_load_settings_1(pcVar3);
  }
  pcVar3 = Concat("pcb.settings",0,pcVar8,pcVar9);
  hid_load_settings_1(pcVar3);
  return;
}



// WARNING: Unknown calling convention

void hid_save_settings(int locally)

{
  byte *pbVar1;
  undefined8 uVar2;
  HID_AttrNode *pHVar3;
  char *__filename;
  int iVar4;
  FILE *__stream;
  uint uVar5;
  int rv;
  char *str;
  undefined4 uVar6;
  int i;
  int iVar7;
  char *fname;
  HID_Attribute *a;
  undefined4 *puVar8;
  HID_AttrNode *ha;
  char *local_8c;
  int local_80;
  stat st;
  
  if (locally == 0) {
    if (homedir == (char *)0x0) {
      return;
    }
    __filename = Concat(homedir,"/",&DAT_0815492b,0);
    iVar4 = __xstat(3,__filename,(stat *)&st);
    if ((iVar4 != 0) && (iVar4 = mkdir(__filename,0x1ff), iVar4 != 0)) {
      free(__filename);
      return;
    }
    free(__filename);
    local_8c = Concat(homedir,"/",&DAT_0815492b,"/","settings",0);
  }
  else {
    local_8c = Concat("pcb.settings",0);
  }
  __stream = fopen(local_8c,"w");
  pHVar3 = hid_attr_nodes;
  if (__stream == (FILE *)0x0) {
    Message("Can\'t open %s",local_8c);
    free(local_8c);
  }
  else {
    for (; pHVar3 != (HID_AttrNode *)0x0; pHVar3 = pHVar3->next) {
      iVar4 = 0;
      local_80 = 0;
      if (0 < pHVar3->n) {
LAB_080d6c50:
        do {
          uVar5 = 0;
          puVar8 = (undefined4 *)((int)&pHVar3->attributes->name + iVar4);
          iVar7 = 0;
          do {
            pbVar1 = (byte *)((int)puVar8 + iVar7);
            iVar7 = iVar7 + 1;
            uVar5 = (int)uVar5 >> 0x10 ^ uVar5 * 0xd ^ (uint)*pbVar1;
          } while (iVar7 != 0x2c);
          if (puVar8[0xb] == uVar5) {
            __fprintf_chk(__stream,1,&DAT_08150595);
          }
          switch(puVar8[2]) {
          case 1:
            if ((undefined4 *)puVar8[10] == (undefined4 *)0x0) {
              uVar6 = puVar8[5];
            }
            else {
              uVar6 = *(undefined4 *)puVar8[10];
            }
            iVar4 = iVar4 + 0x30;
            __fprintf_chk(__stream,1,"%s = %d\n",*puVar8,uVar6);
            local_80 = local_80 + 1;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 2:
            if ((undefined8 *)puVar8[10] == (undefined8 *)0x0) {
              uVar2 = *(undefined8 *)(puVar8 + 7);
            }
            else {
              uVar2 = *(undefined8 *)puVar8[10];
            }
            iVar4 = iVar4 + 0x30;
            __fprintf_chk(__stream,1,"%s = %f\n",*puVar8,uVar2);
            local_80 = local_80 + 1;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 3:
          case 7:
            if ((char **)puVar8[10] == (char **)0x0) {
              str = (char *)puVar8[6];
            }
            else {
              str = *(char **)puVar8[10];
            }
            if (str == (char *)0x0) {
              str = "";
            }
            __fprintf_chk(__stream,1,"%s = %s\n",*puVar8,str);
          default:
            local_80 = local_80 + 1;
            iVar4 = iVar4 + 0x30;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 4:
            if ((char *)puVar8[10] == (char *)0x0) {
              iVar7 = puVar8[5];
            }
            else {
              iVar7 = (int)*(char *)puVar8[10];
            }
            iVar4 = iVar4 + 0x30;
            __fprintf_chk(__stream,1,"%s = %d\n",*puVar8,iVar7);
            local_80 = local_80 + 1;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 5:
            goto switchD_080d6c90_caseD_5;
          case 6:
                    // WARNING: Subroutine does not return
            abort();
          }
        } while( true );
      }
LAB_080d6ce9:
      __fprintf_chk(__stream,1,"\n");
    }
    fclose(__stream);
    free(local_8c);
  }
  return;
switchD_080d6c90_caseD_5:
  if ((int *)puVar8[10] == (int *)0x0) {
    iVar7 = puVar8[5];
  }
  else {
    iVar7 = *(int *)puVar8[10];
  }
  iVar4 = iVar4 + 0x30;
  __fprintf_chk(__stream,1,"%s = %s\n",*puVar8,*(undefined4 *)(puVar8[9] + iVar7 * 4));
  local_80 = local_80 + 1;
  if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
  goto LAB_080d6c50;
}



// WARNING: Unknown calling convention

void hid_parse_command_line(int *argc,char ***argv)

{
  undefined4 *puVar1;
  char *__s2;
  undefined *puVar2;
  undefined8 *puVar3;
  long *plVar4;
  char **ppcVar5;
  double *pdVar6;
  HID_Attribute *a;
  int arg_ofs;
  int iVar7;
  long lVar8;
  char *__s1;
  int i;
  int iVar9;
  int iVar10;
  HID_AttrNode *ha;
  HID_AttrNode *pHVar11;
  HID_Attribute *pHVar12;
  char *ep;
  int e;
  byte *pbVar13;
  byte *pbVar14;
  bool bVar15;
  bool bVar16;
  byte bVar17;
  double dVar18;
  undefined *local_38;
  byte **local_34;
  byte *local_2c;
  HID_AttrNode *local_28;
  
  pHVar11 = hid_attr_nodes;
  bVar17 = 0;
  *argc = *argc + -1;
  *argv = *argv + 1;
  if (pHVar11 != (HID_AttrNode *)0x0) {
    do {
      iVar10 = 0;
      iVar9 = 0;
      if (0 < pHVar11->n) {
        do {
          pHVar12 = pHVar11->attributes;
          if (5 < *(uint *)((int)&pHVar12->type + iVar10)) {
switchD_080d7069_caseD_6:
                    // WARNING: Subroutine does not return
            abort();
          }
          switch(*(undefined4 *)((int)&pHVar12->type + iVar10)) {
          case 0:
            break;
          default:
            puVar1 = *(undefined4 **)((int)&pHVar12->value + iVar10);
            if (puVar1 != (undefined4 *)0x0) {
              *puVar1 = *(undefined4 *)((int)&(pHVar12->default_val).int_value + iVar10);
            }
            break;
          case 2:
            puVar3 = *(undefined8 **)((int)&pHVar12->value + iVar10);
            if (puVar3 != (undefined8 *)0x0) {
              *puVar3 = *(undefined8 *)((int)&(pHVar12->default_val).real_value + iVar10);
            }
            break;
          case 3:
            puVar1 = *(undefined4 **)((int)&pHVar12->value + iVar10);
            if (puVar1 != (undefined4 *)0x0) {
              *puVar1 = *(undefined4 *)((int)&(pHVar12->default_val).str_value + iVar10);
            }
            break;
          case 4:
            puVar2 = *(undefined **)((int)&pHVar12->value + iVar10);
            if (puVar2 != (undefined *)0x0) {
              *puVar2 = (char)*(undefined4 *)((int)&(pHVar12->default_val).int_value + iVar10);
            }
          }
          iVar9 = iVar9 + 1;
          iVar10 = iVar10 + 0x30;
        } while (pHVar11->n != iVar9 && iVar9 <= pHVar11->n);
      }
      pHVar11 = pHVar11->next;
    } while (pHVar11 != (HID_AttrNode *)0x0);
  }
  iVar9 = *argc;
  if (iVar9 == 0) {
LAB_080d729e:
    iVar9 = 1;
  }
  else {
    local_34 = (byte **)*argv;
    local_2c = *local_34;
    if ((*local_2c == 0x2d) && (local_2c[1] == 0x2d)) {
      do {
        pHVar11 = hid_attr_nodes;
        local_38 = &DAT_00000001;
        arg_ofs = 2;
        while (pHVar11 == (HID_AttrNode *)0x0) {
LAB_080d7150:
          bVar15 = local_38 == (undefined *)0x0;
          bVar16 = local_38 == &DAT_00000001;
          if (!bVar16) goto LAB_080d717f;
          iVar9 = 5;
          arg_ofs = 5;
          pbVar13 = local_2c;
          pbVar14 = (byte *)"--no-";
          do {
            if (iVar9 == 0) break;
            iVar9 = iVar9 + -1;
            bVar15 = *pbVar13 < *pbVar14;
            bVar16 = *pbVar13 == *pbVar14;
            pbVar13 = pbVar13 + (uint)bVar17 * -2 + 1;
            pbVar14 = pbVar14 + (uint)bVar17 * -2 + 1;
          } while (bVar16);
          local_38 = (undefined *)0x0;
          if ((!bVar15 && !bVar16) != bVar15) {
LAB_080d717f:
            __fprintf_chk(stderr,1,"unrecognized option: %s\n",local_2c);
                    // WARNING: Subroutine does not return
            exit(1);
          }
        }
        local_28 = pHVar11;
LAB_080d7018:
        iVar9 = local_28->n;
        if (iVar9 < 1) goto LAB_080d7140;
        iVar10 = 0;
        pHVar12 = local_28->attributes;
        while( true ) {
          __s2 = pHVar12->name;
          iVar7 = strcmp((char *)(local_2c + arg_ofs),__s2);
          if (iVar7 == 0) break;
          iVar10 = iVar10 + 1;
          pHVar12 = pHVar12 + 1;
          if (iVar9 <= iVar10) goto LAB_080d7140;
        }
        switch(pHVar12->type) {
        default:
          break;
        case CONFIG_PAGE_COLUMN:
          plVar4 = (long *)pHVar12->value;
          if (plVar4 == (long *)0x0) {
            lVar8 = strtol((char *)local_34[1],(char **)0x0,0);
            (pHVar12->default_val).int_value = lVar8;
          }
          else {
            lVar8 = strtol((char *)local_34[1],(char **)0x0,0);
            *plVar4 = lVar8;
          }
          *argc = *argc + -1;
          *argv = *argv + 1;
          break;
        case DBUS_BUS_STARTER:
          pdVar6 = (double *)pHVar12->value;
          if (pdVar6 == (double *)0x0) {
            dVar18 = strtod((char *)local_34[1],(char **)0x0);
            (pHVar12->default_val).real_value = dVar18;
          }
          else {
            dVar18 = strtod((char *)local_34[1],(char **)0x0);
            *pdVar6 = dVar18;
          }
          goto LAB_080d7225;
        case GDK_CAP_PROJECTING:
          if ((byte **)pHVar12->value == (byte **)0x0) {
            (pHVar12->default_val).str_value = (char *)local_34[1];
          }
          else {
            *(byte **)pHVar12->value = local_34[1];
          }
          goto LAB_080d7225;
        case DBUS_WATCH_ERROR:
          if ((undefined *)pHVar12->value == (undefined *)0x0) {
            (pHVar12->default_val).int_value = (int)local_38;
          }
          else {
            *(undefined *)pHVar12->value = local_38._0_1_;
          }
          break;
        case GDK_AND_REVERSE:
          ppcVar5 = pHVar12->enumerations;
          pbVar13 = local_34[1];
          __s1 = *ppcVar5;
          if (__s1 == (char *)0x0) goto LAB_080d725a;
          iVar9 = 0;
          while (iVar10 = strcmp(__s1,(char *)pbVar13), iVar10 != 0) {
            iVar9 = iVar9 + 1;
            __s1 = ppcVar5[iVar9];
            if (__s1 == (char *)0x0) {
LAB_080d725a:
              __fprintf_chk(stderr,1,"ERROR:  \"%s\" is an unknown value for the --%s option\n",
                            (*argv)[1],__s2);
                    // WARNING: Subroutine does not return
              exit(1);
            }
          }
          (pHVar12->default_val).int_value = iVar9;
          (pHVar12->default_val).str_value = (char *)pbVar13;
LAB_080d7225:
          *argc = *argc + -1;
          *argv = *argv + 1;
          break;
        case EXPANSION_AREA:
        case GDK_NOOP:
          goto switchD_080d7069_caseD_6;
        }
        ppcVar5 = *argv;
        *argc = *argc + -1;
        local_34 = (byte **)(ppcVar5 + 1);
        *argv = (char **)local_34;
        iVar9 = *argc;
        if (iVar9 == 0) goto LAB_080d729e;
        local_2c = (byte *)ppcVar5[1];
        if ((*local_2c != 0x2d) || (local_2c[1] != 0x2d)) break;
      } while( true );
    }
    iVar9 = iVar9 + 1;
  }
  *argv = *argv + -1;
  *argc = iVar9;
  return;
LAB_080d7140:
  local_28 = local_28->next;
  if (local_28 == (HID_AttrNode *)0x0) goto LAB_080d7150;
  goto LAB_080d7018;
}



// WARNING: Unknown calling convention

void hid_register_hid(HID *hid)

{
  size_t __size;
  HID *pHVar1;
  int iVar2;
  int i;
  HID **ppHVar3;
  
  if (hid->struct_size != 0xd0) {
    __fprintf_chk(stderr,1,"Warning: hid \"%s\" has an incompatible ABI.\n",hid->name);
    return;
  }
  if (hid_num_hids < 1) {
LAB_080d733c:
    __size = hid_num_hids * 4 + 8;
    hid_num_hids = hid_num_hids + 1;
    if (hid_list == (HID **)0x0) {
      ppHVar3 = (HID **)calloc(1,__size);
    }
    else {
      ppHVar3 = (HID **)realloc(hid_list,__size);
    }
    iVar2 = hid_num_hids;
    hid_list = ppHVar3;
    ppHVar3[hid_num_hids + -1] = hid;
    ppHVar3[iVar2] = (HID *)0x0;
  }
  else {
    iVar2 = 0;
    pHVar1 = *hid_list;
    while (pHVar1 != hid) {
      iVar2 = iVar2 + 1;
      if (hid_num_hids <= iVar2) goto LAB_080d733c;
      pHVar1 = hid_list[iVar2];
    }
  }
  return;
}



// WARNING: Unknown calling convention

void hid_load_dir(char *dirname)

{
  DIR *__dirp;
  char *__filename;
  dirent *pdVar1;
  dirent *de;
  char *__s;
  size_t sVar2;
  int iVar3;
  char *__ptr;
  code *pcVar4;
  void *sym;
  undefined4 uVar5;
  char *basename;
  char *path;
  void *so;
  stat st;
  
  __dirp = opendir(dirname);
  if (__dirp != (DIR *)0x0) {
    while (pdVar1 = readdir(__dirp), pdVar1 != (dirent *)0x0) {
      __s = (char *)__strdup(pdVar1->d_name);
      sVar2 = strlen(__s);
      if (3 < sVar2) {
        iVar3 = strcasecmp(__s + (sVar2 - 3),".so");
        if (iVar3 == 0) {
          __s[sVar2 - 3] = '\0';
        }
        else if (sVar2 != 4) {
          iVar3 = strcasecmp(__s + (sVar2 - 4),".dll");
          if (iVar3 == 0) {
            __s[sVar2 - 4] = '\0';
          }
        }
      }
      __filename = Concat(dirname,"/",pdVar1->d_name,0);
      iVar3 = __xstat(3,__filename,(stat *)&st);
      if (((iVar3 == 0) && ((st.st_mode & 0x49) != 0)) && ((st.st_mode & 0xf000) == 0x8000)) {
        iVar3 = dlopen(__filename,0x102);
        if (iVar3 == 0) {
          uVar5 = dlerror();
          __fprintf_chk(stderr,1,"dl_error: %s\n",uVar5);
        }
        else {
          __ptr = Concat("hid_",__s,"_init",0);
          pcVar4 = (code *)dlsym(iVar3,__ptr);
          if ((pcVar4 != (code *)0x0) ||
             (pcVar4 = (code *)dlsym(iVar3,"pcb_plugin_init"), pcVar4 != (code *)0x0)) {
            (*pcVar4)();
          }
          free(__ptr);
        }
      }
      free(__s);
      free(__filename);
    }
  }
  free(dirname);
  return;
}



// WARNING: Unknown calling convention

void hid_init(void)

{
  char *pcVar1;
  char *pcVar2;
  char *pcVar3;
  char *pcVar4;
  undefined4 uVar5;
  char *pcVar6;
  undefined4 uVar7;
  
  gui = &hid_nogui;
  hid_gtk_init();
  hid_lpr_init();
  hid_bom_init();
  hid_gerber_init();
  hid_nelma_init();
  hid_png_init();
  hid_ps_init();
  uVar7 = 0;
  pcVar6 = "i686-pc-linux-gnu";
  pcVar1 = Concat(exec_prefix,"/","lib","/",&DAT_0815492c,"/","plugins","/","i686-pc-linux-gnu",0);
  hid_load_dir(pcVar1);
  uVar5 = 0;
  pcVar4 = "plugins";
  pcVar3 = "/";
  pcVar2 = "pcb";
  pcVar1 = Concat(exec_prefix,"/","lib","/",&DAT_0815492c,"/","plugins",0);
  hid_load_dir(pcVar1);
  if (homedir != (char *)0x0) {
    uVar5 = 0;
    pcVar4 = "i686-pc-linux-gnu";
    pcVar1 = Concat(homedir,"/",&DAT_0815492b,"/","plugins","/","i686-pc-linux-gnu",0,pcVar6,uVar7);
    hid_load_dir(pcVar1);
    pcVar3 = (char *)0x0;
    pcVar2 = "plugins";
    pcVar1 = Concat(homedir,"/",&DAT_0815492b,"/","plugins",0);
    hid_load_dir(pcVar1);
  }
  pcVar1 = Concat("plugins","/","i686-pc-linux-gnu",0,pcVar2,pcVar3,pcVar4,uVar5);
  hid_load_dir(pcVar1);
  pcVar1 = Concat("plugins",0);
  hid_load_dir(pcVar1);
  return;
}



// WARNING: Unknown calling convention

hidGC nogui_make_gc(void)

{
  return (hidGC)0x0;
}



// WARNING: Unknown calling convention

void nogui_destroy_gc(hidGC gc)

{
  return;
}



// WARNING: Unknown calling convention

int nogui_shift_is_pressed(void)

{
  return 0;
}



// WARNING: Unknown calling convention

void nogui_set_crosshair(int x,int y,int action)

{
  return;
}



// WARNING: Unknown calling convention

int nogui_progress(int so_far,int total,char *message)

{
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void apply_default_hid(HID *d,HID *s)

{
  _func_void_HID_Attr_Val_ptr *p_Var1;
  _func_void_int_ptr_char_ptr_ptr_ptr *p_Var2;
  _func_void_int_int_int_int_int *p_Var3;
  _func_void *p_Var4;
  _func_int_char_ptr_int_int *p_Var5;
  _func_hidGC *p_Var6;
  _func_void_hidGC *p_Var7;
  _func_void_int *p_Var8;
  _func_void_hidGC_char_ptr *p_Var9;
  _func_void_hidGC_EndCapStyle *p_Var10;
  _func_void_hidGC_int *p_Var11;
  _func_void_hidGC_int_int_int_int *p_Var12;
  _func_void_hidGC_int_int_int_int_int_int *p_Var13;
  _func_void_hidGC_int_int_int *p_Var14;
  _func_void_hidGC_int_int_ptr_int_ptr *p_Var15;
  _func_void_hidGC_PolygonType_ptr_BoxType_ptr *p_Var16;
  _func_void_double_double *p_Var17;
  _func_int *p_Var18;
  _func_void_char_ptr_int_ptr_int_ptr *p_Var19;
  _func_void_int_int_int *p_Var20;
  _func_hidval__func_void_hidval_ptr_ulong_hidval *p_Var21;
  _func_void_hidval *p_Var22;
  _func_hidval_int_uint__func_void_hidval_int_uint_hidval_ptr_hidval *p_Var23;
  _func_hidval__func_void_hidval_ptr_hidval *p_Var24;
  _func_void_char_ptr_varargs *p_Var25;
  _func_void_char_ptr_va_list *p_Var26;
  _func_int_char_ptr_varargs *p_Var27;
  _func_int_varargs *p_Var28;
  _func_void_char_ptr_char_ptr *p_Var29;
  _func_char_ptr_char_ptr_char_ptr *p_Var30;
  _func_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_int *p_Var31;
  _func_int_HID_Attribute_ptr_int_HID_Attr_Val_ptr_char_ptr_char_ptr *p_Var32;
  _func_void_void_ptr *p_Var33;
  
  if (s == (HID *)0x0) {
    s = &hid_nogui;
  }
  if (d->get_export_options == (_func_HID_Attribute_ptr_int_ptr *)0x0) {
    d->get_export_options = s->get_export_options;
    p_Var1 = d->do_export;
  }
  else {
    p_Var1 = d->do_export;
  }
  if (p_Var1 == (_func_void_HID_Attr_Val_ptr *)0x0) {
    d->do_export = s->do_export;
    p_Var2 = d->parse_arguments;
  }
  else {
    p_Var2 = d->parse_arguments;
  }
  if (p_Var2 == (_func_void_int_ptr_char_ptr_ptr_ptr *)0x0) {
    d->parse_arguments = s->parse_arguments;
    p_Var3 = d->invalidate_wh;
  }
  else {
    p_Var3 = d->invalidate_wh;
  }
  if (p_Var3 == (_func_void_int_int_int_int_int *)0x0) {
    d->invalidate_wh = s->invalidate_wh;
    p_Var3 = d->invalidate_lr;
  }
  else {
    p_Var3 = d->invalidate_lr;
  }
  if (p_Var3 == (_func_void_int_int_int_int_int *)0x0) {
    d->invalidate_lr = s->invalidate_lr;
    p_Var4 = d->invalidate_all;
  }
  else {
    p_Var4 = d->invalidate_all;
  }
  if (p_Var4 == (_func_void *)0x0) {
    d->invalidate_all = s->invalidate_all;
    p_Var5 = d->set_layer;
  }
  else {
    p_Var5 = d->set_layer;
  }
  if (p_Var5 == (_func_int_char_ptr_int_int *)0x0) {
    d->set_layer = s->set_layer;
    p_Var6 = d->make_gc;
  }
  else {
    p_Var6 = d->make_gc;
  }
  if (p_Var6 == (_func_hidGC *)0x0) {
    d->make_gc = s->make_gc;
    p_Var7 = d->destroy_gc;
  }
  else {
    p_Var7 = d->destroy_gc;
  }
  if (p_Var7 == (_func_void_hidGC *)0x0) {
    d->destroy_gc = s->destroy_gc;
    p_Var8 = d->use_mask;
  }
  else {
    p_Var8 = d->use_mask;
  }
  if (p_Var8 == (_func_void_int *)0x0) {
    d->use_mask = s->use_mask;
    p_Var9 = d->set_color;
  }
  else {
    p_Var9 = d->set_color;
  }
  if (p_Var9 == (_func_void_hidGC_char_ptr *)0x0) {
    d->set_color = s->set_color;
    p_Var10 = d->set_line_cap;
  }
  else {
    p_Var10 = d->set_line_cap;
  }
  if (p_Var10 == (_func_void_hidGC_EndCapStyle *)0x0) {
    d->set_line_cap = s->set_line_cap;
    p_Var11 = d->set_line_width;
  }
  else {
    p_Var11 = d->set_line_width;
  }
  if (p_Var11 == (_func_void_hidGC_int *)0x0) {
    d->set_line_width = s->set_line_width;
    p_Var11 = d->set_draw_xor;
  }
  else {
    p_Var11 = d->set_draw_xor;
  }
  if (p_Var11 == (_func_void_hidGC_int *)0x0) {
    d->set_draw_xor = s->set_draw_xor;
    p_Var12 = d->set_line_cap_angle;
  }
  else {
    p_Var12 = d->set_line_cap_angle;
  }
  if (p_Var12 == (_func_void_hidGC_int_int_int_int *)0x0) {
    d->set_line_cap_angle = s->set_line_cap_angle;
    p_Var12 = d->draw_line;
  }
  else {
    p_Var12 = d->draw_line;
  }
  if (p_Var12 == (_func_void_hidGC_int_int_int_int *)0x0) {
    d->draw_line = s->draw_line;
    p_Var13 = d->draw_arc;
  }
  else {
    p_Var13 = d->draw_arc;
  }
  if (p_Var13 == (_func_void_hidGC_int_int_int_int_int_int *)0x0) {
    d->draw_arc = s->draw_arc;
    p_Var14 = d->fill_circle;
  }
  else {
    p_Var14 = d->fill_circle;
  }
  if (p_Var14 == (_func_void_hidGC_int_int_int *)0x0) {
    d->fill_circle = s->fill_circle;
    p_Var15 = d->fill_polygon;
  }
  else {
    p_Var15 = d->fill_polygon;
  }
  if (p_Var15 == (_func_void_hidGC_int_int_ptr_int_ptr *)0x0) {
    d->fill_polygon = s->fill_polygon;
    p_Var16 = d->fill_pcb_polygon;
  }
  else {
    p_Var16 = d->fill_pcb_polygon;
  }
  if (p_Var16 == (_func_void_hidGC_PolygonType_ptr_BoxType_ptr *)0x0) {
    d->fill_pcb_polygon = s->fill_pcb_polygon;
    p_Var16 = d->thindraw_pcb_polygon;
  }
  else {
    p_Var16 = d->thindraw_pcb_polygon;
  }
  if (p_Var16 == (_func_void_hidGC_PolygonType_ptr_BoxType_ptr *)0x0) {
    d->thindraw_pcb_polygon = s->thindraw_pcb_polygon;
    p_Var17 = d->calibrate;
  }
  else {
    p_Var17 = d->calibrate;
  }
  if (p_Var17 == (_func_void_double_double *)0x0) {
    d->calibrate = s->calibrate;
    p_Var18 = d->shift_is_pressed;
  }
  else {
    p_Var18 = d->shift_is_pressed;
  }
  if (p_Var18 == (_func_int *)0x0) {
    d->shift_is_pressed = s->shift_is_pressed;
    p_Var18 = d->control_is_pressed;
  }
  else {
    p_Var18 = d->control_is_pressed;
  }
  if (p_Var18 == (_func_int *)0x0) {
    d->control_is_pressed = s->control_is_pressed;
    p_Var18 = d->mod1_is_pressed;
  }
  else {
    p_Var18 = d->mod1_is_pressed;
  }
  if (p_Var18 == (_func_int *)0x0) {
    d->mod1_is_pressed = s->mod1_is_pressed;
    p_Var19 = d->get_coords;
  }
  else {
    p_Var19 = d->get_coords;
  }
  if (p_Var19 == (_func_void_char_ptr_int_ptr_int_ptr *)0x0) {
    d->get_coords = s->get_coords;
    p_Var20 = d->set_crosshair;
  }
  else {
    p_Var20 = d->set_crosshair;
  }
  if (p_Var20 == (_func_void_int_int_int *)0x0) {
    d->set_crosshair = s->set_crosshair;
    p_Var21 = d->add_timer;
  }
  else {
    p_Var21 = d->add_timer;
  }
  if (p_Var21 == (_func_hidval__func_void_hidval_ptr_ulong_hidval *)0x0) {
    d->add_timer = s->add_timer;
    p_Var22 = d->stop_timer;
  }
  else {
    p_Var22 = d->stop_timer;
  }
  if (p_Var22 == (_func_void_hidval *)0x0) {
    d->stop_timer = s->stop_timer;
    p_Var23 = d->watch_file;
  }
  else {
    p_Var23 = d->watch_file;
  }
  if (p_Var23 == (_func_hidval_int_uint__func_void_hidval_int_uint_hidval_ptr_hidval *)0x0) {
    d->watch_file = s->watch_file;
    p_Var22 = d->unwatch_file;
  }
  else {
    p_Var22 = d->unwatch_file;
  }
  if (p_Var22 == (_func_void_hidval *)0x0) {
    d->unwatch_file = s->unwatch_file;
    p_Var24 = d->add_block_hook;
  }
  else {
    p_Var24 = d->add_block_hook;
  }
  if (p_Var24 == (_func_hidval__func_void_hidval_ptr_hidval *)0x0) {
    d->add_block_hook = s->add_block_hook;
    p_Var22 = d->stop_block_hook;
  }
  else {
    p_Var22 = d->stop_block_hook;
  }
  if (p_Var22 == (_func_void_hidval *)0x0) {
    d->stop_block_hook = s->stop_block_hook;
    p_Var25 = d->log;
  }
  else {
    p_Var25 = d->log;
  }
  if (p_Var25 == (_func_void_char_ptr_varargs *)0x0) {
    d->log = s->log;
    p_Var26 = d->logv;
  }
  else {
    p_Var26 = d->logv;
  }
  if (p_Var26 == (_func_void_char_ptr_va_list *)0x0) {
    d->logv = s->logv;
    p_Var27 = d->confirm_dialog;
  }
  else {
    p_Var27 = d->confirm_dialog;
  }
  if (p_Var27 == (_func_int_char_ptr_varargs *)0x0) {
    d->confirm_dialog = s->confirm_dialog;
    p_Var28 = d->close_confirm_dialog;
  }
  else {
    p_Var28 = d->close_confirm_dialog;
  }
  if (p_Var28 == (_func_int_varargs *)0x0) {
    d->close_confirm_dialog = s->close_confirm_dialog;
    p_Var29 = d->report_dialog;
  }
  else {
    p_Var29 = d->report_dialog;
  }
  if (p_Var29 == (_func_void_char_ptr_char_ptr *)0x0) {
    d->report_dialog = s->report_dialog;
    p_Var30 = d->prompt_for;
  }
  else {
    p_Var30 = d->prompt_for;
  }
  if (p_Var30 == (_func_char_ptr_char_ptr_char_ptr *)0x0) {
    d->prompt_for = s->prompt_for;
    p_Var31 = d->fileselect;
  }
  else {
    p_Var31 = d->fileselect;
  }
  if (p_Var31 == (_func_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_int *)0x0) {
    d->fileselect = s->fileselect;
    p_Var32 = d->attribute_dialog;
  }
  else {
    p_Var32 = d->attribute_dialog;
  }
  if (p_Var32 == (_func_int_HID_Attribute_ptr_int_HID_Attr_Val_ptr_char_ptr_char_ptr *)0x0) {
    d->attribute_dialog = s->attribute_dialog;
    p_Var33 = d->show_item;
  }
  else {
    p_Var33 = d->show_item;
  }
  if (p_Var33 == (_func_void_void_ptr *)0x0) {
    d->show_item = s->show_item;
    p_Var4 = d->beep;
  }
  else {
    p_Var4 = d->beep;
  }
  if (p_Var4 == (_func_void *)0x0) {
    d->beep = s->beep;
  }
  if (d->progress == (_func_int_int_int_char_ptr *)0x0) {
    d->progress = s->progress;
  }
  if (d->drc_gui == (HID_DRC_GUI *)0x0) {
    d->drc_gui = s->drc_gui;
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void nogui_beep(void)

{
  _IO_putc(7,stdout);
  fflush(stdout);
  return;
}



// WARNING: Unknown calling convention

void nogui_show_item(void *item)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_show_item");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

int nogui_attribute_dialog
              (HID_Attribute *attrs,int n_attrs,HID_Attr_Val *results,char *title,char *descr)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_attribute_dialog");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_stop_block_hook(hidval block_hook)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_stop_block_hook");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

hidval nogui_add_block_hook(_func_void_hidval *func,hidval data)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_add_block_hook");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_unwatch_file(hidval watch)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_unwatch_file");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

hidval nogui_watch_file(int fd,uint condition,_func_void_hidval_int_uint_hidval *func,
                       hidval user_data)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_watch_file");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_stop_timer(hidval timer)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_stop_timer");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

hidval nogui_add_timer(_func_void_hidval *func,ulong milliseconds,hidval user_data)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_add_timer");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_get_coords(char *msg,int *x,int *y)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_get_coords");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

int nogui_mod1_is_pressed(void)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_mod1_is_pressed");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

int nogui_control_is_pressed(void)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_control_is_pressed");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_calibrate(double xval,double yval)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_rect");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_fill_pcb_polygon(hidGC gc,PolygonType *poly,BoxType *clip_box)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_pcb_polygon");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_polygon");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_circle");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_draw_rect");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_draw_arc(hidGC gc,int cx,int cy,int width,int height,int start_angle,int end_angle)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_draw_arc");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_draw_line");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_set_line_cap_angle(hidGC gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_set_draw_faded(hidGC gc,int faded)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_draw_faded");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_set_draw_xor(hidGC gc,int xor)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_draw_xor");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_set_line_width(hidGC gc,int width)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_line_width");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_set_line_cap(hidGC gc,EndCapStyle style)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_line_cap");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_set_color(hidGC gc,char *name)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_color");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_use_mask(int use_it)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_use_mask");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

int nogui_set_layer(char *name,int idx,int empty)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_layer");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_invalidate_all(void)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_invalidate_all");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_invalidate_lr(int l,int r,int t,int b,int last)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_invalidate_lr");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_invalidate_wh(int x,int y,int width,int height,int last)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_invalidate_wh");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_parse_arguments(int *argc,char ***argv)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_parse_arguments");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_do_export(HID_Attr_Val *options)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_do_export");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

HID_Attribute * nogui_get_export_options(int *n_ret)

{
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_get_export_options");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nogui_report_dialog(char *title,char *msg)

{
  __printf_chk(1,"--- %s ---\n%s\n",title,msg);
  return;
}



// WARNING: Unknown calling convention

char * nogui_fileselect(char *title,char *descr,char *default_file,char *default_ext,
                       char *history_tag,int flags)

{
  if (default_file == (char *)0x0) {
    __printf_chk(1,"%s : ",title);
    fgets(nogui_fileselect::buf,0x400,stdin);
    return nogui_fileselect::buf;
  }
  __printf_chk(1,"%s [%s] : ",title,default_file);
  fgets(nogui_fileselect::buf,0x400,stdin);
  if (nogui_fileselect::buf[0] != '\0') {
    return nogui_fileselect::buf;
  }
  __strcpy_chk(nogui_fileselect::buf,default_file,0x400);
  return nogui_fileselect::buf;
}



// WARNING: Unknown calling convention

char * nogui_prompt_for(char *msg,char *default_string)

{
  if (default_string == (char *)0x0) {
    __printf_chk(1,"%s : ",msg);
    fgets(nogui_prompt_for::buf,0x400,stdin);
    return nogui_prompt_for::buf;
  }
  __printf_chk(1,"%s [%s] : ",msg,default_string);
  fgets(nogui_prompt_for::buf,0x400,stdin);
  if (nogui_prompt_for::buf[0] != '\0') {
    return nogui_prompt_for::buf;
  }
  __strcpy_chk(nogui_prompt_for::buf,default_string,0x400);
  return nogui_prompt_for::buf;
}



// WARNING: Unknown calling convention

int nogui_confirm_dialog(char *msg,...)

{
  int local_10 [3];
  
  __printf_chk(1,"%s ? 0=cancel 1=ok : ",msg);
  fflush(stdout);
  scanf("%d",local_10);
  return local_10[0];
}



// WARNING: Unknown calling convention

int nogui_close_confirm_dialog(void)

{
  int iVar1;
  
  iVar1 = nogui_confirm_dialog("OK to lose data ?",0);
  return iVar1;
}



// WARNING: Unknown calling convention

void nogui_logv(char *fmt,va_list ap)

{
  __vfprintf_chk(stdout,1,fmt,ap);
  return;
}



// WARNING: Unknown calling convention

void nogui_log(char *fmt,...)

{
  __vfprintf_chk(stdout,1,fmt,&stack0x00000008);
  return;
}



// WARNING: Unknown calling convention

int extents_set_layer(char *name,int group,int empty)

{
  int iVar1;
  uint uVar2;
  int idx;
  uint uVar3;
  
  if ((group < 0) ||
     ((iVar1 = PCB->Data->LayerN, group < iVar1 &&
      (group = (PCB->LayerGroups).Entries[group][0], group < 0)))) {
    uVar3 = group & 0xf0;
    if (((uVar3 == 0x30) || (uVar3 == 0x40)) || (uVar2 = 0, uVar3 == 0x10)) {
      uVar2 = 1;
    }
  }
  else {
    uVar2 = (uint)(group <= iVar1 + 1);
  }
  return uVar2;
}



// WARNING: Unknown calling convention

void extents_use_mask(int use_it)

{
  return;
}



// WARNING: Unknown calling convention

void extents_set_color(hidGC_conflict gc,char *name)

{
  return;
}



// WARNING: Unknown calling convention

void extents_set_line_cap(hidGC_conflict gc,EndCapStyle style)

{
  return;
}



// WARNING: Unknown calling convention

void extents_set_line_width(hidGC_conflict gc,int width)

{
  gc->width = width;
  return;
}



// WARNING: Unknown calling convention

void extents_set_draw_xor(hidGC_conflict gc,int xor)

{
  return;
}



// WARNING: Unknown calling convention

void extents_set_draw_faded(hidGC_conflict gc,int faded)

{
  return;
}



// WARNING: Unknown calling convention

void extents_set_line_cap_angle(hidGC_conflict gc,int x1,int y1,int x2,int y2)

{
  return;
}



// WARNING: Unknown calling convention

void extents_draw_line(hidGC_conflict gc,int x1,int y1,int x2,int y2)

{
  int iVar1;
  
  iVar1 = gc->width;
  if (x1 - iVar1 < box.X1) {
    box.X1 = x1 - iVar1;
  }
  if (box.X2 < x1 + iVar1) {
    box.X2 = x1 + iVar1;
  }
  if (y1 - iVar1 < box.Y1) {
    box.Y1 = y1 - iVar1;
  }
  if (box.Y2 < y1 + iVar1) {
    box.Y2 = y1 + iVar1;
  }
  if (x2 - iVar1 < box.X1) {
    box.X1 = x2 - iVar1;
  }
  if (box.X2 < x2 + iVar1) {
    box.X2 = x2 + iVar1;
  }
  if (y2 - iVar1 < box.Y1) {
    box.Y1 = y2 - iVar1;
  }
  if (box.Y2 < y2 + iVar1) {
    box.Y2 = y2 + iVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void extents_draw_arc(hidGC_conflict gc,int cx,int cy,int width,int height,int start_angle,
                     int end_angle)

{
  int iVar1;
  int iVar2;
  
  iVar1 = width + gc->width;
  iVar2 = cx - iVar1;
  if (iVar2 < box.X1) {
    box.X1 = iVar2;
  }
  iVar1 = iVar1 + cx;
  if (box.X2 < iVar1) {
    box.X2 = iVar1;
  }
  iVar1 = gc->width + height;
  iVar2 = cy - iVar1;
  if (iVar2 < box.Y1) {
    box.Y1 = iVar2;
  }
  iVar1 = iVar1 + cy;
  if (box.Y2 < iVar1) {
    box.Y2 = iVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void extents_draw_rect(hidGC_conflict gc,int x1,int y1,int x2,int y2)

{
  int iVar1;
  
  iVar1 = gc->width;
  if (x1 - iVar1 < box.X1) {
    box.X1 = x1 - iVar1;
  }
  if (box.X2 < x1 + iVar1) {
    box.X2 = x1 + iVar1;
  }
  if (y1 - iVar1 < box.Y1) {
    box.Y1 = y1 - iVar1;
  }
  if (box.Y2 < y1 + iVar1) {
    box.Y2 = y1 + iVar1;
  }
  if (x2 - iVar1 < box.X1) {
    box.X1 = x2 - iVar1;
  }
  if (box.X2 < x2 + iVar1) {
    box.X2 = x2 + iVar1;
  }
  if (y2 - iVar1 < box.Y1) {
    box.Y1 = y2 - iVar1;
  }
  if (box.Y2 < y2 + iVar1) {
    box.Y2 = y2 + iVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void extents_fill_circle(hidGC_conflict gc,int cx,int cy,int radius)

{
  if (cx - radius < box.X1) {
    box.X1 = cx - radius;
  }
  if (box.X2 < radius + cx) {
    box.X2 = radius + cx;
  }
  if (cy - radius < box.Y1) {
    box.Y1 = cy - radius;
  }
  if (box.Y2 < radius + cy) {
    box.Y2 = radius + cy;
  }
  return;
}



// WARNING: Unknown calling convention

void extents_fill_polygon(hidGC_conflict gc,int n_coords,int *x,int *y)

{
  int iVar1;
  int i;
  int iVar2;
  int iVar3;
  
  if (0 < n_coords) {
    iVar2 = 0;
    do {
      iVar1 = x[iVar2];
      iVar3 = iVar1;
      if (iVar1 < box.X1) {
        iVar3 = x[iVar2];
        box.X1 = iVar1;
      }
      if (box.X2 < iVar3) {
        box.X2 = iVar3;
      }
      iVar1 = y[iVar2];
      iVar3 = iVar1;
      if (iVar1 < box.Y1) {
        iVar3 = y[iVar2];
        box.Y1 = iVar1;
      }
      if (box.Y2 < iVar3) {
        box.Y2 = iVar3;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != n_coords);
  }
  return;
}



// WARNING: Unknown calling convention

void extents_fill_rect(hidGC_conflict gc,int x1,int y1,int x2,int y2)

{
  if (x1 < box.X1) {
    box.X1 = x1;
  }
  if (box.X2 < x1) {
    box.X2 = x1;
  }
  if (y1 < box.Y1) {
    box.Y1 = y1;
  }
  if (box.Y2 < y1) {
    box.Y2 = y1;
  }
  if (x2 < box.X1) {
    box.X1 = x2;
  }
  if (box.X2 < x2) {
    box.X2 = x2;
  }
  if (y2 < box.Y1) {
    box.Y1 = y2;
  }
  if (box.Y2 < y2) {
    box.Y2 = y2;
  }
  return;
}



// WARNING: Unknown calling convention

BoxType * hid_get_extents(void *item)

{
  BoxType region;
  
  region.X1 = -0x7fffffff;
  region.Y1 = -0x7fffffff;
  region.X2 = 0x7fffffff;
  region.Y2 = 0x7fffffff;
  box.X1 = 0x7fffffff;
  box.Y1 = 0x7fffffff;
  box.X2 = -0x7fffffff;
  box.Y2 = -0x7fffffff;
  hid_expose_callback((HID *)&extents_hid,&region,item);
  return &box;
}



// WARNING: Unknown calling convention

void extents_destroy_gc(hidGC_conflict gc)

{
  free(gc);
  return;
}



// WARNING: Unknown calling convention

hidGC_conflict extents_make_gc(void)

{
  hidGC_conflict phVar1;
  
  phVar1 = (hidGC_conflict)malloc(4);
  phVar1->width = 0;
  return phVar1;
}



// WARNING: Unknown calling convention

void thindraw_contour(hidGC gc,PLINE *pl)

{
  int iVar1;
  int iVar2;
  int last_y;
  int iVar3;
  int last_x;
  int iVar4;
  VNODE *v;
  VNODE *pVVar5;
  int this_y;
  int this_x;
  
  if ((pl->head).next != (VNODE *)0x0) {
    (*gui->set_line_width)(gc,0);
    (*gui->set_line_cap)(gc,Round_Cap);
    pVVar5 = (pl->head).next;
    iVar3 = (pl->head).point[1];
    iVar4 = (pl->head).point[0];
    do {
      iVar1 = pVVar5->point[0];
      iVar2 = pVVar5->point[1];
      (*gui->draw_line)(gc,iVar4,iVar3,iVar1,iVar2);
      pVVar5 = pVVar5->next;
      iVar3 = iVar2;
      iVar4 = iVar1;
    } while (pVVar5 != (pl->head).next);
  }
  return;
}



// WARNING: Unknown calling convention

int thindraw_hole_cb(PLINE *pl,void *user_data)

{
  thindraw_contour((hidGC)user_data,pl);
  return 0;
}



// WARNING: Unknown calling convention

void common_thindraw_pcb_polygon(hidGC gc,PolygonType *poly,BoxType *clip_box)

{
  thindraw_contour(gc,poly->Clipped->contours);
  PolygonHoles(poly,clip_box,thindraw_hole_cb,gc);
  return;
}



// WARNING: Unknown calling convention

void fill_contour(hidGC gc,PLINE *pl)

{
  uint uVar1;
  int *piVar2;
  int *__ptr;
  int *__ptr_00;
  uint uVar3;
  int i;
  int n;
  VNODE *v;
  VNODE *pVVar4;
  
  pVVar4 = &pl->head;
  uVar1 = pl->Count;
  __ptr = (int *)malloc(uVar1 * 4);
  __ptr_00 = (int *)malloc(uVar1 * 4);
  if (0 < (int)uVar1) {
    uVar3 = 0;
    do {
      __ptr[uVar3] = pVVar4->point[0];
      piVar2 = pVVar4->point;
      pVVar4 = pVVar4->next;
      __ptr_00[uVar3] = piVar2[1];
      uVar3 = uVar3 + 1;
    } while (uVar1 != uVar3);
  }
  (*gui->fill_polygon)(gc,uVar1,__ptr,__ptr_00);
  free(__ptr);
  free(__ptr_00);
  return;
}



// WARNING: Unknown calling convention

void common_fill_pcb_polygon(hidGC gc,PolygonType *poly,BoxType *clip_box)

{
  int iVar1;
  PLINE *pl_00;
  uint uVar2;
  PLINE *pl;
  int in_GS_OFFSET;
  PolygonType p;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (poly->NoHolesValid == 0) {
    ComputeNoHoles(poly);
  }
  for (pl_00 = poly->NoHoles; pl_00 != (PLINE *)0x0; pl_00 = pl_00->next) {
    fill_contour(gc,pl_00);
  }
  uVar2 = (poly->Flags).f;
  if ((uVar2 & 0x20) != 0) {
    p.BoundingBox.X1 = (poly->BoundingBox).X1;
    p.BoundingBox.Y1 = (poly->BoundingBox).Y1;
    p.BoundingBox.X2 = (poly->BoundingBox).X2;
    p.BoundingBox.Y2 = (poly->BoundingBox).Y2;
    p.ID = poly->ID;
    p.Flags.t._0_4_ = *(undefined4 *)(poly->Flags).t;
    p.Flags.t._4_4_ = *(undefined4 *)((poly->Flags).t + 4);
    p.net = poly->net;
    p.PointN = poly->PointN;
    p.PointMax = poly->PointMax;
    p.NoHoles = poly->NoHoles;
    p.NoHolesValid = poly->NoHolesValid;
    p.Points = poly->Points;
    p.Clipped = poly->Clipped->f;
    p.Flags.f = uVar2;
    if (p.Clipped != poly->Clipped) {
      do {
        NoHolesPolygonDicer(&p,clip_box,fill_contour_cb,gc);
        p.Clipped = (p.Clipped)->f;
      } while (poly->Clipped != p.Clipped);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void fill_contour_cb(PLINE *pl,void *user_data)

{
  PLINE *local_10 [3];
  
  local_10[0] = pl;
  fill_contour((hidGC)user_data,pl);
  poly_FreeContours(local_10);
  return;
}



// WARNING: Unknown calling convention

void do_mouse_action(int button,int mod_mask)

{
  uint uVar1;
  char *rstr;
  int iVar2;
  int bi;
  int iVar3;
  int iVar4;
  uint *puVar5;
  int iVar6;
  int a;
  int i;
  Resource *action;
  uint uVar7;
  
  if (0 < button_count) {
    if (*button_nums == button) {
      iVar4 = 0;
      iVar6 = 0;
    }
    else {
      iVar4 = 0;
      iVar6 = 0;
      iVar2 = 0;
      do {
        iVar2 = iVar2 + 1;
        if (button_count <= iVar2) {
          return;
        }
        iVar6 = iVar6 + *(int *)((int)mod_count + iVar4);
        iVar4 = iVar2 * 4;
      } while (button_nums[iVar2] != button);
    }
    iVar4 = *(int *)((int)mod_count + iVar4) + iVar6;
    if (iVar6 < iVar4) {
      iVar2 = iVar6 * 4;
      if (mod_mask != mods[iVar6]) {
        iVar2 = iVar6 * 4;
        puVar5 = mods + iVar6 + 1;
        iVar3 = iVar6;
        do {
          iVar2 = iVar2 + 4;
          iVar3 = iVar3 + 1;
          if (iVar4 <= iVar3) goto LAB_080d9005;
          uVar7 = *puVar5;
          puVar5 = puVar5 + 1;
        } while (mod_mask != uVar7);
      }
      iVar4 = *(int *)((int)actions + iVar2);
LAB_080d90b0:
      if ((iVar4 != 0) && (0 < *(int *)(iVar4 + 0xc))) {
        iVar6 = 0;
        iVar2 = 0;
        while ((rstr = *(char **)(*(int *)(iVar4 + 0x10) + 4 + iVar6), rstr == (char *)0x0 ||
               (iVar3 = hid_parse_actions(rstr,hid_actionv), iVar3 == 0))) {
          iVar2 = iVar2 + 1;
          iVar6 = iVar6 + 0xc;
          if (*(int *)(iVar4 + 0xc) == iVar2 || *(int *)(iVar4 + 0xc) < iVar2) {
            return;
          }
        }
      }
    }
    else {
LAB_080d9005:
      uVar7 = (mod_mask & 0x7fffffffU) - 1;
      if (-1 < (int)uVar7) {
        do {
          if (((mod_mask & 0x7fffffffU & uVar7) == uVar7) && (iVar6 < iVar4)) {
            uVar1 = mods[iVar6];
            puVar5 = mods + iVar6 + 1;
            iVar2 = iVar6;
            iVar3 = iVar6 * 4;
            while( true ) {
              if (uVar1 == (mod_mask & 0x80000000U | uVar7)) {
                iVar4 = *(int *)((int)actions + iVar3);
                goto LAB_080d90b0;
              }
              iVar2 = iVar2 + 1;
              if (iVar4 <= iVar2) break;
              uVar1 = *puVar5;
              puVar5 = puVar5 + 1;
              iVar3 = iVar3 + 4;
            }
          }
          uVar7 = uVar7 - 1;
        } while (-1 < (int)uVar7);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

uint parse_mods(char *value)

{
  __int32_t **pp_Var1;
  int *piVar2;
  long lVar3;
  long mod_num;
  char *s;
  char *pcVar4;
  char cVar5;
  uint m;
  
  cVar5 = *value;
  if (cVar5 != '\0') {
    pp_Var1 = __ctype_tolower_loc();
    pcVar4 = value;
    do {
      *pcVar4 = (char)(*pp_Var1)[cVar5];
      pcVar4 = pcVar4 + 1;
      cVar5 = *pcVar4;
    } while (cVar5 != '\0');
  }
  pcVar4 = strstr(value,"mod");
  if (pcVar4 != (char *)0x0) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    lVar3 = strtol(pcVar4 + 3,(char **)0x0,0);
    if (*piVar2 == 0) {
      m = 1 << ((char)lVar3 + 1U & 0x1f);
      goto LAB_080d918a;
    }
  }
  m = 0;
LAB_080d918a:
  pcVar4 = strstr(value,"shift");
  if (pcVar4 != (char *)0x0) {
    m = m | 1;
  }
  pcVar4 = strstr(value,"ctrl");
  if (pcVar4 != (char *)0x0) {
    m = m | 2;
  }
  pcVar4 = strstr(value,"alt");
  if (pcVar4 != (char *)0x0) {
    m = m | 4;
  }
  pcVar4 = strstr(value,"up");
  if (pcVar4 != (char *)0x0) {
    m = m | 0x80000000;
  }
  return m;
}



// WARNING: Unknown calling convention

Resource * res_wrap(char *value)

{
  Resource *n;
  Resource *tmp;
  
  n = resource_create((Resource *)0x0);
  resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
  return n;
}



// WARNING: Unknown calling convention

void load_mouse_resource(Resource *res)

{
  char *pcVar1;
  ResourceVal *pRVar2;
  Resource *pRVar3;
  char **ppcVar4;
  int iVar5;
  int bi;
  int button_num;
  long lVar6;
  uint uVar7;
  uint *puVar8;
  Resource **ppRVar9;
  size_t __size;
  int action_count;
  int iVar10;
  int iVar11;
  int local_30;
  int local_2c;
  int local_24;
  int local_20;
  
  __size = 0;
  button_count = res->c;
  button_nums = (int *)malloc(button_count << 2);
  mod_count = (int *)malloc(res->c << 2);
  if (0 < res->c) {
    pRVar2 = res->v;
    iVar5 = 0;
    do {
      __size = (__size + 1) - (uint)(pRVar2->value == (char *)0x0);
      if (pRVar2->subres != (Resource *)0x0) {
        __size = __size + pRVar2->subres->c;
      }
      iVar5 = iVar5 + 1;
      pRVar2 = pRVar2 + 1;
    } while (iVar5 != res->c);
    __size = __size << 2;
  }
  mods = (uint *)malloc(__size);
  actions = (Resource **)malloc(__size);
  if (0 < res->c) {
    local_30 = 0;
    local_24 = 0;
    local_2c = 0;
    do {
      pcVar1 = *(char **)((int)&res->v->name + local_30);
      if (pcVar1 != (char *)0x0) {
        iVar5 = strcasecmp(pcVar1,"left");
        lVar6 = 1;
        if (iVar5 != 0) {
          iVar5 = strcasecmp(pcVar1,"middle");
          lVar6 = 2;
          if (iVar5 != 0) {
            iVar5 = strcasecmp(pcVar1,"right");
            lVar6 = 3;
            if (iVar5 != 0) {
              iVar5 = strcasecmp(pcVar1,"up");
              lVar6 = 4;
              if (iVar5 != 0) {
                iVar5 = strcasecmp(pcVar1,"down");
                lVar6 = 5;
                if ((iVar5 != 0) && (lVar6 = strtol(pcVar1,(char **)0x0,10), lVar6 < 0))
                goto LAB_080d9570;
              }
            }
          }
        }
        button_nums[local_2c] = lVar6;
        mod_count[local_2c] = 0;
        iVar5 = (int)&res->v->name + local_30;
        if (*(int *)(iVar5 + 4) != 0) {
          mods[local_24] = 0;
          ppRVar9 = actions + local_24;
          pRVar3 = res_wrap(*(char **)((int)&res->v->value + local_30));
          local_24 = local_24 + 1;
          *ppRVar9 = pRVar3;
          mod_count[local_2c] = 1;
          iVar5 = (int)&res->v->name + local_30;
        }
        iVar5 = *(int *)(iVar5 + 8);
        if ((iVar5 != 0) &&
           (mod_count[local_2c] = mod_count[local_2c] + *(int *)(iVar5 + 0xc),
           0 < *(int *)(iVar5 + 0xc))) {
          iVar10 = 0;
          local_20 = 0;
          iVar11 = local_24 << 2;
          do {
            ppcVar4 = (char **)(*(int *)(iVar5 + 0x10) + iVar10);
            pcVar1 = *ppcVar4;
            uVar7 = (~-(uint)(pcVar1 == (char *)0x0) & 100) + (uint)(ppcVar4[2] != (char *)0x0) +
                    (~-(uint)(ppcVar4[1] == (char *)0x0) & 10);
            if (uVar7 == 10) {
              *(undefined4 *)((int)mods + iVar11) = 0;
LAB_080d94e2:
              ppRVar9 = (Resource **)((int)actions + iVar11);
              pRVar3 = res_wrap(*(char **)(*(int *)(iVar5 + 0x10) + 4 + iVar10));
              *ppRVar9 = pRVar3;
            }
            else if (uVar7 < 0xb) {
              if (uVar7 == 1) {
                *(undefined4 *)((int)mods + iVar11) = 0;
                *(undefined4 *)((int)actions + iVar11) =
                     *(undefined4 *)(*(int *)(iVar5 + 0x10) + 8 + iVar10);
              }
            }
            else if (uVar7 == 0x65) {
              puVar8 = (uint *)((int)mods + iVar11);
              uVar7 = parse_mods(pcVar1);
              *puVar8 = uVar7;
              *(undefined4 *)((int)actions + iVar11) =
                   *(undefined4 *)(*(int *)(iVar5 + 0x10) + 8 + iVar10);
            }
            else if (uVar7 == 0x6e) {
              puVar8 = (uint *)((int)mods + iVar11);
              uVar7 = parse_mods(pcVar1);
              *puVar8 = uVar7;
              goto LAB_080d94e2;
            }
            local_20 = local_20 + 1;
            iVar10 = iVar10 + 0xc;
            iVar11 = iVar11 + 4;
            local_24 = local_24 + 1;
          } while (*(int *)(iVar5 + 0xc) != local_20 && local_20 <= *(int *)(iVar5 + 0xc));
        }
      }
LAB_080d9570:
      local_2c = local_2c + 1;
      local_30 = local_30 + 0xc;
    } while (res->c != local_2c && local_2c <= res->c);
  }
  return;
}



// WARNING: Unknown calling convention

void toporouter_edge_init(toporouter_edge_t *edge)

{
  edge->routing = (GList *)0x0;
  edge->flags = 0;
  return;
}



// WARNING: Unknown calling convention

void toporouter_bbox_init(toporouter_bbox_t *box)

{
  box->data = (void *)0x0;
  box->type = OTHER;
  box->constraints = (GList *)0x0;
  box->cluster = (_toporouter_cluster_t *)0x0;
  return;
}



// WARNING: Unknown calling convention

void toporouter_vertex_class_init(toporouter_vertex_class_t *klass)

{
  return;
}



// WARNING: Unknown calling convention

void toporouter_vertex_init(toporouter_vertex_t *vertex)

{
  vertex->gcost = 0.0;
  vertex->bbox = (_toporouter_bbox_t *)0x0;
  vertex->parent = (_toporouter_vertex_t *)0x0;
  vertex->child = (_toporouter_vertex_t *)0x0;
  vertex->flags = 0;
  vertex->routingedge = (toporouter_edge_t *)0x0;
  vertex->arc = (_toporouter_arc_t *)0x0;
  vertex->oproute = (_toporouter_oproute_t *)0x0;
  vertex->route = (_toporouter_route_t *)0x0;
  vertex->hcost = 0.0;
  vertex->gn = 0;
  return;
}



// WARNING: Unknown calling convention

void toporouter_constraint_class_init(toporouter_constraint_class_t *klass)

{
  return;
}



// WARNING: Unknown calling convention

void toporouter_constraint_init(toporouter_constraint_t *constraint)

{
  constraint->box = (toporouter_bbox_t *)0x0;
  constraint->routing = (GList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void toporouter_arc_init(toporouter_arc_t *arc)

{
  arc->x0 = -1.0;
  arc->centre = (toporouter_vertex_t *)0x0;
  arc->y0 = -1.0;
  arc->v = (toporouter_vertex_t *)0x0;
  arc->x1 = -1.0;
  arc->v1 = (toporouter_vertex_t *)0x0;
  arc->y1 = -1.0;
  arc->v2 = (toporouter_vertex_t *)0x0;
  arc->r = -1.0;
  arc->dir = 0x7a69;
  arc->clearance = (GList *)0x0;
  arc->oproute = (toporouter_oproute_t *)0x0;
  return;
}



// WARNING: Unknown calling convention

void toporouter_output_close(drawing_context_t *dc)

{
  return;
}



// WARNING: Unknown calling convention

gint toporouter_draw_vertex(gpointer item,gpointer data)

{
  return -1;
}



// WARNING: Unknown calling convention

gint toporouter_draw_edge(gpointer item,gpointer data)

{
  return -1;
}



// WARNING: Unknown calling convention

toporouter_bbox_t * vertex_bbox(toporouter_vertex_t *v)

{
  toporouter_bbox_t *ptVar1;
  
  ptVar1 = (toporouter_bbox_t *)0x0;
  if (v != (toporouter_vertex_t *)0x0) {
    ptVar1 = v->bbox;
  }
  return ptVar1;
}



// WARNING: Unknown calling convention

char * vertex_netlist(toporouter_vertex_t *v)

{
  _toporouter_cluster_t *p_Var1;
  toporouter_bbox_t *box;
  
  if (((v != (toporouter_vertex_t *)0x0) && (v->bbox != (_toporouter_bbox_t *)0x0)) &&
     (p_Var1 = v->bbox->cluster, p_Var1 != (_toporouter_cluster_t *)0x0)) {
    return p_Var1->netlist->netlist;
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

char * constraint_netlist(toporouter_constraint_t *c)

{
  _toporouter_cluster_t *p_Var1;
  toporouter_bbox_t *box;
  
  if ((c->box != (toporouter_bbox_t *)0x0) &&
     (p_Var1 = c->box->cluster, p_Var1 != (_toporouter_cluster_t *)0x0)) {
    return p_Var1->netlist->netlist;
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

int point_wind(GtsPoint *a,GtsPoint *b,GtsPoint *c)

{
  double dVar1;
  int iVar2;
  gdouble rval;
  
  iVar2 = 1;
  dVar1 = (c->y - b->y) * (b->x - a->x) - (c->x - b->x) * (b->y - a->y);
  if (dVar1 <= 9.999999747378752e-05) {
    iVar2 = (-9.999999747378752e-05 <= dVar1) - 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int sloppy_point_wind(GtsPoint *a,GtsPoint *b,GtsPoint *c)

{
  double dVar1;
  int iVar2;
  gdouble rval;
  
  iVar2 = 1;
  dVar1 = (c->y - b->y) * (b->x - a->x) - (c->x - b->x) * (b->y - a->y);
  if (dVar1 <= 10.0) {
    iVar2 = (-10.0 <= dVar1) - 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void toporouter_draw_cluster
               (toporouter_t *r,drawing_context_t *dc,toporouter_cluster_t *cluster,gdouble red,
               gdouble green,gdouble blue,guint layer)

{
  return;
}



// WARNING: Unknown calling convention

void toporouter_draw_surface
               (toporouter_t *r,GtsSurface *s,char *filename,int w,int h,int mode,GList *datas,
               int layer,GList *candidatepoints)

{
  return;
}



// WARNING: Unknown calling convention

guint groupcount(void)

{
  int iVar1;
  guint gVar2;
  guint count;
  int group;
  int iVar3;
  
  iVar3 = 0;
  iVar1 = PCB->Data->LayerN;
  gVar2 = 0;
  if (0 < iVar1) {
    do {
      gVar2 = (gVar2 + 1) - (uint)((PCB->LayerGroups).Number[iVar3] == 0);
      iVar3 = iVar3 + 1;
    } while (iVar3 != iVar1);
  }
  return gVar2;
}



// WARNING: Unknown calling convention

int wind(toporouter_spoint_t *p1,toporouter_spoint_t *p2,toporouter_spoint_t *p3)

{
  double dVar1;
  int iVar2;
  double rval;
  
  iVar2 = 1;
  dVar1 = (p3->y - p2->y) * (p2->x - p1->x) - (p3->x - p2->x) * (p2->y - p1->y);
  if (dVar1 <= 0.0001) {
    iVar2 = (-0.0001 <= dVar1) - 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int wind_double(gdouble p1_x,gdouble p1_y,gdouble p2_x,gdouble p2_y,gdouble p3_x,gdouble p3_y)

{
  double dVar1;
  int iVar2;
  double rval;
  
  iVar2 = 1;
  dVar1 = (p3_y - p2_y) * (p2_x - p1_x) - (p3_x - p2_x) * (p2_y - p1_y);
  if (dVar1 <= 0.0001) {
    iVar2 = (-0.0001 <= dVar1) - 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

gdouble vertex_gradient(toporouter_spoint_t *a,toporouter_spoint_t *b)

{
  if (a->x != b->x) {
    return (b->y - a->y) / (b->x - a->x);
  }
  return INFINITY;
}



// WARNING: Removing unreachable block (ram,0x080d99b2)
// WARNING: Unknown calling convention

gdouble segment_gradient(GtsSegment *s)

{
  double dVar1;
  double dVar2;
  
  dVar1 = (s->v2->p).x;
  dVar2 = (s->v1->p).x;
  if (dVar1 != dVar2) {
    return ((s->v2->p).y - (s->v1->p).y) / (dVar1 - dVar2);
  }
  return INFINITY;
}



// WARNING: Unknown calling convention

gdouble perpendicular_gradient(gdouble m)

{
  if (m <= 1.797693134862316e+308) {
    return -1.0 / m;
  }
  return 0.0;
}



// WARNING: Unknown calling convention

gint coord_intersect_prop
               (gdouble ax,gdouble ay,gdouble bx,gdouble by,gdouble cx,gdouble cy,gdouble dx,
               gdouble dy)

{
  double dVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  gint wind_cdb;
  int iVar5;
  gint wind_cda;
  int iVar6;
  gint wind_abd;
  int iVar7;
  gint wind_abc;
  gdouble rval;
  gdouble rval_3;
  gdouble dy1;
  gdouble dx1;
  
  iVar7 = 1;
  dVar2 = (cy - by) * (bx - ax) - (cx - bx) * (by - ay);
  if (dVar2 <= 9.999999747378752e-05) {
    iVar7 = (-9.999999747378752e-05 <= dVar2) - 1;
  }
  iVar6 = 1;
  dVar3 = (dy - by) * (bx - ax) - (dx - bx) * (by - ay);
  if (dVar3 <= 9.999999747378752e-05) {
    iVar6 = (-9.999999747378752e-05 <= dVar3) - 1;
  }
  iVar5 = 1;
  dVar1 = (ay - dy) * (dx - cx) - (ax - dx) * (dy - cy);
  if (dVar1 <= 9.999999747378752e-05) {
    iVar5 = (-9.999999747378752e-05 <= dVar1) - 1;
  }
  iVar4 = 1;
  dVar1 = (by - dy) * (dx - cx) - (dy - cy) * (bx - dx);
  if (dVar1 <= 9.999999747378752e-05) {
    iVar4 = (-9.999999747378752e-05 <= dVar1) - 1;
  }
  if ((((9.999999747378752e-05 < dVar3 || dVar3 < -9.999999747378752e-05) &&
       (9.999999747378752e-05 < dVar2 || dVar2 < -9.999999747378752e-05)) && (iVar4 != 0)) &&
     (iVar5 != 0)) {
    return (uint)(iVar7 != iVar6 && iVar5 != iVar4);
  }
  return 0;
}



// WARNING: Unknown calling convention

int point_intersect_prop(GtsPoint *a,GtsPoint *b,GtsPoint *c,GtsPoint *d)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  int iVar10;
  int iVar11;
  gdouble rval;
  gdouble rval_3;
  gdouble rval_1;
  gdouble dy1;
  gdouble dx1;
  gdouble dy1_1;
  gdouble dx1_1;
  
  dVar1 = b->x;
  dVar5 = dVar1 - a->x;
  dVar2 = b->y;
  dVar6 = dVar2 - a->y;
  dVar8 = (c->y - dVar2) * dVar5 - (c->x - dVar1) * dVar6;
  if ((9.999999747378752e-05 < dVar8) || (dVar8 < -9.999999747378752e-05)) {
    dVar3 = d->x;
    dVar4 = d->y;
    dVar5 = (dVar4 - dVar2) * dVar5 - (dVar3 - dVar1) * dVar6;
    if ((9.999999747378752e-05 < dVar5) || (dVar5 < -9.999999747378752e-05)) {
      dVar9 = dVar3 - c->x;
      dVar7 = dVar4 - c->y;
      dVar6 = (a->y - dVar4) * dVar9 - (a->x - dVar3) * dVar7;
      if ((9.999999747378752e-05 < dVar6) || (dVar6 < -9.999999747378752e-05)) {
        dVar1 = (dVar2 - dVar4) * dVar9 - (dVar1 - dVar3) * dVar7;
        if ((9.999999747378752e-05 < dVar1) || (dVar1 < -9.999999747378752e-05)) {
          iVar11 = 1;
          if (dVar8 <= 9.999999747378752e-05) {
            iVar11 = (-9.999999747378752e-05 <= dVar8) - 1;
          }
          iVar10 = 1;
          if (dVar5 <= 9.999999747378752e-05) {
            iVar10 = (-9.999999747378752e-05 <= dVar5) - 1;
          }
          if (iVar11 != iVar10) {
            iVar11 = 1;
            if (dVar6 <= 9.999999747378752e-05) {
              iVar11 = (-9.999999747378752e-05 <= dVar6) - 1;
            }
            iVar10 = 1;
            if (dVar1 <= 9.999999747378752e-05) {
              iVar10 = (-9.999999747378752e-05 <= dVar1) - 1;
            }
            return (uint)(iVar11 != iVar10);
          }
        }
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void coord_intersect(gdouble ax,gdouble ay,gdouble bx,gdouble by,gdouble cx,gdouble cy,gdouble dx,
                    gdouble dy,gdouble *rx,gdouble *ry)

{
  double dVar1;
  gdouble ua;
  
  dVar1 = ((dy - cy) * (bx - ax) - (dx - cx) * (by - ay)) /
          ((ay - cy) * (dx - cx) - (ax - cx) * (dy - cy));
  *rx = (bx - ax) * dVar1 + ax;
  *ry = ay + dVar1 * (by - ay);
  return;
}



// WARNING: Removing unreachable block (ram,0x080d9ee2)
// WARNING: Unknown calling convention

int point_between(GtsPoint *a,GtsPoint *b,GtsPoint *c)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  gdouble rval;
  
  dVar1 = b->x;
  dVar2 = a->x;
  dVar3 = b->y;
  dVar4 = a->y;
  dVar5 = c->x;
  dVar6 = c->y;
  dVar7 = (dVar6 - dVar3) * (dVar1 - dVar2) - (dVar5 - dVar1) * (dVar3 - dVar4);
  if ((dVar7 <= 9.999999747378752e-05) && (-9.999999747378752e-05 <= dVar7)) {
    if (dVar1 == dVar2) {
      if ((dVar4 <= dVar6) && (dVar6 <= dVar3)) {
        return 1;
      }
      if (dVar6 <= dVar4) {
        return (uint)(dVar3 <= dVar6);
      }
    }
    else {
      if ((dVar2 <= dVar5) && (dVar5 <= dVar1)) {
        return 1;
      }
      if (dVar5 <= dVar2) {
        return (uint)(dVar1 <= dVar5);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

gint visited_cmp(gconstpointer a,gconstpointer b)

{
  uint uVar1;
  
  uVar1 = 0xffffffff;
  if (b <= a) {
    uVar1 = (uint)(b < a);
  }
  return uVar1;
}



// WARNING: Removing unreachable block (ram,0x080d9fa2)
// WARNING: Removing unreachable block (ram,0x080d9f9c)
// WARNING: Unknown calling convention

gint compare_points(gconstpointer a,gconstpointer b)

{
  double dVar1;
  double dVar2;
  
  dVar1 = *(double *)((int)a + 0xc);
  dVar2 = *(double *)((int)b + 0xc);
  if (dVar1 == dVar2) {
    dVar1 = *(double *)((int)a + 0x14);
    dVar2 = *(double *)((int)b + 0x14);
    if (dVar1 == dVar2) {
      return 0;
    }
  }
  if (dVar1 < dVar2) {
    return -1;
  }
  return 1;
}



// WARNING: Unknown calling convention

gint compare_segments(gconstpointer a,gconstpointer b)

{
  if (a == b) {
    return 0;
  }
  return -(uint)(a < b) | 1;
}



// WARNING: Unknown calling convention

gdouble route_heap_cmp(gpointer item,gpointer data)

{
  return *(double *)((int)item + 0x3c) + *(double *)((int)item + 0x44);
}



// WARNING: Unknown calling convention

void toporouter_heap_search(gpointer data,gpointer user_data)

{
                    // WARNING: Load size is inaccurate
  if (*user_data != data) {
    return;
  }
  *(gpointer *)((int)user_data + 4) = *user_data;
  return;
}



// WARNING: Unknown calling convention

void toporouter_heap_color(gpointer data,gpointer user_data)

{
  *(uint *)((int)data + 0x38) = *(uint *)((int)data + 0x38) | (uint)user_data;
  return;
}



// WARNING: Unknown calling convention

gint vertex_keepout_test(toporouter_t *r,toporouter_vertex_t *v)

{
  double dVar1;
  GList *pGVar2;
  GList *i;
  
  pGVar2 = r->keepoutlayers;
  if (pGVar2 != (GList *)0x0) {
                    // WARNING: Load size is inaccurate
    dVar1 = *pGVar2->data;
    while( true ) {
      if ((v->v).p.z == dVar1) {
        return 1;
      }
      pGVar2 = pGVar2->next;
      if (pGVar2 == (GList *)0x0) break;
                    // WARNING: Load size is inaccurate
      dVar1 = *pGVar2->data;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void swap_vertices(toporouter_vertex_t **v1,toporouter_vertex_t **v2)

{
  toporouter_vertex_t *ptVar1;
  toporouter_vertex_t *tempv;
  
  ptVar1 = *v1;
  *v1 = *v2;
  *v2 = ptVar1;
  return;
}



guint candidate_is_available(toporouter_vertex_t *pv,toporouter_vertex_t *v)

{
  if (pv == (toporouter_vertex_t *)0x0) {
    return 1;
  }
  if (pv != v) {
    do {
      pv = pv->parent;
      if (pv == (_toporouter_vertex_t *)0x0) {
        return 1;
      }
    } while (v != pv);
  }
  return 0;
}



// WARNING: Unknown calling convention

gint vertices_connected(toporouter_vertex_t *a,toporouter_vertex_t *b)

{
  if (a->route->netlist != b->route->netlist) {
    return 0;
  }
  return (uint)(a->route->src->c == b->route->src->c);
}



// WARNING: Unknown calling convention

void path_set_oproute(GList *path,toporouter_oproute_t *oproute)

{
  toporouter_vertex_t *v;
  
  if (path != (GList *)0x0) {
    do {
      if ((*(byte *)((int)path->data + 0x39) & 1) != 0) {
        *(toporouter_oproute_t **)((int)path->data + 0x54) = oproute;
      }
      path = path->next;
    } while (path != (GList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

gint compare_rubberband_arcs(toporouter_rubberband_arc_t *a,toporouter_rubberband_arc_t *b)

{
  return (int)ROUND(b->d - a->d);
}



// WARNING: Unknown calling convention

void speccut_edge_patch_links(toporouter_edge_t *e)

{
  GList *pGVar1;
  gpointer pvVar2;
  toporouter_vertex_t *v;
  GList *i;
  
  pGVar1 = e->routing;
  while (pGVar1 != (GList *)0x0) {
    pvVar2 = pGVar1->data;
    pGVar1 = pGVar1->next;
    *(gpointer *)(*(int *)((int)pvVar2 + 0x2c) + 0x30) = pvVar2;
    *(gpointer *)(*(int *)((int)pvVar2 + 0x30) + 0x2c) = pvVar2;
  }
  return;
}



// WARNING: Unknown calling convention

gint compare_routedata_ascending(gconstpointer a,gconstpointer b)

{
  return (int)ROUND(*(double *)((int)a + 0x14) - *(double *)((int)b + 0x14));
}



// WARNING: Unknown calling convention

void cluster_merge(toporouter_route_t *routedata)

{
  int iVar1;
  int iVar2;
  GPtrArray *pGVar3;
  int **ppiVar4;
  guint gVar5;
  int *piVar6;
  toporouter_cluster_t **i;
  int **ppiVar7;
  toporouter_cluster_t *cluster;
  gint oldc;
  gint newc;
  
  iVar1 = routedata->dest->c;
  iVar2 = routedata->src->c;
  pGVar3 = routedata->netlist->clusters;
  ppiVar4 = (int **)pGVar3->pdata;
  gVar5 = pGVar3->len;
  ppiVar7 = ppiVar4 + (gVar5 - 1);
  if ((ppiVar4 <= ppiVar7) && (gVar5 != 0)) {
    do {
      while (piVar6 = *ppiVar7, *piVar6 != iVar1) {
        ppiVar7 = ppiVar7 + -1;
        if (ppiVar7 < ppiVar4) {
          return;
        }
      }
      ppiVar7 = ppiVar7 + -1;
      *piVar6 = iVar2;
    } while (ppiVar4 <= ppiVar7);
  }
  return;
}



// WARNING: Unknown calling convention

void netlists_rollback(GList *netlists)

{
  int *piVar1;
  int *piVar2;
  undefined4 *puVar3;
  toporouter_cluster_t **i;
  int *piVar4;
  toporouter_cluster_t *cluster;
  
  if (netlists != (GList *)0x0) {
    do {
                    // WARNING: Load size is inaccurate
      piVar1 = **netlists->data;
      piVar2 = (*netlists->data)[1];
      piVar4 = piVar1 + ((int)piVar2 - 1);
      if ((piVar1 <= piVar4) && (piVar2 != (int *)0x0)) {
        do {
          puVar3 = (undefined4 *)*piVar4;
          piVar4 = piVar4 + -1;
          *puVar3 = puVar3[1];
        } while (piVar1 <= piVar4);
      }
      netlists = netlists->next;
    } while (netlists != (GList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

gint route_detour_compare(toporouter_route_t **a,toporouter_route_t **b)

{
  return (int)ROUND(((*b)->score - (*b)->detourscore) - ((*a)->score - (*a)->detourscore));
}



// WARNING: Unknown calling convention

void register_toporouter_action_list(void)

{
  hid_register_actions(toporouter_action_list,2);
  return;
}



// WARNING: Unknown calling convention

void hid_toporouter_init(void)

{
  register_toporouter_action_list();
  return;
}



// WARNING: Removing unreachable block (ram,0x080da3a7)
// WARNING: Removing unreachable block (ram,0x080da350)
// WARNING: Removing unreachable block (ram,0x080da354)
// WARNING: Removing unreachable block (ram,0x080da358)
// WARNING: Removing unreachable block (ram,0x080da3ab)
// WARNING: Removing unreachable block (ram,0x080da3b0)
// WARNING: Unknown calling convention

void arc_ortho_projections(toporouter_arc_t *arc,toporouter_arc_t *narc,gdouble *b1,gdouble *b2)

{
  toporouter_vertex_t *ptVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  gdouble nay;
  gdouble ay;
  gdouble ax;
  gdouble c;
  gdouble nax;
  
  ptVar1 = arc->centre;
  dVar2 = (narc->centre->v).p.x - (ptVar1->v).p.x;
  dVar6 = (narc->centre->v).p.y - (ptVar1->v).p.y;
  dVar3 = arc->x0 - (ptVar1->v).p.x;
  dVar4 = arc->y0 - (ptVar1->v).p.y;
  dVar5 = (dVar2 * dVar2 + dVar6 * dVar6) / (dVar4 * dVar6 + dVar3 * dVar2);
  dVar2 = dVar2 * dVar5;
  dVar5 = dVar5 * dVar6;
  *b1 = SQRT(dVar5 * dVar5 + dVar2 * dVar2);
  dVar3 = dVar3 - dVar2;
  dVar4 = dVar4 - dVar5;
  *b2 = SQRT(dVar4 * dVar4 + dVar3 * dVar3);
  return;
}



// WARNING: Removing unreachable block (ram,0x080da3f6)
// WARNING: Removing unreachable block (ram,0x080da3fa)
// WARNING: Removing unreachable block (ram,0x080da400)
// WARNING: Unknown calling convention

gdouble vertices_plane_distance(toporouter_spoint_t *a,toporouter_spoint_t *b)

{
  double dVar1;
  double dVar2;
  
  dVar1 = a->x - b->x;
  dVar2 = a->y - b->y;
  return SQRT(dVar2 * dVar2 + dVar1 * dVar1);
}



// WARNING: Removing unreachable block (ram,0x080da4e0)
// WARNING: Removing unreachable block (ram,0x080da4d5)
// WARNING: Removing unreachable block (ram,0x080da4e2)
// WARNING: Unknown calling convention

void points_on_line(GtsPoint *a,gdouble m,gdouble r,GtsPoint *b0,GtsPoint *b1)

{
  double dVar1;
  double dVar2;
  gdouble c;
  
  if ((1.797693134862316e+308 < m) || (m < -1.797693134862316e+308)) {
    b0->y = a->y + r;
    b1->y = a->y - r;
    b0->x = a->x;
    b1->x = a->x;
  }
  else {
    dVar1 = a->y - a->x * m;
    dVar2 = SQRT((r * r) / (m * m + 1.0));
    b0->x = a->x + dVar2;
    dVar2 = a->x - dVar2;
    b1->x = dVar2;
    b0->y = b0->x * m + dVar1;
    b1->y = dVar1 + dVar2 * m;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080da5b0)
// WARNING: Removing unreachable block (ram,0x080da5a6)
// WARNING: Removing unreachable block (ram,0x080da5b2)
// WARNING: Unknown calling convention

void coords_on_line(gdouble ax,gdouble ay,gdouble m,gdouble r,gdouble *b0x,gdouble *b0y,gdouble *b1x
                   ,gdouble *b1y)

{
  double dVar1;
  double dVar2;
  gdouble c;
  
  if ((1.797693134862316e+308 < m) || (m < -1.797693134862316e+308)) {
    *b0y = ay + r;
    *b1y = ay - r;
    *b0x = ax;
    *b1x = ax;
  }
  else {
    dVar2 = ay - m * ax;
    dVar1 = SQRT((r * r) / (m * m + 1.0));
    *b0x = ax + dVar1;
    *b1x = ax - dVar1;
    *b0y = *b0x * m + dVar2;
    *b1y = m * *b1x + dVar2;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080da690)
// WARNING: Removing unreachable block (ram,0x080da687)
// WARNING: Removing unreachable block (ram,0x080da692)
// WARNING: Unknown calling convention

void vertices_on_line(toporouter_spoint_t *a,gdouble m,gdouble r,toporouter_spoint_t *b0,
                     toporouter_spoint_t *b1)

{
  double dVar1;
  double dVar2;
  gdouble c;
  
  if ((1.797693134862316e+308 < m) || (m < -1.797693134862316e+308)) {
    b0->y = a->y + r;
    b1->y = a->y - r;
    b0->x = a->x;
    b1->x = a->x;
  }
  else {
    dVar1 = a->y - a->x * m;
    dVar2 = SQRT((r * r) / (m * m + 1.0));
    b0->x = a->x + dVar2;
    dVar2 = a->x - dVar2;
    b1->x = dVar2;
    b0->y = b0->x * m + dVar1;
    b1->y = dVar1 + dVar2 * m;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080da7d0)
// WARNING: Removing unreachable block (ram,0x080da7ca)
// WARNING: Removing unreachable block (ram,0x080da7d2)
// WARNING: Unknown calling convention

gdouble export_pcb_drawline(guint layer,guint x0,guint y0,guint x1,guint y1,guint thickness,
                           guint keepaway)

{
  int iVar1;
  float fVar2;
  FlagType Flags;
  LineTypePtr Ptr2;
  LineTypePtr line;
  int in_GS_OFFSET;
  gdouble d;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags((-(uint)(((PCB->Flags).f & 0x800) == 0) & 0xffffffe0) + 0xa0);
  Flags.t._0_4_ = local_28;
  Flags.f = local_2c;
  Flags.t._4_4_ = local_24;
  Ptr2 = CreateDrawnLineOnLayer(PCB->Data->Layer + layer,x0,y0,x1,y1,thickness,keepaway,Flags);
  if (Ptr2 == (LineTypePtr)0x0) {
    fVar2 = 0.0;
  }
  else {
    AddObjectToCreateUndoList(4,PCB->Data->Layer + layer,Ptr2,Ptr2);
    fVar2 = SQRT((float)(ulonglong)(y0 - y1) * (float)(ulonglong)(y0 - y1) +
                 (float)(ulonglong)(x0 - x1) * (float)(ulonglong)(x0 - x1)) / 100.0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (gdouble)fVar2;
}



// WARNING: Removing unreachable block (ram,0x080da904)
// WARNING: Removing unreachable block (ram,0x080da900)
// WARNING: Removing unreachable block (ram,0x080da908)
// WARNING: Removing unreachable block (ram,0x080da92e)
// WARNING: Removing unreachable block (ram,0x080da92a)
// WARNING: Removing unreachable block (ram,0x080da930)
// WARNING: Unknown calling convention

int escape(int argc,char **argv,int x,int y)

{
  int iVar1;
  int iVar2;
  ElementTypePtr paVar3;
  uint uVar4;
  int iVar5;
  longdouble lVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  FlagType Flags;
  FlagType Flags_00;
  int iVar10;
  long lVar11;
  DataTypePtr paVar12;
  PinTypePtr via;
  PinTypePtr Via;
  LineTypePtr Line;
  LayerType *Ptr1;
  LayerTypePtr pLVar13;
  uint uVar14;
  Cardinal sn;
  uint uVar15;
  uint uVar16;
  guint viay;
  PadTypePtr pad;
  ElementTypePtr element;
  int iVar17;
  Cardinal n;
  uint uVar18;
  int in_GS_OFFSET;
  gdouble length;
  longdouble lVar19;
  gdouble dx;
  int local_70;
  int local_6c;
  uint local_5c;
  uint local_58;
  ulonglong local_44;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  iVar10 = 0;
  if (argc == 1) {
    lVar11 = strtol(*argv,(char **)0x0,10);
    paVar12 = PCB->Data;
    local_6c = paVar12->ElementN - 1;
    if (local_6c != -1) {
      iVar10 = paVar12->ElementN * 300;
      do {
        local_70 = iVar10 + -300;
        uVar18 = 0;
        paVar3 = paVar12->Element;
        uVar4 = *(uint *)((int)&paVar3[-1].PadN + iVar10);
        iVar17 = 0;
        uVar14 = uVar4;
        while ((uVar14 != 0 && (uVar18 < uVar14))) {
          iVar5 = *(int *)((int)&paVar3[-1].Pad + iVar10);
          iVar1 = iVar5 + iVar17;
          if ((*(byte *)(iVar1 + 0x14) & 0x40) == 0) goto LAB_080da8ae;
          uVar15 = *(int *)(iVar5 + 0x2c) - *(int *)(iVar5 + 0x94);
          uVar14 = (int)uVar15 >> 0x1f;
          uVar16 = *(int *)(iVar5 + 0x30) - *(int *)(iVar5 + 0x98);
          dVar7 = (double)((uVar15 ^ uVar14) - uVar14);
          uVar14 = (int)uVar16 >> 0x1f;
          dVar8 = (double)((uVar16 ^ uVar14) - uVar14);
          dVar7 = SQRT(dVar8 * dVar8 + dVar7 * dVar7);
          dVar8 = SQRT(dVar7 * dVar7 + dVar7 * dVar7) * 0.5;
          dVar9 = dVar8 * 0.7071067811865475;
          dVar8 = dVar8 * 0.7071067811865476;
          switch(lVar11) {
          case 0:
          case 5:
          default:
            __printf_chk(1,"ERROR: escape() with bad direction (%d)\n",lVar11);
            iVar10 = 1;
            goto LAB_080da810;
          case 1:
            dVar9 = (double)*(int *)(iVar1 + 0x2c) - dVar9;
            break;
          case 2:
            local_5c = *(uint *)(iVar1 + 0x2c);
            iVar5 = *(int *)(iVar1 + 0x30);
            dVar7 = dVar7 * 0.5;
            goto LAB_080dac35;
          case 3:
            dVar9 = (double)*(int *)(iVar1 + 0x2c) + dVar9;
            break;
          case 4:
            dVar7 = dVar7 * -0.5 + (double)*(int *)(iVar1 + 0x2c);
            goto LAB_080dac8f;
          case 6:
            dVar7 = dVar7 * 0.5 + (double)*(int *)(iVar1 + 0x2c);
LAB_080dac8f:
            local_44 = (ulonglong)ROUND(dVar7);
            local_5c = (uint)local_44;
            local_58 = *(uint *)(iVar1 + 0x30);
            goto LAB_080da9eb;
          case 7:
            dVar9 = (double)*(int *)(iVar1 + 0x2c) - dVar9;
            goto LAB_080da9b9;
          case 8:
            iVar5 = *(int *)(iVar1 + 0x30);
            dVar7 = dVar7 * -0.5;
            local_5c = *(uint *)(iVar1 + 0x2c);
LAB_080dac35:
            local_44._0_4_ = (uint)(longlong)ROUND(dVar7 + (double)iVar5);
            local_58 = (uint)local_44;
            goto LAB_080da9eb;
          case 9:
            dVar9 = (double)*(int *)(iVar1 + 0x2c) + dVar9;
LAB_080da9b9:
            local_44._0_4_ = (uint)(longlong)ROUND(dVar9);
            dVar8 = (double)*(int *)(iVar1 + 0x30) - dVar8;
            local_5c = (uint)local_44;
            goto LAB_080da9dc;
          }
          local_44._0_4_ = (uint)(longlong)ROUND(dVar9);
          local_5c = (uint)local_44;
          dVar8 = (double)*(int *)(iVar1 + 0x30) + dVar8;
LAB_080da9dc:
          local_44._0_4_ = (uint)(longlong)ROUND(dVar8);
          local_58 = (uint)local_44;
LAB_080da9eb:
          MakeFlags(0);
          Flags_00.t._0_4_ = local_28;
          Flags_00.f = local_2c;
          Flags_00.t._4_4_ = local_24;
          Via = CreateNewVia(PCB->Data,local_5c,local_58,Settings.ViaThickness,Settings.Keepaway * 2
                             ,0,Settings.ViaDrillingHole,(char *)0x0,Flags_00);
          if (Via == (PinTypePtr)0x0) {
LAB_080dad38:
            uVar14 = *(uint *)((int)&paVar3[-1].PadN + iVar10);
          }
          else {
            AddObjectToCreateUndoList(1,Via,Via,Via);
            DrawVia(Via,0);
            MakeFlags(0);
            if (PCB->SilkActive == '\0') {
              pLVar13 = PCB->Data->Layer + LayerStack[0];
            }
            else {
              pLVar13 = PCB->Data->Layer +
                        (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
            }
            local_44 = (ulonglong)local_58;
            lVar19 = (longdouble)local_44;
            lVar6 = (longdouble)1;
            local_44 = (ulonglong)local_5c;
            Flags.t._0_4_ = local_34;
            Flags.f = local_38;
            Flags.t._4_4_ = local_30;
            Line = CreateDrawnLineOnLayer
                             (pLVar13,(int)ROUND((longdouble)*(int *)(iVar1 + 0x2c) + lVar6),
                              (int)ROUND((longdouble)*(int *)(iVar1 + 0x30) + lVar6),
                              (int)ROUND((longdouble)local_44 + lVar6),(int)ROUND(lVar19 + lVar6),
                              Settings.LineThickness,Settings.Keepaway * 2,Flags);
            if (Line == (LineTypePtr)0x0) goto LAB_080dad38;
            if (PCB->SilkActive == '\0') {
              Ptr1 = PCB->Data->Layer + LayerStack[0];
            }
            else {
              Ptr1 = PCB->Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
            }
            AddObjectToCreateUndoList(4,Ptr1,Line,Line);
            if (PCB->SilkActive == '\0') {
              pLVar13 = PCB->Data->Layer + LayerStack[0];
            }
            else {
              pLVar13 = PCB->Data->Layer +
                        (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
            }
            DrawLine(pLVar13,Line,0);
            uVar14 = *(uint *)((int)&paVar3[-1].PadN + iVar10);
          }
LAB_080da8ae:
          if (uVar4 == uVar14) {
            uVar18 = uVar18 + 1;
            iVar17 = iVar17 + 0x68;
            uVar14 = uVar4;
          }
        }
        local_6c = local_6c + -1;
        if (local_6c == -1) break;
        paVar12 = PCB->Data;
        iVar10 = local_70;
      } while( true );
    }
    IncrementUndoSerialNumber();
    Draw();
    iVar10 = 0;
  }
LAB_080da810:
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void print_netlist(toporouter_netlist_t *netlist)

{
  gpointer *ppvVar1;
  guint gVar2;
  char **ppcVar3;
  GPtrArray *pGVar4;
  toporouter_cluster_t **i;
  gpointer *ppvVar5;
  char *pcVar6;
  
  pcVar6 = netlist->netlist;
  __printf_chk(1,"NETLIST %s: ",pcVar6);
  ppvVar1 = netlist->clusters->pdata;
  gVar2 = netlist->clusters->len;
  ppvVar5 = ppvVar1 + (gVar2 - 1);
  if (ppvVar1 <= ppvVar5) {
    while (gVar2 != 0) {
      ppcVar3 = (char **)*ppvVar5;
      ppvVar5 = ppvVar5 + -1;
      pcVar6 = *ppcVar3;
      __printf_chk(1,"%d ",pcVar6);
      pGVar4 = netlist->clusters;
      if (ppvVar5 <= pGVar4->pdata && pGVar4->pdata != ppvVar5) break;
      gVar2 = pGVar4->len;
    }
  }
  __printf_chk(1,"\n",pcVar6);
  return;
}



// WARNING: Unknown calling convention

void print_netscores(GPtrArray *netscores)

{
  char **ppcVar1;
  toporouter_netscore_t **i;
  gpointer *ppvVar2;
  char *pcVar3;
  undefined8 uVar4;
  
  __printf_chk(1,"NETSCORES: \n\n");
  uVar4 = 0x815145508151464;
  pcVar3 = "Score";
  __printf_chk(1,"     %15s %15s %15s\n----------------------------------------------------\n",
               "Score","Detour Sum","Pairwise Fails");
  ppvVar2 = netscores->pdata;
  if (ppvVar2 < ppvVar2 + netscores->len) {
    do {
      ppcVar1 = (char **)*ppvVar2;
      ppvVar2 = ppvVar2 + 1;
      uVar4 = *(undefined8 *)(ppcVar1 + 4);
      pcVar3 = *ppcVar1;
      __printf_chk(1,"%4d %15f %15f %15d %15x\n",pcVar3,uVar4,*(undefined8 *)(ppcVar1 + 2),
                   ppcVar1[6],ppcVar1);
    } while (ppvVar2 < netscores->pdata + netscores->len);
  }
  __printf_chk(1,"\n",pcVar3,uVar4);
  return;
}



// WARNING: Unknown calling convention

void print_costmatrix(gdouble *m,guint n)

{
  guint j;
  uint uVar1;
  gdouble *pgVar2;
  gdouble gVar3;
  uint local_24;
  gdouble *local_20;
  
  __printf_chk(1,"COST MATRIX:\n");
  if (n != 0) {
    local_24 = 0;
    local_20 = m;
    do {
      uVar1 = 0;
      pgVar2 = local_20;
      do {
        gVar3 = *pgVar2;
        uVar1 = uVar1 + 1;
        pgVar2 = pgVar2 + 1;
        __printf_chk(1,"%f ",gVar3);
      } while (uVar1 < n);
      __printf_chk(1,"\n",gVar3);
      local_24 = local_24 + 1;
      local_20 = local_20 + n;
    } while (local_24 < n);
  }
  return;
}



// WARNING: Unknown calling convention

void calculate_serpintine(gdouble delta,gdouble r,gdouble initiala,gdouble *a,guint *nhalfcycles)

{
  double dVar1;
  gdouble lhalfcycle;
  ulonglong local_1c;
  
  dVar1 = r * 3.141592653589793 + (initiala - r) + (initiala - r);
  __printf_chk(1,"lhalfcycle = %f r = %f\n",dVar1,r);
  local_1c = (longlong)ROUND((r * -3.141592653589793 + delta) / (dVar1 + r * -2.0) + 1.0) &
             0xffffffff;
  dVar1 = (double)local_1c;
  *a = (r * -3.141592653589793 + dVar1 * -3.141592653589793 * r + dVar1 * 4.0 * r + delta + r * 4.0)
       / (dVar1 + dVar1);
  *nhalfcycles = (guint)local_1c;
  return;
}



// WARNING: Unknown calling convention

void print_toporouter_arc(toporouter_arc_t *arc)

{
  gdouble gVar1;
  gdouble gVar2;
  
  gVar2 = (arc->centre->v).p.y;
  __printf_chk(1,"ARC CENTRE: %f,%f ",(arc->centre->v).p.x,gVar2);
  gVar1 = arc->r;
  __printf_chk(1,"RADIUS: %f",gVar1);
  if (0 < arc->dir) {
    __printf_chk(1," COUNTERCLOCKWISE ",gVar1,gVar2);
    return;
  }
  if (arc->dir == 0) {
    __printf_chk(1," COLINEAR(ERROR) ",gVar1,gVar2);
    return;
  }
  __printf_chk(1," CLOCKWISE ",gVar1,gVar2);
  return;
}



// WARNING: Unknown calling convention

void print_bbox(toporouter_bbox_t *box)

{
  GtsPoint *pGVar1;
  gint gVar2;
  ulonglong uVar3;
  
  uVar3 = ZEXT48(box);
  __printf_chk(1,"[BBOX %x ",box);
  switch(box->type) {
  case PAD:
    __printf_chk(1,&DAT_0815150d,uVar3);
    break;
  case PIN:
    __printf_chk(1,&DAT_08151512,uVar3);
    break;
  case VIA:
    __printf_chk(1,&DAT_08151517,uVar3);
    break;
  default:
    __printf_chk(1,"UNKNOWN ",uVar3);
    break;
  case LINE:
    __printf_chk(1,"LINE ",uVar3);
    break;
  case BOARD:
    __printf_chk(1,"BOARD ",uVar3);
    break;
  case POLYGON:
    __printf_chk(1,"POLYGON ",uVar3);
    pGVar1 = box->point;
    goto joined_r0x080db229;
  }
  pGVar1 = box->point;
joined_r0x080db229:
  if (pGVar1 == (GtsPoint *)0x0) {
    __printf_chk(1,"P: NONE ",uVar3);
  }
  else {
    __printf_chk(1,"P: %f,%f,%f ",pGVar1->x,pGVar1->y,pGVar1->z);
  }
  __printf_chk(1,"LAYER: %d ",box->layer);
  gVar2 = -1;
  if (box->cluster != (_toporouter_cluster_t *)0x0) {
    gVar2 = box->cluster->c;
  }
  __printf_chk(1,"CLUSTER: %d]\n",gVar2);
  return;
}



// WARNING: Unknown calling convention

void print_cluster(toporouter_cluster_t *c)

{
  toporouter_bbox_t **pptVar1;
  guint gVar2;
  toporouter_bbox_t *box;
  GPtrArray *pGVar3;
  toporouter_bbox_t **i;
  toporouter_bbox_t **pptVar4;
  
  if (c == (toporouter_cluster_t *)0x0) {
    __printf_chk(1,"[CLUSTER (NULL)]\n");
    return;
  }
  __printf_chk(1,"CLUSTER %d: NETLIST = %s STYLE = %s\n",c->c,c->netlist->netlist,c->netlist->style)
  ;
  pptVar1 = (toporouter_bbox_t **)c->boxes->pdata;
  gVar2 = c->boxes->len;
  pptVar4 = pptVar1 + (gVar2 - 1);
  if (pptVar1 <= pptVar4) {
    while (gVar2 != 0) {
      box = *pptVar4;
      pptVar4 = pptVar4 + -1;
      print_bbox(box);
      pGVar3 = c->boxes;
      if (pptVar4 <= pGVar3->pdata && (toporouter_bbox_t **)pGVar3->pdata != pptVar4) {
        return;
      }
      gVar2 = pGVar3->len;
    }
  }
  return;
}



// WARNING: Unknown calling convention

toporouter_route_t * routedata_create(void)

{
  toporouter_route_t *ptVar1;
  
  ptVar1 = (toporouter_route_t *)calloc(1,0x50);
  ptVar1->score = 0.0;
  ptVar1->netlist = (_toporouter_netlist_t *)0x0;
  ptVar1->alltemppoints = (GHashTable *)0x0;
  ptVar1->path = (GList *)0x0;
  ptVar1->curpoint = (toporouter_vertex_t *)0x0;
  ptVar1->pscore = 0.0;
  ptVar1->flags = 0;
  ptVar1->dest = (_toporouter_cluster_t *)0x0;
  ptVar1->src = (_toporouter_cluster_t *)0x0;
  ptVar1->pdest = (_toporouter_cluster_t *)0x0;
  ptVar1->psrc = (_toporouter_cluster_t *)0x0;
  ptVar1->topopath = (GList *)0x0;
  ptVar1->ppath = (GList *)0x0;
  ptVar1->ppathindices = (gint *)0x0;
  ptVar1->srcvertices = (GList *)0x0;
  ptVar1->destvertices = (GList *)0x0;
  return ptVar1;
}



// WARNING: Unknown calling convention

toporouter_rubberband_arc_t *
new_rubberband_arc(toporouter_vertex_t *pathv,toporouter_vertex_t *arcv,gdouble r,gdouble d,
                  gint wind,GList *list)

{
  toporouter_rubberband_arc_t *ptVar1;
  
  ptVar1 = (toporouter_rubberband_arc_t *)calloc(1,0x20);
  ptVar1->pathv = pathv;
  ptVar1->r = r;
  ptVar1->arcv = arcv;
  ptVar1->d = d;
  ptVar1->wind = wind;
  ptVar1->list = list;
  return ptVar1;
}



// WARNING: Unknown calling convention

toporouter_serpintine_t *
toporouter_serpintine_new
          (gdouble x,gdouble y,gdouble x0,gdouble y0,gdouble x1,gdouble y1,gpointer start,
          gdouble halfa,gdouble radius,guint nhalfcycles)

{
  toporouter_serpintine_t *ptVar1;
  
  ptVar1 = (toporouter_serpintine_t *)calloc(1,0x4c);
  ptVar1->x = x;
  ptVar1->y = y;
  ptVar1->x0 = x0;
  ptVar1->y0 = y0;
  ptVar1->x1 = x1;
  ptVar1->y1 = y1;
  ptVar1->start = start;
  ptVar1->halfa = halfa;
  ptVar1->radius = radius;
  ptVar1->nhalfcycles = nhalfcycles;
  ptVar1->arcs = (GList *)0x0;
  return ptVar1;
}



// WARNING: Unknown calling convention

drawing_context_t * toporouter_output_init(int w,int h,char *filename)

{
  int iVar1;
  double dVar2;
  PCBTypePtr pPVar3;
  drawing_context_t *pdVar4;
  
  pdVar4 = (drawing_context_t *)calloc(1,0x24);
  pdVar4->filename = filename;
  pPVar3 = PCB;
  pdVar4->iw = (double)w;
  iVar1 = pPVar3->MaxWidth;
  pdVar4->ih = (double)h;
  if (iVar1 <= pPVar3->MaxHeight) {
    dVar2 = (double)pPVar3->MaxHeight / ((double)h - 20.0);
    pdVar4->s = dVar2;
    pdVar4->iw = (double)pPVar3->MaxWidth * dVar2 + 20.0;
    return pdVar4;
  }
  dVar2 = (double)iVar1 / ((double)w - 20.0);
  pdVar4->s = dVar2;
  pdVar4->ih = (double)pPVar3->MaxHeight * dVar2 + 20.0;
  return pdVar4;
}



// WARNING: Unknown calling convention

toporouter_t * toporouter_new(void)

{
  toporouter_t *ptVar1;
  GPtrArray *pGVar2;
  time_t ltime;
  tm *__tp;
  char *pcVar3;
  time_t local_10 [2];
  
  ptVar1 = (toporouter_t *)calloc(1,100);
  gettimeofday((timeval *)&ptVar1->starttime,(__timezone_ptr_t)0x0);
  ptVar1->netsort = netscore_pairwise_compare;
  ptVar1->destboxes = (GList *)0x0;
  ptVar1->consumeddestboxes = (GList *)0x0;
  ptVar1->paths = (GList *)0x0;
  ptVar1->layers = (toporouter_layer_t *)0x0;
  ptVar1->viacost = 10000.0;
  ptVar1->flags = 0;
  ptVar1->stublength = 300.0;
  ptVar1->viamax = 3;
  ptVar1->serpintine_half_amplitude = 1500.0;
  ptVar1->bboxes = (GSList *)0x0;
  ptVar1->wiring_score = 0.0;
  ptVar1->bboxtree = (GNode *)0x0;
  pGVar2 = (GPtrArray *)g_ptr_array_new();
  ptVar1->netlists = pGVar2;
  pGVar2 = (GPtrArray *)g_ptr_array_new();
  ptVar1->keepoutlayers = (GList *)0x0;
  ptVar1->routednets = (GList *)0x0;
  ptVar1->failednets = (GList *)0x0;
  ptVar1->routes = pGVar2;
  local_10[0] = time((time_t *)0x0);
  gts_predicates_init();
  Message("Topological Autorouter\n");
  __tp = localtime(local_10);
  pcVar3 = asctime(__tp);
  Message("Started %s",pcVar3);
  Message("-------------------------------------\n");
  Message("Copyright 2009 Anthony Blake (tonyb33@gmail.com)\n\n");
  return ptVar1;
}



// WARNING: Unknown calling convention

void parse_arguments(toporouter_t *r,int argc,char **argv)

{
  Cardinal *pCVar1;
  uint uVar2;
  int iVar3;
  double *pdVar4;
  GList *pGVar5;
  PCBTypePtr pPVar6;
  DataTypePtr paVar7;
  int iVar8;
  int i;
  uint uVar9;
  uint local_3c;
  int local_20 [4];
  
  if (0 < argc) {
    iVar8 = 0;
LAB_080db701:
    do {
      iVar3 = __isoc99_sscanf(argv[iVar8],"viacost=%d",local_20);
      if (iVar3 == 0) {
        iVar3 = __isoc99_sscanf(argv[iVar8],"l%d",local_20);
        if (iVar3 != 0) {
          iVar8 = iVar8 + 1;
          pdVar4 = (double *)calloc(1,8);
          *pdVar4 = (double)local_20[0];
          pGVar5 = (GList *)g_list_prepend(r->keepoutlayers,pdVar4);
          r->keepoutlayers = pGVar5;
          if (argc <= iVar8) break;
          goto LAB_080db701;
        }
      }
      else {
        r->viacost = (double)local_20[0];
      }
      iVar8 = iVar8 + 1;
    } while (iVar8 < argc);
  }
  local_3c = 0;
  paVar7 = PCB->Data;
  uVar9 = paVar7->LayerN;
  pPVar6 = PCB;
  if (uVar9 == 0) {
    return;
  }
LAB_080db790:
  if ((pPVar6->LayerGroups).Number[local_3c] != 0) {
    iVar8 = 0;
    do {
      uVar2 = (pPVar6->LayerGroups).Entries[local_3c][iVar8];
      if ((uVar2 < uVar9) && (paVar7->Layer[uVar2].On == '\0')) {
        pdVar4 = (double *)calloc(1,8);
        *pdVar4 = (double)(ulonglong)local_3c;
        pGVar5 = (GList *)g_list_prepend(r->keepoutlayers,pdVar4);
        r->keepoutlayers = pGVar5;
        pCVar1 = (PCB->LayerGroups).Number + local_3c;
        pPVar6 = PCB;
        if (*pCVar1 < iVar8 + 1U || *pCVar1 == iVar8 + 1U) goto LAB_080db840;
      }
      else {
        pCVar1 = (pPVar6->LayerGroups).Number + local_3c;
        if (*pCVar1 < iVar8 + 1U || *pCVar1 == iVar8 + 1U) goto LAB_080db840;
      }
      iVar8 = iVar8 + 1;
      paVar7 = pPVar6->Data;
      uVar9 = paVar7->LayerN;
    } while( true );
  }
  goto LAB_080db849;
LAB_080db840:
  paVar7 = pPVar6->Data;
  uVar9 = paVar7->LayerN;
LAB_080db849:
  local_3c = local_3c + 1;
  if (uVar9 <= local_3c) {
    return;
  }
  goto LAB_080db790;
}



// WARNING: Unknown calling convention

void toporouter_arc_remove(toporouter_oproute_t *oproute,toporouter_arc_t *arc)

{
  GList *pGVar1;
  
  pGVar1 = (GList *)g_list_remove(oproute->arcs,arc);
  oproute->arcs = pGVar1;
  if (arc->v != (toporouter_vertex_t *)0x0) {
    arc->v->arc = (_toporouter_arc_t *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void toporouter_layer_free(toporouter_layer_t *l)

{
  g_list_free(l->vertices);
  g_list_free();
  return;
}



// WARNING: Unknown calling convention

void cluster_join_bbox(toporouter_cluster_t *cluster,toporouter_bbox_t *box)

{
  if (box != (toporouter_bbox_t *)0x0) {
    g_ptr_array_add(cluster->boxes,box);
    box->cluster = cluster;
  }
  return;
}



// WARNING: Unknown calling convention

toporouter_cluster_t * cluster_create(toporouter_t *r,toporouter_netlist_t *netlist)

{
  guint gVar1;
  toporouter_cluster_t *ptVar2;
  GPtrArray *pGVar3;
  
  ptVar2 = (toporouter_cluster_t *)calloc(1,0x10);
  pGVar3 = netlist->clusters;
  gVar1 = pGVar3->len;
  ptVar2->pc = gVar1;
  ptVar2->c = gVar1;
  g_ptr_array_add(pGVar3,ptVar2);
  ptVar2->netlist = netlist;
  pGVar3 = (GPtrArray *)g_ptr_array_new();
  ptVar2->boxes = pGVar3;
  return ptVar2;
}



// WARNING: Unknown calling convention

gint netscore_pairwise_compare(toporouter_netscore_t **a,toporouter_netscore_t **b)

{
  toporouter_netscore_t *ptVar1;
  toporouter_netscore_t *ptVar2;
  uint uVar3;
  bool bVar4;
  
  ptVar1 = *a;
  if (1.797693134862316e+308 < ABS(ptVar1->score)) {
    return (uint)(ABS((*b)->score) <= 1.797693134862316e+308);
  }
  ptVar2 = *b;
  if (ABS(ptVar2->score) <= 1.797693134862316e+308) {
    uVar3 = ptVar2->pairwise_fails;
    bVar4 = uVar3 <= ptVar1->pairwise_fails;
    if (bVar4) {
      if (bVar4 && ptVar1->pairwise_fails != uVar3) {
        return 1;
      }
      if (ptVar2->pairwise_detour_sum <= ptVar1->pairwise_detour_sum) {
        return (uint)(ptVar2->pairwise_detour_sum < ptVar1->pairwise_detour_sum);
      }
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

gint netscore_pairwise_size_compare(toporouter_netscore_t **a,toporouter_netscore_t **b)

{
  double dVar1;
  double dVar2;
  toporouter_netscore_t *ptVar3;
  toporouter_netscore_t *ptVar4;
  uint uVar5;
  bool bVar6;
  
  ptVar3 = *a;
  dVar1 = ptVar3->score;
  if (1.797693134862316e+308 < ABS(dVar1)) {
    return (uint)(ABS((*b)->score) <= 1.797693134862316e+308);
  }
  ptVar4 = *b;
  dVar2 = ptVar4->score;
  if (ABS(dVar2) <= 1.797693134862316e+308) {
    uVar5 = ptVar4->pairwise_fails;
    bVar6 = uVar5 <= ptVar3->pairwise_fails;
    if (bVar6) {
      if (bVar6 && ptVar3->pairwise_fails != uVar5) {
        return 1;
      }
      if (ptVar4->pairwise_detour_sum <= ptVar3->pairwise_detour_sum) {
        if (ptVar4->pairwise_detour_sum < ptVar3->pairwise_detour_sum) {
          return 1;
        }
        if (dVar2 <= dVar1) {
          return (uint)(dVar2 < dVar1);
        }
      }
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

void netlist_recalculate(toporouter_netlist_t *netlist,GList *ignore)

{
  GPtrArray *pGVar1;
  guint gVar2;
  int **ppiVar3;
  int *piVar4;
  undefined4 *puVar5;
  int iVar6;
  int iVar7;
  undefined4 *puVar8;
  toporouter_cluster_t **i_1;
  int **ppiVar9;
  toporouter_cluster_t **i_2;
  gint n;
  int iVar10;
  toporouter_cluster_t *cluster;
  GList *i;
  gint oldc;
  
  puVar8 = (undefined4 *)g_list_last(netlist->routed);
  pGVar1 = netlist->clusters;
  gVar2 = pGVar1->len;
  ppiVar3 = (int **)pGVar1->pdata;
  iVar10 = gVar2 - 1;
  ppiVar9 = ppiVar3 + iVar10;
  if (ppiVar3 <= ppiVar9) {
    while (gVar2 != 0) {
      piVar4 = *ppiVar9;
      ppiVar9 = ppiVar9 + -1;
      *piVar4 = iVar10;
      iVar10 = iVar10 + -1;
      if (ppiVar9 < ppiVar3) break;
      gVar2 = pGVar1->len;
    }
  }
  do {
    if (puVar8 == (undefined4 *)0x0) {
      return;
    }
    if ((ignore == (GList *)0x0) || (iVar10 = g_list_find(ignore,*puVar8), iVar10 == 0)) {
      puVar5 = (undefined4 *)*puVar8;
      iVar10 = *(int *)puVar5[2];
      iVar6 = *(int *)puVar5[1];
      puVar5 = *(undefined4 **)*puVar5;
      ppiVar3 = (int **)*puVar5;
      iVar7 = puVar5[1];
      ppiVar9 = ppiVar3 + iVar7 + -1;
      if (ppiVar3 <= ppiVar9) {
        while (iVar7 != 0) {
          if (iVar10 == **ppiVar9) {
            **ppiVar9 = iVar6;
          }
          if (ppiVar9 + -1 < ppiVar3) break;
          ppiVar9 = ppiVar9 + -1;
          iVar7 = puVar5[1];
        }
      }
    }
    puVar8 = (undefined4 *)puVar8[2];
  } while( true );
}



// WARNING: Unknown calling convention

void netlists_recalculate(GList *netlists,GList *ignore)

{
  GList *i;
  
  if (netlists != (GList *)0x0) {
    do {
      netlist_recalculate((toporouter_netlist_t *)netlists->data,ignore);
      netlists = netlists->next;
    } while (netlists != (GList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

GtsTriangle * opposite_triangle(GtsTriangle *t,toporouter_edge_t *e)

{
  GtsTriangle *pGVar1;
  GSList *i;
  GSList *pGVar2;
  
  pGVar2 = (e->e).triangles;
  if (t == (GtsTriangle *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1798,"opposite_triangle",&DAT_081515aa);
  }
  if (pGVar2 != (GSList *)0x0) {
    pGVar1 = (GtsTriangle *)pGVar2->data;
    if (pGVar1 != t) {
      return pGVar1;
    }
    while (pGVar2 = pGVar2->next, pGVar2 != (GSList *)0x0) {
      if (pGVar1 != (GtsTriangle *)pGVar2->data) {
        return (GtsTriangle *)pGVar2->data;
      }
    }
  }
  return (GtsTriangle *)0x0;
}



// WARNING: Unknown calling convention

GList * cluster_vertices(toporouter_t *r,toporouter_cluster_t *c)

{
  toporouter_cluster_t **pptVar1;
  guint gVar2;
  toporouter_cluster_t *ptVar3;
  gpointer *ppvVar4;
  gpointer pvVar5;
  GPtrArray *pGVar6;
  undefined4 uVar7;
  toporouter_netlist_t *ptVar8;
  toporouter_bbox_t **i;
  gpointer *ppvVar9;
  toporouter_bbox_t *box;
  GList *pGVar10;
  GList *rval;
  toporouter_cluster_t **local_24;
  
  if (c != (toporouter_cluster_t *)0x0) {
    ptVar8 = c->netlist;
    pptVar1 = (toporouter_cluster_t **)ptVar8->clusters->pdata;
    gVar2 = ptVar8->clusters->len;
    local_24 = pptVar1 + (gVar2 - 1);
    if ((pptVar1 <= local_24) && (gVar2 != 0)) {
      pGVar10 = (GList *)0x0;
      do {
        ptVar3 = *local_24;
        if (*(char *)&r->flags < '\0') {
          if (ptVar3->c == c->c) goto LAB_080dbcbe;
        }
        else if (ptVar3 == c) {
LAB_080dbcbe:
          ppvVar4 = ptVar3->boxes->pdata;
          gVar2 = ptVar3->boxes->len;
          ppvVar9 = ppvVar4 + (gVar2 - 1);
          if ((ppvVar4 <= ppvVar9) && (gVar2 != 0)) {
            do {
              pvVar5 = *ppvVar9;
              if (*(int *)((int)pvVar5 + 0x40) == 5) {
                if (**(int **)((int)pvVar5 + 0x54) == 0) {
                    // WARNING: Subroutine does not return
                  g_assertion_message_expr
                            (0,"../../src/toporouter.c",0x962,"cluster_vertices",
                             "box->constraints->data");
                }
                uVar7 = g_list_prepend(pGVar10,*(undefined4 *)(**(int **)((int)pvVar5 + 0x54) + 0xc)
                                      );
                pGVar10 = (GList *)g_list_prepend(uVar7,*(undefined4 *)
                                                         (**(int **)((int)pvVar5 + 0x54) + 0x10));
                pGVar6 = ptVar3->boxes;
                if (ppvVar9 + -1 <= pGVar6->pdata && pGVar6->pdata != ppvVar9 + -1) {
LAB_080dbd4f:
                  ptVar8 = c->netlist;
                  pGVar6 = ptVar8->clusters;
                  if (local_24 + -1 <= pGVar6->pdata &&
                      (toporouter_cluster_t **)pGVar6->pdata != local_24 + -1) {
                    return pGVar10;
                  }
                  goto LAB_080dbc9a;
                }
              }
              else {
                if (*(int *)((int)pvVar5 + 0x58) == 0) {
                  __printf_chk(1,"WARNING: cluster_vertices: unhandled bbox type\n");
                }
                else {
                  pGVar10 = (GList *)g_list_prepend(pGVar10,*(int *)((int)pvVar5 + 0x58));
                }
                pGVar6 = ptVar3->boxes;
                if (ppvVar9 + -1 <= pGVar6->pdata && pGVar6->pdata != ppvVar9 + -1)
                goto LAB_080dbd4f;
              }
              ppvVar9 = ppvVar9 + -1;
            } while (pGVar6->len != 0);
            ptVar8 = c->netlist;
          }
        }
        pGVar6 = ptVar8->clusters;
        if (local_24 + -1 <= pGVar6->pdata &&
            (toporouter_cluster_t **)pGVar6->pdata != local_24 + -1) {
          return pGVar10;
        }
LAB_080dbc9a:
        local_24 = local_24 + -1;
        if (pGVar6->len == 0) {
          return pGVar10;
        }
      } while( true );
    }
  }
  return (GList *)0x0;
}



// WARNING: Unknown calling convention

gpointer gts_object_is_from_class(gpointer object,gpointer klass)

{
  GtsObjectClass *c;
  gpointer pvVar1;
  
  if (klass == (gpointer)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    return (gpointer)0x0;
  }
  if (object != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pvVar1 = *object;
    if (pvVar1 == (gpointer)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      return (gpointer)0x0;
    }
    while (klass != pvVar1) {
      pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
      if (pvVar1 == (gpointer)0x0) {
        return (gpointer)0x0;
      }
    }
  }
  return object;
}



// WARNING: Unknown calling convention

void free_list_elements(gpointer data,gpointer user_data)

{
  free(data);
  return;
}



// WARNING: Unknown calling convention

void toporouter_free(toporouter_t *r)

{
  int iVar1;
  int group;
  uint uVar2;
  guint count;
  int usecs;
  int iVar3;
  int secs;
  int i;
  uint uVar4;
  timeval endtime;
  
  uVar4 = 0;
  while( true ) {
    iVar3 = PCB->Data->LayerN;
    if (iVar3 < 1) break;
    uVar2 = 0;
    iVar1 = 0;
    do {
      uVar2 = (uVar2 + 1) - (uint)((PCB->LayerGroups).Number[iVar1] == 0);
      iVar1 = iVar1 + 1;
    } while (iVar1 != iVar3);
    if (uVar2 <= uVar4) break;
    toporouter_layer_free(r->layers + uVar4);
    uVar4 = uVar4 + 1;
  }
  gettimeofday((timeval *)&endtime,(__timezone_ptr_t)0x0);
  secs = endtime.tv_sec - (r->starttime).tv_sec;
  iVar3 = (endtime.tv_usec - (r->starttime).tv_usec) / 1000;
  if (iVar3 < 0) {
    secs = secs + -1;
    iVar3 = iVar3 + 1000;
  }
  Message("Elapsed time: %d.%02d seconds\n",secs,iVar3);
  free(r->layers);
  free(r);
  return;
}



// WARNING: Removing unreachable block (ram,0x080dbf4a)
// WARNING: Unknown calling convention

gdouble path_score(toporouter_t *r,GList *path)

{
  double dVar1;
  toporouter_vertex_t *pv;
  toporouter_vertex_t *v;
  GtsPoint *p1;
  GtsPoint *p2;
  gdouble score;
  gdouble gVar2;
  
  if (path == (GList *)0x0) {
    return INFINITY;
  }
  p2 = (GtsPoint *)path->data;
  dVar1 = 0.0;
  do {
    path = (GList *)(&path->data)[1];
    p1 = p2;
    if (path == (GList *)0x0) {
      return dVar1;
    }
    while (p2 = (GtsPoint *)path->data, p1 != (GtsPoint *)0x0) {
      gVar2 = gts_point_distance(p1,p2);
      dVar1 = dVar1 + gVar2;
      if (p1->z == p2->z) break;
      path = (GList *)(&path->data)[1];
      if (path == (GList *)0x0) {
        return dVar1;
      }
      dVar1 = dVar1 + r->viacost;
      p1 = p2;
    }
  } while( true );
}



// WARNING: Unknown calling convention

gdouble edge_capacity(toporouter_edge_t *e)

{
  gdouble gVar1;
  
  gVar1 = gts_point_distance(&((e->e).segment.v1)->p,&((e->e).segment.v2)->p);
  return gVar1;
}



// WARNING: Unknown calling convention

gdouble simple_h_cost(toporouter_t *r,toporouter_vertex_t *curpoint,toporouter_vertex_t *destpoint)

{
  gdouble gVar1;
  gdouble local_14;
  
  if ((curpoint->v).p.z == (destpoint->v).p.z) {
    local_14 = 0.0;
  }
  else {
    local_14 = r->viacost;
  }
  gVar1 = gts_point_distance((GtsPoint *)curpoint,(GtsPoint *)destpoint);
  return gVar1 + local_14;
}



// WARNING: Unknown calling convention

toporouter_vertex_t *
closest_dest_vertex(toporouter_t *r,toporouter_vertex_t *v,toporouter_route_t *routedata)

{
  toporouter_vertex_t *destpoint;
  double dVar1;
  toporouter_vertex_t *ptVar2;
  toporouter_vertex_t *closest;
  toporouter_vertex_t *ptVar3;
  GList *i;
  GList *pGVar4;
  toporouter_vertex_t *cv;
  gdouble tempd;
  gdouble closest_distance;
  double dVar5;
  
  pGVar4 = routedata->destvertices;
  ptVar2 = (toporouter_vertex_t *)0x0;
  if (pGVar4 != (GList *)0x0) {
    dVar1 = 0.0;
    ptVar3 = ptVar2;
    do {
      while (destpoint = (toporouter_vertex_t *)pGVar4->data, ptVar2 = ptVar3, dVar5 = dVar1,
            (destpoint->v).p.z == (v->v).p.z) {
        ptVar2 = destpoint;
        if (ptVar3 == (toporouter_vertex_t *)0x0) {
          dVar5 = simple_h_cost(r,v,destpoint);
          break;
        }
        dVar5 = simple_h_cost(r,v,destpoint);
        if ((((*(byte *)((int)&r->flags + 1) & 1) != 0) && (dVar1 < dVar5)) || (dVar5 < dVar1))
        break;
        pGVar4 = (GList *)(&pGVar4->data)[1];
        if (pGVar4 == (GList *)0x0) {
          return ptVar3;
        }
      }
      dVar1 = dVar5;
      pGVar4 = (GList *)(&pGVar4->data)[1];
      ptVar3 = ptVar2;
    } while (pGVar4 != (GList *)0x0);
  }
  return ptVar2;
}



// WARNING: Removing unreachable block (ram,0x080dc257)
// WARNING: Unknown calling convention

void closest_cluster_pair
               (toporouter_t *r,GList *src_vertices,GList *dest_vertices,toporouter_vertex_t **a,
               toporouter_vertex_t **b)

{
  double dVar1;
  double dVar2;
  toporouter_vertex_t *curpoint;
  GList *pGVar3;
  toporouter_vertex_t *v1;
  GList *i;
  GList *j;
  GList *pGVar4;
  toporouter_vertex_t *v2;
  toporouter_vertex_t *destpoint;
  gdouble tempd;
  gdouble min;
  gdouble gVar5;
  double dVar6;
  GList *local_20;
  
  *a = (toporouter_vertex_t *)0x0;
  *b = (toporouter_vertex_t *)0x0;
  if (src_vertices != (GList *)0x0) {
    local_20 = src_vertices;
    dVar6 = 0.0;
    do {
      curpoint = (toporouter_vertex_t *)local_20->data;
      pGVar3 = r->keepoutlayers;
      if (pGVar3 == (GList *)0x0) {
LAB_080dc157:
        if (dest_vertices != (GList *)0x0) {
          destpoint = (toporouter_vertex_t *)dest_vertices->data;
          pGVar4 = dest_vertices;
          if (pGVar3 == (GList *)0x0) goto LAB_080dc204;
LAB_080dc170:
          dVar1 = (destpoint->v).p.z;
                    // WARNING: Load size is inaccurate
          dVar2 = *pGVar3->data;
          while( true ) {
            if (dVar2 == dVar1) goto LAB_080dc1f0;
            pGVar3 = pGVar3->next;
            if (pGVar3 == (GList *)0x0) break;
                    // WARNING: Load size is inaccurate
            dVar2 = *pGVar3->data;
          }
          do {
            if ((curpoint->v).p.z == dVar1) {
              if (*a == (toporouter_vertex_t *)0x0) {
                *a = curpoint;
                *b = destpoint;
                dVar6 = simple_h_cost(r,*a,destpoint);
                goto LAB_080dc1f0;
              }
              gVar5 = simple_h_cost(r,curpoint,destpoint);
              if ((((*(byte *)((int)&r->flags + 1) & 1) != 0) && (dVar6 < gVar5)) || (gVar5 < dVar6)
                 ) {
                *a = curpoint;
                *b = destpoint;
                dVar6 = gVar5;
                goto LAB_080dc1f0;
              }
              pGVar4 = (GList *)(&pGVar4->data)[1];
            }
            else {
LAB_080dc1f0:
              pGVar4 = (GList *)(&pGVar4->data)[1];
            }
            if (pGVar4 == (GList *)0x0) break;
            pGVar3 = r->keepoutlayers;
            destpoint = (toporouter_vertex_t *)pGVar4->data;
            if (pGVar3 != (GList *)0x0) goto LAB_080dc170;
LAB_080dc204:
            dVar1 = (destpoint->v).p.z;
          } while( true );
        }
        local_20 = (GList *)(&local_20->data)[1];
      }
      else {
                    // WARNING: Load size is inaccurate
        dVar1 = *pGVar3->data;
        pGVar4 = pGVar3;
        while (dVar1 != (curpoint->v).p.z) {
          pGVar4 = pGVar4->next;
          if (pGVar4 == (GList *)0x0) goto LAB_080dc157;
                    // WARNING: Load size is inaccurate
          dVar1 = *pGVar4->data;
        }
        local_20 = (GList *)(&local_20->data)[1];
      }
    } while (local_20 != (GList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void snapshot(toporouter_t *r,char *name,GList *datas)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int group;
  uint uVar4;
  guint count;
  int i;
  uint uVar5;
  int in_GS_OFFSET;
  char buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  uVar5 = 0;
  while( true ) {
    iVar2 = PCB->Data->LayerN;
    if (iVar2 < 1) break;
    uVar4 = 0;
    iVar3 = 0;
    do {
      uVar4 = (uVar4 + 1) - (uint)((PCB->LayerGroups).Number[iVar3] == 0);
      iVar3 = iVar3 + 1;
    } while (iVar3 != iVar2);
    if (uVar4 <= uVar5) break;
    __sprintf_chk(buffer,1,0x100,"route-%s-%d.png",name,uVar5);
    uVar5 = uVar5 + 1;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

gint routing_edge_insert(gconstpointer a,gconstpointer b,gpointer user_data)

{
  GtsPoint *p1;
  uint uVar1;
  GtsPoint *v1;
  gdouble gVar2;
  gdouble gVar3;
  
  p1 = *(GtsPoint **)((int)user_data + 0xc);
  gVar2 = gts_point_distance2(p1,(GtsPoint *)a);
  gVar3 = gts_point_distance2(p1,(GtsPoint *)b);
  uVar1 = 0xffffffff;
  if (gVar3 - 9.999999747378752e-05 <= gVar2) {
    gVar2 = gts_point_distance2(p1,(GtsPoint *)a);
    gVar3 = gts_point_distance2(p1,(GtsPoint *)b);
    uVar1 = (uint)(gVar3 + 9.999999747378752e-05 < gVar2);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void oproute_free(toporouter_oproute_t *oproute)

{
  GtsObject *object;
  GList *pGVar1;
  GList *i;
  GList *pGVar2;
  
  pGVar1 = (GList *)0x0;
  pGVar2 = oproute->arcs;
  if (pGVar2 != (GList *)0x0) {
    do {
      while (object = *(GtsObject **)((int)pGVar2->data + 0x2c), -1 < *(char *)&object[4].flags) {
        pGVar2 = pGVar2->next;
        if (pGVar2 == (GList *)0x0) goto LAB_080dc3f9;
      }
      gts_object_destroy(object);
      pGVar2 = pGVar2->next;
    } while (pGVar2 != (GList *)0x0);
LAB_080dc3f9:
    pGVar1 = oproute->arcs;
  }
  g_list_free(pGVar1);
  free(oproute);
  return;
}



// WARNING: Unknown calling convention

GList * split_path(GList *path)

{
  gpointer pvVar1;
  uint uVar2;
  undefined4 uVar3;
  GList *curpath;
  toporouter_vertex_t *v;
  gpointer pvVar4;
  GList *i;
  GList *local_20;
  
  uVar3 = 0;
  local_20 = (GList *)0x0;
  if (path != (GList *)0x0) {
    uVar3 = 0;
    local_20 = (GList *)0x0;
    pvVar1 = path->data;
    i = path;
    while( true ) {
      pvVar4 = pvVar1;
      uVar3 = g_list_append(uVar3,pvVar4);
      i = i->next;
      if (i == (GList *)0x0) break;
      pvVar1 = i->data;
      if (((pvVar4 != (gpointer)0x0) &&
          (*(double *)((int)pvVar1 + 0xc) == *(double *)((int)pvVar4 + 0xc))) &&
         (*(double *)((int)pvVar1 + 0x14) == *(double *)((int)pvVar4 + 0x14))) {
        uVar2 = g_list_length(uVar3);
        if (1 < uVar2) {
          local_20 = (GList *)g_list_prepend(local_20,uVar3);
        }
        *(undefined4 *)((int)pvVar4 + 0x30) = 0;
        uVar3 = 0;
        *(undefined4 *)((int)pvVar1 + 0x2c) = 0;
      }
    }
  }
  uVar2 = g_list_length(uVar3);
  if (1 < uVar2) {
    local_20 = (GList *)g_list_prepend(local_20,uVar3);
  }
  return local_20;
}



// WARNING: Removing unreachable block (ram,0x080dc599)
// WARNING: Removing unreachable block (ram,0x080dc536)
// WARNING: Removing unreachable block (ram,0x080dc53c)
// WARNING: Removing unreachable block (ram,0x080dc540)
// WARNING: Removing unreachable block (ram,0x080dc59f)
// WARNING: Removing unreachable block (ram,0x080dc5a8)
// WARNING: Unknown calling convention

gdouble vector_angle(gdouble ox,gdouble oy,gdouble ax,gdouble ay,gdouble bx,gdouble by)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  
  dVar4 = ax - ox;
  dVar2 = ay - oy;
  dVar1 = bx - ox;
  dVar3 = by - oy;
  dVar4 = acos((dVar3 * dVar2 + dVar1 * dVar4) /
               (SQRT(dVar2 * dVar2 + dVar4 * dVar4) * SQRT(dVar3 * dVar3 + dVar1 * dVar1)));
  return dVar4;
}



// WARNING: Removing unreachable block (ram,0x080dc696)
// WARNING: Removing unreachable block (ram,0x080dc64a)
// WARNING: Removing unreachable block (ram,0x080dc64e)
// WARNING: Removing unreachable block (ram,0x080dc650)
// WARNING: Removing unreachable block (ram,0x080dc69a)
// WARNING: Removing unreachable block (ram,0x080dc6a0)
// WARNING: Unknown calling convention

gdouble arc_angle(toporouter_arc_t *arc)

{
  double dVar1;
  double dVar2;
  double dVar3;
  gdouble y1;
  gdouble y0;
  gdouble x1;
  gdouble x0;
  double dVar4;
  
  dVar4 = (arc->centre->v).p.x;
  dVar2 = arc->x0 - dVar4;
  dVar4 = arc->x1 - dVar4;
  dVar1 = (arc->centre->v).p.y;
  dVar3 = arc->y0 - dVar1;
  dVar1 = arc->y1 - dVar1;
  dVar4 = acos((dVar4 * dVar2 + dVar1 * dVar3) /
               (SQRT(dVar3 * dVar3 + dVar2 * dVar2) * SQRT(dVar1 * dVar1 + dVar4 * dVar4)));
  return dVar4;
}



// WARNING: Removing unreachable block (ram,0x080dc77c)
// WARNING: Removing unreachable block (ram,0x080dc780)
// WARNING: Removing unreachable block (ram,0x080dc788)
// WARNING: Removing unreachable block (ram,0x080dc854)
// WARNING: Removing unreachable block (ram,0x080dc850)
// WARNING: Removing unreachable block (ram,0x080dc858)
// WARNING: Removing unreachable block (ram,0x080dc880)
// WARNING: Removing unreachable block (ram,0x080dc87c)
// WARNING: Removing unreachable block (ram,0x080dc882)
// WARNING: Unknown calling convention

void oproute_calculate_tof(toporouter_oproute_t *oproute)

{
  double dVar1;
  double dVar2;
  double dVar3;
  toporouter_arc_t *ptVar4;
  toporouter_arc_t *arc;
  GList *arcs;
  GList *pGVar5;
  toporouter_arc_t *arc_00;
  toporouter_arc_t *parc;
  toporouter_arc_t *arc_01;
  gdouble gVar6;
  
  dVar1 = 0.0;
  pGVar5 = oproute->arcs;
  oproute->tof = 0.0;
  if (pGVar5 == (GList *)0x0) {
    gVar6 = gts_point_distance((GtsPoint *)oproute->term1,(GtsPoint *)oproute->term2);
    oproute->tof = gVar6;
    return;
  }
  ptVar4 = (toporouter_arc_t *)pGVar5->data;
  arc_01 = (toporouter_arc_t *)0x0;
  do {
    arc_00 = ptVar4;
    if (arc_00 == (toporouter_arc_t *)0x0) {
      if (arc_01 == (toporouter_arc_t *)0x0) goto LAB_080dc75d;
      dVar1 = oproute->tof;
LAB_080dc731:
      pGVar5 = (GList *)(&pGVar5->data)[1];
    }
    else {
      if (arc_01 != (toporouter_arc_t *)0x0) {
        gVar6 = arc_angle(arc_01);
        dVar1 = dVar1 + arc_01->r * gVar6;
        oproute->tof = dVar1;
        dVar2 = arc_01->x1 - arc_00->x0;
        dVar3 = arc_01->y1 - arc_00->y0;
        dVar1 = SQRT(dVar3 * dVar3 + dVar2 * dVar2) + dVar1;
        oproute->tof = dVar1;
        goto LAB_080dc731;
      }
LAB_080dc75d:
      dVar2 = arc_00->x0 - (oproute->term1->v).p.x;
      dVar3 = arc_00->y0 - (oproute->term1->v).p.y;
      pGVar5 = (GList *)(&pGVar5->data)[1];
      dVar1 = SQRT(dVar3 * dVar3 + dVar2 * dVar2) + dVar1;
      oproute->tof = dVar1;
    }
    if (pGVar5 == (GList *)0x0) {
      gVar6 = arc_angle(arc_00);
      dVar1 = dVar1 + arc_00->r * gVar6;
      oproute->tof = dVar1;
      dVar2 = arc_00->x1 - (oproute->term2->v).p.x;
      dVar3 = arc_00->y1 - (oproute->term2->v).p.y;
      oproute->tof = SQRT(dVar3 * dVar3 + dVar2 * dVar2) + dVar1;
      return;
    }
    dVar1 = oproute->tof;
    ptVar4 = (toporouter_arc_t *)pGVar5->data;
    arc_01 = arc_00;
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x080dc9c8)
// WARNING: Removing unreachable block (ram,0x080dc8fe)
// WARNING: Removing unreachable block (ram,0x080dc9fc)
// WARNING: Removing unreachable block (ram,0x080dc9cc)
// WARNING: Removing unreachable block (ram,0x080dc9d0)
// WARNING: Unknown calling convention

gdouble line_line_distance_at_normal
                  (gdouble line1_x1,gdouble line1_y1,gdouble line1_x2,gdouble line1_y2,
                  gdouble line2_x1,gdouble line2_y1,gdouble line2_x2,gdouble line2_y2,gdouble x,
                  gdouble y)

{
  double __value;
  double dVar1;
  int iVar2;
  int iVar3;
  gdouble intx;
  gdouble c2;
  gdouble m2;
  double local_24;
  double local_14;
  
  if ((line1_x1 == line1_x2) ||
     (local_14 = (line1_x2 - line1_x1) / (line1_y2 - line1_y1), 1.797693134862316e+308 < local_14))
  {
    local_14 = 0.0;
  }
  else {
    local_14 = -1.0 / local_14;
  }
  if (line2_x1 == line2_x2) {
    __value = INFINITY;
  }
  else {
    __value = (line2_y2 - line2_y1) / (line2_x2 - line2_x1);
  }
  iVar2 = __isinf(local_14);
  local_24 = x;
  if (iVar2 == 0) {
    local_24 = y - local_14 * x;
  }
  iVar3 = __isinf(__value);
  if (iVar3 == 0) {
    dVar1 = line2_y1 - line2_x1 * __value;
    line2_x1 = x;
    if (iVar2 == 0) {
      line2_x1 = (dVar1 - local_24) / (local_14 - __value);
    }
    local_24 = __value * line2_x1 + dVar1;
  }
  else {
    local_24 = local_14 * line2_x1 + local_24;
  }
  return SQRT((y - local_24) * (y - local_24) + (x - line2_x1) * (x - line2_x1));
}



// WARNING: Unknown calling convention

guint vertex_line_normal_intersection
                (gdouble x1,gdouble y1,gdouble x2,gdouble y2,gdouble x3,gdouble y3,gdouble *x,
                gdouble *y)

{
  double dVar1;
  double dVar2;
  int iVar3;
  int iVar4;
  gdouble m1;
  gdouble c1;
  double local_2c;
  double local_1c;
  
  if (x1 == x2) {
    local_1c = 0.0;
    dVar1 = INFINITY;
  }
  else {
    dVar1 = (y2 - y1) / (x2 - x1);
    if (1.797693134862316e+308 < dVar1) {
      local_1c = 0.0;
    }
    else {
      local_1c = -1.0 / dVar1;
    }
  }
  iVar3 = __isinf(local_1c);
  local_2c = x3;
  if (iVar3 == 0) {
    local_2c = y3 - x3 * local_1c;
  }
  iVar4 = __isinf(dVar1);
  dVar2 = x1;
  if (iVar4 == 0) {
    dVar2 = y1 - x1 * dVar1;
  }
  if (iVar3 == 0) {
    if (iVar4 == 0) {
      dVar1 = (dVar1 - local_1c) / (local_2c - dVar2);
      *x = dVar1;
    }
    else {
      *x = x1;
      dVar1 = x1;
    }
    local_2c = dVar1 * local_1c + local_2c;
  }
  else {
    *x = x3;
    local_2c = y1;
  }
  *y = local_2c;
  dVar1 = x2;
  if (x1 <= x2 || x2 != x1) {
    dVar1 = x1;
  }
  if (dVar1 <= *x) {
    if (x1 <= x2) {
      x1 = x2;
    }
    if (*x <= x1) {
      dVar1 = y2;
      if (y1 <= y2 || y2 != y1) {
        dVar1 = y1;
      }
      if (dVar1 <= local_2c) {
        if (y1 <= y2) {
          y1 = y2;
        }
        return (uint)(local_2c <= y1);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void vertex_move_towards_vertex(GtsVertex *v,GtsVertex *p,gdouble d)

{
  double dVar1;
  gdouble dy;
  gdouble theta;
  gdouble dx;
  double __x;
  double dVar2;
  double dVar3;
  double local_1c;
  double local_14;
  
  dVar3 = (v->p).x;
  dVar2 = (p->p).x - dVar3;
  dVar1 = (p->p).y - (v->p).y;
  __x = atan(ABS(dVar1 / dVar2));
  if (1.797693134862316e+308 < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x132e,"vertex_move_towards_vertex","finite(theta)");
  }
  if (dVar2 < 0.0) {
    if (dVar1 < 0.0) {
      sincos(__x,&local_14,&local_1c);
      (v->p).x = dVar3 - d * local_1c;
      (v->p).y = (v->p).y - local_14 * d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar3 - dVar2 * d;
  }
  else {
    if (dVar1 < 0.0) {
      dVar2 = cos(__x);
      (v->p).x = dVar2 * d + dVar3;
      dVar3 = sin(__x);
      (v->p).y = (v->p).y - dVar3 * d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar2 * d + dVar3;
  }
  (v->p).x = dVar3;
  dVar3 = sin(__x);
  (v->p).y = dVar3 * d + (v->p).y;
  return;
}



// WARNING: Unknown calling convention

void vertex_move_towards_point(GtsVertex *v,gdouble px,gdouble py,gdouble d)

{
  gdouble dy;
  gdouble theta;
  gdouble dx;
  double __x;
  double dVar1;
  double dVar2;
  double local_1c;
  double local_14;
  
  dVar2 = (v->p).x;
  dVar1 = py - (v->p).y;
  __x = atan(ABS(dVar1 / (px - dVar2)));
  if (1.797693134862316e+308 < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x130c,"vertex_move_towards_point","finite(theta)");
  }
  if (px - dVar2 < 0.0) {
    if (dVar1 < 0.0) {
      sincos(__x,&local_14,&local_1c);
      (v->p).x = dVar2 - d * local_1c;
      (v->p).y = (v->p).y - local_14 * d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar2 - dVar1 * d;
  }
  else {
    if (dVar1 < 0.0) {
      dVar1 = cos(__x);
      (v->p).x = dVar1 * d + dVar2;
      dVar2 = sin(__x);
      (v->p).y = (v->p).y - dVar2 * d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar1 * d + dVar2;
  }
  (v->p).x = dVar2;
  dVar2 = sin(__x);
  (v->p).y = dVar2 * d + (v->p).y;
  return;
}



// WARNING: Unknown calling convention

gdouble point_xangle(GtsPoint *a,GtsPoint *b)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  gdouble dx;
  double dVar5;
  
  dVar1 = a->x;
  dVar2 = b->x;
  dVar3 = a->y;
  dVar4 = b->y;
  if (9.999999747378752e-05 <= ABS(dVar1 - dVar2)) {
    dVar5 = atan(ABS(dVar1 - dVar2) / ABS(dVar3 - dVar4));
  }
  else {
    dVar5 = 1.570796326794897;
  }
  if (dVar3 <= dVar4) {
    if (dVar2 < dVar1) {
      dVar5 = 3.141592653589793 - dVar5;
    }
    return dVar5;
  }
  if (dVar1 <= dVar2) {
    return 6.283185307179586 - dVar5;
  }
  return dVar5 + 3.141592653589793;
}



// WARNING: Unknown calling convention

gdouble region_span(toporouter_vertex_region_t *region)

{
  gdouble a1;
  gdouble a2;
  gdouble gVar1;
  gdouble gVar2;
  
  if (region->v1 == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xad8,"region_span","region->v1 != NULL");
  }
  if (region->v2 == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xad9,"region_span","region->v2 != NULL");
  }
  if (region->origin == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xada,"region_span","region->origin != NULL");
  }
  gVar1 = point_xangle((GtsPoint *)region->origin,(GtsPoint *)region->v1);
  gVar2 = point_xangle((GtsPoint *)region->origin,(GtsPoint *)region->v2);
  if (gVar1 <= gVar2) {
    return gVar2 - gVar1;
  }
  return (6.283185307179586 - gVar1) + gVar2;
}



// WARNING: Unknown calling convention

gdouble coord_xangle(gdouble ax,gdouble ay,gdouble bx,gdouble by)

{
  gdouble dx;
  double dVar1;
  
  if (9.999999747378752e-05 <= ABS(ax - bx)) {
    dVar1 = atan(ABS(ay - by) / ABS(ax - bx));
  }
  else {
    dVar1 = 1.570796326794897;
  }
  if (by <= ay) {
    if (bx < ax) {
      dVar1 = 3.141592653589793 - dVar1;
    }
    return dVar1;
  }
  if (ax <= bx) {
    return 6.283185307179586 - dVar1;
  }
  return dVar1 + 3.141592653589793;
}



// WARNING: Unknown calling convention

gdouble export_pcb_drawarc(guint layer,toporouter_arc_t *a,guint thickness,guint keepaway)

{
  double dVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  FlagType Flags;
  ArcTypePtr Ptr2;
  ArcTypePtr arc;
  int iVar5;
  gint wind;
  int in_GS_OFFSET;
  gdouble theta;
  gdouble da;
  gdouble gVar6;
  double dVar7;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  iVar5 = 1;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  dVar7 = (a->centre->v).p.y;
  dVar1 = (a->centre->v).p.x;
  dVar4 = (dVar7 - a->y1) * (a->x1 - a->x0) - (dVar1 - a->x1) * (a->y1 - a->y0);
  if (dVar4 <= 9.999999747378752e-05) {
    iVar5 = (-9.999999747378752e-05 <= dVar4) - 1;
  }
  gVar6 = coord_xangle(a->x0,a->y0,dVar1,dVar7);
  dVar7 = arc_angle(a);
  iVar3 = a->dir;
  if ((9.999999747378752e-05 < dVar4 || dVar4 < -9.999999747378752e-05) && (iVar3 != 0)) {
    if (iVar3 != iVar5) {
      dVar7 = 6.283185307179586 - dVar7;
    }
    dVar1 = ((double)-iVar3 * dVar7 * 180.0) / 3.141592653589793;
    if ((((1.0 <= dVar1) || (dVar1 <= -1.0)) && (dVar1 <= 359.0)) && (-359.0 <= dVar1)) {
      MakeFlags((-(uint)(((PCB->Flags).f & 0x800) == 0) & 0xffffffe0) + 0xa0);
      Flags.t._0_4_ = local_28;
      Flags.f = local_2c;
      Flags.t._4_4_ = local_24;
      Ptr2 = CreateNewArcOnLayer(PCB->Data->Layer + layer,(int)ROUND((a->centre->v).p.x),
                                 (int)ROUND((a->centre->v).p.y),(int)ROUND(a->r),(int)ROUND(a->r),
                                 (int)ROUND((gVar6 * 180.0) / 3.141592653589793),(int)ROUND(dVar1),
                                 thickness,keepaway,Flags);
      if (Ptr2 != (ArcTypePtr)0x0) {
        AddObjectToCreateUndoList(0x4000,PCB->Data->Layer + layer,Ptr2,Ptr2);
        dVar7 = (dVar7 * a->r) / 100.0;
        goto LAB_080dd35a;
      }
    }
  }
  dVar7 = 0.0;
LAB_080dd35a:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return dVar7;
}



// WARNING: Unknown calling convention

void vertex_move_towards_vertex_values(GtsVertex *v,GtsVertex *p,gdouble d,gdouble *x,gdouble *y)

{
  double dVar1;
  gdouble dy;
  gdouble theta;
  gdouble dx;
  double __x;
  double dVar2;
  double dVar3;
  double local_2c;
  double local_24 [2];
  
  dVar3 = (v->p).x;
  dVar2 = (p->p).x - dVar3;
  dVar1 = (p->p).y - (v->p).y;
  __x = atan(ABS(dVar1 / dVar2));
  if (1.797693134862316e+308 < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x382,"vertex_move_towards_vertex_values","finite(theta)")
    ;
  }
  if (dVar2 < 0.0) {
    if (dVar1 < 0.0) {
      sincos(__x,local_24,&local_2c);
      *x = dVar3 - d * local_2c;
      *y = (v->p).y - local_24[0] * d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar3 - dVar2 * d;
  }
  else {
    if (dVar1 < 0.0) {
      dVar2 = cos(__x);
      *x = dVar2 * d + dVar3;
      dVar3 = sin(__x);
      *y = (v->p).y - dVar3 * d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar2 * d + dVar3;
  }
  *x = dVar3;
  dVar3 = sin(__x);
  *y = dVar3 * d + (v->p).y;
  return;
}



// WARNING: Unknown calling convention

void vertex_move_towards_point_values
               (GtsVertex *v,gdouble px,gdouble py,gdouble d,gdouble *x,gdouble *y)

{
  gdouble dy;
  gdouble theta;
  gdouble dx;
  double __x;
  double dVar1;
  double dVar2;
  double local_2c;
  double local_24 [2];
  
  dVar2 = (v->p).x;
  dVar1 = py - (v->p).y;
  __x = atan(ABS(dVar1 / (px - dVar2)));
  if (1.797693134862316e+308 < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x360,"vertex_move_towards_point_values","finite(theta)");
  }
  if (px - dVar2 < 0.0) {
    if (dVar1 < 0.0) {
      sincos(__x,local_24,&local_2c);
      *x = dVar2 - d * local_2c;
      *y = (v->p).y - local_24[0] * d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar2 - dVar1 * d;
  }
  else {
    if (dVar1 < 0.0) {
      dVar1 = cos(__x);
      *x = dVar1 * d + dVar2;
      dVar2 = sin(__x);
      *y = (v->p).y - dVar2 * d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar1 * d + dVar2;
  }
  *x = dVar2;
  dVar2 = sin(__x);
  *y = dVar2 * d + (v->p).y;
  return;
}



// WARNING: Unknown calling convention

void coord_move_towards_coord_values
               (gdouble ax,gdouble ay,gdouble px,gdouble py,gdouble d,gdouble *x,gdouble *y)

{
  gdouble theta;
  gdouble dy;
  gdouble dx;
  double __x;
  double dVar1;
  double local_1c;
  double local_14;
  
  dVar1 = py - ay;
  __x = atan(ABS(dVar1 / (px - ax)));
  if (1.797693134862316e+308 < ABS(__x)) {
    __printf_chk(1,"!finite(theta) a = %f,%f p = %f,%f d = %f\n",ax,ay,px,py,d);
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x33e,"coord_move_towards_coord_values","finite(theta)");
  }
  if (px - ax < 0.0) {
    if (dVar1 < 0.0) {
      sincos(__x,&local_14,&local_1c);
      *x = ax - d * local_1c;
      *y = ay - local_14 * d;
      return;
    }
    dVar1 = cos(__x);
    dVar1 = ax - dVar1 * d;
  }
  else {
    if (dVar1 < 0.0) {
      dVar1 = cos(__x);
      *x = dVar1 * d + ax;
      dVar1 = sin(__x);
      *y = ay - dVar1 * d;
      return;
    }
    dVar1 = cos(__x);
    dVar1 = dVar1 * d + ax;
  }
  *x = dVar1;
  dVar1 = sin(__x);
  *y = dVar1 * d + ay;
  return;
}



// WARNING: Unknown calling convention

void point_from_point_to_point
               (toporouter_vertex_t *a,toporouter_vertex_t *b,gdouble d,gdouble *x,gdouble *y)

{
  double dVar1;
  double dVar2;
  gdouble dy;
  gdouble theta;
  gdouble dx;
  double __x;
  double dVar3;
  double local_2c;
  double local_24 [2];
  
  dVar3 = (a->v).p.x;
  dVar1 = (b->v).p.x - dVar3;
  dVar2 = (b->v).p.y - (a->v).p.y;
  __x = atan(ABS(dVar2 / dVar1));
  if (1.797693134862316e+308 < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x2e0,"point_from_point_to_point","finite(theta)");
  }
  *x = dVar3;
  *y = (a->v).p.y;
  if (dVar1 < 0.0) {
    if (dVar2 < 0.0) {
      sincos(__x,local_24,&local_2c);
      *x = *x - d * local_2c;
      *y = *y - local_24[0] * d;
      return;
    }
    dVar3 = cos(__x);
    dVar3 = *x - dVar3 * d;
  }
  else {
    if (dVar2 < 0.0) {
      dVar3 = cos(__x);
      *x = dVar3 * d + *x;
      dVar3 = sin(__x);
      *y = *y - dVar3 * d;
      return;
    }
    dVar3 = cos(__x);
    dVar3 = dVar3 * d + *x;
  }
  *x = dVar3;
  dVar3 = sin(__x);
  *y = dVar3 * d + *y;
  return;
}



// WARNING: Removing unreachable block (ram,0x080dd9a0)
// WARNING: Unknown calling convention

guint calculate_arc_to_arc(toporouter_t *ar,toporouter_arc_t *parc,toporouter_arc_t *arc)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  toporouter_arc_t *ptVar5;
  int iVar6;
  gint winddir;
  toporouter_arc_t *bigr;
  toporouter_arc_t *ptVar7;
  toporouter_arc_t *smallr;
  gdouble rval;
  gdouble gVar8;
  double dVar9;
  gdouble gVar10;
  int local_f0;
  double local_8c;
  toporouter_vertex_t *local_78;
  toporouter_vertex_t *local_74;
  double local_6c;
  double local_64;
  gdouble local_5c;
  gdouble local_54;
  gdouble local_4c;
  gdouble local_44;
  double local_3c;
  double local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  ptVar7 = arc;
  ptVar5 = parc;
  if (arc->r < parc->r) {
    ptVar7 = parc;
    ptVar5 = arc;
  }
  local_78 = ptVar5->centre;
  local_74 = ptVar7->centre;
  dVar1 = (local_78->v).p.y;
  dVar2 = (local_78->v).p.x;
  dVar3 = (local_74->v).p.x;
  if ((dVar2 == dVar3) ||
     (local_8c = (dVar2 - dVar3) / (dVar1 - (local_74->v).p.y), 1.797693134862316e+308 < local_8c))
  {
    local_8c = 0.0;
  }
  else {
    local_8c = -1.0 / local_8c;
  }
  if (local_78 == local_74) {
    __printf_chk(1,"bigr->centre == smallr->centre @ %f,%f\n",dVar2,dVar1);
    local_74 = ptVar7->centre;
    local_78 = ptVar5->centre;
    if (local_74 == local_78) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x14d1,"calculate_arc_to_arc",
                 "bigr->centre != smallr->centre");
    }
  }
  if (parc->dir == arc->dir) {
    dVar1 = ptVar7->r;
    dVar2 = ptVar5->r;
    gVar8 = gts_point_distance((GtsPoint *)local_74,(GtsPoint *)local_78);
    dVar9 = acos((dVar1 - dVar2) / gVar8);
    sincos(dVar9,&local_64,&local_6c);
    dVar2 = local_64 * ptVar7->r;
    dVar1 = ptVar7->r * local_6c;
    point_from_point_to_point(ptVar7->centre,ptVar5->centre,dVar1,local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,local_8c,dVar2,&local_34,&local_3c,&local_44,&local_4c);
    local_f0 = 1;
    dVar3 = ((ptVar7->centre->v).p.y - local_3c) * (local_34 - (ptVar5->centre->v).p.x) -
            ((ptVar7->centre->v).p.x - local_34) * (local_3c - (ptVar5->centre->v).p.y);
    if ((dVar3 <= 9.999999747378752e-05) && (local_f0 = -1, -9.999999747378752e-05 <= dVar3)) {
      arc_ortho_projections(parc,arc,&local_5c,&local_54);
      __printf_chk(1);
      __printf_chk(1,"bigr centre = %f,%f smallr centre = %f,%f\n",(ptVar7->centre->v).p.x,
                   (ptVar7->centre->v).p.y,(ptVar5->centre->v).p.x,(ptVar5->centre->v).p.y);
      dVar3 = ptVar7->r;
      gVar8 = gts_point_distance((GtsPoint *)ptVar7->centre,(GtsPoint *)ptVar5->centre);
      gVar10 = gts_point_distance((GtsPoint *)ptVar7->centre,(GtsPoint *)ptVar5->centre);
      __printf_chk(1,"theta = %f a = %f b = %f bigrr = %f d = %f po = %f\n",dVar9,dVar2,dVar1,
                   ptVar7->r,gVar10,dVar3 / gVar8);
      dVar1 = ptVar7->r;
      dVar2 = ptVar5->r;
      gVar8 = gts_point_distance((GtsPoint *)ptVar7->centre,(GtsPoint *)ptVar5->centre);
      __printf_chk(1,"bigr-r = %f smallr-r = %f ratio = %f\n",ptVar7->r,ptVar5->r,
                   (dVar1 - dVar2) / gVar8);
      __printf_chk(1,"preva = %f prevb = %f\n\n",local_54,local_5c);
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x14f0,"calculate_arc_to_arc","winddir");
    }
    arc_ortho_projections(parc,arc,&local_5c,&local_54);
    if (ptVar7 == parc) {
      local_f0 = -local_f0;
    }
    if (ptVar7->dir == local_f0) {
      if (ptVar7 == arc) {
        ptVar7->x0 = local_34;
        ptVar7->y0 = local_3c;
      }
      else {
        ptVar7->x1 = local_34;
        ptVar7->y1 = local_3c;
      }
    }
    else if (ptVar7 == arc) {
      ptVar7->x0 = local_44;
      ptVar7->y0 = local_4c;
    }
    else {
      ptVar7->x1 = local_44;
      ptVar7->y1 = local_4c;
    }
    dVar1 = ptVar5->r;
    point_from_point_to_point(ptVar5->centre,ptVar7->centre,-(local_6c * dVar1),local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,local_8c,dVar1 * local_64,&local_34,&local_3c,&local_44,
                   &local_4c);
    if (ptVar7->dir == local_f0) {
      if (ptVar7 != arc) {
        ptVar5->x0 = local_34;
        ptVar5->y0 = local_3c;
        return 0;
      }
      ptVar5->x1 = local_34;
      ptVar5->y1 = local_3c;
      return 0;
    }
  }
  else {
    dVar1 = ptVar7->r;
    dVar2 = ptVar5->r;
    gVar8 = gts_point_distance((GtsPoint *)local_74,(GtsPoint *)local_78);
    dVar9 = acos((dVar1 + dVar2) / gVar8);
    sincos(dVar9,&local_64,&local_6c);
    dVar2 = local_64 * ptVar7->r;
    dVar1 = ptVar7->r * local_6c;
    point_from_point_to_point(ptVar7->centre,ptVar5->centre,dVar1,local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,local_8c,dVar2,&local_34,&local_3c,&local_44,&local_4c);
    local_f0 = 1;
    dVar3 = ((ptVar7->centre->v).p.y - local_3c) * (local_34 - (ptVar5->centre->v).p.x) -
            ((ptVar7->centre->v).p.x - local_34) * (local_3c - (ptVar5->centre->v).p.y);
    if ((dVar3 <= 9.999999747378752e-05) && (local_f0 = -1, -9.999999747378752e-05 <= dVar3)) {
      __printf_chk(1);
      dVar3 = ptVar7->r;
      dVar4 = ptVar5->r;
      gVar8 = gts_point_distance((GtsPoint *)ptVar7->centre,(GtsPoint *)ptVar5->centre);
      gVar10 = gts_point_distance((GtsPoint *)ptVar7->centre,(GtsPoint *)ptVar5->centre);
      __printf_chk(1,"theta = %f a = %f b = %f r = %f d = %f po = %f\n",dVar9,dVar2,dVar1,
                   ptVar7->r + ptVar5->r,gVar10,(dVar3 + dVar4) / gVar8);
      __printf_chk(1,"bigr centre = %f,%f smallr centre = %f,%f\n\n",(ptVar7->centre->v).p.x,
                   (ptVar7->centre->v).p.y,(ptVar5->centre->v).p.x,(ptVar5->centre->v).p.y);
      __printf_chk(1,"big wind = %d small wind = %d\n",ptVar7->dir,ptVar5->dir);
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x154c,"calculate_arc_to_arc","winddir");
    }
    if (ptVar7 == parc) {
      local_f0 = -local_f0;
    }
    if (ptVar7->dir == local_f0) {
      if (ptVar7 == arc) {
        ptVar7->x0 = local_34;
        ptVar7->y0 = local_3c;
      }
      else {
        ptVar7->x1 = local_34;
        ptVar7->y1 = local_3c;
      }
    }
    else if (ptVar7 == arc) {
      ptVar7->x0 = local_44;
      ptVar7->y0 = local_4c;
    }
    else {
      ptVar7->x1 = local_44;
      ptVar7->y1 = local_4c;
    }
    dVar1 = ptVar5->r;
    point_from_point_to_point(ptVar5->centre,ptVar7->centre,local_6c * dVar1,local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,local_8c,dVar1 * local_64,&local_34,&local_3c,&local_44,
                   &local_4c);
    iVar6 = 1;
    dVar1 = ((ptVar7->centre->v).p.y - local_3c) * (local_34 - (ptVar5->centre->v).p.x) -
            ((ptVar7->centre->v).p.x - local_34) * (local_3c - (ptVar5->centre->v).p.y);
    if ((dVar1 <= 9.999999747378752e-05) && (iVar6 = -1, -9.999999747378752e-05 <= dVar1)) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x156b,"calculate_arc_to_arc","winddir");
    }
    if (ptVar7 == parc) {
      iVar6 = -iVar6;
    }
    if (ptVar5->dir == iVar6) {
      if (ptVar7 == arc) {
        ptVar5->x1 = local_34;
        ptVar5->y1 = local_3c;
        return 0;
      }
      ptVar5->x0 = local_34;
      ptVar5->y0 = local_3c;
      return 0;
    }
  }
  if (ptVar7 == arc) {
    ptVar5->x1 = local_44;
    ptVar5->y1 = local_4c;
  }
  else {
    ptVar5->x0 = local_44;
    ptVar5->y0 = local_4c;
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x080de431)
// WARNING: Unknown calling convention

void calculate_term_to_arc(toporouter_vertex_t *v,toporouter_arc_t *arc,guint dir)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  int iVar5;
  gint winddir;
  gdouble theta;
  gdouble gVar6;
  double dVar7;
  double local_5c;
  double local_54;
  gdouble local_4c;
  gdouble local_44;
  double local_3c;
  double local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  dVar7 = arc->r;
  gVar6 = gts_point_distance((GtsPoint *)v,(GtsPoint *)arc->centre);
  dVar7 = acos(dVar7 / gVar6);
  sincos(dVar7,&local_54,&local_5c);
  dVar7 = arc->r;
  point_from_point_to_point(arc->centre,v,local_5c * dVar7,local_24,&local_2c);
  dVar1 = (arc->centre->v).p.x;
  dVar2 = (v->v).p.x;
  if ((dVar1 == dVar2) ||
     (dVar1 = (dVar1 - dVar2) / ((arc->centre->v).p.y - (v->v).p.y), 1.797693134862316e+308 < dVar1)
     ) {
    dVar1 = 0.0;
  }
  else {
    dVar1 = -1.0 / dVar1;
  }
  coords_on_line(local_24[0],local_2c,dVar1,dVar7 * local_54,&local_34,&local_3c,&local_44,&local_4c
                );
  dVar7 = (arc->centre->v).p.y;
  dVar1 = (arc->centre->v).p.x;
  iVar5 = 1;
  dVar2 = (v->v).p.y;
  dVar3 = (v->v).p.x;
  dVar4 = (dVar7 - local_3c) * (local_34 - dVar3) - (dVar1 - local_34) * (local_3c - dVar2);
  if ((dVar4 <= 9.999999747378752e-05) && (iVar5 = -1, -9.999999747378752e-05 <= dVar4)) {
    __printf_chk(1,"!winddir @ v %f,%f arc->centre %f,%f\n",dVar3,dVar2,dVar1,dVar7);
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x147f,"calculate_term_to_arc","winddir");
  }
  if (dir != 0) {
    iVar5 = -iVar5;
  }
  if (arc->dir != iVar5) {
    if (dir != 0) {
      arc->x1 = local_44;
      arc->y1 = local_4c;
      return;
    }
    arc->x0 = local_44;
    arc->y0 = local_4c;
    return;
  }
  if (dir == 0) {
    arc->x0 = local_34;
    arc->y0 = local_3c;
    return;
  }
  arc->x1 = local_34;
  arc->y1 = local_3c;
  return;
}



// WARNING: Unknown calling convention

void clean_routing_edges(toporouter_t *r,toporouter_route_t *data)

{
  g_hash_table_foreach_remove(data->alltemppoints,temp_point_clean,0);
  g_hash_table_destroy(data->alltemppoints);
  data->alltemppoints = (GHashTable *)0x0;
  return;
}



// WARNING: Unknown calling convention

void routedata_insert_temppoints(toporouter_route_t *data,GList *temppoints)

{
  GList *j;
  
  if (temppoints != (GList *)0x0) {
    do {
      g_hash_table_insert(data->alltemppoints,temppoints->data,temppoints->data);
      temppoints = temppoints->next;
    } while (temppoints != (GList *)0x0);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080de869)
// WARNING: Removing unreachable block (ram,0x080de6cb)
// WARNING: Removing unreachable block (ram,0x080de86d)
// WARNING: Removing unreachable block (ram,0x080de870)
// WARNING: Unknown calling convention

gdouble triangle_interior_capacity(GtsTriangle *t,toporouter_vertex_t *v)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  GtsVertex *pGVar5;
  GtsVertex *pGVar6;
  GtsEdge *pGVar7;
  int iVar8;
  int iVar9;
  gdouble m1;
  gdouble x;
  gdouble c1;
  gdouble local_3c;
  double local_34;
  double local_24;
  
  pGVar7 = gts_triangle_edge_opposite(t,&v->v);
  if (pGVar7 == (GtsEdge *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xc1e,"triangle_interior_capacity",&DAT_0815ff3f);
  }
  pGVar5 = (pGVar7->segment).v2;
  pGVar6 = (pGVar7->segment).v1;
  dVar1 = (pGVar5->p).x;
  local_24 = (pGVar6->p).y;
  dVar2 = (pGVar6->p).x;
  if (dVar1 == dVar2) {
    local_34 = 0.0;
    dVar1 = INFINITY;
  }
  else {
    dVar1 = (dVar1 - dVar2) / ((pGVar5->p).y - local_24);
    if (1.797693134862316e+308 < dVar1) {
      local_34 = 0.0;
    }
    else {
      local_34 = -1.0 / dVar1;
    }
  }
  iVar8 = __isinf(local_34);
  if (iVar8 == 0) {
    local_3c = (v->v).p.y - local_34 * (v->v).p.x;
  }
  else {
    local_3c = (v->v).p.x;
  }
  iVar9 = __isinf(dVar1);
  dVar3 = dVar2;
  if (iVar9 == 0) {
    dVar3 = local_24 - dVar2 * dVar1;
  }
  if (iVar8 == 0) {
    if (iVar9 == 0) {
      dVar2 = (local_3c - dVar3) / (dVar1 - local_34);
    }
    local_24 = local_3c + local_34 * dVar2;
  }
  else {
    dVar2 = (v->v).p.x;
  }
  gts_point_distance2(&pGVar6->p,&pGVar5->p);
  pGVar5 = (pGVar7->segment).v1;
  dVar1 = (pGVar5->p).x;
  if ((((dVar2 <= dVar1 - 9.999999747378752e-05) || (dVar1 + 9.999999747378752e-05 <= dVar2)) ||
      (dVar3 = (pGVar5->p).y, local_24 <= dVar3 - 9.999999747378752e-05)) ||
     (dVar3 + 9.999999747378752e-05 <= local_24)) {
    pGVar6 = (pGVar7->segment).v2;
    dVar3 = (pGVar6->p).x;
    if (((dVar2 <= dVar3 - 9.999999747378752e-05) || (dVar3 + 9.999999747378752e-05 <= dVar2)) ||
       ((dVar4 = (pGVar6->p).y, local_24 <= dVar4 - 9.999999747378752e-05 ||
        (dVar4 + 9.999999747378752e-05 <= local_24)))) {
      dVar4 = dVar3;
      if (dVar1 <= dVar3 || dVar3 != dVar1) {
        dVar4 = dVar1;
      }
      if (dVar4 <= dVar2) {
        if (dVar1 <= dVar3) {
          dVar1 = dVar3;
        }
        if (dVar2 <= dVar1) {
          dVar1 = (pGVar5->p).y;
          dVar3 = (pGVar6->p).y;
          dVar4 = dVar3;
          if (dVar1 <= dVar3 || dVar3 != dVar1) {
            dVar4 = dVar1;
          }
          if (dVar4 <= local_24) {
            if (dVar1 <= dVar3) {
              dVar1 = dVar3;
            }
            if (local_24 <= dVar1) {
              dVar2 = (v->v).p.x - dVar2;
              local_24 = (v->v).p.y - local_24;
              return SQRT(local_24 * local_24 + dVar2 * dVar2);
            }
          }
        }
      }
    }
  }
  return INFINITY;
}



// WARNING: Unknown calling convention

GtsPoint * midpoint(GtsPoint *a,GtsPoint *b)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  GtsPointClass *klass;
  GtsPoint *pGVar5;
  
  dVar1 = a->y;
  dVar2 = b->y;
  dVar3 = a->x;
  dVar4 = b->x;
  klass = gts_point_class();
  pGVar5 = gts_point_new(klass,(dVar3 + dVar4) * 0.5,(dVar1 + dVar2) * 0.5,0.0);
  return pGVar5;
}



// WARNING: Unknown calling convention

toporouter_bbox_t *
toporouter_bbox_locate
          (toporouter_t *r,toporouter_term_t type,void *data,gdouble x,gdouble y,guint layergroup)

{
  GSList *pGVar1;
  toporouter_bbox_t *ptVar2;
  GtsPointClass *klass;
  GtsPoint *p_00;
  GtsPoint *p;
  GSList *pGVar3;
  GSList *boxes;
  GSList *i;
  toporouter_bbox_t *box;
  
  klass = gts_point_class();
  p_00 = gts_point_new(klass,x,y,(double)(ulonglong)layergroup);
  pGVar3 = gts_bb_tree_stabbed(r->bboxtree,p_00);
  gts_object_destroy(&p_00->object);
  pGVar1 = pGVar3;
  while( true ) {
    if (pGVar1 == (GSList *)0x0) {
      g_slist_free(pGVar3);
      return (toporouter_bbox_t *)0x0;
    }
    ptVar2 = (toporouter_bbox_t *)pGVar1->data;
    if ((ptVar2->type == type) && (ptVar2->data == data)) break;
    pGVar1 = pGVar1->next;
  }
  g_slist_free(pGVar3);
  return ptVar2;
}



// WARNING: Unknown calling convention

toporouter_cluster_t * cluster_find(toporouter_t *r,gdouble x,gdouble y,gdouble z)

{
  gpointer pvVar1;
  int iVar2;
  double dVar3;
  GtsPointClass *klass;
  GtsPoint *p;
  GSList *pGVar4;
  GSList *hits;
  LineType *line;
  GtsFace *pGVar5;
  toporouter_bbox_t *box;
  gdouble rval;
  toporouter_cluster_t *local_40;
  
  klass = gts_point_class();
  p = gts_point_new(klass,x,y,z);
  pGVar4 = gts_bb_tree_stabbed(r->bboxtree,p);
  local_40 = (toporouter_cluster_t *)0x0;
  if (pGVar4 != (GSList *)0x0) {
    do {
      pvVar1 = pGVar4->data;
      if ((*(int *)((int)pvVar1 + 0x48) == (int)ROUND(z)) && (*(int *)((int)pvVar1 + 0x40) != 7)) {
        if (*(int *)((int)pvVar1 + 0x40) == 5) {
          iVar2 = *(int *)((int)pvVar1 + 0x44);
          dVar3 = ((double)*(int *)(iVar2 + 0x44) - y) * (x - (double)*(int *)(iVar2 + 0x2c)) -
                  ((double)*(int *)(iVar2 + 0x40) - x) * (y - (double)*(int *)(iVar2 + 0x30));
          if ((dVar3 <= 9.999999747378752e-05) && (-9.999999747378752e-05 <= dVar3)) {
            local_40 = *(toporouter_cluster_t **)((int)pvVar1 + 0x60);
          }
        }
        else if ((*(GtsSurface **)((int)pvVar1 + 0x4c) != (GtsSurface *)0x0) &&
                (pGVar5 = gts_point_locate(p,*(GtsSurface **)((int)pvVar1 + 0x4c),(GtsFace *)0x0),
                pGVar5 != (GtsFace *)0x0)) {
          local_40 = *(toporouter_cluster_t **)((int)pvVar1 + 0x60);
          break;
        }
      }
      pGVar4 = pGVar4->next;
    } while (pGVar4 != (GSList *)0x0);
  }
  gts_object_destroy(&p->object);
  return local_40;
}



// WARNING: Unknown calling convention

toporouter_route_t * import_route(toporouter_t *r,RatType *line)

{
  toporouter_route_t *__ptr;
  toporouter_cluster_t *ptVar1;
  _toporouter_cluster_t *p_Var2;
  GList *pGVar3;
  toporouter_route_t *routedata;
  toporouter_route_t *ptVar4;
  
  __ptr = routedata_create();
  ptVar1 = cluster_find(r,(double)(line->Point1).X,(double)(line->Point1).Y,
                        (double)(ulonglong)line->group1);
  __ptr->src = ptVar1;
  p_Var2 = cluster_find(r,(double)(line->Point2).X,(double)(line->Point2).Y,
                        (double)(ulonglong)line->group2);
  __ptr->dest = p_Var2;
  if (__ptr->src == (_toporouter_cluster_t *)0x0) {
    __printf_chk(1,"couldn\'t locate src\n");
    p_Var2 = __ptr->dest;
  }
  if (p_Var2 == (_toporouter_cluster_t *)0x0) {
    __printf_chk(1,"couldn\'t locate dest\n");
  }
  p_Var2 = __ptr->src;
  if ((p_Var2 == (_toporouter_cluster_t *)0x0) || (__ptr->dest == (_toporouter_cluster_t *)0x0)) {
    __printf_chk(1,"PROBLEM: couldn\'t locate rat src or dest for rat %d,%d,%d -> %d,%d,%d\n",
                 (line->Point1).X,(line->Point1).Y,line->group1,(line->Point2).X,(line->Point2).Y,
                 line->group2);
    ptVar4 = (toporouter_route_t *)0x0;
    free(__ptr);
  }
  else {
    __ptr->netlist = p_Var2->netlist;
    if (p_Var2->netlist != __ptr->dest->netlist) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x18d2,"import_route",
                 "routedata->src->netlist == routedata->dest->netlist");
    }
    g_ptr_array_add(r->routes,__ptr);
    g_ptr_array_add(__ptr->netlist->routes,__ptr);
    pGVar3 = (GList *)g_list_prepend(r->failednets,__ptr);
    r->failednets = pGVar3;
    ptVar4 = __ptr;
  }
  return ptVar4;
}



// WARNING: Unknown calling convention

void acquire_twonets(toporouter_t *r)

{
  RatType *line_00;
  RatTypePtr line;
  DataTypePtr paVar1;
  Cardinal n;
  Cardinal n_1;
  int iVar2;
  int iVar3;
  
  paVar1 = PCB->Data;
  iVar2 = paVar1->RatN - 1;
  if (iVar2 != -1) {
    iVar3 = paVar1->RatN * 0x5c;
    while( true ) {
      line_00 = (RatType *)(paVar1->Rat[-1].Flags.t + iVar3 + -0x18);
      if ((*(byte *)&(line_00->Flags).f & 0x40) != 0) {
        import_route(r,line_00);
      }
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      paVar1 = PCB->Data;
      iVar3 = iVar3 + -0x5c;
    }
  }
  if (r->routes->len == 0) {
    paVar1 = PCB->Data;
    iVar2 = paVar1->RatN - 1;
    if (iVar2 != -1) {
      iVar3 = paVar1->RatN * 0x5c;
      while( true ) {
        iVar2 = iVar2 + -1;
        import_route(r,(RatType *)(paVar1->Rat[-1].Flags.t + iVar3 + -0x18));
        if (iVar2 == -1) break;
        paVar1 = PCB->Data;
        iVar3 = iVar3 + -0x5c;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void import_clusters(toporouter_t *r)

{
  char **ppcVar1;
  int iVar2;
  int iVar3;
  toporouter_bbox_t *box_1;
  int group;
  toporouter_netlist_t *netlist;
  GPtrArray *pGVar4;
  toporouter_cluster_t *cluster;
  int iVar5;
  toporouter_bbox_t *ptVar6;
  toporouter_bbox_t *box_3;
  toporouter_bbox_t *box_2;
  toporouter_bbox_t *box;
  toporouter_bbox_t *box_4;
  int iVar7;
  int *piVar8;
  guint count;
  uint uVar9;
  ConnectionTypePtr connection;
  int *piVar10;
  Cardinal *pCVar11;
  guint m;
  uint uVar12;
  NetListListType *pNVar13;
  byte bVar14;
  toporouter_term_t type;
  void *data;
  guint layergroup;
  Cardinal local_64;
  int local_60;
  int local_58;
  int local_50;
  int local_48;
  int local_44;
  Cardinal local_3c [5];
  NetListListType nets;
  
  bVar14 = 0;
  ResetFoundPinsViasAndPads('\0');
  ResetFoundLinesAndPolygons('\0');
  CollectSubnets('\0');
  pCVar11 = local_3c;
  pNVar13 = &nets;
  for (iVar7 = 3; iVar7 != 0; iVar7 = iVar7 + -1) {
    pNVar13->NetListN = *pCVar11;
    pCVar11 = pCVar11 + (uint)bVar14 * -2 + 1;
    pNVar13 = (NetListListType *)((int)pNVar13 + (uint)bVar14 * -8 + 4);
  }
  iVar7 = nets.NetListN * 0xc;
  do {
    do {
      do {
        local_60 = iVar7 + -0xc;
        local_64 = nets.NetListN - 1;
        if (local_64 == 0xffffffff) {
          FreeNetListListMemory((NetListListTypePtr)&nets);
          return;
        }
        piVar8 = (int *)((int)&nets.NetList[-1].NetN + iVar7);
        nets.NetListN = local_64;
        iVar7 = local_60;
      } while (*piVar8 == 0);
      netlist = (toporouter_netlist_t *)calloc(1,0x14);
      ppcVar1 = *(char ***)(*(int *)(piVar8[2] + 8) + 0x18);
      netlist->netlist = *ppcVar1;
      netlist->style = ppcVar1[2];
      pGVar4 = (GPtrArray *)g_ptr_array_new();
      netlist->clusters = pGVar4;
      pGVar4 = (GPtrArray *)g_ptr_array_new();
      netlist->routed = (GList *)0x0;
      netlist->routes = pGVar4;
      g_ptr_array_add(r->netlists,netlist);
      local_58 = *piVar8 + -1;
    } while (local_58 == -1);
    local_50 = (*piVar8 + 0xfffffff) * 0x10;
    do {
      iVar2 = piVar8[2];
      cluster = cluster_create(r,netlist);
      iVar3 = *(int *)(local_50 + iVar2);
      local_44 = iVar3 + -1;
      if (local_44 != -1) {
        local_48 = iVar3 * 0x1c + -0x1c;
        do {
          while( true ) {
            piVar10 = (int *)(local_48 + ((int *)(local_50 + iVar2))[2]);
            iVar3 = piVar10[2];
            if (iVar3 == 4) break;
            if (iVar3 == 0x200) {
              ptVar6 = toporouter_bbox_locate
                                 (r,PAD,(void *)piVar10[4],(double)*piVar10,(double)piVar10[1],
                                  piVar10[5]);
              cluster_join_bbox(cluster,ptVar6);
            }
            else {
              uVar12 = 0;
              if (iVar3 == 0x100) {
                while (iVar3 = PCB->Data->LayerN, 0 < iVar3) {
                  uVar9 = 0;
                  iVar5 = 0;
                  do {
                    uVar9 = (uVar9 + 1) - (uint)((PCB->LayerGroups).Number[iVar5] == 0);
                    iVar5 = iVar5 + 1;
                  } while (iVar5 != iVar3);
                  if (uVar9 <= uVar12) break;
                  ptVar6 = toporouter_bbox_locate
                                     (r,PIN,(void *)piVar10[4],(double)*piVar10,(double)piVar10[1],
                                      uVar12);
                  cluster_join_bbox(cluster,ptVar6);
                  uVar12 = uVar12 + 1;
                }
              }
              else {
                uVar12 = 0;
                if (iVar3 == 1) {
                  while (iVar3 = PCB->Data->LayerN, 0 < iVar3) {
                    uVar9 = 0;
                    iVar5 = 0;
                    do {
                      uVar9 = (uVar9 + 1) - (uint)((PCB->LayerGroups).Number[iVar5] == 0);
                      iVar5 = iVar5 + 1;
                    } while (iVar5 != iVar3);
                    if (uVar9 <= uVar12) break;
                    ptVar6 = toporouter_bbox_locate
                                       (r,VIA,(void *)piVar10[4],(double)*piVar10,(double)piVar10[1]
                                        ,uVar12);
                    cluster_join_bbox(cluster,ptVar6);
                    uVar12 = uVar12 + 1;
                  }
                }
                else if (iVar3 == 8) {
                  layergroup = piVar10[5];
                  iVar3 = piVar10[1];
                  iVar5 = *piVar10;
                  data = (void *)piVar10[4];
                  type = POLYGON;
                  goto LAB_080df0ef;
                }
              }
            }
            local_44 = local_44 + -1;
            local_48 = local_48 + -0x1c;
            if (local_44 == -1) goto LAB_080df11b;
          }
          layergroup = piVar10[5];
          iVar3 = piVar10[1];
          iVar5 = *piVar10;
          data = (void *)piVar10[4];
          type = LINE;
LAB_080df0ef:
          ptVar6 = toporouter_bbox_locate(r,type,data,(double)iVar5,(double)iVar3,layergroup);
          cluster_join_bbox(cluster,ptVar6);
          local_44 = local_44 + -1;
          local_48 = local_48 + -0x1c;
        } while (local_44 != -1);
      }
LAB_080df11b:
      local_58 = local_58 + -1;
      local_50 = local_50 + -0x10;
    } while (local_58 != -1);
  } while( true );
}



// WARNING: Unknown calling convention

gdouble triangle_cost(GtsTriangle *t,gpointer *data)

{
  double *pdVar1;
  double *pdVar2;
  gdouble *min_quality;
  gdouble area;
  gdouble quality;
  gdouble gVar3;
  gdouble gVar4;
  
  pdVar1 = (double *)*data;
  pdVar2 = (double *)data[1];
  gVar3 = gts_triangle_quality(t);
  gVar4 = gts_triangle_area(t);
  if ((*pdVar1 <= gVar3) && (gVar4 <= *pdVar2)) {
    gVar3 = 0.0;
  }
  return gVar3;
}



// WARNING: Unknown calling convention

GSList * list_to_slist(GList *i)

{
  GSList *pGVar1;
  GSList *rval;
  
  pGVar1 = (GSList *)0x0;
  if (i != (GList *)0x0) {
    do {
      pGVar1 = (GSList *)g_slist_prepend(pGVar1,i->data);
      i = i->next;
    } while (i != (GList *)0x0);
  }
  return pGVar1;
}



// WARNING: Unknown calling convention

gdouble lookup_thickness(char *name)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  Cardinal n;
  PCBTypePtr pPVar4;
  
  pPVar1 = PCB;
  iVar2 = Settings.LineThickness;
  if (name != (char *)0x0) {
    iVar3 = 0;
    pPVar4 = PCB;
    do {
      iVar2 = strcmp(pPVar4->RouteStyle[0].Name,name);
      if (iVar2 == 0) {
        iVar2 = pPVar1->RouteStyle[iVar3].Thick;
        break;
      }
      iVar3 = iVar3 + 1;
      pPVar4 = (PCBTypePtr)&pPVar4->PrintFilename;
      iVar2 = Settings.LineThickness;
    } while (iVar3 != 4);
  }
  return (double)iVar2;
}



// WARNING: Unknown calling convention

gdouble vertex_net_thickness(toporouter_vertex_t *v)

{
  toporouter_term_t tVar1;
  PadType *pad;
  PinType *pin;
  void *pvVar2;
  toporouter_bbox_t *box;
  _toporouter_bbox_t *p_Var3;
  gdouble gVar4;
  
  if (v == (toporouter_vertex_t *)0x0) goto LAB_080df392;
  p_Var3 = v->bbox;
  if (p_Var3 == (_toporouter_bbox_t *)0x0) {
    if ((v->flags & 0x180) == 0) goto LAB_080df392;
    do {
      v = v->parent;
      if (v == (_toporouter_vertex_t *)0x0) goto LAB_080df392;
    } while ((v->flags & 0x180) != 0);
    p_Var3 = v->bbox;
    if (p_Var3 == (_toporouter_bbox_t *)0x0) goto LAB_080df392;
  }
  else {
    tVar1 = p_Var3->type;
    if (tVar1 + ~PAD < 2) {
      pvVar2 = p_Var3->data;
      if ((*(uint *)((int)pvVar2 + 0x14) & 0x900) != 0) {
        return 0.0;
      }
LAB_080df34c:
      return (double)*(int *)((int)pvVar2 + 0x24);
    }
    if (tVar1 == PAD) {
      pvVar2 = p_Var3->data;
      if (*(int *)((int)pvVar2 + 0x2c) != *(int *)((int)pvVar2 + 0x40)) {
        return 0.0;
      }
      if (*(int *)((int)pvVar2 + 0x30) != *(int *)((int)pvVar2 + 0x44)) {
        return 0.0;
      }
      if ((*(byte *)((int)pvVar2 + 0x15) & 1) != 0) {
        return 0.0;
      }
      goto LAB_080df34c;
    }
    if (tVar1 == BOARD) {
      return 0.0;
    }
    if (tVar1 == LINE) {
      pvVar2 = p_Var3->data;
      goto LAB_080df34c;
    }
    if (tVar1 == POLYGON) {
      return 0.0;
    }
    __printf_chk(1,"Unrecognized type in thickness lookup..\n");
  }
  if (p_Var3->cluster != (_toporouter_cluster_t *)0x0) {
    gVar4 = lookup_thickness(p_Var3->cluster->netlist->style);
    return gVar4;
  }
LAB_080df392:
  return (double)Settings.LineThickness;
}



// WARNING: Unknown calling convention

gdouble lookup_keepaway(char *name)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  Cardinal n;
  PCBTypePtr pPVar4;
  
  pPVar1 = PCB;
  iVar2 = Settings.Keepaway;
  if (name != (char *)0x0) {
    iVar3 = 0;
    pPVar4 = PCB;
    do {
      iVar2 = strcmp(pPVar4->RouteStyle[0].Name,name);
      if (iVar2 == 0) {
        iVar2 = pPVar1->RouteStyle[iVar3].Keepaway;
        break;
      }
      iVar3 = iVar3 + 1;
      pPVar4 = (PCBTypePtr)&pPVar4->PrintFilename;
      iVar2 = Settings.Keepaway;
    } while (iVar3 != 4);
  }
  return (double)iVar2;
}



// WARNING: Unknown calling convention

gdouble oproute_min_spacing(toporouter_oproute_t *a,toporouter_oproute_t *b)

{
  gdouble gVar1;
  gdouble gVar2;
  gdouble gVar3;
  gdouble gVar4;
  double dVar5;
  
  gVar1 = lookup_thickness(a->style);
  gVar2 = lookup_thickness(b->style);
  gVar3 = lookup_keepaway(a->style);
  gVar4 = lookup_keepaway(b->style);
  if (gVar4 < gVar3) {
    dVar5 = lookup_keepaway(a->style);
  }
  else {
    dVar5 = lookup_keepaway(b->style);
  }
  return gVar2 * 0.5 + gVar1 * 0.5 + dVar5;
}



// WARNING: Unknown calling convention

void export_oproutes(toporouter_t *ar,toporouter_oproute_t *oproute)

{
  double dVar1;
  guint layer;
  toporouter_vertex_t *ptVar2;
  guint gVar3;
  guint gVar4;
  guint thickness;
  guint keepaway;
  guint gVar5;
  toporouter_arc_t *ptVar6;
  toporouter_arc_t *arc;
  GList *arcs;
  GList *pGVar7;
  toporouter_arc_t *a;
  toporouter_arc_t *parc;
  toporouter_arc_t *a_00;
  gdouble gVar8;
  gdouble gVar9;
  guint local_44;
  guint local_2c;
  
  layer = (PCB->LayerGroups).Entries[oproute->layergroup][0];
  gVar8 = lookup_thickness(oproute->style);
  local_2c = (guint)(longlong)ROUND(gVar8);
  thickness = local_2c;
  gVar8 = lookup_keepaway(oproute->style);
  pGVar7 = oproute->arcs;
  local_2c = (guint)(longlong)ROUND(gVar8);
  keepaway = local_2c;
  if (pGVar7 == (GList *)0x0) {
    dVar1 = ar->wiring_score;
    local_2c = (guint)(longlong)ROUND((oproute->term2->v).p.y);
    gVar3 = local_2c;
    local_2c = (guint)(longlong)ROUND((oproute->term2->v).p.x);
    gVar4 = local_2c;
    local_2c = (guint)(longlong)ROUND((oproute->term1->v).p.y);
    gVar5 = local_2c;
    local_2c = (guint)(longlong)ROUND((oproute->term1->v).p.x);
    gVar8 = export_pcb_drawline(layer,local_2c,gVar5,gVar4,gVar3,thickness,keepaway);
    ar->wiring_score = gVar8 + dVar1;
    return;
  }
  dVar1 = ar->wiring_score;
  ptVar6 = (toporouter_arc_t *)pGVar7->data;
  a_00 = (toporouter_arc_t *)0x0;
  do {
    a = ptVar6;
    if (a == (toporouter_arc_t *)0x0) {
      if (a_00 != (toporouter_arc_t *)0x0) {
        dVar1 = ar->wiring_score;
        goto LAB_080df55c;
      }
LAB_080df579:
      local_44 = (guint)(longlong)ROUND(a->y0);
      gVar3 = local_44;
      local_44 = (guint)(longlong)ROUND(a->x0);
      gVar4 = local_44;
      local_44 = (guint)(longlong)ROUND((oproute->term1->v).p.y);
      local_2c = (guint)(longlong)ROUND((oproute->term1->v).p.x);
      gVar8 = export_pcb_drawline(layer,local_2c,local_44,gVar4,gVar3,thickness,keepaway);
      pGVar7 = (GList *)(&pGVar7->data)[1];
      dVar1 = dVar1 + gVar8;
      ar->wiring_score = dVar1;
    }
    else {
      if (a_00 == (toporouter_arc_t *)0x0) goto LAB_080df579;
      gVar8 = export_pcb_drawarc(layer,a_00,thickness,keepaway);
      ar->wiring_score = dVar1 + gVar8;
      local_2c = (guint)(longlong)ROUND(a->y0);
      gVar3 = local_2c;
      local_2c = (guint)(longlong)ROUND(a->x0);
      gVar4 = local_2c;
      local_2c = (guint)(longlong)ROUND(a_00->y1);
      gVar5 = local_2c;
      local_2c = (guint)(longlong)ROUND(a_00->x1);
      gVar9 = export_pcb_drawline(layer,local_2c,gVar5,gVar4,gVar3,thickness,keepaway);
      dVar1 = dVar1 + gVar8 + gVar9;
      ar->wiring_score = dVar1;
LAB_080df55c:
      pGVar7 = (GList *)(&pGVar7->data)[1];
    }
    if (pGVar7 == (GList *)0x0) {
      gVar8 = export_pcb_drawarc(layer,a,thickness,keepaway);
      ptVar2 = oproute->term2;
      ar->wiring_score = dVar1 + gVar8;
      local_2c = (guint)(longlong)ROUND((ptVar2->v).p.y);
      gVar3 = local_2c;
      local_2c = (guint)(longlong)ROUND((ptVar2->v).p.x);
      gVar4 = local_2c;
      local_2c = (guint)(longlong)ROUND(a->y1);
      gVar5 = local_2c;
      local_2c = (guint)(longlong)ROUND(a->x1);
      gVar9 = export_pcb_drawline(layer,local_2c,gVar5,gVar4,gVar3,thickness,keepaway);
      ar->wiring_score = dVar1 + gVar8 + gVar9;
      return;
    }
    ptVar6 = (toporouter_arc_t *)pGVar7->data;
    a_00 = a;
  } while( true );
}



// WARNING: Unknown calling convention

gdouble vertex_net_keepaway(toporouter_vertex_t *v)

{
  toporouter_bbox_t *box;
  _toporouter_bbox_t *p_Var1;
  gdouble gVar2;
  
  if (v == (toporouter_vertex_t *)0x0) goto LAB_080df848;
  p_Var1 = v->bbox;
  if (p_Var1 == (_toporouter_bbox_t *)0x0) {
    if ((v->flags & 0x180) == 0) goto LAB_080df848;
    do {
      v = v->parent;
      if (v == (_toporouter_vertex_t *)0x0) goto LAB_080df848;
    } while ((v->flags & 0x180) != 0);
    p_Var1 = v->bbox;
    if (p_Var1 == (_toporouter_bbox_t *)0x0) goto LAB_080df848;
  }
  if (p_Var1->cluster != (_toporouter_cluster_t *)0x0) {
    gVar2 = lookup_keepaway(p_Var1->cluster->netlist->style);
    return gVar2;
  }
LAB_080df848:
  return (double)Settings.Keepaway;
}



// WARNING: Unknown calling convention

toporouter_arc_class_t * toporouter_arc_class(void)

{
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (toporouter_arc_class::klass == (toporouter_arc_class_t *)0x0) {
    pGVar2 = &constraint_info;
    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name[0] = 't';
    constraint_info.name[1] = 'o';
    constraint_info.name[2] = 'p';
    constraint_info.name[3] = 'o';
    constraint_info.name[4] = 'r';
    constraint_info.name[5] = 'o';
    constraint_info.name[6] = 'u';
    constraint_info.name[7] = 't';
    constraint_info.name[8] = 'e';
    constraint_info.name[9] = 'r';
    constraint_info.name[10] = '_';
    constraint_info.name[11] = 'a';
    constraint_info.name[12] = 'r';
    constraint_info.name[13] = 'c';
    constraint_info.name[14] = '_';
    constraint_info.name[15] = 't';
    constraint_info.object_size = 0x50;
    constraint_info.class_size = 0x60;
    constraint_info.object_init_func = toporouter_arc_init;
    parent_class = (GtsObjectClass *)gts_constraint_class();
    toporouter_arc_class::klass =
         (toporouter_arc_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return toporouter_arc_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

toporouter_arc_t *
toporouter_arc_new(toporouter_oproute_t *oproute,toporouter_vertex_t *v1,toporouter_vertex_t *v2,
                  toporouter_vertex_t *centre,gdouble r,gint dir)

{
  toporouter_arc_class_t *klass;
  toporouter_arc_t *ptVar1;
  toporouter_arc_t *arc;
  
  klass = toporouter_arc_class();
  ptVar1 = (toporouter_arc_t *)gts_object_new(&klass->parent_class);
  ptVar1->centre = centre;
  ptVar1->v = v1;
  ptVar1->r = r;
  ptVar1->v1 = v1;
  ptVar1->v2 = v2;
  ptVar1->dir = dir;
  if (v1 != (toporouter_vertex_t *)0x0) {
    v1->arc = ptVar1;
  }
  ptVar1->clearance = (GList *)0x0;
  ptVar1->oproute = oproute;
  return ptVar1;
}



// WARNING: Unknown calling convention

toporouter_constraint_class_t * toporouter_constraint_class(void)

{
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (toporouter_constraint_class::klass == (toporouter_constraint_class_t *)0x0) {
    pGVar2 = &constraint_info;
    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name[0] = 't';
    constraint_info.name[1] = 'o';
    constraint_info.name[2] = 'p';
    constraint_info.name[3] = 'o';
    constraint_info.name[4] = 'r';
    constraint_info.name[5] = 'o';
    constraint_info.name[6] = 'u';
    constraint_info.name[7] = 't';
    constraint_info.name[8] = 'e';
    constraint_info.name[9] = 'r';
    constraint_info.name[10] = '_';
    constraint_info.name[11] = 'c';
    constraint_info.name[12] = 'o';
    constraint_info.name[13] = 'n';
    constraint_info.name[14] = 's';
    constraint_info.name[15] = 't';
    constraint_info.name[16] = 'r';
    constraint_info.name[17] = 'a';
    constraint_info.name[18] = 'i';
    constraint_info.name[19] = 'n';
    constraint_info.name[20] = 't';
    constraint_info.name[21] = '_';
    constraint_info.name[22] = 't';
    constraint_info.name[23] = '\0';
    constraint_info.object_size = 0x20;
    constraint_info.class_size = 0x5c;
    constraint_info.class_init_func = toporouter_constraint_class_init;
    constraint_info.object_init_func = toporouter_constraint_init;
    parent_class = (GtsObjectClass *)gts_constraint_class();
    toporouter_constraint_class::klass =
         (toporouter_constraint_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return toporouter_constraint_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

toporouter_vertex_class_t * toporouter_vertex_class(void)

{
  GtsVertexClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (toporouter_vertex_class::klass == (toporouter_vertex_class_t *)0x0) {
    pGVar2 = &constraint_info;
    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name[0] = 't';
    constraint_info.name[1] = 'o';
    constraint_info.name[2] = 'p';
    constraint_info.name[3] = 'o';
    constraint_info.name[4] = 'r';
    constraint_info.name[5] = 'o';
    constraint_info.name[6] = 'u';
    constraint_info.name[7] = 't';
    constraint_info.name[8] = 'e';
    constraint_info.name[9] = 'r';
    constraint_info.name[10] = '_';
    constraint_info.name[11] = 'v';
    constraint_info.name[12] = 'e';
    constraint_info.name[13] = 'r';
    constraint_info.name[14] = 't';
    constraint_info.name[15] = 'e';
    constraint_info.name[16] = 'x';
    constraint_info.name[17] = '_';
    constraint_info.name[18] = 't';
    constraint_info.name[19] = '\0';
    constraint_info.object_size = 100;
    constraint_info.class_size = 100;
    constraint_info.class_init_func = toporouter_vertex_class_init;
    constraint_info.object_init_func = toporouter_vertex_init;
    parent_class = gts_vertex_class();
    toporouter_vertex_class::klass =
         (toporouter_vertex_class_t *)
         gts_object_class_new((GtsObjectClass *)parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return toporouter_vertex_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Removing unreachable block (ram,0x080dfb0f)
// WARNING: Removing unreachable block (ram,0x080dfb17)
// WARNING: Removing unreachable block (ram,0x080dfb20)
// WARNING: Unknown calling convention

void create_board_edge(gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble max,gint layer,
                      GList **vlist)

{
  double dVar1;
  uint uVar2;
  GtsVertexClass *klass;
  guint n;
  GtsVertex *pGVar3;
  GList *pGVar4;
  uint uVar5;
  guint count;
  GtsVertexClass *vertex_class;
  ulonglong local_3c;
  gdouble local_2c;
  gdouble local_24 [2];
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  dVar1 = SQRT((y0 - y1) * (y0 - y1) + (x0 - x1) * (x0 - x1));
  local_3c = (ulonglong)ROUND(dVar1 / max);
  uVar2 = (uint)local_3c;
  if ((uint)local_3c != 0) {
    local_3c = local_3c & 0xffffffff;
    local_24[0] = x0;
    local_2c = y0;
    pGVar3 = gts_vertex_new(klass,x0,y0,(double)layer);
    pGVar4 = (GList *)g_list_prepend(*vlist,pGVar3);
    *vlist = pGVar4;
    if (uVar2 != 1) {
      uVar5 = 1;
      do {
        uVar5 = uVar5 + 1;
        coord_move_towards_coord_values(x0,y0,x1,y1,dVar1 / (double)local_3c,local_24,&local_2c);
        pGVar3 = gts_vertex_new(klass,local_24[0],local_2c,(double)layer);
        pGVar4 = (GList *)g_list_prepend(*vlist,pGVar3);
        *vlist = pGVar4;
        x0 = local_24[0];
        y0 = local_2c;
      } while (uVar5 < uVar2);
    }
    return;
  }
  local_24[0] = x0;
  local_2c = y0;
  pGVar3 = gts_vertex_new(klass,x0,y0,(double)layer);
  pGVar4 = (GList *)g_list_prepend(*vlist,pGVar3);
  *vlist = pGVar4;
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

GList * rect_with_attachments
                  (gdouble rad,gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble x2,gdouble y2,
                  gdouble x3,gdouble y3,gdouble z)

{
  GtsVertex *pGVar1;
  GtsVertexClass *klass;
  GtsVertex *pGVar2;
  undefined4 uVar3;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GList *pGVar6;
  GList *rr;
  GList *i;
  toporouter_vertex_t *curpoint;
  GList *r;
  toporouter_vertex_t *temppoint;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar2 = gts_vertex_new(klass,x0,y0,z);
  uVar3 = g_list_prepend(0,pGVar2);
  pGVar4 = gts_vertex_new(klass,x1,y1,z);
  uVar3 = g_list_prepend(uVar3,pGVar4);
  pGVar4 = gts_vertex_new(klass,x2,y2,z);
  uVar3 = g_list_prepend(uVar3,pGVar4);
  pGVar4 = gts_vertex_new(klass,x3,y3,z);
  pGVar5 = (GtsVertex *)g_list_prepend(uVar3,pGVar4);
  pGVar6 = (GList *)0x0;
  pGVar4 = pGVar5;
  if (pGVar5 == (GtsVertex *)0x0) {
    pGVar6 = (GList *)0x0;
  }
  else {
    do {
      pGVar1 = *(GtsVertex **)&pGVar4->p;
      pGVar6 = (GList *)g_list_prepend(pGVar6,pGVar2);
      pGVar4 = *(GtsVertex **)((int)&pGVar4->p + 4);
      pGVar2 = pGVar1;
    } while (pGVar4 != (GtsVertex *)0x0);
  }
  g_list_free(pGVar5);
  return pGVar6;
}



// WARNING: Unknown calling convention

void insert_centre_point(toporouter_t *r,toporouter_layer_t *l,gdouble x,gdouble y)

{
  GtsVertexClass *klass;
  GtsVertex *pGVar1;
  GList *pGVar2;
  GtsPoint *p;
  GList *i;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar2 = l->vertices;
  while( true ) {
    if (pGVar2 == (GList *)0x0) {
      pGVar1 = gts_vertex_new(klass,x,y,0.0);
      pGVar2 = (GList *)g_list_prepend(l->vertices,pGVar1);
      l->vertices = pGVar2;
      return;
    }
    if ((*(double *)((int)pGVar2->data + 0xc) == x) && (*(double *)((int)pGVar2->data + 0x14) == y))
    break;
    pGVar2 = pGVar2->next;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080dff25)
// WARNING: Removing unreachable block (ram,0x080dff38)
// WARNING: Unknown calling convention

GList * insert_constraint_edge
                  (toporouter_t *r,toporouter_layer_t *l,gdouble x1,gdouble y1,guint flags1,
                  gdouble x2,gdouble y2,guint flags2,toporouter_bbox_t *box)

{
  double dVar1;
  GtsVertex *pGVar2;
  GtsVertexClass *klass;
  GtsEdgeClass *klass_00;
  GList *i;
  GtsEdge *pGVar3;
  GList *pGVar4;
  GtsVertex *v;
  GtsVertex *v2;
  GtsEdge *e;
  GtsVertex *v1;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  klass_00 = (GtsEdgeClass *)toporouter_constraint_class();
  pGVar4 = l->vertices;
  if (pGVar4 == (GList *)0x0) {
    v2 = (GtsVertex *)0x0;
  }
  else {
    v2 = (GtsVertex *)0x0;
    v1 = (GtsVertex *)0x0;
    do {
      pGVar2 = (GtsVertex *)pGVar4->data;
      dVar1 = (pGVar2->p).x;
      if ((dVar1 == x1) && ((pGVar2->p).y == y1)) {
        v1 = pGVar2;
      }
      if ((dVar1 == x2) && ((pGVar2->p).y == y2)) {
        v2 = pGVar2;
      }
      pGVar4 = (GList *)(&pGVar4->data)[1];
    } while (pGVar4 != (GList *)0x0);
    if (v1 != (GtsVertex *)0x0) goto LAB_080dff4e;
  }
  v1 = gts_vertex_new(klass,x1,y1,(double)((int)l - (int)r->layers >> 4));
  v1[1].p.object.klass = (GtsObjectClass *)box;
  pGVar4 = (GList *)g_list_prepend(l->vertices,v1);
  l->vertices = pGVar4;
LAB_080dff4e:
  if (v2 == (GtsVertex *)0x0) {
    v2 = gts_vertex_new(klass,x2,y2,(double)((int)l - (int)r->layers >> 4));
    v2[1].p.object.klass = (GtsObjectClass *)box;
    pGVar4 = (GList *)g_list_prepend(l->vertices,v2);
    l->vertices = pGVar4;
  }
  *(guint *)((int)&v1[1].p.x + 4) = flags1;
  *(guint *)((int)&v2[1].p.x + 4) = flags2;
  pGVar3 = gts_edge_new(klass_00,v1,v2);
  pGVar3[1].segment.object.klass = (GtsObjectClass *)box;
  pGVar4 = (GList *)g_list_prepend(l->constraints,pGVar3);
  l->constraints = pGVar4;
  pGVar4 = (GList *)g_list_prepend();
  return pGVar4;
}



// WARNING: Unknown calling convention

void insert_constraints_from_list
               (toporouter_t *r,toporouter_layer_t *l,GList *vlist,toporouter_bbox_t *box)

{
  gpointer pvVar1;
  toporouter_vertex_t *v;
  GList *pGVar2;
  GList *pGVar3;
  gpointer pvVar4;
  toporouter_vertex_t *pv;
  GList *i;
  
  pvVar4 = (gpointer)0x0;
  if (vlist != (GList *)0x0) {
    pvVar4 = vlist->data;
    for (pGVar3 = vlist->next; pGVar3 != (GList *)0x0; pGVar3 = pGVar3->next) {
      pvVar1 = pGVar3->data;
      if (pvVar4 != (gpointer)0x0) {
        pGVar2 = insert_constraint_edge
                           (r,l,*(gdouble *)((int)pvVar1 + 0xc),*(gdouble *)((int)pvVar1 + 0x14),
                            *(guint *)((int)pvVar1 + 0x38),*(gdouble *)((int)pvVar4 + 0xc),
                            *(gdouble *)((int)pvVar4 + 0x14),*(guint *)((int)pvVar4 + 0x38),box);
        pGVar2 = (GList *)g_list_concat(box->constraints,pGVar2);
        box->constraints = pGVar2;
      }
      pvVar4 = pvVar1;
    }
  }
  pvVar1 = vlist->data;
  pGVar3 = insert_constraint_edge
                     (r,l,*(gdouble *)((int)pvVar1 + 0xc),*(gdouble *)((int)pvVar1 + 0x14),
                      *(guint *)((int)pvVar1 + 0x38),*(gdouble *)((int)pvVar4 + 0xc),
                      *(gdouble *)((int)pvVar4 + 0x14),*(guint *)((int)pvVar4 + 0x38),box);
  pGVar3 = (GList *)g_list_concat(box->constraints,pGVar3);
  box->constraints = pGVar3;
  return;
}



// WARNING: Unknown calling convention

GtsVertex *
insert_vertex(toporouter_t *r,toporouter_layer_t *l,gdouble x,gdouble y,toporouter_bbox_t *box)

{
  GtsVertexClass *klass;
  GtsVertex *pGVar1;
  GList *pGVar2;
  GList *i;
  GtsVertex *v;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar2 = l->vertices;
  while( true ) {
    if (pGVar2 == (GList *)0x0) {
      pGVar1 = gts_vertex_new(klass,x,y,(double)((int)l - (int)r->layers >> 4));
      pGVar1[1].p.object.klass = (GtsObjectClass *)box;
      pGVar2 = (GList *)g_list_prepend(l->vertices,pGVar1);
      l->vertices = pGVar2;
      return pGVar1;
    }
    pGVar1 = (GtsVertex *)pGVar2->data;
    if (((pGVar1->p).x == x) && ((pGVar1->p).y == y)) break;
    pGVar2 = (GList *)(&pGVar2->data)[1];
  }
  pGVar1[1].p.object.klass = (GtsObjectClass *)box;
  return pGVar1;
}



// WARNING: Unknown calling convention

GtsVertex * vertex_intersect(GtsVertex *a,GtsVertex *b,GtsVertex *c,GtsVertex *d)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  GtsVertexClass *klass;
  int iVar9;
  GtsVertex *pGVar10;
  GtsVertex *rval;
  gdouble ua;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  iVar9 = point_intersect_prop(&a->p,&b->p,&c->p,&d->p);
  pGVar10 = (GtsVertex *)0x0;
  if (iVar9 != 0) {
    dVar1 = (c->p).x;
    dVar5 = (d->p).x - dVar1;
    dVar2 = (a->p).y;
    dVar3 = (c->p).y;
    dVar7 = (d->p).y - dVar3;
    dVar4 = (a->p).x;
    dVar8 = (b->p).x - dVar4;
    dVar6 = (b->p).y - dVar2;
    dVar1 = ((dVar2 - dVar3) * dVar5 - (dVar4 - dVar1) * dVar7) / (dVar7 * dVar8 - dVar5 * dVar6);
    pGVar10 = gts_vertex_new(klass,dVar1 * dVar8 + dVar4,dVar6 * dVar1 + dVar2,0.0);
  }
  return pGVar10;
}



// WARNING: Unknown calling convention

void speccut_edge_routing_from_edge(GList *i,toporouter_edge_t *e)

{
  uint *puVar1;
  GtsVertex *a;
  guint32 gVar2;
  gpointer pvVar3;
  GtsVertex *pGVar4;
  GList *pGVar5;
  undefined4 uVar6;
  gint index;
  toporouter_vertex_t *curv;
  
  if (i == (GList *)0x0) {
    return;
  }
  do {
    while ((a = (GtsVertex *)i->data, *(char *)((int)&a[1].p.x + 4) < '\0' ||
           (pGVar4 = vertex_intersect(a,(GtsVertex *)a[1].p.object.reserved,(e->e).segment.v1,
                                      (e->e).segment.v2), pGVar4 == (GtsVertex *)0x0))) {
LAB_080e02b8:
      i = (GList *)(&i->data)[1];
      if (i == (GList *)0x0) {
        return;
      }
    }
    puVar1 = (uint *)((int)&pGVar4[1].p.x + 4);
    *puVar1 = *puVar1 | 0x900;
    pGVar5 = (GList *)g_list_insert_sorted_with_data(e->routing,pGVar4,routing_edge_insert,e);
    pGVar4[1].p.object.flags = (guint32)a;
    *(toporouter_edge_t **)&pGVar4[1].p.x = e;
    e->routing = pGVar5;
    gVar2 = a[2].p.object.flags;
    (pGVar4->p).z = (a->p).z;
    pGVar4[2].p.object.flags = gVar2;
    pGVar4[2].p.object.reserved = a[2].p.object.reserved;
    pGVar4[1].p.object.reserved = a[1].p.object.reserved;
    uVar6 = g_list_index(*(undefined4 *)(pGVar4[2].p.object.flags + 0x2c),a);
    gVar2 = pGVar4[2].p.object.flags;
    uVar6 = g_list_insert(*(undefined4 *)(gVar2 + 0x2c),pGVar4,uVar6);
    *(undefined4 *)(gVar2 + 0x2c) = uVar6;
    pvVar3 = pGVar4[2].p.object.reserved;
    if (pvVar3 == (gpointer)0x0) goto LAB_080e02b8;
    *(undefined4 *)((int)pvVar3 + 0x20) = *(undefined4 *)(pGVar4[2].p.object.flags + 0x2c);
    i = (GList *)(&i->data)[1];
    if (i == (GList *)0x0) {
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

toporouter_bbox_class_t * toporouter_bbox_class(void)

{
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (toporouter_bbox_class::class == (toporouter_bbox_class_t *)0x0) {
    pGVar2 = &constraint_info;
    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name[0] = 't';
    constraint_info.name[1] = 'o';
    constraint_info.name[2] = 'p';
    constraint_info.name[3] = 'o';
    constraint_info.name[4] = 'r';
    constraint_info.name[5] = 'o';
    constraint_info.name[6] = 'u';
    constraint_info.name[7] = 't';
    constraint_info.name[8] = 'e';
    constraint_info.name[9] = 'r';
    constraint_info.name[10] = '_';
    constraint_info.name[11] = 'b';
    constraint_info.name[12] = 'b';
    constraint_info.name[13] = 'o';
    constraint_info.name[14] = 'x';
    constraint_info.name[15] = '_';
    constraint_info.name[16] = 't';
    constraint_info.name[17] = '\0';
    constraint_info.name[18] = '\0';
    constraint_info.name[19] = '\0';
    constraint_info.object_size = 100;
    constraint_info.class_size = 0x5c;
    constraint_info.object_init_func = toporouter_bbox_init;
    parent_class = (GtsObjectClass *)gts_bbox_class();
    toporouter_bbox_class::class =
         (toporouter_bbox_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return toporouter_bbox_class::class;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

toporouter_bbox_t *
toporouter_bbox_create_from_points(int layer,GList *vertices,toporouter_term_t type,gpointer data)

{
  GSList *points;
  GtsBBoxClass *klass;
  toporouter_bbox_t *ptVar1;
  GSList *vertices_slist;
  
  points = list_to_slist(vertices);
  klass = (GtsBBoxClass *)toporouter_bbox_class();
  ptVar1 = (toporouter_bbox_t *)gts_bbox_points(klass,points);
  ptVar1->surface = (GtsSurface *)0x0;
  ptVar1->enclosing = (GtsTriangle *)0x0;
  ptVar1->point = (GtsPoint *)0x0;
  ptVar1->type = type;
  ptVar1->realpoint = (GtsPoint *)0x0;
  ptVar1->data = data;
  ptVar1->layer = layer;
  g_slist_free(points);
  return ptVar1;
}



// WARNING: Removing unreachable block (ram,0x080e051a)
// WARNING: Unknown calling convention

int read_lines(toporouter_t *r,toporouter_layer_t *l,LayerType *layer,int ln)

{
  double y;
  double y_00;
  double x;
  double x_00;
  int iVar1;
  GtsVertexClass *klass;
  GtsVertex *pGVar2;
  undefined4 uVar3;
  GList *pGVar4;
  int layer_00;
  toporouter_bbox_t *box;
  GSList *pGVar5;
  GList *vlist;
  int iVar6;
  toporouter_bbox_t *bbox;
  uchar *data;
  Cardinal n;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  iVar6 = layer->LineN - 1;
  if (iVar6 != -1) {
    iVar1 = layer->LineN * 0x58;
    do {
      data = layer->Line[-1].Flags.t + iVar1 + -0x18;
      x = (double)*(int *)(data + 0x2c);
      x_00 = (double)*(int *)(data + 0x40);
      y = (double)*(int *)(data + 0x30);
      y_00 = (double)*(int *)(data + 0x44);
      if ((x != x_00) || (y != y_00)) {
        pGVar2 = gts_vertex_new(klass,x,y,(double)((int)l - (int)r->layers >> 4));
        uVar3 = g_list_prepend(0,pGVar2);
        pGVar2 = gts_vertex_new(klass,x_00,y_00,(double)((int)l - (int)r->layers >> 4));
        pGVar4 = (GList *)g_list_prepend(uVar3,pGVar2);
        layer_00 = GetLayerGroupNumberByNumber(ln);
        box = toporouter_bbox_create_from_points(layer_00,pGVar4,LINE,data);
        pGVar5 = (GSList *)g_slist_prepend(r->bboxes,box);
        r->bboxes = pGVar5;
        g_list_free(pGVar4);
        pGVar4 = insert_constraint_edge(r,l,x,y,0,x_00,y_00,0,box);
        pGVar4 = (GList *)g_list_concat(box->constraints,pGVar4);
        box->constraints = pGVar4;
      }
      iVar6 = iVar6 + -1;
      iVar1 = iVar1 + -0x58;
    } while (iVar6 != -1);
  }
  return 0;
}



// WARNING: Unknown calling convention

toporouter_edge_class_t * toporouter_edge_class(void)

{
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (toporouter_edge_class::class == (toporouter_edge_class_t *)0x0) {
    pGVar2 = &constraint_info;
    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name[0] = 't';
    constraint_info.name[1] = 'o';
    constraint_info.name[2] = 'p';
    constraint_info.name[3] = 'o';
    constraint_info.name[4] = 'r';
    constraint_info.name[5] = 'o';
    constraint_info.name[6] = 'u';
    constraint_info.name[7] = 't';
    constraint_info.name[8] = 'e';
    constraint_info.name[9] = 'r';
    constraint_info.name[10] = '_';
    constraint_info.name[11] = 'e';
    constraint_info.name[12] = 'd';
    constraint_info.name[13] = 'g';
    constraint_info.name[14] = 'e';
    constraint_info.name[15] = '_';
    constraint_info.name[16] = 't';
    constraint_info.name[17] = '\0';
    constraint_info.name[18] = '\0';
    constraint_info.name[19] = '\0';
    constraint_info.object_size = 0x20;
    constraint_info.class_size = 0x5c;
    constraint_info.object_init_func = toporouter_edge_init;
    parent_class = (GtsObjectClass *)gts_edge_class();
    toporouter_edge_class::class =
         (toporouter_edge_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return toporouter_edge_class::class;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void build_cdt(toporouter_t *r,toporouter_layer_t *l)

{
  GtsEdge *e3;
  GtsEdge *e2;
  GtsEdge *e1;
  GList *pGVar1;
  GSList *pGVar2;
  GtsTriangleClass *klass;
  GtsTriangle *t_00;
  GtsVertexClass *vertex_class;
  GtsEdgeClass *edge_class;
  GtsFaceClass *pGVar3;
  GtsSurfaceClass *klass_00;
  GtsSurface *pGVar4;
  GtsFace *f;
  GtsVertex *pGVar5;
  GtsTriangle *t;
  GList *i;
  GSList *vertices_slist;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  pGVar2 = list_to_slist(l->vertices);
  klass = gts_triangle_class();
  t_00 = gts_triangle_enclosing(klass,pGVar2,1000.0);
  gts_triangle_vertices(t_00,local_20,&local_24,&local_28);
  g_slist_free(pGVar2);
  vertex_class = (GtsVertexClass *)toporouter_vertex_class();
  edge_class = (GtsEdgeClass *)toporouter_edge_class();
  pGVar3 = gts_face_class();
  klass_00 = gts_surface_class();
  pGVar4 = gts_surface_new(klass_00,pGVar3,edge_class,vertex_class);
  e3 = t_00->e3;
  e2 = t_00->e2;
  e1 = t_00->e1;
  l->surface = pGVar4;
  pGVar3 = gts_face_class();
  f = gts_face_new(pGVar3,e1,e2,e3);
  gts_surface_add_face(l->surface,f);
  for (pGVar1 = l->vertices; pGVar1 != (GList *)0x0; pGVar1 = (GList *)(&pGVar1->data)[1]) {
    pGVar5 = gts_delaunay_add_vertex(l->surface,(GtsVertex *)pGVar1->data,(GtsFace *)0x0);
    if (pGVar5 != (GtsVertex *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x8d8,"build_cdt",
                 "gts_delaunay_add_vertex (l->surface, i->data, NULL) == NULL");
    }
  }
  pGVar1 = l->constraints;
  while( true ) {
    if (pGVar1 == (GList *)0x0) {
      gts_allow_floating_vertices = 1;
      gts_object_destroy((GtsObject *)local_20[0]);
      gts_object_destroy((GtsObject *)local_24);
      gts_object_destroy((GtsObject *)local_28);
      gts_allow_floating_vertices = 0;
      return;
    }
    pGVar2 = gts_delaunay_add_constraint(l->surface,(GtsConstraint *)pGVar1->data);
    if (pGVar2 != (GSList *)0x0) break;
    pGVar1 = pGVar1->next;
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr
            (0,"../../src/toporouter.c",0x907,"build_cdt",
             "gts_delaunay_add_constraint (l->surface, i->data) == NULL");
}



// WARNING: Unknown calling convention

void route_restore(toporouter_route_t *route)

{
  gpointer pvVar1;
  GtsObjectClass *pGVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GtsObjectClass **ppGVar4;
  toporouter_vertex_t *v;
  GList *i;
  GList *pGVar5;
  toporouter_vertex_t *pv;
  gpointer pvVar6;
  int local_20;
  
  pGVar5 = route->ppath;
  if (pGVar5 == (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1aca,"route_restore","route->ppath");
  }
  if (route->ppathindices == (gint *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x1acb,"route_restore","route->ppathindices");
  }
  route->path = pGVar5;
  local_20 = 0;
  pvVar6 = (gpointer)0x0;
  do {
    pvVar1 = pGVar5->data;
    if (*(int *)((int)pvVar1 + 0x34) != 0) {
      pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
      ppGVar4 = *(GtsObjectClass ***)((int)pvVar1 + 0x34);
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        ppGVar4 = *(GtsObjectClass ***)((int)pvVar1 + 0x34);
      }
      else if (ppGVar4 != (GtsObjectClass **)0x0) {
        pGVar3 = *ppGVar4;
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          ppGVar4 = *(GtsObjectClass ***)((int)pvVar1 + 0x34);
        }
        else {
          do {
            if (pGVar2 == pGVar3) break;
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
        }
      }
      pGVar2 = (GtsObjectClass *)
               g_list_insert(ppGVar4[7],pvVar1,*(undefined4 *)((int)route->ppathindices + local_20))
      ;
      ppGVar4[7] = pGVar2;
    }
    if (pvVar6 != (gpointer)0x0) {
      *(gpointer *)((int)pvVar6 + 0x30) = pvVar1;
      *(gpointer *)((int)pvVar1 + 0x2c) = pvVar6;
    }
    pGVar5 = pGVar5->next;
    local_20 = local_20 + 4;
    pvVar6 = pvVar1;
    if (pGVar5 == (GList *)0x0) {
      route->score = route->pscore;
      route->src = route->psrc;
      route->dest = route->pdest;
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

gint apply_route(GList *path,toporouter_route_t *routedata)

{
  _toporouter_vertex_t *p_Var1;
  GtsObjectClass *pGVar2;
  GList *pGVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  toporouter_edge_t *ptVar5;
  toporouter_vertex_t *tv;
  GList *i;
  GList *pGVar6;
  toporouter_vertex_t *pv;
  int local_20;
  
  local_20 = 0;
  if (path != (GList *)0x0) {
    pGVar6 = path;
    pv = (toporouter_vertex_t *)0x0;
    do {
      p_Var1 = (_toporouter_vertex_t *)pGVar6->data;
      if (p_Var1->routingedge != (toporouter_edge_t *)0x0) {
        pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
        ptVar5 = p_Var1->routingedge;
        if (pGVar2 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          ptVar5 = p_Var1->routingedge;
        }
        else if (ptVar5 != (toporouter_edge_t *)0x0) {
          pGVar4 = (ptVar5->e).segment.object.klass;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            ptVar5 = p_Var1->routingedge;
          }
          else {
            do {
              if (pGVar2 == pGVar4) break;
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
        pGVar3 = (GList *)g_list_insert_sorted_with_data
                                    (ptVar5->routing,p_Var1,routing_edge_insert,ptVar5);
        local_20 = local_20 + 1;
        ptVar5->routing = pGVar3;
      }
      if (pv != (toporouter_vertex_t *)0x0) {
        pv->child = p_Var1;
        p_Var1->parent = pv;
      }
      if (((*(byte *)((int)&p_Var1->flags + 1) & 1) != 0) && (p_Var1->route != routedata)) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/toporouter.c",0x1948,"apply_route","tv->route == routedata");
      }
      pGVar6 = (GList *)(&pGVar6->data)[1];
      pv = p_Var1;
    } while (pGVar6 != (GList *)0x0);
    p_Var1->child = (_toporouter_vertex_t *)0x0;
    *(undefined4 *)((int)path->data + 0x2c) = 0;
  }
  return local_20;
}



// WARNING: Unknown calling convention

void remove_route(GList *path)

{
  gpointer pvVar1;
  GtsObjectClass *pGVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  toporouter_vertex_t *tv;
  GList *i;
  GtsObjectClass **ppGVar4;
  
  i = path;
  if (path != (GList *)0x0) {
    do {
      pvVar1 = i->data;
      *(undefined4 *)((int)pvVar1 + 0x2c) = 0;
      *(undefined4 *)((int)pvVar1 + 0x30) = 0;
      if (*(int *)((int)pvVar1 + 0x34) != 0) {
        pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
        ppGVar4 = *(GtsObjectClass ***)((int)pvVar1 + 0x34);
        if (pGVar2 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          ppGVar4 = *(GtsObjectClass ***)((int)pvVar1 + 0x34);
        }
        else if (ppGVar4 != (GtsObjectClass **)0x0) {
          pGVar3 = *ppGVar4;
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            ppGVar4 = *(GtsObjectClass ***)((int)pvVar1 + 0x34);
          }
          else {
            do {
              if (pGVar2 == pGVar3) break;
              pGVar3 = pGVar3->parent_class;
            } while (pGVar3 != (GtsObjectClass *)0x0);
          }
        }
        pGVar2 = (GtsObjectClass *)g_list_remove(ppGVar4[7],pvVar1);
        ppGVar4[7] = pGVar2;
      }
      i = i->next;
    } while (i != (GList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void route_checkpoint(toporouter_route_t *route,toporouter_route_t *temproute)

{
  int iVar1;
  int *piVar2;
  gint *pgVar3;
  GtsObjectClass *pGVar4;
  int iVar5;
  gint tempindex;
  GtsObjectClass **ppGVar6;
  GtsObjectClass *c_2;
  GtsObjectClass *c_1;
  GtsObjectClass *c;
  GtsObjectClass *pGVar7;
  GList *j;
  toporouter_vertex_t *v;
  int local_24;
  int *local_20;
  
  local_20 = (int *)g_list_last(route->path);
  local_24 = g_list_length(route->path);
  if (route->ppathindices != (gint *)0x0) {
    free(route->ppathindices);
  }
  pgVar3 = (gint *)calloc(1,local_24 * 4);
  route->ppathindices = pgVar3;
  if (local_20 != (int *)0x0) {
    local_24 = local_24 * 4;
    do {
      local_24 = local_24 + -4;
      iVar1 = *local_20;
      if (*(int *)(iVar1 + 0x34) != 0) {
        pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
        ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
        }
        else if (ppGVar6 != (GtsObjectClass **)0x0) {
          pGVar7 = *ppGVar6;
          if (pGVar7 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
          }
          else {
            do {
              if (pGVar4 == pGVar7) break;
              pGVar7 = pGVar7->parent_class;
            } while (pGVar7 != (GtsObjectClass *)0x0);
          }
        }
        iVar5 = g_list_find(ppGVar6[7],iVar1);
        piVar2 = *(int **)(iVar5 + 8);
        pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
        ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
        }
        else if (ppGVar6 != (GtsObjectClass **)0x0) {
          pGVar7 = *ppGVar6;
          if (pGVar7 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
          }
          else {
            do {
              if (pGVar4 == pGVar7) break;
              pGVar7 = pGVar7->parent_class;
            } while (pGVar7 != (GtsObjectClass *)0x0);
          }
        }
        iVar5 = g_list_index(ppGVar6[7],iVar1);
        for (; piVar2 != (int *)0x0; piVar2 = (int *)piVar2[2]) {
          iVar5 = iVar5 - (uint)(*(toporouter_route_t **)(*piVar2 + 0x58) == temproute);
        }
        *(int *)((int)route->ppathindices + local_24) = iVar5;
        pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
        ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
        }
        else if (ppGVar6 != (GtsObjectClass **)0x0) {
          pGVar7 = *ppGVar6;
          if (pGVar7 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            ppGVar6 = *(GtsObjectClass ***)(iVar1 + 0x34);
          }
          else {
            do {
              if (pGVar4 == pGVar7) break;
              pGVar7 = pGVar7->parent_class;
            } while (pGVar7 != (GtsObjectClass *)0x0);
          }
        }
        pGVar4 = (GtsObjectClass *)g_list_remove(ppGVar6[7],iVar1);
        ppGVar6[7] = pGVar4;
      }
      local_20 = (int *)local_20[2];
    } while (local_20 != (int *)0x0);
  }
  route->pscore = route->score;
  route->ppath = route->path;
  remove_route(route->path);
  route->path = (GList *)0x0;
  route->psrc = route->src;
  route->pdest = route->dest;
  return;
}



// WARNING: Unknown calling convention

void delete_route(toporouter_route_t *routedata,guint destroy)

{
  GList *pGVar1;
  GtsVertex *v1;
  GtsObject *object;
  gpointer pvVar2;
  GtsVertex *v2;
  toporouter_vertex_t *tv;
  GtsObjectClass *pGVar3;
  GtsSegment *pGVar4;
  GtsObjectClass *c;
  GtsObjectClass *pGVar5;
  GList *i;
  toporouter_vertex_t *tv_1;
  GList *pGVar6;
  GtsObjectClass **ppGVar7;
  
  pGVar6 = routedata->path;
  if (pGVar6 != (GList *)0x0) {
    if ((GtsVertex *)pGVar6->data == (GtsVertex *)0x0) {
LAB_080e1010:
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x18e5,"delete_route",&DAT_081516de);
    }
    v2 = (GtsVertex *)pGVar6->data;
    for (pGVar1 = pGVar6->next; pGVar1 != (GList *)0x0; pGVar1 = (GList *)(&pGVar1->data)[1]) {
      v1 = (GtsVertex *)pGVar1->data;
      if (v1 == (GtsVertex *)0x0) goto LAB_080e1010;
      if (((((*(byte *)((int)&v1[1].p.x + 5) & 1) == 0) &&
           ((*(byte *)((int)&v2[1].p.x + 5) & 1) == 0)) &&
          (pGVar4 = gts_vertices_are_connected(v1,v2), pGVar4 != (GtsSegment *)0x0)) &&
         (pvVar2 = pGVar4[1].object.reserved, ((uint)pvVar2 & 1) != 0)) {
        pGVar4[1].object.reserved = (gpointer)((uint)pvVar2 ^ 1);
      }
      v2 = v1;
    }
    pGVar6 = routedata->path;
    if (pGVar6 != (GList *)0x0) {
      do {
        object = (GtsObject *)pGVar6->data;
        pvVar2 = object[4].reserved;
        object[3].flags = 0;
        object[4].klass = (GtsObjectClass *)0x0;
        if (pvVar2 != (gpointer)0x0) {
          pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
          ppGVar7 = (GtsObjectClass **)object[4].reserved;
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            ppGVar7 = (GtsObjectClass **)object[4].reserved;
          }
          else if (ppGVar7 != (GtsObjectClass **)0x0) {
            pGVar5 = *ppGVar7;
            if (pGVar5 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
              ppGVar7 = (GtsObjectClass **)object[4].reserved;
            }
            else {
              do {
                if (pGVar3 == pGVar5) break;
                pGVar5 = pGVar5->parent_class;
              } while (pGVar5 != (GtsObjectClass *)0x0);
            }
          }
          pGVar3 = (GtsObjectClass *)g_list_remove(ppGVar7[7],object);
          ppGVar7[7] = pGVar3;
          if (destroy != 0) {
            gts_object_destroy(object);
          }
        }
        pGVar6 = pGVar6->next;
      } while (pGVar6 != (GList *)0x0);
      if (routedata->path != (GList *)0x0) {
        g_list_free(routedata->path);
      }
    }
  }
  routedata->path = (GList *)0x0;
  routedata->curpoint = (toporouter_vertex_t *)0x0;
  routedata->score = INFINITY;
  routedata->alltemppoints = (GHashTable *)0x0;
  return;
}



// WARNING: Unknown calling convention

gdouble pathvertex_arcing_through_constraint(toporouter_vertex_t *pathv,toporouter_vertex_t *arcv)

{
  byte bVar1;
  toporouter_edge_t *ptVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar4;
  toporouter_vertex_t *v;
  _toporouter_vertex_t *p_Var5;
  gdouble gVar6;
  
  p_Var5 = pathv->child;
  if ((p_Var5 != (_toporouter_vertex_t *)0x0) &&
     (ptVar2 = p_Var5->routingedge, ptVar2 != (toporouter_edge_t *)0x0)) {
    if ((*(byte *)((int)&p_Var5->flags + 1) & 1) != 0) {
      while (((toporouter_vertex_t *)(ptVar2->e).segment.v1 == arcv ||
             ((toporouter_vertex_t *)(ptVar2->e).segment.v2 == arcv))) {
        pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
        ptVar2 = p_Var5->routingedge;
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (ptVar2 != (toporouter_edge_t *)0x0) {
          pGVar4 = (ptVar2->e).segment.object.klass;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar3 == pGVar4) goto LAB_080e10fb;
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
        p_Var5 = p_Var5->child;
        if ((*(byte *)((int)&p_Var5->flags + 1) & 1) == 0) break;
        ptVar2 = p_Var5->routingedge;
      }
    }
    p_Var5 = pathv->parent;
    bVar1 = *(byte *)((int)&p_Var5->flags + 1);
    while (((bVar1 & 1) != 0 &&
           (((toporouter_vertex_t *)(p_Var5->routingedge->e).segment.v1 == arcv ||
            ((toporouter_vertex_t *)(p_Var5->routingedge->e).segment.v2 == arcv))))) {
      pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
      ptVar2 = p_Var5->routingedge;
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (ptVar2 != (toporouter_edge_t *)0x0) {
        pGVar4 = (ptVar2->e).segment.object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar3 == pGVar4) {
LAB_080e10fb:
              gVar6 = gts_point_distance(&((ptVar2->e).segment.v1)->p,&((ptVar2->e).segment.v2)->p);
              return gVar6;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
      p_Var5 = p_Var5->parent;
      bVar1 = *(byte *)((int)&p_Var5->flags + 1);
    }
  }
  return 0.0;
}



// WARNING: Unknown calling convention

void split_edge_routing(toporouter_vertex_t *v,GList **l1,GList **l2)

{
  GtsObjectClass *pGVar1;
  int iVar2;
  GList *pGVar3;
  toporouter_edge_t *ptVar4;
  GtsObjectClass *c;
  GtsObjectClass *pGVar5;
  GList *i;
  int *piVar6;
  
  if (v == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x10e5,"split_edge_routing",&DAT_081601a8);
  }
  if (v->routingedge == (toporouter_edge_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x10e6,"split_edge_routing","v->routingedge");
  }
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar4 = v->routingedge;
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    ptVar4 = v->routingedge;
  }
  else if (ptVar4 != (toporouter_edge_t *)0x0) {
    pGVar5 = (ptVar4->e).segment.object.klass;
    if (pGVar5 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      ptVar4 = v->routingedge;
    }
    else {
      do {
        if (pGVar1 == pGVar5) break;
        pGVar5 = pGVar5->parent_class;
      } while (pGVar5 != (GtsObjectClass *)0x0);
    }
  }
  iVar2 = g_list_find(ptVar4->routing,v);
  pGVar3 = (GList *)g_list_prepend(*l1,(v->routingedge->e).segment.v1);
  *l1 = pGVar3;
  pGVar3 = (GList *)g_list_prepend(*l2,(v->routingedge->e).segment.v2);
  *l2 = pGVar3;
  if (iVar2 == 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x10ed,"split_edge_routing","base");
  }
  for (piVar6 = *(int **)(iVar2 + 4); piVar6 != (int *)0x0; piVar6 = (int *)piVar6[1]) {
    while (*(char *)(*piVar6 + 0x38) < '\0') {
      piVar6 = (int *)piVar6[1];
      if (piVar6 == (int *)0x0) goto LAB_080e12e9;
    }
    pGVar3 = (GList *)g_list_prepend(*l2,*piVar6);
    *l2 = pGVar3;
  }
LAB_080e12e9:
  piVar6 = *(int **)(iVar2 + 8);
  do {
    if (piVar6 == (int *)0x0) {
      return;
    }
    while (*(char *)(*piVar6 + 0x38) < '\0') {
      piVar6 = (int *)piVar6[2];
      if (piVar6 == (int *)0x0) {
        return;
      }
    }
    pGVar3 = (GList *)g_list_prepend(*l1,*piVar6);
    *l1 = pGVar3;
    piVar6 = (int *)piVar6[2];
  } while( true );
}



// WARNING: Unknown calling convention

GList * edge_routing_first_not_temp(toporouter_edge_t *e)

{
  GtsObjectClass *pGVar1;
  GList *i;
  GList *pGVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar3 = (e->e).segment.object.klass;
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar3) break;
        pGVar3 = pGVar3->parent_class;
      } while (pGVar3 != (GtsObjectClass *)0x0);
    }
  }
  pGVar2 = e->routing;
  while ((pGVar2 != (GList *)0x0 && (*(char *)((int)pGVar2->data + 0x38) < '\0'))) {
    pGVar2 = pGVar2->next;
  }
  return pGVar2;
}



// WARNING: Unknown calling convention

toporouter_vertex_t * edge_routing_prev_not_temp(toporouter_edge_t *e,GList *list)

{
  GtsObjectClass *pGVar1;
  toporouter_vertex_t *v;
  GtsObjectClass *c;
  GtsObjectClass *pGVar2;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar2 = (e->e).segment.object.klass;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar2) goto LAB_080e14d6;
        pGVar2 = pGVar2->parent_class;
      } while (pGVar2 != (GtsObjectClass *)0x0);
    }
  }
  for (; list != (GList *)0x0; list = (GList *)(&list->data)[2]) {
    if (-1 < *(char *)&((toporouter_vertex_t *)list->data)->flags) {
      return (toporouter_vertex_t *)list->data;
    }
  }
LAB_080e14d6:
  return (toporouter_vertex_t *)(e->e).segment.v1;
}



// WARNING: Unknown calling convention

toporouter_vertex_t * edge_routing_next_not_temp(toporouter_edge_t *e,GList *list)

{
  GtsObjectClass *pGVar1;
  toporouter_vertex_t *v;
  GtsObjectClass *c;
  GtsObjectClass *pGVar2;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar2 = (e->e).segment.object.klass;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar2) goto LAB_080e1576;
        pGVar2 = pGVar2->parent_class;
      } while (pGVar2 != (GtsObjectClass *)0x0);
    }
  }
  for (; list != (GList *)0x0; list = (GList *)(&list->data)[1]) {
    if (-1 < *(char *)&((toporouter_vertex_t *)list->data)->flags) {
      return (toporouter_vertex_t *)list->data;
    }
  }
LAB_080e1576:
  return (toporouter_vertex_t *)(e->e).segment.v2;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

gdouble flow_from_edge_to_edge
                  (GtsTriangle *t,toporouter_edge_t *e1,toporouter_edge_t *e2,
                  toporouter_vertex_t *common_v,toporouter_vertex_t *curpoint)

{
  toporouter_vertex_t *ptVar1;
  toporouter_vertex_t *ptVar2;
  toporouter_vertex_t *ptVar3;
  toporouter_edge_t *ptVar4;
  GtsVertex *pGVar5;
  int iVar6;
  GtsObjectClass *pGVar7;
  GList *i;
  GtsEdge *pGVar8;
  toporouter_edge_t *op_edge;
  toporouter_vertex_t *ptVar9;
  GtsObjectClass *c;
  toporouter_vertex_t *ptVar10;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar11;
  GList *pGVar12;
  toporouter_bbox_t *box;
  toporouter_vertex_t *v;
  gdouble v1keepaway;
  gdouble gVar13;
  double dVar14;
  double dVar15;
  gdouble gVar16;
  gdouble gVar17;
  double local_2c;
  double local_24;
  
  pGVar7 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar7 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e1 != (toporouter_edge_t *)0x0) {
    pGVar11 = (e1->e).segment.object.klass;
    if (pGVar11 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar7 == pGVar11) break;
        pGVar11 = pGVar11->parent_class;
      } while (pGVar11 != (GtsObjectClass *)0x0);
    }
  }
  pGVar12 = e1->routing;
  if (pGVar12 == (GList *)0x0) {
    local_2c = 0.0;
    local_24._0_4_ = common_v;
  }
  else {
    local_2c = 0.0;
    local_24._0_4_ = common_v;
    do {
      ptVar9 = (toporouter_vertex_t *)pGVar12->data;
      if (ptVar9 == curpoint) {
        gVar13 = vertex_net_thickness(curpoint);
        gVar16 = vertex_net_thickness(local_24._0_4_);
        dVar14 = vertex_net_keepaway(curpoint);
        gVar17 = vertex_net_keepaway(local_24._0_4_);
        pGVar12 = (GList *)(&pGVar12->data)[1];
        local_24._0_4_ = curpoint;
        if (dVar14 <= gVar17) {
          dVar14 = gVar17;
        }
        local_2c = gVar16 * 0.5 + gVar13 * 0.5 + dVar14 + local_2c;
      }
      else if (((*(byte *)((int)&ptVar9->flags + 1) & 1) == 0) ||
              (((ptVar9->parent == (_toporouter_vertex_t *)0x0 ||
                (ptVar9->parent->routingedge != e2)) &&
               ((ptVar9->child == (_toporouter_vertex_t *)0x0 || (ptVar9->child->routingedge != e2))
               )))) {
        pGVar12 = (GList *)(&pGVar12->data)[1];
      }
      else {
        gVar13 = vertex_net_thickness(ptVar9);
        gVar16 = vertex_net_thickness(local_24._0_4_);
        dVar14 = vertex_net_keepaway(ptVar9);
        gVar17 = vertex_net_keepaway(local_24._0_4_);
        pGVar12 = (GList *)(&pGVar12->data)[1];
        if (dVar14 <= gVar17) {
          dVar14 = gVar17;
        }
        local_2c = gVar16 * 0.5 + gVar13 * 0.5 + dVar14 + local_2c;
        local_24._0_4_ = ptVar9;
      }
    } while (pGVar12 != (GList *)0x0);
  }
  pGVar8 = gts_triangle_edge_opposite(t,&common_v->v);
  if (pGVar8 == (GtsEdge *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xc97,"flow_from_edge_to_edge","op_edge");
  }
  if (e1 == (toporouter_edge_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xc98,"flow_from_edge_to_edge",&DAT_081516e9);
  }
  if (e2 != (toporouter_edge_t *)0x0) {
    ptVar9 = (toporouter_vertex_t *)(pGVar8->segment).v1;
    ptVar1 = (toporouter_vertex_t *)(e2->e).segment.v1;
    ptVar10 = ptVar9;
    if (((((ptVar1 != ptVar9) &&
          (ptVar2 = (toporouter_vertex_t *)(e2->e).segment.v2, ptVar9 != ptVar2)) &&
         (ptVar3 = (toporouter_vertex_t *)(pGVar8->segment).v2, ptVar10 = ptVar1, ptVar1 != ptVar3))
        && (ptVar10 = ptVar2, ptVar2 != ptVar3)) || (ptVar10 == (toporouter_vertex_t *)0x0)) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0xc9c,"flow_from_edge_to_edge",&DAT_081601a8);
    }
    if ((((*(byte *)((int)&ptVar10->flags + 1) & 1) != 0) &&
        (ptVar10->parent != (_toporouter_vertex_t *)0x0)) &&
       ((ptVar4 = ptVar10->parent->routingedge, ptVar4 != (toporouter_edge_t *)0x0 && (e1 == ptVar4)
        ))) {
      gVar13 = vertex_net_thickness(ptVar10);
      gVar16 = vertex_net_thickness(local_24._0_4_);
      dVar14 = vertex_net_keepaway(ptVar10);
      gVar17 = vertex_net_keepaway(local_24._0_4_);
      ptVar9 = (toporouter_vertex_t *)(pGVar8->segment).v1;
      if (dVar14 <= gVar17) {
        dVar14 = gVar17;
      }
      local_2c = gVar16 * 0.5 + gVar13 * 0.5 + dVar14 + local_2c;
    }
    ptVar1 = (toporouter_vertex_t *)(e1->e).segment.v1;
    if ((((ptVar1 == ptVar9) ||
         (ptVar10 = (toporouter_vertex_t *)(e1->e).segment.v2, ptVar9 == ptVar10)) ||
        ((ptVar2 = (toporouter_vertex_t *)(pGVar8->segment).v2, ptVar9 = ptVar1, ptVar1 == ptVar2 ||
         (ptVar9 = ptVar10, ptVar10 == ptVar2)))) && (ptVar9 != (toporouter_vertex_t *)0x0)) {
      if (((((*(byte *)((int)&ptVar9->flags + 1) & 1) != 0) &&
           (ptVar9->parent != (_toporouter_vertex_t *)0x0)) &&
          (ptVar4 = ptVar9->parent->routingedge, ptVar4 != (toporouter_edge_t *)0x0)) &&
         (e1 == ptVar4)) {
        gVar13 = vertex_net_thickness(ptVar9);
        gVar16 = vertex_net_thickness(local_24._0_4_);
        dVar14 = vertex_net_keepaway(ptVar9);
        gVar17 = vertex_net_keepaway(local_24._0_4_);
        if (dVar14 <= gVar17) {
          dVar14 = gVar17;
        }
        local_2c = gVar16 * 0.5 + gVar13 * 0.5 + dVar14 + local_2c;
      }
      pGVar7 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar7 != (GtsObjectClass *)0x0) {
        pGVar11 = (pGVar8->segment).object.klass;
        if (pGVar11 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          return local_2c;
        }
        while (pGVar7 != pGVar11) {
          pGVar11 = pGVar11->parent_class;
          if (pGVar11 == (GtsObjectClass *)0x0) {
            return local_2c;
          }
        }
        pGVar5 = (pGVar8->segment).v1;
        if (pGVar5 == (GtsVertex *)0x0) {
          gVar13 = vertex_net_thickness(ptVar9);
          local_24 = gVar13 * 0.5 + local_2c;
        }
        else {
          pGVar7 = pGVar5[1].p.object.klass;
          gVar13 = vertex_net_thickness(ptVar9);
          local_24 = gVar13 * 0.5 + local_2c;
          if (pGVar7 != (GtsObjectClass *)0x0) {
            gVar13 = vertex_net_keepaway(ptVar9);
            iVar6 = *(int *)(pGVar7[1].info.name + 4);
            if (iVar6 == 0) {
              dVar14 = lookup_keepaway((char *)0x0);
            }
            else {
              dVar14 = lookup_keepaway(*(char **)(*(int *)(iVar6 + 0xc) + 0xc));
            }
            if (dVar14 < gVar13) {
              dVar14 = vertex_net_keepaway(ptVar9);
              iVar6 = *(int *)(pGVar7[1].info.name + 4);
            }
            else {
              iVar6 = *(int *)(pGVar7[1].info.name + 4);
              if (iVar6 == 0) {
                dVar14 = lookup_keepaway((char *)0x0);
              }
              else {
                dVar14 = lookup_keepaway(*(char **)(*(int *)(iVar6 + 0xc) + 0xc));
              }
              iVar6 = *(int *)(pGVar7[1].info.name + 4);
            }
            if (iVar6 == 0) {
              dVar15 = lookup_thickness((char *)0x0);
            }
            else {
              dVar15 = lookup_thickness(*(char **)(*(int *)(iVar6 + 0xc) + 0xc));
            }
            return dVar15 * 0.5 + dVar14 + local_24;
          }
        }
        gVar13 = vertex_net_keepaway(ptVar9);
        return gVar13 + local_24;
      }
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      return local_2c;
    }
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xca5,"flow_from_edge_to_edge",&DAT_081601a8);
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr(0,"../../src/toporouter.c",0xc99,"flow_from_edge_to_edge",&DAT_0814f5e2);
}



// WARNING: Unknown calling convention

gdouble edge_flow(toporouter_edge_t *e,toporouter_vertex_t *v1,toporouter_vertex_t *v2,
                 toporouter_vertex_t *dest)

{
  toporouter_vertex_t *v_00;
  bool bVar1;
  GtsObjectClass *pGVar2;
  _toporouter_bbox_t *p_Var3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GList *i;
  toporouter_vertex_t *ptVar5;
  toporouter_vertex_t *pv;
  toporouter_vertex_t *v;
  gdouble v1keepaway;
  gdouble gVar6;
  gdouble gVar7;
  double dVar8;
  gdouble gVar9;
  double dVar10;
  gdouble local_4c;
  gdouble local_44;
  gdouble local_34;
  gdouble local_2c;
  double local_24;
  
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar4 = (e->e).segment.object.klass;
    if (pGVar4 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar2 == pGVar4) {
          i = e->routing;
          goto LAB_080e1bfd;
        }
        pGVar4 = pGVar4->parent_class;
      } while (pGVar4 != (GtsObjectClass *)0x0);
    }
  }
  i = e->routing;
LAB_080e1bfd:
  v_00 = (toporouter_vertex_t *)(e->e).segment.v1;
  if ((v_00 == v2) || (v_00 == v1)) {
    gVar6 = vertex_net_thickness(v_00);
    p_Var3 = (_toporouter_bbox_t *)0x0;
    if (dest != (toporouter_vertex_t *)0x0) {
      p_Var3 = dest->bbox;
    }
    if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
      local_34 = lookup_thickness((char *)0x0);
    }
    else {
      local_34 = lookup_thickness(p_Var3->cluster->netlist->style);
    }
    dVar8 = vertex_net_keepaway(v_00);
    p_Var3 = (_toporouter_bbox_t *)0x0;
    if (dest != (toporouter_vertex_t *)0x0) {
      p_Var3 = dest->bbox;
    }
    if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
      dVar10 = lookup_keepaway((char *)0x0);
    }
    else {
      dVar10 = lookup_keepaway(p_Var3->cluster->netlist->style);
    }
    if (dVar8 <= dVar10) {
      dVar8 = dVar10;
    }
    bVar1 = false;
    local_24 = local_34 * 0.5 + gVar6 * 0.5 + dVar8 + 0.0;
    v_00 = dest;
  }
  else {
    bVar1 = true;
    local_24 = 0.0;
  }
  if (v1 == v2) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xaf6,"edge_flow",&DAT_081516ec);
  }
  for (; i != (GList *)0x0; i = (GList *)(&i->data)[1]) {
    ptVar5 = (toporouter_vertex_t *)i->data;
    if (v_00 == dest) {
      gVar6 = vertex_net_thickness(ptVar5);
      p_Var3 = (_toporouter_bbox_t *)0x0;
      if (v_00 != (toporouter_vertex_t *)0x0) {
        p_Var3 = v_00->bbox;
      }
      if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
        local_4c = lookup_thickness((char *)0x0);
      }
      else {
        local_4c = lookup_thickness(p_Var3->cluster->netlist->style);
      }
      dVar8 = vertex_net_keepaway(ptVar5);
      p_Var3 = (_toporouter_bbox_t *)0x0;
      if (v_00 != (toporouter_vertex_t *)0x0) {
        p_Var3 = dest->bbox;
      }
      if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
        dVar10 = lookup_keepaway((char *)0x0);
      }
      else {
        dVar10 = lookup_keepaway(p_Var3->cluster->netlist->style);
      }
      if (dVar8 <= dVar10) {
        dVar8 = dVar10;
      }
      dVar8 = local_4c * 0.5 + gVar6 * 0.5 + dVar8;
    }
    else {
      gVar6 = vertex_net_thickness(ptVar5);
      gVar7 = vertex_net_thickness(v_00);
      dVar8 = vertex_net_keepaway(ptVar5);
      gVar9 = vertex_net_keepaway(v_00);
      if (dVar8 <= gVar9) {
        dVar8 = gVar9;
      }
      dVar8 = gVar7 * 0.5 + gVar6 * 0.5 + dVar8;
    }
    local_24 = dVar8 + local_24;
    if (((ptVar5 == v2) || (ptVar5 == v1)) && (bVar1)) {
      gVar6 = vertex_net_thickness(ptVar5);
      p_Var3 = (_toporouter_bbox_t *)0x0;
      if (dest != (toporouter_vertex_t *)0x0) {
        p_Var3 = dest->bbox;
      }
      if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
        local_44 = lookup_thickness((char *)0x0);
      }
      else {
        local_44 = lookup_thickness(p_Var3->cluster->netlist->style);
      }
      dVar8 = vertex_net_keepaway(ptVar5);
      p_Var3 = (_toporouter_bbox_t *)0x0;
      if (dest != (toporouter_vertex_t *)0x0) {
        p_Var3 = dest->bbox;
      }
      if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
        dVar10 = lookup_keepaway((char *)0x0);
      }
      else {
        dVar10 = lookup_keepaway(p_Var3->cluster->netlist->style);
      }
      if (dVar8 <= dVar10) {
        dVar8 = dVar10;
      }
      bVar1 = false;
      local_24 = local_44 * 0.5 + gVar6 * 0.5 + dVar8 + local_24;
      ptVar5 = dest;
    }
    v_00 = ptVar5;
  }
  if (v_00 != dest) {
    ptVar5 = (toporouter_vertex_t *)(e->e).segment.v2;
    gVar6 = vertex_net_thickness(ptVar5);
    gVar7 = vertex_net_thickness(v_00);
    dVar8 = vertex_net_keepaway(ptVar5);
    gVar9 = vertex_net_keepaway(v_00);
    if (dVar8 <= gVar9) {
      dVar8 = gVar9;
    }
    return gVar7 * 0.5 + gVar6 * 0.5 + dVar8 + local_24;
  }
  ptVar5 = (toporouter_vertex_t *)(e->e).segment.v2;
  gVar6 = vertex_net_thickness(ptVar5);
  p_Var3 = (_toporouter_bbox_t *)0x0;
  if (v_00 != (toporouter_vertex_t *)0x0) {
    p_Var3 = v_00->bbox;
  }
  if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
    local_2c = lookup_thickness((char *)0x0);
  }
  else {
    local_2c = lookup_thickness(p_Var3->cluster->netlist->style);
  }
  dVar8 = vertex_net_keepaway(ptVar5);
  p_Var3 = (_toporouter_bbox_t *)0x0;
  if (v_00 != (toporouter_vertex_t *)0x0) {
    p_Var3 = dest->bbox;
  }
  if (p_Var3->cluster == (_toporouter_cluster_t *)0x0) {
    dVar10 = lookup_keepaway((char *)0x0);
  }
  else {
    dVar10 = lookup_keepaway(p_Var3->cluster->netlist->style);
  }
  if (dVar8 <= dVar10) {
    dVar8 = dVar10;
  }
  return local_2c * 0.5 + gVar6 * 0.5 + dVar8 + local_24;
}



// WARNING: Unknown calling convention

guint check_arc_for_loops(gpointer t1,toporouter_arc_t *arc,gpointer t2)

{
  GtsObjectClass *pGVar1;
  gint gVar2;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar3;
  gdouble y1;
  gdouble x1;
  gdouble local_2c;
  gdouble local_24;
  
  pGVar1 = (GtsObjectClass *)toporouter_vertex_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (t1 != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar3 = *t1;
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar3) {
          local_2c = *(gdouble *)((int)t1 + 0xc);
          local_24 = *(gdouble *)((int)t1 + 0x14);
          goto LAB_080e2116;
        }
        pGVar3 = pGVar3->parent_class;
      } while (pGVar3 != (GtsObjectClass *)0x0);
    }
  }
  local_2c = *(gdouble *)((int)t1 + 0x1c);
  local_24 = *(gdouble *)((int)t1 + 0x24);
LAB_080e2116:
  pGVar1 = (GtsObjectClass *)toporouter_vertex_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (t2 != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar3 = *t2;
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar3) break;
        pGVar3 = pGVar3->parent_class;
      } while (pGVar3 != (GtsObjectClass *)0x0);
    }
  }
  gVar2 = coord_intersect_prop
                    (local_2c,local_24,arc->x0,arc->y0,arc->x1,arc->y1,*(gdouble *)((int)t2 + 0xc),
                     *(gdouble *)((int)t2 + 0x14));
  return (uint)(gVar2 != 0);
}



// WARNING: Unknown calling convention

GList * edge_routing_last_not_temp(toporouter_edge_t *e)

{
  GList *pGVar1;
  GtsObjectClass *pGVar2;
  GList *pGVar3;
  GList *last;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GList *i;
  
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar4 = (e->e).segment.object.klass;
    if (pGVar4 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar2 == pGVar4) break;
        pGVar4 = pGVar4->parent_class;
      } while (pGVar4 != (GtsObjectClass *)0x0);
    }
  }
  pGVar3 = (GList *)0x0;
  for (pGVar1 = e->routing; pGVar1 != (GList *)0x0; pGVar1 = pGVar1->next) {
    if (-1 < *(char *)((int)pGVar1->data + 0x38)) {
      pGVar3 = pGVar1;
    }
  }
  return pGVar3;
}



// WARNING: Unknown calling convention

gdouble edge_min_spacing(GList *list,toporouter_edge_t *e,toporouter_vertex_t *v)

{
  _toporouter_route_t *p_Var1;
  double dVar2;
  gpointer *ppvVar3;
  GList *i;
  GtsObjectClass *pGVar4;
  GList *pGVar5;
  GtsObjectClass *c;
  GtsObjectClass *pGVar6;
  toporouter_vertex_t *nextv;
  toporouter_vertex_t *ptVar7;
  toporouter_vertex_t *origin;
  toporouter_vertex_t *prevv;
  gdouble cms;
  gdouble ms;
  gdouble v1keepaway;
  gdouble gVar8;
  gdouble gVar9;
  double dVar10;
  gdouble gVar11;
  toporouter_vertex_t *local_60;
  double local_24;
  
  if (list == (GList *)0x0) {
    return INFINITY;
  }
  local_60 = (toporouter_vertex_t *)list->data;
  gVar8 = gts_point_distance2((GtsPoint *)local_60,&((e->e).segment.v1)->p);
  gVar9 = gts_point_distance2((GtsPoint *)v,&((e->e).segment.v1)->p);
  if (gVar9 <= gVar8) {
    local_24 = 0.0;
    do {
      pGVar5 = (GList *)(&list->data)[2];
      if (pGVar5 == (GList *)0x0) {
        ptVar7 = (toporouter_vertex_t *)(e->e).segment.v1;
      }
      else {
        ptVar7 = (toporouter_vertex_t *)pGVar5->data;
      }
      p_Var1 = ptVar7->route;
      if ((((p_Var1 == (_toporouter_route_t *)0x0) || (p_Var1->netlist != local_60->route->netlist))
          || (p_Var1->src->c != local_60->route->src->c)) && (-1 < *(char *)&ptVar7->flags)) {
        gVar8 = vertex_net_thickness(local_60);
        gVar9 = vertex_net_thickness(ptVar7);
        dVar10 = vertex_net_keepaway(local_60);
        gVar11 = vertex_net_keepaway(ptVar7);
        if (dVar10 <= gVar11) {
          dVar10 = gVar11;
        }
        dVar10 = gVar9 * 0.5 + gVar8 * 0.5 + dVar10;
        local_60 = ptVar7;
        if ((ptVar7 != (toporouter_vertex_t *)(e->e).segment.v1) ||
           (gVar8 = pathvertex_arcing_through_constraint((toporouter_vertex_t *)list->data,ptVar7),
           gVar8 <= 9.999999747378752e-05)) {
          local_24 = dVar10 + local_24;
          pGVar5 = (GList *)(&list->data)[2];
        }
        else {
          dVar2 = gVar8 * 0.5;
          pGVar5 = (GList *)(&list->data)[2];
          if (dVar10 <= dVar2 || dVar2 != dVar10) {
            dVar2 = dVar10;
          }
          local_24 = dVar2 + local_24;
        }
      }
      list = pGVar5;
    } while (pGVar5 != (GList *)0x0);
  }
  else {
    local_24 = 0.0;
    do {
      while( true ) {
        pGVar5 = (GList *)(&list->data)[1];
        if (pGVar5 == (GList *)0x0) {
          ptVar7 = (toporouter_vertex_t *)(e->e).segment.v2;
        }
        else {
          ptVar7 = (toporouter_vertex_t *)pGVar5->data;
        }
        p_Var1 = ptVar7->route;
        if ((((p_Var1 == (_toporouter_route_t *)0x0) ||
             (p_Var1->netlist != local_60->route->netlist)) ||
            (p_Var1->src->c != local_60->route->src->c)) && (-1 < *(char *)&ptVar7->flags)) break;
LAB_080e2320:
        list = pGVar5;
        if (pGVar5 == (GList *)0x0) goto LAB_080e23d0;
      }
      gVar8 = vertex_net_thickness(local_60);
      gVar9 = vertex_net_thickness(ptVar7);
      dVar10 = vertex_net_keepaway(local_60);
      gVar11 = vertex_net_keepaway(ptVar7);
      if (dVar10 <= gVar11) {
        dVar10 = gVar11;
      }
      dVar10 = gVar9 * 0.5 + gVar8 * 0.5 + dVar10;
      local_60 = ptVar7;
      if ((ptVar7 == (toporouter_vertex_t *)(e->e).segment.v2) &&
         (gVar8 = pathvertex_arcing_through_constraint((toporouter_vertex_t *)list->data,ptVar7),
         9.999999747378752e-05 < gVar8)) {
        dVar2 = gVar8 * 0.5;
        pGVar5 = (GList *)(&list->data)[1];
        if (dVar10 <= dVar2 || dVar2 != dVar10) {
          dVar2 = dVar10;
        }
        local_24 = dVar2 + local_24;
        goto LAB_080e2320;
      }
      local_24 = dVar10 + local_24;
      ppvVar3 = &list->data;
      list = (GList *)ppvVar3[1];
    } while ((GList *)ppvVar3[1] != (GList *)0x0);
  }
LAB_080e23d0:
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    return local_24;
  }
  pGVar6 = (e->e).segment.object.klass;
  if (pGVar6 != (GtsObjectClass *)0x0) {
    do {
      if (pGVar4 == pGVar6) {
        gVar8 = gts_point_distance(&((e->e).segment.v1)->p,&((e->e).segment.v2)->p);
        if (local_24 <= gVar8 * 0.5) {
          return local_24;
        }
        gVar8 = gts_point_distance(&((e->e).segment.v1)->p,&((e->e).segment.v2)->p);
        return gVar8 * 0.5;
      }
      pGVar6 = pGVar6->parent_class;
    } while (pGVar6 != (GtsObjectClass *)0x0);
    return local_24;
  }
  g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
  return local_24;
}



// WARNING: Unknown calling convention

void print_vertex(toporouter_vertex_t *v)

{
  _toporouter_cluster_t *p_Var1;
  _toporouter_netlist_t *p_Var2;
  toporouter_bbox_t *box;
  GtsObjectClass *pGVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  uint uVar6;
  char *pcVar7;
  toporouter_edge_t *ptVar8;
  GtsObjectClass *c_2;
  GtsObjectClass *c_1;
  GtsObjectClass *c;
  GtsObjectClass *pGVar9;
  guint n;
  ulonglong uVar10;
  
  if (v == (toporouter_vertex_t *)0x0) {
    __printf_chk(1,"[V (null) ");
    pcVar7 = (char *)0x0;
  }
  else {
    __printf_chk(1,"[V %f,%f,%f ",(v->v).p.x,(v->v).p.y,(v->v).p.z);
    if ((v->bbox == (_toporouter_bbox_t *)0x0) ||
       (p_Var1 = v->bbox->cluster, p_Var1 == (_toporouter_cluster_t *)0x0)) {
      pcVar7 = (char *)0x0;
    }
    else {
      pcVar7 = p_Var1->netlist->netlist;
    }
  }
  uVar10 = ZEXT48(pcVar7);
  __printf_chk(1,&DAT_08147f34,pcVar7);
  if ((v->route != (_toporouter_route_t *)0x0) &&
     (p_Var2 = v->route->netlist, p_Var2 != (_toporouter_netlist_t *)0x0)) {
    pcVar7 = p_Var2->netlist;
    uVar10 = ZEXT48(pcVar7);
    __printf_chk(1,&DAT_08147f34,pcVar7);
  }
  if (v->routingedge != (toporouter_edge_t *)0x0) {
    pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar8 = v->routingedge;
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      ptVar8 = v->routingedge;
    }
    else if (ptVar8 != (toporouter_edge_t *)0x0) {
      pGVar9 = (ptVar8->e).segment.object.klass;
      if (pGVar9 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        ptVar8 = v->routingedge;
      }
      else {
        do {
          if (pGVar3 == pGVar9) break;
          pGVar9 = pGVar9->parent_class;
        } while (pGVar9 != (GtsObjectClass *)0x0);
      }
    }
    uVar4 = g_list_length(ptVar8->routing);
    pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar8 = v->routingedge;
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      ptVar8 = v->routingedge;
    }
    else if (ptVar8 != (toporouter_edge_t *)0x0) {
      pGVar9 = (ptVar8->e).segment.object.klass;
      if (pGVar9 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        ptVar8 = v->routingedge;
      }
      else {
        do {
          if (pGVar3 == pGVar9) break;
          pGVar9 = pGVar9->parent_class;
        } while (pGVar9 != (GtsObjectClass *)0x0);
      }
    }
    uVar5 = g_list_index(ptVar8->routing,v);
    pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else if (v->routingedge != (toporouter_edge_t *)0x0) {
      pGVar9 = (v->routingedge->e).segment.object.klass;
      if (pGVar9 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
      else {
        do {
          if (pGVar3 == pGVar9) {
            __printf_chk(1,"[CONST ");
            goto LAB_080e27d6;
          }
          pGVar9 = pGVar9->parent_class;
        } while (pGVar9 != (GtsObjectClass *)0x0);
      }
    }
    __printf_chk(1,"[EDGE ");
LAB_080e27d6:
    uVar10 = CONCAT44(uVar4,uVar5);
    __printf_chk(1,"%d/%d] ",uVar5,uVar4);
  }
  uVar6 = v->flags;
  if ((char)uVar6 < '\0') {
    __printf_chk(1,"TEMP ",uVar10);
    uVar6 = v->flags;
  }
  if ((uVar6 & 0x100) != 0) {
    __printf_chk(1,"ROUTE ",uVar10);
    uVar6 = v->flags;
  }
  if ((uVar6 & 0x800) != 0) {
    __printf_chk(1,"SPECCUT ");
    uVar6 = v->flags;
  }
  if ((uVar6 & 0x400) != 0) {
    __printf_chk(1,"FAKE ");
  }
  __printf_chk(1,"]\n");
  return;
}



// WARNING: Unknown calling convention

void print_oproute(toporouter_oproute_t *oproute)

{
  GList *pGVar1;
  toporouter_arc_t *arc_00;
  GList *i;
  toporouter_arc_t *arc;
  
  __printf_chk(1,"Optimized Route:\n");
  __printf_chk(1,"\tNetlist:\t\t%s\n\tStyle:\t\t%s\n",oproute->netlist,oproute->style);
  __printf_chk(1,&DAT_0814741a);
  print_vertex(oproute->term1);
  __printf_chk(1,"\n");
  for (pGVar1 = oproute->arcs; pGVar1 != (GList *)0x0; pGVar1 = (GList *)(&pGVar1->data)[1]) {
    arc_00 = (toporouter_arc_t *)pGVar1->data;
    __printf_chk(1,&DAT_0814741a);
    print_toporouter_arc(arc_00);
    __printf_chk(1,"\n");
  }
  __printf_chk(1,&DAT_0814741a);
  print_vertex(oproute->term2);
  __printf_chk(1,"\n");
  return;
}



// WARNING: Unknown calling convention

void print_vertices(GList *vertices)

{
  toporouter_vertex_t *v_00;
  toporouter_vertex_t *v;
  
  if (vertices != (GList *)0x0) {
    do {
      while( true ) {
        v_00 = (toporouter_vertex_t *)vertices->data;
        print_vertex(v_00);
        if (v_00 != (toporouter_vertex_t *)0x0) break;
        print_bbox((toporouter_bbox_t *)0x0);
LAB_080e2b2d:
        __printf_chk(1,"no bbox\n");
        vertices = (GList *)(&vertices->data)[1];
        if (vertices == (GList *)0x0) {
          return;
        }
      }
      print_bbox(v_00->bbox);
      if (v_00->bbox == (_toporouter_bbox_t *)0x0) goto LAB_080e2b2d;
      __printf_chk(1,"has bbox\n");
      if (v_00->bbox->cluster == (_toporouter_cluster_t *)0x0) {
        __printf_chk(1,"no cluster\n");
      }
      else {
        __printf_chk(1,"has cluster\n");
      }
      vertices = (GList *)(&vertices->data)[1];
    } while (vertices != (GList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void print_edge(toporouter_edge_t *e)

{
  GList *pGVar1;
  GtsObjectClass *pGVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GList *i;
  
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar3 = (e->e).segment.object.klass;
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar2 == pGVar3) break;
        pGVar3 = pGVar3->parent_class;
      } while (pGVar3 != (GtsObjectClass *)0x0);
    }
  }
  pGVar1 = e->routing;
  __printf_chk(1,"EDGE:\n");
  print_vertex((toporouter_vertex_t *)(e->e).segment.v1);
  for (; pGVar1 != (GList *)0x0; pGVar1 = (GList *)(&pGVar1->data)[1]) {
    print_vertex((toporouter_vertex_t *)pGVar1->data);
  }
  print_vertex((toporouter_vertex_t *)(e->e).segment.v2);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

gint check_speccut(toporouter_oproute_t *oproute,toporouter_vertex_t *v1,toporouter_vertex_t *v2,
                  toporouter_edge_t *e,toporouter_edge_t *e1,toporouter_edge_t *e2)

{
  double dVar1;
  double x3;
  double dVar2;
  double y3;
  double dVar3;
  double dVar4;
  GtsVertex *pGVar5;
  GtsVertex *pGVar6;
  GtsVertex *pGVar7;
  GList *pGVar8;
  GtsObjectClass *pGVar9;
  GtsTriangle *pGVar10;
  GtsTriangle *t;
  toporouter_vertex_t *v_00;
  GtsSegment *object;
  GtsSegment *object_00;
  guint gVar11;
  toporouter_constraint_class_t *ptVar12;
  guint32 gVar13;
  toporouter_edge_t *ptVar14;
  toporouter_edge_t *e1_00;
  gpointer pvVar15;
  GtsEdgeClass *klass;
  GList *i;
  GtsObjectClass *c;
  GtsObjectClass *pGVar16;
  toporouter_vertex_t *v;
  toporouter_edge_t *newe;
  gdouble rval;
  gdouble gVar17;
  gdouble gVar18;
  GtsVertex *local_30;
  gdouble line_int_y;
  gdouble line_int_x;
  
  pGVar9 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar9 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar16 = (e->e).segment.object.klass;
    if (pGVar16 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar9 == pGVar16) {
          return 0;
        }
        pGVar16 = pGVar16->parent_class;
      } while (pGVar16 != (GtsObjectClass *)0x0);
    }
  }
  pGVar10 = gts_triangle_use_edges(&e->e,&e1->e,&e2->e);
  if (pGVar10 == (GtsTriangle *)0x0) {
    __printf_chk(1,"check_speccut: NULL t\n");
  }
  else {
    pGVar10 = opposite_triangle(pGVar10,e);
    if (pGVar10 == (GtsTriangle *)0x0) {
      __printf_chk(1,"check_speccut: NULL opt\n");
    }
    else {
      if ((e2 != (toporouter_edge_t *)0x0) && (e1 != (toporouter_edge_t *)0x0)) {
        pGVar5 = (e1->e).segment.v1;
        pGVar6 = (e2->e).segment.v1;
        local_30 = pGVar5;
        if (((pGVar5 == pGVar6) ||
            (((pGVar7 = (e1->e).segment.v2, local_30 = pGVar6, pGVar6 == pGVar7 ||
              (pGVar6 = (e2->e).segment.v2, local_30 = pGVar5, pGVar5 == pGVar6)) ||
             (local_30 = pGVar7, pGVar7 == pGVar6)))) && (local_30 != (GtsVertex *)0x0)) {
          v_00 = (toporouter_vertex_t *)gts_triangle_vertex_opposite(pGVar10,&e->e);
          if (v_00 == (toporouter_vertex_t *)0x0) {
            __printf_chk(1,"check_speccut: NULL opv2\n");
            return 0;
          }
          object = gts_vertices_are_connected((GtsVertex *)v_00,(e->e).segment.v1);
          object_00 = gts_vertices_are_connected((GtsVertex *)v_00,(e->e).segment.v2);
          pGVar5 = (e->e).segment.v1;
          dVar1 = (pGVar5->p).x;
          x3 = (v_00->v).p.x;
          dVar2 = (pGVar5->p).y;
          y3 = (v_00->v).p.y;
          dVar3 = (local_30->p).x;
          dVar4 = (local_30->p).y;
          dVar1 = (dVar4 - dVar2) * (dVar1 - x3) - (dVar3 - dVar1) * (dVar2 - y3);
          if ((9.999999747378752e-05 < dVar1) || (dVar1 < -9.999999747378752e-05)) {
            pGVar6 = (e->e).segment.v2;
            dVar1 = (pGVar6->p).x;
            dVar2 = (pGVar6->p).y;
            dVar1 = (dVar4 - dVar2) * (dVar1 - x3) - (dVar2 - y3) * (dVar3 - dVar1);
            if (((9.999999747378752e-05 < dVar1) || (dVar1 < -9.999999747378752e-05)) &&
               (gVar11 = vertex_line_normal_intersection
                                   ((pGVar5->p).x,(pGVar5->p).y,(pGVar6->p).x,(pGVar6->p).y,x3,y3,
                                    &line_int_x,&line_int_y), gVar11 != 0)) {
              if ((toporouter_vertex_t *)object->v1 == v_00) {
                ptVar12 = toporouter_constraint_class();
                gts_object_is_from_class(object,ptVar12);
                gVar13 = g_list_append(object[1].object.flags);
                object[1].object.flags = gVar13;
              }
              else {
                ptVar12 = toporouter_constraint_class();
                gts_object_is_from_class(object,ptVar12);
                gVar13 = g_list_prepend(object[1].object.flags);
                object[1].object.flags = gVar13;
              }
              gVar17 = triangle_interior_capacity(pGVar10,v_00);
              ptVar14 = (toporouter_edge_t *)
                        gts_vertices_are_connected((GtsVertex *)v_00,(e->e).segment.v2);
              e1_00 = (toporouter_edge_t *)
                      gts_vertices_are_connected((GtsVertex *)v_00,(e->e).segment.v1);
              gVar18 = flow_from_edge_to_edge(pGVar10,e1_00,ptVar14,v_00,v1);
              ptVar12 = toporouter_constraint_class();
              pvVar15 = gts_object_is_from_class(object,ptVar12);
              if (pvVar15 == (gpointer)0x0) {
                gVar13 = g_list_remove(object[1].object.flags);
                object[1].object.flags = gVar13;
              }
              else {
                gVar13 = g_list_remove(object[1].object.flags);
                object[1].object.flags = gVar13;
              }
              if (gVar17 <= gVar18) {
                klass = (GtsEdgeClass *)toporouter_edge_class();
                ptVar14 = (toporouter_edge_t *)gts_edge_new(klass,local_30,(GtsVertex *)v_00);
                ptVar12 = toporouter_constraint_class();
                gts_object_is_from_class(e1,ptVar12);
                speccut_edge_routing_from_edge(e1->routing,ptVar14);
                ptVar12 = toporouter_constraint_class();
                gts_object_is_from_class(e2,ptVar12);
                speccut_edge_routing_from_edge(e2->routing,ptVar14);
                ptVar12 = toporouter_constraint_class();
                gts_object_is_from_class(object,ptVar12);
                speccut_edge_routing_from_edge((GList *)object[1].object.flags,ptVar14);
                ptVar12 = toporouter_constraint_class();
                gts_object_is_from_class(object_00,ptVar12);
                speccut_edge_routing_from_edge((GList *)object_00[1].object.flags,ptVar14);
                pGVar8 = ptVar14->routing;
                while (pGVar8 != (GList *)0x0) {
                  pvVar15 = pGVar8->data;
                  pGVar8 = pGVar8->next;
                  *(gpointer *)(*(int *)((int)pvVar15 + 0x2c) + 0x30) = pvVar15;
                  *(gpointer *)(*(int *)((int)pvVar15 + 0x30) + 0x2c) = pvVar15;
                }
                __printf_chk(1,"SPECCUT WITH v %f,%f for seg %f,%f %f,%f detected\n",(v_00->v).p.x,
                             (v_00->v).p.y,(v1->v).p.x,(v1->v).p.y,(v2->v).p.x,(v2->v).p.y);
                __printf_chk(1,"\tflow %f cap %f\n",gVar18,gVar17);
                print_edge(ptVar14);
                return (uint)(ptVar14->routing != (GList *)0x0);
              }
            }
          }
          return 0;
        }
      }
      __printf_chk(1,"check_speccut: NULL opv\n");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

gint oproute_path_speccut(toporouter_oproute_t *oproute)

{
  toporouter_vertex_t *v2;
  toporouter_vertex_t *ptVar1;
  toporouter_vertex_t *ptVar2;
  toporouter_vertex_t *ptVar3;
  toporouter_vertex_t *ptVar4;
  toporouter_vertex_t *ptVar5;
  toporouter_edge_t *ptVar6;
  gint gVar7;
  toporouter_edge_t *ptVar8;
  toporouter_edge_t *ptVar9;
  GList *i;
  GList *pGVar10;
  toporouter_vertex_t *v;
  toporouter_vertex_t *v1;
  toporouter_vertex_t *v2_00;
  toporouter_edge_t *local_38;
  toporouter_edge_t *local_34;
  
LAB_080e3139:
  pGVar10 = oproute->path;
  if (pGVar10 != (GList *)0x0) {
    v1 = (toporouter_vertex_t *)pGVar10->data;
    pGVar10 = pGVar10->next;
    if (pGVar10 != (GList *)0x0) {
      do {
        v2 = (toporouter_vertex_t *)pGVar10->data;
        if (((v1 != (toporouter_vertex_t *)0x0) &&
            (((local_34 = v2->routingedge, local_34 != (toporouter_edge_t *)0x0 ||
              (v1->routingedge != (toporouter_edge_t *)0x0)) &&
             ((*(byte *)((int)&v1->flags + 1) & 8) == 0)))) &&
           ((*(byte *)((int)&v2->flags + 1) & 8) == 0)) {
          if (local_34 == (toporouter_edge_t *)0x0) {
            ptVar8 = (toporouter_edge_t *)
                     gts_vertices_are_connected((v1->routingedge->e).segment.v2,(GtsVertex *)v2);
            ptVar6 = v1->routingedge;
            ptVar9 = (toporouter_edge_t *)
                     gts_vertices_are_connected((ptVar6->e).segment.v1,(GtsVertex *)v2);
            gVar7 = check_speccut(oproute,v1,v2,ptVar9,ptVar6,ptVar8);
            if (gVar7 != 0) goto LAB_080e3139;
            local_38 = (toporouter_edge_t *)
                       gts_vertices_are_connected((v1->routingedge->e).segment.v1,(GtsVertex *)v2);
            local_34 = v1->routingedge;
            ptVar6 = (toporouter_edge_t *)
                     gts_vertices_are_connected((local_34->e).segment.v2,(GtsVertex *)v2);
            ptVar5 = v1;
            v1 = v2;
          }
          else {
            local_38 = v1->routingedge;
            if (local_38 == (toporouter_edge_t *)0x0) {
              ptVar8 = (toporouter_edge_t *)
                       gts_vertices_are_connected((local_34->e).segment.v2,&v1->v);
              ptVar6 = v2->routingedge;
              ptVar9 = (toporouter_edge_t *)
                       gts_vertices_are_connected((ptVar6->e).segment.v1,&v1->v);
              gVar7 = check_speccut(oproute,v2,v1,ptVar9,ptVar6,ptVar8);
              if (gVar7 != 0) goto LAB_080e3139;
              local_38 = (toporouter_edge_t *)
                         gts_vertices_are_connected((v2->routingedge->e).segment.v1,&v1->v);
              local_34 = v2->routingedge;
              ptVar5 = (toporouter_vertex_t *)(local_34->e).segment.v2;
              v2_00 = v1;
            }
            else {
              ptVar1 = (toporouter_vertex_t *)(local_34->e).segment.v1;
              ptVar2 = (toporouter_vertex_t *)(local_38->e).segment.v1;
              if (ptVar1 == ptVar2) {
                ptVar5 = (toporouter_vertex_t *)(local_34->e).segment.v2;
                v2_00 = (toporouter_vertex_t *)(local_38->e).segment.v2;
              }
              else {
                ptVar3 = (toporouter_vertex_t *)(local_34->e).segment.v2;
                if (ptVar2 == ptVar3) {
                  ptVar5 = ptVar1;
                  v2_00 = (toporouter_vertex_t *)(local_38->e).segment.v2;
                }
                else {
                  ptVar4 = (toporouter_vertex_t *)(local_38->e).segment.v2;
                  ptVar5 = ptVar3;
                  v2_00 = ptVar2;
                  if (ptVar1 != ptVar4) {
                    ptVar5 = (toporouter_vertex_t *)0x0;
                    if (ptVar3 == ptVar4) {
                      ptVar5 = ptVar1;
                    }
                    v2_00 = (toporouter_vertex_t *)0x0;
                    if (ptVar3 == ptVar4) {
                      v2_00 = ptVar2;
                    }
                  }
                }
              }
            }
            ptVar6 = (toporouter_edge_t *)gts_vertices_are_connected(&ptVar5->v,&v2_00->v);
            ptVar5 = v2;
          }
          gVar7 = check_speccut(oproute,ptVar5,v1,ptVar6,local_34,local_38);
          if (gVar7 != 0) goto LAB_080e3139;
        }
        pGVar10 = (GList *)(&pGVar10->data)[1];
        v1 = v2;
        if (pGVar10 == (GList *)0x0) {
          return 0;
        }
      } while( true );
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void print_path(GList *path)

{
  toporouter_vertex_t *v_00;
  gpointer *ppvVar1;
  int iVar2;
  GList *i;
  GList *pGVar3;
  toporouter_vertex_t *v;
  
  __printf_chk(1,"PATH:\n");
  pGVar3 = path;
  if (path != (GList *)0x0) {
    do {
      v_00 = (toporouter_vertex_t *)pGVar3->data;
      print_vertex(v_00);
      if ((v_00->child != (_toporouter_vertex_t *)0x0) &&
         (iVar2 = g_list_find(path,v_00->child), iVar2 == 0)) {
        __printf_chk(1,"\t CHILD NOT IN LIST\n");
      }
      if ((v_00->parent != (_toporouter_vertex_t *)0x0) &&
         (iVar2 = g_list_find(path,v_00->parent), iVar2 == 0)) {
        __printf_chk(1,"\t parent NOT IN LIST\n");
      }
      ppvVar1 = &pGVar3->data;
      pGVar3 = (GList *)ppvVar1[1];
    } while ((GList *)ppvVar1[1] != (GList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void delaunay_create_from_vertices(GList *vertices,GtsSurface **surface,GtsTriangle **t)

{
  GList **ppGVar1;
  GtsEdge *e3;
  GtsEdge *e2;
  GtsEdge *e1;
  GSList *points;
  GtsTriangleClass *klass;
  GtsTriangle *pGVar2;
  GtsVertexClass *vertex_class;
  GtsEdgeClass *edge_class;
  GtsFaceClass *pGVar3;
  GtsSurfaceClass *klass_00;
  GtsSurface *pGVar4;
  GtsFace *f;
  toporouter_vertex_t *v;
  GSList *vertices_slist;
  GList *pGVar5;
  GList *i;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  points = (GSList *)0x0;
  pGVar5 = vertices;
  if (vertices == (GList *)0x0) {
    points = (GSList *)0x0;
  }
  else {
    do {
      points = (GSList *)g_slist_prepend(points,pGVar5->data);
      ppGVar1 = &pGVar5->next;
      pGVar5 = *ppGVar1;
    } while (*ppGVar1 != (GList *)0x0);
  }
  klass = gts_triangle_class();
  pGVar2 = gts_triangle_enclosing(klass,points,100000.0);
  *t = pGVar2;
  gts_triangle_vertices(pGVar2,local_20,&local_24,&local_28);
  vertex_class = (GtsVertexClass *)toporouter_vertex_class();
  edge_class = (GtsEdgeClass *)toporouter_edge_class();
  pGVar3 = gts_face_class();
  klass_00 = gts_surface_class();
  pGVar4 = gts_surface_new(klass_00,pGVar3,edge_class,vertex_class);
  *surface = pGVar4;
  pGVar2 = *t;
  e3 = pGVar2->e3;
  e2 = pGVar2->e2;
  e1 = pGVar2->e1;
  pGVar3 = gts_face_class();
  f = gts_face_new(pGVar3,e1,e2,e3);
  gts_surface_add_face(*surface,f);
  if (vertices != (GList *)0x0) {
    do {
      v = (toporouter_vertex_t *)
          gts_delaunay_add_vertex(*surface,(GtsVertex *)vertices->data,(GtsFace *)0x0);
      if (v != (toporouter_vertex_t *)0x0) {
        __printf_chk(1,"ERROR: vertex could not be added to CDT ");
        print_vertex(v);
      }
      vertices = (GList *)(&vertices->data)[1];
    } while (vertices != (GList *)0x0);
  }
  gts_allow_floating_vertices = 1;
  gts_object_destroy((GtsObject *)local_20[0]);
  gts_object_destroy((GtsObject *)local_24);
  gts_object_destroy((GtsObject *)local_28);
  gts_allow_floating_vertices = 0;
  g_slist_free(points);
  return;
}



// WARNING: Unknown calling convention

toporouter_bbox_t *
toporouter_bbox_create(int layer,GList *vertices,toporouter_term_t type,gpointer data)

{
  GtsSurface *surface;
  GtsBBoxClass *klass;
  toporouter_bbox_t *ptVar1;
  GtsTriangle *local_14;
  GtsSurface *local_10 [2];
  
  delaunay_create_from_vertices(vertices,local_10,&local_14);
  surface = local_10[0];
  klass = (GtsBBoxClass *)toporouter_bbox_class();
  ptVar1 = (toporouter_bbox_t *)gts_bbox_surface(klass,surface);
  ptVar1->type = type;
  ptVar1->data = data;
  ptVar1->surface = local_10[0];
  ptVar1->enclosing = local_14;
  ptVar1->layer = layer;
  return ptVar1;
}



// WARNING: Unknown calling convention

int read_board_constraints(toporouter_t *r,toporouter_layer_t *l,int layer)

{
  toporouter_bbox_t *box;
  GSList *pGVar1;
  toporouter_bbox_t *bbox;
  GList *local_20 [4];
  
  local_20[0] = (GList *)0x0;
  create_board_edge(0.0,0.0,(double)PCB->MaxWidth,0.0,10000.0,layer,local_20);
  create_board_edge((double)PCB->MaxWidth,0.0,(double)PCB->MaxWidth,(double)PCB->MaxHeight,10000.0,
                    layer,local_20);
  create_board_edge((double)PCB->MaxWidth,(double)PCB->MaxHeight,0.0,(double)PCB->MaxHeight,10000.0,
                    layer,local_20);
  create_board_edge(0.0,(double)PCB->MaxHeight,0.0,0.0,10000.0,layer,local_20);
  box = toporouter_bbox_create(layer,local_20[0],BOARD,(gpointer)0x0);
  pGVar1 = (GSList *)g_slist_prepend(r->bboxes);
  r->bboxes = pGVar1;
  insert_constraints_from_list(r,l,local_20[0],box);
  g_list_free(local_20[0]);
  return 0;
}



// WARNING: Unknown calling convention

int read_points(toporouter_t *r,toporouter_layer_t *l,int layer)

{
  ElementTypePtr paVar1;
  toporouter_layer_t *ptVar2;
  uint uVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  int iVar7;
  Cardinal sn;
  toporouter_bbox_t *ptVar8;
  GSList *pGVar9;
  GtsVertex *pGVar10;
  DataTypePtr paVar11;
  GList *pGVar12;
  GList *vlist;
  PCBTypePtr pPVar13;
  ElementTypePtr element;
  Cardinal sn_1;
  toporouter_bbox_t *bbox;
  gpointer data;
  PinTypePtr via;
  PinTypePtr data_00;
  Cardinal n;
  uint uVar14;
  Cardinal n_1;
  gdouble x;
  gdouble y;
  gdouble t;
  gdouble gVar15;
  gdouble gVar16;
  GList *local_60;
  int local_34;
  int local_30;
  uint local_24;
  
  paVar11 = PCB->Data;
  local_30 = paVar11->ElementN - 1;
  if (local_30 != -1) {
    pPVar13 = PCB;
    iVar7 = paVar11->ElementN * 300;
    do {
      local_34 = iVar7 + -300;
      paVar1 = paVar11->Element;
      local_24 = *(uint *)((int)&paVar1[-1].PinN + iVar7);
      if (local_24 != 0) {
        uVar14 = 0;
        do {
          data = (gpointer)(uVar14 * 0x4c + *(int *)((int)&paVar1[-1].Pin + iVar7));
          dVar4 = (double)*(int *)((int)data + 0x24) * 0.5;
          dVar6 = (double)*(int *)((int)data + 0x34);
          dVar5 = (double)*(int *)((int)data + 0x38);
          if ((*(uint *)((int)data + 0x14) & 0x100) == 0) {
            if ((*(uint *)((int)data + 0x14) & 0x800) == 0) {
              ptVar2 = r->layers;
              gVar15 = lookup_thickness(*(char **)((int)data + 0x3c));
              gVar16 = lookup_keepaway(*(char **)((int)data + 0x3c));
              local_60 = rect_with_attachments
                                   (gVar15 * 0.5 + gVar16,dVar6 - dVar4,dVar5 - dVar4,dVar6 - dVar4,
                                    dVar5 + dVar4,dVar6 + dVar4,dVar5 + dVar4,dVar6 + dVar4,
                                    dVar5 - dVar4,(double)((int)l - (int)ptVar2 >> 4));
              ptVar8 = toporouter_bbox_create((int)l - (int)r->layers >> 4,local_60,PIN,data);
              pGVar9 = (GSList *)g_slist_prepend(r->bboxes);
              r->bboxes = pGVar9;
              goto LAB_080e3970;
            }
            __fprintf_chk(stderr,1,"No support for octagon pins yet\n");
            uVar3 = *(uint *)((int)&paVar1[-1].PinN + iVar7);
            pPVar13 = PCB;
          }
          else {
            ptVar2 = r->layers;
            gVar15 = lookup_thickness(*(char **)((int)data + 0x3c));
            gVar16 = lookup_keepaway(*(char **)((int)data + 0x3c));
            local_60 = rect_with_attachments
                                 (gVar15 * 0.5 + gVar16,dVar6 - dVar4,dVar5 - dVar4,dVar6 - dVar4,
                                  dVar5 + dVar4,dVar6 + dVar4,dVar5 + dVar4,dVar6 + dVar4,
                                  dVar5 - dVar4,(double)((int)l - (int)ptVar2 >> 4));
            ptVar8 = toporouter_bbox_create((int)l - (int)r->layers >> 4,local_60,PIN,data);
            pGVar9 = (GSList *)g_slist_prepend(r->bboxes);
            r->bboxes = pGVar9;
            insert_constraints_from_list(r,l,local_60,ptVar8);
LAB_080e3970:
            g_list_free(local_60);
            pGVar10 = insert_vertex(r,l,dVar6,dVar5,ptVar8);
            ptVar8->point = &pGVar10->p;
            uVar3 = *(uint *)((int)&paVar1[-1].PinN + iVar7);
            pPVar13 = PCB;
          }
          PCB = pPVar13;
        } while ((uVar3 != 0) &&
                (uVar14 = (uVar3 + 1 + uVar14) - local_24, local_24 = uVar3, uVar14 < uVar3));
      }
      local_30 = local_30 + -1;
      if (local_30 == -1) goto LAB_080e3ae5;
      paVar11 = pPVar13->Data;
      iVar7 = local_34;
    } while( true );
  }
LAB_080e3aeb:
  if (paVar11->ViaN != 0) {
    uVar14 = 0;
    local_24 = paVar11->ViaN;
    do {
      data_00 = paVar11->Via + uVar14;
      dVar4 = (double)data_00->Thickness * 0.5;
      uVar3 = (data_00->Flags).f;
      dVar6 = (double)data_00->X;
      dVar5 = (double)data_00->Y;
      if ((uVar3 & 0x100) == 0) {
        if ((uVar3 & 0x800) == 0) {
          ptVar2 = r->layers;
          gVar15 = lookup_thickness(data_00->Name);
          gVar16 = lookup_keepaway(data_00->Name);
          pGVar12 = rect_with_attachments
                              (gVar15 * 0.5 + gVar16,dVar6 - dVar4,dVar5 - dVar4,dVar6 - dVar4,
                               dVar5 + dVar4,dVar6 + dVar4,dVar5 + dVar4,dVar6 + dVar4,dVar5 - dVar4
                               ,(double)((int)l - (int)ptVar2 >> 4));
          ptVar8 = toporouter_bbox_create((int)l - (int)r->layers >> 4,pGVar12,VIA,data_00);
          pGVar9 = (GSList *)g_slist_prepend(r->bboxes);
          r->bboxes = pGVar9;
          g_list_free(pGVar12);
          pGVar10 = insert_vertex(r,l,dVar6,dVar5,ptVar8);
          ptVar8->point = &pGVar10->p;
        }
        else {
          __fprintf_chk(stderr,1,"No support for octagon vias yet\n");
        }
      }
      else {
        ptVar2 = r->layers;
        gVar15 = lookup_thickness(data_00->Name);
        gVar16 = lookup_keepaway(data_00->Name);
        pGVar12 = rect_with_attachments
                            (gVar15 * 0.5 + gVar16,dVar6 - dVar4,dVar5 - dVar4,dVar6 - dVar4,
                             dVar5 + dVar4,dVar6 + dVar4,dVar5 + dVar4,dVar6 + dVar4,dVar5 - dVar4,
                             (double)((int)l - (int)ptVar2 >> 4));
        ptVar8 = toporouter_bbox_create((int)l - (int)r->layers >> 4,pGVar12,VIA,data_00);
        pGVar9 = (GSList *)g_slist_prepend(r->bboxes);
        r->bboxes = pGVar9;
        insert_constraints_from_list(r,l,pGVar12,ptVar8);
        g_list_free(pGVar12);
        pGVar10 = insert_vertex(r,l,dVar6,dVar5,ptVar8);
        ptVar8->point = &pGVar10->p;
      }
      paVar11 = PCB->Data;
      uVar3 = paVar11->ViaN;
    } while ((uVar3 != 0) &&
            (uVar14 = (uVar3 + 1 + uVar14) - local_24, local_24 = uVar3, uVar14 < uVar3));
  }
  return 0;
LAB_080e3ae5:
  paVar11 = pPVar13->Data;
  goto LAB_080e3aeb;
}



// WARNING: Removing unreachable block (ram,0x080e446e)
// WARNING: Removing unreachable block (ram,0x080e4934)
// WARNING: Removing unreachable block (ram,0x080e3f61)
// WARNING: Removing unreachable block (ram,0x080e4974)
// WARNING: Unknown calling convention

int read_pads(toporouter_t *r,toporouter_layer_t *l,guint layer)

{
  int iVar1;
  double dVar2;
  ElementTypePtr paVar3;
  uint uVar4;
  toporouter_layer_t *ptVar5;
  bool bVar6;
  float fVar7;
  double x;
  double dVar8;
  double y;
  double dVar9;
  double dVar10;
  gdouble gVar11;
  gdouble gVar12;
  gdouble gVar13;
  gdouble gVar14;
  gdouble gVar15;
  gdouble gVar16;
  int iVar17;
  int iVar18;
  int iVar19;
  DataTypePtr paVar20;
  int iVar21;
  int iVar22;
  GList *pGVar23;
  toporouter_bbox_t *ptVar24;
  GSList *pGVar25;
  GtsVertex *pGVar26;
  toporouter_bbox_t *ptVar27;
  uint uVar28;
  Cardinal sn;
  uint uVar29;
  GList *vlist;
  toporouter_bbox_t *bbox;
  gpointer data;
  gdouble t;
  double rval_1;
  double rval;
  double dx2;
  double dy2;
  gdouble gVar30;
  gdouble gVar31;
  gdouble gVar32;
  gdouble gVar33;
  int local_134;
  int local_130;
  uint local_c0;
  double local_bc;
  toporouter_spoint_t rv [5];
  toporouter_spoint_t temp [2];
  toporouter_spoint_t p [2];
  
  iVar17 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  iVar18 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar19 = (int)l - (int)r->layers >> 4;
  if ((iVar19 == iVar17) || (iVar18 == iVar19)) {
    paVar20 = PCB->Data;
    local_130 = paVar20->ElementN - 1;
    if (local_130 != -1) {
      iVar19 = paVar20->ElementN * 300;
LAB_080e3e80:
      local_134 = iVar19 + -300;
      paVar3 = paVar20->Element;
      local_c0 = 0;
      uVar4 = *(uint *)((int)&paVar3[-1].PadN + iVar19);
      do {
        uVar29 = uVar4;
        do {
          if ((uVar29 == 0) || (uVar29 <= local_c0)) {
            local_130 = local_130 + -1;
            if (local_130 == -1) {
              return 0;
            }
            paVar20 = PCB->Data;
            iVar19 = local_134;
            goto LAB_080e3e80;
          }
          data = (gpointer)(local_c0 * 0x68 + *(int *)((int)&paVar3[-1].Pad + iVar19));
          iVar21 = (int)l - (int)r->layers >> 4;
          if (((iVar21 == iVar18) && (uVar28 = *(uint *)((int)data + 0x14), (char)uVar28 < '\0')) ||
             ((iVar17 == iVar21 && (uVar28 = *(uint *)((int)data + 0x14), -1 < (char)uVar28)))) {
            fVar7 = (float)*(int *)((int)data + 0x24) * 0.5;
            iVar22 = *(int *)((int)data + 0x2c);
            x = (double)iVar22;
            dVar8 = (double)*(int *)((int)data + 0x40);
            iVar1 = *(int *)((int)data + 0x30);
            y = (double)iVar1;
            dVar9 = (double)*(int *)((int)data + 0x44);
            if ((uVar28 & 0x100) == 0) {
              if (x == dVar8) {
                if (y == dVar9) {
                  gVar30 = lookup_thickness(*(char **)((int)data + 0x58));
                  gVar31 = lookup_keepaway(*(char **)((int)data + 0x58));
                  pGVar23 = rect_with_attachments
                                      (gVar30 * 0.5 + gVar31,(double)((float)iVar22 - fVar7),
                                       (double)((float)iVar1 - fVar7),
                                       (double)((float)iVar22 - fVar7),
                                       (double)((float)iVar1 + fVar7),
                                       (double)((float)iVar22 + fVar7),
                                       (double)((float)iVar1 + fVar7),
                                       (double)((float)iVar22 + fVar7),
                                       (double)((float)iVar1 - fVar7),(double)iVar21);
                  ptVar27 = toporouter_bbox_create((int)l - (int)r->layers >> 4,pGVar23,PAD,data);
                  pGVar25 = (GSList *)g_slist_prepend(r->bboxes,ptVar27);
                  r->bboxes = pGVar25;
                  g_list_free(pGVar23);
                  pGVar26 = insert_vertex(r,l,x,y,ptVar27);
                  ptVar27->point = &pGVar26->p;
                  uVar29 = *(uint *)((int)&paVar3[-1].PadN + iVar19);
                  goto LAB_080e3ecc;
                }
                local_bc = INFINITY;
                bVar6 = true;
                gVar30 = INFINITY;
              }
              else {
                local_bc = (dVar9 - y) / (dVar8 - x);
                bVar6 = 1.797693134862316e+308 < local_bc;
                gVar30 = local_bc;
                if (x == dVar8) {
                  gVar30 = INFINITY;
                }
              }
              dVar2 = (double)fVar7;
              p[0].x = x;
              p[0].y = y;
              p[1].x = dVar8;
              p[1].y = dVar9;
              vertices_on_line(p,gVar30,(double)fVar7,temp,temp + 1);
              gVar30 = vertices_plane_distance(temp,p + 1);
              gVar31 = vertices_plane_distance(temp + 1,p + 1);
              if (gVar30 <= gVar31) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
              }
              if (bVar6) {
                gVar30 = 0.0;
              }
              else {
                gVar30 = -1.0 / local_bc;
              }
              vertices_on_line(rv,gVar30,dVar2,rv + 1,rv + 2);
              if (p[1].x == p[0].x) {
                dVar10 = INFINITY;
              }
              else {
                dVar10 = (p[0].y - p[1].y) / (p[0].x - p[1].x);
              }
              vertices_on_line(p + 1,dVar10,dVar2,temp,temp + 1);
              gVar30 = vertices_plane_distance(temp,p);
              gVar31 = vertices_plane_distance(temp + 1,p);
              if (gVar30 <= gVar31) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
                if (!bVar6) goto LAB_080e49af;
LAB_080e465f:
                gVar30 = 0.0;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
                if (bVar6) goto LAB_080e465f;
LAB_080e49af:
                gVar30 = -1.0 / local_bc;
              }
              vertices_on_line(rv,gVar30,dVar2,rv + 3,rv + 4);
              gVar14 = rv[3].y;
              gVar13 = rv[3].x;
              gVar12 = rv[2].y;
              gVar11 = rv[2].x;
              gVar31 = rv[1].y;
              gVar30 = rv[1].x;
              iVar21 = 1;
              dVar2 = (rv[2].x - rv[1].x) * (rv[3].y - rv[2].y) -
                      (rv[2].y - rv[1].y) * (rv[3].x - rv[2].x);
              if (dVar2 <= 0.0001) {
                iVar21 = (-0.0001 <= dVar2) - 1;
              }
              iVar22 = 1;
              dVar2 = (rv[4].y - rv[3].y) * (rv[3].x - rv[2].x) -
                      (rv[4].x - rv[3].x) * (rv[3].y - rv[2].y);
              if (dVar2 <= 0.0001) {
                iVar22 = (-0.0001 <= dVar2) - 1;
              }
              if (iVar21 != iVar22) {
                rv[0].x = rv[3].x;
                rv[0].y = rv[3].y;
                rv[3].x = rv[4].x;
                rv[3].y = rv[4].y;
                rv[4].x = gVar13;
                rv[4].y = gVar14;
              }
              gVar16 = rv[4].y;
              gVar15 = rv[4].x;
              gVar14 = rv[3].y;
              gVar13 = rv[3].x;
              ptVar5 = r->layers;
              gVar32 = lookup_thickness(*(char **)((int)data + 0x58));
              gVar33 = lookup_keepaway(*(char **)((int)data + 0x58));
              pGVar23 = rect_with_attachments
                                  (gVar32 * 0.5 + gVar33,gVar30,gVar31,gVar11,gVar12,gVar13,gVar14,
                                   gVar15,gVar16,(double)((int)l - (int)ptVar5 >> 4));
              ptVar27 = toporouter_bbox_create((int)l - (int)r->layers >> 4,pGVar23,PAD,data);
              pGVar25 = (GSList *)g_slist_prepend(r->bboxes,ptVar27);
              r->bboxes = pGVar25;
              insert_constraints_from_list(r,l,pGVar23,ptVar27);
              g_list_free(pGVar23);
              pGVar26 = insert_vertex(r,l,(x + dVar8) * 0.5,(y + dVar9) * 0.5,ptVar27);
              ptVar27->point = &pGVar26->p;
            }
            else {
              if (x == dVar8) {
                if (y == dVar9) {
                  gVar30 = lookup_thickness(*(char **)((int)data + 0x58));
                  gVar31 = lookup_keepaway(*(char **)((int)data + 0x58));
                  pGVar23 = rect_with_attachments
                                      (gVar30 * 0.5 + gVar31,(double)((float)iVar22 - fVar7),
                                       (double)((float)iVar1 - fVar7),
                                       (double)((float)iVar22 - fVar7),
                                       (double)((float)iVar1 + fVar7),
                                       (double)((float)iVar22 + fVar7),
                                       (double)((float)iVar1 + fVar7),
                                       (double)((float)iVar22 + fVar7),
                                       (double)((float)iVar1 - fVar7),(double)iVar21);
                  ptVar24 = toporouter_bbox_create((int)l - (int)r->layers >> 4,pGVar23,PAD,data);
                  pGVar25 = (GSList *)g_slist_prepend(r->bboxes,ptVar24);
                  r->bboxes = pGVar25;
                  insert_constraints_from_list(r,l,pGVar23,ptVar24);
                  g_list_free(pGVar23);
                  pGVar26 = insert_vertex(r,l,x,y,ptVar24);
                  ptVar27 = (toporouter_bbox_t *)pGVar26[1].p.object.klass;
                  ptVar24->point = &pGVar26->p;
                  if (ptVar24 != ptVar27) {
                    // WARNING: Subroutine does not return
                    g_assertion_message_expr
                              (0,"../../src/toporouter.c",0x782,"read_pads",
                               "TOPOROUTER_VERTEX(bbox->point)->bbox == bbox");
                  }
                  goto LAB_080e48ff;
                }
                local_bc = INFINITY;
                bVar6 = true;
                gVar30 = INFINITY;
              }
              else {
                local_bc = (dVar9 - y) / (dVar8 - x);
                bVar6 = 1.797693134862316e+308 < local_bc;
                gVar30 = local_bc;
                if (x == dVar8) {
                  gVar30 = INFINITY;
                }
              }
              dVar2 = (double)fVar7;
              p[0].x = x;
              p[0].y = y;
              p[1].x = dVar8;
              p[1].y = dVar9;
              vertices_on_line(p,gVar30,(double)fVar7,temp,temp + 1);
              gVar30 = vertices_plane_distance(temp,p + 1);
              gVar31 = vertices_plane_distance(temp + 1,p + 1);
              if (gVar30 <= gVar31) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
                if (!bVar6) goto LAB_080e4a17;
LAB_080e4075:
                gVar30 = 0.0;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
                if (bVar6) goto LAB_080e4075;
LAB_080e4a17:
                gVar30 = -1.0 / local_bc;
              }
              vertices_on_line(rv,gVar30,dVar2,rv + 1,rv + 2);
              if (p[1].x == p[0].x) {
                dVar10 = INFINITY;
              }
              else {
                dVar10 = (p[0].y - p[1].y) / (p[0].x - p[1].x);
              }
              vertices_on_line(p + 1,dVar10,dVar2,temp,temp + 1);
              gVar30 = vertices_plane_distance(temp,p);
              gVar31 = vertices_plane_distance(temp + 1,p);
              if (gVar30 <= gVar31) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
              }
              if (bVar6) {
                gVar30 = 0.0;
              }
              else {
                gVar30 = -1.0 / local_bc;
              }
              vertices_on_line(rv,gVar30,dVar2,rv + 3,rv + 4);
              gVar14 = rv[3].y;
              gVar13 = rv[3].x;
              gVar12 = rv[2].y;
              gVar11 = rv[2].x;
              gVar31 = rv[1].y;
              gVar30 = rv[1].x;
              iVar21 = 1;
              dVar2 = (rv[2].x - rv[1].x) * (rv[3].y - rv[2].y) -
                      (rv[2].y - rv[1].y) * (rv[3].x - rv[2].x);
              if (dVar2 <= 0.0001) {
                iVar21 = (-0.0001 <= dVar2) - 1;
              }
              iVar22 = 1;
              dVar2 = (rv[4].y - rv[3].y) * (rv[3].x - rv[2].x) -
                      (rv[4].x - rv[3].x) * (rv[3].y - rv[2].y);
              if (dVar2 <= 0.0001) {
                iVar22 = (-0.0001 <= dVar2) - 1;
              }
              if (iVar21 != iVar22) {
                rv[0].x = rv[3].x;
                rv[0].y = rv[3].y;
                rv[3].x = rv[4].x;
                rv[3].y = rv[4].y;
                rv[4].x = gVar13;
                rv[4].y = gVar14;
              }
              gVar16 = rv[4].y;
              gVar15 = rv[4].x;
              gVar14 = rv[3].y;
              gVar13 = rv[3].x;
              ptVar5 = r->layers;
              gVar32 = lookup_thickness(*(char **)((int)data + 0x58));
              gVar33 = lookup_keepaway(*(char **)((int)data + 0x58));
              pGVar23 = rect_with_attachments
                                  (gVar32 * 0.5 + gVar33,gVar30,gVar31,gVar11,gVar12,gVar13,gVar14,
                                   gVar15,gVar16,(double)((int)l - (int)ptVar5 >> 4));
              ptVar24 = toporouter_bbox_create((int)l - (int)r->layers >> 4,pGVar23,PAD,data);
              pGVar25 = (GSList *)g_slist_prepend(r->bboxes,ptVar24);
              r->bboxes = pGVar25;
              insert_constraints_from_list(r,l,pGVar23,ptVar24);
              g_list_free(pGVar23);
              pGVar26 = insert_vertex(r,l,(x + dVar8) * 0.5,(y + dVar9) * 0.5,ptVar24);
              ptVar27 = (toporouter_bbox_t *)pGVar26[1].p.object.klass;
              ptVar24->point = &pGVar26->p;
              if (ptVar24 != ptVar27) {
                    // WARNING: Subroutine does not return
                g_assertion_message_expr
                          (0,"../../src/toporouter.c",0x7a8,"read_pads",
                           "TOPOROUTER_VERTEX(bbox->point)->bbox == bbox");
              }
            }
LAB_080e48ff:
            uVar29 = *(uint *)((int)&paVar3[-1].PadN + iVar19);
          }
LAB_080e3ecc:
        } while (uVar29 != uVar4);
        local_c0 = local_c0 + 1;
      } while( true );
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void import_geometry(toporouter_t *r)

{
  int *piVar1;
  Cardinal *pCVar2;
  int iVar3;
  uint ln;
  int iVar4;
  int group;
  DataTypePtr paVar5;
  GNode *pGVar6;
  int iVar7;
  guint count;
  Cardinal number;
  PCBType *pPVar8;
  Cardinal entry;
  uint uVar9;
  size_t __size;
  PCBTypePtr pPVar10;
  toporouter_layer_t *local_28;
  guint local_24;
  
  iVar7 = 0;
  __size = 0;
  iVar3 = PCB->Data->LayerN;
  iVar4 = 0;
  if (0 < iVar3) {
    do {
      iVar7 = (iVar7 + 1) - (uint)((PCB->LayerGroups).Number[iVar4] == 0);
      iVar4 = iVar4 + 1;
    } while (iVar4 != iVar3);
    __size = iVar7 * 0x10;
  }
  local_28 = (toporouter_layer_t *)calloc(1,__size);
  pPVar10 = PCB;
  r->layers = local_28;
  if (0 < pPVar10->Data->LayerN) {
    local_24 = 0;
    do {
      if ((pPVar10->LayerGroups).Number[local_24] != 0) {
        local_28->vertices = (GList *)0x0;
        local_28->constraints = (GList *)0x0;
        read_board_constraints(r,local_28,(pPVar10->LayerGroups).Entries[local_24][0]);
        read_points(r,local_28,(PCB->LayerGroups).Entries[local_24][0]);
        read_pads(r,local_28,local_24);
        paVar5 = PCB->Data;
        pPVar8 = paVar5->pcb;
        if ((pPVar8->LayerGroups).Number[local_24] != 0) {
          uVar9 = 0;
          pPVar10 = PCB;
          do {
            ln = (pPVar8->LayerGroups).Entries[local_24][uVar9];
            if (ln < (uint)paVar5->LayerN) {
              read_lines(r,local_28,paVar5->Layer + ln,ln);
              pPVar10 = PCB;
            }
            paVar5 = pPVar10->Data;
            uVar9 = uVar9 + 1;
            pPVar8 = paVar5->pcb;
            pCVar2 = (pPVar8->LayerGroups).Number + local_24;
          } while (uVar9 <= *pCVar2 && *pCVar2 != uVar9);
        }
        build_cdt(r,local_28);
        pPVar10 = PCB;
        local_28 = local_28 + 1;
      }
      local_24 = local_24 + 1;
      piVar1 = &pPVar10->Data->LayerN;
    } while (*piVar1 != local_24 && (int)local_24 <= *piVar1);
  }
  pGVar6 = gts_bb_tree_new(r->bboxes);
  r->bboxtree = pGVar6;
  import_clusters(r);
  return;
}



// WARNING: Unknown calling convention

toporouter_vertex_t * edge_closest_vertex(toporouter_edge_t *e,toporouter_vertex_t *v)

{
  toporouter_vertex_t *p1;
  GtsObjectClass *pGVar1;
  toporouter_edge_t *ptVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GList *i;
  GList *pGVar4;
  toporouter_vertex_t *ev;
  gdouble tempd;
  gdouble gVar5;
  gdouble local_2c;
  toporouter_vertex_t *local_20;
  
  if (v->routingedge != (toporouter_edge_t *)0x0) {
    pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar2 = v->routingedge;
    if (pGVar1 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      ptVar2 = v->routingedge;
    }
    else if (ptVar2 != (toporouter_edge_t *)0x0) {
      pGVar3 = (ptVar2->e).segment.object.klass;
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        ptVar2 = v->routingedge;
      }
      else {
        do {
          if (pGVar1 == pGVar3) break;
          pGVar3 = pGVar3->parent_class;
        } while (pGVar3 != (GtsObjectClass *)0x0);
      }
    }
    pGVar4 = ptVar2->routing;
    if (pGVar4 != (GList *)0x0) {
      local_20 = (toporouter_vertex_t *)0x0;
      local_2c = 0.0;
      do {
        p1 = (toporouter_vertex_t *)pGVar4->data;
        gVar5 = gts_point_distance2((GtsPoint *)p1,(GtsPoint *)v);
        if ((local_20 == (toporouter_vertex_t *)0x0) || (gVar5 < local_2c)) {
          local_2c = gVar5;
          local_20 = p1;
        }
        pGVar4 = (GList *)(&pGVar4->data)[1];
      } while (pGVar4 != (GList *)0x0);
      return local_20;
    }
  }
  return (toporouter_vertex_t *)0x0;
}



// WARNING: Unknown calling convention

void delete_vertex(toporouter_vertex_t *v)

{
  GtsObjectClass *pGVar1;
  GList *pGVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  toporouter_edge_t *ptVar4;
  
  if (-1 < *(char *)&v->flags) {
    return;
  }
  if (v->routingedge != (toporouter_edge_t *)0x0) {
    pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar4 = v->routingedge;
    if (pGVar1 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      ptVar4 = v->routingedge;
    }
    else if (ptVar4 != (toporouter_edge_t *)0x0) {
      pGVar3 = (ptVar4->e).segment.object.klass;
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        ptVar4 = v->routingedge;
      }
      else {
        do {
          if (pGVar1 == pGVar3) break;
          pGVar3 = pGVar3->parent_class;
        } while (pGVar3 != (GtsObjectClass *)0x0);
      }
    }
    pGVar2 = (GList *)g_list_remove(ptVar4->routing,v);
    ptVar4->routing = pGVar2;
  }
  gts_object_destroy((GtsObject *)v);
  return;
}



// WARNING: Unknown calling convention

void oproute_check_all_loops(toporouter_t *r,toporouter_oproute_t *oproute)

{
  toporouter_vertex_t *arc_00;
  toporouter_vertex_t *v;
  guint gVar1;
  toporouter_arc_class_t *ptVar2;
  gpointer pvVar3;
  GList *i;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  toporouter_arc_class_t *ptVar4;
  GtsObjectClass *c_2;
  toporouter_arc_t *arc;
  gpointer t1;
  toporouter_vertex_t *v_00;
  gpointer t2;
  
  i = oproute->arcs;
LAB_080e518e:
  v = oproute->term1;
  while( true ) {
    if (i == (GList *)0x0) {
      return;
    }
    arc_00 = (toporouter_vertex_t *)i->data;
    if ((GList *)(&i->data)[1] == (GList *)0x0) {
      v_00 = oproute->term2;
    }
    else {
      v_00 = (toporouter_vertex_t *)((GList *)(&i->data)[1])->data;
    }
    gVar1 = check_arc_for_loops(v,(toporouter_arc_t *)arc_00,v_00);
    if (gVar1 != 0) break;
    i = (GList *)(&i->data)[1];
    v = arc_00;
  }
  ptVar2 = toporouter_arc_class();
  if (ptVar2 == (toporouter_arc_class_t *)0x0) {
LAB_080e5290:
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (v != (toporouter_vertex_t *)0x0) {
    ptVar4 = (toporouter_arc_class_t *)(v->v).p.object.klass;
    if (ptVar4 == (toporouter_arc_class_t *)0x0) {
LAB_080e52f8:
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (ptVar2 == ptVar4) {
          if (v != (toporouter_vertex_t *)0x0) {
            ptVar2 = toporouter_arc_class();
            if (ptVar2 == (toporouter_arc_class_t *)0x0) goto LAB_080e5290;
            if (v_00 != (toporouter_vertex_t *)0x0) {
              ptVar4 = (toporouter_arc_class_t *)(v_00->v).p.object.klass;
              if (ptVar4 != (toporouter_arc_class_t *)0x0) goto LAB_080e5252;
              goto LAB_080e52f8;
            }
          }
          break;
        }
        ptVar4 = (toporouter_arc_class_t *)(ptVar4->parent_class).parent_class;
      } while (ptVar4 != (toporouter_arc_class_t *)0x0);
    }
  }
  goto LAB_080e52b0;
  while (ptVar4 = (toporouter_arc_class_t *)(ptVar4->parent_class).parent_class,
        ptVar4 != (toporouter_arc_class_t *)0x0) {
LAB_080e5252:
    if (ptVar2 == ptVar4) {
      if (v_00 != (toporouter_vertex_t *)0x0) {
        calculate_arc_to_arc(r,(toporouter_arc_t *)v,(toporouter_arc_t *)v_00);
        goto LAB_080e526d;
      }
      break;
    }
  }
LAB_080e52b0:
  ptVar2 = toporouter_arc_class();
  if (ptVar2 == (toporouter_arc_class_t *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (v != (toporouter_vertex_t *)0x0) {
    ptVar4 = (toporouter_arc_class_t *)(v->v).p.object.klass;
    if (ptVar4 == (toporouter_arc_class_t *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (ptVar2 == ptVar4) {
          if (v != (toporouter_vertex_t *)0x0) {
            calculate_term_to_arc(v_00,(toporouter_arc_t *)v,1);
            goto LAB_080e526d;
          }
          break;
        }
        ptVar4 = (toporouter_arc_class_t *)(ptVar4->parent_class).parent_class;
      } while (ptVar4 != (toporouter_arc_class_t *)0x0);
    }
  }
  ptVar2 = toporouter_arc_class();
  pvVar3 = gts_object_is_from_class(v_00,ptVar2);
  if (pvVar3 != (gpointer)0x0) {
    calculate_term_to_arc(v,(toporouter_arc_t *)v_00,0);
  }
LAB_080e526d:
  i = (GList *)g_list_remove(oproute->arcs,arc_00);
  oproute->arcs = i;
  goto LAB_080e518e;
}



// WARNING: Unknown calling convention

gboolean temp_point_clean(gpointer key,gpointer value,gpointer user_data)

{
  GtsObjectClass *pGVar1;
  GtsObjectClass *c;
  GtsObjectClass *pGVar2;
  GtsObjectClass **ppGVar3;
  
  if (-1 < *(char *)((int)value + 0x38)) {
    return 1;
  }
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  ppGVar3 = *(GtsObjectClass ***)((int)value + 0x34);
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    ppGVar3 = *(GtsObjectClass ***)((int)value + 0x34);
  }
  else if (ppGVar3 != (GtsObjectClass **)0x0) {
    pGVar2 = *ppGVar3;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      ppGVar3 = *(GtsObjectClass ***)((int)value + 0x34);
    }
    else {
      do {
        if (pGVar1 == pGVar2) break;
        pGVar2 = pGVar2->parent_class;
      } while (pGVar2 != (GtsObjectClass *)0x0);
    }
  }
  pGVar1 = (GtsObjectClass *)g_list_remove(ppGVar3[7],value);
  ppGVar3[7] = pGVar1;
  gts_object_destroy((GtsObject *)value);
  return 1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

GList * vertices_routing_conflicts(toporouter_vertex_t *v,toporouter_vertex_t *pv)

{
  toporouter_edge_t *ptVar1;
  toporouter_edge_t *ptVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  gpointer pvVar5;
  GList *pGVar6;
  GList *pGVar7;
  GtsObjectClass *pGVar8;
  GtsSegment *pGVar9;
  toporouter_edge_t *ope;
  undefined4 uVar10;
  int iVar11;
  GtsVertex *pGVar12;
  toporouter_edge_t *ope_1;
  toporouter_constraint_class_t *ptVar13;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  GtsObjectClass *c_3;
  GtsObjectClass *pGVar14;
  toporouter_vertex_t *v_00;
  GList *i;
  int *piVar15;
  toporouter_vertex_t *curv;
  toporouter_edge_t *e2;
  toporouter_edge_t *ptVar16;
  toporouter_vertex_t *curv_1;
  toporouter_vertex_t *v_01;
  toporouter_vertex_t *commonv;
  GList *rval;
  GList *pGVar17;
  GtsVertex *pGVar18;
  GList *pGVar19;
  GList *local_2c;
  GList *local_28;
  GList *local_24;
  GList *local_20 [4];
  
  if ((v->v).p.z != (pv->v).p.z) {
    return (GList *)0x0;
  }
  local_20[0] = (GList *)0x0;
  local_24 = (GList *)0x0;
  if (v == pv) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x1103,"vertices_routing_conflicts","v != pv");
  }
  if ((v->routingedge == (toporouter_edge_t *)0x0) && (pv->routingedge == (toporouter_edge_t *)0x0))
  {
    pGVar9 = gts_vertices_are_connected(&v->v,&pv->v);
    if (pGVar9 == (GtsSegment *)0x0) {
      return (GList *)0x0;
    }
    ptVar13 = toporouter_constraint_class();
    pGVar17 = (GList *)0x0;
    gts_object_is_from_class(pGVar9,ptVar13);
    piVar15 = (int *)pGVar9[1].object.flags;
    if (piVar15 == (int *)0x0) {
      return (GList *)0x0;
    }
    do {
      pGVar17 = (GList *)g_list_prepend(pGVar17,*(undefined4 *)(*piVar15 + 0x58));
      piVar15 = (int *)piVar15[1];
    } while (piVar15 != (int *)0x0);
    return pGVar17;
  }
  pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar8 == (GtsObjectClass *)0x0) {
LAB_080e57a0:
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (v->routingedge != (toporouter_edge_t *)0x0) {
    pGVar14 = (v->routingedge->e).segment.object.klass;
    if (pGVar14 == (GtsObjectClass *)0x0) {
LAB_080e54b6:
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar8 == pGVar14) {
          ptVar13 = toporouter_constraint_class();
          if (ptVar13 == (toporouter_constraint_class_t *)0x0) goto LAB_080e57a0;
          if (pv->routingedge != (toporouter_edge_t *)0x0) {
            pGVar8 = (pv->routingedge->e).segment.object.klass;
            if (pGVar8 != (GtsObjectClass *)0x0) goto joined_r0x080e55d4;
            goto LAB_080e54b6;
          }
          break;
        }
        pGVar14 = pGVar14->parent_class;
      } while (pGVar14 != (GtsObjectClass *)0x0);
    }
  }
LAB_080e54d8:
  pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar16 = pv->routingedge;
  if (pGVar8 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (ptVar16 != (toporouter_edge_t *)0x0) {
    pGVar14 = (ptVar16->e).segment.object.klass;
    if (pGVar14 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        v_00 = v;
        v_01 = pv;
        if (pGVar8 == pGVar14) goto LAB_080e5518;
        pGVar14 = pGVar14->parent_class;
      } while (pGVar14 != (GtsObjectClass *)0x0);
    }
  }
  ptVar16 = v->routingedge;
  v_00 = pv;
  v_01 = v;
  if (ptVar16 == (toporouter_edge_t *)0x0) {
    ptVar16 = pv->routingedge;
    v_00 = v;
    v_01 = pv;
  }
LAB_080e5518:
  split_edge_routing(v_01,local_20,&local_24);
  if (local_24 == (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x111a,"vertices_routing_conflicts","l2");
  }
  if (local_20[0] == (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x111b,"vertices_routing_conflicts","l1");
  }
  if (v_00->routingedge == (toporouter_edge_t *)0x0) {
    pGVar9 = gts_vertices_are_connected(&v_00->v,(ptVar16->e).segment.v1);
    e2 = (toporouter_edge_t *)gts_vertices_are_connected(&v_00->v,(ptVar16->e).segment.v2);
    ptVar13 = toporouter_constraint_class();
    gts_object_is_from_class(pGVar9,ptVar13);
    uVar10 = g_list_copy(pGVar9[1].object.flags);
    local_20[0] = (GList *)g_list_concat(local_20[0],uVar10);
  }
  else {
    ptVar1 = v_00->routingedge;
    local_28 = (GList *)0x0;
    ptVar2 = v_01->routingedge;
    local_2c = (GList *)0x0;
    if ((ptVar1 == (toporouter_edge_t *)0x0) || (ptVar2 == (toporouter_edge_t *)0x0)) {
LAB_080e556f:
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x1129,"vertices_routing_conflicts","commonv");
    }
    pGVar12 = (ptVar1->e).segment.v1;
    pGVar3 = (ptVar2->e).segment.v1;
    pGVar18 = pGVar3;
    if (((pGVar3 != pGVar12) &&
        (((pGVar4 = (ptVar2->e).segment.v2, pGVar18 = pGVar12, pGVar12 != pGVar4 &&
          (pGVar12 = (ptVar1->e).segment.v2, pGVar18 = pGVar3, pGVar3 != pGVar12)) &&
         (pGVar18 = pGVar4, pGVar4 != pGVar12)))) || (pGVar18 == (GtsVertex *)0x0))
    goto LAB_080e556f;
    split_edge_routing(v_00,&local_28,&local_2c);
    if ((ptVar16->e).segment.v1 != pGVar18) {
      if ((v_00->routingedge->e).segment.v1 == pGVar18) {
        local_20[0] = (GList *)g_list_concat(local_20[0],local_2c);
        local_24 = (GList *)g_list_concat(local_24,local_28);
        pGVar12 = (v_00->routingedge->e).segment.v2;
      }
      else {
        local_20[0] = (GList *)g_list_concat(local_20[0],local_28);
        local_24 = (GList *)g_list_concat(local_24,local_2c);
        pGVar12 = (v_00->routingedge->e).segment.v1;
      }
      pGVar9 = gts_vertices_are_connected((ptVar16->e).segment.v1,pGVar12);
      if (pGVar9 == (GtsSegment *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/toporouter.c",0x1147,"vertices_routing_conflicts",&DAT_08151856);
      }
      pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar8 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        pGVar14 = (pGVar9->object).klass;
        if (pGVar14 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar8 == pGVar14) break;
            pGVar14 = pGVar14->parent_class;
          } while (pGVar14 != (GtsObjectClass *)0x0);
        }
      }
      uVar10 = g_list_copy(pGVar9[1].object.flags);
      local_20[0] = (GList *)g_list_concat(local_20[0],uVar10);
      goto LAB_080e573d;
    }
    if (pGVar18 == (v_00->routingedge->e).segment.v1) {
      local_20[0] = (GList *)g_list_concat(local_20[0],local_28);
      local_24 = (GList *)g_list_concat(local_24,local_2c);
      pGVar12 = (v_00->routingedge->e).segment.v2;
    }
    else {
      local_20[0] = (GList *)g_list_concat(local_20[0],local_2c);
      local_24 = (GList *)g_list_concat(local_24,local_28);
      pGVar12 = (v_00->routingedge->e).segment.v1;
    }
    e2 = (toporouter_edge_t *)gts_vertices_are_connected((ptVar16->e).segment.v2,pGVar12);
    if (e2 == (toporouter_edge_t *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x1139,"vertices_routing_conflicts",&DAT_08151856);
    }
  }
  ptVar13 = toporouter_constraint_class();
  gts_object_is_from_class(e2,ptVar13);
  uVar10 = g_list_copy(e2->routing);
  local_24 = (GList *)g_list_concat(local_24,uVar10);
LAB_080e573d:
  pGVar19 = (GList *)0x0;
  pGVar6 = (GList *)0x0;
  for (pGVar17 = local_20[0]; pGVar7 = local_24, pGVar17 != (GList *)0x0; pGVar17 = pGVar17->next) {
    pvVar5 = pGVar17->data;
    if ((((*(byte *)((int)pvVar5 + 0x39) & 1) != 0) &&
        ((iVar11 = g_list_find(local_24,*(undefined4 *)((int)pvVar5 + 0x2c)), iVar11 != 0 ||
         (iVar11 = g_list_find(local_24,*(undefined4 *)((int)pvVar5 + 0x30)), iVar11 != 0)))) &&
       (iVar11 = g_list_find(pGVar19,*(undefined4 *)((int)pvVar5 + 0x58)), iVar11 == 0)) {
      pGVar19 = (GList *)g_list_prepend(pGVar19,*(undefined4 *)((int)pvVar5 + 0x58));
    }
    pGVar6 = local_20[0];
  }
  for (; pGVar7 != (GList *)0x0; pGVar7 = pGVar7->next) {
    pvVar5 = pGVar7->data;
    if ((((*(byte *)((int)pvVar5 + 0x39) & 1) != 0) &&
        ((iVar11 = g_list_find(pGVar6,*(undefined4 *)((int)pvVar5 + 0x2c)), iVar11 != 0 ||
         (iVar11 = g_list_find(local_20[0],*(undefined4 *)((int)pvVar5 + 0x30)), iVar11 != 0)))) &&
       (iVar11 = g_list_find(pGVar19,*(undefined4 *)((int)pvVar5 + 0x58)), iVar11 == 0)) {
      pGVar19 = (GList *)g_list_prepend(pGVar19,*(undefined4 *)((int)pvVar5 + 0x58));
    }
    pGVar6 = local_20[0];
  }
  g_list_free(pGVar6);
  g_list_free(local_24);
  return pGVar19;
joined_r0x080e55d4:
  do {
    if ((GtsObjectClass *)ptVar13 == pGVar8) {
      return (GList *)0x0;
    }
    pGVar8 = pGVar8->parent_class;
  } while (pGVar8 != (GtsObjectClass *)0x0);
  goto LAB_080e54d8;
}



// WARNING: Unknown calling convention

GList * route_conflicts(toporouter_route_t *route)

{
  GList **ppGVar1;
  toporouter_vertex_t *pv;
  gpointer pvVar2;
  toporouter_vertex_t *v;
  toporouter_vertex_t *v_00;
  GList *pGVar3;
  int iVar4;
  GList *j;
  GList *pGVar5;
  GList *pGVar6;
  GList *conflicts;
  toporouter_route_t *conroute;
  GList *i;
  GList *pGVar7;
  
  pGVar6 = (GList *)0x0;
  pGVar7 = route->path;
  if (pGVar7 != (GList *)0x0) {
    pGVar6 = (GList *)0x0;
    pv = (toporouter_vertex_t *)pGVar7->data;
    while (v_00 = pv, pGVar7 = (GList *)(&pGVar7->data)[1], pGVar7 != (GList *)0x0) {
      pv = (toporouter_vertex_t *)pGVar7->data;
      if (((v_00 != (toporouter_vertex_t *)0x0) && ((v_00->v).p.z == (pv->v).p.z)) &&
         (pGVar3 = vertices_routing_conflicts(v_00,pv), pGVar5 = pGVar3, pGVar3 != (GList *)0x0)) {
        do {
          pvVar2 = pGVar5->data;
          iVar4 = g_list_find(pGVar6,pvVar2);
          if (iVar4 == 0) {
            pGVar6 = (GList *)g_list_prepend(pGVar6,pvVar2);
          }
          ppGVar1 = &pGVar5->next;
          pGVar5 = *ppGVar1;
        } while (*ppGVar1 != (GList *)0x0);
        g_list_free(pGVar3);
      }
    }
  }
  return pGVar6;
}



// WARNING: Unknown calling convention

gdouble vertices_routing_conflict_cost
                  (toporouter_t *r,toporouter_vertex_t *v,toporouter_vertex_t *pv,guint *n)

{
  double dVar1;
  gpointer *ppvVar2;
  GList *pGVar3;
  GList *conflicts;
  guint gVar4;
  GList *i;
  GList *pGVar5;
  gdouble penalty;
  
  pGVar3 = vertices_routing_conflicts(v,pv);
  if (pGVar3 == (GList *)0x0) {
    dVar1 = 0.0;
  }
  else {
    gVar4 = *n;
    dVar1 = 0.0;
    pGVar5 = pGVar3;
    do {
      ppvVar2 = &pGVar5->data;
      gVar4 = gVar4 + 1;
      pGVar5 = pGVar5->next;
      dVar1 = dVar1 + *(double *)((int)*ppvVar2 + 0x14);
    } while (pGVar5 != (GList *)0x0);
    *n = gVar4;
  }
  g_list_free(pGVar3);
  return dVar1;
}



// WARNING: Removing unreachable block (ram,0x080e5cc7)
// WARNING: Removing unreachable block (ram,0x080e5ccb)
// WARNING: Removing unreachable block (ram,0x080e5cd0)
// WARNING: Unknown calling convention

gdouble gcost(toporouter_t *r,toporouter_route_t *data,toporouter_vertex_t *srcv,
             toporouter_vertex_t *v,toporouter_vertex_t *pv,guint *n)

{
  double dVar1;
  int iVar2;
  gdouble conflictcost;
  gdouble cost;
  double dVar3;
  
  *n = pv->gn;
  iVar2 = g_list_find(data->srcvertices,v);
  if (iVar2 == 0) {
    dVar1 = (pv->v).p.x - (v->v).p.x;
    dVar3 = (pv->v).p.y - (v->v).p.y;
    dVar1 = SQRT(dVar3 * dVar3 + dVar1 * dVar1) + pv->gcost;
    if ((*(byte *)&r->flags & 0x20) != 0) {
      if ((pv == v) || ((v->v).p.z != (pv->v).p.z)) {
        dVar3 = 0.0;
      }
      else {
        dVar3 = vertices_routing_conflict_cost(r,v,pv,n);
      }
      dVar1 = (double)(ulonglong)*n * (double)(ulonglong)*n * dVar3 + dVar1;
    }
  }
  else {
    dVar1 = 0.0;
  }
  return dVar1;
}



// WARNING: Removing unreachable block (ram,0x080e5fb8)
// WARNING: Removing unreachable block (ram,0x080e5dd8)
// WARNING: Removing unreachable block (ram,0x080e5fb1)
// WARNING: Removing unreachable block (ram,0x080e5fba)
// WARNING: Removing unreachable block (ram,0x080e5fde)
// WARNING: Removing unreachable block (ram,0x080e5eb0)
// WARNING: Removing unreachable block (ram,0x080e5dd4)
// WARNING: Unknown calling convention

gdouble check_intersect_vertex
                  (gdouble x0,gdouble y0,gdouble x1,gdouble y1,toporouter_vertex_t *pathv,
                  toporouter_vertex_t *arcv,toporouter_vertex_t *opv,gint wind,gint *arcwind,
                  gdouble *arcr,guint debug)

{
  double dVar1;
  double dVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  double dVar5;
  GtsObjectClass *pGVar6;
  guint gVar7;
  int iVar8;
  GList *list;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar9;
  toporouter_edge_t *ptVar10;
  gdouble ms;
  gdouble v1keepaway;
  gdouble d;
  gdouble gVar11;
  gdouble gVar12;
  gdouble gVar13;
  double dVar14;
  gdouble y;
  gdouble x;
  double local_2c;
  double local_24 [2];
  
  pGVar6 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar10 = pathv->routingedge;
  if (pGVar6 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (ptVar10 != (toporouter_edge_t *)0x0) {
    pGVar9 = (ptVar10->e).segment.object.klass;
    if (pGVar9 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar6 == pGVar9) {
          pGVar3 = (ptVar10->e).segment.v1;
          pGVar4 = (ptVar10->e).segment.v2;
          dVar5 = (pGVar3->p).x - (pGVar4->p).x;
          dVar14 = (pGVar3->p).y - (pGVar4->p).y;
          dVar5 = SQRT(dVar14 * dVar14 + dVar5 * dVar5) * 0.5;
          gVar11 = vertex_net_thickness(pathv);
          gVar12 = vertex_net_thickness(arcv);
          dVar14 = vertex_net_keepaway(pathv);
          gVar13 = vertex_net_keepaway(arcv);
          if (dVar14 <= gVar13) {
            dVar14 = gVar13;
          }
          dVar14 = gVar12 * 0.5 + gVar11 * 0.5 + dVar14;
          if (dVar5 <= dVar14 || dVar14 != dVar5) {
            dVar14 = dVar5;
          }
          goto LAB_080e5e5e;
        }
        pGVar9 = pGVar9->parent_class;
      } while (pGVar9 != (GtsObjectClass *)0x0);
    }
  }
  pGVar6 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar10 = pathv->routingedge;
  if (pGVar6 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    ptVar10 = pathv->routingedge;
  }
  else if (ptVar10 != (toporouter_edge_t *)0x0) {
    pGVar9 = (ptVar10->e).segment.object.klass;
    if (pGVar9 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      ptVar10 = pathv->routingedge;
    }
    else {
      do {
        if (pGVar6 == pGVar9) break;
        pGVar9 = pGVar9->parent_class;
      } while (pGVar9 != (GtsObjectClass *)0x0);
    }
  }
  list = (GList *)g_list_find(ptVar10->routing);
  dVar14 = edge_min_spacing(list,ptVar10,arcv);
LAB_080e5e5e:
  gVar7 = vertex_line_normal_intersection
                    (x0,y0,x1,y1,(arcv->v).p.x,(arcv->v).p.y,local_24,&local_2c);
  if ((gVar7 != 0) &&
     (dVar5 = local_24[0] - (arcv->v).p.x, dVar1 = local_2c - (arcv->v).p.y,
     dVar5 = SQRT(dVar1 * dVar1 + dVar5 * dVar5), dVar5 <= dVar14 - 9.999999747378752e-05)) {
    coord_move_towards_coord_values((arcv->v).p.x,(arcv->v).p.y,local_24[0],local_2c,dVar14,&x,&y);
    *arcr = dVar14;
    dVar1 = (pathv->v).p.x;
    dVar2 = (pathv->v).p.y;
    iVar8 = 1;
    dVar1 = ((arcv->v).p.y - dVar2) * (dVar1 - (pathv->parent->v).p.x) -
            ((arcv->v).p.x - dVar1) * (dVar2 - (pathv->parent->v).p.y);
    if (dVar1 <= 9.999999747378752e-05) {
      iVar8 = (-9.999999747378752e-05 <= dVar1) - 1;
    }
    *arcwind = iVar8;
    return dVar14 - dVar5;
  }
  return -1.0;
}



// WARNING: Removing unreachable block (ram,0x080e6585)
// WARNING: Removing unreachable block (ram,0x080e6158)
// WARNING: Removing unreachable block (ram,0x080e6591)
// WARNING: Removing unreachable block (ram,0x080e659b)
// WARNING: Removing unreachable block (ram,0x080e6154)
// WARNING: Unknown calling convention

gdouble check_non_intersect_vertex
                  (gdouble x0,gdouble y0,gdouble x1,gdouble y1,toporouter_vertex_t *pathv,
                  toporouter_vertex_t *arcv,toporouter_vertex_t *opv,gint wind,gint *arcwind,
                  gdouble *arcr,guint debug)

{
  double dVar1;
  double dVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  double dVar5;
  double dVar6;
  GtsObjectClass *pGVar7;
  guint gVar8;
  int iVar9;
  gint wind2;
  GList *list;
  guint windtests;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar10;
  GtsObjectClass *c;
  int iVar11;
  gint wind1;
  toporouter_vertex_t *parent;
  _toporouter_vertex_t *p_Var12;
  toporouter_edge_t *ptVar13;
  int iVar14;
  toporouter_vertex_t *child;
  _toporouter_vertex_t *p_Var15;
  gdouble rval;
  gdouble v1keepaway;
  gdouble rval_1;
  gdouble d;
  gdouble dy1;
  gdouble dx1;
  gdouble gVar16;
  gdouble gVar17;
  gdouble gVar18;
  double local_7c;
  double local_74;
  double local_6c;
  double local_64;
  double local_5c;
  double local_54;
  double local_4c;
  double local_44;
  double local_3c;
  double local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  if (pathv->routingedge == (toporouter_edge_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x162b,"check_non_intersect_vertex","pathv->routingedge");
  }
  pGVar7 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar13 = pathv->routingedge;
  if (pGVar7 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (ptVar13 != (toporouter_edge_t *)0x0) {
    pGVar10 = (ptVar13->e).segment.object.klass;
    if (pGVar10 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar7 == pGVar10) {
          pGVar3 = (ptVar13->e).segment.v1;
          pGVar4 = (ptVar13->e).segment.v2;
          dVar1 = (pGVar3->p).x - (pGVar4->p).x;
          dVar2 = (pGVar3->p).y - (pGVar4->p).y;
          dVar1 = SQRT(dVar2 * dVar2 + dVar1 * dVar1) * 0.5;
          gVar16 = vertex_net_thickness(pathv);
          gVar17 = vertex_net_thickness(arcv);
          local_74 = vertex_net_keepaway(pathv);
          gVar18 = vertex_net_keepaway(arcv);
          if (local_74 <= gVar18) {
            local_74 = gVar18;
          }
          local_74 = gVar17 * 0.5 + gVar16 * 0.5 + local_74;
          if (dVar1 <= local_74 || local_74 != dVar1) {
            local_74 = dVar1;
          }
          goto LAB_080e61e9;
        }
        pGVar10 = pGVar10->parent_class;
      } while (pGVar10 != (GtsObjectClass *)0x0);
    }
  }
  pGVar7 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar13 = pathv->routingedge;
  if (pGVar7 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    ptVar13 = pathv->routingedge;
  }
  else if (ptVar13 != (toporouter_edge_t *)0x0) {
    pGVar10 = (ptVar13->e).segment.object.klass;
    if (pGVar10 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      ptVar13 = pathv->routingedge;
    }
    else {
      do {
        if (pGVar7 == pGVar10) break;
        pGVar10 = pGVar10->parent_class;
      } while (pGVar10 != (GtsObjectClass *)0x0);
    }
  }
  list = (GList *)g_list_find(ptVar13->routing);
  local_74 = edge_min_spacing(list,ptVar13,arcv);
LAB_080e61e9:
  gVar8 = vertex_line_normal_intersection
                    (x0,y0,x1,y1,(arcv->v).p.x,(arcv->v).p.y,local_24,&local_2c);
  if (gVar8 == 0) {
    if ((x0 - local_24[0]) * (x0 - local_24[0]) + (y0 - local_2c) * (y0 - local_2c) <
        (x1 - local_24[0]) * (x1 - local_24[0]) + (y1 - local_2c) * (y1 - local_2c)) {
      local_24[0] = x0;
      local_2c = y0;
    }
    else {
      local_24[0] = x1;
      local_2c = y1;
    }
    gVar16 = (arcv->v).p.y;
    gVar17 = (arcv->v).p.x;
    if ((gVar17 == local_24[0]) ||
       (local_6c = (local_2c - gVar16) / (local_24[0] - gVar17), 1.797693134862316e+308 < local_6c))
    {
      local_6c = 0.0;
    }
    else {
      local_6c = -1.0 / local_6c;
    }
  }
  else if (x0 == x1) {
    gVar16 = (arcv->v).p.y;
    gVar17 = (arcv->v).p.x;
    local_6c = INFINITY;
  }
  else {
    local_6c = (y1 - y0) / (x1 - x0);
    gVar16 = (arcv->v).p.y;
    gVar17 = (arcv->v).p.x;
  }
  coords_on_line(gVar17,gVar16,local_6c,100.0,&local_44,&local_4c,&local_54,&local_5c);
  iVar11 = 1;
  dVar1 = (local_2c - local_5c) * (local_54 - local_44) -
          (local_24[0] - local_54) * (local_5c - local_4c);
  if (dVar1 <= 9.999999747378752e-05) {
    iVar11 = (-9.999999747378752e-05 <= dVar1) - 1;
  }
  iVar9 = 1;
  dVar1 = ((opv->v).p.y - local_5c) * (local_54 - local_44) -
          ((opv->v).p.x - local_54) * (local_5c - local_4c);
  if (9.999999747378752e-05 >= dVar1) {
    iVar9 = (-9.999999747378752e-05 <= dVar1) - 1;
  }
  if ((iVar11 != iVar9) && (9.999999747378752e-05 < dVar1 || dVar1 < -9.999999747378752e-05)) {
    if (wind == 0) {
      if (local_6c <= 1.797693134862316e+308) {
        gVar16 = -1.0 / local_6c;
      }
      else {
        gVar16 = 0.0;
      }
      coords_on_line(local_24[0],local_2c,gVar16,local_74,&local_44,&local_4c,&local_54,&local_5c);
      local_44 = local_44 - (opv->v).p.x;
      local_4c = local_4c - (opv->v).p.y;
      local_54 = local_54 - (opv->v).p.x;
      local_5c = local_5c - (opv->v).p.y;
      if (local_54 * local_54 + local_5c * local_5c <= local_44 * local_44 + local_4c * local_4c) {
        local_64 = 0.0;
      }
      else {
        local_64 = 0.0;
      }
LAB_080e63db:
      *arcr = local_74;
      dVar1 = (pathv->v).p.x;
      dVar2 = (pathv->v).p.y;
      iVar11 = 1;
      dVar1 = ((arcv->v).p.y - dVar2) * (dVar1 - (pathv->parent->v).p.x) -
              ((arcv->v).p.x - dVar1) * (dVar2 - (pathv->parent->v).p.y);
      if (dVar1 <= 9.999999747378752e-05) {
        iVar11 = (-9.999999747378752e-05 <= dVar1) - 1;
      }
      *arcwind = iVar11;
      return local_64 + local_74;
    }
    dVar1 = (arcv->v).p.x;
    p_Var12 = pathv->parent;
    dVar5 = dVar1 - local_24[0];
    p_Var15 = pathv->child;
    dVar2 = (arcv->v).p.y;
    dVar6 = dVar2 - local_2c;
    local_64 = SQRT(dVar6 * dVar6 + dVar5 * dVar5);
    coord_move_towards_coord_values
              (local_24[0],local_2c,dVar1,dVar2,local_74 + local_64,&local_34,&local_3c);
    iVar11 = 0;
    dVar1 = (p_Var12->v).p.y - local_3c;
    dVar2 = (p_Var12->v).p.x - local_34;
    local_6c = (p_Var15->v).p.y - local_3c;
    local_7c = (p_Var15->v).p.x - local_34;
    while( true ) {
      iVar9 = 1;
      dVar5 = dVar1 * (local_34 - local_24[0]) - dVar2 * (local_3c - local_2c);
      if (dVar5 <= 9.999999747378752e-05) {
        iVar9 = (-9.999999747378752e-05 <= dVar5) - 1;
      }
      iVar14 = 1;
      dVar5 = local_6c * (local_34 - local_24[0]) - local_7c * (local_3c - local_2c);
      if (dVar5 <= 9.999999747378752e-05) {
        if (-9.999999747378752e-05 <= dVar5) goto LAB_080e63db;
        iVar14 = -1;
      }
      if ((iVar9 == 0) || (iVar9 != iVar14)) goto LAB_080e63db;
      if (iVar11 == 2) break;
      if ((*(byte *)((int)&p_Var12->flags + 1) & 1) != 0) {
        p_Var12 = p_Var12->parent;
        dVar1 = (p_Var12->v).p.y - local_3c;
        dVar2 = (p_Var12->v).p.x - local_34;
      }
      if ((*(byte *)((int)&p_Var15->flags + 1) & 1) != 0) {
        p_Var15 = p_Var15->child;
        local_6c = (p_Var15->v).p.y - local_3c;
        local_7c = (p_Var15->v).p.x - local_34;
      }
      iVar11 = iVar11 + 1;
    }
  }
  return -1.0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

GList * oproute_rubberband_segment
                  (toporouter_t *r,toporouter_oproute_t *oproute,GList *path,gpointer t1,gpointer t2
                  ,guint debug)

{
  double x1_00;
  double y1_00;
  gdouble gVar1;
  toporouter_vertex_t **__ptr;
  int iVar2;
  double dVar3;
  toporouter_vertex_t *ptVar4;
  GtsObjectClass *pGVar5;
  toporouter_edge_t *ptVar6;
  toporouter_arc_class_t *ptVar7;
  gpointer pvVar8;
  int **ppiVar9;
  toporouter_vertex_t *ptVar10;
  toporouter_arc_t *arc;
  guint gVar11;
  GList *pGVar12;
  int *piVar13;
  GList *list;
  gint gVar14;
  undefined4 uVar15;
  toporouter_vertex_t *ptVar16;
  toporouter_vertex_t *v_2;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  toporouter_arc_class_t *ptVar17;
  GtsObjectClass *c_3;
  GtsObjectClass *c_4;
  GtsObjectClass *pGVar18;
  toporouter_arc_t *parc;
  toporouter_arc_t *narc;
  toporouter_rubberband_arc_t *max;
  toporouter_arc_t *testarc;
  toporouter_vertex_t *ptVar19;
  GList *i;
  GList *list2;
  toporouter_arc_t *newarc;
  toporouter_vertex_t *v_1;
  toporouter_vertex_t *av1;
  gdouble d;
  gdouble y1;
  gdouble x1;
  gdouble gVar20;
  int local_a0;
  undefined4 local_60;
  double local_5c;
  toporouter_vertex_t *local_50;
  double local_4c;
  toporouter_arc_t *local_40;
  toporouter_arc_t *local_3c;
  toporouter_vertex_t *local_38;
  toporouter_vertex_t *local_34;
  int local_30;
  gdouble local_2c;
  gint local_20 [4];
  
  pGVar5 = (GtsObjectClass *)toporouter_vertex_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (t1 != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar18 = *t1;
    if (pGVar18 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar5 == pGVar18) {
          local_3c = (toporouter_arc_t *)0x0;
          local_5c = *(double *)((int)t1 + 0xc);
          local_4c = *(double *)((int)t1 + 0x14);
          local_38 = (toporouter_vertex_t *)t1;
          goto LAB_080e68c0;
        }
        pGVar18 = pGVar18->parent_class;
      } while (pGVar18 != (GtsObjectClass *)0x0);
    }
  }
  ptVar7 = toporouter_arc_class();
  pvVar8 = gts_object_is_from_class(t1,ptVar7);
  if (pvVar8 == (gpointer)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x16ca,"oproute_rubberband_segment",
               "TOPOROUTER_IS_ARC(t1)");
  }
  local_3c = (toporouter_arc_t *)t1;
  local_38 = *(toporouter_vertex_t **)((int)t1 + 0x48);
  local_5c = *(double *)((int)t1 + 0x1c);
  local_4c = *(double *)((int)t1 + 0x24);
LAB_080e68c0:
  pGVar5 = (GtsObjectClass *)toporouter_vertex_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (t2 != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar18 = *t2;
    if (pGVar18 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar5 == pGVar18) {
          local_40 = (toporouter_arc_t *)0x0;
          x1_00 = *(double *)((int)t2 + 0xc);
          local_34 = (toporouter_vertex_t *)t2;
          y1_00 = *(double *)((int)t2 + 0x14);
          goto LAB_080e690a;
        }
        pGVar18 = pGVar18->parent_class;
      } while (pGVar18 != (GtsObjectClass *)0x0);
    }
  }
  ptVar7 = toporouter_arc_class();
  if (ptVar7 == (toporouter_arc_class_t *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (t2 != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    ptVar17 = *t2;
    if (ptVar17 == (toporouter_arc_class_t *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (ptVar7 == ptVar17) {
          local_40 = (toporouter_arc_t *)t2;
          local_34 = *(toporouter_vertex_t **)((int)t2 + 0x4c);
          x1_00 = *(double *)((int)t2 + 0xc);
          y1_00 = *(double *)((int)t2 + 0x14);
LAB_080e690a:
          if (local_38 == local_34) {
            return (GList *)0;
          }
          pGVar12 = path->next;
          if (pGVar12 == (GList *)0x0) {
            return (GList *)0;
          }
          if ((toporouter_vertex_t *)path->data == local_34) {
            return (GList *)0;
          }
          ptVar19 = (toporouter_vertex_t *)pGVar12->data;
          if (((ptVar19 == local_34) || (ptVar19 == local_38)) ||
             (ptVar6 = ptVar19->routingedge, ptVar6 == (toporouter_edge_t *)0x0)) {
            local_60 = 0;
            goto LAB_080e6f85;
          }
          local_60 = 0;
          do {
            ptVar16 = (toporouter_vertex_t *)(ptVar6->e).segment.v1;
            local_a0 = 1;
            dVar3 = ((ptVar16->v).p.y - y1_00) * (x1_00 - local_5c) -
                    ((ptVar16->v).p.x - x1_00) * (y1_00 - local_4c);
            if (dVar3 <= 9.999999747378752e-05) {
              local_a0 = (-9.999999747378752e-05 <= dVar3) - 1;
            }
            ptVar10 = (toporouter_vertex_t *)(ptVar6->e).segment.v2;
            local_30 = 1;
            dVar3 = ((ptVar10->v).p.y - y1_00) * (x1_00 - local_5c) -
                    ((ptVar10->v).p.x - x1_00) * (y1_00 - local_4c);
            if ((9.999999747378752e-05 < dVar3) || (local_30 = -1, dVar3 < -9.999999747378752e-05))
            {
              if ((local_a0 == 0) || (local_a0 == local_30)) goto LAB_080e6c48;
              if ((local_3c == (toporouter_arc_t *)0x0) ||
                 (local_50 = local_3c->centre, local_50 != ptVar16)) {
                if ((local_40 == (toporouter_arc_t *)0x0) || (local_40->centre != ptVar16)) {
                  gVar20 = check_intersect_vertex
                                     (local_5c,local_4c,x1_00,y1_00,ptVar19,ptVar16,ptVar10,local_a0
                                      ,local_20,&local_2c,debug);
                  if (9.999999747378752e-05 < gVar20) {
                    new_rubberband_arc(ptVar19,(toporouter_vertex_t *)
                                               (ptVar19->routingedge->e).segment.v1,local_2c,gVar20,
                                       local_20[0],pGVar12);
                    local_60 = g_list_prepend(local_60);
                    ptVar6 = ptVar19->routingedge;
                  }
                  else {
                    ptVar6 = ptVar19->routingedge;
                  }
                }
                if (local_3c != (toporouter_arc_t *)0x0) {
                  local_50 = local_3c->centre;
                  goto LAB_080e6a98;
                }
                ptVar16 = (toporouter_vertex_t *)(ptVar6->e).segment.v2;
              }
              else {
LAB_080e6a98:
                ptVar16 = (toporouter_vertex_t *)(ptVar6->e).segment.v2;
                if (local_50 == ptVar16) goto LAB_080e6b68;
              }
              if (((local_40 == (toporouter_arc_t *)0x0) || (ptVar16 != local_40->centre)) &&
                 (gVar20 = check_intersect_vertex
                                     (local_5c,local_4c,x1_00,y1_00,ptVar19,ptVar16,
                                      (toporouter_vertex_t *)(ptVar6->e).segment.v1,local_30,
                                      local_20,&local_2c,debug), 9.999999747378752e-05 < gVar20)) {
                new_rubberband_arc(ptVar19,(toporouter_vertex_t *)
                                           (ptVar19->routingedge->e).segment.v2,local_2c,gVar20,
                                   local_20[0],pGVar12);
                local_60 = g_list_prepend(local_60);
              }
            }
            else {
              local_30 = 0;
              if (local_a0 != 0) {
LAB_080e6c48:
                if ((local_3c == (toporouter_arc_t *)0x0) ||
                   (local_50 = local_3c->centre, local_50 != ptVar16)) {
                  if ((local_40 == (toporouter_arc_t *)0x0) || (local_40->centre != ptVar16)) {
                    gVar20 = check_non_intersect_vertex
                                       (local_5c,local_4c,x1_00,y1_00,ptVar19,ptVar16,ptVar10,
                                        local_a0,local_20,&local_2c,debug);
                    if (9.999999747378752e-05 < gVar20) {
                      new_rubberband_arc(ptVar19,(toporouter_vertex_t *)
                                                 (ptVar19->routingedge->e).segment.v1,local_2c,
                                         gVar20,local_20[0],pGVar12);
                      local_60 = g_list_prepend(local_60);
                      ptVar6 = ptVar19->routingedge;
                    }
                    else {
                      ptVar6 = ptVar19->routingedge;
                    }
                  }
                  if (local_3c != (toporouter_arc_t *)0x0) {
                    local_50 = local_3c->centre;
                    goto LAB_080e6d38;
                  }
                  ptVar16 = (toporouter_vertex_t *)(ptVar6->e).segment.v2;
                }
                else {
LAB_080e6d38:
                  ptVar16 = (toporouter_vertex_t *)(ptVar6->e).segment.v2;
                  if (ptVar16 == local_50) goto LAB_080e6b68;
                }
                if (((local_40 == (toporouter_arc_t *)0x0) || (local_40->centre != ptVar16)) &&
                   (gVar20 = check_non_intersect_vertex
                                       (local_5c,local_4c,x1_00,y1_00,ptVar19,ptVar16,
                                        (toporouter_vertex_t *)(ptVar6->e).segment.v1,local_30,
                                        local_20,&local_2c,debug), 9.999999747378752e-05 < gVar20))
                {
                  new_rubberband_arc(ptVar19,(toporouter_vertex_t *)
                                             (ptVar19->routingedge->e).segment.v2,local_2c,gVar20,
                                     local_20[0],pGVar12);
                  local_60 = g_list_prepend(local_60);
                }
              }
            }
LAB_080e6b68:
            pGVar12 = pGVar12->next;
            if ((((pGVar12 == (GList *)0x0) ||
                 (ptVar19 = (toporouter_vertex_t *)pGVar12->data, ptVar19 == local_34)) ||
                (ptVar19 == local_38)) ||
               (ptVar6 = ptVar19->routingedge, ptVar6 == (toporouter_edge_t *)0x0)) {
LAB_080e6f85:
              ppiVar9 = (int **)g_list_sort(local_60);
              do {
                if (ppiVar9 == (int **)0x0) {
                  return (GList *)0x0;
                }
                __ptr = (toporouter_vertex_t **)*ppiVar9;
                ptVar19 = *__ptr;
                ptVar16 = (toporouter_vertex_t *)(__ptr[7]->v).p.object.reserved;
                local_38 = ptVar19;
                if (ptVar16 == (toporouter_vertex_t *)0x0) {
                  ptVar10 = __ptr[1];
                }
                else {
                  ptVar6 = (*(toporouter_vertex_t **)&ptVar16->v)->routingedge;
                  if (ptVar6 == (toporouter_edge_t *)0x0) {
                    ptVar10 = __ptr[1];
                  }
                  else {
                    ptVar10 = __ptr[1];
                    ptVar4 = *(toporouter_vertex_t **)&ptVar16->v;
                    do {
                      local_50 = ptVar4;
                      if ((ptVar10 != (toporouter_vertex_t *)(ptVar6->e).segment.v1) &&
                         (ptVar10 != (toporouter_vertex_t *)(ptVar6->e).segment.v2))
                      goto LAB_080e6ff1;
                      ptVar16 = *(toporouter_vertex_t **)((int)&ptVar16->v + 4);
                      if (ptVar16 == (toporouter_vertex_t *)0x0) break;
                      ptVar6 = (*(toporouter_vertex_t **)&ptVar16->v)->routingedge;
                      local_38 = local_50;
                      ptVar4 = *(toporouter_vertex_t **)&ptVar16->v;
                    } while (ptVar6 != (toporouter_edge_t *)0x0);
                    local_38 = local_50;
                  }
                }
LAB_080e6ff1:
                ptVar16 = (toporouter_vertex_t *)(__ptr[7]->v).p.object.flags;
                if (ptVar16 != (toporouter_vertex_t *)0x0) {
                  ptVar6 = (*(toporouter_vertex_t **)&ptVar16->v)->routingedge;
                  ptVar4 = *(toporouter_vertex_t **)&ptVar16->v;
                  while (((ptVar6 != (toporouter_edge_t *)0x0 &&
                          (((toporouter_vertex_t *)(ptVar6->e).segment.v1 == ptVar10 ||
                           ((toporouter_vertex_t *)(ptVar6->e).segment.v2 == ptVar10)))) &&
                         (ptVar16 = *(toporouter_vertex_t **)((int)&ptVar16->v + 8),
                         ptVar19 = ptVar4, ptVar16 != (toporouter_vertex_t *)0x0))) {
                    ptVar6 = (*(toporouter_vertex_t **)&ptVar16->v)->routingedge;
                    ptVar4 = *(toporouter_vertex_t **)&ptVar16->v;
                  }
                }
                arc = toporouter_arc_new(oproute,ptVar19,local_38,ptVar10,*(gdouble *)(__ptr + 2),
                                         (gint)__ptr[6]);
                pGVar5 = (GtsObjectClass *)toporouter_vertex_class();
                if (pGVar5 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                }
                else if (t1 != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
                  pGVar18 = *t1;
                  if (pGVar18 == (GtsObjectClass *)0x0) {
                    g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
                  }
                  else {
                    do {
                      if (pGVar5 == pGVar18) {
                        calculate_term_to_arc((toporouter_vertex_t *)t1,arc,0);
                        goto LAB_080e7099;
                      }
                      pGVar18 = pGVar18->parent_class;
                    } while (pGVar18 != (GtsObjectClass *)0x0);
                  }
                }
                gVar11 = calculate_arc_to_arc(r,(toporouter_arc_t *)t1,arc);
                if (gVar11 != 0) {
                  __printf_chk(1,"\tERROR: best:  r = %f d = %f\n",*(undefined8 *)(__ptr + 2),
                               *(undefined8 *)(__ptr + 4));
                  return (GList *)0x0;
                }
LAB_080e7099:
                pGVar5 = (GtsObjectClass *)toporouter_vertex_class();
                if (pGVar5 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                }
                else if (t2 != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
                  pGVar18 = *t2;
                  if (pGVar18 == (GtsObjectClass *)0x0) {
                    g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
                  }
                  else {
                    do {
                      if (pGVar5 == pGVar18) {
                        calculate_term_to_arc((toporouter_vertex_t *)t2,arc,1);
                        goto LAB_080e70e9;
                      }
                      pGVar18 = pGVar18->parent_class;
                    } while (pGVar18 != (GtsObjectClass *)0x0);
                  }
                }
                gVar11 = calculate_arc_to_arc(r,arc,(toporouter_arc_t *)t2);
                if (gVar11 != 0) {
                  __printf_chk(1,"\tERROR: best: r = %f d = %f\n",*(undefined8 *)(__ptr + 2),
                               *(undefined8 *)(__ptr + 4));
                  return (GList *)0x0;
                }
LAB_080e70e9:
                gVar11 = check_arc_for_loops(t1,arc,t2);
                if (gVar11 == 0) {
                  local_34 = (toporouter_vertex_t *)
                             oproute_rubberband_segment(r,oproute,path,t1,arc,debug);
                  pGVar12 = oproute_rubberband_segment
                                      (r,oproute,
                                       (GList *)*(toporouter_vertex_t **)((int)&ptVar16->v + 4),arc,
                                       t2,debug);
                  if (local_34 != (toporouter_vertex_t *)0x0) {
                    piVar13 = (int *)g_list_last(local_34);
                    iVar2 = *piVar13;
                    if ((toporouter_arc_t **)piVar13[2] != (toporouter_arc_t **)0x0) {
                      local_3c = *(toporouter_arc_t **)piVar13[2];
                    }
                    if (local_3c == (toporouter_arc_t *)0x0) {
                      gVar20 = *(gdouble *)((int)t1 + 0xc);
                      gVar1 = *(gdouble *)((int)t1 + 0x14);
                    }
                    else {
                      gVar20 = local_3c->x1;
                      gVar1 = local_3c->y1;
                    }
                    gVar14 = coord_intersect_prop
                                       (gVar20,gVar1,*(gdouble *)(iVar2 + 0xc),
                                        *(gdouble *)(iVar2 + 0x14),*(gdouble *)(iVar2 + 0x1c),
                                        *(gdouble *)(iVar2 + 0x24),arc->x0,arc->y0);
                    if (gVar14 != 0) {
                      local_34 = (toporouter_vertex_t *)g_list_remove(local_34);
                      if (local_3c == (toporouter_arc_t *)0x0) {
                        calculate_term_to_arc((toporouter_vertex_t *)t1,arc,0);
                      }
                      else {
                        calculate_arc_to_arc(r,local_3c,arc);
                      }
                    }
                  }
                  if (pGVar12 != (GList *)0x0) {
                    pvVar8 = pGVar12->data;
                    if (pGVar12->next != (GList *)0x0) {
                      local_40 = (toporouter_arc_t *)pGVar12->next->data;
                    }
                    if (local_40 == (toporouter_arc_t *)0x0) {
                      gVar20 = *(gdouble *)((int)t2 + 0xc);
                      gVar1 = *(gdouble *)((int)t2 + 0x14);
                    }
                    else {
                      gVar20 = local_40->x0;
                      gVar1 = local_40->y0;
                    }
                    gVar14 = coord_intersect_prop
                                       (arc->x1,arc->y1,*(gdouble *)((int)pvVar8 + 0xc),
                                        *(gdouble *)((int)pvVar8 + 0x14),
                                        *(gdouble *)((int)pvVar8 + 0x1c),
                                        *(gdouble *)((int)pvVar8 + 0x24),gVar20,gVar1);
                    if (gVar14 != 0) {
                      pGVar12 = (GList *)g_list_remove(pGVar12);
                      if (local_40 == (toporouter_arc_t *)0x0) {
                        calculate_term_to_arc((toporouter_vertex_t *)t2,arc,1);
                      }
                      else {
                        calculate_arc_to_arc(r,arc,local_40);
                      }
                    }
                  }
                  g_list_foreach(ppiVar9,free_list_elements,0);
                  g_list_free(ppiVar9);
                  uVar15 = g_list_prepend(pGVar12,arc);
                  pGVar12 = (GList *)g_list_concat(local_34,uVar15);
                  return pGVar12;
                }
                if (local_40 == (toporouter_arc_t *)0x0) {
                  if (local_3c != (toporouter_arc_t *)0x0) {
                    calculate_term_to_arc((toporouter_vertex_t *)t2,local_3c,1);
                  }
                }
                else if (local_3c != (toporouter_arc_t *)0x0) {
                  calculate_arc_to_arc(r,local_3c,local_40);
                }
                else {
                  calculate_term_to_arc((toporouter_vertex_t *)t1,local_40,0);
                }
                ppiVar9 = (int **)g_list_remove(ppiVar9);
                free(__ptr);
              } while( true );
            }
          } while( true );
        }
        ptVar17 = (toporouter_arc_class_t *)(ptVar17->parent_class).parent_class;
      } while (ptVar17 != (toporouter_arc_class_t *)0x0);
    }
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr
            (0,"../../src/toporouter.c",0x16d5,"oproute_rubberband_segment","TOPOROUTER_IS_ARC(t2)")
  ;
}



// WARNING: Unknown calling convention

toporouter_oproute_t * oproute_rubberband(toporouter_t *r,GList *path)

{
  double dVar1;
  toporouter_vertex_t *ptVar2;
  _toporouter_cluster_t *p_Var3;
  toporouter_netlist_t *ptVar4;
  toporouter_oproute_t *oproute;
  toporouter_vertex_t **pptVar5;
  GList *pGVar6;
  _toporouter_bbox_t *p_Var7;
  toporouter_vertex_t *v;
  guint local_2c;
  
  oproute = (toporouter_oproute_t *)calloc(1,0x28);
  if (path != (GList *)0x0) {
    oproute->term1 = (toporouter_vertex_t *)path->data;
    pptVar5 = (toporouter_vertex_t **)g_list_last(path);
    p_Var7 = (_toporouter_bbox_t *)0x0;
    oproute->arcs = (GList *)0x0;
    oproute->term2 = *pptVar5;
    ptVar2 = oproute->term1;
    if (ptVar2 != (toporouter_vertex_t *)0x0) {
      p_Var7 = ptVar2->bbox;
    }
    oproute->style = p_Var7->cluster->netlist->style;
    p_Var7 = (_toporouter_bbox_t *)0x0;
    if (ptVar2 != (toporouter_vertex_t *)0x0) {
      p_Var7 = ptVar2->bbox;
    }
    p_Var3 = p_Var7->cluster;
    dVar1 = (ptVar2->v).p.z;
    oproute->path = path;
    ptVar4 = p_Var3->netlist;
    oproute->serp = (toporouter_serpintine_t *)0x0;
    oproute->netlist = ptVar4->netlist;
    local_2c = (guint)(longlong)ROUND(dVar1);
    ptVar2->parent = (_toporouter_vertex_t *)0x0;
    oproute->layergroup = local_2c;
    oproute->term2->child = (_toporouter_vertex_t *)0x0;
    pGVar6 = path;
    do {
      if ((*(byte *)((int)pGVar6->data + 0x39) & 1) != 0) {
        *(toporouter_oproute_t **)((int)pGVar6->data + 0x54) = oproute;
      }
      pGVar6 = pGVar6->next;
    } while (pGVar6 != (GList *)0x0);
    oproute_path_speccut(oproute);
    pGVar6 = oproute_rubberband_segment(r,oproute,path,oproute->term1,oproute->term2,0);
    oproute->arcs = pGVar6;
    oproute_check_all_loops(r,oproute);
    return oproute;
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr(0,"../../src/toporouter.c",0x185b,"oproute_rubberband","path");
}



// WARNING: Unknown calling convention

void toporouter_export(toporouter_t *r)

{
  toporouter_oproute_t *ptVar1;
  toporouter_oproute_t *oproute;
  toporouter_oproute_t *oproute_1;
  GList *i;
  GList *pGVar2;
  GList *oproutes;
  
  pGVar2 = r->routednets;
  if (pGVar2 != (GList *)0x0) {
    oproute = (toporouter_oproute_t *)0x0;
    do {
      ptVar1 = oproute_rubberband(r,*(GList **)((int)pGVar2->data + 0x2c));
      oproute = (toporouter_oproute_t *)g_list_prepend(oproute,ptVar1);
      pGVar2 = pGVar2->next;
    } while (pGVar2 != (GList *)0x0);
    for (; oproute != (toporouter_oproute_t *)0x0;
        oproute = *(toporouter_oproute_t **)((int)&((toporouter_vertex_t *)oproute)->v + 4)) {
      ptVar1 = *(toporouter_oproute_t **)&((toporouter_vertex_t *)oproute)->v;
      export_oproutes(r,ptVar1);
      oproute_free(ptVar1);
    }
  }
  Message("Reticulating splines... successful\n\n");
  g_list_free();
  return;
}



// WARNING: Unknown calling convention

void edge_adjacent_vertices
               (toporouter_edge_t *e,toporouter_vertex_t *v,toporouter_vertex_t **v1,
               toporouter_vertex_t **v2)

{
  GtsObjectClass *pGVar1;
  GList *pGVar2;
  toporouter_vertex_t *ptVar3;
  toporouter_constraint_class_t *klass;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar4;
  GList *r;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar4 = (e->e).segment.object.klass;
    if (pGVar4 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar4) break;
        pGVar4 = pGVar4->parent_class;
      } while (pGVar4 != (GtsObjectClass *)0x0);
    }
  }
  pGVar2 = (GList *)g_list_find(e->routing,v);
  if ((toporouter_vertex_t *)(e->e).segment.v1 == v) {
    *v1 = (toporouter_vertex_t *)0x0;
    klass = toporouter_constraint_class();
    gts_object_is_from_class(e,klass);
    ptVar3 = edge_routing_next_not_temp(e,e->routing);
    *v2 = ptVar3;
  }
  else {
    if ((toporouter_vertex_t *)(e->e).segment.v2 == v) {
      pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar1 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        pGVar4 = (e->e).segment.object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar1 == pGVar4) break;
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
      pGVar2 = (GList *)g_list_last(e->routing);
      ptVar3 = edge_routing_prev_not_temp(e,pGVar2);
      *v1 = ptVar3;
      *v2 = (toporouter_vertex_t *)0x0;
      return;
    }
    ptVar3 = edge_routing_prev_not_temp(e,pGVar2);
    *v1 = ptVar3;
    ptVar3 = edge_routing_next_not_temp(e,pGVar2);
    *v2 = ptVar3;
  }
  return;
}



// WARNING: Unknown calling convention

toporouter_vertex_t * new_temp_toporoutervertex(gdouble x,gdouble y,toporouter_edge_t *e)

{
  double dVar1;
  GtsVertexClass *klass;
  GtsObjectClass *pGVar2;
  GList *i;
  toporouter_vertex_t *ptVar3;
  GList *pGVar4;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  GtsObjectClass *pGVar5;
  GtsObjectClass *c_3;
  toporouter_vertex_t *r;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
LAB_080e7cc7:
    g_return_if_fail_warning(0,"gts_object_is_from_class");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar5 = (e->e).segment.object.klass;
    if (pGVar5 == (GtsObjectClass *)0x0) goto LAB_080e7cc7;
    do {
      if (pGVar2 == pGVar5) break;
      pGVar5 = pGVar5->parent_class;
    } while (pGVar5 != (GtsObjectClass *)0x0);
  }
  pGVar4 = e->routing;
  if (pGVar4 != (GList *)0x0) {
    do {
      ptVar3 = (toporouter_vertex_t *)pGVar4->data;
      dVar1 = (ptVar3->v).p.x;
      if ((((x - 9.999999747378752e-05 < dVar1) && (dVar1 < x + 9.999999747378752e-05)) &&
          (dVar1 = (ptVar3->v).p.y, y - 9.999999747378752e-05 < dVar1)) &&
         ((dVar1 < y + 9.999999747378752e-05 && (*(char *)&ptVar3->flags < '\0')))) {
        return ptVar3;
      }
      pGVar4 = (GList *)(&pGVar4->data)[1];
    } while (pGVar4 != (GList *)0x0);
  }
  ptVar3 = (toporouter_vertex_t *)gts_vertex_new(klass,x,y,(((e->e).segment.v1)->p).z);
  ptVar3->flags = ptVar3->flags | 0x80;
  ptVar3->routingedge = e;
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    pGVar5 = (e->e).segment.object.klass;
    if (pGVar5 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar2 == pGVar5) {
          pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
          if (pGVar2 == (GtsObjectClass *)0x0) goto LAB_080e7c9c;
          pGVar5 = (e->e).segment.object.klass;
          if (pGVar5 != (GtsObjectClass *)0x0) goto LAB_080e7c02;
          goto LAB_080e7c65;
        }
        pGVar5 = pGVar5->parent_class;
      } while (pGVar5 != (GtsObjectClass *)0x0);
    }
  }
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
LAB_080e7c9c:
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    pGVar5 = (e->e).segment.object.klass;
    if (pGVar5 == (GtsObjectClass *)0x0) {
LAB_080e7c65:
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar2 == pGVar5) break;
        pGVar5 = pGVar5->parent_class;
      } while (pGVar5 != (GtsObjectClass *)0x0);
    }
  }
LAB_080e7c06:
  pGVar4 = (GList *)g_list_insert_sorted_with_data(e->routing,ptVar3,routing_edge_insert,e);
  e->routing = pGVar4;
  return ptVar3;
  while (pGVar5 = pGVar5->parent_class, pGVar5 != (GtsObjectClass *)0x0) {
LAB_080e7c02:
    if (pGVar2 == pGVar5) break;
  }
  goto LAB_080e7c06;
}



// WARNING: Removing unreachable block (ram,0x080e80d0)
// WARNING: Removing unreachable block (ram,0x080e80c4)
// WARNING: Removing unreachable block (ram,0x080e80d4)
// WARNING: Removing unreachable block (ram,0x080e7f10)
// WARNING: Removing unreachable block (ram,0x080e80ee)
// WARNING: Unknown calling convention

GList * candidate_vertices(toporouter_vertex_t *v1,toporouter_vertex_t *v2,toporouter_vertex_t *dest
                          ,toporouter_edge_t *e)

{
  float fVar1;
  float fVar2;
  float fVar3;
  GtsObjectClass *pGVar4;
  toporouter_vertex_t *ptVar5;
  undefined4 uVar6;
  GtsObjectClass *c;
  GtsObjectClass *pGVar7;
  GList *pGVar8;
  GList *vs;
  gdouble capacity;
  gdouble ms;
  gdouble v1ms;
  gdouble v2ms;
  gdouble gVar9;
  gdouble gVar10;
  gdouble gVar11;
  double dVar12;
  gdouble gVar13;
  gdouble gVar14;
  double dVar15;
  gdouble gVar16;
  gdouble gVar17;
  double dVar18;
  gdouble gVar19;
  gdouble local_6c;
  gdouble local_4c;
  gdouble local_44;
  gdouble local_3c;
  gdouble local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  if (v1 == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xd0b,"candidate_vertices",&DAT_08161c26);
  }
  if (v2 == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xd0c,"candidate_vertices",&DAT_081516f2);
  }
  if (dest == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xd0d,"candidate_vertices","dest");
  }
  if (*(char *)&v1->flags < '\0') {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xd0f,"candidate_vertices",
               "!(v1->flags & VERTEX_FLAG_TEMP)");
  }
  if (*(char *)&v2->flags < '\0') {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xd10,"candidate_vertices",
               "!(v2->flags & VERTEX_FLAG_TEMP)");
  }
  gVar9 = gts_point_distance((GtsPoint *)v1,(GtsPoint *)v2);
  gVar10 = vertex_net_thickness(v1);
  gVar11 = vertex_net_thickness(dest);
  dVar12 = vertex_net_keepaway(v1);
  gVar13 = vertex_net_keepaway(dest);
  if (dVar12 <= gVar13) {
    dVar12 = gVar13;
  }
  gVar13 = vertex_net_thickness(v2);
  gVar14 = vertex_net_thickness(dest);
  dVar15 = vertex_net_keepaway(v2);
  gVar16 = vertex_net_keepaway(dest);
  if (dVar15 <= gVar16) {
    dVar15 = gVar16;
  }
  gVar16 = vertex_net_thickness(dest);
  gVar17 = vertex_net_thickness(dest);
  dVar18 = vertex_net_keepaway(dest);
  gVar19 = vertex_net_keepaway(dest);
  if (dVar18 <= gVar19) {
    dVar18 = gVar19;
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar7 = (e->e).segment.object.klass;
    if (pGVar7 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar4 == pGVar7) {
          local_6c = 0.0;
          goto LAB_080e7e5c;
        }
        pGVar7 = pGVar7->parent_class;
      } while (pGVar7 != (GtsObjectClass *)0x0);
    }
  }
  local_6c = edge_flow(e,v1,v2,dest);
LAB_080e7e5c:
  pGVar8 = (GList *)0x0;
  gVar19 = edge_capacity(e);
  if (local_6c < gVar19) {
    fVar3 = (float)gVar11 * 0.5 + (float)gVar10 * 0.5 + (float)dVar12;
    fVar2 = (float)gVar14 * 0.5 + (float)gVar13 * 0.5 + (float)dVar15;
    fVar1 = (float)gVar17 * 0.5 + (float)gVar16 * 0.5 + (float)dVar18;
    if ((float)gVar9 <= fVar3 + fVar2 + fVar1) {
      ptVar5 = new_temp_toporoutervertex
                         ((double)(((float)(v1->v).p.x + (float)(v2->v).p.x) * 0.5),
                          (double)(((float)(v1->v).p.y + (float)(v2->v).p.y) * 0.5),e);
      pGVar8 = (GList *)g_list_prepend(0,ptVar5);
    }
    else {
      vertex_move_towards_vertex_values(&v1->v,&v2->v,(double)fVar3,local_24,&local_2c);
      new_temp_toporoutervertex(local_24[0],local_2c,e);
      uVar6 = g_list_prepend(0);
      vertex_move_towards_vertex_values(&v2->v,&v1->v,(double)fVar2,&local_34,&local_3c);
      ptVar5 = new_temp_toporoutervertex(local_34,local_3c,e);
      pGVar8 = (GList *)g_list_prepend(uVar6,ptVar5);
      dVar12 = SQRT((local_2c - local_3c) * (local_2c - local_3c) +
                    (local_24[0] - local_34) * (local_24[0] - local_34));
      if ((double)fVar1 < dVar12) {
        coord_move_towards_coord_values
                  (local_24[0],local_2c,local_34,local_3c,dVar12 * 0.5,&local_44,&local_4c);
        ptVar5 = new_temp_toporoutervertex(local_44,local_4c,e);
        pGVar8 = (GList *)g_list_prepend(pGVar8,ptVar5);
      }
    }
  }
  return pGVar8;
}



// WARNING: Removing unreachable block (ram,0x080e82ac)
// WARNING: Unknown calling convention

toporouter_vertex_t *
new_temp_toporoutervertex_in_segment
          (toporouter_edge_t *e,toporouter_vertex_t *v,gdouble r,toporouter_vertex_t *ref)

{
  double dVar1;
  double dVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  double dVar5;
  double dVar6;
  toporouter_vertex_t *rval;
  toporouter_vertex_t *ptVar7;
  gdouble m;
  toporouter_spoint_t np2;
  toporouter_spoint_t np1;
  toporouter_spoint_t p;
  
  pGVar3 = (e->e).segment.v2;
  dVar1 = (pGVar3->p).x;
  pGVar4 = (e->e).segment.v1;
  dVar2 = (pGVar4->p).x;
  if (dVar1 == dVar2) {
    dVar1 = INFINITY;
  }
  else {
    dVar1 = ((pGVar3->p).y - (pGVar4->p).y) / (dVar1 - dVar2);
  }
  p.x = (v->v).p.x;
  p.y = (v->v).p.y;
  vertices_on_line(&p,dVar1,r,&np1,&np2);
  dVar1 = np1.x - (ref->v).p.x;
  dVar6 = np1.y - (ref->v).p.y;
  dVar5 = np2.x - (ref->v).p.x;
  dVar2 = np2.y - (ref->v).p.y;
  if (dVar1 * dVar1 + dVar6 * dVar6 < dVar5 * dVar5 + dVar2 * dVar2) {
    ptVar7 = new_temp_toporoutervertex(np1.x,np1.y,e);
    return ptVar7;
  }
  ptVar7 = new_temp_toporoutervertex(np2.x,np2.y,e);
  return ptVar7;
}



// WARNING: Removing unreachable block (ram,0x080e83e6)
// WARNING: Removing unreachable block (ram,0x080e83e2)
// WARNING: Unknown calling convention

GList * all_candidates_on_edge(toporouter_edge_t *e,toporouter_route_t *routedata)

{
  int *piVar1;
  toporouter_vertex_t *ptVar2;
  double dVar3;
  double dVar4;
  GtsObjectClass *pGVar5;
  toporouter_vertex_t *consv;
  toporouter_vertex_t *pv;
  toporouter_vertex_t *ptVar6;
  GList *pGVar7;
  GList *rval;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  GtsObjectClass *pGVar8;
  GList *i;
  undefined4 uVar9;
  toporouter_vertex_t *v;
  
  pGVar5 = (GtsObjectClass *)toporouter_edge_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar8 = (e->e).segment.object.klass;
    if (pGVar8 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar5 == pGVar8) {
          if ((*(byte *)&e->flags & 1) != 0) {
            return (GList *)0x0;
          }
          break;
        }
        pGVar8 = pGVar8->parent_class;
      } while (pGVar8 != (GtsObjectClass *)0x0);
    }
  }
  pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar8 = (e->e).segment.object.klass;
    if (pGVar8 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar5 == pGVar8) {
          if ((((*(int *)(e->flags + 0x40) != 7) &&
               (piVar1 = *(int **)(e->flags + 0x60), piVar1 != (int *)0x0)) &&
              ((toporouter_netlist_t *)piVar1[3] == routedata->src->netlist)) &&
             ((*piVar1 == routedata->dest->c || (*piVar1 == routedata->src->c)))) {
            ptVar6 = (toporouter_vertex_t *)(e->e).segment.v1;
            ptVar2 = (toporouter_vertex_t *)(e->e).segment.v2;
            dVar3 = (ptVar6->v).p.x - (ptVar2->v).p.x;
            dVar4 = (ptVar6->v).p.y - (ptVar2->v).p.y;
            new_temp_toporoutervertex_in_segment
                      (e,ptVar6,SQRT(dVar4 * dVar4 + dVar3 * dVar3) * 0.5,ptVar2);
            pGVar7 = (GList *)g_list_prepend();
            return pGVar7;
          }
          return (GList *)0x0;
        }
        pGVar8 = pGVar8->parent_class;
      } while (pGVar8 != (GtsObjectClass *)0x0);
    }
  }
  pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (toporouter_edge_t *)0x0) {
    pGVar8 = (e->e).segment.object.klass;
    if (pGVar8 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar5 == pGVar8) break;
        pGVar8 = pGVar8->parent_class;
      } while (pGVar8 != (GtsObjectClass *)0x0);
    }
  }
  pGVar7 = e->routing;
  ptVar6 = (toporouter_vertex_t *)(e->e).segment.v1;
  if (pGVar7 != (GList *)0x0) {
    uVar9 = 0;
    do {
      while (ptVar2 = (toporouter_vertex_t *)pGVar7->data, -1 < *(char *)&ptVar2->flags) {
        candidate_vertices(ptVar6,ptVar2,(toporouter_vertex_t *)routedata->destvertices->data,e);
        uVar9 = g_list_concat(uVar9);
        pGVar7 = (GList *)(&pGVar7->data)[1];
        ptVar6 = ptVar2;
        if (pGVar7 == (GList *)0x0) goto LAB_080e84fa;
      }
      pGVar7 = (GList *)(&pGVar7->data)[1];
    } while (pGVar7 != (GList *)0x0);
  }
LAB_080e84fa:
  candidate_vertices(ptVar6,(toporouter_vertex_t *)(e->e).segment.v2,
                     (toporouter_vertex_t *)routedata->destvertices->data,e);
  pGVar7 = (GList *)g_list_concat();
  return pGVar7;
}



// WARNING: Unknown calling convention

GList * triangle_all_candidate_points_from_vertex
                  (GtsTriangle *t,toporouter_vertex_t *v,toporouter_route_t *routedata)

{
  toporouter_edge_t *e;
  GList *pGVar1;
  
  e = (toporouter_edge_t *)gts_triangle_edge_opposite(t,&v->v);
  pGVar1 = all_candidates_on_edge(e,routedata);
  return pGVar1;
}



// WARNING: Unknown calling convention

GList * triangle_candidate_points_from_vertex
                  (GtsTriangle *t,toporouter_vertex_t *v,toporouter_vertex_t *dest,
                  toporouter_route_t *routedata)

{
  toporouter_vertex_t *ptVar1;
  toporouter_vertex_t *ptVar2;
  int iVar3;
  _toporouter_cluster_t *p_Var4;
  toporouter_edge_t *e;
  toporouter_edge_t *e_00;
  toporouter_edge_t *e_01;
  GtsObjectClass *pGVar5;
  GList *pGVar6;
  GList *i;
  toporouter_vertex_t *temp;
  toporouter_vertex_t *temp_1;
  toporouter_bbox_t *box;
  toporouter_constraint_class_t *klass;
  toporouter_vertex_t *ptVar7;
  GList *pGVar8;
  char *pcVar9;
  toporouter_vertex_t *vv2;
  toporouter_vertex_t *ptVar10;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar11;
  char *pcVar12;
  toporouter_edge_t *op_e;
  toporouter_vertex_t *temp_2;
  toporouter_vertex_t *vv1;
  gdouble gVar13;
  undefined4 local_24;
  toporouter_vertex_t *local_20;
  
  e = (toporouter_edge_t *)gts_triangle_edge_opposite(t,&v->v);
  e_00 = (toporouter_edge_t *)gts_vertices_are_connected(&v->v,(e->e).segment.v1);
  e_01 = (toporouter_edge_t *)gts_vertices_are_connected(&v->v,(e->e).segment.v2);
  pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    pGVar11 = (e->e).segment.object.klass;
    if (pGVar11 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar5 == pGVar11) {
          if (*(int *)(e->flags + 0x40) != 7) {
            iVar3 = *(int *)(e->flags + 0x60);
            pcVar12 = (char *)0x0;
            if (iVar3 != 0) {
              pcVar12 = *(char **)(*(int *)(iVar3 + 0xc) + 8);
            }
            if (((dest == (toporouter_vertex_t *)0x0) || (dest->bbox == (_toporouter_bbox_t *)0x0))
               || (p_Var4 = dest->bbox->cluster, p_Var4 == (_toporouter_cluster_t *)0x0)) {
              pcVar9 = (char *)0x0;
            }
            else {
              pcVar9 = p_Var4->netlist->netlist;
            }
            if (pcVar12 == pcVar9) {
              ptVar7 = (toporouter_vertex_t *)(e->e).segment.v2;
              gVar13 = gts_point_distance(&((e->e).segment.v1)->p,(GtsPoint *)ptVar7);
              local_20 = new_temp_toporoutervertex_in_segment
                                   (e,(toporouter_vertex_t *)(e->e).segment.v1,gVar13 * 0.5,ptVar7);
              goto LAB_080e8683;
            }
          }
          return (GList *)0x0;
        }
        pGVar11 = pGVar11->parent_class;
      } while (pGVar11 != (GtsObjectClass *)0x0);
    }
  }
  local_20 = (toporouter_vertex_t *)0x0;
LAB_080e8683:
  pGVar5 = (GtsObjectClass *)toporouter_edge_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    pGVar11 = (e->e).segment.object.klass;
    if (pGVar11 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar5 == pGVar11) {
          if ((*(byte *)&e->flags & 1) != 0) goto triangle_candidate_points_from_vertex_exit;
          break;
        }
        pGVar11 = pGVar11->parent_class;
      } while (pGVar11 != (GtsObjectClass *)0x0);
    }
  }
  if ((toporouter_vertex_t *)(e_00->e).segment.v1 == v) {
    pGVar6 = edge_routing_first_not_temp(e_00);
  }
  else {
    pGVar6 = edge_routing_last_not_temp(e_00);
  }
  if (pGVar6 == (GList *)0x0) {
    ptVar7 = (toporouter_vertex_t *)(e->e).segment.v1;
  }
  else {
    ptVar10 = (toporouter_vertex_t *)(e->e).segment.v2;
    ptVar7 = *(toporouter_vertex_t **)((int)pGVar6->data + 0x2c);
    if (((ptVar7 == ptVar10) ||
        (ptVar1 = *(toporouter_vertex_t **)((int)pGVar6->data + 0x30), ptVar10 == ptVar1)) ||
       ((ptVar7->routingedge != e && (ptVar7 = ptVar1, ptVar1->routingedge != e))))
    goto triangle_candidate_points_from_vertex_exit;
  }
  if ((toporouter_vertex_t *)(e_01->e).segment.v1 == v) {
    pGVar6 = edge_routing_first_not_temp(e_01);
  }
  else {
    pGVar6 = edge_routing_last_not_temp(e_01);
  }
  if (pGVar6 == (GList *)0x0) {
    ptVar10 = (toporouter_vertex_t *)(e->e).segment.v2;
  }
  else {
    ptVar1 = (toporouter_vertex_t *)(e->e).segment.v1;
    ptVar10 = *(toporouter_vertex_t **)((int)pGVar6->data + 0x2c);
    if (((ptVar10 == ptVar1) ||
        (ptVar2 = *(toporouter_vertex_t **)((int)pGVar6->data + 0x30), ptVar1 == ptVar2)) ||
       ((ptVar10->routingedge != e && (ptVar10 = ptVar2, ptVar2->routingedge != e)))) {
triangle_candidate_points_from_vertex_exit:
      if (local_20 != (toporouter_vertex_t *)0x0) {
        g_hash_table_insert(routedata->alltemppoints,local_20,local_20);
      }
      g_list_free(0);
      return (GList *)0x0;
    }
  }
  if (local_20 != (toporouter_vertex_t *)0x0) {
    pGVar6 = (GList *)g_list_prepend();
    return pGVar6;
  }
  klass = toporouter_constraint_class();
  gts_object_is_from_class(e,klass);
  pGVar6 = e->routing;
  local_24 = 0;
  for (; pGVar6 != (GList *)0x0; pGVar6 = (GList *)(&pGVar6->data)[1]) {
    ptVar1 = (toporouter_vertex_t *)pGVar6->data;
    if ((ptVar1->parent == v) || (ptVar1->child == v)) {
      pGVar8 = candidate_vertices(ptVar7,ptVar1,dest,e);
      local_24 = g_list_concat(local_24,pGVar8);
      ptVar7 = ptVar1;
    }
  }
  candidate_vertices(ptVar7,ptVar10,dest,e);
  pGVar6 = (GList *)g_list_concat();
  return pGVar6;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

gint space_edge(gpointer item,gpointer data)

{
  toporouter_vertex_t *ptVar1;
  toporouter_vertex_t **pptVar2;
  toporouter_vertex_t *v_00;
  GtsVertex *v_01;
  bool bVar3;
  GtsObjectClass *pGVar4;
  toporouter_constraint_class_t *ptVar5;
  int iVar6;
  double *__ptr;
  toporouter_vertex_t *ptVar7;
  toporouter_vertex_t *v;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *c_3;
  GtsObjectClass *c_2;
  GtsObjectClass *pGVar8;
  GList *i;
  GtsVertex *pGVar9;
  toporouter_vertex_t *v_1;
  double *pdVar10;
  gdouble d;
  gdouble ms;
  gdouble v1keepaway;
  gdouble gVar11;
  gdouble gVar12;
  double dVar13;
  gdouble gVar14;
  double dVar15;
  double local_4c;
  int local_38;
  
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (item != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar8 = *item;
    if (pGVar8 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar4 == pGVar8) {
          return 0;
        }
        pGVar8 = pGVar8->parent_class;
      } while (pGVar8 != (GtsObjectClass *)0x0);
    }
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (item != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar8 = *item;
    if (pGVar8 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar4 == pGVar8) break;
        pGVar8 = pGVar8->parent_class;
      } while (pGVar8 != (GtsObjectClass *)0x0);
    }
  }
  if (*(int *)((int)item + 0x1c) != 0) {
    ptVar5 = toporouter_constraint_class();
    gts_object_is_from_class(item,ptVar5);
    iVar6 = g_list_length(*(undefined4 *)((int)item + 0x1c));
    if (iVar6 != 0) {
      ptVar5 = toporouter_constraint_class();
      gts_object_is_from_class(item,ptVar5);
      iVar6 = g_list_length(*(undefined4 *)((int)item + 0x1c));
      __ptr = (double *)calloc(1,iVar6 << 3);
      local_38 = 0;
      do {
        pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (item != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
          pGVar8 = *item;
          if (pGVar8 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar4 == pGVar8) break;
              pGVar8 = pGVar8->parent_class;
            } while (pGVar8 != (GtsObjectClass *)0x0);
          }
        }
        pdVar10 = __ptr;
        for (ptVar1 = *(toporouter_vertex_t **)((int)item + 0x1c);
            ptVar1 != (toporouter_vertex_t *)0x0;
            ptVar1 = *(toporouter_vertex_t **)((int)&ptVar1->v + 4)) {
          pptVar2 = *(toporouter_vertex_t ***)((int)&ptVar1->v + 8);
          v_00 = *(toporouter_vertex_t **)&ptVar1->v;
          if (pptVar2 == (toporouter_vertex_t **)0x0) {
            ptVar7 = *(toporouter_vertex_t **)((int)item + 0xc);
            gVar11 = vertex_net_thickness(v_00);
            gVar12 = vertex_net_thickness(ptVar7);
            dVar13 = vertex_net_keepaway(v_00);
            gVar14 = vertex_net_keepaway(ptVar7);
            if (dVar13 <= gVar14) {
              dVar13 = gVar14;
            }
            dVar13 = gVar12 * 0.5 + gVar11 * 0.5 + dVar13;
            dVar15 = gts_point_distance(*(GtsPoint **)((int)item + 0xc),(GtsPoint *)v_00);
          }
          else {
            ptVar7 = *pptVar2;
            gVar11 = vertex_net_thickness(ptVar7);
            gVar12 = vertex_net_thickness(v_00);
            dVar13 = vertex_net_keepaway(ptVar7);
            gVar14 = vertex_net_keepaway(v_00);
            if (dVar13 <= gVar14) {
              dVar13 = gVar14;
            }
            dVar13 = gVar12 * 0.5 + gVar11 * 0.5 + dVar13;
            dVar15 = gts_point_distance(**(GtsPoint ***)((int)&ptVar1->v + 8),(GtsPoint *)v_00);
          }
          if (dVar15 < dVar13) {
            ptVar7 = *(toporouter_vertex_t **)((int)&ptVar1->v + 4);
            *pdVar10 = dVar13 - dVar15;
            if (ptVar7 == (toporouter_vertex_t *)0x0) goto LAB_080e8b9f;
LAB_080e8a8f:
            ptVar7 = *(toporouter_vertex_t **)&ptVar7->v;
            gVar11 = vertex_net_thickness(ptVar7);
            gVar12 = vertex_net_thickness(v_00);
            local_4c = vertex_net_keepaway(ptVar7);
            gVar14 = vertex_net_keepaway(v_00);
            if (local_4c <= gVar14) {
              local_4c = gVar14;
            }
            local_4c = gVar12 * 0.5 + gVar11 * 0.5 + local_4c;
            dVar13 = gts_point_distance(*(GtsPoint **)
                                         &(*(toporouter_vertex_t **)((int)&ptVar1->v + 4))->v,
                                        (GtsPoint *)v_00);
          }
          else {
            ptVar7 = *(toporouter_vertex_t **)((int)&ptVar1->v + 4);
            *pdVar10 = 0.0;
            if (ptVar7 != (toporouter_vertex_t *)0x0) goto LAB_080e8a8f;
LAB_080e8b9f:
            ptVar7 = *(toporouter_vertex_t **)((int)item + 0x10);
            gVar11 = vertex_net_thickness(v_00);
            gVar12 = vertex_net_thickness(ptVar7);
            local_4c = vertex_net_keepaway(v_00);
            gVar14 = vertex_net_keepaway(ptVar7);
            if (local_4c <= gVar14) {
              local_4c = gVar14;
            }
            local_4c = gVar12 * 0.5 + gVar11 * 0.5 + local_4c;
            dVar13 = gts_point_distance(*(GtsPoint **)((int)item + 0x10),(GtsPoint *)v_00);
          }
          if (dVar13 < local_4c) {
            *pdVar10 = (dVar13 - local_4c) + *pdVar10;
          }
          pdVar10 = pdVar10 + 1;
        }
        pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (item != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
          pGVar8 = *item;
          if (pGVar8 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar4 == pGVar8) break;
              pGVar8 = pGVar8->parent_class;
            } while (pGVar8 != (GtsObjectClass *)0x0);
          }
        }
        pGVar9 = *(GtsVertex **)((int)item + 0x1c);
        if (pGVar9 == (GtsVertex *)0x0) {
LAB_080e8d59:
          free(__ptr);
          return 0;
        }
        bVar3 = true;
        pdVar10 = __ptr;
        do {
          dVar13 = *pdVar10;
          v_01 = *(GtsVertex **)&pGVar9->p;
          if ((9.999999747378752e-05 < dVar13) || (dVar13 < -9.999999747378752e-05)) {
            bVar3 = false;
          }
          pdVar10 = pdVar10 + 1;
          vertex_move_towards_vertex_values
                    (v_01,*(GtsVertex **)((int)item + 0x10),dVar13 * 0.1,&(v_01->p).x,&(v_01->p).y);
          pGVar9 = *(GtsVertex **)((int)&pGVar9->p + 4);
        } while (pGVar9 != (GtsVertex *)0x0);
        if ((bVar3) || (local_38 = local_38 + 1, local_38 == 100)) goto LAB_080e8d59;
      } while( true );
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

guint check_triangle_interior_capacity
                (GtsTriangle *t,toporouter_vertex_t *v,toporouter_vertex_t *curpoint,
                toporouter_edge_t *op_edge,toporouter_edge_t *adj_edge1,toporouter_edge_t *adj_edge2
                )

{
  GtsObjectClass *pGVar1;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar2;
  gdouble gVar3;
  gdouble gVar4;
  
  gVar3 = triangle_interior_capacity(t,v);
  gVar4 = flow_from_edge_to_edge(t,adj_edge1,adj_edge2,v,curpoint);
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (adj_edge1 != (toporouter_edge_t *)0x0) {
    pGVar2 = (adj_edge1->e).segment.object.klass;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar2) {
          return 1;
        }
        pGVar2 = pGVar2->parent_class;
      } while (pGVar2 != (GtsObjectClass *)0x0);
    }
  }
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (adj_edge2 != (toporouter_edge_t *)0x0) {
    pGVar2 = (adj_edge2->e).segment.object.klass;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar1 == pGVar2) {
          return 1;
        }
        pGVar2 = pGVar2->parent_class;
      } while (pGVar2 != (GtsObjectClass *)0x0);
    }
  }
  return (uint)(gVar4 <= gVar3);
}



// WARNING: Unknown calling convention

GList * triangle_candidate_points_from_edge
                  (toporouter_t *r,GtsTriangle *t,toporouter_edge_t *e,toporouter_vertex_t *v,
                  toporouter_vertex_t **dest,toporouter_route_t *routedata)

{
  bool bVar1;
  toporouter_vertex_t *ptVar2;
  toporouter_vertex_t *ptVar3;
  int *piVar4;
  GtsVertex *pGVar5;
  _toporouter_vertex_t *p_Var6;
  toporouter_edge_t *ptVar7;
  bool bVar8;
  _toporouter_vertex_t *p_Var9;
  toporouter_edge_t *e_00;
  toporouter_edge_t *e_01;
  GtsObjectClass *pGVar10;
  toporouter_vertex_t *temp;
  guint gVar11;
  undefined4 uVar12;
  toporouter_vertex_t *temp_1;
  toporouter_constraint_class_t *ptVar13;
  int iVar14;
  toporouter_edge_class_t *klass;
  gpointer pvVar15;
  toporouter_vertex_t *ptVar16;
  toporouter_vertex_t *vv2;
  toporouter_vertex_t *vv;
  toporouter_vertex_t *vv1_1;
  toporouter_vertex_t *vv1;
  _toporouter_vertex_t *p_Var17;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  guint noe2;
  GtsObjectClass *c_2;
  GtsObjectClass *c_3;
  GtsObjectClass *c_4;
  GtsObjectClass *pGVar18;
  GList *i_1;
  GList *i;
  GList *e1cands;
  GList *pGVar19;
  bool bVar20;
  bool bVar21;
  bool bVar22;
  bool bVar23;
  bool bVar24;
  gdouble gVar25;
  undefined4 local_5c;
  toporouter_vertex_t *local_48;
  toporouter_vertex_t *local_40;
  toporouter_vertex_t *local_3c;
  GList *local_34;
  toporouter_vertex_t *local_2c;
  toporouter_vertex_t *local_28;
  toporouter_vertex_t *local_24;
  toporouter_vertex_t *local_20 [4];
  
  p_Var9 = (_toporouter_vertex_t *)gts_triangle_vertex_opposite(t,&e->e);
  e_00 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)p_Var9,(e->e).segment.v1);
  e_01 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)p_Var9,(e->e).segment.v2);
  if (*dest == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xec6,"triangle_candidate_points_from_edge","*dest");
  }
  edge_adjacent_vertices(e,v,local_20,&local_24);
  pGVar10 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar10 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e_00 != (toporouter_edge_t *)0x0) {
    pGVar18 = (e_00->e).segment.object.klass;
    if (pGVar18 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar10 == pGVar18) {
          pGVar10 = (GtsObjectClass *)toporouter_constraint_class();
          if (pGVar10 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else {
            pGVar18 = (e_00->e).segment.object.klass;
            if (pGVar18 != (GtsObjectClass *)0x0) goto LAB_080e9052;
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          goto LAB_080e9056;
        }
        pGVar18 = pGVar18->parent_class;
      } while (pGVar18 != (GtsObjectClass *)0x0);
    }
  }
  pGVar10 = (GtsObjectClass *)toporouter_edge_class();
  if (pGVar10 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e_00 != (toporouter_edge_t *)0x0) {
    pGVar18 = (e_00->e).segment.object.klass;
    if (pGVar18 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar10 == pGVar18) {
          bVar23 = true;
          if ((*(byte *)&e_00->flags & 1) != 0) goto LAB_080e935b;
          break;
        }
        pGVar18 = pGVar18->parent_class;
      } while (pGVar18 != (GtsObjectClass *)0x0);
    }
  }
  ptVar16 = (toporouter_vertex_t *)(e->e).segment.v1;
  if (ptVar16 != local_20[0]) {
    p_Var17 = local_20[0]->parent;
    if ((p_Var17 == p_Var9) || (p_Var6 = local_20[0]->child, p_Var6 == p_Var9)) {
LAB_080e9852:
      bVar24 = false;
      bVar23 = false;
      local_40 = (toporouter_vertex_t *)0x0;
      goto LAB_080e96fb;
    }
    if (p_Var17->routingedge == e_00) {
      if ((_toporouter_vertex_t *)(e_00->e).segment.v1 == p_Var9) {
        ptVar13 = toporouter_constraint_class();
        gts_object_is_from_class(e_00,ptVar13);
        iVar14 = g_list_find(e_00->routing,p_Var17);
        local_3c = edge_routing_prev_not_temp(e_00,*(GList **)(iVar14 + 8));
      }
      else {
        ptVar13 = toporouter_constraint_class();
        gts_object_is_from_class(e_00,ptVar13);
        iVar14 = g_list_find(e_00->routing,p_Var17);
        local_3c = edge_routing_next_not_temp(e_00,*(GList **)(iVar14 + 4));
      }
LAB_080e9535:
      if (local_3c != (toporouter_vertex_t *)0x0) {
        bVar22 = true;
        p_Var6 = (_toporouter_vertex_t *)(e->e).segment.v2;
        if (local_3c->parent != p_Var6) {
          bVar22 = p_Var6 == local_3c->child;
        }
        e1cands = candidate_vertices(p_Var17,local_3c,*dest,e_00);
        bVar23 = local_3c == p_Var9;
        ptVar16 = local_3c;
        goto LAB_080e9588;
      }
      goto LAB_080e9852;
    }
    bVar23 = false;
    if (p_Var6->routingedge == e_00) {
      p_Var17 = p_Var6;
      if ((_toporouter_vertex_t *)(e_00->e).segment.v1 == p_Var9) {
        ptVar13 = toporouter_constraint_class();
        gts_object_is_from_class(e_00,ptVar13);
        iVar14 = g_list_find(e_00->routing,p_Var6);
        local_3c = edge_routing_prev_not_temp(e_00,*(GList **)(iVar14 + 8));
      }
      else {
        ptVar13 = toporouter_constraint_class();
        gts_object_is_from_class(e_00,ptVar13);
        iVar14 = g_list_find(e_00->routing,p_Var6);
        local_3c = edge_routing_next_not_temp(e_00,*(GList **)(iVar14 + 4));
      }
      goto LAB_080e9535;
    }
LAB_080e935b:
    bVar24 = false;
    e1cands = (GList *)0x0;
    local_5c = 0;
    local_40 = (toporouter_vertex_t *)0x0;
    goto LAB_080e936f;
  }
  edge_adjacent_vertices(e_00,ptVar16,&local_2c,&local_28);
  ptVar16 = local_2c;
  if (local_2c == (toporouter_vertex_t *)0x0) {
    ptVar16 = local_28;
  }
  e1cands = candidate_vertices(local_20[0],ptVar16,*dest,e_00);
  if (ptVar16 == p_Var9) {
    bVar23 = true;
    bVar22 = false;
LAB_080e9588:
    if ((ptVar16 == (toporouter_vertex_t *)0x0) || (!bVar23)) goto triangle_candidate_points_e2;
    if (p_Var9->bbox == (_toporouter_bbox_t *)0x0) {
      local_3c = (toporouter_vertex_t *)0x0;
    }
    else {
      local_3c = (toporouter_vertex_t *)p_Var9->bbox->point;
    }
    iVar14 = g_list_find(routedata->destvertices,ptVar16);
    if (iVar14 == 0) {
      iVar14 = g_list_find(routedata->destvertices,local_3c);
      if (iVar14 == 0) {
        iVar14 = g_list_find(routedata->srcvertices,ptVar16);
        if (iVar14 == 0) goto triangle_candidate_points_e2;
        local_5c = g_list_prepend(0,ptVar16);
        bVar24 = false;
        bVar23 = false;
        local_40 = (toporouter_vertex_t *)0x0;
      }
      else {
        bVar24 = false;
        bVar23 = false;
        local_5c = 0;
        *dest = local_3c;
        local_40 = (toporouter_vertex_t *)0x0;
      }
    }
    else {
      local_5c = g_list_prepend(0,ptVar16);
      bVar24 = false;
      bVar23 = false;
      local_40 = (toporouter_vertex_t *)0x0;
      *dest = ptVar16;
    }
  }
  else {
    p_Var17 = (_toporouter_vertex_t *)(e->e).segment.v2;
    bVar22 = true;
    if (ptVar16->parent != p_Var17) {
      bVar22 = p_Var17 == ptVar16->child;
    }
triangle_candidate_points_e2:
    bVar24 = false;
    bVar23 = false;
    local_5c = 0;
    local_40 = (toporouter_vertex_t *)0x0;
  }
LAB_080e90ce:
  if (!bVar22) {
    bVar24 = local_40 != (toporouter_vertex_t *)0x0;
    goto LAB_080e936f;
  }
  bVar20 = local_40 != (toporouter_vertex_t *)0x0;
  bVar22 = !bVar23;
LAB_080e90e7:
  bVar20 = (bool)(bVar20 & bVar22);
  bVar1 = false;
  bVar21 = false;
  bVar22 = true;
  local_34 = (GList *)0x0;
  local_48 = (toporouter_vertex_t *)0x0;
  bVar8 = true;
  goto LAB_080e910e;
  while (pGVar18 = pGVar18->parent_class, pGVar18 != (GtsObjectClass *)0x0) {
LAB_080e9052:
    if (pGVar10 == pGVar18) break;
  }
LAB_080e9056:
  e1cands = e_00->routing;
  if ((((*(int *)(e_00->flags + 0x40) == 7) ||
       (piVar4 = *(int **)(e_00->flags + 0x60), piVar4 == (int *)0x0)) ||
      ((toporouter_netlist_t *)piVar4[3] != routedata->src->netlist)) ||
     ((*piVar4 != routedata->dest->c && (*piVar4 != routedata->src->c)))) {
    bVar23 = true;
    local_40 = (toporouter_vertex_t *)0x0;
  }
  else if ((((toporouter_vertex_t *)(e->e).segment.v1 == local_20[0]) ||
           ((ptVar7 = local_20[0]->parent->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
            (e_00 == ptVar7)))) ||
          ((ptVar7 = local_20[0]->child->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
           (e_00 == ptVar7)))) {
    ptVar16 = (toporouter_vertex_t *)(e_00->e).segment.v2;
    gVar25 = gts_point_distance(&((e_00->e).segment.v1)->p,(GtsPoint *)ptVar16);
    local_40 = new_temp_toporoutervertex_in_segment
                         (e_00,(toporouter_vertex_t *)(e_00->e).segment.v1,gVar25 * 0.5,ptVar16);
    bVar23 = false;
  }
  else {
    bVar23 = false;
    local_40 = (toporouter_vertex_t *)0x0;
  }
  if (e1cands != (GList *)0x0) {
    pGVar5 = (e->e).segment.v2;
    bVar22 = false;
    do {
      while ((pvVar15 = e1cands->data, *(GtsVertex **)((int)pvVar15 + 0x30) == pGVar5 ||
             (*(GtsVertex **)((int)pvVar15 + 0x2c) == pGVar5))) {
        e1cands = e1cands->next;
        if (-1 < *(char *)((int)pvVar15 + 0x38)) {
          bVar22 = true;
        }
        if (e1cands == (GList *)0x0) goto LAB_080e90be;
      }
      e1cands = e1cands->next;
    } while (e1cands != (GList *)0x0);
LAB_080e90be:
    local_5c = 0;
    bVar24 = local_40 != (toporouter_vertex_t *)0x0;
    goto LAB_080e90ce;
  }
  bVar24 = local_40 != (toporouter_vertex_t *)0x0;
LAB_080e96fb:
  local_5c = 0;
  e1cands = (GList *)0x0;
LAB_080e936f:
  pGVar10 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar10 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e_01 != (toporouter_edge_t *)0x0) {
    pGVar18 = (e_01->e).segment.object.klass;
    if (pGVar18 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar10 == pGVar18) {
          pGVar10 = (GtsObjectClass *)toporouter_constraint_class();
          if (pGVar10 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else {
            pGVar18 = (e_01->e).segment.object.klass;
            if (pGVar18 != (GtsObjectClass *)0x0) goto LAB_080e93cf;
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          goto LAB_080e93d3;
        }
        pGVar18 = pGVar18->parent_class;
      } while (pGVar18 != (GtsObjectClass *)0x0);
    }
  }
  klass = toporouter_edge_class();
  pvVar15 = gts_object_is_from_class(e_01,klass);
  if ((pvVar15 != (gpointer)0x0) && ((*(byte *)&e_01->flags & 1) != 0)) {
    bVar20 = !bVar23;
    bVar22 = local_40 != (toporouter_vertex_t *)0x0;
    goto LAB_080e90e7;
  }
  bVar8 = bVar23;
  if ((toporouter_vertex_t *)(e->e).segment.v2 == local_24) {
    local_28 = (toporouter_vertex_t *)0x0;
    local_2c = (toporouter_vertex_t *)0x0;
    edge_adjacent_vertices(e_01,local_24,&local_28,&local_2c);
    ptVar16 = local_28;
    if (local_28 == (toporouter_vertex_t *)0x0) {
      ptVar16 = local_2c;
    }
    local_34 = candidate_vertices(local_24,ptVar16,*dest,e_01);
    if (ptVar16 == p_Var9) {
      bVar1 = false;
      bVar21 = false;
      bVar22 = false;
      local_48 = (toporouter_vertex_t *)0x0;
      bVar20 = local_40 != (toporouter_vertex_t *)0x0 && !bVar23;
    }
    else {
      p_Var9 = (_toporouter_vertex_t *)(e->e).segment.v1;
      if ((ptVar16->parent == p_Var9) || (p_Var9 == ptVar16->child)) {
        bVar1 = false;
        bVar21 = false;
        bVar20 = false;
        bVar22 = false;
        bVar23 = true;
        local_48 = (toporouter_vertex_t *)0x0;
        bVar8 = true;
      }
      else {
        bVar1 = false;
        bVar21 = false;
        bVar22 = false;
        bVar20 = local_40 != (toporouter_vertex_t *)0x0 && !bVar23;
        local_48 = (toporouter_vertex_t *)0x0;
      }
    }
  }
  else {
    p_Var17 = local_24->parent;
    if ((p_Var17 == p_Var9) || (p_Var6 = local_24->child, p_Var6 == p_Var9)) {
      bVar20 = !bVar23 && local_40 != (toporouter_vertex_t *)0x0;
    }
    else {
      if (p_Var17->routingedge == e_01) {
        if ((_toporouter_vertex_t *)(e_01->e).segment.v1 == p_Var9) {
          ptVar13 = toporouter_constraint_class();
          gts_object_is_from_class(e_01,ptVar13);
          iVar14 = g_list_find(e_01->routing,p_Var17);
          ptVar16 = edge_routing_prev_not_temp(e_01,*(GList **)(iVar14 + 8));
        }
        else {
          ptVar13 = toporouter_constraint_class();
          gts_object_is_from_class(e_01,ptVar13);
          iVar14 = g_list_find(e_01->routing,p_Var17);
          ptVar16 = edge_routing_next_not_temp(e_01,*(GList **)(iVar14 + 4));
        }
      }
      else {
        if (p_Var6->routingedge != e_01) {
          bVar20 = !bVar23 && local_40 != (toporouter_vertex_t *)0x0;
          goto LAB_080e99c4;
        }
        p_Var17 = p_Var6;
        if ((_toporouter_vertex_t *)(e_01->e).segment.v1 == p_Var9) {
          ptVar13 = toporouter_constraint_class();
          gts_object_is_from_class(e_01,ptVar13);
          iVar14 = g_list_find(e_01->routing,p_Var6);
          ptVar16 = edge_routing_prev_not_temp(e_01,*(GList **)(iVar14 + 8));
        }
        else {
          ptVar13 = toporouter_constraint_class();
          gts_object_is_from_class(e_01,ptVar13);
          iVar14 = g_list_find(e_01->routing,p_Var6);
          ptVar16 = edge_routing_next_not_temp(e_01,*(GList **)(iVar14 + 4));
        }
      }
      if (ptVar16 != (toporouter_vertex_t *)0x0) {
        p_Var9 = (_toporouter_vertex_t *)(e->e).segment.v1;
        if ((ptVar16->parent == p_Var9) || (p_Var9 == ptVar16->child)) {
          bVar23 = true;
        }
        local_34 = candidate_vertices(p_Var17,ptVar16,*dest,e_01);
        bVar1 = false;
        bVar21 = false;
        bVar22 = false;
        bVar20 = !bVar23 && local_40 != (toporouter_vertex_t *)0x0;
        local_48 = (toporouter_vertex_t *)0x0;
        bVar8 = bVar23;
        goto LAB_080e910e;
      }
      bVar20 = !bVar23 && local_40 != (toporouter_vertex_t *)0x0;
    }
LAB_080e99c4:
    bVar1 = false;
    bVar21 = false;
    bVar22 = false;
    local_34 = (GList *)0x0;
    local_48 = (toporouter_vertex_t *)0x0;
  }
  goto LAB_080e910e;
  while (pGVar18 = pGVar18->parent_class, pGVar18 != (GtsObjectClass *)0x0) {
LAB_080e93cf:
    if (pGVar10 == pGVar18) break;
  }
LAB_080e93d3:
  pGVar19 = e_01->routing;
  if (((*(int *)(e_01->flags + 0x40) == 7) ||
      (piVar4 = *(int **)(e_01->flags + 0x60), piVar4 == (int *)0x0)) ||
     ((toporouter_netlist_t *)piVar4[3] != routedata->src->netlist)) {
LAB_080e9404:
    bVar22 = true;
    local_48 = (toporouter_vertex_t *)0x0;
  }
  else {
    if ((*piVar4 != routedata->dest->c) && (*piVar4 != routedata->src->c)) goto LAB_080e9404;
    if ((((toporouter_vertex_t *)(e->e).segment.v2 == local_24) ||
        ((ptVar7 = local_24->parent->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
         (e_01 == ptVar7)))) ||
       ((ptVar7 = local_24->child->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
        (e_01 == ptVar7)))) {
      ptVar16 = (toporouter_vertex_t *)(e_01->e).segment.v2;
      gVar25 = gts_point_distance(&((e_01->e).segment.v1)->p,(GtsPoint *)ptVar16);
      local_48 = new_temp_toporoutervertex_in_segment
                           (e_01,(toporouter_vertex_t *)(e_01->e).segment.v1,gVar25 * 0.5,ptVar16);
      bVar22 = false;
    }
    else {
      bVar22 = false;
      local_48 = (toporouter_vertex_t *)0x0;
    }
  }
  if (pGVar19 == (GList *)0x0) {
    local_34 = (GList *)0x0;
    bVar20 = local_40 != (toporouter_vertex_t *)0x0 && !bVar23;
    bVar21 = local_48 != (toporouter_vertex_t *)0x0;
    bVar8 = (bool)(bVar22 | bVar23);
    bVar1 = !bVar22 && bVar21;
  }
  else {
    pGVar5 = (e->e).segment.v1;
    do {
      while ((pvVar15 = pGVar19->data, *(GtsVertex **)((int)pvVar15 + 0x30) == pGVar5 ||
             (*(GtsVertex **)((int)pvVar15 + 0x2c) == pGVar5))) {
        pGVar19 = pGVar19->next;
        bVar1 = true;
        if (*(char *)((int)pvVar15 + 0x38) < '\0') {
          bVar1 = bVar23;
        }
        bVar23 = bVar1;
        if (pGVar19 == (GList *)0x0) goto LAB_080e9452;
      }
      pGVar19 = pGVar19->next;
    } while (pGVar19 != (GList *)0x0);
LAB_080e9452:
    local_34 = (GList *)0x0;
    bVar20 = !bVar23 && local_40 != (toporouter_vertex_t *)0x0;
    bVar21 = local_48 != (toporouter_vertex_t *)0x0;
    bVar8 = (bool)(bVar23 | bVar22);
    bVar1 = !bVar22 && bVar21;
  }
LAB_080e910e:
  if (e_00 == (toporouter_edge_t *)0x0) {
LAB_080e913b:
    local_20[0] = (toporouter_vertex_t *)0x0;
  }
  else {
    ptVar16 = (toporouter_vertex_t *)(e->e).segment.v1;
    ptVar2 = (toporouter_vertex_t *)(e_00->e).segment.v1;
    local_20[0] = ptVar16;
    if ((((ptVar16 != ptVar2) &&
         (ptVar3 = (toporouter_vertex_t *)(e->e).segment.v2, local_20[0] = ptVar2, ptVar2 != ptVar3)
         ) && (ptVar2 = (toporouter_vertex_t *)(e_00->e).segment.v2, local_20[0] = ptVar16,
              ptVar16 != ptVar2)) && (local_20[0] = ptVar3, ptVar3 != ptVar2)) goto LAB_080e913b;
  }
  if (e_01 == (toporouter_edge_t *)0x0) {
LAB_080e9180:
    local_24 = (toporouter_vertex_t *)0x0;
  }
  else {
    ptVar16 = (toporouter_vertex_t *)(e->e).segment.v1;
    ptVar2 = (toporouter_vertex_t *)(e_01->e).segment.v1;
    local_24 = ptVar16;
    if (ptVar16 != ptVar2) {
      ptVar3 = (toporouter_vertex_t *)(e->e).segment.v2;
      local_24 = ptVar2;
      if (((ptVar2 != ptVar3) &&
          (ptVar2 = (toporouter_vertex_t *)(e_01->e).segment.v2, local_24 = ptVar16,
          ptVar16 != ptVar2)) && (local_24 = ptVar3, ptVar3 != ptVar2)) goto LAB_080e9180;
    }
  }
  if (bVar23) {
LAB_080e91b5:
    routedata_insert_temppoints(routedata,e1cands);
    pGVar19 = (GList *)0x0;
    g_list_free(e1cands);
  }
  else {
    gVar11 = check_triangle_interior_capacity(t,local_20[0],v,e_01,e,e_00);
    pGVar19 = e1cands;
    if (gVar11 == 0) goto LAB_080e91b5;
  }
  if (!bVar22) {
    gVar11 = check_triangle_interior_capacity(t,local_24,v,e_00,e,e_01);
    if (gVar11 != 0) goto LAB_080e9225;
  }
  routedata_insert_temppoints(routedata,local_34);
  g_list_free(local_34);
  local_34 = (GList *)0x0;
LAB_080e9225:
  if (bVar20) {
    pGVar19 = (GList *)g_list_prepend(pGVar19,local_40);
  }
  else if (bVar24) {
    g_hash_table_insert(routedata->alltemppoints,local_40,local_40);
  }
  if (bVar1) {
    local_34 = (GList *)g_list_prepend(local_34,local_48);
  }
  else if (bVar21) {
    g_hash_table_insert(routedata->alltemppoints,local_48,local_48);
  }
  if (bVar8) {
    pGVar19 = (GList *)g_list_concat(pGVar19,local_34);
    return pGVar19;
  }
  uVar12 = g_list_concat(pGVar19,local_34);
  pGVar19 = (GList *)g_list_concat(local_5c,uVar12);
  return pGVar19;
}



// WARNING: Unknown calling convention

GList * triangle_all_candidate_points_from_edge
                  (toporouter_t *r,GtsTriangle *t,toporouter_edge_t *e,toporouter_route_t *routedata
                  ,toporouter_vertex_t **dest,toporouter_vertex_t *curpoint)

{
  toporouter_vertex_t *v1;
  int iVar1;
  GList *pGVar2;
  toporouter_edge_t *e_00;
  toporouter_edge_t *e_01;
  int *piVar3;
  guint gVar4;
  guint gVar5;
  toporouter_edge_t *ptVar6;
  GtsObjectClass *pGVar7;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar8;
  undefined4 uVar9;
  GList *rval;
  toporouter_edge_t *e2;
  toporouter_vertex_t *v;
  GList *i;
  int *piVar10;
  toporouter_vertex_t *boxpoint;
  toporouter_edge_t *e1;
  char *pcVar11;
  GList *local_20;
  
  v1 = (toporouter_vertex_t *)gts_triangle_vertex_opposite(t,&e->e);
  if ((v1 == (toporouter_vertex_t *)0x0) || (v1->bbox == (_toporouter_bbox_t *)0x0)) {
    boxpoint = (toporouter_vertex_t *)0x0;
  }
  else {
    boxpoint = (toporouter_vertex_t *)v1->bbox->point;
  }
  iVar1 = g_list_find(routedata->destvertices,v1);
  if (iVar1 != 0) {
    pGVar2 = (GList *)g_list_prepend(0,v1);
    *dest = v1;
    return pGVar2;
  }
  iVar1 = g_list_find(routedata->destvertices,boxpoint);
  if (iVar1 == 0) {
    iVar1 = g_list_find(routedata->srcvertices,v1);
    uVar9 = 0;
    if (iVar1 != 0) {
      uVar9 = g_list_prepend(0,v1);
    }
  }
  else {
    uVar9 = 0;
    *dest = boxpoint;
  }
  e_00 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v1,(e->e).segment.v1);
  e_01 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v1,(e->e).segment.v2);
  pGVar2 = all_candidates_on_edge(e_00,routedata);
  uVar9 = g_list_concat(uVar9,pGVar2);
  pGVar2 = all_candidates_on_edge(e_01,routedata);
  piVar3 = (int *)g_list_concat(uVar9,pGVar2);
  gVar4 = check_triangle_interior_capacity
                    (t,(toporouter_vertex_t *)(e->e).segment.v1,curpoint,e_01,e,e_00);
  gVar5 = check_triangle_interior_capacity
                    (t,(toporouter_vertex_t *)(e->e).segment.v2,curpoint,e_00,e,e_01);
  local_20 = (GList *)0x0;
  piVar10 = piVar3;
  if (piVar3 == (int *)0x0) {
    local_20 = (GList *)0x0;
  }
  else {
    do {
      iVar1 = *piVar10;
      ptVar6 = *(toporouter_edge_t **)(iVar1 + 0x34);
      if (ptVar6 == (toporouter_edge_t *)0x0) {
LAB_080ea028:
        local_20 = (GList *)g_list_prepend(local_20,iVar1);
      }
      else {
        if (e_00 == ptVar6) {
          pGVar7 = (GtsObjectClass *)toporouter_constraint_class();
          if (pGVar7 == (GtsObjectClass *)0x0) {
            pcVar11 = "klass != NULL";
LAB_080ea0d7:
            g_return_if_fail_warning(0,"gts_object_is_from_class",pcVar11);
          }
          else {
            pGVar8 = (e_00->e).segment.object.klass;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              pcVar11 = "c != NULL";
              goto LAB_080ea0d7;
            }
            do {
              if (pGVar7 == pGVar8) goto LAB_080ea028;
              pGVar8 = pGVar8->parent_class;
            } while (pGVar8 != (GtsObjectClass *)0x0);
          }
          if (gVar4 != 0) goto LAB_080ea028;
          ptVar6 = *(toporouter_edge_t **)(iVar1 + 0x34);
        }
        if (e_01 == ptVar6) {
          pGVar7 = (GtsObjectClass *)toporouter_constraint_class();
          if (pGVar7 == (GtsObjectClass *)0x0) {
            pcVar11 = "klass != NULL";
LAB_080ea002:
            g_return_if_fail_warning(0,"gts_object_is_from_class",pcVar11);
          }
          else if (e_01 != (toporouter_edge_t *)0x0) {
            pGVar8 = (e_01->e).segment.object.klass;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              pcVar11 = "c != NULL";
              goto LAB_080ea002;
            }
            do {
              if (pGVar7 == pGVar8) goto LAB_080ea028;
              pGVar8 = pGVar8->parent_class;
            } while (pGVar8 != (GtsObjectClass *)0x0);
          }
          if (gVar5 != 0) goto LAB_080ea028;
        }
      }
      piVar10 = (int *)piVar10[1];
    } while (piVar10 != (int *)0x0);
  }
  g_list_free(piVar3);
  return local_20;
}



// WARNING: Removing unreachable block (ram,0x080ea4a4)
// WARNING: Unknown calling convention

GList * compute_candidate_points
                  (toporouter_t *tr,toporouter_layer_t *l,toporouter_vertex_t *curpoint,
                  toporouter_route_t *data,toporouter_vertex_t **closestdest)

{
  double dVar1;
  double dVar2;
  toporouter_edge_t *e;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  gpointer pvVar5;
  gpointer *ppvVar6;
  GList *i;
  GtsSegment *pGVar7;
  toporouter_edge_t *tempedge;
  GtsObjectClass *pGVar8;
  int prevwind;
  GSList *pGVar9;
  GSList *i_2;
  GtsTriangle *t;
  GList *temppoints;
  GList *pGVar10;
  int iVar11;
  GtsVertex *pGVar12;
  GtsVertex *oppv;
  int iVar13;
  GtsObjectClass *c;
  GtsObjectClass *pGVar14;
  GSList *i_1;
  GSList *pGVar15;
  toporouter_edge_t *edge;
  GList *r;
  GList *j;
  gdouble rval;
  char *pcVar16;
  GList *local_20;
  
  pGVar10 = tr->keepoutlayers;
  e = curpoint->routingedge;
  if (pGVar10 == (GList *)0x0) {
LAB_080ea1ab:
    pGVar7 = gts_vertices_are_connected(&curpoint->v,&(*closestdest)->v);
    if (pGVar7 != (GtsSegment *)0x0) {
      pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar8 == (GtsObjectClass *)0x0) {
        pcVar16 = "klass != NULL";
LAB_080ea453:
        g_return_if_fail_warning(0,"gts_object_is_from_class",pcVar16);
      }
      else {
        pGVar14 = (pGVar7->object).klass;
        if (pGVar14 == (GtsObjectClass *)0x0) {
          pcVar16 = "c != NULL";
          goto LAB_080ea453;
        }
        do {
          if (pGVar8 == pGVar14) goto compute_candidate_points_finish;
          pGVar14 = pGVar14->parent_class;
        } while (pGVar14 != (GtsObjectClass *)0x0);
      }
      if (pGVar7[1].object.flags == 0) {
        r = (GList *)g_list_prepend(0,*closestdest);
        ppvVar6 = &pGVar7[1].object.reserved;
        *ppvVar6 = (gpointer)((uint)*ppvVar6 | 1);
        goto LAB_080ea20a;
      }
    }
    if (-1 < *(char *)&curpoint->flags) {
      r = (GList *)0x0;
      pGVar9 = gts_vertex_triangles(&curpoint->v,(GSList *)0x0);
      pGVar15 = pGVar9;
      if (pGVar9 == (GSList *)0x0) {
        r = (GList *)0x0;
      }
      else {
        do {
          if ((*(byte *)&tr->flags & 0x20) == 0) {
            pGVar10 = triangle_candidate_points_from_vertex
                                ((GtsTriangle *)pGVar15->data,curpoint,*closestdest,data);
          }
          else {
            pGVar10 = triangle_all_candidate_points_from_vertex
                                ((GtsTriangle *)pGVar15->data,curpoint,data);
          }
          routedata_insert_temppoints(data,pGVar10);
          r = (GList *)g_list_concat(r,pGVar10);
          ppvVar6 = &pGVar15->data;
          pGVar15 = (GSList *)ppvVar6[1];
        } while ((GSList *)ppvVar6[1] != (GSList *)0x0);
      }
      g_slist_free(pGVar9);
      goto LAB_080ea20a;
    }
    pGVar3 = (e->e).segment.v2;
    pGVar4 = (e->e).segment.v1;
    dVar1 = (pGVar3->p).x;
    dVar2 = (pGVar3->p).y;
    iVar11 = 1;
    dVar1 = ((curpoint->parent->v).p.y - dVar2) * (dVar1 - (pGVar4->p).x) -
            ((curpoint->parent->v).p.x - dVar1) * (dVar2 - (pGVar4->p).y);
    if (dVar1 <= 9.999999747378752e-05) {
      iVar11 = (-9.999999747378752e-05 <= dVar1) - 1;
    }
    for (pGVar15 = (e->e).triangles; pGVar15 != (GSList *)0x0; pGVar15 = pGVar15->next) {
      pGVar12 = gts_triangle_vertex_opposite((GtsTriangle *)pGVar15->data,&e->e);
      pGVar3 = (e->e).segment.v2;
      pGVar4 = (e->e).segment.v1;
      dVar1 = (pGVar3->p).x;
      dVar2 = (pGVar3->p).y;
      iVar13 = 1;
      dVar1 = ((pGVar12->p).y - dVar2) * (dVar1 - (pGVar4->p).x) -
              ((pGVar12->p).x - dVar1) * (dVar2 - (pGVar4->p).y);
      if (dVar1 <= 9.999999747378752e-05) {
        iVar13 = (-9.999999747378752e-05 <= dVar1) - 1;
      }
      if (iVar11 != iVar13) {
        if ((*(byte *)&tr->flags & 0x20) == 0) {
          pGVar10 = triangle_candidate_points_from_edge
                              (tr,(GtsTriangle *)pGVar15->data,e,curpoint,closestdest,data);
          local_20 = pGVar10;
        }
        else {
          pGVar10 = triangle_all_candidate_points_from_edge
                              (tr,(GtsTriangle *)pGVar15->data,e,data,closestdest,curpoint);
          local_20 = pGVar10;
        }
        for (; pGVar10 != (GList *)0x0; pGVar10 = pGVar10->next) {
          pvVar5 = pGVar10->data;
          if (*(char *)((int)pvVar5 + 0x38) < '\0') {
            g_hash_table_insert(data->alltemppoints,pvVar5,pvVar5);
          }
        }
        r = (GList *)g_list_concat(0,local_20);
        goto LAB_080ea20a;
      }
    }
  }
  else {
                    // WARNING: Load size is inaccurate
    dVar1 = *pGVar10->data;
    while (dVar1 != (curpoint->v).p.z) {
      pGVar10 = pGVar10->next;
      if (pGVar10 == (GList *)0x0) goto LAB_080ea1ab;
                    // WARNING: Load size is inaccurate
      dVar1 = *pGVar10->data;
    }
  }
compute_candidate_points_finish:
  r = (GList *)0x0;
LAB_080ea20a:
  if ((curpoint->bbox != (_toporouter_bbox_t *)0x0) && (curpoint->bbox->cluster->c == data->src->c))
  {
    g_list_copy(data->srcvertices);
    pGVar10 = (GList *)g_list_concat();
    return pGVar10;
  }
  return r;
}



// WARNING: Unknown calling convention

GList * route(toporouter_t *r,toporouter_route_t *data,guint debug)

{
  double dVar1;
  _toporouter_cluster_t *p_Var2;
  gpointer pvVar3;
  toporouter_vertex_t *ptVar4;
  toporouter_vertex_t *srcv_00;
  GtsEHeap *heap;
  GList *pGVar5;
  GHashTable *pGVar6;
  guint gVar7;
  int iVar8;
  GList *pGVar9;
  toporouter_vertex_t *ptVar10;
  toporouter_vertex_t *tempv;
  toporouter_vertex_t *tv;
  toporouter_vertex_t *tv_1;
  GtsObjectClass *pGVar11;
  toporouter_vertex_t *pv;
  toporouter_vertex_t *pv_1;
  gpointer pvVar12;
  GtsObjectClass **item;
  GtsObjectClass *c;
  GList *i_3;
  toporouter_vertex_t *v_1;
  GtsObjectClass *pGVar13;
  GList *i;
  toporouter_vertex_t *temppoint;
  _toporouter_vertex_t *p_Var14;
  GList *i_2;
  GList *temp;
  toporouter_vertex_t *srcv;
  _toporouter_vertex_t *p_Var15;
  GList *closelist;
  bool bVar16;
  gdouble temp_g_cost;
  gdouble gVar17;
  toporouter_layer_t *local_50;
  _toporouter_vertex_t *local_48;
  toporouter_heap_search_data_t heap_search_data;
  guint local_28;
  _toporouter_vertex_t *local_24;
  _toporouter_vertex_t *local_20 [4];
  
  heap = gts_eheap_new(route_heap_cmp,(gpointer)0x0);
  local_20[0] = (_toporouter_vertex_t *)0x0;
  local_24 = (toporouter_vertex_t *)0x0;
  if (data->src->c == data->dest->c) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x11a7,"route","data->src->c != data->dest->c");
  }
  if (data->destvertices != (GList *)0x0) {
    g_list_free(data->destvertices);
  }
  if (data->srcvertices != (GList *)0x0) {
    g_list_free(data->srcvertices);
  }
  pGVar5 = cluster_vertices(r,data->dest);
  data->destvertices = pGVar5;
  pGVar5 = cluster_vertices(r,data->src);
  data->srcvertices = pGVar5;
  closest_cluster_pair(r,pGVar5,data->destvertices,&local_24,local_20);
  srcv_00 = local_24;
  if ((local_24 == (toporouter_vertex_t *)0x0) || (local_20[0] == (_toporouter_vertex_t *)0x0)) {
    local_48 = (_toporouter_vertex_t *)0x0;
    closelist = (GList *)0x0;
  }
  else {
    closelist = (GList *)0x0;
    local_50 = r->layers + (int)ROUND((local_24->v).p.z);
    data->path = (GList *)0x0;
    pGVar6 = (GHashTable *)g_hash_table_new(g_direct_hash,g_direct_equal);
    ptVar10 = local_24;
    local_24->parent = (_toporouter_vertex_t *)0x0;
    data->alltemppoints = pGVar6;
    local_24->child = (_toporouter_vertex_t *)0x0;
    local_24->gcost = 0.0;
    local_24->gn = 0;
    gVar17 = simple_h_cost(r,local_24,local_20[0]);
    ptVar10->hcost = gVar17;
    gts_eheap_insert(heap,local_24);
    gVar7 = gts_eheap_size(heap);
    while (gVar7 != 0) {
      data->curpoint = local_24;
      local_24 = (_toporouter_vertex_t *)gts_eheap_remove_top(heap,(gdouble *)0x0);
      if (((local_24->parent != (_toporouter_vertex_t *)0x0) && (-1 < *(char *)&local_24->flags)) &&
         (dVar1 = (local_24->v).p.z, dVar1 != (local_20[0]->v).p.z)) {
        local_50 = r->layers + (int)ROUND(dVar1);
        ptVar10 = closest_dest_vertex(r,local_24,data);
        if (ptVar10 != (toporouter_vertex_t *)0x0) {
          local_20[0] = ptVar10;
        }
      }
      iVar8 = g_list_find(data->destvertices,local_24);
      if (iVar8 != 0) {
        pGVar5 = (GList *)0x0;
        local_48 = (_toporouter_vertex_t *)0x0;
        local_20[0] = local_24;
        data->path = (GList *)0x0;
        p_Var14 = local_24;
        p_Var15 = (_toporouter_vertex_t *)0x0;
        if (local_24 == (_toporouter_vertex_t *)0x0) goto LAB_080ea9b8;
        goto LAB_080ea973;
      }
      closelist = (GList *)g_list_prepend(closelist,local_24);
      pGVar9 = compute_candidate_points(r,local_50,local_24,data,local_20);
      pGVar5 = pGVar9;
joined_r0x080ea798:
      if (pGVar5 != (GList *)0x0) {
        do {
          ptVar10 = (toporouter_vertex_t *)pGVar5->data;
          iVar8 = g_list_find(closelist,ptVar10);
          ptVar4 = local_24;
          if (iVar8 == 0) {
            for (; ptVar4 != (toporouter_vertex_t *)0x0; ptVar4 = ptVar4->parent) {
              if (ptVar10 == ptVar4) goto LAB_080ea7b0;
            }
            heap_search_data.result = (toporouter_vertex_t *)0x0;
            heap_search_data.key = ptVar10;
            gVar17 = gcost(r,data,srcv_00,ptVar10,local_24,&local_28);
            gts_eheap_foreach(heap,toporouter_heap_search,&heap_search_data);
            if (heap_search_data.result == (toporouter_vertex_t *)0x0) {
              ptVar10->gcost = gVar17;
              ptVar10->parent = local_24;
              local_24->child = ptVar10;
              ptVar10->gn = local_28;
              gVar17 = simple_h_cost(r,ptVar10,local_20[0]);
              ptVar10->hcost = gVar17;
              gts_eheap_insert(heap,ptVar10);
            }
            else if (gVar17 < ptVar10->gcost) goto code_r0x080ea853;
          }
LAB_080ea7b0:
          pGVar5 = (GList *)(&pGVar5->data)[1];
          if (pGVar5 == (GList *)0x0) break;
        } while( true );
      }
      g_list_free(pGVar9);
      gVar7 = gts_eheap_size(heap);
    }
    data->score = INFINITY;
    clean_routing_edges(r,data);
    local_48 = (_toporouter_vertex_t *)0x0;
    data->path = (GList *)0x0;
  }
  goto LAB_080ea5f1;
LAB_080ea973:
  pGVar5 = (GList *)g_list_prepend(pGVar5,p_Var14);
  data->path = pGVar5;
  iVar8 = g_list_find(data->srcvertices,p_Var14);
  if ((iVar8 != 0) && (local_48 = p_Var14, (*(byte *)&r->flags & 0x40) != 0)) {
    local_48 = (_toporouter_vertex_t *)data->path;
    p_Var15 = p_Var14;
    goto LAB_080ea9b8;
  }
  if (p_Var14->parent == (_toporouter_vertex_t *)0x0) goto code_r0x080ea9a9;
  pGVar5 = data->path;
  p_Var14 = p_Var14->parent;
  goto LAB_080ea973;
code_r0x080ea853:
  ptVar10->gcost = gVar17;
  ptVar10->gn = local_28;
  ptVar10->parent = local_24;
  local_24->child = ptVar10;
  gts_eheap_update(heap);
  pGVar5 = (GList *)(&pGVar5->data)[1];
  goto joined_r0x080ea798;
code_r0x080ea9a9:
  p_Var15 = local_48;
  local_48 = (_toporouter_vertex_t *)data->path;
LAB_080ea9b8:
  gVar17 = path_score(r,(GList *)local_48);
  p_Var2 = p_Var15->bbox->cluster;
  data->score = gVar17;
  if (p_Var2 != data->src) {
    data->src = p_Var2;
  }
  p_Var2 = local_20[0]->bbox->cluster;
  if (p_Var2 != data->dest) {
    data->dest = p_Var2;
  }
  pGVar5 = data->path;
  if (pGVar5 != (GList *)0x0) {
    pvVar12 = pGVar5->data;
    for (pGVar5 = pGVar5->next; pGVar5 != (GList *)0x0; pGVar5 = pGVar5->next) {
      bVar16 = pvVar12 != (gpointer)0x0;
      pvVar12 = pGVar5->data;
      if ((bVar16) && (iVar8 = g_list_find(data->srcvertices,pvVar12), iVar8 != 0)) {
        pGVar5 = (GList *)g_list_copy(pGVar5);
        g_list_free(data->path);
        data->path = pGVar5;
      }
    }
    pGVar5 = data->path;
    if (pGVar5 != (GList *)0x0) {
      pvVar12 = (gpointer)0x0;
      pGVar9 = pGVar5;
      do {
        pvVar3 = pGVar9->data;
        if ((char)*(uint *)((int)pvVar3 + 0x38) < '\0') {
          *(uint *)((int)pvVar3 + 0x38) = *(uint *)((int)pvVar3 + 0x38) ^ 0x80 | 0x100;
        }
        if (pvVar12 != (gpointer)0x0) {
          *(gpointer *)((int)pvVar12 + 0x30) = pvVar3;
        }
        if (*(int *)((int)pvVar3 + 0x34) != 0) {
          *(toporouter_route_t **)((int)pvVar3 + 0x58) = data;
        }
        pGVar9 = pGVar9->next;
        pvVar12 = pvVar3;
      } while (pGVar9 != (GList *)0x0);
      if (pGVar5 != (GList *)0x0) {
        pvVar12 = (gpointer)0x0;
        do {
          while (pvVar3 = pGVar5->data, pvVar12 == (gpointer)0x0) {
            pGVar5 = pGVar5->next;
            *(undefined4 *)((int)pvVar3 + 0x2c) = 0;
            pvVar12 = pvVar3;
            if (pGVar5 == (GList *)0x0) goto LAB_080eaac5;
          }
          pGVar5 = pGVar5->next;
          *(gpointer *)((int)pvVar3 + 0x2c) = pvVar12;
          *(gpointer *)((int)pvVar12 + 0x30) = pvVar3;
          pvVar12 = pvVar3;
        } while (pGVar5 != (GList *)0x0);
LAB_080eaac5:
        if (pvVar3 != (gpointer)0x0) {
          *(undefined4 *)((int)pvVar3 + 0x30) = 0;
        }
      }
    }
  }
  clean_routing_edges(r,data);
  for (pGVar5 = data->path; pGVar5 != (GList *)0x0; pGVar5 = pGVar5->next) {
    while (pvVar12 = pGVar5->data, *(int *)((int)pvVar12 + 0x34) != 0) {
      pGVar11 = (GtsObjectClass *)toporouter_constraint_class();
      item = *(GtsObjectClass ***)((int)pvVar12 + 0x34);
      if (pGVar11 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        item = *(GtsObjectClass ***)((int)pvVar12 + 0x34);
LAB_080eab54:
        space_edge(item,(gpointer)0x0);
      }
      else {
        if (item == (GtsObjectClass **)0x0) goto LAB_080eab54;
        pGVar13 = *item;
        if (pGVar13 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar11 == pGVar13) goto LAB_080eab26;
            pGVar13 = pGVar13->parent_class;
          } while (pGVar13 != (GtsObjectClass *)0x0);
          goto LAB_080eab54;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        space_edge(*(gpointer *)((int)pvVar12 + 0x34),(gpointer)0x0);
      }
      pGVar5 = pGVar5->next;
      if (pGVar5 == (GList *)0x0) goto LAB_080ea5f1;
    }
LAB_080eab26:
  }
LAB_080ea5f1:
  g_list_free(data->destvertices);
  g_list_free(data->srcvertices);
  data->destvertices = (GList *)0x0;
  data->srcvertices = (GList *)0x0;
  gts_eheap_destroy(heap);
  g_list_free(closelist);
  data->alltemppoints = (GHashTable *)0x0;
  return (GList *)local_48;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void roar_detour_route(toporouter_t *r,toporouter_route_t *data)

{
  GList **ppGVar1;
  _toporouter_netlist_t *p_Var2;
  int iVar3;
  int **ppiVar4;
  guint gVar5;
  int *piVar6;
  toporouter_route_t *route;
  GList *pGVar7;
  GList *pGVar8;
  int iVar9;
  GList *pGVar10;
  toporouter_cluster_t **i;
  int **ppiVar11;
  toporouter_route_t *ptVar12;
  toporouter_cluster_t *cluster;
  toporouter_route_t *conflict;
  toporouter_route_t *conflict_1;
  toporouter_route_t *conflict_2;
  toporouter_route_t *conflict_3;
  GList *j;
  gint oldc;
  GList *local_40;
  gdouble local_3c;
  gdouble local_34;
  GList *local_20;
  
  local_3c = data->score;
  route_checkpoint(data,(toporouter_route_t *)0x0);
  p_Var2 = data->netlist;
  pGVar7 = (GList *)g_list_remove(p_Var2->routed,data);
  p_Var2->routed = pGVar7;
  pGVar7 = (GList *)g_list_remove(r->routednets,data);
  r->routednets = pGVar7;
  pGVar7 = (GList *)g_list_prepend(r->failednets,data);
  r->failednets = pGVar7;
  local_40 = (GList *)g_list_prepend(0,data->netlist);
  netlists_recalculate(local_40,(GList *)0x0);
  r->flags = r->flags | 0x20;
  pGVar7 = ::route(r,data,0);
  if (pGVar7 == (GList *)0x0) {
    r->flags = r->flags & 0xffffffdf;
  }
  else {
    local_34 = data->score;
    pGVar8 = route_conflicts(data);
    p_Var2 = data->netlist;
    pGVar7 = (GList *)g_list_prepend(p_Var2->routed,data);
    p_Var2->routed = pGVar7;
    pGVar7 = (GList *)g_list_prepend(r->routednets,data);
    r->routednets = pGVar7;
    pGVar7 = (GList *)g_list_remove(r->failednets,data);
    r->flags = r->flags & 0xffffffdf;
    r->failednets = pGVar7;
    pGVar7 = pGVar8;
    if (pGVar8 == (GList *)0x0) {
      netlists_recalculate(local_40,(GList *)0x0);
    }
    else {
      do {
        ptVar12 = (toporouter_route_t *)pGVar7->data;
        iVar9 = g_list_find(local_40,ptVar12->netlist);
        if (iVar9 == 0) {
          local_40 = (GList *)g_list_prepend(local_40,ptVar12->netlist);
        }
        local_3c = local_3c + ptVar12->score;
        route_checkpoint(ptVar12,(toporouter_route_t *)0x0);
        p_Var2 = ptVar12->netlist;
        pGVar10 = (GList *)g_list_remove(p_Var2->routed,ptVar12);
        p_Var2->routed = pGVar10;
        pGVar10 = (GList *)g_list_remove(r->routednets,ptVar12);
        r->routednets = pGVar10;
        pGVar10 = (GList *)g_list_prepend(r->failednets,ptVar12);
        r->failednets = pGVar10;
        ppGVar1 = &pGVar7->next;
        pGVar7 = *ppGVar1;
      } while (*ppGVar1 != (GList *)0x0);
      netlists_recalculate(local_40,(GList *)0x0);
      local_20 = pGVar8;
      do {
        ptVar12 = (toporouter_route_t *)local_20->data;
        pGVar7 = ::route(r,ptVar12,0);
        if (pGVar7 == (GList *)0x0) {
          pGVar7 = local_20->prev;
          goto roar_detour_route_rollback_int;
        }
        p_Var2 = ptVar12->netlist;
        iVar9 = ptVar12->dest->c;
        iVar3 = ptVar12->src->c;
        ppiVar4 = (int **)p_Var2->clusters->pdata;
        gVar5 = p_Var2->clusters->len;
        ppiVar11 = ppiVar4 + (gVar5 - 1);
        if ((ppiVar4 <= ppiVar11) && (gVar5 != 0)) {
          do {
            while (piVar6 = *ppiVar11, iVar9 != *piVar6) {
              ppiVar11 = ppiVar11 + -1;
              if (ppiVar11 < ppiVar4) goto LAB_080eae27;
            }
            ppiVar11 = ppiVar11 + -1;
            *piVar6 = iVar3;
          } while (ppiVar4 <= ppiVar11);
        }
LAB_080eae27:
        pGVar7 = (GList *)g_list_prepend(p_Var2->routed,ptVar12);
        p_Var2->routed = pGVar7;
        pGVar7 = (GList *)g_list_prepend(r->routednets,ptVar12);
        r->routednets = pGVar7;
        pGVar7 = (GList *)g_list_remove(r->failednets,ptVar12);
        r->failednets = pGVar7;
        local_34 = local_34 + ptVar12->score;
        local_20 = local_20->next;
      } while (local_20 != (GList *)0x0);
    }
    if (local_34 <= local_3c) {
      g_list_free(pGVar8);
      goto LAB_080eaffe;
    }
    pGVar7 = (GList *)g_list_last(pGVar8);
roar_detour_route_rollback_int:
    p_Var2 = data->netlist;
    pGVar10 = (GList *)g_list_remove(p_Var2->routed,data);
    p_Var2->routed = pGVar10;
    pGVar10 = (GList *)g_list_remove(r->routednets,data);
    r->routednets = pGVar10;
    pGVar10 = (GList *)g_list_prepend(r->failednets,data);
    r->failednets = pGVar10;
    for (; pGVar7 != (GList *)0x0; pGVar7 = pGVar7->prev) {
      ptVar12 = (toporouter_route_t *)pGVar7->data;
      p_Var2 = ptVar12->netlist;
      pGVar10 = (GList *)g_list_remove(p_Var2->routed,ptVar12);
      p_Var2->routed = pGVar10;
      pGVar10 = (GList *)g_list_remove(r->routednets,ptVar12);
      r->routednets = pGVar10;
      pGVar10 = (GList *)g_list_prepend(r->failednets,ptVar12);
      r->failednets = pGVar10;
      delete_route(ptVar12,1);
    }
    for (ptVar12 = (toporouter_route_t *)g_list_last(pGVar8); ptVar12 != (toporouter_route_t *)0x0;
        ptVar12 = (toporouter_route_t *)ptVar12->dest) {
      route = (toporouter_route_t *)ptVar12->netlist;
      route_restore(route);
      p_Var2 = route->netlist;
      pGVar7 = (GList *)g_list_prepend(p_Var2->routed,route);
      p_Var2->routed = pGVar7;
      pGVar7 = (GList *)g_list_prepend(r->routednets,route);
      r->routednets = pGVar7;
      pGVar7 = (GList *)g_list_remove(r->failednets,route);
      r->failednets = pGVar7;
    }
    delete_route(data,1);
  }
  route_restore(data);
  p_Var2 = data->netlist;
  pGVar7 = (GList *)g_list_prepend(p_Var2->routed,data);
  p_Var2->routed = pGVar7;
  pGVar7 = (GList *)g_list_prepend(r->routednets,data);
  r->routednets = pGVar7;
  pGVar7 = (GList *)g_list_remove(r->failednets,data);
  r->failednets = pGVar7;
LAB_080eaffe:
  netlists_recalculate(local_40,(GList *)0x0);
  g_list_free();
  return;
}



// WARNING: Unknown calling convention

void detour_router(toporouter_t *r)

{
  GList *pGVar1;
  gpointer pvVar2;
  toporouter_route_t *data;
  undefined4 uVar3;
  guint n;
  toporouter_route_t *curroute;
  toporouter_route_t *curroute_1;
  int iVar4;
  GList *i;
  toporouter_route_t **i_1;
  toporouter_route_t **pptVar5;
  GPtrArray *scores;
  gdouble gVar6;
  
  pGVar1 = r->routednets;
  uVar3 = g_list_length(pGVar1);
  n = g_ptr_array_sized_new(uVar3);
  for (; pGVar1 != (GList *)0x0; pGVar1 = pGVar1->next) {
    pvVar2 = pGVar1->data;
    gVar6 = path_score(r,*(GList **)((int)pvVar2 + 0x2c));
    *(gdouble *)((int)pvVar2 + 0x14) = gVar6;
    g_ptr_array_add(n,pGVar1->data);
  }
  g_ptr_array_sort(n,route_detour_compare);
  pptVar5 = *(toporouter_route_t ***)n;
  iVar4 = *(int *)(n + 4);
  if (pptVar5 < pptVar5 + iVar4) {
    do {
      data = *pptVar5;
      if ((ABS(data->score) <= 1.797693134862316e+308) &&
         (ABS(data->detourscore) <= 1.797693134862316e+308)) {
        if (data->score - data->detourscore <= 1000.0) break;
        roar_detour_route(r,data);
        iVar4 = *(int *)(n + 4);
      }
      pptVar5 = pptVar5 + 1;
    } while (pptVar5 < (toporouter_route_t **)(iVar4 * 4 + *(int *)n));
  }
  __printf_chk(1,"\n");
  g_ptr_array_free(n,1);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

gint roar_route(toporouter_t *r,toporouter_route_t *routedata,gint threshold)

{
  _toporouter_netlist_t *p_Var1;
  GPtrArray *pGVar2;
  guint gVar3;
  int **ppiVar4;
  int iVar5;
  toporouter_route_t *ptVar6;
  _toporouter_cluster_t *p_Var7;
  GList *pGVar8;
  toporouter_cluster_t **i;
  int **ppiVar9;
  int iVar10;
  GList *pGVar11;
  GList *pGVar12;
  toporouter_cluster_t **i_1;
  toporouter_route_t *ptVar13;
  _toporouter_cluster_t *p_Var14;
  toporouter_cluster_t *cluster;
  toporouter_cluster_t *cluster_1;
  toporouter_route_t *conflict;
  toporouter_route_t *conflict_1;
  toporouter_route_t *intconflict;
  toporouter_route_t *intconflict_1;
  gint intfails;
  gint gVar15;
  gint oldc;
  GList *j;
  GList *i_2;
  gint newc;
  gint oldc_1;
  GList *local_34;
  int local_2c;
  toporouter_route_t *local_28;
  GList *local_20;
  
  if (routedata->path != (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1b3e,"roar_route","!routedata->path");
  }
  p_Var14 = routedata->src;
  p_Var7 = routedata->dest;
  iVar10 = p_Var14->c;
  if (iVar10 == p_Var7->c) {
    __printf_chk(1,"ERROR: attempt to route already complete route\n");
    p_Var14 = routedata->src;
    p_Var7 = routedata->dest;
    iVar10 = p_Var14->c;
    if (iVar10 == p_Var7->c) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x1b42,"roar_route",
                 "routedata->src->c != routedata->dest->c");
    }
  }
  p_Var14->pc = iVar10;
  p_Var7->pc = p_Var7->c;
  r->flags = r->flags | 0x20;
  routedata->psrc = p_Var14;
  routedata->pdest = p_Var7;
  pGVar8 = route(r,routedata,0);
  if (pGVar8 == (GList *)0x0) {
    local_28 = (toporouter_route_t *)0x0;
    r->flags = r->flags & 0xffffffdf;
    gVar15 = 0;
    goto LAB_080eb624;
  }
  p_Var1 = routedata->netlist;
  pGVar8 = (GList *)g_list_prepend(p_Var1->routed,routedata);
  p_Var1->routed = pGVar8;
  pGVar8 = (GList *)g_list_prepend(r->routednets,routedata);
  r->routednets = pGVar8;
  pGVar8 = (GList *)g_list_remove(r->failednets,routedata);
  r->failednets = pGVar8;
  pGVar8 = route_conflicts(routedata);
  p_Var1 = routedata->netlist;
  pGVar2 = p_Var1->clusters;
  iVar10 = routedata->dest->c;
  gVar3 = pGVar2->len;
  ppiVar4 = (int **)pGVar2->pdata;
  iVar5 = routedata->src->c;
  ppiVar9 = ppiVar4 + (gVar3 - 1);
  if (ppiVar4 <= ppiVar9) {
    while (gVar3 != 0) {
      if (iVar10 == **ppiVar9) {
        **ppiVar9 = iVar5;
      }
      if (ppiVar9 + -1 < ppiVar4) break;
      ppiVar9 = ppiVar9 + -1;
      gVar3 = pGVar2->len;
    }
  }
  r->flags = r->flags & 0xffffffdf;
  if (pGVar8 != (GList *)0x0) {
    local_20 = (GList *)0x0;
    pGVar12 = pGVar8;
    do {
      ptVar13 = (toporouter_route_t *)pGVar12->data;
      iVar10 = g_list_find(local_20,ptVar13->netlist);
      if (iVar10 == 0) {
        local_20 = (GList *)g_list_prepend(local_20,ptVar13->netlist);
      }
      route_checkpoint(ptVar13,routedata);
      p_Var1 = ptVar13->netlist;
      pGVar11 = (GList *)g_list_remove(p_Var1->routed,ptVar13);
      p_Var1->routed = pGVar11;
      pGVar11 = (GList *)g_list_remove(r->routednets,ptVar13);
      r->routednets = pGVar11;
      pGVar11 = (GList *)g_list_prepend(r->failednets,ptVar13);
      r->failednets = pGVar11;
      pGVar12 = pGVar12->next;
    } while (pGVar12 != (GList *)0x0);
    local_34 = (GList *)g_list_prepend(local_20,routedata->netlist);
    netlists_recalculate(local_34,(GList *)0x0);
    ptVar13 = (toporouter_route_t *)pGVar8->data;
    if (ptVar13->src->c != ptVar13->dest->c) {
      local_28 = (toporouter_route_t *)0x0;
      local_2c = 0;
      local_20 = pGVar8;
      do {
        pGVar12 = route(r,ptVar13,0);
        if (pGVar12 == (GList *)0x0) {
          local_2c = local_2c + 1;
          ptVar13 = local_28;
          if (threshold <= local_2c) goto joined_r0x080eb4e0;
        }
        else {
          iVar10 = ptVar13->dest->c;
          iVar5 = ptVar13->src->c;
          pGVar2 = ptVar13->netlist->clusters;
          ppiVar4 = (int **)pGVar2->pdata;
          gVar3 = pGVar2->len;
          ppiVar9 = ppiVar4 + (gVar3 - 1);
          if (ppiVar4 <= ppiVar9) {
            while (gVar3 != 0) {
              if (iVar10 == **ppiVar9) {
                **ppiVar9 = iVar5;
              }
              if (ppiVar9 + -1 < ppiVar4) break;
              ppiVar9 = ppiVar9 + -1;
              gVar3 = pGVar2->len;
            }
          }
          local_28 = (toporouter_route_t *)g_list_prepend(local_28,ptVar13);
          p_Var1 = ptVar13->netlist;
          pGVar12 = (GList *)g_list_prepend(p_Var1->routed,ptVar13);
          p_Var1->routed = pGVar12;
          pGVar12 = (GList *)g_list_prepend(r->routednets,ptVar13);
          r->routednets = pGVar12;
          pGVar12 = (GList *)g_list_remove(r->failednets,ptVar13);
          r->failednets = pGVar12;
          netlist_recalculate(ptVar13->netlist,(GList *)0x0);
        }
        local_20 = local_20->next;
        if (local_20 == (GList *)0x0) {
          gVar15 = local_2c + -1;
          goto LAB_080eb63f;
        }
        ptVar13 = (toporouter_route_t *)local_20->data;
      } while (ptVar13->src->c != ptVar13->dest->c);
    }
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x1b67,"roar_route",
               "conflict->src->c != conflict->dest->c");
  }
  gVar15 = -1;
  local_34 = (GList *)g_list_prepend(0,p_Var1);
  netlists_recalculate(local_34,(GList *)0x0);
  local_28 = (toporouter_route_t *)0x0;
LAB_080eb63f:
  netlists_recalculate(local_34,(GList *)0x0);
roar_route_end:
  g_list_free(pGVar8);
  g_list_free(local_34);
LAB_080eb624:
  g_list_free(local_28);
  return gVar15;
joined_r0x080eb4e0:
  for (; ptVar13 != (toporouter_route_t *)0x0; ptVar13 = (toporouter_route_t *)ptVar13->src) {
    ptVar6 = (toporouter_route_t *)ptVar13->netlist;
    p_Var1 = ptVar6->netlist;
    pGVar12 = (GList *)g_list_remove(p_Var1->routed,ptVar6);
    p_Var1->routed = pGVar12;
    pGVar12 = (GList *)g_list_remove(r->routednets,ptVar6);
    r->routednets = pGVar12;
    pGVar12 = (GList *)g_list_prepend(r->failednets,ptVar6);
    r->failednets = pGVar12;
    delete_route(ptVar6,1);
  }
  delete_route(routedata,1);
  for (ptVar13 = (toporouter_route_t *)g_list_last(pGVar8); ptVar13 != (toporouter_route_t *)0x0;
      ptVar13 = (toporouter_route_t *)ptVar13->dest) {
    ptVar6 = (toporouter_route_t *)ptVar13->netlist;
    route_restore(ptVar6);
    p_Var1 = ptVar6->netlist;
    pGVar12 = (GList *)g_list_prepend(p_Var1->routed,ptVar6);
    p_Var1->routed = pGVar12;
    pGVar12 = (GList *)g_list_prepend(r->routednets,ptVar6);
    r->routednets = pGVar12;
    pGVar12 = (GList *)g_list_remove(r->failednets,ptVar6);
    r->failednets = pGVar12;
  }
  p_Var1 = routedata->netlist;
  pGVar12 = (GList *)g_list_remove(p_Var1->routed,routedata);
  p_Var1->routed = pGVar12;
  pGVar12 = (GList *)g_list_remove(r->routednets,routedata);
  r->routednets = pGVar12;
  pGVar12 = (GList *)g_list_prepend(r->failednets,routedata);
  r->failednets = pGVar12;
  gVar15 = 0;
  netlists_recalculate(local_34,(GList *)0x0);
  goto roar_route_end;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

gint roar_router(toporouter_t *r,gint failcount,gint threshold)

{
  toporouter_route_t *ptVar1;
  toporouter_route_t *ptVar2;
  gint gVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GList *k;
  int local_28;
  int local_20;
  
  local_28 = failcount + 1;
  Message("ROAR router: ");
  local_20 = 0;
  while( true ) {
    ptVar2 = (toporouter_route_t *)g_list_copy(r->failednets);
    for (ptVar1 = ptVar2; ptVar1 != (toporouter_route_t *)0x0;
        ptVar1 = (toporouter_route_t *)ptVar1->src) {
      gVar3 = roar_route(r,(toporouter_route_t *)ptVar1->netlist,threshold);
      failcount = failcount + gVar3;
    }
    g_list_free(ptVar2);
    uVar4 = g_list_length(r->failednets);
    uVar5 = g_list_length(r->routednets);
    __printf_chk(1,"\tROAR pass %d - %d routed -  %d failed\n",local_20,uVar5,uVar4);
    if ((local_28 <= failcount) || (failcount == 0)) break;
    Message("%d -> ",failcount);
    local_20 = local_20 + 1;
    local_28 = failcount;
    if (local_20 == 6) {
      return failcount;
    }
  }
  Message("%d nets remaining\n",failcount);
  return failcount;
}



// WARNING: Unknown calling convention

void netscore_pairwise_calculation(toporouter_netscore_t *netscore,GPtrArray *netscores)

{
  double dVar1;
  double dVar2;
  toporouter_netscore_t **pptVar3;
  toporouter_route_t *ptVar4;
  toporouter_netscore_t *ptVar5;
  toporouter_route_t *data;
  toporouter_route_t *temproutedata;
  toporouter_netscore_t **i;
  toporouter_netscore_t **pptVar6;
  int iVar7;
  guint local_20;
  
  pptVar3 = (toporouter_netscore_t **)netscores->pdata;
  data = routedata_create();
  apply_route(netscore->routedata->topopath,netscore->routedata);
  local_20 = netscores->len;
  if (pptVar3 < pptVar3 + local_20) {
    iVar7 = 0;
    pptVar6 = pptVar3;
    do {
      if ((netscore->pairwise_nodetour[iVar7 >> 2] == 0) && (*pptVar6 != netscore)) {
        ptVar4 = (*pptVar6)->routedata;
        data->src = ptVar4->src;
        data->dest = ptVar4->dest;
        route(netscore->r,data,0);
        ptVar5 = *pptVar6;
        dVar1 = data->score;
        dVar2 = ptVar5->score;
        if (dVar1 == dVar2) {
          netscore->pairwise_nodetour[iVar7 >> 2] = 1;
          ptVar5->pairwise_nodetour[netscore->id] = 1;
        }
        else if (ABS(dVar1) <= 1.797693134862316e+308) {
          netscore->pairwise_detour_sum = (dVar1 - dVar2) + netscore->pairwise_detour_sum;
        }
        else {
          netscore->pairwise_fails = netscore->pairwise_fails + 1;
        }
        delete_route(data,1);
        local_20 = netscores->len;
      }
      pptVar6 = pptVar6 + 1;
      iVar7 = iVar7 + 4;
    } while (pptVar6 < pptVar3 + local_20);
  }
  remove_route(netscore->routedata->topopath);
  free(data);
  return;
}



// WARNING: Unknown calling convention

toporouter_netscore_t *
netscore_create(toporouter_t *r,toporouter_route_t *routedata,guint n,guint id)

{
  double dVar1;
  toporouter_netscore_t *ptVar2;
  GList *pGVar3;
  guint *pgVar4;
  uint uVar5;
  guint i;
  
  ptVar2 = (toporouter_netscore_t *)calloc(1,0x24);
  pGVar3 = route(r,routedata,0);
  ptVar2->routedata = routedata;
  dVar1 = routedata->score;
  ptVar2->score = dVar1;
  routedata->detourscore = dVar1;
  ptVar2->id = id;
  if (1.797693134862316e+308 < ABS(dVar1)) {
    __printf_chk(1,"WARNING: !finite(detourscore)\n");
    print_cluster(routedata->src);
    print_cluster(routedata->dest);
  }
  pgVar4 = (guint *)calloc(1,n * 4);
  ptVar2->pairwise_nodetour = pgVar4;
  if (n != 0) {
    uVar5 = 0;
    while( true ) {
      pgVar4[uVar5] = 0;
      uVar5 = uVar5 + 1;
      if (n <= uVar5) break;
      pgVar4 = ptVar2->pairwise_nodetour;
    }
  }
  ptVar2->pairwise_detour_sum = 0.0;
  ptVar2->pairwise_fails = 0;
  ptVar2->r = r;
  if (pGVar3 != (GList *)0x0) {
    pGVar3 = (GList *)g_list_copy(routedata->path);
    routedata->topopath = pGVar3;
    delete_route(routedata,0);
  }
  return ptVar2;
}



// WARNING: Unknown calling convention

guint order_nets_preroute_greedy(toporouter_t *r,GList *nets,GList **rnets)

{
  double dVar1;
  uint uVar2;
  void *__ptr;
  guint n;
  uint *puVar3;
  guint failcount;
  guint id;
  toporouter_netscore_t *ptVar4;
  GList *pGVar5;
  toporouter_netscore_t *netscore;
  toporouter_netscore_t **i;
  void **ppvVar6;
  GPtrArray *netscores;
  guint local_20;
  
  n = g_list_length(nets);
  puVar3 = (uint *)g_ptr_array_sized_new(n);
  if (nets != (GList *)0x0) {
    id = 0;
    do {
      ptVar4 = netscore_create(r,(toporouter_route_t *)nets->data,n,id);
      g_ptr_array_add(puVar3,ptVar4);
      nets = nets->next;
      id = id + 1;
    } while (nets != (GList *)0x0);
  }
  g_ptr_array_foreach(puVar3,netscore_pairwise_calculation,puVar3);
  g_ptr_array_sort(puVar3,r->netsort);
  uVar2 = puVar3[1];
  *rnets = (GList *)0x0;
  ppvVar6 = (void **)*puVar3 + (uVar2 - 1);
  if ((ppvVar6 < (void **)*puVar3) || (uVar2 == 0)) {
    local_20 = 0;
  }
  else {
    pGVar5 = (GList *)0x0;
    local_20 = 0;
    while( true ) {
      __ptr = *ppvVar6;
      pGVar5 = (GList *)g_list_prepend(pGVar5,*(undefined4 *)((int)__ptr + 0x1c));
      dVar1 = *(double *)((int)__ptr + 0x10);
      *rnets = pGVar5;
      local_20 = local_20 + (1.797693134862316e+308 < ABS(dVar1));
      ppvVar6 = ppvVar6 + -1;
      free(*(void **)((int)__ptr + 4));
      free(__ptr);
      if ((ppvVar6 <= (void **)*puVar3 && (void **)*puVar3 != ppvVar6) || (puVar3[1] == 0)) break;
      pGVar5 = *rnets;
    }
  }
  g_ptr_array_free(puVar3,1);
  return local_20;
}



// WARNING: Unknown calling convention

gint rubix_router(toporouter_t *r,gint failcount)

{
  toporouter_route_t *ptVar1;
  _toporouter_netlist_t *p_Var2;
  int iVar3;
  int iVar4;
  GPtrArray *pGVar5;
  int **ppiVar6;
  guint gVar7;
  int *piVar8;
  toporouter_route_t *ptVar9;
  toporouter_cluster_t **i_1;
  GList *pGVar10;
  int **ppiVar11;
  gint oldc;
  toporouter_cluster_t *cluster;
  toporouter_route_t *data;
  GList *i;
  toporouter_route_t *local_20 [4];
  
  order_nets_preroute_greedy(r,r->failednets,(GList **)local_20);
  ptVar1 = (toporouter_route_t *)0x0;
  ptVar9 = local_20[0];
  do {
    if (ptVar9 == (toporouter_route_t *)0x0) {
      g_list_free(ptVar1);
      return failcount;
    }
    ptVar1 = (toporouter_route_t *)ptVar9->netlist;
    pGVar10 = route(r,ptVar1,0);
    if (pGVar10 != (GList *)0x0) {
      p_Var2 = ptVar1->netlist;
      pGVar10 = (GList *)g_list_prepend(p_Var2->routed,ptVar1);
      p_Var2->routed = pGVar10;
      pGVar10 = (GList *)g_list_prepend(r->routednets,ptVar1);
      r->routednets = pGVar10;
      pGVar10 = (GList *)g_list_remove(r->failednets,ptVar1);
      r->failednets = pGVar10;
      iVar3 = ptVar1->dest->c;
      iVar4 = ptVar1->src->c;
      pGVar5 = ptVar1->netlist->clusters;
      ppiVar6 = (int **)pGVar5->pdata;
      gVar7 = pGVar5->len;
      ppiVar11 = ppiVar6 + (gVar7 - 1);
      if ((ppiVar6 <= ppiVar11) && (gVar7 != 0)) {
        do {
          while (piVar8 = *ppiVar11, iVar3 == *piVar8) {
            ppiVar11 = ppiVar11 + -1;
            *piVar8 = iVar4;
            if (ppiVar11 < ppiVar6) goto LAB_080ebca7;
          }
          ppiVar11 = ppiVar11 + -1;
        } while (ppiVar6 <= ppiVar11);
      }
LAB_080ebca7:
      failcount = failcount + -1;
    }
    ptVar9 = (toporouter_route_t *)ptVar9->src;
    ptVar1 = local_20[0];
  } while( true );
}



// WARNING: Unknown calling convention

guint hybrid_router(toporouter_t *r)

{
  gint gVar1;
  guint gVar2;
  gint failcount;
  
  gVar1 = g_list_length(r->failednets);
  r->flags = r->flags | 0xc0;
  gVar1 = rubix_router(r,gVar1);
  Message("RUBIX router: %d nets remaining\n",gVar1);
  __printf_chk(1,"RUBIX router: %d nets remaining\n",gVar1);
  r->flags = r->flags | 0x100;
  gVar1 = roar_router(r,gVar1,2);
  detour_router(r);
  gVar2 = roar_router(r,gVar1,2);
  detour_router(r);
  return gVar2;
}



// WARNING: Unknown calling convention

int toporouter(int argc,char **argv,int x,int y)

{
  toporouter_t *r_00;
  toporouter_t *r;
  
  r_00 = toporouter_new();
  parse_arguments(r_00,argc,argv);
  import_geometry(r_00);
  acquire_twonets(r_00);
  hybrid_router(r_00);
  toporouter_export(r_00);
  toporouter_free(r_00);
  SaveUndoSerialNumber();
  DeleteRats('\0');
  RestoreUndoSerialNumber();
  AddAllRats('\0',(_func_void_varargs *)0x0);
  RestoreUndoSerialNumber();
  IncrementUndoSerialNumber();
  ClearAndRedrawOutput();
  return 0;
}



// WARNING: Unknown calling convention

gint spread_edge(gpointer item,gpointer data)

{
  int iVar1;
  int iVar2;
  double dVar3;
  double d;
  GtsObjectClass *pGVar4;
  int iVar5;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar6;
  GList *i;
  int *piVar7;
  gdouble s;
  gdouble gVar8;
  
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (item != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar6 = *item;
    if (pGVar6 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar4 == pGVar6) {
          return 0;
        }
        pGVar6 = pGVar6->parent_class;
      } while (pGVar6 != (GtsObjectClass *)0x0);
    }
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (item != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pGVar6 = *item;
    if (pGVar6 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar4 == pGVar6) break;
        pGVar6 = pGVar6->parent_class;
      } while (pGVar6 != (GtsObjectClass *)0x0);
    }
  }
  piVar7 = *(int **)((int)item + 0x1c);
  iVar5 = g_list_length(piVar7);
  if (iVar5 != 0) {
    iVar5 = g_list_length(piVar7);
    if (iVar5 == 1) {
      iVar5 = *(int *)((int)item + 0xc);
      iVar1 = *(int *)((int)item + 0x10);
      iVar2 = *piVar7;
      *(double *)(iVar2 + 0xc) = (*(double *)(iVar5 + 0xc) + *(double *)(iVar1 + 0xc)) * 0.5;
      *(double *)(iVar2 + 0x14) = (*(double *)(iVar5 + 0x14) + *(double *)(iVar1 + 0x14)) * 0.5;
    }
    else {
      gVar8 = gts_point_distance(*(GtsPoint **)((int)item + 0xc),*(GtsPoint **)((int)item + 0x10));
      iVar5 = g_list_length(piVar7);
      if (piVar7 != (int *)0x0) {
        dVar3 = gVar8 / (double)(ulonglong)(iVar5 + 1);
        d = dVar3;
        do {
          vertex_move_towards_vertex_values
                    (*(GtsVertex **)((int)item + 0xc),*(GtsVertex **)((int)item + 0x10),d,
                     (gdouble *)(*piVar7 + 0xc),(gdouble *)(*piVar7 + 0x14));
          piVar7 = (int *)piVar7[1];
          d = d + dVar3;
        } while (piVar7 != (int *)0x0);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void dispatch_status_changed(DBusConnection *conn,DBusDispatchStatus new_status,void *data)

{
  return;
}



// WARNING: Unknown calling convention

void pcb_dbus_connection_finish_with_mainloop(DBusConnection *connection)

{
  int iVar1;
  
  iVar1 = dbus_connection_set_watch_functions(connection,0,0,0,0,0);
  if (iVar1 != 0) {
    iVar1 = dbus_connection_set_timeout_functions(connection,0,0,0,0,0);
    if (iVar1 != 0) {
      dbus_connection_set_dispatch_status_function(connection,0,0,0);
      return;
    }
  }
  __fprintf_chk(stderr,1,"Not enough memory when cleaning up DBusConnection mainloop integration\n")
  ;
  return;
}



// WARNING: Unknown calling convention

void pcb_dbus_connection_setup_with_mainloop(DBusConnection *connection)

{
  int iVar1;
  undefined local_10 [8];
  
  iVar1 = dbus_connection_set_watch_functions(connection,watch_add,watch_remove,watch_toggled,0,0);
  if (iVar1 != 0) {
    iVar1 = dbus_connection_set_timeout_functions
                      (connection,timeout_add,timeout_remove,timeout_toggled,0,0);
    if (iVar1 != 0) {
      dbus_connection_set_dispatch_status_function(connection,dispatch_status_changed,0,0);
      (*gui->add_block_hook)((_func_void_hidval *)local_10,(hidval)block_hook_cb);
      return;
    }
  }
  __fprintf_chk(stderr,1,"Not enough memory to set up DBusConnection for use with PCB\n");
  return;
}



// WARNING: Unknown calling convention

void block_hook_cb(hidval data)

{
  int iVar1;
  
  iVar1 = dbus_connection_get_dispatch_status(data.lval);
  if (iVar1 != 0) {
    return;
  }
  dbus_connection_dispatch();
  return;
}



// WARNING: Unknown calling convention

void timeout_remove(DBusTimeout *timeout,void *data)

{
  dbus_timeout_set_data(timeout,0,0);
  return;
}



// WARNING: Unknown calling convention

dbus_bool_t timeout_add(DBusTimeout *timeout,void *data)

{
  _func_hidval__func_void_hidval_ptr_ulong_hidval *p_Var1;
  int iVar2;
  DBusTimeout **ppDVar3;
  hidval hVar4;
  DBusTimeout *local_10;
  
  iVar2 = dbus_timeout_get_enabled(timeout);
  if (iVar2 != 0) {
    ppDVar3 = (DBusTimeout **)malloc(0xc);
    *ppDVar3 = timeout;
    hVar4.lval = dbus_timeout_get_interval(timeout);
    p_Var1 = gui->add_timer;
    *(hidval *)(ppDVar3 + 2) = hVar4;
    (*p_Var1)((_func_void_hidval *)&local_10,(ulong)timeout_handler_cb,hVar4);
    ppDVar3[1] = local_10;
    dbus_timeout_set_data(timeout,ppDVar3,timeout_handler_dbus_freed);
  }
  return 1;
}



// WARNING: Unknown calling convention

void timeout_toggled(DBusTimeout *timeout,void *data)

{
  int iVar1;
  
  iVar1 = dbus_timeout_get_enabled(timeout);
  if (iVar1 == 0) {
    timeout_remove(timeout,data);
    return;
  }
  timeout_add(timeout,data);
  return;
}



// WARNING: Unknown calling convention

void timeout_handler_dbus_freed(void *data)

{
  (*gui->stop_timer)(*(hidval *)((int)data + 4));
  free(data);
  return;
}



// WARNING: Unknown calling convention

void io_watch_handler_dbus_freed(void *data)

{
  (*gui->unwatch_file)(*(hidval *)((int)data + 4));
  free(data);
  return;
}



// WARNING: Unknown calling convention

void watch_remove(DBusWatch *dbus_watch,void *data)

{
  dbus_watch_set_data(dbus_watch,0,0);
  return;
}



// WARNING: Unknown calling convention

dbus_bool_t watch_add(DBusWatch *dbus_watch,void *data)

{
  _func_hidval_int_uint__func_void_hidval_int_uint_hidval_ptr_hidval *p_Var1;
  int iVar2;
  uint uVar3;
  uint dbus_flags;
  DBusWatch **ppDVar4;
  uint pcb_condition;
  int fd;
  DBusWatch *local_20 [4];
  
  iVar2 = dbus_watch_get_enabled(dbus_watch);
  if (iVar2 != 0) {
    uVar3 = dbus_watch_get_flags(dbus_watch);
    pcb_condition = 0xd - ((uVar3 & 1) == 0);
    if ((uVar3 & 2) != 0) {
      pcb_condition = (uint)(pcb_condition | 1);
    }
    uVar3 = dbus_watch_get_unix_fd(dbus_watch);
    ppDVar4 = (DBusWatch **)malloc(8);
    p_Var1 = gui->watch_file;
    *ppDVar4 = dbus_watch;
    (*p_Var1)((int)local_20,uVar3,(_func_void_hidval_int_uint_hidval *)pcb_condition,
              (hidval)io_watch_handler_cb);
    ppDVar4[1] = local_20[0];
    dbus_watch_set_data(dbus_watch,ppDVar4,io_watch_handler_dbus_freed);
  }
  return 1;
}



// WARNING: Unknown calling convention

void watch_toggled(DBusWatch *dbus_watch,void *data)

{
  int iVar1;
  
  iVar1 = dbus_watch_get_enabled(dbus_watch);
  if (iVar1 == 0) {
    watch_remove(dbus_watch,data);
    return;
  }
  watch_add(dbus_watch,data);
  return;
}



// WARNING: Unknown calling convention

void timeout_handler_cb(hidval data)

{
  undefined4 local_10 [2];
  
  (*gui->add_timer)((_func_void_hidval *)local_10,(ulong)timeout_handler_cb,
                    *(hidval *)(data.lval + 8));
  *(undefined4 *)(data.lval + 4) = local_10[0];
  dbus_timeout_handle();
  return;
}



// WARNING: Unknown calling convention

void io_watch_handler_cb(hidval pcb_watch,int fd,uint condition,hidval data)

{
  uint dbus_condition;
  
  dbus_watch_handle();
  return;
}



// WARNING: Unknown calling convention

void unregister_dbus_handler(DBusConnection *connection,void *data)

{
  return;
}



// WARNING: Unknown calling convention

void pcb_dbus_finish(void)

{
  DBusError err;
  
  dbus_error_init(&err);
  dbus_connection_flush(pcb_dbus_conn);
  dbus_connection_unregister_object_path(pcb_dbus_conn,"/org/seul/geda/pcb");
  dbus_bus_release_name(pcb_dbus_conn,"org.seul.geda.pcb",&err);
  dbus_error_free(&err);
  pcb_dbus_connection_finish_with_mainloop(pcb_dbus_conn);
  dbus_connection_close(pcb_dbus_conn);
  dbus_connection_unref(pcb_dbus_conn);
  dbus_shutdown();
  return;
}



// WARNING: Unknown calling convention

void pcb_dbus_setup(void)

{
  int iVar1;
  int iVar2;
  int ret;
  DBusError *pDVar3;
  DBusObjectPathVTable object_vtable;
  DBusError err;
  
  object_vtable.unregister_function = unregister_dbus_handler;
  object_vtable.message_function = handle_dbus_message;
  object_vtable.dbus_internal_pad1 = (_func_void_void_ptr *)0x0;
  object_vtable.dbus_internal_pad2 = (_func_void_void_ptr *)0x0;
  object_vtable.dbus_internal_pad3 = (_func_void_void_ptr *)0x0;
  object_vtable.dbus_internal_pad4 = (_func_void_void_ptr *)0x0;
  dbus_error_init(&err);
  pcb_dbus_conn = (DBusConnection *)dbus_bus_get_private(0,&err);
  iVar1 = dbus_error_is_set(&err);
  if (iVar1 != 0) {
    __fprintf_chk(stderr,1,"pcb_dbus: DBus connection Error (%s)\n",err.message);
    dbus_error_free(&err);
  }
  if (pcb_dbus_conn != (DBusConnection *)0x0) {
    pDVar3 = &err;
    iVar1 = dbus_bus_request_name(pcb_dbus_conn,"org.seul.geda.pcb",2,&err);
    iVar2 = dbus_error_is_set(&err);
    if (iVar2 != 0) {
      __fprintf_chk(stderr,1,"pcb_dbus: DBus name error (%s)\n",err.message);
      dbus_error_free(&err);
      pDVar3 = (DBusError *)err.message;
    }
    if (iVar1 - 1U < 2) {
      iVar1 = dbus_connection_register_object_path
                        (pcb_dbus_conn,"/org/seul/geda/pcb",&object_vtable,0);
      if (iVar1 != 0) {
        pcb_dbus_connection_setup_with_mainloop(pcb_dbus_conn);
        return;
      }
      __fprintf_chk(stderr,1,"pcb_dbus: Couldn\'t register DBUS handler for %s\n",
                    "/org/seul/geda/pcb");
      return;
    }
    __fprintf_chk(stderr,1,
                  "pcb_dbus: Couldn\'t gain ownership or queued ownership of the canonical DBus name\n"
                  ,pDVar3);
  }
  return;
}



// WARNING: Unknown calling convention

DBusHandlerResult handle_dbus_message(DBusConnection *connection,DBusMessage *message,void *data)

{
  int iVar1;
  int msg_type;
  char *interface_name;
  DBusHandlerResult result;
  char *pcVar2;
  int iVar3;
  DBusMessage *reply;
  char *method_name;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  byte bVar7;
  char *pcVar8;
  DBusMessageIter iter;
  DBusError err;
  int local_2c;
  char **local_28;
  char *local_24;
  undefined4 local_20 [4];
  
  bVar7 = 0;
  iVar1 = dbus_message_get_type(message);
  if (iVar1 == 2) {
    pcVar8 = "pcb_dbus: DBUG: Method return message\n";
    goto LAB_080ec772;
  }
  if (iVar1 < 3) {
    if (iVar1 == 1) {
      pcVar8 = (char *)dbus_message_get_member(message);
      if (pcVar8 == (char *)0x0) {
        pcVar8 = "pcb_dbus: Method had no name specified\n";
        goto LAB_080ec772;
      }
      pcVar2 = (char *)dbus_message_get_interface(message);
      bVar6 = pcVar2 == (char *)0x0;
      if (bVar6) {
        pcVar8 = "pcb_dbus: Method had no interface specified\n";
        goto LAB_080ec772;
      }
      iVar1 = 0x12;
      pcVar4 = pcVar2;
      pcVar5 = "org.seul.geda.pcb";
      do {
        if (iVar1 == 0) break;
        iVar1 = iVar1 + -1;
        bVar6 = *pcVar4 == *pcVar5;
        pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
        pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
      } while (bVar6);
      if (bVar6) {
        iVar1 = 0xc;
        pcVar4 = pcVar8;
        pcVar5 = "GetFilename";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar6 = *pcVar4 == *pcVar5;
          pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
          pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
        } while (bVar6);
        if (!bVar6) goto LAB_080ec8ca;
        iVar1 = dbus_message_new_method_return(message);
        if (iVar1 == 0) goto LAB_080ecbe2;
        dbus_message_iter_init_append(iVar1,&iter);
        if (PCB->Filename == (char *)0x0) {
          local_24 = (char *)0x0;
LAB_080ecacf:
          local_24 = (char *)calloc(1,1);
          if (local_24 == (char *)0x0) {
            pcVar8 = "pcb_dbus: Couldn\'t strdup( \"\" ) for the filename\n";
            goto LAB_080ec981;
          }
        }
        else {
          local_24 = lrealpath(PCB->Filename);
          if (local_24 == (char *)0x0) goto LAB_080ecacf;
        }
        iVar3 = dbus_message_iter_append_basic(&iter,0x73,&local_24);
        if (iVar3 == 0) {
          __fprintf_chk(stderr,1,
                        "pcb_dbus: Couldn\'t append return filename string to message reply, Out Of Memory!\n"
                       );
          free(local_24);
          result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
          goto out;
        }
        free(local_24);
LAB_080eca95:
        iVar3 = dbus_connection_send(connection,iVar1,0);
        result = DBUS_HANDLER_RESULT_HANDLED;
        if (iVar3 != 0) goto out;
        pcVar8 = "pcb_dbus: Couldn\'t send message, Out Of Memory!\n";
      }
      else {
        iVar1 = 0x1a;
        pcVar4 = pcVar2;
        pcVar5 = "org.seul.geda.pcb.actions";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar6 = *pcVar4 == *pcVar5;
          pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
          pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
        } while (bVar6);
        if (bVar6) {
          iVar1 = 0xb;
          pcVar4 = pcVar8;
          pcVar5 = "ExecAction";
          do {
            if (iVar1 == 0) break;
            iVar1 = iVar1 + -1;
            bVar6 = *pcVar4 == *pcVar5;
            pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
            pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
          } while (bVar6);
          if (!bVar6) goto LAB_080ec8ca;
          dbus_error_init(&err);
          local_28 = (char **)0x0;
          iVar1 = dbus_message_get_args(message,&err,0x73,&local_24,0x61,0x73,&local_28,&local_2c,0)
          ;
          if (iVar1 == 0) {
            __fprintf_chk(stderr,1,"Failed to read method arguments\n");
            if (local_28 == (char **)0x0) {
              result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
              return result;
            }
            dbus_free_string_array(local_28);
            result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
            return result;
          }
          hid_actionv(local_24,local_2c,local_28);
          local_20[0] = 0;
          dbus_free_string_array(local_28);
          iVar1 = dbus_message_new_method_return(message);
          if (iVar1 == 0) goto LAB_080ecbe2;
          dbus_message_iter_init_append(iVar1,&iter);
          iVar3 = dbus_message_iter_append_basic(&iter,0x75,local_20);
          if (iVar3 == 0) {
            pcVar8 = "pcb_dbus: Couldn\'t sent message, Out Of Memory!\n";
            goto LAB_080ec981;
          }
          goto LAB_080eca95;
        }
        iVar1 = 0x24;
        pcVar4 = pcVar2;
        pcVar5 = "org.freedesktop.DBus.Introspectable";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar6 = *pcVar4 == *pcVar5;
          pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
          pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
        } while (bVar6);
        if (!bVar6) {
          __fprintf_chk(stderr,1,"pcb_dbus: Interface \'%s\' was not recognised\n",pcVar2);
          result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
          return result;
        }
        iVar1 = 0xb;
        pcVar4 = pcVar8;
        pcVar5 = "Introspect";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar6 = *pcVar4 == *pcVar5;
          pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
          pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
        } while (bVar6);
        if (!bVar6) {
LAB_080ec8ca:
          __fprintf_chk(stderr,1,"pcb_dbus: Interface \'%s\' has no method \'%s\'\n",pcVar2,pcVar8);
          result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
          return result;
        }
        iVar1 = dbus_message_new_method_return(message);
        if (iVar1 == 0) {
LAB_080ecbe2:
          pcVar8 = "pcb_dbus: Couldn\'t create reply message\n";
          goto LAB_080ec772;
        }
        dbus_message_iter_init_append(iVar1,&iter);
        iVar3 = dbus_message_iter_append_basic(&iter,0x73,&pcb_dbus_introspect_xml);
        if (iVar3 == 0) {
          pcVar8 = "pcb_dbus: Couldn\'t add introspect XML to message return\n";
        }
        else {
          iVar3 = dbus_connection_send(pcb_dbus_conn,iVar1,0);
          result = DBUS_HANDLER_RESULT_HANDLED;
          if (iVar3 != 0) goto out;
          pcVar8 = "pcb_dbus: Couldn\'t queue reply message for sending\n";
        }
      }
LAB_080ec981:
      __fprintf_chk(stderr,1,pcVar8);
      result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
out:
      dbus_message_unref(iVar1);
      return result;
    }
  }
  else {
    if (iVar1 == 3) {
      pcVar8 = "pcb_dbus: DEBUG: Error message\n";
      goto LAB_080ec772;
    }
    if (iVar1 == 4) {
      pcVar8 = "pcb_dbus: DEBUG: Signal message\n";
      goto LAB_080ec772;
    }
  }
  pcVar8 = "pcb_dbus: DEBUG: Message type wasn\'t one we know about!\n";
LAB_080ec772:
  __fprintf_chk(stderr,1,pcVar8);
  result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  return result;
}



// WARNING: Unknown calling convention

int Vx(int x)

{
  double dVar1;
  int rv;
  
  if (ghid_flip_x == 0) {
    dVar1 = (double)(x - gport->view_x0) / gport->zoom;
  }
  else {
    dVar1 = (double)((PCB->MaxWidth - x) - gport->view_x0) / gport->zoom;
  }
  return (int)ROUND(dVar1 + 0.5);
}



// WARNING: Unknown calling convention

int Vy(int y)

{
  double dVar1;
  int rv;
  
  if (ghid_flip_y == 0) {
    dVar1 = (double)(y - gport->view_y0) / gport->zoom;
  }
  else {
    dVar1 = (double)((PCB->MaxHeight - y) - gport->view_y0) / gport->zoom;
  }
  return (int)ROUND(dVar1 + 0.5);
}



// WARNING: Unknown calling convention

HID_Attribute * ghid_get_export_options(int *n_ret)

{
  return (HID_Attribute *)0x0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int ghid_set_layer(char *name,int group,int empty)

{
  int iVar1;
  uint uVar2;
  int idx;
  
  if (group < 0) {
LAB_080ecd72:
    uVar2 = group & 0xf0;
    if (uVar2 == 0x30) {
      return 1;
    }
    if (uVar2 < 0x31) {
      if (uVar2 == 0x10) {
        if ((bool)(((byte)((uint)group >> 1) ^ 1) & 1) != (Settings.ShowSolderSide != '\0')) {
          return (int)PCB->ElementOn;
        }
      }
      else if ((uVar2 == 0x20) &&
              ((bool)(((byte)((uint)group >> 1) ^ 1) & 1) != (Settings.ShowSolderSide != '\0'))) {
        return (PCB->Flags).f >> 0xd & 1;
      }
    }
    else {
      if (uVar2 == 0x40) {
        return 1;
      }
      if (uVar2 == 0x60) {
        return (int)PCB->InvisibleObjectsOn;
      }
    }
    return 0;
  }
  iVar1 = PCB->Data->LayerN;
  if (group < iVar1) {
    group = (PCB->LayerGroups).Entries[group][0];
    if (group < 0) goto LAB_080ecd72;
    if (iVar1 + 1 < group) {
      return 0;
    }
  }
  else if (iVar1 + 1 < group) {
    return 0;
  }
  return (int)PCB->Data->Layer[group].On;
}



// WARNING: Unknown calling convention

void ghid_extents_use_mask(int use_it)

{
  return;
}



// WARNING: Unknown calling convention

void ghid_notify_gui_is_up(void)

{
  ghid_gui_is_up = 1;
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_block_hook_prepare(GSource *source,gint *timeout)

{
  hidval data;
  
  (*(code *)source[1].callback_data)(source[1].callback_funcs);
  return 0;
}



// WARNING: Unknown calling convention

gboolean ghid_block_hook_check(GSource *source)

{
  return 0;
}



// WARNING: Unknown calling convention

gboolean ghid_block_hook_dispatch(GSource *source,GSourceFunc callback,gpointer user_data)

{
  return 0;
}



// WARNING: Unknown calling convention

int ghid_progress(int so_far,int total,char *message)

{
  return 0;
}



// WARNING: Unknown calling convention

int GetXY(int argc,char **argv,int x,int y)

{
  return 0;
}



// WARNING: Unknown calling convention

int flag_flipx(int x)

{
  return ghid_flip_x;
}



// WARNING: Unknown calling convention

int flag_flipy(int x)

{
  return ghid_flip_y;
}



// WARNING: Unknown calling convention

void zoom_to(double new_zoom,int x,int y)

{
  gint *pgVar1;
  gint *pgVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  double dVar8;
  GhidGui *pGVar9;
  GHidPort *pGVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  gint y0;
  int iVar13;
  gint x0;
  int iVar14;
  double max_zoom;
  gdouble ytmp;
  gdouble xtmp;
  
  dVar7 = (double)(PCB->MaxWidth / gport->width);
  dVar8 = (double)(PCB->MaxHeight / gport->height);
  if (dVar8 <= dVar7) {
    dVar8 = dVar7;
  }
  dVar7 = 1.0;
  if (1.0 <= new_zoom) {
    dVar7 = new_zoom;
  }
  if (dVar8 <= dVar7 || dVar7 != dVar8) {
    dVar7 = dVar8;
  }
  if (gport->zoom != dVar7) {
    iVar13 = gport->view_x;
    iVar4 = gport->view_x0;
    iVar5 = gport->view_y;
    iVar14 = gport->view_width;
    iVar6 = gport->view_y0;
    iVar3 = gport->view_height;
    gport->zoom = dVar7;
    pixel_slop = (int)ROUND(dVar7);
    ghid_port_ranges_scale(0);
    pGVar10 = gport;
    iVar14 = (int)ROUND((double)gport->view_x -
                        ((double)(iVar13 - iVar4) / (double)iVar14) * (double)gport->view_width);
    pgVar2 = &gport->view_y;
    pgVar1 = &gport->view_height;
    if (iVar14 < 0) {
      iVar14 = 0;
    }
    gport->view_x0 = iVar14;
    pGVar9 = ghidgui;
    iVar3 = (int)ROUND((double)*pgVar2 - ((double)(iVar5 - iVar6) / (double)iVar3) * (double)*pgVar1
                      );
    iVar13 = 0;
    if (-1 < iVar3) {
      iVar13 = iVar3;
    }
    pGVar10->view_y0 = iVar13;
    pGVar9->adjustment_changed_holdoff = 1;
    uVar11 = gtk_range_get_type();
    uVar12 = g_type_check_instance_cast(pGVar9->h_range,uVar11);
    gtk_range_set_value(uVar12,(double)iVar14);
    iVar14 = gport->view_y0;
    uVar11 = g_type_check_instance_cast(ghidgui->v_range,uVar11);
    gtk_range_set_value(uVar11,(double)iVar14);
    ghidgui->adjustment_changed_holdoff = 0;
    ghid_port_ranges_changed();
    ghid_set_status_line_label();
    return;
  }
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

int SetUnits(int argc,char **argv,int x,int y)

{
  uchar *__s1;
  char *pcVar1;
  char cVar2;
  
  if (argc != 0) {
    pcVar1 = *argv;
    cVar2 = *pcVar1;
    if ((((cVar2 == 'm') && (pcVar1[1] == 'i')) && (pcVar1[2] == 'l')) && (pcVar1[3] == '\0')) {
      Settings.grid_units_mm = '\0';
      pcVar1 = *argv;
      cVar2 = *pcVar1;
    }
    if (((cVar2 == 'm') && (pcVar1[1] == 'm')) && (pcVar1[2] == '\0')) {
      Settings.grid_units_mm = '\x01';
    }
    ghid_config_handle_units_changed();
    ghid_set_status_line_label();
  }
  return 0;
}



// WARNING: Unknown calling convention

int ScrollAction(int argc,char **argv,int x,int y)

{
  char *__s1;
  double y_00;
  gdouble x_00;
  int iVar1;
  int DeltaX;
  long lVar2;
  int div;
  gdouble dy;
  gdouble dx;
  
  if (ghidgui == (GhidGui *)0x0) {
    return 0;
  }
  if (1 < argc - 1U) {
LAB_080ed238:
    Message("Syntax error.  Usage:\n%s\n");
    return 1;
  }
  lVar2 = 0x28;
  if (argc == 2) {
    lVar2 = strtol(argv[1],(char **)0x0,10);
  }
  __s1 = *argv;
  iVar1 = strcasecmp(__s1,"up");
  if (iVar1 == 0) {
    y_00 = -(((double)ghid_port.height * gport->zoom) / (double)lVar2);
  }
  else {
    iVar1 = strcasecmp(__s1,"down");
    if (iVar1 != 0) {
      iVar1 = strcasecmp(__s1,"right");
      if (iVar1 == 0) {
        x_00 = ((double)ghid_port.width * gport->zoom) / (double)lVar2;
      }
      else {
        iVar1 = strcasecmp(__s1,"left");
        if (iVar1 != 0) goto LAB_080ed238;
        x_00 = -(((double)ghid_port.width * gport->zoom) / (double)lVar2);
      }
      iVar1 = 0;
      DeltaX = (int)ROUND(x_00);
      y_00 = 0.0;
      goto LAB_080ed179;
    }
    y_00 = ((double)ghid_port.height * gport->zoom) / (double)lVar2;
  }
  DeltaX = 0;
  iVar1 = (int)ROUND(y_00);
  x_00 = 0.0;
LAB_080ed179:
  HideCrosshair('\0');
  ghid_port_ranges_pan(x_00,y_00,1);
  MoveCrosshairRelative(DeltaX,iVar1);
  AdjustAttachedObjects();
  RestoreCrosshair('\0');
  return 0;
}



// WARNING: Unknown calling convention

int Save(int argc,char **argv,int x,int y)

{
  int iVar1;
  gchar *pgVar2;
  char *prompt;
  FILE *__stream;
  FILE *exist;
  gchar *message;
  gboolean gVar3;
  char *__s1;
  char *function;
  char *name;
  
  if (1 < argc) {
    iVar1 = hid_actionv("SaveTo",argc,argv);
    return iVar1;
  }
  __s1 = "Layout";
  if (argc != 0) {
    __s1 = *argv;
  }
  iVar1 = strcasecmp(__s1,"Layout");
  if ((iVar1 == 0) && (PCB->Filename != (char *)0x0)) {
    iVar1 = hid_actionl("SaveTo");
    return iVar1;
  }
  iVar1 = strcasecmp(__s1,"PasteBuffer");
  if (iVar1 == 0) {
    pgVar2 = (gchar *)dcgettext(&DAT_0815492c,"Save element as",5);
  }
  else {
    pgVar2 = (gchar *)dcgettext(&DAT_0815492c,"Save layout as",5);
  }
  pgVar2 = ghid_dialog_file_select_save(pgVar2,&Save::current_dir,PCB->Filename,Settings.FilePath);
  if (pgVar2 == (gchar *)0x0) {
    return 1;
  }
  __stream = fopen(pgVar2,"r");
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
    message = (gchar *)dcgettext(&DAT_0815492c,"File exists!  Ok to overwrite?",5);
    gVar3 = ghid_dialog_confirm(message,(gchar *)0x0,(gchar *)0x0);
    if (gVar3 == 0) {
      g_free(pgVar2);
      return 1;
    }
    if (Settings.verbose == 0) goto LAB_080ed3f0;
    __fprintf_chk(stderr,1,"Overwriting %s\n",pgVar2);
  }
  if (Settings.verbose != 0) {
    __fprintf_chk(stderr,1,"%s:  Calling SaveTo(%s, %s)\n","Save",__s1,pgVar2);
  }
LAB_080ed3f0:
  iVar1 = strcasecmp(__s1,"PasteBuffer");
  if (iVar1 == 0) {
    hid_actionl("PasteBuffer","Save",pgVar2,0);
  }
  else {
    iVar1 = strcasecmp(__s1,"Layout");
    if (iVar1 == 0) {
      hid_actionl("SaveTo","LayoutAs",pgVar2,0);
    }
    else {
      hid_actionl("SaveTo",__s1,pgVar2,0);
    }
  }
  g_free(pgVar2);
  return 0;
}



// WARNING: Unknown calling convention

int RouteStylesChanged(int argc,char **argv,int x,int y)

{
  gchar *name;
  
  if ((PCB != (PCBTypePtr)0x0) && (name = PCB->RouteStyle[0].Name, name != (gchar *)0x0)) {
    ghid_route_style_set_button_label(name,0);
    ghid_route_style_set_button_label(PCB->RouteStyle[1].Name,1);
    ghid_route_style_set_button_label(PCB->RouteStyle[2].Name,2);
    ghid_route_style_set_button_label(PCB->RouteStyle[3].Name,3);
  }
  return 0;
}



// WARNING: Unknown calling convention

int PrintCalibrate(int argc,char **argv,int x,int y)

{
  HID *pHVar1;
  int iVar2;
  HID_conflict1 *printer;
  
  pHVar1 = hid_find_printer();
  (*pHVar1->calibrate)(0.0,0.0);
  iVar2 = (*gui->attribute_dialog)
                    (printer_calibrate_attrs,3,printer_calibrate_values,"Printer Calibration Values"
                     ,"Enter calibration values for your printer");
  if (iVar2 == 0) {
    (*pHVar1->calibrate)
              (printer_calibrate_values[1].real_value,printer_calibrate_values[2].real_value);
  }
  return (uint)(iVar2 != 0);
}



// WARNING: Unknown calling convention

int Print(int argc,char **argv,int x,int y)

{
  HID_conflict1 **ppHVar1;
  _func_void_char_ptr_varargs *p_Var2;
  Boolean BVar3;
  HID_conflict1 **ppHVar4;
  HID_conflict1 **hids;
  char *pcVar5;
  HID_conflict1 *exporter;
  HID_conflict1 *printer;
  HID_conflict1 *pHVar6;
  
  ppHVar4 = (HID_conflict1 **)hid_enumerate();
  if (*ppHVar4 != (HID_conflict1 *)0x0) {
    exporter = (HID_conflict1 *)0x0;
    pHVar6 = *ppHVar4;
    do {
      ppHVar1 = ppHVar4 + 1;
      if ((pHVar6->field_0xc & 2) == 0) {
        pHVar6 = exporter;
      }
      exporter = pHVar6;
      ppHVar4 = ppHVar4 + 1;
      pHVar6 = *ppHVar1;
    } while (*ppHVar1 != (HID_conflict1 *)0x0);
    if (exporter != (HID_conflict1 *)0x0) {
      BVar3 = IsDataEmpty(PCB->Data);
      if (BVar3 != '\0') {
        p_Var2 = gui->log;
        pcVar5 = (char *)dcgettext(&DAT_0815492c,"Can\'t print empty layout",5);
        (*p_Var2)(pcVar5);
        return 0;
      }
      ghid_dialog_print(exporter);
      return 0;
    }
  }
  p_Var2 = gui->log;
  pcVar5 = (char *)dcgettext(&DAT_0815492c,"Can\'t find a suitable printer HID",5);
  (*p_Var2)(pcVar5);
  return -1;
}



// WARNING: Unknown calling convention

int Popup(int argc,char **argv,int x,int y)

{
  size_t sVar1;
  void *__ptr;
  int **ppiVar2;
  int iVar3;
  int iVar4;
  gboolean __r;
  undefined4 uVar5;
  undefined4 uVar6;
  GType __t;
  long lVar7;
  guint button;
  GtkWidget *menu;
  
  if (1 < argc - 1U) {
    Message("Syntax error.  Usage:\n%s\n","Popup(MenuName, [Button])");
    return 1;
  }
  lVar7 = 0;
  if (argc != 1) {
    lVar7 = strtol(argv[1],(char **)0x0,10);
  }
  sVar1 = strlen(*argv);
  __ptr = calloc(1,sVar1 + 2);
  if (__ptr == (void *)0x0) {
    __fprintf_chk(stderr,1,"Popup():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  __sprintf_chk(__ptr,1,0xffffffff,"/%s",*argv);
  __printf_chk(1,"Loading popup \"%s\". Button = %u\n",__ptr,lVar7);
  ppiVar2 = (int **)gtk_ui_manager_get_widget(ghidgui->ui_manager,__ptr);
  free(__ptr);
  iVar3 = gtk_menu_get_type();
  if (ppiVar2 != (int **)0x0) {
    if ((*ppiVar2 == (int *)0x0) || (**ppiVar2 != iVar3)) {
      iVar4 = g_type_check_instance_is_a(ppiVar2,iVar3);
      if (iVar4 == 0) goto LAB_080ed8d0;
    }
    ghidgui->in_popup = 1;
    gtk_widget_grab_focus(ghid_port.drawing_area);
    uVar5 = gtk_get_current_event_time();
    uVar6 = g_type_check_instance_cast(ppiVar2,iVar3);
    gtk_menu_popup(uVar6,0,0,0,0,0,uVar5);
    return 0;
  }
LAB_080ed8d0:
  Message("The specified popup menu \"%s\" has not been defined.\n",*argv);
  return 1;
}



// WARNING: Unknown calling convention

int LayerGroupsChanged(int argc,char **argv,int x,int y)

{
  __printf_chk(1,"LayerGroupsChanged -- not implemented\n");
  return 0;
}



// WARNING: Unknown calling convention

void ghid_calibrate(double xval,double yval)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_extents_fill_rect(hidGC_conflict1 gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_extents_fill_polygon(hidGC_conflict1 gc,int n_coords,int *x,int *y)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_extents_fill_circle(hidGC_conflict1 gc,int cx,int cy,int radius)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_extents_draw_rect(hidGC_conflict1 gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_extents_draw_arc
               (hidGC_conflict1 gc,int cx,int cy,int xradius,int yradius,int start_angle,
               int delta_angle)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_extents_draw_line(hidGC_conflict1 gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_set_line_cap_angle(hidGC_conflict1 gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention

void ghid_set_draw_faded(hidGC_conflict1 gc,int faded)

{
  __printf_chk(1,"ghid_set_draw_faded(%p,%d) -- not implemented\n",gc,faded);
  return;
}



// WARNING: Unknown calling convention

int PointCursor(int argc,char **argv,int x,int y)

{
  if (ghidgui != (GhidGui *)0x0) {
    if (argc < 1) {
      ghid_mode_cursor(Settings.Mode);
      return 0;
    }
    ghid_point_cursor();
  }
  return 0;
}



// WARNING: Unknown calling convention

gboolean ghid_watch(GIOChannel *source,GIOCondition condition,gpointer data)

{
  uint pcb_condition;
  
  pcb_condition = condition & G_IO_IN;
  if ((condition & G_IO_OUT) != 0) {
    pcb_condition = pcb_condition | 2;
  }
  if ((condition & G_IO_ERR) != 0) {
    pcb_condition = pcb_condition | 4;
  }
  if ((condition & G_IO_HUP) != 0) {
    pcb_condition = pcb_condition | 8;
  }
                    // WARNING: Load size is inaccurate
  (**data)(data,*(undefined4 *)((int)data + 8),pcb_condition,*(undefined4 *)((int)data + 4));
  ghid_mode_cursor(Settings.Mode);
  return 1;
}



// WARNING: Unknown calling convention

gboolean ghid_timer(GuiTimer *timer)

{
  (*timer->func)((timer->user_data).lval);
  ghid_mode_cursor(Settings.Mode);
  return 0;
}



// WARNING: Unknown calling convention

int PanAction(int argc,char **argv,int x,int y)

{
  int iVar1;
  int mode;
  
  if (ghidgui != (GhidGui *)0x0) {
    if (1 < argc - 1U) {
      Message("Syntax error.  Usage:\n%s\n","Pan([thumb], Mode)");
      return 1;
    }
    if (argc == 1) {
      iVar1 = strtol(*argv,(char **)0x0,10);
      gport->panning = iVar1;
    }
    else {
      iVar1 = strtol(argv[1],(char **)0x0,10);
      Message(
             "The gtk gui currently ignores the optional first argumentto the Pan action.\nFeel free to provide patches.\n"
             );
      gport->panning = iVar1;
    }
    if (iVar1 == 1) {
      PanAction::on_y = y;
      PanAction::on_x = x;
      return 0;
    }
    if ((x == PanAction::on_x) && (y == PanAction::on_y)) {
      ghid_show_crosshair(0);
      ghidgui->auto_pan_on = (uint)(ghidgui->auto_pan_on == 0);
      ghid_show_crosshair(1);
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int Load(int argc,char **argv,int x,int y)

{
  char *shortcuts;
  int iVar1;
  gchar *pgVar2;
  char *__s1;
  char *function;
  char *name;
  char *pcVar3;
  
  if (1 < argc) {
    iVar1 = hid_actionv("LoadFrom",argc,argv);
    return iVar1;
  }
  __s1 = "Layout";
  if (argc != 0) {
    __s1 = *argv;
  }
  iVar1 = strcasecmp(__s1,"Netlist");
  pcVar3 = Settings.FilePath;
  if (iVar1 == 0) {
    pgVar2 = (gchar *)dcgettext(&DAT_0815492c,"Load netlist file",5);
    pgVar2 = ghid_dialog_file_select_open(pgVar2,&Load::current_netlist_dir,pcVar3);
  }
  else {
    iVar1 = strcasecmp(__s1,"ElementToBuffer");
    pcVar3 = Settings.LibraryTree;
    if (iVar1 == 0) {
      pgVar2 = (gchar *)dcgettext(&DAT_0815492c,"Load element to buffer",5);
      pgVar2 = ghid_dialog_file_select_open(pgVar2,&Load::current_element_dir,pcVar3);
    }
    else {
      iVar1 = strcasecmp(__s1,"LayoutToBuffer");
      if (iVar1 == 0) {
        pcVar3 = "Load layout file to buffer";
      }
      else {
        iVar1 = strcasecmp(__s1,"Layout");
        if (iVar1 != 0) {
          return 0;
        }
        pcVar3 = "Load layout file";
      }
      shortcuts = Settings.FilePath;
      pgVar2 = (gchar *)dcgettext(&DAT_0815492c,pcVar3,5);
      pgVar2 = ghid_dialog_file_select_open(pgVar2,&Load::current_layout_dir,shortcuts);
    }
  }
  if (pgVar2 == (gchar *)0x0) {
    return 0;
  }
  if (Settings.verbose != 0) {
    __fprintf_chk(stderr,1,"%s:  Calling LoadFrom(%s, %s)\n","Load",__s1,pgVar2);
  }
  hid_actionl("LoadFrom",__s1,pgVar2,0);
  g_free(pgVar2);
  return 0;
}



// WARNING: Unknown calling convention

int LibraryChanged(int argc,char **argv,int x,int y)

{
  ghid_library_window_show(&ghid_port,0);
  return 0;
}



// WARNING: Unknown calling convention

int Export(int argc,char **argv,int x,int y)

{
  _func_void_char_ptr_varargs *p_Var1;
  Boolean BVar2;
  char *pcVar3;
  
  BVar2 = IsDataEmpty(PCB->Data);
  if (BVar2 != '\0') {
    p_Var1 = gui->log;
    pcVar3 = (char *)dcgettext(&DAT_0815492c,"Can\'t export empty layout",5);
    (*p_Var1)(pcVar3);
    return 0;
  }
  ghid_dialog_export();
  return 0;
}



// WARNING: Unknown calling convention

int DoWindows(int argc,char **argv,int x,int y)

{
  char cVar1;
  int iVar2;
  char *__s1;
  char *a;
  
  __s1 = "";
  if (argc == 1) {
    __s1 = *argv;
  }
  cVar1 = *__s1;
  if (((cVar1 == '1') && (__s1[1] == '\0')) || (iVar2 = strcasecmp(__s1,"Layout"), iVar2 == 0)) {
    return 0;
  }
  if (((cVar1 == '2') && (__s1[1] == '\0')) || (iVar2 = strcasecmp(__s1,"Library"), iVar2 == 0)) {
    ghid_library_window_show(gport,1);
    return 0;
  }
  if (((cVar1 != '3') || (__s1[1] != '\0')) && (iVar2 = strcasecmp(__s1,"Log"), iVar2 != 0)) {
    if (((cVar1 == '4') && (__s1[1] == '\0')) || (iVar2 = strcasecmp(__s1,"Netlist"), iVar2 == 0)) {
      ghid_netlist_window_show(gport,1);
      return 0;
    }
    if (((cVar1 != '5') || (__s1[1] != '\0')) &&
       (iVar2 = strcasecmp(__s1,"Preferences"), iVar2 != 0)) {
      if (((cVar1 != '6') || (__s1[1] != '\0')) && (iVar2 = strcasecmp(__s1,"DRC"), iVar2 != 0)) {
        Message("Syntax error.  Usage:\n%s\n",
                "DoWindows(1|2|3|4|5|6)\nDoWindows(Layout|Library|Log|Netlist|Preferences|DRC)");
        return 1;
      }
      ghid_drc_window_show(1);
      return 0;
    }
    ghid_config_window_show();
    return 0;
  }
  ghid_log_window_show(1);
  return 0;
}



// WARNING: Unknown calling convention

int CursorAction(int argc,char **argv,int x,int y)

{
  double dVar1;
  char *pcVar2;
  double dVar3;
  int iVar4;
  int iVar5;
  int pan_warp;
  double yu;
  double xu;
  double local_24;
  double local_1c;
  
  if (argc != 4) {
LAB_080ee268:
    Message("Syntax error.  Usage:\n%s\n","Cursor(Type,DeltaUp,DeltaRight,Units)");
    return 1;
  }
  pcVar2 = *argv;
  iVar4 = strcasecmp(pcVar2,"pan");
  if (iVar4 == 0) {
    iVar4 = 2;
  }
  else {
    iVar4 = 1;
    iVar5 = strcasecmp(pcVar2,"warp");
    if (iVar5 != 0) goto LAB_080ee268;
  }
  local_24 = strtod(argv[1],(char **)0x0);
  if (ghid_flip_x != 0) {
    local_24 = -local_24;
  }
  local_1c = strtod(argv[2],(char **)0x0);
  if (ghid_flip_y == 0) {
    local_1c = -local_1c;
  }
  pcVar2 = argv[3];
  iVar5 = strncasecmp(pcVar2,"mm",2);
  if (iVar5 == 0) {
    dVar1 = 3937.007874;
    dVar3 = 3937.007874;
  }
  else {
    iVar5 = strncasecmp(pcVar2,"mil",3);
    if (iVar5 == 0) {
      dVar1 = 100.0;
      dVar3 = 100.0;
    }
    else {
      iVar5 = strncasecmp(pcVar2,"grid",4);
      if (iVar5 == 0) {
        dVar1 = PCB->Grid;
        dVar3 = dVar1;
      }
      else {
        iVar5 = strncasecmp(pcVar2,"view",4);
        if (iVar5 == 0) {
          dVar1 = (double)gport->view_width / 100.0;
          dVar3 = (double)gport->view_height / 100.0;
        }
        else {
          iVar5 = strncasecmp(pcVar2,"board",4);
          if (iVar5 == 0) {
            dVar1 = (double)PCB->MaxWidth / 100.0;
            dVar3 = (double)PCB->MaxHeight / 100.0;
          }
          else {
            dVar1 = 0.0;
            dVar3 = 0.0;
          }
        }
      }
    }
  }
  EventMoveCrosshair((int)ROUND(dVar1 * local_24) + Crosshair.X,
                     (int)ROUND(dVar3 * local_1c) + Crosshair.Y);
  (*gui->set_crosshair)(Crosshair.X,Crosshair.Y,iVar4);
  return 0;
}



// WARNING: Unknown calling convention

int Command(int argc,char **argv,int x,int y)

{
  ghid_handle_user_command(1);
  return 0;
}



// WARNING: Unknown calling convention

int Busy(int argc,char **argv,int x,int y)

{
  ghid_watch_cursor();
  return 0;
}



// WARNING: Unknown calling convention

int Benchmark(int argc,char **argv,int x,int y)

{
  undefined4 uVar1;
  int iVar2;
  int i;
  GdkDisplay *display;
  BoxType region;
  int local_24;
  int local_20 [4];
  
  iVar2 = 0;
  uVar1 = gdk_drawable_get_display(gport->drawable);
  region.X1 = 0;
  region.Y1 = 0;
  region.X2 = PCB->MaxWidth;
  region.Y2 = PCB->MaxHeight;
  gdk_display_sync(uVar1);
  time(local_20);
  do {
    iVar2 = iVar2 + 1;
    hid_expose_callback((HID *)&ghid_hid,&region,(void *)0x0);
    gdk_display_sync(uVar1);
    time(&local_24);
  } while (local_24 - local_20[0] < 10);
  __printf_chk(1,"%g redraws per second\n",(double)((float)iVar2 / 10.0));
  return 0;
}



// WARNING: Unknown calling convention

int About(int argc,char **argv,int x,int y)

{
  ghid_dialog_about();
  return 0;
}



// WARNING: Unknown calling convention

void ghid_stop_block_hook(hidval mlpoll)

{
  g_source_destroy();
  return;
}



// WARNING: Unknown calling convention

hidval ghid_add_block_hook(_func_void_hidval *func,hidval user_data)

{
  int iVar1;
  int *in_stack_00000004;
  
  iVar1 = g_source_new(&ghid_block_hook_funcs,0x3c);
  *(_func_void_hidval **)(iVar1 + 0x34) = func;
  *(hidval *)(iVar1 + 0x38) = user_data;
  g_source_attach(iVar1,0);
  *in_stack_00000004 = iVar1;
  return (hidval)in_stack_00000004;
}



// WARNING: Unknown calling convention

void register_ghid_main_flag_list(void)

{
  hid_register_flags(ghid_main_flag_list,2);
  return;
}



// WARNING: Unknown calling convention

void register_ghid_main_action_list(void)

{
  hid_register_actions(ghid_main_action_list,0x18);
  return;
}



// WARNING: Unknown calling convention

void hid_gtk_init(void)

{
  hid_register_hid((HID *)&ghid_hid);
  apply_default_hid((HID *)&ghid_extents,(HID *)&ghid_hid);
  register_ghid_main_action_list();
  register_ghid_main_flag_list();
  register_ghid_netlist_action_list();
  register_ghid_attribute_list();
  register_gtk_topwindow_action_list();
  register_pcbmenu_attr();
  register_ghid_menu_action_list();
  return;
}



// WARNING: Unknown calling convention

int PCBChanged(int argc,char **argv,int x,int y)

{
  if (ghidgui != (GhidGui *)0x0) {
    ghid_window_set_name_label(PCB->Name);
    if (gport->pixmap != (GdkPixmap *)0x0) {
      RouteStylesChanged(0,(char **)0x0,0,0);
      ghid_port_ranges_scale(1);
      ghid_port_ranges_pan(0.0,0.0,0);
      ghid_port_ranges_zoom(0.0);
      ghid_port_ranges_changed();
      ghid_sync_with_new_layout();
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void ghid_beep(void)

{
  gdk_beep();
  return;
}



// WARNING: Unknown calling convention

void ghid_show_item(void *item)

{
  ghid_pinout_window_show(&ghid_port,(ElementType *)item);
  return;
}



// WARNING: Unknown calling convention

char * ghid_prompt_for(char *msg,char *default_string)

{
  gchar *pgVar1;
  
  pgVar1 = ghid_dialog_input(msg,default_string);
  return pgVar1;
}



// WARNING: Unknown calling convention

void ghid_report_dialog(char *title,char *msg)

{
  ghid_dialog_report(title,msg);
  return;
}



// WARNING: Unknown calling convention

int ghid_close_confirm_dialog(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = ghid_dialog_close_confirm();
  iVar2 = 1;
  if ((iVar1 != 1) && (iVar2 = 0, iVar1 == 2)) {
    iVar1 = hid_actionl("Save",0);
    return (uint)(iVar1 == 0);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int ghid_confirm_dialog(char *msg,...)

{
  int rv;
  char *okmsg;
  gboolean gVar1;
  char *cancelmsg;
  gchar *in_stack_00000008;
  gchar *in_stack_0000000c;
  
  if (in_stack_00000008 == (gchar *)0x0) {
    in_stack_00000008 = (gchar *)dcgettext(&DAT_0815492c,"_Cancel",5);
    in_stack_0000000c = (gchar *)dcgettext(&DAT_0815492c,&DAT_08152330,5);
  }
  if (in_stack_0000000c == (gchar *)0x0) {
    in_stack_0000000c = (gchar *)dcgettext(&DAT_0815492c,&DAT_08152330,5);
  }
  gVar1 = ghid_dialog_confirm(msg,in_stack_00000008,in_stack_0000000c);
  return gVar1;
}



// WARNING: Unknown calling convention

void ghid_unwatch_file(hidval data)

{
  g_io_channel_shutdown(*(undefined4 *)(data.lval + 0xc),1,0);
  g_io_channel_unref(*(undefined4 *)(data.lval + 0xc));
  g_free();
  return;
}



// WARNING: Unknown calling convention

hidval ghid_watch_file(int fd,uint condition,_func_void_hidval_int_uint_hidval *func,
                      hidval user_data)

{
  _func_void_hidval_int_uint_hidval **pp_Var1;
  _func_void_hidval_int_uint_hidval *p_Var2;
  uint glib_condition;
  int *in_stack_00000004;
  
  pp_Var1 = (_func_void_hidval_int_uint_hidval **)g_malloc0(0x14);
  glib_condition = condition & 1;
  if ((condition & 2) != 0) {
    glib_condition = glib_condition | 4;
  }
  if ((condition & 4) != 0) {
    glib_condition = glib_condition | 8;
  }
  if ((condition & 8) != 0) {
    glib_condition = glib_condition | 0x10;
  }
  pp_Var1[2] = (_func_void_hidval_int_uint_hidval *)fd;
  *pp_Var1 = func;
  *(hidval *)(pp_Var1 + 1) = user_data;
  p_Var2 = (_func_void_hidval_int_uint_hidval *)g_io_channel_unix_new(fd);
  pp_Var1[3] = p_Var2;
  p_Var2 = (_func_void_hidval_int_uint_hidval *)
           g_io_add_watch(p_Var2,glib_condition,ghid_watch,pp_Var1);
  pp_Var1[4] = p_Var2;
  *in_stack_00000004 = (int)pp_Var1;
  return (hidval)in_stack_00000004;
}



// WARNING: Unknown calling convention

void ghid_stop_timer(hidval timer)

{
  gtk_timeout_remove(*(undefined4 *)(timer.lval + 4));
  g_free();
  return;
}



// WARNING: Unknown calling convention

hidval ghid_add_timer(_func_void_hidval *func,ulong milliseconds,hidval user_data)

{
  _func_void_hidval **pp_Var1;
  _func_void_hidval *p_Var2;
  int *in_stack_00000004;
  
  pp_Var1 = (_func_void_hidval **)g_malloc0(0xc);
  *pp_Var1 = func;
  *(hidval *)(pp_Var1 + 2) = user_data;
  p_Var2 = (_func_void_hidval *)gtk_timeout_add(milliseconds,ghid_timer,pp_Var1);
  pp_Var1[1] = p_Var2;
  *in_stack_00000004 = (int)pp_Var1;
  return (hidval)in_stack_00000004;
}



// WARNING: Unknown calling convention

gboolean ghid_mod1_is_pressed(void)

{
  uint local_10 [3];
  
  if (ghid_gui_is_up == 0) {
    return 0;
  }
  gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  return local_10[0] >> 3 & 1;
}



// WARNING: Unknown calling convention

gboolean ghid_control_is_pressed(void)

{
  uint local_10 [3];
  
  if (ghid_gui_is_up == 0) {
    return 0;
  }
  gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  return local_10[0] >> 2 & 1;
}



// WARNING: Unknown calling convention

gboolean ghid_shift_is_pressed(void)

{
  uint local_10 [3];
  
  if (ghid_gui_is_up == 0) {
    return 0;
  }
  gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  return local_10[0] & 1;
}



// WARNING: Unknown calling convention

void ghid_set_line_width(hidGC_conflict1 gc,int width)

{
  GdkGC *pGVar1;
  
  pGVar1 = gc->gc;
  gc->width = width;
  if (pGVar1 != (GdkGC *)0x0) {
    if (cur_mask == 2) {
      pGVar1 = gport->mask_gc;
    }
    gdk_gc_set_line_attributes
              (pGVar1,(int)ROUND((double)width / gport->zoom + 0.5),0,gc->cap,gc->join);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_set_line_cap(hidGC_conflict1 gc,EndCapStyle style)

{
  GdkGC *pGVar1;
  
  if (style != Square_Cap) {
    if ((style == Trace_Cap) || (style == Round_Cap)) {
      gc->cap = 2;
      gc->join = 1;
      goto LAB_080eea33;
    }
    if (style != Beveled_Cap) goto LAB_080eea33;
  }
  gc->cap = 3;
  gc->join = 0;
LAB_080eea33:
  pGVar1 = gc->gc;
  if (pGVar1 != (GdkGC *)0x0) {
    if (cur_mask == 2) {
      pGVar1 = gport->mask_gc;
    }
    gdk_gc_set_line_attributes
              (pGVar1,(int)ROUND((double)gc->width / gport->zoom + 0.5),0,gc->cap,gc->join);
  }
  return;
}



// WARNING: Unknown calling convention

void set_special_grid_color(void)

{
  guint16 *pgVar1;
  GHidPort *pGVar2;
  
  pGVar2 = gport;
  if (gport->colormap != (GdkColormap *)0x0) {
    pgVar1 = &(gport->grid_color).red;
    *pgVar1 = *pgVar1 ^ (gport->bg_color).red;
    pgVar1 = &(pGVar2->grid_color).green;
    *pgVar1 = *pgVar1 ^ (pGVar2->bg_color).green;
    pgVar1 = &(pGVar2->grid_color).blue;
    *pgVar1 = *pgVar1 ^ (pGVar2->bg_color).blue;
    gdk_color_alloc(pGVar2->colormap,&pGVar2->grid_color);
    if (gport->grid_gc != (GdkGC *)0x0) {
      gdk_gc_set_foreground(gport->grid_gc,&gport->grid_color);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_set_color(hidGC_conflict1 gc,char *name)

{
  GdkColor *pGVar1;
  GHidPort *pGVar2;
  GdkColormap *pGVar3;
  int iVar4;
  uint uVar5;
  char *pcVar6;
  ColorCache *cc;
  char *pcVar7;
  undefined uVar8;
  byte bVar9;
  hidval cval;
  
  bVar9 = 0;
  if (name == (char *)0x0) {
    __fprintf_chk(stderr,1,"%s():  name = NULL, setting to magenta\n","ghid_set_color");
    name = "magenta";
  }
  gc->colorname = name;
  pGVar2 = gport;
  if (gc->gc != (GdkGC *)0x0) {
    uVar8 = gport->colormap == (GdkColormap *)0x0;
    if ((bool)uVar8) {
      pGVar3 = (GdkColormap *)gtk_widget_get_colormap(gport->top_window);
      pGVar2->colormap = pGVar3;
    }
    iVar4 = 6;
    pcVar6 = name;
    pcVar7 = "erase";
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      uVar8 = *pcVar6 == *pcVar7;
      pcVar6 = pcVar6 + (uint)bVar9 * -2 + 1;
      pcVar7 = pcVar7 + (uint)bVar9 * -2 + 1;
    } while ((bool)uVar8);
    if ((bool)uVar8) {
      gdk_gc_set_foreground(gc->gc,&gport->bg_color);
      gc->erase = '\x01';
    }
    else {
      iVar4 = 6;
      pcVar6 = name;
      pcVar7 = "drill";
      do {
        if (iVar4 == 0) break;
        iVar4 = iVar4 + -1;
        uVar8 = *pcVar6 == *pcVar7;
        pcVar6 = pcVar6 + (uint)bVar9 * -2 + 1;
        pcVar7 = pcVar7 + (uint)bVar9 * -2 + 1;
      } while ((bool)uVar8);
      if ((bool)uVar8) {
        gdk_gc_set_foreground(gc->gc,&gport->offlimits_color);
        gc->erase = '\0';
      }
      else {
        iVar4 = hid_cache_color(0,name,&cval,&ghid_set_color::cache);
        cc = (ColorCache *)cval;
        if (iVar4 == 0) {
          cc = (ColorCache *)calloc(1,0x20);
          uVar5 = 0;
          do {
            *(undefined4 *)((int)cc + uVar5) = 0;
            uVar5 = uVar5 + 4;
          } while (uVar5 < 0x20);
          cval = (hidval)(hidval)cc;
          hid_cache_color(1,name,&cval,&ghid_set_color::cache);
        }
        if (cc->color_set == 0) {
          pGVar1 = &cc->color;
          iVar4 = gdk_color_parse(name,pGVar1);
          if (iVar4 == 0) {
            gdk_color_white(gport->colormap,pGVar1);
          }
          else {
            gdk_color_alloc(gport->colormap,pGVar1);
          }
          cc->color_set = 1;
        }
        pGVar2 = gport;
        if (gc->xor == '\0') {
          gdk_gc_set_foreground(gc->gc,&cc->color);
        }
        else {
          if (cc->xor_set == 0) {
            (cc->xor_color).red = (gport->bg_color).red ^ (cc->color).red;
            (cc->xor_color).green = (pGVar2->bg_color).green ^ (cc->color).green;
            (cc->xor_color).blue = (pGVar2->bg_color).blue ^ (cc->color).blue;
            gdk_color_alloc(pGVar2->colormap,&cc->xor_color);
            cc->xor_set = 1;
          }
          gdk_gc_set_foreground(gc->gc,&cc->xor_color);
        }
        gc->erase = '\0';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_set_draw_xor(hidGC_conflict1 gc,int xor)

{
  gc->xor = (gchar)xor;
  if (gc->gc != (GdkGC *)0x0) {
    gdk_gc_set_function(gc->gc,~-(xor == 0) & 2);
    ghid_set_color(gc,gc->colorname);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int use_gc(hidGC_conflict1 gc)

{
  int iVar1;
  GdkGC *pGVar2;
  
  iVar1 = 0;
  if (gport->pixmap != (GdkPixmap *)0x0) {
    if (gc->gc == (GdkGC *)0x0) {
      pGVar2 = (GdkGC *)gdk_gc_new(gport->top_window->window);
      gc->gc = pGVar2;
      ghid_set_color(gc,gc->colorname);
      ghid_set_line_width(gc,gc->width);
      ghid_set_line_cap(gc,gc->cap);
      ghid_set_draw_xor(gc,(int)gc->xor);
    }
    if (gc->mask_seq != mask_seq) {
      if (mask_seq == 0) {
        gdk_gc_set_clip_mask(gc->gc,0);
      }
      else {
        gdk_gc_set_clip_mask(gc->gc,gport->mask);
      }
      gc->mask_seq = mask_seq;
    }
    if (cur_mask == 2) {
      pGVar2 = gport->mask_gc;
    }
    else {
      pGVar2 = gc->gc;
    }
    gport->u_gc = pGVar2;
    iVar1 = 1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void ghid_fill_circle(hidGC_conflict1 gc,int cx,int cy,int radius)

{
  GHidPort *pGVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  gint vr;
  
  iVar4 = cx;
  if (ghid_flip_x != 0) {
    iVar4 = PCB->MaxWidth - cx;
  }
  if (gport->view_x0 - radius <= iVar4) {
    iVar4 = cx;
    if (ghid_flip_x != 0) {
      iVar4 = PCB->MaxWidth - cx;
    }
    if (iVar4 <= (int)ROUND((double)gport->width * gport->zoom) + gport->view_x0 + radius) {
      iVar4 = cy;
      if (ghid_flip_y != 0) {
        iVar4 = PCB->MaxHeight - cy;
      }
      if (gport->view_y0 - radius <= iVar4) {
        iVar4 = cy;
        if (ghid_flip_y != 0) {
          iVar4 = PCB->MaxHeight - cy;
        }
        if ((iVar4 <= (int)ROUND((double)gport->height * gport->zoom) + gport->view_y0 + radius) &&
           (iVar4 = use_gc(gc), pGVar1 = gport, iVar4 != 0)) {
          iVar4 = (int)ROUND((double)radius / gport->zoom + 0.5);
          iVar2 = Vy(cy);
          iVar3 = Vx(cx);
          gdk_draw_arc(pGVar1->drawable,pGVar1->u_gc,1,iVar3 - iVar4,iVar2 - iVar4,iVar4 * 2,
                       iVar4 * 2,0,0x5a00);
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_draw_arc(hidGC_conflict1 gc,int cx,int cy,int xradius,int yradius,int start_angle,
                  int delta_angle)

{
  GHidPort *pGVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  gint radius;
  int iVar5;
  gint vry;
  
  iVar2 = xradius;
  if (xradius <= yradius) {
    iVar2 = yradius;
  }
  iVar5 = cx;
  if (ghid_flip_x != 0) {
    iVar5 = PCB->MaxWidth - cx;
  }
  if (gport->view_x0 - iVar2 <= iVar5) {
    iVar5 = cx;
    if (ghid_flip_x != 0) {
      iVar5 = PCB->MaxWidth - cx;
    }
    if (iVar5 <= (int)ROUND((double)gport->width * gport->zoom) + gport->view_x0 + iVar2) {
      iVar5 = cy;
      if (ghid_flip_y != 0) {
        iVar5 = PCB->MaxHeight - cy;
      }
      if (gport->view_y0 - iVar2 <= iVar5) {
        iVar5 = cy;
        if (ghid_flip_y != 0) {
          iVar5 = PCB->MaxHeight - cy;
        }
        if ((iVar5 <= (int)ROUND((double)gport->height * gport->zoom) + gport->view_y0 + iVar2) &&
           (iVar2 = use_gc(gc), pGVar1 = gport, iVar2 != 0)) {
          iVar2 = (int)ROUND((double)xradius / gport->zoom + 0.5);
          iVar5 = (int)ROUND(gport->zoom / (double)yradius + 0.5);
          if (ghid_flip_x != 0) {
            delta_angle = -delta_angle;
            start_angle = 0xb4 - start_angle;
          }
          if (ghid_flip_y != 0) {
            start_angle = -start_angle;
            delta_angle = -delta_angle;
          }
          iVar3 = Vy(cy);
          iVar4 = Vx(cx);
          gdk_draw_arc(pGVar1->drawable,pGVar1->u_gc,0,iVar4 - iVar2,iVar3 - iVar5,iVar2 * 2,
                       iVar5 * 2,((start_angle + 0x21c) % 0x168) * 0x40,delta_angle << 6);
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_set_special_colors(HID_Attribute *ha)

{
  char **ppcVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  
  pcVar4 = ha->name;
  if (pcVar4 == (char *)0x0) {
    return;
  }
  ppcVar1 = (char **)ha->value;
  bVar6 = ppcVar1 == (char **)0x0;
  if (bVar6) {
    return;
  }
  iVar2 = 0x11;
  pcVar3 = pcVar4;
  pcVar5 = "background-color";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar6 = *pcVar3 == *pcVar5;
    pcVar3 = pcVar3 + 1;
    pcVar5 = pcVar5 + 1;
  } while (bVar6);
  if ((!bVar6) || (bVar6 = gport->bg_gc == (GdkGC *)0x0, bVar6)) {
    iVar2 = 0x10;
    pcVar3 = pcVar4;
    pcVar5 = "off-limit-color";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar6 = *pcVar3 == *pcVar5;
      pcVar3 = pcVar3 + 1;
      pcVar5 = pcVar5 + 1;
    } while (bVar6);
    if ((bVar6) && (bVar6 = gport->offlimits_gc == (GdkGC *)0x0, !bVar6)) {
      ghid_map_color_string(*ppcVar1,&gport->offlimits_color);
      gdk_gc_set_foreground(gport->offlimits_gc,&gport->offlimits_color);
      return;
    }
    iVar2 = 0xb;
    pcVar3 = "grid-color";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar6 = *pcVar4 == *pcVar3;
      pcVar4 = pcVar4 + 1;
      pcVar3 = pcVar3 + 1;
    } while (bVar6);
    if (!bVar6) {
      return;
    }
    if (gport->grid_gc == (GdkGC *)0x0) {
      return;
    }
    ghid_map_color_string(*ppcVar1,&gport->grid_color);
  }
  else {
    ghid_map_color_string(*ppcVar1,&gport->bg_color);
    gdk_gc_set_foreground(gport->bg_gc,&gport->bg_color);
  }
  set_special_grid_color();
  return;
}



// WARNING: Unknown calling convention

void ghid_use_mask(int use_it)

{
  GHidPort *pGVar1;
  GdkGC *pGVar2;
  GdkPixmap *pGVar3;
  GdkColor color;
  
  pGVar1 = gport;
  if (use_it == 6) {
    gdk_flush();
  }
  else {
    if (use_it == 4) {
      ghid_use_mask::old = gport->drawable;
      gport->drawable = gport->drawing_area->window;
      return;
    }
    if (use_it == 5) {
      gport->drawable = ghid_use_mask::old;
      return;
    }
    pGVar3 = gport->pixmap;
    if ((pGVar3 != (GdkPixmap *)0x0) && (use_it != cur_mask)) {
      if (use_it == 1) {
        __printf_chk(1,"gtk doesn\'t support mask_before!\n");
                    // WARNING: Subroutine does not return
        abort();
      }
      if (use_it < 2) {
        if (use_it == 0) {
          gport->drawable = pGVar3;
          mask_seq = 0;
        }
      }
      else if (use_it == 2) {
        pGVar3 = gport->mask;
        if (pGVar3 == (GdkPixmap *)0x0) {
          pGVar3 = (GdkPixmap *)gdk_pixmap_new(0,gport->width,gport->height,1);
          pGVar1->mask = pGVar3;
          pGVar3 = gport->mask;
        }
        pGVar1 = gport;
        pGVar2 = gport->mask_gc;
        gport->drawable = pGVar3;
        mask_seq = 0;
        if (pGVar2 == (GdkGC *)0x0) {
          pGVar2 = (GdkGC *)gdk_gc_new(pGVar3);
          pGVar1->mask_gc = pGVar2;
          pGVar2 = gport->mask_gc;
        }
        color.pixel = 1;
        gdk_gc_set_foreground(pGVar2,&color);
        gdk_draw_rectangle(gport->drawable,gport->mask_gc,1,0,0,gport->width,gport->height);
        color.pixel = 0;
        gdk_gc_set_foreground(gport->mask_gc,&color);
      }
      else if (use_it == 3) {
        ghid_use_mask::mask_seq_id = ghid_use_mask::mask_seq_id + 1;
        if (ghid_use_mask::mask_seq_id == 0) {
          ghid_use_mask::mask_seq_id = 1;
        }
        mask_seq = ghid_use_mask::mask_seq_id;
        gport->drawable = pGVar3;
      }
      cur_mask = use_it;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_fill_polygon(hidGC_conflict1 gc,int n_coords,int *x,int *y)

{
  int iVar1;
  GdkPoint *pGVar2;
  PCBTypePtr pPVar3;
  GHidPort *pGVar4;
  int iVar5;
  int iVar6;
  int i;
  int rv_1;
  int rv;
  int local_20;
  
  iVar5 = use_gc(gc);
  if (iVar5 != 0) {
    if (ghid_fill_polygon::npoints < n_coords) {
      ghid_fill_polygon::npoints = n_coords + 1;
      ghid_fill_polygon::points =
           (GdkPoint *)
           MyRealloc(ghid_fill_polygon::points,ghid_fill_polygon::npoints * 8,"ghid_fill_polygon");
    }
    pGVar4 = gport;
    pPVar3 = PCB;
    pGVar2 = ghid_fill_polygon::points;
    iVar1 = ghid_flip_y;
    iVar5 = ghid_flip_x;
    if (0 < n_coords) {
      iVar6 = 0;
      do {
        if (iVar5 == 0) {
          pGVar2[iVar6].x =
               (int)ROUND((float)(x[iVar6] - pGVar4->view_x0) / (float)pGVar4->zoom + 0.5);
          local_20 = y[iVar6];
          if (iVar1 != 0) goto LAB_080ef71a;
LAB_080ef6aa:
          local_20 = local_20 - pGVar4->view_y0;
        }
        else {
          pGVar2[iVar6].x =
               (int)ROUND((double)((pPVar3->MaxWidth - x[iVar6]) - pGVar4->view_x0) / pGVar4->zoom +
                          0.5);
          local_20 = y[iVar6];
          if (iVar1 == 0) goto LAB_080ef6aa;
LAB_080ef71a:
          local_20 = (pPVar3->MaxHeight - local_20) - pGVar4->view_y0;
        }
        pGVar2[iVar6].y = (int)ROUND((double)local_20 / pGVar4->zoom + 0.5);
        iVar6 = iVar6 + 1;
      } while (iVar6 != n_coords);
    }
    gdk_draw_polygon(pGVar4->drawable,pGVar4->u_gc,1,pGVar2,n_coords);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_draw_line(hidGC_conflict1 gc,int x1,int y1,int x2,int y2)

{
  double dVar1;
  double dVar2;
  Boolean BVar3;
  int iVar4;
  gint gVar5;
  int rv_2;
  int rv_1;
  int rv;
  int local_4c;
  int local_44;
  double local_3c;
  double local_34;
  double local_2c;
  double local_24 [2];
  
  if (ghid_flip_x == 0) {
    local_44 = gport->view_x0;
    dVar1 = gport->zoom;
    dVar2 = (double)((int)ROUND((longdouble)x1) - local_44) / dVar1;
  }
  else {
    local_44 = gport->view_x0;
    dVar1 = gport->zoom;
    dVar2 = (double)((PCB->MaxWidth - (int)ROUND((longdouble)x1)) - local_44) / dVar1;
  }
  local_4c = (int)ROUND(dVar2 + 0.5);
  iVar4 = (int)ROUND((longdouble)y1);
  if (ghid_flip_y == 0) {
    gVar5 = gport->view_y0;
  }
  else {
    gVar5 = gport->view_y0;
    iVar4 = PCB->MaxHeight - iVar4;
  }
  if (ghid_flip_x == 0) {
    local_44 = (int)ROUND((longdouble)x2) - local_44;
  }
  else {
    local_44 = (PCB->MaxWidth - (int)ROUND((longdouble)x2)) - local_44;
  }
  dVar2 = (double)local_44;
  if (ghid_flip_y == 0) {
    local_44 = (int)ROUND((longdouble)y2) - gVar5;
  }
  else {
    local_44 = (PCB->MaxHeight - (int)ROUND((longdouble)y2)) - gVar5;
  }
  local_3c = (double)(int)ROUND((double)local_44 / dVar1 + 0.5);
  local_34 = (double)(int)ROUND(dVar2 / dVar1 + 0.5);
  local_2c = (double)(int)ROUND((double)(iVar4 - gVar5) / dVar1 + 0.5);
  local_24[0] = (double)local_4c;
  BVar3 = ClipLine(0.0,0.0,(double)gport->width,(double)gport->height,local_24,&local_2c,&local_34,
                   &local_3c,(double)gc->width / dVar1);
  if (BVar3 != '\0') {
    iVar4 = use_gc(gc);
    if (iVar4 != 0) {
      gdk_draw_line(gport->drawable,gport->u_gc,(int)ROUND(local_24[0]),(int)ROUND(local_2c),
                    (int)ROUND(local_34),(int)ROUND(local_3c));
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_fill_rect(hidGC_conflict1 gc,int x1,int y1,int x2,int y2)

{
  double dVar1;
  gint lw;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int local_2c;
  int local_28;
  int local_20;
  
  iVar2 = gc->width;
  dVar1 = gport->zoom;
  iVar4 = x1;
  if (ghid_flip_x != 0) {
    iVar4 = PCB->MaxWidth - x1;
  }
  local_20 = gport->view_x0;
  iVar5 = local_20 - iVar2;
  if (iVar4 < iVar5) {
    if (ghid_flip_x == 0) {
      if (x2 < iVar5) {
        return;
      }
    }
    else if (PCB->MaxWidth - x2 < iVar5) {
      return;
    }
  }
  local_28 = x1;
  if (ghid_flip_x != 0) {
    local_28 = PCB->MaxWidth - x1;
  }
  iVar4 = (int)ROUND((double)gport->width * dVar1) + local_20 + iVar2;
  if (iVar4 < local_28) {
    iVar5 = x2;
    if (ghid_flip_x != 0) {
      iVar5 = PCB->MaxWidth - x2;
    }
    if (iVar4 < iVar5) {
      return;
    }
  }
  if (ghid_flip_y == 0) {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= y1) goto LAB_080efb08;
  }
  else {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= PCB->MaxHeight - y1) goto LAB_080efb08;
  }
  if (ghid_flip_y == 0) {
    if (y2 < local_2c) {
      return;
    }
  }
  else if (PCB->MaxHeight - y2 < local_2c) {
    return;
  }
LAB_080efb08:
  iVar5 = y1;
  if (ghid_flip_y != 0) {
    iVar5 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)gport->height * dVar1) + iVar4 + iVar2;
  if (iVar2 < iVar5) {
    iVar5 = y2;
    if (ghid_flip_y != 0) {
      iVar5 = PCB->MaxHeight - y2;
    }
    if (iVar2 < iVar5) {
      return;
    }
  }
  if (ghid_flip_x != 0) {
    x1 = PCB->MaxWidth - x1;
  }
  local_28 = (int)ROUND((double)(x1 - local_20) / dVar1 + 0.5);
  if (ghid_flip_y != 0) {
    y1 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)(y1 - iVar4) / dVar1 + 0.5);
  if (ghid_flip_x == 0) {
    local_20 = x2 - local_20;
  }
  else {
    local_20 = (PCB->MaxWidth - x2) - local_20;
  }
  iVar5 = (int)ROUND((double)local_20 / dVar1 + 0.5);
  if (ghid_flip_y == 0) {
    local_20 = y2 - iVar4;
  }
  else {
    local_20 = (PCB->MaxHeight - y2) - iVar4;
  }
  iVar4 = (int)ROUND((double)local_20 / dVar1 + 0.5);
  iVar3 = iVar5;
  if (iVar5 < local_28) {
    iVar3 = local_28;
    local_28 = iVar5;
  }
  iVar5 = iVar2;
  if (iVar4 < iVar2) {
    iVar5 = iVar4;
    iVar4 = iVar2;
  }
  iVar2 = use_gc(gc);
  if (iVar2 == 0) {
    return;
  }
  gdk_draw_rectangle(gport->drawable,gport->u_gc,1,local_28,iVar5,(iVar3 + 1) - local_28,
                     (iVar4 + 1) - iVar5);
  return;
}



// WARNING: Unknown calling convention

void ghid_draw_rect(hidGC_conflict1 gc,int x1,int y1,int x2,int y2)

{
  double dVar1;
  gint lw;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int local_2c;
  int local_28;
  int local_20;
  
  iVar2 = gc->width;
  dVar1 = gport->zoom;
  iVar4 = x1;
  if (ghid_flip_x != 0) {
    iVar4 = PCB->MaxWidth - x1;
  }
  local_20 = gport->view_x0;
  iVar5 = local_20 - iVar2;
  if (iVar4 < iVar5) {
    if (ghid_flip_x == 0) {
      if (x2 < iVar5) {
        return;
      }
    }
    else if (PCB->MaxWidth - x2 < iVar5) {
      return;
    }
  }
  local_28 = x1;
  if (ghid_flip_x != 0) {
    local_28 = PCB->MaxWidth - x1;
  }
  iVar4 = (int)ROUND((double)gport->width * dVar1) + local_20 + iVar2;
  if (iVar4 < local_28) {
    iVar5 = x2;
    if (ghid_flip_x != 0) {
      iVar5 = PCB->MaxWidth - x2;
    }
    if (iVar4 < iVar5) {
      return;
    }
  }
  if (ghid_flip_y == 0) {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= y1) goto LAB_080efea8;
  }
  else {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= PCB->MaxHeight - y1) goto LAB_080efea8;
  }
  if (ghid_flip_y == 0) {
    if (y2 < local_2c) {
      return;
    }
  }
  else if (PCB->MaxHeight - y2 < local_2c) {
    return;
  }
LAB_080efea8:
  iVar5 = y1;
  if (ghid_flip_y != 0) {
    iVar5 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)gport->height * dVar1) + iVar4 + iVar2;
  if (iVar2 < iVar5) {
    iVar5 = y2;
    if (ghid_flip_y != 0) {
      iVar5 = PCB->MaxHeight - y2;
    }
    if (iVar2 < iVar5) {
      return;
    }
  }
  if (ghid_flip_x != 0) {
    x1 = PCB->MaxWidth - x1;
  }
  local_28 = (int)ROUND((double)(x1 - local_20) / dVar1 + 0.5);
  if (ghid_flip_y != 0) {
    y1 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)(y1 - iVar4) / dVar1 + 0.5);
  if (ghid_flip_x == 0) {
    local_20 = x2 - local_20;
  }
  else {
    local_20 = (PCB->MaxWidth - x2) - local_20;
  }
  iVar5 = (int)ROUND((double)local_20 / dVar1 + 0.5);
  if (ghid_flip_y == 0) {
    local_20 = y2 - iVar4;
  }
  else {
    local_20 = (PCB->MaxHeight - y2) - iVar4;
  }
  iVar4 = (int)ROUND((double)local_20 / dVar1 + 0.5);
  iVar3 = iVar5;
  if (iVar5 < local_28) {
    iVar3 = local_28;
    local_28 = iVar5;
  }
  iVar5 = iVar2;
  if (iVar4 < iVar2) {
    iVar5 = iVar4;
    iVar4 = iVar2;
  }
  iVar2 = use_gc(gc);
  if (iVar2 == 0) {
    return;
  }
  gdk_draw_rectangle(gport->drawable,gport->u_gc,0,local_28,iVar5,(iVar3 + 1) - local_28,
                     (iVar4 + 1) - iVar5);
  return;
}



// WARNING: Unknown calling convention

void ghid_invalidate_all(void)

{
  guint16 *pgVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  GdkPoint *pGVar8;
  GHidPort *pGVar9;
  PCBTypePtr pPVar10;
  undefined4 uVar11;
  int iVar12;
  gint h_src;
  GdkInterpType interp_type;
  int rv_2;
  int i;
  GdkGC *pGVar13;
  int iVar14;
  gint x;
  int rv_4;
  int vy;
  int iVar15;
  int ebottom;
  GdkPixbuf *pGVar16;
  int rv_3;
  int n;
  int iVar17;
  int eleft;
  gint w;
  gint gVar18;
  int rv;
  int rv_1;
  int iVar19;
  int iVar20;
  int etop;
  gint h;
  int x2;
  int eright;
  gint y;
  int rv_6;
  int rv_5;
  double x_1;
  int local_80;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_30;
  BoxType region;
  
  if (gport->pixmap == (GdkPixmap *)0x0) {
    return;
  }
  dVar2 = gport->zoom;
  iVar19 = gport->view_x0;
  dVar4 = (double)iVar19;
  dVar3 = dVar2 * 0.0 + dVar4;
  local_80 = (int)ROUND(dVar3);
  if (ghid_flip_x == 0) {
    local_40 = gport->width;
    dVar5 = (double)(local_40 + 1) * dVar2 + dVar4;
    local_58 = (int)ROUND(dVar5);
    if (local_58 <= local_80) goto LAB_080f0ba0;
LAB_080f01e3:
    local_58 = local_80;
    if (ghid_flip_x != 0) {
      local_58 = (int)ROUND((double)PCB->MaxWidth - dVar3);
    }
  }
  else {
    local_40 = gport->width;
    dVar5 = (double)(local_40 + 1) * dVar2 + dVar4;
    local_58 = (int)ROUND(dVar5);
    if ((int)ROUND((double)PCB->MaxWidth - dVar3) < (int)ROUND((double)PCB->MaxWidth - dVar5))
    goto LAB_080f01e3;
LAB_080f0ba0:
    if (ghid_flip_x != 0) {
      local_58 = (int)ROUND((double)PCB->MaxWidth - dVar5);
    }
  }
  iVar15 = gport->view_y0;
  dVar5 = (double)iVar15;
  dVar7 = dVar2 * 0.0 + dVar5;
  region.Y2 = (LocationType)ROUND(dVar7);
  if (ghid_flip_y == 0) {
    local_50 = gport->height;
    dVar6 = (double)(local_50 + 1) * dVar2 + dVar5;
    local_4c = (int)ROUND(dVar6);
    local_54 = region.Y2;
    local_48 = local_4c;
  }
  else {
    local_50 = gport->height;
    dVar6 = (double)(local_50 + 1) * dVar2 + dVar5;
    local_48 = (int)ROUND(dVar6);
    local_4c = (int)ROUND((double)PCB->MaxHeight - dVar6);
    local_54 = (int)ROUND((double)PCB->MaxHeight - dVar7);
  }
  if (local_54 < local_4c) {
    local_48 = region.Y2;
    if (ghid_flip_y != 0) {
      local_48 = (int)ROUND((double)PCB->MaxHeight - dVar7);
    }
LAB_080f028f:
    if (ghid_flip_x == 0) goto LAB_080f0d39;
LAB_080f0297:
    dVar4 = (double)(local_40 + 1) * dVar2 + dVar4;
    local_54 = (int)ROUND(dVar4);
    if ((int)ROUND((double)PCB->MaxWidth - dVar3) <= (int)ROUND((double)PCB->MaxWidth - dVar4))
    goto LAB_080f0d74;
LAB_080f02e8:
    if (ghid_flip_x != 0) {
      local_80 = (int)ROUND((double)PCB->MaxWidth - dVar3);
    }
LAB_080f0307:
    if (ghid_flip_y == 0) goto LAB_080f0d9d;
LAB_080f030f:
    dVar5 = (double)(local_50 + 1) * dVar2 + dVar5;
    local_50 = (int)ROUND(dVar5);
    if ((int)ROUND((double)PCB->MaxHeight - dVar7) <= (int)ROUND((double)PCB->MaxHeight - dVar5))
    goto LAB_080f0dd3;
  }
  else {
    if (ghid_flip_y == 0) goto LAB_080f028f;
    local_48 = (int)ROUND((double)PCB->MaxHeight - dVar6);
    if (ghid_flip_x != 0) goto LAB_080f0297;
LAB_080f0d39:
    dVar4 = (double)(local_40 + 1) * dVar2 + dVar4;
    local_54 = (int)ROUND(dVar4);
    if (local_54 < local_80) goto LAB_080f02e8;
LAB_080f0d74:
    local_80 = local_54;
    if (ghid_flip_x == 0) goto LAB_080f0307;
    local_80 = (int)ROUND((double)PCB->MaxWidth - dVar4);
    if (ghid_flip_y != 0) goto LAB_080f030f;
LAB_080f0d9d:
    dVar5 = (double)(local_50 + 1) * dVar2 + dVar5;
    local_50 = (int)ROUND(dVar5);
    if (region.Y2 <= local_50) {
LAB_080f0dd3:
      region.Y2 = local_50;
      if (ghid_flip_y != 0) {
        region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar5);
      }
      goto LAB_080f037c;
    }
  }
  if (ghid_flip_y != 0) {
    region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar7);
  }
LAB_080f037c:
  region.X1 = local_58;
  region.Y1 = local_48;
  region.X2 = local_80;
  if (ghid_flip_x == 0) {
    iVar17 = -iVar19;
    iVar19 = PCB->MaxWidth - iVar19;
  }
  else {
    iVar17 = PCB->MaxWidth - iVar19;
    iVar19 = -iVar19;
  }
  iVar17 = (int)ROUND((double)iVar17 / dVar2 + 0.5);
  iVar19 = (int)ROUND((double)iVar19 / dVar2 + 0.5);
  if (ghid_flip_y == 0) {
    iVar14 = -iVar15;
    iVar15 = PCB->MaxHeight - iVar15;
  }
  else {
    iVar14 = PCB->MaxHeight - iVar15;
    iVar15 = -iVar15;
  }
  iVar20 = (int)ROUND((double)iVar14 / dVar2 + 0.5);
  iVar15 = (int)ROUND(dVar2 / (double)iVar15 + 0.5);
  iVar14 = iVar17;
  if (iVar19 < iVar17) {
    iVar14 = iVar19;
    iVar19 = iVar17;
  }
  iVar17 = iVar15;
  if (iVar15 < iVar20) {
    iVar17 = iVar20;
    iVar20 = iVar15;
  }
  if (iVar14 < 1) {
    iVar15 = gport->width;
    iVar14 = 0;
    iVar12 = 1;
  }
  else {
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,0,0,iVar14,gport->height);
    iVar12 = 1 - iVar14;
    iVar15 = gport->width;
  }
  if (iVar19 < iVar15) {
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,iVar19,0,iVar15 - iVar19,gport->height)
    ;
    iVar15 = iVar19;
  }
  if (iVar20 < 1) {
    iVar20 = 0;
    iVar15 = (iVar15 - iVar14) + 1;
    iVar19 = gport->height;
    local_40 = 1;
  }
  else {
    iVar15 = iVar15 + iVar12;
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,iVar14,0,iVar15,iVar20);
    local_40 = 1 - iVar20;
    iVar19 = gport->height;
  }
  if (iVar17 < iVar19) {
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,iVar14,iVar17,iVar15,iVar19 - iVar17);
    iVar19 = iVar17;
  }
  gdk_draw_rectangle(gport->drawable,gport->bg_gc,1,iVar14,iVar20,iVar15,iVar19 + local_40);
  pGVar16 = ghidgui->bg_pixbuf;
  if (pGVar16 != (GdkPixbuf *)0x0) {
    dVar2 = gport->zoom;
    iVar19 = (int)ROUND((double)PCB->MaxWidth / dVar2);
    iVar15 = (int)ROUND((double)PCB->MaxHeight / dVar2);
    iVar17 = gport->view_x0;
    iVar14 = gport->view_y0;
    if ((iVar19 != ghid_draw_bg_image::w_scaled) || (iVar15 != ghid_draw_bg_image::h_scaled)) {
      if (ghid_draw_bg_image::pixbuf != (GdkPixbuf *)0x0) {
        uVar11 = g_type_check_instance_cast(ghid_draw_bg_image::pixbuf,0x50);
        g_object_unref(uVar11);
        pGVar16 = ghidgui->bg_pixbuf;
      }
      iVar20 = gdk_pixbuf_get_width(pGVar16);
      iVar12 = gdk_pixbuf_get_height(ghidgui->bg_pixbuf);
      if ((iVar15 <= iVar12) || (uVar11 = 0, iVar19 <= iVar20)) {
        uVar11 = 2;
      }
      ghid_draw_bg_image::pixbuf =
           (GdkPixbuf *)gdk_pixbuf_scale_simple(ghidgui->bg_pixbuf,iVar19,iVar15,uVar11);
      ghid_draw_bg_image::h_scaled = iVar15;
      ghid_draw_bg_image::w_scaled = iVar19;
    }
    if (ghid_draw_bg_image::pixbuf != (GdkPixbuf *)0x0) {
      iVar17 = (int)ROUND((double)iVar17 / dVar2);
      iVar14 = (int)ROUND((double)iVar14 / dVar2);
      gdk_pixbuf_render_to_drawable
                (ghid_draw_bg_image::pixbuf,gport->drawable,gport->bg_gc,iVar17,iVar14,0,0,
                 iVar19 - iVar17,iVar15 - iVar14,1,0,0);
    }
  }
  hid_expose_callback((HID *)&ghid_hid,&region,(void *)0x0);
  if (Settings.DrawGrid != '\0') {
    dVar2 = PCB->Grid;
    dVar3 = gport->zoom;
    if (3 < (int)ROUND((double)(int)ROUND(dVar2) / dVar3 + 0.5)) {
      if (gport->grid_gc == (GdkGC *)0x0) {
        iVar19 = gdk_color_parse(Settings.GridColor,&gport->grid_color);
        pGVar9 = gport;
        if (iVar19 != 0) {
          pgVar1 = &(gport->grid_color).red;
          *pgVar1 = *pgVar1 ^ (gport->bg_color).red;
          pgVar1 = &(pGVar9->grid_color).green;
          *pgVar1 = *pgVar1 ^ (pGVar9->bg_color).green;
          pgVar1 = &(pGVar9->grid_color).blue;
          *pgVar1 = *pgVar1 ^ (pGVar9->bg_color).blue;
          gdk_color_alloc(pGVar9->colormap,&pGVar9->grid_color);
        }
        pGVar9 = gport;
        pGVar13 = (GdkGC *)gdk_gc_new(gport->drawable);
        pGVar9->grid_gc = pGVar13;
        gdk_gc_set_function(gport->grid_gc,2);
        gdk_gc_set_foreground(gport->grid_gc,&gport->grid_color);
        dVar2 = PCB->Grid;
        dVar3 = gport->zoom;
      }
      if (ghid_flip_x == 0) {
        iVar19 = gport->view_x0;
        iVar15 = iVar19;
      }
      else {
        iVar15 = gport->view_x0;
        iVar19 = PCB->MaxWidth - iVar15;
      }
      iVar17 = PCB->GridOffsetX;
      dVar4 = dVar2 * 0.5;
      iVar19 = (int)ROUND((double)(int)ROUND(((double)(iVar19 - iVar17) + dVar4) / dVar2) * dVar2 +
                          0.5 + (double)iVar17);
      if (ghid_flip_y == 0) {
        gVar18 = gport->view_y0;
        local_50 = gVar18;
      }
      else {
        gVar18 = PCB->MaxHeight - gport->view_y0;
        local_50 = gport->view_y0;
      }
      iVar14 = PCB->GridOffsetY;
      local_40 = (int)ROUND((double)(int)ROUND(((double)(gVar18 - iVar14) + dVar4) / dVar2) * dVar2
                            + 0.5 + (double)iVar14);
      if (ghid_flip_x == 0) {
        local_4c = iVar15 + -1 + gport->view_width;
      }
      else {
        local_4c = ((PCB->MaxWidth + 1) - gport->view_width) - iVar15;
      }
      iVar17 = (int)ROUND((double)(int)ROUND(((double)(local_4c - iVar17) + dVar4) / dVar2) * dVar2
                          + 0.5 + (double)iVar17);
      if (ghid_flip_y == 0) {
        local_4c = local_50 + -1 + gport->view_height;
      }
      else {
        local_4c = ((PCB->MaxHeight + 1) - gport->view_height) - local_50;
      }
      iVar14 = (int)ROUND((double)(int)ROUND(((double)(local_4c - iVar14) + dVar4) / dVar2) * dVar2
                          + 0.5 + (double)iVar14);
      iVar20 = iVar17;
      if (iVar17 < iVar19) {
        iVar20 = iVar19;
        iVar19 = iVar17;
      }
      local_44 = iVar14;
      if (iVar14 < local_40) {
        local_44 = local_40;
        local_40 = iVar14;
      }
      iVar17 = iVar19;
      if (ghid_flip_x != 0) {
        iVar17 = PCB->MaxWidth - iVar19;
      }
      if ((int)ROUND((double)(iVar17 - iVar15) / dVar3 + 0.5) < 0) {
        iVar19 = (int)ROUND((double)iVar19 + dVar2);
      }
      iVar17 = local_40;
      if (ghid_flip_y != 0) {
        iVar17 = PCB->MaxHeight - local_40;
      }
      if ((int)ROUND((double)(iVar17 - local_50) / dVar3 + 0.5) < 0) {
        local_40 = (int)ROUND((double)local_40 + dVar2);
      }
      iVar17 = iVar20;
      if (ghid_flip_x != 0) {
        iVar17 = PCB->MaxWidth - iVar20;
      }
      iVar15 = (int)ROUND((double)(iVar17 - iVar15) / dVar3 + 0.5);
      if (gport->width == iVar15 || gport->width < iVar15) {
        iVar20 = (int)ROUND((double)iVar20 - dVar2);
      }
      iVar15 = local_44;
      if (ghid_flip_y != 0) {
        iVar15 = PCB->MaxHeight - local_44;
      }
      iVar15 = (int)ROUND(dVar3 / (double)(iVar15 - local_50) + 0.5);
      if (gport->height == iVar15 || gport->height < iVar15) {
        local_44 = (int)ROUND((double)local_44 - dVar2);
      }
      iVar15 = (int)ROUND((double)(iVar20 - iVar19) / dVar2 + 0.5);
      if (draw_grid::npoints < iVar15 + 1) {
        draw_grid::npoints = iVar15 + 0xb;
        draw_grid::points =
             (GdkPoint *)MyRealloc(draw_grid::points,draw_grid::npoints * 8,"gtk_draw_grid");
      }
      pGVar9 = gport;
      pPVar10 = PCB;
      pGVar8 = draw_grid::points;
      iVar15 = ghid_flip_x;
      dVar2 = (double)iVar19;
      iVar19 = 0;
      dVar3 = (double)iVar20;
      if (dVar2 <= dVar3) {
        dVar4 = PCB->Grid;
        do {
          while (dVar5 = ROUND(dVar2), iVar15 != 0) {
            dVar2 = dVar2 + dVar4;
            pGVar8[iVar19].x =
                 (int)ROUND((double)((pPVar10->MaxWidth - (int)dVar5) - pGVar9->view_x0) /
                            pGVar9->zoom + 0.5);
            iVar19 = iVar19 + 1;
            if (dVar3 < dVar2) goto LAB_080f0a5c;
          }
          dVar2 = dVar2 + dVar4;
          pGVar8[iVar19].x =
               (int)ROUND((float)((int)dVar5 - pGVar9->view_x0) / (float)pGVar9->zoom + 0.5);
          iVar19 = iVar19 + 1;
        } while (dVar2 <= dVar3);
      }
LAB_080f0a5c:
      pGVar8 = draw_grid::points;
      pGVar9 = gport;
      for (dVar2 = (double)local_40; draw_grid::points = pGVar8, gport = pGVar9,
          dVar2 <= (double)local_44; dVar2 = dVar2 + PCB->Grid) {
        if (ghid_flip_y == 0) {
          local_30 = (int)ROUND(dVar2) - pGVar9->view_y0;
        }
        else {
          local_30 = (PCB->MaxHeight - (int)ROUND(dVar2)) - pGVar9->view_y0;
        }
        dVar3 = pGVar9->zoom;
        if (iVar19 != 0) {
          iVar15 = 0;
          do {
            pGVar8[iVar15].y = (int)ROUND((double)local_30 / dVar3 + 0.5);
            iVar15 = iVar15 + 1;
          } while (iVar15 != iVar19);
        }
        gdk_draw_points(pGVar9->drawable,pGVar9->grid_gc,pGVar8,iVar19);
        pGVar8 = draw_grid::points;
        pGVar9 = gport;
      }
    }
  }
  if (ghidgui->need_restore_crosshair != 0) {
    RestoreCrosshair('\0');
  }
  ghidgui->need_restore_crosshair = 0;
  ghid_screen_update();
  return;
}



// WARNING: Unknown calling convention

int SwapSides(int argc,char **argv,int x,int y)

{
  char cVar1;
  char cVar2;
  Cardinal Layer;
  Cardinal Layer_00;
  bool bVar3;
  bool bVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int solder_showing;
  int comp_group;
  int solder_group;
  uint local_34;
  
  iVar5 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  iVar6 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar7 = GetLayerGroupNumberByNumber(LayerStack[0]);
  Layer = (PCB->LayerGroups).Entries[iVar5][0];
  cVar1 = PCB->Data->Layer[Layer].On;
  Layer_00 = (PCB->LayerGroups).Entries[iVar6][0];
  cVar2 = PCB->Data->Layer[Layer_00].On;
  if (argc < 1) {
    bVar4 = false;
    bVar3 = false;
  }
  else {
    switch(**argv) {
    case 'H':
    case 'h':
      bVar4 = false;
      bVar3 = true;
      ghid_flip_x = (int)(ghid_flip_x == 0);
      local_34 = ghid_flip_y;
      break;
    default:
      return 1;
    case 'R':
    case 'r':
      bVar3 = true;
      ghid_flip_x = (int)(ghid_flip_x == 0);
      local_34 = (uint)(ghid_flip_y == 0);
      bVar4 = true;
      break;
    case 'V':
    case 'v':
      bVar4 = true;
      bVar3 = false;
      local_34 = (uint)(ghid_flip_y == 0);
    }
    Settings.ShowSolderSide = ghid_flip_x == local_34;
    ghid_flip_y = local_34;
  }
  Settings.ShowSolderSide = Settings.ShowSolderSide == '\0';
  if ((bool)Settings.ShowSolderSide) {
    if (((iVar5 != iVar7) || (cVar1 == '\0')) || (cVar2 != '\0')) goto joined_r0x080f1229;
    ChangeGroupVisibility(Layer,'\0','\0');
    iVar5 = iVar6;
  }
  else {
    if (((iVar6 != iVar7) || (cVar2 == '\0')) || (cVar1 != '\0')) goto joined_r0x080f1229;
    ChangeGroupVisibility(Layer_00,'\0','\0');
  }
  ChangeGroupVisibility((PCB->LayerGroups).Entries[iVar5][0],'\x01','\x01');
joined_r0x080f1229:
  if (bVar3) {
    ghid_port_ranges_pan((double)((PCB->MaxWidth / 2 - gport->view_x) * 2),0.0,1);
  }
  if (bVar4) {
    ghid_port_ranges_pan(0.0,(double)((PCB->MaxHeight / 2 - gport->view_y) * 2),1);
  }
  ghid_invalidate_all();
  return 0;
}



// WARNING: Unknown calling convention

void ghid_pan_fixup(void)

{
  int iVar1;
  PCBTypePtr pPVar2;
  GHidPort *pGVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  
  pGVar3 = gport;
  pPVar2 = PCB;
  iVar1 = PCB->MaxWidth;
  iVar6 = iVar1 - gport->view_width;
  if (gport->view_x0 != iVar6 && iVar6 <= gport->view_x0) {
    gport->view_x0 = iVar6;
  }
  iVar6 = pPVar2->MaxHeight;
  iVar7 = iVar6 - pGVar3->view_height;
  if (pGVar3->view_y0 != iVar7 && iVar7 <= pGVar3->view_y0) {
    pGVar3->view_y0 = iVar7;
  }
  if (pGVar3->view_x0 < 0) {
    iVar7 = pGVar3->view_y0;
    pGVar3->view_x0 = 0;
  }
  else {
    iVar7 = pGVar3->view_y0;
  }
  if (iVar7 < 0) {
    pGVar3->view_y0 = 0;
  }
  if ((iVar1 < pGVar3->view_width) && (iVar6 < pGVar3->view_height)) {
    zoom_to(pGVar3->zoom,0,0);
    return;
  }
  iVar1 = pGVar3->view_x0;
  uVar4 = gtk_range_get_type();
  uVar5 = g_type_check_instance_cast(ghidgui->h_range,uVar4);
  gtk_range_set_value(uVar5,(double)iVar1);
  iVar1 = gport->view_y0;
  uVar4 = g_type_check_instance_cast(ghidgui->v_range,uVar4);
  gtk_range_set_value(uVar4,(double)iVar1);
  ghid_invalidate_all();
  return;
}



// WARNING: Unknown calling convention

int Center(int argc,char **argv,int x,int y)

{
  double dVar1;
  double dVar2;
  int iVar3;
  GHidPort *pGVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  GdkScreen *screen;
  int iVar7;
  GdkDisplay *display;
  int iVar8;
  int y0;
  int dx;
  int iVar9;
  int x0;
  int dy;
  int local_24;
  int local_20 [4];
  
  pGVar4 = gport;
  if (argc != 0) {
    Message("Syntax error.  Usage:\n%s\n","Center()\n");
    return 1;
  }
  if (ghid_flip_x != 0) {
    x = PCB->MaxWidth - x;
  }
  dVar1 = PCB->Grid;
  if (ghid_flip_y != 0) {
    y = PCB->MaxHeight - y;
  }
  dVar2 = gport->zoom;
  iVar9 = (int)ROUND((double)PCB->GridOffsetX +
                     (double)(int)ROUND(((double)(x - PCB->GridOffsetX) + dVar1 * 0.5) / dVar1) *
                     dVar1 + 0.5) - gport->view_width / 2;
  iVar7 = 0;
  if (-1 < iVar9) {
    iVar7 = iVar9;
  }
  iVar8 = (int)ROUND((double)PCB->GridOffsetY +
                     (double)(int)ROUND(((double)(y - PCB->GridOffsetY) + dVar1 * 0.5) / dVar1) *
                     dVar1 + 0.5) - gport->view_height / 2;
  iVar9 = 0;
  if (-1 < iVar8) {
    iVar9 = iVar8;
  }
  iVar8 = gport->view_x0;
  iVar3 = gport->view_y0;
  gport->view_x0 = iVar7;
  pGVar4->view_y0 = iVar9;
  ghid_pan_fixup();
  uVar5 = gdk_display_get_default();
  uVar6 = gdk_display_get_default_screen(uVar5);
  gdk_display_get_pointer(uVar5,0,local_20,&local_24,0);
  gdk_display_warp_pointer
            (uVar5,uVar6,local_20[0] - (int)ROUND((double)(iVar7 - iVar8) / dVar2),
             local_24 - (int)ROUND((double)(iVar9 - iVar3) / dVar2));
  return 0;
}



// WARNING: Unknown calling convention

void ghid_invalidate_lr(int left,int right,int top,int bottom,int last)

{
  ghid_invalidate_all();
  return;
}



// WARNING: Unknown calling convention

void ghid_invalidate_wh(int x,int y,int width,int height,int last)

{
  ghid_invalidate_all();
  return;
}



// WARNING: Unknown calling convention

void ghid_set_crosshair(int x,int y,int action)

{
  double dVar1;
  double dVar2;
  int iVar3;
  GHidPort *pGVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int rv_1;
  int rv;
  GdkDisplay *display_1;
  GdkDisplay *display;
  int *local_3c;
  int *local_38;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20 [4];
  
  if ((gport->x_crosshair != x) || (gport->y_crosshair != y)) {
    ghid_set_cursor_position_labels();
    pGVar4 = gport;
    gport->x_crosshair = x;
    pGVar4->y_crosshair = y;
  }
  if (action == 2) {
    uVar5 = gdk_display_get_default();
    gdk_display_get_default_screen(uVar5);
    gdk_display_get_pointer(uVar5,0,local_20,&local_24,0);
    gdk_window_get_origin(gport->drawing_area->window,&local_2c,&local_28);
    pGVar4 = gport;
    iVar3 = ghid_flip_y;
    local_24 = local_24 - local_28;
    local_20[0] = local_20[0] - local_2c;
    if (ghid_flip_x == 0) {
      dVar1 = (double)local_20[0] * gport->zoom;
    }
    else {
      dVar1 = (double)gport->view_width - (double)local_20[0] * gport->zoom;
    }
    gport->view_x0 = (int)ROUND((double)x - dVar1);
    if (iVar3 == 0) {
      pGVar4->view_y0 = (int)ROUND((double)y - (double)local_24 * pGVar4->zoom);
    }
    else {
      pGVar4->view_y0 =
           (int)ROUND((double)y - ((double)pGVar4->view_height - (double)local_24 * pGVar4->zoom));
    }
    ghid_pan_fixup();
  }
  else if (action != 1) {
    return;
  }
  local_38 = &local_2c;
  local_3c = &local_28;
  uVar5 = gdk_display_get_default();
  uVar6 = gdk_display_get_default_screen(uVar5);
  gdk_window_get_origin(gport->drawing_area->window,local_3c,local_38);
  if (ghid_flip_y == 0) {
    local_30 = y - gport->view_y0;
    dVar1 = gport->zoom;
  }
  else {
    dVar1 = gport->zoom;
    local_30 = (PCB->MaxHeight - y) - gport->view_y0;
  }
  dVar2 = (double)local_30;
  if (ghid_flip_x == 0) {
    local_30 = x - gport->view_x0;
  }
  else {
    local_30 = (PCB->MaxWidth - x) - gport->view_x0;
  }
  rv_1 = (int)ROUND((double)local_30 / dVar1 + 0.5) + local_28;
  gdk_display_warp_pointer(uVar5,uVar6,rv_1,(int)ROUND(dVar2 / dVar1 + 0.5) + local_2c);
  return;
}



// WARNING: Unknown calling convention

int Zoom(int argc,char **argv,int x,int y)

{
  char cVar1;
  char *vp;
  char *__nptr;
  int iVar2;
  int x_00;
  int y_00;
  double v;
  double dVar3;
  int local_20;
  
  if (argc < 2) {
    if ((y == 0) && (x == 0)) {
      x_00 = gport->view_width / 2;
      y_00 = gport->view_height / 2;
    }
    else {
      if (ghid_flip_x == 0) {
        local_20 = x - gport->view_x0;
        dVar3 = gport->zoom;
      }
      else {
        dVar3 = gport->zoom;
        local_20 = (PCB->MaxWidth - x) - gport->view_x0;
      }
      x_00 = (int)ROUND((double)local_20 / dVar3 + 0.5);
      if (ghid_flip_y == 0) {
        local_20 = y - gport->view_y0;
      }
      else {
        local_20 = (PCB->MaxHeight - y) - gport->view_y0;
      }
      y_00 = (int)ROUND((double)local_20 / dVar3 + 0.5);
    }
    if (argc == 1) {
      __nptr = *argv;
      cVar1 = *__nptr;
      if (((cVar1 == '-') || (cVar1 == '+')) || (cVar1 == '=')) {
        __nptr = __nptr + 1;
      }
      dVar3 = strtod(__nptr,(char **)0x0);
      iVar2 = 1;
      if (0.0 < dVar3) {
        if (**argv == '-') {
          dVar3 = (1.0 / dVar3) * gport->zoom;
        }
        else if (**argv != '=') {
          dVar3 = dVar3 * gport->zoom;
        }
        zoom_to(dVar3,x_00,y_00);
        iVar2 = 0;
      }
    }
    else {
      zoom_to(1000000.0,0,0);
      iVar2 = 0;
    }
  }
  else {
    Message("Syntax error.  Usage:\n%s\n");
    iVar2 = 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void command_destroy_cb(GtkWidget *widget,gpointer data)

{
  command_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void command_combo_box_entry_create(void)

{
  GhidGui *pGVar1;
  GtkWidget *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  GtkEntry *pGVar6;
  
  pGVar1 = ghidgui;
  pGVar2 = (GtkWidget *)gtk_combo_box_entry_new_text();
  pGVar1->command_combo_box = pGVar2;
  uVar3 = gtk_entry_get_type();
  uVar4 = gtk_bin_get_type();
  pGVar1 = ghidgui;
  iVar5 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar4);
  pGVar6 = (GtkEntry *)g_type_check_instance_cast(*(undefined4 *)(iVar5 + 0x44),uVar3);
  pGVar1->command_entry = pGVar6;
  gtk_entry_set_width_chars(ghidgui->command_entry,0x28);
  gtk_entry_set_activates_default(ghidgui->command_entry,1);
  uVar3 = g_type_check_instance_cast(ghidgui->command_entry,0x50);
  g_signal_connect_data(uVar3,"activate",command_entry_activate_cb,0,0,0);
  uVar3 = g_type_check_instance_cast(ghidgui->command_combo_box,0x50);
  g_object_ref(uVar3);
  return;
}



// WARNING: Unknown calling convention

gchar * ghid_command_entry_get(gchar *prompt,gchar *command)

{
  GtkWidget *pGVar1;
  GhidGui *pGVar2;
  gchar *text;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  
  if (ghidgui->command_combo_box == (GtkWidget *)0x0) {
    command_combo_box_entry_create();
    pGVar2 = ghidgui;
    pGVar1 = ghidgui->command_combo_box;
    uVar3 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(pGVar2->status_line_hbox,uVar3);
    gtk_box_pack_start(uVar3,pGVar1,0,0,0);
  }
  if (prompt == (gchar *)0x0) {
    prompt = "";
  }
  text = (gchar *)g_strdup_printf("<b>%s</b>",prompt);
  ghid_status_line_set_text(text);
  g_free(text);
  pGVar2 = ghidgui;
  if (command == (gchar *)0x0) {
    command = "";
  }
  ghidgui->command_entry_status_line_active = 1;
  gtk_entry_set_text(pGVar2->command_entry,command);
  gtk_widget_show_all(ghidgui->command_combo_box);
  uVar3 = gtk_ui_manager_get_accel_group(ghidgui->ui_manager);
  uVar4 = gtk_window_get_type();
  uVar5 = g_type_check_instance_cast(ghid_port.top_window,uVar4);
  gtk_window_remove_accel_group(uVar5,uVar3);
  ghid_interface_input_signals_disconnect();
  ghid_interface_set_sensitive(0);
  uVar3 = gtk_widget_get_type();
  uVar3 = g_type_check_instance_cast(ghidgui->command_entry,uVar3);
  gtk_widget_grab_focus(uVar3);
  uVar3 = g_type_check_instance_cast(ghidgui->command_entry,0x50);
  uVar3 = g_signal_connect_data(uVar3,"key_press_event",command_escape_cb,0,0,0);
  loop = (GMainLoop *)g_main_loop_new(0,0);
  g_main_loop_run(loop);
  g_main_loop_unref(loop);
  pGVar2 = ghidgui;
  loop = (GMainLoop *)0x0;
  ghidgui->command_entry_status_line_active = 0;
  g_signal_handler_disconnect(pGVar2->command_entry,uVar3);
  ghid_interface_input_signals_connect();
  ghid_interface_set_sensitive(1);
  uVar3 = gtk_ui_manager_get_accel_group(ghidgui->ui_manager);
  uVar4 = g_type_check_instance_cast(ghid_port.top_window,uVar4);
  gtk_window_add_accel_group(uVar4,uVar3);
  gtk_widget_hide(ghidgui->command_combo_box);
  gtk_widget_grab_focus(ghid_port.drawing_area);
  return command_entered;
}



// WARNING: Unknown calling convention

gboolean command_escape_cb(GtkWidget *widget,GdkEventKey *kev,gpointer data)

{
  int iVar1;
  
  if (kev->keyval != 0xff1b) {
    return 0;
  }
  if (loop != (GMainLoop *)0x0) {
    iVar1 = g_main_loop_is_running(loop);
    if (iVar1 != 0) {
      g_main_loop_quit(loop);
    }
  }
  command_entered = (gchar *)0x0;
  return 1;
}



// WARNING: Unknown calling convention

void command_entry_activate_cb(GtkWidget *widget,gpointer data)

{
  char *__s2;
  gint gVar1;
  GList *pGVar2;
  undefined4 uVar3;
  GtkWidget *entry;
  gchar *pgVar4;
  char *__s1;
  int iVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  uint uVar8;
  GList *list;
  GList *pGVar9;
  gchar *command;
  gchar *s;
  int local_20;
  
  uVar3 = gtk_widget_get_type();
  entry = (GtkWidget *)g_type_check_instance_cast(ghidgui->command_entry,uVar3);
  pgVar4 = ghid_entry_get_text(entry);
  __s1 = (char *)g_strdup(pgVar4);
  gtk_entry_set_text(ghidgui->command_entry,&DAT_0814741b);
  pGVar2 = history_list;
  if (*__s1 != '\0') {
    if (history_list == (GList *)0x0) {
LAB_080f2040:
      uVar3 = g_strdup(__s1);
      history_list = (GList *)g_list_prepend(history_list,uVar3);
      uVar6 = gtk_combo_box_get_type();
      uVar7 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar6);
      gtk_combo_box_prepend_text(uVar7,uVar3);
      uVar8 = g_list_length(history_list);
      if ((uint)ghidgui->history_size < uVar8) {
        uVar3 = g_list_nth_data(history_list,ghidgui->history_size);
        history_list = (GList *)g_list_remove(history_list,uVar3);
        gVar1 = ghidgui->history_size;
        uVar6 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar6);
        gtk_combo_box_remove_text(uVar6,gVar1);
        g_free(uVar3);
      }
    }
    else {
      local_20 = 0;
      pGVar9 = history_list;
      while( true ) {
        __s2 = (char *)pGVar9->data;
        iVar5 = strcmp(__s1,__s2);
        if (iVar5 == 0) break;
        pGVar9 = pGVar9->next;
        if (pGVar9 == (GList *)0x0) goto LAB_080f2040;
        local_20 = local_20 + 1;
      }
      history_list = (GList *)g_list_remove(pGVar2,__s2);
      history_list = (GList *)g_list_prepend(history_list,__s2);
      uVar3 = gtk_combo_box_get_type();
      uVar6 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar3);
      gtk_combo_box_remove_text(uVar6,local_20);
      uVar3 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar3);
      gtk_combo_box_prepend_text(uVar3,__s2);
    }
  }
  if (ghidgui->use_command_window != 0) {
    HideCrosshair('\x01');
    hid_parse_actions(__s1,(_func_int_char_ptr_int_char_ptr_ptr *)0x0);
    RestoreCrosshair('\x01');
    g_free();
    return;
  }
  if ((loop != (GMainLoop *)0x0) && (iVar5 = g_main_loop_is_running(loop), iVar5 != 0)) {
    g_main_loop_quit(loop);
    command_entered = __s1;
    return;
  }
  command_entered = __s1;
  return;
}



// WARNING: Unknown calling convention

void ghid_command_window_show(gboolean raise)

{
  gchar **ppgVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  GtkWidget *pGVar5;
  undefined4 uVar6;
  GtkWidget *pGVar7;
  gchar *string;
  GtkWidget *vbox;
  GtkWidget *button;
  GtkWidget *vbox1;
  int iVar8;
  gint i;
  GtkWidget *hbox;
  
  pGVar7 = command_window;
  if (command_window == (GtkWidget *)0x0) {
    command_window = (GtkWidget *)gtk_window_new(0);
    uVar2 = g_type_check_instance_cast(command_window,0x50);
    g_signal_connect_data(uVar2,"destroy",command_destroy_cb,0,0,0);
    uVar2 = dcgettext(&DAT_0815492c,"PCB Command Entry",5);
    uVar3 = gtk_window_get_type();
    uVar4 = g_type_check_instance_cast(command_window,uVar3);
    gtk_window_set_title(uVar4,uVar2);
    uVar2 = g_type_check_instance_cast(command_window,uVar3);
    gtk_window_set_wmclass(uVar2,"PCB_Command",&DAT_08154932);
    uVar2 = g_type_check_instance_cast(command_window,uVar3);
    gtk_window_set_resizable(uVar2,0);
    pGVar5 = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = gtk_container_get_type();
    uVar3 = g_type_check_instance_cast(pGVar5,uVar2);
    gtk_container_set_border_width(uVar3,6);
    uVar3 = g_type_check_instance_cast(command_window,uVar2);
    gtk_container_add(uVar3,pGVar5);
    pGVar7 = ghidgui->command_combo_box;
    if (pGVar7 == (GtkWidget *)0x0) {
      command_combo_box_entry_create();
      pGVar7 = ghidgui->command_combo_box;
    }
    uVar3 = gtk_box_get_type();
    uVar4 = g_type_check_instance_cast(pGVar5,uVar3);
    gtk_box_pack_start(uVar4,pGVar7,0,0,0);
    combo_vbox = pGVar5;
    uVar4 = gtk_expander_new("Command Reference");
    uVar6 = g_type_check_instance_cast(pGVar5,uVar3);
    gtk_box_pack_start(uVar6,uVar4,1,1,2);
    pGVar7 = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = g_type_check_instance_cast(uVar4,uVar2);
    gtk_container_add(uVar2,pGVar7);
    gtk_widget_set_size_request(pGVar7,0xffffffff,0x15e);
    iVar8 = 0;
    pGVar7 = ghid_scrolled_text_view(pGVar7,(GtkWidget **)0x0,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC)
    ;
    do {
      ppgVar1 = command_ref_text + iVar8;
      iVar8 = iVar8 + 1;
      string = (gchar *)dcgettext(&DAT_0815492c,*ppgVar1,5);
      ghid_text_view_append(pGVar7,string);
    } while (iVar8 != 0x33);
    uVar2 = gtk_hbutton_box_new();
    uVar4 = gtk_button_box_get_type();
    uVar4 = g_type_check_instance_cast(uVar2,uVar4);
    gtk_button_box_set_layout(uVar4,4);
    uVar4 = g_type_check_instance_cast(pGVar5,uVar3);
    gtk_box_pack_start(uVar4,uVar2,0,0,3);
    uVar4 = gtk_button_new_from_stock("gtk-close");
    uVar6 = g_type_check_instance_cast(uVar4,0x50);
    g_signal_connect_data(uVar6,"clicked",command_window_close_cb,0,0,0);
    uVar2 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_box_pack_start(uVar2,uVar4,1,1,0);
    gtk_widget_show_all();
    return;
  }
  if (raise == 0) {
    return;
  }
  uVar2 = gtk_window_get_type();
  g_type_check_instance_cast(pGVar7,uVar2);
  gtk_window_present();
  return;
}



// WARNING: Unknown calling convention

void ghid_handle_user_command(gboolean raise)

{
  char *pcVar1;
  char *command;
  
  if (ghidgui->use_command_window != 0) {
    ghid_command_window_show(raise);
    ghid_set_status_line_label();
    return;
  }
  HideCrosshair('\x01');
  if (Settings.SaveLastCommand == '\0') {
    pcVar1 = ghid_command_entry_get("Enter command:","");
    if (pcVar1 == (gchar *)0x0) goto LAB_080f25aa;
LAB_080f252b:
    g_free(ghid_handle_user_command::previous);
    ghid_handle_user_command::previous = (char *)g_strdup(pcVar1);
  }
  else {
    pcVar1 = ghid_handle_user_command::previous;
    if (ghid_handle_user_command::previous == (char *)0x0) {
      pcVar1 = "";
    }
    pcVar1 = ghid_command_entry_get("Enter command:",pcVar1);
    if (pcVar1 != (gchar *)0x0) goto LAB_080f252b;
LAB_080f25aa:
    if (ghid_handle_user_command::previous == (char *)0x0) goto LAB_080f255d;
    pcVar1 = (char *)g_strdup(ghid_handle_user_command::previous);
  }
  hid_parse_actions(pcVar1,(_func_int_char_ptr_int_char_ptr_ptr *)0x0);
  g_free(pcVar1);
LAB_080f255d:
  RestoreCrosshair('\x01');
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void command_window_close_cb(void)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  
  if (command_window != (GtkWidget *)0x0) {
    pGVar1 = ghidgui->command_combo_box;
    uVar2 = gtk_container_get_type();
    uVar2 = g_type_check_instance_cast(combo_vbox,uVar2);
    gtk_container_remove(uVar2,pGVar1);
    gtk_widget_destroy(command_window);
  }
  combo_vbox = (GtkWidget *)0x0;
  command_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void ghid_command_use_command_window_sync(void)

{
  GtkWidget *pGVar1;
  GhidGui *pGVar2;
  undefined4 uVar3;
  
  pGVar2 = ghidgui;
  pGVar1 = ghidgui->command_combo_box;
  if (pGVar1 != (GtkWidget *)0x0) {
    if (ghidgui->use_command_window != 0) {
      uVar3 = gtk_container_get_type();
      uVar3 = g_type_check_instance_cast(pGVar2->status_line_hbox,uVar3);
      gtk_container_remove(uVar3,pGVar1);
      return;
    }
    command_window_close_cb();
    gtk_widget_hide(ghidgui->command_combo_box);
    pGVar2 = ghidgui;
    uVar3 = gtk_box_get_type();
    pGVar1 = pGVar2->command_combo_box;
    uVar3 = g_type_check_instance_cast(pGVar2->status_line_hbox,uVar3);
    gtk_box_pack_start(uVar3,pGVar1,0,0,0);
  }
  return;
}



// WARNING: Unknown calling convention

void config_auto_pan_speed_spin_button_cb(GtkSpinButton *spin_button,gpointer data)

{
  GhidGui *pGVar1;
  gint gVar2;
  
  pGVar1 = ghidgui;
  gVar2 = gtk_spin_button_get_value_as_int(spin_button);
  pGVar1->auto_pan_speed = gVar2;
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void config_history_spin_button_cb(GtkSpinButton *spin_button,gpointer data)

{
  GhidGui *pGVar1;
  gint gVar2;
  
  pGVar1 = ghidgui;
  gVar2 = gtk_spin_button_get_value_as_int(spin_button);
  pGVar1->history_size = gVar2;
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void config_backup_spin_button_cb(GtkSpinButton *spin_button,gpointer data)

{
  Settings.BackupInterval = gtk_spin_button_get_value_as_int(spin_button);
  EnableAutosave();
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void config_general_toggle_cb(GtkToggleButton *button,gint *setting)

{
  gint gVar1;
  
  gVar1 = gtk_toggle_button_get_active(button);
  *setting = gVar1;
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void config_layer_groups_radio_button_cb(GtkToggleButton *button,gpointer data)

{
  int iVar1;
  
  iVar1 = gtk_toggle_button_get_active(button);
  if ((iVar1 != 0) && (groups_holdoff == 0)) {
    config_layer_group[(int)data >> 8] = (uint)data & 0xff;
    groups_modified = 1;
    ghidgui->config_modified = 1;
  }
  return;
}



// WARNING: Unknown calling convention

void config_title_window_cb(GtkToggleButton *button,gpointer data)

{
  GhidGui *pGVar1;
  gboolean gVar2;
  gboolean active;
  
  gVar2 = gtk_toggle_button_get_active(button);
  pGVar1 = ghidgui;
  ghidgui->ghid_title_window = gVar2;
  ghid_window_set_name_label(pGVar1->name_label_string);
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void config_compact_vertical_toggle_cb(GtkToggleButton *button,gpointer data)

{
  gboolean gVar1;
  gboolean active;
  
  gVar1 = gtk_toggle_button_get_active(button);
  ghidgui->compact_vertical = gVar1;
  ghid_pack_mode_buttons();
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void config_compact_horizontal_toggle_cb(GtkToggleButton *button,gpointer data)

{
  GtkWidget *pGVar1;
  GhidGui *pGVar2;
  int iVar3;
  gboolean active;
  undefined4 uVar4;
  
  iVar3 = gtk_toggle_button_get_active(button);
  pGVar2 = ghidgui;
  ghidgui->compact_horizontal = iVar3;
  if (iVar3 == 0) {
    uVar4 = gtk_container_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_vbox,uVar4);
    gtk_container_remove(uVar4,pGVar1);
    pGVar2 = ghidgui;
    uVar4 = gtk_box_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_hbox,uVar4);
    gtk_box_pack_end(uVar4,pGVar1,0,0,4);
  }
  else {
    uVar4 = gtk_container_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_hbox,uVar4);
    gtk_container_remove(uVar4,pGVar1);
    pGVar2 = ghidgui;
    uVar4 = gtk_box_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_vbox,uVar4);
    gtk_box_pack_end(uVar4,pGVar1,1,0,0);
  }
  ghid_set_status_line_label();
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void text_spin_button_cb(GtkSpinButton *spin,gint *dst)

{
  gint gVar1;
  
  gVar1 = gtk_spin_button_get_value_as_int(spin);
  *dst = gVar1;
  ghidgui->config_modified = 1;
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void config_command_window_toggle_cb(GtkToggleButton *button,gpointer data)

{
  gboolean gVar1;
  gboolean active;
  
  gVar1 = gtk_toggle_button_get_active(button);
  if (config_command_window_toggle_cb::holdoff == 0) {
    if (ghidgui->command_entry_status_line_active == 0) {
      ghidgui->use_command_window = gVar1;
      ghid_command_use_command_window_sync();
      return;
    }
    config_command_window_toggle_cb::holdoff = 1;
    gtk_toggle_button_set_active(button,0);
    config_command_window_toggle_cb::holdoff = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void config_increments_tab_create(GtkWidget *tab_vbox)

{
  double dVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  gchar *pgVar7;
  GtkWidget *pGVar8;
  gint gVar9;
  gfloat gVar10;
  undefined1 *puVar11;
  GtkWidget *label;
  gdouble *target;
  double *pdVar12;
  double *pdVar13;
  GtkWidget *vbox;
  gfloat gVar14;
  gfloat gVar15;
  
  if (config_increments_vbox == (GtkWidget *)0x0) {
    pGVar8 = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(tab_vbox,uVar2);
    gtk_box_pack_start(uVar3,pGVar8,0,0,0);
    uVar3 = gtk_container_get_type();
    uVar3 = g_type_check_instance_cast(pGVar8,uVar3);
    gtk_container_set_border_width(uVar3,6);
    config_increments_vbox = pGVar8;
    config_increments_tab_vbox = tab_vbox;
  }
  else {
    uVar2 = gtk_box_get_type();
  }
  puVar11 = &DAT_081562ee;
  if (Settings.grid_units_mm != '\0') {
    puVar11 = &DAT_0815627e;
  }
  uVar3 = dcgettext(&DAT_0815492c,"Increment/Decrement values to use in <b>%s</b> units mode.\n",5);
  uVar3 = g_strdup_printf(uVar3,puVar11);
  uVar4 = gtk_label_new(&DAT_0814741b);
  uVar5 = gtk_label_get_type();
  uVar6 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_label_set_use_markup(uVar6,1);
  uVar5 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_label_set_markup(uVar5,uVar3);
  uVar2 = g_type_check_instance_cast(config_increments_vbox,uVar2);
  pdVar12 = &Settings.grid_increment_mil;
  gtk_box_pack_start(uVar2,uVar4,0,0,4);
  g_free(uVar3);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Grid Increment/Decrement",5);
  pGVar8 = ghid_category_vbox(config_increments_vbox,pgVar7,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    pdVar12 = &Settings.grid_increment_mm;
  }
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"For \'g\' and \'<shift>g\' grid change actions",5);
  if (Settings.grid_units_mm == '\0') {
    gVar15 = 1.0;
    gVar14 = 25.0;
    gVar10 = 5.0;
    gVar9 = 0;
    dVar1 = Settings.grid_increment_mil;
  }
  else {
    gVar15 = 0.01;
    gVar14 = 1.0;
    gVar10 = 0.05;
    gVar9 = 2;
    dVar1 = Settings.grid_increment_mm;
  }
  pdVar13 = &Settings.size_increment_mil;
  ghid_spin_button(pGVar8,(GtkWidget **)0x0,(float)dVar1,gVar15,gVar14,gVar10,gVar10,gVar9,0,
                   increment_spin_button_cb,pdVar12,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Size Increment/Decrement",5);
  pGVar8 = ghid_category_vbox(config_increments_vbox,pgVar7,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    pdVar13 = &Settings.size_increment_mm;
  }
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,
                              "For \'s\' and \'<shift>s\' size change actions on lines,\npads, pins and text.\nUse \'<ctrl>s\' and \'<shift><ctrl>s\' for drill holes."
                              ,5);
  if (Settings.grid_units_mm == '\0') {
    gVar10 = 1.0;
    gVar15 = 10.0;
    gVar14 = 5.0;
    gVar9 = 0;
    dVar1 = Settings.size_increment_mil;
  }
  else {
    gVar10 = 0.01;
    gVar15 = 0.5;
    gVar14 = 0.05;
    gVar9 = 2;
    dVar1 = Settings.size_increment_mm;
  }
  pdVar12 = &Settings.line_increment_mil;
  ghid_spin_button(pGVar8,(GtkWidget **)0x0,(float)dVar1,gVar10,gVar15,gVar10,gVar14,gVar9,0,
                   increment_spin_button_cb,pdVar13,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Line Increment/Decrement",5);
  pGVar8 = ghid_category_vbox(config_increments_vbox,pgVar7,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    pdVar12 = &Settings.line_increment_mm;
  }
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,
                              "For \'l\' and \'<shift>l\' routing line width change actions",5);
  if (Settings.grid_units_mm == '\0') {
    gVar10 = 0.5;
    gVar15 = 10.0;
    gVar14 = 5.0;
    gVar9 = 1;
    dVar1 = Settings.line_increment_mil;
  }
  else {
    gVar10 = 0.005;
    gVar15 = 0.5;
    gVar14 = 0.05;
    gVar9 = 3;
    dVar1 = Settings.line_increment_mm;
  }
  pdVar13 = &Settings.clear_increment_mil;
  ghid_spin_button(pGVar8,(GtkWidget **)0x0,(float)dVar1,gVar10,gVar15,gVar10,gVar14,gVar9,0,
                   increment_spin_button_cb,pdVar12,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Clear Increment/Decrement",5);
  pGVar8 = ghid_category_vbox(config_increments_vbox,pgVar7,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    pdVar13 = &Settings.clear_increment_mm;
  }
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,
                              "For \'k\' and \'<shift>k\' line clearance inside polygon size\nchange actions"
                              ,5);
  if (Settings.grid_units_mm == '\0') {
    gVar10 = 0.5;
    gVar15 = 10.0;
    gVar14 = 5.0;
    gVar9 = 1;
    dVar1 = Settings.clear_increment_mil;
  }
  else {
    gVar10 = 0.005;
    gVar15 = 0.5;
    gVar14 = 0.05;
    gVar9 = 3;
    dVar1 = Settings.clear_increment_mm;
  }
  ghid_spin_button(pGVar8,(GtkWidget **)0x0,(float)dVar1,gVar10,gVar15,gVar10,gVar14,gVar9,0,
                   increment_spin_button_cb,pdVar13,0,pgVar7);
  gtk_widget_show_all(config_increments_vbox);
  return;
}



// WARNING: Unknown calling convention

void config_sizes_tab_create(GtkWidget *tab_vbox)

{
  gfloat gVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  gchar *pgVar7;
  GtkWidget *pGVar8;
  GtkWidget *pGVar9;
  gfloat gVar10;
  gfloat gVar11;
  gint gVar12;
  gfloat gVar13;
  undefined1 *puVar14;
  GtkWidget *label;
  GtkWidget *hbox;
  GtkWidget *vbox;
  GtkWidget *table;
  gfloat gVar15;
  gfloat local_40;
  gfloat local_30;
  gfloat local_2c;
  gfloat local_28;
  
  if (config_sizes_vbox == (GtkWidget *)0x0) {
    pGVar8 = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(tab_vbox,uVar2);
    gtk_box_pack_start(uVar3,pGVar8,0,0,0);
    uVar3 = gtk_container_get_type();
    uVar3 = g_type_check_instance_cast(pGVar8,uVar3);
    gtk_container_set_border_width(uVar3,6);
    config_sizes_vbox = pGVar8;
    config_sizes_tab_vbox = tab_vbox;
  }
  else {
    uVar2 = gtk_box_get_type();
  }
  puVar14 = &DAT_081562ee;
  if (Settings.grid_units_mm != '\0') {
    puVar14 = &DAT_0815627e;
  }
  uVar3 = dcgettext(&DAT_0815492c,"<b>%s</b> grid units are selected",5);
  uVar3 = g_strdup_printf(uVar3,puVar14);
  uVar4 = gtk_label_new(&DAT_0814741b);
  uVar5 = gtk_label_get_type();
  uVar6 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_label_set_use_markup(uVar6,1);
  uVar5 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_label_set_markup(uVar5,uVar3);
  g_free(uVar3);
  uVar3 = g_type_check_instance_cast(config_sizes_vbox,uVar2);
  gtk_box_pack_start(uVar3,uVar4,0,0,4);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Board Size",5);
  pGVar8 = ghid_category_vbox(config_sizes_vbox,pgVar7,4,2,1,1);
  uVar3 = gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(pGVar8,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,0);
  pGVar9 = (GtkWidget *)gtk_table_new(2,2,0);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar3,pGVar9,0,0,0);
  uVar3 = gtk_table_get_type();
  uVar4 = g_type_check_instance_cast(pGVar9,uVar3);
  gtk_table_set_col_spacings(uVar4,6);
  uVar4 = g_type_check_instance_cast(pGVar9,uVar3);
  gtk_table_set_row_spacings(uVar4,3);
  new_board_width = PCB->MaxWidth;
  new_board_height = PCB->MaxHeight;
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Width",5);
  if (Settings.grid_units_mm == '\0') {
    gVar10 = 10.0;
    local_40 = 100000.0;
    local_2c = 100.0;
    local_28 = 1000.0;
    gVar12 = 1;
    gVar1 = (float)PCB->MaxWidth * 0.01;
  }
  else {
    gVar10 = 0.254;
    gVar1 = (float)PCB->MaxWidth * 0.000254;
    local_40 = 2540.0;
    local_2c = 5.0;
    local_28 = 25.0;
    gVar12 = 3;
  }
  ghid_table_spin_button
            (pGVar9,0,0,(GtkWidget **)0x0,gVar1,gVar10,local_40,local_2c,local_28,gVar12,0,
             size_spin_button_cb,&new_board_width,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Height",5);
  if (Settings.grid_units_mm == '\0') {
    gVar12 = 1;
    local_40 = 10.0;
    local_2c = 100000.0;
    local_28 = 100.0;
    gVar1 = (float)PCB->MaxHeight * 0.01;
    local_30 = 1000.0;
  }
  else {
    gVar12 = 3;
    gVar1 = (float)PCB->MaxHeight * 0.000254;
    local_40 = 0.254;
    local_2c = 2540.0;
    local_28 = 5.0;
    local_30 = 25.0;
  }
  ghid_table_spin_button
            (pGVar9,1,0,(GtkWidget **)0x0,gVar1,local_40,local_2c,local_28,local_30,gVar12,0,
             size_spin_button_cb,&new_board_height,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Use this board size as the default for new layouts",5);
  ghid_check_button_connected
            (pGVar8,&use_board_size_default_button,0,1,0,0,0,(_func_void_varargs *)0x0,(gpointer)0x0
             ,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Text Scale",5);
  pGVar8 = ghid_category_vbox(config_sizes_vbox,pgVar7,4,2,1,1);
  uVar4 = gtk_hbox_new(0,0);
  uVar5 = g_type_check_instance_cast(pGVar8,uVar2);
  gtk_box_pack_start(uVar5,uVar4,0,0,0);
  pGVar8 = (GtkWidget *)gtk_table_new(4,2,0);
  uVar4 = g_type_check_instance_cast(uVar4,uVar2);
  gtk_box_pack_start(uVar4,pGVar8,0,0,0);
  uVar4 = g_type_check_instance_cast(pGVar8,uVar3);
  gtk_table_set_col_spacings(uVar4,6);
  uVar4 = g_type_check_instance_cast(pGVar8,uVar3);
  gtk_table_set_row_spacings(uVar4,3);
  ghid_table_spin_button
            (pGVar8,0,0,&config_text_spin_button,(float)Settings.TextScale,10.0,10000.0,10.0,10.0,0,
             0,text_spin_button_cb,&Settings.TextScale,0,"%");
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Design Rule Checking",5);
  pGVar8 = ghid_category_vbox(config_sizes_vbox,pgVar7,4,2,1,1);
  uVar4 = gtk_hbox_new(0,0);
  uVar5 = g_type_check_instance_cast(pGVar8,uVar2);
  gtk_box_pack_start(uVar5,uVar4,0,0,0);
  pGVar9 = (GtkWidget *)gtk_table_new(4,2,0);
  uVar2 = g_type_check_instance_cast(uVar4,uVar2);
  gtk_box_pack_start(uVar2,pGVar9,0,0,0);
  uVar2 = g_type_check_instance_cast(pGVar9,uVar3);
  gtk_table_set_col_spacings(uVar2,6);
  uVar2 = g_type_check_instance_cast(pGVar9,uVar3);
  gtk_table_set_row_spacings(uVar2,3);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Minimum copper spacing",5);
  if (Settings.grid_units_mm == '\0') {
    gVar11 = 0.1;
    gVar15 = 500.0;
    gVar1 = (float)PCB->Bloat * 0.01;
    gVar13 = 1.0;
    local_28 = 1.401298e-45;
    gVar10 = gVar11;
  }
  else {
    gVar11 = 0.00254;
    gVar15 = 12.7;
    gVar1 = (float)PCB->Bloat * 0.000254;
    gVar13 = 0.05;
    local_28 = 4.203895e-45;
    gVar10 = 0.005;
  }
  ghid_table_spin_button
            (pGVar9,0,0,(GtkWidget **)0x0,gVar1,gVar11,gVar15,gVar10,gVar13,(gint)local_28,0,
             size_spin_button_cb,&PCB->Bloat,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Minimum copper width",5);
  if (Settings.grid_units_mm == '\0') {
    gVar11 = 0.1;
    gVar15 = 500.0;
    gVar1 = (float)PCB->minWid * 0.01;
    gVar13 = 1.0;
    local_28 = 1.401298e-45;
    gVar10 = gVar11;
  }
  else {
    gVar11 = 0.00254;
    gVar15 = 12.7;
    gVar1 = (float)PCB->minWid * 0.000254;
    gVar13 = 0.05;
    local_28 = 4.203895e-45;
    gVar10 = 0.005;
  }
  ghid_table_spin_button
            (pGVar9,1,0,(GtkWidget **)0x0,gVar1,gVar11,gVar15,gVar10,gVar13,(gint)local_28,0,
             size_spin_button_cb,&PCB->minWid,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Minimum touching copper overlap",5);
  if (Settings.grid_units_mm == '\0') {
    gVar10 = 0.1;
    local_30 = 1.0;
    gVar11 = 500.0;
    gVar12 = 1;
    gVar1 = (float)PCB->Shrink * 0.01;
    local_28 = 0.1;
  }
  else {
    gVar1 = (float)PCB->Shrink * 0.000254;
    gVar10 = 0.005;
    local_30 = 0.05;
    gVar11 = 12.7;
    gVar12 = 3;
    local_28 = 0.00254;
  }
  ghid_table_spin_button
            (pGVar9,2,0,(GtkWidget **)0x0,gVar1,local_28,gVar11,gVar10,local_30,gVar12,0,
             size_spin_button_cb,&PCB->Shrink,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Minimum silk width",5);
  if (Settings.grid_units_mm == '\0') {
    gVar11 = 1.0;
    gVar15 = 30.0;
    gVar1 = (float)PCB->minSlk * 0.01;
    gVar13 = 0.1;
    local_28 = 1.401298e-45;
    gVar10 = gVar11;
  }
  else {
    gVar11 = 0.0254;
    gVar15 = 0.762;
    gVar1 = (float)PCB->minSlk * 0.000254;
    gVar13 = 0.005;
    local_28 = 4.203895e-45;
    gVar10 = 0.05;
  }
  ghid_table_spin_button
            (pGVar9,3,0,(GtkWidget **)0x0,gVar1,gVar11,gVar15,gVar13,gVar10,(gint)local_28,0,
             size_spin_button_cb,&PCB->minSlk,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Minimum drill diameter",5);
  if (Settings.grid_units_mm == '\0') {
    gVar11 = 1.0;
    gVar15 = 50.0;
    gVar1 = (float)PCB->minDrill * 0.01;
    gVar13 = 0.1;
    local_28 = 1.401298e-45;
    gVar10 = gVar11;
  }
  else {
    gVar11 = 0.0254;
    gVar1 = (float)PCB->minDrill * 0.000254;
    gVar15 = 1.27;
    gVar13 = 0.005;
    local_28 = 4.203895e-45;
    gVar10 = 0.05;
  }
  ghid_table_spin_button
            (pGVar9,4,0,(GtkWidget **)0x0,gVar1,gVar11,gVar15,gVar13,gVar10,(gint)local_28,0,
             size_spin_button_cb,&PCB->minDrill,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Minimum annular ring",5);
  if (Settings.grid_units_mm == '\0') {
    gVar13 = 100.0;
    gVar11 = 1.0;
    gVar1 = (float)PCB->minRing * 0.01;
    gVar10 = 0.1;
    gVar12 = 1;
  }
  else {
    gVar13 = 2.54;
    gVar11 = 0.05;
    gVar1 = (float)PCB->minRing * 0.000254;
    gVar10 = 0.005;
    gVar12 = 3;
  }
  ghid_table_spin_button
            (pGVar9,5,0,(GtkWidget **)0x0,gVar1,0.0,gVar13,gVar10,gVar11,gVar12,0,
             size_spin_button_cb,&PCB->minRing,0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Use DRC values as the default for new layouts",5);
  ghid_check_button_connected
            (pGVar8,&use_drc_sizes_default_button,0,1,0,0,0,(_func_void_varargs *)0x0,(gpointer)0x0,
             pgVar7);
  gtk_widget_show_all(config_sizes_vbox);
  return;
}



// WARNING: Unknown calling convention

void size_spin_button_cb(GtkSpinButton *spin,gint *dst)

{
  gdouble value;
  longdouble lVar1;
  
  lVar1 = (longdouble)gtk_spin_button_get_value(spin);
  if (Settings.grid_units_mm == '\0') {
    lVar1 = lVar1 * (longdouble)100.0;
  }
  else {
    lVar1 = lVar1 / (longdouble)0.000254;
  }
  *dst = (int)ROUND(lVar1 + (longdouble)0.5);
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void increment_spin_button_cb(GtkSpinButton *spin,gdouble *dst)

{
  gdouble value;
  longdouble lVar1;
  
  lVar1 = (longdouble)gtk_spin_button_get_value(spin);
  *dst = (double)lVar1;
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void edit_layer_button_cb(GtkWidget *widget,gchar *data)

{
  char **argv;
  
  if ((PCB->RatDraw == '\0') && (PCB->SilkActive == '\0')) {
    argv = (char **)g_strsplit(data,&DAT_0815ca28,0xffffffff);
    MoveLayerAction(2,argv,0,0);
    g_strfreev();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

GtkWidget * config_page_create(GtkTreeStore *tree,GtkTreeIter *iter,GtkNotebook *notebook)

{
  GtkWidget *pGVar1;
  int iVar2;
  GtkWidget *vbox;
  
  pGVar1 = (GtkWidget *)gtk_vbox_new(0,0);
  gtk_notebook_append_page(notebook,pGVar1,0);
  iVar2 = g_list_length(notebook->children);
  gtk_tree_store_set(tree,iter,1,iVar2 + -1,0xffffffff);
  return pGVar1;
}



// WARNING: Unknown calling convention

void config_color_button_create(GtkWidget *box,ConfigColor *cc)

{
  HID_Attribute *pHVar1;
  char *pcVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  HID_Attribute *ha;
  GtkWidget *label;
  GtkWidget *hbox;
  
  pHVar1 = cc->attributes;
  uVar3 = gtk_hbox_new(0,6);
  uVar4 = gtk_box_get_type();
  uVar5 = g_type_check_instance_cast(box,uVar4);
  gtk_box_pack_start(uVar5,uVar3,0,0,0);
  if (cc->color_is_mapped == 0) {
                    // WARNING: Load size is inaccurate
    ghid_map_color_string(*pHVar1->value,&cc->color);
  }
  pcVar2 = pHVar1->name;
  cc->color_is_mapped = 1;
  uVar5 = dcgettext(&DAT_0815492c,"PCB %s Color",5);
  uVar5 = g_strdup_printf(uVar5,pcVar2);
  uVar6 = gtk_color_button_new_with_color(&cc->color);
  uVar7 = gtk_color_button_get_type();
  uVar7 = g_type_check_instance_cast(uVar6,uVar7);
  gtk_color_button_set_title(uVar7,uVar5);
  g_free(uVar5);
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_box_pack_start(uVar5,uVar6,0,0,0);
  uVar5 = gtk_label_new(pHVar1->name);
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_box_pack_start(uVar3,uVar5,0,0,0);
  uVar3 = g_type_check_instance_cast(uVar6,0x50);
  g_signal_connect_data(uVar3,"color-set",config_color_set_cb,cc,0,0);
  return;
}



// WARNING: Unknown calling convention

void config_color_set_cb(GtkWidget *button,ConfigColor *cc)

{
  HID_Attribute *ha_00;
  undefined4 uVar1;
  gchar *color_string;
  HID_Attribute *ha;
  gchar *str;
  GdkColor new_color;
  
  uVar1 = gtk_color_button_get_type();
  ha_00 = cc->attributes;
  uVar1 = g_type_check_instance_cast(button,uVar1);
  gtk_color_button_get_color(uVar1,&new_color);
  color_string = ghid_get_color_name(&new_color);
  ghid_map_color_string(color_string,&cc->color);
  config_colors_modified = 1;
  *(gchar **)ha_00->value = color_string;
  gtk_widget_set_sensitive(config_colors_save_button,1);
  gtk_widget_set_sensitive(config_color_warn_label,1);
  ghid_set_special_colors(ha_00);
  ghid_layer_buttons_color_update();
  ghid_invalidate_all();
  return;
}



// WARNING: Unknown calling convention

void config_color_file_set_label(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  gchar *name;
  
  if (*color_file == '\0') {
    name = (gchar *)g_strdup("defaults");
  }
  else {
    name = (gchar *)g_path_get_basename(color_file);
  }
  uVar1 = g_strdup_printf("Current colors loaded: <b>%s</b>",name);
  uVar2 = gtk_label_get_type();
  uVar2 = g_type_check_instance_cast(config_color_file_label,uVar2);
  gtk_label_set_markup(uVar2,uVar1);
  g_free(name);
  g_free(uVar1);
  return;
}



// WARNING: Unknown calling convention

void config_colors_tab_create(GtkWidget *tab_vbox)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  gchar *pgVar7;
  ConfigColor *cc;
  GtkWidget *vbox;
  GList *list;
  GtkWidget *expander;
  GtkWidget *sep;
  GList *pGVar8;
  GtkWidget *hbox;
  
  pGVar1 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar2 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(tab_vbox,uVar2);
  gtk_box_pack_start(uVar3,pGVar1,1,1,0);
  uVar3 = gtk_container_get_type();
  uVar4 = g_type_check_instance_cast(pGVar1,uVar3);
  gtk_container_set_border_width(uVar4,6);
  config_colors_vbox = pGVar1;
  config_colors_tab_vbox = tab_vbox;
  pGVar1 = ghid_scrolled_vbox(pGVar1,(GtkWidget **)0x0,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC);
  uVar4 = dcgettext(&DAT_0815492c,"Main colors",5);
  uVar4 = gtk_expander_new(uVar4);
  uVar5 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_box_pack_start(uVar5,uVar4,0,0,2);
  pGVar6 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar4 = g_type_check_instance_cast(uVar4,uVar3);
  gtk_container_add(uVar4,pGVar6);
  pGVar6 = ghid_category_vbox(pGVar6,(gchar *)0x0,0,2,1,0);
  for (pGVar8 = config_color_list; pGVar8 != (GList *)0x0; pGVar8 = pGVar8->next) {
    while (((ConfigColor *)pGVar8->data)->type != MISC_COLOR) {
      pGVar8 = pGVar8->next;
      if (pGVar8 == (GList *)0x0) goto LAB_080f43ef;
    }
    config_color_button_create(pGVar6,(ConfigColor *)pGVar8->data);
  }
LAB_080f43ef:
  uVar4 = dcgettext(&DAT_0815492c,"Layer colors",5);
  uVar4 = gtk_expander_new(uVar4);
  uVar5 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_box_pack_start(uVar5,uVar4,0,0,2);
  pGVar6 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar4 = g_type_check_instance_cast(uVar4,uVar3);
  gtk_container_add(uVar4,pGVar6);
  pGVar6 = ghid_category_vbox(pGVar6,(gchar *)0x0,0,2,1,0);
  for (pGVar8 = config_color_list; pGVar8 != (GList *)0x0; pGVar8 = pGVar8->next) {
    while (((ConfigColor *)pGVar8->data)->type != LAYER_COLOR) {
      pGVar8 = pGVar8->next;
      if (pGVar8 == (GList *)0x0) goto LAB_080f44e8;
    }
    config_color_button_create(pGVar6,(ConfigColor *)pGVar8->data);
  }
LAB_080f44e8:
  uVar4 = dcgettext(&DAT_0815492c,"Selected colors",5);
  uVar4 = gtk_expander_new(uVar4);
  uVar5 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_box_pack_start(uVar5,uVar4,0,0,2);
  pGVar1 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar3 = g_type_check_instance_cast(uVar4,uVar3);
  gtk_container_add(uVar3,pGVar1);
  pGVar1 = ghid_category_vbox(pGVar1,(gchar *)0x0,0,2,1,0);
  for (pGVar8 = config_color_list; pGVar8 != (GList *)0x0; pGVar8 = pGVar8->next) {
    while (((ConfigColor *)pGVar8->data)->type != MISC_SELECTED_COLOR) {
      pGVar8 = pGVar8->next;
      if (pGVar8 == (GList *)0x0) goto LAB_080f45d8;
    }
    config_color_button_create(pGVar1,(ConfigColor *)pGVar8->data);
  }
LAB_080f45d8:
  uVar3 = gtk_hseparator_new();
  uVar4 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,2);
  for (pGVar8 = config_color_list; pGVar8 != (GList *)0x0; pGVar8 = pGVar8->next) {
    while (((ConfigColor *)pGVar8->data)->type != LAYER_SELECTED_COLOR) {
      pGVar8 = pGVar8->next;
      if (pGVar8 == (GList *)0x0) goto LAB_080f4640;
    }
    config_color_button_create(pGVar1,(ConfigColor *)pGVar8->data);
  }
LAB_080f4640:
  pGVar1 = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  config_color_warn_label = pGVar1;
  uVar3 = gtk_label_get_type();
  uVar4 = g_type_check_instance_cast(pGVar1,uVar3);
  gtk_label_set_use_markup(uVar4,1);
  uVar4 = dcgettext(&DAT_0815492c,
                    "<b>Warning:</b> unsaved color changes will be lost at program exit.",5);
  uVar5 = g_type_check_instance_cast(config_color_warn_label,uVar3);
  gtk_label_set_markup(uVar5,uVar4);
  pGVar1 = config_color_warn_label;
  uVar4 = g_type_check_instance_cast(config_colors_vbox,uVar2);
  gtk_box_pack_start(uVar4,pGVar1,0,0,4);
  pGVar6 = (GtkWidget *)gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(config_colors_vbox,uVar2);
  gtk_box_pack_start(uVar4,pGVar6,0,0,6);
  config_color_file_label = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  uVar3 = g_type_check_instance_cast(config_color_file_label,uVar3);
  gtk_label_set_use_markup(uVar3,1);
  config_color_file_set_label();
  pGVar1 = config_color_file_label;
  uVar2 = g_type_check_instance_cast(pGVar6,uVar2);
  gtk_box_pack_start(uVar2,pGVar1,0,0,0);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,&DAT_081523c3,5);
  ghid_button_connected(pGVar6,(GtkWidget **)0x0,0,0,0,4,config_color_load_cb,(gpointer)0x0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Save",5);
  ghid_button_connected
            (pGVar6,&config_colors_save_button,0,0,0,4,config_color_save_cb,(gpointer)0x0,pgVar7);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Defaults",5);
  ghid_button_connected
            (pGVar6,(GtkWidget **)0x0,0,0,0,4,config_color_defaults_cb,(gpointer)0x0,pgVar7);
  gtk_widget_set_sensitive(config_colors_save_button,config_colors_modified);
  gtk_widget_set_sensitive(config_color_warn_label,config_colors_modified);
  gtk_widget_show_all(config_colors_vbox);
  return;
}



// WARNING: Unknown calling convention

void config_color_defaults_cb(gpointer data)

{
  GList **ppGVar1;
  HID_Attribute **ppHVar2;
  HID_Attribute *ha_00;
  GList *list;
  GList *pGVar3;
  HID_Attribute *ha;
  ConfigColor *cc;
  
  pGVar3 = config_color_list;
  if (config_color_list != (GList *)0x0) {
    do {
      ppHVar2 = (HID_Attribute **)pGVar3->data;
      ha_00 = *ppHVar2;
      dup_string((gchar **)ha_00->value,(ha_00->default_val).str_value);
      ppHVar2[5] = (HID_Attribute *)0x0;
      ghid_set_special_colors(ha_00);
      ppGVar1 = &pGVar3->next;
      pGVar3 = *ppGVar1;
    } while (*ppGVar1 != (GList *)0x0);
  }
  dup_string(&color_file,"");
  ghidgui->config_modified = 1;
  gtk_widget_set_sensitive(config_colors_save_button,0);
  gtk_widget_set_sensitive(config_color_warn_label,0);
  config_color_file_set_label();
  config_colors_modified = 0;
  ghid_layer_buttons_color_update();
  gtk_widget_destroy(config_colors_vbox);
  config_colors_tab_create(config_colors_tab_vbox);
  ghid_invalidate_all();
  return;
}



// WARNING: Unknown calling convention

void config_destroy_cb(gpointer data)

{
  config_sizes_vbox = (GtkWidget *)0x0;
  config_increments_vbox = (GtkWidget *)0x0;
  config_groups_table = (GtkWidget *)0x0;
  config_groups_vbox = (GtkWidget *)0x0;
  config_groups_window = (GtkWidget *)0x0;
  gtk_widget_destroy(config_window);
  config_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void config_color_save_cb(gpointer data)

{
  GList *pGVar1;
  gchar *pgVar2;
  gchar *path;
  gchar *pgVar3;
  FILE *__stream;
  FILE *f;
  HID_Attribute *ha;
  gchar *message;
  int iVar4;
  gchar *name;
  GList *list;
  char *pcVar5;
  undefined uVar6;
  byte bVar7;
  gchar *local_20 [4];
  
  bVar7 = 0;
  local_20[0] = (gchar *)g_strdup(color_dir);
  pgVar2 = (gchar *)dcgettext(&DAT_0815492c,"Save Color File",5);
  pgVar2 = ghid_dialog_file_select_save(pgVar2,local_20,(gchar *)0x0,(gchar *)0x0);
  uVar6 = pgVar2 == (gchar *)0x0;
  if (!(bool)uVar6) {
    pgVar3 = (gchar *)g_path_get_basename(pgVar2);
    iVar4 = 8;
    name = pgVar3;
    pcVar5 = "default";
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      name = name + (uint)bVar7 * -2 + 1;
      uVar6 = *name == *pcVar5;
      name = name;
      pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
    } while ((bool)uVar6);
    if ((bool)uVar6) {
      message = (gchar *)dcgettext(&DAT_0815492c,"Sorry, not overwriting the default color file!",5)
      ;
      ghid_dialog_message(message);
      g_free(pgVar3);
    }
    else {
      __stream = fopen(pgVar2,"w");
      pGVar1 = config_color_list;
      if (__stream != (FILE *)0x0) {
        for (; pGVar1 != (GList *)0x0; pGVar1 = pGVar1->next) {
                    // WARNING: Load size is inaccurate
          __fprintf_chk(__stream,1,"%s =\t%s\n",**pGVar1->data,*(undefined4 *)(*pGVar1->data)[10]);
        }
        fclose(__stream);
      }
      dup_string(&color_file,pgVar2);
      ghidgui->config_modified = 1;
      gtk_widget_set_sensitive(config_colors_save_button,0);
      gtk_widget_set_sensitive(config_color_warn_label,0);
      config_color_file_set_label();
      config_colors_modified = 0;
      g_free(pgVar3);
    }
  }
  g_free(pgVar2);
  g_free(local_20[0]);
  return;
}



// WARNING: Unknown calling convention

gboolean config_colors_read(gchar *path)

{
  HID_Attribute **ppHVar1;
  HID_Attribute *ha_00;
  undefined4 *puVar2;
  GList *pGVar3;
  char cVar4;
  gboolean gVar5;
  FILE *__stream;
  char *pcVar6;
  int iVar7;
  undefined4 uVar8;
  HID_Attribute *ha;
  GList *list;
  int in_GS_OFFSET;
  gchar arg [512];
  gchar buf [512];
  gchar option [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if ((path != (gchar *)0x0) && (*path != '\0')) {
    __stream = fopen(path,"r");
    if (__stream != (FILE *)0x0) {
LAB_080f4c20:
      pcVar6 = fgets(buf,0x200,__stream);
      if (pcVar6 != (char *)0x0) {
        sscanf(buf,"%63s %511[^\n]",option,arg);
        pcVar6 = option;
        if ((option[0] != ':') && (cVar4 = option[0], option[0] != '\0')) {
          while (cVar4 != '=') {
            pcVar6 = pcVar6 + 1;
            cVar4 = *pcVar6;
            if ((cVar4 == ':') || (cVar4 == '\0')) break;
          }
        }
        *pcVar6 = '\0';
        for (pcVar6 = arg;
            (((cVar4 = *pcVar6, cVar4 == '\t' || (cVar4 == ' ')) || (cVar4 == ':')) ||
            (pGVar3 = config_color_list, cVar4 == '=')); pcVar6 = pcVar6 + 1) {
        }
        for (; pGVar3 != (GList *)0x0; pGVar3 = pGVar3->next) {
          ppHVar1 = (HID_Attribute **)pGVar3->data;
          ha_00 = *ppHVar1;
          iVar7 = strcmp(option,ha_00->name);
          if (iVar7 == 0) {
            puVar2 = (undefined4 *)ha_00->value;
            uVar8 = g_strdup(pcVar6);
            *puVar2 = uVar8;
            ppHVar1[5] = (HID_Attribute *)0x0;
            ghid_set_special_colors(ha_00);
            break;
          }
        }
        goto LAB_080f4c20;
      }
      fclose(__stream);
      ghid_layer_buttons_color_update();
      gVar5 = 1;
      goto LAB_080f4be3;
    }
  }
  gVar5 = 0;
LAB_080f4be3:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return gVar5;
}



// WARNING: Unknown calling convention

void config_color_load_cb(gpointer data)

{
  gchar *pgVar1;
  gchar *path;
  gchar *local_10 [2];
  
  local_10[0] = (gchar *)g_strdup(color_dir);
  pgVar1 = (gchar *)dcgettext(&DAT_0815492c,"Load Color File",5);
  pgVar1 = ghid_dialog_file_select_open(pgVar1,local_10,(gchar *)0x0);
  if (pgVar1 != (gchar *)0x0) {
    config_colors_read(pgVar1);
    dup_string(&color_file,pgVar1);
    ghidgui->config_modified = 1;
    gtk_widget_set_sensitive(config_colors_save_button,0);
    gtk_widget_set_sensitive(config_color_warn_label,0);
    config_color_file_set_label();
    config_colors_modified = 0;
  }
  g_free(pgVar1);
  g_free(local_10[0]);
  gtk_widget_destroy(config_colors_vbox);
  config_colors_tab_create(config_colors_tab_vbox);
  ghid_invalidate_all();
  return;
}



// WARNING: Unknown calling convention

void config_layer_group_button_state_update(void)

{
  int *piVar1;
  uint *puVar2;
  Cardinal CVar3;
  bool bVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  PCBTypePtr pPVar7;
  gint i;
  uint uVar8;
  Cardinal *pCVar9;
  int iVar10;
  bool bVar11;
  
  groups_holdoff = 1;
  pPVar7 = PCB;
  iVar10 = 1;
  if (0 < PCB->Data->LayerN) {
    do {
      if (*(int *)(iVar10 * 4 + 0x818df7c) != 0) {
        uVar5 = gtk_toggle_button_get_type();
        uVar8 = 0;
        pCVar9 = layer_groups.Number + iVar10 * 0x12 + -2;
        do {
          CVar3 = *pCVar9;
          uVar8 = uVar8 + 1;
          pCVar9 = pCVar9 + 1;
          config_layer_group[CVar3] = iVar10;
          uVar6 = g_type_check_instance_cast(group_button[CVar3 - 1][iVar10 + 0xf],uVar5);
          gtk_toggle_button_set_active(uVar6,1);
          puVar2 = (uint *)(iVar10 * 4 + 0x818df7c);
          pPVar7 = PCB;
        } while (uVar8 <= *puVar2 && *puVar2 != uVar8);
      }
      piVar1 = &pPVar7->Data->LayerN;
      bVar11 = *piVar1 != iVar10;
      bVar4 = iVar10 <= *piVar1;
      iVar10 = iVar10 + 1;
    } while (bVar11 && bVar4);
  }
  groups_holdoff = 0;
  return;
}



// WARNING: Unknown calling convention

void ghid_config_layer_name_update(gchar *name,gint layer)

{
  undefined4 uVar1;
  LayerGroupType *pLVar2;
  int iVar3;
  LayerGroupType *pLVar4;
  LayerGroupType *pLVar5;
  byte bVar6;
  
  bVar6 = 0;
  if (((config_window != (GtkWidget *)0x0) && (name != (gchar *)0x0)) && (layers_applying == 0)) {
    uVar1 = gtk_entry_get_type();
    uVar1 = g_type_check_instance_cast(layer_entry[layer],uVar1);
    gtk_entry_set_text(uVar1,name);
    pLVar2 = &PCB->LayerGroups;
    if (pLVar2 != lg_monitor) {
      pLVar4 = pLVar2;
      pLVar5 = &layer_groups;
      for (iVar3 = 0x130; iVar3 != 0; iVar3 = iVar3 + -1) {
        pLVar5->Number[0] = pLVar4->Number[0];
        pLVar4 = (LayerGroupType *)((int)pLVar4 + (uint)bVar6 * -8 + 4);
        pLVar5 = (LayerGroupType *)((int)pLVar5 + ((uint)bVar6 * -2 + 1) * 4);
      }
      lg_monitor = pLVar2;
      config_layer_group_button_state_update();
      groups_modified = 0;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void layer_name_entry_cb(GtkWidget *entry,gpointer data)

{
  DataTypePtr paVar1;
  gchar *src;
  gchar *name;
  gboolean gVar2;
  
  paVar1 = PCB->Data;
  src = ghid_entry_get_text(entry);
  gVar2 = dup_string(&paVar1->Layer[(int)data].Name,src);
  if (gVar2 == 0) {
    return;
  }
  ghid_layer_buttons_update();
  return;
}



// WARNING: Unknown calling convention

void config_selection_changed_cb(GtkTreeSelection *selection,gpointer data)

{
  int iVar1;
  GtkTreeIter iter;
  undefined4 local_14;
  undefined4 local_10 [2];
  
  iVar1 = gtk_tree_selection_get_selected(selection,local_10,&iter);
  if (iVar1 != 0) {
    gtk_tree_model_get(local_10[0],&iter,1,&local_14,0xffffffff);
    gtk_notebook_set_current_page(config_notebook,local_14);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_config_text_scale_update(void)

{
  double dVar1;
  undefined4 uVar2;
  
  if (config_window != (GtkWidget *)0x0) {
    dVar1 = (double)Settings.TextScale;
    uVar2 = gtk_spin_button_get_type();
    uVar2 = g_type_check_instance_cast(config_text_spin_button,uVar2);
    gtk_spin_button_set_value(uVar2,dVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_config_handle_units_changed(void)

{
  undefined4 uVar1;
  char *pcVar2;
  
  pcVar2 = "<b>mil</b> ";
  ghid_set_cursor_position_labels();
  if (Settings.grid_units_mm != '\0') {
    pcVar2 = "<b>mm</b> ";
  }
  uVar1 = gtk_label_get_type();
  uVar1 = g_type_check_instance_cast(ghidgui->grid_units_label,uVar1);
  gtk_label_set_markup(uVar1,pcVar2);
  if (config_sizes_vbox != (GtkWidget *)0x0) {
    gtk_widget_destroy(config_sizes_vbox);
    config_sizes_vbox = (GtkWidget *)0x0;
    config_sizes_tab_create(config_sizes_tab_vbox);
  }
  if (config_increments_vbox != (GtkWidget *)0x0) {
    gtk_widget_destroy(config_increments_vbox);
    config_increments_vbox = (GtkWidget *)0x0;
    config_increments_tab_create(config_increments_tab_vbox);
  }
  ghidgui->config_modified = 1;
  return;
}



// WARNING: Unknown calling convention

void ghid_config_groups_changed(void)

{
  int iVar1;
  bool bVar2;
  GtkWidget *pGVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  int iVar10;
  PCBTypePtr pPVar11;
  int iVar12;
  GtkWidget **ppGVar13;
  GtkWidget *scrolled_window;
  GtkWidget *label;
  gchar *name;
  char *pcVar14;
  GtkWidget *button;
  DataTypePtr paVar15;
  LayerGroupType *pLVar16;
  gint i;
  int iVar17;
  uint uVar18;
  LayerGroupType *pLVar19;
  int in_GS_OFFSET;
  byte bVar20;
  undefined *puVar21;
  int local_58;
  int local_54;
  undefined4 local_50;
  gchar buf [32];
  
  pGVar6 = config_groups_vbox;
  bVar20 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (config_groups_vbox != (GtkWidget *)0x0) {
    if (config_groups_table != (GtkWidget *)0x0) {
      gtk_widget_destroy(config_groups_table);
    }
    if (config_groups_window != (GtkWidget *)0x0) {
      gtk_widget_destroy(config_groups_window);
    }
    pGVar3 = (GtkWidget *)gtk_scrolled_window_new(0,0);
    config_groups_window = pGVar3;
    gtk_widget_set_size_request(pGVar3,0x22,0x198);
    uVar4 = gtk_container_get_type();
    uVar4 = g_type_check_instance_cast(pGVar3,uVar4);
    gtk_container_set_border_width(uVar4,3);
    uVar4 = gtk_scrolled_window_get_type();
    uVar5 = g_type_check_instance_cast(pGVar3,uVar4);
    gtk_scrolled_window_set_policy(uVar5,1,0);
    uVar5 = gtk_box_get_type();
    uVar5 = g_type_check_instance_cast(pGVar6,uVar5);
    gtk_box_pack_start(uVar5,pGVar3,1,1,0);
    gtk_widget_show(pGVar3);
    iVar10 = PCB->Data->LayerN;
    pGVar6 = (GtkWidget *)gtk_table_new(iVar10 + 3,iVar10 + 1,0);
    config_groups_table = pGVar6;
    uVar5 = gtk_table_get_type();
    uVar7 = g_type_check_instance_cast(pGVar6,uVar5);
    gtk_table_set_row_spacings(uVar7,3);
    uVar4 = g_type_check_instance_cast(pGVar3,uVar4);
    gtk_scrolled_window_add_with_viewport(uVar4,pGVar6);
    gtk_widget_show(pGVar6);
    lg_monitor = &PCB->LayerGroups;
    pLVar16 = &PCB->LayerGroups;
    pLVar19 = &layer_groups;
    for (iVar10 = 0x130; iVar10 != 0; iVar10 = iVar10 + -1) {
      pLVar19->Number[0] = pLVar16->Number[0];
      pLVar16 = (LayerGroupType *)((int)pLVar16 + (uint)bVar20 * -8 + 4);
      pLVar19 = (LayerGroupType *)((int)pLVar19 + ((uint)bVar20 * -2 + 1) * 4);
    }
    uVar4 = dcgettext(&DAT_0815492c,"Group #",5);
    uVar4 = gtk_label_new(uVar4);
    uVar7 = g_type_check_instance_cast(pGVar6,uVar5);
    gtk_table_attach_defaults(uVar7,uVar4,0,1,0,1);
    uVar7 = gtk_misc_get_type();
    uVar4 = g_type_check_instance_cast(uVar4,uVar7);
    gtk_misc_set_alignment(uVar4,0x3f800000,0x3f000000);
    paVar15 = PCB->Data;
    iVar10 = paVar15->LayerN;
    if (0 < iVar10) {
      iVar12 = 1;
      do {
        if (iVar12 < 10) {
          puVar21 = &DAT_081538cf;
        }
        else {
          puVar21 = &DAT_081538d1;
        }
        iVar17 = iVar12 + 1;
        __snprintf_chk(buf,0x20,1,0x20,puVar21,iVar12);
        uVar4 = gtk_label_new(buf);
        uVar8 = g_type_check_instance_cast(pGVar6,uVar5);
        gtk_table_attach_defaults(uVar8,uVar4,iVar12,iVar17,0,1);
        paVar15 = PCB->Data;
        iVar10 = paVar15->LayerN;
        iVar12 = iVar17;
      } while (iVar17 <= iVar10);
    }
    iVar12 = iVar10 + 1;
    if (-1 < iVar12) {
      local_58 = 2;
      local_54 = 1;
      pPVar11 = PCB;
      do {
        iVar17 = local_54 + -1;
        if (iVar17 == iVar12) {
          pcVar14 = (char *)dcgettext(&DAT_0815492c,"component side",5);
          pPVar11 = PCB;
        }
        else if (iVar17 == iVar10) {
          pcVar14 = (char *)dcgettext(&DAT_0815492c,"solder side",5);
          pPVar11 = PCB;
        }
        else {
          pcVar14 = (char *)paVar15->name_tree[local_54 * 0x17 + -0x12];
          if (((rtree_t *)pcVar14 == (rtree_t *)0x0) || (*(char *)(rtree_node **)pcVar14 == '\0')) {
            pcVar14 = "(unknown)";
          }
        }
        if (iVar17 < pPVar11->Data->LayerN) {
          uVar4 = gtk_entry_new();
          *(undefined4 *)(local_54 * 4 + 0x818da5c) = uVar4;
          uVar8 = gtk_entry_get_type();
          uVar4 = g_type_check_instance_cast(uVar4,uVar8);
          gtk_entry_set_text(uVar4,pcVar14);
          uVar4 = *(undefined4 *)(local_54 * 4 + 0x818da5c);
          uVar8 = g_type_check_instance_cast(pGVar6,uVar5);
          gtk_table_attach_defaults(uVar8,uVar4,0,1,local_54,local_58);
          uVar4 = g_type_check_instance_cast(*(undefined4 *)(local_54 * 4 + 0x818da5c),0x50);
          g_signal_connect_data(uVar4,"activate",layer_name_entry_cb,iVar17,0,0);
        }
        else {
          uVar4 = gtk_label_new(pcVar14);
          uVar8 = g_type_check_instance_cast(uVar4,uVar7);
          gtk_misc_set_alignment(uVar8,0,0x3f000000);
          uVar8 = g_type_check_instance_cast(pGVar6,uVar5);
          gtk_table_attach_defaults(uVar8,uVar4,0,1,local_54,local_58);
        }
        paVar15 = PCB->Data;
        iVar10 = paVar15->LayerN;
        pPVar11 = PCB;
        if (0 < iVar10) {
          uVar4 = gtk_toggle_button_get_type();
          uVar8 = gtk_radio_button_get_type();
          ppGVar13 = (GtkWidget **)group_button[iVar17];
          local_50 = 0;
          uVar18 = 1;
          do {
            __snprintf_chk(buf,0x20,1,0x20,"%2.2d",uVar18);
            pGVar3 = (GtkWidget *)gtk_radio_button_new_with_label(local_50,buf);
            uVar9 = g_type_check_instance_cast(pGVar3,uVar4);
            gtk_toggle_button_set_mode(uVar9,0);
            uVar9 = g_type_check_instance_cast(pGVar3,uVar8);
            local_50 = gtk_radio_button_get_group(uVar9);
            uVar9 = g_type_check_instance_cast(pGVar6,uVar5);
            gtk_table_attach_defaults(uVar9,pGVar3,uVar18,uVar18 + 1,local_54,local_58);
            uVar9 = g_type_check_instance_cast(pGVar3,0x50);
            g_signal_connect_data
                      (uVar9,"toggled",config_layer_groups_radio_button_cb,iVar17 * 0x100 | uVar18,0
                       ,0);
            pPVar11 = PCB;
            *ppGVar13 = pGVar3;
            ppGVar13 = ppGVar13 + 1;
            paVar15 = pPVar11->Data;
            iVar10 = paVar15->LayerN;
            bVar2 = (int)uVar18 < iVar10;
            uVar18 = uVar18 + 1;
          } while (bVar2);
        }
        iVar12 = iVar10 + 1;
        local_58 = local_58 + 1;
        bVar2 = local_54 <= iVar12;
        local_54 = local_54 + 1;
      } while (bVar2);
    }
    gtk_widget_show_all(config_groups_vbox);
    config_layer_group_button_state_update();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void config_layers_tab_create(GtkWidget *tab_vbox)

{
  gchar **ppgVar1;
  GtkWidget *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  char *pcVar5;
  GtkWidget *pGVar6;
  gchar *pgVar7;
  GtkWidget *pGVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  GtkWidget *arrow;
  GtkWidget *vbox1;
  GtkWidget *sep;
  int iVar12;
  gint i;
  GtkWidget *tabs;
  GtkWidget *text;
  GtkWidget *button;
  GtkWidget *vbox;
  
  pGVar2 = (GtkWidget *)gtk_notebook_new();
  uVar3 = gtk_box_get_type();
  uVar4 = g_type_check_instance_cast(tab_vbox,uVar3);
  gtk_box_pack_start(uVar4,pGVar2,1,1,0);
  pcVar5 = (char *)dcgettext(&DAT_0815492c,"Change",5);
  pGVar6 = ghid_notebook_page(pGVar2,pcVar5,0,6);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Operations on currently selected layer:",5);
  pGVar8 = ghid_category_vbox(pGVar6,pgVar7,4,2,1,1);
  uVar4 = gtk_button_new();
  uVar9 = gtk_arrow_new(0,3);
  uVar10 = gtk_container_get_type();
  uVar11 = g_type_check_instance_cast(uVar4,uVar10);
  gtk_container_add(uVar11,uVar9);
  uVar9 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar9,"clicked",edit_layer_button_cb,&DAT_08153904,0,0);
  uVar9 = gtk_hbox_new(0,0);
  uVar11 = g_type_check_instance_cast(pGVar8,uVar3);
  gtk_box_pack_start(uVar11,uVar9,1,1,0);
  uVar9 = g_type_check_instance_cast(uVar9,uVar3);
  gtk_box_pack_start(uVar9,uVar4,0,0,0);
  uVar4 = gtk_button_new();
  uVar9 = gtk_arrow_new(1,3);
  uVar10 = g_type_check_instance_cast(uVar4,uVar10);
  gtk_container_add(uVar10,uVar9);
  uVar9 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar9,"clicked",edit_layer_button_cb,&DAT_08153909,0,0);
  uVar9 = gtk_hbox_new(0,0);
  uVar10 = g_type_check_instance_cast(pGVar8,uVar3);
  gtk_box_pack_start(uVar10,uVar9,1,1,0);
  uVar9 = g_type_check_instance_cast(uVar9,uVar3);
  gtk_box_pack_start(uVar9,uVar4,0,0,0);
  uVar4 = gtk_button_new_from_stock("gtk-delete");
  uVar9 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar9,"clicked",edit_layer_button_cb,&DAT_0815391b,0,0);
  uVar9 = gtk_hbox_new(0,0);
  uVar10 = g_type_check_instance_cast(pGVar8,uVar3);
  gtk_box_pack_start(uVar10,uVar9,1,1,0);
  uVar9 = g_type_check_instance_cast(uVar9,uVar3);
  gtk_box_pack_start(uVar9,uVar4,0,0,0);
  pgVar7 = (gchar *)dcgettext(&DAT_0815492c,"Add new layer above currently selected layer:",5);
  pGVar6 = ghid_category_vbox(pGVar6,pgVar7,4,2,1,1);
  uVar4 = gtk_button_new_from_stock("gtk-add");
  uVar9 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar9,"clicked",edit_layer_button_cb,&DAT_08153928,0,0);
  uVar9 = gtk_hbox_new(0,0);
  uVar10 = g_type_check_instance_cast(pGVar6,uVar3);
  gtk_box_pack_start(uVar10,uVar9,1,1,0);
  uVar9 = g_type_check_instance_cast(uVar9,uVar3);
  gtk_box_pack_start(uVar9,uVar4,0,0,0);
  pcVar5 = (char *)dcgettext(&DAT_0815492c,"Groups",5);
  pGVar6 = ghid_notebook_page(pGVar2,pcVar5,0,6);
  pGVar8 = (GtkWidget *)gtk_vbox_new(0,0);
  config_groups_vbox = pGVar8;
  uVar4 = g_type_check_instance_cast(pGVar6,uVar3);
  gtk_box_pack_start(uVar4,pGVar8,0,0,0);
  ghid_config_groups_changed();
  uVar4 = gtk_hseparator_new();
  iVar12 = 0;
  uVar3 = g_type_check_instance_cast(pGVar6,uVar3);
  gtk_box_pack_start(uVar3,uVar4,0,0,4);
  pcVar5 = (char *)dcgettext(&DAT_0815492c,"Info",5);
  pGVar2 = ghid_notebook_page(pGVar2,pcVar5,0,6);
  pGVar2 = ghid_scrolled_text_view
                     (pGVar2,(GtkWidget **)0x0,GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
  do {
    ppgVar1 = layer_info_text + iVar12;
    iVar12 = iVar12 + 1;
    pgVar7 = (gchar *)dcgettext(&DAT_0815492c,*ppgVar1,5);
    ghid_text_view_append(pGVar2,pgVar7);
  } while (iVar12 != 0x24);
  return;
}



// WARNING: Unknown calling convention

void ghid_config_window_show(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  GtkTreeStore *tree;
  GtkWidget *pGVar7;
  gchar *pgVar8;
  GtkWidget *pGVar9;
  undefined4 uVar10;
  GtkWidget *entry;
  GtkCellRenderer *renderer;
  GtkTreeViewColumn *column;
  int iVar11;
  GtkWidget *vbox;
  GtkWidget *config_hbox;
  GtkWidget *widget;
  GtkTreeStore *model;
  GtkTreeSelection *select;
  GtkWidget *button;
  GtkWidget *hbox;
  GtkTreeIter iter;
  
  pGVar7 = config_window;
  if (config_window != (GtkWidget *)0x0) {
    uVar1 = gtk_window_get_type();
    uVar1 = g_type_check_instance_cast(pGVar7,uVar1);
    gtk_window_present(uVar1);
    return;
  }
  config_window = (GtkWidget *)gtk_window_new(0);
  uVar1 = g_type_check_instance_cast(config_window,0x50);
  g_signal_connect_data(uVar1,"delete_event",config_destroy_cb,0,0,0);
  uVar1 = gtk_window_get_type();
  uVar2 = g_type_check_instance_cast(config_window,uVar1);
  gtk_window_set_title(uVar2,"PCB Preferences");
  uVar1 = g_type_check_instance_cast(config_window,uVar1);
  gtk_window_set_wmclass(uVar1,"Pcb_Conf",&DAT_08154932);
  uVar1 = gtk_container_get_type();
  uVar2 = g_type_check_instance_cast(config_window,uVar1);
  gtk_container_set_border_width(uVar2,2);
  uVar2 = gtk_hbox_new(0,4);
  uVar3 = g_type_check_instance_cast(config_window,uVar1);
  gtk_container_add(uVar3,uVar2);
  uVar3 = gtk_scrolled_window_new(0,0);
  uVar4 = gtk_scrolled_window_get_type();
  uVar4 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_scrolled_window_set_policy(uVar4,2,1);
  uVar4 = gtk_box_get_type();
  uVar5 = g_type_check_instance_cast(uVar2,uVar4);
  gtk_box_pack_start(uVar5,uVar3,0,0,0);
  uVar5 = gtk_vbox_new(0,4);
  uVar2 = g_type_check_instance_cast(uVar2,uVar4);
  gtk_box_pack_start(uVar2,uVar5,1,1,0);
  uVar2 = gtk_notebook_new();
  uVar6 = g_type_check_instance_cast(uVar5,uVar4);
  gtk_box_pack_start(uVar6,uVar2,1,1,0);
  uVar6 = gtk_notebook_get_type();
  config_notebook = (GtkNotebook *)g_type_check_instance_cast(uVar2,uVar6);
  gtk_notebook_set_show_tabs(config_notebook,0);
  tree = (GtkTreeStore *)gtk_tree_store_new(2,0x40,0x18);
  gtk_tree_store_append(tree,&iter,0);
  uVar2 = dcgettext(&DAT_0815492c,"General",5);
  gtk_tree_store_set(tree,&iter,0,uVar2,0xffffffff);
  pGVar7 = config_page_create(tree,&iter,config_notebook);
  uVar2 = g_type_check_instance_cast(pGVar7,uVar1);
  gtk_container_set_border_width(uVar2,6);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Enables",5);
  pGVar9 = ghid_category_vbox(pGVar7,pgVar8,4,2,1,1);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Use separate window for command entry",5);
  ghid_check_button_connected
            (pGVar9,(GtkWidget **)0x0,ghidgui->use_command_window,1,0,0,2,
             config_command_window_toggle_cb,(gpointer)0x0,pgVar8);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,
                              "Alternate window layout to allow smaller horizontal size",5);
  ghid_check_button_connected
            (pGVar9,(GtkWidget **)0x0,ghidgui->compact_horizontal,1,0,0,2,
             config_compact_horizontal_toggle_cb,(gpointer)0x0,pgVar8);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Alternate window layout to allow smaller vertical size"
                              ,5);
  ghid_check_button_connected
            (pGVar9,(GtkWidget **)0x0,ghidgui->compact_vertical,1,0,0,2,
             config_compact_vertical_toggle_cb,(gpointer)0x0,pgVar8);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Put layout name on the window title bar",5);
  ghid_check_button_connected
            (pGVar9,(GtkWidget **)0x0,ghidgui->ghid_title_window,1,0,0,2,config_title_window_cb,
             (gpointer)0x0,pgVar8);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Backups",5);
  pGVar9 = ghid_category_vbox(pGVar7,pgVar8,4,2,1,1);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"If layout is modified at exit, save into PCB.%i.save",5
                             );
  ghid_check_button_connected
            (pGVar9,(GtkWidget **)0x0,(int)Settings.SaveInTMP,1,0,0,2,config_general_toggle_cb,
             &Settings.SaveInTMP,pgVar8);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,
                              "Seconds between auto backups\n(set to zero to disable auto backups)",
                              5);
  ghid_spin_button(pGVar9,(GtkWidget **)0x0,(float)Settings.BackupInterval,0.0,3600.0,60.0,600.0,0,0
                   ,config_backup_spin_button_cb,(gpointer)0x0,0,pgVar8);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,&DAT_0815396b,5);
  pGVar7 = ghid_category_vbox(pGVar7,pgVar8,4,2,1,1);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Number of commands to remember in the history list",5);
  ghid_spin_button(pGVar7,(GtkWidget **)0x0,(float)ghidgui->history_size,5.0,25.0,1.0,1.0,0,0,
                   config_history_spin_button_cb,(gpointer)0x0,0,pgVar8);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Auto pan speed",5);
  ghid_spin_button(pGVar7,(GtkWidget **)0x0,(float)ghidgui->auto_pan_speed,1.0,10.0,1.0,1.0,0,0,
                   config_auto_pan_speed_spin_button_cb,(gpointer)0x0,0,pgVar8);
  gtk_tree_store_append(tree,&iter,0);
  uVar2 = dcgettext(&DAT_0815492c,"Sizes",5);
  gtk_tree_store_set(tree,&iter,0,uVar2,0xffffffff);
  pGVar7 = config_page_create(tree,&iter,config_notebook);
  config_sizes_tab_create(pGVar7);
  gtk_tree_store_append(tree,&iter,0);
  uVar2 = dcgettext(&DAT_0815492c,"Increments",5);
  gtk_tree_store_set(tree,&iter,0,uVar2,0xffffffff);
  pGVar7 = config_page_create(tree,&iter,config_notebook);
  config_increments_tab_create(pGVar7);
  gtk_tree_store_append(tree,&iter,0);
  uVar2 = dcgettext(&DAT_0815492c,"Library",5);
  gtk_tree_store_set(tree,&iter,0,uVar2,0xffffffff);
  pGVar7 = config_page_create(tree,&iter,config_notebook);
  uVar2 = g_type_check_instance_cast(pGVar7,uVar1);
  gtk_container_set_border_width(uVar2,6);
  pgVar8 = (gchar *)dcgettext(&DAT_0815492c,"Element Directories",5);
  pGVar7 = ghid_category_vbox(pGVar7,pgVar8,4,2,1,1);
  uVar2 = gtk_label_new(&DAT_0814741b);
  uVar6 = gtk_label_get_type();
  uVar10 = g_type_check_instance_cast(uVar2,uVar6);
  gtk_label_set_use_markup(uVar10,1);
  uVar10 = dcgettext(&DAT_0815492c,
                     "<small>Enter a \":\" separated list of custom top level\nelement directories.  For example:\n\t<b>~/gaf/pcb-elements:packages:/usr/local/pcb-elements</b>\nElements should be organized into subdirectories below each\ntop level directory.  Restart program for changes to take effect.</small>"
                     ,5);
  uVar6 = g_type_check_instance_cast(uVar2,uVar6);
  gtk_label_set_markup(uVar6,uVar10);
  uVar6 = g_type_check_instance_cast(pGVar7,uVar4);
  gtk_box_pack_start(uVar6,uVar2,0,0,0);
  pGVar9 = (GtkWidget *)gtk_entry_new();
  pgVar8 = lib_newlib_config;
  library_newlib_entry = pGVar9;
  entry = (GtkWidget *)gtk_entry_get_type();
  uVar2 = g_type_check_instance_cast(pGVar9,entry);
  gtk_entry_set_text(uVar2,pgVar8);
  uVar2 = g_type_check_instance_cast(pGVar7,uVar4);
  gtk_box_pack_start(uVar2,pGVar9,0,0,4);
  gtk_tree_store_append(tree,&iter,0);
  uVar2 = dcgettext(&DAT_0815492c,"Layers",5);
  gtk_tree_store_set(tree,&iter,0,uVar2,0xffffffff);
  pGVar7 = config_page_create(tree,&iter,config_notebook);
  config_layers_tab_create(pGVar7);
  gtk_tree_store_append(tree,&iter,0);
  uVar2 = dcgettext(&DAT_0815492c,"Colors",5);
  gtk_tree_store_set(tree,&iter,0,uVar2,0xffffffff);
  pGVar7 = config_page_create(tree,&iter,config_notebook);
  config_colors_tab_create(pGVar7);
  uVar2 = gtk_tree_view_get_type();
  uVar6 = gtk_tree_model_get_type();
  uVar6 = g_type_check_instance_cast(tree,uVar6);
  uVar6 = gtk_tree_view_new_with_model(uVar6);
  uVar2 = g_type_check_instance_cast(uVar6,uVar2);
  uVar6 = g_type_check_instance_cast(tree,0x50);
  g_object_unref(uVar6);
  uVar6 = gtk_cell_renderer_text_new();
  renderer = (GtkCellRenderer *)gtk_tree_view_column_new_with_attributes(0,uVar6,&DAT_081539ac,0,0);
  gtk_tree_view_append_column(uVar2,renderer);
  uVar6 = gtk_widget_get_type();
  uVar6 = g_type_check_instance_cast(uVar2,uVar6);
  uVar1 = g_type_check_instance_cast(uVar3,uVar1);
  gtk_container_add(uVar1,uVar6);
  uVar1 = gtk_tree_view_get_selection(uVar2);
  gtk_tree_selection_set_mode(uVar1,1);
  uVar1 = g_type_check_instance_cast(uVar1,0x50);
  g_signal_connect_data(uVar1,"changed",config_selection_changed_cb,0,0,0);
  uVar1 = gtk_hbutton_box_new();
  uVar2 = gtk_button_box_get_type();
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_button_box_set_layout(uVar2,4);
  uVar2 = g_type_check_instance_cast(uVar1,uVar4);
  gtk_box_set_spacing(uVar2,5);
  uVar2 = g_type_check_instance_cast(uVar5,uVar4);
  gtk_box_pack_start(uVar2,uVar1,0,0,0);
  uVar2 = gtk_button_new_from_stock("gtk-ok");
  uVar3 = gtk_object_get_type();
  iVar11 = g_type_check_instance_cast(uVar2,uVar3);
  *(uint *)(iVar11 + 0xc) = *(uint *)(iVar11 + 0xc) | 0x2000;
  uVar3 = g_type_check_instance_cast(uVar2,0x50);
  g_signal_connect_data(uVar3,"clicked",config_close_cb,0,0,0);
  uVar1 = g_type_check_instance_cast(uVar1,uVar4);
  gtk_box_pack_start(uVar1,uVar2,1,1,0);
  gtk_widget_grab_default(uVar2);
  gtk_widget_show_all(config_window);
  return;
}



// WARNING: Unknown calling convention

FILE * config_file_open(gchar *mode)

{
  int iVar1;
  gchar *homedir;
  char *__filename;
  FILE *pFVar2;
  gchar *src;
  FILE *f;
  
  iVar1 = g_get_home_dir();
  if (iVar1 == 0) {
    pFVar2 = (FILE *)0x0;
    g_log(0,0x20,"config_file_open: Can\'t get home directory!");
  }
  else {
    if (config_dir == (gchar *)0x0) {
      config_dir = (gchar *)g_build_path("/",iVar1,&DAT_0815492b,0);
      iVar1 = g_file_test(config_dir,4);
      if ((iVar1 == 0) && (iVar1 = mkdir(config_dir,0x1ed), iVar1 < 0)) {
        g_log(0,0x20,"config_file_open: Can\'t make \"%s\" directory!",config_dir);
        g_free(config_dir);
        config_dir = (gchar *)0x0;
        return (FILE *)0x0;
      }
    }
    if (color_dir == (gchar *)0x0) {
      color_dir = (gchar *)g_build_path("/",config_dir,"colors",0);
      iVar1 = g_file_test(color_dir,4);
      if (iVar1 == 0) {
        iVar1 = mkdir(color_dir,0x1ed);
        if (iVar1 < 0) {
          g_log(0,0x20,"config_file_open: Can\'t make \"%s\" directory!",color_dir);
          g_free(color_dir);
          color_dir = (gchar *)0x0;
        }
        src = (gchar *)g_build_path("/",color_dir,"Default",0);
        dup_string(&color_file,src);
        g_free(src);
      }
    }
    __filename = (char *)g_build_path("/",config_dir,"preferences",0);
    pFVar2 = fopen(__filename,mode);
    g_free(__filename);
  }
  return (FILE *)pFVar2;
}



// WARNING: Unknown calling convention

void ghid_config_files_write(void)

{
  void **ppvVar1;
  ConfigType CVar2;
  gchar **ppgVar3;
  FILE *__stream;
  int iVar4;
  ConfigAttribute *pCVar5;
  ConfigAttribute *ca;
  FILE *f;
  
  if ((ghidgui->config_modified == 0) || (__stream = config_file_open("w"), __stream == (FILE *)0x0)
     ) {
    return;
  }
  __fprintf_chk(__stream,1,"### PCB configuration file. ###\n");
  pCVar5 = config_attributes;
  do {
    while( true ) {
      CVar2 = pCVar5->type;
      if (CVar2 != CONFIG_Integer) break;
                    // WARNING: Load size is inaccurate
      iVar4 = *pCVar5->value;
LAB_080f6e36:
      __fprintf_chk(__stream,1,"%s = %d\n",pCVar5->name,iVar4);
LAB_080f6e58:
      pCVar5 = pCVar5 + 1;
      if (pCVar5 == (ConfigAttribute *)&ghid_dialog_confirm::y) goto LAB_080f6eb8;
    }
    if (CVar2 == CONFIG_Boolean) {
                    // WARNING: Load size is inaccurate
      iVar4 = (int)*pCVar5->value;
      goto LAB_080f6e36;
    }
    if (CVar2 == CONFIG_Real) {
                    // WARNING: Load size is inaccurate
      __fprintf_chk(__stream,1,"%s = %f\n",pCVar5->name,*pCVar5->value);
      goto LAB_080f6e58;
    }
    if (CVar2 != CONFIG_String) goto LAB_080f6e58;
    ppvVar1 = &pCVar5->value;
                    // WARNING: Load size is inaccurate
    if (**ppvVar1 == 0) {
      __fprintf_chk(__stream,1,"# %s = NULL\n",pCVar5->name);
      goto LAB_080f6e58;
    }
    ppgVar3 = &pCVar5->name;
    pCVar5 = pCVar5 + 1;
    __fprintf_chk(__stream,1,"%s = %s\n",*ppgVar3,**ppvVar1);
  } while (pCVar5 != (ConfigAttribute *)&ghid_dialog_confirm::y);
LAB_080f6eb8:
  fclose((FILE *)__stream);
  ghidgui->config_modified = 0;
  return;
}



// WARNING: Unknown calling convention

void config_close_cb(gpointer data)

{
  Cardinal CVar1;
  int iVar2;
  Cardinal CVar3;
  bool bVar4;
  int iVar5;
  int iVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int iVar9;
  gboolean active;
  PCBTypePtr pPVar10;
  gchar *pgVar11;
  gchar *s;
  gboolean gVar12;
  Cardinal CVar13;
  gint group;
  gint soldergroup;
  char *pcVar14;
  Cardinal CVar15;
  gint i;
  DataTypePtr paVar16;
  LayerGroupType *pLVar17;
  gboolean layers_modified;
  LayerGroupType *pLVar18;
  byte bVar19;
  int local_24;
  
  bVar19 = 0;
  uVar7 = gtk_toggle_button_get_type();
  uVar8 = g_type_check_instance_cast(use_board_size_default_button,uVar7);
  iVar9 = gtk_toggle_button_get_active(uVar8);
  if (iVar9 != 0) {
    Settings.MaxWidth = new_board_width;
    Settings.MaxHeight = new_board_height;
    ghidgui->config_modified = 1;
  }
  uVar7 = g_type_check_instance_cast(use_drc_sizes_default_button,uVar7);
  iVar9 = gtk_toggle_button_get_active(uVar7);
  pPVar10 = PCB;
  if (iVar9 == 0) {
    if (PCB->MaxWidth == new_board_width) {
LAB_080f7237:
      if (pPVar10->MaxHeight == new_board_height) goto LAB_080f6fdf;
    }
  }
  else {
    Settings.Bloat = PCB->Bloat;
    Settings.IsleArea = PCB->IsleArea;
    Settings.Shrink = PCB->Shrink;
    Settings.minWid = PCB->minWid;
    Settings.minSlk = PCB->minSlk;
    Settings.minDrill = PCB->minDrill;
    Settings.minRing = PCB->minRing;
    ghidgui->config_modified = 1;
    if (pPVar10->MaxWidth == new_board_width) goto LAB_080f7237;
  }
  ChangePCBSize(new_board_width,new_board_height);
  pPVar10 = PCB;
LAB_080f6fdf:
  paVar16 = pPVar10->Data;
  if (0 < paVar16->LayerN) {
    bVar4 = false;
    i = 0;
    do {
      pgVar11 = ghid_entry_get_text(layer_entry[i]);
      gVar12 = dup_string(&paVar16->Layer[i].Name,pgVar11);
      if (gVar12 != 0) {
        bVar4 = true;
      }
      i = i + 1;
      paVar16 = PCB->Data;
    } while (i < paVar16->LayerN);
    layers_applying = 1;
    if (bVar4) {
      ghid_layer_buttons_update();
    }
  }
  pPVar10 = PCB;
  layers_applying = 0;
  if (groups_modified != 0) {
    CVar1 = PCB->Data->LayerN;
    if (0 < (int)CVar1) {
      CVar13 = 0;
      do {
        layer_groups.Number[CVar13] = 0;
        CVar13 = CVar13 + 1;
      } while (CVar13 != CVar1);
    }
    iVar9 = 0;
    local_24 = 0;
    CVar13 = CVar1 + 1;
    if (-1 < (int)CVar13) {
      iVar9 = 0;
      CVar15 = 0;
      while( true ) {
        iVar2 = config_layer_group[CVar15];
        CVar3 = layer_groups.Number[iVar2 + -1];
        layer_groups.Number[iVar2 * 0x12 + (CVar3 - 2)] = CVar15;
        layer_groups.Number[iVar2 + -1] = CVar3 + 1;
        iVar5 = iVar9;
        iVar6 = iVar2 + -1;
        if ((CVar15 != CVar13) && (iVar5 = iVar2 + -1, iVar6 = local_24, CVar1 != CVar15)) {
          iVar5 = iVar9;
        }
        local_24 = iVar6;
        iVar9 = iVar5;
        if ((int)CVar13 < (int)(CVar15 + 1)) break;
        CVar15 = CVar15 + 1;
      }
    }
    if ((layer_groups.Number[iVar9] < 2) || (layer_groups.Number[local_24] < 2)) {
      pcVar14 = (char *)dcgettext(&DAT_0815492c,
                                  "Both \'solder side\' or \'component side\' layers must have at least\n\tone other layer in their group.\n"
                                  ,5);
      Message(pcVar14);
    }
    else if (iVar9 == local_24) {
      pcVar14 = (char *)dcgettext(&DAT_0815492c,
                                  "The \'solder side\' and \'component side\' layers are not allowed\n\tto be in the same layer group #\n"
                                  ,5);
      Message(pcVar14);
    }
    else {
      pLVar17 = &layer_groups;
      pLVar18 = &pPVar10->LayerGroups;
      for (iVar9 = 0x130; iVar9 != 0; iVar9 = iVar9 + -1) {
        pLVar18->Number[0] = pLVar17->Number[0];
        pLVar17 = (LayerGroupType *)((int)pLVar17 + ((uint)bVar19 * -2 + 1) * 4);
        pLVar18 = (LayerGroupType *)((int)pLVar18 + (uint)bVar19 * -8 + 4);
      }
      ghid_invalidate_all();
      groups_modified = 0;
    }
  }
  pgVar11 = ghid_entry_get_text(library_newlib_entry);
  gVar12 = dup_string(&lib_newlib_config,pgVar11);
  if (gVar12 != 0) {
    ghidgui->config_modified = 1;
  }
  ghid_config_files_write();
  config_sizes_vbox = (GtkWidget *)0x0;
  config_increments_vbox = (GtkWidget *)0x0;
  config_groups_table = (GtkWidget *)0x0;
  config_groups_vbox = (GtkWidget *)0x0;
  config_groups_window = (GtkWidget *)0x0;
  gtk_widget_destroy(config_window);
  config_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention
// Local variable s:gchar *[EAX:4] conflicts with parameter, skipped.

gchar * expand_dir(gchar *dir)

{
  gchar *pgVar1;
  undefined4 uVar2;
  
  if (*dir != '~') {
    pgVar1 = (gchar *)g_strdup(dir);
    return pgVar1;
  }
  uVar2 = g_get_home_dir();
  pgVar1 = (gchar *)g_build_filename(uVar2,dir + 1,0);
  return pgVar1;
}



// WARNING: Unknown calling convention

gint parse_option_line(gchar *line,gchar **option_result,gchar **arg_result)

{
  char *pcVar1;
  gchar *pgVar2;
  gint gVar3;
  gint argc;
  gchar *pgVar4;
  char cVar5;
  gchar *s;
  int in_GS_OFFSET;
  gchar arg [512];
  gchar option [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (option_result != (gchar **)0x0) {
    *option_result = (gchar *)0x0;
  }
  if (arg_result != (gchar **)0x0) {
    *arg_result = (gchar *)0x0;
  }
  cVar5 = *line;
  if ((cVar5 == ' ') || (cVar5 == '\t')) {
    do {
      do {
        line = line + 1;
        cVar5 = *line;
      } while (cVar5 == '\t');
    } while (cVar5 == ' ');
  }
  if ((((cVar5 == '\n') || (cVar5 == '\0')) || (cVar5 == '#')) || (cVar5 == '[')) {
    gVar3 = 0;
  }
  else {
    pcVar1 = strchr(line,10);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '\0';
    }
    pgVar4 = arg;
    arg[0] = '\0';
    sscanf(line,"%63s %511[^\n]",option,pgVar4);
    if ((option[0] == '\0') || (pcVar1 = option, option[0] == ':')) {
      pcVar1 = option;
    }
    else {
      while (option[0] != '=') {
        pcVar1 = pcVar1 + 1;
        option[0] = *pcVar1;
        if ((option[0] == ':') || (option[0] == '\0')) break;
      }
    }
    *pcVar1 = '\0';
    for (; (((cVar5 = *pgVar4, cVar5 == '\t' || (cVar5 == ' ')) || (cVar5 == ':')) ||
           ((cVar5 == '=' || (cVar5 == '\"')))); pgVar4 = pgVar4 + 1) {
    }
    pcVar1 = strchr(pgVar4,0x22);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '\0';
    }
    if (option_result != (gchar **)0x0) {
      pgVar2 = (gchar *)g_strdup(option);
      *option_result = pgVar2;
    }
    if ((arg_result == (gchar **)0x0) || (*pgVar4 == '\0')) {
      gVar3 = 1;
    }
    else {
      pgVar4 = (gchar *)g_strdup(pgVar4);
      *arg_result = pgVar4;
      gVar3 = 2;
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return gVar3;
}



// WARNING: Unknown calling convention

void config_file_read(void)

{
  int iVar1;
  undefined *puVar2;
  double *pdVar3;
  long *plVar4;
  FILE *__stream;
  char *pcVar5;
  gint gVar6;
  int iVar7;
  long lVar8;
  gchar *src;
  ConfigAttribute *ca;
  ConfigAttribute *pCVar9;
  char *__s1;
  int in_GS_OFFSET;
  double dVar10;
  char *local_228;
  char *local_224;
  gchar buf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = config_file_open("r");
  if (__stream != (FILE *)0x0) {
    buf[0] = '\0';
    while (pcVar5 = fgets(buf,0x200,(FILE *)__stream), pcVar5 != (char *)0x0) {
      gVar6 = parse_option_line(buf,&local_224,&local_228);
      __s1 = local_224;
      pcVar5 = local_228;
      if (0 < gVar6) {
        pCVar9 = config_attributes;
        do {
          if ((__s1 != (char *)0x0) && (iVar7 = strcmp(__s1,pCVar9->name), iVar7 == 0)) {
            if (pCVar9 != (ConfigAttribute *)0x0) {
              puVar2 = (undefined *)pCVar9->type;
              if (puVar2 == &DAT_00000001) {
                plVar4 = (long *)pCVar9->value;
                lVar8 = strtol(pcVar5,(char **)0x0,10);
                *plVar4 = lVar8;
                __s1 = local_224;
              }
              else if (puVar2 == (undefined *)0x0) {
                puVar2 = (undefined *)pCVar9->value;
                lVar8 = strtol(pcVar5,(char **)0x0,10);
                *puVar2 = (char)lVar8;
                __s1 = local_224;
              }
              else if (puVar2 == (undefined *)0x2) {
                pdVar3 = (double *)pCVar9->value;
                dVar10 = strtod(pcVar5,(char **)0x0);
                *pdVar3 = dVar10;
                __s1 = local_224;
              }
              else if (puVar2 == (undefined *)0x3) {
                src = "";
                if (pcVar5 != (char *)0x0) {
                  src = pcVar5;
                }
                dup_string((gchar **)pCVar9->value,src);
                __s1 = local_224;
              }
            }
            break;
          }
          pCVar9 = pCVar9 + 1;
        } while (pCVar9 != (ConfigAttribute *)&ghid_dialog_confirm::y);
      }
      g_free(__s1);
      g_free(local_228);
    }
    fclose((FILE *)__stream);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void parse_optionv(gint *argc,gchar ***argv,gboolean from_cmd_line)

{
  HID_Attribute *pHVar1;
  char **ppcVar2;
  char *__s2;
  undefined4 *puVar3;
  double *pdVar4;
  long *plVar5;
  int iVar6;
  undefined4 uVar7;
  char *__s1;
  int iVar8;
  long lVar9;
  gint gVar10;
  char *pcVar11;
  HID_AttrNode *pHVar12;
  HID_Attribute *a;
  HID_Attribute *pHVar13;
  gchar *ep;
  HID_AttrNode *ha;
  double dVar14;
  int local_28;
  
LAB_080f76cf:
  do {
    local_28 = *argc;
    if (local_28 == 0) {
      gVar10 = 1;
LAB_080f7934:
      *argc = gVar10;
      *argv = *argv + -1;
      return;
    }
    ppcVar2 = *argv;
    pcVar11 = *ppcVar2;
    if (((*pcVar11 != '-') || (pcVar11[1] != '-')) && (from_cmd_line != 0)) {
      gVar10 = local_28 + 1;
      goto LAB_080f7934;
    }
    if (hid_attr_nodes != (HID_AttrNode *)0x0) {
      pHVar12 = hid_attr_nodes;
      do {
        pHVar13 = pHVar12->attributes;
        pHVar1 = pHVar13 + pHVar12->n;
        if (pHVar13 < pHVar1) {
          while ((__s2 = pHVar13->name, __s2 == (char *)0x0 ||
                 (iVar6 = strcmp(pcVar11 + (~-(uint)(from_cmd_line == 0) & 2),__s2), iVar6 != 0))) {
            pHVar13 = pHVar13 + 1;
            if (pHVar1 <= pHVar13) goto LAB_080f77be;
          }
          switch(pHVar13->type) {
          default:
            goto switchD_080f7755_caseD_0;
          case CONFIG_PAGE_COLUMN:
            plVar5 = (long *)pHVar13->value;
            if (plVar5 == (long *)0x0) {
              lVar9 = strtol(ppcVar2[1],(char **)0x0,0);
              (pHVar13->default_val).int_value = lVar9;
            }
            else {
              lVar9 = strtol(ppcVar2[1],(char **)0x0,0);
              *plVar5 = lVar9;
            }
            break;
          case DBUS_BUS_STARTER:
            pdVar4 = (double *)pHVar13->value;
            if (pdVar4 == (double *)0x0) {
              dVar14 = strtod(ppcVar2[1],(char **)0x0);
              (pHVar13->default_val).real_value = dVar14;
            }
            else {
              dVar14 = strtod(ppcVar2[1],(char **)0x0);
              *pdVar4 = dVar14;
            }
            break;
          case GDK_CAP_PROJECTING:
            puVar3 = (undefined4 *)pHVar13->value;
            if (puVar3 == (undefined4 *)0x0) {
              pcVar11 = (char *)g_strdup(ppcVar2[1]);
              (pHVar13->default_val).str_value = pcVar11;
            }
            else {
              uVar7 = g_strdup(ppcVar2[1]);
              *puVar3 = uVar7;
            }
            break;
          case DBUS_WATCH_ERROR:
            if ((undefined *)pHVar13->value == (undefined *)0x0) {
              (pHVar13->default_val).int_value = (int)&DAT_00000001;
              local_28 = *argc;
            }
            else {
              *(undefined *)pHVar13->value = 1;
              local_28 = *argc;
            }
            goto switchD_080f7755_caseD_0;
          case GDK_AND_REVERSE:
            goto switchD_080f7755_caseD_5;
          case EXPANSION_AREA:
          case GDK_NOOP:
                    // WARNING: Subroutine does not return
            abort();
          }
          *argc = *argc + -1;
          local_28 = *argc;
          *argv = *argv + 1;
          goto switchD_080f7755_caseD_0;
        }
LAB_080f77be:
        pHVar12 = pHVar12->next;
      } while (pHVar12 != (HID_AttrNode *)0x0);
    }
    if (from_cmd_line != 0) {
      __fprintf_chk(stderr,1,"unrecognized option: %s\n",pcVar11);
                    // WARNING: Subroutine does not return
      exit(1);
    }
    __fprintf_chk(stderr,1,"unrecognized option: %s\n",pcVar11);
  } while( true );
switchD_080f7755_caseD_5:
  pcVar11 = ppcVar2[1];
  ppcVar2 = pHVar13->enumerations;
  __s1 = *ppcVar2;
  if (__s1 == (char *)0x0) goto LAB_080f78fb;
  iVar6 = 0;
  while (iVar8 = strcmp(__s1,pcVar11), iVar8 != 0) {
    iVar6 = iVar6 + 1;
    __s1 = ppcVar2[iVar6];
    if (__s1 == (char *)0x0) {
LAB_080f78fb:
      __fprintf_chk(stderr,1,"ERROR:  \"%s\" is an unknown value for the --%s option\n",pcVar11,__s2
                   );
                    // WARNING: Subroutine does not return
      exit(1);
    }
  }
  (pHVar13->default_val).int_value = iVar6;
  *argc = *argc + -1;
  local_28 = *argc;
  (pHVar13->default_val).str_value = pcVar11;
  *argv = *argv + 1;
switchD_080f7755_caseD_0:
  *argc = local_28 + -1;
  *argv = *argv + 1;
  goto LAB_080f76cf;
}



// WARNING: Unknown calling convention

void load_rc_file(gchar *path)

{
  int iVar1;
  FILE *__stream;
  FILE *f;
  char *pcVar2;
  int in_GS_OFFSET;
  gchar *av [2];
  gint local_428;
  gchar **local_424;
  gchar buf [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen(path,"r");
  if (__stream != (FILE *)0x0) {
    if (Settings.verbose != 0) {
      __printf_chk(1,"Loading pcbrc file: %s\n",path);
    }
    while( true ) {
      pcVar2 = fgets(buf,0x400,__stream);
      if (pcVar2 == (char *)0x0) break;
      local_424 = av;
      local_428 = parse_option_line(buf,av,av + 1);
      if (0 < local_428) {
        parse_optionv(&local_428,&local_424,0);
      }
      g_free(av[0]);
      g_free(av[1]);
    }
    fclose(__stream);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void ghid_config_init(void)

{
  double dVar1;
  double *pdVar2;
  HID_AttrNode *pHVar3;
  anon_enum_32 aVar4;
  GhidGui *pGVar5;
  int iVar6;
  undefined4 uVar7;
  size_t sVar8;
  char *pcVar9;
  HID_Attribute **ppHVar10;
  HID_Attribute *a;
  HID_Attribute *pHVar11;
  ConfigAttribute *ca;
  ConfigAttribute *pCVar12;
  char *pcVar13;
  char *pcVar14;
  undefined uVar15;
  byte bVar16;
  ConfigAttribute dummy_attribute;
  
  pGVar5 = ghidgui;
  bVar16 = 0;
  ghidgui->n_mode_button_columns = 3;
  pGVar5->small_label_markup = 1;
  pGVar5->auto_pan_on = 1;
  pGVar5->auto_pan_speed = 3;
  pGVar5->history_size = 5;
  dup_string(&color_file,"");
  pHVar3 = hid_attr_nodes;
  do {
    if (pHVar3 == (HID_AttrNode *)0x0) {
      return;
    }
    pHVar11 = pHVar3->attributes;
    iVar6 = pHVar3->n;
    if (pHVar11 < pHVar11 + iVar6) {
      do {
        pdVar2 = (double *)pHVar11->value;
        if (pdVar2 != (double *)0x0) {
          pcVar9 = pHVar11->name;
          pCVar12 = config_attributes;
          do {
            if ((pcVar9 != (char *)0x0) && (iVar6 = strcmp(pcVar9,pCVar12->name), iVar6 == 0)) {
              if ((pCVar12->value == (void *)0x0) && (pCVar12 != (ConfigAttribute *)0x0))
              goto LAB_080f7bbf;
              break;
            }
            pCVar12 = pCVar12 + 1;
          } while (pCVar12 != (ConfigAttribute *)&ghid_dialog_confirm::y);
          pCVar12 = &dummy_attribute;
LAB_080f7bbf:
          aVar4 = pHVar11->type;
          pCVar12->type = CONFIG_Unused;
          pCVar12->value = pdVar2;
          if (7 < (uint)aVar4) {
                    // WARNING: Subroutine does not return
            abort();
          }
          switch(pHVar11->type) {
          case CONFIG_PAGE_COLUMN:
            iVar6 = (pHVar11->default_val).int_value;
            pCVar12->type = (ConfigType)&DAT_00000001;
            *(int *)pdVar2 = iVar6;
            iVar6 = pHVar3->n;
            break;
          case DBUS_BUS_STARTER:
            dVar1 = (pHVar11->default_val).real_value;
            pCVar12->type = CONFIG_Real;
            *pdVar2 = dVar1;
            iVar6 = pHVar3->n;
            break;
          case GDK_CAP_PROJECTING:
            if (pcVar9 != (char *)0x0) {
              uVar7 = g_strdup((pHVar11->default_val).str_value);
              pCVar12->type = CONFIG_String;
              *(undefined4 *)pdVar2 = uVar7;
              pcVar9 = pHVar11->name;
              sVar8 = strlen(pcVar9);
              if ((int)sVar8 < 7) goto LAB_080f7bdf;
              pcVar9 = strstr(pcVar9,"color");
              uVar15 = pcVar9 == (char *)0x0;
              if (!(bool)uVar15) {
                ppHVar10 = (HID_Attribute **)g_malloc0(0x18);
                pcVar9 = pHVar11->name;
                iVar6 = 0xb;
                *ppHVar10 = pHVar11;
                pcVar13 = pcVar9;
                pcVar14 = "layer-color";
                do {
                  if (iVar6 == 0) break;
                  iVar6 = iVar6 + -1;
                  uVar15 = *pcVar13 == *pcVar14;
                  pcVar13 = pcVar13 + (uint)bVar16 * -2 + 1;
                  pcVar14 = pcVar14 + (uint)bVar16 * -2 + 1;
                } while ((bool)uVar15);
                if ((bool)uVar15) {
                  ppHVar10[1] = (HID_Attribute *)0x2;
                }
                else {
                  iVar6 = 0x14;
                  pcVar13 = pcVar9;
                  pcVar14 = "layer-selected-color";
                  do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar15 = *pcVar13 == *pcVar14;
                    pcVar13 = pcVar13 + (uint)bVar16 * -2 + 1;
                    pcVar14 = pcVar14 + (uint)bVar16 * -2 + 1;
                  } while ((bool)uVar15);
                  if ((bool)uVar15) {
                    ppHVar10[1] = (HID_Attribute *)0x3;
                  }
                  else {
                    iVar6 = strncmp(pcVar9 + (sVar8 - 0xe),"selected-color",0xe);
                    ppHVar10[1] = (HID_Attribute *)(uint)(iVar6 == 0);
                  }
                }
                config_color_list = (GList *)g_list_append(config_color_list,ppHVar10);
              }
            }
          default:
            iVar6 = pHVar3->n;
            break;
          case DBUS_WATCH_ERROR:
            *(char *)pdVar2 = (char)(pHVar11->default_val).int_value;
            pCVar12->type = CONFIG_Boolean;
            iVar6 = pHVar3->n;
            break;
          case GDK_AND_REVERSE:
            *(int *)pdVar2 = (pHVar11->default_val).int_value;
LAB_080f7bdf:
            iVar6 = pHVar3->n;
          }
        }
        pHVar11 = pHVar11 + 1;
      } while (pHVar11 < pHVar3->attributes + iVar6);
    }
    pHVar3 = pHVar3->next;
  } while( true );
}



// WARNING: Unknown calling convention

void ghid_config_files_read(gint *argc,gchar ***argv)

{
  double dVar1;
  GList *pGVar2;
  gchar *pgVar3;
  undefined4 uVar4;
  int iVar5;
  char *pcVar6;
  gchar *p;
  gchar *paths;
  GList *list;
  gchar *str;
  gchar *dir;
  int local_24;
  int local_20 [4];
  
  ghidgui = &_ghidgui;
  ghid_config_init();
  load_rc_file("/etc/pcbrc");
  load_rc_file("/usr/local/etc/pcbrc");
  pgVar3 = (gchar *)g_build_filename(pcblibdir,"pcbrc",0);
  load_rc_file(pgVar3);
  g_free(pgVar3);
  uVar4 = g_get_home_dir();
  pgVar3 = (gchar *)g_build_filename(uVar4,&DAT_08153a27,0);
  load_rc_file(pgVar3);
  g_free(pgVar3);
  load_rc_file("pcbrc");
  config_file_read();
  config_colors_read(color_file);
  *argc = *argc + -1;
  *argv = *argv + 1;
  parse_optionv(argc,argv,1);
  if ((board_size_override != (gchar *)0x0) &&
     (iVar5 = sscanf(board_size_override,"%dx%d",local_20,&local_24), iVar5 == 2)) {
    if (Settings.grid_units_mm == '\0') {
      dVar1 = (double)local_20[0] * 100.0;
    }
    else {
      dVar1 = (double)local_20[0] / 0.000254;
    }
    Settings.MaxWidth = (int)ROUND(dVar1 + 0.5);
    if (Settings.grid_units_mm == '\0') {
      Settings.MaxHeight = (int)ROUND((float)local_24 * 100.0 + 0.5);
    }
    else {
      Settings.MaxHeight = (int)ROUND((double)local_24 / 0.000254 + 0.5);
    }
  }
  pGVar2 = lib_newlib_list;
  pcVar6 = Settings.LibraryTree;
  if ((lib_newlib_config != (gchar *)0x0) && (*lib_newlib_config != '\0')) {
    pcVar6 = (char *)g_strdup(lib_newlib_config);
    pgVar3 = strtok(pcVar6,":");
    while ((pgVar3 != (gchar *)0x0 && (*pgVar3 != '\0'))) {
      pgVar3 = expand_dir(pgVar3);
      lib_newlib_list = (GList *)g_list_prepend(lib_newlib_list,pgVar3);
      pgVar3 = strtok((char *)0x0,":");
    }
    g_free(pcVar6);
    pGVar2 = lib_newlib_list;
    pcVar6 = Settings.LibraryTree;
  }
  for (; pGVar2 != (GList *)0x0; pGVar2 = pGVar2->next) {
    Settings.LibraryTree = pcVar6;
    pgVar3 = expand_dir((gchar *)pGVar2->data);
    Settings.LibraryTree = (char *)g_strconcat(pcVar6,&DAT_0814d79c,pgVar3,0);
    g_free(pgVar3);
    g_free(pcVar6);
    pcVar6 = Settings.LibraryTree;
  }
  Settings.LibraryTree = pcVar6;
  return;
}



// WARNING: Unknown calling convention

void ghid_dialog_export(void)

{
  _func_void_char_ptr_varargs *p_Var1;
  HID **ppHVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  HID **ppHVar8;
  HID *pHVar9;
  undefined4 uVar10;
  char *pcVar11;
  HID **ppHVar12;
  HID_conflict1 **hids;
  GtkWidget *button;
  
  uVar3 = gtk_tooltips_new();
  uVar4 = gtk_window_get_type();
  uVar5 = g_type_check_instance_cast(ghid_port.top_window,uVar4);
  uVar6 = dcgettext(&DAT_0815492c,"PCB Export Layout",5);
  export_dialog = (GtkWidget *)gtk_dialog_new_with_buttons(uVar6,uVar5,3,"gtk-cancel",0xfffffffa,0);
  uVar4 = g_type_check_instance_cast(export_dialog,uVar4);
  gtk_window_set_wmclass(uVar4,"PCB_Export",&DAT_08154932);
  uVar4 = gtk_vbox_new(0,6);
  uVar5 = gtk_container_get_type();
  uVar6 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_container_set_border_width(uVar6,6);
  uVar6 = gtk_dialog_get_type();
  iVar7 = g_type_check_instance_cast(export_dialog,uVar6);
  uVar5 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0x94),uVar5);
  gtk_container_add(uVar5,uVar4);
  ppHVar8 = hid_enumerate();
  pHVar9 = *ppHVar8;
  if (pHVar9 != (HID *)0x0) {
    ppHVar2 = ppHVar8 + 1;
    do {
      while (ppHVar12 = ppHVar2, (pHVar9->field_0xc & 4) != 0) {
        exporter = pHVar9;
        uVar5 = gtk_button_new_with_label((*ppHVar8)->name);
        gtk_tooltips_set_tip(uVar3,uVar5,(*ppHVar8)->description,0);
        uVar10 = gtk_box_get_type();
        uVar10 = g_type_check_instance_cast(uVar4,uVar10);
        gtk_box_pack_start(uVar10,uVar5,0,0,0);
        pHVar9 = *ppHVar8;
        uVar5 = g_type_check_instance_cast(uVar5,0x50);
        g_signal_connect_data(uVar5,"clicked",exporter_clicked_cb,pHVar9,0,0);
        pHVar9 = *ppHVar12;
        ppHVar2 = ppHVar12 + 1;
        ppHVar8 = ppHVar12;
        if (pHVar9 == (HID *)0x0) goto LAB_080f81de;
      }
      pHVar9 = *ppHVar12;
      ppHVar2 = ppHVar12 + 1;
      ppHVar8 = ppHVar12;
    } while (pHVar9 != (HID *)0x0);
  }
LAB_080f81de:
  if (exporter == (HID *)0x0) {
    p_Var1 = gui->log;
    pcVar11 = (char *)dcgettext(&DAT_0815492c,"Can\'t find a suitable exporter HID",5);
    (*p_Var1)(pcVar11);
  }
  gtk_widget_show_all(export_dialog);
  uVar3 = g_type_check_instance_cast(export_dialog,uVar6);
  gtk_dialog_run(uVar3);
  if (export_dialog != (GtkWidget *)0x0) {
    gtk_widget_destroy(export_dialog);
  }
  export_dialog = (GtkWidget *)0x0;
  exporter = (HID *)0x0;
  return;
}



// WARNING: Unknown calling convention

int ghid_attribute_dialog
              (HID_Attribute *attrs,int n_attrs,HID_Attr_Val *results,char *title,char *descr)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  int iVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  GtkWidget *pGVar11;
  GtkWidget *pGVar12;
  undefined4 uVar13;
  GtkWidget *vbox1;
  HID_Attribute *pHVar14;
  int iVar15;
  int rc;
  GtkWidget *main_vbox;
  int j;
  GtkWidget *hbox;
  int i;
  char *pcVar16;
  float value;
  gfloat step0;
  gfloat step1;
  gint digits;
  code *cb_func;
  HID_Attr_Val *data;
  undefined4 local_5c;
  undefined4 local_38;
  GtkWidget *local_20 [4];
  
  uVar2 = gtk_tooltips_new();
  uVar3 = gtk_window_get_type();
  uVar4 = g_type_check_instance_cast(ghid_port.top_window,uVar3);
  uVar5 = dcgettext(&DAT_0815492c,title,5);
  uVar4 = gtk_dialog_new_with_buttons(uVar5,uVar4,3,"gtk-cancel",0xffffffff,"gtk-ok",0xfffffffb,0);
  uVar3 = g_type_check_instance_cast(uVar4,uVar3);
  gtk_window_set_wmclass(uVar3,"PCB_attribute_editor",&DAT_08154932);
  pGVar6 = (GtkWidget *)gtk_vbox_new(0,6);
  uVar3 = gtk_container_get_type();
  uVar5 = g_type_check_instance_cast(pGVar6,uVar3);
  gtk_container_set_border_width(uVar5,6);
  uVar5 = gtk_dialog_get_type();
  iVar7 = g_type_check_instance_cast(uVar4,uVar5);
  uVar8 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0x94),uVar3);
  gtk_container_add(uVar8,pGVar6);
  if (descr == (char *)0x0) {
    descr = "";
  }
  pcVar16 = (char *)0x4;
  pGVar6 = ghid_category_vbox(pGVar6,descr,4,2,1,1);
  if (n_attrs < 1) {
LAB_080f8440:
    iVar15 = 1;
    gtk_widget_show_all(uVar4);
    uVar2 = g_type_check_instance_cast(uVar4,uVar5);
    iVar7 = gtk_dialog_run(uVar2);
    if (iVar7 == -5) {
      if (0 < n_attrs) {
        iVar7 = 0;
        do {
          results->int_value = (attrs->default_val).int_value;
          pcVar16 = (attrs->default_val).str_value;
          results->str_value = pcVar16;
          *(undefined4 *)&results->real_value = *(undefined4 *)&(attrs->default_val).real_value;
          *(undefined4 *)((int)&results->real_value + 4) =
               *(undefined4 *)((int)&(attrs->default_val).real_value + 4);
          if (pcVar16 != (char *)0x0) {
            pcVar16 = (char *)__strdup(pcVar16);
            results->str_value = pcVar16;
          }
          iVar7 = iVar7 + 1;
          attrs = attrs + 1;
          results = results + 1;
        } while (iVar7 < n_attrs);
      }
      iVar15 = 0;
    }
    gtk_widget_destroy(uVar4);
    return iVar15;
  }
  iVar7 = 0;
  pHVar14 = attrs;
LAB_080f8403:
  do {
    if (pHVar14->help_text == &DAT_00000001) goto LAB_080f83f8;
    if (7 < (uint)pHVar14->type) {
      pcVar16 = "ghid_attribute_dialog";
      __printf_chk(1,"%s: unknown type of HID attribute\n","ghid_attribute_dialog");
      goto LAB_080f83f8;
    }
    switch(pHVar14->type) {
    case CONFIG_NAME_COLUMN:
      pGVar12 = (GtkWidget *)gtk_label_new(pHVar14->name);
      local_20[0] = pGVar12;
      uVar8 = gtk_box_get_type();
      uVar8 = g_type_check_instance_cast(pGVar6,uVar8);
      gtk_box_pack_start(uVar8,pGVar12,0,0,0);
      break;
    case CONFIG_PAGE_COLUMN:
      pGVar12 = (GtkWidget *)gtk_hbox_new(0,4);
      local_5c = gtk_box_get_type();
      uVar8 = g_type_check_instance_cast(pGVar6,local_5c);
      gtk_box_pack_start(uVar8,pGVar12,0,0,0);
      data = &pHVar14->default_val;
      cb_func = intspinner_changed_cb;
      digits = 0;
      step1 = 1.0;
      step0 = 1.0;
      iVar15 = pHVar14->max_val;
      iVar1 = pHVar14->min_val;
      value = (float)(pHVar14->default_val).int_value;
      goto LAB_080f88c7;
    case DBUS_BUS_STARTER:
      pGVar12 = (GtkWidget *)gtk_hbox_new(0,4);
      local_5c = gtk_box_get_type();
      uVar8 = g_type_check_instance_cast(pGVar6,local_5c);
      gtk_box_pack_start(uVar8,pGVar12,0,0,0);
      data = (HID_Attr_Val *)&(pHVar14->default_val).real_value;
      cb_func = dblspinner_changed_cb;
      digits = 3;
      step1 = 0.01;
      step0 = 0.01;
      iVar15 = pHVar14->max_val;
      iVar1 = pHVar14->min_val;
      value = (float)(pHVar14->default_val).real_value;
LAB_080f88c7:
      ghid_spin_button(pGVar12,local_20,value,(float)iVar1,(float)iVar15,step0,step1,digits,0,
                       cb_func,data,0,(gchar *)0x0);
      gtk_tooltips_set_tip(uVar2,local_20[0],pHVar14->help_text,0);
      pGVar11 = (GtkWidget *)gtk_label_new(pHVar14->name);
      local_20[0] = pGVar11;
      uVar8 = g_type_check_instance_cast(pGVar12,local_5c);
      pcVar16 = (char *)0x0;
      gtk_box_pack_start(uVar8,pGVar11,0,0,0);
      goto LAB_080f83f8;
    case GDK_CAP_PROJECTING:
      uVar8 = gtk_hbox_new(0,4);
      uVar13 = gtk_box_get_type();
      uVar9 = g_type_check_instance_cast(pGVar6,uVar13);
      gtk_box_pack_start(uVar9,uVar8,0,0,0);
      uVar9 = gtk_entry_new();
      uVar10 = g_type_check_instance_cast(uVar8,uVar13);
      gtk_box_pack_start(uVar10,uVar9,0,0,0);
      pcVar16 = (pHVar14->default_val).str_value;
      uVar10 = gtk_entry_get_type();
      uVar10 = g_type_check_instance_cast(uVar9,uVar10);
      gtk_entry_set_text(uVar10,pcVar16);
      gtk_tooltips_set_tip(uVar2,uVar9,pHVar14->help_text,0);
      uVar9 = g_type_check_instance_cast(uVar9,0x50);
      g_signal_connect_data(uVar9,"changed",entry_changed_cb,&(pHVar14->default_val).str_value,0,0);
      pGVar12 = (GtkWidget *)gtk_label_new(pHVar14->name);
      goto LAB_080f863b;
    case DBUS_WATCH_ERROR:
      ghid_check_button_connected
                (pGVar6,local_20,(pHVar14->default_val).int_value,1,0,0,0,set_flag_cb,
                 &pHVar14->default_val,pHVar14->name);
      break;
    case GDK_AND_REVERSE:
      uVar8 = gtk_hbox_new(0,4);
      uVar13 = gtk_box_get_type();
      uVar9 = g_type_check_instance_cast(pGVar6,uVar13);
      gtk_box_pack_start(uVar9,uVar8,0,0,0);
      local_20[0] = (GtkWidget *)gtk_event_box_new();
      gtk_tooltips_set_tip(uVar2,local_20[0],pHVar14->help_text,0);
      pGVar12 = local_20[0];
      uVar9 = g_type_check_instance_cast(uVar8,uVar13);
      gtk_box_pack_start(uVar9,pGVar12,0,0,0);
      uVar9 = gtk_combo_box_new_text();
      uVar10 = g_type_check_instance_cast(local_20[0],uVar3);
      gtk_container_add(uVar10,uVar9);
      uVar10 = g_type_check_instance_cast(uVar9,0x50);
      g_signal_connect_data(uVar10,"changed",enum_changed_cb,&pHVar14->default_val,0,0);
      pcVar16 = *pHVar14->enumerations;
      if (pcVar16 == (char *)0x0) {
        local_38 = gtk_combo_box_get_type();
      }
      else {
        local_38 = gtk_combo_box_get_type();
        iVar15 = 4;
        do {
          uVar10 = g_type_check_instance_cast(uVar9,local_38);
          gtk_combo_box_append_text(uVar10,pcVar16);
          pcVar16 = *(char **)((int)pHVar14->enumerations + iVar15);
          iVar15 = iVar15 + 4;
        } while (pcVar16 != (char *)0x0);
      }
      iVar15 = (pHVar14->default_val).int_value;
      uVar9 = g_type_check_instance_cast(uVar9,local_38);
      gtk_combo_box_set_active(uVar9,iVar15);
      pGVar12 = (GtkWidget *)gtk_label_new(pHVar14->name);
LAB_080f863b:
      local_20[0] = pGVar12;
      uVar8 = g_type_check_instance_cast(uVar8,uVar13);
      pcVar16 = (char *)0x0;
      gtk_box_pack_start(uVar8,pGVar12,0,0,0);
      goto LAB_080f83f8;
    case EXPANSION_AREA:
      goto switchD_080f8412_caseD_6;
    case GDK_NOOP:
      pGVar12 = ghid_category_vbox(pGVar6,pHVar14->name,4,2,1,1);
      uVar8 = gtk_entry_new();
      uVar13 = gtk_box_get_type();
      uVar13 = g_type_check_instance_cast(pGVar12,uVar13);
      gtk_box_pack_start(uVar13,uVar8,0,0,0);
      pcVar16 = (pHVar14->default_val).str_value;
      uVar13 = gtk_entry_get_type();
      uVar13 = g_type_check_instance_cast(uVar8,uVar13);
      gtk_entry_set_text(uVar13,pcVar16);
      uVar13 = g_type_check_instance_cast(uVar8,0x50);
      g_signal_connect_data(uVar13,"changed",entry_changed_cb,&(pHVar14->default_val).str_value,0,0)
      ;
      pcVar16 = pHVar14->help_text;
      gtk_tooltips_set_tip(uVar2,uVar8,pcVar16,0);
      goto LAB_080f83f8;
    }
    pcVar16 = pHVar14->help_text;
    gtk_tooltips_set_tip(uVar2,local_20[0],pcVar16,0);
LAB_080f83f8:
    iVar7 = iVar7 + 1;
    pHVar14 = pHVar14 + 1;
  } while (iVar7 < n_attrs);
  goto LAB_080f8440;
switchD_080f8412_caseD_6:
  iVar7 = iVar7 + 1;
  pHVar14 = pHVar14 + 1;
  __printf_chk(1,"HID_Mixed\n",pcVar16);
  if (n_attrs <= iVar7) goto LAB_080f8440;
  goto LAB_080f8403;
}



// WARNING: Unknown calling convention

void ghid_dialog_print(HID_conflict1 *exporter)

{
  char *descr;
  GtkWidget *pGVar1;
  undefined4 uVar2;
  HID_Attribute *attrs;
  char *title;
  int iVar3;
  HID_Attr_Val *results_00;
  HID_Attr_Val *results;
  int i;
  HID_Attribute *attr;
  HID_Attr_Val *pHVar4;
  int local_20 [4];
  
  pGVar1 = export_dialog;
  local_20[0] = 0;
  if (export_dialog != (GtkWidget *)0x0) {
    uVar2 = gtk_dialog_get_type();
    uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
    gtk_dialog_response(uVar2,0xfffffffa);
  }
  results_00 = (HID_Attr_Val *)0x0;
  attrs = (*exporter->get_export_options)(local_20);
  if (0 < local_20[0]) {
    results_00 = (HID_Attr_Val *)calloc(1,local_20[0] << 4);
    if (results_00 == (HID_Attr_Val *)0x0) {
      __fprintf_chk(stderr,1,"%s() -- malloc failed\n","ghid_dialog_print");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    descr = exporter->description;
    title = (char *)dcgettext(&DAT_0815492c,"PCB Print Layout",5);
    iVar3 = ghid_attribute_dialog(attrs,local_20[0],results_00,title,descr);
    if (iVar3 != 0) {
      return;
    }
  }
  (*exporter->do_export)(results_00);
  if (0 < local_20[0]) {
    iVar3 = 0;
    pHVar4 = results_00;
    do {
      if (pHVar4->str_value != (char *)0x0) {
        free(pHVar4->str_value);
      }
      iVar3 = iVar3 + 1;
      pHVar4 = pHVar4 + 1;
    } while (iVar3 < local_20[0]);
  }
  if (results_00 != (HID_Attr_Val *)0x0) {
    free(results_00);
  }
  return;
}



// WARNING: Unknown calling convention

void exporter_clicked_cb(GtkButton *button,HID_conflict1 *exporter)

{
  ghid_dialog_print(exporter);
  return;
}



// WARNING: Unknown calling convention

void enum_changed_cb(GtkWidget *combo_box,int *val)

{
  gint active;
  undefined4 uVar1;
  int iVar2;
  
  uVar1 = gtk_combo_box_get_type();
  uVar1 = g_type_check_instance_cast(combo_box,uVar1);
  iVar2 = gtk_combo_box_get_active(uVar1);
  *val = iVar2;
  return;
}



// WARNING: Unknown calling convention

void set_flag_cb(GtkToggleButton *button,gboolean *flag)

{
  gboolean gVar1;
  
  gVar1 = gtk_toggle_button_get_active(button);
  *flag = gVar1;
  return;
}



// WARNING: Unknown calling convention

void entry_changed_cb(GtkEntry *entry,char **str)

{
  undefined4 uVar1;
  char *pcVar2;
  gchar *s;
  
  uVar1 = gtk_entry_get_text(entry);
  if (*str != (char *)0x0) {
    free(*str);
  }
  pcVar2 = (char *)__strdup(uVar1);
  *str = pcVar2;
  return;
}



// WARNING: Unknown calling convention

void dblspinner_changed_cb(GtkWidget *spin_button,gpointer data)

{
  undefined4 uVar1;
  longdouble lVar2;
  
  uVar1 = gtk_spin_button_get_type();
  uVar1 = g_type_check_instance_cast(spin_button,uVar1);
  lVar2 = (longdouble)gtk_spin_button_get_value(uVar1);
  *(double *)data = (double)lVar2;
  return;
}



// WARNING: Unknown calling convention

void intspinner_changed_cb(GtkWidget *spin_button,gpointer data)

{
  undefined4 uVar1;
  longdouble lVar2;
  
  uVar1 = gtk_spin_button_get_type();
  uVar1 = g_type_check_instance_cast(spin_button,uVar1);
  lVar2 = (longdouble)gtk_spin_button_get_value(uVar1);
  *(int *)data = (int)ROUND(lVar2);
  return;
}



// WARNING: Unknown calling convention

gchar * ghid_fileselect(char *title,char *descr,char *default_file,char *default_ext,
                       char *history_tag,int flags)

{
  uint uVar1;
  int iVar2;
  int i;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  char *tmps2;
  ghid_file_history *pgVar6;
  char *__s1;
  int iVar7;
  char *tmps;
  int iVar8;
  int history_pool;
  char *pcVar9;
  gchar *base;
  int iVar10;
  char **ppcVar11;
  gchar *path;
  int k;
  gchar *local_38;
  char *local_34;
  int local_2c;
  int local_20;
  
  pgVar6 = recent_dirs;
  iVar10 = n_recent_dirs;
  if ((history_tag == (char *)0x0) || (*history_tag == '\0')) {
    iVar7 = -0x24;
  }
  else {
    if (n_recent_dirs < 1) {
      iVar8 = 0;
    }
    else {
      iVar7 = 0;
      iVar8 = 0;
      do {
        iVar2 = strcmp(*(char **)((int)pgVar6->history + iVar7 + -4),history_tag);
        if (iVar2 == 0) goto LAB_080f8e55;
        iVar8 = iVar8 + 1;
        iVar7 = iVar7 + 0x24;
      } while (iVar8 < iVar10);
    }
    n_recent_dirs = iVar10 + 1;
    pgVar6 = (ghid_file_history *)realloc(pgVar6,n_recent_dirs * 0x24);
    recent_dirs = pgVar6;
    if (pgVar6 == (ghid_file_history *)0x0) {
      __fprintf_chk(stderr,1,"%s():  realloc failed\n","ghid_fileselect");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    iVar7 = iVar8 * 0x24;
    pcVar9 = (char *)__strdup(history_tag);
    pgVar6[iVar8].id = pcVar9;
    pgVar6 = recent_dirs;
    iVar10 = 0;
    do {
      pgVar6[iVar8].history[iVar10] = (char *)0x0;
      iVar10 = iVar10 + 1;
    } while (iVar10 != 8);
  }
LAB_080f8e55:
  if ((default_file == (char *)0x0) || (*default_file == '\0')) {
    pcVar9 = (char *)0x0;
    path = (gchar *)0x0;
  }
  else {
    path = (gchar *)g_path_get_dirname(default_file);
    pcVar9 = (char *)g_path_get_basename(default_file);
  }
  uVar1 = flags & 0xffU ^ 1;
  uVar3 = gtk_window_get_type();
  uVar3 = g_type_check_instance_cast(ghid_port.top_window,uVar3);
  uVar3 = gtk_file_chooser_dialog_new
                    (title,uVar3,uVar1 & 1,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar4 = gtk_dialog_get_type();
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_dialog_set_default_response(uVar5,0xfffffffb);
  if ((path != (gchar *)0x0) && (*path != '\0')) {
    uVar5 = gtk_file_chooser_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_file_chooser_set_current_folder(uVar5,path);
    g_free(path);
  }
  if ((pcVar9 != (char *)0x0) && (*pcVar9 != '\0')) {
    if ((uVar1 & 1) != 0) {
      uVar5 = gtk_file_chooser_get_type();
      uVar5 = g_type_check_instance_cast(uVar3,uVar5);
      gtk_file_chooser_set_current_name(uVar5,pcVar9);
    }
    g_free(pcVar9);
  }
  iVar10 = 0;
  do {
    iVar8 = *(int *)((int)recent_dirs->history + iVar7 + iVar10 * 4);
    if (iVar8 == 0) break;
    uVar5 = gtk_file_chooser_get_type();
    iVar10 = iVar10 + 1;
    uVar5 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_file_chooser_add_shortcut_folder(uVar5,iVar8,0);
  } while (iVar10 != 8);
  uVar4 = g_type_check_instance_cast(uVar3,uVar4);
  iVar10 = gtk_dialog_run(uVar4);
  local_38 = (gchar *)0x0;
  if (iVar10 == -5) {
    uVar4 = gtk_file_chooser_get_type();
    uVar4 = g_type_check_instance_cast(uVar3,uVar4);
    local_38 = (gchar *)gtk_file_chooser_get_filename(uVar4);
    if ((local_38 != (gchar *)0x0) &&
       (pcVar9 = (char *)g_path_get_dirname(local_38), pgVar6 = recent_dirs, pcVar9 != (char *)0x0))
    {
      iVar10 = 0;
      do {
        local_34 = *(char **)((int)pgVar6->history + iVar10 * 4 + iVar7);
        if ((local_34 == (char *)0x0) || (iVar8 = strcmp(local_34,pcVar9), iVar8 != 0))
        goto LAB_080f90e4;
        iVar10 = iVar10 + 1;
      } while (iVar10 != 8);
      local_34 = *(char **)((int)pgVar6[1].history + iVar7 + -4);
LAB_080f90e4:
      local_2c = 1;
      *(char **)((int)pgVar6->history + iVar7) = pcVar9;
      do {
        local_20 = local_2c + iVar10;
        if (local_20 < 8) {
          __s1 = *(char **)((int)pgVar6->history + local_20 * 4 + iVar7);
          if (__s1 != (char *)0x0) {
            ppcVar11 = (char **)((int)pgVar6->history + local_20 * 4 + iVar7 + 4);
            do {
              iVar2 = local_20 + 1;
              iVar8 = strcmp(__s1,pcVar9);
              if (iVar8 != 0) break;
              iVar10 = iVar10 + 1;
              if (7 < iVar2) goto LAB_080f9190;
              __s1 = *ppcVar11;
              ppcVar11 = ppcVar11 + 1;
              local_20 = iVar2;
            } while (__s1 != (char *)0x0);
            __s1 = *(char **)((int)pgVar6->history + local_20 * 4 + iVar7);
          }
        }
        else {
LAB_080f9190:
          __s1 = (char *)0x0;
        }
        *(char **)((int)pgVar6->history + local_2c * 4 + iVar7) = local_34;
        local_2c = local_2c + 1;
        local_34 = __s1;
      } while (local_2c != 8);
      if (__s1 != (char *)0x0) {
        free(__s1);
      }
    }
  }
  gtk_widget_destroy(uVar3);
  return local_38;
}



// WARNING: Unknown calling convention

gchar * ghid_dialog_file_select_save(gchar *title,gchar **path,gchar *file,gchar *shortcuts)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  gchar *seed;
  char *pcVar5;
  gchar *src;
  GtkWidget *dialog;
  gchar *folder;
  gchar *pgVar6;
  gchar *result;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_file_chooser_dialog_new(title,uVar1,1,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar2 = gtk_dialog_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_set_default_response(uVar3,0xfffffffb);
  if (((path != (gchar **)0x0) && (pcVar5 = *path, pcVar5 != (char *)0x0)) && (*pcVar5 != '\0')) {
    uVar3 = gtk_file_chooser_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_file_chooser_set_current_folder(uVar3,pcVar5);
  }
  if ((file != (gchar *)0x0) && (*file != '\0')) {
    uVar3 = gtk_file_chooser_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_file_chooser_set_current_name(uVar3,file);
  }
  if ((shortcuts != (gchar *)0x0) && (*shortcuts != '\0')) {
    seed = (gchar *)g_strdup(shortcuts);
    while( true ) {
      pcVar5 = strtok(seed,":");
      if (pcVar5 == (char *)0x0) break;
      uVar3 = gtk_file_chooser_get_type();
      uVar3 = g_type_check_instance_cast(uVar1,uVar3);
      gtk_file_chooser_add_shortcut_folder(uVar3,pcVar5,0);
      seed = (gchar *)0x0;
    }
    g_free(0);
  }
  pgVar6 = (gchar *)0x0;
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  iVar4 = gtk_dialog_run(uVar2);
  if (iVar4 == -5) {
    uVar2 = gtk_file_chooser_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar2);
    pgVar6 = (gchar *)gtk_file_chooser_get_filename(uVar3);
    uVar2 = g_type_check_instance_cast(uVar1,uVar2);
    src = (gchar *)gtk_file_chooser_get_current_folder(uVar2);
    if ((src != (gchar *)0x0) && (path != (gchar **)0x0)) {
      dup_string(path,src);
      g_free(src);
    }
  }
  gtk_widget_destroy(uVar1);
  return pgVar6;
}



// WARNING: Unknown calling convention

gchar * ghid_dialog_file_select_open(gchar *title,gchar **path,gchar *shortcuts)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  char *pcVar6;
  int iVar7;
  gchar *seed;
  gchar *src;
  GtkWidget *dialog;
  GtkFileFilter *net_filter;
  gchar *folder;
  gchar *pgVar8;
  gchar *result;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_file_chooser_dialog_new(title,uVar1,0,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar2 = gtk_dialog_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_set_default_response(uVar3,0xfffffffb);
  uVar3 = gtk_file_filter_new();
  gtk_file_filter_set_name(uVar3,"all");
  gtk_file_filter_add_pattern(uVar3,&DAT_081548e7);
  gtk_file_filter_add_pattern(uVar3,&DAT_081548e9);
  uVar4 = gtk_file_chooser_get_type();
  uVar5 = g_type_check_instance_cast(uVar1,uVar4);
  gtk_file_chooser_add_filter(uVar5,uVar3);
  pcVar6 = (char *)dcgettext(&DAT_0815492c,"Load element to buffer",5);
  iVar7 = strcmp(title,pcVar6);
  if (iVar7 == 0) {
    uVar3 = gtk_file_filter_new();
    gtk_file_filter_set_name(uVar3,&DAT_08154909);
    gtk_file_filter_add_mime_type(uVar3,"application/x-pcb-footprint");
    gtk_file_filter_add_pattern(uVar3,&DAT_08154907);
    gtk_file_filter_add_pattern(uVar3,&DAT_0815490c);
    uVar5 = g_type_check_instance_cast(uVar1,uVar4);
    gtk_file_chooser_add_filter(uVar5,uVar3);
  }
  pcVar6 = (char *)dcgettext(&DAT_0815492c,"Load layout file",5);
  iVar7 = strcmp(title,pcVar6);
  if (iVar7 != 0) {
    pcVar6 = (char *)dcgettext(&DAT_0815492c,"Load layout file to buffer",5);
    iVar7 = strcmp(title,pcVar6);
    if (iVar7 != 0) goto LAB_080f9584;
  }
  uVar3 = gtk_file_filter_new();
  gtk_file_filter_set_name(uVar3,&DAT_0815492c);
  gtk_file_filter_add_mime_type(uVar3,"application/x-pcb-layout");
  gtk_file_filter_add_pattern(uVar3,&DAT_0815492a);
  gtk_file_filter_add_pattern(uVar3,&DAT_08154930);
  uVar5 = g_type_check_instance_cast(uVar1,uVar4);
  gtk_file_chooser_add_filter(uVar5,uVar3);
LAB_080f9584:
  pcVar6 = (char *)dcgettext(&DAT_0815492c,"Load netlist file",5);
  iVar7 = strcmp(title,pcVar6);
  if (iVar7 == 0) {
    uVar3 = gtk_file_filter_new();
    gtk_file_filter_set_name(uVar3,"netlist");
    gtk_file_filter_add_mime_type(uVar3,"application/x-pcb-netlist");
    gtk_file_filter_add_pattern(uVar3,&DAT_08154950);
    gtk_file_filter_add_pattern(uVar3,"*.NET");
    uVar5 = g_type_check_instance_cast(uVar1,uVar4);
    gtk_file_chooser_add_filter(uVar5,uVar3);
  }
  if ((path != (gchar **)0x0) && (pgVar8 = *path, pgVar8 != (gchar *)0x0)) {
    uVar3 = g_type_check_instance_cast(uVar1,uVar4);
    gtk_file_chooser_set_current_folder(uVar3,pgVar8);
  }
  if ((shortcuts != (gchar *)0x0) && (*shortcuts != '\0')) {
    seed = (gchar *)g_strdup(shortcuts);
    while( true ) {
      pcVar6 = strtok(seed,":");
      if (pcVar6 == (char *)0x0) break;
      uVar3 = g_type_check_instance_cast(uVar1,uVar4);
      gtk_file_chooser_add_shortcut_folder(uVar3,pcVar6,0);
      seed = (gchar *)0x0;
    }
    g_free(0);
  }
  pgVar8 = (gchar *)0x0;
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  iVar7 = gtk_dialog_run(uVar2);
  if (iVar7 == -5) {
    uVar2 = g_type_check_instance_cast(uVar1,uVar4);
    pgVar8 = (gchar *)gtk_file_chooser_get_filename(uVar2);
    uVar2 = g_type_check_instance_cast(uVar1,uVar4);
    src = (gchar *)gtk_file_chooser_get_current_folder(uVar2);
    if ((src != (gchar *)0x0) && (path != (gchar **)0x0)) {
      dup_string(path,src);
      g_free(src);
    }
  }
  gtk_widget_destroy(uVar1);
  return pgVar8;
}



// WARNING: Unknown calling convention

void ghid_dialog_message(gchar *message)

{
  undefined4 uVar1;
  undefined4 uVar2;
  GtkWidget *dialog;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_message_dialog_new(uVar1,3,1,1,message);
  uVar2 = gtk_dialog_get_type();
  uVar1 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_run(uVar1);
  gtk_widget_destroy();
  return;
}



// WARNING: Unknown calling convention

int ghid_dialog_close_confirm(void)

{
  char *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  gchar *tmp;
  GtkWidget *dialog;
  int iVar7;
  gint rv;
  
  pcVar1 = PCB->Filename;
  if (pcVar1 == (char *)0x0) {
    uVar2 = dcgettext(&DAT_0815492c,"Save the changes to layout before closing?",5);
    tmp = (gchar *)g_strdup_printf(uVar2);
  }
  else {
    uVar2 = dcgettext(&DAT_0815492c,"Save the changes to layout \"%s\" before closing?",5);
    tmp = (gchar *)g_strdup_printf(uVar2,pcVar1);
  }
  uVar2 = g_strconcat(&DAT_08154967,tmp,"</b></big>",0);
  g_free(tmp);
  uVar3 = dcgettext(&DAT_0815492c,"If you don\'t save, all your changes will be permanently lost.",5
                   );
  uVar2 = g_strconcat(uVar2,"\n\n",uVar3,0);
  uVar3 = gtk_window_get_type();
  uVar3 = g_type_check_instance_cast(ghid_port.top_window,uVar3);
  uVar3 = gtk_message_dialog_new(uVar3,3,1,0,0);
  uVar4 = gtk_message_dialog_get_type();
  uVar4 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_message_dialog_set_markup(uVar4,uVar2);
  uVar2 = dcgettext(&DAT_0815492c,"Close without saving",5);
  uVar4 = gtk_dialog_get_type();
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_dialog_add_buttons(uVar5,uVar2,0xfffffff7,"gtk-cancel",0xfffffffa,"gtk-save",0xfffffff8,0);
  uVar2 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_dialog_set_alternative_button_order(uVar2,0xfffffff8,0xfffffff7,0xfffffffa,0xffffffff);
  iVar7 = 0;
  uVar2 = g_type_check_instance_cast(uVar3,uVar4);
  iVar6 = gtk_dialog_run(uVar2);
  if (iVar6 + 9U < 2) {
    iVar7 = *(int *)((int)&CSWTCH_117 + (iVar6 + 9U) * 4);
  }
  gtk_widget_destroy(uVar3);
  return iVar7;
}



// WARNING: Unknown calling convention

gboolean ghid_dialog_confirm(gchar *message,gchar *cancelmsg,gchar *okmsg)

{
  gint gVar1;
  gint gVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  GtkWidget *dialog;
  
  if (cancelmsg == (gchar *)0x0) {
    cancelmsg = (gchar *)dcgettext(&DAT_0815492c,"_Cancel",5);
  }
  if (okmsg == (gchar *)0x0) {
    okmsg = (gchar *)dcgettext(&DAT_0815492c,&DAT_08152330,5);
  }
  uVar3 = gtk_window_get_type();
  uVar4 = g_type_check_instance_cast(ghid_port.top_window,uVar3);
  uVar4 = gtk_message_dialog_new(uVar4,3,2,0,message);
  uVar5 = gtk_dialog_get_type();
  uVar6 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_dialog_add_buttons(uVar6,cancelmsg,0xfffffffa,okmsg,0xfffffffb,0);
  gVar2 = ghid_dialog_confirm::x;
  gVar1 = ghid_dialog_confirm::y;
  if (ghid_dialog_confirm::x != -1) {
    uVar6 = g_type_check_instance_cast(uVar4,uVar3);
    gtk_window_move(uVar6,gVar2,gVar1);
  }
  uVar5 = g_type_check_instance_cast(uVar4,uVar5);
  iVar7 = gtk_dialog_run(uVar5);
  uVar3 = g_type_check_instance_cast(uVar4,uVar3);
  gtk_window_get_position(uVar3,&ghid_dialog_confirm::x,&ghid_dialog_confirm::y);
  gtk_widget_destroy(uVar4);
  return (uint)(iVar7 == -5);
}



// WARNING: Unknown calling convention

gint ghid_dialog_confirm_all(gchar *all_message)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  GtkWidget *pGVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  gint gVar7;
  GtkWidget *vbox;
  GtkWidget *dialog;
  gint response;
  GtkWidget *label;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_dialog_new_with_buttons
                    ("Confirm",uVar1,3,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,"Sequence OK",1,0
                    );
  uVar2 = gtk_dialog_get_type();
  iVar3 = g_type_check_instance_cast(uVar1,uVar2);
  pGVar4 = ghid_framed_vbox(*(GtkWidget **)(iVar3 + 0x94),(gchar *)0x0,6,0,4,6);
  uVar5 = gtk_label_new(all_message);
  uVar6 = gtk_box_get_type();
  uVar6 = g_type_check_instance_cast(pGVar4,uVar6);
  gtk_box_pack_start(uVar6,uVar5,0,0,3);
  gtk_widget_show_all(uVar1);
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  gVar7 = gtk_dialog_run(uVar2);
  gtk_widget_destroy(uVar1);
  return gVar7;
}



// WARNING: Unknown calling convention

void ghid_dialog_about(void)

{
  char *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *dialog;
  
  pcVar1 = GetInfoString();
  uVar2 = gtk_window_get_type();
  uVar2 = g_type_check_instance_cast(ghid_port.top_window,uVar2);
  uVar2 = gtk_message_dialog_new(uVar2,3,0,1,pcVar1);
  uVar3 = gtk_dialog_get_type();
  uVar3 = g_type_check_instance_cast(uVar2,uVar3);
  gtk_dialog_run(uVar3);
  gtk_widget_destroy(uVar2);
  return;
}



// WARNING: Unknown calling convention

gchar * ghid_dialog_input(gchar *prompt,gchar *initial)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  char *pcVar9;
  int iVar10;
  gboolean response;
  gchar *string;
  GtkWidget *dialog;
  GtkWidget *vbox;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_dialog_new_with_buttons
                    ("PCB User Input",uVar1,1,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar2 = gtk_dialog_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_set_default_response(uVar3,0xfffffffb);
  uVar3 = gtk_vbox_new(0,4);
  uVar4 = gtk_container_get_type();
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_container_set_border_width(uVar5,4);
  uVar5 = gtk_label_new(&DAT_0814741b);
  uVar6 = gtk_box_get_type();
  uVar7 = g_type_check_instance_cast(uVar3,uVar6);
  gtk_box_pack_start(uVar7,uVar5,1,1,0);
  uVar7 = gtk_label_get_type();
  uVar8 = g_type_check_instance_cast(uVar5,uVar7);
  gtk_label_set_use_markup(uVar8,1);
  pcVar9 = "Enter something";
  if (prompt != (gchar *)0x0) {
    pcVar9 = prompt;
  }
  uVar5 = g_type_check_instance_cast(uVar5,uVar7);
  gtk_label_set_markup(uVar5,pcVar9);
  uVar5 = gtk_entry_new();
  if (initial == (gchar *)0x0) {
    uVar7 = gtk_entry_get_type();
  }
  else {
    uVar7 = gtk_entry_get_type();
    uVar8 = g_type_check_instance_cast(uVar5,uVar7);
    gtk_entry_set_text(uVar8,initial);
  }
  uVar7 = g_type_check_instance_cast(uVar5,uVar7);
  gtk_entry_set_activates_default(uVar7,1);
  uVar6 = g_type_check_instance_cast(uVar3,uVar6);
  gtk_box_pack_start_defaults(uVar6,uVar5);
  iVar10 = g_type_check_instance_cast(uVar1,uVar2);
  uVar4 = g_type_check_instance_cast(*(undefined4 *)(iVar10 + 0x94),uVar4);
  gtk_container_add(uVar4,uVar3);
  gtk_widget_show_all(uVar1);
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  iVar10 = gtk_dialog_run(uVar2);
  if (iVar10 == -5) {
    uVar2 = gtk_editable_get_type();
    uVar2 = g_type_check_instance_cast(uVar5,uVar2);
    string = (gchar *)gtk_editable_get_chars(uVar2,0,0xffffffff);
  }
  else {
    if (initial == (gchar *)0x0) {
      initial = "";
    }
    string = (gchar *)g_strdup(initial);
  }
  gtk_widget_destroy(uVar1);
  return string;
}



// WARNING: Unknown calling convention

gint drc_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  ghidgui->drc_window_width = (widget->allocation).width;
  gVar1 = (widget->allocation).height;
  pGVar2->config_modified = 1;
  pGVar2->drc_window_height = gVar1;
  return 0;
}



// WARNING: Unknown calling convention

void drc_destroy_cb(GtkWidget *widget,gpointer data)

{
  drc_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void ghid_drc_window_reset_message(void)

{
  if (drc_list_model != (GtkListStore *)0x0) {
    gtk_list_store_clear(drc_list_model);
  }
  num_violations = 0;
  return;
}



// WARNING: Unknown calling convention

void drc_close_cb(gpointer data)

{
  gtk_widget_destroy(drc_window);
  drc_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void drc_refresh_cb(gpointer data)

{
  hid_actionl("DRC",0);
  return;
}



// WARNING: Unknown calling convention

void row_activated_cb(GtkTreeView *view,GtkTreePath *path,GtkTreeViewColumn *column,
                     gpointer user_data)

{
  undefined4 uVar1;
  GtkTreeModel *model;
  GtkTreeIter iter;
  int local_10;
  
  uVar1 = gtk_tree_view_get_model(view);
  gtk_tree_model_get_iter(uVar1,&iter,path);
  gtk_tree_model_get(uVar1,&iter,1,&local_10,0xffffffff);
  if (local_10 != 0) {
    CenterDisplay(*(LocationType *)(local_10 + 0x14),*(LocationType *)(local_10 + 0x18),'\0');
  }
  return;
}



// WARNING: Unknown calling convention

void unset_found_flags(int AndDraw)

{
  int *piVar1;
  bool bVar2;
  Cardinal sn_1;
  uint uVar3;
  PCBTypePtr pPVar4;
  Cardinal sn_2;
  DataTypePtr paVar5;
  LayerTypePtr layer_1;
  LayerTypePtr pLVar6;
  int change;
  uint uVar7;
  Cardinal n;
  Cardinal n_1;
  PadTypePtr pad;
  PadTypePtr Pad;
  Cardinal n_3;
  LineTypePtr line_1;
  LineTypePtr Line;
  ArcTypePtr arc;
  ArcTypePtr Arc;
  PolygonTypePtr polygon;
  PolygonTypePtr Polygon;
  PinTypePtr via;
  Cardinal n_2;
  PinTypePtr pin;
  PinTypePtr paVar8;
  uint uVar9;
  Cardinal n_4;
  int iVar10;
  Cardinal n_5;
  Cardinal n_6;
  Cardinal sn;
  ElementTypePtr element;
  uchar *Ptr1;
  RatTypePtr line;
  RatTypePtr Line_00;
  LayerTypePtr layer;
  int iVar11;
  int local_24;
  uint local_20;
  
  bVar2 = false;
  uVar7 = 0;
  paVar5 = PCB->Data;
  pPVar4 = PCB;
  uVar3 = paVar5->ViaN;
  if (paVar5->ViaN != 0) {
    do {
      paVar8 = paVar5->Via + uVar7;
      if ((*(byte *)&(paVar8->Flags).f & 4) == 0) {
        paVar5 = pPVar4->Data;
        uVar9 = paVar5->ViaN;
      }
      else {
        AddObjectToFlagUndoList(1,paVar8,paVar8,paVar8);
        (paVar8->Flags).f = (paVar8->Flags).f & 0xfffffffb;
        DrawVia(paVar8,0);
        bVar2 = true;
        paVar5 = PCB->Data;
        uVar9 = paVar5->ViaN;
        pPVar4 = PCB;
      }
    } while ((uVar9 != 0) && (uVar7 = (uVar9 + 1 + uVar7) - uVar3, uVar3 = uVar9, uVar7 < uVar9));
  }
  local_20 = paVar5->ElementN - 1;
  if (local_20 != -1) {
    iVar10 = paVar5->ElementN * 300;
    while( true ) {
      local_24 = iVar10 + -300;
      Ptr1 = paVar5->Element[-1].Flags.t + iVar10 + -0x18;
      if (*(uint *)(Ptr1 + 0xe0) != 0) {
        uVar7 = 0;
        uVar3 = *(uint *)(Ptr1 + 0xe0);
        do {
          paVar8 = (PinTypePtr)(uVar7 * 0x4c + *(int *)(Ptr1 + 0x100));
          uVar9 = uVar3;
          if ((*(byte *)&(paVar8->Flags).f & 4) != 0) {
            AddObjectToFlagUndoList(0x100,Ptr1,paVar8,paVar8);
            (paVar8->Flags).f = (paVar8->Flags).f & 0xfffffffb;
            DrawPin(paVar8,0);
            bVar2 = true;
            uVar9 = *(uint *)(Ptr1 + 0xe0);
          }
        } while ((uVar9 != 0) && (uVar7 = (uVar7 + 1 + uVar9) - uVar3, uVar3 = uVar9, uVar7 < uVar9)
                );
      }
      uVar3 = *(uint *)(Ptr1 + 0xe8);
      uVar7 = uVar3;
      for (uVar9 = 0; (uVar7 != 0 && (uVar9 < uVar7)); uVar9 = uVar9 + (uVar3 == uVar7)) {
        Pad = (PadTypePtr)(uVar9 * 0x68 + *(int *)(Ptr1 + 0x104));
        if ((*(byte *)&(Pad->Flags).f & 4) != 0) {
          AddObjectToFlagUndoList(0x200,Ptr1,Pad,Pad);
          (Pad->Flags).f = (Pad->Flags).f & 0xfffffffb;
          DrawPad(Pad,0);
          uVar7 = *(uint *)(Ptr1 + 0xe8);
          bVar2 = true;
        }
      }
      local_20 = local_20 + -1;
      if (local_20 == -1) break;
      paVar5 = PCB->Data;
      iVar10 = local_24;
    }
    paVar5 = PCB->Data;
    pPVar4 = PCB;
  }
  iVar10 = paVar5->RatN - 1;
  if (iVar10 != -1) {
    iVar11 = paVar5->RatN * 0x5c;
    while( true ) {
      Line_00 = (RatTypePtr)(paVar5->Rat[-1].Flags.t + iVar11 + -0x18);
      if ((*(byte *)&(Line_00->Flags).f & 4) != 0) {
        AddObjectToFlagUndoList(0x20,Line_00,Line_00,Line_00);
        (Line_00->Flags).f = (Line_00->Flags).f & 0xfffffffb;
        DrawRat(Line_00,0);
        bVar2 = true;
        pPVar4 = PCB;
      }
      if (iVar10 == 0) break;
      iVar10 = iVar10 + -1;
      paVar5 = pPVar4->Data;
      iVar11 = iVar11 + -0x5c;
    }
    paVar5 = pPVar4->Data;
  }
  pLVar6 = paVar5->Layer;
  if (paVar5->LayerN != 0) {
    local_20 = 0;
    do {
      iVar10 = pLVar6->LineN - 1;
      if (iVar10 != -1) {
        iVar11 = pLVar6->LineN * 0x58 + -0x58;
        do {
          while (Line = (LineTypePtr)((pLVar6->Line->Flags).t + iVar11 + -0x18),
                (*(byte *)&(Line->Flags).f & 4) != 0) {
            iVar10 = iVar10 + -1;
            iVar11 = iVar11 + -0x58;
            AddObjectToFlagUndoList(4,pLVar6,Line,Line);
            (Line->Flags).f = (Line->Flags).f & 0xfffffffb;
            DrawLine(pLVar6,Line,0);
            bVar2 = true;
            pPVar4 = PCB;
            if (iVar10 == -1) goto LAB_080fa4ac;
          }
          iVar10 = iVar10 + -1;
          iVar11 = iVar11 + -0x58;
          pPVar4 = PCB;
        } while (iVar10 != -1);
      }
LAB_080fa4ac:
      local_20 = local_20 + 1;
      uVar3 = pPVar4->Data->LayerN;
      if (uVar3 <= local_20) goto LAB_080fa4d6;
      pLVar6 = pLVar6 + 1;
    } while( true );
  }
  goto LAB_080fa4c6;
LAB_080fa4d6:
  pLVar6 = pPVar4->Data->Layer;
  if (uVar3 != 0) {
    local_20 = 0;
    do {
      iVar10 = pLVar6->ArcN - 1;
      if (iVar10 != -1) {
        iVar11 = pLVar6->ArcN * 0x44 + -0x44;
        do {
          while (Arc = (ArcTypePtr)((pLVar6->Arc->Flags).t + iVar11 + -0x18),
                (*(byte *)&(Arc->Flags).f & 4) != 0) {
            iVar10 = iVar10 + -1;
            iVar11 = iVar11 + -0x44;
            AddObjectToFlagUndoList(0x4000,pLVar6,Arc,Arc);
            (Arc->Flags).f = (Arc->Flags).f & 0xfffffffb;
            DrawArc(pLVar6,Arc,0);
            bVar2 = true;
            pPVar4 = PCB;
            if (iVar10 == -1) goto LAB_080fa564;
          }
          iVar10 = iVar10 + -1;
          iVar11 = iVar11 + -0x44;
          pPVar4 = PCB;
        } while (iVar10 != -1);
      }
LAB_080fa564:
      local_20 = local_20 + 1;
      uVar3 = pPVar4->Data->LayerN;
      if (uVar3 <= local_20) goto LAB_080fa57e;
      pLVar6 = pLVar6 + 1;
    } while( true );
  }
  goto LAB_080fa4c6;
LAB_080fa57e:
  pLVar6 = pPVar4->Data->Layer;
  if (uVar3 != 0) {
    local_20 = 0;
    do {
      iVar10 = pLVar6->PolygonN - 1;
      if (iVar10 != -1) {
        iVar11 = pLVar6->PolygonN * 0x3c + -0x3c;
        do {
          while (Polygon = (PolygonTypePtr)((pLVar6->Polygon->Flags).t + iVar11 + -0x18),
                (*(byte *)&(Polygon->Flags).f & 4) != 0) {
            iVar10 = iVar10 + -1;
            iVar11 = iVar11 + -0x3c;
            AddObjectToFlagUndoList(8,pLVar6,Polygon,Polygon);
            (Polygon->Flags).f = (Polygon->Flags).f & 0xfffffffb;
            DrawPolygon(pLVar6,Polygon,0);
            bVar2 = true;
            pPVar4 = PCB;
            if (iVar10 == -1) goto LAB_080fa614;
          }
          iVar10 = iVar10 + -1;
          iVar11 = iVar11 + -0x3c;
          pPVar4 = PCB;
        } while (iVar10 != -1);
      }
LAB_080fa614:
      local_20 = local_20 + 1;
      piVar1 = &pPVar4->Data->LayerN;
      if ((uint)*piVar1 < local_20 || *piVar1 == local_20) break;
      pLVar6 = pLVar6 + 1;
    } while( true );
  }
LAB_080fa4c6:
  if ((bVar2) && (SetChangedFlag('\x01'), AndDraw != 0)) {
    IncrementUndoSerialNumber();
    Draw();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void selection_changed_cb(GtkTreeSelection *selection,gpointer user_data)

{
  int type;
  int iVar1;
  int found_type;
  char *Format;
  int iVar2;
  int iVar3;
  int i;
  int object_type;
  int object_id;
  GtkTreeIter iter;
  void *local_30;
  void *local_2c;
  LayerTypePtr local_28;
  int local_24;
  undefined4 local_20 [4];
  
  iVar1 = gtk_tree_selection_get_selected(selection,local_20,&iter);
  if (iVar1 == 0) {
    unset_found_flags(1);
    return;
  }
  iVar1 = gtk_tree_model_iter_has_child(local_20[0],&iter);
  if (iVar1 == 0) {
    gtk_tree_model_get(local_20[0],&iter,1,&local_24,0xffffffff);
    unset_found_flags(0);
    if (local_24 != 0) {
      if (0 < *(int *)(local_24 + 0x3c)) {
        iVar1 = 0;
        do {
          while( true ) {
            iVar3 = *(int *)(*(int *)(local_24 + 0x40) + iVar1 * 4);
            type = *(int *)(*(int *)(local_24 + 0x44) + iVar1 * 4);
            iVar2 = SearchObjectByID(PCB->Data,&local_28,&local_2c,&local_30,iVar3,type);
            if (iVar2 == 0) break;
            AddObjectToFlagUndoList(type,local_28,local_2c,local_30);
            iVar3 = *(int *)(local_24 + 0x44);
            *(uint *)((int)local_2c + 0x14) = *(uint *)((int)local_2c + 0x14) | 4;
            iVar3 = *(int *)(iVar3 + iVar1 * 4);
            if (((iVar3 == 8) || (iVar3 == 0x4000)) || (iVar3 == 4)) {
              iVar3 = GetLayerNumber(PCB->Data,local_28);
              ChangeGroupVisibility(iVar3,'\x01','\x01');
            }
            iVar1 = iVar1 + 1;
            DrawObject(type,local_28,local_2c,0);
            if (*(int *)(local_24 + 0x3c) == iVar1 || *(int *)(local_24 + 0x3c) < iVar1)
            goto LAB_080fa7d0;
          }
          iVar1 = iVar1 + 1;
          Format = (char *)dcgettext(&DAT_0815492c,
                                     "Object ID %i identified during DRC was not found. Stale DRC window?\n"
                                     ,5);
          Message(Format,iVar3);
        } while (*(int *)(local_24 + 0x3c) != iVar1 && iVar1 <= *(int *)(local_24 + 0x3c));
      }
LAB_080fa7d0:
      SetChangedFlag('\x01');
      IncrementUndoSerialNumber();
      Draw();
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

GType ghid_violation_renderer_get_type(void)

{
  undefined4 uVar1;
  
  if (ghid_violation_renderer_get_type::ghid_violation_renderer_type != 0) {
    return ghid_violation_renderer_get_type::ghid_violation_renderer_type;
  }
  uVar1 = gtk_cell_renderer_text_get_type();
  ghid_violation_renderer_get_type::ghid_violation_renderer_type =
       g_type_register_static
                 (uVar1,"GhidViolationRenderer",
                  &ghid_violation_renderer_get_type::lexical_block_0::ghid_violation_renderer_info,0
                 );
  return ghid_violation_renderer_get_type::ghid_violation_renderer_type;
}



// WARNING: Unknown calling convention

GtkCellRenderer * ghid_violation_renderer_new(void)

{
  GType GVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkCellRenderer *pGVar4;
  
  GVar1 = ghid_violation_renderer_get_type();
  uVar2 = g_object_new(GVar1,&DAT_08154a82,6,0);
  uVar3 = gtk_cell_renderer_get_type();
  pGVar4 = (GtkCellRenderer *)g_type_check_instance_cast(uVar2,uVar3);
  return pGVar4;
}



// WARNING: Unknown calling convention

void ghid_drc_window_show(gboolean raise)

{
  gint gVar1;
  gint gVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  GtkWidget *pGVar8;
  undefined4 uVar9;
  GtkCellRenderer *pGVar10;
  GtkWidget *button;
  GtkCellRenderer *violation_renderer;
  GtkWidget *vbox;
  GtkWidget *scrolled_window;
  GtkWidget *hbox;
  
  pGVar8 = drc_window;
  if (drc_window == (GtkWidget *)0x0) {
    drc_window = (GtkWidget *)gtk_window_new(0);
    uVar3 = g_type_check_instance_cast(drc_window,0x50);
    g_signal_connect_data(uVar3,"destroy",drc_destroy_cb,0,0,0);
    uVar3 = g_type_check_instance_cast(drc_window,0x50);
    g_signal_connect_data(uVar3,"configure_event",drc_window_configure_event_cb,0,0,0);
    uVar3 = dcgettext(&DAT_0815492c,&DAT_08154a97,5);
    uVar4 = gtk_window_get_type();
    uVar5 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_window_set_title(uVar5,uVar3);
    uVar3 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_window_set_wmclass(uVar3,"PCB_DRC",&DAT_08154932);
    gVar1 = ghidgui->drc_window_height;
    gVar2 = ghidgui->drc_window_width;
    uVar3 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_window_set_default_size(uVar3,gVar2,gVar1);
    uVar3 = gtk_vbox_new(0,0);
    uVar4 = gtk_container_get_type();
    uVar5 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_container_add(uVar5,uVar3);
    uVar5 = g_type_check_instance_cast(uVar3,uVar4);
    gtk_container_set_border_width(uVar5,6);
    uVar5 = gtk_box_get_type();
    uVar6 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_box_set_spacing(uVar6,6);
    drc_list_model = (GtkListStore *)gtk_list_store_new(2,0x18,0x50);
    uVar6 = gtk_scrolled_window_new(0,0);
    uVar7 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_box_pack_start(uVar7,uVar6,1,1,0);
    uVar7 = gtk_scrolled_window_get_type();
    uVar7 = g_type_check_instance_cast(uVar6,uVar7);
    gtk_scrolled_window_set_policy(uVar7,1,1);
    uVar7 = gtk_tree_model_get_type();
    uVar7 = g_type_check_instance_cast(drc_list_model,uVar7);
    pGVar8 = (GtkWidget *)gtk_tree_view_new_with_model(uVar7);
    drc_list = pGVar8;
    uVar4 = g_type_check_instance_cast(uVar6,uVar4);
    gtk_container_add(uVar4,pGVar8);
    uVar4 = gtk_tree_view_get_type();
    uVar6 = g_type_check_instance_cast(drc_list,uVar4);
    gtk_tree_view_set_rules_hint(uVar6,1);
    uVar6 = g_type_check_instance_cast(drc_list,uVar4);
    uVar6 = gtk_tree_view_get_selection(uVar6);
    g_signal_connect_data(uVar6,"changed",selection_changed_cb,0,0,0);
    g_signal_connect_data(drc_list,"row-activated",row_activated_cb,0,0,0);
    uVar6 = gtk_cell_renderer_text_new();
    uVar7 = dcgettext(&DAT_0815492c,&DAT_08154ab5,5);
    uVar9 = g_type_check_instance_cast(drc_list,uVar4);
    gtk_tree_view_insert_column_with_attributes(uVar9,0xffffffff,uVar7,uVar6,&DAT_081539ac,0,0);
    pGVar10 = ghid_violation_renderer_new();
    uVar6 = dcgettext(&DAT_0815492c,"Violation details",5);
    uVar4 = g_type_check_instance_cast(drc_list,uVar4);
    gtk_tree_view_insert_column_with_attributes(uVar4,0xffffffff,uVar6,pGVar10,"violation",1,0);
    uVar4 = gtk_hbutton_box_new();
    uVar6 = gtk_button_box_get_type();
    uVar6 = g_type_check_instance_cast(uVar4,uVar6);
    gtk_button_box_set_layout(uVar6,4);
    uVar3 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_box_pack_start(uVar3,uVar4,0,0,0);
    uVar3 = g_type_check_instance_cast(uVar4,uVar5);
    gtk_box_set_spacing(uVar3,6);
    uVar3 = gtk_button_new_from_stock("gtk-refresh");
    uVar6 = g_type_check_instance_cast(uVar3,0x50);
    g_signal_connect_data(uVar6,"clicked",drc_refresh_cb,0,0,0);
    uVar6 = g_type_check_instance_cast(uVar4,uVar5);
    gtk_box_pack_start(uVar6,uVar3,1,1,0);
    uVar3 = gtk_button_new_from_stock("gtk-close");
    uVar6 = g_type_check_instance_cast(uVar3,0x50);
    g_signal_connect_data(uVar6,"clicked",drc_close_cb,0,0,0);
    uVar4 = g_type_check_instance_cast(uVar4,uVar5);
    gtk_box_pack_start(uVar4,uVar3,1,1,0);
    gtk_widget_realize(drc_window);
    if (Settings.AutoPlace != '\0') {
      uVar3 = gtk_widget_get_type();
      uVar3 = g_type_check_instance_cast(drc_window,uVar3);
      gtk_widget_set_uposition(uVar3,10,10);
    }
    gtk_widget_show_all();
    return;
  }
  if (raise == 0) {
    return;
  }
  uVar3 = gtk_window_get_type();
  g_type_check_instance_cast(pGVar8,uVar3);
  gtk_window_present();
  return;
}



// WARNING: Unknown calling convention

int ghid_drc_window_throw_dialog(void)

{
  ghid_drc_window_show(1);
  return 1;
}



// WARNING: Unknown calling convention

GType ghid_drc_violation_get_type(void)

{
  if (ghid_drc_violation_get_type::ghid_drc_violation_type != 0) {
    return ghid_drc_violation_get_type::ghid_drc_violation_type;
  }
  ghid_drc_violation_get_type::ghid_drc_violation_type =
       g_type_register_static
                 (0x50,"GhidDrcViolation",
                  &ghid_drc_violation_get_type::lexical_block_0::ghid_drc_violation_info,0);
  return ghid_drc_violation_get_type::ghid_drc_violation_type;
}



// WARNING: Unknown calling convention

GhidDrcViolation * ghid_drc_violation_new(DrcViolationType *violation,GdkDrawable *pixmap)

{
  double dVar1;
  double dVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  char *pcVar8;
  char *pcVar9;
  char *pcVar10;
  GType GVar11;
  GhidDrcViolation *pGVar12;
  object_list obj_list;
  
  obj_list.count = violation->object_count;
  dVar1 = violation->required_value;
  dVar2 = violation->measured_value;
  obj_list.id_list = violation->object_id_list;
  iVar3 = violation->y;
  iVar4 = violation->value_digits;
  iVar5 = violation->have_measured;
  obj_list.type_list = violation->object_type_list;
  iVar6 = violation->x;
  iVar7 = violation->angle;
  pcVar8 = violation->value_units;
  pcVar9 = violation->explanation;
  pcVar10 = violation->title;
  GVar11 = ghid_drc_violation_get_type();
  pGVar12 = (GhidDrcViolation *)
            g_object_new(GVar11,"title",pcVar10,"explanation",pcVar9,"x-coord",iVar6,"y-coord",iVar3
                         ,"angle",iVar7,"have-measured",iVar5,"measured-value",dVar2,
                         "required-value",dVar1,"value-digits",iVar4,"value-units",pcVar8,
                         "object-list",&obj_list,"pixmap",pixmap,0);
  return pGVar12;
}



// WARNING: Unknown calling convention

void ghid_drc_window_append_violation(DrcViolationType *violation)

{
  GhidDrcViolation *pGVar1;
  GhidDrcViolation *violation_obj;
  GtkTreeIter iter;
  
  ghid_drc_window_show(0);
  num_violations = num_violations + 1;
  pGVar1 = ghid_drc_violation_new(violation,(GdkDrawable *)0x0);
  gtk_list_store_append(drc_list_model,&iter);
  gtk_list_store_set(drc_list_model,&iter,0,num_violations,1,pGVar1,0xffffffff);
  g_object_unref(pGVar1);
  return;
}



// WARNING: Unknown calling convention

void ghid_violation_renderer_get_size
               (GtkCellRenderer *cell,GtkWidget *widget,GdkRectangle *cell_area,gint *x_offset,
               gint *y_offset,gint *width,gint *height)

{
  undefined4 uVar1;
  int iVar2;
  gint gVar3;
  
  uVar1 = gtk_cell_renderer_get_type();
  iVar2 = g_type_check_class_cast(ghid_violation_renderer_parent_class,uVar1);
  (**(code **)(iVar2 + 0x50))(cell,widget,cell_area,x_offset,y_offset,width,height);
  if (width != (gint *)0x0) {
    *width = *width + 100;
  }
  if (height != (gint *)0x0) {
    gVar3 = 100;
    if (99 < *height) {
      gVar3 = *height;
    }
    *height = gVar3;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_violation_renderer_finalize(GObject *object)

{
  GType GVar1;
  int iVar2;
  
  GVar1 = ghid_violation_renderer_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  if (*(int *)(iVar2 + 0x58) != 0) {
    g_object_unref(*(int *)(iVar2 + 0x58));
  }
  iVar2 = g_type_check_class_cast(ghid_violation_renderer_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x080fb1fa. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



// WARNING: Unknown calling convention

void ghid_violation_renderer_class_init(GhidViolationRendererClass *klass)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  GType GVar4;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  uVar2 = gtk_cell_renderer_get_type();
  iVar3 = g_type_check_class_cast(klass,uVar2);
  *(code **)(iVar1 + 0x18) = ghid_violation_renderer_finalize;
  *(code **)(iVar1 + 0xc) = ghid_violation_renderer_set_property;
  *(code **)(iVar1 + 0x10) = ghid_violation_renderer_get_property;
  *(code **)(iVar3 + 0x50) = ghid_violation_renderer_get_size;
  *(code **)(iVar3 + 0x54) = ghid_violation_renderer_render;
  ghid_violation_renderer_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  GVar4 = ghid_drc_violation_get_type();
  uVar2 = g_param_spec_object("violation",&DAT_0814741b,&DAT_0814741b,GVar4,2);
  g_object_class_install_property(iVar1,1,uVar2);
  return;
}



// WARNING: Unknown calling convention

void ghid_violation_renderer_render
               (GtkCellRenderer *cell,GdkDrawable *window,GtkWidget *widget,
               GdkRectangle *background_area,GdkRectangle *cell_area,GdkRectangle *expose_area,
               GtkCellRendererState flags)

{
  int iVar1;
  GtkStyle *pGVar2;
  GType GVar3;
  int iVar4;
  undefined4 uVar5;
  int iVar6;
  undefined4 uVar7;
  int iVar8;
  GdkPixmap *pGVar9;
  GdkPixmap *pixmap;
  GhidDrcViolation *violation;
  
  GVar3 = ghid_violation_renderer_get_type();
  iVar4 = g_type_check_instance_cast(cell,GVar3);
  cell_area->width = cell_area->width + -100;
  iVar4 = *(int *)(iVar4 + 0x58);
  uVar5 = gtk_cell_renderer_get_type();
  iVar6 = g_type_check_class_cast(ghid_violation_renderer_parent_class,uVar5);
  (**(code **)(iVar6 + 0x54))(cell,window,widget,background_area,cell_area,expose_area,flags);
  if (iVar4 != 0) {
    iVar6 = *(int *)(iVar4 + 0x48);
    if (iVar6 == 0) {
      iVar6 = gdk_drawable_get_depth(window);
      pGVar9 = ghid_render_pixmap(*(int *)(iVar4 + 0x14),*(int *)(iVar4 + 0x18),111.0,0x5a,0x5a,
                                  iVar6);
      g_object_set(iVar4,"pixmap",pGVar9,0);
      g_object_unref(pGVar9);
      iVar6 = *(int *)(iVar4 + 0x48);
      if (iVar6 == 0) {
        return;
      }
    }
    uVar5 = gdk_drawable_get_type();
    uVar5 = g_type_check_instance_cast(iVar6,uVar5);
    iVar4 = cell_area->y;
    iVar6 = cell_area->x;
    iVar1 = cell_area->width;
    pGVar2 = widget->style;
    uVar7 = gtk_widget_get_type();
    iVar8 = g_type_check_instance_cast(widget,uVar7);
    gdk_draw_drawable(window,pGVar2->fg_gc[*(byte *)(iVar8 + 0x12)],uVar5,0,0,iVar6 + iVar1 + 5,
                      iVar4 + 5,0xffffffff,0xffffffff);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_violation_renderer_get_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = g_type_name(((object->g_type_instance).g_class)->g_type);
  uVar2 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
  g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
        "../../src/hid/gtk/gui-drc-window.c:712","property",property_id,pspec->name,uVar2,uVar1);
  return;
}



// WARNING: Unknown calling convention

void ghid_drc_violation_get_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = g_type_name(((object->g_type_instance).g_class)->g_type);
  uVar2 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
  g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
        "../../src/hid/gtk/gui-drc-window.c:416","property",property_id,pspec->name,uVar2,uVar1);
  return;
}



// WARNING: Unknown calling convention

void ghid_violation_renderer_set_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  GType GVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  char *markup;
  
  GVar1 = ghid_violation_renderer_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  if (property_id == 1) {
    if (*(int *)(iVar2 + 0x58) != 0) {
      g_object_unref(*(int *)(iVar2 + 0x58));
    }
    iVar5 = g_value_dup_object(value);
    *(int *)(iVar2 + 0x58) = iVar5;
    if (iVar5 != 0) {
      if (*(int *)(iVar5 + 0x20) == 0) {
        markup = (char *)g_strdup_printf("<b>%s</b>\n<span size=\'1024\'> </span>\n<small><i>%s</i>\n<span size=\'5120\'> </span>\nRequired: %.*f %s</small>"
                                         ,*(undefined4 *)(iVar5 + 0xc),*(undefined4 *)(iVar5 + 0x10)
                                         ,*(undefined4 *)(iVar5 + 0x34),
                                         (int)*(undefined8 *)(iVar5 + 0x2c),
                                         (int)((ulonglong)*(undefined8 *)(iVar5 + 0x2c) >> 0x20),
                                         *(undefined4 *)(iVar5 + 0x38));
      }
      else {
        markup = (char *)g_strdup_printf("<b>%s (%.*f %s)</b>\n<span size=\'1024\'> </span>\n<small><i>%s</i>\n<span size=\'5120\'> </span>\nRequired: %.*f %s</small>"
                                         ,*(undefined4 *)(iVar5 + 0xc),*(undefined4 *)(iVar5 + 0x34)
                                         ,(int)*(undefined8 *)(iVar5 + 0x24),
                                         (int)((ulonglong)*(undefined8 *)(iVar5 + 0x24) >> 0x20),
                                         *(undefined4 *)(iVar5 + 0x38),*(undefined4 *)(iVar5 + 0x10)
                                         ,*(undefined4 *)(iVar5 + 0x34),
                                         *(undefined8 *)(iVar5 + 0x2c),*(undefined4 *)(iVar5 + 0x38)
                                        );
      }
      g_object_set(object,"markup",markup,0);
      g_free();
      return;
    }
  }
  else {
    uVar3 = g_type_name(((object->g_type_instance).g_class)->g_type);
    uVar4 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
    g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
          "../../src/hid/gtk/gui-drc-window.c:648","property",property_id,pspec->name,uVar4,uVar3);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_drc_violation_finalize(GObject *object)

{
  GType GVar1;
  int iVar2;
  
  GVar1 = ghid_drc_violation_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  g_free(*(undefined4 *)(iVar2 + 0xc));
  g_free(*(undefined4 *)(iVar2 + 0x10));
  g_free(*(undefined4 *)(iVar2 + 0x38));
  g_free(*(undefined4 *)(iVar2 + 0x40));
  g_free(*(undefined4 *)(iVar2 + 0x44));
  if (*(int *)(iVar2 + 0x48) != 0) {
    g_object_unref(*(int *)(iVar2 + 0x48));
  }
  iVar2 = g_type_check_class_cast(ghid_drc_violation_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x080fb735. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



// WARNING: Unknown calling convention

void ghid_drc_violation_class_init(GhidViolationRendererClass *klass)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  *(code **)(iVar1 + 0x18) = ghid_drc_violation_finalize;
  *(code **)(iVar1 + 0xc) = ghid_drc_violation_set_property;
  *(code **)(iVar1 + 0x10) = ghid_drc_violation_get_property;
  ghid_drc_violation_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  uVar2 = g_param_spec_string("title",&DAT_0814741b,&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,1,uVar2);
  uVar2 = g_param_spec_string("explanation",&DAT_0814741b,&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,2,uVar2);
  uVar2 = g_param_spec_int("x-coord",&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,3,uVar2);
  uVar2 = g_param_spec_int("y-coord",&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,4,uVar2);
  uVar2 = g_param_spec_int("angle",&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,5,uVar2);
  uVar2 = g_param_spec_int("have-measured",&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,6,uVar2);
  uVar2 = g_param_spec_double("measured-value",&DAT_0814741b,&DAT_0814741b,0xffefffffffffffff,
                              0x7fefffffffffffff,0,2);
  g_object_class_install_property(iVar1,7,uVar2);
  uVar2 = g_param_spec_double("required-value",&DAT_0814741b,&DAT_0814741b,0x8010000000000000,
                              0x7fefffffffffffff,0,2);
  g_object_class_install_property(iVar1,8,uVar2);
  uVar2 = g_param_spec_int("value-digits",&DAT_0814741b,&DAT_0814741b,0,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,9,uVar2);
  uVar2 = g_param_spec_string("value-units",&DAT_0814741b,&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,10,uVar2);
  uVar2 = g_param_spec_pointer("object-list",&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,0xb,uVar2);
  uVar2 = gdk_drawable_get_type();
  uVar2 = g_param_spec_object("pixmap",&DAT_0814741b,&DAT_0814741b,uVar2,2);
  g_object_class_install_property(iVar1,0xc,uVar2);
  return;
}



// WARNING: Unknown calling convention

void ghid_drc_violation_set_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  int iVar1;
  void *__src;
  GType GVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int *piVar6;
  GhidDrcViolation *violation;
  longdouble lVar7;
  
  GVar2 = ghid_drc_violation_get_type();
  iVar3 = g_type_check_instance_cast(object,GVar2);
  switch(property_id) {
  default:
    uVar4 = g_type_name(((object->g_type_instance).g_class)->g_type);
    uVar5 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
    g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
          "../../src/hid/gtk/gui-drc-window.c:391","property",property_id,pspec->name,uVar5,uVar4);
    break;
  case 1:
    g_free(*(undefined4 *)(iVar3 + 0xc));
    uVar4 = g_value_dup_string(value);
    *(undefined4 *)(iVar3 + 0xc) = uVar4;
    break;
  case 2:
    g_free(*(undefined4 *)(iVar3 + 0x10));
    uVar4 = g_value_dup_string(value);
    *(undefined4 *)(iVar3 + 0x10) = uVar4;
    break;
  case 3:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x14) = uVar4;
    break;
  case 4:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x18) = uVar4;
    break;
  case 5:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x1c) = uVar4;
    break;
  case 6:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x20) = uVar4;
    break;
  case 7:
    lVar7 = (longdouble)g_value_get_double(value);
    *(double *)(iVar3 + 0x24) = (double)lVar7;
    break;
  case 8:
    lVar7 = (longdouble)g_value_get_double(value);
    *(double *)(iVar3 + 0x2c) = (double)lVar7;
    break;
  case 9:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x34) = uVar4;
    break;
  case 10:
    g_free(*(undefined4 *)(iVar3 + 0x38));
    uVar4 = g_value_dup_string(value);
    *(undefined4 *)(iVar3 + 0x38) = uVar4;
    break;
  case 0xb:
    g_free(*(undefined4 *)(iVar3 + 0x40));
    g_free(*(undefined4 *)(iVar3 + 0x44));
    piVar6 = (int *)g_value_get_pointer(value);
    *(int *)(iVar3 + 0x3c) = *piVar6;
    uVar4 = g_malloc_n(*piVar6,4);
    *(undefined4 *)(iVar3 + 0x40) = uVar4;
    uVar4 = g_malloc_n(*piVar6,4);
    iVar1 = *piVar6;
    __src = (void *)piVar6[1];
    *(undefined4 *)(iVar3 + 0x44) = uVar4;
    memcpy(*(void **)(iVar3 + 0x40),__src,iVar1 << 2);
    memcpy(*(void **)(iVar3 + 0x44),(void *)piVar6[2],*piVar6 << 2);
    return;
  case 0xc:
    if (*(int *)(iVar3 + 0x48) != 0) {
      g_object_unref(*(int *)(iVar3 + 0x48));
    }
    uVar4 = g_value_dup_object(value);
    *(undefined4 *)(iVar3 + 0x48) = uVar4;
  }
  return;
}



// WARNING: Unknown calling convention

gint library_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  ghidgui->library_window_width = (widget->allocation).width;
  gVar1 = (widget->allocation).height;
  pGVar2->config_modified = 1;
  pGVar2->library_window_height = gVar1;
  return 0;
}



// WARNING: Unknown calling convention

GType ghid_library_window_get_type(void)

{
  undefined4 uVar1;
  
  if (ghid_library_window_get_type::library_window_type != 0) {
    return ghid_library_window_get_type::library_window_type;
  }
  uVar1 = gtk_dialog_get_type();
  ghid_library_window_get_type::library_window_type =
       g_type_register_static
                 (uVar1,"GhidLibraryWindow",
                  &ghid_library_window_get_type::lexical_block_0::library_window_info,0);
  return ghid_library_window_get_type::library_window_type;
}



// WARNING: Unknown calling convention

void library_window_class_init(GhidLibraryWindowClass *klass)

{
  int iVar1;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  *(code **)(iVar1 + 8) = library_window_constructor;
  *(code **)(iVar1 + 0x18) = library_window_finalize;
  library_window_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  return;
}



// WARNING: Unknown calling convention

void library_window_finalize(GObject *object)

{
  GType GVar1;
  int iVar2;
  
  GVar1 = ghid_library_window_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  if (*(int *)(iVar2 + 0xb8) != 0) {
    g_source_remove(*(int *)(iVar2 + 0xb8));
    *(undefined4 *)(iVar2 + 0xb8) = 0;
  }
  iVar2 = g_type_check_class_cast(library_window_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x080fbe92. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



// WARNING: Unknown calling convention

GObject * library_window_constructor
                    (GType type,guint n_construct_properties,GObjectConstructParam *construct_params
                    )

{
  int iVar1;
  Cardinal CVar2;
  int iVar3;
  GObject *pGVar4;
  GType GVar5;
  undefined4 uVar6;
  int iVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  Cardinal n;
  undefined4 uVar15;
  LibraryEntryTypePtr entry;
  undefined4 uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  undefined4 uVar19;
  undefined4 uVar20;
  undefined4 uVar21;
  GtkTreeStore *tree;
  GtkTreeSelection *selection;
  LibraryMenuTypePtr menu;
  undefined4 *puVar22;
  int iVar23;
  int local_7c;
  int local_78;
  GtkTreeIter c_iter;
  GtkTreeIter e_iter;
  GtkTreeIter p_iter;
  GtkTreeIter iter;
  char *local_20 [4];
  
  iVar3 = g_type_check_class_cast(library_window_parent_class,0x50);
  pGVar4 = (GObject *)(**(code **)(iVar3 + 8))(type,n_construct_properties,construct_params);
  GVar5 = ghid_library_window_get_type();
  iVar3 = g_type_check_instance_cast(pGVar4,GVar5);
  uVar6 = dcgettext(&DAT_0815492c,"Select Footprint...",5);
  g_object_set(pGVar4,"type",0,"title",uVar6,"default-height",300,"default-width",400,"modal",0,
               "window-position",0,"has-separator",1,0);
  uVar6 = gtk_dialog_get_type();
  iVar7 = g_type_check_instance_cast(iVar3,uVar6);
  g_object_set(*(undefined4 *)(iVar7 + 0x94),"homogeneous",0,0);
  uVar8 = gtk_widget_get_type();
  uVar9 = gtk_hpaned_get_type();
  uVar9 = g_object_new(uVar9,"border-width",5,0);
  uVar9 = g_type_check_instance_cast(uVar9,uVar8);
  *(undefined4 *)(iVar3 + 0xa0) = uVar9;
  uVar10 = gtk_notebook_get_type();
  uVar11 = g_object_new(uVar10,"show-tabs",0,0);
  uVar11 = g_type_check_instance_cast(uVar11,uVar8);
  uVar12 = g_type_check_instance_cast(uVar11,uVar10);
  *(undefined4 *)(iVar3 + 0xa8) = uVar12;
  uVar12 = gtk_vbox_get_type();
  uVar12 = g_object_new(uVar12,"border-width",5,"homogeneous",0,"spacing",5,0);
  uVar12 = g_type_check_instance_cast(uVar12,uVar8);
  uVar13 = gtk_tree_store_new(3,0x40,0x44,0x44);
  CVar2 = Library.MenuN;
  local_78 = Library.MenuN - 1;
  if (local_78 != -1) {
    uVar14 = gtk_tree_model_get_type();
    iVar7 = CVar2 * 0x1c;
    do {
      local_7c = iVar7 + -0x1c;
      puVar22 = (undefined4 *)((int)&Library.Menu[-1].Name + iVar7);
      if (puVar22[1] == 0) {
        uVar15 = g_strdup(&DAT_0815d8d1);
        puVar22[1] = uVar15;
      }
      uVar15 = g_type_check_instance_cast(uVar13,uVar14);
      iVar7 = gtk_tree_model_get_iter_first(uVar15,&e_iter);
      while (iVar7 != 0) {
        uVar15 = g_type_check_instance_cast(uVar13,uVar14);
        gtk_tree_model_get(uVar15,&e_iter,0,local_20,0xffffffff);
        iVar7 = strcmp(local_20[0],(char *)puVar22[1]);
        if (iVar7 == 0) goto LAB_080fc248;
        uVar15 = g_type_check_instance_cast(uVar13,uVar14);
        iVar7 = gtk_tree_model_iter_next(uVar15,&e_iter);
      }
      gtk_tree_store_append(uVar13,&p_iter,0);
      gtk_tree_store_set(uVar13,&p_iter,0,puVar22[1],1,0,2,0,0xffffffff);
LAB_080fc248:
      gtk_tree_store_append(uVar13,&iter,&p_iter);
      gtk_tree_store_set(uVar13,&iter,0,*puVar22,1,puVar22,2,0,0xffffffff);
      iVar7 = puVar22[3] + -1;
      if (iVar7 != -1) {
        iVar23 = puVar22[3] * 0x18;
        do {
          iVar23 = iVar23 + -0x18;
          iVar7 = iVar7 + -1;
          iVar1 = puVar22[5];
          gtk_tree_store_append(uVar13,&c_iter,&iter);
          gtk_tree_store_set(uVar13,&c_iter,0,*(undefined4 *)(iVar23 + iVar1),1,puVar22,2,
                             (undefined4 *)(iVar23 + iVar1),0xffffffff);
        } while (iVar7 != -1);
      }
      local_78 = local_78 + -1;
      iVar7 = local_7c;
    } while (local_78 != -1);
  }
  uVar14 = gtk_tree_sortable_get_type();
  uVar14 = g_type_check_instance_cast(uVar13,uVar14);
  gtk_tree_sortable_set_sort_column_id(uVar14,0,0);
  uVar14 = gtk_tree_model_filter_get_type();
  uVar13 = g_object_new(uVar14,"child-model",uVar13,"virtual-root",0,0);
  uVar14 = gtk_scrolled_window_get_type();
  uVar14 = g_object_new(uVar14,"hscrollbar-policy",1,"vscrollbar-policy",0,"shadow-type",3,0);
  uVar14 = g_type_check_instance_cast(uVar14,uVar8);
  uVar15 = gtk_tree_view_get_type();
  uVar16 = g_object_new(uVar15,"model",uVar13,"rules-hint",1,"headers-visible",0,0);
  uVar16 = g_type_check_instance_cast(uVar16,uVar8);
  g_signal_connect_data(uVar16,"row-activated",tree_row_activated,0,0,0);
  uVar17 = g_type_check_instance_cast(uVar16,uVar15);
  uVar17 = gtk_tree_view_get_selection(uVar17);
  gtk_tree_selection_set_mode(uVar17,1);
  g_signal_connect_data(uVar17,"changed",library_window_callback_tree_selection_changed,iVar3,0,0);
  uVar17 = gtk_cell_renderer_get_type();
  uVar18 = gtk_cell_renderer_text_get_type();
  uVar18 = g_object_new(uVar18,"editable",0,0);
  uVar17 = g_type_check_instance_cast(uVar18,uVar17);
  uVar18 = dcgettext(&DAT_0815492c,"Components",5);
  uVar19 = gtk_tree_view_column_get_type();
  uVar18 = g_object_new(uVar19,"title",uVar18,0);
  uVar18 = g_type_check_instance_cast(uVar18,uVar19);
  gtk_tree_view_column_pack_start(uVar18,uVar17,1);
  gtk_tree_view_column_set_attributes(uVar18,uVar17,&DAT_081539ac,0,0);
  uVar17 = g_type_check_instance_cast(uVar16,uVar15);
  gtk_tree_view_append_column(uVar17,uVar18);
  uVar17 = gtk_container_get_type();
  uVar18 = g_type_check_instance_cast(uVar14,uVar17);
  gtk_container_add(uVar18,uVar16);
  uVar18 = g_type_check_instance_cast(uVar16,uVar15);
  *(undefined4 *)(iVar3 + 0xa4) = uVar18;
  uVar18 = gtk_box_get_type();
  uVar19 = g_type_check_instance_cast(uVar12,uVar18);
  gtk_box_pack_start(uVar19,uVar14,1,1,0);
  uVar14 = gtk_hbox_get_type();
  uVar14 = g_object_new(uVar14,"homogeneous",0,"spacing",3,0);
  uVar14 = g_type_check_instance_cast(uVar14,uVar8);
  uVar19 = dcgettext(&DAT_0815492c,"Filter:",5);
  uVar20 = gtk_label_get_type();
  uVar19 = g_object_new(uVar20,"xalign",0,"label",uVar19,0);
  uVar19 = g_type_check_instance_cast(uVar19,uVar8);
  uVar20 = g_type_check_instance_cast(uVar14,uVar18);
  gtk_box_pack_start(uVar20,uVar19,0,0,0);
  uVar19 = gtk_entry_get_type();
  uVar20 = g_object_new(uVar19,&DAT_081539ac,&DAT_0814741b);
  uVar20 = g_type_check_instance_cast(uVar20,uVar8);
  g_signal_connect_data(uVar20,"changed",library_window_callback_filter_entry_changed,iVar3,0,0);
  gtk_tree_model_filter_set_visible_func(uVar13,lib_model_filter_visible_func,iVar3);
  uVar13 = g_type_check_instance_cast(uVar14,uVar18);
  gtk_box_pack_start(uVar13,uVar20,1,1,0);
  uVar13 = g_type_check_instance_cast(uVar20,uVar19);
  *(undefined4 *)(iVar3 + 0xb8) = 0;
  *(undefined4 *)(iVar3 + 0xb0) = uVar13;
  uVar13 = gtk_button_get_type();
  uVar19 = g_object_new(uVar13,"sensitive",0,"relief",2,0);
  uVar19 = g_type_check_instance_cast(uVar19,uVar8);
  uVar20 = gtk_image_new_from_stock("gtk-clear",2);
  uVar21 = g_type_check_instance_cast(uVar19,uVar17);
  gtk_container_add(uVar21,uVar20);
  g_signal_connect_data(uVar19,"clicked",library_window_callback_filter_button_clicked,iVar3,0,0);
  uVar20 = g_type_check_instance_cast(uVar14,uVar18);
  gtk_box_pack_start(uVar20,uVar19,0,0,0);
  uVar13 = g_type_check_instance_cast(uVar19,uVar13);
  *(undefined4 *)(iVar3 + 0xb4) = uVar13;
  uVar13 = g_type_check_instance_cast(uVar12,uVar18);
  gtk_box_pack_start(uVar13,uVar14,0,0,0);
  uVar13 = g_type_check_instance_cast(uVar16,uVar15);
  *(undefined4 *)(iVar3 + 0xa4) = uVar13;
  uVar13 = dcgettext(&DAT_0815492c,"Libraries",5);
  uVar13 = gtk_label_new(uVar13);
  uVar10 = g_type_check_instance_cast(uVar11,uVar10);
  gtk_notebook_append_page(uVar10,uVar12,uVar13);
  uVar10 = gtk_paned_get_type();
  uVar12 = g_type_check_instance_cast(uVar9,uVar10);
  gtk_paned_pack1(uVar12,uVar11,1);
  uVar11 = dcgettext(&DAT_0815492c,"Preview",5);
  uVar12 = gtk_frame_get_type();
  uVar11 = g_object_new(uVar12,"label",uVar11);
  uVar11 = g_type_check_instance_cast(uVar11,uVar8);
  uVar12 = gtk_alignment_get_type();
  uVar12 = g_object_new(uVar12,"left-padding",5,"right-padding",5,"top-padding",5,"bottom-padding",5
                        ,"xscale",0x3ff0000000000000,"yscale",0x3ff0000000000000,"xalign",
                        0x3fe0000000000000,"yalign",0x3fe0000000000000,0);
  uVar8 = g_type_check_instance_cast(uVar12,uVar8);
  GVar5 = ghid_pinout_preview_get_type();
  uVar12 = g_object_new(GVar5,"element-data",0,"width-request",0x96,"height-request",0x96,0);
  uVar13 = g_type_check_instance_cast(uVar8,uVar17);
  gtk_container_add(uVar13,uVar12);
  uVar13 = g_type_check_instance_cast(uVar11,uVar17);
  gtk_container_add(uVar13,uVar8);
  *(undefined4 *)(iVar3 + 0xac) = uVar12;
  uVar8 = g_type_check_instance_cast(uVar9,uVar10);
  gtk_paned_pack2(uVar8,uVar11,0);
  iVar7 = g_type_check_instance_cast(iVar3,uVar6);
  uVar8 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0x94),uVar18);
  gtk_box_pack_start(uVar8,uVar9,1,1,0);
  gtk_widget_show_all(uVar9);
  uVar6 = g_type_check_instance_cast(iVar3,uVar6);
  gtk_dialog_add_buttons(uVar6,"gtk-close",0xfffffff9,0);
  return pGVar4;
}



// WARNING: Unknown calling convention

void library_window_callback_filter_button_clicked(GtkButton *button,gpointer user_data)

{
  GType GVar1;
  
  GVar1 = ghid_library_window_get_type();
  g_type_check_instance_cast(user_data,GVar1);
  gtk_entry_set_text();
  return;
}



// WARNING: Unknown calling convention

gboolean lib_model_filter_visible_func(GtkTreeModel *model,GtkTreeIter *iter,gpointer data)

{
  GType GVar1;
  GType __t;
  int iVar2;
  gboolean __r;
  undefined4 uVar3;
  gboolean ret;
  gboolean gVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  GtkTreeIter iter2;
  undefined4 local_20 [4];
  
  GVar1 = ghid_library_window_get_type();
                    // WARNING: Load size is inaccurate
  if ((data != (gpointer)0x0) &&
     (((*data != (GType *)0x0 && (GVar1 == **data)) ||
      (iVar2 = g_type_check_instance_is_a(data,GVar1), iVar2 != 0)))) {
    uVar3 = gtk_entry_get_text(*(undefined4 *)((int)data + 0xb0));
    iVar2 = g_ascii_strcasecmp(uVar3,&DAT_0814741b);
    if (iVar2 != 0) {
      iVar2 = gtk_tree_model_iter_has_child(model,iter);
      if (iVar2 == 0) {
        gtk_tree_model_get(model,iter,0,local_20,0xffffffff);
        uVar5 = g_ascii_strup(local_20[0],0xffffffff);
        uVar3 = g_ascii_strup(uVar3,0xffffffff);
        uVar6 = g_strconcat(&DAT_081548e9,uVar3,&DAT_081548e9,0);
        gVar4 = g_pattern_match_simple(uVar6,uVar5);
        g_free(uVar5);
        g_free(uVar3);
        g_free(uVar6);
        return gVar4;
      }
      gtk_tree_model_iter_children(model,&iter2,iter);
      while (gVar4 = lib_model_filter_visible_func(model,&iter2,data), gVar4 == 0) {
        iVar2 = gtk_tree_model_iter_next(model,&iter2);
        if (iVar2 == 0) {
          return 0;
        }
      }
    }
    return 1;
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr
            (0,"../../src/hid/gtk/gui-library-window.c",0xe0,"lib_model_filter_visible_func",
             "GHID_IS_LIBRARY_WINDOW (data)");
}



// WARNING: Unknown calling convention

void library_window_callback_filter_entry_changed(GtkEditable *editable,gpointer user_data)

{
  GType GVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  bool bVar7;
  GhidLibraryWindow *library_window;
  gboolean sensitive;
  
  GVar1 = ghid_library_window_get_type();
  iVar2 = g_type_check_instance_cast(user_data,GVar1);
  uVar3 = gtk_widget_get_type();
  uVar3 = g_type_check_instance_cast(*(undefined4 *)(iVar2 + 0xb4),uVar3);
  uVar4 = gtk_entry_get_text(*(undefined4 *)(iVar2 + 0xb0));
  iVar5 = g_ascii_strcasecmp(uVar4,&DAT_0814741b);
  uVar4 = gtk_object_get_type();
  iVar6 = g_type_check_instance_cast(uVar3,uVar4);
  if ((*(byte *)(iVar6 + 0xd) & 2) != 0) {
    iVar6 = g_type_check_instance_cast(uVar3,uVar4);
    bVar7 = true;
    if ((*(byte *)(iVar6 + 0xd) & 4) != 0) goto LAB_080fcf2d;
  }
  bVar7 = false;
LAB_080fcf2d:
  if (bVar7 != (iVar5 != 0)) {
    gtk_widget_set_sensitive(uVar3,iVar5 != 0);
  }
  if (*(int *)(iVar2 + 0xb8) != 0) {
    g_source_remove(*(int *)(iVar2 + 0xb8));
  }
  uVar3 = g_timeout_add(200,library_window_filter_timeout,iVar2);
  *(undefined4 *)(iVar2 + 0xb8) = uVar3;
  return;
}



// WARNING: Unknown calling convention

gboolean library_window_filter_timeout(gpointer data)

{
  GType GVar1;
  int iVar2;
  GtkTreeModel *model;
  
  GVar1 = ghid_library_window_get_type();
  iVar2 = g_type_check_instance_cast(data,GVar1);
  *(undefined4 *)(iVar2 + 0xb8) = 0;
  iVar2 = gtk_tree_view_get_model(*(undefined4 *)(iVar2 + 0xa4));
  if (iVar2 != 0) {
    gtk_tree_model_filter_refilter(iVar2);
  }
  return 0;
}



// WARNING: Unknown calling convention

void library_window_callback_tree_selection_changed(GtkTreeSelection *selection,gpointer user_data)

{
  Boolean BVar1;
  int iVar2;
  undefined1 *puVar3;
  char *Name;
  gchar *m4_args;
  undefined1 *puVar4;
  undefined1 *puVar5;
  GtkTreeIter iter;
  int local_14;
  undefined4 local_10;
  
  local_14 = 0;
  iVar2 = gtk_tree_selection_get_selected(selection,&local_10,&iter);
  if (iVar2 != 0) {
    gtk_tree_selection_get_tree_view(selection);
    gtk_tree_model_get(local_10,&iter,2,&local_14,0xffffffff);
    if (local_14 != 0) {
      puVar3 = *(undefined1 **)(local_14 + 8);
      if (puVar3 == (undefined1 *)0xffffffff) {
        BVar1 = LoadElementToBuffer(Buffers + Settings.BufferNumber,*(char **)(local_14 + 4),'\x01')
        ;
        if (BVar1 != '\0') {
          SetMode(5);
        }
      }
      else {
        puVar4 = *(undefined1 **)(local_14 + 0xc);
        puVar5 = *(undefined1 **)(local_14 + 0x10);
        if (puVar4 == (undefined1 *)0x0) {
          puVar4 = &DAT_0814741b;
        }
        if (puVar5 == (undefined1 *)0x0) {
          puVar5 = &DAT_0814741b;
        }
        if (puVar3 == (undefined1 *)0x0) {
          puVar3 = &DAT_0814741b;
        }
        Name = (char *)g_strdup_printf("\'%s\' \'%s\' \'%s\'",puVar3,puVar5,puVar4);
        BVar1 = LoadElementToBuffer(Buffers + Settings.BufferNumber,Name,'\0');
        if (BVar1 != '\0') {
          SetMode(5);
        }
        g_free(Name);
      }
      g_object_set(*(undefined4 *)((int)user_data + 0xac),"element-data",
                   (Buffers[Settings.BufferNumber].Data)->Element,0);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void tree_row_activated(GtkTreeView *tree_view,GtkTreePath *path,GtkTreeViewColumn *column,
                       gpointer user_data)

{
  undefined4 uVar1;
  int iVar2;
  GtkTreeModel *model;
  GtkTreeIter iter;
  
  uVar1 = gtk_tree_view_get_model(tree_view);
  gtk_tree_model_get_iter(uVar1,&iter,path);
  iVar2 = gtk_tree_model_iter_has_child(uVar1,&iter);
  if (iVar2 != 0) {
    iVar2 = gtk_tree_view_row_expanded(tree_view,path);
    if (iVar2 == 0) {
      gtk_tree_view_expand_row(tree_view,path,0);
    }
    else {
      gtk_tree_view_collapse_row(tree_view,path);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_library_window_show(GHidPort *out,gboolean raise)

{
  gint gVar1;
  gint gVar2;
  GtkWidget *pGVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GType GVar6;
  int iVar7;
  undefined4 uVar8;
  GtkWidget *current_tab;
  
  pGVar3 = library_window;
  if (library_window == (GtkWidget *)0x0) {
    GVar6 = ghid_library_window_get_type();
    library_window = (GtkWidget *)g_object_new(GVar6,0);
    g_signal_connect_data(library_window,"response",library_window_callback_response,0,0,0);
    uVar4 = g_type_check_instance_cast(library_window,0x50);
    g_signal_connect_data(uVar4,"configure_event",library_window_configure_event_cb,0,0,0);
    gVar1 = ghidgui->library_window_width;
    gVar2 = ghidgui->library_window_height;
    uVar4 = gtk_window_get_type();
    uVar5 = g_type_check_instance_cast(library_window,uVar4);
    gtk_window_set_default_size(uVar5,gVar1,gVar2);
    uVar5 = dcgettext(&DAT_0815492c,"PCB Library",5);
    uVar8 = g_type_check_instance_cast(library_window,uVar4);
    gtk_window_set_title(uVar8,uVar5);
    uVar4 = g_type_check_instance_cast(library_window,uVar4);
    gtk_window_set_wmclass(uVar4,"PCB_Library",&DAT_08154932);
    gtk_widget_realize(library_window);
    if (Settings.AutoPlace == '\0') {
      uVar4 = gtk_widget_get_type();
    }
    else {
      uVar4 = gtk_widget_get_type();
      uVar5 = g_type_check_instance_cast(library_window,uVar4);
      gtk_widget_set_uposition(uVar5,10,10);
    }
    gtk_widget_show(library_window);
  }
  else {
    if (raise != 0) {
      uVar4 = gtk_window_get_type();
      uVar4 = g_type_check_instance_cast(pGVar3,uVar4);
      gtk_window_present(uVar4);
    }
    uVar4 = gtk_widget_get_type();
  }
  uVar5 = gtk_editable_get_type();
  GVar6 = ghid_library_window_get_type();
  iVar7 = g_type_check_instance_cast(library_window,GVar6);
  uVar5 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0xb0),uVar5);
  gtk_editable_select_region(uVar5,0,0xffffffff);
  uVar5 = gtk_notebook_get_type();
  GVar6 = ghid_library_window_get_type();
  iVar7 = g_type_check_instance_cast(library_window,GVar6);
  uVar5 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0xa8),uVar5);
  uVar8 = gtk_notebook_get_current_page(uVar5);
  uVar5 = gtk_notebook_get_nth_page(uVar5,uVar8);
  GVar6 = ghid_library_window_get_type();
  iVar7 = g_type_check_instance_cast(library_window,GVar6);
  uVar4 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0xb0),uVar4);
  iVar7 = gtk_widget_is_ancestor(uVar4,uVar5);
  if (iVar7 == 0) {
    return;
  }
  gtk_widget_grab_focus();
  return;
}



// WARNING: Unknown calling convention

void library_window_callback_response(GtkDialog *dialog,gint arg1,gpointer user_data)

{
  undefined4 uVar1;
  
  if ((arg1 != -7) && (arg1 != -4)) {
    return;
  }
  uVar1 = gtk_widget_get_type();
  uVar1 = g_type_check_instance_cast(library_window,uVar1);
  gtk_widget_destroy(uVar1);
  library_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

gint log_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  ghidgui->log_window_width = (widget->allocation).width;
  gVar1 = (widget->allocation).height;
  pGVar2->config_modified = 1;
  pGVar2->log_window_height = gVar1;
  return 0;
}



// WARNING: Unknown calling convention

void log_destroy_cb(GtkWidget *widget,gpointer data)

{
  log_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void ghid_log_window_show(gboolean raise)

{
  gint gVar1;
  gint gVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  GtkWidget *button;
  undefined4 uVar7;
  GtkWidget *vbox;
  GtkWidget *hbox;
  
  pGVar6 = log_window;
  if (log_window == (GtkWidget *)0x0) {
    log_window = (GtkWidget *)gtk_window_new(0);
    uVar3 = g_type_check_instance_cast(log_window,0x50);
    g_signal_connect_data(uVar3,"destroy",log_destroy_cb,0,0,0);
    uVar3 = g_type_check_instance_cast(log_window,0x50);
    g_signal_connect_data(uVar3,"configure_event",log_window_configure_event_cb,0,0,0);
    uVar3 = dcgettext(&DAT_0815492c,&DAT_081550a2,5);
    uVar4 = gtk_window_get_type();
    uVar5 = g_type_check_instance_cast(log_window,uVar4);
    gtk_window_set_title(uVar5,uVar3);
    uVar3 = g_type_check_instance_cast(log_window,uVar4);
    gtk_window_set_wmclass(uVar3,"PCB_Log",&DAT_08154932);
    gVar1 = ghidgui->log_window_height;
    gVar2 = ghidgui->log_window_width;
    uVar3 = g_type_check_instance_cast(log_window,uVar4);
    gtk_window_set_default_size(uVar3,gVar2,gVar1);
    pGVar6 = (GtkWidget *)gtk_vbox_new(0,0);
    uVar3 = gtk_container_get_type();
    uVar4 = g_type_check_instance_cast(pGVar6,uVar3);
    gtk_container_set_border_width(uVar4,6);
    uVar3 = g_type_check_instance_cast(log_window,uVar3);
    gtk_container_add(uVar3,pGVar6);
    log_text = ghid_scrolled_text_view
                         (pGVar6,(GtkWidget **)0x0,GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
    uVar3 = gtk_hbutton_box_new();
    uVar4 = gtk_button_box_get_type();
    uVar4 = g_type_check_instance_cast(uVar3,uVar4);
    gtk_button_box_set_layout(uVar4,4);
    uVar4 = gtk_box_get_type();
    uVar5 = g_type_check_instance_cast(pGVar6,uVar4);
    gtk_box_pack_start(uVar5,uVar3,0,0,0);
    uVar5 = gtk_button_new_from_stock("gtk-close");
    uVar7 = g_type_check_instance_cast(uVar5,0x50);
    g_signal_connect_data(uVar7,"clicked",log_close_cb,0,0,0);
    uVar3 = g_type_check_instance_cast(uVar3,uVar4);
    gtk_box_pack_start(uVar3,uVar5,1,1,0);
    gtk_widget_realize(log_window);
    if (Settings.AutoPlace != '\0') {
      uVar3 = gtk_widget_get_type();
      uVar3 = g_type_check_instance_cast(log_window,uVar3);
      gtk_widget_set_uposition(uVar3,10,10);
    }
    gtk_widget_show_all();
    return;
  }
  if (raise == 0) {
    return;
  }
  uVar3 = gtk_window_get_type();
  g_type_check_instance_cast(pGVar6,uVar3);
  gtk_window_present();
  return;
}



// WARNING: Unknown calling convention

void ghid_logv(char *fmt,va_list args)

{
  char *string;
  int iVar1;
  int i;
  
  if (msg_buffer == (char *)0x0) {
    msg_buffer = (char *)calloc(1,0x3ea);
    if (msg_buffer == (char *)0x0) goto LAB_080fd9a1;
    msg_buffer_size = 1000;
  }
  iVar1 = __vsnprintf_chk(msg_buffer,msg_buffer_size,1,0xffffffff,fmt,args);
  if (msg_buffer_size <= iVar1) {
    msg_buffer_size = iVar1 + 100;
    msg_buffer = (char *)realloc(msg_buffer,iVar1 + 0x66);
    if (msg_buffer == (char *)0x0) {
LAB_080fd9a1:
      __fprintf_chk(stderr,1,"ghid_logv():  malloc failed\n\n");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    __vsnprintf_chk(msg_buffer,msg_buffer_size,1,0xffffffff,fmt,args);
  }
  string = msg_buffer;
  ghid_log_window_show(0);
  ghid_text_view_append(log_text,string);
  return;
}



// WARNING: Unknown calling convention

void ghid_log(char *fmt,...)

{
  ghid_logv(fmt,&stack0x00000008);
  return;
}



// WARNING: Unknown calling convention

void log_close_cb(gpointer data)

{
  gtk_widget_destroy(log_window);
  log_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void ghid_create_abort_dialog(char *msg)

{
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_check_abort(void)

{
  return 0;
}



// WARNING: Unknown calling convention

void ghid_end_abort(void)

{
  return;
}



// WARNING: Unknown calling convention

void ghid_clear_increment_get_value(gchar *saction,gchar **value,gchar **units)

{
  undefined4 uVar1;
  undefined *puVar2;
  gchar *pgVar3;
  undefined4 uVar4;
  
  puVar2 = &DAT_081550d0;
  uVar4 = Settings.clear_increment_mil._4_4_;
  uVar1 = Settings.clear_increment_mil._0_4_;
  if (Settings.grid_units_mm != '\0') {
    uVar4 = Settings.clear_increment_mm._4_4_;
    uVar1 = Settings.clear_increment_mm._0_4_;
  }
  if (*saction == '+') {
    puVar2 = &DAT_081550d4;
  }
  __snprintf_chk(ghid_clear_increment_get_value::s_buf,0x40,1,0x40,puVar2,uVar1,uVar4);
  *value = ghid_clear_increment_get_value::s_buf;
  pgVar3 = "mil";
  if (Settings.grid_units_mm != '\0') {
    pgVar3 = "mm";
  }
  *units = pgVar3;
  return;
}



// WARNING: Unknown calling convention

void ghid_line_increment_get_value(gchar *saction,gchar **value,gchar **units)

{
  undefined4 uVar1;
  undefined *puVar2;
  gchar *pgVar3;
  undefined4 uVar4;
  
  puVar2 = &DAT_081550d0;
  uVar4 = Settings.line_increment_mil._4_4_;
  uVar1 = Settings.line_increment_mil._0_4_;
  if (Settings.grid_units_mm != '\0') {
    uVar4 = Settings.line_increment_mm._4_4_;
    uVar1 = Settings.line_increment_mm._0_4_;
  }
  if (*saction == '+') {
    puVar2 = &DAT_081550d4;
  }
  __snprintf_chk(ghid_line_increment_get_value::s_buf,0x40,1,0x40,puVar2,uVar1,uVar4);
  *value = ghid_line_increment_get_value::s_buf;
  pgVar3 = "mil";
  if (Settings.grid_units_mm != '\0') {
    pgVar3 = "mm";
  }
  *units = pgVar3;
  return;
}



// WARNING: Unknown calling convention

void ghid_size_increment_get_value(gchar *saction,gchar **value,gchar **units)

{
  undefined4 uVar1;
  undefined *puVar2;
  gchar *pgVar3;
  undefined4 uVar4;
  
  puVar2 = &DAT_081550d0;
  uVar4 = Settings.size_increment_mil._4_4_;
  uVar1 = Settings.size_increment_mil._0_4_;
  if (Settings.grid_units_mm != '\0') {
    uVar4 = Settings.size_increment_mm._4_4_;
    uVar1 = Settings.size_increment_mm._0_4_;
  }
  if (*saction == '+') {
    puVar2 = &DAT_081550d4;
  }
  __snprintf_chk(ghid_size_increment_get_value::s_buf,0x40,1,0x40,puVar2,uVar1,uVar4);
  *value = ghid_size_increment_get_value::s_buf;
  pgVar3 = "mil";
  if (Settings.grid_units_mm != '\0') {
    pgVar3 = "mm";
  }
  *units = pgVar3;
  return;
}



// WARNING: Unknown calling convention

void ghid_get_pointer(int *x,int *y)

{
  int local_14;
  int local_10;
  
  gdk_window_get_pointer(gport->drawing_area->window,&local_10,&local_14,0);
  if (x != (int *)0x0) {
    *x = local_10;
  }
  if (y != (int *)0x0) {
    *y = local_14;
  }
  return;
}



// WARNING: Unknown calling convention

gboolean loop_key_press_cb(GtkWidget *drawing_area,GdkEventKey *kev,GMainLoop **loop)

{
  guint ksym_00;
  gboolean gVar1;
  ModifierKeysState mk;
  ModifierKeysState MVar2;
  int iVar3;
  gint ksym;
  char *pcVar4;
  GdkModifierType local_20 [4];
  
  ksym_00 = kev->keyval;
  gVar1 = ghid_is_modifier_key_sym(ksym_00);
  if (gVar1 != 0) {
    return 1;
  }
  local_20[0] = kev->state;
  MVar2 = ghid_modifier_keys_state(local_20);
  if (ksym_00 == 0xff52) {
    if (MVar2 != CONTROL_PRESSED) {
      if (MVar2 == SHIFT_PRESSED) {
        hid_actionl("MovePointer","0","-10",0);
        return 1;
      }
      if (MVar2 != NONE_PRESSED) {
        return 1;
      }
      hid_actionl("MovePointer","0",&DAT_0815391d,0);
      return 1;
    }
    pcVar4 = "8";
    goto LAB_080fde57;
  }
  if ((int)ksym_00 < 0xff53) {
    if (ksym_00 == 0xff0d) goto LAB_080fdcf8;
    if (ksym_00 == 0xff51) {
      if (MVar2 != CONTROL_PRESSED) {
        if (MVar2 == SHIFT_PRESSED) {
          hid_actionl("MovePointer","-10","0",0);
          return 1;
        }
        if (MVar2 != NONE_PRESSED) {
          return 1;
        }
        hid_actionl("MovePointer",&DAT_0815391d,"0",0);
        return 1;
      }
      pcVar4 = "4";
      goto LAB_080fde57;
    }
  }
  else {
    if (ksym_00 == 0xff53) {
      if (MVar2 != CONTROL_PRESSED) {
        if (MVar2 == SHIFT_PRESSED) {
          hid_actionl("MovePointer","10","0",0);
          return 1;
        }
        if (MVar2 != NONE_PRESSED) {
          return 1;
        }
        hid_actionl("MovePointer",&DAT_08156a80,"0",0);
        return 1;
      }
      pcVar4 = "6";
LAB_080fde57:
      hid_actionl("Display","Scroll",pcVar4,0);
      hid_actionl("Display","Scroll","0",0);
      return 1;
    }
    if (ksym_00 == 0xff54) {
      if (MVar2 != CONTROL_PRESSED) {
        if (MVar2 == SHIFT_PRESSED) {
          hid_actionl("MovePointer","0","10",0);
          return 1;
        }
        if (MVar2 != NONE_PRESSED) {
          return 1;
        }
        hid_actionl("MovePointer","0",&DAT_08156a80,0);
        return 1;
      }
      pcVar4 = "2";
      goto LAB_080fde57;
    }
  }
  got_location = 0;
LAB_080fdcf8:
  iVar3 = g_main_loop_is_running(*loop);
  if (iVar3 == 0) {
    return 1;
  }
  g_main_loop_quit(*loop);
  return 1;
}



// WARNING: Unknown calling convention

gboolean loop_button_press_cb(GtkWidget *drawing_area,GdkEventButton *ev,GMainLoop **loop)

{
  int iVar1;
  
  iVar1 = g_main_loop_is_running(*loop);
  if (iVar1 != 0) {
    g_main_loop_quit(*loop);
  }
  ghid_note_event_location(ev);
  return 1;
}



// WARNING: Unknown calling convention

GdkCursorType gport_set_cursor(GdkCursorType shape)

{
  GdkCursorType GVar1;
  GdkCursor *pGVar2;
  GHidPort *pGVar3;
  GdkCursorType old_shape;
  GdkColor bg;
  GdkColor fg;
  
  pGVar3 = gport;
  GVar1 = gport->X_cursor_shape;
  if ((gport->drawing_area != (GtkWidget *)0x0) && (gport->drawing_area->window != (GdkWindow *)0x0)
     ) {
    if (GVar1 != shape) {
      fg.pixel = 0;
      fg.red = 0xffff;
      fg.green = 0xffff;
      fg.blue = 0xffff;
      bg.pixel = 0;
      bg.red = 0;
      bg.green = 0;
      bg.blue = 0;
      gport->X_cursor_shape = shape;
      if (shape < 0x9a) {
        pGVar2 = (GdkCursor *)gdk_cursor_new(shape);
        pGVar3->X_cursor = pGVar2;
        pGVar3 = gport;
      }
      else if (shape == 0xa3) {
        pGVar2 = (GdkCursor *)gdk_cursor_new_from_pixmap(XC_clock_source,XC_clock_mask,&fg,&bg,8,8);
        pGVar3->X_cursor = pGVar2;
        pGVar3 = gport;
      }
      else if (shape == 0xa4) {
        pGVar2 = (GdkCursor *)gdk_cursor_new_from_pixmap(XC_hand_source,XC_hand_mask,&fg,&bg,8,8);
        pGVar3->X_cursor = pGVar2;
        pGVar3 = gport;
      }
      else if (shape == 0xa5) {
        pGVar2 = (GdkCursor *)gdk_cursor_new_from_pixmap(XC_lock_source,XC_lock_mask,&fg,&bg,8,8);
        pGVar3->X_cursor = pGVar2;
        pGVar3 = gport;
      }
      gdk_window_set_cursor(pGVar3->drawing_area->window,pGVar3->X_cursor);
      gdk_cursor_unref(gport->X_cursor);
      shape = GVar1;
    }
    return shape;
  }
  return GDK_X_CURSOR;
}



// WARNING: Unknown calling convention

void ghid_restore_cursor(void)

{
  gport_set_cursor(oldCursor);
  return;
}



// WARNING: Unknown calling convention

void ghid_corner_cursor(void)

{
  GdkCursorType shape;
  GdkCursorType shape_00;
  
  if (Crosshair.AttachedBox.Point1.Y < Crosshair.Y) {
    shape_00 = (uint)(Crosshair.AttachedBox.Point1.X <= Crosshair.X) * 2 + GDK_LL_ANGLE;
    if (gport->X_cursor_shape == shape_00) {
      return;
    }
  }
  else {
    shape_00 = (uint)(Crosshair.AttachedBox.Point1.X <= Crosshair.X) * 4 + GDK_UL_ANGLE;
    if (gport->X_cursor_shape == shape_00) {
      return;
    }
  }
  gport_set_cursor(shape_00);
  return;
}



// WARNING: Unknown calling convention

void ghid_watch_cursor(void)

{
  GdkCursorType tmp;
  GdkCursorType GVar1;
  
  GVar1 = gport_set_cursor(GDK_WATCH);
  if (GVar1 != GDK_WATCH) {
    oldCursor = GVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_hand_cursor(void)

{
  oldCursor = gport_set_cursor(GDK_HAND2);
  return;
}



// WARNING: Unknown calling convention

void ghid_point_cursor(void)

{
  oldCursor = gport_set_cursor(GDK_DRAPED_BOX);
  return;
}



// WARNING: Unknown calling convention

void ghid_mode_cursor(int Mode)

{
  gboolean gVar1;
  
  switch(Mode) {
  case 0:
    gport_set_cursor(0xa4);
    return;
  case 1:
    gport_set_cursor(GDK_ARROW);
    return;
  case 2:
    gport_set_cursor(GDK_PENCIL);
    return;
  case 3:
    gport_set_cursor(GDK_UL_ANGLE);
    return;
  case 4:
    gport_set_cursor(GDK_SB_UP_ARROW);
    return;
  case 5:
    gport_set_cursor(GDK_HAND1);
    return;
  case 6:
    gport_set_cursor(GDK_XTERM);
    return;
  default:
    return;
  case 0x66:
    break;
  case 0x67:
    gport_set_cursor(GDK_PIRATE);
    return;
  case 0x68:
  case 0x69:
    gport_set_cursor(GDK_CROSSHAIR);
    return;
  case 0x6a:
    gport_set_cursor(GDK_DOTBOX);
    return;
  case 0x6c:
    gport_set_cursor(GDK_IRON_CROSS);
    return;
  case 0x6d:
    gport_set_cursor(GDK_QUESTION_ARROW);
    return;
  case 0x6e:
    gport_set_cursor(GDK_LEFT_PTR);
    return;
  case 0x6f:
    gport_set_cursor(0xa5);
    return;
  }
  gVar1 = ghid_shift_is_pressed();
  if (gVar1 != 0) {
    gport_set_cursor(0xa3);
    return;
  }
  gport_set_cursor(GDK_EXCHANGE);
  return;
}



// WARNING: Unknown calling convention

void ghid_cursor_position_relative_label_set_text(gchar *text)

{
  ghid_label_set_markup(ghidgui->cursor_position_relative_label,text);
  return;
}



// WARNING: Unknown calling convention

void ghid_cursor_position_label_set_text(gchar *text)

{
  ghid_label_set_markup(ghidgui->cursor_position_absolute_label,text);
  return;
}



// WARNING: Unknown calling convention

void ghid_set_cursor_position_labels(void)

{
  int iVar1;
  int in_GS_OFFSET;
  double scale;
  double dx;
  double dy;
  double dVar2;
  char *pcVar3;
  double dVar4;
  double dVar5;
  gchar text [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Marked.status == '\0') {
    ghid_cursor_position_relative_label_set_text("r __.__; phi __._; __.__ __.__");
  }
  else {
    dVar5 = 0.01;
    if (Settings.grid_units_mm != '\0') {
      dVar5 = 0.000254;
    }
    dVar4 = (double)(Crosshair.X - Marked.X) * dVar5;
    dVar5 = (double)(Marked.Y - Crosshair.Y) * dVar5;
    dVar2 = atan2(dVar5,dVar4);
    if (Settings.grid_units_mm == '\0') {
      pcVar3 = "r %-.2f; phi %-.1f; %-.2f %-.2f";
    }
    else {
      pcVar3 = "r %-.4f; phi %-.1f; %-.4f %-.4f";
    }
    __snprintf_chk(text,0x80,1,0x80,pcVar3,SQRT(dVar5 * dVar5 + dVar4 * dVar4),
                   (dVar2 * 180.0) / 3.141592653589793,dVar4,dVar5);
    ghid_cursor_position_relative_label_set_text(text);
  }
  if (Settings.grid_units_mm == '\0') {
    pcVar3 = "%-.2f %-.2f";
    dVar5 = (double)((float)Crosshair.Y / 100.0);
    dVar4 = (double)((float)Crosshair.X / 100.0);
  }
  else {
    dVar5 = (double)Crosshair.Y * 0.000254;
    pcVar3 = "%-.4f %-.4f";
    dVar4 = (double)Crosshair.X * 0.000254;
  }
  __snprintf_chk(text,0x80,1,0x80,pcVar3,dVar4,dVar5);
  ghid_cursor_position_label_set_text(text);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void ghid_status_line_set_text(gchar *text)

{
  if (ghidgui->command_entry_status_line_active != 0) {
    return;
  }
  ghid_label_set_markup(ghidgui->status_line_label,text);
  return;
}



// WARNING: Unknown calling convention

void ghid_set_status_line_label(void)

{
  double dVar1;
  int iVar2;
  char cVar3;
  uint uVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  undefined4 uVar17;
  undefined *puVar18;
  char *pcVar19;
  int in_GS_OFFSET;
  undefined4 local_25c;
  char *local_234;
  gchar text [512];
  
  iVar16 = Settings.GridFactor;
  iVar15 = Settings.BufferNumber;
  iVar14 = Settings.TextScale;
  iVar13 = Settings.Keepaway;
  iVar12 = Settings.LineThickness;
  iVar11 = Settings.ViaDrillingHole;
  iVar10 = Settings.ViaThickness;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  if (Settings.grid_units_mm == '\0') {
    pcVar19 = "";
    local_234 = "all";
    puVar18 = &DAT_0815672f;
    if (ghidgui->compact_horizontal != 0) {
      pcVar19 = "\n";
    }
    uVar4 = (PCB->Flags).f;
    if ((uVar4 & 0x10) != 0) {
      puVar18 = &DAT_081550fc;
    }
    if ((uVar4 & 0x100) == 0) {
      local_234 = "45";
      if ((PCB->Clipping != 0) && (local_234 = "45_/", PCB->Clipping != 1)) {
        local_234 = "45\\_";
      }
    }
    dVar1 = PCB->Grid;
    if (Settings.ShowSolderSide == '\0') {
      local_25c = dcgettext(&DAT_0815492c,"component",5);
    }
    else {
      local_25c = dcgettext(&DAT_0815492c,"solder",5);
    }
    cVar3 = PCB->Changed;
    uVar17 = dcgettext(&DAT_0815492c,
                       "<b>%c  view</b>=%s  <b>grid</b>=%.1f:%i  %s%s  <b>line</b>=%.1f  <b>via</b>=%.1f(%.1f)  %s<b>clearance</b>=%.1f  <b>text</b>=%i%%  <b>buffer</b>=#%i"
                       ,5);
    fVar5 = (float)iVar13 / 100.0;
    fVar6 = (float)iVar11 / 100.0;
    fVar7 = (float)iVar10 / 100.0;
    fVar8 = (float)iVar12 / 100.0;
    fVar9 = (float)dVar1 / 100.0;
  }
  else {
    pcVar19 = "";
    puVar18 = &DAT_0815672f;
    local_234 = "all";
    if (ghidgui->compact_horizontal != 0) {
      pcVar19 = "\n";
    }
    uVar4 = (PCB->Flags).f;
    if ((uVar4 & 0x10) != 0) {
      puVar18 = &DAT_081550fc;
    }
    if ((uVar4 & 0x100) == 0) {
      local_234 = "45";
      if ((PCB->Clipping != 0) && (local_234 = "45_/", PCB->Clipping != 1)) {
        local_234 = "45\\_";
      }
    }
    dVar1 = PCB->Grid;
    if (Settings.ShowSolderSide == '\0') {
      local_25c = dcgettext(&DAT_0815492c,"component",5);
    }
    else {
      local_25c = dcgettext(&DAT_0815492c,"solder",5);
    }
    cVar3 = PCB->Changed;
    uVar17 = dcgettext(&DAT_0815492c,
                       "<b>%c  view</b>=%s  <b>grid</b>=%5.3f:%i  %s%s  <b>line</b>=%5.3f  <b>via</b>=%5.3f(%5.3f)  %s<b>clearance</b>=%5.3f  <b>text</b>=%i%%  <b>buffer</b>=#%i"
                       ,5);
    fVar5 = (float)iVar13 * 0.000254;
    fVar6 = (float)iVar11 * 0.000254;
    fVar7 = (float)iVar10 * 0.000254;
    fVar8 = (float)iVar12 * 0.000254;
    fVar9 = (float)dVar1 * 0.000254;
  }
  __snprintf_chk(text,0x200,1,0x200,uVar17,(-(uint)(cVar3 == '\0') & 0xfffffff6) + 0x2a,local_25c,
                 (double)fVar9,iVar16,local_234,puVar18,(double)fVar8,(double)fVar7,(double)fVar6,
                 pcVar19,(double)fVar5,iVar14,iVar15 + 1);
  ghid_status_line_set_text(text);
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_get_user_xy(char *msg)

{
  long lVar1;
  long lVar2;
  long lVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  gint oldBoxState;
  gulong button_handler;
  gulong key_handler;
  gint oldLineState;
  gint oldObjState;
  undefined4 local_20 [4];
  
  ghid_status_line_set_text(msg);
  lVar3 = Crosshair.AttachedObject.State;
  lVar2 = Crosshair.AttachedBox.State;
  lVar1 = Crosshair.AttachedLine.State;
  HideCrosshair('\x01');
  Crosshair.AttachedObject.State = 0;
  Crosshair.AttachedLine.State = 0;
  Crosshair.AttachedBox.State = 0;
  ghid_hand_cursor();
  RestoreCrosshair('\x01');
  ghid_interface_input_signals_disconnect();
  ghid_interface_set_sensitive(0);
  got_location = 1;
  uVar4 = g_type_check_instance_cast(gport->drawing_area,0x50);
  uVar4 = g_signal_connect_data(uVar4,"button_press_event",loop_button_press_cb,local_20,0,0);
  uVar5 = g_type_check_instance_cast(gport->top_window,0x50);
  uVar5 = g_signal_connect_data(uVar5,"key_press_event",loop_key_press_cb,local_20,0,0);
  local_20[0] = g_main_loop_new(0,0);
  g_main_loop_run(local_20[0]);
  g_main_loop_unref(local_20[0]);
  g_signal_handler_disconnect(gport->drawing_area,uVar4);
  g_signal_handler_disconnect(gport->top_window,uVar5);
  ghid_interface_input_signals_connect();
  ghid_interface_set_sensitive(1);
  HideCrosshair('\x01');
  Crosshair.AttachedLine.State = lVar1;
  Crosshair.AttachedBox.State = lVar2;
  Crosshair.AttachedObject.State = lVar3;
  RestoreCrosshair('\x01');
  ghid_restore_cursor();
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

gint netlist_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  gVar1 = (widget->allocation).height;
  ghidgui->config_modified = 1;
  pGVar2->netlist_window_height = gVar1;
  return 0;
}



// WARNING: Unknown calling convention

void netlist_destroy_cb(GtkWidget *widget,GHidPort *out)

{
  selected_net = (LibraryMenuType *)0x0;
  netlist_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void register_ghid_netlist_action_list(void)

{
  hid_register_actions(ghid_netlist_action_list,2);
  return;
}



// WARNING: Unknown calling convention

GtkTreeModel * net_model_create(void)

{
  Cardinal CVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkTreeModel *pGVar4;
  void *__src;
  int iVar5;
  GtkTreeIter *pGVar6;
  void *pvVar7;
  undefined4 uVar8;
  int iVar9;
  GtkTreePath *path;
  undefined4 uVar10;
  undefined1 *puVar11;
  GtkTreeRowReference *row_ref;
  int *piVar12;
  undefined4 *puVar13;
  int try_depth;
  int iVar14;
  GtkTreeIter *parent_ptr;
  int local_68;
  int local_64;
  int local_48;
  size_t local_40;
  GtkTreeIter parent_iter;
  GtkTreeIter new_iter;
  
  uVar2 = gtk_tree_store_new(3,0x40,0x40,0x44);
  uVar3 = gtk_tree_model_get_type();
  pGVar4 = (GtkTreeModel *)g_type_check_instance_cast(uVar2,uVar3);
  uVar3 = g_hash_table_new_full(g_str_hash,g_str_equal,g_free,gtk_tree_row_reference_free);
  CVar1 = (PCB->NetlistLib).MenuN;
  local_64 = CVar1 - 1;
  if (local_64 != -1) {
    iVar5 = CVar1 * 0x1c;
    do {
      local_68 = iVar5 + -0x1c;
      piVar12 = (int *)((int)&(PCB->NetlistLib).Menu[-1].Name + iVar5);
      if (*piVar12 != 0) {
        if (loading_new_netlist != 0) {
          *(undefined *)(piVar12 + 6) = 1;
        }
        __src = (void *)g_strsplit(*piVar12,"/",0);
        iVar5 = g_strv_length(__src);
        iVar5 = iVar5 + -1;
        pGVar6 = (GtkTreeIter *)0x0;
        if (0 < iVar5) {
          local_40 = iVar5 * 4;
          iVar9 = iVar5;
          do {
            local_48 = iVar9;
            pvVar7 = (void *)g_malloc0_n(local_48 + 1,4);
            memcpy(pvVar7,__src,local_40);
            uVar8 = g_strjoinv("/",pvVar7);
            g_free(pvVar7);
            iVar9 = g_hash_table_lookup(uVar3,uVar8);
            g_free(uVar8);
            if (iVar9 != 0) {
              pGVar6 = &parent_iter;
              uVar8 = gtk_tree_row_reference_get_path(iVar9);
              gtk_tree_model_get_iter(pGVar4,&parent_iter,uVar8);
              iVar14 = local_48 + 1;
              if (iVar5 <= local_48) goto LAB_080fef68;
              goto LAB_080fee11;
            }
            iVar9 = local_48 + -1;
            local_40 = local_40 - 4;
          } while (0 < iVar9);
          pGVar6 = (GtkTreeIter *)0x0;
          iVar14 = local_48;
          local_48 = iVar9;
LAB_080fee11:
          puVar13 = (undefined4 *)((int)__src + local_48 * 4);
          local_40 = iVar14 * 4;
          while( true ) {
            iVar9 = iVar14;
            uVar8 = g_strconcat(*puVar13,"/",0);
            gtk_tree_store_append(uVar2,&new_iter,pGVar6);
            gtk_tree_store_set(uVar2,&new_iter,0,&DAT_0814741b,1,uVar8,2,0,0xffffffff);
            g_free(uVar8);
            uVar8 = gtk_tree_model_get_path(pGVar4,&new_iter);
            uVar8 = gtk_tree_row_reference_new(pGVar4,uVar8);
            parent_iter.stamp = new_iter.stamp;
            parent_iter.user_data = new_iter.user_data;
            parent_iter.user_data2 = new_iter.user_data2;
            parent_iter.user_data3 = new_iter.user_data3;
            pvVar7 = (void *)g_malloc0_n(local_48 + 2,4);
            memcpy(pvVar7,__src,local_40);
            uVar10 = g_strjoinv("/",pvVar7);
            pGVar6 = &parent_iter;
            g_free(pvVar7);
            g_hash_table_insert(uVar3,uVar10,uVar8);
            local_40 = local_40 + 4;
            puVar13 = puVar13 + 1;
            if (iVar5 <= iVar9) break;
            iVar14 = iVar9 + 1;
            local_48 = iVar9;
          }
          pGVar6 = &parent_iter;
        }
LAB_080fef68:
        gtk_tree_store_append(uVar2,&new_iter,pGVar6);
        puVar11 = &DAT_081548e9;
        if (*(char *)(piVar12 + 6) != '\0') {
          puVar11 = &DAT_0814741b;
        }
        gtk_tree_store_set(uVar2,&new_iter,0,puVar11,1,*(undefined4 *)((int)__src + iVar5 * 4),2,
                           piVar12,0xffffffff);
        g_strfreev(__src);
      }
      local_64 = local_64 + -1;
      iVar5 = local_68;
    } while (local_64 != -1);
  }
  g_hash_table_destroy(uVar3);
  return pGVar4;
}



// WARNING: Unknown calling convention

void node_model_update(LibraryMenuType *menu)

{
  int iVar1;
  GtkTreeModel *pGVar2;
  undefined4 uVar3;
  Cardinal n;
  undefined4 uVar4;
  GtkListStore *store;
  int iVar5;
  LibraryEntryTypePtr entry;
  int *piVar6;
  GtkTreeIter iter;
  
  pGVar2 = node_model;
  uVar3 = gtk_list_store_new(2,0x40,0x44);
  if (menu != (LibraryMenuType *)0x0) {
    iVar5 = menu->EntryN - 1;
    if (iVar5 != -1) {
      iVar1 = menu->EntryN * 0x18;
      do {
        piVar6 = (int *)((int)&menu->Entry[-1].ListEntry + iVar1);
        if (*piVar6 != 0) {
          gtk_list_store_append(uVar3,&iter);
          gtk_list_store_set(uVar3,&iter,0,*piVar6,1,piVar6,0xffffffff);
        }
        iVar5 = iVar5 + -1;
        iVar1 = iVar1 + -0x18;
      } while (iVar5 != -1);
    }
  }
  uVar4 = gtk_tree_model_get_type();
  node_model = (GtkTreeModel *)g_type_check_instance_cast(uVar3,uVar4);
  gtk_tree_view_set_model(node_treeview,node_model);
  uVar3 = gtk_tree_sortable_get_type();
  uVar3 = g_type_check_instance_cast(node_model,uVar3);
  gtk_tree_sortable_set_sort_column_id(uVar3,0,0);
  if (pGVar2 != (GtkTreeModel *)0x0) {
    uVar3 = g_type_check_instance_cast(pGVar2,0x50);
    g_object_unref(uVar3);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_netlist_nodes_update(LibraryMenuType *net)

{
  node_model_update(net);
  return;
}



// WARNING: Unknown calling convention

gboolean hunt_named_node(GtkTreeModel *model,GtkTreePath *path,GtkTreeIter *iter,gpointer data)

{
  char cVar1;
  int iVar2;
  int iVar3;
  gint j;
  LibraryEntryType_conflict *node;
  char **ppcVar4;
  char *local_24;
  int local_20 [4];
  
  iVar2 = gtk_tree_model_iter_has_child(model,iter);
  if (iVar2 == 0) {
    gtk_tree_model_get(model,iter,2,local_20,0xffffffff);
    gtk_tree_model_get(model,iter,0,&local_24,0xffffffff);
    if (*local_24 == '*') {
      cVar1 = local_24[1];
      g_free(local_24);
                    // WARNING: Load size is inaccurate
      if ((cVar1 == '\0') && (*data != 0)) {
        return 0;
      }
    }
    else {
      g_free(local_24);
    }
    iVar2 = *(int *)(local_20[0] + 0xc);
    ppcVar4 = *(char ***)(local_20[0] + 0x14);
    if (iVar2 != 0) {
      while( true ) {
        if ((*ppcVar4 != (char *)0x0) &&
           (iVar3 = strcmp(*(char **)((int)data + 4),*ppcVar4), iVar3 == 0)) {
          *(int *)((int)data + 8) = local_20[0];
          *(gint *)((int)data + 0xc) = iter->stamp;
          *(gpointer *)((int)data + 0x10) = iter->user_data;
          *(gpointer *)((int)data + 0x14) = iter->user_data2;
          *(gpointer *)((int)data + 0x18) = iter->user_data3;
          return 1;
        }
        iVar2 = iVar2 + -1;
        if (iVar2 == 0) break;
        ppcVar4 = ppcVar4 + 6;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void ghid_netlist_window_show(GHidPort *out,gboolean raise)

{
  gint gVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  GtkWidget *pGVar5;
  GtkWidget *vbox;
  GtkWidget *box;
  GtkTreeModel *pGVar6;
  GtkTreeView *pGVar7;
  undefined4 uVar8;
  GtkTreeViewColumn *column;
  GtkTreeSelection *selection;
  gchar *string;
  GtkWidget *button;
  GtkCellRenderer *renderer;
  GtkWidget *label;
  GtkWidget *hbox;
  GtkWidget *sep;
  
  pGVar5 = netlist_window;
  if ((PCB->NetlistLib).MenuN == 0) {
    return;
  }
  if (netlist_window != (GtkWidget *)0x0) {
    if (raise != 0) {
      uVar2 = gtk_window_get_type();
      uVar2 = g_type_check_instance_cast(pGVar5,uVar2);
      gtk_window_present(uVar2);
    }
    ghid_netlist_window_update(1);
    return;
  }
  netlist_window = (GtkWidget *)gtk_window_new(0);
  uVar2 = g_type_check_instance_cast(netlist_window,0x50);
  g_signal_connect_data(uVar2,"destroy",netlist_destroy_cb,out,0,0);
  uVar2 = dcgettext(&DAT_0815492c,"PCB Netlist",5);
  uVar3 = gtk_window_get_type();
  uVar4 = g_type_check_instance_cast(netlist_window,uVar3);
  gtk_window_set_title(uVar4,uVar2);
  uVar2 = g_type_check_instance_cast(netlist_window,uVar3);
  gtk_window_set_wmclass(uVar2,"PCB_Netlist",&DAT_08154932);
  uVar2 = g_type_check_instance_cast(netlist_window,0x50);
  g_signal_connect_data(uVar2,"configure_event",netlist_window_configure_event_cb,0,0,0);
  gVar1 = ghidgui->netlist_window_height;
  uVar2 = g_type_check_instance_cast(netlist_window,uVar3);
  gtk_window_set_default_size(uVar2,0xffffffff,gVar1);
  uVar2 = gtk_container_get_type();
  uVar3 = g_type_check_instance_cast(netlist_window,uVar2);
  gtk_container_set_border_width(uVar3,2);
  pGVar5 = (GtkWidget *)gtk_vbox_new(0,4);
  uVar3 = g_type_check_instance_cast(pGVar5,uVar2);
  gtk_container_set_border_width(uVar3,6);
  uVar2 = g_type_check_instance_cast(netlist_window,uVar2);
  gtk_container_add(uVar2,pGVar5);
  box = (GtkWidget *)gtk_hbox_new(0,8);
  uVar2 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(pGVar5,uVar2);
  gtk_box_pack_start(uVar3,box,1,1,4);
  pGVar6 = net_model_create();
  uVar3 = gtk_tree_view_get_type();
  uVar4 = gtk_tree_view_new_with_model(pGVar6);
  pGVar7 = (GtkTreeView *)g_type_check_instance_cast(uVar4,uVar3);
  net_model = pGVar6;
  net_treeview = pGVar7;
  uVar4 = gtk_tree_sortable_get_type();
  uVar4 = g_type_check_instance_cast(pGVar6,uVar4);
  gtk_tree_sortable_set_sort_column_id(uVar4,1,0);
  gtk_tree_view_set_rules_hint(pGVar7,0);
  g_object_set(pGVar7,"enable-tree-lines",1,0);
  uVar4 = gtk_cell_renderer_text_new();
  uVar8 = dcgettext(&DAT_0815492c,&DAT_08156730,5);
  gtk_tree_view_insert_column_with_attributes(pGVar7,0xffffffff,uVar8,uVar4,&DAT_081539ac,0,0);
  uVar4 = gtk_cell_renderer_text_new();
  uVar8 = dcgettext(&DAT_0815492c,"Net Name",5);
  uVar4 = gtk_tree_view_column_new_with_attributes(uVar8,uVar4,&DAT_081539ac,1,0);
  gtk_tree_view_insert_column(pGVar7,uVar4,0xffffffff);
  gtk_tree_view_set_expander_column(pGVar7,uVar4);
  gtk_tree_view_expand_all(pGVar7);
  ghid_scrolled_selection
            (pGVar7,box,GTK_SELECTION_SINGLE,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC,
             net_selection_changed_cb,(gpointer)0x0);
  uVar4 = g_type_check_instance_cast(pGVar7,0x50);
  g_signal_connect_data(uVar4,"row-activated",net_selection_double_click_cb,0,0,0);
  uVar4 = gtk_tree_view_new();
  pGVar7 = (GtkTreeView *)g_type_check_instance_cast(uVar4,uVar3);
  node_treeview = pGVar7;
  gtk_tree_view_set_rules_hint(pGVar7,0);
  uVar3 = gtk_cell_renderer_text_new();
  uVar4 = dcgettext(&DAT_0815492c,"Nodes",5);
  gtk_tree_view_insert_column_with_attributes(pGVar7,0xffffffff,uVar4,uVar3,&DAT_081539ac,0,0);
  node_selection =
       ghid_scrolled_selection
                 (pGVar7,box,GTK_SELECTION_SINGLE,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC,
                  node_selection_changed_cb,(gpointer)0x0);
  uVar3 = gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(pGVar5,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,0);
  uVar4 = dcgettext(&DAT_0815492c,"Operations on selected \'Net Name\':",5);
  uVar4 = gtk_label_new(uVar4);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar3,uVar4,0,0,4);
  uVar3 = gtk_misc_get_type();
  uVar3 = g_type_check_instance_cast(uVar4,uVar3);
  gtk_misc_set_alignment(uVar3,0,0x3f000000);
  uVar3 = gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(pGVar5,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,4);
  uVar4 = dcgettext(&DAT_0815492c,"Select",5);
  uVar4 = gtk_button_new_with_label(uVar4);
  uVar8 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar8,uVar4,0,0,0);
  uVar4 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar4,"clicked",netlist_select_cb,1,0,0);
  uVar4 = dcgettext(&DAT_0815492c,"Unselect",5);
  uVar4 = gtk_button_new_with_label(uVar4);
  uVar8 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar8,uVar4,0,0,0);
  uVar4 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar4,"clicked",netlist_select_cb,0,0,0);
  uVar4 = dcgettext(&DAT_0815492c,&DAT_0813a46a,5);
  uVar4 = gtk_button_new_with_label(uVar4);
  uVar8 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar8,uVar4,0,0,0);
  uVar4 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar4,"clicked",netlist_find_cb,0,0,0);
  uVar4 = dcgettext(&DAT_0815492c,&DAT_081554af,5);
  uVar4 = gtk_button_new_with_label(uVar4);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar3,uVar4,0,0,0);
  uVar3 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar3,"clicked",netlist_rip_up_cb,0,0,0);
  string = (gchar *)dcgettext(&DAT_0815492c,"Disable all nets for adding rats",5);
  ghid_check_button_connected
            (pGVar5,&disable_all_button,0,1,0,0,0,netlist_disable_all_cb,(gpointer)0x0,string);
  uVar3 = gtk_hseparator_new();
  uVar4 = g_type_check_instance_cast(pGVar5,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,3);
  uVar3 = gtk_hbutton_box_new();
  uVar4 = gtk_button_box_get_type();
  uVar4 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_button_box_set_layout(uVar4,4);
  uVar4 = g_type_check_instance_cast(pGVar5,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,4);
  uVar4 = gtk_button_new_from_stock("gtk-close");
  uVar8 = g_type_check_instance_cast(uVar4,0x50);
  g_signal_connect_data(uVar8,"clicked",netlist_close_cb,0,0,0);
  uVar2 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar2,uVar4,1,1,0);
  gtk_widget_realize(netlist_window);
  if (Settings.AutoPlace != '\0') {
    uVar2 = gtk_widget_get_type();
    uVar2 = g_type_check_instance_cast(netlist_window,uVar2);
    gtk_widget_set_uposition(uVar2,10,10);
  }
  gtk_widget_show_all();
  return;
}



// WARNING: Unknown calling convention

void ghid_netlist_window_update(gboolean init_nodes)

{
  GtkTreeModel *pGVar1;
  undefined4 uVar2;
  GtkTreeModel *model;
  
  pGVar1 = net_model;
  if (netlist_window == (GtkWidget *)0x0) {
    ghid_netlist_window_show(gport,0);
    return;
  }
  net_model = net_model_create();
  gtk_tree_view_set_model(net_treeview,net_model);
  uVar2 = gtk_tree_sortable_get_type();
  uVar2 = g_type_check_instance_cast(net_model,uVar2);
  gtk_tree_sortable_set_sort_column_id(uVar2,1,0);
  if (pGVar1 != (GtkTreeModel *)0x0) {
    uVar2 = gtk_tree_store_get_type();
    uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
    gtk_tree_store_clear(uVar2);
    g_object_unref(pGVar1);
  }
  selected_net = (LibraryMenuType *)0x0;
  if (init_nodes == 0) {
    return;
  }
  node_model_update((PCB->NetlistLib).Menu);
  return;
}



// WARNING: Unknown calling convention

gint NetlistChanged(int argc,char **argv,int x,int y)

{
  undefined4 uVar1;
  
  loading_new_netlist = 1;
  ghid_netlist_window_update(1);
  uVar1 = gtk_toggle_button_get_type();
  uVar1 = g_type_check_instance_cast(disable_all_button,uVar1);
  gtk_toggle_button_set_active(uVar1,0);
  loading_new_netlist = 0;
  return 0;
}



// WARNING: Unknown calling convention

LibraryMenuType * ghid_get_net_from_node_name(gchar *node_name,gboolean enabled_only)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkTreePath *path;
  ggnfnn_task task;
  
  if (node_name != (gchar *)0x0) {
    if (netlist_window == (GtkWidget *)0x0) {
      ghid_netlist_window_show(gport,0);
    }
    while (iVar1 = gtk_events_pending(), iVar1 != 0) {
      gtk_main_iteration();
    }
    if (netlist_window != (GtkWidget *)0x0) {
      task.enabled_only = enabled_only;
      task.node_name = node_name;
      task.found_net = (LibraryMenuType *)0x0;
      gtk_tree_model_foreach(net_model,hunt_named_node,&task);
      if (enabled_only == 0) {
        return task.found_net;
      }
      if (task.found_net == (LibraryMenuType *)0x0) {
        return (LibraryMenuType *)0x0;
      }
      selection_holdoff = 1;
      uVar2 = gtk_tree_model_get_path(net_model,&task.iter);
      gtk_tree_view_scroll_to_cell(net_treeview,uVar2,0,1,0x3f000000,0x3f000000);
      uVar3 = gtk_tree_view_get_selection(net_treeview);
      gtk_tree_selection_select_path(uVar3,uVar2);
      selection_holdoff = 0;
      return task.found_net;
    }
  }
  return (LibraryMenuType *)0x0;
}



// WARNING: Unknown calling convention

void ghid_netlist_highlight_node(gchar *node_name)

{
  LibraryMenuType *menu;
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkTreePath *path;
  char *pcVar4;
  GtkTreeIter iter;
  char *local_20 [4];
  
  if ((node_name != (gchar *)0x0) &&
     (menu = ghid_get_net_from_node_name(node_name,1), menu != (LibraryMenuType *)0x0)) {
    node_model_update(menu);
    iVar1 = gtk_tree_model_get_iter_first(node_model,&iter);
    while (iVar1 != 0) {
      gtk_tree_model_get(node_model,&iter,0,local_20,0xffffffff);
      pcVar4 = local_20[0];
      iVar1 = strcmp(node_name,local_20[0]);
      if (iVar1 == 0) {
        selection_holdoff = 1;
        selected_net = menu;
        uVar2 = gtk_tree_model_get_path(node_model,&iter);
        gtk_tree_view_scroll_to_cell(node_treeview,uVar2,0,1,0x3f000000,0x3f000000);
        uVar3 = gtk_tree_view_get_selection(node_treeview);
        gtk_tree_selection_select_path(uVar3,uVar2);
        selection_holdoff = 0;
        pcVar4 = local_20[0];
      }
      g_free(pcVar4);
      iVar1 = gtk_tree_model_iter_next(node_model,&iter);
    }
  }
  return;
}



// WARNING: Unknown calling convention

gint NetlistShow(int argc,char **argv,int x,int y)

{
  ghid_netlist_window_show(gport,0);
  if (0 < argc) {
    ghid_netlist_highlight_node(*argv);
  }
  return 0;
}



// WARNING: Unknown calling convention

LibraryEntryType_conflict * node_get_node_from_name(gchar *node_name,LibraryMenuType **node_net)

{
  LibraryMenuType *pLVar1;
  int iVar2;
  LibraryEntryType_conflict *node;
  LibraryEntryType_conflict *pLVar3;
  gint j;
  Cardinal CVar4;
  GtkTreeIter iter;
  LibraryMenuType *local_20 [4];
  
  if (node_name != (gchar *)0x0) {
    if (netlist_window == (GtkWidget *)0x0) {
      ghid_netlist_window_show(gport,0);
    }
    while (iVar2 = gtk_events_pending(), iVar2 != 0) {
      gtk_main_iteration();
    }
    iVar2 = gtk_tree_model_get_iter_first(net_model,&iter);
    while (iVar2 != 0) {
      gtk_tree_model_get(net_model,&iter,2,local_20,0xffffffff);
      pLVar1 = local_20[0];
      CVar4 = local_20[0]->EntryN;
      pLVar3 = local_20[0]->Entry;
      if (CVar4 != 0) {
        while( true ) {
          if ((pLVar3->ListEntry != (char *)0x0) &&
             (iVar2 = strcmp(node_name,pLVar3->ListEntry), iVar2 == 0)) {
            if (node_net == (LibraryMenuType **)0x0) {
              return pLVar3;
            }
            *node_net = pLVar1;
            return pLVar3;
          }
          CVar4 = CVar4 - 1;
          if (CVar4 == 0) break;
          pLVar3 = pLVar3 + 1;
        }
      }
      iVar2 = gtk_tree_model_iter_next(net_model,&iter);
    }
  }
  return (LibraryEntryType_conflict *)0x0;
}



// WARNING: Unknown calling convention

void netlist_close_cb(GtkWidget *widget,gpointer data)

{
  gtk_widget_destroy(netlist_window);
  selected_net = (LibraryMenuType *)0x0;
  netlist_window = (GtkWidget *)0x0;
  return;
}



// WARNING: Unknown calling convention

void netlist_disable_all_cb(GtkToggleButton *button,gpointer data)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined1 *puVar5;
  gboolean active;
  GtkTreeIter iter;
  int local_20 [4];
  
  iVar1 = gtk_toggle_button_get_active(button);
  iVar2 = gtk_tree_model_get_iter_first(net_model,&iter);
  if (iVar2 != 0) {
    uVar3 = gtk_tree_store_get_type();
    do {
      puVar5 = &DAT_081548e9;
      if (iVar1 == 0) {
        puVar5 = &DAT_0814741b;
      }
      uVar4 = g_type_check_instance_cast(net_model,uVar3);
      gtk_tree_store_set(uVar4,&iter,0,puVar5,0xffffffff);
      gtk_tree_model_get(net_model,&iter,2,local_20,0xffffffff);
      *(bool *)(local_20[0] + 0x18) = iVar1 == 0;
      iVar2 = gtk_tree_model_iter_next(net_model,&iter);
    } while (iVar2 != 0);
  }
  return;
}



// WARNING: Unknown calling convention

void netlist_find_cb(GtkWidget *widget,gpointer data)

{
  char *pcVar1;
  char *name;
  
  if (selected_net != (LibraryMenuType *)0x0) {
    pcVar1 = selected_net->Name;
    hid_actionl("connection","reset",0);
    hid_actionl("netlist",&DAT_0814a723,pcVar1 + 2,0);
  }
  return;
}



// WARNING: Unknown calling convention

void netlist_rip_up_cb(GtkWidget *widget,gpointer data)

{
  uint uVar1;
  PCBTypePtr pPVar2;
  LineTypePtr line;
  uchar *puVar3;
  DataTypePtr paVar4;
  ArcTypePtr arc;
  DataTypePtr paVar5;
  int iVar6;
  Cardinal l_1;
  Cardinal sn;
  PinTypePtr via;
  PinTypePtr Ptr1;
  Cardinal n;
  int iVar7;
  Cardinal n_2;
  Cardinal n_1;
  uint uVar8;
  LayerTypePtr layer;
  LayerType *pLVar9;
  uint uVar10;
  Cardinal l;
  LayerTypePtr layer_1;
  
  if (selected_net == (LibraryMenuType *)0x0) {
    return;
  }
  netlist_find_cb(widget,data);
  paVar4 = PCB->Data;
  pLVar9 = paVar4->Layer;
  pPVar2 = PCB;
  if (paVar4->LayerN != -2) {
    uVar10 = 0;
    do {
      if (pLVar9->On != '\0') {
        iVar7 = pLVar9->LineN - 1;
        if (iVar7 != -1) {
          iVar6 = pLVar9->LineN * 0x58 + -0x58;
          do {
            while (puVar3 = (pLVar9->Line->Flags).t + iVar6 + -0x18,
                  (*(uint *)(puVar3 + 0x14) & 0x2004) == 4) {
              iVar7 = iVar7 + -1;
              RemoveObject(4,pLVar9,puVar3,puVar3);
              iVar6 = iVar6 + -0x58;
              pPVar2 = PCB;
              if (iVar7 == -1) goto LAB_08100445;
            }
            iVar7 = iVar7 + -1;
            iVar6 = iVar6 + -0x58;
            pPVar2 = PCB;
          } while (iVar7 != -1);
        }
      }
LAB_08100445:
      paVar4 = pPVar2->Data;
      uVar10 = uVar10 + 1;
      if (paVar4->LayerN + 2U <= uVar10) goto LAB_08100478;
      pLVar9 = pLVar9 + 1;
    } while( true );
  }
  goto LAB_08100460;
LAB_08100478:
  pLVar9 = paVar4->Layer;
  if (paVar4->LayerN != -2) {
    uVar10 = 0;
    do {
      if (pLVar9->On != '\0') {
        iVar7 = pLVar9->ArcN - 1;
        if (iVar7 != -1) {
          iVar6 = pLVar9->ArcN * 0x44 + -0x44;
          do {
            while (puVar3 = (pLVar9->Arc->Flags).t + iVar6 + -0x18,
                  (*(uint *)(puVar3 + 0x14) & 0x2004) == 4) {
              iVar7 = iVar7 + -1;
              iVar6 = iVar6 + -0x44;
              RemoveObject(0x4000,pLVar9,puVar3,puVar3);
              pPVar2 = PCB;
              if (iVar7 == -1) goto LAB_081004f5;
            }
            iVar7 = iVar7 + -1;
            iVar6 = iVar6 + -0x44;
            pPVar2 = PCB;
          } while (iVar7 != -1);
        }
      }
LAB_081004f5:
      paVar4 = pPVar2->Data;
      uVar10 = uVar10 + 1;
      if (paVar4->LayerN + 2U <= uVar10) break;
      pLVar9 = pLVar9 + 1;
    } while( true );
  }
LAB_08100460:
  if (pPVar2->ViaOn != '\0') {
    paVar5 = pPVar2->Data;
    if (paVar5->ViaN != 0) {
      uVar8 = 0;
      uVar10 = paVar4->ViaN;
      do {
        Ptr1 = paVar5->Via + uVar8;
        if (((Ptr1->Flags).f & 0x2004) == 4) {
          RemoveObject(1,Ptr1,Ptr1,Ptr1);
          pPVar2 = PCB;
        }
        paVar5 = pPVar2->Data;
        uVar1 = paVar5->ViaN;
      } while ((uVar1 != 0) && (uVar8 = (uVar1 + 1 + uVar8) - uVar10, uVar10 = uVar1, uVar8 < uVar1)
              );
    }
  }
  return;
}



// WARNING: Unknown calling convention

void netlist_select_cb(GtkWidget *widget,gpointer data)

{
  Boolean BVar1;
  gint i;
  Cardinal CVar2;
  LibraryEntryType_conflict *entry;
  LibraryEntryTypePtr entry_00;
  ConnectionType conn;
  
  if (selected_net != (LibraryMenuType *)0x0) {
    if (selected_net == node_selected_net) {
      node_selected_net = (LibraryMenuType *)0x0;
    }
    InitConnectionLookup();
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    SaveUndoSerialNumber();
    CVar2 = selected_net->EntryN;
    entry_00 = selected_net->Entry;
    if (CVar2 != 0) {
      while( true ) {
        BVar1 = SeekPad(entry_00,&conn,'\0');
        if (BVar1 != '\0') {
          RatFindHook(conn.type,conn.ptr1,conn.ptr2,conn.ptr2,'\x01','\x01');
        }
        if (CVar2 == 1) break;
        CVar2 = CVar2 - 1;
        entry_00 = entry_00 + 1;
      }
    }
    RestoreUndoSerialNumber();
    SelectConnection((Boolean)data);
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    FreeConnectionLookupMemory();
    IncrementUndoSerialNumber();
    ghid_invalidate_all();
  }
  return;
}



// WARNING: Unknown calling convention

void net_selection_changed_cb(GtkTreeSelection *selection,gpointer data)

{
  int iVar1;
  GtkTreeIter iter;
  LibraryMenuType *local_14;
  undefined4 local_10 [2];
  
  if (selection_holdoff != 0) {
    return;
  }
  iVar1 = gtk_tree_selection_get_selected(selection,local_10,&iter);
  if (iVar1 == 0) {
    selected_net = (LibraryMenuType *)0x0;
    return;
  }
  gtk_tree_model_get(local_10[0],&iter,2,&local_14,0xffffffff);
  node_model_update(local_14);
  selected_net = local_14;
  return;
}



// WARNING: Unknown calling convention

void node_selection_changed_cb(GtkTreeSelection *selection,gpointer data)

{
  int iVar1;
  int iVar2;
  gint margin;
  gint gVar3;
  GtkTreeIter iter;
  LibraryEntryType_conflict *local_28;
  LibraryMenuType *local_24;
  undefined4 local_20 [4];
  
  if (selection_holdoff != 0) {
    return;
  }
  local_28 = node_get_node_from_name(node_selection_changed_cb::node_name,&local_24);
  if (local_28 != (LibraryEntryType_conflict *)0x0) {
    if (local_24 == node_selected_net) {
      SelectPin(local_28,'\x01');
    }
    g_free(node_selection_changed_cb::node_name);
    node_selection_changed_cb::node_name = (gchar *)0x0;
  }
  iVar2 = gtk_tree_selection_get_selected(selection,local_20,&iter);
  if (iVar2 == 0) {
    if (local_28 == (LibraryEntryType_conflict *)0x0) {
      return;
    }
    ghid_invalidate_all();
    return;
  }
  gtk_tree_model_get(local_20[0],&iter,1,&local_28,0xffffffff);
  dup_string(&node_selection_changed_cb::node_name,local_28->ListEntry);
  node_selected_net = selected_net;
  SelectPin(local_28,'\x01');
  IncrementUndoSerialNumber();
  iVar2 = gport->view_width;
  iVar1 = iVar2 / 0x14;
  if ((Crosshair.X < iVar1 + gport->view_x0) || ((gport->view_x0 + iVar2) - iVar1 < Crosshair.X)) {
    gVar3 = gport->view_height;
  }
  else if (Crosshair.Y < gport->view_y0 + iVar1) {
    gVar3 = gport->view_height;
  }
  else {
    gVar3 = gport->view_height;
    if (Crosshair.Y <= (gVar3 + gport->view_y0) - iVar1) goto LAB_08100888;
  }
  ghid_port_ranges_pan((double)(Crosshair.X - iVar2 / 2),(double)(Crosshair.Y - gVar3 / 2),0);
LAB_08100888:
  ghid_screen_update();
  return;
}



// WARNING: Unknown calling convention

void net_selection_double_click_cb
               (GtkTreeView *treeview,GtkTreePath *path,GtkTreeViewColumn *col,gpointer data)

{
  undefined4 uVar1;
  int iVar2;
  uchar *__s1;
  undefined4 uVar3;
  uint uVar4;
  int __result;
  GtkTreeModel *model;
  undefined1 *puVar5;
  GtkTreeIter iter;
  int local_24;
  byte *local_20 [4];
  
  uVar1 = gtk_tree_view_get_model(treeview);
  iVar2 = gtk_tree_model_get_iter(uVar1,&iter,path);
  if (iVar2 != 0) {
    iVar2 = gtk_tree_model_iter_has_child(uVar1,&iter);
    if (iVar2 == 0) {
      gtk_tree_model_get(uVar1,&iter,0,local_20,0xffffffff);
      if ((*local_20[0] == 0x2a) && (local_20[0][1] == 0)) {
        puVar5 = &DAT_0814741b;
      }
      else {
        puVar5 = &DAT_081548e9;
      }
      uVar3 = gtk_tree_store_get_type();
      uVar3 = g_type_check_instance_cast(uVar1,uVar3);
      gtk_tree_store_set(uVar3,&iter,0,puVar5,0xffffffff);
      gtk_tree_model_get(uVar1,&iter,2,&local_24,0xffffffff);
      uVar4 = *local_20[0] - 0x2a;
      if (uVar4 == 0) {
        uVar4 = (uint)local_20[0][1];
      }
      *(bool *)(local_24 + 0x18) = uVar4 == 0;
      g_free(local_20[0]);
    }
    else {
      iVar2 = gtk_tree_view_row_expanded(treeview,path);
      if (iVar2 == 0) {
        gtk_tree_view_expand_row(treeview,path,0);
      }
      else {
        gtk_tree_view_collapse_row(treeview,path);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

gboolean have_crosshair_attachments(void)

{
  gboolean result;
  
  if (Settings.Mode == 5) {
    return 1;
  }
  if (Settings.Mode < 6) {
    if ((Settings.Mode == 2) || (Settings.Mode == 4)) {
      return (uint)(Crosshair.AttachedLine.State != 0);
    }
    if (Settings.Mode == 1) {
      return 1;
    }
  }
  else if (0x67 < Settings.Mode) {
    if (Settings.Mode < 0x6b) {
      return (uint)(Crosshair.AttachedObject.Type != 0);
    }
    if (Settings.Mode == 0x6d) {
      return (uint)(Crosshair.AttachedBox.State != 0);
    }
  }
  return (uint)(Crosshair.AttachedBox.State - 1U < 2);
}



// WARNING: Unknown calling convention

gint ghid_port_window_mouse_scroll_cb(GtkWidget *widget,GdkEventScroll *ev,GHidPort *out)

{
  ModifierKeysState mod_mask;
  ModifierKeysState mk;
  int button_00;
  int button;
  GdkModifierType local_10 [2];
  
  local_10[0] = ev->state;
  mod_mask = ghid_modifier_keys_state(local_10);
  button_00 = -1;
  if (ev->direction < 4) {
    button_00 = *(int *)(CSWTCH_147 + ev->direction * 4);
  }
  do_mouse_action(button_00,mod_mask);
  return 1;
}



// WARNING: Unknown calling convention

gboolean ghid_idle_cb(gpointer data)

{
  int iVar1;
  
  if (Settings.Mode == 0) {
    SetMode(0x6e);
  }
  ghid_mode_cursor(Settings.Mode);
  iVar1 = ghidgui->settings_mode;
  if (ghidgui->settings_mode != Settings.Mode) {
    ghid_mode_buttons_update();
    iVar1 = Settings.Mode;
  }
  ghidgui->settings_mode = iVar1;
  ghid_update_toggle_flags();
  return 0;
}



// WARNING: Unknown calling convention

void draw_crosshair(GdkGC *xor_gc,gint x,gint y)

{
  double dVar1;
  double dVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  
  gdk_draw_line(gport->drawing_area->window,xor_gc,x,0,x,gport->height);
  gdk_draw_line(gport->drawing_area->window,xor_gc,0,y,gport->width,y);
  if (draw_crosshair::prev == Union_Jack_Crosshair_Shape) {
    iVar5 = gport->height;
    iVar6 = gport->width;
    iVar3 = (x + iVar5) - y;
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    iVar7 = x - y;
    if (iVar6 < x - y) {
      iVar7 = iVar6;
    }
    iVar8 = y - x;
    iVar4 = iVar6 + iVar8;
    if (iVar5 < iVar6 + iVar8) {
      iVar4 = iVar5;
    }
    if (iVar8 <= iVar5) {
      iVar5 = iVar8;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    iVar5 = 0;
    if (-1 < iVar7) {
      iVar5 = iVar7;
    }
    if (iVar4 < 0) {
      iVar4 = 0;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar3,iVar4,iVar5,iVar6);
    iVar6 = gport->width;
    iVar3 = gport->height;
    iVar5 = y + x;
    iVar7 = (x - iVar3) + y;
    if (iVar6 < iVar7) {
      iVar7 = iVar6;
    }
    iVar4 = iVar6;
    if (iVar5 <= iVar6) {
      iVar4 = iVar5;
    }
    iVar6 = (x - iVar6) + y;
    if (iVar3 < iVar6) {
      iVar6 = iVar3;
    }
    iVar8 = 0;
    if (-1 < iVar6) {
      iVar8 = iVar6;
    }
    iVar6 = 0;
    if (-1 < iVar4) {
      iVar6 = iVar4;
    }
    if (iVar5 <= iVar3) {
      iVar3 = iVar5;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar7,iVar3,iVar6,iVar8);
  }
  if (draw_crosshair::prev == Dozen_Crosshair_Shape) {
    dVar2 = (double)x;
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND((double)(iVar6 - y) / 1.732050807568877 + dVar2);
    dVar1 = (double)y;
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar2 - dVar1 / 1.732050807568877);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar3 = (int)ROUND((double)(iVar3 - x) * 1.732050807568877 + dVar1);
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    iVar4 = (int)ROUND(dVar1 - dVar2 * 1.732050807568877);
    if (iVar4 <= iVar6) {
      iVar6 = iVar4;
    }
    iVar4 = 0;
    if (-1 < iVar6) {
      iVar4 = iVar6;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar6,iVar3,iVar7,iVar4);
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND((double)(iVar6 - y) * 1.732050807568877 + dVar2);
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar2 - dVar1 * 1.732050807568877);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar3 = (int)ROUND((double)(iVar3 - x) / 1.732050807568877 + dVar1);
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    iVar4 = (int)ROUND(dVar1 - 1.732050807568877 / dVar2);
    if (iVar4 <= iVar6) {
      iVar6 = iVar4;
    }
    iVar4 = 0;
    if (-1 < iVar6) {
      iVar4 = iVar6;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar6,iVar3,iVar7,iVar4);
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND(dVar2 - (double)(iVar6 - y) / 1.732050807568877);
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar1 / 1.732050807568877 + dVar2);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar4 = (int)ROUND(dVar2 * 1.732050807568877 + dVar1);
    if (iVar6 < iVar4) {
      iVar4 = iVar6;
    }
    iVar3 = (int)ROUND(dVar1 - (double)(iVar3 - x) * 1.732050807568877);
    if (iVar3 <= iVar6) {
      iVar6 = iVar3;
    }
    iVar3 = 0;
    if (-1 < iVar6) {
      iVar3 = iVar6;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar4 < 0) {
      iVar4 = 0;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar6,iVar4,iVar7,iVar3);
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND(dVar2 - (double)(iVar6 - y) * 1.732050807568877);
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar1 * 1.732050807568877 + dVar2);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar4 = (int)ROUND(1.732050807568877 / dVar2 + dVar1);
    if (iVar6 < iVar4) {
      iVar4 = iVar6;
    }
    iVar3 = (int)ROUND(dVar1 - 1.732050807568877 / (double)(iVar3 - x));
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar4 < 0) {
      iVar4 = 0;
    }
    if (iVar5 < 0) {
      iVar5 = 0;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar5,iVar4,iVar7,iVar3);
  }
  draw_crosshair::prev = Crosshair.shape;
  return;
}



// WARNING: Unknown calling convention

void ghid_show_crosshair(gboolean show)

{
  int x_00;
  double dVar1;
  int iVar2;
  gboolean gVar3;
  int iVar4;
  gint x;
  gint y;
  gint gVar5;
  
  iVar4 = gport->x_crosshair;
  iVar2 = ghid_show_crosshair::y_prev;
  x_00 = ghid_show_crosshair::x_prev;
  if (((-1 < iVar4) && (ghidgui->creating == 0)) && (gport->has_entered != 0)) {
    if (ghid_show_crosshair::xor_gc == (GdkGC *)0x0) {
      ghid_show_crosshair::xor_gc = (GdkGC *)gdk_gc_new((ghid_port.drawing_area)->window);
      gdk_gc_copy(ghid_show_crosshair::xor_gc,(ghid_port.drawing_area)->style->white_gc);
      gdk_gc_set_function(ghid_show_crosshair::xor_gc,2);
      ghid_map_color_string(Settings.CrossColor,&ghid_show_crosshair::cross_color);
      iVar4 = gport->x_crosshair;
    }
    if (ghid_flip_x != 0) {
      iVar4 = PCB->MaxWidth - iVar4;
    }
    dVar1 = gport->zoom;
    x_00 = (int)ROUND((double)(iVar4 - gport->view_x0) / dVar1);
    if (ghid_flip_y == 0) {
      gVar5 = gport->y_crosshair;
    }
    else {
      gVar5 = PCB->MaxHeight - gport->y_crosshair;
    }
    iVar2 = gport->view_y0;
    gdk_gc_set_foreground(ghid_show_crosshair::xor_gc,&ghid_show_crosshair::cross_color);
    if (((-1 < ghid_show_crosshair::x_prev) &&
        (draw_crosshair(ghid_show_crosshair::xor_gc,ghid_show_crosshair::x_prev,
                        ghid_show_crosshair::y_prev), ghidgui->auto_pan_on != 0)) &&
       (gVar3 = have_crosshair_attachments(), gVar3 != 0)) {
      gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,0,
                         ghid_show_crosshair::y_prev + -8,8,0x10);
      gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,gport->width + -8
                         ,ghid_show_crosshair::y_prev + -8,8,0x10);
      gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,
                         ghid_show_crosshair::x_prev + -8,0,0x10,8);
      gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,
                         ghid_show_crosshair::x_prev + -8,gport->height + -8,0x10,8);
    }
    if ((x_00 < 0) || (show == 0)) {
      ghid_show_crosshair::y_prev = -1;
      ghid_show_crosshair::x_prev = -1;
      iVar2 = ghid_show_crosshair::y_prev;
      x_00 = ghid_show_crosshair::x_prev;
    }
    else {
      iVar2 = (int)ROUND((double)(gVar5 - iVar2) / dVar1);
      draw_crosshair(ghid_show_crosshair::xor_gc,x_00,iVar2);
      if ((ghidgui->auto_pan_on != 0) && (gVar3 = have_crosshair_attachments(), gVar3 != 0)) {
        gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,0,iVar2 + -8,8,
                           0x10);
        gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,
                           gport->width + -8,iVar2 + -8,8,0x10);
        gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,x_00 + -8,0,
                           0x10,8);
        gdk_draw_rectangle(gport->drawing_area->window,ghid_show_crosshair::xor_gc,1,x_00 + -8,
                           gport->height + -8,0x10,8);
      }
    }
  }
  ghid_show_crosshair::x_prev = x_00;
  ghid_show_crosshair::y_prev = iVar2;
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_port_drawing_area_expose_event_cb(GtkWidget *widget,GdkEventExpose *ev,GHidPort *port)

{
  gint gVar1;
  gint gVar2;
  
  ghid_show_crosshair(0);
  gVar1 = (ev->area).y;
  gVar2 = (ev->area).x;
  gdk_draw_drawable(widget->window,port->bg_gc,port->pixmap,gVar2,gVar1,gVar2,gVar1,(ev->area).width
                    ,(ev->area).height);
  ghid_show_crosshair(1);
  return 0;
}



// WARNING: Unknown calling convention

void ghid_screen_update(void)

{
  ghid_show_crosshair(0);
  gdk_draw_drawable(gport->drawing_area->window,gport->bg_gc,gport->pixmap,0,0,0,0,gport->width,
                    gport->height);
  ghid_show_crosshair(1);
  return;
}



// WARNING: Unknown calling convention

gint ghid_port_window_enter_cb(GtkWidget *widget,GdkEventCrossing *ev,GHidPort *out)

{
  GdkCrossingMode GVar1;
  
  GVar1 = ev->mode;
  if ((GVar1 == GDK_CROSSING_NORMAL) || (ev->detail == GDK_NOTIFY_NONLINEAR)) {
    if (ghidgui->command_entry_status_line_active == 0) {
      out->has_entered = 1;
      gtk_widget_grab_focus(out->drawing_area);
      GVar1 = ev->mode;
      ghidgui->in_popup = 0;
    }
    else {
      ghidgui->in_popup = 0;
    }
    if ((GVar1 == GDK_CROSSING_UNGRAB) && (ev->detail == GDK_NOTIFY_NONLINEAR)) {
      ghid_screen_update();
    }
    if (cursor_in_viewport == 0) {
      RestoreCrosshair('\x01');
      cursor_in_viewport = 1;
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

gboolean ghid_note_event_location(GdkEventButton *ev)

{
  GHidPort *pGVar1;
  Boolean BVar2;
  int Y;
  int X;
  gboolean moved;
  bool bVar3;
  int local_14;
  int local_10 [2];
  
  if (ev == (GdkEventButton *)0x0) {
    gdk_window_get_pointer((ghid_port.drawing_area)->window,local_10,&local_14,0);
  }
  else {
    local_10[0] = (int)ROUND(ev->x);
    local_14 = (int)ROUND(ev->y);
  }
  pGVar1 = gport;
  bVar3 = ghid_flip_y != 0;
  X = (int)ROUND((double)gport->view_x0 + (double)local_10[0] * gport->zoom);
  event_x = local_10[0];
  event_y = local_14;
  gport->view_x = X;
  Y = (int)ROUND((double)pGVar1->view_y0 + (double)local_14 * pGVar1->zoom);
  pGVar1->view_y = Y;
  if (bVar3) {
    Y = PCB->MaxHeight - Y;
  }
  if (ghid_flip_x != 0) {
    X = PCB->MaxWidth - X;
  }
  BVar2 = MoveCrosshairAbsolute(X,Y);
  if (BVar2 != 0) {
    AdjustAttachedObjects();
    RestoreCrosshair('\0');
  }
  ghid_set_cursor_position_labels();
  return (int)BVar2;
}



// WARNING: Unknown calling convention

gboolean ghid_port_button_release_cb(GtkWidget *drawing_area,GdkEventButton *ev,GtkUIManager *ui)

{
  ModifierKeysState MVar1;
  gboolean gVar2;
  gboolean drag;
  ModifierKeysState mk;
  GdkModifierType local_10;
  
  ghid_note_event_location(ev);
  local_10 = ev->state;
  MVar1 = ghid_modifier_keys_state(&local_10);
  gVar2 = have_crosshair_attachments();
  if (gVar2 == 0) {
    do_mouse_action(ev->button,MVar1 + 0x80000000);
  }
  else {
    HideCrosshair('\x01');
    do_mouse_action(ev->button,MVar1 + 0x80000000);
    AdjustAttachedObjects();
    ghid_invalidate_all();
    RestoreCrosshair('\x01');
    ghid_screen_update();
  }
  ghid_set_status_line_label();
  g_idle_add(ghid_idle_cb,0);
  return 1;
}



// WARNING: Unknown calling convention

gboolean ghid_port_button_press_cb(GtkWidget *drawing_area,GdkEventButton *ev,GtkUIManager *ui)

{
  ModifierKeysState mod_mask;
  ModifierKeysState mk;
  GdkModifierType local_10;
  
  if (ev->type == GDK_BUTTON_PRESS) {
    ghid_note_event_location(ev);
    local_10 = ev->state;
    mod_mask = ghid_modifier_keys_state(&local_10);
    ghid_show_crosshair(0);
    HideCrosshair('\x01');
    do_mouse_action(ev->button,mod_mask);
    ghid_invalidate_all();
    RestoreCrosshair('\x01');
    ghid_set_status_line_label();
    ghid_show_crosshair(1);
    if (gport->panning == 0) {
      g_idle_add(ghid_idle_cb,0);
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

gboolean ghid_port_key_press_cb(GtkWidget *drawing_area,GdkEventKey *kev,GtkUIManager *ui)

{
  guint ksym_00;
  gboolean gVar1;
  ModifierKeysState MVar2;
  gboolean handled;
  gint ksym;
  ModifierKeysState mk;
  GdkModifierType local_10;
  
  ksym_00 = kev->keyval;
  gVar1 = ghid_is_modifier_key_sym(ksym_00);
  if (gVar1 != 0) {
    ghid_note_event_location((GdkEventButton *)0x0);
  }
  local_10 = kev->state;
  MVar2 = ghid_modifier_keys_state(&local_10);
  ghid_show_crosshair(0);
  if (ksym_00 == 0xff53) {
    ghid_hotkey_cb(5);
    return 1;
  }
  if ((int)ksym_00 < 0xff54) {
    if (ksym_00 == 0xff09) {
      switch(MVar2) {
      case NONE_PRESSED:
        ghid_hotkey_cb(1);
        handled = 1;
        return handled;
      case SHIFT_PRESSED:
switchD_08101b30_caseD_0:
        ghid_hotkey_cb(0x21);
        handled = 1;
        return handled;
      case CONTROL_PRESSED:
        ghid_hotkey_cb(0x41);
        handled = 1;
        return handled;
      case SHIFT_CONTROL_PRESSED:
switchD_08101b30_caseD_2:
        ghid_hotkey_cb(0x61);
        handled = 1;
        return handled;
      case MOD1_PRESSED:
        ghid_hotkey_cb(0x81);
        handled = 1;
        return handled;
      case SHIFT_MOD1_PRESSED:
switchD_08101b30_caseD_4:
        ghid_hotkey_cb(0xa1);
        handled = 1;
        return handled;
      }
    }
    else if ((int)ksym_00 < 0xff0a) {
      if ((ksym_00 == 0xfd05) || (ksym_00 == 0xfe20)) {
        switch(MVar2) {
        case NONE_PRESSED:
        case SHIFT_PRESSED:
          goto switchD_08101b30_caseD_0;
        case CONTROL_PRESSED:
        case SHIFT_CONTROL_PRESSED:
          goto switchD_08101b30_caseD_2;
        case MOD1_PRESSED:
        case SHIFT_MOD1_PRESSED:
          goto switchD_08101b30_caseD_4;
        }
      }
    }
    else {
      if (ksym_00 == 0xff51) {
        ghid_hotkey_cb(4);
        return 1;
      }
      if (ksym_00 == 0xff52) {
        ghid_hotkey_cb(2);
        return 1;
      }
    }
  }
  else if ((int)ksym_00 < 0xffe5) {
    if (0xffe0 < (int)ksym_00) {
      return 1;
    }
    if (ksym_00 == 0xff54) {
      ghid_hotkey_cb(3);
      return 1;
    }
  }
  else if ((ksym_00 == 0xffe6) || ((0xffe5 < (int)ksym_00 && (ksym_00 - 0xffe9 < 2)))) {
    return 1;
  }
  handled = 0;
  return handled;
}



// WARNING: Unknown calling convention

gboolean ghid_port_key_release_cb(GtkWidget *drawing_area,GdkEventKey *kev,GtkUIManager *ui)

{
  gboolean gVar1;
  
  gVar1 = ghid_is_modifier_key_sym(kev->keyval);
  if (gVar1 != 0) {
    ghid_note_event_location((GdkEventButton *)0x0);
  }
  HideCrosshair('\x01');
  AdjustAttachedObjects();
  ghid_invalidate_all();
  RestoreCrosshair('\x01');
  ghid_screen_update();
  g_idle_add(ghid_idle_cb,0);
  return 0;
}



// WARNING: Unknown calling convention

void ghid_get_coords(char *msg,int *x,int *y)

{
  GHidPort *pGVar1;
  gint gVar2;
  
  if (msg != (char *)0x0) {
    if (ghid_port.has_entered != 0) goto LAB_08101cc6;
    ghid_get_user_xy(msg);
  }
  if (ghid_port.has_entered == 0) {
    return;
  }
LAB_08101cc6:
  pGVar1 = gport;
  if (ghid_flip_x == 0) {
    *x = gport->view_x;
  }
  else {
    *x = PCB->MaxWidth - gport->view_x;
  }
  if (ghid_flip_y == 0) {
    gVar2 = pGVar1->view_y;
  }
  else {
    gVar2 = PCB->MaxHeight - pGVar1->view_y;
  }
  *y = gVar2;
  return;
}



// WARNING: Unknown calling convention

gint ghid_port_window_leave_cb(GtkWidget *widget,GdkEventCrossing *ev,GHidPort *out)

{
  int iVar1;
  int iVar2;
  double dVar3;
  int iVar4;
  GhidGui *pGVar5;
  gboolean gVar6;
  gint y0;
  int iVar7;
  gint dy;
  gint x0;
  int iVar8;
  gint dx;
  gint h;
  int local_24;
  int local_20 [4];
  
  pGVar5 = ghidgui;
  if (ev->mode == GDK_CROSSING_NORMAL) {
    if ((((out->has_entered != 0) && (ghidgui->in_popup == 0)) &&
        (gVar6 = have_crosshair_attachments(), gVar6 != 0)) && (pGVar5->auto_pan_on != 0)) {
      dVar3 = gport->zoom;
      iVar1 = (int)ROUND((double)ghid_port.width * dVar3);
      iVar2 = (int)ROUND((double)ghid_port.height * dVar3);
      if (ghid_flip_x == 0) {
        x0 = (gint)ROUND((double)gport->view_x0 + dVar3 * 0.0);
      }
      else {
        x0 = PCB->MaxWidth - (int)ROUND((double)gport->view_x0 + dVar3 * 0.0);
      }
      if (ghid_flip_y == 0) {
        y0 = (gint)ROUND((double)gport->view_y0 + dVar3 * 0.0);
      }
      else {
        y0 = PCB->MaxHeight - (int)ROUND((double)gport->view_y0 + dVar3 * 0.0);
      }
      ghid_get_coords((char *)0x0,local_20,&local_24);
      local_20[0] = local_20[0] - x0;
      local_24 = local_24 - y0;
      if (ghid_flip_x != 0) {
        local_20[0] = -local_20[0];
      }
      if (ghid_flip_y != 0) {
        local_24 = -local_24;
      }
      iVar7 = iVar2 - local_24;
      iVar8 = iVar1 - local_20[0];
      iVar4 = ghidgui->auto_pan_speed;
      y_pan_speed = iVar4 * 2;
      x_pan_speed = y_pan_speed;
      if (local_20[0] < iVar8) {
        iVar8 = local_20[0];
        x_pan_speed = iVar4 * -2;
      }
      if (local_24 < iVar7) {
        y_pan_speed = iVar4 * -2;
        iVar7 = local_24;
      }
      if (iVar8 < iVar7) {
        if (iVar7 < iVar2 / 3) {
          y_pan_speed = (y_pan_speed * -3 * iVar7) / iVar2 + y_pan_speed;
        }
        else {
          y_pan_speed = 0;
        }
      }
      else if (iVar8 < iVar1 / 3) {
        x_pan_speed = (x_pan_speed * -3 * iVar8) / iVar1 + x_pan_speed;
      }
      else {
        x_pan_speed = 0;
      }
      g_idle_add(ghid_pan_idle_cb,0);
    }
    if (cursor_in_viewport != 0) {
      HideCrosshair('\x01');
      cursor_in_viewport = 0;
    }
    ghid_show_crosshair(0);
    out->has_entered = 0;
    ghid_screen_update();
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x081021ac)
// WARNING: Removing unreachable block (ram,0x081020d0)
// WARNING: Removing unreachable block (ram,0x0810218e)
// WARNING: Unknown calling convention

gboolean ghid_port_ranges_pan(gdouble x,gdouble y,gboolean relative)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  GhidGui *pGVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int iVar9;
  int iVar10;
  GtkAdjustment *v_adj;
  uint uVar11;
  GtkAdjustment *h_adj;
  gdouble y1;
  gdouble x1;
  gdouble y0;
  gdouble x0;
  
  uVar7 = gtk_range_get_type();
  uVar8 = g_type_check_instance_cast(ghidgui->h_range,uVar7);
  iVar9 = gtk_range_get_adjustment(uVar8);
  uVar8 = g_type_check_instance_cast(ghidgui->v_range,uVar7);
  iVar10 = gtk_range_get_adjustment(uVar8);
  pGVar6 = ghidgui;
  dVar1 = *(double *)(iVar9 + 0x20);
  dVar2 = *(double *)(iVar10 + 0x20);
  if (relative != 0) {
    x = dVar1 + x;
    y = dVar2 + y;
  }
  dVar3 = *(double *)(iVar9 + 0x10);
  if (*(double *)(iVar9 + 0x10) <= x) {
    dVar3 = x;
  }
  dVar4 = *(double *)(iVar9 + 0x18) - *(double *)(iVar9 + 0x38);
  if (dVar4 <= dVar3 || dVar3 != dVar4) {
    dVar3 = dVar4;
  }
  dVar4 = *(double *)(iVar10 + 0x10);
  if (*(double *)(iVar10 + 0x10) <= y) {
    dVar4 = y;
  }
  dVar5 = *(double *)(iVar10 + 0x18) - *(double *)(iVar10 + 0x38);
  if (dVar5 <= dVar4 || dVar4 != dVar5) {
    dVar4 = dVar5;
  }
  if (dVar1 != dVar3) {
    if (dVar2 != dVar4) {
      ghidgui->combine_adjustments = 1;
    }
    uVar8 = g_type_check_instance_cast(pGVar6->h_range,uVar7);
    gtk_range_set_value(uVar8,dVar3);
  }
  if (dVar2 != dVar4) {
    uVar7 = g_type_check_instance_cast(ghidgui->v_range,uVar7);
    gtk_range_set_value(uVar7,dVar4);
  }
  ghid_note_event_location((GdkEventButton *)0x0);
  uVar11 = 1;
  if (dVar1 == dVar3) {
    uVar11 = (uint)(dVar2 != dVar4);
  }
  return uVar11;
}



// WARNING: Unknown calling convention

gboolean ghid_pan_idle_cb(gpointer data)

{
  gboolean gVar1;
  
  if (gport->has_entered != 0) {
    return 0;
  }
  gVar1 = ghid_port_ranges_pan
                    ((double)x_pan_speed * gport->zoom,(double)y_pan_speed * gport->zoom,1);
  return gVar1;
}



// WARNING: Unknown calling convention

gint ghid_port_window_motion_cb(GtkWidget *widget,GdkEventButton *ev,GHidPort *out)

{
  double dVar1;
  double dVar2;
  int iVar3;
  gboolean gVar4;
  gboolean moved;
  
  if (out->panning == 0) {
    ghid_port_window_motion_cb::y_prev = -1;
    ghid_port_window_motion_cb::x_prev = -1;
    gVar4 = ghid_note_event_location(ev);
    ghid_show_crosshair(1);
    if ((gVar4 != 0) && (gVar4 = have_crosshair_attachments(), gVar4 != 0)) {
      ghid_draw_area_update(gport,(GdkRectangle *)0x0);
    }
  }
  else {
    iVar3 = gtk_events_pending();
    if (iVar3 == 0) {
      dVar1 = ev->x;
      dVar2 = ev->y;
      if (0 < ghid_port_window_motion_cb::x_prev) {
        ghid_port_ranges_pan
                  (((double)ghid_port_window_motion_cb::x_prev - dVar1) * gport->zoom,
                   ((double)ghid_port_window_motion_cb::y_prev - dVar2) * gport->zoom,1);
        dVar1 = ev->x;
        dVar2 = ev->y;
      }
      ghid_port_window_motion_cb::x_prev = (gint)ROUND(dVar1);
      ghid_port_window_motion_cb::y_prev = (gint)ROUND(dVar2);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void ghid_port_ranges_changed(void)

{
  GhidGui *pGVar1;
  GHidPort *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  GtkAdjustment *v_adj;
  GtkAdjustment *h_adj;
  
  if (ghidgui->combine_adjustments == 0) {
    HideCrosshair('\0');
    pGVar1 = ghidgui;
    if (ghidgui->combine_adjustments == 0) {
      ghidgui->need_restore_crosshair = 1;
      uVar3 = gtk_range_get_type();
      uVar4 = g_type_check_instance_cast(pGVar1->h_range,uVar3);
      iVar5 = gtk_range_get_adjustment(uVar4);
      uVar3 = g_type_check_instance_cast(ghidgui->v_range,uVar3);
      iVar6 = gtk_range_get_adjustment(uVar3);
      pGVar2 = gport;
      gport->view_x0 = (int)ROUND(*(double *)(iVar5 + 0x20));
      pGVar2->view_y0 = (int)ROUND(*(double *)(iVar6 + 0x20));
      ghid_invalidate_all();
      return;
    }
  }
  ghidgui->combine_adjustments = 0;
  return;
}



// WARNING: Unknown calling convention

void ghid_port_ranges_scale(gboolean emit_changed)

{
  gint *pgVar1;
  gdouble *pgVar2;
  int iVar3;
  int iVar4;
  double dVar5;
  PCBTypePtr pPVar6;
  GHidPort *pGVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  int iVar10;
  GtkAdjustment *adj;
  
  pGVar7 = gport;
  pPVar6 = PCB;
  iVar10 = (int)ROUND((double)gport->width * gport->zoom);
  pgVar1 = &gport->height;
  pgVar2 = &gport->zoom;
  gport->view_width = iVar10;
  iVar3 = (int)ROUND((double)*pgVar1 * *pgVar2);
  pGVar7->view_height = iVar3;
  iVar4 = pPVar6->MaxWidth;
  if (iVar4 <= iVar10) {
    pGVar7->view_width = iVar4;
  }
  iVar10 = pPVar6->MaxHeight;
  if (iVar10 <= iVar3) {
    pGVar7->view_height = iVar10;
  }
  uVar8 = gtk_range_get_type();
  uVar9 = g_type_check_instance_cast(ghidgui->h_range,uVar8);
  iVar10 = gtk_range_get_adjustment(uVar9);
  dVar5 = (double)gport->view_width;
  *(double *)(iVar10 + 0x38) = dVar5;
  pPVar6 = PCB;
  *(double *)(iVar10 + 0x30) = dVar5 / 10.0;
  *(double *)(iVar10 + 0x28) = dVar5 / 100.0;
  *(double *)(iVar10 + 0x18) = (double)pPVar6->MaxWidth;
  if (emit_changed != 0) {
    uVar9 = gtk_object_get_type();
    uVar9 = g_type_check_instance_cast(iVar10,uVar9);
    gtk_signal_emit_by_name(uVar9,"changed");
  }
  uVar8 = g_type_check_instance_cast(ghidgui->v_range,uVar8);
  iVar10 = gtk_range_get_adjustment(uVar8);
  dVar5 = (double)gport->view_height;
  *(double *)(iVar10 + 0x38) = dVar5;
  pPVar6 = PCB;
  *(double *)(iVar10 + 0x30) = dVar5 / 10.0;
  *(double *)(iVar10 + 0x28) = dVar5 / 100.0;
  *(double *)(iVar10 + 0x18) = (double)pPVar6->MaxHeight;
  if (emit_changed != 0) {
    uVar8 = gtk_object_get_type();
    uVar8 = g_type_check_instance_cast(iVar10,uVar8);
    gtk_signal_emit_by_name(uVar8,"changed");
  }
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_port_drawing_area_configure_event_cb
                   (GtkWidget *widget,GdkEventConfigure *ev,GHidPort *out)

{
  gint gVar1;
  GdkPixmap *pGVar2;
  GdkColormap *pGVar3;
  GdkGC *pGVar4;
  int iVar5;
  gint gVar6;
  GHidPort *pGVar7;
  bool bVar8;
  
  HideCrosshair('\x01');
  pGVar7 = gport;
  gVar1 = ev->width;
  pGVar2 = gport->pixmap;
  gport->width = gVar1;
  gVar6 = ev->height;
  pGVar7->height = gVar6;
  if (pGVar2 != (GdkPixmap *)0x0) {
    g_object_unref(pGVar2);
    gVar6 = gport->height;
    gVar1 = gport->width;
    pGVar7 = gport;
  }
  pGVar2 = (GdkPixmap *)gdk_pixmap_new(widget->window,gVar1,gVar6,0xffffffff);
  bVar8 = ghid_port_drawing_area_configure_event_cb::first_time_done == 0;
  pGVar7->pixmap = pGVar2;
  pGVar7 = gport;
  gport->drawable = gport->pixmap;
  if (bVar8) {
    pGVar3 = (GdkColormap *)gtk_widget_get_colormap(pGVar7->top_window);
    pGVar7->colormap = pGVar3;
    pGVar7 = gport;
    pGVar4 = (GdkGC *)gdk_gc_new(gport->drawable);
    pGVar7->bg_gc = pGVar4;
    iVar5 = gdk_color_parse(Settings.BackgroundColor,&gport->bg_color);
    if (iVar5 == 0) {
      gdk_color_white(gport->colormap,&gport->bg_color);
    }
    else {
      gdk_color_alloc(gport->colormap,&gport->bg_color);
    }
    gdk_gc_set_foreground(gport->bg_gc,&gport->bg_color);
    pGVar7 = gport;
    pGVar4 = (GdkGC *)gdk_gc_new(gport->drawable);
    pGVar7->offlimits_gc = pGVar4;
    iVar5 = gdk_color_parse(Settings.OffLimitColor,&gport->offlimits_color);
    if (iVar5 == 0) {
      gdk_color_white(gport->colormap,&gport->offlimits_color);
    }
    else {
      gdk_color_alloc(gport->colormap,&gport->offlimits_color);
    }
    gdk_gc_set_foreground(gport->offlimits_gc,&gport->offlimits_color);
    ghid_port_drawing_area_configure_event_cb::first_time_done = 1;
    PCBChanged(0,(char **)0x0,0,0);
    pGVar7 = gport;
  }
  if (pGVar7->mask != (GdkPixmap *)0x0) {
    g_object_unref(pGVar7->mask);
    pGVar7 = gport;
    pGVar2 = (GdkPixmap *)gdk_pixmap_new(0,gport->width,gport->height,1);
    pGVar7->mask = pGVar2;
  }
  ghid_port_ranges_scale(0);
  ghid_invalidate_all();
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Removing unreachable block (ram,0x081027f6)
// WARNING: Unknown calling convention

void ghid_port_ranges_zoom(gdouble zoom)

{
  gint *pgVar1;
  gint *pgVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  double dVar8;
  GhidGui *pGVar9;
  GHidPort *pGVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  gint y0;
  int iVar13;
  gint x0;
  int iVar14;
  gdouble xtmp;
  gdouble ytmp;
  
  dVar8 = (double)PCB->MaxWidth / (double)gport->width;
  dVar7 = (double)PCB->MaxHeight / (double)gport->height;
  if ((zoom <= dVar8) || (zoom <= dVar7)) {
    if ((zoom == 0.0) && (zoom = dVar8, dVar8 <= dVar7)) {
      zoom = dVar7;
    }
  }
  else {
    zoom = dVar8;
    if (dVar8 <= dVar7) {
      zoom = dVar7;
    }
  }
  iVar13 = gport->view_x;
  iVar4 = gport->view_x0;
  iVar5 = gport->view_y;
  iVar14 = gport->view_width;
  iVar6 = gport->view_y0;
  iVar3 = gport->view_height;
  gport->zoom = zoom;
  pixel_slop = (int)ROUND(zoom);
  ghid_port_ranges_scale(0);
  pGVar10 = gport;
  iVar14 = (int)ROUND((double)gport->view_x -
                      ((double)(iVar13 - iVar4) / (double)iVar14) * (double)gport->view_width);
  pgVar2 = &gport->view_y;
  pgVar1 = &gport->view_height;
  if (iVar14 < 0) {
    iVar14 = 0;
  }
  gport->view_x0 = iVar14;
  pGVar9 = ghidgui;
  iVar3 = (int)ROUND((double)*pgVar2 - ((double)(iVar5 - iVar6) / (double)iVar3) * (double)*pgVar1);
  iVar13 = 0;
  if (-1 < iVar3) {
    iVar13 = iVar3;
  }
  pGVar10->view_y0 = iVar13;
  pGVar9->adjustment_changed_holdoff = 1;
  uVar11 = gtk_range_get_type();
  uVar12 = g_type_check_instance_cast(pGVar9->h_range,uVar11);
  gtk_range_set_value(uVar12,(double)iVar14);
  iVar14 = gport->view_y0;
  uVar11 = g_type_check_instance_cast(ghidgui->v_range,uVar11);
  gtk_range_set_value(uVar11,(double)iVar14);
  ghidgui->adjustment_changed_holdoff = 0;
  ghid_port_ranges_changed();
  return;
}



// WARNING: Unknown calling convention

void ghid_pinout_preview_get_natural_size(GhidPinoutPreview *pinout,int *width,int *height)

{
  *width = pinout->w_pixels;
  *height = pinout->h_pixels;
  return;
}



// WARNING: Unknown calling convention

GType ghid_pinout_preview_get_type(void)

{
  undefined4 uVar1;
  
  if (ghid_pinout_preview_get_type::ghid_pinout_preview_type != 0) {
    return ghid_pinout_preview_get_type::ghid_pinout_preview_type;
  }
  uVar1 = gtk_drawing_area_get_type();
  ghid_pinout_preview_get_type::ghid_pinout_preview_type =
       g_type_register_static
                 (uVar1,"GhidPinoutPreview",
                  &ghid_pinout_preview_get_type::lexical_block_0::ghid_pinout_preview_info,0);
  return ghid_pinout_preview_get_type::ghid_pinout_preview_type;
}



// WARNING: Unknown calling convention

GtkWidget * ghid_pinout_preview_new(ElementType *element)

{
  GType GVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  
  GVar1 = ghid_pinout_preview_get_type();
  uVar2 = g_object_new(GVar1,"element-data",element,0);
  uVar3 = gtk_widget_get_type();
  pGVar4 = (GtkWidget *)g_type_check_instance_cast(uVar2,uVar3);
  return pGVar4;
}



// WARNING: Unknown calling convention

void ghid_pinout_preview_class_init(GhidPinoutPreviewClass *klass)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  uVar2 = gtk_widget_get_type();
  iVar3 = g_type_check_class_cast(klass,uVar2);
  *(code **)(iVar1 + 0x18) = ghid_pinout_preview_finalize;
  *(code **)(iVar1 + 0xc) = ghid_pinout_preview_set_property;
  *(code **)(iVar1 + 0x10) = ghid_pinout_preview_get_property;
  *(code **)(iVar3 + 200) = ghid_pinout_preview_expose;
  ghid_pinout_preview_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  uVar2 = g_param_spec_pointer("element-data",&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,1,uVar2);
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_pinout_preview_expose(GtkWidget *widget,GdkEventExpose *event)

{
  int iVar1;
  int iVar2;
  gdouble gVar3;
  gint gVar4;
  gint gVar5;
  gint gVar6;
  gint gVar7;
  gint gVar8;
  gint gVar9;
  GdkDrawable *pGVar10;
  int iVar11;
  int iVar12;
  GdkDrawable *pGVar13;
  double dVar14;
  double dVar15;
  GHidPort *pGVar16;
  GType GVar17;
  int iVar18;
  GhidPinoutPreview *pinout;
  double yz;
  double xz;
  int local_24;
  int local_20 [4];
  
  GVar17 = ghid_pinout_preview_get_type();
  iVar18 = g_type_check_instance_cast(widget,GVar17);
  gVar4 = gport->width;
  gVar5 = gport->height;
  gVar3 = gport->zoom;
  gVar6 = gport->view_x0;
  gVar7 = gport->view_y0;
  gVar8 = gport->view_width;
  gVar9 = gport->view_height;
  pGVar10 = gport->drawable;
  gdk_window_get_geometry(widget->window,0,0,local_20,&local_24,0);
  pGVar16 = gport;
  iVar11 = *(int *)(iVar18 + 0x174);
  iVar12 = *(int *)(iVar18 + 0x178);
  dVar15 = (double)iVar11 / (double)local_20[0];
  dVar14 = (double)iVar12 / (double)local_24;
  if (dVar14 < dVar15) {
    gport->zoom = dVar15;
  }
  else {
    gport->zoom = dVar14;
  }
  pGVar13 = widget->window;
  pGVar16->width = local_20[0];
  pGVar16->height = local_24;
  pGVar16->drawable = pGVar13;
  iVar1 = (int)ROUND((double)local_20[0] * pGVar16->zoom);
  pGVar16->view_width = iVar1;
  iVar2 = (int)ROUND((double)local_24 * pGVar16->zoom);
  pGVar16->view_x0 = (iVar11 - iVar1) / 2;
  pGVar16->view_height = iVar2;
  pGVar16->view_y0 = (iVar12 - iVar2) / 2;
  gdk_draw_rectangle(pGVar13,pGVar16->bg_gc,1,0,0,local_20[0],local_24);
  hid_expose_callback((HID *)&ghid_hid,(BoxType *)0x0,(void *)(iVar18 + 0x40));
  pGVar16 = gport;
  gport->drawable = pGVar10;
  pGVar16->height = gVar5;
  pGVar16->view_x0 = gVar6;
  pGVar16->width = gVar4;
  pGVar16->zoom = gVar3;
  pGVar16->view_width = gVar8;
  pGVar16->view_height = gVar9;
  pGVar16->view_y0 = gVar7;
  return 0;
}



// WARNING: Unknown calling convention

void ghid_pinout_preview_get_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = g_type_name(((object->g_type_instance).g_class)->g_type);
  uVar2 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
  g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
        "../../src/hid/gtk/gui-pinout-preview.c:293","property",property_id,pspec->name,uVar2,uVar1)
  ;
  return;
}



// WARNING: Unknown calling convention

gboolean pinout_zoom_fit(GhidPinoutPreview *pinout,gint zoom)

{
  int iVar1;
  int iVar2;
  float fVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  
  pinout->zoom = (float)zoom;
  dVar7 = exp((double)((float)zoom * 0.3465736));
  iVar5 = (pinout->element).BoundingBox.X2;
  iVar1 = (pinout->element).BoundingBox.X1;
  pinout->x_max = Settings.PinoutOffsetX + iVar5;
  iVar2 = (pinout->element).BoundingBox.Y2;
  fVar3 = 1.0 / ((float)dVar7 * 100.0);
  iVar6 = (pinout->element).BoundingBox.Y1;
  pinout->y_max = Settings.PinoutOffsetY + iVar2;
  pinout->scale = fVar3;
  iVar5 = (int)ROUND((float)(iVar5 - iVar1) * fVar3);
  pinout->w_pixels = iVar5;
  iVar1 = (int)ROUND((float)(iVar2 - iVar6) * fVar3);
  pinout->h_pixels = iVar1;
  iVar2 = Output.Width * 3;
  iVar6 = iVar2 + 3;
  if (-1 < iVar2) {
    iVar6 = iVar2;
  }
  uVar4 = 0;
  if (iVar5 <= iVar6 >> 2) {
    iVar5 = Output.Height * 3;
    if (iVar5 < 0) {
      iVar5 = iVar5 + 3;
    }
    uVar4 = (uint)(iVar1 <= iVar5 >> 2);
  }
  return uVar4;
}



// WARNING: Unknown calling convention

void pinout_set_data(GhidPinoutPreview *pinout,ElementType *element)

{
  FlagType *pFVar1;
  uint uVar2;
  Cardinal CVar3;
  PinTypePtr paVar4;
  PadTypePtr paVar5;
  gboolean gVar6;
  Cardinal n_2;
  int iVar7;
  Cardinal n_3;
  Cardinal sn;
  Cardinal sn_1;
  uint uVar8;
  Cardinal n;
  Cardinal n_1;
  BDimension *pBVar9;
  
  if (element != (ElementType *)0x0) {
    CopyElementLowLevel((DataTypePtr)0x0,(ElementTypePtr)&pinout->element,(ElementTypePtr)element,
                        '\0',0,0);
    uVar2 = (pinout->element).PinN;
    if (uVar2 != 0) {
      paVar4 = (pinout->element).Pin;
      pFVar1 = &paVar4->Flags;
      pFVar1->f = pFVar1->f | 0x20;
      for (uVar8 = 1; uVar8 < uVar2; uVar8 = uVar8 + 1) {
        paVar4[1].Flags.f = paVar4[1].Flags.f | 0x20;
        paVar4 = paVar4 + 1;
      }
    }
    uVar2 = (pinout->element).PadN;
    if (uVar2 != 0) {
      paVar5 = (pinout->element).Pad;
      pFVar1 = &paVar5->Flags;
      pFVar1->f = pFVar1->f | 0x20;
      for (uVar8 = 1; uVar8 < uVar2; uVar8 = uVar8 + 1) {
        paVar5[1].Flags.f = paVar5[1].Flags.f | 0x20;
        paVar5 = paVar5 + 1;
      }
    }
    MoveElementLowLevel((DataTypePtr)0x0,(ElementTypePtr)&pinout->element,
                        Settings.PinoutOffsetX - (pinout->element).BoundingBox.X1,
                        Settings.PinoutOffsetY - (pinout->element).BoundingBox.Y1);
    gVar6 = pinout_zoom_fit(pinout,2);
    if (gVar6 == 0) {
      pinout_zoom_fit(pinout,3);
    }
    CVar3 = (pinout->element).LineN;
    iVar7 = CVar3 - 1;
    if (iVar7 != -1) {
      pBVar9 = &(pinout->element).Line[CVar3 - 1].Thickness;
      do {
        iVar7 = iVar7 + -1;
        *pBVar9 = 0;
        pBVar9 = pBVar9 + -0x16;
      } while (iVar7 != -1);
    }
    CVar3 = (pinout->element).ArcN;
    iVar7 = CVar3 - 1;
    if (iVar7 != -1) {
      pBVar9 = &(pinout->element).Arc[CVar3 - 1].Thickness;
      do {
        iVar7 = iVar7 + -1;
        *pBVar9 = 1;
        pBVar9 = pBVar9 + -0x11;
      } while (iVar7 != -1);
    }
    return;
  }
  FreeElementMemory((ElementTypePtr)&pinout->element);
  pinout->w_pixels = 0;
  pinout->h_pixels = 0;
  return;
}



// WARNING: Unknown calling convention

void ghid_pinout_preview_set_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  GType GVar1;
  GhidPinoutPreview *pinout;
  undefined4 uVar2;
  undefined4 uVar3;
  ElementType *element;
  undefined4 uVar4;
  int iVar5;
  
  GVar1 = ghid_pinout_preview_get_type();
  pinout = (GhidPinoutPreview *)g_type_check_instance_cast(object,GVar1);
  if (property_id == 1) {
    element = (ElementType *)g_value_get_pointer(value);
    pinout_set_data(pinout,element);
    uVar2 = gtk_object_get_type();
    uVar3 = gtk_widget_get_type();
    uVar4 = g_type_check_instance_cast(pinout,uVar3);
    iVar5 = g_type_check_instance_cast(uVar4,uVar2);
    if ((*(byte *)(iVar5 + 0xc) & 0x40) != 0) {
      g_type_check_instance_cast(pinout,uVar3);
      gdk_window_invalidate_rect();
      return;
    }
  }
  else {
    uVar2 = g_type_name(((object->g_type_instance).g_class)->g_type);
    uVar3 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
    g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
          "../../src/hid/gtk/gui-pinout-preview.c:268","property",property_id,pspec->name,uVar3,
          uVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_pinout_preview_finalize(GObject *object)

{
  GType GVar1;
  GhidPinoutPreview *pinout;
  int iVar2;
  
  GVar1 = ghid_pinout_preview_get_type();
  pinout = (GhidPinoutPreview *)g_type_check_instance_cast(object,GVar1);
  pinout_set_data(pinout,(ElementType *)0x0);
  iVar2 = g_type_check_class_cast(ghid_pinout_preview_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x08103102. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



// WARNING: Unknown calling convention

void ghid_pinout_window_show(GHidPort *out,ElementType *element)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  GtkWidget *pGVar8;
  GType GVar9;
  GhidPinoutPreview *pinout;
  char *pcVar10;
  char *pcVar11;
  char *pcVar12;
  GtkWidget *top_window;
  GtkWidget *preview;
  GtkWidget *hbox;
  GtkWidget *viewport;
  GtkWidget *button;
  int local_24;
  int local_20 [4];
  
  if (element != (ElementType *)0x0) {
    pcVar11 = element->Name[2].TextString;
    if ((pcVar11 == (char *)0x0) || (*pcVar11 == '\0')) {
      pcVar12 = element->Name[1].TextString;
      pcVar11 = "(unknown)";
    }
    else {
      pcVar12 = element->Name[1].TextString;
    }
    if ((pcVar12 == (char *)0x0) || (*pcVar12 == '\0')) {
      pcVar12 = "(unknown)";
    }
    pcVar10 = element->Name[0].TextString;
    if ((pcVar10 == (char *)0x0) || (*pcVar10 == '\0')) {
      pcVar10 = "(unknown)";
    }
    uVar1 = g_strdup_printf("%s [%s,%s]",pcVar10,pcVar12,pcVar11);
    uVar2 = gtk_window_new(0);
    uVar3 = gtk_window_get_type();
    uVar4 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_window_set_title(uVar4,uVar1);
    g_free(uVar1);
    uVar1 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_window_set_wmclass(uVar1,"PCB_Pinout",&DAT_08154932);
    uVar1 = gtk_container_get_type();
    uVar4 = g_type_check_instance_cast(uVar2,uVar1);
    gtk_container_set_border_width(uVar4,4);
    uVar4 = gtk_vbox_new(0,0);
    uVar5 = g_type_check_instance_cast(uVar2,uVar1);
    gtk_container_add(uVar5,uVar4);
    uVar5 = gtk_viewport_new(0,0);
    uVar6 = gtk_viewport_get_type();
    uVar6 = g_type_check_instance_cast(uVar5,uVar6);
    gtk_viewport_set_shadow_type(uVar6,1);
    uVar6 = gtk_box_get_type();
    uVar7 = g_type_check_instance_cast(uVar4,uVar6);
    gtk_box_pack_start(uVar7,uVar5,1,1,0);
    pGVar8 = ghid_pinout_preview_new(element);
    uVar1 = g_type_check_instance_cast(uVar5,uVar1);
    gtk_container_add(uVar1,pGVar8);
    GVar9 = ghid_pinout_preview_get_type();
    pinout = (GhidPinoutPreview *)g_type_check_instance_cast(pGVar8,GVar9);
    ghid_pinout_preview_get_natural_size(pinout,local_20,&local_24);
    uVar1 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_window_set_default_size(uVar1,local_20[0] + 0x32,local_24 + 0x32);
    uVar1 = gtk_hbutton_box_new();
    uVar3 = gtk_button_box_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_button_box_set_layout(uVar3,4);
    uVar3 = g_type_check_instance_cast(uVar4,uVar6);
    gtk_box_pack_start(uVar3,uVar1,0,0,0);
    uVar3 = gtk_button_new_from_stock("gtk-close");
    uVar4 = g_type_check_instance_cast(uVar3,0x50);
    g_signal_connect_data(uVar4,"clicked",pinout_close_cb,uVar2,0,0);
    uVar1 = g_type_check_instance_cast(uVar1,uVar6);
    gtk_box_pack_start(uVar1,uVar3,1,1,0);
    gtk_widget_realize(uVar2);
    if (Settings.AutoPlace != '\0') {
      gtk_widget_set_uposition(uVar2,10,10);
    }
    gtk_widget_show_all(uVar2);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void pinout_close_cb(GtkWidget *widget,GtkWidget *top_window)

{
  gtk_widget_destroy();
  return;
}



// WARNING: Unknown calling convention

GdkPixmap * ghid_render_pixmap(int cx,int cy,double zoom,int width,int height,int depth)

{
  gdouble gVar1;
  double dVar2;
  GdkDrawable *pGVar3;
  gint gVar4;
  gint gVar5;
  gint gVar6;
  gint gVar7;
  gint gVar8;
  gint gVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  GHidPort *pGVar14;
  GdkDrawable *pGVar15;
  int iVar16;
  int rv_1;
  int rv;
  int iVar17;
  int iVar18;
  int local_48;
  int local_44;
  int local_3c;
  BoxType region;
  
  pGVar3 = gport->drawable;
  gVar4 = gport->height;
  gVar5 = gport->view_x0;
  gVar1 = gport->zoom;
  gVar6 = gport->width;
  gVar7 = gport->view_width;
  gVar8 = gport->view_y0;
  gVar9 = gport->view_height;
  pGVar15 = (GdkDrawable *)gdk_pixmap_new(0,width,height,depth);
  pGVar14 = gport;
  gport->zoom = zoom;
  pGVar14->drawable = pGVar15;
  iVar16 = ghid_flip_x;
  pGVar14->width = width;
  pGVar14->height = height;
  pGVar14->view_width = (int)ROUND((double)width * zoom);
  pGVar14->view_height = (int)ROUND((double)height * zoom);
  iVar17 = ghid_flip_y;
  if (iVar16 != 0) {
    cx = PCB->MaxWidth - cx;
  }
  pGVar14->view_x0 = cx - (int)ROUND((double)height * zoom) / 2;
  if (iVar17 != 0) {
    cy = PCB->MaxHeight - cy;
  }
  pGVar14->view_y0 = cy - (int)ROUND((double)width * zoom) / 2;
  gdk_draw_rectangle(pGVar15,pGVar14->bg_gc,1,0,0,width,height);
  dVar2 = gport->zoom;
  dVar13 = (double)gport->view_x0;
  dVar12 = dVar2 * 0.0 + dVar13;
  region.X2 = (LocationType)ROUND(dVar12);
  if (ghid_flip_x == 0) {
    dVar13 = (double)(gport->width + 1) * dVar2 + dVar13;
    iVar16 = (int)ROUND(dVar13);
    iVar17 = region.X2;
    iVar18 = iVar16;
  }
  else {
    dVar13 = (double)(gport->width + 1) * dVar2 + dVar13;
    iVar16 = (int)ROUND((double)PCB->MaxWidth - dVar13);
    iVar17 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    iVar18 = (int)ROUND(dVar13);
  }
  if (iVar17 < iVar16) {
    local_48 = region.X2;
    if (ghid_flip_x != 0) {
      local_48 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    }
  }
  else {
    local_48 = iVar18;
    if (ghid_flip_x != 0) {
      local_48 = (int)ROUND((double)PCB->MaxWidth - dVar13);
    }
  }
  dVar10 = (double)gport->view_y0;
  dVar11 = dVar2 * 0.0 + dVar10;
  region.Y2 = (LocationType)ROUND(dVar11);
  if (ghid_flip_y == 0) {
    dVar10 = (double)(gport->height + 1) * dVar2 + dVar10;
    iVar16 = (int)ROUND(dVar10);
    iVar17 = region.Y2;
    local_3c = iVar16;
  }
  else {
    dVar10 = (double)(gport->height + 1) * dVar2 + dVar10;
    iVar16 = (int)ROUND((double)PCB->MaxHeight - dVar10);
    iVar17 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    local_3c = (int)ROUND(dVar10);
  }
  if (iVar17 < iVar16) {
    region.Y1 = region.Y2;
    if (ghid_flip_y != 0) {
      region.Y1 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    }
  }
  else {
    region.Y1 = local_3c;
    if (ghid_flip_y != 0) {
      region.Y1 = (LocationType)ROUND((double)PCB->MaxHeight - dVar10);
    }
  }
  iVar16 = iVar18;
  local_44 = region.X2;
  if (ghid_flip_x != 0) {
    local_44 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    iVar16 = (int)ROUND((double)PCB->MaxWidth - dVar13);
  }
  if (iVar16 < local_44) {
    if (ghid_flip_x != 0) {
      region.X2 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    }
  }
  else {
    region.X2 = iVar18;
    if (ghid_flip_x != 0) {
      region.X2 = (int)ROUND((double)PCB->MaxWidth - dVar13);
    }
  }
  iVar17 = local_3c;
  iVar16 = region.Y2;
  if (ghid_flip_y != 0) {
    iVar16 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    iVar17 = (int)ROUND((double)PCB->MaxHeight - dVar10);
  }
  if (iVar17 < iVar16) {
    if (ghid_flip_y != 0) {
      region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    }
  }
  else {
    region.Y2 = local_3c;
    if (ghid_flip_y != 0) {
      region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar10);
    }
  }
  region.X1 = local_48;
  hid_expose_callback((HID *)&ghid_hid,&region,(void *)0x0);
  pGVar14 = gport;
  gport->drawable = pGVar3;
  pGVar14->width = gVar6;
  pGVar14->height = gVar4;
  pGVar14->view_x0 = gVar5;
  pGVar14->zoom = gVar1;
  pGVar14->view_y0 = gVar8;
  pGVar14->view_width = gVar7;
  pGVar14->view_height = gVar9;
  return pGVar15;
}



// WARNING: Unknown calling convention

gint top_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,GHidPort *port)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  GhidGui *pGVar5;
  gboolean new_w;
  
  pGVar5 = ghidgui;
  iVar1 = (widget->allocation).width;
  iVar2 = ghidgui->top_window_width;
  iVar3 = (widget->allocation).height;
  iVar4 = ghidgui->top_window_height;
  ghidgui->top_window_width = iVar1;
  pGVar5->top_window_height = iVar3;
  if ((iVar4 != iVar3) || (iVar2 != iVar1)) {
    pGVar5->config_modified = 1;
  }
  return 0;
}



// WARNING: Unknown calling convention

void absolute_label_size_req_cb(GtkWidget *widget,GtkRequisition *req,gpointer data)

{
  if (req->width <= absolute_label_size_req_cb::w) {
    req->width = absolute_label_size_req_cb::w;
    return;
  }
  absolute_label_size_req_cb::w = req->width;
  return;
}



// WARNING: Unknown calling convention

void relative_label_size_req_cb(GtkWidget *widget,GtkRequisition *req,gpointer data)

{
  if (req->width <= relative_label_size_req_cb::w) {
    req->width = relative_label_size_req_cb::w;
    return;
  }
  relative_label_size_req_cb::w = req->width;
  return;
}



// WARNING: Unknown calling convention

int EditLayerGroups(int argc,char **argv,int x,int y)

{
  if (argc == 0) {
    hid_actionl("DoWindows","Preferences",0);
    return 0;
  }
  Message("Syntax error.  Usage:\n%s\n","EditLayerGroups()\n");
  return 1;
}



// WARNING: Unknown calling convention

int AdjustStyle(int argc,char **argv,int x,int y)

{
  RouteStyleType *rst;
  
  if (argc < 2) {
    if (route_style_index < 4) {
      ghid_route_style_dialog(route_style_index,(RouteStyleType *)0x0);
    }
    else {
      ghid_route_style_dialog(route_style_index,&route_style_button[route_style_index].route_style);
    }
    return 0;
  }
  Message("Syntax error.  Usage:\n%s\n","AdjustStyle()\n");
  return 1;
}



// WARNING: Unknown calling convention

void ghid_mode_buttons_update(void)

{
  undefined4 uVar1;
  ModeButton *pMVar2;
  
  pMVar2 = mode_buttons;
  do {
    if (pMVar2->mode == Settings.Mode) {
      uVar1 = gtk_toggle_button_get_type();
      uVar1 = g_type_check_instance_cast(pMVar2->button,uVar1);
      gtk_toggle_button_set_active(uVar1,1);
      return;
    }
    pMVar2 = pMVar2 + 1;
  } while (pMVar2 != (ModeButton *)&DAT_08169958);
  return;
}



// WARNING: Unknown calling convention

void ghid_route_style_button_set_active(gint n)

{
  undefined4 uVar1;
  
  if ((uint)n < 7) {
    uVar1 = gtk_toggle_button_get_type();
    uVar1 = g_type_check_instance_cast(route_style_button[n].button,uVar1);
    gtk_toggle_button_set_active(uVar1,1);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_layer_button_select(gint layer)

{
  undefined4 uVar1;
  
  if (layer != layer_select_button_index) {
    uVar1 = gtk_toggle_button_get_type();
    uVar1 = g_type_check_instance_cast(layer_buttons[layer].radio_select_button,uVar1);
    gtk_toggle_button_set_active(uVar1,1);
    layer_select_button_index = layer;
  }
  return;
}



// WARNING: Unknown calling convention

int ToggleView(int argc,char **argv,int x,int y)

{
  byte *__nptr;
  ushort **ppuVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  long lVar6;
  int iVar7;
  int l;
  byte *pbVar8;
  int i;
  gboolean active;
  byte *pbVar9;
  DataTypePtr paVar10;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  byte bVar14;
  
  bVar14 = 0;
  if (ToggleView::in_toggle_view != 0) {
    __fprintf_chk(stderr,1,
                  "ToggleView() called on top of another ToggleView()\nPlease report this and how it happened\n"
                 );
    return 0;
  }
  ToggleView::in_toggle_view = 1;
  if (argc == 0) {
LAB_08103e08:
    ToggleView::in_toggle_view = 0;
    Message("Syntax error.  Usage:\n%s\n",
            "ToggleView(1..MAXLAYER)\nToggleView(layername)\nToggleView(Silk|Rats|Pins|Vias|Mask|BackSide)"
           );
    return 1;
  }
  ppuVar1 = __ctype_b_loc();
  __nptr = (byte *)*argv;
  bVar11 = false;
  bVar13 = (*(byte *)((int)*ppuVar1 + (char)*__nptr * 2 + 1) & 8) == 0;
  if (bVar13) {
    iVar7 = 5;
    pbVar8 = __nptr;
    pbVar9 = &DAT_08155606;
    do {
      if (iVar7 == 0) break;
      iVar7 = iVar7 + -1;
      bVar11 = *pbVar8 < *pbVar9;
      bVar13 = *pbVar8 == *pbVar9;
      pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
      pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
    } while (bVar13);
    iVar7 = 0x10;
    bVar12 = (!bVar11 && !bVar13) < bVar11;
    bVar11 = (!bVar11 && !bVar13) == bVar11;
    if (!bVar11) {
      iVar7 = 5;
      pbVar8 = __nptr;
      pbVar9 = (byte *)0x813a186;
      do {
        if (iVar7 == 0) break;
        iVar7 = iVar7 + -1;
        bVar12 = *pbVar8 < *pbVar9;
        bVar11 = *pbVar8 == *pbVar9;
        pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
        pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
      } while (bVar11);
      iVar7 = 0x11;
      bVar13 = (!bVar12 && !bVar11) < bVar12;
      bVar11 = (!bVar12 && !bVar11) == bVar12;
      if (!bVar11) {
        iVar7 = 5;
        pbVar8 = __nptr;
        pbVar9 = (byte *)0x8139ea4;
        do {
          if (iVar7 == 0) break;
          iVar7 = iVar7 + -1;
          bVar13 = *pbVar8 < *pbVar9;
          bVar11 = *pbVar8 == *pbVar9;
          pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
          pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
        } while (bVar11);
        iVar7 = 0x12;
        bVar12 = (!bVar13 && !bVar11) < bVar13;
        bVar11 = (!bVar13 && !bVar11) == bVar13;
        if (!bVar11) {
          iVar7 = 5;
          pbVar8 = __nptr;
          pbVar9 = (byte *)0x813a5e3;
          do {
            if (iVar7 == 0) break;
            iVar7 = iVar7 + -1;
            bVar12 = *pbVar8 < *pbVar9;
            bVar11 = *pbVar8 == *pbVar9;
            pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
            pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
          } while (bVar11);
          iVar7 = 0x13;
          bVar13 = (!bVar12 && !bVar11) < bVar12;
          bVar11 = (!bVar12 && !bVar11) == bVar12;
          if (!bVar11) {
            iVar7 = 5;
            pbVar8 = __nptr;
            pbVar9 = (byte *)0x813a651;
            do {
              if (iVar7 == 0) break;
              iVar7 = iVar7 + -1;
              bVar13 = *pbVar8 < *pbVar9;
              bVar11 = *pbVar8 == *pbVar9;
              pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
              pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
            } while (bVar11);
            iVar7 = 0x15;
            bVar12 = (!bVar13 && !bVar11) < bVar13;
            bVar11 = (!bVar13 && !bVar11) == bVar13;
            if (!bVar11) {
              iVar7 = 9;
              pbVar8 = __nptr;
              pbVar9 = (byte *)"BackSide";
              do {
                if (iVar7 == 0) break;
                iVar7 = iVar7 + -1;
                bVar12 = *pbVar8 < *pbVar9;
                bVar11 = *pbVar8 == *pbVar9;
                pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
                pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
              } while (bVar11);
              iVar7 = 0x14;
              if ((!bVar12 && !bVar11) != bVar12) {
                paVar10 = PCB->Data;
                iVar2 = paVar10->LayerN + 1;
                if (-1 < iVar2) {
                  iVar7 = 0;
                  do {
                    iVar3 = strcmp((char *)__nptr,paVar10->Layer[0].Name);
                    if (iVar3 == 0) goto LAB_08103d40;
                    iVar7 = iVar7 + 1;
                    paVar10 = (DataTypePtr)&paVar10->Layer[0].ArcN;
                  } while (iVar7 <= iVar2);
                }
                goto LAB_08103e08;
              }
            }
          }
        }
      }
    }
  }
  else {
    lVar6 = strtol((char *)__nptr,(char **)0x0,10);
    iVar7 = lVar6 + -1;
  }
LAB_08103d40:
  __printf_chk(1,"ToggleView():  l = %d\n",iVar7);
  uVar4 = gtk_toggle_button_get_type();
  uVar5 = g_type_check_instance_cast(layer_buttons[iVar7].layer_enable_button,uVar4);
  iVar2 = gtk_toggle_button_get_active(uVar5);
  uVar4 = g_type_check_instance_cast(layer_buttons[iVar7].layer_enable_button,uVar4);
  gtk_toggle_button_set_active(uVar4,iVar2 != 1);
  ToggleView::in_toggle_view = 0;
  return 0;
}



// WARNING: Unknown calling convention

int SelectLayer(int argc,char **argv,int x,int y)

{
  char *__s1;
  int iVar1;
  undefined4 uVar2;
  long lVar3;
  int iVar4;
  int newl;
  
  if (argc != 0) {
    iVar4 = 0x10;
    __s1 = *argv;
    iVar1 = strcasecmp(__s1,"silk");
    if (iVar1 != 0) {
      iVar4 = 0x11;
      iVar1 = strcasecmp(__s1,"rats");
      if (iVar1 != 0) {
        lVar3 = strtol(__s1,(char **)0x0,10);
        iVar4 = lVar3 + -1;
      }
    }
    uVar2 = gtk_toggle_button_get_type();
    uVar2 = g_type_check_instance_cast(layer_buttons[iVar4].radio_select_button,uVar2);
    gtk_toggle_button_set_active(uVar2,1);
    return 0;
  }
  Message("Syntax error.  Usage:\n%s\n","SelectLayer(1..MAXLAYER|Silk|Rats)");
  return 1;
}



// WARNING: Unknown calling convention

void register_ghid_menu_action_list(void)

{
  hid_register_actions(ghid_menu_action_list,2);
  return;
}



// WARNING: Unknown calling convention

void register_gtk_topwindow_action_list(void)

{
  hid_register_actions(gtk_topwindow_action_list,3);
  return;
}



// WARNING: Unknown calling convention

void register_pcbmenu_attr(void)

{
  hid_register_attributes(pcbmenu_attr,1);
  return;
}



// WARNING: Unknown calling convention

void register_ghid_attribute_list(void)

{
  hid_register_attributes(ghid_attribute_list,2);
  return;
}



// WARNING: Unknown calling convention

void ghid_route_style_set_temp_style(RouteStyleType *rst,gint which)

{
  char *pcVar1;
  int iVar2;
  gint index;
  int iVar3;
  undefined4 uVar4;
  gchar *tmp;
  RouteStyleButton *rsb;
  bool bVar5;
  
  if ((uint)which < 2) {
    iVar3 = which + 4;
    gtk_widget_show(route_style_button[iVar3].button);
    pcVar1 = route_style_button[iVar3].route_style.Name;
    route_style_button[iVar3].shown = 1;
    bVar5 = route_style_index != iVar3;
    route_style_button[iVar3].route_style.Thick = rst->Thick;
    route_style_button[iVar3].route_style.Diameter = rst->Diameter;
    route_style_button[iVar3].route_style.Hole = rst->Hole;
    route_style_button[iVar3].route_style.Keepaway = rst->Keepaway;
    route_style_button[iVar3].route_style.Name = rst->Name;
    iVar2 = rst->index;
    route_style_button[iVar3].route_style.Name = pcVar1;
    route_style_button[iVar3].route_style.index = iVar2;
    if (bVar5) {
      route_style_index = iVar3;
      uVar4 = gtk_toggle_button_get_type();
      g_type_check_instance_cast(route_style_button[iVar3].button,uVar4);
      gtk_toggle_button_set_active();
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_show_layer_buttons(void)

{
  LayerButtonSet *pLVar1;
  int *piVar2;
  int iVar3;
  gint i;
  GtkWidget **ppGVar4;
  
  ppGVar4 = &layer_buttons[0].layer_enable_button;
  iVar3 = 0;
  do {
    while (piVar2 = &PCB->Data->LayerN, *piVar2 == iVar3 || *piVar2 < iVar3) {
      iVar3 = iVar3 + 1;
      gtk_widget_hide(*ppGVar4);
      pLVar1 = (LayerButtonSet *)(ppGVar4 + -1);
      ppGVar4 = ppGVar4 + 6;
      gtk_widget_hide(pLVar1->radio_select_button);
      if (iVar3 == 0x10) {
        return;
      }
    }
    iVar3 = iVar3 + 1;
    gtk_widget_show(*ppGVar4);
    pLVar1 = (LayerButtonSet *)(ppGVar4 + -1);
    ppGVar4 = ppGVar4 + 6;
    gtk_widget_show(pLVar1->radio_select_button);
  } while (iVar3 != 0x10);
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_listener_cb(GIOChannel *source,GIOCondition condition,gpointer data)

{
  int iVar1;
  GIOStatus status;
  undefined4 local_1c;
  gsize term;
  gsize len;
  char *local_10 [3];
  
  local_1c = 0;
  if ((condition & G_IO_HUP) != 0) {
    (*gui->log)("Read end of pipe died!\n");
    return 0;
  }
  if (condition != G_IO_IN) {
    __fprintf_chk(stderr,1,"Unknown condition in ghid_listener_cb\n");
    return 1;
  }
  iVar1 = g_io_channel_read_line(source,local_10,&len,&term,&local_1c);
  if (iVar1 == 1) {
    hid_parse_actions(local_10[0],(_func_int_char_ptr_int_char_ptr_ptr *)0x0);
    g_free(local_10[0]);
    return 1;
  }
  if (iVar1 == 0) {
    (*gui->log)("ERROR status from g_io_channel_read_line\n");
    return 0;
  }
  if (iVar1 == 2) {
    (*gui->log)(
               "Input pipe returned EOF.  The --listen option is \nprobably not running anymore in this session.\n"
               );
    return 0;
  }
  if (iVar1 != 3) {
    __fprintf_chk(stderr,1,"ERROR:  unhandled case in ghid_listener_cb\n");
    return 0;
  }
  (*gui->log)("AGAIN status from g_io_channel_read_line\n");
  return 0;
}



// WARNING: Unknown calling convention

hidGC_conflict1 ghid_make_gc(void)

{
  char *pcVar1;
  hidGC_conflict1 phVar2;
  
  phVar2 = (hidGC_conflict1)g_malloc0(0x20);
  pcVar1 = Settings.BackgroundColor;
  phVar2->me_pointer = &ghid_hid;
  phVar2->colorname = pcVar1;
  return phVar2;
}



// WARNING: Unknown calling convention

void ghid_destroy_gc(hidGC_conflict1 gc)

{
  if (gc->gc != (GdkGC *)0x0) {
    g_object_unref(gc->gc);
  }
  g_free();
  return;
}



// WARNING: Unknown calling convention

void ghid_parse_arguments(int *argc,char ***argv)

{
  gint gVar1;
  gint gVar2;
  GHidPort *pGVar3;
  uint uVar4;
  gint i;
  undefined4 uVar5;
  GdkPixbuf *icon;
  GtkWidget *pGVar6;
  undefined4 uVar7;
  int iVar8;
  byte *pbVar9;
  byte *pbVar10;
  bool bVar11;
  bool bVar12;
  byte bVar13;
  
  bVar13 = 0;
  gtk_set_locale();
  setlocale(1,"POSIX");
  gtk_disable_setlocale();
  gtk_init(argc,argv);
  gport = &ghid_port;
  pixel_slop = 300;
  ghid_port.zoom = 300.0;
  ghid_config_files_read(argc,argv);
  Settings.AutoPlace = '\0';
  if (0 < *argc) {
    bVar11 = false;
    uVar4 = 0;
    bVar12 = true;
    do {
      iVar8 = 0xc;
      pbVar9 = (byte *)(*argv)[uVar4];
      pbVar10 = (byte *)"-auto-place";
      do {
        if (iVar8 == 0) break;
        iVar8 = iVar8 + -1;
        bVar11 = *pbVar9 < *pbVar10;
        bVar12 = *pbVar9 == *pbVar10;
        pbVar9 = pbVar9 + (uint)bVar13 * -2 + 1;
        pbVar10 = pbVar10 + (uint)bVar13 * -2 + 1;
      } while (bVar12);
      if ((!bVar11 && !bVar12) == bVar11) {
        Settings.AutoPlace = '\x01';
      }
      uVar4 = uVar4 + 1;
      bVar11 = (uint)*argc < uVar4;
      bVar12 = *argc == uVar4;
    } while (!bVar12 && (int)uVar4 <= *argc);
  }
  bindtextdomain(&DAT_0815492c,"/usr/share/locale");
  textdomain(&DAT_0815492c);
  bind_textdomain_codeset(&DAT_0815492c,"UTF-8");
  uVar5 = gdk_pixbuf_new_from_xpm_data(icon_bits);
  gtk_window_set_default_icon(uVar5);
  pGVar3 = gport;
  pGVar6 = (GtkWidget *)gtk_window_new(0);
  pGVar3->top_window = pGVar6;
  uVar5 = gtk_window_get_type();
  uVar7 = g_type_check_instance_cast(pGVar6,uVar5);
  gtk_window_set_title(uVar7,&DAT_08154932);
  gVar1 = ghidgui->top_window_height;
  gVar2 = ghidgui->top_window_width;
  uVar5 = g_type_check_instance_cast(pGVar6,uVar5);
  gtk_window_set_default_size(uVar5,gVar2,gVar1);
  if (Settings.AutoPlace != '\0') {
    uVar5 = gtk_widget_get_type();
    uVar5 = g_type_check_instance_cast(pGVar6,uVar5);
    gtk_widget_set_uposition(uVar5,10,10);
  }
  gtk_widget_realize(gport->top_window);
  gtk_widget_show_all(gport->top_window);
  ghidgui->creating = 1;
  return;
}



// WARNING: Unknown calling convention

void layer_enable_button_set_label(GtkWidget *label,gchar *text)

{
  undefined4 uVar1;
  gchar *s;
  
  if (ghidgui->small_label_markup == 0) {
    s = (gchar *)g_strdup(text);
  }
  else {
    s = (gchar *)g_strdup_printf("<small>%s</small>",text);
  }
  uVar1 = gtk_label_get_type();
  uVar1 = g_type_check_instance_cast(label,uVar1);
  gtk_label_set_markup(uVar1,s);
  g_free();
  return;
}



// WARNING: Unknown calling convention

void ghid_interface_input_signals_connect(void)

{
  GtkUIManager *pGVar1;
  undefined4 uVar2;
  
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  button_press_handler =
       g_signal_connect_data(uVar2,"button_press_event",ghid_port_button_press_cb,pGVar1,0,0);
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  button_release_handler =
       g_signal_connect_data(uVar2,"button_release_event",ghid_port_button_release_cb,pGVar1,0,0);
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  key_press_handler =
       g_signal_connect_data(uVar2,"key_press_event",ghid_port_key_press_cb,pGVar1,0,0);
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  key_release_handler =
       g_signal_connect_data(uVar2,"key_release_event",ghid_port_key_release_cb,pGVar1,0,0);
  return;
}



// WARNING: Unknown calling convention

char * ghid_check_unique_accel(char *accelerator)

{
  int iVar1;
  char *pcVar2;
  char **ppcVar3;
  int iVar4;
  int i;
  char *a;
  char *pcVar5;
  int iVar6;
  
  pcVar5 = accelerator;
  if ((accelerator != (char *)0x0) && (*accelerator != '\0')) {
    if (ghid_check_unique_accel::n_list <= ghid_check_unique_accel::amax) {
      ghid_check_unique_accel::n_list = ghid_check_unique_accel::n_list + 0x80;
      ghid_check_unique_accel::accel_list =
           (char **)realloc(ghid_check_unique_accel::accel_list,ghid_check_unique_accel::n_list * 4)
      ;
      if (ghid_check_unique_accel::accel_list == (char **)0x0) {
        __fprintf_chk(stderr,1,"%s():  realloc failed\n","ghid_check_unique_accel");
                    // WARNING: Subroutine does not return
        exit(1);
      }
    }
    ppcVar3 = ghid_check_unique_accel::accel_list;
    iVar6 = ghid_check_unique_accel::amax;
    iVar4 = 0;
    if (0 < ghid_check_unique_accel::amax) {
      do {
        iVar1 = strcmp(ppcVar3[iVar4],accelerator);
        if (iVar1 == 0) {
          Message("Duplicate accelerator found: \"%s\"\nThe second occurance will be dropped\n",
                  accelerator);
          ppcVar3 = ghid_check_unique_accel::accel_list;
          pcVar5 = (char *)0x0;
          iVar6 = ghid_check_unique_accel::amax;
          break;
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < iVar6);
    }
    pcVar2 = (char *)__strdup(accelerator);
    ghid_check_unique_accel::amax = ghid_check_unique_accel::amax + 1;
    ppcVar3[iVar6] = pcVar2;
  }
  return pcVar5;
}



// WARNING: Unknown calling convention

void ghid_ui_info_append(gchar *new)

{
  char cVar1;
  gchar *pgVar2;
  size_t sVar3;
  size_t sVar4;
  gchar *p;
  char *pcVar5;
  size_t n;
  size_t sVar6;
  gchar *np;
  
  sVar6 = new_ui_info_sz;
  pgVar2 = new_ui_info;
  if (new_ui_info_sz == 0) {
    new_ui_info_sz = 0x400;
    pgVar2 = (gchar *)calloc(0x400,1);
    sVar6 = new_ui_info_sz;
  }
  do {
    new_ui_info = pgVar2;
    new_ui_info_sz = sVar6;
    pgVar2 = new_ui_info;
    sVar6 = new_ui_info_sz;
    sVar3 = strlen(new_ui_info);
    sVar4 = strlen(new);
    if (sVar3 + 1 + sVar4 <= sVar6) {
      pcVar5 = pgVar2 + sVar3;
      cVar1 = *new;
      while (cVar1 != '\0') {
        new = new + 1;
        *pcVar5 = cVar1;
        pcVar5 = pcVar5 + 1;
        cVar1 = *new;
      }
      *pcVar5 = '\0';
      return;
    }
    sVar6 = sVar6 + 0x400;
    pgVar2 = (gchar *)realloc(pgVar2,sVar6);
  } while (pgVar2 != (gchar *)0x0);
  __fprintf_chk(stderr,1,"ghid_ui_info_append():  realloc of size %ld failed\n",sVar6);
                    // WARNING: Subroutine does not return
  exit(1);
}



// WARNING: Unknown calling convention

void ghid_ui_info_indent(int indent)

{
  int iVar1;
  int i;
  
  if (0 < indent) {
    iVar1 = 0;
    do {
      iVar1 = iVar1 + 1;
      ghid_ui_info_append(" ");
    } while (iVar1 < indent);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_check_special_key(char *accel,char *name)

{
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  uint mods;
  uint uVar4;
  uint ind;
  uchar *__s1;
  uchar *__s1_1;
  char *pcVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  if (accel == (char *)0x0) {
    return;
  }
  if (*accel == '\0') {
    return;
  }
  pcVar1 = strstr(accel,"<alt>");
  mods = ~-(uint)(pcVar1 == (char *)0x0);
  pcVar1 = strstr(accel,"<control>");
  uVar4 = mods & 0x80;
  if (pcVar1 != (char *)0x0) {
    uVar4 = mods & 0x80 | 0x40;
  }
  pcVar1 = strstr(accel,"<shift>");
  if (pcVar1 != (char *)0x0) {
    uVar4 = uVar4 | 0x20;
  }
  sVar2 = strlen(accel);
  if (sVar2 < 3) {
    if (sVar2 != 2) {
      return;
    }
  }
  else {
    pcVar1 = accel + (sVar2 - 3);
    if ((((*pcVar1 == 'T') && (pcVar1[1] == 'a')) && (pcVar1[2] == 'b')) && (pcVar1[3] == '\0')) {
      ind = uVar4 | 1;
      goto LAB_08104938;
    }
  }
  pcVar1 = accel + (sVar2 - 2);
  if (((*pcVar1 == 'U') && (pcVar1[1] == 'p')) && (pcVar1[2] == '\0')) {
    ind = uVar4 | 2;
  }
  else {
    bVar6 = sVar2 == 3;
    if (sVar2 < 4) {
      return;
    }
    iVar3 = 5;
    pcVar1 = accel + (sVar2 - 4);
    pcVar5 = "Down";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar6 = *pcVar1 == *pcVar5;
      pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
      pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
    } while (bVar6);
    if (bVar6) {
      ind = uVar4 | 3;
    }
    else {
      iVar3 = 5;
      pcVar1 = accel + (sVar2 - 4);
      pcVar5 = "Left";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar6 = *pcVar1 == *pcVar5;
        pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
        pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
      } while (bVar6);
      if (bVar6) {
        ind = uVar4 | 4;
      }
      else {
        bVar6 = sVar2 == 4;
        if (bVar6) {
          return;
        }
        iVar3 = 6;
        pcVar1 = accel + (sVar2 - 5);
        pcVar5 = "Right";
        do {
          if (iVar3 == 0) break;
          iVar3 = iVar3 + -1;
          bVar6 = *pcVar1 == *pcVar5;
          pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
          pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
        } while (bVar6);
        if (!bVar6) {
          return;
        }
        ind = uVar4 | 5;
      }
    }
  }
LAB_08104938:
  pcVar1 = (char *)g_strdup(name);
  ghid_hotkey_actions[ind] = pcVar1;
  return;
}



// WARNING: Unknown calling convention

void note_toggle_flag(char *actionname,MenuFlagType type,char *name)

{
  int iVar1;
  ToggleFlagType *pTVar2;
  char *pcVar3;
  
  if (max_tflags <= n_tflags) {
    max_tflags = max_tflags + 0x14;
    tflags = (ToggleFlagType *)MyRealloc(tflags,max_tflags * 0x14,"note_toggle_flag");
  }
  pTVar2 = tflags;
  iVar1 = n_tflags;
  pcVar3 = (char *)__strdup(actionname);
  pTVar2[iVar1].actionname = pcVar3;
  pTVar2 = tflags;
  tflags[n_tflags].oldval = -1;
  pTVar2[n_tflags].flagname = name;
  pTVar2[n_tflags].flagtype = type;
  pTVar2[n_tflags].xres = "none";
  n_tflags = n_tflags + 1;
  return;
}



// WARNING: Unknown calling convention

void layer_process(gchar **color_string,char **text,int *set,int i)

{
  DataTypePtr paVar1;
  char *pcVar2;
  gchar *tmpc;
  char *tmps;
  int tmp;
  
  if (color_string == (gchar **)0x0) {
    color_string = &tmpc;
  }
  if (text == (char **)0x0) {
    text = &tmps;
  }
  if (set == (int *)0x0) {
    set = &tmp;
  }
  switch(i) {
  case 0x10:
    *color_string = PCB->ElementColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"silk",5);
    *text = pcVar2;
    *set = (int)PCB->ElementOn;
    break;
  case 0x11:
    *color_string = PCB->RatColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"rat lines",5);
    *text = pcVar2;
    *set = (int)PCB->RatOn;
    break;
  case 0x12:
    *color_string = PCB->PinColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"pins/pads",5);
    *text = pcVar2;
    *set = (int)PCB->PinOn;
    break;
  case 0x13:
    *color_string = PCB->ViaColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"vias",5);
    *text = pcVar2;
    *set = (int)PCB->ViaOn;
    break;
  case 0x14:
    *color_string = PCB->InvisibleObjectsColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"far side",5);
    *text = pcVar2;
    *set = (int)PCB->InvisibleObjectsOn;
    break;
  case 0x15:
    *color_string = PCB->MaskColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"solder mask",5);
    *text = pcVar2;
    *set = (PCB->Flags).f >> 0xd & 1;
    break;
  default:
    paVar1 = PCB->Data;
    *color_string = paVar1->Layer[i].Color;
    pcVar2 = paVar1->Layer[i].Name;
    if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
      pcVar2 = "(unknown)";
    }
    *text = pcVar2;
    *set = (int)paVar1->Layer[i].On;
  }
  return;
}



// WARNING: Unknown calling convention

void layer_button_set_color(LayerButtonSet *lb,gchar *color_string)

{
  GdkColor color;
  
  if (lb->layer_enable_ebox != (GtkWidget *)0x0) {
    color.blue = 0;
    color.green = 0;
    color.red = 0;
    ghid_map_color_string(color_string,&color);
    gtk_widget_modify_bg(lb->layer_enable_ebox,1,&color);
    gtk_widget_modify_bg(lb->layer_enable_ebox,2,&color);
    gtk_widget_modify_fg(lb->label,1,&WhitePixel);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_layer_buttons_color_update(void)

{
  gint i;
  int i_00;
  int iVar1;
  LayerButtonSet *lb;
  gchar *local_20 [4];
  
  if (gport->drawing_area != (GtkWidget *)0x0) {
    pcb_colors_from_settings(PCB);
    i_00 = 0;
    lb = layer_buttons;
    do {
      iVar1 = i_00 + 1;
      layer_process(local_20,(char **)0x0,(int *)0x0,i_00);
      layer_button_set_color(lb,local_20[0]);
      i_00 = iVar1;
      lb = lb + 1;
    } while (iVar1 != 0x16);
  }
  return;
}



// WARNING: Unknown calling convention

void mode_button_toggled_cb(GtkWidget *widget,ModeButton *mb)

{
  undefined4 uVar1;
  int iVar2;
  gboolean active;
  
  uVar1 = gtk_toggle_button_get_type();
  uVar1 = g_type_check_instance_cast(widget,uVar1);
  iVar2 = gtk_toggle_button_get_active(uVar1);
  if (iVar2 != 0) {
    SetMode(mb->mode);
    ghid_mode_cursor(mb->mode);
    ghidgui->settings_mode = mb->mode;
  }
  return;
}



// WARNING: Unknown calling convention

void route_style_select_button_cb(GtkToggleButton *button,gpointer data)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  gchar buf [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (((data != (gpointer)0x6) && (ghidgui->toggle_holdoff == 0)) &&
     ((gpointer)route_style_index != data)) {
    route_style_index = (gint)data;
    if ((int)data < 4) {
      __snprintf_chk(buf,0x10,1,0x10,&DAT_081538d1,(int)data + 1);
      iVar2 = gtk_toggle_button_get_active(button);
      if (iVar2 != 0) {
        hid_actionl("RouteStyle",buf,0);
      }
    }
    else if ((int)data < 6) {
      SetLineSize(route_style_button[(int)data].route_style.Thick);
      SetViaSize(route_style_button[(int)data].route_style.Diameter,'\x01');
      SetViaDrillingHole(route_style_button[(int)data].route_style.Hole,'\x01');
      SetKeepawayWidth(route_style_button[(int)data].route_style.Keepaway);
    }
    gtk_widget_set_sensitive(route_style_edit_button,1);
    ghid_set_status_line_label();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void ghid_interface_set_sensitive(gboolean sensitive)

{
  gtk_widget_set_sensitive(ghid_left_sensitive_box,sensitive);
  gtk_widget_set_sensitive(ghidgui->menu_hbox,sensitive);
  return;
}



// WARNING: Unknown calling convention

void ghid_route_style_buttons_update(void)

{
  RouteStyleType *rst;
  RouteStyleType *pRVar1;
  int n;
  gint i;
  
  n = 0;
  do {
    pRVar1 = PCB->RouteStyle + n;
    if (n < 4) {
LAB_08104fcb:
      if ((((Settings.LineThickness == pRVar1->Thick) && (Settings.ViaThickness == pRVar1->Diameter)
           ) && (Settings.ViaDrillingHole == pRVar1->Hole)) &&
         (Settings.Keepaway == pRVar1->Keepaway)) break;
    }
    else if (route_style_button[n].shown != 0) {
      pRVar1 = &route_style_button[n].route_style;
      goto LAB_08104fcb;
    }
    n = n + 1;
  } while (n != 6);
  ghidgui->toggle_holdoff = 1;
  ghid_route_style_button_set_active(n);
  route_style_index = n;
  ghidgui->toggle_holdoff = 0;
  gtk_widget_set_sensitive(route_style_edit_button,n != 6);
  return;
}



// WARNING: Unknown calling convention

void route_style_edit_cb(GtkWidget *widget,GHidPort *port)

{
  hid_action("AdjustStyle");
  return;
}



// WARNING: Unknown calling convention

gint delete_chart_cb(GtkWidget *widget,GdkEvent *event,GHidPort *port)

{
  ghid_config_files_write();
  hid_action("Quit");
  return 1;
}



// WARNING: Unknown calling convention

void destroy_chart_cb(GtkWidget *widget,GHidPort *port)

{
  gtk_main_quit();
  return;
}



// WARNING: Unknown calling convention

void h_adjustment_changed_cb(GtkAdjustment *adj,GhidGui *g)

{
  undefined4 uVar1;
  
  if (g->adjustment_changed_holdoff != 0) {
    return;
  }
  gtk_adjustment_get_value(adj);
  uVar1 = gtk_adjustment_get_type();
  uVar1 = g_type_check_instance_cast(ghidgui->v_adjustment,uVar1);
  gtk_adjustment_get_value(uVar1);
  ghid_port_ranges_changed();
  return;
}



// WARNING: Unknown calling convention

void v_adjustment_changed_cb(GtkAdjustment *adj,GhidGui *g)

{
  undefined4 uVar1;
  
  if (g->adjustment_changed_holdoff != 0) {
    return;
  }
  gtk_adjustment_get_value(adj);
  uVar1 = gtk_adjustment_get_type();
  uVar1 = g_type_check_instance_cast(ghidgui->h_adjustment,uVar1);
  gtk_adjustment_get_value(uVar1);
  ghid_port_ranges_changed();
  return;
}



// WARNING: Unknown calling convention

void ghid_interface_input_signals_disconnect(void)

{
  if (button_press_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,button_press_handler);
  }
  if (button_release_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,button_release_handler);
  }
  if (key_press_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,key_press_handler);
  }
  if (key_release_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,key_release_handler);
  }
  button_release_handler = 0;
  button_press_handler = 0;
  key_release_handler = 0;
  key_press_handler = 0;
  return;
}



// WARNING: Unknown calling convention

void ghid_pack_mode_buttons(void)

{
  undefined4 uVar1;
  GtkWidget *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  GtkWidget *pGVar6;
  
  if (-1 < ghid_pack_mode_buttons::last_pack_compact) {
    if (ghid_pack_mode_buttons::last_pack_compact == 0) {
      uVar1 = gtk_container_get_type();
      pGVar6 = ghidgui->mode_buttons0_frame;
      pGVar2 = ghidgui->mode_buttons0_frame_vbox;
    }
    else {
      uVar1 = gtk_container_get_type();
      pGVar6 = ghidgui->mode_buttons1_frame;
      pGVar2 = ghidgui->mode_buttons1_vbox;
    }
    iVar5 = 0;
    uVar3 = g_type_check_instance_cast(pGVar2,uVar1);
    gtk_container_remove(uVar3,pGVar6);
    do {
      if (ghid_pack_mode_buttons::last_pack_compact == 0) {
        uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
        uVar4 = *(undefined4 *)((int)&mode_buttons[0].box0 + iVar5);
      }
      else {
        uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
        uVar4 = *(undefined4 *)((int)&mode_buttons[0].box1 + iVar5);
      }
      iVar5 = iVar5 + 0x18;
      uVar4 = g_type_check_instance_cast(uVar4,uVar1);
      gtk_container_remove(uVar4,uVar3);
    } while (iVar5 != 0x138);
  }
  uVar1 = gtk_box_get_type();
  iVar5 = 0;
  do {
    if (ghidgui->compact_vertical == 0) {
      uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
      uVar4 = *(undefined4 *)((int)&mode_buttons[0].box0 + iVar5);
    }
    else {
      uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
      uVar4 = *(undefined4 *)((int)&mode_buttons[0].box1 + iVar5);
    }
    iVar5 = iVar5 + 0x18;
    uVar4 = g_type_check_instance_cast(uVar4,uVar1);
    gtk_box_pack_start(uVar4,uVar3,0,0,0);
  } while (iVar5 != 0x138);
  if (ghidgui->compact_vertical == 0) {
    pGVar6 = ghidgui->mode_buttons0_frame;
    uVar1 = g_type_check_instance_cast(ghidgui->mode_buttons0_frame_vbox,uVar1);
    gtk_box_pack_start(uVar1,pGVar6,0,0,0);
    gtk_widget_show_all(ghidgui->mode_buttons0_frame);
  }
  else {
    pGVar6 = ghidgui->mode_buttons1_frame;
    uVar1 = g_type_check_instance_cast(ghidgui->mode_buttons1_vbox,uVar1);
    gtk_box_pack_start(uVar1,pGVar6,0,0,0);
    gtk_widget_show_all(ghidgui->mode_buttons1_frame);
  }
  ghid_pack_mode_buttons::last_pack_compact = ghidgui->compact_vertical;
  return;
}



// WARNING: Unknown calling convention

void ghid_route_style_set_button_label(gchar *name,gint index)

{
  undefined4 uVar1;
  
  if (((uint)index < 4) && (route_style_button[index].button != (GtkWidget *)0x0)) {
    dcgettext(&DAT_0815492c,name,5);
    uVar1 = gtk_button_get_type();
    g_type_check_instance_cast(route_style_button[index].button,uVar1);
    gtk_button_set_label();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_init_toggle_states(void)

{
  gboolean gVar1;
  GhidGui *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  GtkAction *action;
  gboolean old_holdoff;
  int iVar5;
  
  pGVar2 = ghidgui;
  gVar1 = ghidgui->toggle_holdoff;
  ghidgui->toggle_holdoff = 1;
  uVar3 = gtk_action_group_get_action(pGVar2->main_actions,"ToggleDrawGrid");
  iVar5 = (int)Settings.DrawGrid;
  uVar4 = gtk_toggle_action_get_type();
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleGridUnitsMm");
  iVar5 = (int)Settings.grid_units_mm;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"TogglePinoutShowsNumber");
  iVar5 = (int)Settings.ShowNumber;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"Toggle45degree");
  iVar5 = (int)Settings.AllDirectionLines;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleRubberBand");
  iVar5 = (int)Settings.RubberBandMode;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleStartDirection");
  iVar5 = (int)Settings.SwapStartDirection;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleUniqueNames");
  iVar5 = (int)Settings.UniqueNames;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleSnapPin");
  iVar5 = (int)Settings.SnapPin;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleClearLine");
  iVar5 = (int)Settings.ClearLine;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleOrthogonalMoves");
  iVar5 = (int)Settings.OrthogonalMoves;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleLiveRoute");
  iVar5 = (int)Settings.liveRouting;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleShowDRC");
  iVar5 = (int)Settings.ShowDRC;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleAutoDrC");
  iVar5 = (int)Settings.AutoDRC;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  ghidgui->toggle_holdoff = gVar1;
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void ghid_set_menu_toggle_button(GtkActionGroup *ag,gchar *name,gboolean state)

{
  gboolean gVar1;
  int iVar2;
  GtkAction *action;
  undefined4 uVar3;
  gboolean old_holdoff;
  
  gVar1 = ghidgui->toggle_holdoff;
  ghidgui->toggle_holdoff = 1;
  iVar2 = gtk_action_group_get_action(ag,name);
  if (iVar2 != 0) {
    uVar3 = gtk_toggle_action_get_type();
    uVar3 = g_type_check_instance_cast(iVar2,uVar3);
    gtk_toggle_action_set_active(uVar3,state);
  }
  ghidgui->toggle_holdoff = gVar1;
  return;
}



// WARNING: Unknown calling convention

void ghid_window_set_name_label(gchar *name)

{
  GhidGui *pGVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  gchar *pgVar4;
  gchar *str;
  
  if (ghidgui != (GhidGui *)0x0) {
    dup_string(&ghidgui->name_label_string,name);
    pGVar1 = ghidgui;
    if ((ghidgui->name_label_string == (char *)0x0) || (*ghidgui->name_label_string == '\0')) {
      uVar2 = dcgettext(&DAT_0815492c,"Unnamed",5);
      pgVar4 = (gchar *)g_strdup(uVar2);
      pGVar1->name_label_string = pgVar4;
    }
    if (ghidgui->name_label != (GtkWidget *)0x0) {
      if (ghidgui->ghid_title_window == 0) {
        gtk_widget_show(ghidgui->label_hbox);
        uVar2 = g_strdup_printf(" <b><big>%s</big></b> ",ghidgui->name_label_string);
        uVar3 = gtk_label_get_type();
        uVar3 = g_type_check_instance_cast(ghidgui->name_label,uVar3);
        gtk_label_set_markup(uVar3,uVar2);
        uVar2 = gtk_window_get_type();
        uVar2 = g_type_check_instance_cast(gport->top_window,uVar2);
        gtk_window_set_title(uVar2,&DAT_08154932);
        g_free();
        return;
      }
      gtk_widget_hide(ghidgui->label_hbox);
      uVar2 = g_strdup_printf("PCB:  %s",ghidgui->name_label_string);
      uVar3 = gtk_window_get_type();
      uVar3 = g_type_check_instance_cast(gport->top_window,uVar3);
      gtk_window_set_title(uVar3,uVar2);
      g_free();
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_layer_enable_buttons_update(void)

{
  char cVar1;
  GtkWidget *pGVar2;
  gboolean new;
  LayerButtonSet *lb;
  gboolean gVar3;
  gchar *pgVar4;
  undefined4 uVar5;
  int iVar6;
  PCBTypePtr pPVar7;
  int layer;
  gint i;
  GtkWidget **ppGVar8;
  gchar *s;
  gboolean active;
  DataTypePtr paVar9;
  char *src;
  undefined4 local_20;
  
  pPVar7 = PCB;
  layer_enable_button_cb_hold_off = 1;
  paVar9 = PCB->Data;
  if (paVar9->LayerN < 1) {
    local_20 = gtk_toggle_button_get_type();
  }
  else {
    local_20 = gtk_toggle_button_get_type();
    ppGVar8 = &layer_buttons[0].layer_enable_button;
    layer = 0;
    do {
      src = paVar9->Layer[layer].Name;
      if ((src == (char *)0x0) || (*src == '\0')) {
        src = "(unknown)";
      }
      gVar3 = dup_string((gchar **)(ppGVar8 + 3),src);
      if (gVar3 == 0) {
        if (Settings.verbose == 0) goto LAB_081059be;
LAB_08105a94:
        uVar5 = g_type_check_instance_cast(*ppGVar8,local_20);
        active = gtk_toggle_button_get_active(uVar5);
        iVar6 = (int)PCB->Data->Layer[layer].On;
        if (active != iVar6) {
          __printf_chk(1,"ghid_layer_enable_buttons_update: active=%d new=%d\n",active,iVar6);
          active = (gboolean)PCB->Data->Layer[layer].On;
        }
      }
      else {
        pgVar4 = (gchar *)dcgettext(&DAT_0815492c,src,5);
        layer_enable_button_set_label(ppGVar8[2],pgVar4);
        pgVar4 = (gchar *)dcgettext(&DAT_0815492c,src,5);
        ghid_config_layer_name_update(pgVar4,layer);
        if (Settings.verbose != 0) goto LAB_08105a94;
LAB_081059be:
        active = (gboolean)PCB->Data->Layer[layer].On;
      }
      layer = layer + 1;
      pGVar2 = *ppGVar8;
      ppGVar8 = ppGVar8 + 6;
      uVar5 = g_type_check_instance_cast(pGVar2,local_20);
      gtk_toggle_button_set_active(uVar5,active);
      paVar9 = PCB->Data;
      pPVar7 = PCB;
    } while (paVar9->LayerN != layer && layer <= paVar9->LayerN);
  }
  cVar1 = pPVar7->ElementOn;
  uVar5 = g_type_check_instance_cast(layer_buttons[16].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar5,(int)cVar1);
  cVar1 = PCB->RatOn;
  uVar5 = g_type_check_instance_cast(layer_buttons[17].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar5,(int)cVar1);
  cVar1 = PCB->PinOn;
  uVar5 = g_type_check_instance_cast(layer_buttons[18].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar5,(int)cVar1);
  cVar1 = PCB->ViaOn;
  uVar5 = g_type_check_instance_cast(layer_buttons[19].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar5,(int)cVar1);
  cVar1 = PCB->InvisibleObjectsOn;
  uVar5 = g_type_check_instance_cast(layer_buttons[20].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar5,(int)cVar1);
  layer_enable_button_cb_hold_off = 0;
  return;
}



// WARNING: Unknown calling convention

void ghid_layer_buttons_update(void)

{
  int *piVar1;
  int iVar2;
  char cVar3;
  gboolean gVar4;
  int iVar5;
  undefined4 uVar6;
  int iVar7;
  int i;
  GtkAction *a;
  int in_GS_OFFSET;
  bool bVar8;
  int local_94;
  GValue *local_90;
  GValue setlabel;
  GValue settrue;
  GValue setfalse;
  char *local_50;
  int local_4c;
  char tmpnm [40];
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  setfalse.g_type = 0;
  setfalse.data[0].v_int = 0;
  setfalse.data[0].v_int64._4_4_ = 0;
  setfalse.data[1].v_int = 0;
  setfalse.data[1].v_int64._4_4_ = 0;
  settrue.g_type = 0;
  settrue.data[0].v_int = 0;
  settrue.data[0].v_int64._4_4_ = 0;
  settrue.data[1].v_int = 0;
  settrue.data[1].v_int64._4_4_ = 0;
  setlabel.g_type = 0;
  setlabel.data[0].v_int = 0;
  setlabel.data[0].v_int64._4_4_ = 0;
  setlabel.data[1].v_int = 0;
  setlabel.data[1].v_int64._4_4_ = 0;
  g_value_init(&setfalse,0x14);
  g_value_init(&settrue,0x14);
  g_value_set_boolean(&setfalse,0);
  g_value_set_boolean(&settrue,1);
  g_value_init(&setlabel,0x40);
  if ((ghidgui != (GhidGui *)0x0) && (ghidgui->creating == 0)) {
    ghid_layer_enable_buttons_update();
    local_94 = 0x11;
    if ((PCB->RatDraw == '\0') && (local_94 = 0x10, PCB->SilkActive == '\0')) {
      local_94 = LayerStack[0];
    }
    if (local_94 < PCB->Data->LayerN) {
      cVar3 = PCB->Data->Layer[local_94].On;
    }
    else if (local_94 == 0x10) {
      cVar3 = PCB->ElementOn;
    }
    else {
      cVar3 = '\0';
      if (local_94 == 0x11) {
        cVar3 = PCB->RatOn;
      }
    }
    if (((Settings.verbose != 0) &&
        (iVar7 = local_94,
        __printf_chk(1,"ghid_layer_buttons_update cur_index=%d update_index=%d\n",
                     layer_select_button_index,local_94), cVar3 != '\0')) &&
       (local_94 != layer_select_button_index)) {
      __printf_chk(1,"\tActivating button %d\n",local_94,iVar7);
    }
    iVar7 = 0;
    gVar4 = ghidgui->toggle_holdoff;
    ghidgui->toggle_holdoff = 1;
    do {
      __sprintf_chk(tmpnm,1,0x28,&DAT_08139f46,"LayerPick",iVar7);
      iVar5 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
      layer_process((gchar **)0x0,&local_50,&local_4c,iVar7);
      g_value_set_string(&setlabel,local_50);
      if (iVar5 != 0) {
        if ((0xf < iVar7) ||
           (local_90 = &setfalse, piVar1 = &PCB->Data->LayerN, *piVar1 != iVar7 && iVar7 <= *piVar1)
           ) {
          local_90 = &settrue;
        }
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,"visible",local_90);
        bVar8 = local_4c != 0;
        uVar6 = gtk_toggle_action_get_type();
        uVar6 = g_type_check_instance_cast(iVar5,uVar6);
        gtk_toggle_action_set_active(uVar6,bVar8 && iVar7 == local_94);
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,"label",&setlabel);
      }
      __sprintf_chk(tmpnm,1,0x28,&DAT_08139f46,"LayerView",iVar7);
      iVar5 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
      if (iVar5 != 0) {
        if ((0xf < iVar7) ||
           (local_90 = &setfalse, piVar1 = &PCB->Data->LayerN, *piVar1 != iVar7 && iVar7 <= *piVar1)
           ) {
          local_90 = &settrue;
        }
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,"visible",local_90);
        bVar8 = local_4c != 0;
        uVar6 = gtk_toggle_action_get_type();
        uVar6 = g_type_check_instance_cast(iVar5,uVar6);
        gtk_toggle_action_set_active(uVar6,bVar8);
        g_value_set_string(&setlabel,local_50);
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,"label",&setlabel);
      }
      iVar7 = iVar7 + 1;
    } while (iVar7 != 0x16);
    g_value_unset(&setfalse);
    g_value_unset(&settrue);
    g_value_unset(&setlabel);
    ghidgui->toggle_holdoff = gVar4;
    if ((cVar3 != '\0') && (local_94 != layer_select_button_index)) {
      layer_select_button_cb_hold_off = 1;
      uVar6 = gtk_toggle_button_get_type();
      uVar6 = g_type_check_instance_cast(layer_buttons[local_94].radio_select_button,uVar6);
      gtk_toggle_button_set_active(uVar6,1);
      layer_select_button_index = local_94;
      layer_select_button_cb_hold_off = 0;
    }
  }
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

gint LayersChanged(int argc,char **argv,int px,int py)

{
  if ((ghidgui != (GhidGui *)0x0) && (ghidgui->ui_manager != (GtkUIManager *)0x0)) {
    ghid_config_groups_changed();
    ghid_layer_buttons_update();
    ghid_show_layer_buttons();
    pcb_colors_from_settings(PCB);
  }
  return 0;
}



// WARNING: Unknown calling convention

void layer_enable_button_cb(GtkWidget *widget,gpointer data)

{
  DataTypePtr *ppaVar1;
  Cardinal CVar2;
  Boolean BVar3;
  PCBTypePtr pPVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  int iVar8;
  Boolean On;
  gboolean active;
  DataTypePtr paVar9;
  gint i;
  int iVar10;
  gboolean redraw;
  bool bVar11;
  
  uVar5 = gtk_toggle_button_get_type();
  uVar6 = g_type_check_instance_cast(widget,uVar5);
  iVar7 = gtk_toggle_button_get_active(uVar6);
  pPVar4 = PCB;
  if (layer_enable_button_cb_hold_off != 0) {
    return;
  }
  On = (Boolean)iVar7;
  switch(data) {
  case (gpointer)0x10:
    PCB->ElementOn = On;
    BVar3 = Settings.ShowSolderSide;
    paVar9 = pPVar4->Data;
    paVar9->Layer[(uint)(Settings.ShowSolderSide == '\0') + paVar9->LayerN].On = On;
    paVar9->Layer[(uint)(BVar3 != '\0') + paVar9->LayerN].On = On;
    break;
  case (gpointer)0x11:
    PCB->RatOn = On;
    break;
  case (gpointer)0x12:
    PCB->PinOn = On;
    CVar2 = pPVar4->Data->ElementN;
    goto LAB_081062df;
  case (gpointer)0x13:
    PCB->ViaOn = On;
    CVar2 = pPVar4->Data->ViaN;
LAB_081062df:
    layer_select_button_cb_hold_off = 1;
    layer_enable_button_cb_hold_off = 1;
    ghid_layer_buttons_update();
    if (CVar2 == 0) {
      layer_select_button_cb_hold_off = 0;
      layer_enable_button_cb_hold_off = 0;
      return;
    }
    goto LAB_081063fa;
  case (gpointer)0x14:
    bVar11 = false;
    ppaVar1 = &PCB->Data;
    PCB->InvisibleObjectsOn = On;
    if (iVar7 != 0) {
      bVar11 = pPVar4->ElementOn != '\0';
    }
    (*ppaVar1)->Layer[(uint)(Settings.ShowSolderSide != '\0') + (*ppaVar1)->LayerN].On = bVar11;
    break;
  case (gpointer)0x15:
    if (iVar7 == 0) {
      (PCB->Flags).f = (PCB->Flags).f & 0xffffdfff;
    }
    else {
      (PCB->Flags).f = (PCB->Flags).f | 0x2000;
    }
    break;
  default:
    iVar7 = GetGroupOfLayer((int)data);
    if (PCB->SilkActive == '\0') {
      iVar8 = PCB->Data->LayerN;
      iVar10 = LayerStack[0];
    }
    else {
      iVar8 = PCB->Data->LayerN;
      iVar10 = (uint)(Settings.ShowSolderSide == '\0') + iVar8;
    }
    if (iVar10 < iVar8) {
      iVar8 = iVar10;
    }
    iVar8 = GetGroupOfLayer(iVar8);
    if (iVar7 == iVar8) {
      paVar9 = PCB->Data;
      iVar8 = paVar9->LayerN;
      i = ((int)data + 1) % (iVar8 + 1);
      do {
        if (data == (gpointer)i) {
          g_type_check_instance_cast(widget,uVar5);
          gtk_toggle_button_set_active();
          return;
        }
        if (paVar9->Layer[i].On == '\x01') {
          iVar8 = GetGroupOfLayer(i);
          if (iVar7 != iVar8) {
            ChangeGroupVisibility(i,'\x01','\x01');
            break;
          }
          paVar9 = PCB->Data;
          iVar8 = paVar9->LayerN;
        }
        i = (i + 1) % (iVar8 + 1);
      } while( true );
    }
    ChangeGroupVisibility((int)data,On,'\0');
  }
  layer_select_button_cb_hold_off = 1;
  layer_enable_button_cb_hold_off = 1;
  ghid_layer_buttons_update();
LAB_081063fa:
  layer_select_button_cb_hold_off = 0;
  layer_enable_button_cb_hold_off = 0;
  ghid_invalidate_all();
  return;
}



// WARNING: Unknown calling convention

void layer_select_button_cb(GtkWidget *widget,LayerButtonSet *lb)

{
  PCBTypePtr pPVar1;
  undefined4 uVar2;
  int iVar3;
  gboolean active;
  
  uVar2 = gtk_toggle_button_get_type();
  uVar2 = g_type_check_instance_cast(widget,uVar2);
  iVar3 = gtk_toggle_button_get_active(uVar2);
  pPVar1 = PCB;
  if (((iVar3 != 0) && (layer_select_button_cb_hold_off == 0)) &&
     (layer_select_button_cb::in_cb == 0)) {
    iVar3 = lb->index;
    layer_select_button_cb::in_cb = 1;
    PCB->SilkActive = iVar3 == 0x10;
    pPVar1->RatDraw = iVar3 == 0x11;
    if (iVar3 < pPVar1->Data->LayerN) {
      ChangeGroupVisibility(iVar3,'\x01','\x01');
      iVar3 = lb->index;
    }
    layer_select_button_cb_hold_off = 1;
    layer_enable_button_cb_hold_off = 1;
    layer_select_button_index = iVar3;
    ghid_layer_buttons_update();
    layer_select_button_cb_hold_off = 0;
    layer_enable_button_cb_hold_off = 0;
    ghid_invalidate_all();
    layer_select_button_cb::in_cb = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_sync_with_new_layout(void)

{
  pcb_use_route_style(PCB->RouteStyle);
  ghid_route_style_button_set_active(0);
  ghid_config_handle_units_changed();
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void ghid_grid_setting_update_menu_actions(void)

{
  GhidGui *pGVar1;
  GtkActionGroup *pGVar2;
  int iVar3;
  gint i;
  GtkAction *action;
  gdouble *pgVar4;
  gdouble *value;
  
  if (ghidgui->grid_actions != (GtkActionGroup *)0x0) {
    gtk_ui_manager_remove_action_group(ghidgui->ui_manager,ghidgui->grid_actions);
    g_object_unref(ghidgui->grid_actions);
  }
  pGVar1 = ghidgui;
  pGVar2 = (GtkActionGroup *)gtk_action_group_new("GridActions");
  pGVar1->grid_actions = pGVar2;
  gtk_action_group_set_translation_domain(ghidgui->grid_actions,0);
  gtk_ui_manager_insert_action_group(ghidgui->ui_manager,ghidgui->grid_actions,0);
  pgVar4 = grid_mil_values;
  if (Settings.grid_units_mm != '\0') {
    pgVar4 = grid_mm_values;
  }
  iVar3 = 0;
  do {
    if ((PCB->Grid < pgVar4[iVar3] + 1.0) && (pgVar4[iVar3] - 1.0 < PCB->Grid)) goto LAB_081066dc;
    iVar3 = iVar3 + 1;
  } while (iVar3 != 0xb);
  iVar3 = -1;
LAB_081066dc:
  if (Settings.grid_units_mm == '\0') {
    gtk_action_group_add_radio_actions
              (ghidgui->grid_actions,radio_grid_mil_setting_entries,0xc,iVar3,
               radio_grid_mil_setting_cb,0);
  }
  else {
    gtk_action_group_add_radio_actions
              (ghidgui->grid_actions,radio_grid_mm_setting_entries,0xc,iVar3,
               radio_grid_mm_setting_cb,0);
  }
  iVar3 = gtk_action_group_get_action(ghidgui->grid_actions,"grid-user");
  if (iVar3 != 0) {
    g_object_set(iVar3,"sensitive",0,0);
  }
  return;
}



// WARNING: Unknown calling convention

void grid_units_button_cb(GtkWidget *widget,gpointer data)

{
  gdouble gVar1;
  int iVar2;
  gint i;
  undefined4 uVar3;
  gdouble *pgVar4;
  gdouble *value;
  
  pgVar4 = grid_mil_values;
  if (Settings.grid_units_mm != '\0') {
    pgVar4 = grid_mm_values;
  }
  iVar2 = 0;
  do {
    if ((PCB->Grid < pgVar4[iVar2] + 1.0) && (pgVar4[iVar2] - 1.0 < PCB->Grid)) goto LAB_081067f4;
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0xb);
  iVar2 = 10;
LAB_081067f4:
  Settings.grid_units_mm = Settings.grid_units_mm == '\0';
  if ((bool)Settings.grid_units_mm) {
    gVar1 = grid_mm_values[iVar2];
  }
  else {
    gVar1 = grid_mil_values[iVar2];
  }
  PCB->Grid = gVar1;
  ghid_grid_setting_update_menu_actions();
  uVar3 = g_strdup_printf("%f",PCB->Grid);
  hid_actionl("SetValue","Grid",uVar3,&DAT_0814741b,0);
  g_free(uVar3);
  ghid_config_handle_units_changed();
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void radio_grid_mil_setting_cb(GtkAction *action,GtkRadioAction *current)

{
  int iVar1;
  gint index;
  undefined4 uVar2;
  
  __printf_chk(1,"radio_grid_mil_setting_cb()\n");
  if (ghidgui->toggle_holdoff != 0) {
    return;
  }
  iVar1 = gtk_radio_action_get_current_value(current);
  uVar2 = g_strdup_printf("%f",grid_mil_values[iVar1]);
  hid_actionl("SetValue","Grid",uVar2,&DAT_0814741b,0);
  g_free(uVar2);
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void radio_grid_mm_setting_cb(GtkAction *action,GtkRadioAction *current)

{
  int iVar1;
  gint index;
  undefined4 uVar2;
  
  __printf_chk(1,"radio_grid_mm_setting_cb()\n");
  if (ghidgui->toggle_holdoff != 0) {
    return;
  }
  iVar1 = gtk_radio_action_get_current_value(current);
  uVar2 = g_strdup_printf("%f",grid_mm_values[iVar1]);
  hid_actionl("SetValue","Grid",uVar2,&DAT_0814741b,0);
  g_free(uVar2);
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void ghid_update_toggle_flags(void)

{
  int iVar1;
  gboolean gVar2;
  GtkAction *a;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  GValue *pGVar7;
  gboolean active;
  int iVar8;
  int iVar9;
  int i;
  int v;
  int in_GS_OFFSET;
  undefined4 local_90;
  GValue setlabel;
  GValue settrue;
  GValue setfalse;
  char tmpnm [40];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  setfalse.g_type = 0;
  setfalse.data[0].v_int = 0;
  setfalse.data[0].v_int64._4_4_ = 0;
  setfalse.data[1].v_int = 0;
  setfalse.data[1].v_int64._4_4_ = 0;
  settrue.g_type = 0;
  settrue.data[0].v_int = 0;
  settrue.data[0].v_int64._4_4_ = 0;
  settrue.data[1].v_int = 0;
  settrue.data[1].v_int64._4_4_ = 0;
  setlabel.g_type = 0;
  setlabel.data[0].v_int = 0;
  setlabel.data[0].v_int64._4_4_ = 0;
  setlabel.data[1].v_int = 0;
  setlabel.data[1].v_int64._4_4_ = 0;
  g_value_init(&setfalse,0x14);
  g_value_init(&settrue,0x14);
  g_value_set_boolean(&setfalse,0);
  g_value_set_boolean(&settrue,1);
  g_value_init(&setlabel,0x40);
  gVar2 = ghidgui->toggle_holdoff;
  ghidgui->toggle_holdoff = 1;
  if (n_tflags < 1) {
    local_90 = gtk_toggle_action_get_type();
  }
  else {
    local_90 = gtk_toggle_action_get_type();
    iVar8 = 0;
    iVar9 = 0;
LAB_08106b77:
    do {
      iVar6 = *(int *)((int)&tflags->flagtype + iVar8);
      if (iVar6 == 0) {
        iVar6 = hid_get_flag(*(char **)((int)&tflags->flagname + iVar8));
        uVar3 = gtk_action_group_get_action
                          (ghidgui->main_actions,*(undefined4 *)((int)&tflags->actionname + iVar8));
        pGVar7 = &setfalse;
        if (iVar6 != 0) {
          pGVar7 = &settrue;
        }
        a = (GtkAction *)g_type_check_instance_cast(uVar3,0x50);
        g_object_set_property(a,"sensitive",pGVar7);
        *(int *)((int)&tflags->oldval + iVar8) = iVar6;
      }
      else {
        if (iVar6 != 1) {
          iVar9 = iVar9 + 1;
          iVar8 = iVar8 + 0x14;
          __printf_chk(1,"Skipping flagtype %d\n",iVar6);
          if (n_tflags <= iVar9) break;
          goto LAB_08106b77;
        }
        iVar6 = hid_get_flag(*(char **)((int)&tflags->flagname + iVar8));
        uVar3 = gtk_action_group_get_action
                          (ghidgui->main_actions,*(undefined4 *)((int)&tflags->actionname + iVar8));
        uVar3 = g_type_check_instance_cast(uVar3,local_90);
        gtk_toggle_action_set_active(uVar3,iVar6 != 0);
        *(int *)((int)&tflags->oldval + iVar8) = iVar6;
      }
      iVar9 = iVar9 + 1;
      iVar8 = iVar8 + 0x14;
    } while (iVar9 < n_tflags);
  }
  __sprintf_chk(tmpnm,1,0x28,&DAT_08139f46,"RouteStyle",0);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
  uVar4 = gtk_toggle_button_get_type();
  iVar8 = 0;
  while( true ) {
    iVar9 = iVar8 + 1;
    uVar5 = g_type_check_instance_cast(route_style_button[iVar8].button,uVar4);
    uVar5 = gtk_toggle_button_get_active(uVar5);
    uVar3 = g_type_check_instance_cast(uVar3,local_90);
    gtk_toggle_action_set_active(uVar3,uVar5);
    if (iVar9 == 7) break;
    __sprintf_chk(tmpnm,1,0x28,&DAT_08139f46,"RouteStyle",iVar9);
    uVar3 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
    iVar8 = iVar9;
    if (3 < iVar9) {
      uVar5 = g_type_check_instance_cast(uVar3,0x50);
      g_object_set_property(uVar5,"visible",&setfalse);
    }
  }
  g_value_unset(&setfalse);
  g_value_unset(&settrue);
  g_value_unset(&setlabel);
  ghidgui->toggle_holdoff = gVar2;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void ghid_menu_cb(GtkAction *action,gpointer data)

{
  gchar *name;
  char *pcVar1;
  long lVar2;
  int id;
  int iVar3;
  int *piVar4;
  int vi;
  gboolean gVar5;
  char *pcVar6;
  int iVar7;
  char *pcVar8;
  Resource *node;
  Resource *pRVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  if (ghid_menu_cb::in_cb != 0) {
    return;
  }
  ghid_menu_cb::in_cb = 1;
  pcVar1 = (char *)data;
  if (action != (GtkAction *)0x0) {
    pcVar1 = (char *)gtk_action_get_name(action);
  }
  bVar10 = pcVar1 == (char *)0x0;
  if (bVar10) {
    __fprintf_chk(stderr,1,"%s(%p, %p):  name == NULL\n","ghid_menu_cb",action,data);
    ghid_menu_cb::in_cb = 0;
    return;
  }
  iVar3 = 8;
  pcVar6 = pcVar1;
  pcVar8 = "MenuItem";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar10 = *pcVar6 == *pcVar8;
    pcVar6 = pcVar6 + (uint)bVar11 * -2 + 1;
    pcVar8 = pcVar8 + (uint)bVar11 * -2 + 1;
  } while (bVar10);
  if (bVar10) {
    lVar2 = strtol(pcVar1 + 8,(char **)0x0,10);
    pRVar9 = action_resources[lVar2];
LAB_08106efc:
    if (pRVar9 != (Resource *)0x0) {
      iVar7 = 0xc;
      iVar3 = 1;
      if (1 < pRVar9->c) {
        do {
          while( true ) {
            piVar4 = (int *)((int)&pRVar9->v->name + iVar7);
            if ((~-(uint)(*piVar4 == 0) & 100) + (uint)(piVar4[2] != 0) +
                (~-(uint)((char *)piVar4[1] == (char *)0x0) & 10) != 10) break;
            iVar3 = iVar3 + 1;
            iVar7 = iVar7 + 0xc;
            hid_parse_actions((char *)piVar4[1],(_func_int_char_ptr_int_char_ptr_ptr *)0x0);
            if (pRVar9->c == iVar3 || pRVar9->c < iVar3) goto LAB_08106f78;
          }
          iVar3 = iVar3 + 1;
          iVar7 = iVar7 + 0xc;
        } while (pRVar9->c != iVar3 && iVar3 <= pRVar9->c);
      }
    }
LAB_08106f78:
    gVar5 = ghidgui->toggle_holdoff;
  }
  else {
    iVar3 = 9;
    pcVar6 = pcVar1;
    pcVar8 = "TMenuItem";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar10 = *pcVar6 == *pcVar8;
      pcVar6 = pcVar6 + (uint)bVar11 * -2 + 1;
      pcVar8 = pcVar8 + (uint)bVar11 * -2 + 1;
    } while (bVar10);
    if (bVar10) {
      lVar2 = strtol(pcVar1 + 9,(char **)0x0,10);
      if (ghidgui->toggle_holdoff != 1) {
        pRVar9 = toggle_action_resources[lVar2];
        goto LAB_08106efc;
      }
    }
    else {
      iVar3 = 9;
      pcVar6 = pcVar1;
      pcVar8 = "LayerPick";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar10 = *pcVar6 == *pcVar8;
        pcVar6 = pcVar6 + (uint)bVar11 * -2 + 1;
        pcVar8 = pcVar8 + (uint)bVar11 * -2 + 1;
      } while (bVar10);
      if (bVar10) {
        lVar2 = strtol(pcVar1 + 9,(char **)0x0,10);
        if (ghidgui->toggle_holdoff != 1) {
          pRVar9 = layerpick_resources[lVar2];
          goto LAB_08106efc;
        }
      }
      else {
        iVar3 = 9;
        pcVar6 = pcVar1;
        pcVar8 = "LayerView";
        do {
          if (iVar3 == 0) break;
          iVar3 = iVar3 + -1;
          bVar10 = *pcVar6 == *pcVar8;
          pcVar6 = pcVar6 + (uint)bVar11 * -2 + 1;
          pcVar8 = pcVar8 + (uint)bVar11 * -2 + 1;
        } while (bVar10);
        if (bVar10) {
          lVar2 = strtol(pcVar1 + 9,(char **)0x0,10);
          if (ghidgui->toggle_holdoff != 1) {
            pRVar9 = layerview_resources[lVar2];
            goto LAB_08106efc;
          }
        }
        else {
          iVar3 = 10;
          pcVar6 = pcVar1;
          pcVar8 = "RouteStyle";
          do {
            if (iVar3 == 0) break;
            iVar3 = iVar3 + -1;
            bVar10 = *pcVar6 == *pcVar8;
            pcVar6 = pcVar6 + (uint)bVar11 * -2 + 1;
            pcVar8 = pcVar8 + (uint)bVar11 * -2 + 1;
          } while (bVar10);
          if (!bVar10) {
            __fprintf_chk(stderr,1,"ERROR:  ghid_menu_cb():  name = \"%s\" is unknown\n",pcVar1);
            gVar5 = ghidgui->toggle_holdoff;
            goto LAB_08106fc8;
          }
          lVar2 = strtol(pcVar1 + 10,(char **)0x0,10);
          if (ghidgui->toggle_holdoff != 1) {
            ghid_route_style_button_set_active(lVar2);
            gVar5 = ghidgui->toggle_holdoff;
            goto LAB_08106fc8;
          }
        }
      }
    }
    gVar5 = 1;
  }
LAB_08106fc8:
  ghidgui->toggle_holdoff = 1;
  ghid_update_toggle_flags();
  ghidgui->toggle_holdoff = gVar5;
  ghid_menu_cb::in_cb = 0;
  if (gVar5 != 0) {
    ghid_menu_cb::in_cb = 0;
    return;
  }
  HideCrosshair('\x01');
  AdjustAttachedObjects();
  ghid_invalidate_all();
  RestoreCrosshair('\x01');
  ghid_screen_update();
  ghid_set_status_line_label();
  return;
}



// WARNING: Unknown calling convention

void ghid_hotkey_cb(int which)

{
  if (ghid_hotkey_actions[which] != (char *)0x0) {
    ghid_menu_cb((GtkAction *)0x0,ghid_hotkey_actions[which]);
  }
  return;
}



void __regparm3
ghid_append_action(char *name,char *stock_id,char *label,char *accelerator,char *tooltip)

{
  gint gVar1;
  char *pcVar2;
  gchar *pgVar3;
  GtkActionEntry *pGVar4;
  GtkActionEntry *pGVar5;
  
  pcVar2 = ghid_check_unique_accel(label);
  new_entries = (GtkActionEntry *)realloc(new_entries,(menuitem_cnt * 3 + 3) * 8);
  if (new_entries == (GtkActionEntry *)0x0) {
    pcVar2 = "ghid_append_action():  realloc of new_entries failed\n";
  }
  else {
    action_resources = (Resource **)realloc(action_resources,menuitem_cnt * 4 + 4);
    gVar1 = menuitem_cnt;
    if (action_resources != (Resource **)0x0) {
      action_resources[menuitem_cnt] = (Resource *)0x0;
      pGVar4 = new_entries + gVar1;
      pgVar3 = (gchar *)__strdup(name);
      pGVar4->name = pgVar3;
      pGVar4 = new_entries;
      gVar1 = menuitem_cnt;
      new_entries[menuitem_cnt].stock_id = (gchar *)0x0;
      pgVar3 = (gchar *)__strdup(stock_id);
      pGVar4[gVar1].label = pgVar3;
      pGVar4 = new_entries + menuitem_cnt;
      if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
        pgVar3 = (gchar *)0x0;
        pGVar5 = pGVar4;
      }
      else {
        pgVar3 = (gchar *)__strdup(pcVar2);
        pGVar5 = new_entries + menuitem_cnt;
      }
      pGVar4->accelerator = pgVar3;
      pgVar3 = (gchar *)0x0;
      pGVar4 = pGVar5;
      if (accelerator != (char *)0x0) {
        pgVar3 = (gchar *)__strdup(accelerator);
        pGVar4 = new_entries + menuitem_cnt;
      }
      pGVar5->tooltip = pgVar3;
      pGVar4->callback = ghid_menu_cb;
      ghid_check_special_key(pcVar2,name);
      menuitem_cnt = menuitem_cnt + 1;
      return;
    }
    pcVar2 = "ghid_append_action():  realloc of action_resources failed\n";
    action_resources = (Resource **)0x0;
  }
  __fprintf_chk(stderr,1,pcVar2);
                    // WARNING: Subroutine does not return
  exit(1);
}



void __regparm3 add_resource_to_menu(char *menu,Resource *node,void *callback,int indent)

{
  int iVar1;
  gint gVar2;
  char cVar3;
  int *piVar4;
  char *v;
  Resource *pRVar5;
  Resource *r;
  char m;
  int j_1;
  size_t sVar6;
  char *pcVar7;
  gchar *pgVar8;
  char *n;
  char cVar9;
  void *callback_00;
  void *callback_01;
  gint gVar10;
  anon_enum_32 state;
  char *menulabel;
  GtkToggleActionEntry *pGVar11;
  GtkToggleActionEntry *pGVar12;
  uchar *__s1;
  int iVar13;
  char *checked;
  char *p;
  char *s2;
  int iVar14;
  int j;
  char *label;
  char **ppcVar15;
  char *pcVar16;
  char *pcVar17;
  int in_GS_OFFSET;
  bool bVar18;
  bool bVar19;
  byte bVar20;
  char *in_stack_fffffef4;
  Resource *pRVar21;
  char *pcVar22;
  int local_e0;
  char *local_d8;
  char local_d1;
  Resource *local_cc;
  int local_c4;
  int local_bc;
  int local_b4;
  int local_b0;
  char ch [2];
  char accel [64];
  char tmpid [40];
  char tmps [32];
  
  bVar20 = 0;
  ch[1] = '\0';
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (0 < *(int *)(menu + 0xc)) {
    local_b4 = 0;
    local_d1 = '\0';
    local_cc = (Resource *)0x0;
    local_d8 = (char *)0x0;
    local_bc = 0;
    do {
      piVar4 = (int *)(local_b4 + *(int *)(menu + 0x10));
      pcVar22 = (char *)piVar4[1];
      callback_00 = (void *)(~-(uint)(pcVar22 == (char *)0x0) & 10);
      iVar13 = (~-(uint)(*piVar4 == 0) & 100) + (uint)((char *)piVar4[2] != (char *)0x0) +
               (int)callback_00;
      if (iVar13 == 10) {
        bVar18 = *pcVar22 == '@';
        if (bVar18) {
          iVar13 = 0xb;
          pcVar7 = pcVar22;
          pcVar16 = "@layerview";
          do {
            if (iVar13 == 0) break;
            iVar13 = iVar13 + -1;
            bVar18 = *pcVar7 == *pcVar16;
            pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
            pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
          } while (bVar18);
          if (bVar18) {
            iVar13 = 0;
            do {
              in_stack_fffffef4 = tmpid;
              iVar14 = iVar13 + 1;
              __sprintf_chk(in_stack_fffffef4,1,0x28,"<menuitem action=\'%s%d\' />\n","LayerView",
                            iVar13);
              ghid_ui_info_indent((int)node);
              ghid_ui_info_append(tmpid);
              iVar13 = iVar14;
            } while (iVar14 != 0x16);
          }
          else {
            iVar13 = 0xb;
            pcVar7 = pcVar22;
            pcVar16 = "@layerpick";
            do {
              if (iVar13 == 0) break;
              iVar13 = iVar13 + -1;
              bVar18 = *pcVar7 == *pcVar16;
              pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
              pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
            } while (bVar18);
            if (bVar18) {
              iVar13 = 0;
              do {
                in_stack_fffffef4 = tmpid;
                iVar14 = iVar13 + 1;
                __sprintf_chk(in_stack_fffffef4,1,0x28,"<menuitem action=\'%s%d\' />\n","LayerPick",
                              iVar13);
                ghid_ui_info_indent((int)node);
                ghid_ui_info_append(tmpid);
                iVar13 = iVar14;
              } while (iVar14 != 0x12);
            }
            else {
              iVar13 = 0xd;
              pcVar7 = pcVar22;
              pcVar16 = "@routestyles";
              do {
                if (iVar13 == 0) break;
                iVar13 = iVar13 + -1;
                bVar18 = *pcVar7 == *pcVar16;
                pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
                pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
              } while (bVar18);
              if (bVar18) {
                iVar13 = 0;
                do {
                  in_stack_fffffef4 = tmpid;
                  iVar14 = iVar13 + 1;
                  __sprintf_chk(in_stack_fffffef4,1,0x28,"<menuitem action=\'%s%d\' />\n",
                                "RouteStyle",iVar13);
                  ghid_ui_info_indent((int)node);
                  ghid_ui_info_append(tmpid);
                  iVar13 = iVar14;
                } while (iVar14 != 7);
              }
              else {
                Message("GTK GUI currently ignores \"%s\" in the menu\n",pcVar22);
                in_stack_fffffef4 = "resource file.\n";
                Message("resource file.\n");
              }
            }
          }
        }
        else if ((*pcVar22 == '-') && (pcVar22[1] == '\0')) {
          ghid_ui_info_indent((int)node);
          ghid_ui_info_append("<separator/>\n");
        }
        else if (local_bc != 0) {
          pcVar22 = &DAT_00000001;
          __sprintf_chk(tmps,1,0x20,&DAT_08139f46,"MenuItem",menuitem_cnt);
          local_d8 = (char *)__strdup(tmps);
          in_stack_fffffef4 = (char *)0x0;
          ghid_append_action(tmps,*(char **)(*(int *)(menu + 0x10) + 4 + local_b4),accel,(char *)0x0
                             ,pcVar22);
          ghid_ui_info_indent((int)node);
          ghid_ui_info_append("<menuitem action=\'");
          ghid_ui_info_append(tmps);
          ghid_ui_info_append("\'/>\n");
          action_resources[menuitem_cnt + -1] = (Resource *)0x0;
        }
      }
      else if (iVar13 == 0x65) {
        add_resource_to_menu
                  ((char *)piVar4[2],(Resource *)((int)&node->user_ptr + 1),callback_00,
                   (int)in_stack_fffffef4);
      }
      else if (iVar13 == 1) {
        accel[0] = '\0';
        pcVar22 = resource_value(*(Resource **)(*(int *)(menu + 0x10) + 8 + local_b4),"m");
        if (pcVar22 != (char *)0x0) {
          local_d1 = *pcVar22;
        }
        pRVar5 = resource_subres(*(Resource **)(*(int *)(menu + 0x10) + 8 + local_b4),"a");
        if (pRVar5 != (Resource *)0x0) {
          bVar18 = true;
          pcVar22 = pRVar5->v[1].value;
LAB_08107480:
          cVar3 = *pcVar22;
          if (cVar3 != '\0') {
            while (bVar18) {
              bVar19 = cVar3 == ' ';
              if (bVar19) {
                pcVar22 = pcVar22 + 1;
                goto LAB_08107480;
              }
              iVar13 = 5;
              pcVar7 = pcVar22;
              pcVar16 = "<Key>";
              do {
                if (iVar13 == 0) break;
                iVar13 = iVar13 + -1;
                bVar19 = *pcVar7 == *pcVar16;
                pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
                pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
              } while (bVar19);
              if (bVar19) goto LAB_0810772e;
              iVar13 = 4;
              pcVar7 = pcVar22;
              pcVar16 = "Ctrl";
              do {
                if (iVar13 == 0) break;
                iVar13 = iVar13 + -1;
                bVar19 = *pcVar7 == *pcVar16;
                pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
                pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
              } while (bVar19);
              if (bVar19) {
                pcVar22 = pcVar22 + 4;
                __strncat_chk(accel,"<control>",0x40,0x40);
                goto LAB_08107480;
              }
              iVar13 = 5;
              pcVar7 = pcVar22;
              pcVar16 = "Shift";
              do {
                if (iVar13 == 0) break;
                iVar13 = iVar13 + -1;
                bVar19 = *pcVar7 == *pcVar16;
                pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
                pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
              } while (bVar19);
              if (bVar19) {
                pcVar22 = pcVar22 + 5;
                __strncat_chk(accel,"<shift>",0x40,0x40);
                goto LAB_08107480;
              }
              iVar13 = 3;
              pcVar7 = pcVar22;
              pcVar16 = "Alt";
              do {
                if (iVar13 == 0) break;
                iVar13 = iVar13 + -1;
                bVar19 = *pcVar7 == *pcVar16;
                pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
                pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
              } while (bVar19);
              if (!bVar19) {
                pcVar7 = pcVar22;
                Message("Don\'t know how to parse \"%s\" as an accelerator in the menu resource file.\n"
                        ,pcVar22);
                if (add_resource_to_menu::lexical_block_0::lexical_block_0_0::gave_msg == 0) {
                  add_resource_to_menu::lexical_block_0::lexical_block_0_0::gave_msg = 1;
                  Message("Format is:\nmodifiers<Key>k\nwhere \"modifiers\" is a space separated list of key modifiers\nand \"k\" is the name of the key.\nAllowed modifiers are:\n   Ctrl\n   Shift\n   Alt\nPlease note that case is important.\n"
                          ,pcVar7);
                }
                accel[0] = '\0';
                sVar6 = strlen(pcVar22);
                pcVar22 = pcVar22 + sVar6;
                goto LAB_08107480;
              }
              pcVar22 = pcVar22 + 3;
              __strncat_chk(accel,"<alt>",0x40,0x40);
              cVar3 = *pcVar22;
              if (cVar3 == '\0') goto LAB_08107530;
            }
            iVar13 = 5;
            pcVar7 = pcVar22;
            pcVar16 = "Enter";
            do {
              if (iVar13 == 0) break;
              iVar13 = iVar13 + -1;
              bVar18 = *pcVar7 == *pcVar16;
              pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
              pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
            } while (bVar18);
            if (bVar18) {
              __strncat_chk(accel,"Return",0x40,0x40);
LAB_0810772e:
              pcVar22 = pcVar22 + 5;
              bVar18 = false;
            }
            else {
              iVar13 = 0;
              do {
                ch[0] = cVar3;
                if (key_table[iVar13].in == *pcVar22) {
                  __strncat_chk(accel,key_table[iVar13].out,0x40,0x40);
                  goto LAB_081076fe;
                }
                iVar13 = iVar13 + 1;
              } while (iVar13 != 7);
              __strncat_chk(accel,ch,0x40,0x40);
LAB_081076fe:
              pcVar22 = pcVar22 + 1;
              bVar18 = false;
            }
            goto LAB_08107480;
          }
        }
LAB_08107530:
        iVar13 = *(int *)(*(int *)(menu + 0x10) + 8 + local_b4);
        iVar14 = *(int *)(iVar13 + 0xc);
        if (0 < iVar14) {
          piVar4 = *(int **)(iVar13 + 0x10);
          iVar13 = 0;
          do {
            pcVar22 = (char *)piVar4[1];
            if ((~-(uint)(*piVar4 == 0) & 100) + (uint)(piVar4[2] != 0) +
                (~-(uint)(pcVar22 == (char *)0x0) & 10) == 10) goto joined_r0x081075b5;
            iVar13 = iVar13 + 1;
            piVar4 = piVar4 + 3;
          } while (iVar13 < iVar14);
        }
        pcVar22 = "button";
joined_r0x081075b5:
        if (local_d1 == '\0') {
          local_cc = (Resource *)__strdup(pcVar22);
        }
        else {
          sVar6 = strlen(pcVar22);
          local_cc = (Resource *)calloc(1,sVar6 + 2);
          if (local_cc == (Resource *)0x0) {
            pcVar22 = "add_resource_to_menu():  malloc failed\n";
            goto LAB_081080c9;
          }
          cVar3 = *pcVar22;
          pRVar5 = local_cc;
          while (cVar3 != '\0') {
            while (local_d1 == cVar3) {
              *(undefined *)&pRVar5->parent = 0x5f;
              cVar3 = *pcVar22;
              pcVar22 = pcVar22 + 1;
              local_d1 = '\0';
              *(char *)((int)&pRVar5->parent + 1) = cVar3;
              cVar3 = *pcVar22;
              pRVar5 = (Resource *)((int)&pRVar5->parent + 2);
              if (cVar3 == '\0') goto LAB_0810794b;
            }
            pcVar22 = pcVar22 + 1;
            *(char *)&pRVar5->parent = cVar3;
            pRVar5 = (Resource *)((int)&pRVar5->parent + 1);
            cVar3 = *pcVar22;
          }
LAB_0810794b:
          *(undefined *)&pRVar5->parent = 0;
        }
        pRVar5 = *(Resource **)(*(int *)(menu + 0x10) + 8 + local_b4);
        if ((*(byte *)&pRVar5->flags & 4) == 0) {
          pcVar7 = resource_value(pRVar5,"checked");
          pcVar22 = resource_value(*(Resource **)(*(int *)(menu + 0x10) + 8 + local_b4),"sensitive")
          ;
          pRVar5 = *(Resource **)(*(int *)(menu + 0x10) + 8 + local_b4);
          in_stack_fffffef4 = resource_value(pRVar5,"tip");
          if (pcVar7 == (char *)0x0) {
            bVar18 = pcVar22 == (char *)0x0;
            if (!bVar18) {
              iVar13 = 6;
              pcVar7 = "false";
              do {
                if (iVar13 == 0) break;
                iVar13 = iVar13 + -1;
                bVar18 = *pcVar22 == *pcVar7;
                pcVar22 = pcVar22 + (uint)bVar20 * -2 + 1;
                pcVar7 = pcVar7 + (uint)bVar20 * -2 + 1;
              } while (bVar18);
              if (bVar18) {
                local_c4 = *(int *)(menu + 0x10);
                in_stack_fffffef4 = (char *)pRVar5;
                goto LAB_08107b7c;
              }
            }
            pcVar22 = &DAT_00000001;
            __sprintf_chk(tmps,1,0x20,&DAT_08139f46,"MenuItem",menuitem_cnt);
            local_d8 = (char *)__strdup(tmps);
            ghid_append_action(tmps,(char *)local_cc,accel,in_stack_fffffef4,pcVar22);
            ghid_ui_info_indent((int)node);
            ghid_ui_info_append("<menuitem action=\'");
            ghid_ui_info_append(tmps);
            ghid_ui_info_append("\'/>\n");
            local_c4 = *(int *)(menu + 0x10);
            action_resources[menuitem_cnt + -1] = *(Resource **)(local_c4 + 8 + local_b4);
          }
          else {
            __sprintf_chk(tmps,1,0x20,&DAT_08139f46,"TMenuItem",tmenuitem_cnt);
            local_d8 = (char *)__strdup(tmps);
            pRVar5 = (Resource *)ghid_check_unique_accel(accel);
            new_toggle_entries =
                 (GtkToggleActionEntry *)realloc(new_toggle_entries,(tmenuitem_cnt + 1) * 0x1c);
            if (new_toggle_entries == (GtkToggleActionEntry *)0x0) {
              pcVar22 = "ghid_append_toggle_action():  realloc of new_toggle_entries failed\n";
LAB_081080c9:
              __fprintf_chk(stderr,1,pcVar22);
                    // WARNING: Subroutine does not return
              exit(1);
            }
            toggle_action_resources =
                 (Resource **)realloc(toggle_action_resources,tmenuitem_cnt * 4 + 4);
            gVar10 = tmenuitem_cnt;
            if (toggle_action_resources == (Resource **)0x0) {
              pcVar22 = "ghid_append_toggle_action():  realloc of toggle_action_resources failed\n";
              goto LAB_081080c9;
            }
            toggle_action_resources[tmenuitem_cnt] = (Resource *)0x0;
            pGVar11 = new_toggle_entries + gVar10;
            pgVar8 = (gchar *)__strdup(tmps);
            pGVar11->name = pgVar8;
            pGVar11 = new_toggle_entries;
            gVar10 = tmenuitem_cnt;
            new_toggle_entries[tmenuitem_cnt].stock_id = (gchar *)0x0;
            pRVar21 = local_cc;
            pgVar8 = (gchar *)__strdup();
            pGVar12 = new_toggle_entries;
            gVar2 = tmenuitem_cnt;
            pGVar11[gVar10].label = pgVar8;
            pgVar8 = (gchar *)0x0;
            gVar10 = gVar2;
            pGVar11 = pGVar12;
            if (pRVar5 != (Resource *)0x0) {
              pRVar21 = pRVar5;
              pgVar8 = (gchar *)__strdup();
              gVar10 = tmenuitem_cnt;
              pGVar11 = new_toggle_entries;
            }
            pGVar12[gVar2].accelerator = pgVar8;
            pgVar8 = (gchar *)0x0;
            iVar13 = gVar10;
            pGVar12 = pGVar11;
            if ((Resource *)in_stack_fffffef4 != (Resource *)0x0) {
              pgVar8 = (gchar *)__strdup();
              iVar13 = tmenuitem_cnt;
              pGVar12 = new_toggle_entries;
              pRVar21 = (Resource *)in_stack_fffffef4;
            }
            pGVar12[iVar13].callback = ghid_menu_cb;
            pGVar12[iVar13].is_active = 1;
            pGVar11[gVar10].tooltip = pgVar8;
            ghid_check_special_key((char *)pRVar5,tmps);
            tmenuitem_cnt = tmenuitem_cnt + 1;
            ghid_ui_info_indent((int)node);
            ghid_ui_info_append("<menuitem action=\'");
            ghid_ui_info_append(tmps);
            ghid_ui_info_append("\'/>\n");
            local_c4 = *(int *)(menu + 0x10);
            toggle_action_resources[tmenuitem_cnt + -1] = *(Resource **)(local_c4 + 8 + local_b4);
            in_stack_fffffef4 = (char *)pRVar21;
          }
LAB_08107b7c:
          iVar13 = *(int *)(local_c4 + 8 + local_b4);
          if (0 < *(int *)(iVar13 + 0xc)) {
            local_b0 = 0;
            local_e0 = 0;
            do {
              ppcVar15 = (char **)(local_e0 + *(int *)(iVar13 + 0x10));
              pcVar22 = *ppcVar15;
              pcVar7 = ppcVar15[1];
              if ((~-(uint)(pcVar22 == (char *)0x0) & 100) + (uint)(ppcVar15[2] != (char *)0x0) +
                  (~-(uint)(pcVar7 == (char *)0x0) & 10) == 0x6e) {
                cVar3 = *pcVar22;
                if (((cVar3 == 'f') && (pcVar22[1] == 'g')) && (pcVar22[2] == '\0')) {
                  cVar3 = 'f';
                  pcVar22 = "foreground";
                }
                cVar9 = cVar3;
                if (((cVar3 == 'b') && (cVar9 = 'b', pcVar22[1] == 'g')) &&
                   (cVar9 = cVar3, pcVar22[2] == '\0')) {
                  pcVar22 = "background";
                  cVar9 = 'b';
                }
                if (((cVar9 != 'm') || (pcVar22[1] != '\0')) &&
                   ((bVar18 = cVar9 == 'a', !bVar18 || (bVar18 = pcVar22[1] == '\0', !bVar18)))) {
                  iVar13 = 10;
                  pcVar16 = pcVar22;
                  pcVar17 = "sensitive";
                  do {
                    if (iVar13 == 0) break;
                    iVar13 = iVar13 + -1;
                    bVar18 = *pcVar16 == *pcVar17;
                    pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
                    pcVar17 = pcVar17 + (uint)bVar20 * -2 + 1;
                  } while (bVar18);
                  if ((!bVar18) &&
                     ((((bVar18 = cVar9 == 't', !bVar18 || (bVar18 = pcVar22[1] == 'i', !bVar18)) ||
                       (bVar18 = pcVar22[2] == 'p', !bVar18)) ||
                      (bVar18 = pcVar22[3] == '\0', !bVar18)))) {
                    iVar13 = 8;
                    pcVar16 = pcVar22;
                    pcVar17 = "checked";
                    do {
                      if (iVar13 == 0) break;
                      iVar13 = iVar13 + -1;
                      bVar18 = *pcVar16 == *pcVar17;
                      pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
                      pcVar17 = pcVar17 + (uint)bVar20 * -2 + 1;
                    } while (bVar18);
                    if (bVar18) {
                      note_toggle_flag(new_toggle_entries[tmenuitem_cnt + -1].name,GHID_FLAG_CHECKED
                                       ,pcVar7);
                      local_c4 = *(int *)(menu + 0x10);
                    }
                    else {
                      iVar13 = 7;
                      pcVar16 = "active";
                      do {
                        if (iVar13 == 0) break;
                        iVar13 = iVar13 + -1;
                        bVar18 = *pcVar22 == *pcVar16;
                        pcVar22 = pcVar22 + (uint)bVar20 * -2 + 1;
                        pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
                      } while (bVar18);
                      if (bVar18) {
                        if (local_d8 == (char *)0x0) {
                          in_stack_fffffef4 = &DAT_00000001;
                          __printf_chk(1,"WARNING: %s cname == NULL\n","add_resource_to_menu");
                          local_c4 = *(int *)(menu + 0x10);
                        }
                        else {
                          note_toggle_flag(local_d8,GHID_FLAG_ACTIVE,pcVar7);
                          local_c4 = *(int *)(menu + 0x10);
                        }
                      }
                      else {
                        Message("The gtk gui currently ignores \"%s\"",pcVar7);
                        in_stack_fffffef4 =
                             "as part of a menuitem resource.\nFeel free to provide patches\n";
                        Message("as part of a menuitem resource.\nFeel free to provide patches\n");
                        local_c4 = *(int *)(menu + 0x10);
                      }
                    }
                  }
                }
              }
              local_b0 = local_b0 + 1;
              local_e0 = local_e0 + 0xc;
              iVar13 = *(int *)(local_c4 + 8 + local_b4);
            } while (local_b0 < *(int *)(iVar13 + 0xc));
          }
        }
        else {
          pcVar22 = &DAT_00000001;
          __sprintf_chk(tmps,1,0x20,&DAT_08139f46,"MenuItem",menuitem_cnt);
          local_d8 = (char *)__strdup(tmps);
          in_stack_fffffef4 = (char *)0x0;
          ghid_append_action(tmps,(char *)local_cc,accel,(char *)0x0,pcVar22);
          ghid_ui_info_indent((int)node);
          ghid_ui_info_append("<menu action=\'");
          ghid_ui_info_append(tmps);
          ghid_ui_info_append("\'>\n");
          add_resource_to_menu
                    (*(char **)(*(int *)(menu + 0x10) + 8 + local_b4),
                     (Resource *)((int)&node->user_ptr + 1),callback_01,(int)in_stack_fffffef4);
          ghid_ui_info_indent((int)node);
          ghid_ui_info_append("</menu>\n");
        }
      }
      local_bc = local_bc + 1;
      local_b4 = local_b4 + 0xc;
    } while (local_bc < *(int *)(menu + 0xc));
    if (local_d8 != (char *)0x0) {
      free(local_d8);
    }
    if (local_cc != (Resource *)0x0) {
      free(local_cc);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 make_top_menubar(GtkWidget *hbox,GHidPort *port)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkUIManager *pGVar4;
  GtkActionGroup *pGVar5;
  Resource *pRVar6;
  char *pcVar7;
  gchar *pgVar8;
  undefined4 uVar9;
  Resource *ar;
  int iVar10;
  GtkToggleActionEntry *pGVar11;
  int i;
  int iVar12;
  int iVar13;
  int in_GS_OFFSET;
  int local_74;
  char *local_68;
  int local_64;
  char av [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_64 = 0;
  uVar2 = gtk_frame_new(0);
  uVar3 = gtk_box_get_type();
  iVar10 = 0;
  uVar3 = g_type_check_instance_cast(hbox,uVar3);
  gtk_box_pack_start(uVar3,uVar2,0,1,0);
  uVar3 = gtk_frame_get_type();
  uVar3 = g_type_check_instance_cast(uVar2,uVar3);
  gtk_frame_set_shadow_type(uVar3,4);
  pGVar4 = (GtkUIManager *)gtk_ui_manager_new();
  ghidgui->ui_manager = pGVar4;
  pGVar5 = (GtkActionGroup *)gtk_action_group_new("Actions");
  gtk_action_group_set_translation_domain(pGVar5,0);
  ghidgui->main_actions = pGVar5;
  gtk_action_group_add_actions(pGVar5,new_entries,menuitem_cnt,&ghid_port);
  gtk_action_group_add_toggle_actions(pGVar5,new_toggle_entries,tmenuitem_cnt,&ghid_port);
  local_74 = 0;
  do {
    layer_process((gchar **)0x0,&local_68,(int *)0x0,local_74);
    uVar3 = g_strdup_printf(&DAT_08139f46,"LayerView",local_74);
    *(undefined4 *)((int)&layerview_toggle_entries[0].stock_id + iVar10) = 0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].name + iVar10) = uVar3;
    uVar3 = g_strdup(local_68);
    *(undefined4 *)((int)&layerview_toggle_entries[0].accelerator + iVar10) = 0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].tooltip + iVar10) = 0;
    *(code **)((int)&layerview_toggle_entries[0].callback + iVar10) = ghid_menu_cb;
    *(undefined4 *)((int)&layerview_toggle_entries[0].is_active + iVar10) = 0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].label + iVar10) = uVar3;
    pRVar6 = resource_create((Resource *)0x0);
    iVar12 = local_74 + 1;
    __sprintf_chk(av,1,0x40,"ToggleView(%d)",iVar12);
    pcVar7 = (char *)__strdup(av);
    resource_add_val(pRVar6,(char *)0x0,pcVar7,(Resource *)0x0);
    pcVar7 = (char *)__strdup(av);
    resource_add_val(pRVar6,(char *)0x0,pcVar7,(Resource *)0x0);
    pRVar6->flags = pRVar6->flags | 1;
    *(Resource **)(&DAT_0818e8dc + iVar12 * 4) = pRVar6;
    iVar13 = local_74;
    uVar3 = g_strdup_printf(&DAT_08139f46,"LayerPick",local_74);
    *(undefined4 *)((int)&layerpick_toggle_entries[0].stock_id + iVar10) = 0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].name + iVar10) = uVar3;
    uVar3 = g_strdup(local_68);
    *(undefined4 *)((int)&layerpick_toggle_entries[0].accelerator + iVar10) = 0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].tooltip + iVar10) = 0;
    *(code **)((int)&layerpick_toggle_entries[0].callback + iVar10) = ghid_menu_cb;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].is_active + iVar10) = 0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].label + iVar10) = uVar3;
    pRVar6 = resource_create((Resource *)0x0);
    if (local_74 == 0x10) {
      __sprintf_chk(av,1,0x40,"SelectLayer(Silk) LayersChanged()");
    }
    else if (local_74 == 0x11) {
      __sprintf_chk(av,1,0x40,"SelectLayer(Rats) LayersChanged()");
    }
    else {
      if (local_74 < 9) {
        uVar3 = g_strdup_printf("<Key>%d",iVar12,iVar13);
        *(undefined4 *)((int)&layerpick_toggle_entries[0].accelerator + iVar10) = uVar3;
      }
      __sprintf_chk(av,1,0x40,"SelectLayer(%d) LayersChanged()",iVar12);
    }
    iVar10 = iVar10 + 0x1c;
    pcVar7 = (char *)__strdup(av);
    resource_add_val(pRVar6,(char *)0x0,pcVar7,(Resource *)0x0);
    pcVar7 = (char *)__strdup(av);
    resource_add_val(pRVar6,(char *)0x0,pcVar7,(Resource *)0x0);
    pRVar6->flags = pRVar6->flags | 1;
    *(Resource **)(&DAT_0818ebbc + iVar12 * 4) = pRVar6;
    local_74 = iVar12;
  } while (iVar12 != 0x16);
  pGVar11 = routestyle_toggle_entries;
  iVar10 = 0;
  do {
    pgVar8 = (gchar *)g_strdup_printf(&DAT_08139f46,"RouteStyle",iVar10);
    pGVar11->stock_id = (gchar *)0x0;
    pGVar11->name = pgVar8;
    if ((iVar10 < 4) && (PCB != (PCBTypePtr)0x0)) {
      pgVar8 = (gchar *)g_strdup(PCB->RouteStyle[iVar10].Name);
      pGVar11->label = pgVar8;
    }
    else {
      pgVar8 = (gchar *)g_strdup(pGVar11->name);
      pGVar11->label = pgVar8;
    }
    pGVar11->accelerator = (gchar *)0x0;
    iVar13 = iVar10 + 1;
    pGVar11->tooltip = (gchar *)0x0;
    pGVar11->callback = ghid_menu_cb;
    pGVar11->is_active = 0;
    pGVar11 = pGVar11 + 1;
    pRVar6 = resource_create((Resource *)0x0);
    __sprintf_chk(av,1,0x40,"RouteStyle(%d)",iVar13);
    pcVar7 = (char *)__strdup(av);
    resource_add_val(pRVar6,(char *)0x0,pcVar7,(Resource *)0x0);
    pcVar7 = (char *)__strdup(av);
    resource_add_val(pRVar6,(char *)0x0,pcVar7,(Resource *)0x0);
    pRVar6->flags = pRVar6->flags | 1;
    (&routestyle_toggle_entries[7].name)[iVar10] = (gchar *)pRVar6;
    iVar10 = iVar13;
  } while (iVar13 != 7);
  gtk_action_group_add_toggle_actions(pGVar5,layerpick_toggle_entries,0x16,&ghid_port);
  gtk_action_group_add_toggle_actions(pGVar5,layerview_toggle_entries,0x16,&ghid_port);
  gtk_action_group_add_toggle_actions(pGVar5,routestyle_toggle_entries,7,&ghid_port);
  gtk_ui_manager_insert_action_group(pGVar4,pGVar5,0);
  uVar3 = gtk_ui_manager_get_accel_group(pGVar4);
  uVar9 = gtk_window_get_type();
  uVar9 = g_type_check_instance_cast(gport->top_window,uVar9);
  gtk_window_add_accel_group(uVar9,uVar3);
  iVar10 = gtk_ui_manager_add_ui_from_string(pGVar4,new_ui_info,0xffffffff,&local_64);
  if (iVar10 == 0) {
    g_log(0,0x20,"building menus failed: %s",*(undefined4 *)(local_64 + 8));
    g_error_free(local_64);
  }
  gtk_ui_manager_set_add_tearoffs(pGVar4,1);
  uVar3 = gtk_ui_manager_get_widget(pGVar4,"/MenuBar");
  uVar9 = gtk_container_get_type();
  uVar2 = g_type_check_instance_cast(uVar2,uVar9);
  gtk_container_add(uVar2,uVar3);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_create_pcb_widgets(void)

{
  int iVar1;
  GtkWidget *pGVar2;
  GhidGui *pGVar3;
  GdkPixbuf *pGVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  GtkWidget *pGVar8;
  undefined4 uVar9;
  GtkWidget *pGVar10;
  int iVar11;
  int i_1;
  Resource *res;
  Resource *menu;
  Resource *mr;
  Resource *pRVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  GtkWidget *pGVar15;
  GtkWidget *pGVar16;
  GtkWidget *ebox_1;
  gchar *pgVar17;
  GdkPixbuf *pixbuf;
  undefined4 uVar18;
  GtkObject *pGVar19;
  void *callback;
  int *piVar20;
  GtkWidget *image;
  void *callback_00;
  char *pcVar21;
  GHidPort *extraout_EDX;
  GHidPort *pGVar22;
  gchar *s;
  GHidPort *extraout_EDX_00;
  GtkWidget *button_2;
  GtkWidget *button_1;
  RouteStyleButton *pRVar23;
  char *filename;
  GtkWidget *frame;
  GtkWidget *vbox;
  GtkWidget *label;
  GtkWidget *label_1;
  GtkWidget *frame_1;
  GtkWidget *ebox;
  GtkWidget *hbox_1;
  LayerButtonSet *lb;
  ModeButton *pMVar24;
  GtkWidget *button;
  gint i;
  GtkWidget *hbox;
  Resource *pRVar25;
  Resource *r;
  GtkWidget *button_3;
  int in_GS_OFFSET;
  ulonglong uVar26;
  undefined8 uVar27;
  undefined8 uVar28;
  float fVar29;
  undefined4 local_90;
  undefined4 local_7c;
  int local_78;
  int local_74;
  int local_70;
  undefined4 local_6c;
  GtkWidget *local_64;
  int local_60;
  int local_54;
  gchar *local_50;
  gchar *local_4c;
  GtkWidget *scrolled;
  int local_44;
  gchar buf [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_44 = 0;
  gdk_color_parse("white");
  gdk_color_parse("black");
  pGVar3 = ghidgui;
  if (bg_image_file != (gchar *)0x0) {
    pGVar4 = (GdkPixbuf *)gdk_pixbuf_new_from_file(bg_image_file);
    pGVar3->bg_pixbuf = pGVar4;
  }
  if (local_44 != 0) {
    g_log(0,4,*(undefined4 *)(local_44 + 8));
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  pGVar2 = gport->top_window;
  uVar5 = gtk_vbox_new(0);
  uVar6 = gtk_container_get_type();
  uVar7 = g_type_check_instance_cast(pGVar2);
  gtk_container_add(uVar7);
  pGVar8 = (GtkWidget *)gtk_hbox_new(0);
  uVar7 = gtk_box_get_type();
  uVar9 = g_type_check_instance_cast(uVar5);
  gtk_box_pack_start(uVar9,pGVar8,0,0,0);
  pGVar3 = ghidgui;
  ghidgui->top_hbox = pGVar8;
  pGVar8 = (GtkWidget *)gtk_hbox_new(0);
  pGVar3->menu_hbox = pGVar8;
  pGVar8 = ghidgui->menu_hbox;
  uVar9 = g_type_check_instance_cast(ghidgui->top_hbox);
  gtk_box_pack_start(uVar9,pGVar8,0,0,0);
  pGVar8 = (GtkWidget *)gtk_vbox_new(0);
  uVar9 = g_type_check_instance_cast(ghidgui->menu_hbox);
  gtk_box_pack_start(uVar9,pGVar8,0,0,0);
  pGVar10 = (GtkWidget *)gtk_hbox_new(0);
  uVar9 = g_type_check_instance_cast(pGVar8);
  gtk_box_pack_start(uVar9,pGVar10,0,0,0);
  iVar11 = 0;
  do {
    ghid_hotkey_actions[iVar11] = (char *)0x0;
    iVar11 = iVar11 + 1;
  } while (iVar11 != 0x100);
  if (homedir == (char *)0x0) {
    filename = (char *)0x0;
    Message("Warning:  could not determine home directory\n");
  }
  else {
    Message("Note:  home directory is \"%s\"\n");
    filename = Concat(homedir);
  }
  iVar11 = access("gpcb-menu.res",4);
  pcVar21 = "gpcb-menu.res";
  if ((iVar11 != 0) &&
     ((filename == (char *)0x0 || (iVar11 = access(filename,4), pcVar21 = filename, iVar11 != 0))))
  {
    iVar11 = access(pcbmenu_path,4);
    pcVar21 = (char *)0x0;
    if (iVar11 == 0) {
      pcVar21 = pcbmenu_path;
    }
  }
  res = resource_parse((char *)0x0,gpcb_menu_default);
  if (res == (Resource *)0x0) {
    __fprintf_chk(stderr,1,"Error: internal menu resource didn\'t parse\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  pRVar25 = (Resource *)0x0;
  if (pcVar21 != (char *)0x0) {
    pRVar25 = resource_parse(pcVar21,(char **)0x0);
  }
  if (filename != (char *)0x0) {
    free(filename);
  }
  if (pRVar25 == (Resource *)0x0) {
    pRVar25 = res;
  }
  pRVar12 = pRVar25;
  menu = resource_subres(pRVar25,"MainMenu");
  if ((menu != (Resource *)0x0) ||
     (pRVar12 = res, menu = resource_subres(res,"MainMenu"), menu != (Resource *)0x0)) {
    ghid_ui_info_append("<ui>\n");
    ghid_ui_info_indent(5);
    ghid_ui_info_append("<menubar name=\'MenuBar\'>\n");
    add_resource_to_menu((char *)menu,(Resource *)0xa,callback,(int)pRVar12);
    ghid_ui_info_indent(5);
    ghid_ui_info_append("</menubar>\n");
  }
  uVar26 = ZEXT48(pRVar25);
  pRVar12 = resource_subres(pRVar25,"PopupMenus");
  if (pRVar12 == (Resource *)0x0) {
    uVar26 = ZEXT48(res);
    pRVar12 = resource_subres(res,"PopupMenus");
    if (pRVar12 == (Resource *)0x0) goto LAB_08108b48;
  }
  local_78 = pRVar12->c;
  local_70 = 0;
  for (local_74 = 0; local_74 < local_78; local_74 = local_74 + 1) {
    piVar20 = (int *)((int)&pRVar12->v->name + local_70);
    if ((~-(uint)(*piVar20 == 0) & 100) + (uint)(piVar20[2] != 0) + (~-(uint)(piVar20[1] == 0) & 10)
        == 0x65) {
      ghid_ui_info_indent(5);
      ghid_ui_info_append("<popup name=\'");
      ghid_ui_info_append(*(gchar **)((int)&pRVar12->v->name + local_70));
      ghid_ui_info_append("\'>\n");
      add_resource_to_menu
                (*(char **)((int)&pRVar12->v->subres + local_70),(Resource *)0xa,callback_00,
                 (int)uVar26);
      ghid_ui_info_indent(5);
      ghid_ui_info_append("</popup>\n");
      local_78 = pRVar12->c;
    }
    local_70 = local_70 + 0xc;
  }
LAB_08108b48:
  ghid_ui_info_append("</ui>\n");
  pRVar25 = resource_subres(pRVar25,"Mouse");
  if ((pRVar25 != (Resource *)0x0) ||
     (pRVar25 = resource_subres(res,"Mouse"), pGVar22 = extraout_EDX_00, pRVar25 != (Resource *)0x0)
     ) {
    load_mouse_resource(pRVar25);
    pGVar22 = extraout_EDX;
  }
  make_top_menubar(pGVar10,pGVar22);
  pGVar10 = (GtkWidget *)gtk_frame_new(0);
  gtk_widget_show(pGVar10);
  uVar9 = g_type_check_instance_cast(pGVar10);
  g_object_ref(uVar9);
  pGVar3 = ghidgui;
  ghidgui->mode_buttons1_vbox = pGVar8;
  pGVar3->mode_buttons1_frame = pGVar10;
  pGVar8 = (GtkWidget *)gtk_hbox_new(0);
  pGVar3->mode_buttons1_hbox = pGVar8;
  uVar9 = g_type_check_instance_cast(pGVar10);
  gtk_container_add(uVar9);
  uVar9 = gtk_vbox_new(0);
  uVar13 = g_type_check_instance_cast(ghidgui->top_hbox);
  gtk_box_pack_end(uVar13,uVar9,0,0,0);
  pGVar3 = ghidgui;
  pGVar8 = (GtkWidget *)gtk_vbox_new(0);
  pGVar3->compact_vbox = pGVar8;
  pGVar8 = ghidgui->compact_vbox;
  uVar13 = g_type_check_instance_cast(ghidgui->top_hbox);
  gtk_box_pack_end(uVar13,pGVar8,0,0,0);
  pGVar3 = ghidgui;
  pGVar8 = (GtkWidget *)gtk_hbox_new(0);
  pGVar3->compact_hbox = pGVar8;
  pGVar8 = ghidgui->compact_hbox;
  uVar9 = g_type_check_instance_cast(uVar9);
  gtk_box_pack_start(uVar9,pGVar8,1,0,0);
  pGVar8 = (GtkWidget *)gtk_hbox_new(0);
  uVar9 = g_type_check_instance_cast(ghidgui->compact_vbox);
  gtk_box_pack_start(uVar9,pGVar8,1,0,2);
  ghidgui->label_hbox = pGVar8;
  pGVar10 = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  gtk_label_get_type();
  uVar9 = g_type_check_instance_cast(pGVar10);
  gtk_label_set_use_markup(uVar9);
  if (ghidgui->name_label_string == (gchar *)0x0) {
    s = (gchar *)g_strdup("<b><big>%s</big></b>");
  }
  else {
    s = (gchar *)g_strdup_printf(" <b><big>%s</big></b> ");
  }
  uVar9 = g_type_check_instance_cast(pGVar10);
  gtk_label_set_markup(uVar9);
  g_free(s);
  uVar9 = g_type_check_instance_cast(pGVar8);
  gtk_box_pack_start(uVar9,pGVar10,0,1,4);
  pGVar3 = ghidgui;
  ghidgui->name_label = pGVar10;
  pGVar8 = (GtkWidget *)gtk_hbox_new(0);
  pGVar3->position_hbox = pGVar8;
  uVar9 = g_type_check_instance_cast(ghidgui->position_hbox);
  g_object_ref(uVar9);
  if (ghidgui->compact_horizontal == 0) {
    pGVar8 = ghidgui->position_hbox;
    uVar9 = g_type_check_instance_cast(ghidgui->compact_hbox);
    gtk_box_pack_end(uVar9,pGVar8,0,0,4);
  }
  else {
    pGVar8 = ghidgui->position_hbox;
    uVar9 = g_type_check_instance_cast(ghidgui->compact_vbox);
    gtk_box_pack_end(uVar9,pGVar8,1,0,0);
  }
  pGVar8 = ghidgui->position_hbox;
  uVar9 = gtk_button_new();
  pGVar10 = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  uVar13 = g_type_check_instance_cast(pGVar10);
  gtk_label_set_markup(uVar13);
  ghidgui->grid_units_label = pGVar10;
  uVar13 = g_type_check_instance_cast(pGVar10);
  gtk_label_set_use_markup(uVar13);
  uVar13 = g_type_check_instance_cast(uVar9);
  gtk_container_add(uVar13);
  uVar13 = g_type_check_instance_cast(pGVar8);
  gtk_box_pack_end(uVar13,uVar9,0,1,0);
  uVar9 = g_type_check_instance_cast(uVar9);
  g_signal_connect_data(uVar9,"clicked",grid_units_button_cb,0,0,0);
  uVar9 = gtk_frame_new(0);
  uVar13 = g_type_check_instance_cast(pGVar8);
  gtk_box_pack_end(uVar13,uVar9,0,1,0);
  uVar13 = g_type_check_instance_cast(uVar9);
  gtk_container_set_border_width(uVar13);
  gtk_frame_get_type();
  uVar13 = g_type_check_instance_cast(uVar9);
  gtk_frame_set_shadow_type(uVar13);
  pGVar10 = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  uVar9 = g_type_check_instance_cast(uVar9);
  gtk_container_add(uVar9);
  ghidgui->cursor_position_absolute_label = pGVar10;
  uVar9 = g_type_check_instance_cast(pGVar10);
  g_signal_connect_data(uVar9,"size-request",absolute_label_size_req_cb,0,0,0);
  uVar9 = gtk_frame_new(0);
  uVar13 = g_type_check_instance_cast(pGVar8);
  gtk_box_pack_end(uVar13,uVar9,0,1,0);
  uVar13 = g_type_check_instance_cast(uVar9);
  gtk_container_set_border_width(uVar13);
  uVar13 = g_type_check_instance_cast(uVar9);
  gtk_frame_set_shadow_type(uVar13);
  pGVar8 = (GtkWidget *)gtk_label_new(" __.__  __.__ ");
  uVar9 = g_type_check_instance_cast(uVar9);
  gtk_container_add(uVar9);
  ghidgui->cursor_position_relative_label = pGVar8;
  uVar9 = g_type_check_instance_cast(pGVar8);
  g_signal_connect_data(uVar9,"size-request",relative_label_size_req_cb,0,0,0);
  uVar9 = gtk_hbox_new(0);
  uVar13 = g_type_check_instance_cast(uVar5);
  gtk_box_pack_start(uVar13,uVar9,1,1,3);
  pGVar8 = (GtkWidget *)gtk_event_box_new();
  gtk_widget_set_events(pGVar8);
  uVar13 = g_type_check_instance_cast(uVar9);
  gtk_box_pack_start(uVar13,pGVar8,0,0,3);
  ghid_left_sensitive_box = pGVar8;
  pGVar10 = (GtkWidget *)gtk_vbox_new(0);
  uVar13 = g_type_check_instance_cast(pGVar8);
  gtk_container_add(uVar13);
  ghid_scrolled_vbox(pGVar10,&scrolled,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC);
  local_54 = 1;
  uVar13 = gtk_hbox_new(0);
  iVar11 = 0;
  uVar14 = g_type_check_instance_cast();
  gtk_box_pack_start(uVar14,uVar13,0,0,4);
  uVar13 = gtk_table_new(0x16);
  uVar14 = g_type_check_instance_cast();
  gtk_box_pack_start(uVar14,uVar13,0,0,3);
  gtk_table_get_type();
  gtk_toggle_button_get_type();
  gtk_radio_button_get_type();
  local_90 = 0;
  lb = layer_buttons;
  do {
    lb->index = iVar11;
    if (iVar11 < 0x12) {
      pGVar8 = (GtkWidget *)gtk_radio_button_new(local_90);
      uVar14 = g_type_check_instance_cast(pGVar8);
      local_90 = gtk_radio_button_get_group(uVar14);
      uVar14 = g_type_check_instance_cast(uVar13);
      gtk_table_attach_defaults(uVar14,pGVar8,0,1,iVar11);
      lb->radio_select_button = pGVar8;
      uVar14 = g_type_check_instance_cast(pGVar8);
      g_signal_connect_data(uVar14,"toggled",layer_select_button_cb,lb,0);
    }
    layer_process(&local_50,&local_4c,&local_54,iVar11);
    pGVar8 = (GtkWidget *)gtk_check_button_new();
    pGVar15 = (GtkWidget *)gtk_label_new(&DAT_0814741b);
    uVar14 = g_type_check_instance_cast(pGVar15);
    gtk_label_set_use_markup(uVar14);
    layer_enable_button_set_label(pGVar15,local_4c);
    pGVar16 = (GtkWidget *)gtk_event_box_new();
    uVar14 = g_type_check_instance_cast(pGVar16);
    gtk_container_add(uVar14);
    uVar14 = g_type_check_instance_cast(pGVar8);
    gtk_container_add(uVar14);
    uVar14 = g_type_check_instance_cast(uVar13);
    gtk_table_attach_defaults(uVar14,pGVar8,1,2,iVar11);
    uVar14 = g_type_check_instance_cast(pGVar8);
    gtk_toggle_button_set_mode(uVar14);
    lb->layer_enable_button = pGVar8;
    lb->layer_enable_ebox = pGVar16;
    pgVar17 = (gchar *)g_strdup(local_4c);
    lb->label = pGVar15;
    lb->text = pgVar17;
    layer_button_set_color(lb,local_50);
    uVar14 = g_type_check_instance_cast(pGVar8);
    gtk_toggle_button_set_active(uVar14);
    uVar14 = g_type_check_instance_cast(pGVar8);
    iVar11 = iVar11 + 1;
    g_signal_connect_data(uVar14);
    lb = lb + 1;
  } while (iVar11 != 0x16);
  pGVar8 = (GtkWidget *)gtk_vbox_new(0);
  uVar13 = g_type_check_instance_cast(pGVar10);
  gtk_box_pack_start(uVar13,pGVar8,0,0,0);
  ghidgui->mode_buttons0_frame_vbox = pGVar8;
  pGVar8 = (GtkWidget *)gtk_frame_new(0);
  ghidgui->mode_buttons0_frame = pGVar8;
  gtk_widget_show(pGVar8);
  uVar13 = g_type_check_instance_cast(pGVar8);
  g_object_ref(uVar13);
  pGVar3 = ghidgui;
  pGVar15 = (GtkWidget *)gtk_vbox_new(0);
  pGVar3->mode_buttons0_vbox = pGVar15;
  uVar13 = g_type_check_instance_cast(pGVar8);
  gtk_container_add(uVar13);
  local_64 = (GtkWidget *)0x0;
  local_7c = 0;
  local_60 = 0;
  pMVar24 = mode_buttons;
  do {
    pGVar8 = (GtkWidget *)gtk_radio_button_new(local_7c);
    pMVar24->button = pGVar8;
    uVar13 = g_type_check_instance_cast(pGVar8);
    g_object_ref(uVar13);
    uVar13 = g_type_check_instance_cast(pGVar8);
    local_7c = gtk_radio_button_get_group(uVar13);
    uVar13 = g_type_check_instance_cast(pGVar8);
    gtk_toggle_button_set_mode(uVar13);
    if (local_60 % ghidgui->n_mode_button_columns == 0) {
      local_64 = (GtkWidget *)gtk_hbox_new(0);
      uVar13 = g_type_check_instance_cast(ghidgui->mode_buttons0_vbox);
      gtk_box_pack_start(uVar13,local_64,0,0,0);
    }
    pGVar3 = ghidgui;
    pMVar24->box0 = local_64;
    pMVar24->box1 = pGVar3->mode_buttons1_hbox;
    uVar13 = gdk_pixbuf_new_from_xpm_data(pMVar24->xpm);
    gtk_image_new_from_pixbuf(uVar13);
    uVar13 = g_type_check_instance_cast(uVar13);
    g_object_unref(uVar13);
    uVar13 = g_type_check_instance_cast(pGVar8);
    gtk_container_add(uVar13);
    iVar11 = strcmp(pMVar24->name,"select");
    if (iVar11 == 0) {
      uVar13 = g_type_check_instance_cast(pGVar8);
      gtk_toggle_button_set_active(uVar13);
    }
    uVar28 = 0;
    uVar27 = CONCAT44(pMVar24,mode_button_toggled_cb);
    g_signal_connect_data(pGVar8);
    local_60 = local_60 + 1;
    pMVar24 = pMVar24 + 1;
  } while (local_60 != 0xd);
  ghid_pack_mode_buttons();
  uVar13 = gtk_frame_new(0);
  uVar14 = g_type_check_instance_cast(pGVar10,uVar7,uVar27,uVar28);
  gtk_box_pack_end(uVar14,uVar13,0,0,0);
  uVar14 = gtk_vbox_new(0,0);
  uVar13 = g_type_check_instance_cast(uVar13,uVar6);
  gtk_container_add(uVar13,uVar14);
  uVar13 = gtk_hbox_new(0,0);
  uVar14 = g_type_check_instance_cast(uVar14,uVar7);
  gtk_box_pack_start(uVar14,uVar13,0,0,1);
  uVar14 = gtk_vbox_new(0,0);
  uVar13 = g_type_check_instance_cast(uVar13,uVar7);
  gtk_box_pack_start(uVar13,uVar14,0,0,4);
  uVar13 = dcgettext(&DAT_0815492c,"Route Style",5);
  pGVar8 = (GtkWidget *)gtk_button_new_with_label(uVar13);
  uVar13 = g_type_check_instance_cast(uVar14,uVar7);
  gtk_box_pack_start(uVar13,pGVar8,0,0,2);
  g_signal_connect_data(pGVar8,"clicked",route_style_edit_cb,&ghid_port,0,0);
  iVar11 = 0;
  pRVar23 = route_style_button;
  local_6c = 0;
  route_style_edit_button = pGVar8;
  do {
    if (iVar11 < 4) {
      dcgettext(&DAT_0815492c,PCB->RouteStyle[iVar11].Name,5);
      pGVar8 = (GtkWidget *)gtk_radio_button_new_with_label(local_6c);
      uVar13 = g_type_check_instance_cast(pGVar8);
      local_6c = gtk_radio_button_get_group(uVar13);
      uVar13 = g_type_check_instance_cast(uVar14);
      gtk_box_pack_start(uVar13,pGVar8,0,0,0);
      pRVar23->button = pGVar8;
    }
    else {
      uVar13 = dcgettext(&DAT_0815492c,"Temp%d",5);
      __snprintf_chk(buf,0x20,1,0x20,uVar13,iVar11 + -3);
      pGVar8 = (GtkWidget *)gtk_radio_button_new_with_label(local_6c);
      if ((pRVar23->route_style).Name == (char *)0x0) {
        pcVar21 = (char *)g_strdup(buf);
        (pRVar23->route_style).Name = pcVar21;
      }
      uVar13 = g_type_check_instance_cast(pGVar8);
      local_6c = gtk_radio_button_get_group(uVar13);
      uVar13 = g_type_check_instance_cast(uVar14);
      gtk_box_pack_start(uVar13,pGVar8,0,0,0);
      pRVar23->button = pGVar8;
      if (iVar11 == 6) break;
    }
    pRVar23 = pRVar23 + 1;
    uVar13 = g_type_check_instance_cast(pGVar8);
    iVar11 = iVar11 + 1;
    g_signal_connect_data(uVar13,"toggled",route_style_select_button_cb);
  } while (iVar11 != 7);
  uVar13 = gtk_vbox_new(0,0);
  uVar14 = g_type_check_instance_cast(uVar9,uVar7);
  gtk_box_pack_start(uVar14,uVar13,1,1,0);
  uVar14 = gtk_hbox_new(0,0);
  uVar13 = g_type_check_instance_cast(uVar13,uVar7);
  gtk_box_pack_start(uVar13,uVar14,1,1,0);
  uVar13 = gtk_viewport_new(0,0);
  uVar18 = gtk_viewport_get_type();
  uVar18 = g_type_check_instance_cast(uVar13,uVar18);
  gtk_viewport_set_shadow_type(uVar18,1);
  uVar18 = g_type_check_instance_cast(uVar14,uVar7);
  gtk_box_pack_start(uVar18,uVar13,1,1,0);
  pGVar22 = gport;
  pGVar8 = (GtkWidget *)gtk_drawing_area_new();
  pGVar22->drawing_area = pGVar8;
  gtk_widget_add_events(gport->drawing_area,0x7f06);
  uVar18 = gtk_object_get_type();
  iVar11 = g_type_check_instance_cast(gport->drawing_area,uVar18);
  *(uint *)(iVar11 + 0xc) = *(uint *)(iVar11 + 0xc) | 0x800;
  pGVar8 = gport->drawing_area;
  uVar6 = g_type_check_instance_cast(uVar13,uVar6);
  gtk_container_add(uVar6,pGVar8);
  pGVar3 = ghidgui;
  fVar29 = 0.0;
  pGVar19 = (GtkObject *)
            gtk_adjustment_new(0,0,0x4059000000000000,0x4024000000000000,0x4024000000000000,
                               0x4024000000000000,0);
  pGVar3->v_adjustment = pGVar19;
  uVar6 = gtk_adjustment_get_type();
  pGVar3 = ghidgui;
  uVar6 = g_type_check_instance_cast(ghidgui->v_adjustment,uVar6);
  pGVar8 = (GtkWidget *)gtk_vscrollbar_new(uVar6);
  pGVar3->v_range = pGVar8;
  uVar6 = gtk_range_get_type();
  uVar6 = g_type_check_instance_cast(ghidgui->v_range,uVar6);
  gtk_range_set_update_policy(uVar6,0);
  pGVar8 = ghidgui->v_range;
  uVar6 = g_type_check_instance_cast(uVar14,uVar7);
  gtk_box_pack_start(uVar6,pGVar8,0,0,0);
  pGVar3 = ghidgui;
  uVar6 = g_type_check_instance_cast(ghidgui->v_adjustment,0x50);
  g_signal_connect_data(uVar6,"value_changed",v_adjustment_changed_cb,pGVar3,0,0);
  pGVar3 = ghidgui;
  pGVar19 = (GtkObject *)
            gtk_adjustment_new((double)fVar29,(double)fVar29,0x4059000000000000,0x4024000000000000,
                               0x4024000000000000,0x4024000000000000);
  pGVar3->h_adjustment = pGVar19;
  pGVar3 = ghidgui;
  uVar6 = g_type_check_instance_cast(ghidgui->h_adjustment);
  pGVar8 = (GtkWidget *)gtk_hscrollbar_new(uVar6);
  pGVar3->h_range = pGVar8;
  uVar6 = g_type_check_instance_cast(ghidgui->h_range);
  gtk_range_set_update_policy(uVar6);
  pGVar8 = ghidgui->h_range;
  uVar6 = g_type_check_instance_cast();
  gtk_box_pack_start(uVar6,pGVar8,0,0,0);
  uVar6 = g_type_check_instance_cast(ghidgui->h_adjustment);
  g_signal_connect_data(uVar6);
  pGVar3 = ghidgui;
  pGVar8 = (GtkWidget *)gtk_hbox_new(0);
  pGVar3->status_line_hbox = pGVar8;
  pGVar8 = ghidgui->status_line_hbox;
  uVar6 = g_type_check_instance_cast();
  gtk_box_pack_start(uVar6,pGVar8,0,0,2);
  pGVar8 = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  uVar6 = g_type_check_instance_cast(pGVar8);
  gtk_label_set_use_markup(uVar6);
  uVar6 = g_type_check_instance_cast(ghidgui->status_line_hbox);
  gtk_box_pack_start(uVar6);
  ghidgui->status_line_label = pGVar8;
  uVar6 = g_type_check_instance_cast();
  g_signal_connect_data(uVar6,"expose_event",ghid_port_drawing_area_expose_event_cb,&ghid_port,0,0);
  uVar6 = g_type_check_instance_cast(gport->top_window);
  g_signal_connect_data(uVar6);
  uVar6 = g_type_check_instance_cast();
  g_signal_connect_data
            (uVar6,"configure_event",ghid_port_drawing_area_configure_event_cb,&ghid_port,0,0);
  ghid_interface_input_signals_connect();
  uVar6 = g_type_check_instance_cast(gport->drawing_area);
  g_signal_connect_data(uVar6);
  uVar6 = g_type_check_instance_cast();
  g_signal_connect_data(uVar6,"enter_notify_event",ghid_port_window_enter_cb,&ghid_port,0,0);
  uVar6 = g_type_check_instance_cast(gport->drawing_area);
  g_signal_connect_data(uVar6);
  uVar6 = g_type_check_instance_cast();
  g_signal_connect_data(uVar6,"motion_notify_event",ghid_port_window_motion_cb,&ghid_port,0,0);
  uVar6 = g_type_check_instance_cast(pGVar2);
  g_signal_connect_data(uVar6);
  uVar6 = g_type_check_instance_cast();
  g_signal_connect_data(uVar6,"destroy",destroy_chart_cb,&ghid_port,0,0);
  ghidgui->creating = 0;
  gtk_widget_show_all(gport->top_window);
  gtk_widget_realize(uVar5);
  gtk_widget_realize(uVar9);
  gtk_widget_realize(uVar13);
  gtk_widget_realize(gport->drawing_area);
  gdk_window_set_back_pixmap(gport->drawing_area->window);
  gtk_widget_hide(route_style_button[4].button);
  gtk_widget_hide(route_style_button[5].button);
  gtk_widget_hide(route_style_button[6].button);
  ghid_show_layer_buttons();
  ghid_update_toggle_flags();
  XC_clock_source =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,rotateIcon_bits,0x10,0x10)
  ;
  XC_clock_mask =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,rotateMask_bits,0x10,0x10)
  ;
  XC_hand_source =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,handIcon_bits,0x10,0x10);
  XC_hand_mask = (GdkPixmap *)
                 gdk_bitmap_create_from_data(gport->top_window->window,handMask_bits,0x10,0x10);
  XC_lock_source =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,lockIcon_bits,0x10,0x10);
  XC_lock_mask = (GdkPixmap *)
                 gdk_bitmap_create_from_data(gport->top_window->window,lockMask_bits,0x10,0x10);
  SetMode(0x6e);
  ghid_mode_buttons_update();
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void ghid_do_export(HID_Attr_Val *options)

{
  int iVar1;
  int fd;
  GIOChannel *channel;
  
  ghid_create_pcb_widgets();
  ghid_layer_buttons_update();
  ghid_show_layer_buttons();
  if (stdin_listen != 0) {
    iVar1 = fileno(stdin);
    fd = g_io_channel_unix_new(iVar1);
    g_io_add_watch(fd,1,ghid_listener_cb,0);
  }
  ghid_notify_gui_is_up();
  gtk_main();
  ghid_config_files_write();
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_is_modifier_key_sym(gint ksym)

{
  if ((1 < ksym - 0xffe1U) && (ksym != 0xffe4)) {
    return (uint)(ksym == 0xffe3);
  }
  return 1;
}



// WARNING: Unknown calling convention

gboolean dup_string(gchar **dst,gchar *src)

{
  char *__s1;
  char *pcVar1;
  gchar *pgVar2;
  gboolean gVar3;
  
  if (dst == (gchar **)0x0) {
LAB_0810a6c4:
    gVar3 = 0;
  }
  else {
    __s1 = *dst;
    pcVar1 = __s1;
    if (src == (gchar *)0x0) {
joined_r0x0810a6c2:
      if (pcVar1 == (char *)0x0) goto LAB_0810a6c4;
      g_free(__s1);
    }
    else if (__s1 != (char *)0x0) {
      pcVar1 = (char *)strcmp(__s1,src);
      goto joined_r0x0810a6c2;
    }
    pgVar2 = (gchar *)g_strdup(src);
    *dst = pgVar2;
    gVar3 = 1;
  }
  return gVar3;
}



// WARNING: Unknown calling convention

gboolean utf8_dup_string(gchar **dst_utf8,gchar *src)

{
  char *__s1;
  char *pcVar1;
  int iVar2;
  gchar *pgVar3;
  gboolean gVar4;
  
  if (dst_utf8 == (gchar **)0x0) {
LAB_0810a7a0:
    gVar4 = 0;
  }
  else {
    __s1 = *dst_utf8;
    pcVar1 = __s1;
    if (src == (gchar *)0x0) {
joined_r0x0810a79a:
      if (pcVar1 == (char *)0x0) goto LAB_0810a7a0;
      g_free(__s1);
    }
    else if (__s1 != (char *)0x0) {
      pcVar1 = (char *)strcmp(__s1,src);
      goto joined_r0x0810a79a;
    }
    if (src == (gchar *)0x0) {
      *dst_utf8 = (gchar *)0x0;
      gVar4 = 1;
    }
    else {
      iVar2 = g_utf8_validate(src,0xffffffff,0);
      if (iVar2 == 0) {
        pgVar3 = (gchar *)g_locale_to_utf8(src,0xffffffff,0,0,0);
        *dst_utf8 = pgVar3;
        if (pgVar3 != (gchar *)0x0) {
          return 1;
        }
      }
      pgVar3 = (gchar *)g_strdup(src);
      *dst_utf8 = pgVar3;
      gVar4 = 1;
    }
  }
  return gVar4;
}



// WARNING: Unknown calling convention

GtkWidget *
ghid_scrolled_text_view
          (GtkWidget *box,GtkWidget **scr,GtkPolicyType h_policy,GtkPolicyType v_policy)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  GtkWidget *pGVar3;
  undefined4 uVar4;
  GtkTextBuffer *buffer;
  GtkWidget *view;
  GtkWidget *scrolled;
  
  pGVar1 = (GtkWidget *)gtk_scrolled_window_new(0,0);
  uVar2 = gtk_scrolled_window_get_type();
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_scrolled_window_set_policy(uVar2,h_policy,v_policy);
  uVar2 = gtk_box_get_type();
  uVar2 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(uVar2,pGVar1,1,1,0);
  pGVar3 = (GtkWidget *)gtk_text_view_new();
  uVar2 = gtk_text_view_get_type();
  uVar4 = g_type_check_instance_cast(pGVar3,uVar2);
  gtk_text_view_set_editable(uVar4,0);
  uVar2 = g_type_check_instance_cast(pGVar3,uVar2);
  uVar2 = gtk_text_view_get_buffer(uVar2);
  gtk_text_buffer_create_tag(uVar2,"heading","weight",700,"size",0x3800,0);
  gtk_text_buffer_create_tag(uVar2,"italic","style",2,0);
  gtk_text_buffer_create_tag(uVar2,&DAT_0815c4db,"weight",700,0);
  gtk_text_buffer_create_tag(uVar2,"center","justification",2,0);
  gtk_text_buffer_create_tag(uVar2,"underline","underline",1,0);
  uVar2 = gtk_container_get_type();
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_container_add(uVar2,pGVar3);
  if (scr != (GtkWidget **)0x0) {
    *scr = pGVar1;
  }
  return pGVar3;
}



// WARNING: Unknown calling convention

void text_view_append(GtkWidget *view,gchar *s)

{
  int iVar1;
  GtkTextMark *mark;
  gchar *pgVar2;
  char *pcVar3;
  undefined uVar4;
  byte bVar5;
  GtkTextIter iter;
  
  bVar5 = 0;
  uVar4 = &stack0x00000000 == (undefined *)0x9c;
  gtk_text_view_get_type();
  g_type_check_instance_cast();
  gtk_text_view_get_buffer();
  gtk_text_buffer_get_end_iter();
  iVar1 = 3;
  pgVar2 = s;
  pcVar3 = "<b>";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    uVar4 = *pgVar2 == *pcVar3;
    pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
    pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
  } while ((bool)uVar4);
  if ((bool)uVar4) {
    gtk_text_buffer_insert_with_tags_by_name();
  }
  else {
    iVar1 = 3;
    pgVar2 = s;
    pcVar3 = "<i>";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      uVar4 = *pgVar2 == *pcVar3;
      pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
      pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
    } while ((bool)uVar4);
    if (!(bool)uVar4) {
      iVar1 = 3;
      pgVar2 = s;
      pcVar3 = "<h>";
      do {
        if (iVar1 == 0) break;
        iVar1 = iVar1 + -1;
        uVar4 = *pgVar2 == *pcVar3;
        pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
        pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
      } while ((bool)uVar4);
      if (!(bool)uVar4) {
        iVar1 = 3;
        pgVar2 = s;
        pcVar3 = "<c>";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          uVar4 = *pgVar2 == *pcVar3;
          pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
          pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
        } while ((bool)uVar4);
        if (!(bool)uVar4) {
          iVar1 = 4;
          pcVar3 = "<ul>";
          do {
            if (iVar1 == 0) break;
            iVar1 = iVar1 + -1;
            uVar4 = *s == *pcVar3;
            s = s + (uint)bVar5 * -2 + 1;
            pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
          } while ((bool)uVar4);
          if (!(bool)uVar4) {
            gtk_text_buffer_insert();
            goto LAB_0810aa60;
          }
        }
      }
    }
    gtk_text_buffer_insert_with_tags_by_name();
  }
LAB_0810aa60:
  gtk_text_buffer_create_mark();
  g_type_check_instance_cast();
  gtk_text_view_scroll_to_mark();
  gtk_text_buffer_delete_mark();
  return;
}



// WARNING: Unknown calling convention

void ghid_text_view_append_strings(GtkWidget *view,gchar **string,gint n_strings)

{
  char *pcVar1;
  gchar *s;
  gchar *pgVar2;
  char cVar3;
  int iVar4;
  gint i;
  int iVar5;
  gchar *tag;
  
  if (0 < n_strings) {
    iVar4 = 0;
    iVar5 = 0;
    do {
      while (pcVar1 = string[iVar4], *pcVar1 != '<') {
LAB_0810abdd:
        pgVar2 = (gchar *)dcgettext(0,pcVar1,5);
        if (iVar5 == 0) {
          text_view_append(view,pgVar2);
        }
        else {
          pgVar2 = (gchar *)g_strconcat(iVar5,pgVar2,0);
          text_view_append(view,pgVar2);
          g_free(pgVar2);
          g_free(iVar5);
          iVar5 = 0;
        }
        iVar4 = iVar4 + 1;
        if (n_strings <= iVar4) {
          return;
        }
      }
      if (pcVar1[2] == '>') {
        cVar3 = pcVar1[3];
        if (cVar3 != '\0') goto LAB_0810abd4;
      }
      else {
        cVar3 = pcVar1[3];
LAB_0810abd4:
        if ((cVar3 != '>') || (pcVar1[4] != '\0')) goto LAB_0810abdd;
      }
      iVar4 = iVar4 + 1;
      iVar5 = g_strdup(pcVar1);
    } while (iVar4 < n_strings);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_text_view_append(GtkWidget *view,gchar *string)

{
  char cVar1;
  gchar *s;
  
  if (*string == '<') {
    if (string[2] == '>') {
      cVar1 = string[3];
      if (cVar1 != '\0') goto LAB_0810ad02;
    }
    else {
      cVar1 = string[3];
LAB_0810ad02:
      if ((cVar1 != '>') || (string[4] != '\0')) goto LAB_0810aca3;
    }
    ghid_text_view_append::tag = (gchar *)g_strdup(string);
  }
  else {
LAB_0810aca3:
    if (ghid_text_view_append::tag == (gchar *)0x0) {
      text_view_append(view,string);
      return;
    }
    s = (gchar *)g_strconcat(ghid_text_view_append::tag,string,0);
    text_view_append(view,s);
    g_free(s);
    g_free(ghid_text_view_append::tag);
    ghid_text_view_append::tag = (gchar *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_label_set_markup(GtkWidget *label,gchar *text)

{
  undefined4 uVar1;
  
  if (label != (GtkWidget *)0x0) {
    uVar1 = gtk_label_get_type();
    g_type_check_instance_cast(label,uVar1);
    gtk_label_set_markup();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

GtkWidget * ghid_notebook_page(GtkWidget *tabs,char *name,gint pad,gint border)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *vbox;
  GtkWidget *label;
  
  pGVar1 = (GtkWidget *)gtk_vbox_new(0,pad);
  uVar2 = gtk_container_get_type();
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_container_set_border_width(uVar2,border);
  uVar2 = gtk_label_new(name);
  uVar3 = gtk_notebook_get_type();
  uVar3 = g_type_check_instance_cast(tabs,uVar3);
  gtk_notebook_append_page(uVar3,pGVar1,uVar2);
  return pGVar1;
}



// WARNING: Unknown calling convention

GtkTreeSelection *
ghid_scrolled_selection
          (GtkTreeView *treeview,GtkWidget *box,GtkSelectionMode s_mode,GtkPolicyType h_policy,
          GtkPolicyType v_policy,_func_void_varargs *func_cb,gpointer data)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkTreeSelection *selection;
  
  if ((box == (GtkWidget *)0x0) || (treeview == (GtkTreeView *)0x0)) {
    selection = (GtkTreeSelection *)0x0;
  }
  else {
    uVar1 = gtk_scrolled_window_new(0,0);
    uVar2 = gtk_box_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_start(uVar2,uVar1,1,1,0);
    uVar2 = gtk_widget_get_type();
    uVar2 = g_type_check_instance_cast(treeview,uVar2);
    uVar3 = gtk_container_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_container_add(uVar3,uVar2);
    uVar2 = gtk_scrolled_window_get_type();
    uVar1 = g_type_check_instance_cast(uVar1,uVar2);
    gtk_scrolled_window_set_policy(uVar1,h_policy,v_policy);
    selection = (GtkTreeSelection *)gtk_tree_view_get_selection(treeview);
    gtk_tree_selection_set_mode(selection,s_mode);
    if (func_cb != (_func_void_varargs *)0x0) {
      uVar1 = g_type_check_instance_cast(selection,0x50);
      g_signal_connect_data(uVar1,"changed",func_cb,data,0,0);
    }
  }
  return selection;
}



// WARNING: Unknown calling convention

GtkWidget *
ghid_category_vbox(GtkWidget *box,gchar *category_header,gint header_pad,gint box_pad,
                  gboolean pack_start,gboolean bottom_pad)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  GtkWidget *vbox;
  GtkWidget *label;
  GtkWidget *hbox;
  
  uVar1 = gtk_vbox_new(0,0);
  if (pack_start == 0) {
    uVar2 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_end(uVar3,uVar1,0,0,0);
  }
  else {
    uVar2 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_start(uVar3,uVar1,0,0,0);
  }
  if (category_header != (gchar *)0x0) {
    uVar3 = gtk_label_new(0);
    uVar4 = g_strconcat("<span weight=\"bold\">",category_header,"</span>",0);
    uVar5 = gtk_label_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_label_set_markup(uVar5,uVar4);
    uVar5 = gtk_misc_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_misc_set_alignment(uVar5,0,0x3f000000);
    uVar5 = g_type_check_instance_cast(uVar1,uVar2);
    gtk_box_pack_start(uVar5,uVar3,0,0,header_pad);
    g_free(uVar4);
  }
  uVar3 = gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,0);
  uVar4 = gtk_label_new(&DAT_0815672c);
  uVar5 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar5,uVar4,0,0,0);
  pGVar6 = (GtkWidget *)gtk_vbox_new(0,box_pad);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar3,pGVar6,1,1,0);
  if (bottom_pad != 0) {
    uVar3 = gtk_label_new(&DAT_0814741b);
    uVar1 = g_type_check_instance_cast(uVar1,uVar2);
    gtk_box_pack_start(uVar1,uVar3,0,0,0);
  }
  return pGVar6;
}



// WARNING: Unknown calling convention

GtkWidget *
ghid_framed_vbox_end
          (GtkWidget *box,gchar *label,gint frame_border_width,gboolean frame_expand,gint vbox_pad,
          gint vbox_border_width)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  GtkWidget *vbox;
  GtkWidget *frame;
  
  uVar1 = gtk_frame_new(label);
  uVar2 = gtk_container_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_set_border_width(uVar3,frame_border_width);
  uVar3 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar3);
  gtk_box_pack_end(uVar3,uVar1,frame_expand,frame_expand,0);
  pGVar4 = (GtkWidget *)gtk_vbox_new(0,vbox_pad);
  uVar3 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_container_set_border_width(uVar3,vbox_border_width);
  uVar1 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_add(uVar1,pGVar4);
  return pGVar4;
}



// WARNING: Unknown calling convention

GtkWidget *
ghid_framed_vbox(GtkWidget *box,gchar *label,gint frame_border_width,gboolean frame_expand,
                gint vbox_pad,gint vbox_border_width)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  GtkWidget *vbox;
  GtkWidget *frame;
  
  uVar1 = gtk_frame_new(label);
  uVar2 = gtk_container_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_set_border_width(uVar3,frame_border_width);
  uVar3 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar3);
  gtk_box_pack_start(uVar3,uVar1,frame_expand,frame_expand,0);
  pGVar4 = (GtkWidget *)gtk_vbox_new(0,vbox_pad);
  uVar3 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_container_set_border_width(uVar3,vbox_border_width);
  uVar1 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_add(uVar1,pGVar4);
  return pGVar4;
}



// WARNING: Unknown calling convention

GtkWidget *
ghid_framed_notebook_page
          (GtkWidget *tabs,char *name,gint border,gint frame_border,gint vbox_pad,gint vbox_border)

{
  GtkWidget *pGVar1;
  GtkWidget *vbox;
  
  pGVar1 = ghid_notebook_page(tabs,name,0,border);
  pGVar1 = ghid_framed_vbox(pGVar1,(gchar *)0x0,frame_border,1,vbox_pad,vbox_border);
  return pGVar1;
}



// WARNING: Unknown calling convention

GtkWidget *
ghid_scrolled_vbox(GtkWidget *box,GtkWidget **scr,GtkPolicyType h_policy,GtkPolicyType v_policy)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  GtkWidget *scrolled;
  GtkWidget *vbox;
  
  pGVar1 = (GtkWidget *)gtk_scrolled_window_new(0,0);
  uVar2 = gtk_scrolled_window_get_type();
  uVar3 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_scrolled_window_set_policy(uVar3,h_policy,v_policy);
  uVar3 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar3);
  gtk_box_pack_start(uVar3,pGVar1,1,1,0);
  pGVar4 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_scrolled_window_add_with_viewport(uVar2,pGVar4);
  if (scr != (GtkWidget **)0x0) {
    *scr = pGVar1;
  }
  return pGVar4;
}



// WARNING: Unknown calling convention

void ghid_dialog_report(gchar *title,gchar *message)

{
  char cVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *box;
  int iVar6;
  gint nlines;
  GtkWidget *dialog;
  gchar *s;
  GtkWidget *vbox1;
  GtkWidget *vbox;
  GtkWidget *local_20 [4];
  
  if (message != (gchar *)0x0) {
    uVar2 = gtk_window_get_type();
    uVar3 = g_type_check_instance_cast(ghid_port.top_window,uVar2);
    if (title == (gchar *)0x0) {
      title = "PCB";
    }
    uVar3 = gtk_dialog_new_with_buttons(title,uVar3,2,"gtk-ok",0xffffffff,0);
    uVar4 = gtk_object_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar4);
    uVar4 = g_type_check_instance_cast(uVar3,uVar4);
    g_signal_connect_data(uVar4,"response",gtk_widget_destroy,uVar5,0,2);
    uVar2 = g_type_check_instance_cast(uVar3,uVar2);
    gtk_window_set_wmclass(uVar2,"PCB_Dialog",&DAT_08154932);
    box = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = gtk_container_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_container_set_border_width(uVar2,8);
    uVar2 = gtk_box_get_type();
    uVar4 = gtk_dialog_get_type();
    iVar6 = g_type_check_instance_cast(uVar3,uVar4);
    uVar4 = g_type_check_instance_cast(*(undefined4 *)(iVar6 + 0x94),uVar2);
    gtk_box_pack_start(uVar4,box,0,0,0);
    uVar4 = gtk_label_new(message);
    uVar5 = gtk_label_get_type();
    uVar5 = g_type_check_instance_cast(uVar4,uVar5);
    gtk_label_set_justify(uVar5,0);
    cVar1 = *message;
    if (cVar1 != '\0') {
      iVar6 = 0;
      do {
        message = message + 1;
        iVar6 = iVar6 + (uint)(cVar1 == '\n');
        cVar1 = *message;
      } while (cVar1 != '\0');
      if (0x14 < iVar6) {
        box = ghid_scrolled_vbox(box,local_20,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC);
        gtk_widget_set_size_request(local_20[0],0xffffffff,300);
      }
    }
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_start(uVar2,uVar4,0,0,0);
    gtk_widget_show_all(uVar3);
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_range_control(GtkWidget *box,GtkWidget **scale_res,gboolean horizontal,GtkPositionType pos
                       ,gboolean set_draw_value,gint digits,gboolean pack_start,gboolean expand,
                       gboolean fill,guint pad,gfloat value,gfloat low,gfloat high,gfloat step0,
                       gfloat step1,_func_void_varargs *cb_func,gpointer data)

{
  gpointer pvVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *scale;
  
  pvVar1 = (gpointer)
           gtk_adjustment_new((double)value,(double)low,(double)high,(double)step0,(double)step1,0);
  if (horizontal == 0) {
    uVar2 = gtk_adjustment_get_type();
    uVar2 = g_type_check_instance_cast(pvVar1,uVar2);
    scale = (GtkWidget *)gtk_vscale_new(uVar2);
  }
  else {
    uVar2 = gtk_adjustment_get_type();
    uVar2 = g_type_check_instance_cast(pvVar1,uVar2);
    scale = (GtkWidget *)gtk_hscale_new(uVar2);
  }
  uVar2 = gtk_scale_get_type();
  uVar3 = g_type_check_instance_cast(scale,uVar2);
  gtk_scale_set_value_pos(uVar3,pos);
  uVar3 = g_type_check_instance_cast(scale,uVar2);
  gtk_scale_set_draw_value(uVar3,set_draw_value);
  uVar2 = g_type_check_instance_cast(scale,uVar2);
  gtk_scale_set_digits(uVar2,digits);
  uVar2 = gtk_range_get_type();
  uVar3 = g_type_check_instance_cast(scale,uVar2);
  gtk_range_set_update_policy(uVar3,0);
  uVar2 = g_type_check_instance_cast(scale,uVar2);
  gtk_range_set_increments(uVar2,0,0xbff00000,0,0x3ff00000);
  if (pack_start == 0) {
    uVar2 = gtk_box_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_end(uVar2,scale,expand,fill,pad);
  }
  else {
    uVar2 = gtk_box_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_start(uVar2,scale,expand,fill,pad);
  }
  if (data == (gpointer)0x0) {
    data = pvVar1;
  }
  if (cb_func != (_func_void_varargs *)0x0) {
    uVar2 = g_type_check_instance_cast(pvVar1,0x50);
    g_signal_connect_data(uVar2,"value_changed",cb_func,data,0,0);
  }
  if (scale_res != (GtkWidget **)0x0) {
    *scale_res = scale;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_spin_button(GtkWidget *box,GtkWidget **spin_button,gfloat value,gfloat low,gfloat high,
                     gfloat step0,gfloat step1,gint digits,gint width,_func_void_varargs *cb_func,
                     gpointer data,gboolean right_align,gchar *string)

{
  undefined4 uVar1;
  GtkWidget *pGVar2;
  gpointer pvVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  GtkWidget *spin_but;
  GtkWidget *label;
  bool bVar7;
  
  bVar7 = string != (gchar *)0x0;
  pGVar6 = box;
  if ((bVar7) && (box != (GtkWidget *)0x0)) {
    pGVar6 = (GtkWidget *)gtk_hbox_new(0,0);
    uVar1 = gtk_box_get_type();
    uVar1 = g_type_check_instance_cast(box,uVar1);
    gtk_box_pack_start(uVar1,pGVar6,0,0,2);
  }
  uVar1 = gtk_adjustment_new((double)value,(double)low,(double)high,(double)step0,(double)step1,0);
  pGVar2 = (GtkWidget *)gtk_spin_button_new(uVar1,0,0x3fe00000,digits);
  if (spin_button != (GtkWidget **)0x0) {
    *spin_button = pGVar2;
  }
  if (0 < width) {
    gtk_widget_set_size_request(pGVar2,width,0xffffffff);
  }
  uVar1 = gtk_spin_button_get_type();
  pvVar3 = (gpointer)g_type_check_instance_cast(pGVar2,uVar1);
  gtk_spin_button_set_numeric(pvVar3,1);
  if (data == (gpointer)0x0) {
    data = pvVar3;
  }
  if (cb_func != (_func_void_varargs *)0x0) {
    uVar1 = g_type_check_instance_cast(pGVar2,0x50);
    g_signal_connect_data(uVar1,"value_changed",cb_func,data,0,0);
  }
  if (pGVar6 != (GtkWidget *)0x0) {
    if ((bVar7) && (right_align != 0)) {
      uVar4 = gtk_label_new(string);
      uVar1 = gtk_misc_get_type();
      uVar1 = g_type_check_instance_cast(uVar4,uVar1);
      gtk_misc_set_alignment(uVar1,0x3f800000,0x3f000000);
      uVar1 = gtk_box_get_type();
      uVar5 = g_type_check_instance_cast(pGVar6,uVar1);
      gtk_box_pack_start(uVar5,uVar4,1,1,2);
    }
    else {
      uVar1 = gtk_box_get_type();
    }
    uVar4 = g_type_check_instance_cast(pGVar6,uVar1);
    gtk_box_pack_start(uVar4,pGVar2,0,0,2);
    if ((bVar7) && (right_align == 0)) {
      uVar4 = gtk_label_new(string);
      uVar5 = gtk_misc_get_type();
      uVar4 = g_type_check_instance_cast(uVar4,uVar5);
      gtk_misc_set_alignment(uVar4,0,0x3f000000);
      g_type_check_instance_cast(pGVar6,uVar1);
      gtk_box_pack_start();
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_table_spin_button
               (GtkWidget *table,gint row,gint column,GtkWidget **spin_button,gfloat value,
               gfloat low,gfloat high,gfloat step0,gfloat step1,gint digits,gint width,
               _func_void_varargs *cb_func,gpointer data,gboolean right_align,gchar *string)

{
  undefined4 uVar1;
  GtkWidget *pGVar2;
  gpointer pvVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *spin_but;
  GtkWidget *label;
  
  if (table != (GtkWidget *)0x0) {
    uVar1 = gtk_adjustment_new((double)value,(double)low,(double)high,(double)step0,(double)step1,0)
    ;
    pGVar2 = (GtkWidget *)gtk_spin_button_new(uVar1,0,0x3fe00000,digits);
    if (spin_button != (GtkWidget **)0x0) {
      *spin_button = pGVar2;
    }
    if (0 < width) {
      gtk_widget_set_size_request(pGVar2,width,0xffffffff);
    }
    uVar1 = gtk_spin_button_get_type();
    pvVar3 = (gpointer)g_type_check_instance_cast(pGVar2,uVar1);
    gtk_spin_button_set_numeric(pvVar3,1);
    if (data == (gpointer)0x0) {
      data = pvVar3;
    }
    if (cb_func != (_func_void_varargs *)0x0) {
      uVar1 = g_type_check_instance_cast(pGVar2,0x50);
      g_signal_connect_data(uVar1,"value_changed",cb_func,data,0,0);
    }
    if (right_align == 0) {
      uVar1 = gtk_table_get_type();
      uVar4 = g_type_check_instance_cast(table,uVar1);
      gtk_table_attach_defaults(uVar4,pGVar2,column,column + 1,row,row + 1);
      if (string != (gchar *)0x0) {
        uVar4 = gtk_label_new(string);
        uVar5 = gtk_misc_get_type();
        uVar4 = g_type_check_instance_cast(uVar4,uVar5);
        gtk_misc_set_alignment(uVar4,0,0x3f000000);
        g_type_check_instance_cast(table,uVar1);
LAB_0810be18:
        gtk_table_attach_defaults();
        return;
      }
    }
    else {
      uVar1 = gtk_table_get_type();
      uVar4 = g_type_check_instance_cast(table,uVar1);
      gtk_table_attach_defaults(uVar4,pGVar2,column + 1,column + 2,row,row + 1);
      if (string != (gchar *)0x0) {
        uVar4 = gtk_label_new(string);
        uVar5 = gtk_misc_get_type();
        uVar4 = g_type_check_instance_cast(uVar4,uVar5);
        gtk_misc_set_alignment(uVar4,0x3f800000,0x3f000000);
        g_type_check_instance_cast(table,uVar1);
        goto LAB_0810be18;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_button_connected
               (GtkWidget *box,GtkWidget **button,gboolean pack_start,gboolean expand,gboolean fill,
               gint pad,_func_void_varargs *cb_func,gpointer data,gchar *string)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  GtkWidget *b;
  
  if (string != (gchar *)0x0) {
    pGVar1 = (GtkWidget *)gtk_button_new_with_label(string);
    if (pack_start == 0) {
      if (box != (GtkWidget *)0x0) {
        uVar2 = gtk_box_get_type();
        uVar2 = g_type_check_instance_cast(box,uVar2);
        gtk_box_pack_end(uVar2,pGVar1,expand,fill,pad);
      }
    }
    else if (box != (GtkWidget *)0x0) {
      uVar2 = gtk_box_get_type();
      uVar2 = g_type_check_instance_cast(box,uVar2);
      gtk_box_pack_start(uVar2,pGVar1,expand,fill,pad);
    }
    if (cb_func != (_func_void_varargs *)0x0) {
      uVar2 = gtk_object_get_type();
      uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
      gtk_signal_connect_full(uVar2,"clicked",cb_func,0,data,0,0,0);
    }
    if (button != (GtkWidget **)0x0) {
      *button = pGVar1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

gboolean ghid_button_active(GtkWidget *widget)

{
  undefined4 uVar1;
  int iVar2;
  
  uVar1 = gtk_toggle_button_get_type();
  iVar2 = g_type_check_instance_cast(widget,uVar1);
  return *(byte *)(iVar2 + 0x58) & 1;
}



// WARNING: Unknown calling convention

void ghid_check_button_connected
               (GtkWidget *box,GtkWidget **button,gboolean active,gboolean pack_start,
               gboolean expand,gboolean fill,gint pad,_func_void_varargs *cb_func,gpointer data,
               gchar *string)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  GtkWidget *b;
  
  if (string != (gchar *)0x0) {
    pGVar1 = (GtkWidget *)gtk_check_button_new_with_label(string);
    uVar2 = gtk_toggle_button_get_type();
    uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
    gtk_toggle_button_set_active(uVar2,active);
    if (pack_start == 0) {
      if (box != (GtkWidget *)0x0) {
        uVar2 = gtk_box_get_type();
        uVar2 = g_type_check_instance_cast(box,uVar2);
        gtk_box_pack_end(uVar2,pGVar1,expand,fill,pad);
      }
    }
    else if (box != (GtkWidget *)0x0) {
      uVar2 = gtk_box_get_type();
      uVar2 = g_type_check_instance_cast(box,uVar2);
      gtk_box_pack_start(uVar2,pGVar1,expand,fill,pad);
    }
    if (cb_func != (_func_void_varargs *)0x0) {
      uVar2 = gtk_object_get_type();
      uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
      gtk_signal_connect_full(uVar2,"clicked",cb_func,0,data,0,0,0);
    }
    if (button != (GtkWidget **)0x0) {
      *button = pGVar1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

gchar * ghid_entry_get_text(GtkWidget *entry)

{
  gchar *pgVar1;
  gchar *s;
  undefined4 uVar2;
  
  pgVar1 = "";
  if (entry != (GtkWidget *)0x0) {
    uVar2 = gtk_entry_get_type();
    uVar2 = g_type_check_instance_cast(entry,uVar2);
    pgVar1 = (gchar *)gtk_entry_get_text(uVar2);
  }
  for (; (*pgVar1 == '\t' || (*pgVar1 == ' ')); pgVar1 = pgVar1 + 1) {
  }
  return pgVar1;
}



// WARNING: Unknown calling convention

void ghid_button_set_text(GtkWidget *button,gchar *text)

{
  undefined4 uVar1;
  undefined4 uVar2;
  GtkWidget *label;
  
  uVar1 = gtk_bin_get_type();
  uVar1 = g_type_check_instance_cast(button,uVar1);
  uVar1 = gtk_bin_get_child(uVar1);
  uVar2 = gtk_label_get_type();
  g_type_check_instance_cast(uVar1,uVar2);
  gtk_label_set_text();
  return;
}



// WARNING: Unknown calling convention

void ghid_map_color_string(char *color_string,GdkColor *color)

{
  int iVar1;
  
  if ((color != (GdkColor *)0x0) && (ghid_port.top_window != (GtkWidget *)0x0)) {
    if (ghid_map_color_string::colormap == (GdkColormap *)0x0) {
      ghid_map_color_string::colormap = (GdkColormap *)gtk_widget_get_colormap(ghid_port.top_window)
      ;
    }
    iVar1._0_2_ = color->red;
    iVar1._2_2_ = color->green;
    if ((iVar1 != 0) || (color->blue != 0)) {
      gdk_colormap_free_colors(ghid_map_color_string::colormap,color,1);
    }
    gdk_color_parse(color_string,color);
    gdk_color_alloc();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

gchar * ghid_get_color_name(GdkColor *color)

{
  gchar *pgVar1;
  
  if (color != (GdkColor *)0x0) {
    pgVar1 = (gchar *)g_strdup_printf("#%2.2x%2.2x%2.2x",*(undefined *)((int)&color->red + 1),
                                      *(undefined *)((int)&color->green + 1),
                                      *(undefined *)((int)&color->blue + 1));
    return pgVar1;
  }
  pgVar1 = (gchar *)g_strdup();
  return pgVar1;
}



// WARNING: Unknown calling convention

void ghid_draw_string_markup
               (GdkDrawable *drawable,PangoFontDescription *font_desc,GdkGC *gc,gint x,gint y,
               gchar *string)

{
  undefined4 uVar1;
  PangoLayout *layout;
  size_t sVar2;
  
  uVar1 = gtk_widget_create_pango_layout(ghid_port.top_window,0);
  pango_layout_set_font_description(uVar1,font_desc);
  sVar2 = strlen(string);
  pango_layout_set_markup(uVar1,string,sVar2);
  gdk_draw_layout(drawable,gc,x,y,uVar1);
  g_object_unref();
  return;
}



// WARNING: Unknown calling convention

void ghid_string_markup_extents
               (PangoFontDescription *font_desc,gchar *string,gint *width,gint *height)

{
  undefined4 uVar1;
  size_t sVar2;
  PangoLayout *layout;
  gint local_24;
  gint local_20 [4];
  
  uVar1 = gtk_widget_create_pango_layout(ghid_port.top_window,0);
  pango_layout_set_font_description(uVar1,font_desc);
  sVar2 = strlen(string);
  pango_layout_set_markup(uVar1,string,sVar2);
  pango_layout_get_pixel_size(uVar1,local_20,&local_24);
  g_object_unref(uVar1);
  if (*width != 0) {
    *width = local_20[0];
  }
  if (*height != 0) {
    *height = local_24;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_draw_area_update(GHidPort *port,GdkRectangle *rect)

{
  GdkRectangle update_rect;
  
  if (rect == (GdkRectangle *)0x0) {
    update_rect.x = 0;
    update_rect.y = 0;
    update_rect.width = port->width;
    update_rect.height = port->height;
  }
  else {
    update_rect.x = rect->x;
    update_rect.y = rect->y;
    update_rect.width = rect->width;
    update_rect.height = rect->height;
  }
  gdk_window_invalidate_rect(port->drawing_area->window,&update_rect,0);
  return;
}



// WARNING: Unknown calling convention

ButtonState ghid_button_state(GdkModifierType *state)

{
  ButtonState BVar1;
  ButtonState bs;
  GdkModifierType local_10 [3];
  
  if (state == (GdkModifierType *)0x0) {
    gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  }
  else {
    local_10[0] = *state;
  }
  BVar1 = BUTTON1_PRESSED;
  if (((local_10[0] & 0x100) == 0) && (BVar1 = BUTTON2_PRESSED, (local_10[0] & 0x200) == 0)) {
    BVar1 = ~-(uint)((local_10[0] & 0x400) == 0) & 3;
  }
  return BVar1;
}



// WARNING: Unknown calling convention

ModifierKeysState ghid_modifier_keys_state(GdkModifierType *state)

{
  byte bVar1;
  ModifierKeysState MVar2;
  ModifierKeysState mk;
  byte bVar3;
  gboolean shift;
  uint uVar4;
  gboolean mod1;
  uint uVar5;
  uint uVar6;
  gboolean control;
  bool bVar7;
  bool bVar8;
  GdkModifierType local_20 [4];
  
  if (state == (GdkModifierType *)0x0) {
    gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_20);
  }
  else {
    local_20[0] = *state;
  }
  uVar4 = local_20[0] & 1;
  uVar5 = local_20[0] & 8;
  uVar6 = local_20[0] & 4;
  bVar1 = uVar6 == 0 & (byte)uVar4;
  if ((bVar1 == 0) || (MVar2 = SHIFT_PRESSED, uVar5 != 0)) {
    bVar7 = uVar6 != 0;
    if (((((uVar4 != 0 || !bVar7) || (MVar2 = CONTROL_PRESSED, uVar5 != 0)) &&
         ((((bVar8 = uVar5 == 0, uVar6 != 0 || (uVar4 != 0)) || (MVar2 = MOD1_PRESSED, bVar8)) &&
          ((bVar3 = (byte)uVar4 & bVar7, bVar3 == 0 || (MVar2 = SHIFT_CONTROL_PRESSED, uVar5 != 0)))
          ))) && ((bVar1 == 0 || (MVar2 = SHIFT_MOD1_PRESSED, bVar8)))) &&
       (((uVar4 != 0 || !bVar7 || (MVar2 = CONTROL_MOD1_PRESSED, bVar8)) &&
        ((bVar3 == 0 || (MVar2 = SHIFT_CONTROL_MOD1_PRESSED, bVar8)))))) {
      MVar2 = NONE_PRESSED;
    }
  }
  return MVar2;
}



// WARNING: Unknown calling convention

void free_glist_and_data(GList **list_head)

{
  GList *list;
  GList *pGVar1;
  
  pGVar1 = *list_head;
  if (pGVar1 != (GList *)0x0) {
    do {
      if (pGVar1->data != (gpointer)0x0) {
        g_free(pGVar1->data);
      }
      pGVar1 = pGVar1->next;
    } while (pGVar1 != (GList *)0x0);
    g_list_free(*list_head);
    *list_head = (GList *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void ghid_route_style_dialog(gint index,RouteStyleType *temp_rst)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  gfloat gVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  GtkWidget *pGVar9;
  undefined4 uVar10;
  int iVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  GtkWidget *pGVar16;
  gchar *pgVar17;
  GtkWidget *table_00;
  int iVar18;
  char *pcVar19;
  gint gVar20;
  gfloat gVar21;
  gboolean set_temp1;
  RouteStyleType *rst;
  GtkWidget *label;
  GtkWidget *hbox;
  GtkWidget *table;
  gchar *string;
  gboolean set_default;
  int in_GS_OFFSET;
  bool bVar22;
  gdouble value;
  longdouble lVar23;
  gfloat local_c0;
  int local_a0;
  gfloat local_94;
  gfloat local_8c;
  RouteStyleType rst_buf;
  GtkWidget *local_64;
  gchar buf [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_64 = (GtkWidget *)0x0;
  bVar22 = index < 4;
  if (bVar22) {
    temp_rst = PCB->RouteStyle + index;
  }
  if (temp_rst == (RouteStyleType *)0x0) goto LAB_0810cf08;
  pcVar19 = temp_rst->Name;
  uVar7 = dcgettext(&DAT_0815492c,"%s Sizes",5);
  __snprintf_chk(buf,0x40,1,0x40,uVar7,pcVar19);
  uVar7 = gtk_window_get_type();
  uVar8 = g_type_check_instance_cast(ghid_port.top_window,uVar7);
  uVar8 = gtk_dialog_new_with_buttons(buf,uVar8,3,"gtk-cancel",0xffffffff,"gtk-ok",0xfffffffb,0);
  uVar7 = g_type_check_instance_cast(uVar8,uVar7);
  gtk_window_set_wmclass(uVar7,"Sizes_dialog",&DAT_08154932);
  pGVar9 = (GtkWidget *)gtk_vbox_new(0,2);
  uVar7 = gtk_container_get_type();
  uVar10 = g_type_check_instance_cast(pGVar9,uVar7);
  gtk_container_set_border_width(uVar10,6);
  uVar10 = gtk_dialog_get_type();
  iVar11 = g_type_check_instance_cast(uVar8,uVar10);
  uVar7 = g_type_check_instance_cast(*(undefined4 *)(iVar11 + 0x94),uVar7);
  gtk_container_add(uVar7,pGVar9);
  if (Settings.grid_units_mm == '\0') {
    uVar7 = dcgettext(&DAT_0815492c,&DAT_081562ee,5);
  }
  else {
    uVar7 = dcgettext(&DAT_0815492c,&DAT_0815627e,5);
  }
  uVar12 = dcgettext(&DAT_0815492c,"<b>%s</b> grid units are selected",5);
  uVar7 = g_strdup_printf(uVar12,uVar7);
  uVar12 = gtk_label_new(&DAT_0814741b);
  uVar13 = gtk_label_get_type();
  uVar14 = g_type_check_instance_cast(uVar12,uVar13);
  gtk_label_set_use_markup(uVar14,1);
  uVar14 = g_type_check_instance_cast(uVar12,uVar13);
  gtk_label_set_markup(uVar14,uVar7);
  g_free(uVar7);
  uVar7 = gtk_box_get_type();
  uVar14 = g_type_check_instance_cast(pGVar9,uVar7);
  gtk_box_pack_start(uVar14,uVar12,0,0,4);
  uVar12 = gtk_hbox_new(0,4);
  uVar14 = g_type_check_instance_cast(pGVar9,uVar7);
  gtk_box_pack_start(uVar14,uVar12,0,0,4);
  uVar14 = dcgettext(&DAT_0815492c,"Route style name",5);
  uVar14 = gtk_label_new(uVar14);
  uVar15 = g_type_check_instance_cast(uVar12,uVar7);
  gtk_box_pack_start(uVar15,uVar14,0,0,0);
  pGVar16 = (GtkWidget *)gtk_entry_new();
  route_sizes.name_entry = pGVar16;
  uVar12 = g_type_check_instance_cast(uVar12,uVar7);
  gtk_box_pack_start(uVar12,pGVar16,0,0,0);
  route_sizes.units_mm = (gboolean)Settings.grid_units_mm;
  pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Sizes",5);
  pGVar16 = ghid_category_vbox(pGVar9,pgVar17,4,2,1,1);
  table_00 = (GtkWidget *)gtk_table_new(4,2,0);
  uVar12 = gtk_table_get_type();
  uVar14 = g_type_check_instance_cast(table_00,uVar12);
  gtk_table_set_col_spacings(uVar14,6);
  uVar12 = g_type_check_instance_cast(table_00,uVar12);
  gtk_table_set_row_spacings(uVar12,3);
  pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Line width",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.0;
    local_c0 = 0.01;
    gVar21 = 100000.0;
    local_94 = 5.0;
    gVar20 = 1;
    gVar6 = (float)temp_rst->Thick * 0.01;
  }
  else {
    gVar6 = (float)temp_rst->Thick * 0.000254;
    local_8c = 0.05;
    local_c0 = 0.000254;
    gVar21 = 2540.0;
    local_94 = 0.25;
    gVar20 = 3;
  }
  ghid_table_spin_button
            (table_00,0,0,&route_sizes.line_width_spin_button,gVar6,local_c0,gVar21,local_8c,
             local_94,gVar20,0,(_func_void_varargs *)0x0,&route_sizes,1,pgVar17);
  pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Via hole",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.0;
    local_c0 = 4.0;
    gVar21 = 99996.0;
    local_94 = 5.0;
    gVar20 = 1;
    gVar6 = (float)temp_rst->Hole * 0.01;
  }
  else {
    gVar6 = (float)temp_rst->Hole * 0.000254;
    local_8c = 0.05;
    local_c0 = 0.1016;
    gVar21 = 2539.898;
    local_94 = 0.25;
    gVar20 = 3;
  }
  ghid_table_spin_button
            (table_00,1,0,&route_sizes.via_hole_spin_button,gVar6,local_c0,gVar21,local_8c,local_94,
             gVar20,0,via_hole_cb,&route_sizes,1,pgVar17);
  pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Via size",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.0;
    local_c0 = 8.0;
    gVar21 = 100000.0;
    local_94 = 5.0;
    gVar20 = 1;
    gVar6 = (float)temp_rst->Diameter * 0.01;
  }
  else {
    gVar6 = (float)temp_rst->Diameter * 0.000254;
    local_8c = 0.05;
    local_c0 = 0.2032;
    gVar21 = 2540.0;
    local_94 = 0.25;
    gVar20 = 3;
  }
  ghid_table_spin_button
            (table_00,2,0,&route_sizes.via_size_spin_button,gVar6,local_c0,gVar21,local_8c,local_94,
             gVar20,0,via_size_cb,&route_sizes,1,pgVar17);
  pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Clearance",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.0;
    local_c0 = 0.01;
    gVar21 = 100000.0;
    local_94 = 5.0;
    gVar20 = 1;
    gVar6 = (float)temp_rst->Keepaway * 0.01;
  }
  else {
    gVar6 = (float)temp_rst->Keepaway * 0.000254;
    local_8c = 0.05;
    local_c0 = 0.000254;
    gVar21 = 2540.0;
    local_94 = 0.25;
    gVar20 = 3;
  }
  ghid_table_spin_button
            (table_00,3,0,&route_sizes.clearance_spin_button,gVar6,local_c0,gVar21,local_8c,local_94
             ,gVar20,0,(_func_void_varargs *)0x0,&route_sizes,1,pgVar17);
  uVar12 = g_type_check_instance_cast(pGVar16,uVar7);
  gtk_box_pack_start(uVar12,table_00,0,0,0);
  if (bVar22) {
    pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Temporary Styles",5);
    pGVar16 = ghid_category_vbox(pGVar9,pgVar17,4,2,1,1);
    uVar12 = gtk_label_new(&DAT_0814741b);
    uVar14 = g_type_check_instance_cast(uVar12,uVar13);
    gtk_label_set_use_markup(uVar14,1);
    pcVar19 = temp_rst->Name;
    uVar14 = dcgettext(&DAT_0815492c,
                       "<small>Use values in a temporary route style instead of <b>%s</b>.</small>",
                       5);
    uVar14 = g_strdup_printf(uVar14,pcVar19);
    uVar15 = g_type_check_instance_cast(uVar12,uVar13);
    gtk_label_set_markup(uVar15,uVar14);
    g_free(uVar14);
    uVar14 = g_type_check_instance_cast(pGVar16,uVar7);
    gtk_box_pack_start(uVar14,uVar12,0,0,0);
    pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Temp1",5);
    ghid_check_button_connected
              (pGVar16,&route_sizes.set_temp1_button,0,1,0,0,0,use_temp_cb,&DAT_00000001,pgVar17);
    pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Temp2",5);
    ghid_check_button_connected
              (pGVar16,&route_sizes.set_temp2_button,0,1,0,0,0,use_temp_cb,(gpointer)0x2,pgVar17);
    pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Default Style",5);
    pGVar9 = ghid_category_vbox(pGVar9,pgVar17,4,2,1,1);
    uVar12 = gtk_label_new(&DAT_0814741b);
    uVar14 = g_type_check_instance_cast(uVar12,uVar13);
    gtk_label_set_use_markup(uVar14,1);
    uVar14 = dcgettext(&DAT_0815492c,
                       "<small>Use values as the default route style for new layouts.</small>",5);
    uVar14 = g_strdup_printf(uVar14);
    uVar13 = g_type_check_instance_cast(uVar12,uVar13);
    gtk_label_set_markup(uVar13,uVar14);
    g_free(uVar14);
    uVar7 = g_type_check_instance_cast(pGVar9,uVar7);
    gtk_box_pack_start(uVar7,uVar12,0,0,0);
    pgVar17 = (gchar *)dcgettext(&DAT_0815492c,"Set as default",5);
    ghid_check_button_connected
              (pGVar9,&local_64,0,1,0,0,0,(_func_void_varargs *)0x0,(gpointer)0x0,pgVar17);
    pcVar19 = temp_rst->Name;
    uVar7 = gtk_entry_get_type();
    uVar7 = g_type_check_instance_cast(route_sizes.name_entry,uVar7);
    gtk_entry_set_text(uVar7,pcVar19);
  }
  else {
    uVar7 = gtk_entry_get_type();
    pcVar19 = temp_rst->Name;
    uVar7 = g_type_check_instance_cast(route_sizes.name_entry,uVar7);
    gtk_entry_set_text(uVar7,pcVar19);
    uVar7 = gtk_editable_get_type();
    uVar7 = g_type_check_instance_cast(route_sizes.name_entry,uVar7);
    gtk_editable_set_editable(uVar7,0);
  }
  gtk_widget_show_all(uVar8);
  uVar7 = g_type_check_instance_cast(uVar8,uVar10);
  iVar11 = gtk_dialog_run(uVar7);
  if (iVar11 == -5) {
    iVar11 = 0;
    if (bVar22) {
      uVar7 = gtk_toggle_button_get_type();
      uVar10 = g_type_check_instance_cast(route_sizes.set_temp1_button,uVar7);
      iVar18 = gtk_toggle_button_get_active(uVar10);
      uVar10 = g_type_check_instance_cast(route_sizes.set_temp2_button,uVar7);
      local_a0 = gtk_toggle_button_get_active(uVar10);
      uVar7 = g_type_check_instance_cast(local_64,uVar7);
      iVar11 = gtk_toggle_button_get_active(uVar7);
      if ((local_a0 == 0) && (iVar18 == 0)) goto LAB_0810d410;
      bVar22 = iVar18 == 0;
      temp_rst = &rst_buf;
    }
    else {
LAB_0810d410:
      bVar22 = true;
      local_a0 = 0;
    }
    uVar7 = gtk_spin_button_get_type();
    uVar10 = g_type_check_instance_cast(route_sizes.line_width_spin_button,uVar7);
    lVar23 = (longdouble)gtk_spin_button_get_value(uVar10);
    if (Settings.grid_units_mm == '\0') {
      lVar23 = lVar23 * (longdouble)100.0;
    }
    else {
      lVar23 = lVar23 / (longdouble)0.000254;
    }
    temp_rst->Thick = (int)ROUND(lVar23 + (longdouble)0.5);
    uVar10 = g_type_check_instance_cast(route_sizes.via_hole_spin_button,uVar7);
    lVar23 = (longdouble)gtk_spin_button_get_value(uVar10);
    if (Settings.grid_units_mm == '\0') {
      lVar23 = lVar23 * (longdouble)100.0;
    }
    else {
      lVar23 = lVar23 / (longdouble)0.000254;
    }
    temp_rst->Hole = (int)ROUND(lVar23 + (longdouble)0.5);
    uVar10 = g_type_check_instance_cast(route_sizes.via_size_spin_button,uVar7);
    lVar23 = (longdouble)gtk_spin_button_get_value(uVar10);
    if (Settings.grid_units_mm == '\0') {
      lVar23 = lVar23 * (longdouble)100.0;
    }
    else {
      lVar23 = lVar23 / (longdouble)0.000254;
    }
    temp_rst->Diameter = (int)ROUND(lVar23 + (longdouble)0.5);
    uVar7 = g_type_check_instance_cast(route_sizes.clearance_spin_button,uVar7);
    lVar23 = (longdouble)gtk_spin_button_get_value(uVar7);
    if (Settings.grid_units_mm == '\0') {
      lVar23 = lVar23 * (longdouble)100.0;
    }
    else {
      lVar23 = lVar23 / (longdouble)0.000254;
    }
    temp_rst->Keepaway = (int)ROUND(lVar23 + (longdouble)0.5);
    if ((bVar22) && (index < 4)) {
      if (local_a0 != 0) {
        pcb_use_route_style(temp_rst);
        gVar20 = 1;
        goto LAB_0810d5a9;
      }
      pgVar17 = ghid_entry_get_text(route_sizes.name_entry);
      SaveFree(temp_rst->Name);
      pcVar19 = StripWhiteSpaceAndDup(pgVar17);
      temp_rst->Name = pcVar19;
      pcb_use_route_style(temp_rst);
      SetChangedFlag('\x01');
      ghid_route_style_set_button_label(temp_rst->Name,index);
    }
    else {
      pcb_use_route_style(temp_rst);
      if (bVar22) {
        gVar20 = 1;
        if (local_a0 == 0) {
          gVar20 = index + -4;
        }
      }
      else {
        gVar20 = 0;
      }
LAB_0810d5a9:
      ghid_route_style_set_temp_style(temp_rst,gVar20);
    }
    if (iVar11 != 0) {
      Settings.RouteStyle[index].Thick = temp_rst->Thick;
      Settings.RouteStyle[index].Diameter = temp_rst->Diameter;
      Settings.RouteStyle[index].Hole = temp_rst->Hole;
      Settings.RouteStyle[index].Keepaway = temp_rst->Keepaway;
      Settings.RouteStyle[index].Name = temp_rst->Name;
      Settings.RouteStyle[index].index = temp_rst->index;
      ghidgui->config_modified = 1;
      uVar10 = g_strdup(&DAT_0814741b);
      uVar7 = g_strdup_printf("%s,%d,%d,%d,%d",Settings.RouteStyle[0].Name,
                              Settings.RouteStyle[0].Thick,Settings.RouteStyle[0].Diameter,
                              Settings.RouteStyle[0].Hole,Settings.RouteStyle[0].Keepaway);
      uVar7 = g_strconcat(uVar10,uVar7,&DAT_0814d79c,0);
      iVar11 = 0;
      g_free(uVar10);
      while( true ) {
        puVar1 = (undefined4 *)((int)&Settings.RouteStyle[1].Keepaway + iVar11);
        puVar2 = (undefined4 *)((int)&Settings.RouteStyle[1].Hole + iVar11);
        puVar3 = (undefined4 *)((int)&Settings.RouteStyle[1].Diameter + iVar11);
        puVar4 = (undefined4 *)((int)&Settings.RouteStyle[1].Thick + iVar11);
        puVar5 = (undefined4 *)((int)&Settings.RouteStyle[1].Name + iVar11);
        iVar11 = iVar11 + 0x18;
        uVar10 = g_strdup_printf("%s,%d,%d,%d,%d",*puVar5,*puVar4,*puVar3,*puVar2,*puVar1);
        if (iVar11 == 0x48) break;
        uVar10 = g_strconcat(uVar7,uVar10,&DAT_0814d79c,0);
        g_free(uVar7);
        uVar7 = uVar10;
      }
      pcVar19 = (char *)g_strconcat(uVar7,uVar10,0,0);
      g_free(uVar7);
      g_free(Settings.Routes);
      Settings.Routes = pcVar19;
    }
  }
  gtk_widget_destroy(uVar8);
  ghid_set_status_line_label();
LAB_0810cf08:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void use_temp_cb(GtkWidget *button,gpointer data)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  gboolean active;
  GtkWidget *pGVar4;
  
  uVar1 = gtk_toggle_button_get_type();
  uVar2 = g_type_check_instance_cast(button,uVar1);
  iVar3 = gtk_toggle_button_get_active(uVar2);
  if ((iVar3 != 0) &&
     ((pGVar4 = route_sizes.set_temp2_button, (undefined *)data == &DAT_00000001 ||
      (pGVar4 = route_sizes.set_temp1_button, data == (gpointer)0x2)))) {
    g_type_check_instance_cast(pGVar4,uVar1);
    gtk_toggle_button_set_active();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void via_size_cb(GtkWidget *widget,SizesDialog *sd)

{
  undefined4 uVar1;
  undefined4 uVar2;
  gdouble via_hole_size;
  longdouble lVar3;
  longdouble lVar4;
  longdouble lVar5;
  double local_1c;
  
  uVar1 = gtk_spin_button_get_type();
  uVar2 = g_type_check_instance_cast(widget,uVar1);
  lVar3 = (longdouble)gtk_spin_button_get_value(uVar2);
  uVar2 = g_type_check_instance_cast(sd->via_hole_spin_button,uVar1);
  lVar4 = (longdouble)gtk_spin_button_get_value(uVar2);
  if (Settings.grid_units_mm == '\0') {
    lVar5 = (longdouble)4.0;
  }
  else {
    lVar5 = (longdouble)0.1016;
  }
  if ((longdouble)(double)lVar3 - lVar5 < lVar4) {
    if (Settings.grid_units_mm == '\0') {
      local_1c = 4.0;
    }
    else {
      local_1c = 0.1016;
    }
    uVar1 = g_type_check_instance_cast(sd->via_hole_spin_button,uVar1);
    gtk_spin_button_set_value(uVar1,(double)lVar3 - local_1c);
  }
  return;
}



// WARNING: Unknown calling convention

void via_hole_cb(GtkWidget *widget,SizesDialog *sd)

{
  float fVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  gdouble via_size;
  longdouble lVar4;
  longdouble lVar5;
  longdouble lVar6;
  
  uVar2 = gtk_spin_button_get_type();
  uVar3 = g_type_check_instance_cast(widget,uVar2);
  lVar4 = (longdouble)gtk_spin_button_get_value(uVar3);
  uVar3 = g_type_check_instance_cast(sd->via_size_spin_button,uVar2);
  lVar5 = (longdouble)gtk_spin_button_get_value(uVar3);
  if (Settings.grid_units_mm == '\0') {
    lVar6 = (longdouble)4.0;
  }
  else {
    lVar6 = (longdouble)0.1016;
  }
  if (lVar5 < lVar6 + (longdouble)(double)lVar4) {
    if (Settings.grid_units_mm == '\0') {
      fVar1 = 4.0;
    }
    else {
      fVar1 = 0.1016;
    }
    uVar2 = g_type_check_instance_cast(sd->via_size_spin_button,uVar2);
    gtk_spin_button_set_value(uVar2,(double)fVar1 + (double)lVar4);
  }
  return;
}



// WARNING: Unknown calling convention

void lpr_calibrate(double xval,double yval)

{
  ps_calibrate_1(xval,yval,1);
  return;
}



// WARNING: Unknown calling convention

HID_Attribute * lpr_get_export_options(int *n)

{
  HID_Attribute *pHVar1;
  HID_Attribute *ps_opts;
  
  if ((base_lpr_options[0].default_val.str_value == (char *)0x0) &&
     (base_lpr_options[0].default_val.str_value = (char *)calloc(1,4),
     (undefined4 *)base_lpr_options[0].default_val.str_value != (undefined4 *)0x0)) {
    *(undefined4 *)base_lpr_options[0].default_val.str_value = 0x72706c;
  }
  if (lpr_options == (HID_Attribute *)0x0) {
    pHVar1 = (*ps_hid.get_export_options)(&num_lpr_options);
    lpr_options = (HID_Attribute *)calloc(num_lpr_options,0x30);
    memcpy(lpr_options,pHVar1,num_lpr_options * 0x30);
    pHVar1 = lpr_options;
    lpr_options->name = base_lpr_options[0].name;
    pHVar1->help_text = base_lpr_options[0].help_text;
    pHVar1->type = base_lpr_options[0].type;
    pHVar1->min_val = base_lpr_options[0].min_val;
    pHVar1->max_val = base_lpr_options[0].max_val;
    (pHVar1->default_val).int_value = base_lpr_options[0].default_val.int_value;
    (pHVar1->default_val).str_value = base_lpr_options[0].default_val.str_value;
    *(undefined4 *)&(pHVar1->default_val).real_value =
         base_lpr_options[0].default_val.real_value._0_4_;
    *(undefined4 *)((int)&(pHVar1->default_val).real_value + 4) =
         base_lpr_options[0].default_val.real_value._4_4_;
    pHVar1->enumerations = base_lpr_options[0].enumerations;
    pHVar1->value = base_lpr_options[0].value;
    pHVar1->hash = base_lpr_options[0].hash;
    lpr_values = (HID_Attr_Val *)calloc(num_lpr_options,0x10);
  }
  pHVar1 = lpr_options;
  if (n != (int *)0x0) {
    *n = num_lpr_options;
  }
  return pHVar1;
}



// WARNING: Unknown calling convention

void lpr_parse_arguments(int *argc,char ***argv)

{
  lpr_get_export_options((int *)0x0);
  hid_register_attributes(lpr_options,num_lpr_options);
  hid_parse_command_line(argc,argv);
  return;
}



// WARNING: Unknown calling convention

void lpr_do_export(HID_Attr_Val *options)

{
  char *__command;
  HID_Attr_Val *pHVar1;
  int iVar2;
  FILE *f_00;
  FILE *f;
  HID_Attr_Val *pHVar3;
  int i;
  int iVar4;
  HID_Attribute *pHVar5;
  char *filename;
  
  if ((options == (HID_Attr_Val *)0x0) &&
     (lpr_get_export_options((int *)0x0), options = lpr_values, iVar2 = num_lpr_options,
     0 < num_lpr_options)) {
    iVar4 = 0;
    pHVar3 = lpr_values;
    pHVar5 = lpr_options;
    do {
      iVar4 = iVar4 + 1;
      pHVar3->int_value = (pHVar5->default_val).int_value;
      pHVar3->str_value = (pHVar5->default_val).str_value;
      *(undefined4 *)&pHVar3->real_value = *(undefined4 *)&(pHVar5->default_val).real_value;
      pHVar1 = &pHVar5->default_val;
      pHVar5 = pHVar5 + 1;
      *(undefined4 *)((int)&pHVar3->real_value + 4) = *(undefined4 *)((int)&pHVar1->real_value + 4);
      pHVar3 = pHVar3 + 1;
    } while (iVar4 != iVar2);
  }
  __command = options->str_value;
  __printf_chk(1,"LPR: open %s\n",__command);
  f_00 = popen(__command,"w");
  if (f_00 == (FILE *)0x0) {
    perror(__command);
    return;
  }
  ps_start_file((FILE *)f_00);
  ps_hid_export_to_file((FILE *)f_00,options);
  fclose(f_00);
  return;
}



// WARNING: Unknown calling convention

void hid_lpr_init(void)

{
  apply_default_hid(&lpr_hid,(HID *)&ps_hid);
  apply_default_hid(&lpr_hid,(HID *)0x0);
  hid_register_hid(&lpr_hid);
  return;
}



// WARNING: Unknown calling convention

void bom_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes(bom_options,3);
  hid_parse_command_line(argc,argv);
  return;
}



// WARNING: Unknown calling convention

double xyToAngle(double x,double y)

{
  double theta;
  
  if ((0.0 < x) && (0.0 <= y)) {
    return 180.0;
  }
  if ((x <= 0.0) && (0.0 < y)) {
    return 90.0;
  }
  if ((0.0 <= x) || (0.0 < y)) {
    if ((0.0 <= x) && (y < 0.0)) {
      return 270.0;
    }
    Message("xyToAngle(): unable to figure out angle of element\n     because the pin is at the centroid of the part.\n     This is a BUG!!!\n     Setting to %g degrees\n"
            ,0);
  }
  return 0.0;
}



// WARNING: Unknown calling convention

StringList * string_insert(char *str,StringList *list)

{
  _StringList *p_Var1;
  char *pcVar2;
  StringList *cur;
  StringList *pSVar3;
  StringList *new;
  
  new = (StringList *)calloc(1,8);
  if (new == (_StringList *)0x0) {
    __fprintf_chk(stderr,1,"malloc() failed in string_insert()\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  new->next = (_StringList *)0x0;
  pcVar2 = (char *)__strdup(str);
  new->str = pcVar2;
  p_Var1 = list;
  if (list != (StringList *)0x0) {
    do {
      pSVar3 = p_Var1;
      p_Var1 = pSVar3->next;
    } while (p_Var1 != (_StringList *)0x0);
    pSVar3->next = new;
    new = list;
  }
  return new;
}



// WARNING: Unknown calling convention

char * CleanBOMString(char *in)

{
  char cVar1;
  size_t sVar2;
  char *pcVar3;
  int i;
  uint uVar4;
  uint uVar5;
  
  sVar2 = strlen(in);
  pcVar3 = (char *)calloc(1,sVar2 + 1);
  if (pcVar3 != (char *)0x0) {
    uVar5 = 0;
    do {
      cVar1 = in[uVar5];
      if (cVar1 == '\"') {
        cVar1 = '\'';
      }
      uVar4 = uVar5 + 1;
      pcVar3[uVar5] = cVar1;
      sVar2 = strlen(in);
      uVar5 = uVar4;
    } while (uVar4 <= sVar2);
    return pcVar3;
  }
  __fprintf_chk(stderr,1,"Error:  CleanBOMString() malloc() failed\n");
                    // WARNING: Subroutine does not return
  exit(1);
}



// WARNING: Unknown calling convention

void print_and_free(FILE *fp,BomList *bom)

{
  _BomList *p_Var1;
  char *__ptr;
  char *__ptr_00;
  char *value;
  StringList *pSVar2;
  StringList *lasts;
  
  if (bom != (BomList *)0x0) {
    do {
      if (fp != (FILE *)0x0) {
        __ptr = CleanBOMString(bom->descr);
        __ptr_00 = CleanBOMString(bom->value);
        __fprintf_chk(fp,1,&DAT_0815ca1c,bom->num,__ptr,__ptr_00);
        free(__ptr);
        free(__ptr_00);
      }
      while (pSVar2 = bom->refdes, pSVar2 != (StringList *)0x0) {
        if (fp != (FILE *)0x0) {
          __fprintf_chk(fp,1,&DAT_08147f34,pSVar2->str);
          pSVar2 = bom->refdes;
        }
        free(pSVar2->str);
        pSVar2 = bom->refdes;
        bom->refdes = pSVar2->next;
        free(pSVar2);
      }
      if (fp != (FILE *)0x0) {
        __fprintf_chk(fp,1,"\n");
      }
      p_Var1 = bom->next;
      free(bom);
      bom = p_Var1;
    } while (p_Var1 != (_BomList *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

HID_Attribute * bom_get_export_options(int *n)

{
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,bom_options,".bom",&bom_get_export_options::last_bom_filename);
    derive_default_filename
              (PCB->Filename,bom_options + 1,".xy",&bom_get_export_options::last_xy_filename);
  }
  if (n != (int *)0x0) {
    *n = 3;
  }
  return bom_options;
}



// WARNING: Removing unreachable block (ram,0x0810eb21)
// WARNING: Unknown calling convention

void bom_do_export(HID_Attr_Val *options)

{
  int iVar1;
  ElementTypePtr paVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  FILE *pFVar14;
  tm *__tp;
  char *pcVar15;
  DataTypePtr paVar16;
  char *pcVar17;
  int iVar18;
  _BomList *p_Var19;
  int iVar20;
  PadTypePtr pad;
  char *pcVar21;
  StringList *pSVar22;
  FILE *fp;
  int iVar23;
  Cardinal sn_1;
  uint uVar24;
  char *value;
  BomList *bom;
  BomList *pBVar25;
  Cardinal n;
  uint uVar26;
  Cardinal n_1;
  char *descr;
  char *pcVar27;
  HID_Attr_Val *pHVar28;
  char *name;
  HID_Attr_Val *pHVar29;
  int in_GS_OFFSET;
  byte bVar30;
  double user_y;
  double sumy;
  double user_x;
  double dVar31;
  double local_dc;
  BomList *local_cc;
  int local_c8;
  double local_c4;
  double local_bc;
  int local_b0;
  double local_ac;
  double local_9c;
  int local_8c;
  double local_84;
  time_t local_64;
  char utcTime [64];
  
  bVar30 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (options == (HID_Attr_Val *)0x0) {
    bom_get_export_options((int *)0x0);
    pHVar28 = &bom_options[0].default_val;
    pHVar29 = bom_values;
    for (iVar23 = 4; iVar23 != 0; iVar23 = iVar23 + -1) {
      pHVar29->int_value = pHVar28->int_value;
      pHVar28 = (HID_Attr_Val *)((int)pHVar28 + ((uint)bVar30 * -2 + 1) * 4);
      pHVar29 = (HID_Attr_Val *)((int)pHVar29 + ((uint)bVar30 * -2 + 1) * 4);
    }
    pHVar28 = &bom_options[1].default_val;
    for (iVar23 = 4; iVar23 != 0; iVar23 = iVar23 + -1) {
      pHVar29->int_value = pHVar28->int_value;
      pHVar28 = (HID_Attr_Val *)((int)pHVar28 + ((uint)bVar30 * -2 + 1) * 4);
      pHVar29 = (HID_Attr_Val *)((int)pHVar29 + ((uint)bVar30 * -2 + 1) * 4);
    }
    options = bom_values;
    pHVar28 = &bom_options[2].default_val;
    for (iVar23 = 4; iVar23 != 0; iVar23 = iVar23 + -1) {
      pHVar29->int_value = pHVar28->int_value;
      pHVar28 = (HID_Attr_Val *)((int)pHVar28 + ((uint)bVar30 * -2 + 1) * 4);
      pHVar29 = (HID_Attr_Val *)((int)pHVar29 + ((uint)bVar30 * -2 + 1) * 4);
    }
  }
  bom_filename = "pcb-out.bom";
  if (options->str_value != (char *)0x0) {
    bom_filename = options->str_value;
  }
  xy_dim_type = options[2].int_value;
  xy_filename = "pcb-out.xy";
  if (options[1].str_value != (char *)0x0) {
    xy_filename = options[1].str_value;
  }
  pFVar14 = fopen(xy_filename,"w");
  if (pFVar14 == (FILE *)0x0) {
    (*gui->log)("Cannot open file %s for writing\n");
  }
  else {
    local_64 = time((time_t *)0x0);
    __tp = gmtime(&local_64);
    strftime(utcTime,0x40,"%c UTC",__tp);
    __fprintf_chk(pFVar14,1,"# $Id");
    __fprintf_chk(pFVar14,1,&DAT_0815ca47);
    __fprintf_chk(pFVar14,1,"# PcbXY Version 1.0\n");
    __fprintf_chk(pFVar14,1,"# Date: %s\n",utcTime);
    pcVar15 = pcb_author();
    __fprintf_chk(pFVar14,1,"# Author: %s\n",pcVar15);
    pcVar15 = PCB->Name;
    if (pcVar15 == (char *)0x0) {
      pcVar15 = "(unknown)";
    }
    else if (*pcVar15 == '\0') {
      pcVar15 = "(unknown)";
    }
    __fprintf_chk(pFVar14,1,"# Title: %s - PCB X-Y\n",pcVar15);
    __fprintf_chk(pFVar14,1,"# RefDes, Description, Value, X, Y, rotation, top/bottom\n");
    if (xy_dim_type == 0) {
      __fprintf_chk(pFVar14,1,"# X,Y in mils.  rotation in degrees.\n");
    }
    else {
      __fprintf_chk(pFVar14,1,"# X,Y in mm.  rotation in degrees.\n");
    }
    __fprintf_chk(pFVar14,1,"# --------------------------------------------\n");
    paVar16 = PCB->Data;
    local_b0 = paVar16->ElementN - 1;
    if (local_b0 != -1) {
      local_c4 = 0.0;
      local_bc = 0.0;
      local_cc = (BomList *)0x0;
      local_84 = 0.0;
      local_9c = 0.0;
      local_ac = 0.0;
      local_dc = 0.0;
      iVar23 = paVar16->ElementN * 300;
      do {
        local_c8 = iVar23 + -300;
        paVar2 = paVar16->Element;
        pcVar15 = *(char **)((int)(&paVar2[-1].Name[2].Flags + 2) + iVar23 + 8);
        if (pcVar15 == (char *)0x0) {
          pcVar15 = "(unknown)";
        }
        else if (*pcVar15 == '\0') {
          pcVar15 = "(unknown)";
        }
        pcVar27 = *(char **)((int)(&paVar2[-1].Name[0].Flags + 2) + iVar23 + 8);
        if (pcVar27 == (char *)0x0) {
          pcVar27 = "(unknown)";
        }
        else if (*pcVar27 == '\0') {
          pcVar27 = "(unknown)";
        }
        pcVar21 = *(char **)((int)(&paVar2[-1].Name[1].Flags + 2) + iVar23 + 8);
        p_Var19 = local_cc;
        if (pcVar21 == (char *)0x0) {
          pcVar17 = "(unknown)";
          if (local_cc != (BomList *)0x0) goto LAB_0810e3ea;
LAB_0810eb60:
          local_cc = (BomList *)calloc(1,0x14);
          if (local_cc == (BomList *)0x0) {
LAB_0810ee24:
            __fprintf_chk(stderr,1,"malloc() failed in bom_insert()\n");
                    // WARNING: Subroutine does not return
            exit(1);
          }
          local_cc->next = (_BomList *)0x0;
          pcVar27 = (char *)__strdup(pcVar27);
          local_cc->descr = pcVar27;
          pcVar15 = (char *)__strdup(pcVar15);
          local_cc->num = (int)&DAT_00000001;
          local_cc->value = pcVar15;
          pSVar22 = string_insert(pcVar17,(StringList *)0x0);
          local_cc->refdes = pSVar22;
        }
        else {
          pcVar17 = "(unknown)";
          if (*pcVar21 != '\0') {
            pcVar17 = pcVar21;
          }
          if (local_cc == (BomList *)0x0) goto LAB_0810eb60;
LAB_0810e3ea:
          do {
            pBVar25 = p_Var19;
            if ((((pBVar25->descr != (char *)0x0) &&
                 (iVar18 = strcmp(pcVar27,pBVar25->descr), iVar18 == 0)) &&
                (pBVar25->value != (char *)0x0)) &&
               (iVar18 = strcmp(pcVar15,pBVar25->value), iVar18 == 0)) {
              pBVar25->num = pBVar25->num + 1;
              pSVar22 = string_insert(pcVar17,pBVar25->refdes);
              iVar18 = *(int *)((int)&paVar2[-1].PinN + iVar23);
              pBVar25->refdes = pSVar22;
              goto joined_r0x0810eaf0;
            }
            p_Var19 = pBVar25->next;
          } while (pBVar25->next != (_BomList *)0x0);
          p_Var19 = (_BomList *)calloc(1,0x14);
          if (p_Var19 == (_BomList *)0x0) goto LAB_0810ee24;
          pBVar25->next = p_Var19;
          p_Var19->next = (_BomList *)0x0;
          pcVar27 = (char *)__strdup(pcVar27);
          p_Var19->descr = pcVar27;
          pcVar15 = (char *)__strdup(pcVar15);
          p_Var19->num = 1;
          p_Var19->value = pcVar15;
          pSVar22 = string_insert(pcVar17,(StringList *)0x0);
          p_Var19->refdes = pSVar22;
        }
        iVar18 = *(int *)((int)&paVar2[-1].PinN + iVar23);
joined_r0x0810eaf0:
        if (iVar18 == 0) {
          dVar7 = 0.0;
          dVar8 = 0.0;
          bVar12 = false;
          bVar11 = false;
          local_8c = 0;
        }
        else {
          dVar7 = 0.0;
          iVar20 = *(int *)((int)&paVar2[-1].Pin + iVar23);
          bVar11 = false;
          local_8c = 0;
          dVar31 = local_bc;
          dVar8 = dVar7;
          dVar9 = local_c4;
          bVar13 = false;
          do {
            dVar6 = (double)*(int *)(iVar20 + 0x34);
            pcVar15 = *(char **)(iVar20 + 0x40);
            dVar7 = dVar7 + dVar6;
            dVar10 = (double)*(int *)(iVar20 + 0x38);
            dVar8 = dVar8 + dVar10;
            local_bc = dVar31;
            local_c4 = dVar9;
            bVar12 = bVar13;
            if (pcVar15 != (char *)0x0) {
              if ((*pcVar15 == '1') && (pcVar15[1] == '\0')) {
                bVar11 = true;
                local_84 = 0.0;
                local_ac = dVar6;
                local_9c = dVar10;
              }
              else if ((*pcVar15 == '2') &&
                      (local_bc = dVar6, local_c4 = dVar10, bVar12 = true, pcVar15[1] != '\0')) {
                local_bc = dVar31;
                local_c4 = dVar9;
                bVar12 = bVar13;
              }
            }
            local_8c = local_8c + 1;
            iVar20 = iVar20 + 0x4c;
            dVar31 = local_bc;
            dVar9 = local_c4;
            bVar13 = bVar12;
          } while (local_8c != iVar18);
        }
        uVar3 = *(uint *)((int)&paVar2[-1].PadN + iVar23);
        uVar24 = uVar3;
        for (uVar26 = 0; (uVar24 != 0 && (uVar26 < uVar24)); uVar26 = uVar26 + (uVar3 == uVar24)) {
          pad = (PadTypePtr)(uVar26 * 0x68 + *(int *)((int)&paVar2[-1].Pad + iVar23));
          iVar18 = (pad->Point1).X;
          iVar20 = (pad->Point2).X;
          iVar4 = (pad->Point1).Y;
          iVar5 = (pad->Point2).Y;
          dVar9 = (double)(iVar20 + iVar18) * 0.5;
          pcVar15 = pad->Number;
          dVar31 = (double)(iVar4 + iVar5) * 0.5;
          if (pcVar15 != (char *)0x0) {
            if ((*pcVar15 == '1') && (pcVar15[1] == '\0')) {
              local_84 = atan2((double)(iVar4 - iVar5),(double)(iVar20 - iVar18));
              bVar11 = true;
              uVar24 = *(uint *)((int)&paVar2[-1].PadN + iVar23);
              local_84 = local_84 * 57.29577951308232;
              local_ac = dVar9;
              local_9c = dVar31;
            }
            else if ((*pcVar15 == '2') && (pcVar15[1] == '\0')) {
              atan2((double)(iVar4 - iVar5),(double)(iVar20 - iVar18));
              bVar12 = true;
              uVar24 = *(uint *)((int)&paVar2[-1].PadN + iVar23);
              local_c4 = dVar31;
              local_bc = dVar9;
            }
          }
          dVar7 = dVar7 + dVar9;
          local_8c = local_8c + 1;
          dVar8 = dVar8 + dVar31;
        }
        if (local_8c != 0) {
          dVar7 = dVar7 / (double)local_8c;
          dVar8 = (double)local_8c / dVar8;
          if (bVar11) {
            local_ac = local_ac - dVar7;
            local_9c = -(local_9c - dVar8);
            dVar31 = local_84;
            if (local_8c != 1) {
              if ((local_ac == 0.0) && (local_9c == 0.0)) {
                if (bVar12) {
                  dVar31 = xyToAngle(local_bc,local_c4);
                }
                else {
                  Message(
                         "PrintBOM(): unable to figure out angle of element\n     %s because pin #1 is at the centroid of the part.\n     and I could not find pin #2\'s location\n     Setting to %g degrees\n"
                         );
                  dVar31 = local_dc;
                }
              }
              else {
                dVar31 = xyToAngle(local_ac,local_9c);
              }
            }
            local_dc = dVar31;
            pcVar15 = *(char **)((int)(&paVar2[-1].Name[1].Flags + 2) + iVar23 + 8);
            if (pcVar15 != (char *)0x0) goto LAB_0810e904;
LAB_0810eac1:
            pcVar15 = "(unknown)";
          }
          else {
            Message(
                   "PrintBOM(): unable to figure out angle because I could\n     not find pin #1 of element %s\n     Setting to %g degrees\n"
                   );
            pcVar15 = *(char **)((int)(&paVar2[-1].Name[1].Flags + 2) + iVar23 + 8);
            local_dc = 0.0;
            if (pcVar15 == (char *)0x0) goto LAB_0810eac1;
LAB_0810e904:
            if (*pcVar15 == '\0') {
              pcVar15 = "(unknown)";
            }
          }
          pcVar27 = CleanBOMString(pcVar15);
          pcVar15 = *(char **)((int)(&paVar2[-1].Name[0].Flags + 2) + iVar23 + 8);
          if (pcVar15 == (char *)0x0) {
            pcVar15 = "(unknown)";
          }
          else if (*pcVar15 == '\0') {
            pcVar15 = "(unknown)";
          }
          pcVar21 = CleanBOMString(pcVar15);
          pcVar15 = *(char **)((int)(&paVar2[-1].Name[2].Flags + 2) + iVar23 + 8);
          if (pcVar15 == (char *)0x0) {
            pcVar15 = "(unknown)";
          }
          else if (*pcVar15 == '\0') {
            pcVar15 = "(unknown)";
          }
          pcVar15 = CleanBOMString(pcVar15);
          dVar8 = (double)PCB->MaxHeight - dVar8;
          if (xy_dim_type == 0) {
            dVar7 = dVar7 * 0.01;
            dVar8 = dVar8 * 0.01;
          }
          else {
            dVar7 = dVar7 * 0.000254;
            dVar8 = dVar8 * 0.000254;
          }
          pcVar17 = "air-bottom";
          if ((*(uint *)(paVar2[-1].Flags.t + iVar23 + -4) >> 7 & 1) == (int)Settings.ShowSolderSide
             ) {
            pcVar17 = "air-top";
          }
          __fprintf_chk(pFVar14,1,"%s,\"%s\",\"%s\",%.2f,%.2f,%g,%s\n",pcVar27,pcVar21,pcVar15,dVar7
                        ,dVar8,local_dc,pcVar17 + 4);
          free(pcVar27);
          free(pcVar21);
          free(pcVar15);
        }
        local_b0 = local_b0 + -1;
        if (local_b0 == -1) goto LAB_0810ec06;
        paVar16 = PCB->Data;
        iVar23 = local_c8;
      } while( true );
    }
    local_cc = (BomList *)0x0;
LAB_0810ec06:
    fclose(pFVar14);
    pFVar14 = fopen(bom_filename,"w");
    if (pFVar14 == (FILE *)0x0) {
      (*gui->log)("Cannot open file %s for writing\n");
      print_and_free((FILE *)0x0,local_cc);
    }
    else {
      __fprintf_chk(pFVar14,1,"# $Id");
      __fprintf_chk(pFVar14,1,&DAT_0815ca47);
      __fprintf_chk(pFVar14,1,"# PcbBOM Version 1.0\n");
      __fprintf_chk(pFVar14,1,"# Date: %s\n",utcTime);
      pcVar15 = pcb_author();
      __fprintf_chk(pFVar14,1,"# Author: %s\n",pcVar15);
      pcVar15 = PCB->Name;
      if (pcVar15 == (char *)0x0) {
        pcVar15 = "(unknown)";
      }
      else if (*pcVar15 == '\0') {
        pcVar15 = "(unknown)";
      }
      __fprintf_chk(pFVar14,1,"# Title: %s - PCB BOM\n",pcVar15);
      __fprintf_chk(pFVar14,1,"# Quantity, Description, Value, RefDes\n");
      __fprintf_chk(pFVar14,1,"# --------------------------------------------\n");
      print_and_free((FILE *)pFVar14,local_cc);
      fclose(pFVar14);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void hid_bom_init(void)

{
  apply_default_hid(&bom_hid,(HID *)0x0);
  hid_register_hid(&bom_hid);
  return;
}



// WARNING: Unknown calling convention

int drill_sort(void *va,void *vb)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = 0;
  if (*va != *vb) {
    iVar1 = *va - *vb;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void gerber_use_mask(int use_it)

{
  current_mask = use_it;
  return;
}



// WARNING: Unknown calling convention

void gerber_set_line_cap(hidGC_conflict2 gc,EndCapStyle style)

{
  gc->cap = style;
  return;
}



// WARNING: Unknown calling convention

void gerber_set_line_width(hidGC_conflict2 gc,int width)

{
  gc->width = width;
  return;
}



// WARNING: Unknown calling convention

void gerber_set_draw_xor(hidGC_conflict2 gc,int xor)

{
  return;
}



// WARNING: Unknown calling convention

void gerber_set_draw_faded(hidGC_conflict2 gc,int faded)

{
  return;
}



// WARNING: Unknown calling convention

void gerber_set_crosshair(int x,int y,int action)

{
  return;
}



// WARNING: Unknown calling convention

void hid_gerber_init(void)

{
  apply_default_hid((HID *)&gerber_hid,(HID *)0x0);
  hid_register_hid((HID *)&gerber_hid);
  return;
}



// WARNING: Unknown calling convention

void gerber_calibrate(double xval,double yval)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented Gerber function %s.\n",
                "gerber_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void gerber_set_line_cap_angle(hidGC_conflict2 gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented Gerber function %s.\n",
                "gerber_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

int findApertureCode(int width,ApertureShape shape)

{
  ApertureShape *pAVar1;
  int iVar2;
  Apertures *pAVar3;
  int iVar4;
  int i;
  
  pAVar3 = curapp;
  iVar2 = global_aperture_count;
  if (width == 0) {
    return 0;
  }
  if (0 < global_aperture_count) {
    iVar4 = 0;
    do {
      if ((global_aperture_sizes[iVar4] == width) && (global_aperture_shapes[iVar4] == shape)) {
        curapp->aperture_used[iVar4] = 1;
        pAVar3->some_apertures = 1;
        return iVar4 + 0xb;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < global_aperture_count);
    if (0x9ff < global_aperture_count) {
      Message("Error, too many apertures needed for Gerber file.\n");
      return 10;
    }
  }
  global_aperture_sizes[global_aperture_count] = width;
  pAVar3 = curapp;
  pAVar1 = global_aperture_shapes + global_aperture_count;
  global_aperture_count = global_aperture_count + 1;
  *pAVar1 = shape;
  pAVar3->aperture_used[iVar2] = 1;
  pAVar3->some_apertures = 1;
  return iVar2 + 0xb;
}



// WARNING: Unknown calling convention

void use_gc(hidGC_conflict2 gc,int radius)

{
  int iVar1;
  int c;
  EndCapStyle EVar2;
  int iVar3;
  int ap;
  char *pcVar4;
  ApertureShape shape;
  
  if (radius == 0) {
    iVar3 = gc->width;
    if (iVar3 == linewidth) {
      EVar2 = gc->cap;
      if (lastcap == EVar2) {
        return;
      }
    }
    else {
      EVar2 = gc->cap;
    }
    shape = SQUARE;
    if (EVar2 < Beveled_Cap) {
      shape = *(ApertureShape *)(CSWTCH_161 + EVar2 * 4);
    }
    linewidth = iVar3;
    lastcap = EVar2;
    iVar3 = findApertureCode(iVar3,shape);
    if (iVar3 < 1) {
      pcVar4 = "SQUARE";
      if (shape == ROUND) {
        pcVar4 = "ROUND";
      }
      __fprintf_chk(stderr,1,"error: aperture for width %d type %s is %d\n",linewidth,pcVar4,iVar3);
    }
    if (f != (FILE *)0x0) {
      __fprintf_chk(f,1,"G54D%d*",iVar3);
    }
  }
  else {
    iVar3 = radius * 2;
    if ((iVar3 - linewidth != 0) || (lastcap != 2)) {
      iVar1 = findApertureCode(iVar3,ROUND);
      if (iVar1 < 1) {
        __fprintf_chk(stderr,1,"error: aperture for radius %d type ROUND is %d\n",iVar3,iVar1);
      }
      if ((f != (FILE *)0x0) && (is_drill == 0)) {
        __fprintf_chk(f,1,"G54D%d*",iVar1);
      }
      linewidth = iVar3;
      lastcap = 2;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void gerber_fill_polygon(hidGC_conflict2 gc,int n_coords,int *x,int *y)

{
  int iVar1;
  Boolean m;
  int firstTime;
  int iVar2;
  int i;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int local_2c;
  int local_28;
  
  if (((is_mask != 0) && (current_mask == 1)) || (use_gc(gc,1000), f == (FILE *)0x0)) {
    return;
  }
  __fprintf_chk(f,1,"G36*\r\n");
  local_28 = 0;
  local_2c = 0;
  if (0 < n_coords) {
    iVar2 = 0;
    bVar5 = true;
    do {
      while( true ) {
        iVar1 = x[iVar2];
        bVar3 = iVar1 != lastX;
        if (bVar3) {
          lastX = iVar1;
          __fprintf_chk(f,1,&DAT_0815cd61,iVar1);
        }
        iVar1 = y[iVar2];
        bVar4 = iVar1 != lastY;
        if (bVar4) {
          lastY = iVar1;
          __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - iVar1);
        }
        if (!bVar5) break;
        local_2c = x[iVar2];
        local_28 = y[iVar2];
        if (bVar4 || bVar3) {
          __fprintf_chk(f,1,&DAT_0815cd6b);
        }
LAB_0810f27f:
        iVar2 = iVar2 + 1;
        bVar5 = false;
        if (n_coords <= iVar2) goto LAB_0810f348;
      }
      if (!bVar4 && !bVar3) goto LAB_0810f27f;
      iVar2 = iVar2 + 1;
      bVar5 = false;
      __fprintf_chk(f,1,"D01*\r\n");
    } while (iVar2 < n_coords);
  }
LAB_0810f348:
  bVar5 = local_2c == lastX;
  if (!bVar5) {
    lastX = local_2c;
    __fprintf_chk(f,1,&DAT_0815cd61,local_2c);
  }
  if (local_28 == lastY) {
    if (bVar5) goto LAB_0810f3e1;
  }
  else {
    lastY = local_28;
    __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - local_28);
  }
  __fprintf_chk(f,1,"D01*\r\n");
LAB_0810f3e1:
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention

void gerber_fill_rect(hidGC_conflict2 gc,int x1,int y1,int x2,int y2)

{
  int y [5];
  int x [5];
  
  y[4] = y1;
  y[0] = y1;
  y[3] = y1;
  y[1] = y2;
  y[2] = y2;
  x[4] = x1;
  x[0] = x1;
  x[1] = x1;
  x[2] = x2;
  x[3] = x2;
  gerber_fill_polygon(gc,5,x,y);
  return;
}



// WARNING: Unknown calling convention

void gerber_draw_rect(hidGC_conflict2 gc,int x1,int y1,int x2,int y2)

{
  int y [5];
  int x [5];
  
  y[4] = y1;
  y[0] = y1;
  y[3] = y1;
  y[1] = y2;
  y[2] = y2;
  x[4] = x1;
  x[0] = x1;
  x[1] = x1;
  x[2] = x2;
  x[3] = x2;
  gerber_fill_polygon(gc,5,x,y);
  return;
}



// WARNING: Unknown calling convention

void gerber_fill_circle(hidGC_conflict2 gc,int cx,int cy,int radius)

{
  PendingDrills *pPVar1;
  
  if (0 < radius) {
    if (is_drill != 0) {
      radius = ((radius + 0x19) / 0x32) * 0x32;
    }
    use_gc(gc,radius);
    if (f != (FILE *)0x0) {
      if (is_drill == 0) {
        if ((gc->drill == 0) || (flash_drills != 0)) {
          if (cx != lastX) {
            lastX = cx;
            __fprintf_chk(f,1,&DAT_0815cd61,cx);
          }
          if (cy != lastY) {
            lastY = cy;
            __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - cy);
          }
          __fprintf_chk();
          return;
        }
      }
      else {
        if (max_pending_drills <= n_pending_drills) {
          max_pending_drills = max_pending_drills + 100;
          pending_drills = (PendingDrills *)realloc(pending_drills,max_pending_drills * 0xc);
        }
        pPVar1 = pending_drills + n_pending_drills;
        n_pending_drills = n_pending_drills + 1;
        pPVar1->x = cx;
        pPVar1->diam = radius * 2;
        pPVar1->y = cy;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void gerber_draw_line(hidGC_conflict2 gc,int x1,int y1,int x2,int y2)

{
  float fVar1;
  float fVar2;
  Boolean m;
  bool bVar3;
  bool bVar4;
  float ty;
  float tx;
  double dVar5;
  double local_5c;
  double local_54 [2];
  int y [5];
  int x [5];
  
  if (((y1 == y2) || (x1 == x2)) || (gc->cap != Square_Cap)) {
    use_gc(gc,0);
    if (f != (FILE *)0x0) {
      bVar3 = x1 != lastX;
      if (bVar3) {
        lastX = x1;
        __fprintf_chk(f,1,&DAT_0815cd61,x1);
      }
      bVar4 = y1 != lastY;
      if (bVar4) {
        lastY = y1;
        __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - y1);
      }
      if ((y1 == y2) && (x1 == x2)) {
        __fprintf_chk(f,1,"D03*\r\n");
        return;
      }
      if (bVar4 || bVar3) {
        __fprintf_chk(f,1,&DAT_0815cd6b);
      }
      if (x2 != lastX) {
        lastX = x2;
        __fprintf_chk(f,1,&DAT_0815cd61,x2);
      }
      if (y2 != lastY) {
        lastY = y2;
        __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - y2);
      }
      __fprintf_chk(f,1,"D01*\r\n");
    }
  }
  else {
    dVar5 = atan2((double)(y2 - y1),(double)(x2 - x1));
    fVar1 = (float)gc->width * 0.5;
    sincos((double)((float)dVar5 + 0.7853982),local_54,&local_5c);
    fVar2 = (float)local_5c * fVar1 * 1.414214;
    fVar1 = (float)local_54[0] * fVar1 * 1.414214;
    x[0] = (int)ROUND((float)x1 - fVar2);
    y[0] = (int)ROUND((float)y1 - fVar1);
    x[1] = (int)ROUND((float)x2 + fVar1);
    y[1] = (int)ROUND((float)y2 - fVar2);
    x[2] = (int)ROUND((float)x2 + fVar2);
    y[2] = (int)ROUND((float)y2 + fVar1);
    x[3] = (int)ROUND((float)x1 - fVar1);
    y[3] = (int)ROUND((float)y1 + fVar2);
    y[4] = y[0];
    x[4] = x[0];
    gerber_fill_polygon(gc,5,x,y);
  }
  return;
}



// WARNING: Unknown calling convention

void gerber_draw_arc(hidGC_conflict2 gc,int cx,int cy,int width,int height,int start_angle,
                    int delta_angle)

{
  int x2;
  int y2;
  double dVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  int minr;
  FILE *pFVar6;
  int x0;
  Boolean m;
  int x1_00;
  uint uVar7;
  int y0;
  int y1_00;
  double *__cosx;
  int x1;
  int nsteps;
  int max;
  int iVar8;
  int y1;
  double step;
  double angle;
  double dVar9;
  double local_2c;
  double local_24 [2];
  
  if (gc->width == 0) {
    return;
  }
  use_gc(gc,0);
  pFVar6 = f;
  if (f == (FILE *)0x0) {
    return;
  }
  dVar1 = (double)start_angle;
  sincos(dVar1 * 0.0174532925199433,local_24,&local_2c);
  fVar2 = (float)cx - (float)width * (float)local_2c;
  fVar3 = (float)height * (float)local_24[0] + (float)cy;
  uVar7 = delta_angle >> 0x1f;
  if (width != height) {
    max = height;
    if (height < width) {
      max = width;
    }
    iVar8 = max - gc->width / 10;
    if (max <= iVar8) {
      iVar8 = max + -1;
    }
    dVar9 = acos((double)iVar8 / (double)max);
    dVar9 = (dVar9 * 180.0) / 3.141592653589793;
    if (5.0 <= dVar9 || dVar9 != 5.0) {
      dVar9 = 5.0;
    }
    iVar8 = (int)ROUND((double)((delta_angle ^ uVar7) - uVar7) / dVar9 + 1.0);
    dVar9 = (double)iVar8;
    if (iVar8 < 1) {
      return;
    }
    x1_00 = (int)ROUND(fVar2);
    y1_00 = (int)ROUND(fVar3);
    do {
      dVar1 = dVar1 + (double)delta_angle / dVar9;
      iVar8 = iVar8 + -1;
      sincos(dVar1 * 0.0174532925199433,local_24,&local_2c);
      x2 = (int)ROUND((double)cx - (double)width * local_2c);
      y2 = (int)ROUND((double)height * local_24[0] + (double)cy);
      gerber_draw_line(gc,x1_00,y1_00,x2,y2);
      x1_00 = x2;
      y1_00 = y2;
    } while (0 < iVar8);
    return;
  }
  __cosx = &local_2c;
  sincos((double)(delta_angle + start_angle) * 0.0174532925199433,local_24,__cosx);
  fVar4 = (float)height * (float)local_24[0] + (float)cy;
  fVar5 = (float)lastX;
  if (fVar5 != fVar2) {
    lastX = (int)ROUND(fVar2);
    __cosx = (double *)lastX;
    __fprintf_chk(pFVar6,1,&DAT_0815cd61,lastX);
    pFVar6 = f;
  }
  if ((float)lastY == fVar3) {
    if (fVar5 == fVar2) goto LAB_0810fc5b;
  }
  else {
    lastY = (int)ROUND(fVar3);
    __cosx = (double *)(PCB->MaxHeight - lastY);
    __fprintf_chk(pFVar6,1,&DAT_0815cd66,__cosx);
    pFVar6 = f;
  }
  __fprintf_chk(pFVar6,1,&DAT_0815cd6b,__cosx);
  pFVar6 = f;
LAB_0810fc5b:
  iVar8 = (int)ROUND((float)cx - (float)local_2c * (float)width);
  __fprintf_chk(pFVar6,1,"G75*G0%1dX%ldY%ldI%ldJ%ldD01*G01*\r\n",uVar7 + 3,iVar8,
                (int)ROUND((float)PCB->MaxHeight - fVar4),(int)ROUND((float)cx - fVar2),
                (int)ROUND(-((float)cy - fVar3)));
  lastY = (int)ROUND(fVar4);
  lastX = iVar8;
  return;
}



// WARNING: Unknown calling convention

void gerber_set_color(hidGC_conflict2 gc,char *name)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  bool bVar4;
  
  iVar1 = 6;
  bVar4 = &stack0x00000000 == &DAT_00000010;
  pcVar2 = name;
  pcVar3 = "erase";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *pcVar2 == *pcVar3;
    pcVar2 = pcVar2 + 1;
    pcVar3 = pcVar3 + 1;
  } while (bVar4);
  if (bVar4) {
    gc->color = 1;
    gc->erase = 1;
    gc->drill = 0;
  }
  else {
    iVar1 = 6;
    pcVar2 = "drill";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      bVar4 = *name == *pcVar2;
      name = name + 1;
      pcVar2 = pcVar2 + 1;
    } while (bVar4);
    if (bVar4) {
      gc->color = 1;
      gc->erase = 0;
      gc->drill = 1;
    }
    else {
      gc->color = 0;
      gc->erase = 0;
      gc->drill = 0;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void gerber_destroy_gc(hidGC_conflict2 gc)

{
  free(gc);
  return;
}



// WARNING: Unknown calling convention

hidGC_conflict2 gerber_make_gc(void)

{
  hidGC_conflict2 phVar1;
  
  phVar1 = (hidGC_conflict2)calloc(1,0x14);
  phVar1->cap = Trace_Cap;
  return phVar1;
}



// WARNING: Unknown calling convention

void maybe_close_f(void)

{
  if (f != (FILE *)0x0) {
    if (was_drill == 0) {
      __fprintf_chk(f,1,"M02*\r\n");
    }
    else {
      __fprintf_chk(f,1,"M30\r\n");
    }
    fclose((FILE *)f);
  }
  f = (FILE *)0x0;
  return;
}



// WARNING: Unknown calling convention

int gerber_set_layer(char *name,int group,int empty)

{
  Apertures *pAVar1;
  int iVar2;
  ApertureShape AVar3;
  int iVar4;
  uint idx;
  passwd *pwentry;
  char *pcVar5;
  int i_2;
  int iVar6;
  int ap;
  Apertures *pAVar7;
  int i_1;
  tm *__tp;
  __uid_t __uid;
  passwd *ppVar8;
  char *pcVar9;
  ushort **ppuVar10;
  int __res;
  __int32_t **pp_Var11;
  int iVar12;
  char cVar13;
  int iVar14;
  int c;
  int dCode;
  uint uVar15;
  Apertures *pAVar16;
  int i;
  int *piVar17;
  char *cp;
  char *pcVar18;
  char *sext;
  int some_apertures;
  int i_3;
  int width;
  int in_GS_OFFSET;
  bool bVar19;
  byte bVar20;
  undefined *puVar21;
  char *local_7c;
  time_t local_64;
  char utcTime [64];
  
  bVar20 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  local_7c = name;
  idx = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    idx = (PCB->LayerGroups).Entries[group][0];
  }
  if (name == (char *)0x0) {
    local_7c = PCB->Data->Layer[idx].Name;
  }
  bVar19 = idx == 0;
  if ((((int)idx < 0) ||
      (uVar15 = PCB->Data->LayerN, bVar19 = idx == uVar15, (int)uVar15 <= (int)idx)) ||
     (bVar19 = print_layer[idx] == 0, !bVar19)) {
    iVar12 = 10;
    pcVar18 = local_7c;
    pcVar5 = "invisible";
    do {
      if (iVar12 == 0) break;
      iVar12 = iVar12 + -1;
      bVar19 = *pcVar18 == *pcVar5;
      pcVar18 = pcVar18 + 1;
      pcVar5 = pcVar5 + 1;
    } while (bVar19);
    if ((!bVar19) &&
       ((bVar19 = idx == 0, -1 < (int)idx || (bVar19 = (idx & 0xf0) == 0x80, !bVar19)))) {
      iVar12 = 8;
      flash_drills = 0;
      pcVar18 = local_7c;
      pcVar5 = "outline";
      do {
        if (iVar12 == 0) break;
        iVar12 = iVar12 + -1;
        bVar19 = *pcVar18 == *pcVar5;
        pcVar18 = pcVar18 + 1;
        pcVar5 = pcVar5 + 1;
      } while (bVar19);
      if (bVar19) {
LAB_0810ffea:
        flash_drills = 1;
      }
      else {
        iVar12 = 6;
        pcVar18 = local_7c;
        pcVar5 = "route";
        do {
          if (iVar12 == 0) break;
          iVar12 = iVar12 + -1;
          bVar19 = *pcVar18 == *pcVar5;
          pcVar18 = pcVar18 + 1;
          pcVar5 = pcVar5 + 1;
        } while (bVar19);
        if (bVar19) goto LAB_0810ffea;
      }
      if ((is_drill != 0) && (n_pending_drills != 0)) {
        qsort(pending_drills,n_pending_drills,0xc,drill_sort);
        if (0 < n_pending_drills) {
          iVar12 = 0;
          iVar14 = 0;
          do {
            if (iVar14 == 0) {
              iVar6 = *(int *)((int)&pending_drills->diam + iVar12);
LAB_08110328:
              iVar6 = findApertureCode(iVar6,ROUND);
              __fprintf_chk(f,1,"T%02d\r\n",iVar6);
              piVar17 = (int *)((int)&pending_drills->diam + iVar12);
            }
            else {
              piVar17 = (int *)((int)&pending_drills->diam + iVar12);
              iVar6 = *piVar17;
              if (iVar6 != *(int *)((int)&pending_drills[-1].diam + iVar12)) goto LAB_08110328;
            }
            iVar14 = iVar14 + 1;
            iVar12 = iVar12 + 0xc;
            __fprintf_chk(f,1,"X%06ldY%06ld\r\n",piVar17[1] / 10,(PCB->MaxHeight - piVar17[2]) / 10)
            ;
          } while (iVar14 < n_pending_drills);
        }
        free(pending_drills);
        max_pending_drills = 0;
        n_pending_drills = 0;
        pending_drills = (PendingDrills *)0x0;
      }
      iVar14 = n_layerapps;
      iVar12 = c_layerapps;
      if ((int)idx < 0) {
        uVar15 = idx & 0xf0;
        if ((uVar15 == 0x40) || (uVar15 == 0x30)) {
          is_drill = 1;
        }
        else {
          is_drill = 0;
        }
        is_mask = 1;
        if (uVar15 != 0x20) goto LAB_08110020;
      }
      else {
        is_drill = 0;
LAB_08110020:
        is_mask = 0;
      }
      current_mask = 0;
      if ((group < 0) || (group != lastgroup)) {
        lastX = -1;
        lastY = -1;
        lastgroup = group;
        lastcolor = 0;
        linewidth = -1;
        lastcap = -1;
        pAVar7 = layerapps;
        if (n_layerapps <= c_layerapps) {
          n_layerapps = c_layerapps + 1;
          pAVar7 = (Apertures *)MyRealloc(layerapps,n_layerapps * 0x2804,"SetAppLayer");
          pAVar1 = pAVar7 + n_layerapps;
          layerapps = pAVar7;
          for (pAVar16 = pAVar7 + iVar14; pAVar16 < pAVar1; pAVar16 = pAVar16 + 1) {
            pAVar16->some_apertures = 0;
            iVar14 = 0;
            do {
              pAVar16->aperture_used[iVar14] = 0;
              iVar14 = iVar14 + 1;
            } while (iVar14 != 0xa00);
          }
        }
        c_layerapps = c_layerapps + 1;
        curapp = pAVar7 + iVar12;
        if (finding_apertures == 0) {
          if ((curapp->some_apertures != 0) || (all_layers != 0)) {
            maybe_close_f();
            pcVar18 = ".gbr";
            pagecount = pagecount + 1;
            if (idx + 0xfd0 < 0x11) {
              pcVar18 = *(char **)(CSWTCH_164 + (idx + 0xfd0) * 4);
            }
            pcVar5 = layer_type_to_file_name(idx);
            strcpy(filesuff,pcVar5);
            strcat(filesuff,pcVar18);
            f = (FILE *)fopen(filename,"w");
            if (f == (FILE *)0x0) {
              Message("Error:  Could not open %s for writing.\n",filename);
              iVar12 = 1;
              goto LAB_0811024c;
            }
            was_drill = is_drill;
            if (verbose != 0) {
              iVar14 = 0;
              iVar12 = 0;
              do {
                iVar14 = (iVar14 + 1) - (uint)(curapp->aperture_used[iVar12] == 0);
                iVar12 = iVar12 + 1;
              } while (iVar12 != 0xa00);
              pcVar5 = "s";
              if (iVar14 == 1) {
                pcVar5 = "";
              }
              __printf_chk(1,"Gerber: %d aperture%s in %s\n",iVar14,pcVar5,filename);
            }
            if (is_drill == 0) {
              __fprintf_chk(f,1,"G04 start of page %d for group %d idx %d *\r\n",pagecount,group,idx
                           );
              local_64 = time((time_t *)0x0);
              __tp = gmtime(&local_64);
              strftime(utcTime,0x40,"%c UTC",__tp);
              if ((local_7c == (char *)0x0) || (*local_7c == '\0')) {
                local_7c = "(unknown)";
              }
              pcVar5 = PCB->Name;
              if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
                pcVar5 = "(unknown)";
              }
              __fprintf_chk(f,1,"G04 Title: %s, %s *\r\n",pcVar5,local_7c);
              __fprintf_chk(f,1,"G04 Creator: %s 20091103 *\r\n",Progname);
              __fprintf_chk(f,1,"G04 CreationDate: %s *\r\n",utcTime);
              __uid = getuid();
              ppVar8 = getpwuid(__uid);
              __fprintf_chk(f,1,"G04 For: %s *\r\n",ppVar8->pw_name);
              __fprintf_chk(f,1,"G04 Format: Gerber/RS-274X *\r\n");
              __fprintf_chk(f,1,"G04 PCB-Dimensions: %d %d *\r\n",PCB->MaxWidth,PCB->MaxHeight);
              __fprintf_chk(f,1,"G04 PCB-Coordinate-Origin: lower left *\r\n");
              __fprintf_chk(f,1,"%%MOIN*%%\r\n");
              __fprintf_chk(f,1,"%%FSLAX25Y25*%%\r\n");
              if (layername != (char *)0x0) {
                free(layername);
              }
              pcVar9 = (char *)__strdup(filesuff);
              iVar12 = -1;
              pcVar5 = pcVar9;
              do {
                if (iVar12 == 0) break;
                iVar12 = iVar12 + -1;
                cVar13 = *pcVar5;
                pcVar5 = pcVar5 + (uint)bVar20 * -2 + 1;
              } while (cVar13 != '\0');
              iVar14 = -1;
              do {
                if (iVar14 == 0) break;
                iVar14 = iVar14 + -1;
                cVar13 = *pcVar18;
                pcVar18 = pcVar18 + (uint)bVar20 * -2 + 1;
              } while (cVar13 != '\0');
              layername = pcVar9;
              pcVar9[iVar14 - iVar12] = '\0';
              cVar13 = *pcVar9;
              pcVar18 = pcVar9;
              if (cVar13 != '\0') {
                ppuVar10 = __ctype_b_loc();
                do {
                  iVar12 = (int)cVar13;
                  if ((*(byte *)(*ppuVar10 + iVar12) & 8) == 0) {
                    *pcVar9 = '_';
                  }
                  else {
                    if (iVar12 + 0x80U < 0x180) {
                      pp_Var11 = __ctype_toupper_loc();
                      cVar13 = (char)(*pp_Var11)[iVar12];
                    }
                    *pcVar9 = cVar13;
                  }
                  pcVar9 = pcVar9 + 1;
                  cVar13 = *pcVar9;
                  pcVar18 = layername;
                } while (cVar13 != '\0');
              }
              iVar14 = 0;
              iVar12 = 0;
              __fprintf_chk(f,1,"%%LN%s*%%\r\n",pcVar18);
              lncount = 1;
              do {
                if (curapp->aperture_used[iVar12] != 0) {
                  AVar3 = global_aperture_shapes[iVar12];
                  iVar14 = iVar14 + 1;
                  iVar6 = iVar12 + 0xb;
                  iVar4 = global_aperture_sizes[iVar12];
                  if (AVar3 == OCTAGON) {
                    __fprintf_chk(f,1,"%%AMOCT%d*5,0,8,0,0,%.4f,22.5*%%\r\n%%ADD%dOCT%d*%%\r\n",
                                  iVar6,(double)iVar4 / 92387.95330000001,iVar6,iVar6);
                  }
                  else if (AVar3 == ROUND) {
                    __fprintf_chk(f,1,"%%ADD%dC,%.4f*%%\r\n",iVar6,(double)((float)iVar4 / 100000.0)
                                 );
                  }
                  else if (AVar3 == SQUARE) {
                    __fprintf_chk(f,1,"%%ADD%dR,%.4fX%.4f*%%\r\n",iVar6,
                                  (double)((float)iVar4 / 100000.0));
                  }
                }
                iVar12 = iVar12 + 1;
              } while (iVar12 != 0xa00);
              if (iVar14 != 0) goto LAB_081102bc;
              puVar21 = &DAT_0815cebf;
            }
            else {
              iVar12 = 0;
              __fprintf_chk(f,1,"M48\r\nINCH\r\n");
              do {
                if (curapp->aperture_used[iVar12] != 0) {
                  __fprintf_chk(f,1,"T%02dC%.3f\r\n",iVar12 + 0xb,
                                (double)((float)global_aperture_sizes[iVar12] / 100000.0));
                }
                iVar12 = iVar12 + 1;
              } while (iVar12 != 0xa00);
              puVar21 = &DAT_0815cecf;
            }
            __fprintf_chk(f,1,puVar21);
            iVar12 = 1;
            goto LAB_0811024c;
          }
          goto LAB_0811024a;
        }
      }
LAB_081102bc:
      iVar12 = 1;
      goto LAB_0811024c;
    }
  }
LAB_0811024a:
  iVar12 = 0;
LAB_0811024c:
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar12;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void gerber_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes(gerber_options,3);
  hid_parse_command_line(argc,argv);
  return;
}



// WARNING: Unknown calling convention

int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int d;
  int iVar1;
  int iVar2;
  int iVar3;
  int a;
  int b;
  
                    // WARNING: Load size is inaccurate
  Layer = *va;
                    // WARNING: Load size is inaccurate
  Layer_00 = *vb;
  iVar1 = PCB->Data->LayerN;
  iVar3 = iVar1 + 1;
  if (((int)Layer_00 < 0) || (iVar3 < (int)Layer_00)) {
    iVar2 = iVar1 + 3 + Layer_00;
  }
  else {
    iVar2 = GetLayerGroupNumberByNumber(Layer_00);
    iVar1 = PCB->Data->LayerN;
    iVar3 = iVar1 + 1;
  }
  if ((iVar3 < (int)Layer) || ((int)Layer < 0)) {
    iVar3 = iVar1 + 3 + Layer;
  }
  else {
    iVar3 = GetLayerGroupNumberByNumber(Layer);
  }
  iVar1 = iVar2 - iVar3;
  if (iVar2 - iVar3 == 0) {
    iVar1 = Layer_00 - Layer;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

HID_Attribute * gerber_get_export_options(int *n)

{
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,gerber_options,"",&gerber_get_export_options::last_made_filename);
  }
  if (n != (int *)0x0) {
    *n = 3;
  }
  return gerber_options;
}



// WARNING: Unknown calling convention

void gerber_do_export(HID_Attr_Val *options)

{
  uchar uVar1;
  uchar uVar2;
  uchar uVar3;
  uchar uVar4;
  uchar uVar5;
  uchar uVar6;
  uchar uVar7;
  uchar uVar8;
  uint uVar9;
  size_t sVar10;
  int iVar11;
  PCBTypePtr pPVar12;
  DataTypePtr paVar13;
  char *fnbase;
  char *pcVar14;
  Cardinal Layer;
  int i;
  Cardinal CVar15;
  int *piVar16;
  byte bVar17;
  int save_ons [18];
  BoxType region;
  
  bVar17 = 0;
  uVar1 = (PCB->Flags).t[7];
  uVar9 = (PCB->Flags).f;
  uVar2 = (PCB->Flags).t[6];
  uVar3 = (PCB->Flags).t[5];
  uVar4 = (PCB->Flags).t[4];
  uVar5 = (PCB->Flags).t[3];
  uVar6 = (PCB->Flags).t[2];
  uVar7 = (PCB->Flags).t[1];
  uVar8 = (PCB->Flags).t[0];
  (PCB->Flags).f = uVar9 & 0xfffdbfff;
  if (options == (HID_Attr_Val *)0x0) {
    gerber_get_export_options((int *)0x0);
    gerber_values[0].int_value = gerber_options[0].default_val.int_value;
    options = gerber_values;
    gerber_values[0].str_value = gerber_options[0].default_val.str_value;
    gerber_values[0].real_value._0_4_ = gerber_options[0].default_val.real_value._0_4_;
    gerber_values[0].real_value._4_4_ = gerber_options[0].default_val.real_value._4_4_;
    gerber_values[1].int_value = gerber_options[1].default_val.int_value;
    gerber_values[1].str_value = gerber_options[1].default_val.str_value;
    gerber_values[1].real_value._0_4_ = gerber_options[1].default_val.real_value._0_4_;
    gerber_values[1].real_value._4_4_ = gerber_options[1].default_val.real_value._4_4_;
    gerber_values[2].int_value = gerber_options[2].default_val.int_value;
    gerber_values[2].str_value = gerber_options[2].default_val.str_value;
    gerber_values[2].real_value._0_4_ = gerber_options[2].default_val.real_value._0_4_;
    gerber_values[2].real_value._4_4_ = gerber_options[2].default_val.real_value._4_4_;
  }
  pcVar14 = options->str_value;
  if (pcVar14 == (char *)0x0) {
    pcVar14 = "pcb-out";
  }
  verbose = options[2].int_value;
  all_layers = options[1].int_value;
  sVar10 = strlen(pcVar14);
  filename = (char *)MyRealloc(filename,sVar10 + 0x28,"gerber");
  strcpy(filename,pcVar14);
  pcVar14 = filename;
  sVar10 = strlen(filename);
  *(undefined2 *)(pcVar14 + sVar10) = 0x2e;
  pcVar14 = filename;
  sVar10 = strlen(filename);
  filesuff = pcVar14 + sVar10;
  if (all_layers == 0) {
    piVar16 = print_group;
    for (iVar11 = 0x10; iVar11 != 0; iVar11 = iVar11 + -1) {
      *piVar16 = 0;
      piVar16 = piVar16 + (uint)bVar17 * -2 + 1;
    }
    piVar16 = print_layer;
    for (iVar11 = 0x10; iVar11 != 0; iVar11 = iVar11 + -1) {
      *piVar16 = 0;
      piVar16 = piVar16 + (uint)bVar17 * -2 + 1;
    }
  }
  else {
    print_group[0] = 0x1010101;
    print_group[1] = 0x1010101;
    print_group[2] = 0x1010101;
    print_group[3] = 0x1010101;
    print_group[4] = 0x1010101;
    print_group[5] = 0x1010101;
    print_group[6] = 0x1010101;
    print_group[7] = 0x1010101;
    print_group[8] = 0x1010101;
    print_group[9] = 0x1010101;
    print_group[10] = 0x1010101;
    print_group[11] = 0x1010101;
    print_group[12] = 0x1010101;
    print_group[13] = 0x1010101;
    print_group[14] = 0x1010101;
    print_group[15] = 0x1010101;
    print_layer[0] = 0x1010101;
    print_layer[1] = 0x1010101;
    print_layer[2] = 0x1010101;
    print_layer[3] = 0x1010101;
    print_layer[4] = 0x1010101;
    print_layer[5] = 0x1010101;
    print_layer[6] = 0x1010101;
    print_layer[7] = 0x1010101;
    print_layer[8] = 0x1010101;
    print_layer[9] = 0x1010101;
    print_layer[10] = 0x1010101;
    print_layer[11] = 0x1010101;
    print_layer[12] = 0x1010101;
    print_layer[13] = 0x1010101;
    print_layer[14] = 0x1010101;
    print_layer[15] = 0x1010101;
  }
  hid_save_and_show_layer_ons(save_ons);
  paVar13 = PCB->Data;
  CVar15 = paVar13->LayerN;
  if (0 < (int)CVar15) {
    Layer = 0;
    pPVar12 = PCB;
    do {
      if ((((paVar13->Layer[Layer].LineN != 0) || (paVar13->Layer[Layer].TextN != 0)) ||
          (paVar13->Layer[Layer].ArcN != 0)) || (paVar13->Layer[Layer].PolygonN != 0)) {
        iVar11 = GetLayerGroupNumberByNumber(Layer);
        print_group[iVar11] = 1;
        pPVar12 = PCB;
      }
      paVar13 = pPVar12->Data;
      Layer = Layer + 1;
      CVar15 = paVar13->LayerN;
    } while ((int)Layer < (int)CVar15);
  }
  iVar11 = GetLayerGroupNumberByNumber(CVar15);
  print_group[iVar11] = 1;
  iVar11 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  print_group[iVar11] = 1;
  if (0 < PCB->Data->LayerN) {
    CVar15 = 0;
    do {
      iVar11 = GetLayerGroupNumberByNumber(CVar15);
      if (print_group[iVar11] != 0) {
        print_layer[CVar15] = 1;
      }
      CVar15 = CVar15 + 1;
      piVar16 = &PCB->Data->LayerN;
    } while (*piVar16 != CVar15 && (int)CVar15 <= *piVar16);
  }
  gerber_do_export::saved_layer_stack[0] = LayerStack[0];
  gerber_do_export::saved_layer_stack[1] = LayerStack[1];
  gerber_do_export::saved_layer_stack[2] = LayerStack[2];
  gerber_do_export::saved_layer_stack[3] = LayerStack[3];
  gerber_do_export::saved_layer_stack[4] = LayerStack[4];
  gerber_do_export::saved_layer_stack[5] = LayerStack[5];
  gerber_do_export::saved_layer_stack[6] = LayerStack[6];
  gerber_do_export::saved_layer_stack[7] = LayerStack[7];
  gerber_do_export::saved_layer_stack[8] = LayerStack[8];
  gerber_do_export::saved_layer_stack[9] = LayerStack[9];
  gerber_do_export::saved_layer_stack[10] = LayerStack[10];
  gerber_do_export::saved_layer_stack[11] = LayerStack[11];
  gerber_do_export::saved_layer_stack[12] = LayerStack[12];
  gerber_do_export::saved_layer_stack[13] = LayerStack[13];
  gerber_do_export::saved_layer_stack[14] = LayerStack[14];
  gerber_do_export::saved_layer_stack[15] = LayerStack[15];
  qsort(LayerStack,PCB->Data->LayerN,4,layer_sort);
  region.X1 = 0;
  region.Y1 = 0;
  linewidth = -1;
  region.X2 = PCB->MaxWidth;
  lastcap = -1;
  lastcolor = -1;
  layerapps = (Apertures *)0x0;
  region.Y2 = PCB->MaxHeight;
  f = (FILE *)0x0;
  pagecount = 1;
  n_layerapps = 0;
  lastgroup = -1;
  c_layerapps = 0;
  finding_apertures = 1;
  hid_expose_callback((HID *)&gerber_hid,&region,(void *)0x0);
  c_layerapps = 0;
  finding_apertures = 0;
  hid_expose_callback((HID *)&gerber_hid,&region,(void *)0x0);
  LayerStack[0] = gerber_do_export::saved_layer_stack[0];
  LayerStack[1] = gerber_do_export::saved_layer_stack[1];
  LayerStack[2] = gerber_do_export::saved_layer_stack[2];
  LayerStack[3] = gerber_do_export::saved_layer_stack[3];
  LayerStack[4] = gerber_do_export::saved_layer_stack[4];
  LayerStack[5] = gerber_do_export::saved_layer_stack[5];
  LayerStack[6] = gerber_do_export::saved_layer_stack[6];
  LayerStack[7] = gerber_do_export::saved_layer_stack[7];
  LayerStack[8] = gerber_do_export::saved_layer_stack[8];
  LayerStack[9] = gerber_do_export::saved_layer_stack[9];
  LayerStack[10] = gerber_do_export::saved_layer_stack[10];
  LayerStack[11] = gerber_do_export::saved_layer_stack[11];
  LayerStack[12] = gerber_do_export::saved_layer_stack[12];
  LayerStack[13] = gerber_do_export::saved_layer_stack[13];
  LayerStack[14] = gerber_do_export::saved_layer_stack[14];
  LayerStack[15] = gerber_do_export::saved_layer_stack[15];
  maybe_close_f();
  hid_restore_layer_ons(save_ons);
  pPVar12 = PCB;
  (PCB->Flags).t[7] = uVar1;
  (pPVar12->Flags).f = uVar9;
  (pPVar12->Flags).t[6] = uVar2;
  (pPVar12->Flags).t[5] = uVar3;
  (pPVar12->Flags).t[4] = uVar4;
  (pPVar12->Flags).t[3] = uVar5;
  (pPVar12->Flags).t[2] = uVar6;
  (pPVar12->Flags).t[1] = uVar7;
  (pPVar12->Flags).t[0] = uVar8;
  return;
}



// WARNING: Unknown calling convention

void nelma_use_mask(int use_it)

{
  return;
}



// WARNING: Unknown calling convention

void nelma_set_line_cap(hidGC_conflict3 gc,EndCapStyle style)

{
  gc->cap = style;
  return;
}



// WARNING: Unknown calling convention

void nelma_set_line_width(hidGC_conflict3 gc,int width)

{
  gc->width = width;
  return;
}



// WARNING: Unknown calling convention

void nelma_set_draw_xor(hidGC_conflict3 gc,int xor)

{
  return;
}



// WARNING: Unknown calling convention

void nelma_set_draw_faded(hidGC_conflict3 gc,int faded)

{
  gc->faded = faded;
  return;
}



// WARNING: Unknown calling convention

void nelma_set_crosshair(int x,int y,int a)

{
  return;
}



// WARNING: Unknown calling convention

void nelma_calibrate(double xval,double yval)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented PNG function %s.\n","nelma_calibrate")
  ;
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nelma_set_line_cap_angle(hidGC_conflict3 gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented PNG function %s.\n",
                "nelma_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void nelma_write_layer(FILE *out,int z,int h,char *name,int full,char *mat)

{
  uint uVar1;
  LibraryMenuTypePtr paVar2;
  LibraryEntryTypePtr paVar3;
  int m;
  uint uVar4;
  uint uVar5;
  LibraryMenuTypePtr net;
  uint local_24;
  
  __fprintf_chk(out,1,"layer %s {\n",name);
  __fprintf_chk(out,1,"\theight = %d\n",h);
  __fprintf_chk(out,1,"\tz-order = %d\n",z);
  __fprintf_chk(out,1,"\tmaterial = \"%s\"\n",mat);
  if (full != 0) {
    __fprintf_chk(out,1,"\tobjects = {\n",mat);
    uVar1 = (PCB->NetlistLib).MenuN;
    paVar2 = (PCB->NetlistLib).Menu;
    if (uVar1 != 0) {
      local_24 = 0;
      do {
        if (paVar2[local_24].EntryN != 0) {
          uVar5 = 0;
          do {
            paVar3 = paVar2[local_24].Entry;
            if ((uVar5 != 0) || (local_24 != 0)) {
              __fprintf_chk(out,1,&DAT_0815d367,mat);
            }
            uVar4 = uVar5 + 1;
            mat = paVar3[uVar5].ListEntry;
            __fprintf_chk(out,1,"\t\t\"%s-%s\"",mat,name);
            uVar5 = uVar4;
          } while (uVar4 < paVar2[local_24].EntryN);
        }
        local_24 = local_24 + 1;
      } while (local_24 < uVar1);
    }
    __fprintf_chk(out,1,"\n\t}\n",mat);
  }
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention

void nelma_write_material(FILE *out,char *name,char *type,double e)

{
  __fprintf_chk(out,1,"material %s {\n",name);
  __fprintf_chk(out,1,"\ttype = \"%s\"\n",type);
  __fprintf_chk(out,1,"\tpermittivity = %e\n",e);
  __fprintf_chk(out,1,"\tconductivity = 0.0\n");
  __fprintf_chk(out,1,"\tpermeability = 0.0\n");
  __fprintf_chk(out,1,"}\n");
  return;
}



// WARNING: Unknown calling convention

void use_gc(hidGC_conflict3 gc)

{
  int iVar1;
  color_struct *pcVar2;
  hidval hVar3;
  uint uVar4;
  gdImagePtr pgVar5;
  undefined4 uVar6;
  int fg;
  int iVar7;
  undefined4 uVar8;
  int bg;
  int r;
  int in_GS_OFFSET;
  int iVar9;
  char local_12d;
  hidval bval;
  char name [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (gc->me_pointer != &nelma_hid) {
    __fprintf_chk(stderr,1,"Fatal: GC from another HID passed to nelma HID\n");
                    // WARNING: Subroutine does not return
    abort();
  }
  if (gc->width == linewidth) {
    if (gc->brush == lastbrush) goto LAB_081114e4;
  }
  else {
    gdImageSetThickness(nelma_im,(gc->width * nelma_dpi) / 100000);
    linewidth = gc->width;
  }
  if ((gc->cap == Trace_Cap) || (gc->cap == Round_Cap)) {
    local_12d = 'C';
    iVar7 = gc->width / 2;
    uVar8 = 0x43;
  }
  else {
    iVar7 = gc->width;
    local_12d = 'S';
    uVar8 = 0x53;
  }
  iVar9 = (iVar7 * nelma_dpi) / 100000;
  pcVar2 = gc->color;
  __sprintf_chk(name,1,0x100,"#%.2x%.2x%.2x_%c_%d",pcVar2->r,pcVar2->g,pcVar2->b,uVar8,iVar9);
  iVar7 = hid_cache_color(0,name,&bval,&use_gc::lexical_block_0::bcache);
  if (iVar7 == 0) {
    if (local_12d == 'C') {
      iVar7 = iVar9 * 2 + 1;
      pgVar5 = (gdImagePtr)gdImageCreate(iVar7,iVar7);
      gc->brush = pgVar5;
    }
    else {
      pgVar5 = (gdImagePtr)gdImageCreate(iVar9 + 1,iVar9 + 1);
      gc->brush = pgVar5;
    }
    uVar8 = gdImageColorAllocate(pgVar5,0xff,0xff,0xff);
    pcVar2 = gc->color;
    uVar6 = gdImageColorAllocate(gc->brush,pcVar2->r,pcVar2->g,pcVar2->b);
    gdImageColorTransparent(gc->brush,uVar8);
    if (iVar9 == 0) {
      iVar9 = 0;
LAB_0811164c:
      gdImageFilledRectangle(gc->brush,0,0,iVar9,iVar9,uVar6);
    }
    else {
      if (local_12d != 'C') goto LAB_0811164c;
      gdImageFilledEllipse(gc->brush,iVar9,iVar9,iVar9 * 2,iVar9 * 2,uVar6);
    }
    bval = (hidval)gc->brush;
    hid_cache_color(1,name,&bval,&use_gc::lexical_block_0::bcache);
    hVar3 = (hidval)gc->brush;
  }
  else {
    gc->brush = (gdImagePtr)bval;
    hVar3 = bval;
  }
  gdImageSetBrush(nelma_im,hVar3.lval);
  lastbrush = gc->brush;
LAB_081114e4:
  uVar4 = (uint)gc->r << 0x18 | (uint)gc->g << 0x10 | gc->faded | (uint)gc->b << 8;
  if ((uVar4 != lastcolor) && ((is_drill != 0 || (lastcolor = uVar4, is_mask != 0)))) {
    lastcolor = 0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void nelma_fill_rect(hidGC_conflict3 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  gdImageFilledRectangle
            (nelma_im,(nelma_dpi * x1) / 100000,(y1 * nelma_dpi) / 100000,(x2 * nelma_dpi) / 100000,
             (y2 * nelma_dpi) / 100000,gc->color->c);
  return;
}



// WARNING: Unknown calling convention

void nelma_fill_circle(hidGC_conflict3 gc,int cx,int cy,int radius)

{
  int iVar1;
  int nelma;
  
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  iVar1 = (nelma_dpi * 2 * radius) / 100000;
  gdImageFilledEllipse
            (nelma_im,(nelma_dpi * cx) / 100000,(cy * nelma_dpi) / 100000,iVar1,iVar1,gc->color->c);
  return;
}



// WARNING: Unknown calling convention

hidGC_conflict3 nelma_make_gc(void)

{
  hidGC_conflict3 phVar1;
  color_struct *pcVar2;
  
  phVar1 = (hidGC_conflict3)calloc(1,0x20);
  phVar1->me_pointer = &nelma_hid;
  phVar1->cap = Trace_Cap;
  phVar1->width = 1;
  pcVar2 = (color_struct *)calloc(1,0x10);
  pcVar2->b = 0;
  pcVar2->g = 0;
  pcVar2->r = 0;
  pcVar2->c = 0;
  phVar1->color = pcVar2;
  return phVar1;
}



// WARNING: Unknown calling convention

void nelma_fill_polygon(hidGC_conflict3 gc,int n_coords,int *x,int *y)

{
  int iVar1;
  void *__ptr;
  int i;
  
  __ptr = calloc(1,n_coords << 3);
  if (__ptr != (void *)0x0) {
    use_gc(gc);
    iVar1 = nelma_dpi;
    if (0 < n_coords) {
      i = 0;
      do {
        *(int *)((int)__ptr + i * 8) = (x[i] * iVar1) / 100000;
        *(int *)((int)__ptr + i * 8 + 4) = (iVar1 * y[i]) / 100000;
        i = i + 1;
      } while (i != n_coords);
    }
    gdImageSetThickness(nelma_im,0);
    linewidth = 0;
    gdImageFilledPolygon(nelma_im,__ptr,n_coords,gc->color->c);
    free(__ptr);
    return;
  }
  __fprintf_chk(stderr,1,"ERROR:  nelma_fill_polygon():  malloc failed\n");
                    // WARNING: Subroutine does not return
  exit(1);
}



// WARNING: Unknown calling convention

void nelma_destroy_gc(hidGC_conflict3 gc)

{
  free(gc);
  return;
}



// WARNING: Unknown calling convention

void nelma_draw_rect(hidGC_conflict3 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageRectangle(nelma_im,(nelma_dpi * x1) / 100000,(y1 * nelma_dpi) / 100000,
                   (x2 * nelma_dpi) / 100000,(y2 * nelma_dpi) / 100000,gc->color->c);
  return;
}



// WARNING: Unknown calling convention

void nelma_draw_arc(hidGC_conflict3 gc,int cx,int cy,int width,int height,int start_angle,
                   int delta_angle)

{
  int iVar1;
  int iVar2;
  int ea;
  int iVar3;
  int sa;
  
  iVar1 = 0xb4 - start_angle;
  iVar2 = -delta_angle;
  if (iVar2 == 0 || 0 < delta_angle) {
    iVar2 = iVar2 + iVar1;
    iVar3 = iVar1;
  }
  else {
    iVar3 = iVar2 + iVar1;
    iVar2 = iVar1;
  }
  for (; iVar2 < 0; iVar2 = iVar2 + 0x168) {
    iVar3 = iVar3 + 0x168;
  }
  for (; 0x167 < iVar2; iVar2 = iVar2 + -0x168) {
    iVar3 = iVar3 + -0x168;
  }
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  gdImageArc(nelma_im,(nelma_dpi * cx) / 100000,(cy * nelma_dpi) / 100000,
             (nelma_dpi * 2 * width) / 100000,(height * nelma_dpi * 2) / 100000,iVar2,iVar3,
             0xfffffffd);
  return;
}



// WARNING: Unknown calling convention

void nelma_draw_line(hidGC_conflict3 gc,int x1,int y1,int x2,int y2)

{
  int iVar1;
  
  if ((y1 == y2) && (x1 == x2)) {
    iVar1 = gc->width / 2;
    nelma_fill_rect(gc,x1 - iVar1,y1 - iVar1,x1 + iVar1,y1 + iVar1);
    return;
  }
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  gdImageLine(nelma_im,(x1 * nelma_dpi) / 100000,(y1 * nelma_dpi) / 100000,(x2 * nelma_dpi) / 100000
              ,(y2 * nelma_dpi) / 100000,0xfffffffd);
  return;
}



// WARNING: Unknown calling convention

void nelma_set_color(hidGC_conflict3 gc,char *name)

{
  color_struct *pcVar1;
  color_struct *pcVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  
  pcVar2 = white;
  pcVar1 = black;
  if (nelma_im != (gdImagePtr)0x0) {
    bVar6 = name == (char *)0x0;
    if (!bVar6) {
      iVar3 = 6;
      pcVar4 = name;
      pcVar5 = "drill";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar6 = *pcVar4 == *pcVar5;
        pcVar4 = pcVar4 + 1;
        pcVar5 = pcVar5 + 1;
      } while (bVar6);
      if (!bVar6) {
        iVar3 = 6;
        pcVar4 = "erase";
        do {
          if (iVar3 == 0) break;
          iVar3 = iVar3 + -1;
          bVar6 = *name == *pcVar4;
          name = name + 1;
          pcVar4 = pcVar4 + 1;
        } while (bVar6);
        if (bVar6) {
          gc->erase = 1;
          gc->color = pcVar2;
          return;
        }
      }
    }
    gc->erase = 0;
    gc->color = pcVar1;
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int nelma_set_layer(char *name,int group,int empty)

{
  bool bVar1;
  rtree_t **pprVar2;
  int iVar3;
  uint uVar4;
  byte *pbVar5;
  bool bVar6;
  bool bVar7;
  
  uVar4 = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    uVar4 = (PCB->LayerGroups).Entries[group][0];
  }
  bVar7 = name == (char *)0x0;
  bVar6 = false;
  if (bVar7) {
    bVar6 = CARRY4(uVar4 * 0x5c,(uint)PCB->Data);
    pprVar2 = PCB->Data->name_tree + uVar4 * 0x17 + -0xe;
    bVar7 = pprVar2 == (rtree_t **)0x0;
    name = (char *)pprVar2[0x13];
  }
  iVar3 = 10;
  pbVar5 = (byte *)"invisible";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *(byte *)(rtree_node **)name < *pbVar5;
    bVar7 = *(byte *)(rtree_node **)name == *pbVar5;
    name = (char *)((int)(rtree_node **)name + 1);
    pbVar5 = pbVar5 + 1;
  } while (bVar7);
  bVar1 = false;
  if ((!bVar6 && !bVar7) == bVar6) {
    return 0;
  }
  if ((int)uVar4 < 0) {
    uVar4 = uVar4 & 0xf0;
    if ((uVar4 == 0x40) || (uVar4 == 0x30)) {
      is_drill = 1;
      bVar1 = true;
    }
    else {
      is_drill = 0;
    }
    if (uVar4 == 0x20) {
      is_mask = 1;
      return 0;
    }
    if (bVar1) {
      is_mask = 0;
      return 1;
    }
  }
  else {
    is_drill = 0;
  }
  is_mask = 0;
  return (uint)(group == nelma_cur_group);
}



// WARNING: Unknown calling convention

void register_nelma_attribute_list(void)

{
  hid_register_attributes(nelma_attribute_list,5);
  return;
}



// WARNING: Unknown calling convention

void nelma_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes(nelma_attribute_list,5);
  hid_parse_command_line(argc,argv);
  return;
}



// WARNING: Unknown calling convention

char * nelma_get_png_name(char *basename,char *suffix)

{
  size_t sVar1;
  size_t sVar2;
  char *pcVar3;
  
  sVar1 = strlen(basename);
  sVar2 = strlen(suffix);
  pcVar3 = (char *)calloc(1,sVar1 + 6 + sVar2);
  __sprintf_chk(pcVar3,1,0xffffffff,"%s.%s.png",basename,suffix);
  return pcVar3;
}



// WARNING: Unknown calling convention

HID_Attribute * nelma_get_export_options(int *n)

{
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,nelma_attribute_list,".nelma",
               &nelma_get_export_options::last_made_filename);
  }
  if (n != (int *)0x0) {
    *n = 5;
  }
  return nelma_attribute_list;
}



// WARNING: Unknown calling convention

void hid_nelma_init(void)

{
  apply_default_hid((HID *)&nelma_hid,(HID *)0x0);
  hid_register_hid((HID *)&nelma_hid);
  register_nelma_attribute_list();
  return;
}



// WARNING: Unknown calling convention

void nelma_start_png_export(void)

{
  BoxType region;
  
  region.X1 = 0;
  region.Y1 = 0;
  lastbrush = (gdImagePtr)0xffffffff;
  region.X2 = PCB->MaxWidth;
  region.Y2 = PCB->MaxHeight;
  linewidth = -1;
  lastcap = -1;
  lastcolor = -1;
  lastgroup = -1;
  hid_expose_callback((HID *)&nelma_hid,&region,(void *)0x0);
  return;
}



// WARNING: Unknown calling convention

void nelma_choose_groups(void)

{
  DataTypePtr paVar1;
  int m;
  int iVar2;
  PCBTypePtr pPVar3;
  Cardinal Layer;
  int n;
  int *piVar4;
  
  piVar4 = nelma_export_group;
  for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
    *piVar4 = 0;
    piVar4 = piVar4 + 1;
  }
  paVar1 = PCB->Data;
  if (0 < paVar1->LayerN) {
    Layer = 0;
    pPVar3 = PCB;
    do {
      if ((((paVar1->Layer[Layer].LineN != 0) || (paVar1->Layer[Layer].TextN != 0)) ||
          (paVar1->Layer[Layer].ArcN != 0)) || (paVar1->Layer[Layer].PolygonN != 0)) {
        iVar2 = GetLayerGroupNumberByNumber(Layer);
        pPVar3 = PCB;
        nelma_export_group[iVar2] = 1;
      }
      paVar1 = pPVar3->Data;
      Layer = Layer + 1;
    } while (paVar1->LayerN != Layer && (int)Layer <= paVar1->LayerN);
  }
  return;
}



// WARNING: Unknown calling convention

void nelma_do_export(HID_Attr_Val *options)

{
  char cVar1;
  int iVar2;
  LibraryMenuTypePtr paVar3;
  LibraryEntryTypePtr paVar4;
  double dVar5;
  int idx;
  char *pcVar6;
  color_struct *pcVar7;
  int iVar8;
  FILE *out;
  time_t t;
  LibraryMenuTypePtr paVar9;
  Cardinal CVar10;
  char *f;
  int iVar11;
  HID_Attr_Val *pHVar12;
  uint uVar13;
  char *ext_1;
  Cardinal CVar14;
  int i;
  FILE *nelma_config;
  int idx_1;
  int iVar15;
  char *buf;
  char *ext;
  int idx_2;
  int idx_3;
  int idx_4;
  HID_Attr_Val *pHVar16;
  LibraryEntryTypePtr pin;
  LibraryEntryTypePtr pin_1;
  int z;
  int z_00;
  int z_1;
  uint uVar17;
  int *piVar18;
  int in_GS_OFFSET;
  byte bVar19;
  double zh;
  double xh;
  ulonglong uVar20;
  double dVar21;
  uint local_100;
  uint local_f8;
  uint local_f0;
  int save_ons [18];
  ConnectionType conn;
  time_t local_88;
  char buf_1 [100];
  
  bVar19 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  if (options == (HID_Attr_Val *)0x0) {
    iVar8 = 0;
    nelma_get_export_options((int *)0x0);
    pHVar12 = &nelma_attribute_list[0].default_val;
    do {
      piVar18 = (int *)((int)&nelma_values[0].int_value + iVar8);
      iVar8 = iVar8 + 0x10;
      pHVar16 = pHVar12;
      for (iVar11 = 4; iVar11 != 0; iVar11 = iVar11 + -1) {
        *piVar18 = pHVar16->int_value;
        pHVar16 = (HID_Attr_Val *)((int)pHVar16 + ((uint)bVar19 * -2 + 1) * 4);
        piVar18 = piVar18 + (uint)bVar19 * -2 + 1;
      }
      pHVar12 = pHVar12 + 3;
    } while (iVar8 != 0x50);
    options = nelma_values;
  }
  nelma_basename = "pcb-out";
  if (options->str_value != (char *)0x0) {
    nelma_basename = options->str_value;
  }
  nelma_dpi = options[1].int_value;
  if (nelma_dpi < 0) {
    __fprintf_chk(stderr,1,"ERROR:  dpi may not be < 0\n");
  }
  else {
    nelma_copperh = options[2].int_value;
    CVar14 = 0;
    nelma_substratee = options[4].real_value;
    nelma_substrateh = options[3].int_value;
    nelma_choose_groups();
    do {
      if (nelma_export_group[CVar14] != 0) {
        piVar18 = &PCB->Data->LayerN;
        CVar10 = CVar14;
        if (*piVar18 != CVar14 && (int)CVar14 <= *piVar18) {
          CVar10 = (PCB->LayerGroups).Entries[CVar14][0];
        }
        nelma_cur_group = CVar14;
        pcVar6 = layer_type_to_file_name(CVar10);
        pcVar6 = nelma_get_png_name(nelma_basename,pcVar6);
        nelma_im = (gdImagePtr)gdImageCreate((nelma_dpi * PCB->MaxWidth) / 100000);
        nelma_f = (FILE *)fopen(pcVar6,"wb");
        pcVar7 = (color_struct *)calloc(1,0x10);
        pcVar7->b = 0xff;
        pcVar7->g = 0xff;
        pcVar7->r = 0xff;
        white = pcVar7;
        iVar8 = gdImageColorAllocate(nelma_im,0xff,0xff,0xff);
        pcVar7->c = iVar8;
        pcVar7 = (color_struct *)calloc(1,0x10);
        pcVar7->b = 0;
        pcVar7->g = 0;
        pcVar7->r = 0;
        black = pcVar7;
        iVar8 = gdImageColorAllocate(nelma_im,0,0,0);
        pcVar7->c = iVar8;
        free(pcVar6);
        hid_save_and_show_layer_ons(save_ons);
        nelma_start_png_export();
        hid_restore_layer_ons(save_ons);
        gdImagePng(nelma_im);
        gdImageDestroy(nelma_im);
        fclose((FILE *)nelma_f);
        free(white);
        free(black);
        nelma_im = (gdImagePtr)0x0;
        nelma_f = (FILE *)0x0;
      }
      CVar14 = CVar14 + 1;
    } while (CVar14 != 0x10);
    uVar13 = 0xffffffff;
    pcVar6 = nelma_basename;
    do {
      if (uVar13 == 0) break;
      uVar13 = uVar13 - 1;
      cVar1 = *pcVar6;
      pcVar6 = pcVar6 + (uint)bVar19 * -2 + 1;
    } while (cVar1 != '\0');
    pcVar6 = (char *)calloc(1,~uVar13 + 3);
    __sprintf_chk(pcVar6,1,0xffffffff,"%s.em",nelma_basename);
    out = fopen(pcVar6,"w");
    free(pcVar6);
    __fprintf_chk(out,1,"/* Made with PCB Nelma export HID */");
    local_88 = time((time_t *)0x0);
    pcVar6 = ctime(&local_88);
    uVar20 = ZEXT48(pcVar6);
    __fprintf_chk(out,1,"/* %s */",pcVar6);
    uVar13 = (PCB->NetlistLib).MenuN;
    paVar3 = (PCB->NetlistLib).Menu;
    __fprintf_chk(out,1,"\n/* **** Nets **** */\n\n");
    if (uVar13 != 0) {
      local_100 = 0;
      do {
        paVar9 = paVar3 + local_100;
        uVar20 = ZEXT48(paVar9->Name + 2);
        __fprintf_chk(out,1,"net %s {\n",paVar9->Name + 2);
        __fprintf_chk(out,1,"\tobjects = {\n");
        if (paVar9->EntryN != 0) {
          local_f0 = 0;
          do {
            CVar14 = 0;
            pin = paVar9->Entry + local_f0;
            do {
              if (nelma_export_group[CVar14] != 0) {
                piVar18 = &PCB->Data->LayerN;
                CVar10 = CVar14;
                if (*piVar18 != CVar14 && (int)CVar14 <= *piVar18) {
                  CVar10 = (PCB->LayerGroups).Entries[CVar14][0];
                }
                pcVar6 = layer_type_to_file_name(CVar10);
                if ((CVar14 != 0) || (local_f0 != 0)) {
                  __fprintf_chk(out,1,&DAT_0815d367);
                }
                uVar20 = CONCAT44(pcVar6,pin->ListEntry);
                __fprintf_chk(out,1,"\t\t\"%s-%s\"",pin->ListEntry,pcVar6);
              }
              CVar14 = CVar14 + 1;
            } while (CVar14 != 0x10);
            local_f0 = local_f0 + 1;
          } while (local_f0 <= paVar9->EntryN && paVar9->EntryN != local_f0);
        }
        __fprintf_chk(out,1,"\n");
        __fprintf_chk(out,1,"\t}\n");
        __fprintf_chk(out,1,"}\n");
        local_100 = local_100 + 1;
      } while (local_100 < uVar13);
    }
    uVar13 = (PCB->NetlistLib).MenuN;
    paVar3 = (PCB->NetlistLib).Menu;
    __fprintf_chk(out,1,"\n/* **** Objects **** */\n\n",uVar20);
    if (uVar13 != 0) {
      local_100 = 0;
      do {
        if (paVar3[local_100].EntryN != 0) {
          local_f8 = 0;
          do {
            paVar4 = paVar3[local_100].Entry;
            SeekPad(paVar4 + local_f8,&conn,'\0');
            CVar14 = 0;
            do {
              if (nelma_export_group[CVar14] != 0) {
                CVar10 = CVar14;
                if ((int)CVar14 < PCB->Data->LayerN) {
                  CVar10 = (PCB->LayerGroups).Entries[CVar14][0];
                }
                pcVar6 = layer_type_to_file_name(CVar10);
                __fprintf_chk(out,1,"object %s-%s {\n",paVar4[local_f8].ListEntry,pcVar6);
                __fprintf_chk(out,1,"\tposition = { 0, 0 }\n");
                __fprintf_chk(out,1,"\tmaterial = \"copper\"\n");
                __fprintf_chk(out,1,"\ttype = \"image\"\n");
                __fprintf_chk(out,1,"\trole = \"net\"\n");
                pcVar6 = nelma_get_png_name(nelma_basename,pcVar6);
                __fprintf_chk(out,1,"\tfile = \"%s\"\n",pcVar6);
                free(pcVar6);
                __fprintf_chk(out,1,"\tfile-pos = { %d, %d }\n");
                __fprintf_chk(out,1,"}\n");
              }
              CVar14 = CVar14 + 1;
            } while (CVar14 != 0x10);
            local_f8 = local_f8 + 1;
          } while (local_f8 <= paVar3[local_100].EntryN && paVar3[local_100].EntryN != local_f8);
        }
        local_100 = local_100 + 1;
      } while (local_100 < uVar13);
    }
    iVar11 = nelma_substrateh / nelma_copperh;
    __fprintf_chk(out,1,"\n/* **** Layers **** */\n\n");
    iVar8 = iVar11 * 2;
    nelma_write_layer((FILE *)out,1,iVar8,"air-top",0,"air");
    CVar14 = 0;
    nelma_write_layer((FILE *)out,1000,iVar8,"air-bottom",0,"air");
    iVar8 = 10;
    do {
      iVar15 = iVar8;
      if (nelma_export_group[CVar14] != 0) {
        CVar10 = CVar14;
        if ((int)CVar14 < PCB->Data->LayerN) {
          CVar10 = (PCB->LayerGroups).Entries[CVar14][0];
        }
        iVar15 = 0xb;
        pcVar6 = layer_type_to_file_name(CVar10);
        z_00 = iVar8;
        if (iVar8 != 10) {
          __sprintf_chk(buf_1,1,100,"substrate-%d",iVar8);
          z_00 = iVar8 + 1;
          iVar15 = iVar8 + 2;
          nelma_write_layer((FILE *)out,iVar8,iVar11,buf_1,0,"composite");
        }
        nelma_write_layer((FILE *)out,z_00,1,pcVar6,1,"air");
      }
      CVar14 = CVar14 + 1;
      iVar8 = iVar15;
    } while (CVar14 != 0x10);
    CVar14 = 0;
    __fprintf_chk(out,1,"\n/* **** Materials **** */\n\n");
    nelma_write_material((FILE *)out,"copper","metal",8.85e-12);
    nelma_write_material((FILE *)out,"air","dielectric",8.85e-12);
    nelma_write_material((FILE *)out,"composite","dielectric",nelma_substratee * 8.85e-12);
    dVar21 = 0.0254 / (double)nelma_dpi;
    dVar5 = (double)nelma_copperh;
    __fprintf_chk(out,1,"\n/* **** Space **** */\n\n");
    __fprintf_chk(out,1,"space pcb {\n");
    __fprintf_chk(out,1,"\tstep = { %e, %e, %e }\n",dVar21,dVar21,dVar5 * 1e-06);
    __fprintf_chk(out,1,"\tlayers = {\n");
    __fprintf_chk(out,1,&DAT_0815d35c);
    __fprintf_chk(out,1,"\t\t\"air-bottom\"");
    uVar13 = 10;
    do {
      uVar17 = uVar13;
      if (nelma_export_group[CVar14] != 0) {
        CVar10 = CVar14;
        if ((int)CVar14 < PCB->Data->LayerN) {
          CVar10 = (PCB->LayerGroups).Entries[CVar14][0];
        }
        pcVar6 = layer_type_to_file_name(CVar10);
        if (uVar13 == 10) {
          uVar17 = 0xb;
        }
        else {
          __fprintf_chk(out,1,&DAT_0815d367);
          dVar21 = (double)(ulonglong)uVar13;
          uVar17 = uVar13 + 2;
          __fprintf_chk(out,1,"\t\t\"substrate-%d\"",uVar13);
        }
        __fprintf_chk(out,1,&DAT_0815d367,dVar21);
        dVar21 = (double)ZEXT48(pcVar6);
        __fprintf_chk(out,1,"\t\t\"%s\"");
      }
      CVar14 = CVar14 + 1;
      uVar13 = uVar17;
    } while (CVar14 != 0x10);
    __fprintf_chk(out,1,"\n\t}\n",dVar21);
    __fprintf_chk(out,1,"}\n");
    fclose(out);
  }
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void png_use_mask(int use_it)

{
  return;
}



// WARNING: Unknown calling convention

void png_set_line_cap(hidGC_conflict4 gc,EndCapStyle style)

{
  gc->cap = style;
  return;
}



// WARNING: Unknown calling convention

void png_set_line_width(hidGC_conflict4 gc,int width)

{
  gc->width = width;
  return;
}



// WARNING: Unknown calling convention

void png_set_draw_xor(hidGC_conflict4 gc,int xor)

{
  return;
}



// WARNING: Unknown calling convention

void png_set_draw_faded(hidGC_conflict4 gc,int faded)

{
  gc->faded = faded;
  return;
}



// WARNING: Unknown calling convention

void png_set_crosshair(int x,int y,int a)

{
  return;
}



// WARNING: Unknown calling convention

void png_calibrate(double xval,double yval)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented PNG function %s.\n","png_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void png_set_line_cap_angle(hidGC_conflict4 gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented PNG function %s.\n",
                "png_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void use_gc(hidGC_conflict4 gc)

{
  int iVar1;
  char cVar2;
  color_struct_conflict *pcVar3;
  hidval hVar4;
  uint uVar5;
  gdImagePtr pgVar6;
  int bg;
  int iVar7;
  int fg;
  int iVar8;
  int iVar9;
  int r;
  int in_GS_OFFSET;
  hidval bval;
  char name [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (gc->me_pointer != &png_hid) {
    __fprintf_chk(stderr,1,"Fatal: GC from another HID passed to png HID\n");
                    // WARNING: Subroutine does not return
    abort();
  }
  iVar8 = gc->width;
  if (iVar8 == linewidth) {
    if (gc->brush != lastbrush) goto LAB_08112e9f;
  }
  else {
    if (((int)ROUND((double)iVar8 / scale + 0.5) == 0) && (0 < iVar8)) {
      gdImageSetThickness(im,1);
    }
    else {
      gdImageSetThickness(im,(int)ROUND((bloat + bloat + (double)iVar8) / scale + 0.5));
    }
    linewidth = gc->width;
LAB_08112e9f:
    iVar8 = 0x53;
    cVar2 = 'S';
    if (gc->cap < Beveled_Cap) {
      cVar2 = *(char *)((int)&CSWTCH_196 + gc->cap);
      iVar8 = (int)cVar2;
    }
    iVar9 = 1;
    if ((gc->width != 0) &&
       (iVar9 = (int)ROUND((bloat + bloat + (double)gc->width) / scale + 0.5), iVar9 == 0)) {
      iVar9 = 1;
    }
    pcVar3 = gc->color;
    __sprintf_chk(name,1,0x100,"#%.2x%.2x%.2x_%c_%d",pcVar3->r,pcVar3->g,pcVar3->b,iVar8,iVar9);
    iVar8 = hid_cache_color(0,name,&bval,&brush_cache);
    if (iVar8 == 0) {
      pgVar6 = (gdImagePtr)gdImageCreate(iVar9,iVar9);
      gc->brush = pgVar6;
      if (pgVar6 == (gdImagePtr)0x0) {
        Message("%s():  gdImageCreate(%d, %d) returned NULL.  Aborting export.\n","use_gc",iVar9,
                iVar9);
        goto LAB_08112ff8;
      }
      iVar8 = gdImageColorAllocate(pgVar6,0xff,0xff,0xff);
      if (iVar8 != -1) {
        pcVar3 = gc->color;
        iVar7 = gdImageColorAllocateAlpha(gc->brush,pcVar3->r,pcVar3->g,pcVar3->b,0);
        if (iVar7 != -1) {
          gdImageColorTransparent(gc->brush,iVar8);
          if (iVar9 < 2) {
            iVar9 = 0;
LAB_0811313a:
            gdImageFilledRectangle(gc->brush,0,0,iVar9,iVar9,iVar7);
          }
          else {
            if (cVar2 != 'C') {
              iVar9 = iVar9 + -1;
              goto LAB_0811313a;
            }
            iVar8 = iVar9 >> 1;
            gdImageFilledEllipse(gc->brush,iVar8,iVar8,iVar9,iVar9,iVar7);
            gdImageSetPixel(gc->brush,0,iVar8,iVar7);
            gdImageSetPixel(gc->brush,iVar9 + -1,iVar8,iVar7);
            gdImageSetPixel(gc->brush,iVar8,0,iVar7);
            gdImageSetPixel(gc->brush,iVar8,iVar9 + -1,iVar7);
          }
          bval = (hidval)gc->brush;
          hid_cache_color(1,name,&bval,&brush_cache);
          hVar4 = (hidval)gc->brush;
          goto LAB_08112fa2;
        }
      }
      Message("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n","use_gc");
      goto LAB_08112ff8;
    }
    gc->brush = (gdImagePtr)bval;
    hVar4 = bval;
LAB_08112fa2:
    gdImageSetBrush(im,hVar4.lval);
    lastbrush = gc->brush;
  }
  uVar5 = (uint)gc->r << 0x18 | (uint)gc->g << 0x10 | gc->faded | (uint)gc->b << 8;
  if ((uVar5 != lastcolor) && ((is_drill != 0 || (lastcolor = uVar5, is_mask != 0)))) {
    lastcolor = 0;
  }
LAB_08112ff8:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void png_fill_rect(hidGC_conflict4 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageSetThickness(im,0);
  if (y2 < y1) {
    y2 = y1;
  }
  linewidth = 0;
  if (x2 < x1) {
    x2 = x1;
  }
  gdImageFilledRectangle
            (im,(int)ROUND((((double)x1 - bloat) - (double)x_shift) / scale),
             (int)ROUND((((double)y1 - bloat) - (double)y_shift) / scale),
             (int)ROUND((((double)x2 + bloat) - (double)x_shift) / scale) + -1,
             (int)ROUND((((double)y2 + bloat) - (double)y_shift) / scale) + -1,gc->color->c);
  return;
}



// WARNING: Unknown calling convention

void png_fill_circle(hidGC_conflict4 gc,int cx,int cy,int radius)

{
  int iVar1;
  
  use_gc(gc);
  gdImageSetThickness(im,0);
  linewidth = 0;
  iVar1 = (int)ROUND((bloat + bloat + (double)(radius * 2)) / scale + 0.5);
  gdImageFilledEllipse
            (im,(int)ROUND((double)(cx - x_shift) / scale),
             (int)ROUND((double)(cy - y_shift) / scale),iVar1,iVar1,gc->color->c);
  return;
}



// WARNING: Unknown calling convention

hidGC_conflict4 png_make_gc(void)

{
  hidGC_conflict4 phVar1;
  color_struct_conflict *pcVar2;
  
  phVar1 = (hidGC_conflict4)calloc(1,0x20);
  phVar1->me_pointer = &png_hid;
  phVar1->cap = Trace_Cap;
  phVar1->width = 1;
  pcVar2 = (color_struct_conflict *)calloc(1,0x14);
  pcVar2->a = 0;
  pcVar2->b = 0;
  pcVar2->g = 0;
  pcVar2->r = 0;
  pcVar2->c = 0;
  phVar1->color = pcVar2;
  return phVar1;
}



// WARNING: Unknown calling convention

void png_fill_polygon(hidGC_conflict4 gc,int n_coords,int *x,int *y)

{
  double dVar1;
  int iVar2;
  int iVar3;
  void *__ptr;
  int iVar4;
  int i;
  
  __ptr = calloc(1,n_coords * 8);
  if (__ptr == (void *)0x0) {
    __fprintf_chk(stderr,1,"ERROR:  png_fill_polygon():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  use_gc(gc);
  iVar3 = x_shift;
  iVar2 = y_shift;
  dVar1 = scale;
  if (0 < n_coords) {
    iVar4 = 0;
    do {
      *(int *)((int)__ptr + iVar4 * 8) = (int)ROUND((double)(x[iVar4] - iVar3) / dVar1);
      *(int *)((int)__ptr + iVar4 * 8 + 4) = (int)ROUND((double)(y[iVar4] - iVar2) / dVar1);
      iVar4 = iVar4 + 1;
    } while (iVar4 != n_coords);
  }
  gdImageSetThickness(im,0);
  linewidth = 0;
  gdImageFilledPolygon(im,__ptr,n_coords,gc->color->c);
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention

void png_destroy_gc(hidGC_conflict4 gc)

{
  free(gc);
  return;
}



// WARNING: Unknown calling convention

void png_draw_rect(hidGC_conflict4 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageRectangle(im,(int)ROUND((double)(x1 - x_shift) / scale),
                   (int)ROUND((double)(y1 - y_shift) / scale),
                   (int)ROUND((double)(x2 - x_shift) / scale),
                   (int)ROUND((double)(y2 - y_shift) / scale),gc->color->c);
  return;
}



// WARNING: Unknown calling convention

void png_draw_arc(hidGC_conflict4 gc,int cx,int cy,int width,int height,int start_angle,
                 int delta_angle)

{
  int iVar1;
  int sa;
  int iVar2;
  int iVar3;
  int ea;
  
  iVar1 = 0xb4 - start_angle;
  iVar3 = -delta_angle;
  if (iVar3 == 0 || 0 < delta_angle) {
    iVar2 = iVar3 + iVar1;
  }
  else {
    iVar2 = iVar1;
    iVar1 = iVar3 + iVar1;
  }
  for (; iVar2 < 0; iVar2 = iVar2 + 0x168) {
    iVar1 = iVar1 + 0x168;
  }
  for (; 0x167 < iVar2; iVar2 = iVar2 + -0x168) {
    iVar1 = iVar1 + -0x168;
  }
  use_gc(gc);
  gdImageSetThickness(im,0);
  linewidth = 0;
  gdImageArc(im,(int)ROUND((double)(cx - x_shift) / scale),
             (int)ROUND((double)(cy - y_shift) / scale),
             (int)ROUND((double)(width * 2) / scale + 0.5),
             (int)ROUND((double)(height * 2) / scale + 0.5),iVar2,iVar1,0xfffffffd);
  return;
}



// WARNING: Removing unreachable block (ram,0x08113b58)
// WARNING: Removing unreachable block (ram,0x08113b4f)
// WARNING: Removing unreachable block (ram,0x08113b5a)
// WARNING: Unknown calling convention

void png_draw_line(hidGC_conflict4 gc,int x1,int y1,int x2,int y2)

{
  int iVar1;
  int iVar2;
  color_struct_conflict *pcVar3;
  double dVar4;
  undefined4 uVar5;
  int dy;
  int dwx;
  int iVar6;
  int w;
  int dwy;
  int dx;
  double l;
  gdPoint p [4];
  
  if ((y1 == y2) && (x1 == x2)) {
    iVar6 = gc->width / 2;
    png_fill_rect(gc,x1 - iVar6,y1 - iVar6,x1 + iVar6,y1 + iVar6);
    return;
  }
  use_gc(gc);
  gdImageSetThickness(im,0);
  linewidth = 0;
  if (((x1 != x2) && (gc->cap == Square_Cap)) && (y1 != y2)) {
    pcVar3 = gc->color;
    uVar5 = gdImageColorResolve(im,pcVar3->r,pcVar3->g,pcVar3->b);
    dx = x2 - x1;
    dy = y2 - y1;
    dVar4 = SQRT((double)(dx * dx + dy * dy));
    dVar4 = (dVar4 + dVar4) * scale;
    iVar6 = (int)ROUND(bloat + bloat + (double)gc->width);
    iVar1 = (int)ROUND((double)dy * ((double)-iVar6 / dVar4));
    iVar6 = (int)ROUND((double)dx * ((double)iVar6 / dVar4));
    iVar2 = (int)ROUND((double)(x1 - x_shift) / scale);
    p[0].x = (iVar1 + iVar2) - iVar6;
    p[1].x = (iVar2 - iVar1) - iVar6;
    iVar2 = (int)ROUND((double)(y1 - y_shift) / scale);
    p[0].y = iVar6 + iVar1 + iVar2;
    p[1].y = (iVar1 + iVar2) - iVar6;
    iVar2 = (int)ROUND((double)(x2 - x_shift) / scale);
    p[3].x = iVar6 + iVar1 + iVar2;
    p[2].x = (iVar6 + iVar2) - iVar1;
    iVar2 = (int)ROUND((double)(y2 - y_shift) / scale);
    p[2].y = (iVar2 - iVar6) - iVar1;
    p[3].y = (iVar6 + iVar2) - iVar1;
    gdImageFilledPolygon(im,p,4,uVar5);
    return;
  }
  gdImageLine(im,(int)ROUND((double)(x1 - x_shift) / scale),
              (int)ROUND((double)(y1 - y_shift) / scale),(int)ROUND((double)(x2 - x_shift) / scale),
              (int)ROUND((double)(y2 - y_shift) / scale),0xfffffffd);
  return;
}



// WARNING: Unknown calling convention

void png_set_color(hidGC_conflict4 gc,char *name)

{
  color_struct_conflict *pcVar1;
  int iVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  hidval cval;
  
  iVar3 = in_mono;
  pcVar1 = white;
  if (im == (gdImagePtr)0x0) {
    return;
  }
  bVar6 = name == (char *)0x0;
  if (bVar6) {
    name = "#ff0000";
LAB_08113be5:
    gc->erase = 0;
    bVar6 = iVar3 == 0;
    if (bVar6) {
      iVar3 = 8;
      pcVar4 = name;
      pcVar5 = "#000000";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar6 = *pcVar4 == *pcVar5;
        pcVar4 = pcVar4 + 1;
        pcVar5 = pcVar5 + 1;
      } while (bVar6);
      if (!bVar6) {
        iVar3 = hid_cache_color(0,name,&cval,&color_cache);
        if (iVar3 != 0) {
          gc->color = (color_struct_conflict *)cval;
          return;
        }
        if (*name != '#') {
          __printf_chk(1,"WE SHOULD NOT BE HERE!!!\n");
          gc->color = black;
          return;
        }
        pcVar1 = (color_struct_conflict *)calloc(1,0x14);
        gc->color = pcVar1;
        sscanf(name + 1,"%2x%2x%2x",&pcVar1->r,&pcVar1->g,&pcVar1->b);
        pcVar1 = gc->color;
        iVar3 = gdImageColorAllocate(im,pcVar1->r,pcVar1->g,pcVar1->b);
        pcVar1->c = iVar3;
        cval = (hidval)gc->color;
                    // WARNING: Load size is inaccurate
        if (*cval.ptr != -1) {
          hid_cache_color(1,name,&cval,&color_cache);
          return;
        }
        Message("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n","png_set_color");
        return;
      }
    }
    gc->color = black;
  }
  else {
    iVar2 = 6;
    pcVar4 = name;
    pcVar5 = "erase";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar6 = *pcVar4 == *pcVar5;
      pcVar4 = pcVar4 + 1;
      pcVar5 = pcVar5 + 1;
    } while (bVar6);
    if (!bVar6) {
      iVar2 = 6;
      pcVar4 = name;
      pcVar5 = "drill";
      do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        bVar6 = *pcVar4 == *pcVar5;
        pcVar4 = pcVar4 + 1;
        pcVar5 = pcVar5 + 1;
      } while (bVar6);
      if (!bVar6) goto LAB_08113be5;
    }
    gc->erase = 1;
    gc->color = pcVar1;
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int png_set_layer(char *name,int group,int empty)

{
  uint uVar1;
  gdImagePtr *ppgVar2;
  gdImagePtr pgVar3;
  color_struct_conflict *pcVar4;
  int iVar5;
  uint uVar6;
  int idx;
  char *pcVar7;
  char *pcVar8;
  bool bVar9;
  
  uVar1 = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    uVar1 = (PCB->LayerGroups).Entries[group][0];
  }
  if (name == (char *)0x0) {
    name = PCB->Data->Layer[uVar1].Name;
  }
  if ((int)uVar1 < 0) {
    if ((uVar1 & 0xf0) == 0x70) {
      return 0;
    }
    bVar9 = (uVar1 & 0xf0) == 0x80;
    if (bVar9) {
      return 0;
    }
  }
  else {
    uVar6 = PCB->Data->LayerN;
    bVar9 = uVar1 == uVar6;
    if (((int)uVar1 < (int)uVar6) && (bVar9 = print_layer[uVar1] == 0, bVar9)) {
      return 0;
    }
  }
  iVar5 = 10;
  pcVar7 = name;
  pcVar8 = "invisible";
  do {
    if (iVar5 == 0) break;
    iVar5 = iVar5 + -1;
    bVar9 = *pcVar7 == *pcVar8;
    pcVar7 = pcVar7 + 1;
    pcVar8 = pcVar8 + 1;
  } while (bVar9);
  if (bVar9) {
    return 0;
  }
  if ((int)uVar1 < 0) {
    uVar6 = uVar1 & 0xf0;
    if ((uVar6 == 0x40) || (uVar6 == 0x30)) {
      is_drill = 1;
    }
    else {
      is_drill = 0;
    }
    if (uVar6 == 0x20) {
      is_mask = 1;
      bVar9 = true;
    }
    else {
      is_mask = 0;
      if (uVar6 == 0x50) {
        is_mask = 0;
        return 0;
      }
      bVar9 = false;
    }
  }
  else {
    is_drill = 0;
    bVar9 = false;
    is_mask = 0;
  }
  if (photo_mode == 0) {
    if (as_shown == 0) {
      if (bVar9) {
        return 0;
      }
      if (1 < uVar1 + 0xfef) {
        return 1;
      }
      return *(int *)((int)&CSWTCH_199 + (uVar1 + 0xfef) * 4);
    }
    if ((int)uVar1 < -0xfef) {
      return 1;
    }
    if (-0xfee < (int)uVar1) {
      if (1 < uVar1 + 0xfdf) {
        return 1;
      }
      if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x20) == 0) {
        return 0;
      }
      return (uVar1 >> 1 ^ 1) & 1 ^ (uint)(Settings.ShowSolderSide != '\0');
    }
    if ((bool)(((byte)(uVar1 >> 1) ^ 1) & 1) == (Settings.ShowSolderSide != '\0')) {
      return 0;
    }
    return (int)PCB->ElementOn;
  }
  switch(uVar1) {
  case 0xfffff011:
    break;
  case 0xfffff012:
    break;
  default:
    if ((int)uVar1 < 0) {
      return 0;
    }
    iVar5 = strcasecmp(name,"outline");
    if (iVar5 == 0) {
      photo_im = &photo_outline;
    }
    else {
      photo_im = photo_copper + group;
    }
    goto LAB_08113e18;
  case 0xfffff021:
    goto joined_r0x08114028;
  case 0xfffff022:
joined_r0x08114028:
    if (photo_flip == 0) {
      return 0;
    }
    photo_im = &photo_mask;
    goto LAB_08113e18;
  case 0xfffff030:
  case 0xfffff040:
    photo_im = &photo_drill;
    goto LAB_08113e18;
  }
  if (photo_flip == 0) {
    return 0;
  }
  photo_im = &photo_silk;
LAB_08113e18:
  ppgVar2 = photo_im;
  pgVar3 = *photo_im;
  if (pgVar3 == (gdImagePtr)0x0) {
    pgVar3 = (gdImagePtr)gdImageCreate(im->sx,im->sy);
    bVar9 = photo_im == (gdImagePtr *)0x0;
    *ppgVar2 = pgVar3;
    if (bVar9) {
      Message("%s():  gdImageCreate(%d, %d) returned NULL.  Aborting export.\n","png_set_layer",
              im->sx,im->sy);
      return 0;
    }
    pcVar4 = (color_struct_conflict *)calloc(1,0x14);
    pcVar4->b = 0xff;
    pcVar4->g = 0xff;
    pcVar4->r = 0xff;
    pcVar4->a = 0;
    png_set_layer::lexical_block_1::white = pcVar4;
    iVar5 = gdImageColorAllocate(*photo_im,0xff,0xff,0xff);
    pcVar4->c = iVar5;
    if (png_set_layer::lexical_block_1::white->c == -1) {
      Message("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n","png_set_layer");
      return 0;
    }
    pcVar4 = (color_struct_conflict *)calloc(1,0x14);
    pcVar4->a = 0;
    pcVar4->b = 0;
    pcVar4->g = 0;
    pcVar4->r = 0;
    png_set_layer::lexical_block_1::black = pcVar4;
    iVar5 = gdImageColorAllocate(*photo_im,0,0,0);
    pcVar4->c = iVar5;
    if (png_set_layer::lexical_block_1::black->c == -1) {
      Message("%s(): gdImageColorAllocate() returned NULL.  Aborting export.\n","png_set_layer");
      return 0;
    }
    if ((uVar1 == 0xfffff040) || (uVar1 == 0xfffff030)) {
      gdImageFilledRectangle(*photo_im,0,0,im->sx,im->sy,png_set_layer::lexical_block_1::black->c);
    }
    pgVar3 = *photo_im;
  }
  im = pgVar3;
  return 1;
}



// WARNING: Unknown calling convention

void register_png_attribute_list(void)

{
  hid_register_attributes(png_attribute_list,0x11);
  return;
}



// WARNING: Unknown calling convention

void png_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes(png_attribute_list,0x11);
  hid_parse_command_line(argc,argv);
  return;
}



// WARNING: Unknown calling convention

void ts_bs(gdImagePtr im)

{
  int iVar1;
  int sy;
  int iVar2;
  int iVar3;
  int y;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  int local_30;
  int local_24;
  
  local_30 = 0;
  if (0 < im->sx) {
    do {
      iVar4 = 0;
      if (0 < im->sy) {
        do {
          iVar5 = -0x28;
          local_24 = 0;
          iVar3 = local_30 + -2;
          do {
            iVar2 = -2;
            do {
              iVar1 = gdImageGetPixel(im,iVar3,iVar2 + iVar4);
              if (iVar1 == 0) {
                local_24 = local_24 + *(int *)(iVar5 + 0x815db30 + iVar2 * 4);
              }
              iVar2 = iVar2 + 1;
            } while (iVar2 != 3);
            iVar3 = iVar3 + 1;
            iVar5 = iVar5 + 0x14;
          } while (iVar5 != 0x3c);
          iVar3 = gdImageGetPixel(im,local_30,iVar4);
          if (iVar3 != 0) {
            if (local_24 < 2) {
              if (-2 < local_24) goto LAB_08114342;
              uVar6 = 3;
            }
            else {
              uVar6 = 2;
            }
            gdImageSetPixel(im,local_30,iVar4,uVar6);
          }
LAB_08114342:
          iVar4 = iVar4 + 1;
        } while (im->sy != iVar4 && iVar4 <= im->sy);
      }
      local_30 = local_30 + 1;
    } while (im->sx != local_30 && local_30 <= im->sx);
  }
  return;
}



// WARNING: Unknown calling convention

HID_Attribute * png_get_export_options(int *n)

{
  byte bVar1;
  byte *pbVar2;
  char *fmt;
  int iVar3;
  byte *pbVar4;
  byte *pbVar5;
  bool bVar6;
  bool bVar7;
  char *local_20;
  
  pbVar2 = (byte *)filetypes[png_attribute_list[9].default_val.int_value];
  bVar1 = *pbVar2;
  bVar6 = bVar1 < 0x47;
  bVar7 = bVar1 == 0x47;
  if (bVar7) {
    bVar6 = pbVar2[1] < 0x49;
    bVar7 = pbVar2[1] == 0x49;
    if (bVar7) {
      bVar6 = pbVar2[2] < 0x46;
      bVar7 = pbVar2[2] == 0x46;
      if (bVar7) {
        bVar6 = false;
        bVar7 = pbVar2[3] == 0;
        if (bVar7) {
          local_20 = ".gif";
          goto LAB_081143f4;
        }
      }
    }
  }
  iVar3 = 5;
  pbVar4 = pbVar2;
  pbVar5 = &DAT_0815d8c2;
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *pbVar4 < *pbVar5;
    bVar7 = *pbVar4 == *pbVar5;
    pbVar4 = pbVar4 + 1;
    pbVar5 = pbVar5 + 1;
  } while (bVar7);
  local_20 = ".jpg";
  if ((!bVar6 && !bVar7) != bVar6) {
    if ((((bVar1 == 0x50) && (pbVar2[1] == 0x4e)) && (pbVar2[2] == 0x47)) && (pbVar2[3] == 0)) {
      local_20 = ".png";
    }
    else {
      __fprintf_chk(stderr,1,"Error:  Invalid graphic file format\n");
      local_20 = ".???";
    }
  }
LAB_081143f4:
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,png_attribute_list,local_20,&png_get_export_options::last_made_filename
              );
  }
  if (n != (int *)0x0) {
    *n = 0x11;
  }
  return png_attribute_list;
}



// WARNING: Unknown calling convention

void hid_png_init(void)

{
  apply_default_hid((HID *)&png_hid,(HID *)0x0);
  hid_register_hid((HID *)&png_hid);
  register_png_attribute_list();
  return;
}



// WARNING: Unknown calling convention

int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int bl;
  int d;
  int iVar1;
  int bside;
  int iVar2;
  int aside;
  int a;
  int b;
  int al;
  
                    // WARNING: Load size is inaccurate
  Layer = *va;
                    // WARNING: Load size is inaccurate
  Layer_00 = *vb;
  iVar1 = PCB->Data->LayerN;
  iVar2 = iVar1 + 1;
  if (((int)Layer < 0) || (iVar2 < (int)Layer)) {
    al = iVar1 + 3 + Layer;
  }
  else {
    al = GetLayerGroupNumberByNumber(Layer);
    iVar1 = PCB->Data->LayerN;
    iVar2 = iVar1 + 1;
  }
  if ((iVar2 < (int)Layer_00) || ((int)Layer_00 < 0)) {
    bl = iVar1 + 3 + Layer_00;
  }
  else {
    bl = GetLayerGroupNumberByNumber(Layer_00);
  }
  if ((-1 < (int)Layer) && ((int)Layer <= PCB->Data->LayerN + 1)) {
    iVar2 = 0;
    if (solder_layer != al) {
      iVar2 = (comp_layer == al) + 1;
    }
    iVar1 = 0;
    if (solder_layer != bl) {
      iVar1 = (comp_layer == bl) + 1;
    }
    if (iVar2 != iVar1) {
      d = iVar1 - iVar2;
      return d;
    }
  }
  iVar2 = bl - al;
  if (bl - al == 0) {
    iVar2 = Layer_00 - Layer;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void png_hid_export_to_file(FILE *the_file,HID_Attr_Val *options)

{
  DataTypePtr paVar1;
  int i_1;
  int iVar2;
  int iVar3;
  int iVar4;
  int tmp;
  PCBTypePtr pPVar5;
  int *piVar6;
  Cardinal Layer;
  int i;
  Cardinal CVar7;
  int iVar8;
  int n;
  bool bVar9;
  byte bVar10;
  uchar local_38;
  uchar local_37;
  uchar local_36;
  uchar local_35;
  uchar local_34;
  uchar local_33;
  uchar local_32;
  uchar local_31;
  uint local_30;
  BoxType region;
  
  bVar10 = 0;
  region.X1 = 0;
  region.Y1 = 0;
  f = the_file;
  region.X2 = PCB->MaxWidth;
  region.Y2 = PCB->MaxHeight;
  if (options[7].int_value == 0) {
    bounds = &region;
  }
  else {
    bounds = GetDataBoundingBox(PCB->Data);
  }
  pPVar5 = PCB;
  piVar6 = print_group;
  for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {
    *piVar6 = 0;
    piVar6 = piVar6 + (uint)bVar10 * -2 + 1;
  }
  piVar6 = print_layer;
  for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {
    *piVar6 = 0;
    piVar6 = piVar6 + (uint)bVar10 * -2 + 1;
  }
  paVar1 = pPVar5->Data;
  CVar7 = paVar1->LayerN;
  if (0 < (int)CVar7) {
    Layer = 0;
    do {
      if ((((paVar1->Layer[Layer].LineN != 0) || (paVar1->Layer[Layer].TextN != 0)) ||
          (paVar1->Layer[Layer].ArcN != 0)) || (paVar1->Layer[Layer].PolygonN != 0)) {
        iVar4 = GetLayerGroupNumberByNumber(Layer);
        pPVar5 = PCB;
        print_group[iVar4] = 1;
      }
      paVar1 = pPVar5->Data;
      Layer = Layer + 1;
      CVar7 = paVar1->LayerN;
    } while ((int)Layer < (int)CVar7);
  }
  iVar4 = GetLayerGroupNumberByNumber(CVar7);
  print_group[iVar4] = 1;
  iVar4 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  pPVar5 = PCB;
  print_group[iVar4] = 1;
  if (0 < pPVar5->Data->LayerN) {
    CVar7 = 0;
    do {
      iVar4 = GetLayerGroupNumberByNumber(CVar7);
      if (print_group[iVar4] != 0) {
        print_layer[CVar7] = 1;
      }
      CVar7 = CVar7 + 1;
      piVar6 = &PCB->Data->LayerN;
      pPVar5 = PCB;
    } while (*piVar6 != CVar7 && (int)CVar7 <= *piVar6);
  }
  png_hid_export_to_file::saved_layer_stack[0] = LayerStack[0];
  png_hid_export_to_file::saved_layer_stack[1] = LayerStack[1];
  png_hid_export_to_file::saved_layer_stack[2] = LayerStack[2];
  png_hid_export_to_file::saved_layer_stack[3] = LayerStack[3];
  png_hid_export_to_file::saved_layer_stack[4] = LayerStack[4];
  png_hid_export_to_file::saved_layer_stack[5] = LayerStack[5];
  png_hid_export_to_file::saved_layer_stack[6] = LayerStack[6];
  png_hid_export_to_file::saved_layer_stack[7] = LayerStack[7];
  png_hid_export_to_file::saved_layer_stack[8] = LayerStack[8];
  png_hid_export_to_file::saved_layer_stack[9] = LayerStack[9];
  png_hid_export_to_file::saved_layer_stack[10] = LayerStack[10];
  png_hid_export_to_file::saved_layer_stack[11] = LayerStack[11];
  png_hid_export_to_file::saved_layer_stack[12] = LayerStack[12];
  png_hid_export_to_file::saved_layer_stack[13] = LayerStack[13];
  png_hid_export_to_file::saved_layer_stack[14] = LayerStack[14];
  png_hid_export_to_file::saved_layer_stack[15] = LayerStack[15];
  as_shown = options[5].int_value;
  if (as_shown == 0) {
    comp_layer = GetLayerGroupNumberByNumber(pPVar5->Data->LayerN + 1);
    solder_layer = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    qsort(LayerStack,PCB->Data->LayerN,4,layer_sort);
    local_31 = (PCB->Flags).t[7];
    local_32 = (PCB->Flags).t[6];
    local_33 = (PCB->Flags).t[5];
    local_34 = (PCB->Flags).t[4];
    local_35 = (PCB->Flags).t[3];
    local_36 = (PCB->Flags).t[2];
    local_37 = (PCB->Flags).t[1];
    local_38 = (PCB->Flags).t[0];
    local_30 = (PCB->Flags).f;
    bVar9 = photo_mode != 0;
    (PCB->Flags).f = local_30 & 0xfffdbfff;
    iVar3 = solder_layer;
    iVar4 = comp_layer;
    if (bVar9) {
      iVar8 = 0;
      iVar2 = comp_layer;
      if (comp_layer < solder_layer) {
        do {
          photo_groups[iVar2 - iVar4] = iVar2;
          iVar2 = iVar2 + 1;
        } while (iVar2 <= iVar3);
        photo_ngroups = iVar3 + 2 + ~iVar4;
      }
      else {
        do {
          photo_groups[iVar8] = iVar2;
          iVar2 = iVar2 + -1;
          iVar8 = iVar8 + 1;
        } while (iVar3 <= iVar2);
        photo_ngroups = (iVar4 - iVar3) + 1;
      }
      if ((photo_flip != 0) && (iVar4 = photo_ngroups + -1, 0 < iVar4)) {
        piVar6 = photo_groups + iVar4;
        iVar3 = 0;
        do {
          iVar2 = photo_groups[iVar3];
          photo_groups[iVar3] = *piVar6;
          iVar3 = iVar3 + 1;
          *piVar6 = iVar2;
          piVar6 = piVar6 + -1;
        } while (iVar3 < iVar4 - iVar3);
      }
    }
  }
  in_mono = options[6].int_value;
  linewidth = -1;
  lastbrush = (gdImagePtr)0xffffffff;
  lastcap = -1;
  lastcolor = -1;
  lastgroup = -1;
  hid_expose_callback((HID *)&png_hid,bounds,(void *)0x0);
  pPVar5 = PCB;
  LayerStack[0] = png_hid_export_to_file::saved_layer_stack[0];
  LayerStack[1] = png_hid_export_to_file::saved_layer_stack[1];
  LayerStack[2] = png_hid_export_to_file::saved_layer_stack[2];
  LayerStack[3] = png_hid_export_to_file::saved_layer_stack[3];
  LayerStack[4] = png_hid_export_to_file::saved_layer_stack[4];
  LayerStack[5] = png_hid_export_to_file::saved_layer_stack[5];
  LayerStack[6] = png_hid_export_to_file::saved_layer_stack[6];
  LayerStack[7] = png_hid_export_to_file::saved_layer_stack[7];
  LayerStack[8] = png_hid_export_to_file::saved_layer_stack[8];
  LayerStack[9] = png_hid_export_to_file::saved_layer_stack[9];
  LayerStack[10] = png_hid_export_to_file::saved_layer_stack[10];
  LayerStack[11] = png_hid_export_to_file::saved_layer_stack[11];
  LayerStack[12] = png_hid_export_to_file::saved_layer_stack[12];
  LayerStack[13] = png_hid_export_to_file::saved_layer_stack[13];
  LayerStack[14] = png_hid_export_to_file::saved_layer_stack[14];
  LayerStack[15] = png_hid_export_to_file::saved_layer_stack[15];
  if (options[5].int_value == 0) {
    (PCB->Flags).t[7] = local_31;
    (pPVar5->Flags).t[6] = local_32;
    (pPVar5->Flags).t[5] = local_33;
    (pPVar5->Flags).t[4] = local_34;
    (pPVar5->Flags).t[3] = local_35;
    (pPVar5->Flags).t[2] = local_36;
    (pPVar5->Flags).t[1] = local_37;
    (pPVar5->Flags).t[0] = local_38;
    (pPVar5->Flags).f = local_30;
  }
  return;
}



// WARNING: Unknown calling convention

void png_do_export(HID_Attr_Val *options)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  float fVar4;
  double *pdVar5;
  BoxType *bbox;
  int dpi;
  int iVar6;
  int iVar7;
  BoxTypePtr pBVar8;
  int iVar9;
  color_struct_conflict *pcVar10;
  uint uVar11;
  char *fmt;
  int iVar12;
  undefined4 uVar13;
  long lVar14;
  int xmax;
  int cc;
  gdImagePtr pgVar15;
  HID_Attr_Val *pHVar16;
  int ymax;
  int h;
  int black;
  int iVar17;
  int x;
  char *pcVar18;
  uint uVar19;
  uint uVar20;
  int w;
  gdImagePtr *ppgVar21;
  char *pcVar22;
  int *piVar23;
  uint uVar24;
  int in_GS_OFFSET;
  bool bVar25;
  byte bVar26;
  HID_Attr_Val *local_b8;
  int local_b0;
  ulonglong local_ac;
  int local_a4;
  int local_a0;
  uint local_9c;
  uint local_90;
  ulonglong local_84;
  int save_ons [18];
  double local_34;
  char suf [10];
  
  bVar26 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_b8 = options;
  if (color_cache != (void *)0x0) {
    free(color_cache);
    color_cache = (void *)0x0;
  }
  if (brush_cache != (void *)0x0) {
    free(brush_cache);
    brush_cache = (void *)0x0;
  }
  if (options == (HID_Attr_Val *)0x0) {
    png_get_export_options((int *)0x0);
    pHVar16 = &png_attribute_list[0].default_val;
    iVar9 = 0;
    do {
      *(int *)((int)&png_values[0].int_value + iVar9) = pHVar16->int_value;
      *(char **)((int)&png_values[0].str_value + iVar9) = pHVar16->str_value;
      *(undefined4 *)((int)&png_values[0].real_value + iVar9) = *(undefined4 *)&pHVar16->real_value;
      pdVar5 = &pHVar16->real_value;
      pHVar16 = pHVar16 + 3;
      *(undefined4 *)((int)&png_values[0].real_value + iVar9 + 4) = *(undefined4 *)((int)pdVar5 + 4)
      ;
      iVar9 = iVar9 + 0x10;
    } while (iVar9 != 0x110);
    local_b8 = png_values;
  }
  if (local_b8[0xb].int_value == 0) {
    photo_mode = 0;
  }
  else {
    photo_mode = 1;
    local_b8[6].int_value = 1;
    local_b8[5].int_value = 0;
    ppgVar21 = photo_copper;
    for (iVar9 = 0x12; iVar9 != 0; iVar9 = iVar9 + -1) {
      *ppgVar21 = (gdImagePtr)0x0;
      ppgVar21 = ppgVar21 + (uint)bVar26 * -2 + 1;
    }
    photo_drill = (gdImagePtr)0x0;
    photo_mask = (gdImagePtr)0x0;
    photo_silk = (gdImagePtr)0x0;
    photo_outline = (gdImagePtr)0x0;
    if (local_b8[0xc].int_value == 0) {
      photo_flip = ~-(uint)(local_b8[0xd].int_value == 0) & 2;
    }
    else {
      photo_flip = 1;
    }
  }
  filename = "pcb-out.png";
  if (local_b8->str_value != (char *)0x0) {
    filename = local_b8->str_value;
  }
  if (local_b8[7].int_value == 0) {
    x_shift = 0;
    y_shift = 0;
    iVar9 = PCB->MaxHeight;
    iVar12 = PCB->MaxWidth;
  }
  else {
    pBVar8 = GetDataBoundingBox(PCB->Data);
    y_shift = pBVar8->Y1;
    x_shift = pBVar8->X1;
    iVar9 = pBVar8->Y2 - y_shift;
    iVar12 = pBVar8->X2 - x_shift;
  }
  iVar6 = local_b8[1].int_value;
  if ((iVar6 != 0) && (iVar6 < 0)) {
    __fprintf_chk(stderr,1,"ERROR:  dpi may not be < 0\n");
    goto LAB_081150a5;
  }
  iVar17 = local_b8[2].int_value;
  if (iVar17 < 1) {
    iVar17 = 0;
  }
  else {
    iVar6 = 0;
  }
  iVar7 = local_b8[3].int_value;
  if (iVar7 < 1) {
    iVar7 = 0;
  }
  else {
    iVar6 = 0;
  }
  iVar2 = local_b8[4].int_value;
  if (iVar2 < 1) {
    if (iVar6 == 0) goto LAB_08114c04;
    fVar4 = 100000.0 / (float)iVar6;
    scale = (double)fVar4;
    iVar17 = (int)ROUND((float)iVar12 / fVar4);
    iVar7 = (int)ROUND((float)iVar9 / fVar4);
  }
  else {
    if ((iVar17 == 0) || (iVar2 < iVar17)) {
      iVar17 = iVar2;
    }
    if ((iVar7 == 0) || (iVar2 < iVar7)) {
      iVar7 = iVar2;
    }
LAB_08114c04:
    if (iVar7 == 0) {
      if (iVar17 == 0) {
        __fprintf_chk(stderr,1,"ERROR:  You may not set both xmax, ymax,and xy-max to zero\n");
        goto LAB_081150a5;
      }
    }
    else if ((iVar17 == 0) || (iVar12 / iVar17 <= iVar9 / iVar7)) {
      iVar17 = (iVar7 * iVar12) / iVar9;
      scale = (double)(iVar9 / iVar7);
      goto LAB_08114d98;
    }
    iVar7 = (iVar9 * iVar17) / iVar12;
    scale = (double)(iVar12 / iVar17);
  }
LAB_08114d98:
  im = (gdImagePtr)gdImageCreate(iVar17,iVar7);
  if (im == (gdImagePtr)0x0) {
    Message("%s():  gdImageCreate(%d, %d) returned NULL.  Aborting export.\n","png_do_export",iVar17
            ,iVar7);
  }
  else {
    bloat = 0.0;
    master_im = im;
    if (local_b8[10].str_value != (char *)0x0) {
      suf[0] = '\0';
      sscanf(local_b8[10].str_value,"%lf %s",&local_34,suf);
      iVar9 = strcasecmp(suf,"in");
      if (iVar9 == 0) {
        bloat = local_34 * 100000.0;
      }
      else {
        iVar9 = strcasecmp(suf,"mil");
        if (iVar9 == 0) {
          bloat = local_34 * 100.0;
        }
        else {
          iVar9 = strcasecmp(suf,"mm");
          if (iVar9 == 0) {
            bloat = local_34 * 3937.007874;
          }
          else {
            iVar9 = strcasecmp(suf,"um");
            if (iVar9 == 0) {
              bloat = local_34 * 3937.007874 * 1000.0;
            }
            else {
              iVar9 = strcasecmp(suf,"pix");
              if ((iVar9 == 0) || (iVar9 = strcasecmp(suf,"px"), iVar9 == 0)) {
                bloat = local_34 * scale;
              }
              else {
                bloat = local_34;
              }
            }
          }
        }
      }
    }
    pcVar10 = (color_struct_conflict *)calloc(1,0x14);
    pcVar10->b = 0xff;
    pcVar10->g = 0xff;
    pcVar10->r = 0xff;
    uVar11 = ~-(uint)(local_b8[8].int_value == 0) & 0x7f;
    white = pcVar10;
    pcVar10->a = uVar11;
    iVar9 = gdImageColorAllocateAlpha(im,0xff,0xff,0xff,uVar11);
    pcVar10->c = iVar9;
    if (white->c == -1) {
      Message("%s():  gdImageColorAllocateAlpha() returned NULL.  Aborting export.\n",
              "png_do_export",iVar17,iVar7);
    }
    else {
      pcVar10 = (color_struct_conflict *)calloc(1,0x14);
      pcVar10->a = 0;
      pcVar10->b = 0;
      pcVar10->g = 0;
      pcVar10->r = 0;
      ::black = pcVar10;
      iVar9 = gdImageColorAllocate(im,0,0,0);
      pcVar10->c = iVar9;
      if (::black->c == -1) {
        Message("%s():  gdImageColorAllocateAlpha() returned NULL.  Aborting export.\n",
                "png_do_export");
      }
      else {
        f = (FILE *)fopen(filename,"wb");
        if (f == (FILE *)0x0) {
          perror(filename);
        }
        else {
          if (local_b8[5].int_value == 0) {
            hid_save_and_show_layer_ons(save_ons);
          }
          png_hid_export_to_file(f,local_b8);
          if (local_b8[5].int_value == 0) {
            hid_restore_layer_ons(save_ons);
          }
          if (photo_mode != 0) {
            im = master_im;
            ts_bs(photo_copper[photo_groups[0]]);
            ts_bs(photo_silk);
            pgVar15 = photo_mask;
            local_b0 = 0;
            if (0 < photo_mask->sx) {
              do {
                iVar9 = 0;
                if (0 < pgVar15->sy) {
                  do {
                    local_90 = -1;
                    local_a4 = 0;
                    do {
                      iVar17 = 0;
                      iVar12 = local_90 + 1;
                      piVar23 = (int *)smshadows[iVar12];
                      iVar6 = iVar9 + -1;
                      do {
                        iVar7 = gdImageGetPixel(pgVar15,local_90 + local_b0,iVar6);
                        if (iVar7 == 0) {
                          local_a4 = local_a4 + *piVar23;
                        }
                        iVar17 = iVar17 + 1;
                        iVar6 = iVar6 + 1;
                        piVar23 = piVar23 + 1;
                      } while (iVar17 != 3);
                      local_90 = iVar12;
                    } while (iVar12 != 2);
                    iVar12 = gdImageGetPixel(pgVar15,local_b0,iVar9);
                    if (iVar12 != 0) {
                      if (local_a4 < 2) {
                        if (local_a4 < -1) {
                          gdImageSetPixel(pgVar15,local_b0,iVar9,3);
                        }
                      }
                      else {
                        gdImageSetPixel(pgVar15,local_b0,iVar9,2);
                      }
                    }
                    iVar9 = iVar9 + 1;
                  } while (iVar9 < pgVar15->sy);
                }
                local_b0 = local_b0 + 1;
              } while (local_b0 < pgVar15->sx);
            }
            if (photo_outline != (gdImagePtr)0x0) {
              uVar13 = gdImageColorResolve(photo_outline,0,0,0);
              if (0 < im->sx) {
                iVar9 = 0;
                do {
                  gdImageFillToBorder(photo_outline,iVar9,0,uVar13,uVar13);
                  iVar12 = iVar9 + 1;
                  gdImageFillToBorder(photo_outline,iVar9,im->sy + -1,uVar13,uVar13);
                  iVar9 = iVar12;
                } while (im->sx != iVar12 && iVar12 <= im->sx);
              }
              if (2 < im->sy) {
                iVar9 = 1;
                do {
                  gdImageFillToBorder(photo_outline,0,iVar9,uVar13,uVar13);
                  iVar12 = iVar9 + 1;
                  gdImageFillToBorder(photo_outline,im->sx + -1,iVar9,uVar13,uVar13);
                  iVar9 = iVar12;
                } while (iVar12 < im->sy + -1);
              }
            }
            local_90 = 0;
            pgVar15 = im;
            if (0 < im->sx) {
              do {
                uVar11 = 0;
                if (0 < pgVar15->sy) {
LAB_0811555c:
                  do {
                    local_a0 = 0;
                    if (photo_outline != (gdImagePtr)0x0) {
                      local_a0 = gdImageGetPixel(photo_outline,local_90,uVar11);
                    }
                    local_a4 = 0;
                    if (photo_mask != (gdImagePtr)0x0) {
                      local_a4 = gdImageGetPixel(photo_mask,local_90,uVar11);
                    }
                    iVar9 = 0;
                    if (photo_silk != (gdImagePtr)0x0) {
                      iVar9 = gdImageGetPixel(photo_silk,local_90,uVar11);
                    }
                    iVar12 = gdImageGetPixel(photo_copper[photo_groups[1]],local_90,uVar11);
                    uVar24 = (-(uint)(iVar12 == 0) & 0x3c) + 0x28;
                    uVar19 = (-(uint)(iVar12 == 0) & 0x46) + 0x28;
                    local_84._0_4_ = uVar19;
                    if (photo_ngroups == 2) {
                      local_84 = (ulonglong)uVar24;
                      fVar4 = (float)local_84;
                      local_84 = (ulonglong)uVar19;
                      local_ac._0_4_ = (uint)(longlong)ROUND(fVar4 * 0.3 + 49.0);
                      local_84._0_4_ = (uint)(longlong)ROUND((float)local_84 * 0.3 + 49.0);
                      uVar24 = (uint)local_ac;
                    }
                    iVar12 = gdImageGetPixel(photo_copper[photo_groups[0]],local_90,uVar11);
                    uVar19 = uVar24;
                    local_ac._0_4_ = (uint)local_84;
                    if (iVar12 != 0) {
                      if (local_a4 == 0) {
                        lVar14 = random();
                        iVar6 = (lVar14 % 5) * 2;
                        uVar24 = iVar6 + 0x88;
                        uVar19 = iVar6 + 0x92;
                        uVar20 = iVar6 + 0x9c;
                      }
                      else {
                        uVar24 = 0xdc;
                        uVar19 = 0x91;
                        uVar20 = 0xe6;
                      }
                      if (iVar12 == 2) {
                        local_ac = (ulonglong)(0xff - uVar24);
                        local_ac._0_4_ = (uint)(longlong)ROUND((double)local_ac * -0.7 + 255.0);
                        uVar24 = (uint)local_ac;
                        local_84 = (ulonglong)(0xff - uVar19);
                        local_ac = (ulonglong)(0xff - uVar20);
                        local_84._0_4_ = (uint)(longlong)ROUND((double)local_84 * -0.7 + 255.0);
                        local_ac._0_4_ = (uint)(longlong)ROUND((double)local_ac * -0.7 + 255.0);
                        uVar19 = (uint)local_84;
                      }
                      else {
                        local_ac._0_4_ = uVar20;
                        if (iVar12 == 3) {
                          local_ac = (ulonglong)uVar24;
                          local_84 = (ulonglong)uVar19;
                          uVar24 = (uint)(longlong)ROUND((double)local_ac * 0.7);
                          local_ac = (ulonglong)uVar20;
                          local_84._0_4_ = (uint)(longlong)ROUND((double)local_84 * 0.7);
                          local_ac._0_4_ = (uint)(longlong)ROUND((double)local_ac * 0.7);
                          uVar19 = (uint)local_84;
                        }
                      }
                    }
                    if ((photo_drill == (gdImagePtr)0x0) ||
                       (iVar12 = gdImageGetPixel(photo_drill,local_90,uVar11), iVar12 != 0)) {
                      if (iVar9 == 0) {
                        local_84._0_4_ = (uint)local_ac;
                        local_9c = uVar24;
                        if (local_a4 != 0) {
                          if (local_a4 == 2) {
                            fVar4 = 76.5;
                          }
                          else {
                            local_84._0_4_ = (uint)local_ac >> 1;
                            local_9c = uVar24 >> 1;
                            if (local_a4 != 3) goto LAB_0811577d;
                            fVar4 = 0.0;
                          }
                          local_84 = (ulonglong)uVar19;
                          local_9c = (uint)(longlong)
                                           ROUND((float)(ulonglong)(uVar24 >> 1) * 0.7 + fVar4);
                          uVar19 = (uint)(longlong)ROUND((float)local_84 * 0.7 + fVar4);
                          local_84 = (ulonglong)((uint)local_ac >> 1);
                          local_84._0_4_ = (uint)(longlong)ROUND((float)local_84 * 0.7 + fVar4);
                        }
                      }
                      else if (iVar9 == 2) {
                        uVar19 = 0xff;
                        local_84._0_4_ = 0xff;
                        local_9c = 0xff;
                      }
                      else {
                        uVar19 = 0xe0;
                        local_84._0_4_ = uVar19;
                        local_9c = uVar19;
                        if (iVar9 == 3) {
                          uVar19 = 0xc0;
                          local_84._0_4_ = uVar19;
                          local_9c = uVar19;
                        }
                      }
                    }
                    else {
                      local_a0 = 1;
                      uVar19 = 0;
                      local_84._0_4_ = 0;
                      local_9c = 0;
                    }
LAB_0811577d:
                    if (local_b8[8].int_value == 0) {
                      if (local_a0 == 0) {
                        uVar13 = gdImageColorResolve(im,local_9c,uVar19,(uint)local_84);
                        goto LAB_08115513;
                      }
                      uVar13 = gdImageColorResolve(im,0,0,0);
                      if (photo_flip != 1) goto LAB_08115522;
LAB_081157cf:
                      uVar24 = uVar11 + 1;
                      gdImageSetPixel(im,~local_90 + im->sx,uVar11,uVar13);
                      pgVar15 = im;
                      uVar11 = uVar24;
                      if (im->sy == uVar24 || im->sy < (int)uVar24) break;
                      goto LAB_0811555c;
                    }
                    if (local_a0 == 0) {
                      uVar13 = gdImageColorResolveAlpha(im,local_9c,uVar19,(uint)local_84,0);
                    }
                    else {
                      uVar13 = gdImageColorResolveAlpha(im,0,0,0,0x7f);
                    }
LAB_08115513:
                    if (photo_flip == 1) goto LAB_081157cf;
LAB_08115522:
                    if (photo_flip == 2) {
                      gdImageSetPixel(im,local_90,~uVar11 + im->sy,uVar13);
                    }
                    else {
                      gdImageSetPixel(im,local_90,uVar11,uVar13);
                    }
                    uVar11 = uVar11 + 1;
                    pgVar15 = im;
                  } while (im->sy != uVar11 && (int)uVar11 <= im->sy);
                }
                local_90 = local_90 + 1;
              } while (pgVar15->sx != local_90 && (int)local_90 <= pgVar15->sx);
            }
          }
          pcVar3 = filetypes[local_b8[9].int_value];
          bVar25 = *pcVar3 == 'G';
          if ((((bVar25) && (bVar25 = pcVar3[1] == 'I', bVar25)) &&
              (bVar25 = pcVar3[2] == 'F', bVar25)) && (bVar25 = pcVar3[3] == '\0', bVar25)) {
            gdImageGif(im,f);
          }
          else {
            iVar9 = 5;
            pcVar18 = pcVar3;
            pcVar22 = "JPEG";
            do {
              if (iVar9 == 0) break;
              iVar9 = iVar9 + -1;
              bVar25 = *pcVar18 == *pcVar22;
              pcVar18 = pcVar18 + (uint)bVar26 * -2 + 1;
              pcVar22 = pcVar22 + (uint)bVar26 * -2 + 1;
            } while (bVar25);
            if (bVar25) {
              gdImageJpeg(im,f,0xffffffff);
            }
            else if (((*pcVar3 == 'P') && (pcVar3[1] == 'N')) &&
                    ((pcVar3[2] == 'G' && (pcVar3[3] == '\0')))) {
              gdImagePng(im,f);
            }
            else {
              __fprintf_chk(stderr,1,
                            "Error:  Invalid graphic file format.  This is a bug.  Please report it.\n"
                           );
            }
          }
          fclose((FILE *)f);
          gdImageDestroy(im);
        }
      }
    }
  }
LAB_081150a5:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void ps_use_mask(int use_it)

{
  return;
}



// WARNING: Unknown calling convention

void ps_set_line_cap(hidGC_conflict5 gc,EndCapStyle style)

{
  gc->cap = style;
  return;
}



// WARNING: Unknown calling convention

void ps_set_line_width(hidGC_conflict5 gc,int width)

{
  gc->width = width;
  return;
}



// WARNING: Unknown calling convention

void ps_set_draw_xor(hidGC_conflict5 gc,int xor)

{
  return;
}



// WARNING: Unknown calling convention

void ps_set_draw_faded(hidGC_conflict5 gc,int faded)

{
  gc->faded = faded;
  return;
}



// WARNING: Unknown calling convention

void ps_set_crosshair(int x,int y,int action)

{
  return;
}



// WARNING: Unknown calling convention

void use_gc(hidGC_conflict5 gc)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  EndCapStyle EVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  undefined4 uVar11;
  int c;
  double r;
  double g;
  double b;
  
  if (gc->me_pointer != &ps_hid) {
    __fprintf_chk(stderr,1,"Fatal: GC from another HID passed to ps HID\n");
                    // WARNING: Subroutine does not return
    abort();
  }
  if (gc->width != linewidth) {
    __fprintf_chk(f,1,"%d setlinewidth\n",((-(uint)(gc->erase == 0) & 4) - 2) * bloat + gc->width);
    linewidth = gc->width;
  }
  EVar5 = gc->cap;
  if (lastcap != EVar5) {
    uVar11 = 2;
    if (EVar5 < Beveled_Cap) {
      uVar11 = *(undefined4 *)(CSWTCH_163 + EVar5 * 4);
    }
    __fprintf_chk(f,1,"%d setlinecap %d setlinejoin\n",uVar11,uVar11);
    lastcap = gc->cap;
  }
  if (((uint)gc->r << 0x18 | (uint)gc->g << 0x10 | gc->faded | (uint)gc->b << 8) == lastcolor) {
    return;
  }
  if ((is_drill != 0) || (is_mask != 0)) {
    __fprintf_chk(f,1,"%d gray\n",gc->erase == 0);
    lastcolor = 0;
    return;
  }
  fVar6 = (float)(ushort)gc->r;
  fVar8 = (float)(ushort)gc->g;
  fVar9 = (float)(ushort)gc->b;
  if (gc->faded == 0) {
    sVar3._0_1_ = gc->g;
    sVar3._1_1_ = gc->b;
    sVar1._0_1_ = gc->r;
    sVar1._1_1_ = gc->g;
    if (sVar1 != sVar3) {
LAB_08115e64:
      __fprintf_chk(f,1,"%g %g %g rgb\n",(double)(fVar6 / 255.0),(double)(fVar8 / 255.0),
                    (double)(fVar9 / 255.0));
      goto LAB_08115e9d;
    }
  }
  else {
    fVar7 = (float)antifade_ratio * 255.0;
    sVar4._0_1_ = gc->g;
    sVar4._1_1_ = gc->b;
    sVar2._0_1_ = gc->r;
    sVar2._1_1_ = gc->g;
    fVar10 = (float)fade_ratio;
    fVar6 = fVar6 * fVar10 + fVar7;
    fVar8 = fVar8 * fVar10 + fVar7;
    fVar9 = fVar7 + fVar9 * fVar10;
    if (sVar2 != sVar4) goto LAB_08115e64;
  }
  __fprintf_chk(f,1,"%g gray\n",(double)(fVar6 / 255.0));
LAB_08115e9d:
  lastcolor = (uint)gc->r << 0x18 | (uint)gc->g << 0x10 | gc->faded | (uint)gc->b << 8;
  return;
}



// WARNING: Unknown calling convention

void ps_fill_rect(hidGC_conflict5 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  if (y2 < y1) {
    y2 = y1;
  }
  if (x2 < x1) {
    x2 = x1;
  }
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1 - bloat,y1 - bloat,x2 + bloat,y2 + bloat);
  return;
}



// WARNING: Unknown calling convention

void ps_fill_polygon(hidGC_conflict5 gc,int n_coords,int *x,int *y)

{
  int *piVar1;
  int *piVar2;
  char *pcVar3;
  char *op;
  int i;
  
  use_gc(gc);
  if (0 < n_coords) {
    pcVar3 = "moveto";
    i = 0;
    do {
      piVar1 = y + i;
      piVar2 = x + i;
      i = i + 1;
      __fprintf_chk(f,1,"%d %d %s\n",*piVar2,*piVar1,pcVar3);
      pcVar3 = "lineto";
    } while (i < n_coords);
  }
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention

void ps_fill_circle(hidGC_conflict5 gc,int cx,int cy,int radius)

{
  int iVar1;
  
  use_gc(gc);
  iVar1 = 1;
  if (gc->erase != 0) {
    if (is_copper != 0) {
      if (drillcopper == 0) {
        return;
      }
      if (drill_helper != 0) {
        iVar1 = PCB->minDrill;
        if (iVar1 < 0) {
          iVar1 = iVar1 + 3;
        }
        if (iVar1 >> 2 < radius) {
          radius = iVar1 >> 2;
        }
        iVar1 = -1;
        goto LAB_081160f0;
      }
    }
    iVar1 = -1;
  }
LAB_081160f0:
  __fprintf_chk(f,1,"%d %d %d c\n",cx,cy,iVar1 * bloat + radius);
  return;
}



// WARNING: Unknown calling convention

void ps_draw_rect(hidGC_conflict5 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1,y1,x2,y2);
  return;
}



// WARNING: Unknown calling convention

void ps_draw_arc(hidGC_conflict5 gc,int cx,int cy,int width,int height,int start_angle,
                int delta_angle)

{
  int sa;
  int ea;
  
  if (delta_angle < 1) {
    sa = delta_angle + start_angle;
  }
  else {
    sa = start_angle;
    start_angle = delta_angle + start_angle;
  }
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d %d %d %g a\n",sa,start_angle,-width,height,cx,cy,
                (double)(bloat * 2 + linewidth) / (double)width);
  return;
}



// WARNING: Unknown calling convention

void ps_draw_line(hidGC_conflict5 gc,int x1,int y1,int x2,int y2)

{
  int radius;
  
  if ((y1 == y2) && (x1 == x2)) {
    radius = gc->width / 2;
    if (gc->cap != Square_Cap) {
      ps_fill_circle(gc,x1,y1,radius);
      return;
    }
    ps_fill_rect(gc,x1 - radius,y1 - radius,x1 + radius,y1 + radius);
    return;
  }
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d t\n",x1,y1,x2,y2);
  return;
}



// WARNING: Unknown calling convention

void ps_set_line_cap_angle(hidGC_conflict5 gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented PS function %s.\n",
                "ps_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void corner(int x,int y,int dx,int dy)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  
  __fprintf_chk(f,1,"gsave %d setlinewidth %d %d translate %d %d scale\n",0,x,y,dx,dy);
  uVar7 = 200000;
  uVar6 = 0;
  uVar5 = 20000;
  uVar4 = 0;
  uVar3 = 0;
  uVar2 = 0;
  uVar1 = 200000;
  __fprintf_chk(f,1,"%d %d moveto %d %d %d 0 90 arc %d %d lineto\n",200000,0,0,0,20000,0,200000);
  if ((dy < 0) && (dx < 0)) {
    uVar3 = 0xffffb1e0;
    uVar2 = 0;
    uVar1 = 40000;
    __fprintf_chk(f,1,"%d %d moveto 0 %d rlineto\n",40000,0,0xffffb1e0,uVar4,uVar5,uVar6,uVar7);
  }
  __fprintf_chk(f,1,"stroke grestore\n",uVar1,uVar2,uVar3,uVar4,uVar5,uVar6,uVar7);
  return;
}



// WARNING: Unknown calling convention

void ps_start_file(FILE *f)

{
  __fprintf_chk(f,1,"%%!PS-Adobe-3.0\n\n");
  return;
}



// WARNING: Unknown calling convention

void ps_set_color(hidGC_conflict5 gc,char *name)

{
  int b;
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  bool bVar4;
  uchar local_28;
  uchar local_24;
  uchar local_20;
  
  iVar1 = 6;
  bVar4 = &stack0x00000000 == (undefined *)0x4c;
  pcVar2 = name;
  pcVar3 = "erase";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *pcVar2 == *pcVar3;
    pcVar2 = pcVar2 + 1;
    pcVar3 = pcVar3 + 1;
  } while (bVar4);
  if (!bVar4) {
    iVar1 = 6;
    pcVar2 = name;
    pcVar3 = "drill";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      bVar4 = *pcVar2 == *pcVar3;
      pcVar2 = pcVar2 + 1;
      pcVar3 = pcVar3 + 1;
    } while (bVar4);
    if (!bVar4) {
      if (incolor == 0) {
        gc->b = '\0';
        gc->g = '\0';
        gc->r = '\0';
        gc->erase = 0;
        return;
      }
      sscanf(name + 1,"%02x%02x%02x");
      gc->r = local_20;
      gc->g = local_24;
      gc->erase = 0;
      gc->b = local_28;
      return;
    }
  }
  gc->b = 0xff;
  gc->g = 0xff;
  gc->r = 0xff;
  gc->erase = 1;
  return;
}



// WARNING: Unknown calling convention

void ps_destroy_gc(hidGC_conflict5 gc)

{
  free(gc);
  return;
}



// WARNING: Unknown calling convention

hidGC_conflict5 ps_make_gc(void)

{
  hidGC_conflict5 phVar1;
  
  phVar1 = (hidGC_conflict5)calloc(1,0x18);
  phVar1->me_pointer = &ps_hid;
  phVar1->cap = Trace_Cap;
  return phVar1;
}



// WARNING: Unknown calling convention

int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int d;
  int iVar1;
  int iVar2;
  int iVar3;
  int a;
  int b;
  
                    // WARNING: Load size is inaccurate
  Layer = *va;
                    // WARNING: Load size is inaccurate
  Layer_00 = *vb;
  iVar1 = PCB->Data->LayerN;
  iVar3 = iVar1 + 1;
  if (((int)Layer_00 < 0) || (iVar3 < (int)Layer_00)) {
    iVar2 = iVar1 + 3 + Layer_00;
  }
  else {
    iVar2 = GetLayerGroupNumberByNumber(Layer_00);
    iVar1 = PCB->Data->LayerN;
    iVar3 = iVar1 + 1;
  }
  if ((iVar3 < (int)Layer) || ((int)Layer < 0)) {
    iVar3 = iVar1 + 3 + Layer;
  }
  else {
    iVar3 = GetLayerGroupNumberByNumber(Layer);
  }
  iVar1 = iVar2 - iVar3;
  if (iVar2 - iVar3 == 0) {
    iVar1 = Layer_00 - Layer;
  }
  return iVar1;
}



// WARNING: Unknown calling convention
// Local variable f:FILE *[EAX:4] conflicts with parameter, skipped.

FILE * psopen(char *base,char *which)

{
  size_t sVar1;
  size_t sVar2;
  char *__dest;
  char *pcVar3;
  char *pcVar4;
  FILE *pFVar5;
  
  if (multi_file == 0) {
    pFVar5 = (FILE *)fopen(base,"w");
  }
  else {
    sVar1 = strlen(base);
    sVar2 = strlen(which);
    __dest = (char *)calloc(1,sVar1 + 5 + sVar2);
    pcVar3 = strrchr(base,0x2e);
    if (pcVar3 == (char *)0x0) {
      __sprintf_chk(__dest,1,0xffffffff,"%s.%s.ps",base,which);
    }
    else {
      strcpy(__dest,base);
      pcVar4 = strrchr(__dest,0x2e);
      __sprintf_chk(pcVar4,1,0xffffffff,".%s.%s",which,pcVar3 + 1);
    }
    __printf_chk(1,"PS: open %s\n",__dest);
    pFVar5 = (FILE *)fopen(__dest,"w");
    free(__dest);
  }
  return pFVar5;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int ps_set_layer(char *name,int group,int empty)

{
  uint idx;
  char *pcVar1;
  int iVar2;
  int iVar3;
  int natural;
  uint uVar4;
  int mirror_this;
  int needed;
  char *pcVar5;
  bool bVar6;
  byte bVar7;
  undefined8 in_stack_ffffffa0;
  double dVar8;
  double dVar9;
  double dVar10;
  undefined8 uVar11;
  undefined4 uVar12;
  double dVar13;
  double local_34;
  
  uVar12 = (undefined4)((ulonglong)in_stack_ffffffa0 >> 0x20);
  bVar7 = 0;
  idx = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    idx = (PCB->LayerGroups).Entries[group][0];
  }
  if (name == (char *)0x0) {
    name = PCB->Data->Layer[idx].Name;
  }
  if ((empty != 0) ||
     (((bVar6 = idx == 0, -1 < (int)idx &&
       (uVar4 = PCB->Data->LayerN, bVar6 = idx == uVar4, (int)idx < (int)uVar4)) &&
      (bVar6 = print_layer[idx] == 0, bVar6)))) {
    return 0;
  }
  iVar3 = 10;
  pcVar1 = name;
  pcVar5 = "invisible";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *pcVar1 == *pcVar5;
    pcVar1 = pcVar1 + 1;
    pcVar5 = pcVar5 + 1;
  } while (bVar6);
  if (bVar6) {
    return 0;
  }
  if ((int)idx < 0) {
    uVar4 = idx & 0xf0;
    if ((uVar4 == 0x40) || (uVar4 == 0x30)) {
      is_drill = 1;
    }
    else {
      is_drill = 0;
    }
    if (uVar4 == 0x20) {
      is_mask = 1;
      is_assy = 0;
      is_copper = 0;
      goto LAB_0811680e;
    }
    is_mask = 0;
    if (uVar4 == 0x80) {
      is_assy = 1;
      is_copper = 0;
      goto LAB_0811680e;
    }
    is_copper = (int)(uVar4 == 0);
    is_paste = 1;
    is_assy = 0;
    if (uVar4 != 0x50) goto LAB_0811680e;
  }
  else {
    is_drill = 0;
    is_mask = 0;
    is_assy = 0;
    is_copper = 1;
LAB_0811680e:
    is_paste = 0;
  }
  if (doing_toc != 0) {
    if ((group < 0) || (group != lastgroup)) {
      lastgroup = group;
      pagecount = pagecount + 1;
      __fprintf_chk(f,1,"(%d.) tocp\n",pagecount);
    }
    __fprintf_chk(f,1,"(%s) toc\n",name);
    return 0;
  }
  if ((-1 < group) && (group == lastgroup)) goto LAB_08116c63;
  lastgroup = group;
  iVar3 = pagecount;
  if ((f != (FILE *)0x0) && (iVar3 = 0, pagecount != 0)) {
    __fprintf_chk(f,1,"showpage\n");
    iVar3 = pagecount;
  }
  pagecount = iVar3 + 1;
  if (multi_file != 0) {
    if (f != (FILE *)0x0) {
      fclose((FILE *)f);
    }
    pcVar1 = layer_type_to_file_name(idx);
    f = psopen(filename,pcVar1);
    if (f == (FILE *)0x0) {
      perror(filename);
      return 0;
    }
    ps_start_file(f);
  }
  dVar8 = (double)CONCAT44(uVar12,pagecount);
  __fprintf_chk(f,1,"%%%%Page: %d\n",pagecount);
  uVar4 = (uint)(mirror != 0);
  if (automirror != 0) {
    if ((int)idx < 0) {
      if ((idx & 0xf) == 2) goto LAB_08116904;
    }
    else {
      iVar3 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
      if (iVar3 == group) {
LAB_08116904:
        uVar4 = 1 - uVar4;
      }
    }
  }
  __fprintf_chk(f,1,"/Helvetica findfont 10 scalefont setfont\n",dVar8);
  if (legend != 0) {
    uVar12 = (undefined4)((ulonglong)dVar8 >> 0x20);
    __fprintf_chk(f,1,"30 30 moveto (%s) show\n",PCB->Filename);
    if (PCB->Name == (char *)0x0) {
      pcVar1 = layer_type_to_file_name(idx);
      dVar8 = (double)CONCAT44(uVar12,pcVar1);
      __fprintf_chk(f,1,"30 41 moveto (%s) show\n",pcVar1);
    }
    else {
      pcVar1 = layer_type_to_file_name(idx);
      dVar8 = (double)CONCAT44(pcVar1,PCB->Name);
      __fprintf_chk(f,1,"30 41 moveto (%s, %s) show\n",PCB->Name,pcVar1);
    }
    if (uVar4 != 0) {
      __fprintf_chk(f,1,"( \\(mirrored\\)) show\n",dVar8);
    }
    if (fillpage == 0) {
      dVar8 = scale_value;
      __fprintf_chk(f,1,"(, scale = 1:%.3f) show\n",scale_value);
    }
    else {
      __fprintf_chk(f,1,"(, not to scale) show\n",dVar8);
    }
  }
  __fprintf_chk(f,1,"newpath\n",dVar8);
  dVar8 = (double)((float)media_height * 0.5);
  dVar9 = (double)((float)media_width * 0.5);
  __fprintf_chk(f,1,"72 72 scale %g %g translate\n",dVar9,dVar8);
  dVar13 = calibration_y;
  dVar10 = calibration_x;
  local_34 = media_height;
  if (PCB->MaxHeight < PCB->MaxWidth) {
    __fprintf_chk(f,1,"90 rotate\n",dVar9,dVar8);
    dVar13 = calibration_x;
    dVar10 = calibration_y;
    local_34 = media_width;
  }
  local_34 = local_34 * 0.5;
  __fprintf_chk(f,1,"%g %g scale %% calibration\n",dVar10,dVar13);
  if (uVar4 != 0) {
    __fprintf_chk(f,1,"1 -1 scale\n",dVar10,dVar13);
  }
  if (((int)idx < 0) && ((idx & 0xf0) == 0x70)) {
    __fprintf_chk(f,1,"0.00001 dup neg scale\n",dVar10,dVar13);
    __fprintf_chk(f,1,"%d %d translate\n",-(PCB->MaxWidth / 2),-(PCB->MaxHeight / 2));
LAB_08116f2d:
    iVar2 = (int)ROUND((local_34 - 0.5) * 100000.0) - PCB->MaxHeight / 2;
    iVar3 = PrintFab_overhang();
    uVar11 = CONCAT44(iVar3,iVar2);
    __fprintf_chk(f,1,"%% PrintFab overhang natural %d, needed %d\n",iVar2,iVar3);
    if (iVar2 < iVar3) {
      uVar12 = (undefined4)((ulonglong)uVar11 >> 0x20);
      uVar11 = CONCAT44(uVar12,iVar3 - iVar2);
      __fprintf_chk(f,1,"0 %d translate\n",iVar3 - iVar2,uVar12);
    }
  }
  else {
    __fprintf_chk(f,1,"%g dup neg scale\n",fill_zoom * scale_value,dVar13);
    iVar3 = -(PCB->MaxHeight / 2);
    iVar2 = -(PCB->MaxWidth / 2);
    uVar11 = CONCAT44(iVar3,iVar2);
    __fprintf_chk(f,1,"%d %d translate\n",iVar2,iVar3);
    if (((int)idx < 0) && ((idx & 0xf0) == 0x70)) goto LAB_08116f2d;
  }
  if (invert == 0) {
    __fprintf_chk(f,1,"/gray { setgray } bind def\n",uVar11);
    __fprintf_chk(f,1,"/rgb { setrgbcolor } bind def\n");
  }
  else {
    __fprintf_chk(f,1,"/gray { 1 exch sub setgray } bind def\n",uVar11);
    __fprintf_chk(f,1,"/rgb { 1 1 3 { pop 1 exch sub 3 1 roll } for setrgbcolor } bind def\n");
  }
  if ((outline == 0) || (outline_layer != (LayerTypePtr)0x0)) {
    if (invert != 0) goto LAB_08116b17;
  }
  else {
    if (invert == 0) {
      pcVar1 = "stroke";
    }
    else {
LAB_08116b17:
      pcVar1 = "fill";
    }
    iVar3 = PCB->MaxWidth;
    iVar2 = PCB->MaxHeight;
    dVar13 = (double)CONCAT44(iVar3,iVar2);
    uVar11 = CONCAT44(iVar3,iVar2);
    __fprintf_chk(f,1,
                  "0 setgray 0 setlinewidth 0 0 moveto 0 %d lineto %d %d lineto %d 0 lineto closepath %s\n"
                  ,iVar2,iVar3,iVar2,iVar3,pcVar1);
  }
  if (align_marks != 0) {
    corner(0,0,-1,-1);
    corner(PCB->MaxWidth,0,1,-1);
    corner(PCB->MaxWidth,PCB->MaxHeight,1,1);
    corner(0,PCB->MaxHeight,-1,1);
  }
  linewidth = -1;
  lastcap = -1;
  lastcolor = -1;
  __fprintf_chk(f,1,"/ts 10000 def\n",uVar11,dVar13);
  __fprintf_chk(f,1,"/ty ts neg def /tx 0 def /Helvetica findfont ts scalefont setfont\n");
  __fprintf_chk(f,1,"/t { moveto lineto stroke } bind def\n");
  __fprintf_chk(f,1,"/r { /y2 exch def /x2 exch def /y1 exch def /x1 exch def\n");
  __fprintf_chk(f,1,
                "     x1 y1 moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto closepath fill } bind def\n"
               );
  __fprintf_chk(f,1,"/c { 0 360 arc fill } bind def\n");
  __fprintf_chk(f,1,
                "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n"
               );
  if (drill_helper != 0) {
    __fprintf_chk(f,1,"/dh { gsave %d setlinewidth 0 gray %d 0 360 arc stroke grestore} bind def\n",
                  400,600);
  }
LAB_08116c63:
  if ((((outline == 0) || (outline_layer == (LayerTypePtr)0x0)) ||
      (outline_layer == PCB->Data->Layer + idx)) ||
     ((bVar6 = idx == 0, (int)idx < 0 && (bVar6 = (idx & 0xf0) == 0, !bVar6)))) {
    return 1;
  }
  iVar3 = 8;
  pcVar1 = name;
  pcVar5 = "outline";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *pcVar1 == *pcVar5;
    pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
    pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
  } while (bVar6);
  if (bVar6) {
    return 1;
  }
  iVar3 = 6;
  pcVar1 = name;
  pcVar5 = "route";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *pcVar1 == *pcVar5;
    pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
    pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
  } while (bVar6);
  if (bVar6) {
    return 1;
  }
  __printf_chk(1,"attempting to draw outlines on %s\n",name);
  DrawLayer(outline_layer,&region);
  return 1;
}



// WARNING: Unknown calling convention

void register_ps_attribute_list(void)

{
  hid_register_attributes(ps_attribute_list,0x12);
  return;
}



// WARNING: Unknown calling convention

void ps_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes(ps_attribute_list,0x12);
  hid_parse_command_line(argc,argv);
  return;
}



// WARNING: Unknown calling convention

HID_Attribute * ps_get_export_options(int *n)

{
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,ps_attribute_list,".ps",&ps_get_export_options::last_made_filename);
  }
  if (n != (int *)0x0) {
    *n = 0x12;
  }
  return ps_attribute_list;
}



// WARNING: Unknown calling convention

void hid_ps_init(void)

{
  apply_default_hid((HID *)&ps_hid,(HID *)0x0);
  hid_register_hid((HID *)&ps_hid);
  hid_eps_init();
  register_ps_attribute_list();
  register_eps_attribute_list();
  return;
}



// WARNING: Unknown calling convention

void ps_calibrate_1(double xval,double yval,int use_command)

{
  bool bVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  char *pcVar5;
  char *cmd;
  int c;
  FILE *f;
  int used_popen;
  HID_Attr_Val vals [3];
  
  if ((xval <= 0.0) || (yval <= 0.0)) {
    if ((ps_calib_attribute_list[0].default_val.str_value == (char *)0x0) &&
       (ps_calib_attribute_list[0].default_val.str_value = (char *)calloc(1,4),
       (undefined4 *)ps_calib_attribute_list[0].default_val.str_value != (undefined4 *)0x0)) {
      *(undefined4 *)ps_calib_attribute_list[0].default_val.str_value = 0x72706c;
    }
    iVar4 = (*gui->attribute_dialog)
                      (ps_calib_attribute_list,1,vals,"Print Calibration Page",
                       "Generates a printer calibration page");
    dVar2 = ps_attribute_list[15].default_val.real_value;
    dVar3 = calibration_y;
    if (iVar4 == 0) {
      if ((use_command == 0) && (pcVar5 = strchr(vals[0].str_value,0x7c), pcVar5 == (char *)0x0)) {
        bVar1 = false;
        f = (FILE *)fopen(vals[0].str_value,"w");
      }
      else {
        for (; (*vals[0].str_value == '|' || (*vals[0].str_value == ' '));
            vals[0].str_value = vals[0].str_value + 1) {
        }
        bVar1 = true;
        f = (FILE *)popen(vals[0].str_value,"w");
      }
      pcVar5 = "%!PS-Adobe\n";
      iVar4 = 0;
      do {
        iVar4 = iVar4 + 1;
        fputs(pcVar5,(FILE *)f);
        pcVar5 = calib_lines[iVar4];
      } while (pcVar5 != (char *)0x0);
      __fprintf_chk(f,1,"4 in 0.5 (Y in) cbar\n");
      __fprintf_chk(f,1,"20 cm 1.5 (Y cm) cbar\n");
      __fprintf_chk(f,1,"10 in 2.5 (Y in) cbar\n");
      __fprintf_chk(f,1,"-90 rotate\n");
      __fprintf_chk(f,1,"4 in -0.5 (X in) cbar\n");
      __fprintf_chk(f,1,"15 cm -1.5 (X cm) cbar\n");
      __fprintf_chk(f,1,"7.5 in -2.5 (X in) cbar\n");
      __fprintf_chk(f,1,"showpage\n");
      if (bVar1) {
        pclose((FILE *)f);
        return;
      }
      fclose((FILE *)f);
      dVar2 = ps_attribute_list[15].default_val.real_value;
      dVar3 = calibration_y;
    }
  }
  else {
    if ((xval < 3.6) || (4.4 < xval)) {
      if ((xval < 13.5) || (16.5 < xval)) {
        if ((xval < 6.75) || (8.25 < xval)) {
          if (2.0 <= xval) {
            Message("X value of %g is too far off.\nExpecting it near: 1.0, 4.0, 15.0, 7.5\n",xval);
          }
          else {
            calibration_x = xval;
            ps_attribute_list[14].default_val.real_value = xval;
          }
        }
        else {
          calibration_x = 7.5 / xval;
        }
      }
      else {
        calibration_x = 15.0 / xval;
      }
    }
    else {
      calibration_x = 4.0 / xval;
    }
    dVar2 = ps_attribute_list[15].default_val.real_value;
    if ((yval < 3.6) || (4.4 < yval)) {
      if ((yval < 18.0) || (22.0 < yval)) {
        if ((yval < 9.0) || (11.0 < yval)) {
          dVar2 = yval;
          dVar3 = yval;
          if (2.0 <= yval) {
            Message("Y value of %g is too far off.\nExpecting it near: 1.0, 4.0, 20.0, 10.0\n",yval)
            ;
            dVar2 = ps_attribute_list[15].default_val.real_value;
            dVar3 = calibration_y;
          }
        }
        else {
          dVar3 = 10.0 / yval;
        }
      }
      else {
        dVar3 = 20.0 / yval;
      }
    }
    else {
      dVar3 = 4.0 / yval;
    }
  }
  calibration_y = dVar3;
  ps_attribute_list[15].default_val.real_value = dVar2;
  return;
}



// WARNING: Unknown calling convention

void ps_calibrate(double xval,double yval)

{
  ps_calibrate_1(xval,yval,0);
  return;
}



// WARNING: Unknown calling convention

void ps_hid_export_to_file(FILE *the_file,HID_Attr_Val *options)

{
  int iVar1;
  uchar uVar2;
  uchar uVar3;
  uchar uVar4;
  uchar uVar5;
  uchar uVar6;
  uchar uVar7;
  uchar uVar8;
  uchar uVar9;
  uint uVar10;
  int iVar11;
  float fVar12;
  float fVar13;
  double dVar14;
  int iVar15;
  DataTypePtr paVar16;
  PCBTypePtr pPVar17;
  int i;
  Cardinal CVar18;
  char *pcVar19;
  char *pcVar20;
  int *piVar21;
  char *pcVar22;
  undefined uVar23;
  byte bVar24;
  double zy;
  double zx;
  
  pPVar17 = PCB;
  bVar24 = 0;
  uVar2 = (PCB->Flags).t[7];
  uVar3 = (PCB->Flags).t[6];
  uVar4 = (PCB->Flags).t[5];
  uVar5 = (PCB->Flags).t[4];
  uVar6 = (PCB->Flags).t[3];
  uVar7 = (PCB->Flags).t[2];
  uVar8 = (PCB->Flags).t[1];
  uVar9 = (PCB->Flags).t[0];
  uVar10 = (PCB->Flags).f;
  (PCB->Flags).f = uVar10 & 0xfffdbfff;
  f = the_file;
  drill_helper = options[1].int_value;
  align_marks = options[2].int_value;
  outline = options[3].int_value;
  mirror = options[4].int_value;
  fillpage = options[5].int_value;
  fade_ratio = options[0xb].real_value;
  automirror = options[6].int_value;
  incolor = options[7].int_value;
  bloat = options[8].int_value;
  invert = options[9].int_value;
  media = options[10].int_value;
  fVar12 = (float)media_data[media].Width / 100000.0;
  media_width = (double)fVar12;
  fVar13 = 100000.0 / (float)media_data[media].Height;
  media_height = (double)fVar13;
  fVar12 = ((float)media_data[media].MarginX + (float)media_data[media].MarginX) / -100000.0 +
           fVar12;
  ps_width = (double)fVar12;
  drillcopper = options[0x10].int_value;
  fVar13 = -100000.0 / ((float)media_data[media].MarginY + (float)media_data[media].MarginY) +
           fVar13;
  ps_height = (double)fVar13;
  scale_value = options[0xc].real_value;
  calibration_x = options[0xe].real_value;
  calibration_y = options[0xf].real_value;
  legend = options[0x11].int_value;
  if (fade_ratio < 0.0) {
    dVar14 = 0.0;
  }
  else {
    dVar14 = 1.0;
    if (fade_ratio <= 1.0) goto LAB_08117910;
  }
  fade_ratio = dVar14;
LAB_08117910:
  antifade_ratio = 1.0 - fade_ratio;
  if (fillpage == 0) {
    fill_zoom = 1e-05;
  }
  else {
    iVar15 = pPVar17->MaxWidth;
    iVar11 = pPVar17->MaxHeight;
    iVar1 = iVar11;
    if (iVar15 <= iVar11) {
      iVar1 = iVar15;
      iVar15 = iVar11;
    }
    fVar13 = fVar13 / (float)iVar15;
    fVar12 = (float)iVar1 / fVar12;
    if (fVar13 <= fVar12 || fVar12 != fVar13) {
      fVar12 = fVar13;
    }
    fill_zoom = (double)fVar12;
  }
  piVar21 = print_group;
  for (iVar15 = 0x10; iVar15 != 0; iVar15 = iVar15 + -1) {
    *piVar21 = 0;
    piVar21 = piVar21 + 1;
  }
  outline_layer = (LayerTypePtr)0x0;
  piVar21 = print_layer;
  for (iVar15 = 0x10; iVar15 != 0; iVar15 = iVar15 + -1) {
    *piVar21 = 0;
    piVar21 = piVar21 + 1;
  }
  paVar16 = pPVar17->Data;
  CVar18 = paVar16->LayerN;
  if (0 < (int)CVar18) {
    i = 0;
    do {
      uVar23 = paVar16->Layer[i].LineN == 0;
      if ((((!(bool)uVar23) || (uVar23 = paVar16->Layer[i].TextN == 0, !(bool)uVar23)) ||
          (uVar23 = paVar16->Layer[i].ArcN == 0, !(bool)uVar23)) ||
         (uVar23 = paVar16->Layer[i].PolygonN == 0, !(bool)uVar23)) {
        iVar15 = GetLayerGroupNumberByNumber(i);
        print_group[iVar15] = 1;
      }
      iVar15 = 8;
      pcVar20 = paVar16->Layer[i].Name;
      pcVar19 = pcVar20;
      pcVar22 = "outline";
      do {
        if (iVar15 == 0) break;
        iVar15 = iVar15 + -1;
        uVar23 = *pcVar19 == *pcVar22;
        pcVar19 = pcVar19 + (uint)bVar24 * -2 + 1;
        pcVar22 = pcVar22 + (uint)bVar24 * -2 + 1;
      } while ((bool)uVar23);
      if ((bool)uVar23) {
LAB_08117a1c:
        __printf_chk(1,"see outline layer\n");
        outline_layer = paVar16->Layer + i;
      }
      else {
        iVar15 = 6;
        pcVar19 = "route";
        do {
          if (iVar15 == 0) break;
          iVar15 = iVar15 + -1;
          uVar23 = *pcVar20 == *pcVar19;
          pcVar20 = pcVar20 + (uint)bVar24 * -2 + 1;
          pcVar19 = pcVar19 + (uint)bVar24 * -2 + 1;
        } while ((bool)uVar23);
        if ((bool)uVar23) goto LAB_08117a1c;
      }
      i = i + 1;
      paVar16 = PCB->Data;
      CVar18 = paVar16->LayerN;
    } while (i < (int)CVar18);
  }
  iVar15 = GetLayerGroupNumberByNumber(CVar18);
  print_group[iVar15] = 1;
  iVar15 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  pPVar17 = PCB;
  print_group[iVar15] = 1;
  if (0 < pPVar17->Data->LayerN) {
    CVar18 = 0;
    do {
      iVar15 = GetLayerGroupNumberByNumber(CVar18);
      if (print_group[iVar15] != 0) {
        print_layer[CVar18] = 1;
      }
      CVar18 = CVar18 + 1;
      piVar21 = &PCB->Data->LayerN;
      pPVar17 = PCB;
    } while (*piVar21 != CVar18 && (int)CVar18 <= *piVar21);
  }
  ps_hid_export_to_file::saved_layer_stack[0] = LayerStack[0];
  ps_hid_export_to_file::saved_layer_stack[1] = LayerStack[1];
  ps_hid_export_to_file::saved_layer_stack[2] = LayerStack[2];
  ps_hid_export_to_file::saved_layer_stack[3] = LayerStack[3];
  ps_hid_export_to_file::saved_layer_stack[4] = LayerStack[4];
  ps_hid_export_to_file::saved_layer_stack[5] = LayerStack[5];
  ps_hid_export_to_file::saved_layer_stack[6] = LayerStack[6];
  ps_hid_export_to_file::saved_layer_stack[7] = LayerStack[7];
  ps_hid_export_to_file::saved_layer_stack[8] = LayerStack[8];
  ps_hid_export_to_file::saved_layer_stack[9] = LayerStack[9];
  ps_hid_export_to_file::saved_layer_stack[10] = LayerStack[10];
  ps_hid_export_to_file::saved_layer_stack[11] = LayerStack[11];
  ps_hid_export_to_file::saved_layer_stack[12] = LayerStack[12];
  ps_hid_export_to_file::saved_layer_stack[13] = LayerStack[13];
  ps_hid_export_to_file::saved_layer_stack[14] = LayerStack[14];
  ps_hid_export_to_file::saved_layer_stack[15] = LayerStack[15];
  qsort(LayerStack,pPVar17->Data->LayerN,4,layer_sort);
  region.X1 = 0;
  region.Y1 = 0;
  lastgroup = -1;
  region.X2 = PCB->MaxWidth;
  linewidth = -1;
  lastcap = -1;
  region.Y2 = PCB->MaxHeight;
  lastcolor = -1;
  if (multi_file == 0) {
    pagecount = 1;
    __fprintf_chk(f,1,"%%%%Page: 1\n");
    __fprintf_chk(f,1,"/Times-Roman findfont 24 scalefont setfont\n");
    __fprintf_chk(f,1,"/rightshow { /s exch def s stringwidth pop -1 mul 0 rmoveto s show } def\n");
    __fprintf_chk(f,1,"/y 72 9 mul def /toc { 100 y moveto show /y y 24 sub def } bind def\n");
    __fprintf_chk(f,1,"/tocp { /y y 12 sub def 90 y moveto rightshow } bind def\n");
    doing_toc = 1;
    hid_expose_callback((HID *)&ps_hid,&region,(void *)0x0);
  }
  pagecount = 1;
  doing_toc = 0;
  lastgroup = -1;
  hid_expose_callback((HID *)&ps_hid,&region,(void *)0x0);
  if (f != (FILE *)0x0) {
    __fprintf_chk(f,1,"showpage\n");
  }
  pPVar17 = PCB;
  LayerStack[0] = ps_hid_export_to_file::saved_layer_stack[0];
  LayerStack[1] = ps_hid_export_to_file::saved_layer_stack[1];
  LayerStack[2] = ps_hid_export_to_file::saved_layer_stack[2];
  LayerStack[3] = ps_hid_export_to_file::saved_layer_stack[3];
  LayerStack[4] = ps_hid_export_to_file::saved_layer_stack[4];
  LayerStack[5] = ps_hid_export_to_file::saved_layer_stack[5];
  LayerStack[6] = ps_hid_export_to_file::saved_layer_stack[6];
  LayerStack[7] = ps_hid_export_to_file::saved_layer_stack[7];
  LayerStack[8] = ps_hid_export_to_file::saved_layer_stack[8];
  LayerStack[9] = ps_hid_export_to_file::saved_layer_stack[9];
  LayerStack[10] = ps_hid_export_to_file::saved_layer_stack[10];
  LayerStack[11] = ps_hid_export_to_file::saved_layer_stack[11];
  LayerStack[12] = ps_hid_export_to_file::saved_layer_stack[12];
  LayerStack[13] = ps_hid_export_to_file::saved_layer_stack[13];
  LayerStack[14] = ps_hid_export_to_file::saved_layer_stack[14];
  LayerStack[15] = ps_hid_export_to_file::saved_layer_stack[15];
  (PCB->Flags).t[7] = uVar2;
  (pPVar17->Flags).t[6] = uVar3;
  (pPVar17->Flags).t[5] = uVar4;
  (pPVar17->Flags).t[4] = uVar5;
  (pPVar17->Flags).t[3] = uVar6;
  (pPVar17->Flags).t[2] = uVar7;
  (pPVar17->Flags).t[1] = uVar8;
  (pPVar17->Flags).t[0] = uVar9;
  (pPVar17->Flags).f = uVar10;
  return;
}



// WARNING: Unknown calling convention

void ps_do_export(HID_Attr_Val *options)

{
  double *pdVar1;
  int iVar2;
  HID_Attr_Val *pHVar3;
  int save_ons [18];
  
  if (options == (HID_Attr_Val *)0x0) {
    ps_get_export_options((int *)0x0);
    pHVar3 = &ps_attribute_list[0].default_val;
    iVar2 = 0;
    do {
      *(int *)((int)&ps_values[0].int_value + iVar2) = pHVar3->int_value;
      *(char **)((int)&ps_values[0].str_value + iVar2) = pHVar3->str_value;
      *(undefined4 *)((int)&ps_values[0].real_value + iVar2) = *(undefined4 *)&pHVar3->real_value;
      pdVar1 = &pHVar3->real_value;
      pHVar3 = pHVar3 + 3;
      *(undefined4 *)((int)&ps_values[0].real_value + iVar2 + 4) = *(undefined4 *)((int)pdVar1 + 4);
      iVar2 = iVar2 + 0x10;
    } while (iVar2 != 0x120);
    options = ps_values;
  }
  filename = "pcb-out.ps";
  if (options->str_value != (char *)0x0) {
    filename = options->str_value;
  }
  multi_file = options[0xd].int_value;
  if (multi_file == 0) {
    f = psopen(filename,"toc");
    if (f == (FILE *)0x0) {
      perror(filename);
      return;
    }
    ps_start_file(f);
  }
  else {
    f = (FILE *)0x0;
  }
  hid_save_and_show_layer_ons(save_ons);
  ps_hid_export_to_file(f,options);
  hid_restore_layer_ons(save_ons);
  multi_file = 0;
  if (f != (FILE *)0x0) {
    fclose((FILE *)f);
  }
  return;
}



// WARNING: Unknown calling convention

void eps_set_line_cap(hidGC_conflict6 gc,EndCapStyle style)

{
  gc->cap = style;
  return;
}



// WARNING: Unknown calling convention

void eps_set_line_width(hidGC_conflict6 gc,int width)

{
  gc->width = width;
  return;
}



// WARNING: Unknown calling convention

void eps_set_draw_xor(hidGC_conflict6 gc,int xor)

{
  return;
}



// WARNING: Unknown calling convention

void eps_set_draw_faded(hidGC_conflict6 gc,int faded)

{
  return;
}



// WARNING: Unknown calling convention

void eps_set_crosshair(int x,int y,int action)

{
  return;
}



// WARNING: Unknown calling convention

void hid_eps_init(void)

{
  apply_default_hid((HID *)&eps_hid,(HID *)0x0);
  hid_register_hid((HID *)&eps_hid);
  return;
}



// WARNING: Unknown calling convention

void eps_calibrate(double xval,double yval)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented EPS function %s.\n","eps_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void use_gc(hidGC_conflict6 gc)

{
  EndCapStyle EVar1;
  uint uVar2;
  undefined4 uVar3;
  int c;
  
  if (gc->width != linewidth) {
    __fprintf_chk(f,1,"%d setlinewidth\n",gc->width);
    linewidth = gc->width;
  }
  EVar1 = gc->cap;
  if (lastcap != EVar1) {
    uVar3 = 2;
    if (EVar1 < Beveled_Cap) {
      uVar3 = *(undefined4 *)(CSWTCH_106 + EVar1 * 4);
    }
    __fprintf_chk(f,1,"%d setlinecap\n",uVar3);
    lastcap = gc->cap;
  }
  uVar2 = gc->color;
  if (uVar2 != lastcolor) {
    __fprintf_chk(f,1,"%g %g %g setrgbcolor\n",(double)((float)((int)uVar2 >> 0x10 & 0xff) / 255.0),
                  (double)((float)(uVar2 >> 8 & 0xff) / 255.0),
                  (double)((float)(uVar2 & 0xff) / 255.0));
    lastcolor = gc->color;
  }
  return;
}



// WARNING: Unknown calling convention

void eps_fill_rect(hidGC_conflict6 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1,y1,x2,y2);
  return;
}



// WARNING: Unknown calling convention

void eps_fill_polygon(hidGC_conflict6 gc,int n_coords,int *x,int *y)

{
  int *piVar1;
  int *piVar2;
  char *pcVar3;
  char *op;
  int i;
  
  use_gc(gc);
  if (0 < n_coords) {
    pcVar3 = "moveto";
    i = 0;
    do {
      piVar1 = y + i;
      piVar2 = x + i;
      i = i + 1;
      __fprintf_chk(f,1,"%d %d %s\n",*piVar2,*piVar1,pcVar3);
      pcVar3 = "lineto";
    } while (i < n_coords);
  }
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention

void eps_fill_circle(hidGC_conflict6 gc,int cx,int cy,int radius)

{
  undefined *puVar1;
  
  use_gc(gc);
  puVar1 = &DAT_0814df8d;
  if (gc->erase != 0) {
    puVar1 = &DAT_081489c6;
  }
  __fprintf_chk(f,1,"%d %d %d %s\n",cx,cy,radius,puVar1);
  return;
}



// WARNING: Unknown calling convention

void eps_draw_rect(hidGC_conflict6 gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1,y1,x2,y2);
  return;
}



// WARNING: Unknown calling convention

void eps_draw_arc(hidGC_conflict6 gc,int cx,int cy,int width,int height,int start_angle,
                 int delta_angle)

{
  int sa;
  int ea;
  
  if (delta_angle < 1) {
    sa = delta_angle + start_angle;
  }
  else {
    sa = start_angle;
    start_angle = delta_angle + start_angle;
  }
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d %d %d %g a\n",sa,start_angle,-width,height,cx,cy,
                (double)linewidth / (double)width);
  return;
}



// WARNING: Unknown calling convention

void eps_set_line_cap_angle(hidGC_conflict6 gc,int x1,int y1,int x2,int y2)

{
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented EPS function %s.\n",
                "eps_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void eps_use_mask(int use_it)

{
  if (use_it == 0) {
    if (eps_use_mask::mask_pending != 0) {
      eps_use_mask::mask_pending = 0;
      __fprintf_chk(f,1,"grestore\n");
      lastcolor = -1;
      return;
    }
  }
  else if ((use_it == 2) && (eps_use_mask::mask_pending == 0)) {
    eps_use_mask::mask_pending = 1;
    __fprintf_chk(f,1,"gsave\n");
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void eps_draw_line(hidGC_conflict6 gc,int x1,int y1,int x2,int y2)

{
  float fVar1;
  float fVar2;
  undefined *puVar3;
  int radius;
  double ang;
  double dVar4;
  double local_2c;
  double local_24 [2];
  
  radius = gc->width / 2;
  if ((y1 == y2) && (x1 == x2)) {
    if (gc->cap != Square_Cap) {
      eps_fill_circle(gc,x1,y1,radius);
      return;
    }
    eps_fill_rect(gc,x1 - radius,y1 - radius,radius + x1,radius + y1);
    return;
  }
  use_gc(gc);
  puVar3 = &DAT_081515af;
  if ((gc->erase != 0) && (puVar3 = &DAT_0815f4eb, gc->cap != Square_Cap)) {
    dVar4 = atan2((double)(y2 - y1),(double)(x2 - x1));
    sincos(dVar4,local_24,&local_2c);
    dVar4 = (dVar4 * 180.0) / 3.141592653589793;
    __fprintf_chk(f,1,"%d %d moveto ",(int)ROUND((double)radius * local_24[0] + (double)x1),
                  (int)ROUND((double)-radius * local_2c + (double)y1));
    fVar2 = (float)dVar4;
    fVar1 = fVar2 + 90.0;
    __fprintf_chk(f,1,"%d %d %d %g %g arc\n",x2,y2,radius,(double)(fVar2 - 90.0),(double)fVar1);
    __fprintf_chk(f,1,"%d %d %d %g %g arc\n",x1,y1,radius,(double)fVar1,dVar4 + 270.0);
    __fprintf_chk();
    return;
  }
  __fprintf_chk(f,1,"%d %d %d %d %s\n",x1,y1,x2,y2,puVar3);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int eps_set_layer(char *name,int group,int empty)

{
  Cardinal CVar1;
  int iVar2;
  uint uVar3;
  int idx;
  Cardinal CVar4;
  char *pcVar5;
  undefined4 uVar6;
  char *pcVar7;
  bool bVar8;
  
  if ((group < 0) || (PCB->Data->LayerN <= group)) {
    CVar4 = group;
    if (name != (char *)0x0) goto LAB_08118678;
LAB_08118795:
    name = PCB->Data->Layer[CVar4].Name;
    if ((int)CVar4 < 0) goto LAB_081187b8;
LAB_08118680:
    CVar1 = PCB->Data->LayerN;
    bVar8 = CVar4 == CVar1;
    if ((int)CVar1 <= (int)CVar4) goto LAB_081186a0;
    bVar8 = print_layer[CVar4] == 0;
  }
  else {
    CVar4 = (PCB->LayerGroups).Entries[group][0];
    if (name == (char *)0x0) goto LAB_08118795;
LAB_08118678:
    if (-1 < (int)CVar4) goto LAB_08118680;
LAB_081187b8:
    if ((CVar4 & 0xf0) == 0x70) {
      return 0;
    }
    bVar8 = (CVar4 & 0xf0) == 0x80;
  }
  if (bVar8) {
    return 0;
  }
LAB_081186a0:
  iVar2 = 10;
  pcVar5 = name;
  pcVar7 = "invisible";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar8 = *pcVar5 == *pcVar7;
    pcVar5 = pcVar5 + 1;
    pcVar7 = pcVar7 + 1;
  } while (bVar8);
  if (!bVar8) {
    if ((int)CVar4 < 0) {
      uVar3 = CVar4 & 0xf0;
      if ((uVar3 == 0x40) || (uVar3 == 0x30)) {
        is_drill = 1;
        uVar6 = 1;
      }
      else {
        is_drill = 0;
        uVar6 = 0;
      }
      if (uVar3 == 0x20) {
        is_mask = 1;
        bVar8 = true;
      }
      else {
        is_mask = 0;
        if (uVar3 == 0x50) {
          is_mask = 0;
          is_paste = 1;
          return 0;
        }
        bVar8 = false;
      }
    }
    else {
      is_drill = 0;
      bVar8 = false;
      uVar6 = 0;
      is_mask = 0;
    }
    is_paste = 0;
    if (!bVar8) {
      __fprintf_chk(f,1,"%% Layer %s group %d drill %d mask %d\n",name,group,uVar6,0);
      if (as_shown == 0) {
        if (CVar4 + 0xfef < 2) {
          return *(int *)((int)&CSWTCH_109 + (CVar4 + 0xfef) * 4);
        }
      }
      else if (CVar4 + 0xfef < 2) {
        if ((bool)(((byte)(CVar4 >> 1) ^ 1) & 1) == (Settings.ShowSolderSide != '\0')) {
          return 0;
        }
        return (int)PCB->ElementOn;
      }
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void eps_set_color(hidGC_conflict6 gc,char *name)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  bool bVar4;
  int local_2c;
  int local_28;
  int local_24;
  hidval cval;
  
  iVar1 = 6;
  bVar4 = &stack0x00000000 == (undefined *)0x5c;
  pcVar2 = name;
  pcVar3 = "erase";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *pcVar2 == *pcVar3;
    pcVar2 = pcVar2 + 1;
    pcVar3 = pcVar3 + 1;
  } while (bVar4);
  if (bVar4) {
    bVar4 = fast_erase == 0;
    gc->color = 0xffffff;
    gc->erase = (uint)bVar4;
  }
  else {
    iVar1 = 6;
    pcVar2 = name;
    pcVar3 = "drill";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      bVar4 = *pcVar2 == *pcVar3;
      pcVar2 = pcVar2 + 1;
      pcVar3 = pcVar3 + 1;
    } while (bVar4);
    if (bVar4) {
      gc->color = 0xffffff;
      gc->erase = 0;
    }
    else {
      gc->erase = 0;
      iVar1 = hid_cache_color(0,name,&cval,&eps_set_color::cache);
      if (iVar1 == 0) {
        if ((in_mono == 0) && (*name == '#')) {
          sscanf(name + 1,"%2x%2x%2x");
          gc->color = local_24 * 0x10000 + local_28 * 0x100 + local_2c;
        }
        else {
          gc->color = 0;
        }
      }
      else {
        gc->color = (int)cval;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void eps_destroy_gc(hidGC_conflict6 gc)

{
  free(gc);
  return;
}



// WARNING: Unknown calling convention

hidGC_conflict6 eps_make_gc(void)

{
  hidGC_conflict6 phVar1;
  
  phVar1 = (hidGC_conflict6)calloc(1,0x10);
  phVar1->cap = Trace_Cap;
  phVar1->width = 0;
  phVar1->color = 0;
  return phVar1;
}



// WARNING: Unknown calling convention

void register_eps_attribute_list(void)

{
  hid_register_attributes(eps_attribute_list,5);
  return;
}



// WARNING: Unknown calling convention

void eps_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes(eps_attribute_list,5);
  hid_parse_command_line(argc,argv);
  return;
}



// WARNING: Unknown calling convention

HID_Attribute * eps_get_export_options(int *n)

{
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,eps_attribute_list,".eps",&eps_get_export_options::last_made_filename);
  }
  if (n != (int *)0x0) {
    *n = 5;
  }
  return eps_attribute_list;
}



// WARNING: Unknown calling convention

int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int bl;
  int d;
  int iVar1;
  int bside;
  int iVar2;
  int aside;
  int a;
  int b;
  int al;
  
                    // WARNING: Load size is inaccurate
  Layer = *va;
                    // WARNING: Load size is inaccurate
  Layer_00 = *vb;
  iVar1 = PCB->Data->LayerN;
  iVar2 = iVar1 + 1;
  if (((int)Layer < 0) || (iVar2 < (int)Layer)) {
    al = iVar1 + 3 + Layer;
  }
  else {
    al = GetLayerGroupNumberByNumber(Layer);
    iVar1 = PCB->Data->LayerN;
    iVar2 = iVar1 + 1;
  }
  if ((iVar2 < (int)Layer_00) || ((int)Layer_00 < 0)) {
    bl = iVar1 + 3 + Layer_00;
  }
  else {
    bl = GetLayerGroupNumberByNumber(Layer_00);
  }
  if ((-1 < (int)Layer) && ((int)Layer <= PCB->Data->LayerN + 1)) {
    iVar2 = 0;
    if (solder_layer != al) {
      iVar2 = (comp_layer == al) + 1;
    }
    iVar1 = 0;
    if (solder_layer != bl) {
      iVar1 = (comp_layer == bl) + 1;
    }
    if (iVar2 != iVar1) {
      d = iVar1 - iVar2;
      return d;
    }
  }
  iVar2 = bl - al;
  if (bl - al == 0) {
    iVar2 = Layer_00 - Layer;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void eps_hid_export_to_file(FILE *the_file,HID_Attr_Val *options)

{
  uchar uVar1;
  uchar uVar2;
  uchar uVar3;
  uchar uVar4;
  uchar uVar5;
  uchar uVar6;
  uchar uVar7;
  uchar uVar8;
  uint uVar9;
  DataTypePtr paVar10;
  int iVar11;
  int iVar12;
  PCBTypePtr pPVar13;
  int iVar14;
  int iVar15;
  int i;
  Cardinal Layer;
  int *piVar16;
  byte bVar17;
  BoxType region;
  
  pPVar13 = PCB;
  bVar17 = 0;
  uVar1 = (PCB->Flags).t[7];
  uVar2 = (PCB->Flags).t[6];
  uVar3 = (PCB->Flags).t[5];
  uVar4 = (PCB->Flags).t[4];
  uVar5 = (PCB->Flags).t[3];
  uVar6 = (PCB->Flags).t[2];
  uVar7 = (PCB->Flags).t[1];
  uVar8 = (PCB->Flags).t[0];
  region.X1 = 0;
  region.Y1 = 0;
  uVar9 = (PCB->Flags).f;
  (PCB->Flags).f = uVar9 & 0xfffdbfff;
  f = the_file;
  region.X2 = pPVar13->MaxWidth;
  region.Y2 = pPVar13->MaxHeight;
  if (options[4].int_value == 0) {
    bounds = &region;
  }
  else {
    bounds = GetDataBoundingBox(pPVar13->Data);
    pPVar13 = PCB;
  }
  piVar16 = print_group;
  for (iVar12 = 0x10; iVar12 != 0; iVar12 = iVar12 + -1) {
    *piVar16 = 0;
    piVar16 = piVar16 + (uint)bVar17 * -2 + 1;
  }
  piVar16 = print_layer;
  for (iVar12 = 0x10; iVar12 != 0; iVar12 = iVar12 + -1) {
    *piVar16 = 0;
    piVar16 = piVar16 + (uint)bVar17 * -2 + 1;
  }
  paVar10 = pPVar13->Data;
  iVar12 = paVar10->LayerN;
  if (iVar12 < 1) {
    fast_erase = 0;
  }
  else {
    i = 0;
    do {
      if ((paVar10->Layer[i].On != '\0') &&
         ((((paVar10->Layer[i].LineN != 0 || (paVar10->Layer[i].TextN != 0)) ||
           (paVar10->Layer[i].ArcN != 0)) || (paVar10->Layer[i].PolygonN != 0)))) {
        iVar12 = GetLayerGroupNumberByNumber(i);
        pPVar13 = PCB;
        print_group[iVar12] = 1;
      }
      paVar10 = pPVar13->Data;
      i = i + 1;
      iVar12 = paVar10->LayerN;
    } while (i < iVar12);
    fast_erase = 0;
    if (0 < iVar12) {
      fast_erase = 0;
      iVar11 = 0;
      while( true ) {
        if (print_group[iVar11] != 0) {
          fast_erase = fast_erase + 1;
        }
        if (iVar11 + 1 == iVar12) break;
        iVar11 = iVar11 + 1;
      }
      if (fast_erase != 0) {
        fast_erase = (int)(fast_erase == 1);
        goto LAB_08118ce7;
      }
    }
  }
  iVar12 = GetLayerGroupNumberByNumber(iVar12 + 1);
  pPVar13 = PCB;
  print_group[iVar12] = 1;
  iVar12 = pPVar13->Data->LayerN;
  fast_erase = 1;
LAB_08118ce7:
  if (0 < iVar12) {
    Layer = 0;
    do {
      iVar12 = GetLayerGroupNumberByNumber(Layer);
      if (print_group[iVar12] != 0) {
        print_layer[Layer] = 1;
      }
      Layer = Layer + 1;
      piVar16 = &PCB->Data->LayerN;
      pPVar13 = PCB;
    } while (*piVar16 != Layer && (int)Layer <= *piVar16);
  }
  if (fast_erase == 0) {
    eps_hid._12_1_ = eps_hid._12_1_ & 0xf7 | 0x10;
  }
  else {
    eps_hid._12_1_ = eps_hid._12_1_ & 0xef | 8;
  }
  eps_hid_export_to_file::saved_layer_stack[0] = LayerStack[0];
  eps_hid_export_to_file::saved_layer_stack[1] = LayerStack[1];
  eps_hid_export_to_file::saved_layer_stack[2] = LayerStack[2];
  eps_hid_export_to_file::saved_layer_stack[3] = LayerStack[3];
  eps_hid_export_to_file::saved_layer_stack[4] = LayerStack[4];
  eps_hid_export_to_file::saved_layer_stack[5] = LayerStack[5];
  eps_hid_export_to_file::saved_layer_stack[6] = LayerStack[6];
  eps_hid_export_to_file::saved_layer_stack[7] = LayerStack[7];
  eps_hid_export_to_file::saved_layer_stack[8] = LayerStack[8];
  eps_hid_export_to_file::saved_layer_stack[9] = LayerStack[9];
  eps_hid_export_to_file::saved_layer_stack[10] = LayerStack[10];
  eps_hid_export_to_file::saved_layer_stack[11] = LayerStack[11];
  eps_hid_export_to_file::saved_layer_stack[12] = LayerStack[12];
  eps_hid_export_to_file::saved_layer_stack[13] = LayerStack[13];
  eps_hid_export_to_file::saved_layer_stack[14] = LayerStack[14];
  eps_hid_export_to_file::saved_layer_stack[15] = LayerStack[15];
  as_shown = options[2].int_value;
  if (options[2].int_value == 0) {
    comp_layer = GetLayerGroupNumberByNumber(pPVar13->Data->LayerN + 1);
    solder_layer = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    qsort(LayerStack,PCB->Data->LayerN,4,layer_sort);
  }
  __fprintf_chk(f,1,"%%!PS-Adobe-3.0 EPSF-3.0\n");
  in_mono = options[3].int_value;
  linewidth = -1;
  lastcap = -1;
  lastgroup = -1;
  lastcolor = -1;
  __fprintf_chk(f,1,"%%%%BoundingBox: 0 0 %d %d\n",
                (int)ROUND((100000.0 / (double)(bounds->X2 - bounds->X1)) * 72.0 *
                           options[1].real_value + 1.0),
                (int)ROUND(((double)(bounds->Y2 - bounds->Y1) / 100000.0) * 72.0 *
                           options[1].real_value + 1.0));
  __fprintf_chk(f,1,"%%%%Pages: 1\n");
  __fprintf_chk(f,1,"save countdictstack mark newpath /showpage {} def /setpagedevice {pop} def\n");
  __fprintf_chk(f,1,"%%%%EndProlog\n");
  __fprintf_chk(f,1,"%%%%Page: 1 1\n");
  __fprintf_chk(f,1,"%%%%BeginDocument: %s\n\n",filename);
  __fprintf_chk(f,1,"72 72 scale\n");
  __fprintf_chk(f,1,"0.00001 dup neg scale\n");
  __fprintf_chk(f,1,"%g dup scale\n",options[1].real_value);
  __fprintf_chk(f,1,"%d %d translate\n",-bounds->X1,-bounds->Y2);
  if ((options[2].int_value != 0) && (Settings.ShowSolderSide != '\0')) {
    __fprintf_chk(f,1,"-1 1 scale %d 0 translate\n",bounds->X1 - bounds->X2);
  }
  linewidth = -1;
  lastcap = -1;
  lastcolor = -1;
  iVar15 = bounds->X2 + 1000;
  iVar11 = bounds->Y2 + 1000;
  iVar14 = bounds->Y1 + -1000;
  iVar12 = bounds->X1 + -1000;
  __fprintf_chk(f,1,
                "/nclip { %d %d moveto %d %d lineto %d %d lineto %d %d lineto %d %d lineto eoclip newpath } def\n"
                ,iVar12,iVar14,iVar12,iVar11,iVar15,iVar11,iVar15,iVar14,iVar12,iVar14);
  __fprintf_chk(f,1,"/t { moveto lineto stroke } bind def\n");
  __fprintf_chk(f,1,"/tc { moveto lineto strokepath nclip } bind def\n");
  __fprintf_chk(f,1,"/r { /y2 exch def /x2 exch def /y1 exch def /x1 exch def\n");
  __fprintf_chk(f,1,
                "     x1 y1 moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto closepath fill } bind def\n"
               );
  __fprintf_chk(f,1,"/c { 0 360 arc fill } bind def\n");
  __fprintf_chk(f,1,"/cc { 0 360 arc nclip } bind def\n");
  __fprintf_chk(f,1,
                "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n"
               );
  lastgroup = -1;
  hid_expose_callback((HID *)&eps_hid,bounds,(void *)0x0);
  __fprintf_chk(f,1,"showpage\n");
  __fprintf_chk(f,1,"%%%%EndDocument\n");
  __fprintf_chk(f,1,"%%%%Trailer\n");
  __fprintf_chk(f,1,"cleartomark countdictstack exch sub { end } repeat restore\n");
  __fprintf_chk(f,1,"%%%%EOF\n");
  pPVar13 = PCB;
  LayerStack[0] = eps_hid_export_to_file::saved_layer_stack[0];
  LayerStack[1] = eps_hid_export_to_file::saved_layer_stack[1];
  LayerStack[2] = eps_hid_export_to_file::saved_layer_stack[2];
  LayerStack[3] = eps_hid_export_to_file::saved_layer_stack[3];
  LayerStack[4] = eps_hid_export_to_file::saved_layer_stack[4];
  LayerStack[5] = eps_hid_export_to_file::saved_layer_stack[5];
  LayerStack[6] = eps_hid_export_to_file::saved_layer_stack[6];
  LayerStack[7] = eps_hid_export_to_file::saved_layer_stack[7];
  LayerStack[8] = eps_hid_export_to_file::saved_layer_stack[8];
  LayerStack[9] = eps_hid_export_to_file::saved_layer_stack[9];
  LayerStack[10] = eps_hid_export_to_file::saved_layer_stack[10];
  LayerStack[11] = eps_hid_export_to_file::saved_layer_stack[11];
  LayerStack[12] = eps_hid_export_to_file::saved_layer_stack[12];
  LayerStack[13] = eps_hid_export_to_file::saved_layer_stack[13];
  LayerStack[14] = eps_hid_export_to_file::saved_layer_stack[14];
  LayerStack[15] = eps_hid_export_to_file::saved_layer_stack[15];
  (PCB->Flags).t[7] = uVar1;
  (pPVar13->Flags).t[6] = uVar2;
  (pPVar13->Flags).t[5] = uVar3;
  (pPVar13->Flags).t[4] = uVar4;
  (pPVar13->Flags).t[3] = uVar5;
  (pPVar13->Flags).t[2] = uVar6;
  (pPVar13->Flags).t[1] = uVar7;
  (pPVar13->Flags).t[0] = uVar8;
  (pPVar13->Flags).f = uVar9;
  return;
}



// WARNING: Unknown calling convention

void eps_do_export(HID_Attr_Val *options)

{
  double *pdVar1;
  int iVar2;
  HID_Attr_Val *pHVar3;
  int save_ons [18];
  
  if (options == (HID_Attr_Val *)0x0) {
    eps_get_export_options((int *)0x0);
    pHVar3 = &eps_attribute_list[0].default_val;
    iVar2 = 0;
    do {
      *(int *)((int)&eps_values[0].int_value + iVar2) = pHVar3->int_value;
      *(char **)((int)&eps_values[0].str_value + iVar2) = pHVar3->str_value;
      *(undefined4 *)((int)&eps_values[0].real_value + iVar2) = *(undefined4 *)&pHVar3->real_value;
      pdVar1 = &pHVar3->real_value;
      pHVar3 = pHVar3 + 3;
      *(undefined4 *)((int)&eps_values[0].real_value + iVar2 + 4) = *(undefined4 *)((int)pdVar1 + 4)
      ;
      iVar2 = iVar2 + 0x10;
    } while (iVar2 != 0x50);
    options = eps_values;
  }
  filename = options->str_value;
  if (filename == (char *)0x0) {
    filename = "pcb-out.eps";
  }
  f = (FILE *)fopen(filename,"w");
  if (f == (FILE *)0x0) {
    perror(filename);
  }
  else {
    if (options[2].int_value == 0) {
      hid_save_and_show_layer_ons(save_ons);
    }
    eps_hid_export_to_file(f,options);
    if (options[2].int_value == 0) {
      hid_restore_layer_ons(save_ons);
    }
    fclose((FILE *)f);
  }
  return;
}



// WARNING: Unknown calling convention

void gts_object_class_init(GtsObjectClass *klass,GtsObjectClass *parent_class)

{
  GtsObjectClassInitFunc p_Var1;
  
  if (parent_class != (GtsObjectClass *)0x0) {
    gts_object_class_init(klass,parent_class->parent_class);
    p_Var1 = (parent_class->info).class_init_func;
    if (p_Var1 != (GtsObjectClassInitFunc)0x0) {
      (*p_Var1)(klass);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void object_class_init(GtsObjectClass *klass)

{
  klass->clone = object_clone;
  klass->destroy = object_destroy;
  klass->read = (_func_void_GtsObject_ptr_ptr_GtsFile_ptr *)0x0;
  klass->write = (_func_void_GtsObject_ptr_FILE_ptr *)0x0;
  klass->color = (_func_GtsColor_GtsObject_ptr *)0x0;
  klass->attributes = (_func_void_GtsObject_ptr_GtsObject_ptr *)0x0;
  return;
}



// WARNING: Unknown calling convention

void object_init(GtsObject *object)

{
  object->reserved = (gpointer)0x0;
  object->flags = 0;
  return;
}



// WARNING: Unknown calling convention

void gts_finalize(void)

{
  if (class_table != (GHashTable *)0x0) {
    g_hash_table_foreach(class_table,free_class,0);
    g_hash_table_destroy(class_table);
    class_table = (GHashTable *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void free_class(gchar *name,GtsObjectClass *klass)

{
  g_free();
  return;
}



// WARNING: Unknown calling convention

void object_destroy(GtsObject *object)

{
  object->klass = (GtsObjectClass *)0x0;
  g_free();
  return;
}



// WARNING: Unknown calling convention

void gts_object_attributes(GtsObject *object,GtsObject *from)

{
  _func_void_GtsObject_ptr_GtsObject_ptr *UNRECOVERED_JUMPTABLE;
  
  if (object == (GtsObject *)0x0) {
    g_return_if_fail_warning(0,"gts_object_attributes","object != NULL");
  }
  else {
    UNRECOVERED_JUMPTABLE = object->klass->attributes;
    if (UNRECOVERED_JUMPTABLE != (_func_void_GtsObject_ptr_GtsObject_ptr *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08119687. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)(object,from);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void gts_object_reset_reserved(GtsObject *object)

{
  if (object != (GtsObject *)0x0) {
    object->reserved = (gpointer)0x0;
    return;
  }
  g_return_if_fail_warning(0,"gts_object_reset_reserved","object != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_object_init(GtsObject *object,GtsObjectClass *klass)

{
  GtsObjectInitFunc UNRECOVERED_JUMPTABLE;
  GtsObjectClass *parent_class;
  
  if (object == (GtsObject *)0x0) {
    g_return_if_fail_warning(0,"gts_object_init","object != NULL");
    return;
  }
  if (klass == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_init","klass != NULL");
  }
  else {
    if (klass->parent_class != (GtsObjectClass *)0x0) {
      gts_object_init(object,klass->parent_class);
    }
    UNRECOVERED_JUMPTABLE = (klass->info).object_init_func;
    if (UNRECOVERED_JUMPTABLE != (GtsObjectInitFunc)0x0) {
                    // WARNING: Could not recover jumptable at 0x08119730. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)(object);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void gts_object_destroy(GtsObject *object)

{
  if (object->klass->destroy != (_func_void_GtsObject_ptr *)0x0) {
    object->flags = object->flags | 1;
                    // WARNING: Could not recover jumptable at 0x081197aa. Too many branches
                    // WARNING: Treating indirect jump as call
    (*object->klass->destroy)(object);
    return;
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr
            (0,"../../src/gts/object.c",0x126,"gts_object_destroy","object->klass->destroy");
}



// WARNING: Unknown calling convention

GtsObject * gts_object_clone(GtsObject *object)

{
  GtsObjectClass *pGVar1;
  GtsObject *pGVar2;
  GtsObject *clone;
  
  if (object == (GtsObject *)0x0) {
    g_return_if_fail_warning(0,"gts_object_clone","object != NULL");
    return (GtsObject *)0x0;
  }
  if (object->klass->clone != (_func_void_GtsObject_ptr_GtsObject_ptr *)0x0) {
    pGVar2 = (GtsObject *)g_malloc0((object->klass->info).object_size);
    pGVar1 = object->klass;
    pGVar2->reserved = (gpointer)0x0;
    pGVar2->flags = 0;
    pGVar2->klass = pGVar1;
    (*object->klass->clone)(pGVar2,object);
    return pGVar2;
  }
  g_return_if_fail_warning(0,"gts_object_clone","object->klass->clone");
  return (GtsObject *)0x0;
}



// WARNING: Unknown calling convention

GtsObject * gts_object_new(GtsObjectClass *klass)

{
  GtsObject *object_00;
  GtsObject *object;
  
  if (klass != (GtsObjectClass *)0x0) {
    object_00 = (GtsObject *)g_malloc0((klass->info).object_size);
    object_00->klass = klass;
    gts_object_init(object_00,klass);
    return object_00;
  }
  g_return_if_fail_warning(0,"gts_object_new","klass != NULL");
  return (GtsObject *)0x0;
}



// WARNING: Unknown calling convention

gpointer gts_object_class_check_cast(gpointer klass,gpointer from)

{
  GtsObjectClass *c;
  gpointer pvVar1;
  
  if (klass == (gpointer)0x0) {
    g_log(0,0x10,"invalid cast from (NULL) pointer to `%s\'",from);
  }
  else if (from == (gpointer)0x0) {
    g_return_if_fail_warning(0,"gts_object_class_is_from_class","from != NULL");
LAB_08119943:
    g_log(0,0x10,"invalid cast from `%s\' to `%s\'",klass,from);
  }
  else {
    pvVar1 = klass;
    if (from != klass) {
      do {
        pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
        if (pvVar1 == (gpointer)0x0) goto LAB_08119943;
      } while (from != pvVar1);
    }
  }
  return klass;
}



// WARNING: Unknown calling convention

gpointer gts_object_check_cast(gpointer object,gpointer klass)

{
  gpointer pvVar1;
  GtsObjectClass *c;
  gpointer pvVar2;
  char *pcVar3;
  
  if (object == (gpointer)0x0) {
    pcVar3 = "invalid cast from (NULL) pointer to `%s\'";
  }
  else {
                    // WARNING: Load size is inaccurate
    pvVar2 = *object;
    if (pvVar2 != (gpointer)0x0) {
      pvVar1 = pvVar2;
      if (klass == (gpointer)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                    // WARNING: Load size is inaccurate
        pvVar2 = *object;
      }
      else {
        do {
          if (klass == pvVar1) {
            return object;
          }
          pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
        } while (pvVar1 != (gpointer)0x0);
      }
      g_log(0,0x10,"invalid cast from `%s\' to `%s\'",pvVar2,klass);
      return object;
    }
    pcVar3 = "invalid unclassed pointer in cast to `%s\'";
  }
  g_log(0,0x10,pcVar3,klass);
  return object;
}



// WARNING: Unknown calling convention

void object_clone(GtsObject *clone,GtsObject *object)

{
  memcpy(clone,object,(object->klass->info).object_size);
  clone->reserved = (gpointer)0x0;
  return;
}



// WARNING: Unknown calling convention

GtsObjectClass * gts_object_class_from_name(gchar *name)

{
  GtsObjectClass *pGVar1;
  
  if (name != (gchar *)0x0) {
    pGVar1 = (GtsObjectClass *)0x0;
    if (class_table != (GHashTable *)0x0) {
      pGVar1 = (GtsObjectClass *)g_hash_table_lookup(class_table,name);
    }
    return pGVar1;
  }
  g_return_if_fail_warning(0,"gts_object_class_from_name","name != NULL");
  return (GtsObjectClass *)0x0;
}



// WARNING: Unknown calling convention

gpointer gts_object_class_new(GtsObjectClass *parent_class,GtsObjectClassInfo *info)

{
  GtsArgGetFunc p_Var1;
  uint uVar2;
  GtsObjectClass *klass;
  
  if (info == (GtsObjectClassInfo *)0x0) {
    g_return_if_fail_warning(0,"gts_object_class_new","info != NULL");
    return (gpointer)0x0;
  }
  if (parent_class == (GtsObjectClass *)0x0) {
    uVar2 = info->class_size;
  }
  else {
    if (info->object_size < (parent_class->info).object_size) {
      g_return_if_fail_warning
                (0,"gts_object_class_new",
                 "parent_class == NULL || info->object_size >= parent_class->info.object_size");
      return (gpointer)0x0;
    }
    uVar2 = info->class_size;
    if (uVar2 < (parent_class->info).class_size) {
      g_return_if_fail_warning
                (0,"gts_object_class_new",
                 "parent_class == NULL || info->class_size >= parent_class->info.class_size");
      return (gpointer)0x0;
    }
  }
  klass = (GtsObjectClass *)g_malloc0(uVar2);
  *(undefined4 *)(klass->info).name = *(undefined4 *)info->name;
  *(undefined4 *)((klass->info).name + 4) = *(undefined4 *)(info->name + 4);
  *(undefined4 *)((klass->info).name + 8) = *(undefined4 *)(info->name + 8);
  *(undefined4 *)((klass->info).name + 0xc) = *(undefined4 *)(info->name + 0xc);
  *(undefined4 *)((klass->info).name + 0x10) = *(undefined4 *)(info->name + 0x10);
  *(undefined4 *)((klass->info).name + 0x14) = *(undefined4 *)(info->name + 0x14);
  *(undefined4 *)((klass->info).name + 0x18) = *(undefined4 *)(info->name + 0x18);
  *(undefined4 *)((klass->info).name + 0x1c) = *(undefined4 *)(info->name + 0x1c);
  *(undefined4 *)((klass->info).name + 0x20) = *(undefined4 *)(info->name + 0x20);
  *(undefined4 *)((klass->info).name + 0x24) = *(undefined4 *)(info->name + 0x24);
  (klass->info).object_size = info->object_size;
  (klass->info).class_size = info->class_size;
  (klass->info).class_init_func = info->class_init_func;
  (klass->info).object_init_func = info->object_init_func;
  (klass->info).arg_set_func = info->arg_set_func;
  p_Var1 = info->arg_get_func;
  klass->parent_class = parent_class;
  (klass->info).arg_get_func = p_Var1;
  gts_object_class_init(klass,klass);
  if (class_table == (GHashTable *)0x0) {
    class_table = (GHashTable *)g_hash_table_new(g_str_hash,g_str_equal);
  }
  g_hash_table_insert(class_table,klass,klass);
  return klass;
}



// WARNING: Unknown calling convention

GtsObjectClass * gts_object_class(void)

{
  uint uVar1;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo object_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_object_class::klass == (GtsObjectClass *)0x0) {
    pGVar3 = &object_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    object_info.name[0] = 'G';
    object_info.name[1] = 't';
    object_info.name[2] = 's';
    object_info.name[3] = 'O';
    object_info.name[4] = 'b';
    object_info.name[5] = 'j';
    object_info.name[6] = 'e';
    object_info.name[7] = 'c';
    object_info.name[8] = 't';
    object_info.name[9] = '\0';
    object_info.name[10] = '\0';
    object_info.name[11] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(object_info.name + uVar1 + 0xc) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x1c);
    object_info.object_size = 0xc;
    object_info.class_size = 0x5c;
    object_info.class_init_func = object_class_init;
    object_info.object_init_func = object_init;
    gts_object_class::klass =
         (GtsObjectClass *)gts_object_class_new((GtsObjectClass *)0x0,&object_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_object_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void point_class_init(GtsObjectClass *klass)

{
  klass->read = point_read;
  klass->write = point_write;
  return;
}



// WARNING: Unknown calling convention

gint sortp(gpointer *p,guint n)

{
  gpointer pvVar1;
  uint uVar2;
  uint uVar3;
  guint j;
  uint uVar4;
  gint gVar5;
  gint sign;
  uint local_14;
  
  gVar5 = 1;
  uVar2 = n - 1;
  if (uVar2 != 0) {
    local_14 = 0;
    do {
      uVar3 = 0;
      while (uVar4 = uVar3, uVar3 < uVar2 - local_14) {
        while( true ) {
          uVar3 = uVar4 + 1;
          pvVar1 = p[uVar4];
          if (pvVar1 <= p[uVar3]) break;
          gVar5 = -gVar5;
          p[uVar4] = p[uVar3];
          p[uVar3] = pvVar1;
          uVar4 = uVar3;
          if (uVar2 - local_14 <= uVar3) goto LAB_08119d77;
        }
      }
LAB_08119d77:
      local_14 = local_14 + 1;
    } while (local_14 < uVar2);
  }
  return gVar5;
}



// WARNING: Unknown calling convention

void gts_point_transform(GtsPoint *p,GtsMatrix *m)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  gdouble z;
  gdouble y;
  
  if ((m != (GtsMatrix *)0x0) && (p != (GtsPoint *)0x0)) {
    dVar1 = p->x;
    dVar2 = p->y;
    dVar3 = p->z;
    dVar4 = m[1][0];
    dVar5 = m[1][1];
    dVar6 = m[1][2];
    dVar7 = m[1][3];
    dVar8 = m[2][0];
    dVar9 = m[2][1];
    dVar10 = m[2][2];
    dVar11 = m[2][3];
    p->x = dVar3 * (*m)[2] + dVar2 * (*m)[1] + dVar1 * (*m)[0] + (*m)[3];
    p->y = dVar6 * dVar3 + dVar5 * dVar2 + dVar4 * dVar1 + dVar7;
    p->z = dVar10 * dVar3 + dVar9 * dVar2 + dVar8 * dVar1 + dVar11;
    return;
  }
  g_return_if_fail_warning(0,"gts_point_transform","p != NULL && m != NULL");
  return;
}



// WARNING: Unknown calling convention

gdouble gts_point_distance2(GtsPoint *p1,GtsPoint *p2)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  if ((p2 != (GtsPoint *)0x0) && (p1 != (GtsPoint *)0x0)) {
    dVar1 = p1->x - p2->x;
    dVar3 = p1->y - p2->y;
    dVar2 = p1->z - p2->z;
    return dVar2 * dVar2 + dVar3 * dVar3 + dVar1 * dVar1;
  }
  g_return_if_fail_warning(0,"gts_point_distance2","p1 != NULL && p2 != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

gdouble gts_point_segment_distance2(GtsPoint *p,GtsSegment *s)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  GtsVertex *p1_00;
  GtsVertex *p2_00;
  double dVar7;
  double dVar8;
  GtsPoint *p1;
  GtsPoint *p2;
  gdouble ns2;
  gdouble t;
  gdouble gVar9;
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_segment_distance2","p != NULL");
    return 0.0;
  }
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_point_segment_distance2","s != NULL");
    return 0.0;
  }
  p1_00 = s->v1;
  p2_00 = s->v2;
  gVar9 = gts_point_distance2(&p1_00->p,&p2_00->p);
  if (gVar9 != 0.0) {
    dVar1 = (p2_00->p).x;
    dVar2 = (p1_00->p).x;
    dVar3 = (p2_00->p).y;
    dVar4 = (p1_00->p).y;
    dVar5 = (p2_00->p).z;
    dVar6 = (p1_00->p).z;
    dVar7 = gVar9 / ((p->z - dVar6) * (dVar5 - dVar6) +
                    (p->y - dVar4) * (dVar3 - dVar4) + (p->x - dVar2) * (dVar1 - dVar2));
    if (1.0 < dVar7) {
      gVar9 = gts_point_distance2(p,&p2_00->p);
      return gVar9;
    }
    if (0.0 <= dVar7) {
      dVar8 = 1.0 - dVar7;
      dVar2 = (dVar1 * dVar7 + dVar2 * dVar8) - p->x;
      dVar3 = (dVar3 * dVar7 + dVar4 * dVar8) - p->y;
      dVar1 = (dVar7 * dVar5 + dVar8 * dVar6) - p->z;
      return dVar1 * dVar1 + dVar3 * dVar3 + dVar2 * dVar2;
    }
  }
  gVar9 = gts_point_distance2(p,&p1_00->p);
  return gVar9;
}



// WARNING: Unknown calling convention

void gts_point_set(GtsPoint *p,gdouble x,gdouble y,gdouble z)

{
  if (p != (GtsPoint *)0x0) {
    p->x = x;
    p->y = y;
    p->z = z;
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

void gts_point_segment_closest(GtsPoint *p,GtsSegment *s,GtsPoint *closest)

{
  double x;
  double x_00;
  double y;
  double y_00;
  double z;
  double z_00;
  GtsVertex *p1_00;
  GtsVertex *p2_00;
  double dVar1;
  double dVar2;
  GtsPoint *p1;
  GtsPoint *p2;
  gdouble ns2;
  gdouble t;
  gdouble gVar3;
  
  if (((p == (GtsPoint *)0x0) || (s == (GtsSegment *)0x0)) || (closest == (GtsPoint *)0x0)) {
    g_return_if_fail_warning();
    return;
  }
  p1_00 = s->v1;
  p2_00 = s->v2;
  gVar3 = gts_point_distance2(&p1_00->p,&p2_00->p);
  if (gVar3 == 0.0) {
    gts_point_set(closest,(p1_00->p).x,(p1_00->p).y,(p1_00->p).z);
    return;
  }
  x = (p2_00->p).x;
  x_00 = (p1_00->p).x;
  y = (p2_00->p).y;
  y_00 = (p1_00->p).y;
  z = (p2_00->p).z;
  z_00 = (p1_00->p).z;
  dVar1 = gVar3 / ((p->z - z_00) * (z - z_00) +
                  (p->y - y_00) * (y - y_00) + (p->x - x_00) * (x - x_00));
  if (1.0 < dVar1) {
    gts_point_set(closest,x,y,z);
    return;
  }
  if (0.0 <= dVar1) {
    dVar2 = 1.0 - dVar1;
    gts_point_set(closest,dVar1 * x + x_00 * dVar2,y * dVar1 + y_00 * dVar2,z * dVar1 + z_00 * dVar2
                 );
    return;
  }
  gts_point_set(closest,x_00,y_00,z_00);
  return;
}



// WARNING: Unknown calling convention

gint gts_point_orientation_sos(GtsPoint *p1,GtsPoint *p2,GtsPoint *p3)

{
  gint sign;
  int iVar1;
  gdouble o;
  double dVar2;
  GtsPoint *p [3];
  
  if (((p2 == (GtsPoint *)0x0) || (p1 == (GtsPoint *)0x0)) || (p3 == (GtsPoint *)0x0)) {
    g_return_if_fail_warning(0,"gts_point_orientation_sos","p1 != NULL && p2 != NULL && p3 != NULL")
    ;
    sign = 0;
  }
  else {
    dVar2 = orient2d(&p1->x,&p2->x,&p3->x);
    if (dVar2 == 0.0) {
      p[1] = p2;
      iVar1 = -1;
      p[0] = p1;
      p[2] = p3;
      sign = sortp(p,3);
      dVar2 = p[2]->x;
      if ((dVar2 < p[1]->x) || (iVar1 = 1, p[1]->x < dVar2)) {
        sign = sign * iVar1;
      }
      else {
        iVar1 = 1;
        if ((p[1]->y <= p[2]->y) && (iVar1 = -1, p[2]->y <= p[1]->y)) {
          iVar1 = 1;
          if ((p[0]->x <= dVar2) && (iVar1 = -1, dVar2 <= p[0]->x)) {
            return sign;
          }
        }
        sign = sign * iVar1;
      }
    }
    else {
      sign = (uint)(0.0 < dVar2) * 2 + -1;
    }
  }
  return sign;
}



// WARNING: Unknown calling convention

gdouble gts_point_orientation(GtsPoint *p1,GtsPoint *p2,GtsPoint *p3)

{
  double dVar1;
  
  if (((p2 != (GtsPoint *)0x0) && (p1 != (GtsPoint *)0x0)) && (p3 != (GtsPoint *)0x0)) {
    dVar1 = orient2d(&p1->x,&p2->x,&p3->x);
    return dVar1;
  }
  g_return_if_fail_warning(0,"gts_point_orientation","p1 != NULL && p2 != NULL && p3 != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

gint gts_point_orientation_3d_sos(GtsPoint *p1,GtsPoint *p2,GtsPoint *p3,GtsPoint *p4)

{
  bool bVar1;
  gint sign;
  int iVar2;
  gdouble o;
  double dVar3;
  gdouble c [2];
  gdouble b [2];
  gdouble a [2];
  GtsPoint *p [4];
  
  if ((((p2 == (GtsPoint *)0x0) || (p1 == (GtsPoint *)0x0)) || (p4 == (GtsPoint *)0x0)) ||
     (p3 == (GtsPoint *)0x0)) {
    g_return_if_fail_warning
              (0,"gts_point_orientation_3d_sos",
               "p1 != NULL && p2 != NULL && p3 != NULL && p4 != NULL");
    sign = 0;
    return sign;
  }
  dVar3 = orient3d(&p1->x,&p2->x,&p3->x,&p4->x);
  if (dVar3 != 0.0) {
    sign = (uint)(0.0 < dVar3) * 2 + -1;
    return sign;
  }
  p[2] = p3;
  p[0] = p1;
  p[1] = p2;
  p[3] = p4;
  sign = sortp(p,4);
  a[0] = p[1]->x;
  a[1] = p[1]->y;
  b[0] = p[2]->x;
  b[1] = p[2]->y;
  c[0] = p[3]->x;
  c[1] = p[3]->y;
  dVar3 = orient2d(a,b,c);
  if (dVar3 == 0.0) {
    a[0] = p[1]->x;
    a[1] = p[1]->z;
    b[0] = p[2]->x;
    b[1] = p[2]->z;
    c[0] = p[3]->x;
    c[1] = p[3]->z;
    dVar3 = orient2d(a,b,c);
    if (dVar3 != 0.0) {
LAB_0811a553:
      bVar1 = dVar3 <= 0.0;
      goto LAB_0811a414;
    }
    a[0] = p[1]->y;
    a[1] = p[1]->z;
    b[0] = p[2]->y;
    b[1] = p[2]->z;
    c[0] = p[3]->y;
    c[1] = p[3]->z;
    dVar3 = orient2d(a,b,c);
    if (dVar3 == 0.0) {
      a[0] = p[0]->x;
      a[1] = p[0]->y;
      b[0] = p[2]->x;
      b[1] = p[2]->y;
      c[0] = p[3]->x;
      c[1] = p[3]->y;
      dVar3 = orient2d(a,b,c);
      if (dVar3 != 0.0) goto LAB_0811a553;
      b[0] = p[2]->x;
      c[0] = p[3]->x;
      iVar2 = 1;
      if ((c[0] < b[0]) || (iVar2 = -1, b[0] < c[0])) {
LAB_0811a802:
        sign = sign * iVar2;
        return sign;
      }
      iVar2 = -1;
      if ((p[3]->y < p[2]->y) || (iVar2 = 1, p[2]->y < p[3]->y)) goto LAB_0811a802;
      a[0] = p[0]->x;
      a[1] = p[0]->z;
      b[1] = p[2]->z;
      c[1] = p[3]->z;
      dVar3 = orient2d(a,b,c);
      if (dVar3 == 0.0) {
        b[1] = p[2]->z;
        c[1] = p[3]->z;
        iVar2 = 1;
        if ((c[1] < b[1]) || (iVar2 = -1, b[1] < c[1])) goto LAB_0811a802;
        a[0] = p[0]->y;
        a[1] = p[0]->z;
        b[0] = p[2]->y;
        c[0] = p[3]->y;
        dVar3 = orient2d(a,b,c);
        if (dVar3 != 0.0) goto LAB_0811a553;
        a[0] = p[0]->x;
        a[1] = p[0]->y;
        b[0] = p[1]->x;
        b[1] = p[1]->y;
        c[0] = p[3]->x;
        c[1] = p[3]->y;
        dVar3 = orient2d(a,b,c);
        if (dVar3 == 0.0) {
          iVar2 = -1;
          dVar3 = p[3]->x;
          if ((dVar3 < p[1]->x) || (iVar2 = 1, p[1]->x < dVar3)) {
            sign = sign * iVar2;
            return sign;
          }
          iVar2 = 1;
          if ((p[1]->y <= p[3]->y) && (iVar2 = -1, p[3]->y <= p[1]->y)) {
            iVar2 = 1;
            if ((p[0]->x <= dVar3) && (iVar2 = -1, dVar3 <= p[0]->x)) {
              return sign;
            }
          }
          sign = sign * iVar2;
          return sign;
        }
      }
    }
  }
  bVar1 = 0.0 < dVar3;
LAB_0811a414:
  sign = sign * ((uint)bVar1 * 2 + -1);
  return sign;
}



// WARNING: Unknown calling convention

gdouble gts_point_orientation_3d(GtsPoint *p1,GtsPoint *p2,GtsPoint *p3,GtsPoint *p4)

{
  double dVar1;
  
  if ((((p2 != (GtsPoint *)0x0) && (p1 != (GtsPoint *)0x0)) && (p4 != (GtsPoint *)0x0)) &&
     (p3 != (GtsPoint *)0x0)) {
    dVar1 = orient3d(&p1->x,&p2->x,&p3->x,&p4->x);
    return dVar1;
  }
  g_return_if_fail_warning
            (0,"gts_point_orientation_3d","p1 != NULL && p2 != NULL && p3 != NULL && p4 != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

GtsIntersect gts_point_is_in_triangle(GtsPoint *p,GtsTriangle *t)

{
  GtsIntersect GVar1;
  gdouble d3;
  gdouble d1;
  gdouble d2;
  gdouble gVar2;
  gdouble gVar3;
  gdouble gVar4;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if ((t == (GtsTriangle *)0x0) || (p == (GtsPoint *)0x0)) {
    g_return_if_fail_warning(0,"gts_point_is_in_triangle","p != NULL && t != NULL");
    GVar1 = GTS_ON;
  }
  else {
    gts_triangle_vertices(t,local_10,&local_14,&local_18);
    gVar2 = gts_point_orientation(&local_10[0]->p,&local_14->p,p);
    if ((gVar2 < 0.0) ||
       ((gVar3 = gts_point_orientation(&local_14->p,&local_18->p,p), gVar3 < 0.0 ||
        (gVar4 = gts_point_orientation(&local_18->p,&local_10[0]->p,p), gVar4 < 0.0)))) {
      return GTS_OUT;
    }
    if ((gVar2 == 0.0) || (gVar3 == 0.0)) {
      GVar1 = GTS_ON;
    }
    else {
      GVar1 = (GtsIntersect)(gVar4 != 0.0);
    }
  }
  return GVar1;
}



// WARNING: Removing unreachable block (ram,0x0811ad49)
// WARNING: Removing unreachable block (ram,0x0811ab86)
// WARNING: Removing unreachable block (ram,0x0811ab51)
// WARNING: Removing unreachable block (ram,0x0811aba2)
// WARNING: Unknown calling convention

GtsPoint *
gts_segment_triangle_intersection
          (GtsSegment *s,GtsTriangle *t,gboolean boundary,GtsPointClass *klass)

{
  double dVar1;
  GtsVertex *p1;
  GtsVertex *p2;
  GtsVertex *p4;
  bool bVar2;
  double dVar3;
  GtsPoint *p;
  GtsPoint *E;
  GtsVertex *p4_00;
  GtsPoint *D;
  GtsVertex *p4_01;
  GtsVertex *p3;
  gdouble BCDE;
  gdouble ABCD;
  gdouble ABDE;
  gdouble gVar4;
  gdouble gVar5;
  double dVar6;
  double dVar7;
  gdouble local_2c;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_triangle_intersection","s != NULL");
    return (GtsPoint *)0x0;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_triangle_intersection","t != NULL");
    return (GtsPoint *)0x0;
  }
  if (klass == (GtsPointClass *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_triangle_intersection","klass != NULL");
    return (GtsPoint *)0x0;
  }
  p1 = (t->e1->segment).v1;
  p3 = (t->e2->segment).v1;
  p2 = (t->e1->segment).v2;
  if ((p1 == p3) || (p2 == p3)) {
    p3 = (t->e2->segment).v2;
  }
  p4 = s->v2;
  p4_01 = s->v1;
  gVar4 = gts_point_orientation_3d(&p1->p,&p2->p,&p3->p,&p4->p);
  gVar5 = gts_point_orientation_3d(&p1->p,&p2->p,&p3->p,&p4_01->p);
  if (((0.0 <= gVar4) && (p4_00 = p4, dVar1 = gVar5, local_2c = gVar4, gVar5 <= 0.0)) ||
     ((0.0 <= gVar5 && (p4_00 = p4_01, p4_01 = p4, dVar1 = gVar4, local_2c = gVar5, gVar4 <= 0.0))))
  {
    gVar4 = gts_point_orientation_3d(&p1->p,&p4_01->p,&p3->p,&p4_00->p);
    if (boundary == 0) {
      if (gVar4 <= 0.0) {
        return (GtsPoint *)0x0;
      }
      dVar6 = gts_point_orientation_3d(&p1->p,&p2->p,&p4_01->p,&p4_00->p);
      if (dVar6 <= 0.0) {
        return (GtsPoint *)0x0;
      }
      dVar7 = gts_point_orientation_3d(&p2->p,&p3->p,&p4_01->p,&p4_00->p);
      if (dVar7 <= 0.0) {
        return (GtsPoint *)0x0;
      }
    }
    else {
      if (gVar4 < 0.0) {
        return (GtsPoint *)0x0;
      }
      dVar6 = gts_point_orientation_3d(&p1->p,&p2->p,&p4_01->p,&p4_00->p);
      if (dVar6 < 0.0) {
        return (GtsPoint *)0x0;
      }
      dVar7 = gts_point_orientation_3d(&p2->p,&p3->p,&p4_01->p,&p4_00->p);
      if (dVar7 < 0.0) {
        return (GtsPoint *)0x0;
      }
    }
    if (local_2c != 0.0) {
      if (dVar1 == 0.0) {
        return &p4_01->p;
      }
      if (boundary != 0) {
        if (dVar6 == 0.0) {
          if (gVar4 == 0.0) {
            return &p1->p;
          }
        }
        else {
          bVar2 = dVar7 != 0.0;
          p2 = p3;
          dVar7 = gVar4;
          if (bVar2) goto LAB_0811aba8;
        }
        if (dVar7 == 0.0) {
          return &p2->p;
        }
      }
LAB_0811aba8:
      dVar3 = local_2c / (local_2c - dVar1);
      p = (GtsPoint *)gts_object_new(&klass->parent_class);
      dVar1 = (p4_00->p).z;
      dVar6 = (p4_00->p).y;
      dVar7 = (p4_00->p).x;
      gts_point_set(p,dVar7 + ((p4_01->p).x - dVar7) * dVar3,((p4_01->p).y - dVar6) * dVar3 + dVar6,
                    ((p4_01->p).z - dVar1) * dVar3 + dVar1);
      return p;
    }
    if (dVar1 != 0.0) {
      return &p4_00->p;
    }
  }
  return (GtsPoint *)0x0;
}



// WARNING: Unknown calling convention

GtsPoint * gts_point_new(GtsPointClass *klass,gdouble x,gdouble y,gdouble z)

{
  GtsPoint *pGVar1;
  
  pGVar1 = (GtsPoint *)gts_object_new(&klass->parent_class);
  pGVar1->x = x;
  pGVar1->y = y;
  pGVar1->z = z;
  return pGVar1;
}



// WARNING: Removing unreachable block (ram,0x0811af33)
// WARNING: Unknown calling convention

gdouble gts_point_triangle_distance2(GtsPoint *p,GtsTriangle *t)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  gdouble d2;
  gdouble B;
  gdouble C;
  gdouble E;
  gdouble det;
  gdouble D;
  gdouble A;
  gdouble gVar15;
  gdouble gVar16;
  double dVar17;
  GtsEdge *local_24;
  GtsEdge *local_20;
  GtsEdge *local_1c;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_triangle_distance2","p != NULL");
    return 0.0;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_point_triangle_distance2","t != NULL");
    return 0.0;
  }
  gts_triangle_vertices_edges
            (t,(GtsEdge *)0x0,local_10,&local_14,&local_18,&local_1c,&local_20,&local_24);
  dVar17 = (local_10[0]->p).x;
  dVar3 = (local_14->p).x - dVar17;
  dVar1 = (local_10[0]->p).y;
  dVar11 = (local_14->p).y - dVar1;
  dVar2 = (local_10[0]->p).z;
  dVar13 = (local_14->p).z - dVar2;
  dVar4 = (local_18->p).x - dVar17;
  dVar12 = (local_18->p).y - dVar1;
  dVar14 = (local_18->p).z - dVar2;
  dVar9 = dVar13 * dVar14 + dVar11 * dVar12 + dVar4 * dVar3;
  dVar8 = dVar13 * dVar13 + dVar11 * dVar11 + dVar3 * dVar3;
  dVar5 = dVar14 * dVar14 + dVar12 * dVar12 + dVar4 * dVar4;
  dVar6 = dVar9 * dVar9 - dVar8 * dVar5;
  if (dVar6 == 0.0) {
    gVar15 = gts_point_segment_distance2(p,&local_1c->segment);
    gVar16 = gts_point_segment_distance2(p,&local_24->segment);
    if (gVar15 <= gVar16 || gVar16 != gVar15) {
      gVar16 = gVar15;
    }
    return gVar16;
  }
  dVar17 = dVar17 - p->x;
  dVar1 = dVar1 - p->y;
  dVar2 = dVar2 - p->z;
  dVar7 = dVar14 * dVar2 + dVar12 * dVar1 + dVar4 * dVar17;
  dVar10 = dVar13 * dVar2 + dVar11 * dVar1 + dVar17 * dVar3;
  dVar5 = (dVar5 * dVar10 - dVar7 * dVar9) / dVar6;
  if (dVar5 < 0.0) {
    gVar16 = gts_point_segment_distance2(p,&local_24->segment);
    return gVar16;
  }
  dVar6 = dVar6 / (dVar8 * dVar7 - dVar9 * dVar10);
  if (dVar6 < 0.0) {
    gVar16 = gts_point_segment_distance2(p,&local_1c->segment);
    return gVar16;
  }
  if (1.0 < dVar5 + dVar6) {
    dVar17 = gts_point_segment_distance2(p,&local_20->segment);
  }
  else {
    dVar17 = dVar4 * dVar6 + dVar3 * dVar5 + dVar17;
    dVar3 = dVar12 * dVar6 + dVar11 * dVar5 + dVar1;
    dVar1 = dVar6 * dVar14 + dVar5 * dVar13 + dVar2;
    dVar17 = dVar1 * dVar1 + dVar3 * dVar3 + dVar17 * dVar17;
  }
  return dVar17;
}



// WARNING: Removing unreachable block (ram,0x0811b148)
// WARNING: Removing unreachable block (ram,0x0811b13e)
// WARNING: Removing unreachable block (ram,0x0811b14a)
// WARNING: Unknown calling convention

gdouble gts_point_triangle_distance(GtsPoint *p,GtsTriangle *t)

{
  gdouble gVar1;
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_triangle_distance","p != NULL");
    return 0.0;
  }
  if (t != (GtsTriangle *)0x0) {
    gVar1 = gts_point_triangle_distance2(p,t);
    return SQRT(gVar1);
  }
  g_return_if_fail_warning(0,"gts_point_triangle_distance","t != NULL");
  return 0.0;
}



// WARNING: Removing unreachable block (ram,0x0811b1d8)
// WARNING: Removing unreachable block (ram,0x0811b1ce)
// WARNING: Removing unreachable block (ram,0x0811b1da)
// WARNING: Unknown calling convention

gdouble gts_point_segment_distance(GtsPoint *p,GtsSegment *s)

{
  gdouble gVar1;
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_segment_distance","p != NULL");
    return 0.0;
  }
  if (s != (GtsSegment *)0x0) {
    gVar1 = gts_point_segment_distance2(p,s);
    return SQRT(gVar1);
  }
  g_return_if_fail_warning(0,"gts_point_segment_distance","s != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

gdouble gts_point_distance(GtsPoint *p1,GtsPoint *p2)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  if ((p2 != (GtsPoint *)0x0) && (p1 != (GtsPoint *)0x0)) {
    dVar1 = p1->x - p2->x;
    dVar3 = p1->y - p2->y;
    dVar2 = p1->z - p2->z;
    return SQRT(dVar2 * dVar2 + dVar3 * dVar3 + dVar1 * dVar1);
  }
  g_return_if_fail_warning(0,"gts_point_distance","p1 != NULL && p2 != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

gdouble gts_point_in_sphere(GtsPoint *p,GtsPoint *p1,GtsPoint *p2,GtsPoint *p3,GtsPoint *p4)

{
  double dVar1;
  
  if ((((p1 != (GtsPoint *)0x0) && (p != (GtsPoint *)0x0)) && (p3 != (GtsPoint *)0x0)) &&
     ((p2 != (GtsPoint *)0x0 && (p4 != (GtsPoint *)0x0)))) {
    dVar1 = insphere(&p1->x,&p2->x,&p3->x,&p4->x,&p->x);
    return dVar1;
  }
  g_return_if_fail_warning
            (0,"gts_point_in_sphere",
             "p != NULL && p1 != NULL && p2 != NULL && p3 != NULL && p4 != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

gdouble gts_point_in_circle(GtsPoint *p,GtsPoint *p1,GtsPoint *p2,GtsPoint *p3)

{
  double dVar1;
  
  if ((((p1 != (GtsPoint *)0x0) && (p != (GtsPoint *)0x0)) && (p3 != (GtsPoint *)0x0)) &&
     (p2 != (GtsPoint *)0x0)) {
    dVar1 = incircle(&p1->x,&p2->x,&p3->x,&p->x);
    return dVar1;
  }
  g_return_if_fail_warning
            (0,"gts_point_in_circle","p != NULL && p1 != NULL && p2 != NULL && p3 != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

gdouble gts_point_in_triangle_circle(GtsPoint *p,GtsTriangle *t)

{
  double dVar1;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if ((t != (GtsTriangle *)0x0) && (p != (GtsPoint *)0x0)) {
    gts_triangle_vertices(t,local_10,&local_14,&local_18);
    dVar1 = incircle(&(local_10[0]->p).x,&(local_14->p).x,&(local_18->p).x,&p->x);
    return dVar1;
  }
  g_return_if_fail_warning(0,"gts_point_in_triangle_circle","p != NULL && t != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

GtsPointClass * gts_point_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo point_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_point_class::klass == (GtsPointClass *)0x0) {
    pGVar3 = &point_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    point_info.name[0] = 'G';
    point_info.name[1] = 't';
    point_info.name[2] = 's';
    point_info.name[3] = 'P';
    point_info.name[4] = 'o';
    point_info.name[5] = 'i';
    point_info.name[6] = 'n';
    point_info.name[7] = 't';
    uVar1 = 0;
    do {
      *(undefined4 *)(point_info.name + uVar1 + 0xc) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x1c);
    point_info.object_size = 0x24;
    point_info.class_size = 0x60;
    point_info.class_init_func = point_class_init;
    parent_class = gts_object_class();
    gts_point_class::klass = (GtsPointClass *)gts_object_class_new(parent_class,&point_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_point_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

gboolean gts_point_is_inside_surface(GtsPoint *p,GNode *tree,gboolean is_open)

{
  gdouble gVar1;
  gdouble gVar2;
  double dVar3;
  GSList *pGVar4;
  GtsPointClass *klass;
  GtsPoint *p4;
  GSList *pGVar5;
  gint ABCD;
  gint ADCE;
  gint ABDE;
  uint uVar6;
  gint BCDE;
  gint gVar7;
  gint gVar8;
  GtsPoint *p2;
  GtsPoint *p1;
  GtsPoint *p4_00;
  GSList *i;
  uint local_34;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_is_inside_surface","p != NULL");
    return 0;
  }
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_point_is_inside_surface","tree != NULL");
    return 0;
  }
  gVar1 = p->z;
  gVar2 = p->y;
  dVar3 = *(double *)((int)tree->data + 0x28);
  klass = gts_point_class();
  p4 = (GtsPoint *)gts_object_new(&klass->parent_class);
  p4->x = ABS(dVar3) / 10.0 + dVar3;
  p4->y = gVar2;
  p4->z = gVar1;
  pGVar5 = gts_bb_tree_stabbed(tree,p);
  local_34 = 0;
  for (pGVar4 = pGVar5; pGVar4 != (GSList *)0x0; pGVar4 = pGVar4->next) {
    gts_triangle_vertices(*(GtsTriangle **)((int)pGVar4->data + 0xc),local_20,&local_24,&local_28);
    gVar7 = gts_point_orientation_3d_sos(&local_20[0]->p,&local_24->p,&local_28->p,p4);
    gVar8 = gts_point_orientation_3d_sos(&local_20[0]->p,&local_24->p,&local_28->p,p);
    if ((((gVar8 < 1) && (p2 = p, p4_00 = p4, -1 < gVar7)) ||
        ((gVar7 < 1 && (p2 = p4, p4_00 = p, -1 < gVar8)))) &&
       ((gVar7 = gts_point_orientation_3d_sos(&local_20[0]->p,p2,&local_28->p,p4_00), -1 < gVar7 &&
        (gVar7 = gts_point_orientation_3d_sos(&local_20[0]->p,&local_24->p,p2,p4_00), -1 < gVar7))))
    {
      uVar6 = gts_point_orientation_3d_sos(&local_24->p,&local_28->p,p2,p4_00);
      local_34 = local_34 + (uVar6 < 0x80000000);
    }
  }
  g_slist_free(pGVar5);
  gts_object_destroy((GtsObject *)p4);
  if (is_open != 0) {
    return (local_34 ^ 1) & 1;
  }
  return local_34 & 1;
}



// WARNING: Unknown calling convention

void gts_point_triangle_closest(GtsPoint *p,GtsTriangle *t,GtsPoint *closest)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  GtsPointClass *klass;
  GtsPoint *closest_00;
  gdouble B;
  gdouble C;
  gdouble E;
  gdouble gVar18;
  gdouble gVar19;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_triangle_closest","p != NULL");
    return;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_point_triangle_closest","t != NULL");
    return;
  }
  if (closest == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_triangle_closest","closest != NULL");
    return;
  }
  gts_triangle_vertices_edges
            (t,(GtsEdge *)0x0,local_20,&local_24,&local_28,&local_2c,&local_30,&local_34);
  dVar1 = (local_20[0]->p).x;
  dVar4 = (local_24->p).x - dVar1;
  dVar2 = (local_20[0]->p).y;
  dVar6 = (local_24->p).y - dVar2;
  dVar3 = (local_20[0]->p).z;
  dVar12 = (local_24->p).z - dVar3;
  dVar15 = (local_28->p).x - dVar1;
  dVar5 = (local_28->p).y - dVar2;
  dVar11 = (local_28->p).z - dVar3;
  dVar9 = dVar12 * dVar11 + dVar5 * dVar6 + dVar4 * dVar15;
  dVar13 = dVar12 * dVar12 + dVar6 * dVar6 + dVar4 * dVar4;
  dVar8 = dVar11 * dVar11 + dVar5 * dVar5 + dVar15 * dVar15;
  dVar7 = dVar9 * dVar9 - dVar13 * dVar8;
  if (dVar7 != 0.0) {
    dVar14 = dVar1 - p->x;
    dVar16 = dVar2 - p->y;
    dVar17 = dVar3 - p->z;
    dVar10 = dVar17 * dVar11 + dVar16 * dVar5 + dVar15 * dVar14;
    dVar14 = dVar17 * dVar12 + dVar16 * dVar6 + dVar4 * dVar14;
    dVar8 = (dVar14 * dVar8 - dVar10 * dVar9) / dVar7;
    if (dVar8 < 0.0) {
      gts_point_segment_closest(p,&local_34->segment,closest);
      return;
    }
    dVar7 = (dVar13 * dVar10 - dVar9 * dVar14) / dVar7;
    if (dVar7 < 0.0) {
      gts_point_segment_closest(p,&local_2c->segment,closest);
      return;
    }
    if (1.0 < dVar8 + dVar7) {
      gts_point_segment_closest(p,&local_30->segment,closest);
      return;
    }
    gts_point_set(closest,dVar7 * dVar15 + dVar8 * dVar4 + dVar1,
                  dVar5 * dVar7 + dVar6 * dVar8 + dVar2,dVar11 * dVar7 + dVar12 * dVar8 + dVar3);
    return;
  }
  klass = gts_point_class();
  closest_00 = (GtsPoint *)gts_object_new(&klass->parent_class);
  gts_point_segment_closest(p,&local_2c->segment,closest_00);
  gts_point_segment_closest(p,&local_34->segment,closest);
  gVar18 = gts_point_distance2(closest_00,p);
  gVar19 = gts_point_distance2(closest,p);
  if (gVar18 < gVar19) {
    gts_point_set(closest,closest_00->x,closest_00->y,closest_00->z);
    gts_object_destroy((GtsObject *)closest_00);
  }
  else {
    gts_object_destroy((GtsObject *)closest_00);
  }
  return;
}



// WARNING: Unknown calling convention

void point_write(GtsObject *o,FILE *fptr)

{
  undefined8 uVar1;
  undefined8 uVar2;
  
  if (*(int *)o->klass[1].info.name == 0) {
    uVar1._0_4_ = o[2].reserved;
    uVar1._4_4_ = o[2].flags;
    uVar2._0_4_ = o[1].klass;
    uVar2._4_4_ = o[1].reserved;
    __fprintf_chk(fptr,1,"%.10g %.10g %.10g",uVar2,*(undefined8 *)&o[1].flags,uVar1);
    return;
  }
  fwrite(o + 1,8,1,(FILE *)fptr);
  fwrite(&o[1].flags,8,1,(FILE *)fptr);
  fwrite(&o[2].reserved,8,1,(FILE *)fptr);
  return;
}



// WARNING: Unknown calling convention

void point_read(GtsObject **o,GtsFile *f)

{
  GtsObject *pGVar1;
  GtsFile *f_00;
  guint gVar2;
  double dVar3;
  
  f_00 = f;
  pGVar1 = *o;
  if (*(int *)pGVar1->klass[1].info.name == 0) {
    if ((f->type == GTS_FLOAT) || (f->type == GTS_INT)) {
      dVar3 = strtod(f->token->str,(char **)0x0);
      *(double *)(pGVar1 + 1) = dVar3;
      gts_file_next_token(f);
      if ((f->type != GTS_FLOAT) && (f->type != GTS_INT)) {
        gts_file_error(f,"expecting a number (y coordinate)");
        return;
      }
      dVar3 = strtod(f->token->str,(char **)0x0);
      *(double *)&pGVar1[1].flags = dVar3;
      gts_file_next_token(f);
      if ((f->type != GTS_FLOAT) && (f->type != GTS_INT)) {
        gts_file_error(f,"expecting a number (z coordinate)");
        return;
      }
      dVar3 = strtod(f->token->str,(char **)0x0);
      *(double *)&pGVar1[2].reserved = dVar3;
      gts_file_next_token(f);
      return;
    }
    f = (GtsFile *)s_expecting_a_number__x_coordinate_0815fa88;
  }
  else {
    gVar2 = gts_file_read(f,pGVar1 + 1,8,1);
    if (gVar2 != 1) {
      gts_file_error(f,"expecting a binary number (x coordinate)");
      return;
    }
    gVar2 = gts_file_read(f,&pGVar1[1].flags,8,1);
    if (gVar2 == 1) {
      gVar2 = gts_file_read(f,&pGVar1[2].reserved,8,1);
      if (gVar2 == 1) {
        return;
      }
      f = (GtsFile *)s_expecting_a_binary_number__z_coo_0815fa5c;
    }
    else {
      f = (GtsFile *)s_expecting_a_binary_number__y_coo_0815fa30;
    }
  }
  gts_file_error(f_00,(gchar *)f);
  return;
}



// WARNING: Unknown calling convention

void vertex_class_init(GtsVertexClass *klass)

{
  klass->intersection_attributes = (_func_void_GtsVertex_ptr_GtsObject_ptr_GtsObject_ptr *)0x0;
  (klass->parent_class).parent_class.clone = vertex_clone;
  (klass->parent_class).parent_class.destroy = vertex_destroy;
  return;
}



// WARNING: Unknown calling convention

void vertex_init(GtsVertex *vertex)

{
  vertex->segments = (GSList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void gts_vertex_normal_class_init(GtsVertexClass *klass)

{
  klass->intersection_attributes = vertex_normal_attributes;
  return;
}



// WARNING: Unknown calling convention

GtsSegment * gts_vertices_are_connected(GtsVertex *v1,GtsVertex *v2)

{
  GSList *pGVar1;
  GtsSegment *pGVar2;
  GtsSegment *s;
  GSList *i;
  
  if (v1 == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertices_are_connected","v1 != NULL");
    return (GtsSegment *)0x0;
  }
  if (v2 != (GtsVertex *)0x0) {
    pGVar1 = v1->segments;
    while( true ) {
      if (pGVar1 == (GSList *)0x0) {
        return (GtsSegment *)0x0;
      }
      pGVar2 = (GtsSegment *)pGVar1->data;
      if ((pGVar2->v1 == v2) || (pGVar2->v2 == v2)) break;
      pGVar1 = (GSList *)(&pGVar1->data)[1];
    }
    return pGVar2;
  }
  g_return_if_fail_warning(0,"gts_vertices_are_connected","v2 != NULL");
  return (GtsSegment *)0x0;
}



// WARNING: Unknown calling convention

gboolean gts_vertex_is_unattached(GtsVertex *v)

{
  if (v != (GtsVertex *)0x0) {
    return (uint)(v->segments == (GSList *)0x0);
  }
  g_return_if_fail_warning(0,"gts_vertex_is_unattached","v != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void gts_vertex_replace(GtsVertex *v,GtsVertex *with)

{
  gpointer pvVar1;
  GSList *pGVar2;
  GtsVertex *pGVar3;
  GtsSegment *s;
  GSList *i;
  GSList *pGVar4;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_replace","v != NULL");
    return;
  }
  if (with == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_replace","with != NULL");
    return;
  }
  if (v == with) {
    g_return_if_fail_warning(0,"gts_vertex_replace","v != with");
    return;
  }
  pGVar4 = v->segments;
  pGVar2 = (GSList *)0x0;
  if (pGVar4 != (GSList *)0x0) {
    do {
      while( true ) {
        pvVar1 = pGVar4->data;
        pGVar3 = *(GtsVertex **)((int)pvVar1 + 0xc);
        if (pGVar3 == with) break;
        if (*(GtsVertex **)((int)pvVar1 + 0x10) != with) {
          pGVar2 = (GSList *)g_slist_prepend(with->segments,pvVar1);
          with->segments = pGVar2;
          pGVar3 = *(GtsVertex **)((int)pvVar1 + 0xc);
        }
        if (v != pGVar3) break;
        *(GtsVertex **)((int)pvVar1 + 0xc) = with;
        if (*(GtsVertex **)((int)pvVar1 + 0x10) != v) goto LAB_0811be5d;
LAB_0811bea0:
        pGVar4 = pGVar4->next;
        *(GtsVertex **)((int)pvVar1 + 0x10) = with;
        if (pGVar4 == (GSList *)0x0) goto LAB_0811beb0;
      }
      if (*(GtsVertex **)((int)pvVar1 + 0x10) == v) goto LAB_0811bea0;
LAB_0811be5d:
      pGVar4 = pGVar4->next;
    } while (pGVar4 != (GSList *)0x0);
LAB_0811beb0:
    pGVar2 = v->segments;
  }
  g_slist_free(pGVar2);
  v->segments = (GSList *)0x0;
  return;
}



// WARNING: Unknown calling convention

GtsEdge * replace_vertex(GtsTriangle *t,GtsEdge *e1,GtsVertex *v,GtsVertex *with)

{
  GtsVertex *pGVar1;
  GSList *pGVar2;
  GtsEdge *e;
  GtsEdge *pGVar3;
  
  pGVar3 = t->e1;
  if ((((pGVar3 == e1) || (((pGVar3->segment).v1 != v && ((pGVar3->segment).v2 != v)))) &&
      ((pGVar3 = t->e2, pGVar3 == e1 || (((pGVar3->segment).v1 != v && ((pGVar3->segment).v2 != v)))
       ))) && ((pGVar3 = t->e3, pGVar3 == e1 ||
               (((pGVar3->segment).v1 != v && ((pGVar3->segment).v2 != v)))))) {
    pGVar3 = (GtsEdge *)0x0;
  }
  else if (with != v) {
    if ((pGVar3->segment).v1 == v) {
      pGVar1 = (pGVar3->segment).v2;
      (pGVar3->segment).v1 = with;
    }
    else {
      pGVar1 = (pGVar3->segment).v2;
    }
    if (pGVar1 == v) {
      (pGVar3->segment).v2 = with;
    }
    pGVar2 = (GSList *)g_slist_prepend(with->segments,pGVar3);
    with->segments = pGVar2;
    pGVar2 = (GSList *)g_slist_remove(v->segments,pGVar3);
    v->segments = pGVar2;
  }
  return pGVar3;
}



// WARNING: Unknown calling convention

void triangle_next(GtsEdge *e,GtsVertex *v,GtsVertex *with)

{
  GSList *pGVar1;
  GtsTriangle *t_00;
  GtsTriangle *t;
  GtsEdge *e_00;
  GSList *i;
  
  if (e != (GtsEdge *)0x0) {
    for (pGVar1 = e->triangles; pGVar1 != (GSList *)0x0; pGVar1 = (GSList *)(&pGVar1->data)[1]) {
      t_00 = (GtsTriangle *)pGVar1->data;
      if ((t_00->object).reserved != (gpointer)0x0) {
        (t_00->object).reserved = (gpointer)0x0;
        e_00 = replace_vertex(t_00,e,v,with);
        triangle_next(e_00,v,with);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

GList * gts_vertices_merge(GList *vertices,gdouble epsilon,
                          _func_gboolean_GtsVertex_ptr_GtsVertex_ptr *check)

{
  double dVar1;
  double dVar2;
  double dVar3;
  GtsVertex *with;
  GList *pGVar4;
  GtsVertex *v_00;
  GPtrArray *points;
  GNode *tree_3d;
  GtsBBoxClass *klass;
  GtsBBox *bbox;
  GSList *pGVar5;
  GSList *selected;
  gboolean gVar6;
  GPtrArray *array;
  GList *pGVar7;
  GList *i;
  GtsVertex *v;
  GList *next;
  GSList *j;
  GSList *pGVar8;
  
  if (vertices == (GList *)0x0) {
    g_return_if_fail_warning(0,"gts_vertices_merge","vertices != NULL");
    return (GList *)0x0;
  }
  points = (GPtrArray *)g_ptr_array_new();
  pGVar7 = vertices;
  do {
    g_ptr_array_add(points,pGVar7->data);
    pGVar7 = pGVar7->next;
  } while (pGVar7 != (GList *)0x0);
  tree_3d = gts_kdtree_new(points,(_func_int_void_ptr_void_ptr *)0x0);
  g_ptr_array_free(points,1);
  pGVar7 = vertices;
  do {
    with = (GtsVertex *)pGVar7->data;
    if ((with->p).object.reserved == (gpointer)0x0) {
      dVar1 = (with->p).z;
      dVar2 = (with->p).y;
      dVar3 = (with->p).x;
      klass = gts_bbox_class();
      bbox = gts_bbox_new(klass,with,dVar3 - epsilon,dVar2 - epsilon,dVar1 - epsilon,epsilon + dVar3
                          ,epsilon + dVar2,epsilon + dVar1);
      pGVar5 = gts_kdtree_range(tree_3d,bbox,(_func_int_void_ptr_void_ptr *)0x0);
      pGVar8 = pGVar5;
      while (pGVar8 != (GSList *)0x0) {
        while (((v_00 = (GtsVertex *)pGVar8->data, v_00 == with ||
                ((v_00->p).object.reserved != (gpointer)0x0)) ||
               ((check != (_func_gboolean_GtsVertex_ptr_GtsVertex_ptr *)0x0 &&
                (gVar6 = (*check)(v_00,with), gVar6 == 0))))) {
          pGVar8 = (GSList *)(&pGVar8->data)[1];
          if (pGVar8 == (GSList *)0x0) goto LAB_0811c21e;
        }
        gts_vertex_replace(v_00,with);
        pGVar8 = (GSList *)(&pGVar8->data)[1];
        (v_00->p).object.reserved = v_00;
      }
LAB_0811c21e:
      g_slist_free(pGVar5);
      gts_object_destroy(&bbox->object);
    }
    pGVar7 = (GList *)(&pGVar7->data)[1];
    if (pGVar7 == (GList *)0x0) {
      g_node_destroy(tree_3d);
      gts_allow_floating_vertices = 1;
      pGVar7 = vertices;
      do {
        pGVar4 = pGVar7->next;
        if (((GtsObject *)pGVar7->data)->reserved != (gpointer)0x0) {
          gts_object_destroy((GtsObject *)pGVar7->data);
          vertices = (GList *)g_list_remove_link(vertices,pGVar7);
          g_list_free_1(pGVar7);
        }
        pGVar7 = pGVar4;
      } while (pGVar4 != (GList *)0x0);
      gts_allow_floating_vertices = 0;
      return vertices;
    }
  } while( true );
}



// WARNING: Unknown calling convention

GSList * gts_vertices_from_segments(GSList *segments)

{
  gpointer pvVar1;
  undefined4 uVar2;
  int iVar3;
  GSList *i;
  GtsSegment *s;
  GHashTable *hash;
  GSList *local_20;
  
  uVar2 = g_hash_table_new(0,0);
  local_20 = (GSList *)0x0;
  if (segments != (GSList *)0x0) {
    do {
      pvVar1 = segments->data;
      iVar3 = g_hash_table_lookup(uVar2,*(undefined4 *)((int)pvVar1 + 0xc));
      if (iVar3 == 0) {
        local_20 = (GSList *)g_slist_prepend(local_20,*(undefined4 *)((int)pvVar1 + 0xc));
        g_hash_table_insert(uVar2,*(undefined4 *)((int)pvVar1 + 0xc),pvVar1);
      }
      iVar3 = g_hash_table_lookup(uVar2,*(undefined4 *)((int)pvVar1 + 0x10));
      if (iVar3 == 0) {
        local_20 = (GSList *)g_slist_prepend(local_20,*(undefined4 *)((int)pvVar1 + 0x10));
        g_hash_table_insert(uVar2,*(undefined4 *)((int)pvVar1 + 0x10),pvVar1);
      }
      segments = segments->next;
    } while (segments != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar2);
  return local_20;
}



// WARNING: Unknown calling convention

GtsVertex * gts_vertex_new(GtsVertexClass *klass,gdouble x,gdouble y,gdouble z)

{
  GtsVertex *p;
  
  p = (GtsVertex *)gts_object_new((GtsObjectClass *)klass);
  gts_point_set((GtsPoint *)p,x,y,z);
  return p;
}



// WARNING: Unknown calling convention

GtsVertexClass * gts_vertex_class(void)

{
  uint uVar1;
  GtsPointClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo vertex_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_vertex_class::klass == (GtsVertexClass *)0x0) {
    pGVar3 = &vertex_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    vertex_info.name[0] = 'G';
    vertex_info.name[1] = 't';
    vertex_info.name[2] = 's';
    vertex_info.name[3] = 'V';
    vertex_info.name[4] = 'e';
    vertex_info.name[5] = 'r';
    vertex_info.name[6] = 't';
    vertex_info.name[7] = 'e';
    vertex_info.name[8] = 'x';
    vertex_info.name[9] = '\0';
    vertex_info.name[10] = '\0';
    vertex_info.name[11] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(vertex_info.name + uVar1 + 0xc) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x1c);
    vertex_info.object_size = 0x28;
    vertex_info.class_size = 100;
    vertex_info.class_init_func = vertex_class_init;
    vertex_info.object_init_func = vertex_init;
    parent_class = gts_point_class();
    gts_vertex_class::klass =
         (GtsVertexClass *)gts_object_class_new(&parent_class->parent_class,&vertex_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_vertex_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

GtsVertexClass * gts_color_vertex_class(void)

{
  uint uVar1;
  GtsVertexClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo gts_color_vertex_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_color_vertex_class::klass == (GtsVertexClass *)0x0) {
    pGVar3 = &gts_color_vertex_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    gts_color_vertex_info.name[0] = 'G';
    gts_color_vertex_info.name[1] = 't';
    gts_color_vertex_info.name[2] = 's';
    gts_color_vertex_info.name[3] = 'C';
    gts_color_vertex_info.name[4] = 'o';
    gts_color_vertex_info.name[5] = 'l';
    gts_color_vertex_info.name[6] = 'o';
    gts_color_vertex_info.name[7] = 'r';
    gts_color_vertex_info.name[8] = 'V';
    gts_color_vertex_info.name[9] = 'e';
    gts_color_vertex_info.name[10] = 'r';
    gts_color_vertex_info.name[11] = 't';
    gts_color_vertex_info.name[12] = 'e';
    gts_color_vertex_info.name[13] = 'x';
    gts_color_vertex_info.name[14] = '\0';
    gts_color_vertex_info.name[15] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(gts_color_vertex_info.name + uVar1 + 0x10) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x18);
    gts_color_vertex_info.object_size = 0x34;
    gts_color_vertex_info.class_size = 100;
    parent_class = gts_vertex_class();
    gts_color_vertex_class::klass =
         (GtsVertexClass *)
         gts_object_class_new((GtsObjectClass *)parent_class,&gts_color_vertex_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_color_vertex_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

GtsVertexClass * gts_vertex_normal_class(void)

{
  uint uVar1;
  GtsVertexClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo gts_vertex_normal_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_vertex_normal_class::klass == (GtsVertexClass *)0x0) {
    pGVar3 = &gts_vertex_normal_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    gts_vertex_normal_info.name[0] = 'G';
    gts_vertex_normal_info.name[1] = 't';
    gts_vertex_normal_info.name[2] = 's';
    gts_vertex_normal_info.name[3] = 'V';
    gts_vertex_normal_info.name[4] = 'e';
    gts_vertex_normal_info.name[5] = 'r';
    gts_vertex_normal_info.name[6] = 't';
    gts_vertex_normal_info.name[7] = 'e';
    gts_vertex_normal_info.name[8] = 'x';
    gts_vertex_normal_info.name[9] = 'N';
    gts_vertex_normal_info.name[10] = 'o';
    gts_vertex_normal_info.name[11] = 'r';
    gts_vertex_normal_info.name[12] = 'm';
    gts_vertex_normal_info.name[13] = 'a';
    gts_vertex_normal_info.name[14] = 'l';
    gts_vertex_normal_info.name[15] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(gts_vertex_normal_info.name + uVar1 + 0x10) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x18);
    gts_vertex_normal_info.object_size = 0x40;
    gts_vertex_normal_info.class_size = 100;
    gts_vertex_normal_info.class_init_func = gts_vertex_normal_class_init;
    parent_class = gts_vertex_class();
    gts_vertex_normal_class::klass =
         (GtsVertexClass *)
         gts_object_class_new((GtsObjectClass *)parent_class,&gts_vertex_normal_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_vertex_normal_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void vertex_clone(GtsObject *clone,GtsObject *object)

{
  GtsVertexClass *pGVar1;
  
  pGVar1 = gts_vertex_class();
  (*((pGVar1->parent_class).parent_class.parent_class)->clone)(clone,object);
  clone[3].klass = (GtsObjectClass *)0x0;
  return;
}



// WARNING: Unknown calling convention

void vertex_destroy(GtsObject *object)

{
  uint *puVar1;
  GtsObjectClass *pGVar2;
  GSList *i;
  GtsObjectClass *pGVar3;
  GtsVertexClass *pGVar4;
  GtsObjectClass *pGVar5;
  GSList *next;
  
  pGVar3 = object[3].klass;
  pGVar5 = pGVar3;
  if (pGVar3 != (GtsObjectClass *)0x0) {
    do {
      pGVar2 = *(GtsObjectClass **)&pGVar5->info;
      puVar1 = (uint *)(*(int *)(pGVar5->info).name + 8);
      *puVar1 = *puVar1 | 1;
      pGVar5 = pGVar2;
    } while (pGVar2 != (GtsObjectClass *)0x0);
    if (pGVar3 != (GtsObjectClass *)0x0) {
      do {
        pGVar5 = *(GtsObjectClass **)&pGVar3->info;
        gts_object_destroy(*(GtsObject **)(pGVar3->info).name);
        pGVar3 = pGVar5;
      } while (pGVar5 != (GtsObjectClass *)0x0);
      if (object[3].klass != (GtsObjectClass *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/gts/vertex.c",0x29,"vertex_destroy","vertex->segments == NULL");
      }
    }
  }
  pGVar4 = gts_vertex_class();
                    // WARNING: Could not recover jumptable at 0x0811c65c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar4->parent_class).parent_class.parent_class)->destroy)(object);
  return;
}



// WARNING: Unknown calling convention

GSList * edge_fan_list(GtsVertex *v,GtsSurface *surface,GtsFace *f,GtsEdge *e,GtsFace *first)

{
  GtsFace *f_00;
  GtsEdge *pGVar1;
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsEdge *enext;
  GtsEdge *e_00;
  GSList *pGVar4;
  GtsObjectClass *c;
  GtsObjectClass *pGVar5;
  GSList *i;
  GtsEdge *next;
  bool bVar6;
  GtsFace *local_20;
  
  local_20 = (GtsFace *)0x0;
  pGVar4 = e->triangles;
  bVar6 = true;
  if (pGVar4 != (GSList *)0x0) {
    do {
      while( true ) {
        f_00 = (GtsFace *)pGVar4->data;
        pGVar2 = (GtsObjectClass *)gts_face_class();
        if (pGVar2 == (GtsObjectClass *)0x0) break;
        if (f_00 != (GtsFace *)0x0) {
          pGVar5 = (f_00->triangle).object.klass;
          if (pGVar5 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar2 == pGVar5) {
                if ((f_00 != f) && (gVar3 = gts_face_has_parent_surface(f_00,surface), gVar3 != 0))
                {
                  if (local_20 != (GtsFace *)0x0) {
                    g_return_if_fail_warning(0,"edge_fan_list","neighbor == NULL");
                    return (GSList *)0x0;
                  }
                  pGVar4 = (GSList *)(&pGVar4->data)[1];
                  local_20 = f_00;
                  goto joined_r0x0811c7dc;
                }
                break;
              }
              pGVar5 = pGVar5->parent_class;
            } while (pGVar5 != (GtsObjectClass *)0x0);
          }
        }
        pGVar4 = (GSList *)(&pGVar4->data)[1];
joined_r0x0811c7dc:
        if (pGVar4 == (GSList *)0x0) goto LAB_0811c733;
      }
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      pGVar4 = (GSList *)(&pGVar4->data)[1];
    } while (pGVar4 != (GSList *)0x0);
LAB_0811c733:
    bVar6 = local_20 == (GtsFace *)0x0;
  }
  if ((local_20 == first) || (bVar6)) {
    return (GSList *)0x0;
  }
  e_00 = (local_20->triangle).e1;
  if (e_00 == e) {
    e_00 = (local_20->triangle).e3;
  }
  else {
    pGVar1 = (local_20->triangle).e2;
    if ((pGVar1 != e) && (e_00 = pGVar1, (local_20->triangle).e3 != e)) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/vertex.c",0x1dc,"edge_fan_list",0);
    }
  }
  if (((e_00->segment).v1 != v) && ((e_00->segment).v2 != v)) {
    g_return_if_fail_warning
              (0,"edge_fan_list","GTS_SEGMENT (enext)->v1 == v || GTS_SEGMENT (enext)->v2 == v");
    return (GSList *)0x0;
  }
  edge_fan_list(v,surface,local_20,e_00,first);
  pGVar4 = (GSList *)g_slist_prepend();
  return pGVar4;
}



// WARNING: Unknown calling convention

GSList * gts_vertex_fan_oriented(GtsVertex *v,GtsSurface *surface)

{
  GtsEdge *pGVar1;
  GtsFace *f;
  uint uVar2;
  GtsFace *pGVar3;
  GtsObjectClass *pGVar4;
  gboolean gVar5;
  GSList *pGVar6;
  GtsObjectClass *c_1;
  GtsObjectClass *c;
  GtsObjectClass *pGVar7;
  GSList *j;
  guint degree;
  uint uVar8;
  GtsFace *f1;
  GtsFace *t;
  uint local_4c;
  GtsFace *local_48;
  GSList *local_40;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *v1;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_fan_oriented","v != NULL");
    return (GSList *)0x0;
  }
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_fan_oriented","surface != NULL");
    return (GSList *)0x0;
  }
  local_40 = v->segments;
  if (local_40 != (GSList *)0x0) {
    local_4c = 2;
    local_48 = (GtsFace *)0x0;
    do {
      pGVar1 = (GtsEdge *)local_40->data;
      pGVar4 = (GtsObjectClass *)gts_edge_class();
      uVar2 = local_4c;
      pGVar3 = local_48;
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (pGVar1 != (GtsEdge *)0x0) {
        pGVar7 = (pGVar1->segment).object.klass;
        if (pGVar7 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar4 == pGVar7) {
              uVar8 = 0;
              t = (GtsFace *)0x0;
              pGVar6 = pGVar1->triangles;
              if (pGVar6 != (GSList *)0x0) {
                do {
                  pGVar4 = (GtsObjectClass *)gts_face_class();
                  f = (GtsFace *)pGVar6->data;
                  if (pGVar4 == (GtsObjectClass *)0x0) {
                    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                  }
                  else if (f != (GtsFace *)0x0) {
                    pGVar7 = (f->triangle).object.klass;
                    if (pGVar7 == (GtsObjectClass *)0x0) {
                      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
                    }
                    else {
                      do {
                        if (pGVar4 == pGVar7) {
                          gVar5 = gts_face_has_parent_surface(f,surface);
                          if (gVar5 != 0) {
                            t = (GtsFace *)pGVar6->data;
                            uVar8 = uVar8 + 1;
                          }
                          break;
                        }
                        pGVar7 = pGVar7->parent_class;
                      } while (pGVar7 != (GtsObjectClass *)0x0);
                    }
                  }
                  pGVar6 = (GSList *)(&pGVar6->data)[1];
                } while (pGVar6 != (GSList *)0x0);
                if (t != (GtsFace *)0x0) {
                  if (2 < uVar8) {
                    g_return_if_fail_warning(0,"gts_vertex_fan_oriented","degree <= 2");
                    return (GSList *)0x0;
                  }
                  pGVar3 = t;
                  if (uVar8 == 1) {
                    gts_triangle_vertices_edges
                              (&t->triangle,(GtsEdge *)0x0,&v1,&local_24,&local_28,&local_2c,
                               &local_30,&local_34);
                    if (v == local_24) {
                      local_30 = local_34;
                      local_34 = local_2c;
                    }
                    else if (v == local_28) {
                      local_34 = local_30;
                      local_30 = local_2c;
                    }
                    uVar2 = 1;
                    if (pGVar1 == local_34) {
                      uVar2 = local_4c;
                      pGVar3 = local_48;
                    }
                  }
                  else if (local_4c < uVar8) {
                    pGVar3 = local_48;
                  }
                }
              }
              break;
            }
            pGVar7 = pGVar7->parent_class;
          } while (pGVar7 != (GtsObjectClass *)0x0);
        }
      }
      local_48 = pGVar3;
      local_4c = uVar2;
      local_40 = local_40->next;
    } while (local_40 != (GSList *)0x0);
    if (local_48 != (GtsFace *)0x0) {
      gts_triangle_vertices_edges
                (&local_48->triangle,(GtsEdge *)0x0,&v1,&local_24,&local_28,&local_2c,&local_30,
                 &local_34);
      if (v == local_24) {
        local_30 = local_34;
        local_34 = local_2c;
      }
      else if (v == local_28) {
        local_34 = local_30;
        local_30 = local_2c;
      }
      pGVar1 = local_30;
      pGVar6 = edge_fan_list(v,surface,local_48,local_34,local_48);
      pGVar6 = (GSList *)g_slist_prepend(pGVar6,pGVar1);
      return pGVar6;
    }
  }
  return (GSList *)0x0;
}



// WARNING: Unknown calling convention

gboolean gts_vertex_is_boundary(GtsVertex *v,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsEdge *e;
  GtsObjectClass *pGVar2;
  GtsFace *pGVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GSList *i;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_is_boundary","v != NULL");
    return 0;
  }
  pGVar1 = v->segments;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return 0;
    }
    pGVar2 = (GtsObjectClass *)gts_edge_class();
    e = (GtsEdge *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else if (e != (GtsEdge *)0x0) {
      pGVar4 = (e->segment).object.klass;
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
      else {
        do {
          if (pGVar2 == pGVar4) {
            pGVar3 = gts_edge_is_boundary(e,surface);
            if (pGVar3 != (GtsFace *)0x0) {
              return 1;
            }
            break;
          }
          pGVar4 = pGVar4->parent_class;
        } while (pGVar4 != (GtsObjectClass *)0x0);
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

GSList * gts_vertex_neighbors(GtsVertex *v,GSList *list,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsEdge *e;
  GtsObjectClass *pGVar2;
  GtsFace *pGVar3;
  int iVar4;
  GtsObjectClass *c;
  GtsObjectClass *pGVar5;
  GSList *i;
  GtsSegment *s;
  GtsVertex *v1;
  GtsVertex *pGVar6;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_neighbors","v != NULL");
    return (GSList *)0x0;
  }
  pGVar1 = v->segments;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return list;
    }
    e = (GtsEdge *)pGVar1->data;
    pGVar6 = (e->segment).v1;
    if ((pGVar6 != v) || (pGVar6 = (e->segment).v2, v != pGVar6)) {
      if (surface == (GtsSurface *)0x0) {
LAB_0811ccd9:
        iVar4 = g_slist_find(list,pGVar6);
        if (iVar4 == 0) {
          list = (GSList *)g_slist_prepend(list,pGVar6);
        }
      }
      else {
        pGVar2 = (GtsObjectClass *)gts_edge_class();
        if (pGVar2 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          pGVar5 = (e->segment).object.klass;
          if (pGVar5 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar2 == pGVar5) {
                pGVar3 = gts_edge_has_parent_surface(e,surface);
                if (pGVar3 != (GtsFace *)0x0) goto LAB_0811ccd9;
                break;
              }
              pGVar5 = pGVar5->parent_class;
            } while (pGVar5 != (GtsObjectClass *)0x0);
          }
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

GSList * gts_vertex_faces(GtsVertex *v,GtsSurface *surface,GSList *list)

{
  GtsObjectClass **ppGVar1;
  GtsFace *f;
  GtsObjectClass *pGVar2;
  GtsObjectClass *pGVar3;
  gboolean gVar4;
  int iVar5;
  GtsObjectClass *c_1;
  GtsObjectClass *c;
  GtsObjectClass *pGVar6;
  GSList *j;
  GSList *local_20;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_faces","v != NULL");
    list = (GSList *)0x0;
  }
  else {
    for (local_20 = v->segments; local_20 != (GSList *)0x0; local_20 = local_20->next) {
LAB_0811cdb8:
      ppGVar1 = (GtsObjectClass **)local_20->data;
      pGVar2 = (GtsObjectClass *)gts_edge_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        local_20 = local_20->next;
joined_r0x0811ce5f:
        if (local_20 == (GSList *)0x0) {
          return list;
        }
        goto LAB_0811cdb8;
      }
      if (ppGVar1 == (GtsObjectClass **)0x0) {
LAB_0811ce54:
        local_20 = local_20->next;
        goto joined_r0x0811ce5f;
      }
      pGVar3 = *ppGVar1;
      if (pGVar3 != (GtsObjectClass *)0x0) {
LAB_0811cde7:
        if (pGVar2 != pGVar3) goto LAB_0811cde0;
        for (pGVar2 = ppGVar1[5]; pGVar2 != (GtsObjectClass *)0x0;
            pGVar2 = *(GtsObjectClass **)((pGVar2->info).name + 4)) {
          f = *(GtsFace **)(pGVar2->info).name;
          pGVar3 = (GtsObjectClass *)gts_face_class();
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else if (f != (GtsFace *)0x0) {
            pGVar6 = (f->triangle).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            }
            else {
              do {
                if (pGVar3 == pGVar6) {
                  if (((surface == (GtsSurface *)0x0) ||
                      (gVar4 = gts_face_has_parent_surface(f,surface), gVar4 != 0)) &&
                     (iVar5 = g_slist_find(list,f), iVar5 == 0)) {
                    list = (GSList *)g_slist_prepend(list,f);
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
        }
        goto LAB_0811ce54;
      }
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
  }
  return list;
LAB_0811cde0:
  pGVar3 = pGVar3->parent_class;
  if (pGVar3 == (GtsObjectClass *)0x0) goto LAB_0811ce54;
  goto LAB_0811cde7;
}



// WARNING: Unknown calling convention

GSList * gts_vertex_triangles(GtsVertex *v,GSList *list)

{
  GSList *pGVar1;
  GtsObjectClass **ppGVar2;
  GtsObjectClass *pGVar3;
  int iVar4;
  GtsObjectClass *c;
  GtsObjectClass *pGVar5;
  GSList *j;
  GSList *i;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_triangles","v != NULL");
    return (GSList *)0x0;
  }
  pGVar1 = v->segments;
  do {
    while( true ) {
      while( true ) {
        if (pGVar1 == (GSList *)0x0) {
          return list;
        }
        ppGVar2 = (GtsObjectClass **)pGVar1->data;
        pGVar3 = (GtsObjectClass *)gts_edge_class();
        if (pGVar3 != (GtsObjectClass *)0x0) break;
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        pGVar1 = pGVar1->next;
      }
      if (ppGVar2 != (GtsObjectClass **)0x0) break;
LAB_0811cfc1:
      pGVar1 = pGVar1->next;
    }
    pGVar5 = *ppGVar2;
    if (pGVar5 != (GtsObjectClass *)0x0) {
LAB_0811cf97:
      if (pGVar3 != pGVar5) break;
      for (pGVar3 = ppGVar2[5]; pGVar3 != (GtsObjectClass *)0x0;
          pGVar3 = *(GtsObjectClass **)((pGVar3->info).name + 4)) {
        iVar4 = g_slist_find(list,*(undefined4 *)(pGVar3->info).name);
        if (iVar4 == 0) {
          list = (GSList *)g_slist_prepend(list,*(undefined4 *)(pGVar3->info).name);
        }
      }
      goto LAB_0811cfc1;
    }
    g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    pGVar1 = pGVar1->next;
  } while( true );
  pGVar5 = pGVar5->parent_class;
  if (pGVar5 == (GtsObjectClass *)0x0) goto LAB_0811cfc1;
  goto LAB_0811cf97;
}



// WARNING: Unknown calling convention

guint gts_vertex_is_contact(GtsVertex *v,gboolean sever)

{
  GtsTriangle *t_00;
  gpointer *ppvVar1;
  GSList *pGVar2;
  GSList *pGVar3;
  GSList *i;
  GtsEdge *pGVar4;
  GtsVertex *with_00;
  GtsTriangle *t;
  GtsVertex *with;
  guint local_20;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_is_contact","v != NULL");
    return 0;
  }
  pGVar2 = gts_vertex_triangles(v,(GSList *)0x0);
  local_20 = 0;
  pGVar3 = pGVar2;
  if (pGVar2 != (GSList *)0x0) {
    do {
      *(GSList **)((int)pGVar3->data + 4) = pGVar3;
      ppvVar1 = &pGVar3->data;
      pGVar3 = (GSList *)ppvVar1[1];
    } while ((GSList *)ppvVar1[1] != (GSList *)0x0);
    local_20 = 0;
    pGVar3 = pGVar2;
    with_00 = v;
    do {
      t_00 = (GtsTriangle *)pGVar3->data;
      if ((t_00->object).reserved != (gpointer)0x0) {
        if ((local_20 != 0) && (sever != 0)) {
          with_00 = (GtsVertex *)gts_object_clone((GtsObject *)v);
        }
        (t_00->object).reserved = (gpointer)0x0;
        pGVar4 = replace_vertex(t_00,(GtsEdge *)0x0,v,with_00);
        triangle_next(pGVar4,v,with_00);
        pGVar4 = replace_vertex(t_00,pGVar4,v,with_00);
        triangle_next(pGVar4,v,with_00);
        local_20 = local_20 + 1;
      }
      pGVar3 = (GSList *)(&pGVar3->data)[1];
    } while (pGVar3 != (GSList *)0x0);
  }
  g_slist_free(pGVar2);
  return local_20;
}



// WARNING: Removing unreachable block (ram,0x0811d4f0)
// WARNING: Removing unreachable block (ram,0x0811d31c)
// WARNING: Unknown calling convention

void vertex_normal_attributes(GtsVertex *v,GtsObject *e,GtsObject *t)

{
  double dVar1;
  double dVar2;
  double dVar3;
  GtsVertexClass **ppGVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  GtsObjectClass *pGVar14;
  GtsVertexClass *pGVar15;
  guint i;
  guint j;
  uint uVar16;
  int iVar17;
  guint i_1;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar18;
  GtsObjectClass *c_2;
  GtsObjectClass *c_3;
  GtsObjectClass *c_4;
  GtsVertexClass *pGVar19;
  gdouble b;
  gdouble l1;
  gdouble a;
  gdouble l2;
  GtsVector det;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  pGVar14 = (GtsObjectClass *)gts_edge_class();
  if (pGVar14 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e != (GtsObject *)0x0) {
    pGVar18 = e->klass;
    if (pGVar18 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar14 == pGVar18) {
          pGVar14 = (GtsObjectClass *)gts_triangle_class();
          if (pGVar14 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            goto LAB_0811d630;
          }
          if (t == (GtsObject *)0x0) goto LAB_0811d630;
          pGVar18 = t->klass;
          if (pGVar18 != (GtsObjectClass *)0x0) goto LAB_0811d20b;
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          goto LAB_0811d630;
        }
        pGVar18 = pGVar18->parent_class;
      } while (pGVar18 != (GtsObjectClass *)0x0);
    }
  }
  g_return_if_fail_warning(0,"vertex_normal_attributes","GTS_IS_EDGE (e)");
  return;
LAB_0811d20b:
  if (pGVar14 == pGVar18) {
    pGVar15 = gts_vertex_normal_class();
    if (pGVar15 == (GtsVertexClass *)0x0) goto LAB_0811d338;
    if (e[1].klass == (GtsObjectClass *)0x0) goto LAB_0811d358;
    pGVar19 = *(GtsVertexClass **)((e[1].klass)->info).name;
    if (pGVar19 == (GtsVertexClass *)0x0) goto LAB_0811d588;
    goto LAB_0811d246;
  }
  pGVar18 = pGVar18->parent_class;
  if (pGVar18 == (GtsObjectClass *)0x0) {
LAB_0811d630:
    g_return_if_fail_warning(0,"vertex_normal_attributes","GTS_IS_TRIANGLE (t)");
    return;
  }
  goto LAB_0811d20b;
  while (pGVar19 = (GtsVertexClass *)(pGVar19->parent_class).parent_class.parent_class,
        pGVar19 != (GtsVertexClass *)0x0) {
LAB_0811d246:
    if (pGVar15 == pGVar19) {
      pGVar15 = gts_vertex_normal_class();
      ppGVar4 = (GtsVertexClass **)e[1].reserved;
      if (pGVar15 == (GtsVertexClass *)0x0) {
LAB_0811d338:
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (ppGVar4 != (GtsVertexClass **)0x0) {
        pGVar19 = *ppGVar4;
        if (pGVar19 == (GtsVertexClass *)0x0) {
LAB_0811d588:
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar15 == pGVar19) {
              pGVar14 = e[1].klass;
              dVar1 = *(double *)((pGVar14->info).name + 0xc);
              dVar3 = *(double *)(ppGVar4 + 3) - dVar1;
              dVar2 = *(double *)((pGVar14->info).name + 0x14);
              dVar7 = *(double *)(ppGVar4 + 5) - dVar2;
              dVar5 = ABS(dVar7);
              dVar6 = ABS(dVar3);
              if (dVar5 <= dVar6) {
                dVar1 = (v->p).x - dVar1;
              }
              else {
                dVar1 = (v->p).y - dVar2;
                dVar6 = dVar5;
                dVar3 = dVar7;
              }
              dVar2 = *(double *)((pGVar14->info).name + 0x1c);
              dVar5 = *(double *)(ppGVar4 + 7) - dVar2;
              if (dVar6 < ABS(dVar5)) {
                dVar1 = (v->p).z - dVar2;
                dVar3 = dVar5;
              }
              if (dVar3 == 0.0) {
                dVar1 = 0.0;
              }
              else {
                dVar1 = dVar1 / dVar3;
              }
              iVar17 = 0;
              do {
                *(double *)(&v[1].p.object.klass + iVar17 * 2) =
                     *(double *)(ppGVar4 + (iVar17 + 4) * 2 + 2) * dVar1 +
                     *(double *)((pGVar14->info).name + iVar17 * 8 + 0x28) * (1.0 - dVar1);
                iVar17 = iVar17 + 1;
              } while (iVar17 != 3);
              return;
            }
            pGVar19 = (GtsVertexClass *)(pGVar19->parent_class).parent_class.parent_class;
          } while (pGVar19 != (GtsVertexClass *)0x0);
        }
      }
      break;
    }
  }
LAB_0811d358:
  gts_triangle_vertices((GtsTriangle *)t,local_20,&local_24,&local_28);
  pGVar15 = gts_vertex_normal_class();
  if (pGVar15 != (GtsVertexClass *)0x0) {
    if (local_20[0] == (GtsVertex *)0x0) {
      return;
    }
    pGVar19 = (GtsVertexClass *)(local_20[0]->p).object.klass;
    if (pGVar19 != (GtsVertexClass *)0x0) {
      while (pGVar15 != pGVar19) {
        pGVar19 = (GtsVertexClass *)(pGVar19->parent_class).parent_class.parent_class;
        if (pGVar19 == (GtsVertexClass *)0x0) {
          return;
        }
      }
      pGVar15 = gts_vertex_normal_class();
      if (pGVar15 == (GtsVertexClass *)0x0) goto LAB_0811d696;
      if (local_24 == (GtsVertex *)0x0) {
        return;
      }
      pGVar19 = (GtsVertexClass *)(local_24->p).object.klass;
      if (pGVar19 != (GtsVertexClass *)0x0) {
        while (pGVar15 != pGVar19) {
          pGVar19 = (GtsVertexClass *)(pGVar19->parent_class).parent_class.parent_class;
          if (pGVar19 == (GtsVertexClass *)0x0) {
            return;
          }
        }
        pGVar15 = gts_vertex_normal_class();
        if (pGVar15 == (GtsVertexClass *)0x0) goto LAB_0811d696;
        if (local_28 == (GtsVertex *)0x0) {
          return;
        }
        pGVar19 = (GtsVertexClass *)(local_28->p).object.klass;
        if (pGVar19 != (GtsVertexClass *)0x0) {
          while (pGVar15 != pGVar19) {
            pGVar19 = (GtsVertexClass *)(pGVar19->parent_class).parent_class.parent_class;
            if (pGVar19 == (GtsVertexClass *)0x0) {
              return;
            }
          }
          dVar1 = (local_20[0]->p).x;
          dVar2 = (local_20[0]->p).y;
          dVar3 = (local_20[0]->p).z;
          dVar6 = (local_24->p).x - dVar1;
          dVar12 = (local_24->p).y - dVar2;
          dVar13 = (local_24->p).z - dVar3;
          dVar5 = (local_28->p).x - dVar1;
          dVar11 = (local_28->p).y - dVar2;
          dVar10 = (local_28->p).z - dVar3;
          det[0] = dVar12 * dVar10 - dVar13 * dVar11;
          det[1] = dVar13 * dVar5 - dVar6 * dVar10;
          det[2] = dVar6 * dVar11 - dVar12 * dVar5;
          uVar16 = (uint)(ABS(det[0]) < ABS(det[1]));
          dVar9 = ABS(det[2]);
          dVar8 = ABS(det[uVar16]);
          dVar7 = det[uVar16];
          if (dVar8 <= dVar9 || dVar9 != dVar8) {
            dVar7 = det[2];
          }
          if (dVar8 < dVar9) {
            uVar16 = 2;
          }
          if (dVar7 != 0.0) {
            dVar1 = (v->p).x - dVar1;
            dVar2 = (v->p).y - dVar2;
            dVar3 = (v->p).z - dVar3;
            if (uVar16 == 1) {
              dVar5 = (dVar5 * dVar3 - dVar10 * dVar1) / det[1];
              dVar1 = (dVar13 * dVar1 - dVar3 * dVar6) / det[1];
            }
            else if (uVar16 == 2) {
              dVar5 = (dVar11 * dVar1 - dVar5 * dVar2) / det[2];
              dVar1 = det[2] / (dVar6 * dVar2 - dVar1 * dVar12);
            }
            else {
              dVar5 = (dVar10 * dVar2 - dVar11 * dVar3) / det[0];
              dVar1 = det[0] / (dVar12 * dVar3 - dVar2 * dVar13);
            }
            iVar17 = 0;
            do {
              *(double *)(&v[1].p.object.klass + iVar17 * 2) =
                   *(double *)(&local_28[1].p.object.klass + iVar17 * 2) * dVar1 +
                   *(double *)(&local_24[1].p.object.klass + iVar17 * 2) * dVar5 +
                   *(double *)(&local_20[0][1].p.object.klass + iVar17 * 2) *
                   ((1.0 - dVar5) - dVar1);
              iVar17 = iVar17 + 1;
            } while (iVar17 != 3);
            return;
          }
          g_log(0,0x10,"vertex_normal_attributes: det[%d] == 0.",uVar16);
          return;
        }
      }
    }
    g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    return;
  }
LAB_0811d696:
  g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  return;
}



// WARNING: Unknown calling convention

void edge_class_init(GtsObjectClass *klass)

{
  klass->clone = edge_clone;
  klass->destroy = edge_destroy;
  return;
}



// WARNING: Unknown calling convention

void edge_init(GtsEdge *edge)

{
  edge->triangles = (GSList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void triangle_vertices_edges(GtsTriangle *t,GtsEdge *e,GtsVertex **v,GtsEdge **ee1,GtsEdge **ee2)

{
  GtsEdge *pGVar1;
  GtsVertex *pGVar2;
  GtsEdge *pGVar3;
  GtsEdge *e3;
  GtsVertex *pGVar4;
  GtsEdge *e2;
  GtsEdge *pGVar5;
  GtsEdge *pGVar6;
  GtsEdge *e1;
  GtsEdge *pGVar7;
  GtsVertex *v1;
  
  pGVar6 = t->e1;
  pGVar1 = t->e2;
  pGVar2 = (e->segment).v1;
  pGVar3 = t->e3;
  pGVar5 = pGVar1;
  pGVar7 = pGVar3;
  if (((pGVar6 != e) && (pGVar5 = pGVar3, pGVar7 = pGVar6, pGVar1 != e)) &&
     (pGVar5 = pGVar1, pGVar3 != e)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/gts/edge.c",0x165,"triangle_vertices_edges",&DAT_0815ff39)
    ;
  }
  pGVar4 = (pGVar5->segment).v1;
  pGVar6 = pGVar7;
  if ((pGVar4 == pGVar2) ||
     (((pGVar5->segment).v2 != pGVar2 &&
      (pGVar4 = (pGVar7->segment).v1, pGVar6 = pGVar5, pGVar5 = pGVar7, pGVar4 == pGVar2)))) {
    *v = (pGVar5->segment).v2;
  }
  else {
    *v = pGVar4;
  }
  *ee1 = pGVar5;
  *ee2 = pGVar6;
  return;
}



// WARNING: Unknown calling convention

GtsEdge * next_edge(GtsTriangle *t,GtsEdge *e1,GtsEdge *e)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  GtsEdge *pGVar5;
  GtsVertex *v1;
  
  pGVar1 = (e->segment).v2;
  pGVar2 = (e->segment).v1;
  pGVar5 = t->e1;
  if (((((pGVar5 == e1) || (e == pGVar5)) ||
       ((pGVar3 = (pGVar5->segment).v1, pGVar3 != pGVar2 &&
        (((pGVar4 = (pGVar5->segment).v2, pGVar4 != pGVar2 && (pGVar1 != pGVar3)) &&
         (pGVar1 != pGVar4)))))) &&
      (((pGVar5 = t->e2, pGVar5 == e1 || (e == pGVar5)) ||
       ((pGVar3 = (pGVar5->segment).v1, pGVar3 != pGVar2 &&
        (((pGVar4 = (pGVar5->segment).v2, pGVar4 != pGVar2 && (pGVar1 != pGVar3)) &&
         (pGVar1 != pGVar4)))))))) &&
     (((pGVar5 = t->e3, pGVar5 == e1 || (e == pGVar5)) ||
      ((pGVar3 = (pGVar5->segment).v1, pGVar3 != pGVar2 &&
       (((pGVar4 = (pGVar5->segment).v2, pGVar4 != pGVar2 && (pGVar1 != pGVar3)) &&
        (pGVar1 != pGVar4)))))))) {
                    // WARNING: Subroutine does not return
    g_assertion_message(0,"../../src/gts/edge.c",0x1ae,"next_edge",0);
  }
  return pGVar5;
}



// WARNING: Unknown calling convention

void triangle_next(GtsEdge *e1,GtsEdge *e)

{
  GSList *pGVar1;
  GtsTriangle *t_00;
  GtsTriangle *t;
  GtsEdge *e1_00;
  GSList *i;
  
  for (pGVar1 = e1->triangles; pGVar1 != (GSList *)0x0; pGVar1 = (GSList *)(&pGVar1->data)[1]) {
    t_00 = (GtsTriangle *)pGVar1->data;
    if ((t_00->object).reserved != (gpointer)0x0) {
      (t_00->object).reserved = (gpointer)0x0;
      e1_00 = next_edge(t_00,e1,e);
      triangle_next(e1_00,e);
    }
  }
  return;
}



// WARNING: Unknown calling convention

guint gts_edge_is_contact(GtsEdge *e)

{
  GtsTriangle *t_00;
  GSList *pGVar1;
  GSList *triangles;
  GSList *pGVar2;
  GSList *i;
  GtsEdge *pGVar3;
  GtsTriangle *t;
  guint local_24;
  
  if (e != (GtsEdge *)0x0) {
    pGVar1 = gts_vertex_triangles((e->segment).v1,(GSList *)0x0);
    pGVar2 = gts_vertex_triangles((e->segment).v2,pGVar1);
    for (pGVar1 = pGVar2; pGVar1 != (GSList *)0x0; pGVar1 = pGVar1->next) {
      *(GSList **)((int)pGVar1->data + 4) = pGVar1;
    }
    pGVar1 = e->triangles;
    local_24 = 0;
    for (; pGVar1 != (GSList *)0x0; pGVar1 = (GSList *)(&pGVar1->data)[1]) {
      t_00 = (GtsTriangle *)pGVar1->data;
      if ((t_00->object).reserved != (gpointer)0x0) {
        (t_00->object).reserved = (gpointer)0x0;
        pGVar3 = next_edge(t_00,(GtsEdge *)0x0,e);
        triangle_next(pGVar3,e);
        pGVar3 = next_edge(t_00,pGVar3,e);
        triangle_next(pGVar3,e);
        local_24 = local_24 + 1;
      }
    }
    g_slist_foreach(pGVar2,gts_object_reset_reserved,0);
    g_slist_free(pGVar2);
    return local_24;
  }
  g_return_if_fail_warning(0,"gts_edge_is_contact","e != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void gts_edge_replace(GtsEdge *e,GtsEdge *with)

{
  gpointer pvVar1;
  GtsEdge *pGVar2;
  GSList *pGVar3;
  int iVar4;
  GtsTriangle *t;
  GSList *i;
  GSList *pGVar5;
  
  if (((with == (GtsEdge *)0x0) || (e == (GtsEdge *)0x0)) || (e == with)) {
    g_return_if_fail_warning(0,"gts_edge_replace","e != NULL && with != NULL && e != with");
    return;
  }
  pGVar5 = e->triangles;
  pGVar3 = (GSList *)0x0;
  if (pGVar5 != (GSList *)0x0) {
    do {
      pvVar1 = pGVar5->data;
      if (*(GtsEdge **)((int)pvVar1 + 0xc) == e) {
        *(GtsEdge **)((int)pvVar1 + 0xc) = with;
        if (*(GtsEdge **)((int)pvVar1 + 0x10) == e) goto LAB_0811db28;
LAB_0811daed:
        pGVar2 = *(GtsEdge **)((int)pvVar1 + 0x14);
      }
      else {
        if (*(GtsEdge **)((int)pvVar1 + 0x10) != e) goto LAB_0811daed;
LAB_0811db28:
        pGVar2 = *(GtsEdge **)((int)pvVar1 + 0x14);
        *(GtsEdge **)((int)pvVar1 + 0x10) = with;
      }
      if (pGVar2 == e) {
        *(GtsEdge **)((int)pvVar1 + 0x14) = with;
      }
      iVar4 = g_slist_find(with->triangles,pvVar1);
      if (iVar4 == 0) {
        pGVar3 = (GSList *)g_slist_prepend(with->triangles,pvVar1);
        with->triangles = pGVar3;
      }
      pGVar5 = pGVar5->next;
    } while (pGVar5 != (GSList *)0x0);
    pGVar3 = e->triangles;
  }
  g_slist_free(pGVar3);
  e->triangles = (GSList *)0x0;
  return;
}



// WARNING: Unknown calling convention

GtsEdge * gts_edge_new(GtsEdgeClass *klass,GtsVertex *v1,GtsVertex *v2)

{
  GtsEdge *pGVar1;
  
  pGVar1 = (GtsEdge *)gts_segment_new(&klass->parent_class,v1,v2);
  return pGVar1;
}



// WARNING: Unknown calling convention

GtsEdgeClass * gts_edge_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo edge_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_edge_class::klass == (GtsEdgeClass *)0x0) {
    pGVar3 = &edge_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    edge_info.name[0] = 'G';
    edge_info.name[1] = 't';
    edge_info.name[2] = 's';
    edge_info.name[3] = 'E';
    edge_info.name[4] = 'd';
    edge_info.name[5] = 'g';
    edge_info.name[6] = 'e';
    edge_info.name[7] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(edge_info.name + uVar1 + 8) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x20);
    edge_info.object_size = 0x18;
    edge_info.class_size = 0x5c;
    edge_info.class_init_func = edge_class_init;
    edge_info.object_init_func = edge_init;
    parent_class = (GtsObjectClass *)gts_segment_class();
    gts_edge_class::klass = (GtsEdgeClass *)gts_object_class_new(parent_class,&edge_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_edge_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void edge_destroy(GtsObject *object)

{
  GtsObject *pGVar1;
  GSList *i;
  GtsObject *pGVar2;
  GtsEdgeClass *pGVar3;
  GSList *next;
  
  pGVar2 = (GtsObject *)object[1].flags;
  if (pGVar2 != (GtsObject *)0x0) {
    do {
      pGVar1 = (GtsObject *)pGVar2->reserved;
      gts_object_destroy((GtsObject *)pGVar2->klass);
      pGVar2 = pGVar1;
    } while (pGVar1 != (GtsObject *)0x0);
    if (object[1].flags != 0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/gts/edge.c",0x23,"edge_destroy","edge->triangles == NULL");
    }
  }
  pGVar3 = gts_edge_class();
                    // WARNING: Could not recover jumptable at 0x0811dc94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar3->parent_class).parent_class.parent_class)->destroy)(object);
  return;
}



// WARNING: Unknown calling convention

void gts_edge_remove(GtsEdge *edge)

{
  GtsVertex *pGVar1;
  GSList *pGVar2;
  
  pGVar1 = (edge->segment).v1;
  pGVar2 = (GSList *)g_slist_remove(pGVar1->segments,edge);
  pGVar1->segments = pGVar2;
  pGVar1 = (edge->segment).v2;
  pGVar2 = (GSList *)g_slist_remove(pGVar1->segments,edge);
  pGVar1->segments = pGVar2;
  edge_destroy((GtsObject *)edge);
  return;
}



// WARNING: Unknown calling convention

void edge_clone(GtsObject *clone,GtsObject *object)

{
  GtsEdgeClass *pGVar1;
  
  pGVar1 = gts_edge_class();
  (*((pGVar1->parent_class).parent_class.parent_class)->clone)(clone,object);
  clone[1].reserved = (gpointer)0x0;
  clone[1].klass = (GtsObjectClass *)0x0;
  clone[1].flags = 0;
  return;
}



// WARNING: Unknown calling convention

GtsFace * gts_edge_has_any_parent_surface(GtsEdge *e)

{
  GSList *pGVar1;
  GtsFace *pGVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GSList *i;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_has_any_parent_surface","e != NULL");
    return (GtsFace *)0x0;
  }
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsFace *)0x0;
    }
    pGVar2 = (GtsFace *)pGVar1->data;
    pGVar3 = (GtsObjectClass *)gts_face_class();
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else if (pGVar2 != (GtsFace *)0x0) {
      pGVar4 = (pGVar2->triangle).object.klass;
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
      else {
        do {
          if (pGVar3 == pGVar4) {
            if (pGVar2->surfaces != (GSList *)0x0) {
              return pGVar2;
            }
            break;
          }
          pGVar4 = pGVar4->parent_class;
        } while (pGVar4 != (GtsObjectClass *)0x0);
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

gboolean gts_edge_belongs_to_tetrahedron(GtsEdge *e)

{
  GSList *pGVar1;
  GtsEdge *e3;
  GtsObjectClass *pGVar2;
  GtsTriangle *pGVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GtsSegment *s5;
  GSList *j;
  GSList *local_40;
  GtsVertex *local_34;
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsEdge *local_24;
  GtsEdge *local_20 [4];
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_belongs_to_tetrahedron","e != NULL");
  }
  else {
    local_40 = e->triangles;
    if (local_40 != (GSList *)0x0) {
      do {
        pGVar1 = (GSList *)(&local_40->data)[1];
        triangle_vertices_edges((GtsTriangle *)local_40->data,e,&local_28,local_20,&local_24);
        for (; pGVar1 != (GSList *)0x0; pGVar1 = (GSList *)(&pGVar1->data)[1]) {
          triangle_vertices_edges((GtsTriangle *)pGVar1->data,e,&local_34,&local_2c,&local_30);
          e3 = (GtsEdge *)gts_vertices_are_connected(local_28,local_34);
          pGVar2 = (GtsObjectClass *)gts_edge_class();
          if (pGVar2 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else if (e3 != (GtsEdge *)0x0) {
            pGVar4 = (e3->segment).object.klass;
            if (pGVar4 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            }
            else {
              do {
                if (pGVar2 == pGVar4) {
                  pGVar3 = gts_triangle_use_edges(local_20[0],local_2c,e3);
                  if ((pGVar3 != (GtsTriangle *)0x0) &&
                     (pGVar3 = gts_triangle_use_edges(local_24,local_30,e3),
                     pGVar3 != (GtsTriangle *)0x0)) {
                    return 1;
                  }
                  break;
                }
                pGVar4 = pGVar4->parent_class;
              } while (pGVar4 != (GtsObjectClass *)0x0);
            }
          }
        }
        local_40 = (GSList *)(&local_40->data)[1];
      } while (local_40 != (GSList *)0x0);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

gboolean gts_edge_manifold_faces(GtsEdge *e,GtsSurface *s,GtsFace **f1,GtsFace **f2)

{
  GtsFace *f;
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GSList *i;
  GSList *pGVar4;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_manifold_faces","e != NULL");
  }
  else if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_manifold_faces","s != NULL");
  }
  else if (f1 == (GtsFace **)0x0) {
    g_return_if_fail_warning(0,"gts_edge_manifold_faces","f1 != NULL");
  }
  else {
    if (f2 != (GtsFace **)0x0) {
      pGVar4 = e->triangles;
      *f2 = (GtsFace *)0x0;
      *f1 = (GtsFace *)0x0;
      if (pGVar4 != (GSList *)0x0) {
        do {
          pGVar1 = (GtsObjectClass *)gts_face_class();
          f = (GtsFace *)pGVar4->data;
          if (pGVar1 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else if (f != (GtsFace *)0x0) {
            pGVar3 = (f->triangle).object.klass;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            }
            else {
              do {
                if (pGVar1 == pGVar3) {
                  gVar2 = gts_face_has_parent_surface(f,s);
                  if (gVar2 != 0) {
                    if (*f1 == (GtsFace *)0x0) {
                      *f1 = (GtsFace *)pGVar4->data;
                    }
                    else {
                      if (*f2 != (GtsFace *)0x0) {
                        return 0;
                      }
                      *f2 = (GtsFace *)pGVar4->data;
                    }
                  }
                  break;
                }
                pGVar3 = pGVar3->parent_class;
              } while (pGVar3 != (GtsObjectClass *)0x0);
            }
          }
          pGVar4 = (GSList *)(&pGVar4->data)[1];
        } while (pGVar4 != (GSList *)0x0);
        if (*f1 != (GtsFace *)0x0) {
          return (uint)(*f2 != (GtsFace *)0x0);
        }
      }
      return 0;
    }
    g_return_if_fail_warning(0,"gts_edge_manifold_faces","f2 != NULL");
  }
  return 0;
}



// WARNING: Unknown calling convention

guint gts_edge_face_number(GtsEdge *e,GtsSurface *s)

{
  GSList *pGVar1;
  GtsFace *f;
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GSList *i;
  guint gVar5;
  guint nt;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_face_number","e != NULL");
    return 0;
  }
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_face_number","s != NULL");
    return 0;
  }
  pGVar1 = e->triangles;
  gVar5 = 0;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return gVar5;
    }
    pGVar2 = (GtsObjectClass *)gts_face_class();
    f = (GtsFace *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else if (f != (GtsFace *)0x0) {
      pGVar4 = (f->triangle).object.klass;
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
      else {
        do {
          if (pGVar2 == pGVar4) {
            gVar3 = gts_face_has_parent_surface(f,s);
            gVar5 = (gVar5 + 1) - (uint)(gVar3 == 0);
            break;
          }
          pGVar4 = pGVar4->parent_class;
        } while (pGVar4 != (GtsObjectClass *)0x0);
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

GtsFace * gts_edge_is_boundary(GtsEdge *e,GtsSurface *surface)

{
  GtsFace *f_00;
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GSList *i;
  GSList *pGVar4;
  GtsFace *pGVar5;
  GtsFace *f;
  
  if (e == (GtsEdge *)0x0) {
    pGVar5 = (GtsFace *)0x0;
    g_return_if_fail_warning(0,"gts_edge_is_boundary","e != NULL");
  }
  else {
    pGVar4 = e->triangles;
    if (pGVar4 == (GSList *)0x0) {
LAB_0811e30a:
      pGVar5 = (GtsFace *)0x0;
    }
    else {
      pGVar5 = (GtsFace *)0x0;
      do {
        pGVar1 = (GtsObjectClass *)gts_face_class();
        f_00 = (GtsFace *)pGVar4->data;
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (f_00 != (GtsFace *)0x0) {
          pGVar3 = (f_00->triangle).object.klass;
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar1 == pGVar3) {
                if (surface != (GtsSurface *)0x0) {
                  gVar2 = gts_face_has_parent_surface(f_00,surface);
                  if (gVar2 == 0) break;
                }
                if (pGVar5 != (GtsFace *)0x0) goto LAB_0811e30a;
                pGVar5 = (GtsFace *)pGVar4->data;
                break;
              }
              pGVar3 = pGVar3->parent_class;
            } while (pGVar3 != (GtsObjectClass *)0x0);
          }
        }
        pGVar4 = (GSList *)(&pGVar4->data)[1];
      } while (pGVar4 != (GSList *)0x0);
    }
  }
  return pGVar5;
}



// WARNING: Unknown calling convention

GtsFace * gts_edge_has_parent_surface(GtsEdge *e,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsFace *f;
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GSList *i;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_has_parent_surface","e != NULL");
    return (GtsFace *)0x0;
  }
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsFace *)0x0;
    }
    pGVar2 = (GtsObjectClass *)gts_face_class();
    f = (GtsFace *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else if (f != (GtsFace *)0x0) {
      pGVar4 = (f->triangle).object.klass;
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
      else {
        do {
          if (pGVar2 == pGVar4) {
            gVar3 = gts_face_has_parent_surface(f,surface);
            if (gVar3 != 0) {
              return (GtsFace *)pGVar1->data;
            }
            break;
          }
          pGVar4 = pGVar4->parent_class;
        } while (pGVar4 != (GtsObjectClass *)0x0);
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

GSList * gts_edges_from_vertices(GSList *vertices,GtsSurface *parent)

{
  GtsEdge *pGVar1;
  GtsEdge *e;
  undefined4 uVar2;
  GtsObjectClass *pGVar3;
  GtsFace *pGVar4;
  int iVar5;
  GtsObjectClass *c;
  GtsObjectClass *pGVar6;
  GSList *j;
  GHashTable *hash;
  GSList *local_24;
  GSList *local_20;
  
  if (parent == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_edges_from_vertices","parent != NULL");
    local_24 = (GSList *)0x0;
  }
  else {
    uVar2 = g_hash_table_new(0,0);
    local_24 = (GSList *)0x0;
    if (vertices != (GSList *)0x0) {
      local_20 = vertices;
      do {
        for (pGVar1 = *(GtsEdge **)((int)local_20->data + 0x24); pGVar1 != (GtsEdge *)0x0;
            pGVar1 = *(GtsEdge **)((int)&pGVar1->segment + 4)) {
          e = *(GtsEdge **)&pGVar1->segment;
          pGVar3 = (GtsObjectClass *)gts_edge_class();
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else if (e != (GtsEdge *)0x0) {
            pGVar6 = (e->segment).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            }
            else {
              do {
                if (pGVar3 == pGVar6) {
                  pGVar4 = gts_edge_has_parent_surface(e,parent);
                  if ((pGVar4 != (GtsFace *)0x0) &&
                     (iVar5 = g_hash_table_lookup(uVar2,e), iVar5 == 0)) {
                    local_24 = (GSList *)g_slist_prepend(local_24,e);
                    g_hash_table_insert(uVar2,e,local_20);
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
        }
        local_20 = local_20->next;
      } while (local_20 != (GSList *)0x0);
    }
    g_hash_table_destroy(uVar2);
  }
  return local_24;
}



// WARNING: Unknown calling convention

GtsEdge * gts_edge_is_duplicate(GtsEdge *e)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GSList *pGVar3;
  GtsEdge *pGVar4;
  GtsObjectClass *pGVar5;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar6;
  GtsSegment *s;
  GtsSegment *s_1;
  GSList *i;
  GtsVertex *v2;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_is_duplicate","e != NULL");
    return (GtsEdge *)0x0;
  }
  pGVar1 = (e->segment).v2;
  pGVar2 = (e->segment).v1;
  pGVar3 = *(GSList **)(&pGVar2->p + 1);
  if (pGVar1 == pGVar2) {
    for (; pGVar3 != (GSList *)0x0; pGVar3 = (GSList *)(&pGVar3->data)[1]) {
      pGVar4 = (GtsEdge *)pGVar3->data;
      if (e != pGVar4) {
        pGVar5 = (GtsObjectClass *)gts_edge_class();
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (pGVar4 != (GtsEdge *)0x0) {
          pGVar6 = (pGVar4->segment).object.klass;
          if (pGVar6 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar5 == pGVar6) {
                if (((pGVar4->segment).v1 == pGVar1) && (pGVar1 == (pGVar4->segment).v2)) {
                  return pGVar4;
                }
                break;
              }
              pGVar6 = pGVar6->parent_class;
            } while (pGVar6 != (GtsObjectClass *)0x0);
          }
        }
      }
    }
  }
  else {
    for (; pGVar3 != (GSList *)0x0; pGVar3 = (GSList *)(&pGVar3->data)[1]) {
      pGVar4 = (GtsEdge *)pGVar3->data;
      if (e != pGVar4) {
        pGVar5 = (GtsObjectClass *)gts_edge_class();
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (pGVar4 != (GtsEdge *)0x0) {
          pGVar6 = (pGVar4->segment).object.klass;
          if (pGVar6 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar5 == pGVar6) {
                if (((pGVar4->segment).v1 == pGVar1) || ((pGVar4->segment).v2 == pGVar1)) {
                  return pGVar4;
                }
                break;
              }
              pGVar6 = pGVar6->parent_class;
            } while (pGVar6 != (GtsObjectClass *)0x0);
          }
        }
      }
    }
  }
  return (GtsEdge *)0x0;
}



// WARNING: Unknown calling convention

GList * gts_edges_merge(GList *edges)

{
  GList *pGVar1;
  GtsEdge *e_00;
  gpointer *ppvVar2;
  GtsEdge *with;
  GList *i;
  GList *pGVar3;
  GtsEdge *e;
  GtsEdge *de;
  
  gts_allow_floating_edges = 1;
  pGVar3 = edges;
  if (edges != (GList *)0x0) {
    do {
      while( true ) {
        e_00 = (GtsEdge *)pGVar3->data;
        with = gts_edge_is_duplicate(e_00);
        if (with != (GtsEdge *)0x0) break;
        ppvVar2 = &pGVar3->data;
        pGVar3 = (GList *)ppvVar2[1];
        if ((GList *)ppvVar2[1] == (GList *)0x0) {
          gts_allow_floating_edges = 0;
          return edges;
        }
      }
      pGVar1 = (GList *)(&pGVar3->data)[1];
      edges = (GList *)g_list_remove_link(edges,pGVar3);
      g_list_free_1(pGVar3);
      gts_edge_replace(e_00,with);
      gts_object_destroy((GtsObject *)e_00);
      pGVar3 = pGVar1;
    } while (pGVar1 != (GList *)0x0);
  }
  gts_allow_floating_edges = 0;
  return edges;
}



// WARNING: Unknown calling convention

void gts_edge_swap(GtsEdge *e,GtsSurface *s)

{
  GtsSurface *s_00;
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  guint gVar3;
  GtsVertex *v1;
  GtsEdge *e2;
  GtsFace *pGVar4;
  GtsTriangle *t;
  GtsFace *pGVar5;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  GtsObjectClass *c_3;
  GtsObjectClass *pGVar6;
  GSList *i;
  GSList *pGVar7;
  GtsSegment *v3v6;
  GtsFace *f;
  GtsFace *f_00;
  GtsTriangle *t1;
  GtsFace *local_54;
  GtsFace *local_50;
  GtsEdge *local_44;
  GtsEdge *local_40;
  GtsEdge *local_3c;
  GtsEdge *local_38;
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  s_00 = s;
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_swap","e != NULL");
  }
  else {
    if (s != (GtsSurface *)0x0) {
      pGVar7 = e->triangles;
      if (pGVar7 != (GSList *)0x0) {
        f_00 = (GtsFace *)0x0;
        local_50 = (GtsFace *)0x0;
        do {
          while( true ) {
            pGVar1 = (GtsObjectClass *)gts_face_class();
            pGVar4 = (GtsFace *)pGVar7->data;
            if (pGVar1 == (GtsObjectClass *)0x0) break;
            if (pGVar4 != (GtsFace *)0x0) {
              pGVar6 = (pGVar4->triangle).object.klass;
              if (pGVar6 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
              }
              else {
                do {
                  if (pGVar1 == pGVar6) {
                    gVar2 = gts_face_has_parent_surface(pGVar4,s_00);
                    if (gVar2 != 0) {
                      if (f_00 == (GtsFace *)0x0) {
                        f_00 = (GtsFace *)pGVar7->data;
                        pGVar7 = (GSList *)(&pGVar7->data)[1];
                        goto joined_r0x0811e987;
                      }
                      if (local_50 == (GtsFace *)0x0) {
                        local_50 = (GtsFace *)pGVar7->data;
                        pGVar7 = (GSList *)(&pGVar7->data)[1];
                        goto joined_r0x0811e972;
                      }
                      gVar3 = gts_edge_face_number(e,s_00);
                      if (gVar3 != 2) {
                        g_return_if_fail_warning
                                  (0,"gts_edge_swap","gts_edge_face_number (e, s) == 2");
                        return;
                      }
                    }
                    break;
                  }
                  pGVar6 = pGVar6->parent_class;
                } while (pGVar6 != (GtsObjectClass *)0x0);
              }
            }
            pGVar7 = (GSList *)(&pGVar7->data)[1];
joined_r0x0811e987:
            if (pGVar7 == (GSList *)0x0) goto LAB_0811e84b;
          }
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar7 = (GSList *)(&pGVar7->data)[1];
joined_r0x0811e972:
        } while (pGVar7 != (GSList *)0x0);
LAB_0811e84b:
        if ((local_50 != (GtsFace *)0x0) && (f_00 != (GtsFace *)0x0)) {
          gts_triangle_vertices_edges
                    (&f_00->triangle,e,local_20,&local_24,&local_28,&e,&local_38,&local_3c);
          gts_triangle_vertices_edges
                    (&local_50->triangle,e,&local_2c,&local_30,&local_34,&e,&local_40,&local_44);
          if ((local_24 != local_2c) || (local_20[0] != local_30)) {
                    // WARNING: Subroutine does not return
            g_assertion_message_expr
                      (0,"../../src/gts/edge.c",0x20e,"gts_edge_swap","v2 == v4 && v1 == v5");
          }
          e2 = (GtsEdge *)gts_vertices_are_connected(local_28,local_34);
          pGVar1 = (GtsObjectClass *)gts_edge_class();
          if (pGVar1 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else if (e2 != (GtsEdge *)0x0) {
            pGVar6 = (e2->segment).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            }
            else {
              do {
                if (pGVar1 == pGVar6) goto LAB_0811e9ea;
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
          e2 = (GtsEdge *)gts_segment_new((GtsSegmentClass *)s_00->edge_class,local_28,local_34);
LAB_0811e9ea:
          local_54 = gts_face_new(s_00->face_class,local_38,e2,local_44);
          pGVar4 = (GtsFace *)gts_triangle_is_duplicate(&local_54->triangle);
          if (pGVar4 != (GtsFace *)0x0) {
            pGVar1 = (GtsObjectClass *)gts_face_class();
            if (pGVar1 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            }
            else {
              pGVar6 = (pGVar4->triangle).object.klass;
              if (pGVar6 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
              }
              else {
                do {
                  if (pGVar1 == pGVar6) {
                    gts_object_destroy((GtsObject *)local_54);
                    local_54 = pGVar4;
                    break;
                  }
                  pGVar6 = pGVar6->parent_class;
                } while (pGVar6 != (GtsObjectClass *)0x0);
              }
            }
          }
          gts_surface_add_face(s_00,local_54);
          pGVar4 = gts_face_new(s_00->face_class,e2,local_3c,local_40);
          pGVar5 = (GtsFace *)gts_triangle_is_duplicate(&pGVar4->triangle);
          if (pGVar5 != (GtsFace *)0x0) {
            pGVar1 = (GtsObjectClass *)gts_face_class();
            if (pGVar1 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            }
            else {
              pGVar6 = (pGVar5->triangle).object.klass;
              if (pGVar6 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
              }
              else {
                do {
                  if (pGVar1 == pGVar6) {
                    gts_object_destroy((GtsObject *)pGVar4);
                    pGVar4 = pGVar5;
                    break;
                  }
                  pGVar6 = pGVar6->parent_class;
                } while (pGVar6 != (GtsObjectClass *)0x0);
              }
            }
          }
          gts_surface_add_face(s_00,pGVar4);
          gts_surface_remove_face(s_00,f_00);
          gts_surface_remove_face(s_00,local_50);
          return;
        }
      }
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/edge.c",0x20a,"gts_edge_swap","t1 && t2");
    }
    g_return_if_fail_warning(0,"gts_edge_swap","s != NULL");
  }
  return;
}



// WARNING: Unknown calling convention

void triangle_class_init(GtsObjectClass *klass)

{
  klass->destroy = triangle_destroy;
  return;
}



// WARNING: Unknown calling convention

void triangle_init(GtsTriangle *triangle)

{
  triangle->e3 = (GtsEdge *)0x0;
  triangle->e2 = (GtsEdge *)0x0;
  triangle->e1 = (GtsEdge *)0x0;
  return;
}



// WARNING: Removing unreachable block (ram,0x0811eccf)
// WARNING: Unknown calling convention

void gts_triangle_interpolate_height(GtsTriangle *t,GtsPoint *p)

{
  double dVar1;
  double dVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  GtsVertex *pGVar10;
  GtsPoint *p1;
  GtsPoint *p2;
  gdouble det;
  gdouble y;
  gdouble y2;
  gdouble x;
  gdouble y1;
  gdouble x1;
  gdouble x2;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_interpolate_height","t != NULL");
    return;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_interpolate_height","p != NULL");
    return;
  }
  pGVar3 = (t->e1->segment).v1;
  pGVar10 = (t->e2->segment).v1;
  pGVar4 = (t->e1->segment).v2;
  if ((pGVar3 == pGVar10) || (pGVar4 == pGVar10)) {
    pGVar10 = (t->e2->segment).v2;
  }
  dVar1 = (pGVar3->p).x;
  dVar5 = (pGVar4->p).x - dVar1;
  dVar2 = (pGVar3->p).y;
  dVar8 = (pGVar4->p).y - dVar2;
  dVar6 = (pGVar10->p).x - dVar1;
  dVar9 = (pGVar10->p).y - dVar2;
  dVar7 = dVar5 * dVar9 - dVar6 * dVar8;
  if (dVar7 != 0.0) {
    dVar1 = p->x - dVar1;
    dVar2 = p->y - dVar2;
    dVar6 = (dVar9 * dVar1 - dVar6 * dVar2) / dVar7;
    dVar7 = dVar7 / (dVar2 * dVar5 - dVar1 * dVar8);
    p->z = dVar7 * (pGVar10->p).z + dVar6 * (pGVar4->p).z + ((1.0 - dVar6) - dVar7) * (pGVar3->p).z;
    return;
  }
  p->z = ((pGVar3->p).z + (pGVar4->p).z + (pGVar10->p).z) / 3.0;
  return;
}



// WARNING: Unknown calling convention

void gts_triangle_vertices(GtsTriangle *t,GtsVertex **v1,GtsVertex **v2,GtsVertex **v3)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  GtsSegment *e2;
  GtsSegment *e1;
  
  if ((((t != (GtsTriangle *)0x0) && (v2 != (GtsVertex **)0x0)) && (v1 != (GtsVertex **)0x0)) &&
     (v3 != (GtsVertex **)0x0)) {
    pGVar1 = t->e1;
    pGVar2 = t->e2;
    pGVar3 = (pGVar1->segment).v2;
    pGVar4 = (pGVar2->segment).v1;
    if (pGVar3 == pGVar4) {
      *v1 = (pGVar1->segment).v1;
      *v2 = (pGVar1->segment).v2;
      *v3 = (pGVar2->segment).v2;
    }
    else if (pGVar3 == (pGVar2->segment).v2) {
      *v1 = (pGVar1->segment).v1;
      *v2 = (pGVar1->segment).v2;
      *v3 = (pGVar2->segment).v1;
    }
    else if (pGVar4 == (pGVar1->segment).v1) {
      *v1 = pGVar3;
      *v2 = (pGVar1->segment).v1;
      *v3 = (pGVar2->segment).v2;
    }
    else {
      *v1 = pGVar3;
      *v2 = (pGVar1->segment).v1;
      *v3 = (pGVar2->segment).v1;
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

GtsTriangle * gts_triangle_use_edges(GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GSList *pGVar1;
  GtsTriangle *pGVar2;
  GtsEdge *pGVar3;
  GtsTriangle *t;
  GSList *i;
  GtsEdge *pGVar4;
  GtsEdge *pGVar5;
  
  if (e1 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_use_edges","e1 != NULL");
    return (GtsTriangle *)0x0;
  }
  if (e2 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_use_edges","e2 != NULL");
    return (GtsTriangle *)0x0;
  }
  if (e3 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_use_edges","e3 != NULL");
    return (GtsTriangle *)0x0;
  }
  pGVar1 = e1->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsTriangle *)0x0;
    }
    pGVar2 = (GtsTriangle *)pGVar1->data;
    pGVar3 = pGVar2->e1;
    if (pGVar3 == e2) {
      pGVar4 = pGVar2->e2;
      if (pGVar4 == e3) {
        return pGVar2;
      }
      if (pGVar2->e3 == e3) {
        return pGVar2;
      }
    }
    else {
      pGVar4 = pGVar2->e2;
    }
    if (pGVar4 == e2) {
      if (e3 == pGVar3) {
        return pGVar2;
      }
      pGVar5 = pGVar2->e3;
      if (pGVar5 == e3) {
        return pGVar2;
      }
    }
    else {
      pGVar5 = pGVar2->e3;
    }
    if (e2 == pGVar5) {
      if (e3 == pGVar3) {
        return pGVar2;
      }
      if (pGVar4 == e3) {
        return pGVar2;
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

GtsTriangle * gts_triangle_is_duplicate(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GSList *pGVar3;
  GtsTriangle *pGVar4;
  GtsTriangle *t1;
  GSList *i;
  GtsEdge *e2;
  GtsEdge *e3;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_duplicate","t != NULL");
    return (GtsTriangle *)0x0;
  }
  pGVar1 = t->e2;
  pGVar2 = t->e3;
  pGVar3 = t->e1->triangles;
  do {
    if (pGVar3 == (GSList *)0x0) {
      return (GtsTriangle *)0x0;
    }
    pGVar4 = (GtsTriangle *)pGVar3->data;
    if ((pGVar4 != t) &&
       (((pGVar4->e1 == pGVar1 || (pGVar4->e2 == pGVar1)) || (pGVar4->e3 == pGVar1)))) {
      if (pGVar2 == pGVar4->e1) {
        return pGVar4;
      }
      if (pGVar4->e2 == pGVar2) {
        return pGVar4;
      }
      if (pGVar4->e3 == pGVar2) {
        return pGVar4;
      }
    }
    pGVar3 = (GSList *)(&pGVar3->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

gboolean gts_triangle_is_ok(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsEdge *pGVar3;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GtsVertex *pGVar6;
  GtsVertex *pGVar7;
  GtsVertex *pGVar8;
  gboolean gVar9;
  GtsTriangle *pGVar10;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_ok","t != NULL");
    return 0;
  }
  pGVar1 = t->e1;
  if (pGVar1 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_ok","t->e1 != NULL");
    return 0;
  }
  pGVar2 = t->e2;
  if (pGVar2 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_ok","t->e2 != NULL");
    return 0;
  }
  pGVar3 = t->e3;
  if (pGVar3 != (GtsEdge *)0x0) {
    if (((pGVar1 == pGVar2) || (pGVar1 == pGVar3)) || (pGVar2 == pGVar3)) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok","t->e1 != t->e2 && t->e1 != t->e3 && t->e2 != t->e3");
      return 0;
    }
    pGVar4 = (pGVar1->segment).v1;
    pGVar5 = (pGVar2->segment).v1;
    if (((pGVar4 != pGVar5) && (pGVar6 = (pGVar2->segment).v2, pGVar4 != pGVar6)) &&
       ((pGVar7 = (pGVar1->segment).v2, pGVar5 != pGVar7 && (pGVar6 != pGVar7)))) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok",
                 "gts_segments_touch (GTS_SEGMENT (t->e1), GTS_SEGMENT (t->e2))");
      return 0;
    }
    pGVar6 = (pGVar3->segment).v1;
    if (((pGVar4 != pGVar6) && (pGVar7 = (pGVar3->segment).v2, pGVar4 != pGVar7)) &&
       ((pGVar8 = (pGVar1->segment).v2, pGVar6 != pGVar8 && (pGVar7 != pGVar8)))) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok",
                 "gts_segments_touch (GTS_SEGMENT (t->e1), GTS_SEGMENT (t->e3))");
      return 0;
    }
    if ((((pGVar5 != pGVar6) && (pGVar7 = (pGVar3->segment).v2, pGVar5 != pGVar7)) &&
        (pGVar8 = (pGVar2->segment).v2, pGVar6 != pGVar8)) && (pGVar7 != pGVar8)) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok",
                 "gts_segments_touch (GTS_SEGMENT (t->e2), GTS_SEGMENT (t->e3))");
      return 0;
    }
    if (pGVar4 == (pGVar1->segment).v2) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok","GTS_SEGMENT (t->e1)->v1 != GTS_SEGMENT (t->e1)->v2");
      gVar9 = 0;
    }
    else if (pGVar5 == (pGVar2->segment).v2) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok","GTS_SEGMENT (t->e2)->v1 != GTS_SEGMENT (t->e2)->v2");
      gVar9 = 0;
    }
    else if (pGVar6 == (pGVar3->segment).v2) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok","GTS_SEGMENT (t->e3)->v1 != GTS_SEGMENT (t->e3)->v2");
      gVar9 = 0;
    }
    else if ((t->object).reserved == (gpointer)0x0) {
      pGVar10 = gts_triangle_is_duplicate(t);
      if (pGVar10 == (GtsTriangle *)0x0) {
        gVar9 = 1;
      }
      else {
        g_return_if_fail_warning(0,"gts_triangle_is_ok","!gts_triangle_is_duplicate (t)");
        gVar9 = 0;
      }
    }
    else {
      g_return_if_fail_warning(0,"gts_triangle_is_ok","GTS_OBJECT (t)->reserved == NULL");
      gVar9 = 0;
    }
    return gVar9;
  }
  g_return_if_fail_warning(0,"gts_triangle_is_ok","t->e3 != NULL");
  return 0;
}



// WARNING: Unknown calling convention

GtsEdge * gts_triangles_common_edge(GtsTriangle *t1,GtsTriangle *t2)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsEdge *pGVar3;
  GtsEdge *pGVar4;
  GtsEdge *pGVar5;
  
  if (t1 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_common_edge","t1 != NULL");
    return (GtsEdge *)0x0;
  }
  if (t2 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_common_edge","t2 != NULL");
    return (GtsEdge *)0x0;
  }
  pGVar4 = t1->e1;
  pGVar1 = t2->e1;
  if (((pGVar4 != pGVar1) && (pGVar2 = t2->e2, pGVar4 != pGVar2)) &&
     (pGVar5 = t2->e3, pGVar4 != pGVar5)) {
    pGVar3 = t1->e2;
    if (pGVar1 == pGVar3) {
      return pGVar1;
    }
    pGVar4 = pGVar2;
    if ((pGVar2 != pGVar3) && (pGVar4 = pGVar5, pGVar5 != pGVar3)) {
      pGVar3 = t1->e3;
      if (pGVar1 == pGVar3) {
        return pGVar1;
      }
      pGVar4 = pGVar2;
      if (pGVar2 != pGVar3) {
        if (pGVar5 != pGVar3) {
          pGVar5 = (GtsEdge *)0x0;
        }
        return pGVar5;
      }
    }
  }
  return pGVar4;
}



// WARNING: Unknown calling convention

guint gts_triangle_neighbor_number(GtsTriangle *t)

{
  GSList *pGVar1;
  GtsEdge **e;
  GtsEdge **ppGVar2;
  GSList *i;
  guint gVar3;
  guint nn;
  GtsEdge *ee [4];
  
  if (t == (GtsTriangle *)0x0) {
    gVar3 = 0;
    g_return_if_fail_warning(0,"gts_triangle_neighbor_number","t != NULL");
  }
  else {
    gVar3 = 0;
    ee[0] = t->e1;
    ee[1] = t->e2;
    ee[3] = (GtsEdge *)0x0;
    ee[2] = t->e3;
    for (ppGVar2 = ee; *ppGVar2 != (GtsEdge *)0x0; ppGVar2 = ppGVar2 + 1) {
      for (pGVar1 = (*ppGVar2)->triangles; pGVar1 != (GSList *)0x0; pGVar1 = pGVar1->next) {
        gVar3 = gVar3 + ((GtsTriangle *)pGVar1->data != t);
      }
    }
  }
  return gVar3;
}



// WARNING: Unknown calling convention

void gts_triangle_revert(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  GtsEdge *e;
  
  if (t != (GtsTriangle *)0x0) {
    pGVar1 = t->e2;
    t->e2 = t->e1;
    t->e1 = pGVar1;
    return;
  }
  g_return_if_fail_warning(0,"gts_triangle_revert","t != NULL");
  return;
}



// WARNING: Unknown calling convention

GtsEdge * gts_triangle_edge_opposite(GtsTriangle *t,GtsVertex *v)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_edge_opposite","t != NULL");
    return (GtsEdge *)0x0;
  }
  if (v != (GtsVertex *)0x0) {
    pGVar2 = t->e1;
    pGVar1 = t->e2;
    if (((pGVar2->segment).v1 == v) || ((pGVar2->segment).v2 == v)) {
      if ((((pGVar1->segment).v1 == v) || (pGVar2 = pGVar1, (pGVar1->segment).v2 == v)) &&
         ((pGVar2 = t->e3, (pGVar2->segment).v1 == v || ((pGVar2->segment).v2 == v)))) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/gts/triangle.c",0xd7,"gts_triangle_edge_opposite",&DAT_0816018f);
      }
    }
    else if (((pGVar1->segment).v1 != v) && ((pGVar1->segment).v2 != v)) {
      return (GtsEdge *)0x0;
    }
    return pGVar2;
  }
  g_return_if_fail_warning(0,"gts_triangle_edge_opposite","v != NULL");
  return (GtsEdge *)0x0;
}



// WARNING: Unknown calling convention

GtsVertex * triangle_use_vertices(GtsTriangle *t,GtsVertex *A,GtsVertex *B)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *v3;
  GtsVertex *pGVar3;
  GtsVertex *v2;
  GtsVertex *v1;
  
  pGVar1 = (t->e1->segment).v1;
  pGVar3 = (t->e2->segment).v1;
  pGVar2 = (t->e1->segment).v2;
  if ((pGVar1 == pGVar3) || (pGVar2 == pGVar3)) {
    pGVar3 = (t->e2->segment).v2;
  }
  if (pGVar1 == A) {
    if ((pGVar2 != B) && (pGVar3 = pGVar2, pGVar3 != B)) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/triangle.c",0x39e,"triangle_use_vertices","v3 == B")
      ;
    }
  }
  else if (pGVar2 == A) {
    if ((pGVar1 != B) && (pGVar3 = pGVar1, pGVar3 != B)) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/triangle.c",0x3a4,"triangle_use_vertices","v3 == B")
      ;
    }
  }
  else {
    if (pGVar3 != A) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",0x3ad,"triangle_use_vertices",0);
    }
    pGVar3 = pGVar2;
    if ((pGVar1 != B) && (pGVar3 = pGVar1, pGVar2 != B)) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/triangle.c",0x3aa,"triangle_use_vertices","v2 == B")
      ;
    }
  }
  return pGVar3;
}



// WARNING: Unknown calling convention

gboolean gts_triangles_are_folded(GSList *triangles,GtsVertex *A,GtsVertex *B,gdouble max)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  GtsVertex *pGVar11;
  GtsVertex *D;
  GtsVertex *pGVar12;
  GtsVertex *C;
  gdouble nn2;
  gdouble nn1;
  gdouble n1n2;
  GSList *local_44;
  GSList *local_40;
  
  if (A == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_are_folded","A != NULL");
    return 1;
  }
  if (B == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_are_folded","B != NULL");
    return 1;
  }
  if (triangles != (GSList *)0x0) {
    local_44 = triangles;
    do {
      pGVar11 = triangle_use_vertices((GtsTriangle *)local_44->data,A,B);
      local_40 = (GSList *)(&local_44->data)[1];
      if (local_40 == (GSList *)0x0) {
        return 0;
      }
      do {
        pGVar12 = triangle_use_vertices((GtsTriangle *)local_40->data,A,B);
        dVar1 = (A->p).x;
        dVar4 = (B->p).x - dVar1;
        dVar2 = (A->p).y;
        dVar9 = (B->p).y - dVar2;
        dVar3 = (A->p).z;
        dVar10 = (B->p).z - dVar3;
        dVar5 = (pGVar11->p).x - dVar1;
        dVar8 = (pGVar11->p).y - dVar2;
        dVar6 = (pGVar11->p).z - dVar3;
        dVar1 = (pGVar12->p).x - dVar1;
        dVar2 = (pGVar12->p).y - dVar2;
        dVar3 = (pGVar12->p).z - dVar3;
        dVar7 = dVar9 * dVar6 - dVar10 * dVar8;
        dVar6 = dVar5 * dVar10 - dVar6 * dVar4;
        dVar8 = dVar8 * dVar4 - dVar5 * dVar9;
        dVar5 = dVar2 * dVar10 - dVar9 * dVar3;
        dVar3 = dVar3 * dVar4 - dVar10 * dVar1;
        dVar1 = dVar9 * dVar1 - dVar4 * dVar2;
        dVar2 = dVar8 * dVar8 + dVar6 * dVar6 + dVar7 * dVar7;
        dVar4 = dVar1 * dVar1 + dVar3 * dVar3 + dVar5 * dVar5;
        if (dVar4 * 100000000.0 <= dVar2) {
          return 1;
        }
        if (dVar2 * 100000000.0 <= dVar4) {
          return 1;
        }
        dVar1 = dVar1 * dVar8 + dVar5 * dVar7 + dVar3 * dVar6;
        if ((dVar1 <= 0.0) && (max < (dVar1 * dVar1) / (dVar4 * dVar2))) {
          return 1;
        }
        local_40 = (GSList *)(&local_40->data)[1];
      } while (local_40 != (GSList *)0x0);
      local_44 = (GSList *)(&local_44->data)[1];
    } while (local_44 != (GSList *)0x0);
  }
  return 0;
}



// WARNING: Unknown calling convention

void gts_triangle_vertices_edges
               (GtsTriangle *t,GtsEdge *e,GtsVertex **v1,GtsVertex **v2,GtsVertex **v3,GtsEdge **e1,
               GtsEdge **e2,GtsEdge **e3)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsEdge *ee1;
  GtsVertex *pGVar3;
  GtsEdge *pGVar4;
  GtsEdge *ee2;
  GtsEdge *pGVar5;
  GtsVertex *pGVar6;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  pGVar4 = t->e1;
  if ((e == (GtsEdge *)0x0) || (pGVar4 == e)) {
    *e1 = pGVar4;
    pGVar5 = t->e2;
    *e2 = pGVar5;
    *e3 = t->e3;
LAB_0811f98b:
    pGVar3 = (pGVar4->segment).v2;
    pGVar6 = (pGVar5->segment).v1;
    if (pGVar3 != pGVar6) goto LAB_0811f995;
LAB_0811fa08:
    *v1 = (pGVar4->segment).v1;
    pGVar3 = (pGVar4->segment).v2;
LAB_0811fa13:
    *v2 = pGVar3;
    *v3 = (pGVar5->segment).v2;
  }
  else {
    pGVar4 = t->e2;
    if (pGVar4 == e) {
      *e1 = pGVar4;
      pGVar5 = t->e3;
      *e2 = pGVar5;
      *e3 = t->e1;
      goto LAB_0811f98b;
    }
    pGVar4 = t->e3;
    if (pGVar4 != e) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",0x224,"gts_triangle_vertices_edges",0);
    }
    *e1 = pGVar4;
    pGVar5 = t->e1;
    *e2 = pGVar5;
    *e3 = t->e2;
    pGVar3 = (pGVar4->segment).v2;
    pGVar6 = (pGVar5->segment).v1;
    if (pGVar3 == pGVar6) goto LAB_0811fa08;
LAB_0811f995:
    pGVar1 = (pGVar5->segment).v2;
    if (pGVar3 == pGVar1) {
      *v1 = (pGVar4->segment).v1;
      pGVar3 = (pGVar4->segment).v2;
    }
    else {
      pGVar2 = (pGVar4->segment).v1;
      if (pGVar6 == pGVar2) {
        *v1 = pGVar3;
        pGVar3 = (pGVar4->segment).v1;
        goto LAB_0811fa13;
      }
      if (pGVar1 != pGVar2) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0x23c,"gts_triangle_vertices_edges",0);
      }
      *v1 = pGVar3;
      pGVar3 = (pGVar4->segment).v1;
    }
    *v2 = pGVar3;
    *v3 = (pGVar5->segment).v1;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0811fb97)
// WARNING: Removing unreachable block (ram,0x0811fc82)
// WARNING: Removing unreachable block (ram,0x0811fd67)
// WARNING: Unknown calling convention

GtsObject * gts_triangle_is_stabbed(GtsTriangle *t,GtsPoint *p,gdouble *orientation)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  double dVar3;
  GtsEdge *tmp;
  GtsVertex *inverted;
  GtsVertex *pGVar4;
  gdouble o3;
  gdouble o;
  gdouble o1;
  gdouble o2;
  gdouble gVar5;
  gdouble gVar6;
  gdouble gVar7;
  gdouble gVar8;
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_stabbed","t != NULL");
  }
  else if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_stabbed","p != NULL");
  }
  else {
    gts_triangle_vertices_edges
              (t,(GtsEdge *)0x0,local_20,&local_24,&local_28,(GtsEdge **)&local_2c,
               (GtsEdge **)&local_30,(GtsEdge **)&local_34);
    gVar5 = gts_point_orientation(&local_20[0]->p,&local_24->p,&local_28->p);
    if (gVar5 != 0.0) {
      if (gVar5 < 0.0) {
        pGVar1 = local_30;
        pGVar2 = local_24;
        local_30 = local_34;
        pGVar4 = local_20[0];
        local_34 = pGVar1;
        local_24 = local_20[0];
        local_20[0] = pGVar2;
      }
      else {
        pGVar4 = (GtsVertex *)0x0;
      }
      gVar5 = gts_point_orientation_3d(&local_20[0]->p,&local_24->p,&local_28->p,p);
      if ((((0.0 <= gVar5) &&
           (gVar6 = gts_point_orientation(&local_20[0]->p,&local_24->p,p), 0.0 <= gVar6)) &&
          (gVar7 = gts_point_orientation(&local_24->p,&local_28->p,p), 0.0 <= gVar7)) &&
         (gVar8 = gts_point_orientation(&local_28->p,&local_20[0]->p,p), 0.0 <= gVar8)) {
        if (orientation != (gdouble *)0x0) {
          dVar3 = -gVar5;
          if (pGVar4 == (GtsVertex *)0x0) {
            dVar3 = gVar5;
          }
          *orientation = dVar3;
        }
        if (gVar6 != 0.0) {
          if (gVar7 != 0.0) {
            if (gVar8 == 0.0) {
              return (GtsObject *)local_34;
            }
            return &t->object;
          }
          if (gVar8 == 0.0) {
            return (GtsObject *)local_28;
          }
          return (GtsObject *)local_30;
        }
        if (gVar7 == 0.0) {
          return (GtsObject *)local_24;
        }
        if (gVar8 == 0.0) {
          return (GtsObject *)local_20[0];
        }
        return (GtsObject *)local_2c;
      }
    }
  }
  return (GtsObject *)0x0;
}



// WARNING: Unknown calling convention

gdouble gts_triangle_orientation(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsVertex *p1;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GtsVertex *v3;
  GtsVertex *p3;
  GtsVertex *v1;
  GtsVertex *v2;
  GtsVertex *p2;
  gdouble gVar6;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_orientation","t != NULL");
    return 0.0;
  }
  pGVar1 = t->e1;
  pGVar2 = t->e2;
  p1 = (pGVar1->segment).v1;
  pGVar3 = (pGVar2->segment).v1;
  if (p1 == pGVar3) {
    p3 = (pGVar1->segment).v2;
    p2 = (pGVar2->segment).v2;
  }
  else {
    pGVar4 = (pGVar1->segment).v2;
    pGVar5 = (pGVar2->segment).v2;
    p3 = pGVar3;
    p2 = pGVar4;
    if (((pGVar4 != pGVar5) && (p3 = pGVar4, p2 = pGVar3, p1 != pGVar5)) &&
       (p3 = pGVar5, pGVar3 != pGVar4)) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",0x1c5,"gts_triangle_orientation",0);
    }
  }
  gVar6 = gts_point_orientation(&p1->p,&p2->p,&p3->p);
  return gVar6;
}



// WARNING: Unknown calling convention

gboolean gts_triangles_are_compatible(GtsTriangle *t1,GtsTriangle *t2,GtsEdge *e)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GtsEdge *e2;
  GtsEdge *pGVar4;
  GtsEdge *e1;
  GtsEdge *pGVar5;
  
  if (t1 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_are_compatible","t1 != NULL");
    return 0;
  }
  if (t2 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_are_compatible","t2 != NULL");
    return 0;
  }
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_are_compatible","e != NULL");
    return 0;
  }
  pGVar5 = t1->e1;
  if (pGVar5 == e) {
    pGVar5 = t1->e2;
  }
  else if (t1->e2 == e) {
    pGVar5 = t1->e3;
  }
  else if (t1->e3 != e) {
                    // WARNING: Subroutine does not return
    g_assertion_message(0,"../../src/gts/triangle.c",0x111,"gts_triangles_are_compatible",0);
  }
  pGVar4 = t2->e1;
  if (pGVar4 == e) {
    pGVar4 = t2->e2;
    pGVar2 = (pGVar5->segment).v1;
    pGVar3 = (pGVar4->segment).v1;
    if (pGVar2 == pGVar3) {
      return 0;
    }
  }
  else {
    if (t2->e2 == e) {
      pGVar4 = t2->e3;
    }
    else if (t2->e3 != e) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",0x116,"gts_triangles_are_compatible",0);
    }
    pGVar2 = (pGVar5->segment).v1;
    pGVar3 = (pGVar4->segment).v1;
    if (pGVar2 == pGVar3) {
      return 0;
    }
  }
  pGVar1 = (pGVar4->segment).v2;
  if ((pGVar2 != pGVar1) && (pGVar2 = (pGVar5->segment).v2, pGVar3 != pGVar2)) {
    return (uint)(pGVar1 != pGVar2);
  }
  return 0;
}



// WARNING: Unknown calling convention

GtsVertex * gts_triangle_vertex_opposite(GtsTriangle *t,GtsEdge *e)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsVertex *v;
  GtsVertex *v_1;
  GtsVertex *v_2;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_vertex_opposite","t != NULL");
    return (GtsVertex *)0x0;
  }
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_vertex_opposite","e != NULL");
    return (GtsVertex *)0x0;
  }
  pGVar1 = t->e1;
  if (pGVar1 == e) {
    v_2 = (t->e2->segment).v1;
    if (((pGVar1->segment).v1 == v_2) || ((pGVar1->segment).v2 == v_2)) {
      v_2 = (t->e2->segment).v2;
    }
  }
  else {
    pGVar2 = t->e2;
    if (pGVar2 == e) {
      v_2 = (pGVar1->segment).v1;
      if (((pGVar2->segment).v1 == v_2) || ((pGVar2->segment).v2 == v_2)) {
        v_2 = (pGVar1->segment).v2;
      }
    }
    else {
      pGVar1 = t->e3;
      if (pGVar1 != e) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0xba,"gts_triangle_vertex_opposite",0);
      }
      v_2 = (pGVar2->segment).v1;
      if (((pGVar1->segment).v1 == v_2) || ((pGVar1->segment).v2 == v_2)) {
        return (pGVar2->segment).v2;
      }
    }
  }
  return v_2;
}



// WARNING: Unknown calling convention

GtsPoint * gts_triangle_circumcircle_center(GtsTriangle *t,GtsPointClass *point_class)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  GtsPoint *pGVar10;
  gdouble xe;
  gdouble xd;
  gdouble ye;
  gdouble yd;
  gdouble ya;
  gdouble xa;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_circumcircle_center","t != NULL");
    return (GtsPoint *)0x0;
  }
  if (point_class == (GtsPointClass *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_circumcircle_center","point_class != NULL");
    return (GtsPoint *)0x0;
  }
  gts_triangle_vertices(t,local_10,&local_14,&local_18);
  dVar1 = (local_10[0]->p).x;
  dVar2 = (local_10[0]->p).y;
  dVar9 = ((local_14->p).x + dVar1) * 0.5;
  dVar8 = ((local_14->p).y + dVar2) * 0.5;
  dVar7 = ((local_18->p).x + dVar1) * 0.5;
  dVar6 = ((local_18->p).y + dVar2) * 0.5;
  dVar3 = (dVar9 - dVar1) * (dVar6 - dVar2);
  dVar5 = (dVar7 - dVar1) * (dVar8 - dVar2);
  dVar4 = dVar3 - dVar5;
  if (dVar4 != 0.0) {
    pGVar10 = gts_point_new(point_class,
                            (((dVar6 - dVar2) * (dVar8 - dVar2) * (dVar8 - dVar6) + dVar9 * dVar3) -
                            dVar7 * dVar5) / dVar4,
                            -((dVar5 * dVar8 + (dVar9 - dVar7) * (dVar7 - dVar1) * (dVar9 - dVar1))
                             - dVar6 * dVar3) / dVar4,0.0);
    return pGVar10;
  }
  return (GtsPoint *)0x0;
}



// WARNING: Unknown calling convention

GSList * gts_triangle_neighbors(GtsTriangle *t)

{
  GSList *pGVar1;
  GSList *pGVar2;
  GSList *list;
  GtsTriangle *t1;
  GtsEdge **e;
  GtsEdge **ppGVar3;
  GSList *i;
  GtsEdge *ee [4];
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_neighbors","t != NULL");
    pGVar2 = (GSList *)0x0;
  }
  else {
    ee[0] = t->e1;
    ee[1] = t->e2;
    ee[3] = (GtsEdge *)0x0;
    ee[2] = t->e3;
    pGVar2 = (GSList *)0x0;
    for (ppGVar3 = ee; *ppGVar3 != (GtsEdge *)0x0; ppGVar3 = ppGVar3 + 1) {
      for (pGVar1 = (*ppGVar3)->triangles; pGVar1 != (GSList *)0x0; pGVar1 = pGVar1->next) {
        if ((GtsTriangle *)pGVar1->data != t) {
          pGVar2 = (GSList *)g_slist_prepend(pGVar2,(GtsTriangle *)pGVar1->data);
        }
      }
    }
  }
  return pGVar2;
}



// WARNING: Unknown calling convention

void gts_triangle_set(GtsTriangle *triangle,GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GSList *pGVar4;
  GtsVertex *pGVar5;
  GtsVertex *local_20;
  
  if (((((e1 == (GtsEdge *)0x0) || (e2 == (GtsEdge *)0x0)) || (e3 == (GtsEdge *)0x0)) ||
      ((e1 == e3 || (e1 == e2)))) || (e2 == e3)) goto LAB_081203a7;
  pGVar1 = (e1->segment).v1;
  pGVar2 = (e2->segment).v1;
  triangle->e1 = e1;
  triangle->e2 = e2;
  triangle->e3 = e3;
  if (pGVar1 == pGVar2) {
    pGVar1 = (e1->segment).v2;
    pGVar2 = (e3->segment).v1;
    if (pGVar2 == pGVar1) {
      local_20 = (e2->segment).v2;
      if ((e3->segment).v2 == local_20) goto LAB_08120484;
    }
    else {
      local_20 = (e2->segment).v2;
    }
    if ((pGVar2 != local_20) || (pGVar1 != (e3->segment).v2)) goto LAB_081203a7;
    goto LAB_08120484;
  }
  pGVar5 = (e1->segment).v2;
  if (pGVar2 == pGVar5) {
    pGVar2 = (e3->segment).v1;
    if (pGVar1 == pGVar2) {
      pGVar5 = (e2->segment).v2;
      if ((e3->segment).v2 == pGVar5) goto LAB_08120484;
    }
    else {
      pGVar5 = (e2->segment).v2;
    }
    if (pGVar2 != pGVar5) goto LAB_081203a7;
    pGVar2 = (e3->segment).v2;
joined_r0x08120530:
    if (pGVar1 == pGVar2) goto LAB_08120484;
  }
  else {
    pGVar3 = (e2->segment).v2;
    if (pGVar5 == pGVar3) {
      pGVar5 = (e3->segment).v1;
      if (pGVar1 != pGVar5) {
        if (pGVar2 != pGVar5) goto LAB_081203a7;
        pGVar2 = (e3->segment).v2;
        goto joined_r0x08120530;
      }
      pGVar1 = (e3->segment).v2;
    }
    else {
      if (pGVar1 != pGVar3) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0x7d,"gts_triangle_set",0);
      }
      pGVar1 = (e3->segment).v1;
      if (pGVar5 != pGVar1) {
        if ((pGVar2 == pGVar1) && (pGVar5 == (e3->segment).v2)) goto LAB_08120484;
        goto LAB_081203a7;
      }
      pGVar1 = (e3->segment).v2;
    }
    if (pGVar2 == pGVar1) {
LAB_08120484:
      pGVar4 = (GSList *)g_slist_prepend(e1->triangles,triangle);
      e1->triangles = pGVar4;
      pGVar4 = (GSList *)g_slist_prepend(e2->triangles,triangle);
      e2->triangles = pGVar4;
      pGVar4 = (GSList *)g_slist_prepend(e3->triangles,triangle);
      e3->triangles = pGVar4;
      return;
    }
  }
LAB_081203a7:
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

GSList * gts_triangles_from_edges(GSList *edges)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  GSList *j;
  GtsTriangle *t;
  GHashTable *hash;
  GSList *local_24;
  GSList *local_20;
  
  uVar3 = g_hash_table_new(0,0);
  local_24 = (GSList *)0x0;
  local_20 = edges;
  if (edges != (GSList *)0x0) {
    do {
      for (puVar1 = *(undefined4 **)((int)local_20->data + 0x14); puVar1 != (undefined4 *)0x0;
          puVar1 = (undefined4 *)puVar1[1]) {
        uVar2 = *puVar1;
        iVar4 = g_hash_table_lookup(uVar3,uVar2);
        if (iVar4 == 0) {
          local_24 = (GSList *)g_slist_prepend(local_24,uVar2);
          g_hash_table_insert(uVar3,uVar2,local_20);
        }
      }
      local_20 = local_20->next;
    } while (local_20 != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar3);
  return local_24;
}



// WARNING: Unknown calling convention

void gts_triangle_normal(GtsTriangle *t,gdouble *x,gdouble *y,gdouble *z)

{
  double dVar1;
  double dVar2;
  double dVar3;
  GtsEdge *pGVar4;
  GtsEdge *pGVar5;
  GtsVertex *pGVar6;
  GtsVertex *pGVar7;
  GtsVertex *pGVar8;
  GtsVertex *pGVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  GtsVertex *v3;
  GtsVertex *pGVar13;
  GtsVertex *v1;
  GtsVertex *v2;
  GtsVertex *pGVar14;
  gdouble y2;
  gdouble z1;
  gdouble x2;
  gdouble y1;
  gdouble x1;
  gdouble z2;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  pGVar4 = t->e1;
  pGVar5 = t->e2;
  pGVar6 = (pGVar4->segment).v1;
  pGVar7 = (pGVar5->segment).v1;
  if (pGVar6 == pGVar7) {
    pGVar13 = (pGVar4->segment).v2;
    pGVar14 = (pGVar5->segment).v2;
  }
  else {
    pGVar8 = (pGVar4->segment).v2;
    pGVar9 = (pGVar5->segment).v2;
    pGVar13 = pGVar7;
    pGVar14 = pGVar8;
    if (((pGVar8 != pGVar9) && (pGVar13 = pGVar8, pGVar14 = pGVar7, pGVar6 != pGVar9)) &&
       (pGVar13 = pGVar9, pGVar7 != pGVar8)) {
      __fprintf_chk(stderr,1,
                    "t: %p t->e1: %p t->e2: %p t->e3: %p t->e1->v1: %p t->e1->v2: %p t->e2->v1: %p t->e2->v2: %p t->e3->v1: %p t->e3->v2: %p\n"
                    ,t,pGVar4,pGVar5,t->e3,pGVar6,pGVar8,pGVar7,pGVar9,(t->e3->segment).v1,
                    (t->e3->segment).v2);
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",399,"gts_triangle_normal",0);
    }
  }
  dVar1 = (pGVar6->p).x;
  dVar10 = (pGVar14->p).x - dVar1;
  dVar2 = (pGVar6->p).y;
  dVar11 = (pGVar14->p).y - dVar2;
  dVar3 = (pGVar6->p).z;
  dVar12 = (pGVar14->p).z - dVar3;
  dVar1 = (pGVar13->p).x - dVar1;
  dVar2 = (pGVar13->p).y - dVar2;
  dVar3 = (pGVar13->p).z - dVar3;
  *x = dVar11 * dVar3 - dVar12 * dVar2;
  *y = dVar12 * dVar1 - dVar3 * dVar10;
  *z = dVar2 * dVar10 - dVar1 * dVar11;
  return;
}



// WARNING: Unknown calling convention

gdouble gts_triangle_area(GtsTriangle *t)

{
  double local_24;
  double local_1c;
  double local_14 [2];
  
  if (t != (GtsTriangle *)0x0) {
    gts_triangle_normal(t,local_14,&local_1c,&local_24);
    return SQRT(local_24 * local_24 + local_1c * local_1c + local_14[0] * local_14[0]) * 0.5;
  }
  g_return_if_fail_warning(0,"gts_triangle_area","t != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

gdouble gts_triangle_perimeter(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  GtsVertex *p1;
  GtsVertex *p2;
  GtsVertex *v;
  GtsVertex *p2_00;
  gdouble gVar2;
  gdouble gVar3;
  gdouble gVar4;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_perimeter","t != NULL");
    return 0.0;
  }
  pGVar1 = t->e1;
  p1 = (pGVar1->segment).v1;
  p2_00 = (t->e2->segment).v1;
  if (p1 == p2_00) {
    p2 = (pGVar1->segment).v2;
  }
  else {
    p2 = (pGVar1->segment).v2;
    if (p2_00 != p2) goto LAB_08120876;
  }
  p2_00 = (t->e2->segment).v2;
LAB_08120876:
  gVar2 = gts_point_distance(&p1->p,&p2->p);
  gVar3 = gts_point_distance(&((t->e1->segment).v1)->p,&p2_00->p);
  gVar4 = gts_point_distance(&((t->e1->segment).v2)->p,&p2_00->p);
  return gVar2 + gVar3 + gVar4;
}



// WARNING: Removing unreachable block (ram,0x08120958)
// WARNING: Removing unreachable block (ram,0x0812094e)
// WARNING: Removing unreachable block (ram,0x0812095c)
// WARNING: Unknown calling convention

gdouble gts_triangle_quality(GtsTriangle *t)

{
  gdouble perimeter;
  gdouble gVar1;
  gdouble gVar2;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_quality","t != NULL");
    return 0.0;
  }
  gVar1 = gts_triangle_perimeter(t);
  if (0.0 < gVar1) {
    gVar2 = gts_triangle_area(t);
    return (SQRT(gVar2) * 4.5590141139) / gVar1;
  }
  return 0.0;
}



// WARNING: Unknown calling convention

gdouble gts_triangles_angle(GtsTriangle *t1,GtsTriangle *t2)

{
  double dVar1;
  double dVar2;
  gdouble theta;
  double dVar3;
  double local_3c;
  double local_34;
  double local_2c;
  double local_24;
  double local_1c;
  double local_14;
  
  if ((t2 == (GtsTriangle *)0x0) || (t1 == (GtsTriangle *)0x0)) {
    g_return_if_fail_warning(0,"gts_triangles_angle","t1 != NULL && t2 != NULL");
    dVar3 = 0.0;
  }
  else {
    gts_triangle_normal(t1,&local_14,&local_1c,&local_24);
    gts_triangle_normal(t2,&local_2c,&local_34,&local_3c);
    dVar1 = local_3c * local_1c - local_24 * local_34;
    dVar2 = local_24 * local_2c - local_3c * local_14;
    dVar3 = local_34 * local_14 - local_1c * local_2c;
    dVar3 = atan2(SQRT(dVar3 * dVar3 + dVar2 * dVar2 + dVar1 * dVar1),
                  local_3c * local_24 + local_14 * local_2c + local_34 * local_1c);
    dVar3 = dVar3 - 3.141592653589793;
    if (dVar3 < -3.141592653589793) {
      return dVar3 + 6.283185307179586;
    }
  }
  return dVar3;
}



// WARNING: Unknown calling convention

GtsTriangle * gts_triangle_new(GtsTriangleClass *klass,GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GtsTriangle *triangle;
  
  triangle = (GtsTriangle *)gts_object_new(&klass->parent_class);
  gts_triangle_set(triangle,e1,e2,e3);
  return triangle;
}



// WARNING: Unknown calling convention

GtsTriangleClass * gts_triangle_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo triangle_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_triangle_class::klass == (GtsTriangleClass *)0x0) {
    pGVar3 = &triangle_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    triangle_info.name[0] = 'G';
    triangle_info.name[1] = 't';
    triangle_info.name[2] = 's';
    triangle_info.name[3] = 'T';
    triangle_info.name[4] = 'r';
    triangle_info.name[5] = 'i';
    triangle_info.name[6] = 'a';
    triangle_info.name[7] = 'n';
    triangle_info.name[8] = 'g';
    triangle_info.name[9] = 'l';
    triangle_info.name[10] = 'e';
    triangle_info.name[11] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(triangle_info.name + uVar1 + 0xc) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x1c);
    triangle_info.object_size = 0x18;
    triangle_info.class_size = 0x5c;
    triangle_info.class_init_func = triangle_class_init;
    triangle_info.object_init_func = triangle_init;
    parent_class = gts_object_class();
    gts_triangle_class::klass =
         (GtsTriangleClass *)gts_object_class_new(parent_class,&triangle_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_triangle_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

GtsTriangle * gts_triangle_enclosing(GtsTriangleClass *klass,GSList *points,gdouble scale)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  GSList *pGVar8;
  GtsVertexClass *pGVar9;
  GtsVertex *v1_00;
  GtsVertex *v2_00;
  GtsVertex *v2_01;
  GtsEdgeClass *pGVar10;
  GtsEdge *e1_00;
  GtsEdge *e2_00;
  GtsEdge *e3_00;
  GtsTriangleClass *klass_00;
  GtsTriangle *pGVar11;
  GtsPoint *p;
  GtsEdge *e1;
  GtsVertex *v3;
  GtsEdge *e3;
  GtsVertex *v1;
  GtsVertex *v2;
  GtsEdge *e2;
  gdouble ymax;
  gdouble xmax;
  gdouble ymin;
  gdouble xmin;
  
  if (points == (GSList *)0x0) {
    return (GtsTriangle *)points;
  }
  dVar1 = *(double *)((int)points->data + 0xc);
  dVar2 = *(double *)((int)points->data + 0x14);
  dVar5 = dVar1;
  dVar6 = dVar2;
  for (pGVar8 = points->next; dVar3 = dVar5, pGVar8 != (GSList *)0x0; pGVar8 = pGVar8->next) {
    while( true ) {
      dVar4 = *(double *)((int)pGVar8->data + 0xc);
      dVar7 = dVar1;
      dVar5 = dVar4;
      if ((dVar4 <= dVar3) && (dVar7 = dVar4, dVar5 = dVar3, dVar1 <= dVar4)) {
        dVar7 = dVar1;
      }
      dVar1 = dVar7;
      dVar3 = *(double *)((int)pGVar8->data + 0x14);
      dVar4 = dVar3;
      dVar7 = dVar6;
      if ((dVar2 < dVar3) || (dVar4 = dVar2, dVar7 = dVar3, dVar3 < dVar6)) break;
      pGVar8 = pGVar8->next;
      dVar3 = dVar5;
      if (pGVar8 == (GSList *)0x0) goto LAB_08120c42;
    }
    dVar2 = dVar4;
    dVar6 = dVar7;
  }
LAB_08120c42:
  dVar3 = (dVar1 + dVar5) * 0.5;
  dVar6 = (dVar6 + dVar2) * 0.5;
  dVar1 = SQRT((dVar2 - dVar6) * (dVar2 - dVar6) + (dVar5 - dVar3) * (dVar5 - dVar3)) * scale;
  if (dVar1 == 0.0) {
    dVar1 = scale;
  }
  pGVar9 = gts_vertex_class();
  v1_00 = gts_vertex_new(pGVar9,dVar3 + dVar1 * 1.73205080757,dVar6 - dVar1,0.0);
  pGVar9 = gts_vertex_class();
  v2_00 = gts_vertex_new(pGVar9,dVar3,dVar6 + dVar1 + dVar1,0.0);
  pGVar9 = gts_vertex_class();
  v2_01 = gts_vertex_new(pGVar9,dVar3 + dVar1 * -1.73205080757,dVar6 - dVar1,0.0);
  pGVar10 = gts_edge_class();
  e1_00 = gts_edge_new(pGVar10,v1_00,v2_00);
  pGVar10 = gts_edge_class();
  e2_00 = gts_edge_new(pGVar10,v2_00,v2_01);
  pGVar10 = gts_edge_class();
  e3_00 = gts_edge_new(pGVar10,v2_01,v1_00);
  klass_00 = gts_triangle_class();
  pGVar11 = gts_triangle_new(klass_00,e1_00,e2_00,e3_00);
  return pGVar11;
}



// WARNING: Unknown calling convention

void triangle_destroy(GtsObject *object)

{
  byte bVar1;
  GtsObjectClass *object_00;
  GtsObject *object_01;
  GtsObject *object_02;
  int iVar2;
  guint32 gVar3;
  GtsTriangleClass *pGVar4;
  GtsEdge *e1;
  GtsEdge *e3;
  GtsEdge *e2;
  
  object_00 = object[1].klass;
  object_01 = (GtsObject *)object[1].reserved;
  object_02 = (GtsObject *)object[1].flags;
  iVar2 = g_slist_remove(*(undefined4 *)((int)(object_00->info).name + 0x14),object);
  bVar1 = object_00->info;
  *(int *)((int)(object_00->info).name + 0x14) = iVar2;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_edges == 0)) && (iVar2 == 0)) {
    gts_object_destroy((GtsObject *)object_00);
  }
  gVar3 = g_slist_remove(object_01[1].flags,object);
  object_01[1].flags = gVar3;
  if ((((*(byte *)&object_01->flags & 1) == 0) && (gts_allow_floating_edges == 0)) && (gVar3 == 0))
  {
    gts_object_destroy(object_01);
  }
  gVar3 = g_slist_remove(object_02[1].flags,object);
  object_02[1].flags = gVar3;
  if ((((*(byte *)&object_02->flags & 1) == 0) && (gts_allow_floating_edges == 0)) && (gVar3 == 0))
  {
    gts_object_destroy(object_02);
  }
  pGVar4 = gts_triangle_class();
                    // WARNING: Could not recover jumptable at 0x08120e35. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar4->parent_class).parent_class)->destroy)(object);
  return;
}



// WARNING: Unknown calling convention

void face_class_init(GtsFaceClass *klass)

{
  (klass->parent_class).parent_class.clone = face_clone;
  (klass->parent_class).parent_class.destroy = face_destroy;
  return;
}



// WARNING: Unknown calling convention

void face_init(GtsFace *face)

{
  face->surfaces = (GSList *)0x0;
  return;
}



// WARNING: Unknown calling convention

gboolean gts_face_has_parent_surface(GtsFace *f,GtsSurface *s)

{
  GSList *pGVar1;
  GSList *i;
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_has_parent_surface","f != NULL");
    return 0;
  }
  pGVar1 = f->surfaces;
  while( true ) {
    if (pGVar1 == (GSList *)0x0) {
      return 0;
    }
    if ((GtsSurface *)pGVar1->data == s) break;
    pGVar1 = pGVar1->next;
  }
  return 1;
}



// WARNING: Unknown calling convention

GtsFace * gts_face_new(GtsFaceClass *klass,GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GtsFace *triangle;
  
  triangle = (GtsFace *)gts_object_new((GtsObjectClass *)klass);
  gts_triangle_set((GtsTriangle *)triangle,e1,e2,e3);
  return triangle;
}



// WARNING: Unknown calling convention

GtsFaceClass * gts_face_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo face_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_face_class::klass == (GtsFaceClass *)0x0) {
    pGVar3 = &face_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    face_info.name[0] = 'G';
    face_info.name[1] = 't';
    face_info.name[2] = 's';
    face_info.name[3] = 'F';
    face_info.name[4] = 'a';
    face_info.name[5] = 'c';
    face_info.name[6] = 'e';
    face_info.name[7] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(face_info.name + uVar1 + 8) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x20);
    face_info.object_size = 0x1c;
    face_info.class_size = 0x5c;
    face_info.class_init_func = face_class_init;
    face_info.object_init_func = face_init;
    parent_class = (GtsObjectClass *)gts_triangle_class();
    gts_face_class::klass = (GtsFaceClass *)gts_object_class_new(parent_class,&face_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_face_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

guint gts_face_neighbor_number(GtsFace *f,GtsSurface *s)

{
  GtsFace *f_00;
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GtsEdge **e1;
  GtsEdge **ppGVar4;
  GSList *i;
  GSList *pGVar5;
  guint local_30;
  GtsEdge *e [4];
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_neighbor_number","f != NULL");
    local_30 = 0;
  }
  else {
    local_30 = 0;
    e[0] = (f->triangle).e1;
    e[1] = (f->triangle).e2;
    e[3] = (GtsEdge *)0x0;
    e[2] = (f->triangle).e3;
    for (ppGVar4 = e; *ppGVar4 != (GtsEdge *)0x0; ppGVar4 = ppGVar4 + 1) {
      for (pGVar5 = (*ppGVar4)->triangles; pGVar5 != (GSList *)0x0;
          pGVar5 = (GSList *)(&pGVar5->data)[1]) {
LAB_08121034:
        f_00 = (GtsFace *)pGVar5->data;
        if (f_00 == f) {
LAB_08121084:
          pGVar5 = (GSList *)(&pGVar5->data)[1];
joined_r0x081210e9:
          if (pGVar5 == (GSList *)0x0) break;
          goto LAB_08121034;
        }
        pGVar1 = (GtsObjectClass *)gts_face_class();
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar5 = (GSList *)(&pGVar5->data)[1];
          goto joined_r0x081210e9;
        }
        if (f_00 == (GtsFace *)0x0) goto LAB_08121084;
        pGVar3 = (f_00->triangle).object.klass;
        if (pGVar3 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar1 == pGVar3) {
              if ((s == (GtsSurface *)0x0) ||
                 (gVar2 = gts_face_has_parent_surface(f_00,s), gVar2 != 0)) {
                local_30 = local_30 + 1;
              }
              break;
            }
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
          goto LAB_08121084;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
    }
  }
  return local_30;
}



// WARNING: Unknown calling convention

void face_clone(GtsObject *clone,GtsObject *object)

{
  GtsFaceClass *pGVar1;
  
  pGVar1 = gts_face_class();
  (*((pGVar1->parent_class).parent_class.parent_class)->clone)(clone,object);
  clone[2].klass = (GtsObjectClass *)0x0;
  return;
}



// WARNING: Unknown calling convention

void face_destroy(GtsObject *object)

{
  GtsObjectClass *pGVar1;
  GSList *i;
  GtsObjectClass *pGVar2;
  GtsFaceClass *pGVar3;
  GSList *next;
  
  pGVar2 = object[2].klass;
  if (pGVar2 != (GtsObjectClass *)0x0) {
    do {
      pGVar1 = *(GtsObjectClass **)((pGVar2->info).name + 4);
      gts_surface_remove_face(*(GtsSurface **)(pGVar2->info).name,(GtsFace *)object);
      pGVar2 = pGVar1;
    } while (pGVar1 != (GtsObjectClass *)0x0);
    if (object[2].klass != (GtsObjectClass *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/gts/face.c",0x23,"face_destroy","face->surfaces == NULL");
    }
  }
  pGVar3 = gts_face_class();
                    // WARNING: Could not recover jumptable at 0x081211cc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar3->parent_class).parent_class.parent_class)->destroy)(object);
  return;
}



// WARNING: Unknown calling convention

gboolean triangle_is_incompatible(GtsTriangle *t,GtsEdge *e,GtsSurface *s)

{
  GSList *pGVar1;
  GtsFace *f;
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GSList *i;
  
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return 0;
    }
    if ((GtsTriangle *)pGVar1->data != t) {
      pGVar2 = (GtsObjectClass *)gts_face_class();
      f = (GtsFace *)pGVar1->data;
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (f != (GtsFace *)0x0) {
        pGVar4 = (f->triangle).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar2 == pGVar4) {
              gVar3 = gts_face_has_parent_surface(f,s);
              if ((gVar3 != 0) &&
                 (gVar3 = gts_triangles_are_compatible(t,(GtsTriangle *)pGVar1->data,e), gVar3 == 0)
                 ) {
                return 1;
              }
              break;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

gboolean gts_face_is_compatible(GtsFace *f,GtsSurface *s)

{
  gboolean gVar1;
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_is_compatible","f != NULL");
    return 0;
  }
  if (s != (GtsSurface *)0x0) {
    gVar1 = triangle_is_incompatible(&f->triangle,(f->triangle).e1,s);
    if ((gVar1 == 0) &&
       (gVar1 = triangle_is_incompatible(&f->triangle,(f->triangle).e2,s), gVar1 == 0)) {
      gVar1 = triangle_is_incompatible(&f->triangle,(f->triangle).e3,s);
      return (uint)(gVar1 == 0);
    }
    return 0;
  }
  g_return_if_fail_warning(0,"gts_face_is_compatible","s != NULL");
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

GSList * gts_faces_from_edges(GSList *edges,GtsSurface *s)

{
  GtsFace *pGVar1;
  GtsFace *f;
  undefined4 uVar2;
  GtsObjectClass *pGVar3;
  gboolean gVar4;
  int iVar5;
  GtsObjectClass *c;
  GtsObjectClass *pGVar6;
  GSList *j;
  GSList *local_28;
  GSList *local_24;
  
  uVar2 = g_hash_table_new(0,0);
  local_28 = (GSList *)0x0;
  local_24 = edges;
  if (edges != (GSList *)0x0) {
    do {
      for (pGVar1 = *(GtsFace **)((int)local_24->data + 0x14); pGVar1 != (GtsFace *)0x0;
          pGVar1 = *(GtsFace **)((int)&pGVar1->triangle + 4)) {
        f = *(GtsFace **)&pGVar1->triangle;
        pGVar3 = (GtsObjectClass *)gts_face_class();
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (f != (GtsFace *)0x0) {
          pGVar6 = (f->triangle).object.klass;
          if (pGVar6 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar3 == pGVar6) {
                if (((s == (GtsSurface *)0x0) ||
                    (gVar4 = gts_face_has_parent_surface(f,s), gVar4 != 0)) &&
                   (iVar5 = g_hash_table_lookup(uVar2,f), iVar5 == 0)) {
                  local_28 = (GSList *)g_slist_prepend(local_28,f);
                  g_hash_table_insert(uVar2,f,local_24);
                }
                break;
              }
              pGVar6 = pGVar6->parent_class;
            } while (pGVar6 != (GtsObjectClass *)0x0);
          }
        }
      }
      local_24 = local_24->next;
    } while (local_24 != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar2);
  return local_28;
}



// WARNING: Unknown calling convention

void gts_face_foreach_neighbor(GtsFace *f,GtsSurface *s,GtsFunc func,gpointer data)

{
  GtsFace *f_00;
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GtsEdge **e1;
  GtsEdge **ppGVar4;
  GSList *i;
  GSList *pGVar5;
  GtsTriangle *t;
  GtsEdge *e [4];
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_foreach_neighbor","f != NULL");
  }
  else {
    if (func == (GtsFunc)0x0) {
      g_return_if_fail_warning(0,"gts_face_foreach_neighbor","func != NULL");
      return;
    }
    e[0] = (f->triangle).e1;
    e[1] = (f->triangle).e2;
    e[3] = (GtsEdge *)0x0;
    e[2] = (f->triangle).e3;
    for (ppGVar4 = e; *ppGVar4 != (GtsEdge *)0x0; ppGVar4 = ppGVar4 + 1) {
      for (pGVar5 = (*ppGVar4)->triangles; pGVar5 != (GSList *)0x0;
          pGVar5 = (GSList *)(&pGVar5->data)[1]) {
LAB_081214e4:
        f_00 = (GtsFace *)pGVar5->data;
        if (f_00 == f) {
LAB_0812153d:
          pGVar5 = (GSList *)(&pGVar5->data)[1];
joined_r0x08121591:
          if (pGVar5 == (GSList *)0x0) break;
          goto LAB_081214e4;
        }
        pGVar1 = (GtsObjectClass *)gts_face_class();
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar5 = (GSList *)(&pGVar5->data)[1];
          goto joined_r0x08121591;
        }
        if (f_00 == (GtsFace *)0x0) goto LAB_0812153d;
        pGVar3 = (f_00->triangle).object.klass;
        if (pGVar3 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar1 == pGVar3) {
              if ((s == (GtsSurface *)0x0) ||
                 (gVar2 = gts_face_has_parent_surface(f_00,s), gVar2 != 0)) {
                (*func)(f_00,data);
              }
              break;
            }
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
          goto LAB_0812153d;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

GSList * gts_face_neighbors(GtsFace *f,GtsSurface *s)

{
  GtsFace *f_00;
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GtsEdge **e1;
  GtsEdge **ppGVar4;
  GSList *i;
  GSList *pGVar5;
  GtsTriangle *t;
  GSList *local_30;
  GtsEdge *e [4];
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_neighbors","f != NULL");
    local_30 = (GSList *)0x0;
  }
  else {
    local_30 = (GSList *)0x0;
    e[0] = (f->triangle).e1;
    e[1] = (f->triangle).e2;
    e[3] = (GtsEdge *)0x0;
    e[2] = (f->triangle).e3;
    for (ppGVar4 = e; *ppGVar4 != (GtsEdge *)0x0; ppGVar4 = ppGVar4 + 1) {
      for (pGVar5 = (*ppGVar4)->triangles; pGVar5 != (GSList *)0x0;
          pGVar5 = (GSList *)(&pGVar5->data)[1]) {
LAB_08121644:
        f_00 = (GtsFace *)pGVar5->data;
        if (f_00 == f) {
LAB_081216a2:
          pGVar5 = (GSList *)(&pGVar5->data)[1];
joined_r0x08121709:
          if (pGVar5 == (GSList *)0x0) break;
          goto LAB_08121644;
        }
        pGVar1 = (GtsObjectClass *)gts_face_class();
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar5 = (GSList *)(&pGVar5->data)[1];
          goto joined_r0x08121709;
        }
        if (f_00 == (GtsFace *)0x0) goto LAB_081216a2;
        pGVar3 = (f_00->triangle).object.klass;
        if (pGVar3 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar1 == pGVar3) {
              if ((s == (GtsSurface *)0x0) ||
                 (gVar2 = gts_face_has_parent_surface(f_00,s), gVar2 != 0)) {
                local_30 = (GSList *)g_slist_prepend(local_30,f_00);
              }
              break;
            }
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
          goto LAB_081216a2;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
    }
  }
  return local_30;
}



// WARNING: Unknown calling convention

int compare_x(void *p1,void *p2)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return (uint)(*(double *)(*p2 + 0xc) < *(double *)(*p1 + 0xc)) * 2 + -1;
}



// WARNING: Unknown calling convention

int compare_y(void *p1,void *p2)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return (uint)(*(double *)(*p2 + 0x14) < *(double *)(*p1 + 0x14)) * 2 + -1;
}



// WARNING: Unknown calling convention

int compare_z(void *p1,void *p2)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return (uint)(*(double *)(*p2 + 0x1c) < *(double *)(*p1 + 0x1c)) * 2 + -1;
}



// WARNING: Unknown calling convention

GSList * gts_kdtree_range(GNode *tree_3d,GtsBBox *bbox,_func_int_void_ptr_void_ptr *compare)

{
  double dVar1;
  double dVar2;
  double dVar3;
  gpointer pvVar4;
  GNode *tree_3d_00;
  GSList *pGVar5;
  GSList *pGVar6;
  GSList *list;
  GtsPoint *p;
  code *compare_00;
  GNode *node;
  gdouble v;
  gdouble left;
  gdouble right;
  
  if (tree_3d == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_kdtree_range","tree_3d != NULL");
    pGVar6 = (GSList *)0x0;
  }
  else if (bbox == (GtsBBox *)0x0) {
    g_return_if_fail_warning(0,"gts_kdtree_range","bbox != NULL");
    pGVar6 = (GSList *)0x0;
  }
  else {
    pvVar4 = tree_3d->data;
    pGVar6 = (GSList *)0x0;
    if (pvVar4 != (gpointer)0x0) {
      if ((((*(double *)((int)pvVar4 + 0xc) < bbox->x1) ||
           (*(double *)((int)pvVar4 + 0x14) < bbox->y1)) ||
          (*(double *)((int)pvVar4 + 0x1c) < bbox->z1)) ||
         (((bbox->x2 < *(double *)((int)pvVar4 + 0xc) ||
           (bbox->y2 < *(double *)((int)pvVar4 + 0x14))) ||
          (bbox->z2 < *(double *)((int)pvVar4 + 0x1c))))) {
        pGVar6 = (GSList *)0x0;
      }
      else {
        pGVar6 = (GSList *)g_slist_prepend(0,pvVar4);
      }
      if (compare == compare_x) {
        dVar1 = bbox->y1;
        dVar2 = bbox->y2;
        dVar3 = *(double *)((int)pvVar4 + 0x14);
        compare_00 = compare_y;
      }
      else if (compare == compare_y) {
        dVar1 = bbox->z1;
        dVar2 = bbox->z2;
        dVar3 = *(double *)((int)pvVar4 + 0x1c);
        compare_00 = compare_z;
      }
      else {
        dVar1 = bbox->x1;
        dVar2 = bbox->x2;
        dVar3 = *(double *)((int)pvVar4 + 0xc);
        compare_00 = compare_x;
      }
      tree_3d_00 = tree_3d->children;
      if (tree_3d_00 != (GNode *)0x0) {
        if (dVar3 <= dVar2) {
          pGVar5 = gts_kdtree_range(tree_3d_00,bbox,compare_00);
          pGVar6 = (GSList *)g_slist_concat(pGVar6,pGVar5);
        }
        if (dVar1 <= dVar3) {
          gts_kdtree_range(tree_3d_00->next,bbox,compare_00);
          pGVar6 = (GSList *)g_slist_concat();
          return pGVar6;
        }
      }
    }
  }
  return pGVar6;
}



// WARNING: Unknown calling convention

GNode * gts_kdtree_new(GPtrArray *points,_func_int_void_ptr_void_ptr *compare)

{
  GNode *pGVar1;
  undefined4 uVar2;
  guint middle;
  code *__compar;
  GNode *local_30;
  GPtrArray array;
  
  if (points == (GPtrArray *)0x0) {
    g_return_if_fail_warning(0,"gts_kdtree_new","points != NULL");
    return (GNode *)0x0;
  }
  if (points->len == 0) {
    g_return_if_fail_warning(0,"gts_kdtree_new","points->len > 0");
    local_30 = (GNode *)0x0;
  }
  else {
    __compar = compare_y;
    if ((compare != compare_x) && (__compar = compare_x, compare == compare_y)) {
      __compar = compare_z;
    }
    qsort(points->pdata,points->len,4,__compar);
    middle = points->len - 1 >> 1;
    local_30 = (GNode *)g_node_new(points->pdata[middle]);
    if (1 < points->len) {
      array.len = middle;
      if (middle == 0) {
        uVar2 = g_node_new(0);
        g_node_prepend(local_30,uVar2);
        array.len = points->len - 1;
      }
      else {
        array.pdata = points->pdata;
        pGVar1 = gts_kdtree_new(&array,__compar);
        g_node_prepend(local_30,pGVar1);
        array.len = ~middle + points->len;
      }
      if (array.len == 0) {
        uVar2 = g_node_new(0);
        g_node_prepend(local_30,uVar2);
        return local_30;
      }
      array.pdata = points->pdata + middle + 1;
      pGVar1 = gts_kdtree_new(&array,__compar);
      g_node_prepend(local_30,pGVar1);
      return local_30;
    }
  }
  return local_30;
}



// WARNING: Unknown calling convention

void bbox_init(GtsBBox *bbox)

{
  bbox->bounded = (gpointer)0x0;
  return;
}



// WARNING: Unknown calling convention

void bbox_foreach_vertex(GtsPoint *p,GtsBBox *bb)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  dVar1 = p->x;
  if (dVar1 < bb->x1) {
    bb->x1 = dVar1;
  }
  dVar2 = p->y;
  if (dVar2 < bb->y1) {
    bb->y1 = dVar2;
  }
  dVar3 = p->z;
  if (dVar3 < bb->z1) {
    bb->z1 = dVar3;
  }
  if (bb->x2 < dVar1) {
    bb->x2 = dVar1;
  }
  if (bb->y2 < dVar2) {
    bb->y2 = dVar2;
  }
  if (bb->z2 < dVar3) {
    bb->z2 = dVar3;
  }
  return;
}



// WARNING: Unknown calling convention

gboolean gts_bboxes_are_overlapping(GtsBBox *bb1,GtsBBox *bb2)

{
  uint uVar1;
  
  uVar1 = 1;
  if (bb1 != bb2) {
    if ((((bb2->x2 < bb1->x1) || (bb1->x2 < bb2->x1)) || (bb2->y2 < bb1->y1)) ||
       ((bb1->y2 < bb2->y1 || (bb2->z2 < bb1->z1)))) {
      return 0;
    }
    uVar1 = (uint)(bb2->z1 <= bb1->z2);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void gts_bb_tree_traverse_overlapping
               (GNode *tree1,GNode *tree2,GtsBBTreeTraverseFunc func,gpointer data)

{
  GtsBBox *bb1_00;
  GtsBBox *bb2;
  gboolean gVar1;
  GNode *i;
  GtsBBox *bb1;
  GNode *i_1;
  GNode *tree1_00;
  GNode *tree2_00;
  
  if ((tree2 == (GNode *)0x0) || (tree1 == (GNode *)0x0)) {
    g_return_if_fail_warning();
    return;
  }
  bb1_00 = (GtsBBox *)tree1->data;
  bb2 = (GtsBBox *)tree2->data;
  gVar1 = gts_bboxes_are_overlapping(bb1_00,bb2);
  if (gVar1 == 0) {
    return;
  }
  tree1_00 = tree1->children;
  if (tree1_00 == (GNode *)0x0) {
    tree2_00 = tree2->children;
    if (tree2_00 == (GNode *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08121ddb. Too many branches
                    // WARNING: Treating indirect jump as call
      (*func)(bb1_00,bb2,data);
      return;
    }
  }
  else {
    tree2_00 = tree2->children;
    if ((tree2_00 == (GNode *)0x0) ||
       ((bb2->z2 - bb2->z1) * (bb2->y2 - bb2->y1) * (bb2->x2 - bb2->x1) <
        (bb1_00->z2 - bb1_00->z1) * (bb1_00->y2 - bb1_00->y1) * (bb1_00->x2 - bb1_00->x1))) {
      do {
        gts_bb_tree_traverse_overlapping(tree1_00,tree2,func,data);
        tree1_00 = tree1_00->next;
      } while (tree1_00 != (GNode *)0x0);
      return;
    }
  }
  do {
    gts_bb_tree_traverse_overlapping(tree1,tree2_00,func,data);
    tree2_00 = tree2_00->next;
  } while (tree2_00 != (GNode *)0x0);
  return;
}



// WARNING: Unknown calling convention

gboolean gts_bb_tree_is_overlapping(GNode *tree,GtsBBox *bbox)

{
  gboolean gVar1;
  GNode *i;
  GNode *tree_00;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_is_overlapping","tree != NULL");
  }
  else {
    if (bbox == (GtsBBox *)0x0) {
      g_return_if_fail_warning(0,"gts_bb_tree_is_overlapping","bbox != NULL");
      return 0;
    }
    gVar1 = gts_bboxes_are_overlapping(bbox,(GtsBBox *)tree->data);
    if (gVar1 != 0) {
      tree_00 = tree->children;
      if (tree_00 == (GNode *)0x0) {
        return 1;
      }
      do {
        gVar1 = gts_bb_tree_is_overlapping(tree_00,bbox);
        if (gVar1 != 0) {
          return 1;
        }
        tree_00 = tree_00->next;
      } while (tree_00 != (GNode *)0x0);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

gboolean gts_bbox_is_stabbed(GtsBBox *bb,GtsPoint *p)

{
  if (bb == (GtsBBox *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_is_stabbed","bb != NULL");
    return 0;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_is_stabbed","p != NULL");
    return 0;
  }
  if ((((p->x <= bb->x2) && (bb->y1 <= p->y)) && (p->y <= bb->y2)) && (bb->z1 <= p->z)) {
    return (uint)(p->z <= bb->z2);
  }
  return 0;
}



// WARNING: Unknown calling convention

void gts_bbox_point_distance2(GtsBBox *bb,GtsPoint *p,gdouble *min,gdouble *max)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  gdouble mz;
  gdouble dmax;
  gdouble zd2;
  gdouble yd2;
  gdouble xd2;
  gdouble Mx;
  double local_2c;
  double local_24;
  double local_14;
  
  if ((((bb != (GtsBBox *)0x0) && (p != (GtsPoint *)0x0)) && (min != (gdouble *)0x0)) &&
     (max != (gdouble *)0x0)) {
    dVar1 = p->x;
    dVar2 = p->y;
    dVar3 = p->z;
    dVar4 = bb->x1 - dVar1;
    dVar4 = dVar4 * dVar4;
    dVar5 = dVar1 - bb->x2;
    dVar5 = dVar5 * dVar5;
    dVar8 = bb->y1 - dVar2;
    dVar8 = dVar8 * dVar8;
    dVar9 = dVar2 - bb->y2;
    dVar9 = dVar9 * dVar9;
    dVar6 = bb->z1 - dVar3;
    dVar6 = dVar6 * dVar6;
    dVar7 = dVar3 - bb->z2;
    dVar7 = dVar7 * dVar7;
    local_2c = dVar4;
    if ((bb->x1 <= dVar1) && (local_2c = dVar5, dVar1 <= bb->x2)) {
      local_2c = 0.0;
    }
    local_14 = dVar8;
    if ((bb->y1 <= dVar2) && (local_14 = dVar9, dVar2 <= bb->y2)) {
      local_14 = 0.0;
    }
    local_24 = dVar6;
    if ((bb->z1 <= dVar3) && (local_24 = dVar7, dVar3 <= bb->z2)) {
      local_24 = 0.0;
    }
    dVar1 = dVar4;
    if (dVar4 <= dVar5 || dVar5 != dVar4) {
      dVar1 = dVar5;
    }
    if (dVar4 > dVar5 || dVar5 == dVar4) {
      dVar4 = dVar5;
    }
    dVar2 = dVar8;
    if (dVar8 <= dVar9 || dVar9 != dVar8) {
      dVar2 = dVar9;
    }
    if (dVar8 > dVar9 || dVar9 == dVar8) {
      dVar8 = dVar9;
    }
    dVar3 = dVar6;
    if (dVar6 <= dVar7 || dVar7 != dVar6) {
      dVar3 = dVar7;
    }
    if (dVar6 > dVar7 || dVar7 == dVar6) {
      dVar6 = dVar7;
    }
    dVar4 = dVar4 + dVar2 + dVar3;
    dVar3 = dVar8 + dVar1 + dVar3;
    if (dVar4 <= dVar3 || dVar3 != dVar4) {
      dVar3 = dVar4;
    }
    dVar6 = dVar1 + dVar2 + dVar6;
    if (dVar3 <= dVar6 || dVar6 != dVar3) {
      dVar6 = dVar3;
    }
    *min = local_2c + local_14 + local_24;
    *max = dVar6;
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

gdouble gts_bbox_diagonal2(GtsBBox *bb)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  if (bb != (GtsBBox *)0x0) {
    dVar1 = bb->x2 - bb->x1;
    dVar3 = bb->y2 - bb->y1;
    dVar2 = bb->z2 - bb->z1;
    return dVar2 * dVar2 + dVar3 * dVar3 + dVar1 * dVar1;
  }
  g_return_if_fail_warning(0,"gts_bbox_diagonal2","bb != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

void gts_bbox_set(GtsBBox *bbox,gpointer bounded,gdouble x1,gdouble y1,gdouble z1,gdouble x2,
                 gdouble y2,gdouble z2)

{
  if (bbox == (GtsBBox *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  if (((x1 <= x2) && (y1 <= y2)) && (z1 <= z2)) {
    bbox->x1 = x1;
    bbox->y1 = y1;
    bbox->z1 = z1;
    bbox->x2 = x2;
    bbox->y2 = y2;
    bbox->z2 = z2;
    bbox->bounded = bounded;
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Removing unreachable block (ram,0x08122422)
// WARNING: Removing unreachable block (ram,0x081222d0)
// WARNING: Removing unreachable block (ram,0x081222d4)
// WARNING: Removing unreachable block (ram,0x081222d8)
// WARNING: Removing unreachable block (ram,0x0812242a)
// WARNING: Removing unreachable block (ram,0x08122430)
// WARNING: Unknown calling convention

void gts_bb_tree_surface_boundary_distance
               (GNode *tree,GtsSurface *s,_func_gdouble_GtsPoint_ptr_gpointer *distance,
               gdouble delta,GtsRange *range)

{
  double dVar1;
  double dVar2;
  gdouble gVar3;
  double local_44;
  gpointer data [5];
  double local_24 [2];
  
  local_24[0] = 0.0;
  local_44 = delta;
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_boundary_distance","tree != NULL");
    return;
  }
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_boundary_distance","s != NULL");
    return;
  }
  if ((delta <= 0.0) || (1.0 <= delta)) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_boundary_distance","delta > 0. && delta < 1.");
    return;
  }
  if (range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_boundary_distance","range != NULL");
    return;
  }
  gts_range_init(range);
  gVar3 = gts_bbox_diagonal2((GtsBBox *)tree->data);
  local_44 = SQRT(gVar3) * local_44;
  data[0] = tree;
  data[1] = &local_44;
  data[3] = local_24;
  data[2] = range;
  data[4] = distance;
  gts_surface_foreach_edge(s,surface_distance_foreach_boundary,data);
  if (local_24[0] <= 0.0) {
    range->stddev = 0.0;
    range->mean = 0.0;
    range->max = 0.0;
    range->min = 0.0;
    return;
  }
  dVar1 = range->sum;
  dVar2 = range->sum2 - (dVar1 * dVar1) / local_24[0];
  if (dVar2 < 0.0) {
    range->stddev = 0.0;
  }
  else {
    range->stddev = SQRT(dVar2 / local_24[0]);
  }
  range->mean = dVar1 / local_24[0];
  return;
}



// WARNING: Removing unreachable block (ram,0x08122622)
// WARNING: Removing unreachable block (ram,0x081224d0)
// WARNING: Removing unreachable block (ram,0x081224d4)
// WARNING: Removing unreachable block (ram,0x081224d8)
// WARNING: Removing unreachable block (ram,0x0812262a)
// WARNING: Removing unreachable block (ram,0x08122630)
// WARNING: Unknown calling convention

void gts_bb_tree_surface_distance
               (GNode *tree,GtsSurface *s,GtsBBoxDistFunc distance,gdouble delta,GtsRange *range)

{
  double dVar1;
  double dVar2;
  gdouble gVar3;
  double local_44;
  gpointer data [5];
  double local_24 [2];
  
  local_24[0] = 0.0;
  local_44 = delta;
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_distance","tree != NULL");
    return;
  }
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_distance","s != NULL");
    return;
  }
  if ((delta <= 0.0) || (1.0 <= delta)) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_distance","delta > 0. && delta < 1.");
    return;
  }
  if (range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_distance","range != NULL");
    return;
  }
  gts_range_init(range);
  gVar3 = gts_bbox_diagonal2((GtsBBox *)tree->data);
  local_44 = SQRT(gVar3) * local_44;
  data[0] = tree;
  data[1] = &local_44;
  data[3] = local_24;
  data[2] = range;
  data[4] = distance;
  gts_surface_foreach_face(s,surface_distance_foreach_triangle,data);
  if (local_24[0] <= 0.0) {
    range->stddev = 0.0;
    range->mean = 0.0;
    range->max = 0.0;
    range->min = 0.0;
    return;
  }
  dVar1 = range->sum;
  dVar2 = range->sum2 - (dVar1 * dVar1) / local_24[0];
  if (dVar2 < 0.0) {
    range->stddev = 0.0;
  }
  else {
    range->stddev = SQRT(dVar2 / local_24[0]);
  }
  range->mean = dVar1 / local_24[0];
  return;
}



// WARNING: Unknown calling convention

GtsBBox * gts_bbox_new(GtsBBoxClass *klass,gpointer bounded,gdouble x1,gdouble y1,gdouble z1,
                      gdouble x2,gdouble y2,gdouble z2)

{
  GtsBBox *bbox_00;
  GtsBBox *bbox;
  
  if (klass != (GtsBBoxClass *)0x0) {
    bbox_00 = (GtsBBox *)gts_object_new(&klass->parent_class);
    gts_bbox_set(bbox_00,bounded,x1,y1,z1,x2,y2,z2);
    return bbox_00;
  }
  g_return_if_fail_warning(0,"gts_bbox_new","klass != NULL");
  return (GtsBBox *)0x0;
}



// WARNING: Unknown calling convention

GtsBBox * gts_bbox_points(GtsBBoxClass *klass,GSList *points)

{
  double dVar1;
  gpointer pvVar2;
  GtsBBox *bbox;
  GtsPoint *p;
  GtsBBox *pGVar3;
  GSList *i;
  GSList *pGVar4;
  
  if (points == (GSList *)0x0) {
    return (GtsBBox *)0x0;
  }
  pvVar2 = points->data;
  pGVar3 = gts_bbox_new(klass,points,*(gdouble *)((int)pvVar2 + 0xc),
                        *(gdouble *)((int)pvVar2 + 0x14),*(gdouble *)((int)pvVar2 + 0x1c),
                        *(gdouble *)((int)pvVar2 + 0xc),*(gdouble *)((int)pvVar2 + 0x14),
                        *(gdouble *)((int)pvVar2 + 0x1c));
  pGVar4 = points->next;
joined_r0x08122785:
  if (pGVar4 == (GSList *)0x0) {
    return pGVar3;
  }
  do {
    pvVar2 = pGVar4->data;
    dVar1 = *(double *)((int)pvVar2 + 0xc);
    if (dVar1 <= pGVar3->x2) {
      if (pGVar3->x1 <= dVar1) goto LAB_0812279a;
      pGVar3->x1 = dVar1;
      dVar1 = *(double *)((int)pvVar2 + 0x14);
      if (pGVar3->y2 < dVar1) goto LAB_081227a8;
LAB_081227f9:
      if (pGVar3->y1 <= dVar1) goto LAB_081227b2;
      pGVar3->y1 = dVar1;
      dVar1 = *(double *)((int)pvVar2 + 0x1c);
      if (dVar1 <= pGVar3->z2) goto LAB_08122811;
LAB_081227c0:
      pGVar3->z2 = dVar1;
    }
    else {
      pGVar3->x2 = dVar1;
LAB_0812279a:
      dVar1 = *(double *)((int)pvVar2 + 0x14);
      if (dVar1 <= pGVar3->y2) goto LAB_081227f9;
LAB_081227a8:
      pGVar3->y2 = dVar1;
LAB_081227b2:
      dVar1 = *(double *)((int)pvVar2 + 0x1c);
      if (pGVar3->z2 < dVar1) goto LAB_081227c0;
LAB_08122811:
      if (dVar1 < pGVar3->z1) break;
    }
    pGVar4 = pGVar4->next;
    if (pGVar4 == (GSList *)0x0) {
      return pGVar3;
    }
  } while( true );
  pGVar4 = pGVar4->next;
  pGVar3->z1 = dVar1;
  goto joined_r0x08122785;
}



// WARNING: Unknown calling convention

GtsBBox * gts_bbox_bboxes(GtsBBoxClass *klass,GSList *bboxes)

{
  gpointer pvVar1;
  GSList *pGVar2;
  GtsBBox *bb;
  GtsBBox *pGVar3;
  GtsBBox *bbox;
  
  if (bboxes == (GSList *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_bboxes","bboxes != NULL");
    return (GtsBBox *)0x0;
  }
  if (klass != (GtsBBoxClass *)0x0) {
    pvVar1 = bboxes->data;
    pGVar3 = gts_bbox_new(klass,bboxes,*(gdouble *)((int)pvVar1 + 0x10),
                          *(gdouble *)((int)pvVar1 + 0x18),*(gdouble *)((int)pvVar1 + 0x20),
                          *(gdouble *)((int)pvVar1 + 0x28),*(gdouble *)((int)pvVar1 + 0x30),
                          *(gdouble *)((int)pvVar1 + 0x38));
    for (pGVar2 = bboxes->next; pGVar2 != (GSList *)0x0; pGVar2 = pGVar2->next) {
      pvVar1 = pGVar2->data;
      if (*(double *)((int)pvVar1 + 0x10) < pGVar3->x1) {
        pGVar3->x1 = *(double *)((int)pvVar1 + 0x10);
      }
      if (*(double *)((int)pvVar1 + 0x18) < pGVar3->y1) {
        pGVar3->y1 = *(double *)((int)pvVar1 + 0x18);
      }
      if (*(double *)((int)pvVar1 + 0x20) < pGVar3->z1) {
        pGVar3->z1 = *(double *)((int)pvVar1 + 0x20);
      }
      if (pGVar3->x2 < *(double *)((int)pvVar1 + 0x28)) {
        pGVar3->x2 = *(double *)((int)pvVar1 + 0x28);
      }
      if (pGVar3->y2 < *(double *)((int)pvVar1 + 0x30)) {
        pGVar3->y2 = *(double *)((int)pvVar1 + 0x30);
      }
      if (pGVar3->z2 < *(double *)((int)pvVar1 + 0x38)) {
        pGVar3->z2 = *(double *)((int)pvVar1 + 0x38);
      }
    }
    return pGVar3;
  }
  g_return_if_fail_warning(0,"gts_bbox_bboxes","klass != NULL");
  return (GtsBBox *)0x0;
}



// WARNING: Unknown calling convention

GtsBBox * gts_bbox_segment(GtsBBoxClass *klass,GtsSegment *s)

{
  double dVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GtsBBox *pGVar4;
  GtsBBox *bbox;
  GtsPoint *p1;
  GtsPoint *p2;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_segment","s != NULL");
    return (GtsBBox *)0x0;
  }
  if (klass == (GtsBBoxClass *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_segment","klass != NULL");
    return (GtsBBox *)0x0;
  }
  pGVar4 = gts_bbox_new(klass,s,0.0,0.0,0.0,0.0,0.0,0.0);
  pGVar2 = s->v1;
  pGVar3 = s->v2;
  dVar1 = (pGVar2->p).x;
  if ((pGVar3->p).x < dVar1) {
    pGVar4->x2 = dVar1;
    pGVar4->x1 = (pGVar3->p).x;
    dVar1 = (pGVar2->p).y;
    if (dVar1 <= (pGVar3->p).y) goto LAB_08122a3f;
  }
  else {
    pGVar4->x1 = dVar1;
    pGVar4->x2 = (pGVar3->p).x;
    dVar1 = (pGVar2->p).y;
    if (dVar1 <= (pGVar3->p).y) {
LAB_08122a3f:
      pGVar4->y1 = dVar1;
      pGVar4->y2 = (pGVar3->p).y;
      dVar1 = (pGVar2->p).z;
      if ((pGVar3->p).z < dVar1) goto LAB_08122a56;
      goto LAB_08122a15;
    }
  }
  pGVar4->y2 = dVar1;
  pGVar4->y1 = (pGVar3->p).y;
  dVar1 = (pGVar2->p).z;
  if ((pGVar3->p).z < dVar1) {
LAB_08122a56:
    pGVar4->z2 = dVar1;
    pGVar4->z1 = (pGVar3->p).z;
    return pGVar4;
  }
LAB_08122a15:
  pGVar4->z1 = dVar1;
  pGVar4->z2 = (pGVar3->p).z;
  return pGVar4;
}



// WARNING: Unknown calling convention

GtsBBox * gts_bbox_triangle(GtsBBoxClass *klass,GtsTriangle *t)

{
  gdouble z1;
  gdouble y1;
  gdouble x1;
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  GtsEdge *pGVar8;
  GtsPoint *p;
  GtsBBox *pGVar9;
  GtsBBox *bbox;
  GtsVertex *pGVar10;
  GtsEdge *pGVar11;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_triangle","t != NULL");
    return (GtsBBox *)0x0;
  }
  if (klass == (GtsBBoxClass *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_triangle","klass != NULL");
    return (GtsBBox *)0x0;
  }
  pGVar10 = (t->e1->segment).v1;
  z1 = (pGVar10->p).z;
  y1 = (pGVar10->p).y;
  x1 = (pGVar10->p).x;
  pGVar9 = gts_bbox_new(klass,t,x1,y1,z1,x1,y1,z1);
  pGVar8 = t->e1;
  pGVar10 = (pGVar8->segment).v2;
  dVar1 = (pGVar10->p).x;
  dVar2 = pGVar9->x2;
  if (dVar2 < dVar1) {
    pGVar9->x2 = dVar1;
    dVar1 = (pGVar10->p).x;
    dVar2 = pGVar9->x2;
  }
  dVar3 = pGVar9->x1;
  if (dVar1 < dVar3) {
    pGVar9->x1 = dVar1;
    dVar3 = dVar1;
  }
  dVar1 = (pGVar10->p).y;
  dVar4 = pGVar9->y2;
  if (dVar4 < dVar1) {
    pGVar9->y2 = dVar1;
    dVar1 = (pGVar10->p).y;
    dVar4 = pGVar9->y2;
  }
  dVar5 = pGVar9->y1;
  if (dVar1 < dVar5) {
    pGVar9->y1 = dVar1;
    dVar5 = dVar1;
  }
  dVar1 = (pGVar10->p).z;
  dVar6 = pGVar9->z2;
  if (dVar6 < dVar1) {
    pGVar9->z2 = dVar1;
    dVar1 = (pGVar10->p).z;
    dVar6 = pGVar9->z2;
  }
  dVar7 = pGVar9->z1;
  if (dVar1 < dVar7) {
    pGVar11 = t->e2;
    pGVar9->z1 = dVar1;
    pGVar10 = (pGVar11->segment).v1;
    if ((pGVar8->segment).v1 != pGVar10) goto LAB_08122bbf;
  }
  else {
    pGVar11 = t->e2;
    pGVar10 = (pGVar11->segment).v1;
    dVar1 = dVar7;
    if ((pGVar8->segment).v1 != pGVar10) {
LAB_08122bbf:
      if (pGVar10 != (pGVar8->segment).v2) goto LAB_08122bc8;
    }
  }
  pGVar10 = (pGVar11->segment).v2;
LAB_08122bc8:
  dVar7 = (pGVar10->p).x;
  if (dVar2 < dVar7) {
    pGVar9->x2 = dVar7;
    dVar7 = (pGVar10->p).x;
  }
  if (dVar7 < dVar3) {
    pGVar9->x1 = dVar7;
  }
  dVar2 = (pGVar10->p).y;
  if (dVar4 < dVar2) {
    pGVar9->y2 = dVar2;
    dVar2 = (pGVar10->p).y;
  }
  if (dVar2 < dVar5) {
    pGVar9->y1 = dVar2;
  }
  dVar2 = (pGVar10->p).z;
  if (dVar6 < dVar2) {
    pGVar9->z2 = dVar2;
    dVar2 = (pGVar10->p).z;
  }
  if (dVar2 < dVar1) {
    pGVar9->z1 = dVar2;
  }
  return pGVar9;
}



// WARNING: Unknown calling convention

void bb_tree_free(GNode *tree,gboolean free_leaves)

{
  GNode *tree_00;
  GNode *i;
  
  if (tree != (GNode *)0x0) {
    if ((free_leaves != 0) || (tree->children != (GNode *)0x0)) {
      gts_object_destroy((GtsObject *)tree->data);
      for (tree_00 = tree->children; tree_00 != (GNode *)0x0; tree_00 = tree_00->next) {
        bb_tree_free(tree_00,free_leaves);
      }
    }
    return;
  }
  g_return_if_fail_warning(0,"bb_tree_free","tree != NULL");
  return;
}



// WARNING: Unknown calling convention

gdouble bb_tree_min_max(GNode *tree,GtsPoint *p,gdouble min_max,GSList **list)

{
  GNode *tree_00;
  GNode *tree_01;
  GSList *pGVar1;
  GNode *tree2;
  double local_3c;
  double local_34;
  double local_2c;
  double local_24 [2];
  
  tree_00 = tree->children;
  if (tree_00 == (GNode *)0x0) {
    pGVar1 = (GSList *)g_slist_prepend(*list,tree->data);
    *list = pGVar1;
  }
  else {
    gts_bbox_point_distance2((GtsBBox *)tree_00->data,p,local_24,&local_2c);
    tree_01 = tree_00->next;
    if (local_2c <= min_max || min_max != local_2c) {
      min_max = local_2c;
    }
    gts_bbox_point_distance2((GtsBBox *)tree_01->data,p,&local_34,&local_3c);
    if (local_3c <= min_max || min_max != local_3c) {
      min_max = local_3c;
    }
    if (local_24[0] < local_34) {
      if (local_24[0] <= min_max) {
        min_max = bb_tree_min_max(tree_00,p,min_max,list);
        if (local_34 <= min_max) {
          min_max = bb_tree_min_max(tree_01,p,min_max,list);
        }
      }
    }
    else if (local_34 <= min_max) {
      min_max = bb_tree_min_max(tree_01,p,min_max,list);
      if (local_24[0] <= min_max) {
        min_max = bb_tree_min_max(tree_00,p,min_max,list);
      }
    }
  }
  return min_max;
}



// WARNING: Unknown calling convention

GSList * gts_bb_tree_point_closest_bboxes(GNode *tree,GtsPoint *p)

{
  GtsBBox *pGVar1;
  GtsBBox *pGVar2;
  GSList *i;
  GtsBBox *pGVar3;
  GSList *next;
  GSList *prev;
  GtsBBox *pGVar4;
  gdouble max;
  double local_3c;
  gdouble local_34;
  gdouble min;
  GtsBBox *local_20 [4];
  
  local_20[0] = (GtsBBox *)0x0;
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_closest_bboxes","tree != NULL");
    return (GSList *)0x0;
  }
  if (p != (GtsPoint *)0x0) {
    gts_bbox_point_distance2((GtsBBox *)tree->data,p,&min,&local_34);
    local_34 = bb_tree_min_max(tree,p,local_34,(GSList **)local_20);
    pGVar2 = (GtsBBox *)0x0;
    if (local_20[0] != (GtsBBox *)0x0) {
      pGVar1 = local_20[0];
      pGVar4 = (GtsBBox *)0x0;
      do {
        while( true ) {
          pGVar3 = pGVar1;
          pGVar1 = (GtsBBox *)(pGVar3->object).reserved;
          gts_bbox_point_distance2((GtsBBox *)(pGVar3->object).klass,p,&local_3c,&max);
          if (local_3c <= local_34) break;
          pGVar2 = pGVar1;
          if (pGVar4 != (GtsBBox *)0x0) {
            (pGVar4->object).reserved = pGVar1;
            pGVar2 = local_20[0];
          }
          local_20[0] = pGVar2;
          g_slist_free_1(pGVar3);
          if (pGVar1 == (GtsBBox *)0x0) {
            return (GSList *)local_20[0];
          }
        }
        pGVar2 = local_20[0];
        pGVar4 = pGVar3;
      } while (pGVar1 != (GtsBBox *)0x0);
    }
    return (GSList *)pGVar2;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_point_closest_bboxes","p != NULL");
  return (GSList *)0x0;
}



// WARNING: Unknown calling convention

GtsPoint *
gts_bb_tree_point_closest(GNode *tree,GtsPoint *p,GtsBBoxClosestFunc closest,gdouble *distance)

{
  GSList *pGVar1;
  GtsPoint *tp;
  GtsPoint *p1;
  GSList *i;
  GSList *pGVar2;
  GtsPoint *np;
  GtsPoint *object;
  gdouble d;
  gdouble gVar3;
  double local_24;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_closest","tree != NULL");
    return (GtsPoint *)0x0;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_closest","p != NULL");
    return (GtsPoint *)0x0;
  }
  if (closest == (GtsBBoxClosestFunc)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_closest","closest != NULL");
    return (GtsPoint *)0x0;
  }
  pGVar1 = gts_bb_tree_point_closest_bboxes(tree,p);
  if (pGVar1 == (GSList *)0x0) {
    p1 = (GtsPoint *)0x0;
    local_24 = 1.797693134862316e+308;
  }
  else {
    local_24 = 1.797693134862316e+308;
    pGVar2 = pGVar1;
    object = (GtsPoint *)0x0;
    do {
      while( true ) {
        p1 = (*closest)(p,*(gpointer *)((int)pGVar2->data + 0xc));
        gVar3 = gts_point_distance2(p1,p);
        if (gVar3 < local_24) break;
        gts_object_destroy(&p1->object);
        pGVar2 = pGVar2->next;
        p1 = object;
        if (pGVar2 == (GSList *)0x0) goto LAB_08123049;
      }
      if (object != (GtsPoint *)0x0) {
        gts_object_destroy(&object->object);
      }
      pGVar2 = pGVar2->next;
      object = p1;
      local_24 = gVar3;
    } while (pGVar2 != (GSList *)0x0);
  }
LAB_08123049:
  g_slist_free(pGVar1);
  if (distance != (gdouble *)0x0) {
    *distance = local_24;
  }
  return p1;
}



// WARNING: Unknown calling convention

gdouble gts_bb_tree_point_distance(GNode *tree,GtsPoint *p,GtsBBoxDistFunc distance,GtsBBox **bbox)

{
  GSList *pGVar1;
  GSList *i;
  GSList *pGVar2;
  gdouble d;
  longdouble lVar3;
  longdouble lVar4;
  gdouble dmin;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_distance","tree != NULL");
    return 1.797693134862316e+308;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_distance","p != NULL");
    return 1.797693134862316e+308;
  }
  if (distance == (GtsBBoxDistFunc)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_distance","distance != NULL");
    return 1.797693134862316e+308;
  }
  pGVar1 = gts_bb_tree_point_closest_bboxes(tree,p);
  if (pGVar1 == (GSList *)0x0) {
    lVar3 = (longdouble)1.797693134862316e+308;
  }
  else {
    lVar3 = (longdouble)1.797693134862316e+308;
    pGVar2 = pGVar1;
    do {
      lVar4 = (longdouble)(*distance)(p,*(gpointer *)((int)pGVar2->data + 0xc));
      lVar3 = (longdouble)(double)lVar3;
      if ((ABS(lVar4) < ABS(lVar3)) && (lVar3 = lVar4, bbox != (GtsBBox **)0x0)) {
        *bbox = (GtsBBox *)pGVar2->data;
      }
      pGVar2 = pGVar2->next;
    } while (pGVar2 != (GSList *)0x0);
  }
  g_slist_free(pGVar1);
  return (double)lVar3;
}



// WARNING: Unknown calling convention

void gts_bb_tree_segment_distance
               (GNode *tree,GtsSegment *s,_func_gdouble_GtsPoint_ptr_gpointer *distance,
               gdouble delta,GtsRange *range)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  GtsPoint *p2;
  GtsPointClass *klass;
  GtsPoint *p;
  guint i;
  GtsPoint *p1;
  uint uVar6;
  gdouble t;
  gdouble val;
  float local_6c;
  ulonglong local_2c;
  
  if ((((tree != (GNode *)0x0) && (s != (GtsSegment *)0x0)) &&
      (distance != (_func_gdouble_GtsPoint_ptr_gpointer *)0x0)) &&
     ((0.0 < (float)delta && (range != (GtsRange *)0x0)))) {
    pGVar1 = s->v1;
    pGVar2 = s->v2;
    dVar3 = (pGVar2->p).x - (pGVar1->p).x;
    dVar4 = (pGVar2->p).y - (pGVar1->p).y;
    dVar5 = (pGVar2->p).z - (pGVar1->p).z;
    gts_range_init(range);
    klass = gts_point_class();
    p = (GtsPoint *)gts_object_new(&klass->parent_class);
    local_2c = (longlong)
               ROUND(SQRT(dVar5 * dVar5 + dVar4 * dVar4 + dVar3 * dVar3) / (double)(float)delta +
                     1.0) & 0xffffffff;
    uVar6 = 0;
    local_6c = 0.0;
    do {
      uVar6 = uVar6 + 1;
      p->x = (double)((float)dVar3 * local_6c + (float)(pGVar1->p).x);
      p->y = (double)((float)dVar4 * local_6c + (float)(pGVar1->p).y);
      p->z = (double)((float)dVar5 * local_6c + (float)(pGVar1->p).z);
      val = gts_bb_tree_point_distance(tree,p,distance,(GtsBBox **)0x0);
      gts_range_add_value(range,val);
      local_6c = local_6c + 1.0 / (float)local_2c;
    } while (uVar6 <= (uint)local_2c);
    gts_object_destroy((GtsObject *)p);
    gts_range_update(range);
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

void surface_distance_foreach_boundary(GtsEdge *e,gpointer *data)

{
  gdouble *pgVar1;
  double *pdVar2;
  double *pdVar3;
  GtsFace *pGVar4;
  gdouble length;
  gdouble gVar5;
  GtsRange range_edge;
  
  pgVar1 = (gdouble *)data[1];
  pdVar2 = (double *)data[3];
  pdVar3 = (double *)data[2];
  pGVar4 = gts_edge_is_boundary(e,(GtsSurface *)0x0);
  if (pGVar4 != (GtsFace *)0x0) {
    gts_bb_tree_segment_distance
              ((GNode *)*data,&e->segment,(_func_gdouble_GtsPoint_ptr_gpointer *)data[4],*pgVar1,
               &range_edge);
    if (range_edge.min < *pdVar3) {
      *pdVar3 = range_edge.min;
    }
    if (pdVar3[1] < range_edge.max) {
      pdVar3[1] = range_edge.max;
    }
    *(guint *)(pdVar3 + 6) = *(int *)(pdVar3 + 6) + range_edge.n;
    gVar5 = gts_point_distance(&((e->segment).v1)->p,&((e->segment).v2)->p);
    *pdVar2 = *pdVar2 + gVar5;
    pdVar3[2] = range_edge.mean * gVar5 + pdVar3[2];
    pdVar3[3] = range_edge.mean * gVar5 * range_edge.mean + pdVar3[3];
  }
  return;
}



// WARNING: Unknown calling convention

void gts_bb_tree_triangle_distance
               (GNode *tree,GtsTriangle *t,GtsBBoxDistFunc distance,gdouble delta,GtsRange *range)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  uint uVar13;
  GtsPointClass *klass;
  GtsPoint *p;
  guint n2;
  guint j;
  uint uVar14;
  gdouble t2;
  gdouble val;
  uint local_90;
  double local_8c;
  ulonglong local_3c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_triangle_distance","tree != NULL");
    return;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_triangle_distance","t != NULL");
    return;
  }
  if (distance == (GtsBBoxDistFunc)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_triangle_distance","distance != NULL");
    return;
  }
  if ((float)delta <= 0.0) {
    g_return_if_fail_warning(0,"gts_bb_tree_triangle_distance","delta > 0.");
    return;
  }
  if (range != (GtsRange *)0x0) {
    gts_triangle_vertices(t,local_20,&local_24,&local_28);
    dVar1 = (local_20[0]->p).x;
    dVar10 = (local_24->p).x - dVar1;
    dVar2 = (local_20[0]->p).y;
    dVar4 = (local_24->p).y - dVar2;
    dVar3 = (local_20[0]->p).z;
    dVar5 = (local_24->p).z - dVar3;
    dVar1 = (local_28->p).x - dVar1;
    dVar2 = (local_28->p).y - dVar2;
    dVar3 = (local_28->p).z - dVar3;
    gts_range_init(range);
    klass = gts_point_class();
    p = (GtsPoint *)gts_object_new(&klass->parent_class);
    local_90 = 0;
    local_3c = (longlong)ROUND(SQRT(dVar5 * dVar5 + dVar4 * dVar4 + dVar10 * dVar10) / delta + 1.0)
               & 0xffffffff;
    uVar13 = (uint)local_3c;
    dVar10 = (double)local_3c;
    local_8c = 0.0;
    while( true ) {
      dVar11 = 1.0 - local_8c;
      dVar4 = dVar1 * dVar11;
      dVar5 = dVar2 * dVar11;
      dVar6 = dVar3 * dVar11;
      local_3c = (longlong)ROUND(SQRT(dVar6 * dVar6 + dVar5 * dVar5 + dVar4 * dVar4) / delta + 1.0)
                 & 0xffffffff;
      dVar4 = (local_20[0]->p).x;
      dVar5 = (local_24->p).x;
      dVar6 = (local_20[0]->p).y;
      dVar7 = (local_24->p).y;
      dVar8 = (local_20[0]->p).z;
      dVar9 = (local_24->p).z;
      uVar14 = 0;
      dVar12 = 0.0;
      do {
        uVar14 = uVar14 + 1;
        p->x = dVar1 * dVar12 + local_8c * dVar5 + dVar4 * dVar11;
        p->y = dVar2 * dVar12 + local_8c * dVar7 + dVar6 * dVar11;
        p->z = dVar3 * dVar12 + local_8c * dVar9 + dVar11 * dVar8;
        val = gts_bb_tree_point_distance(tree,p,distance,(GtsBBox **)0x0);
        gts_range_add_value(range,val);
        dVar12 = dVar12 + dVar11 / (double)local_3c;
      } while (uVar14 <= (uint)local_3c);
      local_90 = local_90 + 1;
      if (uVar13 < local_90) break;
      local_8c = local_8c + 1.0 / dVar10;
    }
    gts_object_destroy((GtsObject *)p);
    gts_range_update(range);
    return;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_triangle_distance","range != NULL");
  return;
}



// WARNING: Unknown calling convention

void surface_distance_foreach_triangle(GtsTriangle *t,gpointer *data)

{
  double *pdVar1;
  double *pdVar2;
  GtsRange *range;
  gdouble *total_area;
  gdouble area;
  gdouble gVar3;
  GtsRange range_triangle;
  
  pdVar1 = (double *)data[2];
  pdVar2 = (double *)data[3];
                    // WARNING: Load size is inaccurate
  gts_bb_tree_triangle_distance((GNode *)*data,t,(GtsBBoxDistFunc)data[4],*data[1],&range_triangle);
  if (range_triangle.min < *pdVar1) {
    *pdVar1 = range_triangle.min;
  }
  if (pdVar1[1] < range_triangle.max) {
    pdVar1[1] = range_triangle.max;
  }
  *(guint *)(pdVar1 + 6) = *(int *)(pdVar1 + 6) + range_triangle.n;
  gVar3 = gts_triangle_area(t);
  *pdVar2 = *pdVar2 + gVar3;
  pdVar1[2] = range_triangle.mean * gVar3 + pdVar1[2];
  pdVar1[3] = range_triangle.mean * gVar3 * range_triangle.mean + pdVar1[3];
  return;
}



// WARNING: Unknown calling convention

void gts_bb_tree_destroy(GNode *tree,gboolean free_leaves)

{
  if (tree != (GNode *)0x0) {
    bb_tree_free(tree,free_leaves);
    g_node_destroy();
    return;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_destroy","tree != NULL");
  return;
}



// WARNING: Unknown calling convention

GSList * gts_bb_tree_overlap(GNode *tree,GtsBBox *bbox)

{
  gboolean gVar1;
  GSList *pGVar2;
  GtsBBox *bb;
  GNode *i;
  GNode *tree_00;
  GSList *pGVar3;
  GSList *list;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_overlap","tree != NULL");
    return (GSList *)0x0;
  }
  if (bbox != (GtsBBox *)0x0) {
    pGVar3 = (GSList *)0x0;
    gVar1 = gts_bboxes_are_overlapping(bbox,(GtsBBox *)tree->data);
    if (gVar1 != 0) {
      tree_00 = tree->children;
      if (tree_00 == (GNode *)0x0) {
        pGVar3 = (GSList *)g_slist_prepend();
        return pGVar3;
      }
      do {
        pGVar2 = gts_bb_tree_overlap(tree_00,bbox);
        pGVar3 = (GSList *)g_slist_concat(pGVar3,pGVar2);
        tree_00 = tree_00->next;
      } while (tree_00 != (GNode *)0x0);
    }
    return pGVar3;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_overlap","bbox != NULL");
  return (GSList *)0x0;
}



// WARNING: Unknown calling convention

GSList * gts_bb_tree_stabbed(GNode *tree,GtsPoint *p)

{
  gboolean gVar1;
  GSList *pGVar2;
  GtsBBox *bb;
  GNode *i;
  GNode *tree_00;
  GSList *pGVar3;
  GSList *list;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_stabbed","tree != NULL");
    return (GSList *)0x0;
  }
  if (p != (GtsPoint *)0x0) {
    pGVar3 = (GSList *)0x0;
    gVar1 = gts_bbox_is_stabbed((GtsBBox *)tree->data,p);
    if (gVar1 != 0) {
      tree_00 = tree->children;
      if (tree_00 == (GNode *)0x0) {
        pGVar3 = (GSList *)g_slist_prepend();
        return pGVar3;
      }
      do {
        pGVar2 = gts_bb_tree_stabbed(tree_00,p);
        pGVar3 = (GSList *)g_slist_concat(pGVar3,pGVar2);
        tree_00 = tree_00->next;
      } while (tree_00 != (GNode *)0x0);
    }
    return pGVar3;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_stabbed","p != NULL");
  return (GSList *)0x0;
}



// WARNING: Unknown calling convention

gboolean gts_bbox_overlaps_segment(GtsBBox *bb,GtsSegment *s)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsPoint *p2;
  int iVar3;
  GtsPoint *p1;
  double tv [3] [3];
  double bh [3];
  double bc [3];
  
  if (bb == (GtsBBox *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_overlaps_segment","bb != NULL");
    return 0;
  }
  if (s != (GtsSegment *)0x0) {
    pGVar1 = s->v1;
    bc[0] = (bb->x2 + bb->x1) * 0.5;
    bh[0] = (bb->x2 - bb->x1) * 0.5;
    bc[1] = (bb->y2 + bb->y1) * 0.5;
    bh[1] = (bb->y2 - bb->y1) * 0.5;
    pGVar2 = s->v2;
    bc[2] = (bb->z2 + bb->z1) * 0.5;
    bh[2] = (bb->z2 - bb->z1) * 0.5;
    tv[0][0] = (pGVar1->p).x;
    tv[0][1] = (pGVar1->p).y;
    tv[0][2] = (pGVar1->p).z;
    tv[1][0] = (pGVar2->p).x;
    tv[1][1] = (pGVar2->p).y;
    tv[1][2] = (pGVar2->p).z;
    tv[2][0] = tv[0][0];
    tv[2][1] = tv[0][1];
    tv[2][2] = tv[0][2];
    iVar3 = triBoxOverlap(bc,bh,tv);
    return iVar3;
  }
  g_return_if_fail_warning(0,"gts_bbox_overlaps_segment","s != NULL");
  return 0;
}



// WARNING: Unknown calling convention

gboolean gts_bbox_overlaps_triangle(GtsBBox *bb,GtsTriangle *t)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  int iVar4;
  GtsPoint *p1;
  GtsPoint *p2;
  double tv [3] [3];
  double bh [3];
  double bc [3];
  
  if (bb == (GtsBBox *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_overlaps_triangle","bb != NULL");
    return 0;
  }
  if (t != (GtsTriangle *)0x0) {
    pGVar1 = (t->e1->segment).v1;
    pGVar2 = (t->e1->segment).v2;
    pGVar3 = (t->e2->segment).v1;
    if ((pGVar1 == pGVar3) || (pGVar2 == pGVar3)) {
      pGVar3 = (t->e2->segment).v2;
    }
    tv[0][0] = (pGVar1->p).x;
    tv[0][1] = (pGVar1->p).y;
    tv[0][2] = (pGVar1->p).z;
    tv[1][0] = (pGVar2->p).x;
    tv[1][1] = (pGVar2->p).y;
    tv[1][2] = (pGVar2->p).z;
    tv[2][0] = (pGVar3->p).x;
    tv[2][1] = (pGVar3->p).y;
    tv[2][2] = (pGVar3->p).z;
    bh[0] = (bb->x2 - bb->x1) * 0.5;
    bh[1] = (bb->y2 - bb->y1) * 0.5;
    bh[2] = (bb->z2 - bb->z1) * 0.5;
    bc[0] = (bb->x1 + bb->x2) * 0.5;
    bc[1] = (bb->y1 + bb->y2) * 0.5;
    bc[2] = (bb->z2 + bb->z1) * 0.5;
    iVar4 = triBoxOverlap(bc,bh,tv);
    return iVar4;
  }
  g_return_if_fail_warning(0,"gts_bbox_overlaps_triangle","t != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void gts_bbox_draw(GtsBBox *bb,FILE *fptr)

{
  if (bb != (GtsBBox *)0x0) {
    __fprintf_chk(fptr,1,"OFF 8 6 12\n");
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y1,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y1,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y2,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y2,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y1,bb->z2);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y1,bb->z2);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y2,bb->z2);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y2,bb->z2);
    fwrite("4 3 2 1 0\n4 4 5 6 7\n4 2 3 7 6\n4 0 1 5 4\n4 0 4 7 3\n4 1 2 6 5\n",1,0x3c,(FILE *)fptr)
    ;
    return;
  }
  g_return_if_fail_warning(0,"gts_bbox_draw","bb != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_bb_tree_draw(GNode *tree,guint depth,FILE *fptr)

{
  GNode *tree_00;
  uint uVar1;
  guint d;
  GNode *i;
  
  if ((tree == (GNode *)0x0) || (fptr == (FILE *)0x0)) {
    g_return_if_fail_warning();
    return;
  }
  uVar1 = g_node_depth(tree);
  if (uVar1 == 1) {
    __fprintf_chk(fptr,1,"{ LIST");
    if (depth == 1) goto LAB_08124080;
  }
  else if (uVar1 == depth) {
LAB_08124080:
    gts_bbox_draw((GtsBBox *)tree->data,fptr);
    goto LAB_08123fed;
  }
  if (uVar1 < depth) {
    for (tree_00 = tree->children; tree_00 != (GNode *)0x0; tree_00 = tree_00->next) {
      gts_bb_tree_draw(tree_00,depth,fptr);
    }
  }
LAB_08123fed:
  if (uVar1 != 1) {
    return;
  }
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention

GtsBBox * gts_bbox_surface(GtsBBoxClass *klass,GtsSurface *surface)

{
  GtsBBox *data;
  GtsBBox *bbox;
  
  if (klass == (GtsBBoxClass *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_surface","klass != NULL");
    return (GtsBBox *)0x0;
  }
  if (surface != (GtsSurface *)0x0) {
    data = gts_bbox_new(klass,surface,0.0,0.0,0.0,0.0,0.0,0.0);
    data->z1 = 1.797693134862316e+308;
    data->y1 = 1.797693134862316e+308;
    data->x1 = 1.797693134862316e+308;
    data->z2 = -1.797693134862316e+308;
    data->y2 = -1.797693134862316e+308;
    data->x2 = -1.797693134862316e+308;
    gts_surface_foreach_vertex(surface,bbox_foreach_vertex,data);
    return data;
  }
  g_return_if_fail_warning(0,"gts_bbox_surface","surface != NULL");
  return (GtsBBox *)0x0;
}



// WARNING: Unknown calling convention

GtsBBoxClass * gts_bbox_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo bbox_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_bbox_class::klass == (GtsBBoxClass *)0x0) {
    pGVar3 = &bbox_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    bbox_info.name[0] = 'G';
    bbox_info.name[1] = 't';
    bbox_info.name[2] = 's';
    bbox_info.name[3] = 'B';
    bbox_info.name[4] = 'B';
    bbox_info.name[5] = 'o';
    bbox_info.name[6] = 'x';
    bbox_info.name[7] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(bbox_info.name + uVar1 + 8) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x20);
    bbox_info.object_size = 0x40;
    bbox_info.class_size = 0x5c;
    bbox_info.object_init_func = bbox_init;
    parent_class = gts_object_class();
    gts_bbox_class::klass = (GtsBBoxClass *)gts_object_class_new(parent_class,&bbox_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_bbox_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void prepend_triangle_bbox(GtsTriangle *t,GSList **bboxes)

{
  GtsBBoxClass *klass;
  GtsBBox *pGVar1;
  GSList *pGVar2;
  
  klass = gts_bbox_class();
  pGVar1 = gts_bbox_triangle(klass,t);
  pGVar2 = (GSList *)g_slist_prepend(*bboxes,pGVar1);
  *bboxes = pGVar2;
  return;
}



// WARNING: Unknown calling convention

GNode * gts_bb_tree_new(GSList *bboxes)

{
  double dVar1;
  double dVar2;
  gpointer pvVar3;
  GtsBBoxClass *klass;
  GtsBBox *pGVar4;
  GNode *pGVar5;
  GSList *last;
  GNode *pGVar6;
  GSList *bboxes_00;
  GSList *positive;
  GSList *i;
  int iVar7;
  GtsBBox *bbox;
  GSList *bboxes_01;
  GSList *negative;
  int local_2c;
  int local_28;
  
  if (bboxes == (GSList *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_new","bboxes != NULL");
    return (GNode *)0x0;
  }
  if (bboxes->next == (GSList *)0x0) {
    pGVar5 = (GNode *)g_node_new();
    return pGVar5;
  }
  klass = gts_bbox_class();
  pGVar4 = gts_bbox_bboxes(klass,bboxes);
  pGVar5 = (GNode *)g_node_new(pGVar4);
  dVar1 = pGVar4->x2 - pGVar4->x1;
  dVar2 = pGVar4->y2 - pGVar4->y1;
  if (dVar1 <= dVar2) {
    iVar7 = 8;
    if (pGVar4->z2 - pGVar4->z1 <= dVar2) goto LAB_081242b7;
  }
  else {
    iVar7 = 0;
    if (pGVar4->z2 - pGVar4->z1 <= dVar1) goto LAB_081242b7;
  }
  iVar7 = 0x10;
LAB_081242b7:
  dVar1 = *(double *)((int)&pGVar4->x1 + iVar7);
  bboxes_00 = (GSList *)0x0;
  dVar2 = *(double *)((int)&pGVar4->x2 + iVar7);
  bboxes_01 = (GSList *)0x0;
  local_28 = 0;
  local_2c = 0;
  do {
    while (pvVar3 = bboxes->data,
          (*(double *)((int)pvVar3 + iVar7 + 0x10) + *(double *)((int)pvVar3 + iVar7 + 0x28)) * 0.5
          <= (double)((float)(dVar1 + dVar2) * 0.5)) {
      bboxes_01 = (GSList *)g_slist_prepend(bboxes_01,pvVar3);
      bboxes = bboxes->next;
      local_28 = local_28 + 1;
      if (bboxes == (GSList *)0x0) goto LAB_0812433b;
    }
    bboxes_00 = (GSList *)g_slist_prepend(bboxes_00,pvVar3);
    bboxes = bboxes->next;
    local_2c = local_2c + 1;
  } while (bboxes != (GSList *)0x0);
LAB_0812433b:
  if (bboxes_00 == (GSList *)0x0) {
    iVar7 = g_slist_nth(bboxes_01,local_28 - 1U >> 1);
    bboxes_00 = *(GSList **)(iVar7 + 4);
    *(undefined4 *)(iVar7 + 4) = 0;
  }
  else if (bboxes_01 == (GSList *)0x0) {
    iVar7 = g_slist_nth(bboxes_00,local_2c - 1U >> 1);
    bboxes_01 = *(GSList **)(iVar7 + 4);
    *(undefined4 *)(iVar7 + 4) = 0;
  }
  pGVar6 = gts_bb_tree_new(bboxes_00);
  g_node_prepend(pGVar5,pGVar6);
  g_slist_free(bboxes_00);
  pGVar6 = gts_bb_tree_new(bboxes_01);
  g_node_prepend(pGVar5,pGVar6);
  g_slist_free(bboxes_01);
  return pGVar5;
}



// WARNING: Unknown calling convention

GNode * gts_bb_tree_surface(GtsSurface *s)

{
  GNode *pGVar1;
  GNode *tree;
  GSList *local_10 [2];
  
  local_10[0] = (GSList *)0x0;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_face(s,prepend_triangle_bbox,local_10);
    pGVar1 = gts_bb_tree_new(local_10[0]);
    g_slist_free(local_10[0]);
    return pGVar1;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_surface","s != NULL");
  return (GNode *)0x0;
}



// WARNING: Unknown calling convention

guint gts_file_read(GtsFile *f,gpointer ptr,guint size,guint nmemb)

{
  guint gVar1;
  guint n;
  uint uVar2;
  guint i;
  uint uVar3;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_read","f != NULL");
    return 0;
  }
  if (ptr != (gpointer)0x0) {
    if ((FILE *)f->fp == (FILE *)0x0) {
      g_return_if_fail_warning(0,"gts_file_read","f->fp != NULL");
      return 0;
    }
    gVar1 = 0;
    if (f->type != GTS_ERROR) {
      gVar1 = fread(ptr,size,nmemb,(FILE *)f->fp);
      uVar3 = size * gVar1;
      if (uVar3 != 0) {
        uVar2 = 0;
        do {
          while (f->curpos = f->curpos + 1, *(char *)((int)ptr + uVar2) == '\n') {
            uVar2 = uVar2 + 1;
            f->curline = f->curline + 1;
            f->curpos = 1;
            if (uVar3 < uVar2 || uVar3 - uVar2 == 0) {
              return gVar1;
            }
          }
          uVar2 = uVar2 + 1;
        } while (uVar2 <= uVar3 && uVar3 - uVar2 != 0);
      }
    }
    return gVar1;
  }
  g_return_if_fail_warning(0,"gts_file_read","ptr != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void gts_file_verror(GtsFile *f,gchar *format,va_list args)

{
  gchar *pgVar1;
  
  if ((f != (GtsFile *)0x0) && (format != (gchar *)0x0)) {
    if (f->type == GTS_ERROR) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/gts/misc.c",0x8c,"gts_file_verror","f->type != GTS_ERROR");
    }
    pgVar1 = (gchar *)g_strdup_vprintf(format,args);
    f->type = GTS_ERROR;
    f->error = pgVar1;
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

void gts_file_variable_error(GtsFile *f,GtsFileVariable *vars,gchar *name,gchar *format,...)

{
  int iVar1;
  GtsFileVariable *var;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_variable_error","f != NULL");
    return;
  }
  if (vars == (GtsFileVariable *)0x0) {
    g_return_if_fail_warning(0,"gts_file_variable_error","vars != NULL");
    return;
  }
  if (name == (gchar *)0x0) {
    g_return_if_fail_warning(0,"gts_file_variable_error","name != NULL");
    return;
  }
  if (format == (gchar *)0x0) {
    g_return_if_fail_warning(0,"gts_file_variable_error","format != NULL");
    return;
  }
  while( true ) {
    if (vars->type == GTS_NONE) {
      g_return_if_fail_warning(0,"gts_file_variable_error","var->type != GTS_NONE");
      return;
    }
    iVar1 = strcmp(vars->name,name);
    if (iVar1 == 0) break;
    vars = vars + 1;
  }
  if (vars->set != 0) {
    f->line = vars->line;
    f->pos = vars->pos;
  }
  gts_file_verror(f,format,&stack0x00000014);
  return;
}



// WARNING: Unknown calling convention

void gts_file_error(GtsFile *f,gchar *format,...)

{
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_error","f != NULL");
    return;
  }
  if (format != (gchar *)0x0) {
    gts_file_verror(f,format,&stack0x0000000c);
    return;
  }
  g_return_if_fail_warning(0,"gts_file_error","format != NULL");
  return;
}



// WARNING: Unknown calling convention

gint gts_file_getc(GtsFile *f)

{
  char cVar1;
  gint c;
  int iVar2;
  char *pcVar3;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_getc","f != NULL");
  }
  else if (f->type != GTS_ERROR) {
    if ((FILE *)f->fp == (FILE *)0x0) {
      iVar2 = -1;
      cVar1 = *f->s;
      if (cVar1 != '\0') {
        iVar2 = (int)cVar1;
        f->s = f->s + 1;
      }
    }
    else {
      iVar2 = fgetc((FILE *)f->fp);
    }
    f->curpos = f->curpos + 1;
LAB_08124880:
    do {
      pcVar3 = f->comments;
      while( true ) {
        if (*pcVar3 == '\0') {
          if (iVar2 == 0x7b) {
            f->scope = f->scope + 1;
            return 0x7b;
          }
          if (iVar2 != 0x7d) {
            if (iVar2 != 10) {
              return iVar2;
            }
            f->curline = f->curline + 1;
            f->curpos = 1;
            return 10;
          }
          if (f->scope != 0) {
            f->scope = f->scope - 1;
            return 0x7d;
          }
          f->line = f->curline;
          f->pos = f->curpos - 1;
          gts_file_error(f,"no matching opening brace");
          return -1;
        }
        if ((char)iVar2 == *pcVar3) break;
        pcVar3 = pcVar3 + 1;
      }
      while (iVar2 != 10) {
        while( true ) {
          if (iVar2 == -1) goto LAB_081248b5;
          if ((FILE *)f->fp == (FILE *)0x0) break;
          iVar2 = fgetc((FILE *)f->fp);
          if (iVar2 == 10) goto LAB_081248b5;
        }
        cVar1 = *f->s;
        if (cVar1 == '\0') {
          iVar2 = -1;
          goto LAB_08124880;
        }
        f->s = f->s + 1;
        iVar2 = (int)cVar1;
      }
LAB_081248b5:
      if (iVar2 == 10) {
        f->curline = f->curline + 1;
        f->curpos = 1;
        if ((FILE *)f->fp == (FILE *)0x0) {
          iVar2 = -1;
          cVar1 = *f->s;
          if (cVar1 != '\0') {
            iVar2 = (int)cVar1;
            f->s = f->s + 1;
          }
        }
        else {
          iVar2 = fgetc((FILE *)f->fp);
        }
      }
    } while( true );
  }
  return -1;
}



// WARNING: Unknown calling convention

gint gts_file_getc_scope(GtsFile *f)

{
  gint gVar1;
  gint c;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_getc_scope","f != NULL");
    return -1;
  }
  gVar1 = -1;
  if (f->type != GTS_ERROR) {
    if (f->scope < f->scope_max || f->scope == f->scope_max) {
      gVar1 = gts_file_getc(f);
      return gVar1;
    }
    do {
      gVar1 = gts_file_getc(f);
      if (gVar1 == -1) {
        return -1;
      }
    } while (f->scope_max <= f->scope && f->scope != f->scope_max);
  }
  return gVar1;
}



// WARNING: Unknown calling convention

void gts_file_destroy(GtsFile *f)

{
  if (f != (GtsFile *)0x0) {
    g_free(f->delimiters);
    g_free(f->comments);
    g_free(f->tokens);
    if (f->error != (gchar *)0x0) {
      g_free(f->error);
    }
    if (f->s1 != (gchar *)0x0) {
      g_free(f->s1);
    }
    g_string_free(f->token,1);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_file_destroy","f != NULL");
  return;
}



// WARNING: Unknown calling convention

GtsFile * file_new(void)

{
  GtsFile *pGVar1;
  GString *pGVar2;
  gchar *pgVar3;
  
  pGVar1 = (GtsFile *)g_malloc(0x40);
  pGVar1->fp = (FILE *)0x0;
  pGVar1->s1 = (gchar *)0x0;
  pGVar1->s = (gchar *)0x0;
  pGVar1->curline = 1;
  pGVar1->curpos = 1;
  pGVar2 = (GString *)g_string_new(&DAT_0814741b);
  pGVar1->type = 0;
  pGVar1->error = (gchar *)0x0;
  pGVar1->next_token = 0;
  pGVar1->scope_max = 0;
  pGVar1->scope = 0;
  pGVar1->token = pGVar2;
  pgVar3 = (gchar *)g_strdup(&DAT_08160ded);
  pGVar1->delimiters = pgVar3;
  pgVar3 = (gchar *)g_strdup(&DAT_08160df0);
  pGVar1->comments = pgVar3;
  pgVar3 = (gchar *)g_strdup("\n{}()=");
  pGVar1->tokens = pgVar3;
  return pGVar1;
}



// WARNING: Unknown calling convention

void gts_file_next_token(GtsFile *f)

{
  GString *pGVar1;
  gsize gVar2;
  GtsTokenType GVar3;
  char cVar4;
  char *pcVar5;
  int iVar6;
  char cVar7;
  char cVar8;
  char *pcVar9;
  GtsTokenType GVar10;
  gboolean in_string;
  gint c;
  gchar *a;
  char *pcVar11;
  char *pcVar12;
  bool bVar13;
  byte bVar14;
  
  bVar14 = 0;
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_next_token","f != NULL");
    return;
  }
  if (f->type == GTS_ERROR) {
    return;
  }
  *f->token->str = '\0';
  pGVar1 = f->token;
  pGVar1->len = 0;
  GVar3 = f->next_token;
  if (GVar3 == 0) {
    GVar3 = gts_file_getc_scope(f);
  }
  else {
    for (pcVar9 = f->tokens; *pcVar9 != '\0'; pcVar9 = pcVar9 + 1) {
      cVar4 = (char)GVar3;
      if (cVar4 == *pcVar9) {
        f->line = f->curline;
        f->pos = f->curpos - 1;
        gVar2 = pGVar1->len;
        if (gVar2 + 1 < pGVar1->allocated_len) {
          pGVar1->str[gVar2] = cVar4;
          pGVar1->len = gVar2 + 1;
          pGVar1->str[gVar2 + 1] = '\0';
        }
        else {
          g_string_insert_c(pGVar1,0xffffffff,(int)cVar4);
        }
        GVar3 = f->next_token;
        f->next_token = 0;
        f->type = GVar3;
        return;
      }
    }
    f->next_token = 0;
  }
  bVar13 = false;
  f->type = GTS_NONE;
  if (GVar3 != 0xffffffff) {
LAB_08124c50:
    do {
      cVar4 = (char)GVar3;
      if (bVar13) {
        for (pcVar9 = f->delimiters; *pcVar9 != '\0'; pcVar9 = pcVar9 + 1) {
          if (cVar4 == *pcVar9) goto LAB_08124c72;
        }
        for (pcVar9 = f->tokens; *pcVar9 != '\0'; pcVar9 = pcVar9 + 1) {
          if (cVar4 == *pcVar9) {
            f->next_token = GVar3;
            GVar3 = f->type;
            goto LAB_08124c75;
          }
        }
        pGVar1 = f->token;
        gVar2 = pGVar1->len;
        if (pGVar1->allocated_len <= gVar2 + 1) {
          g_string_insert_c(pGVar1,0xffffffff,(int)cVar4);
          GVar3 = gts_file_getc_scope(f);
          if (GVar3 == 0xffffffff) break;
          goto LAB_08124c50;
        }
        pGVar1->str[gVar2] = cVar4;
        pGVar1->len = gVar2 + 1;
        pGVar1->str[gVar2 + 1] = '\0';
        GVar3 = gts_file_getc_scope(f);
      }
      else {
        for (pcVar9 = f->delimiters; *pcVar9 != '\0'; pcVar9 = pcVar9 + 1) {
          if (cVar4 == *pcVar9) {
            GVar3 = gts_file_getc_scope(f);
            goto joined_r0x08124cf3;
          }
        }
        f->line = f->curline;
        f->pos = f->curpos - 1;
        pGVar1 = f->token;
        gVar2 = pGVar1->len;
        if (gVar2 + 1 < pGVar1->allocated_len) {
          pGVar1->str[gVar2] = cVar4;
          pGVar1->len = gVar2 + 1;
          pGVar1->str[gVar2 + 1] = '\0';
          GVar10 = GVar3;
        }
        else {
          g_string_insert_c(pGVar1,0xffffffff,(int)cVar4);
          GVar10 = GVar3 & 0xff;
        }
        for (pcVar9 = f->tokens; *pcVar9 != '\0'; pcVar9 = pcVar9 + 1) {
          if ((char)GVar10 == *pcVar9) {
            f->type = GVar3;
            goto LAB_08124c75;
          }
        }
        bVar13 = true;
        GVar3 = gts_file_getc_scope(f);
      }
joined_r0x08124cf3:
    } while (GVar3 != 0xffffffff);
LAB_08124c72:
    GVar3 = f->type;
LAB_08124c75:
    if (GVar3 != GTS_NONE) {
      return;
    }
  }
  if (f->token->len == 0) {
    return;
  }
  pcVar9 = f->token->str;
  cVar8 = *pcVar9;
  pcVar11 = pcVar9;
  cVar4 = cVar8;
  while (cVar4 != '\0') {
    pcVar5 = "+-";
    while( true ) {
      pcVar12 = pcVar9;
      cVar7 = cVar8;
      if (*pcVar5 == '\0') goto LAB_08124e45;
      if (cVar4 == *pcVar5) break;
      pcVar5 = pcVar5 + 1;
    }
    pcVar11 = pcVar11 + 1;
    cVar4 = *pcVar11;
  }
  goto LAB_08124cbc;
LAB_08124e79:
  do {
    pcVar11 = "+-eE.";
    while( true ) {
      pcVar12 = pcVar9;
      cVar7 = cVar8;
      if (*pcVar11 == '\0') goto LAB_08124ea2;
      if (cVar4 == *pcVar11) break;
      pcVar11 = pcVar11 + 1;
    }
    cVar4 = pcVar5[1];
    pcVar5 = pcVar5 + 1;
  } while (cVar4 != '\0');
  goto LAB_08124cbc;
LAB_08124ea2:
  do {
    pcVar11 = "+-0123456789eE.";
    while( true ) {
      bVar13 = *pcVar11 == '\0';
      if (bVar13) {
        iVar6 = 2;
        pcVar11 = pcVar9;
        pcVar5 = "0x";
        goto code_r0x08124f13;
      }
      if (cVar7 == *pcVar11) break;
      pcVar11 = pcVar11 + 1;
    }
    cVar7 = pcVar12[1];
    pcVar12 = pcVar12 + 1;
  } while (cVar7 != '\0');
  goto LAB_08124ec8;
LAB_08124e45:
  do {
    pcVar11 = "+-0123456789";
    while( true ) {
      pcVar5 = pcVar9;
      cVar4 = cVar8;
      if (*pcVar11 == '\0') goto LAB_08124e79;
      if (cVar7 == *pcVar11) break;
      pcVar11 = pcVar11 + 1;
    }
    cVar7 = pcVar12[1];
    pcVar12 = pcVar12 + 1;
  } while (cVar7 != '\0');
LAB_08124e68:
  f->type = GTS_INT;
  return;
LAB_08124f72:
  do {
    pcVar11 = "+-0123456789abcdefx.p";
    while( true ) {
      if (*pcVar11 == '\0') goto LAB_08124cbc;
      if (cVar8 == *pcVar11) break;
      pcVar11 = pcVar11 + 1;
    }
    pcVar9 = pcVar9 + 1;
    cVar8 = *pcVar9;
  } while (cVar8 != '\0');
LAB_08124ec8:
  f->type = GTS_FLOAT;
  return;
  while( true ) {
    iVar6 = iVar6 + -1;
    bVar13 = *pcVar11 == *pcVar5;
    pcVar11 = pcVar11 + (uint)bVar14 * -2 + 1;
    pcVar5 = pcVar5 + (uint)bVar14 * -2 + 1;
    if (!bVar13) break;
code_r0x08124f13:
    if (iVar6 == 0) break;
  }
  pcVar11 = pcVar9;
  cVar4 = cVar8;
  if (((bVar13) || (iVar6 = strncmp(pcVar9,"-0x",3), iVar6 == 0)) ||
     (iVar6 = strncmp(pcVar9,"+0x",3), iVar6 == 0)) {
    do {
      pcVar5 = "+-0123456789abcdefx";
      while( true ) {
        if (*pcVar5 == '\0') goto LAB_08124f72;
        if (cVar4 == *pcVar5) break;
        pcVar5 = pcVar5 + 1;
      }
      cVar4 = pcVar11[1];
      pcVar11 = pcVar11 + 1;
    } while (cVar4 != '\0');
    goto LAB_08124e68;
  }
LAB_08124cbc:
  f->type = GTS_STRING;
  return;
}



// WARNING: Unknown calling convention

GtsFileVariable * gts_file_assign_next(GtsFile *f,GtsFileVariable *vars)

{
  GtsTokenType GVar1;
  double *pdVar2;
  float *pfVar3;
  long *plVar4;
  undefined4 *puVar5;
  bool bVar6;
  int iVar7;
  long lVar8;
  undefined4 uVar9;
  GtsFileVariable *var;
  double dVar10;
  char *format;
  GtsTokenType local_24;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_next","f != NULL");
    return (GtsFileVariable *)0x0;
  }
  if (vars == (GtsFileVariable *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_next","vars != NULL");
    return (GtsFileVariable *)0x0;
  }
  while (local_24 = f->type, local_24 == 10) {
    gts_file_next_token(f);
  }
  if (local_24 == 0x7d) {
    f->scope_max = f->scope_max - 1;
    gts_file_next_token(f);
    return (GtsFileVariable *)0x0;
  }
  if (local_24 != GTS_ERROR) {
    bVar6 = false;
LAB_08125048:
    if (local_24 != GTS_ERROR) {
      while( true ) {
        if (bVar6) goto LAB_081250e0;
        if (vars->type == GTS_NONE) goto LAB_08125430;
        iVar7 = strcmp(vars->name,f->token->str);
        if (iVar7 != 0) {
          vars = vars + 1;
          goto LAB_08125048;
        }
        if ((vars->unique != 0) && (vars->set != 0)) {
          gts_file_error(f,"variable `%s\' was already set at line %d:%d",vars->name,vars->line,
                         vars->pos);
          local_24 = f->type;
          bVar6 = true;
          goto LAB_08125048;
        }
        vars->line = f->line;
        vars->pos = f->pos;
        gts_file_next_token(f);
        if (f->type == 0x3d) break;
        gts_file_error(f,"expecting `=\'");
        local_24 = f->type;
        bVar6 = true;
        if (local_24 == GTS_ERROR) goto LAB_081250e0;
      }
      GVar1 = vars->type;
      vars->set = 1;
      if (GVar1 == GTS_FLOAT) {
        gts_file_next_token(f);
        local_24 = f->type;
        if ((local_24 == GTS_FLOAT) || (local_24 == GTS_INT)) {
          pfVar3 = (float *)vars->data;
          if (pfVar3 == (float *)0x0) goto LAB_08125420;
          dVar10 = strtod(f->token->str,(char **)0x0);
          bVar6 = true;
          *pfVar3 = (float)dVar10;
          local_24 = f->type;
          goto LAB_08125048;
        }
LAB_081253af:
        format = "expecting a number";
      }
      else {
        if (GTS_FLOAT < GVar1) {
          if (GVar1 == GTS_STRING) {
            gts_file_next_token(f);
            local_24 = f->type;
            if (((local_24 != GTS_FLOAT) && (local_24 != GTS_INT)) && (local_24 != GTS_STRING)) {
              format = "expecting a string";
              goto LAB_08125255;
            }
            puVar5 = (undefined4 *)vars->data;
            if (puVar5 != (undefined4 *)0x0) {
              uVar9 = g_strdup(f->token->str);
              *puVar5 = uVar9;
              local_24 = f->type;
              bVar6 = true;
              goto LAB_08125048;
            }
          }
          else {
            if (GVar1 == GTS_FILE) goto LAB_081250f8;
            if (GVar1 != GTS_DOUBLE) goto LAB_08125156;
            gts_file_next_token(f);
            local_24 = f->type;
            if ((local_24 != GTS_FLOAT) && (local_24 != GTS_INT)) goto LAB_081253af;
            pdVar2 = (double *)vars->data;
            if (pdVar2 != (double *)0x0) {
              dVar10 = strtod(f->token->str,(char **)0x0);
              local_24 = f->type;
              bVar6 = true;
              *pdVar2 = dVar10;
              goto LAB_08125048;
            }
          }
LAB_08125420:
          bVar6 = true;
          goto LAB_08125048;
        }
        if ((GVar1 != GTS_INT) && (GVar1 != GTS_UINT)) {
LAB_08125156:
                    // WARNING: Subroutine does not return
          g_assertion_message(0,"../../src/gts/misc.c",0x217,"gts_file_assign_next",0);
        }
        gts_file_next_token(f);
        if (f->type == GTS_INT) {
          plVar4 = (long *)vars->data;
          if (plVar4 == (long *)0x0) goto LAB_081250f8;
          lVar8 = strtol(f->token->str,(char **)0x0,10);
          *plVar4 = lVar8;
          local_24 = f->type;
          bVar6 = true;
          goto LAB_08125048;
        }
        format = "expecting an integer";
      }
LAB_08125255:
      gts_file_error(f,format);
      local_24 = f->type;
      vars->set = 0;
      bVar6 = true;
      goto LAB_08125048;
    }
LAB_081250e0:
    if (!bVar6) {
LAB_08125430:
      gts_file_error(f,"unknown identifier `%s\'",f->token->str);
      return (GtsFileVariable *)0x0;
    }
    if (local_24 != GTS_ERROR) {
LAB_081250f8:
      if (vars->set != 0) {
        gts_file_next_token(f);
        return vars;
      }
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/misc.c",0x222,"gts_file_assign_next","var->set");
    }
  }
  return (GtsFileVariable *)0x0;
}



// WARNING: Unknown calling convention

void gts_file_assign_start(GtsFile *f,GtsFileVariable *vars)

{
  GtsFileVariable *var;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_start","f != NULL");
    return;
  }
  if (vars == (GtsFileVariable *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_start","vars != NULL");
    return;
  }
  for (; vars->type != GTS_NONE; vars = vars + 1) {
    vars->set = 0;
  }
  if (f->type != 0x7b) {
    gts_file_error(f,"expecting an opening brace");
    return;
  }
  f->scope_max = f->scope_max + 1;
  gts_file_next_token(f);
  return;
}



// WARNING: Unknown calling convention

void gts_file_assign_variables(GtsFile *f,GtsFileVariable *vars)

{
  GtsFileVariable *pGVar1;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_variables","f != NULL");
    return;
  }
  if (vars != (GtsFileVariable *)0x0) {
    gts_file_assign_start(f,vars);
    do {
      pGVar1 = gts_file_assign_next(f,vars);
    } while (pGVar1 != (GtsFileVariable *)0x0);
    return;
  }
  g_return_if_fail_warning(0,"gts_file_assign_variables","vars != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_file_first_token_after(GtsFile *f,GtsTokenType type)

{
  GtsTokenType GVar1;
  
  if (f != (GtsFile *)0x0) {
    GVar1 = f->type;
    if ((GVar1 != GTS_ERROR) && (GVar1 != GTS_NONE)) {
      do {
        if (GVar1 == type) goto LAB_08125600;
        gts_file_next_token(f);
        GVar1 = f->type;
      } while ((GVar1 != GTS_NONE) && (GVar1 != GTS_ERROR));
    }
    if (type == GVar1) {
      gts_file_next_token(f);
      GVar1 = f->type;
      while (type == GVar1) {
LAB_08125600:
        gts_file_next_token(f);
        GVar1 = f->type;
      }
    }
    return;
  }
  g_return_if_fail_warning(0,"gts_file_first_token_after","f != NULL");
  return;
}



// WARNING: Unknown calling convention

GtsFile * gts_file_new_from_string(gchar *s)

{
  GtsFile *f_00;
  gchar *pgVar1;
  GtsFile *f;
  
  if (s != (gchar *)0x0) {
    f_00 = file_new();
    pgVar1 = (gchar *)g_strdup(s);
    f_00->s = pgVar1;
    f_00->s1 = pgVar1;
    gts_file_next_token(f_00);
    return f_00;
  }
  g_return_if_fail_warning(0,"gts_file_new_from_string","s != NULL");
  return (GtsFile *)0x0;
}



// WARNING: Unknown calling convention

GtsFile * gts_file_new(FILE *fp)

{
  GtsFile *f_00;
  GtsFile *f;
  
  if (fp != (FILE *)0x0) {
    f_00 = file_new();
    f_00->fp = fp;
    gts_file_next_token(f_00);
    return f_00;
  }
  g_return_if_fail_warning(0,"gts_file_new","fp != NULL");
  return (GtsFile *)0x0;
}



// WARNING: Unknown calling convention

void gts_predicates_init(void)

{
  float fVar1;
  float fVar2;
  float fVar3;
  bool bVar4;
  int iVar5;
  int every_other;
  double epsilon;
  double check;
  
  fVar3 = 1.0;
  iVar5 = 0;
  bVar4 = true;
  fVar2 = fVar3;
  fVar1 = fVar3;
  while( true ) {
    fVar1 = fVar1 * 0.5;
    if (bVar4) {
      fVar3 = fVar3 + fVar3;
    }
    if (iVar5 == 0x34) break;
    iVar5 = iVar5 + 1;
    if (fVar2 == fVar1 + 1.0) break;
    bVar4 = (bool)(bVar4 ^ 1);
    fVar2 = fVar1 + 1.0;
  }
  splitter = (double)(fVar3 + 1.0);
  resulterrbound = (double)((fVar1 * 8.0 + 3.0) * fVar1);
  ccwerrboundA = (double)((fVar1 * 16.0 + 3.0) * fVar1);
  ccwerrboundB = (double)((fVar1 * 12.0 + 2.0) * fVar1);
  ccwerrboundC = (double)((fVar1 * 64.0 + 9.0) * fVar1 * fVar1);
  o3derrboundA = (double)((fVar1 * 56.0 + 7.0) * fVar1);
  o3derrboundB = (double)((fVar1 * 28.0 + 3.0) * fVar1);
  o3derrboundC = (double)((fVar1 * 288.0 + 26.0) * fVar1 * fVar1);
  iccerrboundA = (double)((fVar1 * 96.0 + 10.0) * fVar1);
  iccerrboundB = (double)((fVar1 * 48.0 + 4.0) * fVar1);
  iccerrboundC = (double)((fVar1 * 576.0 + 44.0) * fVar1 * fVar1);
  isperrboundA = (double)((fVar1 * 224.0 + 16.0) * fVar1);
  isperrboundB = (double)((fVar1 * 72.0 + 5.0) * fVar1);
  isperrboundC = (double)((fVar1 * 1408.0 + 71.0) * fVar1 * fVar1);
  return;
}



// WARNING: Removing unreachable block (ram,0x08125a61)
// WARNING: Removing unreachable block (ram,0x08125ad0)
// WARNING: Unknown calling convention

int fast_expansion_sum_zeroelim(int elen,double *e,int flen,double *f,double *h)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  int hindex;
  double *pdVar6;
  int eindex;
  int iVar7;
  uint uVar8;
  int findex;
  uint uVar9;
  bool bVar10;
  double Q;
  double fnow;
  double enow;
  double Qnew;
  
  dVar1 = *e;
  dVar2 = *f;
  bVar10 = dVar2 <= -dVar1 == dVar1 < dVar2;
  if (bVar10) {
    dVar3 = f[1];
    dVar4 = dVar2;
  }
  else {
    dVar4 = dVar1;
    dVar3 = dVar2;
    dVar1 = e[1];
  }
  uVar8 = (uint)!bVar10;
  uVar9 = (uint)bVar10;
  if (((int)uVar9 < flen) && ((int)uVar8 < elen)) {
    if (dVar3 <= dVar1 == -dVar1 < dVar3) {
      uVar9 = uVar9 + 1;
      dVar2 = dVar3 + dVar4;
      dVar5 = dVar2 - dVar3;
      dVar3 = f[uVar9];
    }
    else {
      uVar8 = uVar8 + 1;
      dVar2 = dVar1 + dVar4;
      dVar5 = dVar2 - dVar1;
      dVar1 = e[uVar8];
    }
    dVar4 = dVar4 - dVar5;
    if (dVar4 != 0.0) {
      *h = dVar4;
    }
    hindex = (int)(dVar4 != 0.0);
    dVar4 = dVar2;
    while (((int)uVar9 < flen && ((int)uVar8 < elen))) {
      if (dVar3 <= dVar1 == -dVar1 < dVar3) {
        uVar9 = uVar9 + 1;
        dVar2 = dVar4 + dVar3;
        dVar5 = (dVar4 - (dVar2 - (dVar2 - dVar4))) + (dVar3 - (dVar2 - dVar4));
        dVar3 = f[uVar9];
      }
      else {
        uVar8 = uVar8 + 1;
        dVar2 = dVar4 + dVar1;
        dVar5 = (dVar4 - (dVar2 - (dVar2 - dVar4))) + (dVar1 - (dVar2 - dVar4));
        dVar1 = e[uVar8];
      }
      dVar4 = dVar2;
      if (dVar5 != 0.0) {
        h[hindex] = dVar5;
        hindex = hindex + 1;
      }
    }
  }
  else {
    hindex = 0;
  }
  if ((int)uVar8 < elen) {
    iVar7 = uVar8 + 1;
    pdVar6 = e + iVar7;
    dVar2 = dVar4;
    while( true ) {
      dVar4 = dVar2 + dVar1;
      dVar2 = (dVar2 - (dVar4 - (dVar4 - dVar2))) + (dVar1 - (dVar4 - dVar2));
      dVar1 = *pdVar6;
      if (dVar2 != 0.0) {
        h[hindex] = dVar2;
        hindex = hindex + 1;
      }
      pdVar6 = pdVar6 + 1;
      if (elen <= iVar7) break;
      iVar7 = iVar7 + 1;
      dVar2 = dVar4;
    }
  }
  if ((int)uVar9 < flen) {
    iVar7 = uVar9 + 1;
    pdVar6 = f + iVar7;
    dVar2 = dVar4;
    while( true ) {
      dVar4 = dVar2 + dVar3;
      dVar2 = (dVar2 - (dVar4 - (dVar4 - dVar2))) + (dVar3 - (dVar4 - dVar2));
      dVar3 = *pdVar6;
      if (dVar2 != 0.0) {
        h[hindex] = dVar2;
        hindex = hindex + 1;
      }
      pdVar6 = pdVar6 + 1;
      if (flen <= iVar7) break;
      iVar7 = iVar7 + 1;
      dVar2 = dVar4;
    }
  }
  if ((hindex != 0) && (dVar4 == 0.0)) {
    return hindex;
  }
  h[hindex] = dVar4;
  return hindex + 1;
}



// WARNING: Removing unreachable block (ram,0x08125c61)
// WARNING: Unknown calling convention

int scale_expansion_zeroelim(int elen,double *e,double b,double *h)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  int eindex;
  int hindex;
  uint uVar8;
  double sum;
  double Q;
  double hh;
  double product1;
  double bvirt;
  double bhi;
  double blo;
  double enow;
  
  dVar7 = splitter;
  dVar6 = b * splitter - (b * splitter - b);
  dVar4 = b - dVar6;
  dVar1 = *e;
  dVar3 = b * dVar1;
  dVar2 = splitter * dVar1 - (splitter * dVar1 - dVar1);
  dVar1 = (dVar1 - dVar2) * dVar4 -
          (((dVar3 - dVar2 * dVar6) - (dVar1 - dVar2) * dVar6) - dVar2 * dVar4);
  if (dVar1 != 0.0) {
    *h = dVar1;
  }
  uVar8 = (uint)(dVar1 != 0.0);
  if (1 < elen) {
    eindex = 1;
    do {
      dVar1 = e[eindex];
      dVar5 = b * dVar1;
      dVar2 = dVar7 * dVar1 - (dVar7 * dVar1 - dVar1);
      dVar2 = (dVar1 - dVar2) * dVar4 -
              (((dVar5 - dVar2 * dVar6) - (dVar1 - dVar2) * dVar6) - dVar2 * dVar4);
      dVar1 = dVar3 + dVar2;
      dVar2 = (dVar3 - (dVar1 - (dVar1 - dVar3))) + (dVar2 - (dVar1 - dVar3));
      if (dVar2 != 0.0) {
        h[uVar8] = dVar2;
        uVar8 = uVar8 + 1;
      }
      dVar3 = dVar5 + dVar1;
      dVar1 = dVar1 - (dVar3 - dVar5);
      if (dVar1 != 0.0) {
        h[uVar8] = dVar1;
        uVar8 = uVar8 + 1;
      }
      eindex = eindex + 1;
    } while (eindex != elen);
  }
  if ((uVar8 != 0) && (dVar3 == 0.0)) {
    return uVar8;
  }
  h[uVar8] = dVar3;
  return uVar8 + 1;
}



// WARNING: Removing unreachable block (ram,0x08125fcc)
// WARNING: Removing unreachable block (ram,0x08125fc4)
// WARNING: Removing unreachable block (ram,0x08125fb2)
// WARNING: Unknown calling convention
// Local variable C1length:int[EAX:4] conflicts with parameter, skipped.
// Local variable C2length:int[EAX:4] conflicts with parameter, skipped.

double orient2dadapt(double *pa,double *pb,double *pc,double detsum)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  double dVar25;
  int Dlength;
  int iVar26;
  double errbound;
  double acy;
  double bcy;
  double acx;
  double detlefttail;
  double acxtail;
  double detrighttail;
  double D [16];
  double C2 [12];
  double C1 [8];
  double u [4];
  double B [4];
  
  dVar12 = splitter;
  dVar1 = *pc;
  dVar2 = *pa;
  dVar9 = dVar2 - dVar1;
  dVar3 = *pb;
  dVar8 = dVar3 - dVar1;
  dVar4 = pc[1];
  dVar5 = pa[1];
  dVar21 = dVar5 - dVar4;
  dVar6 = pb[1];
  dVar23 = dVar6 - dVar4;
  dVar7 = dVar9 * dVar23;
  dVar25 = splitter * dVar9 - (splitter * dVar9 - dVar9);
  dVar10 = dVar9 - dVar25;
  dVar16 = splitter * dVar23 - (splitter * dVar23 - dVar23);
  dVar15 = dVar23 - dVar16;
  dVar14 = dVar10 * dVar15 - (((dVar7 - dVar25 * dVar16) - dVar10 * dVar16) - dVar25 * dVar15);
  dVar22 = dVar8 * dVar21;
  dVar19 = splitter * dVar21 - (splitter * dVar21 - dVar21);
  dVar20 = dVar21 - dVar19;
  dVar17 = dVar8 * splitter - (dVar8 * splitter - dVar8);
  dVar18 = dVar8 - dVar17;
  dVar13 = dVar20 * dVar18 - (((dVar22 - dVar19 * dVar17) - dVar20 * dVar17) - dVar19 * dVar18);
  dVar11 = dVar14 - dVar13;
  B[0] = ((dVar14 - dVar11) - dVar13) + (dVar14 - ((dVar14 - dVar11) + dVar11));
  dVar13 = dVar7 + dVar11;
  dVar11 = (dVar7 - (dVar13 - (dVar13 - dVar7))) + (dVar11 - (dVar13 - dVar7));
  dVar7 = dVar11 - dVar22;
  B[1] = ((dVar11 - dVar7) - dVar22) + (dVar11 - (dVar7 + (dVar11 - dVar7)));
  B[3] = dVar13 + dVar7;
  B[2] = (dVar7 - (B[3] - dVar13)) + (dVar13 - (B[3] - (B[3] - dVar13)));
  dVar7 = B[1] + B[0] + B[2] + B[3];
  if ((dVar7 < detsum * ccwerrboundB) && (-dVar7 < detsum * ccwerrboundB)) {
    dVar2 = ((dVar2 - dVar9) - dVar1) + (dVar2 - (dVar9 + (dVar2 - dVar9)));
    dVar1 = ((dVar3 - dVar8) - dVar1) + (dVar3 - (dVar8 + (dVar3 - dVar8)));
    dVar3 = ((dVar5 - dVar21) - dVar4) + (dVar5 - (dVar21 + (dVar5 - dVar21)));
    dVar4 = ((dVar6 - dVar23) - dVar4) + (dVar6 - (dVar23 + (dVar6 - dVar23)));
    if ((dVar2 != 0.0) || (((dVar3 != 0.0 || (dVar1 != 0.0)) || (dVar4 != 0.0)))) {
      dVar5 = dVar7;
      if (dVar7 < 0.0) {
        dVar5 = -dVar7;
      }
      dVar5 = dVar5 * resulterrbound + detsum * ccwerrboundC;
      dVar9 = dVar9 * dVar4;
      dVar23 = dVar23 * dVar2;
      dVar21 = dVar21 * dVar1;
      dVar8 = dVar8 * dVar3;
      dVar7 = ((dVar9 + dVar23) - (dVar21 + dVar8)) + dVar7;
      if ((dVar7 < dVar5) && (-dVar7 < dVar5)) {
        dVar24 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        dVar22 = dVar2 - dVar24;
        dVar7 = dVar15 * dVar22 - (((dVar23 - dVar16 * dVar24) - dVar16 * dVar22) - dVar15 * dVar24)
        ;
        dVar14 = splitter * dVar3 - (splitter * dVar3 - dVar3);
        dVar13 = dVar3 - dVar14;
        dVar6 = dVar18 * dVar13 - (((dVar8 - dVar17 * dVar14) - dVar17 * dVar13) - dVar18 * dVar14);
        dVar5 = dVar7 - dVar6;
        u[0] = (dVar7 - (dVar5 + (dVar7 - dVar5))) + ((dVar7 - dVar5) - dVar6);
        dVar7 = dVar23 + dVar5;
        dVar6 = (dVar23 - (dVar7 - (dVar7 - dVar23))) + (dVar5 - (dVar7 - dVar23));
        dVar5 = dVar6 - dVar8;
        u[1] = (dVar6 - (dVar5 + (dVar6 - dVar5))) + ((dVar6 - dVar5) - dVar8);
        u[3] = dVar7 + dVar5;
        u[2] = (dVar7 - (u[3] - (u[3] - dVar7))) + (dVar5 - (u[3] - dVar7));
        iVar26 = fast_expansion_sum_zeroelim(4,B,4,u,C1);
        dVar5 = dVar12 * dVar4;
        dVar5 = dVar5 - (dVar5 - dVar4);
        dVar6 = dVar4 - dVar5;
        dVar7 = dVar10 * dVar6 - (((dVar9 - dVar25 * dVar5) - dVar10 * dVar5) - dVar25 * dVar6);
        dVar12 = dVar12 * dVar1;
        dVar12 = dVar12 - (dVar12 - dVar1);
        dVar11 = dVar1 - dVar12;
        dVar10 = dVar20 * dVar11 -
                 (((dVar21 - dVar19 * dVar12) - dVar20 * dVar12) - dVar19 * dVar11);
        dVar8 = dVar7 - dVar10;
        u[0] = (dVar7 - (dVar8 + (dVar7 - dVar8))) + ((dVar7 - dVar8) - dVar10);
        dVar7 = dVar9 + dVar8;
        dVar9 = (dVar9 - (dVar7 - (dVar7 - dVar9))) + (dVar8 - (dVar7 - dVar9));
        dVar8 = dVar9 - dVar21;
        u[1] = ((dVar9 - dVar8) - dVar21) + (dVar9 - (dVar8 + (dVar9 - dVar8)));
        u[3] = dVar7 + dVar8;
        u[2] = (dVar7 - (u[3] - (u[3] - dVar7))) + (dVar8 - (u[3] - dVar7));
        iVar26 = fast_expansion_sum_zeroelim(iVar26,C1,4,u,C2);
        dVar2 = dVar2 * dVar4;
        dVar4 = dVar22 * dVar6 - (((dVar2 - dVar24 * dVar5) - dVar5 * dVar22) - dVar24 * dVar6);
        dVar3 = dVar3 * dVar1;
        dVar1 = dVar13 * dVar11 - (((dVar3 - dVar14 * dVar12) - dVar12 * dVar13) - dVar14 * dVar11);
        dVar5 = dVar4 - dVar1;
        u[0] = (dVar4 - (dVar5 + (dVar4 - dVar5))) + ((dVar4 - dVar5) - dVar1);
        dVar4 = dVar2 + dVar5;
        dVar1 = (dVar2 - (dVar4 - (dVar4 - dVar2))) + (dVar5 - (dVar4 - dVar2));
        dVar2 = dVar1 - dVar3;
        u[1] = (dVar1 - (dVar2 + (dVar1 - dVar2))) + ((dVar1 - dVar2) - dVar3);
        u[3] = dVar4 + dVar2;
        u[2] = (dVar4 - (u[3] - (u[3] - dVar4))) + (dVar2 - (u[3] - dVar4));
        iVar26 = fast_expansion_sum_zeroelim(iVar26,C2,4,u,D);
        dVar7 = D[iVar26 + -1];
      }
    }
  }
  return dVar7;
}



// WARNING: Unknown calling convention

double orient2d(double *pa,double *pb,double *pc)

{
  double dVar1;
  double dVar2;
  double det;
  double detleft;
  double detright;
  double dVar3;
  
  dVar2 = (pb[1] - pc[1]) * (*pa - *pc);
  dVar3 = (*pb - *pc) * (pa[1] - pc[1]);
  dVar1 = dVar2 - dVar3;
  if (dVar2 <= 0.0) {
    if (0.0 <= dVar2) {
      return dVar1;
    }
    if (0.0 <= dVar3) {
      return dVar1;
    }
    dVar3 = -dVar2 - dVar3;
  }
  else {
    if (dVar3 <= 0.0) {
      return dVar1;
    }
    dVar3 = dVar2 + dVar3;
  }
  if ((dVar1 < ccwerrboundA * dVar3) && (-dVar1 < ccwerrboundA * dVar3)) {
    dVar3 = orient2dadapt(pa,pb,pc,dVar3);
    return dVar3;
  }
  return dVar1;
}



// WARNING: Removing unreachable block (ram,0x08127a8d)
// WARNING: Removing unreachable block (ram,0x08127647)
// WARNING: Removing unreachable block (ram,0x08127ae7)
// WARNING: Removing unreachable block (ram,0x08126c12)
// WARNING: Removing unreachable block (ram,0x08126c6a)
// WARNING: Removing unreachable block (ram,0x08126c56)
// WARNING: Removing unreachable block (ram,0x08126c3c)
// WARNING: Removing unreachable block (ram,0x08126c24)
// WARNING: Removing unreachable block (ram,0x08126c2c)
// WARNING: Removing unreachable block (ram,0x08126c4c)
// WARNING: Removing unreachable block (ram,0x08126c62)
// WARNING: Removing unreachable block (ram,0x08127bcd)
// WARNING: Removing unreachable block (ram,0x08127741)
// WARNING: Removing unreachable block (ram,0x08128885)
// WARNING: Unknown calling convention
// Local variable ablen:int[EAX:4] conflicts with parameter, skipped.

double orient3dadapt(double *pa,double *pb,double *pc,double *pd,double permanent)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double b;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  double dVar25;
  double dVar26;
  double dVar27;
  double dVar28;
  double dVar29;
  double dVar30;
  double dVar31;
  double dVar32;
  double dVar33;
  double dVar34;
  double dVar35;
  double dVar36;
  int iVar37;
  int iVar38;
  int iVar39;
  int finlength;
  int eindex;
  int bt_clen;
  int wlength;
  int iVar40;
  int iVar41;
  int vlength;
  int ct_blen;
  double *finnow;
  double *pdVar42;
  double *pdVar43;
  double *pdVar44;
  double det;
  double cdy;
  double errbound;
  double cdxbdy0;
  double bdxt_cdy0;
  double adyt_cdx0;
  double ct_blarge;
  double adxtail;
  int local_108c;
  int local_107c;
  int local_1064;
  double *local_103c;
  double fin2 [192];
  double fin1 [192];
  double w [16];
  double abdet [16];
  double v [12];
  double abt [8];
  double cat [8];
  double bct [8];
  double cdet [8];
  double bdet [8];
  double adet [8];
  double u [4];
  double ct_b [4];
  double ct_a [4];
  double bt_a [4];
  double bt_c [4];
  double at_c [4];
  double at_b [4];
  double ab [4];
  double ca [4];
  double bc [4];
  
  dVar1 = *pd;
  dVar5 = *pa - dVar1;
  dVar6 = *pb - dVar1;
  dVar1 = *pc - dVar1;
  dVar2 = pd[1];
  dVar23 = pa[1] - dVar2;
  dVar24 = pb[1] - dVar2;
  dVar2 = pc[1] - dVar2;
  dVar3 = pd[2];
  dVar7 = pa[2] - dVar3;
  dVar8 = pb[2] - dVar3;
  dVar3 = pc[2] - dVar3;
  dVar25 = dVar6 * dVar2;
  dVar10 = dVar6 * splitter - (dVar6 * splitter - dVar6);
  dVar9 = dVar2 * splitter - (dVar2 * splitter - dVar2);
  dVar10 = (dVar6 - dVar10) * (dVar2 - dVar9) -
           (((dVar25 - dVar10 * dVar9) - dVar9 * (dVar6 - dVar10)) - (dVar2 - dVar9) * dVar10);
  dVar9 = dVar1 * dVar24;
  dVar11 = dVar1 * splitter - (dVar1 * splitter - dVar1);
  dVar12 = splitter * dVar24 - (splitter * dVar24 - dVar24);
  dVar12 = (dVar1 - dVar11) * (dVar24 - dVar12) -
           (((dVar9 - dVar11 * dVar12) - dVar12 * (dVar1 - dVar11)) - (dVar24 - dVar12) * dVar11);
  dVar11 = dVar10 - dVar12;
  bc[0] = (dVar10 - (dVar11 + (dVar10 - dVar11))) + ((dVar10 - dVar11) - dVar12);
  dVar10 = dVar25 + dVar11;
  dVar11 = (dVar11 - (dVar10 - dVar25)) + (dVar25 - (dVar10 - (dVar10 - dVar25)));
  dVar12 = dVar11 - dVar9;
  bc[1] = ((dVar11 - dVar12) - dVar9) + (dVar11 - (dVar12 + (dVar11 - dVar12)));
  bc[3] = dVar10 + dVar12;
  bc[2] = (dVar10 - (bc[3] - (bc[3] - dVar10))) + (dVar12 - (bc[3] - dVar10));
  iVar37 = scale_expansion_zeroelim(4,bc,dVar7,adet);
  dVar10 = dVar1 * dVar23;
  dVar11 = dVar1 * splitter - (dVar1 * splitter - dVar1);
  dVar12 = dVar23 * splitter - (dVar23 * splitter - dVar23);
  dVar4 = (dVar1 - dVar11) * (dVar23 - dVar12) -
          (((dVar10 - dVar11 * dVar12) - dVar12 * (dVar1 - dVar11)) - (dVar23 - dVar12) * dVar11);
  dVar26 = dVar5 * dVar2;
  dVar12 = dVar5 * splitter - (dVar5 * splitter - dVar5);
  dVar11 = splitter * dVar2 - (splitter * dVar2 - dVar2);
  dVar11 = (dVar5 - dVar12) * (dVar2 - dVar11) -
           (((dVar26 - dVar12 * dVar11) - dVar11 * (dVar5 - dVar12)) - dVar12 * (dVar2 - dVar11));
  dVar12 = dVar4 - dVar11;
  ca[0] = (dVar4 - (dVar12 + (dVar4 - dVar12))) + ((dVar4 - dVar12) - dVar11);
  dVar11 = dVar10 + dVar12;
  dVar12 = (dVar12 - (dVar11 - dVar10)) + (dVar10 - (dVar11 - (dVar11 - dVar10)));
  dVar4 = dVar12 - dVar26;
  ca[1] = ((dVar12 - dVar4) - dVar26) + (dVar12 - (dVar4 + (dVar12 - dVar4)));
  ca[3] = dVar11 + dVar4;
  ca[2] = (dVar11 - (ca[3] - (ca[3] - dVar11))) + (dVar4 - (ca[3] - dVar11));
  iVar38 = scale_expansion_zeroelim(4,ca,dVar8,bdet);
  dVar11 = dVar5 * dVar24;
  dVar12 = dVar5 * splitter - (dVar5 * splitter - dVar5);
  dVar4 = dVar24 * splitter - (dVar24 * splitter - dVar24);
  dVar14 = (dVar5 - dVar12) * (dVar24 - dVar4) -
           (((dVar11 - dVar12 * dVar4) - dVar4 * (dVar5 - dVar12)) - (dVar24 - dVar4) * dVar12);
  dVar12 = dVar6 * dVar23;
  dVar13 = dVar6 * splitter - (dVar6 * splitter - dVar6);
  dVar4 = splitter * dVar23 - (splitter * dVar23 - dVar23);
  dVar4 = (dVar6 - dVar13) * (dVar23 - dVar4) -
          (((dVar12 - dVar13 * dVar4) - dVar4 * (dVar6 - dVar13)) - (dVar23 - dVar4) * dVar13);
  dVar13 = dVar14 - dVar4;
  ab[0] = (dVar14 - (dVar13 + (dVar14 - dVar13))) + ((dVar14 - dVar13) - dVar4);
  dVar4 = dVar11 + dVar13;
  dVar13 = (dVar13 - (dVar4 - dVar11)) + (dVar11 - (dVar4 - (dVar4 - dVar11)));
  dVar14 = dVar13 - dVar12;
  ab[1] = ((dVar13 - dVar14) - dVar12) + (dVar13 - (dVar14 + (dVar13 - dVar14)));
  ab[3] = dVar4 + dVar14;
  ab[2] = (dVar4 - (ab[3] - (ab[3] - dVar4))) + (dVar14 - (ab[3] - dVar4));
  iVar39 = scale_expansion_zeroelim(4,ab,dVar3,cdet);
  iVar37 = fast_expansion_sum_zeroelim(iVar37,adet,iVar38,bdet,abdet);
  iVar37 = fast_expansion_sum_zeroelim(iVar37,abdet,iVar39,cdet,fin1);
  if (1 < iVar37) {
    eindex = 1;
    do {
      fin1[0] = fin1[0] + fin1[eindex];
      eindex = eindex + 1;
    } while (eindex != iVar37);
  }
  if (permanent * o3derrboundB <= fin1[0]) {
    return fin1[0];
  }
  if (permanent * o3derrboundB <= -fin1[0]) {
    return fin1[0];
  }
  dVar13 = *pa - dVar5;
  dVar4 = *pd;
  dVar28 = (*pa - (dVar5 + dVar13)) + (dVar13 - dVar4);
  dVar13 = *pb - dVar6;
  dVar36 = (dVar13 - dVar4) + (*pb - (dVar6 + dVar13));
  dVar13 = *pc - dVar1;
  dVar35 = (*pc - (dVar1 + dVar13)) + (dVar13 - dVar4);
  dVar13 = pa[1] - dVar23;
  dVar4 = pd[1];
  dVar34 = (dVar13 - dVar4) + (pa[1] - (dVar23 + dVar13));
  dVar13 = pb[1] - dVar24;
  dVar33 = (dVar13 - dVar4) + (pb[1] - (dVar24 + dVar13));
  dVar13 = pc[1] - dVar2;
  dVar32 = (pc[1] - (dVar2 + dVar13)) + (dVar13 - dVar4);
  dVar13 = pa[2] - dVar7;
  dVar4 = pd[2];
  dVar13 = (dVar13 - dVar4) + (pa[2] - (dVar7 + dVar13));
  dVar14 = pb[2] - dVar8;
  b = (dVar14 - dVar4) + (pb[2] - (dVar8 + dVar14));
  dVar14 = pc[2] - dVar3;
  dVar4 = (pc[2] - (dVar3 + dVar14)) + (dVar14 - dVar4);
  if ((((((dVar28 == 0.0) && (dVar36 == 0.0)) && (dVar35 == 0.0)) &&
       ((dVar34 == 0.0 && (dVar33 == 0.0)))) && ((dVar32 == 0.0 && ((dVar13 == 0.0 && (b == 0.0)))))
      ) && (dVar4 == 0.0)) {
    return fin1[0];
  }
  dVar14 = -fin1[0];
  if (0.0 <= fin1[0]) {
    dVar14 = fin1[0];
  }
  dVar27 = dVar14 * resulterrbound + permanent * o3derrboundC;
  dVar14 = dVar6 * dVar32;
  dVar31 = dVar36 * dVar2;
  dVar15 = dVar24 * dVar35;
  dVar16 = dVar1 * dVar33;
  dVar17 = dVar1 * dVar34;
  dVar18 = dVar23 * dVar35;
  dVar30 = dVar2 * dVar28;
  dVar19 = dVar5 * dVar32;
  dVar20 = dVar5 * dVar33;
  dVar29 = dVar24 * dVar28;
  dVar21 = dVar23 * dVar36;
  dVar22 = dVar6 * dVar34;
  dVar9 = (dVar11 - dVar12) * dVar4 + ((dVar20 + dVar29) - (dVar21 + dVar22)) * dVar3 +
          (dVar10 - dVar26) * b + ((dVar17 + dVar18) - (dVar30 + dVar19)) * dVar8 +
          (dVar25 - dVar9) * dVar13 + ((dVar14 + dVar31) - (dVar15 + dVar16)) * dVar7 + fin1[0];
  if (dVar27 <= dVar9) {
    return dVar9;
  }
  if (dVar27 <= -dVar9) {
    return dVar9;
  }
  if (dVar28 == 0.0) {
    if (dVar34 == 0.0) {
      at_b[0] = 0.0;
      local_107c = 1;
      at_c[0] = 0.0;
      local_108c = 1;
    }
    else {
      dVar9 = -dVar34;
      local_107c = 2;
      local_108c = 2;
      dVar10 = splitter * dVar9 - (splitter * dVar9 - dVar9);
      dVar11 = dVar6 * splitter - (dVar6 * splitter - dVar6);
      at_b[0] = (dVar9 - dVar10) * (dVar6 - dVar11) -
                (((dVar6 * dVar9 - dVar10 * dVar11) - dVar11 * (dVar9 - dVar10)) -
                (dVar6 - dVar11) * dVar10);
      dVar11 = dVar34 * splitter - (dVar34 * splitter - dVar34);
      dVar10 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      at_c[0] = (dVar34 - dVar11) * (dVar1 - dVar10) -
                (((dVar17 - dVar11 * dVar10) - dVar10 * (dVar34 - dVar11)) -
                (dVar1 - dVar10) * dVar11);
      at_c[1] = dVar17;
      at_b[1] = dVar6 * dVar9;
    }
  }
  else if (dVar34 == 0.0) {
    local_108c = 2;
    dVar10 = splitter * dVar28 - (splitter * dVar28 - dVar28);
    dVar9 = dVar24 * splitter - (dVar24 * splitter - dVar24);
    local_107c = 2;
    at_b[0] = (dVar28 - dVar10) * (dVar24 - dVar9) -
              (((dVar29 - dVar10 * dVar9) - (dVar28 - dVar10) * dVar9) - (dVar24 - dVar9) * dVar10);
    dVar9 = -dVar28;
    at_c[1] = dVar9 * dVar2;
    dVar10 = splitter * dVar9 - (splitter * dVar9 - dVar9);
    dVar11 = dVar2 * splitter - (dVar2 * splitter - dVar2);
    at_c[0] = (dVar9 - dVar10) * (dVar2 - dVar11) -
              (((at_c[1] - dVar10 * dVar11) - dVar11 * (dVar9 - dVar10)) - (dVar2 - dVar11) * dVar10
              );
    at_b[1] = dVar29;
  }
  else {
    dVar27 = splitter * dVar28 - (splitter * dVar28 - dVar28);
    dVar9 = dVar28 - dVar27;
    dVar10 = dVar24 * splitter - (dVar24 * splitter - dVar24);
    dVar10 = dVar9 * (dVar24 - dVar10) -
             (((dVar29 - dVar27 * dVar10) - dVar9 * dVar10) - dVar27 * (dVar24 - dVar10));
    dVar25 = dVar34 * splitter - (dVar34 * splitter - dVar34);
    dVar26 = dVar34 - dVar25;
    dVar11 = dVar6 * splitter - (dVar6 * splitter - dVar6);
    dVar12 = dVar26 * (dVar6 - dVar11) -
             (((dVar22 - dVar25 * dVar11) - dVar26 * dVar11) - dVar25 * (dVar6 - dVar11));
    dVar11 = dVar10 - dVar12;
    at_b[0] = (dVar10 - (dVar11 + (dVar10 - dVar11))) + ((dVar10 - dVar11) - dVar12);
    dVar10 = dVar29 + dVar11;
    dVar11 = (dVar11 - (dVar10 - dVar29)) + (dVar29 - (dVar10 - (dVar10 - dVar29)));
    dVar12 = dVar11 - dVar22;
    at_b[1] = ((dVar11 - dVar12) - dVar22) + (dVar11 - (dVar12 + (dVar11 - dVar12)));
    at_b[3] = dVar10 + dVar12;
    at_b[2] = (dVar10 - (at_b[3] - (at_b[3] - dVar10))) + (dVar12 - (at_b[3] - dVar10));
    dVar10 = dVar1 * splitter - (dVar1 * splitter - dVar1);
    local_107c = 4;
    dVar11 = dVar26 * (dVar1 - dVar10) -
             (((dVar17 - dVar25 * dVar10) - dVar10 * dVar26) - dVar25 * (dVar1 - dVar10));
    dVar10 = splitter * dVar2 - (splitter * dVar2 - dVar2);
    local_108c = 4;
    dVar9 = dVar9 * (dVar2 - dVar10) -
            (((dVar30 - dVar27 * dVar10) - dVar10 * dVar9) - dVar27 * (dVar2 - dVar10));
    dVar10 = dVar11 - dVar9;
    at_c[0] = (dVar11 - (dVar10 + (dVar11 - dVar10))) + ((dVar11 - dVar10) - dVar9);
    dVar9 = dVar17 + dVar10;
    dVar10 = (dVar17 - (dVar9 - (dVar9 - dVar17))) + (dVar10 - (dVar9 - dVar17));
    dVar11 = dVar10 - dVar30;
    at_c[1] = ((dVar10 - dVar11) - dVar30) + (dVar10 - (dVar11 + (dVar10 - dVar11)));
    at_c[3] = dVar9 + dVar11;
    at_c[2] = (dVar9 - (at_c[3] - (at_c[3] - dVar9))) + (dVar11 - (at_c[3] - dVar9));
  }
  if (dVar36 == 0.0) {
    if (dVar33 == 0.0) {
      bt_c[0] = 0.0;
      iVar38 = 1;
      local_1064 = 1;
      bt_a[0] = 0.0;
    }
    else {
      iVar38 = 2;
      dVar2 = -dVar33;
      local_1064 = 2;
      dVar9 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      dVar10 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      bt_c[0] = (dVar2 - dVar9) * (dVar1 - dVar10) -
                (((dVar1 * dVar2 - dVar9 * dVar10) - dVar10 * (dVar2 - dVar9)) -
                (dVar1 - dVar10) * dVar9);
      dVar10 = dVar33 * splitter - (dVar33 * splitter - dVar33);
      dVar9 = dVar5 * splitter - (dVar5 * splitter - dVar5);
      bt_a[0] = (dVar33 - dVar10) * (dVar5 - dVar9) -
                (((dVar20 - dVar10 * dVar9) - dVar9 * (dVar33 - dVar10)) - (dVar5 - dVar9) * dVar10)
      ;
      bt_a[1] = dVar20;
      bt_c[1] = dVar1 * dVar2;
    }
  }
  else if (dVar33 == 0.0) {
    iVar38 = 2;
    local_1064 = 2;
    dVar1 = dVar36 * splitter - (dVar36 * splitter - dVar36);
    dVar9 = dVar2 * splitter - (dVar2 * splitter - dVar2);
    bt_c[0] = (dVar36 - dVar1) * (dVar2 - dVar9) -
              (((dVar31 - dVar1 * dVar9) - dVar9 * (dVar36 - dVar1)) - (dVar2 - dVar9) * dVar1);
    dVar2 = -dVar36;
    bt_a[1] = dVar23 * dVar2;
    dVar9 = splitter * dVar2 - (splitter * dVar2 - dVar2);
    dVar1 = dVar23 * splitter - (dVar23 * splitter - dVar23);
    bt_a[0] = (dVar2 - dVar9) * (dVar23 - dVar1) -
              (((bt_a[1] - dVar9 * dVar1) - dVar1 * (dVar2 - dVar9)) - (dVar23 - dVar1) * dVar9);
    bt_c[1] = dVar31;
  }
  else {
    iVar38 = 4;
    dVar12 = dVar36 * splitter - (dVar36 * splitter - dVar36);
    dVar25 = dVar36 - dVar12;
    dVar9 = dVar2 * splitter - (dVar2 * splitter - dVar2);
    dVar2 = dVar25 * (dVar2 - dVar9) -
            (((dVar31 - dVar12 * dVar9) - dVar9 * dVar25) - (dVar2 - dVar9) * dVar12);
    dVar10 = dVar33 * splitter - (dVar33 * splitter - dVar33);
    dVar11 = dVar33 - dVar10;
    dVar9 = dVar1 * splitter - (dVar1 * splitter - dVar1);
    dVar9 = dVar11 * (dVar1 - dVar9) -
            (((dVar16 - dVar10 * dVar9) - dVar9 * dVar11) - (dVar1 - dVar9) * dVar10);
    dVar1 = dVar2 - dVar9;
    bt_c[0] = (dVar2 - (dVar1 + (dVar2 - dVar1))) + ((dVar2 - dVar1) - dVar9);
    dVar2 = dVar31 + dVar1;
    dVar1 = (dVar1 - (dVar2 - dVar31)) + (dVar31 - (dVar2 - (dVar2 - dVar31)));
    dVar9 = dVar1 - dVar16;
    bt_c[1] = ((dVar1 - dVar9) - dVar16) + (dVar1 - (dVar9 + (dVar1 - dVar9)));
    bt_c[3] = dVar2 + dVar9;
    bt_c[2] = (dVar2 - (bt_c[3] - (bt_c[3] - dVar2))) + (dVar9 - (bt_c[3] - dVar2));
    dVar1 = dVar5 * splitter - (dVar5 * splitter - dVar5);
    dVar1 = dVar11 * (dVar5 - dVar1) -
            (((dVar20 - dVar10 * dVar1) - dVar1 * dVar11) - (dVar5 - dVar1) * dVar10);
    dVar2 = dVar23 * splitter - (dVar23 * splitter - dVar23);
    dVar9 = dVar25 * (dVar23 - dVar2) -
            (((dVar21 - dVar12 * dVar2) - dVar2 * dVar25) - dVar12 * (dVar23 - dVar2));
    dVar2 = dVar1 - dVar9;
    bt_a[0] = (dVar1 - (dVar2 + (dVar1 - dVar2))) + ((dVar1 - dVar2) - dVar9);
    dVar1 = dVar20 + dVar2;
    local_1064 = 4;
    dVar2 = (dVar2 - (dVar1 - dVar20)) + (dVar20 - (dVar1 - (dVar1 - dVar20)));
    dVar9 = dVar2 - dVar21;
    bt_a[1] = ((dVar2 - dVar9) - dVar21) + (dVar2 - (dVar9 + (dVar2 - dVar9)));
    bt_a[3] = dVar1 + dVar9;
    bt_a[2] = (dVar1 - (bt_a[3] - (bt_a[3] - dVar1))) + (dVar9 - (bt_a[3] - dVar1));
  }
  if (dVar35 == 0.0) {
    if (dVar32 == 0.0) {
      ct_a[0] = 0.0;
      iVar39 = 1;
      local_103c = (double *)0x1;
      ct_b[0] = 0.0;
    }
    else {
      iVar39 = 2;
      dVar1 = -dVar32;
      local_103c = (double *)0x2;
      dVar2 = splitter * dVar1 - (splitter * dVar1 - dVar1);
      dVar9 = dVar5 * splitter - (dVar5 * splitter - dVar5);
      ct_a[0] = (dVar1 - dVar2) * (dVar5 - dVar9) -
                (((dVar5 * dVar1 - dVar2 * dVar9) - dVar9 * (dVar1 - dVar2)) -
                (dVar5 - dVar9) * dVar2);
      dVar9 = dVar32 * splitter - (dVar32 * splitter - dVar32);
      dVar2 = splitter * dVar6 - (splitter * dVar6 - dVar6);
      ct_b[0] = (dVar32 - dVar9) * (dVar6 - dVar2) -
                (((dVar14 - dVar9 * dVar2) - dVar2 * (dVar32 - dVar9)) - (dVar6 - dVar2) * dVar9);
      ct_b[1] = dVar14;
      ct_a[1] = dVar5 * dVar1;
    }
  }
  else if (dVar32 == 0.0) {
    iVar39 = 2;
    dVar2 = dVar35 * splitter - (dVar35 * splitter - dVar35);
    dVar1 = dVar23 * splitter - (dVar23 * splitter - dVar23);
    ct_a[0] = (dVar35 - dVar2) * (dVar23 - dVar1) -
              (((dVar18 - dVar2 * dVar1) - dVar1 * (dVar35 - dVar2)) - (dVar23 - dVar1) * dVar2);
    dVar2 = -dVar35;
    ct_b[1] = dVar24 * dVar2;
    dVar5 = splitter * dVar2 - (splitter * dVar2 - dVar2);
    dVar1 = splitter * dVar24 - (splitter * dVar24 - dVar24);
    local_103c = (double *)0x2;
    ct_b[0] = (dVar2 - dVar5) * (dVar24 - dVar1) -
              (((ct_b[1] - dVar5 * dVar1) - dVar1 * (dVar2 - dVar5)) - (dVar24 - dVar1) * dVar5);
    ct_a[1] = dVar18;
  }
  else {
    iVar39 = 4;
    dVar12 = dVar35 * splitter - (dVar35 * splitter - dVar35);
    dVar11 = dVar35 - dVar12;
    dVar1 = dVar23 * splitter - (dVar23 * splitter - dVar23);
    dVar10 = dVar11 * (dVar23 - dVar1) -
             (((dVar18 - dVar12 * dVar1) - dVar1 * dVar11) - (dVar23 - dVar1) * dVar12);
    dVar1 = dVar32 * splitter - (dVar32 * splitter - dVar32);
    dVar2 = dVar32 - dVar1;
    dVar9 = dVar5 * splitter - (dVar5 * splitter - dVar5);
    dVar5 = dVar2 * (dVar5 - dVar9) -
            (((dVar19 - dVar1 * dVar9) - dVar9 * dVar2) - (dVar5 - dVar9) * dVar1);
    dVar9 = dVar10 - dVar5;
    ct_a[0] = (dVar10 - (dVar9 + (dVar10 - dVar9))) + ((dVar10 - dVar9) - dVar5);
    dVar5 = dVar18 + dVar9;
    dVar9 = (dVar9 - (dVar5 - dVar18)) + (dVar18 - (dVar5 - (dVar5 - dVar18)));
    dVar10 = dVar9 - dVar19;
    ct_a[1] = ((dVar9 - dVar10) - dVar19) + (dVar9 - (dVar10 + (dVar9 - dVar10)));
    ct_a[3] = dVar5 + dVar10;
    ct_a[2] = (dVar5 - (ct_a[3] - (ct_a[3] - dVar5))) + (dVar10 - (ct_a[3] - dVar5));
    dVar5 = dVar6 * splitter - (dVar6 * splitter - dVar6);
    dVar5 = dVar2 * (dVar6 - dVar5) -
            (((dVar14 - dVar1 * dVar5) - dVar5 * dVar2) - (dVar6 - dVar5) * dVar1);
    dVar1 = dVar24 * splitter - (dVar24 * splitter - dVar24);
    dVar1 = dVar11 * (dVar24 - dVar1) -
            (((dVar15 - dVar12 * dVar1) - dVar1 * dVar11) - (dVar24 - dVar1) * dVar12);
    dVar2 = dVar5 - dVar1;
    ct_b[0] = (dVar5 - (dVar2 + (dVar5 - dVar2))) + ((dVar5 - dVar2) - dVar1);
    dVar1 = dVar14 + dVar2;
    local_103c = (double *)0x4;
    dVar2 = (dVar2 - (dVar1 - dVar14)) + (dVar14 - (dVar1 - (dVar1 - dVar14)));
    dVar5 = dVar2 - dVar15;
    ct_b[1] = ((dVar2 - dVar5) - dVar15) + (dVar2 - (dVar5 + (dVar2 - dVar5)));
    ct_b[3] = dVar1 + dVar5;
    ct_b[2] = (dVar1 - (ct_b[3] - (ct_b[3] - dVar1))) + (dVar5 - (ct_b[3] - dVar1));
  }
  iVar38 = fast_expansion_sum_zeroelim(iVar38,bt_c,iVar39,ct_b,bct);
  iVar39 = scale_expansion_zeroelim(iVar38,bct,dVar7,w);
  iVar37 = fast_expansion_sum_zeroelim(iVar37,fin1,iVar39,w,fin2);
  iVar39 = fast_expansion_sum_zeroelim((int)local_103c,ct_a,local_107c,at_c,cat);
  iVar40 = scale_expansion_zeroelim(iVar39,cat,dVar8,w);
  iVar37 = fast_expansion_sum_zeroelim(iVar37,fin2,iVar40,w,fin1);
  iVar40 = fast_expansion_sum_zeroelim(local_108c,at_b,local_1064,bt_a,abt);
  iVar41 = scale_expansion_zeroelim(iVar40,abt,dVar3,w);
  pdVar43 = fin2;
  iVar37 = fast_expansion_sum_zeroelim(iVar37,fin1,iVar41,w,fin2);
  local_103c = fin1;
  if (dVar13 != 0.0) {
    iVar41 = scale_expansion_zeroelim(4,bc,dVar13,v);
    iVar37 = fast_expansion_sum_zeroelim(iVar37,fin2,iVar41,v,fin1);
    pdVar43 = fin1;
    local_103c = fin2;
  }
  pdVar44 = pdVar43;
  if (b != 0.0) {
    iVar41 = scale_expansion_zeroelim(4,ca,b,v);
    iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar43,iVar41,v,local_103c);
    pdVar44 = local_103c;
    local_103c = pdVar43;
  }
  pdVar43 = pdVar44;
  if (dVar4 != 0.0) {
    iVar41 = scale_expansion_zeroelim(4,ab,dVar4,v);
    iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar44,iVar41,v,local_103c);
    pdVar43 = local_103c;
    local_103c = pdVar44;
  }
  pdVar44 = local_103c;
  if (dVar28 != 0.0) {
    pdVar42 = pdVar43;
    if (dVar33 != 0.0) {
      dVar1 = dVar33 * dVar28;
      dVar2 = splitter * dVar28 - (splitter * dVar28 - dVar28);
      dVar5 = dVar33 * splitter - (dVar33 * splitter - dVar33);
      dVar2 = (dVar28 - dVar2) * (dVar33 - dVar5) -
              (((dVar1 - dVar2 * dVar5) - dVar5 * (dVar28 - dVar2)) - (dVar33 - dVar5) * dVar2);
      dVar9 = dVar3 * splitter - (dVar3 * splitter - dVar3);
      dVar11 = dVar3 - dVar9;
      dVar5 = dVar3 * dVar2;
      dVar6 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      u[0] = (dVar2 - dVar6) * dVar11 -
             (((dVar5 - dVar6 * dVar9) - (dVar2 - dVar6) * dVar9) - dVar6 * dVar11);
      dVar10 = dVar1 * dVar3;
      dVar6 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      dVar6 = (dVar1 - dVar6) * dVar11 -
              (((dVar10 - dVar6 * dVar9) - dVar9 * (dVar1 - dVar6)) - dVar6 * dVar11);
      dVar9 = dVar5 + dVar6;
      u[1] = (dVar5 - (dVar9 - (dVar9 - dVar5))) + (dVar6 - (dVar9 - dVar5));
      u[3] = dVar10 + dVar9;
      u[2] = dVar9 - (u[3] - dVar10);
      iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar43,4,u,local_103c);
      pdVar42 = local_103c;
      pdVar44 = pdVar43;
      if (dVar4 != 0.0) {
        dVar9 = splitter * dVar4 - (splitter * dVar4 - dVar4);
        dVar10 = dVar4 - dVar9;
        dVar5 = dVar4 * dVar2;
        dVar6 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        u[0] = (dVar2 - dVar6) * dVar10 -
               (((dVar5 - dVar6 * dVar9) - (dVar2 - dVar6) * dVar9) - dVar6 * dVar10);
        dVar6 = dVar1 * dVar4;
        dVar2 = dVar1 * splitter - (dVar1 * splitter - dVar1);
        dVar1 = (dVar1 - dVar2) * dVar10 -
                (((dVar6 - dVar2 * dVar9) - dVar9 * (dVar1 - dVar2)) - dVar2 * dVar10);
        dVar2 = dVar5 + dVar1;
        u[1] = (dVar5 - (dVar2 - (dVar2 - dVar5))) + (dVar1 - (dVar2 - dVar5));
        u[3] = dVar6 + dVar2;
        u[2] = dVar2 - (u[3] - dVar6);
        iVar37 = fast_expansion_sum_zeroelim(iVar37,local_103c,4,u,pdVar43);
        pdVar42 = pdVar43;
        pdVar44 = local_103c;
      }
    }
    local_103c = pdVar44;
    pdVar43 = pdVar42;
    pdVar44 = local_103c;
    if (dVar32 != 0.0) {
      dVar28 = -dVar28;
      dVar2 = dVar32 * dVar28;
      dVar1 = splitter * dVar28 - (splitter * dVar28 - dVar28);
      dVar5 = dVar32 * splitter - (dVar32 * splitter - dVar32);
      dVar5 = (dVar28 - dVar1) * (dVar32 - dVar5) -
              (((dVar2 - dVar1 * dVar5) - dVar5 * (dVar28 - dVar1)) - (dVar32 - dVar5) * dVar1);
      dVar9 = dVar8 * splitter - (dVar8 * splitter - dVar8);
      dVar11 = dVar8 - dVar9;
      dVar6 = dVar8 * dVar5;
      dVar1 = splitter * dVar5 - (splitter * dVar5 - dVar5);
      u[0] = (dVar5 - dVar1) * dVar11 -
             (((dVar6 - dVar1 * dVar9) - (dVar5 - dVar1) * dVar9) - dVar1 * dVar11);
      dVar1 = dVar2 * dVar8;
      dVar10 = dVar2 * splitter - (dVar2 * splitter - dVar2);
      dVar9 = (dVar2 - dVar10) * dVar11 -
              (((dVar1 - dVar10 * dVar9) - dVar9 * (dVar2 - dVar10)) - dVar10 * dVar11);
      dVar10 = dVar6 + dVar9;
      u[1] = (dVar6 - (dVar10 - (dVar10 - dVar6))) + (dVar9 - (dVar10 - dVar6));
      u[3] = dVar1 + dVar10;
      u[2] = dVar10 - (u[3] - dVar1);
      iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar42,4,u,local_103c);
      pdVar43 = local_103c;
      pdVar44 = pdVar42;
      if (b != 0.0) {
        dVar9 = splitter * b - (splitter * b - b);
        dVar10 = b - dVar9;
        dVar1 = b * dVar5;
        dVar6 = splitter * dVar5 - (splitter * dVar5 - dVar5);
        u[0] = (dVar5 - dVar6) * dVar10 -
               (((dVar1 - dVar6 * dVar9) - (dVar5 - dVar6) * dVar9) - dVar6 * dVar10);
        dVar6 = dVar2 * b;
        dVar5 = dVar2 * splitter - (dVar2 * splitter - dVar2);
        dVar2 = (dVar2 - dVar5) * dVar10 -
                (((dVar6 - dVar5 * dVar9) - dVar9 * (dVar2 - dVar5)) - dVar5 * dVar10);
        dVar5 = dVar1 + dVar2;
        u[1] = (dVar1 - (dVar5 - (dVar5 - dVar1))) + (dVar2 - (dVar5 - dVar1));
        u[3] = dVar6 + dVar5;
        u[2] = dVar5 - (u[3] - dVar6);
        iVar37 = fast_expansion_sum_zeroelim(iVar37,local_103c,4,u,pdVar42);
        pdVar43 = pdVar42;
        pdVar44 = local_103c;
      }
    }
  }
  local_103c = pdVar44;
  pdVar44 = local_103c;
  if (dVar36 != 0.0) {
    pdVar42 = pdVar43;
    if (dVar32 != 0.0) {
      dVar1 = dVar36 * dVar32;
      dVar2 = splitter * dVar36 - (splitter * dVar36 - dVar36);
      dVar5 = splitter * dVar32 - (splitter * dVar32 - dVar32);
      dVar2 = (dVar36 - dVar2) * (dVar32 - dVar5) -
              (((dVar1 - dVar2 * dVar5) - dVar5 * (dVar36 - dVar2)) - dVar2 * (dVar32 - dVar5));
      dVar9 = dVar7 * splitter - (dVar7 * splitter - dVar7);
      dVar10 = dVar7 - dVar9;
      dVar5 = dVar7 * dVar2;
      dVar6 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      u[0] = (dVar2 - dVar6) * dVar10 -
             (((dVar5 - dVar6 * dVar9) - (dVar2 - dVar6) * dVar9) - dVar6 * dVar10);
      dVar11 = dVar7 * dVar1;
      dVar6 = splitter * dVar1 - (splitter * dVar1 - dVar1);
      dVar6 = (dVar1 - dVar6) * dVar10 -
              (((dVar11 - dVar6 * dVar9) - dVar9 * (dVar1 - dVar6)) - dVar6 * dVar10);
      dVar9 = dVar5 + dVar6;
      u[1] = (dVar5 - (dVar9 - (dVar9 - dVar5))) + (dVar6 - (dVar9 - dVar5));
      u[3] = dVar11 + dVar9;
      u[2] = dVar9 - (u[3] - dVar11);
      iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar43,4,u,local_103c);
      pdVar42 = local_103c;
      pdVar44 = pdVar43;
      if (dVar13 != 0.0) {
        dVar9 = splitter * dVar13 - (splitter * dVar13 - dVar13);
        dVar10 = dVar13 - dVar9;
        dVar5 = dVar13 * dVar2;
        dVar6 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        u[0] = (dVar2 - dVar6) * dVar10 -
               (((dVar5 - dVar6 * dVar9) - (dVar2 - dVar6) * dVar9) - dVar6 * dVar10);
        dVar6 = dVar13 * dVar1;
        dVar2 = splitter * dVar1 - (splitter * dVar1 - dVar1);
        dVar1 = (dVar1 - dVar2) * dVar10 -
                (((dVar6 - dVar2 * dVar9) - dVar9 * (dVar1 - dVar2)) - dVar2 * dVar10);
        dVar2 = dVar5 + dVar1;
        u[1] = (dVar5 - (dVar2 - (dVar2 - dVar5))) + (dVar1 - (dVar2 - dVar5));
        u[3] = dVar6 + dVar2;
        u[2] = dVar2 - (u[3] - dVar6);
        iVar37 = fast_expansion_sum_zeroelim(iVar37,local_103c,4,u,pdVar43);
        pdVar42 = pdVar43;
        pdVar44 = local_103c;
      }
    }
    local_103c = pdVar44;
    pdVar43 = pdVar42;
    pdVar44 = local_103c;
    if (dVar34 != 0.0) {
      dVar36 = -dVar36;
      dVar1 = dVar34 * dVar36;
      dVar2 = splitter * dVar36 - (splitter * dVar36 - dVar36);
      dVar5 = dVar34 * splitter - (dVar34 * splitter - dVar34);
      dVar6 = (dVar36 - dVar2) * (dVar34 - dVar5) -
              (((dVar1 - dVar2 * dVar5) - dVar5 * (dVar36 - dVar2)) - (dVar34 - dVar5) * dVar2);
      dVar5 = dVar3 * splitter - (dVar3 * splitter - dVar3);
      dVar10 = dVar3 - dVar5;
      dVar9 = dVar3 * dVar6;
      dVar2 = splitter * dVar6 - (splitter * dVar6 - dVar6);
      u[0] = (dVar6 - dVar2) * dVar10 -
             (((dVar9 - dVar2 * dVar5) - (dVar6 - dVar2) * dVar5) - dVar2 * dVar10);
      dVar3 = dVar3 * dVar1;
      dVar2 = splitter * dVar1 - (splitter * dVar1 - dVar1);
      dVar2 = (dVar1 - dVar2) * dVar10 -
              (((dVar3 - dVar2 * dVar5) - dVar5 * (dVar1 - dVar2)) - dVar2 * dVar10);
      dVar5 = dVar9 + dVar2;
      u[1] = (dVar2 - (dVar5 - dVar9)) + (dVar9 - (dVar5 - (dVar5 - dVar9)));
      u[3] = dVar3 + dVar5;
      u[2] = dVar5 - (u[3] - dVar3);
      iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar42,4,u,local_103c);
      pdVar43 = local_103c;
      pdVar44 = pdVar42;
      if (dVar4 != 0.0) {
        dVar5 = splitter * dVar4 - (splitter * dVar4 - dVar4);
        dVar9 = dVar4 - dVar5;
        dVar2 = dVar4 * dVar6;
        dVar3 = splitter * dVar6 - (splitter * dVar6 - dVar6);
        u[0] = (dVar6 - dVar3) * dVar9 -
               (((dVar2 - dVar3 * dVar5) - (dVar6 - dVar3) * dVar5) - dVar3 * dVar9);
        dVar6 = dVar4 * dVar1;
        dVar3 = splitter * dVar1 - (splitter * dVar1 - dVar1);
        dVar1 = (dVar1 - dVar3) * dVar9 -
                (((dVar6 - dVar3 * dVar5) - dVar5 * (dVar1 - dVar3)) - dVar3 * dVar9);
        dVar3 = dVar2 + dVar1;
        u[1] = (dVar2 - (dVar3 - (dVar3 - dVar2))) + (dVar1 - (dVar3 - dVar2));
        u[3] = dVar6 + dVar3;
        u[2] = dVar3 - (u[3] - dVar6);
        iVar37 = fast_expansion_sum_zeroelim(iVar37,local_103c,4,u,pdVar42);
        pdVar43 = pdVar42;
        pdVar44 = local_103c;
      }
    }
  }
  local_103c = pdVar44;
  pdVar44 = local_103c;
  if (dVar35 == 0.0) {
LAB_0812724f:
    local_103c = pdVar44;
    pdVar42 = pdVar43;
    if (dVar13 == 0.0) goto LAB_08127267;
  }
  else {
    pdVar42 = pdVar43;
    if (dVar34 != 0.0) {
      dVar1 = dVar34 * dVar35;
      dVar2 = splitter * dVar35 - (splitter * dVar35 - dVar35);
      dVar3 = dVar34 * splitter - (dVar34 * splitter - dVar34);
      dVar2 = (dVar35 - dVar2) * (dVar34 - dVar3) -
              (((dVar1 - dVar2 * dVar3) - dVar3 * (dVar35 - dVar2)) - (dVar34 - dVar3) * dVar2);
      dVar6 = dVar8 * splitter - (dVar8 * splitter - dVar8);
      dVar9 = dVar8 - dVar6;
      dVar3 = dVar8 * dVar2;
      dVar5 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      u[0] = (dVar2 - dVar5) * dVar9 -
             (((dVar3 - dVar5 * dVar6) - (dVar2 - dVar5) * dVar6) - dVar5 * dVar9);
      dVar8 = dVar1 * dVar8;
      dVar5 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      dVar5 = (dVar1 - dVar5) * dVar9 -
              (((dVar8 - dVar5 * dVar6) - dVar6 * (dVar1 - dVar5)) - dVar9 * dVar5);
      dVar6 = dVar3 + dVar5;
      u[1] = (dVar5 - (dVar6 - dVar3)) + (dVar3 - (dVar6 - (dVar6 - dVar3)));
      u[3] = dVar8 + dVar6;
      u[2] = dVar6 - (u[3] - dVar8);
      iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar43,4,u,local_103c);
      pdVar42 = local_103c;
      pdVar44 = pdVar43;
      if (b != 0.0) {
        dVar6 = splitter * b - (splitter * b - b);
        dVar8 = b - dVar6;
        dVar3 = b * dVar2;
        dVar5 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        u[0] = (dVar2 - dVar5) * dVar8 -
               (((dVar3 - dVar5 * dVar6) - (dVar2 - dVar5) * dVar6) - dVar5 * dVar8);
        dVar5 = dVar1 * b;
        dVar2 = dVar1 * splitter - (dVar1 * splitter - dVar1);
        dVar1 = (dVar1 - dVar2) * dVar8 -
                (((dVar5 - dVar2 * dVar6) - dVar6 * (dVar1 - dVar2)) - dVar8 * dVar2);
        dVar2 = dVar3 + dVar1;
        u[1] = (dVar3 - (dVar2 - (dVar2 - dVar3))) + (dVar1 - (dVar2 - dVar3));
        u[3] = dVar5 + dVar2;
        u[2] = dVar2 - (u[3] - dVar5);
        iVar37 = fast_expansion_sum_zeroelim(iVar37,local_103c,4,u,pdVar43);
        pdVar42 = pdVar43;
        pdVar44 = local_103c;
      }
    }
    local_103c = pdVar44;
    pdVar43 = pdVar42;
    pdVar44 = local_103c;
    if (dVar33 == 0.0) goto LAB_0812724f;
    dVar35 = -dVar35;
    dVar1 = dVar33 * dVar35;
    dVar2 = splitter * dVar35 - (splitter * dVar35 - dVar35);
    dVar3 = dVar33 * splitter - (dVar33 * splitter - dVar33);
    dVar2 = (dVar35 - dVar2) * (dVar33 - dVar3) -
            (((dVar1 - dVar2 * dVar3) - dVar3 * (dVar35 - dVar2)) - (dVar33 - dVar3) * dVar2);
    dVar6 = dVar7 * splitter - (dVar7 * splitter - dVar7);
    dVar8 = dVar7 - dVar6;
    dVar3 = dVar7 * dVar2;
    dVar5 = splitter * dVar2 - (splitter * dVar2 - dVar2);
    u[0] = (dVar2 - dVar5) * dVar8 -
           (((dVar3 - dVar5 * dVar6) - (dVar2 - dVar5) * dVar6) - dVar5 * dVar8);
    dVar7 = dVar1 * dVar7;
    dVar5 = dVar1 * splitter - (dVar1 * splitter - dVar1);
    dVar5 = (dVar1 - dVar5) * dVar8 -
            (((dVar7 - dVar5 * dVar6) - dVar6 * (dVar1 - dVar5)) - dVar8 * dVar5);
    dVar6 = dVar3 + dVar5;
    u[1] = (dVar5 - (dVar6 - dVar3)) + (dVar3 - (dVar6 - (dVar6 - dVar3)));
    u[3] = dVar7 + dVar6;
    u[2] = dVar6 - (u[3] - dVar7);
    iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar42,4,u,local_103c);
    pdVar43 = local_103c;
    pdVar44 = pdVar42;
    if (dVar13 == 0.0) goto LAB_0812724f;
    dVar7 = dVar13 * splitter - (dVar13 * splitter - dVar13);
    dVar6 = dVar13 - dVar7;
    dVar5 = dVar13 * dVar2;
    dVar3 = dVar2 * splitter - (dVar2 * splitter - dVar2);
    u[0] = (dVar2 - dVar3) * dVar6 -
           (((dVar5 - dVar3 * dVar7) - (dVar2 - dVar3) * dVar7) - dVar3 * dVar6);
    dVar3 = dVar1 * dVar13;
    dVar2 = dVar1 * splitter - (dVar1 * splitter - dVar1);
    dVar2 = (dVar1 - dVar2) * dVar6 -
            (((dVar3 - dVar2 * dVar7) - dVar7 * (dVar1 - dVar2)) - dVar6 * dVar2);
    dVar1 = dVar5 + dVar2;
    u[1] = (dVar5 - (dVar1 - (dVar1 - dVar5))) + (dVar2 - (dVar1 - dVar5));
    u[3] = dVar3 + dVar1;
    u[2] = dVar1 - (u[3] - dVar3);
    iVar37 = fast_expansion_sum_zeroelim(iVar37,local_103c,4,u,pdVar42);
  }
  iVar38 = scale_expansion_zeroelim(iVar38,bct,dVar13,w);
  iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar42,iVar38,w,local_103c);
  pdVar43 = local_103c;
  local_103c = pdVar42;
LAB_08127267:
  pdVar44 = pdVar43;
  if (b != 0.0) {
    iVar38 = scale_expansion_zeroelim(iVar39,cat,b,w);
    iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar43,iVar38,w,local_103c);
    pdVar44 = local_103c;
    local_103c = pdVar43;
  }
  if (dVar4 != 0.0) {
    iVar38 = scale_expansion_zeroelim(iVar40,abt,dVar4,w);
    iVar37 = fast_expansion_sum_zeroelim(iVar37,pdVar44,iVar38,w,local_103c);
    pdVar44 = local_103c;
  }
  return pdVar44[iVar37 + -1];
}



// WARNING: Unknown calling convention

double orient3d(double *pa,double *pb,double *pc,double *pd)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double ady;
  double bdx;
  double bdy;
  double cdy;
  double cdx;
  double cdxbdy;
  double adx;
  double dVar6;
  double local_2c;
  double local_24;
  double local_1c;
  double local_14;
  
  dVar6 = *pd;
  dVar1 = pd[1];
  local_14 = pd[2];
  local_24 = pa[2] - local_14;
  local_1c = pb[2] - local_14;
  local_14 = pc[2] - local_14;
  local_2c = (*pb - dVar6) * (pc[1] - dVar1);
  dVar2 = (*pc - dVar6) * (pb[1] - dVar1);
  dVar3 = (*pc - dVar6) * (pa[1] - dVar1);
  dVar5 = (pc[1] - dVar1) * (*pa - dVar6);
  dVar4 = (pb[1] - dVar1) * (*pa - dVar6);
  dVar1 = (*pb - dVar6) * (pa[1] - dVar1);
  dVar6 = (dVar4 - dVar1) * local_14 + (local_2c - dVar2) * local_24 + (dVar3 - dVar5) * local_1c;
  if (local_2c < 0.0) {
    local_2c = -local_2c;
  }
  if (dVar2 < 0.0) {
    dVar2 = -dVar2;
  }
  if (local_24 < 0.0) {
    local_24 = -local_24;
  }
  if (dVar3 < 0.0) {
    dVar3 = -dVar3;
  }
  if (dVar5 < 0.0) {
    dVar5 = -dVar5;
  }
  if (local_1c < 0.0) {
    local_1c = -local_1c;
  }
  if (dVar4 < 0.0) {
    dVar4 = -dVar4;
  }
  if (dVar1 < 0.0) {
    dVar1 = -dVar1;
  }
  if (local_14 < 0.0) {
    local_14 = -local_14;
  }
  dVar1 = (dVar1 + dVar4) * local_14 + (dVar5 + dVar3) * local_1c + (dVar2 + local_2c) * local_24;
  dVar2 = o3derrboundA * dVar1;
  if ((dVar6 <= dVar2) && (-dVar6 <= dVar2)) {
    dVar6 = orient3dadapt(pa,pb,pc,pd,dVar1);
    return dVar6;
  }
  return dVar6;
}



// WARNING: Removing unreachable block (ram,0x0812a1fe)
// WARNING: Removing unreachable block (ram,0x0812a172)
// WARNING: Removing unreachable block (ram,0x0812a811)
// WARNING: Removing unreachable block (ram,0x0812a81e)
// WARNING: Removing unreachable block (ram,0x0812ae8e)
// WARNING: Removing unreachable block (ram,0x0812ae09)
// WARNING: Removing unreachable block (ram,0x08129f02)
// WARNING: Removing unreachable block (ram,0x08129f14)
// WARNING: Removing unreachable block (ram,0x08129dd2)
// WARNING: Removing unreachable block (ram,0x08129dec)
// WARNING: Removing unreachable block (ram,0x08129c92)
// WARNING: Removing unreachable block (ram,0x08129cac)
// WARNING: Removing unreachable block (ram,0x081299f2)
// WARNING: Removing unreachable block (ram,0x08129a1c)
// WARNING: Removing unreachable block (ram,0x08129a04)
// WARNING: Removing unreachable block (ram,0x08129a0c)
// WARNING: Removing unreachable block (ram,0x08129a2c)
// WARNING: Removing unreachable block (ram,0x08129ca4)
// WARNING: Removing unreachable block (ram,0x08129de4)
// WARNING: Removing unreachable block (ram,0x08129f06)
// WARNING: Removing unreachable block (ram,0x0812ae7e)
// WARNING: Removing unreachable block (ram,0x0812ae71)
// WARNING: Removing unreachable block (ram,0x0812a7a7)
// WARNING: Removing unreachable block (ram,0x0812a82e)
// WARNING: Removing unreachable block (ram,0x0812a1ee)
// WARNING: Removing unreachable block (ram,0x0812a1df)
// WARNING: Removing unreachable block (ram,0x0812a834)
// WARNING: Removing unreachable block (ram,0x0812ae94)
// WARNING: Removing unreachable block (ram,0x0812a204)
// WARNING: Unknown calling convention
// Local variable axbclen:int[EAX:4] conflicts with parameter, skipped.
// Local variable aybclen:int[EAX:4] conflicts with parameter, skipped.
// Local variable bxcalen:int[EAX:4] conflicts with parameter, skipped.
// Local variable bycalen:int[EAX:4] conflicts with parameter, skipped.
// Local variable cxablen:int[EAX:4] conflicts with parameter, skipped.
// Local variable cyablen:int[EAX:4] conflicts with parameter, skipped.
// Local variable ablen:int[EAX:4] conflicts with parameter, skipped.
// Local variable temp8len:int[EAX:4] conflicts with parameter, skipped.
// Local variable axtbblen:int[EAX:4] conflicts with parameter, skipped.
// Local variable axtcclen:int[EAX:4] conflicts with parameter, skipped.
// Local variable aytbblen:int[EAX:4] conflicts with parameter, skipped.
// Local variable aytcclen:int[EAX:4] conflicts with parameter, skipped.
// Local variable bxtaalen:int[EAX:4] conflicts with parameter, skipped.
// Local variable bxtcclen:int[EAX:4] conflicts with parameter, skipped.
// Local variable bytaalen:int[EAX:4] conflicts with parameter, skipped.
// Local variable bytcclen:int[EAX:4] conflicts with parameter, skipped.
// Local variable cxtaalen:int[EAX:4] conflicts with parameter, skipped.
// Local variable cxtbblen:int[EAX:4] conflicts with parameter, skipped.
// Local variable cytaalen:int[EAX:4] conflicts with parameter, skipped.
// Local variable cytbblen:int[EAX:4] conflicts with parameter, skipped.

double incircleadapt(double *pa,double *pb,double *pc,double *pd,double permanent)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  double dVar25;
  double dVar26;
  double dVar27;
  double dVar28;
  double dVar29;
  double b;
  double dVar30;
  double b_00;
  double dVar31;
  double dVar32;
  int iVar33;
  int iVar34;
  int ayybclen;
  int iVar35;
  int byycalen;
  int iVar36;
  int cyyablen;
  int finlength;
  int eindex;
  int temp32alen;
  int temp48len;
  int temp16blen;
  int temp32blen;
  int temp64len;
  int iVar37;
  int iVar38;
  int iVar39;
  int temp16alen;
  double *finnow;
  double *pdVar40;
  double *pdVar41;
  double *finother;
  double det;
  double adx;
  double bc3;
  double errbound;
  double ahi;
  double bhi;
  double negate;
  double alo;
  int local_648c;
  int local_6474;
  int local_646c;
  int local_645c;
  int local_640c;
  int local_63fc;
  double fin2 [1152];
  double fin1 [1152];
  double temp64 [64];
  double abdet [64];
  double temp48 [48];
  double temp32b [32];
  double temp32a [32];
  double cdet [32];
  double bdet [32];
  double adet [32];
  double cytabt [16];
  double cxtabt [16];
  double bytcat [16];
  double bxtcat [16];
  double aytbct [16];
  double axtbct [16];
  double temp16c [16];
  double temp16b [16];
  double temp16a [16];
  double cyyab [16];
  double cxxab [16];
  double byyca [16];
  double bxxca [16];
  double ayybc [16];
  double axxbc [16];
  double cat [8];
  double bct [8];
  double abt [8];
  double cytabtt [8];
  double cxtabtt [8];
  double bytcatt [8];
  double bxtcatt [8];
  double aytbctt [8];
  double axtbctt [8];
  double cytab [8];
  double cxtab [8];
  double bytca [8];
  double bxtca [8];
  double aytbc [8];
  double axtbc [8];
  double cytbb [8];
  double cytaa [8];
  double cxtbb [8];
  double cxtaa [8];
  double bytcc [8];
  double bytaa [8];
  double bxtcc [8];
  double bxtaa [8];
  double aytcc [8];
  double aytbb [8];
  double axtcc [8];
  double axtbb [8];
  double temp8 [8];
  double cyab [8];
  double cxab [8];
  double byca [8];
  double bxca [8];
  double aybc [8];
  double axbc [8];
  double catt [4];
  double bctt [4];
  double abtt [4];
  double v [4];
  double u [4];
  double cc [4];
  double bb [4];
  double aa [4];
  double ab [4];
  double ca [4];
  double bc [4];
  
  dVar1 = *pd;
  dVar5 = *pa - dVar1;
  dVar6 = *pb - dVar1;
  dVar1 = *pc - dVar1;
  dVar2 = pd[1];
  dVar7 = pa[1] - dVar2;
  dVar8 = pb[1] - dVar2;
  dVar2 = pc[1] - dVar2;
  dVar9 = dVar6 * dVar2;
  dVar10 = dVar6 * splitter - (dVar6 * splitter - dVar6);
  dVar11 = dVar2 * splitter - (dVar2 * splitter - dVar2);
  dVar24 = (dVar6 - dVar10) * (dVar2 - dVar11) -
           (((dVar9 - dVar10 * dVar11) - dVar11 * (dVar6 - dVar10)) - (dVar2 - dVar11) * dVar10);
  dVar10 = dVar1 * dVar8;
  dVar12 = dVar1 * splitter - (dVar1 * splitter - dVar1);
  dVar11 = splitter * dVar8 - (splitter * dVar8 - dVar8);
  dVar11 = (dVar1 - dVar12) * (dVar8 - dVar11) -
           (((dVar10 - dVar12 * dVar11) - dVar11 * (dVar1 - dVar12)) - (dVar8 - dVar11) * dVar12);
  dVar12 = dVar24 - dVar11;
  bc[0] = (dVar24 - (dVar12 + (dVar24 - dVar12))) + ((dVar24 - dVar12) - dVar11);
  dVar11 = dVar9 + dVar12;
  dVar12 = (dVar12 - (dVar11 - dVar9)) + (dVar9 - (dVar11 - (dVar11 - dVar9)));
  dVar24 = dVar12 - dVar10;
  bc[1] = ((dVar12 - dVar24) - dVar10) + (dVar12 - (dVar24 + (dVar12 - dVar24)));
  bc[3] = dVar11 + dVar24;
  bc[2] = (dVar11 - (bc[3] - (bc[3] - dVar11))) + (dVar24 - (bc[3] - dVar11));
  iVar33 = scale_expansion_zeroelim(4,bc,dVar5,axbc);
  iVar33 = scale_expansion_zeroelim(iVar33,axbc,dVar5,axxbc);
  iVar34 = scale_expansion_zeroelim(4,bc,dVar7,aybc);
  iVar34 = scale_expansion_zeroelim(iVar34,aybc,dVar7,ayybc);
  iVar33 = fast_expansion_sum_zeroelim(iVar33,axxbc,iVar34,ayybc,adet);
  dVar11 = dVar1 * dVar7;
  dVar12 = dVar1 * splitter - (dVar1 * splitter - dVar1);
  dVar24 = dVar7 * splitter - (dVar7 * splitter - dVar7);
  dVar3 = (dVar1 - dVar12) * (dVar7 - dVar24) -
          (((dVar11 - dVar12 * dVar24) - dVar24 * (dVar1 - dVar12)) - (dVar7 - dVar24) * dVar12);
  dVar25 = dVar2 * dVar5;
  dVar12 = dVar5 * splitter - (dVar5 * splitter - dVar5);
  dVar24 = splitter * dVar2 - (splitter * dVar2 - dVar2);
  dVar12 = (dVar5 - dVar12) * (dVar2 - dVar24) -
           (((dVar25 - dVar12 * dVar24) - dVar24 * (dVar5 - dVar12)) - (dVar2 - dVar24) * dVar12);
  dVar24 = dVar3 - dVar12;
  ca[0] = (dVar3 - (dVar24 + (dVar3 - dVar24))) + ((dVar3 - dVar24) - dVar12);
  dVar12 = dVar11 + dVar24;
  dVar24 = (dVar24 - (dVar12 - dVar11)) + (dVar11 - (dVar12 - (dVar12 - dVar11)));
  dVar3 = dVar24 - dVar25;
  ca[1] = ((dVar24 - dVar3) - dVar25) + (dVar24 - (dVar3 + (dVar24 - dVar3)));
  ca[3] = dVar12 + dVar3;
  ca[2] = (dVar12 - (ca[3] - (ca[3] - dVar12))) + (dVar3 - (ca[3] - dVar12));
  iVar34 = scale_expansion_zeroelim(4,ca,dVar6,bxca);
  iVar34 = scale_expansion_zeroelim(iVar34,bxca,dVar6,bxxca);
  iVar35 = scale_expansion_zeroelim(4,ca,dVar8,byca);
  iVar35 = scale_expansion_zeroelim(iVar35,byca,dVar8,byyca);
  iVar34 = fast_expansion_sum_zeroelim(iVar34,bxxca,iVar35,byyca,bdet);
  dVar24 = dVar8 * dVar5;
  dVar12 = splitter * dVar5 - (splitter * dVar5 - dVar5);
  dVar3 = dVar8 * splitter - (dVar8 * splitter - dVar8);
  dVar3 = (dVar5 - dVar12) * (dVar8 - dVar3) -
          (((dVar24 - dVar12 * dVar3) - dVar3 * (dVar5 - dVar12)) - (dVar8 - dVar3) * dVar12);
  dVar12 = dVar6 * dVar7;
  dVar4 = dVar6 * splitter - (dVar6 * splitter - dVar6);
  dVar13 = splitter * dVar7 - (splitter * dVar7 - dVar7);
  dVar13 = (dVar6 - dVar4) * (dVar7 - dVar13) -
           (((dVar12 - dVar4 * dVar13) - dVar13 * (dVar6 - dVar4)) - (dVar7 - dVar13) * dVar4);
  dVar4 = dVar3 - dVar13;
  ab[0] = (dVar3 - (dVar4 + (dVar3 - dVar4))) + ((dVar3 - dVar4) - dVar13);
  dVar3 = dVar24 + dVar4;
  dVar4 = (dVar4 - (dVar3 - dVar24)) + (dVar24 - (dVar3 - (dVar3 - dVar24)));
  dVar13 = dVar4 - dVar12;
  ab[1] = ((dVar4 - dVar13) - dVar12) + (dVar4 - (dVar13 + (dVar4 - dVar13)));
  ab[3] = dVar3 + dVar13;
  ab[2] = (dVar3 - (ab[3] - (ab[3] - dVar3))) + (dVar13 - (ab[3] - dVar3));
  iVar35 = scale_expansion_zeroelim(4,ab,dVar1,cxab);
  iVar35 = scale_expansion_zeroelim(iVar35,cxab,dVar1,cxxab);
  iVar36 = scale_expansion_zeroelim(4,ab,dVar2,cyab);
  iVar36 = scale_expansion_zeroelim(iVar36,cyab,dVar2,cyyab);
  finother = fin1;
  iVar35 = fast_expansion_sum_zeroelim(iVar35,cxxab,iVar36,cyyab,cdet);
  iVar33 = fast_expansion_sum_zeroelim(iVar33,adet,iVar34,bdet,abdet);
  iVar33 = fast_expansion_sum_zeroelim(iVar33,abdet,iVar35,cdet,finother);
  if (1 < iVar33) {
    iVar34 = 1;
    do {
      fin1[0] = fin1[0] + finother[iVar34];
      iVar34 = iVar34 + 1;
    } while (iVar34 != iVar33);
  }
  if ((fin1[0] < permanent * iccerrboundB) && (-fin1[0] < permanent * iccerrboundB)) {
    dVar4 = *pa - dVar5;
    dVar3 = *pd;
    b = (dVar4 - dVar3) + (*pa - (dVar5 + dVar4));
    dVar13 = pa[1] - dVar7;
    dVar4 = pd[1];
    dVar13 = (dVar13 - dVar4) + (pa[1] - (dVar7 + dVar13));
    dVar14 = *pb - dVar6;
    b_00 = (dVar14 - dVar3) + (*pb - (dVar6 + dVar14));
    dVar14 = pb[1] - dVar8;
    dVar14 = (dVar14 - dVar4) + (pb[1] - (dVar8 + dVar14));
    dVar30 = *pc - dVar1;
    dVar30 = (*pc - (dVar1 + dVar30)) + (dVar30 - dVar3);
    dVar3 = pc[1] - dVar2;
    dVar3 = (pc[1] - (dVar2 + dVar3)) + (dVar3 - dVar4);
    if (((b != 0.0) || (((b_00 != 0.0 || (dVar30 != 0.0)) || (dVar13 != 0.0)))) ||
       ((dVar14 != 0.0 || (dVar3 != 0.0)))) {
      dVar4 = -fin1[0];
      if (0.0 <= fin1[0]) {
        dVar4 = fin1[0];
      }
      dVar26 = dVar4 * resulterrbound + permanent * iccerrboundC;
      dVar28 = dVar5 * dVar5;
      dVar4 = dVar7 * dVar7;
      dVar15 = dVar6 * dVar3;
      dVar16 = dVar2 * b_00;
      dVar17 = dVar6 * dVar6;
      dVar18 = dVar8 * dVar8;
      dVar19 = dVar1 * dVar13;
      dVar20 = dVar7 * dVar30;
      dVar21 = dVar1 * dVar1;
      dVar22 = dVar2 * dVar2;
      dVar29 = dVar14 * dVar5;
      dVar23 = dVar8 * b;
      dVar27 = dVar7 * dVar13 + b * dVar5;
      dVar31 = dVar8 * dVar14 + dVar6 * b_00;
      dVar32 = dVar2 * dVar3 + dVar1 * dVar30;
      fin1[0] = (dVar24 - dVar12) * (dVar32 + dVar32) +
                ((dVar29 + dVar23) - (dVar6 * dVar13 + dVar7 * b_00)) * (dVar21 + dVar22) +
                (dVar11 - dVar25) * (dVar31 + dVar31) +
                ((dVar19 + dVar20) - (dVar3 * dVar5 + dVar2 * b)) * (dVar17 + dVar18) +
                (dVar9 - dVar10) * (dVar27 + dVar27) +
                ((dVar15 + dVar16) - (dVar1 * dVar14 + dVar8 * dVar30)) * (dVar28 + dVar4) + fin1[0]
      ;
      if ((fin1[0] < dVar26) && (-fin1[0] < dVar26)) {
        if ((b_00 != 0.0) || (((dVar14 != 0.0 || (dVar30 != 0.0)) || (dVar3 != 0.0)))) {
          dVar10 = splitter * dVar5 - (splitter * dVar5 - dVar5);
          dVar9 = dVar5 - dVar10;
          dVar9 = dVar9 * dVar9 - ((dVar28 - dVar10 * dVar10) + dVar10 * -2.0 * dVar9);
          dVar11 = dVar7 * splitter - (dVar7 * splitter - dVar7);
          dVar10 = dVar7 - dVar11;
          dVar11 = dVar10 * dVar10 - ((dVar4 - dVar11 * dVar11) + dVar11 * -2.0 * dVar10);
          dVar10 = dVar9 + dVar11;
          aa[0] = (dVar9 - (dVar10 - (dVar10 - dVar9))) + (dVar11 - (dVar10 - dVar9));
          dVar9 = dVar28 + dVar10;
          dVar10 = (dVar10 - (dVar9 - dVar28)) + (dVar28 - (dVar9 - (dVar9 - dVar28)));
          dVar11 = dVar4 + dVar10;
          aa[1] = (dVar4 - (dVar11 - dVar10)) + (dVar10 - (dVar11 - (dVar11 - dVar10)));
          aa[3] = dVar9 + dVar11;
          aa[2] = (dVar9 - (aa[3] - (aa[3] - dVar9))) + (dVar11 - (aa[3] - dVar9));
        }
        if (((dVar30 != 0.0) || (dVar3 != 0.0)) || ((b != 0.0 || (dVar13 != 0.0)))) {
          dVar10 = dVar6 * splitter - (dVar6 * splitter - dVar6);
          dVar9 = dVar6 - dVar10;
          dVar11 = dVar9 * dVar9 - ((dVar17 - dVar10 * dVar10) + dVar10 * -2.0 * dVar9);
          dVar9 = splitter * dVar8 - (splitter * dVar8 - dVar8);
          dVar10 = dVar8 - dVar9;
          dVar9 = dVar10 * dVar10 - ((dVar18 - dVar9 * dVar9) + dVar9 * -2.0 * dVar10);
          dVar10 = dVar11 + dVar9;
          bb[0] = (dVar11 - (dVar10 - (dVar10 - dVar11))) + (dVar9 - (dVar10 - dVar11));
          dVar9 = dVar17 + dVar10;
          dVar10 = (dVar10 - (dVar9 - dVar17)) + (dVar17 - (dVar9 - (dVar9 - dVar17)));
          dVar11 = dVar18 + dVar10;
          bb[1] = (dVar18 - (dVar11 - dVar10)) + (dVar10 - (dVar11 - (dVar11 - dVar10)));
          bb[3] = dVar9 + dVar11;
          bb[2] = (dVar9 - (bb[3] - (bb[3] - dVar9))) + (dVar11 - (bb[3] - dVar9));
        }
        if (((b != 0.0) || (dVar13 != 0.0)) || ((b_00 != 0.0 || (dVar14 != 0.0)))) {
          dVar10 = dVar1 * splitter - (dVar1 * splitter - dVar1);
          dVar9 = dVar1 - dVar10;
          dVar11 = dVar9 * dVar9 - ((dVar21 - dVar10 * dVar10) + dVar10 * -2.0 * dVar9);
          dVar9 = splitter * dVar2 - (splitter * dVar2 - dVar2);
          dVar10 = dVar2 - dVar9;
          dVar9 = dVar10 * dVar10 - ((dVar22 - dVar9 * dVar9) + dVar9 * -2.0 * dVar10);
          dVar10 = dVar11 + dVar9;
          cc[0] = (dVar11 - (dVar10 - (dVar10 - dVar11))) + (dVar9 - (dVar10 - dVar11));
          dVar9 = dVar21 + dVar10;
          dVar10 = (dVar10 - (dVar9 - dVar21)) + (dVar21 - (dVar9 - (dVar9 - dVar21)));
          dVar11 = dVar22 + dVar10;
          cc[1] = (dVar22 - (dVar11 - dVar10)) + (dVar10 - (dVar11 - (dVar11 - dVar10)));
          cc[3] = dVar9 + dVar11;
          cc[2] = (dVar9 - (cc[3] - (cc[3] - dVar9))) + (dVar11 - (cc[3] - dVar9));
        }
        if (b == 0.0) {
          iVar34 = 0;
          finnow = finother;
          finother = fin2;
        }
        else {
          iVar34 = scale_expansion_zeroelim(4,bc,b,axtbc);
          iVar35 = scale_expansion_zeroelim(iVar34,axtbc,dVar5 + dVar5,temp16a);
          iVar36 = scale_expansion_zeroelim(4,cc,b,axtcc);
          iVar36 = scale_expansion_zeroelim(iVar36,axtcc,dVar8,temp16b);
          iVar37 = scale_expansion_zeroelim(4,bb,b,axtbb);
          iVar37 = scale_expansion_zeroelim(iVar37,axtbb,-dVar2,temp16c);
          iVar35 = fast_expansion_sum_zeroelim(iVar35,temp16a,iVar36,temp16b,temp32a);
          iVar35 = fast_expansion_sum_zeroelim(iVar37,temp16c,iVar35,temp32a,temp48);
          finnow = fin2;
          iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar35,temp48,fin2);
        }
        local_648c = 0;
        pdVar40 = finnow;
        if (dVar13 != 0.0) {
          local_648c = scale_expansion_zeroelim(4,bc,dVar13,aytbc);
          iVar35 = scale_expansion_zeroelim(local_648c,aytbc,dVar7 + dVar7,temp16a);
          iVar36 = scale_expansion_zeroelim(4,bb,dVar13,aytbb);
          iVar36 = scale_expansion_zeroelim(iVar36,aytbb,dVar1,temp16b);
          iVar37 = scale_expansion_zeroelim(4,cc,dVar13,aytcc);
          iVar37 = scale_expansion_zeroelim(iVar37,aytcc,-dVar6,temp16c);
          iVar35 = fast_expansion_sum_zeroelim(iVar35,temp16a,iVar36,temp16b,temp32a);
          iVar35 = fast_expansion_sum_zeroelim(iVar37,temp16c,iVar35,temp32a,temp48);
          iVar33 = fast_expansion_sum_zeroelim(iVar33,finnow,iVar35,temp48,finother);
          pdVar40 = finother;
          finother = finnow;
        }
        iVar35 = 0;
        pdVar41 = pdVar40;
        if (b_00 != 0.0) {
          iVar35 = scale_expansion_zeroelim(4,ca,b_00,bxtca);
          iVar36 = scale_expansion_zeroelim(iVar35,bxtca,dVar6 + dVar6,temp16a);
          iVar37 = scale_expansion_zeroelim(4,aa,b_00,bxtaa);
          iVar37 = scale_expansion_zeroelim(iVar37,bxtaa,dVar2,temp16b);
          iVar38 = scale_expansion_zeroelim(4,cc,b_00,bxtcc);
          iVar38 = scale_expansion_zeroelim(iVar38,bxtcc,-dVar7,temp16c);
          iVar36 = fast_expansion_sum_zeroelim(iVar36,temp16a,iVar37,temp16b,temp32a);
          iVar36 = fast_expansion_sum_zeroelim(iVar38,temp16c,iVar36,temp32a,temp48);
          iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar36,temp48,finother);
          pdVar41 = finother;
          finother = pdVar40;
        }
        local_646c = 0;
        pdVar40 = pdVar41;
        if (dVar14 != 0.0) {
          local_646c = scale_expansion_zeroelim(4,ca,dVar14,bytca);
          iVar36 = scale_expansion_zeroelim(local_646c,bytca,dVar8 + dVar8,temp16a);
          iVar37 = scale_expansion_zeroelim(4,cc,dVar14,bytcc);
          iVar37 = scale_expansion_zeroelim(iVar37,bytcc,dVar5,temp16b);
          iVar38 = scale_expansion_zeroelim(4,aa,dVar14,bytaa);
          iVar38 = scale_expansion_zeroelim(iVar38,bytaa,-dVar1,temp16c);
          iVar36 = fast_expansion_sum_zeroelim(iVar36,temp16a,iVar37,temp16b,temp32a);
          iVar36 = fast_expansion_sum_zeroelim(iVar38,temp16c,iVar36,temp32a,temp48);
          iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar41,iVar36,temp48,finother);
          pdVar40 = finother;
          finother = pdVar41;
        }
        iVar36 = 0;
        pdVar41 = pdVar40;
        if (dVar30 != 0.0) {
          iVar36 = scale_expansion_zeroelim(4,ab,dVar30,cxtab);
          iVar37 = scale_expansion_zeroelim(iVar36,cxtab,dVar1 + dVar1,temp16a);
          iVar38 = scale_expansion_zeroelim(4,bb,dVar30,cxtbb);
          iVar38 = scale_expansion_zeroelim(iVar38,cxtbb,dVar7,temp16b);
          iVar39 = scale_expansion_zeroelim(4,aa,dVar30,cxtaa);
          iVar39 = scale_expansion_zeroelim(iVar39,cxtaa,-dVar8,temp16c);
          iVar37 = fast_expansion_sum_zeroelim(iVar37,temp16a,iVar38,temp16b,temp32a);
          iVar37 = fast_expansion_sum_zeroelim(iVar39,temp16c,iVar37,temp32a,temp48);
          iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar37,temp48,finother);
          pdVar41 = finother;
          finother = pdVar40;
        }
        local_6474 = 0;
        pdVar40 = pdVar41;
        if (dVar3 != 0.0) {
          local_6474 = scale_expansion_zeroelim(4,ab,dVar3,cytab);
          iVar37 = scale_expansion_zeroelim(local_6474,cytab,dVar2 + dVar2,temp16a);
          iVar38 = scale_expansion_zeroelim(4,aa,dVar3,cytaa);
          iVar38 = scale_expansion_zeroelim(iVar38,cytaa,dVar6,temp16b);
          iVar39 = scale_expansion_zeroelim(4,bb,dVar3,cytbb);
          iVar39 = scale_expansion_zeroelim(iVar39,cytbb,-dVar5,temp16c);
          iVar37 = fast_expansion_sum_zeroelim(iVar37,temp16a,iVar38,temp16b,temp32a);
          iVar37 = fast_expansion_sum_zeroelim(iVar39,temp16c,iVar37,temp32a,temp48);
          iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar41,iVar37,temp48,finother);
          pdVar40 = finother;
          finother = pdVar41;
        }
        if ((b != 0.0) || (dVar13 != 0.0)) {
          if ((b_00 == 0.0) && (((dVar14 == 0.0 && (dVar30 == 0.0)) && (dVar3 == 0.0)))) {
            bct[0] = 0.0;
            local_645c = 1;
            bctt[0] = 0.0;
            iVar37 = 1;
          }
          else {
            dVar9 = splitter * b_00 - (splitter * b_00 - b_00);
            dVar10 = dVar2 * splitter - (dVar2 * splitter - dVar2);
            dVar9 = (b_00 - dVar9) * (dVar2 - dVar10) -
                    (((dVar16 - dVar9 * dVar10) - dVar10 * (b_00 - dVar9)) -
                    (dVar2 - dVar10) * dVar9);
            dVar10 = dVar6 * splitter - (dVar6 * splitter - dVar6);
            dVar11 = dVar3 * splitter - (dVar3 * splitter - dVar3);
            dVar11 = (dVar6 - dVar10) * (dVar3 - dVar11) -
                     (((dVar15 - dVar10 * dVar11) - dVar11 * (dVar6 - dVar10)) -
                     (dVar3 - dVar11) * dVar10);
            dVar10 = dVar9 + dVar11;
            u[0] = (dVar9 - (dVar10 - (dVar10 - dVar9))) + (dVar11 - (dVar10 - dVar9));
            dVar9 = dVar16 + dVar10;
            dVar10 = (dVar16 - (dVar9 - (dVar9 - dVar16))) + (dVar10 - (dVar9 - dVar16));
            dVar11 = dVar15 + dVar10;
            u[1] = (dVar15 - (dVar11 - dVar10)) + (dVar10 - (dVar11 - (dVar11 - dVar10)));
            u[3] = dVar9 + dVar11;
            u[2] = (dVar9 - (u[3] - (u[3] - dVar9))) + (dVar11 - (u[3] - dVar9));
            dVar9 = -dVar8;
            dVar10 = dVar30 * dVar9;
            dVar12 = splitter * dVar30 - (splitter * dVar30 - dVar30);
            dVar11 = splitter * dVar9 - (splitter * dVar9 - dVar9);
            dVar9 = (dVar30 - dVar12) * (dVar9 - dVar11) -
                    (((dVar10 - dVar12 * dVar11) - dVar11 * (dVar30 - dVar12)) -
                    dVar12 * (dVar9 - dVar11));
            dVar12 = -dVar14;
            dVar24 = dVar1 * dVar12;
            dVar25 = dVar1 * splitter - (dVar1 * splitter - dVar1);
            dVar11 = splitter * dVar12 - (splitter * dVar12 - dVar12);
            dVar12 = (dVar1 - dVar25) * (dVar12 - dVar11) -
                     (((dVar24 - dVar25 * dVar11) - dVar11 * (dVar1 - dVar25)) -
                     dVar25 * (dVar12 - dVar11));
            dVar11 = dVar9 + dVar12;
            v[0] = (dVar9 - (dVar11 - (dVar11 - dVar9))) + (dVar12 - (dVar11 - dVar9));
            dVar9 = dVar10 + dVar11;
            dVar10 = (dVar10 - (dVar9 - (dVar9 - dVar10))) + (dVar11 - (dVar9 - dVar10));
            dVar11 = dVar24 + dVar10;
            v[1] = (dVar24 - (dVar11 - dVar10)) + (dVar10 - (dVar11 - (dVar11 - dVar10)));
            v[3] = dVar9 + dVar11;
            v[2] = (dVar9 - (v[3] - (v[3] - dVar9))) + (dVar11 - (v[3] - dVar9));
            iVar37 = fast_expansion_sum_zeroelim(4,u,4,v,bct);
            local_645c = 4;
            dVar9 = b_00 * dVar3;
            dVar10 = b_00 * splitter - (b_00 * splitter - b_00);
            dVar11 = dVar3 * splitter - (dVar3 * splitter - dVar3);
            dVar24 = (b_00 - dVar10) * (dVar3 - dVar11) -
                     (((dVar9 - dVar10 * dVar11) - dVar11 * (b_00 - dVar10)) -
                     (dVar3 - dVar11) * dVar10);
            dVar10 = dVar30 * dVar14;
            dVar12 = dVar30 * splitter - (dVar30 * splitter - dVar30);
            dVar11 = splitter * dVar14 - (splitter * dVar14 - dVar14);
            dVar11 = (dVar30 - dVar12) * (dVar14 - dVar11) -
                     (((dVar10 - dVar12 * dVar11) - dVar11 * (dVar30 - dVar12)) -
                     (dVar14 - dVar11) * dVar12);
            dVar12 = dVar24 - dVar11;
            bctt[0] = (dVar24 - (dVar12 + (dVar24 - dVar12))) + ((dVar24 - dVar12) - dVar11);
            dVar11 = dVar9 + dVar12;
            dVar9 = (dVar12 - (dVar11 - dVar9)) + (dVar9 - (dVar11 - (dVar11 - dVar9)));
            dVar12 = dVar9 - dVar10;
            bctt[1] = ((dVar9 - dVar12) - dVar10) + (dVar9 - (dVar12 + (dVar9 - dVar12)));
            bctt[3] = dVar11 + dVar12;
            bctt[2] = (dVar11 - (bctt[3] - (bctt[3] - dVar11))) + (dVar12 - (bctt[3] - dVar11));
          }
          if (b != 0.0) {
            iVar34 = scale_expansion_zeroelim(iVar34,axtbc,b,temp16a);
            iVar38 = scale_expansion_zeroelim(iVar37,bct,b,axtbct);
            iVar39 = scale_expansion_zeroelim(iVar38,axtbct,dVar5 + dVar5,temp32a);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp16a,iVar39,temp32a,temp48);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar34,temp48,finother);
            pdVar41 = finother;
            if (dVar14 != 0.0) {
              iVar34 = scale_expansion_zeroelim(4,cc,b,temp8);
              iVar34 = scale_expansion_zeroelim(iVar34,temp8,dVar14,temp16a);
              iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar34,temp16a,pdVar40);
              pdVar41 = pdVar40;
              pdVar40 = finother;
            }
            finother = pdVar41;
            if (dVar3 != 0.0) {
              iVar34 = scale_expansion_zeroelim(4,bb,-b,temp8);
              iVar34 = scale_expansion_zeroelim(iVar34,temp8,dVar3,temp16a);
              iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar41,iVar34,temp16a,pdVar40);
              finother = pdVar40;
              pdVar40 = pdVar41;
            }
            iVar34 = scale_expansion_zeroelim(iVar38,axtbct,b,temp32a);
            iVar38 = scale_expansion_zeroelim(local_645c,bctt,b,axtbctt);
            iVar39 = scale_expansion_zeroelim(iVar38,axtbctt,dVar5 + dVar5,temp16a);
            iVar38 = scale_expansion_zeroelim(iVar38,axtbctt,b,temp16b);
            iVar38 = fast_expansion_sum_zeroelim(iVar39,temp16a,iVar38,temp16b,temp32b);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp32a,iVar38,temp32b,temp64);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar34,temp64,pdVar40);
          }
          if (dVar13 != 0.0) {
            iVar34 = scale_expansion_zeroelim(local_648c,aytbc,dVar13,temp16a);
            iVar37 = scale_expansion_zeroelim(iVar37,bct,dVar13,aytbct);
            iVar38 = scale_expansion_zeroelim(iVar37,aytbct,dVar7 + dVar7,temp32a);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp16a,iVar38,temp32a,temp48);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar34,temp48,finother);
            iVar34 = scale_expansion_zeroelim(iVar37,aytbct,dVar13,temp32a);
            iVar37 = scale_expansion_zeroelim(local_645c,bctt,dVar13,aytbctt);
            iVar38 = scale_expansion_zeroelim(iVar37,aytbctt,dVar7 + dVar7,temp16a);
            iVar37 = scale_expansion_zeroelim(iVar37,aytbctt,dVar13,temp16b);
            iVar37 = fast_expansion_sum_zeroelim(iVar38,temp16a,iVar37,temp16b,temp32b);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp32a,iVar37,temp32b,temp64);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar34,temp64,pdVar40);
          }
        }
        if ((b_00 != 0.0) || (dVar14 != 0.0)) {
          if (((dVar30 == 0.0) && ((dVar3 == 0.0 && (b == 0.0)))) && (dVar13 == 0.0)) {
            cat[0] = 0.0;
            local_645c = 1;
            catt[0] = 0.0;
            iVar34 = 1;
          }
          else {
            dVar9 = splitter * dVar30 - (splitter * dVar30 - dVar30);
            dVar10 = dVar7 * splitter - (dVar7 * splitter - dVar7);
            dVar9 = (dVar30 - dVar9) * (dVar7 - dVar10) -
                    (((dVar20 - dVar9 * dVar10) - dVar10 * (dVar30 - dVar9)) -
                    (dVar7 - dVar10) * dVar9);
            dVar10 = dVar1 * splitter - (dVar1 * splitter - dVar1);
            dVar11 = dVar13 * splitter - (dVar13 * splitter - dVar13);
            dVar11 = (dVar1 - dVar10) * (dVar13 - dVar11) -
                     (((dVar19 - dVar10 * dVar11) - dVar11 * (dVar1 - dVar10)) -
                     (dVar13 - dVar11) * dVar10);
            dVar10 = dVar9 + dVar11;
            u[0] = (dVar9 - (dVar10 - (dVar10 - dVar9))) + (dVar11 - (dVar10 - dVar9));
            dVar9 = dVar20 + dVar10;
            dVar10 = (dVar20 - (dVar9 - (dVar9 - dVar20))) + (dVar10 - (dVar9 - dVar20));
            dVar11 = dVar19 + dVar10;
            u[1] = (dVar19 - (dVar11 - dVar10)) + (dVar10 - (dVar11 - (dVar11 - dVar10)));
            u[3] = dVar9 + dVar11;
            u[2] = (dVar9 - (u[3] - (u[3] - dVar9))) + (dVar11 - (u[3] - dVar9));
            dVar10 = -dVar2;
            dVar24 = b * dVar10;
            dVar11 = splitter * b - (splitter * b - b);
            dVar9 = splitter * dVar10 - (splitter * dVar10 - dVar10);
            dVar12 = (b - dVar11) * (dVar10 - dVar9) -
                     (((dVar24 - dVar11 * dVar9) - dVar9 * (b - dVar11)) - dVar11 * (dVar10 - dVar9)
                     );
            dVar10 = -dVar3;
            dVar9 = dVar5 * dVar10;
            dVar25 = splitter * dVar5 - (splitter * dVar5 - dVar5);
            dVar11 = splitter * dVar10 - (splitter * dVar10 - dVar10);
            dVar10 = (dVar5 - dVar25) * (dVar10 - dVar11) -
                     (((dVar9 - dVar25 * dVar11) - dVar11 * (dVar5 - dVar25)) -
                     dVar25 * (dVar10 - dVar11));
            dVar11 = dVar12 + dVar10;
            v[0] = (dVar12 - (dVar11 - (dVar11 - dVar12))) + (dVar10 - (dVar11 - dVar12));
            dVar10 = dVar24 + dVar11;
            dVar11 = (dVar24 - (dVar10 - (dVar10 - dVar24))) + (dVar11 - (dVar10 - dVar24));
            dVar12 = dVar9 + dVar11;
            v[1] = (dVar9 - (dVar12 - dVar11)) + (dVar11 - (dVar12 - (dVar12 - dVar11)));
            v[3] = dVar10 + dVar12;
            v[2] = (dVar10 - (v[3] - (v[3] - dVar10))) + (dVar12 - (v[3] - dVar10));
            iVar34 = fast_expansion_sum_zeroelim(4,u,4,v,cat);
            local_645c = 4;
            dVar9 = dVar30 * dVar13;
            dVar10 = dVar30 * splitter - (dVar30 * splitter - dVar30);
            dVar11 = dVar13 * splitter - (dVar13 * splitter - dVar13);
            dVar24 = (dVar30 - dVar10) * (dVar13 - dVar11) -
                     (((dVar9 - dVar10 * dVar11) - dVar11 * (dVar30 - dVar10)) -
                     (dVar13 - dVar11) * dVar10);
            dVar10 = b * dVar3;
            dVar12 = b * splitter - (b * splitter - b);
            dVar11 = splitter * dVar3 - (splitter * dVar3 - dVar3);
            dVar11 = (b - dVar12) * (dVar3 - dVar11) -
                     (((dVar10 - dVar12 * dVar11) - dVar11 * (b - dVar12)) -
                     (dVar3 - dVar11) * dVar12);
            dVar12 = dVar24 - dVar11;
            catt[0] = (dVar24 - (dVar12 + (dVar24 - dVar12))) + ((dVar24 - dVar12) - dVar11);
            dVar11 = dVar9 + dVar12;
            dVar9 = (dVar12 - (dVar11 - dVar9)) + (dVar9 - (dVar11 - (dVar11 - dVar9)));
            dVar12 = dVar9 - dVar10;
            catt[1] = ((dVar9 - dVar12) - dVar10) + (dVar9 - (dVar12 + (dVar9 - dVar12)));
            catt[3] = dVar11 + dVar12;
            catt[2] = (dVar11 - (catt[3] - (catt[3] - dVar11))) + (dVar12 - (catt[3] - dVar11));
          }
          if (b_00 != 0.0) {
            iVar35 = scale_expansion_zeroelim(iVar35,bxtca,b_00,temp16a);
            iVar37 = scale_expansion_zeroelim(iVar34,cat,b_00,bxtcat);
            iVar38 = scale_expansion_zeroelim(iVar37,bxtcat,dVar6 + dVar6,temp32a);
            iVar35 = fast_expansion_sum_zeroelim(iVar35,temp16a,iVar38,temp32a,temp48);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar35,temp48,finother);
            pdVar41 = finother;
            if (dVar3 != 0.0) {
              iVar35 = scale_expansion_zeroelim(4,aa,b_00,temp8);
              iVar35 = scale_expansion_zeroelim(iVar35,temp8,dVar3,temp16a);
              iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar35,temp16a,pdVar40);
              pdVar41 = pdVar40;
              pdVar40 = finother;
            }
            finother = pdVar41;
            if (dVar13 != 0.0) {
              iVar35 = scale_expansion_zeroelim(4,cc,-b_00,temp8);
              iVar35 = scale_expansion_zeroelim(iVar35,temp8,dVar13,temp16a);
              iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar41,iVar35,temp16a,pdVar40);
              finother = pdVar40;
              pdVar40 = pdVar41;
            }
            iVar35 = scale_expansion_zeroelim(iVar37,bxtcat,b_00,temp32a);
            iVar37 = scale_expansion_zeroelim(local_645c,catt,b_00,bxtcatt);
            iVar38 = scale_expansion_zeroelim(iVar37,bxtcatt,dVar6 + dVar6,temp16a);
            iVar37 = scale_expansion_zeroelim(iVar37,bxtcatt,b_00,temp16b);
            iVar37 = fast_expansion_sum_zeroelim(iVar38,temp16a,iVar37,temp16b,temp32b);
            iVar35 = fast_expansion_sum_zeroelim(iVar35,temp32a,iVar37,temp32b,temp64);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar35,temp64,pdVar40);
          }
          if (dVar14 != 0.0) {
            iVar35 = scale_expansion_zeroelim(local_646c,bytca,dVar14,temp16a);
            iVar34 = scale_expansion_zeroelim(iVar34,cat,dVar14,bytcat);
            iVar37 = scale_expansion_zeroelim(iVar34,bytcat,dVar8 + dVar8,temp32a);
            iVar35 = fast_expansion_sum_zeroelim(iVar35,temp16a,iVar37,temp32a,temp48);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar35,temp48,finother);
            iVar34 = scale_expansion_zeroelim(iVar34,bytcat,dVar14,temp32a);
            iVar35 = scale_expansion_zeroelim(local_645c,catt,dVar14,bytcatt);
            iVar37 = scale_expansion_zeroelim(iVar35,bytcatt,dVar8 + dVar8,temp16a);
            iVar35 = scale_expansion_zeroelim(iVar35,bytcatt,dVar14,temp16b);
            iVar35 = fast_expansion_sum_zeroelim(iVar37,temp16a,iVar35,temp16b,temp32b);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp32a,iVar35,temp32b,temp64);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar34,temp64,pdVar40);
          }
        }
        if ((dVar30 != 0.0) || (dVar3 != 0.0)) {
          if ((b == 0.0) && (((dVar13 == 0.0 && (b_00 == 0.0)) && (dVar14 == 0.0)))) {
            abt[0] = 0.0;
            local_63fc = 1;
            abtt[0] = 0.0;
            local_640c = 1;
          }
          else {
            dVar9 = b * splitter - (b * splitter - b);
            dVar10 = dVar8 * splitter - (dVar8 * splitter - dVar8);
            dVar9 = (b - dVar9) * (dVar8 - dVar10) -
                    (((dVar23 - dVar9 * dVar10) - dVar10 * (b - dVar9)) - (dVar8 - dVar10) * dVar9);
            dVar10 = dVar5 * splitter - (dVar5 * splitter - dVar5);
            dVar8 = dVar14 * splitter - (dVar14 * splitter - dVar14);
            dVar5 = (dVar5 - dVar10) * (dVar14 - dVar8) -
                    (((dVar29 - dVar10 * dVar8) - (dVar5 - dVar10) * dVar8) -
                    (dVar14 - dVar8) * dVar10);
            dVar8 = dVar9 + dVar5;
            u[0] = (dVar9 - (dVar8 - (dVar8 - dVar9))) + (dVar5 - (dVar8 - dVar9));
            dVar5 = dVar23 + dVar8;
            dVar8 = (dVar8 - (dVar5 - dVar23)) + (dVar23 - (dVar5 - (dVar5 - dVar23)));
            dVar9 = dVar29 + dVar8;
            u[1] = (dVar29 - (dVar9 - dVar8)) + (dVar8 - (dVar9 - (dVar9 - dVar8)));
            u[3] = dVar5 + dVar9;
            u[2] = (dVar5 - (u[3] - (u[3] - dVar5))) + (dVar9 - (u[3] - dVar5));
            dVar7 = -dVar7;
            dVar11 = b_00 * dVar7;
            dVar8 = b_00 * splitter - (b_00 * splitter - b_00);
            dVar5 = dVar7 * splitter - (dVar7 * splitter - dVar7);
            dVar5 = (b_00 - dVar8) * (dVar7 - dVar5) -
                    (((dVar11 - dVar8 * dVar5) - dVar5 * (b_00 - dVar8)) - dVar8 * (dVar7 - dVar5));
            dVar9 = -dVar13;
            dVar8 = dVar6 * dVar9;
            dVar10 = dVar6 * splitter - (dVar6 * splitter - dVar6);
            dVar7 = splitter * dVar9 - (splitter * dVar9 - dVar9);
            dVar7 = (dVar6 - dVar10) * (dVar9 - dVar7) -
                    (((dVar8 - dVar10 * dVar7) - dVar7 * (dVar6 - dVar10)) -
                    dVar10 * (dVar9 - dVar7));
            dVar6 = dVar5 + dVar7;
            v[0] = (dVar5 - (dVar6 - (dVar6 - dVar5))) + (dVar7 - (dVar6 - dVar5));
            dVar7 = dVar11 + dVar6;
            dVar6 = (dVar11 - (dVar7 - (dVar7 - dVar11))) + (dVar6 - (dVar7 - dVar11));
            dVar5 = dVar6 + dVar8;
            v[1] = (dVar6 - (dVar5 - (dVar5 - dVar6))) + (dVar8 - (dVar5 - dVar6));
            v[3] = dVar7 + dVar5;
            v[2] = (dVar7 - (v[3] - (v[3] - dVar7))) + (dVar5 - (v[3] - dVar7));
            local_640c = fast_expansion_sum_zeroelim(4,u,4,v,abt);
            dVar5 = b * dVar14;
            dVar6 = b * splitter - (b * splitter - b);
            dVar7 = dVar14 * splitter - (dVar14 * splitter - dVar14);
            dVar7 = (b - dVar6) * (dVar14 - dVar7) -
                    (((dVar5 - dVar6 * dVar7) - dVar7 * (b - dVar6)) - (dVar14 - dVar7) * dVar6);
            dVar8 = b_00 * dVar13;
            dVar9 = b_00 * splitter - (b_00 * splitter - b_00);
            dVar6 = splitter * dVar13 - (splitter * dVar13 - dVar13);
            local_63fc = 4;
            dVar6 = (dVar13 - dVar6) * (b_00 - dVar9) -
                    (((dVar8 - dVar9 * dVar6) - dVar6 * (b_00 - dVar9)) - dVar9 * (dVar13 - dVar6));
            dVar9 = dVar7 - dVar6;
            abtt[0] = (dVar7 - (dVar9 + (dVar7 - dVar9))) + ((dVar7 - dVar9) - dVar6);
            dVar6 = dVar5 + dVar9;
            dVar5 = (dVar5 - (dVar6 - (dVar6 - dVar5))) + (dVar9 - (dVar6 - dVar5));
            dVar7 = dVar5 - dVar8;
            abtt[1] = (dVar5 - (dVar7 + (dVar5 - dVar7))) + ((dVar5 - dVar7) - dVar8);
            abtt[3] = dVar6 + dVar7;
            abtt[2] = (dVar6 - (abtt[3] - (abtt[3] - dVar6))) + (dVar7 - (abtt[3] - dVar6));
          }
          if (dVar30 != 0.0) {
            iVar34 = scale_expansion_zeroelim(iVar36,cxtab,dVar30,temp16a);
            iVar35 = scale_expansion_zeroelim(local_640c,abt,dVar30,cxtabt);
            iVar36 = scale_expansion_zeroelim(iVar35,cxtabt,dVar1 + dVar1,temp32a);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp16a,iVar36,temp32a,temp48);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar34,temp48,finother);
            pdVar41 = finother;
            if (dVar13 != 0.0) {
              iVar34 = scale_expansion_zeroelim(4,bb,dVar30,temp8);
              iVar34 = scale_expansion_zeroelim(iVar34,temp8,dVar13,temp16a);
              iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar34,temp16a,pdVar40);
              pdVar41 = pdVar40;
              pdVar40 = finother;
            }
            finother = pdVar41;
            if (dVar14 != 0.0) {
              iVar34 = scale_expansion_zeroelim(4,aa,-dVar30,temp8);
              iVar34 = scale_expansion_zeroelim(iVar34,temp8,dVar14,temp16a);
              iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar41,iVar34,temp16a,pdVar40);
              finother = pdVar40;
              pdVar40 = pdVar41;
            }
            iVar34 = scale_expansion_zeroelim(iVar35,cxtabt,dVar30,temp32a);
            iVar35 = scale_expansion_zeroelim(local_63fc,abtt,dVar30,cxtabtt);
            iVar36 = scale_expansion_zeroelim(iVar35,cxtabtt,dVar1 + dVar1,temp16a);
            iVar35 = scale_expansion_zeroelim(iVar35,cxtabtt,dVar30,temp16b);
            iVar35 = fast_expansion_sum_zeroelim(iVar36,temp16a,iVar35,temp16b,temp32b);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp32a,iVar35,temp32b,temp64);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar34,temp64,pdVar40);
          }
          if (dVar3 != 0.0) {
            iVar34 = scale_expansion_zeroelim(local_6474,cytab,dVar3,temp16a);
            iVar35 = scale_expansion_zeroelim(local_640c,abt,dVar3,cytabt);
            iVar36 = scale_expansion_zeroelim(iVar35,cytabt,dVar2 + dVar2,temp32a);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp16a,iVar36,temp32a,temp48);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,pdVar40,iVar34,temp48,finother);
            iVar34 = scale_expansion_zeroelim(iVar35,cytabt,dVar3,temp32a);
            iVar35 = scale_expansion_zeroelim(local_63fc,abtt,dVar3,cytabtt);
            iVar36 = scale_expansion_zeroelim(iVar35,cytabtt,dVar2 + dVar2,temp16a);
            iVar35 = scale_expansion_zeroelim(iVar35,cytabtt,dVar3,temp16b);
            iVar35 = fast_expansion_sum_zeroelim(iVar36,temp16a,iVar35,temp16b,temp32b);
            iVar34 = fast_expansion_sum_zeroelim(iVar34,temp32a,iVar35,temp32b,temp64);
            iVar33 = fast_expansion_sum_zeroelim(iVar33,finother,iVar34,temp64,pdVar40);
          }
        }
        fin1[0] = pdVar40[iVar33 + -1];
      }
    }
  }
  return fin1[0];
}



// WARNING: Unknown calling convention

double incircle(double *pa,double *pb,double *pc,double *pd)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double cdy;
  double bdxcdy;
  double cdx;
  double ady;
  double bdx;
  double bdy;
  double adx;
  double dVar9;
  double local_34;
  double local_2c;
  double local_24;
  
  dVar9 = *pd;
  dVar2 = *pa - dVar9;
  dVar3 = *pb - dVar9;
  dVar9 = *pc - dVar9;
  dVar1 = pd[1];
  dVar6 = pa[1] - dVar1;
  dVar5 = pb[1] - dVar1;
  dVar1 = pc[1] - dVar1;
  dVar8 = dVar3 * dVar1;
  local_34 = dVar9 * dVar5;
  dVar7 = dVar6 * dVar6 + dVar2 * dVar2;
  local_2c = dVar9 * dVar6;
  local_24 = dVar2 * dVar1;
  dVar4 = dVar5 * dVar5 + dVar3 * dVar3;
  dVar5 = dVar5 * dVar2;
  dVar6 = dVar6 * dVar3;
  dVar9 = dVar1 * dVar1 + dVar9 * dVar9;
  dVar1 = (dVar5 - dVar6) * dVar9 + (dVar8 - local_34) * dVar7 + (local_2c - local_24) * dVar4;
  if (dVar8 < 0.0) {
    dVar8 = -dVar8;
  }
  if (local_34 < 0.0) {
    local_34 = -local_34;
  }
  if (local_2c < 0.0) {
    local_2c = -local_2c;
  }
  if (local_24 < 0.0) {
    local_24 = -local_24;
  }
  if (dVar5 < 0.0) {
    dVar5 = -dVar5;
  }
  if (dVar6 < 0.0) {
    dVar6 = -dVar6;
  }
  dVar9 = (dVar5 + dVar6) * dVar9 + (local_2c + local_24) * dVar4 + (dVar8 + local_34) * dVar7;
  dVar2 = iccerrboundA * dVar9;
  if ((dVar1 <= dVar2) && (-dVar1 <= dVar2)) {
    dVar9 = incircleadapt(pa,pb,pc,pd,dVar9);
    return dVar9;
  }
  return dVar1;
}



// WARNING: Removing unreachable block (ram,0x0812d86a)
// WARNING: Removing unreachable block (ram,0x0812d856)
// WARNING: Removing unreachable block (ram,0x0812d842)
// WARNING: Removing unreachable block (ram,0x0812d82c)
// WARNING: Removing unreachable block (ram,0x0812d80c)
// WARNING: Removing unreachable block (ram,0x0812d804)
// WARNING: Removing unreachable block (ram,0x0812d81c)
// WARNING: Removing unreachable block (ram,0x0812d836)
// WARNING: Removing unreachable block (ram,0x0812d84a)
// WARNING: Removing unreachable block (ram,0x0812d862)
// WARNING: Removing unreachable block (ram,0x0812d7f2)
// WARNING: Unknown calling convention
// Local variable temp48len:int[EAX:4] conflicts with parameter, skipped.
// Local variable xylen:int[EAX:4] conflicts with parameter, skipped.
// Local variable xlen:int[EAX:4] conflicts with parameter, skipped.
// Local variable ylen:int[EAX:4] conflicts with parameter, skipped.
// Local variable xylen_1:int[EAX:4] conflicts with parameter, skipped.
// Local variable cdlen_1:int[EAX:4] conflicts with parameter, skipped.

double insphereadapt(double *pa,double *pb,double *pc,double *pd,double *pe,double permanent)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  double dVar25;
  double dVar26;
  double dVar27;
  double dVar28;
  double dVar29;
  double dVar30;
  double dVar31;
  double dVar32;
  double dVar33;
  double dVar34;
  double dVar35;
  double dVar36;
  double dVar37;
  double dVar38;
  double dVar39;
  double dVar40;
  double dVar41;
  double dVar42;
  double dVar43;
  double dVar44;
  double dVar45;
  double dVar46;
  double dVar47;
  double dVar48;
  int iVar49;
  int iVar50;
  int iVar51;
  int temp16len;
  int iVar52;
  int iVar53;
  int iVar54;
  int cdlen;
  int finlength;
  int deterlen;
  int temp8blen_1;
  int iVar55;
  int iVar56;
  int iVar57;
  int iVar58;
  int iVar59;
  int iVar60;
  int temp48blen;
  int iVar61;
  int cdelen;
  int eindex;
  int i;
  int temp8blen;
  int abcdlen;
  int temp8alen;
  int zlen;
  int temp48alen;
  int temp24len;
  int temp16len_1;
  int zlen_1;
  double det;
  double aexbey0;
  double errbound;
  double aexbey1;
  double cexdey1;
  double bexaey1;
  double dexcey1;
  double deter [5760];
  double cdedet [3456];
  double cddet_1 [2304];
  double abdet_1 [2304];
  double edet [1152];
  double ddet_1 [1152];
  double cdet_1 [1152];
  double bdet_1 [1152];
  double adet_1 [1152];
  double fin1 [1152];
  double detxy [768];
  double cddet [576];
  double abdet [576];
  double det384z [384];
  double det384y [384];
  double det384x [384];
  double ddet [288];
  double cdet [288];
  double bdet [288];
  double adet [288];
  double temp192 [192];
  double xydet [192];
  double eabc [96];
  double deab [96];
  double cdea [96];
  double bcde [96];
  double abcd [96];
  double zdet [96];
  double ydet [96];
  double xdet [96];
  double temp48b [48];
  double temp48a [48];
  double temp48 [48];
  double eac [24];
  double deb [24];
  double cda [24];
  double bce [24];
  double abd [24];
  double eab [24];
  double dea [24];
  double cde [24];
  double bcd [24];
  double abc [24];
  double temp24 [24];
  double temp16_1 [16];
  double temp16 [16];
  double temp8b_1 [8];
  double temp8a_1 [8];
  double temp8c [8];
  double temp8b [8];
  double temp8a [8];
  double eb [4];
  double da_1 [4];
  double ce [4];
  double bd_1 [4];
  double ac_1 [4];
  double ea [4];
  double de [4];
  double cd_1 [4];
  double bc_1 [4];
  double ab_1 [4];
  double bd [4];
  double ac [4];
  double da [4];
  double cd [4];
  double bc [4];
  double ab [4];
  
  dVar1 = *pe;
  dVar16 = *pa - dVar1;
  dVar17 = *pb - dVar1;
  dVar18 = *pc - dVar1;
  dVar1 = *pd - dVar1;
  dVar2 = pe[1];
  dVar19 = pa[1] - dVar2;
  dVar20 = pb[1] - dVar2;
  dVar21 = pc[1] - dVar2;
  dVar2 = pd[1] - dVar2;
  dVar3 = pe[2];
  dVar22 = pa[2] - dVar3;
  dVar23 = pb[2] - dVar3;
  dVar24 = pc[2] - dVar3;
  dVar3 = pd[2] - dVar3;
  dVar25 = dVar16 * dVar20;
  dVar32 = dVar16 * splitter - (dVar16 * splitter - dVar16);
  dVar33 = dVar16 - dVar32;
  dVar8 = dVar20 * splitter - (dVar20 * splitter - dVar20);
  dVar7 = dVar20 - dVar8;
  dVar26 = dVar33 * dVar7 - (((dVar25 - dVar32 * dVar8) - dVar33 * dVar8) - dVar32 * dVar7);
  dVar5 = dVar17 * dVar19;
  dVar30 = dVar17 * splitter - (dVar17 * splitter - dVar17);
  dVar31 = dVar17 - dVar30;
  dVar28 = dVar19 * splitter - (dVar19 * splitter - dVar19);
  dVar29 = dVar19 - dVar28;
  dVar4 = dVar31 * dVar29 - (((dVar5 - dVar30 * dVar28) - dVar31 * dVar28) - dVar30 * dVar29);
  dVar6 = dVar26 - dVar4;
  ab[0] = (dVar26 - (dVar6 + (dVar26 - dVar6))) + ((dVar26 - dVar6) - dVar4);
  dVar4 = dVar25 + dVar6;
  dVar25 = (dVar25 - (dVar4 - (dVar4 - dVar25))) + (dVar6 - (dVar4 - dVar25));
  dVar26 = dVar25 - dVar5;
  ab[1] = (dVar25 - (dVar26 + (dVar25 - dVar26))) + ((dVar25 - dVar26) - dVar5);
  dVar45 = dVar4 + dVar26;
  ab[2] = (dVar4 - (dVar45 - (dVar45 - dVar4))) + (dVar26 - (dVar45 - dVar4));
  dVar5 = dVar17 * dVar21;
  dVar27 = dVar21 * splitter - (dVar21 * splitter - dVar21);
  dVar15 = dVar21 - dVar27;
  dVar26 = dVar31 * dVar15 - (((dVar5 - dVar30 * dVar27) - dVar31 * dVar27) - dVar30 * dVar15);
  dVar6 = dVar18 * dVar20;
  dVar13 = dVar18 * splitter - (dVar18 * splitter - dVar18);
  dVar14 = dVar18 - dVar13;
  dVar25 = dVar14 * dVar7 - (((dVar6 - dVar13 * dVar8) - dVar14 * dVar8) - dVar13 * dVar7);
  dVar4 = dVar26 - dVar25;
  bc[0] = (dVar26 - (dVar4 + (dVar26 - dVar4))) + ((dVar26 - dVar4) - dVar25);
  dVar25 = dVar5 + dVar4;
  dVar4 = (dVar5 - (dVar25 - (dVar25 - dVar5))) + (dVar4 - (dVar25 - dVar5));
  dVar26 = dVar4 - dVar6;
  bc[1] = (dVar4 - (dVar26 + (dVar4 - dVar26))) + ((dVar4 - dVar26) - dVar6);
  dVar44 = dVar25 + dVar26;
  bc[2] = (dVar25 - (dVar44 - (dVar44 - dVar25))) + (dVar26 - (dVar44 - dVar25));
  dVar6 = dVar18 * dVar2;
  dVar11 = dVar2 * splitter - (dVar2 * splitter - dVar2);
  dVar12 = dVar2 - dVar11;
  dVar25 = dVar14 * dVar12 - (((dVar6 - dVar13 * dVar11) - dVar14 * dVar11) - dVar13 * dVar12);
  dVar5 = dVar1 * dVar21;
  dVar9 = splitter * dVar1 - (splitter * dVar1 - dVar1);
  dVar10 = dVar1 - dVar9;
  dVar26 = dVar15 * dVar10 - (((dVar5 - dVar27 * dVar9) - dVar10 * dVar27) - dVar15 * dVar9);
  dVar4 = dVar25 - dVar26;
  cd[0] = ((dVar25 - dVar4) - dVar26) + (dVar25 - ((dVar25 - dVar4) + dVar4));
  dVar26 = dVar6 + dVar4;
  dVar4 = (dVar6 - (dVar26 - (dVar26 - dVar6))) + (dVar4 - (dVar26 - dVar6));
  dVar25 = dVar4 - dVar5;
  cd[1] = (dVar4 - (dVar25 + (dVar4 - dVar25))) + ((dVar4 - dVar25) - dVar5);
  dVar43 = dVar26 + dVar25;
  cd[2] = (dVar25 - (dVar43 - dVar26)) + (dVar26 - (dVar43 - (dVar43 - dVar26)));
  dVar5 = dVar1 * dVar19;
  dVar6 = dVar10 * dVar29 - (((dVar5 - dVar28 * dVar9) - dVar10 * dVar28) - dVar29 * dVar9);
  dVar26 = dVar16 * dVar2;
  dVar25 = dVar33 * dVar12 - (((dVar26 - dVar32 * dVar11) - dVar33 * dVar11) - dVar32 * dVar12);
  dVar4 = dVar6 - dVar25;
  da[0] = ((dVar6 - dVar4) - dVar25) + (dVar6 - ((dVar6 - dVar4) + dVar4));
  dVar25 = dVar5 + dVar4;
  dVar5 = (dVar5 - (dVar25 - (dVar25 - dVar5))) + (dVar4 - (dVar25 - dVar5));
  dVar4 = dVar5 - dVar26;
  da[1] = (dVar5 - (dVar4 + (dVar5 - dVar4))) + ((dVar5 - dVar4) - dVar26);
  dVar42 = dVar25 + dVar4;
  da[2] = (dVar4 - (dVar42 - dVar25)) + (dVar25 - (dVar42 - (dVar42 - dVar25)));
  dVar25 = dVar16 * dVar21;
  dVar26 = dVar33 * dVar15 - (((dVar25 - dVar32 * dVar27) - dVar33 * dVar27) - dVar32 * dVar15);
  dVar5 = dVar18 * dVar19;
  dVar4 = dVar14 * dVar29 - (((dVar5 - dVar13 * dVar28) - dVar14 * dVar28) - dVar13 * dVar29);
  dVar6 = dVar26 - dVar4;
  ac[0] = ((dVar26 - dVar6) - dVar4) + (dVar26 - ((dVar26 - dVar6) + dVar6));
  dVar26 = dVar25 + dVar6;
  dVar25 = (dVar25 - (dVar26 - (dVar26 - dVar25))) + (dVar6 - (dVar26 - dVar25));
  dVar4 = dVar25 - dVar5;
  ac[1] = (dVar25 - (dVar4 + (dVar25 - dVar4))) + ((dVar25 - dVar4) - dVar5);
  dVar25 = dVar26 + dVar4;
  ac[2] = (dVar4 - (dVar25 - dVar26)) + (dVar26 - (dVar25 - (dVar25 - dVar26)));
  dVar6 = dVar17 * dVar2;
  dVar5 = dVar31 * dVar12 - (((dVar6 - dVar30 * dVar11) - dVar11 * dVar31) - dVar30 * dVar12);
  dVar11 = dVar1 * dVar20;
  dVar4 = dVar10 * dVar7 - (((dVar11 - dVar8 * dVar9) - dVar10 * dVar8) - dVar9 * dVar7);
  dVar26 = dVar5 - dVar4;
  bd[0] = (dVar5 - (dVar26 + (dVar5 - dVar26))) + ((dVar5 - dVar26) - dVar4);
  dVar4 = dVar6 + dVar26;
  dVar26 = (dVar6 - (dVar4 - (dVar4 - dVar6))) + (dVar26 - (dVar4 - dVar6));
  dVar5 = dVar26 - dVar11;
  bd[1] = (dVar26 - (dVar5 + (dVar26 - dVar5))) + ((dVar26 - dVar5) - dVar11);
  dVar26 = dVar4 + dVar5;
  bd[2] = (dVar4 - (dVar26 - (dVar26 - dVar4))) + (dVar5 - (dVar26 - dVar4));
  bd[3] = dVar26;
  ac[3] = dVar25;
  da[3] = dVar42;
  cd[3] = dVar43;
  bc[3] = dVar44;
  ab[3] = dVar45;
  iVar49 = scale_expansion_zeroelim(4,cd,dVar23,temp8a);
  iVar50 = scale_expansion_zeroelim(4,bd,-dVar24,temp8b);
  iVar51 = scale_expansion_zeroelim(4,bc,dVar3,temp8c);
  iVar49 = fast_expansion_sum_zeroelim(iVar49,temp8a,iVar50,temp8b,temp16);
  iVar49 = fast_expansion_sum_zeroelim(iVar51,temp8c,iVar49,temp16,temp24);
  iVar50 = scale_expansion_zeroelim(iVar49,temp24,dVar16,temp48);
  iVar50 = scale_expansion_zeroelim(iVar50,temp48,-dVar16,xdet);
  iVar51 = scale_expansion_zeroelim(iVar49,temp24,dVar19,temp48);
  iVar51 = scale_expansion_zeroelim(iVar51,temp48,-dVar19,ydet);
  iVar49 = scale_expansion_zeroelim(iVar49,temp24,dVar22,temp48);
  iVar49 = scale_expansion_zeroelim(iVar49,temp48,-dVar22,zdet);
  iVar50 = fast_expansion_sum_zeroelim(iVar50,xdet,iVar51,ydet,xydet);
  iVar49 = fast_expansion_sum_zeroelim(iVar50,xydet,iVar49,zdet,adet);
  iVar50 = scale_expansion_zeroelim(4,da,dVar24,temp8a);
  iVar51 = scale_expansion_zeroelim(4,ac,dVar3,temp8b);
  iVar52 = scale_expansion_zeroelim(4,cd,dVar22,temp8c);
  iVar50 = fast_expansion_sum_zeroelim(iVar50,temp8a,iVar51,temp8b,temp16);
  iVar50 = fast_expansion_sum_zeroelim(iVar52,temp8c,iVar50,temp16,temp24);
  iVar51 = scale_expansion_zeroelim(iVar50,temp24,dVar17,temp48);
  iVar51 = scale_expansion_zeroelim(iVar51,temp48,dVar17,xdet);
  iVar52 = scale_expansion_zeroelim(iVar50,temp24,dVar20,temp48);
  iVar52 = scale_expansion_zeroelim(iVar52,temp48,dVar20,ydet);
  iVar50 = scale_expansion_zeroelim(iVar50,temp24,dVar23,temp48);
  iVar50 = scale_expansion_zeroelim(iVar50,temp48,dVar23,zdet);
  iVar51 = fast_expansion_sum_zeroelim(iVar51,xdet,iVar52,ydet,xydet);
  iVar50 = fast_expansion_sum_zeroelim(iVar51,xydet,iVar50,zdet,bdet);
  iVar51 = scale_expansion_zeroelim(4,ab,dVar3,temp8a);
  iVar52 = scale_expansion_zeroelim(4,bd,dVar22,temp8b);
  iVar53 = scale_expansion_zeroelim(4,da,dVar23,temp8c);
  iVar51 = fast_expansion_sum_zeroelim(iVar51,temp8a,iVar52,temp8b,temp16);
  iVar51 = fast_expansion_sum_zeroelim(iVar53,temp8c,iVar51,temp16,temp24);
  iVar52 = scale_expansion_zeroelim(iVar51,temp24,dVar18,temp48);
  iVar52 = scale_expansion_zeroelim(iVar52,temp48,-dVar18,xdet);
  iVar53 = scale_expansion_zeroelim(iVar51,temp24,dVar21,temp48);
  iVar53 = scale_expansion_zeroelim(iVar53,temp48,-dVar21,ydet);
  iVar51 = scale_expansion_zeroelim(iVar51,temp24,dVar24,temp48);
  iVar51 = scale_expansion_zeroelim(iVar51,temp48,-dVar24,zdet);
  iVar52 = fast_expansion_sum_zeroelim(iVar52,xdet,iVar53,ydet,xydet);
  iVar51 = fast_expansion_sum_zeroelim(iVar52,xydet,iVar51,zdet,cdet);
  iVar52 = scale_expansion_zeroelim(4,bc,dVar22,temp8a);
  iVar53 = scale_expansion_zeroelim(4,ac,-dVar23,temp8b);
  iVar54 = scale_expansion_zeroelim(4,ab,dVar24,temp8c);
  iVar52 = fast_expansion_sum_zeroelim(iVar52,temp8a,iVar53,temp8b,temp16);
  iVar52 = fast_expansion_sum_zeroelim(iVar54,temp8c,iVar52,temp16,temp24);
  iVar53 = scale_expansion_zeroelim(iVar52,temp24,dVar1,temp48);
  iVar53 = scale_expansion_zeroelim(iVar53,temp48,dVar1,xdet);
  iVar54 = scale_expansion_zeroelim(iVar52,temp24,dVar2,temp48);
  iVar54 = scale_expansion_zeroelim(iVar54,temp48,dVar2,ydet);
  iVar52 = scale_expansion_zeroelim(iVar52,temp24,dVar3,temp48);
  iVar52 = scale_expansion_zeroelim(iVar52,temp48,dVar3,zdet);
  iVar53 = fast_expansion_sum_zeroelim(iVar53,xdet,iVar54,ydet,xydet);
  iVar52 = fast_expansion_sum_zeroelim(iVar53,xydet,iVar52,zdet,ddet);
  iVar49 = fast_expansion_sum_zeroelim(iVar49,adet,iVar50,bdet,abdet);
  iVar50 = fast_expansion_sum_zeroelim(iVar51,cdet,iVar52,ddet,cddet);
  iVar49 = fast_expansion_sum_zeroelim(iVar49,abdet,iVar50,cddet,fin1);
  if (1 < iVar49) {
    eindex = 1;
    do {
      fin1[0] = fin1[0] + fin1[eindex];
      eindex = eindex + 1;
    } while (eindex != iVar49);
  }
  if ((fin1[0] < permanent * isperrboundB) && (-fin1[0] < permanent * isperrboundB)) {
    dVar4 = *pa;
    dVar5 = *pe;
    dVar27 = ((dVar4 - dVar16) - dVar5) + (dVar4 - (dVar16 + (dVar4 - dVar16)));
    dVar6 = pa[1];
    dVar7 = pe[1];
    dVar28 = ((dVar6 - dVar19) - dVar7) + (dVar6 - (dVar19 + (dVar6 - dVar19)));
    dVar8 = pa[2];
    dVar9 = pe[2];
    dVar29 = ((dVar8 - dVar22) - dVar9) + (dVar8 - (dVar22 + (dVar8 - dVar22)));
    dVar10 = *pb;
    dVar33 = ((dVar10 - dVar17) - dVar5) + (dVar10 - (dVar17 + (dVar10 - dVar17)));
    dVar11 = pb[1];
    dVar34 = ((dVar11 - dVar20) - dVar7) + (dVar11 - (dVar20 + (dVar11 - dVar20)));
    dVar12 = pb[2] - dVar23;
    dVar32 = (dVar12 - dVar9) + (pb[2] - (dVar23 + dVar12));
    dVar12 = *pc;
    dVar35 = ((dVar12 - dVar18) - dVar5) + (dVar12 - (dVar18 + (dVar12 - dVar18)));
    dVar13 = pc[1];
    dVar36 = ((dVar13 - dVar21) - dVar7) + (dVar13 - (dVar21 + (dVar13 - dVar21)));
    dVar14 = pc[2] - dVar24;
    dVar31 = (dVar14 - dVar9) + (pc[2] - (dVar24 + dVar14));
    dVar14 = *pd;
    dVar37 = ((dVar14 - dVar1) - dVar5) + (dVar14 - (dVar1 + (dVar14 - dVar1)));
    dVar15 = pd[1];
    dVar38 = ((dVar15 - dVar2) - dVar7) + (dVar15 - (dVar2 + (dVar15 - dVar2)));
    dVar30 = pd[2] - dVar3;
    dVar9 = (pd[2] - (dVar3 + dVar30)) + (dVar30 - dVar9);
    if ((((dVar27 != 0.0) ||
         ((((dVar28 != 0.0 || (dVar29 != 0.0)) || (dVar33 != 0.0)) ||
          ((dVar34 != 0.0 || (dVar32 != 0.0)))))) || (dVar35 != 0.0)) ||
       (((dVar36 != 0.0 || (dVar31 != 0.0)) ||
        ((dVar37 != 0.0 || ((dVar38 != 0.0 || (dVar9 != 0.0)))))))) {
      dVar30 = -fin1[0];
      if (0.0 <= fin1[0]) {
        dVar30 = fin1[0];
      }
      dVar46 = dVar30 * resulterrbound + permanent * isperrboundC;
      dVar30 = (dVar20 * dVar27 + dVar16 * dVar34) - (dVar17 * dVar28 + dVar19 * dVar33);
      dVar39 = (dVar21 * dVar33 + dVar17 * dVar36) - (dVar18 * dVar34 + dVar20 * dVar35);
      dVar47 = (dVar2 * dVar35 + dVar18 * dVar38) - (dVar1 * dVar36 + dVar21 * dVar37);
      dVar40 = (dVar19 * dVar37 + dVar1 * dVar28) - (dVar16 * dVar38 + dVar2 * dVar27);
      dVar48 = (dVar21 * dVar27 + dVar16 * dVar36) - (dVar18 * dVar28 + dVar19 * dVar35);
      dVar41 = (dVar2 * dVar33 + dVar17 * dVar38) - (dVar1 * dVar34 + dVar20 * dVar37);
      dVar27 = ((dVar24 * dVar45 + (dVar22 * dVar44 - dVar23 * dVar25)) *
                (dVar3 * dVar9 + dVar2 * dVar38 + dVar1 * dVar37) +
               (dVar22 * dVar43 + dVar3 * dVar25 + dVar24 * dVar42) *
               (dVar23 * dVar32 + dVar20 * dVar34 + dVar17 * dVar33)) -
               ((dVar3 * dVar44 + (dVar23 * dVar43 - dVar24 * dVar26)) *
                (dVar22 * dVar29 + dVar19 * dVar28 + dVar16 * dVar27) +
               (dVar24 * dVar31 + dVar21 * dVar36 + dVar18 * dVar35) *
               (dVar23 * dVar42 + dVar26 * dVar22 + dVar3 * dVar45));
      fin1[0] = fin1[0] + dVar27 + dVar27 +
                          (((dVar29 * dVar43 + dVar9 * dVar25 + dVar31 * dVar42 +
                            dVar22 * dVar47 + dVar3 * dVar48 + dVar24 * dVar40) *
                            (dVar23 * dVar23 + dVar20 * dVar20 + dVar17 * dVar17) +
                           (dVar3 * dVar3 + dVar2 * dVar2 + dVar1 * dVar1) *
                           (dVar31 * dVar45 + (dVar29 * dVar44 - dVar32 * dVar25) +
                           dVar24 * dVar30 + (dVar22 * dVar39 - dVar48 * dVar23))) -
                          ((dVar32 * dVar42 + dVar29 * dVar26 + dVar9 * dVar45 +
                           dVar23 * dVar40 + dVar22 * dVar41 + dVar3 * dVar30) *
                           (dVar24 * dVar24 + dVar21 * dVar21 + dVar18 * dVar18) +
                          (dVar9 * dVar44 + (dVar32 * dVar43 - dVar31 * dVar26) +
                          dVar3 * dVar39 + (dVar47 * dVar23 - dVar24 * dVar41)) *
                          (dVar22 * dVar22 + dVar19 * dVar19 + dVar16 * dVar16)));
      if ((fin1[0] < dVar46) && (-fin1[0] < dVar46)) {
        dVar1 = dVar4 * dVar11;
        dVar32 = dVar4 * splitter - (dVar4 * splitter - dVar4);
        dVar33 = dVar4 - dVar32;
        dVar19 = dVar11 * splitter - (dVar11 * splitter - dVar11);
        dVar18 = dVar11 - dVar19;
        dVar3 = dVar33 * dVar18 - (((dVar1 - dVar32 * dVar19) - dVar33 * dVar19) - dVar32 * dVar18);
        dVar16 = dVar6 * dVar10;
        dVar30 = dVar10 * splitter - (dVar10 * splitter - dVar10);
        dVar31 = dVar10 - dVar30;
        dVar28 = dVar6 * splitter - (dVar6 * splitter - dVar6);
        dVar29 = dVar6 - dVar28;
        dVar2 = dVar31 * dVar29 - (((dVar16 - dVar30 * dVar28) - dVar31 * dVar28) - dVar30 * dVar29)
        ;
        dVar17 = dVar3 - dVar2;
        ab_1[0] = ((dVar3 - dVar17) - dVar2) + (dVar3 - ((dVar3 - dVar17) + dVar17));
        dVar2 = dVar1 + dVar17;
        dVar1 = (dVar17 - (dVar2 - dVar1)) + (dVar1 - (dVar2 - (dVar2 - dVar1)));
        dVar3 = dVar1 - dVar16;
        ab_1[1] = ((dVar1 - dVar3) - dVar16) + (dVar1 - ((dVar1 - dVar3) + dVar3));
        ab_1[3] = dVar2 + dVar3;
        ab_1[2] = (dVar2 - (ab_1[3] - (ab_1[3] - dVar2))) + (dVar3 - (ab_1[3] - dVar2));
        dVar3 = dVar10 * dVar13;
        dVar27 = dVar13 * splitter - (dVar13 * splitter - dVar13);
        dVar44 = dVar13 - dVar27;
        dVar16 = dVar31 * dVar44 - (((dVar3 - dVar30 * dVar27) - dVar31 * dVar27) - dVar30 * dVar44)
        ;
        dVar17 = dVar12 * dVar11;
        dVar42 = dVar12 * splitter - (dVar12 * splitter - dVar12);
        dVar43 = dVar12 - dVar42;
        dVar1 = dVar43 * dVar18 - (((dVar17 - dVar42 * dVar19) - dVar43 * dVar19) - dVar42 * dVar18)
        ;
        dVar2 = dVar16 - dVar1;
        bc_1[0] = ((dVar16 - dVar2) - dVar1) + (dVar16 - ((dVar16 - dVar2) + dVar2));
        dVar1 = dVar3 + dVar2;
        dVar3 = (dVar2 - (dVar1 - dVar3)) + (dVar3 - (dVar1 - (dVar1 - dVar3)));
        dVar2 = dVar3 - dVar17;
        bc_1[1] = ((dVar3 - dVar2) - dVar17) + (dVar3 - ((dVar3 - dVar2) + dVar2));
        bc_1[3] = dVar1 + dVar2;
        bc_1[2] = (dVar1 - (bc_1[3] - (bc_1[3] - dVar1))) + (dVar2 - (bc_1[3] - dVar1));
        dVar3 = dVar12 * dVar15;
        dVar9 = dVar15 * splitter - (dVar15 * splitter - dVar15);
        dVar26 = dVar15 - dVar9;
        dVar16 = dVar43 * dVar26 - (((dVar3 - dVar42 * dVar9) - dVar43 * dVar9) - dVar42 * dVar26);
        dVar17 = dVar14 * dVar13;
        dVar24 = dVar14 * splitter - (dVar14 * splitter - dVar14);
        dVar25 = dVar14 - dVar24;
        dVar1 = dVar25 * dVar44 - (((dVar17 - dVar24 * dVar27) - dVar25 * dVar27) - dVar24 * dVar44)
        ;
        dVar2 = dVar16 - dVar1;
        cd_1[0] = ((dVar16 - dVar2) - dVar1) + (dVar16 - ((dVar16 - dVar2) + dVar2));
        dVar1 = dVar3 + dVar2;
        dVar3 = (dVar2 - (dVar1 - dVar3)) + (dVar3 - (dVar1 - (dVar1 - dVar3)));
        dVar2 = dVar3 - dVar17;
        cd_1[1] = ((dVar3 - dVar2) - dVar17) + (dVar3 - ((dVar3 - dVar2) + dVar2));
        cd_1[3] = dVar1 + dVar2;
        cd_1[2] = (dVar1 - (cd_1[3] - (cd_1[3] - dVar1))) + (dVar2 - (cd_1[3] - dVar1));
        dVar17 = dVar14 * dVar7;
        dVar22 = dVar7 * splitter - (dVar7 * splitter - dVar7);
        dVar23 = dVar7 - dVar22;
        dVar1 = dVar25 * dVar23 - (((dVar17 - dVar24 * dVar22) - dVar25 * dVar22) - dVar24 * dVar23)
        ;
        dVar16 = dVar5 * dVar15;
        dVar20 = splitter * dVar5 - (splitter * dVar5 - dVar5);
        dVar21 = dVar5 - dVar20;
        dVar3 = dVar26 * dVar21 - (((dVar16 - dVar9 * dVar20) - dVar21 * dVar9) - dVar26 * dVar20);
        dVar2 = dVar1 - dVar3;
        de[0] = ((dVar1 - dVar2) - dVar3) + (dVar1 - ((dVar1 - dVar2) + dVar2));
        dVar3 = dVar17 + dVar2;
        dVar2 = (dVar2 - (dVar3 - dVar17)) + (dVar17 - (dVar3 - (dVar3 - dVar17)));
        dVar1 = dVar2 - dVar16;
        de[1] = ((dVar2 - dVar1) - dVar16) + (dVar2 - ((dVar2 - dVar1) + dVar1));
        de[3] = dVar3 + dVar1;
        de[2] = (dVar3 - (de[3] - (de[3] - dVar3))) + (dVar1 - (de[3] - dVar3));
        dVar16 = dVar5 * dVar6;
        dVar17 = dVar21 * dVar29 -
                 (((dVar16 - dVar28 * dVar20) - dVar21 * dVar28) - dVar29 * dVar20);
        dVar3 = dVar4 * dVar7;
        dVar1 = dVar33 * dVar23 - (((dVar3 - dVar32 * dVar22) - dVar33 * dVar22) - dVar32 * dVar23);
        dVar2 = dVar17 - dVar1;
        ea[0] = ((dVar17 - dVar2) - dVar1) + (dVar17 - ((dVar17 - dVar2) + dVar2));
        dVar1 = dVar16 + dVar2;
        dVar16 = (dVar2 - (dVar1 - dVar16)) + (dVar16 - (dVar1 - (dVar1 - dVar16)));
        dVar2 = dVar16 - dVar3;
        ea[1] = ((dVar16 - dVar2) - dVar3) + (dVar16 - ((dVar16 - dVar2) + dVar2));
        ea[3] = dVar1 + dVar2;
        ea[2] = (dVar1 - (ea[3] - (ea[3] - dVar1))) + (dVar2 - (ea[3] - dVar1));
        dVar1 = dVar4 * dVar13;
        dVar3 = dVar33 * dVar44 - (((dVar1 - dVar32 * dVar27) - dVar33 * dVar27) - dVar32 * dVar44);
        dVar16 = dVar12 * dVar6;
        dVar2 = dVar43 * dVar29 - (((dVar16 - dVar42 * dVar28) - dVar43 * dVar28) - dVar42 * dVar29)
        ;
        dVar17 = dVar3 - dVar2;
        ac_1[0] = ((dVar3 - dVar17) - dVar2) + (dVar3 - ((dVar3 - dVar17) + dVar17));
        dVar3 = dVar1 + dVar17;
        dVar1 = (dVar17 - (dVar3 - dVar1)) + (dVar1 - (dVar3 - (dVar3 - dVar1)));
        dVar2 = dVar1 - dVar16;
        ac_1[1] = ((dVar1 - dVar2) - dVar16) + (dVar1 - ((dVar1 - dVar2) + dVar2));
        ac_1[3] = dVar3 + dVar2;
        ac_1[2] = (dVar3 - (ac_1[3] - (ac_1[3] - dVar3))) + (dVar2 - (ac_1[3] - dVar3));
        dVar1 = dVar10 * dVar15;
        dVar3 = dVar31 * dVar26 - (((dVar1 - dVar30 * dVar9) - dVar31 * dVar9) - dVar30 * dVar26);
        dVar16 = dVar14 * dVar11;
        dVar2 = dVar25 * dVar18 - (((dVar16 - dVar24 * dVar19) - dVar25 * dVar19) - dVar24 * dVar18)
        ;
        dVar17 = dVar3 - dVar2;
        bd_1[0] = ((dVar3 - dVar17) - dVar2) + (dVar3 - ((dVar3 - dVar17) + dVar17));
        dVar3 = dVar1 + dVar17;
        dVar1 = (dVar17 - (dVar3 - dVar1)) + (dVar1 - (dVar3 - (dVar3 - dVar1)));
        dVar2 = dVar1 - dVar16;
        bd_1[1] = ((dVar1 - dVar2) - dVar16) + (dVar1 - ((dVar1 - dVar2) + dVar2));
        bd_1[3] = dVar3 + dVar2;
        bd_1[2] = (dVar3 - (bd_1[3] - (bd_1[3] - dVar3))) + (dVar2 - (bd_1[3] - dVar3));
        dVar12 = dVar12 * dVar7;
        dVar1 = dVar43 * dVar23 - (((dVar12 - dVar42 * dVar22) - dVar43 * dVar22) - dVar42 * dVar23)
        ;
        dVar13 = dVar5 * dVar13;
        dVar3 = dVar21 * dVar44 - (((dVar13 - dVar27 * dVar20) - dVar21 * dVar27) - dVar44 * dVar20)
        ;
        dVar2 = dVar1 - dVar3;
        ce[0] = ((dVar1 - dVar2) - dVar3) + (dVar1 - ((dVar1 - dVar2) + dVar2));
        dVar3 = dVar12 + dVar2;
        dVar2 = (dVar2 - (dVar3 - dVar12)) + (dVar12 - (dVar3 - (dVar3 - dVar12)));
        dVar1 = dVar2 - dVar13;
        ce[1] = ((dVar2 - dVar1) - dVar13) + (dVar2 - ((dVar2 - dVar1) + dVar1));
        ce[3] = dVar3 + dVar1;
        ce[2] = (dVar3 - (ce[3] - (ce[3] - dVar3))) + (dVar1 - (ce[3] - dVar3));
        dVar14 = dVar14 * dVar6;
        dVar2 = dVar25 * dVar29 - (((dVar14 - dVar24 * dVar28) - dVar25 * dVar28) - dVar24 * dVar29)
        ;
        dVar4 = dVar4 * dVar15;
        dVar1 = dVar33 * dVar26 - (((dVar4 - dVar32 * dVar9) - dVar33 * dVar9) - dVar32 * dVar26);
        dVar16 = dVar2 - dVar1;
        da_1[0] = ((dVar2 - dVar16) - dVar1) + (dVar2 - ((dVar2 - dVar16) + dVar16));
        dVar3 = dVar14 + dVar16;
        dVar1 = (dVar16 - (dVar3 - dVar14)) + (dVar14 - (dVar3 - (dVar3 - dVar14)));
        dVar2 = dVar1 - dVar4;
        da_1[1] = ((dVar1 - dVar2) - dVar4) + (dVar1 - ((dVar1 - dVar2) + dVar2));
        da_1[3] = dVar3 + dVar2;
        da_1[2] = (dVar3 - (da_1[3] - (da_1[3] - dVar3))) + (dVar2 - (da_1[3] - dVar3));
        dVar5 = dVar5 * dVar11;
        dVar1 = dVar21 * dVar18 - (((dVar5 - dVar19 * dVar20) - dVar21 * dVar19) - dVar20 * dVar18);
        dVar10 = dVar10 * dVar7;
        dVar3 = dVar31 * dVar23 - (((dVar10 - dVar30 * dVar22) - dVar22 * dVar31) - dVar30 * dVar23)
        ;
        dVar2 = dVar1 - dVar3;
        eb[0] = ((dVar1 - dVar2) - dVar3) + (dVar1 - ((dVar1 - dVar2) + dVar2));
        dVar3 = dVar5 + dVar2;
        dVar2 = (dVar2 - (dVar3 - dVar5)) + (dVar5 - (dVar3 - (dVar3 - dVar5)));
        dVar1 = dVar2 - dVar10;
        eb[1] = ((dVar2 - dVar1) - dVar10) + (dVar2 - ((dVar2 - dVar1) + dVar1));
        eb[3] = dVar3 + dVar1;
        eb[2] = (dVar1 - (eb[3] - dVar3)) + (dVar3 - (eb[3] - (eb[3] - dVar3)));
        iVar49 = scale_expansion_zeroelim(4,bc_1,dVar8,temp8a_1);
        iVar50 = scale_expansion_zeroelim(4,ac_1,-pb[2],temp8b_1);
        iVar49 = fast_expansion_sum_zeroelim(iVar49,temp8a_1,iVar50,temp8b_1,temp16_1);
        iVar50 = scale_expansion_zeroelim(4,ab_1,pc[2],temp8a_1);
        iVar49 = fast_expansion_sum_zeroelim(iVar50,temp8a_1,iVar49,temp16_1,abc);
        iVar50 = scale_expansion_zeroelim(4,cd_1,pb[2],temp8a_1);
        iVar51 = scale_expansion_zeroelim(4,bd_1,-pc[2],temp8b_1);
        iVar50 = fast_expansion_sum_zeroelim(iVar50,temp8a_1,iVar51,temp8b_1,temp16_1);
        iVar51 = scale_expansion_zeroelim(4,bc_1,pd[2],temp8a_1);
        iVar50 = fast_expansion_sum_zeroelim(iVar51,temp8a_1,iVar50,temp16_1,bcd);
        iVar51 = scale_expansion_zeroelim(4,de,pc[2],temp8a_1);
        iVar52 = scale_expansion_zeroelim(4,ce,-pd[2],temp8b_1);
        iVar51 = fast_expansion_sum_zeroelim(iVar51,temp8a_1,iVar52,temp8b_1,temp16_1);
        iVar52 = scale_expansion_zeroelim(4,cd_1,pe[2],temp8a_1);
        iVar51 = fast_expansion_sum_zeroelim(iVar52,temp8a_1,iVar51,temp16_1,cde);
        iVar52 = scale_expansion_zeroelim(4,ea,pd[2],temp8a_1);
        iVar53 = scale_expansion_zeroelim(4,da_1,-pe[2],temp8b_1);
        iVar52 = fast_expansion_sum_zeroelim(iVar52,temp8a_1,iVar53,temp8b_1,temp16_1);
        iVar53 = scale_expansion_zeroelim(4,de,pa[2],temp8a_1);
        iVar52 = fast_expansion_sum_zeroelim(iVar53,temp8a_1,iVar52,temp16_1,dea);
        iVar53 = scale_expansion_zeroelim(4,ab_1,pe[2],temp8a_1);
        iVar54 = scale_expansion_zeroelim(4,eb,-pa[2],temp8b_1);
        iVar53 = fast_expansion_sum_zeroelim(iVar53,temp8a_1,iVar54,temp8b_1,temp16_1);
        iVar54 = scale_expansion_zeroelim(4,ea,pb[2],temp8a_1);
        iVar53 = fast_expansion_sum_zeroelim(iVar54,temp8a_1,iVar53,temp16_1,eab);
        iVar54 = scale_expansion_zeroelim(4,bd_1,pa[2],temp8a_1);
        iVar55 = scale_expansion_zeroelim(4,da_1,pb[2],temp8b_1);
        iVar54 = fast_expansion_sum_zeroelim(iVar54,temp8a_1,iVar55,temp8b_1,temp16_1);
        iVar55 = scale_expansion_zeroelim(4,ab_1,pd[2],temp8a_1);
        iVar54 = fast_expansion_sum_zeroelim(iVar55,temp8a_1,iVar54,temp16_1,abd);
        iVar55 = scale_expansion_zeroelim(4,ce,pb[2],temp8a_1);
        iVar56 = scale_expansion_zeroelim(4,eb,pc[2],temp8b_1);
        iVar55 = fast_expansion_sum_zeroelim(iVar55,temp8a_1,iVar56,temp8b_1,temp16_1);
        iVar56 = scale_expansion_zeroelim(4,bc_1,pe[2],temp8a_1);
        iVar55 = fast_expansion_sum_zeroelim(iVar56,temp8a_1,iVar55,temp16_1,bce);
        iVar56 = scale_expansion_zeroelim(4,da_1,pc[2],temp8a_1);
        iVar57 = scale_expansion_zeroelim(4,ac_1,pd[2],temp8b_1);
        iVar56 = fast_expansion_sum_zeroelim(iVar56,temp8a_1,iVar57,temp8b_1,temp16_1);
        iVar57 = scale_expansion_zeroelim(4,cd_1,pa[2],temp8a_1);
        iVar56 = fast_expansion_sum_zeroelim(iVar57,temp8a_1,iVar56,temp16_1,cda);
        iVar57 = scale_expansion_zeroelim(4,eb,pd[2],temp8a_1);
        iVar58 = scale_expansion_zeroelim(4,bd_1,pe[2],temp8b_1);
        iVar57 = fast_expansion_sum_zeroelim(iVar57,temp8a_1,iVar58,temp8b_1,temp16_1);
        iVar58 = scale_expansion_zeroelim(4,de,pb[2],temp8a_1);
        iVar57 = fast_expansion_sum_zeroelim(iVar58,temp8a_1,iVar57,temp16_1,deb);
        iVar58 = scale_expansion_zeroelim(4,ac_1,pe[2],temp8a_1);
        iVar59 = scale_expansion_zeroelim(4,ce,pa[2],temp8b_1);
        iVar58 = fast_expansion_sum_zeroelim(iVar58,temp8a_1,iVar59,temp8b_1,temp16_1);
        iVar59 = scale_expansion_zeroelim(4,ea,pc[2],temp8a_1);
        iVar58 = fast_expansion_sum_zeroelim(iVar59,temp8a_1,iVar58,temp16_1,eac);
        iVar59 = fast_expansion_sum_zeroelim(iVar51,cde,iVar55,bce,temp48a);
        iVar60 = fast_expansion_sum_zeroelim(iVar57,deb,iVar50,bcd,temp48b);
        if (0 < iVar60) {
          i = 0;
          do {
            temp48b[i] = -temp48b[i];
            i = i + 1;
          } while (i != iVar60);
        }
        iVar59 = fast_expansion_sum_zeroelim(iVar59,temp48a,iVar60,temp48b,bcde);
        iVar60 = scale_expansion_zeroelim(iVar59,bcde,*pa,temp192);
        iVar60 = scale_expansion_zeroelim(iVar60,temp192,*pa,det384x);
        iVar61 = scale_expansion_zeroelim(iVar59,bcde,pa[1],temp192);
        iVar61 = scale_expansion_zeroelim(iVar61,temp192,pa[1],det384y);
        iVar59 = scale_expansion_zeroelim(iVar59,bcde,pa[2],temp192);
        iVar59 = scale_expansion_zeroelim(iVar59,temp192,pa[2],det384z);
        iVar60 = fast_expansion_sum_zeroelim(iVar60,det384x,iVar61,det384y,detxy);
        iVar59 = fast_expansion_sum_zeroelim(iVar60,detxy,iVar59,det384z,adet_1);
        iVar60 = fast_expansion_sum_zeroelim(iVar52,dea,iVar56,cda,temp48a);
        iVar51 = fast_expansion_sum_zeroelim(iVar58,eac,iVar51,cde,temp48b);
        if (0 < iVar51) {
          iVar61 = 0;
          do {
            temp48b[iVar61] = -temp48b[iVar61];
            iVar61 = iVar61 + 1;
          } while (iVar61 != iVar51);
        }
        iVar51 = fast_expansion_sum_zeroelim(iVar60,temp48a,iVar51,temp48b,cdea);
        iVar60 = scale_expansion_zeroelim(iVar51,cdea,*pb,temp192);
        iVar60 = scale_expansion_zeroelim(iVar60,temp192,*pb,det384x);
        iVar61 = scale_expansion_zeroelim(iVar51,cdea,pb[1],temp192);
        iVar61 = scale_expansion_zeroelim(iVar61,temp192,pb[1],det384y);
        iVar51 = scale_expansion_zeroelim(iVar51,cdea,pb[2],temp192);
        iVar51 = scale_expansion_zeroelim(iVar51,temp192,pb[2],det384z);
        iVar60 = fast_expansion_sum_zeroelim(iVar60,det384x,iVar61,det384y,detxy);
        iVar51 = fast_expansion_sum_zeroelim(iVar60,detxy,iVar51,det384z,bdet_1);
        iVar57 = fast_expansion_sum_zeroelim(iVar53,eab,iVar57,deb,temp48a);
        iVar52 = fast_expansion_sum_zeroelim(iVar54,abd,iVar52,dea,temp48b);
        if (0 < iVar52) {
          iVar60 = 0;
          do {
            temp48b[iVar60] = -temp48b[iVar60];
            iVar60 = iVar60 + 1;
          } while (iVar60 != iVar52);
        }
        iVar52 = fast_expansion_sum_zeroelim(iVar57,temp48a,iVar52,temp48b,deab);
        iVar57 = scale_expansion_zeroelim(iVar52,deab,*pc,temp192);
        iVar57 = scale_expansion_zeroelim(iVar57,temp192,*pc,det384x);
        iVar60 = scale_expansion_zeroelim(iVar52,deab,pc[1],temp192);
        iVar60 = scale_expansion_zeroelim(iVar60,temp192,pc[1],det384y);
        iVar52 = scale_expansion_zeroelim(iVar52,deab,pc[2],temp192);
        iVar52 = scale_expansion_zeroelim(iVar52,temp192,pc[2],det384z);
        iVar57 = fast_expansion_sum_zeroelim(iVar57,det384x,iVar60,det384y,detxy);
        iVar52 = fast_expansion_sum_zeroelim(iVar57,detxy,iVar52,det384z,cdet_1);
        iVar57 = fast_expansion_sum_zeroelim(iVar49,abc,iVar58,eac,temp48a);
        iVar53 = fast_expansion_sum_zeroelim(iVar55,bce,iVar53,eab,temp48b);
        if (0 < iVar53) {
          iVar55 = 0;
          do {
            temp48b[iVar55] = -temp48b[iVar55];
            iVar55 = iVar55 + 1;
          } while (iVar55 != iVar53);
        }
        iVar53 = fast_expansion_sum_zeroelim(iVar57,temp48a,iVar53,temp48b,eabc);
        iVar55 = scale_expansion_zeroelim(iVar53,eabc,*pd,temp192);
        iVar55 = scale_expansion_zeroelim(iVar55,temp192,*pd,det384x);
        iVar57 = scale_expansion_zeroelim(iVar53,eabc,pd[1],temp192);
        iVar57 = scale_expansion_zeroelim(iVar57,temp192,pd[1],det384y);
        iVar53 = scale_expansion_zeroelim(iVar53,eabc,pd[2],temp192);
        iVar53 = scale_expansion_zeroelim(iVar53,temp192,pd[2],det384z);
        iVar55 = fast_expansion_sum_zeroelim(iVar55,det384x,iVar57,det384y,detxy);
        iVar53 = fast_expansion_sum_zeroelim(iVar55,detxy,iVar53,det384z,ddet_1);
        iVar50 = fast_expansion_sum_zeroelim(iVar50,bcd,iVar54,abd,temp48a);
        iVar49 = fast_expansion_sum_zeroelim(iVar56,cda,iVar49,abc,temp48b);
        if (0 < iVar49) {
          iVar54 = 0;
          do {
            temp48b[iVar54] = -temp48b[iVar54];
            iVar54 = iVar54 + 1;
          } while (iVar54 != iVar49);
        }
        iVar49 = fast_expansion_sum_zeroelim(iVar50,temp48a,iVar49,temp48b,abcd);
        iVar50 = scale_expansion_zeroelim(iVar49,abcd,*pe,temp192);
        iVar50 = scale_expansion_zeroelim(iVar50,temp192,*pe,det384x);
        iVar54 = scale_expansion_zeroelim(iVar49,abcd,pe[1],temp192);
        iVar54 = scale_expansion_zeroelim(iVar54,temp192,pe[1],det384y);
        iVar49 = scale_expansion_zeroelim(iVar49,abcd,pe[2],temp192);
        iVar49 = scale_expansion_zeroelim(iVar49,temp192,pe[2],det384z);
        iVar50 = fast_expansion_sum_zeroelim(iVar50,det384x,iVar54,det384y,detxy);
        iVar49 = fast_expansion_sum_zeroelim(iVar50,detxy,iVar49,det384z,edet);
        iVar50 = fast_expansion_sum_zeroelim(iVar59,adet_1,iVar51,bdet_1,abdet_1);
        iVar51 = fast_expansion_sum_zeroelim(iVar52,cdet_1,iVar53,ddet_1,cddet_1);
        iVar49 = fast_expansion_sum_zeroelim(iVar51,cddet_1,iVar49,edet,cdedet);
        iVar49 = fast_expansion_sum_zeroelim(iVar50,abdet_1,iVar49,cdedet,deter);
        fin1[0] = deter[iVar49 + -1];
      }
    }
  }
  return fin1[0];
}



// WARNING: Unknown calling convention

double insphere(double *pa,double *pb,double *pc,double *pd,double *pe)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double det;
  double cez;
  double bez;
  double aez;
  double bey;
  double bex;
  double aey;
  double aex;
  double dVar13;
  double local_d4;
  double local_6c;
  double local_64;
  double local_5c;
  double local_54;
  double local_4c;
  double local_3c;
  double local_34;
  double local_2c;
  double local_24;
  double local_14;
  
  dVar13 = *pe;
  dVar2 = *pa - dVar13;
  dVar3 = *pb - dVar13;
  dVar4 = *pc - dVar13;
  dVar13 = *pd - dVar13;
  dVar1 = pe[1];
  dVar6 = pa[1] - dVar1;
  dVar7 = pb[1] - dVar1;
  dVar8 = pc[1] - dVar1;
  dVar1 = pd[1] - dVar1;
  local_24 = pa[2] - pe[2];
  dVar11 = pb[2] - pe[2];
  dVar12 = pc[2] - pe[2];
  dVar9 = pd[2] - pe[2];
  local_14 = dVar2 * dVar7;
  local_6c = dVar3 * dVar6;
  local_34 = dVar8 * dVar3;
  local_64 = dVar4 * dVar7;
  local_d4 = dVar1 * dVar4;
  dVar10 = dVar13 * dVar8;
  local_2c = dVar13 * dVar6;
  local_5c = dVar1 * dVar2;
  local_54 = dVar8 * dVar2;
  local_4c = dVar4 * dVar6;
  dVar5 = dVar1 * dVar3;
  local_3c = dVar13 * dVar7;
  dVar6 = local_24 * local_24 + dVar6 * dVar6 + dVar2 * dVar2;
  dVar3 = dVar11 * dVar11 + dVar7 * dVar7 + dVar3 * dVar3;
  dVar2 = dVar12 * dVar12 + dVar8 * dVar8 + dVar4 * dVar4;
  dVar13 = dVar9 * dVar9 + dVar1 * dVar1 + dVar13 * dVar13;
  dVar1 = (((local_d4 - dVar10) * local_24 +
           dVar9 * (local_54 - local_4c) + (local_2c - local_5c) * dVar12) * dVar3 -
          (dVar9 * (local_34 - local_64) +
          ((local_d4 - dVar10) * dVar11 - (dVar5 - local_3c) * dVar12)) * dVar6) +
          (((local_14 - local_6c) * dVar12 +
           ((local_34 - local_64) * local_24 - (local_54 - local_4c) * dVar11)) * dVar13 -
          ((local_2c - local_5c) * dVar11 +
          (dVar5 - local_3c) * local_24 + dVar9 * (local_14 - local_6c)) * dVar2);
  if (local_24 < 0.0) {
    local_24 = -local_24;
  }
  if (dVar11 < 0.0) {
    dVar11 = -dVar11;
  }
  if (dVar12 < 0.0) {
    dVar12 = -dVar12;
  }
  if (dVar9 < 0.0) {
    dVar9 = -dVar9;
  }
  if (local_14 < 0.0) {
    local_14 = -local_14;
  }
  if (local_6c < 0.0) {
    local_6c = -local_6c;
  }
  if (local_34 < 0.0) {
    local_34 = -local_34;
  }
  if (local_64 < 0.0) {
    local_64 = -local_64;
  }
  if (local_d4 < 0.0) {
    local_d4 = -local_d4;
  }
  if (dVar10 < 0.0) {
    dVar10 = -dVar10;
  }
  if (local_2c < 0.0) {
    local_2c = -local_2c;
  }
  if (local_5c < 0.0) {
    local_5c = -local_5c;
  }
  if (local_54 < 0.0) {
    local_54 = -local_54;
  }
  if (local_4c < 0.0) {
    local_4c = -local_4c;
  }
  if (dVar5 < 0.0) {
    dVar5 = -dVar5;
  }
  if (local_3c < 0.0) {
    local_3c = -local_3c;
  }
  dVar2 = (dVar12 * (local_14 + local_6c) +
          dVar11 * (local_54 + local_4c) + local_24 * (local_34 + local_64)) * dVar13 +
          ((local_2c + local_5c) * dVar11 +
          local_24 * (dVar5 + local_3c) + dVar9 * (local_14 + local_6c)) * dVar2 +
          (local_24 * (dVar10 + local_d4) +
          dVar9 * (local_54 + local_4c) + (local_2c + local_5c) * dVar12) * dVar3 +
          ((local_34 + local_64) * dVar9 +
          (dVar5 + local_3c) * dVar12 + (dVar10 + local_d4) * dVar11) * dVar6;
  dVar13 = isperrboundA * dVar2;
  if ((dVar1 <= dVar13) && (-dVar1 <= dVar13)) {
    dVar13 = insphereadapt(pa,pb,pc,pd,pe,dVar2);
    return dVar13;
  }
  return dVar1;
}



// WARNING: Unknown calling convention

void sift_down(GtsEHeap *heap,guint i)

{
  double dVar1;
  double dVar2;
  gpointer *ppvVar3;
  uint uVar4;
  gpointer pvVar5;
  uint uVar6;
  gpointer pvVar7;
  GtsEHeapPair *right_child;
  gpointer pvVar8;
  GtsEHeapPair *left_child;
  GtsEHeapPair *child;
  guint c;
  guint lc;
  uint uVar9;
  guint rc;
  uint uVar10;
  gdouble key;
  
  uVar9 = i * 2;
  uVar10 = uVar9 + 1;
  ppvVar3 = heap->elts->pdata;
  uVar4 = heap->elts->len;
  pvVar8 = (gpointer)0x0;
  if (uVar9 <= uVar4) {
    pvVar8 = ppvVar3[i * 2 + -1];
  }
  pvVar7 = (gpointer)0x0;
  if (uVar10 <= uVar4) {
    pvVar7 = ppvVar3[i * 2];
  }
  pvVar5 = ppvVar3[i - 1];
  dVar1 = *(double *)((int)pvVar5 + 4);
  while( true ) {
    if (pvVar8 == (gpointer)0x0) {
      return;
    }
    uVar6 = uVar9;
    if (pvVar7 == (gpointer)0x0) {
      dVar2 = *(double *)((int)pvVar8 + 4);
    }
    else {
      dVar2 = *(double *)((int)pvVar8 + 4);
      if (*(double *)((int)pvVar7 + 4) <= dVar2) {
        pvVar8 = pvVar7;
        uVar6 = uVar10;
        dVar2 = *(double *)((int)pvVar7 + 4);
      }
    }
    if (dVar1 <= dVar2) break;
    uVar9 = uVar6 * 2;
    *(guint *)((int)pvVar8 + 0xc) = i;
    uVar10 = uVar9 + 1;
    ppvVar3[i - 1] = pvVar8;
    pvVar8 = (gpointer)0x0;
    ppvVar3[uVar6 - 1] = pvVar5;
    *(uint *)((int)pvVar5 + 0xc) = uVar6;
    if (uVar9 <= uVar4) {
      pvVar8 = ppvVar3[uVar6 * 2 + -1];
    }
    pvVar7 = (gpointer)0x0;
    i = uVar6;
    if (uVar10 <= uVar4) {
      pvVar7 = ppvVar3[uVar6 * 2];
    }
  }
  return;
}



// WARNING: Unknown calling convention

void gts_eheap_randomized(GtsEHeap *heap,gboolean randomized)

{
  if (heap != (GtsEHeap *)0x0) {
    heap->randomized = randomized;
    return;
  }
  g_return_if_fail_warning(0,"gts_eheap_randomized","heap != NULL");
  return;
}



// WARNING: Unknown calling convention

gdouble gts_eheap_key(GtsEHeap *heap,gpointer p)

{
  longdouble extraout_ST0;
  
  if (heap == (GtsEHeap *)0x0) {
    g_return_if_fail_warning(0,"gts_eheap_key","heap != NULL");
    return 0.0;
  }
  if (heap->func != (GtsKeyFunc)0x0) {
                    // WARNING: Could not recover jumptable at 0x0812fb51. Too many branches
                    // WARNING: Treating indirect jump as call
    (*heap->func)(p,heap->data);
    return (gdouble)extraout_ST0;
  }
  g_return_if_fail_warning(0,"gts_eheap_key","heap->func != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

guint gts_eheap_size(GtsEHeap *heap)

{
  if (heap != (GtsEHeap *)0x0) {
    return heap->elts->len;
  }
  g_return_if_fail_warning(0,"gts_eheap_size","heap != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void gts_eheap_freeze(GtsEHeap *heap)

{
  if (heap != (GtsEHeap *)0x0) {
    heap->frozen = 1;
    return;
  }
  g_return_if_fail_warning(0,"gts_eheap_freeze","heap != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_eheap_foreach(GtsEHeap *heap,GFunc func,gpointer data)

{
  gpointer *ppvVar1;
  GPtrArray *pGVar2;
  guint i;
  GPtrArray *elts;
  
  if ((heap != (GtsEHeap *)0x0) && (func != (GFunc)0x0)) {
    pGVar2 = heap->elts;
    if (pGVar2->len != 0) {
      i = 0;
      do {
        ppvVar1 = pGVar2->pdata + i;
        i = i + 1;
                    // WARNING: Load size is inaccurate
        (*func)(**ppvVar1,data);
      } while (i <= pGVar2->len && pGVar2->len != i);
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

void gts_eheap_thaw(GtsEHeap *heap)

{
  guint i_00;
  guint i;
  
  if (heap == (GtsEHeap *)0x0) {
    g_return_if_fail_warning(0,"gts_eheap_thaw","heap != NULL");
    return;
  }
  if (heap->frozen != 0) {
    for (i_00 = heap->elts->len >> 1; i_00 != 0; i_00 = i_00 - 1) {
      sift_down(heap,i_00);
    }
    heap->frozen = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void gts_eheap_update(GtsEHeap *heap)

{
  uint uVar1;
  gpointer *ppvVar2;
  gpointer pvVar3;
  GtsKeyFunc p_Var4;
  gpointer *ppvVar5;
  gpointer data;
  uint uVar6;
  guint i;
  GtsEHeapPair *pair;
  guint len;
  longdouble lVar7;
  
  if (heap == (GtsEHeap *)0x0) {
    g_return_if_fail_warning(0,"gts_eheap_update","heap != NULL");
  }
  else {
    if (heap->func != (GtsKeyFunc)0x0) {
      heap->frozen = 1;
      uVar1 = heap->elts->len;
      ppvVar2 = heap->elts->pdata;
      pvVar3 = heap->data;
      p_Var4 = heap->func;
      if (uVar1 != 0) {
        uVar6 = 0;
        do {
          ppvVar5 = (gpointer *)ppvVar2[uVar6];
          uVar6 = uVar6 + 1;
          lVar7 = (longdouble)(*p_Var4)(*ppvVar5,pvVar3);
          *(double *)(ppvVar5 + 1) = (double)lVar7;
        } while (uVar6 < uVar1);
      }
      gts_eheap_thaw(heap);
      return;
    }
    g_return_if_fail_warning(0,"gts_eheap_update","heap->func != NULL");
  }
  return;
}



// WARNING: Unknown calling convention

gpointer gts_eheap_top(GtsEHeap *heap,gdouble *key)

{
  gpointer *ppvVar1;
  gpointer pvVar2;
  GtsEHeapPair *pair;
  GPtrArray *elts;
  
  if (heap != (GtsEHeap *)0x0) {
    pvVar2 = (gpointer)0x0;
    if (heap->elts->len != 0) {
      ppvVar1 = (gpointer *)*heap->elts->pdata;
      if (key != (gdouble *)0x0) {
        *key = *(gdouble *)(ppvVar1 + 1);
      }
      pvVar2 = *ppvVar1;
    }
    return pvVar2;
  }
  g_return_if_fail_warning(0,"gts_eheap_top","heap != NULL");
  return (gpointer)0x0;
}



// WARNING: Removing unreachable block (ram,0x0812fea4)
// WARNING: Unknown calling convention

void sift_up(GtsEHeap *heap,guint i)

{
  double dVar1;
  gpointer *ppvVar2;
  gpointer pvVar3;
  gpointer pvVar4;
  int iVar5;
  gpointer *pdata;
  guint p;
  uint uVar6;
  GtsEHeapPair *parent;
  gdouble key;
  
  ppvVar2 = heap->elts->pdata;
  pvVar3 = ppvVar2[i - 1];
  dVar1 = *(double *)((int)pvVar3 + 4);
  if (1 < i) {
    do {
      uVar6 = i >> 1;
      pvVar4 = ppvVar2[uVar6 - 1];
      if (*(double *)((int)pvVar4 + 4) <= dVar1) {
        if (heap->randomized == 0) {
          return;
        }
        if (dVar1 != *(double *)((int)pvVar4 + 4)) {
          return;
        }
        iVar5 = rand();
        if (0x3ffffffe < iVar5) {
          return;
        }
      }
      ppvVar2[uVar6 - 1] = pvVar3;
      *(uint *)((int)pvVar3 + 0xc) = uVar6;
      ppvVar2[i - 1] = pvVar4;
      *(guint *)((int)pvVar4 + 0xc) = i;
      i = uVar6;
    } while (1 < uVar6);
  }
  return;
}



// WARNING: Unknown calling convention

void gts_eheap_decrease_key(GtsEHeap *heap,GtsEHeapPair *p,gdouble new_key)

{
  guint *pgVar1;
  uint i_00;
  guint i;
  
  if ((((heap != (GtsEHeap *)0x0) && (p != (GtsEHeapPair *)0x0)) && (i_00 = p->pos, i_00 != 0)) &&
     (((pgVar1 = &heap->elts->len, i_00 < *pgVar1 || i_00 == *pgVar1 &&
       ((GtsEHeapPair *)heap->elts->pdata[i_00 - 1] == p)) && (new_key <= p->key)))) {
    p->key = new_key;
    if (heap->frozen == 0) {
      sift_up(heap,i_00);
      return;
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

void gts_eheap_destroy(GtsEHeap *heap)

{
  gpointer *ppvVar1;
  GPtrArray *pGVar2;
  guint i;
  
  if (heap != (GtsEHeap *)0x0) {
    pGVar2 = heap->elts;
    if (pGVar2->len != 0) {
      i = 0;
      do {
        ppvVar1 = pGVar2->pdata + i;
        i = i + 1;
        g_free(*ppvVar1);
        pGVar2 = heap->elts;
      } while (i <= pGVar2->len && pGVar2->len != i);
    }
    g_ptr_array_free(pGVar2,1);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_eheap_destroy","heap != NULL");
  return;
}



// WARNING: Unknown calling convention

gpointer gts_eheap_remove_top(GtsEHeap *heap,gdouble *key)

{
  GPtrArray *pGVar1;
  undefined *puVar2;
  guint len;
  gpointer pvVar3;
  gpointer *ppvVar4;
  GtsEHeapPair *pair;
  gpointer pvVar5;
  gpointer root;
  GPtrArray *elts;
  
  if (heap == (GtsEHeap *)0x0) {
    pvVar5 = (gpointer)0x0;
    g_return_if_fail_warning(0,"gts_eheap_remove_top","heap != NULL");
  }
  else {
    pGVar1 = heap->elts;
    pvVar5 = (gpointer)0x0;
    puVar2 = (undefined *)pGVar1->len;
    if (puVar2 != (undefined *)0x0) {
      if (puVar2 == &DAT_00000001) {
        ppvVar4 = (gpointer *)g_ptr_array_remove_index(pGVar1,0);
        pvVar5 = *ppvVar4;
        if (key != (gdouble *)0x0) {
          *key = *(gdouble *)(ppvVar4 + 1);
        }
        g_free(ppvVar4);
      }
      else {
        ppvVar4 = (gpointer *)*pGVar1->pdata;
        pvVar5 = *ppvVar4;
        if (key != (gdouble *)0x0) {
          *key = *(gdouble *)(ppvVar4 + 1);
        }
        g_free(ppvVar4);
        pvVar3 = (gpointer)g_ptr_array_remove_index(pGVar1,puVar2 + -1);
        ppvVar4 = pGVar1->pdata;
        *(undefined4 *)((int)pvVar3 + 0xc) = 1;
        *ppvVar4 = pvVar3;
        sift_down(heap,1);
      }
    }
  }
  return pvVar5;
}



// WARNING: Unknown calling convention

gpointer gts_eheap_remove(GtsEHeap *heap,GtsEHeapPair *p)

{
  guint *pgVar1;
  int iVar2;
  gpointer pvVar3;
  uint uVar4;
  gpointer *ppvVar5;
  GtsEHeapPair *pGVar6;
  GtsEHeapPair *pGVar7;
  guint i;
  GtsEHeapPair *parent;
  guint par;
  uint uVar8;
  
  if (heap == (GtsEHeap *)0x0) {
    g_return_if_fail_warning(0,"gts_eheap_remove","heap != NULL");
  }
  else if (p == (GtsEHeapPair *)0x0) {
    g_return_if_fail_warning(0,"gts_eheap_remove","p != NULL");
  }
  else {
    pvVar3 = p->data;
    uVar4 = p->pos;
    ppvVar5 = heap->elts->pdata;
    if ((uVar4 != 0) && (pgVar1 = &heap->elts->len, uVar4 < *pgVar1 || uVar4 == *pgVar1)) {
      iVar2 = uVar4 - 1;
      pGVar6 = (GtsEHeapPair *)ppvVar5[iVar2];
      if (pGVar6 == p) {
        while (1 < uVar4) {
          uVar8 = uVar4 >> 1;
          pGVar7 = (GtsEHeapPair *)ppvVar5[uVar8 - 1];
          ppvVar5[uVar8 - 1] = pGVar6;
          ppvVar5[iVar2] = pGVar7;
          pGVar6->pos = uVar8;
          pGVar7->pos = uVar4;
          uVar4 = uVar8;
          iVar2 = uVar8 - 1;
        }
        gts_eheap_remove_top(heap,(gdouble *)0x0);
        return pvVar3;
      }
      g_return_if_fail_warning(0,"gts_eheap_remove","p == pdata[i - 1]");
      return (gpointer)0x0;
    }
    g_return_if_fail_warning(0,"gts_eheap_remove","i > 0 && i <= heap->elts->len");
  }
  return (gpointer)0x0;
}



// WARNING: Unknown calling convention

GtsEHeapPair * gts_eheap_insert_with_key(GtsEHeap *heap,gpointer p,gdouble key)

{
  GPtrArray *pGVar1;
  guint gVar2;
  GtsEHeapPair *pGVar3;
  GtsEHeapPair *pair;
  GPtrArray *elts;
  
  if (heap == (GtsEHeap *)0x0) {
    pGVar3 = (GtsEHeapPair *)0x0;
    g_return_if_fail_warning(0,"gts_eheap_insert_with_key","heap != NULL");
  }
  else {
    pGVar1 = heap->elts;
    pGVar3 = (GtsEHeapPair *)g_malloc(0x10);
    g_ptr_array_add(pGVar1,pGVar3);
    pGVar3->data = p;
    gVar2 = pGVar1->len;
    pGVar3->key = key;
    pGVar3->pos = gVar2;
    if (heap->frozen == 0) {
      sift_up(heap,pGVar1->len);
    }
  }
  return pGVar3;
}



// WARNING: Unknown calling convention

GtsEHeapPair * gts_eheap_insert(GtsEHeap *heap,gpointer p)

{
  GPtrArray *pGVar1;
  int iVar2;
  GtsEHeapPair *pGVar3;
  GtsEHeapPair *pair;
  GPtrArray *elts;
  longdouble lVar4;
  
  if (heap == (GtsEHeap *)0x0) {
    pGVar3 = (GtsEHeapPair *)0x0;
    g_return_if_fail_warning(0,"gts_eheap_insert","heap != NULL");
  }
  else if (heap->func == (GtsKeyFunc)0x0) {
    pGVar3 = (GtsEHeapPair *)0x0;
    g_return_if_fail_warning(0,"gts_eheap_insert","heap->func != NULL");
  }
  else {
    pGVar1 = heap->elts;
    pGVar3 = (GtsEHeapPair *)g_malloc(0x10);
    g_ptr_array_add(pGVar1,pGVar3);
    pGVar3->pos = pGVar1->len;
    pGVar3->data = p;
    lVar4 = (longdouble)(*heap->func)(p,heap->data);
    iVar2 = heap->frozen;
    pGVar3->key = (double)lVar4;
    if (iVar2 == 0) {
      sift_up(heap,pGVar1->len);
    }
  }
  return pGVar3;
}



// WARNING: Unknown calling convention

GtsEHeap * gts_eheap_new(GtsKeyFunc key_func,gpointer data)

{
  GtsEHeap *pGVar1;
  GPtrArray *pGVar2;
  
  pGVar1 = (GtsEHeap *)g_malloc(0x14);
  pGVar2 = (GPtrArray *)g_ptr_array_new();
  pGVar1->frozen = 0;
  pGVar1->randomized = 0;
  pGVar1->elts = pGVar2;
  pGVar1->func = key_func;
  pGVar1->data = data;
  return pGVar1;
}



// WARNING: Unknown calling convention

void surface_class_init(GtsSurfaceClass *klass)

{
  (klass->parent_class).destroy = surface_destroy;
  (klass->parent_class).write = surface_write;
  klass->add_face = (_func_void_GtsSurface_ptr_GtsFace_ptr *)0x0;
  klass->remove_face = (_func_void_GtsSurface_ptr_GtsFace_ptr *)0x0;
  return;
}



// WARNING: Unknown calling convention

void foreach_face(GtsFace *f,gpointer t_data,gpointer *info)

{
                    // WARNING: Could not recover jumptable at 0x08130452. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)*info)();
  return;
}



// WARNING: Unknown calling convention

void number_foreach(gpointer data,guint *n)

{
  *n = *n + 1;
  return;
}



// WARNING: Unknown calling convention

gboolean gts_coarsen_stop_cost(gdouble cost,guint nedge,gdouble *max_cost)

{
  if (max_cost != (gdouble *)0x0) {
    return (uint)(*max_cost < cost);
  }
  g_return_if_fail_warning(0,"gts_coarsen_stop_cost","max_cost != NULL");
  return 1;
}



// WARNING: Unknown calling convention

gboolean gts_coarsen_stop_number(gdouble cost,guint nedge,guint *min_number)

{
  if (min_number != (guint *)0x0) {
    return (uint)(nedge <= *min_number && *min_number != nedge);
  }
  g_return_if_fail_warning(0,"gts_coarsen_stop_number","min_number != NULL");
  return 1;
}



// WARNING: Unknown calling convention

void gts_range_add_value(GtsRange *r,gdouble val)

{
  if (r != (GtsRange *)0x0) {
    if (val < r->min) {
      r->min = val;
    }
    if (r->max < val) {
      r->max = val;
    }
    r->n = r->n + 1;
    r->sum = r->sum + val;
    r->sum2 = val * val + r->sum2;
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

void gts_range_reset(GtsRange *r)

{
  if (r != (GtsRange *)0x0) {
    r->max = 0.0;
    r->n = 0;
    r->min = 0.0;
    r->sum2 = 0.0;
    r->sum = 0.0;
    return;
  }
  g_return_if_fail_warning(0,"gts_range_reset","r != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_range_init(GtsRange *r)

{
  if (r != (GtsRange *)0x0) {
    r->max = -1.797693134862316e+308;
    r->min = 1.797693134862316e+308;
    r->sum2 = 0.0;
    r->n = 0;
    r->sum = 0.0;
    return;
  }
  g_return_if_fail_warning(0,"gts_range_init","r != NULL");
  return;
}



// WARNING: Unknown calling convention

GSList * edge_triangles(GtsEdge *e1,GtsEdge *e)

{
  GSList *pGVar1;
  gpointer pvVar2;
  GSList *pGVar3;
  GSList *triangles;
  GtsEdge *e2;
  GtsEdge *pGVar4;
  GtsTriangle *t;
  GtsTriangle *t_1;
  GSList *j;
  GSList *pGVar5;
  GSList *i;
  
  pGVar1 = e1->triangles;
  pGVar3 = (GSList *)0x0;
  do {
    while( true ) {
      if (pGVar1 == (GSList *)0x0) {
        return pGVar3;
      }
      pvVar2 = pGVar1->data;
      if (*(GtsEdge **)((int)pvVar2 + 0xc) == e) break;
      pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x10);
      if (pGVar4 == e) {
        pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x14);
joined_r0x081306b6:
        if (pGVar4 == e1) {
          pGVar4 = *(GtsEdge **)((int)pvVar2 + 0xc);
        }
        goto LAB_0813065d;
      }
      if (*(GtsEdge **)((int)pvVar2 + 0x14) == e) goto joined_r0x081306b6;
      pGVar3 = (GSList *)g_slist_prepend(pGVar3,pvVar2);
LAB_0813063c:
      pGVar1 = pGVar1->next;
    }
    pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x10);
    if (pGVar4 == e1) {
      pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x14);
    }
LAB_0813065d:
    pGVar5 = pGVar4->triangles;
    if (pGVar5 == (GSList *)0x0) goto LAB_0813063c;
    do {
      pvVar2 = pGVar5->data;
      if (((*(GtsEdge **)((int)pvVar2 + 0xc) != e) && (*(GtsEdge **)((int)pvVar2 + 0x10) != e)) &&
         (*(GtsEdge **)((int)pvVar2 + 0x14) != e)) {
        pGVar3 = (GSList *)g_slist_prepend(pGVar3,pvVar2);
      }
      pGVar5 = pGVar5->next;
    } while (pGVar5 != (GSList *)0x0);
    pGVar1 = pGVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

void closed_foreach_edge(GtsEdge *e,gpointer *data)

{
  int *piVar1;
  guint gVar2;
  gboolean *is_closed;
  
  piVar1 = (int *)*data;
  if (*piVar1 != 0) {
    gVar2 = gts_edge_face_number(e,(GtsSurface *)data[1]);
    if (gVar2 != 2) {
      *piVar1 = 0;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void manifold_foreach_edge(GtsEdge *e,gpointer *data)

{
  int *piVar1;
  guint gVar2;
  gboolean *is_manifold;
  
  piVar1 = (int *)*data;
  if (*piVar1 != 0) {
    gVar2 = gts_edge_face_number(e,(GtsSurface *)data[1]);
    if (2 < gVar2) {
      *piVar1 = 0;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void non_manifold_edges(GtsEdge *e,gpointer *data)

{
  GtsSurface *s_00;
  undefined4 *puVar1;
  guint gVar2;
  gboolean gVar3;
  int iVar4;
  undefined4 uVar5;
  GSList *i;
  GSList *pGVar6;
  GtsSurface *s;
  GSList **non_manifold;
  
  s_00 = (GtsSurface *)*data;
  puVar1 = (undefined4 *)data[1];
  gVar2 = gts_edge_face_number(e,s_00);
  if (2 < gVar2) {
    for (pGVar6 = e->triangles; pGVar6 != (GSList *)0x0; pGVar6 = (GSList *)(&pGVar6->data)[1]) {
      while ((gVar3 = gts_face_has_parent_surface((GtsFace *)pGVar6->data,s_00), gVar3 == 0 ||
             (iVar4 = g_slist_find(*puVar1,pGVar6->data), iVar4 != 0))) {
        pGVar6 = (GSList *)(&pGVar6->data)[1];
        if (pGVar6 == (GSList *)0x0) {
          return;
        }
      }
      uVar5 = g_slist_prepend(*puVar1,pGVar6->data);
      *puVar1 = uVar5;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void surface_boundary(GtsEdge *e,gpointer *data)

{
  undefined4 *puVar1;
  GtsFace *pGVar2;
  undefined4 uVar3;
  
  puVar1 = (undefined4 *)*data;
  pGVar2 = gts_edge_is_boundary(e,(GtsSurface *)data[1]);
  if (pGVar2 != (GtsFace *)0x0) {
    uVar3 = g_slist_prepend(*puVar1,e);
    *puVar1 = uVar3;
  }
  return;
}



// WARNING: Unknown calling convention

GtsFace * gts_surface_traverse_next(GtsSurfaceTraverse *t,guint *level)

{
  GtsFace *f;
  GtsFace *u;
  gpointer data [2];
  
  if (t == (GtsSurfaceTraverse *)0x0) {
    f = (GtsFace *)0x0;
    g_return_if_fail_warning(0,"gts_surface_traverse_next","t != NULL");
  }
  else {
    f = (GtsFace *)gts_fifo_pop(t->q);
    if (f != (GtsFace *)0x0) {
      if (level != (guint *)0x0) {
        *level = (guint)(f->triangle).object.reserved;
      }
      data[0] = t->q;
      data[1] = f;
      gts_face_foreach_neighbor(f,t->s,push_neighbor,data);
    }
  }
  return f;
}



// WARNING: Unknown calling convention

void push_neighbor(GtsFace *v,gpointer *data)

{
  if ((v->triangle).object.reserved != (gpointer)0x0) {
    return;
  }
  (v->triangle).object.reserved = (gpointer)(*(int *)((int)data[1] + 4) + 1);
  gts_fifo_push((GtsFifo *)*data,v);
  return;
}



// WARNING: Unknown calling convention

GtsSurfaceTraverse * gts_surface_traverse_new(GtsSurface *s,GtsFace *f)

{
  gboolean gVar1;
  GtsFifo *pGVar2;
  GtsSurfaceTraverse *pGVar3;
  GtsSurfaceTraverse *t;
  
  if (s == (GtsSurface *)0x0) {
    pGVar3 = (GtsSurfaceTraverse *)0x0;
    g_return_if_fail_warning(0,"gts_surface_traverse_new","s != NULL");
  }
  else if (f == (GtsFace *)0x0) {
    pGVar3 = (GtsSurfaceTraverse *)0x0;
    g_return_if_fail_warning(0,"gts_surface_traverse_new","f != NULL");
  }
  else {
    gVar1 = gts_face_has_parent_surface(f,s);
    if (gVar1 == 0) {
      pGVar3 = (GtsSurfaceTraverse *)0x0;
      g_return_if_fail_warning(0,"gts_surface_traverse_new","gts_face_has_parent_surface (f, s)");
    }
    else {
      pGVar3 = (GtsSurfaceTraverse *)g_malloc(8);
      pGVar2 = gts_fifo_new();
      pGVar3->s = s;
      (f->triangle).object.reserved = &DAT_00000001;
      pGVar3->q = pGVar2;
      gts_fifo_push(pGVar3->q,f);
    }
  }
  return pGVar3;
}



// WARNING: Unknown calling convention

void build_list_boundary(GtsEdge *e,GSList **list)

{
  GtsFace *pGVar1;
  GtsBBoxClass *klass;
  GtsBBox *pGVar2;
  GSList *pGVar3;
  
  pGVar1 = gts_edge_is_boundary(e,(GtsSurface *)0x0);
  if (pGVar1 != (GtsFace *)0x0) {
    klass = gts_bbox_class();
    pGVar2 = gts_bbox_segment(klass,&e->segment);
    pGVar3 = (GSList *)g_slist_prepend(*list,pGVar2);
    *list = pGVar3;
  }
  return;
}



// WARNING: Unknown calling convention

void build_list_face(GtsTriangle *t,GSList **list)

{
  GtsBBoxClass *klass;
  GtsBBox *pGVar1;
  GSList *pGVar2;
  
  klass = gts_bbox_class();
  pGVar1 = gts_bbox_triangle(klass,t);
  pGVar2 = (GSList *)g_slist_prepend(*list,pGVar1);
  *list = pGVar2;
  return;
}



// WARNING: Unknown calling convention

guint gts_surface_face_number(GtsSurface *s)

{
  guint gVar1;
  
  if (s != (GtsSurface *)0x0) {
    gVar1 = g_hash_table_size();
    return gVar1;
  }
  g_return_if_fail_warning(0,"gts_surface_face_number","s != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void center_of_mass_foreach_face(GtsTriangle *t,gpointer *data)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double *pdVar9;
  double *pdVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  GtsPoint *p3;
  GtsPoint *p1;
  GtsPoint *p2;
  gdouble *cm;
  gdouble *volume;
  gdouble nx;
  gdouble z2;
  gdouble z1;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10;
  
  pdVar9 = (double *)data[1];
  pdVar10 = (double *)*data;
  gts_triangle_vertices(t,&local_10,&local_14,&local_18);
  dVar1 = (local_14->p).x;
  dVar2 = (local_10->p).x;
  dVar3 = (local_10->p).y;
  dVar13 = (local_14->p).y - dVar3;
  dVar4 = (local_10->p).z;
  dVar12 = (local_14->p).z - dVar4;
  dVar5 = (local_18->p).x;
  dVar3 = (local_18->p).y - dVar3;
  dVar4 = (local_18->p).z - dVar4;
  dVar11 = dVar13 * dVar4 - dVar3 * dVar12;
  *pdVar9 = (dVar2 * dVar5 + dVar1 * dVar2 + dVar5 * dVar5 + dVar1 * dVar1 + dVar2 * dVar2 +
            dVar5 * dVar1) * dVar11 + *pdVar9;
  dVar6 = (local_10->p).y;
  dVar7 = (local_14->p).y;
  dVar8 = (local_18->p).y;
  pdVar9[1] = (dVar12 * (dVar5 - dVar2) - dVar4 * (dVar1 - dVar2)) *
              (dVar8 * dVar7 +
              dVar6 * dVar8 + dVar6 * dVar7 + dVar8 * dVar8 + dVar7 * dVar7 + dVar6 * dVar6) +
              pdVar9[1];
  dVar4 = (local_10->p).z;
  dVar6 = (local_14->p).z;
  dVar7 = (local_18->p).z;
  pdVar9[2] = ((dVar1 - dVar2) * dVar3 - dVar13 * (dVar5 - dVar2)) *
              (dVar7 * dVar6 +
              dVar4 * dVar7 + dVar4 * dVar6 + dVar7 * dVar7 + dVar6 * dVar6 + dVar4 * dVar4) +
              pdVar9[2];
  *pdVar10 = ((local_10->p).x + (local_14->p).x + (local_18->p).x) * dVar11 + *pdVar10;
  return;
}



// WARNING: Unknown calling convention

void volume_foreach_face(GtsTriangle *t,gdouble *volume)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  GtsPoint *pc;
  GtsPoint *pa;
  GtsPoint *pb;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  gts_triangle_vertices(t,local_10,&local_14,&local_18);
  dVar1 = (local_14->p).y;
  dVar2 = (local_18->p).z;
  dVar3 = (local_14->p).z;
  dVar4 = (local_18->p).y;
  dVar5 = (local_10[0]->p).z;
  dVar6 = (local_10[0]->p).y;
  *volume = (dVar6 * dVar3 - dVar5 * dVar1) * (local_18->p).x +
            (dVar4 * dVar5 - dVar2 * dVar6) * (local_14->p).x +
            (dVar1 * dVar2 - dVar3 * dVar4) * (local_10[0]->p).x + *volume;
  return;
}



// WARNING: Unknown calling convention

void center_of_area_foreach_face(GtsTriangle *t,gpointer *data)

{
  double *pdVar1;
  double *pdVar2;
  GtsPoint *p1;
  gdouble *area;
  gdouble *cm;
  GtsPoint *p3;
  GtsPoint *p2;
  gdouble a;
  gdouble gVar3;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  pdVar1 = (double *)*data;
  pdVar2 = (double *)data[1];
  gts_triangle_vertices(t,local_20,&local_24,&local_28);
  gVar3 = gts_triangle_area(t);
  *pdVar2 = ((local_20[0]->p).x + (local_24->p).x + (local_28->p).x) * gVar3 + *pdVar2;
  pdVar2[1] = ((local_20[0]->p).y + (local_24->p).y + (local_28->p).y) * gVar3 + pdVar2[1];
  pdVar2[2] = ((local_20[0]->p).z + (local_24->p).z + (local_28->p).z) * gVar3 + pdVar2[2];
  *pdVar1 = gVar3 + *pdVar1;
  return;
}



// WARNING: Unknown calling convention

void sum_area(GtsFace *f,gdouble *area)

{
  double dVar1;
  gdouble gVar2;
  
  dVar1 = *area;
  gVar2 = gts_triangle_area(&f->triangle);
  *area = gVar2 + dVar1;
  return;
}



// WARNING: Unknown calling convention

void foreach_edge_copy(GtsSegment *s,GtsEdgeClass *klass)

{
  GtsEdge *pGVar1;
  
  pGVar1 = gts_edge_new(klass,(GtsVertex *)(s->v1->p).object.reserved,
                        (GtsVertex *)(s->v2->p).object.reserved);
  (s->object).reserved = pGVar1;
  return;
}



// WARNING: Unknown calling convention

void foreach_vertex_copy(GtsPoint *p,GtsVertexClass *klass)

{
  GtsVertex *pGVar1;
  
  pGVar1 = gts_vertex_new(klass,p->x,p->y,p->z);
  (p->object).reserved = pGVar1;
  return;
}



// WARNING: Unknown calling convention

gboolean foreach_face_remove(GtsFace *f,gpointer t_data,gpointer *info)

{
  byte bVar1;
  int *piVar2;
  int iVar3;
  gboolean gVar4;
  GSList *pGVar5;
  GtsSurface *s;
  
  iVar3 = (*(code *)*info)(f,info[1]);
  gVar4 = 0;
  if (iVar3 != 0) {
    piVar2 = (int *)info[2];
    pGVar5 = (GSList *)g_slist_remove(f->surfaces,piVar2);
    bVar1 = *(byte *)&(f->triangle).object.flags;
    f->surfaces = pGVar5;
    if ((((bVar1 & 1) == 0) && (gts_allow_floating_faces == 0)) && (pGVar5 == (GSList *)0x0)) {
      gts_object_destroy((GtsObject *)f);
    }
    gVar4 = 1;
    if (*(code **)(*piVar2 + 0x60) != (code *)0x0) {
      (**(code **)(*piVar2 + 0x60))(piVar2,f);
      return 1;
    }
  }
  return gVar4;
}



// WARNING: Unknown calling convention

void destroy_foreach_face(GtsFace *f,GtsSurface *s)

{
  byte bVar1;
  GSList *pGVar2;
  
  pGVar2 = (GSList *)g_slist_remove(f->surfaces,s);
  bVar1 = *(byte *)&(f->triangle).object.flags;
  f->surfaces = pGVar2;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_faces == 0)) && (pGVar2 == (GSList *)0x0)) {
    gts_object_destroy((GtsObject *)f);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void create_array_tessellate(GtsFace *f,GPtrArray *array)

{
  g_ptr_array_add();
  return;
}



// WARNING: Removing unreachable block (ram,0x08130f07)
// WARNING: Removing unreachable block (ram,0x08130f0b)
// WARNING: Removing unreachable block (ram,0x08130f10)
// WARNING: Unknown calling convention

GtsVertex * unit_sphere_arc_midvertex(GtsSegment *s,GtsVertexClass *vertex_class)

{
  GtsVertex *pGVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  GtsPoint *p2;
  GtsVertex *pGVar6;
  GtsPoint *p1;
  gdouble x;
  gdouble y;
  gdouble z;
  gdouble norm;
  
  pGVar6 = s->v1;
  pGVar1 = s->v2;
  dVar2 = ((pGVar6->p).x + (pGVar1->p).x) * 0.5;
  dVar5 = ((pGVar6->p).y + (pGVar1->p).y) * 0.5;
  dVar4 = ((pGVar6->p).z + (pGVar1->p).z) * 0.5;
  dVar3 = SQRT(dVar4 * dVar4 + dVar5 * dVar5 + dVar2 * dVar2);
  pGVar6 = gts_vertex_new(vertex_class,dVar2 / dVar3,dVar5 / dVar3,dVar4 / dVar3);
  return pGVar6;
}



// WARNING: Removing unreachable block (ram,0x08131006)
// WARNING: Removing unreachable block (ram,0x0813100c)
// WARNING: Removing unreachable block (ram,0x08131010)
// WARNING: Unknown calling convention

void gts_range_update(GtsRange *r)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  if (r == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_range_update","r != NULL");
    return;
  }
  if (r->n != 0) {
    dVar1 = r->sum;
    dVar3 = (double)(ulonglong)r->n;
    dVar2 = r->sum2 - (dVar1 * dVar1) / dVar3;
    if (dVar2 < 0.0) {
      r->stddev = 0.0;
    }
    else {
      r->stddev = SQRT(dVar2 / dVar3);
    }
    r->mean = dVar1 / (double)(ulonglong)r->n;
    return;
  }
  r->stddev = 0.0;
  r->mean = 0.0;
  r->max = 0.0;
  r->min = 0.0;
  return;
}



// WARNING: Unknown calling convention

void create_heap_coarsen(GtsEdge *e,GtsEHeap *heap)

{
  GtsEHeapPair *pGVar1;
  
  pGVar1 = gts_eheap_insert(heap,e);
  (e->segment).object.reserved = pGVar1;
  return;
}



// WARNING: Unknown calling convention

void create_heap_refine(GtsEdge *e,GtsEHeap *heap)

{
  gts_eheap_insert(heap,e);
  return;
}



// WARNING: Unknown calling convention

gdouble edge_length2(GtsEdge *e)

{
  gdouble gVar1;
  
  gVar1 = gts_point_distance2(&((e->segment).v1)->p,&((e->segment).v2)->p);
  return gVar1;
}



// WARNING: Unknown calling convention

gdouble edge_length2_inverse(GtsSegment *s)

{
  gdouble gVar1;
  
  gVar1 = gts_point_distance2(&s->v1->p,&s->v2->p);
  return -gVar1;
}



// WARNING: Unknown calling convention

guint gts_surface_foreach_face_remove(GtsSurface *s,GtsFunc func,gpointer data)

{
  guint gVar1;
  guint n;
  gpointer info [4];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_face_remove","s != NULL");
    return 0;
  }
  if (func != (GtsFunc)0x0) {
    info[0] = func;
    info[2] = s;
    s->keep_faces = 1;
    info[1] = data;
    gVar1 = g_hash_table_foreach_remove(s->faces,foreach_face_remove,info);
    s->keep_faces = 0;
    return gVar1;
  }
  g_return_if_fail_warning(0,"gts_surface_foreach_face_remove","func != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void gts_surface_foreach_face(GtsSurface *s,GtsFunc func,gpointer data)

{
  gpointer info [2];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_face","s != NULL");
    return;
  }
  if (func != (GtsFunc)0x0) {
    info[0] = func;
    s->keep_faces = 1;
    info[1] = data;
    g_hash_table_foreach(s->faces,foreach_face,info);
    s->keep_faces = 0;
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_foreach_face","func != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_surface_traverse_destroy(GtsSurfaceTraverse *t)

{
  if (t != (GtsSurfaceTraverse *)0x0) {
    gts_surface_foreach_face(t->s,gts_object_reset_reserved,(gpointer)0x0);
    gts_fifo_destroy(t->q);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_traverse_destroy","t != NULL");
  return;
}



// WARNING: Unknown calling convention

gdouble gts_surface_center_of_area(GtsSurface *s,gdouble *cm)

{
  gpointer data [2];
  double local_14;
  
  local_14 = 0.0;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_center_of_area","s != NULL");
    return 0.0;
  }
  cm[2] = 0.0;
  data[0] = &local_14;
  cm[1] = 0.0;
  *cm = 0.0;
  data[1] = cm;
  gts_surface_foreach_face(s,center_of_area_foreach_face,data);
  if (local_14 != 0.0) {
    *cm = *cm / (local_14 * 3.0);
    cm[1] = cm[1] / (local_14 * 3.0);
    cm[2] = cm[2] / (local_14 * 3.0);
    return local_14;
  }
  return local_14;
}



// WARNING: Unknown calling convention

gdouble gts_surface_center_of_mass(GtsSurface *s,gdouble *cm)

{
  gpointer data [2];
  double local_14;
  
  local_14 = 0.0;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_center_of_mass","s != NULL");
    return 0.0;
  }
  cm[2] = 0.0;
  data[0] = &local_14;
  cm[1] = 0.0;
  *cm = 0.0;
  data[1] = cm;
  gts_surface_foreach_face(s,center_of_mass_foreach_face,data);
  if (local_14 != 0.0) {
    *cm = *cm / (local_14 * 4.0);
    cm[1] = cm[1] / (local_14 * 4.0);
    cm[2] = cm[2] / (local_14 * 4.0);
  }
  return local_14 / 6.0;
}



// WARNING: Unknown calling convention

gdouble gts_surface_volume(GtsSurface *s)

{
  double local_14 [2];
  
  local_14[0] = 0.0;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_face(s,volume_foreach_face,local_14);
    return local_14[0] / 6.0;
  }
  g_return_if_fail_warning(0,"gts_surface_volume","s != NULL");
  return 0.0;
}



// WARNING: Unknown calling convention

void gts_surface_merge(GtsSurface *s,GtsSurface *with)

{
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_merge","s != NULL");
    return;
  }
  if (with != (GtsSurface *)0x0) {
    gts_surface_foreach_face(with,merge_foreach_face,s);
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_merge","with != NULL");
  return;
}



// WARNING: Unknown calling convention

gdouble gts_surface_area(GtsSurface *s)

{
  gdouble local_14 [2];
  
  local_14[0] = 0.0;
  gts_surface_foreach_face(s,sum_area,local_14);
  return local_14[0];
}



// WARNING: Unknown calling convention

void gts_surface_foreach_edge(GtsSurface *s,GtsFunc func,gpointer data)

{
  gpointer info [3];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_edge","s != NULL");
    return;
  }
  if (func != (GtsFunc)0x0) {
    s->keep_faces = 1;
    info[0] = (gpointer)g_hash_table_new(0,0);
    info[2] = func;
    info[1] = data;
    g_hash_table_foreach(s->faces,edge_foreach_face,info);
    g_hash_table_destroy(info[0]);
    s->keep_faces = 0;
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_foreach_edge","func != NULL");
  return;
}



// WARNING: Unknown calling convention

GSList * gts_surface_split(GtsSurface *s)

{
  gpointer data [2];
  GSList *local_10;
  
  local_10 = (GSList *)0x0;
  if (s != (GtsSurface *)0x0) {
    data[1] = &local_10;
    data[0] = s;
    gts_surface_foreach_edge(s,traverse_boundary,data);
    gts_surface_foreach_face(s,traverse_remaining,data);
    return local_10;
  }
  g_return_if_fail_warning(0,"gts_surface_split","s != NULL");
  return (GSList *)0x0;
}



// WARNING: Unknown calling convention

GSList * gts_surface_boundary(GtsSurface *surface)

{
  gpointer data [2];
  GSList *local_10 [3];
  
  local_10[0] = (GSList *)0x0;
  if (surface != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = surface;
    gts_surface_foreach_edge(surface,surface_boundary,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_boundary","surface != NULL");
  return (GSList *)0x0;
}



// WARNING: Unknown calling convention

void gts_surface_distance
               (GtsSurface *s1,GtsSurface *s2,gdouble delta,GtsRange *face_range,
               GtsRange *boundary_range)

{
  GNode *pGVar1;
  GNode *boundary_tree;
  GSList *local_20 [4];
  
  if (s1 == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_distance","s1 != NULL");
    return;
  }
  if (s2 == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_distance","s2 != NULL");
    return;
  }
  if ((delta <= 0.0) || (1.0 <= delta)) {
    g_return_if_fail_warning(0,"gts_surface_distance","delta > 0. && delta < 1.");
    return;
  }
  if (face_range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_distance","face_range != NULL");
    return;
  }
  if (boundary_range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_distance","boundary_range != NULL");
    return;
  }
  local_20[0] = (GSList *)0x0;
  gts_surface_foreach_face(s2,build_list_face,local_20);
  if (local_20[0] == (GSList *)0x0) {
    gts_range_reset(face_range);
  }
  else {
    pGVar1 = gts_bb_tree_new(local_20[0]);
    g_slist_free(local_20[0]);
    gts_bb_tree_surface_distance(pGVar1,s1,gts_point_triangle_distance,delta,face_range);
    gts_bb_tree_destroy(pGVar1,1);
    local_20[0] = (GSList *)0x0;
    gts_surface_foreach_edge(s2,build_list_boundary,local_20);
    if (local_20[0] != (GSList *)0x0) {
      pGVar1 = gts_bb_tree_new(local_20[0]);
      g_slist_free(local_20[0]);
      gts_bb_tree_surface_boundary_distance
                (pGVar1,s1,gts_point_segment_distance,delta,boundary_range);
      gts_bb_tree_destroy(pGVar1,1);
      return;
    }
  }
  gts_range_reset(boundary_range);
  return;
}



// WARNING: Unknown calling convention

guint gts_surface_edge_number(GtsSurface *s)

{
  guint local_10 [3];
  
  local_10[0] = 0;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_edge(s,number_foreach,local_10);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_edge_number","s != NULL");
  return 0;
}



// WARNING: Unknown calling convention

gboolean gts_surface_is_orientable(GtsSurface *s)

{
  gpointer data [2];
  gboolean local_10 [3];
  
  local_10[0] = 1;
  if (s != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = s;
    gts_surface_foreach_edge(s,orientable_foreach_edge,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_is_orientable","s != NULL");
  return 0;
}



// WARNING: Unknown calling convention

gboolean gts_surface_is_closed(GtsSurface *s)

{
  gpointer data [2];
  gboolean local_10 [3];
  
  local_10[0] = 1;
  if (s != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = s;
    gts_surface_foreach_edge(s,closed_foreach_edge,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_is_closed","s != NULL");
  return 0;
}



// WARNING: Unknown calling convention

gboolean gts_surface_is_manifold(GtsSurface *s)

{
  gpointer data [2];
  gboolean local_10 [3];
  
  local_10[0] = 1;
  if (s != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = s;
    gts_surface_foreach_edge(s,manifold_foreach_edge,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_is_manifold","s != NULL");
  return 0;
}



// WARNING: Unknown calling convention

void gts_surface_quality_stats(GtsSurface *s,GtsSurfaceQualityStats *stats)

{
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_quality_stats","s != NULL");
  }
  else {
    if (stats != (GtsSurfaceQualityStats *)0x0) {
      stats->parent = s;
      gts_range_init(&stats->face_quality);
      gts_range_init(&stats->face_area);
      gts_range_init(&stats->edge_length);
      gts_range_init(&stats->edge_angle);
      gts_surface_foreach_edge(s,quality_foreach_edge,stats);
      gts_surface_foreach_face(s,quality_foreach_face,stats);
      gts_range_update(&stats->face_quality);
      gts_range_update(&stats->face_area);
      gts_range_update(&stats->edge_length);
      gts_range_update(&stats->edge_angle);
      return;
    }
    g_return_if_fail_warning(0,"gts_surface_quality_stats","stats != NULL");
  }
  return;
}



// WARNING: Unknown calling convention

void gts_surface_foreach_vertex(GtsSurface *s,GtsFunc func,gpointer data)

{
  gpointer info [3];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_vertex","s != NULL");
    return;
  }
  if (func != (GtsFunc)0x0) {
    s->keep_faces = 1;
    info[0] = (gpointer)g_hash_table_new(0,0);
    info[2] = func;
    info[1] = data;
    g_hash_table_foreach(s->faces,vertex_foreach_face,info);
    g_hash_table_destroy(info[0]);
    s->keep_faces = 0;
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_foreach_vertex","func != NULL");
  return;
}



// WARNING: Unknown calling convention

guint gts_surface_vertex_number(GtsSurface *s)

{
  guint local_10 [3];
  
  local_10[0] = 0;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_vertex(s,number_foreach,local_10);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_vertex_number","s != NULL");
  return 0;
}



// WARNING: Unknown calling convention

GtsSurface * gts_surface_copy(GtsSurface *s1,GtsSurface *s2)

{
  if (s1 == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_copy","s1 != NULL");
    return (GtsSurface *)0x0;
  }
  if (s2 != (GtsSurface *)0x0) {
    gts_surface_foreach_vertex(s2,foreach_vertex_copy,s1->vertex_class);
    gts_surface_foreach_edge(s2,foreach_edge_copy,s1->edge_class);
    gts_surface_foreach_face(s2,foreach_face_copy,s1);
    gts_surface_foreach_vertex(s2,gts_object_reset_reserved,(gpointer)0x0);
    gts_surface_foreach_edge(s2,gts_object_reset_reserved,(gpointer)0x0);
    return s1;
  }
  g_return_if_fail_warning(0,"gts_surface_copy","s2 != NULL");
  return (GtsSurface *)0x0;
}



// WARNING: Unknown calling convention

void gts_surface_stats(GtsSurface *s,GtsSurfaceStats *stats)

{
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_stats","s != NULL");
  }
  else {
    if (stats != (GtsSurfaceStats *)0x0) {
      stats->parent = s;
      stats->n_faces = 0;
      stats->n_incompatible_faces = 0;
      stats->n_duplicate_faces = 0;
      stats->n_duplicate_edges = 0;
      stats->n_boundary_edges = 0;
      stats->n_non_manifold_edges = 0;
      gts_range_init(&stats->edges_per_vertex);
      gts_range_init(&stats->faces_per_edge);
      gts_surface_foreach_vertex(s,stats_foreach_vertex,stats);
      gts_surface_foreach_edge(s,stats_foreach_edge,stats);
      gts_surface_foreach_face(s,stats_foreach_face,stats);
      gts_range_update(&stats->edges_per_vertex);
      gts_range_update(&stats->faces_per_edge);
      return;
    }
    g_return_if_fail_warning(0,"gts_surface_stats","stats != NULL");
  }
  return;
}



// WARNING: Unknown calling convention

void edge_foreach_face(GtsTriangle *t,gpointer t_data,gpointer *info)

{
  gpointer pvVar1;
  gpointer pvVar2;
  code *pcVar3;
  int iVar4;
  GHashTable *hash;
  GtsFunc func;
  
  pvVar1 = info[1];
  pvVar2 = *info;
  pcVar3 = (code *)info[2];
  iVar4 = g_hash_table_lookup(pvVar2,t->e1);
  if (iVar4 == 0) {
    (*pcVar3)(t->e1,pvVar1);
    g_hash_table_insert(pvVar2,t->e1,0xffffffff);
  }
  iVar4 = g_hash_table_lookup(pvVar2,t->e2);
  if (iVar4 == 0) {
    (*pcVar3)(t->e2,pvVar1);
    g_hash_table_insert(pvVar2,t->e2,0xffffffff);
  }
  iVar4 = g_hash_table_lookup(pvVar2,t->e3);
  if (iVar4 != 0) {
    return;
  }
  (*pcVar3)(t->e3,pvVar1);
  g_hash_table_insert();
  return;
}



// WARNING: Unknown calling convention

void vertex_foreach_face(GtsTriangle *t,gpointer t_data,gpointer *info)

{
  gpointer pvVar1;
  gpointer pvVar2;
  GtsEdge *pGVar3;
  code *pcVar4;
  int iVar5;
  GtsVertex *pGVar6;
  GHashTable *hash;
  GtsSegment *s1;
  
  pvVar1 = info[1];
  pvVar2 = *info;
  pGVar3 = t->e1;
  pcVar4 = (code *)info[2];
  iVar5 = g_hash_table_lookup(pvVar2,(pGVar3->segment).v1);
  if (iVar5 == 0) {
    (*pcVar4)((pGVar3->segment).v1,pvVar1);
    g_hash_table_insert(pvVar2,(pGVar3->segment).v1,0xffffffff);
  }
  iVar5 = g_hash_table_lookup(pvVar2,(pGVar3->segment).v2);
  if (iVar5 == 0) {
    (*pcVar4)((pGVar3->segment).v2,pvVar1);
    g_hash_table_insert(pvVar2,(pGVar3->segment).v2,0xffffffff);
  }
  pGVar6 = (t->e2->segment).v1;
  if (((t->e1->segment).v1 == pGVar6) || (pGVar6 == (t->e1->segment).v2)) {
    iVar5 = g_hash_table_lookup(pvVar2,(t->e2->segment).v2);
  }
  else {
    iVar5 = g_hash_table_lookup(pvVar2,pGVar6);
  }
  if (iVar5 == 0) {
    pGVar6 = (t->e2->segment).v1;
    if (((t->e1->segment).v1 == pGVar6) || (pGVar6 == (t->e1->segment).v2)) {
      pGVar6 = (t->e2->segment).v2;
    }
    (*pcVar4)(pGVar6,pvVar1);
    g_hash_table_insert();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void gts_surface_add_face(GtsSurface *s,GtsFace *f)

{
  code *UNRECOVERED_JUMPTABLE;
  int iVar1;
  GSList *pGVar2;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_add_face","s != NULL");
  }
  else {
    if (f == (GtsFace *)0x0) {
      g_return_if_fail_warning(0,"gts_surface_add_face","f != NULL");
      return;
    }
    if (s->keep_faces != 0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/gts/surface.c",0x99,"gts_surface_add_face","s->keep_faces == FALSE");
    }
    iVar1 = g_hash_table_lookup(s->faces,f);
    if (iVar1 == 0) {
      pGVar2 = (GSList *)g_slist_prepend(f->surfaces,s);
      f->surfaces = pGVar2;
      g_hash_table_insert(s->faces,f,f);
    }
    UNRECOVERED_JUMPTABLE = *(code **)(s->object).klass[1].info.name;
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0813212d. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)();
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void traverse_manifold(GtsTriangle *t,GtsSurface *s)

{
  GSList *pGVar1;
  GtsFace *pGVar2;
  uint uVar3;
  int iVar4;
  
  do {
    uVar3 = g_slist_length(*(GSList **)((int)t + 0x18));
    while( true ) {
      if (1 < uVar3) {
        return;
      }
      gts_surface_add_face(s,(GtsFace *)t);
      iVar4 = g_slist_length(((((GtsFace *)t)->triangle).e1)->triangles);
      if (iVar4 == 2) {
        pGVar1 = ((((GtsFace *)t)->triangle).e1)->triangles;
        pGVar2 = (GtsFace *)pGVar1->data;
        if (pGVar2 == (GtsFace *)t) {
          traverse_manifold((GtsTriangle *)pGVar1->next->data,s);
        }
        else {
          traverse_manifold((GtsTriangle *)pGVar2,s);
        }
      }
      iVar4 = g_slist_length(((((GtsFace *)t)->triangle).e2)->triangles);
      if (iVar4 == 2) {
        pGVar1 = ((((GtsFace *)t)->triangle).e2)->triangles;
        pGVar2 = (GtsFace *)pGVar1->data;
        if (pGVar2 == (GtsFace *)t) {
          traverse_manifold((GtsTriangle *)pGVar1->next->data,s);
        }
        else {
          traverse_manifold((GtsTriangle *)pGVar2,s);
        }
      }
      iVar4 = g_slist_length(((((GtsFace *)t)->triangle).e3)->triangles);
      if (iVar4 != 2) {
        return;
      }
      pGVar1 = ((((GtsFace *)t)->triangle).e3)->triangles;
      pGVar2 = (GtsFace *)pGVar1->data;
      if (pGVar2 == (GtsFace *)t) break;
      uVar3 = g_slist_length(pGVar2->surfaces);
      t = (GtsTriangle *)pGVar2;
    }
    t = (GtsTriangle *)pGVar1->next->data;
  } while( true );
}



// WARNING: Unknown calling convention

void merge_foreach_face(GtsFace *f,GtsSurface *s)

{
  gts_surface_add_face(s,f);
  return;
}



// WARNING: Unknown calling convention

void foreach_face_copy(GtsTriangle *t,GtsSurface *s)

{
  GtsFace *f;
  
  f = gts_face_new(s->face_class,(GtsEdge *)(t->e1->segment).object.reserved,
                   (GtsEdge *)(t->e2->segment).object.reserved,
                   (GtsEdge *)(t->e3->segment).object.reserved);
  gts_surface_add_face(s,f);
  return;
}



// WARNING: Unknown calling convention

void gts_surface_tessellate(GtsSurface *s,GtsRefineFunc refine_func,gpointer refine_data)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsEdge **ppGVar3;
  GtsObjectClass *pGVar4;
  GtsEdgeClass *klass;
  GtsVertexClass *pGVar5;
  int iVar6;
  GtsVertex *pGVar7;
  code *pcVar8;
  int *data;
  GSList *pGVar9;
  GtsEdge *e34;
  GSList *dum;
  GtsEdge *e15;
  GtsEdge *e26;
  GtsEdge *pGVar10;
  GtsEdge *pGVar11;
  GtsEdge *pGVar12;
  GtsFace *pGVar13;
  undefined4 uVar14;
  gpointer pvVar15;
  GtsVertex *v3;
  GtsEdge *e45;
  GtsEdge *e1;
  GtsEdge *e56;
  GtsTriangle *t;
  GtsEdge *e2;
  GtsEdge *e64;
  GtsVertex *local_50;
  GtsVertex *local_48;
  GtsVertex *local_44;
  GtsObjectClass *local_40;
  GtsObjectClass *local_3c;
  uint local_38;
  GtsVertex *local_34;
  GtsObjectClass *local_2c;
  GtsObjectClass *local_28;
  GtsObjectClass *local_24;
  GtsObjectClass *local_20;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  pcVar8 = unit_sphere_arc_midvertex;
  if (refine_func != (GtsRefineFunc)0x0) {
    pcVar8 = refine_func;
  }
  data = (int *)g_ptr_array_new();
  gts_surface_foreach_face(s,create_array_tessellate,data);
  if (data[1] != 0) {
    local_38 = 0;
    do {
      klass = s->edge_class;
      pGVar5 = s->vertex_class;
      iVar6 = *(int *)(*data + local_38 * 4);
      pGVar10 = *(GtsEdge **)(iVar6 + 0x14);
      pGVar11 = *(GtsEdge **)(iVar6 + 0xc);
      pGVar12 = *(GtsEdge **)(iVar6 + 0x10);
      pGVar7 = (pGVar11->segment).v2;
      local_20 = (GtsObjectClass *)(pGVar12->segment).v1;
      if ((GtsObjectClass *)pGVar7 == local_20) {
        local_50 = (pGVar11->segment).v1;
        local_28 = (GtsObjectClass *)(pGVar12->segment).v2;
      }
      else {
        pGVar1 = (pGVar12->segment).v2;
        if (pGVar7 == pGVar1) {
          local_50 = (pGVar11->segment).v1;
          local_28 = local_20;
          local_20 = (GtsObjectClass *)pGVar7;
        }
        else {
          pGVar2 = (pGVar11->segment).v1;
          local_50 = pGVar7;
          local_28 = (GtsObjectClass *)pGVar1;
          if ((local_20 != (GtsObjectClass *)pGVar2) &&
             (local_28 = local_20, local_20 = (GtsObjectClass *)pGVar2, pGVar1 != pGVar2)) {
                    // WARNING: Subroutine does not return
            g_assertion_message(0,"../../src/gts/surface.c",0x763,"tessellate_face",0);
          }
        }
      }
      pGVar9 = (GSList *)g_slist_remove(pGVar11->triangles,iVar6);
      pGVar11->triangles = pGVar9;
      pGVar9 = (GSList *)g_slist_remove(pGVar12->triangles,iVar6);
      pGVar12->triangles = pGVar9;
      pGVar9 = (GSList *)g_slist_remove(pGVar10->triangles,iVar6);
      pGVar10->triangles = pGVar9;
      ppGVar3 = *(GtsEdge ***)&pGVar11->segment;
      if (ppGVar3 == (GtsEdge **)0x0) {
        local_44 = (*pcVar8)(pGVar11,pGVar5,refine_data);
        local_3c = (GtsObjectClass *)gts_edge_new(klass,local_50,local_44);
        local_2c = (GtsObjectClass *)gts_edge_new(klass,(GtsVertex *)local_20,local_44);
        uVar14 = g_slist_append(0,local_3c);
        pvVar15 = (gpointer)g_slist_append(uVar14,local_2c);
        *(gpointer *)&pGVar11->segment = pvVar15;
      }
      else {
        local_2c = (GtsObjectClass *)*ppGVar3;
        pGVar4 = (ppGVar3[1]->segment).object.klass;
        local_44 = ((GtsSegment *)&local_2c->info)->v2;
        local_3c = pGVar4;
        if ((GtsObjectClass *)((GtsSegment *)&local_2c->info)->v1 != local_20) {
          local_3c = local_2c;
          local_2c = pGVar4;
        }
      }
      ppGVar3 = *(GtsEdge ***)&pGVar12->segment;
      if (ppGVar3 == (GtsEdge **)0x0) {
        local_48 = (*pcVar8)(pGVar12,pGVar5,refine_data);
        local_40 = (GtsObjectClass *)gts_edge_new(klass,(GtsVertex *)local_20,local_48);
        local_24 = (GtsObjectClass *)gts_edge_new(klass,(GtsVertex *)local_28,local_48);
        uVar14 = g_slist_append(0,local_40);
        pvVar15 = (gpointer)g_slist_append(uVar14,local_24);
        *(gpointer *)&pGVar12->segment = pvVar15;
      }
      else {
        local_24 = (GtsObjectClass *)*ppGVar3;
        pGVar4 = (ppGVar3[1]->segment).object.klass;
        local_48 = ((GtsSegment *)&local_24->info)->v2;
        local_40 = pGVar4;
        if ((GtsObjectClass *)((GtsSegment *)&local_24->info)->v1 != local_28) {
          local_40 = local_24;
          local_24 = pGVar4;
        }
      }
      ppGVar3 = *(GtsEdge ***)&pGVar10->segment;
      if (ppGVar3 == (GtsEdge **)0x0) {
        local_34 = (*pcVar8)(pGVar10,pGVar5,refine_data);
        local_28 = (GtsObjectClass *)gts_edge_new(klass,(GtsVertex *)local_28,local_34);
        local_20 = (GtsObjectClass *)gts_edge_new(klass,local_50,local_34);
        uVar14 = g_slist_append(0,local_28);
        pvVar15 = (gpointer)g_slist_append(uVar14,local_20);
        *(gpointer *)&pGVar10->segment = pvVar15;
        if (pGVar11->triangles == (GSList *)0x0) goto LAB_08132758;
LAB_081324d3:
        pGVar9 = pGVar12->triangles;
      }
      else {
        local_20 = (GtsObjectClass *)*ppGVar3;
        pGVar4 = (ppGVar3[1]->segment).object.klass;
        local_34 = (((GtsEdge *)local_20)->segment).v2;
        local_28 = pGVar4;
        if (local_50 != (((GtsEdge *)local_20)->segment).v1) {
          local_28 = local_20;
          local_20 = pGVar4;
        }
        if (pGVar11->triangles != (GSList *)0x0) goto LAB_081324d3;
LAB_08132758:
        g_slist_free(*(gpointer *)&pGVar11->segment);
        *(gpointer *)&pGVar11->segment = (gpointer)0x0;
        gts_object_destroy((GtsObject *)pGVar11);
        pGVar9 = pGVar12->triangles;
      }
      if (pGVar9 == (GSList *)0x0) {
        g_slist_free(*(gpointer *)&pGVar12->segment);
        *(gpointer *)&pGVar12->segment = (gpointer)0x0;
        gts_object_destroy((GtsObject *)pGVar12);
      }
      if (pGVar10->triangles == (GSList *)0x0) {
        g_slist_free(*(gpointer *)&pGVar10->segment);
        *(gpointer *)&pGVar10->segment = (gpointer)0x0;
        gts_object_destroy((GtsObject *)pGVar10);
      }
      pGVar10 = gts_edge_new(klass,local_48,local_34);
      pGVar11 = gts_edge_new(klass,local_34,local_44);
      pGVar12 = gts_edge_new(klass,local_44,local_48);
      *(GtsEdge **)(iVar6 + 0xc) = pGVar10;
      pGVar9 = (GSList *)g_slist_prepend(pGVar10->triangles,iVar6);
      *(GtsEdge **)(iVar6 + 0x10) = pGVar11;
      pGVar10->triangles = pGVar9;
      pGVar9 = (GSList *)g_slist_prepend(pGVar11->triangles,iVar6);
      *(GtsEdge **)(iVar6 + 0x14) = pGVar12;
      pGVar11->triangles = pGVar9;
      pGVar9 = (GSList *)g_slist_prepend(pGVar12->triangles,iVar6);
      pGVar12->triangles = pGVar9;
      pGVar13 = gts_face_new(s->face_class,(GtsEdge *)local_28,pGVar10,(GtsEdge *)local_24);
      gts_surface_add_face(s,pGVar13);
      pGVar13 = gts_face_new(s->face_class,(GtsEdge *)local_20,(GtsEdge *)local_3c,pGVar11);
      gts_surface_add_face(s,pGVar13);
      pGVar13 = gts_face_new(s->face_class,pGVar12,(GtsEdge *)local_2c,(GtsEdge *)local_40);
      gts_surface_add_face(s,pGVar13);
      local_38 = local_38 + 1;
    } while (local_38 <= (uint)data[1] && data[1] != local_38);
  }
  g_ptr_array_free();
  return;
}



// WARNING: Unknown calling convention

GtsSurface * gts_surface_generate_sphere(GtsSurface *s,guint geodesation_order)

{
  GtsVertex *v1;
  GtsVertex *v2;
  GtsVertex *v1_00;
  GtsVertex *v2_00;
  GtsVertex *v2_01;
  GtsVertex *v1_01;
  GtsVertex *v1_02;
  GtsVertex *v1_03;
  GtsVertex *v2_02;
  GtsVertex *v2_03;
  GtsVertex *v2_04;
  GtsVertex *v1_04;
  GtsEdge *e2;
  GtsEdge *e2_00;
  GtsEdge *e3;
  GtsEdge *e2_01;
  GtsEdge *e2_02;
  GtsEdge *e2_03;
  GtsEdge *e3_00;
  GtsEdge *e2_04;
  GtsEdge *e1;
  GtsEdge *e1_00;
  GtsEdge *e2_05;
  GtsEdge *e3_01;
  GtsEdge *e3_02;
  GtsEdge *e2_06;
  GtsEdge *e3_03;
  GtsEdge *e2_07;
  GtsEdge *e3_04;
  GtsEdge *e2_08;
  GtsEdge *e2_09;
  GtsEdge *e2_10;
  GtsEdge *e3_05;
  GtsEdge *e1_01;
  GtsEdge *e3_06;
  GtsEdge *e1_02;
  GtsEdge *e2_11;
  GtsEdge *e3_07;
  GtsEdge *e2_12;
  GtsEdge *e2_13;
  GtsEdge *e3_08;
  GtsEdge *e3_09;
  GtsFace *pGVar1;
  GtsEdge *e29;
  GtsVertex *v02;
  uint uVar2;
  guint cgo;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_generate_sphere","s != NULL");
    return (GtsSurface *)0x0;
  }
  if (geodesation_order == 0) {
    s = (GtsSurface *)0x0;
    g_return_if_fail_warning(0,"gts_surface_generate_sphere","geodesation_order != 0");
  }
  else {
    v1 = gts_vertex_new(s->vertex_class,0.0,0.8506508083520399,-0.5257311121191336);
    v2 = gts_vertex_new(s->vertex_class,0.8506508083520399,0.5257311121191336,0.0);
    v1_00 = gts_vertex_new(s->vertex_class,0.5257311121191336,0.0,-0.8506508083520399);
    v2_00 = gts_vertex_new(s->vertex_class,0.5257311121191336,0.0,0.8506508083520399);
    v2_01 = gts_vertex_new(s->vertex_class,0.8506508083520399,-0.5257311121191336,0.0);
    v1_01 = gts_vertex_new(s->vertex_class,0.0,0.8506508083520399,0.5257311121191336);
    v1_02 = gts_vertex_new(s->vertex_class,-0.5257311121191336,0.0,0.8506508083520399);
    v1_03 = gts_vertex_new(s->vertex_class,0.0,-0.8506508083520399,-0.5257311121191336);
    v2_02 = gts_vertex_new(s->vertex_class,-0.8506508083520399,0.5257311121191336,0.0);
    v2_03 = gts_vertex_new(s->vertex_class,-0.5257311121191336,0.0,-0.8506508083520399);
    v2_04 = gts_vertex_new(s->vertex_class,-0.8506508083520399,-0.5257311121191336,0.0);
    v1_04 = gts_vertex_new(s->vertex_class,0.0,-0.8506508083520399,0.5257311121191336);
    e2 = gts_edge_new(s->edge_class,v1,v2);
    e2_00 = gts_edge_new(s->edge_class,v1_00,v2);
    e3 = gts_edge_new(s->edge_class,v1,v1_00);
    e2_01 = gts_edge_new(s->edge_class,v2_00,v2_01);
    e2_02 = gts_edge_new(s->edge_class,v2,v2_01);
    e2_03 = gts_edge_new(s->edge_class,v2_00,v2);
    e3_00 = gts_edge_new(s->edge_class,v1_01,v1_02);
    e2_04 = gts_edge_new(s->edge_class,v2_00,v1_02);
    e1 = gts_edge_new(s->edge_class,v1_01,v2_00);
    e1_00 = gts_edge_new(s->edge_class,v1_03,v1_00);
    e2_05 = gts_edge_new(s->edge_class,v1_00,v2_01);
    e3_01 = gts_edge_new(s->edge_class,v1_03,v2_01);
    e3_02 = gts_edge_new(s->edge_class,v1_01,v2_02);
    e2_06 = gts_edge_new(s->edge_class,v1_02,v2_02);
    e3_03 = gts_edge_new(s->edge_class,v1_03,v2_03);
    e2_07 = gts_edge_new(s->edge_class,v1_00,v2_03);
    e3_04 = gts_edge_new(s->edge_class,v1_01,v1);
    e2_08 = gts_edge_new(s->edge_class,v1,v2_02);
    e2_09 = gts_edge_new(s->edge_class,v1_03,v2_04);
    e2_10 = gts_edge_new(s->edge_class,v2_03,v2_04);
    e3_05 = gts_edge_new(s->edge_class,v1_01,v2);
    e1_01 = gts_edge_new(s->edge_class,v1_04,v2_04);
    e3_06 = gts_edge_new(s->edge_class,v1_04,v1_03);
    e1_02 = gts_edge_new(s->edge_class,v1_04,v1_02);
    e2_11 = gts_edge_new(s->edge_class,v1_02,v2_04);
    e3_07 = gts_edge_new(s->edge_class,v1_04,v2_00);
    e2_12 = gts_edge_new(s->edge_class,v2_02,v2_04);
    e2_13 = gts_edge_new(s->edge_class,v2_03,v2_02);
    e3_08 = gts_edge_new(s->edge_class,v1_04,v2_01);
    e3_09 = gts_edge_new(s->edge_class,v1,v2_03);
    pGVar1 = gts_face_new(s->face_class,e2,e2_00,e3);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e2_01,e2_02,e2_03);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_00,e2_04,e1);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e1_00,e2_05,e3_01);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_02,e2_06,e3_00);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_03,e2_07,e1_00);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_04,e2_08,e3_02);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e2_09,e2_10,e3_03);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_05,e2,e3_04);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e1_01,e2_09,e3_06);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e1,e2_03,e3_05);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e1_02,e2_11,e1_01);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_07,e2_04,e1_02);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e2_10,e2_12,e2_13);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_08,e2_01,e3_07);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e2_06,e2_12,e2_11);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_06,e3_01,e3_08);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e2_00,e2_02,e2_05);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3_09,e2_13,e2_08);
    gts_surface_add_face(s,pGVar1);
    pGVar1 = gts_face_new(s->face_class,e3,e2_07,e3_09);
    gts_surface_add_face(s,pGVar1);
    if (1 < geodesation_order) {
      uVar2 = 1;
      do {
        uVar2 = uVar2 + 1;
        gts_surface_tessellate(s,(GtsRefineFunc)0x0,(gpointer)0x0);
      } while (uVar2 < geodesation_order);
      return s;
    }
  }
  return s;
}



// WARNING: Unknown calling convention

void gts_surface_refine(GtsSurface *surface,GtsKeyFunc cost_func,gpointer cost_data,
                       GtsRefineFunc refine_func,gpointer refine_data,GtsStopFunc stop_func,
                       gpointer stop_data)

{
  GtsEdgeClass *klass;
  GtsTriangle *t_00;
  GtsEHeap *heap;
  GtsEdge *pGVar1;
  guint gVar2;
  guint gVar3;
  gboolean gVar4;
  GtsVertex *v2;
  GtsEdge *p;
  GtsEdge *e3;
  GtsEdge *ne;
  GtsFace *f;
  GSList *i;
  code *pcVar5;
  GtsEdge *e1;
  GSList *pGVar6;
  GtsTriangle *t;
  GtsEdge *e2;
  GSList *local_70;
  gdouble local_3c;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *v1;
  GtsEdge *local_20 [4];
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_refine","surface != NULL");
    return;
  }
  if (stop_func == (GtsStopFunc)0x0) {
    g_return_if_fail_warning(0,"gts_surface_refine","stop_func != NULL");
    return;
  }
  if (cost_func == (GtsKeyFunc)0x0) {
    cost_func = edge_length2_inverse;
  }
  pcVar5 = gts_segment_midvertex;
  if (refine_func != (GtsRefineFunc)0x0) {
    pcVar5 = refine_func;
  }
  heap = gts_eheap_new(cost_func,cost_data);
  gts_eheap_freeze(heap);
  gts_surface_foreach_edge(surface,create_heap_refine,heap);
  gts_eheap_thaw(heap);
  while (pGVar1 = (GtsEdge *)gts_eheap_remove_top(heap,&local_3c), pGVar1 != (GtsEdge *)0x0) {
    gVar2 = gts_eheap_size(heap);
    gVar3 = gts_edge_face_number(pGVar1,surface);
    gVar4 = (*stop_func)(local_3c,gVar3 + 2 + gVar2,stop_data);
    if (gVar4 != 0) break;
    klass = surface->edge_class;
    local_20[0] = pGVar1;
    v2 = (*pcVar5)(pGVar1,surface->vertex_class,refine_data);
    p = gts_edge_new(klass,(local_20[0]->segment).v1,v2);
    gts_eheap_insert(heap,p);
    pGVar1 = gts_edge_new(klass,(local_20[0]->segment).v2,v2);
    pGVar6 = (GSList *)0x0;
    gts_eheap_insert(heap,pGVar1);
    local_70 = local_20[0]->triangles;
    if (local_70 != (GSList *)0x0) {
      do {
        t_00 = (GtsTriangle *)local_70->data;
        gts_triangle_vertices_edges
                  (t_00,local_20[0],&v1,&local_28,&local_2c,local_20,&local_30,&local_34);
        e3 = gts_edge_new(klass,v2,local_2c);
        gts_eheap_insert(heap,e3);
        e1 = p;
        if ((p->segment).v1 != local_28) {
          e1 = pGVar1;
          pGVar1 = p;
        }
        p = pGVar1;
        pGVar6 = (GSList *)g_slist_prepend(p->triangles);
        p->triangles = pGVar6;
        pGVar6 = (GSList *)g_slist_prepend(e3->triangles);
        pGVar1 = local_30;
        e3->triangles = pGVar6;
        pGVar6 = (GSList *)g_slist_remove(local_30->triangles);
        t_00->e2 = e3;
        t_00->e1 = p;
        pGVar1->triangles = pGVar6;
        t_00->e3 = local_34;
        f = gts_face_new(surface->face_class,e1,local_30,e3);
        gts_surface_add_face(surface,f);
        local_70 = (GSList *)(&local_70->data)[1];
        pGVar1 = e1;
      } while (local_70 != (GSList *)0x0);
      pGVar6 = local_20[0]->triangles;
    }
    g_slist_free(pGVar6);
    local_20[0]->triangles = (GSList *)0x0;
    gts_object_destroy((GtsObject *)local_20[0]);
  }
  gts_eheap_destroy(heap);
  return;
}



// WARNING: Unknown calling convention

void gts_surface_write_oogl_boundary(GtsSurface *s,FILE *fptr)

{
  gpointer data [2];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write_oogl_boundary","s != NULL");
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[0] = fptr;
    data[1] = s;
    fwrite("LIST {\n",1,7,(FILE *)fptr);
    gts_surface_foreach_edge(s,write_edge_oogl_boundary,data);
    fwrite("}\n",1,2,(FILE *)fptr);
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_write_oogl_boundary","fptr != NULL");
  return;
}



// WARNING: Unknown calling convention

void write_edge_oogl_boundary(GtsSegment *s,gpointer *data)

{
  gdouble gVar1;
  gdouble gVar2;
  gdouble gVar3;
  gdouble gVar4;
  gdouble gVar5;
  gdouble gVar6;
  _func_GtsColor_GtsObject_ptr *p_Var7;
  GtsVertex *pGVar8;
  GtsVertex *pGVar9;
  GtsFace *pGVar10;
  GtsColor c;
  
  pGVar10 = gts_edge_is_boundary((GtsEdge *)s,(GtsSurface *)data[1]);
  if (pGVar10 != (GtsFace *)0x0) {
    p_Var7 = ((s->object).klass)->color;
    if (p_Var7 == (_func_GtsColor_GtsObject_ptr *)0x0) {
      pGVar8 = s->v2;
      pGVar9 = s->v1;
      gVar1 = (pGVar8->p).z;
      gVar2 = (pGVar8->p).y;
      gVar3 = (pGVar8->p).x;
      gVar4 = (pGVar9->p).z;
      gVar5 = (pGVar9->p).y;
      gVar6 = (pGVar9->p).x;
      __fprintf_chk(*data,1,"VECT 1 2 0 2 0 %g %g %g %g %g %g\n",SUB84(gVar6,0),
                    (int)((ulonglong)gVar6 >> 0x20),SUB84(gVar5,0),(int)((ulonglong)gVar5 >> 0x20),
                    SUB84(gVar4,0),(int)((ulonglong)gVar4 >> 0x20),SUB84(gVar3,0),
                    (int)((ulonglong)gVar3 >> 0x20),SUB84(gVar2,0),(int)((ulonglong)gVar2 >> 0x20),
                    SUB84(gVar1,0),(int)((ulonglong)gVar1 >> 0x20));
      return;
    }
    (*p_Var7)(&c,&s->object);
    pGVar8 = s->v1;
    pGVar9 = s->v2;
    gVar1 = (pGVar9->p).z;
    gVar2 = (pGVar9->p).y;
    gVar3 = (pGVar9->p).x;
    gVar4 = (pGVar8->p).z;
    gVar5 = (pGVar8->p).y;
    gVar6 = (pGVar8->p).x;
    __fprintf_chk(*data,1,"VECT 1 2 1 2 1 %g %g %g %g %g %g %g %g %g 1.\n",SUB84(gVar6,0),
                  (int)((ulonglong)gVar6 >> 0x20),SUB84(gVar5,0),(int)((ulonglong)gVar5 >> 0x20),
                  SUB84(gVar4,0),(int)((ulonglong)gVar4 >> 0x20),SUB84(gVar3,0),
                  (int)((ulonglong)gVar3 >> 0x20),SUB84(gVar2,0),(int)((ulonglong)gVar2 >> 0x20),
                  SUB84(gVar1,0),(int)((ulonglong)gVar1 >> 0x20),(double)c.r,(double)c.g,(double)c.b
                 );
  }
  return;
}



// WARNING: Unknown calling convention

void gts_surface_write_vtk(GtsSurface *s,FILE *fptr)

{
  GtsSurfaceStats stats;
  gpointer data [2];
  undefined4 local_10;
  
  local_10 = 0;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write_vtk","s != NULL");
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[1] = &local_10;
    data[0] = fptr;
    gts_surface_stats(s,&stats);
    __fprintf_chk(fptr,1,
                  "# vtk DataFile Version 2.0\nGenerated by GTS\nASCII\nDATASET POLYDATA\nPOINTS %u float\n"
                  ,stats.edges_per_vertex.n);
    gts_surface_foreach_vertex(s,write_vertex_vtk,data);
    __fprintf_chk(fptr,1,"POLYGONS %u %u\n",stats.n_faces,stats.n_faces * 4);
    gts_surface_foreach_face(s,write_face_vtk,fptr);
    gts_surface_foreach_vertex(s,gts_object_reset_reserved,(gpointer)0x0);
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_write_vtk","fptr != NULL");
  return;
}



// WARNING: Unknown calling convention

void write_face_vtk(GtsTriangle *t,FILE *fp)

{
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [3];
  
  gts_triangle_vertices(t,local_10,&local_14,&local_18);
  __fprintf_chk(fp,1,"3 %u %u %u\n",(local_10[0]->p).object.reserved,(local_14->p).object.reserved,
                (local_18->p).object.reserved);
  return;
}



// WARNING: Unknown calling convention

void write_vertex_vtk(GtsPoint *p,gpointer *data)

{
  gpointer *ppvVar1;
  gpointer pvVar2;
  
  __fprintf_chk(*data,1,"%g %g %g\n",p->x,p->y,p->z);
  ppvVar1 = (gpointer *)data[1];
  pvVar2 = *ppvVar1;
  (p->object).reserved = pvVar2;
  *ppvVar1 = (gpointer)((int)pvVar2 + 1);
  return;
}



// WARNING: Unknown calling convention

void gts_surface_write_oogl(GtsSurface *s,FILE *fptr)

{
  GtsSurfaceStats stats;
  gpointer data [2];
  undefined4 local_10;
  
  local_10 = 0;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write_oogl","s != NULL");
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[1] = &local_10;
    data[0] = fptr;
    gts_surface_stats(s,&stats);
    if ((s->vertex_class->parent_class).parent_class.color == (_func_GtsColor_GtsObject_ptr *)0x0) {
      fwrite(&DAT_081612cd,1,4,(FILE *)fptr);
    }
    else {
      fwrite(&DAT_081612cc,1,5,(FILE *)fptr);
    }
    __fprintf_chk(fptr,1,"%u %u %u\n",stats.edges_per_vertex.n,stats.n_faces,stats.faces_per_edge.n)
    ;
    gts_surface_foreach_vertex(s,write_vertex_oogl,data);
    gts_surface_foreach_face(s,write_face_oogl,fptr);
    gts_surface_foreach_vertex(s,gts_object_reset_reserved,(gpointer)0x0);
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_write_oogl","fptr != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_range_print(GtsRange *r,FILE *fptr)

{
  if (r == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_range_print","r != NULL");
    return;
  }
  if (fptr != (FILE *)0x0) {
    __fprintf_chk(fptr,1,"min: %g mean: %g | %g max: %g",r->min,r->mean,r->stddev,r->max);
    return;
  }
  g_return_if_fail_warning(0,"gts_range_print","fptr != NULL");
  return;
}



// WARNING: Unknown calling convention

void surface_write(GtsObject *object,FILE *fptr)

{
  GtsObjectClass *pGVar1;
  
  pGVar1 = (GtsObjectClass *)"GtsVertexBinary";
  if (*(int *)object[2].klass[1].info.name == 0) {
    pGVar1 = object[2].klass;
  }
  __fprintf_chk(fptr,1," %s %s %s %s",object->klass,object[1].reserved,object[1].flags,pGVar1);
  return;
}



// WARNING: Unknown calling convention

void write_face_oogl(GtsTriangle *t,FILE *fp)

{
  _func_GtsColor_GtsObject_ptr *p_Var1;
  GtsColor c;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10;
  
  gts_triangle_vertices(t,&local_10,&local_14,&local_18);
  __fprintf_chk(fp,1,"3 %u %u %u",(local_10->p).object.reserved,(local_14->p).object.reserved,
                (local_18->p).object.reserved);
  p_Var1 = ((t->object).klass)->color;
  if (p_Var1 != (_func_GtsColor_GtsObject_ptr *)0x0) {
    (*p_Var1)(&c,&t->object);
    __fprintf_chk(fp,1,&DAT_08161318,(double)c.r,(double)c.g,(double)c.b);
    return;
  }
  fputc(10,(FILE *)fp);
  return;
}



// WARNING: Unknown calling convention

void write_vertex_oogl(GtsPoint *p,gpointer *data)

{
  FILE *__stream;
  _func_GtsColor_GtsObject_ptr *p_Var1;
  gpointer *ppvVar2;
  gpointer pvVar3;
  FILE *fp;
  GtsColor c;
  
  __stream = (FILE *)*data;
  __fprintf_chk(__stream,1,"%g %g %g",SUB84(p->x,0),(int)((ulonglong)p->x >> 0x20),SUB84(p->y,0),
                (int)((ulonglong)p->y >> 0x20),SUB84(p->z,0),(int)((ulonglong)p->z >> 0x20));
  p_Var1 = ((p->object).klass)->color;
  if (p_Var1 == (_func_GtsColor_GtsObject_ptr *)0x0) {
    fputc(10,__stream);
  }
  else {
    (*p_Var1)(&c,&p->object);
    __fprintf_chk(__stream,1," %g %g %g 1.0\n",(double)c.r,(double)c.g,(double)c.b);
  }
  ppvVar2 = (gpointer *)data[1];
  pvVar3 = *ppvVar2;
  (p->object).reserved = pvVar3;
  *ppvVar2 = (gpointer)((int)pvVar3 + 1);
  return;
}



// WARNING: Unknown calling convention

void gts_surface_write(GtsSurface *s,FILE *fptr)

{
  _func_void_GtsObject_ptr_FILE_ptr *p_Var1;
  gpointer pvVar2;
  gpointer pvVar3;
  GtsSurfaceStats stats;
  gpointer data [4];
  undefined4 local_20 [4];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write","s != NULL");
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[1] = local_20;
    data[0] = fptr;
    pvVar2 = (gpointer)g_hash_table_new(0,0);
    data[2] = pvVar2;
    pvVar3 = (gpointer)g_hash_table_new(0,0);
    data[3] = pvVar3;
    gts_surface_stats(s,&stats);
    __fprintf_chk(fptr,1,"%u %u %u",stats.edges_per_vertex.n,stats.faces_per_edge.n,stats.n_faces);
    p_Var1 = ((s->object).klass)->write;
    if (p_Var1 != (_func_void_GtsObject_ptr_FILE_ptr *)0x0) {
      (*p_Var1)(&s->object,fptr);
    }
    fputc(10,(FILE *)fptr);
    local_20[0] = 0;
    gts_surface_foreach_vertex(s,write_vertex,data);
    local_20[0] = 0;
    if ((s->vertex_class->parent_class).binary != 0) {
      fputc(10,(FILE *)fptr);
    }
    gts_surface_foreach_edge(s,write_edge,data);
    gts_surface_foreach_face(s,write_face,data);
    g_hash_table_destroy(pvVar2);
    g_hash_table_destroy(pvVar3);
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_write","fptr != NULL");
  return;
}



// WARNING: Unknown calling convention

void write_face(GtsTriangle *t,gpointer *data)

{
  _func_void_GtsObject_ptr_FILE_ptr *p_Var1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  
  uVar2 = g_hash_table_lookup(data[3],t->e3);
  uVar3 = g_hash_table_lookup(data[3],t->e2);
  uVar4 = g_hash_table_lookup(data[3],t->e1);
  __fprintf_chk(*data,1,"%u %u %u",uVar4,uVar3,uVar2);
  p_Var1 = ((t->object).klass)->write;
  if (p_Var1 != (_func_void_GtsObject_ptr_FILE_ptr *)0x0) {
    (*p_Var1)(&t->object,(FILE *)*data);
  }
  fputc(10,(FILE *)*data);
  return;
}



// WARNING: Unknown calling convention

void write_edge(GtsSegment *s,gpointer *data)

{
  _func_void_GtsObject_ptr_FILE_ptr *p_Var1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  
  uVar2 = g_hash_table_lookup(data[2],s->v2);
  uVar3 = g_hash_table_lookup(data[2],s->v1);
  __fprintf_chk(*data,1,"%u %u",uVar3,uVar2);
  p_Var1 = ((s->object).klass)->write;
  if (p_Var1 != (_func_void_GtsObject_ptr_FILE_ptr *)0x0) {
    (*p_Var1)(&s->object,(FILE *)*data);
  }
  fputc(10,(FILE *)*data);
                    // WARNING: Load size is inaccurate
  iVar4 = *data[1] + 1;
  *(int *)data[1] = iVar4;
  g_hash_table_insert(data[3],s,iVar4);
  return;
}



// WARNING: Unknown calling convention

void write_vertex(GtsPoint *p,gpointer *data)

{
  int iVar1;
  
  (*((p->object).klass)->write)(&p->object,(FILE *)*data);
  if (*(int *)(p->object).klass[1].info.name == 0) {
    fputc(10,(FILE *)*data);
  }
                    // WARNING: Load size is inaccurate
  iVar1 = *data[1] + 1;
  *(int *)data[1] = iVar1;
  g_hash_table_insert(data[2],p,iVar1);
  return;
}



// WARNING: Unknown calling convention

void gts_surface_print_stats(GtsSurface *s,FILE *fptr)

{
  GtsSurfaceQualityStats qstats;
  GtsSurfaceStats stats;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_print_stats","s != NULL");
    return;
  }
  if (fptr != (FILE *)0x0) {
    gts_surface_stats(s,&stats);
    gts_surface_quality_stats(s,&qstats);
    __fprintf_chk(fptr,1,
                  "# vertices: %u edges: %u faces: %u\n# Connectivity statistics\n#   incompatible faces: %u\n#   duplicate faces: %u\n#   boundary edges: %u\n#   duplicate edges: %u\n#   non-manifold edges: %u\n"
                  ,stats.edges_per_vertex.n,stats.faces_per_edge.n,stats.n_faces,
                  stats.n_incompatible_faces,stats.n_duplicate_faces,stats.n_boundary_edges,
                  stats.n_duplicate_edges,stats.n_non_manifold_edges);
    fwrite("#   edges per vertex: ",1,0x16,(FILE *)fptr);
    gts_range_print(&stats.edges_per_vertex,fptr);
    fwrite("\n#   faces per edge: ",1,0x15,(FILE *)fptr);
    gts_range_print(&stats.faces_per_edge,fptr);
    fwrite("\n# Geometric statistics\n#   face quality: ",1,0x2a,(FILE *)fptr);
    gts_range_print(&qstats.face_quality,fptr);
    fwrite("\n#   face area  : ",1,0x12,(FILE *)fptr);
    gts_range_print(&qstats.face_area,fptr);
    fwrite("\n#   edge length : ",1,0x13,(FILE *)fptr);
    gts_range_print(&qstats.edge_length,fptr);
    fputc(10,(FILE *)fptr);
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_print_stats","fptr != NULL");
  return;
}



// WARNING: Unknown calling convention

void quality_foreach_face(GtsTriangle *t,GtsSurfaceQualityStats *stats)

{
  gdouble gVar1;
  
  gVar1 = gts_triangle_quality(t);
  gts_range_add_value(&stats->face_quality,gVar1);
  gVar1 = gts_triangle_area(t);
  gts_range_add_value(&stats->face_area,gVar1);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void quality_foreach_edge(GtsSegment *s,GtsSurfaceQualityStats *stats)

{
  GSList *j;
  GtsTriangle *pGVar1;
  GSList *i;
  GtsObjectClass *pGVar2;
  gdouble gVar3;
  
  pGVar2 = s[1].object.klass;
  gVar3 = gts_point_distance(&s->v1->p,&s->v2->p);
  gts_range_add_value(&stats->edge_length,gVar3);
  if (pGVar2 != (GtsObjectClass *)0x0) {
    do {
      pGVar1 = *(GtsTriangle **)((pGVar2->info).name + 4);
      if (pGVar1 == (GtsTriangle *)0x0) {
        return;
      }
      do {
        gVar3 = gts_triangles_angle(*(GtsTriangle **)(pGVar2->info).name,
                                    *(GtsTriangle **)&pGVar1->object);
        gts_range_add_value(&stats->edge_angle,ABS(gVar3));
        pGVar1 = *(GtsTriangle **)((int)&pGVar1->object + 4);
      } while (pGVar1 != (GtsTriangle *)0x0);
      pGVar2 = *(GtsObjectClass **)((pGVar2->info).name + 4);
    } while (pGVar2 != (GtsObjectClass *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void stats_foreach_face(GtsTriangle *t,GtsSurfaceStats *stats)

{
  gboolean gVar1;
  GtsTriangle *pGVar2;
  
  gVar1 = gts_face_is_compatible((GtsFace *)t,stats->parent);
  if (gVar1 == 0) {
    stats->n_incompatible_faces = stats->n_incompatible_faces + 1;
  }
  pGVar2 = gts_triangle_is_duplicate(t);
  if (pGVar2 != (GtsTriangle *)0x0) {
    stats->n_duplicate_faces = stats->n_duplicate_faces + 1;
  }
  stats->n_faces = stats->n_faces + 1;
  return;
}



// WARNING: Unknown calling convention

void stats_foreach_edge(GtsEdge *e,GtsSurfaceStats *stats)

{
  guint gVar1;
  GtsSegment *pGVar2;
  guint nt;
  
  gVar1 = gts_edge_face_number(e,stats->parent);
  pGVar2 = gts_segment_is_duplicate(&e->segment);
  if (pGVar2 != (GtsSegment *)0x0) {
    stats->n_duplicate_edges = stats->n_duplicate_edges + 1;
  }
  if (gVar1 == 1) {
    stats->n_boundary_edges = stats->n_boundary_edges + 1;
  }
  else if (2 < gVar1) {
    stats->n_non_manifold_edges = stats->n_non_manifold_edges + 1;
  }
  gts_range_add_value(&stats->faces_per_edge,(double)(ulonglong)gVar1);
  return;
}



// WARNING: Unknown calling convention

void stats_foreach_vertex(GtsVertex *v,GtsSurfaceStats *stats)

{
  GSList *pGVar1;
  GtsEdge *e;
  GtsObjectClass *pGVar2;
  GtsFace *pGVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GSList *i;
  uint uVar5;
  guint nedges;
  
  uVar5 = 0;
  pGVar1 = v->segments;
  do {
    if (pGVar1 == (GSList *)0x0) {
      gts_range_add_value(&stats->edges_per_vertex,(double)(ulonglong)uVar5);
      return;
    }
    pGVar2 = (GtsObjectClass *)gts_edge_class();
    e = (GtsEdge *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class");
    }
    else if (e != (GtsEdge *)0x0) {
      pGVar4 = (e->segment).object.klass;
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class");
      }
      else {
        do {
          if (pGVar2 == pGVar4) {
            pGVar3 = gts_edge_has_parent_surface(e,stats->parent);
            uVar5 = (uVar5 + 1) - (uint)(pGVar3 == (GtsFace *)0x0);
            break;
          }
          pGVar4 = pGVar4->parent_class;
        } while (pGVar4 != (GtsObjectClass *)0x0);
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Unknown calling convention

GtsSurface *
gts_surface_new(GtsSurfaceClass *klass,GtsFaceClass *face_class,GtsEdgeClass *edge_class,
               GtsVertexClass *vertex_class)

{
  GtsSurface *pGVar1;
  
  pGVar1 = (GtsSurface *)gts_object_new(&klass->parent_class);
  pGVar1->vertex_class = vertex_class;
  pGVar1->edge_class = edge_class;
  pGVar1->face_class = face_class;
  return pGVar1;
}



// WARNING: Unknown calling convention

guint gts_surface_read(GtsSurface *surface,GtsFile *f)

{
  int iVar1;
  GtsObject *object;
  _func_void_GtsObject_ptr_ptr_GtsFile_ptr *p_Var2;
  uint uVar3;
  int iVar4;
  int iVar5;
  GtsVertexClass *klass;
  GtsTokenType GVar6;
  GtsVertex *pGVar7;
  guint s1;
  GtsObject **ppGVar8;
  guint n;
  GtsVertex *pGVar9;
  uint uVar10;
  undefined *puVar11;
  GtsVertex *v2;
  GtsVertex *local_44;
  GtsVertex *local_40;
  GtsFace *local_28;
  GtsEdge *local_24;
  GtsObject *local_20 [4];
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_read","surface != NULL");
    return 1;
  }
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_read","f != NULL");
    return 1;
  }
  if (f->type != GTS_INT) {
    gts_file_error(f,"expecting an integer (number of vertices)");
    return f->line;
  }
  local_40 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
  gts_file_next_token(f);
  if (f->type != GTS_INT) {
    gts_file_error(f,"expecting an integer (number of edges)");
    return f->line;
  }
  local_44 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
  gts_file_next_token(f);
  if (f->type != GTS_INT) {
    gts_file_error(f,"expecting an integer (number of faces)");
    return f->line;
  }
  v2 = (GtsVertex *)0xa;
  uVar3 = strtol(f->token->str,(char **)0x0,10);
  gts_file_next_token(f);
  if (f->type == GTS_STRING) {
    gts_file_next_token(f);
    if (f->type != GTS_STRING) {
      gts_file_error(f,"expecting a string (GtsFaceClass)");
      return f->line;
    }
    gts_file_next_token(f);
    if (f->type != GTS_STRING) {
      gts_file_error(f,"expecting a string (GtsEdgeClass)");
      return f->line;
    }
    gts_file_next_token(f);
    if (f->type != GTS_STRING) {
      gts_file_error(f,"expecting a string (GtsVertexClass)");
      return f->line;
    }
    iVar4 = strcmp(f->token->str,"GtsVertexBinary");
    if (iVar4 == 0) {
      (surface->vertex_class->parent_class).binary = 1;
    }
    else {
      (surface->vertex_class->parent_class).binary = 0;
      gts_file_first_token_after(f,10);
    }
  }
  else {
    gts_file_first_token_after(f,10);
  }
  if (uVar3 == 0) {
    return 0;
  }
  iVar4 = g_malloc((int)local_40 * 4 + 4);
  iVar5 = g_malloc((int)local_44 * 4 + 4);
  if (local_40 == (GtsVertex *)0x0) {
    pGVar9 = (GtsVertex *)0x0;
    klass = surface->vertex_class;
LAB_0813487a:
    if (f->type == GTS_ERROR) goto LAB_08134a57;
  }
  else {
    if (f->type == GTS_ERROR) {
      pGVar9 = (GtsVertex *)0x0;
      klass = surface->vertex_class;
    }
    else {
      klass = surface->vertex_class;
      pGVar9 = (GtsVertex *)0x0;
      do {
        local_20[0] = gts_object_new((GtsObjectClass *)klass);
        (*(surface->vertex_class->parent_class).parent_class.read)(local_20,f);
        if (f->type == GTS_ERROR) {
          gts_object_destroy(local_20[0]);
          klass = surface->vertex_class;
        }
        else {
          klass = surface->vertex_class;
          if ((klass->parent_class).binary == 0) {
            gts_file_first_token_after(f,10);
            klass = surface->vertex_class;
          }
          *(GtsObject **)(iVar4 + (int)pGVar9 * 4) = local_20[0];
          pGVar9 = (GtsVertex *)((int)&(pGVar9->p).object.klass + 1);
        }
        if (local_40 <= pGVar9) goto LAB_0813487a;
      } while (f->type != GTS_ERROR);
    }
LAB_08134a57:
    local_40 = pGVar9;
  }
  if ((klass->parent_class).binary != 0) {
    gts_file_first_token_after(f,10);
  }
  if (local_44 == (GtsVertex *)0x0) {
    pGVar9 = (GtsVertex *)0x0;
LAB_0813495d:
    GVar6 = f->type;
    if (GVar6 != GTS_ERROR) goto LAB_0813496d;
  }
  else {
    GVar6 = f->type;
    if (GVar6 == GTS_ERROR) {
      pGVar9 = (GtsVertex *)0x0;
      GVar6 = GTS_ERROR;
    }
    else {
      pGVar9 = (GtsVertex *)0x0;
      do {
        if (GVar6 == GTS_INT) {
          v2 = (GtsVertex *)0xa;
          pGVar7 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
          if ((local_40 < pGVar7) || (pGVar7 == (GtsVertex *)0x0)) {
            gts_file_error(f,"vertex index `%d\' is out of range `[1,%d]\'",pGVar7,local_40);
            v2 = pGVar7;
          }
          else {
            gts_file_next_token(f);
            if (f->type == GTS_INT) {
              v2 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
              if ((local_40 < v2) || (v2 == (GtsVertex *)0x0)) {
                gts_file_error(f,"vertex index `%d\' is out of range `[1,%d]\'",v2,local_40);
              }
              else {
                v2 = *(GtsVertex **)(iVar4 + -4 + (int)v2 * 4);
                local_24 = gts_edge_new(surface->edge_class,
                                        *(GtsVertex **)(iVar4 + -4 + (int)pGVar7 * 4),v2);
                gts_file_next_token(f);
                if ((f->type != 10) &&
                   (p_Var2 = (surface->edge_class->parent_class).parent_class.read,
                   p_Var2 != (_func_void_GtsObject_ptr_ptr_GtsFile_ptr *)0x0)) {
                  (*p_Var2)((GtsObject **)&local_24,f);
                }
                gts_file_first_token_after(f,10);
                *(GtsEdge **)(iVar5 + (int)pGVar9 * 4) = local_24;
                pGVar9 = (GtsVertex *)((int)&(pGVar9->p).object.klass + 1);
              }
            }
            else {
              gts_file_error(f,"expecting an integer (second vertex index)");
            }
          }
        }
        else {
          gts_file_error(f,"expecting an integer (first vertex index)",v2);
        }
        if (local_44 <= pGVar9) goto LAB_0813495d;
        GVar6 = f->type;
      } while (GVar6 != GTS_ERROR);
      GVar6 = GTS_ERROR;
    }
  }
  local_44 = pGVar9;
LAB_0813496d:
  uVar10 = 0;
  do {
    if (GVar6 == GTS_ERROR) {
LAB_08134b56:
      gts_allow_floating_vertices = 1;
      if (local_40 != (GtsVertex *)0x0) {
        puVar11 = (undefined *)((int)&local_40[-1].segments + 3);
        ppGVar8 = (GtsObject **)(iVar4 + (int)puVar11 * 4);
        while( true ) {
          object = *ppGVar8;
          ppGVar8 = ppGVar8 + -1;
          gts_object_destroy(object);
          if (puVar11 == (undefined *)0x0) break;
          puVar11 = puVar11 + -1;
        }
      }
      gts_allow_floating_vertices = 0;
LAB_08134a29:
      g_free(iVar4);
      g_free(iVar5);
      if (f->type != GTS_ERROR) {
        return 0;
      }
      return f->line;
    }
    if (GVar6 == GTS_INT) {
      v2 = (GtsVertex *)0xa;
      pGVar9 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
      if ((local_44 < pGVar9) || (pGVar9 == (GtsVertex *)0x0)) {
        gts_file_error(f,"edge index `%d\' is out of range `[1,%d]\'",pGVar9,local_44);
        v2 = pGVar9;
      }
      else {
        gts_file_next_token(f);
        if (f->type == GTS_INT) {
          v2 = (GtsVertex *)0xa;
          pGVar7 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
          if ((local_44 < pGVar7) || (pGVar7 == (GtsVertex *)0x0)) {
            gts_file_error(f,"edge index `%d\' is out of range `[1,%d]\'",pGVar7,local_44);
            v2 = pGVar7;
          }
          else {
            gts_file_next_token(f);
            if (f->type == GTS_INT) {
              v2 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
              if ((local_44 < v2) || (v2 == (GtsVertex *)0x0)) {
                gts_file_error(f,"edge index `%d\' is out of range `[1,%d]\'",v2,local_44);
              }
              else {
                iVar1 = (int)v2 * 4;
                v2 = *(GtsVertex **)(iVar5 + -4 + (int)pGVar7 * 4);
                local_28 = gts_face_new(surface->face_class,
                                        *(GtsEdge **)(iVar5 + -4 + (int)pGVar9 * 4),(GtsEdge *)v2,
                                        *(GtsEdge **)(iVar5 + -4 + iVar1));
                gts_file_next_token(f);
                if ((f->type != 10) &&
                   (p_Var2 = (surface->face_class->parent_class).parent_class.read,
                   p_Var2 != (_func_void_GtsObject_ptr_ptr_GtsFile_ptr *)0x0)) {
                  (*p_Var2)((GtsObject **)&local_28,f);
                }
                uVar10 = uVar10 + 1;
                gts_file_first_token_after(f,10);
                gts_surface_add_face(surface,local_28);
              }
            }
            else {
              gts_file_error(f,"expecting an integer (third edge index)");
            }
          }
        }
        else {
          gts_file_error(f,"expecting an integer (second edge index)");
        }
      }
    }
    else {
      gts_file_error(f,"expecting an integer (first edge index)",v2);
    }
    if (uVar3 <= uVar10) {
      if (f->type != GTS_ERROR) goto LAB_08134a29;
      goto LAB_08134b56;
    }
    GVar6 = f->type;
  } while( true );
}



// WARNING: Unknown calling convention

void gts_surface_remove_face(GtsSurface *s,GtsFace *f)

{
  code *pcVar1;
  GSList *pGVar2;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_remove_face","s != NULL");
    return;
  }
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_remove_face","f != NULL");
    return;
  }
  if (s->keep_faces != 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/gts/surface.c",0xb8,"gts_surface_remove_face","s->keep_faces == FALSE");
  }
  g_hash_table_remove(s->faces,f);
  pGVar2 = (GSList *)g_slist_remove(f->surfaces,s);
  f->surfaces = pGVar2;
  pcVar1 = *(code **)((s->object).klass[1].info.name + 4);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(s,f);
  }
  if ((((*(byte *)&(f->triangle).object.flags & 1) == 0) && (gts_allow_floating_faces == 0)) &&
     (f->surfaces == (GSList *)0x0)) {
    gts_object_destroy((GtsObject *)f);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void traverse_remaining(GtsFace *f,gpointer *data)

{
  GtsObjectClass **ppGVar1;
  undefined4 *puVar2;
  GtsObjectClass *pGVar3;
  GtsVertexClass *pGVar4;
  GtsObjectClass *pGVar5;
  GtsFace *pGVar6;
  GtsFace *pGVar7;
  int iVar8;
  GtsSurface *s;
  undefined4 uVar9;
  GSList *i;
  gpointer data_1 [2];
  GtsFace *local_20 [4];
  
  ppGVar1 = (GtsObjectClass **)*data;
  puVar2 = (undefined4 *)data[1];
  iVar8 = g_slist_length(f->surfaces);
  if (iVar8 == 1) {
    pGVar3 = ppGVar1[4];
    pGVar4 = (GtsVertexClass *)ppGVar1[6];
    pGVar5 = ppGVar1[5];
    s = (GtsSurface *)gts_object_new(*ppGVar1);
    local_20[0] = (GtsFace *)0x0;
    s->edge_class = (GtsEdgeClass *)pGVar5;
    s->vertex_class = pGVar4;
    s->face_class = (GtsFaceClass *)pGVar3;
    uVar9 = g_slist_prepend(*puVar2,s);
    *puVar2 = uVar9;
    data_1[1] = local_20;
    data_1[0] = s;
    traverse_manifold(&f->triangle,s);
    gts_surface_foreach_edge(s,non_manifold_edges,data_1);
    pGVar7 = (GtsFace *)0x0;
    for (pGVar6 = local_20[0]; pGVar6 != (GtsFace *)0x0;
        pGVar6 = (GtsFace *)(pGVar6->triangle).object.reserved) {
      gts_surface_remove_face(s,(GtsFace *)(pGVar6->triangle).object.klass);
      pGVar7 = local_20[0];
    }
    g_slist_free(pGVar7);
  }
  return;
}



// WARNING: Unknown calling convention

void traverse_boundary(GtsEdge *e,gpointer *data)

{
  undefined4 *puVar1;
  GtsFaceClass *pGVar2;
  GtsVertexClass *pGVar3;
  GtsEdgeClass *pGVar4;
  GtsFace *pGVar5;
  GtsFace *pGVar6;
  GtsFace *f;
  int iVar7;
  GtsSurface *pGVar8;
  undefined4 uVar9;
  GSList *i;
  GtsSurface *orig;
  gpointer data_1 [2];
  GtsFace *local_20 [4];
  
  pGVar8 = (GtsSurface *)*data;
  puVar1 = (undefined4 *)data[1];
  pGVar6 = gts_edge_is_boundary(e,pGVar8);
  if ((pGVar6 != (GtsFace *)0x0) && (iVar7 = g_slist_length(pGVar6->surfaces), iVar7 == 1)) {
    pGVar2 = pGVar8->face_class;
    pGVar3 = pGVar8->vertex_class;
    pGVar4 = pGVar8->edge_class;
    pGVar8 = (GtsSurface *)gts_object_new((pGVar8->object).klass);
    local_20[0] = (GtsFace *)0x0;
    pGVar8->edge_class = pGVar4;
    pGVar8->vertex_class = pGVar3;
    pGVar8->face_class = pGVar2;
    uVar9 = g_slist_prepend(*puVar1,pGVar8);
    *puVar1 = uVar9;
    data_1[1] = local_20;
    data_1[0] = pGVar8;
    traverse_manifold(&pGVar6->triangle,pGVar8);
    gts_surface_foreach_edge(pGVar8,non_manifold_edges,data_1);
    pGVar5 = (GtsFace *)0x0;
    for (pGVar6 = local_20[0]; pGVar6 != (GtsFace *)0x0;
        pGVar6 = (GtsFace *)(pGVar6->triangle).object.reserved) {
      gts_surface_remove_face(pGVar8,(GtsFace *)(pGVar6->triangle).object.klass);
      pGVar5 = local_20[0];
    }
    g_slist_free(pGVar5);
  }
  return;
}



// WARNING: Unknown calling convention

GtsSurfaceClass * gts_surface_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo surface_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_surface_class::klass == (GtsSurfaceClass *)0x0) {
    pGVar3 = &surface_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    surface_info.name[0] = 'G';
    surface_info.name[1] = 't';
    surface_info.name[2] = 's';
    surface_info.name[3] = 'S';
    surface_info.name[4] = 'u';
    surface_info.name[5] = 'r';
    surface_info.name[6] = 'f';
    surface_info.name[7] = 'a';
    surface_info.name[8] = 'c';
    surface_info.name[9] = 'e';
    surface_info.name[10] = '\0';
    surface_info.name[11] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(surface_info.name + uVar1 + 0xc) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x1c);
    surface_info.object_size = 0x20;
    surface_info.class_size = 100;
    surface_info.class_init_func = surface_class_init;
    surface_info.object_init_func = surface_init;
    parent_class = gts_object_class();
    gts_surface_class::klass = (GtsSurfaceClass *)gts_object_class_new(parent_class,&surface_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_surface_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void surface_destroy(GtsObject *object)

{
  GtsSurfaceClass *pGVar1;
  
  gts_surface_foreach_face((GtsSurface *)object,destroy_foreach_face,object);
  g_hash_table_destroy(object[1].klass);
  pGVar1 = gts_surface_class();
                    // WARNING: Could not recover jumptable at 0x0813518c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar1->parent_class).parent_class)->destroy)(object);
  return;
}



// WARNING: Unknown calling convention

void surface_init(GtsSurface *surface)

{
  GHashTable *pGVar1;
  GtsVertexClass *pGVar2;
  GtsEdgeClass *pGVar3;
  GtsFaceClass *pGVar4;
  
  pGVar1 = (GHashTable *)g_hash_table_new(0,0);
  surface->faces = pGVar1;
  pGVar2 = gts_vertex_class();
  surface->vertex_class = pGVar2;
  pGVar3 = gts_edge_class();
  surface->edge_class = pGVar3;
  pGVar4 = gts_face_class();
  surface->keep_faces = 0;
  surface->face_class = pGVar4;
  return;
}



// WARNING: Unknown calling convention

void orientable_foreach_edge(GtsEdge *e,gpointer *data)

{
  int *piVar1;
  GtsSurface *s;
  GtsFace *f;
  GtsFace *pGVar2;
  GtsFace *pGVar3;
  GtsObjectClass *pGVar4;
  gboolean gVar5;
  GtsObjectClass *c;
  GtsObjectClass *pGVar6;
  GSList *i;
  GSList *pGVar7;
  gboolean *is_orientable;
  GtsFace *local_24;
  GtsFace *local_20;
  
  piVar1 = (int *)*data;
  if (*piVar1 != 0) {
    s = (GtsSurface *)data[1];
    pGVar7 = e->triangles;
    if (pGVar7 != (GSList *)0x0) {
      local_24 = (GtsFace *)0x0;
      local_20 = (GtsFace *)0x0;
      do {
        f = (GtsFace *)pGVar7->data;
        pGVar4 = (GtsObjectClass *)gts_face_class();
        pGVar2 = local_24;
        pGVar3 = local_20;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (f != (GtsFace *)0x0) {
          pGVar6 = (f->triangle).object.klass;
          if (pGVar6 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar4 == pGVar6) {
                gVar5 = gts_face_has_parent_surface(f,s);
                if (((gVar5 != 0) && (pGVar3 = f, local_20 != (GtsFace *)0x0)) &&
                   (pGVar2 = f, pGVar3 = local_20, local_24 != (GtsFace *)0x0)) {
                  *piVar1 = 0;
                  pGVar2 = local_24;
                }
                break;
              }
              pGVar6 = pGVar6->parent_class;
            } while (pGVar6 != (GtsObjectClass *)0x0);
          }
        }
        local_20 = pGVar3;
        local_24 = pGVar2;
        pGVar7 = (GSList *)(&pGVar7->data)[1];
      } while ((pGVar7 != (GSList *)0x0) && (*piVar1 != 0));
      if ((local_24 != (GtsFace *)0x0) &&
         ((local_20 != (GtsFace *)0x0 &&
          (gVar5 = gts_triangles_are_compatible(&local_20->triangle,&local_24->triangle,e),
          gVar5 == 0)))) {
        *piVar1 = 0;
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

gboolean gts_edge_collapse_is_valid(GtsEdge *e)

{
  GSList *pGVar1;
  GtsEdge *e2;
  GtsEdge *e3;
  gpointer pvVar2;
  GtsObjectClass *pGVar3;
  GtsVertex *pGVar4;
  GtsTriangle *pGVar5;
  GtsFace *pGVar6;
  gboolean gVar7;
  GtsObjectClass *c;
  GtsObjectClass *pGVar8;
  GtsTriangle *t;
  GSList *j;
  GSList *pGVar9;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_collapse_is_valid","e != NULL");
  }
  else {
    for (pGVar1 = ((e->segment).v1)->segments; pGVar1 != (GSList *)0x0;
        pGVar1 = (GSList *)(&pGVar1->data)[1]) {
      e2 = (GtsEdge *)pGVar1->data;
      if (e2 != e) {
        pGVar3 = (GtsObjectClass *)gts_edge_class();
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else if (e2 != (GtsEdge *)0x0) {
          pGVar8 = (e2->segment).object.klass;
          if (pGVar8 != (GtsObjectClass *)0x0) {
LAB_08135387:
            if (pGVar3 != pGVar8) goto LAB_08135380;
            pGVar4 = (e2->segment).v1;
            if (pGVar4 == (e->segment).v1) {
              pGVar4 = (e2->segment).v2;
            }
            for (pGVar9 = pGVar4->segments; pGVar9 != (GSList *)0x0; pGVar9 = pGVar9->next) {
              e3 = (GtsEdge *)pGVar9->data;
              pGVar3 = (GtsObjectClass *)gts_edge_class();
              if (pGVar3 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
              }
              else if (e3 != (GtsEdge *)0x0) {
                pGVar8 = (e3->segment).object.klass;
                if (pGVar8 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
                }
                else {
                  do {
                    if (pGVar3 == pGVar8) {
                      pGVar4 = (e->segment).v2;
                      if (((e3->segment).v1 == pGVar4) || (pGVar4 == (e3->segment).v2)) {
                        pGVar5 = gts_triangle_use_edges(e,e2,e3);
                        if (pGVar5 == (GtsTriangle *)0x0) {
                          return 0;
                        }
                        goto LAB_08135403;
                      }
                      break;
                    }
                    pGVar8 = pGVar8->parent_class;
                  } while (pGVar8 != (GtsObjectClass *)0x0);
                }
              }
            }
            goto LAB_08135403;
          }
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
      }
LAB_08135403:
    }
    pGVar6 = gts_edge_is_boundary(e,(GtsSurface *)0x0);
    if (pGVar6 != (GtsFace *)0x0) {
      pvVar2 = e->triangles->data;
      pGVar6 = gts_edge_is_boundary(*(GtsEdge **)((int)pvVar2 + 0xc),(GtsSurface *)0x0);
      if ((pGVar6 != (GtsFace *)0x0) &&
         (pGVar6 = gts_edge_is_boundary(*(GtsEdge **)((int)pvVar2 + 0x10),(GtsSurface *)0x0),
         pGVar6 != (GtsFace *)0x0)) {
        pGVar6 = gts_edge_is_boundary(*(GtsEdge **)((int)pvVar2 + 0x14),(GtsSurface *)0x0);
        return (uint)(pGVar6 == (GtsFace *)0x0);
      }
      return 1;
    }
    gVar7 = gts_vertex_is_boundary((e->segment).v1,(GtsSurface *)0x0);
    if ((gVar7 == 0) ||
       (gVar7 = gts_vertex_is_boundary((e->segment).v2,(GtsSurface *)0x0), gVar7 == 0)) {
      gVar7 = gts_edge_belongs_to_tetrahedron(e);
      return (uint)(gVar7 == 0);
    }
  }
  return 0;
LAB_08135380:
  pGVar8 = pGVar8->parent_class;
  if (pGVar8 == (GtsObjectClass *)0x0) goto LAB_08135403;
  goto LAB_08135387;
}



// WARNING: Unknown calling convention

gboolean gts_edge_collapse_creates_fold(GtsEdge *e,GtsVertex *v,gdouble max)

{
  GtsVertex *v_00;
  GtsVertex *v_01;
  gpointer pvVar1;
  GtsTriangle *t_00;
  GSList *pGVar2;
  GtsObjectClass *pGVar3;
  GSList *pGVar4;
  GSList *triangles_2;
  GSList *pGVar5;
  GtsTriangle *t;
  GtsEdge *pGVar6;
  GtsEdge *e1;
  GtsVertex *v1;
  GtsSegment *s;
  GtsSegment *s_1;
  GtsObjectClass *c;
  GSList *triangles;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar7;
  GSList *triangles_1;
  GtsSegment *s_2;
  GtsSegment *s_3;
  GtsVertex *v2;
  gboolean gVar8;
  gboolean folded;
  GSList *i;
  bool bVar9;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_collapse_creates_fold","e != NULL");
    return 1;
  }
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_collapse_creates_fold","v != NULL");
    return 1;
  }
  v_00 = (e->segment).v1;
  v_01 = (e->segment).v2;
  pGVar4 = v_00->segments;
  pGVar5 = pGVar4;
  while (pGVar5 != (GSList *)0x0) {
    while (pvVar1 = pGVar5->data, v_00 != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      pGVar5 = pGVar5->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v;
      if (pGVar5 == (GSList *)0x0) goto LAB_081355f3;
    }
    pGVar5 = pGVar5->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v;
  }
LAB_081355f3:
  pGVar5 = v_01->segments;
  pGVar2 = pGVar5;
  while (pGVar2 != (GSList *)0x0) {
    while (pvVar1 = pGVar2->data, v_01 != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      pGVar2 = pGVar2->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v;
      if (pGVar2 == (GSList *)0x0) goto LAB_08135628;
    }
    pGVar2 = pGVar2->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v;
  }
LAB_08135628:
  gVar8 = 0;
  bVar9 = true;
  if (pGVar4 != (GSList *)0x0) {
    do {
      pGVar6 = (GtsEdge *)pGVar4->data;
      pGVar3 = (GtsObjectClass *)gts_edge_class();
      if (pGVar3 == (GtsObjectClass *)0x0) {
        gVar8 = 0;
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        bVar9 = true;
      }
      else {
        if (pGVar6 != (GtsEdge *)0x0) {
          pGVar7 = (pGVar6->segment).object.klass;
          if (pGVar7 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar3 == pGVar7) {
                if (pGVar6 != e) {
                  pGVar5 = edge_triangles(pGVar6,e);
                  gVar8 = gts_triangles_are_folded
                                    (pGVar5,(pGVar6->segment).v1,(pGVar6->segment).v2,max);
                  g_slist_free(pGVar5);
                  bVar9 = gVar8 == 0;
                  goto LAB_081356b9;
                }
                break;
              }
              pGVar7 = pGVar7->parent_class;
            } while (pGVar7 != (GtsObjectClass *)0x0);
          }
        }
        bVar9 = true;
        gVar8 = 0;
      }
LAB_081356b9:
      pGVar4 = pGVar4->next;
    } while ((bVar9) && (pGVar4 != (GSList *)0x0));
    pGVar5 = v_01->segments;
  }
  if (bVar9) {
    do {
      if (pGVar5 == (GSList *)0x0) break;
      pGVar6 = (GtsEdge *)pGVar5->data;
      pGVar3 = (GtsObjectClass *)gts_edge_class();
      if (pGVar3 == (GtsObjectClass *)0x0) {
        gVar8 = 0;
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        bVar9 = true;
      }
      else {
        if (pGVar6 != (GtsEdge *)0x0) {
          pGVar7 = (pGVar6->segment).object.klass;
          if (pGVar7 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          }
          else {
            do {
              if (pGVar3 == pGVar7) {
                if (pGVar6 != e) {
                  pGVar4 = edge_triangles(pGVar6,e);
                  gVar8 = gts_triangles_are_folded
                                    (pGVar4,(pGVar6->segment).v1,(pGVar6->segment).v2,max);
                  g_slist_free(pGVar4);
                  bVar9 = gVar8 == 0;
                  goto LAB_08135764;
                }
                break;
              }
              pGVar7 = pGVar7->parent_class;
            } while (pGVar7 != (GtsObjectClass *)0x0);
          }
        }
        bVar9 = true;
        gVar8 = 0;
      }
LAB_08135764:
      pGVar5 = pGVar5->next;
    } while (bVar9);
  }
  if (gVar8 == 0) {
    pGVar4 = gts_vertex_triangles(v_00,(GSList *)0x0);
    pGVar5 = gts_vertex_triangles(v_01,pGVar4);
    pGVar4 = pGVar5;
    do {
      while( true ) {
        if (pGVar4 == (GSList *)0x0) goto LAB_08135919;
        t_00 = (GtsTriangle *)pGVar4->data;
        if (((t_00->e1 != e) && (t_00->e2 != e)) && (t_00->e3 != e)) break;
        gVar8 = 0;
        pGVar4 = (GSList *)(&pGVar4->data)[1];
      }
      pGVar6 = gts_triangle_edge_opposite(t_00,v);
      if (pGVar6 == (GtsEdge *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/gts/surface.c",0x58c,"gts_edge_collapse_creates_fold",&DAT_081516e9)
        ;
      }
      gVar8 = gts_triangles_are_folded
                        (pGVar6->triangles,(pGVar6->segment).v1,(pGVar6->segment).v2,max);
      pGVar4 = (GSList *)(&pGVar4->data)[1];
    } while (gVar8 == 0);
LAB_08135919:
    g_slist_free(pGVar5);
  }
  pGVar4 = v_00->segments;
  while (pGVar4 != (GSList *)0x0) {
    while (pvVar1 = pGVar4->data, v != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      pGVar4 = pGVar4->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v_00;
      if (pGVar4 == (GSList *)0x0) goto LAB_081357a8;
    }
    pGVar4 = pGVar4->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v_00;
  }
LAB_081357a8:
  pGVar4 = v_01->segments;
  do {
    if (pGVar4 == (GSList *)0x0) {
      return gVar8;
    }
    while (pvVar1 = pGVar4->data, v != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      pGVar4 = pGVar4->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v_01;
      if (pGVar4 == (GSList *)0x0) {
        return gVar8;
      }
    }
    pGVar4 = pGVar4->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v_01;
  } while( true );
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void gts_surface_coarsen(GtsSurface *surface,GtsKeyFunc cost_func,gpointer cost_data,
                        GtsCoarsenFunc coarsen_func,gpointer coarsen_data,GtsStopFunc stop_func,
                        gpointer stop_data,gdouble minangle)

{
  GtsVertex *v;
  GtsVertexClass *pGVar1;
  GtsVertex *v_00;
  GtsObjectClass **ppGVar2;
  int **ppiVar3;
  int *p;
  GtsEHeap *heap_00;
  GtsEdge *pGVar4;
  guint gVar5;
  guint gVar6;
  gboolean gVar7;
  GtsObjectClass *v_01;
  GtsEdge *e_00;
  GtsObjectClass *pGVar8;
  GtsVertex *v1;
  int iVar9;
  GtsEHeapPair *pGVar10;
  code *pcVar11;
  GtsObjectClass *c;
  GtsObjectClass *pGVar12;
  GtsEHeap *heap;
  GSList *j;
  GtsEdge *e;
  GSList *i;
  int **ppiVar13;
  double dVar14;
  int **local_30;
  double local_24 [2];
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_coarsen","surface != NULL");
  }
  else if (stop_func == (GtsStopFunc)0x0) {
    g_return_if_fail_warning(0,"gts_surface_coarsen","stop_func != NULL");
  }
  else {
    if (cost_func == (GtsKeyFunc)0x0) {
      cost_func = edge_length2;
    }
    pcVar11 = gts_segment_midvertex;
    if (coarsen_func != (GtsCoarsenFunc)0x0) {
      pcVar11 = coarsen_func;
    }
    heap_00 = gts_eheap_new(cost_func,cost_data);
    dVar14 = cos(minangle);
    gts_eheap_freeze(heap_00);
    gts_surface_foreach_edge(surface,create_heap_coarsen,heap_00);
    gts_eheap_thaw(heap_00);
    gts_allow_floating_edges = 1;
LAB_08135a42:
    pGVar4 = (GtsEdge *)gts_eheap_remove_top(heap_00,local_24);
    if (pGVar4 != (GtsEdge *)0x0) {
      if (1.797693134862316e+308 <= local_24[0]) {
LAB_08135e4b:
        gts_allow_floating_edges = 0;
        (pGVar4->segment).object.reserved = (gpointer)0x0;
        goto LAB_08135e5c;
      }
      gVar5 = gts_eheap_size(heap_00);
      gVar6 = gts_edge_face_number(pGVar4,surface);
      gVar7 = (*stop_func)(local_24[0],gVar5 - gVar6,stop_data);
      if (gVar7 != 0) goto LAB_08135e4b;
      v = (pGVar4->segment).v2;
      pGVar1 = surface->vertex_class;
      v_00 = (pGVar4->segment).v1;
      if (v_00 == v) {
        gts_object_destroy((GtsObject *)pGVar4);
      }
      else {
        gVar7 = gts_edge_collapse_is_valid(pGVar4);
        if (gVar7 == 0) {
          pGVar10 = gts_eheap_insert_with_key(heap_00,pGVar4,1.797693134862316e+308);
          (pGVar4->segment).object.reserved = pGVar10;
        }
        else {
          v_01 = (GtsObjectClass *)(*pcVar11)(pGVar4,pGVar1,coarsen_data);
          gVar7 = gts_edge_collapse_creates_fold(pGVar4,(GtsVertex *)v_01,dVar14 * dVar14);
          if (gVar7 == 0) {
            gts_object_destroy((GtsObject *)pGVar4);
            gts_vertex_replace(v_00,(GtsVertex *)v_01);
            gts_object_destroy((GtsObject *)v_00);
            gts_vertex_replace(v,(GtsVertex *)v_01);
            gts_object_destroy((GtsObject *)v);
            local_30 = *(int ***)((GtsObject *)(v_01->info).name + 3);
            while (local_30 != (int **)0x0) {
              while( true ) {
                pGVar4 = (GtsEdge *)*local_30;
                while (e_00 = gts_edge_is_duplicate(pGVar4), e_00 != (GtsEdge *)0x0) {
                  gts_edge_replace(e_00,pGVar4);
                  gts_eheap_remove(heap_00,(GtsEHeapPair *)(e_00->segment).object.reserved);
                  (e_00->segment).object.reserved = (gpointer)0x0;
                  gts_object_destroy((GtsObject *)e_00);
                }
                local_30 = *(int ***)((int)local_30 + 4);
                if (pGVar4->triangles != (GSList *)0x0) break;
                g_log(0,0x10,"file %s: line %d (%s): probably duplicate triangle.",
                      "../../src/gts/surface.c",0x60d,&DAT_0814741b);
                gts_eheap_remove(heap_00,(GtsEHeapPair *)(pGVar4->segment).object.reserved);
                (pGVar4->segment).object.reserved = (gpointer)0x0;
                gts_object_destroy((GtsObject *)pGVar4);
                if (local_30 == (int **)0x0) goto LAB_08135a42;
              }
            }
            if (v_01 != (GtsObjectClass *)0x0) {
              local_30 = *(int ***)((GtsObject *)(v_01->info).name + 3);
              if (local_30 != (int **)0x0) {
                ppiVar13 = (int **)0x0;
                do {
                  while( true ) {
                    ppGVar2 = (GtsObjectClass **)*local_30;
                    pGVar8 = (GtsObjectClass *)gts_edge_class();
                    if (pGVar8 != (GtsObjectClass *)0x0) break;
                    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                    local_30 = (int **)local_30[1];
joined_r0x08135c71:
                    ppiVar3 = ppiVar13;
                    if (local_30 == (int **)0x0) goto joined_r0x08135c7f;
                  }
                  if (ppGVar2 == (GtsObjectClass **)0x0) {
LAB_08135c66:
                    local_30 = (int **)local_30[1];
                    goto joined_r0x08135c71;
                  }
                  pGVar12 = *ppGVar2;
                  if (pGVar12 != (GtsObjectClass *)0x0) {
LAB_08135c07:
                    if (pGVar8 != pGVar12) goto LAB_08135c00;
                    pGVar8 = ppGVar2[3];
                    if (v_01 == pGVar8) {
                      pGVar8 = ppGVar2[4];
                    }
                    for (ppiVar3 = *(int ***)((GtsObject *)(pGVar8->info).name + 3);
                        ppiVar3 != (int **)0x0; ppiVar3 = (int **)ppiVar3[1]) {
                      ppGVar2 = (GtsObjectClass **)*ppiVar3;
                      pGVar8 = (GtsObjectClass *)gts_edge_class();
                      if (pGVar8 == (GtsObjectClass *)0x0) {
                        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                      }
                      else if (ppGVar2 != (GtsObjectClass **)0x0) {
                        pGVar12 = *ppGVar2;
                        if (pGVar12 == (GtsObjectClass *)0x0) {
                          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
                        }
                        else {
                          do {
                            if (pGVar8 == pGVar12) {
                              iVar9 = g_slist_find();
                              if (iVar9 == 0) {
                                ppiVar13 = (int **)g_slist_prepend();
                              }
                              break;
                            }
                            pGVar12 = pGVar12->parent_class;
                          } while (pGVar12 != (GtsObjectClass *)0x0);
                        }
                      }
                    }
                    goto LAB_08135c66;
                  }
                  g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
                  local_30 = (int **)local_30[1];
                  ppiVar3 = ppiVar13;
                } while (local_30 != (int **)0x0);
joined_r0x08135c7f:
                while (local_30 = ppiVar3, ppiVar13 != (int **)0x0) {
                  p = *ppiVar13;
                  gts_eheap_remove(heap_00,(GtsEHeapPair *)p[1]);
                  p[1] = 0;
                  pGVar10 = gts_eheap_insert(heap_00,p);
                  ppiVar13 = (int **)ppiVar13[1];
                  p[1] = (int)pGVar10;
                  ppiVar3 = local_30;
                }
              }
              g_slist_free(local_30);
            }
          }
          else {
            pGVar10 = gts_eheap_insert_with_key(heap_00,pGVar4,1.797693134862316e+308);
            (pGVar4->segment).object.reserved = pGVar10;
            gts_object_destroy((GtsObject *)v_01);
          }
        }
      }
      goto LAB_08135a42;
    }
    gts_allow_floating_edges = 0;
LAB_08135e5c:
    gts_eheap_foreach(heap_00,gts_object_reset_reserved,(gpointer)0x0);
    gts_eheap_destroy(heap_00);
  }
  return;
LAB_08135c00:
  pGVar12 = pGVar12->parent_class;
  if (pGVar12 == (GtsObjectClass *)0x0) goto LAB_08135c66;
  goto LAB_08135c07;
}



// WARNING: Unknown calling convention

void triangle_barycenter(GtsTriangle *t,GtsPoint *b)

{
  GtsEdge *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  
  pGVar1 = t->e1;
  pGVar2 = (pGVar1->segment).v1;
  pGVar3 = (t->e2->segment).v1;
  if (pGVar2 == pGVar3) {
    pGVar4 = (pGVar1->segment).v2;
  }
  else {
    pGVar4 = (pGVar1->segment).v2;
    if (pGVar3 != pGVar4) goto LAB_08135efc;
  }
  pGVar3 = (t->e2->segment).v2;
LAB_08135efc:
  b->x = ((pGVar3->p).x + (pGVar2->p).x + (pGVar4->p).x) / 3.0;
  b->y = ((pGVar3->p).y + (pGVar2->p).y + (pGVar4->p).y) / 3.0;
  return;
}



// WARNING: Unknown calling convention

void gts_list_face_class_init(GtsFaceClass *klass)

{
  (klass->parent_class).parent_class.destroy = gts_list_face_destroy;
  return;
}



// WARNING: Unknown calling convention

GtsFaceClass * gts_list_face_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo gts_list_face_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_list_face_class::klass == (GtsFaceClass *)0x0) {
    pGVar3 = &gts_list_face_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    gts_list_face_info.name[0] = 'G';
    gts_list_face_info.name[1] = 't';
    gts_list_face_info.name[2] = 's';
    gts_list_face_info.name[3] = 'L';
    gts_list_face_info.name[4] = 'i';
    gts_list_face_info.name[5] = 's';
    gts_list_face_info.name[6] = 't';
    gts_list_face_info.name[7] = 'F';
    gts_list_face_info.name[8] = 'a';
    gts_list_face_info.name[9] = 'c';
    gts_list_face_info.name[10] = 'e';
    gts_list_face_info.name[11] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(gts_list_face_info.name + uVar1 + 0xc) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x1c);
    gts_list_face_info.object_size = 0x20;
    gts_list_face_info.class_size = 0x5c;
    gts_list_face_info.class_init_func = gts_list_face_class_init;
    parent_class = (GtsObjectClass *)gts_face_class();
    gts_list_face_class::klass =
         (GtsFaceClass *)gts_object_class_new(parent_class,&gts_list_face_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_list_face_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void gts_list_face_destroy(GtsObject *object)

{
  GtsFaceClass *pGVar1;
  
  g_slist_free(object[2].reserved);
  pGVar1 = gts_list_face_class();
                    // WARNING: Could not recover jumptable at 0x08136008. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar1->parent_class).parent_class.parent_class)->destroy)(object);
  return;
}



// WARNING: Unknown calling convention

gpointer gts_object_is_from_class(gpointer object,gpointer klass)

{
  GtsObjectClass *c;
  gpointer pvVar1;
  
  if (klass == (gpointer)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    return (gpointer)0x0;
  }
  if (object != (gpointer)0x0) {
                    // WARNING: Load size is inaccurate
    pvVar1 = *object;
    if (pvVar1 == (gpointer)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      return (gpointer)0x0;
    }
    while (klass != pvVar1) {
      pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
      if (pvVar1 == (gpointer)0x0) {
        return (gpointer)0x0;
      }
    }
  }
  return object;
}



// WARNING: Unknown calling convention

GtsFace * gts_delaunay_check(GtsSurface *surface)

{
  gpointer data [2];
  GtsFace *local_10 [3];
  
  local_10[0] = (GtsFace *)0x0;
  if (surface != (GtsSurface *)0x0) {
    data[1] = local_10;
    data[0] = surface;
    gts_surface_foreach_face(surface,delaunay_check,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_delaunay_check","surface != NULL");
  return (GtsFace *)0x0;
}



// WARNING: Unknown calling convention

void delaunay_check(GtsTriangle *t,gpointer *data)

{
  GtsTriangle **ppGVar1;
  GtsSurface *surface;
  GtsTriangle *pGVar2;
  GtsVertex *p;
  GSList *pGVar3;
  GSList *pGVar4;
  GSList *list;
  GtsVertex *v;
  GtsFace **face;
  GSList *i;
  gdouble gVar5;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  ppGVar1 = (GtsTriangle **)data[1];
  surface = (GtsSurface *)*data;
  if (*ppGVar1 == (GtsTriangle *)0x0) {
    gts_triangle_vertices(t,local_20,&local_24,&local_28);
    pGVar4 = gts_vertex_neighbors(local_20[0],(GSList *)0x0,surface);
    pGVar4 = gts_vertex_neighbors(local_24,pGVar4,surface);
    pGVar4 = gts_vertex_neighbors(local_28,pGVar4,surface);
    if (pGVar4 != (GSList *)0x0) {
      pGVar2 = *ppGVar1;
      pGVar3 = pGVar4;
      while (pGVar2 == (GtsTriangle *)0x0) {
        p = (GtsVertex *)pGVar3->data;
        if ((((p != local_20[0]) && (p != local_24)) && (p != local_28)) &&
           (gVar5 = gts_point_in_circle((GtsPoint *)p,&local_20[0]->p,&local_24->p,&local_28->p),
           0.0 < gVar5)) {
          *ppGVar1 = t;
        }
        pGVar3 = (GSList *)(&pGVar3->data)[1];
        if (pGVar3 == (GSList *)0x0) break;
        pGVar2 = *ppGVar1;
      }
    }
    g_slist_free(pGVar4);
  }
  return;
}



// WARNING: Unknown calling convention

GtsConstraintClass * gts_constraint_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_constraint_class::klass == (GtsConstraintClass *)0x0) {
    pGVar3 = &constraint_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    constraint_info.name[0] = 'G';
    constraint_info.name[1] = 't';
    constraint_info.name[2] = 's';
    constraint_info.name[3] = 'C';
    constraint_info.name[4] = 'o';
    constraint_info.name[5] = 'n';
    constraint_info.name[6] = 's';
    constraint_info.name[7] = 't';
    constraint_info.name[8] = 'r';
    constraint_info.name[9] = 'a';
    constraint_info.name[10] = 'i';
    constraint_info.name[11] = 'n';
    constraint_info.name[12] = 't';
    constraint_info.name[13] = '\0';
    constraint_info.name[14] = '\0';
    constraint_info.name[15] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(constraint_info.name + uVar1 + 0x10) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x18);
    constraint_info.object_size = 0x18;
    constraint_info.class_size = 0x5c;
    parent_class = (GtsObjectClass *)gts_edge_class();
    gts_constraint_class::klass =
         (GtsConstraintClass *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_constraint_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

gboolean find_closest(gpointer key,gpointer value,gpointer user_data)

{
  double dVar1;
  double dVar2;
  GtsPoint *p1;
  int iVar3;
  gdouble d;
  gdouble gVar4;
  
  gVar4 = gts_triangle_orientation((GtsTriangle *)value);
                    // WARNING: Load size is inaccurate
  if ((0.0 < gVar4) &&
     (iVar3 = *(int *)(*(int *)((int)value + 0xc) + 0xc),
     dVar1 = *(double *)(*(int *)((int)user_data + 0xc) + 0xc) - *(double *)(iVar3 + 0xc),
     dVar2 = *(double *)(*(int *)((int)user_data + 0xc) + 0x14) - *(double *)(iVar3 + 0x14),
     dVar1 = dVar2 * dVar2 + dVar1 * dVar1, dVar1 < *user_data)) {
    *(double *)user_data = dVar1;
    *(gpointer *)((int)user_data + 8) = value;
  }
  iVar3 = *(int *)((int)user_data + 0x10) + -1;
  *(int *)((int)user_data + 0x10) = iVar3;
  return (uint)(iVar3 < 1);
}



// WARNING: Unknown calling convention

GtsFace * neighbor(GtsFace *f,GtsEdge *e,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsFace *f_00;
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *c;
  GtsObjectClass *pGVar4;
  GtsTriangle *t1;
  GSList *i;
  
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsFace *)0x0;
    }
    f_00 = (GtsFace *)pGVar1->data;
    if (f_00 != f) {
      pGVar2 = (GtsObjectClass *)gts_face_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (f_00 != (GtsFace *)0x0) {
        pGVar4 = (f_00->triangle).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar2 == pGVar4) {
              gVar3 = gts_face_has_parent_surface(f_00,surface);
              if (gVar3 != 0) {
                return f_00;
              }
              break;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

GtsFace * point_locate(GtsPoint *o,GtsPoint *p,GtsFace *f,GtsSurface *surface)

{
  bool bVar1;
  gboolean on_summit;
  GtsFace *f1_1;
  GtsFace *pGVar2;
  GtsFace *f1;
  GtsEdge *e;
  gdouble orient;
  gdouble gVar3;
  double dVar4;
  GtsVertex *p2;
  GtsEdge *local_4c;
  GtsEdge *local_48;
  GtsEdge *local_44;
  GtsVertex *local_40;
  GtsVertex *local_3c;
  GtsVertex *local_38;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsEdge *local_20 [4];
  
  gts_triangle_vertices_edges
            (&f->triangle,(GtsEdge *)0x0,&local_38,&local_3c,&local_40,&local_44,&local_48,&local_4c
            );
  gVar3 = gts_point_orientation(o,&local_38->p,p);
  if (0.0 < gVar3) {
    gVar3 = gts_point_orientation(o,&local_3c->p,p);
    if (0.0 < gVar3) {
      dVar4 = gts_point_orientation(&local_3c->p,&local_40->p,p);
    }
    else {
      local_40 = local_38;
      p2 = local_3c;
      if (0.0 <= gVar3) goto LAB_0813649d;
      dVar4 = gts_point_orientation(&local_38->p,&local_3c->p,p);
      local_48 = local_44;
    }
joined_r0x0813681e:
    if (dVar4 < 0.0) {
LAB_0813644b:
      if ((local_48 == (GtsEdge *)0x0) ||
         (local_20[0] = local_48, f = neighbor(f,local_48,surface), f == (GtsFace *)0x0)) {
        return f;
      }
      gts_triangle_vertices_edges
                (&f->triangle,local_20[0],&local_24,&local_28,&local_2c,local_20,&local_30,&local_34
                );
      do {
        gVar3 = gts_point_orientation(o,&local_2c->p,p);
        if (gVar3 < 0.0) {
          gVar3 = gts_point_orientation(&local_28->p,&local_2c->p,p);
          if (0.0 <= gVar3) {
            return f;
          }
          f = neighbor(f,local_30,surface);
          local_20[0] = local_30;
          local_24 = local_2c;
        }
        else {
          if (gVar3 <= 0.0) {
            gVar3 = gts_point_orientation(&local_28->p,&local_2c->p,p);
            if (0.0 <= gVar3) {
              return f;
            }
            pGVar2 = neighbor(f,local_30,surface);
            e = local_34;
            if (pGVar2 == (GtsFace *)0x0) goto LAB_081367a5;
            goto LAB_081364d9;
          }
          gVar3 = gts_point_orientation(&local_2c->p,&local_24->p,p);
          if (0.0 <= gVar3) {
            return f;
          }
          f = neighbor(f,local_34,surface);
          local_20[0] = local_34;
          local_28 = local_2c;
        }
        if (f == (GtsFace *)0x0) {
          return (GtsFace *)0x0;
        }
        local_30 = (f->triangle).e1;
        if (local_30 == local_20[0]) {
          local_30 = (f->triangle).e2;
          local_34 = (f->triangle).e3;
        }
        else {
          local_34 = (f->triangle).e2;
          if (local_20[0] == local_34) {
            local_34 = local_30;
            local_30 = (f->triangle).e3;
          }
        }
        local_2c = (local_30->segment).v1;
        if ((local_2c == local_24) || (local_2c == local_28)) {
          local_2c = (local_30->segment).v2;
        }
      } while( true );
    }
  }
  else {
    if (gVar3 < 0.0) {
      gVar3 = gts_point_orientation(o,&local_40->p,p);
      if (0.0 < gVar3) {
        dVar4 = gts_point_orientation(&local_40->p,&local_38->p,p);
        local_48 = local_4c;
      }
      else {
        p2 = local_38;
        if (0.0 <= gVar3) goto LAB_0813649d;
        dVar4 = gts_point_orientation(&local_3c->p,&local_40->p,p);
      }
      goto joined_r0x0813681e;
    }
    gVar3 = gts_point_orientation(&local_3c->p,&local_40->p,p);
    local_40 = local_38;
    p2 = local_3c;
    if (gVar3 < 0.0) goto LAB_0813644b;
LAB_0813649d:
    gVar3 = gts_point_orientation(&local_40->p,&p2->p,p);
    if (gVar3 < 0.0) {
      bVar1 = true;
      goto LAB_081364b7;
    }
  }
  bVar1 = false;
LAB_081364b7:
  local_20[0] = (GtsEdge *)0x0;
  if (!bVar1) {
    return f;
  }
  pGVar2 = neighbor(f,(f->triangle).e1,surface);
  if ((pGVar2 == (GtsFace *)0x0) &&
     (pGVar2 = neighbor(f,(f->triangle).e2,surface), pGVar2 == (GtsFace *)0x0)) {
    e = (f->triangle).e3;
LAB_081367a5:
    pGVar2 = neighbor(f,e,surface);
    if (pGVar2 == (GtsFace *)0x0) {
      return (GtsFace *)0x0;
    }
  }
LAB_081364d9:
  triangle_barycenter(&pGVar2->triangle,o);
  pGVar2 = point_locate(o,p,pGVar2,surface);
  return pGVar2;
}



// WARNING: Unknown calling convention

GtsFace * gts_point_locate(GtsPoint *p,GtsSurface *surface,GtsFace *guess)

{
  gboolean gVar1;
  GtsFace *fr;
  GtsPointClass *klass;
  GtsPoint *b;
  GtsFace *pGVar2;
  uint uVar3;
  gdouble gVar4;
  double dVar5;
  SFindClosest fc;
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_locate","p != NULL");
  }
  else if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_point_locate","surface != NULL");
  }
  else if (guess == (GtsFace *)0x0) {
    fc.dmin = 1.797693134862316e+308;
    fc.closest = (GtsFace *)0x0;
    fc.p = p;
    uVar3 = g_hash_table_size(surface->faces);
    dVar5 = log((double)(ulonglong)uVar3);
    dVar5 = exp(dVar5 / 3.0);
    fc.stop = (gint)ROUND(dVar5);
    g_hash_table_find(surface->faces,find_closest,&fc);
    guess = fc.closest;
    if (fc.closest != (GtsFace *)0x0) goto LAB_081368a2;
  }
  else {
    gVar1 = gts_face_has_parent_surface(guess,surface);
    if (gVar1 != 0) {
      gVar4 = gts_triangle_orientation(&guess->triangle);
      if (gVar4 <= 0.0) {
        g_return_if_fail_warning
                  (0,"gts_point_locate","gts_triangle_orientation (GTS_TRIANGLE (guess)) > 0.");
        return (GtsFace *)0x0;
      }
LAB_081368a2:
      klass = gts_point_class();
      b = (GtsPoint *)gts_object_new(&klass->parent_class);
      triangle_barycenter(&guess->triangle,b);
      pGVar2 = point_locate(b,p,guess,surface);
      gts_object_destroy((GtsObject *)b);
      return pGVar2;
    }
    g_return_if_fail_warning
              (0,"gts_point_locate","guess == NULL || gts_face_has_parent_surface (guess, surface)")
    ;
  }
  fr = (GtsFace *)0x0;
  return fr;
}



// WARNING: Unknown calling convention

void remove_triangles(GtsEdge *e,GtsSurface *s)

{
  GSList *pGVar1;
  GtsFace *f;
  GSList *pGVar2;
  GtsObjectClass *pGVar3;
  gboolean gVar4;
  GtsObjectClass *c;
  GtsObjectClass *pGVar5;
  GSList *i;
  GSList *next;
  
  pGVar1 = e->triangles;
  do {
    while( true ) {
      do {
        while( true ) {
          pGVar2 = pGVar1;
          if (pGVar2 == (GSList *)0x0) {
            return;
          }
          pGVar1 = (GSList *)(&pGVar2->data)[1];
          pGVar3 = (GtsObjectClass *)gts_face_class();
          f = (GtsFace *)pGVar2->data;
          if (pGVar3 != (GtsObjectClass *)0x0) break;
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
      } while (f == (GtsFace *)0x0);
      pGVar5 = (f->triangle).object.klass;
      if (pGVar5 != (GtsObjectClass *)0x0) break;
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    do {
      if (pGVar3 == pGVar5) {
        gVar4 = gts_face_has_parent_surface(f,s);
        if (gVar4 != 0) {
          gts_surface_remove_face(s,(GtsFace *)pGVar2->data);
        }
        break;
      }
      pGVar5 = pGVar5->parent_class;
    } while (pGVar5 != (GtsObjectClass *)0x0);
  } while( true );
}



// WARNING: Unknown calling convention

void triangulate_polygon(GSList *poly,GtsSurface *surface,GtsFace *ref)

{
  GtsEdge *e1_00;
  gpointer pvVar1;
  bool bVar2;
  GtsSegment *s1;
  GtsVertex *v2;
  gboolean found;
  GtsVertex *pGVar3;
  GtsVertex *v;
  GtsEdge *e2;
  GtsObjectClass *pGVar4;
  GtsEdge *e3;
  GtsFace *f_00;
  GSList *pGVar5;
  GtsVertex *pGVar6;
  GtsVertex *v1;
  GtsVertex *pGVar7;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar8;
  GSList *poly2;
  GtsVertex *v3;
  GtsSegment *s;
  GtsFace *f;
  GtsSegment *s2;
  GSList *pGVar9;
  GtsEdge *e1;
  GtsVertex *pGVar10;
  gdouble gVar11;
  GSList *local_30;
  GtsVertex *local_2c;
  GSList *local_28;
  GtsVertex *local_20;
  
  local_30 = poly;
  if (poly != (GSList *)0x0) {
    local_28 = poly->next;
    while (local_28 != (GSList *)0x0) {
      e1_00 = (GtsEdge *)local_30->data;
      pGVar7 = *(GtsVertex **)((int)local_28->data + 0xc);
      local_2c = (e1_00->segment).v1;
      if ((local_2c == pGVar7) ||
         (pGVar6 = *(GtsVertex **)((int)local_28->data + 0x10), local_2c == pGVar6)) {
        pGVar7 = local_2c;
        local_20 = (e1_00->segment).v2;
      }
      else {
        pGVar10 = (e1_00->segment).v2;
        local_20 = local_2c;
        local_2c = pGVar7;
        if ((pGVar7 != pGVar10) && (pGVar7 = pGVar6, local_2c = pGVar6, pGVar6 != pGVar10)) {
                    // WARNING: Subroutine does not return
          g_assertion_message_expr
                    (0,"../../src/gts/cdt.c",0x2c6,"triangulate_polygon",
                     "s->v2 == s1->v1 || s->v2 == s1->v2");
        }
      }
      do {
        if (local_28 == (GSList *)0x0) {
          g_slist_free(local_30);
          return;
        }
        pvVar1 = local_28->data;
        pGVar6 = *(GtsVertex **)((int)pvVar1 + 0xc);
        if (pGVar6 == pGVar7) {
          pGVar6 = *(GtsVertex **)((int)pvVar1 + 0x10);
        }
        else if (*(GtsVertex **)((int)pvVar1 + 0x10) != pGVar7) {
                    // WARNING: Subroutine does not return
          g_assertion_message_expr
                    (0,"../../src/gts/cdt.c",0x2d2,"triangulate_polygon","s1->v2 == v3");
        }
        if ((pGVar6 == local_20) ||
           (gVar11 = gts_point_orientation(&local_20->p,&local_2c->p,&pGVar6->p), gVar11 < 0.0)) {
LAB_08136e10:
          local_28 = local_28->next;
          bVar2 = false;
        }
        else {
          pGVar7 = (GtsVertex *)0x0;
          pGVar9 = local_30;
          pGVar10 = (GtsVertex *)0x0;
          do {
            while( true ) {
              pvVar1 = pGVar9->data;
              pGVar3 = *(GtsVertex **)((int)pvVar1 + 0xc);
              if (((((pGVar3 != pGVar10) && (pGVar3 != pGVar7)) && (local_2c != pGVar3)) &&
                  ((local_20 != pGVar3 && (pGVar6 != pGVar3)))) &&
                 (gVar11 = gts_point_in_circle(&pGVar3->p,&local_20->p,&local_2c->p,&pGVar6->p),
                 0.0 < gVar11)) goto LAB_08136e10;
              pGVar3 = *(GtsVertex **)((int)pvVar1 + 0x10);
              if (((pGVar10 != pGVar3) && (pGVar7 != pGVar3)) &&
                 ((local_2c != pGVar3 && (local_20 != pGVar3)))) break;
LAB_08136c08:
              pGVar9 = (GSList *)(&pGVar9->data)[1];
              pGVar7 = *(GtsVertex **)((int)pvVar1 + 0xc);
              pGVar10 = pGVar3;
              if (pGVar9 == (GSList *)0x0) goto LAB_08136ca0;
            }
            if (pGVar6 != pGVar3) {
              gVar11 = gts_point_in_circle(&pGVar3->p,&local_20->p,&local_2c->p,&pGVar6->p);
              if (gVar11 <= 0.0) {
                pGVar3 = *(GtsVertex **)((int)pvVar1 + 0x10);
                goto LAB_08136c08;
              }
              goto LAB_08136e10;
            }
            pGVar9 = (GSList *)(&pGVar9->data)[1];
            pGVar7 = *(GtsVertex **)((int)pvVar1 + 0xc);
            pGVar10 = pGVar6;
          } while (pGVar9 != (GSList *)0x0);
LAB_08136ca0:
          bVar2 = true;
        }
        pGVar7 = pGVar6;
      } while (!bVar2);
      e2 = (GtsEdge *)gts_vertices_are_connected(local_2c,pGVar6);
      pGVar4 = (GtsObjectClass *)gts_edge_class();
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (e2 != (GtsEdge *)0x0) {
        pGVar8 = (e2->segment).object.klass;
        if (pGVar8 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar4 == pGVar8) goto LAB_08136cfc;
            pGVar8 = pGVar8->parent_class;
          } while (pGVar8 != (GtsObjectClass *)0x0);
        }
      }
      e2 = gts_edge_new(surface->edge_class,local_2c,pGVar6);
LAB_08136cfc:
      e3 = (GtsEdge *)gts_vertices_are_connected(pGVar6,local_20);
      pGVar4 = (GtsObjectClass *)gts_edge_class();
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (e3 != (GtsEdge *)0x0) {
        pGVar8 = (e3->segment).object.klass;
        if (pGVar8 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar4 == pGVar8) goto LAB_08136d42;
            pGVar8 = pGVar8->parent_class;
          } while (pGVar8 != (GtsObjectClass *)0x0);
        }
      }
      e3 = gts_edge_new(surface->edge_class,pGVar6,local_20);
LAB_08136d42:
      f_00 = gts_face_new(surface->face_class,e1_00,e2,e3);
      gts_object_attributes((GtsObject *)f_00,(GtsObject *)ref);
      gts_surface_add_face(surface,f_00);
      pGVar9 = (GSList *)(&local_30->data)[1];
      g_slist_free_1(local_30);
      local_30 = local_28->next;
      if ((local_30 != (GSList *)0x0) && ((GtsEdge *)local_30->data != e3)) {
        local_30 = (GSList *)g_slist_prepend(local_30,e3);
      }
      if ((GtsEdge *)local_28->data == e2) {
        local_28->next = (GSList *)0x0;
      }
      else {
        pGVar5 = (GSList *)g_slist_prepend(0,e2);
        local_28->next = pGVar5;
      }
      triangulate_polygon(pGVar9,surface,ref);
      if (local_30 == (GSList *)0x0) break;
      local_28 = (GSList *)(&local_30->data)[1];
    }
  }
  g_slist_free(local_30);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void swap_if_in_circle(GtsFace *f1,GtsVertex *v1,GtsVertex *v2,GtsVertex *v3,GtsEdge *e1,GtsEdge *e2
                      ,GtsEdge *e3,GtsSurface *surface)

{
  GtsEdge *pGVar1;
  GtsObjectClass *pGVar2;
  GtsFace *f;
  GtsEdge *e4;
  GtsFace *f_00;
  GtsFace *f_01;
  GtsObjectClass *pGVar3;
  GSList *last4;
  GtsObjectClass *c;
  GtsObjectClass *c_4;
  GtsObjectClass *c_3;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  GtsVertex *v4;
  GtsVertex *v2_00;
  GtsObjectClass *pGVar4;
  GtsSegment *sn;
  GSList *last3;
  GtsObjectClass *pGVar5;
  gdouble gVar6;
  char *pcVar7;
  GtsVertex *local_44;
  GtsEdge *local_40;
  GtsEdge *local_3c;
  GtsEdge *local_38;
  GtsFace *local_30;
  
  local_44 = v2;
  local_30 = f1;
LAB_08136f28:
  pGVar2 = (GtsObjectClass *)gts_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else if (e1 != (GtsEdge *)0x0) {
    pGVar5 = (e1->segment).object.klass;
    if (pGVar5 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
    }
    else {
      do {
        if (pGVar2 == pGVar5) {
          return;
        }
        pGVar5 = pGVar5->parent_class;
      } while (pGVar5 != (GtsObjectClass *)0x0);
    }
  }
  f = neighbor(local_30,e1,surface);
  if (f != (GtsFace *)0x0) {
    pGVar1 = (f->triangle).e1;
    if (pGVar1 == e1) {
      local_3c = (f->triangle).e2;
      local_40 = (f->triangle).e3;
    }
    else {
      local_40 = (f->triangle).e2;
      local_3c = pGVar1;
      if (local_40 == e1) {
        local_3c = (f->triangle).e3;
        local_40 = pGVar1;
      }
    }
    v2_00 = (local_3c->segment).v1;
    if ((v2_00 == (e1->segment).v1) || (v2_00 == (e1->segment).v2)) {
      v2_00 = (local_3c->segment).v2;
    }
    gVar6 = gts_point_in_circle(&v2_00->p,&v1->p,&local_44->p,&v3->p);
    if (0.0 < gVar6) {
      local_38 = (GtsEdge *)gts_vertices_are_connected(v3,v2_00);
      pGVar2 = (GtsObjectClass *)gts_edge_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (local_38 != (GtsEdge *)0x0) {
        pGVar5 = (local_38->segment).object.klass;
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar2 == pGVar5) goto LAB_0813703d;
            pGVar5 = pGVar5->parent_class;
          } while (pGVar5 != (GtsObjectClass *)0x0);
        }
      }
      local_38 = gts_edge_new(surface->edge_class,v3,v2_00);
LAB_0813703d:
      f_00 = gts_face_new(surface->face_class,local_38,local_40,e2);
      gts_object_attributes((GtsObject *)f_00,(GtsObject *)local_30);
      f_01 = gts_face_new(surface->face_class,local_38,e3,local_3c);
      gts_object_attributes((GtsObject *)f_01,(GtsObject *)f);
      pGVar2 = (GtsObjectClass *)gts_list_face_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else if (f_00 != (GtsFace *)0x0) {
        pGVar5 = (f_00->triangle).object.klass;
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
        }
        else {
          do {
            if (pGVar2 == pGVar5) {
              pGVar2 = (GtsObjectClass *)gts_list_face_class();
              if (pGVar2 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                goto LAB_08137460;
              }
              if (local_30 == (GtsFace *)0x0) goto LAB_08137460;
              pGVar5 = (local_30->triangle).object.klass;
              if (pGVar5 != (GtsObjectClass *)0x0) goto LAB_0813711b;
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
              goto LAB_08137460;
            }
            pGVar5 = pGVar5->parent_class;
          } while (pGVar5 != (GtsObjectClass *)0x0);
        }
      }
      goto LAB_081371f8;
    }
  }
  return;
  while (pGVar5 = pGVar5->parent_class, pGVar5 != (GtsObjectClass *)0x0) {
LAB_0813711b:
    if (pGVar2 == pGVar5) {
      pGVar3 = (GtsObjectClass *)0x0;
      pGVar2 = local_30[1].triangle.object.klass;
      pGVar5 = pGVar2;
      if (pGVar2 == (GtsObjectClass *)0x0) goto LAB_08137194;
      pGVar4 = pGVar2;
      pGVar2 = (GtsObjectClass *)0x0;
      goto LAB_08137154;
    }
  }
LAB_08137460:
  pGVar5 = (GtsObjectClass *)0x0;
  pGVar3 = (GtsObjectClass *)gts_list_face_class();
  pGVar2 = (GtsObjectClass *)0x0;
  goto joined_r0x081371ad;
LAB_08137154:
  do {
    gVar6 = gts_point_orientation(&v3->p,&v2_00->p,*(GtsPoint **)(pGVar4->info).name);
    if (0.0 <= gVar6) {
      if (pGVar3 == (GtsObjectClass *)0x0) {
        f_00[1].triangle.object.klass = pGVar4;
        pGVar3 = pGVar4;
      }
      else {
        *(GtsObjectClass **)((pGVar3->info).name + 4) = pGVar4;
        pGVar3 = pGVar4;
      }
LAB_0813714d:
      pGVar5 = *(GtsObjectClass **)((pGVar4->info).name + 4);
    }
    else {
      if (pGVar2 == (GtsObjectClass *)0x0) {
        f_01[1].triangle.object.klass = pGVar4;
        pGVar2 = pGVar4;
        goto LAB_0813714d;
      }
      *(GtsObjectClass **)((pGVar2->info).name + 4) = pGVar4;
      pGVar5 = *(GtsObjectClass **)((pGVar4->info).name + 4);
      pGVar2 = pGVar4;
    }
    pGVar4 = pGVar5;
    pGVar5 = pGVar3;
  } while (pGVar4 != (GtsObjectClass *)0x0);
LAB_08137194:
  local_30[1].triangle.object.klass = (GtsObjectClass *)0x0;
  pGVar3 = (GtsObjectClass *)gts_list_face_class();
joined_r0x081371ad:
  if (pGVar3 == (GtsObjectClass *)0x0) {
    pcVar7 = "klass != NULL";
  }
  else {
    pGVar4 = (f->triangle).object.klass;
    if (pGVar4 != (GtsObjectClass *)0x0) {
joined_r0x081371c5:
      if (pGVar3 != pGVar4) goto LAB_081371d8;
      pGVar3 = f[1].triangle.object.klass;
      while (pGVar4 = pGVar2, pGVar3 != (GtsObjectClass *)0x0) {
        while (pGVar2 = pGVar3,
              gVar6 = gts_point_orientation(&v3->p,&v2_00->p,*(GtsPoint **)(pGVar2->info).name),
              gVar6 < 0.0) {
          if (pGVar4 == (GtsObjectClass *)0x0) {
            f_01[1].triangle.object.klass = pGVar2;
            pGVar4 = pGVar2;
            goto LAB_081372c9;
          }
          *(GtsObjectClass **)((pGVar4->info).name + 4) = pGVar2;
          pGVar3 = *(GtsObjectClass **)((pGVar2->info).name + 4);
          pGVar4 = pGVar2;
          if (pGVar3 == (GtsObjectClass *)0x0) goto LAB_0813730a;
        }
        if (pGVar5 == (GtsObjectClass *)0x0) {
          f_00[1].triangle.object.klass = pGVar2;
          pGVar5 = pGVar2;
        }
        else {
          *(GtsObjectClass **)((pGVar5->info).name + 4) = pGVar2;
          pGVar5 = pGVar2;
        }
LAB_081372c9:
        pGVar3 = *(GtsObjectClass **)((pGVar2->info).name + 4);
        pGVar2 = pGVar4;
      }
LAB_0813730a:
      f[1].triangle.object.klass = (GtsObjectClass *)0x0;
      goto LAB_081371e2;
    }
    pcVar7 = "c != NULL";
  }
  g_return_if_fail_warning(0,"gts_object_is_from_class",pcVar7);
LAB_081371e2:
  if (pGVar5 != (GtsObjectClass *)0x0) {
    *(undefined4 *)((pGVar5->info).name + 4) = 0;
  }
  if (pGVar2 != (GtsObjectClass *)0x0) {
    *(undefined4 *)((pGVar2->info).name + 4) = 0;
  }
LAB_081371f8:
  gts_surface_remove_face(surface,local_30);
  gts_surface_remove_face(surface,f);
  gts_surface_add_face(surface,f_00);
  gts_surface_add_face(surface,f_01);
  swap_if_in_circle(f_00,v2_00,local_44,v3,local_40,e2,local_38,surface);
  e2 = local_38;
  e1 = local_3c;
  local_44 = v2_00;
  local_30 = f_01;
  goto LAB_08136f28;
LAB_081371d8:
  pGVar4 = pGVar4->parent_class;
  if (pGVar4 == (GtsObjectClass *)0x0) goto LAB_081371e2;
  goto joined_r0x081371c5;
}



// WARNING: Unknown calling convention

GtsVertex * gts_delaunay_add_vertex_to_face(GtsSurface *surface,GtsVertex *v,GtsFace *f)

{
  double dVar1;
  GtsObjectClass *pGVar2;
  GtsEdgeClass *pGVar3;
  gpointer pvVar4;
  GtsFace *f_00;
  GtsFace *f_01;
  GtsFace *f_02;
  GtsFaceClass *pGVar5;
  GSList *i;
  guint j;
  uint uVar6;
  GtsVertex *pGVar7;
  GtsPoint *p;
  GtsObjectClass *pGVar8;
  gdouble o;
  gdouble gVar9;
  GtsEdge *local_5c;
  GtsEdge *local_58;
  GtsEdge *local_54;
  GSList *last [3];
  GtsFace *nf [3];
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsEdge *local_28;
  GtsEdge *local_24;
  GtsEdge *local_20 [4];
  
  pGVar7 = v;
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_vertex_to_face","surface != NULL");
  }
  else if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_vertex_to_face","v != NULL");
    pGVar7 = (GtsVertex *)0x0;
  }
  else if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_vertex_to_face","f != NULL");
  }
  else {
    gts_triangle_vertices_edges
              (&f->triangle,(GtsEdge *)0x0,&local_2c,&local_30,&local_34,local_20,&local_24,
               &local_28);
    if (((v == local_2c) || (v == local_30)) || (v == local_34)) {
      pGVar7 = (GtsVertex *)0x0;
    }
    else {
      dVar1 = (v->p).x;
      if ((((dVar1 != (local_2c->p).x) || (pGVar7 = local_2c, (v->p).y != (local_2c->p).y)) &&
          ((dVar1 != (local_30->p).x || (pGVar7 = local_30, (v->p).y != (local_30->p).y)))) &&
         ((dVar1 != (local_34->p).x || (pGVar7 = local_34, (v->p).y != (local_34->p).y)))) {
        local_5c = (GtsEdge *)gts_vertices_are_connected(v,local_2c);
        pGVar3 = gts_edge_class();
        pvVar4 = gts_object_is_from_class(local_5c,pGVar3);
        if (pvVar4 == (gpointer)0x0) {
          local_5c = gts_edge_new(surface->edge_class,v,local_2c);
        }
        local_58 = (GtsEdge *)gts_vertices_are_connected(v,local_30);
        pGVar3 = gts_edge_class();
        pvVar4 = gts_object_is_from_class(local_58,pGVar3);
        if (pvVar4 == (gpointer)0x0) {
          local_58 = gts_edge_new(surface->edge_class,v,local_30);
        }
        local_54 = (GtsEdge *)gts_vertices_are_connected(v,local_34);
        pGVar3 = gts_edge_class();
        pvVar4 = gts_object_is_from_class(local_54,pGVar3);
        if (pvVar4 == (gpointer)0x0) {
          local_54 = gts_edge_new(surface->edge_class,v,local_34);
        }
        f_00 = gts_face_new(surface->face_class,local_5c,local_20[0],local_58);
        nf[0] = f_00;
        gts_object_attributes((GtsObject *)f_00,(GtsObject *)f);
        f_01 = gts_face_new(surface->face_class,local_58,local_24,local_54);
        nf[1] = f_01;
        gts_object_attributes((GtsObject *)f_01,(GtsObject *)f);
        f_02 = gts_face_new(surface->face_class,local_54,local_28,local_5c);
        nf[2] = f_02;
        gts_object_attributes((GtsObject *)f_02,(GtsObject *)f);
        pGVar5 = gts_list_face_class();
        pvVar4 = gts_object_is_from_class(f,pGVar5);
        if (pvVar4 != (gpointer)0x0) {
          pGVar5 = gts_list_face_class();
          pvVar4 = gts_object_is_from_class(f_00,pGVar5);
          if (pvVar4 != (gpointer)0x0) {
            pGVar8 = f[1].triangle.object.klass;
            last[0] = (GSList *)0x0;
            last[1] = (GSList *)0x0;
            last[2] = (GSList *)0x0;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              f[1].triangle.object.klass = (GtsObjectClass *)0x0;
            }
            else {
              do {
                pGVar7 = *(GtsVertex **)(pGVar8->info).name;
                pGVar2 = *(GtsObjectClass **)((int)(pGVar8->info).name + 4);
                if (v == pGVar7) {
                  g_slist_free_1(pGVar8);
                }
                else {
                  gVar9 = gts_point_orientation(&v->p,&local_2c->p,&pGVar7->p);
                  if (0.0 <= gVar9) {
                    gVar9 = gts_point_orientation(&v->p,&local_30->p,&pGVar7->p);
                    if (gVar9 == 0.0) {
                      gVar9 = gts_point_orientation(&v->p,&local_34->p,&pGVar7->p);
                      uVar6 = (uint)(gVar9 <= 0.0);
                    }
                    else {
                      uVar6 = (uint)(0.0 < gVar9);
                    }
                  }
                  else {
                    gVar9 = gts_point_orientation(&v->p,&local_34->p,&pGVar7->p);
                    uVar6 = (0.0 < gVar9) + 1;
                  }
                  if (last[uVar6] == (GSList *)0x0) {
                    nf[uVar6][1].triangle.object.klass = pGVar8;
                  }
                  else {
                    last[uVar6]->next = (GSList *)pGVar8;
                  }
                  last[uVar6] = (GSList *)pGVar8;
                }
                pGVar8 = pGVar2;
              } while (pGVar2 != (GtsObjectClass *)0x0);
              f[1].triangle.object.klass = (GtsObjectClass *)0x0;
              if (last[0] != (GSList *)0x0) {
                last[0]->next = (GSList *)0x0;
              }
              if (last[1] != (GSList *)0x0) {
                last[1]->next = (GSList *)0x0;
              }
              if (last[2] != (GSList *)0x0) {
                last[2]->next = (GSList *)0x0;
              }
            }
          }
        }
        gts_surface_remove_face(surface,f);
        gts_surface_add_face(surface,f_00);
        gts_surface_add_face(surface,f_01);
        gts_surface_add_face(surface,f_02);
        swap_if_in_circle(f_00,local_2c,local_30,v,local_20[0],local_58,local_5c,surface);
        swap_if_in_circle(f_01,local_30,local_34,v,local_24,local_54,local_58,surface);
        swap_if_in_circle(f_02,local_34,local_2c,v,local_28,local_5c,local_54,surface);
        pGVar7 = (GtsVertex *)0x0;
      }
    }
  }
  return pGVar7;
}



// WARNING: Unknown calling convention

GtsVertex * gts_delaunay_add_vertex(GtsSurface *surface,GtsVertex *v,GtsFace *guess)

{
  GtsFace *f_00;
  GtsFace *f;
  GtsVertex *pGVar1;
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_vertex","surface != NULL");
  }
  else {
    if (v == (GtsVertex *)0x0) {
      g_return_if_fail_warning(0,"gts_delaunay_add_vertex","v != NULL");
      return (GtsVertex *)0x0;
    }
    f_00 = gts_point_locate(&v->p,surface,guess);
    if (f_00 != (GtsFace *)0x0) {
      pGVar1 = gts_delaunay_add_vertex_to_face(surface,v,f_00);
      return pGVar1;
    }
  }
  return v;
}



// WARNING: Unknown calling convention

void gts_delaunay_remove_vertex(GtsSurface *surface,GtsVertex *v)

{
  gpointer *ppvVar1;
  GSList *pGVar2;
  GtsObjectClass *pGVar3;
  GSList *pGVar4;
  gboolean gVar5;
  GtsObjectClass *c;
  GtsObjectClass *c_1;
  GtsObjectClass *pGVar6;
  GSList *i;
  GtsFace *ref;
  GtsFace *pGVar7;
  bool bVar8;
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_remove_vertex","surface != NULL");
  }
  else if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_remove_vertex","v != NULL");
  }
  else {
    pGVar2 = gts_vertex_triangles(v,(GSList *)0x0);
    pGVar4 = pGVar2;
    if (pGVar2 != (GSList *)0x0) {
      do {
        pGVar3 = (GtsObjectClass *)gts_face_class();
        pGVar7 = (GtsFace *)pGVar4->data;
        if (pGVar3 == (GtsObjectClass *)0x0) {
          pGVar7 = (GtsFace *)0x0;
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          bVar8 = true;
        }
        else {
          if (pGVar7 != (GtsFace *)0x0) {
            pGVar6 = (pGVar7->triangle).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            }
            else {
              do {
                if (pGVar3 == pGVar6) {
                  gVar5 = gts_face_has_parent_surface(pGVar7,surface);
                  if (gVar5 != 0) {
                    pGVar7 = (GtsFace *)pGVar4->data;
                    bVar8 = pGVar7 == (GtsFace *)0x0;
                    goto LAB_08137b45;
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
          bVar8 = true;
          pGVar7 = (GtsFace *)0x0;
        }
LAB_08137b45:
        ppvVar1 = &pGVar4->data;
      } while ((bVar8) && (pGVar4 = (GSList *)ppvVar1[1], (GSList *)ppvVar1[1] != (GSList *)0x0));
      if (pGVar7 != (GtsFace *)0x0) {
        pGVar4 = gts_vertex_fan_oriented(v,surface);
        triangulate_polygon(pGVar4,surface,pGVar7);
        do {
          pGVar3 = (GtsObjectClass *)gts_face_class();
          pGVar7 = (GtsFace *)pGVar2->data;
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else if (pGVar7 != (GtsFace *)0x0) {
            pGVar6 = (pGVar7->triangle).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
            }
            else {
              do {
                if (pGVar3 == pGVar6) {
                  gVar5 = gts_face_has_parent_surface(pGVar7,surface);
                  if (gVar5 != 0) {
                    gts_surface_remove_face(surface,(GtsFace *)pGVar2->data);
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
          pGVar2 = (GSList *)(&pGVar2->data)[1];
          if (pGVar2 == (GSList *)0x0) {
            g_slist_free();
            return;
          }
        } while( true );
      }
    }
    g_slist_free(pGVar2);
    g_return_if_fail_warning(0,"gts_delaunay_remove_vertex","ref");
  }
  return;
}



// WARNING: Unknown calling convention

void gts_delaunay_remove_hull(GtsSurface *surface)

{
  GtsEdge *e_00;
  GtsObjectClass *pGVar1;
  GtsFace *f;
  GtsFace *pGVar2;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  GtsObjectClass *c_3;
  GtsObjectClass *pGVar3;
  GtsObjectClass *c;
  GSList *boundary;
  GSList *pGVar4;
  GtsEdge *e;
  GtsEdge *pGVar5;
  char *pcVar6;
  GtsEdge *local_20;
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_remove_hull","surface != NULL");
  }
  else {
    boundary = gts_surface_boundary(surface);
    gts_allow_floating_edges = 1;
    while (pGVar4 = boundary, boundary != (GSList *)0x0) {
      while( true ) {
        e_00 = (GtsEdge *)pGVar4->data;
        boundary = (GSList *)(&pGVar4->data)[1];
        g_slist_free_1(pGVar4);
        pGVar1 = (GtsObjectClass *)gts_constraint_class();
        if (pGVar1 == (GtsObjectClass *)0x0) break;
        if (e_00 == (GtsEdge *)0x0) goto LAB_08137d96;
        pGVar3 = (e_00->segment).object.klass;
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
          goto LAB_08137d96;
        }
        while (pGVar1 != pGVar3) {
          pGVar3 = pGVar3->parent_class;
          if (pGVar3 == (GtsObjectClass *)0x0) goto LAB_08137d96;
        }
        pGVar4 = boundary;
        if (boundary == (GSList *)0x0) goto LAB_08137eec;
      }
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
LAB_08137d96:
      f = gts_edge_is_boundary(e_00,surface);
      if (f != (GtsFace *)0x0) {
        if (e_00 != (f->triangle).e1) {
          pGVar1 = (GtsObjectClass *)gts_constraint_class();
          local_20 = (f->triangle).e1;
          if (pGVar1 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            local_20 = (f->triangle).e1;
          }
          else if (local_20 != (GtsEdge *)0x0) {
            pGVar3 = (local_20->segment).object.klass;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
              local_20 = (f->triangle).e1;
            }
            else {
              do {
                if (pGVar1 == pGVar3) goto LAB_08137e13;
                pGVar3 = pGVar3->parent_class;
              } while (pGVar3 != (GtsObjectClass *)0x0);
            }
          }
          pGVar2 = gts_edge_is_boundary(local_20,surface);
          if (pGVar2 == (GtsFace *)0x0) {
            boundary = (GSList *)g_slist_prepend(boundary,(f->triangle).e1);
          }
        }
LAB_08137e13:
        if (e_00 != (f->triangle).e2) {
          pGVar1 = (GtsObjectClass *)gts_constraint_class();
          pGVar5 = (f->triangle).e2;
          if (pGVar1 == (GtsObjectClass *)0x0) {
            pcVar6 = "klass != NULL";
LAB_08137f33:
            g_return_if_fail_warning(0,"gts_object_is_from_class",pcVar6);
            pGVar5 = (f->triangle).e2;
          }
          else if (pGVar5 != (GtsEdge *)0x0) {
            pGVar3 = (pGVar5->segment).object.klass;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              pcVar6 = "c != NULL";
              goto LAB_08137f33;
            }
            do {
              if (pGVar1 == pGVar3) goto LAB_08137e5a;
              pGVar3 = pGVar3->parent_class;
            } while (pGVar3 != (GtsObjectClass *)0x0);
          }
          pGVar2 = gts_edge_is_boundary(pGVar5,surface);
          if (pGVar2 == (GtsFace *)0x0) {
            boundary = (GSList *)g_slist_prepend(boundary,(f->triangle).e2);
          }
        }
LAB_08137e5a:
        if (e_00 != (f->triangle).e3) {
          pGVar1 = (GtsObjectClass *)gts_constraint_class();
          pGVar5 = (f->triangle).e3;
          if (pGVar1 == (GtsObjectClass *)0x0) {
            pcVar6 = "klass != NULL";
LAB_08137f90:
            g_return_if_fail_warning(0,"gts_object_is_from_class",pcVar6);
            pGVar5 = (f->triangle).e3;
          }
          else if (pGVar5 != (GtsEdge *)0x0) {
            pGVar3 = (pGVar5->segment).object.klass;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              pcVar6 = "c != NULL";
              goto LAB_08137f90;
            }
            do {
              if (pGVar1 == pGVar3) goto LAB_08137ea2;
              pGVar3 = pGVar3->parent_class;
            } while (pGVar3 != (GtsObjectClass *)0x0);
          }
          pGVar2 = gts_edge_is_boundary(pGVar5,surface);
          if (pGVar2 == (GtsFace *)0x0) {
            boundary = (GSList *)g_slist_prepend(boundary,(f->triangle).e3);
          }
        }
LAB_08137ea2:
        gts_surface_remove_face(surface,f);
      }
      if (e_00->triangles == (GSList *)0x0) {
        gts_object_destroy((GtsObject *)e_00);
      }
    }
LAB_08137eec:
    gts_allow_floating_edges = 0;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x08138162)
// WARNING: Removing unreachable block (ram,0x0813815c)
// WARNING: Unknown calling convention

GSList * remove_intersected_edge
                   (GtsSegment *s,GtsEdge *e,GtsFace *f,GtsSurface *surface,GSList **left,
                   GSList **right)

{
  GtsObjectClass *pGVar1;
  GtsFace *f_00;
  GSList *pGVar2;
  GtsObjectClass *c;
  GtsObjectClass *pGVar3;
  GSList *constraint;
  GtsFace *next;
  gdouble o2;
  gdouble o1;
  gdouble gVar4;
  gdouble gVar5;
  GtsEdge *local_40 [4];
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  local_40[0] = e;
  pGVar1 = (GtsObjectClass *)gts_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
LAB_081383af:
    constraint = (GSList *)0x0;
  }
  else {
    if (local_40[0] == (GtsEdge *)0x0) goto LAB_081383af;
    pGVar3 = (local_40[0]->segment).object.klass;
    if (pGVar3 != (GtsObjectClass *)0x0) {
      do {
        if (pGVar1 == pGVar3) {
          constraint = (GSList *)g_slist_prepend(0,local_40[0]);
          goto LAB_081380cf;
        }
        pGVar3 = pGVar3->parent_class;
      } while (pGVar3 != (GtsObjectClass *)0x0);
      goto LAB_081383af;
    }
    constraint = (GSList *)0x0;
    g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
  }
LAB_081380cf:
  gts_triangle_vertices_edges
            (&f->triangle,local_40[0],local_20,&local_24,&local_28,local_40,&local_2c,&local_30);
  gVar4 = gts_point_orientation(&local_24->p,&local_28->p,&s->v2->p);
  gVar5 = gts_point_orientation(&local_28->p,&local_20[0]->p,&s->v2->p);
  if ((gVar4 == 0.0) && (gVar5 == 0.0)) {
    remove_triangles(local_40[0],surface);
    if ((constraint == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
      gts_object_destroy((GtsObject *)local_40[0]);
    }
    pGVar2 = (GSList *)g_slist_prepend(*left,local_30);
    *left = pGVar2;
    pGVar2 = (GSList *)g_slist_prepend(*right,local_2c);
    *right = pGVar2;
    return constraint;
  }
  if (gVar4 <= 0.0) {
    if (gVar5 < 0.0) {
      gVar4 = gts_point_orientation(&s->v1->p,&s->v2->p,&local_28->p);
      if (gVar4 <= 0.0) {
        f_00 = neighbor(f,local_30,surface);
        remove_triangles(local_40[0],surface);
        if ((constraint == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
          gts_object_destroy((GtsObject *)local_40[0]);
        }
        if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
          g_assertion_message_expr
                    (0,"../../src/gts/cdt.c",0x37a,"remove_intersected_edge",&DAT_08161c06);
        }
        goto LAB_081381a8;
      }
      f_00 = neighbor(f,local_2c,surface);
      remove_triangles(local_40[0],surface);
      if ((constraint == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
        gts_object_destroy((GtsObject *)local_40[0]);
      }
      if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/gts/cdt.c",0x378,"remove_intersected_edge",&DAT_08161c06);
      }
    }
    else {
      f_00 = neighbor(f,local_2c,surface);
      remove_triangles(local_40[0],surface);
      if ((constraint == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
        gts_object_destroy((GtsObject *)local_40[0]);
      }
      if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/gts/cdt.c",0x373,"remove_intersected_edge",&DAT_08161c06);
      }
    }
    pGVar2 = (GSList *)g_slist_prepend(*left,local_30);
    *left = pGVar2;
    local_30 = local_2c;
  }
  else {
    if (0.0 < gVar5) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/cdt.c",0x36f,"remove_intersected_edge","o2 <= 0.");
    }
    f_00 = neighbor(f,local_30,surface);
    remove_triangles(local_40[0],surface);
    if ((constraint == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
      gts_object_destroy((GtsObject *)local_40[0]);
    }
    if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/gts/cdt.c",0x370,"remove_intersected_edge",&DAT_08161c06);
    }
LAB_081381a8:
    pGVar2 = (GSList *)g_slist_prepend(*right,local_2c);
    *right = pGVar2;
  }
  pGVar2 = remove_intersected_edge(s,local_30,f_00,surface,left,right);
  pGVar2 = (GSList *)g_slist_concat(constraint,pGVar2);
  return pGVar2;
}



// WARNING: Unknown calling convention

GSList * gts_delaunay_add_constraint(GtsSurface *surface,GtsConstraint *c)

{
  GtsFace *f;
  GtsVertex *pGVar1;
  GtsObjectClass *pGVar2;
  GtsVertex *v1;
  GSList *pGVar3;
  gboolean gVar4;
  GtsFace *f_00;
  undefined4 uVar5;
  GSList *pGVar6;
  GtsObjectClass *c_1;
  GtsObjectClass *c_2;
  GtsObjectClass *pGVar7;
  GSList *i;
  gdouble o1;
  gdouble gVar8;
  GSList *local_50;
  GtsEdge *local_40;
  GtsEdge *local_3c;
  GtsEdge *local_38;
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GSList *local_24;
  GSList *local_20 [4];
  
  local_20[0] = (GSList *)0x0;
  local_24 = (GSList *)0x0;
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_constraint","surface != NULL");
  }
  else if (c == (GtsConstraint *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_constraint","c != NULL");
  }
  else {
    pGVar2 = (GtsObjectClass *)gts_constraint_class();
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else {
      pGVar7 = (c->edge).segment.object.klass;
      if (pGVar7 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
      }
      else {
        do {
          if (pGVar2 == pGVar7) {
            local_28 = (c->edge).segment.v1;
            gts_allow_floating_edges = 1;
            pGVar3 = gts_vertex_triangles(local_28,(GSList *)0x0);
            pGVar6 = pGVar3;
            do {
              if (pGVar6 == (GSList *)0x0) {
                    // WARNING: Subroutine does not return
                g_assertion_message(0,"../../src/gts/cdt.c",0x3be,"remove_intersected_vertex",0);
              }
              f = (GtsFace *)pGVar6->data;
              pGVar2 = (GtsObjectClass *)gts_face_class();
              if (pGVar2 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
              }
              else if (f != (GtsFace *)0x0) {
                pGVar7 = (f->triangle).object.klass;
                if (pGVar7 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class","c != NULL");
                }
                else {
                  do {
                    if (pGVar2 == pGVar7) {
                      gVar4 = gts_face_has_parent_surface(f,surface);
                      if (gVar4 != 0) {
                        gts_triangle_vertices((GtsTriangle *)f,&local_2c,&local_30,&local_34);
                        pGVar1 = local_30;
                        if (local_28 == local_30) {
                          local_30 = local_34;
                          local_34 = local_2c;
                        }
                        else if (local_28 == local_34) {
                          local_30 = local_2c;
                          local_34 = pGVar1;
                        }
                        else if (local_28 != local_2c) {
                    // WARNING: Subroutine does not return
                          g_assertion_message_expr
                                    (0,"../../src/gts/cdt.c",0x39c,"remove_intersected_vertex",
                                     &DAT_08161c21);
                        }
                        gVar8 = gts_point_orientation
                                          (&local_28->p,&local_30->p,&((c->edge).segment.v2)->p);
                        if ((0.0 <= gVar8) &&
                           (gVar8 = gts_point_orientation
                                              (&local_34->p,&local_28->p,&((c->edge).segment.v2)->p)
                           , 0.0 <= gVar8)) {
                          gVar8 = gts_point_orientation
                                            (&local_30->p,&local_34->p,&((c->edge).segment.v2)->p);
                          local_38 = gts_triangle_edge_opposite((GtsTriangle *)f,local_28);
                          f_00 = neighbor(f,local_38,surface);
                          gts_triangle_vertices_edges
                                    ((GtsTriangle *)f,local_38,&local_30,&local_34,&local_28,
                                     &local_38,&local_40,&local_3c);
                          g_slist_free(pGVar3);
                          local_50 = (GSList *)0x0;
                          if (gVar8 < 0.0) {
                            gts_allow_floating_faces = 1;
                            gts_surface_remove_face(surface,f);
                            gts_allow_floating_faces = 0;
                            local_20[0] = (GSList *)g_slist_prepend(local_20[0],local_40);
                            local_24 = (GSList *)g_slist_prepend(local_24,local_3c);
                            if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
                              g_assertion_message_expr
                                        (0,"../../src/gts/cdt.c",0x3b7,"remove_intersected_vertex",
                                         &DAT_08161c06);
                            }
                            local_50 = remove_intersected_edge
                                                 ((GtsSegment *)c,local_38,f_00,surface,local_20,
                                                  &local_24);
                          }
                          gts_allow_floating_edges = 0;
                          uVar5 = g_slist_reverse(local_24);
                          pGVar6 = (GSList *)g_slist_prepend(uVar5,c);
                          triangulate_polygon(pGVar6,surface,f);
                          pGVar6 = (GSList *)g_slist_prepend(local_20[0],c);
                          triangulate_polygon(pGVar6,surface,f);
                          if (f->surfaces != (GSList *)0x0) {
                            return local_50;
                          }
                          gts_allow_floating_edges = 1;
                          gts_object_destroy((GtsObject *)f);
                          gts_allow_floating_edges = 0;
                          return local_50;
                        }
                      }
                      break;
                    }
                    pGVar7 = pGVar7->parent_class;
                  } while (pGVar7 != (GtsObjectClass *)0x0);
                }
              }
              pGVar6 = (GSList *)(&pGVar6->data)[1];
            } while( true );
          }
          pGVar7 = pGVar7->parent_class;
        } while (pGVar7 != (GtsObjectClass *)0x0);
      }
    }
    g_return_if_fail_warning(0,"gts_delaunay_add_constraint","GTS_IS_CONSTRAINT (c)");
  }
  return (GSList *)0x0;
}



// WARNING: Unknown calling convention

int planeBoxOverlap(double *normal,double *vert,double *maxbox)

{
  double dVar1;
  double dVar2;
  int iVar3;
  int q;
  uint uVar4;
  double v;
  double vmax [3];
  double vmin [3];
  
  iVar3 = 0;
  do {
    dVar1 = vert[iVar3];
    if (normal[iVar3] <= 0.0) {
      dVar2 = maxbox[iVar3];
      vmin[iVar3] = dVar2 - dVar1;
      vmax[iVar3] = -dVar2 - dVar1;
    }
    else {
      dVar2 = maxbox[iVar3];
      vmin[iVar3] = -dVar2 - dVar1;
      vmax[iVar3] = dVar2 - dVar1;
    }
    iVar3 = iVar3 + 1;
  } while (iVar3 != 3);
  uVar4 = 0;
  if (vmin[2] * normal[2] + vmin[1] * normal[1] + vmin[0] * *normal <= 0.0) {
    uVar4 = (uint)(0.0 <= normal[2] * vmax[2] + normal[1] * vmax[1] + vmax[0] * *normal);
  }
  return uVar4;
}



// WARNING: Unknown calling convention

int triBoxOverlap(double *boxcenter,double *boxhalfsize,double (*triverts) [3])

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  double dVar22;
  float fVar23;
  double dVar24;
  double dVar25;
  double dVar26;
  int iVar27;
  double p2;
  double min;
  double p1;
  double local_ac;
  double normal [3];
  double v0 [3];
  
  fVar20 = (float)(*triverts)[0] - (float)*boxcenter;
  v0[0] = (double)fVar20;
  fVar21 = (float)(*triverts)[1] - (float)boxcenter[1];
  v0[1] = (double)fVar21;
  fVar18 = (float)(*triverts)[2] - (float)boxcenter[2];
  v0[2] = (double)fVar18;
  fVar8 = (float)triverts[1][1] - (float)boxcenter[1];
  fVar6 = (float)triverts[1][2] - (float)boxcenter[2];
  fVar13 = (float)triverts[2][1] - (float)boxcenter[1];
  fVar7 = (float)triverts[2][2] - (float)boxcenter[2];
  fVar1 = fVar8 - fVar21;
  fVar17 = fVar6 - fVar18;
  fVar2 = fVar21 * fVar17 - fVar18 * fVar1;
  fVar5 = fVar13 * fVar17 - fVar7 * fVar1;
  fVar3 = fVar5;
  if (fVar2 <= fVar5 || fVar5 != fVar2) {
    fVar3 = fVar2;
    fVar2 = fVar5;
  }
  fVar15 = (float)boxhalfsize[1];
  fVar16 = (float)boxhalfsize[2];
  fVar5 = fVar16 * ABS(fVar1) + fVar15 * ABS(fVar17);
  if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
    fVar11 = (float)triverts[1][0] - (float)*boxcenter;
    dVar22 = triverts[2][0] - *boxcenter;
    fVar19 = fVar11 - fVar20;
    fVar5 = fVar19 * fVar18 + fVar20 * -fVar17;
    fVar2 = fVar7 * fVar19 + (float)dVar22 * -fVar17;
    fVar3 = fVar2;
    if (fVar5 <= fVar2 || fVar2 != fVar5) {
      fVar3 = fVar5;
      fVar5 = fVar2;
    }
    fVar4 = (float)*boxhalfsize;
    fVar2 = ABS(fVar19) * fVar16 + fVar4 * ABS(fVar17);
    if ((fVar3 <= fVar2) && (-fVar2 <= fVar5)) {
      fVar5 = fVar11 * fVar1 - fVar8 * fVar19;
      fVar2 = (float)dVar22 * fVar1 - fVar13 * fVar19;
      fVar3 = fVar5;
      if (fVar2 <= fVar5 || fVar5 != fVar2) {
        fVar3 = fVar2;
        fVar2 = fVar5;
      }
      fVar5 = ABS(fVar19) * fVar15 + ABS(fVar1) * fVar4;
      if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
        fVar23 = fVar13 - fVar8;
        fVar14 = fVar7 - fVar6;
        fVar2 = fVar14 * fVar21 - fVar23 * fVar18;
        fVar5 = fVar13 * fVar14 - fVar7 * fVar23;
        fVar3 = fVar5;
        if (fVar2 <= fVar5 || fVar5 != fVar2) {
          fVar3 = fVar2;
          fVar2 = fVar5;
        }
        fVar5 = fVar16 * ABS(fVar23) + fVar15 * ABS(fVar14);
        if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
          dVar24 = dVar22 - (double)fVar11;
          fVar2 = (float)dVar24 * fVar18 + fVar20 * -fVar14;
          fVar5 = fVar7 * (float)dVar24 + -fVar14 * (float)dVar22;
          fVar3 = fVar5;
          if (fVar2 <= fVar5 || fVar5 != fVar2) {
            fVar3 = fVar2;
            fVar2 = fVar5;
          }
          fVar5 = fVar16 * ABS((float)dVar24) + fVar4 * ABS(fVar14);
          if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
            fVar2 = fVar23 * fVar20 - (float)dVar24 * fVar21;
            fVar5 = fVar11 * fVar23 - fVar8 * (float)dVar24;
            fVar3 = fVar5;
            if (fVar2 <= fVar5 || fVar5 != fVar2) {
              fVar3 = fVar2;
              fVar2 = fVar5;
            }
            fVar5 = fVar15 * ABS((float)dVar24) + fVar4 * ABS(fVar23);
            if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
              fVar3 = fVar21 - fVar13;
              fVar2 = fVar18 - fVar7;
              fVar5 = fVar2 * fVar21 - fVar3 * fVar18;
              fVar10 = fVar8 * fVar2 - fVar6 * fVar3;
              fVar9 = fVar10;
              if (fVar5 <= fVar10 || fVar10 != fVar5) {
                fVar9 = fVar5;
                fVar5 = fVar10;
              }
              fVar10 = fVar16 * ABS(fVar3) + fVar15 * ABS(fVar2);
              if ((fVar9 <= fVar10) && (-fVar10 <= fVar5)) {
                fVar12 = fVar20 - (float)dVar22;
                fVar5 = fVar12 * fVar18 + fVar20 * -fVar2;
                fVar10 = fVar6 * fVar12 + -fVar2 * fVar11;
                fVar9 = fVar10;
                if (fVar5 <= fVar10 || fVar10 != fVar5) {
                  fVar9 = fVar5;
                  fVar5 = fVar10;
                }
                fVar2 = fVar16 * ABS(fVar12) + fVar4 * ABS(fVar2);
                if ((fVar9 <= fVar2) && (-fVar2 <= fVar5)) {
                  local_ac = (double)fVar11 * (double)fVar3 - (double)fVar8 * (double)fVar12;
                  dVar26 = dVar22 * (double)fVar3 - (double)fVar13 * (double)fVar12;
                  dVar25 = dVar26;
                  if (local_ac <= dVar26) {
                    dVar25 = local_ac;
                    local_ac = dVar26;
                  }
                  dVar26 = (double)fVar15 * (double)ABS(fVar12) + (double)fVar4 * (double)ABS(fVar3)
                  ;
                  if ((dVar25 <= dVar26) && (-dVar26 <= local_ac)) {
                    fVar2 = fVar11;
                    if (fVar20 <= fVar11) {
                      fVar2 = fVar20;
                    }
                    if (fVar11 <= fVar20) {
                      fVar11 = fVar20;
                    }
                    fVar3 = (float)dVar22;
                    if (fVar3 <= fVar2 || fVar2 != fVar3) {
                      fVar2 = fVar3;
                    }
                    if (fVar3 <= fVar11) {
                      fVar3 = fVar11;
                    }
                    if ((fVar2 <= fVar4) && (-fVar4 <= fVar3)) {
                      fVar2 = fVar8;
                      if (fVar21 <= fVar8) {
                        fVar2 = fVar21;
                      }
                      if (fVar8 <= fVar21) {
                        fVar8 = fVar21;
                      }
                      if (fVar13 <= fVar2 || fVar2 != fVar13) {
                        fVar2 = fVar13;
                      }
                      if (fVar13 <= fVar8) {
                        fVar13 = fVar8;
                      }
                      if ((fVar2 <= fVar15) && (-fVar15 <= fVar13)) {
                        fVar8 = fVar6;
                        if (fVar18 <= fVar6) {
                          fVar8 = fVar18;
                        }
                        if (fVar6 <= fVar18) {
                          fVar6 = fVar18;
                        }
                        if (fVar7 <= fVar8 || fVar8 != fVar7) {
                          fVar8 = fVar7;
                        }
                        if (fVar7 <= fVar6) {
                          fVar7 = fVar6;
                        }
                        if ((fVar8 <= fVar16) && (-fVar16 <= fVar7)) {
                          normal[0] = (double)(fVar14 * fVar1 - fVar23 * fVar17);
                          normal[1] = (double)(fVar17 * (float)dVar24 - fVar19 * fVar14);
                          normal[2] = (double)(fVar19 * fVar23 - fVar1 * (float)dVar24);
                          iVar27 = planeBoxOverlap(normal,v0,boxhalfsize);
                          return (uint)(iVar27 != 0);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void segment_class_init(GtsObjectClass *klass)

{
  klass->destroy = segment_destroy;
  return;
}



// WARNING: Unknown calling convention

void segment_init(GtsSegment *segment)

{
  segment->v2 = (GtsVertex *)0x0;
  segment->v1 = (GtsVertex *)0x0;
  return;
}



// WARNING: Unknown calling convention

GtsSegment * gts_segment_is_duplicate(GtsSegment *s)

{
  GtsVertex *pGVar1;
  GtsSegment *s1;
  GtsSegment *s1_1;
  GtsVertex *v2;
  GSList *i;
  GSList *pGVar2;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_is_duplicate","s != NULL");
    return (GtsSegment *)0x0;
  }
  pGVar1 = s->v2;
  pGVar2 = s->v1->segments;
  if (pGVar1 == s->v1) {
    if (pGVar2 != (GSList *)0x0) {
      while (((s1_1 = (GtsSegment *)pGVar2->data, s1_1 == s || (s1_1->v1 != pGVar1)) ||
             (pGVar1 != s1_1->v2))) {
        pGVar2 = pGVar2->next;
        if (pGVar2 == (GSList *)0x0) {
          s1_1 = (GtsSegment *)0x0;
          return s1_1;
        }
      }
      return s1_1;
    }
  }
  else {
    for (; pGVar2 != (GSList *)0x0; pGVar2 = pGVar2->next) {
      s1_1 = (GtsSegment *)pGVar2->data;
      if (s1_1 != s) {
        if (s1_1->v1 == pGVar1) {
          return s1_1;
        }
        if (s1_1->v2 == pGVar1) {
          return s1_1;
        }
      }
    }
  }
  s1_1 = (GtsSegment *)0x0;
  return s1_1;
}



// WARNING: Unknown calling convention

gboolean gts_segment_is_ok(GtsSegment *s)

{
  GtsSegment *pGVar1;
  gboolean gVar2;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_is_ok","s != NULL");
    return 0;
  }
  if (s->v1 != s->v2) {
    pGVar1 = gts_segment_is_duplicate(s);
    if (pGVar1 == (GtsSegment *)0x0) {
      if ((s->object).reserved != (gpointer)0x0) {
        g_return_if_fail_warning(0,"gts_segment_is_ok","GTS_OBJECT (s)->reserved == NULL");
        return 0;
      }
      gVar2 = 1;
    }
    else {
      g_return_if_fail_warning(0,"gts_segment_is_ok","!gts_segment_is_duplicate (s)");
      gVar2 = 0;
    }
    return gVar2;
  }
  g_return_if_fail_warning(0,"gts_segment_is_ok","s->v1 != s->v2");
  return 0;
}



// WARNING: Unknown calling convention

GSList * gts_segments_from_vertices(GSList *vertices)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  GSList *j;
  GtsSegment *s;
  GHashTable *hash;
  GSList *local_24;
  GSList *local_20;
  
  uVar3 = g_hash_table_new(0,0);
  local_24 = (GSList *)0x0;
  local_20 = vertices;
  if (vertices != (GSList *)0x0) {
    do {
      for (puVar1 = *(undefined4 **)((int)local_20->data + 0x24); puVar1 != (undefined4 *)0x0;
          puVar1 = (undefined4 *)puVar1[1]) {
        uVar2 = *puVar1;
        iVar4 = g_hash_table_lookup(uVar3,uVar2);
        if (iVar4 == 0) {
          local_24 = (GSList *)g_slist_prepend(local_24,uVar2);
          g_hash_table_insert(uVar3,uVar2,local_20);
        }
      }
      local_20 = local_20->next;
    } while (local_20 != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar3);
  return local_24;
}



// WARNING: Unknown calling convention

GtsVertex * gts_segment_midvertex(GtsSegment *s,GtsVertexClass *klass)

{
  GtsVertex *pGVar1;
  GtsPoint *p2;
  GtsVertex *pGVar2;
  GtsPoint *p1;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_midvertex","s != NULL");
    return (GtsVertex *)0x0;
  }
  if (klass != (GtsVertexClass *)0x0) {
    pGVar2 = s->v1;
    pGVar1 = s->v2;
    pGVar2 = gts_vertex_new(klass,((pGVar2->p).x + (pGVar1->p).x) * 0.5,
                            ((pGVar2->p).y + (pGVar1->p).y) * 0.5,
                            ((pGVar2->p).z + (pGVar1->p).z) * 0.5);
    return pGVar2;
  }
  g_return_if_fail_warning(0,"gts_segment_midvertex","klass != NULL");
  return (GtsVertex *)0x0;
}



// WARNING: Removing unreachable block (ram,0x081395c6)
// WARNING: Unknown calling convention

GtsIntersect gts_segments_are_intersecting(GtsSegment *s1,GtsSegment *s2)

{
  GtsVertex *p1_00;
  GtsVertex *p2_00;
  GtsVertex *p3_00;
  GtsVertex *p3_01;
  GtsIntersect GVar1;
  GtsPoint *p1;
  GtsPoint *p3;
  GtsPoint *p4;
  GtsPoint *p2;
  gdouble d4;
  gdouble d3;
  gdouble d1;
  gdouble gVar2;
  gdouble gVar3;
  gdouble gVar4;
  gdouble gVar5;
  
  if ((s2 == (GtsSegment *)0x0) || (s1 == (GtsSegment *)0x0)) {
    g_return_if_fail_warning(0,"gts_segments_are_intersecting","s1 != NULL && s2 != NULL");
    GVar1 = GTS_ON;
  }
  else {
    p1_00 = s1->v1;
    p2_00 = s1->v2;
    p3_00 = s2->v1;
    p3_01 = s2->v2;
    gVar2 = gts_point_orientation(&p1_00->p,&p2_00->p,&p3_00->p);
    gVar3 = gts_point_orientation(&p1_00->p,&p2_00->p,&p3_01->p);
    if (((gVar2 <= 0.0) || (gVar3 <= 0.0)) && ((0.0 <= gVar2 || (0.0 <= gVar3)))) {
      gVar4 = gts_point_orientation(&p3_00->p,&p3_01->p,&p1_00->p);
      gVar5 = gts_point_orientation(&p3_00->p,&p3_01->p,&p2_00->p);
      if (((gVar4 <= 0.0) || (gVar5 <= 0.0)) && ((0.0 <= gVar4 || (0.0 <= gVar5)))) {
        if (((gVar2 != 0.0) && (gVar3 != 0.0)) && (gVar4 != 0.0)) {
          return (uint)(gVar5 != 0.0);
        }
        return GTS_ON;
      }
    }
    GVar1 = GTS_OUT;
  }
  return GVar1;
}



// WARNING: Unknown calling convention

GtsSegment * gts_segment_new(GtsSegmentClass *klass,GtsVertex *v1,GtsVertex *v2)

{
  GtsSegment *pGVar1;
  GtsSegment *s;
  GSList *pGVar2;
  
  if (v1 == (GtsVertex *)0x0) {
    pGVar1 = (GtsSegment *)0x0;
    g_return_if_fail_warning(0,"gts_segment_new","v1 != NULL");
  }
  else if (v2 == (GtsVertex *)0x0) {
    pGVar1 = (GtsSegment *)0x0;
    g_return_if_fail_warning(0,"gts_segment_new","v2 != NULL");
  }
  else if (v1 == v2) {
    pGVar1 = (GtsSegment *)0x0;
    g_return_if_fail_warning(0,"gts_segment_new",&DAT_081516ec);
  }
  else {
    pGVar1 = (GtsSegment *)gts_object_new(&klass->parent_class);
    pGVar1->v1 = v1;
    pGVar1->v2 = v2;
    pGVar2 = (GSList *)g_slist_prepend(v1->segments,pGVar1);
    v1->segments = pGVar2;
    pGVar2 = (GSList *)g_slist_prepend(v2->segments,pGVar1);
    v2->segments = pGVar2;
  }
  return pGVar1;
}



// WARNING: Unknown calling convention

GtsSegmentClass * gts_segment_class(void)

{
  uint uVar1;
  GtsObjectClass *parent_class;
  int iVar2;
  GtsObjectClassInfo *pGVar3;
  int in_GS_OFFSET;
  GtsObjectClassInfo segment_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (gts_segment_class::klass == (GtsSegmentClass *)0x0) {
    pGVar3 = &segment_info;
    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)pGVar3->name = 0;
      pGVar3 = (GtsObjectClassInfo *)(pGVar3->name + 4);
    }
    segment_info.name[0] = 'G';
    segment_info.name[1] = 't';
    segment_info.name[2] = 's';
    segment_info.name[3] = 'S';
    segment_info.name[4] = 'e';
    segment_info.name[5] = 'g';
    segment_info.name[6] = 'm';
    segment_info.name[7] = 'e';
    segment_info.name[8] = 'n';
    segment_info.name[9] = 't';
    segment_info.name[10] = '\0';
    segment_info.name[11] = '\0';
    uVar1 = 0;
    do {
      *(undefined4 *)(segment_info.name + uVar1 + 0xc) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < 0x1c);
    segment_info.object_size = 0x14;
    segment_info.class_size = 0x5c;
    segment_info.class_init_func = segment_class_init;
    segment_info.object_init_func = segment_init;
    parent_class = gts_object_class();
    gts_segment_class::klass = (GtsSegmentClass *)gts_object_class_new(parent_class,&segment_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return gts_segment_class::klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void segment_destroy(GtsObject *object)

{
  byte bVar1;
  GtsObject *object_00;
  int iVar2;
  GtsObjectClass *pGVar3;
  GtsSegmentClass *pGVar4;
  GtsVertex *v2;
  GtsVertex *v1;
  
  pGVar3 = object[1].klass;
  object_00 = (GtsObject *)object[1].reserved;
  iVar2 = g_slist_remove(*(undefined4 *)((int)(pGVar3->info).name + 0x24),object);
  bVar1 = pGVar3->info;
  *(int *)((int)(pGVar3->info).name + 0x24) = iVar2;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_vertices == 0)) && (iVar2 == 0)) {
    gts_object_destroy((GtsObject *)pGVar3);
  }
  pGVar3 = (GtsObjectClass *)g_slist_remove(object_00[3].klass,object);
  bVar1 = *(byte *)&object_00->flags;
  object_00[3].klass = pGVar3;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_vertices == 0)) &&
     (pGVar3 == (GtsObjectClass *)0x0)) {
    gts_object_destroy(object_00);
  }
  pGVar4 = gts_segment_class();
                    // WARNING: Could not recover jumptable at 0x0813987a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar4->parent_class).parent_class)->destroy)(object);
  return;
}



// WARNING: Unknown calling convention

void gts_fifo_foreach(GtsFifo *fifo,GtsFunc func,gpointer data)

{
  GList *pGVar1;
  GList *i;
  
  if ((fifo != (GtsFifo *)0x0) && (func != (GtsFunc)0x0)) {
    for (pGVar1 = fifo->tail; pGVar1 != (GList *)0x0; pGVar1 = pGVar1->prev) {
      (*func)(pGVar1->data,data);
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Unknown calling convention

gboolean gts_fifo_is_empty(GtsFifo *fifo)

{
  if (fifo != (GtsFifo *)0x0) {
    return (uint)(fifo->head == (GList *)0x0);
  }
  g_return_if_fail_warning(0,"gts_fifo_is_empty","fifo != NULL");
  return 1;
}



// WARNING: Unknown calling convention

gpointer gts_fifo_top(GtsFifo *fifo)

{
  gpointer pvVar1;
  
  if (fifo != (GtsFifo *)0x0) {
    pvVar1 = (gpointer)0x0;
    if (fifo->tail != (GList *)0x0) {
      pvVar1 = fifo->tail->data;
    }
    return pvVar1;
  }
  g_return_if_fail_warning(0,"gts_fifo_top","fifo != NULL");
  return (gpointer)0x0;
}



// WARNING: Unknown calling convention

void gts_fifo_reverse(GtsFifo *fifo)

{
  GList *pGVar1;
  
  if (fifo != (GtsFifo *)0x0) {
    fifo->tail = fifo->head;
    pGVar1 = (GList *)g_list_reverse(fifo->head);
    fifo->head = pGVar1;
    return;
  }
  g_return_if_fail_warning(0,"gts_fifo_reverse","fifo != NULL");
  return;
}



// WARNING: Unknown calling convention

void gts_fifo_destroy(GtsFifo *fifo)

{
  if (fifo != (GtsFifo *)0x0) {
    g_list_free(fifo->head);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_fifo_destroy","fifo != NULL");
  return;
}



// WARNING: Unknown calling convention

guint gts_fifo_size(GtsFifo *fifo)

{
  guint gVar1;
  
  if (fifo != (GtsFifo *)0x0) {
    gVar1 = g_list_length();
    return gVar1;
  }
  g_return_if_fail_warning(0,"gts_fifo_size","fifo != NULL");
  return 0;
}



// WARNING: Unknown calling convention

gpointer gts_fifo_pop(GtsFifo *fifo)

{
  GList *pGVar1;
  GList *pGVar2;
  gpointer pvVar3;
  gpointer data;
  GList *tail;
  
  if (fifo == (GtsFifo *)0x0) {
    pvVar3 = (gpointer)0x0;
    g_return_if_fail_warning(0,"gts_fifo_pop","fifo != NULL");
  }
  else {
    pGVar2 = fifo->tail;
    pvVar3 = (gpointer)0x0;
    if (pGVar2 != (GList *)0x0) {
      pGVar1 = pGVar2->prev;
      pvVar3 = pGVar2->data;
      pGVar2 = (GList *)g_list_remove_link(fifo->head,pGVar2);
      fifo->head = pGVar2;
      g_list_free_1(fifo->tail);
      fifo->tail = pGVar1;
    }
  }
  return pvVar3;
}



// WARNING: Unknown calling convention

void gts_fifo_push(GtsFifo *fifo,gpointer data)

{
  GList *pGVar1;
  
  if (fifo == (GtsFifo *)0x0) {
    g_return_if_fail_warning(0,"gts_fifo_push","fifo != NULL");
    return;
  }
  pGVar1 = (GList *)g_list_prepend(fifo->head,data);
  fifo->head = pGVar1;
  if (fifo->tail != (GList *)0x0) {
    return;
  }
  fifo->tail = pGVar1;
  return;
}



// WARNING: Unknown calling convention

void gts_fifo_write(GtsFifo *fifo,FILE *fp)

{
  GList *pGVar1;
  GList *i;
  
  if (fifo == (GtsFifo *)0x0) {
    g_return_if_fail_warning(0,"gts_fifo_write","fifo != NULL");
    return;
  }
  if (fp == (FILE *)0x0) {
    g_return_if_fail_warning(0,"gts_fifo_write","fp != NULL");
    return;
  }
  __fprintf_chk(fp,1,&DAT_0814748b);
  for (pGVar1 = fifo->head; pGVar1 != (GList *)0x0; pGVar1 = pGVar1->next) {
    __fprintf_chk(fp,1,&DAT_08161ed8,pGVar1->data);
  }
  __fprintf_chk(fp,1,&DAT_0815389e);
  return;
}



// WARNING: Unknown calling convention

GtsFifo * gts_fifo_new(void)

{
  GtsFifo *pGVar1;
  
  pGVar1 = (GtsFifo *)g_malloc(8);
  pGVar1->tail = (GList *)0x0;
  pGVar1->head = (GList *)0x0;
  return pGVar1;
}



void __libc_csu_fini(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx
// WARNING: Removing unreachable block (ram,0x08139cce)
// WARNING: Removing unreachable block (ram,0x08139cd0)

void __libc_csu_init(void)

{
  EVP_PKEY_CTX *in_stack_ffffffd4;
  
  _init(in_stack_ffffffd4);
  return;
}



// WARNING: This is an inlined function

void __i686_get_pc_thunk_bx(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int atexit(__func *__func)

{
  int iVar1;
  
  iVar1 = __cxa_atexit(__func,0,__dso_handle);
  return iVar1;
}



// WARNING: Removing unreachable block (ram,0x08139d51)
// WARNING: Removing unreachable block (ram,0x08139d58)

void __do_global_ctors_aux(void)

{
  return;
}



void _fini(void)

{
  __do_global_dtors_aux();
  return;
}


