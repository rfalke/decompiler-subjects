// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b12060 = 0x00; // 0000000000012060
byte g_b12067 = 0x00; // 0000000000012067
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw12050 = 0x00012050; // 0000000000012050
word64 j.3281 = 0x01; // 0000000000012058
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 000000000000120C: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_csu_fini_GOT = __libc_csu_fini; // 0000000000011FA0
<anonymous> * g_ptr11FA8 = null; // 0000000000011FA8
word64 g_qw11FB0 = 0x00; // 0000000000011FB0
word64 g_qw11FB8 = 0x00; // 0000000000011FB8
<anonymous> * __libc_csu_init_GOT = __libc_csu_init; // 0000000000011FC0
<anonymous> * main_GOT = main; // 0000000000011FC8
<anonymous> * g_ptr11FD8 = null; // 0000000000011FD8
<anonymous> * g_ptr11FE0 = null; // 0000000000011FE0
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_402 g_t12000 = // 0000000000012000
	{
		0x00,
	};
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000000000007A0: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_weak_fn();
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a11DA0[] = // 0000000000011DA0
	{
	};
// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw11DB0 = 0x00; // 0000000000011DB0
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_a1230[] = // 0000000000001230
	{
	};
byte g_a1248[] = // 0000000000001248
	{
	};
byte g_a1260[] = // 0000000000001260
	{
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000870: void main(Register real64 d9)
void main(real64 d9)
{
main_entry:
	def fp
	def d9
	w20_22 = 0x01
	printf("Start...%c\n\n", '\a')
	x19_38 = (struct Eq_15 *) 0x00011000
	x23_41 = fp + ~0x67
	x22_42 = fp + ~0xCF
	x21_43 = ~0xFB2C7335
	d8_44 = 1e-06
	goto l00000000000008C4
l0000000000000870:
l00000000000008C4:
	x21_318 = PHI((x21_43, l0000000000000870), (x21_200, l00000000000008F8))
	w20_73 = PHI((w20_22, l0000000000000870), (w20_77, l00000000000008F8))
	Mem64 = PHI((Mem33, l0000000000000870), (Mem85, l00000000000008F8))
	x19_63 = PHI((x19_38, l0000000000000870), (x19_100, l00000000000008F8))
	x22_48 = PHI((x22_42, l0000000000000870), (x22_294, l00000000000008F8))
	x23_46 = PHI((x23_41, l0000000000000870), (x23_290, l00000000000008F8))
	w0_50 = stest(x22_48, x23_46)
	x2_65 = x19_63->ptr0FD0
	x2_65->dw0000 = w0_50
	printf("\ncresult = %d\n", w0_50)
	branch w20_73 == 0x06 l0000000000000AA0
l00000000000008F4:
	w20_76 = w20_73 + 0x01
l00000000000008F8:
	x22_294 = PHI((x22_48, l00000000000008F4), (x22_296, l0000000000000A4C), (x22_296, l000000000000091C), (x22_240, l00000000000009C0), (x22_296, l00000000000009E4))
	x23_290 = PHI((x23_46, l00000000000008F4), (x23_292, l0000000000000A4C), (x23_292, l000000000000091C), (x23_241, l00000000000009C0), (x23_292, l00000000000009E4))
	x21_200 = PHI((x21_318, l00000000000008F4), (x21_199, l0000000000000A4C), (x21_199, l000000000000091C), (x21_239, l00000000000009C0), (x21_199, l00000000000009E4))
	x19_100 = PHI((x19_63, l00000000000008F4), (x19_99, l0000000000000A4C), (x19_99, l000000000000091C), (x19_237, l00000000000009C0), (x19_99, l00000000000009E4))
	Mem85 = PHI((Mem69, l00000000000008F4), (Mem178, l0000000000000A4C), (Mem207, l000000000000091C), (Mem275, l00000000000009C0), (Mem287, l00000000000009E4))
	w20_77 = PHI((w20_76, l00000000000008F4), (w20_176, l0000000000000A4C), (w20_196, l000000000000091C), (w20_274, l00000000000009C0), (w20_286, l00000000000009E4))
	w1_78 = w20_77 - 0x02
	branch w1_78 > 0x04 l00000000000008C4
	goto l00000000000008C4
l000000000000091C:
	x7_195 = x19_99->ptr0FD0
	w20_196 = w20_174 + 0x01
	x0_197 = j.3281
	x1_201 = x21_199 + (x0_197 + 0x02) * 8999
	x1_204 = x1_201 + x0_197
	j.3281 = x0_197 + 18000
	x7_195->qw0010 = x1_204
	x0_208 = SEQ(0x00, sq(x1_204))
	x1_215 = x7_195->qw0010
	printf("\nlresult = %ld", (int32) x1_215)
	printf("\n square = %ld\n", (int32) x0_208)
	goto l00000000000008F8
l000000000000097C:
	w6_224 = 0x00
	w5_225 = 0x18
l0000000000000984:
	w6_263 = PHI((w6_224, l000000000000097C), (w6_264, l00000000000009AC))
	w5_226 = PHI((w5_225, l000000000000097C), (w5_261, l00000000000009AC))
	w7_227 = w5_226 - 0x02
	w5_228 = w5_226 & 0x01
	w3_229 = w7_227
	w4_230 = 0x00
l0000000000000994:
	w4_255 = PHI((w4_256, l0000000000000994), (w4_230, l0000000000000984))
	w3_231 = PHI((w3_233, l0000000000000994), (w3_229, l0000000000000984))
	w3_233 = w3_231 - 0x02
	w0_234 = fib(w3_231, out x19_237, out w20_595, out x21_239, out x22_240, out x23_241, out w24_596, out w25_597, out w26_598, out w27_599, out w28_600, out x29_601)
	x20_238 = <invalid>
	w20_273 = (word32) x20_238
	w4_256 = w4_255 + w0_234
	branch w5_228 != w3_233 l0000000000000994
l00000000000009AC:
	w5_261 = w7_227
	w6_264 = w6_263 + (w4_256 + 0x01)
	branch w7_227 != 0x02 l0000000000000984
l00000000000009C0:
	x2_269 = x19_237->ptr0FD0
	w20_274 = w20_273 + 0x01
	x2_269->dw000C = w6_264 + 0x01
	printf("\nuresult = %u\n", w6_264 + 0x01)
	goto l00000000000008F8
l00000000000009E4:
	x2_282 = x19_99->ptr0FD0
	w20_286 = w20_174 + 0x01
	x2_282->dw0004 = 0x7D29
	printf("\niresult = %d\n", 0x7D29)
	goto l00000000000008F8
l0000000000000A08:
	x0_139 = x19_99->ptr0FD0
	x0_140 = x0_139->qw0010
	d0_141 = (real64) x0_140
	d1_144 = d0_141 * d9
	d2_147 = d1_144 * d8_44
	branch d0_141 <= d2_147 l0000000000000A4C
l0000000000000A24:
	d1_151 = PHI((d1_144, l0000000000000A08), (d1_157, l0000000000000A24))
	d2_152 = d0_141 / d1_151
	d3_153 = d2_152 - d1_151
	d1_154 = d1_151 + d2_152
	d1_157 = d1_154 * d9
	d2_158 = -d3_153
	d4_160 = d1_157 * d8_44
	d2_162 = d3_153 < 0.0 ? d2_158 : d3_153
	branch d4_160 < d2_162 l0000000000000A24
l0000000000000A4C:
	d1_165 = PHI((d1_144, l0000000000000A08), (d1_157, l0000000000000A24))
	x24_171 = x19_99->ptr0FD0
	w20_176 = w20_174 + 0x01
	x24_171->r0018 = d1_165
	printf("\ndresult = %f\n", d1_165)
	d0_186 = x24_171->r0018
	d0_187 = dply(d0_186)
	printf("  dmath = %f\n", d0_187)
	goto l00000000000008F8
l0000000000000A80:
	x0_93 = SEQ(0x00, mcopy())
	w0_102 = (word32) x0_93
	x19_101 = x19_99->ptr0FD0
	x19_101->dw0008 = w0_102
	printf("\b   copy = %d", w0_102)
l0000000000000AA0:
	printf("\n\n...End%c", '\a')
	return
main_exit:
}

real64 g_r0AD0 = 1e-06; // 0000000000000AD0
// 0000000000000AD8: void _start(Register (ptr64 Eq_341) x0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* x0)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__libc_start_main(main_GOT, (int32) qwArg00, &ptrArg08, __libc_csu_init_GOT, __libc_csu_fini_GOT, x0, fp);
	abort();
}

// 0000000000000B10: void call_weak_fn()
// Called from:
//      _init
void call_weak_fn()
{
	if (g_qw11FB8 == 0x00)
		return;
	__gmon_start__();
}

// 0000000000000B28: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (&g_b12067 - &g_b12060 <= 0x0E)
		return;
	<anonymous> * x1_13 = g_ptr11FA8;
	if (x1_13 == null)
		return;
	x1_13();
}

// 0000000000000B60: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	byte * x1_7 = &g_b12060 - &g_b12060;
	if ((x1_7 >> 3) + ((x1_7 >> 3) >>u 63) >> 1 == 0x00)
		return;
	<anonymous> * x2_13 = g_ptr11FE0;
	if (x2_13 == null)
		return;
	word64 x2_17;
	x2_13();
}

// 0000000000000BA0: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	struct Eq_402 * x19_11 = &g_t12000;
	if ((word32) g_b12060 == 0x00)
	{
		if (g_qw11FB0 != 0x00)
			__cxa_finalize(&g_t12000, g_qw12050);
		deregister_tm_clones();
		x19_11->b0060 = 0x01;
	}
}

// 0000000000000BE8: void frame_dummy(Register word64 x29, Register word64 x30)
void frame_dummy(word64 x29, word64 x30)
{
	ptr64 fp;
	if (g_qw11DB0 != 0x00)
	{
		<anonymous> * x1_8 = g_ptr11FD8;
		if (x1_8 != null)
		{
			x1_8();
			register_tm_clones();
			return;
		}
	}
	register_tm_clones();
}

// 0000000000000C20: Register ui32 sq(Register word64 x0)
// Called from:
//      main
ui32 sq(word64 x0)
{
	if (x0 != 0x00)
	{
		word64 x3_10 = j.3281;
		j.3281 = x3_10 + ~0x464F;
		return (0x04 - (word32) x3_10) * 8999 + 80973002 + ((word32) x0 - ((word32) x3_10 - 0x02));
	}
	else
	{
		word64 x1_24 = j.3281;
		j.3281 = x1_24 + 18000;
		return ((word32) x1_24 + 0x02) * 8999 + 80973002 + (word32) x1_24;
	}
}

// 0000000000000C98: void sroot(Register real64 d0, Register real64 d1)
void sroot(real64 d0, real64 d1)
{
	real64 d5_4 = 1e-06;
	real64 d1_13 = d0 * d1;
	if (d0 > d1_13 * d5_4)
	{
		do
		{
			real64 d2_14 = d0 / d1_13;
			real64 d3_15 = d2_14 - d1_13;
			d1_13 = (d2_14 + d1_13) * d1;
		} while (d1_13 * d5_4 < (d3_15 < 0.0 ? -d3_15 : d3_15));
	}
}

real64 g_r0CE8 = 1e-06; // 0000000000000CE8
// 0000000000000CF0: void abs(Register real64 d0)
void abs(real64 d0)
{
	if (d0 < 0.0)
		;
}

// 0000000000000D08: Register real64 dply(Register real64 d0)
// Called from:
//      main
real64 dply(real64 d0)
{
	return d0 * d0 * d0 * d0 * d0 * d0 * d0 / d0 / d0 / d0 / d0 / d0 / d0 + d0 + d0 + d0 + d0 + d0 + d0 - d0 - d0 - d0 - d0 - d0 - d0;
}

// 0000000000000D70: Register int32 fib(Register int32 w0, Register out Eq_269 x19Out, Register out Eq_269 w20Out, Register out Eq_269 x21Out, Register out Eq_269 x22Out, Register out Eq_269 x23Out, Register out Eq_269 w24Out, Register out Eq_269 w25Out, Register out Eq_269 w26Out, Register out Eq_269 w27Out, Register out Eq_269 w28Out, Register out Eq_269 x29Out)
// Called from:
//      main
//      fib
int32 fib(int32 w0, union Eq_269 & x19Out, union Eq_269 & w20Out, union Eq_269 & x21Out, union Eq_269 & x22Out, union Eq_269 & x23Out, union Eq_269 & w24Out, union Eq_269 & w25Out, union Eq_269 & w26Out, union Eq_269 & w27Out, union Eq_269 & w28Out, union Eq_269 & x29Out)
{
	ptr64 fp;
	word64 x25;
	word64 x21;
	word64 x22;
	word64 x23;
	word64 x24;
	word64 x27;
	word32 x25_32_32_371 = SLICE(x25, word32, 32);
	word32 x21_32_32_420 = SLICE(x21, word32, 32);
	word32 x22_32_32_440 = SLICE(x22, word32, 32);
	word32 x23_32_32_459 = SLICE(x23, word32, 32);
	word32 x24_32_32_479 = SLICE(x24, word32, 32);
	word32 x27_32_32_499 = SLICE(x27, word32, 32);
	if (w0 <= 0x02)
	{
		x19Out.u0 = <invalid>;
		w20Out.u0 = <invalid>;
		x21Out.u0 = <invalid>;
		x22Out.u0 = <invalid>;
		x23Out.u0 = <invalid>;
		w24Out.u0 = <invalid>;
		w25Out.u0 = <invalid>;
		w26Out.u0 = <invalid>;
		w27Out.u0 = <invalid>;
		w28Out.u0 = <invalid>;
		x29Out.u0 = <invalid>;
		return 0x01;
	}
	else
	{
		struct Eq_547 * x29_12 = fp + -0x00A0;
		word64 x25_852 = SEQ(x25_32_32_371, w0 - 0x01);
		do
		{
			word32 w0_264;
			int32 w25_269 = (word32) x25_852;
			word32 x25_32_32_370 = SLICE(x25_852, word32, 32);
			int32 w1_258 = w25_269;
			if (w25_269 != 0x02)
			{
				x29_12[74] = (struct Eq_547) 0x00;
				word64 x25_138 = x25_852;
				do
				{
					word32 w0_254;
					if (w1_258 != 0x03)
					{
						x29_12[56] = (struct Eq_547) (w1_258 & 0x01);
						ui32 w0_57 = w1_258 - 0x02;
						struct Eq_576 * v27_60 = x29_12 + 64;
						v27_60->dw0000 = w0_57;
						v27_60->dw0004 = w0_57;
						x29_12[78] = (struct Eq_547) 0x00;
						do
						{
							word32 w0_240;
							int32 w0_236 = x29_12[66];
							if (w0_236 != 0x02)
							{
								x29_12[72] = (struct Eq_547) 0x00;
								do
								{
									word32 w0_229;
									if (w0_236 != 0x03)
									{
										struct Eq_601 * v29_80 = x29_12 + 58;
										v29_80->dw0000 = w0_236 & 0x01;
										ui32 w1_77 = w0_236 - 0x02;
										v29_80->dw0004 = w1_77;
										x29_12[70] = (struct Eq_547) 0x00;
										word64 x27_836 = SEQ(x27_32_32_499, w1_77);
										do
										{
											word32 w0_208;
											int32 w27_213 = (word32) x27_836;
											x27_32_32_499 = SLICE(x27_836, word32, 32);
											int32 w24_202 = w27_213;
											if (w27_213 != 0x02)
											{
												x29_12[0x0044] = (struct Eq_547) 0x00;
												word64 x27_146 = x27_836;
												do
												{
													word32 w23_188;
													if (w24_202 != 0x03)
													{
														word32 w0_97 = w24_202 - 0x02;
														x29_12[62] = (struct Eq_547) w0_97;
														word64 x22_807 = SEQ(x22_32_32_440, w0_97);
														word64 x23_811 = SEQ(x23_32_32_459, 0x00);
														word64 x24_145 = SEQ(x24_32_32_479, w24_202 & 0x01);
														do
														{
															word32 w21_106;
															int32 w22_102 = (word32) x22_807;
															x23_32_32_459 = SLICE(x23_811, word32, 32);
															x22_32_32_440 = SLICE(x22_807, word32, 32);
															word32 w23_174 = (word32) x23_811;
															int32 w19_104 = w22_102;
															if (w22_102 != 0x02)
															{
																word64 x21_788 = SEQ(x21_32_32_420, 0x00);
																word64 x22_143 = x22_807;
																word64 x23_144 = x23_811;
																do
																{
																	word32 w2_111;
																	int32 w20_112;
																	x21_32_32_420 = SLICE(x21_788, word32, 32);
																	word32 w21_162 = (word32) x21_788;
																	if (w19_104 != 0x03)
																	{
																		int32 w26_115 = w19_104 - 0x02;
																		do
																		{
																			word64 x26_139 = <invalid>;
																			word64 x20_141 = <invalid>;
																			word64 x28_147 = <invalid>;
																			x27_146 = <invalid>;
																			x24_145 = <invalid>;
																			x25_138 = <invalid>;
																			w26_115 = (word32) x26_139;
																			w20_112 = (word32) x20_141;
																			w21_162 = (word32) x21_142;
																			x21_32_32_420 = SLICE(x21_142, word32, 32);
																			word64 x19_140;
																			word64 x21_142;
																			word32 w25_869;
																			word32 w27_871;
																			word32 w28_872;
																			word32 w26_870;
																			word32 w24_868;
																			word32 w20_867;
																			word32 w28_152 = (word32) x28_147 + fib(w26_115, out x19_140, out w20_867, out x21_142, out x22_143, out x23_144, out w24_868, out w25_869, out w26_870, out w27_871, out w28_872, out x29_12);
																		} while (w26_115 != (word32) x19_140);
																		w2_111 = w28_152 + 0x01;
																	}
																	else
																	{
																		w2_111 = 0x01;
																		w20_112 = 0x01;
																	}
																	word32 w21_166 = w21_162 + w2_111;
																	x23_32_32_459 = SLICE(x23_144, word32, 32);
																	x22_32_32_440 = SLICE(x22_143, word32, 32);
																	w23_174 = (word32) x23_144;
																	w22_102 = (word32) x22_143;
																	w19_104 = w20_112;
																	x21_788 = SEQ(x21_32_32_420, w21_166);
																} while (w20_112 > 0x02);
																w21_106 = w21_166 + 0x01;
															}
															else
																w21_106 = 0x01;
															word32 w22_173 = w22_102 - 0x02;
															word32 w23_180 = w23_174 + w21_106;
															x24_32_32_479 = SLICE(x24_145, word32, 32);
															x22_807 = SEQ(x22_32_32_440, w22_173);
															x23_811 = SEQ(x23_32_32_459, w23_180);
														} while ((word32) x24_145 != w22_173);
														w23_188 = w23_180 + 0x01;
													}
													else
													{
														x29_12[62] = (struct Eq_547) 0x01;
														w23_188 = 0x01;
													}
													int32 w0_200 = x29_12[62];
													word32 w0_205 = (word16) x29_12[0x0044] + w23_188;
													x29_12[0x0044] = (struct Eq_547) w0_205;
													x27_32_32_499 = SLICE(x27_146, word32, 32);
													w27_213 = (word32) x27_146;
													w24_202 = w0_200;
												} while (w0_200 > 0x02);
												w0_208 = w0_205 + 0x01;
											}
											else
												w0_208 = 0x01;
											x29_12[70] = (struct Eq_547) ((word16) x29_12[70] + w0_208);
											word32 w27_221 = w27_213 - 0x02;
											x27_836 = SEQ(x27_32_32_499, w27_221);
										} while (x29_12[58] != w27_221);
										w0_229 = (word32) ((word16) x29_12[70] + 1);
									}
									else
									{
										x29_12[60] = (struct Eq_547) 0x01;
										w0_229 = 0x01;
									}
									x29_12[72] = (struct Eq_547) ((word16) x29_12[72] + w0_229);
									w0_236 = (int32) x29_12[60];
								} while (w0_236 > 0x02);
								w0_240 = (word32) ((word16) x29_12[72] + 1);
							}
							else
								w0_240 = 0x01;
							word32 w1_244 = x29_12[66];
							x29_12[78] = (struct Eq_547) ((word16) x29_12[78] + w0_240);
							word32 w0_249 = x29_12[56];
							x29_12[66] = (struct Eq_547) (w1_244 - 0x02);
						} while (w0_249 != w1_244 - 0x02);
						w0_254 = (word32) ((word16) x29_12[78] + 1);
					}
					else
					{
						x29_12[64] = (struct Eq_547) 0x01;
						w0_254 = 0x01;
					}
					w1_258 = (int32) x29_12[64];
					word32 w0_260 = (word16) x29_12[74] + w0_254;
					x29_12[74] = (struct Eq_547) w0_260;
					x25_32_32_370 = SLICE(x25_138, word32, 32);
					w25_269 = (word32) x25_138;
				} while (w1_258 > 0x02);
				w0_264 = w0_260 + 0x01;
			}
			else
				w0_264 = 0x01;
			x29_12[76] = (struct Eq_547) ((word16) x29_12[76] + w0_264);
			word32 w25_285 = w25_269 - 0x02;
			x25_852 = SEQ(x25_32_32_370, w25_285);
		} while (x29_12[54] != w25_285);
		int32 w0_312 = (word16) x29_12[76] + 1;
		x19Out.u0 = <invalid>;
		w20Out.u0 = <invalid>;
		x21Out.u0 = <invalid>;
		x22Out.u0 = <invalid>;
		x23Out.u0 = <invalid>;
		w24Out.u0 = <invalid>;
		w25Out.u0 = <invalid>;
		w26Out.u0 = <invalid>;
		w27Out.u0 = <invalid>;
		w28Out.u0 = <invalid>;
		x29Out.u0 = <invalid>;
		return w0_312;
	}
}

// 0000000000000FE0: Register word32 stest(Register (ptr64 byte) x0, Register (arr byte) x1)
// Called from:
//      main
word32 stest(byte * x0, byte x1[])
{
	word32 w7_54;
	word32 w8_63 = 0x00;
	for (w7_54 = 9000; w7_54 != 0x00; --w7_54)
	{
		struct Eq_885 * x2_10 = null;
		do
		{
			word32 w3_14 = (word32) x2_10[4656];
			Mem16[x0 + x2_10:byte] = SLICE(w3_14, byte, 0);
			++x2_10;
		} while (w3_14 != 0x00);
		struct Eq_897 * x2_18 = null;
		do
		{
			word32 w3_23 = (word32) x2_18[4680];
			Mem25[x1 + x2_18:byte] = SLICE(w3_23, byte, 0);
			++x2_18;
		} while (w3_23 != 0x00);
		word32 w3_46;
		word32 w3_29 = (word32) *x0;
		word32 w4_31 = (word32) x1[0];
		if (w3_29 == w4_31)
		{
			if (w3_29 != 0x00)
			{
				int64 x2_34 = 0x01;
				do
				{
					w3_29 = (word32) x0[x2_34];
					w4_31 = (word32) x1[x2_34];
					++x2_34;
					if (w3_29 != w4_31)
						goto l0000000000001058;
				} while (w3_29 != 0x00);
			}
			w3_46 = 0x00;
		}
		else
		{
l0000000000001058:
			w3_46 = w3_29 - w4_31;
		}
		w8_63 += w3_46;
	}
	return w8_63;
}

// 0000000000001078: void mstrcmp(Register (ptr64 byte) x0, Register (arr byte) x1)
void mstrcmp(byte * x0, byte x1[])
{
	word32 w4_9 = (word32) x1[0];
	if (w4_9 != (word32) (*x0))
		return;
	if (w4_9 != 0x00)
	{
		int64 x2_12 = 0x01;
		do
		{
			word32 w3_17 = (word32) x0[x2_12];
			++x2_12;
			if (w3_17 != (word32) x1[x2_12])
				return;
		} while (w3_17 != 0x00);
	}
}

// 00000000000010C0: void mstrcpy(Register (arr byte) x0, Register ptr64 x1)
void mstrcpy(byte x0[], ptr64 x1)
{
	int64 x2_11 = 0x00;
	do
	{
		word32 w3_8 = (word32) *((word64) x1 + x2_11);
		x0[x2_11] = (byte) w3_8;
		++x2_11;
	} while (w3_8 != 0x00);
}

// 00000000000010D8: Register word32 mcopy()
// Called from:
//      main
word32 mcopy()
{
	byte * fp;
	byte bLoc68;
	struct Eq_992 * x0_10 = null;
	do
	{
		word32 w2_29 = (word32) x0_10[4704];
		Mem31[fp + ~0x67 + x0_10:byte] = SLICE(w2_29, byte, 0);
		++x0_10;
	} while (w2_29 != 0x00);
	union Eq_1008 * x0_37 = fopen("zyxw.vut", "w");
	word32 x0_32_32_90 = SLICE(x0_37, word32, 32);
	if (x0_37 == null)
	{
		printf("Cannot open file");
		exit(~0x00);
	}
	else
	{
		word32 w22_47 = (word32) bLoc68;
		word32 w21_48 = 999;
		if (w22_47 != 0x00)
		{
			do
			{
				word32 x0_32_32_92;
				word64 x19_50 = fp + ~0x66;
				word64 x0_55 = SEQ(x0_32_32_90, w22_47);
				do
				{
					x0_94 = SEQ(x0_32_32_92, w0_60);
					x0_32_32_92 = SLICE((uint64) _IO_putc((int32) x0_55, x0_37), word32, 32);
					word32 w0_60 = (word32) *x19_50;
					++x19_50;
					x0_55 = x0_94;
				} while (w0_60 != 0x00);
				--w21_48;
				x0_32_32_90 = x0_32_32_92;
			} while (w21_48 != 0x00);
		}
		return 1000;
	}
}

// 0000000000001188: void intest()
void intest()
{
}

// 0000000000001190: void __libc_csu_init(Register word32 w0, Register word64 x1, Register word64 x2, Register word64 x24, Register word64 x30)
void __libc_csu_init(word32 w0, word64 x1, word64 x2, word64 x24, word64 x30)
{
	ptr64 fp;
	word32 x24_32_32_89 = SLICE(x24, word32, 32);
	_init();
	int64 x20_23 = 0x00011DA8 - g_a11DA0;
	ptr64 x29_49 = fp + -64;
	<anonymous> * x21_21[] = g_a11DA0;
	word64 x22_30 = x2;
	word64 x23_34 = x1;
	int64 x20_36 = x20_23 >> 3;
	if (x20_23 >> 3 != 0x00)
	{
		int64 x19_37 = 0x00;
		word64 x24_133 = SEQ(x24_32_32_89, w0);
		do
		{
			word64 x3_67;
			x21_21[x19_37]();
			int64 x31_70 = x20_36 - x19_37;
		} while (x31_70 != 0x00);
	}
}

// 0000000000001208: void __libc_csu_fini()
void __libc_csu_fini()
{
}

