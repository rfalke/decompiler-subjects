// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b12060 = 0x00; // 0000000000012060
byte g_b12067 = 0x00; // 0000000000012067
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw12050 = 0x00012050; // 0000000000012050
word64 j.3281 = 0x01; // 0000000000012058
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000FFC: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_csu_fini_GOT = __libc_csu_fini; // 0000000000011FA0
<anonymous> * g_ptr11FA8 = null; // 0000000000011FA8
word64 g_qw11FB0 = 0x00; // 0000000000011FB0
word64 g_qw11FB8 = 0x00; // 0000000000011FB8
<anonymous> * __libc_csu_init_GOT = __libc_csu_init; // 0000000000011FC0
<anonymous> * main_GOT = main; // 0000000000011FC8
<anonymous> * g_ptr11FD8 = null; // 0000000000011FD8
<anonymous> * g_ptr11FE0 = null; // 0000000000011FE0
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_342 g_t12000 = // 0000000000012000
	{
		0x00,
	};
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000000000007A0: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_weak_fn();
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a11DA0[] = // 0000000000011DA0
	{
	};
// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw11DB0 = 0x00; // 0000000000011DB0
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_a1020[] = // 0000000000001020
	{
	};
byte g_a1038[] = // 0000000000001038
	{
	};
byte g_a1050[] = // 0000000000001050
	{
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000870: void main(Register real64 d9)
void main(real64 d9)
{
main_entry:
	def d9
	def tLocD0
	def qwLoc68
	w20_22 = 0x01
	printf("Start...%c\n\n", '\a')
	x19_38 = (struct Eq_15 *) 0x00011000
	d8_44 = 1e-06
	goto l00000000000008C4
l0000000000000870:
l00000000000008C4:
	w20_73 = PHI((w20_22, l0000000000000870), (w20_77, l00000000000008F8))
	Mem64 = PHI((Mem33, l0000000000000870), (Mem85, l00000000000008F8))
	x19_63 = PHI((x19_38, l0000000000000870), (x19_100, l00000000000008F8))
	w0_50 = stest(&tLocD0, &qwLoc68)
	x2_65 = x19_63->ptr0FD0
	x2_65->dw0000 = w0_50
	printf("\ncresult = %d\n", w0_50)
	branch w20_73 == 0x06 l0000000000000AA0
l00000000000008F4:
	w20_76 = w20_73 + 0x01
l00000000000008F8:
	x19_100 = PHI((x19_63, l00000000000008F4), (x19_99, l0000000000000920), (x19_234, l00000000000009A0), (x19_99, l0000000000000A4C), (x19_99, l00000000000009C8))
	Mem85 = PHI((Mem69, l00000000000008F4), (Mem211, l0000000000000920), (Mem254, l00000000000009A0), (Mem182, l0000000000000A4C), (Mem265, l00000000000009C8))
	w20_77 = PHI((w20_76, l00000000000008F4), (w20_200, l0000000000000920), (w20_253, l00000000000009A0), (w20_180, l0000000000000A4C), (w20_264, l00000000000009C8))
	w1_78 = w20_77 - 0x02
	branch w1_78 > 0x04 l00000000000008C4
	goto l00000000000008C4
l0000000000000920:
	x7_199 = x19_99->ptr0FD0
	w20_200 = w20_178 + 0x01
	x0_201 = j.3281
	x1_205 = (x0_201 + 0x02) * 8999 + ~0xFB2C7335
	x1_208 = x1_205 + x0_201
	j.3281 = x0_201 + 18000
	x7_199->qw0010 = x1_208
	x0_212 = SEQ(0x00, sq(x1_208))
	x1_219 = x7_199->qw0010
	printf("\nlresult = %ld", (int32) x1_219)
	printf("\n square = %ld\n", (int32) x0_212)
	goto l00000000000008F8
l0000000000000980:
	w2_228 = 0x17
	w1_229 = 0x00
l0000000000000988:
	w1_243 = PHI((w1_229, l0000000000000980), (w1_244, l0000000000000988))
	w2_230 = PHI((w2_228, l0000000000000980), (w2_232, l0000000000000988))
	w2_232 = w2_230 - 0x02
	w0_233 = fib(w2_230, out x19_234, out w20_514)
	x20_235 = <invalid>
	w20_252 = (word32) x20_235
	w1_244 = w1_243 + w0_233
	branch w2_232 != 0x01 l0000000000000988
l00000000000009A0:
	x3_248 = x19_234->ptr0FD0
	w20_253 = w20_252 + 0x01
	x3_248->dw000C = w1_244 + 0x01
	printf("\nuresult = %u\n", w1_244 + 0x01)
	goto l00000000000008F8
l00000000000009C8:
	x2_260 = x19_99->ptr0FD0
	w20_264 = w20_178 + 0x01
	x2_260->dw0004 = 0x7D29
	printf("\niresult = %d\n", 0x7D29)
	goto l00000000000008F8
l00000000000009F0:
	x0_139 = x19_99->ptr0FD0
	x0_140 = x0_139->qw0010
	d0_141 = (real64) x0_140
	d1_144 = d0_141 * d9
	d2_147 = d1_144 * d8_44
	branch d0_141 > d2_147 l0000000000000A24
	goto l0000000000000A4C
l0000000000000A10:
	d1_156 = d1_151 + d3_152
	d1_158 = d1_156 * d9
	d3_160 = d1_158 * d8_44
	branch d3_160 >= d2_153 l0000000000000A4C
l0000000000000A24:
	d1_151 = PHI((d1_144, l00000000000009F0), (d1_165, l0000000000000A34), (d1_158, l0000000000000A10))
	d3_152 = d0_141 / d1_151
	d2_153 = d3_152 - d1_151
	branch d2_153 >= 0.0 l0000000000000A10
l0000000000000A34:
	d1_163 = d1_151 + d3_152
	d2_164 = -d2_153
	d1_165 = d1_163 * d9
	d3_166 = d1_165 * d8_44
	branch d3_166 < d2_164 l0000000000000A24
l0000000000000A4C:
	d1_169 = PHI((d1_144, l0000000000000A0C), (d1_165, l0000000000000A34), (d1_158, l0000000000000A10))
	x24_175 = x19_99->ptr0FD0
	w20_180 = w20_178 + 0x01
	x24_175->r0018 = d1_169
	printf("\ndresult = %f\n", d1_169)
	d0_190 = x24_175->r0018
	d0_191 = dply(d0_190)
	printf("  dmath = %f\n", d0_191)
	goto l00000000000008F8
l0000000000000A80:
	x0_93 = SEQ(0x00, mcopy())
	w0_102 = (word32) x0_93
	x19_101 = x19_99->ptr0FD0
	x19_101->dw0008 = w0_102
	printf("\b   copy = %d", w0_102)
l0000000000000AA0:
	printf("\n\n...End%c", '\a')
	return
main_exit:
}

real64 g_r0AD0 = 1e-06; // 0000000000000AD0
// 0000000000000AD8: void _start(Register (ptr64 Eq_281) x0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* x0)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__libc_start_main(main_GOT, (int32) qwArg00, &ptrArg08, __libc_csu_init_GOT, __libc_csu_fini_GOT, x0, fp);
	abort();
}

// 0000000000000B10: void call_weak_fn()
// Called from:
//      _init
void call_weak_fn()
{
	if (g_qw11FB8 == 0x00)
		return;
	__gmon_start__();
}

// 0000000000000B28: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (&g_b12067 - &g_b12060 <= 0x0E)
		return;
	<anonymous> * x1_13 = g_ptr11FA8;
	if (x1_13 == null)
		return;
	x1_13();
}

// 0000000000000B60: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	byte * x1_7 = &g_b12060 - &g_b12060;
	if ((x1_7 >> 3) + ((x1_7 >> 3) >>u 63) >> 1 == 0x00)
		return;
	<anonymous> * x2_13 = g_ptr11FE0;
	if (x2_13 == null)
		return;
	word64 x2_17;
	x2_13();
}

// 0000000000000BA0: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	struct Eq_342 * x19_11 = &g_t12000;
	if ((word32) g_b12060 == 0x00)
	{
		if (g_qw11FB0 != 0x00)
			__cxa_finalize(&g_t12000, g_qw12050);
		deregister_tm_clones();
		x19_11->b0060 = 0x01;
	}
}

// 0000000000000BE8: void frame_dummy(Register word64 x29, Register word64 x30)
void frame_dummy(word64 x29, word64 x30)
{
	ptr64 fp;
	if (g_qw11DB0 != 0x00)
	{
		<anonymous> * x1_8 = g_ptr11FD8;
		if (x1_8 != null)
		{
			x1_8();
			register_tm_clones();
			return;
		}
	}
	register_tm_clones();
}

// 0000000000000C20: Register ui32 sq(Register ui64 x0)
// Called from:
//      main
ui32 sq(ui64 x0)
{
	if (x0 != 0x00)
	{
		word64 x3_10 = j.3281;
		j.3281 = x3_10 + ~0x464F;
		return (0x04 - (word32) x3_10) * 8999 + 80973002 + ((word32) x0 - ((word32) x3_10 - 0x02));
	}
	else
	{
		word64 x1_24 = j.3281;
		j.3281 = x1_24 + 18000;
		return ((word32) x1_24 + 0x02) * 8999 + 80973002 + (word32) x1_24;
	}
}

// 0000000000000C98: void sroot(Register real64 d0, Register real64 d1)
void sroot(real64 d0, real64 d1)
{
	real64 d4_6 = 1e-06;
	real64 d0_14 = d0 * d1;
	if (d0 > d0_14 * d4_6)
	{
		do
		{
			real64 d1_15 = d0 / d0_14;
			d0_14 = (d1_15 + d0_14) * d1;
			real64 d1_17 = d1_15 - d0_14;
			real64 d2_22 = d0_14 * d4_6;
			if (d1_17 < 0.0)
			{
				if (d2_22 >= -d1_17)
					return;
				continue;
			}
		} while (d2_22 < d1_17);
	}
}

real64 g_r0CF8 = 1e-06; // 0000000000000CF8
// 0000000000000D00: void abs(Register real64 d0)
void abs(real64 d0)
{
	if (d0 < 0.0)
		;
}

// 0000000000000D18: Register real64 dply(Register real64 d0)
// Called from:
//      main
real64 dply(real64 d0)
{
	return d0 * d0 * d0 * d0 * d0 * d0 * d0 / d0 / d0 / d0 / d0 / d0 / d0 + d0 + d0 + d0 + d0 + d0 + d0 - d0 - d0 - d0 - d0 - d0 - d0;
}

// 0000000000000D80: Register int32 fib(Register int32 w0, Register out Eq_236 x19Out, Register out Eq_236 w20Out)
// Called from:
//      main
//      fib
int32 fib(int32 w0, union Eq_236 & x19Out, union Eq_236 & w20Out)
{
	if (w0 <= 0x02)
	{
		x19Out.u0 = <invalid>;
		w20Out.u0 = <invalid>;
		return 0x01;
	}
	else
	{
		int32 w19_18 = w0;
		do
		{
			word64 x20_34 = <invalid>;
			w19_18 = (word32) x19_33;
			word64 x19_33;
			word32 w20_86;
			word32 w20_37 = (word32) x20_34 + fib(w19_18 - 0x01, out x19_33, out w20_86);
		} while (w19_18 > 0x02);
		x19Out.u0 = <invalid>;
		w20Out.u0 = <invalid>;
		return w20_37 + 0x01;
	}
}

// 0000000000000DD0: Register word32 stest(Register (ptr64 byte) x0, Register (arr word64) x1)
// Called from:
//      main
word32 stest(byte * x0, word64 x1[])
{
	word32 w7_54;
	word32 w8_63 = 0x00;
	for (w7_54 = 9000; w7_54 != 0x00; --w7_54)
	{
		struct Eq_493 * x2_10 = null;
		do
		{
			word32 w3_14 = (word32) x2_10[0x00001020];
			Mem16[x0 + x2_10:byte] = SLICE(w3_14, byte, 0);
			++x2_10;
		} while (w3_14 != 0x00);
		struct Eq_505 * x2_18 = null;
		do
		{
			word32 w3_23 = (word32) x2_18[4152];
			Mem25[x1 + x2_18:byte] = SLICE(w3_23, byte, 0);
			++x2_18;
		} while (w3_23 != 0x00);
		word32 w3_46;
		word32 w3_29 = (word32) *x0;
		word32 w4_31 = (word32) x1[0];
		if (w3_29 == w4_31)
		{
			if (w3_29 != 0x00)
			{
				int64 x2_34 = 0x01;
				do
				{
					w3_29 = (word32) x0[x2_34];
					w4_31 = (word32) x1[x2_34 /64 8];
					++x2_34;
					if (w3_29 != w4_31)
						goto l0000000000000E48;
				} while (w3_29 != 0x00);
			}
			w3_46 = 0x00;
		}
		else
		{
l0000000000000E48:
			w3_46 = w3_29 - w4_31;
		}
		w8_63 += w3_46;
	}
	return w8_63;
}

// 0000000000000E68: void mstrcmp(Register (ptr64 byte) x0, Register (arr byte) x1)
void mstrcmp(byte * x0, byte x1[])
{
	word32 w4_9 = (word32) x1[0];
	if (w4_9 != (word32) (*x0))
		return;
	if (w4_9 != 0x00)
	{
		int64 x2_12 = 0x01;
		do
		{
			word32 w3_17 = (word32) x0[x2_12];
			++x2_12;
			if (w3_17 != (word32) x1[x2_12])
				return;
		} while (w3_17 != 0x00);
	}
}

// 0000000000000EB0: void mstrcpy(Register (arr byte) x0, Register ptr64 x1)
void mstrcpy(byte x0[], ptr64 x1)
{
	int64 x2_11 = 0x00;
	do
	{
		word32 w3_8 = (word32) *((word64) x1 + x2_11);
		x0[x2_11] = (byte) w3_8;
		++x2_11;
	} while (w3_8 != 0x00);
}

// 0000000000000EC8: Register word32 mcopy()
// Called from:
//      main
word32 mcopy()
{
	byte * fp;
	byte bLoc68;
	struct Eq_600 * x0_10 = null;
	do
	{
		word32 w2_29 = (word32) x0_10[0x00001050];
		Mem31[fp + ~0x67 + x0_10:byte] = SLICE(w2_29, byte, 0);
		++x0_10;
	} while (w2_29 != 0x00);
	union Eq_616 * x0_37 = fopen("zyxw.vut", "w");
	word32 x0_32_32_96 = SLICE(x0_37, word32, 32);
	if (x0_37 == null)
	{
		printf("Cannot open file");
		exit(~0x00);
	}
	else
	{
		word32 w22_47 = (word32) bLoc68;
		word32 w21_48;
		for (w21_48 = 999; w21_48 != 0x00; --w21_48)
		{
			word32 x0_32_32_94;
			word64 x19_50 = fp + ~0x66;
			word64 x0_55 = SEQ(x0_32_32_96, w22_47);
			if (w22_47 != 0x00)
			{
				do
				{
					x0_95 = SEQ(x0_32_32_94, w0_60);
					x0_32_32_94 = SLICE((uint64) _IO_putc((int32) x0_55, x0_37), word32, 32);
					word32 w0_60 = (word32) *x19_50;
					++x19_50;
					x0_55 = x0_95;
					x0_32_32_96 = x0_32_32_94;
				} while (w0_60 != 0x00);
			}
		}
		return 1000;
	}
}

// 0000000000000F78: void intest()
void intest()
{
}

// 0000000000000F80: void __libc_csu_init(Register word32 w0, Register word64 x1, Register word64 x2, Register word64 x24, Register word64 x30)
void __libc_csu_init(word32 w0, word64 x1, word64 x2, word64 x24, word64 x30)
{
	ptr64 fp;
	word32 x24_32_32_89 = SLICE(x24, word32, 32);
	_init();
	int64 x20_23 = 0x00011DA8 - g_a11DA0;
	ptr64 x29_49 = fp + -64;
	<anonymous> * x21_21[] = g_a11DA0;
	word64 x22_30 = x2;
	word64 x23_34 = x1;
	int64 x20_36 = x20_23 >> 3;
	if (x20_23 >> 3 != 0x00)
	{
		int64 x19_37 = 0x00;
		word64 x24_133 = SEQ(x24_32_32_89, w0);
		do
		{
			word64 x3_67;
			x21_21[x19_37]();
			int64 x31_70 = x20_36 - x19_37;
		} while (x31_70 != 0x00);
	}
}

// 0000000000000FF8: void __libc_csu_fini()
void __libc_csu_fini()
{
}

