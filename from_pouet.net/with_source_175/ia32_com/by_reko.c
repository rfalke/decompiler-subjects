// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100(Register byte ch, Register byte bh)
void fn0C00_0100(byte ch, byte bh)
{
	__syscall<byte>(0x10);
	__out<byte>(0x03C8, 0x00);
	uint8 dl_146 = 0xC9;
	ui8 dh_151 = 0x03;
	word16 cx_193 = SEQ(ch, ~0x00);
	do
	{
		byte cl_13 = (byte) cx_196;
		uint8 al_14 = ~0x00 - cl_13;
		if (al_14 >= 0x40)
			al_14 = 0x3F;
		__out<byte>(969, al_14);
		bcu8 al_23 = ~0x00 - cl_13;
		uint8 al_24 = al_23 >> 0x01;
		if (al_23 >> 0x01 >= 0x40)
			al_24 = 0x3F;
		__out<byte>(969, al_24);
		__out<byte>(969, 0x00);
		byte cl_134 = cl_13 - 0x01;
		cx_193 = SEQ(SLICE(cx_196 - 0x01, byte, 8), cl_13 - 0x01);
		cx_196 = cx_193;
	} while (cx_196 != 0x01);
	do
	{
		word16 Eq_79::* di_50 = &Eq_79::wF780;
		word16 cx_158 = SEQ(0x02, cl_134);
		do
		{
			dl_146 = __ror<byte,byte>(dl_146 ^ dh_151, 0x01);
			dh_151 = dh_151 + 0x2A ^ dl_146;
			0x8000->*di_50 = SEQ(dh_151, dl_146);
			++di_50;
			--cx_158;
		} while (cx_158 != 0x00);
		word16 cx_103 = ~cx_158;
		struct Eq_92 Eq_79::* di_101 = &Eq_79::t0000;
		do
		{
			byte al_90 = (byte) ((word16) (0x8000->*di_101).b0000 + SEQ(bh, di_101[319]) + SEQ(bh, di_101[640]) + SEQ(bh, di_101[0x0141]) >> 0x02);
			byte al_91 = al_90 - 0x01;
			if (al_90 == 0x01)
				al_91 = al_90;
			(0x8000->*di_101).b0000 = al_91;
			++di_101;
			--cx_103;
		} while (cx_103 != 0x00);
		struct Eq_92 Eq_79::* si_106 = di_101;
		word16 cx_117 = ~cx_103;
		while (true)
		{
			cl_134 = (byte) cx_117;
			if (cx_117 == 0x00)
				break;
			(0xA000->*di_101).b0000 = (0x8000->*si_106).b0000;
			--si_106;
			--di_101;
			--cx_117;
		}
	} while (__in<byte>(0x60) != 0x01);
}

