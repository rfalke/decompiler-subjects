// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100(Register word16 cx, Register word16 si, Register (ptr16 Eq_5) ds)
void fn0C00_0100(word16 cx, word16 si, struct Eq_5 * ds)
{
	struct Eq_5 * cs;
	bios_video_set_mode(0x13);
	cui16 ax_16 = 0x86;
	do
	{
		fn0C00_01E3();
		byte Eq_18::* di_189 = Eq_18::a0000;
		--cx;
		byte al_238 = (byte) ax_293 - 0x01;
		while (true)
		{
			ax_16 = ax_293 - 0x01;
			byte ch_212 = SLICE(cx, byte, 8);
			if (cx == 0x00)
				break;
			0xA000->*di_189 = al_238;
			++di_189;
			--cx;
		}
		ax_293 = ax_16;
	} while (ax_293 != 0x01);
	word16 dx_31 = 0x01;
	Eq_44 bx_32 = 0x0140;
	word16 cx_290 = SEQ(ch_212, 0x09);
	do
	{
		byte cl_34 = (byte) cx_294;
		if ((cl_34 & 0x0D) != 0x00 && PARITY_EVEN(cl_34 & 0x0D))
			si = 0x01EC;
		dx_31 = fn0C00_01A1(si, cx_294, dx_31, bx_32, 0xA000, out bx_32, out si, out ds);
		cx_290 = SEQ(SLICE(cx_294 - 0x01, byte, 8), cl_34 - 0x01);
		cx_294 = cx_290;
	} while (cx_294 != 0x01);
	do
	{
		fn0C00_01E3();
		uint32 eax_76 = ds->dw0200 * ~0x21520F52;
		ds->dw0200 = eax_76 + 0x01;
		0xA000->*((word16) ((word16) SLICE(eax_76 + 0x01, byte, 8)) + 3) = (word16) ((byte) eax_76 + 0x01 & 0x1F | 0x1C);
		struct Eq_114 Eq_18::* bx_155 = Eq_18::a0000;
		do
		{
			struct Eq_114 Eq_18::* bx_94 = bx_155 - 0x01;
			if ((0xA000->*bx_94).b0000 != 0x00)
			{
				struct Eq_114 Eq_18::* bx_116;
				cu8 v28_101 = (0xA000->*bx_94).b0000;
				(0xA000->*bx_94).b0000 = 0x00;
				cu8 al_103 = v28_101;
				if (v28_101 < 0x20)
				{
					bx_116 = &bx_94->b0000 + 320;
					byte bl_117 = (byte) bx_94 + 0x40;
					if ((bl_117 & 0xC0) == 0x00 && PARITY_EVEN(bl_117 & 0xC0))
						bx_116 = &bx_94->b0000 + 0x0141;
					if ((0xA000->*bx_116).b0000 >= 0x01)
					{
						bx_116 = &bx_116->b0000 + 1;
						if ((0xA000->*bx_116).b0000 >= 0x01)
						{
							bx_116 -= 0x02;
							if ((0xA000->*bx_116).bFFFFFFFE >= 0x01)
								bx_116 = bx_94;
						}
					}
				}
				else
				{
					word16 ax_110 = SEQ(0x01, v28_101);
					if (v28_101 == 0x20)
						ax_110 = SEQ(0x01, v28_101 + 0x18);
					al_103 = (byte) ax_110 - 0x01;
					bx_116 = bx_94;
				}
				(0xA000->*bx_116).b0000 = al_103;
			}
			bx_155 = bx_94;
		} while (bx_94 != Eq_18::a0000);
		ds = cs;
		byte al_182;
		byte ah_183;
	} while (bios_kbd_check_keystroke(out al_182, out ah_183));
	bios_video_set_mode(0x03);
	__syscall<byte>(22);
}

// 0C00:01A1: Register word16 fn0C00_01A1(Sequence (ptr32 word16) ds_si, Register word16 cx, Register word16 dx, Register Eq_44 bx, Register word16 bp, Register out ptr16 bxOut, Register out ptr16 siOut, Register out (ptr16 Eq_58) dsOut)
// Called from:
//      fn0C00_0100
word16 fn0C00_01A1(word16 * ds_si, word16 cx, word16 dx, Eq_44 bx, word16 bp, ptr16 & bxOut, ptr16 & siOut, struct Eq_58 & dsOut)
{
	struct Eq_215 * ds = SLICE(ds_si, selector, 16);
	word16 si = (word16) ds_si;
	*ds_si += 100;
	Eq_44 bx_26;
	word16 di_27;
	struct Eq_229 * ds_28;
	word16 si_54;
	word16 dx_29 = fn0C00_01AB(SEQ(bp, *ds_si), si + 2, cx, dx, bx, out bx_26, out si_54, out di_27, out ds_28);
	ptr16 bx_40;
	struct Eq_58 * ds_42;
	ptr16 si_44;
	word16 di_55;
	word16 dx_43 = fn0C00_01AB(SEQ(bp, di_27), si + 2, cx, dx_29, bx_26, out bx_40, out si_44, out di_55, out ds_42);
	bxOut = bx_40;
	siOut = si_44;
	dsOut = ds_42;
	return dx_43;
}

// 0C00:01AB: Register word16 fn0C00_01AB(Sequence (ptr32 byte) bp_di, Sequence (ptr32 byte) ds_si, Register word16 cx, Register word16 dx, Register Eq_44 bx, Register out ptr16 bxOut, Register out ptr16 siOut, Register out ptr16 diOut, Register out (ptr16 Eq_242) dsOut)
// Called from:
//      fn0C00_01A1
word16 fn0C00_01AB(byte * bp_di, byte * ds_si, word16 cx, word16 dx, Eq_44 bx, ptr16 & bxOut, ptr16 & siOut, ptr16 & diOut, struct Eq_242 & dsOut)
{
	word16 bp = SLICE(bp_di, word16, 16);
	Eq_44 bx_14;
	word16 di_15;
	word16 dx_17;
	byte * ds_si_37 = fn0C00_01AE(bp_di, ds_si, (byte) cx, dx, bx, out dx_17, out bx_14, out di_15);
	ptr16 bx_26;
	ptr16 di_27;
	word16 dx_29;
	byte * ds_si_42 = fn0C00_01AE(SEQ(bp, di_15), ds_si_37, (byte) cx, dx_17, bx_14, out dx_29, out bx_26, out di_27);
	bxOut = bx_26;
	siOut = (word16) ds_si_42;
	diOut = di_27;
	dsOut = SLICE(ds_si_42, selector, 16);
	return dx_29;
}

// 0C00:01AE: Sequence (ptr32 byte) fn0C00_01AE(Sequence (ptr32 byte) bp_di, Sequence (ptr32 byte) ds_si, Register byte ch, Register word16 dx, Register Eq_44 bx, Register out Eq_44 dxOut, Register out ptr16 bxOut, Register out Eq_284 diOut)
// Called from:
//      fn0C00_01AB
byte * fn0C00_01AE(byte * bp_di, byte * ds_si, byte ch, word16 dx, Eq_44 bx, union Eq_44 & dxOut, ptr16 & bxOut, union Eq_284 & diOut)
{
	word16 cx;
	struct Eq_304 * cs;
	byte ch_15 = SLICE(cx, byte, 8);
	word16 si = (word16) ds_si;
	struct Eq_309 * bp = SLICE(bp_di, word16, 16);
	byte al_10 = *ds_si;
	word16 cx_58 = SEQ(ch_15, al_10);
	if (al_10 == 0x3C)
		cx_58 = SEQ(ch_15 + 0x01, al_10);
	Eq_284 di_37 = fn0C00_01DC(fn0C00_01DE(bp_di, 0x20, dx), 0x35, 0x20, dx, bx);
	do
	{
		word16 di_44 = di_37 + bx;
		bp->*((word16) bx + di_44) = 0x34;
		di_37 = fn0C00_01DC(di_44 - bx, 0x35, 0x20, dx, bx);
		--cx_58;
	} while (cx_58 != 0x00);
	Eq_284 di_61 = fn0C00_01DC(di_37, 0x35, 0x20, dx, bx);
	bp->*di_61 = 0x20;
	dxOut = bx;
	bxOut = -dx;
	diOut = di_61;
	return si + 1;
}

// 0C00:01DC: Register word16 fn0C00_01DC(Sequence (ptr32 byte) ds_di, Register byte ah, Register byte al, Register word16 dx, Register Eq_44 bx)
// Called from:
//      fn0C00_01AE
word16 fn0C00_01DC(byte * ds_di, byte ah, byte al, word16 dx, Eq_44 bx)
{
	ds_di[(uipr32) bx] = ah;
	return fn0C00_01DE(ds_di, al, dx);
}

// 0C00:01DE: Register word16 fn0C00_01DE(Sequence (ptr32 byte) ds_di, Register byte al, Register word16 dx)
// Called from:
//      fn0C00_01AE
//      fn0C00_01DC
word16 fn0C00_01DE(byte * ds_di, byte al, word16 dx)
{
	word16 di = (word16) ds_di;
	*ds_di = al;
	return di + dx;
}

// 0C00:01E3: void fn0C00_01E3()
// Called from:
//      fn0C00_0100
void fn0C00_01E3()
{
	do
		;
	while ((__in<byte>(0x03DA) & 0x08) == 0x00);
}

