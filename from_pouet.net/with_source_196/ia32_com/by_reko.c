// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100(Register word16 cx, Register Eq_4 bp, Register (ptr16 Eq_5) es, Register (ptr16 Eq_6) ds)
void fn0C00_0100(word16 cx, Eq_4 bp, struct Eq_5 * es, struct Eq_6 * ds)
{
	__syscall<byte>(0x10);
	cui16 ax_248 = 20226;
	do
	{
		byte al_8 = (byte) ax_248;
		__out<byte>(969, al_8);
		__out<byte>(969, al_8);
		__out<byte>(969, al_8);
		--cx;
		ax_248 = SEQ(SLICE(ax_248 + 0x01, byte, 8), al_8 + 0x01);
	} while (cx != 0x00);
	__syscall<byte>(0x10);
	do
	{
		byte Eq_42::* di_133 = &Eq_42::bFFFF;
		cu16 bx_162 = 0x01E0;
		do
		{
			cu16 cx_158;
			for (cx_158 = 0x0280; cx_158 != 0x00; --cx_158)
			{
				cu16 bx_41 = bx_251 - 0xF0;
				ui8 al_117 = (byte) (63 /16 SEQ(SLICE(bx_41, byte, 8), (byte) bx_41 | 0x01)) & 0x3F ^ 0x3F;
				if (bx_251 >= 0x3C && (bx_251 < 0x017C && (cx_158 >= 0x32 && cx_158 < 500)))
				{
					al_117 = (byte) (bx_251 >> 0x03);
					if (bx_251 >= 0x50 && (bx_251 < 0x0168 && (cx_158 >= 0x3C && cx_158 < 0x01EA)))
					{
						byte bl_101 = 0x00;
						if ((Mem85[es:(bx_251 >>u 0x02 & 0x07) + bp + (((bx_251 ^ Mem77[0C00:0400:word16]) ^ cx_158) & 0x03C0):byte] & 0x01 << (SLICE(cx_158 >>u 0x01, byte, 0) & 0x07)) != 0x00)
							bl_101 = 0x10;
						Eq_98 ax_110 = (ds->w0116 *s ds->t0200 >> 0x01) + ds->w0204;
						--ds->w0204;
						ds->t0200 = ax_110;
						al_117 = (byte) (ax_110 >> 0x0C) + bl_101;
					}
				}
				0xA000->*di_133 = al_117;
				byte Eq_42::* di_136 = di_133 + 1;
				di_133 = di_136;
				if (di_136 == &Eq_42::b0000)
					__syscall<byte>(0x10);
			}
			bx_162 = bx_251 - 0x01;
			bx_251 = bx_162;
		} while (bx_251 != 0x01);
		++seg0C00->w0400;
	} while (__in<byte>(0x60) != 0x01);
}

