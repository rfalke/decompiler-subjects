// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100(Sequence (ptr32 Eq_10) ds_bx, Register Eq_4 di)
void fn0C00_0100(union Eq_10 * ds_bx, Eq_4 di)
{
	__syscall<byte>(0x10);
	Eq_10 es_ax_8 = ds_bx->u1;
	word16 ax_56 = (word16) es_ax_8;
	struct Eq_16 * es_69 = SLICE(es_ax_8, selector, 16);
	while (true)
	{
		Eq_63 dx_ax_15 = SEQ(SLICE((int32) ax_56, word16, 16), di);
		uint16 dx_17 = (uint16) (dx_ax_15 % 0x0140);
		word16 cx_13;
		uint16 ax_18 = (uint16) (dx_ax_15 /u 0x0140);
		int16 bx_22 = 0x00;
		int16 si_23 = 0x00;
		word16 dx_68 = SEQ(SLICE(dx_17, byte, 8) - 0x01, (byte) dx_17);
		for (cx_13 = 0x0140; cx_13 != 0x00; --cx_13)
		{
			int16 si_30 = si_23 *s bx_22;
			int16 bx_32 = bx_22 *s bx_22;
			if (OVERFLOW<word16>(bx_32))
				break;
			int16 bp_35 = si_23 *s si_23;
			if (OVERFLOW<word16>(bp_35))
				break;
			int16 bx_38 = bx_32 + bp_35;
			if (OVERFLOW<word16>(bx_38))
				break;
			bx_22 = (bx_38 - bp_35 * 0x02 >> 0x06) + dx_68;
			si_23 = (si_30 * 0x02 >> 0x06) + (ax_18 - 100);
		}
		es_69->*di = (byte) cx_13;
		ax_56 = cx_13;
		di = (word16) di + 1;
	}
}

