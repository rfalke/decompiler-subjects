// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100(Register ui16 eax_16_16, Register byte al, Register word16 cx, Register word16 ebx_16_16, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds)
void fn0C00_0100(ui16 eax_16_16, byte al, word16 cx, word16 ebx_16_16, struct Eq_7 * es, struct Eq_8 * ds)
{
	struct Eq_8 * cs;
	byte Eq_7::* di_367 = Eq_7::a02CB;
	for (; cx != 0x00; --cx)
	{
		es->*di_367 = al;
		++di_367;
	}
	byte Eq_8::* si_10 = Eq_8::a02AE;
	byte Eq_7::* di_25 = &Eq_7::b02E2;
	byte cl_33 = 0x20;
	do
	{
		ui8 bl_12 = ds->*si_10;
		++si_10;
		byte ch_15 = 0x04;
		do
		{
			uint16 bx_18 = (uint16) bl_12;
			al += SLICE(bx_18 << 0x02, byte, 8);
			es->*di_25 = al;
			--ch_15;
			bl_12 = (byte) bx_18 << 0x02;
			++di_25;
			word16 cx_34 = SEQ(ch_15, cl_33);
		} while (ch_15 != 0x00);
		--cl_33;
		byte ch_383 = SLICE(cx_34 - 0x01, byte, 8);
	} while (cx_34 != 0x01);
	byte Eq_8::* si_36 = &Eq_8::b0360;
	byte Eq_7::* di_37 = &Eq_7::b0361;
	word16 cx_384 = SEQ(ch_383, 0x80);
	do
	{
		es->*di_37 = ds->*si_36;
		--cx_384;
		--si_36;
		++di_37;
		byte ch_52 = SLICE(cx_384, byte, 8);
		byte cl_385 = (byte) cx_384;
	} while (cx_384 != 0x00);
	byte Eq_8::* si_51 = si_36 + 1;
	word16 cx_386 = SEQ(ch_52 + 0x01, cl_385);
	do
	{
		es->*di_37 = -(ds->*si_51);
		--cx_386;
		++si_51;
		++di_37;
		byte ch_388 = SLICE(cx_386, byte, 8);
	} while (cx_386 != 0x00);
	bios_video_set_mode(0x13);
	word16 cx_642 = SEQ(ch_388, 0x3F);
	do
	{
		byte cl_74 = (byte) cx_645;
		__out<byte>(0x03C8, cl_74);
		__out<byte>(969, 0x00);
		__out<byte>(969, cl_74);
		__out<byte>(969, 0x00);
		cx_642 = SEQ(SLICE(cx_645 - 0x01, byte, 8), cl_74 - 0x01);
		cx_645 = cx_642;
	} while (cx_645 != 0x01);
	word16 bx_88;
	msdos_resize_memory_block(es, 0x1000, out bx_88);
	msdos_allocate_memory_block(0x1000);
	struct Eq_169 * es_95 = 0x4800;
	byte Eq_169::* di_361 = Eq_169::a0000;
	word16 cx_102 = SEQ(~0x05, cl_74 - 0x01);
	while (true)
	{
		byte cl_391 = (byte) cx_102;
		if (cx_102 == 0x00)
			break;
		es_95->*di_361 = 0x00;
		++di_361;
		--cx_102;
	}
	if (!msdos_allocate_memory_block(0x1000))
	{
		struct Eq_200 * gs_108 = 0x4800;
		struct Eq_202 * es_109 = 0x4800;
		byte Eq_202::* di_112 = Eq_202::a0000;
		word16 cx_116;
		for (cx_116 = SEQ(~0x05, cl_391); cx_116 != 0x00; --cx_116)
		{
			es_109->*di_112 = 0x00;
			++di_112;
		}
		do
		{
			word16 bp_124;
			for (bp_124 = 2000; bp_124 != 0x00; --bp_124)
			{
				uint32 ax_dx_480 = SEQ(ds->w02D2, ds->w02CE) + (uint32) ds->w02D0;
				ds->w02CE = (word16) ax_dx_480;
				cui16 ax_139 = SLICE(ax_dx_480, word16, 16);
				ds->w02D2 = ax_139 & 0x01FF;
				uint32 ax_dx_482 = SEQ(ds->w02D8, ds->w02D4) + (uint32) ds->t02D6;
				ds->w02D4 = (word16) ax_dx_482;
				cui16 ax_153 = SLICE(ax_dx_482, word16, 16);
				ds->w02D8 = ax_153 & 0x01FF;
				word32 ebx_169;
				word32 eax_168 = fn0C00_0288(SEQ(ebx_16_16, 0x00, (word16) (ds->*((word16) (ax_153 & 0x01FF) + 737)) + 0x0080), eax_16_16, ds, out ebx_169);
				word16 di_177 = (word16) eax_168 + ds->w02DD;
				word32 ebx_188;
				word32 eax_187 = fn0C00_0288(SEQ(SLICE(ebx_169, word24, 8), (word16) (ds->*((word16) (ax_139 & 0x01FF) + 737)) + 0x0080), SLICE(eax_168, word16, 16), ds, out ebx_188);
				struct Eq_310 Eq_200::* di_204 = di_177 + (uint16) ((byte) eax_187) * 0x0140;
				(gs_108->*di_204).w0000 = 7999;
				(gs_108->*di_204).w0140 = 7999;
				ebx_16_16 = SLICE(ebx_188, word16, 16);
				eax_16_16 = SLICE(eax_187, word16, 16);
			}
			Eq_332 di_217 = 0xFA00;
			do
			{
				word16 ax_223 = Mem220[gs_108:di_217 + -0x0141:word16] + Mem220[gs_108:di_217 + 0x00:word16];
				Eq_354 al_229 = ((byte) ax_223 + SLICE(ax_223, byte, 8) >> 0x02) - 0x01;
				Eq_334 al_230 = al_229 - 0x01;
				if (al_229 < 0x01)
					al_230.u0 = 0x00;
				gs_108->*di_217 = al_230;
				--di_217;
			} while (di_217 >= 0x0144);
			do
			{
				gs_108->*di_217 = 0x00;
				--di_217;
			} while (di_217 >= 0x00);
			memcpy((word16) di_217 + 1, *gs_108, 0xFA00);
			ds = cs;
			if (cs->w02DA == 0x00)
			{
				cs->w02DD = 0x7DA0;
				cs->t02DF = (word16) cs->t02DF + 2;
				word16 ax_303 = cs->*((word16) cs->t02DF + 663);
				byte al_305 = (byte) ax_303;
				byte ah_312 = SLICE(ax_303, byte, 8);
				if (al_305 == 0x00)
					break;
				cs->b02D1 = al_305;
				cs->b02D7 = ah_312;
				cs->t02D6.u0 = 0x20;
			}
			uint16 ax_317 = cs->w02DA;
			uint16 ax_318 = ax_317 + 0x01;
			if (ax_317 >= 399)
				ax_318 = 0x00;
			cs->w02DA = ax_318;
			byte al_330 = cs->b02DC + 0x01 & 0x03;
			if (al_330 == 0x00)
				cs->w02DD -= 0x0141;
			cs->b02DC = al_330;
			do
				;
			while ((__in<byte>(0x03DA) & 0x08) == 0x00);
		} while (__in<byte>(0x60) != 0x01);
	}
	bios_video_set_mode(0x03);
}

// 0C00:0288: Register uint32 fn0C00_0288(Sequence Eq_274 ebx_24_8_al, Register ui16 eax_16_16, Register (ptr16 Eq_8) ds, Register out Eq_274 ebxOut)
// Called from:
//      fn0C00_0100
uint32 fn0C00_0288(Eq_274 ebx_24_8_al, ui16 eax_16_16, struct Eq_8 * ds, union Eq_274 & ebxOut)
{
	uint32 eax_16 = ebx_24_8_al * (SEQ(eax_16_16, ds->w02DA) << 0x08) >> 0x11;
	ebxOut = ebx_24_8_al;
	return eax_16;
}

