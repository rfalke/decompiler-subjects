// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100()
void fn0C00_0100()
{
	struct Eq_3 * cs;
	Eq_4 Top_3 = 0;
	bios_video_set_mode(0x13);
	__out<byte>(0x03C7, 0x00);
	word16 cx_19;
	for (cx_19 = 0x0300; cx_19 != 0x00; --cx_19)
		__in<byte>(969);
	seg0C00->dw0409 = cs->dw46C8;
	seg0C00->ptr0403 = Eq_83::a013F;
	do
	{
		ui16 cx_36;
		for (cx_36 = 199; cx_36 != 0x00; --cx_36)
		{
			seg0C00->t0405 = seg0C00->ptr0403 + cx_36 /16 320;
			__wait();
			__fninit();
			--Top_3;
			Top_3.u1->r0000 = (real64) seg0C00->t0405;
			Top_3.u1->r0000 = sqrt(Top_3.u1->r0000);
			seg0C00->t0405.u0 = (int16) Top_3.u1->r0000;
			0xA000:Mem47[0C00:0403:word16][cx_36 * 0x0140] = Mem47[0C00:0405:byte] + SLICE(CONVERT(fn0C00_0520(), word16, uint32) %u 0x0C, byte, 0) - 0x06 << 0x01;
		}
		struct Eq_936 Eq_83::* v25_77 = seg0C00->ptr0403 - 0x01;
		seg0C00->ptr0403 = v25_77;
	} while (v25_77 != Eq_83::a0000);
	bios_video_write_string(0x00, 0x00, 0x07, 0x10, 0x0C, 0x0C, (char *) cs + 0x040D);
	word16 cx_100;
	for (cx_100 = 0xFF; cx_100 != 0x00; --cx_100)
	{
		__out<byte>(0x03C8, (byte) cx_100);
		__out<byte>(969, (byte) cx_100);
		__out<byte>(969, (byte) cx_100 * 0x05);
		__out<byte>(969, (byte) cx_100 - 100);
	}
	fn0C00_0542();
	fn0C00_0445();
	fn0C00_041D(0xA000);
	cui16 cx_667 = 0x3F;
	do
	{
		Eq_14 cl_155 = (byte) cx_670;
		__out<byte>(0x03C8, cl_155);
		__out<byte>(969, 0x00);
		__out<byte>(969, 0x00);
		__out<byte>(969, cl_155);
		cx_667 = SEQ(SLICE(cx_670 - 0x01, byte, 8), cl_155 - 0x01);
		cx_670 = cx_667;
	} while (cx_670 != 0x01);
	byte Eq_83::* di_167 = Eq_83::a0000;
	word16 cx_171;
	for (cx_171 = ~0x00; cx_171 != 0x00; --cx_171)
	{
		0xA000->*di_167 = 0x3F;
		++di_167;
	}
	seg0C00->w0688 = 0x78;
	__out<byte>(0x43, 0xB0);
	__out<byte>(66, ~0x00);
	__out<byte>(66, ~0x00);
	__out<byte>(0x61, __in<byte>(0x61) | 0x01);
	do
	{
		byte al_191 = (byte) fn0C00_0520();
		byte Eq_83::* di_204 = fn0C00_0520() - 0x32;
		byte al_211 = (byte) fn0C00_0520();
		uint16 cx_218;
		for (cx_218 = (uint16) (al_191 & 0x32); cx_218 != 0x00; --cx_218)
		{
			0xA000->*di_204 = (al_211 & 0x2B) + 0x0A;
			++di_204;
		}
		word16 cx_219;
		for (cx_219 = 0x0100; cx_219 != 0x00; --cx_219)
			;
		if ((__in<byte>(0x60) & 0x80) == 0x00)
		{
			bios_video_set_mode(0x03);
			msdos_terminate(0x00);
		}
		if (((uint16) __in<byte>(0x61) & 0x20) == 0x00)
			continue;
		__out<byte>(0x43, 0xB0);
		__out<byte>(66, ~0x00);
		__out<byte>(66, ~0x00);
		__out<byte>(0x61, __in<byte>(0x61) | 0x01);
		word16 v38_248 = seg0C00->w0688 - 0x01;
		seg0C00->w0688 = v38_248;
	} while (v38_248 != 0x00);
	fn0C00_0445();
	fn0C00_041D(0xA000);
	seg0C00->w06FF = 0x78;
	__out<byte>(0x43, 0xB0);
	__out<byte>(66, ~0x00);
	__out<byte>(66, ~0x00);
	__out<byte>(0x61, __in<byte>(0x61) | 0x01);
	do
	{
		Eq_73 ax_291 = fn0C00_0520();
		cui16 cx_293;
		Eq_73 di_297 = ax_291;
		byte al_663 = (byte) fn0C00_0520();
		for (cx_293 = ax_291 & 0x0A; cx_293 != 0x00; --cx_293)
		{
			0xA000->*di_297 = al_663;
			di_297 = (word16) di_297 + 1;
		}
		if ((__in<byte>(0x60) & 0x80) == 0x00)
		{
			bios_video_set_mode(0x03);
			msdos_terminate(0x00);
		}
		if (((uint16) __in<byte>(0x61) & 0x20) == 0x00)
			continue;
		__out<byte>(0x43, 0xB0);
		__out<byte>(66, ~0x00);
		__out<byte>(66, ~0x00);
		__out<byte>(0x61, __in<byte>(0x61) | 0x01);
		word16 v41_329 = seg0C00->w06FF - 0x01;
		seg0C00->w06FF = v41_329;
	} while (v41_329 != 0x00);
	fn0C00_0445();
	fn0C00_041D(0xA000);
	struct Eq_413 * dx_353 = 0x00;
	seg0C00->w0767 = 100;
	__out<byte>(0x43, 0xB0);
	__out<byte>(66, ~0x00);
	__out<byte>(66, ~0x00);
	__out<byte>(0x61, __in<byte>(0x61) | 0x01);
	do
	{
		memcpy(A000:0000, *dx_353, 0xFFFF);
		dx_353 = (struct Eq_413 *) ((char *) dx_353 + 100);
		word16 cx_383;
		for (cx_383 = ~0x00; cx_383 != 0x00; --cx_383)
			;
		if ((__in<byte>(0x60) & 0x80) == 0x00)
		{
			bios_video_set_mode(0x03);
			msdos_terminate(0x00);
		}
		if (((uint16) __in<byte>(0x61) & 0x20) == 0x00)
			continue;
		__out<byte>(0x43, 0xB0);
		__out<byte>(66, ~0x00);
		__out<byte>(66, ~0x00);
		__out<byte>(0x61, __in<byte>(0x61) | 0x01);
		word16 v46_411 = seg0C00->w0767 - 0x01;
		seg0C00->w0767 = v46_411;
	} while (v46_411 != 0x00);
	fn0C00_0445();
	fn0C00_041D(0xA000);
	word16 ebx_16_16_643 = 0x00;
	uint32 ecx_646 = 0x013F;
	do
	{
		word16 ebx_16_16_641;
		uint32 ebx_449 = SEQ(ebx_16_16_643, 199);
		do
		{
			ebx_642 = SEQ(ebx_16_16_641, bx_455 - 0x01);
			struct Eq_940 Eq_83::* cx_461 = (word16) ecx_646;
			ui16 bx_455 = (word16) ebx_449;
			(&&(0xA000->*(0xA000->*cx_461).b0000))[bx_455].b0000 = (byte) ((word16) (ecx_646 *64 ebx_449) >> 0x08);
			word16 ecx_16_16_649 = SLICE(ecx_646, word16, 16);
			ebx_16_16_641 = SLICE(ebx_449, word16, 16);
			ebx_449 = ebx_642;
		} while (bx_455 != 0x00);
		ecx_646 = SEQ(ecx_16_16_649, cx_461 - 0x01);
		ebx_16_16_643 = ebx_16_16_641;
	} while (cx_461 != Eq_83::a0000);
	fn0C00_0542();
	fn0C00_0542();
	fn0C00_0445();
	fn0C00_041D(0xA000);
	word16 ebx_16_16_654 = 0x00;
	uint32 ecx_657 = 0x013F;
	do
	{
		word16 ebx_16_16_652;
		uint32 ebx_522 = SEQ(ebx_16_16_654, 199);
		do
		{
			ebx_653 = SEQ(ebx_16_16_652, bx_534 - 0x01);
			struct Eq_942 Eq_83::* cx_540 = (word16) ecx_657;
			ui16 bx_534 = (word16) ebx_522;
			(&&(0xA000->*(0xA000->*cx_540).b0000))[bx_534].b0000 = (byte) ((word16) (ecx_657 * ecx_657 + ebx_522 * ebx_522) >> 0x02);
			word16 ecx_16_16_660 = SLICE(ecx_657, word16, 16);
			ebx_16_16_652 = SLICE(ebx_522, word16, 16);
			ebx_522 = ebx_653;
		} while (bx_534 != 0x00);
		ecx_657 = SEQ(ecx_16_16_660, cx_540 - 0x01);
		ebx_16_16_654 = ebx_16_16_652;
	} while (cx_540 != Eq_83::a0000);
	fn0C00_0542();
	fn0C00_0445();
	fn0C00_041D(0xA000);
	bios_video_set_mode(0x03);
	msdos_terminate(0x00);
}

// 0C00:041D: void fn0C00_041D(Register (ptr16 Eq_83) es)
// Called from:
//      fn0C00_0100
void fn0C00_041D(struct Eq_83 * es)
{
	word32 Eq_83::* di_4 = Eq_83::a0000;
	word16 cx_10;
	for (cx_10 = 0x4000; cx_10 != 0x00; --cx_10)
	{
		es->*di_4 = 0x00;
		++di_4;
	}
	do
		;
	while ((__in<byte>(0x03DA) & 0x08) != 0x00);
	do
		;
	while ((__in<byte>(0x03DA) & 0x08) == 0x00);
	__out<byte>(0x03C8, 0x00);
	word16 cx_32;
	for (cx_32 = 0x0300; cx_32 != 0x00; --cx_32)
		__out<byte>(969, 0x00);
}

// 0C00:0445: void fn0C00_0445()
// Called from:
//      fn0C00_0100
void fn0C00_0445()
{
	while (true)
	{
		word16 bp_30 = 0x00;
		cui16 cx_122 = 0xFF;
		do
		{
			Eq_14 cl_10 = (byte) cx_125;
			__out<byte>(0x03C7, cl_10);
			uint16 ax_16 = (uint16) __in<byte>(969);
			uint16 ax_19 = (uint16) __in<byte>(969);
			uint16 ax_22 = (uint16) __in<byte>(969);
			uint16 bx_24 = ax_16;
			if (ax_16 != 0x00)
			{
				bx_24 = ax_16 - 0x01;
				++bp_30;
			}
			uint16 si_34 = ax_19;
			if (ax_19 != 0x00)
			{
				si_34 = ax_19 - 0x01;
				++bp_30;
			}
			uint16 di_45 = ax_22;
			if (ax_22 != 0x00)
			{
				di_45 = ax_22 - 0x01;
				++bp_30;
			}
			__out<byte>(0x03C8, cl_10);
			__out<byte>(969, (byte) bx_24);
			__out<byte>(969, (byte) si_34);
			__out<byte>(969, (byte) di_45);
			cx_122 = SEQ(SLICE(cx_125 - 0x01, byte, 8), cl_10 - 0x01);
			cx_125 = cx_122;
		} while (cx_125 != 0x01);
		if (bp_30 == 0x00)
			break;
		__out<byte>(0x43, 0xB0);
		__out<byte>(66, ~0x00);
		__out<byte>(66, ~0x00);
		__out<byte>(0x61, __in<byte>(0x61) | 0x01);
		do
			;
		while (((uint16) __in<byte>(0x61) & 0x20) == 0x00);
	}
}

// 0C00:04AC: void fn0C00_04AC()
// Called from:
//      fn0C00_0542
void fn0C00_04AC()
{
	do
		;
	while ((__in<byte>(0x03DA) & 0x08) != 0x00);
	do
		;
	while ((__in<byte>(0x03DA) & 0x08) == 0x00);
	__out<byte>(0x03C7, ~0x00);
	seg0C00->t04AF.u1 = (uint16) __in<byte>(969);
	seg0C00->t04B1.u1 = (uint16) __in<byte>(969);
	seg0C00->t04B3.u1 = (uint16) __in<byte>(969);
	Eq_14 cl_38 = ~0x01;
	do
	{
		__out<byte>(0x03C7, cl_38);
		uint16 ax_44 = (uint16) __in<byte>(969);
		uint16 ax_47 = (uint16) __in<byte>(969);
		uint16 ax_50 = (uint16) __in<byte>(969);
		Eq_14 cl_52 = (word16) cl_38 + 1;
		__out<byte>(0x03C8, cl_52);
		__out<byte>(969, (byte) ax_44);
		__out<byte>(969, (byte) ax_47);
		__out<byte>(969, (byte) ax_50);
		cl_38 = cl_52 - 0x02;
	} while (cl_52 != 0x02);
	__out<byte>(0x03C8, 0x01);
	__out<byte>(969, seg0C00->t04AF);
	__out<byte>(969, seg0C00->t04B1);
	__out<byte>(969, seg0C00->t04B3);
}

struct Eq_936 Eq_83::* g_ptr0403 = ;
Eq_39 g_t0405 = // 0C00:0505
	{
		-0x00003602
	};
uint32 g_dw0409 = 3367633328; // 0C00:0509
// 0C00:0520: Register word16 fn0C00_0520()
// Called from:
//      fn0C00_0100
word16 fn0C00_0520()
{
	uint32 eax_8 = seg0C00->dw0409;
	seg0C00->dw0409 = eax_8 * 0x00010003 + 74565;
	return (word16) (eax_8 * 0x00010003 + 74565 >> 0x10);
}

// 0C00:0542: void fn0C00_0542()
// Called from:
//      fn0C00_0100
void fn0C00_0542()
{
	seg0C00->w0544 = 0x78;
	__out<byte>(0x43, 0xB0);
	__out<byte>(66, ~0x00);
	__out<byte>(66, ~0x00);
	__out<byte>(0x61, __in<byte>(0x61) | 0x01);
	do
	{
		fn0C00_04AC();
		fn0C00_04AC();
		if ((__in<byte>(0x60) & 0x80) == 0x00)
		{
			bios_video_set_mode(0x03);
			msdos_terminate(0x00);
		}
		if (((uint16) __in<byte>(0x61) & 0x20) == 0x00)
			continue;
		__out<byte>(0x43, 0xB0);
		__out<byte>(66, ~0x00);
		__out<byte>(66, ~0x00);
		__out<byte>(0x61, __in<byte>(0x61) | 0x01);
		word16 v13_62 = seg0C00->w0544 - 0x01;
		seg0C00->w0544 = v13_62;
	} while (v13_62 != 0x00);
}

Eq_14 g_t04AF = // 0C00:05AF
	{
		66
	};
Eq_14 g_t04B1 = // 0C00:05B1
	{
		191
	};
Eq_14 g_t04B3 = // 0C00:05B3
	{
		0x01
	};
word16 g_w0544 = 58359; // 0C00:0644
word16 g_w0688 = ~0x4600; // 0C00:0788
word16 g_w06FF = 0xC08A; // 0C00:07FF
word16 g_w0767 = 0x03B8; // 0C00:0867
