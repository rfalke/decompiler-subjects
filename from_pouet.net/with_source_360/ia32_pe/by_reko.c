// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

WCHAR g_t402000 = 'D'; // 00402000
WCHAR g_t402012 = '<'; // 00402012
WCHAR g_t40204C = 'S'; // 0040204C
Eq_297 g_t40206C = // 0040206C
	{
		
		{
			0x28,
			320,
			200,
			0x01,
			0x20,
			0x00,
			0x00,
			0,
			0,
			0x00,
			0x00,
		},
		
		{
			
			{
				0x00,
				0x00,
				0x00,
				0x00,
			},
		},
	};
Eq_383 g_t4020A4 = // 004020A4
	{
		0x00,
		&g_t401324,
		0,
		0,
		null,
		null,
		null,
		&g_t0002,
		null,
		&g_str402000,
	};
Eq_358 g_t4020B4 = // 004020B4
	{
		null
	};
Eq_367 g_t4020B8 = null; // 004020B8
Eq_370 g_t4020BC = null; // 004020BC
Eq_279 g_t4020CC = null; // 004020CC
Eq_287 g_t4020D0 = null; // 004020D0
Eq_458 g_t4020D4 = // 004020D4
	{
		null,
		0x00,
		0x00,
		0,
		0x00,
		
		{
			0,
			0,
		},
	};
word32 g_dw4020D8 = 0x00; // 004020D8
Eq_298 g_t4020DC = 0x00; // 004020DC
struct tagRECT g_t4020F0 = // 004020F0
	{
		0,
		0,
		0,
		0,
	};
int32 g_dw4020F8 = 0; // 004020F8
int32 g_dw4020FC = 0; // 004020FC
Eq_179 g_t402100 = // 00402100
	{
		null
	};
Eq_2 g_t402104 = // 00402104
	{
		null
	};
word32 g_dw402108 = 0x00; // 00402108
Eq_2 g_t40210C = // 0040210C
	{
		null
	};
Eq_121 g_t40211C = null; // 0040211C
Eq_124 g_t402120 = null; // 00402120
int16 g_w40213A = 0x000028C0; // 0040213A
word16 g_w40213B = 0x28; // 0040213B
Eq_35 g_t40213C = // 0040213C
	{
		0x00
	};
int16 g_w40213E = 0; // 0040213E
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw403074 = 12444; // 00403074
word32 g_dw403078 = 0x30AA; // 00403078
word32 g_dw40307C = 0x30BE; // 0040307C
word32 g_dw403080 = 0x30CC; // 00403080
<anonymous> * __imp__ExitProcess = &g_t309C; // 00403088
<anonymous> * __imp__GetModuleHandleW = &g_t30AA; // 0040308C
<anonymous> * __imp__GlobalAlloc = &g_t30BE; // 00403090
<anonymous> * __imp__GlobalFree = &g_t30CC; // 00403094
word32 g_dw4030DA = 12618; // 004030DA
word32 g_dw4030DE = 12636; // 004030DE
word32 g_dw4030E2 = 0x316E; // 004030E2
word32 g_dw4030E6 = 0x3182; // 004030E6
word32 g_dw4030EA = 0x3192; // 004030EA
word32 g_dw4030EE = 0x319A; // 004030EE
word32 g_dw4030F2 = 12712; // 004030F2
word32 g_dw4030F6 = 12724; // 004030F6
word32 g_dw4030FA = 0x31C2; // 004030FA
word32 g_dw4030FE = 0x31D2; // 004030FE
word32 g_dw403102 = 12772; // 00403102
word32 g_dw403106 = 0x31F6; // 00403106
word32 g_dw40310A = 0x3202; // 0040310A
<anonymous> * __imp__CreateWindowExW = &g_t314A; // 00403112
<anonymous> * __imp__DefWindowProcW = &g_t315C; // 00403116
<anonymous> * __imp__DispatchMessageW = &g_t316E; // 0040311A
<anonymous> * __imp__GetClientRect = &g_t3182; // 0040311E
<anonymous> * __imp__GetDC = &g_t3192; // 00403122
<anonymous> * __imp__LoadCursorW = &g_t319A; // 00403126
<anonymous> * __imp__LoadIconW = &g_t31A8; // 0040312A
<anonymous> * __imp__MessageBoxW = &g_t31B4; // 0040312E
<anonymous> * __imp__PeekMessageW = &g_t31C2; // 00403132
<anonymous> * __imp__PostQuitMessage = &g_t31D2; // 00403136
<anonymous> * __imp__RegisterClassW = &g_t31E4; // 0040313A
<anonymous> * __imp__ReleaseDC = &g_t31F6; // 0040313E
<anonymous> * __imp__TranslateMessage = &g_t3202; // 00403142
word32 g_dw403216 = 0x322E; // 00403216
word32 g_dw40321A = 0x3242; // 0040321A
<anonymous> * __imp__SetStretchBltMode = &g_t322E; // 00403222
<anonymous> * __imp__StretchDIBits = &g_t3242; // 00403226
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
// Called from:
//      Win32CrtStartup
void fn00401000()
{
	Eq_2 edx_12 = g_t402104.u0;
	cu8 bl_23 = 0x00;
	do
	{
		if (bl_23 >= 0x80)
			edx_12->u0->a0000 = bl_23 << 0x01;
		struct Eq_7 * edx_15 = (word32) edx_12 + 1;
		edx_15->b0000 = bl_23 << 0x01;
		edx_15->b0001 = bl_23 << 0x01;
		edx_12.u0->a0000 = &edx_15->b0001 + 2;
		++bl_23;
	} while (bl_23 != 0x00);
}

// 00401020: void fn00401020()
// Called from:
//      Win32CrtStartup
void fn00401020()
{
	bool P;
	Eq_32 Top_3 = 0;
	g_t40213C.u1 = (word16) (g_t40213C.u1 - 0x01);
	word16 eax_16_16_230 = 0x00;
	byte bl_313 = 0x00;
	byte bh_320 = 0x00;
	do
	{
		byte al_43 = bl_313;
		word16 dx_44 = 0xF400;
		do
		{
			int16 ax_47 = (int16) (al_43 - 0x80);
			g_w40213E = ax_47;
			bi8 al_49 = (byte) ax_47;
			--Top_3;
			Top_3.u1->r0000 = (real64) g_w40213E;
			dx_44 -= al_49 *s16 al_49;
			ptr32 ebx_130 = SEQ(0x00, bh_320, bl_313);
			cu8 dh_73 = SLICE(dx_44, byte, 8);
			al_43 = bh_320;
			word16 bx_140 = (word16) ebx_130;
		} while (P);
		Top_3.u1->r0001 = __atan2(Top_3.u1->r0001, Top_3.u1->r0000);
		Top_3.u1->r0001 *= (real64) g_w40213A;
		g_w40213E = (int16) Top_3.u1->r0001;
		byte ah_70 = SLICE(g_w40213E + g_w40213B, byte, 8);
		&Top_3.u1->r0000 = (word32) Top_3 + 2;
		byte cl_101 = 0x00;
		byte dh_105 = (dh_73 & 0x07) + (ah_70 & 0x07) + dh_73;
		if (dh_73 >= ~0x10)
			cl_101 = 0x50;
		if (dh_73 <= ~0x15)
		{
			word16 cx_102 = SEQ(ah_70 & 0x1F, cl_101);
			if ((ah_70 & 0x1F) <= 0x03)
			{
				if (dh_73 >= 233)
				{
					dh_105 = __ror<byte,byte>(dh_73, 0x03) + 155;
					--cx_102;
				}
				dh_105 -= 0x14;
			}
			cl_101 = (byte) cx_102;
			if (dh_73 <= 0xB4)
				cl_101 = (byte) cx_102 - 0x01;
		}
		*((char *) g_t40211C + ebx_130) = (Eq_121) cl_101;
		Eq_124 ebp_138 = g_t402120;
		*((char *) ebp_138 + ebx_130) = (Eq_124) (dh_105 + 0x80);
		word16 ebp_16_16_338 = SLICE(ebp_138, word16, 16);
		bl_313 = (byte) bx_140 + 0x01;
		bh_320 = SLICE(bx_140 + 0x01, byte, 8);
	} while (bx_140 != ~0x00);
	ptr32 edi_144 = 0x0003E800;
	word16 si_145;
	for (si_145 = ~0x63; si_145 != 100; ++si_145)
	{
		word32 ebp_149 = SEQ(ebp_16_16_338, ~0x9F);
		do
		{
			int32 dx_ax_159 = (int32) (int16) (g_t40213C.u0 << 0x01);
			bi8 al_164 = ((byte) dx_ax_159 & 0x7F) - 0x40;
			int16 ax_165 = al_164 *s16 al_164;
			bui8 al_169 = (byte) ax_165;
			ui16 ax_170 = SEQ(SLICE(ax_165, byte, 8) - 0x10, al_169);
			ui16 dx_171 = SLICE(dx_ax_159, word16, 16) ^ ax_170;
			word16 bp_346 = (word16) ebp_149;
			word16 cx_154 = 0x7F40;
			word16 di_181 = SEQ(SLICE(ax_170 * 0x02, byte, 8) - 0x01, al_169 * 0x02);
			word16 dx_185 = SEQ(SLICE(dx_171, byte, 8) + 0x24, (byte) dx_171);
			do
			{
				cx_154 += bp_346;
				di_181 -= 0xA0;
				char (* ebx_201)[] = SEQ(0x00, SLICE(di_181, byte, 8), SLICE(cx_154, byte, 8));
				dx_185 += si_145;
				byte ah_202 = Mem197[ebx_201 + Mem197[0x0040211C<p32>:word32]:byte];
				byte al_204 = Mem197[ebx_201 + Mem197[0x00402120<p32>:word32]:byte];
				char dh_212 = SLICE(dx_185, byte, 8);
				ui32 eax_228 = SEQ(eax_16_16_230, ah_202, al_204);
				if (ah_202 < 0x00)
					break;
				word16 ax_233 = SEQ(ah_202, al_204);
				if (ah_202 != 0x00)
				{
					if (dh_212 < ah_202)
						continue;
					ax_233 = SEQ(ah_202, al_204);
					if (dh_212 >= ah_202)
						ax_233 = SEQ(ah_202, al_204 + ah_202);
				}
				eax_228 = SEQ(eax_16_16_230, ax_233);
			} while (dh_212 <= 0x46);
			word32 eax_241 = g_t402104.u0[(eax_228 & 0xFF) * 0x04];
			*((char *) g_t402100.u0 + edi_144) = eax_241;
			word16 bp_246 = (word16) ebp_149;
			ebp_16_16_338 = SLICE(ebp_149, word16, 16);
			eax_16_16_230 = SLICE(eax_241, word16, 16);
			edi_144 -= 0x04;
			ebp_149 = SEQ(ebp_16_16_338, bp_246 + 0x01);
		} while (bp_246 != 0x9F);
	}
	GetClientRect(g_t4020CC, &g_t4020F0);
	StretchDIBits(g_t4020D0, 0x00, 0x00, g_dw4020F8, g_dw4020FC, 0x00, 0x00, 0x0140, 200, g_t402100.u0, &g_t40206C, 0x00, 0x00CC0020);
}

// 004011C5: Register Eq_299 Win32CrtStartup()
Eq_299 Win32CrtStartup()
{
	Eq_2 eax_8 = GlobalAlloc(0x00, 1000000);
	if (eax_8 != 0x00)
	{
		g_t40210C.u0 = (struct Eq_513 *) eax_8;
		g_t402104.u0 = (struct Eq_513 *) eax_8;
		g_t402100.u0 = (word32) eax_8 + 2000;
		g_t40211C = (Eq_121) ((word32) eax_8 + 402000);
		g_t402120 = (Eq_124) ((word32) eax_8 + 602000);
		g_t4020B4.u0 = (HINSTANCE) GetModuleHandleW(null);
		g_t4020B8 = LoadIconW(0x00, (WCHAR *) 0x7F00);
		Eq_370 eax_38 = LoadCursorW(0x00, (WCHAR *) 0x7F00);
		g_t4020BC = eax_38;
		if (SEQ(SLICE(eax_38, word16, 16), RegisterClassW(&g_t4020A4)) != 0x00)
		{
			Eq_279 eax_76 = CreateWindowExW(0x00, &g_t402000, &g_t402012, 0x10CF0000, 0x8000, 0x8000, 0x021C, 400, null, null, g_t4020B4.u0, null);
			if (eax_76 != null)
			{
				g_t4020CC = eax_76;
				g_t4020D0 = GetDC(eax_76);
				fn00401000();
				fn00401020();
				SetStretchBltMode(g_t4020D0, 0x04);
				while (true)
				{
					PeekMessageW(&g_t4020D4, null, 0x00, 0x00, 0x01);
					if (g_dw4020D8 == 0x12)
						break;
					TranslateMessage(&g_t4020D4);
					DispatchMessageW(&g_t4020D4);
					fn00401020();
					++g_dw402108;
				}
l004012FA:
				ReleaseDC(g_t4020CC, g_t4020D0);
				GlobalFree(g_t40210C.u0);
				ExitProcess(g_t4020DC);
			}
		}
	}
	MessageBoxW(null, &g_t40204C, null, 0x10);
	goto l004012FA;
}

LRESULT g_t401324(HWND tArg04, UINT tArg08, WPARAM tArg0C, LPARAM tArg10) = ??/* Unexpected function type (fn LRESULT (HWND, UINT, WPARAM, LPARAM)) */ ; // 00401324
