// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100(Register byte bh, Register wchar_t si)
void fn0C00_0100(byte bh, wchar_t si)
{
	__syscall<byte>(0x10);
	cup16 bx_114 = SEQ(bh, 0x05);
	do
	{
		byte Eq_14::* di_11 = Eq_14::a0000;
		word16 cx_15;
		for (cx_15 = 0xFA00; cx_15 != 0x00; --cx_15)
		{
			word16 dx_19;
			int16 ax_17 = fn0C00_0168(di_11, out dx_19);
			wchar_t dx_25 = dx_19 + ax_17 *s ax_17;
			byte al_26 = 0x00;
			if (dx_25 >= si)
			{
				al_26 = 0x09;
				if (dx_25 >= 2500)
				{
					cup16 dx_35;
					int16 ax_33 = fn0C00_0168(di_11, out dx_35);
					al_26 = 0x0F;
					if ((word16) ((ax_33 + 0x46) *s (ax_33 + 0x46)) + dx_35 >= 14641)
						al_26 = 0x0C;
				}
			}
			0xA000->*di_11 = al_26;
			++di_11;
		}
		si += bx_114;
		if (si <= 0x01 || si >= 0x0960)
			bx_114 = -bx_114;
	} while (__in<byte>(0x60) != 0x01);
	word16 cx_107 = 100;
	do
	{
		memcpy(A000:0000, A000:0280, 0xFA00);
		cx_107 = cx_143 - 0x01;
		cx_143 = cx_107;
	} while (cx_143 != 0x01);
}

// 0C00:0168: Register Eq_88 fn0C00_0168(Register (memptr (ptr16 Eq_14) byte) di, Register out Eq_36 dxOut)
// Called from:
//      fn0C00_0100
Eq_88 fn0C00_0168(byte Eq_14::* di, union Eq_36 & dxOut)
{
	uint32 dx_ax_8 = (uint32) di;
	Eq_91 ax_11 = (uint16) (dx_ax_8 /u 0x0140);
	Eq_95 dx_10 = (uint16) (dx_ax_8 % 0x0140);
	Eq_88 ax_13 = ax_11 - 100;
	if (ax_11 < 100)
		ax_13 = 100 - ax_11;
	dxOut = (dx_10 - 0xA0) *s (dx_10 - 0xA0);
	return ax_13;
}

