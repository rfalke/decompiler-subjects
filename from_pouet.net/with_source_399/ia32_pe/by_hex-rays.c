/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// char __usercall sub_401000@<al>(int a1@<eax>, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7);
// float *__usercall sub_4011E0@<eax>(float *result@<eax>, int a2, int a3, float a4, float a5, float a6, float a7);
// int __usercall sub_401600@<eax>(int result@<eax>, int a2@<ebx>, int a3, float a4, float a5, float a6);
int __cdecl sub_401680(int, int, float, float, float); // idb
// void __usercall sub_4018C0(int a1@<eax>, float a2);
char sub_4019E0();
float *__cdecl sub_401A40(int *a1);
// _BYTE *__usercall sub_401AF0@<eax>(int *a1@<eax>);
// int __usercall sub_401B90@<eax>(int *a1@<edi>, int a2, int a3, int a4);
int *sub_401D00();
// _DWORD *__usercall sub_401E50@<eax>(int a1@<eax>);
// void *__usercall sub_402010@<eax>(unsigned __int8 a1@<al>, _DWORD *a2@<edi>, void *a3, int a4);
// char __usercall sub_402070@<al>(int a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3, int a4);
// _BYTE *__usercall sub_4020E0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<edi>, char a4, int a5, size_t Size);
// int __usercall sub_402150@<eax>(int *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4);
int __fastcall sub_402230(char **a1, int a2);
// int __usercall sub_4022A0@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_4022C0(int a1);
_DWORD *sub_402340();
int nullsub_1(); // weak
int __cdecl sub_4023D0(int, int, char *FileName); // idb
int sub_402780();
int sub_4028A0();
int __cdecl sub_402900(int a1);
// int __usercall sub_402A40@<eax>(char *a1@<ecx>, int a2@<esi>);
_DWORD *sub_402AA0();
// int __usercall sub_402B70@<eax>(size_t *a1@<eax>, _DWORD *a2);
int sub_402E00();
// int *__usercall sub_403040@<eax>(int *result@<eax>, int a2, int a3, int a4, int a5, float a6);
// _DWORD *__usercall sub_403190@<eax>(_DWORD *a1@<eax>);
// int *__usercall sub_4032D0@<eax>(signed int *a1@<eax>, char **a2@<ecx>, int a3, int a4, int a5);
int __cdecl main(int argc, const char **argv, const char **envp);
int __cdecl sub_403A50(int, float, float); // idb
void *sub_403EF0();
int __cdecl sub_403FB0(size_t *a1);
_DWORD *sub_404080();
int __cdecl sub_4041E0(char *a1, int a2);
// int __usercall sub_4042F0@<eax>(int a1@<edx>, char **a2@<ecx>, int a3, int a4, int a5);
int sub_404A70();
_DWORD *__cdecl sub_404C90(float a1);
_BYTE *sub_404E40();
_DWORD *sub_404FD0();
_BYTE *__cdecl sub_405030(int a1, int a2);
// int __cdecl SDL_UpdateRect(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SDL_Init(_DWORD); weak
// int __cdecl SDL_SetVideoMode(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SDL_PollEvent(_DWORD); weak
// int __cdecl SDL_ShowCursor(_DWORD); weak
// int __cdecl SDL_LockSurface(_DWORD); weak
// int __cdecl SDL_UnlockSurface(_DWORD); weak
// int __cdecl SDL_SetColors(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SDL_Flip(_DWORD); weak
// int SDL_Quit(void); weak
int __cdecl sub_405120(int a1, int a2);
int __cdecl sub_405140(int *a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9);
int __cdecl sub_405270(int a1, int a2, _DWORD *a3, _DWORD *a4);
void **__cdecl sub_4052B0(char *a1, int a2, int a3, int a4, int a5, int (__cdecl *a6)(char *, size_t), int a7);
int __cdecl sub_405510(char *EndPtr, int); // idb
int (__cdecl *__cdecl sub_4064B0(int a1, void *a2, void *a3))(int, _DWORD, _DWORD);
int (__cdecl *__cdecl sub_4069C0(int a1, void **a2))(int, _DWORD, _DWORD);
void __cdecl sub_406A20(char *EndPtr, int a2);
void *__cdecl sub_407890(void *a1, int a2, int a3);
void **__cdecl sub_407B20(char *a1, int a2, int a3, int a4);
void __cdecl sub_407B50(_DWORD **a1, void **a2, void **a3);
// int __usercall sub_407C10@<eax>(int a1@<eax>, int a2, int a3);
int __cdecl sub_407C40(int a1, unsigned int a2, unsigned int a3);
void *__cdecl sub_407D70(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_407DC0(int, void *Block); // idb
int __cdecl sub_407DD0(int a1);
void __cdecl sub_407DF0(int a1, _BYTE *a2, unsigned int a3);
void *__cdecl sub_407E40(int *a1, unsigned int a2);
void __cdecl png_free_data(int a1, int a2, int a3, int a4);
void *__cdecl sub_408230(int a1, int a2);
int __cdecl sub_408290(int a1, int a2);
int __cdecl sub_4082A0(int a1, const void *a2);
int __cdecl sub_408390(int a1);
void *__cdecl sub_4083B0(void *a1);
// char *__usercall sub_4083F0@<eax>(int a1@<eax>, const char *a2@<edx>, int a3);
void __cdecl __noreturn sub_408490(int *a1, char *a2);
int __cdecl sub_4085C0(const char *a1);
_DWORD *__cdecl sub_408720(_DWORD *a1, int a2, int a3, int a4);
void __cdecl __noreturn sub_408740(int *a1, char *a2);
int __cdecl sub_4087F0(int a1, _BYTE *a2);
void __cdecl __noreturn sub_408850(int *a1, const char *a2);
int __cdecl sub_408880(int a1, const char *a2);
int __cdecl sub_4088C0(int *a1);
size_t __cdecl sub_4088E0(int a1, void *Buffer, size_t ElementCount);
int __cdecl sub_408920(_DWORD *a1, int a2, int a3);
void *__cdecl sub_408980(int a1, int (__cdecl *a2)(char *, size_t), int a3);
void __cdecl sub_408A30(void *Block, int a2, int a3);
void *__cdecl sub_408AB0(int a1, size_t Size);
void *__cdecl sub_408AF0(int a1, void *a2, void *Src, size_t Size);
void *__cdecl sub_408B10(int a1, void *a2, int Val, size_t Size);
_DWORD *__cdecl sub_408B30(_DWORD *a1, int a2, int a3, int a4);
// void __cdecl __noreturn exit_1(int Code);
void *__cdecl sub_408BA0(int a1, size_t Size);
void __cdecl sub_408BF0(int a1, void *Block);
void *__cdecl sub_408C20(int a1, size_t Size);
int __cdecl png_get_uint_32(unsigned __int8 *a1);
__int16 __cdecl sub_408C80(unsigned __int8 *a1);
void __cdecl png_crc_read(struct png_struct_def *, unsigned __int8 *, unsigned int); // idb
BOOL __cdecl png_crc_error(struct png_struct_def *a1);
char *__cdecl sub_408D40(int a1, int a2, char *a3, int a4, size_t a5, size_t *a6);
unsigned __int8 __cdecl sub_4090D0(int *a1, unsigned __int8 *a2);
int __cdecl sub_409130(int, void *, int); // idb
unsigned int __cdecl sub_409430(unsigned int a1);
char __cdecl sub_409860(int a1, int a2, _BYTE *a3, _BYTE *a4, int a5);
void *__cdecl sub_409A60(int a1);
unsigned int __cdecl sub_409D20(int *a1, unsigned __int8 *a2);
int __cdecl png_crc_finish(struct png_struct_def *, unsigned int); // idb
void __cdecl sub_409E10(int a1, int a2, int a3);
void __cdecl sub_409F90(int a1, int a2, signed int a3);
int __cdecl sub_40A120(int *a1, int a2, unsigned int a3);
void __cdecl sub_40A170(int *a1, int a2, unsigned int a3);
void __cdecl sub_40A2E0(int a1, int a2, unsigned int a3);
int __cdecl sub_40A450(int *a1, int a2, unsigned int a3);
void __cdecl sub_40A940(int *a1, int a2, unsigned int a3);
void __cdecl sub_40AB30(int *a1, int a2, unsigned int a3);
void __cdecl sub_40ACE0(int *a1, int a2, unsigned int a3);
void __cdecl sub_40AF00(int a1, int a2, unsigned int a3);
void __cdecl png_handle_bKGD(struct png_struct_def *, struct png_info_struct *, unsigned int); // idb
void __cdecl sub_40B390(int a1, int a2, unsigned int a3);
void __cdecl sub_40B530(int *a1, int a2, unsigned int a3);
void __cdecl sub_40B650(int *a1, int a2, unsigned int a3);
void __cdecl sub_40B780(int *a1, int a2, unsigned int a3);
void __cdecl sub_40B9E0(char *EndPtr, int a2, int a3);
void __cdecl sub_40BBA0(int a1, _DWORD *a2, unsigned int a3);
void __cdecl sub_40BCC0(int a1, _DWORD *a2, unsigned int a3);
void __cdecl sub_40BDE0(int a1, _DWORD *a2, int a3);
int __cdecl sub_40BF40(int, int, size_t Size); // idb
unsigned int __cdecl sub_40C120(int a1);
char __cdecl sub_40C430(int *a1, int a2);
void __cdecl sub_40C570(int *a1, _BYTE *a2, unsigned __int8 *a3);
void __cdecl sub_40C750(int a1, _BYTE *a2);
_BYTE *__cdecl sub_40C7A0(int *a1, int a2);
_BYTE *__cdecl sub_40C920(int *a1, int a2);
char __cdecl sub_40CA00(int a1, int a2, unsigned int a3, char a4);
void __cdecl sub_40CD20(int *a1, int a2);
int __cdecl sub_40CEE0(int a1, int *a2, unsigned __int8 *a3);
char __cdecl sub_40D5E0(int *a1, unsigned __int8 *a2, _WORD *a3, _BYTE *a4, _WORD *a5, int a6, int a7, int a8, int a9, int a10, int a11, __int16 a12);
char __cdecl sub_40E5E0(int *a1, unsigned __int8 *a2, int a3, int a4, char a5);
void __cdecl sub_40E9A0(int *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_40EBF0(int *a1, int a2, _WORD *a3);
char __cdecl sub_40EFF0(int *a1, char *a2, int a3, int a4);
void __cdecl sub_40F160(int a1);
char __cdecl sub_40F880(int *a1, int a2);
void __cdecl sub_40F950(int a1);
void __cdecl sub_410530(int a1);
int __cdecl sub_4109D0(int a1);
char __cdecl sub_4109F0(int a1, _BYTE *a2);
void __cdecl sub_410A80(int a1, char *a2);
_BYTE *__cdecl sub_410AC0(int a1, _BYTE *a2);
int __cdecl sub_410B20(int a1, _BYTE *a2, int a3);
char __cdecl sub_410DD0(int *a1, char *a2);
void __cdecl sub_410EC0(int a1, int a2, int a3);
void __cdecl png_set_cHRM(int a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
int __cdecl sub_411230(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void __cdecl sub_411420(int a1, int a2, double a3);
void __cdecl sub_4114A0(int a1, int a2, int a3);
void __cdecl sub_411520(int a1, int a2, int a3);
void __cdecl png_set_IHDR(jmp_buf Buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
void __cdecl sub_411810(int a1, int a2, int a3, int a4, char a5);
void __cdecl sub_411840(int a1, int a2, void *Src, int a4, int a5, char a6, int a7, void *a8, int a9);
void __cdecl sub_4119E0(int a1, int a2, char a3, double a4, double a5);
void __cdecl sub_411A20(int a1, int a2, int a3, int a4, char a5);
void __cdecl sub_411A50(int a1, int a2, void *Src, int a4);
void __cdecl sub_411AE0(int a1, int a2, int a3);
void __cdecl sub_411B10(int a1, int a2, char a3);
void __cdecl sub_411B30(int a1, int a2, char a3);
void __cdecl sub_411C10(int a1, int a2, int a3, char a4, void *Src, size_t Size);
int __cdecl sub_411D10(int a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_411F00(int a1, _DWORD *a2, _DWORD *a3);
void __cdecl sub_411F30(int a1, int a2, void *Src, size_t Size, int a5);
int __cdecl sub_411FC0(int a1, int a2, int a3, int a4);
void __cdecl sub_412100(int a1, int a2, int a3, int a4);
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// int __cdecl setjmp3(_DWORD, _DWORD); weak
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
void *sub_412787();
void __cdecl sub_4127AB(); // idb
int __cdecl UserMathErrorFunction();
// int _get_sse2_info(void); weak
int sub_412AB8();
int __cdecl inflateReset(_DWORD *a1);
int __cdecl sub_412B50(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_412C20(_DWORD *a1, _BYTE *a2, int a3);
// _DWORD *__usercall sub_412C40@<eax>(_DWORD *result@<eax>);
// int __usercall sub_412C60@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl inflate(int a1, int a2);
int __cdecl inflateEnd(_DWORD *a1);
int __cdecl sub_414630(int a1, _BYTE *a2, unsigned int a3);
void *__cdecl sub_414650(int a1, int a2, int a3);
void __cdecl sub_414670(int a1, void *Block);
_DWORD *__cdecl inflate_fast(_DWORD *a1, int a2);
int __cdecl inflate_table(int a1, int a2, unsigned int a3, _DWORD **a4, unsigned int *a5, _WORD *a6);
unsigned int __cdecl adler32(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
// void *__cdecl malloc(size_t Size);
// FILE *__cdecl _iob_func();
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// int __cdecl fclose(FILE *Stream);
// void __cdecl free(void *Block);
// int __cdecl rand();
// int printf(const char *const Format, ...);
// void __cdecl __noreturn exit(int Code);
// void __cdecl __noreturn abort();
// int sprintf(char *const Buffer, const char *const Format, ...);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// double __cdecl strtod(const char *String, char **EndPtr);
// DWORD __stdcall timeGetTime();
// int MikMod_RegisterAllLoaders(void); weak
// int MikMod_Update(void); weak
// int __cdecl Player_Start(_DWORD); weak
// int __cdecl MikMod_Init(_DWORD); weak
// int MikMod_Exit(void); weak
// int __cdecl Player_SetVolume(_DWORD); weak
// int MikMod_RegisterAllDrivers(void); weak
// int __cdecl Player_Load(_DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN md_reverb; weak
// extern _UNKNOWN md_mode; weak
char a128_0[6] = "1.2.8"; // weak
int dword_4164B4[7] = { 0, 4, 0, 2, 0, 1, 0 }; // idb
int dword_4164D0[7] = { 8, 8, 4, 4, 2, 2, 1 }; // idb
int dword_4164EC[7] = { 0, 0, 4, 0, 2, 0, 1 }; // idb
int dword_416508[7] = { 8, 8, 8, 4, 4, 2, 2 }; // idb
int dword_416524[7] = { 128, 8, 136, 34, 170, 85, 255 }; // idb
const int dword_416540 = 255; // idb
char byte_4165D4[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F'
}; // idb
_UNKNOWN unk_417B70; // weak
_UNKNOWN unk_418370; // weak
__int16 word_4183F0[20] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15, 0 }; // idb
int dword_4185D8[256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // idb
int dword_4189D8[256] =
{
  0,
  421212481,
  842424962,
  724390851,
  1684849924,
  2105013317,
  1448781702,
  1329698503,
  -925267448,
  -775767223,
  -84940662,
  -470492725,
  -1397403892,
  -1246855603,
  -1635570290,
  -2020074289,
  1254232657,
  1406739216,
  2029285587,
  1643069842,
  783210325,
  934667796,
  479770071,
  92505238,
  -2112120743,
  -1694455528,
  -1339163941,
  -1456026726,
  -428384931,
  -9671652,
  -733921313,
  -849736034,
  -1786501982,
  -1935731229,
  -1481488864,
  -1096190111,
  -236396122,
  -386674457,
  -1008827612,
  -624577947,
  1566420650,
  1145479147,
  1869335592,
  1987116393,
  959540142,
  539646703,
  185010476,
  303839341,
  -549046541,
  -966981710,
  -311405455,
  -194288336,
  -1154812937,
  -1573797194,
  -1994616459,
  -1878548428,
  396344571,
  243568058,
  631889529,
  1018359608,
  1945336319,
  1793607870,
  1103436669,
  1490954812,
  -260485371,
  -379421116,
  -1034998393,
  -615244602,
  -1810527743,
  -1928414400,
  -1507596157,
  -1086793278,
  950060301,
  565965900,
  177645455,
  328046286,
  1556873225,
  1171730760,
  1861902987,
  2011255754,
  -1162125996,
  -1549767659,
  -2004009002,
  -1852436841,
  -556296112,
  -942888687,
  -320734510,
  -168113261,
  1919080284,
  1803150877,
  1079293406,
  1498383519,
  370020952,
  253043481,
  607678682,
  1025720731,
  1711106983,
  2095471334,
  1472923941,
  1322268772,
  26324643,
  411738082,
  866634785,
  717028704,
  -1390091857,
  -1270886162,
  -1626176723,
  -2046184852,
  -918018901,
  -799861270,
  -75610583,
  -496666776,
  792689142,
  908347575,
  487136116,
  68299317,
  1263779058,
  1380486579,
  2036719216,
  1618931505,
  -404294658,
  -16923969,
  -707751556,
  -859070403,
  -2088093958,
  -1701771333,
  -1313057672,
  -1465424583,
  998479947,
  580430090,
  162921161,
  279890824,
  1609522511,
  1190423566,
  1842954189,
  1958874764,
  -212200893,
  -364829950,
  -1049857855,
  -663273088,
  -1758013625,
  -1909594618,
  -1526680123,
  -1139047292,
  1900120602,
  1750776667,
  1131931800,
  1517083097,
  355290910,
  204897887,
  656092572,
  1040194781,
  -1181220846,
  -1602014893,
  -1951505776,
  -1833610287,
  -571161322,
  -990907305,
  -272455788,
  -153512235,
  -1375224599,
  -1222865496,
  -1674453397,
  -2060783830,
  -898926099,
  -747616084,
  -128115857,
  -515495378,
  1725839073,
  2143618976,
  1424512099,
  1307796770,
  45282277,
  464110244,
  813994343,
  698327078,
  -456806728,
  -35741703,
  -688665542,
  -806814341,
  -2136380484,
  -1716364547,
  -1298200258,
  -1417398145,
  740041904,
  889656817,
  506086962,
  120682355,
  1215357364,
  1366020341,
  2051441462,
  1667084919,
  -872753330,
  -756947441,
  -104024628,
  -522746739,
  -1349119414,
  -1232264437,
  -1650429752,
  -2068102775,
  52649286,
  439905287,
  823476164,
  672009861,
  1733269570,
  2119477507,
  1434057408,
  1281543041,
  -2126985953,
  -1742474146,
  -1290885219,
  -1441425700,
  -447479781,
  -61918886,
  -681418087,
  -830909480,
  1239502615,
  1358593622,
  2077699477,
  1657543892,
  764250643,
  882293586,
  532408465,
  111204816,
  1585378284,
  1197851309,
  1816695150,
  1968414767,
  974272232,
  587794345,
  136598634,
  289367339,
  -1767409180,
  -1883486043,
  -1533994138,
  -1115018713,
  -221528864,
  -338653791,
  -1057104286,
  -639176925,
  347922877,
  229101820,
  646611775,
  1066513022,
  1892689081,
  1774917112,
  1122387515,
  1543337850,
  -597333067,
  -981574924,
  -296548041,
  -146261898,
  -1207325007,
  -1592614928,
  -1975530445,
  -1826292366
}; // idb
int dword_418DD8[256] =
{
  0,
  29518391,
  59036782,
  38190681,
  118073564,
  114017003,
  76381362,
  89069189,
  236147128,
  265370511,
  228034006,
  206958561,
  152762724,
  148411219,
  178138378,
  190596925,
  472294256,
  501532999,
  530741022,
  509615401,
  456068012,
  451764635,
  413917122,
  426358261,
  305525448,
  334993663,
  296822438,
  275991697,
  356276756,
  352202787,
  381193850,
  393929805,
  944588512,
  965684439,
  1003065998,
  973863097,
  1061482044,
  1049003019,
  1019230802,
  1023561829,
  912136024,
  933002607,
  903529270,
  874031361,
  827834244,
  815125939,
  852716522,
  856752605,
  611050896,
  631869351,
  669987326,
  640506825,
  593644876,
  580921211,
  551983394,
  556069653,
  712553512,
  733666847,
  704405574,
  675154545,
  762387700,
  749958851,
  787859610,
  792175277,
  1889177024,
  1901651959,
  1931368878,
  1927033753,
  2006131996,
  1985040171,
  1947726194,
  1976933189,
  2122964088,
  2135668303,
  2098006038,
  2093965857,
  2038461604,
  2017599123,
  2047123658,
  2076625661,
  1824272048,
  1836991623,
  1866005214,
  1861914857,
  1807058540,
  1786244187,
  1748062722,
  1777547317,
  1655668488,
  1668093247,
  1630251878,
  1625932113,
  1705433044,
  1684323811,
  1713505210,
  1742760333,
  1222101792,
  1226154263,
  1263738702,
  1251046777,
  1339974652,
  1310460363,
  1281013650,
  1301863845,
  1187289752,
  1191637167,
  1161842422,
  1149379777,
  1103966788,
  1074747507,
  1112139306,
  1133218845,
  1425107024,
  1429406311,
  1467333694,
  1454888457,
  1408811148,
  1379576507,
  1350309090,
  1371438805,
  1524775400,
  1528845279,
  1499917702,
  1487177649,
  1575719220,
  1546255107,
  1584350554,
  1605185389,
  -516613248,
  -520654409,
  -491663378,
  -478960167,
  -432229540,
  -402728597,
  -440899790,
  -461763323,
  -282703304,
  -287039473,
  -324886954,
  -312413087,
  -399514908,
  -370308909,
  -341100918,
  -362193731,
  -49039120,
  -53357881,
  -23630690,
  -11204951,
  -98955220,
  -69699045,
  -107035582,
  -128143755,
  -218044088,
  -222133377,
  -259769050,
  -247048431,
  -200719980,
  -171234397,
  -141715974,
  -162529331,
  -646423200,
  -658884777,
  -620984050,
  -616635591,
  -562956868,
  -541876341,
  -571137582,
  -600355867,
  -680850216,
  -693541137,
  -722478922,
  -718425471,
  -798841852,
  -777990605,
  -739872662,
  -769385891,
  -983630320,
  -996371417,
  -958780802,
  -954711991,
  -1034463540,
  -1013629701,
  -1043103070,
  -1072568171,
  -884101208,
  -896547425,
  -926319674,
  -922021391,
  -867956876,
  -846828221,
  -809446630,
  -838682323,
  -1850763712,
  -1871840137,
  -1842658770,
  -1813436391,
  -1767489892,
  -1755032405,
  -1792873742,
  -1797226299,
  -1615017992,
  -1635865137,
  -1674046570,
  -1644529247,
  -1732939996,
  -1720253165,
  -1691239606,
  -1695297155,
  -1920387792,
  -1941217529,
  -1911692962,
  -1882223767,
  -1971282452,
  -1958545445,
  -1996207742,
  -2000280651,
  -2087033720,
  -2108158273,
  -2145472282,
  -2116232495,
  -2070688684,
  -2058246557,
  -2028529606,
  -2032831987,
  -1444753248,
  -1474250089,
  -1436154674,
  -1415287047,
  -1360299908,
  -1356262837,
  -1385190382,
  -1397897691,
  -1477345000,
  -1506546897,
  -1535814282,
  -1514717375,
  -1594349116,
  -1590017037,
  -1552089686,
  -1564567651,
  -1245416496,
  -1274668569,
  -1237276738,
  -1216164471,
  -1295131892,
  -1290817221,
  -1320611998,
  -1333041835,
  -1143528856,
  -1173010337,
  -1202457082,
  -1181639631,
  -1126266188,
  -1122180989,
  -1084596518,
  -1097321235
}; // idb
int dword_4191D8[1334] =
{
  0,
  -1195612315,
  -1442199413,
  313896942,
  -1889364137,
  937357362,
  627793884,
  -1646839623,
  -978048785,
  2097696650,
  1874714724,
  -687765759,
  1255587768,
  -227878691,
  -522225869,
  1482887254,
  1343838111,
  -391827206,
  -99573996,
  1118632049,
  -545537848,
  1741137837,
  1970407491,
  -842109146,
  -1783791760,
  756094997,
  1067759611,
  -2028416866,
  449832999,
  -1569484990,
  -1329192788,
  142231497,
  -1607291074,
  412010587,
  171665333,
  -1299775280,
  793786473,
  -1746116852,
  -2057703198,
  1038456711,
  1703315409,
  -583343948,
  -812691622,
  1999841343,
  -354152314,
  1381529571,
  1089329165,
  -128860312,
  -265553759,
  1217896388,
  1512189994,
  -492939441,
  2135519222,
  -940242797,
  -717183107,
  1845280792,
  899665998,
  -1927039189,
  -1617553211,
  657096608,
  -1157806311,
  37822588,
  284462994,
  -1471616777,
  -1693165507,
  598228824,
  824021174,
  -1985873965,
  343330666,
  -1396004849,
  -1098971167,
  113467524,
  1587572946,
  -434366537,
  -190203815,
  1276501820,
  -775755899,
  1769898208,
  2076913422,
  -1015592853,
  -888336478,
  1941006535,
  1627703081,
  -642211764,
  1148164341,
  -53215344,
  -295284610,
  1457141531,
  247015245,
  -1241169880,
  -1531908154,
  470583459,
  -2116308966,
  963106687,
  735213713,
  -1821499404,
  992409347,
  -2087022490,
  -1859174520,
  697522413,
  -1270587308,
  217581361,
  508405983,
  -1494102086,
  -23928852,
  1177467017,
  1419450215,
  -332959742,
  1911572667,
  -917753890,
  -604405712,
  1665525589,
  1799331996,
  -746338311,
  -1053399017,
  2039091058,
  -463652917,
  1558270126,
  1314193216,
  -152528859,
  -1366587277,
  372764438,
  75645176,
  -1136777315,
  568925988,
  -1722451903,
  -1948198993,
  861712586,
  -312887749,
  1441124702,
  1196457648,
  -1304107,
  1648042348,
  -628668919,
  -936187417,
  1888390786,
  686661332,
  -1873675855,
  -2098964897,
  978858298,
  -1483798141,
  523464422,
  226935048,
  -1254447507,
  -1119821404,
  100435649,
  390670639,
  -1342878134,
  841119475,
  -1969352298,
  -1741963656,
  546822429,
  2029308235,
  -1068978642,
  -755170880,
  1782671013,
  -141140452,
  1328167289,
  1570739863,
  -450629134,
  1298864389,
  -170426784,
  -412954226,
  1608431339,
  -1039561134,
  2058742071,
  1744848601,
  -792976964,
  -1998638614,
  811816591,
  584513889,
  -1704288764,
  129869501,
  -1090403880,
  -1380684234,
  352848211,
  494030490,
  -1513215489,
  -1216641519,
  264757620,
  -1844389427,
  715964072,
  941166918,
  -2136639965,
  -658086283,
  1618608400,
  1926213374,
  -898381413,
  1470427426,
  -283601337,
  -38979159,
  1158766284,
  1984818694,
  -823031453,
  -599513459,
  1693991400,
  -114329263,
  1100160564,
  1395044826,
  -342174017,
  -1275476247,
  189112716,
  435162722,
  -1588827897,
  1016811966,
  -2077804837,
  -1768777419,
  774831696,
  643086745,
  -1628905732,
  -1940033262,
  887166583,
  -1456066866,
  294275499,
  54519365,
  -1149009632,
  -471821962,
  1532818963,
  1240029693,
  -246071656,
  1820460577,
  -734109372,
  -963916118,
  2117577167,
  -696303304,
  1858283101,
  2088143283,
  -993333546,
  1495127663,
  -509497078,
  -216785180,
  1269332353,
  332098007,
  -1418260814,
  -1178427044,
  25085497,
  -1666580864,
  605395429,
  916469259,
  -1910746770,
  -2040129881,
  1054503362,
  745528876,
  -1798063799,
  151290352,
  -1313282411,
  -1559410309,
  464596510,
  1137851976,
  -76654291,
  -371460413,
  1365741990,
  -860837601,
  1946996346,
  1723425172,
  -570095887,
  0,
  -1775237257,
  744558318,
  -1169094247,
  432303367,
  -1879807376,
  900031465,
  -1550490466,
  847829774,
  -1531388807,
  518641120,
  -1998990697,
  726447625,
  -1115901570,
  120436967,
  -1860321392,
  1678817053,
  -232738710,
  1215412723,
  -566116732,
  2111101466,
  -337322643,
  1370871028,
  -947530877,
  1452829715,
  -1062704284,
  2063164157,
  -322345590,
  1331429652,
  -647231901,
  1664946170,
  -183695219,
  -937398725,
  1578133836,
  -465477419,
  1920034722,
  -773586116,
  1205077067,
  -41611822,
  1807026853,
  -89606859,
  1821946434,
  -691422245,
  1090108588,
  -479406030,
  1969020741,
  -821176612,
  1497223595,
  -1406084826,
  973135441,
  -2142119992,
  375509183,
  -1242254303,
  600093526,
  -1718240561,
  262520248,
  -1632107992,
  143131999,
  -1294398266,
  619252657,
  -2021888209,
  290220120,
  -1424137791,
  1026385590,
  -1874731914,
  108124929,
  -1138699624,
  705746415,
  -1987726991,
  532002310,
  -1511735393,
  869578984,
  -1563883656,
  888733711,
  -1901590122,
  412618465,
  -1156748673,
  759000328,
  -1754504047,
  22832102,
  -195990677,
  1650551836,
  -667916923,
  1308648178,
  -309000596,
  2074411291,
  -1040971646,
  1472466933,
  -958812059,
  1357494034,
  -356991349,
  2089335292,
  -551690910,
  1227741717,
  -209923188,
  1699534075,
  1482797645,
  -833505990,
  1946205347,
  -500122668,
  1101389642,
  -678045635,
  1841615268,
  -67840301,
  1793681731,
  -52859340,
  1183344557,
  -793222950,
  1932330052,
  -451083469,
  1598818986,
  -914616867,
  1014039888,
  -1438580185,
  269487038,
  -2044719927,
  632645719,
  -1283100896,
  164914873,
  -1612422706,
  251256414,
  -1731602135,
  580440240,
  -1264003129,
  389919577,
  -2129808338,
  995933623,
  -1385383232,
  545503469,
  -1229733990,
  216184323,
  -1697468044,
  961009130,
  -1351101795,
  354867972,
  -2095653773,
  302736355,
  -2076482412,
  1047162125,
  -1470469510,
  198119140,
  -1644230253,
  665714698,
  -1315043459,
  1150488560,
  -761067385,
  1760690462,
  -20838807,
  1566008055,
  -882416256,
  1899392025,
  -419009682,
  1981535486,
  -533998711,
  1518000656,
  -867508889,
  1876933113,
  -101728626,
  1136572183,
  -712069024,
  -391915818,
  2123616673,
  -993863624,
  1391648591,
  -244859951,
  1733803174,
  -586762945,
  1261875784,
  -634712616,
  1276840623,
  -162921674,
  1618609217,
  -1007722273,
  1440704424,
  -275878351,
  2042521926,
  -1934401077,
  444819132,
  -1596821723,
  920807506,
  -1787360052,
  54987707,
  -1189739998,
  791020885,
  -1103381819,
  671858098,
  -1839549397,
  74101596,
  -1476405310,
  835702965,
  -1952523988,
  497999451,
  -1329437541,
  653419500,
  -1667011979,
  177433858,
  -1459222116,
  1060507371,
  -2056845454,
  324468741,
  -2109030507,
  343587042,
  -1372868229,
  941340172,
  -1685138798,
  230610405,
  -1209017220,
  568318731,
  -724380794,
  1122161905,
  -122430104,
  1854134815,
  -854147455,
  1529264630,
  -512249745,
  2001188632,
  -430307192,
  1885999103,
  -902101402,
  1544225041,
  -6396529,
  1773036280,
  -738235551,
  1171221526,
  2028079776,
  -288223785,
  1417872462,
  -1028455623,
  1629906855,
  -149528368,
  1296525641,
  -612929986,
  1248514478,
  -598026535,
  1712054080,
  -264513481,
  1403960489,
  -979452962,
  2144318023,
  -369117904,
  485670333,
  -1966949686,
  814986067,
  -1499220956,
  87478458,
  -1828268083,
  693624404,
  -1083713245,
  779773619,
  -1203084860,
  35350621,
  -1809092822,
  935201716,
  -1584526141,
  467600730,
  -1913716179,
  0,
  1093737241,
  -2107492814,
  -1017959125,
  80047204,
  1173649277,
  -2035852714,
  -946454193,
  143317448,
  1237041873,
  -1964445702,
  -874908445,
  206550444,
  1300147893,
  -1909619810,
  -820209529,
  1360183882,
  270784851,
  -747572104,
  -1841172639,
  1440198190,
  350663991,
  -675964900,
  -1769700603,
  1503140738,
  413728923,
  -604361296,
  -1697958231,
  1566406630,
  476867839,
  -549502508,
  -1643226419,
  -1574665067,
  -485122164,
  541504167,
  1635232190,
  -1495144207,
  -405736472,
  612622019,
  1706214874,
  -1431413411,
  -341883324,
  684485487,
  1778217078,
  -1368706759,
  -279303648,
  738789131,
  1832393746,
  -214546721,
  -1308140090,
  1901359341,
  811953140,
  -135058757,
  -1228787294,
  1972444297,
  882902928,
  -71524585,
  -1165130738,
  2044635429,
  955232828,
  -8785037,
  -1102518166,
  2098971969,
  1009442392,
  89094640,
  1149133545,
  -2027073598,
  -971221797,
  25826708,
  1086000781,
  -2081938522,
  -1025951553,
  231055416,
  1291107105,
  -1884842486,
  -828994285,
  151047260,
  1211225925,
  -1956447634,
  -900472457,
  1415429050,
  359440547,
  -700478072,
  -1760651631,
  1352194014,
  296340679,
  -755310100,
  -1815348491,
  1557619314,
  501643627,
  -558541760,
  -1618718887,
  1477578262,
  421729551,
  -630179804,
  -1690229955,
  -1486095003,
  -430250372,
  621398871,
  1681444942,
  -1548840703,
  -492860904,
  567060275,
  1627241514,
  -1344199507,
  -288342092,
  763564703,
  1823607174,
  -1423685431,
  -367701040,
  692485883,
  1752655330,
  -159826129,
  -1220008906,
  1947928861,
  891949572,
  -222538933,
  -1282586542,
  1893623161,
  837779040,
  -17570073,
  -1077740034,
  2089930965,
  1033948108,
  -97088893,
  -1157131878,
  2018819249,
  962963368,
  1268286267,
  178886690,
  -906316535,
  -1999917552,
  1331556191,
  242021446,
  -851453587,
  -1945189772,
  1125276403,
  35865066,
  -1049596735,
  -2143193128,
  1205286551,
  115748238,
  -977993563,
  -2071716932,
  445268337,
  1539005032,
  -1729595581,
  -640062374,
  508505365,
  1602106892,
  -1674765529,
  -585367490,
  302028985,
  1395753888,
  -1872580981,
  -783043182,
  382072029,
  1475669956,
  -1800944913,
  -711534090,
  -373553234,
  -1467147081,
  1809723804,
  720317061,
  -310809654,
  -1404538669,
  1864064504,
  774522593,
  -516497818,
  -1610103425,
  1666508884,
  577106765,
  -437014014,
  -1530746597,
  1737589808,
  648060713,
  -1196505628,
  -106963203,
  986510294,
  2080237775,
  -1133794944,
  -44387687,
  1040818098,
  2134410411,
  -1339810772,
  -250280139,
  843459102,
  1937191175,
  -1260294072,
  -170890415,
  914572922,
  2008178019,
  1322777291,
  266789330,
  -860500743,
  -1920673824,
  1242732207,
  186879414,
  -932142947,
  -1992180860,
  1180508931,
  124532762,
  -1002498767,
  -2062676440,
  1117278055,
  61428862,
  -1057326763,
  -2117377460,
  533018753,
  1593058200,
  -1649996109,
  -594143830,
  453006565,
  1513181180,
  -1721605417,
  -665617970,
  391110985,
  1451162192,
  -1792157829,
  -736310174,
  327847213,
  1388025396,
  -1847018721,
  -791044090,
  -319586722,
  -1379769017,
  1855015020,
  799036277,
  -399109574,
  -1459156701,
  1783899144,
  728055569,
  -461789290,
  -1521959793,
  1713082788,
  657099453,
  -524497934,
  -1584541461,
  1658781120,
  602924761,
  -1109279724,
  -53434611,
  1065585190,
  2125631807,
  -1188769680,
  -132789399,
  994502210,
  2054683995,
  -1251252772,
  -195395899,
  923358190,
  1983400183,
  -1313994312,
  -258010463,
  869023626,
  1929192595,
  0,
  929743361,
  1859421187,
  1505641986,
  -592967417,
  -339555578,
  -1300460284,
  -2062135547,
  -1202646258,
  -1891905265,
  -695888115,
  -504408820,
  1694046729,
  1402198024,
  170761738,
  1028086795,
  1889740316,
  1204413469,
  511156767,
  689791006,
  -1408553189,
  -1688081126,
  -1025529064,
  -172660455,
  -923650798,
  -6752493,
  -1507413743,
  -1857260784,
  341457941,
  590413332,
  2056173590,
  1306819095,
  -532263624,
  -684945607,
  -1902982853,
  -1174926534,
  1022247999,
  193234494,
  1379582012,
  1699742269,
  1477926454,
  1870502967,
  918805045,
  27858996,
  -2067835087,
  -1277848272,
  -362032334,
  -587132621,
  -1864013020,
  -1483757275,
  -30281945,
  -916771546,
  1280139811,
  2066194466,
  580511264,
  368256033,
  682915882,
  534690347,
  1180761129,
  1896496680,
  -199462611,
  -1015631060,
  -1698106066,
  -1381877969,
  -1064461712,
  -135833487,
  -1369891213,
  -1724654478,
  472224631,
  726618486,
  1928402804,
  1167840629,
  2027719038,
  1337346943,
  369626493,
  560123772,
  -1535868807,
  -1826733448,
  -895482758,
  -37042565,
  -1339114388,
  -2025554323,
  -554026897,
  -376374674,
  1820767595,
  1542223722,
  38941032,
  892924777,
  142585698,
  1058368867,
  1722493793,
  1371662688,
  -724064667,
  -474127260,
  -1174199706,
  -1922441113,
  550229832,
  396432713,
  1310675787,
  2037748042,
  -60563889,
  -888595378,
  -1833477556,
  -1512204211,
  -1734687674,
  -1343224249,
  -162643899,
  -1054571964,
  1144180033,
  1935150912,
  719735106,
  495749955,
  1349054804,
  1728197461,
  1052538199,
  165066582,
  -1933510573,
  -1146471854,
  -501973936,
  -713114031,
  -398859686,
  -548200357,
  -2031262119,
  -1316510632,
  881978205,
  66791772,
  1514499934,
  1831841119,
  -2145700383,
  -1217267744,
  -288378398,
  -643468317,
  1555250406,
  1809448679,
  845658341,
  84769508,
  944383727,
  253813998,
  1453236972,
  1643405549,
  -454938648,
  -746000919,
  -1976128533,
  -1118017046,
  -256371715,
  -942484996,
  -1637050370,
  -1459202561,
  739252986,
  461035771,
  1120182009,
  1974361336,
  1223229683,
  2139341554,
  641565936,
  290932465,
  -1807676940,
  -1557410827,
  -90862089,
  -838905866,
  1616738521,
  1463270104,
  243924186,
  971194075,
  -1124765218,
  -1952468001,
  -769526307,
  -448055332,
  -670274601,
  -278484522,
  -1227296812,
  -2119029291,
  77882064,
  869179601,
  1785784019,
  1561994450,
  285105861,
  664050884,
  2116737734,
  1228937415,
  -866756670,
  -79915581,
  -1568484415,
  -1779953216,
  -1464906293,
  -1614442550,
  -964965944,
  -250541111,
  1946633420,
  1131251405,
  450085071,
  767099598,
  1083617169,
  2013031824,
  776088466,
  422111635,
  -1673615722,
  -1420532585,
  -219536747,
  -981409644,
  -121127777,
  -810713442,
  -1777125220,
  -1585841507,
  611300760,
  319125401,
  1253781915,
  2110911386,
  808814989,
  123685772,
  1591807374,
  1770770319,
  -325222262,
  -604552565,
  -2109143927,
  -1255946616,
  -2006672765,
  -1089578878,
  -424665472,
  -774185855,
  1422693252,
  1671844229,
  974657415,
  225629574,
  -1596923223,
  -1749409624,
  -838572374,
  -110189397,
  2088299438,
  1259481519,
  313290669,
  633777580,
  411169191,
  803943334,
  1985312164,
  1094694821,
  -1003882336,
  -213697887,
  -1426228061,
  -1650999646,
  -797719371,
  -417790284,
  -1096335178,
  -1983020361,
  215731634,
  1001459635,
  1645169073,
  1432718256,
  1747113915,
  1598559674,
  116806584,
  832344505,
  -1265967428,
  -2082464579,
  -631350593,
  -315320130,
  0,
  1701297336,
  -1949824598,
  -290474734,
  1469538959,
  854646327,
  -597726427,
  -1187457123,
  -282544955,
  -1974531971,
  1692450159,
  25625047,
  -1195387318,
  -573019406,
  863494112,
  1443914584,
  -1621681840,
  -97475096,
  345968890,
  1912122434,
  -926909473,
  -1381513369,
  1124627061,
  644861645,
  1887415701,
  353898797,
  -71850945,
  -1630529401,
  669568794,
  1116697506,
  -1407138128,
  -918062584,
  1051669152,
  1539870232,
  -1251525878,
  -805271630,
  1765298223,
  207613079,
  -487564923,
  -2020088515,
  -779647387,
  -1260373283,
  1515163599,
  1059599223,
  -2045713174,
  -478717870,
  232320320,
  1757368824,
  -1577571344,
  -996174008,
  707797594,
  1331142370,
  -160478849,
  -1828129337,
  2108113109,
  415300717,
  1322295093,
  733422477,
  -988244321,
  -1602278873,
  424148410,
  2082488578,
  -1836059632,
  -135771992,
  1029182619,
  1480566819,
  -1232069327,
  -738745975,
  1791981076,
  262720172,
  -519602242,
  -2074033402,
  -764370850,
  -1223222042,
  1505274356,
  1021252940,
  -2048408879,
  -528449943,
  238013307,
  1799911363,
  -1576071733,
  -949440141,
  700908641,
  1285601497,
  -174559420,
  -1862282244,
  2119198446,
  456645206,
  1294448910,
  675284406,
  -957370204,
  -1551365092,
  447798145,
  2144823097,
  -1854352853,
  -199266669,
  66528827,
  1720752771,
  -2009124975,
  -312962263,
  1415595188,
  822605836,
  -542618338,
  -1160777306,
  -320892162,
  -1984418234,
  1729600340,
  40904684,
  -1152847759,
  -567325495,
  813758939,
  1441219939,
  -1667219605,
  -104365101,
  392705729,
  1913621113,
  -885563932,
  -1370431140,
  1090475086,
  630778102,
  1938328494,
  384775958,
  -129990140,
  -1658372420,
  606071073,
  1098405273,
  -1344806773,
  -894411725,
  1001806317,
  1590814037,
  -1333899193,
  -719721217,
  1814117218,
  155617242,
  -404147512,
  -2104586640,
  -727782104,
  -1309060720,
  1599530114,
  976312378,
  -2096525401,
  -428985569,
  146900493,
  1839610549,
  -1528741699,
  -1048118267,
  791234839,
  1246688687,
  -210361806,
  -1777230198,
  2025728920,
  500799264,
  1271526520,
  783173824,
  -1073611310,
  -1520025238,
  475961079,
  2033789519,
  -1751736483,
  -219077659,
  85551949,
  1618925557,
  -1898880281,
  -340337057,
  1385040322,
  938063226,
  -649723800,
  -1138639664,
  -365830264,
  -1890163920,
  1643763234,
  77490842,
  -1113146105,
  -658439745,
  913224877,
  1393100821,
  -1706135011,
  -14037339,
  294026167,
  1960953615,
  -841412462,
  -1463899094,
  1175525688,
  594978176,
  1969669848,
  268532320,
  -22098062,
  -1681296438,
  586261591,
  1201019119,
  -1455837699,
  -866250427,
  116280694,
  1669984718,
  -1926871844,
  -398329756,
  1366896633,
  874419009,
  -625924525,
  -1076454677,
  -372835917,
  -1935588085,
  1645146137,
  124341409,
  -1101948100,
  -617207932,
  899256982,
  1358835246,
  -1715907546,
  -52500322,
  309419404,
  1997988148,
  -835832151,
  -1421243887,
  1172717315,
  545358779,
  1989271779,
  334912603,
  -44439223,
  -1740745231,
  554074732,
  1147223764,
  -1429304378,
  -810993794,
  943816662,
  1562821486,
  -1282836868,
  -688993596,
  1876303193,
  179413473,
  -467790605,
  -2122733493,
  -680932589,
  -1307674709,
  1554105017,
  969309697,
  -2130794084,
  -442952412,
  188129334,
  1850809486,
  -1491704186,
  -1032725954,
  752774956,
  1236915092,
  -259980279,
  -1780041551,
  2068385187,
  506376475,
  1212076611,
  760835835,
  -1007232023,
  -1500420271,
  531214540,
  2060323956,
  -1805534874,
  -251263522,
  1868787305,
  1952542829,
  1701601897,
  1919252000,
  1852795251,
  0,
  1717990754,
  1696625253,
  1919906418,
  0,
  1970499177,
  1667851878,
  1953391977,
  1835363616,
  7959151,
  1635017060,
  1920099616,
  29295,
  1701999731,
  1696623969,
  1919906418,
  0,
  1701603686,
  1920099616,
  29295,
  1701999731,
  1696623969,
  25710,
  1684366702,
  1667851296,
  1852795252,
  7959137,
  4302408,
  4302396,
  4302902,
  4302384,
  4302368,
  4302356,
  4302336,
  4302320,
  4302296,
  4302902,
  1718511904,
  1702125932,
  841888032,
  1126183726,
  1920561263,
  1952999273,
  960049440,
  808594741,
  1293956400,
  543912545,
  1701602369,
  8306
}; // idb
_UNKNOWN unk_41A6B0; // weak
_UNKNOWN unk_41A6F0; // weak
_UNKNOWN unk_41A730; // weak
_UNKNOWN unk_41A770; // weak
_UNKNOWN unk_41A836; // weak
const char FileName[] = { 'c', 'h', 'i', 'p' }; // idb
_UNKNOWN unk_41AEF8; // weak
char aErrorDecodingC[31] = "Error decoding compressed text"; // weak
int dword_41C020[8] = { 16, 33, 66, 132, 272, 584, 1360, 4080 }; // idb
_UNKNOWN unk_41C040; // weak
_UNKNOWN unk_41C140; // weak
_UNKNOWN unk_41C240; // weak
int dword_41C364 = 1; // weak
int dword_41C368 = 1; // weak
int dword_41C36C = 1; // weak
int dword_41C370 = 1; // weak
int dword_41C374 = 16; // weak
int dword_41C378 = 64; // weak
int dword_41C37C = 64; // weak
int dword_41C380 = 16; // weak
int dword_41C384 = 64; // weak
int dword_41C388 = 64; // weak
int dword_41C38C = 16; // weak
int dword_41C390 = 64; // weak
int dword_41C394 = 64; // weak
int dword_41C398 = 64; // weak
int dword_41C39C = 64; // weak
float flt_41C3A0 =  50.0; // weak
float flt_41C3A4 =  130.0; // weak
float flt_41C3A8 =  560.0; // weak
float flt_41C3AC =  1.0; // weak
float flt_41C3B0 =  1.0; // weak
float flt_41C3B4 =  1.0; // weak
float flt_41C3B8 =  1.0; // weak
int dword_41C3BC = 1; // weak
_UNKNOWN unk_41C3C0; // weak
float flt_41CA14 =  2.0; // weak
float flt_41CA18 =  1500.0; // weak
int dword_41CA1C = 1; // weak
int dword_41CD78 = 0; // weak
float flt_41CE78 =  0.0; // weak
float flt_41CE7C =  0.0; // weak
int dword_41CE80 = 0; // weak
float flt_41CE84 =  0.0; // weak
float flt_41CE88 =  0.0; // weak
float flt_41CE8C =  0.0; // weak
int dword_41CE90 = 0; // weak
int dword_41CE94 = 0; // weak
int dword_41CE98 = 0; // weak
int dword_41CE9C = 0; // weak
int dword_41CEA0 = 0; // weak
float flt_41CEA4 =  0.0; // weak
int dword_41CEA8 = 0; // weak
float flt_41CEAC =  0.0; // weak
int dword_41CEB0 = 0; // weak
float flt_41CEB4 =  0.0; // weak
int dword_41CEB8 = 0; // weak
int dword_41CEBC = 0; // weak
int dword_41CEC0 = 0; // weak
float flt_41CEC4 =  0.0; // weak
int dword_41CEC8 = 0; // weak
int dword_41CECC = 0; // weak
char byte_41CF00[65536] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
char byte_42CF00[]; // weak
_UNKNOWN unk_42CF02; // weak
char byte_43CF00[320]; // idb
int dword_43D040; // weak
_UNKNOWN unk_43D064; // weak
_UNKNOWN unk_43E060; // weak
_UNKNOWN unk_43E560; // weak
char byte_44805F[]; // weak
_UNKNOWN unk_448060; // weak
_UNKNOWN unk_448062; // weak
float flt_45805C[]; // weak
int dword_458060[]; // weak
int dword_458064; // weak
int dword_458068; // weak
int dword_45806C[]; // weak
int dword_458070[]; // weak
int dword_458074[]; // weak
int dword_458078; // weak
int dword_45807C; // weak
int dword_458080; // weak
_UNKNOWN unk_4580A0; // weak
_UNKNOWN unk_4580A1; // weak
char byte_4581E9[26071]; // idb
_UNKNOWN unk_45E7C0; // weak
int dword_468270[]; // weak
int dword_468274; // weak
int dword_468278; // weak
int dword_46827C; // weak
_UNKNOWN unk_468280; // weak
char byte_4683C9[65671]; // idb
float flt_478450[]; // weak
int dword_478460; // weak
int dword_478470; // weak
int dword_478474; // weak
int dword_478478; // weak
int dword_47847C; // weak
char *dword_478480; // idb
int dword_478484; // weak
int dword_478488; // weak
int dword_47848C; // weak
size_t Size; // idb
int dword_4784A0; // weak
int dword_4784A4; // weak
int dword_4784A8; // weak
int dword_4784AC; // weak
int dword_4784B0; // weak
int dword_4784B4; // weak
int dword_4784B8; // weak
int dword_4784BC; // weak
int dword_4784C0; // weak
int dword_4784C4; // weak
int dword_4784D0; // weak
int dword_4784D4; // weak
int dword_4784D8; // weak
int dword_4784DC; // weak
int dword_4784E0; // weak
int dword_4784E4; // weak
int dword_4784E8; // weak
int dword_4784EC; // weak
_UNKNOWN unk_4784F0; // weak
int dword_4784F8; // weak
int dword_4784FC; // weak
int dword_478500; // weak
int dword_478504; // weak
int dword_478508; // weak
int dword_47850C; // weak
int dword_478510; // weak
int dword_478514; // weak
int dword_478518; // weak
int dword_47851C; // weak
char byte_478520[]; // weak
char byte_478521[]; // weak
char byte_478522[694]; // idb
char byte_4787D8; // weak
char byte_4787D9; // weak
char byte_4787DA; // weak
char byte_4787DE; // weak
char byte_4787DF; // weak
char byte_4787E0; // weak
char byte_4787E4; // weak
char byte_4787E5; // weak
char byte_4787E6; // weak
int dword_478820; // weak
int dword_478824; // weak
int dword_478828; // weak
int dword_47882C; // weak
int dword_478830; // weak
int dword_478834; // weak
int dword_478838; // weak
int dword_47883C; // weak
char byte_478840[]; // weak


//----- (00401000) --------------------------------------------------------
char __usercall sub_401000@<al>(int a1@<eax>, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7)
{
  int v7; // ecx
  int v8; // ebp
  int v9; // edi
  int v10; // esi
  int v11; // ecx
  int v12; // ebx
  int v13; // edi
  int v14; // ebx
  int v15; // edx
  _BYTE *v16; // ecx
  bool v17; // zf
  int v18; // ebx
  unsigned __int8 v19; // dl
  int v20; // edi
  int v21; // ebx
  int v22; // ebp
  int v23; // esi
  int v24; // edx
  _BYTE *v25; // edx
  int v27; // [esp+10h] [ebp-8h]
  int v28; // [esp+14h] [ebp-4h]
  unsigned __int8 v29; // [esp+1Ch] [ebp+4h]
  int v30; // [esp+1Ch] [ebp+4h]
  unsigned __int8 v31; // [esp+1Ch] [ebp+4h]
  int v32; // [esp+1Ch] [ebp+4h]

  v7 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)a1;
  v9 = *(_DWORD *)(a1 + 12);
  if ( a2 >= 0 )
  {
    LOBYTE(a1) = a4;
    if ( a4 >= 0 && a3 >= 0 && a5 >= 0 && a2 < v8 && a4 < v8 && a3 < v7 && a5 < v7 )
    {
      v10 = a5 - a3;
      v11 = a4 - a2;
      if ( (int)abs32(a5 - a3) <= (int)abs32(a4 - a2) )
      {
        a1 = a2;
        if ( a4 >= a2 )
        {
          v19 = a6;
          v18 = a3;
        }
        else
        {
          v18 = a5;
          a1 = a4;
          v31 = a7;
          v11 = -v11;
          a7 = a6;
          v19 = v31;
          v10 = a3 - a5;
        }
        if ( v11 )
        {
          v20 = a1 + v18 * v8 + v9;
          v21 = v19 << 16;
          v22 = ((a7 - v19) << 16) / v11;
          a1 = (v10 << 16) / v11;
          v23 = 0;
          v28 = a1;
          if ( v11 > 0 )
          {
            v32 = v11;
            do
            {
              v23 += v28;
              v21 += v22;
              v24 = 320 * (v23 >> 16);
              a1 = *(unsigned __int8 *)(v24 + v20);
              v25 = (_BYTE *)(v20 + v24);
              LOBYTE(a1) = byte_478840[64 * a1 + (v21 >> 16)];
              ++v20;
              v17 = v32-- == 1;
              *v25 = a1;
            }
            while ( !v17 );
          }
        }
      }
      else
      {
        a1 = a3;
        if ( a5 >= a3 )
        {
          v12 = a2;
        }
        else
        {
          v12 = a4;
          a1 = a5;
          v29 = a7;
          a7 = a6;
          v10 = a3 - a5;
          v11 = -v11;
          a6 = v29;
        }
        if ( v10 )
        {
          v13 = v12 + a1 * v8 + v9;
          v14 = a6 << 16;
          a1 = (v11 << 16) / v10;
          v15 = 0;
          v27 = a1;
          if ( v10 > 0 )
          {
            v30 = v10;
            do
            {
              v15 += v27;
              v14 += ((a7 - a6) << 16) / v10;
              v16 = (_BYTE *)(v13 + (v15 >> 16));
              LOBYTE(a1) = byte_478840[64 * (unsigned __int8)*v16 + (v14 >> 16)];
              v13 += v8;
              v17 = v30-- == 1;
              *v16 = a1;
            }
            while ( !v17 );
          }
        }
      }
    }
  }
  return a1;
}

//----- (004011E0) --------------------------------------------------------
float *__usercall sub_4011E0@<eax>(float *result@<eax>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  float *v7; // edi
  int v8; // esi
  double v9; // st7
  double v10; // st6
  float *v11; // ecx
  double v12; // st5
  double v13; // st4
  double v14; // st3
  unsigned int v15; // edx
  double v16; // st2
  double v17; // st2
  double v18; // st2
  double v19; // st2
  double v20; // st7
  double v21; // st6
  double v22; // st5
  double v23; // st4
  int v24; // ecx
  float *v25; // edi
  double v26; // st3
  double v27; // st2
  double v28; // st3
  float v29; // [esp+4h] [ebp-28h]
  float v30; // [esp+8h] [ebp-24h]
  float v31; // [esp+Ch] [ebp-20h]
  float v32; // [esp+10h] [ebp-1Ch]
  float v33; // [esp+14h] [ebp-18h]
  double v34; // [esp+18h] [ebp-14h]
  double v35; // [esp+18h] [ebp-14h]
  double v36; // [esp+18h] [ebp-14h]
  double v37; // [esp+18h] [ebp-14h]
  double v38; // [esp+18h] [ebp-14h]
  double v39; // [esp+18h] [ebp-14h]
  double v40; // [esp+18h] [ebp-14h]
  double v41; // [esp+18h] [ebp-14h]
  double v42; // [esp+18h] [ebp-14h]
  double v43; // [esp+20h] [ebp-Ch]
  double v44; // [esp+20h] [ebp-Ch]
  float v45; // [esp+38h] [ebp+Ch]
  float v46; // [esp+38h] [ebp+Ch]
  float v47; // [esp+38h] [ebp+Ch]
  float v48; // [esp+38h] [ebp+Ch]
  float v49; // [esp+38h] [ebp+Ch]
  float v50; // [esp+38h] [ebp+Ch]
  float v51; // [esp+40h] [ebp+14h]
  float v52; // [esp+40h] [ebp+14h]
  float v53; // [esp+40h] [ebp+14h]
  float v54; // [esp+40h] [ebp+14h]
  float v55; // [esp+40h] [ebp+14h]
  float v56; // [esp+40h] [ebp+14h]
  float v57; // [esp+40h] [ebp+14h]
  float v58; // [esp+40h] [ebp+14h]
  float v59; // [esp+40h] [ebp+14h]
  float v60; // [esp+40h] [ebp+14h]
  float v61; // [esp+44h] [ebp+18h]

  v7 = result;
  v31 = sin(a5) * a4;
  v30 = cos(a5) * a4;
  v33 = sin(a6) * a4;
  v32 = cos(a6) * a4;
  v29 = sin(a7) * a4;
  v8 = 0;
  v61 = cos(a7) * a4;
  if ( (int)result >= 4 )
  {
    v9 = v61;
    v10 = v29;
    v11 = (float *)(a2 + 8);
    v12 = v30;
    v13 = v31;
    v14 = v32;
    v15 = ((unsigned int)(result - 1) >> 2) + 1;
    v43 = v33;
    result = (float *)(a3 + 16);
    v8 = 4 * v15;
    do
    {
      v51 = *v11;
      v16 = *(v11 - 2);
      v34 = *(v11 - 1);
      *(result - 3) = v34 * v9 + v10 * v16;
      v45 = v16 * v9 - v10 * v34;
      v35 = *(result - 3);
      *(result - 3) = v35 * v12 - v13 * v51;
      v52 = v51 * v12 + v13 * v35;
      *(result - 4) = v52 * v43 + v14 * v45;
      *(float *)((char *)v11 + a3 - a2) = v14 * v52 - v45 * v43;
      v53 = v11[3];
      v17 = v11[1];
      v36 = v11[2];
      *result = v36 * v9 + v10 * v17;
      v46 = v17 * v9 - v10 * v36;
      v37 = *result;
      *result = v37 * v12 - v13 * v53;
      v54 = v53 * v12 + v13 * v37;
      *(result - 1) = v54 * v43 + v14 * v46;
      result[1] = v14 * v54 - v46 * v43;
      v55 = v11[6];
      v18 = v11[4];
      v38 = v11[5];
      result[3] = v38 * v9 + v10 * v18;
      v47 = v18 * v9 - v10 * v38;
      v39 = result[3];
      result[3] = v39 * v12 - v13 * v55;
      v56 = v55 * v12 + v13 * v39;
      result[2] = v56 * v43 + v14 * v47;
      result[4] = v14 * v56 - v47 * v43;
      v57 = v11[9];
      v19 = v11[7];
      v40 = v11[8];
      v11 += 12;
      result += 12;
      --v15;
      *(result - 6) = v40 * v9 + v10 * v19;
      v48 = v19 * v9 - v10 * v40;
      v41 = *(result - 6);
      *(result - 6) = v41 * v12 - v13 * v57;
      v58 = v57 * v12 + v13 * v41;
      *(result - 7) = v58 * v43 + v14 * v48;
      *(result - 5) = v14 * v58 - v48 * v43;
    }
    while ( v15 );
  }
  if ( v8 < (int)v7 )
  {
    v20 = v61;
    v21 = v29;
    v22 = v30;
    v23 = v31;
    v42 = v32;
    v24 = 12 * v8 + a3 + 4;
    v44 = v33;
    result = (float *)(12 * v8 + a2 + 8);
    v25 = &v7[v8 / 0xFFFFFFFC];
    do
    {
      v26 = *(result - 2);
      result += 3;
      v49 = v26;
      v24 += 12;
      v25 = (float *)((char *)v25 - 1);
      v59 = *(result - 3);
      v27 = *(result - 4);
      *(float *)(v24 - 12) = v27 * v20 + v21 * v49;
      v50 = v49 * v20 - v27 * v21;
      v28 = *(float *)(v24 - 12);
      *(float *)(v24 - 12) = v22 * v28 - v23 * v59;
      v60 = v28 * v23 + v59 * v22;
      *(float *)(v24 - 16) = v44 * v60 + v42 * v50;
      *(float *)((char *)result + a3 - a2 - 12) = v60 * v42 - v50 * v44;
    }
    while ( v25 );
  }
  return result;
}

//----- (00401600) --------------------------------------------------------
int __usercall sub_401600@<eax>(int result@<eax>, int a2@<ebx>, int a3, float a4, float a5, float a6)
{
  int v7; // esi
  float *v8; // edi
  float v9; // [esp+Ch] [ebp+4h]

  v7 = 0;
  if ( a3 > 0 )
  {
    v8 = (float *)(result + 4);
    do
    {
      v9 = v8[1] + 384.0;
      *(_DWORD *)(a2 + 8 * v7) = (int)(*(v8 - 1) * (1.3 * a6) / v9 + a4);
      result = (int)(*v8 * a6 / v9 + a5);
      *(_DWORD *)(a2 + 8 * v7++ + 4) = result;
      v8 += 3;
    }
    while ( v7 < a3 );
  }
  return result;
}

//----- (00401680) --------------------------------------------------------
int __cdecl sub_401680(int a1, int a2, float a3, float a4, float a5)
{
  int v5; // edi
  int v6; // ecx
  double v7; // st7
  int v8; // esi
  int v9; // ebx
  bool v10; // cc
  int result; // eax
  int v12; // esi
  double v13; // st4
  int v14; // edx
  int v15; // ecx
  int v16; // ebx
  int v17; // ecx
  float v18; // [esp+4h] [ebp-34h]
  float v19; // [esp+8h] [ebp-30h]
  float v20; // [esp+Ch] [ebp-2Ch]
  int v21; // [esp+20h] [ebp-18h]
  int v22; // [esp+20h] [ebp-18h]
  int v23; // [esp+24h] [ebp-14h]
  float v24; // [esp+28h] [ebp-10h]
  float v25; // [esp+28h] [ebp-10h]
  float v26; // [esp+28h] [ebp-10h]
  float v27; // [esp+28h] [ebp-10h]
  float v28; // [esp+28h] [ebp-10h]
  float v29; // [esp+28h] [ebp-10h]
  float v30; // [esp+2Ch] [ebp-Ch]
  float v31; // [esp+2Ch] [ebp-Ch]
  int v32; // [esp+2Ch] [ebp-Ch]
  double v33; // [esp+30h] [ebp-8h]

  v5 = 0;
  v21 = 0;
  v23 = 4;
  v33 = sin(flt_41CA18 / 500.0) * 3.0;
  do
  {
    v6 = v5 * (*(_DWORD *)a2 / 4);
    v24 = (double)v23 * v33 + flt_41CA18;
    v7 = v24;
    v8 = *(_DWORD *)(a2 + 4) + 12 * v6;
    v9 = *(_DWORD *)(a2 + 8) + 8 * v6;
    v25 = v24 / 54.0;
    v20 = v25;
    v26 = v7 / 20.0;
    v19 = v26;
    v27 = v7 * 0.03125;
    v18 = v27;
    v28 = (double)v21 * 0.015 + 0.95;
    sub_4011E0((float *)(*(_DWORD *)a2 / 4), *(_DWORD *)(a2 + 12), v8, v28, v18, v19, v20);
    v30 = a5 * 50.0 + 90.0;
    sub_401600(v8, v9, *(_DWORD *)a2 / 4, a3, a4, v30);
    ++v5;
    v10 = v23 - 1 <= 0;
    v21 = v5;
    --v23;
  }
  while ( !v10 );
  v22 = 0;
  result = *(_DWORD *)a2 / 4;
  do
  {
    v12 = 0;
    if ( result > 0 )
    {
      v31 = (double)v22 + 1.0;
      v13 = v31;
      do
      {
        v14 = *(_DWORD *)(a2 + 8);
        v15 = v14 + 8 * v22 * result;
        v16 = *(_DWORD *)(v15 + 8 * v12);
        v32 = *(_DWORD *)(v15 + 8 * v12 + 4);
        v17 = result * (v22 + 1);
        v29 = (float)v22;
        sub_401000(
          a1,
          v16,
          v32,
          *(_DWORD *)(v14 + 8 * v17 + 8 * v12),
          *(_DWORD *)(v14 + 8 * v17 + 8 * v12 + 4),
          63 - ((int)((256.0 - *(float *)(*(_DWORD *)(a2 + 4) + 12 * (v12 + v22 * result) + 8)) * v29 * 0.25) >> 3),
          63 - ((int)((256.0 - *(float *)(*(_DWORD *)(a2 + 4) + 12 * (v12 + v17) + 8)) * v13 * 0.25) >> 3));
        ++v12;
        result = *(_DWORD *)a2 / 4;
      }
      while ( v12 < result );
    }
    ++v22;
  }
  while ( v22 < 3 );
  return result;
}
// 41CA18: using guessed type float flt_41CA18;

//----- (004018C0) --------------------------------------------------------
void __usercall sub_4018C0(int a1@<eax>, float a2)
{
  int v2; // esi
  int v3; // edi
  double v4; // st7
  float v5; // [esp+Ch] [ebp-10h]
  float v6; // [esp+Ch] [ebp-10h]
  float v7; // [esp+10h] [ebp-Ch]
  float v8; // [esp+10h] [ebp-Ch]
  float v9; // [esp+14h] [ebp-8h]
  float v10; // [esp+14h] [ebp-8h]
  float v11; // [esp+14h] [ebp-8h]
  float v12; // [esp+14h] [ebp-8h]
  float v13; // [esp+14h] [ebp-8h]
  float v14; // [esp+18h] [ebp-4h]

  v2 = a1 + 8;
  v3 = 750;
  do
  {
    do
    {
      v9 = (double)rand() / 32767.0;
      v5 = v9 + v9 - 1.0;
      v10 = (double)rand() / 32767.0;
      v7 = v10 + v10 - 1.0;
      v11 = (double)rand() / 32767.0;
      v12 = v11 + v11 - 1.0;
      v14 = sqrt(v7 * v7 + v5 * v5 + v12 * v12);
    }
    while ( v14 > 1.0 );
    v2 += 12;
    --v3;
    v4 = 1.0 / v14;
    v6 = v5 * v4 * a2;
    v8 = v7 * v4 * a2;
    v13 = v4 * v12 * a2;
    *(float *)(v2 - 20) = v6;
    *(float *)(v2 - 16) = v8;
    *(float *)(v2 - 12) = v13;
  }
  while ( v3 );
}

//----- (004019E0) --------------------------------------------------------
char sub_4019E0()
{
  char *v0; // ebx
  int i; // ebp
  int v2; // ecx
  int v3; // esi
  char result; // al
  int v5; // [esp+10h] [ebp-4h]

  v5 = 0;
  v0 = byte_478840;
  for ( i = 1; i > -63; --i )
  {
    v2 = 0;
    v3 = i;
    do
    {
      result = v3 / 64 + 1;
      v0[v2++] = result;
      v3 += v5 - 1;
    }
    while ( v2 < 64 );
    ++v5;
    v0 += 64;
  }
  return result;
}

//----- (00401A40) --------------------------------------------------------
float *__cdecl sub_401A40(int *a1)
{
  float *v1; // esi
  void *v2; // ebx
  void *v3; // eax
  double v4; // st7
  int v6; // [esp+18h] [ebp+4h]

  v1 = (float *)malloc(0x2Cu);
  *(_DWORD *)v1 = 750;
  *((_DWORD *)v1 + 1) = malloc(0x2328u);
  *((_DWORD *)v1 + 2) = malloc(0x1770u);
  v2 = malloc(0x2328u);
  *((_DWORD *)v1 + 3) = v2;
  sub_4019E0();
  sub_4018C0((int)v2, 256.0);
  v3 = malloc(0xC00u);
  v4 = (double)*a1;
  *((_DWORD *)v1 + 4) = v3;
  v6 = -a1[1];
  v1[9] = v4 * 0.5;
  v1[10] = 0.5 * (double)v6;
  sub_4023D0((int)(v1 + 5), (int)(v1 + 4), "ball.png");
  return v1;
}

//----- (00401AF0) --------------------------------------------------------
_BYTE *__usercall sub_401AF0@<eax>(int *a1@<eax>)
{
  int v2; // esi
  float v4; // [esp+8h] [ebp-4h]

  flt_41CA14 = flt_41CE78 + flt_41CA14;
  flt_41CE78 = flt_41CE78 + 0.2;
  v4 = (float)a1[1];
  if ( v4 < (double)flt_41CA14 )
  {
    flt_41CA14 = (float)a1[1];
    flt_41CE78 = 0.0;
  }
  v2 = (int)flt_41CA14;
  sub_4020E0(v2, 0, a1, 63, 0, *a1);
  return sub_4020E0((int)((double)(a1[1] + 1) - flt_41CA14), v2, a1, 0, 0, *a1);
}
// 41CA14: using guessed type float flt_41CA14;
// 41CE78: using guessed type float flt_41CE78;

//----- (00401B90) --------------------------------------------------------
int __usercall sub_401B90@<eax>(int *a1@<edi>, int a2, int a3, int a4)
{
  int v4; // ebx
  char *v5; // esi
  size_t v6; // ebp
  int v7; // esi
  int v8; // ebx
  float v10; // [esp+8h] [ebp-14h]
  float v11; // [esp+20h] [ebp+4h]
  float v12; // [esp+20h] [ebp+4h]
  float v13; // [esp+20h] [ebp+4h]

  sub_401AF0(a1);
  if ( dword_41CA1C )
  {
    v4 = a1[1];
    v5 = (char *)a1[3];
    dword_41CA1C = 0;
    if ( v4 > 0 )
    {
      v6 = *a1;
      do
      {
        memset(v5, 0, v6);
        v5 += a1[2];
        --v4;
      }
      while ( v4 );
    }
    v7 = a2;
    sub_402230((char **)(a2 + 16), 128);
  }
  else
  {
    v7 = a2;
  }
  flt_41CA18 = flt_41CA18 + 1.0;
  if ( a3 )
    flt_41CE8C = 0.2;
  v8 = a1[1];
  flt_41CE84 = flt_41CE88 + flt_41CE84;
  flt_41CE88 = flt_41CE88 + flt_41CE8C;
  v11 = (float)v8;
  if ( v11 < (double)flt_41CE84 )
  {
    flt_41CE88 = 0.0;
    flt_41CE84 = (float)v8;
  }
  ++dword_41CE80;
  if ( a4 )
  {
    dword_41CE80 = 0;
    flt_41CE7C = 1.0;
  }
  flt_41CE7C = flt_41CE7C * 0.95;
  v12 = 1.0 / (sin((1.0 - flt_41CE7C) * 6.283185307179586 + 1.570796326794897) + 1.75) - 0.36;
  v10 = v12;
  v13 = flt_41CE84 - (double)(v8 / 2);
  return sub_401680((int)a1, v7, *(float *)(v7 + 36), v13, v10);
}
// 41CA18: using guessed type float flt_41CA18;
// 41CA1C: using guessed type int dword_41CA1C;
// 41CE7C: using guessed type float flt_41CE7C;
// 41CE80: using guessed type int dword_41CE80;
// 41CE84: using guessed type float flt_41CE84;
// 41CE88: using guessed type float flt_41CE88;
// 41CE8C: using guessed type float flt_41CE8C;

//----- (00401D00) --------------------------------------------------------
int *sub_401D00()
{
  FILE *v0; // eax
  int *result; // eax
  int v2; // eax
  char v3; // cl
  FILE *v4; // eax

  strcpy((char *)&dword_41CD78, "/usr/local/share");
  *(_WORD *)((char *)&dword_41CD78 + strlen((const char *)&dword_41CD78)) = 47;
  strcat((char *)&dword_41CD78, "ecfh-awts");
  *(_WORD *)((char *)&dword_41CD78 + strlen((const char *)&dword_41CD78)) = 47;
  strcat((char *)&dword_41CD78, "chip.xm");
  v0 = fopen((const char *)&dword_41CD78, "r");
  if ( v0 )
    goto LABEL_2;
  v2 = 0;
  do
  {
    v3 = FileName[v2];
    *((_BYTE *)&dword_41CD78 + v2++) = v3;
  }
  while ( v3 );
  v0 = fopen(FileName, "r");
  if ( v0 )
  {
LABEL_2:
    fclose(v0);
    result = &dword_41CD78;
  }
  else
  {
    v4 = _iob_func();
    fprintf(v4 + 2, "findfile: file %s could not be found\n", FileName);
    result = 0;
  }
  return result;
}
// 41CD78: using guessed type int dword_41CD78;

//----- (00401E50) --------------------------------------------------------
_DWORD *__usercall sub_401E50@<eax>(int a1@<eax>)
{
  _DWORD *v2; // ebp
  _DWORD *v3; // eax
  int v4; // ecx
  _DWORD *v5; // esi
  int v6; // eax
  _DWORD *v7; // edi
  unsigned __int8 v8; // cl
  int j; // ebx
  int v10; // edi
  int *v11; // ecx
  _DWORD *result; // eax
  unsigned __int8 v13; // [esp+13h] [ebp-19h]
  _DWORD *v14; // [esp+14h] [ebp-18h]
  int v15; // [esp+18h] [ebp-14h]
  const char *v16; // [esp+1Ch] [ebp-10h]
  int v17; // [esp+20h] [ebp-Ch]
  int i; // [esp+24h] [ebp-8h]
  int *v19; // [esp+28h] [ebp-4h]

  v16 = "abcdefghijklmnopqrstuvwxyz ";
  v2 = &unk_41C3C0;
  v14 = malloc(0x80Cu);
  v3 = malloc(0x80u);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = v3;
  v6 = *(_DWORD *)(a1 + 12);
  *v5 = 16;
  v5[3] = v6;
  v5[2] = v4;
  v5[1] = 12;
  v5[7] = v6 + 17;
  v5[4] = 16;
  v5[5] = 12;
  v5[6] = v4;
  v5[11] = v6 + 34;
  v5[8] = 16;
  v5[9] = 12;
  v5[10] = v4;
  v5[15] = v6 + 51;
  v5[12] = 16;
  v5[13] = 12;
  v5[14] = v4;
  v5[19] = v6 + 68;
  v5[16] = 16;
  v5[17] = 12;
  v5[18] = v4;
  v5[23] = v6 + 85;
  v5[20] = 16;
  v5[21] = 12;
  v5[22] = v4;
  v5[27] = v6 + 102;
  v5[24] = 16;
  v5[25] = 12;
  v5[26] = v4;
  v5[31] = v6 + 119;
  v5[28] = 16;
  v5[29] = 12;
  v5[30] = v4;
  v7 = malloc(0x10u);
  *v7 = 1296;
  v7[1] = 60;
  v7[2] = 1296;
  v7[3] = malloc(0x12FC0u);
  v14[514] = v7;
  v15 = 0;
  for ( i = 0; i < 1296; i += 48 )
  {
    v8 = *v16++;
    v13 = v8;
    v19 = (int *)v14[514];
    for ( j = 0; j < 60; j += 12 )
    {
      v10 = v15;
      v17 = 3;
      do
      {
        v11 = &v5[4 * *v2++];
        sub_402150(v19, v10, v11, j);
        v10 += 16;
        --v17;
      }
      while ( v17 );
    }
    v15 += 48;
    v14[v13 + 257] = i;
    v14[v13 + 1] = 48;
  }
  result = v14;
  v14[513] = 48;
  *v14 = 60;
  return result;
}

//----- (00402010) --------------------------------------------------------
void *__usercall sub_402010@<eax>(unsigned __int8 a1@<al>, _DWORD *a2@<edi>, void *a3, int a4)
{
  int *v4; // ecx
  char *v6; // esi
  void *result; // eax
  int v8; // ebx
  int Size; // [esp+Ch] [ebp-8h]
  int i; // [esp+10h] [ebp-4h]

  v4 = (int *)a2[514];
  v6 = (char *)(v4[3] + a2[a1 + 257]);
  result = (void *)a2[a1 + 1];
  v8 = 0;
  Size = (int)result;
  for ( i = *v4; v8 < *a2; ++v8 )
  {
    result = memcpy(a3, v6, Size);
    v6 += i;
    a3 = (char *)a3 + a4;
  }
  return result;
}

//----- (00402070) --------------------------------------------------------
char __usercall sub_402070@<al>(int a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3, int a4)
{
  _DWORD *v4; // edx
  const char *v6; // ebp
  int v7; // ebx
  int v8; // ecx
  int v9; // esi
  int v11; // [esp+Ch] [ebp-4h]

  v4 = a3;
  v6 = "another way to scroll";
  v7 = 320;
  if ( a1 <= a3[1] - *a2 )
  {
    v8 = a3[3] + a1 * *a3;
    v11 = v8;
    LOBYTE(a1) = 97;
    while ( 1 )
    {
      ++v6;
      v9 = a2[(unsigned __int8)a1 + 1] + 1;
      if ( v7 >= 0 && v7 <= *v4 - v9 )
      {
        sub_402010(a1, a2, (void *)(v7 + v8), a4);
        v8 = v11;
      }
      LOBYTE(a1) = *v6;
      v7 += v9;
      if ( !*v6 )
        break;
      v4 = a3;
    }
  }
  return a1;
}

//----- (004020E0) --------------------------------------------------------
_BYTE *__usercall sub_4020E0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<edi>, char a4, int a5, size_t Size)
{
  _BYTE *result; // eax
  signed int v8; // edx
  char *v9; // esi

  result = (_BYTE *)a3[1];
  if ( a2 <= (int)result )
  {
    v8 = *a3;
    if ( a5 <= *a3 && (int)Size > 0 && a1 > 0 )
    {
      if ( a2 + a1 > (int)result )
        a1 = (int)&result[-a2];
      result = (_BYTE *)a5;
      if ( (int)(a5 + Size) > v8 )
        Size = v8 - a5;
      v9 = (char *)(a5 + a2 * a3[2] + a3[3]);
      if ( a1 > 0 )
      {
        do
        {
          result = memset(v9, (unsigned __int8)a4, Size);
          v9 += a3[2];
          --a1;
        }
        while ( a1 );
      }
    }
  }
  return result;
}

//----- (00402150) --------------------------------------------------------
int __usercall sub_402150@<eax>(int *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4)
{
  char *v4; // esi
  int v6; // ebx
  int result; // eax
  int v8; // ecx
  int v9; // ebp
  int v10; // ecx
  int v11; // ebp
  int v12; // edi
  char *v13; // ebx
  int v14; // ebp
  size_t Size; // [esp+10h] [ebp-14h]
  int v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  int v18; // [esp+20h] [ebp-4h]

  v4 = (char *)a3[3];
  v6 = a1[3];
  v17 = a1[2];
  v18 = a3[2];
  result = *a3;
  v8 = a3[1];
  Size = result;
  v16 = v8;
  if ( a2 >= -result )
  {
    v9 = v8;
    v10 = a4;
    if ( a4 >= -v9 )
    {
      v11 = *a1;
      if ( a2 <= *a1 )
      {
        v12 = a1[1];
        if ( a4 <= v12 )
        {
          if ( a2 >= 0 )
          {
            if ( result + a2 > v11 )
              Size = v11 - a2;
          }
          else
          {
            Size = a2 + result;
            v4 -= a2;
            a2 = 0;
          }
          if ( a4 >= 0 )
          {
            result = v16;
            if ( v16 + a4 > v12 )
              result = v12 - a4;
          }
          else
          {
            v4 -= a4 * result;
            result = a4 + v16;
            v10 = 0;
          }
          v13 = (char *)(a2 + v10 * v17 + v6);
          if ( result > 0 )
          {
            v14 = result;
            do
            {
              result = (int)memcpy(v13, v4, Size);
              v4 += v18;
              v13 += v17;
              --v14;
            }
            while ( v14 );
          }
        }
      }
    }
  }
  return result;
}

//----- (00402230) --------------------------------------------------------
int __fastcall sub_402230(char **a1, int a2)
{
  char *v2; // eax
  char *v3; // ecx
  int v4; // edi
  _BYTE *v5; // eax
  char v7[768]; // [esp+4h] [ebp-304h] BYREF

  v2 = v7;
  if ( a2 > 0 )
  {
    v3 = *a1;
    v4 = a2;
    do
    {
      *v2 = *v3;
      v5 = v2 + 1;
      *v5++ = v3[4];
      *v5 = v3[8];
      v2 = v5 + 1;
      v3 += 12;
      --v4;
    }
    while ( v4 );
  }
  return sub_402A40(v7, a2);
}

//----- (004022A0) --------------------------------------------------------
int __usercall sub_4022A0@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( result >= a2 )
    result = a2 < 0 ? 0 : a2;
  return result;
}

//----- (004022C0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __cdecl sub_4022C0(int a1)
{
  int v1; // eax

  dword_478830 = 0;
  MikMod_RegisterAllDrivers();
  MikMod_RegisterAllLoaders();
  md_mode = 9;
  md_reverb = 0;
  MikMod_Init(&unk_41A836);
  md_mode = 9;
  md_reverb = 0;
  v1 = Player_Load(a1, 6, 0);
  dword_478834 = v1;
  if ( !v1 )
    return -1;
  *(_DWORD *)(v1 + 248) = 1;
  return 0;
}
// 4022E1: write access to const memory at 416148 has been detected
// 4022EB: write access to const memory at 41612C has been detected
// 402307: write access to const memory at 416148 has been detected
// 40230D: write access to const memory at 41612C has been detected
// 416128: using guessed type int MikMod_RegisterAllLoaders(void);
// 416138: using guessed type int __cdecl MikMod_Init(_DWORD);
// 416144: using guessed type int MikMod_RegisterAllDrivers(void);
// 41614C: using guessed type int __cdecl Player_Load(_DWORD, _DWORD, _DWORD);
// 478830: using guessed type int dword_478830;
// 478834: using guessed type int dword_478834;

//----- (00402340) --------------------------------------------------------
_DWORD *sub_402340()
{
  _DWORD *result; // eax
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx

  result = malloc(0x2Cu);
  v1 = dword_41C378;
  *result = dword_41C374;
  v2 = dword_41C37C;
  result[1] = v1;
  v3 = dword_41C380;
  result[2] = v2;
  v4 = dword_41C384;
  result[3] = v3;
  v5 = dword_41C388;
  result[4] = v4;
  v6 = dword_41C38C;
  result[5] = v5;
  v7 = dword_41C390;
  result[6] = v6;
  v8 = dword_41C394;
  result[7] = v7;
  v9 = dword_41C398;
  result[8] = v8;
  v10 = dword_41C39C;
  result[9] = v9;
  dword_478838 = (int)result;
  dword_478830 = 11;
  result[10] = v10;
  return result;
}
// 41C374: using guessed type int dword_41C374;
// 41C378: using guessed type int dword_41C378;
// 41C37C: using guessed type int dword_41C37C;
// 41C380: using guessed type int dword_41C380;
// 41C384: using guessed type int dword_41C384;
// 41C388: using guessed type int dword_41C388;
// 41C38C: using guessed type int dword_41C38C;
// 41C390: using guessed type int dword_41C390;
// 41C394: using guessed type int dword_41C394;
// 41C398: using guessed type int dword_41C398;
// 41C39C: using guessed type int dword_41C39C;
// 478830: using guessed type int dword_478830;
// 478838: using guessed type int dword_478838;

//----- (004023D0) --------------------------------------------------------
int __cdecl sub_4023D0(int a1, int a2, char *FileName)
{
  FILE *v3; // edi
  int result; // eax
  char *v5; // eax
  int v6; // esi
  void **v7; // edi
  int v8; // eax
  void *v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // ecx
  _BYTE *v12; // eax
  unsigned int v13; // ebx
  _BYTE *v14; // esi
  unsigned int v15; // edx
  _BYTE *v16; // eax
  unsigned int v17; // ecx
  unsigned int i; // esi
  void *v19; // eax
  char *v20; // ecx
  int v21; // ecx
  int j; // eax
  int v23; // [esp+Ch] [ebp-2Ch] BYREF
  int v24; // [esp+10h] [ebp-28h] BYREF
  int v25; // [esp+14h] [ebp-24h] BYREF
  int v26; // [esp+18h] [ebp-20h] BYREF
  int v27; // [esp+1Ch] [ebp-1Ch]
  FILE *Stream; // [esp+20h] [ebp-18h]
  unsigned int v29; // [esp+24h] [ebp-14h] BYREF
  int v30; // [esp+28h] [ebp-10h] BYREF
  unsigned int v31; // [esp+2Ch] [ebp-Ch] BYREF
  char *EndPtr; // [esp+30h] [ebp-8h] BYREF
  unsigned __int8 *v33; // [esp+34h] [ebp-4h] BYREF

  v27 = 0;
  printf("pngloader: loading %s\n", FileName);
  v3 = fopen(FileName, "rb");
  Stream = v3;
  if ( v3 )
  {
    v5 = (char *)sub_407B20("1.2.8", 0, (int)nullsub_1, (int)nullsub_1);
    EndPtr = v5;
    if ( v5 )
    {
      v30 = (int)sub_4083B0(v5);
      if ( v30 )
      {
        if ( setjmp3(EndPtr, 0) )
        {
          printf("pngloader: file %s doesn't seem to be a valid .png file\n", FileName);
          sub_407B50((_DWORD **)&EndPtr, (void **)&v30, 0);
          fclose(Stream);
          result = 1;
        }
        else
        {
          sub_408290((int)EndPtr, (int)Stream);
          sub_407C10((int)EndPtr, (int)EndPtr, v27);
          sub_405510(EndPtr, v30);
          sub_405140((int *)EndPtr, v30, &v29, &v31, &v23, &v24, &v25, 0, 0);
          v6 = 0;
          v7 = (void **)malloc(4 * v31);
          if ( v31 )
          {
            while ( 1 )
            {
              v8 = sub_405120((int)EndPtr, v30);
              v9 = malloc(v8);
              v7[v6] = v9;
              if ( !v9 )
                break;
              if ( ++v6 >= v31 )
                goto LABEL_12;
            }
            printf("pngloader: could not allocate memory\n");
            result = -1;
          }
          else
          {
LABEL_12:
            sub_4069C0((int)EndPtr, v7);
            v10 = v29;
            v11 = v31;
            *(_DWORD *)a1 = v29;
            *(_DWORD *)(a1 + 8) = v10;
            *(_DWORD *)(a1 + 4) = v11;
            v12 = malloc(v11 * v10);
            *(_DWORD *)(a1 + 12) = v12;
            if ( v12 )
            {
              v13 = 0;
              v14 = v12;
              if ( v31 )
              {
                v15 = v29;
                do
                {
                  v16 = v7[v13];
                  v17 = 0;
                  if ( v15 )
                  {
                    do
                    {
                      *v14 = *v16;
                      v15 = v29;
                      ++v17;
                      ++v14;
                      ++v16;
                    }
                    while ( v17 < v29 );
                  }
                  ++v13;
                }
                while ( v13 < v31 );
              }
              for ( i = 0; i < v31; ++i )
                free(v7[i]);
              free(v7);
              v33 = (unsigned __int8 *)malloc(0x300u);
              v19 = malloc(0xC00u);
              v20 = EndPtr;
              *(_DWORD *)a2 = v19;
              v26 = 256;
              sub_405270((int)v20, v30, &v33, &v26);
              v21 = 0;
              for ( j = 0; j < 768; j += 12 )
              {
                *(_DWORD *)(v21 + *(_DWORD *)a2) = v33[j] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 4) = v33[j + 1] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 8) = v33[j + 2] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 12) = v33[j + 3] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 16) = v33[j + 4] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 20) = v33[j + 5] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 24) = v33[j + 6] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 28) = v33[j + 7] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 32) = v33[j + 8] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 36) = v33[j + 9] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 40) = v33[j + 10] >> 2;
                *(_DWORD *)(v21 + *(_DWORD *)a2 + 44) = v33[j + 11] >> 2;
                v21 += 48;
              }
              sub_406A20(EndPtr, v30);
              sub_407B50((_DWORD **)&EndPtr, (void **)&v30, 0);
              fclose(Stream);
              result = 0;
            }
            else
            {
              printf("pngloader: could not get memory for image\n");
              result = 1;
            }
          }
        }
      }
      else
      {
        printf("pngloader: file %s doesn't seem to be a valid .png file\n", FileName);
        fclose(v3);
        sub_407B50((_DWORD **)&EndPtr, 0, 0);
        result = 1;
      }
    }
    else
    {
      printf("pngloader: file %s doesn't seem to be a valid .png file\n", FileName);
      fclose(v3);
      result = 1;
    }
  }
  else
  {
    printf("pngloader: could not open file %s\n", FileName);
    result = 1;
  }
  return result;
}
// 4023C0: using guessed type int nullsub_1();
// 412500: using guessed type int __cdecl setjmp3(_DWORD, _DWORD);

//----- (00402780) --------------------------------------------------------
int sub_402780()
{
  int v0; // eax
  int v1; // eax
  int result; // eax
  int v3; // ecx
  int v4; // edx
  void *v5; // edi
  _DWORD *v6; // eax
  int v7; // [esp-14h] [ebp-14h]

  v0 = SDL_Init(32);
  if ( v0 < 0 )
    exit(v0);
  SDL_ShowCursor(0);
  v1 = SDL_SetVideoMode(320, 200, 8, -1073741823);
  dword_41CE90 = v1;
  if ( v1 )
  {
    v3 = *(_DWORD *)(v1 + 12);
    v4 = *(_DWORD *)(v1 + 8);
    v7 = *(unsigned __int16 *)(v1 + 16);
    dword_47850C = 0;
    dword_478508 = 1;
    printf("video stride=%d w=%d h=%d\n", v7, v4, v3);
    memset(byte_478520, 0, 0x300u);
    dword_478518 = *(unsigned __int16 *)(dword_41CE90 + 16);
    dword_478500 = 320;
    dword_478504 = 200;
    dword_47882C = 8;
    v5 = malloc(0xFA00u);
    dword_47851C = (int)v5;
    v6 = malloc(0x10u);
    dword_478824 = (int)v6;
    *v6 = 320;
    v6[1] = 200;
    v6[2] = 320;
    v6[3] = v5;
    dword_478828 = 14285;
    dword_478510 = timeGetTime();
    dword_478820 = timeGetTime();
    result = 0;
  }
  else
  {
    printf("sdl video init failure\n");
    SDL_Quit();
    result = -1;
  }
  return result;
}
// 4050E4: using guessed type int __cdecl SDL_Init(_DWORD);
// 4050EA: using guessed type int __cdecl SDL_SetVideoMode(_DWORD, _DWORD, _DWORD, _DWORD);
// 4050F6: using guessed type int __cdecl SDL_ShowCursor(_DWORD);
// 405114: using guessed type int SDL_Quit(void);
// 41CE90: using guessed type int dword_41CE90;
// 478500: using guessed type int dword_478500;
// 478504: using guessed type int dword_478504;
// 478508: using guessed type int dword_478508;
// 47850C: using guessed type int dword_47850C;
// 478510: using guessed type int dword_478510;
// 478518: using guessed type int dword_478518;
// 47851C: using guessed type int dword_47851C;
// 478820: using guessed type int dword_478820;
// 478824: using guessed type int dword_478824;
// 478828: using guessed type int dword_478828;
// 47882C: using guessed type int dword_47882C;

//----- (004028A0) --------------------------------------------------------
int sub_4028A0()
{
  char v1[8]; // [esp+0h] [ebp-14h] BYREF
  int v2; // [esp+8h] [ebp-Ch]

  if ( !SDL_PollEvent(v1) )
    return 0;
  while ( v1[0] != 3 )
  {
    if ( v1[0] == 12 )
    {
      dword_47850C = 27;
      return 1;
    }
    if ( !SDL_PollEvent(v1) )
      return 0;
  }
  dword_47850C = v2;
  return 1;
}
// 4050F0: using guessed type int __cdecl SDL_PollEvent(_DWORD);
// 47850C: using guessed type int dword_47850C;

//----- (00402900) --------------------------------------------------------
int __cdecl sub_402900(int a1)
{
  char *v1; // ecx
  char *v2; // eax
  int v3; // ebx
  _DWORD *v4; // esi
  _DWORD *v5; // edi
  int v6; // ebp
  int v7; // eax
  int v8; // ecx
  char v10; // [esp+0h] [ebp-400h] BYREF
  char v11; // [esp+1h] [ebp-3FFh] BYREF

  if ( dword_478508 )
  {
    dword_478508 = 0;
    v1 = &v11;
    v2 = byte_478521;
    do
    {
      *(v1 - 1) = 4 * *(v2 - 1);
      *v1 = 4 * *v2;
      v1[1] = 4 * v2[1];
      v2 += 3;
      v1 += 4;
    }
    while ( (int)v2 < 4687905 );
    SDL_SetColors(dword_41CE90, &v10, 0, 256);
  }
  if ( SDL_LockSurface(dword_41CE90) )
  {
    printf("failed to lock vidmem, exiting\n");
    exit(1);
  }
  v3 = dword_478504;
  v4 = *(_DWORD **)(dword_41CE90 + 20);
  v5 = *(_DWORD **)(a1 + 12);
  dword_478514 = (int)v4;
  if ( dword_478504 )
  {
    v6 = dword_478500 / 4;
    v7 = 4 * ((dword_478518 - dword_478500) / 4);
    do
    {
      v8 = v6;
      --v3;
      if ( v6 )
      {
        do
        {
          --v8;
          *v4++ = *v5++;
        }
        while ( v8 );
      }
      v4 = (_DWORD *)((char *)v4 + v7);
    }
    while ( v3 );
  }
  SDL_UnlockSurface(dword_41CE90);
  return SDL_UpdateRect(dword_41CE90, 0, 0, 0, 0);
}
// 4050DE: using guessed type int __cdecl SDL_UpdateRect(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4050FC: using guessed type int __cdecl SDL_LockSurface(_DWORD);
// 405102: using guessed type int __cdecl SDL_UnlockSurface(_DWORD);
// 405108: using guessed type int __cdecl SDL_SetColors(_DWORD, _DWORD, _DWORD, _DWORD);
// 41CE90: using guessed type int dword_41CE90;
// 478500: using guessed type int dword_478500;
// 478504: using guessed type int dword_478504;
// 478508: using guessed type int dword_478508;
// 478514: using guessed type int dword_478514;
// 478518: using guessed type int dword_478518;

//----- (00402A40) --------------------------------------------------------
int __usercall sub_402A40@<eax>(char *a1@<ecx>, int a2@<esi>)
{
  int v2; // edx
  char v3; // bl
  char v4; // al
  char *v5; // ecx
  int result; // eax
  char v7; // [esp+0h] [ebp-2h]
  char v8; // [esp+1h] [ebp-1h]

  v2 = 0;
  if ( a2 > 0 )
  {
    dword_478508 = 1;
    do
    {
      v3 = *a1;
      v4 = a1[1];
      v5 = a1 + 2;
      v7 = v4;
      v8 = *v5;
      result = (unsigned __int8)v2;
      byte_478520[3 * (unsigned __int8)v2] = v3;
      byte_478521[3 * (unsigned __int8)v2++] = v7;
      a1 = v5 + 1;
      byte_478522[3 * result] = v8;
    }
    while ( v2 < a2 );
  }
  return result;
}
// 478508: using guessed type int dword_478508;

//----- (00402AA0) --------------------------------------------------------
_DWORD *sub_402AA0()
{
  _DWORD *v0; // esi
  _DWORD *result; // eax

  v0 = malloc(4u);
  *v0 = 1;
  sub_4023D0((int)&unk_4784F0, (int)&dword_4784C0, "credits.png");
  dword_4784DC = dword_4784FC + 80 * dword_4784F8;
  dword_4784E0 = 80;
  dword_4784B0 = 80;
  dword_4784A0 = 80;
  Size = 80;
  dword_4784D8 = dword_4784F8;
  dword_4784E8 = dword_4784F8;
  dword_4784B8 = dword_4784F8;
  dword_4784A8 = dword_4784F8;
  dword_4784EC = dword_4784FC + 80;
  result = v0;
  dword_4784BC = dword_4784FC + 160;
  dword_4784D0 = 106;
  dword_4784D4 = 24;
  dword_4784E4 = 60;
  dword_4784B4 = 60;
  dword_4784AC = dword_4784FC + 240;
  dword_4784A4 = 60;
  dword_4784C4 = 60;
  return result;
}
// 4784A0: using guessed type int dword_4784A0;
// 4784A4: using guessed type int dword_4784A4;
// 4784A8: using guessed type int dword_4784A8;
// 4784AC: using guessed type int dword_4784AC;
// 4784B0: using guessed type int dword_4784B0;
// 4784B4: using guessed type int dword_4784B4;
// 4784B8: using guessed type int dword_4784B8;
// 4784BC: using guessed type int dword_4784BC;
// 4784C0: using guessed type int dword_4784C0;
// 4784C4: using guessed type int dword_4784C4;
// 4784D0: using guessed type int dword_4784D0;
// 4784D4: using guessed type int dword_4784D4;
// 4784D8: using guessed type int dword_4784D8;
// 4784DC: using guessed type int dword_4784DC;
// 4784E0: using guessed type int dword_4784E0;
// 4784E4: using guessed type int dword_4784E4;
// 4784E8: using guessed type int dword_4784E8;
// 4784EC: using guessed type int dword_4784EC;
// 4784F8: using guessed type int dword_4784F8;
// 4784FC: using guessed type int dword_4784FC;

//----- (00402B70) --------------------------------------------------------
int __usercall sub_402B70@<eax>(size_t *a1@<eax>, _DWORD *a2)
{
  int v3; // ebx
  char *v4; // esi
  size_t v5; // ebp
  int v6; // eax
  int v7; // ecx
  bool v8; // cc
  int v9; // ebp
  int v10; // esi
  int *v11; // ecx
  unsigned __int8 v12; // al
  _DWORD *v13; // esi
  unsigned int v14; // ecx
  unsigned int v15; // edx
  int v16; // ecx
  int result; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // [esp+10h] [ebp-4h]
  int v22; // [esp+18h] [ebp+4h]

  if ( *a2 == 1 )
  {
    v3 = a1[1];
    v4 = (char *)a1[3];
    if ( v3 > 0 )
    {
      v5 = a1[1];
      do
      {
        memset(v4, 0, *a1);
        v4 += a1[2];
        --v5;
      }
      while ( v5 );
    }
    sub_402150((int *)a1, 30, &dword_4784D0, v3 - 3 * dword_4784D4 / 2);
    *a2 = 0;
  }
  v6 = (*(unsigned __int16 *)(dword_478834 + 260) + 4) >> 4;
  v7 = ((unsigned __int8)*(_WORD *)(dword_478834 + 260) + 4) & 0xF;
  v8 = v6 <= 3;
  v21 = v6;
  if ( v6 < 3 )
  {
    if ( dword_41CE98 < 63 )
      dword_41CE98 += 4;
    v8 = v6 <= 3;
  }
  if ( !v8 && dword_41CE98 > 0 )
    dword_41CE98 -= 4;
  v9 = dword_41CE94;
  if ( v7 >= 8 )
  {
    if ( dword_41CE94 <= 0 )
      goto LABEL_19;
    v9 = dword_41CE94 - 3;
  }
  else
  {
    if ( dword_41CE94 >= 63 )
      goto LABEL_19;
    v9 = dword_41CE94 + 3;
  }
  dword_41CE94 = v9;
LABEL_19:
  v10 = a1[1] - 27;
  sub_4020E0(dword_4784C4, v10 - dword_4784C4 / 2, (int *)a1, 0, 220 - (int)Size / 2, Size);
  switch ( v21 )
  {
    case 1:
      v11 = &dword_4784E0;
      goto LABEL_25;
    case 2:
      v11 = &dword_4784B0;
      goto LABEL_25;
    case 3:
      v11 = &dword_4784A0;
LABEL_25:
      sub_402150((int *)a1, 220 - dword_4784E0 / 2, v11, v10 - dword_4784E4 / 2);
      break;
  }
  v12 = -32;
  v22 = 224;
  v13 = (_DWORD *)(dword_4784C0 + 2692);
  do
  {
    v14 = (unsigned int)(v9 * v13[1]) >> 6;
    v15 = (unsigned int)(v9 * *v13) >> 6;
    byte_478520[3 * v12] = (unsigned int)(v9 * *(v13 - 1)) >> 6;
    byte_478521[3 * v12] = v15;
    byte_478522[3 * v12] = v14;
    v12 = v22 + 1;
    v13 += 3;
    ++v22;
  }
  while ( v22 < 229 );
  if ( v21 == 1 || v21 == 2 )
    v16 = v9;
  else
    v16 = 0;
  result = dword_41CE98;
  v18 = v16 >> 1;
  byte_4787D8 = (dword_41CE98 * v18) >> 6;
  byte_4787DA = (dword_41CE98 * (v18 + 20)) >> 6;
  byte_4787D9 = (dword_41CE98 * (v18 + 10)) >> 6;
  dword_478508 = 1;
  v19 = (v21 != 3 ? 0 : v9) >> 1;
  byte_4787DE = (dword_41CE98 * v19) >> 6;
  byte_4787E0 = (dword_41CE98 * (v19 + 20)) >> 6;
  byte_4787DF = (dword_41CE98 * (v19 + 10)) >> 6;
  v20 = (v21 != 2 ? 0 : v9) >> 1;
  byte_4787E4 = (dword_41CE98 * v20) >> 6;
  byte_4787E5 = (dword_41CE98 * (v20 + 10)) >> 6;
  byte_4787E6 = (dword_41CE98 * (v20 + 20)) >> 6;
  return result;
}
// 41CE94: using guessed type int dword_41CE94;
// 41CE98: using guessed type int dword_41CE98;
// 4784A0: using guessed type int dword_4784A0;
// 4784B0: using guessed type int dword_4784B0;
// 4784C0: using guessed type int dword_4784C0;
// 4784C4: using guessed type int dword_4784C4;
// 4784D0: using guessed type int dword_4784D0;
// 4784D4: using guessed type int dword_4784D4;
// 4784E0: using guessed type int dword_4784E0;
// 4784E4: using guessed type int dword_4784E4;
// 478508: using guessed type int dword_478508;
// 4787D8: using guessed type char byte_4787D8;
// 4787D9: using guessed type char byte_4787D9;
// 4787DA: using guessed type char byte_4787DA;
// 4787DE: using guessed type char byte_4787DE;
// 4787DF: using guessed type char byte_4787DF;
// 4787E0: using guessed type char byte_4787E0;
// 4787E4: using guessed type char byte_4787E4;
// 4787E5: using guessed type char byte_4787E5;
// 4787E6: using guessed type char byte_4787E6;
// 478834: using guessed type int dword_478834;

//----- (00402E00) --------------------------------------------------------
int sub_402E00()
{
  int *v0; // esi
  _BYTE *v1; // edi
  int v2; // ebx
  _BYTE *v3; // ebp
  int v4; // ecx
  int v5; // ebx
  int result; // eax
  double v7; // st7
  double v8; // st6
  double v9; // st5
  double v10; // st4
  double v11; // st3
  double i; // st6
  double v13; // st5
  double v14; // st7
  char v15; // bl
  int v16; // [esp+10h] [ebp-34h]
  float v17; // [esp+10h] [ebp-34h]
  float v18; // [esp+10h] [ebp-34h]
  _BYTE *v19; // [esp+14h] [ebp-30h]
  _BYTE *v20; // [esp+18h] [ebp-2Ch]
  int v21; // [esp+1Ch] [ebp-28h]
  float v22; // [esp+20h] [ebp-24h]
  float v23; // [esp+20h] [ebp-24h]
  float v24; // [esp+24h] [ebp-20h]
  float v25; // [esp+24h] [ebp-20h]
  float v26; // [esp+28h] [ebp-1Ch]
  float v27; // [esp+28h] [ebp-1Ch]
  float v28; // [esp+2Ch] [ebp-18h]
  int v29; // [esp+2Ch] [ebp-18h]
  float v30; // [esp+30h] [ebp-14h]
  int v31; // [esp+34h] [ebp-10h]
  float v32; // [esp+34h] [ebp-10h]
  float v33; // [esp+38h] [ebp-Ch]
  float v34; // [esp+38h] [ebp-Ch]
  int v35; // [esp+3Ch] [ebp-8h]
  int v36; // [esp+40h] [ebp-4h]

  v0 = (int *)dword_47848C;
  v1 = *(_BYTE **)(dword_47848C + 12);
  v19 = &v1[*(_DWORD *)dword_47848C - 1];
  v31 = *(_DWORD *)(dword_47848C + 4);
  v2 = *(_DWORD *)(dword_47848C + 8);
  v16 = *(_DWORD *)dword_47848C;
  v3 = &v1[v2 * (v31 - 1)];
  v20 = &v3[*(_DWORD *)dword_47848C - 1];
  v4 = *(_DWORD *)dword_47848C / 2;
  v36 = v4 + v2;
  v5 = v2 - v4;
  result = v31 / 2;
  v35 = v5;
  v21 = 0;
  v7 = 0.5;
  v32 = 1.0 / ((double)v31 * 0.5);
  v30 = 1.7 / ((double)*(int *)dword_47848C * 0.5);
  if ( result > 0 )
  {
    v8 = v32;
    v9 = v30;
    do
    {
      v28 = (float)v21;
      v10 = (double)v0[1] * v7;
      v11 = v28;
      v29 = 0;
      v24 = (v11 + 0.25 - v10) * v8;
      v25 = v24 * v24;
      v22 = (v11 + v7 - v10) * v8;
      v23 = v22 * v22;
      v26 = (v11 + 0.75 - v10) * v8;
      v27 = v26 * v26;
      if ( v4 > 0 )
      {
        for ( i = v9; ; i = v30 )
        {
          v13 = (double)v29 + v7;
          v14 = v7 * (double)v16;
          v17 = (v13 - 0.333 - v14) * i;
          v18 = v17 * v17;
          v33 = (v13 + 0.167 - v14) * i;
          v34 = v33 * v33;
          v15 = (int)(sqrt(v18 + v27) * 18.0) & 3 | (4
                                                   * ((4 * ((int)(sqrt(v18 + v25) * 18.0) & 3)) | (int)(sqrt(v34 + v23) * 18.0) & 3));
          *v1 = v15;
          *v19-- = v15;
          *v3 = v15;
          *v20-- = v15;
          v16 = *v0;
          v4 = *v0 / 2;
          ++v1;
          ++v3;
          if ( ++v29 >= v4 )
            break;
          v7 = 0.5;
        }
        v5 = v35;
        v8 = v32;
        v9 = v30;
        v7 = 0.5;
      }
      v19 += v36;
      ++v21;
      v20 -= v5;
      v3 -= v36;
      result = v0[1] / 2;
      v1 += v5;
    }
    while ( v21 < result );
  }
  return result;
}
// 47848C: using guessed type int dword_47848C;

//----- (00403040) --------------------------------------------------------
int *__usercall sub_403040@<eax>(int *result@<eax>, int a2, int a3, int a4, int a5, float a6)
{
  int v6; // ebx
  int v7; // edi
  int v8; // ebp
  _DWORD *v9; // esi
  long double i; // st7
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  double v13; // [esp+18h] [ebp-20h]
  double v14; // [esp+20h] [ebp-18h]
  double v15; // [esp+28h] [ebp-10h]
  double v16; // [esp+30h] [ebp-8h]
  int v17; // [esp+3Ch] [ebp+4h]
  int v18; // [esp+40h] [ebp+8h]
  int v19; // [esp+44h] [ebp+Ch]

  v11 = result[3];
  v6 = a4 + *(_DWORD *)(dword_47848C + 12) + a5 * *(_DWORD *)(dword_47848C + 8);
  v7 = a2 + *(_DWORD *)(dword_47848C + 12) + a3 * *(_DWORD *)(dword_47848C + 8);
  v18 = 0;
  v12 = result[1];
  if ( v12 > 0 )
  {
    v8 = *result >> 2;
    v17 = v8;
    v19 = result[2];
    v13 = (double)dword_41CEB0 * 0.5;
    v14 = a6;
    while ( 1 )
    {
      v15 = (double)v18;
      v16 = (sin(v15 / 100.0 + v13) + 1.0) * 32.0;
      v9 = (_DWORD *)(v7 + (int)(v16 * v14));
      for ( i = sin(v15 / 30.0 + v13); v8; ++v9 )
      {
        --v8;
        *(_DWORD *)((char *)v9 + v11 - (v7 + (int)(v16 * v14))) = *v9 ^ *(_DWORD *)((char *)v9
                                                                                  + (int)(v14 * ((1.0 - i) * 32.0))
                                                                                  - (v7
                                                                                   + (int)(v16 * v14))
                                                                                  + v6);
      }
      v11 += v19;
      v7 += *(_DWORD *)(dword_47848C + 8);
      v6 += *(_DWORD *)(dword_47848C + 8);
      result = (int *)++v18;
      if ( v18 >= v12 )
        break;
      v8 = v17;
    }
  }
  return result;
}
// 41CEB0: using guessed type int dword_41CEB0;
// 47848C: using guessed type int dword_47848C;

//----- (00403190) --------------------------------------------------------
_DWORD *__usercall sub_403190@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v2; // eax
  int v3; // esi
  int v4; // ebx
  _DWORD *v5; // eax
  int v6; // edi
  size_t v7; // ebx
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  int v10; // edx
  _DWORD *v11; // esi
  double v12; // st4
  _DWORD *v14; // [esp+14h] [ebp-10h]
  int v15; // [esp+14h] [ebp-10h]

  v2 = malloc(4u);
  v4 = a1[1] + 200;
  v14 = v2;
  dword_478484 = *a1 + 384;
  v3 = dword_478484;
  dword_478488 = v4;
  v5 = malloc(0x10u);
  v6 = (int)v5;
  v5[1] = v4;
  v7 = v3 * v4;
  *v5 = v3;
  v5[2] = v3;
  if ( v7 )
    v5[3] = malloc(v7);
  else
    v5[3] = 0;
  dword_47848C = v6;
  sub_402E00();
  v8 = malloc(0xC00u);
  v9 = v14;
  *v14 = v8;
  v10 = 0;
  v11 = v8;
  do
  {
    v15 = 4 * ((v10 & 3) + ((v10 >> 2) & 3) + ((v10 >> 4) & 3) + ((v10 >> 6) & 3));
    v12 = (double)v15;
    v11[2] = v15;
    ++v10;
    v11 += 3;
    *(v11 - 3) = (__int64)(v12 * 54.0 / 63.0);
    *(v11 - 2) = (__int64)(v12 * 59.0 / 63.0);
  }
  while ( v10 < 64 );
  return v9;
}
// 478484: using guessed type int dword_478484;
// 478488: using guessed type int dword_478488;
// 47848C: using guessed type int dword_47848C;

//----- (004032D0) --------------------------------------------------------
int *__usercall sub_4032D0@<eax>(signed int *a1@<eax>, char **a2@<ecx>, int a3, int a4, int a5)
{
  int v6; // edx
  int v7; // eax
  bool v8; // cc
  signed int v9; // ecx
  int v10; // esi
  signed int v11; // ebx
  int v12; // edi
  int v13; // eax
  int v14; // edx
  char *v15; // esi
  int v16; // ebp
  long double v18; // [esp+14h] [ebp-20h]
  long double v19; // [esp+14h] [ebp-20h]
  long double v20; // [esp+1Ch] [ebp-18h]
  int v21[4]; // [esp+24h] [ebp-10h] BYREF
  float v22; // [esp+38h] [ebp+4h]

  if ( dword_41C3BC )
  {
    dword_41C3BC = 0;
    sub_402230(a2, 64);
  }
  ++dword_41CEB0;
  if ( a3 )
  {
    dword_41CEB0 = 0;
    flt_41CEAC = 1.0;
  }
  flt_41CEAC = flt_41CEAC * 0.95;
  if ( flt_41CEAC > 0.0 )
    flt_41CEAC = flt_41CEAC + 0.01;
  if ( a4 )
  {
    if ( dword_41CEA8 )
    {
      dword_41CEA8 = 0;
      flt_41C3AC = -flt_41C3AC;
      flt_41C3B0 = -flt_41C3B0;
      flt_41C3B4 = -flt_41C3B4;
      flt_41C3B8 = -flt_41C3B8;
    }
  }
  else
  {
    dword_41CEA8 = 1;
  }
  ++dword_41CE9C;
  v6 = dword_41CEA0;
  flt_41CEA4 = flt_41CEA4 + flt_41C3AC;
  flt_41C3A0 = flt_41C3A0 + flt_41C3B0;
  flt_41C3A4 = flt_41C3A4 + flt_41C3B4;
  flt_41C3A8 = flt_41C3A8 + flt_41C3B8;
  if ( a5 )
  {
    v7 = a1[1];
    v8 = dword_41CEA0 <= v7;
    if ( dword_41CEA0 < v7 )
    {
      v6 = dword_41CEA0 + 2;
      dword_41CEA0 = v6;
      v8 = v6 <= v7;
    }
    if ( !v8 )
    {
      v6 = v7;
      dword_41CEA0 = v7;
    }
  }
  v9 = a1[1];
  v10 = a1[3];
  v11 = *a1;
  v12 = a1[2];
  v13 = v9 - v6;
  v8 = v9 - v6 <= v9;
  v21[3] = v10;
  v21[0] = v11;
  v21[1] = v9 - v6;
  v21[2] = v12;
  v14 = 2;
  if ( v8 && v11 > 0 )
  {
    if ( v13 + 2 > v9 )
      v14 = v9 - v13;
    v15 = (char *)(v13 * v12 + v10);
    if ( v14 > 0 )
    {
      v16 = v14;
      do
      {
        memset(v15, 0, v11);
        v15 += v12;
        --v16;
      }
      while ( v16 );
    }
  }
  v18 = (double)dword_41CE9C / 60.0;
  v20 = sin(v18) * 0.5;
  v19 = cos(v18) * 0.5;
  v22 = 1.0 / (sin((1.0 - flt_41CEAC) * 6.283185307179586 + 1.570796326794897) + 1.75) - 0.36;
  return sub_403040(
           v21,
           (int)((cos(flt_41CEA4 / 50.0) * 0.5 + 1.0) * 160.0 + 160.0 * v20),
           (int)((sin(flt_41C3A0 / 50.0) * 0.5 + 1.0) * 100.0 + 100.0 * v19),
           (int)((sin(flt_41C3A4 / 50.0) * 0.5 + 1.0) * 160.0 + 160.0 * v19),
           (int)((cos(flt_41C3A8 / 50.0) * 0.5 + 1.0) * 100.0 + 100.0 * v20),
           v22);
}
// 41C3A0: using guessed type float flt_41C3A0;
// 41C3A4: using guessed type float flt_41C3A4;
// 41C3A8: using guessed type float flt_41C3A8;
// 41C3AC: using guessed type float flt_41C3AC;
// 41C3B0: using guessed type float flt_41C3B0;
// 41C3B4: using guessed type float flt_41C3B4;
// 41C3B8: using guessed type float flt_41C3B8;
// 41C3BC: using guessed type int dword_41C3BC;
// 41CE9C: using guessed type int dword_41CE9C;
// 41CEA0: using guessed type int dword_41CEA0;
// 41CEA4: using guessed type float flt_41CEA4;
// 41CEA8: using guessed type int dword_41CEA8;
// 41CEAC: using guessed type float flt_41CEAC;
// 41CEB0: using guessed type int dword_41CEB0;

//----- (004035B0) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  signed int v3; // edi
  int *v4; // eax
  size_t *v5; // ebx
  char *v6; // esi
  int v7; // ecx
  float *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v15; // [esp+10h] [ebp-50h]
  int v16; // [esp+14h] [ebp-4Ch] BYREF
  int v17; // [esp+18h] [ebp-48h]
  int v18; // [esp+1Ch] [ebp-44h] BYREF
  float *v19; // [esp+20h] [ebp-40h]
  _DWORD *v20; // [esp+24h] [ebp-3Ch]
  char **v21; // [esp+28h] [ebp-38h]
  _DWORD *v22; // [esp+2Ch] [ebp-34h]
  int v23[4]; // [esp+30h] [ebp-30h] BYREF
  int v24[4]; // [esp+40h] [ebp-20h] BYREF
  int v25[4]; // [esp+50h] [ebp-10h] BYREF

  v3 = 0;
  v15 = 200;
  v17 = 0;
  printf("\n");
  printf("another way to scroll 1.0\n");
  printf("Copyright (C) 2000, Tijs van Bakel and Jorik Blaas\n");
  printf("\n");
  printf("This program is free software; you may redistribute it under the terms of\n");
  printf("the GNU General Public License. (See the file COPYING for more details).\n");
  printf("This program has absolutely no warranty.\n");
  printf("\n");
  sub_402780();
  sub_4023D0((int)v24, (int)&v16, "blockfont.png");
  sub_402230((char **)&v16, 256);
  dword_47883C = (int)sub_401E50((int)v24);
  v4 = sub_401D00();
  sub_4022C0((int)v4);
  sub_402340();
  v5 = (size_t *)dword_478824;
  v6 = *(char **)(dword_478824 + 12);
  if ( *(int *)(dword_478824 + 4) > 0 )
  {
    do
    {
      memset(v6, 0, *v5);
      v6 += v5[2];
      ++v3;
    }
    while ( v3 < (int)v5[1] );
  }
  v7 = v5[2];
  v23[3] = v5[3];
  v23[0] = 320;
  v23[1] = 180;
  v23[2] = v7;
  sub_4023D0((int)v25, (int)&v18, "logo.png");
  v24[3] = v25[3];
  v24[0] = 320;
  v24[1] = 20;
  v24[2] = v25[2];
  v8 = sub_401A40(v23);
  v19 = v8;
  sub_403EF0();
  v21 = (char **)sub_403190(v23);
  v16 = (int)sub_404080();
  v20 = sub_404FD0();
  v22 = sub_402AA0();
  sub_402230((char **)&v18, 256);
  Player_Start(dword_478834);
  while ( 1 )
  {
    v9 = *(unsigned __int16 *)(dword_478834 + 260);
    switch ( *(_WORD *)(dword_478834 + 262) )
    {
      case 0:
        break;
      case 1:
        sub_4042F0(4 * v9 / 64 + 1, (char **)v16, (int)v23, 0, 0);
        break;
      case 2:
        v10 = 4 - 4 * v9 / 28;
        if ( v10 <= 4 )
          v11 = v10 < 0 ? 0 : v10;
        else
          v11 = 4;
        sub_4042F0(v11, (char **)v16, (int)v23, 2, 1);
        break;
      case 3:
        sub_4042F0(0, (char **)v16, (int)v23, 2, 1);
        break;
      case 4:
        v12 = *(unsigned __int16 *)(dword_478834 + 260) > 0x14u && (v9 & 0xF) == 3;
        sub_401B90(v23, (int)v8, *(unsigned __int16 *)(dword_478834 + 260) > 0xFu, v12);
        v13 = v15;
        if ( v15 > 180 )
        {
          --v15;
          sub_402150((int *)v5, 0, v24, v13 - 1);
        }
        break;
      case 5:
        sub_401B90(v23, (int)v8, 1, (v9 & 0xF) == 3);
        break;
      case 6:
        sub_403FB0((size_t *)v23);
        break;
      case 7:
        sub_405030((int)v23, (v9 & 0xF) == 11);
        break;
      case 8:
        sub_4032D0(v23, v21, (v9 & 0xF) == 10, (v9 & 7) == 4, *(unsigned __int16 *)(dword_478834 + 260) > 0x2Du);
        if ( v9 > 56 && v15 < 200 )
        {
          sub_402150((int *)v5, 0, v24, ++v15);
          sub_4020E0(1, v15 - 1, (int *)v5, 0, 0, *v5);
        }
        break;
      case 9:
        Player_SetVolume(127 - 2 * v9);
        if ( v9 == 63 )
          v17 = 1;
        sub_402B70((size_t *)v23, v22);
        break;
      default:
        v17 = 1;
        break;
    }
    MikMod_Update();
    SDL_Flip(dword_41CE90);
    sub_402900((int)v5);
    if ( sub_4028A0() )
    {
      if ( dword_47850C == 27 )
        break;
    }
    if ( v17 )
      break;
    v8 = v19;
  }
  MikMod_Exit();
  printf("\n");
  printf("(defcredits :code '(avoozl smoke)\n");
  printf("            :gfx '(smoke)\n");
  printf("            :guest-music '(floppi))\n");
  printf("\n");
  printf("(defemail (('smoke \"smoke@casema.net\")\n");
  printf("           ('avoozl \"jrk@panic.et.tudelft.nl\")\n");
  printf("           ('floppi \"tero.laihanen@sci.fi\"))\n");
  printf("\n");
  return 0;
}
// 40510E: using guessed type int __cdecl SDL_Flip(_DWORD);
// 416130: using guessed type int MikMod_Update(void);
// 416134: using guessed type int __cdecl Player_Start(_DWORD);
// 41613C: using guessed type int MikMod_Exit(void);
// 416140: using guessed type int __cdecl Player_SetVolume(_DWORD);
// 41CE90: using guessed type int dword_41CE90;
// 47850C: using guessed type int dword_47850C;
// 478824: using guessed type int dword_478824;
// 478834: using guessed type int dword_478834;
// 47883C: using guessed type int dword_47883C;

//----- (00403A50) --------------------------------------------------------
int __cdecl sub_403A50(int a1, float a2, float a3)
{
  long double v3; // st7
  int v4; // esi
  int v5; // edi
  int v6; // ebx
  int v7; // ebp
  int v8; // edx
  int i; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int result; // eax
  int v14; // ebx
  int v15; // esi
  _BYTE *v16; // ecx
  int v17; // eax
  int v18; // edi
  unsigned int v19; // ebp
  int *v20; // esi
  int *v21; // edx
  int *v22; // edx
  int *v23; // esi
  unsigned int v24; // eax
  _BYTE *v25; // ecx
  unsigned int v26; // eax
  int v27; // ebx
  int v28; // ebx
  unsigned int v29; // eax
  int v30; // ebx
  int v31; // eax
  int v32; // ebx
  int v33; // eax
  int v34; // edi
  bool v35; // zf
  int v36; // [esp+0h] [ebp-850h]
  int v37; // [esp+0h] [ebp-850h]
  float v38; // [esp+4h] [ebp-84Ch]
  int v39; // [esp+4h] [ebp-84Ch]
  _BYTE *v40; // [esp+4h] [ebp-84Ch]
  float v41; // [esp+8h] [ebp-848h]
  int v42; // [esp+8h] [ebp-848h]
  int v43; // [esp+Ch] [ebp-844h]
  int v44; // [esp+Ch] [ebp-844h]
  int v45; // [esp+10h] [ebp-840h]
  _BYTE *v46; // [esp+10h] [ebp-840h]
  int v47; // [esp+14h] [ebp-83Ch]
  int v48; // [esp+14h] [ebp-83Ch]
  int v49; // [esp+18h] [ebp-838h]
  int v50; // [esp+18h] [ebp-838h]
  int v51; // [esp+1Ch] [ebp-834h]
  int v52; // [esp+1Ch] [ebp-834h]
  float v53; // [esp+20h] [ebp-830h]
  int v54; // [esp+20h] [ebp-830h]
  int v55; // [esp+24h] [ebp-82Ch]
  int v56; // [esp+28h] [ebp-828h]
  int v57; // [esp+30h] [ebp-820h]
  int v58; // [esp+34h] [ebp-81Ch]
  long double v59; // [esp+38h] [ebp-818h]
  int v60; // [esp+38h] [ebp-818h]
  int v61; // [esp+40h] [ebp-810h]
  int v62; // [esp+44h] [ebp-80Ch]
  int v63; // [esp+48h] [ebp-808h]
  _BYTE *v64; // [esp+4Ch] [ebp-804h]
  int v65[256]; // [esp+50h] [ebp-800h] BYREF
  int v66[256]; // [esp+450h] [ebp-400h] BYREF

  v62 = dword_47847C;
  v64 = *(_BYTE **)(a1 + 12);
  v59 = (a2 * 0.0000152587890625 + a2 * 0.0000152587890625) * 3.141592653589793;
  v63 = *(_DWORD *)(a1 + 8);
  v41 = cos(v59) * a3;
  v3 = sin(v59) * a3;
  v38 = -v3;
  v53 = v3;
  v57 = (int)(v41 * 8.0);
  v60 = (int)(v53 * 8.0);
  v58 = (int)(v38 * 8.0);
  v56 = (int)(8.0 * v41);
  v4 = v57 >> 3;
  v5 = v58 >> 3;
  v6 = v60 >> 3;
  v7 = v56 >> 3;
  v54 = (int)(v41 * -160.0 - v53 * 100.0);
  v42 = (int)(-160.0 * v38 - 100.0 * v41);
  v47 = 0;
  v36 = 0;
  v43 = 2 * (v58 >> 3);
  v45 = 2 * (v57 >> 3);
  v51 = 4 * (v58 >> 3);
  v49 = 4 * (v57 >> 3);
  v39 = 6 * (v58 >> 3);
  v8 = 6 * (v57 >> 3);
  for ( i = 0; i < 64; i += 8 )
  {
    v65[i] = v47;
    v66[i] = v36;
    v65[i + 1] = v4 + v47;
    v66[i + 1] = v5 + v36;
    v65[i + 2] = v45;
    v66[i + 2] = v43;
    v65[i + 3] = v4 + v45;
    v66[i + 3] = v5 + v43;
    v65[i + 4] = v49;
    v47 += v6;
    v45 += v6;
    v36 += v7;
    v43 += v7;
    v66[i + 4] = v51;
    v10 = v49;
    v49 += v6;
    v65[i + 5] = v4 + v10;
    v11 = v51;
    v51 += v7;
    v66[i + 5] = v5 + v11;
    v66[i + 6] = v39;
    v65[i + 7] = v8 + v4;
    v12 = v39;
    v39 += v7;
    v65[i + 6] = v8;
    v66[i + 7] = v5 + v12;
    v8 += v6;
  }
  result = ((*(int *)(a1 + 4) >> 31) & 7) + *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 4) / 8 > 0 )
  {
    v14 = v42;
    result = *(_DWORD *)a1 / 8;
    v61 = result;
    v40 = v64;
    v55 = *(_DWORD *)(a1 + 4) / 8;
    do
    {
      v15 = v54;
      v44 = v54;
      v50 = v14;
      if ( result > 0 )
      {
        v16 = v40;
        v46 = v40;
        v48 = result;
        do
        {
          if ( (unsigned int)(v15 + 20480) > 0xC800 || (unsigned int)(v14 + 33280) > 0xAA00 )
          {
            v34 = 8;
            do
            {
              *(_DWORD *)v16 = 0;
              *((_DWORD *)v16 + 1) = 0;
              v16 += 320;
              --v34;
            }
            while ( v34 );
          }
          else
          {
            v17 = (unsigned __int8)v14;
            v18 = (unsigned __int8)v15;
            v37 = (unsigned __int8)v14;
            v19 = (v15 >> 8) + v62 + (v14 & 0xFFFFFF00) + 32896;
            v20 = v65;
            v21 = v66;
            v52 = 8;
            while ( 1 )
            {
              *v16 = *(_BYTE *)(((v18 + *v20) >> 8) + v19 + ((v17 + *v21) & 0xFFFFFF00));
              v16[1] = *(_BYTE *)(((v18 + v20[1]) >> 8) + v19 + ((v37 + v21[1]) & 0xFFFFFF00));
              v22 = v21 + 1;
              v23 = v20 + 1;
              v24 = v19 + ((v37 + v22[1]) & 0xFFFFFF00);
              v25 = v16 + 1;
              ++v22;
              v25[1] = *(_BYTE *)(((v18 + v23[1]) >> 8) + v24);
              ++v23;
              ++v25;
              v26 = v19 + ((v37 + v22[1]) & 0xFFFFFF00);
              ++v22;
              v27 = v18 + v23[1];
              ++v23;
              LOBYTE(v26) = *(_BYTE *)((v27 >> 8) + v26);
              v28 = v23[1];
              *++v25 = v26;
              v29 = (v37 + v22[1]) & 0xFFFFFF00;
              ++v22;
              ++v23;
              LOBYTE(v29) = *(_BYTE *)(((v18 + v28) >> 8) + v19 + v29);
              v30 = v23[1];
              v25[1] = v29;
              v31 = v37 + v22[1];
              ++v25;
              ++v22;
              ++v23;
              LOBYTE(v31) = *(_BYTE *)(((v18 + v30) >> 8) + v19 + (v31 & 0xFFFFFF00));
              v32 = v23[1];
              v25[1] = v31;
              v33 = v37 + v22[1];
              ++v22;
              ++v23;
              v25 += 2;
              *v25++ = *(_BYTE *)(((v18 + v32) >> 8) + v19 + (v33 & 0xFFFFFF00));
              *v25 = *(_BYTE *)(((v18 + v23[1]) >> 8) + v19 + ((v37 + v22[1]) & 0xFFFFFF00));
              v21 = v22 + 2;
              v20 = v23 + 2;
              v16 = &v25[v63 - 7];
              if ( !--v52 )
                break;
              v17 = v37;
            }
            v15 = v44;
            v14 = v50;
            result = v61;
          }
          v15 += v57;
          v14 += v58;
          v16 = v46 + 8;
          v35 = v48-- == 1;
          v44 = v15;
          v50 = v14;
          v46 += 8;
        }
        while ( !v35 );
        v14 = v42;
      }
      v14 += v56;
      v54 += v60;
      v40 += 2560;
      v35 = v55-- == 1;
      v42 = v14;
    }
    while ( !v35 );
  }
  return result;
}
// 47847C: using guessed type int dword_47847C;

//----- (00403EF0) --------------------------------------------------------
void *sub_403EF0()
{
  void *v0; // ebp
  size_t *v1; // esi
  char *v2; // eax
  signed int v3; // ebx
  bool v4; // cc
  char *v5; // edi
  int v6; // edx
  int v8[5]; // [esp+10h] [ebp-14h] BYREF

  v0 = malloc(4u);
  sub_4023D0((int)v8, (int)&dword_478480, "rotozoom.png");
  v1 = (size_t *)malloc(0x10u);
  *v1 = 256;
  v1[1] = 512;
  v1[2] = 256;
  v2 = (char *)malloc(0x20000u);
  v3 = 0;
  v1[3] = (size_t)v2;
  v4 = (int)v1[1] <= 0;
  dword_478460 = (int)v1;
  v5 = v2;
  if ( !v4 )
  {
    do
    {
      memset(v5, 0, *v1);
      v5 += v1[2];
      ++v3;
    }
    while ( v3 < (int)v1[1] );
  }
  sub_402150((int *)v1, 0, v8, 128);
  v6 = v1[3] + (v1[2] << 7);
  dword_478470 = 256;
  dword_478474 = 256;
  dword_47847C = v6;
  dword_478478 = v1[2];
  return v0;
}
// 478460: using guessed type int dword_478460;
// 478470: using guessed type int dword_478470;
// 478474: using guessed type int dword_478474;
// 478478: using guessed type int dword_478478;
// 47847C: using guessed type int dword_47847C;

//----- (00403FB0) --------------------------------------------------------
int __cdecl sub_403FB0(size_t *a1)
{
  int v1; // edi
  char *v2; // esi
  size_t v3; // ebx
  size_t v4; // ebp
  float v6; // [esp+4h] [ebp-1Ch]
  float v7; // [esp+1Ch] [ebp-4h]
  float v8; // [esp+1Ch] [ebp-4h]

  if ( dword_41C370 )
  {
    v1 = a1[1];
    v2 = (char *)a1[3];
    dword_41C370 = 0;
    if ( v1 > 0 )
    {
      v3 = *a1;
      v4 = a1[2];
      do
      {
        memset(v2, 0, v3);
        v2 += v4;
        --v1;
      }
      while ( v1 );
    }
    sub_402230(&dword_478480, 128);
  }
  flt_41CEB4 = flt_41CEB4 + 1.0;
  v7 = cos(flt_41CEB4 * 0.03125) * 256.0 + 384.0;
  v6 = v7;
  v8 = sin(flt_41CEB4 * 0.015625) * 65535.0;
  return sub_403A50((int)a1, v8, v6);
}
// 41C370: using guessed type int dword_41C370;
// 41CEB4: using guessed type float flt_41CEB4;

//----- (00404080) --------------------------------------------------------
_DWORD *sub_404080()
{
  _DWORD *v0; // ebp
  int *v1; // esi
  void *v2; // eax
  _DWORD *v3; // ecx
  int *v4; // eax
  int v5; // ecx
  int *v6; // esi
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v11; // [esp-1Ch] [ebp-28h]

  v0 = malloc(4u);
  memset(&unk_468280, 0, 0xFA00u);
  v1 = (int *)malloc(0x10u);
  *v1 = 4096;
  v1[1] = 60;
  v1[2] = 4096;
  v2 = malloc(0x3C000u);
  v3 = (_DWORD *)dword_47883C;
  v1[3] = (int)v2;
  v11 = *v1;
  dword_458080 = (int)v1;
  sub_402070(0, v3, v1, v11);
  v4 = (int *)malloc(0xC00u);
  *v0 = v4;
  v5 = -3;
  v6 = v4;
  do
  {
    if ( v5 - 2 <= 63 )
      v7 = (v5 - 2) & ((v5 - 2 < 0) - 1);
    else
      v7 = 63;
    *v6 = v7;
    if ( v5 <= 63 )
      v8 = v5 < 0 ? 0 : v5;
    else
      v8 = 63;
    v6[1] = v8;
    v9 = v5 + 3;
    ++v5;
    v6[2] = v9;
    v6 += 3;
  }
  while ( v5 + 3 < 64 );
  v4[192] = 14;
  v4[193] = 14;
  v4[194] = 14;
  v4[195] = 28;
  v4[196] = 28;
  v4[197] = 28;
  v4[576] = 14;
  v4[577] = 6;
  v4[578] = 6;
  v4[579] = 27;
  v4[580] = 18;
  v4[581] = 18;
  dword_458060[0] = 0;
  dword_458064 = 0;
  dword_458068 = 0;
  dword_45806C[0] = 0;
  dword_468270[0] = 0;
  dword_468274 = 0;
  dword_468278 = 0;
  dword_46827C = 0;
  dword_458070[0] = 0;
  dword_458074[0] = 0;
  dword_458078 = 0;
  dword_45807C = 0;
  return v0;
}
// 458060: using guessed type int dword_458060[];
// 458064: using guessed type int dword_458064;
// 458068: using guessed type int dword_458068;
// 45806C: using guessed type int dword_45806C[];
// 458070: using guessed type int dword_458070[];
// 458074: using guessed type int dword_458074[];
// 458078: using guessed type int dword_458078;
// 45807C: using guessed type int dword_45807C;
// 458080: using guessed type int dword_458080;
// 468270: using guessed type int dword_468270[];
// 468274: using guessed type int dword_468274;
// 468278: using guessed type int dword_468278;
// 46827C: using guessed type int dword_46827C;
// 47883C: using guessed type int dword_47883C;

//----- (004041E0) --------------------------------------------------------
int __cdecl sub_4041E0(char *a1, int a2)
{
  char *v2; // edx
  int v3; // ebx
  char *v4; // eax
  const void *v5; // esi
  char *v6; // edi
  int result; // eax
  int v8; // ebp
  _BYTE *v9; // edi
  char *v10; // esi
  _BYTE *v11; // ecx
  char *v13; // [esp+14h] [ebp-18h]
  int v14; // [esp+18h] [ebp-14h]
  int v15; // [esp+24h] [ebp-8h]
  char *v16; // [esp+34h] [ebp+8h]

  v2 = a1;
  v3 = dword_458080;
  v15 = *(_DWORD *)(dword_458080 + 12);
  v4 = (char *)&unk_468280;
  do
  {
    v5 = v4;
    v6 = v2;
    v4 += 330;
    v2 += 320;
    qmemcpy(v6, v5, 0x140u);
  }
  while ( (int)v4 < (int)flt_478450 );
  result = 1;
  if ( a2 == 1 )
  {
    ++dword_41CEBC;
    result = (int)(sin((double)dword_41CEBC / 50.0) * 100.0 + (double)dword_41CEBC * 2.5);
    v8 = 0;
    v14 = result;
    if ( *(int *)(v3 + 4) > 0 )
    {
      v13 = (char *)&unk_45E7C0;
      v16 = a1 + 25600;
      do
      {
        v9 = v13;
        v10 = v16;
        v11 = (_BYTE *)(v15 + v14 + v8 * *(_DWORD *)(v3 + 8));
        result = 319;
        do
        {
          if ( !*v9++ )
          {
            if ( *v11 )
            {
              *v10 = *v11 | v9[9];
              v3 = dword_458080;
            }
          }
          ++v10;
          ++v11;
          --result;
        }
        while ( result );
        v16 += 320;
        v13 += 330;
        ++v8;
      }
      while ( v8 < *(_DWORD *)(v3 + 4) );
    }
  }
  return result;
}
// 41CEBC: using guessed type int dword_41CEBC;
// 458080: using guessed type int dword_458080;
// 478450: using guessed type float flt_478450[];

//----- (004042F0) --------------------------------------------------------
int __usercall sub_4042F0@<eax>(int a1@<edx>, char **a2@<ecx>, int a3, int a4, int a5)
{
  double v6; // st6
  int v7; // eax
  double v8; // st3
  int v9; // edx
  int v10; // eax
  unsigned int v11; // esi
  float *v12; // ecx
  double v13; // rt0
  double v14; // st3
  double v15; // st6
  double v16; // rtt
  double v17; // rt2
  double v18; // rtt
  double v19; // rt0
  double v20; // st3
  double v21; // st6
  double v22; // rtt
  int v23; // edi
  double v24; // st7
  double v25; // st6
  int v26; // edx
  int v27; // esi
  double v28; // st3
  double v29; // rt2
  double v30; // rtt
  double v31; // st3
  double v32; // st6
  double v33; // rt2
  double v34; // st7
  bool v35; // c0
  bool v36; // c3
  double v37; // st7
  double v38; // st6
  int v39; // esi
  double v40; // st4
  double v41; // st5
  double v42; // st7
  double v43; // st7
  int v44; // edx
  int v45; // eax
  int v46; // ecx
  int result; // eax
  float v48; // [esp+10h] [ebp-370h]
  float v49; // [esp+10h] [ebp-370h]
  float v50; // [esp+10h] [ebp-370h]
  float v51; // [esp+10h] [ebp-370h]
  float v52; // [esp+10h] [ebp-370h]
  float v53; // [esp+10h] [ebp-370h]
  float v54; // [esp+10h] [ebp-370h]
  float v55; // [esp+10h] [ebp-370h]
  float v56; // [esp+10h] [ebp-370h]
  double v57; // [esp+10h] [ebp-370h]
  float v58; // [esp+10h] [ebp-370h]
  int v59; // [esp+1Ch] [ebp-364h]
  float v60; // [esp+1Ch] [ebp-364h]
  float v61; // [esp+1Ch] [ebp-364h]
  float v62; // [esp+1Ch] [ebp-364h]
  float v63; // [esp+1Ch] [ebp-364h]
  float v64; // [esp+1Ch] [ebp-364h]
  double v65; // [esp+20h] [ebp-360h]
  float v66; // [esp+20h] [ebp-360h]
  float v67; // [esp+20h] [ebp-360h]
  float v68; // [esp+20h] [ebp-360h]
  float v69; // [esp+20h] [ebp-360h]
  double v70; // [esp+28h] [ebp-358h]
  double v71; // [esp+28h] [ebp-358h]
  double v72; // [esp+28h] [ebp-358h]
  float v73; // [esp+30h] [ebp-350h]
  double v74; // [esp+38h] [ebp-348h]
  double v75; // [esp+40h] [ebp-340h]
  double v76; // [esp+48h] [ebp-338h]
  double v77; // [esp+50h] [ebp-330h]
  char v78[400]; // [esp+58h] [ebp-328h] BYREF
  char v79[404]; // [esp+1E8h] [ebp-198h] BYREF

  if ( dword_41C36C )
  {
    dword_41C36C = 0;
    sub_402230(a2, 194);
  }
  if ( dword_41CEB8 )
  {
    byte_478520[0] = 0;
    byte_478521[0] = 0;
    byte_478522[0] = 63;
  }
  memset(v78, 0, sizeof(v78));
  memset(v79, 0, 0x190u);
  v6 = 1.0;
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      *(float *)dword_458060 = *(float *)dword_458060 + 1.0;
      *(float *)&dword_458064 = *(float *)&dword_458064 + 1.0;
      *(float *)&dword_458068 = *(float *)&dword_458068 + 1.0;
      *(float *)dword_45806C = *(float *)dword_45806C + 1.0;
      if ( a1 <= 4 )
        v7 = a1 < 0 ? 0 : a1;
      else
        v7 = 4;
      v8 = 0.0125;
      v9 = 3 - v7;
      v10 = 3 - v7 + 1;
      if ( v10 >= 4 )
      {
        v11 = (unsigned int)v10 >> 2;
        v12 = (float *)(4 * v9 + 4554856);
        v9 -= 4 * ((unsigned int)v10 >> 2);
        do
        {
          v48 = v12[2] - v8;
          if ( v48 <= 1.0 )
          {
            if ( v48 < 0.0 )
              v48 = 0.0;
            v16 = v8;
            v14 = v6;
            v15 = v16;
          }
          else
          {
            v13 = v8;
            v14 = v6;
            v15 = v13;
            v48 = v14;
          }
          v12[2] = v48;
          v49 = v12[1] - v15;
          if ( v49 <= 1.0 )
          {
            if ( v49 < 0.0 )
              v49 = 0.0;
          }
          else
          {
            v49 = v14;
          }
          v12[1] = v49;
          v50 = *v12 - v15;
          if ( v50 <= 1.0 )
          {
            if ( v50 < 0.0 )
              v50 = 0.0;
          }
          else
          {
            v50 = v14;
          }
          *v12 = v50;
          v51 = *(v12 - 1) - v15;
          if ( v51 <= 1.0 )
          {
            if ( v51 < 0.0 )
              v51 = 0.0;
          }
          else
          {
            v51 = v14;
          }
          v12 -= 4;
          --v11;
          v12[3] = v51;
          v17 = v14;
          v8 = v15;
          v6 = v17;
        }
        while ( v11 );
      }
      if ( v9 >= 0 )
      {
        while ( 1 )
        {
          v52 = *(float *)&dword_458070[v9] - v8;
          if ( v52 <= 1.0 )
          {
            if ( v52 < 0.0 )
              v52 = 0.0;
            v22 = v8;
            v20 = v6;
            v21 = v22;
          }
          else
          {
            v19 = v8;
            v20 = v6;
            v21 = v19;
            v52 = v20;
          }
          *(float *)&dword_458074[--v9] = v52;
          if ( v9 < 0 )
            break;
          v18 = v20;
          v8 = v21;
          v6 = v18;
        }
      }
    }
  }
  else
  {
    v27 = sub_4022A0(4, a1);
    if ( v27 > 0 )
    {
      v28 = 0.0125;
      memset32(dword_468270, 1, v27);
      while ( 1 )
      {
        v63 = *(float *)&dword_458070[v26] + v28;
        if ( v63 <= 1.0 )
        {
          v55 = v63 >= 0.0 ? (float)(*(float *)&dword_458070[v26] + v28) : (float)0.0;
          v33 = v28;
          v31 = v6;
          v32 = v33;
        }
        else
        {
          v30 = v28;
          v31 = v6;
          v32 = v30;
          v55 = v31;
        }
        *(float *)&dword_45806C[++v26] = v55;
        flt_45805C[v26] = flt_45805C[v26] + 1.0;
        if ( v26 >= v27 )
          break;
        v29 = v31;
        v28 = v32;
        v6 = v29;
      }
    }
  }
  v23 = 0;
  v59 = 0;
  do
  {
    v65 = (double)v59;
    v70 = *(float *)&dword_458060[v23];
    v60 = v65 * 1.8 - (v65 + 3.0) * (v70 / 40.0) / 7.0;
    v53 = sin(v60) * 0.8 + sin(v70 / 19.0) * ((2.0 - v65) * 0.2 / 6.0);
    v61 = cos(v60) * 0.8 + cos(v70 / 17.0) * ((3.0 - v65) * 0.2 / 5.0);
    v62 = v61 * 160.0 + 200.0;
    if ( dword_468270[v23] )
      flt_478450[v23] = v62;
    v74 = v62;
    v71 = v53;
    v75 = v53 + 2.0;
    v54 = *(float *)&dword_458070[v23];
    if ( v54 <= 1.0 )
    {
      if ( v54 >= 0.0 )
      {
        v25 = v54;
        v24 = 1.0;
      }
      else
      {
        v24 = 1.0;
        v25 = 0.0;
      }
    }
    else
    {
      v24 = 1.0;
      v25 = 1.0;
    }
    v56 = v25;
    v66 = v75 * 5.0;
    v67 = v56 * v66;
    v73 = (flt_478450[v23] - v62) * 0.5;
    v68 = sqrt(v24 + v73 * v73) * v67;
    v34 = v68;
    v77 = v68;
    if ( v68 >= 0.01 )
    {
      flt_478450[v23] = v62;
      v35 = v34 > 80.0;
      v36 = 80.0 == v34;
      v37 = v68;
      if ( !v35 && !v36 )
      {
        v38 = v62;
        v39 = (int)(v74 - v37);
        v76 = v37 + v74;
        v40 = (double)v39;
        if ( v40 < v76 )
        {
          v41 = v68;
          v42 = v40;
          v72 = v71 * 90.0 + 127.0;
          while ( 1 )
          {
            v57 = v42 - v38;
            v64 = sqrt((v41 + 1.0) * (v41 + 1.0) - v57 * v57) * 0.5 + v72;
            if ( v64 > (double)(unsigned __int8)v79[v39] )
            {
              v69 = cos(v57 / v77 * 0.45 * 3.141592653589793) * 63.0 * v75 * 0.25;
              if ( v69 <= 63.0 )
              {
                v43 = v69;
                if ( v69 < 0.0 )
                  v43 = 0.0;
              }
              else
              {
                v43 = 63.0;
              }
              v58 = v43;
              v78[v39] = (int)v58;
              v79[v39] = (int)v64;
            }
            v42 = (double)++v39;
            if ( v76 <= v42 )
              break;
            v38 = v74;
          }
        }
      }
    }
    v59 = ++v23;
  }
  while ( v23 < 4 );
  dword_41C368 = 0;
  if ( dword_41CEB8 )
  {
    byte_478520[0] = 0;
    byte_478521[0] = 63;
    byte_478522[0] = 63;
  }
  v44 = 0;
  if ( *(int *)(a3 + 4) > 0 )
  {
    v45 = 0;
    do
    {
      qmemcpy((char *)&unk_468280 + v45, (char *)&unk_468280 + v45 + 1, 0x149u);
      qmemcpy((char *)&unk_4580A0 + v45, (char *)&unk_4580A1 + v45, 0x148u);
      v46 = (unsigned __int8)v78[2 * v44 + 1];
      *((_BYTE *)&unk_4580A0 + v45 + 328) = *((_BYTE *)&unk_4580A1 + v45 + 328);
      byte_4683C9[v45] = ((unsigned __int8)v78[2 * v44] + v46) >> 1;
      byte_4581E9[v45] = v79[2 * v44++] & 0x80;
      v45 += 330;
    }
    while ( v44 < *(_DWORD *)(a3 + 4) );
  }
  if ( dword_41CEB8 )
  {
    byte_478520[0] = 0;
    byte_478521[0] = 63;
    byte_478522[0] = 0;
  }
  result = sub_4041E0(*(char **)(a3 + 12), a5);
  byte_478520[0] = 0;
  byte_478521[0] = 0;
  byte_478522[0] = 0;
  dword_478508 = 1;
  return result;
}
// 40471A: variable 'v26' is possibly undefined
// 41C368: using guessed type int dword_41C368;
// 41C36C: using guessed type int dword_41C36C;
// 41CEB8: using guessed type int dword_41CEB8;
// 45805C: using guessed type float flt_45805C[];
// 458060: using guessed type int dword_458060[];
// 458064: using guessed type int dword_458064;
// 458068: using guessed type int dword_458068;
// 45806C: using guessed type int dword_45806C[];
// 458070: using guessed type int dword_458070[];
// 458074: using guessed type int dword_458074[];
// 468270: using guessed type int dword_468270[];
// 478450: using guessed type float flt_478450[];
// 478508: using guessed type int dword_478508;

//----- (00404A70) --------------------------------------------------------
int sub_404A70()
{
  int v0; // esi
  int result; // eax
  int v2; // [esp+8h] [ebp-1Ch]
  long double v3; // [esp+8h] [ebp-1Ch]
  double v4; // [esp+18h] [ebp-Ch]

  v0 = 0;
  v2 = 0;
  do
  {
    v4 = (double)v2;
    byte_42CF00[v0] = (int)(cos(v4 / 170.4) * (sin((v4 / 119.34 + v4 / 119.34) * 3.141592653589793) * 25.0)
                          + cos(v4 / 145.4) * 10.0
                          + sin((v4 / 365.4 + v4 / 365.4) * 3.141592653589793) * 15.0
                          + 60.0);
    byte_41CF00[v0] = (int)(cos(v4 / 90.40000000000001) * (sin((v4 / 819.34 + v4 / 819.34) * 3.141592653589793) * 25.0)
                          + cos(v4 / 635.4) * 10.0
                          + sin((v4 / 235.4 + v4 / 235.4) * 3.141592653589793) * 15.0
                          + 60.0);
    v3 = cos(v4 / 345.4) * 10.0 + sin((v4 / 265.4 + v4 / 265.4) * 3.141592653589793) * 15.0;
    ++v0;
    result = LOWORD(v3) | 0xC00;
    byte_44805F[v0] = (int)(cos(v4 / 70.40000000000001) * (sin((v4 / 319.34 + v4 / 319.34) * 3.141592653589793) * 25.0)
                          + v3
                          + 60.0);
    v2 = v0;
  }
  while ( v0 < 0x10000 );
  return result;
}

//----- (00404C90) --------------------------------------------------------
_DWORD *__cdecl sub_404C90(float a1)
{
  int v1; // eax
  double v2; // st7
  int v3; // edi
  char *v4; // ebx
  int v5; // eax
  unsigned __int8 *v6; // esi
  int v7; // ebp
  unsigned __int8 *v8; // edx
  _DWORD *result; // eax
  unsigned __int8 *v10; // ecx
  int v11; // ebx
  int v12; // ebp
  int v13; // ebx
  int v14; // ebp
  int v15; // ebx
  int v16; // ebp
  int v17; // ebx
  int v18; // ebp
  int v19; // [esp+10h] [ebp-30h]
  _DWORD *v20; // [esp+14h] [ebp-2Ch]
  int v21; // [esp+18h] [ebp-28h]
  char *v22; // [esp+1Ch] [ebp-24h]
  char *v23; // [esp+20h] [ebp-20h]
  int v24; // [esp+24h] [ebp-1Ch]
  double v25; // [esp+28h] [ebp-18h]
  char *v26; // [esp+28h] [ebp-18h]

  v19 = 0;
  v1 = (int)((sin((double)dword_41CEC8 / 240.1) * 100.0 + 100.0) * a1);
  v2 = (double)dword_41CEC0;
  v23 = &byte_42CF00[v1];
  v22 = (char *)&unk_42CF02 + v1;
  v20 = &unk_43D064;
  v3 = -35000;
  do
  {
    v25 = (double)v19;
    v4 = &byte_41CF00[(int)(sin(v25 / 4.3 + v2 / 223.2) * 800.0 + 1400.0)];
    v5 = (int)(sin(v25 / 3.1 + v2 / 289.4) * 900.0 + 1900.0);
    v6 = (unsigned __int8 *)v22;
    v26 = (char *)((_UNKNOWN *)((char *)&unk_448060 + v5) - (_UNKNOWN *)v4);
    v7 = v23 - v4;
    v8 = (unsigned __int8 *)&unk_448062 + v5;
    result = v20;
    v10 = (unsigned __int8 *)v4;
    v24 = v23 - v4;
    v21 = 64;
    while ( 1 )
    {
      v11 = *v10 + (unsigned __int8)v26[(_DWORD)v10] + v10[v7];
      v12 = *(v6 - 1);
      *(result - 1) = v3 + (v11 << 7);
      v13 = v10[1] + v12 + *(v8 - 1);
      v14 = *v6;
      *result = v3 + (v13 << 7);
      v15 = *v8 + v14 + v10[2];
      v16 = v6[1];
      result[1] = v3 + (v15 << 7);
      v17 = v10[3] + v16 + v8[1];
      v18 = v6[2];
      result[2] = v3 + (v17 << 7);
      result[3] = v3 + ((v10[4] + v18 + v8[2]) << 7);
      result += 5;
      v8 += 5;
      v10 += 5;
      v6 += 5;
      if ( !--v21 )
        break;
      v7 = v24;
    }
    ++v19;
    v20 += 1024;
    v3 += 4000;
  }
  while ( v3 < 5000 );
  return result;
}
// 41CEC0: using guessed type int dword_41CEC0;
// 41CEC8: using guessed type int dword_41CEC8;

//----- (00404E40) --------------------------------------------------------
_BYTE *sub_404E40()
{
  int *v0; // ebp
  int v1; // ecx
  int v2; // esi
  int v3; // edi
  int v4; // ebx
  int v5; // esi
  int v6; // eax
  int v7; // ebp
  _BYTE *v8; // ecx
  int v9; // edi
  int v10; // edi
  int i; // esi
  int v12; // esi
  int v13; // ecx
  _BYTE *result; // eax
  int v15; // edx
  int *v16; // [esp+10h] [ebp-18h]
  int v17; // [esp+14h] [ebp-14h]
  int v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+1Ch] [ebp-Ch]
  int v20; // [esp+20h] [ebp-8h]
  int *v21; // [esp+24h] [ebp-4h]

  v0 = (int *)&unk_43E060;
  v17 = 0;
  v21 = (int *)&unk_43E060;
  do
  {
    v1 = *(v0 - 1024);
    v2 = 512;
    v19 = 0;
    v20 = 512;
    v16 = v0;
    do
    {
      v3 = *v16;
      v4 = (*v16 - v1) / 8 - v2 + 5376;
      v18 = *v16;
      if ( v1 < *v16 )
      {
        v5 = 200 - v1 / 256;
        v6 = 200 - v3 / 256;
        v7 = v4;
        v8 = (_BYTE *)(v17 + dword_43D040 + 320 * v6);
        if ( v5 > v6 && v6 <= 180 )
        {
          v9 = 180;
          if ( v5 <= 180 )
            v9 = v5;
          v10 = v9 - v6;
          for ( i = (v19 - v4) / (v5 - v6); v10; v8 += 320 )
          {
            --v10;
            *v8 = BYTE1(v7);
            v7 += i;
          }
          v3 = v18;
        }
        v0 = v21;
        v2 = v20;
        v1 = v3;
      }
      v16 += 1024;
      v2 += 512;
      v19 = v4;
      v20 = v2;
    }
    while ( v2 < 5120 );
    v12 = (unsigned __int8)byte_43CF00[v17];
    v13 = 200 - v1 / 256;
    result = (_BYTE *)(v17 + dword_43D040 + 320 * v13);
    if ( v13 > v12 )
    {
      v15 = v13 - v12;
      do
      {
        result -= 320;
        --v15;
        *result = 0;
      }
      while ( v15 );
    }
    ++v0;
    byte_43CF00[v17++] = v13;
    v21 = v0;
  }
  while ( (int)v0 < (int)&unk_43E560 );
  return result;
}
// 43D040: using guessed type int dword_43D040;

//----- (00404FD0) --------------------------------------------------------
_DWORD *sub_404FD0()
{
  _DWORD *v0; // edi
  _DWORD *v1; // eax
  int v2; // ecx
  int v3; // edx

  memset(byte_43CF00, 0, sizeof(byte_43CF00));
  v0 = malloc(4u);
  sub_404A70();
  v1 = malloc(0xC00u);
  *v0 = v1;
  v2 = 3;
  v3 = 64;
  do
  {
    *v1 = v2 - 2;
    v1[1] = v2;
    v1[2] = v2 + 3;
    ++v2;
    v1 += 3;
    --v3;
  }
  while ( v3 );
  return v0;
}

//----- (00405030) --------------------------------------------------------
_BYTE *__cdecl sub_405030(int a1, int a2)
{
  char **v2; // ecx
  float v4; // [esp+10h] [ebp+8h]

  if ( dword_41C364 )
  {
    dword_41C364 = 0;
    sub_402230(v2, 128);
  }
  ++dword_41CEC8;
  if ( a2 )
  {
    dword_41CEC8 = 0;
    flt_41CEC4 = 1.0;
  }
  ++dword_41CEC0;
  dword_43D040 = *(_DWORD *)(a1 + 12);
  flt_41CEC4 = flt_41CEC4 * 0.95;
  v4 = 1.0 / (sin((1.0 - flt_41CEC4) * 6.283185307179586 + 1.570796326794897) + 1.75) - 0.36;
  sub_404C90(v4);
  return sub_404E40();
}
// 405049: variable 'v2' is possibly undefined
// 41C364: using guessed type int dword_41C364;
// 41CEC0: using guessed type int dword_41CEC0;
// 41CEC4: using guessed type float flt_41CEC4;
// 41CEC8: using guessed type int dword_41CEC8;
// 43D040: using guessed type int dword_43D040;

//----- (00405120) --------------------------------------------------------
int __cdecl sub_405120(int a1, int a2)
{
  int result; // eax

  if ( a1 && a2 )
    result = *(_DWORD *)(a2 + 12);
  else
    result = 0;
  return result;
}

//----- (00405140) --------------------------------------------------------
int __cdecl sub_405140(int *a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9)
{
  if ( !a1 || !a2 || !a3 || !a4 || !a5 || !a6 )
    return 0;
  *a3 = *(_DWORD *)a2;
  *a4 = *(_DWORD *)(a2 + 4);
  *a5 = *(unsigned __int8 *)(a2 + 24);
  if ( !*(_BYTE *)(a2 + 24) || *(_BYTE *)(a2 + 24) > 0x10u )
    sub_408740(a1, "Invalid bit depth");
  *a6 = *(unsigned __int8 *)(a2 + 25);
  if ( *(_BYTE *)(a2 + 25) > 6u )
    sub_408740(a1, "Invalid color type");
  if ( a8 )
    *a8 = *(unsigned __int8 *)(a2 + 26);
  if ( a9 )
    *a9 = *(unsigned __int8 *)(a2 + 27);
  if ( a7 )
    *a7 = *(unsigned __int8 *)(a2 + 28);
  if ( !*a3 || *a3 > 0x7FFFFFFFu )
    sub_408740(a1, "Invalid image width");
  if ( !*a4 || *a4 > 0x7FFFFFFFu )
    sub_408740(a1, "Invalid image height");
  if ( *(_DWORD *)a2 > 0x1FFFFF7Eu )
    sub_4087F0((int)a1, "Width too large for libpng to process image data.");
  return 1;
}

//----- (00405270) --------------------------------------------------------
int __cdecl sub_405270(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 8) == 0 || !a3 )
    return 0;
  *a3 = *(_DWORD *)(a2 + 16);
  *a4 = *(unsigned __int16 *)(a2 + 20);
  return 8;
}

//----- (004052B0) --------------------------------------------------------
void **__cdecl sub_4052B0(char *a1, int a2, int a3, int a4, int a5, int (__cdecl *a6)(char *, size_t), int a7)
{
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  void **result; // eax
  const char *v10; // eax
  bool v12; // zf
  char v13; // al
  void **Block; // [esp+28h] [ebp-58h]
  char Buffer[80]; // [esp+2Ch] [ebp-54h] BYREF

  v7 = sub_408980(1, a6, a5);
  v8 = v7;
  Block = (void **)v7;
  if ( !v7 )
    return 0;
  sub_408390((int)v7);
  v8[153] = 1000000;
  v8[154] = 1000000;
  if ( setjmp3(v8, 0) )
  {
    sub_408BF0((int)Block, Block[43]);
    Block[43] = 0;
    sub_408A30(Block, a7, a5);
    return 0;
  }
  sub_408B30(Block, a5, (int)a6, a7);
  sub_408720(Block, a2, a3, a4);
  v10 = "1.2.8";
  do
  {
    if ( v10[a1 - "1.2.8"] != *v10 )
      Block[27] = (void *)((unsigned int)Block[27] | 0x20000);
  }
  while ( *v10++ );
  if ( ((unsigned int)Block[27] & 0x20000) != 0 )
  {
    v12 = a1 == 0;
    if ( !a1 )
      goto LABEL_17;
    v13 = *a1;
    if ( *a1 != a128_0[0] || v13 == 49 && a1[2] != a128_0[2] || v13 == 48 && a1[2] < 57 )
    {
      v12 = a1 == 0;
LABEL_17:
      if ( !v12 )
      {
        sprintf(Buffer, "Application was compiled with png.h from libpng-%.20s", a1);
        sub_4087F0((int)Block, Buffer);
      }
      sprintf(Buffer, "Application  is  running with png.c from libpng-%.20s", "1.2.8");
      sub_4087F0((int)Block, Buffer);
      Block[27] = 0;
      sub_408740((int *)Block, "Incompatible libpng version in application and library");
    }
  }
  Block[44] = (void *)0x2000;
  Block[43] = sub_408BA0((int)Block, 0x2000u);
  Block[37] = sub_407D70;
  Block[38] = sub_407DC0;
  Block[39] = Block;
  switch ( sub_412C20(Block + 29, "1.2.3", 56) )
  {
    case -6:
      sub_408740((int *)Block, "zlib version error");
    case -4:
    case -2:
      sub_408740((int *)Block, "zlib memory error");
    case 0:
      Block[32] = Block[43];
      Block[33] = Block[44];
      sub_408920(Block, 0, 0);
      if ( setjmp3(Block, 0) )
        abort();
      result = Block;
      break;
    default:
      sub_408740((int *)Block, "Unknown zlib error");
  }
  return result;
}
// 412500: using guessed type int __cdecl setjmp3(_DWORD, _DWORD);

//----- (00405510) --------------------------------------------------------
int __cdecl sub_405510(char *EndPtr, int a2)
{
  int *v2; // ebx
  unsigned __int8 v3; // al
  unsigned int v4; // edi
  unsigned int v5; // esi
  unsigned __int8 *v6; // edi
  unsigned int v7; // ebp
  int result; // eax
  unsigned __int8 v9[4]; // [esp+10h] [ebp-4h] BYREF

  v2 = (int *)EndPtr;
  v3 = EndPtr[300];
  if ( v3 < 8u )
  {
    v4 = v3;
    v5 = 8 - v3;
    sub_4088C0((int *)EndPtr);
    EndPtr[300] = 8;
    if ( sub_407C40(a2 + 32, v4, v5) )
    {
      if ( v4 < 4 )
      {
        if ( sub_407C40(a2 + 32, v4, v5 - 4) )
          sub_408740((int *)EndPtr, "Not a PNG file");
      }
      sub_408740((int *)EndPtr, "PNG file corrupted by ASCII conversion");
    }
    if ( v4 < 3 )
      *((_DWORD *)EndPtr + 26) |= 0x1000u;
  }
  v6 = (unsigned __int8 *)(EndPtr + 284);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            sub_4088C0(v2);
            v7 = sub_409D20(v2, v9);
            sub_407DD0((int)v2);
            png_crc_read((struct png_struct_def *)v2, v6, 4u);
            if ( memcmp(v6, "IHDR", 4u) )
              break;
            v2 = (int *)EndPtr;
            sub_409E10((int)EndPtr, a2, v7);
          }
          if ( memcmp(v6, "IEND", 4u) )
            break;
          v2 = (int *)EndPtr;
          sub_40A120((int *)EndPtr, a2, v7);
        }
        if ( !sub_4082A0((int)EndPtr, v6) )
          break;
        v2 = (int *)EndPtr;
        if ( !memcmp(v6, "IDAT", 4u) )
          *((_DWORD *)EndPtr + 26) |= 4u;
        sub_40BF40((int)EndPtr, a2, v7);
        if ( !memcmp(v6, "PLTE", 4u) )
        {
          *((_DWORD *)EndPtr + 26) |= 2u;
        }
        else if ( !memcmp(v6, "IDAT", 4u) )
        {
          result = *((_DWORD *)EndPtr + 26);
          if ( (result & 1) == 0 )
            sub_408740((int *)EndPtr, "Missing IHDR before IDAT");
          if ( EndPtr[294] == 3 && (result & 2) == 0 )
            sub_408740((int *)EndPtr, "Missing PLTE before IDAT");
          return result;
        }
      }
      if ( memcmp(v6, "PLTE", 4u) )
        break;
      v2 = (int *)EndPtr;
      sub_409F90((int)EndPtr, a2, v7);
    }
    if ( !memcmp(v6, "IDAT", 4u) )
      break;
    if ( !memcmp(v6, "bKGD", 4u) )
    {
      v2 = (int *)EndPtr;
      png_handle_bKGD((struct png_struct_def *)EndPtr, (struct png_info_struct *)a2, v7);
    }
    else if ( !memcmp(v6, "cHRM", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40A450((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "gAMA", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40A170((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "hIST", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40B390((int)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "oFFs", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40B650((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "pCAL", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40B780((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "sCAL", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40B9E0(EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "pHYs", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40B530((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "sBIT", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40A2E0((int)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "sRGB", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40A940((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "iCCP", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40AB30((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "sPLT", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40ACE0((int *)EndPtr, a2, v7);
    }
    else if ( !memcmp(v6, "tEXt", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40BCC0((int)EndPtr, (_DWORD *)a2, v7);
    }
    else if ( !memcmp(v6, "tIME", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40BBA0((int)EndPtr, (_DWORD *)a2, v7);
    }
    else if ( !memcmp(v6, "tRNS", 4u) )
    {
      v2 = (int *)EndPtr;
      sub_40AF00((int)EndPtr, a2, v7);
    }
    else
    {
      v2 = (int *)EndPtr;
      if ( !memcmp(v6, "zTXt", 4u) )
        sub_40BDE0((int)EndPtr, (_DWORD *)a2, v7);
      else
        sub_40BF40((int)EndPtr, a2, v7);
    }
  }
  result = *((_DWORD *)EndPtr + 26);
  if ( (result & 1) == 0 )
    sub_408740((int *)EndPtr, "Missing IHDR before IDAT");
  if ( EndPtr[294] == 3 && (result & 2) == 0 )
    sub_408740((int *)EndPtr, "Missing PLTE before IDAT");
  *((_DWORD *)EndPtr + 26) |= 4u;
  *((_DWORD *)EndPtr + 67) = v7;
  return result;
}

//----- (004064B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_4064B0(int a1, void *a2, void *a3))(int, _DWORD, _DWORD)
{
  int v3; // esi
  void *v4; // eax
  int v5; // ecx
  int (__cdecl *result)(int, _DWORD, _DWORD); // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edi
  unsigned int v11; // eax
  unsigned int v12; // ecx
  unsigned __int8 *v13; // edx
  int v14; // eax
  char *v15; // eax
  int v16; // ecx
  char v17; // dl
  unsigned __int8 v18; // al
  unsigned int v19; // eax
  unsigned __int8 *v20; // eax

  v3 = a1;
  if ( (*(_BYTE *)(a1 + 108) & 0x40) == 0 )
    sub_409A60(a1);
  if ( *(_BYTE *)(v3 + 291) && (*(_BYTE *)(v3 + 112) & 2) != 0 )
  {
    switch ( *(_BYTE *)(v3 + 292) )
    {
      case 0:
        if ( (*(_BYTE *)(v3 + 228) & 7) == 0 )
          goto LABEL_32;
        v4 = a3;
        if ( !a3 )
          goto LABEL_10;
        v5 = 255;
        goto LABEL_9;
      case 1:
        if ( (*(_BYTE *)(v3 + 228) & 7) == 0 && *(_DWORD *)(v3 + 200) >= 5u )
          goto LABEL_32;
        if ( a3 )
          sub_409130(v3, a3, 15);
        goto LABEL_10;
      case 2:
        v7 = *(_DWORD *)(v3 + 228);
        if ( (v7 & 7) == 4 )
          goto LABEL_32;
        if ( a3 && (v7 & 4) != 0 )
          goto LABEL_18;
        goto LABEL_10;
      case 3:
        if ( (*(_BYTE *)(v3 + 228) & 3) == 0 && *(_DWORD *)(v3 + 200) >= 3u )
          goto LABEL_32;
        v4 = a3;
        if ( !a3 )
          goto LABEL_10;
        v5 = 51;
        goto LABEL_9;
      case 4:
        v8 = *(_DWORD *)(v3 + 228);
        if ( (v8 & 3) == 2 )
          goto LABEL_32;
        if ( !a3 || (v8 & 2) == 0 )
          goto LABEL_10;
LABEL_18:
        sub_409130(v3, a3, 255);
        result = (int (__cdecl *)(int, _DWORD, _DWORD))sub_40C120(v3);
        break;
      case 5:
        if ( (*(_BYTE *)(v3 + 228) & 1) == 0 && *(_DWORD *)(v3 + 200) >= 2u )
          goto LABEL_32;
        v4 = a3;
        if ( !a3 )
          goto LABEL_10;
        v5 = 85;
LABEL_9:
        sub_409130(v3, v4, v5);
LABEL_10:
        result = (int (__cdecl *)(int, _DWORD, _DWORD))sub_40C120(v3);
        break;
      case 6:
        if ( (*(_BYTE *)(v3 + 228) & 1) != 0 )
          goto LABEL_32;
        goto LABEL_10;
      default:
        goto LABEL_32;
    }
  }
  else
  {
LABEL_32:
    if ( (*(_BYTE *)(v3 + 104) & 4) == 0 )
      sub_408740((int *)v3, "Invalid attempt to read row data");
    v9 = *(_DWORD *)(v3 + 220);
    *(_DWORD *)(v3 + 128) = *(_DWORD *)(v3 + 236);
    *(_DWORD *)(v3 + 132) = v9;
    v10 = v3 + 116;
    while ( 1 )
    {
      if ( !*(_DWORD *)(v3 + 120) )
      {
        while ( !*(_DWORD *)(v3 + 268) )
        {
          png_crc_finish((struct png_struct_def *)v3, 0);
          sub_4088C0((int *)v3);
          *(_DWORD *)(v3 + 268) = sub_409D20((int *)v3, (unsigned __int8 *)&a1);
          sub_407DD0(v3);
          png_crc_read((struct png_struct_def *)v3, (unsigned __int8 *)(v3 + 284), 4u);
          if ( memcmp((const void *)(v3 + 284), "IDAT", 4u) )
            sub_408740((int *)v3, "Not enough image data");
        }
        v11 = *(_DWORD *)(v3 + 176);
        v12 = *(_DWORD *)(v3 + 268);
        v13 = *(unsigned __int8 **)(v3 + 172);
        v10 = v3 + 116;
        *(_DWORD *)(v3 + 120) = v11;
        *(_DWORD *)(v3 + 116) = v13;
        if ( v11 > v12 )
          *(_DWORD *)(v3 + 120) = v12;
        png_crc_read((struct png_struct_def *)v3, v13, *(_DWORD *)(v3 + 120));
        *(_DWORD *)(v3 + 268) -= *(_DWORD *)(v3 + 120);
      }
      v14 = inflate(v10, 1);
      if ( v14 == 1 )
        break;
      if ( v14 )
      {
        v15 = *(char **)(v3 + 140);
        if ( !v15 )
          v15 = "Decompression error";
        sub_408740((int *)v3, v15);
      }
      if ( !*(_DWORD *)(v3 + 132) )
        goto LABEL_55;
    }
    if ( *(_DWORD *)(v3 + 132) || *(_DWORD *)(v3 + 120) || *(_DWORD *)(v3 + 268) )
      sub_408740((int *)v3, "Extra compressed data");
    *(_DWORD *)(v3 + 104) |= 8u;
    *(_DWORD *)(v3 + 108) |= 0x20u;
LABEL_55:
    v16 = *(_DWORD *)(v3 + 224);
    v17 = *(_BYTE *)(v3 + 298);
    *(_BYTE *)(v3 + 264) = *(_BYTE *)(v3 + 294);
    *(_BYTE *)(v3 + 265) = *(_BYTE *)(v3 + 295);
    v18 = *(_BYTE *)(v3 + 297);
    *(_BYTE *)(v3 + 267) = v18;
    *(_DWORD *)(v3 + 256) = v16;
    *(_BYTE *)(v3 + 266) = v17;
    if ( v18 < 8u )
      v19 = (v16 * (unsigned int)v18 + 7) >> 3;
    else
      v19 = v16 * (v18 >> 3);
    *(_DWORD *)(v3 + 260) = v19;
    v20 = *(unsigned __int8 **)(v3 + 236);
    if ( *v20 )
      sub_409860(v3, v3 + 256, v20 + 1, (_BYTE *)(*(_DWORD *)(v3 + 232) + 1), *v20);
    sub_408AF0(v3, *(void **)(v3 + 232), *(void **)(v3 + 236), *(_DWORD *)(v3 + 216) + 1);
    if ( (*(_BYTE *)(v3 + 560) & 4) != 0 && *(_BYTE *)(v3 + 568) == 64 )
      sub_40F880((int *)(v3 + 256), *(_DWORD *)(v3 + 236) + 1);
    if ( *(_DWORD *)(v3 + 112) || (*(_DWORD *)(v3 + 108) & 0x400000) != 0 )
      sub_410530(v3);
    if ( *(_BYTE *)(v3 + 291) && (*(_BYTE *)(v3 + 112) & 2) != 0 )
    {
      if ( *(_BYTE *)(v3 + 292) < 6u )
        sub_409430(v3);
      if ( a3 )
        sub_409130(v3, a3, *(&dword_416540 + *(unsigned __int8 *)(v3 + 292)));
      if ( a2 )
        sub_409130(v3, a2, dword_416524[*(unsigned __int8 *)(v3 + 292)]);
    }
    else
    {
      if ( a2 )
        sub_409130(v3, a2, 255);
      if ( a3 )
        sub_409130(v3, a3, 255);
    }
    sub_40C120(v3);
    result = *(int (__cdecl **)(int, _DWORD, _DWORD))(v3 + 408);
    if ( result )
      result = (int (__cdecl *)(int, _DWORD, _DWORD))result(v3, *(_DWORD *)(v3 + 228), *(unsigned __int8 *)(v3 + 292));
  }
  return result;
}

//----- (004069C0) --------------------------------------------------------
int (__cdecl *__cdecl sub_4069C0(int a1, void **a2))(int, _DWORD, _DWORD)
{
  int (__cdecl *result)(int, _DWORD, _DWORD); // eax
  int v4; // ebp
  void **v5; // esi
  int v6; // edi
  int v7; // [esp+Ch] [ebp+4h]

  result = (int (__cdecl *)(int, _DWORD, _DWORD))sub_4109D0(a1);
  v4 = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(a1 + 208) = v4;
  if ( (int)result > 0 )
  {
    v7 = (int)result;
    do
    {
      v5 = a2;
      if ( v4 )
      {
        v6 = v4;
        do
        {
          result = sub_4064B0(a1, *v5++, 0);
          --v6;
        }
        while ( v6 );
      }
      --v7;
    }
    while ( v7 );
  }
  return result;
}

//----- (00406A20) --------------------------------------------------------
void __cdecl sub_406A20(char *EndPtr, int a2)
{
  bool v3; // zf
  char *v4; // edx
  unsigned __int8 v5[4]; // [esp+10h] [ebp-4h] BYREF
  char *EndPtra; // [esp+18h] [ebp+4h]

  png_crc_finish((struct png_struct_def *)EndPtr, 0);
  do
  {
    sub_4088C0((int *)EndPtr);
    EndPtra = (char *)sub_409D20((int *)EndPtr, v5);
    sub_407DD0((int)EndPtr);
    png_crc_read((struct png_struct_def *)EndPtr, (unsigned __int8 *)EndPtr + 284, 4u);
    if ( !memcmp(EndPtr + 284, "IHDR", 4u) )
    {
      sub_409E10((int)EndPtr, a2, (int)EndPtra);
    }
    else if ( !memcmp(EndPtr + 284, "IEND", 4u) )
    {
      sub_40A120((int *)EndPtr, a2, (unsigned int)EndPtra);
    }
    else
    {
      v3 = sub_4082A0((int)EndPtr, EndPtr + 284) == 0;
      v4 = EndPtr + 284;
      if ( v3 )
      {
        if ( !memcmp(v4, "IDAT", 4u) )
        {
          if ( EndPtra || (EndPtr[104] & 8) != 0 )
            sub_408740((int *)EndPtr, "Too many IDAT's found");
          png_crc_finish((struct png_struct_def *)EndPtr, 0);
        }
        else if ( !memcmp(EndPtr + 284, "PLTE", 4u) )
        {
          sub_409F90((int)EndPtr, a2, (signed int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "bKGD", 4u) )
        {
          png_handle_bKGD((struct png_struct_def *)EndPtr, (struct png_info_struct *)a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "cHRM", 4u) )
        {
          sub_40A450((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "gAMA", 4u) )
        {
          sub_40A170((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "hIST", 4u) )
        {
          sub_40B390((int)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "oFFs", 4u) )
        {
          sub_40B650((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "pCAL", 4u) )
        {
          sub_40B780((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "sCAL", 4u) )
        {
          sub_40B9E0(EndPtr, a2, (int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "pHYs", 4u) )
        {
          sub_40B530((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "sBIT", 4u) )
        {
          sub_40A2E0((int)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "sRGB", 4u) )
        {
          sub_40A940((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "iCCP", 4u) )
        {
          sub_40AB30((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "sPLT", 4u) )
        {
          sub_40ACE0((int *)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "tEXt", 4u) )
        {
          sub_40BCC0((int)EndPtr, (_DWORD *)a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "tIME", 4u) )
        {
          sub_40BBA0((int)EndPtr, (_DWORD *)a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "tRNS", 4u) )
        {
          sub_40AF00((int)EndPtr, a2, (unsigned int)EndPtra);
        }
        else if ( !memcmp(EndPtr + 284, "zTXt", 4u) )
        {
          sub_40BDE0((int)EndPtr, (_DWORD *)a2, (int)EndPtra);
        }
        else
        {
          sub_40BF40((int)EndPtr, a2, (size_t)EndPtra);
        }
      }
      else
      {
        if ( !memcmp(v4, "IDAT", 4u) )
        {
          if ( EndPtra || (EndPtr[104] & 8) != 0 )
            sub_408740((int *)EndPtr, "Too many IDAT's found");
        }
        else
        {
          *((_DWORD *)EndPtr + 26) |= 8u;
        }
        sub_40BF40((int)EndPtr, a2, (size_t)EndPtra);
        if ( !memcmp(EndPtr + 284, "PLTE", 4u) )
          *((_DWORD *)EndPtr + 26) |= 2u;
      }
    }
  }
  while ( (EndPtr[104] & 0x10) == 0 );
}

//----- (00407890) --------------------------------------------------------
void *__cdecl sub_407890(void *a1, int a2, int a3)
{
  int v3; // esi
  int i; // edi
  int v5; // esi
  int j; // edi
  int v7; // esi
  int k; // edi
  int v9; // eax
  int v10; // ebp
  int v11; // esi
  int v12; // edi
  void *result; // eax
  char v14[64]; // [esp+10h] [ebp-40h] BYREF
  int v15; // [esp+58h] [ebp+8h]

  if ( a2 )
    sub_408230((int)a1, a2);
  if ( a3 )
    sub_408230((int)a1, a3);
  sub_408BF0((int)a1, *((void **)a1 + 43));
  sub_408BF0((int)a1, *((void **)a1 + 148));
  sub_408BF0((int)a1, *((void **)a1 + 58));
  sub_408BF0((int)a1, *((void **)a1 + 123));
  sub_408BF0((int)a1, *((void **)a1 + 124));
  sub_408BF0((int)a1, *((void **)a1 + 89));
  sub_408BF0((int)a1, *((void **)a1 + 90));
  sub_408BF0((int)a1, *((void **)a1 + 91));
  if ( (*((_DWORD *)a1 + 133) & 0x1000) != 0 )
    sub_407DC0((int)a1, *((void **)a1 + 69));
  *((_DWORD *)a1 + 133) &= 0xFFFFEFFF;
  if ( (*((_DWORD *)a1 + 133) & 0x2000) != 0 )
    sub_408BF0((int)a1, *((void **)a1 + 98));
  *((_DWORD *)a1 + 133) &= 0xFFFFDFFF;
  if ( (*((_DWORD *)a1 + 133) & 8) != 0 )
    sub_408BF0((int)a1, *((void **)a1 + 125));
  *((_DWORD *)a1 + 133) &= 0xFFFFFFF7;
  if ( *((_DWORD *)a1 + 92) )
  {
    v3 = 1 << (8 - *((_BYTE *)a1 + 344));
    for ( i = 0; i < v3; ++i )
      sub_408BF0((int)a1, *(void **)(*((_DWORD *)a1 + 92) + 4 * i));
    sub_408BF0((int)a1, *((void **)a1 + 92));
  }
  if ( *((_DWORD *)a1 + 93) )
  {
    v5 = 1 << (8 - *((_BYTE *)a1 + 344));
    for ( j = 0; j < v5; ++j )
      sub_408BF0((int)a1, *(void **)(*((_DWORD *)a1 + 93) + 4 * j));
    sub_408BF0((int)a1, *((void **)a1 + 93));
  }
  if ( *((_DWORD *)a1 + 94) )
  {
    v7 = 1 << (8 - *((_BYTE *)a1 + 344));
    for ( k = 0; k < v7; ++k )
      sub_408BF0((int)a1, *(void **)(*((_DWORD *)a1 + 94) + 4 * k));
    sub_408BF0((int)a1, *((void **)a1 + 94));
  }
  sub_408BF0((int)a1, *((void **)a1 + 132));
  inflateEnd((_DWORD *)a1 + 29);
  sub_408BF0((int)a1, *((void **)a1 + 108));
  sub_408BF0((int)a1, *((void **)a1 + 121));
  v9 = *((_DWORD *)a1 + 147);
  v10 = *((_DWORD *)a1 + 18);
  qmemcpy(v14, a1, sizeof(v14));
  v11 = *((_DWORD *)a1 + 16);
  v12 = *((_DWORD *)a1 + 17);
  v15 = v9;
  result = memset(a1, 0, 0x26Cu);
  *((_DWORD *)a1 + 16) = v11;
  *((_DWORD *)a1 + 17) = v12;
  *((_DWORD *)a1 + 147) = v15;
  qmemcpy(a1, v14, 0x40u);
  *((_DWORD *)a1 + 18) = v10;
  return result;
}

//----- (00407B20) --------------------------------------------------------
void **__cdecl sub_407B20(char *a1, int a2, int a3, int a4)
{
  return sub_4052B0(a1, a2, a3, a4, 0, 0, 0);
}

//----- (00407B50) --------------------------------------------------------
void __cdecl sub_407B50(_DWORD **a1, void **a2, void **a3)
{
  _DWORD *v3; // esi
  void *v4; // edi
  int v5; // ebx
  int v6; // ebp
  void *Block; // [esp+10h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  Block = 0;
  if ( a1 )
    v3 = *a1;
  if ( a2 )
    v4 = *a2;
  if ( a3 )
    Block = *a3;
  v5 = v3[147];
  v6 = v3[145];
  sub_407890(v3, (int)v4, (int)Block);
  if ( v4 )
  {
    png_free_data((int)v3, (int)v4, 0x4000, -1);
    sub_408A30(v4, v5, v6);
    *a2 = 0;
  }
  if ( Block )
  {
    png_free_data((int)v3, (int)Block, 0x4000, -1);
    sub_408A30(Block, v5, v6);
    *a3 = 0;
  }
  sub_408A30(v3, v5, v6);
  *a1 = 0;
}

//----- (00407C10) --------------------------------------------------------
int __usercall sub_407C10@<eax>(int a1@<eax>, int a2, int a3)
{
  int result; // eax

  if ( a3 > 8 )
    sub_408740((int *)a2, "Too many bytes for PNG signature.");
  LOBYTE(a1) = (a3 < 0) - 1;
  result = a3 & a1;
  *(_BYTE *)(a2 + 300) = result;
  return result;
}

//----- (00407C40) --------------------------------------------------------
int __cdecl sub_407C40(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // eax
  char *v4; // ecx
  _DWORD *v5; // edx
  int v6; // esi
  unsigned int v7; // eax
  unsigned __int8 *v8; // ecx
  unsigned __int8 *v9; // edx
  unsigned int v10; // eax
  unsigned __int8 *v11; // ecx
  unsigned __int8 *v12; // edx
  unsigned __int8 *v13; // ecx
  unsigned __int8 *v14; // edx
  int result; // eax
  char v16[8]; // [esp+0h] [ebp-Ch] BYREF

  v16[5] = 10;
  v16[7] = 10;
  v3 = a3;
  v16[0] = -119;
  v16[1] = 80;
  v16[2] = 78;
  v16[3] = 71;
  v16[4] = 13;
  v16[6] = 26;
  if ( a3 <= 8 )
  {
    if ( !a3 )
      return 0;
  }
  else
  {
    v3 = 8;
  }
  if ( a2 > 7 )
    return 0;
  if ( a2 + v3 > 8 )
    v3 = 8 - a2;
  v4 = &v16[a2];
  v5 = (_DWORD *)(a1 + a2);
  if ( v3 < 4 )
  {
LABEL_9:
    if ( !v3 )
      return 0;
  }
  else
  {
    while ( *v5 == *(_DWORD *)v4 )
    {
      v3 -= 4;
      v4 += 4;
      ++v5;
      if ( v3 < 4 )
        goto LABEL_9;
    }
  }
  v6 = *(unsigned __int8 *)v5 - (unsigned __int8)*v4;
  if ( !v6 )
  {
    v7 = v3 - 1;
    v8 = (unsigned __int8 *)(v4 + 1);
    v9 = (unsigned __int8 *)v5 + 1;
    if ( !v7 )
      return 0;
    v6 = *v9 - *v8;
    if ( !v6 )
    {
      v10 = v7 - 1;
      v11 = v8 + 1;
      v12 = v9 + 1;
      if ( !v10 )
        return 0;
      v6 = *v12 - *v11;
      if ( !v6 )
      {
        v13 = v11 + 1;
        v14 = v12 + 1;
        if ( v10 == 1 )
          return 0;
        v6 = *v14 - *v13;
        if ( !v6 )
          return 0;
      }
    }
  }
  result = 1;
  if ( v6 <= 0 )
    result = -1;
  return result;
}

//----- (00407D70) --------------------------------------------------------
void *__cdecl sub_407D70(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // edi
  void *result; // eax

  v3 = *(_DWORD *)(a1 + 108);
  if ( a2 <= 0xFFFFFFFF / a3 )
  {
    *(_DWORD *)(a1 + 108) = v3 | 0x100000;
    result = sub_408BA0(a1, a3 * a2);
    *(_DWORD *)(a1 + 108) = v3;
  }
  else
  {
    sub_4087F0(a1, "Potential overflow in png_zalloc()");
    result = 0;
  }
  return result;
}

//----- (00407DD0) --------------------------------------------------------
int __cdecl sub_407DD0(int a1)
{
  int result; // eax

  result = sub_414630(0, 0, 0);
  *(_DWORD *)(a1 + 272) = result;
  return result;
}

//----- (00407DF0) --------------------------------------------------------
void __cdecl sub_407DF0(int a1, _BYTE *a2, unsigned int a3)
{
  if ( (*(_BYTE *)(a1 + 284) & 0x20) == 0 )
  {
    if ( (*(_DWORD *)(a1 + 108) & 0x800) != 0 )
      return;
    goto LABEL_5;
  }
  if ( (*(_DWORD *)(a1 + 108) & 0x300) != 768 )
LABEL_5:
    *(_DWORD *)(a1 + 272) = sub_414630(*(_DWORD *)(a1 + 272), a2, a3);
}

//----- (00407E40) --------------------------------------------------------
void *__cdecl sub_407E40(int *a1, unsigned int a2)
{
  if ( a2 < 0x120 )
    exit_1(*a1);
  return memset((void *)*a1, 0, 0x120u);
}

//----- (00407E80) --------------------------------------------------------
void __cdecl png_free_data(int a1, int a2, int a3, int a4)
{
  int v4; // ebp
  int v5; // eax
  void *v6; // eax
  int i; // ebp
  int v8; // eax
  bool v9; // zf
  int v10; // ebp
  int v11; // eax
  int v12; // ebp
  int v13; // eax
  int v14; // ebp
  int v15; // eax
  int v16; // eax
  int v17; // ebp
  int j; // ebp

  if ( !a1 || !a2 )
    return;
  v4 = a3;
  if ( ((unsigned __int16)a3 & (unsigned __int16)*(_DWORD *)(a2 + 184) & 0x4000) != 0 )
  {
    if ( a4 == -1 )
    {
      for ( i = 0; i < *(_DWORD *)(a2 + 48); ++i )
        png_free_data(a1, a2, 0x4000, i);
      sub_408BF0(a1, *(void **)(a2 + 56));
      *(_DWORD *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 48) = 0;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 56);
      if ( !v5 )
        goto LABEL_12;
      v6 = *(void **)(v5 + 16 * a4 + 4);
      if ( v6 )
      {
        sub_408BF0(a1, v6);
        *(_DWORD *)(*(_DWORD *)(a2 + 56) + 16 * a4 + 4) = 0;
      }
    }
    v4 = a3;
  }
LABEL_12:
  if ( (v4 & *(_DWORD *)(a2 + 184) & 0x2000) != 0 )
  {
    sub_408BF0(a1, *(void **)(a2 + 76));
    *(_DWORD *)(a2 + 8) &= 0xFFFFFFEF;
    *(_DWORD *)(a2 + 76) = 0;
  }
  v8 = v4 & *(_DWORD *)(a2 + 184);
  if ( (v8 & 0x100) != 0 )
    *(_DWORD *)(a2 + 8) &= 0xFFFFBFFF;
  if ( (v8 & 0x80u) != 0 )
  {
    sub_408BF0(a1, *(void **)(a2 + 160));
    sub_408BF0(a1, *(void **)(a2 + 172));
    v9 = *(_DWORD *)(a2 + 176) == 0;
    *(_DWORD *)(a2 + 160) = 0;
    *(_DWORD *)(a2 + 172) = 0;
    if ( !v9 )
    {
      v10 = 0;
      if ( *(_BYTE *)(a2 + 181) )
      {
        do
        {
          sub_408BF0(a1, *(void **)(*(_DWORD *)(a2 + 176) + 4 * v10));
          *(_DWORD *)(*(_DWORD *)(a2 + 176) + 4 * v10++) = 0;
        }
        while ( v10 < *(unsigned __int8 *)(a2 + 181) );
      }
      sub_408BF0(a1, *(void **)(a2 + 176));
      v4 = a3;
      *(_DWORD *)(a2 + 176) = 0;
    }
    *(_DWORD *)(a2 + 8) &= 0xFFFFFBFF;
  }
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 0x10) != 0 )
  {
    sub_408BF0(a1, *(void **)(a2 + 196));
    sub_408BF0(a1, *(void **)(a2 + 200));
    *(_DWORD *)(a2 + 8) &= 0xFFFFEFFF;
    *(_DWORD *)(a2 + 196) = 0;
    *(_DWORD *)(a2 + 200) = 0;
  }
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 0x20) != 0 )
  {
    if ( a4 == -1 )
    {
      v13 = *(_DWORD *)(a2 + 216);
      if ( v13 )
      {
        v14 = 0;
        if ( v13 > 0 )
        {
          do
            png_free_data(a1, a2, 32, v14++);
          while ( v14 < *(_DWORD *)(a2 + 216) );
        }
        sub_408BF0(a1, *(void **)(a2 + 212));
        v4 = a3;
        *(_DWORD *)(a2 + 212) = 0;
        *(_DWORD *)(a2 + 216) = 0;
      }
      *(_DWORD *)(a2 + 8) &= 0xFFFFDFFF;
    }
    else
    {
      v11 = *(_DWORD *)(a2 + 212);
      if ( v11 )
      {
        v12 = 16 * a4;
        sub_408BF0(a1, *(void **)(v11 + 16 * a4));
        sub_408BF0(a1, *(void **)(*(_DWORD *)(a2 + 212) + 16 * a4 + 8));
        *(_DWORD *)(*(_DWORD *)(a2 + 212) + v12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 212) + v12 + 8) = 0;
        v4 = a3;
      }
    }
  }
  if ( (v4 & *(_DWORD *)(a2 + 184) & 0x200) == 0 )
    goto LABEL_42;
  if ( a4 == -1 )
  {
    v16 = *(_DWORD *)(a2 + 192);
    if ( v16 )
    {
      v17 = 0;
      if ( v16 > 0 )
      {
        do
          png_free_data(a1, a2, 512, v17++);
        while ( v17 < *(_DWORD *)(a2 + 192) );
      }
      sub_408BF0(a1, *(void **)(a2 + 188));
      *(_DWORD *)(a2 + 188) = 0;
      *(_DWORD *)(a2 + 192) = 0;
      goto LABEL_41;
    }
  }
  else
  {
    v15 = *(_DWORD *)(a2 + 188);
    if ( v15 )
    {
      sub_408BF0(a1, *(void **)(v15 + 20 * a4 + 8));
      *(_DWORD *)(*(_DWORD *)(a2 + 188) + 20 * a4 + 8) = 0;
LABEL_41:
      v4 = a3;
      goto LABEL_42;
    }
  }
LABEL_42:
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 8) != 0 )
  {
    sub_408BF0(a1, *(void **)(a2 + 124));
    *(_DWORD *)(a2 + 8) &= 0xFFFFFFBF;
    *(_DWORD *)(a2 + 124) = 0;
  }
  if ( (v4 & *(_DWORD *)(a2 + 184) & 0x1000) != 0 )
  {
    sub_407DC0(a1, *(void **)(a2 + 16));
    *(_DWORD *)(a2 + 8) &= 0xFFFFFFF7;
    *(_DWORD *)(a2 + 16) = 0;
    *(_WORD *)(a2 + 20) = 0;
  }
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 0x40) != 0 )
  {
    if ( *(_DWORD *)(a2 + 248) )
    {
      for ( j = 0; j < *(_DWORD *)(a2 + 4); ++j )
      {
        sub_408BF0(a1, *(void **)(*(_DWORD *)(a2 + 248) + 4 * j));
        *(_DWORD *)(*(_DWORD *)(a2 + 248) + 4 * j) = 0;
      }
      sub_408BF0(a1, *(void **)(a2 + 248));
      v4 = a3;
      *(_DWORD *)(a2 + 248) = 0;
    }
    *(_DWORD *)(a2 + 8) &= 0xFFFF7FFF;
  }
  if ( a4 != -1 )
    v4 &= 0xFFFFBDDF;
  *(_DWORD *)(a2 + 184) &= ~v4;
}

//----- (00408230) --------------------------------------------------------
void *__cdecl sub_408230(int a1, int a2)
{
  png_free_data(a1, a2, 0x7FFF, -1);
  if ( *(_DWORD *)(a1 + 544) )
  {
    sub_408BF0(a1, *(void **)(a1 + 548));
    *(_DWORD *)(a1 + 548) = 0;
    *(_DWORD *)(a1 + 544) = 0;
  }
  return sub_407E40(&a2, 0x120u);
}

//----- (00408290) --------------------------------------------------------
int __cdecl sub_408290(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 84) = a2;
  return result;
}

//----- (004082A0) --------------------------------------------------------
int __cdecl sub_4082A0(int a1, const void *a2)
{
  int v3; // ebx
  unsigned __int8 *v4; // edi

  if ( !a1 && !a2 || *(int *)(a1 + 544) <= 0 )
    return 0;
  v3 = *(_DWORD *)(a1 + 544);
  v4 = (unsigned __int8 *)(5 * v3 + *(_DWORD *)(a1 + 548) - 5);
  if ( !v3 )
    return 0;
  while ( memcmp(a2, v4, 4u) )
  {
    --v3;
    v4 -= 5;
    if ( !v3 )
      return 0;
  }
  return v4[4];
}

//----- (00408390) --------------------------------------------------------
int __cdecl sub_408390(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 572) = 0;
  *(_BYTE *)(a1 + 569) = 0;
  *(_BYTE *)(a1 + 576) = 0;
  return result;
}

//----- (004083B0) --------------------------------------------------------
void *__cdecl sub_4083B0(void *a1)
{
  void *result; // eax

  result = a1;
  if ( a1 )
  {
    result = sub_408980(2, *((int (__cdecl **)(char *, size_t))a1 + 146), *((_DWORD *)a1 + 145));
    a1 = result;
    if ( result )
    {
      sub_407E40((int *)&a1, 0x120u);
      result = a1;
    }
  }
  return result;
}

//----- (004083F0) --------------------------------------------------------
char *__usercall sub_4083F0@<eax>(int a1@<eax>, const char *a2@<edx>, int a3)
{
  char *result; // eax
  int i; // edi
  int v6; // ecx
  char *v7; // eax
  char *v8; // eax
  char *v9; // esi

  result = 0;
  for ( i = 0; i < 4; ++i )
  {
    v6 = *(unsigned __int8 *)(i + a3 + 284);
    if ( (unsigned int)(v6 - 65) > 0x39 || v6 > 90 && v6 < 97 )
    {
      result[a1] = 91;
      v7 = result + 1;
      v7[a1] = byte_4165D4[(v6 >> 4) & 0xF];
      (++v7)[a1] = byte_4165D4[v6 & 0xF];
      result = v7 + 1;
      result[a1] = 93;
    }
    else
    {
      result[a1] = v6;
    }
    ++result;
  }
  if ( a2 )
  {
    result[a1] = 58;
    v8 = result + 1;
    v8[a1] = 32;
    v9 = &v8[a1 + 1];
    result = strncpy(v9, a2, 0x3Fu);
    v9[63] = 0;
  }
  else
  {
    result[a1] = 0;
  }
  return result;
}

//----- (00408490) --------------------------------------------------------
void __cdecl __noreturn sub_408490(int *a1, char *a2)
{
  char *v2; // ebx
  char *v3; // ebp
  int v4; // esi
  bool v5; // zf
  char v6; // dl
  char v7; // bl
  char v8; // dl
  char v9; // bl
  FILE *v10; // eax
  FILE *v11; // eax
  const char *v12; // [esp-Ch] [ebp-38h]
  char *v13; // [esp-8h] [ebp-34h]
  const char *v14; // [esp-4h] [ebp-30h]
  char *v15; // [esp+14h] [ebp-18h]
  char v16[2]; // [esp+18h] [ebp-14h] BYREF
  char v17[14]; // [esp+1Ah] [ebp-12h] BYREF

  if ( *a2 == 35 )
  {
    v2 = (char *)(v16 - a2);
    v3 = (char *)(v17 - a2);
    v4 = 0;
    v15 = (char *)(v17 - a2);
    while ( 1 )
    {
      v5 = a2[v4] == 32;
      v6 = a2[v4 + 1];
      a2[v4 + (_DWORD)v2] = v6;
      if ( v5 )
        goto LABEL_15;
      v7 = a2[v4 + 2];
      v16[v4 + 1] = v7;
      if ( v6 == 32 )
      {
        ++v4;
        goto LABEL_15;
      }
      v8 = a2[v4 + 3];
      a2[v4 + (_DWORD)v3] = v8;
      if ( v7 == 32 )
      {
        v4 += 2;
        goto LABEL_15;
      }
      v9 = a2[v4 + 4];
      v17[v4 + 1] = v9;
      if ( v8 == 32 )
      {
        v4 += 3;
        goto LABEL_15;
      }
      v17[v4 + 2] = a2[v4 + 5];
      if ( v9 == 32 )
        break;
      v4 += 5;
      if ( v4 >= 15 )
        goto LABEL_15;
      v3 = v15;
      v2 = (char *)(v16 - a2);
    }
    v4 += 4;
LABEL_15:
    if ( (unsigned int)(v4 - 2) > 0xC )
    {
      v14 = (const char *)v4;
      v13 = a2;
      v12 = "libpng error: %s, offset=%d\n";
    }
    else
    {
      v14 = &a2[v4];
      v13 = v16;
      *((_BYTE *)&v15 + v4 + 3) = 0;
      v12 = "libpng error no. %s: %s\n";
    }
    v10 = _iob_func();
    fprintf(v10 + 2, v12, v13, v14);
  }
  else
  {
    v11 = _iob_func();
    fprintf(v11 + 2, "libpng error: %s\n", a2);
  }
  longjmp(a1, 1);
}

//----- (004085C0) --------------------------------------------------------
int __cdecl sub_4085C0(const char *a1)
{
  char *v1; // ebx
  char *v2; // ebp
  int v3; // esi
  bool v4; // zf
  char v5; // dl
  char v6; // bl
  char v7; // dl
  char v8; // bl
  FILE *v9; // eax
  int result; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  char *i; // [esp+Ch] [ebp-18h]
  char v14[2]; // [esp+10h] [ebp-14h] BYREF
  char v15[14]; // [esp+12h] [ebp-12h] BYREF

  if ( *a1 == 35 )
  {
    v1 = (char *)(v14 - a1);
    v2 = (char *)(v15 - a1);
    v3 = 0;
    for ( i = (char *)(v14 - a1); ; v1 = i )
    {
      v4 = a1[v3] == 32;
      v5 = a1[v3 + 1];
      a1[v3 + (_DWORD)v1] = v5;
      if ( v4 )
        break;
      v6 = a1[v3 + 2];
      v14[v3 + 1] = v6;
      if ( v5 == 32 )
      {
        ++v3;
        break;
      }
      v7 = a1[v3 + 3];
      a1[v3 + (_DWORD)v2] = v7;
      if ( v6 == 32 )
      {
        v3 += 2;
        break;
      }
      v8 = a1[v3 + 4];
      v15[v3 + 1] = v8;
      if ( v7 == 32 )
      {
        v3 += 3;
        break;
      }
      v15[v3 + 2] = a1[v3 + 5];
      if ( v8 == 32 )
      {
        v3 += 4;
        break;
      }
      v3 += 5;
      if ( v3 >= 15 )
        break;
      v2 = (char *)(v15 - a1);
    }
    if ( (unsigned int)(v3 - 2) > 0xC )
    {
      v11 = _iob_func();
      result = fprintf(v11 + 2, "libpng warning: %s\n", a1);
    }
    else
    {
      *((_BYTE *)&i + v3 + 3) = 0;
      v9 = _iob_func();
      result = fprintf(v9 + 2, "libpng warning no. %s: %s\n", v14, &a1[v3]);
    }
  }
  else
  {
    v12 = _iob_func();
    result = fprintf(v12 + 2, "libpng warning: %s\n", a1);
  }
  return result;
}

//----- (00408720) --------------------------------------------------------
_DWORD *__cdecl sub_408720(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  a1[18] = a2;
  a1[16] = a3;
  a1[17] = a4;
  return result;
}

//----- (00408740) --------------------------------------------------------
void __cdecl __noreturn sub_408740(int *a1, char *a2)
{
  int v2; // edx
  char *v3; // esi
  int v4; // eax
  int v5; // edi
  int v6; // ecx
  void (__cdecl *v7)(int *, char *); // eax
  char v8[16]; // [esp+8h] [ebp-14h] BYREF

  v2 = a1[27];
  v3 = a2;
  if ( (v2 & 0xC0000) == 0 )
    goto LABEL_17;
  if ( *a2 == 35 )
  {
    v4 = 1;
    while ( 1 )
    {
      if ( a2[v4] == 32 )
        goto LABEL_9;
      if ( a2[v4 + 1] == 32 )
        break;
      v4 += 2;
      if ( v4 >= 15 )
        goto LABEL_9;
    }
    ++v4;
LABEL_9:
    if ( (v2 & 0x80000) == 0 )
    {
      v3 = &a2[v4];
      goto LABEL_17;
    }
    v5 = v4 - 1;
    v6 = 0;
    if ( v4 - 1 > 0 )
    {
      memcpy(v8, a2 + 1, v4 - 1);
      v6 = v5;
    }
    v8[v6] = 0;
  }
  else
  {
    if ( (v2 & 0x80000) == 0 )
      goto LABEL_17;
    v8[0] = 48;
    v8[1] = 0;
  }
  v3 = v8;
LABEL_17:
  v7 = (void (__cdecl *)(int *, char *))a1[16];
  if ( v7 )
    v7(a1, v3);
  sub_408490(a1, v3);
}

//----- (004087F0) --------------------------------------------------------
int __cdecl sub_4087F0(int a1, _BYTE *a2)
{
  int v2; // eax
  int (__cdecl *v3)(int, const char *); // edx
  int result; // eax
  const char *v5; // [esp-4h] [ebp-8h]

  v2 = 0;
  if ( (*(_DWORD *)(a1 + 108) & 0xC0000) != 0 && *a2 == 35 )
  {
    v2 = 1;
    while ( a2[v2] != 32 )
    {
      if ( a2[v2 + 1] == 32 )
      {
        ++v2;
        break;
      }
      v2 += 2;
      if ( v2 >= 15 )
        break;
    }
  }
  v3 = *(int (__cdecl **)(int, const char *))(a1 + 68);
  v5 = &a2[v2];
  if ( v3 )
    result = v3(a1, v5);
  else
    result = sub_4085C0(v5);
  return result;
}

//----- (00408850) --------------------------------------------------------
void __cdecl __noreturn sub_408850(int *a1, const char *a2)
{
  char v2[84]; // [esp+4h] [ebp-58h] BYREF

  sub_4083F0((int)v2, a2, (int)a1);
  sub_408740(a1, v2);
}

//----- (00408880) --------------------------------------------------------
int __cdecl sub_408880(int a1, const char *a2)
{
  char v3[84]; // [esp+4h] [ebp-58h] BYREF

  sub_4083F0((int)v3, a2, a1);
  return sub_4087F0(a1, v3);
}

//----- (004088C0) --------------------------------------------------------
int __cdecl sub_4088C0(int *a1)
{
  int (*v1)(void); // eax

  v1 = (int (*)(void))a1[20];
  if ( !v1 )
    sub_408740(a1, "Call to NULL read function");
  return v1();
}

//----- (004088E0) --------------------------------------------------------
size_t __cdecl sub_4088E0(int a1, void *Buffer, size_t ElementCount)
{
  size_t result; // eax

  result = fread(Buffer, 1u, ElementCount, *(FILE **)(a1 + 84));
  if ( result != ElementCount )
    sub_408740((int *)a1, "Read Error");
  return result;
}

//----- (00408920) --------------------------------------------------------
int __cdecl sub_408920(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  a1[21] = a2;
  result = a3;
  if ( a3 )
    a1[20] = a3;
  else
    a1[20] = sub_4088E0;
  if ( a1[19] )
  {
    a1[19] = 0;
    sub_4087F0((int)a1, "It's an error to set both read_data_fn and write_data_fn in the ");
    result = sub_4087F0((int)a1, "same structure.  Resetting write_data_fn to NULL.");
  }
  a1[83] = 0;
  return result;
}

//----- (00408980) --------------------------------------------------------
void *__cdecl sub_408980(int a1, int (__cdecl *a2)(char *, size_t), int a3)
{
  size_t v3; // esi
  void *v4; // eax
  void *v5; // edi
  char v7[580]; // [esp+4h] [ebp-270h] BYREF
  int v8; // [esp+248h] [ebp-2Ch]

  if ( a1 == 2 )
  {
    v3 = 288;
  }
  else
  {
    if ( a1 != 1 )
      return 0;
    v3 = 620;
  }
  if ( a2 )
  {
    v8 = a3;
    v4 = (void *)a2(v7, v3);
  }
  else
  {
    v4 = malloc(v3);
  }
  v5 = v4;
  if ( v4 )
    memset(v4, 0, v3);
  return v5;
}

//----- (00408A30) --------------------------------------------------------
void __cdecl sub_408A30(void *Block, int a2, int a3)
{
  char v3[580]; // [esp+0h] [ebp-270h] BYREF
  int v4; // [esp+244h] [ebp-2Ch]

  if ( Block )
  {
    if ( a2 )
    {
      v4 = a3;
      ((void (__cdecl *)(char *, void *))a2)(v3, Block);
    }
    else
    {
      free(Block);
    }
  }
}

//----- (00408AB0) --------------------------------------------------------
void *__cdecl sub_408AB0(int a1, size_t Size)
{
  void *result; // eax

  if ( a1 && Size )
    result = malloc(Size);
  else
    result = 0;
  return result;
}

//----- (00408AF0) --------------------------------------------------------
void *__cdecl sub_408AF0(int a1, void *a2, void *Src, size_t Size)
{
  return memcpy(a2, Src, Size);
}

//----- (00408B10) --------------------------------------------------------
void *__cdecl sub_408B10(int a1, void *a2, int Val, size_t Size)
{
  return memset(a2, Val, Size);
}

//----- (00408B30) --------------------------------------------------------
_DWORD *__cdecl sub_408B30(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  a1[145] = a2;
  a1[146] = a3;
  a1[147] = a4;
  return result;
}

//----- (00408BA0) --------------------------------------------------------
void *__cdecl sub_408BA0(int a1, size_t Size)
{
  int (__cdecl *v2)(int, size_t); // eax
  void *result; // eax

  if ( !a1 || !Size )
    return 0;
  v2 = *(int (__cdecl **)(int, size_t))(a1 + 584);
  if ( v2 )
    result = (void *)v2(a1, Size);
  else
    result = sub_408AB0(a1, Size);
  if ( !result && (*(_DWORD *)(a1 + 108) & 0x100000) == 0 )
    sub_408740((int *)a1, "Out of Memory!");
  return result;
}

//----- (00408BF0) --------------------------------------------------------
void __cdecl sub_408BF0(int a1, void *Block)
{
  void (*v2)(void); // eax

  if ( a1 && Block )
  {
    v2 = *(void (**)(void))(a1 + 588);
    if ( v2 )
      v2();
    else
      free(Block);
  }
}
// 408AD5: conditional instruction was optimized away because of '%arg_0.4!=0'
// 408ADD: conditional instruction was optimized away because of '%Block.4!=0'

//----- (00408C20) --------------------------------------------------------
void *__cdecl sub_408C20(int a1, size_t Size)
{
  int v2; // edi
  void *result; // eax

  v2 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(a1 + 108) = v2 | 0x100000;
  result = sub_408BA0(a1, Size);
  *(_DWORD *)(a1 + 108) = v2;
  return result;
}

//----- (00408C50) --------------------------------------------------------
int __cdecl png_get_uint_32(unsigned __int8 *a1)
{
  return a1[3] + ((a1[2] + ((a1[1] + (*a1 << 8)) << 8)) << 8);
}

//----- (00408C80) --------------------------------------------------------
__int16 __cdecl sub_408C80(unsigned __int8 *a1)
{
  return a1[1] + (*a1 << 8);
}

//----- (00408CA0) --------------------------------------------------------
void __cdecl png_crc_read(struct png_struct_def *a1, unsigned __int8 *a2, unsigned int a3)
{
  sub_4088C0((int *)a1);
  sub_407DF0((int)a1, a2, a3);
}

//----- (00408CD0) --------------------------------------------------------
BOOL __cdecl png_crc_error(struct png_struct_def *a1)
{
  struct png_struct_def *v1; // edi
  int v2; // esi
  BOOL result; // eax

  v1 = a1;
  v2 = 1;
  if ( (*((_BYTE *)a1 + 284) & 0x20) != 0 )
  {
    if ( (*((_DWORD *)a1 + 27) & 0x300) != 768 )
      goto LABEL_6;
  }
  else if ( (*((_DWORD *)a1 + 27) & 0x800) == 0 )
  {
    goto LABEL_6;
  }
  v2 = 0;
LABEL_6:
  sub_4088C0((int *)a1);
  if ( v2 )
    result = png_get_uint_32((unsigned __int8 *)&a1) != *((_DWORD *)v1 + 68);
  else
    result = 0;
  return result;
}

//----- (00408D40) --------------------------------------------------------
char *__cdecl sub_408D40(int a1, int a2, char *a3, int a4, size_t a5, size_t *a6)
{
  int v6; // ecx
  int v7; // eax
  size_t v8; // ebp
  char *v9; // edi
  int v10; // eax
  int v11; // ecx
  char *v12; // eax
  int v13; // edx
  char *v14; // eax
  char *result; // eax
  int v16; // [esp+Ch] [ebp-44h]
  void *Block; // [esp+10h] [ebp-40h]
  char Buffer[52]; // [esp+18h] [ebp-38h] BYREF

  if ( !a2 )
  {
    v6 = *(_DWORD *)(a1 + 176);
    *(_DWORD *)(a1 + 120) = a4 - a5;
    v7 = *(_DWORD *)(a1 + 172);
    v8 = 0;
    *(_DWORD *)(a1 + 116) = &a3[a5];
    *(_DWORD *)(a1 + 128) = v7;
    *(_DWORD *)(a1 + 132) = v6;
    v9 = 0;
    if ( a4 != a5 )
    {
      while ( 1 )
      {
        v10 = inflate(a1 + 116, 1);
        v16 = v10;
        if ( v10 )
        {
          if ( v10 != 1 )
            break;
        }
        v11 = *(_DWORD *)(a1 + 132);
        if ( !v11 || v10 == 1 )
        {
          if ( v9 )
          {
            Block = v9;
            v12 = (char *)sub_408C20(a1, v8 - v11 + *(_DWORD *)(a1 + 176) + 1);
            v9 = v12;
            if ( !v12 )
            {
              sub_408BF0(a1, Block);
              sub_408BF0(a1, a3);
              sub_408740((int *)a1, "Not enough memory to decompress chunk..");
            }
            memcpy(v12, Block, v8);
            sub_408BF0(a1, Block);
            memcpy(&v9[v8], *(const void **)(a1 + 172), *(_DWORD *)(a1 + 176) - *(_DWORD *)(a1 + 132));
            v8 += *(_DWORD *)(a1 + 176) - *(_DWORD *)(a1 + 132);
          }
          else
          {
            v8 = *(_DWORD *)(a1 + 176) + a5 - v11;
            v9 = (char *)sub_408C20(a1, v8 + 1);
            if ( !v9 )
            {
              sub_408BF0(a1, a3);
              sub_408740((int *)a1, "Not enough memory to decompress chunk.");
            }
            memcpy(&v9[a5], *(const void **)(a1 + 172), v8 - a5);
            memcpy(v9, a3, a5);
          }
          v9[v8] = 0;
          if ( v16 == 1 )
            goto LABEL_39;
          v13 = *(_DWORD *)(a1 + 176);
          v10 = v16;
          *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 172);
          *(_DWORD *)(a1 + 132) = v13;
        }
        if ( !*(_DWORD *)(a1 + 120) )
          goto LABEL_28;
      }
      if ( *(_DWORD *)(a1 + 140) )
        sub_4087F0(a1, *(_BYTE **)(a1 + 140));
      else
        sub_4087F0(a1, aErrorDecodingC);
      inflateReset((_DWORD *)(a1 + 116));
      *(_DWORD *)(a1 + 120) = 0;
      if ( !v9 )
      {
        v8 = a5 + 32;
        v14 = (char *)sub_408C20(a1, a5 + 32);
        v9 = v14;
        if ( !v14 )
        {
          sub_408BF0(a1, a3);
          sub_408740((int *)a1, "Not enough memory to decompress chunk");
        }
        memcpy(v14, a3, a5);
      }
      v9[v8 - 1] = 0;
      v8 = a3 - v9 + a4 - 1;
      if ( v8 >= 0x1F )
        v8 = 31;
      memcpy(&v9[a5], aErrorDecodingC, v8 + 1);
      v10 = v16;
LABEL_28:
      switch ( v10 )
      {
        case 1:
          goto LABEL_39;
        case -5:
          sprintf(Buffer, "Buffer error in compressed datastream in %s chunk", a1 + 284);
LABEL_34:
          sub_4087F0(a1, Buffer);
          v8 = a5;
          if ( !v9 )
          {
            v9 = (char *)sub_408C20(a1, a5 + 1);
            if ( !v9 )
            {
              sub_408BF0(a1, a3);
              sub_408740((int *)a1, "Not enough memory for text.");
            }
            memcpy(v9, a3, a5);
          }
          v9[a5] = 0;
LABEL_39:
          inflateReset((_DWORD *)(a1 + 116));
          *(_DWORD *)(a1 + 120) = 0;
          sub_408BF0(a1, a3);
          result = v9;
          *a6 = v8;
          return result;
        case -3:
          sprintf(Buffer, "Data error in compressed datastream in %s chunk", a1 + 284);
          goto LABEL_34;
      }
    }
    sprintf(Buffer, "Incomplete compressed datastream in %s chunk", a1 + 284);
    goto LABEL_34;
  }
  sprintf(Buffer, "Unknown zTXt compression type %d", a2);
  sub_4087F0(a1, Buffer);
  result = a3;
  a3[a5] = 0;
  *a6 = a5;
  return result;
}

//----- (004090D0) --------------------------------------------------------
unsigned __int8 __cdecl sub_4090D0(int *a1, unsigned __int8 *a2)
{
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  unsigned __int8 result; // al

  v2 = *a2;
  if ( *a2 < 0x41u
    || v2 > 0x7Au
    || v2 > 0x5Au && v2 < 0x61u
    || (v3 = a2[1], v3 < 0x41u)
    || v3 > 0x7Au
    || v3 > 0x5Au && v3 < 0x61u
    || (v4 = a2[2], v4 < 0x41u)
    || v4 > 0x7Au
    || v4 > 0x5Au && v4 < 0x61u
    || (result = a2[3], result < 0x41u)
    || result > 0x7Au
    || result > 0x5Au && result < 0x61u )
  {
    sub_408850(a1, "invalid chunk type");
  }
  return result;
}

//----- (00409130) --------------------------------------------------------
int __cdecl sub_409130(int a1, void *a2, int a3)
{
  unsigned __int8 v3; // al
  unsigned int v4; // eax
  int result; // eax
  unsigned int v6; // ecx
  unsigned __int8 *v7; // esi
  char *v8; // ebp
  size_t v9; // edi
  unsigned __int8 v10; // bl
  _BYTE *v11; // edi
  int v12; // ebp
  int v13; // edx
  _BYTE *v14; // edi
  int v15; // ebp
  int v16; // edx
  _BYTE *v17; // edi
  int v18; // ebp
  int v19; // edx
  int v20; // [esp+0h] [ebp-10h]
  int v21; // [esp+0h] [ebp-10h]
  int v22; // [esp+0h] [ebp-10h]
  int v23; // [esp+0h] [ebp-10h]
  int v24; // [esp+4h] [ebp-Ch]
  int v25; // [esp+4h] [ebp-Ch]
  int v26; // [esp+4h] [ebp-Ch]
  int v27; // [esp+8h] [ebp-8h]
  int v28; // [esp+8h] [ebp-8h]
  int v29; // [esp+8h] [ebp-8h]
  int v30; // [esp+Ch] [ebp-4h]
  int v31; // [esp+Ch] [ebp-4h]
  int v32; // [esp+Ch] [ebp-4h]

  if ( a3 == 255 )
  {
    v3 = *(_BYTE *)(a1 + 267);
    if ( v3 < 8u )
      v4 = (*(_DWORD *)(a1 + 200) * (unsigned int)v3 + 7) >> 3;
    else
      v4 = *(_DWORD *)(a1 + 200) * (v3 >> 3);
    result = (int)memcpy(a2, (const void *)(*(_DWORD *)(a1 + 236) + 1), v4);
  }
  else
  {
    result = a1;
    v6 = *(unsigned __int8 *)(a1 + 267);
    v7 = (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1);
    switch ( v6 )
    {
      case 1u:
        v17 = a2;
        v23 = 128;
        if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
        {
          v18 = 0;
          v32 = 7;
          v29 = 1;
        }
        else
        {
          v18 = 7;
          v32 = 0;
          v29 = -1;
        }
        v19 = v18;
        if ( *(_DWORD *)(a1 + 200) )
        {
          v26 = *(_DWORD *)(a1 + 200);
          do
          {
            if ( (a3 & v23) != 0 )
              *v17 = (((*v7 >> v19) & 1) << v19) | *v17 & (32639 >> (7 - v19));
            if ( v19 == v32 )
            {
              ++v7;
              v19 = v18;
              ++v17;
            }
            else
            {
              v19 += v29;
            }
            result = 1;
            if ( v23 == 1 )
              v23 = 128;
            else
              v23 >>= 1;
            --v26;
          }
          while ( v26 );
        }
        break;
      case 2u:
        v14 = a2;
        v22 = 128;
        if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
        {
          v15 = 0;
          v31 = 6;
          v28 = 2;
        }
        else
        {
          v15 = 6;
          v31 = 0;
          v28 = -2;
        }
        v16 = v15;
        if ( *(_DWORD *)(a1 + 200) )
        {
          v25 = *(_DWORD *)(a1 + 200);
          do
          {
            if ( (a3 & v22) != 0 )
              *v14 = (((*v7 >> v16) & 3) << v16) | *v14 & (16191 >> (6 - v16));
            if ( v16 == v31 )
            {
              ++v7;
              v16 = v15;
              ++v14;
            }
            else
            {
              v16 += v28;
            }
            result = 1;
            if ( v22 == 1 )
              v22 = 128;
            else
              v22 >>= 1;
            --v25;
          }
          while ( v25 );
        }
        break;
      case 4u:
        v11 = a2;
        v21 = 128;
        if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
        {
          result = 4;
          v12 = 0;
          v24 = 4;
          v27 = 4;
        }
        else
        {
          v12 = 4;
          v24 = 0;
          v27 = -4;
        }
        v13 = v12;
        if ( *(_DWORD *)(a1 + 200) )
        {
          v30 = *(_DWORD *)(a1 + 200);
          do
          {
            if ( (a3 & v21) != 0 )
              *v11 = (((*v7 >> v13) & 0xF) << v13) | *v11 & (3855 >> (4 - v13));
            if ( v13 == v24 )
            {
              ++v7;
              v13 = v12;
              ++v11;
            }
            else
            {
              v13 += v27;
            }
            result = 1;
            if ( v21 == 1 )
              v21 = 128;
            else
              v21 >>= 1;
            --v30;
          }
          while ( v30 );
        }
        break;
      default:
        result = *(_DWORD *)(a1 + 200);
        v8 = (char *)a2;
        v9 = v6 >> 3;
        v10 = 0x80;
        if ( result )
        {
          v20 = *(_DWORD *)(a1 + 200);
          do
          {
            if ( (v10 & (unsigned __int8)a3) != 0 )
              result = (int)memcpy(v8, v7, v9);
            v7 += v9;
            v8 += v9;
            if ( v10 == 1 )
              v10 = 0x80;
            else
              v10 >>= 1;
            --v20;
          }
          while ( v20 );
        }
        break;
    }
  }
  return result;
}

//----- (00409430) --------------------------------------------------------
unsigned int __cdecl sub_409430(unsigned int a1)
{
  unsigned int result; // eax
  int v2; // ecx
  bool v3; // zf
  int v4; // ecx
  int v5; // ebx
  int v6; // eax
  unsigned int v7; // esi
  int v8; // ebp
  unsigned int v9; // edi
  size_t v10; // esi
  char *v11; // ebx
  char *v12; // edi
  int v13; // ebp
  _BYTE *v14; // edi
  int v15; // edx
  int v16; // esi
  int v17; // ebp
  char v18; // al
  _BYTE *v19; // edi
  int v20; // edx
  int v21; // esi
  char v22; // al
  _BYTE *v23; // edi
  int v24; // edx
  int v25; // esi
  int v26; // ebp
  char v27; // al
  bool v28; // cf
  unsigned __int8 v29; // al
  char v30; // [esp+Bh] [ebp-2Dh]
  char v31; // [esp+Bh] [ebp-2Dh]
  int v32; // [esp+Ch] [ebp-2Ch]
  _BYTE *v33; // [esp+Ch] [ebp-2Ch]
  int v34; // [esp+Ch] [ebp-2Ch]
  unsigned int v35; // [esp+10h] [ebp-28h]
  int v36; // [esp+10h] [ebp-28h]
  unsigned int v37; // [esp+10h] [ebp-28h]
  int v38; // [esp+10h] [ebp-28h]
  _BYTE *v39; // [esp+14h] [ebp-24h]
  int v40; // [esp+14h] [ebp-24h]
  _BYTE *v41; // [esp+14h] [ebp-24h]
  int v42; // [esp+18h] [ebp-20h]
  int v43; // [esp+18h] [ebp-20h]
  int v44; // [esp+18h] [ebp-20h]
  int v45; // [esp+1Ch] [ebp-1Ch]
  int v46; // [esp+1Ch] [ebp-1Ch]
  unsigned int v47; // [esp+20h] [ebp-18h]
  int v48; // [esp+20h] [ebp-18h]
  int v49; // [esp+20h] [ebp-18h]
  int *v50; // [esp+24h] [ebp-14h]
  int v51; // [esp+28h] [ebp-10h]
  int Src[2]; // [esp+2Ch] [ebp-Ch] BYREF

  result = a1;
  v2 = *(_DWORD *)(a1 + 236);
  v3 = v2 == -1;
  v4 = v2 + 1;
  v5 = *(_DWORD *)(a1 + 112);
  v50 = (int *)(a1 + 256);
  if ( v3 || a1 == -256 )
    return result;
  v6 = *(_DWORD *)(a1 + 256);
  v7 = *(unsigned __int8 *)(a1 + 267);
  v8 = dword_4164D0[*(unsigned __int8 *)(a1 + 292)] * v6;
  v51 = dword_4164D0[*(unsigned __int8 *)(a1 + 292)];
  v45 = v8;
  v9 = v8 - 1;
  switch ( v7 )
  {
    case 1u:
      v23 = (_BYTE *)(v4 + (v9 >> 3));
      v41 = (_BYTE *)(v4 + ((unsigned int)(v6 - 1) >> 3));
      if ( (v5 & 0x10000) != 0 )
      {
        v24 = ((_BYTE)v6 - 1) & 7;
        v25 = ((_BYTE)v8 - 1) & 7;
        v44 = 7;
        v26 = 0;
        v38 = -1;
      }
      else
      {
        v24 = 7 - (((_BYTE)v6 - 1) & 7);
        v25 = 7 - (((_BYTE)v8 - 1) & 7);
        v44 = 0;
        v26 = 7;
        v38 = 1;
      }
      v34 = v24;
      Src[0] = 0;
      if ( v6 )
      {
        do
        {
          v27 = (*v41 >> v24) & 1;
          if ( v51 > 0 )
          {
            v49 = v51;
            do
            {
              *v23 = (v27 << v25) | *v23 & (32639 >> (7 - v25));
              if ( v25 == v26 )
              {
                v25 = v44;
                --v23;
              }
              else
              {
                v25 += v38;
              }
              --v49;
            }
            while ( v49 );
            v24 = v34;
          }
          if ( v24 == v26 )
          {
            v24 = v44;
            --v41;
          }
          else
          {
            v24 += v38;
          }
          v28 = Src[0] + 1 < (unsigned int)*v50;
          v34 = v24;
          ++Src[0];
        }
        while ( v28 );
      }
      break;
    case 2u:
      v19 = (_BYTE *)(v4 + (v9 >> 2));
      v33 = (_BYTE *)(v4 + ((unsigned int)(v6 - 1) >> 2));
      if ( (v5 & 0x10000) != 0 )
      {
        v20 = (2 * (_BYTE)v6 - 1) & 6;
        v21 = (2 * (_BYTE)v8 - 1) & 6;
        v40 = 6;
        v43 = 0;
        v46 = -2;
      }
      else
      {
        v20 = 2 * (3 - (((_BYTE)v6 - 1) & 3));
        v21 = 2 * (3 - (((_BYTE)v8 - 1) & 3));
        v40 = 0;
        v43 = 6;
        v46 = 2;
      }
      v37 = 0;
      if ( v6 )
      {
        do
        {
          v22 = (*v33 >> v20) & 3;
          v31 = v22;
          if ( v51 > 0 )
          {
            v48 = v51;
            while ( 1 )
            {
              *v19 = (v22 << v21) | *v19 & (16191 >> (6 - v21));
              if ( v21 == v43 )
              {
                v21 = v40;
                --v19;
              }
              else
              {
                v21 += v46;
              }
              if ( !--v48 )
                break;
              v22 = v31;
            }
          }
          if ( v20 == v43 )
          {
            v20 = v40;
            --v33;
          }
          else
          {
            v20 += v46;
          }
          ++v37;
        }
        while ( v37 < *v50 );
      }
      goto LABEL_61;
    case 4u:
      v14 = (_BYTE *)(v4 + (v9 >> 1));
      v39 = (_BYTE *)(v4 + ((unsigned int)(v6 - 1) >> 1));
      if ( (v5 & 0x10000) != 0 )
      {
        v15 = (-1 - 4 * (_BYTE)v6) & 4;
        v16 = (-1 - 4 * (_BYTE)v8) & 4;
        v32 = 4;
        v17 = 0;
        v42 = -4;
      }
      else
      {
        v15 = 4 - 4 * (((_BYTE)v6 - 1) & 1);
        v16 = 4 - 4 * (((_BYTE)v8 - 1) & 1);
        v17 = 4;
        v32 = 0;
        v42 = 4;
      }
      v47 = 0;
      if ( v6 )
      {
        do
        {
          v18 = (*v39 >> v15) & 0xF;
          v30 = v18;
          if ( v51 > 0 )
          {
            v36 = v51;
            while ( 1 )
            {
              *v14 = (v18 << v16) | *v14 & (3855 >> (4 - v16));
              if ( v16 == v17 )
              {
                v16 = v32;
                --v14;
              }
              else
              {
                v16 += v42;
              }
              if ( !--v36 )
                break;
              v18 = v30;
            }
          }
          if ( v15 == v17 )
          {
            v15 = v32;
            --v39;
          }
          else
          {
            v15 += v42;
          }
          ++v47;
        }
        while ( v47 < *v50 );
      }
      break;
    default:
      v10 = v7 >> 3;
      v11 = (char *)(v4 + v10 * (v6 - 1));
      v12 = (char *)(v4 + v10 * v9);
      v35 = 0;
      if ( v6 )
      {
        do
        {
          memcpy(Src, v11, v10);
          if ( v51 > 0 )
          {
            v13 = v51;
            do
            {
              memcpy(v12, Src, v10);
              v12 -= v10;
              --v13;
            }
            while ( v13 );
            v8 = v45;
          }
          v11 -= v10;
          ++v35;
        }
        while ( v35 < *v50 );
      }
      goto LABEL_61;
  }
  v8 = v45;
LABEL_61:
  v29 = *(_BYTE *)(a1 + 267);
  *v50 = v8;
  if ( v29 < 8u )
    result = (v8 * (unsigned int)v29 + 7) >> 3;
  else
    result = v8 * (v29 >> 3);
  *(_DWORD *)(a1 + 260) = result;
  return result;
}

//----- (00409860) --------------------------------------------------------
char __cdecl sub_409860(int a1, int a2, _BYTE *a3, _BYTE *a4, int a5)
{
  unsigned int v5; // eax
  unsigned int v6; // esi
  _BYTE *v7; // ecx
  _BYTE *v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // esi
  unsigned int i; // ecx
  _BYTE *v12; // ecx
  _BYTE *v13; // esi
  unsigned int v14; // edx
  unsigned __int8 *v15; // edi
  int v16; // ebp
  unsigned int v17; // ebx
  unsigned __int8 *v18; // esi
  _BYTE *v19; // edi
  unsigned __int8 *v20; // edx
  unsigned int v21; // ecx
  unsigned __int8 *v22; // ebp
  int v23; // edi
  int v24; // ebx
  int v25; // edx
  int v26; // ecx
  int v27; // ebp
  int v28; // eax
  bool v29; // zf
  int v31; // [esp+10h] [ebp-10h]
  unsigned int v32; // [esp+14h] [ebp-Ch]
  unsigned __int8 *v33; // [esp+18h] [ebp-8h]
  unsigned __int8 *v34; // [esp+1Ch] [ebp-4h]
  _BYTE *v35; // [esp+34h] [ebp+14h]

  LOBYTE(v5) = a5;
  switch ( a5 )
  {
    case 0:
      return v5;
    case 1:
      v6 = *(_DWORD *)(a2 + 4);
      v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
      v7 = &a3[v5];
      if ( v5 < v6 )
      {
        v8 = a3;
        v9 = v6 - v5;
        do
        {
          LOBYTE(v5) = *v8;
          *v7++ += *v8++;
          --v9;
        }
        while ( v9 );
      }
      break;
    case 2:
      v10 = *(_DWORD *)(a2 + 4);
      v5 = (unsigned int)a3;
      for ( i = 0; i < v10; ++v5 )
        *(_BYTE *)v5 += a4[i++];
      break;
    case 3:
      v12 = a3;
      v13 = a4;
      v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
      v14 = *(_DWORD *)(a2 + 4) - v5;
      v15 = a3;
      if ( v5 )
      {
        v16 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
        do
        {
          LOBYTE(v5) = *v13 >> 1;
          *v12 += v5;
          ++v13;
          ++v12;
          --v16;
        }
        while ( v16 );
      }
      if ( v14 )
      {
        v17 = v14;
        do
        {
          v5 = ((unsigned __int8)*v13 + *v15) / 2;
          *v12 += v5;
          ++v15;
          ++v13;
          ++v12;
          --v17;
        }
        while ( v17 );
      }
      break;
    case 4:
      v18 = a4;
      v19 = a3;
      v35 = a3;
      v20 = a3;
      v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
      v21 = *(_DWORD *)(a2 + 4) - v5;
      v22 = a4;
      if ( v5 )
      {
        do
        {
          *v19++ += *v18++;
          --v5;
        }
        while ( v5 );
        v35 = v19;
      }
      if ( v21 )
      {
        v32 = v21;
        while ( 1 )
        {
          v23 = *v20;
          v24 = *v18;
          v33 = v20 + 1;
          v25 = *v22;
          ++v18;
          v26 = v23 - v25;
          v34 = v22 + 1;
          if ( v24 - v25 >= 0 )
            v31 = v24 - v25;
          else
            v31 = v25 - v24;
          v27 = v23 - v25;
          if ( v26 < 0 )
            v27 = v25 - v23;
          v28 = v26 + v24 - v25;
          if ( v28 < 0 )
            v28 = -v28;
          if ( v31 > v27 || v31 > v28 )
          {
            if ( v27 <= v28 )
              LOBYTE(v25) = v24;
          }
          else
          {
            LOBYTE(v25) = v23;
          }
          *v35 += v25;
          LOBYTE(v5) = (_BYTE)v35 + 1;
          v29 = v32-- == 1;
          ++v35;
          if ( v29 )
            break;
          v20 = v33;
          v22 = v34;
        }
      }
      break;
    default:
      LOBYTE(v5) = sub_4087F0(a1, "Ignoring bad adaptive filter type");
      *a3 = 0;
      break;
  }
  return v5;
}

//----- (00409A60) --------------------------------------------------------
void *__cdecl sub_409A60(int a1)
{
  int v1; // ebp
  unsigned int v2; // ecx
  unsigned int v3; // eax
  unsigned __int8 v4; // cl
  unsigned int v5; // ecx
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  char v9; // cl
  char v10; // cl
  int v11; // ecx
  char v12; // cl
  int v13; // edx
  unsigned int v14; // edx
  unsigned int v15; // ecx
  char *v16; // eax
  bool v17; // cc
  void *v18; // eax
  void *result; // eax
  size_t v20; // [esp-Ch] [ebp-14h]

  *(_DWORD *)(a1 + 120) = 0;
  sub_40F950(a1);
  if ( *(_BYTE *)(a1 + 291) )
  {
    if ( (*(_BYTE *)(a1 + 112) & 2) != 0 )
      *(_DWORD *)(a1 + 208) = *(_DWORD *)(a1 + 204);
    else
      *(_DWORD *)(a1 + 208) = (*(_DWORD *)(a1 + 204) + 7) / 8u;
    v1 = *(_DWORD *)(a1 + 200);
    v2 = dword_4164D0[*(unsigned __int8 *)(a1 + 292)];
    v3 = (v1 - dword_4164B4[*(unsigned __int8 *)(a1 + 292)] + v2 - 1) / v2;
    v4 = *(_BYTE *)(a1 + 297);
    *(_DWORD *)(a1 + 224) = v3;
    if ( v4 < 8u )
      v5 = (v3 * v4 + 7) >> 3;
    else
      v5 = v3 * (v4 >> 3);
    *(_DWORD *)(a1 + 220) = v5 + 1;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 216);
    v1 = *(_DWORD *)(a1 + 200);
    *(_DWORD *)(a1 + 208) = *(_DWORD *)(a1 + 204);
    *(_DWORD *)(a1 + 224) = v1;
    *(_DWORD *)(a1 + 220) = v6 + 1;
  }
  v7 = *(unsigned __int8 *)(a1 + 297);
  v8 = *(_DWORD *)(a1 + 112);
  if ( (v8 & 4) != 0 && *(_BYTE *)(a1 + 295) < 8u )
    v7 = 8;
  if ( (v8 & 0x1000) != 0 )
  {
    v9 = *(_BYTE *)(a1 + 294);
    if ( v9 == 3 )
    {
      v7 = 8 * (*(_WORD *)(a1 + 282) != 0) + 24;
    }
    else if ( v9 )
    {
      if ( v9 == 2 && *(_WORD *)(a1 + 282) )
        v7 = 4 * v7 / 3;
    }
    else
    {
      if ( v7 < 8 )
        v7 = 8;
      if ( *(_WORD *)(a1 + 282) )
        v7 *= 2;
    }
  }
  if ( (v8 & 0x8000) != 0 )
  {
    v10 = *(_BYTE *)(a1 + 294);
    if ( v10 == 3 )
    {
      v7 = 32;
      goto LABEL_32;
    }
    if ( v10 )
    {
      if ( v10 != 2 )
        goto LABEL_32;
      v11 = v7 > 32 ? 64 : 32;
    }
    else
    {
      v11 = v7 > 8 ? 32 : 16;
    }
    v7 = v11;
  }
LABEL_32:
  if ( (v8 & 0x4000) != 0 )
  {
    if ( *(_WORD *)(a1 + 282) && (v8 & 0x1000) != 0 || (v8 & 0x8000) != 0 || (v12 = *(_BYTE *)(a1 + 294), v12 == 4) )
    {
      v7 = v7 > 16 ? 64 : 32;
    }
    else if ( v7 > 8 )
    {
      v7 = v12 != 6 ? 48 : 64;
    }
    else
    {
      v7 = 8 * (v12 == 6) + 24;
    }
  }
  if ( (v8 & 0x100000) != 0 )
  {
    v13 = *(unsigned __int8 *)(a1 + 100);
    if ( v13 * *(unsigned __int8 *)(a1 + 101) > v7 )
      v7 = v13 * *(unsigned __int8 *)(a1 + 101);
  }
  v14 = (v1 + 7) & 0xFFFFFFF8;
  if ( v7 < 8 )
    v15 = (v14 * v7 + 7) >> 3;
  else
    v15 = v14 * ((unsigned int)v7 >> 3);
  v16 = (char *)sub_408BA0(a1, ((v7 + 7) >> 3) + v15 + 65);
  *(_DWORD *)(a1 + 592) = v16;
  v17 = *(_DWORD *)(a1 + 216) != -1;
  *(_DWORD *)(a1 + 236) = v16 + 32;
  if ( !v17 )
    sub_408740((int *)a1, "Row has too many bytes to allocate in memory.");
  v18 = sub_408BA0(a1, *(_DWORD *)(a1 + 216) + 1);
  v20 = *(_DWORD *)(a1 + 216) + 1;
  *(_DWORD *)(a1 + 232) = v18;
  result = sub_408B10(a1, v18, 0, v20);
  *(_DWORD *)(a1 + 108) |= 0x40u;
  return result;
}

//----- (00409D20) --------------------------------------------------------
unsigned int __cdecl sub_409D20(int *a1, unsigned __int8 *a2)
{
  unsigned int result; // eax

  result = png_get_uint_32(a2);
  if ( result > 0x7FFFFFFF )
    sub_408740(a1, "PNG unsigned integer out of range.\n");
  return result;
}

//----- (00409D50) --------------------------------------------------------
int __cdecl png_crc_finish(struct png_struct_def *a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned int i; // edi

  v2 = *((_DWORD *)a1 + 44);
  for ( i = a2; i > v2; i -= v2 )
    png_crc_read(a1, *((unsigned __int8 **)a1 + 43), *((_DWORD *)a1 + 44));
  if ( i )
    png_crc_read(a1, *((unsigned __int8 **)a1 + 43), i);
  if ( !png_crc_error(a1) )
    return 0;
  if ( ((*((_BYTE *)a1 + 284) & 0x20) == 0 || (*((_DWORD *)a1 + 27) & 0x200) != 0)
    && ((*((_BYTE *)a1 + 284) & 0x20) != 0 || (*((_DWORD *)a1 + 27) & 0x400) == 0) )
  {
    sub_408850((int *)a1, "CRC error");
  }
  sub_408880((int)a1, "CRC error");
  return 1;
}

//----- (00409E10) --------------------------------------------------------
void __cdecl sub_409E10(int a1, int a2, int a3)
{
  int v3; // edi
  unsigned int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // ebp
  unsigned __int8 v9; // al
  unsigned int v10; // eax
  int v11; // [esp+10h] [ebp-20h]
  int v12; // [esp+14h] [ebp-1Ch]
  unsigned __int8 v13[4]; // [esp+1Ch] [ebp-14h] BYREF
  unsigned __int8 v14[8]; // [esp+20h] [ebp-10h] BYREF
  unsigned __int8 v15; // [esp+28h] [ebp-8h]

  if ( (*(_BYTE *)(a1 + 104) & 1) != 0 )
    sub_408740((int *)a1, "Out of place IHDR");
  if ( a3 != 13 )
    sub_408740((int *)a1, "Invalid IHDR chunk");
  *(_DWORD *)(a1 + 104) |= 1u;
  png_crc_read((struct png_struct_def *)a1, v13, 0xDu);
  png_crc_finish((struct png_struct_def *)a1, 0);
  v3 = sub_409D20((int *)a1, v13);
  v4 = sub_409D20((int *)a1, v14);
  v5 = v14[5];
  v6 = v14[4];
  v7 = v14[6];
  v8 = v4;
  v11 = v14[7];
  v12 = v15;
  *(_BYTE *)(a1 + 291) = v15;
  *(_BYTE *)(a1 + 568) = v11;
  *(_DWORD *)(a1 + 200) = v3;
  *(_DWORD *)(a1 + 204) = v4;
  *(_BYTE *)(a1 + 295) = v6;
  *(_BYTE *)(a1 + 294) = v5;
  *(_BYTE *)(a1 + 608) = v7;
  switch ( (char)v5 )
  {
    case 0:
    case 3:
      *(_BYTE *)(a1 + 298) = 1;
      break;
    case 2:
      *(_BYTE *)(a1 + 298) = 3;
      break;
    case 4:
      *(_BYTE *)(a1 + 298) = 2;
      break;
    case 6:
      *(_BYTE *)(a1 + 298) = 4;
      break;
    default:
      break;
  }
  v9 = v6 * *(_BYTE *)(a1 + 298);
  *(_BYTE *)(a1 + 297) = v9;
  if ( v9 < 8u )
    v10 = (v3 * (unsigned int)v9 + 7) >> 3;
  else
    v10 = v3 * (v9 >> 3);
  *(_DWORD *)(a1 + 216) = v10;
  png_set_IHDR((int *)a1, a2, v3, v8, v6, v5, v12, v7, v11);
}

//----- (00409F90) --------------------------------------------------------
void __cdecl sub_409F90(int a1, int a2, signed int a3)
{
  int v3; // eax
  char v4; // cl
  int v5; // ebx
  char *v6; // edi
  int v7; // ebp
  unsigned __int8 v8; // al
  unsigned __int8 v9; // cl
  unsigned __int8 v10[4]; // [esp+4h] [ebp-304h] BYREF
  char Src[2]; // [esp+8h] [ebp-300h] BYREF
  char v12; // [esp+Ah] [ebp-2FEh] BYREF

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 1) == 0 )
    sub_408740((int *)a1, "Missing IHDR before PLTE");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0(a1, "Invalid PLTE after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else
  {
    if ( (v3 & 2) != 0 )
      sub_408740((int *)a1, "Duplicate PLTE chunk");
    v4 = *(_BYTE *)(a1 + 294);
    *(_DWORD *)(a1 + 104) |= 2u;
    if ( (v4 & 2) != 0 )
    {
      if ( (unsigned int)a3 > 0x300 || a3 % 3u )
      {
        if ( v4 == 3 )
          sub_408740((int *)a1, "Invalid palette chunk");
        sub_4087F0(a1, "Invalid palette chunk");
        png_crc_finish((struct png_struct_def *)a1, a3);
      }
      else
      {
        v5 = a3 / 3;
        if ( a3 / 3 > 0 )
        {
          v6 = &v12;
          v7 = a3 / 3;
          do
          {
            png_crc_read((struct png_struct_def *)a1, v10, 3u);
            v8 = v10[1];
            v9 = v10[2];
            *(v6 - 2) = v10[0];
            *(v6 - 1) = v8;
            *v6 = v9;
            v6 += 3;
            --v7;
          }
          while ( v7 );
        }
        png_crc_finish((struct png_struct_def *)a1, 0);
        sub_411A50(a1, a2, Src, v5);
        if ( *(_BYTE *)(a1 + 294) == 3 && a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
        {
          if ( *(_WORD *)(a1 + 282) > (unsigned __int16)v5 )
          {
            sub_4087F0(a1, "Truncating incorrect tRNS chunk length");
            *(_WORD *)(a1 + 282) = v5;
          }
          if ( *(_WORD *)(a2 + 22) > (unsigned __int16)v5 )
          {
            sub_4087F0(a1, "Truncating incorrect info tRNS chunk length");
            *(_WORD *)(a2 + 22) = v5;
          }
        }
      }
    }
    else
    {
      sub_4087F0(a1, "Ignoring PLTE chunk in grayscale PNG");
      png_crc_finish((struct png_struct_def *)a1, a3);
    }
  }
}

//----- (0040A120) --------------------------------------------------------
int __cdecl sub_40A120(int *a1, int a2, unsigned int a3)
{
  int v3; // eax

  v3 = a1[26];
  if ( (v3 & 1) == 0 || (v3 & 4) == 0 )
    sub_408740(a1, "No image in file");
  a1[26] |= 0x18u;
  if ( a3 )
    sub_4087F0((int)a1, "Incorrect IEND chunk length");
  return png_crc_finish((struct png_struct_def *)a1, a3);
}

//----- (0040A170) --------------------------------------------------------
void __cdecl sub_40A170(int *a1, int a2, unsigned int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  unsigned int v7; // edi
  int v8; // eax
  int v9; // edi
  FILE *v10; // eax
  float v11; // [esp+14h] [ebp-4h]

  v3 = (int)a1;
  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before gAMA");
  if ( (v4 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid gAMA after IDAT");
    png_crc_finish((struct png_struct_def *)v3, a3);
  }
  else
  {
    if ( (v4 & 2) != 0 )
      sub_4087F0((int)a1, "Out of place gAMA chunk");
    v5 = a2;
    if ( a2 && (v6 = *(_DWORD *)(a2 + 8), (v6 & 1) != 0) && (v6 & 0x800) == 0 )
    {
      sub_4087F0(v3, "Duplicate gAMA chunk");
      png_crc_finish((struct png_struct_def *)v3, a3);
    }
    else
    {
      v7 = a3;
      if ( a3 == 4 )
      {
        png_crc_read((struct png_struct_def *)v3, (unsigned __int8 *)&a1, 4u);
        if ( !png_crc_finish((struct png_struct_def *)v3, 0) )
        {
          v8 = png_get_uint_32((unsigned __int8 *)&a1);
          v9 = v8;
          if ( v8 )
          {
            if ( (*(_DWORD *)(v5 + 8) & 0x800) != 0 && (v8 < 45000 || v8 > 46000) )
            {
              sub_4087F0(v3, "Ignoring incorrect gAMA value when sRGB is also present");
              v10 = _iob_func();
              fprintf(v10 + 2, "gamma = (%d/100000)\n", v9);
            }
            else
            {
              v11 = (double)v8 / 100000.0;
              *(float *)(v3 + 348) = v11;
              sub_411420(v3, v5, v11);
              sub_4114A0(v3, v5, v9);
            }
          }
          else
          {
            sub_4087F0(v3, "Ignoring gAMA chunk with gamma=0");
          }
        }
      }
      else
      {
        sub_4087F0(v3, "Incorrect gAMA chunk length");
        png_crc_finish((struct png_struct_def *)v3, v7);
      }
    }
  }
}

//----- (0040A2E0) --------------------------------------------------------
void __cdecl sub_40A2E0(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  unsigned int v4; // eax
  unsigned __int8 *v5; // eax
  char v6; // dl
  char v7; // cl
  char v8; // dl
  unsigned __int8 v9; // cl
  unsigned __int8 v10; // [esp+8h] [ebp-4h] BYREF
  char v11; // [esp+9h] [ebp-3h]
  char v12; // [esp+Ah] [ebp-2h]
  char v13; // [esp+Bh] [ebp-1h]

  v3 = *(_DWORD *)(a1 + 104);
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  if ( (v3 & 1) == 0 )
    sub_408740((int *)a1, "Missing IHDR before sBIT");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0(a1, "Invalid sBIT after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else
  {
    if ( (v3 & 2) != 0 )
      sub_4087F0(a1, "Out of place sBIT chunk");
    if ( a2 && (*(_BYTE *)(a2 + 8) & 2) != 0 )
    {
      sub_4087F0(a1, "Duplicate sBIT chunk");
      png_crc_finish((struct png_struct_def *)a1, a3);
    }
    else
    {
      v4 = 3;
      if ( *(_BYTE *)(a1 + 294) != 3 )
        v4 = *(unsigned __int8 *)(a1 + 298);
      if ( a3 == v4 && a3 <= 4 )
      {
        png_crc_read((struct png_struct_def *)a1, &v10, v4);
        if ( !png_crc_finish((struct png_struct_def *)a1, 0) )
        {
          v5 = (unsigned __int8 *)(a1 + 380);
          if ( (*(_BYTE *)(a1 + 294) & 2) != 0 )
          {
            v6 = v11;
            *v5 = v10;
            v7 = v12;
            *(_BYTE *)(a1 + 381) = v6;
            v8 = v13;
            *(_BYTE *)(a1 + 382) = v7;
            *(_BYTE *)(a1 + 384) = v8;
          }
          else
          {
            v9 = v10;
            *(_BYTE *)(a1 + 383) = v10;
            *v5 = v9;
            *(_BYTE *)(a1 + 381) = v9;
            *(_BYTE *)(a1 + 382) = v9;
            *(_BYTE *)(a1 + 384) = v11;
          }
          sub_411AE0(a1, a2, a1 + 380);
        }
      }
      else
      {
        sub_4087F0(a1, "Incorrect sBIT chunk length");
        png_crc_finish((struct png_struct_def *)a1, a3);
      }
    }
  }
}

//----- (0040A450) --------------------------------------------------------
int __cdecl sub_40A450(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // ebx
  bool v15; // zf
  FILE *v16; // eax
  FILE *v17; // eax
  double v18; // [esp+20h] [ebp-A0h]
  double v19; // [esp+20h] [ebp-A0h]
  double v20; // [esp+28h] [ebp-98h]
  double v21; // [esp+28h] [ebp-98h]
  double v22; // [esp+30h] [ebp-90h]
  double v23; // [esp+30h] [ebp-90h]
  double v24; // [esp+38h] [ebp-88h]
  double v25; // [esp+38h] [ebp-88h]
  unsigned __int8 v26[4]; // [esp+84h] [ebp-3Ch] BYREF
  int v27; // [esp+88h] [ebp-38h]
  int v28; // [esp+8Ch] [ebp-34h]
  int v29; // [esp+90h] [ebp-30h]
  int v30; // [esp+94h] [ebp-2Ch]
  int v31; // [esp+98h] [ebp-28h]
  int v32; // [esp+9Ch] [ebp-24h]
  float v33; // [esp+A0h] [ebp-20h]
  float v34; // [esp+A4h] [ebp-1Ch]
  float v35; // [esp+A8h] [ebp-18h]
  float v36; // [esp+ACh] [ebp-14h]
  float v37; // [esp+B0h] [ebp-10h]
  float v38; // [esp+B4h] [ebp-Ch]
  float v39; // [esp+B8h] [ebp-8h]
  float v40; // [esp+BCh] [ebp-4h]

  v3 = a1[26];
  if ( (v3 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before cHRM");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid cHRM after IDAT");
    result = png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else
  {
    if ( (v3 & 2) != 0 )
      sub_4087F0((int)a1, "Missing PLTE before cHRM");
    if ( a2 && (v5 = *(_DWORD *)(a2 + 8), (v5 & 4) != 0) && (v5 & 0x800) == 0 )
    {
      sub_4087F0((int)a1, "Duplicate cHRM chunk");
      result = png_crc_finish((struct png_struct_def *)a1, a3);
    }
    else if ( a3 == 32 )
    {
      png_crc_read((struct png_struct_def *)a1, v26, 4u);
      v6 = png_get_uint_32(v26);
      png_crc_read((struct png_struct_def *)a1, v26, 4u);
      v7 = png_get_uint_32(v26);
      if ( v6 > 0x13880 || v7 > 0x13880 || v7 + v6 > 0x186A0 )
      {
        sub_4087F0((int)a1, "Invalid cHRM white point");
        result = png_crc_finish((struct png_struct_def *)a1, 0x18u);
      }
      else
      {
        v32 = v6;
        v31 = v7;
        png_crc_read((struct png_struct_def *)a1, v26, 4u);
        v8 = png_get_uint_32(v26);
        png_crc_read((struct png_struct_def *)a1, v26, 4u);
        v9 = png_get_uint_32(v26);
        if ( v8 > 0x13880 || v9 > 0x13880 || v9 + v8 > 0x186A0 )
        {
          sub_4087F0((int)a1, "Invalid cHRM red point");
          result = png_crc_finish((struct png_struct_def *)a1, 0x10u);
        }
        else
        {
          v30 = v8;
          v29 = v9;
          png_crc_read((struct png_struct_def *)a1, v26, 4u);
          v10 = png_get_uint_32(v26);
          png_crc_read((struct png_struct_def *)a1, v26, 4u);
          v11 = png_get_uint_32(v26);
          if ( v10 > 0x13880 || v11 > 0x13880 || v11 + v10 > 0x186A0 )
          {
            sub_4087F0((int)a1, "Invalid cHRM green point");
            result = png_crc_finish((struct png_struct_def *)a1, 8u);
          }
          else
          {
            v28 = v10;
            v27 = v11;
            png_crc_read((struct png_struct_def *)a1, v26, 4u);
            v12 = png_get_uint_32(v26);
            v34 = *(float *)&v12;
            png_crc_read((struct png_struct_def *)a1, v26, 4u);
            v13 = png_get_uint_32(v26);
            v14 = v13;
            v33 = *(float *)&v13;
            if ( (unsigned int)v12 > 0x13880 || (unsigned int)v13 > 0x13880 || (unsigned int)(v13 + v12) > 0x186A0 )
            {
              sub_4087F0((int)a1, "Invalid cHRM blue point");
              result = png_crc_finish((struct png_struct_def *)a1, 0);
            }
            else
            {
              v15 = (*(_DWORD *)(a2 + 8) & 0x800) == 0;
              v40 = (double)v32 / 100000.0;
              v39 = (double)v31 / 100000.0;
              v38 = (double)v30 / 100000.0;
              v37 = (double)v29 / 100000.0;
              v36 = (double)v28 / 100000.0;
              v35 = (double)v27 / 100000.0;
              v34 = (double)SLODWORD(v34) / 100000.0;
              v33 = (double)SLODWORD(v33) / 100000.0;
              if ( v15 )
              {
                png_set_cHRM((int)a1, a2, v40, v39, v38, v37, v36, v35, v34, v33);
                sub_411230((int)a1, a2, v32, v31, v30, v29, v28, v27, v12, v14);
                result = png_crc_finish((struct png_struct_def *)a1, 0);
              }
              else
              {
                if ( (unsigned int)(v32 - 30270) > 0x7D0
                  || (unsigned int)(v31 - 31900) > 0x7D0
                  || (unsigned int)(v30 - 63000) > 0x7D0
                  || (unsigned int)(v29 - 32000) > 0x7D0
                  || (unsigned int)(v28 - 29000) > 0x7D0
                  || (unsigned int)(v27 - 59000) > 0x7D0
                  || v12 < 14000
                  || v12 > 16000
                  || v13 < 5000
                  || v13 > 7000 )
                {
                  sub_4087F0((int)a1, "Ignoring incorrect cHRM value when sRGB is also present");
                  v24 = v37;
                  v22 = v38;
                  v20 = v39;
                  v18 = v40;
                  v16 = _iob_func();
                  fprintf(v16 + 2, "wx=%f, wy=%f, rx=%f, ry=%f\n", v18, v20, v22, v24);
                  v25 = v33;
                  v23 = v34;
                  v21 = v35;
                  v19 = v36;
                  v17 = _iob_func();
                  fprintf(v17 + 2, "gx=%f, gy=%f, bx=%f, by=%f\n", v19, v21, v23, v25);
                }
                result = png_crc_finish((struct png_struct_def *)a1, 0);
              }
            }
          }
        }
      }
    }
    else
    {
      sub_4087F0((int)a1, "Incorrect cHRM chunk length");
      result = png_crc_finish((struct png_struct_def *)a1, a3);
    }
  }
  return result;
}

//----- (0040A940) --------------------------------------------------------
void __cdecl sub_40A940(int *a1, int a2, unsigned int a3)
{
  int v3; // edi
  int v4; // eax
  int v5; // esi
  unsigned int v6; // ebx
  char v7; // bl
  int v8; // eax
  FILE *v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // [esp-Ch] [ebp-10h]

  v3 = (int)a1;
  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before sRGB");
  if ( (v4 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid sRGB after IDAT");
    png_crc_finish((struct png_struct_def *)v3, a3);
  }
  else
  {
    if ( (v4 & 2) != 0 )
      sub_4087F0((int)a1, "Out of place sRGB chunk");
    v5 = a2;
    if ( a2 && (*(_DWORD *)(a2 + 8) & 0x800) != 0 )
    {
      sub_4087F0(v3, "Duplicate sRGB chunk");
      png_crc_finish((struct png_struct_def *)v3, a3);
    }
    else
    {
      v6 = a3;
      if ( a3 == 1 )
      {
        png_crc_read((struct png_struct_def *)v3, (unsigned __int8 *)&a1, 1u);
        if ( !png_crc_finish((struct png_struct_def *)v3, 0) )
        {
          v7 = (char)a1;
          if ( (unsigned __int8)a1 < 4u )
          {
            if ( (*(_BYTE *)(v5 + 8) & 1) != 0 )
            {
              v8 = *(_DWORD *)(v5 + 252);
              if ( v8 < 45000 || v8 > 46000 )
              {
                sub_4087F0(v3, "Ignoring incorrect gAMA value when sRGB is also present");
                v18 = *(_DWORD *)(v3 + 564);
                v9 = _iob_func();
                fprintf(v9 + 2, "incorrect gamma=(%d/100000)\n", v18);
              }
            }
            if ( (*(_BYTE *)(v5 + 8) & 4) != 0 )
            {
              v10 = *(_DWORD *)(v5 + 256);
              if ( v10 < 30270
                || v10 > 32270
                || (v11 = *(_DWORD *)(v5 + 260), v11 < 31900)
                || v11 > 33900
                || (v12 = *(_DWORD *)(v5 + 264), v12 < 63000)
                || v12 > 65000
                || (v13 = *(_DWORD *)(v5 + 268), v13 < 32000)
                || v13 > 34000
                || (v14 = *(_DWORD *)(v5 + 272), v14 < 29000)
                || v14 > 31000
                || (v15 = *(_DWORD *)(v5 + 276), v15 < 59000)
                || v15 > 61000
                || (v16 = *(_DWORD *)(v5 + 280), v16 < 14000)
                || v16 > 16000
                || (v17 = *(_DWORD *)(v5 + 284), v17 < 5000)
                || v17 > 7000 )
              {
                sub_4087F0(v3, "Ignoring incorrect cHRM value when sRGB is also present");
              }
            }
            sub_411B30(v3, v5, v7);
          }
          else
          {
            sub_4087F0(v3, "Unknown sRGB intent");
          }
        }
      }
      else
      {
        sub_4087F0(v3, "Incorrect sRGB chunk length");
        png_crc_finish((struct png_struct_def *)v3, v6);
      }
    }
  }
}

//----- (0040AB30) --------------------------------------------------------
void __cdecl sub_40AB30(int *a1, int a2, unsigned int a3)
{
  struct png_struct_def *v3; // edi
  int v4; // eax
  unsigned int v5; // ebp
  unsigned __int8 *v6; // ebx
  unsigned __int8 *i; // esi
  unsigned __int8 *v8; // esi
  unsigned __int8 v9; // al
  _BYTE *v10; // esi
  size_t v11; // esi
  char *v12; // ebp
  size_t v13; // eax
  unsigned __int16 v14; // dx
  unsigned int v15; // edx
  char v16; // [esp+4h] [ebp-4h]

  v3 = (struct png_struct_def *)a1;
  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before iCCP");
  if ( (v4 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid iCCP after IDAT");
    png_crc_finish(v3, a3);
    return;
  }
  if ( (v4 & 2) != 0 )
    sub_4087F0((int)a1, "Out of place iCCP chunk");
  if ( a2 && (*(_DWORD *)(a2 + 8) & 0x1000) != 0 )
  {
    sub_4087F0((int)v3, "Duplicate iCCP chunk");
    png_crc_finish(v3, a3);
    return;
  }
  v5 = a3;
  v6 = (unsigned __int8 *)sub_408BA0((int)v3, a3 + 1);
  png_crc_read(v3, v6, v5);
  if ( png_crc_finish(v3, 0) )
  {
    sub_408BF0((int)v3, v6);
    return;
  }
  v6[v5] = 0;
  for ( i = v6; *i; ++i )
    ;
  v8 = i + 1;
  if ( v8 >= &v6[v5] )
  {
    sub_408BF0((int)v3, v6);
    sub_4087F0((int)v3, "Malformed iCCP chunk");
    return;
  }
  v9 = *v8;
  v10 = v8 + 1;
  if ( v9 )
  {
    sub_4087F0((int)v3, "Ignoring nonzero compression type in iCCP chunk");
    v9 = 0;
  }
  v11 = v10 - v6;
  v16 = v9;
  v12 = sub_408D40((int)v3, v9, (char *)v6, v5, v11, (size_t *)&a1);
  v13 = (size_t)a1 - v11;
  if ( v11 > (unsigned int)a1 || v13 < 4 )
  {
    sub_408BF0((int)v3, v12);
    sub_4087F0((int)v3, "Profile size field missing from iCCP chunk");
  }
  else
  {
    HIBYTE(v14) = v12[v11];
    LOBYTE(v14) = v12[v11 + 1];
    v15 = (unsigned __int8)v12[v11 + 3] | (((unsigned __int8)v12[v11 + 2] | (v14 << 8)) << 8);
    if ( v15 < v13 )
    {
      v13 = v15;
LABEL_22:
      sub_411C10((int)v3, a2, (int)v12, v16, &v12[v11], v13);
      sub_408BF0((int)v3, v12);
      return;
    }
    if ( v15 <= v13 )
      goto LABEL_22;
    sub_408BF0((int)v3, v12);
    sub_4087F0((int)v3, "Ignoring truncated iCCP profile.\n");
  }
}

//----- (0040ACE0) --------------------------------------------------------
void __cdecl sub_40ACE0(int *a1, int a2, unsigned int a3)
{
  int v3; // ebx
  int v4; // eax
  unsigned __int8 *v5; // ebp
  unsigned __int8 *i; // esi
  unsigned __int8 *v7; // esi
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // esi
  int v10; // ecx
  unsigned int v11; // eax
  char *v12; // eax
  int v13; // edi
  int v14; // ebx
  char *v15; // edx
  __int16 v16; // ax
  unsigned __int8 *v17; // esi
  __int16 v18; // cx
  __int16 v19; // ax
  unsigned __int8 *v20; // esi
  __int16 v21; // ax
  unsigned __int8 *v22; // esi
  __int16 *v23; // edx
  __int16 v24; // ax
  int v25; // edx
  __int16 v26; // ax
  int v27; // edx
  __int16 v28; // ax
  int v29; // edx
  __int16 v30; // ax
  int v31; // edx
  unsigned __int8 *v32; // [esp+8h] [ebp-10h] BYREF
  int v33; // [esp+Ch] [ebp-Ch]
  void *Block; // [esp+10h] [ebp-8h]
  int v35; // [esp+14h] [ebp-4h]

  v3 = (int)a1;
  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before sPLT");
  if ( (v4 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid sPLT after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else
  {
    v5 = (unsigned __int8 *)sub_408BA0((int)a1, a3 + 1);
    png_crc_read((struct png_struct_def *)a1, v5, a3);
    if ( png_crc_finish((struct png_struct_def *)a1, 0) )
    {
      sub_408BF0((int)a1, v5);
    }
    else
    {
      v5[a3] = 0;
      for ( i = v5; *i; ++i )
        ;
      v7 = i + 1;
      if ( v7 <= &v5[a3] )
      {
        v8 = *v7;
        v9 = v7 + 1;
        LOBYTE(v33) = v8;
        v10 = 4 * (v8 != 8) + 6;
        v11 = (int)(a3 + v5 - v9) / v10;
        if ( (int)(a3 + v5 - v9) % v10 )
        {
          sub_408BF0((int)a1, v5);
          sub_4087F0((int)a1, "sPLT chunk has bad length");
        }
        else
        {
          v35 = (int)(a3 + v5 - v9) / v10;
          if ( v11 <= 0x19999999 )
          {
            v12 = (char *)sub_408C20((int)a1, 10 * v11);
            Block = v12;
            if ( v12 )
            {
              v13 = 0;
              if ( v35 > 0 )
              {
                v14 = 0;
                while ( 1 )
                {
                  v15 = &v12[v14];
                  if ( (_BYTE)v33 == 8 )
                  {
                    v16 = *v9;
                    v17 = v9 + 1;
                    *(_WORD *)v15 = v16;
                    v18 = *v17++;
                    *((_WORD *)v15 + 1) = v18;
                    v19 = *v17++;
                    *((_WORD *)v15 + 2) = v19;
                    *((_WORD *)v15 + 3) = *v17;
                    v20 = v17 + 1;
                  }
                  else
                  {
                    v21 = sub_408C80(v9);
                    v22 = v9 + 2;
                    *v23 = v21;
                    v24 = sub_408C80(v22);
                    v22 += 2;
                    *(_WORD *)(v25 + 2) = v24;
                    v26 = sub_408C80(v22);
                    v22 += 2;
                    *(_WORD *)(v27 + 4) = v26;
                    v28 = sub_408C80(v22);
                    *(_WORD *)(v29 + 6) = v28;
                    v20 = v22 + 2;
                  }
                  v30 = sub_408C80(v20);
                  ++v13;
                  *(_WORD *)(v31 + 8) = v30;
                  v9 = v20 + 2;
                  v14 += 10;
                  if ( v13 >= v35 )
                    break;
                  v12 = (char *)Block;
                }
                v3 = (int)a1;
              }
              v32 = v5;
              sub_411FC0(v3, a2, (int)&v32, 1);
              sub_408BF0(v3, v5);
              sub_408BF0(v3, Block);
            }
            else
            {
              sub_4087F0((int)a1, "sPLT chunk requires too much memory");
            }
          }
          else
          {
            sub_4087F0((int)a1, "sPLT chunk too long");
          }
        }
      }
      else
      {
        sub_408BF0((int)a1, v5);
        sub_4087F0((int)a1, "malformed sPLT chunk");
      }
    }
  }
}
// 40AE74: variable 'v23' is possibly undefined
// 40AE80: variable 'v25' is possibly undefined
// 40AE8D: variable 'v27' is possibly undefined
// 40AE99: variable 'v29' is possibly undefined
// 40AEAC: variable 'v31' is possibly undefined

//----- (0040AF00) --------------------------------------------------------
void __cdecl sub_40AF00(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  char v4; // al
  unsigned int v5; // edi
  unsigned __int8 v6[4]; // [esp+8h] [ebp-110h] BYREF
  unsigned __int8 v7[2]; // [esp+Ch] [ebp-10Ch] BYREF
  unsigned __int8 v8[2]; // [esp+Eh] [ebp-10Ah] BYREF
  unsigned __int8 v9[4]; // [esp+10h] [ebp-108h] BYREF
  unsigned __int8 Src[256]; // [esp+14h] [ebp-104h] BYREF

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 1) == 0 )
    sub_408740((int *)a1, "Missing IHDR before tRNS");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0(a1, "Invalid tRNS after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
    return;
  }
  if ( a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
  {
    sub_4087F0(a1, "Duplicate tRNS chunk");
    png_crc_finish((struct png_struct_def *)a1, a3);
    return;
  }
  v4 = *(_BYTE *)(a1 + 294);
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      v5 = a3;
      if ( a3 != 6 )
        goto LABEL_5;
      png_crc_read((struct png_struct_def *)a1, v7, 6u);
      *(_WORD *)(a1 + 282) = 1;
      *(_WORD *)(a1 + 398) = sub_408C80(v7);
      *(_WORD *)(a1 + 400) = sub_408C80(v8);
      *(_WORD *)(a1 + 402) = sub_408C80(v9);
    }
    else
    {
      if ( v4 != 3 )
      {
        sub_4087F0(a1, "tRNS chunk not allowed with alpha channel");
        png_crc_finish((struct png_struct_def *)a1, a3);
        return;
      }
      if ( (*(_BYTE *)(a1 + 104) & 2) == 0 )
        sub_4087F0(a1, "Missing PLTE before tRNS");
      v5 = a3;
      if ( a3 > *(unsigned __int16 *)(a1 + 280) || a3 > 0x100 )
        goto LABEL_5;
      if ( !a3 )
      {
        sub_4087F0(a1, "Zero length tRNS chunk");
        png_crc_finish((struct png_struct_def *)a1, 0);
        return;
      }
      png_crc_read((struct png_struct_def *)a1, Src, a3);
      *(_WORD *)(a1 + 282) = a3;
    }
  }
  else
  {
    v5 = a3;
    if ( a3 != 2 )
    {
LABEL_5:
      sub_4087F0(a1, "Incorrect tRNS chunk length");
      png_crc_finish((struct png_struct_def *)a1, v5);
      return;
    }
    png_crc_read((struct png_struct_def *)a1, v6, 2u);
    *(_WORD *)(a1 + 282) = 1;
    *(_WORD *)(a1 + 404) = sub_408C80(v6);
  }
  if ( !png_crc_finish((struct png_struct_def *)a1, 0) )
    sub_411F30(a1, a2, Src, *(unsigned __int16 *)(a1 + 282), a1 + 396);
}

//----- (0040B150) --------------------------------------------------------
void __cdecl png_handle_bKGD(struct png_struct_def *a1, struct png_info_struct *a2, unsigned int a3)
{
  int v3; // eax
  char v4; // al
  unsigned int v5; // eax
  char v6; // al
  unsigned __int8 v7; // cl
  unsigned __int16 v8; // ax
  int v9; // eax
  int v10; // ecx
  __int16 v11; // dx
  int v12; // eax
  __int16 v13; // ax
  int v14; // [esp+8h] [ebp-Ch] BYREF
  unsigned __int8 v15[4]; // [esp+Ch] [ebp-8h] BYREF

  v3 = *((_DWORD *)a1 + 26);
  if ( (v3 & 1) == 0 )
    sub_408740((int *)a1, "Missing IHDR before bKGD");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid bKGD after IDAT");
    png_crc_finish(a1, a3);
    return;
  }
  if ( *((_BYTE *)a1 + 294) == 3 && (v3 & 2) == 0 )
  {
    sub_4087F0((int)a1, "Missing PLTE before bKGD");
    png_crc_finish(a1, a3);
    return;
  }
  if ( a2 && (*((_BYTE *)a2 + 8) & 0x20) != 0 )
  {
    sub_4087F0((int)a1, "Duplicate bKGD chunk");
    png_crc_finish(a1, a3);
    return;
  }
  v4 = *((_BYTE *)a1 + 294);
  if ( v4 == 3 )
    v5 = 1;
  else
    v5 = 2 * (v4 & 2 | 1);
  if ( a3 != v5 )
  {
    sub_4087F0((int)a1, "Incorrect bKGD chunk length");
    png_crc_finish(a1, a3);
    return;
  }
  png_crc_read(a1, (unsigned __int8 *)&v14, v5);
  if ( !png_crc_finish(a1, 0) )
  {
    v6 = *((_BYTE *)a1 + 294);
    if ( v6 == 3 )
    {
      v7 = v14;
      *((_BYTE *)a1 + 312) = v14;
      v8 = *((_WORD *)a2 + 10);
      if ( v8 )
      {
        if ( v7 > v8 )
        {
          sub_4087F0((int)a1, "Incorrect bKGD chunk index value");
          return;
        }
        v9 = v7;
        v10 = *((_DWORD *)a1 + 69);
        v9 *= 3;
        v11 = *(unsigned __int8 *)(v9 + v10);
        v12 = v10 + v9;
        *((_WORD *)a1 + 157) = v11;
        *((_WORD *)a1 + 158) = *(unsigned __int8 *)(v12 + 1);
        *((_WORD *)a1 + 159) = *(unsigned __int8 *)(v12 + 2);
      }
    }
    else
    {
      if ( (v6 & 2) != 0 )
      {
        *((_WORD *)a1 + 157) = sub_408C80((unsigned __int8 *)&v14);
        *((_WORD *)a1 + 158) = sub_408C80((unsigned __int8 *)&v14 + 2);
        v13 = sub_408C80(v15);
      }
      else
      {
        v13 = sub_408C80((unsigned __int8 *)&v14);
        *((_WORD *)a1 + 160) = v13;
        *((_WORD *)a1 + 158) = v13;
        *((_WORD *)a1 + 157) = v13;
      }
      *((_WORD *)a1 + 159) = v13;
    }
    sub_410EC0((int)a1, (int)a2, (int)a1 + 312);
  }
}

//----- (0040B390) --------------------------------------------------------
void __cdecl sub_40B390(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  unsigned int v4; // ebx
  unsigned int i; // edi
  unsigned __int8 v6[4]; // [esp+8h] [ebp-208h] BYREF
  __int16 v7[256]; // [esp+Ch] [ebp-204h] BYREF

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 1) == 0 )
    sub_408740((int *)a1, "Missing IHDR before hIST");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0(a1, "Invalid hIST after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else if ( (v3 & 2) != 0 )
  {
    if ( a2 && (*(_BYTE *)(a2 + 8) & 0x40) != 0 )
    {
      sub_4087F0(a1, "Duplicate hIST chunk");
      png_crc_finish((struct png_struct_def *)a1, a3);
    }
    else
    {
      v4 = a3 >> 1;
      if ( a3 >> 1 == *(unsigned __int16 *)(a1 + 280) && v4 <= 0x100 )
      {
        for ( i = 0; i < v4; ++i )
        {
          png_crc_read((struct png_struct_def *)a1, v6, 2u);
          v7[i] = sub_408C80(v6);
        }
        if ( !png_crc_finish((struct png_struct_def *)a1, 0) )
          sub_411520(a1, a2, (int)v7);
      }
      else
      {
        sub_4087F0(a1, "Incorrect hIST chunk length");
        png_crc_finish((struct png_struct_def *)a1, a3);
      }
    }
  }
  else
  {
    sub_4087F0(a1, "Missing PLTE before hIST");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
}

//----- (0040B530) --------------------------------------------------------
void __cdecl sub_40B530(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // [esp-Ch] [ebp-24h]
  char v6; // [esp-8h] [ebp-20h]
  unsigned __int8 v7[4]; // [esp+8h] [ebp-10h] BYREF
  int v8; // [esp+Ch] [ebp-Ch] BYREF
  char v9; // [esp+10h] [ebp-8h]

  v3 = a1[26];
  if ( (v3 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before pHYs");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid pHYs after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else if ( a2 && *(char *)(a2 + 8) < 0 )
  {
    sub_4087F0((int)a1, "Duplicate pHYs chunk");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else if ( a3 == 9 )
  {
    png_crc_read((struct png_struct_def *)a1, v7, 9u);
    if ( !png_crc_finish((struct png_struct_def *)a1, 0) )
    {
      v6 = v9;
      v5 = png_get_uint_32((unsigned __int8 *)&v8);
      v4 = png_get_uint_32(v7);
      sub_411A20((int)a1, a2, v4, v5, v6);
    }
  }
  else
  {
    sub_4087F0((int)a1, "Incorrect pHYs chunk length");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
}

//----- (0040B650) --------------------------------------------------------
void __cdecl sub_40B650(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // [esp-Ch] [ebp-24h]
  char v6; // [esp-8h] [ebp-20h]
  unsigned __int8 v7[4]; // [esp+8h] [ebp-10h] BYREF
  int v8; // [esp+Ch] [ebp-Ch] BYREF
  char v9; // [esp+10h] [ebp-8h]

  v3 = a1[26];
  if ( (v3 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before oFFs");
  if ( (v3 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid oFFs after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else if ( a2 && (*(_DWORD *)(a2 + 8) & 0x100) != 0 )
  {
    sub_4087F0((int)a1, "Duplicate oFFs chunk");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else if ( a3 == 9 )
  {
    png_crc_read((struct png_struct_def *)a1, v7, 9u);
    if ( !png_crc_finish((struct png_struct_def *)a1, 0) )
    {
      v6 = v9;
      v5 = png_get_uint_32((unsigned __int8 *)&v8);
      v4 = png_get_uint_32(v7);
      sub_411810((int)a1, a2, v4, v5, v6);
    }
  }
  else
  {
    sub_4087F0((int)a1, "Incorrect oFFs chunk length");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
}

//----- (0040B780) --------------------------------------------------------
void __cdecl sub_40B780(int *a1, int a2, unsigned int a3)
{
  int v4; // eax
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // ebx
  unsigned __int8 *i; // esi
  int v8; // eax
  unsigned __int8 v9; // cl
  char v10; // al
  unsigned __int8 *v11; // esi
  void *v12; // ebp
  int v13; // eax
  char v14; // [esp+9h] [ebp-11h]
  unsigned __int8 *v15; // [esp+Ah] [ebp-10h]
  unsigned __int8 *v16; // [esp+Eh] [ebp-Ch]
  int v17; // [esp+12h] [ebp-8h]
  int v18; // [esp+16h] [ebp-4h]
  unsigned __int8 v19; // [esp+1Eh] [ebp+4h]
  int v20; // [esp+1Eh] [ebp+4h]

  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_408740(a1, "Missing IHDR before pCAL");
  if ( (v4 & 4) != 0 )
  {
    sub_4087F0((int)a1, "Invalid pCAL after IDAT");
    png_crc_finish((struct png_struct_def *)a1, a3);
    return;
  }
  if ( a2 && (*(_DWORD *)(a2 + 8) & 0x400) != 0 )
  {
    sub_4087F0((int)a1, "Duplicate pCAL chunk");
    png_crc_finish((struct png_struct_def *)a1, a3);
    return;
  }
  v5 = (unsigned __int8 *)sub_408C20((int)a1, a3 + 1);
  v6 = v5;
  if ( !v5 )
  {
    sub_4087F0((int)a1, "No memory for pCAL purpose.");
    return;
  }
  png_crc_read((struct png_struct_def *)a1, v5, a3);
  if ( png_crc_finish((struct png_struct_def *)a1, 0) )
  {
    sub_408BF0((int)a1, v6);
    return;
  }
  v6[a3] = 0;
  v15 = &v6[a3];
  for ( i = v6; *i; ++i )
    ;
  if ( &v6[a3] <= i + 12 )
  {
    sub_4087F0((int)a1, "Invalid pCAL data");
LABEL_28:
    sub_408BF0((int)a1, v6);
    return;
  }
  v18 = png_get_uint_32(i + 1);
  v8 = png_get_uint_32(i + 5);
  v9 = i[10];
  v17 = v8;
  v10 = i[9];
  v11 = i + 11;
  v14 = v10;
  v19 = v9;
  v16 = v11;
  switch ( v10 )
  {
    case 0:
      if ( v9 == 2 )
        break;
LABEL_27:
      sub_4087F0((int)a1, "Invalid pCAL parameters for equation type");
      goto LABEL_28;
    case 1:
      if ( v9 != 3 )
        goto LABEL_27;
      break;
    case 2:
      if ( v9 != 3 )
        goto LABEL_27;
      break;
    case 3:
      if ( v9 == 4 )
        break;
      goto LABEL_27;
    default:
      sub_4087F0((int)a1, "Unrecognized equation type for pCAL chunk");
      v9 = v19;
      break;
  }
  while ( *v11 )
    ++v11;
  v20 = v9;
  v12 = sub_408C20((int)a1, 4 * v9);
  if ( v12 )
  {
    v13 = 0;
    if ( v20 <= 0 )
    {
LABEL_40:
      sub_411840((int)a1, a2, v6, v18, v17, v14, v20, v16, (int)v12);
      sub_408BF0((int)a1, v6);
      sub_408BF0((int)a1, v12);
    }
    else
    {
      while ( 1 )
      {
        *((_DWORD *)v12 + v13) = ++v11;
        if ( *v11 )
          break;
LABEL_38:
        if ( v11 > v15 )
          goto LABEL_41;
        if ( ++v13 >= v20 )
          goto LABEL_40;
      }
      while ( v11 <= v15 )
      {
        if ( !*++v11 )
          goto LABEL_38;
      }
LABEL_41:
      sub_4087F0((int)a1, "Invalid pCAL data");
      sub_408BF0((int)a1, v6);
      sub_408BF0((int)a1, v12);
    }
  }
  else
  {
    sub_408BF0((int)a1, v6);
    sub_4087F0((int)a1, "No memory for pCAL params.");
  }
}
// 40B8E5: conditional instruction was optimized away because of 'al.1>=4u'

//----- (0040B9E0) --------------------------------------------------------
void __cdecl sub_40B9E0(char *EndPtr, int a2, int a3)
{
  char *v3; // edi
  int v4; // eax
  int v5; // ebx
  char *v6; // esi
  const char *v7; // ebp
  _BYTE *i; // ebx
  const char *v9; // ebx
  double v10; // st7
  double v11; // [esp+28h] [ebp-8h]

  v3 = EndPtr;
  v4 = *((_DWORD *)EndPtr + 26);
  if ( (v4 & 1) == 0 )
    sub_408740((int *)EndPtr, "Missing IHDR before sCAL");
  if ( (v4 & 4) != 0 )
  {
    sub_4087F0((int)EndPtr, "Invalid sCAL after IDAT");
    png_crc_finish((struct png_struct_def *)v3, a3);
  }
  else if ( a2 && (*(_DWORD *)(a2 + 8) & 0x4000) != 0 )
  {
    sub_4087F0((int)EndPtr, "Duplicate sCAL chunk");
    png_crc_finish((struct png_struct_def *)v3, a3);
  }
  else
  {
    v5 = a3;
    v6 = (char *)sub_408C20((int)EndPtr, a3 + 1);
    if ( v6 )
    {
      png_crc_read((struct png_struct_def *)v3, (unsigned __int8 *)v6, v5);
      if ( png_crc_finish((struct png_struct_def *)v3, 0) )
      {
        sub_408BF0((int)v3, v6);
      }
      else
      {
        v7 = &v6[v5];
        v6[v5] = 0;
        v11 = strtod(v6 + 1, &EndPtr);
        if ( *EndPtr )
        {
          sub_4087F0((int)v3, "malformed width string in sCAL chunk");
        }
        else
        {
          for ( i = v6; *i; ++i )
            ;
          v9 = i + 1;
          v10 = strtod(v9, &EndPtr);
          if ( *EndPtr )
          {
            sub_4087F0((int)v3, "malformed height string in sCAL chunk");
          }
          else if ( v7 < v9 || v11 <= 0.0 || v10 <= 0.0 )
          {
            sub_4087F0((int)v3, "Invalid sCAL data");
            sub_408BF0((int)v3, v6);
          }
          else
          {
            sub_4119E0((int)v3, a2, *v6, v11, v10);
            sub_408BF0((int)v3, v6);
          }
        }
      }
    }
    else
    {
      sub_4087F0((int)v3, "Out of memory while processing sCAL chunk");
    }
  }
}

//----- (0040BBA0) --------------------------------------------------------
void __cdecl sub_40BBA0(int a1, _DWORD *a2, unsigned int a3)
{
  int v3; // eax
  __int16 v4; // [esp+8h] [ebp-14h] BYREF
  char v5; // [esp+Ah] [ebp-12h]
  __int16 v6; // [esp+Bh] [ebp-11h]
  char v7; // [esp+Dh] [ebp-Fh]
  char v8; // [esp+Eh] [ebp-Eh]
  char v9[8]; // [esp+10h] [ebp-Ch] BYREF

  if ( (*(_BYTE *)(a1 + 104) & 1) == 0 )
    sub_408740((int *)a1, "Out of place tIME chunk");
  if ( a2 && (a2[2] & 0x200) != 0 )
  {
    sub_4087F0(a1, "Duplicate tIME chunk");
    png_crc_finish((struct png_struct_def *)a1, a3);
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 104);
    if ( (v3 & 4) != 0 )
      *(_DWORD *)(a1 + 104) = v3 | 8;
    if ( a3 == 7 )
    {
      png_crc_read((struct png_struct_def *)a1, (unsigned __int8 *)v9, 7u);
      if ( !png_crc_finish((struct png_struct_def *)a1, 0) )
      {
        v7 = v9[5];
        v8 = v9[6];
        v6 = *(_WORD *)&v9[3];
        v5 = v9[2];
        v4 = sub_408C80((unsigned __int8 *)v9);
        sub_411F00(a1, a2, &v4);
      }
    }
    else
    {
      sub_4087F0(a1, "Incorrect tIME chunk length");
      png_crc_finish((struct png_struct_def *)a1, a3);
    }
  }
}

//----- (0040BCC0) --------------------------------------------------------
void __cdecl sub_40BCC0(int a1, _DWORD *a2, unsigned int a3)
{
  int v3; // eax
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ebx
  const char *v6; // ebp
  _DWORD *v7; // esi
  int v8; // ebp

  if ( (*(_BYTE *)(a1 + 104) & 1) == 0 )
    sub_408740((int *)a1, "Missing IHDR before tEXt");
  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 4) != 0 )
    *(_DWORD *)(a1 + 104) = v3 | 8;
  v4 = (unsigned __int8 *)sub_408C20(a1, a3 + 1);
  v5 = v4;
  if ( v4 )
  {
    png_crc_read((struct png_struct_def *)a1, v4, a3);
    if ( png_crc_finish((struct png_struct_def *)a1, 0) )
    {
      sub_408BF0(a1, v5);
    }
    else
    {
      v5[a3] = 0;
      v6 = (const char *)v5;
      if ( *v5 )
      {
        do
          ++v6;
        while ( *v6 );
      }
      if ( v6 != (const char *)&v5[a3] )
        ++v6;
      v7 = sub_408C20(a1, 0x10u);
      if ( v7 )
      {
        *v7 = -1;
        v7[1] = v5;
        v7[2] = v6;
        v7[3] = strlen(v6);
        v8 = sub_411D10(a1, a2, (int)v7, 1);
        sub_408BF0(a1, v5);
        sub_408BF0(a1, v7);
        if ( v8 )
          sub_4087F0(a1, "Insufficient memory to process text chunk.");
      }
      else
      {
        sub_4087F0(a1, "Not enough memory to process text chunk.");
        sub_408BF0(a1, v5);
      }
    }
  }
  else
  {
    sub_4087F0(a1, "No memory to process text chunk.");
  }
}

//----- (0040BDE0) --------------------------------------------------------
void __cdecl sub_40BDE0(int a1, _DWORD *a2, int a3)
{
  int v4; // eax
  unsigned int v5; // esi
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // eax
  unsigned __int8 *i; // esi
  int v10; // ebp
  _BYTE *v11; // esi
  char *v12; // ebx
  _DWORD *v13; // eax
  void *v14; // esi
  int v15; // ecx
  int v16; // ebp
  int v17; // [esp+10h] [ebp+4h]

  if ( (*(_BYTE *)(a1 + 104) & 1) == 0 )
    sub_408740((int *)a1, "Missing IHDR before zTXt");
  v4 = *(_DWORD *)(a1 + 104);
  if ( (v4 & 4) != 0 )
    *(_DWORD *)(a1 + 104) = v4 | 8;
  v5 = a3;
  v6 = (unsigned __int8 *)sub_408C20(a1, a3 + 1);
  v7 = v6;
  if ( v6 )
  {
    png_crc_read((struct png_struct_def *)a1, v6, v5);
    if ( png_crc_finish((struct png_struct_def *)a1, 0) )
    {
      sub_408BF0(a1, v7);
    }
    else
    {
      v8 = &v7[v5];
      v7[v5] = 0;
      for ( i = v7; *i; ++i )
        ;
      if ( i == v8 )
      {
        v10 = -1;
        sub_4087F0(a1, "Zero length zTXt chunk");
      }
      else
      {
        v10 = (char)i[1];
        v11 = i + 1;
        if ( v10 )
        {
          sub_4087F0(a1, "Unknown compression type in zTXt chunk");
          v10 = 0;
        }
        i = v11 + 1;
      }
      v17 = i - v7;
      v12 = sub_408D40(a1, v10, (char *)v7, a3, i - v7, (size_t *)&a3);
      v13 = sub_408C20(a1, 0x10u);
      v14 = v13;
      if ( v13 )
      {
        v15 = a3;
        *v13 = v10;
        v13[1] = v12;
        v13[2] = &v12[v17];
        v13[3] = v15;
        v16 = sub_411D10(a1, a2, (int)v13, 1);
        sub_408BF0(a1, v14);
        sub_408BF0(a1, v12);
        if ( v16 )
          sub_408740((int *)a1, "Insufficient memory to store zTXt chunk.");
      }
      else
      {
        sub_4087F0(a1, "Not enough memory to process zTXt chunk.");
        sub_408BF0(a1, v12);
      }
    }
  }
  else
  {
    sub_4087F0(a1, "Out of memory processing zTXt chunk.");
  }
}

//----- (0040BF40) --------------------------------------------------------
int __cdecl sub_40BF40(int a1, int a2, size_t Size)
{
  int v3; // ebx
  _BYTE *v4; // esi
  char *v5; // eax
  char v6; // cl
  int (__cdecl *v7)(int, char *); // eax
  unsigned int v8; // eax
  char v10[8]; // [esp+14h] [ebp-18h] BYREF
  void *Block; // [esp+1Ch] [ebp-10h]
  size_t v12; // [esp+20h] [ebp-Ch]

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 4) != 0 && memcmp((const void *)(a1 + 284), "IDAT", 4u) )
    *(_DWORD *)(a1 + 104) = v3 | 8;
  v4 = (_BYTE *)(a1 + 284);
  sub_4090D0((int *)a1, (unsigned __int8 *)(a1 + 284));
  if ( (*(_BYTE *)(a1 + 284) & 0x20) == 0 && sub_4082A0(a1, (const void *)(a1 + 284)) != 3 && !*(_DWORD *)(a1 + 540) )
    sub_408850((int *)a1, "unknown critical chunk");
  if ( (*(_DWORD *)(a1 + 108) & 0x8000) == 0 )
  {
    v8 = Size;
    return png_crc_finish((struct png_struct_def *)a1, v8);
  }
  v5 = (char *)(a1 + 284);
  do
  {
    v6 = *v5;
    v5[v10 - v4] = *v5;
    ++v5;
  }
  while ( v6 );
  Block = sub_408BA0(a1, Size);
  v12 = Size;
  png_crc_read((struct png_struct_def *)a1, (unsigned __int8 *)Block, Size);
  v7 = *(int (__cdecl **)(int, char *))(a1 + 540);
  if ( !v7 )
    goto LABEL_16;
  if ( v7(a1, v10) <= 0 )
  {
    if ( (*v4 & 0x20) == 0 && sub_4082A0(a1, (const void *)(a1 + 284)) != 3 )
    {
      sub_408BF0(a1, Block);
      sub_408850((int *)a1, "unknown critical chunk");
    }
LABEL_16:
    sub_412100(a1, a2, (int)v10, 1);
  }
  sub_408BF0(a1, Block);
  v8 = 0;
  return png_crc_finish((struct png_struct_def *)a1, v8);
}

//----- (0040C120) --------------------------------------------------------
unsigned int __cdecl sub_40C120(int a1)
{
  int v1; // esi
  unsigned int result; // eax
  unsigned __int8 v3; // bl
  unsigned __int8 v4; // cl
  unsigned int v5; // ecx
  bool v6; // zf
  int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned __int8 *v10; // edx
  int v11; // eax
  char *v12; // eax
  void *v13; // [esp-14h] [ebp-20h]
  size_t v14; // [esp-Ch] [ebp-18h]
  unsigned __int8 v15[4]; // [esp+8h] [ebp-4h] BYREF

  v1 = a1;
  ++*(_DWORD *)(a1 + 228);
  result = *(_DWORD *)(v1 + 228);
  if ( result >= *(_DWORD *)(v1 + 208) )
  {
    if ( *(_BYTE *)(v1 + 291) )
    {
      v14 = *(_DWORD *)(v1 + 216) + 1;
      v13 = *(void **)(v1 + 232);
      *(_DWORD *)(v1 + 228) = 0;
      sub_408B10(v1, v13, 0, v14);
      while ( 1 )
      {
        v3 = ++*(_BYTE *)(v1 + 292);
        if ( v3 >= 7u )
          break;
        result = (*(_DWORD *)(v1 + 200) - dword_4164B4[v3] + dword_4164D0[v3] - 1) / (unsigned int)dword_4164D0[v3];
        v4 = *(_BYTE *)(v1 + 297);
        *(_DWORD *)(v1 + 224) = result;
        if ( v4 < 8u )
          v5 = (result * v4 + 7) >> 3;
        else
          v5 = result * (v4 >> 3);
        v6 = (*(_BYTE *)(v1 + 112) & 2) == 0;
        *(_DWORD *)(v1 + 220) = v5 + 1;
        if ( v6 )
        {
          result = (*(_DWORD *)(v1 + 204) - dword_4164EC[v3] + dword_416508[v3] - 1) / (unsigned int)dword_416508[v3];
          v6 = *(_DWORD *)(v1 + 224) == 0;
          *(_DWORD *)(v1 + 208) = result;
          if ( v6 )
            continue;
        }
        return result;
      }
    }
    if ( (*(_BYTE *)(v1 + 108) & 0x20) == 0 )
    {
      *(_DWORD *)(v1 + 128) = &a1;
      *(_DWORD *)(v1 + 132) = 1;
      v7 = v1 + 116;
      while ( 1 )
      {
        if ( !*(_DWORD *)(v1 + 120) )
        {
          while ( !*(_DWORD *)(v1 + 268) )
          {
            png_crc_finish((struct png_struct_def *)v1, 0);
            sub_4088C0((int *)v1);
            *(_DWORD *)(v1 + 268) = sub_409D20((int *)v1, v15);
            sub_407DD0(v1);
            png_crc_read((struct png_struct_def *)v1, (unsigned __int8 *)(v1 + 284), 4u);
            if ( memcmp((const void *)(v1 + 284), "IDAT", 4u) )
              sub_408740((int *)v1, "Not enough image data");
          }
          v8 = *(_DWORD *)(v1 + 176);
          v9 = *(_DWORD *)(v1 + 268);
          v10 = *(unsigned __int8 **)(v1 + 172);
          v7 = v1 + 116;
          *(_DWORD *)(v1 + 120) = v8;
          *(_DWORD *)(v1 + 116) = v10;
          if ( v8 > v9 )
            *(_DWORD *)(v1 + 120) = v9;
          png_crc_read((struct png_struct_def *)v1, v10, *(_DWORD *)(v1 + 120));
          *(_DWORD *)(v1 + 268) -= *(_DWORD *)(v1 + 120);
        }
        v11 = inflate(v7, 1);
        if ( v11 == 1 )
          break;
        if ( v11 )
        {
          v12 = *(char **)(v1 + 140);
          if ( !v12 )
            v12 = "Decompression Error";
          sub_408740((int *)v1, v12);
        }
        if ( !*(_DWORD *)(v1 + 132) )
        {
          sub_4087F0(v1, "Extra compressed data.");
          goto LABEL_28;
        }
      }
      if ( !*(_DWORD *)(v1 + 132) || *(_DWORD *)(v1 + 120) || *(_DWORD *)(v1 + 268) )
        sub_4087F0(v1, "Extra compressed data");
LABEL_28:
      *(_DWORD *)(v1 + 104) |= 8u;
      *(_DWORD *)(v1 + 108) |= 0x20u;
      *(_DWORD *)(v1 + 132) = 0;
    }
    if ( *(_DWORD *)(v1 + 268) || *(_DWORD *)(v1 + 120) )
      sub_4087F0(v1, "Extra compression data");
    result = inflateReset((_DWORD *)(v1 + 116));
    *(_DWORD *)(v1 + 104) |= 8u;
  }
  return result;
}
// 40C21C: conditional instruction was optimized away because of 'bl.1<7u'

//----- (0040C430) --------------------------------------------------------
char __cdecl sub_40C430(int *a1, int a2)
{
  int *v2; // edx
  int v3; // eax
  int v4; // eax
  int v5; // edi
  int v6; // eax
  _BYTE *v7; // esi
  _BYTE *v8; // ebp
  int v9; // eax
  _BYTE *v10; // esi
  _BYTE *v11; // ebp
  int v12; // eax
  int v13; // edx
  _BYTE *v14; // esi
  _BYTE *v15; // ebp
  int v16; // eax
  int v17; // edx
  char v18; // cl
  int v20; // [esp+4h] [ebp+4h]

  v2 = a1;
  LOBYTE(v3) = *((_BYTE *)a1 + 9);
  if ( (unsigned __int8)v3 < 8u )
  {
    v4 = (unsigned __int8)v3 - 1;
    v5 = *a1;
    if ( v4 )
    {
      v6 = v4 - 1;
      if ( v6 )
      {
        if ( v6 == 2 )
        {
          v7 = (_BYTE *)(a2 + ((unsigned int)(v5 - 1) >> 1));
          v8 = (_BYTE *)(v5 + a2 - 1);
          v9 = 4 * (1 - ((v5 - 1) & 1));
          if ( v5 )
          {
            v20 = *a1;
            do
            {
              *v8 = (*v7 >> v9) & 0xF;
              if ( v9 == 4 )
              {
                v9 = 0;
                --v7;
              }
              else
              {
                v9 = 4;
              }
              --v8;
              --v20;
            }
            while ( v20 );
          }
        }
        goto LABEL_26;
      }
      v10 = (_BYTE *)(a2 + ((unsigned int)(v5 - 1) >> 2));
      v11 = (_BYTE *)(v5 + a2 - 1);
      v12 = 2 * (3 - ((v5 - 1) & 3));
      if ( v5 )
      {
        v13 = *a1;
        do
        {
          *v11 = (*v10 >> v12) & 3;
          if ( v12 == 6 )
          {
            v12 = 0;
            --v10;
          }
          else
          {
            v12 += 2;
          }
          --v11;
          --v13;
        }
        while ( v13 );
LABEL_25:
        v2 = a1;
        goto LABEL_26;
      }
    }
    else
    {
      v14 = (_BYTE *)(a2 + ((unsigned int)(v5 - 1) >> 3));
      v15 = (_BYTE *)(v5 + a2 - 1);
      v16 = 7 - ((v5 - 1) & 7);
      if ( v5 )
      {
        v17 = *a1;
        do
        {
          *v15 = (*v14 >> v16) & 1;
          if ( v16 == 7 )
          {
            v16 = 0;
            --v14;
          }
          else
          {
            ++v16;
          }
          --v15;
          --v17;
        }
        while ( v17 );
        goto LABEL_25;
      }
    }
LABEL_26:
    v18 = 8 * *((_BYTE *)v2 + 10);
    v3 = v5 * *((unsigned __int8 *)v2 + 10);
    *((_BYTE *)v2 + 9) = 8;
    *((_BYTE *)v2 + 11) = v18;
    v2[1] = v3;
  }
  return v3;
}

//----- (0040C570) --------------------------------------------------------
void __cdecl sub_40C570(int *a1, _BYTE *a2, unsigned __int8 *a3)
{
  char v3; // bl
  int v4; // ebp
  __int16 v5; // si
  int v6; // eax
  int v7; // esi
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // edx
  _BYTE *i; // eax
  int v14; // edi
  char v15; // dl
  _BYTE *v16; // esi
  char j; // al
  char v18; // bl
  _BYTE *v19; // esi
  unsigned int v20; // ebp
  unsigned int k; // ebx
  int v22; // edx
  unsigned __int8 *v23; // esi
  unsigned int v24; // ebp
  unsigned int l; // ebx
  int v26; // edx
  unsigned __int16 v27; // ax
  __int16 v28; // ax
  int v29[4]; // [esp+4h] [ebp-10h]

  v3 = *((_BYTE *)a1 + 8);
  if ( v3 != 3 )
  {
    v4 = *a1;
    v5 = 0;
    if ( (v3 & 2) != 0 )
    {
      v6 = *((unsigned __int8 *)a1 + 9);
      v7 = a3[1];
      v29[0] = v6 - *a3;
      v8 = v6 - v7;
      v9 = v6 - a3[2];
      v5 = 0;
      v29[1] = v8;
      v29[2] = v9;
      v10 = 3;
    }
    else
    {
      v29[0] = *((unsigned __int8 *)a1 + 9) - a3[3];
      v10 = 1;
    }
    if ( (v3 & 4) != 0 )
      v29[v10++] = *((unsigned __int8 *)a1 + 9) - a3[4];
    v11 = 0;
    if ( v10 > 0 )
    {
      do
      {
        if ( v29[v11] > 0 )
          v5 = 1;
        else
          v29[v11] = 0;
        ++v11;
      }
      while ( v11 < v10 );
      if ( v5 )
      {
        switch ( *((_BYTE *)a1 + 9) )
        {
          case 2:
            v12 = a1[1];
            for ( i = a2; v12; --v12 )
            {
              *i = (*i >> 1) & 0x55;
              ++i;
            }
            break;
          case 4:
            v14 = a1[1];
            v15 = v29[0];
            v16 = a2;
            for ( j = (15 >> SLOBYTE(v29[0])) | (240 >> SLOBYTE(v29[0])) & 0xF0; v14; *(v16 - 1) = j & v18 )
            {
              v18 = *v16++ >> v15;
              --v14;
            }
            break;
          case 8:
            v19 = a2;
            v20 = v10 * v4;
            for ( k = 0; k < v20; *(v19 - 1) >>= LOBYTE(v29[v22]) )
            {
              v22 = k % v10;
              ++k;
              ++v19;
            }
            break;
          case 0x10:
            v23 = a2;
            v24 = v10 * v4;
            for ( l = 0; l < v24; *(v23 - 1) = v28 )
            {
              v26 = l % v10;
              v27 = v23[1] + (*v23 << 8);
              ++l;
              v23 += 2;
              v28 = v27 >> LOWORD(v29[v26]);
              *(v23 - 2) = HIBYTE(v28);
            }
            break;
          default:
            return;
        }
      }
    }
  }
}

//----- (0040C750) --------------------------------------------------------
void __cdecl sub_40C750(int a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ecx
  int v4; // edi
  char v5; // cl
  int v6; // edx

  if ( *(_BYTE *)(a1 + 9) == 16 )
  {
    v2 = a2;
    v3 = a2;
    if ( *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
    {
      v4 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
      do
      {
        *v3 = *v2;
        v2 += 2;
        ++v3;
        --v4;
      }
      while ( v4 );
    }
    v5 = 8 * *(_BYTE *)(a1 + 10);
    v6 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
    *(_BYTE *)(a1 + 9) = 8;
    *(_BYTE *)(a1 + 11) = v5;
    *(_DWORD *)(a1 + 4) = v6;
  }
}

//----- (0040C7A0) --------------------------------------------------------
_BYTE *__cdecl sub_40C7A0(int *a1, int a2)
{
  _BYTE *result; // eax
  char v3; // cl
  int v4; // edx
  int v5; // eax
  _BYTE *v6; // ecx
  int v7; // esi
  char v8; // dl
  _BYTE *v9; // eax
  char v10; // bl
  char v11; // bl
  _BYTE *v12; // ecx
  char v13; // bl
  _BYTE *v14; // ecx
  int v15; // esi
  char v16; // dl
  _BYTE *v17; // eax
  char v18; // bl
  _BYTE *v19; // ecx
  char v20; // bl
  char v21; // bl
  char v22; // bl
  int v23; // eax
  _BYTE *v24; // ecx
  int v25; // esi
  char v26; // dl
  _BYTE *v27; // eax
  char v28; // bl
  _BYTE *v29; // ecx
  _BYTE *v30; // ecx
  int v31; // esi
  char v32; // dl
  _BYTE *v33; // eax
  char v34; // bl
  _BYTE *v35; // ecx
  char v36; // bl
  char v37; // [esp+Dh] [ebp+5h]
  char v38; // [esp+Dh] [ebp+5h]

  result = a1;
  v3 = *((_BYTE *)a1 + 8);
  v4 = *a1;
  if ( v3 == 6 )
  {
    v5 = a1[1];
    if ( *((_BYTE *)a1 + 9) == 8 )
    {
      result = (_BYTE *)(a2 + v5);
      v6 = result;
      if ( v4 )
      {
        v7 = *a1;
        do
        {
          v8 = *(result - 1);
          v9 = result - 1;
          v10 = *--v9;
          *(v6 - 1) = v10;
          v11 = *--v9;
          v12 = v6 - 2;
          *v12 = v11;
          v13 = *(v9 - 1);
          result = v9 - 1;
          *--v12 = v13;
          v6 = v12 - 1;
          --v7;
          *v6 = v8;
        }
        while ( v7 );
      }
    }
    else
    {
      result = (_BYTE *)(a2 + v5);
      v14 = result;
      if ( v4 )
      {
        v15 = *a1;
        do
        {
          v16 = *(result - 1);
          v17 = result - 1;
          v18 = *(v17 - 1);
          v17 -= 2;
          v37 = v18;
          *(v14 - 1) = *v17;
          v19 = v14 - 1;
          *(v19 - 1) = *--v17;
          *(--v19 - 1) = *(v17 - 1);
          v20 = *(--v17 - 1);
          --v19;
          --v17;
          *(v19 - 1) = v20;
          v21 = *--v17;
          v19 -= 2;
          *v19 = v21;
          v22 = *(v17 - 1);
          result = v17 - 1;
          *--v19 = v22;
          *--v19 = v16;
          v14 = v19 - 1;
          --v15;
          *v14 = v37;
        }
        while ( v15 );
      }
    }
  }
  else if ( v3 == 4 )
  {
    v23 = a1[1];
    if ( *((_BYTE *)a1 + 9) == 8 )
    {
      result = (_BYTE *)(a2 + v23);
      v24 = result;
      if ( v4 )
      {
        v25 = *a1;
        do
        {
          v26 = *(result - 1);
          v27 = result - 1;
          v28 = *(v27 - 1);
          result = v27 - 1;
          v29 = v24 - 1;
          *v29 = v28;
          v24 = v29 - 1;
          --v25;
          *v24 = v26;
        }
        while ( v25 );
      }
    }
    else
    {
      result = (_BYTE *)(a2 + v23);
      v30 = result;
      if ( v4 )
      {
        v31 = *a1;
        do
        {
          v32 = *(result - 1);
          v33 = result - 1;
          v34 = *(v33 - 1);
          v33 -= 2;
          v38 = v34;
          v35 = v30 - 1;
          *v35 = *v33;
          v36 = *(v33 - 1);
          result = v33 - 1;
          *--v35 = v36;
          *--v35 = v32;
          v30 = v35 - 1;
          --v31;
          *v30 = v38;
        }
        while ( v31 );
      }
    }
  }
  return result;
}

//----- (0040C920) --------------------------------------------------------
_BYTE *__cdecl sub_40C920(int *a1, int a2)
{
  _BYTE *result; // eax
  char v3; // cl
  int v4; // edx
  int v5; // eax
  _BYTE *v6; // eax
  char v7; // cl
  int v8; // esi
  _BYTE *v9; // ecx
  _BYTE *v10; // eax
  char v11; // dl
  int v12; // eax
  _BYTE *v13; // ecx
  int v14; // esi
  _BYTE *v15; // eax
  _BYTE *v16; // ecx
  char v17; // dl
  int v18; // esi
  _BYTE *v19; // ecx
  _BYTE *v20; // eax
  char v21; // dl

  result = a1;
  v3 = *((_BYTE *)a1 + 8);
  v4 = *a1;
  if ( v3 == 6 )
  {
    v5 = a1[1];
    if ( *((_BYTE *)a1 + 9) == 8 )
    {
      for ( result = (_BYTE *)(a2 + v5); v4; result[3] = v7 )
      {
        v6 = result - 1;
        v7 = -1 - *v6;
        result = v6 - 3;
        --v4;
      }
    }
    else
    {
      result = (_BYTE *)(a2 + v5);
      if ( v4 )
      {
        v8 = *a1;
        do
        {
          v9 = result - 1;
          *v9 = -1 - *v9;
          v10 = result - 2;
          v11 = -1 - *v10;
          result = v10 - 6;
          --v8;
          *(v9 - 1) = v11;
        }
        while ( v8 );
      }
    }
  }
  else if ( v3 == 4 )
  {
    v12 = a1[1];
    if ( *((_BYTE *)a1 + 9) == 8 )
    {
      result = (_BYTE *)(a2 + v12);
      v13 = result;
      if ( v4 )
      {
        v14 = *a1;
        do
        {
          v15 = result - 1;
          v16 = v13 - 1;
          *v16 = -1 - *v15;
          v17 = *(v15 - 1);
          result = v15 - 1;
          v13 = v16 - 1;
          --v14;
          *v13 = v17;
        }
        while ( v14 );
      }
    }
    else
    {
      result = (_BYTE *)(a2 + v12);
      if ( v4 )
      {
        v18 = *a1;
        do
        {
          v19 = result - 1;
          *v19 = -1 - *v19;
          v20 = result - 2;
          v21 = -1 - *v20;
          result = v20 - 2;
          --v18;
          *(v19 - 1) = v21;
        }
        while ( v18 );
      }
    }
  }
  return result;
}

//----- (0040CA00) --------------------------------------------------------
char __cdecl sub_40CA00(int a1, int a2, unsigned int a3, char a4)
{
  _BYTE *v5; // eax
  unsigned int v6; // esi
  unsigned int v7; // ebx
  int v8; // edi
  unsigned int v9; // ecx
  _BYTE *v10; // eax
  char v11; // bl
  unsigned int v12; // ecx
  char v13; // bl
  _BYTE *v14; // eax
  int v15; // edi
  _BYTE *v16; // eax
  char v17; // cl
  int v18; // edi
  char v19; // cl
  bool v20; // zf
  char v21; // cl
  int v22; // edi
  _BYTE *v23; // eax
  char v24; // cl
  unsigned int v25; // edi
  unsigned int v26; // ecx
  char v27; // bl
  unsigned int v28; // edi
  _BYTE *v29; // eax
  char v30; // bl
  char v31; // bl
  unsigned int v32; // ecx
  char v33; // bl
  unsigned int v34; // edi
  char v35; // bl
  _BYTE *v36; // eax
  char v37; // bl
  int v38; // ecx
  unsigned int v39; // edi
  _BYTE *v40; // eax
  int v41; // ecx
  char v42; // bl
  char v43; // bl
  char v44; // bl
  char v45; // bl
  unsigned int v46; // edi
  int v47; // ecx
  _BYTE *v48; // eax
  char v49; // bl
  char v50; // bl
  unsigned int v52; // [esp+14h] [ebp+4h]
  unsigned int v53; // [esp+14h] [ebp+4h]

  LOBYTE(v5) = *(_BYTE *)(a1 + 8);
  v6 = *(_DWORD *)a1;
  v7 = a3 >> 8;
  if ( (_BYTE)v5 )
  {
    if ( (_BYTE)v5 == 2 )
    {
      LOBYTE(v5) = *(_BYTE *)(a1 + 9);
      if ( (_BYTE)v5 == 8 )
      {
        v25 = v6 + a2 + 2 * v6;
        v5 = (_BYTE *)(v25 + v6);
        if ( a4 >= 0 )
        {
          if ( v6 )
          {
            v32 = *(_DWORD *)a1;
            do
            {
              v33 = *(_BYTE *)(v25 - 1);
              v34 = v25 - 1;
              *(v5 - 1) = v33;
              v35 = *(_BYTE *)--v34;
              v36 = v5 - 2;
              *v36 = v35;
              v37 = *(_BYTE *)(v34 - 1);
              v25 = v34 - 1;
              *--v36 = v37;
              v5 = v36 - 1;
              --v32;
              *v5 = a3;
            }
            while ( v32 );
          }
        }
        else
        {
          if ( v6 > 1 )
          {
            v26 = v6 - 1;
            do
            {
              *(v5 - 1) = a3;
              v27 = *(_BYTE *)(v25 - 1);
              v28 = v25 - 1;
              v29 = v5 - 2;
              *v29 = v27;
              v30 = *(_BYTE *)--v28;
              *--v29 = v30;
              v31 = *(_BYTE *)(v28 - 1);
              v25 = v28 - 1;
              v5 = v29 - 1;
              --v26;
              *v5 = v31;
            }
            while ( v26 );
          }
          *(v5 - 1) = a3;
        }
        *(_BYTE *)(a1 + 10) = 4;
        *(_BYTE *)(a1 + 11) = 32;
        *(_DWORD *)(a1 + 4) = 4 * v6;
      }
      else if ( (_BYTE)v5 == 16 )
      {
        v38 = a2 + 6 * v6;
        v5 = (_BYTE *)(v38 + 2 * v6);
        if ( a4 >= 0 )
        {
          if ( v6 )
          {
            v46 = *(_DWORD *)a1;
            do
            {
              *(v5 - 1) = *(_BYTE *)(v38 - 1);
              v47 = v38 - 1;
              v48 = v5 - 1;
              *(v48 - 1) = *(_BYTE *)--v47;
              *(--v48 - 1) = *(_BYTE *)--v47;
              *(--v48 - 1) = *(_BYTE *)(v47 - 1);
              v49 = *(_BYTE *)(--v47 - 1);
              --v48;
              --v47;
              *(v48 - 1) = v49;
              v50 = *(_BYTE *)(v47 - 1);
              v38 = v47 - 1;
              v48 -= 2;
              *v48-- = v50;
              *v48 = BYTE1(a3);
              v5 = v48 - 1;
              --v46;
              *v5 = a3;
            }
            while ( v46 );
          }
        }
        else
        {
          if ( v6 > 1 )
          {
            v39 = v6 - 1;
            do
            {
              *(v5 - 1) = v7;
              v40 = v5 - 1;
              *--v40 = a3;
              *(v40 - 1) = *(_BYTE *)(v38 - 1);
              v41 = v38 - 1;
              *(--v40 - 1) = *(_BYTE *)(v41 - 1);
              v42 = *(_BYTE *)(--v41 - 1);
              --v40;
              --v41;
              *(v40 - 1) = v42;
              v43 = *(_BYTE *)(v41 - 1);
              --v40;
              --v41;
              *(v40 - 1) = v43;
              v44 = *(_BYTE *)--v41;
              v40 -= 2;
              *v40 = v44;
              v45 = *(_BYTE *)(v41 - 1);
              v38 = v41 - 1;
              v5 = v40 - 1;
              --v39;
              *v5 = v45;
              LOBYTE(v7) = BYTE1(a3);
            }
            while ( v39 );
          }
          *--v5 = v7;
          *(v5 - 1) = a3;
        }
        *(_BYTE *)(a1 + 11) = 64;
        *(_BYTE *)(a1 + 10) = 4;
        *(_DWORD *)(a1 + 4) = 8 * v6;
      }
    }
  }
  else
  {
    LOBYTE(v5) = *(_BYTE *)(a1 + 9);
    if ( (_BYTE)v5 == 8 )
    {
      v8 = v6 + a2;
      v5 = (_BYTE *)(v6 + a2 + v6);
      if ( a4 >= 0 )
      {
        if ( v6 )
        {
          v12 = *(_DWORD *)a1;
          do
          {
            v13 = *(_BYTE *)--v8;
            v14 = v5 - 1;
            *v14 = v13;
            v5 = v14 - 1;
            --v12;
            *v5 = a3;
          }
          while ( v12 );
        }
        *(_BYTE *)(a1 + 10) = 2;
        *(_BYTE *)(a1 + 11) = 16;
        *(_DWORD *)(a1 + 4) = 2 * v6;
      }
      else
      {
        if ( v6 > 1 )
        {
          v9 = v6 - 1;
          do
          {
            v10 = v5 - 1;
            *v10 = a3;
            v11 = *(_BYTE *)--v8;
            v5 = v10 - 1;
            --v9;
            *v5 = v11;
          }
          while ( v9 );
        }
        *(v5 - 1) = a3;
        *(_BYTE *)(a1 + 10) = 2;
        *(_BYTE *)(a1 + 11) = 16;
        *(_DWORD *)(a1 + 4) = 2 * v6;
      }
    }
    else if ( (_BYTE)v5 == 16 )
    {
      v15 = a2 + 2 * v6;
      v5 = (_BYTE *)(v15 + 2 * v6);
      if ( a4 >= 0 )
      {
        if ( v6 )
        {
          v53 = *(_DWORD *)a1;
          do
          {
            v21 = *(_BYTE *)(v15 - 1);
            v22 = v15 - 1;
            v23 = v5 - 1;
            *v23 = v21;
            v24 = *(_BYTE *)(v22 - 1);
            v15 = v22 - 1;
            *--v23 = v24;
            *--v23 = BYTE1(a3);
            v5 = v23 - 1;
            v20 = v53-- == 1;
            *v5 = a3;
          }
          while ( !v20 );
        }
        *(_BYTE *)(a1 + 10) = 2;
        *(_BYTE *)(a1 + 11) = 32;
        *(_DWORD *)(a1 + 4) = 4 * v6;
      }
      else
      {
        if ( v6 > 1 )
        {
          v52 = v6 - 1;
          do
          {
            *(v5 - 1) = BYTE1(a3);
            v16 = v5 - 2;
            *v16 = a3;
            v17 = *(_BYTE *)(v15 - 1);
            v18 = v15 - 1;
            *--v16 = v17;
            v19 = *(_BYTE *)(v18 - 1);
            v15 = v18 - 1;
            v5 = v16 - 1;
            v20 = v52-- == 1;
            *v5 = v19;
          }
          while ( !v20 );
        }
        *--v5 = BYTE1(a3);
        *(v5 - 1) = a3;
        *(_BYTE *)(a1 + 10) = 2;
        *(_BYTE *)(a1 + 11) = 32;
        *(_DWORD *)(a1 + 4) = 4 * v6;
      }
    }
  }
  return (char)v5;
}

//----- (0040CD20) --------------------------------------------------------
void __cdecl sub_40CD20(int *a1, int a2)
{
  unsigned __int8 v2; // cl
  int v3; // esi
  char v4; // al
  _BYTE *v5; // ecx
  _BYTE *v6; // eax
  int v7; // edi
  _BYTE *v8; // eax
  _BYTE *v9; // ecx
  _BYTE *v10; // eax
  int v11; // edi
  _BYTE *v12; // eax
  _BYTE *v13; // ecx
  _BYTE *v14; // eax
  int v15; // edi
  char v16; // bl
  _BYTE *v17; // ecx
  _BYTE *v18; // eax
  _BYTE *v19; // ecx
  _BYTE *v20; // eax
  int v21; // edi
  _BYTE *v22; // eax
  _BYTE *v23; // ecx
  char v24; // bl
  char v25; // al
  char v26; // cl
  unsigned __int8 v27; // al

  v2 = *((_BYTE *)a1 + 9);
  v3 = *a1;
  if ( v2 >= 8u )
  {
    v4 = *((_BYTE *)a1 + 8);
    if ( (v4 & 2) == 0 )
    {
      if ( v4 )
      {
        if ( v4 == 4 )
        {
          if ( v2 == 8 )
          {
            v13 = (_BYTE *)(a2 + 2 * v3 - 1);
            v14 = &v13[2 * v3];
            if ( v3 )
            {
              v15 = *a1;
              do
              {
                *v14 = *v13;
                v16 = *(v13 - 1);
                v17 = v13 - 1;
                v18 = v14 - 1;
                *v18-- = v16;
                *v18-- = *v17;
                *v18 = *v17;
                v14 = v18 - 1;
                v13 = v17 - 1;
                --v15;
              }
              while ( v15 );
            }
          }
          else
          {
            v19 = (_BYTE *)(a2 + 4 * v3 - 1);
            v20 = &v19[4 * v3];
            if ( v3 )
            {
              v21 = *a1;
              do
              {
                *v20 = *v19;
                *(v20 - 1) = *(v19 - 1);
                v22 = v20 - 1;
                v23 = v19 - 1;
                *(v22 - 1) = *(v23 - 1);
                v24 = *(v23 - 2);
                --v23;
                *(--v22 - 1) = v24;
                *(--v22 - 1) = *v23;
                v22 -= 2;
                *v22-- = *(v23 - 1);
                *v22-- = *v23;
                *v22 = *(v23 - 1);
                v20 = v22 - 1;
                v19 = v23 - 2;
                --v21;
              }
              while ( v21 );
            }
          }
        }
      }
      else if ( v2 == 8 )
      {
        v5 = (_BYTE *)(v3 + a2 - 1);
        v6 = &v5[2 * v3];
        if ( v3 )
        {
          v7 = *a1;
          do
          {
            *v6 = *v5;
            v8 = v6 - 1;
            *v8-- = *v5;
            *v8 = *v5;
            v6 = v8 - 1;
            --v5;
            --v7;
          }
          while ( v7 );
        }
      }
      else
      {
        v9 = (_BYTE *)(a2 + 2 * v3 - 1);
        v10 = &v9[4 * v3];
        if ( v3 )
        {
          v11 = *a1;
          do
          {
            *v10 = *v9;
            *(v10 - 1) = *(v9 - 1);
            v12 = v10 - 1;
            *(v12 - 1) = *v9;
            v12 -= 2;
            *v12-- = *(v9 - 1);
            *v12-- = *v9;
            *v12 = *(v9 - 1);
            v10 = v12 - 1;
            v9 -= 2;
            --v11;
          }
          while ( v11 );
        }
      }
      *((_BYTE *)a1 + 10) += 2;
      v25 = *((_BYTE *)a1 + 9);
      v26 = *((_BYTE *)a1 + 10);
      *((_BYTE *)a1 + 8) |= 2u;
      v27 = v26 * v25;
      *((_BYTE *)a1 + 11) = v27;
      if ( v27 < 8u )
        a1[1] = (v3 * (unsigned int)v27 + 7) >> 3;
      else
        a1[1] = v3 * (v27 >> 3);
    }
  }
}

//----- (0040CEE0) --------------------------------------------------------
int __cdecl sub_40CEE0(int a1, int *a2, unsigned __int8 *a3)
{
  int v3; // ecx
  char v4; // dl
  int result; // eax
  int v6; // ebx
  int v7; // edi
  unsigned __int8 *v8; // esi
  int v9; // ebp
  unsigned __int8 v10; // dl
  unsigned __int8 v11; // cl
  unsigned __int8 *v12; // esi
  unsigned __int8 *v13; // ebp
  bool v14; // zf
  unsigned __int8 *v15; // esi
  unsigned __int8 *v16; // ebp
  unsigned __int8 v17; // cl
  unsigned __int8 *v18; // esi
  unsigned __int8 v19; // cl
  unsigned __int8 *v20; // edx
  unsigned __int16 v21; // cx
  unsigned __int16 v22; // bp
  unsigned __int16 v23; // cx
  unsigned __int16 v24; // si
  unsigned __int16 v25; // cx
  __int16 v26; // cx
  unsigned int v27; // edx
  int v28; // esi
  int v29; // ebp
  unsigned int v30; // ebp
  unsigned __int8 *v31; // edx
  unsigned __int8 *v32; // esi
  unsigned __int16 v33; // cx
  unsigned __int16 v34; // bp
  unsigned __int16 v35; // cx
  _BYTE *v36; // esi
  _BYTE *v37; // ebp
  int v38; // ecx
  unsigned __int8 v39; // dl
  unsigned __int8 *v40; // esi
  unsigned __int8 v41; // dl
  _BYTE *v42; // esi
  _BYTE *v43; // ebp
  unsigned __int8 *v44; // eax
  unsigned __int8 v45; // cl
  unsigned __int8 v46; // dl
  unsigned __int8 *v47; // eax
  unsigned __int8 v48; // dl
  _BYTE *v49; // eax
  _BYTE *v50; // esi
  _BYTE *v51; // ecx
  unsigned __int16 v52; // dx
  _BYTE *v53; // ecx
  unsigned __int16 v54; // bp
  unsigned __int16 v55; // bx
  unsigned __int16 v56; // dx
  unsigned __int16 v57; // dx
  __int16 v58; // cx
  int v59; // esi
  int v60; // ebp
  unsigned int v61; // ebp
  _BYTE *v62; // esi
  _BYTE *v63; // eax
  _BYTE *v64; // ecx
  unsigned __int16 v65; // dx
  _BYTE *v66; // eax
  unsigned __int16 v67; // bp
  unsigned __int16 v68; // si
  unsigned __int16 v69; // dx
  unsigned int v70; // edx
  _BYTE *v71; // ecx
  char v72; // al
  char v73; // dl
  unsigned __int8 v74; // al
  unsigned __int8 v75; // [esp+1h] [ebp-27h]
  unsigned __int8 v76; // [esp+1h] [ebp-27h]
  unsigned __int8 v77; // [esp+2h] [ebp-26h]
  unsigned __int8 v78; // [esp+2h] [ebp-26h]
  unsigned __int8 v79; // [esp+2h] [ebp-26h]
  unsigned __int8 v80; // [esp+3h] [ebp-25h]
  int v81; // [esp+4h] [ebp-24h]
  int v82; // [esp+8h] [ebp-20h]
  int v83; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 *v84; // [esp+10h] [ebp-18h]
  unsigned __int8 *v85; // [esp+10h] [ebp-18h]
  int v86; // [esp+10h] [ebp-18h]
  _BYTE *v87; // [esp+10h] [ebp-18h]
  int v88; // [esp+14h] [ebp-14h]
  int v89; // [esp+14h] [ebp-14h]
  unsigned __int16 v90; // [esp+14h] [ebp-14h]
  unsigned __int16 v91; // [esp+14h] [ebp-14h]
  int v92; // [esp+14h] [ebp-14h]
  int v93; // [esp+18h] [ebp-10h]
  int v94; // [esp+18h] [ebp-10h]
  int v95; // [esp+18h] [ebp-10h]
  unsigned __int8 *v96; // [esp+18h] [ebp-10h]
  int v97; // [esp+1Ch] [ebp-Ch]
  int v98; // [esp+20h] [ebp-8h]
  int v99; // [esp+20h] [ebp-8h]
  unsigned __int8 *v100; // [esp+24h] [ebp-4h]

  v3 = *a2;
  v4 = *((_BYTE *)a2 + 8);
  result = 0;
  v82 = *a2;
  v81 = 0;
  if ( (v4 & 2) == 0 )
    return result;
  v6 = *(unsigned __int16 *)(a1 + 558);
  v7 = *(unsigned __int16 *)(a1 + 554);
  v98 = v7;
  v83 = *(unsigned __int16 *)(a1 + 556);
  v97 = v6;
  if ( v4 != 2 )
    goto LABEL_39;
  if ( *((_BYTE *)a2 + 9) == 8 )
  {
    if ( *(_DWORD *)(a1 + 360) && *(_DWORD *)(a1 + 364) )
    {
      v8 = a3;
      v84 = a3;
      if ( !v3 )
        goto LABEL_40;
      v88 = *a2;
      do
      {
        v9 = *(_DWORD *)(a1 + 364);
        v10 = *(_BYTE *)(*v8 + v9);
        v11 = *(_BYTE *)(v8[1] + v9);
        v12 = v8 + 2;
        v75 = *(_BYTE *)(*v12 + v9);
        v8 = v12 + 1;
        if ( v10 == v11 && v10 == v75 )
        {
          v13 = v84;
          *v84 = *(v8 - 1);
        }
        else
        {
          v81 |= 1u;
          v13 = v84;
          *v84 = *(_BYTE *)(((v7 * v10 + v83 * v11 + v6 * (unsigned int)v75) >> 15) + *(_DWORD *)(a1 + 360));
        }
        v14 = v88-- == 1;
        v84 = v13 + 1;
      }
      while ( !v14 );
      goto LABEL_38;
    }
    v15 = a3;
    v16 = a3;
    if ( v3 )
    {
      v89 = *a2;
      do
      {
        v17 = *v15;
        v18 = v15 + 1;
        v76 = v17;
        v19 = *v18;
        v77 = v18[1];
        v15 = v18 + 2;
        if ( v76 == v19 && v76 == v77 )
        {
          *v16 = *(v15 - 1);
        }
        else
        {
          v81 |= 1u;
          *v16 = (v7 * v76 + v83 * v19 + v6 * (unsigned int)v77) >> 15;
        }
        ++v16;
        --v89;
      }
      while ( v89 );
LABEL_38:
      v3 = v82;
      goto LABEL_39;
    }
  }
  else if ( *(_DWORD *)(a1 + 376) && *(_DWORD *)(a1 + 372) )
  {
    v20 = a3;
    v85 = a3;
    if ( v3 )
    {
      v93 = *a2;
      do
      {
        HIBYTE(v21) = *v20;
        v20 += 6;
        v100 = v20;
        LOBYTE(v21) = *(v20 - 5);
        v22 = v21;
        HIBYTE(v21) = *(v20 - 4);
        LOBYTE(v21) = *(v20 - 3);
        v90 = v21;
        v14 = v22 == v21;
        HIBYTE(v23) = *(v20 - 2);
        LOBYTE(v23) = *(v20 - 1);
        v24 = v23;
        if ( v14 && v22 == v23 )
        {
          v25 = v22;
        }
        else
        {
          v26 = *(_WORD *)(a1 + 344);
          v27 = v24;
          v28 = *(_DWORD *)(a1 + 376);
          v6 = v97;
          v29 = v83 * *(unsigned __int16 *)(*(_DWORD *)(v28 + 4 * ((unsigned __int8)v90 >> v26)) + 2 * HIBYTE(v90))
              + v7 * *(unsigned __int16 *)(*(_DWORD *)(v28 + 4 * ((unsigned __int8)v22 >> v26)) + 2 * HIBYTE(v22));
          v7 = v98;
          v30 = (v97
               * (unsigned int)*(unsigned __int16 *)(*(_DWORD *)(v28 + 4 * ((unsigned __int8)v27 >> v26))
                                                   + 2 * (v27 >> 8))
               + v29) >> 15;
          v81 |= 1u;
          v25 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * ((unsigned __int8)v30 >> v26)) + 2 * BYTE1(v30));
          v20 = v100;
        }
        *v85 = HIBYTE(v25);
        v85[1] = v25;
        v85 += 2;
        --v93;
      }
      while ( v93 );
      goto LABEL_38;
    }
  }
  else
  {
    v31 = a3;
    v32 = a3;
    if ( v3 )
    {
      v86 = *a2;
      do
      {
        HIBYTE(v33) = *v31;
        v31 += 6;
        LOBYTE(v33) = *(v31 - 5);
        v34 = v33;
        HIBYTE(v33) = *(v31 - 4);
        LOBYTE(v33) = *(v31 - 3);
        v91 = v33;
        v14 = v34 == v33;
        HIBYTE(v35) = *(v31 - 2);
        LOBYTE(v35) = *(v31 - 1);
        if ( !v14 || v34 != v35 )
          v81 |= 1u;
        *v32 = (unsigned __int16)((v7 * v34 + v83 * v91 + v6 * (unsigned int)v35) >> 15) >> 8;
        v36 = v32 + 1;
        *v36 = (v7 * v34 + v83 * v91 + v6 * (unsigned int)v35) >> 15;
        v32 = v36 + 1;
        --v86;
      }
      while ( v86 );
      goto LABEL_38;
    }
  }
LABEL_39:
  v8 = a3;
LABEL_40:
  if ( *((_BYTE *)a2 + 8) == 6 )
  {
    if ( *((_BYTE *)a2 + 9) != 8 )
    {
      if ( *(_DWORD *)(a1 + 376) && *(_DWORD *)(a1 + 372) )
      {
        v51 = v8;
        v96 = v8;
        if ( v82 )
        {
          v92 = v82;
          do
          {
            HIBYTE(v52) = *v51;
            v53 = v51 + 6;
            v87 = v53;
            LOBYTE(v52) = *(v53 - 5);
            v54 = v52;
            HIBYTE(v52) = *(v53 - 4);
            LOBYTE(v52) = *(v53 - 3);
            v55 = v52;
            v14 = v54 == v52;
            HIBYTE(v56) = *(v53 - 2);
            LOBYTE(v56) = *(v53 - 1);
            if ( v14 && v54 == v56 )
            {
              v57 = v54;
            }
            else
            {
              v58 = *(_WORD *)(a1 + 344);
              v59 = *(_DWORD *)(a1 + 376);
              v60 = v83 * *(unsigned __int16 *)(*(_DWORD *)(v59 + 4 * ((unsigned __int8)v55 >> v58)) + 2 * HIBYTE(v55))
                  + v7 * *(unsigned __int16 *)(*(_DWORD *)(v59 + 4 * ((unsigned __int8)v54 >> v58)) + 2 * HIBYTE(v54));
              v7 = v98;
              v61 = (v97
                   * (unsigned int)*(unsigned __int16 *)(*(_DWORD *)(v59 + 4 * ((unsigned __int8)v56 >> v58))
                                                       + 2 * HIBYTE(v56))
                   + v60) >> 15;
              v81 |= 1u;
              v57 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * ((unsigned __int8)v61 >> v58)) + 2 * BYTE1(v61));
              v8 = v96;
              v53 = v87;
            }
            *v8 = HIBYTE(v57);
            v62 = v8 + 1;
            *v62++ = v57;
            *v62++ = *v53;
            *v62 = v53[1];
            v8 = v62 + 1;
            v51 = v53 + 2;
            v14 = v92-- == 1;
            v96 = v8;
          }
          while ( !v14 );
        }
      }
      else
      {
        v63 = v8;
        v64 = v8;
        if ( v82 )
        {
          v99 = v82;
          do
          {
            LOBYTE(v65) = v63[1];
            HIBYTE(v65) = *v63;
            v66 = v63 + 6;
            v67 = v65;
            LOBYTE(v65) = *(v66 - 3);
            HIBYTE(v65) = *(v66 - 4);
            v68 = v65;
            v14 = v67 == v65;
            LOBYTE(v69) = *(v66 - 1);
            HIBYTE(v69) = *(v66 - 2);
            if ( !v14 || v67 != v69 )
              v81 |= 1u;
            v70 = (v7 * v67 + v83 * v68 + v6 * (unsigned int)v69) >> 15;
            *v64 = BYTE1(v70);
            v71 = v64 + 1;
            *v71++ = v70;
            *v71++ = *v66;
            *v71 = v66[1];
            v64 = v71 + 1;
            v63 = v66 + 2;
            --v99;
          }
          while ( v99 );
        }
      }
      goto LABEL_74;
    }
    if ( *(_DWORD *)(a1 + 360) && *(_DWORD *)(a1 + 364) )
    {
      v37 = v8;
      if ( v82 )
      {
        v94 = v82;
        do
        {
          v38 = *(_DWORD *)(a1 + 364);
          v39 = *(_BYTE *)(*v8 + v38);
          v40 = v8 + 1;
          v80 = v39;
          v41 = *(_BYTE *)(*v40++ + v38);
          v78 = *(_BYTE *)(*v40 + v38);
          v42 = v40 + 1;
          if ( v80 != v41 || v80 != v78 )
            v81 |= 1u;
          *v37 = *(_BYTE *)(((v7 * v80 + v83 * v41 + v6 * (unsigned int)v78) >> 15) + *(_DWORD *)(a1 + 360));
          v43 = v37 + 1;
          *v43 = *v42;
          v37 = v43 + 1;
          v8 = v42 + 1;
          --v94;
        }
        while ( v94 );
      }
LABEL_74:
      v3 = v82;
      goto LABEL_75;
    }
    v44 = v8;
    if ( v3 )
    {
      v95 = v3;
      do
      {
        v45 = *v44;
        v46 = v44[1];
        v47 = v44 + 2;
        v79 = v46;
        v48 = *v47;
        v49 = v47 + 1;
        if ( v45 != v79 || v45 != v48 )
          v81 |= 1u;
        *v8 = (v7 * v45 + v83 * v79 + v6 * (unsigned int)v48) >> 15;
        v50 = v8 + 1;
        *v50 = *v49;
        v8 = v50 + 1;
        v44 = v49 + 1;
        --v95;
      }
      while ( v95 );
      goto LABEL_74;
    }
  }
LABEL_75:
  *((_BYTE *)a2 + 10) -= 2;
  v72 = *((_BYTE *)a2 + 9);
  v73 = *((_BYTE *)a2 + 10);
  *((_BYTE *)a2 + 8) &= 0xFDu;
  v74 = v73 * v72;
  *((_BYTE *)a2 + 11) = v74;
  if ( v74 < 8u )
    a2[1] = (v3 * (unsigned int)v74 + 7) >> 3;
  else
    a2[1] = v3 * (v74 >> 3);
  return v81;
}

//----- (0040D5E0) --------------------------------------------------------
char __cdecl sub_40D5E0(int *a1, unsigned __int8 *a2, _WORD *a3, _BYTE *a4, _WORD *a5, int a6, int a7, int a8, int a9, int a10, int a11, __int16 a12)
{
  unsigned int v12; // eax
  int v13; // ecx
  _WORD *v14; // ebp
  _BYTE *v15; // esi
  int v16; // edx
  int v17; // ebp
  char v18; // al
  _BYTE *v19; // esi
  int v20; // edx
  unsigned __int8 v21; // al
  char v22; // al
  char v23; // bl
  int v24; // ebp
  char v25; // al
  _BYTE *v26; // esi
  int v27; // edx
  unsigned __int8 v28; // al
  char v29; // al
  char v30; // bl
  int v31; // ebp
  char v32; // al
  _BYTE *v33; // eax
  int v34; // edx
  char v35; // cl
  unsigned __int8 *v36; // eax
  unsigned __int8 v37; // cl
  __int16 v38; // cx
  _BYTE *v39; // eax
  int v40; // edi
  unsigned __int8 v41; // cl
  char v42; // cl
  _BYTE *v43; // eax
  unsigned __int8 *v44; // eax
  unsigned __int8 v45; // bl
  unsigned __int8 v46; // cl
  __int16 v47; // cx
  unsigned int v48; // ebx
  __int16 v49; // cx
  unsigned int v50; // ebx
  int v51; // edx
  __int16 v52; // cx
  unsigned __int8 *v53; // eax
  unsigned __int8 *v54; // ecx
  _BYTE *v55; // esi
  __int16 v56; // ax
  unsigned int v57; // eax
  unsigned __int8 *v58; // ecx
  _BYTE *v59; // esi
  int v60; // edi
  unsigned __int8 v61; // al
  int v62; // edx
  unsigned int v63; // eax
  _BYTE *v64; // esi
  _BYTE *v65; // edi
  unsigned __int8 *v66; // edx
  unsigned __int16 v67; // ax
  __int16 v68; // ax
  unsigned int v69; // eax
  unsigned __int8 *v70; // edx
  _BYTE *v71; // esi
  unsigned __int8 *v72; // ecx
  unsigned __int16 v73; // ax
  unsigned int v74; // eax
  int v75; // edi
  int v76; // ebp
  int v77; // ecx
  _BYTE *v78; // ebx
  _BYTE *v79; // esi
  unsigned __int8 *v80; // edi
  unsigned __int8 v81; // al
  char v82; // al
  __int16 v83; // cx
  unsigned int v84; // ebp
  unsigned int v85; // ebp
  char v86; // bl
  unsigned int v87; // eax
  _BYTE *v88; // esi
  unsigned __int8 *v89; // edi
  unsigned __int8 v90; // al
  int v91; // ecx
  __int16 v92; // cx
  unsigned int v93; // eax
  int v94; // ebp
  char v95; // bl
  _BYTE *v96; // eax
  unsigned __int8 *v97; // edx
  unsigned __int16 v98; // si
  __int16 v99; // cx
  __int16 v100; // cx
  __int16 v101; // cx
  int v102; // edi
  unsigned int v103; // ebx
  __int16 v104; // cx
  unsigned int v105; // ebx
  __int16 v106; // cx
  unsigned int v107; // ebx
  _BYTE *v108; // esi
  unsigned __int8 *v109; // eax
  unsigned __int8 *v110; // ecx
  unsigned __int16 v111; // dx
  unsigned int v112; // edx
  int v113; // esi
  unsigned __int16 v114; // dx
  unsigned int v115; // edx
  int v116; // ebp
  unsigned int v117; // ebp
  unsigned int v118; // edx
  unsigned int v119; // esi
  char v120; // cl
  unsigned __int8 v121; // al
  int v123; // [esp+0h] [ebp-10h]
  int v124; // [esp+4h] [ebp-Ch]
  int v125; // [esp+4h] [ebp-Ch]
  int v126; // [esp+4h] [ebp-Ch]
  int v127; // [esp+4h] [ebp-Ch]
  int v128; // [esp+4h] [ebp-Ch]
  int v129; // [esp+4h] [ebp-Ch]
  int v130; // [esp+4h] [ebp-Ch]
  int v131; // [esp+4h] [ebp-Ch]
  int v132; // [esp+4h] [ebp-Ch]
  char v133; // [esp+4h] [ebp-Ch]
  unsigned __int16 v134; // [esp+4h] [ebp-Ch]
  int v135; // [esp+Ch] [ebp-4h]
  int v136; // [esp+Ch] [ebp-4h]

  LOBYTE(v12) = (_BYTE)a1;
  v13 = *a1;
  v123 = *a1;
  if ( !a4 )
    return v12;
  LOBYTE(v12) = *((_BYTE *)a1 + 8);
  if ( (v12 & 4) != 0 )
  {
    if ( (_BYTE)v12 == 3 )
      return v12;
    v14 = a3;
    if ( !a3 )
      return v12;
  }
  else
  {
    v14 = a3;
  }
  switch ( (char)v12 )
  {
    case 0:
      switch ( *((_BYTE *)a1 + 9) )
      {
        case 1:
          v15 = a2;
          v16 = 7;
          if ( v13 )
          {
            v17 = *a1;
            do
            {
              if ( ((*v15 >> v16) & 1) == a3[4] )
              {
                v18 = *v15 & (32639 >> (7 - v16));
                *v15 = v18;
                *v15 = v18 | (a4[8] << v16);
              }
              if ( v16 )
              {
                --v16;
              }
              else
              {
                v16 = 7;
                ++v15;
              }
              --v17;
            }
            while ( v17 );
          }
          break;
        case 2:
          v19 = a2;
          v20 = 6;
          if ( a6 )
          {
            if ( v13 )
            {
              v124 = *a1;
              do
              {
                v21 = (*v19 >> v20) & 3;
                if ( v21 == a3[4] )
                {
                  v22 = *v19 & (16191 >> (6 - v20));
                  *v19 = v22;
                  v23 = a4[8] << v20;
                }
                else
                {
                  v23 = *v19 & (16191 >> (6 - v20));
                  v22 = *(_BYTE *)((v21 | (4 * (v21 | (4 * (v21 | (4 * v21)))))) + a6) >> 6 << v20;
                }
                *v19 = v22 | v23;
                if ( v20 )
                {
                  v20 -= 2;
                }
                else
                {
                  v20 = 6;
                  ++v19;
                }
                --v124;
              }
              while ( v124 );
            }
          }
          else if ( v13 )
          {
            v24 = *a1;
            do
            {
              if ( ((*v19 >> v20) & 3) == a3[4] )
              {
                v25 = *v19 & (16191 >> (6 - v20));
                *v19 = v25;
                *v19 = v25 | (a4[8] << v20);
              }
              if ( v20 )
              {
                v20 -= 2;
              }
              else
              {
                v20 = 6;
                ++v19;
              }
              --v24;
            }
            while ( v24 );
          }
          break;
        case 4:
          v26 = a2;
          v27 = 4;
          if ( a6 )
          {
            if ( v13 )
            {
              v125 = *a1;
              do
              {
                v28 = (*v26 >> v27) & 0xF;
                if ( v28 == a3[4] )
                {
                  v29 = *v26 & (3855 >> (4 - v27));
                  *v26 = v29;
                  v30 = a4[8] << v27;
                }
                else
                {
                  v30 = *v26 & (3855 >> (4 - v27));
                  v29 = *(_BYTE *)((v28 | (16 * v28)) + a6) >> 4 << v27;
                }
                *v26 = v29 | v30;
                if ( v27 )
                {
                  v27 -= 4;
                }
                else
                {
                  v27 = 4;
                  ++v26;
                }
                --v125;
              }
              while ( v125 );
            }
          }
          else if ( v13 )
          {
            v31 = *a1;
            do
            {
              if ( ((*v26 >> v27) & 0xF) == a3[4] )
              {
                v32 = *v26 & (3855 >> (4 - v27));
                *v26 = v32;
                *v26 = v32 | (a4[8] << v27);
              }
              if ( v27 )
              {
                v27 -= 4;
              }
              else
              {
                v27 = 4;
                ++v26;
              }
              --v31;
            }
            while ( v31 );
          }
          break;
        case 8:
          v33 = a2;
          if ( a6 )
          {
            if ( v13 )
            {
              v34 = *a1;
              do
              {
                if ( (unsigned __int8)*v33 == v14[4] )
                  v35 = a4[8];
                else
                  v35 = *(_BYTE *)((unsigned __int8)*v33 + a6);
                *v33++ = v35;
                --v34;
              }
              while ( v34 );
            }
          }
          else
          {
            for ( ; v13; --v13 )
            {
              if ( (unsigned __int8)*v33 == v14[4] )
                *v33 = a4[8];
              ++v33;
            }
          }
          break;
        case 0x10:
          v36 = a2;
          if ( a9 )
          {
            if ( v13 )
            {
              v126 = *a1;
              do
              {
                v37 = v36[1];
                if ( v37 + (*v36 << 8) == a3[4] )
                {
                  *v36 = a4[9];
                  LOBYTE(v38) = a4[8];
                }
                else
                {
                  v38 = *(_WORD *)(*(_DWORD *)(a9 + 4 * (v37 >> a12)) + 2 * *v36);
                  *v36 = HIBYTE(v38);
                }
                v36[1] = v38;
                v36 += 2;
                --v126;
              }
              while ( v126 );
            }
          }
          else
          {
            for ( ; v13; --v13 )
            {
              if ( v36[1] + (*v36 << 8) == v14[4] )
              {
                *v36 = a4[9];
                v36[1] = a4[8];
              }
              v36 += 2;
            }
          }
          break;
        default:
          goto LABEL_211;
      }
      goto LABEL_211;
    case 2:
      if ( *((_BYTE *)a1 + 9) == 8 )
      {
        if ( a6 )
        {
          if ( v13 )
          {
            v39 = a2 + 2;
            v40 = *a1;
            do
            {
              v41 = *(v39 - 2);
              if ( v41 == v14[1] && (unsigned __int8)*(v39 - 1) == v14[2] && (unsigned __int8)*v39 == v14[3] )
              {
                *(v39 - 2) = a4[2];
                *(v39 - 1) = a4[4];
                v42 = a4[6];
              }
              else
              {
                *(v39 - 2) = *(_BYTE *)(v41 + a6);
                *(v39 - 1) = *(_BYTE *)((unsigned __int8)*(v39 - 1) + a6);
                v42 = *(_BYTE *)((unsigned __int8)*v39 + a6);
              }
              *v39 = v42;
              v39 += 3;
              --v40;
            }
            while ( v40 );
          }
        }
        else if ( v13 )
        {
          v43 = a2 + 2;
          do
          {
            if ( (unsigned __int8)*(v43 - 2) == v14[1]
              && (unsigned __int8)*(v43 - 1) == v14[2]
              && (unsigned __int8)*v43 == v14[3] )
            {
              *(v43 - 2) = a4[2];
              *(v43 - 1) = a4[4];
              *v43 = a4[6];
            }
            v43 += 3;
            --v13;
          }
          while ( v13 );
        }
      }
      else if ( a9 )
      {
        if ( v13 )
        {
          v44 = a2 + 2;
          v127 = *a1;
          do
          {
            v45 = *(v44 - 2);
            v46 = *(v44 - 1);
            if ( v46 + (v45 << 8) == a3[1] && v44[1] + (*v44 << 8) == a3[2] && v44[3] + (v44[2] << 8) == a3[3] )
            {
              *(v44 - 2) = a4[3];
              *(v44 - 1) = a4[2];
              *v44 = a4[5];
              v44[1] = a4[4];
              v44[2] = a4[7];
              v44[3] = a4[6];
            }
            else
            {
              v47 = *(_WORD *)(*(_DWORD *)(a9 + 4 * (v46 >> a12)) + 2 * v45);
              v48 = v44[1];
              *(v44 - 1) = v47;
              *(v44 - 2) = HIBYTE(v47);
              v49 = *(_WORD *)(*(_DWORD *)(a9 + 4 * (v48 >> a12)) + 2 * *v44);
              v50 = v44[3];
              v44[1] = v49;
              v51 = v44[2];
              *v44 = HIBYTE(v49);
              v52 = *(_WORD *)(*(_DWORD *)(a9 + 4 * (v50 >> a12)) + 2 * v51);
              v44[2] = HIBYTE(v52);
              v44[3] = v52;
            }
            v44 += 6;
            --v127;
          }
          while ( v127 );
        }
      }
      else if ( v13 )
      {
        v53 = a2 + 2;
        do
        {
          if ( *(v53 - 1) + (*(v53 - 2) << 8) == v14[1]
            && v53[1] + (*v53 << 8) == v14[2]
            && v53[3] + (v53[2] << 8) == v14[3] )
          {
            *(v53 - 2) = a4[3];
            *(v53 - 1) = a4[2];
            *v53 = a4[5];
            v53[1] = a4[4];
            v53[2] = a4[7];
            v53[3] = a4[6];
          }
          v53 += 6;
          --v13;
        }
        while ( v13 );
      }
      goto LABEL_211;
    case 4:
      if ( *((_BYTE *)a1 + 9) == 8 )
      {
        if ( a8 && a7 && a6 )
        {
          v54 = a2;
          v55 = a2;
          if ( v123 )
          {
            v128 = *a1;
            do
            {
              v56 = v54[1];
              if ( v56 == 255 )
              {
                *v55 = *(_BYTE *)(*v54 + a6);
              }
              else if ( v54[1] )
              {
                v57 = (unsigned __int16)(v56 * *(unsigned __int8 *)(*v54 + a8) + a5[4] * (255 - v56) + 128);
                *v55 = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v57 + (v57 >> 8)) >> 8) + a7);
              }
              else
              {
                *v55 = a4[8];
              }
              v54 += 2;
              ++v55;
              --v128;
            }
            while ( v128 );
          }
        }
        else
        {
          v58 = a2;
          v59 = a2;
          if ( v123 )
          {
            v60 = *a1;
            do
            {
              v61 = v58[1];
              if ( v61 == 0xFF )
              {
                LOBYTE(v62) = *v58;
              }
              else if ( v61 )
              {
                v63 = (unsigned __int16)(v61 * *v58 + a5[4] * (255 - v61) + 128);
                v62 = (int)(v63 + (v63 >> 8)) >> 8;
              }
              else
              {
                LOBYTE(v62) = a4[8];
              }
              *v59 = v62;
              v58 += 2;
              ++v59;
              --v60;
            }
            while ( v60 );
          }
        }
        goto LABEL_211;
      }
      if ( !a9 || !a10 || !a11 )
      {
        v70 = a2;
        if ( v123 )
        {
          v71 = a4;
          v72 = a2 + 3;
          v130 = *a1;
          do
          {
            v73 = *v72 + (*(v72 - 1) << 8);
            if ( v73 == 0xFFFF )
            {
              *(_WORD *)v70 = *(_WORD *)(v72 - 3);
            }
            else
            {
              if ( v73 )
              {
                v75 = (0xFFFF - v73) * (unsigned __int16)a5[4];
                v71 = a4;
                v74 = (v73 * (unsigned __int16)(*(v72 - 2) + (*(v72 - 3) << 8))
                     + v75
                     + 0x8000
                     + ((v73 * (unsigned int)(unsigned __int16)(*(v72 - 2) + (*(v72 - 3) << 8)) + v75 + 0x8000) >> 16)) >> 16;
                *v70 = BYTE1(v74);
              }
              else
              {
                *v70 = v71[9];
                LOBYTE(v74) = v71[8];
              }
              v70[1] = v74;
            }
            v72 += 4;
            v70 += 2;
            --v130;
          }
          while ( v130 );
        }
        goto LABEL_211;
      }
      v64 = a2;
      if ( v13 )
      {
        v65 = a4;
        v66 = a2 + 1;
        v129 = *a1;
        while ( 1 )
        {
          v67 = v66[2] + (v66[1] << 8);
          if ( v67 == 0xFFFF )
            break;
          if ( v67 )
          {
            v69 = (v67 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (*v66 >> a12)) + 2 * *(v66 - 1))
                 + (0xFFFF - v67) * (unsigned __int16)a5[4]
                 + 0x8000
                 + ((v67 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (*v66 >> a12)) + 2 * *(v66 - 1))
                   + (0xFFFF - v67) * (unsigned int)(unsigned __int16)a5[4]
                   + 0x8000) >> 16)) >> 16;
            v68 = *(_WORD *)(*(_DWORD *)(a10 + 4 * ((unsigned __int8)v69 >> a12)) + 2 * (v69 >> 8));
            v65 = a4;
            goto LABEL_153;
          }
          *v64 = v65[9];
          LOBYTE(v68) = v65[8];
LABEL_154:
          v64[1] = v68;
          v66 += 4;
          v64 += 2;
          if ( !--v129 )
            goto LABEL_211;
        }
        v68 = *(_WORD *)(*(_DWORD *)(a9 + 4 * (*v66 >> a12)) + 2 * *(v66 - 1));
LABEL_153:
        *v64 = HIBYTE(v68);
        goto LABEL_154;
      }
LABEL_211:
      LOBYTE(v12) = *((_BYTE *)a1 + 8);
      if ( (v12 & 4) != 0 )
      {
        v120 = --*((_BYTE *)a1 + 10);
        *((_BYTE *)a1 + 8) = v12 & 0xFB;
        v121 = v120 * *((_BYTE *)a1 + 9);
        *((_BYTE *)a1 + 11) = v121;
        if ( v121 < 8u )
          v12 = (v123 * (unsigned int)v121 + 7) >> 3;
        else
          v12 = v123 * (v121 >> 3);
        a1[1] = v12;
      }
      return v12;
    case 6:
      if ( *((_BYTE *)a1 + 9) == 8 )
      {
        v76 = a8;
        if ( a8 && a7 && (v77 = a6) != 0 )
        {
          if ( v123 )
          {
            v78 = a4;
            v79 = a2 + 2;
            v131 = *a1;
            v80 = a2 + 1;
            do
            {
              v81 = v80[2];
              if ( v81 == 0xFF )
              {
                *(v79 - 2) = *(_BYTE *)(*(v80 - 1) + v77);
                *(v79 - 1) = *(_BYTE *)(*v80 + v77);
                v82 = *(_BYTE *)(v80[1] + v77);
              }
              else if ( v81 )
              {
                v83 = 255 - v81;
                v84 = (unsigned __int16)(v83 * a5[1] + v81 * *(unsigned __int8 *)(*(v80 - 1) + v76) + 128);
                *(v79 - 2) = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v84 + (v84 >> 8)) >> 8) + a7);
                v85 = (unsigned __int16)(v83 * a5[2] + v81 * *(unsigned __int8 *)(*v80 + a8) + 128);
                v86 = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v85 + (v85 >> 8)) >> 8) + a7);
                v76 = a8;
                *(v79 - 1) = v86;
                v78 = a4;
                v87 = (unsigned __int16)(v83 * a5[3] + v81 * *(unsigned __int8 *)(v80[1] + a8) + 128);
                v82 = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v87 + (v87 >> 8)) >> 8) + a7);
                v77 = a6;
              }
              else
              {
                *(v79 - 2) = v78[2];
                *(v79 - 1) = v78[4];
                v82 = v78[6];
              }
              *v79 = v82;
              v80 += 4;
              v79 += 3;
              --v131;
            }
            while ( v131 );
          }
        }
        else if ( v123 )
        {
          v88 = a2 + 2;
          v89 = a2 + 1;
          v132 = *a1;
          do
          {
            v90 = v89[2];
            if ( v90 == 0xFF )
            {
              *(v88 - 2) = *(v89 - 1);
              *(v88 - 1) = *v89;
              *v88 = v89[1];
            }
            else
            {
              if ( v90 )
              {
                v92 = 255 - v90;
                *(v88 - 2) = (unsigned __int16)(v92 * *((_WORD *)a4 + 1)
                                              + v90 * *(v89 - 1)
                                              + 128
                                              + ((unsigned __int16)(v92 * *((_WORD *)a4 + 1) + v90 * *(v89 - 1) + 128) >> 8)) >> 8;
                *(v88 - 1) = (unsigned __int16)(v90 * *v89
                                              + v92 * *((_WORD *)a4 + 2)
                                              + 128
                                              + ((unsigned __int16)(v90 * *v89 + v92 * *((_WORD *)a4 + 2) + 128) >> 8)) >> 8;
                v93 = (unsigned __int16)(v92 * *((_WORD *)a4 + 3) + v90 * v89[1] + 128);
                v91 = (int)(v93 + (v93 >> 8)) >> 8;
              }
              else
              {
                *(v88 - 2) = a4[2];
                *(v88 - 1) = a4[4];
                LOBYTE(v91) = a4[6];
              }
              *v88 = v91;
            }
            v89 += 4;
            v88 += 3;
            --v132;
          }
          while ( v132 );
        }
        goto LABEL_211;
      }
      v94 = a9;
      if ( !a9 || !a10 || !a11 )
      {
        if ( v123 )
        {
          v108 = a4;
          v109 = a2 + 2;
          v110 = a2 + 7;
          v136 = *a1;
          do
          {
            v111 = *v110 + (*(v110 - 1) << 8);
            if ( v111 == 0xFFFF )
            {
              *(_DWORD *)(v109 - 2) = *(_DWORD *)(v110 - 7);
              *((_WORD *)v109 + 1) = *(_WORD *)(v110 - 3);
            }
            else
            {
              if ( v111 )
              {
                v134 = *(v110 - 2) + (*(v110 - 3) << 8);
                v113 = v111;
                v114 = *(v110 - 6) + (*(v110 - 7) << 8);
                v115 = (v113 * v114
                      + (0xFFFF - v113) * *((unsigned __int16 *)a4 + 1)
                      + 0x8000
                      + ((v113 * v114 + (0xFFFF - v113) * (unsigned int)*((unsigned __int16 *)a4 + 1) + 0x8000) >> 16)) >> 16;
                v116 = v113 * (unsigned __int16)(*(v110 - 4) + (*(v110 - 5) << 8));
                *(v109 - 2) = BYTE1(v115);
                *(v109 - 1) = v115;
                v117 = (0xFFFF - v113) * *((unsigned __int16 *)a4 + 2) + v116 + 0x8000;
                v118 = (v117 + HIWORD(v117)) >> 16;
                *v109 = BYTE1(v118);
                v109[1] = v118;
                v119 = (0xFFFF - v113) * *((unsigned __int16 *)a4 + 3) + v113 * v134 + 0x8000;
                v112 = (v119 + HIWORD(v119)) >> 16;
                v109[2] = BYTE1(v112);
                v108 = a4;
              }
              else
              {
                *(v109 - 2) = v108[3];
                *(v109 - 1) = v108[2];
                *v109 = v108[5];
                v109[1] = v108[4];
                v109[2] = v108[7];
                LOBYTE(v112) = v108[6];
              }
              v109[3] = v112;
            }
            v110 += 8;
            v109 += 6;
            --v136;
          }
          while ( v136 );
        }
        goto LABEL_211;
      }
      if ( !v123 )
        goto LABEL_211;
      v95 = a12;
      v96 = a2 + 2;
      v97 = a2 + 1;
      v135 = *a1;
      break;
    default:
      goto LABEL_211;
  }
  while ( 1 )
  {
    v98 = v97[6] + (v97[5] << 8);
    if ( v98 == 0xFFFF )
      break;
    if ( v98 )
    {
      v102 = v98;
      v133 = v95;
      v103 = (v102 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (*v97 >> v95)) + 2 * *(v97 - 1))
            + (0xFFFF - v102) * (unsigned __int16)a5[1]
            + 0x8000
            + ((v102 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (*v97 >> v95)) + 2 * *(v97 - 1))
              + (0xFFFF - v102) * (unsigned int)(unsigned __int16)a5[1]
              + 0x8000) >> 16)) >> 16;
      v104 = *(_WORD *)(*(_DWORD *)(a10 + 4 * ((unsigned __int8)v103 >> a12)) + 2 * (v103 >> 8));
      *(v96 - 2) = HIBYTE(v104);
      *(v96 - 1) = v104;
      v105 = (v102 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (v97[2] >> v133)) + 2 * v97[1])
            + (0xFFFF - v102) * (unsigned __int16)a5[2]
            + 0x8000
            + ((v102 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (v97[2] >> v133)) + 2 * v97[1])
              + (0xFFFF - v102) * (unsigned int)(unsigned __int16)a5[2]
              + 0x8000) >> 16)) >> 16;
      v106 = *(_WORD *)(*(_DWORD *)(a10 + 4 * ((unsigned __int8)v105 >> a12)) + 2 * (v105 >> 8));
      *v96 = HIBYTE(v106);
      v96[1] = v106;
      v107 = (v102 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (v97[4] >> v133)) + 2 * v97[3])
            + (0xFFFF - v102) * (unsigned __int16)a5[3]
            + 0x8000
            + ((v102 * *(unsigned __int16 *)(*(_DWORD *)(a11 + 4 * (v97[4] >> v133)) + 2 * v97[3])
              + (0xFFFF - v102) * (unsigned int)(unsigned __int16)a5[3]
              + 0x8000) >> 16)) >> 16;
      v101 = *(_WORD *)(*(_DWORD *)(a10 + 4 * ((unsigned __int8)v107 >> a12)) + 2 * (v107 >> 8));
      v94 = a9;
      v95 = a12;
      goto LABEL_199;
    }
    *(v96 - 2) = a4[3];
    *(v96 - 1) = a4[2];
    *v96 = a4[5];
    v96[1] = a4[4];
    v96[2] = a4[7];
    LOBYTE(v101) = a4[6];
LABEL_200:
    v96[3] = v101;
    v97 += 8;
    v96 += 6;
    if ( !--v135 )
      goto LABEL_211;
  }
  v99 = *(_WORD *)(*(_DWORD *)(v94 + 4 * (*v97 >> v95)) + 2 * *(v97 - 1));
  *(v96 - 2) = HIBYTE(v99);
  *(v96 - 1) = v99;
  v100 = *(_WORD *)(*(_DWORD *)(v94 + 4 * (v97[2] >> v95)) + 2 * v97[1]);
  *v96 = HIBYTE(v100);
  v96[1] = v100;
  v101 = *(_WORD *)(*(_DWORD *)(v94 + 4 * (v97[4] >> v95)) + 2 * v97[3]);
LABEL_199:
  v96[2] = HIBYTE(v101);
  goto LABEL_200;
}

//----- (0040E5E0) --------------------------------------------------------
char __cdecl sub_40E5E0(int *a1, unsigned __int8 *a2, int a3, int a4, char a5)
{
  int v5; // edx
  int *v6; // ebp
  unsigned __int8 *v7; // eax
  int v8; // esi
  bool v9; // zf
  char v10; // dl
  _BYTE *v11; // eax
  char v12; // dl
  __int16 v13; // cx
  unsigned int v14; // edi
  unsigned __int8 *v15; // eax
  __int16 v16; // cx
  unsigned int v17; // edi
  __int16 v18; // cx
  char v19; // cl
  _BYTE *v20; // eax
  int v21; // edx
  __int16 v22; // cx
  unsigned int v23; // edi
  unsigned __int8 *v24; // eax
  __int16 v25; // cx
  unsigned int v26; // edi
  __int16 v27; // cx
  __int16 v28; // cx
  char v29; // al
  int v30; // edx
  int v31; // esi
  int v32; // ecx
  char v33; // cl
  _BYTE *v34; // edx
  unsigned int v35; // esi
  __int16 v36; // cx
  unsigned __int8 *v38; // [esp+Ch] [ebp-Ch]
  unsigned int v39; // [esp+10h] [ebp-8h]
  int v40; // [esp+14h] [ebp-4h]

  v5 = a4;
  v6 = a1;
  LOBYTE(v7) = *((_BYTE *)a1 + 9);
  v8 = *a1;
  v40 = *a1;
  if ( (unsigned __int8)v7 <= 8u && a3 || (_BYTE)v7 == 16 && a4 )
  {
    switch ( *((_BYTE *)a1 + 8) )
    {
      case 0:
        v9 = (_BYTE)v7 == 2;
        v7 = a2;
        if ( v9 )
        {
          v38 = a2;
          if ( v8 )
          {
            v39 = ((unsigned int)(v8 - 1) >> 2) + 1;
            do
            {
              v29 = *v7;
              v30 = v29 & 0xC;
              v31 = v29 & 0x30;
              v32 = v29 & 0xC0;
              *v38 = *(_BYTE *)((v32 | ((v32 | ((v32 | (v32 >> 2)) >> 2)) >> 2)) + a3) & 0xC0 | ((unsigned __int8)(*(_BYTE *)((v31 | (4 * v31) | ((v31 | (v31 >> 2)) >> 2)) + a3) & 0xC3 | ((unsigned __int8)((*(_BYTE *)((v29 & 3 | (4 * (v29 & 3 | (4 * (v29 & 3 | (4 * (v29 & 3))))))) + a3) >> 2) | *(_BYTE *)((v30 | (v30 >> 2) | (4 * (v30 | (4 * v30)))) + a3) & 0xCF) >> 2)) >> 2);
              v7 = v38 + 1;
              v9 = v39-- == 1;
              ++v38;
            }
            while ( !v9 );
            v5 = a4;
            v7 = a2;
            v6 = a1;
            v8 = v40;
          }
        }
        v33 = *((_BYTE *)v6 + 9);
        if ( v33 == 4 )
        {
          v34 = v7;
          if ( v8 )
          {
            v35 = ((unsigned int)(v8 - 1) >> 1) + 1;
            do
            {
              LOBYTE(v7) = *(_BYTE *)((*v34 & 0xF | (16 * (*v34 & 0xF))) + a3) >> 4;
              *v34 = (unsigned __int8)v7 | *(_BYTE *)((*v34 & 0xF0 | ((*v34 & 0xF0) >> 4)) + a3) & 0xF0;
              ++v34;
              --v35;
            }
            while ( v35 );
          }
        }
        else if ( v33 == 8 )
        {
          for ( ; v8; --v8 )
          {
            *v7 = *(_BYTE *)(*v7 + a3);
            ++v7;
          }
        }
        else if ( v33 == 16 && v8 )
        {
          do
          {
            v36 = *(_WORD *)(*(_DWORD *)(v5 + 4 * (v7[1] >> a5)) + 2 * *v7);
            *v7 = HIBYTE(v36);
            v7[1] = v36;
            v7 += 2;
            --v8;
          }
          while ( v8 );
        }
        break;
      case 2:
        v9 = (_BYTE)v7 == 8;
        v7 = a2;
        if ( v9 )
        {
          for ( ; v8; --v8 )
          {
            *v7 = *(_BYTE *)(*v7 + a3);
            v10 = *(_BYTE *)(v7[1] + a3);
            v11 = v7 + 1;
            *v11 = v10;
            v12 = *(_BYTE *)((unsigned __int8)*++v11 + a3);
            *v11 = v12;
            v7 = v11 + 1;
          }
        }
        else
        {
          for ( ; v8; --v8 )
          {
            v13 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v7[1] >> a5)) + 2 * *v7);
            v7[1] = v13;
            *v7 = HIBYTE(v13);
            v14 = v7[3];
            v15 = v7 + 2;
            v16 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v14 >> a5)) + 2 * *v15);
            v15[1] = v16;
            *v15 = HIBYTE(v16);
            v17 = v15[3];
            v15 += 2;
            v18 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v17 >> a5)) + 2 * *v15);
            *v15 = HIBYTE(v18);
            v15[1] = v18;
            v7 = v15 + 2;
          }
        }
        break;
      case 4:
        v9 = (_BYTE)v7 == 8;
        v7 = a2;
        if ( v9 )
        {
          for ( ; v8; --v8 )
          {
            *v7 = *(_BYTE *)(*v7 + a3);
            v7 += 2;
          }
        }
        else
        {
          for ( ; v8; --v8 )
          {
            v28 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v7[1] >> a5)) + 2 * *v7);
            *v7 = HIBYTE(v28);
            v7[1] = v28;
            v7 += 4;
          }
        }
        break;
      case 6:
        v9 = (_BYTE)v7 == 8;
        v7 = a2;
        if ( v9 )
        {
          for ( ; v8; --v8 )
          {
            *v7 = *(_BYTE *)(*v7 + a3);
            v19 = *(_BYTE *)(v7[1] + a3);
            v20 = v7 + 1;
            *v20 = v19;
            v21 = (unsigned __int8)*++v20;
            *v20 = *(_BYTE *)(v21 + a3);
            v7 = v20 + 2;
          }
        }
        else
        {
          for ( ; v8; --v8 )
          {
            v22 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v7[1] >> a5)) + 2 * *v7);
            v7[1] = v22;
            *v7 = HIBYTE(v22);
            v23 = v7[3];
            v24 = v7 + 2;
            v25 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v23 >> a5)) + 2 * *v24);
            v24[1] = v25;
            *v24 = HIBYTE(v25);
            v26 = v24[3];
            v24 += 2;
            v27 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v26 >> a5)) + 2 * *v24);
            *v24 = HIBYTE(v27);
            v24[1] = v27;
            v7 = v24 + 4;
          }
        }
        break;
      default:
        return (char)v7;
    }
  }
  return (char)v7;
}

//----- (0040E9A0) --------------------------------------------------------
void __cdecl sub_40E9A0(int *a1, int a2, int a3, int a4, int a5)
{
  int *v5; // ebx
  int v6; // edx
  unsigned __int8 v7; // al
  int v8; // eax
  int v9; // eax
  _BYTE *v10; // esi
  int v11; // eax
  _BYTE *v12; // edi
  _BYTE *v13; // esi
  int v14; // eax
  _BYTE *v15; // edi
  _BYTE *v16; // esi
  int v17; // eax
  _BYTE *v18; // edi
  unsigned __int8 *v19; // ecx
  int v20; // esi
  _BYTE *v21; // eax
  int v22; // ebp
  int v23; // esi
  _BYTE *v24; // eax
  int v25; // esi
  _BYTE *v26; // eax
  int v27; // ebp
  _BYTE *v28; // eax
  int v29; // [esp+4h] [ebp-4h]
  int v30; // [esp+4h] [ebp-4h]
  int v31; // [esp+4h] [ebp-4h]

  v5 = a1;
  v6 = *a1;
  if ( *((_BYTE *)a1 + 8) != 3 )
    return;
  v7 = *((_BYTE *)a1 + 9);
  if ( v7 < 8u )
  {
    v8 = v7 - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        if ( v9 != 2 )
          goto LABEL_27;
        v10 = (_BYTE *)(a2 + ((unsigned int)(v6 - 1) >> 1));
        v11 = 4 * (*a1 & 1);
        v12 = (_BYTE *)(v6 + a2 - 1);
        if ( !v6 )
          goto LABEL_27;
        v29 = *a1;
        do
        {
          *v12 = (*v10 >> v11) & 0xF;
          if ( v11 == 4 )
          {
            v11 = 0;
            --v10;
          }
          else
          {
            v11 += 4;
          }
          --v12;
          --v29;
        }
        while ( v29 );
        goto LABEL_26;
      }
      v13 = (_BYTE *)(a2 + ((unsigned int)(v6 - 1) >> 2));
      v14 = 2 * (3 - (((_BYTE)v6 - 1) & 3));
      v15 = (_BYTE *)(v6 + a2 - 1);
      if ( v6 )
      {
        v30 = *a1;
        do
        {
          *v15 = (*v13 >> v14) & 3;
          if ( v14 == 6 )
          {
            v14 = 0;
            --v13;
          }
          else
          {
            v14 += 2;
          }
          --v15;
          --v30;
        }
        while ( v30 );
LABEL_26:
        v5 = a1;
        goto LABEL_27;
      }
    }
    else
    {
      v16 = (_BYTE *)(a2 + ((unsigned int)(v6 - 1) >> 3));
      v17 = 7 - (((_BYTE)v6 - 1) & 7);
      v18 = (_BYTE *)(v6 + a2 - 1);
      if ( v6 )
      {
        v31 = *a1;
        do
        {
          *v18 = (*v16 >> v17) & 1;
          if ( v17 == 7 )
          {
            v17 = 0;
            --v16;
          }
          else
          {
            ++v17;
          }
          --v18;
          --v31;
        }
        while ( v31 );
        goto LABEL_26;
      }
    }
LABEL_27:
    *((_BYTE *)v5 + 9) = 8;
    *((_BYTE *)v5 + 11) = 8;
    v5[1] = v6;
  }
  if ( *((_BYTE *)v5 + 9) == 8 )
  {
    v19 = (unsigned __int8 *)(v6 + a2 - 1);
    if ( a4 )
    {
      v20 = 4 * v6;
      v21 = (_BYTE *)(4 * v6 + a2 - 1);
      if ( v6 )
      {
        v22 = v6;
        do
        {
          v23 = *v19;
          if ( v23 < a5 )
            *v21 = *(_BYTE *)(v23 + a4);
          else
            *v21 = -1;
          *(v21 - 1) = *(_BYTE *)(*v19 + a3 + 2 * *v19 + 2);
          v24 = v21 - 2;
          *v24-- = *(_BYTE *)(*v19 + a3 + 2 * *v19 + 1);
          *v24 = *(_BYTE *)(*v19 + a3 + 2 * *v19);
          v21 = v24 - 1;
          --v19;
          --v22;
        }
        while ( v22 );
        v5 = a1;
        v20 = 4 * v6;
      }
      v5[1] = v20;
      *((_BYTE *)v5 + 11) = 32;
      *((_BYTE *)v5 + 8) = 6;
      *((_BYTE *)v5 + 10) = 4;
      *((_BYTE *)v5 + 9) = 8;
    }
    else
    {
      v25 = 3 * v6;
      v26 = (_BYTE *)(3 * v6 + a2 - 1);
      if ( v6 )
      {
        v27 = v6;
        do
        {
          *v26 = *(_BYTE *)(*v19 + a3 + 2 * *v19 + 2);
          v28 = v26 - 1;
          *v28-- = *(_BYTE *)(*v19 + a3 + 2 * *v19 + 1);
          *v28 = *(_BYTE *)(*v19 + a3 + 2 * *v19);
          v26 = v28 - 1;
          --v19;
          --v27;
        }
        while ( v27 );
        v5 = a1;
        v25 = 3 * v6;
      }
      *((_BYTE *)v5 + 11) = 24;
      *((_BYTE *)v5 + 8) = 2;
      *((_BYTE *)v5 + 10) = 3;
      v5[1] = v25;
      *((_BYTE *)v5 + 9) = 8;
    }
  }
}

//----- (0040EBF0) --------------------------------------------------------
char __cdecl sub_40EBF0(int *a1, int a2, _WORD *a3)
{
  int *v3; // edx
  int v4; // eax
  int v5; // esi
  _WORD *v6; // ecx
  unsigned __int16 v7; // di
  int v8; // eax
  int v9; // eax
  unsigned __int16 v10; // cx
  unsigned __int8 *v11; // edi
  int v12; // edx
  _BYTE *v13; // ebp
  unsigned __int8 *v14; // edi
  int v15; // edx
  _BYTE *v16; // ebp
  _BYTE *v17; // edi
  _BYTE *v18; // ebp
  char v19; // al
  _BYTE *v20; // ecx
  _BYTE *v21; // eax
  int v22; // ebp
  _BYTE *v23; // eax
  char v24; // al
  int v25; // eax
  _BYTE *v26; // ecx
  _BYTE *v27; // eax
  int v28; // ebp
  int v29; // edi
  unsigned __int16 v30; // bx
  _BYTE *v31; // eax
  _BYTE *v32; // eax
  char v33; // al
  _BYTE *v34; // ecx
  _BYTE *v35; // eax
  int v36; // edi
  _BYTE *v37; // eax
  char v38; // bl
  _BYTE *v39; // ecx
  _BYTE *v40; // ecx
  _BYTE *v41; // eax
  int v42; // edi
  __int16 v43; // dx
  __int16 v44; // dx
  __int16 v45; // dx
  _BYTE *v46; // eax
  char v47; // dl
  _BYTE *v48; // eax
  _BYTE *v49; // ecx
  char v50; // dl
  char v51; // dl
  char v52; // dl
  char v53; // al
  unsigned __int8 v54; // al
  unsigned __int16 v56; // [esp+10h] [ebp-8h]
  int v57; // [esp+14h] [ebp-4h]
  int v58; // [esp+14h] [ebp-4h]
  int v59; // [esp+14h] [ebp-4h]

  v3 = a1;
  LOBYTE(v4) = *((_BYTE *)a1 + 8);
  v5 = *a1;
  if ( (_BYTE)v4 )
  {
    if ( (_BYTE)v4 != 2 || !a3 )
      return v4;
    v33 = *((_BYTE *)a1 + 9);
    if ( v33 == 8 )
    {
      v34 = (_BYTE *)(a1[1] + a2 - 1);
      v35 = (_BYTE *)(a2 + 4 * v5 - 1);
      if ( v5 )
      {
        v36 = *a1;
        do
        {
          if ( (unsigned __int8)*(v34 - 2) == a3[1]
            && (unsigned __int8)*(v34 - 1) == a3[2]
            && (unsigned __int8)*v34 == a3[3] )
          {
            *v35 = 0;
          }
          else
          {
            *v35 = -1;
          }
          v37 = v35 - 1;
          *v37 = *v34;
          v38 = *(v34 - 1);
          v39 = v34 - 1;
          *--v37 = v38;
          *--v37 = *(v39 - 1);
          v35 = v37 - 1;
          v34 = v39 - 2;
          --v36;
        }
        while ( v36 );
      }
    }
    else if ( v33 == 16 )
    {
      v40 = (_BYTE *)(a1[1] + a2 - 1);
      v41 = (_BYTE *)(a2 + 8 * v5 - 1);
      if ( v5 )
      {
        v42 = *a1;
        do
        {
          HIBYTE(v43) = *(v40 - 5);
          LOBYTE(v43) = *(v40 - 4);
          if ( v43 == a3[1]
            && (HIBYTE(v44) = *(v40 - 3), LOBYTE(v44) = *(v40 - 2), v44 == a3[2])
            && (HIBYTE(v45) = *(v40 - 1), LOBYTE(v45) = *v40, v45 == a3[3]) )
          {
            *v41 = 0;
            v46 = v41 - 1;
            *v46 = 0;
          }
          else
          {
            *v41 = -1;
            v46 = v41 - 1;
            *v46 = -1;
          }
          *(v46 - 1) = *v40;
          v47 = *(v40 - 1);
          v48 = v46 - 1;
          v49 = v40 - 1;
          *(v48 - 1) = v47;
          v50 = *(v49 - 1);
          --v48;
          --v49;
          *(v48 - 1) = v50;
          v51 = *--v49;
          v48 -= 2;
          *v48 = v51;
          v52 = *--v49;
          *--v48 = v52;
          *--v48 = *(v49 - 1);
          v41 = v48 - 1;
          v40 = v49 - 2;
          --v42;
        }
        while ( v42 );
        v3 = a1;
      }
    }
    v53 = *((_BYTE *)v3 + 9);
    *((_BYTE *)v3 + 8) = 6;
    *((_BYTE *)v3 + 10) = 4;
    v24 = 2 * v53;
    goto LABEL_72;
  }
  v6 = a3;
  if ( a3 )
    v7 = a3[4];
  else
    v7 = 0;
  LOBYTE(v4) = *((_BYTE *)a1 + 9);
  if ( (unsigned __int8)v4 < 8u )
  {
    v8 = (unsigned __int8)v4 - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        v4 = v9 - 2;
        if ( v4 )
        {
LABEL_31:
          v6 = a3;
          *((_BYTE *)v3 + 9) = 8;
          *((_BYTE *)v3 + 11) = 8;
          v3[1] = v5;
          goto LABEL_32;
        }
        v10 = 17 * v7;
        v4 = 4 * (((_BYTE)v5 - 1) & 1);
        v11 = (unsigned __int8 *)(a2 + ((unsigned int)(v5 - 1) >> 1));
        v12 = 4 - v4;
        v56 = v10;
        v13 = (_BYTE *)(v5 + a2 - 1);
        if ( v5 )
        {
          v57 = *a1;
          do
          {
            v4 = (*v11 >> v12) & 0xF;
            *v13 = v4 | (16 * ((*v11 >> v12) & 0xF));
            if ( v12 == 4 )
            {
              v12 = 0;
              --v11;
            }
            else
            {
              v12 = 4;
            }
            --v13;
            --v57;
          }
          while ( v57 );
        }
      }
      else
      {
        v56 = 85 * v7;
        v4 = ((_BYTE)v5 - 1) & 3;
        v14 = (unsigned __int8 *)(a2 + ((unsigned int)(v5 - 1) >> 2));
        v15 = 2 * (3 - v4);
        v16 = (_BYTE *)(v5 + a2 - 1);
        if ( v5 )
        {
          v58 = *a1;
          do
          {
            v4 = (*v14 >> v15) & 3;
            *v16 = v4 | (4 * (v4 | (4 * (v4 | (4 * ((*v14 >> v15) & 3))))));
            if ( v15 == 6 )
            {
              v15 = 0;
              --v14;
            }
            else
            {
              v15 += 2;
            }
            --v16;
            --v58;
          }
          while ( v58 );
        }
      }
    }
    else
    {
      v56 = 255 * v7;
      v17 = (_BYTE *)(a2 + ((unsigned int)(v5 - 1) >> 3));
      v4 = 7 - (((_BYTE)v5 - 1) & 7);
      v18 = (_BYTE *)(v5 + a2 - 1);
      if ( !v5 )
      {
LABEL_30:
        v7 = v56;
        goto LABEL_31;
      }
      v59 = *a1;
      do
      {
        *v18 = -(((*v17 >> v4) & 1) != 0);
        if ( v4 == 7 )
        {
          v4 = 0;
          --v17;
        }
        else
        {
          ++v4;
        }
        --v18;
        --v59;
      }
      while ( v59 );
    }
    v3 = a1;
    goto LABEL_30;
  }
LABEL_32:
  if ( !v6 )
    return v4;
  v19 = *((_BYTE *)v3 + 9);
  if ( v19 == 8 )
  {
    v20 = (_BYTE *)(v5 + a2 - 1);
    v21 = (_BYTE *)(a2 + 2 * v5 - 1);
    if ( v5 )
    {
      v22 = v5;
      do
      {
        if ( (unsigned __int8)*v20 == v7 )
          *v21 = 0;
        else
          *v21 = -1;
        v23 = v21 - 1;
        *v23 = *v20;
        v21 = v23 - 1;
        --v20;
        --v22;
      }
      while ( v22 );
      v24 = *((_BYTE *)v3 + 9);
      *((_BYTE *)v3 + 8) = 4;
      *((_BYTE *)v3 + 10) = 2;
      goto LABEL_72;
    }
  }
  else if ( v19 == 16 )
  {
    v25 = v3[1];
    v26 = (_BYTE *)(v25 + a2 - 1);
    v27 = (_BYTE *)(a2 + 2 * v25 - 1);
    if ( v5 )
    {
      v28 = v7;
      v29 = v5;
      do
      {
        HIBYTE(v30) = *(v26 - 1);
        LOBYTE(v30) = *v26;
        if ( v30 == v28 )
        {
          *v27 = 0;
          v31 = v27 - 1;
          *v31 = 0;
        }
        else
        {
          *v27 = -1;
          v31 = v27 - 1;
          *v31 = -1;
        }
        v32 = v31 - 1;
        *v32-- = *v26;
        *v32 = *(v26 - 1);
        v27 = v32 - 1;
        v26 -= 2;
        --v29;
      }
      while ( v29 );
    }
  }
  v24 = *((_BYTE *)v3 + 9);
  *((_BYTE *)v3 + 8) = 4;
  *((_BYTE *)v3 + 10) = 2;
LABEL_72:
  v54 = 2 * v24;
  *((_BYTE *)v3 + 11) = v54;
  if ( v54 < 8u )
    v4 = (v5 * (unsigned int)v54 + 7) >> 3;
  else
    v4 = v5 * (v54 >> 3);
  v3[1] = v4;
  return v4;
}

//----- (0040EFF0) --------------------------------------------------------
char __cdecl sub_40EFF0(int *a1, char *a2, int a3, int a4)
{
  int *v4; // edx
  unsigned int i; // eax
  int v6; // ebx
  char *v7; // ecx
  char *v8; // edi
  char v9; // al
  char v10; // si
  _BYTE *v11; // ecx
  int v12; // eax
  char *v13; // ecx
  char *v14; // edi
  char v15; // al
  char v16; // si
  _BYTE *v17; // ecx
  int v19; // [esp+10h] [ebp-4h]

  v4 = a1;
  LOBYTE(i) = *((_BYTE *)a1 + 8);
  v6 = *a1;
  v19 = *a1;
  if ( (_BYTE)i == 2 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v7 = a2;
    v8 = a2;
    if ( v6 )
    {
      do
      {
        v9 = *v7;
        v10 = v7[1];
        v11 = v7 + 1;
        *v8 = *(_BYTE *)((((int)(unsigned __int8)v11[1] >> 3) & 0x1F | (4 * (v10 & 0xF8 | (32 * (v9 & 0xF8))))) + a3);
        v7 = v11 + 2;
        ++v8;
        --v6;
      }
      while ( v6 );
      v6 = v19;
      v4 = a1;
    }
    LOBYTE(v12) = *((_BYTE *)v4 + 9);
    *((_BYTE *)v4 + 11) = v12;
    *((_BYTE *)v4 + 8) = 3;
    *((_BYTE *)v4 + 10) = 1;
    v12 = (unsigned __int8)v12;
    if ( (unsigned __int8)v12 >= 8u )
    {
      i = v6 * ((unsigned __int8)v12 >> 3);
      v4[1] = i;
      return i;
    }
LABEL_17:
    i = (unsigned int)(v6 * v12 + 7) >> 3;
    v4[1] = i;
    return i;
  }
  if ( (_BYTE)i == 6 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v13 = a2;
    v14 = a2;
    if ( v6 )
    {
      do
      {
        v15 = *v13;
        v16 = v13[1];
        v17 = v13 + 1;
        *v14 = *(_BYTE *)((((int)(unsigned __int8)v17[1] >> 3) & 0x1F | (4 * (v16 & 0xF8 | (32 * (v15 & 0xF8))))) + a3);
        v13 = v17 + 3;
        ++v14;
        --v6;
      }
      while ( v6 );
      v6 = v19;
      v4 = a1;
    }
    LOBYTE(v12) = *((_BYTE *)v4 + 9);
    *((_BYTE *)v4 + 11) = v12;
    *((_BYTE *)v4 + 8) = 3;
    *((_BYTE *)v4 + 10) = 1;
    v12 = (unsigned __int8)v12;
    if ( (unsigned __int8)v12 >= 8u )
    {
      i = v6 * ((unsigned __int8)v12 >> 3);
      v4[1] = i;
      return i;
    }
    goto LABEL_17;
  }
  if ( (_BYTE)i == 3 )
  {
    if ( a4 )
    {
      if ( *((_BYTE *)a1 + 9) == 8 )
      {
        for ( i = (unsigned int)a2; v6; --v6 )
        {
          *(_BYTE *)i = *(_BYTE *)(*(unsigned __int8 *)i + a4);
          ++i;
        }
      }
    }
  }
  return i;
}

//----- (0040F160) --------------------------------------------------------
void __cdecl sub_40F160(int a1)
{
  double v1; // st7
  double v2; // st7
  double v3; // st7
  int v4; // edi
  long double v5; // st6
  double v6; // st7
  int v7; // edi
  long double v8; // st6
  void *v9; // eax
  double v10; // st7
  double v11; // st7
  int v12; // edi
  double v13; // st7
  long double v14; // st6
  int v15; // ecx
  int v16; // edi
  int v17; // eax
  double v18; // st7
  int v19; // ebx
  double v20; // st7
  void *v21; // eax
  bool v22; // zf
  unsigned int v23; // edi
  double v24; // st7
  long double v25; // st7
  __int16 v26; // cx
  int i; // eax
  unsigned int v28; // ebx
  int v29; // eax
  int j; // eax
  int v31; // eax
  unsigned int v32; // ebx
  double v33; // st7
  unsigned int v34; // eax
  int v35; // edi
  unsigned int v36; // ebx
  long double v37; // st6
  int v38; // eax
  void *v39; // eax
  int v40; // ebx
  double v41; // st7
  int v42; // edi
  long double v43; // st7
  long double v44; // st6
  double v45; // st7
  double v46; // st7
  int v47; // ebx
  double v48; // st7
  int v49; // edi
  long double v50; // st7
  long double v51; // st6
  int v52; // [esp+10h] [ebp-30h]
  int v53; // [esp+14h] [ebp-2Ch]
  int v54; // [esp+14h] [ebp-2Ch]
  unsigned int v55; // [esp+14h] [ebp-2Ch]
  unsigned int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+18h] [ebp-28h]
  int v58; // [esp+18h] [ebp-28h]
  int v59; // [esp+18h] [ebp-28h]
  int v60; // [esp+18h] [ebp-28h]
  char v61; // [esp+1Ch] [ebp-24h]
  unsigned int v62; // [esp+20h] [ebp-20h]
  double v63; // [esp+30h] [ebp-10h]
  double v64; // [esp+30h] [ebp-10h]
  double v65; // [esp+30h] [ebp-10h]
  double v66; // [esp+30h] [ebp-10h]
  double v67; // [esp+30h] [ebp-10h]
  double v68; // [esp+30h] [ebp-10h]
  double v69; // [esp+30h] [ebp-10h]
  double v70; // [esp+38h] [ebp-8h]

  if ( 0.0 == *(float *)(a1 + 348) )
    return;
  if ( *(_BYTE *)(a1 + 295) <= 8u )
  {
    v1 = *(float *)(a1 + 352);
    if ( v1 <= 0.000001 )
      v2 = 1.0;
    else
      v2 = 1.0 / (v1 * *(float *)(a1 + 348));
    v63 = v2;
    v3 = 255.0;
    v4 = 0;
    *(_DWORD *)(a1 + 356) = sub_408BA0(a1, 0x100u);
    v57 = 0;
    do
    {
      v5 = pow((double)v57 / v3, v63) * 255.0;
      v3 = 255.0;
      v57 = ++v4;
      *(_BYTE *)(v4 + *(_DWORD *)(a1 + 356) - 1) = (int)(v5 + 0.5);
    }
    while ( v4 < 256 );
    if ( (*(_DWORD *)(a1 + 112) & 0x600080) != 0 )
    {
      v64 = 1.0 / *(float *)(a1 + 348);
      v6 = 255.0;
      v7 = 0;
      *(_DWORD *)(a1 + 364) = sub_408BA0(a1, 0x100u);
      v58 = 0;
      do
      {
        ++v7;
        v8 = pow((double)v58 / v6, v64) * 255.0;
        v6 = 255.0;
        v58 = v7;
        *(_BYTE *)(v7 + *(_DWORD *)(a1 + 364) - 1) = (int)(v8 + 0.5);
      }
      while ( v7 < 256 );
      v9 = sub_408BA0(a1, 0x100u);
      v10 = *(float *)(a1 + 352);
      *(_DWORD *)(a1 + 360) = v9;
      if ( v10 <= 0.000001 )
        v11 = *(float *)(a1 + 348);
      else
        v11 = 1.0 / v10;
      v12 = 0;
      v65 = v11;
      v13 = 255.0;
      v59 = 0;
      do
      {
        v14 = pow((double)v59 / v13, v65) * 255.0;
        v13 = 255.0;
        v59 = ++v12;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 360) - 1) = (int)(v14 + 0.5);
      }
      while ( v12 < 256 );
    }
    return;
  }
  if ( (*(_BYTE *)(a1 + 294) & 2) != 0 )
  {
    v15 = *(unsigned __int8 *)(a1 + 380);
    if ( *(unsigned __int8 *)(a1 + 381) > v15 )
      v15 = *(unsigned __int8 *)(a1 + 381);
    if ( *(unsigned __int8 *)(a1 + 382) > v15 )
      v15 = *(unsigned __int8 *)(a1 + 382);
  }
  else
  {
    v15 = *(unsigned __int8 *)(a1 + 383);
  }
  v16 = 0;
  if ( v15 <= 0 )
  {
    v52 = 0;
    v17 = 0;
  }
  else
  {
    v17 = 16 - v15;
    v52 = 16 - v15;
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x400) != 0 && v17 < 5 )
  {
    v52 = 5;
  }
  else if ( v17 <= 8 )
  {
    if ( v17 >= 0 )
      goto LABEL_34;
    v52 = 0;
  }
  else
  {
    v52 = 8;
  }
  LOBYTE(v17) = v52;
LABEL_34:
  v18 = *(float *)(a1 + 352);
  *(_DWORD *)(a1 + 344) = (unsigned __int8)v17;
  v19 = 1 << (8 - v17);
  v61 = 8 - v17;
  v60 = v19;
  if ( v18 <= 0.000001 )
    v20 = 1.0;
  else
    v20 = 1.0 / (v18 * *(float *)(a1 + 348));
  v66 = v20;
  v21 = sub_408BA0(a1, 4 * v19);
  v22 = (*(_DWORD *)(a1 + 112) & 0x480) == 0;
  *(_DWORD *)(a1 + 368) = v21;
  if ( v22 )
  {
    v54 = 0;
    if ( v19 <= 0 )
      goto LABEL_61;
    while ( 1 )
    {
      v33 = 65535.0;
      *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * v16) = sub_408BA0(a1, 0x200u);
      v34 = (unsigned int)(v16 * dword_41C020[v52]) >> 4;
      v35 = 0;
      v36 = v34;
      do
      {
        v37 = pow((double)v36 / v33, v66) * 65535.0;
        v33 = 65535.0;
        v38 = v54;
        v35 += 2;
        v36 += 256;
        *(_WORD *)(v35 + *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * v54) - 2) = (int)(v37 + 0.5);
      }
      while ( v35 < 512 );
      ++v54;
      if ( v38 + 1 >= v60 )
        break;
      v16 = v38 + 1;
    }
  }
  else
  {
    if ( v19 > 0 )
    {
      do
        *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * v16++) = sub_408BA0(a1, 0x200u);
      while ( v16 < v19 );
    }
    v23 = 0;
    v53 = 0;
    v62 = v19 << 8;
    v67 = 1.0 / v20;
    v24 = (double)(v19 << 8);
    if ( (v19 & 0x800000) != 0 )
      v24 = v24 + 4294967296.0;
    v70 = v24;
    do
    {
      v25 = pow(((double)v53 + 0.5) * 0.00390625, v67) * v70;
      if ( v23 <= (unsigned int)(__int64)v25 )
      {
        LOBYTE(v26) = 0;
        HIBYTE(v26) = v53;
        for ( i = 255 >> v52; ; i = 255 >> v52 )
        {
          v28 = v23 >> v61;
          v29 = *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * (v23++ & i));
          *(_WORD *)(v29 + 2 * v28) = v53 | v26;
          if ( v23 > (unsigned int)(__int64)v25 )
            break;
        }
        v19 = v60;
      }
      ++v53;
    }
    while ( v53 < 256 );
    if ( v23 >= v62 )
      goto LABEL_61;
    for ( j = 255 >> v52; ; j = 255 >> v52 )
    {
      v31 = *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * (v23 & j));
      v32 = v23++ >> v61;
      *(_WORD *)(v31 + 2 * v32) = -1;
      if ( v23 >= v62 )
        break;
    }
  }
  v19 = v60;
LABEL_61:
  if ( (*(_DWORD *)(a1 + 112) & 0x600080) != 0 )
  {
    v68 = 1.0 / *(float *)(a1 + 348);
    v39 = sub_408BA0(a1, 4 * v19);
    v40 = 0;
    for ( *(_DWORD *)(a1 + 376) = v39; v40 < v60; ++v40 )
    {
      v41 = 65535.0;
      *(_DWORD *)(*(_DWORD *)(a1 + 376) + 4 * v40) = sub_408BA0(a1, 0x200u);
      v42 = 0;
      v55 = (unsigned int)(v40 * dword_41C020[v52]) >> 4;
      do
      {
        v43 = pow((double)v55 / v41, v68);
        v55 += 256;
        v44 = v43 * 65535.0;
        v41 = 65535.0;
        v42 += 2;
        *(_WORD *)(v42 + *(_DWORD *)(*(_DWORD *)(a1 + 376) + 4 * v40) - 2) = (int)(v44 + 0.5);
      }
      while ( v42 < 512 );
    }
    v45 = *(float *)(a1 + 352);
    if ( v45 <= 0.000001 )
      v46 = *(float *)(a1 + 348);
    else
      v46 = 1.0 / v45;
    v69 = v46;
    v47 = 0;
    for ( *(_DWORD *)(a1 + 372) = sub_408BA0(a1, 4 * v60); v47 < v60; ++v47 )
    {
      v48 = 65535.0;
      *(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * v47) = sub_408BA0(a1, 0x200u);
      v49 = 0;
      v56 = (unsigned int)(v47 * dword_41C020[v52]) >> 4;
      do
      {
        v50 = pow((double)v56 / v48, v69);
        v56 += 256;
        v51 = v50 * 65535.0;
        v48 = 65535.0;
        v49 += 2;
        *(_WORD *)(v49 + *(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * v47) - 2) = (int)(v51 + 0.5);
      }
      while ( v49 < 512 );
    }
  }
}

//----- (0040F880) --------------------------------------------------------
char __cdecl sub_40F880(int *a1, int a2)
{
  _BYTE *v2; // eax
  char v3; // cl
  int v4; // edx
  int v5; // edi
  char v6; // cl
  int v7; // edi
  int v8; // esi
  __int16 v9; // bx
  __int16 v10; // cx
  __int16 v11; // dx
  __int16 v12; // dx
  __int16 v13; // cx

  LOBYTE(v2) = (_BYTE)a1;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    LOBYTE(v2) = *((_BYTE *)a1 + 9);
    if ( (_BYTE)v2 == 8 )
    {
      if ( v3 == 2 )
      {
        v5 = 3;
      }
      else
      {
        if ( v3 != 6 )
          return (char)v2;
        v5 = 4;
      }
      if ( v4 )
      {
        v2 = (_BYTE *)(a2 + 2);
        do
        {
          v6 = *(v2 - 1);
          *(v2 - 2) += v6;
          *v2 += v6;
          v2 += v5;
          --v4;
        }
        while ( v4 );
      }
    }
    else if ( (_BYTE)v2 == 16 )
    {
      if ( v3 == 2 )
      {
        v7 = 6;
      }
      else
      {
        if ( v3 != 6 )
          return (char)v2;
        v7 = 8;
      }
      if ( v4 )
      {
        v2 = (_BYTE *)(a2 + 1);
        v8 = *a1;
        do
        {
          HIBYTE(v9) = v2[3];
          HIBYTE(v10) = v2[1];
          HIBYTE(v11) = *(v2 - 1);
          LOBYTE(v9) = v2[4];
          LOBYTE(v10) = v2[2];
          LOBYTE(v11) = *v2;
          v12 = v10 + v11;
          v13 = v10 + v9;
          *v2 = v12;
          *(v2 - 1) = HIBYTE(v12);
          v2[3] = HIBYTE(v13);
          v2[4] = v13;
          v2 += v7;
          --v8;
        }
        while ( v8 );
      }
    }
  }
  return (char)v2;
}

//----- (0040F950) --------------------------------------------------------
void __cdecl sub_40F950(int a1)
{
  int v2; // ebx
  __int16 v3; // ax
  unsigned __int8 *v4; // eax
  int v5; // edx
  __int16 v6; // ax
  int v7; // ebp
  int v8; // ecx
  char v9; // al
  int v10; // eax
  int v11; // ebp
  unsigned __int8 v12; // al
  int v13; // ecx
  int v14; // eax
  int v15; // edi
  int v16; // edx
  int v17; // eax
  unsigned __int8 v18; // bl
  int v19; // eax
  int v20; // eax
  double v21; // st7
  double v22; // st7
  double v23; // st6
  long double v24; // rt1
  long double v25; // st6
  long double v26; // st7
  double v27; // st7
  char v28; // dl
  int v29; // edi
  _BYTE *v30; // eax
  int v31; // ecx
  char v32; // dl
  unsigned __int8 *v33; // ecx
  char v34; // cl
  unsigned int v35; // ecx
  unsigned int v36; // ecx
  unsigned int v37; // ecx
  int v38; // ecx
  int v39; // edx
  double v40; // st7
  long double v41; // st6
  double v42; // st6
  double v43; // st5
  double v44; // st4
  unsigned __int16 v45; // di
  unsigned __int16 v46; // cx
  __int16 v47; // ax
  __int16 v48; // cx
  int v49; // ecx
  int v50; // ecx
  _BYTE *v51; // eax
  int v52; // ebp
  int v53; // edi
  unsigned __int8 v54; // dl
  unsigned __int8 *v55; // eax
  int v56; // ecx
  char v57; // bl
  unsigned __int8 *v58; // ecx
  unsigned int v59; // ecx
  unsigned int v60; // ecx
  unsigned int v61; // ecx
  unsigned __int16 v62; // dx
  int v63; // ebx
  int v64; // eax
  int v65; // ecx
  int v66; // eax
  int v67; // edi
  __int16 v68; // [esp+Ch] [ebp-3Ch]
  char v69; // [esp+Eh] [ebp-3Ah]
  double v70; // [esp+10h] [ebp-38h]
  unsigned __int8 v71; // [esp+11h] [ebp-37h]
  unsigned __int8 v72; // [esp+12h] [ebp-36h]
  int v73; // [esp+18h] [ebp-30h]
  char v74; // [esp+18h] [ebp-30h]
  double v75; // [esp+1Ch] [ebp-2Ch]
  int v76; // [esp+24h] [ebp-24h]
  int v77; // [esp+24h] [ebp-24h]
  double v78; // [esp+28h] [ebp-20h]
  double v79; // [esp+28h] [ebp-20h]
  long double v80; // [esp+30h] [ebp-18h]
  long double v81; // [esp+30h] [ebp-18h]
  long double v82; // [esp+38h] [ebp-10h]
  long double v83; // [esp+40h] [ebp-8h]
  int v84; // [esp+4Ch] [ebp+4h]
  __int16 v85; // [esp+4Ch] [ebp+4h]
  char v86; // [esp+4Ch] [ebp+4h]

  v2 = *(unsigned __int8 *)(a1 + 294);
  v73 = v2;
  v84 = *(_DWORD *)(a1 + 112);
  if ( (v84 & 0x100) != 0 && (v84 & 0x1000) != 0 )
  {
    if ( (v2 & 2) == 0 )
    {
      switch ( *(_BYTE *)(a1 + 295) )
      {
        case 1:
          v3 = 255 * *(_WORD *)(a1 + 320);
          goto LABEL_6;
        case 2:
          v3 = 85 * *(_WORD *)(a1 + 320);
          goto LABEL_6;
        case 4:
          v3 = 17 * *(_WORD *)(a1 + 320);
LABEL_6:
          *(_WORD *)(a1 + 320) = v3;
          *(_WORD *)(a1 + 316) = v3;
          *(_WORD *)(a1 + 314) = v3;
          goto LABEL_12;
        case 8:
        case 0x10:
          v3 = *(_WORD *)(a1 + 320);
          *(_WORD *)(a1 + 316) = v3;
          *(_WORD *)(a1 + 314) = v3;
          goto LABEL_12;
        default:
          goto LABEL_13;
      }
    }
    if ( v2 == 3 )
    {
      v4 = (unsigned __int8 *)(3 * *(unsigned __int8 *)(a1 + 312) + *(_DWORD *)(a1 + 276));
      *(_WORD *)(a1 + 314) = *v4;
      *(_WORD *)(a1 + 316) = v4[1];
      v3 = v4[2];
LABEL_12:
      *(_WORD *)(a1 + 318) = v3;
    }
  }
LABEL_13:
  v5 = *(_DWORD *)(a1 + 316);
  v6 = *(_WORD *)(a1 + 320);
  *(_DWORD *)(a1 + 322) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 326) = v5;
  *(_WORD *)(a1 + 330) = v6;
  if ( v2 == 3 && *(_WORD *)(a1 + 282) && fabs(*(float *)(a1 + 352) * *(float *)(a1 + 348) - 1.0) < 0.05 )
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *(_BYTE *)(*(_DWORD *)(a1 + 392) + v8);
      if ( v9 && v9 != -1 )
        v7 = 1;
      ++v8;
    }
    while ( v8 < *(unsigned __int16 *)(a1 + 282) );
    if ( !v7 )
      *(_DWORD *)(a1 + 112) = v84 & 0xFFFFDFFF;
  }
  v10 = *(_DWORD *)(a1 + 112);
  if ( (v10 & 0x602000) != 0 )
  {
    sub_40F160(a1);
    if ( *(char *)(a1 + 112) < 0 )
    {
      if ( v2 == 3 )
      {
        v11 = *(unsigned __int16 *)(a1 + 280);
        v12 = *(_BYTE *)(a1 + 304);
        v76 = v11;
        if ( v12 == 2 )
        {
          v13 = *(unsigned __int16 *)(a1 + 314);
          v14 = *(_DWORD *)(a1 + 356);
          v15 = *(unsigned __int16 *)(a1 + 316);
          LOBYTE(v68) = *(_BYTE *)(v14 + v13);
          HIBYTE(v68) = *(_BYTE *)(v15 + v14);
          v16 = *(unsigned __int16 *)(a1 + 318);
          v69 = *(_BYTE *)(v16 + v14);
          v17 = *(_DWORD *)(a1 + 364);
          v18 = *(_BYTE *)(v17 + v13);
          v71 = *(_BYTE *)(v17 + v15);
          v72 = *(_BYTE *)(v17 + v16);
          goto LABEL_41;
        }
        v19 = v12 - 1;
        if ( v19 )
        {
          v20 = v19 - 1;
          if ( v20 )
          {
            if ( v20 != 1 )
            {
              v21 = 1.0;
              v75 = 1.0;
LABEL_36:
              v23 = v21;
              goto LABEL_37;
            }
            v22 = *(float *)(a1 + 308);
          }
          else
          {
            v22 = *(float *)(a1 + 348);
          }
          v75 = 1.0 / v22;
          v23 = 1.0 / (v22 * *(float *)(a1 + 352));
          v21 = 1.0;
LABEL_37:
          v78 = v23;
          v24 = v23;
          v25 = v23 - v21;
          v26 = v24;
          if ( fabs(v25) >= 0.05 )
          {
            LOBYTE(v68) = (int)(pow((double)*(unsigned __int16 *)(a1 + 314) / 255.0, v26) * 255.0 + 0.5);
            HIBYTE(v68) = (int)(pow((double)*(unsigned __int16 *)(a1 + 316) / 255.0, v78) * 255.0 + 0.5);
            v27 = 255.0;
            v28 = (int)(pow((double)*(unsigned __int16 *)(a1 + 318) / 255.0, v78) * 255.0 + 0.5);
          }
          else
          {
            v27 = 255.0;
            v28 = *(_BYTE *)(a1 + 318);
            LOBYTE(v68) = *(_BYTE *)(a1 + 314);
            HIBYTE(v68) = *(_BYTE *)(a1 + 316);
          }
          v69 = v28;
          v18 = (int)(pow((double)*(unsigned __int16 *)(a1 + 314) / v27, v75) * 255.0 + 0.5);
          v71 = (int)(pow((double)*(unsigned __int16 *)(a1 + 316) / 255.0, v75) * 255.0 + 0.5);
          v72 = (int)(pow((double)*(unsigned __int16 *)(a1 + 318) / 255.0, v75) * 255.0 + 0.5);
LABEL_41:
          v29 = 0;
          if ( *(_WORD *)(a1 + 280) )
          {
            v30 = (_BYTE *)(*(_DWORD *)(a1 + 276) + 2);
            do
            {
              if ( v29 >= *(unsigned __int16 *)(a1 + 282)
                || (v31 = *(_DWORD *)(a1 + 392),
                    v32 = *(_BYTE *)(v31 + v29),
                    v33 = (unsigned __int8 *)(v29 + v31),
                    v32 == -1) )
              {
                v38 = (unsigned __int8)*(v30 - 1);
                *(v30 - 2) = *(_BYTE *)((unsigned __int8)*(v30 - 2) + *(_DWORD *)(a1 + 356));
                v39 = (unsigned __int8)*v30;
                *(v30 - 1) = *(_BYTE *)(v38 + *(_DWORD *)(a1 + 356));
                *v30 = *(_BYTE *)(v39 + *(_DWORD *)(a1 + 356));
              }
              else
              {
                if ( v32 )
                {
                  v35 = (unsigned __int16)(v18 * (255 - *v33)
                                         + *v33
                                         * *(unsigned __int8 *)((unsigned __int8)*(v30 - 2) + *(_DWORD *)(a1 + 364))
                                         + 128);
                  *(v30 - 2) = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v35 + (v35 >> 8)) >> 8)
                                        + *(_DWORD *)(a1 + 360));
                  LOWORD(v35) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v29);
                  v36 = (unsigned __int16)(v71 * (255 - v35)
                                         + v35
                                         * *(unsigned __int8 *)((unsigned __int8)*(v30 - 1) + *(_DWORD *)(a1 + 364))
                                         + 128);
                  *(v30 - 1) = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v36 + (v36 >> 8)) >> 8)
                                        + *(_DWORD *)(a1 + 360));
                  LOWORD(v36) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v29);
                  v11 = v76;
                  v37 = (unsigned __int16)(v72 * (255 - v36)
                                         + v36 * *(unsigned __int8 *)((unsigned __int8)*v30 + *(_DWORD *)(a1 + 364))
                                         + 128);
                  v34 = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v37 + (v37 >> 8)) >> 8) + *(_DWORD *)(a1 + 360));
                }
                else
                {
                  v34 = v69;
                  *((_WORD *)v30 - 1) = v68;
                }
                *v30 = v34;
              }
              ++v29;
              v30 += 3;
            }
            while ( v29 < v11 );
          }
          goto LABEL_78;
        }
        v75 = *(float *)(a1 + 352);
        v21 = 1.0;
        goto LABEL_36;
      }
      v40 = (double)(unsigned int)((1 << *(_BYTE *)(a1 + 295)) - 1);
      v79 = 1.0;
      v41 = 1.0;
      v70 = 1.0;
      switch ( *(_BYTE *)(a1 + 304) )
      {
        case 1:
          v79 = *(float *)(a1 + 352);
          v41 = v79;
          v70 = 1.0;
          goto LABEL_59;
        case 2:
          v42 = 1.0;
          v43 = *(float *)(a1 + 348);
          break;
        case 3:
          v42 = 1.0;
          v43 = *(float *)(a1 + 308);
          break;
        default:
LABEL_59:
          v80 = (double)*(unsigned __int16 *)(a1 + 320) / v40;
          *(_WORD *)(a1 + 330) = (int)(pow(v80, v41) * v40 + 0.5);
          v45 = *(_WORD *)(a1 + 316);
          v46 = *(_WORD *)(a1 + 314);
          v47 = (int)(pow(v80, v70) * v40 + 0.5);
          *(_WORD *)(a1 + 320) = v47;
          if ( v46 == v45 && v46 == *(_WORD *)(a1 + 318) && v46 == v47 )
          {
            v48 = *(_WORD *)(a1 + 330);
            *(_WORD *)(a1 + 328) = v48;
            *(_WORD *)(a1 + 326) = v48;
            *(_WORD *)(a1 + 324) = v48;
            *(_WORD *)(a1 + 318) = v47;
            *(_WORD *)(a1 + 316) = v47;
            *(_WORD *)(a1 + 314) = v47;
          }
          else
          {
            v81 = (double)v46 / v40;
            *(_WORD *)(a1 + 324) = (int)(pow(v81, v79) * v40 + 0.5);
            v82 = (double)v45 / v40;
            v49 = *(unsigned __int16 *)(a1 + 318);
            *(_WORD *)(a1 + 326) = (int)(pow(v82, v79) * v40 + 0.5);
            v83 = (double)v49 / v40;
            *(_WORD *)(a1 + 328) = (int)(pow(v83, v79) * v40 + 0.5);
            *(_WORD *)(a1 + 314) = (int)(pow(v81, v70) * v40 + 0.5);
            *(_WORD *)(a1 + 316) = (int)(pow(v82, v70) * v40 + 0.5);
            *(_WORD *)(a1 + 318) = (int)(pow(v83, v70) * v40 + 0.5);
          }
          goto LABEL_78;
      }
      v79 = v42 / v43;
      v44 = v42;
      v41 = v79;
      v70 = v44 / (v43 * *(float *)(a1 + 352));
      goto LABEL_59;
    }
    if ( v2 == 3 )
    {
      v50 = *(unsigned __int16 *)(a1 + 280);
      if ( *(_WORD *)(a1 + 280) )
      {
        v51 = (_BYTE *)(*(_DWORD *)(a1 + 276) + 2);
        do
        {
          *(v51 - 2) = *(_BYTE *)((unsigned __int8)*(v51 - 2) + *(_DWORD *)(a1 + 356));
          *(v51 - 1) = *(_BYTE *)((unsigned __int8)*(v51 - 1) + *(_DWORD *)(a1 + 356));
          *v51 = *(_BYTE *)((unsigned __int8)*v51 + *(_DWORD *)(a1 + 356));
          v51 += 3;
          --v50;
        }
        while ( v50 );
      }
    }
  }
  else if ( (v10 & 0x80u) != 0 && v2 == 3 )
  {
    v52 = *(unsigned __int16 *)(a1 + 282);
    v53 = 0;
    HIBYTE(v85) = *(_BYTE *)(a1 + 316);
    v54 = *(_BYTE *)(a1 + 318);
    v77 = v52;
    LOBYTE(v85) = *(_BYTE *)(a1 + 314);
    if ( *(_WORD *)(a1 + 282) )
    {
      v55 = (unsigned __int8 *)(*(_DWORD *)(a1 + 276) + 2);
      do
      {
        v56 = *(_DWORD *)(a1 + 392);
        v57 = *(_BYTE *)(v56 + v53);
        v58 = (unsigned __int8 *)(v53 + v56);
        if ( v57 )
        {
          if ( v57 != -1 )
          {
            v59 = (unsigned __int16)(*v58 * *(v55 - 2) + (unsigned __int8)v85 * (255 - *v58) + 128);
            *(v55 - 2) = (unsigned __int16)(v59 + (v59 >> 8)) >> 8;
            LOWORD(v59) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v53);
            v60 = (unsigned __int16)(v59 * *(v55 - 1) + HIBYTE(v85) * (255 - v59) + 128);
            *(v55 - 1) = (unsigned __int16)(v60 + (v60 >> 8)) >> 8;
            LOWORD(v60) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v53);
            v52 = v77;
            v61 = (unsigned __int16)(v60 * *v55 + v54 * (255 - v60) + 128);
            *v55 = (unsigned __int16)(v61 + (v61 >> 8)) >> 8;
          }
        }
        else
        {
          *((_WORD *)v55 - 1) = v85;
          *v55 = v54;
        }
        ++v53;
        v55 += 3;
      }
      while ( v53 < v52 );
    }
  }
LABEL_78:
  if ( (*(_BYTE *)(a1 + 112) & 8) != 0 && v73 == 3 )
  {
    v62 = *(_WORD *)(a1 + 280);
    v63 = 8 - *(unsigned __int8 *)(a1 + 380);
    v64 = 8 - *(unsigned __int8 *)(a1 + 381);
    v65 = 8 - *(unsigned __int8 *)(a1 + 382);
    v86 = 8 - *(_BYTE *)(a1 + 381);
    v74 = 8 - *(_BYTE *)(a1 + 382);
    if ( v63 < 0 || v63 > 8 )
      LOBYTE(v63) = 0;
    if ( v64 < 0 || v64 > 8 )
      v86 = 0;
    if ( v65 < 0 || v65 > 8 )
      v74 = 0;
    if ( v62 )
    {
      v66 = 0;
      v67 = v62;
      do
      {
        *(_BYTE *)(v66 + *(_DWORD *)(a1 + 276)) >>= v63;
        *(_BYTE *)(*(_DWORD *)(a1 + 276) + v66 + 1) >>= v86;
        *(_BYTE *)(*(_DWORD *)(a1 + 276) + v66 + 2) >>= v74;
        v66 += 3;
        --v67;
      }
      while ( v67 );
    }
  }
}
// 40FAA0: conditional instruction was optimized away because of 'dx.2!=0'

//----- (00410530) --------------------------------------------------------
void __cdecl sub_410530(int a1)
{
  bool v1; // zf
  int v2; // eax
  void (__cdecl *v3)(int, int, int); // eax
  char v4; // al
  char v5; // al
  unsigned __int8 v6; // al
  unsigned int v7; // eax
  char Buffer[52]; // [esp+4h] [ebp-38h] BYREF

  if ( !*(_DWORD *)(a1 + 236) )
  {
    sprintf(Buffer, "NULL row buffer for row %ld, pass %d", *(_DWORD *)(a1 + 228), *(unsigned __int8 *)(a1 + 292));
    sub_408740((int *)a1, Buffer);
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x1000) != 0 )
  {
    if ( *(_BYTE *)(a1 + 264) == 3 )
    {
      sub_40E9A0(
        (int *)(a1 + 256),
        *(_DWORD *)(a1 + 236) + 1,
        *(_DWORD *)(a1 + 276),
        *(_DWORD *)(a1 + 392),
        *(unsigned __int16 *)(a1 + 282));
    }
    else if ( *(_WORD *)(a1 + 282) )
    {
      sub_40EBF0((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1, (_WORD *)(a1 + 396));
    }
    else
    {
      sub_40EBF0((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1, 0);
    }
  }
  if ( (*(_DWORD *)(a1 + 108) & 0x400000) != 0 )
    sub_410B20(a1 + 256, (_BYTE *)(*(_DWORD *)(a1 + 236) + 1), *(_DWORD *)(a1 + 108) & 0x400000 | 0x80);
  if ( (*(_DWORD *)(a1 + 112) & 0x600000) != 0
    && sub_40CEE0(a1, (int *)(a1 + 256), (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1)) )
  {
    v1 = *(_DWORD *)(a1 + 112) == 0x400000;
    *(_BYTE *)(a1 + 552) = 1;
    if ( v1 )
      sub_4087F0(a1, "png_do_rgb_to_gray found nongray pixel");
    if ( *(_DWORD *)(a1 + 112) == 0x200000 )
      sub_408740((int *)a1, "png_do_rgb_to_gray found nongray pixel");
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x4000) != 0 && (*(_DWORD *)(a1 + 104) & 0x800) == 0 )
    sub_40CD20((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( *(char *)(a1 + 112) < 0 && (*(_WORD *)(a1 + 282) || (*(_BYTE *)(a1 + 294) & 4) != 0) )
    sub_40D5E0(
      (int *)(a1 + 256),
      (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1),
      (_WORD *)(a1 + 396),
      (_BYTE *)(a1 + 312),
      (_WORD *)(a1 + 322),
      *(_DWORD *)(a1 + 356),
      *(_DWORD *)(a1 + 360),
      *(_DWORD *)(a1 + 364),
      *(_DWORD *)(a1 + 368),
      *(_DWORD *)(a1 + 372),
      *(_DWORD *)(a1 + 376),
      *(_DWORD *)(a1 + 344));
  v2 = *(_DWORD *)(a1 + 112);
  if ( (v2 & 0x2000) != 0
    && ((v2 & 0x80u) == 0 || !*(_WORD *)(a1 + 282) && (*(_BYTE *)(a1 + 294) & 4) == 0)
    && *(_BYTE *)(a1 + 294) != 3 )
  {
    sub_40E5E0(
      (int *)(a1 + 256),
      (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1),
      *(_DWORD *)(a1 + 356),
      *(_DWORD *)(a1 + 368),
      *(_DWORD *)(a1 + 344));
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x400) != 0 )
    sub_40C750(a1 + 256, (_BYTE *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_BYTE *)(a1 + 112) & 0x40) != 0 )
  {
    sub_40EFF0((int *)(a1 + 256), (char *)(*(_DWORD *)(a1 + 236) + 1), *(_DWORD *)(a1 + 492), *(_DWORD *)(a1 + 496));
    if ( !*(_DWORD *)(a1 + 260) )
      sub_408740((int *)a1, "png_do_dither returned rowbytes=0");
  }
  if ( (*(_BYTE *)(a1 + 112) & 0x20) != 0 )
    sub_4109F0(a1 + 256, (_BYTE *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_BYTE *)(a1 + 112) & 8) != 0 )
    sub_40C570((int *)(a1 + 256), (_BYTE *)(*(_DWORD *)(a1 + 236) + 1), (unsigned __int8 *)(a1 + 385));
  if ( (*(_BYTE *)(a1 + 112) & 4) != 0 )
    sub_40C430((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (*(_BYTE *)(a1 + 112) & 1) != 0 )
    sub_410DD0((int *)(a1 + 256), (char *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
    sub_410AC0(a1 + 256, (_BYTE *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_DWORD *)(a1 + 112) & 0x4000) != 0 && (*(_DWORD *)(a1 + 104) & 0x800) != 0 )
    sub_40CD20((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (*(_DWORD *)(a1 + 112) & 0x8000) != 0 )
    sub_40CA00(a1 + 256, *(_DWORD *)(a1 + 236) + 1, *(unsigned __int16 *)(a1 + 302), *(_DWORD *)(a1 + 108));
  if ( (*(_DWORD *)(a1 + 112) & 0x80000) != 0 )
    sub_40C920((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (*(_DWORD *)(a1 + 112) & 0x20000) != 0 )
    sub_40C7A0((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (*(_BYTE *)(a1 + 112) & 0x10) != 0 )
    sub_410A80(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_DWORD *)(a1 + 112) & 0x100000) != 0 )
  {
    v3 = *(void (__cdecl **)(int, int, int))(a1 + 88);
    if ( v3 )
      v3(a1, a1 + 256, *(_DWORD *)(a1 + 236) + 1);
    v4 = *(_BYTE *)(a1 + 100);
    if ( v4 )
      *(_BYTE *)(a1 + 265) = v4;
    v5 = *(_BYTE *)(a1 + 101);
    if ( v5 )
      *(_BYTE *)(a1 + 266) = v5;
    v6 = *(_BYTE *)(a1 + 265) * *(_BYTE *)(a1 + 266);
    *(_BYTE *)(a1 + 267) = v6;
    if ( v6 < 8u )
      v7 = (*(_DWORD *)(a1 + 256) * (unsigned int)v6 + 7) >> 3;
    else
      v7 = *(_DWORD *)(a1 + 256) * (v6 >> 3);
    *(_DWORD *)(a1 + 260) = v7;
  }
}

//----- (004109D0) --------------------------------------------------------
int __cdecl sub_4109D0(int a1)
{
  if ( !*(_BYTE *)(a1 + 291) )
    return 1;
  *(_DWORD *)(a1 + 112) |= 2u;
  return 7;
}

//----- (004109F0) --------------------------------------------------------
char __cdecl sub_4109F0(int a1, _BYTE *a2)
{
  _BYTE *i; // eax
  int v3; // ecx
  int v4; // ecx
  unsigned int v5; // ecx
  int v6; // ecx
  unsigned int v7; // ecx

  LOBYTE(i) = *(_BYTE *)(a1 + 8);
  if ( (_BYTE)i )
  {
    if ( (_BYTE)i == 4 )
    {
      if ( *(_BYTE *)(a1 + 9) == 8 )
      {
        v4 = *(_DWORD *)(a1 + 4);
        i = a2;
        if ( v4 )
        {
          v5 = ((unsigned int)(v4 - 1) >> 1) + 1;
          do
          {
            *i = ~*i;
            i += 2;
            --v5;
          }
          while ( v5 );
        }
      }
      else if ( *(_BYTE *)(a1 + 9) == 16 )
      {
        v6 = *(_DWORD *)(a1 + 4);
        if ( v6 )
        {
          i = a2 + 1;
          v7 = ((unsigned int)(v6 - 1) >> 2) + 1;
          do
          {
            *(i - 1) = ~*(i - 1);
            *i = ~*i;
            i += 4;
            --v7;
          }
          while ( v7 );
        }
      }
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 4);
    for ( i = a2; v3; --v3 )
    {
      *i = ~*i;
      ++i;
    }
  }
  return (char)i;
}
// 410A43: conditional instruction was optimized away because of 'al.1==4'

//----- (00410A80) --------------------------------------------------------
void __cdecl sub_410A80(int a1, char *a2)
{
  int v3; // esi
  char v4; // cl

  if ( *(_BYTE *)(a1 + 9) == 16 && *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
  {
    v3 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
    do
    {
      v4 = *a2;
      *a2 = a2[1];
      a2[1] = v4;
      a2 += 2;
      --v3;
    }
    while ( v3 );
  }
}

//----- (00410AC0) --------------------------------------------------------
_BYTE *__cdecl sub_410AC0(int a1, _BYTE *a2)
{
  _BYTE *result; // eax
  unsigned __int8 v3; // dl
  unsigned int v4; // ecx
  _BYTE *v5; // esi

  result = (_BYTE *)a1;
  v3 = *(_BYTE *)(a1 + 9);
  if ( v3 < 8u )
  {
    result = a2;
    v4 = (unsigned int)&a2[*(_DWORD *)(a1 + 4)];
    switch ( v3 )
    {
      case 1u:
        v5 = &unk_41C040;
        break;
      case 2u:
        v5 = &unk_41C140;
        break;
      case 4u:
        v5 = &unk_41C240;
        break;
      default:
        return result;
    }
    if ( (unsigned int)a2 < v4 )
    {
      do
      {
        *result = v5[(unsigned __int8)*result];
        ++result;
      }
      while ( (unsigned int)result < v4 );
    }
  }
  return result;
}

//----- (00410B20) --------------------------------------------------------
int __cdecl sub_410B20(int a1, _BYTE *a2, int a3)
{
  int v3; // ebx
  char v4; // dl
  unsigned int v5; // edi
  int result; // eax
  _BYTE *v7; // ecx
  _BYTE *v8; // edx
  _BYTE *v9; // eax
  unsigned int v10; // esi
  char v11; // cl
  _BYTE *v12; // eax
  _BYTE *v13; // edx
  unsigned int v14; // esi
  char v15; // dl
  int v16; // eax
  char v17; // dl
  _BYTE *v18; // ecx
  _BYTE *v19; // edx
  _BYTE *v20; // eax
  unsigned int v21; // esi
  char v22; // cl
  _BYTE *v23; // edx
  char v24; // cl
  _BYTE *v25; // eax
  char v26; // cl
  char v27; // cl
  unsigned int v28; // esi
  int v29; // eax
  char v30; // dl
  char v31; // dl
  _BYTE *v32; // ecx
  char v33; // dl
  char v34; // dl
  unsigned int v35; // esi
  unsigned int v36; // esi
  _BYTE *v37; // edx
  _BYTE *v38; // eax
  unsigned int v39; // esi
  _BYTE *v40; // eax
  unsigned int v41; // esi
  char v42; // dl
  int v43; // eax
  _BYTE *v44; // ecx

  v3 = a3;
  v4 = *(_BYTE *)(a1 + 8);
  v5 = *(_DWORD *)a1;
  result = (int)a2;
  v7 = a2;
  if ( (v4 == 2 || v4 == 6 && (a3 & 0x400000) != 0) && *(_BYTE *)(a1 + 10) == 4 )
  {
    if ( *(_BYTE *)(a1 + 9) != 8 )
    {
      if ( (a3 & 0x80u) == 0 )
      {
        if ( v5 )
        {
          v28 = *(_DWORD *)a1;
          do
          {
            *v7 = *(_BYTE *)(result + 2);
            v29 = result + 2;
            v30 = *(_BYTE *)++v29;
            v7[1] = v30;
            v31 = *(_BYTE *)(v29 + 1);
            v32 = v7 + 1;
            ++v29;
            v32[1] = v31;
            v33 = *(_BYTE *)++v29;
            v32 += 2;
            *v32 = v33;
            v34 = *(_BYTE *)++v29;
            *++v32 = v34;
            *++v32 = *(_BYTE *)(v29 + 1);
            v7 = v32 + 1;
            result = v29 + 2;
            --v28;
          }
          while ( v28 );
        }
      }
      else
      {
        v19 = a2 + 8;
        v20 = a2 + 6;
        if ( v5 > 1 )
        {
          v21 = v5 - 1;
          do
          {
            *v20 = *v19;
            v22 = v19[1];
            v23 = v19 + 1;
            v20[1] = v22;
            v24 = v23[1];
            v25 = v20 + 1;
            ++v23;
            v25[1] = v24;
            v26 = *++v23;
            v25 += 2;
            *v25 = v26;
            v27 = *++v23;
            *++v25 = v27;
            *++v25 = v23[1];
            v20 = v25 + 1;
            v19 = v23 + 4;
            --v21;
          }
          while ( v21 );
        }
      }
      result = 6 * v5;
      *(_BYTE *)(a1 + 11) = 48;
      *(_DWORD *)(a1 + 4) = 6 * v5;
      *(_BYTE *)(a1 + 10) = 3;
      goto LABEL_49;
    }
    if ( (a3 & 0x80u) == 0 )
    {
      if ( v5 )
      {
        v14 = *(_DWORD *)a1;
        do
        {
          v15 = *(_BYTE *)(result + 1);
          v16 = result + 1;
          *v7 = v15;
          v17 = *(_BYTE *)++v16;
          v18 = v7 + 1;
          *v18++ = v17;
          *v18 = *(_BYTE *)(v16 + 1);
          v7 = v18 + 1;
          result = v16 + 2;
          --v14;
        }
        while ( v14 );
      }
    }
    else
    {
      v8 = a2 + 3;
      v9 = a2 + 4;
      if ( v5 > 1 )
      {
        v10 = v5 - 1;
        do
        {
          *v8 = *v9;
          v11 = v9[1];
          v12 = v9 + 1;
          v13 = v8 + 1;
          *v13++ = v11;
          *v13 = v12[1];
          v8 = v13 + 1;
          v9 = v12 + 3;
          --v10;
        }
        while ( v10 );
        result = 3 * v5;
        *(_BYTE *)(a1 + 11) = 24;
        *(_DWORD *)(a1 + 4) = 3 * v5;
        *(_BYTE *)(a1 + 10) = 3;
        goto LABEL_49;
      }
    }
    result = 3 * v5;
    *(_BYTE *)(a1 + 11) = 24;
    *(_DWORD *)(a1 + 4) = 3 * v5;
    *(_BYTE *)(a1 + 10) = 3;
    goto LABEL_49;
  }
  if ( v4 )
  {
    if ( v4 != 4 )
      goto LABEL_49;
    if ( (a3 & 0x400000) == 0 )
      return result;
  }
  if ( *(_BYTE *)(a1 + 10) == 2 )
  {
    if ( *(_BYTE *)(a1 + 9) != 8 )
    {
      if ( (a3 & 0x80u) == 0 )
      {
        if ( v5 )
        {
          v41 = *(_DWORD *)a1;
          do
          {
            v42 = *(_BYTE *)(result + 2);
            v43 = result + 2;
            *v7 = v42;
            v44 = v7 + 1;
            *v44 = *(_BYTE *)(v43 + 1);
            v7 = v44 + 1;
            result = v43 + 2;
            --v41;
          }
          while ( v41 );
        }
      }
      else
      {
        v37 = a2 + 4;
        v38 = a2 + 2;
        if ( v5 > 1 )
        {
          v39 = v5 - 1;
          do
          {
            *v38 = *v37;
            v40 = v38 + 1;
            *v40 = v37[1];
            v38 = v40 + 1;
            v37 += 4;
            --v39;
          }
          while ( v39 );
        }
      }
      result = 2 * v5;
      *(_BYTE *)(a1 + 11) = 16;
      *(_DWORD *)(a1 + 4) = 2 * v5;
      goto LABEL_48;
    }
    if ( (a3 & 0x80u) == 0 )
    {
      if ( v5 )
      {
        v36 = *(_DWORD *)a1;
        do
        {
          *v7++ = *(_BYTE *)(result + 1);
          result += 2;
          --v36;
        }
        while ( v36 );
        v3 = a3;
      }
    }
    else if ( v5 )
    {
      v35 = *(_DWORD *)a1;
      do
      {
        *v7++ = *(_BYTE *)result;
        result += 2;
        --v35;
      }
      while ( v35 );
      v3 = a3;
      *(_BYTE *)(a1 + 11) = 8;
      *(_DWORD *)(a1 + 4) = v5;
      goto LABEL_48;
    }
    *(_BYTE *)(a1 + 11) = 8;
    *(_DWORD *)(a1 + 4) = v5;
LABEL_48:
    *(_BYTE *)(a1 + 10) = 1;
  }
LABEL_49:
  if ( (v3 & 0x400000) != 0 )
    *(_BYTE *)(a1 + 8) &= 0xFBu;
  return result;
}

//----- (00410DD0) --------------------------------------------------------
char __cdecl sub_410DD0(int *a1, char *a2)
{
  char *v2; // eax
  char v3; // dl
  int v4; // ecx
  int v5; // esi
  char v6; // cl
  int v7; // esi
  char v8; // cl
  int v9; // esi
  char v10; // cl
  char v11; // dl
  char v12; // cl
  int v13; // esi
  char v14; // cl
  char v15; // dl
  char v16; // cl

  LOBYTE(v2) = (_BYTE)a1;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    LOBYTE(v2) = *((_BYTE *)a1 + 9);
    if ( (_BYTE)v2 == 8 )
    {
      if ( v3 == 2 )
      {
        v2 = a2;
        if ( v4 )
        {
          v5 = *a1;
          do
          {
            v6 = *v2;
            *v2 = v2[2];
            v2[2] = v6;
            v2 += 3;
            --v5;
          }
          while ( v5 );
        }
      }
      else if ( v3 == 6 )
      {
        v2 = a2;
        if ( v4 )
        {
          v7 = *a1;
          do
          {
            v8 = *v2;
            *v2 = v2[2];
            v2[2] = v8;
            v2 += 4;
            --v7;
          }
          while ( v7 );
        }
      }
    }
    else if ( (_BYTE)v2 == 16 )
    {
      if ( v3 == 2 )
      {
        if ( v4 )
        {
          v2 = a2 + 1;
          v9 = *a1;
          do
          {
            v10 = *(v2 - 1);
            *(v2 - 1) = v2[3];
            v11 = v2[4];
            v2[3] = v10;
            v12 = *v2;
            *v2 = v11;
            v2[4] = v12;
            v2 += 6;
            --v9;
          }
          while ( v9 );
        }
      }
      else if ( v3 == 6 && v4 )
      {
        v2 = a2 + 1;
        v13 = *a1;
        do
        {
          v14 = *(v2 - 1);
          *(v2 - 1) = v2[3];
          v15 = v2[4];
          v2[3] = v14;
          v16 = *v2;
          *v2 = v15;
          v2[4] = v16;
          v2 += 8;
          --v13;
        }
        while ( v13 );
      }
    }
  }
  return (char)v2;
}

//----- (00410EC0) --------------------------------------------------------
void __cdecl sub_410EC0(int a1, int a2, int a3)
{
  __int16 v3; // cx

  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 90) = *(_DWORD *)a3;
      *(_DWORD *)(a2 + 94) = *(_DWORD *)(a3 + 4);
      v3 = *(_WORD *)(a3 + 8);
      *(_DWORD *)(a2 + 8) |= 0x20u;
      *(_WORD *)(a2 + 98) = v3;
    }
  }
}

//----- (00410EF0) --------------------------------------------------------
void __cdecl png_set_cHRM(int a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  if ( a1 && a2 )
  {
    if ( a3 < 0.0 || a4 < 0.0 || a5 < 0.0 || a6 < 0.0 || a7 < 0.0 || a8 < 0.0 || a9 < 0.0 || a10 < 0.0 )
    {
      sub_4087F0(a1, "Ignoring attempt to set negative chromaticity value");
    }
    else if ( a3 > 21474.83
           || a4 > 21474.83
           || a5 > 21474.83
           || a6 > 21474.83
           || a7 > 21474.83
           || a8 > 21474.83
           || a9 > 21474.83
           || a10 > 21474.83 )
    {
      sub_4087F0(a1, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
    else
    {
      *(float *)(a2 + 128) = a3;
      *(float *)(a2 + 132) = a4;
      *(float *)(a2 + 136) = a5;
      *(float *)(a2 + 140) = a6;
      *(float *)(a2 + 144) = a7;
      *(float *)(a2 + 148) = a8;
      *(float *)(a2 + 152) = a9;
      *(float *)(a2 + 156) = a10;
      *(_DWORD *)(a2 + 256) = (int)(a3 * 100000.0 + 0.5);
      *(_DWORD *)(a2 + 260) = (int)(a4 * 100000.0 + 0.5);
      *(_DWORD *)(a2 + 264) = (int)(a5 * 100000.0 + 0.5);
      *(_DWORD *)(a2 + 268) = (int)(a6 * 100000.0 + 0.5);
      *(_DWORD *)(a2 + 272) = (int)(a7 * 100000.0 + 0.5);
      *(_DWORD *)(a2 + 276) = (int)(a8 * 100000.0 + 0.5);
      *(_DWORD *)(a2 + 280) = (int)(a9 * 100000.0 + 0.5);
      *(_DWORD *)(a2 + 8) |= 4u;
      *(_DWORD *)(a2 + 284) = (int)(100000.0 * a10 + 0.5);
    }
  }
}

//----- (00411230) --------------------------------------------------------
int __cdecl sub_411230(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  double v10; // st7
  double v11; // st5
  double v12; // st4
  double v13; // st3
  double v14; // st2
  double v15; // st1
  double v16; // st6
  int result; // eax
  double v18; // [esp+0h] [ebp-8h]

  if ( a1 && a2 )
  {
    if ( a3 < 0 || a4 < 0 || a5 < 0 || a6 < 0 || a7 < 0 || a8 < 0 || a9 < 0 || a10 < 0 )
    {
      result = sub_4087F0(a1, "Ignoring attempt to set negative chromaticity value");
    }
    else
    {
      v10 = (double)a3;
      if ( v10 > 2147483647.0
        || (v18 = (double)a4, v18 > 2147483647.0)
        || (v11 = (double)a5, v11 > 2147483647.0)
        || (v12 = (double)a6, v12 > 2147483647.0)
        || (v13 = (double)a7, v13 > 2147483647.0)
        || (v14 = (double)a8, v14 > 2147483647.0)
        || (v15 = (double)a9, v15 > 2147483647.0)
        || (v16 = (double)a10, v16 > 2147483647.0) )
      {
        result = sub_4087F0(a1, "Ignoring attempt to set chromaticity value exceeding 21474.83");
      }
      else
      {
        *(_DWORD *)(a2 + 8) |= 4u;
        *(_DWORD *)(a2 + 256) = a3;
        *(_DWORD *)(a2 + 276) = a8;
        *(_DWORD *)(a2 + 280) = a9;
        *(_DWORD *)(a2 + 260) = a4;
        result = a5;
        *(_DWORD *)(a2 + 268) = a6;
        *(_DWORD *)(a2 + 272) = a7;
        *(_DWORD *)(a2 + 264) = a5;
        *(_DWORD *)(a2 + 284) = a10;
        *(float *)(a2 + 128) = v10 / 100000.0;
        *(float *)(a2 + 132) = v18 / 100000.0;
        *(float *)(a2 + 136) = v11 / 100000.0;
        *(float *)(a2 + 140) = v12 / 100000.0;
        *(float *)(a2 + 144) = v13 / 100000.0;
        *(float *)(a2 + 148) = v14 / 100000.0;
        *(float *)(a2 + 152) = v15 / 100000.0;
        *(float *)(a2 + 156) = v16 / 100000.0;
      }
    }
  }
  return result;
}

//----- (00411420) --------------------------------------------------------
void __cdecl sub_411420(int a1, int a2, double a3)
{
  double v3; // st7

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( a3 > 21474.83 )
    {
      sub_4087F0(a1, "Limiting gamma to 21474.83");
      v3 = 21474.83;
    }
    *(float *)(a2 + 40) = v3;
    *(_DWORD *)(a2 + 8) |= 1u;
    *(_DWORD *)(a2 + 252) = (int)(100000.0 * v3 + 0.5);
    if ( 0.0 == v3 )
      sub_4087F0(a1, "Setting gamma=0");
  }
}

//----- (004114A0) --------------------------------------------------------
void __cdecl sub_4114A0(int a1, int a2, int a3)
{
  int v3; // eax

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( a3 < 0 )
    {
      sub_4087F0(a1, "Setting negative gamma to zero");
      v3 = 0;
    }
    *(_DWORD *)(a2 + 8) |= 1u;
    *(_DWORD *)(a2 + 252) = v3;
    *(float *)(a2 + 40) = (double)v3 / 100000.0;
    if ( !v3 )
      sub_4087F0(a1, "Setting gamma=0");
  }
}

//----- (00411520) --------------------------------------------------------
void __cdecl sub_411520(int a1, int a2, int a3)
{
  void *v3; // eax
  int v4; // eax
  int v5; // eax

  if ( a1 && a2 )
  {
    if ( *(_WORD *)(a2 + 20) )
    {
      png_free_data(a1, a2, 8, 0);
      v3 = sub_408C20(a1, 0x200u);
      *(_DWORD *)(a1 + 500) = v3;
      if ( v3 )
      {
        v4 = 0;
        if ( *(_WORD *)(a2 + 20) )
        {
          do
          {
            *(_WORD *)(*(_DWORD *)(a1 + 500) + 2 * v4) = *(_WORD *)(a3 + 2 * v4);
            ++v4;
          }
          while ( v4 < *(unsigned __int16 *)(a2 + 20) );
        }
        v5 = *(_DWORD *)(a1 + 500);
        *(_DWORD *)(a2 + 8) |= 0x40u;
        *(_DWORD *)(a2 + 184) |= 8u;
        *(_DWORD *)(a2 + 124) = v5;
      }
      else
      {
        sub_4087F0(a1, "Insufficient memory for hIST chunk data.");
      }
    }
    else
    {
      sub_4087F0(a1, "Palette size 0, hIST allocation skipped.");
    }
  }
}

//----- (004115E0) --------------------------------------------------------
void __cdecl png_set_IHDR(jmp_buf Buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  unsigned __int8 v9; // al

  if ( !Buf || !a2 )
    return;
  if ( !a3 || !a4 )
    sub_408740(Buf, "Image width or height is zero in IHDR");
  if ( a3 > (unsigned int)Buf[153] || a4 > (unsigned int)Buf[154] )
    sub_408740(Buf, "image size exceeds user limits in IHDR");
  if ( (unsigned int)a3 > 0x7FFFFFFF || (unsigned int)a4 > 0x7FFFFFFF )
    sub_408740(Buf, "Invalid image size in IHDR");
  if ( (unsigned int)a3 > 0x1FFFFF7E )
    sub_4087F0((int)Buf, "Width is too large for libpng to process pixels");
  if ( a5 != 1 && a5 != 2 && a5 != 4 && a5 != 8 && a5 != 16 )
    sub_408740(Buf, "Invalid bit depth in IHDR");
  if ( a6 < 0 || a6 == 1 || a6 == 5 || a6 > 6 )
    sub_408740(Buf, "Invalid color type in IHDR");
  if ( a6 != 3 )
  {
    if ( a6 != 2 && a6 != 4 && a6 != 6 || a5 >= 8 )
      goto LABEL_33;
LABEL_32:
    sub_408740(Buf, "Invalid color type/bit depth combination in IHDR");
  }
  if ( a5 > 8 )
    goto LABEL_32;
LABEL_33:
  if ( a7 >= 2 )
    sub_408740(Buf, "Unknown interlace method in IHDR");
  if ( a8 )
    sub_408740(Buf, "Unknown compression method in IHDR");
  if ( (Buf[26] & 0x1000) != 0 && Buf[140] )
    sub_4087F0((int)Buf, "MNG features are not allowed in a PNG datastream\n");
  if ( a9 )
  {
    if ( (Buf[140] & 4) == 0 || a9 != 64 || (Buf[26] & 0x1000) != 0 || a6 != 2 && a6 != 6 )
      sub_408740(Buf, "Unknown filter method in IHDR");
    if ( (Buf[26] & 0x1000) != 0 )
      sub_4087F0((int)Buf, "Invalid filter method in IHDR");
  }
  *(_DWORD *)(a2 + 4) = a4;
  *(_BYTE *)(a2 + 26) = 0;
  *(_BYTE *)(a2 + 27) = a9;
  *(_DWORD *)a2 = a3;
  *(_BYTE *)(a2 + 24) = a5;
  *(_BYTE *)(a2 + 25) = a6;
  *(_BYTE *)(a2 + 28) = a7;
  if ( (_BYTE)a6 == 3 || (a6 & 2) == 0 )
    *(_BYTE *)(a2 + 29) = 1;
  else
    *(_BYTE *)(a2 + 29) = 3;
  if ( (a6 & 4) != 0 )
    ++*(_BYTE *)(a2 + 29);
  v9 = a5 * *(_BYTE *)(a2 + 29);
  *(_BYTE *)(a2 + 30) = v9;
  if ( (unsigned int)a3 <= 0x1FFFFF7E )
  {
    if ( v9 < 8u )
      *(_DWORD *)(a2 + 12) = (a3 * (unsigned int)v9 + 7) >> 3;
    else
      *(_DWORD *)(a2 + 12) = a3 * (v9 >> 3);
  }
  else
  {
    *(_DWORD *)(a2 + 12) = 0;
  }
}

//----- (00411810) --------------------------------------------------------
void __cdecl sub_411810(int a1, int a2, int a3, int a4, char a5)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 0x100u;
      *(_DWORD *)(a2 + 100) = a3;
      *(_DWORD *)(a2 + 104) = a4;
      *(_BYTE *)(a2 + 108) = a5;
    }
  }
}

//----- (00411840) --------------------------------------------------------
void __cdecl sub_411840(int a1, int a2, void *Src, int a4, int a5, char a6, int a7, void *a8, int a9)
{
  unsigned int v9; // kr00_4
  void *v10; // eax
  unsigned int v11; // kr04_4
  void *v12; // eax
  _DWORD *v13; // eax
  int v14; // esi
  unsigned int v15; // kr08_4
  void **v16; // eax

  if ( a1 && a2 )
  {
    v9 = strlen((const char *)Src);
    v10 = sub_408C20(a1, v9 + 1);
    *(_DWORD *)(a2 + 160) = v10;
    if ( v10 )
    {
      memcpy(v10, Src, v9 + 1);
      *(_DWORD *)(a2 + 164) = a4;
      *(_BYTE *)(a2 + 181) = a7;
      *(_DWORD *)(a2 + 168) = a5;
      *(_BYTE *)(a2 + 180) = a6;
      v11 = strlen((const char *)a8);
      v12 = sub_408C20(a1, v11 + 1);
      *(_DWORD *)(a2 + 172) = v12;
      if ( v12 )
      {
        memcpy(v12, a8, v11 + 1);
        v13 = sub_408C20(a1, 4 * a7 + 4);
        *(_DWORD *)(a2 + 176) = v13;
        if ( v13 )
        {
          v14 = 0;
          v13[a7] = 0;
          if ( a7 <= 0 )
          {
LABEL_12:
            *(_DWORD *)(a2 + 8) |= 0x400u;
            *(_DWORD *)(a2 + 184) |= 0x80u;
          }
          else
          {
            while ( 1 )
            {
              v15 = strlen(*(const char **)(a9 + 4 * v14));
              *(_DWORD *)(*(_DWORD *)(a2 + 176) + 4 * v14) = sub_408C20(a1, v15 + 1);
              v16 = (void **)(*(_DWORD *)(a2 + 176) + 4 * v14);
              if ( !*v16 )
                break;
              memcpy(*v16, *(const void **)(a9 + 4 * v14++), v15 + 1);
              if ( v14 >= a7 )
                goto LABEL_12;
            }
            sub_4087F0(a1, "Insufficient memory for pCAL parameter.");
          }
        }
        else
        {
          sub_4087F0(a1, "Insufficient memory for pCAL params.");
        }
      }
      else
      {
        sub_4087F0(a1, "Insufficient memory for pCAL units.");
      }
    }
    else
    {
      sub_4087F0(a1, "Insufficient memory for pCAL purpose.");
    }
  }
}

//----- (004119E0) --------------------------------------------------------
void __cdecl sub_4119E0(int a1, int a2, char a3, double a4, double a5)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 0x4000u;
      *(double *)(a2 + 224) = a4;
      *(_BYTE *)(a2 + 220) = a3;
      *(double *)(a2 + 232) = a5;
    }
  }
}

//----- (00411A20) --------------------------------------------------------
void __cdecl sub_411A20(int a1, int a2, int a3, int a4, char a5)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 0x80u;
      *(_DWORD *)(a2 + 112) = a3;
      *(_DWORD *)(a2 + 116) = a4;
      *(_BYTE *)(a2 + 120) = a5;
    }
  }
}

//----- (00411A50) --------------------------------------------------------
void __cdecl sub_411A50(int a1, int a2, void *Src, int a4)
{
  void *v4; // eax

  if ( a1 )
  {
    if ( a2 )
    {
      png_free_data(a1, a2, 4096, 0);
      v4 = sub_408BA0(a1, 0x300u);
      *(_DWORD *)(a1 + 276) = v4;
      memset(v4, 0, 0x300u);
      memcpy(*(void **)(a1 + 276), Src, 3 * a4);
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 276);
      *(_WORD *)(a1 + 280) = a4;
      *(_DWORD *)(a2 + 184) |= 0x1000u;
      *(_DWORD *)(a2 + 8) |= 8u;
      *(_WORD *)(a2 + 20) = a4;
    }
  }
}

//----- (00411AE0) --------------------------------------------------------
void __cdecl sub_411AE0(int a1, int a2, int a3)
{
  char v3; // cl

  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 68) = *(_DWORD *)a3;
      v3 = *(_BYTE *)(a3 + 4);
      *(_DWORD *)(a2 + 8) |= 2u;
      *(_BYTE *)(a2 + 72) = v3;
    }
  }
}

//----- (00411B10) --------------------------------------------------------
void __cdecl sub_411B10(int a1, int a2, char a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 0x800u;
      *(_BYTE *)(a2 + 44) = a3;
    }
  }
}

//----- (00411B30) --------------------------------------------------------
void __cdecl sub_411B30(int a1, int a2, char a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      sub_411B10(a1, a2, a3);
      sub_411420(a1, a2, 0.4545499980449677);
      sub_4114A0(a1, a2, 45455);
      sub_411230(a1, a2, 31270, 32900, 64000, 33000, 30000, 60000, 15000, 6000);
      png_set_cHRM(
        a1,
        a2,
        0.3127000033855438,
        0.3289999961853027,
        0.6399999856948853,
        0.3300000131130219,
        0.300000011920929,
        0.6000000238418579,
        0.1500000059604645,
        0.05999999865889549);
    }
  }
}

//----- (00411C10) --------------------------------------------------------
void __cdecl sub_411C10(int a1, int a2, int a3, char a4, void *Src, size_t Size)
{
  char *v6; // ebp
  void *v7; // edi

  if ( a1 && a2 && a3 && Src )
  {
    v6 = (char *)sub_408C20(a1, strlen((const char *)a3) + 1);
    if ( v6 )
    {
      strcpy(v6, (const char *)a3);
      v7 = sub_408C20(a1, Size);
      if ( v7 )
      {
        memcpy(v7, Src, Size);
        png_free_data(a1, a2, 16, 0);
        *(_DWORD *)(a2 + 184) |= 0x10u;
        *(_DWORD *)(a2 + 8) |= 0x1000u;
        *(_DWORD *)(a2 + 196) = v6;
        *(_DWORD *)(a2 + 204) = Size;
        *(_DWORD *)(a2 + 200) = v7;
        *(_BYTE *)(a2 + 208) = a4;
      }
      else
      {
        sub_408BF0(a1, v6);
        sub_4087F0(a1, "Insufficient memory to process iCCP profile.");
      }
    }
    else
    {
      sub_4087F0(a1, "Insufficient memory to process iCCP chunk.");
    }
  }
}

//----- (00411D10) --------------------------------------------------------
int __cdecl sub_411D10(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // esi
  int v5; // eax
  void *v6; // ebp
  int v7; // eax
  void *v8; // eax
  void *v10; // eax
  const char **v11; // edi
  const char *v12; // eax
  int *v13; // esi
  size_t v14; // ebp
  int v15; // ecx
  const char *v16; // edi
  size_t v17; // edi
  void *v18; // eax
  void *v19; // eax
  int *v20; // eax
  bool v21; // cc
  const void **v22; // [esp+8h] [ebp-8h]
  int v23; // [esp+Ch] [ebp-4h]

  if ( !a1 || !a2 || !a4 )
    return 0;
  v4 = a2[13];
  v5 = a4 + a2[12];
  if ( v5 > v4 )
  {
    v6 = (void *)a2[14];
    if ( v6 )
    {
      v7 = v5 + 8;
      a2[13] = v7;
      v8 = sub_408C20(a1, 16 * v7);
      a2[14] = v8;
      if ( !v8 )
      {
        sub_408BF0(a1, v6);
        return 1;
      }
      memcpy(v8, v6, 16 * v4);
      sub_408BF0(a1, v6);
    }
    else
    {
      a2[13] = a4 + 8;
      a2[12] = 0;
      v10 = sub_408C20(a1, 16 * (a4 + 8));
      a2[14] = v10;
      if ( !v10 )
        return 1;
      a2[46] |= 0x4000u;
    }
  }
  v23 = 0;
  if ( a4 > 0 )
  {
    v11 = (const char **)(a3 + 8);
    v22 = (const void **)(a3 + 8);
    do
    {
      v12 = *(v11 - 1);
      v13 = (int *)(a2[14] + 16 * a2[12]);
      if ( v12 )
      {
        v14 = strlen(v12);
        v15 = (int)*(v11 - 2);
        if ( v15 > 0 )
        {
          sub_4087F0(a1, "iTXt chunk not supported.");
        }
        else
        {
          v16 = *v11;
          if ( v16 && *v16 )
          {
            v17 = strlen(v16);
            *v13 = v15;
          }
          else
          {
            v17 = 0;
            *v13 = -1;
          }
          v18 = sub_408C20(a1, v17 + v14 + 4);
          v13[1] = (int)v18;
          if ( !v18 )
            return 1;
          memcpy(v18, *(v22 - 1), v14);
          *(_BYTE *)(v13[1] + v14) = 0;
          v19 = (void *)(v13[1] + v14 + 1);
          v13[2] = (int)v19;
          if ( v17 )
            memcpy(v19, *v22, v17);
          *(_BYTE *)(v17 + v13[2]) = 0;
          v13[3] = v17;
          v11 = (const char **)v22;
          v20 = (int *)(a2[14] + 16 * a2[12]);
          *v20 = *v13;
          v20[1] = v13[1];
          v20[2] = v13[2];
          v20[3] = v13[3];
          ++a2[12];
        }
      }
      v11 += 4;
      v21 = ++v23 < a4;
      v22 = (const void **)v11;
    }
    while ( v21 );
  }
  return 0;
}

//----- (00411F00) --------------------------------------------------------
void __cdecl sub_411F00(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // ecx

  if ( a1 && a2 && (*(_DWORD *)(a1 + 104) & 0x200) == 0 )
  {
    a2[15] = *a3;
    v3 = a3[1];
    a2[2] |= 0x200u;
    a2[16] = v3;
  }
}

//----- (00411F30) --------------------------------------------------------
void __cdecl sub_411F30(int a1, int a2, void *Src, size_t Size, int a5)
{
  __int16 v5; // bx
  void *v6; // eax

  if ( a1 && a2 )
  {
    v5 = Size;
    if ( Src )
    {
      png_free_data(a1, a2, 0x2000, 0);
      v6 = sub_408BA0(a1, 0x100u);
      *(_DWORD *)(a2 + 76) = v6;
      *(_DWORD *)(a1 + 392) = v6;
      memcpy(*(void **)(a2 + 76), Src, Size);
      *(_DWORD *)(a2 + 184) |= 0x2000u;
    }
    if ( a5 )
    {
      *(_DWORD *)(a2 + 80) = *(_DWORD *)a5;
      *(_DWORD *)(a2 + 84) = *(_DWORD *)(a5 + 4);
      *(_WORD *)(a2 + 88) = *(_WORD *)(a5 + 8);
      if ( !Size )
        v5 = 1;
    }
    *(_DWORD *)(a2 + 8) |= 0x10u;
    *(_WORD *)(a2 + 22) = v5;
  }
}

//----- (00411FC0) --------------------------------------------------------
int __cdecl sub_411FC0(int a1, int a2, int a3, int a4)
{
  int v5; // esi
  char *v6; // eax
  char *v7; // ebp
  int result; // eax
  char *v10; // esi
  _BYTE *v11; // eax
  const char *v12; // ecx
  _BYTE *v13; // edx
  char v14; // al
  void *v15; // eax
  char *v16; // [esp+10h] [ebp-4h]
  int v17; // [esp+1Ch] [ebp+8h]

  v5 = a4;
  v6 = (char *)sub_408C20(a1, 16 * (a4 + *(_DWORD *)(a2 + 216)));
  v7 = v6;
  v16 = v6;
  if ( !v6 )
    return sub_4087F0(a1, "No memory for sPLT palettes.");
  memcpy(v6, *(const void **)(a2 + 212), 16 * *(_DWORD *)(a2 + 216));
  sub_408BF0(a1, *(void **)(a2 + 212));
  result = 0;
  *(_DWORD *)(a2 + 212) = 0;
  v17 = 0;
  if ( a4 > 0 )
  {
    do
    {
      v10 = &v7[16 * v17 + 16 * *(_DWORD *)(a2 + 216)];
      v11 = sub_408BA0(a1, *(_DWORD *)a3 + strlen(*(const char **)a3) + 1 - *(_DWORD *)a3);
      *(_DWORD *)v10 = v11;
      v12 = *(const char **)a3;
      v13 = v11;
      do
      {
        v14 = *v12;
        *v13++ = *v12++;
      }
      while ( v14 );
      v15 = sub_408BA0(a1, 16 * *(_DWORD *)(a3 + 12));
      *((_DWORD *)v10 + 2) = v15;
      memcpy(v15, *(const void **)(a3 + 8), 16 * *(_DWORD *)(a3 + 12));
      v7 = v16;
      *((_DWORD *)v10 + 3) = *(_DWORD *)(a3 + 12);
      v10[4] = *(_BYTE *)(a3 + 4);
      result = v17 + 1;
      a3 += 16;
      ++v17;
    }
    while ( v17 < a4 );
    v5 = a4;
  }
  *(_DWORD *)(a2 + 216) += v5;
  *(_DWORD *)(a2 + 8) |= 0x2000u;
  *(_DWORD *)(a2 + 184) |= 0x20u;
  *(_DWORD *)(a2 + 212) = v7;
  return result;
}

//----- (00412100) --------------------------------------------------------
void __cdecl sub_412100(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  char *v5; // esi
  int v6; // ebp
  size_t *v7; // edi
  char *v8; // esi
  void *v9; // eax
  char *v10; // [esp+4h] [ebp-4h]

  if ( a1 )
  {
    if ( a2 )
    {
      v4 = a4;
      if ( a4 )
      {
        v5 = (char *)sub_408C20(a1, 20 * (a4 + *(_DWORD *)(a2 + 192)));
        v10 = v5;
        if ( v5 )
        {
          memcpy(v5, *(const void **)(a2 + 188), 20 * *(_DWORD *)(a2 + 192));
          sub_408BF0(a1, *(void **)(a2 + 188));
          v6 = 0;
          *(_DWORD *)(a2 + 188) = 0;
          if ( a4 > 0 )
          {
            v7 = (size_t *)(a3 + 12);
            do
            {
              v8 = &v5[20 * v6 + 20 * *(_DWORD *)(a2 + 192)];
              strncpy(v8, (const char *)v7 - 12, 5u);
              v9 = sub_408C20(a1, *v7);
              *((_DWORD *)v8 + 2) = v9;
              if ( v9 )
              {
                memcpy(v9, (const void *)*(v7 - 1), *v7);
                *((_DWORD *)v8 + 3) = *v7;
                v8[16] = *(_BYTE *)(a1 + 104);
              }
              else
              {
                sub_4087F0(a1, "Out of memory processing unknown chunk.");
              }
              v5 = v10;
              ++v6;
              v7 += 5;
            }
            while ( v6 < a4 );
            v4 = a4;
          }
          *(_DWORD *)(a2 + 192) += v4;
          *(_DWORD *)(a2 + 184) |= 0x200u;
          *(_DWORD *)(a2 + 188) = v5;
        }
        else
        {
          sub_4087F0(a1, "Out of memory while processing unknown chunk.");
        }
      }
    }
  }
}

//----- (00412787) --------------------------------------------------------
void *sub_412787()
{
  return &unk_41AEF8;
}

//----- (004127AB) --------------------------------------------------------
void __cdecl sub_4127AB()
{
  ;
}

//----- (00412971) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (00412AB8) --------------------------------------------------------
int sub_412AB8()
{
  dword_41CECC = _get_sse2_info();
  return 0;
}
// 412A58: using guessed type int _get_sse2_info(void);
// 41CECC: using guessed type int dword_41CECC;

//----- (00412AF0) --------------------------------------------------------
int __cdecl inflateReset(_DWORD *a1)
{
  _DWORD *v1; // eax

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  v1[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  a1[12] = 1;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[8] = 0;
  v1[10] = 0;
  v1[11] = 0;
  v1[12] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[5] = 0x8000;
  v1[27] = v1 + 332;
  v1[20] = v1 + 332;
  v1[19] = v1 + 332;
  return 0;
}

//----- (00412B50) --------------------------------------------------------
int __cdecl sub_412B50(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  bool v4; // zf
  _DWORD *v5; // eax
  int v7; // ecx

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( a1 )
  {
    v4 = a1[8] == 0;
    a1[6] = 0;
    if ( v4 )
    {
      a1[8] = sub_414650;
      a1[10] = 0;
    }
    if ( !a1[9] )
      a1[9] = sub_414670;
    v5 = (_DWORD *)((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 9520);
    if ( !v5 )
      return -4;
    v7 = a2;
    a1[7] = v5;
    if ( a2 >= 0 )
    {
      v5[2] = (a2 >> 4) + 1;
      if ( a2 < 48 )
        v7 = a2 & 0xF;
    }
    else
    {
      v5[2] = 0;
      v7 = -a2;
    }
    if ( (unsigned int)(v7 - 8) <= 7 )
    {
      v5[9] = v7;
      v5[13] = 0;
      return inflateReset(a1);
    }
    ((void (__cdecl *)(_DWORD, _DWORD *))a1[9])(a1[10], v5);
    a1[7] = 0;
  }
  return -2;
}

//----- (00412C20) --------------------------------------------------------
int __cdecl sub_412C20(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_412B50(a1, 15, a2, a3);
}

//----- (00412C40) --------------------------------------------------------
_DWORD *__usercall sub_412C40@<eax>(_DWORD *result@<eax>)
{
  result[19] = &unk_417B70;
  result[21] = 9;
  result[20] = &unk_418370;
  result[22] = 5;
  return result;
}

//----- (00412C60) --------------------------------------------------------
int __usercall sub_412C60@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi
  int v4; // eax
  int result; // eax
  int v6; // ecx
  size_t v7; // edi
  size_t v8; // eax
  int v9; // eax
  size_t v10; // ebp
  size_t v11; // edi
  int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // ecx

  v2 = *(_DWORD *)(a2 + 28);
  if ( !*(_DWORD *)(v2 + 52) )
  {
    v4 = (*(int (__cdecl **)(_DWORD, int, int))(a2 + 32))(*(_DWORD *)(a2 + 40), 1 << *(_DWORD *)(v2 + 36), 1);
    *(_DWORD *)(v2 + 52) = v4;
    if ( !v4 )
      return 1;
  }
  if ( !*(_DWORD *)(v2 + 40) )
  {
    v6 = *(_DWORD *)(v2 + 36);
    *(_DWORD *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 44) = 0;
    *(_DWORD *)(v2 + 40) = 1 << v6;
  }
  v7 = a1 - *(_DWORD *)(a2 + 16);
  v8 = *(_DWORD *)(v2 + 40);
  if ( v7 < v8 )
  {
    v10 = v8 - *(_DWORD *)(v2 + 48);
    if ( v10 > v7 )
      v10 = v7;
    memcpy((void *)(*(_DWORD *)(v2 + 48) + *(_DWORD *)(v2 + 52)), (const void *)(*(_DWORD *)(a2 + 12) - v7), v10);
    v11 = v7 - v10;
    if ( v11 )
    {
      memcpy(*(void **)(v2 + 52), (const void *)(*(_DWORD *)(a2 + 12) - v11), v11);
      v12 = *(_DWORD *)(v2 + 40);
      *(_DWORD *)(v2 + 48) = v11;
      *(_DWORD *)(v2 + 44) = v12;
      result = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 48) += v10;
      v13 = *(_DWORD *)(v2 + 40);
      if ( *(_DWORD *)(v2 + 48) == v13 )
        *(_DWORD *)(v2 + 48) = 0;
      v14 = *(_DWORD *)(v2 + 44);
      if ( v14 < v13 )
        *(_DWORD *)(v2 + 44) = v10 + v14;
      result = 0;
    }
  }
  else
  {
    memcpy(*(void **)(v2 + 52), (const void *)(*(_DWORD *)(a2 + 12) - v8), *(_DWORD *)(v2 + 40));
    v9 = *(_DWORD *)(v2 + 40);
    *(_DWORD *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 44) = v9;
    result = 0;
  }
  return result;
}

//----- (00412D50) --------------------------------------------------------
int __cdecl inflate(int a1, int a2)
{
  int *v2; // edi
  unsigned int v3; // edx
  unsigned int v4; // ebx
  unsigned __int8 *v5; // ebp
  int v6; // eax
  unsigned int v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // eax
  int v13; // eax
  int *v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  size_t v26; // eax
  int v27; // ecx
  unsigned int v28; // edx
  int v29; // eax
  unsigned int v30; // eax
  int v31; // ecx
  int v32; // eax
  unsigned int v33; // ecx
  int v34; // eax
  int v35; // eax
  unsigned int v36; // eax
  int v37; // ecx
  int v38; // eax
  unsigned int v39; // ecx
  int v40; // eax
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  unsigned __int16 v46; // ax
  int v47; // eax
  unsigned int v48; // eax
  int v49; // ecx
  int v50; // eax
  char v51; // cl
  unsigned int v52; // ebx
  unsigned int v53; // esi
  int v54; // ecx
  int v55; // eax
  int v56; // eax
  unsigned int v57; // eax
  int v58; // eax
  int v59; // ecx
  unsigned int v60; // ebx
  char v61; // al
  unsigned int v62; // eax
  int v63; // ecx
  bool v64; // cc
  int v65; // eax
  int v66; // eax
  unsigned int v67; // eax
  int v68; // eax
  int v69; // ecx
  int v70; // eax
  int v71; // eax
  int v72; // ecx
  int v73; // eax
  int v74; // ecx
  int v75; // eax
  unsigned int v76; // ebx
  int v77; // eax
  int v78; // eax
  unsigned int v79; // ebx
  __int16 v80; // ax
  int v81; // ecx
  int v82; // eax
  void *v83; // ecx
  int v84; // edx
  unsigned int v85; // eax
  size_t v86; // eax
  int v87; // eax
  int v88; // eax
  unsigned int v89; // eax
  int v90; // eax
  int v91; // ecx
  size_t v92; // eax
  int v93; // eax
  int v94; // eax
  unsigned int v95; // eax
  int v96; // eax
  int v97; // ecx
  unsigned int v98; // eax
  unsigned int v99; // eax
  unsigned int v100; // ecx
  int v101; // ecx
  char *v102; // ecx
  unsigned int v103; // ecx
  _BYTE *v104; // eax
  char v105; // cl
  bool v106; // zf
  char *v107; // eax
  int v108; // eax
  unsigned int v109; // eax
  unsigned int v110; // eax
  int v111; // eax
  unsigned __int16 v112; // cx
  int v113; // eax
  int result; // eax
  unsigned int v115; // ebp
  unsigned int v116; // ebx
  unsigned int v117; // eax
  unsigned int v118; // [esp-1Ch] [ebp-4Ch]
  unsigned int v119; // [esp-18h] [ebp-48h]
  unsigned __int8 *v120; // [esp-14h] [ebp-44h]
  unsigned int v121; // [esp+4h] [ebp-2Ch]
  unsigned int Size; // [esp+8h] [ebp-28h]
  unsigned int Sizea; // [esp+8h] [ebp-28h]
  unsigned int Sizeb; // [esp+8h] [ebp-28h]
  size_t Sizec; // [esp+8h] [ebp-28h]
  size_t Sized; // [esp+8h] [ebp-28h]
  size_t Sizee; // [esp+8h] [ebp-28h]
  size_t Sizef; // [esp+8h] [ebp-28h]
  size_t Sizeg; // [esp+8h] [ebp-28h]
  size_t Sizeh; // [esp+8h] [ebp-28h]
  size_t Sizei; // [esp+8h] [ebp-28h]
  size_t Sizej; // [esp+8h] [ebp-28h]
  size_t v133; // [esp+Ch] [ebp-24h]
  size_t v134; // [esp+Ch] [ebp-24h]
  char v135; // [esp+Eh] [ebp-22h]
  unsigned int v136; // [esp+10h] [ebp-20h]
  unsigned int v137; // [esp+14h] [ebp-1Ch] BYREF
  int v138; // [esp+18h] [ebp-18h]
  void *v139; // [esp+1Ch] [ebp-14h]
  int v140; // [esp+20h] [ebp-10h]
  int v141; // [esp+24h] [ebp-Ch]
  unsigned int v142; // [esp+28h] [ebp-8h]
  unsigned int v143; // [esp+2Ch] [ebp-4h]

  if ( !a1 )
    return -2;
  v2 = *(int **)(a1 + 28);
  if ( !v2 || !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  if ( *v2 == 11 )
    *v2 = 12;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = v2[14];
  v5 = *(unsigned __int8 **)a1;
  v139 = *(void **)(a1 + 12);
  v6 = *v2;
  v7 = v2[15];
  v136 = *(_DWORD *)(a1 + 16);
  v121 = v3;
  v135 = BYTE2(v4);
  v143 = v3;
  v140 = v136;
  v141 = 0;
  while ( 2 )
  {
    switch ( v6 )
    {
      case 0:
        if ( !v2[2] )
        {
          *v2 = 12;
          goto LABEL_294;
        }
        for ( ; v7 < 0x10; v135 = BYTE2(v4) )
        {
          if ( !v3 )
            goto LABEL_302;
          v8 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v8;
          v121 = v3;
        }
        if ( (v2[2] & 2) != 0 && v4 == 35615 )
        {
          v2[6] = sub_414630(0, 0, 0);
          LOWORD(v137) = -29921;
          v9 = sub_414630(v2[6], &v137, 2u);
          v3 = v121;
          v4 = 0;
          v2[6] = v9;
          v135 = 0;
          v7 = 0;
          *v2 = 1;
          goto LABEL_294;
        }
        v10 = v2[8];
        v2[4] = 0;
        if ( v10 )
          *(_DWORD *)(v10 + 48) = -1;
        if ( (v2[2] & 1) == 0 || ((v4 >> 8) + ((unsigned __int8)v4 << 8)) % 0x1F )
        {
          *(_DWORD *)(a1 + 24) = "incorrect header check";
          v3 = v121;
          goto LABEL_293;
        }
        if ( (v4 & 0xF) != 8 )
        {
          v3 = v121;
          *(_DWORD *)(a1 + 24) = "unknown compression method";
          goto LABEL_293;
        }
        v4 >>= 4;
        v11 = (v4 & 0xF) + 8;
        v7 -= 4;
        v135 = BYTE2(v4);
        if ( v11 > v2[9] )
        {
          v3 = v121;
          *(_DWORD *)(a1 + 24) = "invalid window size";
          goto LABEL_293;
        }
        v2[5] = 1 << v11;
        v12 = adler32(0, 0, 0);
        v3 = v121;
        v2[6] = v12;
        *(_DWORD *)(a1 + 48) = v12;
        *v2 = ~BYTE1(v4) & 2 | 9;
        v4 = 0;
        v135 = 0;
        v7 = 0;
        goto LABEL_294;
      case 1:
        if ( v7 >= 0x10 )
          goto LABEL_31;
        do
        {
          if ( !v3 )
            goto LABEL_302;
          v13 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v13;
          v121 = v3;
          v135 = BYTE2(v4);
        }
        while ( v7 < 0x10 );
LABEL_31:
        v2[4] = v4;
        if ( (_BYTE)v4 != 8 )
        {
          *(_DWORD *)(a1 + 24) = "unknown compression method";
          goto LABEL_293;
        }
        if ( (v4 & 0xE000) != 0 )
        {
          *(_DWORD *)(a1 + 24) = "unknown header flags set";
          goto LABEL_293;
        }
        v14 = (int *)v2[8];
        if ( v14 )
          *v14 = (v4 >> 8) & 1;
        if ( (v2[4] & 0x200) != 0 )
        {
          LOBYTE(v137) = 8;
          BYTE1(v137) = BYTE1(v4);
          v15 = sub_414630(v2[6], &v137, 2u);
          v3 = v121;
          v2[6] = v15;
        }
        v4 = 0;
        v7 = 0;
        *v2 = 2;
        do
        {
LABEL_41:
          if ( !v3 )
            goto LABEL_302;
          v16 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v16;
          v121 = v3;
        }
        while ( v7 < 0x20 );
LABEL_43:
        v17 = v2[8];
        if ( v17 )
          *(_DWORD *)(v17 + 4) = v4;
        if ( (v2[4] & 0x200) != 0 )
        {
          v137 = v4;
          v18 = sub_414630(v2[6], &v137, 4u);
          v3 = v121;
          v2[6] = v18;
        }
        v4 = 0;
        v7 = 0;
        *v2 = 3;
        do
        {
LABEL_49:
          if ( !v3 )
            goto LABEL_302;
          v19 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v19;
          v121 = v3;
        }
        while ( v7 < 0x10 );
LABEL_51:
        v20 = v2[8];
        if ( v20 )
        {
          *(_DWORD *)(v20 + 8) = (unsigned __int8)v4;
          *(_DWORD *)(v2[8] + 12) = v4 >> 8;
        }
        if ( (v2[4] & 0x200) != 0 )
        {
          LOWORD(v137) = v4;
          v21 = sub_414630(v2[6], &v137, 2u);
          v3 = v121;
          v2[6] = v21;
        }
        v4 = 0;
        v135 = 0;
        v7 = 0;
        *v2 = 4;
LABEL_56:
        if ( (v2[4] & 0x400) != 0 )
        {
          if ( v7 < 0x10 )
          {
            while ( v3 )
            {
              v22 = *v5 << v7;
              --v3;
              v7 += 8;
              ++v5;
              v4 += v22;
              v121 = v3;
              if ( v7 >= 0x10 )
                goto LABEL_60;
            }
            goto LABEL_302;
          }
LABEL_60:
          v23 = v2[8];
          v2[16] = v4;
          if ( v23 )
            *(_DWORD *)(v23 + 20) = v4;
          if ( (v2[4] & 0x200) != 0 )
          {
            LOWORD(v137) = v4;
            v24 = sub_414630(v2[6], &v137, 2u);
            v3 = v121;
            v2[6] = v24;
          }
          v4 = 0;
          v135 = 0;
          v7 = 0;
        }
        else
        {
          v25 = v2[8];
          if ( v25 )
            *(_DWORD *)(v25 + 16) = 0;
        }
        *v2 = 5;
LABEL_68:
        if ( (v2[4] & 0x400) != 0 )
        {
          v26 = v2[16];
          Size = v26;
          if ( v26 > v3 )
          {
            v26 = v3;
            Size = v3;
          }
          if ( v26 )
          {
            v27 = v2[8];
            if ( v27 )
            {
              v142 = *(_DWORD *)(v27 + 16);
              if ( v142 )
              {
                v28 = *(_DWORD *)(v2[8] + 24);
                v138 = *(_DWORD *)(v2[8] + 20) - v2[16];
                if ( v26 + v138 > v28 )
                  v26 = v28 - v138;
                memcpy((void *)(v138 + v142), v5, v26);
                v26 = Size;
                v3 = v121;
              }
            }
            if ( (v2[4] & 0x200) != 0 )
            {
              v29 = sub_414630(v2[6], v5, Size);
              v3 = v121;
              v2[6] = v29;
              v26 = Size;
            }
            v3 -= v26;
            v5 += v26;
            v2[16] -= v26;
            v121 = v3;
          }
          if ( v2[16] )
            goto LABEL_302;
        }
        v2[16] = 0;
        *v2 = 6;
LABEL_82:
        if ( (v2[4] & 0x800) != 0 )
        {
          if ( !v3 )
            goto LABEL_302;
          v30 = 0;
          do
          {
            v31 = v5[v30];
            Sizea = v30 + 1;
            v32 = v2[8];
            v138 = v31;
            if ( v32 )
            {
              v142 = *(_DWORD *)(v32 + 28);
              if ( v142 )
              {
                v33 = v2[16];
                if ( v33 < *(_DWORD *)(v32 + 32) )
                {
                  *(_BYTE *)(v142 + v33) = v138;
                  ++v2[16];
                  v3 = v121;
                }
              }
            }
            if ( !v138 )
              break;
            v30 = Sizea;
          }
          while ( Sizea < v3 );
          if ( (v2[4] & 0x200) != 0 )
          {
            v34 = sub_414630(v2[6], v5, Sizea);
            v3 = v121;
            v2[6] = v34;
          }
          v3 -= Sizea;
          v5 += Sizea;
          v121 = v3;
          if ( v138 )
            goto LABEL_302;
        }
        else
        {
          v35 = v2[8];
          if ( v35 )
            *(_DWORD *)(v35 + 28) = 0;
        }
        v2[16] = 0;
        *v2 = 7;
LABEL_98:
        if ( (v2[4] & 0x1000) != 0 )
        {
          if ( !v3 )
            goto LABEL_302;
          v36 = 0;
          do
          {
            v37 = v5[v36];
            Sizeb = v36 + 1;
            v38 = v2[8];
            v138 = v37;
            if ( v38 )
            {
              v142 = *(_DWORD *)(v38 + 36);
              if ( v142 )
              {
                v39 = v2[16];
                if ( v39 < *(_DWORD *)(v38 + 40) )
                {
                  *(_BYTE *)(v142 + v39) = v138;
                  ++v2[16];
                  v3 = v121;
                }
              }
            }
            if ( !v138 )
              break;
            v36 = Sizeb;
          }
          while ( Sizeb < v3 );
          if ( (v2[4] & 0x200) != 0 )
          {
            v40 = sub_414630(v2[6], v5, Sizeb);
            v3 = v121;
            v2[6] = v40;
          }
          v3 -= Sizeb;
          v5 += Sizeb;
          v121 = v3;
          if ( v138 )
            goto LABEL_302;
        }
        else
        {
          v41 = v2[8];
          if ( v41 )
            *(_DWORD *)(v41 + 36) = 0;
        }
        *v2 = 8;
LABEL_114:
        if ( (v2[4] & 0x200) != 0 )
        {
          if ( v7 < 0x10 )
          {
            while ( v3 )
            {
              v42 = *v5 << v7;
              --v3;
              v7 += 8;
              ++v5;
              v4 += v42;
              v121 = v3;
              v135 = BYTE2(v4);
              if ( v7 >= 0x10 )
                goto LABEL_118;
            }
            goto LABEL_302;
          }
LABEL_118:
          if ( v4 != *((unsigned __int16 *)v2 + 12) )
          {
            *(_DWORD *)(a1 + 24) = "header crc mismatch";
            goto LABEL_293;
          }
          v4 = 0;
          v135 = 0;
          v7 = 0;
        }
        v43 = v2[8];
        if ( v43 )
        {
          *(_DWORD *)(v43 + 44) = (v2[4] >> 9) & 1;
          *(_DWORD *)(v2[8] + 48) = 1;
        }
        v44 = sub_414630(0, 0, 0);
        v3 = v121;
        v2[6] = v44;
        *(_DWORD *)(a1 + 48) = v44;
        *v2 = 11;
        goto LABEL_294;
      case 2:
        if ( v7 < 0x20 )
          goto LABEL_41;
        goto LABEL_43;
      case 3:
        if ( v7 < 0x10 )
          goto LABEL_49;
        goto LABEL_51;
      case 4:
        goto LABEL_56;
      case 5:
        goto LABEL_68;
      case 6:
        goto LABEL_82;
      case 7:
        goto LABEL_98;
      case 8:
        goto LABEL_114;
      case 9:
        if ( v7 >= 0x20 )
          goto LABEL_127;
        do
        {
          if ( !v3 )
            goto LABEL_302;
          v45 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v45;
          v121 = v3;
          v135 = BYTE2(v4);
        }
        while ( v7 < 0x20 );
LABEL_127:
        LOBYTE(v46) = 0;
        HIBYTE(v46) = v135;
        v47 = v46 + (((v4 << 16) + (v4 & 0xFF00)) << 8) + HIBYTE(v4);
        v2[6] = v47;
        *(_DWORD *)(a1 + 48) = v47;
        v4 = 0;
        v7 = 0;
        *v2 = 10;
LABEL_128:
        if ( !v2[3] )
        {
          *(_DWORD *)(a1 + 12) = v139;
          *(_DWORD *)a1 = v5;
          *(_DWORD *)(a1 + 16) = v136;
          *(_DWORD *)(a1 + 4) = v3;
          v2[15] = v7;
          v2[14] = v4;
          return 2;
        }
        v48 = adler32(0, 0, 0);
        v2[6] = v48;
        *(_DWORD *)(a1 + 48) = v48;
        v3 = v121;
        *v2 = 11;
LABEL_130:
        if ( a2 == 5 )
          goto LABEL_302;
LABEL_131:
        if ( v2[1] )
        {
          v49 = v7 & 7;
          v4 >>= v49;
          v7 -= v49;
          *v2 = 24;
          v135 = BYTE2(v4);
        }
        else
        {
          if ( v7 < 3 )
          {
            while ( v3 )
            {
              v50 = *v5 << v7;
              --v3;
              v7 += 8;
              ++v5;
              v4 += v50;
              v121 = v3;
              if ( v7 >= 3 )
                goto LABEL_136;
            }
            goto LABEL_302;
          }
LABEL_136:
          v51 = v4;
          v52 = v4 >> 1;
          v53 = v7 - 1;
          v2[1] = v51 & 1;
          switch ( v52 & 3 )
          {
            case 0u:
              v4 = v52 >> 2;
              *v2 = 13;
              v135 = BYTE2(v4);
              v7 = v53 - 2;
              break;
            case 1u:
              sub_412C40(v2);
              v4 = v52 >> 2;
              *v2 = 18;
              v135 = BYTE2(v4);
              v7 = v53 - 2;
              break;
            case 2u:
              v4 = v52 >> 2;
              *v2 = 15;
              v135 = BYTE2(v4);
              v7 = v53 - 2;
              break;
            case 3u:
              *(_DWORD *)(a1 + 24) = "invalid block type";
              *v2 = 27;
              goto LABEL_141;
            default:
LABEL_141:
              v4 = v52 >> 2;
              v135 = BYTE2(v4);
              v7 = v53 - 2;
              break;
          }
        }
        goto LABEL_294;
      case 10:
        goto LABEL_128;
      case 11:
        goto LABEL_130;
      case 12:
        goto LABEL_131;
      case 13:
        v54 = v7 & 7;
        v4 >>= v54;
        v7 -= v54;
        v135 = BYTE2(v4);
        if ( v7 >= 0x20 )
          goto LABEL_145;
        do
        {
          if ( !v3 )
            goto LABEL_302;
          v55 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v55;
          v121 = v3;
          v135 = BYTE2(v4);
        }
        while ( v7 < 0x20 );
LABEL_145:
        v56 = (unsigned __int16)v4;
        if ( (unsigned __int16)v4 != ~v4 >> 16 )
        {
          *(_DWORD *)(a1 + 24) = "invalid stored block lengths";
          goto LABEL_293;
        }
        v4 = 0;
        v2[16] = v56;
        v135 = 0;
        v7 = 0;
        *v2 = 14;
LABEL_148:
        v57 = v2[16];
        Sizec = v57;
        if ( !v57 )
          goto LABEL_225;
        if ( v57 > v3 )
        {
          v57 = v3;
          Sizec = v3;
        }
        if ( v57 > v136 )
        {
          v57 = v136;
          Sizec = v136;
        }
        if ( !v57 )
          goto LABEL_302;
        memcpy(v139, v5, Sizec);
        v121 -= Sizec;
        v136 -= Sizec;
        v139 = (char *)v139 + Sizec;
        v3 = v121;
        v5 += Sizec;
        v2[16] -= Sizec;
        goto LABEL_294;
      case 14:
        goto LABEL_148;
      case 15:
        if ( v7 >= 0xE )
          goto LABEL_158;
        do
        {
          if ( !v3 )
            goto LABEL_302;
          v58 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v58;
          v121 = v3;
        }
        while ( v7 < 0xE );
LABEL_158:
        v59 = v4 & 0x1F;
        v60 = v4 >> 5;
        v61 = v60;
        v2[24] = v59 + 257;
        v60 >>= 5;
        v62 = (v61 & 0x1F) + 1;
        v63 = (v60 & 0xF) + 4;
        v4 = v60 >> 4;
        v7 -= 14;
        v64 = (unsigned int)v2[24] <= 0x11E;
        v2[25] = v62;
        v2[23] = v63;
        v135 = BYTE2(v4);
        if ( !v64 || v62 > 0x1E )
        {
          *(_DWORD *)(a1 + 24) = "too many length or distance symbols";
          goto LABEL_293;
        }
        v2[26] = 0;
        *v2 = 16;
LABEL_161:
        if ( v2[26] < (unsigned int)v2[23] )
        {
          while ( v7 >= 3 )
          {
LABEL_165:
            *((_WORD *)v2 + (unsigned __int16)word_4183F0[v2[26]++] + 56) = v4 & 7;
            v4 >>= 3;
            v7 -= 3;
            v135 = BYTE2(v4);
            if ( v2[26] >= (unsigned int)v2[23] )
              goto LABEL_166;
          }
          while ( v3 )
          {
            v65 = *v5 << v7;
            --v3;
            v7 += 8;
            ++v5;
            v4 += v65;
            v121 = v3;
            if ( v7 >= 3 )
              goto LABEL_165;
          }
          goto LABEL_302;
        }
LABEL_166:
        while ( (unsigned int)v2[26] < 0x13 )
          *((_WORD *)v2 + (unsigned __int16)word_4183F0[v2[26]++] + 56) = 0;
        v2[27] = (int)(v2 + 332);
        v2[19] = (int)(v2 + 332);
        v2[21] = 7;
        v66 = inflate_table(0, (int)(v2 + 28), 0x13u, (_DWORD **)v2 + 27, (unsigned int *)v2 + 21, (_WORD *)v2 + 376);
        v3 = v121;
        v141 = v66;
        if ( v66 )
        {
          *(_DWORD *)(a1 + 24) = "invalid code lengths set";
          goto LABEL_293;
        }
        v2[26] = 0;
        *v2 = 17;
LABEL_172:
        if ( v2[26] < (unsigned int)(v2[24] + v2[25]) )
        {
          while ( 1 )
          {
            v67 = *(_DWORD *)(v2[19] + 4 * (v4 & ((1 << v2[21]) - 1)));
            Sized = v67;
            if ( BYTE1(v67) > v7 )
              break;
LABEL_176:
            if ( HIWORD(v67) >= 0x10u )
            {
              if ( HIWORD(Sized) == 16 )
              {
                v69 = BYTE1(v67);
                v138 = BYTE1(v67);
                if ( v7 < (unsigned int)BYTE1(v67) + 2 )
                {
                  while ( v3 )
                  {
                    v70 = *v5 << v7;
                    v69 = v138;
                    --v3;
                    v7 += 8;
                    v4 += v70;
                    ++v5;
                    v121 = v3;
                    if ( v7 >= v138 + 2 )
                      goto LABEL_185;
                  }
                  goto LABEL_302;
                }
LABEL_185:
                v71 = v2[26];
                v4 >>= v69;
                v7 -= v69;
                v135 = BYTE2(v4);
                if ( !v71 )
                {
                  *(_DWORD *)(a1 + 24) = "invalid bit length repeat";
                  goto LABEL_293;
                }
                v72 = *((unsigned __int16 *)v2 + v71 + 55);
                v73 = (v4 & 3) + 3;
                v4 >>= 2;
                v138 = v72;
                Sizee = v73;
                v7 -= 2;
              }
              else
              {
                v74 = BYTE1(v67);
                v138 = BYTE1(v67);
                if ( HIWORD(Sized) == 17 )
                {
                  if ( v7 < (unsigned int)BYTE1(v67) + 3 )
                  {
                    while ( v3 )
                    {
                      v75 = *v5 << v7;
                      v74 = v138;
                      --v3;
                      v7 += 8;
                      v4 += v75;
                      ++v5;
                      v121 = v3;
                      if ( v7 >= v138 + 3 )
                        goto LABEL_191;
                    }
                    goto LABEL_302;
                  }
LABEL_191:
                  v76 = v4 >> v74;
                  Sizee = (v76 & 7) + 3;
                  v4 = v76 >> 3;
                  v77 = -3;
                }
                else
                {
                  if ( v7 < (unsigned int)BYTE1(v67) + 7 )
                  {
                    while ( v3 )
                    {
                      v78 = *v5 << v7;
                      v74 = v138;
                      --v3;
                      v7 += 8;
                      v4 += v78;
                      ++v5;
                      v121 = v3;
                      if ( v7 >= v138 + 7 )
                        goto LABEL_195;
                    }
                    goto LABEL_302;
                  }
LABEL_195:
                  v79 = v4 >> v74;
                  Sizee = (v79 & 0x7F) + 11;
                  v4 = v79 >> 7;
                  v77 = -7;
                }
                v7 += v77 - v74;
                v73 = Sizee;
                v138 = 0;
              }
              v135 = BYTE2(v4);
              if ( v73 + v2[26] > (unsigned int)(v2[24] + v2[25]) )
              {
                *(_DWORD *)(a1 + 24) = "invalid bit length repeat";
                goto LABEL_293;
              }
              if ( Sizee )
              {
                v80 = v138;
                do
                {
                  --Sizee;
                  *((_WORD *)v2 + v2[26]++ + 56) = v80;
                }
                while ( Sizee );
              }
            }
            else
            {
              if ( v7 < BYTE1(v67) )
              {
                while ( v3 )
                {
                  v67 = *v5 << v7;
                  --v3;
                  v7 += 8;
                  ++v5;
                  v4 += v67;
                  BYTE1(v67) = BYTE1(Sized);
                  v121 = v3;
                  if ( v7 >= BYTE1(Sized) )
                    goto LABEL_180;
                }
                goto LABEL_302;
              }
LABEL_180:
              v4 >>= SBYTE1(v67);
              v7 -= BYTE1(v67);
              *((_WORD *)v2 + v2[26]++ + 56) = HIWORD(Sized);
              v135 = BYTE2(v4);
            }
            if ( v2[26] >= (unsigned int)(v2[24] + v2[25]) )
              goto LABEL_202;
          }
          while ( v3 )
          {
            v68 = *v5 << v7;
            --v3;
            v7 += 8;
            v4 += v68;
            ++v5;
            v121 = v3;
            v67 = *(_DWORD *)(v2[19] + 4 * (v4 & ((1 << v2[21]) - 1)));
            Sized = v67;
            if ( BYTE1(v67) <= v7 )
              goto LABEL_176;
          }
          goto LABEL_302;
        }
LABEL_202:
        if ( *v2 == 27 )
          goto LABEL_294;
        v2[27] = (int)(v2 + 332);
        v2[19] = (int)(v2 + 332);
        v118 = v2[24];
        v2[21] = 9;
        v141 = inflate_table(1, (int)(v2 + 28), v118, (_DWORD **)v2 + 27, (unsigned int *)v2 + 21, (_WORD *)v2 + 376);
        if ( v141 )
        {
          v3 = v121;
          *(_DWORD *)(a1 + 24) = "invalid literal/lengths set";
          goto LABEL_293;
        }
        v2[20] = v2[27];
        v81 = v2[24];
        v2[22] = 6;
        v82 = inflate_table(
                2,
                (int)v2 + 2 * v81 + 112,
                v2[25],
                (_DWORD **)v2 + 27,
                (unsigned int *)v2 + 22,
                (_WORD *)v2 + 376);
        v3 = v121;
        v141 = v82;
        if ( v82 )
        {
          *(_DWORD *)(a1 + 24) = "invalid distances set";
          goto LABEL_293;
        }
        *v2 = 18;
LABEL_210:
        if ( v3 >= 6 && v136 >= 0x102 )
        {
          v83 = v139;
          *(_DWORD *)(a1 + 16) = v136;
          v84 = v140;
          *(_DWORD *)(a1 + 12) = v83;
          *(_DWORD *)a1 = v5;
          *(_DWORD *)(a1 + 4) = v121;
          v2[14] = v4;
          v2[15] = v7;
          inflate_fast((_DWORD *)a1, v84);
          v5 = *(unsigned __int8 **)a1;
          v85 = *(_DWORD *)(a1 + 4);
          v4 = v2[14];
          v7 = v2[15];
          v136 = *(_DWORD *)(a1 + 16);
          v139 = *(void **)(a1 + 12);
          v121 = v85;
          v135 = BYTE2(v4);
          v3 = v85;
          goto LABEL_294;
        }
        v86 = *(_DWORD *)(v2[19] + 4 * (v4 & ((1 << v2[21]) - 1)));
        Sizef = v86;
        if ( BYTE1(v86) > v7 )
        {
          while ( v3 )
          {
            v87 = *v5 << v7;
            --v3;
            v7 += 8;
            v4 += v87;
            ++v5;
            v121 = v3;
            v86 = *(_DWORD *)(v2[19] + 4 * (v4 & ((1 << v2[21]) - 1)));
            Sizef = v86;
            if ( BYTE1(v86) <= v7 )
              goto LABEL_216;
          }
          goto LABEL_302;
        }
LABEL_216:
        if ( (_BYTE)v86 && (v86 & 0xF0) == 0 )
        {
          v142 = v86 >> 8;
          v138 = BYTE1(v86);
          v133 = v86;
          Sizeg = *(_DWORD *)(v2[19] + 4 * (HIWORD(Sizef) + ((v4 & ((1 << (BYTE1(v86) + v86)) - 1)) >> SBYTE1(v86))));
          if ( BYTE1(v86) + (unsigned int)BYTE1(Sizeg) > v7 )
          {
            while ( v3 )
            {
              v88 = *v5 << v7;
              --v3;
              v7 += 8;
              v4 += v88;
              v138 = BYTE1(v133);
              ++v5;
              v121 = v3;
              Sizeg = *(_DWORD *)(v2[19]
                                + 4 * (HIWORD(v133) + ((v4 & ((1 << (BYTE1(v133) + v133)) - 1)) >> SBYTE1(v133))));
              if ( BYTE1(v133) + (unsigned int)BYTE1(Sizeg) <= v7 )
                goto LABEL_221;
            }
            goto LABEL_302;
          }
LABEL_221:
          v86 = Sizeg;
          v4 >>= SBYTE1(v133);
          v7 -= BYTE1(v133);
        }
        v4 >>= SBYTE1(v86);
        v7 -= BYTE1(v86);
        v138 = BYTE1(v86);
        v135 = BYTE2(v4);
        v2[16] = HIWORD(v86);
        if ( !(_BYTE)v86 )
        {
          *v2 = 23;
          goto LABEL_294;
        }
        if ( (v86 & 0x20) != 0 )
        {
LABEL_225:
          *v2 = 11;
          goto LABEL_294;
        }
        if ( (v86 & 0x40) != 0 )
        {
          *(_DWORD *)(a1 + 24) = "invalid literal/length code";
          goto LABEL_293;
        }
        v2[18] = v86 & 0xF;
        *v2 = 19;
LABEL_229:
        v89 = v2[18];
        if ( v89 )
        {
          if ( v7 < v89 )
          {
            while ( v3 )
            {
              v90 = *v5 << v7;
              --v3;
              v7 += 8;
              ++v5;
              v4 += v90;
              v121 = v3;
              if ( v7 >= v2[18] )
                goto LABEL_233;
            }
            goto LABEL_302;
          }
LABEL_233:
          v91 = v2[18];
          v2[16] += v4 & ((1 << v91) - 1);
          v4 >>= v91;
          v7 -= v91;
        }
        *v2 = 20;
LABEL_235:
        v92 = *(_DWORD *)(v2[20] + 4 * (v4 & ((1 << v2[22]) - 1)));
        Sizeh = v92;
        if ( BYTE1(v92) > v7 )
        {
          while ( v3 )
          {
            v93 = *v5 << v7;
            --v3;
            v7 += 8;
            v4 += v93;
            ++v5;
            v121 = v3;
            v92 = *(_DWORD *)(v2[20] + 4 * (v4 & ((1 << v2[22]) - 1)));
            Sizeh = v92;
            if ( BYTE1(v92) <= v7 )
              goto LABEL_238;
          }
          goto LABEL_302;
        }
LABEL_238:
        if ( (v92 & 0xF0) == 0 )
        {
          v142 = v92 >> 8;
          v138 = BYTE1(v92);
          v134 = v92;
          Sizei = *(_DWORD *)(v2[20] + 4 * (HIWORD(Sizeh) + ((v4 & ((1 << (BYTE1(v92) + v92)) - 1)) >> SBYTE1(v92))));
          if ( BYTE1(v92) + (unsigned int)BYTE1(Sizei) > v7 )
          {
            while ( v3 )
            {
              v94 = *v5 << v7;
              --v3;
              v7 += 8;
              v4 += v94;
              v138 = BYTE1(v134);
              ++v5;
              v121 = v3;
              Sizei = *(_DWORD *)(v2[20]
                                + 4 * (HIWORD(v134) + ((v4 & ((1 << (BYTE1(v134) + v134)) - 1)) >> SBYTE1(v134))));
              if ( BYTE1(v134) + (unsigned int)BYTE1(Sizei) <= v7 )
                goto LABEL_242;
            }
            goto LABEL_302;
          }
LABEL_242:
          v92 = Sizei;
          v4 >>= SBYTE1(v134);
          v7 -= BYTE1(v134);
        }
        v4 >>= SBYTE1(v92);
        v7 -= BYTE1(v92);
        v138 = BYTE1(v92);
        v135 = BYTE2(v4);
        if ( (v92 & 0x40) != 0 )
        {
          *(_DWORD *)(a1 + 24) = "invalid distance code";
          goto LABEL_293;
        }
        v2[17] = HIWORD(v92);
        v2[18] = v92 & 0xF;
        *v2 = 21;
LABEL_246:
        v95 = v2[18];
        if ( v95 )
        {
          if ( v7 < v95 )
          {
            while ( v3 )
            {
              v96 = *v5 << v7;
              --v3;
              v7 += 8;
              ++v5;
              v4 += v96;
              v121 = v3;
              if ( v7 >= v2[18] )
                goto LABEL_250;
            }
            goto LABEL_302;
          }
LABEL_250:
          v97 = v2[18];
          v2[17] += v4 & ((1 << v97) - 1);
          v4 >>= v97;
          v7 -= v97;
          v135 = BYTE2(v4);
        }
        if ( v2[17] > v140 + v2[11] - v136 )
        {
          *(_DWORD *)(a1 + 24) = "invalid distance too far back";
          goto LABEL_293;
        }
        *v2 = 22;
LABEL_254:
        if ( !v136 )
          goto LABEL_302;
        v98 = v2[17];
        if ( v98 <= v140 - v136 )
        {
          v102 = (char *)v139 - v98;
          v99 = v2[16];
          v138 = (int)v102;
          v142 = v99;
          goto LABEL_262;
        }
        v99 = v98 - (v140 - v136);
        v100 = v2[12];
        Sizej = v99;
        if ( v99 <= v100 )
        {
          v101 = v2[12] + v2[13] - v99;
        }
        else
        {
          v99 -= v100;
          Sizej = v99;
          v101 = v2[10] + v2[13] - v99;
        }
        v138 = v101;
        v142 = v2[16];
        if ( v99 > v142 )
        {
          v99 = v142;
LABEL_262:
          Sizej = v99;
        }
        if ( v99 > v136 )
        {
          v99 = v136;
          Sizej = v136;
        }
        v136 -= v99;
        v103 = v142 - v99;
        v104 = v139;
        v2[16] = v103;
        do
        {
          v105 = *(_BYTE *)v138++;
          *v104++ = v105;
          --Sizej;
        }
        while ( Sizej );
        v106 = v2[16] == 0;
        v139 = v104;
        if ( v106 )
          *v2 = 18;
        goto LABEL_294;
      case 16:
        goto LABEL_161;
      case 17:
        goto LABEL_172;
      case 18:
        goto LABEL_210;
      case 19:
        goto LABEL_229;
      case 20:
        goto LABEL_235;
      case 21:
        goto LABEL_246;
      case 22:
        goto LABEL_254;
      case 23:
        if ( !v136 )
          goto LABEL_302;
        v107 = (char *)v139;
        *(_BYTE *)v139 = *((_BYTE *)v2 + 64);
        --v136;
        v139 = v107 + 1;
        *v2 = 18;
        goto LABEL_294;
      case 24:
        if ( !v2[2] )
          goto LABEL_285;
        if ( v7 >= 0x20 )
          goto LABEL_275;
        do
        {
          if ( !v3 )
            goto LABEL_302;
          v108 = *v5 << v7;
          --v3;
          v7 += 8;
          ++v5;
          v4 += v108;
          v121 = v3;
          v135 = BYTE2(v4);
        }
        while ( v7 < 0x20 );
LABEL_275:
        v109 = v140 - v136;
        *(_DWORD *)(a1 + 20) += v140 - v136;
        v2[7] += v109;
        v140 = v109;
        if ( v109 )
        {
          v120 = (unsigned __int8 *)v139 - v109;
          v119 = v2[6];
          if ( v2[4] )
            v110 = sub_414630(v119, v120, v109);
          else
            v110 = adler32(v119, v120, v109);
          v3 = v121;
          v2[6] = v110;
          *(_DWORD *)(a1 + 48) = v110;
        }
        v106 = v2[4] == 0;
        v140 = v136;
        v111 = v4;
        if ( v106 )
        {
          LOBYTE(v112) = 0;
          HIBYTE(v112) = v135;
          v111 = HIBYTE(v4) + v112 + (((v4 << 16) + (v4 & 0xFF00)) << 8);
        }
        if ( v111 != v2[6] )
        {
          *(_DWORD *)(a1 + 24) = "incorrect data check";
          goto LABEL_293;
        }
        v4 = 0;
        v135 = 0;
        v7 = 0;
LABEL_285:
        *v2 = 25;
LABEL_286:
        if ( !v2[2] || !v2[4] )
          goto LABEL_299;
        if ( v7 < 0x20 )
        {
          while ( v3 )
          {
            v113 = *v5 << v7;
            --v3;
            v7 += 8;
            ++v5;
            v4 += v113;
            v121 = v3;
            v135 = BYTE2(v4);
            if ( v7 >= 0x20 )
              goto LABEL_291;
          }
          goto LABEL_302;
        }
LABEL_291:
        if ( v4 != v2[7] )
        {
          *(_DWORD *)(a1 + 24) = "incorrect length check";
LABEL_293:
          *v2 = 27;
LABEL_294:
          v6 = *v2;
          if ( (unsigned int)*v2 > 0x1C )
            return -2;
          continue;
        }
        v4 = 0;
        v7 = 0;
LABEL_299:
        *v2 = 26;
LABEL_300:
        v141 = 1;
LABEL_302:
        *(_DWORD *)(a1 + 12) = v139;
        *(_DWORD *)(a1 + 16) = v136;
        *(_DWORD *)a1 = v5;
        *(_DWORD *)(a1 + 4) = v3;
        v106 = v2[10] == 0;
        v2[14] = v4;
        v2[15] = v7;
        if ( v106 && (*v2 >= 24 || v140 == *(_DWORD *)(a1 + 16)) || !sub_412C60(v140, a1) )
        {
          v115 = v143 - *(_DWORD *)(a1 + 4);
          v116 = v140 - *(_DWORD *)(a1 + 16);
          *(_DWORD *)(a1 + 8) += v115;
          *(_DWORD *)(a1 + 20) += v116;
          v2[7] += v116;
          if ( v2[2] && v116 )
          {
            if ( v2[4] )
              v117 = sub_414630(v2[6], (_BYTE *)(*(_DWORD *)(a1 + 12) - v116), v116);
            else
              v117 = adler32(v2[6], (unsigned __int8 *)(*(_DWORD *)(a1 + 12) - v116), v116);
            v2[6] = v117;
            *(_DWORD *)(a1 + 48) = v117;
          }
          *(_DWORD *)(a1 + 44) = v2[15] + (*v2 != 11 ? 0 : 0x80) + (v2[1] != 0 ? 0x40 : 0);
          if ( (v115 || v116) && a2 != 4 )
          {
            result = v141;
          }
          else
          {
            result = v141;
            if ( !v141 )
              result = -5;
          }
        }
        else
        {
          *v2 = 28;
LABEL_307:
          result = -4;
        }
        return result;
      case 25:
        goto LABEL_286;
      case 26:
        goto LABEL_300;
      case 27:
        v141 = -3;
        goto LABEL_302;
      case 28:
        goto LABEL_307;
      default:
        return -2;
    }
  }
}
// 412DF2: variable 'v3' is possibly undefined

//----- (00414340) --------------------------------------------------------
int __cdecl inflateEnd(_DWORD *a1)
{
  int v1; // eax
  void (__cdecl *v2)(_DWORD, int); // ecx
  int v3; // eax

  if ( !a1 )
    return -2;
  v1 = a1[7];
  if ( !v1 )
    return -2;
  v2 = (void (__cdecl *)(_DWORD, int))a1[9];
  if ( !v2 )
    return -2;
  v3 = *(_DWORD *)(v1 + 52);
  if ( v3 )
    v2(a1[10], v3);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (00414630) --------------------------------------------------------
int __cdecl sub_414630(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // esi
  unsigned int i; // eax
  unsigned int v5; // edi
  unsigned int v6; // eax
  _DWORD *v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // edx
  unsigned int v15; // edx
  unsigned int v16; // eax
  _BYTE *v17; // ecx

  v17 = a2;
  if ( !a2 )
    return 0;
  v3 = a3;
  for ( i = ~a1; v3; --v3 )
  {
    if ( ((unsigned __int8)v17 & 3) == 0 )
      break;
    i = dword_4185D8[(unsigned __int8)(i ^ *v17++)] ^ (i >> 8);
  }
  if ( v3 >= 0x20 )
  {
    v5 = v3 >> 5;
    do
    {
      v6 = *(_DWORD *)v17 ^ i;
      v7 = v17 + 12;
      v8 = *(v7 - 2) ^ dword_4191D8[(unsigned __int8)v6] ^ dword_4185D8[HIBYTE(v6)] ^ dword_418DD8[BYTE1(v6)] ^ dword_4189D8[BYTE2(v6)];
      v7 += 3;
      v9 = *(v7 - 4) ^ dword_4191D8[(unsigned __int8)v8] ^ dword_4185D8[HIBYTE(v8)] ^ dword_418DD8[BYTE1(v8)] ^ dword_4189D8[BYTE2(v8)];
      v10 = *(v7 - 3) ^ dword_4191D8[(unsigned __int8)v9] ^ dword_4185D8[HIBYTE(v9)] ^ dword_418DD8[BYTE1(v9)] ^ dword_4189D8[BYTE2(v9)];
      v11 = *(v7 - 2) ^ dword_4191D8[(unsigned __int8)v10] ^ dword_4185D8[HIBYTE(v10)] ^ dword_418DD8[BYTE1(v10)] ^ dword_4189D8[BYTE2(v10)];
      v12 = *(v7 - 1) ^ dword_4191D8[(unsigned __int8)v11] ^ dword_4185D8[HIBYTE(v11)] ^ dword_418DD8[BYTE1(v11)] ^ dword_4189D8[BYTE2(v11)];
      v13 = *v7 ^ dword_4191D8[(unsigned __int8)v12] ^ dword_4185D8[HIBYTE(v12)] ^ dword_418DD8[BYTE1(v12)] ^ dword_4189D8[BYTE2(v12)];
      v17 = v7 + 2;
      v3 -= 32;
      v14 = *((_DWORD *)v17 - 1) ^ dword_4191D8[(unsigned __int8)v13] ^ dword_4185D8[HIBYTE(v13)] ^ dword_418DD8[BYTE1(v13)] ^ dword_4189D8[BYTE2(v13)];
      i = dword_4191D8[(unsigned __int8)v14] ^ dword_4185D8[HIBYTE(v14)] ^ dword_418DD8[BYTE1(v14)] ^ dword_4189D8[BYTE2(v14)];
      --v5;
    }
    while ( v5 );
  }
  if ( v3 >= 4 )
  {
    v15 = v3 >> 2;
    do
    {
      v16 = *(_DWORD *)v17 ^ i;
      v17 += 4;
      v3 -= 4;
      --v15;
      i = dword_4191D8[(unsigned __int8)v16] ^ dword_4185D8[HIBYTE(v16)] ^ dword_418DD8[BYTE1(v16)] ^ dword_4189D8[BYTE2(v16)];
    }
    while ( v15 );
  }
  for ( ; v3; --v3 )
    i = dword_4185D8[(unsigned __int8)(i ^ *v17++)] ^ (i >> 8);
  return ~i;
}

//----- (00414650) --------------------------------------------------------
void *__cdecl sub_414650(int a1, int a2, int a3)
{
  return malloc(a3 * a2);
}

//----- (00414670) --------------------------------------------------------
void __cdecl sub_414670(int a1, void *Block)
{
  free(Block);
}

//----- (00414680) --------------------------------------------------------
_DWORD *__cdecl inflate_fast(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  unsigned int v3; // ebx
  unsigned __int8 *v4; // ebp
  _BYTE *v5; // esi
  unsigned int v6; // edi
  int v7; // edx
  int v8; // eax
  unsigned int v9; // eax
  char v10; // dl
  unsigned int v11; // edx
  int v12; // eax
  int v13; // edx
  unsigned __int8 *v14; // ebp
  int v15; // eax
  unsigned int v16; // edx
  char v17; // al
  unsigned int v18; // eax
  int v19; // edx
  int v20; // edx
  int v21; // edx
  unsigned int v22; // edx
  char v23; // cl
  _BYTE *v24; // eax
  unsigned int v25; // ebp
  int v26; // ecx
  _BYTE *v27; // ecx
  char v28; // al
  int v29; // edx
  unsigned int v30; // ebp
  char v31; // dl
  unsigned int v32; // ebp
  char v33; // al
  char v34; // al
  unsigned int v35; // ebp
  char v36; // al
  _BYTE *v37; // ecx
  _BYTE *v38; // esi
  char v39; // dl
  char v40; // al
  char v41; // dl
  _BYTE *v42; // ecx
  unsigned int v43; // edx
  _BYTE *v44; // eax
  char v45; // cl
  _BYTE *v46; // eax
  char v47; // dl
  _BYTE *v48; // esi
  char v49; // cl
  unsigned int v50; // ecx
  char v51; // dl
  _BYTE *v52; // eax
  unsigned __int8 *v53; // ebp
  unsigned int v54; // edi
  _DWORD *result; // eax
  unsigned __int8 *v56; // [esp+10h] [ebp-3Ch]
  unsigned int v57; // [esp+14h] [ebp-38h]
  _DWORD *v58; // [esp+18h] [ebp-34h]
  unsigned int v59; // [esp+1Ch] [ebp-30h]
  unsigned int v60; // [esp+1Ch] [ebp-30h]
  unsigned __int16 v61; // [esp+1Eh] [ebp-2Eh]
  int v62; // [esp+20h] [ebp-2Ch]
  int v63; // [esp+24h] [ebp-28h]
  int v64; // [esp+28h] [ebp-24h]
  unsigned int v65; // [esp+2Ch] [ebp-20h]
  int v66; // [esp+30h] [ebp-1Ch]
  _BYTE *v67; // [esp+38h] [ebp-14h]
  unsigned int v68; // [esp+3Ch] [ebp-10h]
  int v69; // [esp+40h] [ebp-Ch]
  unsigned int v70; // [esp+44h] [ebp-8h]
  int v71; // [esp+48h] [ebp-4h]
  unsigned int v72; // [esp+54h] [ebp+8h]

  v2 = (_DWORD *)a1[7];
  v3 = v2[14];
  v4 = (unsigned __int8 *)(*a1 - 1);
  v57 = (unsigned int)&v4[a1[1] - 5];
  v5 = (_BYTE *)(a1[3] - 1);
  v67 = &v5[a1[4] - a2];
  v65 = (unsigned int)&v5[a1[4] - 257];
  v64 = v2[10];
  v68 = v2[11];
  v70 = v2[12];
  v69 = v2[13];
  v62 = v2[19];
  v63 = v2[20];
  v58 = v2;
  v6 = v2[15];
  v7 = (1 << v2[21]) - 1;
  v56 = v4;
  v71 = v7;
  v66 = (1 << v2[22]) - 1;
  while ( 1 )
  {
    if ( v6 < 0xF )
    {
      v8 = v4[1];
      v4 += 2;
      v56 = v4;
      v3 += (*v4 << (v6 + 8)) + (v8 << v6);
      v6 += 16;
    }
    v9 = *(_DWORD *)(v62 + 4 * (v3 & v7));
    v10 = v9;
    v3 >>= SBYTE1(v9);
    v6 -= BYTE1(v9);
    if ( !(_BYTE)v9 )
    {
LABEL_8:
      *++v5 = BYTE2(v9);
      goto LABEL_47;
    }
    while ( (v10 & 0x10) == 0 )
    {
      if ( (v10 & 0x40) != 0 )
      {
        if ( (v10 & 0x20) != 0 )
        {
          *v58 = 11;
          goto LABEL_61;
        }
        a1[6] = "invalid literal/length code";
LABEL_60:
        *v58 = 27;
        goto LABEL_61;
      }
      v9 = *(_DWORD *)(v62 + 4 * (HIWORD(v9) + (v3 & ((1 << v10) - 1))));
      v10 = v9;
      v3 >>= SBYTE1(v9);
      v6 -= BYTE1(v9);
      if ( !(_BYTE)v9 )
        goto LABEL_8;
    }
    v11 = v10 & 0xF;
    v72 = HIWORD(v9);
    if ( v11 )
    {
      if ( v6 < v11 )
      {
        v12 = *++v4;
        v56 = v4;
        v3 += v12 << v6;
        v6 += 8;
      }
      v72 += v3 & ((1 << v11) - 1);
      v3 >>= v11;
      v6 -= v11;
    }
    if ( v6 < 0xF )
    {
      v13 = v4[1];
      v14 = v4 + 1;
      v15 = v14[1];
      v4 = v14 + 1;
      v56 = v4;
      v3 += (v15 << (v6 + 8)) + (v13 << v6);
      v6 += 16;
    }
    v16 = *(_DWORD *)(v63 + 4 * (v3 & v66));
    v17 = v16;
    v3 >>= SBYTE1(v16);
    v6 -= BYTE1(v16);
    v61 = HIWORD(v16);
    if ( (v16 & 0x10) == 0 )
    {
      while ( (v17 & 0x40) == 0 )
      {
        v16 = *(_DWORD *)(v63 + 4 * (v61 + (v3 & ((1 << v17) - 1))));
        v17 = v16;
        v3 >>= SBYTE1(v16);
        v6 -= BYTE1(v16);
        v61 = HIWORD(v16);
        if ( (v16 & 0x10) != 0 )
          goto LABEL_18;
      }
      a1[6] = "invalid distance code";
      goto LABEL_60;
    }
LABEL_18:
    v18 = v17 & 0xF;
    v59 = HIWORD(v16);
    if ( v6 < v18 )
    {
      v19 = *++v4;
      v20 = v19 << v6;
      v6 += 8;
      v56 = v4;
      v3 += v20;
      if ( v6 < v18 )
      {
        v21 = *++v4;
        v56 = v4;
        v3 += v21 << v6;
        v6 += 8;
      }
    }
    v6 -= v18;
    v22 = (v3 & ((1 << v18) - 1)) + v59;
    v23 = v18;
    v24 = (_BYTE *)(v5 - v67);
    v3 >>= v23;
    v60 = v22;
    if ( v22 > v5 - v67 )
    {
      v25 = v22 - (_DWORD)v24;
      if ( v22 - (unsigned int)v24 > v68 )
      {
        v4 = v56;
        a1[6] = "invalid distance too far back";
        *v58 = 27;
LABEL_61:
        v43 = v57;
        break;
      }
      v26 = v69 - 1;
      if ( v70 )
      {
        if ( v70 < v25 )
        {
          v29 = v64 + v70 - v25;
          v30 = v25 - v70;
          v27 = (_BYTE *)(v29 + v26);
          if ( v30 < v72 )
          {
            v72 -= v30;
            do
            {
              v31 = *++v27;
              ++v5;
              --v30;
              *v5 = v31;
            }
            while ( v30 );
            v27 = (_BYTE *)(v69 - 1);
            if ( v70 < v72 )
            {
              v72 -= v70;
              v32 = v70;
              do
              {
                v33 = *++v27;
                ++v5;
                --v32;
                *v5 = v33;
              }
              while ( v32 );
              v27 = &v5[-v60];
            }
          }
          goto LABEL_40;
        }
        v27 = (_BYTE *)(v70 - v25 + v26);
        if ( v25 < v72 )
        {
          v72 -= v25;
          do
          {
            v34 = *++v27;
            ++v5;
            --v25;
            *v5 = v34;
          }
          while ( v25 );
          goto LABEL_39;
        }
      }
      else
      {
        v27 = (_BYTE *)(v64 - v25 + v26);
        if ( v25 < v72 )
        {
          v72 -= v25;
          do
          {
            v28 = *++v27;
            ++v5;
            --v25;
            *v5 = v28;
          }
          while ( v25 );
LABEL_39:
          v27 = &v5[-v22];
          goto LABEL_40;
        }
      }
LABEL_40:
      if ( v72 > 2 )
      {
        v35 = (v72 - 3) / 3 + 1;
        do
        {
          v36 = v27[1];
          v72 -= 3;
          v37 = v27 + 1;
          v38 = v5 + 1;
          *v38 = v36;
          v39 = *++v37;
          *++v38 = v39;
          v40 = v37[1];
          v27 = v37 + 1;
          v5 = v38 + 1;
          --v35;
          *v5 = v40;
        }
        while ( v35 );
      }
      if ( v72 )
      {
        v41 = v27[1];
        v42 = v27 + 1;
        *++v5 = v41;
        if ( v72 > 1 )
          *++v5 = v42[1];
      }
      v4 = v56;
      goto LABEL_47;
    }
    v44 = &v5[-v22];
    do
    {
      v45 = v44[1];
      v46 = v44 + 1;
      v5[1] = v45;
      v47 = *++v46;
      v48 = v5 + 2;
      *v48 = v47;
      v49 = v46[1];
      v44 = v46 + 1;
      v5 = v48 + 1;
      *v5 = v49;
      v50 = v72 - 3;
      v72 -= 3;
    }
    while ( v72 > 2 );
    if ( v50 )
    {
      v51 = v44[1];
      v52 = v44 + 1;
      *++v5 = v51;
      if ( v50 > 1 )
        *++v5 = v52[1];
    }
LABEL_47:
    v43 = v57;
    if ( (unsigned int)v4 >= v57 || (unsigned int)v5 >= v65 )
      break;
    v7 = v71;
  }
  v53 = &v4[-(v6 >> 3)];
  v54 = v6 - 8 * (v6 >> 3);
  *a1 = v53 + 1;
  a1[3] = v5 + 1;
  a1[4] = v65 - (_DWORD)v5 + 257;
  result = v58;
  a1[1] = v43 - (_DWORD)v53 + 5;
  v58[15] = v54;
  v58[14] = ((1 << v54) - 1) & v3;
  return result;
}

//----- (00414B40) --------------------------------------------------------
int __cdecl inflate_table(int a1, int a2, unsigned int a3, _DWORD **a4, unsigned int *a5, _WORD *a6)
{
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v10; // esi
  int v11; // edx
  unsigned int i; // eax
  unsigned int j; // eax
  __int16 v14; // cx
  unsigned int k; // eax
  unsigned int v16; // ebp
  unsigned int v17; // ebx
  int v18; // eax
  int v19; // eax
  int v20; // edx
  _DWORD *v21; // ecx
  unsigned int v22; // edx
  unsigned int l; // eax
  int v24; // esi
  char v25; // cl
  unsigned int v26; // edx
  int v27; // eax
  unsigned __int16 *v28; // esi
  int v29; // eax
  _DWORD *v30; // esi
  unsigned int m; // eax
  int v32; // [esp+Ch] [ebp-8Ch]
  int v33; // [esp+Ch] [ebp-8Ch]
  unsigned int v34; // [esp+10h] [ebp-88h]
  unsigned int v35; // [esp+14h] [ebp-84h]
  _WORD *v36; // [esp+18h] [ebp-80h]
  unsigned int v37; // [esp+1Ch] [ebp-7Ch]
  _DWORD *v38; // [esp+20h] [ebp-78h]
  unsigned int v39; // [esp+24h] [ebp-74h]
  char *v40; // [esp+28h] [ebp-70h]
  int v41; // [esp+2Ch] [ebp-6Ch]
  int v42; // [esp+30h] [ebp-68h]
  char *v43; // [esp+34h] [ebp-64h]
  int v44; // [esp+3Ch] [ebp-5Ch]
  int v45; // [esp+40h] [ebp-58h]
  int v46; // [esp+54h] [ebp-44h] BYREF
  int v47; // [esp+58h] [ebp-40h]
  int v48[6]; // [esp+5Ch] [ebp-3Ch]
  __int16 v49; // [esp+76h] [ebp-22h]

  v36 = a6;
  v6 = 0;
  v46 = 0;
  v47 = 0;
  v48[0] = 0;
  v48[1] = 0;
  v48[2] = 0;
  v48[3] = 0;
  v48[4] = 0;
  for ( v48[5] = 0; v6 < a3; ++v6 )
    ++*((_WORD *)&v46 + *(unsigned __int16 *)(a2 + 2 * v6));
  v7 = *a5;
  v34 = *a5;
  v8 = 15;
  do
  {
    if ( *((_WORD *)&v46 + v8) )
      break;
    --v8;
  }
  while ( v8 );
  v37 = v8;
  if ( v7 > v8 )
  {
    v34 = v8;
    v7 = v8;
  }
  if ( !v8 )
  {
    *(*a4)++ = 320;
    *(*a4)++ = 320;
    *a5 = 1;
    return 0;
  }
  v10 = 1;
  while ( !*((_WORD *)&v46 + v10) )
  {
    if ( *((_WORD *)&v46 + v10 + 1) )
    {
      ++v10;
      break;
    }
    if ( *((_WORD *)&v47 + v10) )
    {
      v10 += 2;
      break;
    }
    if ( *((_WORD *)&v47 + v10 + 1) )
    {
      v10 += 3;
      break;
    }
    if ( *((_WORD *)v48 + v10) )
    {
      v10 += 4;
      break;
    }
    v10 += 5;
    if ( v10 > 0xF )
      break;
  }
  if ( v7 < v10 )
    v34 = v10;
  v11 = 1;
  for ( i = 1; i <= 0xF; ++i )
  {
    v11 = 2 * v11 - *((unsigned __int16 *)&v46 + i);
    if ( v11 < 0 )
      return -1;
  }
  if ( v11 > 0 && (!a1 || v8 != 1) )
    return -1;
  v49 = 0;
  for ( j = 2; j < 0x1E; *(_WORD *)((char *)&v48[6] + j) = v14 )
  {
    v14 = *(_WORD *)((char *)&v46 + j) + *(_WORD *)((char *)&v48[6] + j);
    j += 2;
  }
  for ( k = 0; k < a3; ++k )
  {
    if ( *(_WORD *)(a2 + 2 * k) )
      a6[(unsigned __int16)(*((_WORD *)&v48[6] + *(unsigned __int16 *)(a2 + 2 * k)))++] = k;
  }
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v40 = (char *)&unk_41A6B0 - 514;
      v43 = (char *)&unk_41A6F0 - 514;
      v41 = 256;
    }
    else
    {
      v40 = (char *)&unk_41A730;
      v43 = (char *)&unk_41A770;
      v41 = -1;
    }
  }
  else
  {
    v43 = (char *)a6;
    v40 = (char *)a6;
    v41 = 19;
  }
  v38 = *a4;
  v16 = 0;
  v17 = 0;
  v35 = v10;
  v42 = -1;
  v45 = 1 << v34;
  v39 = 1 << v34;
  v44 = (1 << v34) - 1;
  if ( a1 == 1 && (unsigned int)(1 << v34) >= 0x5B0 )
    return 1;
  while ( 1 )
  {
    if ( (unsigned __int16)*v36 >= v41 )
    {
      if ( (unsigned __int16)*v36 <= v41 )
      {
        LOBYTE(v32) = 96;
        HIWORD(v32) = 0;
      }
      else
      {
        v18 = 2 * (unsigned __int16)*v36;
        LOBYTE(v32) = v43[v18];
        HIWORD(v32) = *(_WORD *)&v40[v18];
      }
    }
    else
    {
      LOBYTE(v32) = 0;
      HIWORD(v32) = *v36;
    }
    v19 = v45;
    v20 = 1 << (v35 - v17);
    v21 = &v38[v45 + (v16 >> v17)];
    do
    {
      v19 -= v20;
      v21 -= v20;
      BYTE1(v32) = v35 - v17;
      *v21 = v32;
    }
    while ( v19 );
    v22 = v35;
    for ( l = 1 << (v35 - 1); (l & v16) != 0; l >>= 1 )
      ;
    if ( l )
      v16 = l + (v16 & (l - 1));
    else
      v16 = 0;
    --*((_WORD *)&v46 + v35);
    ++v36;
    if ( *((_WORD *)&v46 + v35) )
      goto LABEL_59;
    if ( v35 == v37 )
      break;
    v22 = *(unsigned __int16 *)(a2 + 2 * (unsigned __int16)*v36);
    v35 = v22;
LABEL_59:
    if ( v22 > v34 )
    {
      v24 = v16 & v44;
      if ( (v16 & v44) != v42 )
      {
        if ( !v17 )
          v17 = v34;
        v25 = v35 - v17;
        v38 += v45;
        v26 = v35;
        v27 = 1 << (v35 - v17);
        if ( v35 < v37 )
        {
          v28 = (unsigned __int16 *)&v46 + v35;
          do
          {
            v29 = v27 - *v28;
            if ( v29 <= 0 )
              break;
            ++v26;
            ++v25;
            ++v28;
            v27 = 2 * v29;
          }
          while ( v26 < v37 );
          v24 = v16 & v44;
        }
        v39 += 1 << v25;
        v45 = 1 << v25;
        if ( a1 == 1 && v39 >= 0x5B0 )
          return 1;
        LOBYTE((*a4)[v24]) = v25;
        BYTE1((*a4)[v24]) = v34;
        v42 = v24;
        HIWORD((*a4)[v24]) = v38 - *a4;
      }
    }
  }
  LOBYTE(v33) = 64;
  BYTE1(v33) = v35 - v17;
  HIWORD(v33) = 0;
  if ( v16 )
  {
    v30 = v38;
    do
    {
      if ( v17 && (v16 & v44) != v42 )
      {
        v30 = *a4;
        v17 = 0;
        BYTE1(v33) = v34;
        LOBYTE(v22) = v34;
      }
      v30[v16 >> v17] = v33;
      for ( m = 1 << (v22 - 1); (m & v16) != 0; m >>= 1 )
        ;
      if ( !m )
        break;
      v16 = m + (v16 & (m - 1));
    }
    while ( v16 );
  }
  *a4 += v39;
  *a5 = v34;
  return 0;
}

//----- (00415030) --------------------------------------------------------
unsigned int __cdecl adler32(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  unsigned int v4; // edi
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // edi
  unsigned int result; // eax
  unsigned __int8 *v9; // esi
  unsigned int v10; // ebp
  int v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // edi
  unsigned int v14; // ecx
  unsigned int v15; // edi
  unsigned int v16; // ecx
  unsigned int v17; // edi
  unsigned int v18; // ecx
  unsigned int v19; // edi
  unsigned int v20; // ecx
  unsigned int v21; // edi
  unsigned int v22; // ecx
  unsigned int v23; // edi
  unsigned int v24; // ecx
  int v25; // edi
  unsigned int v26; // ecx
  int v27; // edi
  unsigned int v28; // ecx
  int v29; // edi
  int v30; // ecx
  int v31; // edi
  int v32; // ecx
  int v33; // edi
  int v34; // ecx
  int v35; // edi
  int v36; // ecx
  int v37; // edi
  int v38; // ecx
  int v39; // edi
  int v40; // ecx
  int v41; // edi
  unsigned int v42; // eax
  unsigned int v43; // ecx
  unsigned int v44; // edi
  unsigned int v45; // ecx
  unsigned int v46; // edi
  unsigned int v47; // ecx
  unsigned int v48; // edi
  unsigned int v49; // ecx
  unsigned int v50; // edi
  unsigned int v51; // ecx
  unsigned int v52; // edi
  unsigned int v53; // ecx
  unsigned int v54; // edi
  unsigned int v55; // ecx
  int v56; // edi
  unsigned int v57; // ecx
  int v58; // edi
  unsigned int v59; // ecx
  int v60; // edi
  int v61; // ecx
  int v62; // edi
  int v63; // ecx
  int v64; // edi
  int v65; // ecx
  int v66; // edi
  int v67; // ecx
  int v68; // edi
  int v69; // ecx
  int v70; // edi
  int v71; // ecx
  int v72; // edi

  v3 = a3;
  v4 = HIWORD(a1);
  v5 = (unsigned __int16)a1;
  if ( a3 == 1 )
  {
    v6 = *a2 + (unsigned __int16)a1;
    if ( v6 >= 0xFFF1 )
      v6 -= 65521;
    v7 = v6 + v4;
    if ( v7 >= 0xFFF1 )
      v7 -= 65521;
    result = v6 | (v7 << 16);
  }
  else
  {
    v9 = a2;
    if ( a2 )
    {
      if ( a3 >= 0x10 )
      {
        if ( a3 >= 0x15B0 )
        {
          v10 = a3 / 0x15B0;
          do
          {
            v3 -= 5552;
            v11 = 347;
            do
            {
              v12 = *v9 + v5;
              v13 = v12 + v4;
              v14 = v9[1] + v12;
              v15 = v14 + v13;
              v16 = v9[2] + v14;
              v17 = v16 + v15;
              v18 = v9[3] + v16;
              v19 = v18 + v17;
              v20 = v9[4] + v18;
              v21 = v20 + v19;
              v22 = v9[5] + v20;
              v23 = v22 + v21;
              v24 = v9[6] + v22;
              v25 = v24 + v23;
              v26 = v9[7] + v24;
              v27 = v26 + v25;
              v28 = v9[8] + v26;
              v29 = v28 + v27;
              v30 = v9[9] + v28;
              v31 = v30 + v29;
              v32 = v9[10] + v30;
              v33 = v32 + v31;
              v34 = v9[11] + v32;
              v35 = v34 + v33;
              v36 = v9[12] + v34;
              v37 = v36 + v35;
              v38 = v9[13] + v36;
              v39 = v38 + v37;
              v40 = v9[14] + v38;
              v41 = v40 + v39;
              v5 = v9[15] + v40;
              v4 = v5 + v41;
              v9 += 16;
              --v11;
            }
            while ( v11 );
            v5 %= 0xFFF1u;
            v4 %= 0xFFF1u;
            --v10;
          }
          while ( v10 );
        }
        if ( v3 )
        {
          if ( v3 >= 0x10 )
          {
            v42 = v3 >> 4;
            do
            {
              v43 = *v9 + v5;
              v44 = v43 + v4;
              v45 = v9[1] + v43;
              v46 = v45 + v44;
              v47 = v9[2] + v45;
              v48 = v47 + v46;
              v49 = v9[3] + v47;
              v50 = v49 + v48;
              v51 = v9[4] + v49;
              v52 = v51 + v50;
              v53 = v9[5] + v51;
              v54 = v53 + v52;
              v55 = v9[6] + v53;
              v56 = v55 + v54;
              v57 = v9[7] + v55;
              v58 = v57 + v56;
              v59 = v9[8] + v57;
              v60 = v59 + v58;
              v61 = v9[9] + v59;
              v62 = v61 + v60;
              v63 = v9[10] + v61;
              v64 = v63 + v62;
              v65 = v9[11] + v63;
              v66 = v65 + v64;
              v67 = v9[12] + v65;
              v68 = v67 + v66;
              v69 = v9[13] + v67;
              v70 = v69 + v68;
              v71 = v9[14] + v69;
              v72 = v71 + v70;
              v5 = v9[15] + v71;
              v3 -= 16;
              v4 = v5 + v72;
              v9 += 16;
              --v42;
            }
            while ( v42 );
          }
          for ( ; v3; v4 += v5 )
          {
            v5 += *v9;
            --v3;
            ++v9;
          }
          v5 %= 0xFFF1u;
          v4 %= 0xFFF1u;
        }
        result = v5 | (v4 << 16);
      }
      else
      {
        if ( a3 )
        {
          do
          {
            v5 += *v9;
            --v3;
            ++v9;
            v4 += v5;
          }
          while ( v3 );
        }
        if ( v5 >= 0xFFF1 )
          v5 -= 65521;
        result = v5 | ((v4 + 15 * (v4 / 0xFFF1)) << 16);
      }
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 415030: too many cbuild loops

// nfuncs=230 queued=179 decompiled=179 lumina nreq=0 worse=0 better=0
// ALL OK, 179 function(s) have been successfully decompiled
