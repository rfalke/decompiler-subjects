// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0C00:0100: void fn0C00_0100(Register byte ch, Register cui16 bx, Register (memptr (ptr16 Eq_7) word16) di)
void fn0C00_0100(byte ch, cui16 bx, word16 Eq_7::* di)
{
	struct Eq_6 * cs;
	struct Eq_7 * wLoc02;
	word16 wLoc04;
	uint16 wLoc06;
	uint16 wLoc08;
	Eq_11 wLoc0A;
	__syscall<byte>(0x10);
	__out<byte>(0x03C8, 0x01);
	byte ah_13 = 0x00;
	word16 cx_176 = SEQ(ch, 0x80);
	do
	{
		__out<byte>(969, ah_13 + 0x00);
		__out<byte>(969, 0x00);
		__out<byte>(969, 0x00);
		++ah_13;
		if (ah_13 == 0xC1)
			seg0C00->b0119 = 0xCC;
		--cx_176;
	} while (cx_176 != 0x00);
	byte ch_29 = SLICE(cs, byte, 8);
	byte cl_32 = (byte) cs;
	struct Eq_7 * cx_33 = SEQ(ch_29 + 0x30, cl_32);
	struct Eq_7 * cx_38 = SEQ(ch_29 + 0x31, cl_32);
	byte dh_153 = 0x06;
	word16 cx_41 = 0x0200;
	do
	{
		bx += 1663;
		cx_33->*di = bx & 1663;
		--cx_41;
		++di;
		byte ch_183 = SLICE(cx_41, byte, 8);
		byte cl_194 = (byte) cx_41;
	} while (cx_41 != 0x00);
	do
	{
		__syscall<byte>(0x10);
		word16 Eq_7::* si_57 = Eq_7::a0000;
		struct Eq_92 Eq_7::* di_131 = Eq_7::a0000;
		word16 cx_197 = SEQ(ch_183 + 0x01, cl_194);
		do
		{
			word16 ax_66 = cx_33->*si_57;
			byte ah_69 = SLICE(ax_66, byte, 8);
			cu8 al_70 = (byte) ax_66 + ah_69;
			++si_57;
			word16 ax_76 = SEQ(ah_69, al_70);
			if (al_70 >= 200)
			{
				byte ah_73 = -ah_69;
				ax_76 = SEQ(ah_73, al_70 + ah_73);
			}
			(cx_33->*di_131).t0000.u1 = ax_76;
			--cx_197;
			di_131 += 2;
			byte ch_218 = SLICE(cx_197, byte, 8);
		} while (cx_197 != 0x00);
		Eq_130 si_199 = 0x00;
		do
		{
			word16 cx_108 = SEQ(ch_218, 0x06);
			do
			{
				--cx_108;
				si_199 = (word16) si_199 + 2;
				Eq_137 ax_105 = (uint16) (cx_33->*si_199);
				ch_218 = SLICE(cx_108, byte, 8);
				byte cl_228 = (byte) cx_108;
			} while (cx_108 != 0x00);
			word16 dx_322;
			word16 bx_323;
			word16 cx_321;
			fn0C00_01A4(cx_38, 0x05, ax_105, wLoc0A, wLoc08, wLoc06, wLoc04, wLoc02, out cx_321, out dx_322, out bx_323);
		} while (si_199 < 0x01F8);
		wLoc02 = cx_33;
		wLoc04 = 0xA000;
		word16 cx_137 = SEQ(~0x00, cl_228);
		do
		{
			(0xA000->*di_131).t0000.u1 = (cx_38->*di_131).t0000.u1;
			di_131 += 2;
			--cx_137;
		} while (cx_137 != 0x00);
		int16 bx_143 = 0x0140;
		word16 cx_144 = cx_137 - 0x01;
		do
		{
			bx_143 = -bx_143;
			cu16 dx_154 = SEQ(dh_153, (word16) di_131[bx_143].t0000 + ((cx_38->*di_131).t0000).u0);
			byte dl_157 = (byte) (dx_154 >> 0x01);
			(cx_38->*di_131).bFFFFFEC1 = dl_157;
			di_131[319] = (struct Eq_92) dl_157;
			--cx_144;
			dh_153 = SLICE(dx_154 >> 0x01, byte, 8);
			++di_131;
			ch_183 = SLICE(cx_144, byte, 8);
			cl_194 = (byte) cx_144;
		} while (cx_144 != 0x00);
	} while (__in<byte>(SEQ(dh_153, 0x60)) != 0x01);
	bios_video_set_mode(0x03);
}

// 0C00:01A4: Register word16 fn0C00_01A4(Register (ptr16 Eq_7) fs, Stack word16 wArg02, Stack Eq_137 wArg04, Stack Eq_11 wArg06, Stack uint16 wArg08, Stack uint16 wArg0A, Stack word16 wArg0C, Stack (ptr16 Eq_7) wArg0E, Register out ptr16 cxOut, Register out ptr16 dxOut, Register out ptr16 bxOut)
// Called from:
//      fn0C00_0100
//      fn0C00_01A4
word16 fn0C00_01A4(struct Eq_7 * fs, word16 wArg02, Eq_137 wArg04, Eq_11 wArg06, uint16 wArg08, uint16 wArg0A, word16 wArg0C, struct Eq_7 * wArg0E, ptr16 & cxOut, ptr16 & dxOut, ptr16 & bxOut)
{
	if (wArg02 == 0x00)
		Mem103[fs:wArg04 *s 0x0140 + wArg06 + 64:byte] = 0x80;
	else
	{
		cu16 ax_45 = wArg0E + wArg0A;
		cu16 dx_47 = wArg0C + wArg08;
		uint16 cx_72;
		word16 dx_73;
		uint16 bx_74;
		word16 cx_178;
		word16 dx_179;
		word16 bx_180;
		fn0C00_01A4(fs, wArg02 - 0x01, wArg04, wArg06, bx_74, cx_72, dx_73, fn0C00_01A4(fs, wArg02 - 0x01, (dx_47 >> 0x01) + ((word16) wArg04 + wArg08 >> 0x01) >> 0x01, (ax_45 >> 0x01) + ((word16) wArg06 + wArg0A >> 0x01) >> 0x01, dx_47 >> 0x01, ax_45 >> 0x01, wArg0C, wArg0E, out cx_72, out dx_73, out bx_74), out cx_178, out dx_179, out bx_180);
	}
	cxOut = <invalid>;
	dxOut = <invalid>;
	bxOut = <invalid>;
	return <invalid>;
}

