/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// unsigned __int64 __usercall start@<edx:eax>(unsigned __int64 result@<edx:eax>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_400188; // weak
signed __int32 dword_4001A8[16278] =
{
  1610612957,
  1656228509,
  972378728,
  -1376379509,
  2068410527,
  -98594467,
  540158192,
  -282057763,
  230379572,
  1978806894,
  2001792936,
  2042350922,
  -666819749,
  1528718096,
  -81691031,
  2013926006,
  -1493523202,
  2038199010,
  -864435153,
  -1837593993,
  882409550,
  -471256201,
  -625299791,
  1001590263,
  -1816491271,
  1077377105,
  -716137088,
  1083302149,
  -352596276,
  -1156224055,
  242414306,
  1344495963,
  938000863,
  -585212770,
  -991496735,
  -1773898840,
  2054149819,
  1879533294,
  1484864580,
  786081535,
  11607372,
  638750642,
  -231282470,
  -1492687762,
  88447233,
  1552704424,
  1564560025,
  -1903899907,
  2084322075,
  1375785202,
  -433786066,
  890693156,
  897274422,
  -1877361578,
  -987762572,
  2147441762,
  941370188,
  -1421386259,
  1685452371,
  -322684678,
  -765671557,
  -2006563768,
  -1120976296,
  60773585,
  -1042017888,
  1969657685,
  -461563760,
  -570568774,
  -2065736797,
  -1269879167,
  -961656694,
  -1691429251,
  -1040847244,
  793241807,
  1661804780,
  634303060,
  1210909851,
  -118377448,
  409988308,
  526972162,
  1471436712,
  1158200014,
  -1024666039,
  578666472,
  224467315,
  -632435471,
  -54274153,
  62886029,
  1207198525,
  131088039,
  2031078666,
  779450678,
  -1751727187,
  -536736079,
  -429969522,
  1419226778,
  584776651,
  1843821908,
  -347810955,
  -1053177783,
  -535636349,
  -1732495242,
  1815348251,
  1685917402,
  435936606,
  1023876284,
  1770145255,
  656425070,
  1048865510,
  -1265773818,
  -875198723,
  971975450,
  -711467053,
  946007380,
  -2132942470,
  -1318035847,
  -980556288,
  -360014123,
  408156867,
  894024551,
  279486518,
  1959021392,
  -275357577,
  917948631,
  -1535059657,
  1538811603,
  896767356,
  -418801507,
  -1168325348,
  -757598810,
  332877012,
  -1479378079,
  117777904,
  960137005,
  1607061698,
  -1883906937,
  1993527659,
  679855350,
  -858292847,
  -16760144,
  -1635641426,
  -1274503690,
  875890651,
  1884871317,
  415932218,
  -665063641,
  -1686327374,
  1586286088,
  -1794196910,
  2106154863,
  
}; // weak
int dword_420000[338]; // weak
char byte_42054B[]; // weak
int dword_42054C[1676608]; // weak


//----- (00400002) --------------------------------------------------------
unsigned __int64 __usercall start@<edx:eax>(unsigned __int64 result@<edx:eax>)
{
  unsigned int v1; // edi
  unsigned int v3; // ebp
  _DWORD *v4; // esi
  unsigned int v5; // ecx
  bool v6; // sf
  char v7; // cc
  int v8; // ecx
  _WORD *v9; // edi
  bool v10; // pf
  unsigned int v11; // eax
  _DWORD *v12; // esi
  bool v13; // cf
  int v14; // ecx
  _BYTE *v15; // edi
  _BYTE *v16; // esi
  unsigned int v17; // ebp
  bool v18; // zf
  int v19; // eax
  bool v20; // zf
  char v21; // cl
  int v22; // edi
  int v23; // eax
  int v24; // eax
  unsigned __int64 v26; // [esp-34h] [ebp-44h]
  int v27; // [esp-2Ch] [ebp-3Ch]
  int v28; // [esp-28h] [ebp-38h]
  unsigned int v29; // [esp-20h] [ebp-30h]
  _BYTE *v30; // [esp-1Ch] [ebp-2Ch]
  _BYTE *v31; // [esp-18h] [ebp-28h]
  unsigned __int64 v32; // [esp-14h] [ebp-24h]
  unsigned int v33; // [esp-Ch] [ebp-1Ch]
  int v34; // [esp-8h] [ebp-18h]
  unsigned int v35; // [esp+0h] [ebp-10h]
  unsigned int v36; // [esp+4h] [ebp-Ch]
  _DWORD *v37; // [esp+8h] [ebp-8h]
  signed __int32 *v38; // [esp+Ch] [ebp-4h]

  v38 = dword_420000;
  LODWORD(result) = 1;
  v1 = 0;
  _EBX = 2;
  v3 = 0;
  v4 = (_DWORD *)&unk_400188;
  v5 = 0;
  do
  {
LABEL_14:
    v37 = v4;
    v36 = v1;
    v35 = v3;
    v34 = _EBX;
    v33 = v5;
    v32 = result;
    v11 = *v4;
    v12 = v4 + 1;
    v13 = v11 < v1;
    LODWORD(result) = v11 - v1;
    if ( (_DWORD)result )
    {
      v14 = v1 & 7;
      v15 = (char *)v38 + (v1 >> 3);
      v35 = 10;
      LODWORD(result) = *v12;
      v16 = v12 + 1;
      v17 = 0;
      goto LABEL_16;
    }
    while ( 1 )
    {
      v9 = (_WORD *)byte_42054B;
      v8 = 78642401;
      if ( !v13 )
        break;
      v21 = v3;
      v22 = 2 * (result % 0x4AFFCE1) + 4326732;
      if ( !byte_42054B[2 * (result % 0x4AFFCE1)] || !(*((_BYTE *)dword_42054C + 2 * (result % 0x4AFFCE1)) | BYTE1(v3)) )
        v21 = v3 + 2;
      v23 = -1;
      do
      {
        *(&v35 + v23) += *(unsigned __int8 *)(v22 + v23) << v21;
        v7 = (v23 + 1 < 0) ^ __OFADD__(1, v23) | (v23 == -1);
        ++v23;
      }
      while ( v7 );
      v24 = v23 - _EBX;
      if ( v24 >= 0 )
      {
        _EDI = v22 - 1;
        ++*(_BYTE *)(_EDI + v24);
        v18 = *(_BYTE *)(_EDI + _EBX) >> 1 == 0;
        *(_BYTE *)(_EDI + _EBX) >>= 1;
        if ( v18 )
          __asm { rcl     byte ptr [edi+ebx], 1 }
      }
      result = v26;
      v14 = v27;
      _EBX = v28;
      v17 = v29;
      v15 = v30;
      v16 = v31 + 1;
LABEL_16:
      v3 = v17 - 1;
      do
      {
        ++v3;
        v13 = __CFADD__((_DWORD)result, (_DWORD)result);
        v18 = 2 * (_DWORD)result == 0;
        LODWORD(result) = 2 * result;
      }
      while ( v13 );
      if ( v18 )
      {
        v6 = _EBX - 1 < 0;
        v7 = _EBX <= 1;
        LODWORD(result) = v32;
        v5 = v33;
        _EBX = v34;
        v3 = v35;
        v1 = v36;
        v4 = v37;
        if ( v7 )
        {
          HIDWORD(result) = v38;
          if ( !v6 )
          {
            v37 = (_DWORD *)v36;
            _bittestandset(v38, v36 ^ 7);
            v1 = (unsigned int)v37;
          }
          ++v1;
        }
        else
        {
          while ( (result & 0x80000000) == 0i64 )
          {
            v5 += _bittest(dword_4001A8, v3++) + v5;
            LODWORD(result) = 2 * result;
          }
          v37 = (_DWORD *)result;
          LODWORD(result) = HIDWORD(v32) * (unsigned __int64)(unsigned int)result / (unsigned int)(HIDWORD(v32) + v34);
          _EBX = 0;
          HIDWORD(result) = v37;
          if ( v5 >= (unsigned int)result )
          {
            v5 -= result;
            HIDWORD(result) = result;
            LODWORD(result) = (char *)v37 - result;
            _EBX = 1;
          }
        }
        goto LABEL_14;
      }
      v31 = v16;
      v30 = v15;
      v29 = v3;
      v28 = _EBX;
      v27 = v14;
      v26 = result;
      LOBYTE(result) = *v16;
      v12 = v16 + 1;
      HIDWORD(result) = (unsigned __int8)result;
LABEL_20:
      LOBYTE(result) = *v15 ^ result;
      v19 = __ROL4__(result, 9);
      LOBYTE(v19) = *v15 + v19;
      LODWORD(result) = v19 - 1;
      do
      {
        --v15;
        v13 = __CFADD__(BYTE4(result), BYTE4(result));
        v20 = 2 * BYTE4(result) == 0;
        BYTE4(result) *= 2;
        if ( v13 )
          goto LABEL_20;
      }
      while ( !v20 );
      LODWORD(result) = __ROR4__(result, v14);
      LOBYTE(result) = v14 + result;
      v13 = 1;
    }
    while ( v8 )
    {
      *v9++ = result;
      --v8;
    }
    v10 = __SETP__(*(_BYTE *)v12 | result, 0);
    result = v26;
    v5 = v27;
    _EBX = v28;
    v3 = v29;
    v1 = (unsigned int)v30;
    v4 = v31 + 16;
  }
  while ( !v10 );
  return result;
}
// 400002: could not find valid save-restore pair for ebx
// 400002: could not find valid save-restore pair for ebp
// 400002: could not find valid save-restore pair for edi
// 4000DC: variable 'v26' is possibly undefined
// 4000DC: variable 'v27' is possibly undefined
// 4000DC: variable 'v28' is possibly undefined
// 4000DC: variable 'v29' is possibly undefined
// 4000DC: variable 'v30' is possibly undefined
// 4000DD: variable 'v31' is possibly undefined
// 4001A8: using guessed type signed __int32 dword_4001A8[16278];
// 420000: using guessed type int dword_420000[338];
// 42054C: using guessed type int dword_42054C[1676608];

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
