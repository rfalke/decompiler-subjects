// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

T_285 g_t807D100 = // 0807D100;
T_61 g_t807D104 = ;
T_56 g_t807D108 = ;
T_64491 g_t807D160 = // 0807D160;
T_285 g_t807D280 = // 0807D280;
T_64675 g_t807D284 = ;
T_64687 g_t807D288 = ;
T_64690 g_t807D28C = ;
T_64693 g_t807D290 = ;
T_285 g_t807D294 = // 0807D294;
T_65769 g_t807D298 = ;
T_65055 g_t807D29C = // 0807D29C;
T_285 g_t807D2A0 = // 0807D2A0;
T_168 g_t807D2A4 = ;
T_65371 g_t807D2A8 = // 0807D2A8;
T_65435 g_t807D2AC = ;
T_168 g_t807D2B0 = ;
T_65459 g_t807D2B4 = ;
T_65503 g_t807D2B8 = ;
T_66834 g_t807D324 = ;
T_66834 g_t807D368 = ;
T_66604 g_t807D3CC = ;
T_67408 g_t807D3D0 = ;
T_67482 g_t807D3D4 = ;
T_67428 g_t807D3D8 = ;
T_285 g_t807D3DC = // 0807D3DC;
T_68200 g_t807D3E0 = // 0807D3E0;
T_285 g_t807F400 = // 0807F400;
T_285 g_t807F420 = // 0807F420;
T_285 g_t807F424 = // 0807F424;
T_69145 g_t807F428 = // 0807F428;
T_69145 g_t807F42C = // 0807F42C;
T_69145 g_t807F430 = // 0807F430;
T_70032 g_t807F440 = ;
T_70448 g_t80803DC = ;
T_69264 g_t80803E0 = // 080803E0;
T_285 g_t80803E4 = // 080803E4;
T_48252 g_t80803E8 = // 080803E8;
T_48252 g_t80803EC = // 080803EC;
T_48252 g_t80803F0 = // 080803F0;
T_48252 g_t80803F4 = // 080803F4;
T_70802 g_t80803F8 = ;
T_48252 g_t80803FC = // 080803FC;
T_48252 g_t8080400 = // 08080400;
T_48252 g_t8080404 = // 08080404;
T_48252 g_t8080408 = // 08080408;
T_285 g_t808040C = // 0808040C;
T_285 g_t8080410 = // 08080410;
T_285 g_t8080414 = // 08080414;
T_285 g_t8080418 = // 08080418;
T_72901 g_t808041C = // 0808041C;
T_285 g_t8080428 = // 08080428;
T_285 g_t808042C = // 0808042C;
T_72913 g_t8080438 = ;
T_72913 g_t8080444 = ;
T_110677 g_t8080448 = ;
T_72894 g_t8080454 = ;
T_285 g_t8080458 = // 08080458;
T_285 g_t808045C = // 0808045C;
T_86877 g_t8081860 = ;
T_89870 g_t8081864 = ;
T_285 g_t8081868 = // 08081868;
T_285 g_t808186C = // 0808186C;
T_64618 g_t8081870 = ;
T_285 g_t8081874 = // 08081874;
T_285 g_t8081880 = // 08081880;
T_285 g_t8081884 = // 08081884;
T_285 g_t8081888 = // 08081888;
T_95963 g_t808188C = // 0808188C;
T_95963 g_t8081890 = // 08081890;
T_285 g_t80838AC = // 080838AC;
T_285 g_t80838B0 = // 080838B0;
T_285 g_t80838B4 = // 080838B4;
T_285 g_t80838B8 = // 080838B8;
T_285 g_t80838BC = // 080838BC;
T_285 g_t80838C0 = // 080838C0;
T_285 g_t80838C4 = // 080838C4;
T_285 g_t80838C8 = // 080838C8;
T_98683 g_t80838CC = ;
T_285 g_t80838E0 = // 080838E0;
T_285 g_t80838E4 = // 080838E4;
T_98312 g_t80838E8 = ;
T_285 g_t80838EC = // 080838EC;
T_285 g_t80838F0 = // 080838F0;
T_285 g_t80838F4 = // 080838F4;
T_285 g_t80838F8 = // 080838F8;
T_285 g_t80838FC = // 080838FC;
T_98393 g_t8083900 = // 08083900;
T_98393 g_t8083904 = // 08083904;
T_100203 g_t8083908 = ;
T_100203 g_t808390C = ;
T_100203 g_t8083910 = ;
T_285 g_t8083914 = // 08083914;
T_102354 g_t8083918 = ;
T_73009 g_t8083920 = ;
T_285 g_t8083928 = // 08083928;
T_72078 g_t8083930 = ;
T_285 g_t8083938 = // 08083938;
T_285 g_t808393C = // 0808393C;
T_285 g_t8083940 = // 08083940;
T_285 g_t8083944 = // 08083944;
T_285 g_t8083948 = // 08083948;
T_285 g_t808394C = // 0808394C;
T_111807 g_t8083994 = // 08083994;
T_285 g_t808399C = // 0808399C;
T_113654 g_t80839A0 = ;
T_113394 g_t80839A4 = ;
T_113401 g_t80839A8 = ;
T_113394 g_t80839AC = ;
T_113394 g_t80839B0 = ;
T_113394 g_t80839B4 = ;
T_113394 g_t80839B8 = ;
T_114299 g_t80839BC = ;
T_114446 g_t80839C0 = ;
T_109675 g_t80839C4 = ;
T_285 g_t80839C8 = // 080839C8;
T_285 g_t80839CC = // 080839CC;
T_64167 g_t80839E0 = // 080839E0;
T_64167 g_t8083A9C = // 08083A9C;
T_65109 g_t8083EA0 = ;
T_64167 g_t8083EA4 = // 08083EA4;
T_285 g_t8083EA8 = // 08083EA8;
T_285 g_t8083FC8 = // 08083FC8;
T_285 g_t8083FCC = // 08083FCC;
T_285 g_t8083FD0 = // 08083FD0;
T_72225 g_t8083FD4 = ;
T_285 g_t8083FD8 = // 08083FD8;
T_285 g_t8083FDC = // 08083FDC;
T_70810 g_t8083FE0 = ;
T_285 g_t8083FE8 = // 08083FE8;
T_285 g_t8083FEC = // 08083FEC;
T_72231 g_t8083FF0 = ;
T_285 g_t8083FF4 = // 08083FF4;
T_76305 g_t8084800 = ;
T_285 g_t8084804 = // 08084804;
T_285 g_t8084808 = // 08084808;
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

T_118809 g_t8073558 = ;
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

T_65777 g_t8073B34 = ;
T_64322 g_t8073E20 = // 08073E20;
T_64351 g_t8073E9C = // 08073E9C;
T_64355 g_t8073EA0 = // 08073EA0;
T_64360 g_t8073EA4 = // 08073EA4;
T_65515 g_t8073F18 = ;
T_2971 g_t80741F4 = ;
T_2976 g_t80741F8 = ;
T_3012 g_t80741FC = ;
T_3015 g_t8074200 = ;
T_3018 g_t8074204 = ;
T_3059 g_t8074208 = ;
T_3817 g_t8074338 = ;
T_3676 g_t8074340 = ;
T_285 g_t8074608 = // 08074608;
T_12714 g_t807460C = ;
T_12752 g_t8074610 = ;
T_12711 g_t8074614 = ;
T_12708 g_t8074618 = ;
T_12705 g_t807461C = ;
T_12702 g_t8074620 = ;
T_12699 g_t8074624 = ;
T_12696 g_t8074628 = ;
T_12693 g_t807462C = ;
T_12690 g_t8074630 = ;
T_12687 g_t8074634 = ;
T_12684 g_t8074638 = ;
T_13026 g_t807463C = ;
T_12681 g_t8074640 = ;
T_12678 g_t8074644 = ;
T_12675 g_t8074648 = ;
T_12757 g_t807464C = ;
T_12760 g_t8074650 = ;
T_12763 g_t8074654 = ;
T_12672 g_t8074658 = ;
T_12669 g_t807465C = ;
T_12764 g_t8074660 = ;
T_12767 g_t8074664 = ;
T_12770 g_t8074668 = ;
T_12666 g_t807466C = ;
T_12663 g_t8074670 = ;
T_12660 g_t8074674 = ;
T_12657 g_t8074678 = ;
T_12654 g_t807467C = ;
T_12651 g_t8074680 = ;
T_12648 g_t8074684 = ;
T_12645 g_t8074688 = ;
T_12642 g_t807468C = ;
T_12639 g_t8074690 = ;
T_12636 g_t8074694 = ;
T_12803 g_t8074698 = ;
T_12633 g_t807469C = ;
T_12630 g_t80746A0 = ;
T_12627 g_t80746A4 = ;
T_12624 g_t80746A8 = ;
T_12621 g_t80746AC = ;
T_12618 g_t80746B0 = ;
T_12615 g_t80746B4 = ;
T_12612 g_t80746B8 = ;
T_12609 g_t80746BC = ;
T_12606 g_t80746C0 = ;
T_12603 g_t80746C4 = ;
T_12600 g_t80746C8 = ;
T_12597 g_t80746CC = ;
T_12594 g_t80746D0 = ;
T_12591 g_t80746D4 = ;
T_12588 g_t80746D8 = ;
T_12585 g_t80746DC = ;
T_12582 g_t80746E0 = ;
T_12579 g_t80746E4 = ;
T_12576 g_t80746E8 = ;
T_12573 g_t80746EC = ;
T_12570 g_t80746F0 = ;
T_12567 g_t80746F4 = ;
T_12564 g_t80746F8 = ;
T_12561 g_t80746FC = ;
T_12558 g_t8074700 = ;
T_13038 g_t8074704 = ;
T_13041 g_t8074708 = ;
T_13051 g_t807470C = ;
T_13054 g_t8074710 = ;
T_13057 g_t8074714 = ;
T_13063 g_t8074718 = ;
T_13072 g_t807471C = ;
T_13075 g_t8074720 = ;
T_13078 g_t8074724 = ;
T_13081 g_t8074728 = ;
T_12555 g_t807472C = ;
T_12552 g_t8074730 = ;
T_12549 g_t8074734 = ;
T_12546 g_t8074738 = ;
T_12543 g_t807473C = ;
T_12540 g_t8074740 = ;
T_12537 g_t8074744 = ;
T_12534 g_t8074748 = ;
T_12808 g_t807474C = ;
T_12531 g_t8074750 = ;
T_12528 g_t8074754 = ;
T_12525 g_t8074758 = ;
T_12522 g_t807475C = ;
T_12519 g_t8074760 = ;
T_12516 g_t8074764 = ;
T_12513 g_t8074768 = ;
T_12510 g_t807476C = ;
T_12507 g_t8074770 = ;
T_12504 g_t8074774 = ;
T_12501 g_t8074778 = ;
T_12498 g_t807477C = ;
T_12495 g_t8074780 = ;
T_12492 g_t8074784 = ;
T_12489 g_t8074788 = ;
T_12486 g_t807478C = ;
T_12483 g_t8074790 = ;
T_12480 g_t8074794 = ;
T_12477 g_t8074798 = ;
T_12474 g_t807479C = ;
T_12471 g_t80747A0 = ;
T_12468 g_t80747A4 = ;
T_12465 g_t80747A8 = ;
T_12462 g_t80747AC = ;
T_12459 g_t80747B0 = ;
T_12456 g_t80747B4 = ;
T_12453 g_t80747B8 = ;
T_285 g_t80747BC = // 080747BC;
T_285 g_t80747C0 = // 080747C0;
T_12905 g_t80747C4 = ;
T_285 g_t80747C8 = // 080747C8;
T_12450 g_t80747CC = ;
T_12935 g_t80747D0 = ;
T_12447 g_t80747D4 = ;
T_12444 g_t80747D8 = ;
T_12441 g_t80747DC = ;
T_12438 g_t80747E0 = ;
T_12435 g_t80747E4 = ;
T_12432 g_t80747E8 = ;
T_12429 g_t80747EC = ;
T_12426 g_t80747F0 = ;
T_12938 g_t80747F4 = ;
T_12941 g_t80747F8 = ;
T_12944 g_t80747FC = ;
T_12947 g_t8074800 = ;
T_12987 g_t8074804 = ;
T_12990 g_t8074808 = ;
T_12993 g_t807480C = ;
T_12996 g_t8074810 = ;
T_12999 g_t8074814 = ;
T_13002 g_t8074818 = ;
T_13005 g_t807481C = ;
T_13008 g_t8074820 = ;
T_13011 g_t8074824 = ;
T_13084 g_t8074828 = ;
T_13087 g_t807482C = ;
T_13093 g_t8074830 = ;
T_12423 g_t8074834 = ;
T_12420 g_t8074838 = ;
T_12417 g_t807483C = ;
T_12414 g_t8074840 = ;
T_12411 g_t8074844 = ;
T_12408 g_t8074848 = ;
T_12405 g_t807484C = ;
T_13017 g_t8074850 = ;
T_13023 g_t8074854 = ;
T_12402 g_t8074858 = ;
T_12399 g_t807485C = ;
T_12396 g_t8074860 = ;
T_12393 g_t8074864 = ;
T_12390 g_t8074868 = ;
T_12387 g_t807486C = ;
T_12384 g_t8074870 = ;
T_285 g_t8074874 = // 08074874;
T_12813 g_t8074878 = ;
T_12984 g_t807487C = ;
T_13014 g_t8074880 = ;
T_13020 g_t8074884 = ;
T_13029 g_t8074888 = ;
T_13032 g_t807488C = ;
T_13035 g_t8074890 = ;
T_285 g_t8074894 = // 08074894;
T_13048 g_t8074898 = ;
T_13060 g_t807489C = ;
T_13066 g_t80748A0 = ;
T_13069 g_t80748A4 = ;
T_13090 g_t80748A8 = ;
T_13260 g_t8076B7C = // 08076B7C;
T_13265 g_t8076B80 = ;
T_13270 g_t8076B84 = ;
T_13275 g_t8076B88 = ;
T_13280 g_t8076B8C = ;
T_13285 g_t8076B90 = ;
T_13290 g_t8076B94 = ;
T_13295 g_t8076B98 = ;
T_13300 g_t8076B9C = ;
T_13305 g_t8076BA0 = ;
T_13310 g_t8076BA4 = ;
T_13315 g_t8076BA8 = ;
T_13320 g_t8076BAC = ;
T_13325 g_t8076BB0 = ;
T_13330 g_t8076BB4 = ;
T_13335 g_t8076BB8 = ;
T_13340 g_t8076BBC = ;
T_13343 g_t8076BC0 = ;
T_13346 g_t8076BC4 = ;
T_13349 g_t8076BC8 = ;
T_13354 g_t8076BCC = ;
T_13359 g_t8076BD0 = ;
T_13364 g_t8076BD4 = ;
T_13369 g_t8076BD8 = ;
T_13374 g_t8076BDC = ;
T_13379 g_t8076BE0 = ;
T_13384 g_t8076BE4 = ;
T_13389 g_t8076BE8 = ;
T_13394 g_t8076BEC = ;
T_13399 g_t8076BF0 = ;
T_13404 g_t8076BF4 = ;
T_13409 g_t8076BF8 = ;
T_13414 g_t8076BFC = ;
T_13419 g_t8076C00 = ;
T_13424 g_t8076C04 = ;
T_13429 g_t8076C08 = ;
T_13434 g_t8076C0C = ;
T_13439 g_t8076C10 = ;
T_13444 g_t8076C14 = ;
T_13449 g_t8076C18 = ;
T_13454 g_t8076C1C = ;
T_13459 g_t8076C20 = ;
T_13464 g_t8076C24 = ;
T_13469 g_t8076C28 = ;
T_13474 g_t8076C2C = ;
T_13479 g_t8076C30 = ;
T_13484 g_t8076C34 = ;
T_13489 g_t8076C38 = ;
T_13494 g_t8076C3C = ;
T_13499 g_t8076C40 = ;
T_13504 g_t8076C44 = ;
T_13509 g_t8076C48 = ;
T_13514 g_t8076C4C = ;
T_13519 g_t8076C50 = ;
T_13524 g_t8076C54 = ;
T_13529 g_t8076C58 = ;
T_13534 g_t8076C5C = ;
T_13539 g_t8076C60 = ;
T_13544 g_t8076C64 = ;
T_13549 g_t8076C68 = ;
T_13554 g_t8076C6C = ;
T_13559 g_t8076C70 = ;
T_13564 g_t8076C74 = ;
T_13569 g_t8076C78 = ;
T_13574 g_t8076C7C = ;
T_13579 g_t8076C80 = ;
T_13584 g_t8076C84 = ;
T_13589 g_t8076C88 = ;
T_13594 g_t8076C8C = ;
T_13599 g_t8076C90 = ;
T_13604 g_t8076C94 = ;
T_13609 g_t8076C98 = ;
T_13614 g_t8076C9C = ;
T_13619 g_t8076CA0 = ;
T_13624 g_t8076CA4 = ;
T_13629 g_t8076CA8 = ;
T_13634 g_t8076CAC = ;
T_13639 g_t8076CB0 = ;
T_13644 g_t8076CB4 = ;
T_13649 g_t8076CB8 = ;
T_13654 g_t8076CBC = ;
T_13659 g_t8076CC0 = ;
T_13664 g_t8076CC4 = ;
T_13669 g_t8076CC8 = ;
T_13674 g_t8076CCC = ;
T_13679 g_t8076CD0 = ;
T_13684 g_t8076CD4 = ;
T_13689 g_t8076CD8 = ;
T_13694 g_t8076CDC = ;
T_13699 g_t8076CE0 = ;
T_13704 g_t8076CE4 = ;
T_13709 g_t8076CE8 = ;
T_13714 g_t8076CEC = ;
T_13719 g_t8076CF0 = ;
T_13724 g_t8076CF4 = ;
T_13729 g_t8076CF8 = ;
T_13734 g_t8076CFC = ;
T_13739 g_t8076D00 = ;
T_13744 g_t8076D04 = ;
T_13749 g_t8076D08 = ;
T_13754 g_t8076D0C = ;
T_13759 g_t8076D10 = ;
T_13764 g_t8076D14 = ;
T_13769 g_t8076D18 = ;
T_13774 g_t8076D1C = ;
T_13779 g_t8076D20 = ;
T_13784 g_t8076D24 = ;
T_13789 g_t8076D28 = ;
T_13794 g_t8076D2C = ;
T_13799 g_t8076D30 = // 08076D30;
T_13804 g_t8076D34 = // 08076D34;
T_13809 g_t8076D38 = ;
T_13814 g_t8076D3C = // 08076D3C;
T_13819 g_t8076D40 = ;
T_13824 g_t8076D44 = ;
T_13829 g_t8076D48 = ;
T_13834 g_t8076D4C = ;
T_13839 g_t8076D50 = ;
T_13844 g_t8076D54 = ;
T_13849 g_t8076D58 = ;
T_13854 g_t8076D5C = ;
T_13859 g_t8076D60 = ;
T_13864 g_t8076D64 = ;
T_13869 g_t8076D68 = ;
T_13874 g_t8076D6C = ;
T_13879 g_t8076D70 = ;
T_13884 g_t8076D74 = ;
T_13889 g_t8076D78 = ;
T_13894 g_t8076D7C = ;
T_13899 g_t8076D80 = ;
T_13904 g_t8076D84 = ;
T_13909 g_t8076D88 = ;
T_13914 g_t8076D8C = ;
T_13919 g_t8076D90 = ;
T_13924 g_t8076D94 = ;
T_13929 g_t8076D98 = ;
T_13934 g_t8076D9C = ;
T_13939 g_t8076DA0 = ;
T_13944 g_t8076DA4 = ;
T_13949 g_t8076DA8 = ;
T_13954 g_t8076DAC = ;
T_13959 g_t8076DB0 = ;
T_13964 g_t8076DB4 = ;
T_13969 g_t8076DB8 = ;
T_13974 g_t8076DBC = ;
T_13979 g_t8076DC0 = ;
T_13984 g_t8076DC4 = ;
T_13989 g_t8076DC8 = ;
T_13994 g_t8076DCC = ;
T_13999 g_t8076DD0 = ;
T_14004 g_t8076DD4 = ;
T_14009 g_t8076DD8 = ;
T_14014 g_t8076DDC = ;
T_14018 g_t8076DE0 = ;
T_14023 g_t8076DE4 = ;
T_16792 g_t8076DF4 = ;
T_16789 g_t8076DF8 = ;
T_16805 g_t8076DFC = ;
T_16808 g_t8076E00 = ;
T_16811 g_t8076E04 = ;
T_16814 g_t8076E08 = ;
T_16823 g_t8076E0C = ;
T_16820 g_t8076E10 = ;
T_16817 g_t8076E14 = ;
T_16827 g_t8076E18 = ;
T_16831 g_t8076E1C = ;
T_16835 g_t8076E20 = ;
T_16839 g_t8076E24 = ;
T_16843 g_t8076E28 = ;
T_16847 g_t8076E2C = ;
T_16850 g_t8076E30 = ;
T_16853 g_t8076E34 = ;
T_16856 g_t8076E38 = ;
T_16859 g_t8076E3C = ;
T_16862 g_t8076E40 = ;
T_16871 g_t8076E44 = ;
T_16872 g_t8076E48 = ;
T_4013 g_t8076E4C = ;
T_16103 g_t8076E50 = ;
T_6833 g_t8076E54 = // 08076E54;
T_16937 g_t8076E58 = ;
T_16940 g_t8076E5C = ;
T_16943 g_t8076E60 = ;
T_16946 g_t8076E64 = ;
T_16949 g_t8076E68 = ;
T_16952 g_t8076E6C = ;
T_16955 g_t8076E70 = ;
T_16958 g_t8076E74 = ;
T_16961 g_t8076E78 = ;
T_16964 g_t8076E7C = ;
T_16967 g_t8076E80 = ;
T_16970 g_t8076E84 = ;
T_16973 g_t8076E88 = ;
T_16976 g_t8076E8C = ;
T_16979 g_t8076E90 = ;
T_16889 g_t8076E94 = ;
T_16892 g_t8076E98 = ;
T_16886 g_t8076E9C = ;
T_16784 g_t8076EA0 = ;
T_16893 g_t8076EA4 = ;
T_16781 g_t8076EA8 = ;
T_16896 g_t8076EAC = ;
T_16901 g_t8076EB0 = ;
T_16780 g_t8076EB4 = ;
T_16777 g_t8076EB8 = ;
T_16904 g_t8076EBC = ;
T_16774 g_t8076EC0 = ;
T_16771 g_t8076EC4 = ;
T_16768 g_t8076EC8 = ;
T_16907 g_t8076ECC = ;
T_16910 g_t8076ED0 = ;
T_16765 g_t8076ED4 = ;
T_16916 g_t8076ED8 = ;
T_16919 g_t8076EDC = ;
T_16913 g_t8076EE0 = ;
T_16762 g_t8076EE4 = ;
T_16931 g_t8076EE8 = ;
T_16922 g_t8076EEC = ;
T_16928 g_t8076EF0 = ;
T_16759 g_t8076EF4 = ;
T_16756 g_t8076EF8 = ;
T_16753 g_t8076EFC = ;
T_16750 g_t8076F00 = ;
T_16747 g_t8076F04 = ;
T_16744 g_t8076F08 = ;
T_16741 g_t8076F0C = ;
T_16934 g_t8076F10 = ;
T_16738 g_t8076F14 = ;
T_17012 g_t8076F18 = ;
T_17018 g_t8076F1C = ;
T_17015 g_t8076F20 = ;
T_17039 g_t8076F24 = ;
T_17033 g_t8076F28 = ;
T_16868 g_t8076F2C = ;
T_16925 g_t8076F30 = ;
T_17036 g_t8076F34 = ;
T_16865 g_t8076F38 = ;
T_285 g_t8076F3C = // 08076F3C;
T_24573 g_t8077C3C = ;
T_24574 g_t8077C40 = ;
T_24580 g_t8077C44 = ;
T_24586 g_t8077C48 = ;
T_24592 g_t8077C4C = ;
T_24595 g_t8077C50 = ;
T_24583 g_t8077C54 = ;
T_24598 g_t8077C58 = ;
T_24601 g_t8077C5C = ;
T_24616 g_t8077C60 = ;
T_24622 g_t8077C64 = ;
T_24604 g_t8077C68 = ;
T_24607 g_t8077C6C = ;
T_24610 g_t8077C70 = ;
T_24613 g_t8077C74 = ;
T_24625 g_t8077C78 = ;
T_24628 g_t8077C7C = ;
T_24643 g_t8077C80 = ;
T_24647 g_t8077C84 = ;
T_24653 g_t8077C88 = ;
T_24589 g_t8077C8C = ;
T_24619 g_t8077C90 = ;
T_285 g_t8077C94 = // 08077C94;
T_24646 g_t8077C98 = ;
T_28912 g_t8078AF4 = ;
T_28915 g_t8078AF8 = ;
T_28918 g_t8078AFC = ;
T_28921 g_t8078B00 = ;
T_28931 g_t8078B04 = ;
T_28925 g_t8078B08 = ;
T_28928 g_t8078B0C = ;
T_28938 g_t8078B10 = ;
T_28932 g_t8078B14 = ;
T_28947 g_t8078B18 = ;
T_28941 g_t8078B1C = ;
T_28944 g_t8078B20 = ;
T_28950 g_t8078B24 = ;
T_28953 g_t8078B28 = ;
T_28962 g_t8078B2C = ;
T_28956 g_t8078B30 = ;
T_28959 g_t8078B34 = ;
T_28965 g_t8078B38 = ;
T_28968 g_t8078B3C = ;
T_28971 g_t8078B40 = ;
T_28974 g_t8078B44 = ;
T_28977 g_t8078B48 = ;
T_28980 g_t8078B4C = ;
T_28983 g_t8078B50 = ;
T_28986 g_t8078B54 = ;
T_29007 g_t8078B58 = ;
T_29014 g_t8078B5C = ;
T_29008 g_t8078B60 = ;
T_29017 g_t8078B64 = ;
T_28989 g_t8078B68 = ;
T_28992 g_t8078B6C = ;
T_28995 g_t8078B70 = ;
T_28998 g_t8078B74 = ;
T_29001 g_t8078B78 = ;
T_29004 g_t8078B7C = ;
T_29020 g_t8078B80 = ;
T_29023 g_t8078B84 = ;
T_29036 g_t8078B88 = ;
T_29030 g_t8078B8C = ;
T_29040 g_t8078B90 = ;
T_29026 g_t8078B94 = ;
T_28909 g_t8078B98 = ;
T_29029 g_t8078B9C = ;
T_29312 g_t807966C = ;
T_29315 g_t8079670 = ;
T_29316 g_t8079674 = ;
T_29319 g_t8079678 = ;
T_29324 g_t807967C = ;
T_31475 g_t8079790 = ;
T_31478 g_t8079794 = ;
T_31481 g_t8079798 = ;
T_31484 g_t807979C = ;
T_31487 g_t80797A0 = ;
T_31493 g_t80797A4 = ;
T_31490 g_t80797A8 = ;
T_31496 g_t80797AC = ;
T_31520 g_t80797B0 = ;
T_31529 g_t80797B4 = ;
T_31523 g_t80797B8 = ;
T_31532 g_t80797BC = ;
T_31538 g_t80797C0 = ;
T_31535 g_t80797C4 = ;
T_31541 g_t80797C8 = ;
T_31502 g_t80797CC = ;
T_31505 g_t80797D0 = ;
T_31511 g_t80797D4 = ;
T_31514 g_t80797D8 = ;
T_31544 g_t80797DC = ;
T_31499 g_t80797E0 = ;
T_31508 g_t80797E4 = ;
T_31517 g_t80797E8 = ;
T_31526 g_t80797EC = ;
T_6833 g_t8079C18 = // 08079C18;
T_31658 g_t8079C1C = ;
T_31733 g_t8079C20 = ;
T_31671 g_t8079C24 = ;
T_31664 g_t8079C28 = ;
T_285 g_t8079C2C = // 08079C2C;
T_31686 g_t8079C30 = // 08079C30;
T_31736 g_t8079C34 = ;
T_31739 g_t8079C38 = ;
T_31742 g_t8079C3C = ;
T_31745 g_t8079C40 = ;
T_31748 g_t8079C44 = ;
T_31751 g_t8079C48 = ;
T_31754 g_t8079C4C = ;
T_31757 g_t8079C50 = ;
T_31760 g_t8079C54 = ;
T_31763 g_t8079C58 = ;
T_31766 g_t8079C5C = ;
T_31769 g_t8079C60 = ;
T_31772 g_t8079C64 = ;
T_31775 g_t8079C68 = ;
T_31778 g_t8079C6C = ;
T_31781 g_t8079C70 = ;
T_31784 g_t8079C74 = ;
T_31787 g_t8079C78 = ;
T_31790 g_t8079C7C = ;
T_31793 g_t8079C80 = ;
T_31796 g_t8079C84 = ;
T_31799 g_t8079C88 = ;
T_31569 g_t8079C8C = ;
T_31812 g_t8079C90 = ;
T_31815 g_t8079C94 = ;
T_285 g_t8079D7C = // 08079D7C;
T_285 g_t8079D80 = // 08079D80;
T_36751 g_t8079D84 = ;
T_285 g_t8079D88 = // 08079D88;
T_36760 g_t8079D8C = ;
T_36763 g_t8079D90 = ;
T_36769 g_t8079D94 = ;
T_36754 g_t8079D98 = ;
T_36766 g_t8079D9C = ;
T_285 g_t8079DA0 = // 08079DA0;
T_36653 g_t8079DA4 = // 08079DA4;
T_36656 g_t8079DA8 = // 08079DA8;
T_36776 g_t8079DAC = ;
T_285 g_t8079DB0 = // 08079DB0;
T_36748 g_t8079DB4 = ;
T_36757 g_t8079DB8 = ;
T_38614 g_t807A75C = ;
T_38617 g_t807A760 = ;
T_38620 g_t807A764 = ;
T_38623 g_t807A768 = ;
T_38626 g_t807A76C = ;
T_38629 g_t807A770 = ;
T_38632 g_t807A774 = ;
T_38635 g_t807A778 = ;
T_38639 g_t807A77C = ;
T_38645 g_t807A780 = ;
T_38644 g_t807A784 = ;
T_38671 g_t807A788 = ;
T_38650 g_t807A78C = ;
T_38653 g_t807A790 = ;
T_38656 g_t807A794 = ;
T_38638 g_t807A798 = ;
T_38659 g_t807A79C = ;
T_38662 g_t807A7A0 = ;
T_38665 g_t807A7A4 = ;
T_38668 g_t807A7A8 = ;
T_45469 g_t807ADE0 = ;
T_45472 g_t807ADE4 = ;
T_45475 g_t807ADE8 = ;
T_45466 g_t807ADEC = ;
T_45494 g_t807ADF0 = ;
T_45481 g_t807ADF4 = ;
T_45463 g_t807ADF8 = ;
T_45489 g_t807ADFC = ;
T_45478 g_t807AE00 = ;
T_45498 g_t807AE04 = ;
T_45591 g_t807AE08 = ;
T_285 g_t807AE0C = // 0807AE0C;
T_45376 g_t807AE10 = ;
T_43975 g_t807AE14 = ;
T_43969 g_t807AE18 = ;
T_45383 g_t807AE1C = ;
T_45386 g_t807AE20 = ;
T_45389 g_t807AE24 = ;
T_45392 g_t807AE28 = ;
T_45395 g_t807AE2C = ;
T_45398 g_t807AE30 = ;
T_43972 g_t807AE34 = ;
T_45403 g_t807AE38 = ;
T_45406 g_t807AE3C = ;
T_45407 g_t807AE40 = ;
T_45412 g_t807AE44 = ;
T_45276 g_t807AE48 = ;
T_45418 g_t807AE4C = ;
T_45421 g_t807AE50 = ;
T_44991 g_t807AE54 = ;
T_45426 g_t807AE58 = ;
T_45429 g_t807AE5C = ;
T_45432 g_t807AE60 = ;
T_45455 g_t807AE64 = ;
T_45456 g_t807AE68 = ;
T_285 g_t807AE6C = // 0807AE6C;
T_45226 g_t807AE70 = ;
T_45486 g_t807AE74 = ;
T_45226 g_t807AE78 = ;
T_45685 g_t807CAD0 = ;
T_45688 g_t807CAD4 = ;
T_64248 g_t807CF98 = // 0807CF98;
T_64253 g_t807CF9C = // 0807CF9C;
T_64258 g_t807CFA0 = // 0807CFA0;
T_64263 g_t807CFA4 = // 0807CFA4;
T_64268 g_t807CFA8 = // 0807CFA8;
T_64681 g_t807CFB0 = ;
T_64684 g_t807CFC7 = ;
T_285 g_t807CFCC = // 0807CFCC;
T_68188 g_t807CFD0 = ;
T_68159 g_t807CFD4 = ;
T_68619 g_t807CFD8 = ;
T_48252 g_t807CFDC = // 0807CFDC;
T_69145 g_t807CFE8 = // 0807CFE8;
T_69145 g_t807CFF0 = // 0807CFF0;
T_285 g_t807CFF4 = // 0807CFF4;
T_285 g_t807CFF8 = // 0807CFF8;
T_285 g_t807D0A4 = // 0807D0A4;
T_116500 g_t807D0A8 = ;
T_285 g_t807D0BC = // 0807D0BC;
T_285 g_t807D0C0 = // 0807D0C0;
T_285 g_t807D0C4 = // 0807D0C4;
T_743 g_t807D0C8 = // 0807D0C8;
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0807105C: define _fini
define _fini
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x08071068<p32>;
	ebx += 9788;
	SCZO = cond(ebx);
	__do_global_dtors_aux();
	ecx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebx = Mem0[esp + 0x00:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

T_12 g_t8073680 = ;
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049D84: define _init
// Called from:
//      __libc_csu_init
define _init
{
	word32 dwLoc0C;
	Top_3 = 0;
	edx_14 = Mem10[0x08073680<p32>:word32];
	if (edx_14 != 0x00)
		__gmon_start__();
	edx_48 = ϕ(edx_14, edx_19);
	frame_dummy();
	__do_global_ctors_aux();
	eax_35 = dwLoc0C;
}

// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

T_107 g_t8073568 = ;
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049DC4: define ldexp
define ldexp
{
}

// 08049DD4: define fputs
define fputs
{
}

// 08049DE4: define fmod
define fmod
{
}

// 08049DF4: define __errno_location
define __errno_location
{
}

// 08049E04: define sigemptyset
define sigemptyset
{
}

// 08049E14: define inet_ntop
define inet_ntop
{
}

// 08049E24: define sprintf
define sprintf
{
}

// 08049E34: define tcflow
define tcflow
{
}

// 08049E44: define connect
define connect
{
}

// 08049E54: define setgroups
define setgroups
{
}

// 08049E64: define getpid
define getpid
{
}

// 08049E74: define mkdir
define mkdir
{
}

// 08049E84: define strerror
define strerror
{
}

// 08049E94: define getsockname
define getsockname
{
}

// 08049EA4: define memcmp
define memcmp
{
}

// 08049EB4: define log1p
define log1p
{
}

// 08049EC4: define freeaddrinfo
define freeaddrinfo
{
}

// 08049ED4: define asin
define asin
{
}

// 08049EE4: define shutdown
define shutdown
{
}

// 08049EF4: define open64
define open64
{
}

// 08049F04: define sigismember
define sigismember
{
}

// 08049F14: define __gmon_start__
define __gmon_start__
{
}

// 08049F24: define realloc
define realloc
{
}

// 08049F34: define sinh
define sinh
{
}

// 08049F44: define __isoc99_sscanf
define __isoc99_sscanf
{
}

// 08049F54: define __xstat64
define __xstat64
{
}

// 08049F64: define localtime
define localtime
{
}

// 08049F74: define cfgetispeed
define cfgetispeed
{
}

// 08049F84: define getgrnam
define getgrnam
{
}

// 08049F94: define strtod
define strtod
{
}

// 08049FA4: define socketpair
define socketpair
{
}

// 08049FB4: define recv
define recv
{
}

// 08049FC4: define getenv
define getenv
{
}

// 08049FD4: define calloc
define calloc
{
}

// 08049FE4: define system
define system
{
}

// 08049FF4: define fchown
define fchown
{
}

// 0804A004: define write
define write
{
}

// 0804A014: define sendto
define sendto
{
}

// 0804A024: define pow
define pow
{
}

// 0804A034: define listen
define listen
{
}

// 0804A044: define dlclose
define dlclose
{
}

// 0804A054: define rename
define rename
{
}

// 0804A064: define getlogin
define getlogin
{
}

// 0804A074: define memset
define memset
{
}

// 0804A084: define setitimer
define setitimer
{
}

// 0804A094: define setsid
define setsid
{
}

// 0804A0A4: define getprotobyname
define getprotobyname
{
}

// 0804A0B4: define __libc_start_main
define __libc_start_main
{
}

// 0804A0C4: define wait
define wait
{
}

// 0804A0D4: define floor
define floor
{
}

// 0804A0E4: define modf
define modf
{
}

// 0804A0F4: define tcgetattr
define tcgetattr
{
}

// 0804A104: define chmod
define chmod
{
}

// 0804A114: define read
define read
{
}

// 0804A124: define tcdrain
define tcdrain
{
}

// 0804A134: define sigaltstack
define sigaltstack
{
}

// 0804A144: define exp
define exp
{
}

// 0804A154: define getrusage
define getrusage
{
}

// 0804A164: define gettimeofday
define gettimeofday
{
}

// 0804A174: define expm1
define expm1
{
}

// 0804A184: define strtol
define strtol
{
}

// 0804A194: define getservbyport
define getservbyport
{
}

// 0804A1A4: define free
define free
{
}

// 0804A1B4: define inet_pton
define inet_pton
{
}

// 0804A1C4: define __lxstat64
define __lxstat64
{
}

// 0804A1D4: define atan
define atan
{
}

// 0804A1E4: define __fpclassify
define __fpclassify
{
}

// 0804A1F4: define getprotobynumber
define getprotobynumber
{
}

// 0804A204: define access
define access
{
}

// 0804A214: define dlsym
define dlsym
{
}

// 0804A224: define truncate64
define truncate64
{
}

// 0804A234: define sigaction
define sigaction
{
}

// 0804A244: define fflush
define fflush
{
}

// 0804A254: define sqrt
define sqrt
{
}

// 0804A264: define opendir
define opendir
{
}

// 0804A274: define gethostbyaddr_r
define gethostbyaddr_r
{
}

// 0804A284: define accept
define accept
{
}

// 0804A294: define tcflush
define tcflush
{
}

// 0804A2A4: define symlink
define symlink
{
}

// 0804A2B4: define socket
define socket
{
}

// 0804A2C4: define dup2
define dup2
{
}

// 0804A2D4: define __ctype_b_loc
define __ctype_b_loc
{
}

// 0804A2E4: define isatty
define isatty
{
}

// 0804A2F4: define getaddrinfo
define getaddrinfo
{
}

// 0804A304: define umask
define umask
{
}

// 0804A314: define tanh
define tanh
{
}

// 0804A324: define setuid
define setuid
{
}

// 0804A334: define dup
define dup
{
}

// 0804A344: define mktime
define mktime
{
}

// 0804A354: define readdir64
define readdir64
{
}

// 0804A364: define acos
define acos
{
}

// 0804A374: define memcpy
define memcpy
{
}

// 0804A384: define cfsetospeed
define cfsetospeed
{
}

// 0804A394: define utime
define utime
{
}

// 0804A3A4: define execv
define execv
{
}

// 0804A3B4: define execvp
define execvp
{
}

// 0804A3C4: define cos
define cos
{
}

// 0804A3D4: define alarm
define alarm
{
}

// 0804A3E4: define unlink
define unlink
{
}

// 0804A3F4: define getpwuid
define getpwuid
{
}

// 0804A404: define nice
define nice
{
}

// 0804A414: define getppid
define getppid
{
}

// 0804A424: define setlocale
define setlocale
{
}

// 0804A434: define waitpid
define waitpid
{
}

// 0804A444: define sigdelset
define sigdelset
{
}

// 0804A454: define __h_errno_location
define __h_errno_location
{
}

// 0804A464: define strcpy
define strcpy
{
}

// 0804A474: define chroot
define chroot
{
}

// 0804A484: define getegid
define getegid
{
}

// 0804A494: define dlopen
define dlopen
{
}

// 0804A4A4: define mkfifo
define mkfifo
{
}

// 0804A4B4: define chdir
define chdir
{
}

// 0804A4C4: define bind
define bind
{
}

// 0804A4D4: define getuid
define getuid
{
}

// 0804A4E4: define putenv
define putenv
{
}

// 0804A4F4: define sigpending
define sigpending
{
}

// 0804A504: define select
define select
{
}

// 0804A514: define closedir
define closedir
{
}

// 0804A524: define close
define close
{
}

// 0804A534: define fwrite
define fwrite
{
}

// 0804A544: define rewinddir
define rewinddir
{
}

// 0804A554: define frexp
define frexp
{
}

// 0804A564: define initgroups
define initgroups
{
}

// 0804A574: define fprintf
define fprintf
{
}

// 0804A584: define time
define time
{
}

// 0804A594: define log10
define log10
{
}

// 0804A5A4: define execve
define execve
{
}

// 0804A5B4: define ftruncate64
define ftruncate64
{
}

// 0804A5C4: define malloc
define malloc
{
}

// 0804A5D4: define sigprocmask
define sigprocmask
{
}

// 0804A5E4: define chown
define chown
{
}

// 0804A5F4: define gethostname
define gethostname
{
}

// 0804A604: define atan2
define atan2
{
}

// 0804A614: define fputc
define fputc
{
}

// 0804A624: define rmdir
define rmdir
{
}

// 0804A634: define dlerror
define dlerror
{
}

// 0804A644: define getgrgid
define getgrgid
{
}

// 0804A654: define sleep
define sleep
{
}

// 0804A664: define sigaddset
define sigaddset
{
}

// 0804A674: define readlink
define readlink
{
}

// 0804A684: define memmove
define memmove
{
}

// 0804A694: define cfgetospeed
define cfgetospeed
{
}

// 0804A6A4: define getnameinfo
define getnameinfo
{
}

// 0804A6B4: define strcat
define strcat
{
}

// 0804A6C4: define send
define send
{
}

// 0804A6D4: define getcwd
define getcwd
{
}

// 0804A6E4: define log
define log
{
}

// 0804A6F4: define gethostbyname_r
define gethostbyname_r
{
}

// 0804A704: define fork
define fork
{
}

// 0804A714: define __fxstat64
define __fxstat64
{
}

// 0804A724: define setsockopt
define setsockopt
{
}

// 0804A734: define tcsetattr
define tcsetattr
{
}

// 0804A744: define fcntl
define fcntl
{
}

// 0804A754: define getrlimit64
define getrlimit64
{
}

// 0804A764: define gmtime
define gmtime
{
}

// 0804A774: define getgroups
define getgroups
{
}

// 0804A784: define link
define link
{
}

// 0804A794: define pipe
define pipe
{
}

// 0804A7A4: define tan
define tan
{
}

// 0804A7B4: define getsockopt
define getsockopt
{
}

// 0804A7C4: define setgid
define setgid
{
}

// 0804A7D4: define cosh
define cosh
{
}

// 0804A7E4: define kill
define kill
{
}

// 0804A7F4: define sin
define sin
{
}

// 0804A804: define getpeername
define getpeername
{
}

// 0804A814: define tcsendbreak
define tcsendbreak
{
}

// 0804A824: define recvfrom
define recvfrom
{
}

// 0804A834: define getpwnam
define getpwnam
{
}

// 0804A844: define lseek64
define lseek64
{
}

// 0804A854: define getitimer
define getitimer
{
}

// 0804A864: define strcmp
define strcmp
{
}

// 0804A874: define __sigsetjmp
define __sigsetjmp
{
}

// 0804A884: define getservbyname
define getservbyname
{
}

// 0804A894: define exit
define exit
{
}

// 0804A8A4: define cfsetispeed
define cfsetispeed
{
}

// 0804A8B4: define fchmod
define fchmod
{
}

// 0804A8C4: define sigsuspend
define sigsuspend
{
}

// 0804A8D4: define getgid
define getgid
{
}

// 0804A8E4: define ceil
define ceil
{
}

// 0804A8F4: define geteuid
define geteuid
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

T_101000 g_t8071188 = ;
T_72202 g_t80718AC = ;
T_72220 g_t80718B0 = ;
T_72351 g_t80718B4 = ;
T_72314 g_t80718B8 = ;
T_104285 g_t807225C = ;
T_104336 g_t8072260 = ;
T_113280 g_t8072334 = ;
T_115179 g_t80723B5 = ;
T_115188 g_t80723B6 = ;
// subject_text_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804A910: define _start
define _start
{
	ptr32 fp;
	word32 edx;
	word32 dwArg00;
	char * ptrArg04;
	__align_stack<word32>(&ptrArg04);
	dwLoc14_39 = &ptrArg04;
	__libc_start_main(0x0806200C, dwArg00, dwLoc14_39, 0x08070FD0, 0x08070FC0, edx, fp);
	__halt();
}

// 0804A940: define __do_global_dtors_aux
// Called from:
//      _fini
define __do_global_dtors_aux
{
	ptr32 fp;
	word32 eax;
	Top_3 = 0;
	if (Mem10[0x0807D104<p32>:byte] == 0x00)
	{
		eax_14 = Mem10[0x0807D108<p32>:word32];
		if (eax_14 <u 0x00)
		{
			do
			{
				eax_23 = ϕ(eax_14, eax_34);
				eax_24 = eax_23 + 0x01;
				Mem26[0x0807D108<p32>:word32] = eax_24;
				0x08073560[eax_24 * 0x04]();
				eax_34 = Mem26[0x0807D108<p32>:word32];
			} while (eax_34 <u 0x00);
		}
		eax_58 = ϕ(eax_14, eax_34);
		Mem37[0x0807D104<p32>:byte] = 0x01;
	}
	eax_56 = ϕ(eax, eax_58);
	SCZO_41 = cond(fp - 0x08);
	C_55 = SLICE(SCZO_41, bool, 1);
	O_61 = SLICE(SCZO_41, bool, 4);
	S_62 = SLICE(SCZO_41, bool, 0);
	Z_65 = SLICE(SCZO_41, bool, 2);
}

// 0804A9A0: define frame_dummy
// Called from:
//      _init
define frame_dummy
{
	Top_3 = 0;
	eax_9 = Mem6[0x08073568<p32>:word32];
	SZP_10 = cond(eax_9);
	Z_13 = SLICE(SZP_10, bool, 2);
	P_36 = SLICE(SZP_10, bool, 5);
	S_40 = SLICE(SZP_10, bool, 0);
	O_11 = false;
	C_12 = false;
	if (eax_9 != 0x00)
	{
		eax_14 = 0x00;
		SZP_15 = cond(0x00);
		Z_18 = SLICE(SZP_15, bool, 2);
		P_37 = SLICE(SZP_15, bool, 5);
		S_41 = SLICE(SZP_15, bool, 0);
		O_16 = false;
		C_17 = false;
		if (false)
		{
			eax_20 = fn00000000(0x08073568);
			C_31 = SLICE(SCZOP_21, bool, 1);
			O_34 = SLICE(SCZOP_21, bool, 4);
			P_38 = SLICE(SCZOP_21, bool, 5);
			S_42 = SLICE(SCZOP_21, bool, 0);
			Z_45 = SLICE(SCZOP_21, bool, 2);
		}
	}
	Z_44 = ϕ(Z_13, Z_18, Z_45);
	S_39 = ϕ(S_40, S_41, S_42);
	P_35 = ϕ(P_36, P_37, P_38);
	O_33 = ϕ(O_11, O_16, O_34);
	eax_32 = ϕ(eax_9, eax_14, eax_20);
	C_30 = ϕ(C_12, C_17, C_31);
}

// 0804A9D0: define caml_program
define caml_program
{
	esp = fp;
	Top = 0;
	camlPervasives__entry();
	v4 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v4;
	SCZO = cond(v4);
	camlArray__entry();
	v6 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v6;
	SCZO = cond(v6);
	camlList__entry();
	v7 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v7;
	SCZO = cond(v7);
	camlChar__entry();
	v8 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v8;
	SCZO = cond(v8);
	camlString__entry();
	v9 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v9;
	SCZO = cond(v9);
	camlSys__entry();
	v10 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v10;
	SCZO = cond(v10);
	camlHashtbl__entry();
	v11 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v11;
	SCZO = cond(v11);
	camlBuffer__entry();
	v12 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v12;
	SCZO = cond(v12);
	camlPrintf__entry();
	v13 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v13;
	SCZO = cond(v13);
	camlCallback__entry();
	v14 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v14;
	SCZO = cond(v14);
	camlUnix__entry();
	v15 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v15;
	SCZO = cond(v15);
	camlUnixLabels__entry();
	v16 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v16;
	SCZO = cond(v16);
	camlSource__entry();
	v17 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v17;
	SCZO = cond(v17);
	camlStd_exit__entry();
	v18 = Mem0[0x0807D2A4<p32>:word32] + 0x01;
	Mem0[0x0807D2A4<p32>:word32] = v18;
	SCZO = cond(v18);
	eax = 0x01;
}

// 0804AA80: define caml_curry9
define caml_curry9
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AAC0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AAC0: define caml_curry9_1
define caml_curry9_1
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AB00;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AB00: define caml_curry9_2
define caml_curry9_2
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AB40;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AB40: define caml_curry9_3
define caml_curry9_3
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AB80;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AB80: define caml_curry9_4
define caml_curry9_4
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804ABC0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804ABC0: define caml_curry9_5
define caml_curry9_5
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AC00;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AC00: define caml_curry9_6
define caml_curry9_6
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AC40;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AC40: define caml_curry9_7
define caml_curry9_7
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AC80;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AC80: define caml_curry9_8
define caml_curry9_8
{
	esp = fp;
	Top = 0;
	esp -= 44;
	Mem0[esp + 36:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	eax = Mem0[ebx + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	Mem0[esp + 16:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	Mem0[esp + 20:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	Mem0[esp + 24:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	Mem0[esp + 28:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	Mem0[esp + 40:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	eax = Mem0[eax + 8:word32];
	Mem0[esp + 32:word32] = eax;
	eax = Mem0[esp + 4:word32];
	eax = Mem0[eax + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[esp + 8:word32];
	eax = Mem0[eax + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 0x0C:word32];
	esi = Mem0[eax + 8:word32];
	eax = Mem0[esp + 16:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[esp + 20:word32];
	ecx = Mem0[eax + 8:word32];
	eax = Mem0[esp + 24:word32];
	ebx = Mem0[eax + 8:word32];
	eax = Mem0[esp + 28:word32];
	eax = Mem0[eax + 8:word32];
	edi = Mem0[esp + 40:word32];
	edi = Mem0[edi + 8:word32];
	Mem0[esp + 8:word32] = edi;
	edi = Mem0[esp + 0x00:word32];
	ebp = Mem0[esp + 4:word32];
	Mem0[0x0807D0BC<p32>:word32] = ebp;
	ebp = Mem0[esp + 32:word32];
	Mem0[0x0807D0C0<p32>:word32] = ebp;
	ebp = Mem0[esp + 36:word32];
	Mem0[0x0807D0C4<p32>:word32] = ebp;
	ebp = Mem0[esp + 40:word32];
	Mem0[0x0807D0C8<p32>:word32] = ebp;
	ebp = Mem0[esp + 8:word32];
	esp += 44;
	SCZO = cond(esp);
	ebp();
}

// 0804AD50: define caml_curry7
define caml_curry7
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AD90;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AD90: define caml_curry7_1
define caml_curry7_1
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804ADD0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804ADD0: define caml_curry7_2
define caml_curry7_2
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 134524432;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AE10: define caml_curry7_3
define caml_curry7_3
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AE50;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AE50: define caml_curry7_4
define caml_curry7_4
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AE90;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AE90: define caml_curry7_5
define caml_curry7_5
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AED0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AED0: define caml_curry7_6
define caml_curry7_6
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	Mem0[esp + 4:word32] = eax;
	esi = ebx;
	eax = Mem0[esi + 0x0C:word32];
	ecx = Mem0[eax + 0x0C:word32];
	edi = Mem0[ecx + 0x0C:word32];
	ebp = Mem0[edi + 0x0C:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	edx = Mem0[ebx + 0x0C:word32];
	Mem0[esp + 8:word32] = edx;
	esi = Mem0[esi + 8:word32];
	Mem0[esp + 0x00:word32] = esi;
	eax = Mem0[eax + 8:word32];
	Mem0[esp + 16:word32] = eax;
	esi = Mem0[ecx + 8:word32];
	ecx = Mem0[edi + 8:word32];
	edi = Mem0[ebp + 8:word32];
	eax = Mem0[ebx + 8:word32];
	ebx = Mem0[edx + 8:word32];
	Mem0[esp + 0x0C:word32] = ebx;
	ebx = edi;
	edx = esi;
	esi = Mem0[esp + 16:word32];
	edi = Mem0[esp + 0x00:word32];
	ebp = Mem0[esp + 4:word32];
	Mem0[0x0807D0BC<p32>:word32] = ebp;
	ebp = Mem0[esp + 8:word32];
	Mem0[0x0807D0C0<p32>:word32] = ebp;
	ebp = Mem0[esp + 0x0C:word32];
	esp += 0x14;
	SCZO = cond(esp);
	ebp();
}

// 0804AF40: define caml_curry6
define caml_curry6
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AF80;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AF80: define caml_curry6_1
define caml_curry6_1
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804AFC0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804AFC0: define caml_curry6_2
define caml_curry6_2
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B000;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B000: define caml_curry6_3
define caml_curry6_3
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B040;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B040: define caml_curry6_4
define caml_curry6_4
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B080;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B080: define caml_curry6_5
define caml_curry6_5
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[ebx + 0x0C:word32];
	ecx = Mem0[eax + 0x0C:word32];
	edi = Mem0[ecx + 0x0C:word32];
	ebp = Mem0[edi + 0x0C:word32];
	edx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = edx;
	ebx = Mem0[ebx + 8:word32];
	Mem0[esp + 0x0C:word32] = ebx;
	esi = Mem0[eax + 8:word32];
	ecx = Mem0[ecx + 8:word32];
	ebx = Mem0[edi + 8:word32];
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[edx + 8:word32];
	Mem0[esp + 8:word32] = edx;
	edx = esi;
	esi = Mem0[esp + 0x0C:word32];
	edi = Mem0[esp + 0x00:word32];
	ebp = Mem0[esp + 4:word32];
	Mem0[0x0807D0BC<p32>:word32] = ebp;
	ebp = Mem0[esp + 8:word32];
	esp += 0x10;
	SCZO = cond(esp);
	ebp();
}

// 0804B0D0: define caml_curry5
define caml_curry5
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B110;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B110: define caml_curry5_1
define caml_curry5_1
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B150;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B150: define caml_curry5_2
define caml_curry5_2
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B190;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B190: define caml_curry5_3
define caml_curry5_3
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B1D0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B1D0: define caml_curry5_4
define caml_curry5_4
{
	esp = fp;
	Top = 0;
	esi = eax;
	ecx = Mem0[ebx + 0x0C:word32];
	eax = Mem0[ecx + 0x0C:word32];
	ebp = Mem0[eax + 0x0C:word32];
	edi = Mem0[ebp + 0x0C:word32];
	edx = Mem0[ebx + 8:word32];
	ecx = Mem0[ecx + 8:word32];
	ebx = Mem0[eax + 8:word32];
	eax = Mem0[ebp + 8:word32];
	ebp = Mem0[edi + 8:word32];
	ebp();
}

// 0804B1F0: define caml_curry4
define caml_curry4
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B230;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B230: define caml_curry4_1
define caml_curry4_1
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 134525552;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B270: define caml_curry4_2
define caml_curry4_2
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B2B0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B2B0: define caml_curry4_3
define caml_curry4_3
{
	esp = fp;
	Top = 0;
	edx = eax;
	edi = Mem0[ebx + 0x0C:word32];
	eax = Mem0[edi + 0x0C:word32];
	esi = Mem0[eax + 0x0C:word32];
	ecx = Mem0[ebx + 8:word32];
	ebx = Mem0[edi + 8:word32];
	eax = Mem0[eax + 8:word32];
	edi = Mem0[esi + 8:word32];
	edi();
}

// 0804B2D0: define caml_curry3
define caml_curry3
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B310;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B310: define caml_curry3_1
define caml_curry3_1
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B350;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B350: define caml_curry3_2
define caml_curry3_2
{
	esp = fp;
	Top = 0;
	ecx = eax;
	eax = Mem0[ebx + 0x0C:word32];
	edx = Mem0[eax + 0x0C:word32];
	ebx = Mem0[ebx + 8:word32];
	eax = Mem0[eax + 8:word32];
	esi = Mem0[edx + 8:word32];
	esi();
}

// 0804B370: define caml_curry2
define caml_curry2
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B3B0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
}

// 0804B3B0: define caml_curry2_1
define caml_curry2_1
{
	esp = fp;
	Top = 0;
	esi = eax;
	ecx = Mem0[ebx + 0x0C:word32];
	eax = Mem0[ebx + 8:word32];
	edx = Mem0[ecx + 8:word32];
	ebx = esi;
	edx();
}

// 0804B3C0: define caml_tuplify2
define caml_tuplify2
{
	esp = fp;
	Top = 0;
	ecx = ebx;
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[eax + 0x00:word32];
	edx = Mem0[ecx + 8:word32];
	edx();
}

// 0804B3D0: define caml_tuplify3
define caml_tuplify3
{
	esp = fp;
	Top = 0;
	edx = ebx;
	ecx = Mem0[eax + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[eax + 0x00:word32];
	esi = Mem0[edx + 8:word32];
	esi();
}

// 0804B3E0: define caml_apply6
// Called from:
//      camlPrintf__fprintf_1391
//      camlPrintf__bprintf_1400
//      camlPrintf__ksprintf_1411
define caml_apply6
{
	word32 eax;
	word32 ebx;
	word32 ecx;
	word32 edx;
	word32 esi;
	word32 edi;
	word32 ebp;
	Top_3 = 0;
	ebx_17 = Mem16[0x0807D0BC<p32>:word32];
	eax_18 = Mem16[ebx_17 + 4:word32];
	if (eax_18 != 0x0D)
	{
		eax_21 = Mem16[ebx_17 + 0x00:word32];
		eax_21();
		ecx_30 = Mem22[eax_25 + 0x00:word32];
		ecx_30();
		ecx_37 = Mem22[eax_32 + 0x00:word32];
		ecx_37();
		ecx_44 = Mem22[eax_39 + 0x00:word32];
		ecx_44();
		ecx_51 = Mem22[eax_46 + 0x00:word32];
		ecx_51();
		ebx_57 = eax_53;
		ecx_58 = Mem22[eax_53 + 0x00:word32];
		ecx_58();
		C_95 = SLICE(SCZO_65, bool, 1);
		O_107 = SLICE(SCZO_65, bool, 4);
		S_110 = SLICE(SCZO_65, bool, 0);
		Z_114 = SLICE(SCZO_65, bool, 2);
	}
	else
	{
		eax_67 = Mem66[ebx_17 + 8:word32];
		ebx_70 = ebx;
		Mem76[0x0807D0BC<p32>:word32] = ebx_17;
		ebp_77 = eax_67;
		eax_67();
		C_94 = SLICE(SCZO_83, bool, 1);
		O_106 = SLICE(SCZO_83, bool, 4);
		S_109 = SLICE(SCZO_83, bool, 0);
		Z_113 = SLICE(SCZO_83, bool, 2);
	}
}

// 0804B490: define caml_apply4
define caml_apply4
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	edi = Mem0[esi + 4:word32];
	SCZO = cond(edi - 0x09);
	if (Test(NE,Z))
	{
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		ecx = Mem0[esi + 0x00:word32];
		ebx = esi;
		ecx();
		ebx = eax;
		ecx = Mem0[ebx + 0x00:word32];
		eax = Mem0[esp + 0x00:word32];
		ecx();
		ebx = eax;
		ecx = Mem0[ebx + 0x00:word32];
		eax = Mem0[esp + 4:word32];
		ecx();
		ebx = eax;
		ecx = Mem0[ebx + 0x00:word32];
		eax = Mem0[esp + 8:word32];
		esp += 0x0C;
		SCZO = cond(esp);
		ecx();
	}
	else
	{
		edi = Mem0[esi + 8:word32];
		esp += 0x0C;
		SCZO = cond(esp);
		edi();
	}
}

// 0804B4F0: define caml_apply3
// Called from:
//      camlList__fold_left2_1119
//      camlList__fold_right2_1128
//      camlHashtbl__do_bucket_1142
//      camlPrintf__sub_fmt_1124
//      camlPrintf__sub_format_for_printf_1135
define caml_apply3
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	esi = Mem0[edx + 4:word32];
	SCZO = cond(esi - 0x07);
	if (Test(NE,Z))
	{
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		ecx = Mem0[edx + 0x00:word32];
		ebx = edx;
		ecx();
		ebx = eax;
		ecx = Mem0[ebx + 0x00:word32];
		eax = Mem0[esp + 0x00:word32];
		ecx();
		ebx = eax;
		ecx = Mem0[ebx + 0x00:word32];
		eax = Mem0[esp + 4:word32];
		esp += 0x08;
		SCZO = cond(esp);
		ecx();
	}
	else
	{
		esi = Mem0[edx + 8:word32];
		esp += 0x08;
		SCZO = cond(esp);
		esi();
	}
}

// 0804B540: define caml_apply2
// Called from:
//      camlUnix__establish_server_2026
//      camlArray__maxson_1155
//      camlArray__trickledown_1160
//      camlArray__trickleup_1178
//      camlArray__sortto_1217
//      camlArray__iteri_1111
//      camlArray__mapi_1115
//      camlArray__fold_left_1139
//      camlArray__fold_right_1145
//      camlArray__stable_sort_1188
//      camlList__rev_sort_1272
//      camlList__sort_1271
//      camlList__fold_left_1078
//      camlList__fold_right_1084
//      camlList__map2_1090
//      camlList__rev_map2_1099
//      camlList__iter2_1111
//      camlList__for_all2_1145
//      camlList__exists2_1153
//      camlList__merge_1233
//      camlList__stable_sort_1248
//      camlHashtbl__remove_bucket_1188
//      camlHashtbl__replace_bucket_1221
//      camlHashtbl__do_bucket_1132
//      camlHashtbl__find_1198
//      camlHashtbl__find_all_1210
//      camlHashtbl__mem_1227
//      camlPrintf__loop_1159
//      camlPrintf__cont_t_1363
//      camlPrintf__cont_a_1362
//      camlPrintf__cont_s_1361
//      camlPrintf__doprn_1360
//      camlPrintf__fun_1587
//      camlPrintf__fun_1584
//      camlPrintf__fun_1581
//      camlPrintf__fun_1578
//      camlPrintf__fun_1575
//      camlPrintf__fun_1572
//      camlPrintf__list_iter_i_1201
//      camlPrintf__scan_format_1278
//      camlPrintf__mkprintf_1345
define caml_apply2
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	edx = Mem0[ecx + 4:word32];
	SCZO = cond(edx - 0x05);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		edx = Mem0[ecx + 0x00:word32];
		ebx = ecx;
		edx();
		ebx = eax;
		ecx = Mem0[ebx + 0x00:word32];
		eax = Mem0[esp + 0x00:word32];
		esp += 0x04;
		SCZO = cond(esp);
		ecx();
	}
	else
	{
		edx = Mem0[ecx + 8:word32];
		esp += 0x04;
		SCZO = cond(esp);
		edx();
	}
}

// 0804B580: define camlStd_exit__entry
// Called from:
//      caml_program
define camlStd_exit__entry
{
	esp = fp;
	Top = 0;
	eax = Mem0[0x08076F3C<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	eax = 0x01;
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
	eax = 0x01;
}

// 0804B5A0: define camlSource__loop_1044
// Called from:
//      camlSource__merge_1034
define camlSource__loop_1044
{
	word32 eax;
	word32 edx;
	word32 ebx;
	word32 edi;
	word32 esi;
	word32 ecx;
	word32 dwLoc10;
	bool P;
	while (true)
	{
		while (true)
		{
			P_178 = ϕ(P, P_180, P_181);
			ecx_31 = ϕ(ecx, ecx_31, ecx_32);
			esi_28 = ϕ(esi, esi_142, esi_82);
			ebx_14 = ϕ(ebx, ebx_131, ebx_14);
			edx_11 = ϕ(edx, edx_11, edx_71);
			eax_6 = ϕ(eax, eax_144, eax_84);
			rLoc1_155 = Mem8[edx_11 + 0x00:real64];
			rLoc2_156 = Mem8[ebx_14 + 0x00:real64];
			FPUF_16 = cond(rLoc2_156 - rLoc1_155);
			ax_18 = __fstsw(FPUF_16);
			ah_19 = SLICE(ax_18, byte, 8);
			ah_21 = (ah_19 & 0x45) - 0x01;
			if (ah_21 >=u 0x40)
				break;
			eax_85 = Mem8[edi + 20:word32];
			rLoc1_161 = Mem8[ebx_14 + 0x00:real64];
			(eax_85 - 4)[esi_28 * 0x04] = rLoc1_161;
			eax_92 = Mem88[edi + 24:word32];
			if (eax_6 + 0x02 >= eax_92)
			{
				ebp_95 = Mem88[edi + 28:word32];
				ebp_96 = ebp_95 - ecx_31;
				edx_99 = esi_28 + 0x02;
				esi_100 = Mem88[edi + 20:word32];
				eax_101 = Mem88[edi + 16:word32];
				camlArray__blit_1093();
				return;
			}
			while (true)
			{
				P_180 = ϕ(P_178, P_130);
				Mem118 = ϕ(Mem88, Mem121);
				eax_119 = Mem118[0x08080414<p32>:word32];
				Mem121[0x08080414<p32>:word32] = eax_119 - 0x0C;
				if (eax_119 - 0x0C >=u Mem121[0x08080418<p32>:word32])
					break;
				fn080708CC();
			}
			ebx_131 = eax_119 - 0x08;
			Mem132[eax_119 + -0x0C:word32] = 0x08FD;
			eax_134 = Mem132[edi + 0x0C:word32];
			rLoc1_163 = (eax_134 - 4)[(eax_6 + 0x02) * 0x04];
			Mem139[eax_119 + -8:real64] = rLoc1_163;
			esi_142 = esi_28 + 0x02;
			eax_144 = eax_6 + 0x02;
		}
		eax_25 = Mem8[edi + 20:word32];
		rLoc1_157 = Mem8[edx_11 + 0x00:real64];
		(eax_25 - 4)[esi_28 * 0x04] = rLoc1_157;
		ecx_32 = ecx_31 + 0x02;
		eax_33 = Mem29[edi + 28:word32];
		if (ecx_32 >= eax_33)
			break;
		while (true)
		{
			P_181 = ϕ(P_178, P_70);
			Mem58 = ϕ(Mem29, Mem61);
			eax_59 = Mem58[0x08080414<p32>:word32];
			Mem61[0x08080414<p32>:word32] = eax_59 - 0x0C;
			if (eax_59 - 0x0C >=u Mem61[0x08080418<p32>:word32])
				break;
			fn080708CC();
		}
		edx_71 = eax_59 - 0x08;
		Mem72[eax_59 + -0x0C:word32] = 0x08FD;
		eax_74 = Mem72[edi + 16:word32];
		rLoc1_159 = (eax_74 - 4)[ecx_32 * 0x04];
		Mem79[eax_59 + -8:real64] = rLoc1_159;
		esi_82 = esi_28 + 0x02;
		eax_84 = eax_6;
	}
	ebp_36 = Mem29[edi + 24:word32];
	ebp_37 = ebp_36 - eax_6;
	edx_40 = esi_28 + 0x02;
	ecx_41 = Mem29[edi + 20:word32];
	eax_42 = Mem29[edi + 0x0C:word32];
	camlArray__blit_1093();
}

// 0804B6B0: define camlSource__merge_1034
// Called from:
//      camlSource__sortto_1060
//      camlSource__sort_floats_1031
define camlSource__merge_1034
{
	word32 eax;
	word32 ecx;
	word32 edx;
	word32 edi;
	word32 ebx;
	word32 esi;
	word32 dwLoc20;
	bool P;
	eax_14 = Mem13[0x0807D0BC<p32>:word32];
	edx_16 = Mem15[0x0807D0C0<p32>:word32];
	ecx_19 = eax - 1 + ebx;
	esi_22 = edx - 1 + esi;
	while (true)
	{
		P_99 = ϕ(P, P_35);
		Mem23 = ϕ(Mem15, Mem26);
		eax_24 = Mem23[0x08080414<p32>:word32];
		Mem26[0x08080414<p32>:word32] = eax_24 - 0x3C;
		if (eax_24 - 0x3C >=u Mem26[0x08080418<p32>:word32])
			break;
		fn080708CC();
	}
	Mem37[eax_24 + -60:word32] = 0x20F7;
	Mem38[eax_24 + -56:word32] = 0x0804B0D0;
	Mem39[eax_24 + -52:word32] = 11;
	Mem40[eax_24 + -48:word32] = 0x0804B5A0;
	eax_42 = Mem40[edx_16 + 0x0C:word32];
	Mem43[eax_24 + -44:word32] = eax_42;
	Mem45[eax_24 + -40:word32] = ecx;
	Mem47[eax_24 + -36:word32] = edi;
	Mem49[eax_24 + -32:word32] = ecx_19;
	Mem51[eax_24 + -28:word32] = esi_22;
	Mem53[eax_24 + -24:word32] = 0x08FD;
	rLoc1_95 = (ecx - 4)[edx * 0x04];
	Mem58[eax_24 + -20:real64] = rLoc1_95;
	Mem61[eax_24 + -0x0C:word32] = 0x08FD;
	eax_62 = Mem61[edx_16 + 0x0C:word32];
	rLoc1_96 = (eax_62 - 4)[eax * 0x04];
	Mem66[eax_24 + -8:real64] = rLoc1_96;
	Top_67 = 0x00;
	camlSource__loop_1044();
}

// 0804B780: define camlSource__isortto_1052
// Called from:
//      camlSource__sortto_1060
//      camlSource__sort_floats_1031
define camlSource__isortto_1052
{
	ptr32 fp;
	word32 eax;
	word32 edx;
	word32 ebx;
	word32 esi;
	word32 ecx;
	word32 edi;
	word16 FPUF;
	ebp_7 = 0x01;
	edx_9 = edx + ~0x01;
	if (edx >= 0x03)
	{
		do
		{
			FPUF_110 = ϕ(FPUF, FPUF_108);
			edi_104 = ϕ(edi, edi_102);
			ebp_17 = ϕ(ebp_7, ebp_61);
			Mem15 = ϕ(Mem13, Mem56);
			ebx_18 = eax + ebp_17;
			eax_22 = Mem15[esi + 0x0C:word32];
			rLoc1_85 = (eax_22 - 8)[ebx_18 * 0x04];
			ebx_29 = ecx - 3 + ebp_17;
			while (true)
			{
				FPUF_109 = ϕ(FPUF_40, FPUF_110);
				edi_103 = ϕ(edi_36, edi_104);
				Mem35 = ϕ(Mem72, Mem26);
				ebx_30 = ϕ(ebx_74, ebx_29);
				if (ebx_30 < ecx)
					break;
				edi_36 = ebx;
				rLoc1_88 = (ebx - 4)[ebx_30 * 0x04];
				FPUF_40 = cond(rLoc1_88 - rLoc1_85);
				ax_42 = __fstsw(FPUF_40);
				ah_43 = SLICE(ax_42, byte, 8);
				if ((ah_43 & 0x05) != 0x00)
					break;
				rLoc1_93 = (ebx - 4)[ebx_30 * 0x04];
				(ebx + 4)[ebx_30 * 0x04] = rLoc1_93;
				ebx_74 = ebx_30 + ~0x01;
			}
			FPUF_108 = ϕ(FPUF_40, FPUF_109);
			edi_102 = ϕ(edi_36, edi_103);
			(ebx + 4)[ebx_30 * 0x04] = rLoc1_85;
			ebp_61 = ebp_17 + 0x02;
		} while (ebp_17 != edx + ~0x01);
	}
	Top_115 = 0;
	FPUF_106 = ϕ(FPUF, FPUF_108);
	edi_100 = ϕ(edi, edi_102);
	ebx_99 = ϕ(ebx, ebx_30);
	ebp_98 = ϕ(ebp_7, ebp_61);
	eax_66 = 0x01;
	SCZO_69 = cond(fp);
	C_97 = SLICE(SCZO_69, bool, 1);
	O_111 = SLICE(SCZO_69, bool, 4);
	S_114 = SLICE(SCZO_69, bool, 0);
	Z_116 = SLICE(SCZO_69, bool, 2);
}

// 0804B800: define camlSource__sortto_1060
// Called from:
//      camlSource__sortto_1060
//      camlSource__sort_floats_1031
define camlSource__sortto_1060
{
	ptr32 fp;
	word32 edx;
	word32 esi;
	word32 ecx;
	word32 ebx;
	word32 eax;
	<unknown> Mem0;
	bool P;
	Top_3 = 0;
	if (edx > 11)
	{
		esi_17 = edx >> 0x01;
		if (edx >> 0x01 < 0x00)
			esi_23 = (edx >> 0x01) + 0x01;
		esi_25 = ϕ(esi_17, esi_23);
		esi_26 = esi_25 >> 0x01;
		esi_27 = esi_26 * 0x02 + 1;
		edx_31 = edx - esi_27;
		ecx_37 = ecx - 1 + esi_27;
		eax_39 = eax - 1 + esi_27;
		camlSource__sortto_1060();
		ecx_50 = eax - 1 + (edx_31 + 0x01);
		ebx_52 = Mem35[esi + 0x0C:word32];
		camlSource__sortto_1060();
		P_124 = SLICE(SCZOP_57, bool, 5);
		eax_59 = Mem35[esi + 16:word32];
		edx_63 = ecx - 1 + esi_27;
		eax_66 = eax - 1 + (edx_31 + 0x01);
		Mem69[0x0807D0BC<p32>:word32] = ecx;
		Mem71[0x0807D0C0<p32>:word32] = eax_59;
		camlSource__merge_1034();
	}
	else
	{
		esi_87 = Mem0[esi + 20:word32];
		camlSource__isortto_1052();
	}
}

// 0804B8C0: define camlSource__sort_floats_1031
// Called from:
//      camlSource__entry
define camlSource__sort_floats_1031
{
	ptr32 fp;
	word32 eax;
	word32 ebx;
	<unknown> Mem0;
	word32 dwLoc2C;
	word32 dwLoc08;
	word32 dwLoc04;
	word32 dwLoc24;
	bool P;
	real64 rLoc1;
	while (true)
	{
		P_226 = ϕ(P, P_20);
		Mem8 = ϕ(Mem0, Mem11);
		eax_9 = Mem8[0x08080414<p32>:word32];
		Mem11[0x08080414<p32>:word32] = eax_9 - 0x44;
		if (eax_9 - 0x44 >=u Mem11[0x08080418<p32>:word32])
			break;
		fn080708CC();
	}
	Mem22[eax_9 + -0x0044:word32] = 4343;
	Mem23[eax_9 + -64:word32] = 0x0804AD50;
	Mem24[eax_9 + -60:word32] = 0x0F;
	Mem25[eax_9 + -56:word32] = 0x0804B6B0;
	Mem28[eax_9 + -52:word32] = ebx;
	esi_29 = eax_9 - 44;
	Mem30[eax_9 + -48:word32] = 4343;
	Mem31[eax_9 + -44:word32] = 134525424;
	Mem32[eax_9 + -40:word32] = 0x09;
	Mem33[eax_9 + -36:word32] = 0x0804B780;
	Mem34[eax_9 + -32:word32] = ebx;
	Mem36[eax_9 + -28:word32] = 0x18F7;
	Mem37[eax_9 + -24:word32] = 134525424;
	Mem38[eax_9 + -20:word32] = 0x09;
	Mem39[eax_9 + -16:word32] = 0x0804B800;
	Mem40[eax_9 + -0x0C:word32] = ebx;
	Mem41[eax_9 + -8:word32] = eax_9 - 0x40;
	Mem42[eax_9 + -4:word32] = eax_9 - 44;
	if (eax > 11)
	{
		eax_50 = eax >> 0x01;
		if (eax >> 0x01 < 0x00)
			eax_56 = (eax >> 0x01) + 0x01;
		eax_58 = ϕ(eax_50, eax_56);
		eax_59 = eax_58 >> 0x01;
		eax_60 = eax_59 * 0x02 + 1;
		edx_64 = eax - eax_60;
		while (true)
		{
			Mem69 = ϕ(Mem68, Mem72);
			eax_70 = Mem69[0x08080414<p32>:word32];
			Mem72[0x08080414<p32>:word32] = eax_70 - 0x0C;
			if (eax_70 - 0x0C >=u Mem72[0x08080418<p32>:word32])
				break;
			fn080708CC();
		}
		Mem83[eax_70 + -0x0C:word32] = 0x08FD;
		rLoc1_188 = Mem83[ebx + 0x00:real64];
		Mem91[eax_70 + -8:real64] = rLoc1_188;
		fn080709D8();
		camlSource__sortto_1060();
		camlSource__sortto_1060();
		Mem149[0x0807D0BC<p32>:word32] = 0x01;
		Mem151[0x0807D0C0<p32>:word32] = dwLoc04;
		esp_152 = fp + 0x08;
		camlSource__merge_1034();
	}
	else
	{
		ecx_166 = 0x01;
		esp_168 = fp;
		camlSource__isortto_1052();
	}
}

// 0804BA40: define camlSource__entry
// Called from:
//      caml_program
define camlSource__entry
{
}

// 0804BE02: define fn0804BE02
// Called from:
//      camlSource__entry
define fn0804BE02
{
	ptr32 fp;
	esp_6 = fp - 4;
	Mem8[0x0807D280<p32>:word32] = fp - 4;
	while (true)
	{
		esp_21 = ϕ(esp_6, esp_67, esp_123);
		Mem9 = ϕ(Mem8, Mem73, Mem114);
		eax_10 = Mem9[0x08076E4C<p32>:word32];
		camlPervasives__input_line_1241();
		esp_22 = esp_21 + 0x04;
		Mem24[esp_22 + -4:word32] = eax_11;
		fn080709D8();
		eax_31 = Mem24[0x080741FC<p32>:word32];
		ecx_32 = Mem24[eax_31 + 0x00:word32];
		eax_33 = Mem24[0x08074208<p32>:word32];
		eax_34 = Mem24[eax_33 + 0x00:word32];
		rLoc1_126 = Mem24[eax_26 + 0x00:real64];
		(eax_34 - 4)[ecx_32 * 0x04] = rLoc1_126;
		fn0807092C();
		Mem46[eax_40 + 0x00:word32] = 0x08FD;
		eax_47 = Mem46[0x08074200<p32>:word32];
		eax_48 = Mem46[eax_47 + 0x00:word32];
		rLoc1_127 = Mem46[eax_48 + 0x00:real64];
		rLoc1_128 = rLoc1_127 + Mem46[eax_26 + 0x00:real64];
		Mem52[eax_40 + 4:real64] = rLoc1_128;
		Mem55[esp_22 + -4:word32] = eax_40 + 4;
		v10_56 = Mem55[0x08074200<p32>:word32];
		Mem58[esp_22 + -8:word32] = v10_56;
		caml_modify();
		esp_67 = esp_22;
		eax_68 = Mem58[0x080741FC<p32>:word32];
		v11_69 = Mem58[eax_68 + 0x00:word32] + 0x02;
		Mem70[eax_68 + 0x00:word32] = v11_69;
		eax_71 = Mem70[0x08074204<p32>:word32];
		ebx_72 = Mem70[eax_71 + 0x00:word32];
		Mem73[esp_22 + 8:word32] = ebx_72;
		eax_74 = Mem73[0x080741FC<p32>:word32];
		eax_75 = Mem73[eax_74 + 0x00:word32];
		if (eax_75 == ebx_72)
		{
			ebx_78 = ebx_72 * 0x04 + ~0x02;
			eax_79 = Mem73[0x08074204<p32>:word32];
			Mem80[eax_79 + 0x00:word32] = ebx_78;
			Mem82[esp_22 + -4:word32] = 0x08074318;
			Mem84[esp_22 + -8:word32] = ebx_78;
			fn080709D8();
			Mem91[esp_22 + 0x0C:word32] = eax_86;
			eax_94 = Mem91[0x08074208<p32>:word32];
			eax_95 = Mem91[eax_94 + 0x00:word32];
			esi_96 = Mem91[esp_22 + 8:word32];
			camlArray__blit_1093();
			eax_109 = Mem91[esp_22 + 0x10:word32];
			Mem111[esp_22 + 0x00:word32] = eax_109;
			v15_112 = Mem111[0x08074208<p32>:word32];
			Mem114[esp_22 + -4:word32] = v15_112;
			caml_modify();
			esp_123 = esp_22 + 0x04;
		}
	}
}

// 0804BEF0: define camlUnix__fun_2842
define camlUnix__fun_2842
{
	esp = fp;
	Top = 0;
	esi = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x24;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 0x0801;
	Mem0[edx + 0x00:word32] = esi;
	eax = Mem0[ecx + 20:word32];
	Mem0[edx + 4:word32] = eax;
	eax = edx + 0x0C;
	Mem0[eax + -4:word32] = 0x1400;
	Mem0[eax + 0x00:word32] = 0x03;
	esi = Mem0[ecx + 16:word32];
	Mem0[eax + 4:word32] = esi;
	ecx = Mem0[ecx + 0x0C:word32];
	ecx = Mem0[ecx + 0x00:word32];
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = edx;
	Mem0[eax + 16:word32] = ebx;
}

// 0804BF50: define camlUnix__fun_2828
define camlUnix__fun_2828
{
	esp = fp;
	Top = 0;
	SZP = cond(eax & 0x01);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax >>= 0x01;
		SCZO = cond(eax - 0x02);
		if (Test(GE,SO))
		{
			eax = Mem0[ebx + 16:word32];
			Mem0[eax + 0x00:word32] = 0x03;
			eax = 0x01;
			return;
		}
	}
	else
	{
		ecx = CONVERT(Mem0[eax + -4:byte], byte, word32);
		SCZO = cond(ecx - 0x01);
		if (Test(UGE,C))
		{
			if (Test(GT,SZO))
			{
				ecx = Mem0[eax + 0x00:word32];
				eax = Mem0[ebx + 0x0C:word32];
				Mem0[eax + 0x00:word32] = ecx;
				eax = 0x01;
				return;
			}
			else
			{
				ecx = Mem0[eax + 0x00:word32];
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x08;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				v15 = Mem0[ebx + 8:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = v15;
				caml_modify();
				esp += 0x08;
				SCZO = cond(esp);
				eax = 0x01;
				return;
			}
		}
	}
	eax = 0x01;
}

// 0804BFD0: define camlUnix__get_port_1739
// Called from:
//      camlUnix__getaddrinfo_1751
define camlUnix__get_port_1739
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	esi = eax;
	edi = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x080753FC;
	v9 = Mem0[edi + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v9;
	caml_string_equal();
	esp += 0x08;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = edi;
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 8:word32] = esi;
		fn0804C110();
		ecx = 0x080739CC;
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - ecx);
		if (Test(NE,Z))
		{
			fn08070A44();
			esi = esi;
			edi += 0x00;
			fn0804C110();
		}
		else
		{
			fn0804C080();
			ecx = 134691416;
			ebx = Mem0[eax + 0x00:word32];
			SCZO = cond(ebx - ecx);
			if (Test(NE,Z))
			{
				fn08070A44();
				esi = esi;
				edi += 0x00;
				fn0804C080();
			}
			else
			{
				eax = 0x01;
				esp += 0x0C;
				SCZO = cond(esp);
			}
		}
	}
	else
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x18;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ebx = eax + 4;
		Mem0[ebx + -4:word32] = 0x0800;
		Mem0[ebx + 0x00:word32] = esi;
		Mem0[ebx + 4:word32] = 0x01;
		eax = ebx + 0x0C;
		Mem0[eax + -4:word32] = 0x0800;
		Mem0[eax + 0x00:word32] = ebx;
		Mem0[eax + 4:word32] = 0x01;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 0804C080: define fn0804C080
// Called from:
//      camlUnix__get_port_1739
define fn0804C080
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 16:word32];
	v6 = Mem0[eax + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v6;
	eax = 134604443;
	fn080709D8();
	esp += 0x08;
	eax += 0x08;
	SCZO = cond(eax);
	ecx = Mem0[eax + 0x00:word32];
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x18;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0800;
	eax = Mem0[esp + 16:word32];
	Mem0[ebx + 0x00:word32] = eax;
	Mem0[ebx + 4:word32] = ecx;
	eax = ebx + 0x0C;
	Mem0[eax + -4:word32] = 0x0800;
	Mem0[eax + 0x00:word32] = ebx;
	Mem0[eax + 4:word32] = 0x01;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C110: define fn0804C110
// Called from:
//      camlUnix__get_port_1739
define fn0804C110
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	v6 = Mem0[edi + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v6;
	eax = 0x080668B4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x18;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0800;
	eax = Mem0[esp + 16:word32];
	Mem0[ebx + 0x00:word32] = eax;
	Mem0[ebx + 4:word32] = ecx;
	eax = ebx + 0x0C;
	Mem0[eax + -4:word32] = 0x0800;
	Mem0[eax + 0x00:word32] = ebx;
	Mem0[eax + 4:word32] = 0x01;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C1A0: define camlUnix__fun_2833
define camlUnix__fun_2833
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0800;
	Mem0[eax + 0x00:word32] = ecx;
	ebx = Mem0[ebx + 8:word32];
	ebx = Mem0[ebx + 0x00:word32];
	Mem0[eax + 4:word32] = ebx;
}

// 0804C1E0: define camlUnix__fun_2836
define camlUnix__fun_2836
{
	esp = fp;
	Top = 0;
	esi = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x1C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x18F7;
	Mem0[eax + 0x00:word32] = 0x0804B3C0;
	Mem0[eax + 4:word32] = ~0x02;
	Mem0[eax + 8:word32] = 0x0804BEF0;
	edx = Mem0[ecx + 0x0C:word32];
	Mem0[eax + 0x0C:word32] = edx;
	Mem0[eax + 16:word32] = esi;
	Mem0[eax + 20:word32] = ebx;
	ebx = Mem0[ecx + 16:word32];
	camlList__map_1062();
}

// 0804C230: define camlUnix__fun_2857
define camlUnix__fun_2857
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C240: define camlUnix__fun_2863
define camlUnix__fun_2863
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C250: define camlUnix__fun_2562
define camlUnix__fun_2562
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805FE40;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C260: define camlUnix__fun_2564
define camlUnix__fun_2564
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060EA0;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C270: define camlUnix__fun_2566
define camlUnix__fun_2566
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134614773;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C280: define camlUnix__fun_2568
define camlUnix__fun_2568
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060F4A;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C290: define camlUnix__fun_2570
define camlUnix__fun_2570
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060F8F;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C2A0: define camlUnix__fun_2572
define camlUnix__fun_2572
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060FDD;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C2C0: define camlUnix__fun_2574
define camlUnix__fun_2574
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08061211;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C2D0: define camlUnix__fun_2576
define camlUnix__fun_2576
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E657;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C2E0: define camlUnix__fun_2578
define camlUnix__fun_2578
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134604443;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C2F0: define camlUnix__fun_2580
define camlUnix__fun_2580
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134603610;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C300: define camlUnix__fun_2582
define camlUnix__fun_2582
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134603661;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C310: define camlUnix__fun_2584
define camlUnix__fun_2584
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805DF7F;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C320: define camlUnix__fun_2586
define camlUnix__fun_2586
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134602339;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C330: define camlUnix__fun_2588
define camlUnix__fun_2588
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E018;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C340: define camlUnix__fun_2590
define camlUnix__fun_2590
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E1E8;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C350: define camlUnix__fun_2592
define camlUnix__fun_2592
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134604500;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C360: define camlUnix__fun_2594
define camlUnix__fun_2594
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134610604;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C370: define camlUnix__fun_2596
define camlUnix__fun_2596
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805ECCC;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C380: define camlUnix__fun_2598
define camlUnix__fun_2598
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D000;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C390: define camlUnix__fun_2600
define camlUnix__fun_2600
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CDA4;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C3A0: define camlUnix__fun_2602
define camlUnix__fun_2602
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CB9C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C3B0: define camlUnix__fun_2604
define camlUnix__fun_2604
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060534;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C3D0: define camlUnix__fun_2606
define camlUnix__fun_2606
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060188;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C3F0: define camlUnix__fun_2608
define camlUnix__fun_2608
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060DB8;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C400: define camlUnix__fun_2610
define camlUnix__fun_2610
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CCF4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C410: define camlUnix__fun_2612
define camlUnix__fun_2612
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805DC70;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C420: define camlUnix__fun_2614
define camlUnix__fun_2614
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E4CC;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C430: define camlUnix__fun_2616
define camlUnix__fun_2616
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805DCA3;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C440: define camlUnix__fun_2618
define camlUnix__fun_2618
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134604031;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C450: define camlUnix__fun_2620
define camlUnix__fun_2620
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E058;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C460: define camlUnix__fun_2622
define camlUnix__fun_2622
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E9D8;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C470: define camlUnix__fun_2624
define camlUnix__fun_2624
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134610356;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C480: define camlUnix__fun_2626
define camlUnix__fun_2626
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805DCD4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C490: define camlUnix__fun_2628
define camlUnix__fun_2628
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805FD6C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C4A0: define camlUnix__fun_2630
define camlUnix__fun_2630
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805DB38;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C4B0: define camlUnix__fun_2632
define camlUnix__fun_2632
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805DB80;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C4C0: define camlUnix__fun_2634
define camlUnix__fun_2634
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805FE64;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C4D0: define camlUnix__fun_2636
define camlUnix__fun_2636
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805DB5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C4E0: define camlUnix__fun_2638
define camlUnix__fun_2638
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134604620;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C4F0: define camlUnix__fun_2640
define camlUnix__fun_2640
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805EB99;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C500: define camlUnix__fun_2642
define camlUnix__fun_2642
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805EAAD;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C510: define camlUnix__fun_2644
define camlUnix__fun_2644
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08061764;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C530: define camlUnix__fun_2646
define camlUnix__fun_2646
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08061400;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C540: define camlUnix__fun_2648
define camlUnix__fun_2648
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060154;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C550: define camlUnix__fun_2650
define camlUnix__fun_2650
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CD78;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C560: define camlUnix__fun_2652
define camlUnix__fun_2652
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E7FD;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C570: define camlUnix__fun_2654
define camlUnix__fun_2654
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E90E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C580: define camlUnix__fun_2656
define camlUnix__fun_2656
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E973;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C590: define camlUnix__fun_2658
define camlUnix__fun_2658
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E530;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C5A0: define camlUnix__fun_2660
define camlUnix__fun_2660
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080613CC;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C5B0: define camlUnix__fun_2662
define camlUnix__fun_2662
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805FF5D;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C5C0: define camlUnix__fun_2664
define camlUnix__fun_2664
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060074;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C5D0: define camlUnix__fun_2666
define camlUnix__fun_2666
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080600C6;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C5E0: define camlUnix__fun_2668
define camlUnix__fun_2668
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805EC24;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C5F0: define camlUnix__fun_2670
define camlUnix__fun_2670
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134606108;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C610: define camlUnix__fun_2672
define camlUnix__fun_2672
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F734;
	fn080709D8();
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804C630: define camlUnix__fun_2674
define camlUnix__fun_2674
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F4B8;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C640: define camlUnix__fun_2676
define camlUnix__fun_2676
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060E44;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C650: define camlUnix__fun_2678
define camlUnix__fun_2678
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F070;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C660: define camlUnix__fun_2680
define camlUnix__fun_2680
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C670: define camlUnix__fun_2682
define camlUnix__fun_2682
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CFA4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C680: define camlUnix__fun_2684
define camlUnix__fun_2684
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F578;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C690: define camlUnix__fun_2686
define camlUnix__fun_2686
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F45C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C6A0: define camlUnix__fun_2688
define camlUnix__fun_2688
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F208;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C6B0: define camlUnix__fun_2690
define camlUnix__fun_2690
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF14;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C6C0: define camlUnix__fun_2692
define camlUnix__fun_2692
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134601436;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C6D0: define camlUnix__fun_2694
define camlUnix__fun_2694
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CE1C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C6E0: define camlUnix__fun_2696
define camlUnix__fun_2696
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F5C4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C6F0: define camlUnix__fun_2698
define camlUnix__fun_2698
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F01C;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C700: define camlUnix__fun_2700
define camlUnix__fun_2700
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134599596;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C710: define camlUnix__fun_2702
define camlUnix__fun_2702
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D426;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C720: define camlUnix__fun_2704
define camlUnix__fun_2704
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D4A0;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C730: define camlUnix__fun_2706
define camlUnix__fun_2706
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D51A;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C740: define camlUnix__fun_2708
define camlUnix__fun_2708
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D0C4;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C750: define camlUnix__fun_2710
define camlUnix__fun_2710
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D080;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C760: define camlUnix__fun_2712
define camlUnix__fun_2712
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CC90;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C770: define camlUnix__fun_2714
define camlUnix__fun_2714
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08061558;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C780: define camlUnix__fun_2716
define camlUnix__fun_2716
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D354;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C7A0: define camlUnix__fun_2718
define camlUnix__fun_2718
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CEB8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C7C0: define camlUnix__fun_2720
define camlUnix__fun_2720
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D304;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C7D0: define camlUnix__fun_2722
define camlUnix__fun_2722
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134598244;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C7E0: define camlUnix__fun_2724
define camlUnix__fun_2724
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805EC7C;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C7F0: define camlUnix__fun_2726
define camlUnix__fun_2726
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F528;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C800: define camlUnix__fun_2728
define camlUnix__fun_2728
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134616860;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C810: define camlUnix__fun_2730
define camlUnix__fun_2730
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805EA24;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C820: define camlUnix__fun_2732
define camlUnix__fun_2732
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060BED;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C830: define camlUnix__fun_2734
define camlUnix__fun_2734
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060C8B;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C840: define camlUnix__fun_2736
define camlUnix__fun_2736
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060D21;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C850: define camlUnix__fun_2738
define camlUnix__fun_2738
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D66A;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C860: define camlUnix__fun_2740
define camlUnix__fun_2740
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134616317;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C870: define camlUnix__fun_2742
define camlUnix__fun_2742
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805EF66;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C890: define camlUnix__fun_2744
define camlUnix__fun_2744
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134646339;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C8A0: define camlUnix__fun_2746
define camlUnix__fun_2746
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134646339;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C8B0: define camlUnix__fun_2748
define camlUnix__fun_2748
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C6E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C8C0: define camlUnix__fun_2750
define camlUnix__fun_2750
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C37;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C8D0: define camlUnix__fun_2752
define camlUnix__fun_2752
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C8E0: define camlUnix__fun_2754
define camlUnix__fun_2754
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134607140;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C900: define camlUnix__fun_2756
define camlUnix__fun_2756
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F0C4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C910: define camlUnix__fun_2758
define camlUnix__fun_2758
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E284;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C920: define camlUnix__fun_2760
define camlUnix__fun_2760
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134603360;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C930: define camlUnix__fun_2762
define camlUnix__fun_2762
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080618EF;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C940: define camlUnix__fun_2764
define camlUnix__fun_2764
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08061969;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C950: define camlUnix__fun_2766
define camlUnix__fun_2766
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D5A0;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C960: define camlUnix__fun_2768
define camlUnix__fun_2768
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D238;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C980: define camlUnix__fun_2770
define camlUnix__fun_2770
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D2B2;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C990: define camlUnix__fun_2772
define camlUnix__fun_2772
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D1CC;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804C9B0: define camlUnix__fun_2774
define camlUnix__fun_2774
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D17C;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C9C0: define camlUnix__fun_2776
define camlUnix__fun_2776
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805F2D0;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804C9D0: define camlUnix__fun_2778
define camlUnix__fun_2778
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0806C0FD;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C9E0: define camlUnix__fun_2780
define camlUnix__fun_2780
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D114;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804C9F0: define camlUnix__fun_2782
define camlUnix__fun_2782
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D13C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804CA00: define camlUnix__handle_unix_error_1171
define camlUnix__handle_unix_error_1171
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	edx = eax;
	eax = ebx;
	fn0804CB10();
	ecx = Mem0[0x08074608<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn0804CB10();
	}
	else
	{
		ebx = Mem0[eax + 0x0C:word32];
		Mem0[esp + 8:word32] = ebx;
		ebx = Mem0[eax + 8:word32];
		Mem0[esp + 0x00:word32] = ebx;
		eax = Mem0[eax + 4:word32];
		Mem0[esp + 4:word32] = eax;
		ebx = Mem0[0x08079C18<p32>:word32];
		eax = Mem0[ebx + -4:word32];
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			esi += 0x00;
			edi += 0x00;
			camlUnix__read_1237();
		}
		else
		{
			ebx = Mem0[ebx + 0x00:word32];
			eax = Mem0[0x08076E54<p32>:word32];
			camlPervasives__output_string_1191();
			ebx = 0x080753F4;
			eax = Mem0[0x08076E54<p32>:word32];
			camlPervasives__output_string_1191();
			eax = Mem0[0x08076E54<p32>:word32];
			ebx = Mem0[esp + 0x00:word32];
			camlPervasives__output_string_1191();
			ebx = 0x080753E4;
			eax = Mem0[0x08076E54<p32>:word32];
			camlPervasives__output_string_1191();
			eax = Mem0[esp + 8:word32];
			ebx = Mem0[eax + -4:word32];
			ebx >>= 0x0A;
			ebx = ~0x00 + ebx * 0x04;
			ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
			ebx -= ecx;
			ebx = ebx + 1 + ebx;
			SCZO = cond(ebx - 0x01);
			if (Test(GT,SZO))
			{
				Mem0[esp + 8:word32] = eax;
				ebx = 0x080753D8;
				eax = Mem0[0x08076E54<p32>:word32];
				camlPervasives__output_string_1191();
				eax = Mem0[0x08076E54<p32>:word32];
				ebx = Mem0[esp + 8:word32];
				camlPervasives__output_string_1191();
				ebx = 0x080753D0;
				eax = Mem0[0x08076E54<p32>:word32];
				camlPervasives__output_string_1191();
			}
			ebx = 0x080753C8;
			eax = Mem0[0x08076E54<p32>:word32];
			camlPervasives__output_string_1191();
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x0805D13C;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
			camlPervasives__prerr_endline_1285();
			eax = 0x05;
			esp += 0x0C;
			SCZO = cond(esp);
			camlPervasives__exit_1326();
		}
	}
}

// 0804CB10: define fn0804CB10
// Called from:
//      camlUnix__handle_unix_error_1171
define fn0804CB10
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	ecx = Mem0[edx + 0x00:word32];
	ebx = edx;
	ecx();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804CB40: define camlUnix__read_1237
// Called from:
//      camlUnix__handle_unix_error_1171
define camlUnix__read_1237
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[ebx + -4:word32];
			esi >>= 0x0A;
			esi = ~0x00 + esi * 0x04;
			edi = CONVERT(Mem0[ebx + esi:byte], byte, word32);
			esi -= edi;
			esi <<= 0x01;
			esi -= edx;
			esi += 0x02;
			SCZO = cond(ecx - esi);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x0805F384;
				fn080709D8();
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x080753B8;
	camlPervasives__invalid_arg_1012();
}

// 0804CB90: define camlUnix__write_1242
define camlUnix__write_1242
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[ebx + -4:word32];
			esi >>= 0x0A;
			esi = ~0x00 + esi * 0x04;
			edi = CONVERT(Mem0[ebx + esi:byte], byte, word32);
			esi -= edi;
			esi <<= 0x01;
			esi -= edx;
			esi += 0x02;
			SCZO = cond(ecx - esi);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 134617773;
				fn080709D8();
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x080753A8;
	camlPervasives__invalid_arg_1012();
}

// 0804CBE0: define camlUnix__single_write_1247
define camlUnix__single_write_1247
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[ebx + -4:word32];
			esi >>= 0x0A;
			esi = ~0x00 + esi * 0x04;
			edi = CONVERT(Mem0[ebx + esi:byte], byte, word32);
			esi -= edi;
			esi <<= 0x01;
			esi -= edx;
			esi += 0x02;
			SCZO = cond(ecx - esi);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x080619C8;
				fn080709D8();
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x08075390;
	camlPervasives__invalid_arg_1012();
}

// 0804CC30: define camlUnix__fun_2804
define camlUnix__fun_2804
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060AD3;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804CC40: define camlUnix__fun_2802
define camlUnix__fun_2802
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060B2F;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804CC50: define camlUnix__fun_2800
define camlUnix__fun_2800
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060B8E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804CC60: define camlUnix__fun_2798
define camlUnix__fun_2798
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134600212;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804CC70: define camlUnix__fun_2796
define camlUnix__fun_2796
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080614A4;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804CC80: define camlUnix__fun_2794
define camlUnix__fun_2794
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805EED8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804CCA0: define camlUnix__try_set_close_on_exec_1366
// Called from:
//      fn0804E6B0
//      camlUnix__establish_server_2026
define camlUnix__try_set_close_on_exec_1366
{
	esp = fp;
	Top = 0;
	fn0804CCD0();
	ecx = 0x080739E8;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn0804CCD0();
	}
	else
		eax = 0x01;
}

// 0804CCD0: define fn0804CCD0
// Called from:
//      camlUnix__try_set_close_on_exec_1366
define fn0804CCD0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D426;
	fn080709D8();
	esp += 0x04;
	eax = 0x03;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804CD00: define camlUnix__pause_1408
define camlUnix__pause_1408
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x03;
	eax = 0x080600C6;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805FF5D;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804CD20: define camlUnix__is_inet6_addr_1500
define camlUnix__is_inet6_addr_1500
{
	esp = fp;
	Top = 0;
	ecx = eax;
	ebx = Mem0[ecx + -4:word32];
	ebx >>= 0x0A;
	eax = ~0x00 + ebx * 0x04;
	ebx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ebx;
	eax = eax + 1 + eax;
	SCZO = cond(eax - 33);
	al = CONVERT(Test(EQ,Z), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
}

// 0804CD50: define camlUnix__domain_of_sockaddr_1529
// Called from:
//      camlUnix__open_connection_2018
//      camlUnix__establish_server_2026
define camlUnix__domain_of_sockaddr_1529
{
	esp = fp;
	Top = 0;
	ebx = CONVERT(Mem0[eax + -4:byte], byte, word32);
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(EQ,Z))
		eax = 0x01;
	else
	{
		ebx = Mem0[eax + 0x00:word32];
		eax = Mem0[ebx + -4:word32];
		eax >>= 0x0A;
		eax = ~0x00 + eax * 0x04;
		ebx = CONVERT(Mem0[ebx + eax:byte], byte, word32);
		eax -= ebx;
		eax = eax + 1 + eax;
		SCZO = cond(eax - 33);
		if (Test(NE,Z))
			eax = 0x03;
		else
			eax = 0x05;
	}
}

// 0804CDA0: define camlUnix__recv_1558
define camlUnix__recv_1558
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			edi = Mem0[ebx + -4:word32];
			edi >>= 0x0A;
			ebp = ~0x00 + edi * 0x04;
			edi = CONVERT(Mem0[ebx + ebp:byte], byte, word32);
			ebp -= edi;
			ebp <<= 0x01;
			ebp -= edx;
			ebp += 0x02;
			SCZO = cond(ecx - ebp);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = esi;
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x0805FC77;
				fn080709D8();
				esp += 0x14;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x08075380;
	camlPervasives__invalid_arg_1012();
}

// 0804CDF0: define camlUnix__recvfrom_1564
define camlUnix__recvfrom_1564
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			edi = Mem0[ebx + -4:word32];
			edi >>= 0x0A;
			ebp = ~0x00 + edi * 0x04;
			edi = CONVERT(Mem0[ebx + ebp:byte], byte, word32);
			ebp -= edi;
			ebp <<= 0x01;
			ebp -= edx;
			ebp += 0x02;
			SCZO = cond(ecx - ebp);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = esi;
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x0805FB09;
				fn080709D8();
				esp += 0x14;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x0807536C;
	camlPervasives__invalid_arg_1012();
}

// 0804CE40: define camlUnix__send_1570
define camlUnix__send_1570
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			edi = Mem0[ebx + -4:word32];
			edi >>= 0x0A;
			ebp = ~0x00 + edi * 0x04;
			edi = CONVERT(Mem0[ebx + ebp:byte], byte, word32);
			ebp -= edi;
			ebp <<= 0x01;
			ebp -= edx;
			ebp += 0x02;
			SCZO = cond(ecx - ebp);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = esi;
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x0805FA49;
				fn080709D8();
				esp += 0x14;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x0807535C;
	camlPervasives__invalid_arg_1012();
}

// 0804CE90: define camlUnix__sendto_1576
define camlUnix__sendto_1576
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			Mem0[esp + 0x00:word32] = eax;
			eax = Mem0[ebx + -4:word32];
			eax >>= 0x0A;
			ebp = ~0x00 + eax * 0x04;
			eax = CONVERT(Mem0[ebx + ebp:byte], byte, word32);
			ebp -= eax;
			ebp <<= 0x01;
			ebp -= edx;
			ebp += 0x02;
			SCZO = cond(ecx - ebp);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edi;
				esp -= 4;
				Mem0[esp + 0x00:word32] = esi;
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				eax = Mem0[esp + 20:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x0805F910;
				fn080709D8();
				esp += 0x18;
				esp += 0x04;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x0807534C;
	esp += 0x04;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 0804CEF0: define camlUnix__fun_2816
define camlUnix__fun_2816
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080606CB;
	fn080709D8();
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804CF10: define camlUnix__fun_2814
define camlUnix__fun_2814
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080608D8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804CF30: define camlUnix__getsockopt_1643
define camlUnix__getsockopt_1643
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x080608D8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804CF50: define camlUnix__setsockopt_1646
// Called from:
//      camlUnix__establish_server_2026
define camlUnix__setsockopt_1646
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x080606CB;
	fn080709D8();
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804CF70: define camlUnix__getsockopt_int_1650
define camlUnix__getsockopt_int_1650
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x03;
	eax = 0x080608D8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804CF90: define camlUnix__setsockopt_int_1653
define camlUnix__setsockopt_int_1653
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x03;
	eax = 0x080606CB;
	fn080709D8();
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804CFB0: define camlUnix__getsockopt_optint_1657
define camlUnix__getsockopt_optint_1657
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x05;
	eax = 0x080608D8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804CFD0: define camlUnix__setsockopt_optint_1660
define camlUnix__setsockopt_optint_1660
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x05;
	eax = 0x080606CB;
	fn080709D8();
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804CFF0: define camlUnix__getsockopt_float_1664
define camlUnix__getsockopt_float_1664
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x07;
	eax = 0x080608D8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804D010: define camlUnix__setsockopt_float_1667
define camlUnix__setsockopt_float_1667
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x07;
	eax = 0x080606CB;
	fn080709D8();
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804D030: define camlUnix__getsockopt_error_1671
define camlUnix__getsockopt_error_1671
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x09;
	eax = 0x080608D8;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804D050: define camlUnix__getaddrinfo_emulation_1730
// Called from:
//      camlUnix__getaddrinfo_1751
define camlUnix__getaddrinfo_emulation_1730
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	ebx = ecx;
	Mem0[esp + 16:word32] = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x30;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edi = eax + 4;
	Mem0[esp + 4:word32] = edi;
	Mem0[edi + -4:word32] = 0x0400;
	Mem0[edi + 0x00:word32] = 0x01;
	esi = edi + 8;
	Mem0[esp + 8:word32] = esi;
	Mem0[esi + -4:word32] = 0x0400;
	Mem0[esi + 0x00:word32] = 0x01;
	edx = edi + 16;
	Mem0[edx + -4:word32] = 0x0400;
	Mem0[edx + 0x00:word32] = 0x01;
	eax = edi + 24;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x0804BF50;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = edi;
	Mem0[eax + 0x0C:word32] = esi;
	Mem0[eax + 16:word32] = edx;
	camlList__iter_1074();
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x0804BFD0;
	edx = Mem0[esp + 0x00:word32];
	Mem0[ecx + 0x0C:word32] = edx;
	eax = Mem0[esp + 4:word32];
	eax = Mem0[eax + 0x00:word32];
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - 0x03);
		if (Test(NE,Z))
		{
			SCZO = cond(ebx - 0x01);
			if (Test(NE,Z))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = 0x08075344;
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				caml_string_equal();
				esp += 0x08;
				SCZO = cond(eax - 0x01);
				if (Test(NE,Z))
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x18;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					ecx = eax + 4;
					Mem0[ecx + -4:word32] = 0x0800;
					Mem0[ecx + 0x00:word32] = ebx;
					Mem0[ecx + 4:word32] = 0x01;
					eax = ecx + 0x0C;
					Mem0[esp + 0x00:word32] = eax;
					Mem0[eax + -4:word32] = 0x0800;
					Mem0[eax + 0x00:word32] = ecx;
					Mem0[eax + 4:word32] = 0x01;
				}
				else
				{
					eax = 0x01;
					Mem0[esp + 0x00:word32] = eax;
				}
			}
			else
			{
				ebx = 0x0807533C;
				eax = 0x01;
				camlUnix__get_port_1739();
				Mem0[esp + 0x00:word32] = eax;
			}
		}
		else
		{
			ebx = 0x08075334;
			eax = 0x03;
			camlUnix__get_port_1739();
			Mem0[esp + 0x00:word32] = eax;
		}
	}
	else
	{
		Mem0[esp + 0x00:word32] = ecx;
		ebx = 134697772;
		eax = 0x03;
		camlUnix__get_port_1739();
		Mem0[esp + 4:word32] = eax;
		ebx = 134697764;
		eax = 0x01;
		ecx = Mem0[esp + 0x00:word32];
		camlUnix__get_port_1739();
		ebx = Mem0[esp + 4:word32];
		camlPervasives__$40_1143();
		Mem0[esp + 0x00:word32] = eax;
	}
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x0807531C;
	ebx = Mem0[esp + 16:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	caml_string_equal();
	esp += 0x08;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x0C:word32] = ebx;
		fn0804D3C0();
		ecx = 0x080739CC;
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - ecx);
		if (Test(NE,Z))
		{
			fn08070A44();
			esi = esi;
			edi += 0x00;
			fn0804D3C0();
		}
		else
		{
			fn0804D330();
			ecx = 134691416;
			ebx = Mem0[eax + 0x00:word32];
			SCZO = cond(ebx - ecx);
			if (Test(NE,Z))
			{
				fn08070A44();
				esi = esi;
				edi += 0x00;
				fn0804D330();
			}
			else
			{
				ecx = 0x01;
				fn0804D424();
			}
		}
	}
	else
	{
		eax = 0x05;
		ebx = Mem0[esp + 16:word32];
		camlList__mem_1161();
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x18;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ebx = eax + 4;
			Mem0[ebx + -4:word32] = 0x0800;
			eax = Mem0[0x080747C0<p32>:word32];
			Mem0[ebx + 0x00:word32] = eax;
			Mem0[ebx + 4:word32] = 0x08075300;
			ecx = ebx + 0x0C;
			Mem0[ecx + -4:word32] = 0x0800;
			Mem0[ecx + 0x00:word32] = ebx;
			Mem0[ecx + 4:word32] = 0x01;
			fn0804D424();
		}
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x18;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ebx = eax + 4;
			Mem0[ebx + -4:word32] = 0x0800;
			eax = Mem0[0x080747BC<p32>:word32];
			Mem0[ebx + 0x00:word32] = eax;
			Mem0[ebx + 4:word32] = 0x08075310;
			ecx = ebx + 0x0C;
			Mem0[ecx + -4:word32] = 0x0800;
			Mem0[ecx + 0x00:word32] = ebx;
			Mem0[ecx + 4:word32] = 0x01;
			fn0804D424();
		}
	}
}

// 0804D330: define fn0804D330
// Called from:
//      camlUnix__getaddrinfo_1751
define fn0804D330
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134602339;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[eax + 0x0C:word32];
	camlArray__to_list_1121();
	ebx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 3319;
	Mem0[eax + 0x00:word32] = 0x0804C1A0;
	Mem0[eax + 4:word32] = 0x03;
	ecx = Mem0[esp + 0x0C:word32];
	Mem0[eax + 8:word32] = ecx;
	camlList__map_1062();
	ecx = eax;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	fn0804D424();
}

// 0804D3C0: define fn0804D3C0
// Called from:
//      camlUnix__getaddrinfo_1751
define fn0804D3C0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	eax = 0x0805CCF4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x18;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0800;
	Mem0[ebx + 0x00:word32] = ecx;
	eax = Mem0[esp + 20:word32];
	Mem0[ebx + 4:word32] = eax;
	ecx = ebx + 0x0C;
	Mem0[ecx + -4:word32] = 0x0800;
	Mem0[ecx + 0x00:word32] = ebx;
	Mem0[ecx + 4:word32] = 0x01;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	fn0804D424();
}

// 0804D424: define fn0804D424
// Called from:
//      fn0804D330
//      fn0804D3C0
//      camlUnix__getaddrinfo_1751
define fn0804D424
{
	esp = fp;
	Top = 0;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x18;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x0804B3C0;
	Mem0[eax + 4:word32] = ~0x02;
	Mem0[eax + 8:word32] = 0x0804C1E0;
	ebx = Mem0[esp + 8:word32];
	Mem0[eax + 0x0C:word32] = ebx;
	Mem0[eax + 16:word32] = ecx;
	ebx = Mem0[esp + 0x00:word32];
	camlList__map_1062();
	esp += 0x14;
	SCZO = cond(esp);
	camlList__flatten_1058();
}

// 0804D4C0: define camlUnix__getaddrinfo_1751
define camlUnix__getaddrinfo_1751
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 8:word32] = ecx;
	fn0804D510();
	ecx = 0x080739E8;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn0804D510();
	}
	else
	{
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
		esp += 0x0C;
		SCZO = cond(esp);
		camlUnix__getaddrinfo_emulation_1730();
	}
}

// 0804D510: define fn0804D510
// Called from:
//      camlUnix__getaddrinfo_1751
define fn0804D510
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D6D0;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
	ebx = 0x01;
	camlList__rev_append_1051();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804D550: define camlUnix__getnameinfo_emulation_1772
// Called from:
//      camlUnix__getnameinfo_1781
define camlUnix__getnameinfo_emulation_1772
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	ecx = CONVERT(Mem0[eax + -4:byte], byte, word32);
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		ebx = Mem0[eax + 0x00:word32];
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		Mem0[eax + 0x00:word32] = 0x080752E8;
		Mem0[eax + 4:word32] = ebx;
		esp += 0x0C;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 8:word32] = ebx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 4:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x00:word32] = eax;
		fn0804D600();
		ecx = 134691416;
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - ecx);
		if (Test(EQ,Z))
		{
			eax = 0x05;
			ebx = Mem0[esp + 8:word32];
			camlList__mem_1161();
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x08;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = 134691416;
				fn08070A44();
			}
			eax = Mem0[esp + 0x00:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x08060DB8;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
		}
		else
		{
			fn08070A44();
			esi = esi;
			edi += 0x00;
		}
		Mem0[esp + 0x00:word32] = eax;
		fn0804D671();
	}
}

// 0804D600: define fn0804D600
// Called from:
//      camlUnix__getnameinfo_1781
define fn0804D600
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = 0x03;
	camlList__mem_1161();
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
		fn0804D61B();
	else
		fn0804D61B();
}

// 0804D61B: define fn0804D61B
// Called from:
//      fn0804D600
//      fn0804D7B6
define fn0804D61B
{
	esp = fp;
	Top = 0;
	eax = Mem0[0x08080414<p32>:word32];
	eax -= 0x08;
	Mem0[0x08080414<p32>:word32] = eax;
	SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
	if (Test(ULT,C))
		fn0804D7B6();
	else
	{
		eax += 4;
		Mem0[eax + -4:word32] = 0x0400;
		Mem0[eax + 0x00:word32] = 134691416;
		fn08070A44();
		esi += 0x00;
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805DF7F;
		fn080709D8();
		esp += 0x04;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 8:word32] = eax;
		Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
		esp += 4;
		esp += 0x04;
		SCZO = cond(esp);
		fn0804D671();
	}
}

// 0804D671: define fn0804D671
// Called from:
//      fn0804D61B
//      camlUnix__getnameinfo_1781
define fn0804D671
{
	esp = fp;
	Top = 0;
	fn0804D6B0();
	ecx = 134691416;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
		fn0804D6A0();
	else
		fn0804D681();
}

// 0804D681: define fn0804D681
// Called from:
//      fn0804D61B
//      fn0804D671
define fn0804D681
{
	esp = fp;
	Top = 0;
	eax = Mem0[esp + 4:word32];
	camlPervasives__string_of_int_1130();
	ecx = eax;
	fn0804D743();
}

// 0804D6A0: define fn0804D6A0
// Called from:
//      fn0804D61B
//      fn0804D671
define fn0804D6A0
{
	esp = fp;
	Top = 0;
	fn08070A44();
	esi = esi;
	edi += 0x00;
	fn0804D6B0();
}

// 0804D6B0: define fn0804D6B0
// Called from:
//      fn0804D600
//      fn0804D671
define fn0804D6B0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = 0x07;
	ebx = Mem0[esp + 16:word32];
	camlList__mem_1161();
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
		fn0804D6CF();
	else
		fn0804D6CF();
}

// 0804D6CF: define fn0804D6CF
// Called from:
//      fn0804D6B0
//      fn0804D7AC
define fn0804D6CF
{
	esp = fp;
	Top = 0;
	eax = Mem0[0x08080414<p32>:word32];
	eax -= 0x08;
	Mem0[0x08080414<p32>:word32] = eax;
	SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
	if (Test(ULT,C))
		fn0804D7AC();
	else
	{
		eax += 4;
		Mem0[eax + -4:word32] = 0x0400;
		Mem0[eax + 0x00:word32] = 134691416;
		fn08070A44();
		esi = esi;
		eax = 0x09;
		ebx = Mem0[esp + 16:word32];
		camlList__mem_1161();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
			eax = 0x080752F8;
		else
			eax = 0x080752F0;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[esp + 16:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805E657;
		fn080709D8();
		esp += 0x08;
		ecx = Mem0[eax + 0x00:word32];
		Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
		esp += 4;
		esp += 0x04;
		SCZO = cond(esp);
		fn0804D743();
	}
}

// 0804D743: define fn0804D743
// Called from:
//      fn0804D600
//      fn0804D6CF
//      fn0804D7A5
define fn0804D743
{
	esp = fp;
	Top = 0;
	eax = Mem0[0x08080414<p32>:word32];
	eax -= 0x0C;
	Mem0[0x08080414<p32>:word32] = eax;
	SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
	if (Test(ULT,C))
		fn0804D7A5();
	else
	{
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		ebx = Mem0[esp + 0x00:word32];
		Mem0[eax + 0x00:word32] = ebx;
		Mem0[eax + 4:word32] = ecx;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 0804D7A5: define fn0804D7A5
// Called from:
//      fn0804D6B0
//      fn0804D743
define fn0804D7A5
{
	esp = fp;
	Top = 0;
	fn080708CC();
	fn0804D743();
}

// 0804D7AC: define fn0804D7AC
// Called from:
//      fn0804D6B0
define fn0804D7AC
{
	esp = fp;
	Top = 0;
	fn080708CC();
	fn0804D6CF();
}

// 0804D7B6: define fn0804D7B6
// Called from:
//      fn0804D600
define fn0804D7B6
{
	esp = fp;
	Top = 0;
	fn080708CC();
	fn0804D61B();
}

// 0804D7D0: define camlUnix__getnameinfo_1781
define camlUnix__getnameinfo_1781
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = ebx;
	fn0804D810();
	ecx = 0x080739E8;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn0804D810();
	}
	else
	{
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
		esp += 0x08;
		SCZO = cond(esp);
		camlUnix__getnameinfo_emulation_1772();
	}
}

// 0804D810: define fn0804D810
// Called from:
//      camlUnix__getnameinfo_1781
define fn0804D810
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805E0A0;
	fn080709D8();
	esp += 0x08;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804D840: define camlUnix__system_1891
define camlUnix__system_1891
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x0805D5A0;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		fn0804D8A0();
		eax = 0xFF;
		esp += 0x04;
		SCZO = cond(esp);
		camlPervasives__exit_1326();
	}
	else
	{
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x01;
		eax = 0x080618EF;
		fn080709D8();
		esp += 0x08;
		eax += 0x04;
		eax = Mem0[eax + 0x00:word32];
		esp += 0x04;
		SCZO = cond(esp);
	}
}

// 0804D8A0: define fn0804D8A0
// Called from:
//      camlUnix__system_1891
define fn0804D8A0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0C00;
	Mem0[ebx + 0x00:word32] = 0x080752D4;
	Mem0[ebx + 4:word32] = 0x080752E0;
	eax = Mem0[esp + 8:word32];
	Mem0[ebx + 8:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x080752C8;
	eax = 0x0805D17C;
	fn080709D8();
	esp += 0x08;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804D910: define camlUnix__safe_dup_1894
// Called from:
//      camlUnix__safe_dup_1894
//      camlUnix__perform_redirections_1900
define camlUnix__safe_dup_1894
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D080;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(eax - 0x07);
	if (Test(LT,SO))
	{
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[esp + 0x00:word32];
		camlUnix__safe_dup_1894();
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[esp + 4:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805CF5C;
		fn080709D8();
		esp += 0x04;
		eax = Mem0[esp + 0x00:word32];
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		esp += 0x08;
		SCZO = cond(esp);
	}
}

// 0804D960: define camlUnix__safe_close_1898
// Called from:
//      camlUnix__perform_redirections_1900
define camlUnix__safe_close_1898
{
	esp = fp;
	Top = 0;
	fn0804D990();
	ecx = Mem0[0x08074608<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn0804D990();
	}
	else
		eax = 0x01;
}

// 0804D990: define fn0804D990
// Called from:
//      camlUnix__safe_close_1898
define fn0804D990
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804D9C0: define camlUnix__perform_redirections_1900
// Called from:
//      fn0804DAE0
//      fn0804DB90
define camlUnix__perform_redirections_1900
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 8:word32] = ecx;
	camlUnix__safe_dup_1894();
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[esp + 4:word32];
	camlUnix__safe_dup_1894();
	Mem0[esp + 16:word32] = eax;
	eax = Mem0[esp + 8:word32];
	camlUnix__safe_dup_1894();
	Mem0[esp + 20:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	camlUnix__safe_close_1898();
	eax = Mem0[esp + 4:word32];
	camlUnix__safe_close_1898();
	eax = Mem0[esp + 8:word32];
	camlUnix__safe_close_1898();
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = Mem0[esp + 16:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D0C4;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	eax = Mem0[esp + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x03;
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D0C4;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	eax = Mem0[esp + 16:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x05;
	eax = Mem0[esp + 24:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D0C4;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	esp += 0x18;
	SCZO = cond(esp);
}

// 0804DA90: define camlUnix__create_process_1907
define camlUnix__create_process_1907
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
	Mem0[esp + 16:word32] = eax;
	Mem0[esp + 0x0C:word32] = ebx;
	Mem0[esp + 0x00:word32] = ecx;
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 8:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x0805D5A0;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		fn0804DAE0();
		eax = 0xFF;
		esp += 0x14;
		SCZO = cond(esp);
		camlPervasives__exit_1326();
	}
	else
	{
		esp += 0x14;
		SCZO = cond(esp);
	}
}

// 0804DAE0: define fn0804DAE0
// Called from:
//      camlUnix__create_process_1907
define fn0804DAE0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[esp + 8:word32];
	ebx = Mem0[esp + 0x0C:word32];
	ecx = Mem0[esp + 16:word32];
	camlUnix__perform_redirections_1900();
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 28:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D2B2;
	fn080709D8();
	esp += 0x08;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x14;
	SCZO = cond(esp);
}

// 0804DB30: define camlUnix__create_process_env_1914
define camlUnix__create_process_env_1914
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 20:word32] = eax;
	Mem0[esp + 16:word32] = ebx;
	Mem0[esp + 0x0C:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 8:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x0805D5A0;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		fn0804DB90();
		eax = 0xFF;
		esp += 0x18;
		SCZO = cond(esp);
		camlPervasives__exit_1326();
	}
	else
	{
		esp += 0x18;
		SCZO = cond(esp);
	}
}

// 0804DB90: define fn0804DB90
// Called from:
//      camlUnix__create_process_env_1914
define fn0804DB90
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[esp + 8:word32];
	ebx = Mem0[esp + 0x0C:word32];
	ecx = Mem0[esp + 16:word32];
	camlUnix__perform_redirections_1900();
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 28:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 36:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D238;
	fn080709D8();
	esp += 0x0C;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x18;
	SCZO = cond(esp);
}

// 0804DBE0: define camlUnix__open_proc_1949
// Called from:
//      camlUnix__open_process_in_1957
//      camlUnix__open_process_out_1962
//      camlUnix__open_process_1967
define camlUnix__open_proc_1949
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 20:word32] = ebx;
	Mem0[esp + 16:word32] = ecx;
	Mem0[esp + 0x0C:word32] = edx;
	ebx = esi;
	Mem0[esp + 8:word32] = ebx;
	eax = Mem0[0x08074874<p32>:word32];
	camlList__for_all_1137();
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x0805D5A0;
	fn080709D8();
	esp += 0x04;
	ecx = eax;
	SCZO = cond(ecx - 0x01);
	if (Test(EQ,Z))
	{
		eax = Mem0[esp + 16:word32];
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			Mem0[esp + 16:word32] = eax;
			esp -= 4;
			Mem0[esp + 0x00:word32] = 0x01;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x0805D0C4;
			fn080709D8();
			esp += 0x08;
			SCZO = cond(esp);
			eax = Mem0[esp + 16:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x0805CF5C;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
		}
		eax = Mem0[esp + 0x0C:word32];
		SCZO = cond(eax - 0x03);
		if (Test(NE,Z))
		{
			Mem0[esp + 0x0C:word32] = eax;
			esp -= 4;
			Mem0[esp + 0x00:word32] = 0x03;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x0805D0C4;
			fn080709D8();
			esp += 0x08;
			SCZO = cond(esp);
			eax = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x0805CF5C;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
		}
		eax = Mem0[esp + 0x00:word32];
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x080751B0;
			ebx = Mem0[esp + 8:word32];
			camlList__iter_1074();
		}
		fn0804DCC0();
		eax = 0xFF;
		esp += 0x18;
		SCZO = cond(esp);
		camlPervasives__exit_1326();
	}
	else
	{
		eax = Mem0[0x08074894<p32>:word32];
		ebx = Mem0[esp + 20:word32];
		esp += 0x18;
		SCZO = cond(esp);
		camlHashtbl__add_1074();
	}
}

// 0804DCC0: define fn0804DCC0
// Called from:
//      camlUnix__open_proc_1949
define fn0804DCC0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0C00;
	Mem0[ebx + 0x00:word32] = 0x080752B4;
	Mem0[ebx + 4:word32] = 0x080752C0;
	eax = Mem0[esp + 0x0C:word32];
	Mem0[ebx + 8:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x080752A8;
	eax = 0x0805D17C;
	fn080709D8();
	esp += 0x08;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x18;
	SCZO = cond(esp);
}

// 0804DD30: define camlUnix__open_process_in_1957
define camlUnix__open_process_in_1957
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 8:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C37;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 0x0C:word32] = ecx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	esi = eax + 4;
	Mem0[esi + -4:word32] = 0x0800;
	eax = Mem0[esp + 0x00:word32];
	Mem0[esi + 0x00:word32] = eax;
	Mem0[esi + 4:word32] = 0x01;
	ebx = esi + 0x0C;
	Mem0[ebx + -4:word32] = 0x0401;
	Mem0[ebx + 0x00:word32] = ecx;
	ecx = 0x01;
	eax = Mem0[esp + 4:word32];
	edx = Mem0[esp + 8:word32];
	camlUnix__open_proc_1949();
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	eax = Mem0[esp + 0x0C:word32];
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804DDD0: define camlUnix__open_process_out_1962
define camlUnix__open_process_out_1962
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 8:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	eax = 0x08069C6E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 0x0C:word32] = ecx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	esi = eax + 4;
	Mem0[esi + -4:word32] = 0x0800;
	eax = Mem0[esp + 0x00:word32];
	Mem0[esi + 0x00:word32] = eax;
	Mem0[esi + 4:word32] = 0x01;
	ebx = esi + 0x0C;
	Mem0[ebx + -4:word32] = 0x0402;
	Mem0[ebx + 0x00:word32] = ecx;
	edx = 0x03;
	eax = Mem0[esp + 4:word32];
	ecx = Mem0[esp + 8:word32];
	camlUnix__open_proc_1949();
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	eax = Mem0[esp + 0x0C:word32];
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804DE70: define camlUnix__open_process_1967
define camlUnix__open_process_1967
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 16:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 4:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[esp + 4:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C37;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[esp + 20:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C6E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 24:word32] = ecx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x24;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 0x0800;
	eax = Mem0[esp + 0x00:word32];
	Mem0[edx + 0x00:word32] = eax;
	Mem0[edx + 4:word32] = 0x01;
	ebx = edx + 0x0C;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[ebx + -4:word32] = 0x0800;
	eax = Mem0[esp + 4:word32];
	Mem0[ebx + 0x00:word32] = eax;
	Mem0[ebx + 4:word32] = edx;
	ebx = edx + 24;
	Mem0[ebx + -4:word32] = 0x0800;
	eax = Mem0[esp + 20:word32];
	Mem0[ebx + 0x00:word32] = eax;
	Mem0[ebx + 4:word32] = ecx;
	eax = Mem0[esp + 8:word32];
	ecx = Mem0[esp + 0x0C:word32];
	edx = Mem0[esp + 16:word32];
	esi = Mem0[esp + 0x00:word32];
	camlUnix__open_proc_1949();
	eax = Mem0[esp + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 16:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0800;
	ebx = Mem0[esp + 20:word32];
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[esp + 24:word32];
	Mem0[eax + 4:word32] = ebx;
	esp += 0x1C;
	SCZO = cond(esp);
}

// 0804DFB0: define camlUnix__open_proc_full_1975
// Called from:
//      camlUnix__open_process_full_1985
define camlUnix__open_proc_full_1975
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	Mem0[esp + 16:word32] = eax;
	Mem0[esp + 20:word32] = ebx;
	Mem0[esp + 28:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 8:word32] = edi;
	ebx = Mem0[0x0807D0BC<p32>:word32];
	Mem0[esp + 24:word32] = ebx;
	eax = Mem0[0x08074874<p32>:word32];
	camlList__for_all_1137();
	Mem0[esp + 0x0C:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x0805D5A0;
	fn080709D8();
	esp += 0x04;
	ecx = eax;
	SCZO = cond(ecx - 0x01);
	if (Test(EQ,Z))
	{
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x01;
		eax = Mem0[esp + 4:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805D0C4;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(esp);
		eax = Mem0[esp + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805CF5C;
		fn080709D8();
		esp += 0x04;
		SCZO = cond(esp);
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x03;
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805D0C4;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(esp);
		eax = Mem0[esp + 4:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805CF5C;
		fn080709D8();
		esp += 0x04;
		SCZO = cond(esp);
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x05;
		eax = Mem0[esp + 0x0C:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805D0C4;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(esp);
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x0805CF5C;
		fn080709D8();
		esp += 0x04;
		eax = Mem0[esp + 0x0C:word32];
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x080751A4;
			ebx = Mem0[esp + 24:word32];
			camlList__iter_1074();
		}
		fn0804E0B0();
		eax = 0xFF;
		esp += 0x20;
		SCZO = cond(esp);
		camlPervasives__exit_1326();
	}
	else
	{
		eax = Mem0[0x08074894<p32>:word32];
		ebx = Mem0[esp + 28:word32];
		esp += 0x20;
		SCZO = cond(esp);
		camlHashtbl__add_1074();
	}
}

// 0804E0B0: define fn0804E0B0
// Called from:
//      camlUnix__open_proc_full_1975
define fn0804E0B0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0C00;
	Mem0[ebx + 0x00:word32] = 0x08075294;
	Mem0[ebx + 4:word32] = 0x080752A0;
	eax = Mem0[esp + 24:word32];
	Mem0[ebx + 8:word32] = eax;
	eax = Mem0[esp + 28:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x08075288;
	eax = 0x0805D1CC;
	fn080709D8();
	esp += 0x0C;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x20;
	SCZO = cond(esp);
}

// 0804E120: define camlUnix__open_process_full_1985
define camlUnix__open_process_full_1985
{
	esp = fp;
	Top = 0;
	esp -= 44;
	SCZO = cond(esp);
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 16:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 24:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 8:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 4:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 20:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134607464;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 28:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C37;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[esp + 32:word32] = eax;
	eax = Mem0[esp + 4:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C6E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[esp + 36:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C37;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = eax;
	Mem0[esp + 40:word32] = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x34;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	esi = eax + 4;
	Mem0[esi + -4:word32] = 0x0800;
	eax = Mem0[esp + 0x00:word32];
	Mem0[esi + 0x00:word32] = eax;
	Mem0[esi + 4:word32] = 0x01;
	edx = esi + 0x0C;
	Mem0[edx + -4:word32] = 0x0800;
	eax = Mem0[esp + 4:word32];
	Mem0[edx + 0x00:word32] = eax;
	Mem0[edx + 4:word32] = esi;
	ecx = esi + 24;
	Mem0[esp + 0x00:word32] = ecx;
	Mem0[ecx + -4:word32] = 0x0800;
	eax = Mem0[esp + 8:word32];
	Mem0[ecx + 0x00:word32] = eax;
	Mem0[ecx + 4:word32] = edx;
	ecx = esi + 36;
	Mem0[ecx + -4:word32] = 0x0C03;
	eax = Mem0[esp + 32:word32];
	Mem0[ecx + 0x00:word32] = eax;
	eax = Mem0[esp + 36:word32];
	Mem0[ecx + 4:word32] = eax;
	Mem0[ecx + 8:word32] = ebx;
	eax = Mem0[esp + 0x0C:word32];
	ebx = Mem0[esp + 16:word32];
	edx = Mem0[esp + 20:word32];
	esi = Mem0[esp + 24:word32];
	edi = Mem0[esp + 28:word32];
	ebp = Mem0[esp + 0x00:word32];
	Mem0[0x0807D0BC<p32>:word32] = ebp;
	camlUnix__open_proc_full_1975();
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 24:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 28:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0C00;
	ebx = Mem0[esp + 32:word32];
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[esp + 36:word32];
	Mem0[eax + 4:word32] = ebx;
	ebx = Mem0[esp + 40:word32];
	Mem0[eax + 8:word32] = ebx;
	esp += 44;
	SCZO = cond(esp);
}

// 0804E2E0: define camlUnix__find_proc_id_1997
// Called from:
//      camlUnix__close_process_in_2003
//      camlUnix__close_process_out_2006
//      camlUnix__close_process_2009
//      camlUnix__close_process_full_2013
define camlUnix__find_proc_id_1997
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = ebx;
	fn0804E350();
	ecx = 134691416;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(EQ,Z))
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x14;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x1000;
		ebx = Mem0[0x08074608<p32>:word32];
		Mem0[eax + 0x00:word32] = ebx;
		Mem0[eax + 4:word32] = 0x07;
		ebx = Mem0[esp + 4:word32];
		Mem0[eax + 8:word32] = ebx;
		Mem0[eax + 0x0C:word32] = 0x08075280;
		fn08070A44();
		esi = esi;
	}
	fn08070A44();
	esi = esi;
	edi += 0x00;
	fn0804E350();
}

// 0804E350: define fn0804E350
// Called from:
//      camlUnix__find_proc_id_1997
define fn0804E350
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[0x08074894<p32>:word32];
	camlHashtbl__find_1093();
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[0x08074894<p32>:word32];
	ebx = Mem0[esp + 16:word32];
	camlHashtbl__remove_1080();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	eax = Mem0[esp + 0x00:word32];
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804E3A0: define camlUnix__waitpid_non_intr_2001
// Called from:
//      camlUnix__close_process_in_2003
//      camlUnix__close_process_out_2006
//      camlUnix__close_process_2009
//      fn0804E550
//      camlUnix__close_process_full_2013
//      fn0804E610
//      camlUnix__establish_server_2026
define camlUnix__waitpid_non_intr_2001
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	while (true)
	{
		Mem0[esp + 0x00:word32] = eax;
		fn0804E3E0();
		ecx = Mem0[0x08074608<p32>:word32];
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - ecx);
		if (Test(NE,Z))
			break;
		ebx = Mem0[eax + 4:word32];
		SZP = cond(ebx & 0x01);
		O = false;
		C = false;
		if (Test(EQ,Z))
			break;
		SCZO = cond(ebx - 0x17);
		if (Test(NE,Z))
			break;
		eax = Mem0[esp + 0x00:word32];
	}
	fn08070A44();
	esi = esi;
	edi += 0x00;
	fn0804E3E0();
}

// 0804E3E0: define fn0804E3E0
// Called from:
//      camlUnix__waitpid_non_intr_2001
define fn0804E3E0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 0x080618EF;
	fn080709D8();
	esp += 0x08;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804E410: define camlUnix__close_process_in_2003
define camlUnix__close_process_in_2003
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 0x00:word32] = ecx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0401;
	Mem0[ebx + 0x00:word32] = ecx;
	eax = 0x08075268;
	camlUnix__find_proc_id_1997();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 4:word32];
	camlUnix__waitpid_non_intr_2001();
	eax += 0x04;
	eax = Mem0[eax + 0x00:word32];
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804E480: define camlUnix__close_process_out_2006
define camlUnix__close_process_out_2006
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 0x00:word32] = ecx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0402;
	Mem0[ebx + 0x00:word32] = ecx;
	eax = 0x08075250;
	camlUnix__find_proc_id_1997();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	camlPervasives__close_out_1209();
	eax = Mem0[esp + 4:word32];
	camlUnix__waitpid_non_intr_2001();
	eax += 0x04;
	eax = Mem0[eax + 0x00:word32];
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804E4E0: define camlUnix__close_process_2009
define camlUnix__close_process_2009
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	edx = ebx;
	Mem0[esp + 8:word32] = edx;
	ecx = eax;
	Mem0[esp + 0x00:word32] = ecx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0800;
	Mem0[ebx + 0x00:word32] = ecx;
	Mem0[ebx + 4:word32] = edx;
	eax = 0x0807523C;
	camlUnix__find_proc_id_1997();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	fn0804E550();
	ecx = 134691244;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(EQ,Z))
	{
		eax = Mem0[esp + 4:word32];
		camlUnix__waitpid_non_intr_2001();
		eax += 0x04;
		eax = Mem0[eax + 0x00:word32];
		esp += 0x0C;
		SCZO = cond(esp);
	}
	else
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn0804E550();
	}
}

// 0804E550: define fn0804E550
// Called from:
//      camlUnix__close_process_2009
define fn0804E550
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[esp + 16:word32];
	camlPervasives__close_out_1209();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 4:word32];
	camlUnix__waitpid_non_intr_2001();
	eax += 0x04;
	eax = Mem0[eax + 0x00:word32];
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0804E590: define camlUnix__close_process_full_2013
define camlUnix__close_process_full_2013
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = ecx;
	esi = ebx;
	Mem0[esp + 0x0C:word32] = esi;
	edx = eax;
	Mem0[esp + 0x00:word32] = edx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0C03;
	Mem0[ebx + 0x00:word32] = edx;
	Mem0[ebx + 4:word32] = esi;
	Mem0[ebx + 8:word32] = ecx;
	eax = 0x08075224;
	camlUnix__find_proc_id_1997();
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	fn0804E610();
	ecx = 134691244;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(EQ,Z))
	{
		eax = Mem0[esp + 4:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x08068A78;
		fn080709D8();
		esp += 0x04;
		SCZO = cond(esp);
		eax = Mem0[esp + 8:word32];
		camlUnix__waitpid_non_intr_2001();
		eax += 0x04;
		eax = Mem0[eax + 0x00:word32];
		esp += 0x10;
		SCZO = cond(esp);
	}
	else
	{
		fn08070A44();
		fn0804E610();
	}
}

// 0804E610: define fn0804E610
// Called from:
//      camlUnix__close_process_full_2013
define fn0804E610
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[esp + 20:word32];
	camlPervasives__close_out_1209();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 4:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 8:word32];
	camlUnix__waitpid_non_intr_2001();
	eax += 0x04;
	eax = Mem0[eax + 0x00:word32];
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804E660: define camlUnix__open_connection_2018
define camlUnix__open_connection_2018
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	camlUnix__domain_of_sockaddr_1529();
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060188;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	fn0804E6B0();
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 4:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CF5C;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 0x00:word32];
	fn08070A44();
	esi += 0x00;
	edi += 0x00;
	fn0804E6B0();
}

// 0804E6B0: define fn0804E6B0
// Called from:
//      camlUnix__open_connection_2018
define fn0804E6B0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	ebx = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805D000;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	eax = Mem0[esp + 0x0C:word32];
	camlUnix__try_set_close_on_exec_1366();
	eax = Mem0[esp + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C6E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[esp + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C37;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0800;
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[esp + 8:word32];
	Mem0[eax + 4:word32] = ebx;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804E740: define camlUnix__shutdown_connection_2022
define camlUnix__shutdown_connection_2022
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134646339;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x03;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134610604;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804E760: define camlUnix__accept_non_intr_2024
// Called from:
//      camlUnix__establish_server_2026
define camlUnix__accept_non_intr_2024
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	while (true)
	{
		Mem0[esp + 0x00:word32] = eax;
		fn0804E7A0();
		ecx = Mem0[0x08074608<p32>:word32];
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - ecx);
		if (Test(NE,Z))
			break;
		ebx = Mem0[eax + 4:word32];
		SZP = cond(ebx & 0x01);
		O = false;
		C = false;
		if (Test(EQ,Z))
			break;
		SCZO = cond(ebx - 0x17);
		if (Test(NE,Z))
			break;
		eax = Mem0[esp + 0x00:word32];
	}
	fn08070A44();
	esi = esi;
	edi += 0x00;
	fn0804E7A0();
}

// 0804E7A0: define fn0804E7A0
// Called from:
//      camlUnix__accept_non_intr_2024
define fn0804E7A0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CB9C;
	fn080709D8();
	esp += 0x04;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804E7D0: define camlUnix__establish_server_2026
define camlUnix__establish_server_2026
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = eax;
	eax = ebx;
	Mem0[esp + 0x00:word32] = eax;
	camlUnix__domain_of_sockaddr_1529();
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08060188;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	ecx = 0x03;
	ebx = 0x05;
	camlUnix__setsockopt_1646();
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805CDA4;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	esp -= 4;
	Mem0[esp + 0x00:word32] = 11;
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0805ECCC;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	while (true)
	{
		eax = Mem0[esp + 4:word32];
		camlUnix__accept_non_intr_2024();
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x0C:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x01;
		eax = 0x0805D5A0;
		fn080709D8();
		esp += 0x04;
		Mem0[esp + 0x00:word32] = eax;
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x0805CF5C;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
			eax = Mem0[esp + 0x00:word32];
			camlUnix__waitpid_non_intr_2001();
		}
		else
		{
			esp -= 4;
			Mem0[esp + 0x00:word32] = 0x01;
			eax = 0x0805D5A0;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				eax = 0x01;
				camlPervasives__exit_1326();
			}
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x0805CF5C;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
			eax = Mem0[esp + 0x0C:word32];
			camlUnix__try_set_close_on_exec_1366();
			eax = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x08069C37;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
			Mem0[esp + 0x00:word32] = eax;
			eax = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x08069C6E;
			fn080709D8();
			esp += 0x04;
			SCZO = cond(esp);
			ebx = eax;
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[esp + 8:word32];
			caml_apply2();
			eax = 0x01;
			camlPervasives__exit_1326();
		}
	}
}

// 0804E910: define camlUnix__entry
// Called from:
//      caml_program
define camlUnix__entry
{
	word32 dwLoc04;
	word32 dwLoc08;
	bool P;
	Top_3 = 0;
	Mem4[0x08074870<p32>:word32] = 0x08075198;
	Mem5[0x0807486C<p32>:word32] = 0x08075188;
	Mem6[0x08074868<p32>:word32] = 0x08075178;
	Mem7[0x08074864<p32>:word32] = 0x0807516C;
	Mem8[0x08074860<p32>:word32] = 0x0807515C;
	Mem9[0x0807485C<p32>:word32] = 0x0807514C;
	Mem10[0x08074858<p32>:word32] = 0x08075140;
	Mem11[0x0807484C<p32>:word32] = 0x08075130;
	Mem12[0x08074848<p32>:word32] = 0x08075120;
	Mem13[0x08074844<p32>:word32] = 0x08075114;
	Mem14[0x08074840<p32>:word32] = 0x08075108;
	Mem15[0x0807483C<p32>:word32] = 0x080750FC;
	Mem16[0x08074838<p32>:word32] = 0x080750F0;
	Mem17[0x08074834<p32>:word32] = 0x080750E4;
	Mem18[0x080747F0<p32>:word32] = 0x080750D8;
	Mem19[0x080747EC<p32>:word32] = 0x080750CC;
	Mem20[0x080747E8<p32>:word32] = 0x080750BC;
	Mem21[0x080747E4<p32>:word32] = 0x080750AC;
	Mem22[0x080747E0<p32>:word32] = 0x0807509C;
	Mem23[0x080747DC<p32>:word32] = 0x0807508C;
	Mem24[0x080747D8<p32>:word32] = 0x08075080;
	Mem25[0x080747D4<p32>:word32] = 0x08075070;
	Mem26[0x080747CC<p32>:word32] = 0x08075060;
	Mem27[0x080747B8<p32>:word32] = 0x08075054;
	Mem28[0x080747B4<p32>:word32] = 0x08075048;
	Mem29[0x080747B0<p32>:word32] = 0x0807503C;
	Mem30[0x080747AC<p32>:word32] = 0x08075030;
	Mem31[0x080747A8<p32>:word32] = 134696996;
	Mem32[0x080747A4<p32>:word32] = 0x08075018;
	Mem33[0x080747A0<p32>:word32] = 0x0807500C;
	Mem34[0x0807479C<p32>:word32] = 134696956;
	Mem35[0x08074798<p32>:word32] = 0x08074FF0;
	Mem36[0x08074794<p32>:word32] = 0x08074FE4;
	Mem37[0x08074790<p32>:word32] = 0x08074FD8;
	Mem38[0x0807478C<p32>:word32] = 0x08074FCC;
	Mem39[0x08074788<p32>:word32] = 0x08074FC0;
	Mem40[0x08074784<p32>:word32] = 0x08074FB4;
	Mem41[0x08074780<p32>:word32] = 0x08074FA8;
	Mem42[0x0807477C<p32>:word32] = 134696860;
	Mem43[0x08074778<p32>:word32] = 0x08074F8C;
	Mem44[0x08074774<p32>:word32] = 0x08074F80;
	Mem45[0x08074770<p32>:word32] = 0x08074F70;
	Mem46[0x0807476C<p32>:word32] = 0x08074F64;
	Mem47[0x08074768<p32>:word32] = 0x08074F58;
	Mem48[0x08074764<p32>:word32] = 0x08074F4C;
	Mem49[0x08074760<p32>:word32] = 0x08074F40;
	Mem50[0x0807475C<p32>:word32] = 0x08074F34;
	Mem51[0x08074758<p32>:word32] = 0x08074F28;
	Mem52[0x08074754<p32>:word32] = 0x08074F1C;
	Mem53[0x08074750<p32>:word32] = 0x08074F10;
	Mem54[0x08074748<p32>:word32] = 0x08074F04;
	Mem55[0x08074744<p32>:word32] = 134696696;
	Mem56[0x08074740<p32>:word32] = 0x08074EE8;
	Mem57[0x0807473C<p32>:word32] = 134696664;
	Mem58[0x08074738<p32>:word32] = 0x08074EC8;
	Mem59[0x08074734<p32>:word32] = 0x08074EB8;
	Mem60[0x08074730<p32>:word32] = 134696620;
	Mem61[0x0807472C<p32>:word32] = 134696604;
	Mem62[0x08074700<p32>:word32] = 0x08074E8C;
	Mem63[0x080746FC<p32>:word32] = 0x08074E80;
	Mem64[0x080746F8<p32>:word32] = 0x08074E74;
	Mem65[0x080746F4<p32>:word32] = 0x08074E68;
	Mem66[0x080746F0<p32>:word32] = 0x08074E5C;
	Mem67[0x080746EC<p32>:word32] = 0x08074E50;
	Mem68[0x080746E8<p32>:word32] = 0x08074E44;
	Mem69[0x080746E4<p32>:word32] = 0x08074E38;
	Mem70[0x080746E0<p32>:word32] = 134696492;
	Mem71[0x080746DC<p32>:word32] = 0x08074E20;
	Mem72[0x080746D8<p32>:word32] = 134696464;
	Mem73[0x080746D4<p32>:word32] = 0x08074E04;
	Mem74[0x080746D0<p32>:word32] = 134696440;
	Mem75[0x080746CC<p32>:word32] = 0x08074DEC;
	Mem76[0x080746C8<p32>:word32] = 134696416;
	Mem77[0x080746C4<p32>:word32] = 0x08074DD0;
	Mem78[0x080746C0<p32>:word32] = 0x08074DC4;
	Mem79[0x080746BC<p32>:word32] = 0x08074DB4;
	Mem80[0x080746B8<p32>:word32] = 0x08074DA8;
	Mem81[0x080746B4<p32>:word32] = 134696344;
	Mem82[0x080746B0<p32>:word32] = 0x08074D88;
	Mem83[0x080746AC<p32>:word32] = 0x08074D78;
	Mem84[0x080746A8<p32>:word32] = 134696296;
	Mem85[0x080746A4<p32>:word32] = 0x08074D58;
	Mem86[0x080746A0<p32>:word32] = 0x08074D48;
	Mem87[0x0807469C<p32>:word32] = 0x08074D3C;
	Mem88[0x08074694<p32>:word32] = 0x08074D30;
	Mem89[0x08074690<p32>:word32] = 0x08074D24;
	Mem90[0x0807468C<p32>:word32] = 0x08074D18;
	Mem91[0x08074688<p32>:word32] = 0x08074D0C;
	Mem92[0x08074684<p32>:word32] = 0x08074CFC;
	Mem93[0x08074680<p32>:word32] = 0x08074CEC;
	Mem94[0x0807467C<p32>:word32] = 0x08074CDC;
	Mem95[0x08074678<p32>:word32] = 134696144;
	Mem96[0x08074674<p32>:word32] = 0x08074CC4;
	Mem97[0x08074670<p32>:word32] = 0x08074CB8;
	Mem98[0x0807466C<p32>:word32] = 0x08074CAC;
	Mem99[0x0807465C<p32>:word32] = 0x08074CA0;
	Mem100[0x08074658<p32>:word32] = 0x08074C90;
	Mem101[0x08074648<p32>:word32] = 0x08074C84;
	Mem102[0x08074644<p32>:word32] = 0x08074C78;
	Mem103[0x08074640<p32>:word32] = 134696044;
	Mem104[0x08074638<p32>:word32] = 0x08074C5C;
	Mem105[0x08074634<p32>:word32] = 0x08074C50;
	Mem106[0x08074630<p32>:word32] = 0x08074C44;
	Mem107[0x0807462C<p32>:word32] = 0x08074C34;
	Mem108[0x08074628<p32>:word32] = 0x08074C24;
	Mem109[0x08074624<p32>:word32] = 0x08074C14;
	Mem110[0x08074620<p32>:word32] = 0x08074C04;
	Mem111[0x0807461C<p32>:word32] = 0x08074BF4;
	Mem112[0x08074618<p32>:word32] = 0x08074BE8;
	Mem113[0x08074614<p32>:word32] = 0x08074BDC;
	Mem114[0x0807460C<p32>:word32] = 0x08074BD0;
	fn08070994();
	Mem122[eax_116 + 0x00:word32] = 0x0400;
	Mem123[eax_116 + 4:word32] = 0x08075210;
	Mem124[0x08074608<p32>:word32] = eax_116 + 4;
	Mem126[eax_116 + 8:word32] = 0x1000;
	eax_127 = Mem126[0x08074608<p32>:word32];
	Mem128[eax_116 + 0x0C:word32] = eax_127;
	Mem129[eax_116 + 16:word32] = 0x01;
	Mem130[eax_116 + 20:word32] = 0x08075200;
	Mem131[eax_116 + 24:word32] = 0x08075208;
	camlCallback__register_exception_1034();
	Mem141[0x08074610<p32>:word32] = 0x08074BC0;
	Mem142[0x0807464C<p32>:word32] = 0x01;
	Mem143[0x08074650<p32>:word32] = 0x03;
	Mem144[0x08074654<p32>:word32] = 0x05;
	Mem146[0x08074660<p32>:word32] = 0x08074BB0;
	Mem148[0x08074664<p32>:word32] = 0x08074BA0;
	Mem150[0x08074668<p32>:word32] = 0x08074B90;
	fn08070994();
	Mem158[eax_152 + 0x00:word32] = 0x1800;
	Mem159[eax_152 + 4:word32] = 0x08074B3C;
	Mem160[eax_152 + 8:word32] = 0x08074B4C;
	Mem161[eax_152 + 0x0C:word32] = 0x08074B5C;
	Mem162[eax_152 + 16:word32] = 0x08074B6C;
	Mem163[eax_152 + 20:word32] = 0x08074B78;
	Mem164[eax_152 + 24:word32] = 0x08074B84;
	Mem165[0x08074698<p32>:word32] = eax_152 + 4;
	Mem167[0x08074874<p32>:word32] = 0x08074B30;
	Mem169[0x0807474C<p32>:word32] = 0x08074B24;
	Mem171[0x08074878<p32>:word32] = 0x08074B18;
	fn080709D8();
	Mem179[0x080747BC<p32>:word32] = eax_175;
	fn080709D8();
	Mem187[0x080747C0<p32>:word32] = eax_183;
	fn0804EEAA();
	ebx_200 = Mem187[eax_188 + 0x00:word32];
	if (ebx_200 != 0x080739CC)
	{
		fn08070A44();
		fn0804EEAA();
	}
	else
	{
		eax_224 = Mem187[0x080747BC<p32>:word32];
		fn0804EED1();
	}
}

// 0804EEAA: define fn0804EEAA
// Called from:
//      camlUnix__entry
define fn0804EEAA
{
	ptr32 fp;
	<unknown> Mem0;
	word32 dwLoc0C;
	Top_3 = 0;
	v4_5 = Mem0[0x0807D280<p32>:word32];
	Mem8[0x0807D280<p32>:word32] = fp - 4;
	fn080709D8();
	Mem15[0x0807D280<p32>:word32] = v4_5;
	esp_17 = fp + 0x04;
	fn0804EED1();
}

// 0804EED1: define fn0804EED1
// Called from:
//      camlUnix__entry
//      fn0804EEAA
define fn0804EED1
{
	word32 eax;
	word32 dwLoc04;
	word32 edi;
	word32 esi;
	bool P;
	Top_22 = 0;
	Mem24[0x080747C4<p32>:word32] = eax;
	fn0804EEF2();
	ecx_33 = 0x080739CC;
	ebx_34 = Mem24[eax_25 + 0x00:word32];
	if (ebx_34 != 0x080739CC)
		fn0804EEED();
	else
		fn0804EEE6();
}

// 0804EEE6: define fn0804EEE6
// Called from:
//      fn0804EEAA
//      fn0804EED1
define fn0804EEE6
{
	<unknown> Mem0;
	word32 dwLoc04;
	Top_3 = 0;
	eax_5 = Mem0[0x080747C0<p32>:word32];
	Mem6[0x080747C8<p32>:word32] = eax_5;
	Mem8[0x080747D0<p32>:word32] = 0x08074B0C;
	Mem10[0x080747F4<p32>:word32] = 134695676;
	Mem12[0x080747F8<p32>:word32] = 134695660;
	Mem14[0x080747FC<p32>:word32] = 134695644;
	Mem16[0x08074800<p32>:word32] = 0x08074ACC;
	fn08070994();
	Mem24[eax_18 + 0x00:word32] = 0x1C00;
	Mem25[eax_18 + 4:word32] = 0x01;
	Mem26[eax_18 + 8:word32] = 0x03;
	Mem27[eax_18 + 0x0C:word32] = 0x05;
	Mem28[eax_18 + 16:word32] = 0x07;
	Mem29[eax_18 + 20:word32] = 0x09;
	Mem30[eax_18 + 24:word32] = 0x08074AAC;
	Mem31[eax_18 + 28:word32] = 0x08074ABC;
	Mem32[0x0807487C<p32>:word32] = eax_18 + 4;
	Mem34[0x08074804<p32>:word32] = 0x08074A9C;
	Mem36[0x08074808<p32>:word32] = 0x08074A8C;
	Mem38[0x0807480C<p32>:word32] = 0x08074A7C;
	Mem40[0x08074810<p32>:word32] = 0x08074A6C;
	Mem42[0x08074814<p32>:word32] = 134695516;
	Mem44[0x08074818<p32>:word32] = 0x08074A4C;
	Mem46[0x0807481C<p32>:word32] = 0x08074A3C;
	Mem48[0x08074820<p32>:word32] = 0x08074A2C;
	Mem50[0x08074824<p32>:word32] = 0x08074A20;
	Mem52[0x08074880<p32>:word32] = 0x08074A10;
	Mem54[0x08074850<p32>:word32] = 0x08074A00;
	Mem56[0x08074884<p32>:word32] = 0x080749F0;
	Mem58[0x08074854<p32>:word32] = 0x080749E0;
	Mem60[0x0807463C<p32>:word32] = 0x080749D4;
	Mem62[0x08074888<p32>:word32] = 0x080749C8;
	Mem64[0x0807488C<p32>:word32] = 134695356;
	Mem66[0x08074890<p32>:word32] = 0x080749AC;
	Mem68[0x08074704<p32>:word32] = 0x0807499C;
	Mem70[0x08074708<p32>:word32] = 0x0807498C;
	camlHashtbl__create_1051();
	Mem79[0x08074894<p32>:word32] = eax_72;
	Mem81[0x08074898<p32>:word32] = 0x0807497C;
	Mem83[0x0807470C<p32>:word32] = 0x08074970;
	Mem85[0x08074710<p32>:word32] = 0x08074964;
	Mem87[0x08074714<p32>:word32] = 0x08074958;
	Mem89[0x0807489C<p32>:word32] = 0x08074948;
	Mem91[0x08074718<p32>:word32] = 0x08074938;
	Mem93[0x080748A0<p32>:word32] = 0x08074928;
	Mem95[0x080748A4<p32>:word32] = 134695196;
	Mem97[0x0807471C<p32>:word32] = 0x08074910;
	Mem99[0x08074720<p32>:word32] = 0x08074904;
	Mem101[0x08074724<p32>:word32] = 0x080748F4;
	Mem103[0x08074728<p32>:word32] = 0x080748E4;
	Mem105[0x08074828<p32>:word32] = 0x080748D8;
	Mem107[0x0807482C<p32>:word32] = 0x080748CC;
	Mem109[0x080748A8<p32>:word32] = 0x080748C0;
	Mem111[0x08074830<p32>:word32] = 0x080748B0;
	eax_112 = 0x01;
}

// 0804EEED: define fn0804EEED
// Called from:
//      fn0804EEAA
//      fn0804EED1
define fn0804EEED
{
	word32 eax;
	<unknown> Mem0;
	word32 dwLoc04;
	Top_3 = 0;
	fn08070A44();
	fn0804EEF2();
}

// 0804EEF2: define fn0804EEF2
// Called from:
//      fn0804EEAA
//      fn0804EED1
define fn0804EEF2
{
	ptr32 fp;
	<unknown> Mem0;
	word32 dwLoc0C;
	word32 dwArg00;
	Top_3 = 0;
	v4_5 = Mem0[0x0807D280<p32>:word32];
	Mem8[0x0807D280<p32>:word32] = fp - 4;
	fn080709D8();
	Mem15[0x0807D280<p32>:word32] = v4_5;
	esp_17 = fp + 0x04;
	Mem19[0x080747C8<p32>:word32] = eax_12;
	Mem21[0x080747D0<p32>:word32] = 0x08074B0C;
	Mem23[0x080747F4<p32>:word32] = 134695676;
	Mem25[0x080747F8<p32>:word32] = 134695660;
	Mem27[0x080747FC<p32>:word32] = 134695644;
	Mem29[0x08074800<p32>:word32] = 0x08074ACC;
	fn08070994();
	Mem37[eax_31 + 0x00:word32] = 0x1C00;
	Mem38[eax_31 + 4:word32] = 0x01;
	Mem39[eax_31 + 8:word32] = 0x03;
	Mem40[eax_31 + 0x0C:word32] = 0x05;
	Mem41[eax_31 + 16:word32] = 0x07;
	Mem42[eax_31 + 20:word32] = 0x09;
	Mem43[eax_31 + 24:word32] = 0x08074AAC;
	Mem44[eax_31 + 28:word32] = 0x08074ABC;
	Mem45[0x0807487C<p32>:word32] = eax_31 + 4;
	Mem47[0x08074804<p32>:word32] = 0x08074A9C;
	Mem49[0x08074808<p32>:word32] = 0x08074A8C;
	Mem51[0x0807480C<p32>:word32] = 0x08074A7C;
	Mem53[0x08074810<p32>:word32] = 0x08074A6C;
	Mem55[0x08074814<p32>:word32] = 134695516;
	Mem57[0x08074818<p32>:word32] = 0x08074A4C;
	Mem59[0x0807481C<p32>:word32] = 0x08074A3C;
	Mem61[0x08074820<p32>:word32] = 0x08074A2C;
	Mem63[0x08074824<p32>:word32] = 0x08074A20;
	Mem65[0x08074880<p32>:word32] = 0x08074A10;
	Mem67[0x08074850<p32>:word32] = 0x08074A00;
	Mem69[0x08074884<p32>:word32] = 0x080749F0;
	Mem71[0x08074854<p32>:word32] = 0x080749E0;
	Mem73[0x0807463C<p32>:word32] = 0x080749D4;
	Mem75[0x08074888<p32>:word32] = 0x080749C8;
	Mem77[0x0807488C<p32>:word32] = 134695356;
	Mem79[0x08074890<p32>:word32] = 0x080749AC;
	Mem81[0x08074704<p32>:word32] = 0x0807499C;
	Mem83[0x08074708<p32>:word32] = 0x0807498C;
	camlHashtbl__create_1051();
	Mem92[0x08074894<p32>:word32] = eax_85;
	Mem94[0x08074898<p32>:word32] = 0x0807497C;
	Mem96[0x0807470C<p32>:word32] = 0x08074970;
	Mem98[0x08074710<p32>:word32] = 0x08074964;
	Mem100[0x08074714<p32>:word32] = 0x08074958;
	Mem102[0x0807489C<p32>:word32] = 0x08074948;
	Mem104[0x08074718<p32>:word32] = 0x08074938;
	Mem106[0x080748A0<p32>:word32] = 0x08074928;
	Mem108[0x080748A4<p32>:word32] = 134695196;
	Mem110[0x0807471C<p32>:word32] = 0x08074910;
	Mem112[0x08074720<p32>:word32] = 0x08074904;
	Mem114[0x08074724<p32>:word32] = 0x080748F4;
	Mem116[0x08074728<p32>:word32] = 0x080748E4;
	Mem118[0x08074828<p32>:word32] = 0x080748D8;
	Mem120[0x0807482C<p32>:word32] = 0x080748CC;
	Mem122[0x080748A8<p32>:word32] = 0x080748C0;
	Mem124[0x08074830<p32>:word32] = 0x080748B0;
	eax_125 = 0x01;
}

// 0804F110: define camlUnixLabels__entry
// Called from:
//      caml_program
define camlUnixLabels__entry
{
	<unknown> Mem0;
	Top_3 = 0;
	ebx_6 = Mem0[0x08074608:word32];
	Mem7[0x08076B7C<p32>:word32] = ebx_6;
	ebx_8 = Mem7[0x0807460C:word32];
	Mem9[0x08076B80<p32>:word32] = ebx_8;
	ebx_10 = Mem9[134694416:word32];
	Mem11[0x08076B84<p32>:word32] = ebx_10;
	ebx_12 = Mem11[0x08074614:word32];
	Mem13[0x08076B88<p32>:word32] = ebx_12;
	ebx_14 = Mem13[134694424:word32];
	Mem15[0x08076B8C<p32>:word32] = ebx_14;
	ebx_16 = Mem15[134694428:word32];
	Mem17[0x08076B90<p32>:word32] = ebx_16;
	ebx_18 = Mem17[0x08074620:word32];
	Mem19[0x08076B94<p32>:word32] = ebx_18;
	ebx_20 = Mem19[134694436:word32];
	Mem21[0x08076B98<p32>:word32] = ebx_20;
	ebx_22 = Mem21[134694440:word32];
	Mem23[0x08076B9C<p32>:word32] = ebx_22;
	ebx_24 = Mem23[134694444:word32];
	Mem25[0x08076BA0<p32>:word32] = ebx_24;
	ebx_26 = Mem25[0x08074630:word32];
	Mem27[0x08076BA4<p32>:word32] = ebx_26;
	ebx_28 = Mem27[0x08074634:word32];
	Mem29[0x08076BA8<p32>:word32] = ebx_28;
	ebx_30 = Mem29[0x08074638:word32];
	Mem31[0x08076BAC<p32>:word32] = ebx_30;
	ebx_32 = Mem31[134694460:word32];
	Mem33[0x08076BB0<p32>:word32] = ebx_32;
	ebx_34 = Mem33[0x08074640:word32];
	Mem35[0x08076BB4<p32>:word32] = ebx_34;
	ebx_36 = Mem35[0x08074644:word32];
	Mem37[0x08076BB8<p32>:word32] = ebx_36;
	ebx_38 = Mem37[0x08074648:word32];
	Mem39[0x08076BBC<p32>:word32] = ebx_38;
	Mem40[0x08076BC0<p32>:word32] = 0x01;
	Mem41[0x08076BC4<p32>:word32] = 0x03;
	Mem42[0x08076BC8<p32>:word32] = 0x05;
	ebx_43 = Mem42[0x08074658:word32];
	Mem44[0x08076BCC<p32>:word32] = ebx_43;
	ebx_45 = Mem44[134694492:word32];
	Mem46[0x08076BD0<p32>:word32] = ebx_45;
	ebx_47 = Mem46[0x08074660:word32];
	Mem48[0x08076BD4<p32>:word32] = ebx_47;
	ebx_49 = Mem48[0x08074664:word32];
	Mem50[0x08076BD8<p32>:word32] = ebx_49;
	ebx_51 = Mem50[0x08074668:word32];
	Mem52[0x08076BDC<p32>:word32] = ebx_51;
	ebx_53 = Mem52[0x0807466C:word32];
	Mem54[0x08076BE0<p32>:word32] = ebx_53;
	ebx_55 = Mem54[0x08074670:word32];
	Mem56[0x08076BE4<p32>:word32] = ebx_55;
	ebx_57 = Mem56[0x08074674:word32];
	Mem58[0x08076BE8<p32>:word32] = ebx_57;
	ebx_59 = Mem58[0x08074678:word32];
	Mem60[0x08076BEC<p32>:word32] = ebx_59;
	ebx_61 = Mem60[0x0807467C:word32];
	Mem62[0x08076BF0<p32>:word32] = ebx_61;
	ebx_63 = Mem62[0x08074680:word32];
	Mem64[0x08076BF4<p32>:word32] = ebx_63;
	ebx_65 = Mem64[0x08074684:word32];
	Mem66[0x08076BF8<p32>:word32] = ebx_65;
	ebx_67 = Mem66[0x08074688:word32];
	Mem68[0x08076BFC<p32>:word32] = ebx_67;
	ebx_69 = Mem68[0x0807468C:word32];
	Mem70[0x08076C00<p32>:word32] = ebx_69;
	ebx_71 = Mem70[0x08074690:word32];
	Mem72[0x08076C04<p32>:word32] = ebx_71;
	ebx_73 = Mem72[0x08074694:word32];
	Mem74[0x08076C08<p32>:word32] = ebx_73;
	ebx_75 = Mem74[0x08074698:word32];
	Mem76[0x08076C0C<p32>:word32] = ebx_75;
	ebx_77 = Mem76[134694556:word32];
	Mem78[0x08076C10<p32>:word32] = ebx_77;
	ebx_79 = Mem78[0x080746A0:word32];
	Mem80[0x08076C14<p32>:word32] = ebx_79;
	ebx_81 = Mem80[134694564:word32];
	Mem82[0x08076C18<p32>:word32] = ebx_81;
	ebx_83 = Mem82[0x080746A8:word32];
	Mem84[0x08076C1C<p32>:word32] = ebx_83;
	ebx_85 = Mem84[0x080746AC:word32];
	Mem86[0x08076C20<p32>:word32] = ebx_85;
	ebx_87 = Mem86[0x080746B0:word32];
	Mem88[0x08076C24<p32>:word32] = ebx_87;
	ebx_89 = Mem88[0x080746B4:word32];
	Mem90[0x08076C28<p32>:word32] = ebx_89;
	ebx_91 = Mem90[0x080746B8:word32];
	Mem92[0x08076C2C<p32>:word32] = ebx_91;
	ebx_93 = Mem92[0x080746BC:word32];
	Mem94[0x08076C30<p32>:word32] = ebx_93;
	ebx_95 = Mem94[0x080746C0:word32];
	Mem96[0x08076C34<p32>:word32] = ebx_95;
	ebx_97 = Mem96[0x080746C4:word32];
	Mem98[0x08076C38<p32>:word32] = ebx_97;
	ebx_99 = Mem98[0x080746C8:word32];
	Mem100[0x08076C3C<p32>:word32] = ebx_99;
	ebx_101 = Mem100[134694604:word32];
	Mem102[0x08076C40<p32>:word32] = ebx_101;
	ebx_103 = Mem102[0x080746D0:word32];
	Mem104[0x08076C44<p32>:word32] = ebx_103;
	ebx_105 = Mem104[0x080746D4:word32];
	Mem106[0x08076C48<p32>:word32] = ebx_105;
	ebx_107 = Mem106[134694616:word32];
	Mem108[0x08076C4C<p32>:word32] = ebx_107;
	ebx_109 = Mem108[0x080746DC:word32];
	Mem110[0x08076C50<p32>:word32] = ebx_109;
	ebx_111 = Mem110[0x080746E0:word32];
	Mem112[0x08076C54<p32>:word32] = ebx_111;
	ebx_113 = Mem112[0x080746E4:word32];
	Mem114[0x08076C58<p32>:word32] = ebx_113;
	ebx_115 = Mem114[0x080746E8:word32];
	Mem116[0x08076C5C<p32>:word32] = ebx_115;
	ebx_117 = Mem116[134694636:word32];
	Mem118[0x08076C60<p32>:word32] = ebx_117;
	ebx_119 = Mem118[0x080746F0:word32];
	Mem120[0x08076C64<p32>:word32] = ebx_119;
	ebx_121 = Mem120[134694644:word32];
	Mem122[0x08076C68<p32>:word32] = ebx_121;
	ebx_123 = Mem122[0x080746F8:word32];
	Mem124[0x08076C6C<p32>:word32] = ebx_123;
	ebx_125 = Mem124[0x080746FC:word32];
	Mem126[0x08076C70<p32>:word32] = ebx_125;
	ebx_127 = Mem126[0x08074700:word32];
	Mem128[0x08076C74<p32>:word32] = ebx_127;
	ebx_129 = Mem128[0x08074704:word32];
	Mem130[0x08076C78<p32>:word32] = ebx_129;
	ebx_131 = Mem130[0x08074708:word32];
	Mem132[0x08076C7C<p32>:word32] = ebx_131;
	ebx_133 = Mem132[0x0807470C:word32];
	Mem134[0x08076C80<p32>:word32] = ebx_133;
	ebx_135 = Mem134[0x08074710:word32];
	Mem136[0x08076C84<p32>:word32] = ebx_135;
	ebx_137 = Mem136[0x08074714:word32];
	Mem138[0x08076C88<p32>:word32] = ebx_137;
	ebx_139 = Mem138[0x08074718:word32];
	Mem140[0x08076C8C<p32>:word32] = ebx_139;
	ebx_141 = Mem140[0x0807471C:word32];
	Mem142[0x08076C90<p32>:word32] = ebx_141;
	ebx_143 = Mem142[0x08074720:word32];
	Mem144[0x08076C94<p32>:word32] = ebx_143;
	ebx_145 = Mem144[0x08074724:word32];
	Mem146[0x08076C98<p32>:word32] = ebx_145;
	ebx_147 = Mem146[0x08074728:word32];
	Mem148[0x08076C9C<p32>:word32] = ebx_147;
	ebx_149 = Mem148[0x0807472C:word32];
	Mem150[0x08076CA0<p32>:word32] = ebx_149;
	ebx_151 = Mem150[0x08074730:word32];
	Mem152[0x08076CA4<p32>:word32] = ebx_151;
	ebx_153 = Mem152[0x08074734:word32];
	Mem154[0x08076CA8<p32>:word32] = ebx_153;
	ebx_155 = Mem154[0x08074738:word32];
	Mem156[0x08076CAC<p32>:word32] = ebx_155;
	ebx_157 = Mem156[0x0807473C:word32];
	Mem158[0x08076CB0<p32>:word32] = ebx_157;
	ebx_159 = Mem158[0x08074740:word32];
	Mem160[0x08076CB4<p32>:word32] = ebx_159;
	ebx_161 = Mem160[0x08074744:word32];
	Mem162[0x08076CB8<p32>:word32] = ebx_161;
	ebx_163 = Mem162[0x08074748:word32];
	Mem164[0x08076CBC<p32>:word32] = ebx_163;
	ebx_165 = Mem164[0x0807474C:word32];
	Mem166[0x08076CC0<p32>:word32] = ebx_165;
	ebx_167 = Mem166[0x08074750:word32];
	Mem168[0x08076CC4<p32>:word32] = ebx_167;
	ebx_169 = Mem168[0x08074754:word32];
	Mem170[0x08076CC8<p32>:word32] = ebx_169;
	ebx_171 = Mem170[0x08074758:word32];
	Mem172[0x08076CCC<p32>:word32] = ebx_171;
	ebx_173 = Mem172[0x0807475C:word32];
	Mem174[0x08076CD0<p32>:word32] = ebx_173;
	ebx_175 = Mem174[0x08074760:word32];
	Mem176[0x08076CD4<p32>:word32] = ebx_175;
	ebx_177 = Mem176[0x08074764:word32];
	Mem178[0x08076CD8<p32>:word32] = ebx_177;
	ebx_179 = Mem178[0x08074768:word32];
	Mem180[0x08076CDC<p32>:word32] = ebx_179;
	ebx_181 = Mem180[0x0807476C:word32];
	Mem182[0x08076CE0<p32>:word32] = ebx_181;
	ebx_183 = Mem182[0x08074770:word32];
	Mem184[0x08076CE4<p32>:word32] = ebx_183;
	ebx_185 = Mem184[0x08074774:word32];
	Mem186[0x08076CE8<p32>:word32] = ebx_185;
	ebx_187 = Mem186[0x08074778:word32];
	Mem188[0x08076CEC<p32>:word32] = ebx_187;
	ebx_189 = Mem188[0x0807477C:word32];
	Mem190[0x08076CF0<p32>:word32] = ebx_189;
	ebx_191 = Mem190[0x08074780:word32];
	Mem192[0x08076CF4<p32>:word32] = ebx_191;
	ebx_193 = Mem192[0x08074784:word32];
	Mem194[0x08076CF8<p32>:word32] = ebx_193;
	ebx_195 = Mem194[0x08074788:word32];
	Mem196[0x08076CFC<p32>:word32] = ebx_195;
	ebx_197 = Mem196[0x0807478C:word32];
	Mem198[0x08076D00<p32>:word32] = ebx_197;
	ebx_199 = Mem198[0x08074790:word32];
	Mem200[0x08076D04<p32>:word32] = ebx_199;
	ebx_201 = Mem200[0x08074794:word32];
	Mem202[0x08076D08<p32>:word32] = ebx_201;
	ebx_203 = Mem202[0x08074798:word32];
	Mem204[0x08076D0C<p32>:word32] = ebx_203;
	ebx_205 = Mem204[0x0807479C:word32];
	Mem206[0x08076D10<p32>:word32] = ebx_205;
	ebx_207 = Mem206[0x080747A0:word32];
	Mem208[0x08076D14<p32>:word32] = ebx_207;
	ebx_209 = Mem208[0x080747A4:word32];
	Mem210[0x08076D18<p32>:word32] = ebx_209;
	ebx_211 = Mem210[0x080747A8:word32];
	Mem212[0x08076D1C<p32>:word32] = ebx_211;
	ebx_213 = Mem212[0x080747AC:word32];
	Mem214[0x08076D20<p32>:word32] = ebx_213;
	ebx_215 = Mem214[0x080747B0:word32];
	Mem216[0x08076D24<p32>:word32] = ebx_215;
	ebx_217 = Mem216[0x080747B4:word32];
	Mem218[0x08076D28<p32>:word32] = ebx_217;
	ebx_219 = Mem218[0x080747B8:word32];
	Mem220[0x08076D2C<p32>:word32] = ebx_219;
	ebx_221 = Mem220[134694844:word32];
	Mem222[0x08076D30<p32>:word32] = ebx_221;
	ebx_223 = Mem222[0x080747C0:word32];
	Mem224[0x08076D34<p32>:word32] = ebx_223;
	ebx_225 = Mem224[0x080747C4:word32];
	Mem226[0x08076D38<p32>:word32] = ebx_225;
	ebx_227 = Mem226[0x080747C8:word32];
	Mem228[0x08076D3C<p32>:word32] = ebx_227;
	ebx_229 = Mem228[0x080747CC:word32];
	Mem230[0x08076D40<p32>:word32] = ebx_229;
	ebx_231 = Mem230[0x080747D0:word32];
	Mem232[0x08076D44<p32>:word32] = ebx_231;
	ebx_233 = Mem232[0x080747D4:word32];
	Mem234[0x08076D48<p32>:word32] = ebx_233;
	ebx_235 = Mem234[0x080747D8:word32];
	Mem236[0x08076D4C<p32>:word32] = ebx_235;
	ebx_237 = Mem236[0x080747DC:word32];
	Mem238[0x08076D50<p32>:word32] = ebx_237;
	ebx_239 = Mem238[0x080747E0:word32];
	Mem240[0x08076D54<p32>:word32] = ebx_239;
	ebx_241 = Mem240[0x080747E4:word32];
	Mem242[0x08076D58<p32>:word32] = ebx_241;
	ebx_243 = Mem242[0x080747E8:word32];
	Mem244[0x08076D5C<p32>:word32] = ebx_243;
	ebx_245 = Mem244[0x080747EC:word32];
	Mem246[0x08076D60<p32>:word32] = ebx_245;
	ebx_247 = Mem246[0x080747F0:word32];
	Mem248[0x08076D64<p32>:word32] = ebx_247;
	ebx_249 = Mem248[0x080747F4:word32];
	Mem250[0x08076D68<p32>:word32] = ebx_249;
	ebx_251 = Mem250[0x080747F8:word32];
	Mem252[0x08076D6C<p32>:word32] = ebx_251;
	ebx_253 = Mem252[0x080747FC:word32];
	Mem254[0x08076D70<p32>:word32] = ebx_253;
	ebx_255 = Mem254[0x08074800:word32];
	Mem256[0x08076D74<p32>:word32] = ebx_255;
	ebx_257 = Mem256[0x08074804:word32];
	Mem258[0x08076D78<p32>:word32] = ebx_257;
	ebx_259 = Mem258[0x08074808:word32];
	Mem260[0x08076D7C<p32>:word32] = ebx_259;
	ebx_261 = Mem260[0x0807480C:word32];
	Mem262[0x08076D80<p32>:word32] = ebx_261;
	ebx_263 = Mem262[0x08074810:word32];
	Mem264[0x08076D84<p32>:word32] = ebx_263;
	ebx_265 = Mem264[0x08074814:word32];
	Mem266[0x08076D88<p32>:word32] = ebx_265;
	ebx_267 = Mem266[0x08074818:word32];
	Mem268[0x08076D8C<p32>:word32] = ebx_267;
	ebx_269 = Mem268[134694940:word32];
	Mem270[0x08076D90<p32>:word32] = ebx_269;
	ebx_271 = Mem270[0x08074820:word32];
	Mem272[0x08076D94<p32>:word32] = ebx_271;
	ebx_273 = Mem272[0x08074824:word32];
	Mem274[0x08076D98<p32>:word32] = ebx_273;
	ebx_275 = Mem274[0x08074828:word32];
	Mem276[0x08076D9C<p32>:word32] = ebx_275;
	ebx_277 = Mem276[0x0807482C:word32];
	Mem278[0x08076DA0<p32>:word32] = ebx_277;
	ebx_279 = Mem278[0x08074830:word32];
	Mem280[0x08076DA4<p32>:word32] = ebx_279;
	ebx_281 = Mem280[0x08074834:word32];
	Mem282[0x08076DA8<p32>:word32] = ebx_281;
	ebx_283 = Mem282[0x08074838:word32];
	Mem284[0x08076DAC<p32>:word32] = ebx_283;
	ebx_285 = Mem284[0x0807483C:word32];
	Mem286[0x08076DB0<p32>:word32] = ebx_285;
	ebx_287 = Mem286[0x08074840:word32];
	Mem288[0x08076DB4<p32>:word32] = ebx_287;
	ebx_289 = Mem288[0x08074844:word32];
	Mem290[0x08076DB8<p32>:word32] = ebx_289;
	ebx_291 = Mem290[0x08074848:word32];
	Mem292[0x08076DBC<p32>:word32] = ebx_291;
	ebx_293 = Mem292[0x0807484C:word32];
	Mem294[0x08076DC0<p32>:word32] = ebx_293;
	ebx_295 = Mem294[0x08074850:word32];
	Mem296[0x08076DC4<p32>:word32] = ebx_295;
	ebx_297 = Mem296[0x08074854:word32];
	Mem298[0x08076DC8<p32>:word32] = ebx_297;
	ebx_299 = Mem298[0x08074858:word32];
	Mem300[0x08076DCC<p32>:word32] = ebx_299;
	ebx_301 = Mem300[0x0807485C:word32];
	Mem302[0x08076DD0<p32>:word32] = ebx_301;
	ebx_303 = Mem302[0x08074860:word32];
	Mem304[0x08076DD4<p32>:word32] = ebx_303;
	ebx_305 = Mem304[0x08074864:word32];
	Mem306[0x08076DD8<p32>:word32] = ebx_305;
	ebx_307 = Mem306[0x08074868:word32];
	Mem308[0x08076DDC<p32>:word32] = ebx_307;
	ebx_309 = Mem308[0x0807486C:word32];
	Mem310[0x08076DE0<p32>:word32] = ebx_309;
	eax_311 = Mem310[0x08074870:word32];
	Mem312[0x08076DE4<p32>:word32] = eax_311;
	eax_313 = 0x01;
}

// 0804F800: define camlPervasives__loop_1138
// Called from:
//      camlPervasives__valid_float_lexem_1135
define camlPervasives__loop_1138
{
	esp = fp;
	Top = 0;
	while (true)
	{
		ecx = Mem0[ebx + 0x0C:word32];
		SCZO = cond(eax - ecx);
		if (Test(GE,SO))
			break;
		edx = Mem0[ebx + 8:word32];
		ecx = eax;
		ecx >>= 0x01;
		esi = Mem0[edx + -4:word32];
		esi >>= 0x0A;
		esi = ~0x00 + esi * 0x04;
		edi = CONVERT(Mem0[edx + esi:byte], byte, word32);
		esi -= edi;
		SCZO = cond(esi - ecx);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			esi += 0x00;
		}
		ecx = CONVERT(Mem0[edx + ecx:byte], byte, word32);
		ecx = ecx + 1 + ecx;
		SCZO = cond(ecx - 0x61);
		if (Test(GE,SO))
		{
			SCZO = cond(ecx - 117);
			if (Test(GE,SO))
				goto l0804F865;
		}
		else
		{
			SCZO = cond(ecx - 0x5B);
			if (Test(NE,Z))
			{
l0804F865:
				eax = Mem0[ebx + 8:word32];
				return;
			}
		}
		eax += 0x02;
		SCZO = cond(eax);
	}
	ecx = 0x080774F4;
	eax = Mem0[ebx + 8:word32];
	ebx = ecx;
	camlPervasives__$5e_1112();
}

// 0804F880: define camlPervasives__iter_1186
// Called from:
//      camlPervasives__string_of_float_1140
//      camlPervasives__flush_all_1185
define camlPervasives__iter_1186
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	fn0804F883();
}

// 0804F883: define fn0804F883
// Called from:
//      camlPervasives__iter_1186
//      fn0804F8A0
//      fn0804F8C3
define fn0804F883
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
		fn0804F8D0();
	else
		fn0804F888();
}

// 0804F888: define fn0804F888
// Called from:
//      camlPervasives__iter_1186
//      fn0804F883
define fn0804F888
{
	esp = fp;
	Top = 0;
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = ebx;
	eax = Mem0[eax + 0x00:word32];
	fn0804F8A0();
	fn0804F8C3();
}

// 0804F8A0: define fn0804F8A0
// Called from:
//      fn0804F888
define fn0804F8A0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	fn0804F8C3();
}

// 0804F8C3: define fn0804F8C3
// Called from:
//      fn0804F888
//      fn0804F8A0
define fn0804F8C3
{
	esp = fp;
	Top = 0;
	eax = Mem0[esp + 0x00:word32];
	fn0804F883();
}

// 0804F8D0: define fn0804F8D0
// Called from:
//      camlPervasives__iter_1186
//      fn0804F883
define fn0804F8D0
{
	esp = fp;
	Top = 0;
	eax = 0x01;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804F8E0: define camlPervasives__build_result_1243
// Called from:
//      camlPervasives__scan_1249
define camlPervasives__build_result_1243
{
	word32 eax;
	word32 ecx;
	<unknown> Mem0;
	Top_3 = 0;
	while (true)
	{
		Mem10 = ϕ(Mem35, Mem0);
		ecx_6 = ϕ(ecx_42, ecx);
		edi_5 = eax;
		SCZO_7 = cond(ecx_6 - 0x01);
		Z_8 = SLICE(SCZO_7, bool, 2);
		C_52 = SLICE(SCZO_7, bool, 1);
		O_59 = SLICE(SCZO_7, bool, 4);
		S_60 = SLICE(SCZO_7, bool, 0);
		if (ecx_6 == 0x01)
			break;
		ebp_11 = Mem10[ecx_6 + 4:word32];
		caml_blit_string();
		ecx_42 = ebp_11;
	}
}

// 0804F930: define camlPervasives__scan_1249
// Called from:
//      camlPervasives__input_line_1241
define camlPervasives__scan_1249
{
	ptr32 fp;
	word32 eax;
	word32 ebx;
	word32 ecx;
	word32 edi;
	word32 esi;
	bool P;
	word32 dwLoc1C;
	word32 dwLoc28;
	Top_3 = 0;
	while (true)
	{
		dwLoc1C_252 = ϕ(dwLoc1C, dwLoc1C_260);
		P_234 = ϕ(P, P_236);
		esi_225 = ϕ(esi, esi_224);
		edi_219 = ϕ(edi, edi_218);
		ebx_9 = ϕ(ebx, ebx_108);
		eax_6 = ϕ(eax, eax_98);
		v8_13 = Mem12[ecx + 0x0C:word32];
		fn080709D8();
		if (eax_17 == 0x01)
		{
			if (eax_6 != 0x01)
			{
				fn080709D8();
				ebx_200 = ebx_9;
				ecx_201 = eax_6;
				camlPervasives__build_result_1243();
				return;
			}
			while (true)
			{
				Mem25 = ϕ(Mem15, Mem28);
				eax_26 = Mem25[0x08080414<p32>:word32];
				Mem28[0x08080414<p32>:word32] = eax_26 - 0x08;
				if (eax_26 - 0x08 >=u Mem28[0x08080418<p32>:word32])
					break;
				fn080708CC();
			}
			eax_38 = eax_26 - 0x04;
			Mem39[eax_26 + -8:word32] = 0x0400;
			Mem40[eax_26 + -4:word32] = 134691344;
			fn08070A44();
		}
		P_233 = ϕ(P_50, P_234);
		esi_224 = ϕ(esi_44, esi_225);
		edi_218 = ϕ(edi_42, edi_219);
		eax_51 = ϕ(eax_38, eax_17);
		if (eax_51 > 0x01)
		{
			fn080709D8();
			ebx_121 = eax_51 + ~0x01;
			fn080709D8();
			v17_139 = Mem132[ecx + 0x0C:word32];
			fn080709D8();
			ecx_146 = eax_6;
			if (eax_6 == 0x01)
			{
				eax_149 = eax_116;
				SCZO_151 = cond(fp);
				C_213 = SLICE(SCZO_151, bool, 1);
				O_231 = SLICE(SCZO_151, bool, 4);
				S_239 = SLICE(SCZO_151, bool, 0);
				Z_247 = SLICE(SCZO_151, bool, 2);
				return;
			}
			else
			{
				edx_154 = ebx_9 - 3 + eax_51;
				while (true)
				{
					P_237 = ϕ(P_233, P_168);
					Mem156 = ϕ(Mem155, Mem159);
					eax_157 = Mem156[0x08080414<p32>:word32];
					Mem159[0x08080414<p32>:word32] = eax_157 - 0x0C;
					if (eax_157 - 0x0C >=u Mem159[0x08080418<p32>:word32])
						break;
					fn080708CC();
				}
				Mem171[eax_157 + -0x0C:word32] = 0x0800;
				Mem173[eax_157 + -8:word32] = eax_116;
				Mem175[eax_157 + -4:word32] = eax_6;
				fn080709D8();
				ebx_183 = edx_154;
				ecx_184 = eax_157 - 0x08;
				camlPervasives__build_result_1243();
				return;
			}
		}
		fn080709D8();
		ecx_68 = 0x02 - eax_51;
		dwLoc1C_260 = 0x01;
		fn080709D8();
		while (true)
		{
			P_236 = ϕ(P_233, P_97);
			Mem85 = ϕ(Mem79, Mem88);
			eax_86 = Mem85[0x08080414<p32>:word32];
			Mem88[0x08080414<p32>:word32] = eax_86 - 0x0C;
			if (eax_86 - 0x0C >=u Mem88[0x08080418<p32>:word32])
				break;
			fn080708CC();
		}
		eax_98 = eax_86 - 0x08;
		Mem99[eax_86 + -0x0C:word32] = 0x0800;
		Mem101[eax_86 + -8:word32] = eax_62;
		Mem103[eax_86 + -4:word32] = eax_6;
		ebx_106 = ebx_9 - eax_51;
		ebx_108 = ebx_106 + 0x01;
	}
}

// 0804FB30: define camlPervasives__fun_1500
define camlPervasives__fun_1500
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = ebx;
	ebx = Mem0[ebx + 8:word32];
	eax = 0x01;
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[eax + 0x0C:word32];
	eax = 0x01;
	ecx = Mem0[ebx + 0x00:word32];
	esp += 0x04;
	SCZO = cond(esp);
	ecx();
}

// 0804FB60: define camlPervasives__fun_1392
define camlPervasives__fun_1392
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134646119;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FB70: define camlPervasives__fun_1394
define camlPervasives__fun_1394
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FB80: define camlPervasives__fun_1396
define camlPervasives__fun_1396
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068EC3;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FB90: define camlPervasives__fun_1398
define camlPervasives__fun_1398
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080689B5;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FBA0: define camlPervasives__fun_1400
define camlPervasives__fun_1400
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068D81;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FBB0: define camlPervasives__fun_1402
define camlPervasives__fun_1402
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0806BBE1;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FBC0: define camlPervasives__fun_1404
define camlPervasives__fun_1404
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080693E5;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FBD0: define camlPervasives__fun_1406
define camlPervasives__fun_1406
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134648561;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FBE0: define camlPervasives__fun_1408
define camlPervasives__fun_1408
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134648561;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FBF0: define camlPervasives__fun_1410
define camlPervasives__fun_1410
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134646119;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FC00: define camlPervasives__fun_1412
define camlPervasives__fun_1412
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068EC3;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FC10: define camlPervasives__fun_1414
define camlPervasives__fun_1414
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080689FC;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FC20: define camlPervasives__fun_1416
define camlPervasives__fun_1416
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069B0C;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FC30: define camlPervasives__fun_1418
define camlPervasives__fun_1418
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069912;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FC40: define camlPervasives__fun_1420
define camlPervasives__fun_1420
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FC50: define camlPervasives__fun_1422
define camlPervasives__fun_1422
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FC60: define camlPervasives__fun_1424
define camlPervasives__fun_1424
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FC70: define camlPervasives__failwith_1010
// Called from:
//      camlList__hd_1036
//      camlList__tl_1039
//      camlList__nth_1042
//      camlBuffer__resize_1066
//      camlPrintf__index_of_int_1037
//      camlPrintf__scan_format_1278
define camlPervasives__failwith_1010
{
	esp = fp;
	Top = 0;
	ebx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			Mem0[eax + 0x00:word32] = 0x080739CC;
			Mem0[eax + 4:word32] = ebx;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 0804FCB0: define camlPervasives__invalid_arg_1012
// Called from:
//      camlUnix__read_1237
//      camlUnix__write_1242
//      camlUnix__single_write_1247
//      camlUnix__recv_1558
//      camlUnix__recvfrom_1564
//      camlUnix__send_1570
//      camlUnix__sendto_1576
//      camlPervasives__char_of_int_1120
//      camlPervasives__bool_of_string_1129
//      camlPervasives__input_1224
//      camlPervasives__really_input_1235
//      camlArray__sortto_1217
//      camlArray__sub_1081
//      camlArray__fill_1087
//      camlList__nth_1042
//      camlList__map2_1090
//      camlList__rev_map2_1099
//      camlList__iter2_1111
//      camlList__fold_left2_1119
//      camlList__fold_right2_1128
//      camlList__for_all2_1145
//      camlList__exists2_1153
//      camlList__combine_1226
//      camlChar__chr_1032
//      camlString__sub_1046
//      camlString__fill_1051
//      camlString__blit_1056
//      camlString__index_from_1116
//      camlString__rindex_from_1128
//      camlString__contains_1137
//      camlString__rcontains_from_1140
//      camlBuffer__sub_1046
//      camlBuffer__blit_1051
//      camlBuffer__nth_1057
//      camlBuffer__add_substring_1076
//      camlBuffer__add_channel_1090
//      camlBuffer__output_buffer_1094
//      camlPrintf__scan_conv_1143
//      camlPrintf__scan_flags_1142
define camlPervasives__invalid_arg_1012
{
	esp = fp;
	Top = 0;
	ebx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			Mem0[eax + 0x00:word32] = 0x080739E8;
			Mem0[eax + 4:word32] = ebx;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 0804FCF0: define camlPervasives__min_1022
// Called from:
//      camlHashtbl__create_1051
//      camlHashtbl__replace_1112
define camlPervasives__min_1022
{
	ptr32 fp;
	word32 eax;
	word32 ebx;
	word32 dwLoc14;
	Top_3 = 0;
	fn080709D8();
	if (eax_15 == 0x01)
	{
		eax_20 = ebx;
		SCZO_22 = cond(fp);
		C_33 = SLICE(SCZO_22, bool, 1);
		O_39 = SLICE(SCZO_22, bool, 4);
		S_42 = SLICE(SCZO_22, bool, 0);
		Z_46 = SLICE(SCZO_22, bool, 2);
	}
	else
	{
		eax_23 = eax;
		SCZO_25 = cond(fp);
		C_32 = SLICE(SCZO_25, bool, 1);
		O_38 = SLICE(SCZO_25, bool, 4);
		S_41 = SLICE(SCZO_25, bool, 0);
		Z_45 = SLICE(SCZO_25, bool, 2);
	}
}

// 0804FD30: define camlPervasives__max_1025
// Called from:
//      camlHashtbl__create_1051
define camlPervasives__max_1025
{
	ptr32 fp;
	word32 eax;
	word32 ebx;
	word32 dwLoc14;
	Top_3 = 0;
	fn080709D8();
	if (eax_15 == 0x01)
	{
		eax_20 = ebx;
		SCZO_22 = cond(fp);
		C_33 = SLICE(SCZO_22, bool, 1);
		O_39 = SLICE(SCZO_22, bool, 4);
		S_42 = SLICE(SCZO_22, bool, 0);
		Z_46 = SLICE(SCZO_22, bool, 2);
	}
	else
	{
		eax_23 = eax;
		SCZO_25 = cond(fp);
		C_32 = SLICE(SCZO_25, bool, 1);
		O_38 = SLICE(SCZO_25, bool, 4);
		S_41 = SLICE(SCZO_25, bool, 0);
		Z_45 = SLICE(SCZO_25, bool, 2);
	}
}

// 0804FD70: define camlPervasives__abs_1044
define camlPervasives__abs_1044
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(GE,SO))
		return;
	ebx = 0x02;
	ebx -= eax;
	SCZO = cond(ebx);
	eax = ebx;
}

// 0804FD90: define camlPervasives__lnot_1049
define camlPervasives__lnot_1049
{
	esp = fp;
	Top = 0;
	eax = eax ^ ~0x00;
	eax |= 0x01;
	SZ = cond(eax);
	O = false;
	C = false;
}

// 0804FDA0: define camlPervasives__$5e_1112
// Called from:
//      camlPervasives__string_of_float_1140
//      camlPervasives__$5e$5e_1312
//      camlPrintf__scan_conv_1143
//      camlPrintf__scan_flags_1142
//      camlPrintf__index_of_int_1037
//      camlPrintf__fun_1600
define camlPervasives__$5e_1112
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	edx = eax;
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x0C:word32] = ebx;
	ecx = Mem0[edx + -4:word32];
	ecx >>= 0x0A;
	eax = ~0x00 + ecx * 0x04;
	ecx = CONVERT(Mem0[edx + eax:byte], byte, word32);
	eax -= ecx;
	eax = eax + 1 + eax;
	Mem0[esp + 0x00:word32] = eax;
	ecx = Mem0[ebx + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	ebx = CONVERT(Mem0[ebx + ecx:byte], byte, word32);
	ecx -= ebx;
	SCZO = cond(ecx);
	ebx = ecx + 1 + ecx;
	Mem0[esp + 8:word32] = ebx;
	eax = eax - 1 + ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068247;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = eax;
	esi = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	caml_blit_string();
	esp += 0x14;
	SCZO = cond(esp);
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = Mem0[esp + 28:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	caml_blit_string();
	esp += 0x14;
	eax = ebx;
	esp += 0x10;
	SCZO = cond(esp);
}

// 0804FE30: define camlPervasives__char_of_int_1120
define camlPervasives__char_of_int_1120
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(eax - 0x01FF);
		if (Test(LE,SZO))
			return;
	}
	eax = 0x080774E4;
	camlPervasives__invalid_arg_1012();
}

// 0804FE50: define camlPervasives__string_of_bool_1127
define camlPervasives__string_of_bool_1127
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
		eax = 0x080774CC;
	else
		eax = 0x080774D8;
}

// 0804FE70: define camlPervasives__bool_of_string_1129
define camlPervasives__bool_of_string_1129
{
	esp = fp;
	Top = 0;
	ebx = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x080774C0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	caml_string_notequal();
	esp += 0x08;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
		eax = 0x01;
	else
	{
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x080774B4;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		caml_string_notequal();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			eax = 0x03;
		else
		{
			eax = 0x080774A0;
			camlPervasives__invalid_arg_1012();
		}
	}
}

// 0804FED0: define camlPervasives__string_of_int_1130
// Called from:
//      fn0804D600
//      camlPervasives__print_int_1270
//      camlPervasives__prerr_int_1281
//      camlPrintf__fill_format_1096
//      camlPrintf__scan_conv_1143
//      camlPrintf__index_of_int_1037
define camlPervasives__string_of_int_1130
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x08077498;
	eax = 134638366;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0804FEF0: define camlPervasives__valid_float_lexem_1135
// Called from:
//      camlPervasives__string_of_float_1140
define camlPervasives__valid_float_lexem_1135
{
	esp = fp;
	Top = 0;
	ecx = eax;
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ebx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ebx;
	SCZO = cond(eax);
	edx = eax + 1 + eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 4343;
	Mem0[ebx + 0x00:word32] = 0x0804F800;
	Mem0[ebx + 4:word32] = 0x03;
	Mem0[ebx + 8:word32] = ecx;
	Mem0[ebx + 0x0C:word32] = edx;
	eax = 0x01;
	camlPervasives__loop_1138();
}

// 0804FF50: define camlPervasives__string_of_float_1140
// Called from:
//      camlPervasives__print_float_1272
//      camlPervasives__prerr_float_1283
define camlPervasives__string_of_float_1140
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x0807748C;
	eax = 0x0806778A;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	camlPervasives__valid_float_lexem_1135();
}

// 0804FF70: define camlPervasives__$40_1143
// Called from:
//      camlUnix__getaddrinfo_1751
//      camlPervasives__$40_1143
//      camlList__flatten_1058
define camlPervasives__$40_1143
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = ebx;
		esp += 0x04;
		SCZO = cond(esp);
	}
	else
	{
		edx = Mem0[eax + 4:word32];
		ecx = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x00:word32] = ecx;
		eax = edx;
		camlPervasives__$40_1143();
		esp += 0x04;
		ecx = eax;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		ebx = Mem0[esp + 0x00:word32];
		Mem0[eax + 0x00:word32] = ebx;
		Mem0[eax + 4:word32] = ecx;
		esp += 0x04;
		SCZO = cond(esp);
	}
}

// 0804FFD0: define camlPervasives__open_out_gen_1175
// Called from:
//      camlPervasives__open_out_1179
//      camlPervasives__open_out_bin_1181
define camlPervasives__open_out_gen_1175
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	eax = 134661361;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C6E;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 0804FFF0: define camlPervasives__open_out_1179
define camlPervasives__open_out_1179
{
	esp = fp;
	Top = 0;
	ecx = eax;
	ebx = 877;
	eax = 0x0807745C;
	camlPervasives__open_out_gen_1175();
}

// 08050010: define camlPervasives__open_out_bin_1181
define camlPervasives__open_out_bin_1181
{
	esp = fp;
	Top = 0;
	ecx = eax;
	ebx = 877;
	eax = 0x0807742C;
	camlPervasives__open_out_gen_1175();
}

// 08050030: define camlPervasives__flush_all_1185
define camlPervasives__flush_all_1185
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = 134646545;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	camlPervasives__iter_1186();
}

// 08050050: define camlPervasives__output_string_1191
// Called from:
//      camlUnix__handle_unix_error_1171
//      camlPervasives__print_string_1268
//      camlPervasives__print_int_1270
//      camlPervasives__print_float_1272
//      camlPervasives__print_endline_1274
//      camlPervasives__prerr_string_1279
//      camlPervasives__prerr_int_1281
//      camlPervasives__prerr_float_1283
//      camlPervasives__prerr_endline_1285
define camlPervasives__output_string_1191
{
	esp = fp;
	Top = 0;
	ecx = Mem0[ebx + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	edx = CONVERT(Mem0[ebx + ecx:byte], byte, word32);
	ecx -= edx;
	SCZO = cond(ecx);
	ecx = ecx + 1 + ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134649199;
	fn080709D8();
	esp += 0x10;
	SCZO = cond(esp);
}

// 08050080: define camlPervasives__output_1194
// Called from:
//      camlBuffer__output_buffer_1094
define camlPervasives__output_1194
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[ebx + -4:word32];
			esi >>= 0x0A;
			esi = ~0x00 + esi * 0x04;
			edi = CONVERT(Mem0[ebx + esi:byte], byte, word32);
			esi -= edi;
			esi <<= 0x01;
			esi -= edx;
			esi += 0x02;
			SCZO = cond(ecx - esi);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 134649199;
				fn080709D8();
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x08077420;
	camlPervasives__invalid_arg_1012();
}

// 080500D0: define camlPervasives__output_value_1202
define camlPervasives__output_value_1202
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0806AB96;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 080500F0: define camlPervasives__close_out_1209
// Called from:
//      camlUnix__close_process_out_2006
//      fn0804E550
//      fn0804E610
define camlPervasives__close_out_1209
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050120: define camlPervasives__close_out_noerr_1211
define camlPervasives__close_out_noerr_1211
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	fn08050130();
	fn08050170();
	eax = 0x01;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050130: define fn08050130
// Called from:
//      camlPervasives__close_out_noerr_1211
define fn08050130
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	fn08050170();
	eax = 0x01;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050170: define fn08050170
// Called from:
//      camlPervasives__close_out_noerr_1211
//      fn08050130
define fn08050170
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x04;
	SCZO = cond(esp);
}

// 080501A0: define camlPervasives__open_in_gen_1214
// Called from:
//      camlPervasives__open_in_1218
//      camlPervasives__open_in_bin_1220
define camlPervasives__open_in_gen_1214
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ecx;
	eax = 134661361;
	fn080709D8();
	esp += 0x0C;
	SCZO = cond(esp);
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069C37;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 080501C0: define camlPervasives__open_in_1218
define camlPervasives__open_in_1218
{
	esp = fp;
	Top = 0;
	ecx = eax;
	ebx = 0x01;
	eax = 0x08077408;
	camlPervasives__open_in_gen_1214();
}

// 080501E0: define camlPervasives__open_in_bin_1220
define camlPervasives__open_in_bin_1220
{
	esp = fp;
	Top = 0;
	ecx = eax;
	ebx = 0x01;
	eax = 0x080773F0;
	camlPervasives__open_in_gen_1214();
}

// 08050200: define camlPervasives__input_1224
define camlPervasives__input_1224
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[ebx + -4:word32];
			esi >>= 0x0A;
			esi = ~0x00 + esi * 0x04;
			edi = CONVERT(Mem0[ebx + esi:byte], byte, word32);
			esi -= edi;
			esi <<= 0x01;
			esi -= edx;
			esi += 0x02;
			SCZO = cond(ecx - esi);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x08068F5D;
				fn080709D8();
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x080773E4;
	camlPervasives__invalid_arg_1012();
}

// 08050250: define camlPervasives__unsafe_really_input_1229
// Called from:
//      camlPervasives__really_input_1235
define camlPervasives__unsafe_really_input_1229
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(edx - 0x01);
		if (Test(LE,SZO))
			break;
		Mem0[esp + 0x00:word32] = edx;
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 0x0C:word32] = ebx;
		Mem0[esp + 8:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = edx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ecx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x08068F5D;
		fn080709D8();
		esp += 0x10;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691344;
			fn08070A44();
		}
		edx = Mem0[esp + 0x00:word32];
		edx -= eax;
		SCZO = cond(edx);
		++edx;
		SZO = cond(edx);
		ebx = Mem0[esp + 4:word32];
		ecx = ebx - 1 + eax;
		eax = Mem0[esp + 8:word32];
		ebx = Mem0[esp + 0x0C:word32];
	}
	eax = 0x01;
	esp += 0x10;
	SCZO = cond(esp);
}

// 080502F0: define camlPervasives__really_input_1235
// Called from:
//      camlBuffer__add_channel_1090
define camlPervasives__really_input_1235
{
	esp = fp;
	Top = 0;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[ebx + -4:word32];
			esi >>= 0x0A;
			esi = ~0x00 + esi * 0x04;
			edi = CONVERT(Mem0[ebx + esi:byte], byte, word32);
			esi -= edi;
			esi <<= 0x01;
			esi -= edx;
			esi += 0x02;
			SCZO = cond(ecx - esi);
			if (Test(LE,SZO))
			{
				camlPervasives__unsafe_really_input_1229();
				return;
			}
		}
	}
	eax = 0x080773D0;
	camlPervasives__invalid_arg_1012();
}

// 08050330: define camlPervasives__input_line_1241
// Called from:
//      fn0804BE02
//      camlPervasives__read_line_1288
define camlPervasives__input_line_1241
{
	word32 eax;
	<unknown> Mem0;
	word32 dwLoc04;
	bool P;
	Top_3 = 0;
	while (true)
	{
		P_44 = ϕ(P, P_19);
		Mem7 = ϕ(Mem0, Mem10);
		eax_8 = Mem7[0x08080414<p32>:word32];
		Mem10[0x08080414<p32>:word32] = eax_8 - 0x18;
		if (eax_8 - 0x18 >=u Mem10[0x08080418<p32>:word32])
			break;
		fn080708CC();
	}
	Mem21[eax_8 + -24:word32] = 0x14F7;
	Mem22[eax_8 + -20:word32] = 0x0804B370;
	Mem23[eax_8 + -16:word32] = 0x05;
	Mem24[eax_8 + -0x0C:word32] = 134543664;
	Mem26[eax_8 + -8:word32] = eax;
	Mem28[eax_8 + -4:word32] = 0x08077314;
	camlPervasives__scan_1249();
}

// 08050390: define camlPervasives__close_in_noerr_1263
define camlPervasives__close_in_noerr_1263
{
	esp = fp;
	Top = 0;
	fn080503A0();
	eax = 0x01;
}

// 080503A0: define fn080503A0
// Called from:
//      camlPervasives__close_in_noerr_1263
define fn080503A0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068A78;
	fn080709D8();
	esp += 0x04;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
}

// 080503D0: define camlPervasives__print_char_1266
define camlPervasives__print_char_1266
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	v5 = Mem0[0x08076E50<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v5;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 080503F0: define camlPervasives__print_string_1268
define camlPervasives__print_string_1268
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08076E50<p32>:word32];
	camlPervasives__output_string_1191();
}

// 08050400: define camlPervasives__print_int_1270
define camlPervasives__print_int_1270
{
	esp = fp;
	Top = 0;
	camlPervasives__string_of_int_1130();
	ebx = eax;
	eax = Mem0[0x08076E50<p32>:word32];
	camlPervasives__output_string_1191();
}

// 08050420: define camlPervasives__print_float_1272
define camlPervasives__print_float_1272
{
	esp = fp;
	Top = 0;
	camlPervasives__string_of_float_1140();
	ebx = eax;
	eax = Mem0[0x08076E50<p32>:word32];
	camlPervasives__output_string_1191();
}

// 08050440: define camlPervasives__print_endline_1274
define camlPervasives__print_endline_1274
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08076E50<p32>:word32];
	camlPervasives__output_string_1191();
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x15;
	v6 = Mem0[0x08076E50<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v6;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	v8 = Mem0[0x08076E50<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v8;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050480: define camlPervasives__print_newline_1276
define camlPervasives__print_newline_1276
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x15;
	v4 = Mem0[0x08076E50<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	v7 = Mem0[0x08076E50<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v7;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 080504B0: define camlPervasives__prerr_char_1277
define camlPervasives__prerr_char_1277
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	v5 = Mem0[0x08076E54<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v5;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 080504D0: define camlPervasives__prerr_string_1279
define camlPervasives__prerr_string_1279
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08076E54<p32>:word32];
	camlPervasives__output_string_1191();
}

// 080504E0: define camlPervasives__prerr_int_1281
define camlPervasives__prerr_int_1281
{
	esp = fp;
	Top = 0;
	camlPervasives__string_of_int_1130();
	ebx = eax;
	eax = Mem0[0x08076E54<p32>:word32];
	camlPervasives__output_string_1191();
}

// 08050500: define camlPervasives__prerr_float_1283
define camlPervasives__prerr_float_1283
{
	esp = fp;
	Top = 0;
	camlPervasives__string_of_float_1140();
	ebx = eax;
	eax = Mem0[0x08076E54<p32>:word32];
	camlPervasives__output_string_1191();
}

// 08050520: define camlPervasives__prerr_endline_1285
// Called from:
//      camlUnix__handle_unix_error_1171
define camlPervasives__prerr_endline_1285
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08076E54<p32>:word32];
	camlPervasives__output_string_1191();
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x15;
	v6 = Mem0[0x08076E54<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v6;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	v8 = Mem0[0x08076E54<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v8;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050560: define camlPervasives__prerr_newline_1287
define camlPervasives__prerr_newline_1287
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x15;
	v4 = Mem0[0x08076E54<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	eax = 134649690;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	v7 = Mem0[0x08076E54<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v7;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050590: define camlPervasives__read_line_1288
// Called from:
//      camlPervasives__read_int_1289
//      camlPervasives__read_float_1290
define camlPervasives__read_line_1288
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x08076E50<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	eax = 0x080699A6;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	eax = Mem0[0x08076E4C<p32>:word32];
	camlPervasives__input_line_1241();
}

// 080505B0: define camlPervasives__read_int_1289
define camlPervasives__read_int_1289
{
	esp = fp;
	Top = 0;
	eax = 0x01;
	camlPervasives__read_line_1288();
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080668B4;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 080505D0: define camlPervasives__read_float_1290
define camlPervasives__read_float_1290
{
	esp = fp;
	Top = 0;
	eax = 0x01;
	camlPervasives__read_line_1288();
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134643147;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 080505F0: define camlPervasives__fun_1495
define camlPervasives__fun_1495
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068EA1;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050600: define camlPervasives__fun_1493
define camlPervasives__fun_1493
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068971;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050610: define camlPervasives__fun_1491
define camlPervasives__fun_1491
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068D01;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 08050620: define camlPervasives__fun_1489
define camlPervasives__fun_1489
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068EA1;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050630: define camlPervasives__fun_1487
define camlPervasives__fun_1487
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134646163;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050640: define camlPervasives__fun_1485
define camlPervasives__fun_1485
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08069A8C;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 08050650: define camlPervasives__$5e$5e_1312
define camlPervasives__$5e$5e_1312
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080773C8;
	camlPervasives__$5e_1112();
	ebx = eax;
	eax = Mem0[esp + 0x00:word32];
	esp += 0x04;
	SCZO = cond(esp);
	camlPervasives__$5e_1112();
}

// 08050670: define camlPervasives__string_of_format_1315
define camlPervasives__string_of_format_1315
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	ecx = eax;
	Mem0[esp + 4:word32] = ecx;
	ebx = Mem0[ecx + -4:word32];
	ebx >>= 0x0A;
	eax = ~0x00 + ebx * 0x04;
	ebx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ebx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068247;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	caml_blit_string();
	esp += 0x14;
	eax = ebx;
	esp += 0x08;
	SCZO = cond(esp);
}

// 080506C0: define camlPervasives__at_exit_1322
define camlPervasives__at_exit_1322
{
	esp = fp;
	Top = 0;
	ecx = eax;
	eax = Mem0[0x08076F3C<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804FB30;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ecx;
	Mem0[eax + 0x0C:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	v9 = Mem0[0x08076F3C<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v9;
	caml_modify();
	esp += 0x08;
	SCZO = cond(esp);
	eax = 0x01;
}

// 08050720: define camlPervasives__do_at_exit_1325
define camlPervasives__do_at_exit_1325
{
	esp = fp;
	Top = 0;
	eax = Mem0[0x08076F3C<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	eax = 0x01;
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
}

// 08050730: define camlPervasives__exit_1326
// Called from:
//      camlUnix__handle_unix_error_1171
//      camlUnix__system_1891
//      camlUnix__create_process_1907
//      camlUnix__create_process_env_1914
//      camlUnix__open_proc_1949
//      camlUnix__open_proc_full_1975
//      camlUnix__establish_server_2026
define camlPervasives__exit_1326
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[0x08076F3C<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	eax = 0x01;
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0806C168;
	fn080709D8();
	esp += 0x04;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08050760: define camlPervasives__entry
// Called from:
//      caml_program
define camlPervasives__entry
{
	ptr32 fp;
	word32 dwLoc04;
	word32 dwLoc08;
	word32 dwLoc0C;
	Top_3 = 0;
	Mem4[0x08076F14<p32>:word32] = 0x08077304;
	Mem5[0x08076F0C<p32>:word32] = 0x080772F8;
	Mem6[0x08076F08<p32>:word32] = 0x080772EC;
	Mem7[0x08076F04<p32>:word32] = 0x080772E0;
	Mem8[0x08076F00<p32>:word32] = 0x080772D0;
	Mem9[0x08076EFC<p32>:word32] = 0x080772C4;
	Mem10[0x08076EF8<p32>:word32] = 0x080772B8;
	Mem11[0x08076EF4<p32>:word32] = 0x080772AC;
	Mem12[0x08076EE4<p32>:word32] = 0x080772A0;
	Mem13[0x08076ED4<p32>:word32] = 0x08077290;
	Mem14[0x08076EC8<p32>:word32] = 0x08077284;
	Mem15[0x08076EC4<p32>:word32] = 0x08077278;
	Mem16[0x08076EC0<p32>:word32] = 0x08077268;
	Mem17[0x08076EB8<p32>:word32] = 0x08077258;
	Mem18[0x08076EB4<p32>:word32] = 0x08077248;
	Mem19[0x08076EA8<p32>:word32] = 0x08077238;
	Mem20[0x08076EA0<p32>:word32] = 0x0807722C;
	Mem22[0x08076DF8<p32>:word32] = 0x08077220;
	Mem24[0x08076DF4<p32>:word32] = 0x08077214;
	fn080708F8();
	Mem31[eax_25 + 0x00:word32] = 0x0400;
	Mem32[eax_25 + 4:word32] = 0x080773B4;
	Mem33[0x08076DFC<p32>:word32] = eax_25 + 4;
	Mem35[0x08076E00<p32>:word32] = 0x08077204;
	Mem37[0x08076E04<p32>:word32] = 0x080771F4;
	Mem39[0x08076E08<p32>:word32] = 0x080771E8;
	Mem41[0x08076E14<p32>:word32] = 0x080771DC;
	Mem42[0x08076E10<p32>:word32] = 0x80000001;
	Mem43[0x08076E0C<p32>:word32] = 0x7FFFFFFF;
	fn080709D8();
	Mem51[0x08076E18<p32>:word32] = eax_47;
	fn080709D8();
	Mem59[0x08076E1C<p32>:word32] = eax_55;
	fn080709D8();
	Mem67[0x08076E20<p32>:word32] = eax_63;
	fn080709D8();
	Mem75[0x08076E24<p32>:word32] = eax_71;
	fn080709D8();
	Mem83[0x08076E28<p32>:word32] = eax_79;
	fn080709D8();
	Mem91[0x08076E2C<p32>:word32] = eax_87;
	Mem93[0x08076E30<p32>:word32] = 0x080771CC;
	Mem95[0x08076E34<p32>:word32] = 0x080771C0;
	Mem97[0x08076E38<p32>:word32] = 0x080771B4;
	Mem99[0x08076E3C<p32>:word32] = 0x080771A8;
	Mem101[0x08076E40<p32>:word32] = 0x0807719C;
	Mem103[0x08076F38<p32>:word32] = 0x08077350;
	Mem105[0x08076F2C<p32>:word32] = 0x08077190;
	Mem107[0x08076E44<p32>:word32] = 0x08077184;
	Mem109[0x08076E48<p32>:word32] = 0x08077174;
	fn080709D8();
	Mem117[0x08076E4C<p32>:word32] = eax_113;
	fn080709D8();
	Mem125[0x08076E50<p32>:word32] = eax_121;
	fn080709D8();
	Mem133[0x08076E54<p32>:word32] = eax_129;
	Mem135[0x08076E9C<p32>:word32] = 0x08077164;
	Mem137[0x08076E94<p32>:word32] = 0x08077158;
	Mem139[0x08076E98<p32>:word32] = 0x0807714C;
	Mem141[0x08076EA4<p32>:word32] = 0x08077140;
	Mem143[0x08076EAC<p32>:word32] = 0x08077130;
	Mem145[0x08076EB0<p32>:word32] = 0x08077120;
	Mem147[0x08076EBC<p32>:word32] = 0x08077110;
	Mem149[0x08076ECC<p32>:word32] = 0x08077104;
	Mem151[0x08076ED0<p32>:word32] = 0x080770F8;
	Mem153[0x08076EE0<p32>:word32] = 0x080770E8;
	Mem155[0x08076ED8<p32>:word32] = 0x080770DC;
	Mem157[0x08076EDC<p32>:word32] = 0x080770D0;
	Mem159[0x08076EEC<p32>:word32] = 0x080770C0;
	Mem161[0x08076F30<p32>:word32] = 0x080770B0;
	Mem163[0x08076EF0<p32>:word32] = 0x080770A0;
	Mem165[0x08076EE8<p32>:word32] = 0x08077094;
	Mem167[0x08076F10<p32>:word32] = 0x08077088;
	Mem169[0x08076E58<p32>:word32] = 0x0807707C;
	Mem171[0x08076E5C<p32>:word32] = 0x08077070;
	Mem173[0x08076E60<p32>:word32] = 0x08077064;
	Mem175[0x08076E64<p32>:word32] = 0x08077058;
	Mem177[0x08076E68<p32>:word32] = 0x0807704C;
	Mem179[0x08076E6C<p32>:word32] = 0x08077040;
	Mem181[0x08076E70<p32>:word32] = 0x08077034;
	Mem183[0x08076E74<p32>:word32] = 0x08077028;
	Mem185[0x08076E78<p32>:word32] = 0x0807701C;
	Mem187[0x08076E7C<p32>:word32] = 0x08077010;
	Mem189[0x08076E80<p32>:word32] = 0x08077004;
	Mem191[0x08076E84<p32>:word32] = 0x08076FF8;
	Mem193[0x08076E88<p32>:word32] = 0x08076FEC;
	Mem195[0x08076E8C<p32>:word32] = 0x08076FE0;
	Mem197[0x08076E90<p32>:word32] = 0x08076FD4;
	fn08070994();
	Mem205[eax_199 + 0x00:word32] = 0x1800;
	Mem206[eax_199 + 4:word32] = 0x08076F84;
	Mem207[eax_199 + 8:word32] = 134705044;
	Mem208[eax_199 + 0x0C:word32] = 0x08076FA0;
	Mem209[eax_199 + 16:word32] = 0x08076FAC;
	Mem210[eax_199 + 20:word32] = 0x08076FBC;
	Mem211[eax_199 + 24:word32] = 0x08076FC8;
	Mem212[0x08076F18<p32>:word32] = eax_199 + 4;
	Mem214[0x08076F20<p32>:word32] = 0x08076F74;
	Mem216[0x08076F1C<p32>:word32] = 0x08076F68;
	ebx_217 = eax_199 + 0x20;
	Mem219[eax_199 + 0x1C:word32] = 0x0400;
	eax_220 = Mem219[0x08076EA4<p32>:word32];
	Mem221[eax_199 + 0x20:word32] = eax_220;
	Mem222[0x08076F3C<p32>:word32] = eax_199 + 0x20;
	Mem224[0x08076F28<p32>:word32] = 0x08076F5C;
	Mem226[0x08076F34<p32>:word32] = 0x08076F50;
	Mem228[0x08076F24<p32>:word32] = 0x08076F44;
	fn080709D8();
	SCZO_238 = cond(fp);
	C_254 = SLICE(SCZO_238, bool, 1);
	O_255 = SLICE(SCZO_238, bool, 4);
	S_256 = SLICE(SCZO_238, bool, 0);
	Z_257 = SLICE(SCZO_238, bool, 2);
	eax_239 = 0x01;
}

// 08050B90: define camlArray__loop_1201
// Called from:
//      camlArray__merge_1191
define camlArray__loop_1201
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	while (true)
	{
l08050B93:
		Mem0[esp + 4:word32] = eax;
		eax = ebx;
		Mem0[esp + 20:word32] = eax;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 16:word32] = esi;
		Mem0[esp + 0x00:word32] = edi;
		ecx = Mem0[edi + 0x0C:word32];
		ebx = edx;
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(LE,SZO))
			break;
		edi = Mem0[esp + 0x00:word32];
		eax = Mem0[edi + 24:word32];
		ebx = Mem0[eax + -4:word32];
		ecx = ebx;
		ecx &= 0xFF;
		SCZO = cond(ecx - 0xFE);
		if (Test(NE,Z))
		{
			ebx >>= 0x09;
			esi = Mem0[esp + 16:word32];
			SCZO = cond(ebx - esi);
			if (Test(ULE,CZ))
				goto l08050DCF;
			ebx = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			eax = eax - 2 + esi * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l08050D19;
		}
		ebx >>= 0x0A;
		esi = Mem0[esp + 16:word32];
		SCZO = cond(ebx - esi);
		if (Test(ULE,CZ))
		{
l08050DCA:
			fn08070B18();
l08050DCF:
			fn08070B18();
			goto l08050DD4;
		}
		ebx = Mem0[esp + 0x0C:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
		(eax - 4)[esi * 0x04] = ST[Top + 0x00:real64];
		++Top;
l08050D19:
		ecx = Mem0[esp + 8:word32];
		ecx += 0x02;
		eax = Mem0[edi + 32:word32];
		SCZO = cond(ecx - eax);
		if (Test(GE,SO))
		{
			ebp = Mem0[edi + 28:word32];
			ebx = Mem0[esp + 4:word32];
			ebp -= ebx;
			++ebp;
			esi += 0x02;
			ecx = Mem0[edi + 24:word32];
			eax = Mem0[edi + 16:word32];
			edx = esi;
			esi = ebp;
			esp += 0x20;
			SCZO = cond(esp);
			camlArray__blit_1093();
			return;
		}
		ebx = Mem0[edi + 20:word32];
		edx = Mem0[ebx + -4:word32];
		eax = edx;
		eax &= 0xFF;
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
		{
			eax = edx;
			eax >>= 0x09;
			SCZO = cond(eax - ecx);
			if (Test(ULE,CZ))
				goto l08050DC5;
			edx = (ebx - 2)[ecx * 0x02];
			goto l08050D7E;
		}
		eax = edx;
		eax >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(ULE,CZ))
		{
			fn08070B18();
l08050DC5:
			fn08070B18();
			goto l08050DCA;
		}
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		edx = eax + 4;
		Mem0[edx + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = (ebx - 4)[ecx * 0x04];
		Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
l08050D7E:
		esi += 0x02;
		SCZO = cond(esi);
		eax = Mem0[esp + 4:word32];
		ebx = Mem0[esp + 20:word32];
	}
	edi = Mem0[esp + 0x00:word32];
	eax = Mem0[edi + 24:word32];
	ebx = Mem0[eax + -4:word32];
	ecx = ebx;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		ebx >>= 0x09;
		esi = Mem0[esp + 16:word32];
		SCZO = cond(ebx - esi);
		if (Test(ULE,CZ))
			goto l08050DE3;
		ebx = Mem0[esp + 20:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		eax = eax - 2 + esi * 0x02;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		ebx >>= 0x0A;
		esi = Mem0[esp + 16:word32];
		SCZO = cond(ebx - esi);
		if (Test(ULE,CZ))
			goto l08050DDE;
		ebx = Mem0[esp + 20:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
		(eax - 4)[esi * 0x04] = ST[Top + 0x00:real64];
		++Top;
	}
	ecx = Mem0[esp + 4:word32];
	ecx += 0x02;
	eax = Mem0[edi + 28:word32];
	SCZO = cond(ecx - eax);
	if (Test(GE,SO))
	{
		ebp = Mem0[edi + 32:word32];
		ebx = Mem0[esp + 8:word32];
		ebp -= ebx;
		++ebp;
		esi += 0x02;
		ecx = Mem0[edi + 24:word32];
		eax = Mem0[edi + 20:word32];
		edx = esi;
		esi = ebp;
		esp += 0x20;
		SCZO = cond(esp);
		camlArray__blit_1093();
		return;
	}
	ebx = Mem0[edi + 16:word32];
	edx = Mem0[ebx + -4:word32];
	eax = edx;
	eax &= 0xFF;
	SCZO = cond(eax - 0xFE);
	if (Test(NE,Z))
	{
		eax = edx;
		eax >>= 0x09;
		SCZO = cond(eax - ecx);
		if (Test(UGT,CZ))
		{
			ebx = (ebx - 2)[ecx * 0x02];
			goto l08050C88;
		}
	}
	else
	{
		eax = edx;
		eax >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(UGT,CZ))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			edx = eax + 4;
			Mem0[edx + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (ebx - 4)[ecx * 0x04];
			Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			ebx = edx;
l08050C88:
			esi += 0x02;
			SCZO = cond(esi);
			eax = ecx;
			ecx = Mem0[esp + 8:word32];
			edx = Mem0[esp + 0x0C:word32];
			goto l08050B93;
		}
l08050DD4:
		fn08070B18();
	}
	fn08070B18();
l08050DDE:
	fn08070B18();
l08050DE3:
	fn08070B18();
	esi += 0x00;
}

// 08050DF0: define camlArray__size_1065
// Called from:
//      camlArray__find_init_1077
//      camlArray__sortto_1217
define camlArray__size_1065
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		ecx = Mem0[ebx + 4:word32];
		ebx = Mem0[ebx + 0x00:word32];
		ebx = Mem0[ebx + -4:word32];
		edx = ebx;
		edx &= 0xFF;
		SCZO = cond(edx - 0xFE);
		if (Test(NE,Z))
		{
			ebx >>= 0x09;
			SCZO = cond(ebx);
		}
		else
		{
			ebx >>= 0x0A;
			SCZO = cond(ebx);
		}
		ebx |= 0x01;
		eax += ebx;
		SCZO = cond(eax);
		--eax;
		SZO = cond(eax);
		ebx = ecx;
	}
}

// 08050E40: define camlArray__fill_1070
// Called from:
//      camlArray__find_init_1077
define camlArray__fill_1070
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
	while (true)
	{
		edi = ecx;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 8:word32] = eax;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		Mem0[esp + 4:word32] = eax;
		ebx = 0x01;
		esi = Mem0[eax + -4:word32];
		eax = esi;
		eax &= 0xFF;
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
		{
			esi >>= 0x09;
			SCZO = cond(esi);
		}
		else
		{
			esi >>= 0x0A;
			SCZO = cond(esi);
		}
		esi |= 0x01;
		esi += ~0x01;
		SCZO = cond(ebx - esi);
		if (Test(LE,SZO))
		{
			do
			{
				ecx = Mem0[esp + 4:word32];
				eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
				SCZO = cond(eax - 0xFE);
				if (Test(NE,Z))
					eax = (ecx - 2)[ebx * 0x02];
				else
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x0C;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					eax += 4;
					Mem0[eax + -4:word32] = 0x08FD;
					--Top;
					ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
					Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
					++Top;
				}
				ecx = Mem0[esp + 8:word32];
				ebp = ecx - 1 + ebx;
				edx = Mem0[edi + 0x0C:word32];
				ecx = CONVERT(Mem0[edx + -4:byte], byte, word32);
				SCZO = cond(ecx - 0xFE);
				if (Test(NE,Z))
				{
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					eax = edx - 2 + ebp * 0x02;
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					caml_modify();
					esp += 0x08;
					SCZO = cond(esp);
				}
				else
				{
					--Top;
					ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
					(edx - 4)[ebp * 0x04] = ST[Top + 0x00:real64];
					++Top;
				}
				eax = ebx;
				ebx += 0x02;
				SCZO = cond(eax - esi);
			} while (Test(NE,Z));
		}
		eax = Mem0[esp + 4:word32];
		ebx = Mem0[eax + -4:word32];
		eax = ebx;
		eax &= 0xFF;
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
		{
			ebx >>= 0x09;
			SCZO = cond(ebx);
		}
		else
		{
			ebx >>= 0x0A;
			SCZO = cond(ebx);
		}
		ebx |= 0x01;
		eax = Mem0[esp + 8:word32];
		eax += ebx;
		SCZO = cond(eax);
		--eax;
		SZO = cond(eax);
		ebx = Mem0[esp + 0x00:word32];
		ecx = edi;
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
}

// 08050F70: define camlArray__find_init_1077
// Called from:
//      camlArray__concat_1075
define camlArray__find_init_1077
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	do
	{
		ebx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x08077E70;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[ebx + 4:word32];
		ecx = Mem0[ebx + 0x00:word32];
		edx = Mem0[ecx + -4:word32];
		esi = edx;
		esi &= 0xFF;
		SCZO = cond(esi - 0xFE);
		if (Test(NE,Z))
		{
			edx >>= 0x09;
			SCZO = cond(edx);
		}
		else
		{
			edx >>= 0x0A;
			SCZO = cond(edx);
		}
		edx |= 0x01;
		SCZO = cond(edx - 0x01);
	} while (Test(LE,SZO));
	eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
	SCZO = cond(eax - 0xFE);
	if (Test(NE,Z))
		eax = Mem0[ecx + 0x00:word32];
	else
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
		Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	esp += 0x08;
	SCZO = cond(esp);
	camlArray__concat_aux_1062();
}

// 08051010: define camlArray__tolist_1123
// Called from:
//      camlArray__to_list_1121
define camlArray__tolist_1123
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(edx - 0x01);
		if (Test(LT,SO))
			break;
		esi = Mem0[ecx + 0x0C:word32];
		eax = CONVERT(Mem0[esi + -4:byte], byte, word32);
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
			edi = (esi - 2)[edx * 0x02];
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			edi = eax + 4;
			Mem0[edi + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (esi - 4)[edx * 0x04];
			Mem0[edi + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		esi = eax + 4;
		Mem0[esi + -4:word32] = 0x0800;
		Mem0[esi + 0x00:word32] = edi;
		Mem0[esi + 4:word32] = ebx;
		eax = edx;
		eax += ~0x01;
		SCZO = cond(eax);
		ebx = esi;
	}
	eax = ebx;
	esp += 0x08;
	SCZO = cond(esp);
}

// 080510A0: define camlArray__fill_1135
// Called from:
//      camlArray__of_list_1130
define camlArray__fill_1135
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		edi = eax;
		esi = ecx;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		ebp = Mem0[ebx + 4:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ebx = Mem0[esi + 0x0C:word32];
		eax = CONVERT(Mem0[ebx + -4:byte], byte, word32);
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
		{
			esp -= 4;
			Mem0[esp + 0x00:word32] = ecx;
			eax = ebx - 2 + edi * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
		}
		else
		{
			--Top;
			ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
			(ebx - 4)[edi * 0x04] = ST[Top + 0x00:real64];
			++Top;
		}
		eax = edi;
		eax += 0x02;
		SCZO = cond(eax);
		ebx = ebp;
		ecx = esi;
	}
	eax = Mem0[esi + 0x0C:word32];
	esp += 0x08;
	SCZO = cond(esp);
}

// 08051100: define camlArray__maxson_1155
// Called from:
//      camlArray__trickledown_1160
//      camlArray__bubbledown_1170
define camlArray__maxson_1155
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	edx = eax;
	eax = ebx;
	eax += ebx;
	esi = eax + 3 + ebx;
	esi += ~0x02;
	SCZO = cond(esi);
	Mem0[esp + 8:word32] = esi;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edi = eax + 4;
	Mem0[edi + -4:word32] = 0x0400;
	Mem0[edi + 0x00:word32] = esi;
	eax = esi;
	eax += 0x04;
	SCZO = cond(eax - edx);
	if (Test(LT,SO))
	{
		Mem0[esp + 4:word32] = edi;
		Mem0[esp + 0x00:word32] = ecx;
		edx = esi;
		edx += 0x02;
		edi = Mem0[ecx + 16:word32];
		eax = Mem0[edi + -4:word32];
		ebx = eax;
		ebx &= 0xFF;
		SCZO = cond(ebx - 0xFE);
		if (Test(NE,Z))
		{
			eax >>= 0x09;
			SCZO = cond(eax - edx);
			if (Test(ULE,CZ))
				goto l080514E7;
			ebx = (edi - 2)[edx * 0x02];
		}
		else
		{
			eax >>= 0x0A;
			SCZO = cond(eax - edx);
			if (Test(ULE,CZ))
				goto l080514E2;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ebx = eax + 4;
			Mem0[ebx + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (edi - 4)[edx * 0x04];
			Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		edx = Mem0[ecx + 16:word32];
		eax = Mem0[edx + -4:word32];
		edi = eax;
		edi &= 0xFF;
		SCZO = cond(edi - 0xFE);
		if (Test(NE,Z))
		{
			eax >>= 0x09;
			SCZO = cond(eax - esi);
			if (Test(ULE,CZ))
				goto l080514DD;
			eax = (edx - 2)[esi * 0x02];
		}
		else
		{
			eax >>= 0x0A;
			SCZO = cond(eax - esi);
			if (Test(ULE,CZ))
				goto l080514D8;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (edx - 4)[esi * 0x04];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		ecx = Mem0[ecx + 0x0C:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(LT,SO))
		{
			ebx = Mem0[esp + 8:word32];
			ebx += 0x02;
			SCZO = cond(ebx);
			eax = Mem0[esp + 4:word32];
			Mem0[eax + 0x00:word32] = ebx;
		}
		ecx = Mem0[esp + 8:word32];
		ecx += 0x04;
		esi = Mem0[esp + 0x00:word32];
		edx = Mem0[esi + 16:word32];
		eax = Mem0[edx + -4:word32];
		ebx = eax;
		ebx &= 0xFF;
		SCZO = cond(ebx - 0xFE);
		if (Test(NE,Z))
		{
			eax >>= 0x09;
			SCZO = cond(eax - ecx);
			if (Test(ULE,CZ))
				goto l080514D3;
			ebx = (edx - 2)[ecx * 0x02];
		}
		else
		{
			eax >>= 0x0A;
			SCZO = cond(eax - ecx);
			if (Test(ULE,CZ))
				goto l080514CE;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ebx = eax + 4;
			Mem0[ebx + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (edx - 4)[ecx * 0x04];
			Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		eax = Mem0[esp + 4:word32];
		edx = Mem0[eax + 0x00:word32];
		ecx = Mem0[esi + 16:word32];
		eax = Mem0[ecx + -4:word32];
		edi = eax;
		edi &= 0xFF;
		SCZO = cond(edi - 0xFE);
		if (Test(NE,Z))
		{
			eax >>= 0x09;
			SCZO = cond(eax - edx);
			if (Test(UGT,CZ))
			{
				eax = (ecx - 2)[edx * 0x02];
				goto l08051304;
			}
			goto l080514C9;
		}
		eax >>= 0x0A;
		SCZO = cond(eax - edx);
		if (Test(UGT,CZ))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (ecx - 4)[edx * 0x04];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
l08051304:
			ecx = Mem0[esi + 0x0C:word32];
			caml_apply2();
			SCZO = cond(eax - 0x01);
			if (Test(LT,SO))
			{
				ebx = Mem0[esp + 8:word32];
				ebx += 0x04;
				SCZO = cond(ebx);
				eax = Mem0[esp + 4:word32];
				Mem0[eax + 0x00:word32] = ebx;
			}
			eax = Mem0[esp + 4:word32];
			eax = Mem0[eax + 0x00:word32];
			esp += 0x14;
			SCZO = cond(esp);
			return;
		}
l080514C4:
		fn08070B18();
l080514C9:
		fn08070B18();
l080514CE:
		fn08070B18();
l080514D3:
		fn08070B18();
l080514D8:
		fn08070B18();
l080514DD:
		fn08070B18();
l080514E2:
		fn08070B18();
l080514E7:
		fn08070B18();
		esi = esi;
		camlArray__trickledown_1160();
		return;
	}
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 0x00:word32] = edx;
	eax = esi;
	eax += 0x02;
	SCZO = cond(eax - edx);
	if (Test(GE,SO))
	{
l08051420:
		eax = Mem0[esp + 8:word32];
		ebx = Mem0[esp + 0x00:word32];
		SCZO = cond(eax - ebx);
		if (Test(GE,SO))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
				{
					eax += 4;
					Mem0[eax + -4:word32] = 0x0800;
					ebx = Mem0[0x08077C94<p32>:word32];
					Mem0[eax + 0x00:word32] = ebx;
					ebx = Mem0[esp + 4:word32];
					Mem0[eax + 4:word32] = ebx;
					fn08070A44();
				}
				fn080708CC();
			}
		}
		else
		{
			esp += 0x14;
			SCZO = cond(esp);
			return;
		}
	}
	ebx = esi;
	ebx += 0x02;
	edx = Mem0[ecx + 16:word32];
	edi = Mem0[edx + -4:word32];
	eax = edi;
	eax &= 0xFF;
	SCZO = cond(eax - 0xFE);
	if (Test(NE,Z))
	{
		eax = edi;
		eax >>= 0x09;
		SCZO = cond(eax - ebx);
		if (Test(ULE,CZ))
			goto l080514BF;
		ebx = (edx - 2)[ebx * 0x02];
	}
	else
	{
		eax = edi;
		eax >>= 0x0A;
		SCZO = cond(eax - ebx);
		if (Test(ULE,CZ))
			goto l080514BA;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = (edx - 4)[ebx * 0x04];
		Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
		ebx = eax;
	}
	edx = Mem0[ecx + 16:word32];
	edi = Mem0[edx + -4:word32];
	eax = edi;
	eax &= 0xFF;
	SCZO = cond(eax - 0xFE);
	if (Test(NE,Z))
	{
		eax = edi;
		eax >>= 0x09;
		SCZO = cond(eax - esi);
		if (Test(UGT,CZ))
		{
			eax = (edx - 2)[esi * 0x02];
			goto l08051402;
		}
	}
	else
	{
		eax = edi;
		eax >>= 0x0A;
		SCZO = cond(eax - esi);
		if (Test(UGT,CZ))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (edx - 4)[esi * 0x04];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
l08051402:
			ecx = Mem0[ecx + 0x0C:word32];
			caml_apply2();
			SCZO = cond(eax - 0x01);
			if (Test(LT,SO))
			{
				eax = Mem0[esp + 8:word32];
				eax += 0x02;
				esp += 0x14;
				SCZO = cond(esp);
				return;
			}
			goto l08051420;
		}
		fn08070B18();
	}
	fn08070B18();
l080514BA:
	fn08070B18();
l080514BF:
	fn08070B18();
	goto l080514C4;
}

// 080514F0: define camlArray__trickledown_1160
// Called from:
//      camlArray__maxson_1155
//      fn08051790
define camlArray__trickledown_1160
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
l080514F3:
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x0C:word32] = ebx;
	Mem0[esp + 8:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	ecx = Mem0[edx + 20:word32];
	camlArray__maxson_1155();
	ebx = eax;
	Mem0[esp + 16:word32] = ebx;
	edx = Mem0[esp + 0x00:word32];
	ecx = Mem0[edx + 16:word32];
	eax = Mem0[ecx + -4:word32];
	esi = eax;
	esi &= 0xFF;
	SCZO = cond(esi - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - ebx);
		if (Test(ULE,CZ))
			goto l080516F5;
		eax = (ecx - 2)[ebx * 0x02];
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - ebx);
		if (Test(ULE,CZ))
			goto l080516F0;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
		Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	ecx = Mem0[edx + 0x0C:word32];
	ebx = Mem0[esp + 8:word32];
	caml_apply2();
	SCZO = cond(eax - 0x01);
	if (Test(GT,SZO))
	{
		esi = Mem0[esp + 0x00:word32];
		ecx = Mem0[esi + 16:word32];
		eax = Mem0[ecx + -4:word32];
		ebx = eax;
		ebx &= 0xFF;
		SCZO = cond(ebx - 0xFE);
		if (Test(NE,Z))
		{
			eax >>= 0x09;
			ebx = Mem0[esp + 16:word32];
			SCZO = cond(eax - ebx);
			if (Test(ULE,CZ))
				goto l080516EB;
			edx = (ecx - 2)[ebx * 0x02];
		}
		else
		{
			eax >>= 0x0A;
			ebx = Mem0[esp + 16:word32];
			SCZO = cond(eax - ebx);
			if (Test(ULE,CZ))
				goto l080516E6;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			edx = eax + 4;
			Mem0[edx + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
			Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		eax = Mem0[esi + 16:word32];
		edi = Mem0[eax + -4:word32];
		ecx = edi;
		ecx &= 0xFF;
		SCZO = cond(ecx - 0xFE);
		if (Test(NE,Z))
		{
			edi >>= 0x09;
			ecx = Mem0[esp + 0x0C:word32];
			SCZO = cond(edi - ecx);
			if (Test(UGT,CZ))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				eax = eax - 2 + ecx * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				SCZO = cond(esp);
				goto l08051645;
			}
			goto l080516E1;
		}
		edi >>= 0x0A;
		ecx = Mem0[esp + 0x0C:word32];
		SCZO = cond(edi - ecx);
		if (Test(UGT,CZ))
		{
			--Top;
			ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
			(eax - 4)[ecx * 0x04] = ST[Top + 0x00:real64];
			++Top;
l08051645:
			eax = Mem0[esp + 4:word32];
			ecx = Mem0[esp + 8:word32];
			edx = esi;
			goto l080514F3;
		}
l080516DC:
		fn08070B18();
l080516E1:
		fn08070B18();
l080516E6:
		fn08070B18();
l080516EB:
		fn08070B18();
l080516F0:
		fn08070B18();
l080516F5:
		fn08070B18();
		esi += 0x00;
		camlArray__trickle_1165();
		return;
	}
	eax = Mem0[esp + 0x00:word32];
	eax = Mem0[eax + 16:word32];
	ebx = Mem0[eax + -4:word32];
	ecx = ebx;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		ebx >>= 0x09;
		ecx = Mem0[esp + 0x0C:word32];
		SCZO = cond(ebx - ecx);
		if (Test(UGT,CZ))
		{
			ebx = Mem0[esp + 8:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			eax = eax - 2 + ecx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l080516B5;
		}
	}
	else
	{
		ebx >>= 0x0A;
		ecx = Mem0[esp + 0x0C:word32];
		SCZO = cond(ebx - ecx);
		if (Test(UGT,CZ))
		{
			ebx = Mem0[esp + 8:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
			(eax - 4)[ecx * 0x04] = ST[Top + 0x00:real64];
			++Top;
l080516B5:
			eax = 0x01;
			esp += 0x1C;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	goto l080516DC;
}

// 08051700: define camlArray__trickle_1165
// Called from:
//      camlArray__trickledown_1160
//      camlArray__sort_1152
define camlArray__trickle_1165
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	fn08051790();
	ecx = Mem0[0x08077C94<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn08051790();
		return;
	}
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[esp + 0x00:word32];
	eax = Mem0[eax + 0x0C:word32];
	ecx = Mem0[eax + -4:word32];
	edx = ecx;
	edx &= 0xFF;
	SCZO = cond(edx - 0xFE);
	if (Test(NE,Z))
	{
		ecx >>= 0x09;
		SCZO = cond(ecx - ebx);
		if (Test(UGT,CZ))
		{
			ecx = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = ecx;
			eax = eax - 2 + ebx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l08051771;
		}
	}
	else
	{
		ecx >>= 0x0A;
		SCZO = cond(ecx - ebx);
		if (Test(UGT,CZ))
		{
			ecx = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
			(eax - 4)[ebx * 0x04] = ST[Top + 0x00:real64];
			++Top;
l08051771:
			eax = 0x01;
			esp += 0x10;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	esi = esi;
	camlArray__bubbledown_1170();
}

// 08051790: define fn08051790
// Called from:
//      camlArray__trickle_1165
define fn08051790
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	edx = Mem0[edx + 16:word32];
	camlArray__trickledown_1160();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x10;
	SCZO = cond(esp);
}

// 080517C0: define camlArray__bubbledown_1170
// Called from:
//      camlArray__trickle_1165
//      fn080518F0
define camlArray__bubbledown_1170
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
l080517C3:
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 0x00:word32] = ecx;
	ecx = Mem0[ecx + 16:word32];
	camlArray__maxson_1155();
	ebx = eax;
	esi = Mem0[esp + 0x00:word32];
	ecx = Mem0[esi + 0x0C:word32];
	eax = Mem0[ecx + -4:word32];
	edx = eax;
	edx &= 0xFF;
	SCZO = cond(edx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - ebx);
		if (Test(ULE,CZ))
			goto l080518B5;
		edx = (ecx - 2)[ebx * 0x02];
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - ebx);
		if (Test(ULE,CZ))
			goto l080518B0;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		edx = eax + 4;
		Mem0[edx + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
		Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[esi + 0x0C:word32];
	edi = Mem0[eax + -4:word32];
	ecx = edi;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		edi >>= 0x09;
		ecx = Mem0[esp + 8:word32];
		SCZO = cond(edi - ecx);
		if (Test(UGT,CZ))
		{
			esp -= 4;
			Mem0[esp + 0x00:word32] = edx;
			eax = eax - 2 + ecx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l08051891;
		}
	}
	else
	{
		edi >>= 0x0A;
		ecx = Mem0[esp + 8:word32];
		SCZO = cond(edi - ecx);
		if (Test(UGT,CZ))
		{
			--Top;
			ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
			(eax - 4)[ecx * 0x04] = ST[Top + 0x00:real64];
			++Top;
l08051891:
			eax = Mem0[esp + 4:word32];
			ecx = esi;
			goto l080517C3;
		}
		fn08070B18();
	}
	fn08070B18();
l080518B0:
	fn08070B18();
l080518B5:
	fn08070B18();
	esi += 0x00;
	camlArray__bubble_1174();
}

// 080518C0: define camlArray__bubble_1174
// Called from:
//      camlArray__bubbledown_1170
//      camlArray__sort_1152
define camlArray__bubble_1174
{
	esp = fp;
	Top = 0;
	fn080518F0();
	ecx = Mem0[0x08077C94<p32>:word32];
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn080518F0();
	}
	else
		eax = Mem0[eax + 4:word32];
}

// 080518F0: define fn080518F0
// Called from:
//      camlArray__bubble_1174
define fn080518F0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	ecx = Mem0[ecx + 0x0C:word32];
	camlArray__bubbledown_1170();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08051910: define camlArray__trickleup_1178
// Called from:
//      camlArray__sort_1152
define camlArray__trickleup_1178
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
l08051913:
	esi = eax;
	edi = ecx;
	ecx = 0x03;
	eax = esi;
	eax += ~0x01;
	eax >>= 0x01;
	edx_eax = CONVERT(eax, int32, int64);
	v13 = edx_eax;
	edx = CONVERT(v13 %s ecx, int64, int32);
	eax = CONVERT(v13 /32 ecx, word32, int32);
	ecx = eax + 1 + eax;
	SCZO = cond(esi - ecx);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x0C:word32] = ecx;
		Mem0[esp + 0x00:word32] = edi;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 8:word32] = esi;
	}
	else
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		Mem0[eax + 0x00:word32] = 134691556;
		Mem0[eax + 4:word32] = 0x08077E50;
		fn08070A44();
		esi = esi;
		edi += 0x00;
	}
	edx = Mem0[edi + 16:word32];
	eax = Mem0[edx + -4:word32];
	esi = eax;
	esi &= 0xFF;
	SCZO = cond(esi - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - ecx);
		if (Test(ULE,CZ))
			goto l08051BD9;
		eax = (edx - 2)[ecx * 0x02];
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(ULE,CZ))
			goto l08051BD4;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = (edx - 4)[ecx * 0x04];
		Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	ecx = Mem0[edi + 0x0C:word32];
	caml_apply2();
	SCZO = cond(eax - 0x01);
	if (Test(LT,SO))
	{
		edi = Mem0[esp + 0x00:word32];
		ebx = Mem0[edi + 16:word32];
		eax = Mem0[ebx + -4:word32];
		ecx = eax;
		ecx &= 0xFF;
		SCZO = cond(ecx - 0xFE);
		if (Test(NE,Z))
		{
			eax >>= 0x09;
			esi = Mem0[esp + 0x0C:word32];
			SCZO = cond(eax - esi);
			if (Test(ULE,CZ))
				goto l08051BCF;
			ecx = (ebx - 2)[esi * 0x02];
		}
		else
		{
			eax >>= 0x0A;
			esi = Mem0[esp + 0x0C:word32];
			SCZO = cond(eax - esi);
			if (Test(ULE,CZ))
				goto l08051BCA;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ecx = eax + 4;
			Mem0[ecx + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (ebx - 4)[esi * 0x04];
			Mem0[ecx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		eax = Mem0[edi + 16:word32];
		edx = Mem0[eax + -4:word32];
		ebx = edx;
		ebx &= 0xFF;
		SCZO = cond(ebx - 0xFE);
		if (Test(NE,Z))
		{
			edx >>= 0x09;
			ebx = Mem0[esp + 8:word32];
			SCZO = cond(edx - ebx);
			if (Test(ULE,CZ))
				goto l08051BC5;
			esp -= 4;
			Mem0[esp + 0x00:word32] = ecx;
			eax = eax - 2 + ebx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
		}
		else
		{
			edx >>= 0x0A;
			ebx = Mem0[esp + 8:word32];
			SCZO = cond(edx - ebx);
			if (Test(ULE,CZ))
				goto l08051BC0;
			--Top;
			ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
			(eax - 4)[ebx * 0x04] = ST[Top + 0x00:real64];
			++Top;
		}
		SCZO = cond(esi - 0x01);
		if (Test(GT,SZO))
		{
			eax = esi;
			ebx = Mem0[esp + 4:word32];
			ecx = edi;
			goto l08051913;
		}
		ecx = Mem0[edi + 16:word32];
		ebx = Mem0[ecx + -4:word32];
		eax = ebx;
		eax &= 0xFF;
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
		{
			eax = ebx;
			eax >>= 0x09;
			SCZO = cond(eax - 0x01);
			if (Test(UGT,CZ))
			{
				eax = Mem0[esp + 4:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				caml_modify();
				esp += 0x08;
				SCZO = cond(esp);
				goto l08051B26;
			}
			goto l08051BBB;
		}
		eax = ebx;
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[ecx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
l08051B26:
			eax = 0x01;
			esp += 0x18;
			SCZO = cond(esp);
			return;
		}
l08051BB6:
		fn08070B18();
l08051BBB:
		fn08070B18();
l08051BC0:
		fn08070B18();
l08051BC5:
		fn08070B18();
l08051BCA:
		fn08070B18();
l08051BCF:
		fn08070B18();
l08051BD4:
		fn08070B18();
l08051BD9:
		fn08070B18();
		camlArray__merge_1191();
		return;
	}
	eax = Mem0[esp + 0x00:word32];
	eax = Mem0[eax + 16:word32];
	ebx = Mem0[eax + -4:word32];
	ecx = ebx;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		ebx >>= 0x09;
		ecx = Mem0[esp + 8:word32];
		SCZO = cond(ebx - ecx);
		if (Test(UGT,CZ))
		{
			ebx = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			eax = eax - 2 + ecx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l08051B85;
		}
	}
	else
	{
		ebx >>= 0x0A;
		ecx = Mem0[esp + 8:word32];
		SCZO = cond(ebx - ecx);
		if (Test(UGT,CZ))
		{
			ebx = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
			(eax - 4)[ecx * 0x04] = ST[Top + 0x00:real64];
			++Top;
l08051B85:
			eax = 0x01;
			esp += 0x18;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	goto l08051BB6;
}

// 08051BE0: define camlArray__merge_1191
// Called from:
//      camlArray__trickleup_1178
//      camlArray__sortto_1217
//      camlArray__stable_sort_1188
define camlArray__merge_1191
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 16:word32] = edx;
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[0x0807D0BC<p32>:word32];
	Mem0[esp + 0x0C:word32] = eax;
	ebp = Mem0[0x0807D0C0<p32>:word32];
	ecx = Mem0[esp + 0x00:word32];
	edx = ecx - 1 + ebx;
	eax = Mem0[esp + 16:word32];
	esi = eax - 1 + esi;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x28;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edi = eax + 4;
	Mem0[edi + -4:word32] = 0x24F7;
	Mem0[edi + 0x00:word32] = 0x0804B0D0;
	Mem0[edi + 4:word32] = 11;
	Mem0[edi + 8:word32] = 0x08050B90;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[edi + 0x0C:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	Mem0[edi + 16:word32] = eax;
	ebx = Mem0[esp + 4:word32];
	Mem0[edi + 20:word32] = ebx;
	eax = Mem0[esp + 8:word32];
	Mem0[edi + 24:word32] = eax;
	Mem0[edi + 28:word32] = edx;
	Mem0[edi + 32:word32] = esi;
	eax = Mem0[ebx + -4:word32];
	edx = eax;
	edx &= 0xFF;
	SCZO = cond(edx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - Mem0[esp + 16:word32]);
		if (Test(ULE,CZ))
			goto l08051D68;
		eax = Mem0[esp + 16:word32];
		edx = (ebx - 2)[eax * 0x02];
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - Mem0[esp + 16:word32]);
		if (Test(ULE,CZ))
			goto l08051D63;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		edx = eax + 4;
		Mem0[edx + -4:word32] = 0x08FD;
		eax = Mem0[esp + 16:word32];
		--Top;
		ST[Top + 0x00:real64] = (ebx - 4)[eax * 0x04];
		Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	esi = Mem0[ebp + 16:word32];
	eax = Mem0[esi + -4:word32];
	ebx = eax;
	ebx &= 0xFF;
	SCZO = cond(ebx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - ecx);
		if (Test(UGT,CZ))
		{
			ebx = (esi - 2)[ecx * 0x02];
			goto l08051D2C;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(UGT,CZ))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ebx = eax + 4;
			Mem0[ebx + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (esi - 4)[ecx * 0x04];
			Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
l08051D2C:
			eax = ecx;
			ecx = Mem0[esp + 16:word32];
			esi = Mem0[esp + 0x0C:word32];
			esp += 0x1C;
			SCZO = cond(esp);
			camlArray__loop_1201();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
l08051D63:
	fn08070B18();
l08051D68:
	fn08070B18();
	esi = esi;
	camlArray__isortto_1209();
}

// 08051D70: define camlArray__isortto_1209
// Called from:
//      camlArray__sortto_1217
//      camlArray__stable_sort_1188
define camlArray__isortto_1209
{
	esp = fp;
	Top = 0;
	esp -= 0x28;
	edi = 0x01;
	edx += ~0x01;
	SCZO = cond(edi - edx);
	if (Test(LE,SZO))
	{
		Mem0[esp + 16:word32] = edx;
		Mem0[esp + 0x0C:word32] = edi;
		Mem0[esp + 24:word32] = esi;
		Mem0[esp + 20:word32] = ecx;
		Mem0[esp + 28:word32] = ebx;
		Mem0[esp + 0x00:word32] = eax;
		do
		{
			eax = Mem0[esp + 0x00:word32];
			eax = eax - 1 + edi;
			Mem0[esp + 4:word32] = eax;
			ecx = Mem0[esp + 24:word32];
			ecx = Mem0[ecx + 16:word32];
			edx = Mem0[ecx + -4:word32];
			Mem0[esp + 8:word32] = edx;
			edx = Mem0[esp + 8:word32];
			edx &= 0xFF;
			SCZO = cond(edx - 0xFE);
			if (Test(NE,Z))
			{
				edx = Mem0[esp + 8:word32];
				edx >>= 0x09;
				SCZO = cond(edx - eax);
				if (Test(ULE,CZ))
					goto l08052068;
				edx = (ecx - 2)[eax * 0x02];
				Mem0[esp + 4:word32] = edx;
				goto l08051E20;
			}
			edx = Mem0[esp + 8:word32];
			edx >>= 0x0A;
			SCZO = cond(edx - eax);
			if (Test(ULE,CZ))
			{
l08052063:
				fn08070B18();
l08052068:
				fn08070B18();
				esi = esi;
				camlArray__sortto_1217();
				return;
			}
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			edx = eax + 4;
			Mem0[edx + -4:word32] = 0x08FD;
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = (ecx - 4)[eax * 0x04];
			Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			Mem0[esp + 4:word32] = edx;
l08051E20:
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			esi = eax + 4;
			Mem0[esp + 8:word32] = esi;
			Mem0[esi + -4:word32] = 0x0400;
			eax = Mem0[esp + 20:word32];
			eax = eax - 3 + edi;
			Mem0[esi + 0x00:word32] = eax;
			while (true)
			{
				ecx = Mem0[esi + 0x00:word32];
				eax = Mem0[esp + 20:word32];
				SCZO = cond(ecx - eax);
				if (Test(LT,SO))
					break;
				ecx = Mem0[esi + 0x00:word32];
				eax = Mem0[ebx + -4:word32];
				edx = eax;
				edx &= 0xFF;
				SCZO = cond(edx - 0xFE);
				if (Test(NE,Z))
				{
					eax >>= 0x09;
					SCZO = cond(eax - ecx);
					if (Test(ULE,CZ))
						goto l0805205E;
					eax = (ebx - 2)[ecx * 0x02];
				}
				else
				{
					eax >>= 0x0A;
					SCZO = cond(eax - ecx);
					if (Test(ULE,CZ))
						goto l08052059;
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x0C;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					eax += 4;
					Mem0[eax + -4:word32] = 0x08FD;
					--Top;
					ST[Top + 0x00:real64] = (ebx - 4)[ecx * 0x04];
					Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
					++Top;
				}
				ebx = Mem0[esp + 24:word32];
				ecx = Mem0[ebx + 0x0C:word32];
				ebx = Mem0[esp + 4:word32];
				caml_apply2();
				SCZO = cond(eax - 0x01);
				if (Test(LE,SZO))
					break;
				esi = Mem0[esp + 8:word32];
				ecx = Mem0[esi + 0x00:word32];
				ebx = Mem0[esp + 28:word32];
				eax = Mem0[ebx + -4:word32];
				edx = eax;
				edx &= 0xFF;
				SCZO = cond(edx - 0xFE);
				if (Test(NE,Z))
				{
					eax >>= 0x09;
					SCZO = cond(eax - ecx);
					if (Test(ULE,CZ))
						goto l08052054;
					edx = (ebx - 2)[ecx * 0x02];
				}
				else
				{
					eax >>= 0x0A;
					SCZO = cond(eax - ecx);
					if (Test(ULE,CZ))
						goto l0805204F;
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x0C;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					edx = eax + 4;
					Mem0[edx + -4:word32] = 0x08FD;
					--Top;
					ST[Top + 0x00:real64] = (ebx - 4)[ecx * 0x04];
					Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
					++Top;
				}
				eax = Mem0[esi + 0x00:word32];
				eax += 0x02;
				ecx = Mem0[ebx + -4:word32];
				edi = ecx;
				edi &= 0xFF;
				SCZO = cond(edi - 0xFE);
				if (Test(NE,Z))
				{
					ecx >>= 0x09;
					SCZO = cond(ecx - eax);
					if (Test(ULE,CZ))
						goto l0805204A;
					esp -= 4;
					Mem0[esp + 0x00:word32] = edx;
					eax = ebx - 2 + eax * 0x02;
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					caml_modify();
					esp += 0x08;
					SCZO = cond(esp);
				}
				else
				{
					ecx >>= 0x0A;
					SCZO = cond(ecx - eax);
					if (Test(ULE,CZ))
						goto l08052045;
					--Top;
					ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
					(ebx - 4)[eax * 0x04] = ST[Top + 0x00:real64];
					++Top;
				}
				v18 = Mem0[esi + 0x00:word32] + ~0x01;
				Mem0[esi + 0x00:word32] = v18;
				SCZO = cond(v18);
			}
			eax = Mem0[esp + 8:word32];
			eax = Mem0[eax + 0x00:word32];
			eax += 0x02;
			ebx = Mem0[esp + 28:word32];
			ecx = Mem0[ebx + -4:word32];
			edx = ecx;
			edx &= 0xFF;
			SCZO = cond(edx - 0xFE);
			if (Test(NE,Z))
			{
				ecx >>= 0x09;
				SCZO = cond(ecx - eax);
				if (Test(ULE,CZ))
					goto l08052040;
				ecx = Mem0[esp + 4:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				eax = ebx - 2 + eax * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				SCZO = cond(esp);
				goto l08051FF1;
			}
			ecx >>= 0x0A;
			SCZO = cond(ecx - eax);
			if (Test(ULE,CZ))
			{
				fn08070B18();
l08052040:
				fn08070B18();
l08052045:
				fn08070B18();
l0805204A:
				fn08070B18();
l0805204F:
				fn08070B18();
l08052054:
				fn08070B18();
l08052059:
				fn08070B18();
l0805205E:
				fn08070B18();
				goto l08052063;
			}
			ecx = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
			(ebx - 4)[eax * 0x04] = ST[Top + 0x00:real64];
			++Top;
l08051FF1:
			edi = Mem0[esp + 0x0C:word32];
			ecx = edi;
			edi += 0x02;
			Mem0[esp + 0x0C:word32] = edi;
			eax = Mem0[esp + 16:word32];
			SCZO = cond(ecx - eax);
		} while (Test(NE,Z));
	}
	eax = 0x01;
	esp += 0x28;
	SCZO = cond(esp);
}

// 08052070: define camlArray__sortto_1217
// Called from:
//      camlArray__sortto_1217
//      camlArray__stable_sort_1188
define camlArray__sortto_1217
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(edx - 11);
	if (Test(GT,SZO))
	{
		Mem0[esp + 0x00:word32] = esi;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 20:word32] = ebx;
		Mem0[esp + 16:word32] = eax;
		esi = edx;
		esi >>= 0x01;
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(LT,SO))
		{
			++esi;
			SCZO = cond(esi);
		}
		esi >>= 0x01;
		esi = esi + 1 + esi;
		Mem0[esp + 4:word32] = esi;
		edx -= esi;
		SCZO = cond(edx);
		++edx;
		SZO = cond(edx);
		Mem0[esp + 0x0C:word32] = edx;
		ecx = ecx - 1 + esi;
		eax = eax - 1 + esi;
		edx = Mem0[esp + 0x0C:word32];
		esi = Mem0[esp + 0x00:word32];
		camlArray__sortto_1217();
		ebx = Mem0[esp + 0x0C:word32];
		eax = Mem0[esp + 16:word32];
		ecx = eax - 1 + ebx;
		esi = Mem0[esp + 0x00:word32];
		ebx = Mem0[esi + 0x0C:word32];
		edx = Mem0[esp + 4:word32];
		camlArray__sortto_1217();
		eax = Mem0[esp + 0x00:word32];
		eax = Mem0[eax + 16:word32];
		Mem0[esp + 0x00:word32] = eax;
		ebx = Mem0[esp + 4:word32];
		ebp = Mem0[esp + 8:word32];
		edx = ebp - 1 + ebx;
		esi = Mem0[esp + 0x0C:word32];
		eax = Mem0[esp + 16:word32];
		eax = eax - 1 + esi;
		ecx = Mem0[esp + 20:word32];
		edi = ecx;
		Mem0[0x0807D0BC<p32>:word32] = ebp;
		ebp = Mem0[esp + 0x00:word32];
		Mem0[0x0807D0C0<p32>:word32] = ebp;
		esp += 0x18;
		SCZO = cond(esp);
		camlArray__merge_1191();
	}
	else
	{
		esi = Mem0[esi + 20:word32];
		esp += 0x18;
		SCZO = cond(esp);
		camlArray__isortto_1209();
	}
}

// 08052130: define camlArray__init_1037
define camlArray__init_1037
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x01;
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[esp + 4:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080683F9;
		fn080709D8();
		esp += 0x08;
		ebx = eax;
		esi = 0x03;
		eax = Mem0[esp + 0x00:word32];
		eax += ~0x01;
		SCZO = cond(esi - eax);
		if (Test(LE,SZO))
		{
			Mem0[esp + 8:word32] = eax;
			Mem0[esp + 0x0C:word32] = esi;
			Mem0[esp + 0x00:word32] = ebx;
			do
			{
				ebx = Mem0[esp + 4:word32];
				ecx = Mem0[ebx + 0x00:word32];
				eax = esi;
				ecx();
				ebx = Mem0[esp + 0x00:word32];
				ecx = CONVERT(Mem0[ebx + -4:byte], byte, word32);
				SCZO = cond(ecx - 0xFE);
				if (Test(NE,Z))
				{
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					esi = Mem0[esp + 16:word32];
					eax = ebx - 2 + esi * 0x02;
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					caml_modify();
					esp += 0x08;
					SCZO = cond(esp);
				}
				else
				{
					--Top;
					ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
					esi = Mem0[esp + 0x0C:word32];
					(ebx - 4)[esi * 0x04] = ST[Top + 0x00:real64];
					++Top;
				}
				ecx = esi;
				esi += 0x02;
				Mem0[esp + 0x0C:word32] = esi;
				eax = Mem0[esp + 8:word32];
				SCZO = cond(ecx - eax);
			} while (Test(NE,Z));
		}
		eax = ebx;
		esp += 0x18;
		SCZO = cond(esp);
	}
	else
	{
		eax = 0x08077E4C;
		esp += 0x18;
		SCZO = cond(esp);
	}
}

// 080521F0: define camlArray__make_matrix_1042
define camlArray__make_matrix_1042
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 4:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x08077E48;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	ebx = eax;
	ecx = 0x01;
	eax = Mem0[esp + 0x00:word32];
	eax += ~0x01;
	SCZO = cond(ecx - eax);
	if (Test(LE,SZO))
	{
		Mem0[esp + 16:word32] = eax;
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 0x0C:word32] = ebx;
		do
		{
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = 0x080683F9;
			fn080709D8();
			esp += 0x08;
			SCZO = cond(esp);
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			esi = Mem0[esp + 4:word32];
			ebx = Mem0[esp + 16:word32];
			eax = ebx - 2 + esi * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			ecx = esi;
			esi += 0x02;
			Mem0[esp + 0x00:word32] = esi;
			eax = Mem0[esp + 16:word32];
			SCZO = cond(ecx - eax);
		} while (Test(NE,Z));
	}
	eax = ebx;
	esp += 0x14;
	SCZO = cond(esp);
}

// 08052270: define camlArray__copy_1049
// Called from:
//      camlHashtbl__copy_1057
define camlArray__copy_1049
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	ebx = eax;
	ecx = Mem0[ebx + -4:word32];
	eax = ecx;
	eax &= 0xFF;
	SCZO = cond(eax - 0xFE);
	if (Test(NE,Z))
	{
		ecx >>= 0x09;
		SCZO = cond(ecx);
	}
	else
	{
		ecx >>= 0x0A;
		SCZO = cond(ecx);
	}
	ecx |= 0x01;
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 4:word32] = ebx;
		eax = CONVERT(Mem0[ebx + -4:byte], byte, word32);
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
			eax = Mem0[ebx + 0x00:word32];
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ecx;
		eax = 0x080683F9;
		fn080709D8();
		esp += 0x08;
		esi = eax;
		ebx = 0x03;
		edi = Mem0[esp + 0x00:word32];
		edi += ~0x01;
		SCZO = cond(ebx - edi);
		if (Test(LE,SZO))
		{
			do
			{
				ecx = Mem0[esp + 4:word32];
				eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
				SCZO = cond(eax - 0xFE);
				if (Test(NE,Z))
					edx = (ecx - 2)[ebx * 0x02];
				else
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x0C;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					edx = eax + 4;
					Mem0[edx + -4:word32] = 0x08FD;
					--Top;
					ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
					Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
					++Top;
				}
				eax = CONVERT(Mem0[esi + -4:byte], byte, word32);
				SCZO = cond(eax - 0xFE);
				if (Test(NE,Z))
				{
					esp -= 4;
					Mem0[esp + 0x00:word32] = edx;
					eax = esi - 2 + ebx * 0x02;
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					caml_modify();
					esp += 0x08;
					SCZO = cond(esp);
				}
				else
				{
					--Top;
					ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
					(esi - 4)[ebx * 0x04] = ST[Top + 0x00:real64];
					++Top;
				}
				eax = ebx;
				ebx += 0x02;
				SCZO = cond(eax - edi);
			} while (Test(NE,Z));
		}
		eax = esi;
		esp += 0x10;
		SCZO = cond(esp);
	}
	else
	{
		eax = 0x08077E44;
		esp += 0x10;
		SCZO = cond(esp);
	}
}

// 080523A0: define camlArray__append_1054
define camlArray__append_1054
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	edx = Mem0[eax + -4:word32];
	ecx = edx;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		edx >>= 0x09;
		SCZO = cond(edx);
	}
	else
	{
		edx >>= 0x0A;
		SCZO = cond(edx);
	}
	edx |= 0x01;
	ecx = Mem0[ebx + -4:word32];
	esi = ecx;
	esi &= 0xFF;
	SCZO = cond(esi - 0xFE);
	if (Test(NE,Z))
	{
		ecx >>= 0x09;
		SCZO = cond(ecx);
	}
	else
	{
		ecx >>= 0x0A;
		SCZO = cond(ecx);
	}
	ecx |= 0x01;
	SCZO = cond(edx - 0x01);
	if (Test(EQ,Z))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x08077E40;
			esp += 0x18;
			SCZO = cond(esp);
			return;
		}
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 0x0C:word32] = eax;
	}
	else
	{
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 0x0C:word32] = eax;
	}
	SCZO = cond(edx - 0x01);
	if (Test(GT,SZO))
		ebx = eax;
	esi = CONVERT(Mem0[ebx + -4:byte], byte, word32);
	SCZO = cond(esi - 0xFE);
	if (Test(NE,Z))
		esi = Mem0[ebx + 0x00:word32];
	else
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		esi = eax + 4;
		Mem0[esi + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
		Mem0[esi + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	eax = edx - 1 + ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	esi = eax;
	ebx = 0x01;
	edi = Mem0[esp + 8:word32];
	edi += ~0x01;
	SCZO = cond(ebx - edi);
	if (Test(LE,SZO))
	{
		do
		{
			ecx = Mem0[esp + 0x0C:word32];
			eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
				edx = (ecx - 2)[ebx * 0x02];
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				edx = eax + 4;
				Mem0[edx + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
				Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			eax = CONVERT(Mem0[esi + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				eax = esi - 2 + ebx * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				SCZO = cond(esp);
			}
			else
			{
				--Top;
				ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
				(esi - 4)[ebx * 0x04] = ST[Top + 0x00:real64];
				++Top;
			}
			eax = ebx;
			ebx += 0x02;
			SCZO = cond(eax - edi);
		} while (Test(NE,Z));
	}
	ebx = 0x01;
	eax = Mem0[esp + 0x00:word32];
	eax += ~0x01;
	SCZO = cond(ebx - eax);
	if (Test(LE,SZO))
	{
		Mem0[esp + 0x00:word32] = eax;
		do
		{
			ecx = Mem0[esp + 4:word32];
			eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
				edx = (ecx - 2)[ebx * 0x02];
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				edx = eax + 4;
				Mem0[edx + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
				Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			eax = Mem0[esp + 8:word32];
			ecx = ebx - 1 + eax;
			eax = CONVERT(Mem0[esi + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				eax = esi - 2 + ecx * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				SCZO = cond(esp);
			}
			else
			{
				--Top;
				ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
				(esi - 4)[ecx * 0x04] = ST[Top + 0x00:real64];
				++Top;
			}
			ecx = ebx;
			ebx += 0x02;
			eax = Mem0[esp + 0x00:word32];
			SCZO = cond(ecx - eax);
		} while (Test(NE,Z));
	}
	eax = esi;
	esp += 0x18;
	SCZO = cond(esp);
}

// 080525E0: define camlArray__concat_aux_1062
// Called from:
//      camlArray__find_init_1077
define camlArray__concat_aux_1062
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = ebx;
	eax = 0x01;
	camlArray__size_1065();
	ebx = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	ebx = eax;
	Mem0[esp + 0x00:word32] = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x08050E40;
	Mem0[ecx + 0x0C:word32] = ebx;
	eax = 0x01;
	ebx = Mem0[esp + 4:word32];
	camlArray__fill_1070();
	eax = Mem0[esp + 0x00:word32];
	esp += 0x08;
	SCZO = cond(esp);
}

// 08052670: define camlArray__concat_1075
define camlArray__concat_1075
{
	esp = fp;
	Top = 0;
	ebx = 0x08077DD0;
	camlArray__find_init_1077();
}

// 08052680: define camlArray__sub_1081
define camlArray__sub_1081
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	edx = eax;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[edx + -4:word32];
			eax = esi;
			eax &= 0xFF;
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
			{
				eax = esi;
				eax >>= 0x09;
				SCZO = cond(eax);
			}
			else
			{
				eax = esi;
				eax >>= 0x0A;
				SCZO = cond(eax);
			}
			eax |= 0x01;
			eax -= ecx;
			++eax;
			SCZO = cond(ebx - eax);
			if (Test(LE,SZO))
			{
				SCZO = cond(ecx - 0x01);
				if (Test(NE,Z))
				{
					Mem0[esp + 0x00:word32] = ecx;
					Mem0[esp + 4:word32] = ebx;
					Mem0[esp + 8:word32] = edx;
					eax = CONVERT(Mem0[edx + -4:byte], byte, word32);
					SCZO = cond(eax - 0xFE);
					if (Test(NE,Z))
						eax = (edx - 2)[ebx * 0x02];
					else
					{
						while (true)
						{
							eax = Mem0[0x08080414<p32>:word32];
							eax -= 0x0C;
							Mem0[0x08080414<p32>:word32] = eax;
							SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
							if (Test(UGE,C))
								break;
							fn080708CC();
						}
						eax += 4;
						Mem0[eax + -4:word32] = 0x08FD;
						--Top;
						ST[Top + 0x00:real64] = (edx - 4)[ebx * 0x04];
						Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
						++Top;
					}
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					esp -= 4;
					Mem0[esp + 0x00:word32] = ecx;
					eax = 0x080683F9;
					fn080709D8();
					esp += 0x08;
					esi = eax;
					ebx = 0x03;
					eax = Mem0[esp + 0x00:word32];
					eax += ~0x01;
					SCZO = cond(ebx - eax);
					if (Test(LE,SZO))
					{
						Mem0[esp + 0x0C:word32] = eax;
						Mem0[esp + 0x00:word32] = esi;
						do
						{
							eax = Mem0[esp + 4:word32];
							edx = eax - 1 + ebx;
							ecx = Mem0[esp + 8:word32];
							eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
							SCZO = cond(eax - 0xFE);
							if (Test(NE,Z))
								ecx = (ecx - 2)[edx * 0x02];
							else
							{
								while (true)
								{
									eax = Mem0[0x08080414<p32>:word32];
									eax -= 0x0C;
									Mem0[0x08080414<p32>:word32] = eax;
									SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
									if (Test(UGE,C))
										break;
									fn080708CC();
								}
								eax += 4;
								Mem0[eax + -4:word32] = 0x08FD;
								--Top;
								ST[Top + 0x00:real64] = (ecx - 4)[edx * 0x04];
								Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
								++Top;
								ecx = eax;
							}
							esi = Mem0[esp + 0x00:word32];
							eax = CONVERT(Mem0[esi + -4:byte], byte, word32);
							SCZO = cond(eax - 0xFE);
							if (Test(NE,Z))
							{
								esp -= 4;
								Mem0[esp + 0x00:word32] = ecx;
								eax = esi - 2 + ebx * 0x02;
								esp -= 4;
								Mem0[esp + 0x00:word32] = eax;
								caml_modify();
								esp += 0x08;
								SCZO = cond(esp);
							}
							else
							{
								--Top;
								ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
								(esi - 4)[ebx * 0x04] = ST[Top + 0x00:real64];
								++Top;
							}
							ecx = ebx;
							eax = ebx;
							eax += 0x02;
							ebx = eax;
							eax = Mem0[esp + 0x0C:word32];
							SCZO = cond(ecx - eax);
						} while (Test(NE,Z));
					}
					eax = esi;
					esp += 0x18;
					SCZO = cond(esp);
					return;
				}
				else
				{
					eax = 0x08077E3C;
					esp += 0x18;
					SCZO = cond(esp);
					return;
				}
			}
		}
	}
	eax = 0x08077E2C;
	esp += 0x18;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 08052830: define camlArray__fill_1087
define camlArray__fill_1087
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	esi = eax;
	edi = edx;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(GE,SO))
		{
			edx = Mem0[esi + -4:word32];
			eax = edx;
			eax &= 0xFF;
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
			{
				eax = edx;
				eax >>= 0x09;
				SCZO = cond(eax);
			}
			else
			{
				eax = edx;
				eax >>= 0x0A;
				SCZO = cond(eax);
			}
			eax |= 0x01;
			eax -= ecx;
			++eax;
			SCZO = cond(ebx - eax);
			if (Test(LE,SZO))
			{
				ebp = ebx;
				ebx = ebx - 3 + ecx;
				SCZO = cond(ebp - ebx);
				if (Test(LE,SZO))
				{
					do
					{
						eax = CONVERT(Mem0[esi + -4:byte], byte, word32);
						SCZO = cond(eax - 0xFE);
						if (Test(NE,Z))
						{
							esp -= 4;
							Mem0[esp + 0x00:word32] = edi;
							eax = esi - 2 + ebp * 0x02;
							esp -= 4;
							Mem0[esp + 0x00:word32] = eax;
							caml_modify();
							esp += 0x08;
							SCZO = cond(esp);
						}
						else
						{
							--Top;
							ST[Top + 0x00:real64] = Mem0[edi + 0x00:real64];
							(esi - 4)[ebp * 0x04] = ST[Top + 0x00:real64];
							++Top;
						}
						ecx = ebp;
						eax = ebp;
						eax += 0x02;
						ebp = eax;
						SCZO = cond(ecx - ebx);
					} while (Test(NE,Z));
				}
				eax = 0x01;
				esp += 0x08;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x08077E1C;
	esp += 0x08;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 080528D0: define camlArray__blit_1093
// Called from:
//      camlSource__sortto_1060
//      fn0804BE02
//      camlArray__sortto_1217
define camlArray__blit_1093
{
	ptr32 fp;
	word32 eax;
	word32 ecx;
	word32 edx;
	word32 esi;
	word32 ebx;
	word32 dwLoc1C;
	bool P;
	edi_6 = eax;
	ebp_10 = edx;
	if (esi >= 0x01 && ebx >= 0x01)
	{
		ecx_17 = Mem8[eax + -4:word32];
		if ((ecx_17 & 0xFF) != 0xFE)
			eax_26 = ecx_17 >>u 0x09;
		else
			eax_23 = ecx_17 >>u 0x0A;
		eax_28 = ϕ(eax_26, eax_23);
		eax_29 = eax_28 | 0x01;
		eax_31 = eax_29 - esi;
		if (ebx <= eax_31 + 0x01 && edx >= 0x01)
		{
			ecx_42 = Mem8[ecx + -4:word32];
			if ((ecx_42 & 0xFF) != 0xFE)
				eax_51 = ecx_42 >>u 0x09;
			else
				eax_48 = ecx_42 >>u 0x0A;
			eax_53 = ϕ(eax_51, eax_48);
			eax_54 = eax_53 | 0x01;
			eax_56 = eax_54 - esi;
			if (edx <= eax_56 + 0x01)
			{
				if (ebx >= edx)
				{
					dwLoc0C_260 = 0x01;
					esi_71 = esi + ~0x01;
					if (esi >= 0x03)
					{
						do
						{
							P_373 = ϕ(P, P_371);
							edx_349 = ϕ(edx, edx_347);
							dwLoc1C_294 = ϕ(dwLoc1C, dwLoc1C_298);
							dwLoc0C_264 = ϕ(dwLoc0C_260, dwLoc0C_278);
							Mem79 = ϕ(Mem77, Mem152);
							ebx_82 = ebx - 1 + dwLoc0C_264;
							ecx_84 = CONVERT(Mem79[eax + -4:byte], byte, word32);
							if (ecx_84 != 0xFE)
								ebx_111 = (eax - 2)[ebx_82 * 0x02];
							else
							{
								while (true)
								{
									P_374 = ϕ(P_373, P_99);
									Mem87 = ϕ(Mem79, Mem90);
									eax_88 = Mem87[0x08080414<p32>:word32];
									Mem90[0x08080414<p32>:word32] = eax_88 - 0x0C;
									if (eax_88 - 0x0C >=u Mem90[0x08080418<p32>:word32])
										break;
									fn080708CC();
								}
								Mem101[eax_88 + -0x0C:word32] = 0x08FD;
								rLoc1_268 = (eax - 4)[ebx_82 * 0x04];
								Mem108[eax_88 + -8:real64] = rLoc1_268;
								ebx_110 = eax_88 - 0x08;
							}
							P_372 = ϕ(P_373, P_374);
							ebx_126 = ϕ(ebx_111, ebx_110);
							Mem113 = ϕ(Mem79, Mem108);
							eax_119 = edx - 1 + dwLoc0C_264;
							ecx_121 = CONVERT(Mem113[ecx + -4:byte], byte, word32);
							if (ecx_121 != 0xFE)
							{
								dwLoc1C_275 = ebx_126;
								eax_134 = ecx - 2 + eax_119 * 0x02;
								caml_modify();
							}
							else
							{
								rLoc1_274 = Mem113[ebx_126 + 0x00:real64];
								(ecx - 4)[eax_119 * 0x04] = rLoc1_274;
							}
							P_371 = ϕ(P_144, P_372);
							edx_347 = ϕ(edx_138, edx_349);
							ecx_327 = ϕ(ecx_139, ecx_121);
							dwLoc1C_298 = ϕ(dwLoc1C_275, dwLoc1C_294);
							ebx_149 = dwLoc0C_264;
							dwLoc0C_278 = dwLoc0C_264 + 0x02;
						} while (dwLoc0C_264 != esi + ~0x01);
					}
					P_370 = ϕ(P, P_371);
					edx_346 = ϕ(edx, edx_347);
					ecx_326 = ϕ(ecx_42, ecx_327);
					ebx_320 = ϕ(ebx, ebx_149);
					eax_159 = 0x01;
					SCZO_162 = cond(fp);
					C_311 = SLICE(SCZO_162, bool, 1);
					O_359 = SLICE(SCZO_162, bool, 4);
					S_391 = SLICE(SCZO_162, bool, 0);
					Z_399 = SLICE(SCZO_162, bool, 2);
					return;
				}
				else
				{
					esi_163 = esi + ~0x01;
					if (esi >= 0x03)
					{
						do
						{
							P_368 = ϕ(P, P_366);
							edx_344 = ϕ(edx, edx_342);
							dwLoc1C_305 = ϕ(dwLoc1C, dwLoc1C_306);
							esi_170 = ϕ(esi_163, esi_241);
							Mem168 = ϕ(Mem166, Mem253);
							ebx_171 = ebx - 1 + esi_170;
							eax_173 = CONVERT(Mem168[eax + -4:byte], byte, word32);
							if (eax_173 != 0xFE)
								ebx_200 = (eax - 2)[ebx_171 * 0x02];
							else
							{
								while (true)
								{
									P_369 = ϕ(P_368, P_188);
									Mem176 = ϕ(Mem168, Mem179);
									eax_177 = Mem176[0x08080414<p32>:word32];
									Mem179[0x08080414<p32>:word32] = eax_177 - 0x0C;
									if (eax_177 - 0x0C >=u Mem179[0x08080418<p32>:word32])
										break;
									fn080708CC();
								}
								Mem190[eax_177 + -0x0C:word32] = 0x08FD;
								rLoc1_282 = (eax - 4)[ebx_171 * 0x04];
								Mem197[eax_177 + -8:real64] = rLoc1_282;
								ebx_199 = eax_177 - 0x08;
							}
							P_367 = ϕ(P_368, P_369);
							ebx_216 = ϕ(ebx_200, ebx_199);
							Mem209 = ϕ(Mem168, Mem197);
							eax_207 = edx - 1 + esi_170;
							ecx_211 = CONVERT(Mem209[ecx + -4:byte], byte, word32);
							if (ecx_211 != 0xFE)
							{
								dwLoc1C_287 = ebx_216;
								eax_224 = ecx - 2 + eax_207 * 0x02;
								caml_modify();
							}
							else
							{
								rLoc1_286 = Mem209[ebx_216 + 0x00:real64];
								(ecx - 4)[eax_207 * 0x04] = rLoc1_286;
							}
							P_366 = ϕ(P_234, P_367);
							edx_342 = ϕ(edx_228, edx_344);
							ecx_325 = ϕ(ecx_229, ecx_211);
							dwLoc1C_306 = ϕ(dwLoc1C_287, dwLoc1C_305);
							Mem253 = ϕ(Mem226, Mem219);
							ebx_238 = esi_170;
							eax_240 = esi_170 - 0x02;
							esi_241 = eax_240;
						} while (esi_170 != 0x01);
					}
					P_362 = ϕ(P, P_366);
					esi_353 = ϕ(esi_163, esi_241);
					edx_339 = ϕ(edx, edx_342);
					ecx_323 = ϕ(ecx_42, ecx_325);
					ebx_319 = ϕ(ebx, ebx_238);
					eax_244 = 0x01;
					SCZO_248 = cond(fp);
					C_310 = SLICE(SCZO_248, bool, 1);
					O_358 = SLICE(SCZO_248, bool, 4);
					S_390 = SLICE(SCZO_248, bool, 0);
					Z_398 = SLICE(SCZO_248, bool, 2);
					return;
				}
			}
		}
	}
	ecx_328 = ϕ(ecx, ecx, ecx_17, ecx_17, ecx_42);
	eax_61 = 0x08077E0C;
	SCZO_65 = cond(fp);
	C_312 = SLICE(SCZO_65, bool, 1);
	O_360 = SLICE(SCZO_65, bool, 4);
	S_392 = SLICE(SCZO_65, bool, 0);
	Z_400 = SLICE(SCZO_65, bool, 2);
	camlPervasives__invalid_arg_1012();
}

// 08052B30: define camlArray__iter_1101
define camlArray__iter_1101
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	ecx = 0x01;
	edx = Mem0[ebx + -4:word32];
	esi = edx;
	esi &= 0xFF;
	SCZO = cond(esi - 0xFE);
	if (Test(NE,Z))
	{
		edx >>= 0x09;
		SCZO = cond(edx);
	}
	else
	{
		edx >>= 0x0A;
		SCZO = cond(edx);
	}
	edx |= 0x01;
	edx += ~0x01;
	SCZO = cond(ecx - edx);
	if (Test(LE,SZO))
	{
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 4:word32] = eax;
		do
		{
			ebx = Mem0[esp + 0x00:word32];
			eax = CONVERT(Mem0[ebx + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
				eax = (ebx - 2)[ecx * 0x02];
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (ebx - 4)[ecx * 0x04];
				Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			ebx = Mem0[esp + 4:word32];
			ecx = Mem0[ebx + 0x00:word32];
			ecx();
			ecx = Mem0[esp + 8:word32];
			ebx = ecx;
			ecx += 0x02;
			Mem0[esp + 8:word32] = ecx;
			eax = Mem0[esp + 0x0C:word32];
			SCZO = cond(ebx - eax);
		} while (Test(NE,Z));
	}
	eax = 0x01;
	esp += 0x18;
	SCZO = cond(esp);
}

// 08052BE0: define camlArray__map_1105
define camlArray__map_1105
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	ecx = eax;
	eax = Mem0[ebx + -4:word32];
	edx = eax;
	edx &= 0xFF;
	SCZO = cond(edx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax);
	}
	eax |= 0x01;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 8:word32] = ecx;
		eax = CONVERT(Mem0[ebx + -4:byte], byte, word32);
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
			eax = Mem0[ebx + 0x00:word32];
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
		}
		edx = Mem0[ecx + 0x00:word32];
		ebx = ecx;
		edx();
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[esp + 4:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080683F9;
		fn080709D8();
		esp += 0x08;
		esi = eax;
		ebx = 0x03;
		eax = Mem0[esp + 0x00:word32];
		eax += ~0x01;
		SCZO = cond(ebx - eax);
		if (Test(LE,SZO))
		{
			Mem0[esp + 0x0C:word32] = eax;
			Mem0[esp + 16:word32] = ebx;
			Mem0[esp + 0x00:word32] = esi;
			do
			{
				ecx = Mem0[esp + 4:word32];
				eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
				SCZO = cond(eax - 0xFE);
				if (Test(NE,Z))
					eax = (ecx - 2)[ebx * 0x02];
				else
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x0C;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					eax += 4;
					Mem0[eax + -4:word32] = 0x08FD;
					--Top;
					ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
					Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
					++Top;
				}
				ebx = Mem0[esp + 8:word32];
				ecx = Mem0[ebx + 0x00:word32];
				ecx();
				esi = Mem0[esp + 0x00:word32];
				ebx = CONVERT(Mem0[esi + -4:byte], byte, word32);
				SCZO = cond(ebx - 0xFE);
				if (Test(NE,Z))
				{
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					ebx = Mem0[esp + 20:word32];
					eax = esi - 2 + ebx * 0x02;
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					caml_modify();
					esp += 0x08;
					SCZO = cond(esp);
				}
				else
				{
					--Top;
					ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
					ebx = Mem0[esp + 16:word32];
					(esi - 4)[ebx * 0x04] = ST[Top + 0x00:real64];
					++Top;
				}
				ecx = ebx;
				ebx += 0x02;
				Mem0[esp + 16:word32] = ebx;
				eax = Mem0[esp + 0x0C:word32];
				SCZO = cond(ecx - eax);
			} while (Test(NE,Z));
		}
		eax = esi;
		esp += 0x1C;
		SCZO = cond(esp);
	}
	else
	{
		eax = 0x08077E08;
		esp += 0x1C;
		SCZO = cond(esp);
	}
}

// 08052D50: define camlArray__iteri_1111
define camlArray__iteri_1111
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	ecx = 0x01;
	edx = Mem0[ebx + -4:word32];
	esi = edx;
	esi &= 0xFF;
	SCZO = cond(esi - 0xFE);
	if (Test(NE,Z))
	{
		edx >>= 0x09;
		SCZO = cond(edx);
	}
	else
	{
		edx >>= 0x0A;
		SCZO = cond(edx);
	}
	edx |= 0x01;
	edx += ~0x01;
	SCZO = cond(ecx - edx);
	if (Test(LE,SZO))
	{
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 4:word32] = eax;
		do
		{
			edx = Mem0[esp + 0x00:word32];
			eax = CONVERT(Mem0[edx + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
				ebx = (edx - 2)[ecx * 0x02];
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				ebx = eax + 4;
				Mem0[ebx + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (edx - 4)[ecx * 0x04];
				Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			eax = ecx;
			ecx = Mem0[esp + 4:word32];
			caml_apply2();
			ecx = Mem0[esp + 8:word32];
			ebx = ecx;
			ecx += 0x02;
			Mem0[esp + 8:word32] = ecx;
			eax = Mem0[esp + 0x0C:word32];
			SCZO = cond(ebx - eax);
		} while (Test(NE,Z));
	}
	eax = 0x01;
	esp += 0x18;
	SCZO = cond(esp);
}

// 08052E00: define camlArray__mapi_1115
define camlArray__mapi_1115
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	ecx = eax;
	eax = Mem0[ebx + -4:word32];
	edx = eax;
	edx &= 0xFF;
	SCZO = cond(edx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax);
	}
	eax |= 0x01;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 8:word32] = ecx;
		eax = CONVERT(Mem0[ebx + -4:byte], byte, word32);
		SCZO = cond(eax - 0xFE);
		if (Test(NE,Z))
			ebx = Mem0[ebx + 0x00:word32];
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			edx = eax + 4;
			Mem0[edx + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
			Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			ebx = edx;
		}
		eax = 0x01;
		caml_apply2();
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[esp + 4:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080683F9;
		fn080709D8();
		esp += 0x08;
		ebx = eax;
		esi = 0x03;
		eax = Mem0[esp + 0x00:word32];
		eax += ~0x01;
		SCZO = cond(esi - eax);
		if (Test(LE,SZO))
		{
			Mem0[esp + 0x0C:word32] = eax;
			Mem0[esp + 16:word32] = esi;
			Mem0[esp + 0x00:word32] = ebx;
			do
			{
				ecx = Mem0[esp + 4:word32];
				eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
				SCZO = cond(eax - 0xFE);
				if (Test(NE,Z))
					ebx = (ecx - 2)[esi * 0x02];
				else
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x0C;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					ebx = eax + 4;
					Mem0[ebx + -4:word32] = 0x08FD;
					--Top;
					ST[Top + 0x00:real64] = (ecx - 4)[esi * 0x04];
					Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
					++Top;
				}
				eax = esi;
				ecx = Mem0[esp + 8:word32];
				caml_apply2();
				ebx = Mem0[esp + 0x00:word32];
				ecx = CONVERT(Mem0[ebx + -4:byte], byte, word32);
				SCZO = cond(ecx - 0xFE);
				if (Test(NE,Z))
				{
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					esi = Mem0[esp + 20:word32];
					eax = ebx - 2 + esi * 0x02;
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					caml_modify();
					esp += 0x08;
					SCZO = cond(esp);
				}
				else
				{
					--Top;
					ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
					esi = Mem0[esp + 16:word32];
					(ebx - 4)[esi * 0x04] = ST[Top + 0x00:real64];
					++Top;
				}
				ecx = esi;
				esi += 0x02;
				Mem0[esp + 16:word32] = esi;
				eax = Mem0[esp + 0x0C:word32];
				SCZO = cond(ecx - eax);
			} while (Test(NE,Z));
		}
		eax = ebx;
		esp += 0x1C;
		SCZO = cond(esp);
	}
	else
	{
		eax = 0x08077E04;
		esp += 0x1C;
		SCZO = cond(esp);
	}
}

// 08052F80: define camlArray__to_list_1121
// Called from:
//      fn0804D330
define camlArray__to_list_1121
{
	esp = fp;
	Top = 0;
	ebx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x08051010;
	Mem0[ecx + 0x0C:word32] = ebx;
	eax = Mem0[ebx + -4:word32];
	ebx = eax;
	ebx &= 0xFF;
	SCZO = cond(ebx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax);
	}
	eax |= 0x01;
	eax += ~0x01;
	SCZO = cond(eax);
	ebx = 0x01;
	camlArray__tolist_1123();
}

// 08052FF0: define camlArray__list_length_1126
// Called from:
//      camlArray__of_list_1130
define camlArray__list_length_1126
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		ebx = Mem0[ebx + 4:word32];
		eax += 0x02;
		SCZO = cond(eax);
	}
}

// 08053010: define camlArray__of_list_1130
define camlArray__of_list_1130
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	ebx = eax;
	SCZO = cond(ebx - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x08077E00;
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x01;
		camlArray__list_length_1126();
		ebx = Mem0[esp + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080683F9;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(esp);
		ebx = eax;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x14;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ecx = eax + 4;
		Mem0[ecx + -4:word32] = 4343;
		Mem0[ecx + 0x00:word32] = 0x0804B370;
		Mem0[ecx + 4:word32] = 0x05;
		Mem0[ecx + 8:word32] = 0x080510A0;
		Mem0[ecx + 0x0C:word32] = ebx;
		eax = 0x03;
		ebx = Mem0[esp + 4:word32];
		esp += 0x08;
		SCZO = cond(esp);
		camlArray__fill_1135();
	}
}

// 080530A0: define camlArray__fold_left_1139
define camlArray__fold_left_1139
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	edi = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	esi = eax + 4;
	Mem0[esi + -4:word32] = 0x0400;
	Mem0[esi + 0x00:word32] = ebx;
	edx = 0x01;
	eax = Mem0[ecx + -4:word32];
	ebx = eax;
	ebx &= 0xFF;
	SCZO = cond(ebx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax);
	}
	eax |= 0x01;
	eax += ~0x01;
	SCZO = cond(edx - eax);
	if (Test(LE,SZO))
	{
		Mem0[esp + 16:word32] = eax;
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 8:word32] = esi;
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 4:word32] = edi;
		do
		{
			ecx = Mem0[esp + 0x00:word32];
			eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
				ebx = (ecx - 2)[edx * 0x02];
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				ebx = eax + 4;
				Mem0[ebx + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (ecx - 4)[edx * 0x04];
				Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			eax = Mem0[esi + 0x00:word32];
			ecx = Mem0[esp + 4:word32];
			caml_apply2();
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			esi = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = esi;
			caml_modify();
			esp += 0x08;
			edx = Mem0[esp + 0x0C:word32];
			ebx = edx;
			edx += 0x02;
			Mem0[esp + 0x0C:word32] = edx;
			eax = Mem0[esp + 16:word32];
			SCZO = cond(ebx - eax);
		} while (Test(NE,Z));
	}
	eax = Mem0[esi + 0x00:word32];
	esp += 0x1C;
	SCZO = cond(esp);
}

// 080531A0: define camlArray__fold_right_1145
define camlArray__fold_right_1145
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	esi = eax + 4;
	Mem0[esi + -4:word32] = 0x0400;
	Mem0[esi + 0x00:word32] = ecx;
	ecx = Mem0[ebx + -4:word32];
	eax = ecx;
	eax &= 0xFF;
	SCZO = cond(eax - 0xFE);
	if (Test(NE,Z))
	{
		ecx >>= 0x09;
		SCZO = cond(ecx);
	}
	else
	{
		ecx >>= 0x0A;
		SCZO = cond(ecx);
	}
	ecx |= 0x01;
	ecx += ~0x01;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		Mem0[esp + 0x0C:word32] = ecx;
		Mem0[esp + 8:word32] = esi;
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 4:word32] = edx;
		do
		{
			ebx = Mem0[esp + 0x00:word32];
			eax = CONVERT(Mem0[ebx + -4:byte], byte, word32);
			SCZO = cond(eax - 0xFE);
			if (Test(NE,Z))
				eax = (ebx - 2)[ecx * 0x02];
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (ebx - 4)[ecx * 0x04];
				Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			ebx = Mem0[esi + 0x00:word32];
			ecx = Mem0[esp + 4:word32];
			caml_apply2();
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			esi = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = esi;
			caml_modify();
			esp += 0x08;
			ecx = Mem0[esp + 0x0C:word32];
			eax = ecx;
			ecx -= 0x02;
			Mem0[esp + 0x0C:word32] = ecx;
			SCZO = cond(eax - 0x01);
		} while (Test(NE,Z));
	}
	eax = Mem0[esi + 0x00:word32];
	esp += 0x18;
	SCZO = cond(esp);
}

// 08053290: define camlArray__sort_1152
define camlArray__sort_1152
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 16:word32] = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x90;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	esi = eax + 4;
	Mem0[esi + -4:word32] = 0x14F7;
	Mem0[esi + 0x00:word32] = 0x0804B370;
	Mem0[esi + 4:word32] = 0x05;
	Mem0[esi + 8:word32] = 0x08051100;
	Mem0[esi + 0x0C:word32] = ecx;
	Mem0[esi + 16:word32] = ebx;
	edx = esi + 24;
	Mem0[edx + -4:word32] = 0x18F7;
	Mem0[edx + 0x00:word32] = 0x0804B2D0;
	Mem0[edx + 4:word32] = 0x07;
	Mem0[edx + 8:word32] = 0x080514F0;
	Mem0[edx + 0x0C:word32] = ecx;
	Mem0[edx + 16:word32] = ebx;
	Mem0[edx + 20:word32] = esi;
	eax = esi + 52;
	Mem0[esp + 4:word32] = eax;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x0804B2D0;
	Mem0[eax + 4:word32] = 0x07;
	Mem0[eax + 8:word32] = 0x08051700;
	Mem0[eax + 0x0C:word32] = ebx;
	Mem0[eax + 16:word32] = edx;
	edx = esi + 76;
	Mem0[edx + -4:word32] = 0x14F7;
	Mem0[edx + 0x00:word32] = 0x0804B370;
	Mem0[edx + 4:word32] = 0x05;
	Mem0[edx + 8:word32] = 134551488;
	Mem0[edx + 0x0C:word32] = ebx;
	Mem0[edx + 16:word32] = esi;
	eax = esi + 100;
	Mem0[esp + 0x00:word32] = eax;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B370;
	Mem0[eax + 4:word32] = 0x05;
	Mem0[eax + 8:word32] = 0x080518C0;
	Mem0[eax + 0x0C:word32] = edx;
	eax = esi + 0x0078;
	Mem0[esp + 8:word32] = eax;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x0804B370;
	Mem0[eax + 4:word32] = 0x05;
	Mem0[eax + 8:word32] = 0x08051910;
	Mem0[eax + 0x0C:word32] = ecx;
	Mem0[eax + 16:word32] = ebx;
	eax = Mem0[ebx + -4:word32];
	ebx = eax;
	ebx &= 0xFF;
	SCZO = cond(ebx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax);
	}
	eax |= 0x01;
	Mem0[esp + 20:word32] = eax;
	ecx = 0x03;
	eax += 0x02;
	eax >>= 0x01;
	edx_eax = CONVERT(eax, int32, int64);
	v16 = edx_eax;
	edx = CONVERT(v16 %s ecx, int64, int32);
	eax = CONVERT(v16 /32 ecx, word32, int32);
	ebx = eax - 1 + eax;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		Mem0[esp + 0x0C:word32] = ebx;
		do
		{
			edx = Mem0[esp + 16:word32];
			eax = Mem0[edx + -4:word32];
			ecx = eax;
			ecx &= 0xFF;
			SCZO = cond(ecx - 0xFE);
			if (Test(NE,Z))
			{
				eax >>= 0x09;
				SCZO = cond(eax - ebx);
				if (Test(ULE,CZ))
					goto l080537B0;
				ecx = (edx - 2)[ebx * 0x02];
			}
			else
			{
				eax >>= 0x0A;
				SCZO = cond(eax - ebx);
				if (Test(ULE,CZ))
					goto l080537AB;
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				ecx = eax + 4;
				Mem0[ecx + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (edx - 4)[ebx * 0x04];
				Mem0[ecx + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			eax = Mem0[esp + 20:word32];
			edx = Mem0[esp + 4:word32];
			camlArray__trickle_1165();
			ebx = Mem0[esp + 0x0C:word32];
			eax = ebx;
			ebx -= 0x02;
			Mem0[esp + 0x0C:word32] = ebx;
			SCZO = cond(eax - 0x01);
		} while (Test(NE,Z));
	}
	esi = Mem0[esp + 20:word32];
	esi += ~0x01;
	SCZO = cond(esi - 0x05);
	if (Test(GE,SO))
	{
		Mem0[esp + 0x0C:word32] = esi;
		do
		{
			ebx = Mem0[esp + 16:word32];
			eax = Mem0[ebx + -4:word32];
			ecx = eax;
			ecx &= 0xFF;
			SCZO = cond(ecx - 0xFE);
			if (Test(NE,Z))
			{
				eax >>= 0x09;
				SCZO = cond(eax - esi);
				if (Test(ULE,CZ))
					goto l080537A6;
				eax = (ebx - 2)[esi * 0x02];
				Mem0[esp + 4:word32] = eax;
			}
			else
			{
				eax >>= 0x0A;
				SCZO = cond(eax - esi);
				if (Test(ULE,CZ))
					goto l080537A1;
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = (ebx - 4)[esi * 0x04];
				Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
				Mem0[esp + 4:word32] = eax;
			}
			eax = Mem0[ebx + -4:word32];
			ecx = eax;
			ecx &= 0xFF;
			SCZO = cond(ecx - 0xFE);
			if (Test(NE,Z))
			{
				eax >>= 0x09;
				SCZO = cond(eax - 0x01);
				if (Test(ULE,CZ))
					goto l0805379C;
				edx = Mem0[ebx + 0x00:word32];
			}
			else
			{
				eax >>= 0x0A;
				SCZO = cond(eax - 0x01);
				if (Test(ULE,CZ))
					goto l08053797;
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				edx = eax + 4;
				Mem0[edx + -4:word32] = 0x08FD;
				--Top;
				ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
				Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
				++Top;
			}
			eax = Mem0[ebx + -4:word32];
			ecx = eax;
			ecx &= 0xFF;
			SCZO = cond(ecx - 0xFE);
			if (Test(NE,Z))
			{
				eax >>= 0x09;
				SCZO = cond(eax - esi);
				if (Test(ULE,CZ))
					goto l08053792;
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				eax = ebx - 2 + esi * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				SCZO = cond(esp);
			}
			else
			{
				eax >>= 0x0A;
				SCZO = cond(eax - esi);
				if (Test(ULE,CZ))
					goto l0805378D;
				--Top;
				ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
				(ebx - 4)[esi * 0x04] = ST[Top + 0x00:real64];
				++Top;
			}
			ebx = 0x01;
			eax = esi;
			ecx = Mem0[esp + 0x00:word32];
			camlArray__bubble_1174();
			ebx = Mem0[esp + 4:word32];
			ecx = Mem0[esp + 8:word32];
			camlArray__trickleup_1178();
			esi = Mem0[esp + 0x0C:word32];
			eax = esi;
			esi -= 0x02;
			Mem0[esp + 0x0C:word32] = esi;
			SCZO = cond(eax - 0x05);
		} while (Test(NE,Z));
	}
	eax = Mem0[esp + 20:word32];
	SCZO = cond(eax - 0x03);
	if (Test(LE,SZO))
	{
		eax = 0x01;
		esp += 0x20;
		SCZO = cond(esp);
		return;
	}
	ebx = Mem0[esp + 16:word32];
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l08053788;
		esi = Mem0[ebx + 4:word32];
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l08053783;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		esi = eax + 4;
		Mem0[esi + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = Mem0[ebx + 8:real64];
		Mem0[esi + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805377E;
		edx = Mem0[ebx + 0x00:word32];
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l08053779;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		edx = eax + 4;
		Mem0[edx + -4:word32] = 0x08FD;
		--Top;
		ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
		Mem0[edx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l08053774;
		esp -= 4;
		Mem0[esp + 0x00:word32] = edx;
		eax = ebx;
		eax += 0x04;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805376F;
		--Top;
		ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
		Mem0[ebx + 8:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(UGT,CZ))
		{
			esp -= 4;
			Mem0[esp + 0x00:word32] = esi;
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805370C;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(UGT,CZ))
		{
			--Top;
			ST[Top + 0x00:real64] = Mem0[esi + 0x00:real64];
			Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
l0805370C:
			eax = 0x01;
			esp += 0x20;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
l0805376F:
	fn08070B18();
l08053774:
	fn08070B18();
l08053779:
	fn08070B18();
l0805377E:
	fn08070B18();
l08053783:
	fn08070B18();
l08053788:
	fn08070B18();
l0805378D:
	fn08070B18();
l08053792:
	fn08070B18();
l08053797:
	fn08070B18();
l0805379C:
	fn08070B18();
l080537A1:
	fn08070B18();
l080537A6:
	fn08070B18();
l080537AB:
	fn08070B18();
l080537B0:
	fn08070B18();
	esi = esi;
	edi += 0x00;
	camlArray__stable_sort_1188();
}

// 080537C0: define camlArray__stable_sort_1188
// Called from:
//      camlArray__sort_1152
define camlArray__stable_sort_1188
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x4C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x0804AD50;
	Mem0[eax + 4:word32] = 0x0F;
	Mem0[eax + 8:word32] = 134552544;
	Mem0[eax + 0x0C:word32] = ecx;
	Mem0[eax + 16:word32] = ebx;
	esi = eax + 24;
	Mem0[esi + -4:word32] = 0x14F7;
	Mem0[esi + 0x00:word32] = 134525424;
	Mem0[esi + 4:word32] = 0x09;
	Mem0[esi + 8:word32] = 0x08051D70;
	Mem0[esi + 0x0C:word32] = ecx;
	Mem0[esi + 16:word32] = ebx;
	ecx = eax + 48;
	Mem0[ecx + -4:word32] = 0x18F7;
	Mem0[ecx + 0x00:word32] = 134525424;
	Mem0[ecx + 4:word32] = 0x09;
	Mem0[ecx + 8:word32] = 0x08052070;
	Mem0[ecx + 0x0C:word32] = ebx;
	Mem0[ecx + 16:word32] = eax;
	Mem0[ecx + 20:word32] = esi;
	edx = Mem0[ebx + -4:word32];
	edi = edx;
	edi &= 0xFF;
	SCZO = cond(edi - 0xFE);
	if (Test(NE,Z))
	{
		edx >>= 0x09;
		SCZO = cond(edx);
	}
	else
	{
		edx >>= 0x0A;
		SCZO = cond(edx);
	}
	edx |= 0x01;
	SCZO = cond(edx - 11);
	if (Test(LE,SZO))
	{
		ecx = 0x01;
		eax = 0x01;
		esp += 0x20;
		SCZO = cond(esp);
		camlArray__isortto_1209();
		return;
	}
	Mem0[esp + 0x00:word32] = ecx;
	Mem0[esp + 20:word32] = eax;
	Mem0[esp + 16:word32] = ebx;
	eax = edx;
	eax >>= 0x01;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(LT,SO))
	{
		++eax;
		SCZO = cond(eax);
	}
	eax >>= 0x01;
	eax = eax + 1 + eax;
	Mem0[esp + 8:word32] = eax;
	edx -= eax;
	++edx;
	Mem0[esp + 4:word32] = edx;
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(UGT,CZ))
		{
			eax = Mem0[ebx + 0x00:word32];
			goto l08053913;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(UGT,CZ))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
l08053913:
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			esp -= 4;
			Mem0[esp + 0x00:word32] = edx;
			eax = 0x080683F9;
			fn080709D8();
			esp += 0x08;
			SCZO = cond(esp);
			ebx = eax;
			Mem0[esp + 0x0C:word32] = ebx;
			ecx = 0x01;
			eax = Mem0[esp + 8:word32];
			edx = Mem0[esp + 4:word32];
			esi = Mem0[esp + 0x00:word32];
			camlArray__sortto_1217();
			eax = 0x01;
			ebx = Mem0[esp + 16:word32];
			ecx = Mem0[esp + 4:word32];
			edx = Mem0[esp + 8:word32];
			esi = Mem0[esp + 0x00:word32];
			camlArray__sortto_1217();
			ebp = 0x01;
			edx = 0x01;
			eax = Mem0[esp + 4:word32];
			ebx = Mem0[esp + 8:word32];
			ecx = Mem0[esp + 0x0C:word32];
			esi = eax;
			edi = Mem0[esp + 16:word32];
			Mem0[0x0807D0BC<p32>:word32] = ebp;
			ebp = Mem0[esp + 20:word32];
			Mem0[0x0807D0C0<p32>:word32] = ebp;
			esp += 0x20;
			SCZO = cond(esp);
			camlArray__merge_1191();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	esi += 0x00;
	camlArray__entry();
}

// 080539B0: define camlArray__entry
// Called from:
//      caml_program
//      camlArray__stable_sort_1188
define camlArray__entry
{
	word32 dwLoc04;
	Top_3 = 0;
	Mem5[0x08077C3C<p32>:word32] = 0x08077DC0;
	Mem7[0x08077C40<p32>:word32] = 0x08077DB0;
	eax_8 = Mem7[0x08077C40<p32>:word32];
	Mem9[0x08077C44<p32>:word32] = eax_8;
	Mem11[0x08077C54<p32>:word32] = 0x08077DA4;
	Mem13[0x08077C48<p32>:word32] = 0x08077D94;
	Mem15[0x08077C8C<p32>:word32] = 0x08077D84;
	Mem17[0x08077C4C<p32>:word32] = 0x08077D78;
	Mem19[0x08077C50<p32>:word32] = 0x08077D68;
	Mem21[0x08077C58<p32>:word32] = 0x08077D58;
	Mem23[0x08077C5C<p32>:word32] = 0x08077D48;
	Mem25[0x08077C68<p32>:word32] = 0x08077D38;
	Mem27[0x08077C6C<p32>:word32] = 0x08077D28;
	Mem29[0x08077C70<p32>:word32] = 0x08077D18;
	Mem31[0x08077C74<p32>:word32] = 0x08077D08;
	Mem33[0x08077C60<p32>:word32] = 0x08077CFC;
	Mem35[0x08077C90<p32>:word32] = 0x08077CEC;
	Mem37[0x08077C64<p32>:word32] = 0x08077CE0;
	Mem39[0x08077C78<p32>:word32] = 0x08077CD0;
	Mem41[0x08077C7C<p32>:word32] = 0x08077CC0;
	fn080708F8();
	Mem48[eax_42 + 0x00:word32] = 0x0400;
	Mem49[eax_42 + 4:word32] = 0x08077DEC;
	Mem50[0x08077C94<p32>:word32] = eax_42 + 4;
	Mem52[0x08077C80<p32>:word32] = 0x08077CB0;
	Mem53[0x08077C98<p32>:word32] = 11;
	Mem55[0x08077C84<p32>:word32] = 0x08077CA0;
	eax_56 = Mem55[0x08077C84<p32>:word32];
	Mem57[0x08077C88<p32>:word32] = eax_56;
	eax_58 = 0x01;
}

// 08053AC0: define camlList__nth_aux_1045
// Called from:
//      camlList__nth_1042
define camlList__nth_aux_1045
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		ecx = Mem0[eax + 4:word32];
		eax = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			return;
		ebx += ~0x01;
		SCZO = cond(ebx);
		eax = ecx;
	}
	eax = 0x08078EDC;
	camlPervasives__failwith_1010();
}

// 08053AF0: define camlList__rmap_f_1070
// Called from:
//      camlList__rev_map_1067
define camlList__rmap_f_1070
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ebx = Mem0[ecx + 0x0C:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
		ebx = eax;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		Mem0[eax + 0x00:word32] = ebx;
		ebx = Mem0[esp + 0x00:word32];
		Mem0[eax + 4:word32] = ebx;
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
	}
	esp += 0x0C;
	SCZO = cond(esp);
}

// 08053B60: define camlList__rmap2_f_1103
// Called from:
//      camlList__rev_map2_1099
define camlList__rmap2_f_1103
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
			goto l08053BE0;
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[ecx + 4:word32];
		Mem0[esp + 8:word32] = eax;
		esi = Mem0[ecx + 0x00:word32];
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ecx = Mem0[edx + 0x0C:word32];
		ebx = esi;
		caml_apply2();
		ebx = eax;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		Mem0[eax + 0x00:word32] = ebx;
		ebx = Mem0[esp + 0x00:word32];
		Mem0[eax + 4:word32] = ebx;
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
		edx = Mem0[esp + 0x0C:word32];
	}
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
l08053BE0:
		eax = 0x08078EC8;
		esp += 0x10;
		SCZO = cond(esp);
		camlPervasives__invalid_arg_1012();
	}
	else
	{
		esp += 0x10;
		SCZO = cond(esp);
	}
}

// 08053C00: define camlList__find_1207
define camlList__find_1207
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x0C:word32] = ecx;
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 8:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		Mem0[esp + 0x00:word32] = eax;
		ebx = Mem0[ecx + 0x0C:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			ebx = Mem0[esp + 0x00:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 4:word32] = ebx;
			ebx = Mem0[esp + 8:word32];
			ecx = Mem0[esp + 0x0C:word32];
		}
		else
		{
			eax = Mem0[esp + 4:word32];
			ebx = Mem0[esp + 8:word32];
			ecx = Mem0[esp + 0x0C:word32];
		}
	}
	ebx = 0x01;
	esp += 0x10;
	SCZO = cond(esp);
	camlList__rev_append_1051();
}

// 08053C90: define camlList__part_1215
// Called from:
//      camlList__partition_1212
define camlList__part_1215
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
	while (true)
	{
		Mem0[esp + 4:word32] = eax;
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 16:word32] = edx;
		Mem0[esp + 8:word32] = ebx;
		eax = Mem0[ecx + 4:word32];
		Mem0[esp + 0x0C:word32] = eax;
		eax = Mem0[ecx + 0x00:word32];
		Mem0[esp + 0x00:word32] = eax;
		ebx = Mem0[edx + 0x0C:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			ebx = Mem0[esp + 0x00:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 4:word32] = ebx;
			ebx = Mem0[esp + 8:word32];
			ecx = Mem0[esp + 0x0C:word32];
			edx = Mem0[esp + 16:word32];
		}
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ebx = eax + 4;
			Mem0[ebx + -4:word32] = 0x0800;
			eax = Mem0[esp + 0x00:word32];
			Mem0[ebx + 0x00:word32] = eax;
			eax = Mem0[esp + 8:word32];
			Mem0[ebx + 4:word32] = eax;
			eax = Mem0[esp + 4:word32];
			ecx = Mem0[esp + 0x0C:word32];
			edx = Mem0[esp + 16:word32];
		}
	}
	ecx = 0x01;
	eax = ebx;
	ebx = ecx;
	camlList__rev_append_1051();
	Mem0[esp + 0x00:word32] = eax;
	ebx = 0x01;
	eax = Mem0[esp + 4:word32];
	camlList__rev_append_1051();
	ebx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0800;
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[esp + 0x00:word32];
	Mem0[eax + 4:word32] = ebx;
	esp += 0x14;
	SCZO = cond(esp);
}

// 08053DB0: define camlList__rev_merge_1251
// Called from:
//      camlList__rev_sort_1272
define camlList__rev_merge_1251
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
		{
			ebx = ecx;
			esp += 0x20;
			SCZO = cond(esp);
			camlList__rev_append_1051();
			return;
		}
		Mem0[esp + 28:word32] = edx;
		Mem0[esp + 16:word32] = ecx;
		Mem0[esp + 24:word32] = ebx;
		Mem0[esp + 4:word32] = eax;
		ecx = Mem0[ebx + 4:word32];
		Mem0[esp + 8:word32] = ecx;
		ebx = Mem0[ebx + 0x00:word32];
		Mem0[esp + 0x00:word32] = ebx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 20:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x0C:word32] = eax;
		ecx = Mem0[edx + 0x0C:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(LE,SZO))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ecx = eax + 4;
			Mem0[ecx + -4:word32] = 0x0800;
			eax = Mem0[esp + 0x0C:word32];
			Mem0[ecx + 0x00:word32] = eax;
			eax = Mem0[esp + 16:word32];
			Mem0[ecx + 4:word32] = eax;
			eax = Mem0[esp + 20:word32];
			ebx = Mem0[esp + 24:word32];
			edx = Mem0[esp + 28:word32];
		}
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ecx = eax + 4;
			Mem0[ecx + -4:word32] = 0x0800;
			eax = Mem0[esp + 0x00:word32];
			Mem0[ecx + 0x00:word32] = eax;
			eax = Mem0[esp + 16:word32];
			Mem0[ecx + 4:word32] = eax;
			eax = Mem0[esp + 4:word32];
			ebx = Mem0[esp + 8:word32];
			edx = Mem0[esp + 28:word32];
		}
	}
	eax = ebx;
	ebx = ecx;
	esp += 0x20;
	SCZO = cond(esp);
	camlList__rev_append_1051();
}

// 08053EB0: define camlList__rev_merge_rev_1261
// Called from:
//      camlList__sort_1271
define camlList__rev_merge_rev_1261
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
		{
			ebx = ecx;
			esp += 0x20;
			SCZO = cond(esp);
			camlList__rev_append_1051();
			return;
		}
		Mem0[esp + 28:word32] = edx;
		Mem0[esp + 16:word32] = ecx;
		Mem0[esp + 24:word32] = ebx;
		Mem0[esp + 4:word32] = eax;
		ecx = Mem0[ebx + 4:word32];
		Mem0[esp + 8:word32] = ecx;
		ebx = Mem0[ebx + 0x00:word32];
		Mem0[esp + 0x00:word32] = ebx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 20:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x0C:word32] = eax;
		ecx = Mem0[edx + 0x0C:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(GT,SZO))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ecx = eax + 4;
			Mem0[ecx + -4:word32] = 0x0800;
			eax = Mem0[esp + 0x0C:word32];
			Mem0[ecx + 0x00:word32] = eax;
			eax = Mem0[esp + 16:word32];
			Mem0[ecx + 4:word32] = eax;
			eax = Mem0[esp + 20:word32];
			ebx = Mem0[esp + 24:word32];
			edx = Mem0[esp + 28:word32];
		}
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ecx = eax + 4;
			Mem0[ecx + -4:word32] = 0x0800;
			eax = Mem0[esp + 0x00:word32];
			Mem0[ecx + 0x00:word32] = eax;
			eax = Mem0[esp + 16:word32];
			Mem0[ecx + 4:word32] = eax;
			eax = Mem0[esp + 4:word32];
			ebx = Mem0[esp + 8:word32];
			edx = Mem0[esp + 28:word32];
		}
	}
	eax = ebx;
	ebx = ecx;
	esp += 0x20;
	SCZO = cond(esp);
	camlList__rev_append_1051();
}

// 08053FB0: define camlList__rev_sort_1272
// Called from:
//      camlList__sort_1271
define camlList__rev_sort_1272
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(eax - 0x05);
	if (Test(NE,Z))
	{
		Mem0[esp + 16:word32] = ecx;
		SCZO = cond(eax - 0x07);
		if (Test(EQ,Z))
		{
			SCZO = cond(ebx - 0x01);
			if (Test(NE,Z))
			{
				esi = Mem0[ebx + 4:word32];
				SCZO = cond(esi - 0x01);
				if (Test(NE,Z))
				{
					edx = Mem0[esi + 4:word32];
					SCZO = cond(edx - 0x01);
					if (Test(NE,Z))
					{
						eax = Mem0[edx + 0x00:word32];
						Mem0[esp + 0x00:word32] = eax;
						edx = Mem0[esi + 0x00:word32];
						Mem0[esp + 4:word32] = edx;
						eax = Mem0[ebx + 0x00:word32];
						Mem0[esp + 8:word32] = eax;
						ecx = Mem0[ecx + 0x0C:word32];
						ebx = edx;
						caml_apply2();
						SCZO = cond(eax - 0x01);
						if (Test(LE,SZO))
						{
							eax = Mem0[esp + 16:word32];
							ecx = Mem0[eax + 0x0C:word32];
							eax = Mem0[esp + 8:word32];
							ebx = Mem0[esp + 0x00:word32];
							caml_apply2();
							SCZO = cond(eax - 0x01);
							if (Test(LE,SZO))
							{
								eax = Mem0[esp + 16:word32];
								ecx = Mem0[eax + 0x0C:word32];
								eax = Mem0[esp + 4:word32];
								ebx = Mem0[esp + 0x00:word32];
								caml_apply2();
								SCZO = cond(eax - 0x01);
								if (Test(LE,SZO))
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
								else
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
							}
							else
							{
								while (true)
								{
									eax = Mem0[0x08080414<p32>:word32];
									eax -= 0x24;
									Mem0[0x08080414<p32>:word32] = eax;
									SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
									if (Test(UGE,C))
										break;
									fn080708CC();
								}
								ebx = eax + 4;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 0x00:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = 0x01;
								ecx = ebx + 0x0C;
								Mem0[ecx + -4:word32] = 0x0800;
								eax = Mem0[esp + 8:word32];
								Mem0[ecx + 0x00:word32] = eax;
								Mem0[ecx + 4:word32] = ebx;
								ebx += 0x18;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 4:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = ecx;
								eax = ebx;
								esp += 0x14;
								SCZO = cond(esp);
								return;
							}
						}
						else
						{
							eax = Mem0[esp + 16:word32];
							ecx = Mem0[eax + 0x0C:word32];
							eax = Mem0[esp + 4:word32];
							ebx = Mem0[esp + 0x00:word32];
							caml_apply2();
							SCZO = cond(eax - 0x01);
							if (Test(LE,SZO))
							{
								eax = Mem0[esp + 16:word32];
								ecx = Mem0[eax + 0x0C:word32];
								eax = Mem0[esp + 8:word32];
								ebx = Mem0[esp + 0x00:word32];
								caml_apply2();
								SCZO = cond(eax - 0x01);
								if (Test(LE,SZO))
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
								else
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
							}
							else
							{
								while (true)
								{
									eax = Mem0[0x08080414<p32>:word32];
									eax -= 0x24;
									Mem0[0x08080414<p32>:word32] = eax;
									SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
									if (Test(UGE,C))
										break;
									fn080708CC();
								}
								ebx = eax + 4;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 0x00:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = 0x01;
								ecx = ebx + 0x0C;
								Mem0[ecx + -4:word32] = 0x0800;
								eax = Mem0[esp + 4:word32];
								Mem0[ecx + 0x00:word32] = eax;
								Mem0[ecx + 4:word32] = ebx;
								ebx += 0x18;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 8:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = ecx;
								eax = ebx;
								esp += 0x14;
								SCZO = cond(esp);
								return;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		SCZO = cond(ebx - 0x01);
		if (Test(NE,Z))
		{
			edx = Mem0[ebx + 4:word32];
			SCZO = cond(edx - 0x01);
			if (Test(NE,Z))
			{
				edx = Mem0[edx + 0x00:word32];
				Mem0[esp + 0x00:word32] = edx;
				eax = Mem0[ebx + 0x00:word32];
				Mem0[esp + 4:word32] = eax;
				ecx = Mem0[ecx + 0x0C:word32];
				ebx = edx;
				caml_apply2();
				SCZO = cond(eax - 0x01);
				if (Test(LE,SZO))
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x18;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					ecx = eax + 4;
					Mem0[ecx + -4:word32] = 0x0800;
					eax = Mem0[esp + 4:word32];
					Mem0[ecx + 0x00:word32] = eax;
					Mem0[ecx + 4:word32] = 0x01;
					ebx = ecx + 0x0C;
					Mem0[ebx + -4:word32] = 0x0800;
					eax = Mem0[esp + 0x00:word32];
					Mem0[ebx + 0x00:word32] = eax;
					Mem0[ebx + 4:word32] = ecx;
					eax = ebx;
					esp += 0x14;
					SCZO = cond(esp);
					return;
				}
				else
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x18;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					ecx = eax + 4;
					Mem0[ecx + -4:word32] = 0x0800;
					eax = Mem0[esp + 0x00:word32];
					Mem0[ecx + 0x00:word32] = eax;
					Mem0[ecx + 4:word32] = 0x01;
					ebx = ecx + 0x0C;
					Mem0[ebx + -4:word32] = 0x0800;
					eax = Mem0[esp + 4:word32];
					Mem0[ebx + 0x00:word32] = eax;
					Mem0[ebx + 4:word32] = ecx;
					eax = ebx;
					esp += 0x14;
					SCZO = cond(esp);
					return;
				}
			}
			Mem0[esp + 16:word32] = ecx;
		}
		else
			Mem0[esp + 16:word32] = ecx;
	}
	Mem0[esp + 4:word32] = ebx;
	ecx = eax;
	ecx >>= 0x01;
	ecx |= 0x01;
	Mem0[esp + 0x00:word32] = ecx;
	eax -= ecx;
	SCZO = cond(eax);
	++eax;
	SZO = cond(eax);
	Mem0[esp + 8:word32] = eax;
	eax = ecx;
	camlList__chop_1243();
	Mem0[esp + 0x0C:word32] = eax;
	ecx = Mem0[esp + 16:word32];
	ecx += ~0x0F;
	SCZO = cond(ecx);
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[esp + 4:word32];
	camlList__sort_1271();
	esp += 0x04;
	Mem0[esp + 0x00:word32] = eax;
	ecx = Mem0[esp + 16:word32];
	ecx += ~0x0F;
	SCZO = cond(ecx);
	eax = Mem0[esp + 8:word32];
	ebx = Mem0[esp + 0x0C:word32];
	camlList__sort_1271();
	esp += 0x04;
	ebx = eax;
	eax = Mem0[esp + 16:word32];
	edx = Mem0[eax + 16:word32];
	ecx = 0x01;
	eax = Mem0[esp + 0x00:word32];
	esp += 0x14;
	SCZO = cond(esp);
	camlList__rev_merge_1251();
}

// 08054470: define camlList__sort_1271
// Called from:
//      camlList__rev_sort_1272
//      camlList__stable_sort_1248
define camlList__sort_1271
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(eax - 0x05);
	if (Test(NE,Z))
	{
		Mem0[esp + 16:word32] = ecx;
		SCZO = cond(eax - 0x07);
		if (Test(EQ,Z))
		{
			SCZO = cond(ebx - 0x01);
			if (Test(NE,Z))
			{
				esi = Mem0[ebx + 4:word32];
				SCZO = cond(esi - 0x01);
				if (Test(NE,Z))
				{
					edx = Mem0[esi + 4:word32];
					SCZO = cond(edx - 0x01);
					if (Test(NE,Z))
					{
						eax = Mem0[edx + 0x00:word32];
						Mem0[esp + 0x00:word32] = eax;
						edx = Mem0[esi + 0x00:word32];
						Mem0[esp + 4:word32] = edx;
						eax = Mem0[ebx + 0x00:word32];
						Mem0[esp + 8:word32] = eax;
						ecx = Mem0[ecx + 28:word32];
						ebx = edx;
						caml_apply2();
						SCZO = cond(eax - 0x01);
						if (Test(GT,SZO))
						{
							eax = Mem0[esp + 16:word32];
							ecx = Mem0[eax + 28:word32];
							eax = Mem0[esp + 8:word32];
							ebx = Mem0[esp + 0x00:word32];
							caml_apply2();
							SCZO = cond(eax - 0x01);
							if (Test(GT,SZO))
							{
								eax = Mem0[esp + 16:word32];
								ecx = Mem0[eax + 28:word32];
								eax = Mem0[esp + 4:word32];
								ebx = Mem0[esp + 0x00:word32];
								caml_apply2();
								SCZO = cond(eax - 0x01);
								if (Test(GT,SZO))
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
								else
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
							}
							else
							{
								while (true)
								{
									eax = Mem0[0x08080414<p32>:word32];
									eax -= 0x24;
									Mem0[0x08080414<p32>:word32] = eax;
									SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
									if (Test(UGE,C))
										break;
									fn080708CC();
								}
								ebx = eax + 4;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 0x00:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = 0x01;
								ecx = ebx + 0x0C;
								Mem0[ecx + -4:word32] = 0x0800;
								eax = Mem0[esp + 8:word32];
								Mem0[ecx + 0x00:word32] = eax;
								Mem0[ecx + 4:word32] = ebx;
								ebx += 0x18;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 4:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = ecx;
								eax = ebx;
								esp += 0x14;
								SCZO = cond(esp);
								return;
							}
						}
						else
						{
							eax = Mem0[esp + 16:word32];
							ecx = Mem0[eax + 28:word32];
							eax = Mem0[esp + 4:word32];
							ebx = Mem0[esp + 0x00:word32];
							caml_apply2();
							SCZO = cond(eax - 0x01);
							if (Test(GT,SZO))
							{
								eax = Mem0[esp + 16:word32];
								ecx = Mem0[eax + 28:word32];
								eax = Mem0[esp + 8:word32];
								ebx = Mem0[esp + 0x00:word32];
								caml_apply2();
								SCZO = cond(eax - 0x01);
								if (Test(GT,SZO))
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
								else
								{
									while (true)
									{
										eax = Mem0[0x08080414<p32>:word32];
										eax -= 0x24;
										Mem0[0x08080414<p32>:word32] = eax;
										SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
										if (Test(UGE,C))
											break;
										fn080708CC();
									}
									ebx = eax + 4;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 4:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = 0x01;
									ecx = ebx + 0x0C;
									Mem0[ecx + -4:word32] = 0x0800;
									eax = Mem0[esp + 0x00:word32];
									Mem0[ecx + 0x00:word32] = eax;
									Mem0[ecx + 4:word32] = ebx;
									ebx += 0x18;
									Mem0[ebx + -4:word32] = 0x0800;
									eax = Mem0[esp + 8:word32];
									Mem0[ebx + 0x00:word32] = eax;
									Mem0[ebx + 4:word32] = ecx;
									eax = ebx;
									esp += 0x14;
									SCZO = cond(esp);
									return;
								}
							}
							else
							{
								while (true)
								{
									eax = Mem0[0x08080414<p32>:word32];
									eax -= 0x24;
									Mem0[0x08080414<p32>:word32] = eax;
									SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
									if (Test(UGE,C))
										break;
									fn080708CC();
								}
								ebx = eax + 4;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 0x00:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = 0x01;
								ecx = ebx + 0x0C;
								Mem0[ecx + -4:word32] = 0x0800;
								eax = Mem0[esp + 4:word32];
								Mem0[ecx + 0x00:word32] = eax;
								Mem0[ecx + 4:word32] = ebx;
								ebx += 0x18;
								Mem0[ebx + -4:word32] = 0x0800;
								eax = Mem0[esp + 8:word32];
								Mem0[ebx + 0x00:word32] = eax;
								Mem0[ebx + 4:word32] = ecx;
								eax = ebx;
								esp += 0x14;
								SCZO = cond(esp);
								return;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		SCZO = cond(ebx - 0x01);
		if (Test(NE,Z))
		{
			edx = Mem0[ebx + 4:word32];
			SCZO = cond(edx - 0x01);
			if (Test(NE,Z))
			{
				edx = Mem0[edx + 0x00:word32];
				Mem0[esp + 0x00:word32] = edx;
				eax = Mem0[ebx + 0x00:word32];
				Mem0[esp + 4:word32] = eax;
				ecx = Mem0[ecx + 28:word32];
				ebx = edx;
				caml_apply2();
				SCZO = cond(eax - 0x01);
				if (Test(GT,SZO))
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x18;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					ecx = eax + 4;
					Mem0[ecx + -4:word32] = 0x0800;
					eax = Mem0[esp + 4:word32];
					Mem0[ecx + 0x00:word32] = eax;
					Mem0[ecx + 4:word32] = 0x01;
					ebx = ecx + 0x0C;
					Mem0[ebx + -4:word32] = 0x0800;
					eax = Mem0[esp + 0x00:word32];
					Mem0[ebx + 0x00:word32] = eax;
					Mem0[ebx + 4:word32] = ecx;
					eax = ebx;
					esp += 0x14;
					SCZO = cond(esp);
					return;
				}
				else
				{
					while (true)
					{
						eax = Mem0[0x08080414<p32>:word32];
						eax -= 0x18;
						Mem0[0x08080414<p32>:word32] = eax;
						SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
						if (Test(UGE,C))
							break;
						fn080708CC();
					}
					ecx = eax + 4;
					Mem0[ecx + -4:word32] = 0x0800;
					eax = Mem0[esp + 0x00:word32];
					Mem0[ecx + 0x00:word32] = eax;
					Mem0[ecx + 4:word32] = 0x01;
					ebx = ecx + 0x0C;
					Mem0[ebx + -4:word32] = 0x0800;
					eax = Mem0[esp + 4:word32];
					Mem0[ebx + 0x00:word32] = eax;
					Mem0[ebx + 4:word32] = ecx;
					eax = ebx;
					esp += 0x14;
					SCZO = cond(esp);
					return;
				}
			}
			Mem0[esp + 16:word32] = ecx;
		}
		else
			Mem0[esp + 16:word32] = ecx;
	}
	Mem0[esp + 4:word32] = ebx;
	ecx = eax;
	ecx >>= 0x01;
	ecx |= 0x01;
	Mem0[esp + 0x00:word32] = ecx;
	eax -= ecx;
	SCZO = cond(eax);
	++eax;
	SZO = cond(eax);
	Mem0[esp + 8:word32] = eax;
	eax = ecx;
	camlList__chop_1243();
	Mem0[esp + 0x0C:word32] = eax;
	ecx = Mem0[esp + 16:word32];
	ecx += 0x10;
	SCZO = cond(ecx);
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[esp + 4:word32];
	camlList__rev_sort_1272();
	Mem0[esp + 0x00:word32] = eax;
	ecx = Mem0[esp + 16:word32];
	ecx += 0x10;
	SCZO = cond(ecx);
	eax = Mem0[esp + 8:word32];
	ebx = Mem0[esp + 0x0C:word32];
	camlList__rev_sort_1272();
	ebx = eax;
	eax = Mem0[esp + 16:word32];
	edx = Mem0[eax + 36:word32];
	ecx = 0x01;
	eax = Mem0[esp + 0x00:word32];
	esp += 0x14;
	SCZO = cond(esp);
	camlList__rev_merge_rev_1261();
}

// 08054930: define camlList__length_aux_1030
// Called from:
//      camlList__length_1034
//      camlList__stable_sort_1248
define camlList__length_aux_1030
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		ebx = Mem0[ebx + 4:word32];
		eax += 0x02;
		SCZO = cond(eax);
	}
}

// 08054950: define camlList__length_1034
define camlList__length_1034
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = 0x01;
	camlList__length_aux_1030();
}

// 08054960: define camlList__hd_1036
define camlList__hd_1036
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x08078EC0;
		camlPervasives__failwith_1010();
	}
	else
		eax = Mem0[eax + 0x00:word32];
}

// 08054980: define camlList__tl_1039
define camlList__tl_1039
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x08078EB8;
		camlPervasives__failwith_1010();
	}
	else
		eax = Mem0[eax + 4:word32];
}

// 080549A0: define camlList__nth_1042
define camlList__nth_1042
{
	esp = fp;
	Top = 0;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		ecx = 0x08078DE8;
		camlList__nth_aux_1045();
	}
	else
	{
		eax = 0x08078EA8;
		camlPervasives__invalid_arg_1012();
	}
}

// 080549C0: define camlList__rev_append_1051
// Called from:
//      fn0804D510
//      camlList__find_1207
//      camlList__rev_sort_1272
//      camlList__sort_1271
//      camlList__rev_1056
//      camlList__partition_1212
//      camlPrintf__extract_format_1085
define camlList__rev_append_1051
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		esi = Mem0[eax + 4:word32];
		edx = Mem0[eax + 0x00:word32];
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ecx = eax + 4;
		Mem0[ecx + -4:word32] = 0x0800;
		Mem0[ecx + 0x00:word32] = edx;
		Mem0[ecx + 4:word32] = ebx;
		eax = esi;
		ebx = ecx;
	}
	eax = ebx;
}

// 08054A10: define camlList__rev_1056
define camlList__rev_1056
{
	esp = fp;
	Top = 0;
	ebx = 0x01;
	camlList__rev_append_1051();
}

// 08054A20: define camlList__flatten_1058
// Called from:
//      camlUnix__getaddrinfo_1751
//      camlList__flatten_1058
define camlList__flatten_1058
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x04;
		SCZO = cond(esp);
	}
	else
	{
		ecx = Mem0[eax + 4:word32];
		ebx = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x00:word32] = ebx;
		eax = ecx;
		camlList__flatten_1058();
		ebx = eax;
		eax = Mem0[esp + 0x00:word32];
		esp += 0x04;
		SCZO = cond(esp);
		camlPervasives__$40_1143();
	}
}

// 08054A60: define camlList__map_1062
// Called from:
//      camlUnix__fun_2836
//      fn0804D330
//      camlUnix__getaddrinfo_1751
//      camlList__map_1062
define camlList__map_1062
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	edx = eax;
	SCZO = cond(ebx - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x0C;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ecx = Mem0[edx + 0x00:word32];
		ebx = edx;
		ecx();
		Mem0[esp + 8:word32] = eax;
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
		camlList__map_1062();
		ecx = eax;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		ebx = Mem0[esp + 8:word32];
		Mem0[eax + 0x00:word32] = ebx;
		Mem0[eax + 4:word32] = ecx;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 08054AD0: define camlList__rev_map_1067
define camlList__rev_map_1067
{
	esp = fp;
	Top = 0;
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x08053AF0;
	Mem0[ecx + 0x0C:word32] = edx;
	eax = 0x01;
	camlList__rmap_f_1070();
}

// 08054B20: define camlList__iter_1074
// Called from:
//      camlUnix__getaddrinfo_1751
//      camlUnix__open_proc_1949
//      camlUnix__open_proc_full_1975
//      camlString__concat_1066
define camlList__iter_1074
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ecx = Mem0[edx + 0x00:word32];
		ebx = edx;
		ecx();
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08054B60: define camlList__fold_left_1078
define camlList__fold_left_1078
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		eax = ebx;
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = edx;
		esi = Mem0[ecx + 4:word32];
		Mem0[esp + 4:word32] = esi;
		ecx = Mem0[ecx + 0x00:word32];
		ebx = ecx;
		ecx = edx;
		caml_apply2();
		ebx = eax;
		eax = Mem0[esp + 0x00:word32];
		ecx = Mem0[esp + 4:word32];
	}
	esp += 0x08;
	SCZO = cond(esp);
}

// 08054BA0: define camlList__fold_right_1084
// Called from:
//      camlList__fold_right_1084
define camlList__fold_right_1084
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(ebx - 0x01);
	if (Test(EQ,Z))
	{
		eax = ecx;
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 4:word32] = eax;
		esi = Mem0[ebx + 4:word32];
		edx = Mem0[ebx + 0x00:word32];
		Mem0[esp + 0x00:word32] = edx;
		ebx = esi;
		camlList__fold_right_1084();
		ebx = eax;
		eax = Mem0[esp + 0x00:word32];
		ecx = Mem0[esp + 4:word32];
		esp += 0x08;
		SCZO = cond(esp);
		caml_apply2();
	}
}

// 08054BE0: define camlList__map2_1090
// Called from:
//      camlList__map2_1090
define camlList__map2_1090
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	edx = eax;
	SCZO = cond(ebx - 0x01);
	if (Test(NE,Z))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = edx;
			eax = Mem0[ecx + 4:word32];
			Mem0[esp + 8:word32] = eax;
			ecx = Mem0[ecx + 0x00:word32];
			eax = Mem0[ebx + 4:word32];
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebx + 0x00:word32];
			ebx = ecx;
			ecx = edx;
			caml_apply2();
			Mem0[esp + 0x0C:word32] = eax;
			eax = Mem0[esp + 0x00:word32];
			ebx = Mem0[esp + 4:word32];
			ecx = Mem0[esp + 8:word32];
			camlList__map2_1090();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			ebx = Mem0[esp + 0x0C:word32];
			Mem0[eax + 0x00:word32] = ebx;
			Mem0[eax + 4:word32] = ecx;
			esp += 0x10;
			SCZO = cond(esp);
			return;
		}
	}
	else
	{
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x01;
			esp += 0x10;
			SCZO = cond(esp);
			return;
		}
	}
	eax = 0x08078E98;
	esp += 0x10;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 08054C80: define camlList__rev_map2_1099
define camlList__rev_map2_1099
{
	esp = fp;
	Top = 0;
	esi = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 4343;
	Mem0[edx + 0x00:word32] = 0x0804B2D0;
	Mem0[edx + 4:word32] = 0x07;
	Mem0[edx + 8:word32] = 0x08053B60;
	Mem0[edx + 0x0C:word32] = esi;
	eax = 0x01;
	camlList__rmap2_f_1103();
}

// 08054CD0: define camlList__iter2_1111
define camlList__iter2_1111
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
			goto l08054D20;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ecx + 4:word32];
		Mem0[esp + 8:word32] = eax;
		ecx = Mem0[ecx + 0x00:word32];
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ebx = ecx;
		ecx = edx;
		caml_apply2();
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
	}
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
l08054D20:
		eax = 0x08078E88;
		esp += 0x0C;
		SCZO = cond(esp);
		camlPervasives__invalid_arg_1012();
	}
	else
	{
		eax = 0x01;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 08054D30: define camlList__fold_left2_1119
define camlList__fold_left2_1119
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		esi = eax;
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(edx - 0x01);
		if (Test(EQ,Z))
			goto l08054D80;
		Mem0[esp + 0x00:word32] = esi;
		eax = Mem0[edx + 4:word32];
		Mem0[esp + 8:word32] = eax;
		edx = Mem0[edx + 0x00:word32];
		eax = Mem0[ecx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		ecx = Mem0[ecx + 0x00:word32];
		eax = ebx;
		ebx = ecx;
		ecx = edx;
		edx = esi;
		caml_apply3();
		ebx = eax;
		eax = Mem0[esp + 0x00:word32];
		ecx = Mem0[esp + 4:word32];
		edx = Mem0[esp + 8:word32];
	}
	SCZO = cond(edx - 0x01);
	if (Test(NE,Z))
	{
l08054D80:
		eax = 0x08078E74;
		esp += 0x0C;
		SCZO = cond(esp);
		camlPervasives__invalid_arg_1012();
	}
	else
	{
		eax = ebx;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 08054D90: define camlList__fold_right2_1128
// Called from:
//      camlList__fold_right2_1128
define camlList__fold_right2_1128
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(ebx - 0x01);
	if (Test(NE,Z))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(NE,Z))
		{
			Mem0[esp + 8:word32] = eax;
			esi = Mem0[ecx + 4:word32];
			ecx = Mem0[ecx + 0x00:word32];
			Mem0[esp + 4:word32] = ecx;
			edi = Mem0[ebx + 4:word32];
			ecx = Mem0[ebx + 0x00:word32];
			Mem0[esp + 0x00:word32] = ecx;
			ebx = edi;
			ecx = esi;
			camlList__fold_right2_1128();
			ecx = eax;
			eax = Mem0[esp + 0x00:word32];
			ebx = Mem0[esp + 4:word32];
			edx = Mem0[esp + 8:word32];
			esp += 0x0C;
			SCZO = cond(esp);
			caml_apply3();
			return;
		}
	}
	else
	{
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
		{
			eax = edx;
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
	}
	eax = 0x08078E5C;
	esp += 0x0C;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 08054DF0: define camlList__for_all_1137
// Called from:
//      camlUnix__open_proc_1949
//      camlUnix__open_proc_full_1975
define camlList__for_all_1137
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ecx = Mem0[edx + 0x00:word32];
		ebx = edx;
		ecx();
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x01;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x03;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08054E40: define camlList__exists_1141
define camlList__exists_1141
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ecx = Mem0[edx + 0x00:word32];
		ebx = edx;
		ecx();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = 0x03;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08054E90: define camlList__for_all2_1145
define camlList__for_all2_1145
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
			goto l08054EF0;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ecx + 4:word32];
		Mem0[esp + 8:word32] = eax;
		ecx = Mem0[ecx + 0x00:word32];
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ebx = ecx;
		ecx = edx;
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x01;
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
	}
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
l08054EF0:
		eax = 0x08078E48;
		esp += 0x0C;
		SCZO = cond(esp);
		camlPervasives__invalid_arg_1012();
	}
	else
	{
		eax = 0x03;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 08054F00: define camlList__exists2_1153
define camlList__exists2_1153
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
			goto l08054F60;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ecx + 4:word32];
		Mem0[esp + 8:word32] = eax;
		ecx = Mem0[ecx + 0x00:word32];
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		ebx = ecx;
		ecx = edx;
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = 0x03;
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
	}
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
l08054F60:
		eax = 0x08078E34;
		esp += 0x0C;
		SCZO = cond(esp);
		camlPervasives__invalid_arg_1012();
	}
	else
	{
		eax = 0x01;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 08054F70: define camlList__mem_1161
// Called from:
//      camlUnix__getaddrinfo_1751
//      fn0804D600
//      fn0804D6B0
//      camlUnix__getnameinfo_1781
define camlList__mem_1161
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = eax;
		ecx = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = ecx;
		ebx = Mem0[ebx + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x03;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08054FD0: define camlList__memq_1165
define camlList__memq_1165
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		edx = Mem0[ebx + 4:word32];
		ecx = Mem0[ebx + 0x00:word32];
		SCZO = cond(ecx - eax);
		if (Test(EQ,Z))
		{
			eax = 0x03;
			return;
		}
		ebx = edx;
	}
	eax = 0x01;
}

// 08055010: define camlList__assoc_1169
define camlList__assoc_1169
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = eax;
		ecx = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = ecx;
		ecx = Mem0[ebx + 0x00:word32];
		ebx = Mem0[ecx + 4:word32];
		Mem0[esp + 8:word32] = ebx;
		ebx = Mem0[ecx + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = Mem0[esp + 8:word32];
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 080550A0: define camlList__assq_1174
define camlList__assq_1174
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		esi = Mem0[ebx + 4:word32];
		ecx = Mem0[ebx + 0x00:word32];
		edx = Mem0[ecx + 4:word32];
		ecx = Mem0[ecx + 0x00:word32];
		SCZO = cond(ecx - eax);
		if (Test(EQ,Z))
		{
			eax = edx;
			return;
		}
		ebx = esi;
	}
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 08055110: define camlList__mem_assoc_1179
define camlList__mem_assoc_1179
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = eax;
		ecx = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = ecx;
		ebx = Mem0[ebx + 0x00:word32];
		ebx = Mem0[ebx + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x03;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08055170: define camlList__mem_assq_1184
define camlList__mem_assq_1184
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		edx = Mem0[ebx + 4:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ecx = Mem0[ecx + 0x00:word32];
		SCZO = cond(ecx - eax);
		if (Test(EQ,Z))
		{
			eax = 0x03;
			return;
		}
		ebx = edx;
	}
	eax = 0x01;
}

// 080551B0: define camlList__remove_assoc_1189
// Called from:
//      camlList__remove_assoc_1189
define camlList__remove_assoc_1189
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(ebx - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x0C;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 0x00:word32] = eax;
		ecx = Mem0[ebx + 4:word32];
		Mem0[esp + 8:word32] = ecx;
		ebx = Mem0[ebx + 0x00:word32];
		Mem0[esp + 4:word32] = ebx;
		ebx = Mem0[ebx + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[esp + 0x00:word32];
			ebx = Mem0[esp + 8:word32];
			camlList__remove_assoc_1189();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 0x00:word32] = ebx;
			Mem0[eax + 4:word32] = ecx;
			esp += 0x0C;
			SCZO = cond(esp);
		}
		else
		{
			eax = Mem0[esp + 8:word32];
			esp += 0x0C;
			SCZO = cond(esp);
		}
	}
}

// 08055240: define camlList__remove_assq_1195
// Called from:
//      camlList__remove_assq_1195
define camlList__remove_assq_1195
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(ebx - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x04;
		SCZO = cond(esp);
	}
	else
	{
		esi = Mem0[ebx + 4:word32];
		edx = Mem0[ebx + 0x00:word32];
		ecx = Mem0[edx + 0x00:word32];
		SCZO = cond(ecx - eax);
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = edx;
			ebx = esi;
			camlList__remove_assq_1195();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			ebx = Mem0[esp + 0x00:word32];
			Mem0[eax + 0x00:word32] = ebx;
			Mem0[eax + 4:word32] = ecx;
			esp += 0x04;
			SCZO = cond(esp);
		}
		else
		{
			eax = esi;
			esp += 0x04;
			SCZO = cond(esp);
		}
	}
}

// 080552B0: define camlList__find_1201
define camlList__find_1201
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		Mem0[esp + 8:word32] = eax;
		ecx = Mem0[edx + 0x00:word32];
		ebx = edx;
		ecx();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[esp + 8:word32];
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 08055330: define camlList__find_all_1205
define camlList__find_all_1205
{
	esp = fp;
	Top = 0;
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 4343;
	Mem0[ebx + 0x00:word32] = 0x0804B370;
	Mem0[ebx + 4:word32] = 0x05;
	Mem0[ebx + 8:word32] = 0x08053C00;
	Mem0[ebx + 0x0C:word32] = ecx;
	eax = 0x01;
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
}

// 08055380: define camlList__partition_1212
define camlList__partition_1212
{
	esp = fp;
	Top = 0;
	esi = eax;
	ecx = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 4343;
	Mem0[edx + 0x00:word32] = 0x0804B2D0;
	Mem0[edx + 4:word32] = 0x07;
	Mem0[edx + 8:word32] = 0x08053C90;
	Mem0[edx + 0x0C:word32] = esi;
	ebx = 0x01;
	eax = 0x01;
	camlList__part_1215();
}

// 080553D0: define camlList__split_1220
// Called from:
//      camlList__split_1220
define camlList__split_1220
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x08078E28;
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		edx = Mem0[eax + 4:word32];
		ecx = Mem0[eax + 0x00:word32];
		ebx = Mem0[ecx + 4:word32];
		Mem0[esp + 0x00:word32] = ebx;
		ebx = Mem0[ecx + 0x00:word32];
		Mem0[esp + 4:word32] = ebx;
		eax = edx;
		camlList__split_1220();
		ebx = Mem0[eax + 4:word32];
		edx = Mem0[eax + 0x00:word32];
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x24;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ecx = eax + 4;
		Mem0[ecx + -4:word32] = 0x0800;
		eax = Mem0[esp + 0x00:word32];
		Mem0[ecx + 0x00:word32] = eax;
		Mem0[ecx + 4:word32] = ebx;
		ebx = ecx + 0x0C;
		Mem0[ebx + -4:word32] = 0x0800;
		eax = Mem0[esp + 4:word32];
		Mem0[ebx + 0x00:word32] = eax;
		Mem0[ebx + 4:word32] = edx;
		eax = ecx + 24;
		Mem0[eax + -4:word32] = 0x0800;
		Mem0[eax + 0x00:word32] = ebx;
		Mem0[eax + 4:word32] = ecx;
		esp += 0x08;
		SCZO = cond(esp);
	}
}

// 08055460: define camlList__combine_1226
// Called from:
//      camlList__combine_1226
define camlList__combine_1226
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		SCZO = cond(ebx - 0x01);
		if (Test(NE,Z))
		{
			esi = Mem0[ebx + 4:word32];
			ecx = Mem0[ebx + 0x00:word32];
			Mem0[esp + 4:word32] = ecx;
			edx = Mem0[eax + 4:word32];
			ecx = Mem0[eax + 0x00:word32];
			Mem0[esp + 0x00:word32] = ecx;
			eax = edx;
			ebx = esi;
			camlList__combine_1226();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x18;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			ebx = eax + 4;
			Mem0[ebx + -4:word32] = 0x0800;
			eax = Mem0[esp + 0x00:word32];
			Mem0[ebx + 0x00:word32] = eax;
			eax = Mem0[esp + 4:word32];
			Mem0[ebx + 4:word32] = eax;
			eax = ebx + 0x0C;
			Mem0[eax + -4:word32] = 0x0800;
			Mem0[eax + 0x00:word32] = ebx;
			Mem0[eax + 4:word32] = ecx;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
	}
	else
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x01;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
	}
	eax = 0x08078E14;
	esp += 0x08;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 08055500: define camlList__merge_1233
// Called from:
//      camlList__merge_1233
define camlList__merge_1233
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(ebx - 0x01);
	if (Test(EQ,Z))
	{
		eax = ecx;
		esp += 0x1C;
		SCZO = cond(esp);
	}
	else
	{
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
		{
			eax = ebx;
			esp += 0x1C;
			SCZO = cond(esp);
		}
		else
		{
			Mem0[esp + 20:word32] = ecx;
			Mem0[esp + 0x00:word32] = ebx;
			Mem0[esp + 0x0C:word32] = eax;
			edx = Mem0[ecx + 4:word32];
			Mem0[esp + 4:word32] = edx;
			edx = Mem0[ecx + 0x00:word32];
			Mem0[esp + 8:word32] = edx;
			ecx = Mem0[ebx + 4:word32];
			Mem0[esp + 16:word32] = ecx;
			eax = Mem0[ebx + 0x00:word32];
			Mem0[esp + 24:word32] = eax;
			ebx = edx;
			ecx = Mem0[esp + 0x0C:word32];
			caml_apply2();
			SCZO = cond(eax - 0x01);
			if (Test(GT,SZO))
			{
				eax = Mem0[esp + 0x0C:word32];
				ebx = Mem0[esp + 0x00:word32];
				ecx = Mem0[esp + 4:word32];
				camlList__merge_1233();
				ecx = eax;
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				ebx = eax + 4;
				Mem0[ebx + -4:word32] = 0x0800;
				eax = Mem0[esp + 8:word32];
				Mem0[ebx + 0x00:word32] = eax;
				Mem0[ebx + 4:word32] = ecx;
				eax = ebx;
				esp += 0x1C;
				SCZO = cond(esp);
			}
			else
			{
				eax = Mem0[esp + 0x0C:word32];
				ebx = Mem0[esp + 16:word32];
				ecx = Mem0[esp + 20:word32];
				camlList__merge_1233();
				ecx = eax;
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				ebx = eax + 4;
				Mem0[ebx + -4:word32] = 0x0800;
				eax = Mem0[esp + 24:word32];
				Mem0[ebx + 0x00:word32] = eax;
				Mem0[ebx + 4:word32] = ecx;
				eax = ebx;
				esp += 0x1C;
				SCZO = cond(esp);
			}
		}
	}
}

// 08055600: define camlList__chop_1243
// Called from:
//      camlList__rev_sort_1272
//      camlList__stable_sort_1248
define camlList__chop_1243
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
				{
					eax += 4;
					Mem0[eax + -4:word32] = 0x0800;
					Mem0[eax + 0x00:word32] = 134691556;
					Mem0[eax + 4:word32] = 0x08078DF8;
					fn08070A44();
				}
				fn080708CC();
			}
		}
		ebx = Mem0[ebx + 4:word32];
		eax += ~0x01;
		SCZO = cond(eax);
	}
	eax = ebx;
}

// 08055660: define camlList__stable_sort_1248
define camlList__stable_sort_1248
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	esi = eax;
	Mem0[esp + 4:word32] = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x54;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 4343;
	Mem0[edx + 0x00:word32] = 0x0804B2D0;
	Mem0[edx + 4:word32] = 0x07;
	Mem0[edx + 8:word32] = 0x08053DB0;
	Mem0[edx + 0x0C:word32] = esi;
	ecx = edx + 20;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B2D0;
	Mem0[ecx + 4:word32] = 0x07;
	Mem0[ecx + 8:word32] = 134561456;
	Mem0[ecx + 0x0C:word32] = esi;
	eax = edx + 40;
	Mem0[esp + 0x00:word32] = eax;
	Mem0[eax + -4:word32] = 0x28F7;
	Mem0[eax + 0x00:word32] = 0x0804B370;
	Mem0[eax + 4:word32] = 0x05;
	Mem0[eax + 8:word32] = 0x08054470;
	Mem0[eax + 0x0C:word32] = 4345;
	Mem0[eax + 16:word32] = 0x0804B370;
	Mem0[eax + 20:word32] = 0x05;
	Mem0[eax + 24:word32] = 0x08053FB0;
	Mem0[eax + 28:word32] = esi;
	Mem0[eax + 32:word32] = edx;
	Mem0[eax + 36:word32] = ecx;
	eax = 0x01;
	camlList__length_aux_1030();
	SCZO = cond(eax - 0x05);
	if (Test(GE,SO))
	{
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 0x00:word32];
		esp += 0x08;
		SCZO = cond(esp);
		camlList__sort_1271();
	}
	else
	{
		eax = Mem0[esp + 4:word32];
		esp += 0x08;
		SCZO = cond(esp);
	}
}

// 08055750: define camlList__entry
// Called from:
//      caml_program
define camlList__entry
{
	Top_3 = 0;
	Mem5[0x08078B98<p32>:word32] = 0x08078DD8;
	Mem7[0x08078AF4<p32>:word32] = 0x08078DCC;
	Mem9[0x08078AF8<p32>:word32] = 0x08078DC0;
	Mem11[0x08078AFC<p32>:word32] = 0x08078DB4;
	Mem13[0x08078B00<p32>:word32] = 0x08078DA4;
	eax_14 = Mem13[0x08076E48<p32>:word32];
	Mem15[0x08078B08<p32>:word32] = eax_14;
	Mem17[0x08078B0C<p32>:word32] = 134712724;
	Mem19[0x08078B04<p32>:word32] = 0x08078D88;
	Mem21[0x08078B14<p32>:word32] = 0x08078D7C;
	eax_22 = Mem21[0x08078B14<p32>:word32];
	Mem23[0x08078B10<p32>:word32] = eax_22;
	Mem25[0x08078B1C<p32>:word32] = 0x08078D6C;
	Mem27[0x08078B20<p32>:word32] = 0x08078D5C;
	Mem29[0x08078B18<p32>:word32] = 0x08078D4C;
	Mem31[0x08078B24<p32>:word32] = 0x08078D3C;
	Mem33[0x08078B28<p32>:word32] = 0x08078D2C;
	Mem35[0x08078B30<p32>:word32] = 0x08078D1C;
	Mem37[0x08078B34<p32>:word32] = 0x08078D0C;
	Mem39[0x08078B2C<p32>:word32] = 0x08078CFC;
	Mem41[0x08078B38<p32>:word32] = 0x08078CEC;
	Mem43[0x08078B3C<p32>:word32] = 0x08078CDC;
	Mem45[0x08078B40<p32>:word32] = 0x08078CCC;
	Mem47[0x08078B44<p32>:word32] = 0x08078CBC;
	Mem49[0x08078B48<p32>:word32] = 0x08078CAC;
	Mem51[0x08078B4C<p32>:word32] = 0x08078C9C;
	Mem53[0x08078B50<p32>:word32] = 0x08078C8C;
	Mem55[0x08078B54<p32>:word32] = 0x08078C7C;
	Mem57[0x08078B68<p32>:word32] = 0x08078C6C;
	Mem59[0x08078B6C<p32>:word32] = 0x08078C5C;
	Mem61[0x08078B70<p32>:word32] = 0x08078C4C;
	Mem63[0x08078B74<p32>:word32] = 0x08078C3C;
	Mem65[0x08078B78<p32>:word32] = 0x08078C2C;
	Mem67[0x08078B7C<p32>:word32] = 0x08078C1C;
	Mem69[0x08078B58<p32>:word32] = 0x08078C0C;
	Mem71[0x08078B60<p32>:word32] = 0x08078C00;
	eax_72 = Mem71[0x08078B60<p32>:word32];
	Mem73[0x08078B5C<p32>:word32] = eax_72;
	Mem75[0x08078B64<p32>:word32] = 0x08078BF0;
	Mem77[0x08078B80<p32>:word32] = 0x08078BE4;
	Mem79[0x08078B84<p32>:word32] = 0x08078BD4;
	Mem81[0x08078B94<p32>:word32] = 0x08078BC4;
	Mem83[0x08078B9C<p32>:word32] = 0x08078BB4;
	Mem85[0x08078B8C<p32>:word32] = 0x08078BA4;
	eax_86 = Mem85[0x08078B8C<p32>:word32];
	Mem87[0x08078B88<p32>:word32] = eax_86;
	eax_88 = Mem87[0x08078B8C<p32>:word32];
	Mem89[0x08078B90<p32>:word32] = eax_88;
	eax_90 = 0x01;
}

// 08055910: define camlChar__chr_1032
define camlChar__chr_1032
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(eax - 0x01FF);
		if (Test(LE,SZO))
			return;
	}
	eax = 134715124;
	camlPervasives__invalid_arg_1012();
}

// 08055930: define camlChar__escaped_1038
define camlChar__escaped_1038
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(eax - 0x4F);
	if (Test(EQ,Z))
	{
		eax = 0x080796C4;
		esp += 0x04;
		SCZO = cond(esp);
	}
	else
	{
		SCZO = cond(eax - 0xB9);
		if (Test(EQ,Z))
		{
			eax = 0x080796CC;
			esp += 0x04;
			SCZO = cond(esp);
		}
		else
		{
			Mem0[esp + 0x00:word32] = eax;
			SCZO = cond(eax - 0x1D);
			if (Test(GE,SO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x0806800D;
				fn080709D8();
				esp += 0x04;
				SCZO = cond(eax - 0x01);
				if (Test(EQ,Z))
				{
					eax = Mem0[esp + 0x00:word32];
					Mem0[esp + 0x00:word32] = eax;
					esp -= 4;
					Mem0[esp + 0x00:word32] = 0x09;
					eax = 0x08068247;
					fn080709D8();
					esp += 0x04;
					ebx = eax;
					edx = 0x5C;
					Mem0[ebx + 0x00:byte] = dl;
					ecx = 100;
					edi = Mem0[esp + 0x00:word32];
					eax = edi;
					eax >>= 0x01;
					edx_eax = CONVERT(eax, int32, int64);
					v16 = edx_eax;
					eax = CONVERT(v16 /32 ecx, word32, int32);
					edx = eax + 97 + eax;
					edx >>= 0x01;
					Mem0[ebx + 1:byte] = dl;
					esi = 0x0A;
					ecx = 0x0A;
					eax = edi;
					eax >>= 0x01;
					edx_eax = CONVERT(eax, int32, int64);
					v18 = edx_eax;
					eax = CONVERT(v18 /32 ecx, word32, int32);
					ecx = esi;
					edx_eax = CONVERT(eax, int32, int64);
					v19 = edx_eax;
					edx = CONVERT(v19 %s ecx, int64, int32);
					eax = CONVERT(v19 /32 ecx, word32, int32);
					edx = edx + 97 + edx;
					edx >>= 0x01;
					Mem0[ebx + 2:byte] = dl;
					ecx = 0x0A;
					eax = edi;
					eax >>= 0x01;
					edx_eax = CONVERT(eax, int32, int64);
					v20 = edx_eax;
					edx = CONVERT(v20 %s ecx, int64, int32);
					eax = CONVERT(v20 /32 ecx, word32, int32);
					edx = edx + 97 + edx;
					edx >>= 0x01;
					Mem0[ebx + 3:byte] = dl;
					eax = ebx;
					esp += 0x04;
					SCZO = cond(esp);
				}
				else
				{
					esp -= 4;
					Mem0[esp + 0x00:word32] = 0x03;
					eax = 0x08068247;
					fn080709D8();
					esp += 0x04;
					edx = Mem0[esp + 0x00:word32];
					edx >>= 0x01;
					Mem0[eax + 0x00:byte] = dl;
					esp += 0x04;
					SCZO = cond(esp);
				}
			}
			else
			{
				ebx = eax;
				ebx >>= 0x01;
				SCZ = cond(ebx);
				O = false;
				0x08079700[ebx * 0x04]();
			}
		}
	}
}

// 08055A60: define camlChar__lowercase_1043
define camlChar__lowercase_1043
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 131);
	if (Test(GE,SO))
	{
		SCZO = cond(eax - 181);
		if (Test(LE,SZO))
			goto l08055A90;
	}
	SCZO = cond(eax - 0x0181);
	if (Test(GE,SO))
	{
		SCZO = cond(eax - 0x01AD);
		if (Test(LE,SZO))
			goto l08055A90;
	}
	SCZO = cond(eax - 0x01B1);
	if (Test(LT,SO))
		return;
	SCZO = cond(eax - 445);
	if (Test(GT,SZO))
		return;
l08055A90:
	eax += 0x40;
	SCZO = cond(eax);
}

// 08055AA0: define camlChar__uppercase_1045
define camlChar__uppercase_1045
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0xC3);
	if (Test(GE,SO))
	{
		SCZO = cond(eax - 0xF5);
		if (Test(LE,SZO))
			goto l08055AD0;
	}
	SCZO = cond(eax - 0x01C1);
	if (Test(GE,SO))
	{
		SCZO = cond(eax - 0x01ED);
		if (Test(LE,SZO))
			goto l08055AD0;
	}
	SCZO = cond(eax - 0x01F1);
	if (Test(LT,SO))
		return;
	SCZO = cond(eax - 0x01FD);
	if (Test(GT,SZO))
		return;
l08055AD0:
	eax += ~0x3F;
	SCZO = cond(eax);
}

// 08055AE0: define camlChar__compare_1048
define camlChar__compare_1048
{
	esp = fp;
	Top = 0;
	eax -= ebx;
	SCZO = cond(eax);
	++eax;
	SZO = cond(eax);
}

// 08055AF0: define camlChar__entry
// Called from:
//      caml_program
define camlChar__entry
{
	Top_3 = 0;
	Mem5[0x0807966C<p32>:word32] = 0x080796B8;
	Mem7[0x08079670<p32>:word32] = 0x080796AC;
	Mem9[0x08079674<p32>:word32] = 0x080796A0;
	Mem11[0x08079678<p32>:word32] = 0x08079694;
	Mem13[0x0807967C<p32>:word32] = 0x08079684;
	eax_14 = 0x01;
}

// 08055B30: define camlString__fun_1160
define camlString__fun_1160
{
	esp = fp;
	Top = 0;
	ecx = Mem0[ebx + 8:word32];
	v6 = Mem0[ecx + 0x00:word32] + 0x02;
	Mem0[ecx + 0x00:word32] = v6;
	ecx = Mem0[ebx + 0x0C:word32];
	edx = Mem0[eax + -4:word32];
	edx >>= 0x0A;
	edx = ~0x00 + edx * 0x04;
	eax = CONVERT(Mem0[eax + edx:byte], byte, word32);
	edx -= eax;
	SCZO = cond(edx);
	eax = Mem0[ebx + 0x0C:word32];
	eax = Mem0[eax + 0x00:word32];
	eax += edx * 0x02;
	Mem0[ecx + 0x00:word32] = eax;
	eax = 0x01;
}

// 08055B60: define camlString__fun_1163
define camlString__fun_1163
{
	esp = fp;
	Top = 0;
	esi = eax;
	ecx = Mem0[ebx + 8:word32];
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ecx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ecx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[ebx + 16:word32];
	v9 = Mem0[eax + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v9;
	v10 = Mem0[ebx + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v10;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	v11 = Mem0[ebx + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v11;
	caml_blit_string();
	esp += 0x14;
	eax = Mem0[ebx + 16:word32];
	edi = Mem0[ebx + 8:word32];
	ecx = Mem0[edi + -4:word32];
	ecx >>= 0x0A;
	edx = ~0x00 + ecx * 0x04;
	ecx = CONVERT(Mem0[edi + edx:byte], byte, word32);
	edx -= ecx;
	ecx = Mem0[ebx + 16:word32];
	ecx = Mem0[ecx + 0x00:word32];
	ecx += edx * 0x02;
	Mem0[eax + 0x00:word32] = ecx;
	eax = Mem0[esi + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ecx = CONVERT(Mem0[esi + eax:byte], byte, word32);
	eax -= ecx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[ebx + 16:word32];
	v14 = Mem0[eax + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v14;
	v15 = Mem0[ebx + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v15;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	caml_blit_string();
	esp += 0x14;
	eax = Mem0[ebx + 16:word32];
	ecx = Mem0[esi + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	edx = CONVERT(Mem0[esi + ecx:byte], byte, word32);
	ecx -= edx;
	SCZO = cond(ecx);
	ebx = Mem0[ebx + 16:word32];
	ebx = Mem0[ebx + 0x00:word32];
	ebx += ecx * 0x02;
	Mem0[eax + 0x00:word32] = ebx;
	eax = 0x01;
}

// 08055C10: define camlString__make_1038
// Called from:
//      camlPrintf__scan_conv_1143
//      camlPrintf__format_string_1080
define camlString__make_1038
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068247;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	caml_fill_string();
	esp += 0x10;
	eax = ebx;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08055C50: define camlString__copy_1042
// Called from:
//      camlString__uncapitalize_1106
define camlString__copy_1042
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	ecx = eax;
	Mem0[esp + 4:word32] = ecx;
	ebx = Mem0[ecx + -4:word32];
	ebx >>= 0x0A;
	eax = ~0x00 + ebx * 0x04;
	ebx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ebx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068247;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ebx = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	eax = Mem0[esp + 20:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	caml_blit_string();
	esp += 0x14;
	eax = ebx;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08055CA0: define camlString__sub_1046
// Called from:
//      camlBuffer__contents_1044
//      camlBuffer__find_ident_1114
//      camlPrintf__parse_1069
//      camlPrintf__scan_conv_1143
//      camlPrintf__scan_flags_1142
//      camlPrintf__sub_1050
//      camlPrintf__to_string_1054
//      camlPrintf__format_string_1080
//      camlPrintf__extract_format_1085
//      camlPrintf__summarize_format_type_1162
//      camlPrintf__get_contents_1405
//      camlPrintf__get_cont_1408
define camlString__sub_1046
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(GE,SO))
		{
			edx = Mem0[eax + -4:word32];
			edx >>= 0x0A;
			edx = ~0x00 + edx * 0x04;
			esi = CONVERT(Mem0[eax + edx:byte], byte, word32);
			edx -= esi;
			edx <<= 0x01;
			edx -= ecx;
			edx += 0x02;
			SCZO = cond(ebx - edx);
			if (Test(LE,SZO))
			{
				Mem0[esp + 0x00:word32] = ecx;
				Mem0[esp + 4:word32] = ebx;
				Mem0[esp + 8:word32] = eax;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				eax = 0x08068247;
				fn080709D8();
				esp += 0x04;
				SCZO = cond(esp);
				ebx = eax;
				eax = Mem0[esp + 0x00:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				esp -= 4;
				Mem0[esp + 0x00:word32] = 0x01;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				eax = Mem0[esp + 16:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = Mem0[esp + 24:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_blit_string();
				esp += 0x14;
				eax = ebx;
				esp += 0x0C;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x080799EC;
	esp += 0x0C;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 08055D20: define camlString__fill_1051
define camlString__fill_1051
{
	esp = fp;
	Top = 0;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(GE,SO))
		{
			esi = Mem0[eax + -4:word32];
			esi >>= 0x0A;
			esi = ~0x00 + esi * 0x04;
			edi = CONVERT(Mem0[eax + esi:byte], byte, word32);
			esi -= edi;
			esi <<= 0x01;
			esi -= ecx;
			esi += 0x02;
			SCZO = cond(ebx - esi);
			if (Test(LE,SZO))
			{
				esp -= 4;
				Mem0[esp + 0x00:word32] = edx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_fill_string();
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x080799DC;
	camlPervasives__invalid_arg_1012();
}

// 08055D70: define camlString__blit_1056
// Called from:
//      camlBuffer__sub_1046
//      camlBuffer__blit_1051
//      camlBuffer__resize_1066
//      camlBuffer__add_substring_1076
//      camlBuffer__add_string_1082
//      camlPrintf__format_string_1080
define camlString__blit_1056
{
	esp = fp;
	Top = 0;
	SCZO = cond(esi - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(ebx - 0x01);
		if (Test(GE,SO))
		{
			edi = Mem0[eax + -4:word32];
			edi >>= 0x0A;
			ebp = ~0x00 + edi * 0x04;
			edi = CONVERT(Mem0[eax + ebp:byte], byte, word32);
			ebp -= edi;
			ebp <<= 0x01;
			ebp -= esi;
			ebp += 0x02;
			SCZO = cond(ebx - ebp);
			if (Test(LE,SZO))
			{
				SCZO = cond(edx - 0x01);
				if (Test(GE,SO))
				{
					edi = Mem0[ecx + -4:word32];
					edi >>= 0x0A;
					ebp = ~0x00 + edi * 0x04;
					edi = CONVERT(Mem0[ecx + ebp:byte], byte, word32);
					ebp -= edi;
					edi = ebp;
					edi <<= 0x01;
					edi -= esi;
					edi += 0x02;
					SCZO = cond(edx - edi);
					if (Test(LE,SZO))
					{
						esp -= 4;
						Mem0[esp + 0x00:word32] = esi;
						esp -= 4;
						Mem0[esp + 0x00:word32] = edx;
						esp -= 4;
						Mem0[esp + 0x00:word32] = ecx;
						esp -= 4;
						Mem0[esp + 0x00:word32] = ebx;
						esp -= 4;
						Mem0[esp + 0x00:word32] = eax;
						caml_blit_string();
						esp += 0x14;
						SCZO = cond(esp);
						return;
					}
				}
			}
		}
	}
	eax = 0x080799CC;
	camlPervasives__invalid_arg_1012();
}

// 08055DE0: define camlString__iter_1062
define camlString__iter_1062
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	ecx = 0x01;
	edx = Mem0[ebx + -4:word32];
	edx >>= 0x0A;
	edx = ~0x00 + edx * 0x04;
	esi = CONVERT(Mem0[ebx + edx:byte], byte, word32);
	edx -= esi;
	edx = edx - 1 + edx;
	SCZO = cond(ecx - edx);
	if (Test(LE,SZO))
	{
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 4:word32] = eax;
		do
		{
			ecx >>= 0x01;
			SCZ = cond(ecx);
			O = false;
			eax = Mem0[esp + 0x00:word32];
			eax = CONVERT(Mem0[eax + ecx:byte], byte, word32);
			eax = eax + 1 + eax;
			ebx = Mem0[esp + 4:word32];
			ecx = Mem0[ebx + 0x00:word32];
			ecx();
			ecx = Mem0[esp + 8:word32];
			ebx = ecx;
			ecx += 0x02;
			Mem0[esp + 8:word32] = ecx;
			eax = Mem0[esp + 0x0C:word32];
			SCZO = cond(ebx - eax);
		} while (Test(NE,Z));
	}
	eax = 0x01;
	esp += 0x10;
	SCZO = cond(esp);
}

// 08055E50: define camlString__concat_1066
define camlString__concat_1066
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(ebx - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x080799C4;
		esp += 0x14;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 0x0C:word32] = eax;
		eax = Mem0[ebx + 4:word32];
		Mem0[esp + 16:word32] = eax;
		eax = Mem0[ebx + 0x00:word32];
		Mem0[esp + 8:word32] = eax;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x24;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		edx = eax + 4;
		Mem0[esp + 0x00:word32] = edx;
		Mem0[edx + -4:word32] = 0x0400;
		Mem0[edx + 0x00:word32] = 0x01;
		ecx = edx + 8;
		Mem0[esp + 4:word32] = ecx;
		Mem0[ecx + -4:word32] = 0x0400;
		Mem0[ecx + 0x00:word32] = 0x01;
		eax = edx + 16;
		Mem0[eax + -4:word32] = 4343;
		Mem0[eax + 0x00:word32] = 0x08055B30;
		Mem0[eax + 4:word32] = 0x03;
		Mem0[eax + 8:word32] = edx;
		Mem0[eax + 0x0C:word32] = ecx;
		camlList__iter_1074();
		eax = Mem0[esp + 0x00:word32];
		eax = Mem0[eax + 0x00:word32];
		eax += ~0x01;
		eax >>= 0x01;
		ebx = Mem0[esp + 0x0C:word32];
		ecx = Mem0[ebx + -4:word32];
		ecx >>= 0x0A;
		ecx = ~0x00 + ecx * 0x04;
		ebx = CONVERT(Mem0[ebx + ecx:byte], byte, word32);
		ecx -= ebx;
		ecx <<= 0x01;
		ecx *= eax;
		eax = Mem0[esp + 4:word32];
		eax = Mem0[eax + 0x00:word32];
		eax += ecx;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x08068247;
		fn080709D8();
		esp += 0x04;
		edi = eax;
		Mem0[esp + 0x00:word32] = edi;
		esi = Mem0[esp + 8:word32];
		eax = Mem0[esi + -4:word32];
		eax >>= 0x0A;
		eax = ~0x00 + eax * 0x04;
		ebx = CONVERT(Mem0[esi + eax:byte], byte, word32);
		eax -= ebx;
		SCZO = cond(eax);
		eax = eax + 1 + eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x01;
		esp -= 4;
		Mem0[esp + 0x00:word32] = edi;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x01;
		esp -= 4;
		Mem0[esp + 0x00:word32] = esi;
		caml_blit_string();
		esp += 0x14;
		SCZO = cond(esp);
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x20;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ebx = eax + 4;
		Mem0[ebx + -4:word32] = 0x0400;
		eax = Mem0[esi + -4:word32];
		eax >>= 0x0A;
		eax = ~0x00 + eax * 0x04;
		ecx = CONVERT(Mem0[esi + eax:byte], byte, word32);
		eax -= ecx;
		SCZO = cond(eax);
		eax = eax + 1 + eax;
		Mem0[ebx + 0x00:word32] = eax;
		eax = ebx + 8;
		Mem0[eax + -4:word32] = 0x14F7;
		Mem0[eax + 0x00:word32] = 0x08055B60;
		Mem0[eax + 4:word32] = 0x03;
		ecx = Mem0[esp + 0x0C:word32];
		Mem0[eax + 8:word32] = ecx;
		Mem0[eax + 0x0C:word32] = edi;
		Mem0[eax + 16:word32] = ebx;
		ebx = Mem0[esp + 16:word32];
		camlList__iter_1074();
		eax = Mem0[esp + 0x00:word32];
		esp += 0x14;
		SCZO = cond(esp);
	}
}

// 08055FD0: define camlString__escaped_1080
define camlString__escaped_1080
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
	edx = eax;
	Mem0[esp + 16:word32] = edx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0400;
	Mem0[ebx + 0x00:word32] = 0x01;
	eax = 0x01;
	ecx = Mem0[edx + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	edx = CONVERT(Mem0[edx + ecx:byte], byte, word32);
	ecx -= edx;
	ecx = ecx - 1 + ecx;
	SCZO = cond(eax - ecx);
	if (Test(LE,SZO))
	{
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 0x00:word32] = eax;
		Mem0[esp + 20:word32] = ebx;
		do
		{
			eax >>= 0x01;
			ebx = Mem0[esp + 16:word32];
			eax = CONVERT(Mem0[ebx + eax:byte], byte, word32);
			eax = eax + 1 + eax;
			SCZO = cond(eax - 0x1D);
			if (Test(GE,SO))
			{
				SCZO = cond(eax - 0x45);
				if (Test(EQ,Z))
					goto l080560A0;
				SCZO = cond(eax - 0xB9);
				if (Test(NE,Z))
					goto l08056075;
				goto l080560A0;
			}
			SCZO = cond(eax - 0x17);
			if (Test(GE,SO))
			{
				SCZO = cond(eax - 0x1B);
				if (Test(LT,SO))
					goto l08056075;
				goto l080560A0;
			}
			SCZO = cond(eax - 0x11);
			if (Test(LT,SO))
			{
l08056075:
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x0806800D;
				fn080709D8();
				esp += 0x04;
				SCZO = cond(eax - 0x01);
				if (Test(NE,Z))
					ecx = 0x03;
				else
					ecx = 0x09;
			}
			else
			{
l080560A0:
				ecx = 0x05;
			}
			ebx = Mem0[esp + 20:word32];
			eax = Mem0[ebx + 0x00:word32];
			eax += ecx;
			--eax;
			Mem0[ebx + 0x00:word32] = eax;
			eax = Mem0[esp + 0x00:word32];
			edx = eax;
			eax += 0x02;
			Mem0[esp + 0x00:word32] = eax;
			ecx = Mem0[esp + 4:word32];
			SCZO = cond(edx - ecx);
		} while (Test(NE,Z));
	}
	eax = Mem0[esp + 16:word32];
	ecx = Mem0[eax + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	edx = CONVERT(Mem0[eax + ecx:byte], byte, word32);
	ecx -= edx;
	edx = ecx + 1 + ecx;
	ecx = Mem0[ebx + 0x00:word32];
	SCZO = cond(ecx - edx);
	if (Test(NE,Z))
	{
		Mem0[esp + 20:word32] = ebx;
		Mem0[esp + 16:word32] = eax;
		v15 = Mem0[ebx + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = v15;
		eax = 0x08068247;
		fn080709D8();
		esp += 0x04;
		ebp = eax;
		esi = Mem0[esp + 20:word32];
		Mem0[esi + 0x00:word32] = 0x01;
		eax = 0x01;
		ebx = Mem0[esp + 16:word32];
		ecx = Mem0[ebx + -4:word32];
		ecx >>= 0x0A;
		ecx = ~0x00 + ecx * 0x04;
		edx = CONVERT(Mem0[ebx + ecx:byte], byte, word32);
		ecx -= edx;
		ecx = ecx - 1 + ecx;
		SCZO = cond(eax - ecx);
		if (Test(LE,SZO))
		{
			Mem0[esp + 8:word32] = ecx;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x0C:word32] = ebp;
			Mem0[esp + 20:word32] = esi;
			Mem0[esp + 16:word32] = ebx;
			do
			{
				eax >>= 0x01;
				ebx = Mem0[esp + 16:word32];
				eax = CONVERT(Mem0[ebx + eax:byte], byte, word32);
				eax = eax + 1 + eax;
				ebx = eax;
				ebx += ~0x43;
				SCZO = cond(ebx - 117);
				if (Test(UGT,CZ))
				{
					SCZO = cond(ebx - ~0x26);
					if (Test(LT,SO))
					{
						ebx += 0x44;
						ebx >>= 0x01;
						SCZ = cond(ebx);
						O = false;
					}
					goto l08056270;
				}
				ebx += ~0x01;
				SCZO = cond(ebx - 113);
				if (Test(UGT,CZ))
				{
					ebx = Mem0[esi + 0x00:word32];
					ebx >>= 0x01;
					edx = 0x5C;
					Mem0[ebp + ebx:byte] = dl;
					v20 = Mem0[esi + 0x00:word32] + 0x02;
					Mem0[esi + 0x00:word32] = v20;
					ebx = Mem0[esi + 0x00:word32];
					ebx >>= 0x01;
					eax >>= 0x01;
					SCZ = cond(eax);
					O = false;
					edx = eax;
					Mem0[ebp + ebx:byte] = dl;
				}
				else
				{
l08056270:
					Mem0[esp + 0x00:word32] = eax;
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					eax = 0x0806800D;
					fn080709D8();
					esp += 0x04;
					SCZO = cond(eax - 0x01);
					if (Test(NE,Z))
					{
						esi = Mem0[esp + 20:word32];
						eax = Mem0[esi + 0x00:word32];
						eax >>= 0x01;
						edx = Mem0[esp + 0x00:word32];
						edx >>= 0x01;
						SCZ = cond(edx);
						O = false;
						ebp = Mem0[esp + 0x0C:word32];
						Mem0[ebp + eax:byte] = dl;
					}
					else
					{
						edi = Mem0[esp + 0x00:word32];
						esi = Mem0[esp + 20:word32];
						eax = Mem0[esi + 0x00:word32];
						eax >>= 0x01;
						edx = 0x5C;
						ebp = Mem0[esp + 0x0C:word32];
						Mem0[ebp + eax:byte] = dl;
						v23 = Mem0[esi + 0x00:word32] + 0x02;
						Mem0[esi + 0x00:word32] = v23;
						ebx = Mem0[esi + 0x00:word32];
						ebx >>= 0x01;
						ecx = 100;
						eax = edi;
						eax >>= 0x01;
						edx_eax = CONVERT(eax, int32, int64);
						v25 = edx_eax;
						eax = CONVERT(v25 /32 ecx, word32, int32);
						edx = eax + 97 + eax;
						edx >>= 0x01;
						Mem0[ebp + ebx:byte] = dl;
						v26 = Mem0[esi + 0x00:word32] + 0x02;
						Mem0[esi + 0x00:word32] = v26;
						ebx = Mem0[esi + 0x00:word32];
						ebx >>= 0x01;
						eax = 0x0A;
						Mem0[esp + 0x00:word32] = eax;
						ecx = 0x0A;
						eax = edi;
						eax >>= 0x01;
						edx_eax = CONVERT(eax, int32, int64);
						v27 = edx_eax;
						eax = CONVERT(v27 /32 ecx, word32, int32);
						ecx = Mem0[esp + 0x00:word32];
						edx_eax = CONVERT(eax, int32, int64);
						v28 = edx_eax;
						edx = CONVERT(v28 %s ecx, int64, int32);
						eax = CONVERT(v28 /32 ecx, word32, int32);
						edx = edx + 97 + edx;
						edx >>= 0x01;
						Mem0[ebp + ebx:byte] = dl;
						v29 = Mem0[esi + 0x00:word32] + 0x02;
						Mem0[esi + 0x00:word32] = v29;
						ebx = Mem0[esi + 0x00:word32];
						ebx >>= 0x01;
						ecx = 0x0A;
						eax = edi;
						eax >>= 0x01;
						edx_eax = CONVERT(eax, int32, int64);
						v30 = edx_eax;
						edx = CONVERT(v30 %s ecx, int64, int32);
						eax = CONVERT(v30 /32 ecx, word32, int32);
						edx = edx + 97 + edx;
						edx >>= 0x01;
						SCZ = cond(edx);
						O = false;
						Mem0[ebp + ebx:byte] = dl;
					}
				}
				v21 = Mem0[esi + 0x00:word32] + 0x02;
				Mem0[esi + 0x00:word32] = v21;
				eax = Mem0[esp + 4:word32];
				ecx = eax;
				eax += 0x02;
				Mem0[esp + 4:word32] = eax;
				ebx = Mem0[esp + 8:word32];
				SCZO = cond(ecx - ebx);
			} while (Test(NE,Z));
		}
		eax = ebp;
		esp += 0x18;
		SCZO = cond(esp);
	}
	else
	{
		esp += 0x18;
		SCZO = cond(esp);
	}
}

// 08056350: define camlString__map_1090
// Called from:
//      camlString__uppercase_1096
//      camlString__lowercase_1098
define camlString__map_1090
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	ecx = Mem0[ebx + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	edx = CONVERT(Mem0[ebx + ecx:byte], byte, word32);
	ecx -= edx;
	ecx = ecx + 1 + ecx;
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 8:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ecx;
		eax = 0x08068247;
		fn080709D8();
		esp += 0x04;
		ebx = 0x01;
		ecx = Mem0[esp + 0x00:word32];
		ecx += ~0x01;
		SCZO = cond(ebx - ecx);
		if (Test(LE,SZO))
		{
			Mem0[esp + 16:word32] = ecx;
			Mem0[esp + 0x00:word32] = ebx;
			Mem0[esp + 0x0C:word32] = eax;
			do
			{
				ebx >>= 0x01;
				SCZ = cond(ebx);
				O = false;
				eax = Mem0[esp + 4:word32];
				eax = CONVERT(Mem0[eax + ebx:byte], byte, word32);
				eax = eax + 1 + eax;
				ebx = Mem0[esp + 8:word32];
				ecx = Mem0[ebx + 0x00:word32];
				ecx();
				eax >>= 0x01;
				ebx = Mem0[esp + 0x00:word32];
				ecx = ebx;
				ecx >>= 0x01;
				edx = eax;
				eax = Mem0[esp + 0x0C:word32];
				Mem0[eax + ecx:byte] = dl;
				edx = ebx;
				ebx += 0x02;
				Mem0[esp + 0x00:word32] = ebx;
				ecx = Mem0[esp + 16:word32];
				SCZO = cond(edx - ecx);
			} while (Test(NE,Z));
		}
		esp += 0x14;
		SCZO = cond(esp);
	}
	else
	{
		eax = ebx;
		esp += 0x14;
		SCZO = cond(esp);
	}
}

// 080563F0: define camlString__uppercase_1096
define camlString__uppercase_1096
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08079678<p32>:word32];
	camlString__map_1090();
}

// 08056400: define camlString__lowercase_1098
define camlString__lowercase_1098
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08079674<p32>:word32];
	camlString__map_1090();
}

// 08056410: define camlString__apply1_1100
// Called from:
//      camlString__capitalize_1104
//      camlString__uncapitalize_1106
define camlString__apply1_1100
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	ecx = Mem0[ebx + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	edx = CONVERT(Mem0[ebx + ecx:byte], byte, word32);
	ecx -= edx;
	ecx = ecx + 1 + ecx;
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 4:word32] = eax;
		eax = ebx;
		camlString__copy_1042();
		Mem0[esp + 8:word32] = eax;
		eax = Mem0[esp + 0x00:word32];
		eax = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
		eax = eax + 1 + eax;
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
		eax >>= 0x01;
		edx = eax;
		eax = Mem0[esp + 8:word32];
		Mem0[eax + 0x00:byte] = dl;
		esp += 0x0C;
		SCZO = cond(esp);
	}
	else
	{
		eax = ebx;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 08056480: define camlString__capitalize_1104
define camlString__capitalize_1104
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08079678<p32>:word32];
	camlString__apply1_1100();
}

// 08056490: define camlString__uncapitalize_1106
define camlString__uncapitalize_1106
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = Mem0[0x08079674<p32>:word32];
	camlString__apply1_1100();
}

// 080564A0: define camlString__index_rec_1108
// Called from:
//      camlString__index_1113
//      camlString__index_from_1116
//      fn08056680
define camlString__index_rec_1108
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ecx - ebx);
		if (Test(GE,SO))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
		}
		esi = ecx;
		esi >>= 0x01;
		esi = CONVERT(Mem0[eax + esi:byte], byte, word32);
		esi = esi + 1 + esi;
		SCZO = cond(esi - edx);
		if (Test(EQ,Z))
			break;
		ecx += 0x02;
		SCZO = cond(ecx);
	}
	eax = ecx;
}

// 08056500: define camlString__index_1113
define camlString__index_1113
{
	esp = fp;
	Top = 0;
	edx = ebx;
	ecx = 0x01;
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	esi = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= esi;
	SCZO = cond(ebx);
	ebx = ebx + 1 + ebx;
	camlString__index_rec_1108();
}

// 08056530: define camlString__index_from_1116
define camlString__index_from_1116
{
	esp = fp;
	Top = 0;
	esi = ebx;
	edx = ecx;
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= ecx;
	ebx = ebx + 1 + ebx;
	SCZO = cond(esi - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(esi - ebx);
		if (Test(LE,SZO))
		{
			ecx = esi;
			camlString__index_rec_1108();
			return;
		}
	}
	eax = 0x080799AC;
	camlPervasives__invalid_arg_1012();
}

// 08056570: define camlString__rindex_rec_1121
// Called from:
//      camlString__rindex_1125
//      camlString__rindex_from_1128
//      fn08056720
define camlString__rindex_rec_1121
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(LT,SO))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
		}
		edx = ebx;
		edx >>= 0x01;
		edx = CONVERT(Mem0[eax + edx:byte], byte, word32);
		edx = edx + 1 + edx;
		SCZO = cond(edx - ecx);
		if (Test(EQ,Z))
			break;
		ebx += ~0x01;
		SCZO = cond(ebx);
	}
	eax = ebx;
}

// 080565D0: define camlString__rindex_1125
define camlString__rindex_1125
{
	esp = fp;
	Top = 0;
	ecx = ebx;
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	edx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= edx;
	SCZO = cond(ebx);
	ebx = ebx - 1 + ebx;
	camlString__rindex_rec_1121();
}

// 080565F0: define camlString__rindex_from_1128
define camlString__rindex_from_1128
{
	esp = fp;
	Top = 0;
	SCZO = cond(ebx - ~0x00);
	if (Test(GE,SO))
	{
		edx = Mem0[eax + -4:word32];
		edx >>= 0x0A;
		edx = ~0x00 + edx * 0x04;
		esi = CONVERT(Mem0[eax + edx:byte], byte, word32);
		edx -= esi;
		edx = edx + 1 + edx;
		SCZO = cond(ebx - edx);
		if (Test(LT,SO))
		{
			camlString__rindex_rec_1121();
			return;
		}
	}
	eax = 0x08079994;
	camlPervasives__invalid_arg_1012();
}

// 08056630: define camlString__contains_from_1132
// Called from:
//      camlString__contains_1137
define camlString__contains_from_1132
{
	esp = fp;
	Top = 0;
	esi = ebx;
	edx = ecx;
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= ecx;
	ebx = ebx + 1 + ebx;
	SCZO = cond(esi - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(esi - ebx);
		if (Test(LE,SZO))
		{
			fn08056680();
			ecx = 134691416;
			ebx = Mem0[eax + 0x00:word32];
			SCZO = cond(ebx - ecx);
			if (Test(NE,Z))
			{
				fn08070A44();
				esi = esi;
				edi += 0x00;
				fn08056680();
				return;
			}
			else
			{
				eax = 0x01;
				return;
			}
		}
	}
	eax = 0x08079978;
	camlPervasives__invalid_arg_1012();
}

// 08056680: define fn08056680
// Called from:
//      camlString__contains_1137
define fn08056680
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	ecx = esi;
	camlString__index_rec_1108();
	eax = 0x03;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
}

// 080566C0: define camlString__contains_1137
define camlString__contains_1137
{
	esp = fp;
	Top = 0;
	ecx = ebx;
	ebx = 0x01;
	camlString__contains_from_1132();
}

// 080566D0: define camlString__rcontains_from_1140
define camlString__rcontains_from_1140
{
	esp = fp;
	Top = 0;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		edx = Mem0[eax + -4:word32];
		edx >>= 0x0A;
		edx = ~0x00 + edx * 0x04;
		esi = CONVERT(Mem0[eax + edx:byte], byte, word32);
		edx -= esi;
		edx = edx + 1 + edx;
		SCZO = cond(ebx - edx);
		if (Test(LT,SO))
		{
			fn08056720();
			ecx = 134691416;
			ebx = Mem0[eax + 0x00:word32];
			SCZO = cond(ebx - ecx);
			if (Test(NE,Z))
			{
				fn08070A44();
				esi = esi;
				edi += 0x00;
				fn08056720();
				return;
			}
			else
			{
				eax = 0x01;
				return;
			}
		}
	}
	eax = 0x0807995C;
	camlPervasives__invalid_arg_1012();
}

// 08056720: define fn08056720
// Called from:
//      camlString__rcontains_from_1140
define fn08056720
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	camlString__rindex_rec_1121();
	eax = 0x03;
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08056750: define camlString__compare_1145
define camlString__compare_1145
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	caml_string_compare();
	esp += 0x08;
	SCZO = cond(esp);
}

// 08056760: define camlString__entry
// Called from:
//      caml_program
define camlString__entry
{
	Top_3 = 0;
	Mem5[0x08079790<p32>:word32] = 0x0807994C;
	Mem7[0x08079794<p32>:word32] = 0x08079940;
	Mem9[0x08079798<p32>:word32] = 0x08079930;
	Mem11[0x0807979C<p32>:word32] = 0x08079920;
	Mem13[0x080797A0<p32>:word32] = 0x08079910;
	Mem15[0x080797A8<p32>:word32] = 0x08079900;
	Mem17[0x080797A4<p32>:word32] = 0x080798F0;
	Mem19[0x080797AC<p32>:word32] = 0x080798E4;
	Mem21[0x080797E0<p32>:word32] = 0x080798D4;
	Mem23[0x080797CC<p32>:word32] = 0x080798C8;
	Mem25[0x080797D0<p32>:word32] = 0x080798BC;
	Mem27[0x080797E4<p32>:word32] = 0x080798AC;
	Mem29[0x080797D4<p32>:word32] = 0x080798A0;
	Mem31[0x080797D8<p32>:word32] = 0x08079894;
	Mem33[0x080797E8<p32>:word32] = 0x08079884;
	Mem35[0x080797B0<p32>:word32] = 0x08079874;
	Mem37[0x080797B8<p32>:word32] = 0x08079864;
	Mem39[0x080797EC<p32>:word32] = 0x08079854;
	Mem41[0x080797B4<p32>:word32] = 0x08079844;
	Mem43[0x080797BC<p32>:word32] = 134715444;
	Mem45[0x080797C4<p32>:word32] = 0x08079824;
	Mem47[0x080797C0<p32>:word32] = 0x08079814;
	Mem49[0x080797C8<p32>:word32] = 0x08079804;
	Mem51[0x080797DC<p32>:word32] = 0x080797F4;
	eax_52 = 0x01;
}

// 08056860: define camlSys__fun_1093
define camlSys__fun_1093
{
	esp = fp;
	Top = 0;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			ebx = Mem0[0x08079C8C<p32>:word32];
			Mem0[eax + 0x00:word32] = ebx;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 080568A0: define camlSys__set_signal_1057
// Called from:
//      camlSys__catch_break_1082
define camlSys__set_signal_1057
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134623326;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	eax = 0x01;
}

// 080568C0: define camlSys__catch_break_1082
define camlSys__catch_break_1082
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		ebx = 0x01;
		eax = ~0x0A;
		camlSys__set_signal_1057();
	}
	else
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x08;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ebx = eax + 4;
		Mem0[ebx + -4:word32] = 0x0400;
		Mem0[ebx + 0x00:word32] = 0x08079CB8;
		eax = ~0x0A;
		camlSys__set_signal_1057();
	}
}

// 08056920: define camlSys__entry
// Called from:
//      caml_program
define camlSys__entry
{
	word32 dwLoc08;
	Top_3 = 0;
	fn080709D8();
	ebx_11 = Mem5[eax_7 + 4:word32];
	eax_12 = Mem5[eax_7 + 0x00:word32];
	Mem13[0x08079C1C<p32>:word32] = eax_12;
	Mem14[0x08079C18<p32>:word32] = ebx_11;
	fn080709D8();
	ebx_21 = Mem16[eax_18 + 4:word32];
	eax_22 = Mem16[eax_18 + 0x00:word32];
	Mem23[0x08079C24<p32>:word32] = eax_22;
	Mem24[0x08079C28<p32>:word32] = ebx_21;
	ecx_25 = Mem24[0x08079C28<p32>:word32];
	ecx_27 = ecx_25 + ~0x13 >> 0x01;
	cl_29 = SLICE(ecx_27, byte, 0);
	eax_30 = 0x02 << cl_29;
	Mem33[0x08079C30<p32>:word32] = eax_30 - 0x01;
	ebx_34 = Mem33[0x08079C30<p32>:word32];
	eax_36 = Mem33[0x08079C28<p32>:word32];
	eax_37 = eax_36 >> 0x01;
	SZP_38 = cond(eax_36 >> 0x01);
	P_103 = SLICE(SZP_38, bool, 5);
	if (eax_36 >> 0x01 < 0x00)
		eax_43 = (eax_36 >> 0x01) + 0x07;
	eax_45 = ϕ(eax_37, eax_43);
	eax_46 = eax_45 >> 0x03;
	eax_49 = (eax_46 << 0x01) *s (ebx_34 >> 0x01);
	Mem53[0x08079C2C<p32>:word32] = eax_49 - 0x01;
	fn08070960();
	ebx_60 = eax_55 + 4;
	Mem61[eax_55 + 0x00:word32] = 0x0400;
	Mem62[eax_55 + 4:word32] = 0x01;
	Mem63[0x08079C20<p32>:word32] = eax_55 + 4;
	Mem65[0x08079C34<p32>:word32] = 0x08079CA8;
	Mem66[0x08079C38<p32>:word32] = ~0x00;
	Mem67[0x08079C3C<p32>:word32] = ~0x02;
	Mem68[0x08079C40<p32>:word32] = ~0x04;
	Mem69[0x08079C44<p32>:word32] = ~0x06;
	Mem70[0x08079C48<p32>:word32] = ~0x08;
	Mem71[0x08079C4C<p32>:word32] = ~0x0A;
	Mem72[0x08079C50<p32>:word32] = ~0x0C;
	Mem73[0x08079C54<p32>:word32] = ~0x0E;
	Mem74[0x08079C58<p32>:word32] = ~0x10;
	Mem75[0x08079C5C<p32>:word32] = ~0x12;
	Mem76[0x08079C60<p32>:word32] = ~0x14;
	Mem77[0x08079C64<p32>:word32] = ~0x16;
	Mem78[0x08079C68<p32>:word32] = ~0x18;
	Mem79[0x08079C6C<p32>:word32] = ~0x1A;
	Mem80[0x08079C70<p32>:word32] = ~0x1C;
	Mem81[0x08079C74<p32>:word32] = ~0x1E;
	Mem82[0x08079C78<p32>:word32] = ~0x20;
	Mem83[0x08079C7C<p32>:word32] = ~0x22;
	Mem84[0x08079C80<p32>:word32] = ~0x24;
	Mem85[0x08079C84<p32>:word32] = ~0x26;
	Mem86[0x08079C88<p32>:word32] = ~0x28;
	Mem88[eax_55 + 8:word32] = 0x0400;
	Mem89[eax_55 + 0x0C:word32] = 0x08079CD0;
	Mem90[0x08079C8C<p32>:word32] = eax_55 + 0x0C;
	Mem92[0x08079C90<p32>:word32] = 0x08079C9C;
	Mem94[0x08079C94<p32>:word32] = 0x08079CC4;
	eax_95 = 0x01;
}

// 08056AD0: define camlHashtbl__remove_bucket_1188
// Called from:
//      camlHashtbl__remove_bucket_1188
//      camlHashtbl__remove_1185
define camlHashtbl__remove_bucket_1188
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x10;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 8:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x0C:word32] = ecx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 4:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x00:word32] = eax;
		ecx = Mem0[ebx + 8:word32];
		ecx = Mem0[ecx + 0x00:word32];
		ebx = Mem0[ebx + 16:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = Mem0[esp + 0x0C:word32];
			ebx = Mem0[esp + 8:word32];
			camlHashtbl__remove_bucket_1188();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x10;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0C00;
			ebx = Mem0[esp + 0x00:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 4:word32] = ebx;
			Mem0[eax + 8:word32] = ecx;
			esp += 0x10;
			SCZO = cond(esp);
		}
		else
		{
			eax = Mem0[esp + 8:word32];
			eax = Mem0[eax + 0x0C:word32];
			v9 = Mem0[eax + 0x00:word32] + ~0x01;
			Mem0[eax + 0x00:word32] = v9;
			eax = Mem0[esp + 0x0C:word32];
			esp += 0x10;
			SCZO = cond(esp);
		}
	}
}

// 08056B80: define camlHashtbl__find_in_bucket_1213
// Called from:
//      camlHashtbl__find_in_bucket_1213
//      camlHashtbl__find_all_1210
define camlHashtbl__find_in_bucket_1213
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 4:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x00:word32] = ecx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 8:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		ecx = Mem0[ebx + 8:word32];
		ecx = Mem0[ecx + 0x00:word32];
		ebx = Mem0[ebx + 0x0C:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[esp + 0x00:word32];
			ebx = Mem0[esp + 4:word32];
			camlHashtbl__find_in_bucket_1213();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			ebx = Mem0[esp + 8:word32];
			Mem0[eax + 0x00:word32] = ebx;
			Mem0[eax + 4:word32] = ecx;
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 08056C10: define camlHashtbl__replace_bucket_1221
// Called from:
//      camlHashtbl__replace_bucket_1221
//      fn080578D0
define camlHashtbl__replace_bucket_1221
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x08;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
			{
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = 134691416;
				fn08070A44();
			}
			fn080708CC();
		}
	}
	else
	{
		Mem0[esp + 8:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x0C:word32] = ecx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 0x00:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 4:word32] = eax;
		ecx = Mem0[ebx + 8:word32];
		ecx = Mem0[ecx + 0x00:word32];
		ebx = Mem0[ebx + 0x0C:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = Mem0[esp + 0x0C:word32];
			ebx = Mem0[esp + 8:word32];
			camlHashtbl__replace_bucket_1221();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x10;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0C00;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 0x00:word32];
			Mem0[eax + 4:word32] = ebx;
			Mem0[eax + 8:word32] = ecx;
			esp += 0x10;
			SCZO = cond(esp);
		}
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x10;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0C00;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 8:word32];
			ebx = Mem0[ebx + 16:word32];
			Mem0[eax + 4:word32] = ebx;
			ebx = Mem0[esp + 0x0C:word32];
			Mem0[eax + 8:word32] = ebx;
			esp += 0x10;
			SCZO = cond(esp);
		}
	}
}

// 08056D30: define camlHashtbl__mem_in_bucket_1230
// Called from:
//      camlHashtbl__mem_1227
define camlHashtbl__mem_in_bucket_1230
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 4:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x00:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		ecx = Mem0[ebx + 8:word32];
		ecx = Mem0[ecx + 0x00:word32];
		ebx = Mem0[ebx + 0x0C:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = 0x03;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08056D80: define camlHashtbl__insert_bucket_1068
// Called from:
//      camlHashtbl__insert_bucket_1068
//      camlHashtbl__replace_1112
define camlHashtbl__insert_bucket_1068
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x10;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 0x00:word32] = ebx;
		edx = Mem0[eax + 8:word32];
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 4:word32] = ecx;
		ecx = Mem0[eax + 0x00:word32];
		Mem0[esp + 8:word32] = ecx;
		eax = edx;
		camlHashtbl__insert_bucket_1068();
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[eax + 0x0C:word32];
		ebx >>= 0x01;
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x0C:word32] = ebx;
			Mem0[esp + 0x00:word32] = eax;
			ebx = Mem0[eax + 8:word32];
			ecx = Mem0[ebx + 0x00:word32];
			eax = Mem0[esp + 8:word32];
			ecx();
			eax >>= 0x01;
			ecx = Mem0[esp + 0x0C:word32];
			edx_eax = CONVERT(eax, int32, int64);
			v15 = edx_eax;
			edx = CONVERT(v15 %s ecx, int64, int32);
			eax = CONVERT(v15 /32 ecx, word32, int32);
			SCZO = cond(eax);
		}
		else
		{
			eax = 0x08073A50;
			fn08070A44();
			esi += 0x00;
		}
		edx <<= 0x01;
		++edx;
		ebx = Mem0[esp + 0x00:word32];
		ecx = Mem0[ebx + 16:word32];
		eax = Mem0[ecx + -4:word32];
		eax >>= 0x09;
		SCZO = cond(eax - edx);
		if (Test(UGT,CZ))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x10;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0C00;
			esi = Mem0[esp + 8:word32];
			Mem0[eax + 0x00:word32] = esi;
			esi = Mem0[esp + 4:word32];
			Mem0[eax + 4:word32] = esi;
			esi = Mem0[ebx + 16:word32];
			ebx = Mem0[esi + -4:word32];
			ebx >>= 0x09;
			SCZO = cond(ebx - edx);
			if (Test(UGT,CZ))
			{
				ebx = (esi - 2)[edx * 0x02];
				Mem0[eax + 8:word32] = ebx;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = ecx - 2 + edx * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				eax = 0x01;
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
			fn08070B18();
		}
		fn08070B18();
		esi += 0x00;
	}
}

// 08056E70: define camlHashtbl__remove_bucket_1083
// Called from:
//      camlHashtbl__insert_bucket_1068
//      camlHashtbl__remove_bucket_1083
//      camlHashtbl__remove_1080
define camlHashtbl__remove_bucket_1083
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x10;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 8:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x0C:word32] = ecx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 4:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x00:word32] = eax;
		v9 = Mem0[ebx + 0x0C:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = v9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[esp + 0x0C:word32];
			ebx = Mem0[esp + 8:word32];
			camlHashtbl__remove_bucket_1083();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x10;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0C00;
			ebx = Mem0[esp + 0x00:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 4:word32] = ebx;
			Mem0[eax + 8:word32] = ecx;
			esp += 0x10;
			SCZO = cond(esp);
		}
		else
		{
			eax = Mem0[esp + 8:word32];
			eax = Mem0[eax + 8:word32];
			v10 = Mem0[eax + 0x00:word32] + ~0x01;
			Mem0[eax + 0x00:word32] = v10;
			eax = Mem0[esp + 0x0C:word32];
			esp += 0x10;
			SCZO = cond(esp);
		}
	}
}

// 08056F20: define camlHashtbl__find_in_bucket_1108
// Called from:
//      camlHashtbl__find_in_bucket_1108
//      camlHashtbl__find_all_1105
define camlHashtbl__find_in_bucket_1108
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 4:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x00:word32] = ecx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 8:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		v9 = Mem0[ebx + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = v9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = Mem0[esp + 0x00:word32];
			ebx = Mem0[esp + 4:word32];
			camlHashtbl__find_in_bucket_1108();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			ebx = Mem0[esp + 8:word32];
			Mem0[eax + 0x00:word32] = ebx;
			Mem0[eax + 4:word32] = ecx;
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 08056FB0: define camlHashtbl__replace_bucket_1116
// Called from:
//      camlHashtbl__replace_bucket_1116
//      fn080582B0
define camlHashtbl__replace_bucket_1116
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x08;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
			{
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = 134691416;
				fn08070A44();
			}
			fn080708CC();
		}
	}
	else
	{
		Mem0[esp + 8:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x0C:word32] = ecx;
		ecx = Mem0[eax + 4:word32];
		Mem0[esp + 0x00:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 4:word32] = eax;
		v9 = Mem0[ebx + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = v9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[esp + 0x0C:word32];
			ebx = Mem0[esp + 8:word32];
			camlHashtbl__replace_bucket_1116();
			ecx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x10;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0C00;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 0x00:word32];
			Mem0[eax + 4:word32] = ebx;
			Mem0[eax + 8:word32] = ecx;
			esp += 0x10;
			SCZO = cond(esp);
		}
		else
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x10;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0C00;
			ebx = Mem0[esp + 4:word32];
			Mem0[eax + 0x00:word32] = ebx;
			ebx = Mem0[esp + 8:word32];
			ebx = Mem0[ebx + 0x0C:word32];
			Mem0[eax + 4:word32] = ebx;
			ebx = Mem0[esp + 0x0C:word32];
			Mem0[eax + 8:word32] = ebx;
			esp += 0x10;
			SCZO = cond(esp);
		}
	}
}

// 080570D0: define camlHashtbl__mem_in_bucket_1125
// Called from:
//      camlHashtbl__mem_1122
define camlHashtbl__mem_in_bucket_1125
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 4:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x00:word32] = ecx;
		eax = Mem0[eax + 0x00:word32];
		v9 = Mem0[ebx + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = v9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = 0x03;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08057130: define camlHashtbl__do_bucket_1132
// Called from:
//      camlHashtbl__iter_1129
define camlHashtbl__do_bucket_1132
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 4:word32] = ebx;
		ecx = Mem0[eax + 8:word32];
		Mem0[esp + 0x00:word32] = ecx;
		edx = Mem0[eax + 4:word32];
		eax = Mem0[eax + 0x00:word32];
		ecx = Mem0[ebx + 8:word32];
		ebx = edx;
		caml_apply2();
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	eax = 0x01;
	esp += 0x08;
	SCZO = cond(esp);
}

// 08057170: define camlHashtbl__do_bucket_1142
// Called from:
//      camlHashtbl__fold_1138
define camlHashtbl__do_bucket_1142
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		esi = ebx;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 4:word32] = ecx;
		ebx = Mem0[eax + 8:word32];
		Mem0[esp + 0x00:word32] = ebx;
		ebx = Mem0[eax + 4:word32];
		eax = Mem0[eax + 0x00:word32];
		edx = Mem0[ecx + 0x0C:word32];
		ecx = esi;
		caml_apply3();
		ebx = eax;
		eax = Mem0[esp + 0x00:word32];
		ecx = Mem0[esp + 4:word32];
	}
	eax = esi;
	esp += 0x08;
	SCZO = cond(esp);
}

// 080571B0: define camlHashtbl__safehash_1177
define camlHashtbl__safehash_1177
{
	esp = fp;
	Top = 0;
	ebx = Mem0[ebx + 8:word32];
	ebx = Mem0[ebx + 4:word32];
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
	ebx = 0x7FFFFFFF;
	eax &= ebx;
	SZ = cond(eax);
	O = false;
	C = false;
}

// 080571D0: define camlHashtbl__add_1179
define camlHashtbl__add_1179
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	esi = Mem0[eax + 4:word32];
	esi = Mem0[esi + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 16:word32] = esi;
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 8:word32] = eax;
		eax = Mem0[edx + 0x0C:word32];
		eax = Mem0[eax + 8:word32];
		edx = Mem0[eax + 4:word32];
		ecx = Mem0[edx + 0x00:word32];
		eax = ebx;
		ebx = edx;
		ecx();
		ebx = 0x7FFFFFFF;
		eax &= ebx;
		eax >>= 0x01;
		ecx = Mem0[esp + 16:word32];
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	SCZO = cond(edx);
	++edx;
	SZO = cond(edx);
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0C00;
	ebx = Mem0[esp + 0x00:word32];
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[esp + 4:word32];
	Mem0[eax + 4:word32] = ebx;
	ebx = Mem0[esp + 8:word32];
	esi = Mem0[ebx + 4:word32];
	ecx = Mem0[esi + -4:word32];
	ecx >>= 0x09;
	SCZO = cond(ecx - edx);
	if (Test(UGT,CZ))
	{
		ecx = (esi - 2)[edx * 0x02];
		Mem0[eax + 8:word32] = ecx;
		esi = Mem0[ebx + 4:word32];
		ecx = Mem0[esi + -4:word32];
		ecx >>= 0x09;
		SCZO = cond(ecx - edx);
		if (Test(UGT,CZ))
		{
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = esi - 2 + edx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			v20 = Mem0[ebx + 0x00:word32] + 0x02;
			Mem0[ebx + 0x00:word32] = v20;
			eax = Mem0[ebx + 4:word32];
			eax = Mem0[eax + -4:word32];
			eax >>= 0x09;
			eax |= 0x01;
			ecx = eax - 1 + eax;
			eax = Mem0[ebx + 0x00:word32];
			SCZO = cond(eax - ecx);
			if (Test(LE,SZO))
			{
				eax = 0x01;
				esp += 0x14;
				SCZO = cond(esp);
				return;
			}
			else
			{
				eax = Mem0[esp + 0x0C:word32];
				eax = Mem0[eax + 0x0C:word32];
				esp += 0x14;
				SCZO = cond(esp);
				camlHashtbl__resize_1061();
				return;
			}
		}
		fn08070B18();
	}
	fn08070B18();
	esi = esi;
	camlHashtbl__remove_1185();
}

// 080572E0: define camlHashtbl__remove_1185
// Called from:
//      camlHashtbl__add_1179
define camlHashtbl__remove_1185
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x18;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x08056AD0;
	Mem0[eax + 4:word32] = 0x03;
	esi = Mem0[ecx + 0x0C:word32];
	Mem0[eax + 8:word32] = esi;
	Mem0[eax + 0x0C:word32] = edx;
	Mem0[eax + 16:word32] = ebx;
	esi = Mem0[edx + 4:word32];
	esi = Mem0[esi + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 8:word32] = esi;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ecx + 16:word32];
		eax = Mem0[eax + 8:word32];
		edx = Mem0[eax + 4:word32];
		ecx = Mem0[edx + 0x00:word32];
		eax = ebx;
		ebx = edx;
		ecx();
		ebx = 0x7FFFFFFF;
		eax &= ebx;
		eax >>= 0x01;
		ecx = Mem0[esp + 8:word32];
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	Mem0[esp + 8:word32] = edx;
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = ebx;
	ebx = Mem0[ebx + -4:word32];
	ebx >>= 0x09;
	SCZO = cond(ebx - edx);
	if (Test(UGT,CZ))
	{
		ebx = Mem0[eax + 4:word32];
		eax = Mem0[ebx + -4:word32];
		eax >>= 0x09;
		SCZO = cond(eax - edx);
		if (Test(UGT,CZ))
		{
			eax = (ebx - 2)[edx * 0x02];
			ebx = Mem0[esp + 4:word32];
			camlHashtbl__remove_bucket_1188();
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			ebx = Mem0[esp + 4:word32];
			eax = Mem0[esp + 0x0C:word32];
			eax = ebx - 2 + eax * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			eax = 0x01;
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	esi = esi;
	edi += 0x00;
	camlHashtbl__find_rec_1193();
}

// 080573E0: define camlHashtbl__find_rec_1193
// Called from:
//      camlHashtbl__remove_1185
//      camlHashtbl__find_1198
define camlHashtbl__find_rec_1193
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = eax;
		edx = Mem0[ebx + 8:word32];
		Mem0[esp + 4:word32] = edx;
		edx = Mem0[ebx + 4:word32];
		Mem0[esp + 0x0C:word32] = edx;
		ebx = Mem0[ebx + 0x00:word32];
		ecx = Mem0[ecx + 0x0C:word32];
		ecx = Mem0[ecx + 0x00:word32];
		caml_apply2();
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[esp + 0x0C:word32];
			esp += 0x10;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
	}
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 08057470: define camlHashtbl__find_1198
define camlHashtbl__find_1198
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	edx = Mem0[eax + 4:word32];
	edx = Mem0[edx + -4:word32];
	edx >>= 0x0A;
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 8:word32] = ebx;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[ecx + 16:word32];
		eax = Mem0[eax + 8:word32];
		edx = Mem0[eax + 4:word32];
		ecx = Mem0[edx + 0x00:word32];
		eax = ebx;
		ebx = edx;
		ecx();
		ebx = 0x7FFFFFFF;
		eax &= ebx;
		eax >>= 0x01;
		ecx = Mem0[esp + 0x0C:word32];
		edx_eax = CONVERT(eax, int32, int64);
		v16 = edx_eax;
		edx = CONVERT(v16 %s ecx, int64, int32);
		eax = CONVERT(v16 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[ebx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi = esi;
		edi += 0x00;
		camlHashtbl__find_all_1210();
	}
	else
	{
		ebx = (ebx - 2)[edx * 0x02];
		SCZO = cond(ebx - 0x01);
		if (Test(NE,Z))
		{
			eax = Mem0[ebx + 8:word32];
			Mem0[esp + 0x00:word32] = eax;
			eax = Mem0[ebx + 4:word32];
			Mem0[esp + 0x0C:word32] = eax;
			ebx = Mem0[ebx + 0x00:word32];
			eax = Mem0[esp + 4:word32];
			eax = Mem0[eax + 0x0C:word32];
			ecx = Mem0[eax + 0x00:word32];
			eax = Mem0[esp + 8:word32];
			caml_apply2();
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				eax = Mem0[esp + 0x0C:word32];
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
			eax = Mem0[esp + 0x00:word32];
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				ebx = Mem0[eax + 8:word32];
				Mem0[esp + 0x00:word32] = ebx;
				ebx = Mem0[eax + 4:word32];
				Mem0[esp + 0x0C:word32] = ebx;
				ebx = Mem0[eax + 0x00:word32];
				eax = Mem0[esp + 4:word32];
				eax = Mem0[eax + 0x0C:word32];
				ecx = Mem0[eax + 0x00:word32];
				eax = Mem0[esp + 8:word32];
				caml_apply2();
				SCZO = cond(eax - 0x01);
				if (Test(NE,Z))
				{
					eax = Mem0[esp + 0x0C:word32];
					esp += 0x10;
					SCZO = cond(esp);
					return;
				}
				eax = Mem0[esp + 0x00:word32];
				SCZO = cond(eax - 0x01);
				if (Test(NE,Z))
				{
					ebx = Mem0[eax + 8:word32];
					Mem0[esp + 0x00:word32] = ebx;
					ebx = Mem0[eax + 4:word32];
					Mem0[esp + 0x0C:word32] = ebx;
					ebx = Mem0[eax + 0x00:word32];
					eax = Mem0[esp + 4:word32];
					eax = Mem0[eax + 0x0C:word32];
					ecx = Mem0[eax + 0x00:word32];
					eax = Mem0[esp + 8:word32];
					caml_apply2();
					SCZO = cond(eax - 0x01);
					if (Test(EQ,Z))
					{
						eax = Mem0[esp + 4:word32];
						ecx = Mem0[eax + 20:word32];
						eax = Mem0[esp + 8:word32];
						ebx = Mem0[esp + 0x00:word32];
						esp += 0x10;
						SCZO = cond(esp);
						camlHashtbl__find_rec_1193();
						return;
					}
					else
					{
						eax = Mem0[esp + 0x0C:word32];
						esp += 0x10;
						SCZO = cond(esp);
						return;
					}
				}
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x08;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = 134691416;
				fn08070A44();
			}
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
			esi += 0x00;
		}
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x08;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
			{
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = 134691416;
				fn08070A44();
			}
			fn080708CC();
		}
	}
}

// 08057680: define camlHashtbl__find_all_1210
// Called from:
//      camlHashtbl__find_1198
define camlHashtbl__find_all_1210
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x08056B80;
	Mem0[eax + 4:word32] = 0x03;
	esi = Mem0[ecx + 0x0C:word32];
	Mem0[eax + 8:word32] = esi;
	Mem0[eax + 0x0C:word32] = ebx;
	esi = Mem0[edx + 4:word32];
	esi = Mem0[esi + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 8:word32] = esi;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ecx + 16:word32];
		eax = Mem0[eax + 8:word32];
		edx = Mem0[eax + 4:word32];
		ecx = Mem0[edx + 0x00:word32];
		eax = ebx;
		ebx = edx;
		ecx();
		ebx = 0x7FFFFFFF;
		eax &= ebx;
		eax >>= 0x01;
		ecx = Mem0[esp + 8:word32];
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[ebx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi += 0x00;
		edi += 0x00;
		camlHashtbl__replace_1217();
	}
	else
	{
		eax = (ebx - 2)[edx * 0x02];
		ebx = Mem0[esp + 4:word32];
		esp += 0x0C;
		SCZO = cond(esp);
		camlHashtbl__find_in_bucket_1213();
	}
}

// 08057750: define camlHashtbl__replace_1217
// Called from:
//      camlHashtbl__find_all_1210
define camlHashtbl__replace_1217
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	esi = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x18;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x08056C10;
	Mem0[eax + 4:word32] = 0x03;
	edi = Mem0[edx + 0x0C:word32];
	Mem0[eax + 8:word32] = edi;
	Mem0[eax + 0x0C:word32] = ebx;
	Mem0[eax + 16:word32] = ecx;
	edi = Mem0[esi + 4:word32];
	edi = Mem0[edi + -4:word32];
	edi >>= 0x0A;
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 8:word32] = edi;
		Mem0[esp + 16:word32] = eax;
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 28:word32] = ebx;
		Mem0[esp + 0x00:word32] = esi;
		eax = Mem0[edx + 16:word32];
		eax = Mem0[eax + 8:word32];
		ebx = Mem0[eax + 4:word32];
		ecx = Mem0[ebx + 0x00:word32];
		eax = Mem0[esp + 28:word32];
		ecx();
		ebx = 0x7FFFFFFF;
		eax &= ebx;
		eax >>= 0x01;
		ecx = Mem0[esp + 8:word32];
		edx_eax = CONVERT(eax, int32, int64);
		v18 = edx_eax;
		edx = CONVERT(v18 %s ecx, int64, int32);
		eax = CONVERT(v18 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	Mem0[esp + 24:word32] = edx;
	ebx = Mem0[esp + 0x00:word32];
	ecx = Mem0[ebx + 4:word32];
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
		fn0805793C();
	else
	{
		eax = (ecx - 2)[edx * 0x02];
		Mem0[esp + 8:word32] = eax;
		fn080578D0();
		ecx = 134691416;
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - ecx);
		if (Test(NE,Z))
		{
			fn08070A44();
			esi = esi;
			edi += 0x00;
			fn080578D0();
		}
		else
		{
			ebx = Mem0[esp + 0x00:word32];
			edx = Mem0[ebx + 4:word32];
			eax = Mem0[edx + -4:word32];
			eax >>= 0x09;
			ecx = Mem0[esp + 24:word32];
			SCZO = cond(eax - ecx);
			if (Test(ULE,CZ))
				fn08057937();
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x10;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				esi = eax + 4;
				Mem0[esi + -4:word32] = 0x0C00;
				eax = Mem0[esp + 28:word32];
				Mem0[esi + 0x00:word32] = eax;
				eax = Mem0[esp + 4:word32];
				Mem0[esi + 4:word32] = eax;
				eax = Mem0[esp + 8:word32];
				Mem0[esi + 8:word32] = eax;
				esp -= 4;
				Mem0[esp + 0x00:word32] = esi;
				eax = edx - 2 + ecx * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				v21 = Mem0[ebx + 0x00:word32] + 0x02;
				Mem0[ebx + 0x00:word32] = v21;
				eax = Mem0[ebx + 4:word32];
				eax = Mem0[eax + -4:word32];
				eax >>= 0x09;
				eax |= 0x01;
				ecx = eax - 1 + eax;
				eax = Mem0[ebx + 0x00:word32];
				SCZO = cond(eax - ecx);
				if (Test(LE,SZO))
				{
					eax = 0x01;
					esp += 0x20;
					SCZO = cond(esp);
				}
				else
				{
					eax = Mem0[esp + 0x0C:word32];
					eax = Mem0[eax + 16:word32];
					esp += 0x20;
					SCZO = cond(esp);
					camlHashtbl__resize_1061();
				}
			}
		}
	}
}

// 080578D0: define fn080578D0
// Called from:
//      camlHashtbl__replace_1217
define fn080578D0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	ebx = Mem0[ebx + 4:word32];
	Mem0[esp + 28:word32] = ebx;
	ebx = Mem0[ebx + -4:word32];
	ebx >>= 0x09;
	SCZO = cond(ebx - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		fn08057937();
	}
	else
	{
		ebx = Mem0[esp + 24:word32];
		camlHashtbl__replace_bucket_1221();
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		ebx = Mem0[esp + 32:word32];
		eax = Mem0[esp + 36:word32];
		eax = ebx - 2 + eax * 0x02;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		eax = 0x01;
		Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
		esp += 4;
		esp += 0x04;
		esp += 0x20;
		SCZO = cond(esp);
	}
}

// 08057937: define fn08057937
// Called from:
//      camlHashtbl__replace_1217
//      fn080578D0
define fn08057937
{
	esp = fp;
	Top = 0;
	fn08070B18();
	fn0805793C();
}

// 0805793C: define fn0805793C
// Called from:
//      camlHashtbl__replace_1217
//      fn080578D0
//      fn08057937
define fn0805793C
{
	esp = fp;
	Top = 0;
	fn08070B18();
	camlHashtbl__mem_1227();
}

// 08057950: define camlHashtbl__mem_1227
// Called from:
//      fn0805793C
define camlHashtbl__mem_1227
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x08056D30;
	Mem0[eax + 4:word32] = 0x03;
	esi = Mem0[ecx + 0x0C:word32];
	Mem0[eax + 8:word32] = esi;
	Mem0[eax + 0x0C:word32] = ebx;
	esi = Mem0[edx + 4:word32];
	esi = Mem0[esi + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 8:word32] = esi;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edx;
		eax = Mem0[ecx + 16:word32];
		eax = Mem0[eax + 8:word32];
		edx = Mem0[eax + 4:word32];
		ecx = Mem0[edx + 0x00:word32];
		eax = ebx;
		ebx = edx;
		ecx();
		ebx = 0x7FFFFFFF;
		eax &= ebx;
		eax >>= 0x01;
		ecx = Mem0[esp + 8:word32];
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[ebx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi += 0x00;
		edi += 0x00;
		camlHashtbl__hash_1031();
	}
	else
	{
		eax = (ebx - 2)[edx * 0x02];
		ebx = Mem0[esp + 4:word32];
		esp += 0x0C;
		SCZO = cond(esp);
		camlHashtbl__mem_in_bucket_1230();
	}
}

// 08057A20: define camlHashtbl__hash_1031
// Called from:
//      camlHashtbl__mem_1227
define camlHashtbl__hash_1031
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0xC9;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x15;
	caml_hash_univ_param();
	esp += 0x0C;
	SCZO = cond(esp);
}

// 08057A40: define camlHashtbl__create_1051
// Called from:
//      fn0804EEAA
//      fn0804EEF2
define camlHashtbl__create_1051
{
	word32 dwLoc0C;
	bool P;
	Top_3 = 0;
	camlPervasives__max_1025();
	camlPervasives__min_1022();
	fn080709D8();
	ebx_30 = eax_26;
	while (true)
	{
		P_55 = ϕ(P, P_43);
		Mem31 = ϕ(Mem24, Mem34);
		eax_32 = Mem31[0x08080414<p32>:word32];
		Mem34[0x08080414<p32>:word32] = eax_32 - 0x0C;
		SCZO_35 = cond(eax_32 - 0x0C - Mem34[0x08080418<p32>:word32]);
		C_36 = SLICE(SCZO_35, bool, 1);
		O_54 = SLICE(SCZO_35, bool, 4);
		S_57 = SLICE(SCZO_35, bool, 0);
		Z_59 = SLICE(SCZO_35, bool, 2);
		if (eax_32 - 0x0C >=u Mem34[0x08080418<p32>:word32])
			break;
		fn080708CC();
	}
	eax_44 = eax_32 - 0x08;
	Mem45[eax_32 + -0x0C:word32] = 0x0800;
	Mem46[eax_32 + -8:word32] = 0x01;
	Mem48[eax_32 + -4:word32] = eax_26;
}

// 08057AA0: define camlHashtbl__clear_1054
define camlHashtbl__clear_1054
{
	esp = fp;
	Top = 0;
	edi = eax;
	ebx = 0x01;
	eax = Mem0[edi + 4:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x09;
	esi |= 0x01;
	esi += ~0x01;
	SCZO = cond(ebx - esi);
	if (Test(LE,SZO))
	{
		do
		{
			ecx = Mem0[edi + 4:word32];
			eax = Mem0[ecx + -4:word32];
			eax >>= 0x09;
			SCZO = cond(eax - ebx);
			if (Test(ULE,CZ))
			{
				fn08070B18();
				camlHashtbl__copy_1057();
				return;
			}
			esp -= 4;
			Mem0[esp + 0x00:word32] = 0x01;
			eax = ecx - 2 + ebx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			eax = ebx;
			ebx += 0x02;
			SCZO = cond(eax - esi);
		} while (Test(NE,Z));
	}
	Mem0[edi + 0x00:word32] = 0x01;
	eax = 0x01;
}

// 08057AF0: define camlHashtbl__copy_1057
// Called from:
//      camlHashtbl__clear_1054
define camlHashtbl__copy_1057
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[eax + 4:word32];
	camlArray__copy_1049();
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0800;
	ebx = Mem0[esp + 0x00:word32];
	ebx = Mem0[ebx + 0x00:word32];
	Mem0[eax + 0x00:word32] = ebx;
	Mem0[eax + 4:word32] = ecx;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08057B40: define camlHashtbl__length_1059
define camlHashtbl__length_1059
{
	esp = fp;
	Top = 0;
	eax = Mem0[eax + 0x00:word32];
}

// 08057B50: define camlHashtbl__resize_1061
// Called from:
//      camlHashtbl__add_1179
//      camlHashtbl__replace_1217
//      camlHashtbl__add_1074
//      camlHashtbl__replace_1112
define camlHashtbl__resize_1061
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 16:word32] = ebx;
	eax = Mem0[ebx + 4:word32];
	Mem0[esp + 20:word32] = eax;
	eax = Mem0[eax + -4:word32];
	eax >>= 0x09;
	eax |= 0x01;
	Mem0[esp + 8:word32] = eax;
	ebx = Mem0[0x08079C30<p32>:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	eax = 0x03 + eax * 0x04;
	camlPervasives__min_1022();
	ebx = Mem0[esp + 8:word32];
	SCZO = cond(eax - ebx);
	if (Test(EQ,Z))
	{
		eax = 0x01;
		esp += 0x18;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 8:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x01;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080683F9;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(esp);
		ebx = eax;
		Mem0[esp + 0x0C:word32] = ebx;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x18;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ecx = eax + 4;
		Mem0[ecx + -4:word32] = 0x14F7;
		Mem0[ecx + 0x00:word32] = 0x08056D80;
		Mem0[ecx + 4:word32] = 0x03;
		eax = Mem0[esp + 0x00:word32];
		Mem0[ecx + 8:word32] = eax;
		eax = Mem0[esp + 4:word32];
		Mem0[ecx + 0x0C:word32] = eax;
		Mem0[ecx + 16:word32] = ebx;
		eax = 0x01;
		ebx = Mem0[esp + 8:word32];
		ebx += ~0x01;
		SCZO = cond(eax - ebx);
		if (Test(LE,SZO))
		{
			Mem0[esp + 8:word32] = ebx;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = ecx;
			do
			{
				ebx = Mem0[esp + 20:word32];
				ecx = Mem0[ebx + -4:word32];
				ecx >>= 0x09;
				SCZO = cond(ecx - eax);
				if (Test(ULE,CZ))
				{
					fn08070B18();
					esi += 0x00;
				}
				eax = (ebx - 2)[eax * 0x02];
				ebx = Mem0[esp + 0x00:word32];
				camlHashtbl__insert_bucket_1068();
				eax = Mem0[esp + 4:word32];
				ecx = eax;
				eax += 0x02;
				Mem0[esp + 4:word32] = eax;
				ebx = Mem0[esp + 8:word32];
				SCZO = cond(ecx - ebx);
			} while (Test(NE,Z));
		}
		eax = Mem0[esp + 0x0C:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = Mem0[esp + 20:word32];
		eax += 0x04;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		eax = 0x01;
		esp += 0x18;
		SCZO = cond(esp);
	}
}

// 08057C80: define camlHashtbl__add_1074
// Called from:
//      camlUnix__open_proc_1949
//      camlUnix__open_proc_full_1975
//      camlHashtbl__replace_1112
define camlHashtbl__add_1074
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	edi = eax;
	eax = Mem0[edi + 4:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ecx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0xC9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x15;
		caml_hash_univ_param();
		esp += 0x0C;
		eax >>= 0x01;
		ecx = esi;
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	SCZO = cond(edx);
	++edx;
	SZO = cond(edx);
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0C00;
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[esp + 0x00:word32];
	Mem0[eax + 4:word32] = ebx;
	ecx = Mem0[edi + 4:word32];
	ebx = Mem0[ecx + -4:word32];
	ebx >>= 0x09;
	SCZO = cond(ebx - edx);
	if (Test(UGT,CZ))
	{
		ebx = (ecx - 2)[edx * 0x02];
		Mem0[eax + 8:word32] = ebx;
		ecx = Mem0[edi + 4:word32];
		ebx = Mem0[ecx + -4:word32];
		ebx >>= 0x09;
		SCZO = cond(ebx - edx);
		if (Test(UGT,CZ))
		{
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = ecx - 2 + edx * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			v20 = Mem0[edi + 0x00:word32] + 0x02;
			Mem0[edi + 0x00:word32] = v20;
			eax = Mem0[edi + 4:word32];
			eax = Mem0[eax + -4:word32];
			eax >>= 0x09;
			eax |= 0x01;
			ebx = eax - 1 + eax;
			eax = Mem0[edi + 0x00:word32];
			SCZO = cond(eax - ebx);
			if (Test(LE,SZO))
			{
				eax = 0x01;
				esp += 0x04;
				SCZO = cond(esp);
				return;
			}
			else
			{
				eax = Mem0[0x08079DB0<p32>:word32];
				ebx = edi;
				esp += 0x04;
				SCZO = cond(esp);
				camlHashtbl__resize_1061();
				return;
			}
		}
		fn08070B18();
	}
	fn08070B18();
	esi = esi;
	camlHashtbl__remove_1080();
}

// 08057D70: define camlHashtbl__remove_1080
// Called from:
//      fn0804E350
//      camlHashtbl__add_1074
define camlHashtbl__remove_1080
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	edi = eax;
	ecx = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 4343;
	Mem0[ebx + 0x00:word32] = 0x08056E70;
	Mem0[ebx + 4:word32] = 0x03;
	Mem0[ebx + 8:word32] = edi;
	Mem0[ebx + 0x0C:word32] = ecx;
	eax = Mem0[edi + 4:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		esp -= 4;
		Mem0[esp + 0x00:word32] = ecx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0xC9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x15;
		caml_hash_univ_param();
		esp += 0x0C;
		eax >>= 0x01;
		ecx = esi;
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	Mem0[esp + 4:word32] = edx;
	eax = Mem0[edi + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[eax + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(UGT,CZ))
	{
		ecx = Mem0[edi + 4:word32];
		eax = Mem0[ecx + -4:word32];
		eax >>= 0x09;
		SCZO = cond(eax - edx);
		if (Test(UGT,CZ))
		{
			eax = (ecx - 2)[edx * 0x02];
			camlHashtbl__remove_bucket_1083();
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			ebx = Mem0[esp + 4:word32];
			eax = Mem0[esp + 8:word32];
			eax = ebx - 2 + eax * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			eax = 0x01;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	camlHashtbl__find_rec_1088();
}

// 08057E50: define camlHashtbl__find_rec_1088
// Called from:
//      camlHashtbl__remove_1080
//      camlHashtbl__find_1093
define camlHashtbl__find_rec_1088
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		Mem0[esp + 0x00:word32] = eax;
		ecx = Mem0[ebx + 8:word32];
		Mem0[esp + 4:word32] = ecx;
		ecx = Mem0[ebx + 4:word32];
		Mem0[esp + 8:word32] = ecx;
		ebx = Mem0[ebx + 0x00:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = 0x080663DB;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = Mem0[esp + 8:word32];
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
		eax = Mem0[esp + 0x00:word32];
		ebx = Mem0[esp + 4:word32];
	}
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
		{
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
		}
		fn080708CC();
	}
}

// 08057EE0: define camlHashtbl__find_1093
// Called from:
//      fn0804E350
define camlHashtbl__find_1093
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	edi = eax;
	eax = Mem0[edi + 4:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0xC9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x15;
		caml_hash_univ_param();
		esp += 0x0C;
		eax >>= 0x01;
		ecx = esi;
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	ecx = Mem0[edi + 4:word32];
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi = esi;
		edi += 0x00;
		camlHashtbl__find_all_1105();
	}
	else
	{
		ecx = (ecx - 2)[edx * 0x02];
		SCZO = cond(ecx - 0x01);
		if (Test(NE,Z))
		{
			Mem0[esp + 4:word32] = ebx;
			eax = Mem0[ecx + 8:word32];
			Mem0[esp + 0x00:word32] = eax;
			eax = Mem0[ecx + 4:word32];
			Mem0[esp + 8:word32] = eax;
			eax = Mem0[ecx + 0x00:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			eax = 0x080663DB;
			fn080709D8();
			esp += 0x08;
			SCZO = cond(eax - 0x01);
			if (Test(EQ,Z))
			{
				eax = Mem0[esp + 8:word32];
				esp += 0x0C;
				SCZO = cond(esp);
				return;
			}
			eax = Mem0[esp + 0x00:word32];
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				ebx = Mem0[eax + 8:word32];
				Mem0[esp + 0x00:word32] = ebx;
				ebx = Mem0[eax + 4:word32];
				Mem0[esp + 8:word32] = ebx;
				eax = Mem0[eax + 0x00:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = Mem0[esp + 8:word32];
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x080663DB;
				fn080709D8();
				esp += 0x08;
				SCZO = cond(eax - 0x01);
				if (Test(EQ,Z))
				{
					eax = Mem0[esp + 8:word32];
					esp += 0x0C;
					SCZO = cond(esp);
					return;
				}
				eax = Mem0[esp + 0x00:word32];
				SCZO = cond(eax - 0x01);
				if (Test(NE,Z))
				{
					ebx = Mem0[eax + 8:word32];
					Mem0[esp + 0x00:word32] = ebx;
					ebx = Mem0[eax + 4:word32];
					Mem0[esp + 8:word32] = ebx;
					eax = Mem0[eax + 0x00:word32];
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					eax = Mem0[esp + 8:word32];
					esp -= 4;
					Mem0[esp + 0x00:word32] = eax;
					eax = 0x080663DB;
					fn080709D8();
					esp += 0x08;
					SCZO = cond(eax - 0x01);
					if (Test(NE,Z))
					{
						eax = Mem0[esp + 4:word32];
						ebx = Mem0[esp + 0x00:word32];
						esp += 0x0C;
						SCZO = cond(esp);
						camlHashtbl__find_rec_1088();
						return;
					}
					else
					{
						eax = Mem0[esp + 8:word32];
						esp += 0x0C;
						SCZO = cond(esp);
						return;
					}
				}
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x08;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = 134691416;
				fn08070A44();
			}
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
			esi += 0x00;
		}
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x08;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
			{
				eax += 4;
				Mem0[eax + -4:word32] = 0x0400;
				Mem0[eax + 0x00:word32] = 134691416;
				fn08070A44();
			}
			fn080708CC();
		}
	}
}

// 080580B0: define camlHashtbl__find_all_1105
// Called from:
//      camlHashtbl__find_1093
define camlHashtbl__find_all_1105
{
	esp = fp;
	Top = 0;
	edi = eax;
	ecx = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 3319;
	Mem0[ebx + 0x00:word32] = 0x08056F20;
	Mem0[ebx + 4:word32] = 0x03;
	Mem0[ebx + 8:word32] = ecx;
	eax = Mem0[edi + 4:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		esp -= 4;
		Mem0[esp + 0x00:word32] = ecx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0xC9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x15;
		caml_hash_univ_param();
		esp += 0x0C;
		eax >>= 0x01;
		ecx = esi;
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	ecx = Mem0[edi + 4:word32];
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi += 0x00;
		camlHashtbl__replace_1112();
	}
	else
	{
		eax = (ecx - 2)[edx * 0x02];
		camlHashtbl__find_in_bucket_1108();
	}
}

// 08058150: define camlHashtbl__replace_1112
// Called from:
//      camlHashtbl__find_all_1105
define camlHashtbl__replace_1112
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	edi = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 4343;
	Mem0[edx + 0x00:word32] = 0x08056FB0;
	Mem0[edx + 4:word32] = 0x03;
	Mem0[edx + 8:word32] = ebx;
	Mem0[edx + 0x0C:word32] = ecx;
	eax = Mem0[edi + 4:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 16:word32] = edx;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 0x00:word32] = edi;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0xC9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x15;
		caml_hash_univ_param();
		esp += 0x0C;
		eax >>= 0x01;
		ecx = esi;
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	Mem0[esp + 24:word32] = edx;
	ebx = Mem0[edi + 4:word32];
	eax = Mem0[ebx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
		fn0805831C();
	else
	{
		eax = (ebx - 2)[edx * 0x02];
		Mem0[esp + 0x0C:word32] = eax;
		fn080582B0();
		ecx = 134691416;
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(ebx - ecx);
		if (Test(NE,Z))
		{
			fn08070A44();
			esi = esi;
			edi += 0x00;
			fn080582B0();
		}
		else
		{
			ebx = Mem0[esp + 0x00:word32];
			edx = Mem0[ebx + 4:word32];
			eax = Mem0[edx + -4:word32];
			eax >>= 0x09;
			ecx = Mem0[esp + 24:word32];
			SCZO = cond(eax - ecx);
			if (Test(ULE,CZ))
				fn08058317();
			else
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x10;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				esi = eax + 4;
				Mem0[esi + -4:word32] = 0x0C00;
				eax = Mem0[esp + 4:word32];
				Mem0[esi + 0x00:word32] = eax;
				eax = Mem0[esp + 8:word32];
				Mem0[esi + 4:word32] = eax;
				eax = Mem0[esp + 0x0C:word32];
				Mem0[esi + 8:word32] = eax;
				esp -= 4;
				Mem0[esp + 0x00:word32] = esi;
				eax = edx - 2 + ecx * 0x02;
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				esp += 0x08;
				v20 = Mem0[ebx + 0x00:word32] + 0x02;
				Mem0[ebx + 0x00:word32] = v20;
				eax = Mem0[ebx + 4:word32];
				eax = Mem0[eax + -4:word32];
				eax >>= 0x09;
				eax |= 0x01;
				ecx = eax - 1 + eax;
				eax = Mem0[ebx + 0x00:word32];
				SCZO = cond(eax - ecx);
				if (Test(LE,SZO))
				{
					eax = 0x01;
					esp += 0x1C;
					SCZO = cond(esp);
				}
				else
				{
					eax = Mem0[0x08079DB0<p32>:word32];
					esp += 0x1C;
					SCZO = cond(esp);
					camlHashtbl__resize_1061();
				}
			}
		}
	}
}

// 080582B0: define fn080582B0
// Called from:
//      camlHashtbl__replace_1112
define fn080582B0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	ebx = Mem0[edi + 4:word32];
	Mem0[esp + 28:word32] = ebx;
	ebx = Mem0[ebx + -4:word32];
	ebx >>= 0x09;
	SCZO = cond(ebx - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		fn08058317();
	}
	else
	{
		ebx = Mem0[esp + 24:word32];
		camlHashtbl__replace_bucket_1116();
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		ebx = Mem0[esp + 32:word32];
		eax = Mem0[esp + 36:word32];
		eax = ebx - 2 + eax * 0x02;
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		eax = 0x01;
		Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
		esp += 4;
		esp += 0x04;
		esp += 0x1C;
		SCZO = cond(esp);
	}
}

// 08058317: define fn08058317
// Called from:
//      camlHashtbl__replace_1112
//      fn080582B0
define fn08058317
{
	esp = fp;
	Top = 0;
	fn08070B18();
	fn0805831C();
}

// 0805831C: define fn0805831C
// Called from:
//      camlHashtbl__replace_1112
//      fn080582B0
//      fn08058317
define fn0805831C
{
	esp = fp;
	Top = 0;
	fn08070B18();
	camlHashtbl__mem_1122();
}

// 08058330: define camlHashtbl__mem_1122
// Called from:
//      fn0805831C
define camlHashtbl__mem_1122
{
	esp = fp;
	Top = 0;
	edi = eax;
	ecx = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 3319;
	Mem0[ebx + 0x00:word32] = 0x080570D0;
	Mem0[ebx + 4:word32] = 0x03;
	Mem0[ebx + 8:word32] = ecx;
	eax = Mem0[edi + 4:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		esp -= 4;
		Mem0[esp + 0x00:word32] = ecx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0xC9;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x15;
		caml_hash_univ_param();
		esp += 0x0C;
		eax >>= 0x01;
		ecx = esi;
		edx_eax = CONVERT(eax, int32, int64);
		v17 = edx_eax;
		edx = CONVERT(v17 %s ecx, int64, int32);
		eax = CONVERT(v17 /32 ecx, word32, int32);
		SCZO = cond(eax);
	}
	else
	{
		eax = 0x08073A50;
		fn08070A44();
		esi += 0x00;
	}
	edx <<= 0x01;
	++edx;
	ecx = Mem0[edi + 4:word32];
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x09;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi += 0x00;
		camlHashtbl__iter_1129();
	}
	else
	{
		eax = (ecx - 2)[edx * 0x02];
		camlHashtbl__mem_in_bucket_1125();
	}
}

// 080583D0: define camlHashtbl__iter_1129
// Called from:
//      camlHashtbl__mem_1122
define camlHashtbl__iter_1129
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 3319;
	Mem0[ecx + 0x00:word32] = 0x08057130;
	Mem0[ecx + 4:word32] = 0x03;
	Mem0[ecx + 8:word32] = edx;
	edx = Mem0[ebx + 4:word32];
	eax = 0x01;
	ebx = Mem0[edx + -4:word32];
	ebx >>= 0x09;
	ebx |= 0x01;
	ebx += ~0x01;
	SCZO = cond(eax - ebx);
	if (Test(LE,SZO))
	{
		Mem0[esp + 0x0C:word32] = ebx;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 0x00:word32] = edx;
		Mem0[esp + 4:word32] = ecx;
		do
		{
			ebx = Mem0[esp + 0x00:word32];
			ecx = Mem0[ebx + -4:word32];
			ecx >>= 0x09;
			SCZO = cond(ecx - eax);
			if (Test(ULE,CZ))
			{
				fn08070B18();
				esi += 0x00;
				edi += 0x00;
				camlHashtbl__fold_1138();
				return;
			}
			eax = (ebx - 2)[eax * 0x02];
			ebx = Mem0[esp + 4:word32];
			camlHashtbl__do_bucket_1132();
			eax = Mem0[esp + 8:word32];
			ecx = eax;
			eax += 0x02;
			Mem0[esp + 8:word32] = eax;
			ebx = Mem0[esp + 0x0C:word32];
			SCZO = cond(ecx - ebx);
		} while (Test(NE,Z));
	}
	eax = 0x01;
	esp += 0x10;
	SCZO = cond(esp);
}

// 08058480: define camlHashtbl__fold_1138
// Called from:
//      camlHashtbl__iter_1129
define camlHashtbl__fold_1138
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
	esi = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x1C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 4343;
	Mem0[edx + 0x00:word32] = 0x0804B370;
	Mem0[edx + 4:word32] = 0x05;
	Mem0[edx + 8:word32] = 0x08057170;
	Mem0[edx + 0x0C:word32] = esi;
	esi = Mem0[ebx + 4:word32];
	ebx = edx + 20;
	Mem0[ebx + -4:word32] = 0x0400;
	Mem0[ebx + 0x00:word32] = ecx;
	eax = 0x01;
	ecx = Mem0[esi + -4:word32];
	ecx >>= 0x09;
	ecx |= 0x01;
	ecx += ~0x01;
	SCZO = cond(eax - ecx);
	if (Test(LE,SZO))
	{
		Mem0[esp + 16:word32] = ecx;
		Mem0[esp + 0x0C:word32] = eax;
		Mem0[esp + 8:word32] = ebx;
		Mem0[esp + 0x00:word32] = esi;
		Mem0[esp + 4:word32] = edx;
		do
		{
			ebx = Mem0[ebx + 0x00:word32];
			ecx = Mem0[esp + 0x00:word32];
			edx = Mem0[ecx + -4:word32];
			edx >>= 0x09;
			SCZO = cond(edx - eax);
			if (Test(ULE,CZ))
			{
				fn08070B18();
				esi += 0x00;
				camlHashtbl__Make_1251();
				return;
			}
			eax = (ecx - 2)[eax * 0x02];
			ecx = Mem0[esp + 4:word32];
			camlHashtbl__do_bucket_1142();
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			ebx = Mem0[esp + 0x0C:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			caml_modify();
			esp += 0x08;
			eax = Mem0[esp + 0x0C:word32];
			edx = eax;
			eax += 0x02;
			Mem0[esp + 0x0C:word32] = eax;
			ecx = Mem0[esp + 16:word32];
			SCZO = cond(edx - ecx);
		} while (Test(NE,Z));
	}
	eax = Mem0[ebx + 0x00:word32];
	esp += 0x14;
	SCZO = cond(esp);
}

// 08058550: define camlHashtbl__Make_1251
// Called from:
//      camlHashtbl__fold_1138
define camlHashtbl__Make_1251
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	ebx = eax;
	eax = Mem0[0x08079D7C<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[0x08079D80<p32>:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x08079D88<p32>:word32];
	Mem0[esp + 8:word32] = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 232;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 3319;
	Mem0[eax + 0x00:word32] = 0x080571B0;
	Mem0[eax + 4:word32] = 0x03;
	Mem0[eax + 8:word32] = ebx;
	ecx = eax + 16;
	Mem0[esp + 0x0C:word32] = ecx;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B2D0;
	Mem0[ecx + 4:word32] = 0x07;
	Mem0[ecx + 8:word32] = 134574544;
	Mem0[ecx + 0x0C:word32] = eax;
	ecx = eax + 36;
	Mem0[esp + 16:word32] = ecx;
	Mem0[ecx + -4:word32] = 0x14F7;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x080572E0;
	Mem0[ecx + 0x0C:word32] = ebx;
	Mem0[ecx + 16:word32] = eax;
	edx = eax + 60;
	Mem0[edx + -4:word32] = 4343;
	Mem0[edx + 0x00:word32] = 0x0804B370;
	Mem0[edx + 4:word32] = 0x05;
	Mem0[edx + 8:word32] = 0x080573E0;
	Mem0[edx + 0x0C:word32] = ebx;
	ecx = eax + 80;
	Mem0[esp + 20:word32] = ecx;
	Mem0[ecx + -4:word32] = 0x18F7;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x08057470;
	Mem0[ecx + 0x0C:word32] = ebx;
	Mem0[ecx + 16:word32] = eax;
	Mem0[ecx + 20:word32] = edx;
	esi = eax + 0x006C;
	Mem0[esi + -4:word32] = 0x14F7;
	Mem0[esi + 0x00:word32] = 0x0804B370;
	Mem0[esi + 4:word32] = 0x05;
	Mem0[esi + 8:word32] = 0x08057680;
	Mem0[esi + 0x0C:word32] = ebx;
	Mem0[esi + 16:word32] = eax;
	edx = eax + 0x84;
	Mem0[edx + -4:word32] = 0x14F7;
	Mem0[edx + 0x00:word32] = 0x0804B2D0;
	Mem0[edx + 4:word32] = 0x07;
	Mem0[edx + 8:word32] = 0x08057750;
	Mem0[edx + 0x0C:word32] = ebx;
	Mem0[edx + 16:word32] = eax;
	ecx = eax + 0x9C;
	Mem0[ecx + -4:word32] = 0x14F7;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x08057950;
	Mem0[ecx + 0x0C:word32] = ebx;
	Mem0[ecx + 16:word32] = eax;
	ebx = Mem0[0x08079DA0<p32>:word32];
	Mem0[esp + 24:word32] = ebx;
	ebp = Mem0[0x08079DA4<p32>:word32];
	edi = Mem0[0x08079DA8<p32>:word32];
	eax += 0xB4;
	Mem0[eax + -4:word32] = 0x3000;
	ebx = Mem0[esp + 0x00:word32];
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[esp + 4:word32];
	Mem0[eax + 4:word32] = ebx;
	ebx = Mem0[esp + 8:word32];
	Mem0[eax + 8:word32] = ebx;
	ebx = Mem0[esp + 0x0C:word32];
	Mem0[eax + 0x0C:word32] = ebx;
	ebx = Mem0[esp + 16:word32];
	Mem0[eax + 16:word32] = ebx;
	ebx = Mem0[esp + 20:word32];
	Mem0[eax + 20:word32] = ebx;
	Mem0[eax + 24:word32] = esi;
	Mem0[eax + 28:word32] = edx;
	Mem0[eax + 32:word32] = ecx;
	ebx = Mem0[esp + 24:word32];
	Mem0[eax + 36:word32] = ebx;
	Mem0[eax + 40:word32] = ebp;
	Mem0[eax + 44:word32] = edi;
	esp += 0x1C;
	SCZO = cond(esp);
}

// 08058720: define camlHashtbl__entry
// Called from:
//      caml_program
define camlHashtbl__entry
{
	Top_3 = 0;
	Mem5[0x08079DB0<p32>:word32] = 0x08079E9C;
	Mem7[0x08079D7C<p32>:word32] = 0x08079E90;
	Mem9[0x08079D80<p32>:word32] = 0x08079E84;
	Mem11[0x08079D88<p32>:word32] = 0x08079E78;
	Mem13[0x08079DA8<p32>:word32] = 134717036;
	Mem15[0x08079DB4<p32>:word32] = 134717020;
	Mem17[0x08079D84<p32>:word32] = 134717004;
	Mem19[0x08079D98<p32>:word32] = 0x08079E3C;
	Mem21[0x08079DB8<p32>:word32] = 0x08079E2C;
	Mem23[0x08079D8C<p32>:word32] = 0x08079E1C;
	Mem25[0x08079D90<p32>:word32] = 0x08079E0C;
	Mem27[0x08079D9C<p32>:word32] = 0x08079DFC;
	Mem29[0x08079D94<p32>:word32] = 0x08079DEC;
	Mem31[0x08079DA0<p32>:word32] = 0x08079DDC;
	Mem33[0x08079DA4<p32>:word32] = 0x08079DCC;
	Mem35[0x08079DAC<p32>:word32] = 0x08079DC0;
	eax_36 = 0x01;
}

// 080587D0: define camlBuffer__advance_1104
// Called from:
//      camlBuffer__advance_to_closing_1098
define camlBuffer__advance_1104
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - ecx);
		if (Test(GE,SO))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0400;
			Mem0[eax + 0x00:word32] = 134691416;
			fn08070A44();
			esi = esi;
			edi += 0x00;
		}
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 0x00:word32] = eax;
		edi = Mem0[edx + 0x0C:word32];
		ecx = Mem0[edx + 20:word32];
		eax = ebx;
		eax >>= 0x01;
		esi = Mem0[ecx + -4:word32];
		esi >>= 0x0A;
		ebp = ~0x00 + esi * 0x04;
		esi = CONVERT(Mem0[ecx + ebp:byte], byte, word32);
		ebp -= esi;
		SCZO = cond(ebp - eax);
		if (Test(ULE,CZ))
			break;
		eax = CONVERT(Mem0[ecx + eax:byte], byte, word32);
		eax = eax + 1 + eax;
		SCZO = cond(eax - edi);
		if (Test(NE,Z))
		{
			edi = Mem0[edx + 16:word32];
			ecx = Mem0[edx + 20:word32];
			eax = ebx;
			eax >>= 0x01;
			esi = Mem0[ecx + -4:word32];
			esi >>= 0x0A;
			ebp = ~0x00 + esi * 0x04;
			esi = CONVERT(Mem0[ecx + ebp:byte], byte, word32);
			ebp -= esi;
			SCZO = cond(ebp - eax);
			if (Test(ULE,CZ))
			{
				fn08070B18();
				break;
			}
			eax = CONVERT(Mem0[ecx + eax:byte], byte, word32);
			eax = eax + 1 + eax;
			SCZO = cond(eax - edi);
			if (Test(NE,Z))
			{
				ebx += 0x02;
				SCZO = cond(ebx);
				eax = Mem0[esp + 0x00:word32];
				ecx = Mem0[esp + 4:word32];
				continue;
			}
			eax = Mem0[esp + 0x00:word32];
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				ebx += 0x02;
				eax += ~0x01;
				SCZO = cond(eax);
				ecx = Mem0[esp + 4:word32];
				continue;
			}
			else
			{
				eax = ebx;
				esp += 0x08;
				SCZO = cond(esp);
				return;
			}
		}
		ebx += 0x02;
		eax = Mem0[esp + 0x00:word32];
		eax += 0x02;
		SCZO = cond(eax);
		ecx = Mem0[esp + 4:word32];
	}
	fn08070B18();
	esi += 0x00;
	edi += 0x00;
	camlBuffer__advance_1111();
}

// 080588E0: define camlBuffer__advance_1111
// Called from:
//      camlBuffer__advance_to_closing_1098
//      camlBuffer__advance_to_non_alpha_1108
define camlBuffer__advance_1111
{
	esp = fp;
	Top = 0;
	while (true)
	{
		SCZO = cond(eax - ebx);
		if (Test(GE,SO))
			break;
		esi = Mem0[ecx + 0x0C:word32];
		edx = eax;
		edx >>= 0x01;
		edi = Mem0[esi + -4:word32];
		edi >>= 0x0A;
		ebp = ~0x00 + edi * 0x04;
		edi = CONVERT(Mem0[esi + ebp:byte], byte, word32);
		ebp -= edi;
		SCZO = cond(ebp - edx);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			esi = esi;
			camlBuffer__subst_1127();
			return;
		}
		edx = CONVERT(Mem0[esi + edx:byte], byte, word32);
		edx = edx + 1 + edx;
		SCZO = cond(edx - 191);
		if (Test(LT,SO))
		{
			SCZO = cond(edx - 117);
			if (Test(GE,SO))
			{
				edx += ~0x81;
				SCZO = cond(edx - 0x33);
				if (Test(UGT,CZ))
					return;
				goto l08058970;
			}
			SCZO = cond(edx - 0x61);
			if (Test(LT,SO))
				return;
			goto l08058970;
		}
		SCZO = cond(edx - 0xF7);
		if (Test(GE,SO))
		{
			SCZO = cond(edx - 0x0181);
			if (Test(GE,SO))
			{
				edx += ~0x017F;
				edx >>= 0x01;
				SCZ = cond(edx);
				O = false;
				0x0807A97C[edx * 0x04]();
				return;
			}
			return;
		}
		SCZO = cond(edx - 0xC1);
		if (Test(EQ,Z))
			return;
l08058970:
		eax += 0x02;
		SCZO = cond(eax);
	}
	eax = ebx;
}

// 08058980: define camlBuffer__subst_1127
// Called from:
//      camlBuffer__advance_to_non_alpha_1108
//      camlBuffer__add_substitute_1122
define camlBuffer__subst_1127
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		edi = eax;
		eax = Mem0[ecx + 24:word32];
		SCZO = cond(ebx - eax);
		if (Test(GE,SO))
			break;
		edx = Mem0[ecx + 20:word32];
		eax = ebx;
		eax >>= 0x01;
		esi = Mem0[edx + -4:word32];
		esi >>= 0x0A;
		ebp = ~0x00 + esi * 0x04;
		esi = CONVERT(Mem0[edx + ebp:byte], byte, word32);
		ebp -= esi;
		SCZO = cond(ebp - eax);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			camlBuffer__create_1039();
			return;
		}
		eax = CONVERT(Mem0[edx + eax:byte], byte, word32);
		edx = eax + 1 + eax;
		SCZO = cond(edx - 0x49);
		if (Test(NE,Z))
		{
			SCZO = cond(edi - 0xB9);
			if (Test(EQ,Z))
			{
				Mem0[esp + 0x00:word32] = edx;
				Mem0[esp + 8:word32] = ecx;
				Mem0[esp + 4:word32] = ebx;
				ebx = 0xB9;
				eax = Mem0[ecx + 0x0C:word32];
				camlBuffer__add_char_1072();
				eax = Mem0[esp + 8:word32];
				eax = Mem0[eax + 0x0C:word32];
				ebx = Mem0[esp + 0x00:word32];
				camlBuffer__add_char_1072();
				ebx = Mem0[esp + 4:word32];
				ebx += 0x02;
				SCZO = cond(ebx);
				eax = 0x41;
				ecx = Mem0[esp + 8:word32];
			}
			else
			{
				SCZO = cond(edx - 0xB9);
				if (Test(NE,Z))
				{
					Mem0[esp + 8:word32] = ecx;
					Mem0[esp + 4:word32] = ebx;
					ebx = edx;
					Mem0[esp + 0x00:word32] = ebx;
					eax = Mem0[ecx + 0x0C:word32];
					camlBuffer__add_char_1072();
					eax = Mem0[esp + 4:word32];
					ebx = eax;
					ebx += 0x02;
					SCZO = cond(ebx);
					eax = Mem0[esp + 0x00:word32];
					ecx = Mem0[esp + 8:word32];
				}
				else
				{
					eax = edx;
					ebx += 0x02;
					SCZO = cond(ebx);
				}
			}
		}
		else
		{
			Mem0[esp + 8:word32] = ecx;
			SCZO = cond(edi - 0xB9);
			if (Test(EQ,Z))
			{
				Mem0[esp + 4:word32] = ebx;
				eax = Mem0[ecx + 0x0C:word32];
				ebx = edx;
				camlBuffer__add_char_1072();
				ebx = Mem0[esp + 4:word32];
				ebx += 0x02;
				SCZO = cond(ebx);
				eax = 0x41;
				ecx = Mem0[esp + 8:word32];
			}
			else
			{
				ebx += 0x02;
				SCZO = cond(ebx);
				edx = Mem0[ecx + 24:word32];
				eax = Mem0[ecx + 20:word32];
				ecx = edx;
				camlBuffer__find_ident_1114();
				ebx = eax;
				eax = Mem0[ebx + 4:word32];
				Mem0[esp + 0x00:word32] = eax;
				edx = Mem0[ebx + 0x00:word32];
				eax = Mem0[esp + 8:word32];
				ebx = Mem0[eax + 16:word32];
				ecx = Mem0[ebx + 0x00:word32];
				eax = edx;
				ecx();
				ebx = eax;
				eax = Mem0[esp + 8:word32];
				eax = Mem0[eax + 0x0C:word32];
				camlBuffer__add_string_1082();
				eax = 0x41;
				ebx = Mem0[esp + 0x00:word32];
				ecx = Mem0[esp + 8:word32];
			}
		}
	}
	SCZO = cond(edi - 0xB9);
	if (Test(NE,Z))
	{
		eax = 0x01;
		esp += 0x0C;
		SCZO = cond(esp);
	}
	else
	{
		eax = Mem0[ecx + 0x0C:word32];
		ebx = edi;
		esp += 0x0C;
		SCZO = cond(esp);
		camlBuffer__add_char_1072();
	}
}

// 08058B10: define camlBuffer__create_1039
// Called from:
//      camlBuffer__add_substitute_1122
//      camlPrintf__extract_format_1085
//      camlPrintf__summarize_format_type_1162
//      camlPrintf__get_buff_1402
define camlBuffer__create_1039
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(eax - 0x03);
	if (Test(LT,SO))
		eax = 0x03;
	ebx = Mem0[0x08079C2C<p32>:word32];
	SCZO = cond(eax - ebx);
	if (Test(GT,SZO))
	{
		eax = Mem0[0x08079C2C<p32>:word32];
		Mem0[esp + 0x00:word32] = eax;
	}
	else
		Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x08068247;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x1000;
	Mem0[eax + 0x00:word32] = ecx;
	Mem0[eax + 4:word32] = 0x01;
	ebx = Mem0[esp + 0x00:word32];
	Mem0[eax + 8:word32] = ebx;
	Mem0[eax + 0x0C:word32] = ecx;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08058B90: define camlBuffer__contents_1044
define camlBuffer__contents_1044
{
	esp = fp;
	Top = 0;
	ecx = Mem0[eax + 4:word32];
	ebx = 0x01;
	eax = Mem0[eax + 0x00:word32];
	camlString__sub_1046();
}

// 08058BA0: define camlBuffer__sub_1046
define camlBuffer__sub_1046
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(ecx - 0x01);
		if (Test(GE,SO))
		{
			edx = Mem0[eax + 4:word32];
			edx -= ecx;
			++edx;
			SCZO = cond(ebx - edx);
			if (Test(LE,SZO))
			{
				Mem0[esp + 8:word32] = ecx;
				Mem0[esp + 4:word32] = ebx;
				Mem0[esp + 0x00:word32] = eax;
				esp -= 4;
				Mem0[esp + 0x00:word32] = ecx;
				eax = 0x08068247;
				fn080709D8();
				esp += 0x04;
				SCZO = cond(esp);
				ecx = eax;
				Mem0[esp + 0x0C:word32] = ecx;
				edx = 0x01;
				eax = Mem0[esp + 0x00:word32];
				eax = Mem0[eax + 0x00:word32];
				ebx = Mem0[esp + 4:word32];
				esi = Mem0[esp + 8:word32];
				camlString__blit_1056();
				eax = Mem0[esp + 0x0C:word32];
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x0807A970;
	esp += 0x10;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 08058C10: define camlBuffer__blit_1051
define camlBuffer__blit_1051
{
	esp = fp;
	Top = 0;
	SCZO = cond(esi - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(ebx - 0x01);
		if (Test(GE,SO))
		{
			edi = Mem0[eax + 4:word32];
			edi -= esi;
			++edi;
			SCZO = cond(ebx - edi);
			if (Test(LE,SZO))
			{
				SCZO = cond(edx - 0x01);
				if (Test(GE,SO))
				{
					edi = Mem0[ecx + -4:word32];
					edi >>= 0x0A;
					ebp = ~0x00 + edi * 0x04;
					edi = CONVERT(Mem0[ecx + ebp:byte], byte, word32);
					ebp -= edi;
					edi = ebp;
					edi <<= 0x01;
					edi -= esi;
					edi += 0x02;
					SCZO = cond(edx - edi);
					if (Test(LE,SZO))
					{
						eax = Mem0[eax + 0x00:word32];
						camlString__blit_1056();
						return;
					}
				}
			}
		}
	}
	eax = 0x0807A960;
	camlPervasives__invalid_arg_1012();
}

// 08058C60: define camlBuffer__nth_1057
define camlBuffer__nth_1057
{
	esp = fp;
	Top = 0;
	SCZO = cond(ebx - 0x01);
	if (Test(GE,SO))
	{
		ecx = Mem0[eax + 4:word32];
		SCZO = cond(ebx - ecx);
		if (Test(LT,SO))
		{
			eax = Mem0[eax + 0x00:word32];
			ebx >>= 0x01;
			ecx = Mem0[eax + -4:word32];
			ecx >>= 0x0A;
			ecx = ~0x00 + ecx * 0x04;
			edx = CONVERT(Mem0[eax + ecx:byte], byte, word32);
			ecx -= edx;
			SCZO = cond(ecx - ebx);
			if (Test(ULE,CZ))
			{
				fn08070B18();
				camlBuffer__length_1060();
				return;
			}
			else
			{
				eax = CONVERT(Mem0[eax + ebx:byte], byte, word32);
				eax = eax + 1 + eax;
				return;
			}
		}
	}
	eax = 0x0807A950;
	camlPervasives__invalid_arg_1012();
}

// 08058CA0: define camlBuffer__length_1060
// Called from:
//      camlBuffer__nth_1057
define camlBuffer__length_1060
{
	esp = fp;
	Top = 0;
	eax = Mem0[eax + 4:word32];
}

// 08058CB0: define camlBuffer__clear_1062
define camlBuffer__clear_1062
{
	esp = fp;
	Top = 0;
	Mem0[eax + 4:word32] = 0x01;
	eax = 0x01;
}

// 08058CC0: define camlBuffer__reset_1064
define camlBuffer__reset_1064
{
	esp = fp;
	Top = 0;
	ebx = eax;
	Mem0[ebx + 4:word32] = 0x01;
	v6 = Mem0[ebx + 0x0C:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v6;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	caml_modify();
	esp += 0x08;
	ecx = Mem0[ebx + 0x00:word32];
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ecx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ecx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	Mem0[ebx + 8:word32] = eax;
	eax = 0x01;
}

// 08058D00: define camlBuffer__resize_1066
// Called from:
//      camlBuffer__add_char_1072
//      camlBuffer__add_substring_1076
//      camlBuffer__add_string_1082
//      camlBuffer__add_channel_1090
define camlBuffer__resize_1066
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 4:word32] = ecx;
	edx = Mem0[ecx + 8:word32];
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x08;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[esp + 8:word32] = eax;
	Mem0[eax + -4:word32] = 0x0400;
	Mem0[eax + 0x00:word32] = edx;
	while (true)
	{
		esi = Mem0[eax + 0x00:word32];
		edx = Mem0[ecx + 4:word32];
		edx = edx - 1 + ebx;
		SCZO = cond(edx - esi);
		if (Test(LE,SZO))
			break;
		edx = Mem0[eax + 0x00:word32];
		edx >>= 0x01;
		SCZ = cond(edx);
		O = false;
		edx = 0x01 + edx * 0x04;
		Mem0[eax + 0x00:word32] = edx;
	}
	esi = Mem0[0x08079C2C<p32>:word32];
	edx = Mem0[eax + 0x00:word32];
	SCZO = cond(edx - esi);
	if (Test(GT,SZO))
	{
		edx = Mem0[0x08079C2C<p32>:word32];
		ecx = Mem0[ecx + 4:word32];
		ebx = ecx - 1 + ebx;
		SCZO = cond(ebx - edx);
		if (Test(LE,SZO))
		{
			ebx = Mem0[0x08079C2C<p32>:word32];
			Mem0[eax + 0x00:word32] = ebx;
		}
		else
		{
			eax = 134719788;
			camlPervasives__failwith_1010();
			esp += 0x04;
		}
	}
	eax = Mem0[esp + 8:word32];
	v14 = Mem0[eax + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v14;
	eax = 0x08068247;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(esp);
	ecx = eax;
	Mem0[esp + 0x00:word32] = ecx;
	eax = Mem0[esp + 4:word32];
	esi = Mem0[eax + 4:word32];
	edx = 0x01;
	ebx = 0x01;
	eax = Mem0[eax + 0x00:word32];
	camlString__blit_1056();
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	ebx = Mem0[esp + 8:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	caml_modify();
	esp += 0x08;
	eax = Mem0[esp + 8:word32];
	eax = Mem0[eax + 0x00:word32];
	Mem0[ebx + 8:word32] = eax;
	eax = 0x01;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 08058E00: define camlBuffer__add_char_1072
// Called from:
//      camlBuffer__add_substitute_1122
//      camlPrintf__fill_format_1096
//      camlPrintf__add_char_1166
//      camlPrintf__add_conv_1169
//      camlPrintf__extract_format_1085
define camlBuffer__add_char_1072
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 8:word32] = ebx;
	ecx = Mem0[eax + 4:word32];
	Mem0[esp + 4:word32] = ecx;
	ebx = Mem0[eax + 8:word32];
	SCZO = cond(ecx - ebx);
	if (Test(GE,SO))
	{
		ebx = 0x03;
		camlBuffer__resize_1066();
	}
	esi = Mem0[esp + 0x00:word32];
	ebx = Mem0[esi + 0x00:word32];
	ecx = Mem0[esp + 4:word32];
	eax = ecx;
	eax >>= 0x01;
	edx = Mem0[ebx + -4:word32];
	edx >>= 0x0A;
	edx = ~0x00 + edx * 0x04;
	edi = CONVERT(Mem0[ebx + edx:byte], byte, word32);
	edx -= edi;
	SCZO = cond(edx - eax);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi += 0x00;
		edi += 0x00;
	}
	else
	{
		edx = Mem0[esp + 8:word32];
		edx >>= 0x01;
		Mem0[ebx + eax:byte] = dl;
		ecx += 0x02;
		Mem0[esi + 4:word32] = ecx;
		eax = 0x01;
		esp += 0x0C;
		SCZO = cond(esp);
	}
}

// 08058E70: define camlBuffer__add_substring_1076
// Called from:
//      camlBuffer__add_char_1072
//      camlBuffer__add_buffer_1087
define camlBuffer__add_substring_1076
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	Mem0[esp + 16:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 8:word32] = edx;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		SCZO = cond(edx - 0x01);
		if (Test(GE,SO))
		{
			eax = Mem0[ebx + -4:word32];
			eax >>= 0x0A;
			eax = ~0x00 + eax * 0x04;
			ebx = CONVERT(Mem0[ebx + eax:byte], byte, word32);
			eax -= ebx;
			eax <<= 0x01;
			eax -= edx;
			eax += 0x02;
			SCZO = cond(ecx - eax);
			if (Test(LE,SZO))
			{
l08058EB4:
				eax = Mem0[esp + 16:word32];
				ecx = Mem0[eax + 4:word32];
				ebx = Mem0[esp + 8:word32];
				edx = ecx - 1 + ebx;
				Mem0[esp + 0x0C:word32] = edx;
				ecx = Mem0[eax + 8:word32];
				SCZO = cond(edx - ecx);
				if (Test(GT,SZO))
					camlBuffer__resize_1066();
				eax = Mem0[esp + 16:word32];
				edx = Mem0[eax + 4:word32];
				ecx = Mem0[eax + 0x00:word32];
				eax = Mem0[esp + 0x00:word32];
				ebx = Mem0[esp + 4:word32];
				esi = Mem0[esp + 8:word32];
				camlString__blit_1056();
				ebx = Mem0[esp + 0x0C:word32];
				eax = Mem0[esp + 16:word32];
				Mem0[eax + 4:word32] = ebx;
				eax = 0x01;
				esp += 0x14;
				SCZO = cond(esp);
				return;
			}
		}
	}
	eax = 0x0807A910;
	camlPervasives__invalid_arg_1012();
	esp += 0x04;
	goto l08058EB4;
}

// 08058F00: define camlBuffer__add_string_1082
// Called from:
//      camlBuffer__add_substitute_1122
//      camlPrintf__fill_format_1096
//      camlPrintf__add_conv_1169
define camlBuffer__add_string_1082
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	Mem0[esp + 0x0C:word32] = eax;
	edx = ebx;
	Mem0[esp + 0x00:word32] = edx;
	ecx = Mem0[edx + -4:word32];
	ecx >>= 0x0A;
	ebx = ~0x00 + ecx * 0x04;
	ecx = CONVERT(Mem0[edx + ebx:byte], byte, word32);
	ebx -= ecx;
	ebx = ebx + 1 + ebx;
	Mem0[esp + 4:word32] = ebx;
	ecx = Mem0[eax + 4:word32];
	edx = ecx - 1 + ebx;
	Mem0[esp + 8:word32] = edx;
	ecx = Mem0[eax + 8:word32];
	SCZO = cond(edx - ecx);
	if (Test(GT,SZO))
		camlBuffer__resize_1066();
	eax = Mem0[esp + 0x0C:word32];
	edx = Mem0[eax + 4:word32];
	ecx = Mem0[eax + 0x00:word32];
	ebx = 0x01;
	eax = Mem0[esp + 0x00:word32];
	esi = Mem0[esp + 4:word32];
	camlString__blit_1056();
	ebx = Mem0[esp + 8:word32];
	eax = Mem0[esp + 0x0C:word32];
	Mem0[eax + 4:word32] = ebx;
	eax = 0x01;
	esp += 0x10;
	SCZO = cond(esp);
}

// 08058F70: define camlBuffer__add_buffer_1087
define camlBuffer__add_buffer_1087
{
	esp = fp;
	Top = 0;
	edx = Mem0[ebx + 4:word32];
	ecx = 0x01;
	ebx = Mem0[ebx + 0x00:word32];
	camlBuffer__add_substring_1076();
}

// 08058F80: define camlBuffer__add_channel_1090
define camlBuffer__add_channel_1090
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 8:word32] = ecx;
	SCZO = cond(ecx - 0x01);
	if (Test(GE,SO))
	{
		eax = Mem0[0x08079C2C<p32>:word32];
		SCZO = cond(ecx - eax);
		if (Test(LE,SZO))
		{
l08058FA6:
			eax = Mem0[esp + 4:word32];
			edx = Mem0[eax + 8:word32];
			ecx = Mem0[eax + 4:word32];
			ebx = Mem0[esp + 8:word32];
			ecx = ecx - 1 + ebx;
			SCZO = cond(ecx - edx);
			if (Test(GT,SZO))
				camlBuffer__resize_1066();
			eax = Mem0[esp + 4:word32];
			ecx = Mem0[eax + 4:word32];
			ebx = Mem0[eax + 0x00:word32];
			eax = Mem0[esp + 0x00:word32];
			edx = Mem0[esp + 8:word32];
			camlPervasives__really_input_1235();
			ebx = Mem0[esp + 4:word32];
			ecx = Mem0[ebx + 4:word32];
			eax = Mem0[esp + 8:word32];
			eax = ecx - 1 + eax;
			Mem0[ebx + 4:word32] = eax;
			eax = 0x01;
			esp += 0x0C;
			SCZO = cond(esp);
			return;
		}
	}
	eax = 0x0807A8F8;
	camlPervasives__invalid_arg_1012();
	esp += 0x04;
	goto l08058FA6;
}

// 08059000: define camlBuffer__output_buffer_1094
define camlBuffer__output_buffer_1094
{
	esp = fp;
	Top = 0;
	edx = Mem0[ebx + 4:word32];
	ecx = 0x01;
	ebx = Mem0[ebx + 0x00:word32];
	camlPervasives__output_1194();
}

// 08059010: define camlBuffer__closing_1097
// Called from:
//      camlBuffer__find_ident_1114
define camlBuffer__closing_1097
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x51);
	if (Test(EQ,Z))
		eax = 0x53;
	else
	{
		SCZO = cond(eax - 0xF7);
		if (Test(NE,Z))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x0800;
			Mem0[eax + 0x00:word32] = 134691556;
			Mem0[eax + 4:word32] = 0x0807A8D8;
			fn08070A44();
			esi = esi;
		}
		eax = 0xFB;
	}
}

// 08059070: define camlBuffer__advance_to_closing_1098
// Called from:
//      camlBuffer__find_ident_1114
define camlBuffer__advance_to_closing_1098
{
	esp = fp;
	Top = 0;
	ebp = eax;
	edi = edx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x1C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	edx = eax + 4;
	Mem0[edx + -4:word32] = 0x18F7;
	Mem0[edx + 0x00:word32] = 0x0804B2D0;
	Mem0[edx + 4:word32] = 0x07;
	Mem0[edx + 8:word32] = 0x080587D0;
	Mem0[edx + 0x0C:word32] = ebp;
	Mem0[edx + 16:word32] = ebx;
	Mem0[edx + 20:word32] = edi;
	eax = Mem0[edi + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ebx = CONVERT(Mem0[edi + eax:byte], byte, word32);
	eax -= ebx;
	SCZO = cond(eax);
	edi = eax + 1 + eax;
	eax = ecx;
	ebx = esi;
	ecx = edi;
	camlBuffer__advance_1104();
}

// 080590E0: define camlBuffer__advance_to_non_alpha_1108
// Called from:
//      camlBuffer__find_ident_1114
define camlBuffer__advance_to_non_alpha_1108
{
	esp = fp;
	Top = 0;
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x080588E0;
	Mem0[ecx + 0x0C:word32] = edx;
	eax = Mem0[edx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	edx = CONVERT(Mem0[edx + eax:byte], byte, word32);
	eax -= edx;
	SCZO = cond(eax);
	edx = eax + 1 + eax;
	eax = ebx;
	ebx = edx;
	camlBuffer__advance_1111();
}

// 08059140: define camlBuffer__find_ident_1114
// Called from:
//      camlBuffer__add_substitute_1122
define camlBuffer__find_ident_1114
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(ebx - ecx);
	if (Test(GE,SO))
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x08;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0400;
		Mem0[eax + 0x00:word32] = 134691416;
		fn08070A44();
		esi = esi;
		edi += 0x00;
	}
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 0x0C:word32] = eax;
	ecx = ebx;
	ecx >>= 0x01;
	edx = Mem0[eax + -4:word32];
	edx >>= 0x0A;
	edx = ~0x00 + edx * 0x04;
	esi = CONVERT(Mem0[eax + edx:byte], byte, word32);
	edx -= esi;
	SCZO = cond(edx - ecx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi = esi;
		edi += 0x00;
		camlBuffer__add_substitute_1122();
	}
	else
	{
		ecx = CONVERT(Mem0[eax + ecx:byte], byte, word32);
		ecx = ecx + 1 + ecx;
		SCZO = cond(ecx - 0x51);
		if (Test(NE,Z))
		{
			SCZO = cond(ecx - 0xF7);
			if (Test(NE,Z))
			{
				ebx += 0x02;
				SCZO = cond(ebx);
				camlBuffer__advance_to_non_alpha_1108();
				Mem0[esp + 0x00:word32] = eax;
				ebx = Mem0[esp + 8:word32];
				eax -= ebx;
				SCZO = cond(eax);
				ecx = eax;
				++ecx;
				SZO = cond(ecx);
				eax = Mem0[esp + 0x0C:word32];
				camlString__sub_1046();
				ecx = eax;
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				ebx = eax + 4;
				Mem0[ebx + -4:word32] = 0x0800;
				Mem0[ebx + 0x00:word32] = ecx;
				eax = Mem0[esp + 0x00:word32];
				Mem0[ebx + 4:word32] = eax;
				eax = ebx;
				esp += 0x10;
				SCZO = cond(esp);
				return;
			}
			Mem0[esp + 0x00:word32] = ecx;
		}
		else
			Mem0[esp + 0x00:word32] = ecx;
		ebx += 0x02;
		SCZO = cond(ebx);
		Mem0[esp + 4:word32] = ebx;
		eax = ecx;
		camlBuffer__closing_1097();
		ebx = eax;
		ecx = 0x01;
		eax = Mem0[esp + 0x00:word32];
		edx = Mem0[esp + 0x0C:word32];
		esi = Mem0[esp + 4:word32];
		camlBuffer__advance_to_closing_1098();
		Mem0[esp + 0x00:word32] = eax;
		ebx = Mem0[esp + 8:word32];
		eax -= ebx;
		eax -= 0x03;
		ecx = eax;
		ecx += 0x02;
		SCZO = cond(ecx);
		eax = Mem0[esp + 0x0C:word32];
		ebx = Mem0[esp + 4:word32];
		camlString__sub_1046();
		ebx = eax;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x0800;
		Mem0[eax + 0x00:word32] = ebx;
		ebx = Mem0[esp + 0x00:word32];
		ebx += 0x02;
		Mem0[eax + 4:word32] = ebx;
		esp += 0x10;
		SCZO = cond(esp);
	}
}

// 080592C0: define camlBuffer__add_substitute_1122
// Called from:
//      camlBuffer__find_ident_1114
define camlBuffer__add_substitute_1122
{
	esp = fp;
	Top = 0;
	esi = eax;
	edx = ecx;
	eax = Mem0[edx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ecx = CONVERT(Mem0[edx + eax:byte], byte, word32);
	eax -= ecx;
	SCZO = cond(eax);
	edi = eax + 1 + eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x20;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 0x1CF7;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x08058980;
	Mem0[ecx + 0x0C:word32] = esi;
	Mem0[ecx + 16:word32] = ebx;
	Mem0[ecx + 20:word32] = edx;
	Mem0[ecx + 24:word32] = edi;
	ebx = 0x01;
	eax = 0x41;
	camlBuffer__subst_1127();
}

// 08059330: define camlBuffer__entry
// Called from:
//      caml_program
define camlBuffer__entry
{
	Top_3 = 0;
	Mem5[0x0807A75C<p32>:word32] = 0x0807A8CC;
	Mem7[0x0807A760<p32>:word32] = 0x0807A8C0;
	Mem9[0x0807A764<p32>:word32] = 0x0807A8B0;
	Mem11[0x0807A768<p32>:word32] = 0x0807A8A0;
	Mem13[0x0807A76C<p32>:word32] = 0x0807A890;
	Mem15[0x0807A770<p32>:word32] = 0x0807A884;
	Mem17[0x0807A774<p32>:word32] = 0x0807A878;
	Mem19[0x0807A778<p32>:word32] = 0x0807A86C;
	Mem21[0x0807A798<p32>:word32] = 0x0807A85C;
	Mem23[0x0807A77C<p32>:word32] = 0x0807A84C;
	Mem25[0x0807A784<p32>:word32] = 0x0807A83C;
	Mem27[0x0807A780<p32>:word32] = 0x0807A82C;
	Mem29[0x0807A78C<p32>:word32] = 0x0807A81C;
	Mem31[0x0807A790<p32>:word32] = 0x0807A80C;
	Mem33[0x0807A794<p32>:word32] = 134719484;
	Mem35[0x0807A79C<p32>:word32] = 0x0807A7F0;
	Mem37[0x0807A7A0<p32>:word32] = 0x0807A7E0;
	Mem39[0x0807A7A4<p32>:word32] = 0x0807A7D0;
	Mem41[0x0807A7A8<p32>:word32] = 0x0807A7C0;
	Mem43[0x0807A788<p32>:word32] = 0x0807A7B0;
	eax_44 = 0x01;
}

// 08059400: define camlPrintf__fun_1673
define camlPrintf__fun_1673
{
	esp = fp;
	Top = 0;
	eax = ebx;
	ecx = Mem0[eax + 8:word32];
	ebx = Mem0[eax + 0x0C:word32];
	eax = Mem0[eax + 16:word32];
	camlPrintf__doprn_1360();
}

// 08059410: define camlPrintf__skip_int_literal_1092
// Called from:
//      camlPrintf__skip_positional_spec_1090
define camlPrintf__skip_int_literal_1092
{
	esp = fp;
	Top = 0;
	while (true)
	{
		edx = eax;
		edx >>= 0x01;
		ecx = Mem0[ebx + 8:word32];
		ecx = CONVERT(Mem0[ecx + edx:byte], byte, word32);
		ecx = ecx + 1 + ecx;
		SCZO = cond(ecx - 0x61);
		if (Test(LT,SO))
			break;
		SCZO = cond(ecx - 117);
		if (Test(GE,SO))
			goto l08059440;
		eax += 0x02;
		SCZO = cond(eax);
	}
	SCZO = cond(ecx - 0x49);
	if (Test(NE,Z))
	{
l08059440:
		eax = Mem0[ebx + 0x0C:word32];
	}
	else
	{
		eax += 0x02;
		SCZO = cond(eax);
	}
}

// 08059450: define camlPrintf__sub_sub_1129
// Called from:
//      camlPrintf__sub_1128
define camlPrintf__sub_sub_1129
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	ecx = Mem0[ebx + 20:word32];
	SCZO = cond(eax - ecx);
	if (Test(GE,SO))
	{
		edx = Mem0[ebx + 8:word32];
		eax = Mem0[ebx + 16:word32];
		ecx = Mem0[edx + 0x00:word32];
		ebx = edx;
		esp += 0x04;
		SCZO = cond(esp);
		ecx();
		return;
	}
	edx = Mem0[ebx + 16:word32];
	ecx = eax;
	ecx >>= 0x01;
	esi = Mem0[edx + -4:word32];
	esi >>= 0x0A;
	esi = ~0x00 + esi * 0x04;
	edi = CONVERT(Mem0[edx + esi:byte], byte, word32);
	esi -= edi;
	SCZO = cond(esi - ecx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		esi = esi;
		camlPrintf__sub_1128();
		return;
	}
	ecx = CONVERT(Mem0[edx + ecx:byte], byte, word32);
	edx = ecx + 1 + ecx;
	ecx = edx;
	ecx += ~0x4F;
	SCZO = cond(ecx - 0x03);
	if (Test(ULE,CZ))
	{
l080594BD:
		SCZO = cond(ecx - 0x01);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
l080594E0:
			ecx = Mem0[ebx + 24:word32];
			ebx = eax;
			ebx += 0x02;
			SCZO = cond(ebx);
			eax = edx;
			camlPrintf__sub_fmt_1124();
			ebx = Mem0[esp + 0x00:word32];
			ebx += ~0x0B;
			eax += 0x02;
			esp += 0x04;
			SCZO = cond(esp);
			camlPrintf__sub_1128();
			return;
		}
l08059500:
		ecx = Mem0[ebx + 32:word32];
		SCZO = cond(edx - ecx);
		if (Test(NE,Z))
		{
			esi = Mem0[ebx + 0x0C:word32];
			ecx = Mem0[ebx + 28:word32];
			eax = Mem0[ebx + 16:word32];
			ebx = ecx;
			ecx = edx;
			edx = esi;
			esp += 0x04;
			SCZO = cond(esp);
			caml_apply3();
		}
		else
		{
			eax += 0x02;
			esp += 0x04;
			SCZO = cond(esp);
		}
	}
	else
	{
		ecx += ~0xA5;
		SCZO = cond(ecx - 0x05);
		if (Test(ULE,CZ))
		{
			Mem0[esp + 0x00:word32] = ebx;
			ecx >>= 0x01;
			SCZO = cond(ecx - 0x01);
			if (Test(ULT,C))
				goto l080594E0;
			if (Test(NE,Z))
			{
				if (Test(GT,SZO))
					goto l08059500;
				goto l080594BD;
			}
		}
		ebx += ~0x0B;
		eax += 0x02;
		esp += 0x04;
		SCZO = cond(esp);
		camlPrintf__sub_1128();
	}
}

// 08059530: define camlPrintf__sub_1128
// Called from:
//      camlPrintf__sub_sub_1129
//      camlPrintf__sub_fmt_1124
//      camlPrintf__sub_format_1117
define camlPrintf__sub_1128
{
	esp = fp;
	Top = 0;
	while (true)
	{
		ecx = Mem0[ebx + 32:word32];
		SCZO = cond(eax - ecx);
		if (Test(GE,SO))
			break;
		edx = Mem0[ebx + 28:word32];
		ecx = eax;
		ecx >>= 0x01;
		esi = Mem0[edx + -4:word32];
		esi >>= 0x0A;
		esi = ~0x00 + esi * 0x04;
		edi = CONVERT(Mem0[edx + esi:byte], byte, word32);
		esi -= edi;
		SCZO = cond(esi - ecx);
		if (Test(ULE,CZ))
			fn08070B18();
		ecx = CONVERT(Mem0[edx + ecx:byte], byte, word32);
		ecx = ecx + 1 + ecx;
		SCZO = cond(ecx - 0x4B);
		if (Test(EQ,Z))
		{
			ebx += 0x0C;
			eax += 0x02;
			SCZO = cond(eax);
			camlPrintf__sub_sub_1129();
			return;
		}
		eax += 0x02;
		SCZO = cond(eax);
	}
	edx = Mem0[ebx + 20:word32];
	eax = Mem0[ebx + 28:word32];
	ecx = Mem0[edx + 0x00:word32];
	ebx = edx;
	ecx();
}

// 08059590: define camlPrintf__loop_1159
// Called from:
//      camlPrintf__sub_format_1117
define camlPrintf__loop_1159
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	while (true)
	{
		ecx = Mem0[ebx + 16:word32];
		ecx += ~0x03;
		SCZO = cond(eax - ecx);
		if (Test(GE,SO))
			break;
		Mem0[esp + 0x00:word32] = ebx;
		ecx = Mem0[ebx + 0x0C:word32];
		edx = Mem0[ebx + 8:word32];
		ebx = eax;
		ebx >>= 0x01;
		esi = Mem0[edx + -4:word32];
		esi >>= 0x0A;
		esi = ~0x00 + esi * 0x04;
		edi = CONVERT(Mem0[edx + esi:byte], byte, word32);
		esi -= edi;
		SCZO = cond(esi - ebx);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			camlPrintf__fun_1565();
			return;
		}
		ebx = CONVERT(Mem0[edx + ebx:byte], byte, word32);
		ebx = ebx + 1 + ebx;
		caml_apply2();
		ebx = Mem0[esp + 0x00:word32];
	}
	eax = 0x01;
	esp += 0x04;
	SCZO = cond(esp);
}

// 080595F0: define camlPrintf__fun_1565
// Called from:
//      camlPrintf__loop_1159
define camlPrintf__fun_1565
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	edx = eax;
	eax = Mem0[ecx + 0x0C:word32];
	eax -= edx;
	eax -= 0x03;
	eax += 0x02;
	esi = Mem0[ecx + 16:word32];
	ecx = Mem0[esi + -4:word32];
	edx = ecx;
	edx &= 0xFF;
	SCZO = cond(edx - 0xFE);
	if (Test(NE,Z))
	{
		ecx >>= 0x09;
		SCZO = cond(ecx - eax);
		if (Test(UGT,CZ))
		{
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			eax = esi - 2 + eax * 0x02;
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805963D;
		}
	}
	else
	{
		ecx >>= 0x0A;
		SCZO = cond(ecx - eax);
		if (Test(UGT,CZ))
		{
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebx + 0x00:real64];
			(esi - 4)[eax * 0x04] = ST[Top + 0x00:real64];
			++Top;
l0805963D:
			eax = 0x01;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	camlPrintf__fun_1568();
}

// 08059650: define camlPrintf__fun_1568
// Called from:
//      camlPrintf__fun_1565
define camlPrintf__fun_1568
{
	esp = fp;
	Top = 0;
	ecx = eax;
	edx = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x0800;
	Mem0[ebx + 0x00:word32] = ecx;
	eax = Mem0[edx + 16:word32];
	Mem0[ebx + 4:word32] = eax;
	ecx = Mem0[edx + 8:word32];
	eax = Mem0[edx + 0x0C:word32];
	eax += 0x02;
	SCZO = cond(eax);
	camlPrintf__loop_1240();
}

// 08059690: define camlPrintf__got_spec_1304
define camlPrintf__got_spec_1304
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 0x0C:word32] = ebx;
	ebx = ecx;
	Mem0[esp + 4:word32] = ebx;
	ecx = Mem0[ebx + 0x0C:word32];
	ebx = Mem0[ebx + 24:word32];
	camlPrintf__get_arg_1288();
	ebx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[esp + 8:word32] = ecx;
	Mem0[ecx + -4:word32] = 0x0800;
	Mem0[ecx + 0x00:word32] = ebx;
	eax = Mem0[esp + 4:word32];
	ebx = Mem0[eax + 28:word32];
	Mem0[ecx + 4:word32] = ebx;
	eax = Mem0[eax + 24:word32];
	ecx = Mem0[esp + 0x00:word32];
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
		ebx = eax;
	else
	{
		ecx = Mem0[0x0807AE0C<p32>:word32];
		ebx = Mem0[ecx + 8:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
		ebx = eax;
	}
	ecx = Mem0[esp + 4:word32];
	esi = Mem0[ecx + 16:word32];
	eax = Mem0[ecx + 20:word32];
	ecx = Mem0[esp + 8:word32];
	edx = Mem0[esp + 0x0C:word32];
	esp += 0x10;
	SCZO = cond(esp);
	camlPrintf__scan_flags_1292();
}

// 08059720: define camlPrintf__got_spec_1297
define camlPrintf__got_spec_1297
{
	esp = fp;
	Top = 0;
	edx = ebx;
	ebx = ecx;
	esi = Mem0[ebx + 0x0C:word32];
	ecx = Mem0[ebx + 20:word32];
	ebx = Mem0[ebx + 16:word32];
	camlPrintf__scan_flags_1292();
}

// 08059740: define camlPrintf__cont_m_1365
define camlPrintf__cont_m_1365
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = eax;
	eax = ebx;
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	camlPrintf__ac_of_format_1184();
	ebx = Mem0[eax + 0x00:word32];
	eax = Mem0[esp + 8:word32];
	eax = ebx - 1 + eax;
	camlPrintf__index_of_int_1037();
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x18;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x14F7;
	Mem0[eax + 0x00:word32] = 0x08059400;
	Mem0[eax + 4:word32] = 0x03;
	ecx = Mem0[esp + 0x00:word32];
	ebx = ecx;
	ebx += ~0x4F;
	Mem0[eax + 8:word32] = ebx;
	ebx = Mem0[esp + 4:word32];
	Mem0[eax + 0x0C:word32] = ebx;
	Mem0[eax + 16:word32] = edx;
	esi = Mem0[ecx + 32:word32];
	edx = Mem0[ecx + 44:word32];
	ebx = Mem0[esp + 8:word32];
	ecx = Mem0[esp + 0x0C:word32];
	esp += 0x10;
	SCZO = cond(esp);
	camlPrintf__pr_1354();
}

// 080597D0: define camlPrintf__cont_f_1364
define camlPrintf__cont_f_1364
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 0x00:word32] = ecx;
	ebx = Mem0[ecx + 40:word32];
	eax = Mem0[ecx + 44:word32];
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
	ecx = Mem0[esp + 0x00:word32];
	ecx += ~0x3F;
	eax = Mem0[esp + 4:word32];
	ebx = Mem0[esp + 8:word32];
	esp += 0x0C;
	SCZO = cond(esp);
	camlPrintf__doprn_1360();
}

// 08059800: define camlPrintf__cont_t_1363
define camlPrintf__cont_t_1363
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 8:word32] = edx;
	eax = Mem0[edx + 44:word32];
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		eax = 0x01;
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
		ebx = eax;
		eax = Mem0[esp + 8:word32];
		ecx = Mem0[eax + 52:word32];
		eax = Mem0[eax + 60:word32];
		caml_apply2();
	}
	else
	{
		eax = Mem0[edx + 60:word32];
		ecx = Mem0[ebx + 0x00:word32];
		ecx();
	}
	ecx = Mem0[esp + 8:word32];
	ecx += ~0x2F;
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[esp + 4:word32];
	esp += 0x0C;
	SCZO = cond(esp);
	camlPrintf__doprn_1360();
}

// 08059860: define camlPrintf__cont_a_1362
define camlPrintf__cont_a_1362
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	Mem0[esp + 0x00:word32] = eax;
	edi = ebx;
	ebx = ecx;
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 8:word32] = esi;
	eax = Mem0[esi + 60:word32];
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		eax = 0x01;
		ecx = edi;
		caml_apply2();
		ebx = eax;
		eax = Mem0[esp + 8:word32];
		ecx = Mem0[eax + 0x0044:word32];
		eax = Mem0[eax + 76:word32];
		caml_apply2();
	}
	else
	{
		eax = Mem0[esi + 76:word32];
		ecx = edi;
		caml_apply2();
	}
	ecx = Mem0[esp + 8:word32];
	ecx += ~0x1F;
	eax = Mem0[esp + 0x00:word32];
	ebx = Mem0[esp + 4:word32];
	esp += 0x0C;
	SCZO = cond(esp);
	camlPrintf__doprn_1360();
}

// 080598C0: define camlPrintf__cont_s_1361
define camlPrintf__cont_s_1361
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	ecx = Mem0[edx + 84:word32];
	eax = Mem0[edx + 92:word32];
	caml_apply2();
	ecx = Mem0[esp + 0x00:word32];
	ecx += ~0x0F;
	eax = Mem0[esp + 4:word32];
	ebx = Mem0[esp + 8:word32];
	esp += 0x0C;
	SCZO = cond(esp);
	camlPrintf__doprn_1360();
}

// 080598F0: define camlPrintf__doprn_1360
// Called from:
//      camlPrintf__fun_1673
//      camlPrintf__cont_f_1364
//      camlPrintf__cont_t_1363
//      camlPrintf__cont_a_1362
//      camlPrintf__cont_s_1361
//      camlPrintf__pr_1354
define camlPrintf__doprn_1360
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		ebp = eax;
		edx = ebx;
		eax = Mem0[ecx + 0x80:word32];
		SCZO = cond(edx - eax);
		if (Test(GE,SO))
			break;
		ebx = edx;
		ebx >>= 0x01;
		eax = Mem0[ecx + 0x0078:word32];
		eax = CONVERT(Mem0[eax + ebx:byte], byte, word32);
		ebx = eax + 1 + eax;
		SCZO = cond(ebx - 0x4B);
		if (Test(EQ,Z))
		{
			eax = ecx;
			eax += 0x50;
			Mem0[esp + 4:word32] = eax;
			eax = ecx;
			eax += 0x40;
			Mem0[esp + 0x00:word32] = eax;
			Mem0[esp + 8:word32] = ecx;
			v14 = Mem0[esp + 8:word32] + 0x30;
			Mem0[esp + 8:word32] = v14;
			edi = ecx;
			edi += 0x20;
			esi = ecx;
			esi += 0x10;
			ebx = Mem0[ecx + 0x007C:word32];
			eax = Mem0[ecx + 0x0078:word32];
			ecx = ebp;
			ebp = Mem0[esp + 8:word32];
			Mem0[0x0807D0BC<p32>:word32] = ebp;
			ebp = Mem0[esp + 0x00:word32];
			Mem0[0x0807D0C0<p32>:word32] = ebp;
			ebp = Mem0[esp + 4:word32];
			Mem0[0x0807D0C4<p32>:word32] = ebp;
			esp += 0x0C;
			SCZO = cond(esp);
			camlPrintf__scan_format_1278();
			return;
		}
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = edx;
		Mem0[esp + 4:word32] = ebp;
		edx = Mem0[ecx + 96:word32];
		eax = Mem0[ecx + 0x006C:word32];
		ecx = edx;
		caml_apply2();
		ebx = Mem0[esp + 0x00:word32];
		ebx += 0x02;
		SCZO = cond(ebx);
		eax = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
	}
	ebx = Mem0[ecx + 116:word32];
	eax = Mem0[ecx + 0x006C:word32];
	ecx = Mem0[ebx + 0x00:word32];
	esp += 0x0C;
	SCZO = cond(esp);
	ecx();
}

// 080599B0: define camlPrintf__fun_1686
define camlPrintf__fun_1686
{
	esp = fp;
	Top = 0;
	eax = 0x01;
}

// 080599C0: define camlPrintf__parse_1069
// Called from:
//      fn0805B9A0
define camlPrintf__parse_1069
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	while (true)
	{
		edx = eax;
		esi = Mem0[ecx + 0x0C:word32];
		eax = Mem0[esi + -4:word32];
		eax >>= 0x0A;
		eax = ~0x00 + eax * 0x04;
		esi = CONVERT(Mem0[esi + eax:byte], byte, word32);
		eax -= esi;
		eax = eax + 1 + eax;
		SCZO = cond(ebx - eax);
		if (Test(GE,SO))
			break;
		esi = ebx;
		esi >>= 0x01;
		eax = Mem0[ecx + 0x0C:word32];
		eax = CONVERT(Mem0[eax + esi:byte], byte, word32);
		eax = eax + 1 + eax;
		SCZO = cond(eax - 99);
		if (Test(GE,SO))
		{
			SCZO = cond(eax - 117);
			if (Test(LT,SO))
			{
				Mem0[esp + 0x00:word32] = edx;
				esi = Mem0[ecx + 0x0C:word32];
				eax = Mem0[esi + -4:word32];
				eax >>= 0x0A;
				edx = ~0x00 + eax * 0x04;
				eax = CONVERT(Mem0[esi + edx:byte], byte, word32);
				edx -= eax;
				edx <<= 0x01;
				edx -= ebx;
				edx -= 0x03;
				edx += 0x03;
				SCZO = cond(edx);
				eax = Mem0[ecx + 0x0C:word32];
				ecx = edx;
				camlString__sub_1046();
				esp -= 4;
				Mem0[esp + 0x00:word32] = eax;
				eax = 0x080668B4;
				fn080709D8();
				esp += 0x04;
				SCZO = cond(esp);
				ecx = eax;
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				ebx = eax + 4;
				Mem0[ebx + -4:word32] = 0x0800;
				Mem0[ebx + 0x00:word32] = ecx;
				eax = Mem0[esp + 0x00:word32];
				Mem0[ebx + 4:word32] = eax;
				eax = ebx;
				esp += 0x04;
				SCZO = cond(esp);
				return;
			}
		}
		else
		{
			SCZO = cond(eax - 0x5B);
			if (Test(EQ,Z))
			{
				ebx += 0x02;
				SCZO = cond(ebx);
				eax = 0x03;
				continue;
			}
		}
		ebx += 0x02;
		SCZO = cond(ebx);
		eax = edx;
	}
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x0C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x0800;
	Mem0[eax + 0x00:word32] = 0x01;
	Mem0[eax + 4:word32] = edx;
	esp += 0x04;
	SCZO = cond(esp);
}

// 08059AF0: define camlPrintf__skip_positional_spec_1090
// Called from:
//      camlPrintf__fill_format_1096
//      camlPrintf__extract_format_1085
define camlPrintf__skip_positional_spec_1090
{
	esp = fp;
	Top = 0;
	ecx = eax;
	edx = ecx;
	edx >>= 0x01;
	eax = Mem0[ebx + 8:word32];
	eax = CONVERT(Mem0[eax + edx:byte], byte, word32);
	eax = eax + 1 + eax;
	eax += ~0x5F;
	SCZO = cond(eax - 0x13);
	if (Test(ULE,CZ))
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x14;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		edx = eax + 4;
		Mem0[edx + -4:word32] = 4343;
		Mem0[edx + 0x00:word32] = 0x08059410;
		Mem0[edx + 4:word32] = 0x03;
		eax = Mem0[ebx + 8:word32];
		Mem0[edx + 8:word32] = eax;
		Mem0[edx + 0x0C:word32] = ecx;
		eax = ecx;
		eax += 0x02;
		SCZO = cond(eax);
		ebx = edx;
		camlPrintf__skip_int_literal_1092();
	}
	else
		eax = ecx;
}

// 08059B60: define camlPrintf__fill_format_1096
// Called from:
//      camlPrintf__extract_format_1085
define camlPrintf__fill_format_1096
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		edx = Mem0[ecx + 16:word32];
		SCZO = cond(eax - edx);
		if (Test(GT,SZO))
			break;
		esi = eax;
		esi >>= 0x01;
		edx = Mem0[ecx + 0x0C:word32];
		edx = CONVERT(Mem0[edx + esi:byte], byte, word32);
		edx = edx + 1 + edx;
		SCZO = cond(edx - 0x55);
		if (Test(EQ,Z))
		{
			SCZO = cond(ebx - 0x01);
			if (Test(EQ,Z))
			{
				while (true)
				{
					eax = Mem0[0x08080414<p32>:word32];
					eax -= 0x0C;
					Mem0[0x08080414<p32>:word32] = eax;
					SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
					if (Test(UGE,C))
						break;
					fn080708CC();
				}
				eax += 4;
				Mem0[eax + -4:word32] = 0x0800;
				Mem0[eax + 0x00:word32] = 134691556;
				Mem0[eax + 4:word32] = 134722100;
				fn08070A44();
				break;
			}
			else
			{
				Mem0[esp + 8:word32] = ecx;
				Mem0[esp + 4:word32] = eax;
				eax = Mem0[ebx + 4:word32];
				Mem0[esp + 0x00:word32] = eax;
				eax = Mem0[ebx + 0x00:word32];
				camlPervasives__string_of_int_1130();
				ebx = eax;
				eax = Mem0[esp + 8:word32];
				eax = Mem0[eax + 24:word32];
				camlBuffer__add_string_1082();
				eax = Mem0[esp + 8:word32];
				ebx = Mem0[eax + 20:word32];
				eax = Mem0[esp + 4:word32];
				eax += 0x02;
				SCZO = cond(eax);
				camlPrintf__skip_positional_spec_1090();
				ebx = Mem0[esp + 0x00:word32];
				ecx = Mem0[esp + 8:word32];
				continue;
			}
		}
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ecx + 24:word32];
		ebx = edx;
		camlBuffer__add_char_1072();
		eax = Mem0[esp + 4:word32];
		eax += 0x02;
		SCZO = cond(eax);
		ebx = Mem0[esp + 0x00:word32];
		ecx = Mem0[esp + 8:word32];
	}
	eax = 0x01;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 08059C50: define camlPrintf__sub_fmt_1124
// Called from:
//      camlPrintf__sub_fmt_1124
//      camlPrintf__sub_format_1117
define camlPrintf__sub_fmt_1124
{
	esp = fp;
	Top = 0;
	edx = ebx;
	SCZO = cond(eax - 0x51);
	if (Test(EQ,Z))
		esi = 0x53;
	else
		esi = 0xFB;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x34;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x30F7;
	Mem0[ebx + 0x00:word32] = 0x08059530;
	Mem0[ebx + 4:word32] = 0x03;
	Mem0[ebx + 8:word32] = 3321;
	Mem0[ebx + 0x0C:word32] = 0x08059450;
	Mem0[ebx + 16:word32] = 0x03;
	eax = Mem0[ecx + 0x0C:word32];
	Mem0[ebx + 20:word32] = eax;
	eax = Mem0[ecx + 16:word32];
	Mem0[ebx + 24:word32] = eax;
	eax = Mem0[ecx + 20:word32];
	Mem0[ebx + 28:word32] = eax;
	eax = Mem0[ecx + 24:word32];
	Mem0[ebx + 32:word32] = eax;
	Mem0[ebx + 36:word32] = ecx;
	Mem0[ebx + 40:word32] = edx;
	Mem0[ebx + 44:word32] = esi;
	eax = edx;
	camlPrintf__sub_1128();
}

// 08059CE0: define camlPrintf__scan_fmt_1144
// Called from:
//      camlPrintf__iter_on_format_args_1137
define camlPrintf__scan_fmt_1144
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	while (true)
	{
		ecx = Mem0[ebx + 20:word32];
		SCZO = cond(eax - ecx);
		if (Test(GE,SO))
			break;
		esi = Mem0[ebx + 8:word32];
		edx = eax;
		edx >>= 0x01;
		ecx = Mem0[esi + -4:word32];
		ecx >>= 0x0A;
		ecx = ~0x00 + ecx * 0x04;
		edi = CONVERT(Mem0[esi + ecx:byte], byte, word32);
		ecx -= edi;
		SCZO = cond(ecx - edx);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			esi += 0x00;
			camlPrintf__scan_conv_1143();
			return;
		}
		ecx = CONVERT(Mem0[esi + edx:byte], byte, word32);
		ecx = ecx + 1 + ecx;
		SCZO = cond(ecx - 0x4B);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
			ecx = ebx;
			ecx += ~0x1F;
			ebx = eax;
			ebx += 0x02;
			SCZO = cond(ebx);
			eax = 0x01;
			camlPrintf__scan_flags_1142();
			ebx = Mem0[esp + 0x00:word32];
		}
		else
		{
			eax += 0x02;
			SCZO = cond(eax);
		}
	}
	esp += 0x04;
	SCZO = cond(esp);
}

// 08059D60: define camlPrintf__scan_conv_1143
// Called from:
//      camlPrintf__scan_fmt_1144
//      camlPrintf__scan_flags_1142
define camlPrintf__scan_conv_1143
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	edx = ecx;
	ecx = Mem0[edx + 36:word32];
	SCZO = cond(ebx - ecx);
	if (Test(LE,SZO))
	{
		esi = ebx;
		esi >>= 0x01;
		ecx = Mem0[edx + 24:word32];
		ecx = CONVERT(Mem0[ecx + esi:byte], byte, word32);
		ecx = ecx + 1 + ecx;
		SCZO = cond(ecx - 0xFD);
		if (Test(GE,SO))
		{
			eax = Mem0[edx + 24:word32];
			esp += 0x10;
			SCZO = cond(esp);
			camlPrintf__bad_conversion_format_1061();
		}
		else
		{
			Mem0[esp + 0x0C:word32] = edx;
			Mem0[esp + 8:word32] = eax;
			esi = ecx;
			esi >>= 0x01;
			SCZ = cond(esi);
			O = false;
			0x0807B250[esi * 0x04]();
		}
	}
	else
	{
		eax = Mem0[edx + 24:word32];
		esp += 0x10;
		SCZO = cond(esp);
		camlPrintf__incomplete_format_1065();
	}
}

// 08059FA0: define camlPrintf__scan_flags_1142
// Called from:
//      camlPrintf__scan_fmt_1144
define camlPrintf__scan_flags_1142
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		edx = Mem0[ecx + 52:word32];
		SCZO = cond(ebx - edx);
		if (Test(GT,SZO))
			break;
		esi = ebx;
		esi >>= 0x01;
		edx = Mem0[ecx + 40:word32];
		edx = CONVERT(Mem0[edx + esi:byte], byte, word32);
		edx = edx + 1 + edx;
		SCZO = cond(edx - 117);
		if (Test(LT,SO))
		{
			SCZO = cond(edx - 0x41);
			if (Test(GE,SO))
			{
				Mem0[esp + 4:word32] = ecx;
				Mem0[esp + 0x00:word32] = eax;
				edx += ~0x3F;
				edx >>= 0x01;
				SCZ = cond(edx);
				O = false;
				0x0807B4CC[edx * 0x04]();
				return;
			}
l0805A030:
			ecx += 0x10;
			esp += 0x08;
			SCZO = cond(esp);
			camlPrintf__scan_conv_1143();
			return;
		}
		SCZO = cond(edx - 191);
		if (Test(NE,Z))
			goto l0805A030;
		ebx += 0x02;
		SCZO = cond(ebx);
		eax = 0x03;
	}
	eax = Mem0[ecx + 40:word32];
	esp += 0x08;
	SCZO = cond(esp);
	camlPrintf__incomplete_format_1065();
}

// 0805A060: define camlPrintf__add_char_1166
define camlPrintf__add_char_1166
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[ecx + 0x0C:word32];
	camlBuffer__add_char_1072();
	eax = Mem0[esp + 0x00:word32];
	eax += 0x02;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0805A080: define camlPrintf__add_conv_1169
define camlPrintf__add_conv_1169
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		ebx = 0x0807B22C;
		eax = Mem0[edx + 0x0C:word32];
		camlBuffer__add_string_1082();
	}
	else
	{
		ebx = 0x4B;
		eax = Mem0[edx + 0x0C:word32];
		camlBuffer__add_char_1072();
	}
	eax = Mem0[esp + 0x00:word32];
	eax = Mem0[eax + 16:word32];
	eax = Mem0[eax + 0x0C:word32];
	ebx = Mem0[esp + 4:word32];
	camlBuffer__add_char_1072();
	eax = Mem0[esp + 8:word32];
	eax += 0x02;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0805A0E0: define camlPrintf__incr_ac_1187
// Called from:
//      camlPrintf__add_conv_1191
define camlPrintf__incr_ac_1187
{
	esp = fp;
	Top = 0;
	SCZO = cond(ebx - 0xC3);
	if (Test(EQ,Z))
		edx = 0x05;
	else
		edx = 0x03;
	SCZO = cond(ebx - 229);
	if (Test(EQ,Z))
	{
		ebx = Mem0[ecx + 0x0C:word32];
		v9 = Mem0[ebx + 8:word32] + 0x02;
		Mem0[ebx + 8:word32] = v9;
		SCZO = cond(v9);
	}
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		ebx = Mem0[ecx + 0x0C:word32];
		eax = Mem0[ecx + 0x0C:word32];
		eax = Mem0[eax + 0x00:word32];
		eax = eax - 1 + edx;
		Mem0[ebx + 0x00:word32] = eax;
		eax = 0x01;
	}
	else
	{
		ebx = Mem0[ecx + 0x0C:word32];
		eax = Mem0[ecx + 0x0C:word32];
		eax = Mem0[eax + 4:word32];
		eax = eax - 1 + edx;
		Mem0[ebx + 4:word32] = eax;
		eax = 0x01;
	}
}

// 0805A140: define camlPrintf__add_conv_1191
define camlPrintf__add_conv_1191
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	Mem0[esp + 0x00:word32] = ebx;
	SCZO = cond(ecx - 0x53);
	if (Test(NE,Z))
	{
		SCZO = cond(ecx - 0xFB);
		if (Test(NE,Z))
		{
			edx = Mem0[edx + 0x0C:word32];
			ebx = ecx;
			ecx = edx;
			camlPrintf__incr_ac_1187();
		}
	}
	eax = Mem0[esp + 0x00:word32];
	eax += 0x02;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0805A170: define camlPrintf__add_char_1192
define camlPrintf__add_char_1192
{
	esp = fp;
	Top = 0;
	eax += 0x02;
	SCZO = cond(eax);
}

// 0805A180: define camlPrintf__loop_1204
// Called from:
//      camlPrintf__list_iter_i_1201
define camlPrintf__loop_1204
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	while (true)
	{
		SCZO = cond(ebx - 0x01);
		if (Test(EQ,Z))
			break;
		edx = Mem0[ebx + 4:word32];
		ebx = Mem0[ebx + 0x00:word32];
		SCZO = cond(edx - 0x01);
		if (Test(EQ,Z))
		{
			ecx = Mem0[ecx + 0x0C:word32];
			esp += 0x0C;
			SCZO = cond(esp);
			caml_apply2();
			return;
		}
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 0x00:word32] = eax;
		ecx = Mem0[ecx + 0x0C:word32];
		caml_apply2();
		eax = Mem0[esp + 0x00:word32];
		eax += 0x02;
		SCZO = cond(eax);
		ebx = Mem0[esp + 4:word32];
		ecx = Mem0[esp + 8:word32];
	}
	eax = 0x01;
	esp += 0x0C;
	SCZO = cond(esp);
}

// 0805A1E0: define camlPrintf__loop_1240
// Called from:
//      camlPrintf__fun_1568
//      camlPrintf__kapr_1209
define camlPrintf__loop_1240
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	edx = eax;
	eax = Mem0[ecx + 20:word32];
	SCZO = cond(edx - eax);
	if (Test(LT,SO))
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x18;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x14F7;
		Mem0[eax + 0x00:word32] = 0x08059650;
		Mem0[eax + 4:word32] = 0x03;
		Mem0[eax + 8:word32] = ecx;
		Mem0[eax + 0x0C:word32] = edx;
		Mem0[eax + 16:word32] = ebx;
		esp += 0x0C;
		SCZO = cond(esp);
	}
	else
	{
		Mem0[esp + 4:word32] = ecx;
		Mem0[esp + 0x00:word32] = ebx;
		esp -= 4;
		Mem0[esp + 0x00:word32] = 0x01;
		v10 = Mem0[ecx + 20:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = v10;
		eax = 0x080683F9;
		fn080709D8();
		esp += 0x08;
		SCZO = cond(esp);
		ecx = eax;
		Mem0[esp + 8:word32] = ecx;
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x18;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		eax += 4;
		Mem0[eax + -4:word32] = 0x14F7;
		Mem0[eax + 0x00:word32] = 0x0804B370;
		Mem0[eax + 4:word32] = 0x05;
		Mem0[eax + 8:word32] = 0x080595F0;
		ebx = Mem0[esp + 4:word32];
		ebx = Mem0[ebx + 20:word32];
		Mem0[eax + 0x0C:word32] = ebx;
		Mem0[eax + 16:word32] = ecx;
		ebx = Mem0[esp + 0x00:word32];
		camlPrintf__list_iter_i_1201();
		eax = Mem0[esp + 4:word32];
		ecx = Mem0[eax + 0x0C:word32];
		eax = Mem0[eax + 16:word32];
		ebx = Mem0[esp + 8:word32];
		esp += 0x0C;
		SCZO = cond(esp);
		caml_apply2();
	}
}

// 0805A2D0: define camlPrintf__fun_1587
define camlPrintf__fun_1587
{
	esp = fp;
	Top = 0;
	esp -= 0x24;
	SCZO = cond(esp);
	Mem0[esp + 24:word32] = eax;
	Mem0[esp + 20:word32] = ebx;
	Mem0[esp + 16:word32] = ecx;
	Mem0[esp + 0x0C:word32] = edx;
	Mem0[esp + 8:word32] = esi;
	Mem0[esp + 4:word32] = edi;
	eax = Mem0[0x0807D0BC<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x0D;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	ebx = eax;
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805A529;
		eax = Mem0[esp + 24:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805A524;
		eax = Mem0[esp + 24:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805A51F;
		eax = Mem0[esp + 20:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x04;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805A51A;
		eax = Mem0[esp + 20:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 8:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x05);
		if (Test(ULE,CZ))
			goto l0805A515;
		eax = Mem0[esp + 16:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x08;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x05);
		if (Test(ULE,CZ))
			goto l0805A510;
		eax = Mem0[esp + 16:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 16:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x07);
		if (Test(ULE,CZ))
			goto l0805A50B;
		eax = Mem0[esp + 0x0C:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x0C;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x07);
		if (Test(ULE,CZ))
			goto l0805A506;
		eax = Mem0[esp + 0x0C:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 24:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x09);
		if (Test(ULE,CZ))
			goto l0805A501;
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x10;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x09);
		if (Test(ULE,CZ))
			goto l0805A4FC;
		eax = Mem0[esp + 8:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 32:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 11);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = ebx;
			eax += 0x14;
			SCZO = cond(eax);
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805A4E1;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 11);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[ebx + 40:real64] = ST[Top + 0x00:real64];
			++Top;
l0805A4E1:
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[eax + 0x0C:word32];
			eax = Mem0[eax + 16:word32];
			esp += 0x24;
			SCZO = cond(esp);
			caml_apply2();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
l0805A4FC:
	fn08070B18();
l0805A501:
	fn08070B18();
l0805A506:
	fn08070B18();
l0805A50B:
	fn08070B18();
l0805A510:
	fn08070B18();
l0805A515:
	fn08070B18();
l0805A51A:
	fn08070B18();
l0805A51F:
	fn08070B18();
l0805A524:
	fn08070B18();
l0805A529:
	fn08070B18();
	camlPrintf__fun_1584();
}

// 0805A530: define camlPrintf__fun_1584
// Called from:
//      camlPrintf__fun_1587
define camlPrintf__fun_1584
{
	esp = fp;
	Top = 0;
	esp -= 0x20;
	SCZO = cond(esp);
	Mem0[esp + 20:word32] = eax;
	Mem0[esp + 16:word32] = ebx;
	Mem0[esp + 0x0C:word32] = ecx;
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 11;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	ebx = eax;
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805A71F;
		eax = Mem0[esp + 20:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805A71A;
		eax = Mem0[esp + 20:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805A715;
		eax = Mem0[esp + 16:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x04;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805A710;
		eax = Mem0[esp + 16:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 8:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x05);
		if (Test(ULE,CZ))
			goto l0805A70B;
		eax = Mem0[esp + 0x0C:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x08;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x05);
		if (Test(ULE,CZ))
			goto l0805A706;
		eax = Mem0[esp + 0x0C:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 16:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x07);
		if (Test(ULE,CZ))
			goto l0805A701;
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x0C;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x07);
		if (Test(ULE,CZ))
			goto l0805A6FC;
		eax = Mem0[esp + 8:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 24:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x09);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = ebx;
			eax += 0x10;
			SCZO = cond(eax);
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805A6E1;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x09);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[ebx + 32:real64] = ST[Top + 0x00:real64];
			++Top;
l0805A6E1:
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[eax + 0x0C:word32];
			eax = Mem0[eax + 16:word32];
			esp += 0x20;
			SCZO = cond(esp);
			caml_apply2();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
l0805A6FC:
	fn08070B18();
l0805A701:
	fn08070B18();
l0805A706:
	fn08070B18();
l0805A70B:
	fn08070B18();
l0805A710:
	fn08070B18();
l0805A715:
	fn08070B18();
l0805A71A:
	fn08070B18();
l0805A71F:
	fn08070B18();
	esi += 0x00;
	edi += 0x00;
	camlPrintf__fun_1581();
}

// 0805A730: define camlPrintf__fun_1581
// Called from:
//      camlPrintf__fun_1584
define camlPrintf__fun_1581
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	Mem0[esp + 16:word32] = eax;
	Mem0[esp + 0x0C:word32] = ebx;
	Mem0[esp + 8:word32] = ecx;
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x09;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	ebx = eax;
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805A8C5;
		eax = Mem0[esp + 16:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805A8C0;
		eax = Mem0[esp + 16:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805A8BB;
		eax = Mem0[esp + 0x0C:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x04;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805A8B6;
		eax = Mem0[esp + 0x0C:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 8:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x05);
		if (Test(ULE,CZ))
			goto l0805A8B1;
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x08;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x05);
		if (Test(ULE,CZ))
			goto l0805A8AC;
		eax = Mem0[esp + 8:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 16:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x07);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = ebx;
			eax += 0x0C;
			SCZO = cond(eax);
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805A891;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x07);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[ebx + 24:real64] = ST[Top + 0x00:real64];
			++Top;
l0805A891:
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[eax + 0x0C:word32];
			eax = Mem0[eax + 16:word32];
			esp += 0x1C;
			SCZO = cond(esp);
			caml_apply2();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
l0805A8AC:
	fn08070B18();
l0805A8B1:
	fn08070B18();
l0805A8B6:
	fn08070B18();
l0805A8BB:
	fn08070B18();
l0805A8C0:
	fn08070B18();
l0805A8C5:
	fn08070B18();
	esi += 0x00;
	camlPrintf__fun_1578();
}

// 0805A8D0: define camlPrintf__fun_1578
// Called from:
//      camlPrintf__fun_1581
define camlPrintf__fun_1578
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 0x00:word32] = edx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x07;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	ebx = eax;
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805AA0B;
		eax = Mem0[esp + 0x0C:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805AA06;
		eax = Mem0[esp + 0x0C:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805AA01;
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		eax = ebx;
		eax += 0x04;
		SCZO = cond(eax);
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x03);
		if (Test(ULE,CZ))
			goto l0805A9FC;
		eax = Mem0[esp + 8:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 8:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x05);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = ebx;
			eax += 0x08;
			SCZO = cond(eax);
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805A9E1;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x05);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[ebx + 16:real64] = ST[Top + 0x00:real64];
			++Top;
l0805A9E1:
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[eax + 0x0C:word32];
			eax = Mem0[eax + 16:word32];
			esp += 0x18;
			SCZO = cond(esp);
			caml_apply2();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
l0805A9FC:
	fn08070B18();
l0805AA01:
	fn08070B18();
l0805AA06:
	fn08070B18();
l0805AA0B:
	fn08070B18();
	camlPrintf__fun_1575();
}

// subject_text_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0805AA10: define camlPrintf__fun_1575
// Called from:
//      camlPrintf__fun_1578
define camlPrintf__fun_1575
{
	esp = fp;
	Top = 0;
	esp -= 0x14;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 0x00:word32] = ecx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x05;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	ebx = eax;
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805AAD1;
		eax = Mem0[esp + 8:word32];
		esp -= 4;
		Mem0[esp + 0x00:word32] = eax;
		esp -= 4;
		Mem0[esp + 0x00:word32] = ebx;
		caml_modify();
		esp += 0x08;
		SCZO = cond(esp);
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(ULE,CZ))
			goto l0805AACC;
		eax = Mem0[esp + 8:word32];
		--Top;
		ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
		Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x03);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			eax = ebx;
			eax += 0x04;
			SCZO = cond(eax);
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805AAB1;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x03);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[ebx + 8:real64] = ST[Top + 0x00:real64];
			++Top;
l0805AAB1:
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[eax + 0x0C:word32];
			eax = Mem0[eax + 16:word32];
			esp += 0x14;
			SCZO = cond(esp);
			caml_apply2();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
l0805AACC:
	fn08070B18();
l0805AAD1:
	fn08070B18();
	esi = esi;
	edi += 0x00;
	camlPrintf__fun_1572();
}

// 0805AAE0: define camlPrintf__fun_1572
// Called from:
//      camlPrintf__fun_1575
define camlPrintf__fun_1572
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x01;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x03;
	eax = 0x080683F9;
	fn080709D8();
	esp += 0x08;
	ebx = eax;
	eax = Mem0[ebx + -4:word32];
	ecx = eax;
	ecx &= 0xFF;
	SCZO = cond(ecx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - 0x01);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			esp -= 4;
			Mem0[esp + 0x00:word32] = eax;
			esp -= 4;
			Mem0[esp + 0x00:word32] = ebx;
			caml_modify();
			esp += 0x08;
			SCZO = cond(esp);
			goto l0805AB40;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - 0x01);
		if (Test(UGT,CZ))
		{
			eax = Mem0[esp + 4:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[ebx + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
l0805AB40:
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[eax + 8:word32];
			eax = Mem0[eax + 0x0C:word32];
			esp += 0x10;
			SCZO = cond(esp);
			caml_apply2();
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	esi = esi;
	camlPrintf__get_int_literal_1258();
}

// 0805AB60: define camlPrintf__get_int_literal_1258
// Called from:
//      camlPrintf__fun_1572
//      camlPrintf__scan_positional_spec_1252
define camlPrintf__get_int_literal_1258
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		esi = ebx;
		esi >>= 0x01;
		edx = Mem0[ecx + 0x0C:word32];
		edx = CONVERT(Mem0[edx + esi:byte], byte, word32);
		edx = edx + 1 + edx;
		SCZO = cond(edx - 0x61);
		if (Test(LT,SO))
			break;
		SCZO = cond(edx - 117);
		if (Test(GE,SO))
			goto l0805AC00;
		ebx += 0x02;
		eax >>= 0x01;
		eax *= 0x14;
		SCZO = cond(eax);
		eax = eax - 96 + edx;
	}
	SCZO = cond(edx - 0x49);
	if (Test(NE,Z))
	{
l0805AC00:
		edx = Mem0[ecx + 16:word32];
		ebx = Mem0[ecx + 20:word32];
		eax = 0x01;
		ecx = edx;
		esp += 0x08;
		SCZO = cond(esp);
		caml_apply2();
	}
	else
	{
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = ecx;
			Mem0[esp + 4:word32] = ebx;
			eax += ~0x01;
			SCZO = cond(eax);
			camlPrintf__index_of_int_1037();
			ebx = eax;
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x08;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			edx = eax + 4;
			Mem0[edx + -4:word32] = 0x0400;
			Mem0[edx + 0x00:word32] = ebx;
			eax = Mem0[esp + 0x00:word32];
			ecx = Mem0[eax + 16:word32];
			ebx = Mem0[esp + 4:word32];
			ebx += 0x02;
			eax = edx;
			esp += 0x08;
			SCZO = cond(esp);
			caml_apply2();
		}
		else
		{
			eax = 134722044;
			esp += 0x08;
			SCZO = cond(esp);
			camlPervasives__failwith_1010();
		}
	}
}

// 0805AC20: define camlPrintf__valid_float_loop_1273
// Called from:
//      camlPrintf__make_valid_float_lexeme_1270
define camlPrintf__valid_float_loop_1273
{
	esp = fp;
	Top = 0;
	while (true)
	{
		ecx = Mem0[ebx + 0x0C:word32];
		SCZO = cond(eax - ecx);
		if (Test(GE,SO))
			break;
		edx = Mem0[ebx + 8:word32];
		ecx = eax;
		ecx >>= 0x01;
		esi = Mem0[edx + -4:word32];
		esi >>= 0x0A;
		esi = ~0x00 + esi * 0x04;
		edi = CONVERT(Mem0[edx + esi:byte], byte, word32);
		esi -= edi;
		SCZO = cond(esi - ecx);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			esi += 0x00;
		}
		ecx = CONVERT(Mem0[edx + ecx:byte], byte, word32);
		ecx = ecx + 1 + ecx;
		ecx += ~0x5B;
		SCZO = cond(ecx - 0x2F);
		if (Test(UGT,CZ))
		{
			SCZO = cond(ecx - 111);
			if (Test(NE,Z))
				goto l0805AC88;
l0805AC90:
			eax = Mem0[ebx + 8:word32];
			return;
		}
		ecx += ~0x01;
		SCZO = cond(ecx - 0x2B);
		if (Test(UGT,CZ))
			goto l0805AC90;
l0805AC88:
		eax += 0x02;
		SCZO = cond(eax);
	}
	ecx = 0x0807B1F4;
	eax = Mem0[ebx + 8:word32];
	ebx = ecx;
	camlPervasives__$5e_1112();
}

// 0805ACA0: define camlPrintf__get_arg_1288
// Called from:
//      camlPrintf__got_spec_1304
//      camlPrintf__fun_1600
define camlPrintf__get_arg_1288
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
		ebx = Mem0[eax + 0x00:word32];
	ecx = Mem0[ecx + 0x0C:word32];
	eax = Mem0[ecx + -4:word32];
	edx = eax;
	edx &= 0xFF;
	SCZO = cond(edx - 0xFE);
	if (Test(NE,Z))
	{
		eax >>= 0x09;
		SCZO = cond(eax - ebx);
		if (Test(UGT,CZ))
		{
			eax = (ecx - 2)[ebx * 0x02];
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
	}
	else
	{
		eax >>= 0x0A;
		SCZO = cond(eax - ebx);
		if (Test(UGT,CZ))
		{
			while (true)
			{
				eax = Mem0[0x08080414<p32>:word32];
				eax -= 0x0C;
				Mem0[0x08080414<p32>:word32] = eax;
				SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
				if (Test(UGE,C))
					break;
				fn080708CC();
			}
			eax += 4;
			Mem0[eax + -4:word32] = 0x08FD;
			--Top;
			ST[Top + 0x00:real64] = (ecx - 4)[ebx * 0x04];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			esp += 0x08;
			SCZO = cond(esp);
			return;
		}
		fn08070B18();
	}
	fn08070B18();
	camlPrintf__scan_conv_1293();
}

// 0805AD20: define camlPrintf__scan_conv_1293
// Called from:
//      camlPrintf__get_arg_1288
//      camlPrintf__scan_flags_1292
define camlPrintf__scan_conv_1293
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	edi = ecx;
	ebp = edx;
	ebp >>= 0x01;
	ecx = Mem0[esi + 0x0C:word32];
	ecx = CONVERT(Mem0[ecx + ebp:byte], byte, word32);
	ecx = ecx + 1 + ecx;
	SCZO = cond(ecx - 0xF9);
	if (Test(GE,SO))
	{
		eax = Mem0[esi + 0x0C:word32];
		ebx = edx;
		esp += 0x1C;
		SCZO = cond(esp);
		camlPrintf__bad_conversion_format_1061();
	}
	else
	{
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 24:word32] = esi;
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 8:word32] = edi;
		Mem0[esp + 20:word32] = ebx;
		Mem0[esp + 16:word32] = eax;
		edi = ecx;
		edi >>= 0x01;
		SCZ = cond(edi);
		O = false;
		0x0807B534[edi * 0x04]();
	}
}

// 0805B4C0: define camlPrintf__scan_flags_1292
// Called from:
//      camlPrintf__got_spec_1304
//      camlPrintf__got_spec_1297
define camlPrintf__scan_flags_1292
{
	esp = fp;
	Top = 0;
	edi = eax;
	ebp = ebx;
	ebx = edx;
	ebx >>= 0x01;
	eax = Mem0[esi + 28:word32];
	eax = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	eax = eax + 1 + eax;
	eax += ~0x3F;
	SCZO = cond(eax - 0x33);
	if (Test(UGT,CZ))
	{
		esi += 0x10;
		SCZO = cond(esi);
		eax = edi;
		ebx = ebp;
		camlPrintf__scan_conv_1293();
	}
	else
	{
		eax >>= 0x01;
		SCZ = cond(eax);
		O = false;
		0x0807B7A8[eax * 0x04]();
	}
}

// 0805B580: define camlPrintf__scan_positional_1291
// Called from:
//      camlPrintf__scan_format_1278
define camlPrintf__scan_positional_1291
{
	esp = fp;
	Top = 0;
	esi = eax;
	edi = ebx;
	ebp = ecx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x1C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 0x18F7;
	Mem0[ebx + 0x00:word32] = 0x0804B370;
	Mem0[ebx + 4:word32] = 0x05;
	Mem0[ebx + 8:word32] = 0x08059720;
	eax = edx;
	eax += 0x10;
	SCZO = cond(eax);
	Mem0[ebx + 0x0C:word32] = eax;
	Mem0[ebx + 16:word32] = esi;
	Mem0[ebx + 20:word32] = edi;
	eax = Mem0[edx + 44:word32];
	ecx = esi;
	edx = ebp;
	camlPrintf__scan_positional_spec_1252();
}

// 0805B5E0: define camlPrintf__pr_1354
// Called from:
//      camlPrintf__cont_m_1365
define camlPrintf__pr_1354
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	Mem0[esp + 0x00:word32] = eax;
	edi = ecx;
	eax = Mem0[edi + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ecx = CONVERT(Mem0[edi + eax:byte], byte, word32);
	eax -= ecx;
	SCZO = cond(eax);
	ebp = eax + 1 + eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x88;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 34039;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x080598F0;
	Mem0[ecx + 0x0C:word32] = 4345;
	Mem0[ecx + 16:word32] = 0x0804B2D0;
	Mem0[ecx + 20:word32] = 0x07;
	Mem0[ecx + 24:word32] = 0x080598C0;
	Mem0[ecx + 28:word32] = 8441;
	Mem0[ecx + 32:word32] = 134525424;
	Mem0[ecx + 36:word32] = 0x09;
	Mem0[ecx + 40:word32] = 0x08059860;
	Mem0[ecx + 44:word32] = 0x30F9;
	Mem0[ecx + 48:word32] = 0x0804B2D0;
	Mem0[ecx + 52:word32] = 0x07;
	Mem0[ecx + 56:word32] = 0x08059800;
	Mem0[ecx + 60:word32] = 16633;
	Mem0[ecx + 64:word32] = 0x0804B370;
	Mem0[ecx + 0x0044:word32] = 0x05;
	Mem0[ecx + 72:word32] = 0x080597D0;
	Mem0[ecx + 76:word32] = 0x50F9;
	Mem0[ecx + 80:word32] = 0x0804B2D0;
	Mem0[ecx + 84:word32] = 0x07;
	Mem0[ecx + 88:word32] = 0x08059740;
	eax = Mem0[esi + 0x0C:word32];
	Mem0[ecx + 92:word32] = eax;
	eax = Mem0[esi + 16:word32];
	Mem0[ecx + 96:word32] = eax;
	eax = Mem0[esi + 20:word32];
	Mem0[ecx + 100:word32] = eax;
	eax = Mem0[esi + 24:word32];
	Mem0[ecx + 0x0068:word32] = eax;
	eax = Mem0[esi + 28:word32];
	Mem0[ecx + 0x006C:word32] = eax;
	Mem0[ecx + 112:word32] = esi;
	eax = Mem0[esp + 0x00:word32];
	Mem0[ecx + 116:word32] = eax;
	Mem0[ecx + 0x0078:word32] = edi;
	Mem0[ecx + 0x007C:word32] = edx;
	Mem0[ecx + 0x80:word32] = ebp;
	edx = 0x01;
	eax = ebx;
	ebx = edx;
	esp += 0x04;
	SCZO = cond(esp);
	camlPrintf__doprn_1360();
}

// 0805B720: define camlPrintf__fun_1680
define camlPrintf__fun_1680
{
	esp = fp;
	Top = 0;
	eax = Mem0[ebx + 8:word32];
}

// 0805B730: define camlPrintf__fun_1684
define camlPrintf__fun_1684
{
	esp = fp;
	Top = 0;
	eax = 0x0807B0E4;
}

// 0805B740: define camlPrintf__fun_1689
define camlPrintf__fun_1689
{
	esp = fp;
	Top = 0;
	eax = 0x01;
}

// 0805B750: define camlPrintf__fun_1697
define camlPrintf__fun_1697
{
	esp = fp;
	Top = 0;
	eax = 0x01;
}

// 0805B760: define camlPrintf__fun_1694
define camlPrintf__fun_1694
{
	esp = fp;
	Top = 0;
	eax = Mem0[ebx + 8:word32];
}

// 0805B770: define camlPrintf__fun_1700
define camlPrintf__fun_1700
{
	esp = fp;
	Top = 0;
	eax = 0x01;
}

// 0805B780: define camlPrintf__fun_1707
define camlPrintf__fun_1707
{
	esp = fp;
	Top = 0;
	eax = 0x01;
}

// 0805B790: define camlPrintf__fun_1710
define camlPrintf__fun_1710
{
	esp = fp;
	Top = 0;
}

// 0805B7A0: define camlPrintf__index_of_int_1037
// Called from:
//      camlPrintf__cont_m_1365
//      camlPrintf__add_int_index_1040
//      camlPrintf__index_of_literal_position_1044
//      camlPrintf__scan_format_1278
//      camlPrintf__mkprintf_1345
define camlPrintf__index_of_int_1037
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(GE,SO))
		return;
	camlPervasives__string_of_int_1130();
	ebx = eax;
	eax = 0x0807B18C;
	camlPervasives__$5e_1112();
	camlPervasives__failwith_1010();
}

// 0805B7D0: define camlPrintf__add_int_index_1040
define camlPrintf__add_int_index_1040
{
	esp = fp;
	Top = 0;
	eax = eax - 1 + ebx;
	camlPrintf__index_of_int_1037();
}

// 0805B7E0: define camlPrintf__index_of_literal_position_1044
define camlPrintf__index_of_literal_position_1044
{
	esp = fp;
	Top = 0;
	eax += ~0x01;
	SCZO = cond(eax);
	camlPrintf__index_of_int_1037();
}

// 0805B7F0: define camlPrintf__sub_1050
define camlPrintf__sub_1050
{
	esp = fp;
	Top = 0;
	camlString__sub_1046();
}

// 0805B800: define camlPrintf__to_string_1054
define camlPrintf__to_string_1054
{
	esp = fp;
	Top = 0;
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= ecx;
	SCZO = cond(ebx);
	ecx = ebx + 1 + ebx;
	ebx = 0x01;
	camlString__sub_1046();
}

// 0805B830: define camlPrintf__bad_conversion_1057
// Called from:
//      camlPrintf__bad_conversion_format_1061
//      camlPrintf__parse_string_conversion_1067
define camlPrintf__bad_conversion_1057
{
	esp = fp;
	Top = 0;
	esp -= 0x0C;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 8:word32] = ecx;
	ebx = 0x0807B184;
	camlPervasives__$5e_1112();
	ebx = eax;
	eax = 0x0807B168;
	camlPervasives__$5e_1112();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	camlPervasives__string_of_int_1130();
	ebx = Mem0[esp + 4:word32];
	camlPervasives__$5e_1112();
	ebx = eax;
	eax = 0x0807B150;
	camlPervasives__$5e_1112();
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x03;
	ebx = Mem0[esp + 8:word32];
	camlString__make_1038();
	ebx = Mem0[esp + 0x00:word32];
	camlPervasives__$5e_1112();
	ebx = eax;
	eax = 0x0807B130;
	camlPervasives__$5e_1112();
	esp += 0x0C;
	SCZO = cond(esp);
	camlPervasives__invalid_arg_1012();
}

// 0805B8A0: define camlPrintf__bad_conversion_format_1061
// Called from:
//      camlPrintf__scan_conv_1143
//      camlPrintf__scan_conv_1293
define camlPrintf__bad_conversion_format_1061
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = ecx;
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= ecx;
	SCZO = cond(ebx);
	ecx = ebx + 1 + ebx;
	ebx = 0x01;
	camlString__sub_1046();
	ebx = Mem0[esp + 0x00:word32];
	ecx = Mem0[esp + 4:word32];
	esp += 0x08;
	SCZO = cond(esp);
	camlPrintf__bad_conversion_1057();
}

// 0805B8E0: define camlPrintf__incomplete_format_1065
// Called from:
//      camlPrintf__scan_conv_1143
//      camlPrintf__scan_flags_1142
define camlPrintf__incomplete_format_1065
{
	esp = fp;
	Top = 0;
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= ecx;
	SCZO = cond(ebx);
	ecx = ebx + 1 + ebx;
	ebx = 0x01;
	camlString__sub_1046();
	ebx = 0x0807B128;
	camlPervasives__$5e_1112();
	ebx = eax;
	eax = 0x0807B0F8;
	camlPervasives__$5e_1112();
	camlPervasives__invalid_arg_1012();
}

// 0805B920: define camlPrintf__parse_string_conversion_1067
// Called from:
//      camlPrintf__format_string_1080
define camlPrintf__parse_string_conversion_1067
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	ebx = eax;
	Mem0[esp + 0x00:word32] = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x080599C0;
	Mem0[ecx + 0x0C:word32] = ebx;
	fn0805B9A0();
	ecx = 0x080739CC;
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ecx);
	if (Test(NE,Z))
	{
		fn08070A44();
		esi = esi;
		edi += 0x00;
		fn0805B9A0();
	}
	else
	{
		ecx = 0xE7;
		ebx = 0x01;
		eax = Mem0[esp + 0x00:word32];
		esp += 0x04;
		SCZO = cond(esp);
		camlPrintf__bad_conversion_1057();
	}
}

// 0805B9A0: define fn0805B9A0
// Called from:
//      camlPrintf__parse_string_conversion_1067
define fn0805B9A0
{
	esp = fp;
	Top = 0;
	v4 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v4;
	Mem0[0x0807D280<p32>:word32] = esp;
	ebx = 0x03;
	eax = 0x01;
	camlPrintf__parse_1069();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0805B9E0: define camlPrintf__pad_string_1072
// Called from:
//      camlPrintf__format_string_1080
define camlPrintf__pad_string_1072
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	ebp = eax;
	SCZO = cond(ebx - edi);
	if (Test(EQ,Z))
	{
		SCZO = cond(esi - 0x01);
		if (Test(EQ,Z))
		{
			eax = edx;
			esp += 0x18;
			SCZO = cond(esp);
			return;
		}
	}
	SCZO = cond(ebx - edi);
	if (Test(GT,SZO))
	{
		Mem0[esp + 20:word32] = edi;
		Mem0[esp + 16:word32] = esi;
		Mem0[esp + 0x0C:word32] = edx;
		Mem0[esp + 0x00:word32] = ecx;
		Mem0[esp + 8:word32] = ebx;
		eax = ebx;
		ebx = ebp;
		camlString__make_1038();
		ecx = eax;
		Mem0[esp + 4:word32] = ecx;
		eax = Mem0[esp + 0x00:word32];
		SCZO = cond(eax - 0x01);
		if (Test(NE,Z))
		{
			edx = 0x01;
			eax = Mem0[esp + 0x0C:word32];
			ebx = Mem0[esp + 16:word32];
			esi = Mem0[esp + 20:word32];
			camlString__blit_1056();
		}
		else
		{
			edx = Mem0[esp + 8:word32];
			esi = Mem0[esp + 20:word32];
			edx -= esi;
			SCZO = cond(edx);
			++edx;
			SZO = cond(edx);
			eax = Mem0[esp + 0x0C:word32];
			ebx = Mem0[esp + 16:word32];
			camlString__blit_1056();
		}
		eax = Mem0[esp + 4:word32];
		esp += 0x18;
		SCZO = cond(esp);
	}
	else
	{
		eax = edx;
		ebx = esi;
		ecx = edi;
		esp += 0x18;
		SCZO = cond(esp);
		camlString__sub_1046();
	}
}

// 0805BA90: define camlPrintf__format_string_1080
define camlPrintf__format_string_1080
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = ebx;
	camlPrintf__parse_string_conversion_1067();
	ecx = Mem0[eax + 4:word32];
	ebx = Mem0[eax + 0x00:word32];
	edx = Mem0[esp + 0x00:word32];
	eax = Mem0[edx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	esi = CONVERT(Mem0[edx + eax:byte], byte, word32);
	eax -= esi;
	edi = eax + 1 + eax;
	esi = 0x01;
	eax = 0x41;
	esp += 0x04;
	SCZO = cond(esp);
	camlPrintf__pad_string_1072();
}

// 0805BAD0: define camlPrintf__extract_format_1085
// Called from:
//      camlPrintf__extract_format_int_1103
//      camlPrintf__extract_format_float_1110
define camlPrintf__extract_format_1085
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	esi = eax;
	Mem0[esp + 0x00:word32] = esi;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 0x0C:word32] = edx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[esp + 8:word32] = ecx;
	Mem0[ecx + -4:word32] = 3319;
	Mem0[ecx + 0x00:word32] = 0x08059AF0;
	Mem0[ecx + 4:word32] = 0x03;
	Mem0[ecx + 8:word32] = esi;
	eax = ebx;
	eax += 0x02;
	SCZO = cond(eax);
	ebx = ecx;
	camlPrintf__skip_positional_spec_1090();
	ebx = eax;
	Mem0[esp + 16:word32] = ebx;
	eax = Mem0[esp + 4:word32];
	eax -= ebx;
	eax += 0x15;
	SCZO = cond(eax);
	camlBuffer__create_1039();
	esp += 0x04;
	Mem0[esp + 24:word32] = eax;
	ebx = 0x4B;
	camlBuffer__add_char_1072();
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x20;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[esp + 20:word32] = ebx;
	Mem0[ebx + -4:word32] = 0x1CF7;
	Mem0[ebx + 0x00:word32] = 0x0804B370;
	Mem0[ebx + 4:word32] = 0x05;
	Mem0[ebx + 8:word32] = 134585184;
	eax = Mem0[esp + 0x00:word32];
	Mem0[ebx + 0x0C:word32] = eax;
	eax = Mem0[esp + 4:word32];
	Mem0[ebx + 16:word32] = eax;
	eax = Mem0[esp + 8:word32];
	Mem0[ebx + 20:word32] = eax;
	eax = Mem0[esp + 24:word32];
	Mem0[ebx + 24:word32] = eax;
	ebx = 0x01;
	eax = Mem0[esp + 0x0C:word32];
	camlList__rev_append_1051();
	ebx = eax;
	eax = Mem0[esp + 16:word32];
	ecx = Mem0[esp + 20:word32];
	camlPrintf__fill_format_1096();
	eax = Mem0[esp + 24:word32];
	ecx = Mem0[eax + 4:word32];
	ebx = 0x01;
	eax = Mem0[eax + 0x00:word32];
	esp += 0x1C;
	SCZO = cond(esp);
	camlString__sub_1046();
}

// 0805BBE0: define camlPrintf__extract_format_int_1103
define camlPrintf__extract_format_int_1103
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = ebx;
	ebx = ecx;
	ecx = edx;
	edx = esi;
	camlPrintf__extract_format_1085();
	ebx = Mem0[esp + 0x00:word32];
	SCZO = cond(ebx - 0x9D);
	if (Test(NE,Z))
	{
		SCZO = cond(ebx - 0xDD);
		if (Test(NE,Z))
		{
			esp += 0x04;
			SCZO = cond(esp);
			return;
		}
	}
	ebx = Mem0[eax + -4:word32];
	ebx >>= 0x0A;
	ebx = ~0x00 + ebx * 0x04;
	ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
	ebx -= ecx;
	ebx = ebx - 1 + ebx;
	ebx >>= 0x01;
	ecx = Mem0[eax + -4:word32];
	ecx >>= 0x0A;
	ecx = ~0x00 + ecx * 0x04;
	edx = CONVERT(Mem0[eax + ecx:byte], byte, word32);
	ecx -= edx;
	SCZO = cond(ecx - ebx);
	if (Test(ULE,CZ))
	{
		fn08070B18();
		camlPrintf__extract_format_float_1110();
	}
	else
	{
		edx = 117;
		Mem0[eax + ebx:byte] = dl;
		esp += 0x04;
		SCZO = cond(esp);
	}
}

// 0805BC60: define camlPrintf__extract_format_float_1110
// Called from:
//      camlPrintf__extract_format_int_1103
define camlPrintf__extract_format_float_1110
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = ebx;
	ebx = ecx;
	ecx = edx;
	edx = esi;
	camlPrintf__extract_format_1085();
	ebx = Mem0[esp + 0x00:word32];
	SCZO = cond(ebx - 141);
	if (Test(EQ,Z))
	{
		ebx = Mem0[eax + -4:word32];
		ebx >>= 0x0A;
		ebx = ~0x00 + ebx * 0x04;
		ecx = CONVERT(Mem0[eax + ebx:byte], byte, word32);
		ebx -= ecx;
		ebx = ebx - 1 + ebx;
		ebx >>= 0x01;
		ecx = Mem0[eax + -4:word32];
		ecx >>= 0x0A;
		ecx = ~0x00 + ecx * 0x04;
		edx = CONVERT(Mem0[eax + ecx:byte], byte, word32);
		ecx -= edx;
		SCZO = cond(ecx - ebx);
		if (Test(ULE,CZ))
		{
			fn08070B18();
			camlPrintf__sub_format_1117();
		}
		else
		{
			edx = 0x67;
			Mem0[eax + ebx:byte] = dl;
			esp += 0x04;
			SCZO = cond(esp);
		}
	}
	else
	{
		esp += 0x04;
		SCZO = cond(esp);
	}
}

// 0805BCE0: define camlPrintf__sub_format_1117
// Called from:
//      camlPrintf__extract_format_float_1110
define camlPrintf__sub_format_1117
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	Mem0[esp + 0x00:word32] = eax;
	ebp = ecx;
	eax = Mem0[edx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ecx = CONVERT(Mem0[edx + eax:byte], byte, word32);
	eax -= ecx;
	SCZO = cond(eax);
	edi = eax + 1 + eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x20;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 0x1CF7;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x08059C50;
	eax = Mem0[esp + 0x00:word32];
	Mem0[ecx + 0x0C:word32] = eax;
	Mem0[ecx + 16:word32] = ebx;
	Mem0[ecx + 20:word32] = edx;
	Mem0[ecx + 24:word32] = edi;
	eax = ebp;
	ebx = esi;
	esp += 0x04;
	SCZO = cond(esp);
	camlPrintf__sub_fmt_1124();
}

// 0805BD60: define camlPrintf__sub_format_for_printf_1135
define camlPrintf__sub_format_for_printf_1135
{
	esp = fp;
	Top = 0;
	ecx = eax;
	edx = Mem0[0x0807AE34<p32>:word32];
	ebx = Mem0[0x0807AE14<p32>:word32];
	eax = Mem0[0x0807AE18<p32>:word32];
	caml_apply3();
}

// 0805BD80: define camlPrintf__iter_on_format_args_1137
// Called from:
//      camlPrintf__summarize_format_type_1162
//      camlPrintf__ac_of_format_1184
define camlPrintf__iter_on_format_args_1137
{
	esp = fp;
	Top = 0;
	edx = eax;
	eax = Mem0[edx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	esi = CONVERT(Mem0[edx + eax:byte], byte, word32);
	eax -= esi;
	SCZO = cond(eax);
	esi = eax - 1 + eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x3C;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 0x38F7;
	Mem0[eax + 0x00:word32] = 0x0804B370;
	Mem0[eax + 4:word32] = 0x05;
	Mem0[eax + 8:word32] = 0x08059FA0;
	Mem0[eax + 0x0C:word32] = 4345;
	Mem0[eax + 16:word32] = 0x0804B370;
	Mem0[eax + 20:word32] = 0x05;
	Mem0[eax + 24:word32] = 0x08059D60;
	Mem0[eax + 28:word32] = 8441;
	Mem0[eax + 32:word32] = 0x08059CE0;
	Mem0[eax + 36:word32] = 0x03;
	Mem0[eax + 40:word32] = edx;
	Mem0[eax + 44:word32] = ebx;
	Mem0[eax + 48:word32] = ecx;
	Mem0[eax + 52:word32] = esi;
	ebx = eax;
	ebx += 0x20;
	SCZO = cond(ebx);
	eax = 0x01;
	camlPrintf__scan_fmt_1144();
	eax = 0x01;
}

// 0805BE30: define camlPrintf__summarize_format_type_1162
define camlPrintf__summarize_format_type_1162
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	ecx = eax;
	Mem0[esp + 0x00:word32] = ecx;
	ebx = Mem0[ecx + -4:word32];
	ebx >>= 0x0A;
	eax = ~0x00 + ebx * 0x04;
	ebx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ebx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	camlBuffer__create_1039();
	esp += 0x04;
	edx = eax;
	Mem0[esp + 4:word32] = edx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 44;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x0805A060;
	Mem0[ecx + 0x0C:word32] = edx;
	ebx = ecx + 20;
	Mem0[ebx + -4:word32] = 0x14F7;
	Mem0[ebx + 0x00:word32] = 0x0804B2D0;
	Mem0[ebx + 4:word32] = 0x07;
	Mem0[ebx + 8:word32] = 0x0805A080;
	Mem0[ebx + 0x0C:word32] = edx;
	Mem0[ebx + 16:word32] = ecx;
	eax = Mem0[esp + 0x00:word32];
	camlPrintf__iter_on_format_args_1137();
	eax = Mem0[esp + 4:word32];
	ecx = Mem0[eax + 4:word32];
	ebx = 0x01;
	eax = Mem0[eax + 0x00:word32];
	esp += 0x08;
	SCZO = cond(esp);
	camlString__sub_1046();
}

// 0805BEE0: define camlPrintf__ac_of_format_1184
// Called from:
//      camlPrintf__cont_m_1365
//      camlPrintf__count_arguments_of_format_1198
//      camlPrintf__mkprintf_1345
define camlPrintf__ac_of_format_1184
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x38;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[ebx + -4:word32] = 0x0C00;
	Mem0[ebx + 0x00:word32] = 0x01;
	Mem0[ebx + 4:word32] = 0x01;
	Mem0[ebx + 8:word32] = 0x01;
	eax = ebx + 16;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B370;
	Mem0[eax + 4:word32] = 0x05;
	Mem0[eax + 8:word32] = 0x0805A0E0;
	Mem0[eax + 0x0C:word32] = ebx;
	ebx += 0x24;
	SCZO = cond(ebx);
	Mem0[ebx + -4:word32] = 4343;
	Mem0[ebx + 0x00:word32] = 0x0804B2D0;
	Mem0[ebx + 4:word32] = 0x07;
	Mem0[ebx + 8:word32] = 0x0805A140;
	Mem0[ebx + 0x0C:word32] = eax;
	ecx = 0x0807B0D4;
	eax = edx;
	camlPrintf__iter_on_format_args_1137();
	eax = Mem0[esp + 0x00:word32];
	esp += 0x04;
	SCZO = cond(esp);
}

// 0805BF80: define camlPrintf__count_arguments_of_format_1198
define camlPrintf__count_arguments_of_format_1198
{
	esp = fp;
	Top = 0;
	camlPrintf__ac_of_format_1184();
	eax = Mem0[eax + 0x00:word32];
}

// 0805BF90: define camlPrintf__list_iter_i_1201
// Called from:
//      camlPrintf__mkprintf_1345
define camlPrintf__list_iter_i_1201
{
	esp = fp;
	Top = 0;
	edx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ecx = eax + 4;
	Mem0[ecx + -4:word32] = 4343;
	Mem0[ecx + 0x00:word32] = 0x0804B370;
	Mem0[ecx + 4:word32] = 0x05;
	Mem0[ecx + 8:word32] = 0x0805A180;
	Mem0[ecx + 0x0C:word32] = edx;
	eax = 0x01;
	camlPrintf__loop_1204();
}

// 0805BFE0: define camlPrintf__kapr_1209
// Called from:
//      camlPrintf__mkprintf_1345
define camlPrintf__kapr_1209
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = ebx;
	Mem0[esp + 4:word32] = eax;
	camlPrintf__ac_of_format_1184();
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - 0x0D);
	if (Test(ULE,CZ))
	{
		ebx >>= 0x01;
		SCZ = cond(ebx);
		O = false;
		0x0807B810[ebx * 0x04]();
	}
	else
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x1C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ecx = eax + 4;
		Mem0[ecx + -4:word32] = 0x18F7;
		Mem0[ecx + 0x00:word32] = 0x0804B370;
		Mem0[ecx + 4:word32] = 0x05;
		Mem0[ecx + 8:word32] = 0x0805A1E0;
		eax = Mem0[esp + 0x00:word32];
		Mem0[ecx + 0x0C:word32] = eax;
		eax = Mem0[esp + 4:word32];
		Mem0[ecx + 16:word32] = eax;
		Mem0[ecx + 20:word32] = ebx;
		ebx = 0x01;
		eax = 0x01;
		esp += 0x08;
		SCZO = cond(esp);
		camlPrintf__loop_1240();
	}
}

// 0805C2B0: define camlPrintf__scan_positional_spec_1252
// Called from:
//      camlPrintf__scan_format_1278
define camlPrintf__scan_positional_spec_1252
{
	esp = fp;
	Top = 0;
	esi = eax;
	edi = ebx;
	ebx = edx;
	eax = ebx;
	eax >>= 0x01;
	eax = CONVERT(Mem0[esi + eax:byte], byte, word32);
	edx = eax + 1 + eax;
	eax = edx;
	eax += ~0x5F;
	SCZO = cond(eax - 0x13);
	if (Test(ULE,CZ))
	{
		while (true)
		{
			eax = Mem0[0x08080414<p32>:word32];
			eax -= 0x1C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(UGE,C))
				break;
			fn080708CC();
		}
		ecx = eax + 4;
		Mem0[ecx + -4:word32] = 0x18F7;
		Mem0[ecx + 0x00:word32] = 0x0804B370;
		Mem0[ecx + 4:word32] = 0x05;
		Mem0[ecx + 8:word32] = 0x0805AB60;
		Mem0[ecx + 0x0C:word32] = esi;
		Mem0[ecx + 16:word32] = edi;
		Mem0[ecx + 20:word32] = ebx;
		ebx += 0x02;
		eax = edx;
		eax += ~0x5F;
		SCZO = cond(eax);
		camlPrintf__get_int_literal_1258();
	}
	else
	{
		eax = 0x01;
		ecx = edi;
		caml_apply2();
	}
}

// 0805C330: define camlPrintf__next_index_1262
define camlPrintf__next_index_1262
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
	{
		ecx = Mem0[0x0807AE0C<p32>:word32];
		edx = Mem0[ecx + 8:word32];
		ecx = Mem0[edx + 0x00:word32];
		eax = ebx;
		ebx = edx;
		ecx();
	}
	else
		eax = ebx;
}

// 0805C360: define camlPrintf__get_index_1265
define camlPrintf__get_index_1265
{
	esp = fp;
	Top = 0;
	SCZO = cond(eax - 0x01);
	if (Test(EQ,Z))
		eax = ebx;
	else
		eax = Mem0[eax + 0x00:word32];
}

// 0805C380: define camlPrintf__make_valid_float_lexeme_1270
// Called from:
//      camlPrintf__fun_1600
define camlPrintf__make_valid_float_lexeme_1270
{
	esp = fp;
	Top = 0;
	ecx = eax;
	eax = Mem0[ecx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	ebx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ebx;
	SCZO = cond(eax);
	edx = eax + 1 + eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x14;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 4343;
	Mem0[ebx + 0x00:word32] = 0x0805AC20;
	Mem0[ebx + 4:word32] = 0x03;
	Mem0[ebx + 8:word32] = ecx;
	Mem0[ebx + 0x0C:word32] = edx;
	eax = 0x01;
	camlPrintf__valid_float_loop_1273();
}

// 0805C3E0: define camlPrintf__fun_1600
define camlPrintf__fun_1600
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0806778A;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[esp + 0x00:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 134641468;
	fn080709D8();
	esp += 0x04;
	SCZO = cond(eax - 0x07);
	if (Test(LT,SO))
	{
		eax = Mem0[esp + 4:word32];
		esp += 0x08;
		SCZO = cond(esp);
		camlPrintf__make_valid_float_lexeme_1270();
	}
	else
	{
		eax = Mem0[esp + 4:word32];
		esp += 0x08;
		SCZO = cond(esp);
	}
}

// 0805C430: define camlPrintf__scan_format_1278
// Called from:
//      camlPrintf__doprn_1360
define camlPrintf__scan_format_1278
{
	esp = fp;
	Top = 0;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 0x0C:word32] = ecx;
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 20:word32] = edi;
	eax = Mem0[0x0807D0BC<p32>:word32];
	Mem0[esp + 16:word32] = eax;
	edi = Mem0[0x0807D0C0<p32>:word32];
	ebp = Mem0[0x0807D0C4<p32>:word32];
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 100;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	eax += 4;
	Mem0[eax + -4:word32] = 4343;
	Mem0[eax + 0x00:word32] = 0x0804B370;
	Mem0[eax + 4:word32] = 0x05;
	Mem0[eax + 8:word32] = 0x0805ACA0;
	ebx = Mem0[esp + 0x00:word32];
	Mem0[eax + 0x0C:word32] = ebx;
	edx = eax + 20;
	Mem0[edx + -4:word32] = 0x4CF7;
	Mem0[edx + 0x00:word32] = 0x0804B2D0;
	Mem0[edx + 4:word32] = 0x07;
	Mem0[edx + 8:word32] = 0x0805B580;
	Mem0[edx + 0x0C:word32] = 4345;
	Mem0[edx + 16:word32] = 134525424;
	Mem0[edx + 20:word32] = 0x09;
	Mem0[edx + 24:word32] = 0x0805B4C0;
	Mem0[edx + 28:word32] = 8441;
	Mem0[edx + 32:word32] = 134525424;
	Mem0[edx + 36:word32] = 0x09;
	Mem0[edx + 40:word32] = 0x0805AD20;
	ebx = Mem0[esp + 4:word32];
	Mem0[edx + 44:word32] = ebx;
	ecx = Mem0[esp + 8:word32];
	Mem0[edx + 48:word32] = ecx;
	Mem0[edx + 52:word32] = esi;
	ebx = Mem0[esp + 20:word32];
	Mem0[edx + 56:word32] = ebx;
	ebx = Mem0[esp + 16:word32];
	Mem0[edx + 60:word32] = ebx;
	Mem0[edx + 64:word32] = edi;
	Mem0[edx + 0x0044:word32] = ebp;
	Mem0[edx + 72:word32] = eax;
	ecx += 0x02;
	ebx = 0x01;
	eax = Mem0[esp + 0x0C:word32];
	esp += 0x18;
	SCZO = cond(esp);
	camlPrintf__scan_positional_1291();
}

// 0805C540: define camlPrintf__mkprintf_1345
define camlPrintf__mkprintf_1345
{
	esp = fp;
	Top = 0;
	esp -= 0x1C;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x0C:word32] = esi;
	Mem0[esp + 16:word32] = edi;
	eax = Mem0[0x0807D0BC<p32>:word32];
	Mem0[esp + 24:word32] = eax;
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
	ecx = eax;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x24;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[esp + 20:word32] = ebx;
	Mem0[ebx + -4:word32] = 0x20F7;
	Mem0[ebx + 0x00:word32] = 134525424;
	Mem0[ebx + 4:word32] = 0x09;
	Mem0[ebx + 8:word32] = 0x0805B5E0;
	eax = Mem0[esp + 0x00:word32];
	Mem0[ebx + 0x0C:word32] = eax;
	eax = Mem0[esp + 4:word32];
	Mem0[ebx + 16:word32] = eax;
	eax = Mem0[esp + 8:word32];
	Mem0[ebx + 20:word32] = eax;
	eax = Mem0[esp + 0x0C:word32];
	Mem0[ebx + 24:word32] = eax;
	Mem0[ebx + 28:word32] = ecx;
	eax = 0x01;
	camlPrintf__index_of_int_1037();
	ebx = eax;
	eax = Mem0[esp + 16:word32];
	ecx = Mem0[esp + 20:word32];
	caml_apply2();
	ebx = Mem0[esp + 24:word32];
	esp += 0x1C;
	SCZO = cond(esp);
	camlPrintf__kapr_1209();
}

// 0805C5F0: define camlPrintf__kfprintf_1386
// Called from:
//      camlPrintf__fprintf_1391
define camlPrintf__kfprintf_1386
{
	word32 eax;
	word32 ebx;
	<unknown> Mem0;
	word32 dwLoc04;
	bool P;
	Top_3 = 0;
	edi_5 = eax;
	while (true)
	{
		P_46 = ϕ(P, P_20);
		Mem8 = ϕ(Mem0, Mem11);
		eax_9 = Mem8[0x08080414<p32>:word32];
		Mem11[0x08080414<p32>:word32] = eax_9 - 0x10;
		if (eax_9 - 0x10 >=u Mem11[0x08080418<p32>:word32])
			break;
		fn080708CC();
	}
	Mem22[eax_9 + -16:word32] = 3319;
	Mem23[eax_9 + -0x0C:word32] = 0x0805B720;
	Mem24[eax_9 + -8:word32] = 0x03;
	Mem26[eax_9 + -4:word32] = ebx;
	ebp_27 = Mem26[0x0807AE6C<p32>:word32];
	esi_28 = Mem26[0x08076EA0<p32>:word32];
	edx_29 = Mem26[0x08076EAC<p32>:word32];
	ecx_30 = Mem26[0x08076EA8<p32>:word32];
	Mem32[0x0807D0BC<p32>:word32] = ebp_27;
	caml_apply6();
}

// 0805C660: define camlPrintf__ifprintf_1389
define camlPrintf__ifprintf_1389
{
	esp = fp;
	Top = 0;
	ebx = Mem0[0x0807AE54<p32>:word32];
	eax = 0x0807B0C8;
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
}

// 0805C670: define camlPrintf__fprintf_1391
// Called from:
//      camlPrintf__printf_1393
//      camlPrintf__eprintf_1395
define camlPrintf__fprintf_1391
{
	word32 eax;
	Top_3 = 0;
	camlPrintf__kfprintf_1386();
}

// 0805C680: define camlPrintf__printf_1393
// Called from:
//      camlSource__entry
define camlPrintf__printf_1393
{
	word32 eax;
	Top_3 = 0;
	eax_8 = Mem7[0x08076E50<p32>:word32];
	camlPrintf__fprintf_1391();
	ebx_20 = eax_9;
	ecx_21 = Mem7[eax_9 + 0x00:word32];
	ecx_21();
	C_30 = SLICE(SCZO_28, bool, 1);
	O_31 = SLICE(SCZO_28, bool, 4);
	S_32 = SLICE(SCZO_28, bool, 0);
	Z_33 = SLICE(SCZO_28, bool, 2);
}

// 0805C6A0: define camlPrintf__eprintf_1395
define camlPrintf__eprintf_1395
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = Mem0[0x08076E54<p32>:word32];
	camlPrintf__fprintf_1391();
	ebx = eax;
	ecx = Mem0[ebx + 0x00:word32];
	eax = Mem0[esp + 0x00:word32];
	esp += 0x04;
	SCZO = cond(esp);
	ecx();
}

// 0805C6C0: define camlPrintf__kbprintf_1397
// Called from:
//      camlPrintf__bprintf_1400
define camlPrintf__kbprintf_1397
{
	esp = fp;
	Top = 0;
	edi = eax;
	ecx = ebx;
	while (true)
	{
		eax = Mem0[0x08080414<p32>:word32];
		eax -= 0x10;
		Mem0[0x08080414<p32>:word32] = eax;
		SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
		if (Test(UGE,C))
			break;
		fn080708CC();
	}
	ebx = eax + 4;
	Mem0[ebx + -4:word32] = 3319;
	Mem0[ebx + 0x00:word32] = 0x0805B760;
	Mem0[ebx + 4:word32] = 0x03;
	Mem0[ebx + 8:word32] = ecx;
	ebp = Mem0[0x0807AE6C<p32>:word32];
	esi = 0x0807B0B0;
	edx = Mem0[0x0807A780<p32>:word32];
	ecx = Mem0[0x0807A77C<p32>:word32];
	eax = 0x01;
	Mem0[0x0807D0BC<p32>:word32] = ebp;
	caml_apply6();
}

// 0805C730: define camlPrintf__bprintf_1400
define camlPrintf__bprintf_1400
{
	esp = fp;
	Top = 0;
	ebx = eax;
	eax = 0x0807B0A4;
	camlPrintf__kbprintf_1397();
}

// 0805C740: define camlPrintf__get_buff_1402
define camlPrintf__get_buff_1402
{
	esp = fp;
	Top = 0;
	ecx = eax;
	ebx = Mem0[ecx + -4:word32];
	ebx >>= 0x0A;
	eax = ~0x00 + ebx * 0x04;
	ebx = CONVERT(Mem0[ecx + eax:byte], byte, word32);
	eax -= ebx;
	SCZO = cond(eax);
	eax = 0x01 + eax * 0x04;
	camlBuffer__create_1039();
}

// 0805C770: define camlPrintf__get_contents_1405
define camlPrintf__get_contents_1405
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	ecx = Mem0[eax + 4:word32];
	ebx = 0x01;
	eax = Mem0[eax + 0x00:word32];
	camlString__sub_1046();
	ebx = Mem0[esp + 0x00:word32];
	Mem0[ebx + 4:word32] = 0x01;
	esp += 0x04;
	SCZO = cond(esp);
}

// 0805C7A0: define camlPrintf__get_cont_1408
define camlPrintf__get_cont_1408
{
	esp = fp;
	Top = 0;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = eax;
	eax = ebx;
	Mem0[esp + 0x00:word32] = eax;
	ecx = Mem0[eax + 4:word32];
	ebx = 0x01;
	eax = Mem0[eax + 0x00:word32];
	camlString__sub_1046();
	ebx = Mem0[esp + 0x00:word32];
	Mem0[ebx + 4:word32] = 0x01;
	ebx = Mem0[esp + 4:word32];
	ecx = Mem0[ebx + 0x00:word32];
	esp += 0x08;
	SCZO = cond(esp);
	ecx();
}

// 0805C7D0: define camlPrintf__ksprintf_1411
// Called from:
//      camlPrintf__sprintf_1413
define camlPrintf__ksprintf_1411
{
	esp = fp;
	Top = 0;
	ebx = Mem0[0x0807AE78<p32>:word32];
	ecx = Mem0[ebx + 0x00:word32];
	ecx();
	edi = eax;
	ebp = Mem0[0x0807AE6C<p32>:word32];
	esi = 0x0807B098;
	edx = Mem0[0x0807A780<p32>:word32];
	ecx = Mem0[0x0807A77C<p32>:word32];
	ebx = Mem0[0x0807AE70<p32>:word32];
	eax = 0x03;
	Mem0[0x0807D0BC<p32>:word32] = ebp;
	caml_apply6();
}

// 0805C810: define camlPrintf__sprintf_1413
define camlPrintf__sprintf_1413
{
	esp = fp;
	Top = 0;
	esp -= 0x04;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0807B08C;
	camlPrintf__ksprintf_1411();
	ebx = eax;
	ecx = Mem0[ebx + 0x00:word32];
	eax = Mem0[esp + 0x00:word32];
	esp += 0x04;
	SCZO = cond(esp);
	ecx();
}

// 0805C830: define camlPrintf__entry
// Called from:
//      caml_program
define camlPrintf__entry
{
	ptr32 fp;
	word32 dwLoc0C;
	Top_3 = 0;
	fn08070994();
	Mem16[eax_9 + 0x00:word32] = 4343;
	Mem17[eax_9 + 4:word32] = 0x0804B370;
	Mem18[eax_9 + 8:word32] = 0x05;
	Mem19[eax_9 + 0x0C:word32] = 0x0805B7D0;
	Mem20[eax_9 + 16:word32] = 0x0807B080;
	ecx_22 = Mem20[eax_9 + 4:word32];
	ecx_22();
	fn08070994();
	Mem35[eax_29 + 0x00:word32] = 3319;
	Mem36[eax_29 + 4:word32] = 0x0805B7E0;
	Mem37[eax_29 + 8:word32] = 0x03;
	Mem39[eax_29 + 0x0C:word32] = 0x0807B080;
	Mem42[eax_29 + 16:word32] = 3319;
	Mem43[eax_29 + 20:word32] = 0x0805B800;
	Mem44[eax_29 + 24:word32] = 0x03;
	Mem45[eax_29 + 28:word32] = 0x0807B070;
	Mem47[eax_29 + 32:word32] = 0x1800;
	Mem48[eax_29 + 36:word32] = 0x0807B080;
	Mem50[eax_29 + 40:word32] = eax_9 + 4;
	Mem51[eax_29 + 44:word32] = eax_24;
	Mem52[eax_29 + 48:word32] = eax_29 + 4;
	Mem53[eax_29 + 52:word32] = 0x0807B070;
	Mem54[eax_29 + 56:word32] = eax_29 + 20;
	Mem55[0x0807AE0C<p32>:word32] = eax_29 + 36;
	Mem57[0x0807AE10<p32>:word32] = 0x0807B060;
	Mem59[0x0807AE14<p32>:word32] = 0x0807B050;
	Mem61[0x0807AE18<p32>:word32] = 0x0807B044;
	Mem63[0x0807AE1C<p32>:word32] = 0x0807B038;
	Mem65[0x0807AE20<p32>:word32] = 0x0807B028;
	Mem67[0x0807AE24<p32>:word32] = 0x0807B018;
	Mem69[0x0807AE28<p32>:word32] = 0x0807B008;
	Mem71[0x0807AE2C<p32>:word32] = 0x0807AFF8;
	Mem73[0x0807AE30<p32>:word32] = 0x0807AFE8;
	Mem75[0x0807AE34<p32>:word32] = 0x0807AFD8;
	Mem77[0x0807AE38<p32>:word32] = 0x0807AFCC;
	Mem79[0x0807AE3C<p32>:word32] = 0x0807AFBC;
	Mem81[0x0807AE40<p32>:word32] = 0x0807AFB0;
	Mem83[0x0807AE44<p32>:word32] = 0x0807B0F0;
	Mem85[0x0807AE48<p32>:word32] = 134721444;
	Mem87[0x0807AE4C<p32>:word32] = 134721432;
	Mem89[0x0807AE50<p32>:word32] = 0x0807AF88;
	Mem91[0x0807AE54<p32>:word32] = 0x0807AF78;
	Mem93[0x0807AE58<p32>:word32] = 0x0807AF68;
	Mem95[0x0807AE5C<p32>:word32] = 0x0807AF58;
	Mem97[0x0807AE60<p32>:word32] = 0x0807AF48;
	Mem100[eax_29 + 60:word32] = 4343;
	Mem101[eax_29 + 64:word32] = 0x0804B370;
	Mem102[eax_29 + 0x0044:word32] = 0x05;
	Mem103[eax_29 + 72:word32] = 134595552;
	Mem104[eax_29 + 76:word32] = 134721340;
	Mem105[0x0807AE64<p32>:word32] = eax_29 + 64;
	Mem107[0x0807AE68<p32>:word32] = 134721324;
	Mem109[0x0807AE6C<p32>:word32] = 0x0807AF1C;
	Mem111[0x0807ADF8<p32>:word32] = 0x0807AF0C;
	Mem113[0x0807ADEC<p32>:word32] = 0x0807AF00;
	Mem115[0x0807ADE0<p32>:word32] = 0x0807AEF4;
	Mem117[0x0807ADE4<p32>:word32] = 0x0807AEE8;
	Mem119[0x0807ADE8<p32>:word32] = 134721244;
	Mem121[0x0807AE00<p32>:word32] = 0x0807AECC;
	Mem123[0x0807ADF4<p32>:word32] = 0x0807AEC0;
	Mem125[0x0807AE70<p32>:word32] = 134721204;
	Mem127[0x0807AE74<p32>:word32] = 0x0807AEA8;
	Mem129[0x0807AE78<p32>:word32] = 0x0807AE98;
	Mem131[0x0807ADFC<p32>:word32] = 0x0807AE8C;
	Mem133[0x0807ADF0<p32>:word32] = 0x0807AE80;
	eax_134 = Mem133[0x0807ADFC<p32>:word32];
	Mem135[0x0807AE04<p32>:word32] = eax_134;
	eax_136 = Mem135[0x0807AE0C<p32>:word32];
	ebp_138 = Mem137[0x0807AE48<p32>:word32];
	edi_139 = Mem137[0x0807AE34<p32>:word32];
	esi_140 = Mem137[0x0807AE40<p32>:word32];
	edx_141 = Mem137[0x0807AE68<p32>:word32];
	ebx_142 = Mem137[0x0807AE54<p32>:word32];
	Mem144[eax_29 + 80:word32] = 0x1400;
	Mem145[eax_29 + 84:word32] = ebp_138;
	Mem146[eax_29 + 88:word32] = edi_139;
	Mem147[eax_29 + 92:word32] = esi_140;
	Mem148[eax_29 + 96:word32] = edx_141;
	Mem149[eax_29 + 100:word32] = ebx_142;
	ebx_150 = eax_29 + 0x006C;
	Mem151[eax_29 + 0x0068:word32] = 0x0800;
	Mem153[eax_29 + 0x006C:word32] = eax_136;
	Mem154[eax_29 + 112:word32] = eax_29 + 84;
	esi_155 = Mem154[eax_29 + 0x006C:word32];
	Mem157[eax_29 + 116:word32] = 0x1000;
	edx_158 = Mem157[esi_155 + 0x00:word32];
	Mem159[eax_29 + 0x0078:word32] = edx_158;
	edx_160 = Mem159[esi_155 + 8:word32];
	Mem161[eax_29 + 0x007C:word32] = edx_160;
	edx_162 = Mem161[esi_155 + 16:word32];
	Mem163[eax_29 + 0x0080:word32] = edx_162;
	edx_164 = Mem163[esi_155 + 20:word32];
	Mem165[eax_29 + 0x0084:word32] = edx_164;
	ecx_166 = eax_29 + 0x8C;
	Mem167[eax_29 + 0x88:word32] = 0x0800;
	Mem168[eax_29 + 0x8C:word32] = eax_29 + 0x0078;
	eax_169 = Mem168[eax_29 + 112:word32];
	Mem170[eax_29 + 0x90:word32] = eax_169;
	Mem171[0x0807AE08<p32>:word32] = eax_29 + 0x8C;
	eax_172 = 0x01;
	SCZO_174 = cond(fp);
	C_179 = SLICE(SCZO_174, bool, 1);
	O_180 = SLICE(SCZO_174, bool, 4);
	S_181 = SLICE(SCZO_174, bool, 0);
	Z_182 = SLICE(SCZO_174, bool, 2);
}

// 0805CB10: define camlCallback__register_1031
define camlCallback__register_1031
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = eax;
	eax = 0x0806E867;
	fn080709D8();
	esp += 0x08;
	SCZO = cond(esp);
}

// 0805CB20: define camlCallback__register_exception_1034
// Called from:
//      camlUnix__entry
define camlCallback__register_exception_1034
{
	ptr32 fp;
	word32 eax;
	word32 ebx;
	<unknown> Mem0;
	word32 dwLoc14;
	word32 dwLoc0C;
	bool P;
	real64 rLoc1;
	ecx_6 = eax;
	eax_9 = CONVERT(Mem0[ebx + -4:byte], byte, word32);
	if (eax_9 == 0xFE)
	{
		while (true)
		{
			P_60 = ϕ(P, P_24);
			Mem12 = ϕ(Mem0, Mem15);
			eax_13 = Mem12[0x08080414<p32>:word32];
			Mem15[0x08080414<p32>:word32] = eax_13 - 0x0C;
			if (eax_13 - 0x0C >=u Mem15[0x08080418<p32>:word32])
				break;
			fn080708CC();
		}
		Mem26[eax_13 + -0x0C:word32] = 0x08FD;
		rLoc1_49 = Mem26[ebx + 0x00:real64];
		Mem31[eax_13 + -8:real64] = rLoc1_49;
	}
	Top_64 = 0;
	rLoc1_61 = ϕ(rLoc1, rLoc1_49);
	P_58 = ϕ(P, P_60);
	fn080709D8();
	SCZO_47 = cond(fp);
	C_56 = SLICE(SCZO_47, bool, 1);
	O_57 = SLICE(SCZO_47, bool, 4);
	S_63 = SLICE(SCZO_47, bool, 0);
	Z_65 = SLICE(SCZO_47, bool, 2);
}

// 0805CB80: define camlCallback__entry
// Called from:
//      caml_program
define camlCallback__entry
{
	Top_3 = 0;
	Mem5[0x0807CAD0<p32>:word32] = 0x0807CAEC;
	Mem7[0x0807CAD4<p32>:word32] = 0x0807CADC;
	eax_8 = 0x01;
}

// 0805CB9C: define unix_accept
define unix_accept
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 188;
	ebx = 0x0805CBAD<p32>;
	ebx += 92919;
	SCZO = cond(ebx);
	Mem0[ebp + -144:word32] = 0x70;
	caml_enter_blocking_section();
	eax = ebp - 0x90;
	Mem0[esp + 8:word32] = eax;
	eax = ebp - 0x8C;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	eax = accept(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 (struct "sockaddr"))], Mem0[esp + 8:(ptr32 socklen_t)]);
	edi = eax;
	caml_leave_blocking_section();
	SCZO = cond(edi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + 4294957544;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebp + -144:word32];
	Mem0[esp + 4:word32] = eax;
	eax = ebp - 0x8C;
	Mem0[esp + 0x00:word32] = eax;
	alloc_sockaddr();
	Mem0[ebp + -28:word32] = eax;
	esi = Mem0[ebx + -24:word32];
	eax = Mem0[esi + 0x00:word32];
	Mem0[ebp + -0x00B0:word32] = eax;
	eax = ebp - 0xB0;
	Mem0[esi + 0x00:word32] = eax;
	Mem0[ebp + -0x00A8:word32] = 0x01;
	Mem0[ebp + -0x00AC:word32] = 0x01;
	eax = ebp - 28;
	Mem0[ebp + -0x00A4:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	edx = edi + 1 + edi;
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -28:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[ebp + -0x00B0:word32];
	Mem0[esi + 0x00:word32] = edx;
	esp += 188;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CC8A: define __i686.get_pc_thunk.bx
define __i686.get_pc_thunk.bx
{
	esp = fp;
	Top = 0;
	ebx = Mem0[esp + 0x00:word32];
}

// 0805CC90: define unix_access
define unix_access
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CCA1<p32>;
	ebx += 0x00016A03;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	eax = ebx + 0x9498;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	eax = access(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2610;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CCF4: define unix_inet_addr_of_string
define unix_inet_addr_of_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CD05<p32>;
	ebx += 0x0001699F;
	esi = Mem0[ebp + 8:word32];
	eax = ebp - 0x0C;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = 0x02;
	eax = inet_pton(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:(ptr32 void)]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		eax = ebp - 0x0C;
		Mem0[esp + 0x00:word32] = eax;
		alloc_inet_addr();
	}
	else
	{
		eax = ebp - 28;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = esi;
		Mem0[esp + 0x00:word32] = 0x0A;
		eax = inet_pton(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:(ptr32 void)]);
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
			eax = ebp - 28;
			Mem0[esp + 0x00:word32] = eax;
			alloc_inet6_addr();
		}
		else
		{
			eax = ebx + ~0x2609;
			Mem0[esp + 0x00:word32] = eax;
			caml_failwith();
		}
	}
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CD78: define unix_alarm
define unix_alarm
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805CD84<p32>;
	ebx += 92448;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	alarm();
	eax = eax + 1 + eax;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CDA4: define unix_bind
define unix_bind
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x98;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CDB8<p32>;
	ebx += 92396;
	SCZO = cond(ebx);
	eax = ebp - 0x007C;
	Mem0[esp + 8:word32] = eax;
	esi = ebp - 0x0078;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	get_sockaddr();
	eax = Mem0[ebp + -0x007C:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	Mem0[esp + 0x00:word32] = eax;
	eax = bind(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 (struct "sockaddr"))], Mem0[esp + 8:socklen_t]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x25F5;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CE1C: define unix_chdir
define unix_chdir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CE2D<p32>;
	ebx += 92279;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = esi;
	chdir();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x25F0;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CE64: define unix_chmod
define unix_chmod
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CE75<p32>;
	ebx += 92207;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	eax = chmod(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:mode_t]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x25AE;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CEB8: define unix_chown
define unix_chown
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CEC9<p32>;
	ebx += 92123;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	chown();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x25A7;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CF14: define unix_chroot
define unix_chroot
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CF25<p32>;
	ebx += 0x0001677F;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = esi;
	chroot();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x25EA;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CF5C: define unix_close
define unix_close
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805CF68<p32>;
	ebx += 91964;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	Mem0[esp + 0x00:word32] = eax;
	eax = close(Mem0[esp + 0x00:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x25E3;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805CFA4: define unix_closedir
define unix_closedir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805CFB5<p32>;
	ebx += 0x000166EF;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[esi + 0x00:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x25DD;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x09;
		unix_error();
	}
	Mem0[esp + 0x00:word32] = eax;
	eax = closedir(Mem0[esp + 0x00:(ptr32 DIR)]);
	Mem0[esi + 0x00:word32] = 0x00;
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D000: define unix_connect
define unix_connect
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x90;
	ebx = 0x0805D010<p32>;
	ebx += 0x00016694;
	SCZO = cond(ebx);
	eax = ebp - 0x007C;
	Mem0[esp + 8:word32] = eax;
	esi = ebp - 0x0078;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	get_sockaddr();
	caml_enter_blocking_section();
	eax = Mem0[ebp + -0x007C:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	eax = connect(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 (struct "sockaddr"))], Mem0[esp + 8:socklen_t]);
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x25D4;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x90;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D080: define unix_dup
define unix_dup
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D08C<p32>;
	ebx += 0x00016618;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	Mem0[esp + 0x00:word32] = eax;
	eax = dup(Mem0[esp + 0x00:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x25CC;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = eax + 1 + eax;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D0C4: define unix_dup2
define unix_dup2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D0D0<p32>;
	ebx += 0x000165D4;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	dup2();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x25C8;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D114: define unix_environment
define unix_environment
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D120<p32>;
	ebx += 0x00016584;
	SCZO = cond(ebx);
	eax = Mem0[ebx + -20:word32];
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string_array();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D13C: define unix_error_message
define unix_error_message
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D148<p32>;
	ebx += 0x0001655C;
	eax = Mem0[ebp + 8:word32];
	SZP = cond(al & 0x01);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		eax = Mem0[eax + 0x00:word32];
		eax >>= 0x01;
		SCZ = cond(eax);
		O = false;
	}
	else
	{
		eax >>= 0x01;
		SCZ = cond(eax);
		O = false;
		edx = Mem0[ebx + -8:word32];
		eax = edx[eax * 0x04];
	}
	Mem0[esp + 0x00:word32] = eax;
	eax = strerror(Mem0[esp + 0x00:int32]);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D17C: define unix_execv
define unix_execv
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805D190<p32>;
	ebx += 0x00016514;
	SCZO = cond(ebx);
	edi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	cstringvect();
	esi = eax;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = edi;
	eax = execv(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 (ptr32 char))]);
	Mem0[esp + 0x00:word32] = esi;
	caml_stat_free();
	Mem0[esp + 4:word32] = edi;
	eax = ebx + ~0x25C3;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	unix_execve();
}

// 0805D1CC: define unix_execve
// Called from:
//      unix_execv
define unix_execve
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805D1E0<p32>;
	ebx += 0x000164C4;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	cstringvect();
	esi = eax;
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 0x00:word32] = eax;
	cstringvect();
	edi = eax;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	execve();
	Mem0[esp + 0x00:word32] = esi;
	caml_stat_free();
	Mem0[esp + 0x00:word32] = edi;
	caml_stat_free();
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = ebx + ~0x25BD;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	unix_execvpe();
}

// 0805D238: define unix_execvpe
// Called from:
//      unix_execve
define unix_execvpe
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805D24C<p32>;
	ebx += 91224;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	cstringvect();
	edi = eax;
	esi = Mem0[ebx + -20:word32];
	eax = Mem0[esi + 0x00:word32];
	Mem0[ebp + -28:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 0x00:word32] = eax;
	cstringvect();
	Mem0[esi + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = execvp(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 (ptr32 char))]);
	Mem0[esp + 0x00:word32] = edi;
	caml_stat_free();
	eax = Mem0[esi + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_free();
	eax = Mem0[ebp + -28:word32];
	Mem0[esi + 0x00:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = ebx + ~0x25B6;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	unix_execvp();
}

// 0805D2B2: define unix_execvp
// Called from:
//      unix_execvpe
define unix_execvp
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805D2C6<p32>;
	ebx += 91102;
	SCZO = cond(ebx);
	edi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	cstringvect();
	esi = eax;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = edi;
	eax = execvp(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 (ptr32 char))]);
	Mem0[esp + 0x00:word32] = esi;
	caml_stat_free();
	Mem0[esp + 4:word32] = edi;
	eax = ebx + ~0x25B6;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	unix_fchmod();
}

// 0805D304: define unix_fchmod
// Called from:
//      unix_execvp
define unix_fchmod
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D310<p32>;
	ebx += 0x00016394;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	fchmod();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x25AF;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D354: define unix_fchown
define unix_fchown
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D360<p32>;
	ebx += 0x00016344;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	fchown();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x25A8;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D3AC: define unix_clear_close_on_exec
define unix_clear_close_on_exec
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805D3BD<p32>;
	ebx += 90855;
	esi = Mem0[ebp + 8:word32];
	esi >>= 0x01;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x01;
	Mem0[esp + 0x00:word32] = esi;
	eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(NE,Z))
	{
		eax &= ~0x01;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x02;
		Mem0[esp + 0x00:word32] = esi;
		eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
		SCZO = cond(eax - ~0x00);
		if (Test(NE,Z))
		{
l0805D417:
			eax = 0x01;
			ebx = Mem0[ebp + -8:word32];
			esi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 4:word32] = 0x00;
	eax = ebx + ~0x25A1;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	goto l0805D417;
}

// 0805D426: define unix_set_close_on_exec
define unix_set_close_on_exec
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805D437<p32>;
	ebx += 0x0001626D;
	esi = Mem0[ebp + 8:word32];
	esi >>= 0x01;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x01;
	Mem0[esp + 0x00:word32] = esi;
	eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(NE,Z))
	{
		eax |= 0x01;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x02;
		Mem0[esp + 0x00:word32] = esi;
		eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
		SCZO = cond(eax - ~0x00);
		if (Test(NE,Z))
		{
l0805D491:
			eax = 0x01;
			ebx = Mem0[ebp + -8:word32];
			esi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 4:word32] = 0x00;
	eax = ebx + ~0x258D;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	goto l0805D491;
}

// 0805D4A0: define unix_clear_nonblock
define unix_clear_nonblock
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805D4B1<p32>;
	ebx += 0x000161F3;
	esi = Mem0[ebp + 8:word32];
	esi >>= 0x01;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x03;
	Mem0[esp + 0x00:word32] = esi;
	eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(NE,Z))
	{
		ah &= ~0x08;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x04;
		Mem0[esp + 0x00:word32] = esi;
		eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
		SCZO = cond(eax - ~0x00);
		if (Test(NE,Z))
		{
l0805D50B:
			eax = 0x01;
			ebx = Mem0[ebp + -8:word32];
			esi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 4:word32] = 0x00;
	eax = ebx + ~0x257B;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	goto l0805D50B;
}

// 0805D51A: define unix_set_nonblock
define unix_set_nonblock
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805D52B<p32>;
	ebx += 0x00016179;
	esi = Mem0[ebp + 8:word32];
	esi >>= 0x01;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x03;
	Mem0[esp + 0x00:word32] = esi;
	eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(NE,Z))
	{
		ah |= 0x08;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x04;
		Mem0[esp + 0x00:word32] = esi;
		eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
		SCZO = cond(eax - ~0x00);
		if (Test(NE,Z))
		{
l0805D585:
			eax = 0x01;
			ebx = Mem0[ebp + -8:word32];
			esi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 4:word32] = 0x00;
	eax = ebx + ~0x256C;
	Mem0[esp + 0x00:word32] = eax;
	uerror();
	goto l0805D585;
}

// 0805D5A0: define unix_fork
define unix_fork
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805D5B1<p32>;
	ebx += 90355;
	SCZO = cond(ebx);
	fork();
	esi = eax;
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x255F;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = Mem0[ebx + -16:word32];
	SCZO = cond(Mem0[eax + 0x00:word32] - 0x00);
	if (Test(NE,Z))
	{
		eax = Mem0[ebx + -0x0C:word32];
		eax = Mem0[eax + 0x00:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			SZP = cond(esi & esi);
			O = false;
			C = false;
			if (Test(EQ,Z))
				goto l0805D5FC;
		}
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
			goto l0805D605;
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
l0805D5FC:
			esi = esi;
			caml_debugger_cleanup_fork();
			goto l0805D605;
		}
	}
l0805D605:
	eax = esi + 1 + esi;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D614: define unix_ftruncate_64
define unix_ftruncate_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D620<p32>;
	ebx += 90244;
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = edx;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	ftruncate64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x255A;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D66A: define unix_ftruncate
define unix_ftruncate
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805D676<p32>;
	ebx += 0x0001602E;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	Mem0[esp + 8:word32] = edx;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	ftruncate64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x255A;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805D6D0: define unix_getaddrinfo
define unix_getaddrinfo
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x013C;
	ebx = 0x0805D6E1<p32>;
	ebx += 90051;
	SCZO = cond(ebx);
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + -312:word32] = edx;
	Mem0[ebp + -56:word32] = edx;
	edx = ebp - 56;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x03;
	ecx = ebp + 8;
	Mem0[ebp + -44:word32] = ecx;
	ecx = ebp + 0x0C;
	Mem0[ebp + -40:word32] = ecx;
	ecx = ebp + 16;
	Mem0[ebp + -36:word32] = ecx;
	Mem0[ebp + -60:word32] = 0x00;
	Mem0[ebp + -64:word32] = 0x00;
	Mem0[ebp + -0x0044:word32] = 0x00;
	Mem0[ebp + -100:word32] = edx;
	edx = ebp - 100;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + -92:word32] = 0x01;
	Mem0[ebp + -96:word32] = 0x03;
	eax = ebp - 60;
	Mem0[ebp + -88:word32] = eax;
	eax = ebp - 64;
	Mem0[ebp + -84:word32] = eax;
	eax = ebp - 0x0044;
	Mem0[ebp + -80:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	esi = 0x00;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		++eax;
		SCZO = cond(eax);
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_alloc();
		esi = eax;
		eax = Mem0[ebp + 8:word32];
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = esi;
		eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	}
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	edi = 0x00;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		++eax;
		SCZO = cond(eax);
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_alloc();
		edi = eax;
		eax = Mem0[ebp + 0x0C:word32];
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edi;
		eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	}
	ecx = ebp - 0x84;
	edx = 0x00;
	eax = 0x00;
	do
	{
		Mem0[ecx + eax:word32] = edx;
		eax += 0x04;
		SCZO = cond(eax - 0x20);
	} while (Test(ULT,C));
	Mem0[ebp + -0x0080:word32] = 0x00;
	eax = Mem0[ebp + 16:word32];
	SZP = cond(al & 0x01);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		ecx = Mem0[ebx + -28:word32];
		do
		{
			eax = Mem0[eax + 0x00:word32];
			Mem0[ebp + -64:word32] = eax;
			SZP = cond(al & 0x01);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				edx = CONVERT(Mem0[eax + -4:byte], byte, word32);
				SCZO = cond(dl - 0x01);
				if (Test(NE,Z))
				{
					SCZO = cond(dl - 0x01);
					if (Test(UGE,C))
					{
						SCZO = cond(dl - 0x02);
						if (Test(EQ,Z))
						{
							eax = Mem0[eax + 0x00:word32];
							eax >>= 0x01;
							SCZ = cond(eax);
							O = false;
							Mem0[ebp + -0x0078:word32] = eax;
						}
					}
					else
					{
						eax = Mem0[eax + 0x00:word32];
						eax >>= 0x01;
						SCZ = cond(eax);
						O = false;
						edx = Mem0[ebx + -32:word32];
						eax = edx[eax * 0x04];
						Mem0[ebp + -0x0080:word32] = eax;
					}
				}
				else
				{
					eax = Mem0[eax + 0x00:word32];
					eax >>= 0x01;
					SCZ = cond(eax);
					O = false;
					eax = ecx[eax * 0x04];
					Mem0[ebp + -0x007C:word32] = eax;
				}
			}
			else
			{
				eax >>= 0x01;
				SCZO = cond(eax - 0x01);
				if (Test(NE,Z))
				{
					SCZO = cond(eax - 0x02);
					if (Test(NE,Z))
					{
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(EQ,Z))
						{
							v20 = Mem0[ebp + -0x0084:word32] | 0x04;
							Mem0[ebp + -0x0084:word32] = v20;
							SZ = cond(Mem0[ebp + -0x0084:word32]);
							O = false;
							C = false;
						}
					}
					else
					{
						v23 = Mem0[ebp + -0x0084:word32] | 0x01;
						Mem0[ebp + -0x0084:word32] = v23;
						SZ = cond(Mem0[ebp + -0x0084:word32]);
						O = false;
						C = false;
					}
				}
				else
				{
					v22 = Mem0[ebp + -0x0084:word32] | 0x02;
					Mem0[ebp + -0x0084:word32] = v22;
					SZ = cond(Mem0[ebp + -0x0084:word32]);
					O = false;
					C = false;
				}
			}
			eax = Mem0[ebp + 16:word32];
			eax = Mem0[eax + 4:word32];
			Mem0[ebp + 16:word32] = eax;
			SZP = cond(al & 0x01);
			O = false;
			C = false;
		} while (Test(EQ,Z));
	}
	caml_enter_blocking_section();
	eax = ebp - 0x88;
	Mem0[esp + 0x0C:word32] = eax;
	eax = ebp - 0x84;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = edi;
	Mem0[esp + 0x00:word32] = esi;
	eax = getaddrinfo(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:(ptr32 (struct "addrinfo" 0020))], Mem0[esp + 0x0C:(ptr32 (ptr32 (struct "addrinfo" 0020)))]);
	Mem0[ebp + -300:word32] = eax;
	caml_leave_blocking_section();
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = esi;
		caml_stat_free();
	}
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = edi;
		caml_stat_free();
	}
	Mem0[ebp + -60:word32] = 0x01;
	SCZO = cond(Mem0[ebp + -300:word32] - 0x00);
	if (Test(EQ,Z))
	{
		esi = Mem0[ebp + -0x0088:word32];
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			ecx = ebp - 0xB4;
			Mem0[ebp + -308:word32] = ecx;
			do
			{
				eax = Mem0[ebx + -24:word32];
				eax = Mem0[eax + 0x00:word32];
				Mem0[ebp + -300:word32] = eax;
				Mem0[ebp + -0x008C:word32] = 0x00;
				Mem0[ebp + -144:word32] = 0x00;
				Mem0[ebp + -0x0094:word32] = 0x00;
				Mem0[ebp + -0x00B4:word32] = eax;
				ecx = Mem0[ebp + -308:word32];
				edx = Mem0[ebx + -24:word32];
				Mem0[edx + 0x00:word32] = ecx;
				Mem0[ebp + -0x00AC:word32] = 0x01;
				Mem0[ebp + -0x00B0:word32] = 0x03;
				eax = ebp - 0x8C;
				Mem0[ebp + -0x00A8:word32] = eax;
				eax = ebp - 0x90;
				Mem0[ebp + -0x00A4:word32] = eax;
				eax = ebp - 0x94;
				Mem0[ebp + -0x00A0:word32] = eax;
				eax = Mem0[esi + 16:word32];
				SCZO = cond(eax - 0x70);
				edi = 0x70;
				if (Test(ULE,CZ))
					edi = eax;
				eax = ebp - 292;
				Mem0[ebp + -304:word32] = eax;
				eax = Mem0[esi + 20:word32];
				Mem0[esp + 8:word32] = edi;
				Mem0[esp + 4:word32] = eax;
				edx = Mem0[ebp + -304:word32];
				Mem0[esp + 0x00:word32] = edx;
				eax = memcpy(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
				Mem0[esp + 8:word32] = ~0x00;
				Mem0[esp + 4:word32] = edi;
				ecx = Mem0[ebp + -304:word32];
				Mem0[esp + 0x00:word32] = ecx;
				alloc_sockaddr();
				Mem0[ebp + -144:word32] = eax;
				eax = Mem0[esi + 24:word32];
				SZP = cond(eax & eax);
				O = false;
				C = false;
				edx = ebx + ~0x147B;
				if (Test(EQ,Z))
					eax = edx;
				Mem0[esp + 0x00:word32] = eax;
				caml_copy_string();
				Mem0[ebp + -0x0094:word32] = eax;
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = 0x05;
				caml_alloc_small();
				edi = eax;
				Mem0[ebp + -0x008C:word32] = eax;
				Mem0[esp + 0x0C:word32] = 0x00;
				Mem0[esp + 8:word32] = 0x03;
				eax = Mem0[ebx + -32:word32];
				Mem0[esp + 4:word32] = eax;
				eax = Mem0[esi + 4:word32];
				Mem0[esp + 0x00:word32] = eax;
				cst_to_constr();
				Mem0[edi + 0x00:word32] = eax;
				edi = Mem0[ebp + -0x008C:word32];
				edi += 0x04;
				SCZO = cond(edi);
				Mem0[esp + 0x0C:word32] = 0x00;
				Mem0[esp + 8:word32] = 0x04;
				edx = Mem0[ebx + -28:word32];
				Mem0[esp + 4:word32] = edx;
				eax = Mem0[esi + 8:word32];
				Mem0[esp + 0x00:word32] = eax;
				cst_to_constr();
				Mem0[edi + 0x00:word32] = eax;
				eax = Mem0[esi + 0x0C:word32];
				edx = eax + 1 + eax;
				eax = Mem0[ebp + -0x008C:word32];
				Mem0[eax + 8:word32] = edx;
				edx = Mem0[ebp + -144:word32];
				eax = Mem0[ebp + -0x008C:word32];
				Mem0[eax + 0x0C:word32] = edx;
				edx = Mem0[ebp + -0x0094:word32];
				eax = Mem0[ebp + -0x008C:word32];
				Mem0[eax + 16:word32] = edx;
				eax = Mem0[ebx + -24:word32];
				ecx = Mem0[ebp + -300:word32];
				Mem0[eax + 0x00:word32] = ecx;
				eax = Mem0[ebp + -0x008C:word32];
				Mem0[ebp + -0x0044:word32] = eax;
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = 0x02;
				caml_alloc_small();
				Mem0[ebp + -64:word32] = eax;
				edx = Mem0[ebp + -0x0044:word32];
				Mem0[eax + 0x00:word32] = edx;
				edx = Mem0[ebp + -60:word32];
				eax = Mem0[ebp + -64:word32];
				Mem0[eax + 4:word32] = edx;
				eax = Mem0[ebp + -64:word32];
				Mem0[ebp + -60:word32] = eax;
				esi = Mem0[esi + 28:word32];
				SZP = cond(esi & esi);
				O = false;
				C = false;
			} while (Test(NE,Z));
		}
		eax = Mem0[ebp + -0x0088:word32];
		Mem0[esp + 0x00:word32] = eax;
		freeaddrinfo(Mem0[esp + 0x00:(ptr32 (struct "addrinfo" 0020))]);
	}
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[ebp + -312:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = Mem0[ebp + -60:word32];
	esp += 0x013C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DADC: define unix_getcwd
define unix_getcwd
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1014;
	ebx = 0x0805DAEB<p32>;
	ebx += 0x00015BB9;
	Mem0[esp + 4:word32] = 0x1000;
	eax = ebp + ~0x1007;
	Mem0[esp + 0x00:word32] = eax;
	eax = getcwd(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:size_t]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2550;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = ebp + ~0x1007;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	esp += 0x1014;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DB38: define unix_getegid
define unix_getegid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x0805DB44<p32>;
	ebx += 88928;
	SCZO = cond(ebx);
	getegid();
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DB5C: define unix_geteuid
define unix_geteuid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x0805DB68<p32>;
	ebx += 88892;
	eax = geteuid();
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DB80: define unix_getgid
define unix_getgid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x0805DB8C<p32>;
	ebx += 88856;
	eax = getgid();
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DBB0: define alloc_group_entry
// Called from:
//      unix_getgrgid
//      unix_getgrnam
define alloc_group_entry
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	ebx = 0x0805DBBE<p32>;
	ebx += 88806;
	SCZO = cond(ebx);
	esi = eax;
	Mem0[ebp + -28:word32] = 0x01;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x01;
	edi = Mem0[ebx + -24:word32];
	eax = Mem0[edi + 0x00:word32];
	Mem0[ebp + -0x0044:word32] = eax;
	eax = ebp - 0x0044;
	Mem0[edi + 0x00:word32] = eax;
	Mem0[ebp + -60:word32] = 0x01;
	Mem0[ebp + -64:word32] = 0x03;
	eax = ebp - 28;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 36;
	Mem0[ebp + -48:word32] = eax;
	eax = Mem0[esi + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -28:word32] = eax;
	eax = Mem0[esi + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[esi + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string_array();
	Mem0[ebp + -36:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x04;
	caml_alloc_small();
	edx = Mem0[ebp + -28:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -32:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[esi + 8:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 8:word32] = edx;
	edx = Mem0[ebp + -36:word32];
	Mem0[eax + 0x0C:word32] = edx;
	edx = Mem0[ebp + -0x0044:word32];
	Mem0[edi + 0x00:word32] = edx;
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DC70: define unix_getgrgid
define unix_getgrgid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805DC7C<p32>;
	ebx += 88616;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	Mem0[esp + 0x00:word32] = eax;
	eax = getgrgid(Mem0[esp + 0x00:gid_t]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_group_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DCA3: define unix_getgrnam
define unix_getgrnam
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805DCAF<p32>;
	ebx += 88565;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = getgrnam(Mem0[esp + 0x00:(ptr32 char)]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_group_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DCD4: define unix_getgroups
define unix_getgroups
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x0004001C;
	ebx = 0x0805DCE5<p32>;
	ebx += 88511;
	SCZO = cond(ebx);
	eax = ebp + ~0x00040017;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x00010000;
	getgroups();
	esi = eax;
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2549;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_tuple();
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		edx = 0x00;
		edi = ebp + ~0x00040017;
		do
		{
			ecx = edi[edx * 0x04];
			ecx = ecx + 1 + ecx;
			eax[edx * 0x04] = ecx;
			++edx;
			SCZO = cond(edx - esi);
		} while (Test(NE,Z));
	}
	esp += 0x0004001C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DD54: define alloc_host_entry
// Called from:
//      unix_gethostbyname
//      unix_gethostbyaddr
define alloc_host_entry
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x40;
	ebx = 0x0805DD61<p32>;
	ebx += 88387;
	SCZO = cond(ebx);
	esi = eax;
	Mem0[ebp + -0x0C:word32] = 0x01;
	Mem0[ebp + -16:word32] = 0x01;
	Mem0[ebp + -20:word32] = 0x01;
	Mem0[ebp + -24:word32] = 0x01;
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + -56:word32] = edx;
	edx = ebp - 56;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x04;
	eax = ebp - 0x0C;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp - 16;
	Mem0[ebp + -40:word32] = eax;
	eax = ebp - 20;
	Mem0[ebp + -36:word32] = eax;
	eax = ebp - 24;
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[esi + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -0x0C:word32] = eax;
	eax = Mem0[esi + 4:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_copy_string_array();
		Mem0[ebp + -16:word32] = eax;
	}
	else
	{
		eax = Mem0[ebx + -4:word32];
		eax += 4;
		Mem0[ebp + -16:word32] = eax;
	}
	eax = Mem0[esi + 0x0C:word32];
	Mem0[ebx + 0x9A68:word32] = eax;
	eax = Mem0[esi + 16:word32];
	Mem0[esp + 4:word32] = eax;
	eax = ebx + ~0x00015791;
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_array();
	Mem0[ebp + -20:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x04;
	caml_alloc_small();
	edx = Mem0[ebp + -0x0C:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = eax;
	ecx = Mem0[ebp + -16:word32];
	Mem0[eax + 4:word32] = ecx;
	ecx = Mem0[esi + 8:word32];
	SCZO = cond(ecx - 0x01);
	if (Test(NE,Z))
	{
		SCZO = cond(ecx - 0x02);
		cl = CONVERT(Test(NE,Z), bool, int8);
		ecx = CONVERT(cl, byte, word32);
		ecx = ecx + 3 + ecx;
		Mem0[eax + 8:word32] = ecx;
	}
	else
		Mem0[eax + 8:word32] = 0x01;
	ecx = Mem0[ebp + -20:word32];
	Mem0[edx + 0x0C:word32] = ecx;
	ecx = Mem0[ebp + -56:word32];
	edx = Mem0[ebx + -24:word32];
	Mem0[edx + 0x00:word32] = ecx;
	esp += 0x40;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DE63: define unix_gethostbyname
define unix_gethostbyname
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 10088;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805DE7A<p32>;
	ebx += 88106;
	SCZO = cond(ebx);
	edi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = edi;
	caml_string_length();
	++eax;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_alloc();
	esi = eax;
	Mem0[esp + 4:word32] = edi;
	Mem0[esp + 0x00:word32] = eax;
	eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	caml_enter_blocking_section();
	__h_errno_location();
	Mem0[esp + 20:word32] = eax;
	eax = ebp - 28;
	Mem0[esp + 16:word32] = eax;
	Mem0[esp + 0x0C:word32] = 10000;
	eax = ebp + ~0x273F;
	Mem0[esp + 8:word32] = eax;
	eax = ebp - 48;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	gethostbyname_r();
	edi = eax;
	caml_leave_blocking_section();
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(NE,Z))
		Mem0[ebp + -28:word32] = 0x00;
	Mem0[esp + 0x00:word32] = esi;
	caml_stat_free();
	eax = Mem0[ebp + -28:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_host_entry();
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DF12: define alloc_one_addr
define alloc_one_addr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805DF23<p32>;
	ebx += 0x00015781;
	eax = Mem0[ebp + 8:word32];
	SCZO = cond(Mem0[ebx + 0x9A68:word32] - 0x10);
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x10;
		Mem0[esp + 4:word32] = eax;
		esi = ebp - 28;
		Mem0[esp + 0x00:word32] = esi;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		Mem0[esp + 0x00:word32] = esi;
		alloc_inet6_addr();
	}
	else
	{
		Mem0[esp + 8:word32] = 0x04;
		Mem0[esp + 4:word32] = eax;
		esi = ebp - 0x0C;
		Mem0[esp + 0x00:word32] = esi;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		Mem0[esp + 0x00:word32] = esi;
		alloc_inet_addr();
	}
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805DF7F: define unix_gethostbyaddr
define unix_gethostbyaddr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x2750;
	ebx = 0x0805DF8F<p32>;
	ebx += 0x00015715;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 0x00:word32];
	Mem0[ebp + -0x0C:word32] = eax;
	caml_enter_blocking_section();
	eax = ebp + ~0x2737;
	Mem0[esp + 28:word32] = eax;
	eax = ebp - 16;
	Mem0[esp + 24:word32] = eax;
	Mem0[esp + 20:word32] = 10000;
	eax = ebp + ~0x2733;
	Mem0[esp + 16:word32] = eax;
	eax = ebp - 36;
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 8:word32] = 0x02;
	Mem0[esp + 4:word32] = 0x04;
	eax = ebp - 0x0C;
	Mem0[esp + 0x00:word32] = eax;
	gethostbyaddr_r();
	esi = eax;
	caml_leave_blocking_section();
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
		Mem0[ebp + -16:word32] = 0x00;
	else
	{
		eax = Mem0[ebp + -16:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
			goto l0805E007;
	}
	caml_raise_not_found();
l0805E007:
	alloc_host_entry();
	esp += 0x2750;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E018: define unix_gethostname
define unix_gethostname
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 88;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805E029<p32>;
	ebx += 87675;
	SCZO = cond(ebx);
	Mem0[esp + 4:word32] = 0x40;
	esi = ebp - 72;
	Mem0[esp + 0x00:word32] = esi;
	gethostname();
	Mem0[ebp + -9:byte] = 0x00;
	Mem0[esp + 0x00:word32] = esi;
	caml_copy_string();
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E058: define unix_getlogin
define unix_getlogin
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E064<p32>;
	ebx += 87616;
	SCZO = cond(ebx);
	getlogin();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x253F;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x02;
		unix_error();
	}
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E0A0: define unix_getnameinfo
define unix_getnameinfo
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14DC;
	ebx = 0x0805E0B1<p32>;
	ebx += 0x000155F3;
	SCZO = cond(ebx);
	eax = Mem0[ebx + -24:word32];
	edi = Mem0[eax + 0x00:word32];
	Mem0[ebp + -28:word32] = 0x00;
	Mem0[ebp + -32:word32] = 0x00;
	Mem0[ebp + -36:word32] = 0x00;
	Mem0[ebp + -0x0044:word32] = edi;
	edx = ebp - 0x0044;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + -60:word32] = 0x01;
	Mem0[ebp + -64:word32] = 0x03;
	eax = ebp - 28;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 36;
	Mem0[ebp + -48:word32] = eax;
	eax = ebp - 0xB8;
	Mem0[esp + 8:word32] = eax;
	esi = ebp - 0xB4;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	get_sockaddr();
	eax = ebx + 0x94A8;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	Mem0[ebp + ~0x14BB:word32] = eax;
	caml_enter_blocking_section();
	eax = Mem0[ebp + ~0x14BB:word32];
	Mem0[esp + 24:word32] = eax;
	Mem0[esp + 20:word32] = 0x0400;
	eax = ebp + 4294961992;
	Mem0[esp + 16:word32] = eax;
	Mem0[esp + 0x0C:word32] = 0x1000;
	eax = ebp + ~0x10B7;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + -0x00B8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	eax = getnameinfo(Mem0[esp + 0x00:(ptr32 (struct "sockaddr"))], Mem0[esp + 4:socklen_t], Mem0[esp + 8:(ptr32 char)], Mem0[esp + 0x0C:socklen_t], Mem0[esp + 16:(ptr32 char)], Mem0[esp + 20:socklen_t], Mem0[esp + 24:int32]);
	esi = eax;
	caml_leave_blocking_section();
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NE,Z))
		caml_raise_not_found();
	eax = ebp + ~0x10B7;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 4294961992;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -32:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	Mem0[ebp + -36:word32] = eax;
	edx = Mem0[ebp + -28:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -32:word32];
	eax = Mem0[ebp + -36:word32];
	Mem0[eax + 4:word32] = edx;
	eax = Mem0[ebx + -24:word32];
	Mem0[eax + 0x00:word32] = edi;
	eax = Mem0[ebp + -36:word32];
	esp += 0x14DC;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E1E8: define unix_getpeername
define unix_getpeername
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x94;
	ebx = 0x0805E1F7<p32>;
	ebx += 0x000154AD;
	Mem0[ebp + -0x007C:word32] = 0x70;
	eax = ebp - 0x007C;
	Mem0[esp + 8:word32] = eax;
	eax = ebp - 0x0078;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	getpeername();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2536;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 8:word32] = ~0x00;
	eax = Mem0[ebp + -0x007C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = ebp - 0x0078;
	Mem0[esp + 0x00:word32] = eax;
	alloc_sockaddr();
	esp += 0x94;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E260: define unix_getpid
define unix_getpid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x0805E26C<p32>;
	ebx += 0x00015438;
	eax = getpid();
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E284: define unix_getppid
define unix_getppid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x0805E290<p32>;
	ebx += 0x00015414;
	SCZO = cond(ebx);
	getppid();
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E2B0: define alloc_proto_entry
// Called from:
//      unix_getprotobynumber
//      unix_getprotobyname
define alloc_proto_entry
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 88;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805E2C4<p32>;
	ebx += 87008;
	SCZO = cond(ebx);
	esi = eax;
	Mem0[ebp + -28:word32] = 0x01;
	Mem0[ebp + -32:word32] = 0x01;
	edi = Mem0[ebx + -24:word32];
	eax = Mem0[edi + 0x00:word32];
	Mem0[ebp + -64:word32] = eax;
	eax = ebp - 64;
	Mem0[edi + 0x00:word32] = eax;
	Mem0[ebp + -56:word32] = 0x01;
	Mem0[ebp + -60:word32] = 0x02;
	eax = ebp - 28;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -48:word32] = eax;
	eax = Mem0[esi + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -28:word32] = eax;
	eax = Mem0[esi + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string_array();
	Mem0[ebp + -32:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x03;
	caml_alloc_small();
	edx = Mem0[ebp + -28:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -32:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[esi + 8:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 8:word32] = edx;
	edx = Mem0[ebp + -64:word32];
	Mem0[edi + 0x00:word32] = edx;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E35A: define unix_getprotobynumber
define unix_getprotobynumber
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E366<p32>;
	ebx += 86846;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	getprotobynumber();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_proto_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E38D: define unix_getprotobyname
define unix_getprotobyname
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E399<p32>;
	ebx += 0x0001530B;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	getprotobyname();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_proto_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E3C0: define alloc_passwd_entry
// Called from:
//      unix_getpwuid
//      unix_getpwnam
define alloc_passwd_entry
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x5C;
	ebx = 0x0805E3CE<p32>;
	ebx += 0x000152D6;
	SCZO = cond(ebx);
	esi = eax;
	Mem0[ebp + -28:word32] = 0x01;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x01;
	Mem0[ebp + -40:word32] = 0x01;
	Mem0[ebp + -44:word32] = 0x01;
	edi = Mem0[ebx + -24:word32];
	eax = Mem0[edi + 0x00:word32];
	Mem0[ebp + -76:word32] = eax;
	eax = ebp - 76;
	Mem0[edi + 0x00:word32] = eax;
	Mem0[ebp + -0x0044:word32] = 0x01;
	Mem0[ebp + -72:word32] = 0x05;
	eax = ebp - 28;
	Mem0[ebp + -64:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -60:word32] = eax;
	eax = ebp - 36;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 40;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 44;
	Mem0[ebp + -48:word32] = eax;
	eax = Mem0[esi + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -28:word32] = eax;
	eax = Mem0[esi + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[esi + 16:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -36:word32] = eax;
	eax = Mem0[esi + 20:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -40:word32] = eax;
	eax = Mem0[esi + 24:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -44:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x07;
	caml_alloc_small();
	edx = Mem0[ebp + -28:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -32:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[esi + 8:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 8:word32] = edx;
	edx = Mem0[esi + 0x0C:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 0x0C:word32] = edx;
	edx = Mem0[ebp + -36:word32];
	Mem0[eax + 16:word32] = edx;
	edx = Mem0[ebp + -40:word32];
	Mem0[eax + 20:word32] = edx;
	edx = Mem0[ebp + -44:word32];
	Mem0[eax + 24:word32] = edx;
	edx = Mem0[ebp + -76:word32];
	Mem0[edi + 0x00:word32] = edx;
	esp += 0x5C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E4CC: define unix_getpwuid
define unix_getpwuid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E4D8<p32>;
	ebx += 0x000151CC;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	Mem0[esp + 0x00:word32] = eax;
	eax = getpwuid(Mem0[esp + 0x00:uid_t]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_passwd_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E4FF: define unix_getpwnam
define unix_getpwnam
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E50B<p32>;
	ebx += 0x00015199;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = getpwnam(Mem0[esp + 0x00:(ptr32 char)]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_passwd_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E530: define unix_gettimeofday
define unix_gettimeofday
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x0805E53C<p32>;
	ebx += 0x00015168;
	Mem0[esp + 4:word32] = 0x00;
	eax = ebp - 16;
	Mem0[esp + 0x00:word32] = eax;
	eax = gettimeofday(Mem0[esp + 0x00:(ptr32 (struct "timeval"))], Mem0[esp + 4:(ptr32 (struct "timezone"))]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x252A;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -16:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -0x0C:int32], int32, real64);
	ST[Top + 0x00:real64] /= CONVERT(Mem0[ebx + ~0x251B:real32], real32, real64);
	ST[Top + 1:real64] += ST[Top + 0x00:real64];
	++Top;
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E590: define alloc_service_entry
// Called from:
//      unix_getservbyport
//      unix_getservbyname
define alloc_service_entry
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	ebx = 0x0805E59E<p32>;
	ebx += 0x00015106;
	SCZO = cond(ebx);
	esi = eax;
	Mem0[ebp + -28:word32] = 0x01;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x01;
	edi = Mem0[ebx + -24:word32];
	eax = Mem0[edi + 0x00:word32];
	Mem0[ebp + -0x0044:word32] = eax;
	eax = ebp - 0x0044;
	Mem0[edi + 0x00:word32] = eax;
	Mem0[ebp + -60:word32] = 0x01;
	Mem0[ebp + -64:word32] = 0x03;
	eax = ebp - 28;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 36;
	Mem0[ebp + -48:word32] = eax;
	eax = Mem0[esi + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -28:word32] = eax;
	eax = Mem0[esi + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string_array();
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[esi + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -36:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x04;
	caml_alloc_small();
	edx = Mem0[ebp + -28:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -32:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[esi + 8:word32];
	v11 = (dx & 0x01 << 0x08) != 0x00;
	dx = __ror<word16,byte>(dx, 0x08);
	edx = CONVERT(dx, word16, word32);
	edx = edx + 1 + edx;
	Mem0[eax + 8:word32] = edx;
	edx = Mem0[ebp + -36:word32];
	Mem0[eax + 0x0C:word32] = edx;
	edx = Mem0[ebp + -0x0044:word32];
	Mem0[edi + 0x00:word32] = edx;
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E657: define unix_getservbyport
define unix_getservbyport
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E663<p32>;
	ebx += 0x00015041;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	v10 = (ax & 0x01 << 0x08) != 0x00;
	ax = __ror<word16,byte>(ax, 0x08);
	C = v10;
	edx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = edx;
	eax = CONVERT(ax, word16, word32);
	Mem0[esp + 0x00:word32] = eax;
	getservbyport();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	esi = esi;
	alloc_service_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E69B: define unix_getservbyname
define unix_getservbyname
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E6A7<p32>;
	ebx += 0x00014FFD;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	getservbyname();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	alloc_service_entry();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E6D4: define unix_getsockname
define unix_getsockname
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x94;
	ebx = 0x0805E6E3<p32>;
	ebx += 0x00014FC1;
	Mem0[ebp + -0x007C:word32] = 0x70;
	eax = ebp - 0x007C;
	Mem0[esp + 8:word32] = eax;
	eax = ebp - 0x0078;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	getsockname();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2517;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 8:word32] = ~0x00;
	eax = Mem0[ebp + -0x007C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = ebp - 0x0078;
	Mem0[esp + 0x00:word32] = eax;
	alloc_sockaddr();
	esp += 0x94;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E74C: define unix_getuid
define unix_getuid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x0805E758<p32>;
	ebx += 0x00014F4C;
	eax = getuid();
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E770: define alloc_tm
// Called from:
//      unix_mktime
//      unix_localtime
//      unix_gmtime
define alloc_tm
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	ebx = 0x0805E77D<p32>;
	ebx += 85799;
	SCZO = cond(ebx);
	esi = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x09;
	caml_alloc_small();
	edx = Mem0[esi + 0x00:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[esi + 4:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[esi + 8:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 8:word32] = edx;
	edx = Mem0[esi + 0x0C:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 0x0C:word32] = edx;
	edx = Mem0[esi + 16:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 16:word32] = edx;
	edx = Mem0[esi + 20:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 20:word32] = edx;
	edx = Mem0[esi + 24:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 24:word32] = edx;
	edx = Mem0[esi + 28:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 28:word32] = edx;
	SCZO = cond(Mem0[esi + 32:word32] - 0x01);
	edx = edx - edx - C;
	edx &= ~0x01;
	edx += 0x03;
	Mem0[eax + 32:word32] = edx;
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E7FD: define unix_mktime
define unix_mktime
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp += ~0x7F;
	ebx = 0x0805E80A<p32>;
	ebx += 85658;
	eax = Mem0[ebp + 8:word32];
	Mem0[ebp + -56:word32] = 0x01;
	Mem0[ebp + -60:word32] = 0x01;
	edx = Mem0[ebx + -24:word32];
	ecx = Mem0[edx + 0x00:word32];
	Mem0[ebp + -92:word32] = ecx;
	ecx = ebp - 92;
	Mem0[edx + 0x00:word32] = ecx;
	Mem0[ebp + -84:word32] = 0x01;
	Mem0[ebp + -88:word32] = 0x02;
	edx = ebp - 56;
	Mem0[ebp + -80:word32] = edx;
	edx = ebp - 60;
	Mem0[ebp + -76:word32] = edx;
	edx = Mem0[eax + 0x00:word32];
	edx >>= 0x01;
	Mem0[ebp + -52:word32] = edx;
	edx = Mem0[eax + 4:word32];
	edx >>= 0x01;
	Mem0[ebp + -48:word32] = edx;
	edx = Mem0[eax + 8:word32];
	edx >>= 0x01;
	Mem0[ebp + -44:word32] = edx;
	edx = Mem0[eax + 0x0C:word32];
	edx >>= 0x01;
	Mem0[ebp + -40:word32] = edx;
	edx = Mem0[eax + 16:word32];
	edx >>= 0x01;
	Mem0[ebp + -36:word32] = edx;
	edx = Mem0[eax + 20:word32];
	edx >>= 0x01;
	Mem0[ebp + -32:word32] = edx;
	edx = Mem0[eax + 24:word32];
	edx >>= 0x01;
	Mem0[ebp + -28:word32] = edx;
	eax = Mem0[eax + 28:word32];
	eax >>= 0x01;
	Mem0[ebp + -24:word32] = eax;
	Mem0[ebp + -20:word32] = ~0x00;
	eax = ebp - 52;
	Mem0[esp + 0x00:word32] = eax;
	eax = mktime(Mem0[esp + 0x00:(ptr32 (struct "tm"))]);
	esi = eax;
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x250B;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x22;
		unix_error();
	}
	eax = ebp - 52;
	alloc_tm();
	Mem0[ebp + -56:word32] = eax;
	Mem0[ebp + -0x006C:word32] = esi;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -0x006C:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[ebp + -60:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	edx = Mem0[ebp + -60:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -56:word32];
	Mem0[eax + 4:word32] = edx;
	ecx = Mem0[ebp + -92:word32];
	edx = Mem0[ebx + -24:word32];
	Mem0[edx + 0x00:word32] = ecx;
	esp -= ~0x7F;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E90E: define unix_localtime
define unix_localtime
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x34;
	ebx = 0x0805E91A<p32>;
	ebx += 85386;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -26:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -26:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -28:word16] = ax;
	__fldcw(Mem0[ebp + -28:word16]);
	Mem0[ebp + -0x0C:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -26:word16]);
	eax = ebp - 0x0C;
	Mem0[esp + 0x00:word32] = eax;
	eax = localtime(Mem0[esp + 0x00:time_t]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x2504;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 22;
		unix_error();
	}
	alloc_tm();
	esp += 0x34;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E973: define unix_gmtime
define unix_gmtime
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x34;
	ebx = 0x0805E97F<p32>;
	ebx += 85285;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -26:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -26:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -28:word16] = ax;
	__fldcw(Mem0[ebp + -28:word16]);
	Mem0[ebp + -0x0C:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -26:word16]);
	eax = ebp - 0x0C;
	Mem0[esp + 0x00:word32] = eax;
	gmtime();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x24FA;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 22;
		unix_error();
	}
	alloc_tm();
	esp += 0x34;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805E9D8: define unix_initgroups
define unix_initgroups
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805E9E4<p32>;
	ebx += 0x00014CC0;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	initgroups();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24F3;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EA24: define unix_isatty
define unix_isatty
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805EA30<p32>;
	ebx += 0x00014C74;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	Mem0[esp + 0x00:word32] = eax;
	eax = isatty(Mem0[esp + 0x00:int32]);
	SCZO = cond(eax - 0x01);
	eax = eax - eax - C;
	eax &= ~0x01;
	eax += 0x03;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EA54: define unix_convert_itimer
// Called from:
//      unix_getitimer
//      unix_setitimer
define unix_convert_itimer
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805EA65<p32>;
	ebx += 85055;
	SCZO = cond(ebx);
	esi = eax;
	Mem0[esp + 4:word32] = 0xFE;
	Mem0[esp + 0x00:word32] = 0x04;
	caml_alloc_small();
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[esi + 0x00:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[esi + 4:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebx + ~0x251B:real32], real32, real64);
	ST[Top + 1:real64] /= ST[Top + 0x00:real64];
	v10 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v10;
	ST[Top + 2:real64] += ST[Top + 0x00:real64];
	++Top;
	v11 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v11;
	Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[esi + 8:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[esi + 0x0C:int32], int32, real64);
	ST[Top + 2:real64] = ST[Top + 0x00:real64] / ST[Top + 2:real64];
	++Top;
	ST[Top + 1:real64] += ST[Top + 0x00:real64];
	++Top;
	Mem0[eax + 8:real64] = ST[Top + 0x00:real64];
	++Top;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EAAD: define unix_getitimer
define unix_getitimer
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x0805EAB9<p32>;
	ebx += 0x00014BEB;
	eax = ebp - 24;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	eax = (ebx + ~0x24D3)[eax * 0x04];
	Mem0[esp + 0x00:word32] = eax;
	getitimer();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24E8;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = ebp - 24;
	unix_convert_itimer();
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EB03: define unix_set_timeval
// Called from:
//      unix_setitimer
define unix_set_timeval
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805EB17<p32>;
	ebx += 84877;
	SCZO = cond(ebx);
	esi = eax;
	eax = ebp - 32;
	Mem0[esp + 8:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + 8:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	modf();
	Mem0[ebp + -42:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -42:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -44:word16] = ax;
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -32:real64];
	__fldcw(Mem0[ebp + -44:word16]);
	Mem0[ebp + -48:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -42:word16]);
	edi = Mem0[ebp + -48:word32];
	Mem0[esi + 0x00:word32] = edi;
	ST[Top + 0x00:real64] *= CONVERT(Mem0[ebx + ~0x251B:real32], real32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	ceil();
	Mem0[ebp + -42:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -42:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -44:word16] = ax;
	__fldcw(Mem0[ebp + -44:word16]);
	Mem0[ebp + -48:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -42:word16]);
	eax = Mem0[ebp + -48:word32];
	Mem0[esi + 4:word32] = eax;
	SCZO = cond(eax - 999999);
	if (Test(GT,SZO))
	{
		++edi;
		SCZO = cond(edi);
		Mem0[esi + 0x00:word32] = edi;
		Mem0[esi + 4:word32] = 0x00;
	}
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EB99: define unix_setitimer
define unix_setitimer
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805EBAD<p32>;
	ebx += 84727;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 0x0C:word32];
	edi = ebp - 40;
	--Top;
	ST[Top + 0x00:real64] = Mem0[esi + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = edi;
	unix_set_timeval();
	eax = ebp - 32;
	--Top;
	ST[Top + 0x00:real64] = Mem0[esi + 8:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	unix_set_timeval();
	eax = ebp - 56;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	eax = (ebx + ~0x24D3)[eax * 0x04];
	Mem0[esp + 0x00:word32] = eax;
	setitimer();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24DE;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = ebp - 56;
	unix_convert_itimer();
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EC24: define unix_kill
define unix_kill
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805EC30<p32>;
	ebx += 0x00014A74;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_signal_number();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	kill();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24C7;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EC7C: define unix_link
define unix_link
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805EC8D<p32>;
	ebx += 0x00014A17;
	esi = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = link(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2467;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805ECCC: define unix_listen
define unix_listen
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805ECD8<p32>;
	ebx += 84428;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	listen();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24C2;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805ED1C: define unix_lockf
define unix_lockf
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	ebx = 0x0805ED29<p32>;
	ebx += 84347;
	eax = Mem0[ebp + 16:word32];
	esi = Mem0[ebp + 8:word32];
	esi >>= 0x01;
	Mem0[ebp + -30:word16] = 0x01;
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	if (Test(SG,S))
	{
		Mem0[ebp + -28:word32] = eax;
		edx = eax;
		edx >>= 0x1F;
		Mem0[ebp + -24:word32] = edx;
		eax = -eax;
		SZO = cond(eax);
		Mem0[ebp + -20:word32] = eax;
		edx = eax;
		edx >>= 0x1F;
		SCZ = cond(edx);
		Mem0[ebp + -16:word32] = edx;
	}
	else
	{
		Mem0[ebp + -28:word32] = 0x00;
		Mem0[ebp + -24:word32] = 0x00;
		Mem0[ebp + -20:word32] = eax;
		edx = eax;
		edx >>= 0x1F;
		SCZ = cond(edx);
		Mem0[ebp + -16:word32] = edx;
	}
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZO = cond(eax - 0x05);
	if (Test(UGT,CZ))
	{
		eax = __errno_location();
		Mem0[eax + 0x00:word32] = 22;
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24BB;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
		eax = 0x01;
		esp += 0x30;
		SCZO = cond(esp);
		ebx = Mem0[esp + 0x00:word32];
		esp += 4;
		esi = Mem0[esp + 0x00:word32];
		esp += 4;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
	}
	else
	{
		edx = ebx;
		edx -= (ebx + ~0x00014913)[eax * 0x04];
		SCZO = cond(edx);
		edx();
	}
}

// 0805EED8: define unix_lseek_64
define unix_lseek_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805EEEC<p32>;
	ebx += 83896;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 0x0C:word32];
	esi = Mem0[eax + 4:word32];
	edi = Mem0[eax + 8:word32];
	caml_enter_blocking_section();
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax = (ebx + ~0x24AF)[eax * 0x04];
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	lseek64();
	esi = eax;
	edi = edx;
	caml_leave_blocking_section();
	eax = esi;
	eax &= edi;
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24B5;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 0x00:word32] = esi;
	Mem0[esp + 4:word32] = edi;
	caml_copy_int64();
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805EF66: define unix_lseek
define unix_lseek
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805EF7A<p32>;
	ebx += 0x0001472A;
	SCZO = cond(ebx);
	caml_enter_blocking_section();
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax = (ebx + ~0x24AF)[eax * 0x04];
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	Mem0[esp + 8:word32] = edx;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	lseek64();
	edi = eax;
	esi = edx;
	caml_leave_blocking_section();
	eax = edi;
	eax &= esi;
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x24B5;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
l0805EFEC:
			Mem0[esp + 8:word32] = 0x00;
			eax = ebx + ~0x24B5;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = 0x4B;
			unix_error();
			goto l0805F00A;
		}
		SCZO = cond(edi - 0x3FFFFFFF);
		if (Test(UGT,CZ))
			goto l0805EFEC;
	}
l0805F00A:
	eax = edi + 1 + edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F01C: define unix_mkdir
define unix_mkdir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805F02D<p32>;
	ebx += 0x00014677;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	eax = mkdir(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x24A3;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F070: define unix_mkfifo
define unix_mkfifo
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805F081<p32>;
	ebx += 0x00014623;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	mkfifo();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + 4294957922;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F0C4: define unix_nice
define unix_nice
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805F0D5<p32>;
	ebx += 0x000145CF;
	eax = __errno_location();
	esi = eax;
	Mem0[eax + 0x00:word32] = 0x00;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	nice();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		SCZO = cond(Mem0[esi + 0x00:word32] - 0x00);
		if (Test(NE,Z))
		{
			Mem0[esp + 4:word32] = 0x00;
			eax = ebx + 4294957929;
			Mem0[esp + 0x00:word32] = eax;
			uerror();
		}
	}
	eax = eax + 1 + eax;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F124: define unix_open
define unix_open
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	ebx = 0x0805F132<p32>;
	ebx += 83314;
	SCZO = cond(ebx);
	eax = Mem0[ebx + -24:word32];
	edi = Mem0[eax + 0x00:word32];
	Mem0[ebp + -56:word32] = edi;
	edx = ebp - 56;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x03;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = ebp + 16;
	Mem0[ebp + -36:word32] = eax;
	eax = ebx + 0x94BC;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	Mem0[ebp + -60:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	++eax;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_alloc();
	esi = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	caml_enter_blocking_section();
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 8:word32] = eax;
	edx = Mem0[ebp + -60:word32];
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = esi;
	eax = open64(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:int32]);
	Mem0[ebp + -60:word32] = eax;
	caml_leave_blocking_section();
	Mem0[esp + 0x00:word32] = esi;
	caml_stat_free();
	SCZO = cond(Mem0[ebp + -60:word32] - ~0x00);
	if (Test(EQ,Z))
	{
		eax = Mem0[ebp + 8:word32];
		Mem0[esp + 4:word32] = eax;
		eax = ebx + ~0x2491;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = Mem0[ebx + -24:word32];
	Mem0[eax + 0x00:word32] = edi;
	edx = Mem0[ebp + -60:word32];
	eax = edx + 1 + edx;
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F208: define unix_opendir
define unix_opendir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805F21C<p32>;
	ebx += 0x00014488;
	edi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = edi;
	eax = opendir(Mem0[esp + 0x00:(ptr32 char)]);
	esi = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = edi;
		eax = ebx + ~0x248C;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 4:word32] = 0xFB;
	Mem0[esp + 0x00:word32] = 0x01;
	caml_alloc_small();
	Mem0[eax + 0x00:word32] = esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F268: define unix_pipe
define unix_pipe
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x0805F274<p32>;
	ebx += 82992;
	eax = ebp - 16;
	Mem0[esp + 0x00:word32] = eax;
	eax = pipe(Mem0[esp + 0x00:(ptr32 int32)]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2484;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	edx = Mem0[ebp + -16:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -0x0C:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 4:word32] = edx;
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F2D0: define unix_putenv
define unix_putenv
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805F2E4<p32>;
	ebx += 82880;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	edi = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	Mem0[ebp + -28:word32] = eax;
	eax += edi;
	Mem0[ebp + -32:word32] = eax;
	eax += 0x02;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_alloc();
	esi = eax;
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	Mem0[esi + edi:byte] = 0x3D;
	eax = Mem0[ebp + -28:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = esi + 1 + edi;
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	eax = Mem0[ebp + -32:word32];
	Mem0[esi + 1 + eax:byte] = 0x00;
	Mem0[esp + 0x00:word32] = esi;
	putenv();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		eax = Mem0[ebp + 8:word32];
		Mem0[esp + 4:word32] = eax;
		eax = ebx + ~0x247F;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F384: define unix_read
define unix_read
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4030;
	ebx = 0x0805F394<p32>;
	ebx += 0x00014310;
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + ~0x4027:word32] = edx;
	edx = ebp + ~0x4027;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + ~0x401F:word32] = 0x01;
	Mem0[ebp + ~0x4023:word32] = 0x01;
	eax = ebp + 0x0C;
	Mem0[ebp + ~0x401B:word32] = eax;
	esi = Mem0[ebp + 20:word32];
	esi >>= 0x01;
	SCZ = cond(esi);
	O = false;
	caml_enter_blocking_section();
	SCZO = cond(esi - 0x4000);
	eax = 0x4000;
	if (Test(GT,SZO))
		esi = eax;
	Mem0[esp + 8:word32] = esi;
	eax = ebp + ~0x4007;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	eax = read(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + 4294957959;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 8:word32] = esi;
	eax = ebp + ~0x4007;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	edx = Mem0[ebp + ~0x4027:word32];
	eax = Mem0[ebx + -24:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = esi + 1 + esi;
	esp += 0x4030;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F45C: define unix_readdir
define unix_readdir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805F468<p32>;
	ebx += 82492;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 0x00:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x2473;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x09;
		unix_error();
	}
	Mem0[esp + 0x00:word32] = eax;
	readdir64();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_end_of_file();
	eax += 0x13;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F4B8: define unix_readlink
define unix_readlink
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x1018;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805F4CC<p32>;
	ebx += 0x000141D8;
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 8:word32] = 0x0FFF;
	eax = ebp + ~0x1007;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	eax = readlink(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:size_t]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + 4294957972;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[ebp + ~0x1007 + eax:byte] = 0x00;
	eax = ebp + ~0x1007;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F528: define unix_rename
define unix_rename
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805F539<p32>;
	ebx += 82283;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	rename();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2462;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F578: define unix_rewinddir
define unix_rewinddir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805F584<p32>;
	ebx += 82208;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 0x00:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x245B;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x09;
		unix_error();
	}
	Mem0[esp + 0x00:word32] = eax;
	rewinddir();
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F5C4: define unix_rmdir
define unix_rmdir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805F5D5<p32>;
	ebx += 82127;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = esi;
	rmdir();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2451;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F60C: define fdlist_to_fdset
// Called from:
//      unix_select
define fdlist_to_fdset
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 0x04;
	SCZO = cond(esp);
	esi = eax;
	Mem0[ebp + -0x0C:word32] = edx;
	edi = edx;
	eax = 0x00;
	D = false;
	for (ecx = 0x20; ecx != 0x00; --ecx)
	{
		Mem0[edi + 0x00:word32] = eax;
		edi += 4;
	}
	SCZO = cond(esi - 0x01);
	if (Test(NE,Z))
	{
		edx = esi;
		do
		{
			edi = Mem0[edx + 0x00:word32];
			eax = edi;
			eax >>= 0x01;
			esi = eax + 31;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NS,S))
				esi = eax;
			esi >>= 0x05;
			edi >>= 0x1F;
			edi >>= 0x1B;
			ecx = eax + edi;
			ecx &= 0x1F;
			ecx -= edi;
			edi = 0x01;
			edi <<= cl;
			ecx = edi;
			edi = Mem0[ebp + -0x0C:word32];
			v20 = edi[esi * 0x04] | ecx;
			edi[esi * 0x04] = v20;
			SZ = cond(edi[esi * 0x04]);
			ecx = Mem0[ebp + 8:word32];
			SCZO = cond(eax - Mem0[ecx + 0x00:word32]);
			if (Test(GT,SZO))
				Mem0[ecx + 0x00:word32] = eax;
			edx = Mem0[edx + 4:word32];
			SCZO = cond(edx - 0x01);
		} while (Test(NE,Z));
	}
	esp += 0x04;
	SCZO = cond(esp);
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F675: define fdset_to_fdlist
// Called from:
//      unix_select
define fdset_to_fdlist
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	ebx = 0x0805F683<p32>;
	ebx += 0x00014021;
	edi = edx;
	Mem0[ebp + -32:word32] = 0x01;
	edx = Mem0[ebx + -24:word32];
	ecx = Mem0[edx + 0x00:word32];
	Mem0[ebp + -64:word32] = ecx;
	ecx = ebp - 64;
	Mem0[edx + 0x00:word32] = ecx;
	Mem0[ebp + -56:word32] = 0x01;
	Mem0[ebp + -60:word32] = 0x02;
	edx = ebp - 28;
	Mem0[ebp + -52:word32] = edx;
	edx = ebp - 32;
	Mem0[ebp + -48:word32] = edx;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		Mem0[ebp + -28:word32] = eax;
		while (true)
		{
			eax = Mem0[eax + 0x00:word32];
			esi = eax;
			esi >>= 0x01;
			edx = esi + 31;
			SZP = cond(esi & esi);
			O = false;
			C = false;
			if (Test(NS,S))
				edx = esi;
			edx >>= 0x05;
			eax >>= 0x1F;
			eax >>= 0x1B;
			ecx = esi + eax;
			ecx &= 0x1F;
			ecx -= eax;
			SCZO = cond(ecx);
			edx = edi[edx * 0x04];
			C = __bt<word32>(edx, ecx);
			if (Test(ULT,C))
			{
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = 0x02;
				caml_alloc_small();
				edx = esi + 1 + esi;
				Mem0[eax + 0x00:word32] = edx;
				edx = Mem0[ebp + -32:word32];
				Mem0[eax + 4:word32] = edx;
				Mem0[ebp + -32:word32] = eax;
			}
			eax = Mem0[ebp + -28:word32];
			eax = Mem0[eax + 4:word32];
			SCZO = cond(eax - 0x01);
			if (Test(EQ,Z))
				break;
			Mem0[ebp + -28:word32] = eax;
		}
	}
	edx = Mem0[ebp + -64:word32];
	eax = Mem0[ebx + -24:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = Mem0[ebp + -32:word32];
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F734: define unix_select
define unix_select
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x01E0;
	ebx = 0x0805F744<p32>;
	ebx += 0x00013F60;
	SCZO = cond(ebx);
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + -436:word32] = edx;
	edx = ebp - 0x01B4;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + -428:word32] = 0x01;
	Mem0[ebp + -432:word32] = 0x03;
	eax = ebp + 8;
	Mem0[ebp + -424:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -420:word32] = eax;
	eax = ebp + 16;
	Mem0[ebp + -416:word32] = eax;
	Mem0[ebp + -396:word32] = ~0x00;
	edx = ebp - 0x88;
	esi = ebp - 0x018C;
	Mem0[esp + 0x00:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	fdlist_to_fdset();
	edx = ebp - 0x0108;
	Mem0[esp + 0x00:word32] = esi;
	eax = Mem0[ebp + 0x0C:word32];
	fdlist_to_fdset();
	edx = ebp - 0x0188;
	Mem0[esp + 0x00:word32] = esi;
	eax = Mem0[ebp + 16:word32];
	fdlist_to_fdset();
	eax = Mem0[ebp + 20:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	esi = 0x00;
	--Top;
	ST[Top + 0x00:real64] = 0.0;
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	++Top;
	if (Test(ULE,CZ))
	{
		Mem0[ebp + -442:word16] = __fstcw();
		eax = CONVERT(Mem0[ebp + -442:word16], word16, word32);
		ah = 0x0C;
		Mem0[ebp + -444:word16] = ax;
		__fldcw(Mem0[ebp + -444:word16]);
		Mem0[ebp + -448:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
		__fldcw(Mem0[ebp + -442:word16]);
		eax = Mem0[ebp + -448:word32];
		Mem0[ebp + -404:word32] = eax;
		Mem0[ebp + -448:word32] = eax;
		--Top;
		ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -448:int32], int32, real64);
		ST[Top + 1:real64] -= ST[Top + 0x00:real64];
		++Top;
		ST[Top + 0x00:real64] *= CONVERT(Mem0[ebx + ~0x251B:real32], real32, real64);
		__fldcw(Mem0[ebp + -444:word16]);
		Mem0[ebp + -400:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
		++Top;
		__fldcw(Mem0[ebp + -442:word16]);
		esi = ebp - 404;
	}
	else
	{
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	caml_enter_blocking_section();
	Mem0[esp + 16:word32] = esi;
	eax = ebp - 0x0188;
	Mem0[esp + 0x0C:word32] = eax;
	eax = ebp - 0x0108;
	Mem0[esp + 8:word32] = eax;
	eax = ebp - 0x88;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -396:word32];
	++eax;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	select();
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x244B;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	edx = ebp - 0x88;
	eax = Mem0[ebp + 8:word32];
	fdset_to_fdlist();
	Mem0[ebp + 8:word32] = eax;
	edx = ebp - 0x0108;
	eax = Mem0[ebp + 0x0C:word32];
	fdset_to_fdlist();
	Mem0[ebp + 0x0C:word32] = eax;
	edx = ebp - 0x0188;
	eax = Mem0[ebp + 16:word32];
	fdset_to_fdlist();
	Mem0[ebp + 16:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x03;
	caml_alloc_small();
	edx = Mem0[ebp + 8:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + 0x0C:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[ebp + 16:word32];
	Mem0[eax + 8:word32] = edx;
	ecx = Mem0[ebp + -436:word32];
	edx = Mem0[ebx + -24:word32];
	Mem0[edx + 0x00:word32] = ecx;
	esp += 0x01E0;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805F910: define unix_sendto_native
// Called from:
//      unix_sendto
define unix_sendto_native
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x40BC;
	ebx = 0x0805F921<p32>;
	ebx += 0x00013D83;
	SCZO = cond(ebx);
	eax = ebx + 0x94EC;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 24:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	Mem0[ebp + ~0x409F:word32] = eax;
	eax = ebp + ~0x408B;
	Mem0[esp + 8:word32] = eax;
	esi = ebp + ~0x4087;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 28:word32];
	Mem0[esp + 0x00:word32] = eax;
	get_sockaddr();
	edi = Mem0[ebp + 20:word32];
	edi >>= 0x01;
	SCZO = cond(edi - 0x4000);
	eax = 0x4000;
	if (Test(GT,SZO))
		edi = eax;
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 0x0C:word32];
	SCZO = cond(eax);
	Mem0[esp + 4:word32] = eax;
	eax = ebp + ~0x4017;
	Mem0[ebp + ~0x409B:word32] = eax;
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	caml_enter_blocking_section();
	eax = Mem0[ebp + ~0x408B:word32];
	Mem0[esp + 20:word32] = eax;
	Mem0[esp + 16:word32] = esi;
	eax = Mem0[ebp + ~0x409F:word32];
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebp + ~0x409B:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	sendto();
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2444;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = esi + 1 + esi;
	esp += 0x40BC;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FA01: define unix_sendto
define unix_sendto
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x0805FA0D<p32>;
	ebx += 0x00013C97;
	SCZO = cond(ebx);
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 20:word32];
	Mem0[esp + 20:word32] = edx;
	edx = Mem0[eax + 16:word32];
	Mem0[esp + 16:word32] = edx;
	edx = Mem0[eax + 0x0C:word32];
	Mem0[esp + 0x0C:word32] = edx;
	edx = Mem0[eax + 8:word32];
	Mem0[esp + 8:word32] = edx;
	edx = Mem0[eax + 4:word32];
	Mem0[esp + 4:word32] = edx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	unix_sendto_native();
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FA49: define unix_send
define unix_send
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x4038;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x0805FA60<p32>;
	ebx += 0x00013C44;
	SCZO = cond(ebx);
	eax = ebx + 0x94EC;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 24:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	Mem0[ebp + ~0x401B:word32] = eax;
	esi = Mem0[ebp + 20:word32];
	esi >>= 0x01;
	SCZO = cond(esi - 0x4000);
	eax = 0x4000;
	if (Test(GT,SZO))
		esi = eax;
	Mem0[esp + 8:word32] = esi;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 0x0C:word32];
	SCZO = cond(eax);
	Mem0[esp + 4:word32] = eax;
	edi = ebp + ~0x4017;
	Mem0[esp + 0x00:word32] = edi;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	caml_enter_blocking_section();
	eax = Mem0[ebp + ~0x401B:word32];
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 8:word32] = esi;
	Mem0[esp + 4:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	send();
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x243D;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = esi + 1 + esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FB09: define unix_recvfrom
define unix_recvfrom
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x40CC;
	ebx = 0x0805FB1A<p32>;
	ebx += 80778;
	SCZO = cond(ebx);
	Mem0[ebp + ~0x401B:word32] = 0x01;
	eax = ebx + 0x94EC;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 24:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	edi = eax;
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + ~0x40AF:word32] = edx;
	edx = ebp + ~0x40AF;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + ~0x40A7:word32] = 0x01;
	Mem0[ebp + ~0x40AB:word32] = 0x02;
	eax = ebp + 0x0C;
	Mem0[ebp + ~0x40A3:word32] = eax;
	eax = ebp + ~0x401B;
	Mem0[ebp + ~0x409F:word32] = eax;
	esi = Mem0[ebp + 20:word32];
	esi >>= 0x01;
	SCZ = cond(esi);
	O = false;
	Mem0[ebp + ~0x408F:word32] = 0x70;
	caml_enter_blocking_section();
	eax = ebp + ~0x408F;
	Mem0[esp + 20:word32] = eax;
	eax = ebp + ~0x408B;
	Mem0[esp + 16:word32] = eax;
	Mem0[esp + 0x0C:word32] = edi;
	SCZO = cond(esi - 0x4000);
	eax = 0x4000;
	if (Test(GT,SZO))
		esi = eax;
	Mem0[esp + 8:word32] = esi;
	eax = ebp + ~0x4017;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	recvfrom();
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2438;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 8:word32] = esi;
	eax = ebp + ~0x4017;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 0x0C:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	Mem0[esp + 8:word32] = ~0x00;
	eax = Mem0[ebp + ~0x408F:word32];
	Mem0[esp + 4:word32] = eax;
	eax = ebp + ~0x408B;
	Mem0[esp + 0x00:word32] = eax;
	alloc_sockaddr();
	Mem0[ebp + ~0x401B:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	edx = esi + 1 + esi;
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + ~0x401B:word32];
	Mem0[eax + 4:word32] = edx;
	ecx = Mem0[ebp + ~0x40AF:word32];
	edx = Mem0[ebx + -24:word32];
	Mem0[edx + 0x00:word32] = ecx;
	esp += 0x40CC;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FC77: define unix_recv
define unix_recv
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 16444;
	ebx = 0x0805FC88<p32>;
	ebx += 0x00013A1C;
	SCZO = cond(ebx);
	eax = ebx + 0x94EC;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 24:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	edi = eax;
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + ~0x4037:word32] = edx;
	edx = ebp + ~0x4037;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + ~0x402F:word32] = 0x01;
	Mem0[ebp + ~0x4033:word32] = 0x01;
	eax = ebp + 0x0C;
	Mem0[ebp + ~0x402B:word32] = eax;
	esi = Mem0[ebp + 20:word32];
	esi >>= 0x01;
	SCZ = cond(esi);
	O = false;
	caml_enter_blocking_section();
	Mem0[esp + 0x0C:word32] = edi;
	SCZO = cond(esi - 0x4000);
	eax = 0x4000;
	if (Test(GT,SZO))
		esi = eax;
	Mem0[esp + 8:word32] = esi;
	eax = ebp + ~0x4017;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	recv();
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x242F;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 8:word32] = esi;
	eax = ebp + ~0x4017;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	edx = Mem0[ebp + ~0x4037:word32];
	eax = Mem0[ebx + -24:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = esi + 1 + esi;
	esp += 16444;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FD6C: define unix_setgid
define unix_setgid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805FD78<p32>;
	ebx += 0x0001392C;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	setgid();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x242A;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FDB4: define unix_setgroups
define unix_setgroups
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	ebx = 0x0805FDC2<p32>;
	ebx += 80098;
	esi = Mem0[ebp + 8:word32];
	edi = Mem0[esi + -4:word32];
	edi >>= 0x0A;
	SCZO = cond(edi);
	eax = 0x00 + edi * 0x04;
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_alloc();
	Mem0[ebp + -28:word32] = eax;
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edx = 0x00;
		do
		{
			ecx = esi[edx * 0x04];
			ecx >>= 0x01;
			eax[edx * 0x04] = ecx;
			++edx;
			SCZO = cond(edi - edx);
		} while (Test(UGT,CZ));
	}
	eax = Mem0[ebp + -28:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = edi;
	setgroups();
	esi = eax;
	eax = Mem0[ebp + -28:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_free();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2423;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FE40: define unix_setsid
define unix_setsid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = 0x0805FE4C<p32>;
	ebx += 0x00013858;
	SCZO = cond(ebx);
	setsid();
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FE64: define unix_setuid
define unix_setuid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805FE70<p32>;
	ebx += 0x00013834;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	setuid();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2419;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FEAC: define unix_shutdown
define unix_shutdown
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0805FEB8<p32>;
	ebx += 0x000137EC;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	eax = (ebx + ~0x2407)[eax * 0x04];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	shutdown();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2412;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FF10: define decode_sigset
// Called from:
//      unix_sigsuspend
//      unix_sigprocmask
define decode_sigset
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	ebx = 0x0805FF1E<p32>;
	ebx += 79750;
	esi = eax;
	edi = edx;
	Mem0[esp + 0x00:word32] = edx;
	eax = sigemptyset(Mem0[esp + 0x00:(ptr32 sigset_t)]);
	SCZO = cond(esi - 0x01);
	while (Test(NE,Z))
	{
		eax = Mem0[esi + 0x00:word32];
		eax >>= 0x01;
		SCZ = cond(eax);
		O = false;
		Mem0[esp + 0x00:word32] = eax;
		caml_convert_signal_number();
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edi;
		eax = sigaddset(Mem0[esp + 0x00:(ptr32 sigset_t)], Mem0[esp + 4:int32]);
		esi = Mem0[esi + 4:word32];
		SCZO = cond(esi - 0x01);
	}
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FF5D: define unix_sigsuspend
define unix_sigsuspend
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x98;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0805FF71<p32>;
	ebx += 0x00013733;
	SCZO = cond(ebx);
	esi = ebp - 0x88;
	edx = esi;
	eax = Mem0[ebp + 8:word32];
	decode_sigset();
	caml_enter_blocking_section();
	Mem0[esp + 0x00:word32] = esi;
	sigsuspend();
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		eax = __errno_location();
		SCZO = cond(Mem0[eax + 0x00:word32] - 0x04);
		if (Test(NE,Z))
		{
			Mem0[esp + 4:word32] = 0x00;
			eax = ebx + ~0x23FB;
			Mem0[esp + 0x00:word32] = eax;
			uerror();
		}
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0805FFCF: define encode_sigset
// Called from:
//      unix_sigpending
//      unix_sigprocmask
define encode_sigset
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x5C;
	ebx = 0x0805FFDD<p32>;
	ebx += 79559;
	SCZO = cond(ebx);
	Mem0[ebp + -76:word32] = eax;
	Mem0[ebp + -28:word32] = 0x01;
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + -60:word32] = edx;
	edx = ebp - 60;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + -52:word32] = 0x01;
	Mem0[ebp + -56:word32] = 0x01;
	eax = ebp - 28;
	Mem0[ebp + -48:word32] = eax;
	esi = 0x01;
	do
	{
		Mem0[esp + 4:word32] = esi;
		eax = Mem0[ebp + -76:word32];
		Mem0[esp + 0x00:word32] = eax;
		eax = sigismember(Mem0[esp + 0x00:(ptr32 sigset_t)], Mem0[esp + 4:int32]);
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
			Mem0[esp + 4:word32] = 0x00;
			Mem0[esp + 0x00:word32] = 0x02;
			caml_alloc_small();
			edi = eax;
			Mem0[esp + 0x00:word32] = esi;
			caml_rev_convert_signal_number();
			eax = eax + 1 + eax;
			Mem0[edi + 0x00:word32] = eax;
			eax = Mem0[ebp + -28:word32];
			Mem0[edi + 4:word32] = eax;
			Mem0[ebp + -28:word32] = edi;
		}
		++esi;
		SCZO = cond(esi - 0x41);
	} while (Test(NE,Z));
	edx = Mem0[ebp + -60:word32];
	eax = Mem0[ebx + -24:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = Mem0[ebp + -28:word32];
	esp += 0x5C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060074: define unix_sigpending
define unix_sigpending
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x94;
	ebx = 0x08060083<p32>;
	ebx += 79393;
	SCZO = cond(ebx);
	eax = ebp - 0x88;
	Mem0[esp + 0x00:word32] = eax;
	sigpending();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x23F0;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = ebp - 0x88;
	encode_sigset();
	esp += 0x94;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080600C6: define unix_sigprocmask
define unix_sigprocmask
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x0128;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x080600DD<p32>;
	ebx += 79303;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	edi = (ebx + ~0x23D7)[eax * 0x04];
	esi = ebp - 0x98;
	edx = esi;
	eax = Mem0[ebp + 0x0C:word32];
	decode_sigset();
	caml_enter_blocking_section();
	eax = ebp - 0x0118;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = edi;
	eax = sigprocmask(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 sigset_t)], Mem0[esp + 8:(ptr32 sigset_t)]);
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x23E5;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = ebp - 0x0118;
	encode_sigset();
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060154: define unix_sleep
define unix_sleep
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x08060160<p32>;
	ebx += 0x00013544;
	SCZO = cond(ebx);
	caml_enter_blocking_section();
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	eax = sleep(Mem0[esp + 0x00:uint32]);
	caml_leave_blocking_section();
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060188: define unix_socket
define unix_socket
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x08060194<p32>;
	ebx += 0x00013510;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	Mem0[esp + 8:word32] = eax;
	edx = Mem0[ebp + 0x0C:word32];
	edx >>= 0x01;
	eax = Mem0[ebx + -28:word32];
	eax = eax[edx * 0x04];
	Mem0[esp + 4:word32] = eax;
	edx = Mem0[ebp + 8:word32];
	edx >>= 0x01;
	eax = Mem0[ebx + -32:word32];
	eax = eax[edx * 0x04];
	Mem0[esp + 0x00:word32] = eax;
	eax = socket(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32], Mem0[esp + 8:int32]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x23CB;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = eax + 1 + eax;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080601F0: define get_sockaddr
// Called from:
//      unix_bind
//      unix_connect
//      unix_getnameinfo
//      unix_sendto_native
define get_sockaddr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x08060204<p32>;
	ebx += 79008;
	eax = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	edi = eax;
	edx = CONVERT(Mem0[eax + -4:byte], byte, word32);
	SZP = cond(dl & dl);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(dl - 0x01);
		if (Test(EQ,Z))
		{
			Mem0[ebp + -28:word32] = eax;
			eax = Mem0[eax + 0x00:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_string_length();
			SCZO = cond(eax - 0x10);
			if (Test(EQ,Z))
			{
				edx = esi;
				ecx = 0x00;
				al = 0x00;
				do
				{
					Mem0[edx + eax:word32] = ecx;
					eax += 0x04;
					SCZO = cond(eax - 0x1C);
				} while (Test(ULT,C));
				Mem0[esi + 0x00:word16] = 0x0A;
				edx = Mem0[ebp + -28:word32];
				eax = Mem0[edx + 0x00:word32];
				edx = Mem0[eax + 0x00:word32];
				Mem0[esi + 8:word32] = edx;
				edx = Mem0[eax + 4:word32];
				Mem0[esi + 0x0C:word32] = edx;
				edx = Mem0[eax + 8:word32];
				Mem0[esi + 16:word32] = edx;
				eax = Mem0[eax + 0x0C:word32];
				Mem0[esi + 20:word32] = eax;
				eax = Mem0[edi + 4:word32];
				eax >>= 0x01;
				SCZ = cond(eax);
				O = false;
				v20 = (ax & 0x01 << 0x08) != 0x00;
				ax = __ror<word16,byte>(ax, 0x08);
				C = v20;
				Mem0[esi + 2:word16] = ax;
				eax = Mem0[ebp + 16:word32];
				Mem0[eax + 0x00:word32] = 0x1C;
			}
			else
			{
				Mem0[esi + 0x00:word32] = 0x00;
				Mem0[esi + 4:word32] = 0x00;
				Mem0[esi + 8:word32] = 0x00;
				Mem0[esi + 0x0C:word32] = 0x00;
				Mem0[esi + 0x00:word16] = 0x02;
				edx = Mem0[ebp + -28:word32];
				eax = Mem0[edx + 0x00:word32];
				eax = Mem0[eax + 0x00:word32];
				Mem0[esi + 4:word32] = eax;
				eax = Mem0[edi + 4:word32];
				eax >>= 0x01;
				SCZ = cond(eax);
				O = false;
				v22 = (ax & 0x01 << 0x08) != 0x00;
				ax = __ror<word16,byte>(ax, 0x08);
				C = v22;
				Mem0[esi + 2:word16] = ax;
				eax = Mem0[ebp + 16:word32];
				Mem0[eax + 0x00:word32] = 0x10;
			}
		}
	}
	else
	{
		eax = Mem0[eax + 0x00:word32];
		Mem0[ebp + -28:word32] = eax;
		Mem0[esp + 0x00:word32] = eax;
		caml_string_length();
		edi = eax;
		Mem0[esi + 0x00:word16] = 0x01;
		SCZO = cond(eax - 0x6B);
		if (Test(UGT,CZ))
		{
			eax = Mem0[ebp + -28:word32];
			Mem0[esp + 8:word32] = eax;
			eax = ebx + ~0x147B;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = 0x24;
			unix_error();
		}
		++eax;
		Mem0[esp + 8:word32] = eax;
		edx = Mem0[ebp + -28:word32];
		Mem0[esp + 4:word32] = edx;
		esi += 0x02;
		Mem0[esp + 0x00:word32] = esi;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		edi += 0x02;
		SCZO = cond(edi);
		eax = Mem0[ebp + 16:word32];
		Mem0[eax + 0x00:word32] = edi;
	}
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806032D: define alloc_inet6_addr
// Called from:
//      unix_inet_addr_of_string
//      alloc_one_addr
//      alloc_sockaddr
define alloc_inet6_addr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0806033E<p32>;
	ebx += 0x00013366;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = 0x10;
	caml_alloc_string();
	edx = Mem0[esi + 0x00:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[esi + 4:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[esi + 8:word32];
	Mem0[eax + 8:word32] = edx;
	edx = Mem0[esi + 0x0C:word32];
	Mem0[eax + 0x0C:word32] = edx;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060373: define alloc_inet_addr
// Called from:
//      unix_inet_addr_of_string
//      alloc_one_addr
//      alloc_sockaddr
define alloc_inet_addr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x0806037F<p32>;
	ebx += 0x00013325;
	SCZO = cond(ebx);
	Mem0[esp + 0x00:word32] = 0x04;
	caml_alloc_string();
	edx = Mem0[ebp + 8:word32];
	edx = Mem0[edx + 0x00:word32];
	Mem0[eax + 0x00:word32] = edx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806039E: define alloc_sockaddr
// Called from:
//      unix_accept
//      unix_getaddrinfo
//      unix_getpeername
//      unix_getsockname
//      unix_recvfrom
define alloc_sockaddr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 88;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x080603B2<p32>;
	ebx += 78578;
	esi = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 16:word32];
	eax = CONVERT(Mem0[esi + 0x00:word16], word16, word32);
	SCZO = cond(ax - 0x02);
	if (Test(NE,Z))
	{
		SCZO = cond(ax - 0x0A);
		if (Test(NE,Z))
		{
			SCZO = cond(ax - 0x01);
			if (Test(EQ,Z))
			{
				esi += 0x02;
				SCZO = cond(esi);
				Mem0[esp + 0x00:word32] = esi;
				caml_copy_string();
				Mem0[ebp + -28:word32] = eax;
				esi = Mem0[ebx + -24:word32];
				eax = Mem0[esi + 0x00:word32];
				Mem0[ebp + -60:word32] = eax;
				eax = ebp - 60;
				Mem0[esi + 0x00:word32] = eax;
				Mem0[ebp + -52:word32] = 0x01;
				Mem0[ebp + -56:word32] = 0x01;
				eax = ebp - 28;
				Mem0[ebp + -48:word32] = eax;
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = 0x01;
				caml_alloc_small();
				edx = Mem0[ebp + -28:word32];
				Mem0[eax + 0x00:word32] = edx;
				edx = Mem0[ebp + -60:word32];
				Mem0[esi + 0x00:word32] = edx;
			}
			else
			{
				SCZO = cond(edx - ~0x00);
				if (Test(NE,Z))
				{
					Mem0[esp + 0x00:word32] = edx;
					eax = close(Mem0[esp + 0x00:int32]);
				}
				Mem0[esp + 8:word32] = 0x00;
				eax = ebx + ~0x147B;
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = 0x61;
				unix_error();
			}
		}
		else
		{
			eax = esi + 8;
			Mem0[esp + 0x00:word32] = eax;
			alloc_inet6_addr();
			Mem0[ebp + -28:word32] = eax;
			edi = Mem0[ebx + -24:word32];
			eax = Mem0[edi + 0x00:word32];
			Mem0[ebp + -60:word32] = eax;
			eax = ebp - 60;
			Mem0[edi + 0x00:word32] = eax;
			Mem0[ebp + -52:word32] = 0x01;
			Mem0[ebp + -56:word32] = 0x01;
			eax = ebp - 28;
			Mem0[ebp + -48:word32] = eax;
			Mem0[esp + 4:word32] = 0x01;
			Mem0[esp + 0x00:word32] = 0x02;
			caml_alloc_small();
			edx = Mem0[ebp + -28:word32];
			Mem0[eax + 0x00:word32] = edx;
			edx = CONVERT(Mem0[esi + 2:word16], word16, word32);
			v16 = (dx & 0x01 << 0x08) != 0x00;
			dx = __ror<word16,byte>(dx, 0x08);
			C = v16;
			edx = CONVERT(dx, word16, word32);
			edx = edx + 1 + edx;
			Mem0[eax + 4:word32] = edx;
			edx = Mem0[ebp + -60:word32];
			Mem0[edi + 0x00:word32] = edx;
		}
	}
	else
	{
		eax = esi + 4;
		Mem0[esp + 0x00:word32] = eax;
		alloc_inet_addr();
		Mem0[ebp + -28:word32] = eax;
		edi = Mem0[ebx + -24:word32];
		eax = Mem0[edi + 0x00:word32];
		Mem0[ebp + -60:word32] = eax;
		eax = ebp - 60;
		Mem0[edi + 0x00:word32] = eax;
		Mem0[ebp + -52:word32] = 0x01;
		Mem0[ebp + -56:word32] = 0x01;
		eax = ebp - 28;
		Mem0[ebp + -48:word32] = eax;
		Mem0[esp + 4:word32] = 0x01;
		Mem0[esp + 0x00:word32] = 0x02;
		caml_alloc_small();
		edx = Mem0[ebp + -28:word32];
		Mem0[eax + 0x00:word32] = edx;
		edx = CONVERT(Mem0[esi + 2:word16], word16, word32);
		v13 = (dx & 0x01 << 0x08) != 0x00;
		dx = __ror<word16,byte>(dx, 0x08);
		C = v13;
		edx = CONVERT(dx, word16, word32);
		edx = edx + 1 + edx;
		Mem0[eax + 4:word32] = edx;
		edx = Mem0[ebp + -60:word32];
		Mem0[edi + 0x00:word32] = edx;
	}
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060534: define unix_socketpair
define unix_socketpair
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x08060540<p32>;
	ebx += 0x00013164;
	eax = ebp - 16;
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	Mem0[esp + 8:word32] = eax;
	edx = Mem0[ebp + 0x0C:word32];
	edx >>= 0x01;
	eax = Mem0[ebx + -28:word32];
	eax = eax[edx * 0x04];
	Mem0[esp + 4:word32] = eax;
	edx = Mem0[ebp + 8:word32];
	edx >>= 0x01;
	SCZ = cond(edx);
	O = false;
	eax = Mem0[ebx + -32:word32];
	eax = eax[edx * 0x04];
	Mem0[esp + 0x00:word32] = eax;
	socketpair();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x23C4;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	edx = Mem0[ebp + -16:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -0x0C:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 4:word32] = edx;
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080605D0: define unix_setsockopt_aux
// Called from:
//      unix_setsockopt
define unix_setsockopt_aux
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x40;
	ebx = 0x080605DD<p32>;
	ebx += 0x000130C7;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[ebp + 28:word32];
	SCZO = cond(eax - 0x02);
	if (Test(NE,Z))
	{
		SCZO = cond(eax - 0x02);
		if (Test(UGE,C))
		{
			SCZO = cond(eax - 0x03);
			if (Test(EQ,Z))
			{
				esi = esi;
				--Top;
				ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
				Mem0[ebp + -26:word16] = __fstcw();
				eax = CONVERT(Mem0[ebp + -26:word16], word16, word32);
				ah = 0x0C;
				Mem0[ebp + -28:word16] = ax;
				__fldcw(Mem0[ebp + -28:word16]);
				Mem0[ebp + -32:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
				__fldcw(Mem0[ebp + -26:word16]);
				eax = Mem0[ebp + -32:word32];
				Mem0[ebp + -16:word32] = eax;
				Mem0[ebp + -32:word32] = eax;
				--Top;
				ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -32:int32], int32, real64);
				ST[Top + 1:real64] -= ST[Top + 0x00:real64];
				++Top;
				ST[Top + 0x00:real64] *= CONVERT(Mem0[ebx + ~0x251B:real32], real32, real64);
				__fldcw(Mem0[ebp + -28:word16]);
				Mem0[ebp + -0x0C:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
				++Top;
				__fldcw(Mem0[ebp + -26:word16]);
				eax = 0x08;
			}
			else
			{
				Mem0[esp + 8:word32] = 0x00;
				Mem0[esp + 4:word32] = esi;
				Mem0[esp + 0x00:word32] = 22;
				unix_error();
			}
		}
		else
		{
			edx >>= 0x01;
			SCZ = cond(edx);
			O = false;
			Mem0[ebp + -16:word32] = edx;
			eax = 0x04;
		}
	}
	else
	{
		ecx = edx;
		ecx = ecx ^ 0x01;
		ecx &= 0x01;
		Mem0[ebp + -16:word32] = ecx;
		eax = 0x08;
		SZP = cond(ecx & ecx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			eax = Mem0[edx + 0x00:word32];
			eax >>= 0x01;
			SCZ = cond(eax);
			O = false;
			Mem0[ebp + -0x0C:word32] = eax;
			eax = 0x08;
		}
	}
	Mem0[esp + 16:word32] = eax;
	eax = ebp - 16;
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[ebp + 20:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 24:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	setsockopt();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = esi;
		uerror();
	}
	eax = 0x01;
	esp += 0x40;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080606CB: define unix_setsockopt
define unix_setsockopt
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x080606D7<p32>;
	ebx += 77773;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	edx = Mem0[ebp + 16:word32];
	edx >>= 0x01;
	edx <<= 0x03;
	edx += (ebx - 0x0138)[eax * 0x04];
	SCZO = cond(edx);
	ecx = Mem0[ebp + 20:word32];
	Mem0[esp + 20:word32] = ecx;
	ecx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 16:word32] = ecx;
	ecx = Mem0[edx + 4:word32];
	Mem0[esp + 0x0C:word32] = ecx;
	edx = Mem0[edx + 0x00:word32];
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 4:word32] = eax;
	eax = (ebx - 292)[eax * 0x04];
	Mem0[esp + 0x00:word32] = eax;
	unix_setsockopt_aux();
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060725: define unix_getsockopt_aux
// Called from:
//      unix_getsockopt
define unix_getsockopt_aux
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x68;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x08060739<p32>;
	ebx += 77675;
	edi = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	SCZO = cond(esi - 0x04);
	if (Test(UGT,CZ))
	{
		Mem0[esp + 8:word32] = 0x00;
		Mem0[esp + 4:word32] = edi;
		Mem0[esp + 0x00:word32] = 22;
		unix_error();
		eax = ebp - 36;
		Mem0[esp + 16:word32] = eax;
		eax = ebp - 32;
		Mem0[esp + 0x0C:word32] = eax;
		eax = Mem0[ebp + 20:word32];
		Mem0[esp + 8:word32] = eax;
		eax = Mem0[ebp + 16:word32];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebp + 24:word32];
		eax >>= 0x01;
		SCZ = cond(eax);
		O = false;
		Mem0[esp + 0x00:word32] = eax;
		getsockopt();
		SCZO = cond(eax - ~0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 4:word32] = 0x00;
			Mem0[esp + 0x00:word32] = edi;
			uerror();
		}
		SCZO = cond(esi - 0x04);
		if (Test(UGT,CZ))
		{
			Mem0[esp + 8:word32] = 0x00;
			Mem0[esp + 4:word32] = edi;
			Mem0[esp + 0x00:word32] = 22;
			unix_error();
			eax = 0x01;
			ebx = Mem0[ebp + -0x0C:word32];
			esi = Mem0[ebp + -8:word32];
			edi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
		}
		else
		{
			eax = ebx;
			eax -= (ebx + 4294889808)[esi * 0x04];
			SCZO = cond(eax);
			eax();
		}
	}
	else
	{
		eax = ebx;
		eax -= (ebx + ~0x00012F4B)[esi * 0x04];
		SCZO = cond(eax);
		eax();
	}
}

// 080608D8: define unix_getsockopt
define unix_getsockopt
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x080608E4<p32>;
	ebx += 77248;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	edx = Mem0[ebp + 16:word32];
	edx >>= 0x01;
	edx <<= 0x03;
	edx += (ebx - 0x0138)[eax * 0x04];
	SCZO = cond(edx);
	ecx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 16:word32] = ecx;
	ecx = Mem0[edx + 4:word32];
	Mem0[esp + 0x0C:word32] = ecx;
	edx = Mem0[edx + 0x00:word32];
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 4:word32] = eax;
	eax = (ebx - 0x0110)[eax * 0x04];
	Mem0[esp + 0x00:word32] = eax;
	unix_getsockopt_aux();
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806092C: define stat_aux
// Called from:
//      unix_fstat_64
//      unix_lstat_64
//      unix_stat_64
//      unix_fstat
//      unix_lstat
//      unix_stat
define stat_aux
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x6C;
	ebx = 0x0806093A<p32>;
	ebx += 77162;
	SCZO = cond(ebx);
	Mem0[ebp + -92:word32] = eax;
	esi = edx;
	eax = Mem0[ebx + -24:word32];
	edi = Mem0[eax + 0x00:word32];
	Mem0[ebp + -28:word32] = 0x00;
	Mem0[ebp + -32:word32] = 0x00;
	Mem0[ebp + -36:word32] = 0x00;
	Mem0[ebp + -40:word32] = 0x00;
	Mem0[ebp + -44:word32] = 0x00;
	Mem0[ebp + -76:word32] = edi;
	edx = ebp - 76;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + -0x0044:word32] = 0x01;
	Mem0[ebp + -72:word32] = 0x05;
	eax = ebp - 28;
	Mem0[ebp + -64:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -60:word32] = eax;
	eax = ebp - 36;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 40;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 44;
	Mem0[ebp + -48:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[esi + 64:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[ebp + -28:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[esi + 72:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[ebp + -32:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[esi + 80:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[ebp + -36:word32] = eax;
	SCZO = cond(Mem0[ebp + -92:word32] - 0x00);
	if (Test(NE,Z))
	{
		eax = Mem0[esi + 44:word32];
		edx = Mem0[esi + 48:word32];
		Mem0[esp + 0x00:word32] = eax;
		Mem0[esp + 4:word32] = edx;
		caml_copy_int64();
	}
	else
	{
		eax = Mem0[esi + 44:word32];
		eax = eax + 1 + eax;
	}
	Mem0[ebp + -40:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x0C;
	caml_alloc_small();
	Mem0[ebp + -44:word32] = eax;
	edx = Mem0[esi + 0x00:word32];
	edx = edx + 1 + edx;
	Mem0[eax + 0x00:word32] = edx;
	eax = Mem0[esi + 88:word32];
	edx = eax + 1 + eax;
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 4:word32] = edx;
	eax = Mem0[ebp + -44:word32];
	eax += 0x08;
	Mem0[ebp + -92:word32] = eax;
	Mem0[esp + 0x0C:word32] = 0x00;
	Mem0[esp + 8:word32] = 0x07;
	eax = ebx + 38348;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[esi + 16:word32];
	eax &= 0xF000;
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = eax;
	cst_to_constr();
	edx = Mem0[ebp + -92:word32];
	Mem0[edx + 0x00:word32] = eax;
	eax = Mem0[esi + 16:word32];
	eax &= 0x0FFF;
	edx = eax + 1 + eax;
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 0x0C:word32] = edx;
	eax = Mem0[esi + 20:word32];
	edx = eax + 1 + eax;
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 16:word32] = edx;
	eax = Mem0[esi + 24:word32];
	edx = eax + 1 + eax;
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 20:word32] = edx;
	eax = Mem0[esi + 28:word32];
	edx = eax + 1 + eax;
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 24:word32] = edx;
	eax = Mem0[esi + 32:word32];
	edx = eax + 1 + eax;
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 28:word32] = edx;
	edx = Mem0[ebp + -40:word32];
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 32:word32] = edx;
	edx = Mem0[ebp + -28:word32];
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 36:word32] = edx;
	edx = Mem0[ebp + -32:word32];
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 40:word32] = edx;
	edx = Mem0[ebp + -36:word32];
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 44:word32] = edx;
	eax = Mem0[ebx + -24:word32];
	Mem0[eax + 0x00:word32] = edi;
	eax = Mem0[ebp + -44:word32];
	esp += 0x6C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060AD3: define unix_fstat_64
define unix_fstat_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 116;
	ebx = 0x08060ADF<p32>;
	ebx += 76741;
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x03;
	__fxstat64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x231D;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	edx = ebp - 0x0068;
	eax = 0x01;
	stat_aux();
	esp += 116;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060B2F: define unix_lstat_64
define unix_lstat_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x08060B40<p32>;
	ebx += 76644;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = 0x03;
	__lxstat64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2317;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	edx = ebp - 0x0068;
	eax = 0x01;
	stat_aux();
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060B8E: define unix_stat_64
define unix_stat_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x08060B9F<p32>;
	ebx += 0x00012B05;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = 0x03;
	__xstat64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x231C;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	edx = ebp - 0x0068;
	eax = 0x01;
	stat_aux();
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060BED: define unix_fstat
define unix_fstat
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 116;
	ebx = 0x08060BF9<p32>;
	ebx += 0x00012AAB;
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x03;
	__fxstat64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x231D;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	SCZO = cond(Mem0[ebp + -56:word32] - 0x00);
	if (Test(NS,S))
	{
		SCZO = cond(Mem0[ebp + -56:word32] - 0x00);
		if (Test(GT,SZO))
		{
l08060C4B:
			eax = Mem0[ebp + -88:word32];
			eax &= 0xF000;
			SCZO = cond(eax - 0x8000);
			if (Test(EQ,Z))
			{
				Mem0[esp + 8:word32] = 0x00;
				eax = ebx + ~0x231D;
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = 0x4B;
				unix_error();
			}
			goto l08060C78;
		}
		SCZO = cond(Mem0[ebp + -60:word32] - 0x3FFFFFFF);
		if (Test(UGT,CZ))
			goto l08060C4B;
	}
l08060C78:
	edx = ebp - 0x0068;
	eax = 0x00;
	stat_aux();
	esp += 116;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060C8B: define unix_lstat
define unix_lstat
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x70;
	ebx = 0x08060C98<p32>;
	ebx += 76300;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = 0x03;
	__lxstat64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2317;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	SCZO = cond(Mem0[ebp + -56:word32] - 0x00);
	if (Test(NS,S))
	{
		SCZO = cond(Mem0[ebp + -56:word32] - 0x00);
		if (Test(GT,SZO))
		{
l08060CE4:
			eax = Mem0[ebp + -88:word32];
			eax &= 0xF000;
			SCZO = cond(eax - 0x8000);
			if (Test(EQ,Z))
			{
				Mem0[esp + 8:word32] = esi;
				eax = ebx + ~0x2317;
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = 0x4B;
				unix_error();
			}
			goto l08060D0D;
		}
		SCZO = cond(Mem0[ebp + -60:word32] - 0x3FFFFFFF);
		if (Test(UGT,CZ))
			goto l08060CE4;
	}
l08060D0D:
	edx = ebp - 0x0068;
	eax = 0x00;
	stat_aux();
	esp += 0x70;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060D21: define unix_stat
define unix_stat
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x70;
	ebx = 0x08060D2E<p32>;
	ebx += 0x00012976;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = 0x03;
	__xstat64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x231C;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	SCZO = cond(Mem0[ebp + -56:word32] - 0x00);
	if (Test(NS,S))
	{
		SCZO = cond(Mem0[ebp + -56:word32] - 0x00);
		if (Test(GT,SZO))
		{
l08060D7A:
			eax = Mem0[ebp + -88:word32];
			eax &= 0xF000;
			SCZO = cond(eax - 0x8000);
			if (Test(EQ,Z))
			{
				Mem0[esp + 8:word32] = esi;
				eax = ebx + ~0x231C;
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = 0x4B;
				unix_error();
			}
			goto l08060DA3;
		}
		SCZO = cond(Mem0[ebp + -60:word32] - 0x3FFFFFFF);
		if (Test(UGT,CZ))
			goto l08060D7A;
	}
l08060DA3:
	edx = ebp - 0x0068;
	eax = 0x00;
	stat_aux();
	esp += 0x70;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060DB8: define unix_string_of_inet_addr
define unix_string_of_inet_addr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x50;
	ebx = 0x08060DC5<p32>;
	ebx += 75999;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = esi;
	caml_string_length();
	SCZO = cond(eax - 0x10);
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x0C:word32] = 0x40;
		eax = ebp - 72;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = esi;
		Mem0[esp + 0x00:word32] = 0x0A;
		eax = inet_ntop(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:(ptr32 char)], Mem0[esp + 0x0C:socklen_t]);
	}
	else
	{
		Mem0[esp + 0x0C:word32] = 0x40;
		eax = ebp - 72;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = esi;
		Mem0[esp + 0x00:word32] = 0x02;
		eax = inet_ntop(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:(ptr32 char)], Mem0[esp + 0x0C:socklen_t]);
	}
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2311;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	esp += 0x50;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060E44: define unix_symlink
define unix_symlink
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x08060E55<p32>;
	ebx += 75855;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	symlink();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x22FD;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060EA0: define unix_tcflow
define unix_tcflow
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x08060EAC<p32>;
	ebx += 75768;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	eax = (ebx + ~0x22A3)[eax * 0x04];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	tcflow();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x22F5;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060EF5: define unix_tcflush
define unix_tcflush
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x08060F01<p32>;
	ebx += 0x000127A3;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	eax = (ebx + 4294958444)[eax * 0x04];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	tcflush();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x22EE;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060F4A: define unix_tcdrain
define unix_tcdrain
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x08060F56<p32>;
	ebx += 75598;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	tcdrain();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x22E6;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060F8F: define unix_tcsendbreak
define unix_tcsendbreak
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x08060F9B<p32>;
	ebx += 75529;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	tcsendbreak();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x22DE;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08060FDD: define unix_tcsetattr
define unix_tcsetattr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x3C;
	ebx = 0x08060FEB<p32>;
	ebx += 75449;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[ebp + -40:word32] = eax;
	eax = ebx + 0x9A7C;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -40:word32];
	Mem0[esp + 0x00:word32] = eax;
	tcgetattr();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x22D2;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = Mem0[ebx + 38396:word32];
	SCZO = cond(eax - 0x04);
	if (Test(EQ,Z))
	{
l080611C4:
		eax = ebx + 0x9A7C;
		Mem0[esp + 8:word32] = eax;
		eax = Mem0[ebp + 0x0C:word32];
		eax >>= 0x01;
		eax = (ebx + ~0x2287)[eax * 0x04];
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebp + -40:word32];
		Mem0[esp + 0x00:word32] = eax;
		eax = tcsetattr(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32], Mem0[esp + 8:(ptr32 (struct "termios"))]);
		SCZO = cond(eax - ~0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 4:word32] = 0x00;
			eax = ebx + ~0x22D2;
			Mem0[esp + 0x00:word32] = eax;
			uerror();
		}
		eax = 0x01;
		esp += 0x3C;
		SCZO = cond(esp);
		ebx = Mem0[esp + 0x00:word32];
		esp += 4;
		esi = Mem0[esp + 0x00:word32];
		esp += 4;
		edi = Mem0[esp + 0x00:word32];
		esp += 4;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
		return;
	}
	edi = Mem0[ebp + 16:word32];
	esi = ebx + 38396;
	edx = ebx + ~0x2263;
	Mem0[ebp + -36:word32] = edx;
	ecx = ebx + 0x9A7C;
	Mem0[ebp + -44:word32] = ecx;
l08061053:
	esi += 0x04;
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		SCZO = cond(eax - 0x01);
		if (Test(LE,SZO))
		{
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[esi + 0x00:word32];
				ecx = Mem0[esi + 4:word32];
				esi += 0x08;
				edx = Mem0[edi + 0x00:word32];
				edx >>= 0x01;
				SCZO = cond(edx);
				if (Test(NE,Z))
				{
					v20 = Mem0[eax + 0x00:word32] | ecx;
					Mem0[eax + 0x00:word32] = v20;
					SZ = cond(Mem0[eax + 0x00:word32]);
					O = false;
					C = false;
				}
				else
				{
					ecx = ~ecx;
					v21 = Mem0[eax + 0x00:word32] & ecx;
					Mem0[eax + 0x00:word32] = v21;
					SZ = cond(Mem0[eax + 0x00:word32]);
					O = false;
					C = false;
				}
			}
			goto l080611B5;
		}
		SCZO = cond(eax - 0x02);
		esi = esi;
		if (Test(NE,Z))
		{
			SCZO = cond(eax - 0x03);
			if (Test(NE,Z))
				goto l080611B5;
			goto l080611A5;
		}
	}
	else
	{
		eax = Mem0[esi + 0x00:word32];
		edx = Mem0[esi + 8:word32];
		Mem0[ebp + -28:word32] = edx;
		edx = esi + 0x0C;
		ecx = Mem0[edx + 0x00:word32];
		Mem0[ebp + -32:word32] = ecx;
		ecx = Mem0[edi + 0x00:word32];
		ecx >>= 0x01;
		ecx -= Mem0[esi + 4:word32];
		SCZO = cond(ecx);
		if (Test(NS,S))
		{
			SCZO = cond(Mem0[ebp + -28:word32] - ecx);
			if (Test(GT,SZO))
			{
				edx += 0x04;
				esi = Mem0[ebp + -32:word32];
				esi = ~esi;
				esi &= Mem0[eax + 0x00:word32];
				esi |= edx[ecx * 0x04];
				SZ = cond(esi);
				O = false;
				C = false;
				Mem0[eax + 0x00:word32] = esi;
				eax = Mem0[ebp + -28:word32];
				esi = edx + eax * 0x04;
				goto l080611B5;
			}
		}
		Mem0[esp + 8:word32] = 0x00;
		eax = ebx + ~0x22D2;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 22;
		unix_error();
	}
	ecx = Mem0[esi + 0x00:word32];
	edx = Mem0[edi + 0x00:word32];
	edx >>= 0x01;
	eax = 0x01;
	SCZO = cond(edx - Mem0[ebx + ~0x225F:word32]);
	if (Test(EQ,Z))
	{
		al = 0x00;
l0806111F:
		SZP = cond(ecx & ecx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			edx = 0x00;
			SCZO = cond(ecx - 0x01);
			if (Test(EQ,Z))
			{
				eax = (ebx + ~0x2263)[eax * 0x08];
				Mem0[esp + 4:word32] = eax;
				edx = Mem0[ebp + -44:word32];
				Mem0[esp + 0x00:word32] = edx;
				cfsetospeed();
				edx = eax;
			}
		}
		else
		{
			eax = (ebx + ~0x2263)[eax * 0x08];
			Mem0[esp + 4:word32] = eax;
			ecx = Mem0[ebp + -44:word32];
			Mem0[esp + 0x00:word32] = ecx;
			cfsetispeed();
			edx = eax;
		}
		SCZO = cond(edx - ~0x00);
		if (Test(NE,Z))
		{
			esi += 0x04;
			SCZO = cond(esi);
l080611B5:
			eax = Mem0[esi + 0x00:word32];
			SCZO = cond(eax - 0x04);
			if (Test(NE,Z))
			{
				edi += 0x04;
				SCZO = cond(edi);
				goto l08061053;
			}
			goto l080611C4;
		}
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x22D2;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
l0806117F:
		++eax;
		SCZO = cond(eax - 0x12);
		if (Test(EQ,Z))
		{
			Mem0[esp + 8:word32] = 0x00;
			eax = ebx + ~0x22D2;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = 22;
			unix_error();
l080611A5:
			eax = Mem0[esi + 0x00:word32];
			esi += 0x04;
			edx = Mem0[edi + 0x00:word32];
			edx >>= 0x01;
			SCZ = cond(edx);
			O = false;
			Mem0[ebx + 39565 + eax:byte] = dl;
			goto l080611B5;
		}
	}
	else
	{
		Mem0[ebp + -28:word32] = esi;
		esi = Mem0[ebp + -36:word32];
	}
	SCZO = cond(edx - (esi + 4)[eax * 0x08]);
	if (Test(EQ,Z))
	{
		esi = Mem0[ebp + -28:word32];
		goto l0806111F;
	}
	goto l0806117F;
}

// 08061211: define unix_tcgetattr
define unix_tcgetattr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	ebx = 0x0806121F<p32>;
	ebx += 74885;
	eax = ebx + 0x9A7C;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	tcgetattr();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x22C8;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	Mem0[esp + 0x00:word32] = 0x26;
	caml_alloc_tuple();
	Mem0[ebp + -40:word32] = eax;
	eax = Mem0[ebx + 38396:word32];
	SCZO = cond(eax - 0x04);
	if (Test(NE,Z))
	{
		edi = Mem0[ebp + -40:word32];
		edx = ebx + 38396;
		ecx = ~0x2263;
		Mem0[ebp + -44:word32] = ecx;
		ecx = ebx + 0x9A7C;
		Mem0[ebp + -48:word32] = ecx;
		while (true)
		{
			esi = edx + 4;
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				SCZO = cond(eax - 0x01);
				if (Test(LE,SZO))
				{
					SZP = cond(eax & eax);
					O = false;
					C = false;
					if (Test(EQ,Z))
					{
						edx = esi + 4;
						eax = Mem0[esi + 0x00:word32];
						eax = Mem0[eax + 0x00:word32];
						eax &= Mem0[edx + 0x00:word32];
						SCZO = cond(eax - 0x01);
						eax = eax - eax - C;
						eax &= ~0x01;
						eax += 0x03;
						SCZO = cond(eax);
						esi = edx + 4;
						Mem0[edi + 0x00:word32] = eax;
					}
				}
				else
				{
					SCZO = cond(eax - 0x02);
					if (Test(NE,Z))
					{
						SCZO = cond(eax - 0x03);
						if (Test(EQ,Z))
						{
							eax = Mem0[esi + 0x00:word32];
							esi += 0x04;
							SCZO = cond(esi);
							eax = CONVERT(Mem0[ebx + 39565 + eax:byte], byte, word32);
							eax = eax + 1 + eax;
							Mem0[edi + 0x00:word32] = eax;
						}
					}
					else
					{
						edx = Mem0[esi + 0x00:word32];
						esi += 0x04;
						Mem0[edi + 0x00:word32] = 0x4B01;
						SZP = cond(edx & edx);
						O = false;
						C = false;
						if (Test(NE,Z))
						{
							eax = 0x00;
							SCZO = cond(edx - 0x01);
							if (Test(EQ,Z))
							{
								ecx = Mem0[ebp + -48:word32];
								Mem0[esp + 0x00:word32] = ecx;
								cfgetospeed();
							}
						}
						else
						{
							eax = Mem0[ebp + -48:word32];
							Mem0[esp + 0x00:word32] = eax;
							cfgetispeed();
						}
						edx = 0x01;
						ecx = Mem0[ebp + -44:word32];
						SCZO = cond(Mem0[ebx + ecx:word32] - eax);
						if (Test(EQ,Z))
						{
							dl = 0x00;
l08061384:
							eax = (ebx + ~0x225F)[edx * 0x08];
							eax = eax + 1 + eax;
							Mem0[edi + 0x00:word32] = eax;
						}
						else
						{
							do
							{
								SCZO = cond((ebx + ~0x2263)[edx * 0x08] - eax);
								if (Test(EQ,Z))
									goto l08061384;
								++edx;
								SCZO = cond(edx - 0x12);
							} while (Test(NE,Z));
						}
					}
				}
			}
			else
			{
				eax = Mem0[esi + 0x00:word32];
				Mem0[ebp + -32:word32] = eax;
				ecx = Mem0[esi + 4:word32];
				Mem0[ebp + -36:word32] = ecx;
				ecx = Mem0[esi + 8:word32];
				eax = Mem0[esi + 0x0C:word32];
				Mem0[ebp + -60:word32] = eax;
				esi += 0x10;
				Mem0[ebp + -28:word32] = esi;
				SZP = cond(ecx & ecx);
				O = false;
				C = false;
				if (Test(GT,SZO))
				{
					esi = eax;
					eax = Mem0[ebp + -32:word32];
					esi &= Mem0[eax + 0x00:word32];
					Mem0[ebp + -32:word32] = 0x00;
					eax = Mem0[ebp + -28:word32];
					SCZO = cond(esi - Mem0[eax + 0x00:word32]);
					if (Test(NE,Z))
					{
						eax = Mem0[ebp + -32:word32];
						do
						{
							++eax;
							SCZO = cond(ecx - eax);
							if (Test(LE,SZO))
								goto l08061331;
							SCZO = cond((edx + 20)[eax * 0x04] - esi);
						} while (Test(NE,Z));
						Mem0[ebp + -32:word32] = eax;
					}
					eax = Mem0[ebp + -32:word32];
					eax += Mem0[ebp + -36:word32];
					SCZO = cond(eax);
					eax = eax + 1 + eax;
					Mem0[edi + 0x00:word32] = eax;
				}
l08061331:
				eax = Mem0[ebp + -28:word32];
				esi = eax + ecx * 0x04;
			}
			eax = Mem0[esi + 0x00:word32];
			SCZO = cond(eax - 0x04);
			if (Test(EQ,Z))
				break;
			edi += 0x04;
			SCZO = cond(edi);
			edx = esi;
		}
	}
	eax = Mem0[ebp + -40:word32];
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080613CC: define unix_time
define unix_time
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x24;
	ebx = 0x080613D8<p32>;
	ebx += 74444;
	SCZO = cond(ebx);
	Mem0[esp + 0x00:word32] = 0x00;
	eax = time(Mem0[esp + 0x00:(ptr32 time_t)]);
	Mem0[ebp + -0x0C:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -0x0C:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp += 0x24;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061400: define unix_times
define unix_times
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x08061414<p32>;
	ebx += 0x00012290;
	SCZO = cond(ebx);
	Mem0[esp + 4:word32] = 0xFE;
	Mem0[esp + 0x00:word32] = 0x08;
	caml_alloc_small();
	esi = eax;
	edi = ebp - 96;
	Mem0[esp + 4:word32] = edi;
	Mem0[esp + 0x00:word32] = 0x00;
	getrusage();
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -96:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -92:int32], int32, real64);
	eax = ebx + ~0x21D3;
	ST[Top + 0x00:real64] /= Mem0[eax + 0x00:real64];
	ST[Top + 1:real64] += ST[Top + 0x00:real64];
	++Top;
	Mem0[esi + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -88:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -84:int32], int32, real64);
	ST[Top + 0x00:real64] /= Mem0[eax + 0x00:real64];
	ST[Top + 1:real64] += ST[Top + 0x00:real64];
	++Top;
	Mem0[esi + 8:real64] = ST[Top + 0x00:real64];
	++Top;
	Mem0[esp + 4:word32] = edi;
	Mem0[esp + 0x00:word32] = ~0x00;
	getrusage();
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -96:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -92:int32], int32, real64);
	eax = ebx + ~0x21D3;
	ST[Top + 0x00:real64] /= Mem0[eax + 0x00:real64];
	ST[Top + 1:real64] += ST[Top + 0x00:real64];
	++Top;
	Mem0[esi + 16:real64] = ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -88:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -84:int32], int32, real64);
	ST[Top + 0x00:real64] /= Mem0[eax + 0x00:real64];
	ST[Top + 1:real64] += ST[Top + 0x00:real64];
	++Top;
	Mem0[esi + 24:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080614A4: define unix_truncate_64
define unix_truncate_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x080614B5<p32>;
	ebx += 0x000121EF;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x00:word32] = esi;
	truncate64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2559;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080614FD: define unix_truncate
define unix_truncate
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0806150E<p32>;
	ebx += 0x00012196;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	O = false;
	Mem0[esp + 4:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	SCZ = cond(edx);
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x00:word32] = esi;
	truncate64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x2559;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061558: define unix_umask
define unix_umask
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x08061564<p32>;
	ebx += 0x00012140;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	umask();
	eax = eax + 1 + eax;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061584: define unix_error_of_code
// Called from:
//      unix_error
define unix_error_of_code
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x08061595<p32>;
	ebx += 73999;
	SCZO = cond(ebx);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x0C:word32] = ~0x00;
	Mem0[esp + 8:word32] = 0x44;
	eax = Mem0[ebx + -8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = esi;
	cst_to_constr();
	edx = eax;
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = 0x01;
		caml_alloc_small();
		edx = eax;
		eax = esi + 1 + esi;
		Mem0[edx + 0x00:word32] = eax;
	}
	eax = edx;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080615EF: define unix_error
// Called from:
//      unix_closedir
//      unix_getlogin
//      unix_mktime
//      unix_localtime
//      unix_gmtime
//      unix_lseek
//      unix_readdir
//      unix_rewinddir
//      get_sockaddr
//      alloc_sockaddr
//      unix_setsockopt_aux
//      unix_getsockopt_aux
//      unix_fstat
//      unix_lstat
//      unix_stat
//      unix_tcsetattr
//      uerror
define unix_error
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x44;
	ebx = 0x080615FB<p32>;
	ebx += 73897;
	eax = Mem0[ebp + 16:word32];
	Mem0[ebp + -0x0C:word32] = 0x01;
	Mem0[ebp + -16:word32] = 0x01;
	Mem0[ebp + -20:word32] = 0x01;
	edx = Mem0[ebx + -24:word32];
	ecx = Mem0[edx + 0x00:word32];
	Mem0[ebp + -52:word32] = ecx;
	ecx = ebp - 52;
	Mem0[edx + 0x00:word32] = ecx;
	Mem0[ebp + -44:word32] = 0x01;
	Mem0[ebp + -48:word32] = 0x03;
	edx = ebp - 0x0C;
	Mem0[ebp + -40:word32] = edx;
	edx = ebp - 16;
	Mem0[ebp + -36:word32] = edx;
	edx = ebp - 20;
	Mem0[ebp + -32:word32] = edx;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		eax = ebx + ~0x147B;
		Mem0[esp + 0x00:word32] = eax;
		caml_copy_string();
	}
	Mem0[ebp + -20:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -0x0C:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	unix_error_of_code();
	Mem0[ebp + -16:word32] = eax;
	SCZO = cond(Mem0[ebx + 0x9AB8:word32] - 0x00);
	if (Test(EQ,Z))
	{
		eax = ebx + ~0x21CB;
		Mem0[esp + 0x00:word32] = eax;
		caml_named_value();
		Mem0[ebx + 0x9AB8:word32] = eax;
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			eax = ebx + ~0x21BB;
			Mem0[esp + 0x00:word32] = eax;
			caml_invalid_argument();
		}
	}
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x04;
	caml_alloc_small();
	edx = Mem0[ebx + 0x9AB8:word32];
	edx = Mem0[edx + 0x00:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -16:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[ebp + -0x0C:word32];
	Mem0[eax + 8:word32] = edx;
	edx = Mem0[ebp + -20:word32];
	Mem0[eax + 0x0C:word32] = edx;
	ecx = Mem0[ebp + -52:word32];
	edx = Mem0[ebx + -24:word32];
	Mem0[edx + 0x00:word32] = ecx;
	Mem0[esp + 0x00:word32] = eax;
	caml_raise();
	uerror();
}

// 080616EC: define uerror
// Called from:
//      unix_accept
//      unix_access
//      unix_bind
//      unix_chdir
//      unix_chmod
//      unix_chown
//      unix_chroot
//      unix_close
//      unix_connect
//      unix_dup
//      unix_dup2
//      unix_execv
//      unix_execve
//      unix_execvpe
//      unix_execvp
//      unix_fchmod
//      unix_fchown
//      unix_clear_close_on_exec
//      unix_set_close_on_exec
//      unix_clear_nonblock
//      unix_set_nonblock
//      unix_fork
//      unix_ftruncate_64
//      unix_ftruncate
//      unix_getcwd
//      unix_getgroups
//      unix_getpeername
//      unix_gettimeofday
//      unix_getsockname
//      unix_initgroups
//      unix_getitimer
//      unix_setitimer
//      unix_kill
//      unix_link
//      unix_listen
//      unix_lockf
//      unix_lseek_64
//      unix_lseek
//      unix_mkdir
//      unix_mkfifo
//      unix_nice
//      unix_open
//      unix_opendir
//      unix_pipe
//      unix_putenv
//      unix_read
//      unix_readlink
//      unix_rename
//      unix_rmdir
//      unix_select
//      unix_sendto_native
//      unix_send
//      unix_recvfrom
//      unix_recv
//      unix_setgid
//      unix_setgroups
//      unix_setuid
//      unix_shutdown
//      unix_sigsuspend
//      unix_sigpending
//      unix_sigprocmask
//      unix_socket
//      unix_socketpair
//      unix_setsockopt_aux
//      unix_getsockopt_aux
//      unix_fstat_64
//      unix_lstat_64
//      unix_stat_64
//      unix_fstat
//      unix_lstat
//      unix_stat
//      unix_string_of_inet_addr
//      unix_symlink
//      unix_tcflow
//      unix_tcflush
//      unix_tcdrain
//      unix_tcsendbreak
//      unix_tcsetattr
//      unix_tcgetattr
//      unix_truncate_64
//      unix_truncate
//      unix_error
//      unix_unlink
//      unix_utimes
//      unix_waitpid
//      unix_wait
//      unix_single_write
//      unix_write
define uerror
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = 0x080616F8<p32>;
	ebx += 0x00011FAC;
	SCZO = cond(ebx);
	eax = __errno_location();
	edx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 8:word32] = edx;
	edx = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = edx;
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	unix_error();
	unix_unlink();
}

// 0806171C: define unix_unlink
// Called from:
//      uerror
define unix_unlink
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0806172D<p32>;
	ebx += 0x00011F77;
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = esi;
	eax = unlink(Mem0[esp + 0x00:(ptr32 char)]);
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = esi;
		eax = ebx + ~0x217B;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	eax = 0x01;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061764: define unix_utimes
define unix_utimes
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	ebx = 0x08061771<p32>;
	ebx += 0x00011F33;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -26:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -26:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -28:word16] = ax;
	__fldcw(Mem0[ebp + -28:word16]);
	Mem0[ebp + -32:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -26:word16]);
	eax = Mem0[ebp + -32:word32];
	Mem0[ebp + -16:word32] = eax;
	edx = Mem0[ebp + 16:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
	__fldcw(Mem0[ebp + -28:word16]);
	Mem0[ebp + -32:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -26:word16]);
	edx = Mem0[ebp + -32:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
l080617B7:
			Mem0[ebp + -0x0C:word32] = edx;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = esi;
			eax = utime(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 (struct "utimbuf"))]);
			SCZO = cond(eax - ~0x00);
			if (Test(EQ,Z))
			{
				Mem0[esp + 4:word32] = esi;
				eax = ebx + ~0x2174;
				Mem0[esp + 0x00:word32] = eax;
				uerror();
			}
			eax = 0x01;
			esp += 0x30;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	eax = ebp - 16;
	goto l080617B7;
}

// 080617EC: define alloc_process_status
// Called from:
//      unix_waitpid
//      unix_wait
define alloc_process_status
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x68;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x08061800<p32>;
	ebx += 0x00011EA4;
	edi = eax;
	esi = edx;
	eax = edx;
	eax &= 0x7F;
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[ebp + -76:word32] = eax;
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = 0x01;
		caml_alloc_small();
		Mem0[ebp + -28:word32] = eax;
		edx = esi;
		esi = CONVERT(dh, byte, word32);
		edx = esi + 1 + esi;
		Mem0[eax + 0x00:word32] = edx;
	}
	else
	{
		SCZO = cond(dl - 0x7F);
		if (Test(EQ,Z))
		{
			Mem0[esp + 4:word32] = 0x02;
			Mem0[esp + 0x00:word32] = 0x01;
			caml_alloc_small();
			Mem0[ebp + -76:word32] = eax;
			Mem0[ebp + -28:word32] = eax;
			edx = esi;
			esi = CONVERT(dh, byte, word32);
			Mem0[esp + 0x00:word32] = esi;
			caml_rev_convert_signal_number();
			eax = eax + 1 + eax;
			edx = Mem0[ebp + -76:word32];
			Mem0[edx + 0x00:word32] = eax;
		}
		else
		{
			Mem0[esp + 4:word32] = 0x01;
			Mem0[esp + 0x00:word32] = 0x01;
			caml_alloc_small();
			esi = eax;
			Mem0[ebp + -28:word32] = eax;
			eax = Mem0[ebp + -76:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_rev_convert_signal_number();
			eax = eax + 1 + eax;
			Mem0[esi + 0x00:word32] = eax;
		}
	}
	esi = Mem0[ebx + -24:word32];
	eax = Mem0[esi + 0x00:word32];
	Mem0[ebp + -60:word32] = eax;
	eax = ebp - 60;
	Mem0[esi + 0x00:word32] = eax;
	Mem0[ebp + -52:word32] = 0x01;
	Mem0[ebp + -56:word32] = 0x01;
	eax = ebp - 28;
	Mem0[ebp + -48:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	edx = edi + 1 + edi;
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -28:word32];
	Mem0[eax + 4:word32] = edx;
	edx = Mem0[ebp + -60:word32];
	Mem0[esi + 0x00:word32] = edx;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080618EF: define unix_waitpid
define unix_waitpid
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x20;
	ebx = 0x080618FC<p32>;
	ebx += 0x00011DA8;
	SCZO = cond(ebx);
	eax = ebx + 0x98EC;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	esi = eax;
	caml_enter_blocking_section();
	Mem0[esp + 8:word32] = esi;
	eax = ebp - 0x0C;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	waitpid();
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x216D;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	edx = Mem0[ebp + -0x0C:word32];
	eax = esi;
	alloc_process_status();
	esp += 0x20;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061969: define unix_wait
define unix_wait
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = 0x0806197A<p32>;
	ebx += 0x00011D2A;
	SCZO = cond(ebx);
	caml_enter_blocking_section();
	eax = ebp - 0x0C;
	Mem0[esp + 0x00:word32] = eax;
	eax = wait(Mem0[esp + 0x00:(ptr32 int32)]);
	esi = eax;
	caml_leave_blocking_section();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2165;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	edx = Mem0[ebp + -0x0C:word32];
	eax = esi;
	alloc_process_status();
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080619C8: define unix_single_write
define unix_single_write
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x4048;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = 0x080619DF<p32>;
	ebx += 0x00011CC5;
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + ~0x4037:word32] = edx;
	edx = ebp + ~0x4037;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + ~0x402F:word32] = 0x01;
	Mem0[ebp + ~0x4033:word32] = 0x01;
	eax = ebp + 0x0C;
	Mem0[ebp + ~0x402B:word32] = eax;
	esi = Mem0[ebp + 20:word32];
	esi >>= 0x01;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		SCZO = cond(esi - 0x4000);
		eax = 0x4000;
		if (Test(GT,SZO))
			esi = eax;
		Mem0[esp + 8:word32] = esi;
		eax = Mem0[ebp + 16:word32];
		eax >>= 0x01;
		eax += Mem0[ebp + 0x0C:word32];
		SCZO = cond(eax);
		Mem0[esp + 4:word32] = eax;
		edi = ebp + ~0x4017;
		Mem0[esp + 0x00:word32] = edi;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		caml_enter_blocking_section();
		Mem0[esp + 8:word32] = esi;
		Mem0[esp + 4:word32] = edi;
		eax = Mem0[ebp + 8:word32];
		eax >>= 0x01;
		SCZ = cond(eax);
		O = false;
		Mem0[esp + 0x00:word32] = eax;
		eax = write(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		esi = eax;
		caml_leave_blocking_section();
		SCZO = cond(esi - ~0x00);
		if (Test(NE,Z))
		{
l08061A8E:
			edx = Mem0[ebp + ~0x4037:word32];
			eax = Mem0[ebx + -24:word32];
			Mem0[eax + 0x00:word32] = edx;
			eax = esi + 1 + esi;
			ebx = Mem0[ebp + -0x0C:word32];
			esi = Mem0[ebp + -8:word32];
			edi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2160;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	esi = 0x00;
	goto l08061A8E;
}

// 08061AAD: define unix_write
define unix_write
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x404C;
	ebx = 0x08061ABE<p32>;
	ebx += 0x00011BE6;
	eax = Mem0[ebx + -24:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + ~0x4037:word32] = edx;
	edx = ebp + ~0x4037;
	Mem0[eax + 0x00:word32] = edx;
	Mem0[ebp + ~0x402F:word32] = 0x01;
	Mem0[ebp + ~0x4033:word32] = 0x01;
	eax = ebp + 0x0C;
	Mem0[ebp + ~0x402B:word32] = eax;
	esi = Mem0[ebp + 20:word32];
	esi >>= 0x01;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(LE,SZO))
	{
		Mem0[ebp + ~0x403F:word32] = 0x00;
		goto l08061BD5;
	}
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	Mem0[ebp + ~0x403B:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[ebp + ~0x4047:word32] = eax;
	Mem0[ebp + ~0x403F:word32] = 0x00;
	eax = ebp + ~0x4017;
	Mem0[ebp + ~0x4043:word32] = eax;
l08061B30:
	SCZO = cond(esi - 0x4000);
	edi = 0x4000;
	if (Test(LE,SZO))
		edi = esi;
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebp + ~0x403B:word32];
	eax += Mem0[ebp + 0x0C:word32];
	SCZO = cond(eax);
	Mem0[esp + 4:word32] = eax;
	edx = Mem0[ebp + ~0x4043:word32];
	Mem0[esp + 0x00:word32] = edx;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	caml_enter_blocking_section();
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebp + ~0x4043:word32];
	Mem0[esp + 4:word32] = eax;
	edx = Mem0[ebp + ~0x4047:word32];
	Mem0[esp + 0x00:word32] = edx;
	eax = write(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	edi = eax;
	caml_leave_blocking_section();
	SCZO = cond(edi - ~0x00);
	if (Test(EQ,Z))
	{
		esi = Mem0[ebp + ~0x403F:word32];
		eax = __errno_location();
		SCZO = cond(Mem0[eax + 0x00:word32] - 11);
		if (Test(EQ,Z))
		{
			SZP = cond(esi & esi);
			O = false;
			C = false;
			if (Test(GT,SZO))
			{
l08061BD5:
				edx = Mem0[ebp + ~0x4037:word32];
				eax = Mem0[ebx + -24:word32];
				Mem0[eax + 0x00:word32] = edx;
				edx = Mem0[ebp + ~0x403F:word32];
				eax = edx + 1 + edx;
				esp += 0x404C;
				SCZO = cond(esp);
				ebx = Mem0[esp + 0x00:word32];
				esp += 4;
				esi = Mem0[esp + 0x00:word32];
				esp += 4;
				edi = Mem0[esp + 0x00:word32];
				esp += 4;
				ebp = Mem0[esp + 0x00:word32];
				esp += 4;
				return;
			}
		}
		Mem0[esp + 4:word32] = 0x00;
		eax = ebx + ~0x2159;
		Mem0[esp + 0x00:word32] = eax;
		uerror();
	}
	v17 = Mem0[ebp + ~0x403F:word32] + edi;
	Mem0[ebp + ~0x403F:word32] = v17;
	esi -= edi;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		v18 = Mem0[ebp + ~0x403B:word32] + edi;
		Mem0[ebp + ~0x403B:word32] = v18;
		SCZO = cond(v18);
		goto l08061B30;
	}
	goto l08061BD5;
}

// 08061C00: define cst_to_constr
// Called from:
//      unix_getaddrinfo
//      stat_aux
//      unix_error_of_code
define cst_to_constr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	ecx = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	edx = Mem0[ebp + 16:word32];
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		eax = 0x00;
		SCZO = cond(Mem0[esi + 0x00:word32] - ecx);
		while (Test(NE,Z))
		{
			++eax;
			SCZO = cond(edx - eax);
			if (Test(LE,SZO))
				goto l08061C2E;
			SCZO = cond(esi[eax * 0x04] - ecx);
		}
		eax = eax + 1 + eax;
	}
	else
	{
l08061C2E:
		eax = Mem0[ebp + 20:word32];
		eax = eax + 1 + eax;
	}
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061C38: define cstringvect
// Called from:
//      unix_execv
//      unix_execve
//      unix_execvpe
//      unix_execvp
define cstringvect
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	ebx = 0x08061C46<p32>;
	ebx += 0x00011A5E;
	esi = Mem0[ebp + 8:word32];
	edi = Mem0[esi + -4:word32];
	edi >>= 0x0A;
	SCZO = cond(edi);
	eax = 0x04 + edi * 0x04;
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_alloc();
	Mem0[ebp + -28:word32] = eax;
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edx = 0x00;
		do
		{
			ecx = esi[edx * 0x04];
			eax[edx * 0x04] = ecx;
			++edx;
			SCZO = cond(edi - edx);
		} while (Test(UGT,CZ));
	}
	eax = Mem0[ebp + -28:word32];
	eax[edi * 0x04] = 0x00;
	eax = Mem0[ebp + -28:word32];
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061CA0: define scanmult
define scanmult
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	edi = eax;
	Mem0[ebp + -44:word32] = edx;
	Mem0[ebp + -25:byte] = 0x20;
	ebx = ebp - 25;
	Mem0[esp + 0x0C:word32] = ebx;
	esi = ebp - 32;
	Mem0[esp + 8:word32] = esi;
	Mem0[esp + 4:word32] = 0x08071550;
	Mem0[esp + 0x00:word32] = eax;
	eax = __isoc99_sscanf(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:(ptr32 uint32)], Mem0[esp + 0x0C:(ptr32 char)]);
	Mem0[esp + 0x0C:word32] = ebx;
	Mem0[esp + 8:word32] = esi;
	Mem0[esp + 4:word32] = 0x08071556;
	Mem0[esp + 0x00:word32] = edi;
	eax = __isoc99_sscanf(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:(ptr32 uint32)], Mem0[esp + 0x0C:(ptr32 char)]);
	eax = CONVERT(Mem0[ebp + -25:byte], byte, word32);
	SCZO = cond(al - 77);
	if (Test(NE,Z))
	{
		SCZO = cond(al - 0x6B);
		if (Test(NE,Z))
		{
			SCZO = cond(al - 0x47);
			if (Test(EQ,Z))
			{
				eax = Mem0[ebp + -32:word32];
				eax <<= 0x1E;
				SCZO = cond(eax);
				edx = Mem0[ebp + -44:word32];
				Mem0[edx + 0x00:word32] = eax;
			}
			else
			{
				eax = Mem0[ebp + -32:word32];
				edx = Mem0[ebp + -44:word32];
				Mem0[edx + 0x00:word32] = eax;
			}
		}
		else
		{
			eax = Mem0[ebp + -32:word32];
			eax <<= 0x0A;
			SCZO = cond(eax);
			edx = Mem0[ebp + -44:word32];
			Mem0[edx + 0x00:word32] = eax;
		}
	}
	else
	{
		eax = Mem0[ebp + -32:word32];
		eax <<= 0x14;
		SCZO = cond(eax);
		edx = Mem0[ebp + -44:word32];
		Mem0[edx + 0x00:word32] = eax;
	}
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061D3E: define caml_main
// Called from:
//      caml_startup
//      main
define caml_main
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x3C;
	SCZO = cond(esp);
	caml_init_ieee_floats();
	caml_init_custom_operations();
	eax = ebp - 25;
	Mem0[0x08083EA4<p32>:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x0807155E;
	eax = getenv(Mem0[esp + 0x00:(ptr32 char)]);
	ebx = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
l08061E33:
		esi = 0x080715A8;
		edi = ebp - 32;
		do
		{
			eax = CONVERT(Mem0[ebx + 0x00:byte], byte, word32);
			SZP = cond(al & al);
			O = false;
			C = false;
			if (Test(EQ,Z))
				goto l08061E46;
			++ebx;
			eax -= 0x4F;
			SCZO = cond(al - 0x27);
		} while (Test(UGT,CZ));
		eax = CONVERT(al, byte, word32);
		esi[eax * 0x04]();
		return;
	}
	Mem0[esp + 0x00:word32] = 0x0807155F;
	eax = getenv(Mem0[esp + 0x00:(ptr32 char)]);
	ebx = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
		goto l08061E33;
l08061E46:
	eax = Mem0[0x0807CF98<p32>:word32];
	Mem0[esp + 16:word32] = eax;
	eax = Mem0[0x0807CF9C<p32>:word32];
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[0x0807CFA0<p32>:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[0x0807CFA4<p32>:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x0807CFA8<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_init_gc();
	eax = 0x00;
	edx = 0x08083AA0;
	do
	{
		edx[eax * 0x04] = eax;
		++eax;
		SCZO = cond(eax - 0x0100);
	} while (Test(NE,Z));
	Mem0[esp + 8:word32] = 0x08083EA0;
	Mem0[esp + 4:word32] = 0x08083AA0;
	Mem0[esp + 0x00:word32] = 0x04;
	caml_page_table_add();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		eax = Mem0[0x08073E20<p32>:word32];
		ebx = 0x00;
		esi = 0x08073E24;
		edi = 0x08073E20;
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
			goto l08061F05;
	}
	else
	{
		Mem0[esp + 0x00:word32] = 134681964;
		caml_fatal_error();
	}
	do
	{
		edx = esi[ebx * 0x08];
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x04;
		caml_page_table_add();
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = 134681964;
			caml_fatal_error();
		}
		++ebx;
		eax = edi[ebx * 0x08];
		SZP = cond(eax & eax);
		O = false;
		C = false;
	} while (Test(NE,Z));
l08061F05:
	eax = Mem0[0x08073E9C<p32>:word32];
	Mem0[0x080839E0<p32>:word32] = eax;
	ecx = Mem0[0x08073EA0<p32>:word32];
	Mem0[0x08083A9C<p32>:word32] = ecx;
	eax = Mem0[0x08073EA4<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		ebx = Mem0[0x080839E0<p32>:word32];
		edx = 0x01;
		edi = 0x08073EA0;
		esi = 0x08073E9C;
		do
		{
			SCZO = cond(ebx - eax);
			if (Test(UGT,CZ))
				ebx = eax;
			eax = edi[edx * 0x08];
			SCZO = cond(ecx - eax);
			if (Test(ULT,C))
				ecx = eax;
			++edx;
			eax = esi[edx * 0x08];
			SZP = cond(eax & eax);
			O = false;
			C = false;
		} while (Test(NE,Z));
		Mem0[0x080839E0<p32>:word32] = ebx;
		Mem0[0x08083A9C<p32>:word32] = ecx;
	}
	caml_init_signals();
	caml_debugger_init();
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 0x00:word32];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	eax = 0x08072228;
	if (Test(EQ,Z))
		ebx = eax;
	Mem0[esp + 4:word32] = 0x0100;
	Mem0[esp + 0x00:word32] = 0x0807D180;
	caml_executable_name();
	edx = 0x0807D180;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_search_exe_in_path();
		edx = eax;
	}
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = edx;
	caml_sys_init();
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x08083A00;
	__sigsetjmp();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax = Mem0[0x0807D160<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = 0x00;
			eax();
		}
	}
	else
	{
		fn080709F0();
		edx = eax;
		edx &= 0x03;
		SCZO = cond(edx - 0x02);
		if (Test(EQ,Z))
		{
			eax &= ~0x03;
			SZ = cond(eax);
			O = false;
			C = false;
			Mem0[esp + 0x00:word32] = eax;
			caml_fatal_uncaught_exception();
		}
	}
	esp += 0x3C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08061FF9: define caml_startup
define caml_startup
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_main();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806200C: define main
define main
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	__align_stack<word32>(esp);
	esp -= 0x10;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_main();
	Mem0[esp + 0x00:word32] = 0x01;
	caml_sys_exit();
	eax = 0x00;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062040: define caml_raise
// Called from:
//      unix_error
//      caml_array_bound_error
//      caml_raise_stack_overflow
//      caml_raise_out_of_memory
//      caml_raise_with_args
//      caml_raise_with_arg
//      caml_raise_constant
//      caml_execute_signal
//      caml_callback3
//      caml_callback2
//      caml_callback
//      caml_callbackN
//      caml_final_do_calls
define caml_raise
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_11 = fp - 0x1C;
	ebx_12 = dwArg04;
	eax_13 = Mem10[0x08081870<p32>:word32];
	if (eax_13 != 0x00)
		eax_13();
	edx_22 = Mem10[0x0807D280<p32>:word32];
	if (edx_22 == 0x00)
		caml_fatal_uncaught_exception();
	else
	{
		eax_30 = Mem10[0x0807D294<p32>:word32];
		if (eax_30 != 0x00 && eax_30 <u edx_22)
		{
			do
			{
				Mem38 = ϕ(Mem10, Mem40);
				eax_37 = ϕ(eax_30, eax_39);
				eax_39 = Mem38[eax_37 + 0x00:word32];
				Mem40[0x0807D294<p32>:word32] = eax_39;
			} while (eax_39 != 0x00 && edx_22 >u eax_39);
		}
		fn08070A80();
		caml_array_bound_error();
		C_73 = SLICE(SCZOP_64, bool, 1);
		O_74 = SLICE(SCZOP_64, bool, 4);
		P_75 = SLICE(SCZOP_64, bool, 5);
		S_76 = SLICE(SCZOP_64, bool, 0);
		Z_77 = SLICE(SCZOP_64, bool, 2);
	}
}

// 0806208D: define caml_array_bound_error
// Called from:
//      caml_raise
//      caml_string_set
//      caml_string_get
//      caml_array_set_float
//      caml_array_set_addr
//      caml_array_get_float
//      caml_array_get_addr
//      fn08070B18
define caml_array_bound_error
{
	ptr32 fp;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	if (Mem6[0x0807D284<p32>:word32] == 0x00)
	{
		Mem11[0x0807CFB0<p32>:word32] = 0x14FC;
		Mem12[0x0807CFC7<p32>:byte] = 0x00;
		Mem13[0x0807D288<p32>:word32] = 0x0800;
		Mem14[0x0807D28C<p32>:word32] = 0x080739E8;
		Mem15[0x0807D290<p32>:word32] = 0x0807CFB4;
		Mem16[0x0807D284<p32>:word32] = 0x01;
		caml_page_table_add();
		Mem28[0x0807D284<p32>:word32] = 0x01;
	}
	caml_raise();
	caml_raise_stack_overflow();
	C_46 = SLICE(SCZOP_40, bool, 1);
	O_47 = SLICE(SCZOP_40, bool, 4);
	P_48 = SLICE(SCZOP_40, bool, 5);
	S_49 = SLICE(SCZOP_40, bool, 0);
	Z_50 = SLICE(SCZOP_40, bool, 2);
}

// 08062107: define caml_raise_stack_overflow
// Called from:
//      caml_array_bound_error
//      segv_handler
define caml_raise_stack_overflow
{
	ptr32 fp;
	word32 ebp;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise();
	caml_raise_out_of_memory();
	C_15 = SLICE(SCZO_12, bool, 1);
	O_16 = SLICE(SCZO_12, bool, 4);
	S_17 = SLICE(SCZO_12, bool, 0);
	Z_18 = SLICE(SCZO_12, bool, 2);
}

// 08062119: define caml_raise_out_of_memory
// Called from:
//      caml_raise_stack_overflow
//      caml_round_heap_chunk_size
//      caml_set_minor_heap_size
//      caml_stat_resize
//      caml_stat_alloc
//      caml_alloc_shr
//      compare_stack_overflow
//      extern_out_of_memory
//      init_extern_output
//      intern_alloc
define caml_raise_out_of_memory
{
	ptr32 fp;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise();
	caml_raise_with_args();
	C_15 = SLICE(SCZO_12, bool, 1);
	O_16 = SLICE(SCZO_12, bool, 4);
	S_17 = SLICE(SCZO_12, bool, 0);
	Z_18 = SLICE(SCZO_12, bool, 2);
}

// 0806212B: define caml_raise_with_args
// Called from:
//      caml_raise_out_of_memory
define caml_raise_with_args
{
	ptr32 fp;
	word32 dwArg08;
	word32 dwArg0C;
	word32 dwArg04;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_14 = fp - 0x5C;
	esi_16 = dwArg08;
	ebx_17 = dwArg0C;
	Mem27[0x0807D294<p32>:word32] = fp - 76;
	caml_alloc_small();
	Mem39[eax_34 + 0x00:word32] = dwArg04;
	if (dwArg08 > 0x00)
	{
		edx_45 = 0x00;
		do
		{
			Mem48 = ϕ(Mem39, Mem51);
			edx_47 = ϕ(edx_45, edx_52);
			ecx_49 = dwArg0C[edx_47 * 0x04];
			(eax_34 + 4)[edx_47 * 0x04] = ecx_49;
			edx_52 = edx_47 + 0x01;
		} while (edx_52 != dwArg08);
	}
	caml_raise();
	caml_raise_with_arg();
	C_97 = SLICE(SCZOP_73, bool, 1);
	O_98 = SLICE(SCZOP_73, bool, 4);
	P_99 = SLICE(SCZOP_73, bool, 5);
	S_100 = SLICE(SCZOP_73, bool, 0);
	Z_101 = SLICE(SCZOP_73, bool, 2);
}

// 080621A7: define caml_raise_with_arg
// Called from:
//      caml_raise_with_args
//      caml_raise_sys_error
//      caml_raise_with_string
define caml_raise_with_arg
{
	ptr32 fp;
	word32 ebp;
	word32 dwArg04;
	word32 dwArg08;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x6C;
	eax_10 = Mem6[0x0807D294<p32>:word32];
	Mem22[0x0807D294<p32>:word32] = fp - 80;
	caml_alloc_small();
	Mem34[eax_29 + 0x00:word32] = dwArg04;
	Mem37[eax_29 + 4:word32] = dwArg08;
	caml_raise();
	caml_raise_sys_error();
	C_63 = SLICE(SCZO_45, bool, 1);
	O_64 = SLICE(SCZO_45, bool, 4);
	S_65 = SLICE(SCZO_45, bool, 0);
	Z_66 = SLICE(SCZO_45, bool, 2);
}

// 08062228: define caml_raise_sys_error
// Called from:
//      caml_raise_with_arg
//      caml_sys_error
define caml_raise_sys_error
{
	ptr32 fp;
	word32 ebp;
	word32 dwArg04;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise_with_arg();
	caml_raise_with_string();
	C_21 = SLICE(SCZO_16, bool, 1);
	O_22 = SLICE(SCZO_16, bool, 4);
	S_23 = SLICE(SCZO_16, bool, 0);
	Z_24 = SLICE(SCZO_16, bool, 2);
}

// 08062241: define caml_raise_with_string
// Called from:
//      caml_raise_sys_error
//      caml_invalid_argument
//      caml_failwith
define caml_raise_with_string
{
	ptr32 fp;
	word32 dwArg08;
	word32 dwArg04;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_copy_string();
	caml_raise_with_arg();
	caml_invalid_argument();
	C_27 = SLICE(SCZO_20, bool, 1);
	O_28 = SLICE(SCZO_20, bool, 4);
	S_29 = SLICE(SCZO_20, bool, 0);
	Z_30 = SLICE(SCZO_20, bool, 2);
}

// 08062261: define caml_invalid_argument
// Called from:
//      unix_error
//      caml_raise_with_string
//      caml_install_signal_handler
//      compare_val
//      parse_format
//      caml_create_string
//      caml_make_vect
//      extern_invalid_argument
//      caml_weak_check
//      caml_weak_blit
//      caml_weak_set
//      caml_weak_get_copy
//      caml_weak_get
//      caml_weak_create
//      caml_final_register
define caml_invalid_argument
{
	ptr32 fp;
	word32 ebp;
	word32 dwArg04;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise_with_string();
	caml_failwith();
	C_21 = SLICE(SCZO_16, bool, 1);
	O_22 = SLICE(SCZO_16, bool, 4);
	S_23 = SLICE(SCZO_16, bool, 0);
	Z_24 = SLICE(SCZO_16, bool, 2);
}

// 0806227A: define caml_failwith
// Called from:
//      unix_inet_addr_of_string
//      caml_invalid_argument
//      parse_intnat
//      caml_int64_of_string
//      caml_float_of_string
//      caml_float_of_substring
//      caml_getword
//      caml_putword
//      grow_extern_output
//      caml_output_val
//      caml_marshal_data_size
//      caml_deserialize_error
//      intern_rec
//      caml_input_value_from_block
//      caml_input_value_from_malloc
//      caml_input_val
define caml_failwith
{
	ptr32 fp;
	word32 ebp;
	word32 dwArg04;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise_with_string();
	caml_raise_constant();
	C_21 = SLICE(SCZO_16, bool, 1);
	O_22 = SLICE(SCZO_16, bool, 4);
	S_23 = SLICE(SCZO_16, bool, 0);
	Z_24 = SLICE(SCZO_16, bool, 2);
}

// 08062293: define caml_raise_constant
// Called from:
//      caml_failwith
//      caml_raise_sys_blocked_io
//      caml_raise_not_found
//      caml_raise_zero_divide
//      caml_raise_end_of_file
define caml_raise_constant
{
	ptr32 fp;
	word32 ebp;
	word32 dwArg04;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x6C;
	eax_10 = Mem6[0x0807D294<p32>:word32];
	Mem20[0x0807D294<p32>:word32] = fp - 80;
	caml_alloc_small();
	Mem32[eax_27 + 0x00:word32] = dwArg04;
	caml_raise();
	caml_raise_sys_blocked_io();
	C_56 = SLICE(SCZO_40, bool, 1);
	O_57 = SLICE(SCZO_40, bool, 4);
	S_58 = SLICE(SCZO_40, bool, 0);
	Z_59 = SLICE(SCZO_40, bool, 2);
}

// 08062305: define caml_raise_sys_blocked_io
// Called from:
//      caml_raise_constant
//      caml_sys_io_error
define caml_raise_sys_blocked_io
{
	ptr32 fp;
	word32 ebp;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise_constant();
	caml_raise_not_found();
	C_15 = SLICE(SCZO_12, bool, 1);
	O_16 = SLICE(SCZO_12, bool, 4);
	S_17 = SLICE(SCZO_12, bool, 0);
	Z_18 = SLICE(SCZO_12, bool, 2);
}

// 08062317: define caml_raise_not_found
// Called from:
//      unix_getgrgid
//      unix_getgrnam
//      unix_gethostbyname
//      unix_gethostbyaddr
//      unix_getnameinfo
//      unix_getprotobynumber
//      unix_getprotobyname
//      unix_getpwuid
//      unix_getpwnam
//      unix_getservbyport
//      unix_getservbyname
//      caml_raise_sys_blocked_io
//      caml_sys_getenv
define caml_raise_not_found
{
	ptr32 fp;
	word32 ebp;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise_constant();
	caml_raise_zero_divide();
	C_15 = SLICE(SCZO_12, bool, 1);
	O_16 = SLICE(SCZO_12, bool, 4);
	S_17 = SLICE(SCZO_12, bool, 0);
	Z_18 = SLICE(SCZO_12, bool, 2);
}

// 08062329: define caml_raise_zero_divide
// Called from:
//      caml_raise_not_found
//      caml_nativeint_mod
//      caml_nativeint_div
//      caml_int64_mod
//      caml_int64_div
//      caml_int32_mod
//      caml_int32_div
define caml_raise_zero_divide
{
	ptr32 fp;
	word32 ebp;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise_constant();
	caml_raise_end_of_file();
	C_15 = SLICE(SCZO_12, bool, 1);
	O_16 = SLICE(SCZO_12, bool, 4);
	S_17 = SLICE(SCZO_12, bool, 0);
	Z_18 = SLICE(SCZO_12, bool, 2);
}

// 0806233B: define caml_raise_end_of_file
// Called from:
//      unix_readdir
//      caml_raise_zero_divide
//      caml_refill
//      caml_md5_chan
define caml_raise_end_of_file
{
	ptr32 fp;
	word32 ebp;
	word32 dwLoc14;
	word32 dwLoc0C;
	word32 dwLoc10;
	word32 dwLoc08;
	word32 dwLoc18;
	Top_3 = 0;
	ebp_7 = fp - 4;
	esp_8 = fp - 0x1C;
	caml_raise_constant();
	caml_do_local_roots();
}

// 08062350: define caml_do_local_roots
// Called from:
//      caml_raise_end_of_file
//      caml_do_roots
define caml_do_local_roots
{
	ptr32 fp;
	word32 dwArg08;
	word32 dwArg10;
	word32 dwArg0C;
	word32 dwArg14;
	word32 dwArg04;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	eax_18 = dwArg08;
	SZP_19 = cond(dwArg08);
	P_385 = SLICE(SZP_19, bool, 5);
	if (dwArg08 != 0x00)
	{
		dwLoc24_215 = dwArg10;
		edx_25 = dwArg0C;
		dwLoc20_217 = dwArg08;
		do
		{
			while (true)
			{
				P_387 = ϕ(P_385, P_388, P_387);
				dwLoc24_356 = ϕ(dwLoc24_215, dwLoc24_356, dwLoc24_222);
				dwLoc20_219 = ϕ(dwLoc20_217, dwLoc20_297, dwLoc20_221);
				edx_29 = ϕ(edx_25, edx_193, edx_58);
				Mem27 = ϕ(Mem26, Mem190, Mem60);
				esi_28 = Mem27[0x08083EA0<p32>:word32];
				eax_31 = edx_29 >>u 0x03;
				eax_32 = eax_31 & esi_28;
				ecx_33 = Mem27[0x0807D29C<p32>:word32];
				ebx_34 = ecx_33[eax_32 * 0x04];
				if (Mem27[ebx_34 + 0x00:word32] != edx_29)
				{
					do
					{
						eax_37 = ϕ(eax_32, eax_40);
						eax_38 = eax_37 + 0x01;
						eax_40 = eax_38 & esi_28;
						ebx_43 = ecx_33[eax_40 * 0x04];
					} while (Mem27[ebx_43 + 0x00:word32] != edx_29);
				}
				ebx_47 = ϕ(ebx_34, ebx_43);
				if (Mem27[ebx_47 + 4:word16] == ~0x00)
					break;
				esi_134 = CONVERT(Mem27[ebx_47 + 6:word16], word16, word32);
				SZP_135 = cond(esi_134);
				P_389 = SLICE(SZP_135, bool, 5);
				if (esi_134 > 0x00)
				{
					edi_140 = ebx_47 + 8;
					while (true)
					{
						esi_170 = ϕ(esi_134, esi_177);
						Mem144 = ϕ(Mem141, Mem164);
						edi_143 = ϕ(edi_140, edi_194);
						eax_145 = CONVERT(Mem144[edi_143 + 0x00:word16], word16, word32);
						al_146 = SLICE(eax_145, byte, 0);
						if ((al_146 & 0x01) != 0x00)
							eax_158 = dwLoc24_356 + (eax_145 >> 0x01) * 0x04;
						else
							eax_152 = eax_145 + dwLoc20_219;
						eax_159 = ϕ(eax_158, eax_152);
						eax_163 = Mem162[eax_159 + 0x00:word32];
						dwArg04();
						esi_177 = esi_170 - 0x01;
						SZP_178 = cond(esi_177);
						P_390 = SLICE(SZP_178, bool, 5);
						if (esi_177 <= 0x00)
							break;
						edi_194 = edi_143 + 0x02;
					}
				}
				P_388 = ϕ(P_389, P_390);
				Mem185 = ϕ(Mem27, Mem164);
				eax_186 = CONVERT(Mem185[ebx_47 + 4:word16], word16, word32);
				v20_189 = dwLoc20_219 + (eax_186 & 0xFFFC);
				dwLoc20_297 = v20_189;
				edx_193 = Mem190[v20_189 + -4:word32];
			}
			edx_56 = Mem27[dwLoc20_219 + 0x08:word32];
			dwLoc20_221 = edx_56;
			edx_58 = Mem57[dwLoc20_219 + 0x0C:word32];
			eax_59 = Mem57[dwLoc20_219 + 0x10:word32];
			dwLoc24_222 = eax_59;
		} while (edx_56 != 0x00);
	}
	P_384 = ϕ(P_385, P_387);
	edx_376 = ϕ(edx, edx_58);
	ecx_368 = ϕ(ecx, ecx_33);
	eax_362 = ϕ(eax_18, eax_59);
	if (dwArg14 != 0x00)
	{
		esi_67 = dwArg14;
		do
		{
			edx_379 = ϕ(edx_376, edx_378);
			ecx_372 = ϕ(ecx_368, ecx_371);
			eax_364 = ϕ(eax_362, eax_363);
			Mem71 = ϕ(Mem68, Mem108);
			esi_70 = ϕ(esi_67, esi_109);
			edi_69 = 0x00;
			if (Mem71[esi_70 + 4:word32] > 0x00)
			{
				do
				{
					edx_381 = ϕ(edx_379, edx_380);
					ecx_374 = ϕ(ecx_372, ecx_373);
					eax_366 = ϕ(eax_364, eax_365);
					edi_101 = ϕ(edi_69, edi_102);
					Mem75 = ϕ(Mem71, Mem104);
					ebx_76 = 0x00;
					if (Mem75[esi_70 + 8:word32] > 0x00)
					{
						do
						{
							Mem84 = ϕ(Mem75, Mem90);
							ebx_80 = ϕ(ebx_76, ebx_97);
							eax_81 = ebx_80 * 0x04;
							eax_85 = eax_81 + (esi_70 + 0x0C)[edi_101 * 0x04];
							eax_89 = Mem88[eax_85 + 0x00:word32];
							dwArg04();
							ebx_97 = ebx_80 + 0x01;
						} while (Mem90[esi_70 + 8:word32] > ebx_97);
					}
					edx_380 = ϕ(edx_381, edx_94);
					ecx_373 = ϕ(ecx_374, ecx_95);
					eax_365 = ϕ(eax_366, eax_93);
					Mem104 = ϕ(Mem75, Mem90);
					edi_102 = edi_101 + 0x01;
				} while (Mem104[esi_70 + 4:word32] > edi_102);
			}
			edx_378 = ϕ(edx_379, edx_380);
			ecx_371 = ϕ(ecx_372, ecx_373);
			eax_363 = ϕ(eax_364, eax_365);
			Mem108 = ϕ(Mem71, Mem104);
			esi_109 = Mem108[esi_70 + 0x00:word32];
			SZP_110 = cond(esi_109);
			P_392 = SLICE(SZP_110, bool, 5);
		} while (esi_109 != 0x00);
	}
	P_383 = ϕ(P_384, P_392);
	edx_375 = ϕ(edx_376, edx_378);
	ecx_367 = ϕ(ecx_368, ecx_371);
	eax_361 = ϕ(eax_362, eax_363);
	SCZO_124 = cond(fp - 0x10);
	C_360 = SLICE(SCZO_124, bool, 1);
	O_382 = SLICE(SCZO_124, bool, 4);
	S_393 = SLICE(SCZO_124, bool, 0);
	Z_395 = SLICE(SCZO_124, bool, 2);
}

// 08062477: define caml_stack_usage
// Called from:
//      caml_gc_quick_stat
//      caml_gc_stat
define caml_stack_usage
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = Mem0[0x08083EA4<p32>:word32];
	ebx -= Mem0[0x0807D2A0<p32>:word32];
	ebx >>= 0x02;
	eax = Mem0[0x0807D2A8<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax();
		ebx += eax;
		SCZO = cond(ebx);
	}
	eax = ebx;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080624A2: define cons
// Called from:
//      caml_register_dyn_global
//      caml_register_frametable
define cons
{
	word32 eax;
	word32 edx;
	Top_3 = 0;
	caml_stat_alloc();
	C_33 = SLICE(SCZO_21, bool, 1);
	O_34 = SLICE(SCZO_21, bool, 4);
	S_35 = SLICE(SCZO_21, bool, 0);
	Z_36 = SLICE(SCZO_21, bool, 2);
	Mem22[eax_19 + 0x00:word32] = eax;
	Mem23[eax_19 + 4:word32] = edx;
}

// 080624CD: define caml_register_dyn_global
define caml_register_dyn_global
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	edx = Mem0[0x0807D2AC<p32>:word32];
	eax = Mem0[ebp + 8:word32];
	cons();
	Mem0[0x0807D2AC<p32>:word32] = eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080624E8: define caml_register_frametable
// Called from:
//      caml_init_frame_descriptors
define caml_register_frametable
{
	word32 dwArg04;
	Top_3 = 0;
	edx_10 = Mem6[0x0807D2B4<p32>:word32];
	cons();
	Mem15[0x0807D2B4<p32>:word32] = eax_13;
	eax_16 = Mem15[0x0807D29C<p32>:word32];
	SZP_17 = cond(eax_16);
	Z_20 = SLICE(SZP_17, bool, 2);
	P_42 = SLICE(SZP_17, bool, 5);
	S_44 = SLICE(SZP_17, bool, 0);
	O_18 = false;
	C_19 = false;
	if (eax_16 != 0x00)
	{
		caml_stat_free();
		Mem27[0x0807D29C<p32>:word32] = 0x00;
	}
	Z_46 = ϕ(Z_20, Z_25);
	S_43 = ϕ(S_44, S_23);
	O_40 = ϕ(O_18, O_26);
	eax_38 = ϕ(eax_16, eax_22);
	C_37 = ϕ(C_19, C_24);
}

// 0806251E: define caml_init_frame_descriptors
// Called from:
//      caml_do_roots
//      caml_oldify_local_roots
//      caml_stash_backtrace
define caml_init_frame_descriptors
{
	ptr32 fp;
	Top_3 = 0;
	if (Mem16[0x0807D2B8<p32>:word32] == 0x00)
	{
		eax_20 = Mem16[0x08073F18<p32>:word32];
		if (eax_20 != 0x00)
		{
			ebx_25 = 0x00;
			do
			{
				ebx_33 = ϕ(ebx_25, ebx_39);
				caml_register_frametable();
				ebx_39 = ebx_33 + 0x01;
				eax_40 = 0x08073F18[ebx_39 * 0x04];
			} while (eax_40 != 0x00);
		}
		Mem45[0x0807D2B8<p32>:word32] = 0x01;
	}
	Mem46 = ϕ(Mem16, Mem45);
	eax_47 = Mem46[0x0807D2B4<p32>:word32];
	if (eax_47 != 0x00)
	{
		edx_52 = 0x00;
		do
		{
			edx_56 = ϕ(edx_52, edx_57);
			eax_53 = ϕ(eax_47, eax_58);
			ecx_55 = Mem46[eax_53 + 0x00:word32];
			edx_57 = edx_56 + Mem46[ecx_55 + 0x00:word32];
			eax_58 = Mem46[eax_53 + 4:word32];
		} while (eax_58 != 0x00);
		if (edx_57 * 0x02 > 0x04)
		{
			ebx_97 = 0x04;
			do
			{
				ebx_98 = ϕ(ebx_97, ebx_99);
				ebx_99 = ebx_98 * 0x02;
			} while (ebx_99 < edx_57 * 0x02);
			caml_stat_alloc();
			Mem114[0x0807D29C<p32>:word32] = eax_110;
			if (ebx_99 <= 0x00)
			{
l080625C4:
				edx_328 = ϕ(edx_111, edx_122);
				ecx_320 = ϕ(ecx_112, ecx_322);
				ebx_129 = ϕ(ebx_99, ebx_232);
				ebx_130 = ebx_129 - 0x01;
				Mem131[0x08083EA0<p32>:word32] = ebx_130;
				eax_132 = Mem131[0x0807D2B4<p32>:word32];
				dwLoc24_240 = eax_132;
				SZP_137 = cond(eax_132);
				P_334 = SLICE(SZP_137, bool, 5);
				if (eax_132 != 0x00)
				{
					do
					{
						edx_330 = ϕ(edx_328, edx_329);
						ecx_324 = ϕ(ecx_320, ecx_323);
						dwLoc24_241 = ϕ(dwLoc24_240, dwLoc24_252);
						Mem142 = ϕ(Mem136, Mem203);
						esi_144 = Mem142[dwLoc24_241 + 0x00:word32];
						eax_145 = Mem142[esi_144 + 0x00:word32];
						if (eax_145 > 0x00)
						{
							esi_152 = esi_144 + 0x04;
							edi_154 = 0x00;
							while (true)
							{
								edi_190 = ϕ(edi_154, edi_191);
								esi_157 = ϕ(esi_152, esi_230);
								Mem155 = ϕ(Mem146, Mem177);
								ebx_156 = Mem155[0x08083EA0<p32>:word32];
								eax_158 = Mem155[esi_157 + 0x00:word32];
								eax_160 = eax_158 >>u 0x03 & ebx_156;
								ecx_161 = Mem155[0x0807D29C<p32>:word32];
								edx_162 = ecx_161 + eax_160 * 0x04;
								if (Mem155[edx_162 + 0x00:word32] != 0x00)
								{
									do
									{
										eax_165 = ϕ(eax_168, eax_160);
										eax_166 = eax_165 + 0x01;
										eax_168 = eax_166 & ebx_156;
										edx_170 = ecx_161 + eax_168 * 0x04;
									} while (Mem155[edx_170 + 0x00:word32] != 0x00);
								}
								edx_176 = ϕ(edx_170, edx_162);
								Mem177[edx_176 + 0x00:word32] = esi_157;
								eax_178 = CONVERT(Mem177[esi_157 + 6:word16], word16, word32);
								eax_179 = esi_157 + 11 + eax_178 * 0x02;
								eax_180 = eax_179 & ~0x03;
								edx_181 = (eax_179 & ~0x03) + 8;
								if ((Mem177[esi_157 + 4:byte] & 0x01) != 0x00)
									eax_186 = edx_181;
								eax_229 = ϕ(eax_180, eax_186);
								edi_191 = edi_190 + 0x01;
								if (edi_191 == eax_145)
									break;
								esi_230 = eax_229;
							}
						}
						edx_329 = ϕ(edx_330, edx_181);
						ecx_323 = ϕ(ecx_324, ecx_161);
						Mem200 = ϕ(Mem146, Mem177);
						eax_202 = Mem200[dwLoc24_241 + 4:word32];
						dwLoc24_252 = eax_202;
						SZP_204 = cond(eax_202);
						P_335 = SLICE(SZP_204, bool, 5);
					} while (eax_202 != 0x00);
				}
				P_333 = ϕ(P_334, P_335);
				edx_327 = ϕ(edx_328, edx_329);
				ecx_319 = ϕ(ecx_320, ecx_323);
				eax_318 = ϕ(eax_132, eax_202);
				SCZO_219 = cond(fp - 0x10);
				C_317 = SLICE(SCZO_219, bool, 1);
				O_332 = SLICE(SCZO_219, bool, 4);
				S_336 = SLICE(SCZO_219, bool, 0);
				Z_347 = SLICE(SCZO_219, bool, 2);
				return;
			}
l08062663:
			ecx_322 = ϕ(ecx_112, ecx_93);
			ebx_232 = ϕ(ebx_99, ebx_96);
			Mem231 = ϕ(Mem114, Mem95);
			eax_120 = 0x00;
			do
			{
				eax_123 = ϕ(eax_120, eax_125);
				Mem121 = ϕ(Mem231, Mem124);
				edx_122 = Mem121[0x0807D29C<p32>:word32];
				edx_122[eax_123 * 0x04] = 0x00;
				eax_125 = eax_123 + 0x01;
			} while (eax_125 < ebx_232);
			goto l080625C4;
		}
	}
	caml_stat_alloc();
	Mem95[0x0807D29C<p32>:word32] = eax_91;
	ebx_96 = 0x04;
	goto l08062663;
}

// 08062675: define caml_do_roots
// Called from:
//      caml_darken_all_roots
//      caml_compact_heap
define caml_do_roots
{
	ptr32 fp;
	word32 esi;
	word32 ebx;
	word32 dwArg04;
	Top_3 = 0;
	edi_18 = Mem16[0x08073B34<p32>:word32];
	if (edi_18 != 0x00)
	{
		dwLoc20_218 = 0x00;
		do
		{
			dwLoc20_224 = ϕ(dwLoc20_218, dwLoc20_226);
			Mem26 = ϕ(Mem23, Mem59);
			edi_24 = ϕ(edi_18, edi_62);
			esi_25 = edi_24 - 4;
			edx_27 = Mem26[esi_25 + 0x00:word32];
			eax_29 = 0x00;
			ebx_30 = 0x00;
			if (edx_27 >>u 0x0A != 0x00)
			{
				do
				{
					ebx_44 = ϕ(ebx_30, ebx_49);
					eax_36 = ϕ(eax_29, eax_50);
					eax_37 = edi_24 + eax_36 * 0x04;
					eax_40 = Mem39[eax_37 + 0x00:word32];
					dwArg04();
					ebx_49 = ebx_44 + 0x01;
					eax_50 = ebx_49;
					edx_51 = Mem41[esi_25 + 0x00:word32];
				} while (ebx_49 <u edx_51 >>u 0x0A);
			}
			ebx_130 = ϕ(ebx_30, ebx_49);
			v16_58 = dwLoc20_224 + 0x01;
			dwLoc20_226 = v16_58;
			edi_62 = 134691636[v16_58 * 0x04];
		} while (edi_62 != 0x00);
	}
	ebx_129 = ϕ(ebx, ebx_130);
	esi_125 = ϕ(esi, esi_25);
	edi_122 = ϕ(edi_18, edi_62);
	Mem67 = ϕ(Mem16, Mem59);
	eax_68 = Mem67[0x0807D2AC<p32>:word32];
	dwLoc20_227 = eax_68;
	if (eax_68 != 0x00)
	{
		do
		{
			dwLoc20_228 = ϕ(dwLoc20_227, dwLoc20_235);
			ebx_132 = ϕ(ebx_129, ebx_131);
			Mem76 = ϕ(Mem70, Mem112);
			edi_78 = Mem76[dwLoc20_228 + 0x00:word32];
			esi_79 = edi_78 - 4;
			eax_80 = Mem76[edi_78 + -4:word32];
			if (eax_80 >>u 0x0A != 0x00)
			{
				eax_86 = 0x00;
				ebx_87 = 0x00;
				do
				{
					ebx_97 = ϕ(ebx_87, ebx_102);
					eax_89 = ϕ(eax_86, eax_103);
					eax_90 = edi_78 + eax_89 * 0x04;
					eax_93 = Mem92[eax_90 + 0x00:word32];
					dwArg04();
					ebx_102 = ebx_97 + 0x01;
					eax_103 = ebx_102;
					edx_104 = Mem94[edi_78 + -4:word32];
				} while (edx_104 >>u 0x0A >u ebx_102);
			}
			ebx_131 = ϕ(ebx_132, ebx_102);
			Mem109 = ϕ(Mem76, Mem94);
			eax_111 = Mem109[dwLoc20_228 + 4:word32];
			dwLoc20_235 = eax_111;
		} while (eax_111 != 0x00);
	}
	ebx_128 = ϕ(ebx_129, ebx_131);
	esi_124 = ϕ(esi_125, esi_79);
	edi_121 = ϕ(edi_122, edi_78);
	Mem117 = ϕ(Mem70, Mem112);
	if (Mem117[0x0807D29C<p32>:word32] == 0x00)
		caml_init_frame_descriptors();
	eax_149 = Mem117[0x0807D294<p32>:word32];
	eax_152 = Mem151[0x08083EA8<p32>:word32];
	eax_154 = Mem153[0x0807CFCC<p32>:word32];
	eax_156 = Mem155[0x0807D2A0<p32>:word32];
	caml_do_local_roots();
	caml_scan_global_roots();
	caml_final_do_strong_roots();
	eax_187 = Mem179[0x0807D298<p32>:word32];
	SZP_188 = cond(eax_187);
	P_299 = SLICE(SZP_188, bool, 5);
	if (eax_187 != 0x00)
	{
		eax_187();
		P_300 = SLICE(SCZOP_201, bool, 5);
	}
	P_298 = ϕ(P_299, P_300);
	edx_296 = ϕ(edx_181, edx_199);
	ecx_295 = ϕ(ecx_162, ecx_200);
	eax_294 = ϕ(eax_187, eax_198);
	SCZO_204 = cond(fp - 0x10);
	C_293 = SLICE(SCZO_204, bool, 1);
	O_297 = SLICE(SCZO_204, bool, 4);
	S_301 = SLICE(SCZO_204, bool, 0);
	Z_303 = SLICE(SCZO_204, bool, 2);
}

// 08062796: define caml_darken_all_roots
// Called from:
//      start_cycle
define caml_darken_all_roots
{
	Top_3 = 0;
	caml_do_roots();
	C_17 = SLICE(SCZO_11, bool, 1);
	O_18 = SLICE(SCZO_11, bool, 4);
	S_19 = SLICE(SCZO_11, bool, 0);
	Z_20 = SLICE(SCZO_11, bool, 2);
}

// 080627AA: define caml_oldify_local_roots
// Called from:
//      caml_empty_minor_heap
define caml_oldify_local_roots
{
	ptr32 fp;
	Top_3 = 0;
	eax_18 = Mem16[0x0807D2B0<p32>:word32];
	dwLoc20_465 = eax_18;
	eax_20 = Mem19[0x0807D2A4<p32>:word32];
	if (eax_18 <= eax_20)
	{
		edi_24 = 134691636[eax_18 * 0x04];
		if (edi_24 != 0x00)
		{
			do
			{
				dwLoc20_469 = ϕ(dwLoc20_465, dwLoc20_472);
				Mem31 = ϕ(Mem19, Mem79);
				edi_29 = ϕ(edi_24, edi_85);
				esi_30 = edi_29 - 4;
				edx_32 = Mem31[esi_30 + 0x00:word32];
				eax_34 = 0x00;
				ebx_35 = 0x00;
				if (edx_32 >>u 0x0A != 0x00)
				{
					do
					{
						ebx_59 = ϕ(ebx_35, ebx_66);
						Mem43 = ϕ(Mem31, Mem69);
						eax_41 = ϕ(eax_34, eax_67);
						edx_42 = edi_29 + eax_41 * 0x04;
						eax_44 = Mem43[edx_42 + 0x00:word32];
						al_45 = SLICE(eax_44, byte, 0);
						if ((al_45 & 0x01) == 0x00 && (eax_44 <u Mem43[0x08080410<p32>:word32] && eax_44 >u Mem43[0x0808040C<p32>:word32]))
							caml_oldify_one();
						Mem69 = ϕ(Mem43, Mem43, Mem43, Mem56);
						ebx_66 = ebx_59 + 0x01;
						eax_67 = ebx_66;
						edx_70 = Mem69[esi_30 + 0x00:word32];
					} while (ebx_66 <u edx_70 >>u 0x0A);
				}
				v23_78 = dwLoc20_469 + 0x01;
				dwLoc20_472 = v23_78;
				eax_80 = Mem79[0x0807D2A4<p32>:word32];
				if (eax_80 < v23_78)
					break;
				edi_85 = 134691636[v23_78 * 0x04];
			} while (edi_85 != 0x00);
		}
	}
	eax_90 = ϕ(eax_20, eax_20, eax_80, eax_80);
	Mem91[0x0807D2B0<p32>:word32] = eax_90;
	ecx_92 = Mem91[0x0807D2AC<p32>:word32];
	dwLoc20_473 = ecx_92;
	if (ecx_92 != 0x00)
	{
		do
		{
			dwLoc20_474 = ϕ(dwLoc20_473, dwLoc20_480);
			Mem100 = ϕ(Mem94, Mem151);
			edi_102 = Mem100[dwLoc20_474 + 0x00:word32];
			eax_104 = Mem100[edi_102 + -4:word32];
			if (eax_104 >>u 0x0A != 0x00)
			{
				eax_110 = 0x00;
				ebx_111 = 0x00;
				do
				{
					ebx_131 = ϕ(ebx_111, ebx_138);
					Mem115 = ϕ(Mem100, Mem141);
					eax_113 = ϕ(eax_110, eax_139);
					edx_114 = edi_102 + eax_113 * 0x04;
					eax_116 = Mem115[edx_114 + 0x00:word32];
					al_117 = SLICE(eax_116, byte, 0);
					if ((al_117 & 0x01) == 0x00 && (eax_116 <u Mem115[0x08080410<p32>:word32] && eax_116 >u Mem115[0x0808040C<p32>:word32]))
						caml_oldify_one();
					Mem141 = ϕ(Mem115, Mem115, Mem128, Mem115);
					ebx_138 = ebx_131 + 0x01;
					eax_139 = ebx_138;
					edx_142 = Mem141[edi_102 + -4:word32];
				} while (ebx_138 <u edx_142 >>u 0x0A);
			}
			Mem148 = ϕ(Mem100, Mem141);
			edx_150 = Mem148[dwLoc20_474 + 4:word32];
			dwLoc20_480 = edx_150;
		} while (edx_150 != 0x00);
	}
	Mem156 = ϕ(Mem94, Mem151);
	if (Mem156[0x0807D29C<p32>:word32] == 0x00)
		caml_init_frame_descriptors();
	ecx_196 = Mem156[0x0807D2A0<p32>:word32];
	dwLoc20_481 = ecx_196;
	edx_199 = Mem198[0x0807CFCC<p32>:word32];
	eax_200 = Mem198[0x08083EA8<p32>:word32];
	dwLoc24_482 = eax_200;
	if (ecx_196 != 0x00)
	{
		do
		{
			while (true)
			{
				dwLoc24_617 = ϕ(dwLoc24_482, dwLoc24_617, dwLoc24_487);
				dwLoc20_484 = ϕ(dwLoc20_481, dwLoc20_594, dwLoc20_486);
				edx_208 = ϕ(edx_199, edx_452, edx_237);
				Mem206 = ϕ(Mem201, Mem449, Mem239);
				esi_207 = Mem206[0x08083EA0<p32>:word32];
				eax_210 = edx_208 >>u 0x03;
				eax_211 = eax_210 & esi_207;
				ecx_212 = Mem206[0x0807D29C<p32>:word32];
				ebx_213 = ecx_212[eax_211 * 0x04];
				if (Mem206[ebx_213 + 0x00:word32] != edx_208)
				{
					do
					{
						eax_216 = ϕ(eax_211, eax_219);
						eax_217 = eax_216 + 0x01;
						eax_219 = eax_217 & esi_207;
						ebx_222 = ecx_212[eax_219 * 0x04];
					} while (Mem206[ebx_222 + 0x00:word32] != edx_208);
				}
				ebx_226 = ϕ(ebx_213, ebx_222);
				if (Mem206[ebx_226 + 4:word16] == ~0x00)
					break;
				esi_382 = CONVERT(Mem206[ebx_226 + 6:word16], word16, word32);
				if (esi_382 > 0x00)
				{
					edi_388 = ebx_226 + 8;
					while (true)
					{
						esi_424 = ϕ(esi_382, esi_434);
						Mem390 = ϕ(Mem206, Mem443);
						edi_389 = ϕ(edi_388, edi_454);
						edx_391 = CONVERT(Mem390[edi_389 + 0x00:word16], word16, word32);
						dl_392 = SLICE(edx_391, byte, 0);
						if ((dl_392 & 0x01) != 0x00)
							edx_404 = dwLoc24_617 + (edx_391 >> 0x01) * 0x04;
						else
							edx_398 = edx_391 + dwLoc20_484;
						edx_405 = ϕ(edx_404, edx_398);
						eax_407 = Mem390[edx_405 + 0x00:word32];
						al_408 = SLICE(eax_407, byte, 0);
						if ((al_408 & 0x01) == 0x00 && (eax_407 <u Mem390[0x08080410<p32>:word32] && eax_407 >u Mem390[0x0808040C<p32>:word32]))
							caml_oldify_one();
						Mem443 = ϕ(Mem390, Mem390, Mem390, Mem420);
						esi_434 = esi_424 - 0x01;
						if (esi_434 <= 0x00)
							break;
						edi_454 = edi_389 + 0x02;
					}
				}
				Mem442 = ϕ(Mem206, Mem443);
				eax_444 = CONVERT(Mem442[ebx_226 + 4:word16], word16, word32);
				v22_448 = dwLoc20_484 + (eax_444 & 0xFFFC);
				dwLoc20_594 = v22_448;
				edx_452 = Mem449[v22_448 + -4:word32];
			}
			edx_235 = Mem206[dwLoc20_484 + 0x08:word32];
			dwLoc20_486 = edx_235;
			edx_237 = Mem236[dwLoc20_484 + 0x0C:word32];
			eax_238 = Mem236[dwLoc20_484 + 0x10:word32];
			dwLoc24_487 = eax_238;
		} while (edx_235 != 0x00);
	}
	Mem242 = ϕ(Mem201, Mem239);
	esi_243 = Mem242[0x0807D294<p32>:word32];
	if (esi_243 != 0x00)
	{
		do
		{
			Mem252 = ϕ(Mem245, Mem301);
			esi_251 = ϕ(esi_243, esi_302);
			edi_250 = 0x00;
			if (Mem252[esi_251 + 4:word32] > 0x00)
			{
				do
				{
					edi_293 = ϕ(edi_250, edi_295);
					Mem256 = ϕ(Mem252, Mem297);
					ebx_257 = 0x00;
					if (Mem256[esi_251 + 8:word32] > 0x00)
					{
						do
						{
							Mem265 = ϕ(Mem256, Mem289);
							ebx_261 = ϕ(ebx_257, ebx_287);
							edx_262 = ebx_261 * 0x04;
							edx_266 = edx_262 + (esi_251 + 0x0C)[edi_293 * 0x04];
							eax_267 = Mem265[edx_266 + 0x00:word32];
							al_268 = SLICE(eax_267, byte, 0);
							if ((al_268 & 0x01) == 0x00 && (eax_267 <u Mem265[0x08080410<p32>:word32] && eax_267 >u Mem265[0x0808040C<p32>:word32]))
								caml_oldify_one();
							Mem289 = ϕ(Mem265, Mem265, Mem265, Mem279);
							ebx_287 = ebx_261 + 0x01;
						} while (Mem289[esi_251 + 8:word32] > ebx_287);
					}
					Mem297 = ϕ(Mem256, Mem289);
					edi_295 = edi_293 + 0x01;
				} while (Mem297[esi_251 + 4:word32] > edi_295);
			}
			Mem301 = ϕ(Mem252, Mem297);
			esi_302 = Mem301[esi_251 + 0x00:word32];
		} while (esi_302 != 0x00);
	}
	caml_scan_global_young_roots();
	caml_final_do_young_roots();
	eax_360 = Mem353[0x0807D298<p32>:word32];
	SZP_361 = cond(eax_360);
	P_628 = SLICE(SZP_361, bool, 5);
	if (eax_360 != 0x00)
	{
		eax_360();
		P_629 = SLICE(SCZOP_369, bool, 5);
	}
	P_627 = ϕ(P_628, P_629);
	edx_625 = ϕ(edx_355, edx_367);
	ecx_624 = ϕ(ecx_351, ecx_368);
	eax_623 = ϕ(eax_360, eax_366);
	SCZO_372 = cond(fp - 0x10);
	C_622 = SLICE(SCZO_372, bool, 1);
	O_626 = SLICE(SCZO_372, bool, 4);
	S_630 = SLICE(SCZO_372, bool, 0);
	Z_632 = SLICE(SCZO_372, bool, 2);
}

// 08062A30: define caml_iterate_global_roots
// Called from:
//      caml_scan_global_roots
//      caml_scan_global_young_roots
define caml_iterate_global_roots
{
	ptr32 fp;
	word32 eax;
	word32 edx;
	Top_3 = 0;
	ebx_18 = Mem13[edx + 4:word32];
	SZP_19 = cond(ebx_18);
	P_68 = SLICE(SZP_19, bool, 5);
	if (ebx_18 != 0x00)
	{
		do
		{
			edx_32 = ϕ(edx, edx_35);
			Mem24 = ϕ(Mem13, Mem29);
			ebx_23 = ϕ(ebx_18, ebx_37);
			eax_25 = Mem24[ebx_23 + 0x00:word32];
			eax_28 = Mem27[eax_25 + 0x00:word32];
			eax();
			ebx_37 = Mem29[ebx_23 + 4:word32];
			SZP_38 = cond(ebx_37);
			P_69 = SLICE(SZP_38, bool, 5);
		} while (ebx_37 != 0x00);
	}
	P_67 = ϕ(P_68, P_69);
	edx_65 = ϕ(edx, edx_35);
	eax_64 = ϕ(eax, eax_34);
	SCZO_44 = cond(fp - 0x0C);
	C_63 = SLICE(SCZO_44, bool, 1);
	O_66 = SLICE(SCZO_44, bool, 4);
	S_70 = SLICE(SCZO_44, bool, 0);
	Z_72 = SLICE(SCZO_44, bool, 2);
}

// 08062A5C: define caml_scan_global_roots
// Called from:
//      caml_do_roots
define caml_scan_global_roots
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	caml_iterate_global_roots();
	caml_iterate_global_roots();
	caml_iterate_global_roots();
	SCZO_42 = cond(fp - 0x08);
	C_50 = SLICE(SCZO_42, bool, 1);
	O_51 = SLICE(SCZO_42, bool, 4);
	S_52 = SLICE(SCZO_42, bool, 0);
	Z_53 = SLICE(SCZO_42, bool, 2);
}

// 08062A90: define caml_insert_global_root
// Called from:
//      caml_register_generational_global_root
//      caml_register_global_root
//      caml_scan_global_young_roots
//      caml_modify_generational_global_root
define caml_insert_global_root
{
	ptr32 fp;
	word32 eax;
	word32 edx;
	Top_3 = 0;
	eax_23 = Mem19[eax + 72:word32];
	ecx_25 = eax_23;
	edx_26 = eax;
	if (eax_23 >= 0x00)
	{
		do
		{
			while (true)
			{
				Mem34 = ϕ(Mem24, Mem34, Mem47);
				ecx_33 = ϕ(ecx_25, ecx_33, ecx_48);
				edx_32 = ϕ(edx_26, edx_184, edx_32);
				eax_35 = (edx_32 + 4)[ecx_33 * 0x04];
				if (eax_35 == 0x00 || Mem34[eax_35 + 0x00:word32] >=u edx)
					break;
				edx_184 = eax_35;
			}
			(fp - 96)[ecx_33 * 0x04] = edx_32;
			ecx_48 = ecx_33 - 0x01;
		} while (ecx_48 != ~0x00);
	}
	ecx_253 = ϕ(ecx_25, ecx_48);
	Mem52 = ϕ(Mem24, Mem47);
	edx_51 = ϕ(edx_26, edx_32);
	eax_53 = Mem52[edx_51 + 4:word32];
	SZP_54 = cond(eax_53);
	P_257 = SLICE(SZP_54, bool, 5);
	if (eax_53 == 0x00 || Mem52[eax_53 + 0x00:word32] != edx)
	{
		eax_63 = Mem52[0x0807D3CC<p32>:word32] *s 69069;
		eax_64 = eax_63 + 0x6255;
		Mem65[0x0807D3CC<p32>:word32] = eax_63 + 0x6255;
		edx_67 = eax_63 + 0x6255 & 0xC0000000;
		esi_68 = 0x00;
		if (edx_67 == 0xC0000000)
		{
			do
			{
				eax_73 = ϕ(eax_64, eax_74);
				esi_71 = ϕ(esi_68, esi_72);
				esi_72 = esi_71 + 0x01;
				eax_74 = eax_73 << 0x02;
				edx_76 = eax_74 & 0xC0000000;
			} while ((eax_74 & 0xC0000000) == 0xC0000000);
		}
		edx_137 = ϕ(edx_67, edx_76);
		esi_87 = ϕ(esi_68, esi_72);
		if (eax_23 < esi_87)
		{
			eax_91 = eax_23 + 0x01;
			if (eax_23 + 0x01 <= esi_87)
			{
				edx_94 = fp - 96;
				do
				{
					eax_97 = ϕ(eax_91, eax_99);
					(fp - 96)[eax_97 * 0x04] = eax;
					eax_99 = eax_97 + 0x01;
				} while (eax_99 <= esi_87);
			}
			edx_138 = ϕ(edx_137, edx_94);
			Mem108[eax + 72:word32] = esi_87;
		}
		edx_136 = ϕ(edx_137, edx_138);
		eax_110 = esi_87 * 0x04 + 0x08;
		caml_stat_alloc();
		Mem152[eax_148 + 0x00:word32] = edx;
		SZP_153 = cond(esi_87);
		P_258 = SLICE(SZP_153, bool, 5);
		if (esi_87 >= 0x00)
		{
			edx_157 = 0x00;
			do
			{
				Mem161 = ϕ(Mem152, Mem166);
				edx_160 = ϕ(edx_157, edx_167);
				ecx_162 = (fp - 96)[edx_160 * 0x04];
				ebx_163 = (ecx_162 + 4)[edx_160 * 0x04];
				(eax_148 + 4)[edx_160 * 0x04] = ebx_163;
				(ecx_162 + 4)[edx_160 * 0x04] = eax_148;
				edx_167 = edx_160 + 0x01;
			} while (edx_167 <= esi_87);
		}
	}
	P_256 = ϕ(P_257, P_258, P_258);
	edx_254 = ϕ(edx_51, edx_149, edx_167);
	ecx_252 = ϕ(ecx_253, ecx_150, ecx_162);
	eax_251 = ϕ(eax_53, eax_148, eax_148);
	SCZO_174 = cond(fp - 0x10);
	C_250 = SLICE(SCZO_174, bool, 1);
	O_255 = SLICE(SCZO_174, bool, 4);
	S_260 = SLICE(SCZO_174, bool, 0);
	Z_263 = SLICE(SCZO_174, bool, 2);
}

// 08062B77: define caml_register_generational_global_root
define caml_register_generational_global_root
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[edx + 0x00:word32];
	SZP = cond(al & 0x01);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
l08062BC8:
		esp = ebp;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
	}
	else
	{
		SCZO = cond(eax - Mem0[0x08080410<p32>:word32]);
		if (Test(ULT,C))
		{
			SCZO = cond(eax - Mem0[0x0808040C<p32>:word32]);
			if (Test(UGT,CZ))
			{
				eax = 0x0807D320;
				caml_insert_global_root();
				goto l08062BC8;
			}
		}
		ecx = eax;
		ecx >>= 0x17;
		eax >>= 0x0C;
		eax &= 0x07FF;
		ecx = 0x08084000[ecx * 0x04];
		SZP = cond(Mem0[ecx + eax:byte] & 0x01);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			eax = 0x0807D380;
			caml_insert_global_root();
		}
		goto l08062BC8;
	}
}

// 08062BCA: define caml_register_global_root
// Called from:
//      caml_install_signal_handler
//      caml_register_named_value
//      caml_record_backtrace
define caml_register_global_root
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	edx = Mem0[ebp + 8:word32];
	eax = 0x0807D2C0;
	caml_insert_global_root();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062BDF: define caml_scan_global_young_roots
// Called from:
//      caml_oldify_local_roots
define caml_scan_global_young_roots
{
	ptr32 fp;
	word32 dwArg04;
	word32 ecx;
	Top_3 = 0;
	caml_iterate_global_roots();
	caml_iterate_global_roots();
	ebx_32 = Mem10[0x0807D324<p32>:word32];
	if (ebx_32 != 0x00)
	{
		do
		{
			ebx_37 = ϕ(ebx_32, ebx_48);
			edx_39 = Mem10[ebx_37 + 0x00:word32];
			caml_insert_global_root();
			ebx_48 = Mem10[ebx_37 + 4:word32];
		} while (ebx_48 != 0x00);
		eax_53 = Mem10[0x0807D324<p32>:word32];
		if (eax_53 != 0x00)
		{
			while (true)
			{
				Mem59 = ϕ(Mem10, Mem62);
				eax_58 = ϕ(eax_53, eax_97);
				ebx_60 = Mem59[eax_58 + 4:word32];
				caml_stat_free();
				if (ebx_60 == 0x00)
					break;
				eax_97 = ebx_60;
			}
		}
	}
	ecx_117 = ϕ(ecx, ecx_46, ecx_46);
	eax_115 = ϕ(eax_25, eax_53, eax_63);
	Mem72 = ϕ(Mem10, Mem10, Mem62);
	edx_73 = Mem72[0x0807D368<p32>:word32];
	SZP_74 = cond(edx_73);
	P_123 = SLICE(SZP_74, bool, 5);
	if (edx_73 >= 0x00)
	{
		eax_78 = 0x00;
		ecx_79 = 134730532;
		do
		{
			eax_81 = ϕ(eax_78, eax_83);
			134730532[eax_81 * 0x04] = 0x00;
			eax_83 = eax_81 + 0x01;
		} while (eax_83 <= edx_73);
	}
	ecx_116 = ϕ(ecx_117, ecx_79);
	eax_114 = ϕ(eax_115, eax_83);
	Mem87[0x0807D368<p32>:word32] = 0x00;
	SCZO_92 = cond(fp - 0x08);
	C_113 = SLICE(SCZO_92, bool, 1);
	O_121 = SLICE(SCZO_92, bool, 4);
	S_125 = SLICE(SCZO_92, bool, 0);
	Z_130 = SLICE(SCZO_92, bool, 2);
}

// 08062C6C: define caml_delete_global_root
// Called from:
//      caml_modify_generational_global_root
//      caml_remove_generational_global_root
//      caml_remove_global_root
define caml_delete_global_root
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	ebx = eax;
	ecx = eax;
	eax = Mem0[eax + 72:word32];
	Mem0[ebp + -0x006C:word32] = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		esi = eax;
		edi = ebp - 92;
		do
		{
			eax = (ecx + 4)[esi * 0x04];
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NE,Z))
			{
				SCZO = cond(Mem0[eax + 0x00:word32] - edx);
				if (Test(ULT,C))
				{
					ecx = eax;
					continue;
				}
			}
			edi[esi * 0x04] = ecx;
			--esi;
			SCZO = cond(esi - ~0x00);
		} while (Test(NE,Z));
	}
	ecx = Mem0[ecx + 4:word32];
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(Mem0[ecx + 0x00:word32] - edx);
		if (Test(EQ,Z))
		{
			SCZO = cond(Mem0[ebp + -0x006C:word32] - 0x00);
			if (Test(NS,S))
			{
				eax = 0x00;
				edi = ebp - 92;
				do
				{
					edx = edi[eax * 0x04];
					SCZO = cond((edx + 4)[eax * 0x04] - ecx);
					if (Test(EQ,Z))
					{
						esi = (ecx + 4)[eax * 0x04];
						(edx + 4)[eax * 0x04] = esi;
					}
					++eax;
					SCZO = cond(Mem0[ebx + 72:word32] - eax);
				} while (Test(GE,SO));
			}
			Mem0[esp + 0x00:word32] = ecx;
			caml_stat_free();
			eax = Mem0[ebx + 72:word32];
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(GT,SZO))
			{
				SCZO = cond((ebx + 4)[eax * 0x04] - 0x00);
				if (Test(EQ,Z))
				{
					do
					{
						--eax;
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(LE,SZO))
						{
							Mem0[ebx + 72:word32] = eax;
							goto l08062D01;
						}
						SCZO = cond((ebx + 4)[eax * 0x04] - 0x00);
					} while (Test(EQ,Z));
					Mem0[ebx + 72:word32] = eax;
				}
			}
		}
	}
l08062D01:
	esp += 0x7C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062D09: define caml_modify_generational_global_root
define caml_modify_generational_global_root
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = esi;
	esi = Mem0[ebp + 8:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[esi + 0x00:word32];
	edx = ebx;
	edx &= 0x01;
	SZ = cond(edx);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		SCZO = cond(ebx - Mem0[0x08080410<p32>:word32]);
		if (Test(ULT,C))
		{
			SCZO = cond(ebx - Mem0[0x0808040C<p32>:word32]);
			if (Test(UGT,CZ))
			{
				SZP = cond(al & 0x01);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
					edx = eax;
					edx >>= 0x17;
					eax >>= 0x0C;
					eax &= 0x07FF;
					edx = 0x08084000[edx * 0x04];
					SZP = cond(Mem0[edx + eax:byte] & 0x01);
					O = false;
					C = false;
					if (Test(NE,Z))
					{
						edx = esi;
						eax = 0x0807D380;
						caml_delete_global_root();
						edx = esi;
						eax = 0x0807D320;
						caml_insert_global_root();
					}
					goto l08062DCF;
				}
				goto l08062D75;
			}
		}
	}
	SZP = cond(al & 0x01);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(NE,Z))
			goto l08062DCF;
l08062D75:
		SCZO = cond(ebx - Mem0[0x08080410<p32>:word32]);
		if (Test(ULT,C))
		{
			SCZO = cond(ebx - Mem0[0x0808040C<p32>:word32]);
			if (Test(UGT,CZ))
			{
				edx = esi;
				eax = 0x0807D320;
				caml_insert_global_root();
				goto l08062DCF;
			}
		}
		edx = ebx;
		edx >>= 0x17;
		eax = ebx;
		eax >>= 0x0C;
		eax &= 0x07FF;
		edx = 0x08084000[edx * 0x04];
		SZP = cond(Mem0[edx + eax:byte] & 0x01);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			edx = esi;
			eax = 0x0807D380;
			caml_insert_global_root();
		}
		goto l08062DCF;
	}
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(EQ,Z))
		goto l08062DCF;
	SCZO = cond(eax - Mem0[0x08080410<p32>:word32]);
	if (Test(ULT,C))
	{
		SCZO = cond(eax - Mem0[0x0808040C<p32>:word32]);
		if (Test(UGT,CZ))
		{
			edx = esi;
			eax = 0x0807D320;
			caml_delete_global_root();
l08062DCF:
			Mem0[esi + 0x00:word32] = ebx;
			ebx = Mem0[esp + 0x00:word32];
			esi = Mem0[esp + 4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	edx = eax;
	edx >>= 0x17;
	eax >>= 0x0C;
	eax &= 0x07FF;
	edx = 0x08084000[edx * 0x04];
	SZP = cond(Mem0[edx + eax:byte] & 0x01);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edx = esi;
		eax = 0x0807D380;
		caml_delete_global_root();
	}
	goto l08062DCF;
}

// 08062E16: define caml_remove_generational_global_root
define caml_remove_generational_global_root
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[edx + 0x00:word32];
	SZP = cond(al & 0x01);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
l08062E67:
		esp = ebp;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
	}
	else
	{
		SCZO = cond(eax - Mem0[0x08080410<p32>:word32]);
		if (Test(ULT,C))
		{
			SCZO = cond(eax - Mem0[0x0808040C<p32>:word32]);
			if (Test(UGT,CZ))
			{
				eax = 0x0807D320;
				caml_delete_global_root();
				goto l08062E67;
			}
		}
		ecx = eax;
		ecx >>= 0x17;
		eax >>= 0x0C;
		eax &= 0x07FF;
		ecx = 0x08084000[ecx * 0x04];
		SZP = cond(Mem0[ecx + eax:byte] & 0x01);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			eax = 0x0807D380;
			caml_delete_global_root();
		}
		goto l08062E67;
	}
}

// 08062E69: define caml_remove_global_root
// Called from:
//      caml_record_backtrace
define caml_remove_global_root
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	edx = Mem0[ebp + 8:word32];
	eax = 0x0807D2C0;
	caml_delete_global_root();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062E80: define caml_record_signal
// Called from:
//      handle_signal
define caml_record_signal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	0x08083EC0[eax * 0x04] = 0x01;
	Mem0[0x0807D3D0<p32>:word32] = 0x01;
	eax = Mem0[0x08080410<p32>:word32];
	Mem0[0x08080418<p32>:word32] = eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062EA7: define caml_enter_blocking_section_default
define caml_enter_blocking_section_default
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	Mem0[0x0807D3D8<p32>:word32] = 0x01;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062EB6: define caml_leave_blocking_section_default
define caml_leave_blocking_section_default
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	Mem0[0x0807D3D8<p32>:word32] = 0x00;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062EC5: define caml_try_leave_blocking_section_default
define caml_try_leave_blocking_section_default
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	eax = eax ^ eax;
	SZ = cond(eax);
	O = false;
	C = false;
	v9 = Mem0[0x0807D3D8<p32>:word32];
	Mem0[0x0807D3D8<p32>:word32] = eax;
	eax = v9;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062ED2: define caml_urge_major_slice
// Called from:
//      caml_realloc_ref_table
//      caml_adjust_gc_speed
//      caml_alloc_shr
define caml_urge_major_slice
{
	Top_3 = 0;
	Mem7[0x0807D3D4<p32>:word32] = 0x01;
	eax_8 = Mem7[0x08080410<p32>:word32];
	Mem9[0x08080418<p32>:word32] = eax_8;
}

// 08062EEB: define caml_convert_signal_number
// Called from:
//      unix_kill
//      decode_sigset
//      caml_install_signal_handler
define caml_convert_signal_number
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(SG,S))
	{
		SCZO = cond(eax - ~0x15);
		if (Test(UGT,CZ))
		{
			eax = ~eax;
			eax = 0x08071680[eax * 0x04];
		}
	}
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08062F05: define caml_rev_convert_signal_number
// Called from:
//      encode_sigset
//      alloc_process_status
//      caml_execute_signal
define caml_rev_convert_signal_number
{
	word32 dwArg04;
	Top_3 = 0;
	eax_8 = dwArg04;
	edx_9 = 0x01;
	ecx_10 = 0x08071680;
	SCZO_11 = cond(dwArg04 - 0x06);
	Z_12 = SLICE(SCZO_11, bool, 2);
	C_42 = SLICE(SCZO_11, bool, 1);
	O_51 = SLICE(SCZO_11, bool, 4);
	S_56 = SLICE(SCZO_11, bool, 0);
	if (dwArg04 == 0x06)
	{
		edx_25 = 0x00;
l08062F23:
		Z_63 = ϕ(Z_12, Z_18);
		S_55 = ϕ(S_56, S_57);
		O_50 = ϕ(O_51, O_52);
		C_41 = ϕ(C_42, C_43);
		edx_23 = ϕ(edx_25, edx_14);
		eax_27 = ~edx_23;
	}
	else
	{
		do
		{
			edx_14 = ϕ(edx_9, edx_19);
			SCZO_17 = cond(0x08071680[edx_14 * 0x04] - dwArg04);
			Z_18 = SLICE(SCZO_17, bool, 2);
			C_43 = SLICE(SCZO_17, bool, 1);
			O_52 = SLICE(SCZO_17, bool, 4);
			S_57 = SLICE(SCZO_17, bool, 0);
			if (0x08071680[edx_14 * 0x04] == dwArg04)
				goto l08062F23;
			edx_19 = edx_14 + 0x01;
			SCZO_20 = cond(edx_19 - 0x15);
			Z_21 = SLICE(SCZO_20, bool, 2);
			C_44 = SLICE(SCZO_20, bool, 1);
			O_53 = SLICE(SCZO_20, bool, 4);
			S_58 = SLICE(SCZO_20, bool, 0);
		} while (edx_19 != 0x15);
	}
	Z_62 = ϕ(Z_63, Z_21);
	S_54 = ϕ(S_55, S_58);
	O_49 = ϕ(O_50, O_53);
	edx_48 = ϕ(edx_23, edx_19);
	eax_45 = ϕ(eax_27, eax_8);
	C_40 = ϕ(C_41, C_44);
}

// 08062F33: define caml_execute_signal
// Called from:
//      caml_process_pending_signals
//      handle_signal
define caml_execute_signal
{
	ptr32 fp;
	word32 dwLoc9C;
	word32 dwArg04;
	word32 dwArg08;
	bool P;
	Top_3 = 0;
	ebp_7 = fp - 4;
	dwLocAC_101 = &dwLoc9C;
	sigemptyset(dwLocAC_101);
	dwLocAC_103 = &dwLoc9C;
	sigaddset(dwLocAC_103, dwArg04);
	dwLocA4_104 = &dwLoc9C;
	dwLocA8_105 = &dwLoc9C;
	sigprocmask(0x00, dwLocA8_105, dwLocA4_104);
	caml_rev_convert_signal_number();
	eax_35 = eax_28 * 0x02 + 1;
	eax_37 = Mem36[0x0807D3DC<p32>:word32];
	eax_38 = eax_37[dwArg04 * 0x04];
	fn08070AC8();
	if (dwArg08 == 0x00)
	{
		dwLocA8_118 = &dwLoc9C;
		sigprocmask(0x02, dwLocA8_118, 0x00);
		eax_67 = eax_40 & 0x03;
		SCZO_68 = cond((eax_40 & 0x03) - 0x02);
		Z_69 = SLICE(SCZO_68, bool, 2);
		C_122 = SLICE(SCZO_68, bool, 1);
		O_129 = SLICE(SCZO_68, bool, 4);
		S_134 = SLICE(SCZO_68, bool, 0);
		if ((eax_40 & 0x03) != 0x02)
			goto l08062FFF;
	}
	else
	{
		eax_48 = eax_40 & 0x03;
		SCZO_49 = cond((eax_40 & 0x03) - 0x02);
		Z_50 = SLICE(SCZO_49, bool, 2);
		C_123 = SLICE(SCZO_49, bool, 1);
		O_130 = SLICE(SCZO_49, bool, 4);
		S_135 = SLICE(SCZO_49, bool, 0);
		if ((eax_40 & 0x03) != 0x02)
			goto l08062FFF;
		dwLocAC_112 = &dwLoc9C;
		sigdelset(dwLocAC_112, dwArg04);
		dwLocA8_115 = &dwLoc9C;
		sigprocmask(0x02, dwLocA8_115, 0x00);
	}
	ecx_126 = ϕ(ecx_29, ecx_55);
	caml_raise();
l08062FFF:
	Z_138 = ϕ(Z_69, Z_50, Z_84);
	S_133 = ϕ(S_134, S_135, S_82);
	P_131 = ϕ(P, P, P_86);
	O_128 = ϕ(O_129, O_130, O_85);
	edx_127 = ϕ(edx_30, edx_30, edx_80);
	ecx_125 = ϕ(ecx_29, ecx_29, ecx_126);
	eax_124 = ϕ(eax_67, eax_48, eax_77);
	C_121 = ϕ(C_122, C_123, C_83);
	Mem88 = ϕ(Mem64, Mem39, Mem76);
	ebp_87 = ϕ(ebp_7, ebp_7, ebp_78);
	ebx_89 = Mem88[ebp_87 + -0x0C:word32];
	esi_90 = Mem88[ebp_87 + -8:word32];
	edi_91 = Mem88[ebp_87 + -4:word32];
	ebp_93 = Mem88[ebp_87 + 0x00:word32];
	esp_94 = ebp_87 + 4;
}

// 0806300C: define caml_process_pending_signals
// Called from:
//      caml_install_signal_handler
//      caml_leave_blocking_section
//      caml_enter_blocking_section
//      caml_garbage_collection
define caml_process_pending_signals
{
	ptr32 fp;
	word32 ecx;
	word32 edi;
	word32 edx;
	Top_3 = 0;
	esp_14 = fp - 0x1C;
	eax_15 = Mem13[0x0807D3D0<p32>:word32];
	SZP_16 = cond(eax_15);
	P_84 = SLICE(SZP_16, bool, 5);
	if (eax_15 != 0x00)
	{
		Mem20[0x0807D3D0<p32>:word32] = 0x00;
		ebx_21 = 0x00;
		esi_22 = 0x08083EC0;
		do
		{
			edx_81 = ϕ(edx, edx_80);
			edi_77 = ϕ(edi, edi_76);
			ecx_73 = ϕ(ecx, ecx_72);
			esp_32 = ϕ(esp_14, esp_52);
			Mem25 = ϕ(Mem20, Mem56);
			ebx_24 = ϕ(ebx_21, ebx_48);
			esi_23 = ϕ(esi_22, esi_63);
			eax_26 = esi_23[ebx_24 * 0x04];
			SZP_27 = cond(eax_26);
			P_86 = SLICE(SZP_27, bool, 5);
			if (eax_26 != 0x00)
			{
				esi_23[ebx_24 * 0x04] = 0x00;
				Mem33[esp_32 + 4:word32] = 0x00;
				Mem34[esp_32 + 0x00:word32] = ebx_24;
				caml_execute_signal();
			}
			edx_80 = ϕ(edx_37, edx_81);
			edi_76 = ϕ(edi_40, edi_77);
			ecx_72 = ϕ(ecx_36, ecx_73);
			eax_69 = ϕ(eax_35, eax_26);
			esi_63 = ϕ(esi_41, esi_23);
			Mem56 = ϕ(Mem34, Mem25);
			esp_52 = ϕ(esp_42, esp_32);
			ebx_47 = ϕ(ebx_39, ebx_24);
			ebx_48 = ebx_47 + 0x01;
		} while (ebx_48 != 0x41);
	}
	P_83 = ϕ(P_84, P_86);
	edx_78 = ϕ(edx, edx_80);
	edi_74 = ϕ(edi, edi_76);
	ecx_70 = ϕ(ecx, ecx_72);
	eax_68 = ϕ(eax_15, eax_69);
	SCZO_54 = cond(fp - 0x0C);
	C_67 = SLICE(SCZO_54, bool, 1);
	O_82 = SLICE(SCZO_54, bool, 4);
	S_87 = SLICE(SCZO_54, bool, 0);
	Z_91 = SLICE(SCZO_54, bool, 2);
}

// 0806305E: define caml_install_signal_handler
define caml_install_signal_handler
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x6C;
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = ebx;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	Mem0[ebp + -60:word32] = 0x00;
	eax = ebp - 56;
	Mem0[ebp + -92:word32] = eax;
	eax = ebp - 92;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -84:word32] = 0x01;
	Mem0[ebp + -88:word32] = 0x01;
	eax = ebp - 60;
	Mem0[ebp + -80:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_signal_number();
	esi = eax;
	SCZO = cond(eax - 0x40);
	if (Test(UGT,CZ))
	{
		Mem0[esp + 0x00:word32] = 0x08071648;
		caml_invalid_argument();
	}
	ecx = Mem0[ebp + 0x0C:word32];
	edi = ecx - 1;
	edx = 0x02;
	SCZO = cond(edi - 0x02);
	if (Test(ULE,CZ))
		edx = 0x080716D0[ecx * 0x04];
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = eax;
	caml_set_signal_action();
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		SCZO = cond(eax - 0x02);
		if (Test(NE,Z))
		{
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				Mem0[ebp + -60:word32] = 0x01;
			else
			{
				Mem0[esp + 0x00:word32] = 0x01;
				caml_sys_error();
			}
		}
		else
		{
			Mem0[esp + 4:word32] = 0x00;
			Mem0[esp + 0x00:word32] = 0x01;
			caml_alloc_small();
			Mem0[ebp + -60:word32] = eax;
			edx = Mem0[0x0807D3DC<p32>:word32];
			edx = edx[esi * 0x04];
			Mem0[eax + 0x00:word32] = edx;
		}
	}
	else
		Mem0[ebp + -60:word32] = 0x03;
	SZP = cond(Mem0[ebp + 0x0C:byte] & 0x01);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		SCZO = cond(Mem0[0x0807D3DC<p32>:word32] - 0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 4:word32] = 0x00;
			Mem0[esp + 0x00:word32] = 0x41;
			caml_alloc();
			Mem0[0x0807D3DC<p32>:word32] = eax;
			Mem0[esp + 0x00:word32] = 0x0807D3DC;
			caml_register_global_root();
		}
		eax = Mem0[ebp + 0x0C:word32];
		eax = Mem0[eax + 0x00:word32];
		Mem0[esp + 4:word32] = eax;
		esi <<= 0x02;
		esi += Mem0[0x0807D3DC<p32>:word32];
		SCZO = cond(esi);
		Mem0[esp + 0x00:word32] = esi;
		caml_modify();
	}
	caml_process_pending_signals();
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -60:word32];
	esp += 0x6C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080631AA: define caml_leave_blocking_section
// Called from:
//      unix_accept
//      unix_connect
//      unix_getaddrinfo
//      unix_gethostbyname
//      unix_gethostbyaddr
//      unix_getnameinfo
//      unix_lseek_64
//      unix_lseek
//      unix_open
//      unix_read
//      unix_select
//      unix_sendto_native
//      unix_send
//      unix_recvfrom
//      unix_recv
//      unix_sigsuspend
//      unix_sigprocmask
//      unix_sleep
//      unix_waitpid
//      unix_wait
//      unix_single_write
//      unix_write
//      caml_ml_close_channel
//      caml_seek_in
//      caml_channel_size
//      caml_do_read
//      do_write
//      caml_seek_out
//      caml_open_descriptor_in
//      caml_sys_system_command
//      caml_sys_open
define caml_leave_blocking_section
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	Mem0[0x0807CFD4<p32>:word32]();
	caml_process_pending_signals();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080631BD: define caml_enter_blocking_section
// Called from:
//      unix_accept
//      unix_connect
//      unix_getaddrinfo
//      unix_gethostbyname
//      unix_gethostbyaddr
//      unix_getnameinfo
//      unix_lseek_64
//      unix_lseek
//      unix_open
//      unix_read
//      unix_select
//      unix_sendto_native
//      unix_send
//      unix_recvfrom
//      unix_recv
//      unix_sigsuspend
//      unix_sigprocmask
//      unix_sleep
//      unix_waitpid
//      unix_wait
//      unix_single_write
//      unix_write
//      caml_ml_close_channel
//      caml_seek_in
//      caml_channel_size
//      caml_do_read
//      do_write
//      caml_seek_out
//      caml_open_descriptor_in
//      caml_sys_system_command
//      caml_sys_open
define caml_enter_blocking_section
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	while (true)
	{
		caml_process_pending_signals();
		Mem0[0x0807CFD0<p32>:word32]();
		eax = Mem0[0x0807D3D0<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
			break;
		Mem0[0x0807CFD4<p32>:word32]();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080631F0: define caml_init_signals
// Called from:
//      caml_main
define caml_init_signals
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0xB4;
	SCZO = cond(esp);
	Mem0[ebp + -20:word32] = 0x0807D400;
	Mem0[ebp + -0x0C:word32] = 0x2000;
	Mem0[ebp + -16:word32] = 0x00;
	Mem0[ebp + -0x00A0:word32] = 0x0806331F;
	Mem0[ebp + -28:word32] = 0x48000000;
	ebx = ebp - 0xA0;
	eax = ebp - 0x9C;
	Mem0[esp + 0x00:word32] = eax;
	eax = sigemptyset(Mem0[esp + 0x00:(ptr32 sigset_t)]);
	Mem0[0x0807D3E0<p32>:word32] = ebx;
	Mem0[esp + 4:word32] = 0x00;
	eax = ebp - 20;
	Mem0[esp + 0x00:word32] = eax;
	sigaltstack();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = 0x00;
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 0x00:word32] = 11;
		eax = sigaction(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 (struct "sigaction"))], Mem0[esp + 8:(ptr32 (struct "sigaction"))]);
	}
	esp += 0xB4;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08063272: define caml_set_signal_action
// Called from:
//      caml_install_signal_handler
define caml_set_signal_action
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x0134;
	eax = Mem0[ebp + 0x0C:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			Mem0[ebp + -0x0094:word32] = 0x01;
			Mem0[ebp + -16:word32] = 0x00;
		}
		else
		{
			Mem0[ebp + -0x0094:word32] = 0x080633A9;
			Mem0[ebp + -16:word32] = 0x00;
		}
	}
	else
	{
		Mem0[ebp + -0x0094:word32] = 0x00;
		Mem0[ebp + -16:word32] = 0x00;
	}
	ebx = ebp - 0x94;
	eax = ebp - 0x90;
	Mem0[esp + 0x00:word32] = eax;
	eax = sigemptyset(Mem0[esp + 0x00:(ptr32 sigset_t)]);
	eax = ebp - 288;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = ebx;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = sigaction(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 (struct "sigaction"))], Mem0[esp + 8:(ptr32 (struct "sigaction"))]);
	edx = eax;
	eax = ~0x00;
	SCZO = cond(edx - ~0x00);
	if (Test(NE,Z))
	{
		edx = Mem0[ebp + -288:word32];
		eax = 0x02;
		SCZO = cond(edx - 0x080633A9);
		if (Test(NE,Z))
		{
			SCZO = cond(edx - 0x01);
			al = CONVERT(Test(EQ,Z), bool, int8);
			eax = CONVERT(al, byte, word32);
		}
	}
	esp += 0x0134;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806331F: define segv_handler
define segv_handler
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0xB4;
	ebx = Mem0[ebp + 96:word32];
	SZP = cond(bl & 0x03);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		eax = ebp - 24;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x03;
		getrlimit64();
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			eax = Mem0[0x0807D3E0<p32>:word32];
			SCZO = cond(ebx - eax);
			if (Test(ULT,C))
			{
				eax -= Mem0[ebp + -24:word32];
				eax += ~0x1FFF;
				SCZO = cond(ebx - eax);
				if (Test(UGE,C))
					caml_raise_stack_overflow();
			}
		}
	}
	Mem0[ebp + -0x00A4:word32] = 0x00;
	Mem0[ebp + -32:word32] = 0x00;
	ebx = ebp - 0xA4;
	eax = ebp - 0xA0;
	Mem0[esp + 0x00:word32] = eax;
	eax = sigemptyset(Mem0[esp + 0x00:(ptr32 sigset_t)]);
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 0x00:word32] = 11;
	eax = sigaction(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 (struct "sigaction"))], Mem0[esp + 8:(ptr32 (struct "sigaction"))]);
	esp += 0xB4;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080633A9: define handle_signal
define handle_signal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	SCZO = cond(ebx - 0x40);
	if (Test(ULE,CZ))
	{
		Mem0[0x0807CFD8<p32>:word32]();
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 4:word32] = 0x01;
			Mem0[esp + 0x00:word32] = ebx;
			caml_execute_signal();
			Mem0[0x0807CFD0<p32>:word32]();
		}
		else
		{
			Mem0[esp + 0x00:word32] = ebx;
			esi = esi;
			caml_record_signal();
		}
	}
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080633EB: define caml_garbage_collection
// Called from:
//      fn080708CC
//      fn080708DD
define caml_garbage_collection
{
	Top_3 = 0;
	eax_9 = Mem6[0x0808040C<p32>:word32];
	Mem10[0x08080418<p32>:word32] = eax_9;
	if (eax_9 <=u Mem10[0x08080414<p32>:word32])
	{
		eax_13 = Mem10[0x0807D3D4<p32>:word32];
		if (eax_13 == 0x00)
		{
l08063411:
			caml_process_pending_signals();
			return;
		}
	}
	caml_minor_collection();
	goto l08063411;
}

// 08063418: define caml_ext_table_free
// Called from:
//      caml_sys_read_directory
//      caml_search_exe_in_path
define caml_ext_table_free
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	esi = Mem0[ebp + 8:word32];
	SCZO = cond(Mem0[ebp + 0x0C:word32] - 0x00);
	if (Test(NE,Z))
	{
		SCZO = cond(Mem0[esi + 0x00:word32] - 0x00);
		if (Test(GT,SZO))
		{
			ebx = 0x00;
			do
			{
				eax = Mem0[esi + 8:word32];
				eax = eax[ebx * 0x04];
				Mem0[esp + 0x00:word32] = eax;
				caml_stat_free();
				++ebx;
				SCZO = cond(Mem0[esi + 0x00:word32] - ebx);
			} while (Test(GT,SZO));
		}
	}
	eax = Mem0[esi + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_free();
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806345A: define caml_ext_table_add
// Called from:
//      caml_sys_read_directory
//      caml_decompose_path
//      caml_read_directory
define caml_ext_table_add
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[ebx + 4:word32];
	SCZO = cond(Mem0[ebx + 0x00:word32] - eax);
	if (Test(GE,SO))
	{
		edx = eax + eax;
		Mem0[ebx + 4:word32] = edx;
		eax <<= 0x03;
		SCZO = cond(eax);
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebx + 8:word32];
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_resize();
		Mem0[ebx + 8:word32] = eax;
	}
	eax = Mem0[ebx + 0x00:word32];
	edx = Mem0[ebx + 8:word32];
	ecx = Mem0[ebp + 0x0C:word32];
	edx[eax * 0x04] = ecx;
	v11 = Mem0[ebx + 0x00:word32] + 0x01;
	Mem0[ebx + 0x00:word32] = v11;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806349A: define caml_ext_table_init
// Called from:
//      caml_sys_read_directory
//      caml_search_exe_in_path
define caml_ext_table_init
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[ebx + 0x00:word32] = 0x00;
	Mem0[ebx + 4:word32] = eax;
	eax <<= 0x02;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_alloc();
	Mem0[ebx + 8:word32] = eax;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080634C4: define caml_aligned_malloc
// Called from:
//      caml_set_minor_heap_size
//      caml_alloc_for_heap
define caml_aligned_malloc
{
	ptr32 fp;
	word32 dwArg08;
	word32 dwArg04;
	word32 dwArg0C;
	Top_3 = 0;
	eax_16 = malloc(dwArg04 + 0x1000);
	edx_17 = eax_16;
	eax_18 = 0x00;
	SZP_19 = cond(eax_16);
	P_51 = SLICE(SZP_19, bool, 5);
	if (eax_16 != 0x00)
	{
		Mem24[dwArg0C + 0x00:word32] = eax_16;
		edx_25 = eax_16 + dwArg08;
		edx_26 = edx_25 & ~0x0FFF;
		eax_27 = (edx_25 & ~0x0FFF) + 0x1000;
		eax_28 = eax_27 - dwArg08;
	}
	edx_48 = ϕ(edx_17, edx_26);
	eax_47 = ϕ(eax_18, eax_28);
	SCZO_32 = cond(fp - 0x08);
	C_46 = SLICE(SCZO_32, bool, 1);
	O_49 = SLICE(SCZO_32, bool, 4);
	S_52 = SLICE(SCZO_32, bool, 0);
	Z_54 = SLICE(SCZO_32, bool, 2);
}

// 08063504: define caml_fatal_error_arg2
define caml_fatal_error_arg2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x0807D100<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	fprintf();
	eax = Mem0[ebp + 20:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x0807D100<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	fprintf();
	Mem0[esp + 0x00:word32] = 0x02;
	exit(Mem0[esp + 0x00:int32]);
}

// 0806354C: define caml_fatal_error_arg
define caml_fatal_error_arg
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x0807D100<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	fprintf();
	Mem0[esp + 0x00:word32] = 0x02;
	exit(Mem0[esp + 0x00:int32]);
}

// 08063579: define caml_fatal_error
// Called from:
//      caml_main
//      caml_init_major_heap
//      caml_realloc_ref_table
//      caml_alloc_shr
//      caml_init_gc
//      caml_final_update
define caml_fatal_error
{
	word32 dwArg04;
	eax_10 = Mem6[0x0807D100<p32>:word32];
	fputs(dwArg04, eax_10);
	exit(0x02);
}

// 0806359F: define caml_gc_message
// Called from:
//      start_cycle
//      realloc_gray_vals
//      mark_slice
//      sweep_slice
//      caml_major_collection_slice
//      caml_empty_minor_heap
//      caml_realloc_ref_table
//      caml_shrink_heap
//      caml_add_to_heap
//      caml_alloc_shr
//      compare_stack_overflow
//      caml_init_gc
//      caml_gc_compaction
//      test_and_compact
//      caml_gc_full_major
//      caml_gc_major
//      caml_gc_set
//      caml_compact_heap
//      caml_compact_heap_maybe
//      caml_final_do_calls
define caml_gc_message
{
	word32 dwArg04;
	word32 dwArg08;
	Top_3 = 0;
	eax_9 = dwArg04;
	SZP_10 = cond(dwArg04);
	S_13 = SLICE(SZP_10, bool, 0);
	P_56 = SLICE(SZP_10, bool, 5);
	Z_64 = SLICE(SZP_10, bool, 2);
	if (dwArg04 >= 0x00)
	{
		SZP_14 = cond(Mem6[0x0807F400<p32>:word32] & dwArg04);
		Z_17 = SLICE(SZP_14, bool, 2);
		P_54 = SLICE(SZP_14, bool, 5);
		S_58 = SLICE(SZP_14, bool, 0);
		if ((Mem6[0x0807F400<p32>:word32] & dwArg04) == 0x00)
		{
l080635DC:
			Z_62 = ϕ(Z_17, Z_63);
			S_57 = ϕ(S_58, S_59);
			P_53 = ϕ(P_54, P_55);
			O_51 = false;
			eax_50 = ϕ(eax_9, eax_30);
			C_48 = false;
			return;
		}
	}
	Z_63 = ϕ(Z_64, Z_17);
	S_59 = ϕ(S_13, S_58);
	P_55 = ϕ(P_56, P_54);
	eax_25 = Mem24[0x0807D100<p32>:word32];
	fprintf();
	eax_28 = Mem26[0x0807D100<p32>:word32];
	eax_30 = fflush(eax_28);
	goto l080635DC;
}

// 080635E0: define allocate_block
// Called from:
//      caml_fl_allocate
define allocate_block
{
	word32 edx;
	word32 eax;
	word32 ecx;
	word32 dwArg04;
	Top_3 = 0;
	edx_17 = dwArg04;
	ebx_19 = Mem16[dwArg04 + -4:word32];
	if (ebx_19 >>u 0x0A <u eax + 1)
	{
		edi_34 = ~(ebx_19 >>u 0x0A);
		v12_35 = Mem16[0x0807F420<p32>:word32] + edi_34;
		Mem36[0x0807F420<p32>:word32] = v12_35;
		edi_37 = Mem36[dwArg04 + 0x00:word32];
		Mem39[ecx + 0x00:word32] = edi_37;
		edi_41 = Mem39[0x0807CFDC<p32>:word32];
		if (Mem39[0x0807CFDC<p32>:word32] == dwArg04)
			edi_43 = ecx;
		edi_44 = ϕ(edi_41, edi_43);
		Mem45[0x0807CFDC<p32>:word32] = edi_44;
		Mem47[dwArg04 + -4:word32] = 0x00;
		if (Mem47[0x0807F424<p32>:word32] == 0x01)
		{
			esi_53 = Mem47[0x0807F428<p32>:word32];
			if (edx + 0x01 < esi_53 && 0x0807F440[(edx + 0x01) * 0x04] == dwArg04)
			{
				0x0807F440[(edx + 0x01) * 0x04] = ecx;
				goto l080636A0;
			}
			if (esi_53 - 0x01 == edx)
			{
				if (ecx == 0x0807CFE8)
					ecx_75 = 0x00;
				ecx_76 = ϕ(ecx, ecx_75);
				Mem77[0x0807F42C<p32>:word32] = ecx_76;
				Mem79[0x0807F428<p32>:word32] = esi_53 - 0x01;
l080636A0:
				ecx_137 = ϕ(ecx, ecx, ecx, ecx_76);
				ebx_91 = (ebx_19 >>u 0x0A) - eax;
				SCZO_92 = cond(ebx_91);
				C_136 = SLICE(SCZO_92, bool, 1);
				O_138 = SLICE(SCZO_92, bool, 4);
				S_139 = SLICE(SCZO_92, bool, 0);
				Z_145 = SLICE(SCZO_92, bool, 2);
				eax_97 = dwArg04 + ebx_91 * 0x04;
				return;
			}
		}
	}
	else
	{
		v15_25 = Mem16[0x0807F420<p32>:word32] - eax;
		Mem26[0x0807F420<p32>:word32] = v15_25;
		edi_28 = (ebx_19 >>u 0x0A) - eax;
		edi_30 = (edi_28 << 0x0A) + 0x0200;
		Mem32[dwArg04 + -4:word32] = edi_30;
	}
	Mem65 = ϕ(Mem32, Mem47, Mem47);
	if (Mem65[0x0807F424<p32>:word32] == 0x00)
		Mem71[0x0807CFF0<p32>:word32] = ecx;
	goto l080636A0;
}

// 080636B2: define caml_fl_init_merge
// Called from:
//      caml_fl_reset
//      caml_init_major_heap
//      mark_slice
define caml_fl_init_merge
{
	Top_3 = 0;
	Mem7[0x080803E0<p32>:word32] = 0x00;
	Mem8[0x0807CFDC<p32>:word32] = 0x0807CFE8;
}

// 080636CB: define truncate_flp
// Called from:
//      caml_fl_reset
//      caml_fl_merge_block
//      caml_fl_add_blocks
define truncate_flp
{
	word32 eax;
	word32 edx;
	bool P;
	Top_3 = 0;
	SCZO_15 = cond(eax - 0x0807CFE8);
	Z_16 = SLICE(SCZO_15, bool, 2);
	C_74 = SLICE(SCZO_15, bool, 1);
	O_84 = SLICE(SCZO_15, bool, 4);
	S_92 = SLICE(SCZO_15, bool, 0);
	if (eax != 0x0807CFE8)
	{
		edx_19 = Mem13[0x0807F428<p32>:word32];
		SZP_20 = cond(edx_19);
		P_89 = SLICE(SZP_20, bool, 5);
		if (edx_19 > 0x00)
		{
			edx_25 = edx_19 - 0x01;
			ecx_26 = 0x0807F440[(edx_19 - 0x01) * 0x04];
			if (eax <=u Mem13[ecx_26 + 0x00:word32])
			{
				while (true)
				{
					edx_30 = ϕ(edx_25, edx_44);
					SZP_31 = cond(edx_30);
					P_90 = SLICE(SZP_31, bool, 5);
					if (edx_30 <= 0x00)
						break;
					ecx_37 = edx_30 - 1;
					ebx_40 = 0x0807F440[ecx_37 * 0x04];
					if (eax >u Mem13[ebx_40 + 0x00:word32])
					{
						Mem45[0x0807F428<p32>:word32] = edx_30;
						goto l0806372A;
					}
					edx_44 = ecx_37;
				}
				Mem36[0x0807F428<p32>:word32] = edx_30;
			}
		}
l0806372A:
		P_88 = ϕ(P_89, P_89, P_90, P_90);
		edx_82 = ϕ(edx_19, edx_25, edx_30, edx_30);
		Mem47 = ϕ(Mem13, Mem13, Mem45, Mem36);
		SCZO_48 = cond(eax - Mem47[0x0807F42C<p32>:word32]);
		C_75 = SLICE(SCZO_48, bool, 1);
		O_85 = SLICE(SCZO_48, bool, 4);
		S_93 = SLICE(SCZO_48, bool, 0);
		Z_98 = SLICE(SCZO_48, bool, 2);
		if (eax <=u Mem47[0x0807F42C<p32>:word32])
			Mem50[0x0807F42C<p32>:word32] = 0x00;
	}
	else
	{
		Mem17[0x0807F428<p32>:word32] = 0x00;
		Mem18[0x0807F42C<p32>:word32] = 0x00;
	}
	Z_97 = ϕ(Z_16, Z_98, Z_98);
	S_91 = ϕ(S_92, S_93, S_93);
	P_86 = ϕ(P, P_88, P_88);
	O_83 = ϕ(O_84, O_85, O_85);
	edx_80 = ϕ(edx, edx_82, edx_82);
	C_73 = ϕ(C_74, C_75, C_75);
}

// 08063740: define caml_fl_reset
// Called from:
//      caml_compact_heap
define caml_fl_reset
{
	word32 edx;
	Top_3 = 0;
	Mem8[0x0807CFE8<p32>:word32] = 0x00;
	eax_9 = Mem8[0x0807F424<p32>:word32];
	SZP_10 = cond(eax_9);
	Z_13 = SLICE(SZP_10, bool, 2);
	P_38 = SLICE(SZP_10, bool, 5);
	S_41 = SLICE(SZP_10, bool, 0);
	O_11 = false;
	C_12 = false;
	if (eax_9 != 0x00)
	{
		SCZO_15 = cond(eax_9 - 0x01);
		Z_16 = SLICE(SCZO_15, bool, 2);
		C_31 = SLICE(SCZO_15, bool, 1);
		O_36 = SLICE(SCZO_15, bool, 4);
		S_40 = SLICE(SCZO_15, bool, 0);
		if (eax_9 == 0x01)
		{
			eax_17 = 0x0807CFE8;
			truncate_flp();
		}
	}
	else
		Mem14[0x0807CFF0<p32>:word32] = 0x0807CFE8;
	Z_43 = ϕ(Z_16, Z_13, Z_21);
	S_39 = ϕ(S_40, S_41, S_19);
	P_37 = ϕ(P_38, P_38, P_23);
	O_35 = ϕ(O_36, O_11, O_22);
	edx_33 = ϕ(edx, edx, edx_18);
	eax_32 = ϕ(eax_9, eax_9, eax_17);
	C_30 = ϕ(C_31, C_12, C_20);
	Mem24[0x0807F420<p32>:word32] = 0x00;
	caml_fl_init_merge();
}

// 08063784: define caml_fl_merge_block
// Called from:
//      caml_make_free_blocks
//      sweep_slice
define caml_fl_merge_block
{
	ptr32 fp;
	word32 dwArg04;
	bool P;
	Top_3 = 0;
	esi_21 = Mem20[dwArg04 + -4:word32];
	edx_24 = Mem20[0x0807F420<p32>:word32];
	eax_25 = edx_24 + 1 + (esi_21 >>u 0x0A);
	Mem26[0x0807F420<p32>:word32] = eax_25;
	ebx_27 = Mem26[0x0807CFDC<p32>:word32];
	ecx_29 = Mem28[ebx_27 + 0x00:word32];
	dwLoc18_192 = ecx_29;
	if (Mem30[0x0807F424<p32>:word32] == 0x01)
		truncate_flp();
	P_255 = ϕ(P, P_39);
	edx_41 = dwArg04 - 4;
	if (dwArg04 - 4 == Mem30[0x080803E0<p32>:word32])
	{
		eax_47 = Mem30[dwArg04 + -4:word32];
		eax_49 = (eax_47 >>u 0x0A) + 0x01;
		if (eax_49 <=u 0x003FFFFF)
		{
			esi_55 = eax_49 << 0x0A;
			Mem56[dwArg04 + -8:word32] = eax_49 << 0x0A;
			v14_57 = Mem56[0x0807F420<p32>:word32] + 0x01;
			Mem58[0x0807F420<p32>:word32] = v14_57;
l080637FA:
			Mem69 = ϕ(Mem58, Mem30);
			edx_65 = ϕ(edx_41, edx_53);
			esi_60 = ϕ(esi_55, esi_21);
			edi_64 = esi_60 >>u 0x0A;
			ecx_66 = edx_65 + edi_64 * 0x04;
			eax_72 = ecx_29 - 0x04;
			if (ecx_29 - 0x04 != ecx_66)
				eax_116 = ecx_66;
			else
			{
				ecx_76 = Mem69[ecx_29 + 0x00:word32];
				ecx_79 = Mem77[ecx_29 + -4:word32];
				ecx_82 = edi_64 + 1 + (ecx_79 >>u 0x0A);
				if (ecx_82 <=u 0x003FFFFF)
				{
					Mem87[ebx_27 + 0x00:word32] = ecx_76;
					if (Mem87[0x0807F424<p32>:word32] == 0x00)
					{
						eax_92 = Mem87[0x0807CFF0<p32>:word32];
						if (Mem87[0x0807CFF0<p32>:word32] == ecx_29)
							eax_97 = ebx_27;
						eax_98 = ϕ(eax_92, eax_97);
						Mem99[0x0807CFF0<p32>:word32] = eax_98;
					}
					esi_104 = (ecx_82 << 0x0A) + 0x0200;
					Mem107[edx_65 + -4:word32] = esi_104;
					eax_111 = edx_65 + (esi_104 >>u 0x0A) * 0x04;
					dwLoc18_204 = ecx_76;
				}
			}
			eax_247 = ϕ(eax_116, eax_72, eax_111);
			dwLoc18_208 = ϕ(dwLoc18_192, dwLoc18_192, dwLoc18_204);
			esi_132 = ϕ(esi_60, esi_60, esi_104);
			Mem121 = ϕ(Mem69, Mem80, Mem115);
			ecx_120 = ebx_27 - 4;
			edi_122 = Mem121[ebx_27 + -4:word32];
			ebx_126 = ebx_27 + (edi_122 >>u 0x0A) * 0x04;
			ebx_129 = edx_65 - 4;
			if (ebx_126 == ebx_129)
			{
				ebx_134 = esi_132 >>u 0x0A;
				ebx_135 = (edi_122 >>u 0x0A) + 1 + ebx_134;
				if (ebx_135 <=u 0x003FFFFE)
				{
					ebx_163 = (ebx_135 << 0x0A) + 0x0200;
					Mem165[ebx_27 + -4:word32] = ebx_163;
					goto l080638E1;
				}
			}
			ecx_140 = esi_132 >>u 0x0A;
			SZP_141 = cond(ecx_140);
			P_260 = SLICE(SZP_141, bool, 5);
			if (ecx_140 != 0x00)
			{
				esi_150 = esi_132 & ~0x0300;
				Mem155[edx_65 + -4:word32] = esi_150 | 0x0200;
				Mem158[edx_65 + 0x00:word32] = dwLoc18_208;
				Mem160[ebx_27 + 0x00:word32] = edx_65;
				Mem161[0x0807CFDC<p32>:word32] = edx_65;
			}
			else
			{
				Mem146[0x080803E0<p32>:word32] = edx_65;
				v19_147 = Mem146[0x0807F420<p32>:word32] - 0x01;
				Mem148[0x0807F420<p32>:word32] = v19_147;
			}
l080638E1:
			P_252 = ϕ(P_255, P_260, P_260);
			ecx_249 = ϕ(ecx_120, ecx_140, ecx_140);
			SCZO_175 = cond(fp - 0x10);
			C_245 = SLICE(SCZO_175, bool, 1);
			O_251 = SLICE(SCZO_175, bool, 4);
			S_261 = SLICE(SCZO_175, bool, 0);
			Z_270 = SLICE(SCZO_175, bool, 2);
			return;
		}
	}
	edx_53 = dwArg04;
	goto l080637FA;
}

// 080638E9: define caml_fl_add_blocks
// Called from:
//      caml_alloc_shr
define caml_fl_add_blocks
{
	word32 dwArg04;
	bool P;
	Top_3 = 0;
	eax_14 = dwArg04;
	edx_15 = Mem13[dwArg04 + -4:word32];
	ecx_17 = Mem13[0x0807F420<p32>:word32];
	edx_18 = ecx_17 + 1 + (edx_15 >>u 0x0A);
	Mem19[0x0807F420<p32>:word32] = edx_18;
	edx_20 = Mem19[0x0807F430<p32>:word32];
	if (dwArg04 >u edx_20)
	{
		Mem75[edx_20 + 0x00:word32] = dwArg04;
		if (edx_20 == Mem75[0x0807CFDC<p32>:word32] && dwArg04 <u Mem75[0x08083FCC<p32>:word32])
		{
			eax_80 = Mem75[dwArg04 + 4:word32];
			Mem81[0x0807CFDC<p32>:word32] = eax_80;
		}
		eax_138 = ϕ(eax_14, eax_14, eax_80);
		Mem82 = ϕ(Mem75, Mem75, Mem81);
		SCZO_83 = cond(Mem82[0x0807F424<p32>:word32] - 0x01);
		Z_84 = SLICE(SCZO_83, bool, 2);
		C_134 = SLICE(SCZO_83, bool, 1);
		O_146 = SLICE(SCZO_83, bool, 4);
		S_160 = SLICE(SCZO_83, bool, 0);
		if (Mem82[0x0807F424<p32>:word32] == 0x01)
		{
			eax_85 = Mem82[0x0807F428<p32>:word32];
			SCZO_86 = cond(eax_85 - 999);
			C_135 = SLICE(SCZO_86, bool, 1);
			O_147 = SLICE(SCZO_86, bool, 4);
			S_161 = SLICE(SCZO_86, bool, 0);
			Z_171 = SLICE(SCZO_86, bool, 2);
			if (eax_85 <= 999)
			{
				0x0807F440[eax_85 * 0x04] = edx_20;
				eax_90 = eax_85 + 0x01;
				SCZO_91 = cond(eax_85 + 0x01);
				C_136 = SLICE(SCZO_91, bool, 1);
				O_148 = SLICE(SCZO_91, bool, 4);
				S_162 = SLICE(SCZO_91, bool, 0);
				Z_172 = SLICE(SCZO_91, bool, 2);
				Mem92[0x0807F428<p32>:word32] = eax_85 + 0x01;
			}
		}
	}
	else
	{
		ecx_23 = Mem19[0x0807CFE8<p32>:word32];
		SZP_24 = cond(ecx_23);
		P_153 = SLICE(SZP_24, bool, 5);
		if (ecx_23 != 0x00 && dwArg04 >u ecx_23)
		{
			while (true)
			{
				ecx_30 = ϕ(ecx_23, ecx_40);
				edx_32 = Mem19[ecx_30 + 0x00:word32];
				SZP_33 = cond(edx_32);
				P_155 = SLICE(SZP_33, bool, 5);
				if (edx_32 == 0x00 || dwArg04 <=u edx_32)
					break;
				ecx_40 = edx_32;
			}
			ebx_42 = ecx_30;
			ecx_44 = edx_32;
		}
		else
			ebx_45 = 0x0807CFE8;
		P_151 = ϕ(P_153, P_155);
		ebx_57 = ϕ(ebx_45, ebx_42);
		ecx_54 = ϕ(ecx_23, ecx_44);
		edx_49 = dwArg04 + 4;
		esi_53 = Mem19[dwArg04 + 4:word32];
		Mem56[esi_53 + 0x00:word32] = ecx_54;
		Mem58[ebx_57 + 0x00:word32] = dwArg04;
		if (ebx_57 == Mem58[0x0807CFDC<p32>:word32] && dwArg04 <u Mem58[0x08083FCC<p32>:word32])
		{
			edx_63 = Mem58[dwArg04 + 4:word32];
			Mem64[0x0807CFDC<p32>:word32] = edx_63;
		}
		edx_143 = ϕ(edx_49, edx_49, edx_63);
		Mem65 = ϕ(Mem58, Mem58, Mem64);
		SCZO_66 = cond(Mem65[0x0807F424<p32>:word32] - 0x01);
		Z_67 = SLICE(SCZO_66, bool, 2);
		C_133 = SLICE(SCZO_66, bool, 1);
		O_145 = SLICE(SCZO_66, bool, 4);
		S_159 = SLICE(SCZO_66, bool, 0);
		if (Mem65[0x0807F424<p32>:word32] == 0x01)
			truncate_flp();
	}
	Z_170 = ϕ(Z_67, Z_72, Z_84, Z_171, Z_172);
	S_158 = ϕ(S_159, S_70, S_160, S_161, S_162);
	P_149 = ϕ(P_151, P_74, P, P, P);
	O_144 = ϕ(O_145, O_73, O_146, O_147, O_148);
	edx_142 = ϕ(edx_143, edx_69, edx_20, edx_20, edx_20);
	ecx_139 = ϕ(ecx_54, ecx_54, ecx_17, ecx_17, ecx_17);
	eax_137 = ϕ(eax_14, eax_14, eax_138, eax_85, eax_90);
	C_132 = ϕ(C_133, C_71, C_134, C_135, C_136);
}

// 080639A9: define caml_make_free_blocks
// Called from:
//      caml_init_major_heap
//      intern_add_to_heap
//      caml_compact_heap
define caml_make_free_blocks
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	word32 dwArg0C;
	word32 eax;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	esi_18 = dwArg04;
	edi_19 = dwArg08;
	SZP_20 = cond(dwArg08);
	P_117 = SLICE(SZP_20, bool, 5);
	if (dwArg08 != 0x00)
	{
		while (true)
		{
			P_120 = ϕ(P_117, P_118);
			edx_114 = ϕ(edx, edx_112);
			ecx_109 = ϕ(ecx, ecx_107);
			esi_33 = ϕ(esi_18, esi_72);
			edi_24 = ϕ(edi_19, edi_54);
			ebx_26 = 0x00400000;
			if (edi_24 <=u 0x00400000)
				ebx_28 = edi_24;
			ebx_29 = ϕ(ebx_26, ebx_28);
			eax_30 = ebx_29 - 1;
			eax_31 = eax_30 << 0x0A;
			Mem34[esi_33 + 0x00:word32] = eax_30 << 0x0A;
			if (dwArg0C != 0x00)
			{
				eax_39 = esi_33 + 4;
				caml_fl_merge_block();
			}
			P_118 = ϕ(P_120, P_50);
			edx_112 = ϕ(edx_114, edx_45);
			ecx_107 = ϕ(ecx_109, ecx_44);
			eax_104 = ϕ(eax_31, eax_43);
			edi_54 = edi_24 - ebx_29;
			if (edi_54 == 0x00)
				break;
			esi_72 = esi_33 + ebx_29 * 0x04;
		}
	}
	P_116 = ϕ(P_117, P_118);
	edx_110 = ϕ(edx, edx_112);
	ecx_105 = ϕ(ecx, ecx_107);
	eax_102 = ϕ(eax, eax_104);
	SCZO_60 = cond(fp - 0x10);
	C_101 = SLICE(SCZO_60, bool, 1);
	O_115 = SLICE(SCZO_60, bool, 4);
	S_121 = SLICE(SCZO_60, bool, 0);
	Z_126 = SLICE(SCZO_60, bool, 2);
}

// 080639F4: define caml_set_allocation_policy
// Called from:
//      caml_gc_set
define caml_set_allocation_policy
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			Mem0[0x0807F428<p32>:word32] = 0x00;
			Mem0[0x0807F42C<p32>:word32] = 0x00;
		}
	}
	else
		Mem0[0x0807CFF0<p32>:word32] = 0x0807CFE8;
	Mem0[0x0807F424<p32>:word32] = eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08063A2C: define caml_fl_allocate
// Called from:
//      caml_alloc_shr
define caml_fl_allocate
{
	ptr32 fp;
	word32 dwLoc0FBC;
	word32 dwArg04;
	word32 ecx;
	Top_3 = 0;
	edx_19 = Mem16[0x0807F424<p32>:word32];
	SZP_20 = cond(edx_19);
	P_705 = SLICE(SZP_20, bool, 5);
	switch (edx_19)
	{
	case 0x00:
		ecx_24 = Mem16[0x0807CFF0<p32>:word32];
		edx_25 = Mem16[ecx_24 + 0x00:word32];
		SZP_26 = cond(edx_25);
		P_680 = SLICE(SZP_26, bool, 5);
		if (edx_25 != 0x00)
		{
			ebx_30 = Mem16[edx_25 + -4:word32];
			if (dwArg04 >u ebx_30 >>u 0x0A)
			{
				do
				{
					edx_34 = ϕ(edx_25, edx_37);
					ecx_35 = edx_34;
					edx_37 = Mem16[edx_34 + 0x00:word32];
					SZP_38 = cond(edx_37);
					P_681 = SLICE(SZP_38, bool, 5);
					if (edx_37 == 0x00)
						goto l08063AC8;
					ebx_42 = Mem16[edx_37 + -4:word32];
				} while (ebx_42 >>u 0x0A <u dwArg04);
			}
			P_679 = ϕ(P_680, P_681);
			ecx_97 = ϕ(ecx_24, ecx_35);
			edx_93 = ϕ(edx_25, edx_37);
			allocate_block();
			edi_105 = eax_98;
			goto l08063E9B;
		}
l08063AC8:
		P_688 = ϕ(P_680, P_681);
		ecx_47 = ϕ(ecx_24, ecx_35);
		Mem48[0x0807F430<p32>:word32] = ecx_47;
		ecx_49 = 0x0807CFE8;
		edx_50 = Mem48[0x0807CFE8:word32];
		esi_51 = Mem48[0x0807CFF0<p32>:word32];
		if (esi_51 != 0x0807CFE8)
		{
			ebx_54 = Mem48[edx_50 + -4:word32];
			if (dwArg04 >u ebx_54 >>u 0x0A)
			{
				do
				{
					edx_59 = ϕ(edx_50, edx_62);
					ecx_60 = edx_59;
					edx_62 = Mem48[edx_59 + 0x00:word32];
					if (esi_51 == edx_59)
						goto l08063E96;
					ebx_66 = Mem48[edx_62 + -4:word32];
				} while (dwArg04 >u ebx_66 >>u 0x0A);
			}
			ecx_81 = ϕ(ecx_49, ecx_60);
			edx_74 = ϕ(edx_50, edx_62);
			allocate_block();
			edi_89 = eax_82;
			goto l08063E9B;
		}
		break;
	case 0x01:
		edx_109 = Mem16[0x0807F428<p32>:word32];
		SZP_111 = cond(edx_109);
		P_684 = SLICE(SZP_111, bool, 5);
		if (edx_109 <= 0x00)
		{
l08063B4B:
			if (edx_109 == 0x00)
			{
				ecx_153 = 0x0807CFE8;
				edi_154 = 0x00;
			}
			else
			{
				edx_143 = 134739004[edx_109 * 0x04];
				ecx_144 = Mem110[edx_143 + 0x00:word32];
				edi_145 = Mem110[ecx_144 + -4:word32];
				edi_146 = edi_145 >>u 0x0A;
				edx_147 = Mem110[0x0807F42C<p32>:word32];
				if (edx_147 != 0x00)
					ecx_152 = edx_147;
				ecx_485 = ϕ(ecx_144, ecx_152);
			}
			edi_486 = ϕ(edi_154, edi_146);
			ecx_484 = ϕ(ecx_153, ecx_485);
			edx_155 = 0x00;
			while (true)
			{
				edx_208 = ϕ(edx_155, edx_161);
				edi_168 = ϕ(edi_486, edi_488);
				ecx_160 = ϕ(ecx_484, ecx_180);
				Mem156 = ϕ(Mem110, Mem483);
				ebx_157 = Mem156[0x0807F428<p32>:word32];
				if (ebx_157 > 999)
					break;
				edx_161 = Mem156[ecx_160 + 0x00:word32];
				SZP_162 = cond(edx_161);
				P_686 = SLICE(SZP_162, bool, 5);
				if (edx_161 == 0x00)
				{
					Mem200[0x0807F430<p32>:word32] = ecx_160;
					if (ecx_160 == 0x0807CFE8)
						ecx_204 = 0x00;
					ecx_205 = ϕ(ecx_160, ecx_204);
					Mem206[0x0807F42C<p32>:word32] = ecx_205;
					edi_207 = 0x00;
					goto l08063E9B;
				}
				esi_166 = Mem156[edx_161 + -4:word32];
				esi_167 = esi_166 >>u 0x0A;
				if (edi_168 <u esi_166 >>u 0x0A)
				{
					0x0807F440[ebx_157 * 0x04] = ecx_160;
					ebx_172 = Mem171[0x0807F428<p32>:word32];
					Mem174[0x0807F428<p32>:word32] = ebx_172 + 1;
					if (dwArg04 <=u esi_166 >>u 0x0A)
					{
						Mem181[0x0807F42C<p32>:word32] = edx_161;
						allocate_block();
						edi_199 = eax_192;
						goto l08063C77;
					}
					edi_178 = esi_166 >>u 0x0A;
				}
				edi_488 = ϕ(edi_168, edi_178);
				Mem483 = ϕ(Mem156, Mem174);
				ecx_180 = edx_161;
			}
			Mem209[0x0807F42C<p32>:word32] = edx_208;
			ecx_210 = edx_208;
			if (edx_208 == 0x00)
				ecx_215 = 134739004[ebx_157 * 0x04];
			ecx_221 = ϕ(ecx_210, ecx_215);
			edx_217 = Mem209[0x080803DC<p32>:word32];
			edx_218 = Mem209[edx_217 + 0x00:word32];
			esi_219 = Mem209[edx_218 + -4:word32];
			edx_222 = Mem209[ecx_221 + 0x00:word32];
			SZP_223 = cond(edx_222);
			P_700 = SLICE(SZP_223, bool, 5);
			if (edx_222 != 0x00)
			{
				while (true)
				{
					P_702 = ϕ(P_700, P_701);
					ecx_242 = ϕ(ecx_221, ecx_263);
					Mem228 = ϕ(Mem209, Mem253);
					edx_227 = ϕ(edx_222, edx_264);
					ebx_229 = Mem228[edx_227 + -4:word32];
					if (esi_219 >>u 0x0A >u ebx_229 >>u 0x0A)
						Mem251[0x0807F42C<p32>:word32] = edx_227;
					else if (dwArg04 <=u ebx_229 >>u 0x0A)
					{
						edx_241 = Mem240[0x0807F428<p32>:word32];
						allocate_block();
						edi_250 = eax_243;
						goto l08063E9B;
					}
					Mem253 = ϕ(Mem251, Mem228);
					ebx_254 = Mem253[edx_227 + 0x00:word32];
					SZP_255 = cond(ebx_254);
					P_701 = SLICE(SZP_255, bool, 5);
					if (ebx_254 == 0x00)
						break;
					ecx_263 = edx_227;
					edx_264 = ebx_254;
				}
				ecx_259 = edx_227;
			}
			P_699 = ϕ(P_700, P_701);
			edx_674 = ϕ(edx_222, edx_227);
			ecx_260 = ϕ(ecx_221, ecx_259);
			Mem261[0x0807F430<p32>:word32] = ecx_260;
			edi_262 = 0x00;
			goto l08063E9B;
		}
		ecx_116 = Mem110[0x0807F440<p32>:word32];
		edx_117 = Mem110[ecx_116 + 0x00:word32];
		esi_118 = Mem110[edx_117 + -4:word32];
		esi_119 = esi_118 >>u 0x0A;
		ebx_120 = 0x00;
		if (dwArg04 >u esi_118 >>u 0x0A)
		{
			do
			{
				ebx_124 = ϕ(ebx_120, ebx_125);
				ebx_125 = ebx_124 + 0x01;
				if (ebx_125 >= edx_109)
					goto l08063B4B;
				ecx_131 = 0x0807F440[ebx_125 * 0x04];
				edx_132 = Mem110[ecx_131 + 0x00:word32];
				esi_133 = Mem110[edx_132 + -4:word32];
				esi_134 = esi_133 >>u 0x0A;
			} while (dwArg04 >u esi_133 >>u 0x0A);
		}
		esi_318 = ϕ(esi_119, esi_134);
		ecx_273 = ϕ(ecx_116, ecx_131);
		ebx_271 = ϕ(ebx_120, ebx_125);
		edx_268 = ϕ(edx_117, edx_132);
		allocate_block();
		edi_281 = eax_274;
l08063C77:
		P_682 = ϕ(P_684, P_686);
		edx_671 = ϕ(edx_275, edx_193);
		ecx_660 = ϕ(ecx_276, ecx_194);
		edi_325 = ϕ(edi_281, edi_199);
		esi_317 = ϕ(esi_318, esi_167);
		ebx_284 = ϕ(ebx_271, ebx_172);
		Mem282 = ϕ(Mem270, Mem190);
		eax_283 = Mem282[0x0807F428<p32>:word32];
		if (ebx_284 >= eax_283)
			goto l08063E9B;
		ecx_287 = 0x00;
		SZP_288 = cond(ebx_284);
		P_691 = SLICE(SZP_288, bool, 5);
		if (ebx_284 > 0x00)
		{
			edx_293 = 134739004[ebx_284 * 0x04];
			edx_294 = Mem282[edx_293 + 0x00:word32];
			edx_295 = Mem282[edx_294 + -4:word32];
			ecx_297 = edx_295 >>u 0x0A;
		}
		ecx_320 = ϕ(ecx_287, ecx_297);
		if (eax_283 - 0x01 == ebx_284)
		{
			eax_444 = 0x0807F440[(eax_283 - 0x01) * 0x04];
			eax_445 = Mem282[eax_444 + 0x00:word32];
			edx_446 = Mem282[eax_445 + -4:word32];
			edx_447 = edx_446 >>u 0x0A;
			if (ecx_320 >=u edx_446 >>u 0x0A)
			{
				Mem451[0x0807F42C<p32>:word32] = eax_445;
				v19_452 = Mem451[0x0807F428<p32>:word32] - 0x01;
				Mem453[0x0807F428<p32>:word32] = v19_452;
			}
			else
				Mem450[0x0807F42C<p32>:word32] = 0x00;
l08063E9B:
			P_678 = ϕ(P_679, P_682, P_688, P_691, P_691, P_691, P_691, P_699, P_702, P_686, P_704);
			edx_670 = ϕ(edx_99, edx_671, edx_83, edx_447, edx_447, edx_441, edx_672, edx_674, edx_244, edx_161, edx_676);
			ecx_659 = ϕ(ecx_100, ecx_660, ecx_84, ecx_320, ecx_320, ecx_662, ecx_662, ecx_260, ecx_245, ecx_205, ecx_668);
			edi_455 = ϕ(edi_105, edi_325, edi_89, edi_325, edi_325, edi_352, edi_352, edi_262, edi_250, edi_207, edi_108);
			eax_460 = edi_455;
			SCZO_470 = cond(fp - 0x10);
			C_658 = SLICE(SCZO_470, bool, 1);
			O_677 = SLICE(SCZO_470, bool, 4);
			S_706 = SLICE(SCZO_470, bool, 0);
			Z_735 = SLICE(SCZO_470, bool, 2);
			return;
		}
		eax_306 = 0x0807F440[ebx_284 * 0x04];
		edx_307 = 0x0807F444[ebx_284 * 0x04];
		esi_321 = ecx_320;
		ebx_323 = 0x00;
		while (true)
		{
			ecx_663 = ϕ(ecx_320, ecx_335);
			ebx_340 = ϕ(ebx_323, ebx_500);
			esi_336 = ϕ(esi_321, esi_498);
			Mem332 = ϕ(Mem326, Mem497);
			eax_329 = ϕ(eax_306, eax_347);
			if (edx_307 == eax_329)
				break;
			edx_333 = Mem332[eax_329 + 0x00:word32];
			ecx_334 = Mem332[edx_333 + -4:word32];
			ecx_335 = ecx_334 >>u 0x0A;
			if (esi_336 <u ecx_334 >>u 0x0A)
			{
				(&dwLoc0FBC)[ebx_340 * 0x04] = eax_329;
				ebx_342 = ebx_340 + 0x01;
				if (esi_317 <=u ecx_334 >>u 0x0A)
					break;
				esi_345 = ecx_334 >>u 0x0A;
			}
			ebx_500 = ϕ(ebx_340, ebx_342);
			esi_498 = ϕ(esi_336, esi_345);
			Mem497 = ϕ(Mem332, Mem341);
			eax_347 = edx_333;
		}
		ecx_662 = ϕ(ecx_663, ecx_335);
		ebx_348 = ϕ(ebx_340, ebx_342);
		edi_352 = edi_325;
		eax_353 = Mem350[0x0807F428<p32>:word32];
		edx_356 = eax_353 - 0x01 + ebx_348;
		if (edx_356 <= 1000)
		{
			if (ebx_348 != 0x01)
			{
				eax_413 = eax_353 - 0x01 - ebx_284;
				eax_416 = ebx_284 * 0x04 + 0x0807F444;
				eax_419 = ebx_348 + ebx_284;
				eax_420 = eax_419 * 0x04 + 0x0807F440;
				memmove(eax_420, eax_416, eax_413 << 0x02);
				if (ebx_348 <= 0x00)
				{
l08063DBF:
					Mem438 = ϕ(Mem421, Mem436);
					eax_439 = Mem438[0x0807F428<p32>:word32];
					edx_441 = ebx_348;
					eax_442 = ebx_348 - 1 + eax_439;
					Mem443[0x0807F428<p32>:word32] = eax_442;
					goto l08063E9B;
				}
			}
			dwLoc0FD4_541 = ebx_348 << 0x02;
			dwLoc0FD8_542 = &dwLoc0FBC;
			eax_435 = ebx_284 * 0x04 + 0x0807F440;
			memmove(eax_435, dwLoc0FD8_542, dwLoc0FD4_541);
			goto l08063DBF;
		}
		eax_360 = ebx_348 + ebx_284;
		if (eax_360 > 999)
		{
			if (ebx_284 != 1000)
			{
				eax_366 = 1000 - ebx_284;
				dwLoc0FD8_528 = &dwLoc0FBC;
				eax_377 = ebx_284 * 0x04 + 0x0807F440;
				memmove(eax_377, dwLoc0FD8_528, eax_366 << 0x02);
			}
			goto l08063E7E;
		}
		if (ebx_348 != 0x01)
		{
			edx_383 = 1000 - ebx_284;
			edx_384 = edx_383 - ebx_348;
			edx_387 = ebx_284 * 0x04 + 0x0807F444;
			eax_389 = eax_360 * 0x04 + 0x0807F440;
			memmove(eax_389, edx_387, edx_384 << 0x02);
			if (ebx_348 <= 0x00)
			{
l08063E7E:
				edx_672 = ϕ(edx_387, edx_673, edx_356, edx_356);
				Mem407[0x0807F428<p32>:word32] = 999;
				eax_408 = Mem407[0x080803DC<p32>:word32];
				eax_409 = Mem407[eax_408 + 0x00:word32];
				Mem410[0x0807F42C<p32>:word32] = eax_409;
				goto l08063E9B;
			}
		}
		edx_673 = ϕ(edx_356, edx_387);
		dwLoc0FD4_534 = ebx_348 << 0x02;
		dwLoc0FD8_535 = &dwLoc0FBC;
		eax_404 = ebx_284 * 0x04 + 0x0807F440;
		memmove(eax_404, dwLoc0FD8_535, dwLoc0FD4_534);
		goto l08063E7E;
	}
l08063E96:
	P_704 = ϕ(P_705, P_688, P_688);
	edx_676 = ϕ(edx_19, edx_50, edx_62);
	ecx_668 = ϕ(ecx, ecx_49, ecx_60);
	edi_108 = 0x00;
	goto l08063E9B;
}

// 08063EB0: define clip_heap_chunk_size
// Called from:
//      caml_init_major_heap
//      caml_round_heap_chunk_size
define clip_heap_chunk_size
{
	word32 eax;
	Top_3 = 0;
	edx_10 = 0x2000;
	if (eax <=u 0x1FFF)
		eax_12 = 0x2000;
	eax_13 = ϕ(eax, eax_12);
	eax_14 = eax_13 + 0x0FFF;
	eax_15 = eax_14 & ~0x0FFF;
	SZ_16 = cond(eax_14 & ~0x0FFF);
	S_26 = SLICE(SZ_16, bool, 0);
	Z_28 = SLICE(SZ_16, bool, 2);
	O_17 = false;
	C_18 = false;
}

// 08063ECC: define caml_init_major_heap
// Called from:
//      caml_init_gc
define caml_init_major_heap
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	clip_heap_chunk_size();
	Mem0[0x08083940<p32>:word32] = eax;
	Mem0[0x08083944<p32>:word32] = eax;
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_for_heap();
	Mem0[0x08083FD8<p32>:word32] = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = 0x080716E0;
		caml_fatal_error();
	}
	Mem0[eax + -4:word32] = 0x00;
	Mem0[0x0808394C<p32>:word32] = 0x01;
	eax = Mem0[0x08083FD8<p32>:word32];
	edx = eax;
	edx += Mem0[0x08083940<p32>:word32];
	SCZO = cond(edx);
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x01;
	caml_page_table_add();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071718;
		caml_fatal_error();
	}
	caml_fl_init_merge();
	Mem0[esp + 8:word32] = 0x01;
	eax = Mem0[0x08083940<p32>:word32];
	eax >>= 0x02;
	SCZO = cond(eax);
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x08083FD8<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_make_free_blocks();
	Mem0[0x08083FDC<p32>:word32] = 0x02;
	Mem0[0x080803F4<p32>:word32] = 0x0800;
	Mem0[esp + 0x00:word32] = 0x2000;
	eax = malloc(Mem0[esp + 0x00:size_t]);
	Mem0[0x080803E8<p32>:word32] = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071754;
		caml_fatal_error();
	}
	Mem0[0x080803EC<p32>:word32] = eax;
	edx = Mem0[0x080803F4<p32>:word32];
	eax += edx * 0x04;
	Mem0[0x080803F0<p32>:word32] = eax;
	Mem0[0x080803F8<p32>:word32] = 0x01;
	Mem0[0x08083FE8<p32>:word32] = 0x00;
	--Top;
	ST[Top + 0x00:real64] = 0.0;
	Mem0[0x08083FE0<p32>:real64] = ST[Top + 0x00:real64];
	++Top;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08063FCF: define caml_round_heap_chunk_size
// Called from:
//      caml_alloc_shr
define caml_round_heap_chunk_size
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	eax_13 = Mem10[0x08083FEC<p32>:word32];
	if (dwArg04 >=u eax_13)
		eax_16 = dwArg04;
	eax_17 = ϕ(eax_13, eax_16);
	clip_heap_chunk_size();
	if (dwArg04 >u eax_18)
		caml_raise_out_of_memory();
	edx_52 = ϕ(edx_19, edx_31);
	eax_51 = ϕ(eax_18, eax_30);
	SCZO_35 = cond(fp - 0x08);
	C_50 = SLICE(SCZO_35, bool, 1);
	O_53 = SLICE(SCZO_35, bool, 4);
	S_54 = SLICE(SCZO_35, bool, 0);
	Z_56 = SLICE(SCZO_35, bool, 2);
}

// 08063FF7: define start_cycle
// Called from:
//      caml_finish_major_cycle
//      caml_major_collection_slice
define start_cycle
{
	Top_3 = 0;
	caml_gc_message();
	caml_darken_all_roots();
	C_31 = SLICE(SCZOP_20, bool, 1);
	O_32 = SLICE(SCZOP_20, bool, 4);
	P_33 = SLICE(SCZOP_20, bool, 5);
	S_34 = SLICE(SCZOP_20, bool, 0);
	Z_35 = SLICE(SCZOP_20, bool, 2);
	Mem21[0x08083FDC<p32>:word32] = 0x00;
	Mem22[0x08083FC8<p32>:word32] = 0x0A;
	Mem23[0x080803FC<p32>:word32] = 0x00;
}

// 0806403E: define realloc_gray_vals
// Called from:
//      mark_slice
//      caml_darken
define realloc_gray_vals
{
	Top_3 = 0;
	edx_9 = Mem6[0x080803F4<p32>:word32];
	eax_10 = Mem6[0x08083940<p32>:word32];
	ecx_11 = eax_10 + 0x007F;
	SZP_12 = cond(eax_10);
	P_99 = SLICE(SZP_12, bool, 5);
	if (eax_10 < 0x00)
		eax_16 = eax_10 + 0x007F;
	eax_17 = ϕ(eax_10, eax_16);
	eax_18 = eax_17 >> 0x07;
	if (eax_18 >u edx_9)
	{
		edx_30 = edx_9 << 0x02 >>u 0x09;
		caml_gc_message();
		eax_42 = Mem35[0x080803F4<p32>:word32];
		eax_45 = Mem44[0x080803E8<p32>:word32];
		eax_47 = realloc(eax_45, eax_42 << 0x03);
		SZP_48 = cond(eax_47);
		Z_51 = SLICE(SZP_48, bool, 2);
		P_100 = SLICE(SZP_48, bool, 5);
		S_103 = SLICE(SZP_48, bool, 0);
		O_49 = false;
		C_50 = false;
		if (eax_47 == 0x00)
		{
			caml_gc_message();
			eax_69 = Mem62[0x080803E8<p32>:word32];
			Mem70[0x080803EC<p32>:word32] = eax_69;
			Mem71[0x080803F8<p32>:word32] = 0x00;
		}
		else
		{
			Mem52[0x080803E8<p32>:word32] = eax_47;
			edx_53 = Mem52[0x080803F4<p32>:word32];
			ecx_54 = eax_47 + edx_53 * 0x04;
			Mem55[0x080803EC<p32>:word32] = ecx_54;
			ecx_56 = edx_53 * 0x02;
			Mem57[0x080803F4<p32>:word32] = edx_53 * 0x02;
			eax_58 = eax_47 + edx_53 * 0x08;
			Mem59[0x080803F0<p32>:word32] = eax_58;
		}
	}
	else
	{
		edx_23 = edx_9 >>u 0x01 << 0x02;
		edx_25 = edx_23 + Mem6[0x080803E8<p32>:word32];
		SCZO_26 = cond(edx_25);
		C_90 = SLICE(SCZO_26, bool, 1);
		O_96 = SLICE(SCZO_26, bool, 4);
		S_102 = SLICE(SCZO_26, bool, 0);
		Z_107 = SLICE(SCZO_26, bool, 2);
		Mem27[0x080803EC<p32>:word32] = edx_25;
		Mem28[0x080803F8<p32>:word32] = 0x00;
	}
	Z_106 = ϕ(Z_66, Z_107, Z_51);
	S_101 = ϕ(S_64, S_102, S_103);
	P_97 = ϕ(P_68, P_99, P_100);
	O_95 = ϕ(O_67, O_96, O_49);
	edx_94 = ϕ(edx_30, edx_25, edx_53);
	ecx_92 = ϕ(ecx_11, ecx_11, ecx_56);
	eax_91 = ϕ(eax_69, eax_18, eax_58);
	C_89 = ϕ(C_65, C_90, C_50);
}

// 08064113: define mark_slice
// Called from:
//      caml_finish_major_cycle
//      caml_major_collection_slice
define mark_slice
{
	ptr32 fp;
	word32 eax;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	dwLoc28_466 = eax;
	caml_gc_message();
	caml_gc_message();
	esi_40 = Mem33[0x080803EC<p32>:word32];
	if (eax > 0x00)
	{
		do
		{
			P_636 = ϕ(P_39, P_634);
			edx_629 = ϕ(edx, edx_624);
			ecx_619 = ϕ(ecx, ecx_613);
			dwLoc28_509 = ϕ(dwLoc28_466, dwLoc28_540);
			esi_44 = ϕ(esi_40, esi_428);
			Mem43 = ϕ(Mem33, Mem424);
			if (Mem43[0x080803E8<p32>:word32] <u esi_44)
			{
				esi_277 = esi_44 - 0x04;
				edi_278 = Mem43[esi_277 + 0x00:word32];
				eax_280 = Mem43[edi_278 + -4:word32];
				al_291 = SLICE(eax_280, byte, 0);
				ch_282 = SLICE(eax_280, byte, 8);
				ecx_16_16_284 = SLICE(eax_280, word16, 16);
				cl_285 = SLICE(eax_280, byte, 0);
				ecx_286 = SEQ(ecx_16_16_284, ch_282 | 0x03, cl_285);
				Mem287[edi_278 + -4:word32] = ecx_286;
				edx_289 = eax_280 >>u 0x0A;
				if (al_291 <=u ~0x05)
				{
					SZP_294 = cond(eax_280 >>u 0x0A);
					P_637 = SLICE(SZP_294, bool, 5);
					if (eax_280 >>u 0x0A != 0x00)
					{
						ebx_298 = 0x00;
						dwLoc38_519 = esi_277;
						do
						{
							edx_627 = ϕ(edx_289, edx_626);
							ecx_616 = ϕ(ecx_286, ecx_615);
							dwLoc38_524 = ϕ(dwLoc38_519, dwLoc38_532);
							Mem302 = ϕ(Mem299, Mem410);
							ebx_301 = ϕ(ebx_298, ebx_408);
							eax_303 = edi_278[ebx_301 * 0x04];
							al_304 = SLICE(eax_303, byte, 0);
							SZP_305 = cond(al_304 & 0x01);
							P_640 = SLICE(SZP_305, bool, 5);
							if ((al_304 & 0x01) == 0x00)
							{
								edx_314 = eax_303 >>u 0x0C & 0x07FF;
								ecx_315 = 0x08084000[(eax_303 >>u 0x17) * 0x04];
								SZP_316 = cond(Mem302[ecx_315 + edx_314:byte] & 0x01);
								P_639 = SLICE(SZP_316, bool, 5);
								if ((Mem302[ecx_315 + edx_314:byte] & 0x01) == 0x00)
									goto l08064273;
								edx_320 = Mem302[eax_303 + -4:word32];
								dl_321 = SLICE(edx_320, byte, 0);
								ecx_322 = CONVERT(dl_321, byte, word32);
								if (ecx_322 == 0xFA)
								{
									ecx_333 = Mem302[eax_303 + 0x00:word32];
									cl_336 = SLICE(ecx_333, byte, 0);
									if ((cl_336 & 0x01) == 0x00)
									{
										ecx_345 = ecx_333 >>u 0x0C & 0x07FF;
										esi_346 = 0x08084000[(ecx_333 >>u 0x17) * 0x04];
										if ((Mem341[esi_346 + ecx_345:byte] & 0x07) == 0x00)
											goto l0806423E;
										esi_352 = CONVERT(Mem341[ecx_333 + -4:byte], byte, word32);
										ecx_353 = esi_352;
										cl_354 = SLICE(esi_352, byte, 0);
										if (cl_354 != ~0x05 && (cl_354 != ~0x09 && cl_354 != ~0x02))
											goto l0806421D;
									}
									else
									{
l0806421D:
										ecx_618 = ϕ(ecx_333, ecx_353);
										edi_278[ebx_301 * 0x04] = ecx_333;
									}
								}
								else if (ecx_322 == 0xF9)
								{
									eax_328 = (edx_320 >>u 0x0A) * 0x04;
									esi_329 = eax_303 - eax_328;
									eax_331 = esi_329;
									edx_332 = Mem302[esi_329 + -4:word32];
								}
l0806423E:
								edx_675 = ϕ(edx_320, edx_320, edx_320, edx_320, edx_320, edx_320, edx_332);
								ecx_617 = ϕ(ecx_345, ecx_353, ecx_353, ecx_353, ecx_618, ecx_322, ecx_322);
								Mem411 = ϕ(Mem341, Mem341, Mem341, Mem341, Mem366, Mem302, Mem302);
								eax_385 = ϕ(eax_303, eax_303, eax_303, eax_303, eax_303, eax_303, eax_331);
								edx_16_16_380 = SLICE(edx_675, word16, 16);
								dl_377 = SLICE(edx_675, byte, 0);
								dh_367 = SLICE(edx_675, byte, 8);
								SZP_371 = cond(dh_367 & 0x03);
								P_641 = SLICE(SZP_371, bool, 5);
								edx_628 = edx_675;
								if ((dh_367 & 0x03) == 0x00)
								{
									dh_375 = dh_367 & 252;
									edx_384 = SEQ(edx_16_16_380, dh_375 | 0x01, dl_377);
									Mem387[eax_385 + -4:word32] = edx_384;
									Mem390[dwLoc38_524 + 0x00:word32] = eax_385;
									edx_391 = dwLoc38_524 + 0x04;
									dwLoc38_526 = dwLoc38_524 + 0x04;
									if (dwLoc38_524 + 0x04 >=u Mem392[0x080803F0<p32>:word32])
									{
										Mem395[0x080803EC<p32>:word32] = dwLoc38_524 + 0x04;
										realloc_gray_vals();
										ecx_404 = Mem395[0x080803EC<p32>:word32];
										dwLoc38_527 = ecx_404;
									}
								}
							}
l08064273:
							P_638 = ϕ(P_639, P_640, P_641, P_641, P_403);
							edx_626 = ϕ(edx_314, edx_627, edx_628, edx_391, edx_398);
							ecx_615 = ϕ(ecx_315, ecx_616, ecx_617, ecx_617, ecx_404);
							dwLoc38_532 = ϕ(dwLoc38_524, dwLoc38_524, dwLoc38_524, dwLoc38_526, dwLoc38_527);
							Mem410 = ϕ(Mem302, Mem302, Mem411, Mem392, Mem405);
							ebx_408 = ebx_301 + 0x01;
						} while (eax_280 >>u 0x0A >u ebx_408);
						esi_414 = dwLoc38_532;
					}
				}
				P_635 = ϕ(P_636, P_637, P_638);
				edx_625 = ϕ(edx_289, edx_289, edx_626);
				ecx_614 = ϕ(ecx_286, ecx_286, ecx_615);
				esi_429 = ϕ(esi_277, esi_277, esi_414);
				eax_418 = ~(eax_280 >>u 0x0A);
				v24_419 = dwLoc28_509 + eax_418;
				dwLoc28_539 = v24_419;
			}
			else
			{
				eax_47 = Mem43[0x080803FC<p32>:word32];
				SZP_48 = cond(eax_47);
				P_643 = SLICE(SZP_48, bool, 5);
				if (eax_47 != 0x00)
				{
					if (eax_47 == Mem43[0x08080404<p32>:word32])
					{
						eax_265 = Mem43[0x08080400<p32>:word32];
						eax_266 = Mem43[eax_265 + -4:word32];
						Mem267[0x08080400<p32>:word32] = eax_266;
						SZP_268 = cond(eax_266);
						P_642 = SLICE(SZP_268, bool, 5);
						if (eax_266 == 0x00)
							Mem276[0x080803FC<p32>:word32] = 0x00;
						else
						{
							Mem272[0x080803FC<p32>:word32] = eax_266;
							eax_273 = eax_266 + Mem272[eax_266 + -8:word32];
							Mem275[0x08080404<p32>:word32] = eax_273;
						}
					}
					else
					{
						edx_250 = Mem43[eax_47 + 0x00:word32];
						if ((edx_250 & 0x0300) == 0x0100)
						{
							Mem255[esi_44 + 0x00:word32] = eax_47 + 0x04;
							esi_256 = esi_44 + 0x04;
						}
						esi_430 = ϕ(esi_44, esi_256);
						Mem258 = ϕ(Mem43, Mem255);
						eax_259 = Mem258[0x080803FC<p32>:word32];
						edx_260 = Mem258[eax_259 + 0x00:word32];
						edx_261 = edx_260 >>u 0x0A;
						eax_263 = eax_259 + 4 + (edx_260 >>u 0x0A) * 0x04;
						Mem264[0x080803FC<p32>:word32] = eax_263;
					}
				}
				else if (Mem43[0x080803F8<p32>:word32] == 0x00)
				{
					Mem241[0x080803F8<p32>:word32] = 0x01;
					eax_242 = Mem241[0x08083FD8<p32>:word32];
					Mem243[0x08080400<p32>:word32] = eax_242;
					Mem244[0x080803FC<p32>:word32] = eax_242;
					eax_245 = eax_242 + Mem244[eax_242 + -8:word32];
					Mem247[0x08080404<p32>:word32] = eax_245;
				}
				else
				{
					eax_54 = Mem43[0x08083FC8<p32>:word32];
					if (eax_54 != 11)
					{
						if (eax_54 <= 11)
						{
							if (eax_54 == 0x0A)
							{
								Mem239[0x08083FC8<p32>:word32] = 11;
								Mem240[0x08080408<p32>:word32] = 0x08083994;
							}
						}
						else if (eax_54 != 0x0C)
						{
							if (eax_54 == 0x0D)
							{
								Mem225[0x080803EC<p32>:word32] = esi_44;
								eax_226 = Mem225[0x08083FD8<p32>:word32];
								Mem227[0x08083FCC<p32>:word32] = eax_226;
								caml_fl_init_merge();
								Mem228[0x08083FDC<p32>:word32] = 0x01;
								eax_229 = Mem228[0x08083FD8<p32>:word32];
								Mem230[0x08080400<p32>:word32] = eax_229;
								Mem231[0x08083FCC<p32>:word32] = eax_229;
								eax_232 = eax_229 + Mem231[eax_229 + -8:word32];
								Mem234[0x08080404<p32>:word32] = eax_232;
								eax_235 = Mem234[0x0807F420<p32>:word32];
								Mem236[0x080803E4<p32>:word32] = eax_235;
								break;
							}
						}
						else
						{
							edx_194 = Mem43[0x08080408<p32>:word32];
							eax_195 = Mem43[edx_194 + 0x00:word32];
							if (eax_195 != 0x00)
							{
								SZP_211 = cond(Mem43[eax_195 + -4:word32] & 0x0300);
								P_646 = SLICE(SZP_211, bool, 5);
								if ((Mem43[eax_195 + -4:word32] & 0x0300) == 0x00)
								{
									eax_216 = Mem43[eax_195 + 0x00:word32];
									Mem217[edx_194 + 0x00:word32] = eax_216;
								}
								else
									Mem215[0x08080408<p32>:word32] = eax_195;
								eax_610 = ϕ(eax_216, eax_195);
								v25_220 = dwLoc28_509 - 0x01;
								dwLoc28_517 = v25_220;
							}
							else
							{
								Mem200[0x080803EC<p32>:word32] = esi_44;
								caml_final_update();
								esi_209 = Mem200[0x080803EC<p32>:word32];
								Mem210[0x08083FC8<p32>:word32] = 0x0D;
							}
						}
					}
					else
					{
						eax_57 = Mem43[0x08080408<p32>:word32];
						eax_58 = Mem43[eax_57 + 0x00:word32];
						SZP_61 = cond(eax_58);
						P_648 = SLICE(SZP_61, bool, 5);
						if (eax_58 != 0x00)
						{
							eax_68 = Mem67[eax_58 + -4:word32];
							if (eax_68 >>u 0x0A >u 0x01)
							{
								dwLoc24_476 = 0x01;
								do
								{
									P_656 = ϕ(P_648, P_649);
									dwLoc24_478 = ϕ(dwLoc24_476, dwLoc24_490);
									Mem76 = ϕ(Mem74, Mem176);
									eax_79 = eax_58[dwLoc24_478 * 0x04];
									al_83 = SLICE(eax_79, byte, 0);
									edi_80 = Mem76[0x0807D0A4<p32>:word32];
									if (eax_79 != edi_80)
									{
										SZP_84 = cond(al_83 & 0x01);
										P_650 = SLICE(SZP_84, bool, 5);
										if ((al_83 & 0x01) == 0x00)
										{
											edx_92 = eax_79 >>u 0x0C & 0x07FF;
											ecx_93 = 0x08084000[(eax_79 >>u 0x17) * 0x04];
											SZP_94 = cond(Mem76[ecx_93 + edx_92:byte] & 0x01);
											P_651 = SLICE(SZP_94, bool, 5);
											if ((Mem76[ecx_93 + edx_92:byte] & 0x01) != 0x00)
											{
												edx_98 = eax_79 - 4;
												if (Mem76[eax_79 + -4:byte] == ~0x05)
												{
													eax_101 = Mem76[eax_79 + 0x00:word32];
													al_102 = SLICE(eax_101, byte, 0);
													if ((al_102 & 0x01) == 0x00)
													{
														do
														{
															edi_171 = ϕ(edi_80, edi_138);
															eax_110 = ϕ(eax_101, eax_154);
															al_141 = SLICE(eax_110, byte, 0);
															edx_107 = ϕ(edx_98, edx_122);
															esi_113 = eax_110 >>u 0x17;
															ebx_115 = eax_110 >>u 0x0C;
															ecx_117 = 0x08084000[esi_113 * 0x04];
															SZP_118 = cond(Mem109[ecx_117 + (ebx_115 & 0x07FF):byte] & 0x07);
															P_652 = SLICE(SZP_118, bool, 5);
															if ((Mem109[ecx_117 + (ebx_115 & 0x07FF):byte] & 0x07) == 0x00)
															{
l0806446D:
																Mem133 = ϕ(Mem109, Mem123, Mem123, Mem123);
																edx_134 = edx_107;
																break;
															}
															edx_122 = eax_110 - 0x04;
															ecx_124 = CONVERT(Mem123[edx_122 + 0x00:byte], byte, word32);
															cl_125 = SLICE(ecx_124, byte, 0);
															if (cl_125 == ~0x05 || (cl_125 == ~0x09 || cl_125 == ~0x02))
																goto l0806446D;
															eax_58[dwLoc24_478 * 0x04] = eax_110;
															edi_138 = Mem137[0x0807D0A4<p32>:word32];
															if (eax_110 == edi_138)
																goto l08064481;
															SZP_142 = cond(al_141 & 0x01);
															P_654 = SLICE(SZP_142, bool, 5);
															if ((al_141 & 0x01) != 0x00)
																goto l08064481;
															ecx_146 = 0x08084000[esi_113 * 0x04];
															SZP_147 = cond(Mem137[ecx_146 + (ebx_115 & 0x07FF):byte] & 0x01);
															P_655 = SLICE(SZP_147, bool, 5);
															if ((Mem137[ecx_146 + (ebx_115 & 0x07FF):byte] & 0x01) == 0x00)
																goto l08064481;
															if (Mem137[edx_122 + 0x00:byte] != ~0x05)
																break;
															eax_154 = Mem137[eax_110 + 0x00:word32];
															al_155 = SLICE(eax_154, byte, 0);
														} while ((al_155 & 0x01) == 0x00);
													}
												}
												edi_169 = ϕ(edi_80, edi_80, edi_138, edi_138, edi_171);
												Mem161 = ϕ(Mem76, Mem76, Mem137, Mem137, Mem133);
												edx_160 = ϕ(edx_98, edx_98, edx_122, edx_122, edx_134);
												SZP_162 = cond(Mem161[edx_160 + 0x00:word32] & 0x0300);
												P_653 = SLICE(SZP_162, bool, 5);
												if ((Mem161[edx_160 + 0x00:word32] & 0x0300) == 0x00)
													eax_58[dwLoc24_478 * 0x04] = edi_169;
											}
										}
									}
l08064481:
									P_649 = ϕ(P_650, P_651, P_652, P_653, P_653, P_654, P_655, P_656);
									v26_175 = dwLoc24_478 + 0x01;
									dwLoc24_490 = v26_175;
									edx_177 = eax_68 >>u 0x0A;
								} while (v26_175 != eax_68 >>u 0x0A);
							}
							P_647 = ϕ(P_648, P_649);
							edx_631 = ϕ(edx_629, edx_177);
							esi_432 = esi_44;
							ecx_183 = eax_58;
							Mem184[0x08080408<p32>:word32] = eax_58;
							eax_186 = ~(eax_68 >>u 0x0A);
							v27_187 = dwLoc28_509 + eax_186;
							dwLoc28_515 = v27_187;
						}
						else
						{
							Mem65[0x08083FC8<p32>:word32] = 0x0C;
							Mem66[0x08080408<p32>:word32] = 0x08083994;
						}
					}
				}
			}
			P_634 = ϕ(P_635, P_642, P_643, P_642, P_643, P_643, P_643, P_643, P_208, P_646, P_647, P_648);
			edx_624 = ϕ(edx_625, edx_629, edx_629, edx_629, edx_261, edx_629, edx_629, edx_629, edx_203, edx_194, edx_631, edx_629);
			ecx_613 = ϕ(ecx_614, ecx_619, ecx_619, ecx_619, ecx_619, ecx_619, ecx_619, ecx_619, ecx_202, ecx_619, ecx_183, ecx_619);
			eax_609 = ϕ(eax_418, eax_266, eax_245, eax_273, eax_263, eax_54, eax_54, eax_54, eax_201, eax_610, eax_186, eax_58);
			dwLoc28_540 = ϕ(dwLoc28_539, dwLoc28_509, dwLoc28_509, dwLoc28_509, dwLoc28_509, dwLoc28_509, dwLoc28_509, dwLoc28_509, dwLoc28_509, dwLoc28_517, dwLoc28_515, dwLoc28_509);
			esi_428 = ϕ(esi_429, esi_44, esi_44, esi_44, esi_430, esi_44, esi_44, esi_44, esi_209, esi_44, esi_432, esi_44);
			Mem424 = ϕ(Mem420, Mem276, Mem247, Mem275, Mem264, Mem43, Mem240, Mem43, Mem210, Mem221, Mem188, Mem66);
		} while (dwLoc28_540 > 0x00);
	}
	P_633 = ϕ(P_39, P_634, P_643);
	edx_622 = ϕ(edx, edx_624, edx_629);
	ecx_611 = ϕ(ecx, ecx_613, ecx_619);
	eax_608 = ϕ(eax_34, eax_609, eax_235);
	esi_427 = ϕ(esi_40, esi_428, esi_44);
	Mem433[0x080803EC<p32>:word32] = esi_427;
	SCZO_451 = cond(fp - 0x10);
	C_607 = SLICE(SCZO_451, bool, 1);
	O_632 = SLICE(SCZO_451, bool, 4);
	S_657 = SLICE(SCZO_451, bool, 0);
	Z_674 = SLICE(SCZO_451, bool, 2);
}

// 08064560: define caml_darken
// Called from:
//      caml_modify
//      caml_array_unsafe_set_addr
//      caml_array_set_addr
//      caml_weak_get_copy
//      caml_weak_get
//      caml_final_update
define caml_darken
{
	ptr32 fp;
	word32 dwArg04;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	eax_12 = dwArg04;
	al_13 = SLICE(dwArg04, byte, 0);
	SZP_14 = cond(al_13 & 0x01);
	P_107 = SLICE(SZP_14, bool, 5);
	if ((al_13 & 0x01) == 0x00)
	{
		edx_23 = dwArg04 >>u 0x0C & 0x07FF;
		ecx_24 = 0x08084000[(dwArg04 >>u 0x17) * 0x04];
		SZP_25 = cond(Mem10[ecx_24 + edx_23:byte] & 0x01);
		P_108 = SLICE(SZP_25, bool, 5);
		if ((Mem10[ecx_24 + edx_23:byte] & 0x01) != 0x00)
		{
			edx_29 = Mem10[dwArg04 + -4:word32];
			dl_30 = SLICE(edx_29, byte, 0);
			ecx_31 = CONVERT(dl_30, byte, word32);
			if (ecx_31 == 0xF9)
			{
				eax_35 = (edx_29 >>u 0x0A) * 0x04;
				ebx_36 = dwArg04 - eax_35;
				eax_38 = ebx_36;
				edx_39 = Mem10[ebx_36 + -4:word32];
				dl_40 = SLICE(edx_39, byte, 0);
				ecx_41 = CONVERT(dl_40, byte, word32);
			}
			edx_114 = ϕ(edx_29, edx_39);
			eax_61 = ϕ(eax_12, eax_38);
			edx_16_16_57 = SLICE(edx_114, word16, 16);
			dl_56 = SLICE(edx_114, byte, 0);
			ecx_49 = ϕ(ecx_31, ecx_41);
			dh_42 = SLICE(edx_114, byte, 8);
			SZP_45 = cond(dh_42 & 0x03);
			P_109 = SLICE(SZP_45, bool, 5);
			edx_104 = edx_114;
			if ((dh_42 & 0x03) == 0x00)
			{
				if (ecx_49 <=u 0xFA)
				{
					dh_63 = dh_42 & 252;
					edx_65 = SEQ(edx_16_16_57, dh_63 | 0x01, dl_56);
					Mem66[eax_61 + -4:word32] = edx_65;
					edx_67 = Mem66[0x080803EC<p32>:word32];
					Mem68[edx_67 + 0x00:word32] = eax_61;
					eax_69 = edx_67 + 4;
					Mem70[0x080803EC<p32>:word32] = edx_67 + 4;
					if (edx_67 + 4 >=u Mem70[0x080803F0<p32>:word32])
						realloc_gray_vals();
				}
				else
				{
					dh_52 = dh_42 | 0x03;
					edx_60 = SEQ(edx_16_16_57, dh_52, dl_56);
					Mem62[eax_61 + -4:word32] = edx_60;
				}
			}
		}
	}
	P_106 = ϕ(P_107, P_108, P_109, P_109, P_80, P_109);
	edx_102 = ϕ(edx, edx_23, edx_104, edx_67, edx_75, edx_60);
	ecx_100 = ϕ(ecx, ecx_24, ecx_49, ecx_49, ecx_74, ecx_49);
	eax_99 = ϕ(eax_12, eax_12, eax_61, eax_69, eax_73, eax_61);
	SCZO_84 = cond(fp - 0x08);
	C_98 = SLICE(SCZO_84, bool, 1);
	O_105 = SLICE(SCZO_84, bool, 4);
	S_110 = SLICE(SCZO_84, bool, 0);
	Z_113 = SLICE(SCZO_84, bool, 2);
}

// 080645F0: define sweep_slice
// Called from:
//      caml_finish_major_cycle
//      caml_major_collection_slice
define sweep_slice
{
	ptr32 fp;
	word32 eax;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	esi_20 = eax;
	caml_gc_message();
	SZP_30 = cond(eax);
	P_179 = SLICE(SZP_30, bool, 5);
	if (eax > 0x00)
	{
		do
		{
			edx_176 = ϕ(edx, edx_175);
			ecx_172 = ϕ(ecx, ecx_171);
			esi_60 = ϕ(esi_20, esi_116);
			Mem35 = ϕ(Mem23, Mem128);
			ebx_36 = Mem35[0x08083FCC<p32>:word32];
			if (ebx_36 <u Mem35[0x08080404<p32>:word32])
			{
				ecx_54 = ebx_36;
				eax_55 = Mem35[ebx_36 + 0x00:word32];
				al_70 = SLICE(eax_55, byte, 0);
				ah_105 = SLICE(eax_55, byte, 8);
				eax_16_16_110 = SLICE(eax_55, word16, 16);
				edi_59 = ~(eax_55 >>u 0x0A);
				esi_61 = esi_60 + edi_59;
				edx_62 = ebx_36 + 4 + (eax_55 >>u 0x0A) * 0x04;
				Mem63[0x08083FCC<p32>:word32] = edx_62;
				edx_65 = eax_55 & 0x0300;
				if ((eax_55 & 0x0300) != 0x00)
				{
					if ((eax_55 & 0x0300) == 0x0200)
						Mem115[0x0807CFDC<p32>:word32] = ebx_36 + 0x04;
					else
					{
						eax_111 = SEQ(eax_16_16_110, ah_105 & 252, al_70);
						Mem112[ebx_36 + 0x00:word32] = eax_111;
					}
				}
				else
				{
					if (al_70 == ~0x00)
					{
						eax_73 = Mem63[ebx_36 + 4:word32];
						eax_74 = Mem63[eax_73 + 4:word32];
						if (eax_74 != 0x00)
							eax_74();
					}
					caml_fl_merge_block();
					Mem102[0x08083FCC<p32>:word32] = eax_94;
				}
			}
			else
			{
				eax_39 = Mem35[0x08080400<p32>:word32];
				eax_40 = Mem35[eax_39 + -4:word32];
				Mem41[0x08080400<p32>:word32] = eax_40;
				SZP_42 = cond(eax_40);
				P_181 = SLICE(SZP_42, bool, 5);
				if (eax_40 == 0x00)
				{
					v20_50 = Mem41[0x0808393C<p32>:word32] + 0x01;
					Mem51[0x0808393C<p32>:word32] = v20_50;
					Mem53[0x08083FDC<p32>:word32] = 0x02;
					break;
				}
				Mem46[0x08083FCC<p32>:word32] = eax_40;
				eax_47 = eax_40 + Mem46[eax_40 + -8:word32];
				Mem49[0x08080404<p32>:word32] = eax_47;
			}
			edx_175 = ϕ(edx_65, edx_65, edx_176, edx_96);
			ecx_171 = ϕ(ecx_54, ecx_54, ecx_172, ecx_95);
			eax_168 = ϕ(eax_55, eax_111, eax_47, eax_94);
			Mem128 = ϕ(Mem115, Mem112, Mem49, Mem102);
			esi_116 = ϕ(esi_61, esi_61, esi_60, esi_61);
			SZP_118 = cond(esi_116);
			P_180 = SLICE(SZP_118, bool, 5);
		} while (esi_116 > 0x00);
	}
	P_178 = ϕ(P_179, P_180, P_181);
	edx_173 = ϕ(edx, edx_175, edx_176);
	ecx_169 = ϕ(ecx, ecx_171, ecx_172);
	eax_167 = ϕ(eax_24, eax_168, eax_40);
	SCZO_126 = cond(fp - 0x10);
	C_166 = SLICE(SCZO_126, bool, 1);
	O_177 = SLICE(SCZO_126, bool, 4);
	S_182 = SLICE(SCZO_126, bool, 0);
	Z_184 = SLICE(SCZO_126, bool, 2);
}

// 080646D1: define caml_finish_major_cycle
// Called from:
//      caml_gc_compaction
//      caml_gc_full_major
//      caml_gc_major
//      caml_compact_heap_maybe
define caml_finish_major_cycle
{
	ptr32 fp;
	word32 ecx;
	bool P;
	if (Mem6[0x08083FDC<p32>:word32] == 0x02)
	{
		start_cycle();
		P_95 = SLICE(SCZOP_70, bool, 5);
	}
	P_93 = ϕ(P, P_95);
	ecx_86 = ϕ(ecx, ecx_69);
	while (Mem6[0x08083FDC<p32>:word32] == 0x00)
		mark_slice();
	P_92 = ϕ(P_93, P_25);
	ecx_85 = ϕ(ecx_86, ecx_19);
	SCZO_30 = cond(Mem6[0x08083FDC<p32>:word32] - 0x01);
	Z_31 = SLICE(SCZO_30, bool, 2);
	C_82 = SLICE(SCZO_30, bool, 1);
	O_89 = SLICE(SCZO_30, bool, 4);
	S_97 = SLICE(SCZO_30, bool, 0);
	while (Mem6[0x08083FDC<p32>:word32] == 0x01)
	{
		sweep_slice();
		SCZO_42 = cond(Mem6[0x08083FDC<p32>:word32] - 0x01);
		Z_43 = SLICE(SCZO_42, bool, 2);
		C_83 = SLICE(SCZO_42, bool, 1);
		O_90 = SLICE(SCZO_42, bool, 4);
		S_98 = SLICE(SCZO_42, bool, 0);
	}
	Z_99 = ϕ(Z_31, Z_43);
	S_96 = ϕ(S_97, S_98);
	P_91 = ϕ(P_92, P_40);
	O_88 = ϕ(O_89, O_90);
	ecx_84 = ϕ(ecx_85, ecx_34);
	C_81 = ϕ(C_82, C_83);
	eax_45 = Mem6[0x08083FE8<p32>:word32];
	edx_46 = 0x00;
	qwLoc14_73 = CONVERT(eax_45, word32, uint64);
	rLoc1_74 = CONVERT(qwLoc14_73, int64, real64);
	rLoc1_75 = rLoc1_74 + Mem53[0x08083930<p32>:real64];
	Mem62[0x08083930<p32>:real64] = rLoc1_75;
	Top_63 = 0x00;
	Mem64[0x08083FE8<p32>:word32] = 0x00;
}

// 08064748: define caml_major_collection_slice
// Called from:
//      caml_minor_collection
//      caml_gc_major_slice
define caml_major_collection_slice
{
	ptr32 fp;
	word32 dwArg04;
	ebx_18 = dwArg04;
	if (Mem16[0x08083FDC<p32>:word32] == 0x02)
		start_cycle();
	eax_26 = Mem16[0x08083FE8<p32>:word32];
	edx_27 = Mem16[0x08083FD0<p32>:word32];
	qwLoc24_362 = CONVERT(edx_27 + 100, word32, uint64);
	rLoc1_363 = CONVERT(qwLoc24_362, int64, real64);
	qwLoc24_366 = CONVERT(edx_27, word32, uint64);
	rLoc2_367 = CONVERT(qwLoc24_366, int64, real64);
	qwLoc24_370 = CONVERT(eax_26, word32, uint64);
	rLoc3_371 = CONVERT(qwLoc24_370, int64, real64);
	rLoc3_372 = rLoc3_371 * CONVERT(Mem43[0x080718AC<p32>:real32], real32, real64);
	rLoc3_373 = rLoc3_372 * rLoc1_363;
	edx_48 = Mem43[0x08083940<p32>:word32];
	qwLoc24_376 = CONVERT(edx_48 >>u 0x02, word32, uint64);
	rLoc4_377 = CONVERT(qwLoc24_376, int64, real64);
	rLoc3_378 = rLoc3_373 / rLoc4_377;
	rLoc3_379 = rLoc3_378 / rLoc2_367;
	rLoc3_380 = rLoc3_379 * CONVERT(Mem52[0x080718B0<p32>:real32], real32, real64);
	edx_61 = Mem59[0x08083FD4<p32>:word32];
	if (edx_61 == 0x00)
		rLoc1_395 = 0.0;
	else
	{
		esi_66 = Mem59[0x08083FF0<p32>:word32];
		qwLoc24_384 = CONVERT(esi_66, word32, uint64);
		rLoc3_385 = CONVERT(qwLoc24_384, int64, real64);
		rLoc1_386 = rLoc1_363 * rLoc3_385;
		qwLoc24_389 = CONVERT(edx_61, word32, uint64);
		rLoc3_390 = CONVERT(qwLoc24_389, int64, real64);
		rLoc1_391 = rLoc1_386 / rLoc3_390;
		rLoc1_392 = rLoc1_391 / rLoc2_367;
	}
	rLoc3_528 = ϕ(rLoc3_380, rLoc3_390);
	rLoc1_398 = ϕ(rLoc1_395, rLoc1_392);
	Mem92 = ϕ(Mem59, Mem76);
	rLoc2_399 = rLoc1_398;
	if (rLoc1_398 <= rLoc3_380)
		rLoc2_401 = rLoc3_380;
	rLoc2_402 = ϕ(rLoc2_399, rLoc2_401);
	rLoc2_404 = Mem92[0x08083FE0<p32>:real64];
	if (rLoc2_404 <= rLoc2_402)
		rLoc2_405 = rLoc2_402;
	rLoc2_406 = ϕ(rLoc2_404, rLoc2_405);
	caml_gc_message();
	wLoc26_414 = __fstcw();
	eax_142 = CONVERT(wLoc26_414, word16, word32);
	al_144 = SLICE(eax_142, byte, 0);
	ax_145 = SEQ(0x0C, al_144);
	__fldcw(ax_145);
	__fldcw(wLoc26_414);
	caml_gc_message();
	wLoc26_423 = __fstcw();
	eax_163 = CONVERT(wLoc26_423, word16, word32);
	al_165 = SLICE(eax_163, byte, 0);
	ax_166 = SEQ(0x0C, al_165);
	__fldcw(ax_166);
	__fldcw(wLoc26_423);
	caml_gc_message();
	if (Mem173[0x08083FDC<p32>:word32] == 0x00)
	{
		eax_202 = Mem173[0x08083940<p32>:word32];
		qwLoc24_442 = CONVERT(eax_202 >>u 0x02, word32, uint64);
		rLoc1_443 = CONVERT(qwLoc24_442, int64, real64);
		rLoc1_444 = rLoc1_443 * rLoc2_406;
		rLoc1_445 = rLoc1_444 * CONVERT(Mem206[0x080718B4<p32>:real32], real32, real64);
		eax_211 = Mem206[0x08083FD0<p32>:word32];
		qwLoc24_448 = CONVERT(eax_211 + 100, word32, uint64);
		rLoc2_449 = CONVERT(qwLoc24_448, int64, real64);
		rLoc1_450 = rLoc1_445 / rLoc2_449;
		wLoc26_451 = __fstcw();
		eax_222 = CONVERT(wLoc26_451, word16, word32);
		al_224 = SLICE(eax_222, byte, 0);
		ax_225 = SEQ(0x0C, al_224);
		__fldcw(ax_225);
		dwLoc2C_453 = CONVERT(rLoc1_450, real64, int32);
		__fldcw(wLoc26_451);
		esi_229 = dwLoc2C_453;
	}
	else
	{
		eax_182 = Mem173[0x08083940<p32>:word32];
		qwLoc24_432 = CONVERT(eax_182 >>u 0x02, word32, uint64);
		rLoc1_433 = CONVERT(qwLoc24_432, int64, real64);
		rLoc1_434 = rLoc1_433 * rLoc2_406;
		rLoc1_435 = rLoc1_434 * CONVERT(Mem187[0x080718B8<p32>:real32], real32, real64);
		rLoc1_436 = rLoc1_435 / CONVERT(Mem187[0x080718AC<p32>:real32], real32, real64);
		wLoc26_437 = __fstcw();
		eax_194 = CONVERT(wLoc26_437, word16, word32);
		al_196 = SLICE(eax_194, byte, 0);
		ax_197 = SEQ(0x0C, al_196);
		__fldcw(ax_197);
		dwLoc2C_439 = CONVERT(rLoc1_436, real64, int32);
		__fldcw(wLoc26_437);
		esi_201 = dwLoc2C_439;
	}
	rLoc2_521 = ϕ(rLoc2_449, rLoc2_406);
	esi_245 = ϕ(esi_229, esi_201);
	caml_gc_message();
	caml_gc_message();
	if (dwArg04 == 0x00)
		ebx_259 = esi_245;
	ebx_263 = ϕ(ebx_18, ebx_259);
	if (Mem248[0x08083FDC<p32>:word32] == 0x00)
	{
		mark_slice();
		caml_gc_message();
	}
	else
	{
		sweep_slice();
		caml_gc_message();
	}
	P_516 = ϕ(P_300, P_282);
	ecx_513 = ϕ(ecx_285, ecx_266);
	Mem301 = ϕ(Mem294, Mem276);
	if (Mem301[0x08083FDC<p32>:word32] == 0x02)
	{
		caml_compact_heap_maybe();
		P_517 = SLICE(SCZOP_323, bool, 5);
	}
	P_515 = ϕ(P_516, P_517);
	ecx_512 = ϕ(ecx_513, ecx_322);
	eax_325 = Mem301[0x08083FE8<p32>:word32];
	edx_326 = 0x00;
	qwLoc24_475 = CONVERT(eax_325, word32, uint64);
	rLoc1_476 = CONVERT(qwLoc24_475, int64, real64);
	rLoc1_477 = rLoc1_476 + Mem329[0x08083930<p32>:real64];
	Mem334[0x08083930<p32>:real64] = rLoc1_477;
	Mem336[0x08083FE8<p32>:word32] = 0x00;
	Mem337[0x08083FF0<p32>:word32] = 0x00;
	rLoc1_478 = 0.0;
	Mem340[0x08083FE0<p32>:real64] = 0.0;
	Top_341 = 0x00;
	eax_343 = esi_245;
	SCZO_346 = cond(fp - 0x10);
	C_511 = SLICE(SCZO_346, bool, 1);
	O_514 = SLICE(SCZO_346, bool, 4);
	S_536 = SLICE(SCZO_346, bool, 0);
	Z_537 = SLICE(SCZO_346, bool, 2);
}

// 08064A1C: define clear_table
// Called from:
//      caml_empty_minor_heap
define clear_table
{
	word32 eax;
	Top_3 = 0;
	edx_8 = Mem6[eax + 0x00:word32];
	Mem9[eax + 0x0C:word32] = edx_8;
	edx_10 = Mem9[eax + 8:word32];
	Mem11[eax + 16:word32] = edx_10;
}

// 08064A2C: define caml_oldify_one
// Called from:
//      caml_oldify_local_roots
//      caml_oldify_one
//      caml_oldify_mopup
//      caml_empty_minor_heap
define caml_oldify_one
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	word32 eax;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	edi_20 = dwArg08;
	while (true)
	{
		ebx_294 = ϕ(dwArg04, edx_172, ebx_55, ebx_55, ebx_55);
		edx_275 = ϕ(edx, edx_172, edx_41, edx_67, edx_105);
		ecx_268 = ϕ(ecx, ecx_173, ecx_268, ecx_72, ecx_109);
		eax_265 = ϕ(eax, eax_167, eax_47, eax_81, eax_104);
		edi_35 = ϕ(edi_20, edi_178, edi_35, edi_35, edi_112);
		Mem28 = ϕ(Mem16, Mem175, Mem40, Mem40, Mem111);
		bl_21 = SLICE(ebx_294, byte, 0);
		SZP_22 = cond(bl_21 & 0x01);
		P_282 = SLICE(SZP_22, bool, 5);
		ebx_27 = ebx_294;
		if ((bl_21 & 0x01) != 0x00 || (ebx_27 >=u Mem28[0x08080410<p32>:word32] || ebx_27 <=u Mem28[0x0808040C<p32>:word32]))
			break;
		edx_41 = Mem40[ebx_27 + -4:word32];
		dl_46 = SLICE(edx_41, byte, 0);
		SZP_42 = cond(edx_41);
		P_280 = SLICE(SZP_42, bool, 5);
		if (edx_41 == 0x00)
		{
			eax_184 = Mem40[ebx_27 + 0x00:word32];
			Mem185[edi_35 + 0x00:word32] = eax_184;
			goto l08064BB3;
		}
		eax_47 = CONVERT(dl_46, byte, word32);
		if (eax_47 >u 0xF8)
		{
			if (eax_47 >u 0xFA)
			{
				caml_alloc_shr();
				P_286 = SLICE(SCZOP_134, bool, 5);
				if (edx_41 >>u 0x0A != 0x00)
				{
					edx_137 = 0x00;
					do
					{
						Mem142 = ϕ(Mem138, Mem145);
						edx_141 = ϕ(edx_137, edx_146);
						ecx_143 = ebx_27[edx_141 * 0x04];
						eax_131[edx_141 * 0x04] = ecx_143;
						edx_146 = edx_141 + 0x01;
					} while (edx_41 >>u 0x0A >u edx_146);
				}
				ecx_272 = ϕ(ecx_133, ecx_143);
				edx_154 = ebx_27 - 4;
				Mem155[ebx_27 + -4:word32] = 0x00;
				Mem158[ebx_27 + 0x00:word32] = eax_131;
				Mem161[edi_35 + 0x00:word32] = eax_131;
				goto l08064BB3;
			}
			if (eax_47 != 0xF9)
			{
				ebx_55 = Mem40[ebx_27 + 0x00:word32];
				bl_56 = SLICE(ebx_55, byte, 0);
				if ((bl_56 & 0x01) != 0x00)
					continue;
				eax_66 = ebx_55 >>u 0x0C & 0x07FF;
				edx_67 = 0x08084000[(ebx_55 >>u 0x17) * 0x04];
				if ((Mem40[edx_67 + eax_66:byte] & 0x07) != 0x00)
				{
					ecx_72 = ebx_55 - 0x04;
					eax_73 = ebx_55 - 0x04;
					if (Mem40[ebx_55 + -4:word32] == 0x00)
					{
						eax_76 = Mem40[ebx_55 + 0x00:word32];
						eax_77 = eax_76 - 0x04;
					}
					eax_79 = ϕ(eax_73, eax_77);
					eax_81 = CONVERT(Mem40[eax_79 + 0x00:byte], byte, word32);
					if (eax_81 != 0xFA && (eax_81 != 0xF6 && eax_81 != 0xFD))
						continue;
				}
				caml_alloc_shr();
				Mem108[edi_35 + 0x00:word32] = eax_104;
				ecx_109 = ebx_27 - 4;
				Mem110[ebx_27 + -4:word32] = 0x00;
				Mem111[ebx_27 + 0x00:word32] = eax_104;
				edi_112 = eax_104;
				continue;
			}
			else
			{
				ebx_114 = (edx_41 >>u 0x0A) * 0x04;
				esi_116 = ebx_27 - ebx_114;
				caml_oldify_one();
				P_284 = SLICE(SCZOP_122, bool, 5);
				v19_123 = Mem118[edi_35 + 0x00:word32] + ebx_114;
				Mem124[edi_35 + 0x00:word32] = v19_123;
				goto l08064BB3;
			}
		}
		caml_alloc_shr();
		P_283 = SLICE(SCZOP_170, bool, 5);
		Mem171[edi_35 + 0x00:word32] = eax_167;
		edx_172 = Mem171[ebx_27 + 0x00:word32];
		ecx_173 = ebx_27 - 4;
		Mem174[ebx_27 + -4:word32] = 0x00;
		Mem175[ebx_27 + 0x00:word32] = eax_167;
		if (edx_41 >>u 0x0A >u 0x01)
		{
			Mem180[eax_167 + 0x00:word32] = edx_172;
			edx_181 = Mem180[0x08080458<p32>:word32];
			Mem182[eax_167 + 4:word32] = edx_181;
			Mem183[0x08080458<p32>:word32] = ebx_27;
			goto l08064BB3;
		}
		edi_178 = eax_167;
	}
	Mem36[edi_35 + 0x00:word32] = ebx_27;
l08064BB3:
	P_279 = ϕ(P_280, P_282, P_283, P_284, P_286);
	edx_273 = ϕ(edx_41, edx_275, edx_181, edx_120, edx_154);
	ecx_267 = ϕ(ecx_268, ecx_268, ecx_173, ecx_121, ecx_272);
	eax_263 = ϕ(eax_184, eax_265, eax_167, eax_119, eax_131);
	SCZO_191 = cond(fp - 0x10);
	C_262 = SLICE(SCZO_191, bool, 1);
	O_278 = SLICE(SCZO_191, bool, 4);
	S_288 = SLICE(SCZO_191, bool, 0);
	Z_293 = SLICE(SCZO_191, bool, 2);
}

// 08064BBB: define caml_oldify_mopup
// Called from:
//      caml_empty_minor_heap
define caml_oldify_mopup
{
	ptr32 fp;
	word32 eax;
	word32 edx;
	Top_3 = 0;
	while (true)
	{
		edx_151 = ϕ(edx, edx_153, edx_154);
		eax_149 = ϕ(eax, eax_51, eax_92);
		Mem19 = ϕ(Mem16, Mem49, Mem86);
		edi_20 = Mem19[0x08080458<p32>:word32];
		SZP_21 = cond(edi_20);
		P_157 = SLICE(SZP_21, bool, 5);
		if (edi_20 == 0x00)
			break;
		ebx_25 = Mem19[edi_20 + 0x00:word32];
		esi_26 = ebx_25 + 4;
		eax_27 = Mem19[ebx_25 + 4:word32];
		Mem28[0x08080458<p32>:word32] = eax_27;
		eax_29 = Mem28[ebx_25 + 0x00:word32];
		al_30 = SLICE(eax_29, byte, 0);
		if ((al_30 & 0x01) == 0x00 && (eax_29 <u Mem28[0x08080410<p32>:word32] && eax_29 >u Mem28[0x0808040C<p32>:word32]))
			caml_oldify_one();
		edx_153 = ϕ(edx_151, edx_151, edx_151, edx_45);
		Mem49 = ϕ(Mem28, Mem28, Mem28, Mem41);
		eax_50 = Mem49[ebx_25 + -4:word32];
		eax_51 = eax_50 >>u 0x0A;
		if (eax_50 >>u 0x0A >u 0x01)
		{
			dwLoc20_121 = 0x01;
			do
			{
				dwLoc20_122 = ϕ(dwLoc20_121, dwLoc20_127);
				esi_72 = ϕ(esi_26, esi_88);
				Mem57 = ϕ(Mem55, Mem86);
				edx_58 = dwLoc20_122;
				eax_60 = edi_20[dwLoc20_122 * 0x04];
				al_61 = SLICE(eax_60, byte, 0);
				if ((al_61 & 0x01) == 0x00 && (eax_60 <u Mem57[0x08080410<p32>:word32] && eax_60 >u Mem57[0x0808040C<p32>:word32]))
					caml_oldify_one();
				else
					Mem73[esi_72 + 0x00:word32] = eax_60;
				edx_154 = ϕ(edx_80, edx_58);
				v17_85 = dwLoc20_122 + 0x01;
				dwLoc20_127 = v17_85;
				esi_88 = esi_72 + 0x04;
				eax_91 = Mem86[ebx_25 + -4:word32];
				eax_92 = eax_91 >>u 0x0A;
			} while (eax_91 >>u 0x0A >u v17_85);
		}
	}
	SCZO_96 = cond(fp - 0x10);
	C_148 = SLICE(SCZO_96, bool, 1);
	O_156 = SLICE(SCZO_96, bool, 4);
	S_158 = SLICE(SCZO_96, bool, 0);
	Z_159 = SLICE(SCZO_96, bool, 2);
}

// 08064C59: define caml_empty_minor_heap
// Called from:
//      caml_minor_collection
//      caml_gc_compaction
//      caml_gc_full_major
//      caml_gc_major
//      caml_gc_major_slice
define caml_empty_minor_heap
{
	ptr32 fp;
	word32 ecx;
	word32 edx;
	bool P;
	eax_15 = Mem13[0x08080414<p32>:word32];
	if (eax_15 != Mem13[0x08080410<p32>:word32])
	{
		Mem18[0x08080454<p32>:word32] = 0x01;
		caml_gc_message();
		caml_oldify_local_roots();
		ebx_32 = Mem21[0x0808041C<p32>:word32];
		if (ebx_32 <u Mem21[0x08080428<p32>:word32])
		{
			do
			{
				Mem37 = ϕ(Mem21, Mem42);
				ebx_36 = ϕ(ebx_32, ebx_50);
				eax_38 = Mem37[ebx_36 + 0x00:word32];
				eax_41 = Mem40[eax_38 + 0x00:word32];
				caml_oldify_one();
				ebx_50 = ebx_36 + 0x04;
			} while (Mem42[0x08080428:word32] >u ebx_50);
		}
		Mem62 = ϕ(Mem21, Mem42);
		caml_oldify_mopup();
		eax_63 = Mem62[0x08080438<p32>:word32];
		if (eax_63 <u Mem62[0x08080444<p32>:word32])
		{
			do
			{
				Mem68 = ϕ(Mem62, Mem90);
				eax_67 = ϕ(eax_63, eax_87);
				ecx_69 = Mem68[eax_67 + 0x00:word32];
				edx_70 = Mem68[ecx_69 + 0x00:word32];
				dl_71 = SLICE(edx_70, byte, 0);
				if ((dl_71 & 0x01) == 0x00 && (edx_70 <u Mem68[0x08080410<p32>:word32] && edx_70 >u Mem68[0x0808040C<p32>:word32]))
				{
					if (Mem68[edx_70 + -4:word32] == 0x00)
					{
						edx_84 = Mem68[edx_70 + 0x00:word32];
						Mem85[ecx_69 + 0x00:word32] = edx_84;
					}
					else
					{
						edx_82 = Mem68[0x0807D0A4<p32>:word32];
						Mem83[ecx_69 + 0x00:word32] = edx_82;
					}
				}
				Mem90 = ϕ(Mem68, Mem68, Mem85, Mem68, Mem83);
				eax_87 = eax_67 + 0x04;
			} while (Mem90[0x08080444:word32] >u eax_87);
		}
		Mem93 = ϕ(Mem62, Mem90);
		eax_94 = Mem93[0x0808040C<p32>:word32];
		edx_96 = Mem93[0x08080414<p32>:word32];
		if (Mem93[0x08080414<p32>:word32] <u eax_94)
			edx_98 = eax_94;
		edx_102 = ϕ(edx_96, edx_98);
		eax_100 = Mem93[0x08080410<p32>:word32];
		ecx_103 = eax_100 - edx_102;
		ecx_107 = 0x00;
		qwLoc14_165 = CONVERT(ecx_103 >>u 0x02, word32, uint64);
		rLoc1_166 = CONVERT(qwLoc14_165, int64, real64);
		rLoc1_167 = rLoc1_166 + Mem113[0x08083920<p32>:real64];
		Mem121[0x08083920<p32>:real64] = rLoc1_167;
		Mem123[0x08080414<p32>:word32] = eax_100;
		eax_124 = Mem123[0x0808040C<p32>:word32];
		Mem125[0x08080418<p32>:word32] = eax_124;
		clear_table();
		clear_table();
		caml_gc_message();
		Mem143[0x08080454<p32>:word32] = 0x00;
	}
	Top_203 = 0;
	P_198 = ϕ(P, P_142);
	edx_195 = ϕ(edx, edx_129);
	ecx_193 = ϕ(ecx, ecx_107);
	caml_final_empty_young();
	SCZO_147 = cond(fp - 0x0C);
	C_192 = SLICE(SCZO_147, bool, 1);
	O_197 = SLICE(SCZO_147, bool, 4);
	S_202 = SLICE(SCZO_147, bool, 0);
	Z_204 = SLICE(SCZO_147, bool, 2);
}

// 08064DA3: define caml_minor_collection
// Called from:
//      caml_garbage_collection
//      caml_check_urgent_gc
//      caml_set_minor_heap_size
//      caml_alloc_small
//      caml_alloc_string
//      caml_alloc
//      caml_copy_double
//      caml_array_unsafe_get_float
//      caml_make_vect
//      caml_array_get_float
//      caml_gc_minor
define caml_minor_collection
{
	ebx_14 = Mem13[0x08083FE8<p32>:word32];
	caml_empty_minor_heap();
	eax_17 = Mem13[0x08083FE8<p32>:word32];
	eax_18 = eax_17 - ebx_14;
	qwLoc14_48 = CONVERT(eax_18, word32, uint64);
	rLoc1_49 = CONVERT(qwLoc14_48, int64, real64);
	rLoc1_50 = rLoc1_49 + Mem21[0x08083928<p32>:real64];
	Mem25[0x08083928<p32>:real64] = rLoc1_50;
	Top_26 = 0x00;
	v10_27 = Mem25[0x08083938<p32>:word32] + 0x01;
	Mem28[0x08083938<p32>:word32] = v10_27;
	caml_major_collection_slice();
	Mem33[0x0807D3D4<p32>:word32] = 0x00;
	caml_final_do_calls();
	caml_empty_minor_heap();
	C_52 = SLICE(SCZO_37, bool, 1);
	O_53 = SLICE(SCZO_37, bool, 4);
	S_54 = SLICE(SCZO_37, bool, 0);
	Z_55 = SLICE(SCZO_37, bool, 2);
}

// 08064E0C: define caml_check_urgent_gc
// Called from:
//      caml_alloc_string
//      caml_alloc
//      caml_make_vect
//      caml_alloc_custom
define caml_check_urgent_gc
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	ebx_12 = Mem10[0x0807D294<p32>:word32];
	Mem14[0x0807D294<p32>:word32] = fp - 44;
	eax_15 = Mem14[0x0807D3D4<p32>:word32];
	SZP_16 = cond(eax_15);
	P_51 = SLICE(SZP_16, bool, 5);
	if (eax_15 != 0x00)
	{
		caml_minor_collection();
		P_52 = SLICE(SCZOP_26, bool, 5);
	}
	P_50 = ϕ(P_51, P_52);
	Mem28[0x0807D294<p32>:word32] = ebx_12;
	eax_30 = dwArg04;
	SCZO_33 = cond(fp - 0x08);
	C_48 = SLICE(SCZO_33, bool, 1);
	O_49 = SLICE(SCZO_33, bool, 4);
	S_53 = SLICE(SCZO_33, bool, 0);
	Z_55 = SLICE(SCZO_33, bool, 2);
}

// 08064E55: define reset_table
// Called from:
//      caml_set_minor_heap_size
define reset_table
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = eax;
	Mem0[eax + 20:word32] = 0x00;
	Mem0[eax + 24:word32] = 0x00;
	eax = Mem0[eax + 0x00:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_free();
	}
	Mem0[ebx + 4:word32] = 0x00;
	Mem0[ebx + 16:word32] = 0x00;
	Mem0[ebx + 8:word32] = 0x00;
	Mem0[ebx + 0x0C:word32] = 0x00;
	Mem0[ebx + 0x00:word32] = 0x00;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08064EA2: define caml_set_minor_heap_size
// Called from:
//      caml_init_gc
//      caml_gc_set
define caml_set_minor_heap_size
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	edi = Mem0[ebp + 8:word32];
	eax = Mem0[0x08080414<p32>:word32];
	SCZO = cond(eax - Mem0[0x08080410<p32>:word32]);
	if (Test(NE,Z))
		caml_minor_collection();
	eax = ebp - 28;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = edi;
	caml_aligned_malloc();
	ebx = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_out_of_memory();
	esi = eax + edi;
	Mem0[esp + 8:word32] = esi;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_page_table_add();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
		caml_raise_out_of_memory();
	eax = Mem0[0x0808040C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edx = Mem0[0x08080410<p32>:word32];
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = 0x02;
		caml_page_table_remove();
		eax = Mem0[0x0808045C<p32>:word32];
		Mem0[esp + 0x00:word32] = eax;
		free(Mem0[esp + 0x00:(ptr32 void)]);
	}
	eax = Mem0[ebp + -28:word32];
	Mem0[0x0808045C<p32>:word32] = eax;
	Mem0[0x0808040C<p32>:word32] = ebx;
	Mem0[0x08080410<p32>:word32] = esi;
	Mem0[0x08080418<p32>:word32] = ebx;
	Mem0[0x08080414<p32>:word32] = esi;
	Mem0[0x08083FF4<p32>:word32] = edi;
	eax = 0x0808041C;
	reset_table();
	eax = 0x08080438;
	reset_table();
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08064F74: define caml_alloc_table
// Called from:
//      caml_realloc_ref_table
define caml_alloc_table
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	word32 dwArg0C;
	Top_3 = 0;
	Mem18[dwArg04 + 20:word32] = dwArg08;
	Mem19[dwArg04 + 24:word32] = dwArg0C;
	eax_20 = dwArg0C + dwArg08;
	caml_stat_alloc();
	eax_31 = Mem23[dwArg04 + 0x00:word32];
	SZP_32 = cond(eax_31);
	P_76 = SLICE(SZP_32, bool, 5);
	if (eax_31 != 0x00)
		caml_stat_free();
	Mem44[dwArg04 + 0x00:word32] = eax_24;
	Mem45[dwArg04 + 0x0C:word32] = eax_24;
	eax_46 = Mem45[dwArg04 + 20:word32];
	edx_47 = eax_24 + eax_46 * 0x04;
	Mem48[dwArg04 + 8:word32] = edx_47;
	Mem49[dwArg04 + 16:word32] = edx_47;
	eax_50 = eax_46 + Mem49[dwArg04 + 24:word32];
	eax_51 = eax_24 + eax_50 * 0x04;
	Mem52[dwArg04 + 4:word32] = eax_51;
	SCZO_55 = cond(fp - 0x0C);
	C_73 = SLICE(SCZO_55, bool, 1);
	O_74 = SLICE(SCZO_55, bool, 4);
	S_77 = SLICE(SCZO_55, bool, 0);
	Z_79 = SLICE(SCZO_55, bool, 2);
}

// 08064FCA: define caml_realloc_ref_table
// Called from:
//      caml_modify
//      caml_initialize
//      caml_array_unsafe_set_addr
//      caml_array_set_addr
//      do_set
//      caml_weak_get_copy
define caml_realloc_ref_table
{
	word32 dwArg04;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	edi_16 = Mem14[dwArg04 + 0x00:word32];
	if (edi_16 == 0x00)
	{
		eax_92 = Mem91[0x08083FF4<p32>:word32];
		caml_alloc_table();
	}
	else
	{
		eax_21 = Mem14[dwArg04 + 16:word32];
		if (eax_21 == Mem14[dwArg04 + 8:word32])
		{
			caml_gc_message();
			eax_88 = Mem81[dwArg04 + 4:word32];
			Mem89[dwArg04 + 16:word32] = eax_88;
			caml_urge_major_slice();
		}
		else
		{
			eax_24 = Mem14[dwArg04 + 0x0C:word32];
			esi_26 = Mem25[dwArg04 + 20:word32];
			Mem28[dwArg04 + 20:word32] = esi_26 * 0x02;
			esi_29 = esi_26 * 0x02 + Mem28[dwArg04 + 24:word32];
			caml_gc_message();
			eax_53 = Mem51[dwArg04 + 0x00:word32];
			eax_55 = realloc(eax_53, esi_29 << 0x02);
			Mem56[dwArg04 + 0x00:word32] = eax_55;
			SZP_57 = cond(eax_55);
			P_149 = SLICE(SZP_57, bool, 5);
			if (eax_55 == 0x00)
				caml_fatal_error();
			ecx_62 = Mem56[dwArg04 + 20:word32];
			edx_63 = Mem56[dwArg04 + 24:word32];
			edx_64 = edx_63 + ecx_62;
			edx_65 = eax_55 + edx_64 * 0x04;
			Mem66[dwArg04 + 4:word32] = edx_65;
			ecx_67 = eax_55 + ecx_62 * 0x04;
			Mem68[dwArg04 + 8:word32] = ecx_67;
			ecx_72 = eax_24 - edi_16;
			eax_75 = eax_55 + (ecx_72 & ~0x03);
			SCZO_76 = cond(eax_75);
			C_140 = SLICE(SCZO_76, bool, 1);
			O_147 = SLICE(SCZO_76, bool, 4);
			S_151 = SLICE(SCZO_76, bool, 0);
			Z_155 = SLICE(SCZO_76, bool, 2);
			Mem77[dwArg04 + 0x0C:word32] = eax_75;
			Mem78[dwArg04 + 16:word32] = edx_65;
		}
	}
	Z_154 = ϕ(Z_101, Z_85, Z_155);
	S_150 = ϕ(S_99, S_83, S_151);
	P_148 = ϕ(P_103, P_87, P_149);
	O_146 = ϕ(O_102, O_86, O_147);
	edx_144 = ϕ(edx_98, edx, edx_65);
	ecx_142 = ϕ(ecx, ecx, ecx_72);
	eax_141 = ϕ(eax_97, eax_90, eax_75);
	C_139 = ϕ(C_100, C_84, C_140);
}

// 080650D0: define caml_page_table_initialize
// Called from:
//      caml_init_gc
define caml_page_table_initialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = 0x00;
	edx = 0x08084000;
	do
	{
		edx[eax * 0x04] = 0x08080460;
		++eax;
		SCZO = cond(eax - 0x0200);
	} while (Test(NE,Z));
	ax = 0x00;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080650F4: define caml_allocation_color
// Called from:
//      intern_alloc
define caml_allocation_color
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[0x08083FDC<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
l08065110:
		eax = 0x0300;
		goto l0806511C;
	}
	else
	{
		SCZO = cond(eax - 0x01);
		if (Test(EQ,Z))
		{
			eax = Mem0[ebp + 8:word32];
			SCZO = cond(eax - Mem0[0x08083FCC<p32>:word32]);
			if (Test(UGE,C))
				goto l08065110;
		}
		eax = 0x00;
l0806511C:
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
	}
}

// 0806511E: define caml_alloc_dependent_memory
define caml_alloc_dependent_memory
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x02;
	v7 = Mem0[0x08083FD4<p32>:word32] + eax;
	Mem0[0x08083FD4<p32>:word32] = v7;
	v8 = Mem0[0x08083FF0<p32>:word32] + eax;
	Mem0[0x08083FF0<p32>:word32] = v8;
	SCZO = cond(v8);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065135: define caml_free_dependent_memory
define caml_free_dependent_memory
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x02;
	edx = Mem0[0x08083FD4<p32>:word32];
	SCZO = cond(eax - edx);
	if (Test(UGT,CZ))
		Mem0[0x08083FD4<p32>:word32] = 0x00;
	else
	{
		edx -= eax;
		SCZO = cond(edx);
		Mem0[0x08083FD4<p32>:word32] = edx;
	}
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806515E: define caml_stat_resize
// Called from:
//      caml_ext_table_add
//      caml_final_register
define caml_stat_resize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = realloc(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:size_t]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_out_of_memory();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065181: define caml_stat_free
// Called from:
//      unix_execv
//      unix_execve
//      unix_execvpe
//      unix_execvp
//      unix_getaddrinfo
//      unix_gethostbyname
//      unix_open
//      unix_setgroups
//      caml_register_frametable
//      caml_scan_global_young_roots
//      caml_delete_global_root
//      caml_ext_table_free
//      reset_table
//      caml_alloc_table
//      caml_nativeint_format
//      caml_int64_format
//      caml_int32_format
//      caml_format_int
//      caml_format_float
//      caml_float_of_string
//      caml_float_of_substring
//      caml_finalize_channel
//      caml_close_channel
//      intern_cleanup
//      input_val_from_block
//      caml_input_value_from_malloc
//      caml_input_val_from_string
//      caml_input_val
//      caml_sys_system_command
//      caml_sys_open
//      caml_search_in_path
//      caml_search_dll_in_path
//      caml_search_exe_in_path
define caml_stat_free
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	SCZO_9 = cond(fp - 0x1C);
	C_18 = SLICE(SCZO_9, bool, 1);
	O_19 = SLICE(SCZO_9, bool, 4);
	S_20 = SLICE(SCZO_9, bool, 0);
	Z_21 = SLICE(SCZO_9, bool, 2);
	eax_10 = dwArg04;
	free(dwArg04);
}

// 08065194: define caml_free_for_heap
// Called from:
//      caml_shrink_heap
//      caml_alloc_shr
//      intern_cleanup
define caml_free_for_heap
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	SCZO_9 = cond(fp - 0x1C);
	C_19 = SLICE(SCZO_9, bool, 1);
	O_20 = SLICE(SCZO_9, bool, 4);
	S_21 = SLICE(SCZO_9, bool, 0);
	Z_22 = SLICE(SCZO_9, bool, 2);
	eax_11 = Mem6[dwArg04 + -16:word32];
	free(eax_11);
}

// 080651AA: define caml_stat_alloc
// Called from:
//      unix_getaddrinfo
//      unix_gethostbyname
//      unix_open
//      unix_putenv
//      unix_setgroups
//      cstringvect
//      cons
//      caml_init_frame_descriptors
//      caml_insert_global_root
//      caml_ext_table_init
//      caml_alloc_table
//      parse_format
//      caml_format_float
//      caml_float_of_string
//      caml_float_of_substring
//      caml_open_descriptor_in
//      intern_alloc
//      caml_input_val
//      caml_sys_system_command
//      caml_sys_open
//      caml_register_named_value
//      caml_final_register
//      caml_final_custom_operations
//      caml_register_custom_operations
//      caml_decompose_path
//      caml_read_directory
//      caml_search_in_path
//      caml_search_dll_in_path
define caml_stat_alloc
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	eax_14 = malloc(dwArg04);
	SZP_15 = cond(eax_14);
	P_43 = SLICE(SZP_15, bool, 5);
	if (eax_14 == 0x00)
	{
		SZP_19 = cond(dwArg04);
		P_44 = SLICE(SZP_19, bool, 5);
		if (dwArg04 != 0x00)
		{
			caml_raise_out_of_memory();
			P_45 = SLICE(SCZOP_24, bool, 5);
		}
	}
	P_42 = ϕ(P_43, P_44, P_45);
	eax_40 = ϕ(eax_14, eax_14, eax_23);
	SCZO_27 = cond(fp - 0x08);
	C_39 = SLICE(SCZO_27, bool, 1);
	O_41 = SLICE(SCZO_27, bool, 4);
	S_46 = SLICE(SCZO_27, bool, 0);
	Z_48 = SLICE(SCZO_27, bool, 2);
}

// 080651CF: define caml_modify
// Called from:
//      fn0804BE02
//      camlUnix__fun_2828
//      camlPervasives__at_exit_1322
//      camlArray__fill_1070
//      camlArray__fill_1135
//      camlArray__trickledown_1160
//      camlArray__trickle_1165
//      camlArray__bubbledown_1170
//      camlArray__trickleup_1178
//      camlArray__sortto_1217
//      camlArray__init_1037
//      camlArray__make_matrix_1042
//      camlArray__copy_1049
//      camlArray__append_1054
//      camlArray__sub_1081
//      camlArray__fill_1087
//      camlArray__map_1105
//      camlArray__mapi_1115
//      camlArray__fold_left_1139
//      camlArray__fold_right_1145
//      camlArray__sort_1152
//      camlArray__stable_sort_1188
//      camlHashtbl__insert_bucket_1068
//      camlHashtbl__add_1179
//      camlHashtbl__remove_1185
//      camlHashtbl__replace_1217
//      fn080578D0
//      camlHashtbl__clear_1054
//      camlHashtbl__add_1074
//      camlHashtbl__remove_1080
//      camlHashtbl__replace_1112
//      fn080582B0
//      camlHashtbl__fold_1138
//      camlBuffer__reset_1064
//      camlBuffer__resize_1066
//      camlPrintf__fun_1565
//      camlPrintf__fun_1587
//      camlPrintf__fun_1584
//      camlPrintf__fun_1581
//      camlPrintf__fun_1578
//      camlPrintf__fun_1575
//      camlPrintf__fun_1572
//      caml_install_signal_handler
//      caml_update_dummy
//      caml_alloc_array
//      caml_parse_engine
//      caml_gc_get
//      caml_gc_counters
//      caml_gc_quick_stat
//      caml_gc_stat
//      caml_get_exception_backtrace
define caml_modify
{
	word32 dwArg04;
	word32 dwArg08;
	word32 ecx;
	Top_3 = 0;
	edi_17 = Mem14[dwArg04 + 0x00:word32];
	Mem18[dwArg04 + 0x00:word32] = dwArg08;
	eax_23 = dwArg04 >>u 0x0C & 0x07FF;
	edx_24 = 0x08084000[(dwArg04 >>u 0x17) * 0x04];
	SZP_25 = cond(Mem18[edx_24 + eax_23:byte] & 0x01);
	Z_28 = SLICE(SZP_25, bool, 2);
	P_141 = SLICE(SZP_25, bool, 5);
	S_147 = SLICE(SZP_25, bool, 0);
	O_26 = false;
	C_27 = false;
	if ((Mem18[edx_24 + eax_23:byte] & 0x01) != 0x00)
	{
		if (Mem18[0x08083FDC<p32>:word32] == 0x00)
			caml_darken();
		edx_134 = ϕ(edx_24, edx_35);
		ecx_130 = ϕ(ecx, ecx_34);
		eax_127 = ϕ(eax_23, eax_33);
		Mem46 = ϕ(Mem18, Mem32);
		SZP_42 = cond(dwArg08 & 0x01);
		Z_45 = SLICE(SZP_42, bool, 2);
		P_142 = SLICE(SZP_42, bool, 5);
		S_148 = SLICE(SZP_42, bool, 0);
		O_43 = false;
		C_44 = false;
		if ((dwArg08 & 0x01) == 0x00)
		{
			eax_47 = Mem46[0x08080410<p32>:word32];
			SCZO_48 = cond(dwArg08 - eax_47);
			C_49 = SLICE(SCZO_48, bool, 1);
			O_136 = SLICE(SCZO_48, bool, 4);
			S_149 = SLICE(SCZO_48, bool, 0);
			Z_158 = SLICE(SCZO_48, bool, 2);
			if (dwArg08 >=u eax_47)
				goto l0806526F;
			edx_50 = Mem46[0x0808040C<p32>:word32];
			SCZO_51 = cond(dwArg08 - edx_50);
			C_124 = SLICE(SCZO_51, bool, 1);
			O_137 = SLICE(SCZO_51, bool, 4);
			S_150 = SLICE(SCZO_51, bool, 0);
			Z_159 = SLICE(SCZO_51, bool, 2);
			if (dwArg08 >u edx_50)
			{
				SZP_54 = cond(edi_17 & 0x01);
				P_143 = SLICE(SZP_54, bool, 5);
				if ((edi_17 & 0x01) == 0x00 && eax_47 >u edi_17)
				{
					SCZO_60 = cond(edx_50 - edi_17);
					C_61 = SLICE(SCZO_60, bool, 1);
					O_138 = SLICE(SCZO_60, bool, 4);
					S_151 = SLICE(SCZO_60, bool, 0);
					Z_160 = SLICE(SCZO_60, bool, 2);
					if (edx_50 <u edi_17)
						goto l0806526F;
				}
				eax_63 = Mem46[0x08080428<p32>:word32];
				if (eax_63 >=u Mem46[0x0808042C<p32>:word32])
					caml_realloc_ref_table();
				P_144 = ϕ(P_143, P_76);
				ecx_131 = ϕ(ecx_130, ecx_70);
				Mem78 = ϕ(Mem46, Mem68);
				eax_77 = 0x08080428;
				edx_79 = Mem78[0x08080428:word32];
				Mem83[edx_79 + 0x00:word32] = dwArg04;
				edx_84 = edx_79 + 0x04;
				SCZO_85 = cond(edx_79 + 0x04);
				C_125 = SLICE(SCZO_85, bool, 1);
				O_139 = SLICE(SCZO_85, bool, 4);
				S_152 = SLICE(SCZO_85, bool, 0);
				Z_161 = SLICE(SCZO_85, bool, 2);
				Mem86[0x08080428:word32] = edx_79 + 0x04;
			}
		}
	}
l0806526F:
	Z_157 = ϕ(Z_28, Z_45, Z_158, Z_159, Z_160, Z_161);
	S_146 = ϕ(S_147, S_148, S_149, S_150, S_151, S_152);
	P_140 = ϕ(P_141, P_142, P_142, P_142, P_143, P_144);
	O_135 = ϕ(O_26, O_43, O_136, O_137, O_138, O_139);
	edx_133 = ϕ(edx_24, edx_134, edx_134, edx_50, edx_50, edx_84);
	ecx_128 = ϕ(ecx, ecx_130, ecx_130, ecx_130, ecx_130, ecx_131);
	eax_126 = ϕ(eax_23, eax_127, eax_47, eax_47, eax_47, eax_77);
	C_123 = ϕ(C_27, C_44, C_49, C_124, C_61, C_125);
}

// 0806527C: define caml_initialize
// Called from:
//      caml_make_vect
define caml_initialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[ebx + 0x00:word32] = eax;
	SZP = cond(al & 0x01);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		SCZO = cond(eax - Mem0[0x08080410<p32>:word32]);
		if (Test(ULT,C))
		{
			SCZO = cond(eax - Mem0[0x0808040C<p32>:word32]);
			if (Test(UGT,CZ))
			{
				edx = ebx;
				edx >>= 0x17;
				eax = ebx;
				eax >>= 0x0C;
				eax &= 0x07FF;
				edx = 0x08084000[edx * 0x04];
				SZP = cond(Mem0[edx + eax:byte] & 0x01);
				O = false;
				C = false;
				if (Test(NE,Z))
				{
					eax = Mem0[0x08080428<p32>:word32];
					SCZO = cond(eax - Mem0[0x0808042C<p32>:word32]);
					if (Test(UGE,C))
					{
						Mem0[esp + 0x00:word32] = 0x0808041C;
						caml_realloc_ref_table();
					}
					eax = 0x08080428;
					edx = Mem0[eax + 0x00:word32];
					Mem0[edx + 0x00:word32] = ebx;
					edx += 0x04;
					SCZO = cond(edx);
					Mem0[eax + 0x00:word32] = edx;
				}
			}
		}
	}
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080652E8: define caml_adjust_gc_speed
// Called from:
//      caml_alloc_custom
define caml_adjust_gc_speed
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	ecx = 0x01;
	if (Test(EQ,Z))
		eax = ecx;
	SCZO = cond(eax - edx);
	if (Test(ULE,CZ))
		edx = eax;
	ecx = 0x00;
	Mem0[ebp + -16:word32] = edx;
	Mem0[ebp + -0x0C:word32] = ecx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -16:int64], int64, real64);
	edx = 0x00;
	Mem0[ebp + -16:word32] = eax;
	Mem0[ebp + -0x0C:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -16:int64], int64, real64);
	ST[Top + 1:real64] /= ST[Top + 0x00:real64];
	++Top;
	ST[Top + 0x00:real64] += Mem0[0x08083FE0<p32>:real64];
	Mem0[0x08083FE0<p32>:real64] = ST[Top + 0x00:real64];
	--Top;
	ST[Top + 0x00:real64] = 1.0;
	v15 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v15;
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	if (Test(UGT,CZ))
	{
		--Top;
		ST[Top + 0x00:real64] = 1.0;
		Mem0[0x08083FE0<p32>:real64] = ST[Top + 0x00:real64];
		++Top;
		caml_urge_major_slice();
	}
	eax = Mem0[0x08083FF4<p32>:word32];
	eax >>= 0x02;
	edx = 0x00;
	Mem0[ebp + -16:word32] = eax;
	Mem0[ebp + -0x0C:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -16:int64], int64, real64);
	ST[Top + 0x00:real64] *= CONVERT(Mem0[0x080718B0<p32>:real32], real32, real64);
	eax = Mem0[0x08083940<p32>:word32];
	eax >>= 0x02;
	edx = 0x00;
	Mem0[ebp + -16:word32] = eax;
	Mem0[ebp + -0x0C:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -16:int64], int64, real64);
	ST[Top + 1:real64] /= ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = Mem0[0x08083FE0<p32>:real64];
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	if (Test(UGT,CZ))
		caml_urge_major_slice();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806538B: define caml_alloc_for_heap
// Called from:
//      caml_init_major_heap
//      caml_alloc_shr
//      intern_alloc
define caml_alloc_for_heap
{
	ptr32 fp;
	struct <anonymous> tLoc10;
	word32 dwArg04;
	word32 ecx;
	Top_3 = 0;
	dwLoc24_48 = &tLoc10;
	caml_aligned_malloc();
	SZP_26 = cond(eax_19);
	P_60 = SLICE(SZP_26, bool, 5);
	if (eax_19 != 0x00)
	{
		eax_30 = eax_19 + 0x10;
		edx_32 = eax_19;
		Mem33[eax_19 + 8:word32] = dwArg04;
		ecx_34 = Mem33[&tLoc10 + 0x00:word32];
		Mem35[eax_19 + 0x00:word32] = ecx_34;
	}
	edx_57 = ϕ(edx_20, edx_32);
	ecx_55 = ϕ(ecx, ecx_34);
	eax_54 = ϕ(eax_19, eax_30);
	SCZO_38 = cond(fp - 0x08);
	C_53 = SLICE(SCZO_38, bool, 1);
	O_58 = SLICE(SCZO_38, bool, 4);
	S_61 = SLICE(SCZO_38, bool, 0);
	Z_63 = SLICE(SCZO_38, bool, 2);
}

// 080653C7: define caml_page_table_modify
// Called from:
//      caml_page_table_remove
//      caml_page_table_add
define caml_page_table_modify
{
	word32 eax;
	word32 edx;
	word32 ecx;
	bool P;
	Top_3 = 0;
	bLoc20_69 = SLICE(ecx, byte, 0);
	if (0x08084000[(eax >>u 0x17) * 0x04] == 0x08080460)
	{
		eax_27 = calloc(0x0800, 0x01);
		edx_28 = eax_27;
		eax_29 = ~0x00;
		SZP_30 = cond(eax_27);
		Z_33 = SLICE(SZP_30, bool, 2);
		P_84 = SLICE(SZP_30, bool, 5);
		S_88 = SLICE(SZP_30, bool, 0);
		if (eax_27 == 0x00)
		{
l08065435:
			Z_92 = ϕ(Z_33, Z_93);
			S_87 = ϕ(S_88, S_89);
			P_83 = ϕ(P_84, P_85);
			O_82 = false;
			edx_80 = ϕ(edx_28, edx_81);
			eax_79 = ϕ(eax_29, eax_52);
			C_78 = false;
			return;
		}
		0x08084000[(eax >>u 0x17) * 0x04] = eax_27;
	}
	P_85 = ϕ(P, P_84);
	edx_81 = ϕ(edx, edx_28);
	Mem39 = ϕ(Mem20, Mem34);
	ebx_37 = eax >>u 0x0C & 0x07FF;
	ebx_40 = ebx_37 + 0x08084000[(eax >>u 0x17) * 0x04];
	eax_43 = ~edx;
	al_44 = SLICE(eax_43, byte, 0);
	al_45 = al_44 & Mem39[ebx_40 + 0x00:byte];
	al_47 = al_45 | bLoc20_69;
	SZ_48 = cond(al_47);
	S_89 = SLICE(SZ_48, bool, 0);
	Z_93 = SLICE(SZ_48, bool, 2);
	Mem51[ebx_40 + 0x00:byte] = al_47;
	eax_52 = 0x00;
	goto l08065435;
}

// 08065442: define caml_page_table_remove
// Called from:
//      caml_set_minor_heap_size
//      caml_shrink_heap
define caml_page_table_remove
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	word32 dwArg0C;
	word32 ecx;
	word32 edx;
	bool P;
	Top_3 = 0;
	ebx_20 = dwArg08 & ~0x0FFF;
	esi_23 = dwArg0C - 0x01 & ~0x0FFF;
	if ((dwArg08 & ~0x0FFF) <=u esi_23)
	{
		do
		{
			ebx_29 = ϕ(ebx_20, ebx_42);
			ecx_26 = 0x00;
			caml_page_table_modify();
			SZP_38 = cond(eax_31);
			P_93 = SLICE(SZP_38, bool, 5);
			if (eax_31 != 0x00)
			{
				eax_47 = ~0x00;
				goto l0806548F;
			}
			ebx_42 = ebx_29 + 0x1000;
		} while (esi_23 >=u ebx_42);
	}
	P_94 = ϕ(P, P_93);
	edx_89 = ϕ(edx, edx_32);
	ecx_86 = ϕ(ecx, ecx_26);
	eax_46 = 0x00;
l0806548F:
	P_92 = ϕ(P_93, P_94);
	edx_88 = ϕ(edx_32, edx_89);
	ecx_85 = ϕ(ecx_26, ecx_86);
	eax_84 = ϕ(eax_47, eax_46);
	SCZO_52 = cond(fp - 0x10);
	C_83 = SLICE(SCZO_52, bool, 1);
	O_91 = SLICE(SCZO_52, bool, 4);
	S_96 = SLICE(SCZO_52, bool, 0);
	Z_100 = SLICE(SCZO_52, bool, 2);
}

// 08065497: define caml_shrink_heap
// Called from:
//      caml_compact_heap
define caml_shrink_heap
{
	ptr32 fp;
	word32 dwArg04;
	word32 eax;
	word32 ecx;
	word32 edx;
	bool P;
	Top_3 = 0;
	if (dwArg04 != Mem13[0x08083FD8<p32>:word32])
	{
		eax_19 = Mem13[0x08083940<p32>:word32];
		eax_20 = eax_19 - Mem13[dwArg04 + -8:word32];
		Mem21[0x08083940<p32>:word32] = eax_20;
		caml_gc_message();
		v10_33 = Mem26[0x0808394C<p32>:word32] - 0x01;
		Mem34[0x0808394C<p32>:word32] = v10_33;
		eax_35 = Mem34[0x08083FD8<p32>:word32];
		edx_36 = 0x08083FD8;
		if (dwArg04 != eax_35)
		{
			do
			{
				eax_39 = ϕ(eax_35, eax_42);
				edx_40 = eax_39 - 4;
				eax_42 = Mem34[eax_39 + -4:word32];
			} while (dwArg04 != eax_42);
		}
		edx_50 = ϕ(edx_36, edx_40);
		eax_49 = Mem34[dwArg04 + -4:word32];
		Mem51[edx_50 + 0x00:word32] = eax_49;
		eax_54 = dwArg04 + Mem51[dwArg04 + -8:word32];
		caml_page_table_remove();
		caml_free_for_heap();
	}
	P_113 = ϕ(P, P_68);
	edx_110 = ϕ(edx, edx_63);
	ecx_108 = ϕ(ecx, ecx_62);
	eax_106 = ϕ(eax, eax_70);
	SCZO_77 = cond(fp - 0x0C);
	C_105 = SLICE(SCZO_77, bool, 1);
	O_112 = SLICE(SCZO_77, bool, 4);
	S_115 = SLICE(SCZO_77, bool, 0);
	Z_119 = SLICE(SCZO_77, bool, 2);
}

// 08065521: define caml_page_table_add
// Called from:
//      caml_main
//      caml_array_bound_error
//      caml_init_major_heap
//      caml_set_minor_heap_size
//      caml_add_to_heap
define caml_page_table_add
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	word32 dwArg0C;
	word32 ecx;
	word32 edx;
	bool P;
	Top_3 = 0;
	ebx_20 = dwArg08 & ~0x0FFF;
	esi_23 = dwArg0C - 0x01 & ~0x0FFF;
	if ((dwArg08 & ~0x0FFF) <=u esi_23)
	{
		do
		{
			ebx_29 = ϕ(ebx_20, ebx_42);
			ecx_27 = dwArg04;
			caml_page_table_modify();
			SZP_38 = cond(eax_31);
			P_93 = SLICE(SZP_38, bool, 5);
			if (eax_31 != 0x00)
			{
				eax_47 = ~0x00;
				goto l0806556E;
			}
			ebx_42 = ebx_29 + 0x1000;
		} while (esi_23 >=u ebx_42);
	}
	P_94 = ϕ(P, P_93);
	edx_89 = ϕ(edx, edx_32);
	ecx_86 = ϕ(ecx, ecx_27);
	eax_46 = 0x00;
l0806556E:
	P_92 = ϕ(P_93, P_94);
	edx_88 = ϕ(edx_32, edx_89);
	ecx_85 = ϕ(ecx_27, ecx_86);
	eax_84 = ϕ(eax_47, eax_46);
	SCZO_52 = cond(fp - 0x10);
	C_83 = SLICE(SCZO_52, bool, 1);
	O_91 = SLICE(SCZO_52, bool, 4);
	S_96 = SLICE(SCZO_52, bool, 0);
	Z_100 = SLICE(SCZO_52, bool, 2);
}

// 08065576: define caml_add_to_heap
// Called from:
//      caml_alloc_shr
//      intern_add_to_heap
define caml_add_to_heap
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	caml_gc_message();
	eax_31 = dwArg04 + Mem23[dwArg04 + -8:word32];
	caml_page_table_add();
	edx_44 = eax_36;
	eax_45 = ~0x00;
	SZP_46 = cond(eax_36);
	P_132 = SLICE(SZP_46, bool, 5);
	if (eax_36 == 0x00)
	{
		eax_50 = Mem35[0x08083FD8<p32>:word32];
		SZP_51 = cond(eax_50);
		P_135 = SLICE(SZP_51, bool, 5);
		if (eax_50 != 0x00 && dwArg04 >u eax_50)
		{
			do
			{
				eax_57 = ϕ(eax_50, eax_60);
				edx_58 = eax_57 - 4;
				eax_60 = Mem35[eax_57 + -4:word32];
				SZP_61 = cond(eax_60);
				P_136 = SLICE(SZP_61, bool, 5);
			} while (eax_60 != 0x00 && dwArg04 >u eax_60);
		}
		else
			edx_68 = 0x08083FD8;
		P_133 = ϕ(P_135, P_136, P_136);
		edx_77 = ϕ(edx_68, edx_58, edx_58);
		eax_69 = ϕ(eax_50, eax_60, eax_60);
		Mem74[dwArg04 + -4:word32] = eax_69;
		Mem78[edx_77 + 0x00:word32] = dwArg04;
		v15_79 = Mem78[0x0808394C<p32>:word32] + 0x01;
		Mem80[0x0808394C<p32>:word32] = v15_79;
		edx_81 = Mem80[0x08083940<p32>:word32];
		edx_82 = edx_81 + Mem80[dwArg04 + -8:word32];
		Mem83[0x08083940<p32>:word32] = edx_82;
		eax_84 = 0x00;
		if (edx_82 > Mem83[0x08083944<p32>:word32])
			Mem87[0x08083944<p32>:word32] = edx_82;
	}
	P_131 = ϕ(P_132, P_133, P_133);
	edx_129 = ϕ(edx_44, edx_82, edx_82);
	eax_124 = ϕ(eax_45, eax_84, eax_84);
	SCZO_93 = cond(fp - 0x0C);
	C_123 = SLICE(SCZO_93, bool, 1);
	O_130 = SLICE(SCZO_93, bool, 4);
	S_137 = SLICE(SCZO_93, bool, 0);
	Z_142 = SLICE(SCZO_93, bool, 2);
}

// 08065622: define caml_alloc_shr
// Called from:
//      caml_oldify_one
//      caml_alloc_string
//      caml_alloc
//      caml_make_vect
//      intern_alloc
//      caml_weak_create
//      caml_alloc_custom
define caml_alloc_shr
{
	word32 dwArg04;
	word32 dwArg08;
	Top_3 = 0;
	if (dwArg04 >u 0x003FFFFF)
		caml_raise_out_of_memory();
	caml_fl_allocate();
	ebx_33 = eax_25;
	if (eax_25 != 0x00)
	{
l0806575E:
		ecx_327 = ϕ(ecx_26, ecx_184);
		ebx_200 = ϕ(ebx_33, ebx_191);
		Mem192 = ϕ(Mem24, Mem182);
		eax_193 = Mem192[0x08083FDC<p32>:word32];
		SZP_194 = cond(eax_193);
		P_335 = SLICE(SZP_194, bool, 5);
		if (eax_193 != 0x00 && (eax_193 != 0x01 || ebx_200 <u Mem192[0x08083FCC<p32>:word32]))
		{
			eax_211 = (dwArg04 << 0x0A) + dwArg08;
			Mem214[ebx_200 + 0x00:word32] = eax_211;
		}
		else
		{
			eax_222 = dwArg08 + 0x0300 + (dwArg04 << 0x0A);
			Mem224[ebx_200 + 0x00:word32] = eax_222;
		}
		Mem225 = ϕ(Mem224, Mem214);
		eax_226 = Mem225[0x08083FE8<p32>:word32];
		eax_228 = dwArg04 + 1 + eax_226;
		Mem229[0x08083FE8<p32>:word32] = eax_228;
		edx_230 = Mem229[0x08083FF4<p32>:word32];
		edx_231 = edx_230 >>u 0x02;
		SCZO_232 = cond(eax_228 - (edx_230 >>u 0x02));
		C_323 = SLICE(SCZO_232, bool, 1);
		O_331 = SLICE(SCZO_232, bool, 4);
		S_338 = SLICE(SCZO_232, bool, 0);
		Z_346 = SLICE(SCZO_232, bool, 2);
		if (eax_228 >u edx_230 >>u 0x02)
			caml_urge_major_slice();
		eax_237 = ebx_200 + 4;
		return;
	}
	edx_41 = SLICE(dwArg04 *u64 1374389535, word32, 32);
	edx_43 = (edx_41 >>u 0x05) *s Mem24[0x08083FD0<p32>:word32];
	eax_44 = dwArg04 + 1 + edx_43;
	caml_round_heap_chunk_size();
	ebx_55 = eax_51;
	caml_alloc_for_heap();
	edi_65 = eax_57;
	if (eax_57 != 0x00)
	{
		edx_81 = (eax_51 >>u 0x02) - 0x01;
		ecx_82 = eax_57;
		if (edx_81 >u 0x003FFFFF)
		{
			while (true)
			{
				ecx_91 = ϕ(ecx_82, ecx_100);
				ebx_88 = ϕ(ebx_55, ebx_89);
				eax_85 = ϕ(eax_57, eax_87);
				Mem86[eax_85 + 0x00:word32] = ~0x01FF;
				eax_87 = eax_85 + 0x01000000;
				ebx_89 = ebx_88 - 0x01000000;
				Mem92[ecx_91 + 4:word32] = eax_87 + 4;
				Mem94[eax_57 + 8:word32] = eax_87 + 4;
				edx_97 = (ebx_89 >>u 0x02) - 0x01;
				if (edx_97 <=u 0x003FFFFF)
					break;
				ecx_100 = eax_87;
			}
			ecx_101 = eax_87;
		}
		edx_111 = ϕ(edx_81, edx_97);
		eax_109 = ϕ(eax_57, eax_87);
		ecx_105 = ϕ(ecx_82, ecx_101);
		ebx_102 = ϕ(ebx_55, ebx_89);
		if (ebx_102 >u 0x01)
		{
			edx_112 = edx_111 << 0x0A;
			Mem114[eax_109 + 0x00:word32] = edx_112 + 0x0200;
			ecx_115 = ecx_105 + 0x04;
			Mem118[eax_57 + 8:word32] = ecx_115;
			Mem119[ecx_115 + 0x00:word32] = 0x00;
		}
		else
		{
			Mem106[ecx_105 + 4:word32] = 0x00;
			if (ebx_102 == 0x01)
				Mem110[eax_109 + 0x00:word32] = 0x00;
		}
		caml_add_to_heap();
		if (eax_125 != 0x00)
			caml_free_for_heap();
		else
		{
			edi_137 = eax_57 + 0x04;
			if (eax_57 != ~0x03)
				goto l0806574C;
		}
	}
	else
		caml_gc_message();
	edi_161 = ϕ(edi_65, edi_65, edi_137);
	Mem146 = ϕ(Mem72, Mem140, Mem124);
	if (Mem146[0x08080454<p32>:word32] != 0x00)
		caml_fatal_error();
	caml_raise_out_of_memory();
l0806574C:
	edi_170 = ϕ(edi_137, edi_161);
	caml_fl_add_blocks();
	caml_fl_allocate();
	ebx_191 = eax_183;
	goto l0806575E;
}

// 080657C4: define caml_convert_flag_list
// Called from:
//      unix_access
//      unix_getnameinfo
//      unix_open
//      unix_sendto_native
//      unix_send
//      unix_recvfrom
//      unix_recv
//      unix_waitpid
//      extern_value
//      caml_sys_open
define caml_convert_flag_list
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	edx = Mem0[ebp + 8:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	eax = 0x00;
	SCZO = cond(edx - 0x01);
	while (Test(NE,Z))
	{
		ecx = Mem0[edx + 0x00:word32];
		ecx >>= 0x01;
		eax |= ebx[ecx * 0x04];
		edx = Mem0[edx + 4:word32];
		SCZO = cond(edx - 0x01);
	}
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080657EA: define caml_update_dummy
define caml_update_dummy
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	edi = Mem0[ebp + 0x0C:word32];
	eax = edi - 4;
	ecx = Mem0[eax + 0x00:word32];
	edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
	esi = Mem0[ebp + 8:word32];
	Mem0[esi + -4:byte] = dl;
	SCZO = cond(dl - ~0x01);
	if (Test(NE,Z))
	{
		ecx >>= 0x0A;
		Mem0[ebp + -28:word32] = ecx;
		ebx = 0x00;
		SZP = cond(ecx & ecx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			do
			{
				eax = edi[ebx * 0x04];
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = esi;
				caml_modify();
				++ebx;
				esi += 0x04;
				SCZO = cond(Mem0[ebp + -28:word32] - ebx);
			} while (Test(UGT,CZ));
		}
	}
	else
	{
		edx = Mem0[eax + 0x00:word32];
		edx >>= 11;
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			eax = 0x00;
			do
			{
				--Top;
				ST[Top + 0x00:real64] = edi[eax * 0x08];
				esi[eax * 0x08] = ST[Top + 0x00:real64];
				++Top;
				++eax;
				SCZO = cond(edx - eax);
			} while (Test(UGT,CZ));
		}
	}
	eax = 0x01;
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806585E: define caml_alloc_final
define caml_alloc_final
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_final_custom_operations();
	edx = Mem0[ebp + 20:word32];
	Mem0[esp + 0x0C:word32] = edx;
	edx = Mem0[ebp + 16:word32];
	Mem0[esp + 8:word32] = edx;
	edx = Mem0[ebp + 8:word32];
	edx <<= 0x02;
	SCZO = cond(edx);
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_custom();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065891: define caml_alloc_small
// Called from:
//      unix_accept
//      unix_getaddrinfo
//      alloc_group_entry
//      alloc_host_entry
//      unix_getnameinfo
//      alloc_proto_entry
//      alloc_passwd_entry
//      alloc_service_entry
//      alloc_tm
//      unix_mktime
//      unix_convert_itimer
//      unix_opendir
//      unix_pipe
//      fdset_to_fdlist
//      unix_select
//      unix_recvfrom
//      encode_sigset
//      alloc_sockaddr
//      unix_socketpair
//      stat_aux
//      unix_times
//      unix_error_of_code
//      unix_error
//      alloc_process_status
//      caml_raise_with_args
//      caml_raise_with_arg
//      caml_raise_constant
//      caml_install_signal_handler
//      caml_make_array
//      caml_make_vect
//      caml_ml_out_channels_list
//      intern_alloc
//      caml_sys_get_config
//      caml_sys_get_argv
//      caml_weak_get_copy
//      caml_weak_get
//      caml_alloc_custom
//      caml_get_exception_backtrace
define caml_alloc_small
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	Top_3 = 0;
	edx_14 = dwArg04 * 0x04 + 0x04;
	ebx_16 = -edx_14;
	eax_18 = ebx_16 + Mem12[0x08080414<p32>:word32];
	Mem19[0x08080414<p32>:word32] = eax_18;
	if (eax_18 <u Mem19[0x08080418<p32>:word32])
	{
		eax_22 = eax_18 + edx_14;
		Mem24[0x08080414<p32>:word32] = eax_22;
		caml_minor_collection();
		v12_28 = Mem24[0x08080414<p32>:word32] + ebx_16;
		Mem29[0x08080414<p32>:word32] = v12_28;
	}
	Mem34 = ϕ(Mem19, Mem29);
	edx_36 = dwArg08 + 0x0300 + (dwArg04 << 0x0A);
	eax_37 = Mem34[0x08080414<p32>:word32];
	Mem38[eax_37 + 0x00:word32] = edx_36;
	eax_39 = Mem38[0x08080414<p32>:word32];
	eax_40 = eax_39 + 0x04;
	SCZO_41 = cond(eax_39 + 0x04);
	C_57 = SLICE(SCZO_41, bool, 1);
	O_58 = SLICE(SCZO_41, bool, 4);
	S_59 = SLICE(SCZO_41, bool, 0);
	Z_61 = SLICE(SCZO_41, bool, 2);
}

// 080658FA: define caml_alloc_string
// Called from:
//      alloc_inet6_addr
//      alloc_inet_addr
//      caml_copy_string
//      caml_create_string
//      caml_output_value_to_string
//      caml_sys_error
//      caml_md5_chan
//      caml_md5_string
define caml_alloc_string
{
	ptr32 fp;
	word32 edi;
	word32 dwArg04;
	Top_3 = 0;
	ebx_17 = dwArg04 + 4 >>u 0x02;
	if (ebx_17 <=u 0x0100)
	{
		edx_31 = ebx_17 * 0x04 + 0x04;
		edi_33 = -edx_31;
		eax_35 = edi_33 + Mem14[0x08080414<p32>:word32];
		Mem36[0x08080414<p32>:word32] = eax_35;
		if (eax_35 <u Mem36[0x08080418<p32>:word32])
		{
			eax_39 = eax_35 + edx_31;
			Mem41[0x08080414<p32>:word32] = eax_39;
			caml_minor_collection();
			v14_46 = Mem41[0x08080414<p32>:word32] + edi_33;
			Mem47[0x08080414<p32>:word32] = v14_46;
		}
		Mem53 = ϕ(Mem36, Mem47);
		edx_52 = (ebx_17 << 0x0A) + 1020;
		eax_54 = Mem53[0x08080414<p32>:word32];
		Mem55[eax_54 + 0x00:word32] = edx_52;
		eax_56 = Mem55[0x08080414<p32>:word32];
		eax_57 = eax_56 + 0x04;
	}
	else
	{
		caml_alloc_shr();
		caml_check_urgent_gc();
	}
	eax_61 = ϕ(eax_28, eax_57);
	ebx_60 = __align(dwArg04 + 4, 4);
	Mem62[eax_61 - 4 + ebx_60:word32] = 0x00;
	dl_68 = SLICE(ebx_60, byte, 0) - 0x01;
	edx_24_8_98 = SLICE(ebx_60 - 0x01, word24, 8);
	ecx_67 = dwArg04;
	cl_69 = SLICE(dwArg04, byte, 0);
	dl_70 = dl_68 - cl_69;
	SCZO_71 = cond(dl_70);
	C_97 = SLICE(SCZO_71, bool, 1);
	O_100 = SLICE(SCZO_71, bool, 4);
	S_101 = SLICE(SCZO_71, bool, 0);
	Z_104 = SLICE(SCZO_71, bool, 2);
	Mem72[eax_61 + (ebx_60 - 0x01):byte] = dl_70;
	edx_99 = SEQ(edx_24_8_98, dl_70);
}

// 080659A4: define caml_copy_string
// Called from:
//      unix_error_message
//      unix_getaddrinfo
//      unix_getcwd
//      alloc_group_entry
//      alloc_host_entry
//      unix_gethostname
//      unix_getlogin
//      unix_getnameinfo
//      alloc_proto_entry
//      alloc_passwd_entry
//      alloc_service_entry
//      unix_readdir
//      unix_readlink
//      alloc_sockaddr
//      unix_string_of_inet_addr
//      unix_error
//      caml_raise_with_string
//      caml_nativeint_format
//      caml_int64_format
//      caml_int32_format
//      caml_format_int
//      caml_format_float
//      caml_sys_get_config
//      caml_sys_get_argv
//      caml_sys_getenv
//      caml_sys_error
//      caml_sys_getcwd
//      caml_get_exception_backtrace
define caml_copy_string
{
	word32 dwArg04;
	Top_3 = 0;
	size_18 = strlen(dwArg04) + 1;
	ecx_19 = ~0x00 - size_18;
	ecx_22 = ~ecx_19;
	caml_alloc_string();
	C_50 = SLICE(SCZO_27, bool, 1);
	O_51 = SLICE(SCZO_27, bool, 4);
	S_52 = SLICE(SCZO_27, bool, 0);
	Z_53 = SLICE(SCZO_27, bool, 2);
	memmove(eax_25, dwArg04, ecx_22 - 1);
	eax_34 = eax_25;
}

// 080659F3: define caml_alloc
// Called from:
//      caml_install_signal_handler
//      caml_alloc_dummy_float
//      caml_alloc_dummy
//      caml_alloc_array
//      caml_alloc_tuple
//      caml_make_vect
//      caml_weak_get_copy
//      caml_get_exception_backtrace
define caml_alloc
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	eax = 0x08083AA4 + esi * 0x04;
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(ebx - 0x0100);
		if (Test(ULE,CZ))
		{
			edx = 0x04 + ebx * 0x04;
			edi = edx;
			edi = -edi;
			eax = edi;
			eax += Mem0[0x08080414<p32>:word32];
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(ULT,C))
			{
				eax += edx;
				SCZO = cond(eax);
				Mem0[0x08080414<p32>:word32] = eax;
				caml_minor_collection();
				v17 = Mem0[0x08080414<p32>:word32] + edi;
				Mem0[0x08080414<p32>:word32] = v17;
				SCZO = cond(v17);
			}
			eax = ebx;
			eax <<= 0x0A;
			edx = esi + 0x0300 + eax;
			eax = Mem0[0x08080414<p32>:word32];
			Mem0[eax + 0x00:word32] = edx;
			ecx = Mem0[0x08080414<p32>:word32];
			eax = ecx + 4;
			SCZO = cond(esi - 0xFA);
			if (Test(ULE,CZ))
			{
				edx = 0x00;
				do
				{
					(ecx + 4)[edx * 0x04] = 0x00;
					++edx;
					SCZO = cond(edx - ebx);
				} while (Test(NE,Z));
			}
		}
		else
		{
			Mem0[esp + 4:word32] = esi;
			Mem0[esp + 0x00:word32] = ebx;
			caml_alloc_shr();
			edi = eax;
			SCZO = cond(esi - 0xFA);
			if (Test(ULE,CZ))
			{
				ebx <<= 0x02;
				SCZO = cond(ebx);
				Mem0[esp + 8:word32] = ebx;
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = eax;
				eax = memset(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:int32], Mem0[esp + 8:size_t]);
			}
			Mem0[esp + 0x00:word32] = edi;
			caml_check_urgent_gc();
		}
	}
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065ACD: define caml_alloc_dummy_float
define caml_alloc_dummy_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	edx = Mem0[ebp + 8:word32];
	eax = 0x08083AA4;
	edx &= ~0x01;
	SZ = cond(edx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = edx;
		caml_alloc();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065AF2: define caml_alloc_dummy
define caml_alloc_dummy
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	edx = Mem0[ebp + 8:word32];
	eax = 0x08083AA4;
	edx >>= 0x01;
	SCZ = cond(edx);
	O = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = edx;
		caml_alloc();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065B16: define caml_alloc_array
// Called from:
//      alloc_host_entry
//      caml_copy_string_array
define caml_alloc_array
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x5C;
	esi = Mem0[ebp + 0x0C:word32];
	eax = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -76:word32] = eax;
	Mem0[ebp + -28:word32] = 0x00;
	Mem0[ebp + -32:word32] = 0x00;
	Mem0[ebp + -64:word32] = eax;
	eax = ebp - 64;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -56:word32] = 0x01;
	Mem0[ebp + -60:word32] = 0x02;
	eax = ebp - 28;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -48:word32] = eax;
	SCZO = cond(Mem0[esi + 0x00:word32] - 0x00);
	if (Test(NE,Z))
	{
		ebx = 0x00;
		do
		{
			++ebx;
			SCZO = cond(esi[ebx * 0x04] - 0x00);
		} while (Test(NE,Z));
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 4:word32] = 0x00;
			Mem0[esp + 0x00:word32] = ebx;
			caml_alloc();
			Mem0[ebp + -32:word32] = eax;
			edi = 0x00;
			do
			{
				eax = Mem0[esi + 0x00:word32];
				Mem0[esp + 0x00:word32] = eax;
				Mem0[ebp + 8:word32]();
				Mem0[ebp + -28:word32] = eax;
				Mem0[esp + 4:word32] = eax;
				eax = 0x00 + edi * 0x04;
				eax += Mem0[ebp + -32:word32];
				SCZO = cond(eax);
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
				++edi;
				esi += 0x04;
				SCZO = cond(edi - ebx);
			} while (Test(ULT,C));
			eax = Mem0[ebp + -76:word32];
			Mem0[0x0807D294<p32>:word32] = eax;
			eax = Mem0[ebp + -32:word32];
l08065BD2:
			esp += 0x5C;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	eax = 0x08083AA4;
	edx = Mem0[ebp + -76:word32];
	Mem0[0x0807D294<p32>:word32] = edx;
	goto l08065BD2;
}

// 08065BDA: define caml_copy_string_array
// Called from:
//      unix_environment
//      alloc_group_entry
//      alloc_host_entry
//      alloc_proto_entry
//      alloc_service_entry
//      caml_sys_get_argv
//      caml_sys_read_directory
define caml_copy_string_array
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x080659A4;
	caml_alloc_array();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065BF5: define caml_alloc_tuple
// Called from:
//      unix_getgroups
//      unix_tcgetattr
//      caml_modf_float
//      caml_frexp_float
//      caml_gc_get
//      caml_gc_counters
//      caml_gc_quick_stat
//      caml_gc_stat
define caml_alloc_tuple
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = 0x00;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065C10: define compare_free_stack
// Called from:
//      compare_stack_overflow
//      compare_val
//      caml_greaterequal
//      caml_greaterthan
//      caml_lessequal
//      caml_lessthan
//      caml_notequal
//      caml_equal
//      caml_compare
define compare_free_stack
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[0x0807CFF4<p32>:word32];
	SCZO = cond(eax - 0x08080C60);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		free(Mem0[esp + 0x00:(ptr32 void)]);
		Mem0[0x0807CFF4<p32>:word32] = 0x08080C60;
		Mem0[0x0807CFF8<p32>:word32] = 0x08081860;
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08065C40: define compare_stack_overflow
// Called from:
//      compare_val
define compare_stack_overflow
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x08071994;
	Mem0[esp + 0x00:word32] = 0x04;
	caml_gc_message();
	compare_free_stack();
	caml_raise_out_of_memory();
	compare_val();
}

// 08065C6C: define compare_val
// Called from:
//      compare_stack_overflow
//      caml_greaterequal
//      caml_greaterthan
//      caml_lessequal
//      caml_lessthan
//      caml_notequal
//      caml_equal
//      caml_compare
define compare_val
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	SCZO = cond(esp);
	Mem0[ebp + -28:word32] = eax;
	Mem0[ebp + -32:word32] = edx;
	Mem0[ebp + -36:word32] = ecx;
	ebx = Mem0[0x0807CFF4<p32>:word32];
	while (true)
	{
		while (true)
		{
			while (true)
			{
l08065C84:
				eax = Mem0[ebp + -32:word32];
				SCZO = cond(Mem0[ebp + -28:word32] - eax);
				al = CONVERT(Test(EQ,Z), bool, int8);
				if (Test(EQ,Z))
				{
					SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
					if (Test(NE,Z))
						goto l080661D6;
				}
				SZP = cond(Mem0[ebp + -28:byte] & 0x01);
				O = false;
				C = false;
				if (Test(EQ,Z))
					break;
				SZP = cond(al & al);
				O = false;
				C = false;
				if (Test(NE,Z))
					goto l080661D6;
				SZP = cond(Mem0[ebp + -32:byte] & 0x01);
				O = false;
				C = false;
				if (Test(NE,Z))
				{
					eax = Mem0[ebp + -28:word32];
					eax >>= 0x01;
					ecx = Mem0[ebp + -32:word32];
					ecx >>= 0x01;
					eax -= ecx;
					SCZO = cond(eax);
					goto l0806625A;
				}
				ecx = Mem0[ebp + -32:word32];
				edx = ecx;
				edx >>= 0x17;
				eax = ecx;
				eax >>= 0x0C;
				eax &= 0x07FF;
				edx = 0x08084000[edx * 0x04];
				SZP = cond(Mem0[edx + eax:byte] & 0x07);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
l08066236:
					eax = ~0x00;
					goto l0806625A;
				}
				eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
				SCZO = cond(al - ~0x05);
				if (Test(NE,Z))
				{
					SCZO = cond(al - ~0x00);
					if (Test(EQ,Z))
					{
						ecx = Mem0[ebp + -32:word32];
						eax = Mem0[ecx + 0x00:word32];
						eax = Mem0[eax + 24:word32];
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(NE,Z))
						{
							Mem0[0x08084800<p32>:word32] = 0x00;
							Mem0[esp + 4:word32] = ecx;
							edx = Mem0[ebp + -28:word32];
							Mem0[esp + 0x00:word32] = edx;
							eax();
							SCZO = cond(Mem0[0x08084800<p32>:word32] - 0x00);
							if (Test(EQ,Z))
							{
l08065D3A:
								SZP = cond(eax & eax);
								O = false;
								C = false;
								if (Test(NE,Z))
									goto l0806625A;
								goto l080661D6;
							}
							SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
							if (Test(NE,Z))
								goto l08065D3A;
l0806621F:
							eax = 0x80000000;
							goto l0806625A;
						}
					}
					goto l08066236;
				}
				edx = Mem0[ebp + -32:word32];
				edx = Mem0[edx + 0x00:word32];
				Mem0[ebp + -32:word32] = edx;
			}
			SZP = cond(Mem0[ebp + -32:byte] & 0x01);
			O = false;
			C = false;
			esi = esi;
			if (Test(EQ,Z))
				break;
			ecx = Mem0[ebp + -28:word32];
			edx = ecx;
			edx >>= 0x17;
			eax = ecx;
			eax >>= 0x0C;
			eax &= 0x07FF;
			edx = 0x08084000[edx * 0x04];
			SZP = cond(Mem0[edx + eax:byte] & 0x07);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
l08066255:
				eax = 0x01;
				goto l0806625A;
			}
			eax = CONVERT(Mem0[ecx + -4:byte], byte, word32);
			SCZO = cond(al - ~0x05);
			if (Test(NE,Z))
			{
				SCZO = cond(al - ~0x00);
				if (Test(EQ,Z))
				{
					edx = Mem0[ebp + -28:word32];
					eax = Mem0[edx + 0x00:word32];
					eax = Mem0[eax + 24:word32];
					SZP = cond(eax & eax);
					O = false;
					C = false;
					if (Test(NE,Z))
					{
						Mem0[0x08084800<p32>:word32] = 0x00;
						ecx = Mem0[ebp + -32:word32];
						Mem0[esp + 4:word32] = ecx;
						Mem0[esp + 0x00:word32] = edx;
						eax();
						SCZO = cond(Mem0[0x08084800<p32>:word32] - 0x00);
						if (Test(NE,Z))
						{
							SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
							if (Test(EQ,Z))
								goto l0806621F;
						}
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(NE,Z))
							goto l0806625A;
						goto l080661D6;
					}
				}
				goto l08066255;
			}
			ecx = Mem0[ebp + -28:word32];
			ecx = Mem0[ecx + 0x00:word32];
			Mem0[ebp + -28:word32] = ecx;
		}
		edx = Mem0[ebp + -28:word32];
		Mem0[ebp + -40:word32] = edx;
		ecx = edx;
		ecx >>= 0x17;
		edx >>= 0x0C;
		edx &= 0x07FF;
		ecx = 0x08084000[ecx * 0x04];
		SZP = cond(Mem0[ecx + edx:byte] & 0x07);
		O = false;
		C = false;
		if (Test(EQ,Z))
			break;
		ecx = Mem0[ebp + -32:word32];
		Mem0[ebp + -44:word32] = ecx;
		ecx >>= 0x17;
		edx = Mem0[ebp + -32:word32];
		edx >>= 0x0C;
		edx &= 0x07FF;
		ecx = 0x08084000[ecx * 0x04];
		SZP = cond(Mem0[ecx + edx:byte] & 0x07);
		O = false;
		C = false;
		if (Test(EQ,Z))
			break;
		edi = Mem0[ebp + -40:word32];
		edi -= 0x04;
		esi = CONVERT(Mem0[edi + 0x00:byte], byte, word32);
		ecx = esi;
		edx = CONVERT(cl, byte, word32);
		ecx = Mem0[ebp + -44:word32];
		ecx -= 0x04;
		Mem0[ebp + -48:word32] = ecx;
		ecx = CONVERT(Mem0[ecx + 0x00:byte], byte, word32);
		Mem0[ebp + -52:byte] = cl;
		SCZO = cond(edx - 0xFA);
		if (Test(NE,Z))
		{
			ecx = CONVERT(Mem0[ebp + -52:byte], byte, word32);
			SCZO = cond(ecx - 0xFA);
			if (Test(EQ,Z))
			{
				edx = Mem0[ebp + -32:word32];
				edx = Mem0[edx + 0x00:word32];
				Mem0[ebp + -32:word32] = edx;
				continue;
			}
			SCZO = cond(edx - ecx);
			if (Test(NE,Z))
			{
				edx -= ecx;
				SCZO = cond(edx);
				eax = edx;
			}
			else
			{
				edx = esi + 9;
				v22 = dl;
				SCZO = cond(dl - 0x08);
				if (Test(ULE,CZ))
				{
					edx = CONVERT(dl, byte, word32);
					switch (v22)
					{
					case 0x00:
					case 0x02:
						break;
					case 0x01:
						goto l08066024;
					case 0x03:
						goto l080660CA;
					case 0x04:
						compare_free_stack();
						Mem0[esp + 0x00:word32] = 0x080719BD;
						caml_invalid_argument();
						break;
					case 0x05:
						SZP = cond(al & al);
						O = false;
						C = false;
						if (Test(NE,Z))
							goto l080661D6;
						ecx = Mem0[ebp + -28:word32];
						Mem0[esp + 0x00:word32] = ecx;
						caml_string_length();
						esi = eax;
						eax = Mem0[ebp + -32:word32];
						Mem0[esp + 0x00:word32] = eax;
						caml_string_length();
						edi = eax;
						SCZO = cond(eax - esi);
						eax = esi;
						if (Test(ULE,CZ))
							eax = edi;
						Mem0[esp + 8:word32] = eax;
						edx = Mem0[ebp + -32:word32];
						Mem0[esp + 4:word32] = edx;
						ecx = Mem0[ebp + -28:word32];
						Mem0[esp + 0x00:word32] = ecx;
						eax = memcmp(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(SG,S))
							goto l08066236;
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(GT,SZO))
							goto l08066255;
						SCZO = cond(esi - edi);
						esi = esi;
						if (Test(EQ,Z))
							goto l080661D6;
						eax = esi;
						eax -= edi;
						SCZO = cond(eax);
						goto l0806625A;
					case 0x06:
						eax = Mem0[ebp + -28:word32];
						--Top;
						ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
						edx = Mem0[ebp + -32:word32];
						--Top;
						ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
						CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
						O = false;
						S = false;
						if (Test(UGT,CZ))
						{
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							goto l08066236;
						}
						v26 = ST[Top + 0x00:real64];
						ST[Top + 0x00:real64] = ST[Top + 1:real64];
						ST[Top + 1:real64] = v26;
						CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
						O = false;
						S = false;
						if (Test(UGT,CZ))
						{
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							goto l08066255;
						}
						CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
						O = false;
						S = false;
						if (Test(PO,P) && Test(EQ,Z))
						{
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							goto l080661D6;
						}
						SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
						if (Test(EQ,Z))
						{
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							goto l0806621F;
						}
						CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
						O = false;
						S = false;
						++Top;
						if (Test(PE,P) || Test(NE,Z))
						{
							CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
							O = false;
							S = false;
							++Top;
							esi = esi;
							if (Test(NE,Z))
								goto l080661D6;
							if (Test(PO,P))
								goto l08066236;
							esi = esi;
							goto l080661D6;
						}
						else
						{
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							goto l08066255;
						}
					case 0x07:
						edx = Mem0[edi + 0x00:word32];
						edx >>= 11;
						ecx = Mem0[ebp + -48:word32];
						eax = Mem0[ecx + 0x00:word32];
						eax >>= 11;
						SCZO = cond(edx - eax);
						if (Test(NE,Z))
						{
							edx -= eax;
							SCZO = cond(edx);
							eax = edx;
							goto l0806625A;
						}
						SZP = cond(edx & edx);
						O = false;
						C = false;
						if (Test(EQ,Z))
							goto l080661D6;
						eax = Mem0[ebp + -40:word32];
						--Top;
						ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
						ecx = Mem0[ebp + -44:word32];
						--Top;
						ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
						CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
						O = false;
						S = false;
						if (Test(UGT,CZ))
						{
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							goto l08066236;
						}
						else
						{
							v28 = ST[Top + 0x00:real64];
							ST[Top + 0x00:real64] = ST[Top + 1:real64];
							ST[Top + 1:real64] = v28;
							CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
							O = false;
							S = false;
							if (Test(ULE,CZ))
							{
								eax = 0x00;
								esi = Mem0[ebp + -40:word32];
								do
								{
									CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
									O = false;
									S = false;
									if (Test(PO,P) && Test(EQ,Z))
									{
										ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
										++Top;
										ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
										++Top;
									}
									else
									{
										SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
										if (Test(EQ,Z))
										{
											ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
											++Top;
											ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
											++Top;
											goto l0806621F;
										}
										CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
										O = false;
										S = false;
										++Top;
										if (Test(PO,P) && Test(EQ,Z))
										{
											ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
											++Top;
											goto l08066255;
										}
										CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
										O = false;
										S = false;
										++Top;
										if (Test(PO,P))
										{
											if (Test(EQ,Z))
												goto l08066236;
											esi += 0x00;
										}
									}
									++eax;
									SCZO = cond(edx - eax);
									if (Test(ULE,CZ))
										goto l080661D6;
									--Top;
									ST[Top + 0x00:real64] = esi[eax * 0x08];
									--Top;
									ST[Top + 0x00:real64] = ecx[eax * 0x08];
									CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
									O = false;
									S = false;
									if (Test(UGT,CZ))
									{
										ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
										++Top;
										ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
										++Top;
										goto l08066236;
									}
									v30 = ST[Top + 0x00:real64];
									ST[Top + 0x00:real64] = ST[Top + 1:real64];
									ST[Top + 1:real64] = v30;
									CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
									O = false;
									S = false;
								} while (Test(ULE,CZ));
								ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
								++Top;
								ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
								++Top;
							}
							else
							{
								ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
								++Top;
								ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
								++Top;
							}
							goto l08066255;
						}
					case 0x08:
						eax = Mem0[ebp + -28:word32];
						ecx = Mem0[eax + 0x00:word32];
						edx = Mem0[ebp + -32:word32];
						eax = Mem0[edx + 0x00:word32];
						edx = Mem0[eax + 8:word32];
						SCZO = cond(edx - Mem0[ecx + 8:word32]);
						if (Test(EQ,Z))
						{
							SZP = cond(edx & edx);
							O = false;
							C = false;
							if (Test(EQ,Z))
							{
								esi += 0x00;
								compare_free_stack();
								Mem0[esp + 0x00:word32] = 0x080719BD;
								caml_invalid_argument();
							}
							Mem0[0x08084800<p32>:word32] = 0x00;
							ecx = Mem0[ebp + -32:word32];
							Mem0[esp + 4:word32] = ecx;
							eax = Mem0[ebp + -28:word32];
							Mem0[esp + 0x00:word32] = eax;
							edx();
							SCZO = cond(Mem0[0x08084800<p32>:word32] - 0x00);
							if (Test(NE,Z))
							{
								SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
								if (Test(EQ,Z))
									goto l0806621F;
							}
							SZP = cond(eax & eax);
							O = false;
							C = false;
							if (Test(NE,Z))
								goto l0806625A;
							goto l080661D6;
						}
						else
						{
							edx = Mem0[ecx + 0x00:word32];
							eax = Mem0[eax + 0x00:word32];
							Mem0[esp + 4:word32] = eax;
							Mem0[esp + 0x00:word32] = edx;
							eax = strcmp(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
							SZP = cond(eax & eax);
							O = false;
							C = false;
							if (Test(SG,S))
								goto l08066236;
							goto l08066255;
						}
					}
					compare_free_stack();
					Mem0[esp + 0x00:word32] = 0x080719D3;
					caml_invalid_argument();
l08066024:
					eax = Mem0[ebp + -40:word32];
					edx = Mem0[eax + 4:word32];
					edx >>= 0x01;
					ecx = Mem0[ebp + -44:word32];
					eax = Mem0[ecx + 4:word32];
					eax >>= 0x01;
					SCZO = cond(edx - eax);
					if (Test(EQ,Z))
						goto l080661D6;
					edx -= eax;
					SCZO = cond(edx);
					eax = edx;
				}
				else
				{
l080660CA:
					eax = Mem0[edi + 0x00:word32];
					eax >>= 0x0A;
					Mem0[ebp + -52:word32] = eax;
					edx = Mem0[ebp + -48:word32];
					eax = Mem0[edx + 0x00:word32];
					eax >>= 0x0A;
					SCZO = cond(Mem0[ebp + -52:word32] - eax);
					if (Test(EQ,Z))
					{
						SCZO = cond(Mem0[ebp + -52:word32] - 0x00);
						if (Test(EQ,Z))
							goto l080661D6;
						SCZO = cond(Mem0[ebp + -52:word32] - 0x01);
						if (Test(UGT,CZ))
						{
							ebx += 0x0C;
							eax = Mem0[0x0807CFF8<p32>:word32];
							SCZO = cond(ebx - eax);
							if (Test(UGE,C))
							{
								edx = Mem0[0x0807CFF4<p32>:word32];
								Mem0[ebp + -60:word32] = edx;
								eax -= edx;
								eax >>= 0x02;
								eax *= ~0x55555554;
								eax += eax;
								Mem0[ebp + -56:word32] = eax;
								SCZO = cond(eax - 0x000FFFFF);
								if (Test(UGT,CZ))
									compare_stack_overflow();
								edx = Mem0[0x0807CFF4<p32>:word32];
								SCZO = cond(edx - 0x08080C60);
								if (Test(EQ,Z))
								{
									eax = Mem0[ebp + -56:word32] *s 0x0C;
									Mem0[esp + 0x00:word32] = eax;
									eax = malloc(Mem0[esp + 0x00:size_t]);
									Mem0[ebp + -48:word32] = eax;
									SZP = cond(eax & eax);
									O = false;
									C = false;
									if (Test(EQ,Z))
										compare_stack_overflow();
									ecx = 0x0300;
									edi = Mem0[ebp + -48:word32];
									esi = 0x08080C60;
									size = ecx *u 0x04;
									memcpy(edi, esi, size);
									ecx = 0x00;
									esi += size;
									edi += size;
								}
								else
								{
									eax = Mem0[ebp + -56:word32] *s 0x0C;
									Mem0[esp + 4:word32] = eax;
									Mem0[esp + 0x00:word32] = edx;
									eax = realloc(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:size_t]);
									Mem0[ebp + -48:word32] = eax;
									SZP = cond(eax & eax);
									O = false;
									C = false;
									if (Test(EQ,Z))
										compare_stack_overflow();
								}
								ecx = Mem0[ebp + -48:word32];
								Mem0[0x0807CFF4<p32>:word32] = ecx;
								eax = Mem0[ebp + -56:word32] *s 0x0C;
								eax += ecx;
								Mem0[0x0807CFF8<p32>:word32] = eax;
								ebx -= Mem0[ebp + -60:word32];
								ebx &= ~0x03;
								ebx += ecx;
								SCZO = cond(ebx);
							}
							eax = Mem0[ebp + -40:word32];
							eax += 0x04;
							Mem0[ebx + 0x00:word32] = eax;
							eax = Mem0[ebp + -44:word32];
							eax += 0x04;
							Mem0[ebx + 4:word32] = eax;
							eax = Mem0[ebp + -52:word32];
							--eax;
							SCZO = cond(eax);
							Mem0[ebx + 8:word32] = eax;
						}
						eax = Mem0[ebp + -28:word32];
						eax = Mem0[eax + 0x00:word32];
						Mem0[ebp + -28:word32] = eax;
						edx = Mem0[ebp + -32:word32];
						edx = Mem0[edx + 0x00:word32];
						Mem0[ebp + -32:word32] = edx;
						continue;
					}
					ecx = Mem0[ebp + -52:word32];
					ecx -= eax;
					SCZO = cond(ecx);
					eax = ecx;
				}
			}
l0806625A:
			esp += 0x4C;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
		eax = Mem0[ebp + -28:word32];
		eax = Mem0[eax + 0x00:word32];
		Mem0[ebp + -28:word32] = eax;
	}
	SZP = cond(al & al);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		edx = Mem0[ebp + -28:word32];
		edx >>= 0x01;
		eax = Mem0[ebp + -32:word32];
		eax >>= 0x01;
		edx -= eax;
		SCZO = cond(edx);
		eax = edx;
		goto l0806625A;
	}
l080661D6:
	SCZO = cond(ebx - Mem0[0x0807CFF4<p32>:word32]);
	if (Test(EQ,Z))
	{
		eax = 0x00;
		goto l0806625A;
	}
	eax = Mem0[ebx + 0x00:word32];
	ecx = Mem0[eax + 0x00:word32];
	Mem0[ebp + -28:word32] = ecx;
	eax += 0x04;
	Mem0[ebx + 0x00:word32] = eax;
	eax = Mem0[ebx + 4:word32];
	edx = Mem0[eax + 0x00:word32];
	Mem0[ebp + -32:word32] = edx;
	eax += 0x04;
	Mem0[ebx + 4:word32] = eax;
	eax = Mem0[ebx + 8:word32];
	--eax;
	Mem0[ebx + 8:word32] = eax;
	edx = ebx - 0x0C;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		ebx = edx;
	goto l08065C84;
}

// 08066262: define caml_greaterequal
define caml_greaterequal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	ecx = 0x00;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	compare_val();
	ebx = eax;
	SCZO = cond(Mem0[0x0807CFF4<p32>:word32] - 0x08080C60);
	if (Test(NE,Z))
		compare_free_stack();
	eax = ebx;
	eax >>= 0x1F;
	eax &= ~0x01;
	eax += 0x03;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806629D: define caml_greaterthan
define caml_greaterthan
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	ecx = 0x00;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	compare_val();
	ebx = eax;
	SCZO = cond(Mem0[0x0807CFF4<p32>:word32] - 0x08080C60);
	if (Test(NE,Z))
		compare_free_stack();
	SZP = cond(ebx & ebx);
	O = false;
	al = CONVERT(Test(GT,SZO), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080662D9: define caml_lessequal
define caml_lessequal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	ecx = 0x00;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	compare_val();
	ebx = eax;
	SCZO = cond(Mem0[0x0807CFF4<p32>:word32] - 0x08080C60);
	if (Test(NE,Z))
		compare_free_stack();
	SZP = cond(ebx & ebx);
	O = false;
	dl = CONVERT(Test(LE,SZO), bool, int8);
	SCZO = cond(ebx - 0x80000000);
	al = CONVERT(Test(NE,Z), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax &= edx;
	eax += eax;
	++eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066321: define caml_lessthan
define caml_lessthan
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	ecx = 0x00;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	compare_val();
	ebx = eax;
	SCZO = cond(Mem0[0x0807CFF4<p32>:word32] - 0x08080C60);
	if (Test(NE,Z))
		compare_free_stack();
	ebx += 0x7FFFFFFF;
	SCZO = cond(ebx - 0x7FFFFFFF);
	eax = eax - eax - C;
	eax &= 0x02;
	++eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066365: define caml_notequal
define caml_notequal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	ecx = 0x00;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	compare_val();
	ebx = eax;
	SCZO = cond(Mem0[0x0807CFF4<p32>:word32] - 0x08080C60);
	if (Test(NE,Z))
		compare_free_stack();
	SCZO = cond(ebx - 0x01);
	eax = eax - eax - C;
	eax &= ~0x01;
	eax += 0x03;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080663A0: define caml_equal
define caml_equal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	ecx = 0x00;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	compare_val();
	ebx = eax;
	SCZO = cond(Mem0[0x0807CFF4<p32>:word32] - 0x08080C60);
	if (Test(NE,Z))
		compare_free_stack();
	SCZO = cond(ebx - 0x01);
	eax = eax - eax - C;
	eax &= 0x02;
	++eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080663DB: define caml_compare
define caml_compare
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	ecx = 0x01;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	compare_val();
	ebx = eax;
	SCZO = cond(Mem0[0x0807CFF4<p32>:word32] - 0x08080C60);
	if (Test(NE,Z))
		compare_free_stack();
	eax = ~0x00;
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
		al = CONVERT(Test(GT,SZO), bool, int8);
		eax = CONVERT(al, byte, word32);
		eax = eax + 1 + eax;
	}
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066420: define parse_sign_and_base
// Called from:
//      parse_intnat
//      caml_int64_of_string
define parse_sign_and_base
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	Mem0[ecx + 0x00:word32] = 0x01;
	SCZO = cond(Mem0[eax + 0x00:byte] - 0x2D);
	if (Test(EQ,Z))
	{
		Mem0[ecx + 0x00:word32] = ~0x00;
		++eax;
		SCZO = cond(eax);
	}
	Mem0[edx + 0x00:word32] = 0x0A;
	SCZO = cond(Mem0[eax + 0x00:byte] - 0x30);
	if (Test(EQ,Z))
	{
		ecx = CONVERT(Mem0[eax + 1:byte], byte, word32);
		ecx -= 66;
		v12 = cl;
		SCZO = cond(cl - 0x36);
		if (Test(ULE,CZ))
		{
			ecx = CONVERT(cl, byte, word32);
			switch (v12)
			{
			case 0x00:
			case 0x20:
				Mem0[edx + 0x00:word32] = 0x02;
				eax += 0x02;
				SCZO = cond(eax);
				break;
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case 0x09:
			case 0x0A:
			case 11:
			case 0x0C:
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x1F:
			case 33:
			case 0x22:
			case 0x23:
			case 0x24:
			case 0x25:
			case 0x26:
			case 0x27:
			case 0x28:
			case 0x29:
			case 0x2A:
			case 0x2B:
			case 44:
			case 0x2E:
			case 0x2F:
			case 0x30:
			case 0x31:
			case 0x32:
			case 0x33:
			case 0x34:
			case 0x35:
				break;
			case 0x0D:
			case 0x2D:
				Mem0[edx + 0x00:word32] = 0x08;
				eax += 0x02;
				SCZO = cond(eax);
				break;
			case 22:
			case 0x36:
				Mem0[edx + 0x00:word32] = 0x10;
				eax += 0x02;
				SCZO = cond(eax);
				break;
			}
		}
	}
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066479: define parse_digit
// Called from:
//      parse_intnat
//      caml_int64_of_string
define parse_digit
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	edx = eax;
	ecx = edx - 48;
	SCZO = cond(cl - 0x09);
	if (Test(ULE,CZ))
	{
		edx = CONVERT(al, byte, int32);
		eax = edx - 48;
	}
	else
	{
		ecx = eax - 65;
		SCZO = cond(cl - 0x05);
		if (Test(ULE,CZ))
		{
			edx = CONVERT(al, byte, int32);
			eax = edx - 55;
		}
		else
		{
			ecx = eax - 97;
			eax = ~0x00;
			SCZO = cond(cl - 0x05);
			if (Test(ULE,CZ))
			{
				eax = CONVERT(dl, byte, int32);
				eax -= 0x57;
				SCZO = cond(eax);
			}
		}
	}
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080664B3: define caml_int_compare
define caml_int_compare
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	SCZO = cond(edx - eax);
	cl = CONVERT(Test(GT,SZO), bool, int8);
	ecx = CONVERT(cl, byte, word32);
	SCZO = cond(edx - eax);
	dl = CONVERT(Test(LT,SO), bool, int8);
	edx = CONVERT(dl, byte, word32);
	eax = ecx;
	eax -= edx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080664D6: define int32_cmp
define int32_cmp
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	ecx = Mem0[eax + 4:word32];
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 4:word32];
	SCZO = cond(ecx - edx);
	al = CONVERT(Test(GT,SZO), bool, int8);
	eax = CONVERT(al, byte, word32);
	SCZO = cond(ecx - edx);
	dl = CONVERT(Test(LT,SO), bool, int8);
	edx = CONVERT(dl, byte, word32);
	eax -= edx;
	SCZO = cond(eax);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080664F9: define int32_hash
define int32_hash
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066504: define caml_int32_to_int
define caml_int32_to_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066513: define caml_int32_compare
define caml_int32_compare
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 4:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	SCZO = cond(edx - eax);
	cl = CONVERT(Test(GT,SZO), bool, int8);
	ecx = CONVERT(cl, byte, word32);
	SCZO = cond(edx - eax);
	dl = CONVERT(Test(LT,SO), bool, int8);
	edx = CONVERT(dl, byte, word32);
	eax = ecx;
	eax -= edx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806653C: define int64_cmp
define int64_cmp
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x0C;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 8:word32] = edi;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	esi = Mem0[edx + 4:word32];
	ecx = Mem0[edx + 8:word32];
	edi = Mem0[eax + 4:word32];
	edx = Mem0[eax + 8:word32];
	eax = 0x01;
	SCZO = cond(ecx - edx);
	if (Test(LE,SZO))
	{
		if (Test(LT,SO))
		{
l0806656E:
			eax = 0x00;
			goto l08066573;
		}
		SCZO = cond(esi - edi);
		if (Test(ULE,CZ))
			goto l0806656E;
	}
l08066573:
	ebx = 0x01;
	SCZO = cond(ecx - edx);
	if (Test(GE,SO))
	{
		if (Test(GT,SZO))
		{
l08066582:
			ebx = 0x00;
			goto l08066587;
		}
		SCZO = cond(esi - edi);
		if (Test(UGE,C))
			goto l08066582;
	}
l08066587:
	eax -= ebx;
	SCZO = cond(eax);
	ebx = Mem0[esp + 0x00:word32];
	esi = Mem0[esp + 4:word32];
	edi = Mem0[esp + 8:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066598: define int64_hash
define int64_hash
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080665A3: define caml_int64_to_int
define caml_int64_to_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080665B2: define caml_int64_compare
define caml_int64_compare
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x0C;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 8:word32] = edi;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	ebx = Mem0[edx + 4:word32];
	edx = Mem0[edx + 8:word32];
	esi = Mem0[eax + 4:word32];
	eax = Mem0[eax + 8:word32];
	edi = 0x01;
	SCZO = cond(edx - eax);
	if (Test(LE,SZO))
	{
		if (Test(LT,SO))
		{
l080665E4:
			edi = 0x00;
			goto l080665E9;
		}
		SCZO = cond(ebx - esi);
		if (Test(ULE,CZ))
			goto l080665E4;
	}
l080665E9:
	ecx = 0x01;
	SCZO = cond(edx - eax);
	if (Test(GE,SO))
	{
		if (Test(GT,SZO))
		{
l080665F8:
			ecx = 0x00;
			goto l080665FD;
		}
		SCZO = cond(ebx - esi);
		if (Test(UGE,C))
			goto l080665F8;
	}
l080665FD:
	edi -= ecx;
	SCZO = cond(edi);
	eax = edi + 1 + edi;
	ebx = Mem0[esp + 0x00:word32];
	esi = Mem0[esp + 4:word32];
	edi = Mem0[esp + 8:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066612: define nativeint_cmp
define nativeint_cmp
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	ecx = Mem0[eax + 4:word32];
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 4:word32];
	SCZO = cond(ecx - edx);
	al = CONVERT(Test(GT,SZO), bool, int8);
	eax = CONVERT(al, byte, word32);
	SCZO = cond(ecx - edx);
	dl = CONVERT(Test(LT,SO), bool, int8);
	edx = CONVERT(dl, byte, word32);
	eax -= edx;
	SCZO = cond(eax);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066635: define nativeint_hash
define nativeint_hash
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066640: define caml_nativeint_to_int
define caml_nativeint_to_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806664F: define caml_nativeint_compare
define caml_nativeint_compare
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 4:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	SCZO = cond(edx - eax);
	cl = CONVERT(Test(GT,SZO), bool, int8);
	ecx = CONVERT(cl, byte, word32);
	SCZO = cond(edx - eax);
	dl = CONVERT(Test(LT,SO), bool, int8);
	edx = CONVERT(dl, byte, word32);
	eax = ecx;
	eax -= edx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066678: define int32_deserialize
define int32_deserialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	caml_deserialize_sint_4();
	edx = Mem0[ebp + 8:word32];
	Mem0[edx + 0x00:word32] = eax;
	eax = 0x04;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806668F: define nativeint_deserialize
define nativeint_deserialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	caml_deserialize_uint_1();
	SCZO = cond(eax - 0x01);
	if (Test(NE,Z))
	{
		SCZO = cond(eax - 0x02);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = 0x08071AEC;
			caml_deserialize_error();
		}
		else
		{
			Mem0[esp + 0x00:word32] = 0x08071B18;
			caml_deserialize_error();
		}
	}
	else
	{
		caml_deserialize_sint_4();
		edx = Mem0[ebp + 8:word32];
		Mem0[edx + 0x00:word32] = eax;
	}
	eax = 0x04;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080666D3: define nativeint_serialize
define nativeint_serialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = 0x01;
	caml_serialize_int_1();
	Mem0[esp + 0x00:word32] = ebx;
	caml_serialize_int_4();
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[eax + 0x00:word32] = 0x04;
	eax = Mem0[ebp + 16:word32];
	Mem0[eax + 0x00:word32] = 0x08;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806670C: define int32_serialize
define int32_serialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_serialize_int_4();
	eax = Mem0[ebp + 16:word32];
	Mem0[eax + 0x00:word32] = 0x04;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[eax + 0x00:word32] = 0x04;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066734: define int64_deserialize
define int64_deserialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	SCZO = cond(esp);
	caml_deserialize_sint_8();
	ecx = eax;
	ebx = edx;
	edx = Mem0[ebp + 8:word32];
	Mem0[edx + 0x00:word32] = ecx;
	Mem0[edx + 4:word32] = ebx;
	eax = 0x08;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066757: define int64_serialize
define int64_serialize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_serialize_int_8();
	eax = Mem0[ebp + 16:word32];
	Mem0[eax + 0x00:word32] = 0x08;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[eax + 0x00:word32] = 0x08;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066786: define parse_intnat
// Called from:
//      caml_int_of_string
//      caml_nativeint_of_string
//      caml_int32_of_string
define parse_intnat
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x3C;
	SCZO = cond(esp);
	Mem0[ebp + -52:word32] = eax;
	Mem0[ebp + -56:word32] = edx;
	ecx = ebp - 28;
	edx = ebp - 32;
	parse_sign_and_base();
	ebx = eax;
	edi = Mem0[ebp + -32:word32];
	Mem0[ebp + -48:word32] = edi;
	eax = ~0x00;
	edx = 0x00;
	v13 = edx_eax;
	edx = CONVERT(v13 %u edi, word64, uint32);
	eax = CONVERT(v13 /u edi, word32, uint32);
	SCZO = cond(eax);
	Mem0[ebp + -44:word32] = eax;
	eax = CONVERT(Mem0[ebx + 0x00:byte], byte, int32);
	parse_digit();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SCZO = cond(edi - eax);
		if (Test(GT,SZO))
		{
l080667D3:
			++ebx;
			SCZO = cond(ebx);
			esi = eax;
l080667D8:
			eax = CONVERT(Mem0[ebx + 0x00:byte], byte, word32);
			SCZO = cond(al - 0x5F);
			if (Test(EQ,Z))
			{
l08066814:
				++ebx;
				SCZO = cond(ebx);
				goto l080667D8;
			}
			eax = CONVERT(al, byte, int32);
			parse_digit();
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NS,S))
			{
				SCZO = cond(edi - eax);
				if (Test(GT,SZO))
				{
					SCZO = cond(esi - Mem0[ebp + -44:word32]);
					if (Test(UGT,CZ))
					{
						Mem0[esp + 0x00:word32] = 134683455;
						caml_failwith();
					}
					esi *= Mem0[ebp + -48:word32];
					esi += eax;
					SCZO = cond(esi);
					if (Test(ULT,C))
					{
						Mem0[esp + 0x00:word32] = 134683455;
						caml_failwith();
					}
					goto l08066814;
				}
			}
			eax = Mem0[ebp + -52:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_string_length();
			eax += Mem0[ebp + -52:word32];
			SCZO = cond(ebx - eax);
			if (Test(NE,Z))
			{
				Mem0[esp + 0x00:word32] = 134683455;
				caml_failwith();
			}
			SCZO = cond(Mem0[ebp + -32:word32] - 0x0A);
			if (Test(EQ,Z))
			{
				SCZO = cond(Mem0[ebp + -28:word32] - 0x00);
				if (Test(NS,S))
				{
					ecx = Mem0[ebp + -56:word32];
					--ecx;
					eax = 0x01;
					eax <<= cl;
					SCZO = cond(eax - esi);
					if (Test(UGT,CZ))
						goto l080668AA;
					Mem0[esp + 0x00:word32] = 134683455;
					caml_failwith();
				}
				ecx = Mem0[ebp + -56:word32];
				--ecx;
				eax = 0x01;
				eax <<= cl;
				SCZO = cond(eax - esi);
				if (Test(UGE,C))
					goto l080668A4;
				Mem0[esp + 0x00:word32] = 134683455;
				caml_failwith();
			}
			SCZO = cond(Mem0[ebp + -56:word32] - 0x1F);
			if (Test(ULE,CZ))
			{
				eax = 0x01;
				ecx = CONVERT(Mem0[ebp + -56:byte], byte, word32);
				eax <<= cl;
				SCZO = cond(eax - esi);
				if (Test(ULE,CZ))
				{
					Mem0[esp + 0x00:word32] = 134683455;
					caml_failwith();
				}
			}
			SCZO = cond(Mem0[ebp + -28:word32] - 0x00);
			if (Test(SG,S))
			{
l080668A4:
				eax = esi;
				C = eax != 0x00;
				eax = -eax;
				SZO = cond(eax);
l080668AC:
				esp += 0x3C;
				SCZO = cond(esp);
				ebx = Mem0[esp + 0x00:word32];
				esp += 4;
				esi = Mem0[esp + 0x00:word32];
				esp += 4;
				edi = Mem0[esp + 0x00:word32];
				esp += 4;
				ebp = Mem0[esp + 0x00:word32];
				esp += 4;
				return;
			}
l080668AA:
			eax = esi;
			goto l080668AC;
		}
	}
	Mem0[esp + 0x00:word32] = 134683455;
	caml_failwith();
	goto l080667D3;
}

// 080668B4: define caml_int_of_string
define caml_int_of_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	edx = 0x1F;
	eax = Mem0[ebp + 8:word32];
	parse_intnat();
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080668CD: define parse_format
// Called from:
//      caml_nativeint_format
//      caml_int64_format
//      caml_int32_format
//      caml_format_int
define parse_format
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	SCZO = cond(esp);
	Mem0[ebp + -28:word32] = eax;
	Mem0[ebp + -32:word32] = edx;
	Mem0[ebp + -36:word32] = ecx;
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	ebx = eax;
	edi = Mem0[ebp + -32:word32];
	ecx = ~0x00;
	size = strlen(edi) + 1;
	ecx -= size;
	edi += size;
	ecx = ~ecx;
	esi = ecx - 1;
	eax = esi + 1 + ebx;
	SCZO = cond(eax - 0x1F);
	if (Test(UGT,CZ))
	{
		Mem0[esp + 0x00:word32] = 134683469;
		caml_invalid_argument();
	}
	Mem0[esp + 8:word32] = ebx;
	eax = Mem0[ebp + -28:word32];
	Mem0[esp + 4:word32] = eax;
	edx = Mem0[ebp + -36:word32];
	Mem0[esp + 0x00:word32] = edx;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	ecx = Mem0[ebp + -36:word32];
	ebx = ecx - 1 + ebx;
	edi = CONVERT(Mem0[ebx + 0x00:byte], byte, word32);
	edx = ebx - 1;
	eax = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
	SCZO = cond(al - 0x6C);
	if (Test(NE,Z))
	{
		SCZO = cond(al - 110);
		if (Test(NE,Z))
		{
			SCZO = cond(al - 0x4C);
			if (Test(NE,Z))
			{
l08066946:
				Mem0[esp + 8:word32] = esi;
				eax = Mem0[ebp + -32:word32];
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = ebx;
				eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
				ebx += esi;
				edx = edi;
				Mem0[ebx + 0x00:byte] = dl;
				Mem0[ebx + 1:byte] = 0x00;
				eax = Mem0[ebp + -28:word32];
				edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
				SZP = cond(dl & dl);
				O = false;
				C = false;
				if (Test(NE,Z))
				{
					edx -= 0x30;
					SCZO = cond(dl - 0x09);
					while (Test(UGT,CZ))
					{
						++eax;
						edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
						SZP = cond(dl & dl);
						O = false;
						C = false;
						if (Test(EQ,Z))
							goto l080669CD;
						edx -= 0x30;
						SCZO = cond(dl - 0x09);
					}
					Mem0[esp + 8:word32] = 0x0A;
					Mem0[esp + 4:word32] = 0x00;
					Mem0[esp + 0x00:word32] = eax;
					eax = strtol(Mem0[esp + 0x00:(ptr32 char)]);
					eax += 0x05;
					ecx = edi;
					edx = Mem0[ebp + 0x0C:word32];
					Mem0[edx + 0x00:byte] = cl;
					SCZO = cond(eax - 0x1F);
					if (Test(GT,SZO))
					{
						++eax;
						SCZO = cond(eax);
						Mem0[esp + 0x00:word32] = eax;
						caml_stat_alloc();
						Mem0[ebp + 8:word32] = eax;
					}
				}
				else
				{
l080669CD:
					ecx = edi;
					eax = Mem0[ebp + 0x0C:word32];
					Mem0[eax + 0x00:byte] = cl;
				}
				eax = Mem0[ebp + 8:word32];
				esp += 44;
				SCZO = cond(esp);
				ebx = Mem0[esp + 0x00:word32];
				esp += 4;
				esi = Mem0[esp + 0x00:word32];
				esp += 4;
				edi = Mem0[esp + 0x00:word32];
				esp += 4;
				ebp = Mem0[esp + 0x00:word32];
				esp += 4;
				return;
			}
		}
	}
	ebx = edx;
	goto l08066946;
}

// 080669D6: define caml_nativeint_format
define caml_nativeint_format
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = ebp - 56;
	eax = ebp - 89;
	Mem0[esp + 4:word32] = eax;
	edi = ebp - 88;
	Mem0[esp + 0x00:word32] = edi;
	ecx = esi;
	edx = 0x080723A3;
	eax = Mem0[ebp + 8:word32];
	parse_format();
	ebx = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = ebx;
	sprintf();
	Mem0[esp + 0x00:word32] = ebx;
	caml_copy_string();
	esi = eax;
	SCZO = cond(ebx - edi);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_stat_free();
	}
	eax = esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066A41: define caml_int64_format
define caml_int64_format
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = ebp - 56;
	eax = ebp - 89;
	Mem0[esp + 4:word32] = eax;
	edi = ebp - 88;
	Mem0[esp + 0x00:word32] = edi;
	ecx = esi;
	edx = 0x080711DE;
	eax = Mem0[ebp + 8:word32];
	parse_format();
	ebx = eax;
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 0x0C:word32] = edx;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = ebx;
	sprintf();
	Mem0[esp + 0x00:word32] = ebx;
	caml_copy_string();
	esi = eax;
	SCZO = cond(ebx - edi);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_stat_free();
	}
	eax = esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066AB3: define caml_int32_format
define caml_int32_format
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = ebp - 56;
	eax = ebp - 89;
	Mem0[esp + 4:word32] = eax;
	edi = ebp - 88;
	Mem0[esp + 0x00:word32] = edi;
	ecx = esi;
	edx = 0x08072228;
	eax = Mem0[ebp + 8:word32];
	parse_format();
	ebx = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = ebx;
	sprintf();
	Mem0[esp + 0x00:word32] = ebx;
	caml_copy_string();
	esi = eax;
	SCZO = cond(ebx - edi);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_stat_free();
	}
	eax = esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066B1E: define caml_format_int
define caml_format_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x60;
	SCZO = cond(esp);
	esi = Mem0[ebp + 0x0C:word32];
	ecx = ebp - 40;
	eax = ebp - 73;
	Mem0[esp + 4:word32] = eax;
	eax = ebp - 72;
	Mem0[esp + 0x00:word32] = eax;
	edx = 0x080723A3;
	eax = Mem0[ebp + 8:word32];
	parse_format();
	ebx = eax;
	eax = CONVERT(Mem0[ebp + -73:byte], byte, word32);
	SCZO = cond(al - 111);
	if (Test(NE,Z))
	{
		SCZO = cond(al - 111);
		if (Test(LE,SZO))
		{
			SCZO = cond(al - 88);
			if (Test(EQ,Z))
				goto l08066B66;
			goto l08066B7D;
		}
		SCZO = cond(al - 117);
		esi = esi;
		if (Test(EQ,Z))
			goto l08066B66;
		SCZO = cond(al - 0x78);
		if (Test(NE,Z))
		{
l08066B7D:
			esi >>= 0x01;
			SCZ = cond(esi);
			O = false;
			Mem0[esp + 8:word32] = esi;
			eax = ebp - 40;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = ebx;
			sprintf();
l08066B92:
			Mem0[esp + 0x00:word32] = ebx;
			caml_copy_string();
			esi = eax;
			eax = ebp - 72;
			SCZO = cond(ebx - eax);
			if (Test(NE,Z))
			{
				Mem0[esp + 0x00:word32] = ebx;
				caml_stat_free();
			}
			eax = esi;
			esp += 0x60;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
l08066B66:
	esi >>= 0x01;
	SCZO = cond(esi);
	Mem0[esp + 8:word32] = esi;
	eax = ebp - 40;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	sprintf();
	goto l08066B92;
}

// 08066BB4: define caml_nativeint_to_float
define caml_nativeint_to_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[eax + 4:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066BCA: define caml_int64_float_of_bits
define caml_int64_float_of_bits
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 4:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066BE0: define caml_int64_to_float
define caml_int64_to_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[eax + 4:int64], int64, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066BF6: define caml_int32_float_of_bits
define caml_int32_float_of_bits
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[eax + 4:real32], real32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066C0C: define caml_int32_to_float
define caml_int32_to_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[eax + 4:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066C22: define caml_copy_nativeint
// Called from:
//      caml_nativeint_of_string
//      caml_nativeint_of_int32
//      caml_nativeint_of_float
//      caml_nativeint_of_int
//      caml_nativeint_shift_right_unsigned
//      caml_nativeint_shift_right
//      caml_nativeint_shift_left
//      caml_nativeint_xor
//      caml_nativeint_or
//      caml_nativeint_and
//      caml_nativeint_mod
//      caml_nativeint_div
//      caml_nativeint_mul
//      caml_nativeint_sub
//      caml_nativeint_add
//      caml_nativeint_neg
//      caml_int64_to_nativeint
define caml_copy_nativeint
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 0x0C:word32] = 0x01;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x04;
	Mem0[esp + 0x00:word32] = 0x0807D034;
	caml_alloc_custom();
	edx = Mem0[ebp + 8:word32];
	Mem0[eax + 4:word32] = edx;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066C54: define caml_nativeint_of_string
define caml_nativeint_of_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	edx = 0x20;
	eax = Mem0[ebp + 8:word32];
	parse_intnat();
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066C71: define caml_nativeint_of_int32
define caml_nativeint_of_int32
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066C87: define caml_nativeint_of_float
define caml_nativeint_of_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -0x0A:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -0x0A:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -0x0C:word16] = ax;
	__fldcw(Mem0[ebp + -0x0C:word16]);
	Mem0[esp + 0x00:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -0x0A:word16]);
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066CAF: define caml_nativeint_of_int
define caml_nativeint_of_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066CC4: define caml_nativeint_shift_right_unsigned
define caml_nativeint_shift_right_unsigned
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax >>= cl;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066CE1: define caml_nativeint_shift_right
define caml_nativeint_shift_right
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	O = false;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax >>= cl;
	SCZ = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066CFE: define caml_nativeint_shift_left
define caml_nativeint_shift_left
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax <<= cl;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066D1B: define caml_nativeint_xor
define caml_nativeint_xor
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax = eax ^ Mem0[edx + 4:word32];
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066D37: define caml_nativeint_or
define caml_nativeint_or
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax |= Mem0[edx + 4:word32];
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066D53: define caml_nativeint_and
define caml_nativeint_and
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax &= Mem0[edx + 4:word32];
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066D6F: define caml_nativeint_mod
define caml_nativeint_mod
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 4:word32];
	eax = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[eax + 4:word32];
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_zero_divide();
	SCZO = cond(edx - 0x80000000);
	if (Test(EQ,Z))
	{
		SCZO = cond(ecx - ~0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = 0x00;
			caml_copy_nativeint();
l08066DB4:
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	eax = edx;
	edx >>= 0x1F;
	v15 = edx_eax;
	edx = CONVERT(v15 %s ecx, word64, int32);
	eax = CONVERT(v15 /32 ecx, word32, int32);
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = edx;
	caml_copy_nativeint();
	goto l08066DB4;
}

// 08066DB6: define caml_nativeint_div
define caml_nativeint_div
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 4:word32];
	ecx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[ecx + 4:word32];
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_zero_divide();
	SCZO = cond(edx - 0x80000000);
	if (Test(EQ,Z))
	{
		SCZO = cond(ecx - ~0x00);
		if (Test(EQ,Z))
		{
l08066DED:
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	eax = edx;
	edx >>= 0x1F;
	v15 = edx_eax;
	edx = CONVERT(v15 %s ecx, word64, int32);
	eax = CONVERT(v15 /32 ecx, word32, int32);
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	goto l08066DED;
}

// 08066DEF: define caml_nativeint_mul
define caml_nativeint_mul
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax *= Mem0[edx + 4:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066E0C: define caml_nativeint_sub
define caml_nativeint_sub
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 0x0C:word32];
	eax -= Mem0[edx + 4:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066E28: define caml_nativeint_add
define caml_nativeint_add
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax += Mem0[edx + 4:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066E44: define caml_nativeint_neg
define caml_nativeint_neg
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	C = eax != 0x00;
	eax = -eax;
	SZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066E5C: define caml_int64_to_nativeint
define caml_int64_to_nativeint
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_nativeint();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066E72: define caml_copy_int64
// Called from:
//      unix_lseek_64
//      stat_aux
//      caml_int64_bits_of_float
//      caml_int64_of_string
//      caml_int64_of_nativeint
//      caml_int64_of_int32
//      caml_int64_of_float
//      caml_int64_of_int
//      caml_int64_shift_right_unsigned
//      caml_int64_shift_right
//      caml_int64_shift_left
//      caml_int64_xor
//      caml_int64_or
//      caml_int64_and
//      caml_int64_mod
//      caml_int64_div
//      caml_int64_mul
//      caml_int64_sub
//      caml_int64_add
//      caml_int64_neg
//      caml_ml_pos_in_64
//      caml_ml_pos_out_64
//      caml_ml_channel_size_64
define caml_copy_int64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x0C:word32] = 0x01;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x08;
	Mem0[esp + 0x00:word32] = 0x0807D018;
	caml_alloc_custom();
	Mem0[eax + 4:word32] = ebx;
	Mem0[eax + 8:word32] = esi;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066EB8: define caml_int64_bits_of_float
define caml_int64_bits_of_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 4:word32];
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08066ED4: define caml_int64_of_string
define caml_int64_of_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x6C;
	SCZO = cond(esp);
	ecx = ebp - 28;
	edx = ebp - 32;
	eax = Mem0[ebp + 8:word32];
	parse_sign_and_base();
	edi = eax;
	eax = Mem0[ebp + -32:word32];
	Mem0[ebp + -56:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	SCZ = cond(edx);
	Mem0[ebp + -48:word32] = eax;
	Mem0[ebp + -44:word32] = edx;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 0x0C:word32] = edx;
	Mem0[esp + 0x00:word32] = ~0x00;
	Mem0[esp + 4:word32] = ~0x00;
	__udivdi3();
	Mem0[ebp + -60:word32] = eax;
	Mem0[ebp + -52:word32] = edx;
	eax = CONVERT(Mem0[edi + 0x00:byte], byte, int32);
	parse_digit();
	ebx = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SCZO = cond(Mem0[ebp + -56:word32] - eax);
		if (Test(GT,SZO))
		{
l08066F3F:
			esi = eax;
			esi >>= 0x1F;
			++edi;
			SCZO = cond(edi);
l08066F47:
			eax = CONVERT(Mem0[edi + 0x00:byte], byte, word32);
			SCZO = cond(al - 0x5F);
			if (Test(EQ,Z))
			{
l08066FC6:
				++edi;
				SCZO = cond(edi);
				goto l08066F47;
			}
			eax = CONVERT(al, byte, int32);
			parse_digit();
			Mem0[ebp + -76:word32] = eax;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NS,S))
			{
				SCZO = cond(Mem0[ebp + -56:word32] - eax);
				if (Test(GT,SZO))
				{
					SCZO = cond(esi - Mem0[ebp + -52:word32]);
					if (Test(UGE,C))
					{
						if (Test(UGT,CZ))
						{
l08066F72:
							Mem0[esp + 0x00:word32] = 134683455;
							caml_failwith();
							goto l08066F7E;
						}
						SCZO = cond(ebx - Mem0[ebp + -60:word32]);
						esi = esi;
						if (Test(UGT,CZ))
							goto l08066F72;
					}
l08066F7E:
					edx = Mem0[ebp + -48:word32];
					edx *= esi;
					ecx = Mem0[ebp + -44:word32];
					ecx *= ebx;
					edx += ecx;
					Mem0[ebp + -80:word32] = edx;
					eax = Mem0[ebp + -48:word32];
					edx_eax = ebx *u64 eax;
					ebx = eax;
					esi = edx;
					esi += Mem0[ebp + -80:word32];
					eax = Mem0[ebp + -76:word32];
					edx = eax;
					edx >>= 0x1F;
					Mem0[ebp + -96:word32] = eax;
					Mem0[ebp + -92:word32] = edx;
					ebx += eax;
					SCZO = cond(ebx);
					esi = esi + edx + C;
					SCZO = cond(edx - esi);
					if (Test(ULT,C))
						goto l08066FC6;
					SCZO = cond(Mem0[ebp + -92:word32] - esi);
					if (Test(UGT,CZ))
					{
l08066FBA:
						Mem0[esp + 0x00:word32] = 134683455;
						caml_failwith();
						goto l08066FC6;
					}
					SCZO = cond(eax - ebx);
					if (Test(UGT,CZ))
						goto l08066FBA;
					goto l08066FC6;
				}
			}
			Mem0[ebp + -48:word32] = ebx;
			Mem0[ebp + -44:word32] = esi;
			edx = Mem0[ebp + 8:word32];
			Mem0[esp + 0x00:word32] = edx;
			caml_string_length();
			eax += Mem0[ebp + 8:word32];
			SCZO = cond(edi - eax);
			if (Test(NE,Z))
			{
				Mem0[esp + 0x00:word32] = 134683455;
				caml_failwith();
			}
			SCZO = cond(Mem0[ebp + -32:word32] - 0x0A);
			if (Test(EQ,Z))
			{
				eax = ~0x00;
				edx = 0x7FFFFFFF;
				SCZO = cond(Mem0[ebp + -28:word32] - 0x00);
				if (Test(SG,S))
				{
					eax = 0x00;
					edx = 0x80000000;
				}
				SCZO = cond(edx - Mem0[ebp + -44:word32]);
				if (Test(ULE,CZ))
				{
					if (Test(ULT,C))
					{
l0806701E:
						Mem0[esp + 0x00:word32] = 134683455;
						caml_failwith();
						goto l0806702A;
					}
					SCZO = cond(eax - Mem0[ebp + -48:word32]);
					if (Test(ULT,C))
						goto l0806701E;
				}
			}
l0806702A:
			SCZO = cond(Mem0[ebp + -28:word32] - 0x00);
			if (Test(SG,S))
			{
				ebx = Mem0[ebp + -48:word32];
				esi = Mem0[ebp + -44:word32];
				C = ebx != 0x00;
				ebx = -ebx;
				esi = esi + 0x00 + C;
				C = esi != 0x00;
				esi = -esi;
				SZO = cond(esi);
			}
			Mem0[esp + 0x00:word32] = ebx;
			Mem0[esp + 4:word32] = esi;
			caml_copy_int64();
			esp += 0x6C;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 0x00:word32] = 134683455;
	caml_failwith();
	goto l08066F3F;
}

// 08067051: define caml_int64_of_nativeint
define caml_int64_of_nativeint
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	SCZ = cond(edx);
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067070: define caml_int64_of_int32
define caml_int64_of_int32
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	SCZ = cond(edx);
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806708F: define caml_int64_of_float
define caml_int64_of_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -0x0A:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -0x0A:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -0x0C:word16] = ax;
	__fldcw(Mem0[ebp + -0x0C:word16]);
	Mem0[esp + 0x00:int64] = CONVERT(ST[Top + 0x00:real64], real64, int64);
	++Top;
	__fldcw(Mem0[ebp + -0x0A:word16]);
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080670B7: define caml_int64_of_int
define caml_int64_of_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	SCZ = cond(edx);
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080670D5: define caml_int64_shift_right_unsigned
define caml_int64_shift_right_unsigned
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax = __shrd<word32>(eax, edx, cl);
	edx >>= cl;
	SZP = cond(cl & 0x20);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax = edx;
		edx = edx ^ edx;
		SZ = cond(edx);
		O = false;
		C = false;
	}
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067105: define caml_int64_shift_right
define caml_int64_shift_right
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax = __shrd<word32>(eax, edx, cl);
	edx >>= cl;
	SZP = cond(cl & 0x20);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax = edx;
		edx >>= 0x1F;
		SCZ = cond(edx);
	}
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067136: define caml_int64_shift_left
define caml_int64_shift_left
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	edx = __shld<word32>(edx, eax, cl);
	eax <<= cl;
	SZP = cond(cl & 0x20);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edx = eax;
		eax = eax ^ eax;
		SZ = cond(eax);
		O = false;
		C = false;
	}
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067166: define caml_int64_xor
define caml_int64_xor
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[edx + 4:word32];
	ecx = ecx ^ Mem0[eax + 4:word32];
	edx = Mem0[edx + 8:word32];
	edx = edx ^ Mem0[eax + 8:word32];
	SZ = cond(edx);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = ecx;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806718C: define caml_int64_or
define caml_int64_or
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[edx + 4:word32];
	ecx |= Mem0[eax + 4:word32];
	edx = Mem0[edx + 8:word32];
	edx |= Mem0[eax + 8:word32];
	SZ = cond(edx);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = ecx;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080671B2: define caml_int64_and
define caml_int64_and
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[edx + 4:word32];
	ecx &= Mem0[eax + 4:word32];
	edx = Mem0[edx + 8:word32];
	edx &= Mem0[eax + 8:word32];
	SZ = cond(edx);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = ecx;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080671D8: define caml_int64_mod
define caml_int64_mod
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	ebx = Mem0[edx + 4:word32];
	ecx = Mem0[edx + 8:word32];
	edx = Mem0[eax + 4:word32];
	eax = Mem0[eax + 8:word32];
	esi = eax;
	esi |= edx;
	SZ = cond(esi);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_zero_divide();
	esi = ecx + 0x80000000;
	esi |= ebx;
	SZ = cond(esi);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		esi = edx;
		esi &= eax;
		SCZO = cond(esi - ~0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = 0x00;
			Mem0[esp + 4:word32] = 0x00;
			caml_copy_int64();
l08067246:
			esp += 0x10;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x0C:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = ecx;
	__moddi3();
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	goto l08067246;
}

// 0806724D: define caml_int64_div
define caml_int64_div
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	esi = Mem0[eax + 4:word32];
	ebx = Mem0[eax + 8:word32];
	ecx = Mem0[edx + 4:word32];
	edx = Mem0[edx + 8:word32];
	edi = edx;
	edi |= ecx;
	SZ = cond(edi);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_zero_divide();
	edi = ebx + 0x80000000;
	edi |= esi;
	SZ = cond(edi);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		edi = ecx;
		edi &= edx;
		SCZO = cond(edi - ~0x00);
		if (Test(EQ,Z))
		{
l080672AC:
			ebx = Mem0[ebp + -0x0C:word32];
			esi = Mem0[ebp + -8:word32];
			edi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 8:word32] = ecx;
	Mem0[esp + 0x0C:word32] = edx;
	Mem0[esp + 0x00:word32] = esi;
	Mem0[esp + 4:word32] = ebx;
	__divdi3();
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	goto l080672AC;
}

// 080672B9: define caml_int64_mul
define caml_int64_mul
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[edx + 8:word32];
	ecx *= Mem0[eax + 4:word32];
	ebx = Mem0[eax + 8:word32];
	ebx *= Mem0[edx + 4:word32];
	ecx += ebx;
	eax = Mem0[eax + 4:word32];
	edx_eax = Mem0[edx + 4:word32] *u64 eax;
	SCZO = cond(edx_eax);
	edx = ecx + edx;
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080672F1: define caml_int64_sub
define caml_int64_sub
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	ecx = Mem0[eax + 4:word32];
	ebx = Mem0[eax + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	esi = ecx;
	edi = ebx;
	esi -= Mem0[edx + 4:word32];
	SCZO = cond(esi);
	edi = edi - Mem0[edx + 8:word32] - C;
	SCZO = cond(edi);
	Mem0[esp + 0x00:word32] = esi;
	Mem0[esp + 4:word32] = edi;
	caml_copy_int64();
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806732F: define caml_int64_add
define caml_int64_add
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[eax + 4:word32];
	ebx = Mem0[eax + 8:word32];
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[edx + 4:word32];
	edx = Mem0[edx + 8:word32];
	eax += ecx;
	SCZO = cond(eax);
	edx = edx + ebx + C;
	SCZO = cond(edx);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806735E: define caml_int64_neg
define caml_int64_neg
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	C = eax != 0x00;
	eax = -eax;
	edx = edx + 0x00 + C;
	C = edx != 0x00;
	edx = -edx;
	SZO = cond(edx);
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067382: define caml_copy_int32
// Called from:
//      caml_nativeint_to_int32
//      caml_int64_to_int32
//      caml_int32_bits_of_float
//      caml_int32_of_string
//      caml_int32_of_float
//      caml_int32_of_int
//      caml_int32_shift_right_unsigned
//      caml_int32_shift_right
//      caml_int32_shift_left
//      caml_int32_xor
//      caml_int32_or
//      caml_int32_and
//      caml_int32_mod
//      caml_int32_div
//      caml_int32_mul
//      caml_int32_sub
//      caml_int32_add
//      caml_int32_neg
define caml_copy_int32
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 0x0C:word32] = 0x01;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x04;
	Mem0[esp + 0x00:word32] = 0x0807CFFC;
	caml_alloc_custom();
	edx = Mem0[ebp + 8:word32];
	Mem0[eax + 4:word32] = edx;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080673B4: define caml_nativeint_to_int32
define caml_nativeint_to_int32
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080673CA: define caml_int64_to_int32
define caml_int64_to_int32
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080673E0: define caml_int32_bits_of_float
define caml_int32_bits_of_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -16:real32] = CONVERT(ST[Top + 0x00:real64], real64, real32);
	++Top;
	eax = Mem0[ebp + -16:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080673FB: define caml_int32_of_string
define caml_int32_of_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	edx = 0x20;
	eax = Mem0[ebp + 8:word32];
	parse_intnat();
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067418: define caml_int32_of_float
define caml_int32_of_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -0x0A:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -0x0A:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -0x0C:word16] = ax;
	__fldcw(Mem0[ebp + -0x0C:word16]);
	Mem0[esp + 0x00:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -0x0A:word16]);
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067440: define caml_int32_of_int
define caml_int32_of_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067455: define caml_int32_shift_right_unsigned
define caml_int32_shift_right_unsigned
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax >>= cl;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067472: define caml_int32_shift_right
define caml_int32_shift_right
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	O = false;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax >>= cl;
	SCZ = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806748F: define caml_int32_shift_left
define caml_int32_shift_left
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 0x0C:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	eax <<= cl;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080674AC: define caml_int32_xor
define caml_int32_xor
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax = eax ^ Mem0[edx + 4:word32];
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080674C8: define caml_int32_or
define caml_int32_or
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax |= Mem0[edx + 4:word32];
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080674E4: define caml_int32_and
define caml_int32_and
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax &= Mem0[edx + 4:word32];
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067500: define caml_int32_mod
define caml_int32_mod
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 4:word32];
	eax = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[eax + 4:word32];
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_zero_divide();
	SCZO = cond(edx - 0x80000000);
	if (Test(EQ,Z))
	{
		SCZO = cond(ecx - ~0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = 0x00;
			caml_copy_int32();
l08067545:
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	eax = edx;
	edx >>= 0x1F;
	v15 = edx_eax;
	edx = CONVERT(v15 %s ecx, word64, int32);
	eax = CONVERT(v15 /32 ecx, word32, int32);
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = edx;
	caml_copy_int32();
	goto l08067545;
}

// 08067547: define caml_int32_div
define caml_int32_div
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 4:word32];
	ecx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[ecx + 4:word32];
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_zero_divide();
	SCZO = cond(edx - 0x80000000);
	if (Test(EQ,Z))
	{
		SCZO = cond(ecx - ~0x00);
		if (Test(EQ,Z))
		{
l0806757E:
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	eax = edx;
	edx >>= 0x1F;
	v15 = edx_eax;
	edx = CONVERT(v15 %s ecx, word64, int32);
	eax = CONVERT(v15 /32 ecx, word32, int32);
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	goto l0806757E;
}

// 08067580: define caml_int32_mul
define caml_int32_mul
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax *= Mem0[edx + 4:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806759D: define caml_int32_sub
define caml_int32_sub
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 0x0C:word32];
	eax -= Mem0[edx + 4:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080675B9: define caml_int32_add
define caml_int32_add
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax = Mem0[eax + 4:word32];
	edx = Mem0[ebp + 8:word32];
	eax += Mem0[edx + 4:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080675D5: define caml_int32_neg
define caml_int32_neg
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	C = eax != 0x00;
	eax = -eax;
	SZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_int32();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080675F0: define caml_int_of_float
define caml_int_of_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[ebp + -2:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -2:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -4:word16] = ax;
	__fldcw(Mem0[ebp + -4:word16]);
	Mem0[ebp + -8:int32] = CONVERT(ST[Top + 0x00:real64], real64, int32);
	++Top;
	__fldcw(Mem0[ebp + -2:word16]);
	eax = Mem0[ebp + -8:word32];
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806761A: define caml_eq_float
define caml_eq_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	al = CONVERT(Test(EQ,Z), bool, int8);
	dl = CONVERT(Test(PO,P), bool, int8);
	eax &= edx;
	SZ = cond(eax);
	O = false;
	C = false;
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806763C: define caml_neq_float
define caml_neq_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	al = CONVERT(Test(NE,Z), bool, int8);
	dl = CONVERT(Test(PE,P), bool, int8);
	eax |= edx;
	SZ = cond(eax);
	O = false;
	C = false;
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806765E: define caml_le_float
define caml_le_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = eax - eax - C;
	eax &= ~0x01;
	eax += 0x03;
	SCZO = cond(eax);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067679: define caml_lt_float
define caml_lt_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	al = CONVERT(Test(UGT,CZ), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067696: define caml_ge_float
define caml_ge_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	v7 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v7;
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = eax - eax - C;
	eax &= ~0x01;
	eax += 0x03;
	SCZO = cond(eax);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080676B3: define caml_gt_float
define caml_gt_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	v7 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v7;
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	al = CONVERT(Test(UGT,CZ), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080676D2: define caml_float_compare
define caml_float_compare
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	v7 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v7;
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	if (Test(PO,P))
	{
		if (Test(EQ,Z))
		{
			ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			goto l08067716;
		}
		v13 = ST[Top + 0x00:real64];
		ST[Top + 0x00:real64] = ST[Top + 1:real64];
		ST[Top + 1:real64] = v13;
	}
	else
	{
		v14 = ST[Top + 0x00:real64];
		ST[Top + 0x00:real64] = ST[Top + 1:real64];
		ST[Top + 1:real64] = v14;
	}
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	if (Test(UGT,CZ))
	{
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
		goto l08067721;
	}
	v16 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v16;
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	if (Test(ULE,CZ))
	{
		CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
		O = false;
		S = false;
		++Top;
		if (Test(PE,P))
		{
l08067702:
			CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
			O = false;
			S = false;
			++Top;
			if (Test(PE,P))
			{
l08067716:
				eax = 0x01;
				goto l08067735;
			}
			if (Test(NE,Z))
			{
				esi += 0x00;
				goto l08067716;
			}
l08067721:
			eax = ~0x00;
			goto l08067735;
		}
		esi = esi;
		if (Test(NE,Z))
			goto l08067702;
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	else
	{
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	eax = 0x03;
l08067735:
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067737: define caml_init_ieee_floats
// Called from:
//      caml_main
define caml_init_ieee_floats
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806773C: define caml_classify_float
define caml_classify_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	__fpclassify();
	edx = eax;
	eax = 0x01;
	SCZO = cond(edx - 0x03);
	if (Test(ULE,CZ))
		eax = 0x08071B84[edx * 0x04];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067764: define caml_log1p
// Called from:
//      caml_log1p_float
define caml_log1p
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + 8:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	log1p();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067777: define caml_expm1
// Called from:
//      caml_expm1_float
define caml_expm1
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + 8:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	expm1();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806778A: define caml_format_float
define caml_format_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x019C;
	edi = Mem0[ebp + 8:word32];
	ebx = edi;
	eax = CONVERT(Mem0[edi + 0x00:byte], byte, word32);
	SZP = cond(al & al);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax -= 0x30;
		SCZO = cond(al - 0x09);
		while (Test(UGT,CZ))
		{
			++ebx;
			eax = CONVERT(Mem0[ebx + 0x00:byte], byte, word32);
			SZP = cond(al & al);
			O = false;
			C = false;
			if (Test(EQ,Z))
				goto l08067883;
			eax -= 0x30;
			SCZO = cond(al - 0x09);
		}
		Mem0[esp + 8:word32] = 0x0A;
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = ebx;
		eax = strtol(Mem0[esp + 0x00:(ptr32 char)]);
		esi = eax + 0x015E;
		SCZO = cond(esi - 0x015E);
		eax = 0x015E;
		if (Test(LT,SO))
			esi = eax;
		eax = CONVERT(Mem0[ebx + 0x00:byte], byte, word32);
		SZP = cond(al & al);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			SCZO = cond(al - 0x2E);
			while (Test(NE,Z))
			{
				++ebx;
				eax = CONVERT(Mem0[ebx + 0x00:byte], byte, word32);
				SZP = cond(al & al);
				O = false;
				C = false;
				if (Test(EQ,Z))
					goto l08067833;
				SCZO = cond(al - 0x2E);
			}
			Mem0[esp + 8:word32] = 0x0A;
			Mem0[esp + 4:word32] = 0x00;
			++ebx;
			Mem0[esp + 0x00:word32] = ebx;
			eax = strtol(Mem0[esp + 0x00:(ptr32 char)]);
			eax += 0x015E;
			SCZO = cond(esi - eax);
			if (Test(LT,SO))
				esi = eax;
		}
l08067833:
		SCZO = cond(esi - 0x0171);
		if (Test(UGT,CZ))
		{
			Mem0[esp + 0x00:word32] = esi;
			caml_stat_alloc();
			esi = eax;
			eax = Mem0[ebp + 0x0C:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
			Mem0[esp + 8:real64] = ST[Top + 0x00:real64];
			++Top;
			Mem0[esp + 4:word32] = edi;
			Mem0[esp + 0x00:word32] = esi;
			sprintf();
			Mem0[esp + 0x00:word32] = esi;
			caml_copy_string();
			ebx = eax;
			eax = ebp - 0x018A;
			SCZO = cond(esi - eax);
			if (Test(NE,Z))
			{
				Mem0[esp + 0x00:word32] = esi;
				caml_stat_free();
			}
l08067876:
			eax = ebx;
			esp += 0x019C;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
l08067883:
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 8:real64] = ST[Top + 0x00:real64];
	++Top;
	Mem0[esp + 4:word32] = edi;
	ebx = ebp - 0x018A;
	Mem0[esp + 0x00:word32] = ebx;
	sprintf();
	Mem0[esp + 0x00:word32] = ebx;
	caml_copy_string();
	ebx = eax;
	goto l08067876;
}

// 080678AA: define caml_copy_double
// Called from:
//      unix_gettimeofday
//      unix_mktime
//      stat_aux
//      unix_time
//      caml_nativeint_to_float
//      caml_int64_float_of_bits
//      caml_int64_to_float
//      caml_int32_float_of_bits
//      caml_int32_to_float
//      caml_log1p_float
//      caml_expm1_float
//      caml_ceil_float
//      caml_atan2_float
//      caml_atan_float
//      caml_acos_float
//      caml_asin_float
//      caml_tanh_float
//      caml_tan_float
//      caml_cosh_float
//      caml_cos_float
//      caml_sinh_float
//      caml_sin_float
//      caml_power_float
//      caml_sqrt_float
//      caml_modf_float
//      caml_log10_float
//      caml_log_float
//      caml_ldexp_float
//      caml_frexp_float
//      caml_fmod_float
//      caml_floor_float
//      caml_exp_float
//      caml_div_float
//      caml_mul_float
//      caml_sub_float
//      caml_add_float
//      caml_abs_float
//      caml_neg_float
//      caml_float_of_int
//      caml_float_of_string
//      caml_float_of_substring
//      caml_sys_time
//      caml_gc_counters
//      caml_gc_quick_stat
//      caml_gc_stat
define caml_copy_double
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + 8:real64];
	Mem0[ebp + -16:real64] = ST[Top + 0x00:real64];
	++Top;
	edx = Mem0[0x08080414<p32>:word32];
	eax = edx - 0x0C;
	Mem0[0x08080414<p32>:word32] = eax;
	SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
	if (Test(ULT,C))
	{
		Mem0[0x08080414<p32>:word32] = edx;
		caml_minor_collection();
		v10 = Mem0[0x08080414<p32>:word32] - 0x0C;
		Mem0[0x08080414<p32>:word32] = v10;
		SCZO = cond(v10);
	}
	eax = Mem0[0x08080414<p32>:word32];
	Mem0[eax + 0x00:word32] = 0x0BFD;
	eax = Mem0[0x08080414<p32>:word32];
	eax += 0x04;
	SCZO = cond(eax);
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -16:real64];
	Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080678F8: define caml_log1p_float
define caml_log1p_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_log1p();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067915: define caml_expm1_float
define caml_expm1_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_expm1();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067932: define caml_ceil_float
define caml_ceil_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	ceil();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806794F: define caml_atan2_float
define caml_atan2_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 8:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	atan2();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067975: define caml_atan_float
define caml_atan_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	atan();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067992: define caml_acos_float
define caml_acos_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	acos();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080679AF: define caml_asin_float
define caml_asin_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	asin();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080679CC: define caml_tanh_float
define caml_tanh_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	tanh();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080679E9: define caml_tan_float
define caml_tan_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	tan();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067A06: define caml_cosh_float
define caml_cosh_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	cosh();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067A23: define caml_cos_float
define caml_cos_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	cos();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067A40: define caml_sinh_float
define caml_sinh_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	sinh();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067A5D: define caml_sin_float
define caml_sin_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	sin();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067A7A: define caml_power_float
define caml_power_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 8:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	pow();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067AA0: define caml_sqrt_float
define caml_sqrt_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	v8 = ST[Top + 0x00:real64];
	--Top;
	ST[Top + 0x00:real64] = v8;
	ST[Top + 0x00:real64] = sqrt(ST[Top + 0x00:real64]);
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
	O = false;
	S = false;
	if (Test(PO,P))
	{
		if (Test(EQ,Z))
		{
			ST[Top + 1:real64] = ST[Top + 0x00:real64];
			++Top;
			goto l08067AC7;
		}
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	else
	{
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	ST[Top + -1:real64] = sqrt(Mem0[esp + 0x00:real64]);
	--Top;
l08067AC7:
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067AD1: define caml_modf_float
define caml_modf_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 116;
	SCZO = cond(esp);
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -48:word32] = ebx;
	Mem0[ebp + -40:word32] = 0x01;
	Mem0[ebp + -44:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -36:word32] = eax;
	Mem0[ebp + -52:word32] = 0x00;
	Mem0[ebp + -56:word32] = 0x00;
	Mem0[ebp + -60:word32] = 0x00;
	eax = ebp - 48;
	Mem0[ebp + -92:word32] = eax;
	eax = ebp - 92;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -84:word32] = 0x01;
	Mem0[ebp + -88:word32] = 0x03;
	eax = ebp - 52;
	Mem0[ebp + -80:word32] = eax;
	eax = ebp - 56;
	Mem0[ebp + -76:word32] = eax;
	eax = ebp - 60;
	Mem0[ebp + -72:word32] = eax;
	eax = ebp - 16;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	modf();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[ebp + -56:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -16:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[ebp + -60:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_tuple();
	Mem0[ebp + -52:word32] = eax;
	edx = Mem0[ebp + -56:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -60:word32];
	eax = Mem0[ebp + -52:word32];
	Mem0[eax + 4:word32] = edx;
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -52:word32];
	esp += 116;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067B91: define caml_log10_float
define caml_log10_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	log10();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067BAE: define caml_log_float
define caml_log_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	log();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067BCB: define caml_ldexp_float
define caml_ldexp_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	ldexp();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067BF1: define caml_frexp_float
define caml_frexp_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 100;
	SCZO = cond(esp);
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = ebx;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	Mem0[ebp + -44:word32] = 0x00;
	Mem0[ebp + -48:word32] = 0x00;
	eax = ebp - 40;
	Mem0[ebp + -80:word32] = eax;
	eax = ebp - 80;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -72:word32] = 0x01;
	Mem0[ebp + -76:word32] = 0x02;
	eax = ebp - 44;
	Mem0[ebp + -0x0044:word32] = eax;
	eax = ebp - 48;
	Mem0[ebp + -64:word32] = eax;
	eax = ebp - 84;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	frexp();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[ebp + -48:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_tuple();
	Mem0[ebp + -44:word32] = eax;
	edx = Mem0[ebp + -48:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = Mem0[ebp + -84:word32];
	edx = eax + 1 + eax;
	eax = Mem0[ebp + -44:word32];
	Mem0[eax + 4:word32] = edx;
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -44:word32];
	esp += 100;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067C9A: define caml_fmod_float
define caml_fmod_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	v8 = ST[Top + 0x00:real64];
	--Top;
	ST[Top + 0x00:real64] = v8;
	v9 = ST[Top + 2:real64];
	--Top;
	ST[Top + 0x00:real64] = v9;
	do
	{
		ST[Top + 0x00:real64] = __fprem_x87(ST[Top + 0x00:real64], ST[Top + 1:real64]);
		C2 = __fprem_incomplete(ST[Top + 0x00:real64]);
		ax = __fstsw(FPUF);
		SCZO = ah;
	} while (Test(PE,P));
	ST[Top + 1:real64] = ST[Top + 0x00:real64];
	++Top;
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 0x00:real64]);
	O = false;
	S = false;
	if (Test(PO,P))
	{
		if (Test(EQ,Z))
		{
			ST[Top + 1:real64] = ST[Top + 0x00:real64];
			++Top;
			ST[Top + 1:real64] = ST[Top + 0x00:real64];
			++Top;
			goto l08067CD6;
		}
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	else
	{
		ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
		++Top;
	}
	Mem0[esp + 8:real64] = ST[Top + 0x00:real64];
	++Top;
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	fmod();
l08067CD6:
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067CE0: define caml_floor_float
define caml_floor_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	floor();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067CFD: define caml_exp_float
define caml_exp_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	exp();
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067D1A: define caml_div_float
define caml_div_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	ST[Top + 0x00:real64] /= Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067D34: define caml_mul_float
define caml_mul_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	ST[Top + 0x00:real64] *= Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067D4E: define caml_sub_float
define caml_sub_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	ST[Top + 0x00:real64] -= Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067D68: define caml_add_float
define caml_add_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 0x0C:word32];
	ST[Top + 0x00:real64] += Mem0[eax + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067D82: define caml_abs_float
define caml_abs_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	ST[Top + 0x00:real64] = fabs(ST[Top + 0x00:real64]);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067D99: define caml_neg_float
define caml_neg_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	ST[Top + 0x00:real64] = -ST[Top + 0x00:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067DB0: define caml_float_of_int
define caml_float_of_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[ebp + -0x0C:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -0x0C:int32], int32, real64);
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067DCB: define caml_float_of_string
define caml_float_of_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	SCZO = cond(esp);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = esi;
	caml_string_length();
	ebx = eax;
	edi = ebp - 88;
	SCZO = cond(eax - 0x3F);
	if (Test(UGT,CZ))
	{
		++eax;
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_alloc();
		edi = eax;
	}
	eax = esi;
	esi = edi;
	while (true)
	{
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
		if (Test(EQ,Z))
			break;
		edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
		SCZO = cond(dl - 0x5F);
		if (Test(NE,Z))
		{
			Mem0[esi + 0x00:byte] = dl;
			++esi;
			SCZO = cond(esi);
		}
		++eax;
		--ebx;
		SCZO = cond(ebx);
	}
	Mem0[esi + 0x00:byte] = 0x00;
	SCZO = cond(esi - edi);
	if (Test(NE,Z))
	{
		eax = ebp - 92;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edi;
		strtod();
		Mem0[ebp + -112:real64] = ST[Top + 0x00:real64];
		++Top;
		SCZO = cond(Mem0[ebp + -92:word32] - esi);
		if (Test(EQ,Z))
		{
			eax = ebp - 88;
			SCZO = cond(edi - eax);
			if (Test(NE,Z))
			{
				Mem0[esp + 0x00:word32] = edi;
				caml_stat_free();
			}
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebp + -112:real64];
			Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			caml_copy_double();
			esp += 0x7C;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	eax = ebp - 88;
	SCZO = cond(edi - eax);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = edi;
		caml_stat_free();
	}
	Mem0[esp + 0x00:word32] = 0x08071B72;
	caml_failwith();
	caml_float_of_substring();
}

// 08067E6E: define caml_float_of_substring
// Called from:
//      caml_float_of_string
define caml_float_of_substring
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	esi = Mem0[ebp + 0x0C:word32];
	esi >>= 0x01;
	SCZ = cond(esi);
	O = false;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SCZO = cond(eax - esi);
		if (Test(UGT,CZ))
		{
			ebx = Mem0[ebp + 16:word32];
			ebx >>= 0x01;
			SZP = cond(ebx & ebx);
			O = false;
			C = false;
			if (Test(GT,SZO))
			{
				eax -= esi;
				SCZO = cond(ebx - eax);
				if (Test(ULE,CZ))
				{
					SCZO = cond(ebx - 0x3F);
					if (Test(ULE,CZ))
						edi = ebp - 88;
					else
					{
						eax = ebx + 1;
						Mem0[esp + 0x00:word32] = eax;
						caml_stat_alloc();
						edi = eax;
					}
l08067EBF:
					eax = Mem0[ebp + 8:word32];
					eax = esi + eax;
					esi = edi;
					while (true)
					{
						SZP = cond(ebx & ebx);
						O = false;
						C = false;
						if (Test(EQ,Z))
							break;
						edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
						SCZO = cond(dl - 0x5F);
						if (Test(NE,Z))
						{
							Mem0[esi + 0x00:byte] = dl;
							++esi;
							SCZO = cond(esi);
						}
						++eax;
						--ebx;
						SCZO = cond(ebx);
					}
					Mem0[esi + 0x00:byte] = 0x00;
					SCZO = cond(esi - edi);
					if (Test(NE,Z))
					{
						eax = ebp - 92;
						Mem0[esp + 4:word32] = eax;
						Mem0[esp + 0x00:word32] = edi;
						strtod();
						Mem0[ebp + -112:real64] = ST[Top + 0x00:real64];
						++Top;
						SCZO = cond(Mem0[ebp + -92:word32] - esi);
						if (Test(EQ,Z))
						{
							eax = ebp - 88;
							SCZO = cond(edi - eax);
							if (Test(NE,Z))
							{
								Mem0[esp + 0x00:word32] = edi;
								caml_stat_free();
							}
							--Top;
							ST[Top + 0x00:real64] = Mem0[ebp + -112:real64];
							Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
							++Top;
							caml_copy_double();
							esp += 0x7C;
							SCZO = cond(esp);
							ebx = Mem0[esp + 0x00:word32];
							esp += 4;
							esi = Mem0[esp + 0x00:word32];
							esp += 4;
							edi = Mem0[esp + 0x00:word32];
							esp += 4;
							ebp = Mem0[esp + 0x00:word32];
							esp += 4;
							return;
						}
					}
					eax = ebp - 88;
					SCZO = cond(edi - eax);
					if (Test(NE,Z))
					{
						Mem0[esp + 0x00:word32] = edi;
						caml_stat_free();
					}
					Mem0[esp + 0x00:word32] = 0x08071B72;
					caml_failwith();
					caml_string_length();
					return;
				}
			}
		}
	}
	ebx = 0x00;
	edi = ebp - 88;
	goto l08067EBF;
}

// 08067F40: define caml_string_length
// Called from:
//      unix_getaddrinfo
//      unix_gethostbyname
//      unix_open
//      unix_putenv
//      get_sockaddr
//      unix_string_of_inet_addr
//      compare_val
//      parse_intnat
//      parse_format
//      caml_int64_of_string
//      caml_float_of_string
//      caml_float_of_substring
//      caml_string_compare
//      caml_string_set
//      caml_string_get
//      extern_rec
//      hash_aux
//      caml_sys_error
//      caml_sys_system_command
//      caml_sys_open
define caml_string_length
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[edx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	edx = CONVERT(Mem0[eax + edx:byte], byte, int32);
	eax -= edx;
	SCZO = cond(eax);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067F5B: define caml_ml_string_length
define caml_ml_string_length
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	edx = Mem0[ebp + 8:word32];
	eax = Mem0[edx + -4:word32];
	eax >>= 0x0A;
	eax = ~0x00 + eax * 0x04;
	edx = CONVERT(Mem0[eax + edx:byte], byte, int32);
	eax -= edx;
	SCZO = cond(eax);
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067F7A: define caml_string_equal
// Called from:
//      camlUnix__get_port_1739
//      camlUnix__getaddrinfo_1751
//      caml_string_notequal
define caml_string_equal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	ecx = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	SCZO = cond(ecx - edx);
	if (Test(NE,Z))
	{
		eax = Mem0[ecx + -4:word32];
		eax >>= 0x0A;
		ebx = Mem0[edx + -4:word32];
		ebx >>= 0x0A;
		SCZO = cond(eax - ebx);
		if (Test(NE,Z))
		{
l08067FBC:
			eax = 0x01;
l08067FC1:
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			ebx = Mem0[ecx + 0x00:word32];
			SCZO = cond(ebx - Mem0[edx + 0x00:word32]);
			while (Test(EQ,Z))
			{
				--eax;
				SCZO = cond(eax);
				if (Test(EQ,Z))
					goto l08067FB5;
				ecx += 0x04;
				edx += 0x04;
				ebx = Mem0[ecx + 0x00:word32];
				SCZO = cond(ebx - Mem0[edx + 0x00:word32]);
			}
			goto l08067FBC;
		}
	}
l08067FB5:
	eax = 0x03;
	goto l08067FC1;
}

// 08067FC4: define caml_string_notequal
// Called from:
//      camlPervasives__bool_of_string_1129
define caml_string_notequal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_equal();
	edx = 0x04;
	edx -= eax;
	SCZO = cond(edx);
	eax = edx;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08067FE7: define caml_bitvect_test
define caml_bitvect_test
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 0x0C:word32];
	ecx = eax;
	ecx >>= 0x01;
	eax >>= 0x04;
	edx = Mem0[ebp + 8:word32];
	eax = CONVERT(Mem0[eax + edx:byte], byte, word32);
	ecx &= 0x07;
	edx = 0x01;
	edx <<= cl;
	eax &= edx;
	SZ = cond(eax);
	O = false;
	C = false;
	eax = eax + 1 + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806800D: define caml_is_printable
define caml_is_printable
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(Mem0[0x08081860<p32>:word32] - 0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x08072228;
		Mem0[esp + 0x00:word32] = 0x00;
		eax = setlocale(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 char)]);
		Mem0[0x08081860<p32>:word32] = 0x01;
	}
	eax = __ctype_b_loc();
	edx = Mem0[ebp + 8:word32];
	edx >>= 0x01;
	eax = Mem0[eax + 0x00:word32];
	eax = CONVERT(eax[edx * 0x02], word16, word32);
	eax &= 0x4000;
	SCZO = cond(eax - 0x01);
	eax = eax - eax - C;
	eax &= ~0x01;
	eax += 0x03;
	SCZO = cond(eax);
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806805C: define caml_fill_string
// Called from:
//      camlString__make_1038
//      camlString__fill_1051
define caml_fill_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	ecx = Mem0[ebp + 16:word32];
	ecx >>= 0x01;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 20:word32];
	edx >>= 0x01;
	SCZ = cond(edx);
	O = false;
	Mem0[esp + 8:word32] = ecx;
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = eax;
	eax = memset(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:int32], Mem0[esp + 8:size_t]);
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806808B: define caml_blit_string
// Called from:
//      camlPervasives__$5e_1112
//      camlPervasives__read_line_1288
//      camlPervasives__string_of_format_1315
//      camlString__fun_1163
//      camlString__copy_1042
//      camlString__sub_1046
//      camlString__blit_1056
//      camlString__concat_1066
define caml_blit_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 24:word32];
	eax >>= 0x01;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 20:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 16:word32];
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080680BD: define caml_string_compare
// Called from:
//      camlString__compare_1145
//      caml_string_greaterequal
//      caml_string_greaterthan
//      caml_string_lessequal
//      caml_string_lessthan
define caml_string_compare
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x14;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 8:word32];
	edi = Mem0[ebp + 0x0C:word32];
	SCZO = cond(ebx - edi);
	if (Test(EQ,Z))
	{
l08068116:
		eax = 0x01;
		goto l08068129;
	}
	Mem0[esp + 0x00:word32] = ebx;
	caml_string_length();
	Mem0[ebp + -16:word32] = eax;
	Mem0[esp + 0x00:word32] = edi;
	caml_string_length();
	edx = eax;
	SCZO = cond(eax - Mem0[ebp + -16:word32]);
	eax = Mem0[ebp + -16:word32];
	if (Test(ULE,CZ))
		eax = edx;
	esi = ebx;
	ecx = eax;
	cmpResult = memcmp(esi, edi, ecx *u 0x01);
	firstDifference = __find_first_difference__(esi, edi);
	ecx -= firstDifference;
	esi += firstDifference;
	edi += firstDifference;
	SCZO = cond(cmpResult);
	al = CONVERT(Test(UGT,CZ), bool, int8);
	cl = CONVERT(Test(ULT,C), bool, int8);
	al -= cl;
	eax = CONVERT(al, byte, int32);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
l08068124:
			eax = 0x03;
l08068129:
			ebx = Mem0[ebp + -0x0C:word32];
			esi = Mem0[ebp + -8:word32];
			edi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
		SCZO = cond(Mem0[ebp + -16:word32] - edx);
		if (Test(UGE,C))
		{
			if (Test(ULE,CZ))
				goto l08068116;
			goto l08068124;
		}
	}
	eax = ~0x00;
	goto l08068129;
}

// 08068136: define caml_string_greaterequal
define caml_string_greaterequal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_compare();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	al = CONVERT(Test(GT,SZO), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806815C: define caml_string_greaterthan
define caml_string_greaterthan
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_compare();
	SCZO = cond(eax - 0x01);
	al = CONVERT(Test(GT,SZO), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068183: define caml_string_lessequal
define caml_string_lessequal
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_compare();
	SCZO = cond(eax - 0x02);
	al = CONVERT(Test(LT,SO), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080681AA: define caml_string_lessthan
define caml_string_lessthan
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_compare();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	al = CONVERT(Test(LE,SZO), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080681D0: define caml_string_set
define caml_string_set
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	esi = Mem0[ebp + 8:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	ebx >>= 0x01;
	SCZ = cond(ebx);
	O = false;
	if (Test(NS,S))
	{
		Mem0[esp + 0x00:word32] = esi;
		caml_string_length();
		SCZO = cond(ebx - eax);
		if (Test(ULT,C))
		{
l080681F7:
			eax = Mem0[ebp + 16:word32];
			eax >>= 0x01;
			SCZ = cond(eax);
			O = false;
			Mem0[ebx + esi:byte] = al;
			eax = 0x01;
			ebx = Mem0[ebp + -8:word32];
			esi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	caml_array_bound_error();
	goto l080681F7;
}

// 0806820E: define caml_string_get
define caml_string_get
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	esi = Mem0[ebp + 8:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	ebx >>= 0x01;
	SCZ = cond(ebx);
	O = false;
	if (Test(NS,S))
	{
		Mem0[esp + 0x00:word32] = esi;
		caml_string_length();
		SCZO = cond(ebx - eax);
		if (Test(ULT,C))
		{
l08068235:
			eax = CONVERT(Mem0[ebx + esi:byte], byte, word32);
			eax = eax + 1 + eax;
			ebx = Mem0[ebp + -8:word32];
			esi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	caml_array_bound_error();
	goto l08068235;
}

// 08068247: define caml_create_string
define caml_create_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZO = cond(eax - 0x00FFFFFB);
	if (Test(UGT,CZ))
	{
		Mem0[esp + 0x00:word32] = 0x08071B94;
		caml_invalid_argument();
	}
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_string();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068270: define caml_array_unsafe_set_float
// Called from:
//      caml_array_unsafe_set
define caml_array_unsafe_set_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	edx = Mem0[ebp + 0x0C:word32];
	edx >>= 0x01;
	SCZ = cond(edx);
	O = false;
	eax = Mem0[ebp + 16:word32];
	--Top;
	ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
	eax = Mem0[ebp + 8:word32];
	eax[edx * 0x08] = ST[Top + 0x00:real64];
	++Top;
	eax = 0x01;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806828A: define caml_make_array
define caml_make_array
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = ebx;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	Mem0[ebp + -60:word32] = 0x00;
	Mem0[ebp + -64:word32] = 0x00;
	eax = ebp - 56;
	Mem0[ebp + -96:word32] = eax;
	eax = ebp - 96;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -88:word32] = 0x01;
	Mem0[ebp + -92:word32] = 0x02;
	eax = ebp - 60;
	Mem0[ebp + -84:word32] = eax;
	eax = ebp - 64;
	Mem0[ebp + -80:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	esi = Mem0[eax + -4:word32];
	esi >>= 0x0A;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[0x0807D294<p32>:word32] = ebx;
		goto l0806836F;
	}
	edx = Mem0[eax + 0x00:word32];
	SZP = cond(dl & 0x01);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[ebp + -60:word32] = edx;
		edi = edx;
		edi >>= 0x17;
		ecx = edx;
		ecx >>= 0x0C;
		ecx &= 0x07FF;
		edi = 0x08084000[edi * 0x04];
		SZP = cond(Mem0[edi + ecx:byte] & 0x07);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			SCZO = cond(Mem0[edx + -4:byte] - ~0x02);
			if (Test(EQ,Z))
			{
				Mem0[esp + 4:word32] = 0xFE;
				eax = esi + esi;
				Mem0[esp + 0x00:word32] = eax;
				caml_alloc_small();
				Mem0[ebp + -64:word32] = eax;
				eax = 0x00;
				do
				{
					edx = Mem0[ebp + 8:word32];
					edx = edx[eax * 0x04];
					--Top;
					ST[Top + 0x00:real64] = Mem0[edx + 0x00:real64];
					edx = Mem0[ebp + -64:word32];
					edx[eax * 0x08] = ST[Top + 0x00:real64];
					++Top;
					++eax;
					SCZO = cond(esi - eax);
				} while (Test(UGT,CZ));
				Mem0[0x0807D294<p32>:word32] = ebx;
				eax = Mem0[ebp + -64:word32];
l0806836F:
				ebx = Mem0[ebp + -0x0C:word32];
				esi = Mem0[ebp + -8:word32];
				edi = Mem0[ebp + -4:word32];
				esp = ebp;
				ebp = Mem0[esp + 0x00:word32];
				esp += 4;
				return;
			}
		}
	}
	Mem0[0x0807D294<p32>:word32] = ebx;
	goto l0806836F;
}

// 0806837C: define caml_array_unsafe_get_float
// Called from:
//      caml_array_unsafe_get
define caml_array_unsafe_get_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	edx = Mem0[ebp + 0x0C:word32];
	edx >>= 0x01;
	eax = Mem0[ebp + 8:word32];
	--Top;
	ST[Top + 0x00:real64] = eax[edx * 0x08];
	Mem0[ebp + -16:real64] = ST[Top + 0x00:real64];
	++Top;
	edx = Mem0[0x08080414<p32>:word32];
	eax = edx - 0x0C;
	Mem0[0x08080414<p32>:word32] = eax;
	SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
	if (Test(ULT,C))
	{
		Mem0[0x08080414<p32>:word32] = edx;
		caml_minor_collection();
		v12 = Mem0[0x08080414<p32>:word32] - 0x0C;
		Mem0[0x08080414<p32>:word32] = v12;
		SCZO = cond(v12);
	}
	eax = Mem0[0x08080414<p32>:word32];
	Mem0[eax + 0x00:word32] = 0x0BFD;
	eax = Mem0[0x08080414<p32>:word32];
	eax += 0x04;
	SCZO = cond(eax);
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -16:real64];
	Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080683D2: define caml_array_unsafe_get
define caml_array_unsafe_get
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	SCZO = cond(Mem0[eax + -4:byte] - ~0x01);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		caml_array_unsafe_get_float();
	}
	else
	{
		edx >>= 0x01;
		SCZ = cond(edx);
		O = false;
		eax = eax[edx * 0x04];
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080683F9: define caml_make_vect
define caml_make_vect
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	edi = Mem0[0x0807D294<p32>:word32];
	eax = ebp - 56;
	Mem0[ebp + -60:word32] = 0x00;
	Mem0[ebp + -92:word32] = eax;
	eax = ebp - 92;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -84:word32] = 0x01;
	Mem0[ebp + -88:word32] = 0x01;
	eax = ebp - 60;
	Mem0[ebp + -80:word32] = eax;
	esi = Mem0[ebp + 8:word32];
	esi >>= 0x01;
	SCZ = cond(esi);
	O = false;
	if (Test(EQ,Z))
	{
		Mem0[ebp + -60:word32] = 0x08083AA4;
		goto l080685C0;
	}
	Mem0[ebp + -56:word32] = edi;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	edx = eax;
	edx &= 0x01;
	SZ = cond(edx);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[ebp + -112:word32] = eax;
		ebx = eax;
		ebx >>= 0x17;
		ecx = eax;
		ecx >>= 0x0C;
		ecx &= 0x07FF;
		ebx = 0x08084000[ebx * 0x04];
		SZP = cond(Mem0[ebx + ecx:byte] & 0x07);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			SCZO = cond(Mem0[eax + -4:byte] - ~0x02);
			if (Test(EQ,Z))
			{
				--Top;
				ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
				Mem0[ebp + -112:real64] = ST[Top + 0x00:real64];
				++Top;
				eax = esi + esi;
				SCZO = cond(eax - 0x003FFFFF);
				if (Test(UGT,CZ))
				{
					Mem0[esp + 0x00:word32] = 134683554;
					caml_invalid_argument();
				}
				Mem0[esp + 4:word32] = 0xFE;
				Mem0[esp + 0x00:word32] = eax;
				caml_alloc();
				Mem0[ebp + -60:word32] = eax;
				eax = 0x00;
				do
				{
					edx = Mem0[ebp + -60:word32];
					--Top;
					ST[Top + 0x00:real64] = Mem0[ebp + -112:real64];
					edx[eax * 0x08] = ST[Top + 0x00:real64];
					++Top;
					++eax;
					SCZO = cond(esi - eax);
				} while (Test(UGT,CZ));
				goto l080685C0;
			}
		}
	}
	SCZO = cond(esi - 0x003FFFFF);
	if (Test(UGT,CZ))
	{
		Mem0[esp + 0x00:word32] = 134683554;
		caml_invalid_argument();
	}
	SCZO = cond(esi - 0xFF);
	if (Test(ULE,CZ))
	{
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = esi;
		caml_alloc_small();
		Mem0[ebp + -60:word32] = eax;
		esi <<= 0x02;
		SCZO = cond(esi);
		eax = 0x00;
		do
		{
			ecx = Mem0[ebp + 0x0C:word32];
			edx = Mem0[ebp + -60:word32];
			Mem0[eax + edx:word32] = ecx;
			eax += 0x04;
			SCZO = cond(eax - esi);
		} while (Test(NE,Z));
		goto l080685C0;
	}
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		SCZO = cond(eax - Mem0[0x08080410<p32>:word32]);
		if (Test(ULT,C))
		{
			SCZO = cond(eax - Mem0[0x0808040C<p32>:word32]);
			if (Test(UGT,CZ))
			{
				caml_minor_collection();
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = esi;
				caml_alloc_shr();
				Mem0[ebp + -60:word32] = eax;
				esi <<= 0x02;
				SCZO = cond(esi);
				eax = 0x00;
				do
				{
					ecx = Mem0[ebp + 0x0C:word32];
					edx = Mem0[ebp + -60:word32];
					Mem0[edx + eax:word32] = ecx;
					eax += 0x04;
					SCZO = cond(eax - esi);
				} while (Test(NE,Z));
				eax = Mem0[ebp + -60:word32];
				Mem0[esp + 0x00:word32] = eax;
				caml_check_urgent_gc();
				Mem0[ebp + -60:word32] = eax;
				goto l080685C0;
			}
		}
	}
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = esi;
	caml_alloc_shr();
	Mem0[ebp + -60:word32] = eax;
	ebx = 0x00;
	do
	{
		eax = Mem0[ebp + 0x0C:word32];
		Mem0[esp + 4:word32] = eax;
		eax = 0x00 + ebx * 0x04;
		eax += Mem0[ebp + -60:word32];
		SCZO = cond(eax);
		Mem0[esp + 0x00:word32] = eax;
		caml_initialize();
		++ebx;
		SCZO = cond(esi - ebx);
	} while (Test(UGT,CZ));
	eax = Mem0[ebp + -60:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_check_urgent_gc();
	Mem0[ebp + -60:word32] = eax;
l080685C0:
	Mem0[0x0807D294<p32>:word32] = edi;
	eax = Mem0[ebp + -60:word32];
	esp += 0x7C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080685D1: define caml_array_unsafe_set_addr
// Called from:
//      caml_array_unsafe_set
define caml_array_unsafe_set_addr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = Mem0[ebp + 16:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	ebx >>= 0x01;
	ebx <<= 0x02;
	ebx += Mem0[ebp + 8:word32];
	edi = Mem0[ebx + 0x00:word32];
	Mem0[ebx + 0x00:word32] = esi;
	edx = ebx;
	edx >>= 0x17;
	eax = ebx;
	eax >>= 0x0C;
	eax &= 0x07FF;
	edx = 0x08084000[edx * 0x04];
	SZP = cond(Mem0[edx + eax:byte] & 0x01);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(Mem0[0x08083FDC<p32>:word32] - 0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 4:word32] = 0x00;
			Mem0[esp + 0x00:word32] = edi;
			caml_darken();
		}
		SZP = cond(esi & 0x01);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			eax = Mem0[0x08080410<p32>:word32];
			SCZO = cond(esi - eax);
			if (Test(UGE,C))
				goto l08068679;
			edx = Mem0[0x0808040C<p32>:word32];
			SCZO = cond(esi - edx);
			if (Test(UGT,CZ))
			{
				SZP = cond(edi & 0x01);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
					SCZO = cond(eax - edi);
					if (Test(UGT,CZ))
					{
						SCZO = cond(edx - edi);
						if (Test(ULT,C))
							goto l08068679;
					}
				}
				eax = Mem0[0x08080428<p32>:word32];
				SCZO = cond(eax - Mem0[0x0808042C<p32>:word32]);
				if (Test(UGE,C))
				{
					Mem0[esp + 0x00:word32] = 0x0808041C;
					caml_realloc_ref_table();
				}
				eax = 0x08080428;
				edx = Mem0[eax + 0x00:word32];
				Mem0[edx + 0x00:word32] = ebx;
				edx += 0x04;
				SCZO = cond(edx);
				Mem0[eax + 0x00:word32] = edx;
			}
		}
	}
l08068679:
	eax = 0x01;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806868B: define caml_array_unsafe_set
define caml_array_unsafe_set
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[ebp + 16:word32];
	SCZO = cond(Mem0[eax + -4:byte] - ~0x01);
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		caml_array_unsafe_set_float();
	}
	else
	{
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		caml_array_unsafe_set_addr();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080686C4: define caml_array_set_float
// Called from:
//      caml_array_set
define caml_array_set_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	if (Test(NS,S))
	{
		edx = Mem0[ebp + 8:word32];
		ecx = Mem0[edx + -4:word32];
		ecx >>= 11;
		SCZO = cond(eax - ecx);
		if (Test(ULT,C))
		{
l080686E3:
			ecx = Mem0[ebp + 16:word32];
			--Top;
			ST[Top + 0x00:real64] = Mem0[ecx + 0x00:real64];
			edx[eax * 0x08] = ST[Top + 0x00:real64];
			++Top;
			eax = 0x01;
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	caml_array_bound_error();
	goto l080686E3;
}

// 080686F2: define caml_array_set_addr
// Called from:
//      caml_array_set
define caml_array_set_addr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	eax = Mem0[ebp + 0x0C:word32];
	esi = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	if (Test(NS,S))
	{
		edx = Mem0[ebp + 8:word32];
		ecx = Mem0[edx + -4:word32];
		ecx >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(ULT,C))
		{
l0806871D:
			ebx = edx + eax * 0x04;
			edi = Mem0[ebx + 0x00:word32];
			Mem0[ebx + 0x00:word32] = esi;
			edx = ebx;
			edx >>= 0x17;
			eax = ebx;
			eax >>= 0x0C;
			eax &= 0x07FF;
			edx = 0x08084000[edx * 0x04];
			SZP = cond(Mem0[edx + eax:byte] & 0x01);
			O = false;
			C = false;
			if (Test(NE,Z))
			{
				SCZO = cond(Mem0[0x08083FDC<p32>:word32] - 0x00);
				if (Test(EQ,Z))
				{
					Mem0[esp + 4:word32] = 0x00;
					Mem0[esp + 0x00:word32] = edi;
					caml_darken();
				}
				SZP = cond(esi & 0x01);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
					eax = Mem0[0x08080410<p32>:word32];
					SCZO = cond(esi - eax);
					if (Test(UGE,C))
						goto l080687AB;
					edx = Mem0[0x0808040C<p32>:word32];
					SCZO = cond(esi - edx);
					if (Test(UGT,CZ))
					{
						SZP = cond(edi & 0x01);
						O = false;
						C = false;
						if (Test(EQ,Z))
						{
							SCZO = cond(eax - edi);
							if (Test(UGT,CZ))
							{
								SCZO = cond(edx - edi);
								if (Test(ULT,C))
									goto l080687AB;
							}
						}
						eax = Mem0[0x08080428<p32>:word32];
						SCZO = cond(eax - Mem0[0x0808042C<p32>:word32]);
						if (Test(UGE,C))
						{
							Mem0[esp + 0x00:word32] = 0x0808041C;
							caml_realloc_ref_table();
						}
						eax = 0x08080428;
						edx = Mem0[eax + 0x00:word32];
						Mem0[edx + 0x00:word32] = ebx;
						edx += 0x04;
						SCZO = cond(edx);
						Mem0[eax + 0x00:word32] = edx;
					}
				}
			}
l080687AB:
			eax = 0x01;
			ebx = Mem0[ebp + -0x0C:word32];
			esi = Mem0[ebp + -8:word32];
			edi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	caml_array_bound_error();
	goto l0806871D;
}

// 080687BD: define caml_array_set
define caml_array_set
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[ebp + 16:word32];
	SCZO = cond(Mem0[eax + -4:byte] - ~0x01);
	if (Test(EQ,Z))
	{
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		caml_array_set_float();
	}
	else
	{
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		caml_array_set_addr();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080687F6: define caml_array_get_float
// Called from:
//      caml_array_get
define caml_array_get_float
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	if (Test(NS,S))
	{
		edx = Mem0[ebp + 8:word32];
		ecx = Mem0[edx + -4:word32];
		ecx >>= 11;
		SCZO = cond(eax - ecx);
		if (Test(ULT,C))
		{
l08068815:
			--Top;
			ST[Top + 0x00:real64] = edx[eax * 0x08];
			Mem0[ebp + -16:real64] = ST[Top + 0x00:real64];
			++Top;
			edx = Mem0[0x08080414<p32>:word32];
			eax = edx - 0x0C;
			Mem0[0x08080414<p32>:word32] = eax;
			SCZO = cond(eax - Mem0[0x08080418<p32>:word32]);
			if (Test(ULT,C))
			{
				Mem0[0x08080414<p32>:word32] = edx;
				caml_minor_collection();
				v14 = Mem0[0x08080414<p32>:word32] - 0x0C;
				Mem0[0x08080414<p32>:word32] = v14;
				SCZO = cond(v14);
			}
			eax = Mem0[0x08080414<p32>:word32];
			Mem0[eax + 0x00:word32] = 0x0BFD;
			eax = Mem0[0x08080414<p32>:word32];
			eax += 0x04;
			SCZO = cond(eax);
			--Top;
			ST[Top + 0x00:real64] = Mem0[ebp + -16:real64];
			Mem0[eax + 0x00:real64] = ST[Top + 0x00:real64];
			++Top;
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	caml_array_bound_error();
	goto l08068815;
}

// 0806885D: define caml_array_get_addr
// Called from:
//      caml_array_get
define caml_array_get_addr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	if (Test(NS,S))
	{
		edx = Mem0[ebp + 8:word32];
		ecx = Mem0[edx + -4:word32];
		ecx >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(ULT,C))
		{
l0806887C:
			eax = edx[eax * 0x04];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	caml_array_bound_error();
	goto l0806887C;
}

// 08068881: define caml_array_get
define caml_array_get
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	SCZO = cond(Mem0[eax + -4:byte] - ~0x01);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		caml_array_get_float();
	}
	else
	{
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		caml_array_get_addr();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080688B0: define unlink_channel
// Called from:
//      caml_finalize_channel
//      caml_close_channel
define unlink_channel
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	edx = Mem0[eax + 32:word32];
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		eax = Mem0[0x08081874<p32>:word32];
		eax = Mem0[eax + 28:word32];
		Mem0[0x08081874<p32>:word32] = eax;
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
			Mem0[eax + 32:word32] = 0x00;
	}
	else
	{
		ecx = Mem0[eax + 28:word32];
		Mem0[edx + 28:word32] = ecx;
		edx = Mem0[eax + 28:word32];
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			eax = Mem0[eax + 32:word32];
			Mem0[edx + 32:word32] = eax;
		}
	}
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080688E9: define caml_channel_binary_mode
// Called from:
//      caml_getword
//      caml_putword
//      caml_output_val
//      caml_input_val
define caml_channel_binary_mode
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	eax = 0x01;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080688F3: define caml_pos_out
// Called from:
//      caml_ml_pos_out_64
//      caml_ml_pos_out
define caml_pos_out
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	edx = Mem0[ebp + 8:word32];
	ebx = edx + 52;
	ecx = Mem0[edx + 16:word32];
	ecx -= ebx;
	ebx = ecx;
	ebx >>= 0x1F;
	eax = Mem0[edx + 4:word32];
	edx = Mem0[edx + 8:word32];
	eax += ecx;
	SCZO = cond(eax);
	edx = edx + ebx + C;
	SCZO = cond(edx);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068914: define caml_pos_in
// Called from:
//      caml_ml_pos_in_64
//      caml_ml_pos_in
define caml_pos_in
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x10;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[eax + 20:word32];
	edx -= Mem0[eax + 16:word32];
	ecx = edx;
	ecx >>= 0x1F;
	ebx = Mem0[eax + 4:word32];
	esi = Mem0[eax + 8:word32];
	ebx -= edx;
	SCZO = cond(ebx);
	esi = esi - ecx - C;
	SCZO = cond(esi);
	eax = ebx;
	edx = esi;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068946: define compare_channel
define compare_channel
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	ecx = Mem0[eax + 4:word32];
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 4:word32];
	eax = 0x00;
	SCZO = cond(ecx - edx);
	if (Test(NE,Z))
	{
		SCZO = cond(ecx - edx);
		eax = eax - eax - C;
		eax |= 0x01;
		SZ = cond(eax);
		O = false;
		C = false;
	}
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068967: define caml_ml_set_binary_mode
define caml_ml_set_binary_mode
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	eax = 0x01;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068971: define caml_ml_pos_in_64
define caml_ml_pos_in_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_pos_in();
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068993: define caml_ml_pos_out_64
define caml_ml_pos_out_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_pos_out();
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080689B5: define caml_ml_pos_in
define caml_ml_pos_in
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_pos_in();
	ebx = eax;
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
l080689DB:
			eax = __errno_location();
			Mem0[eax + 0x00:word32] = 0x4B;
			Mem0[esp + 0x00:word32] = 0x01;
			caml_sys_error();
			goto l080689F2;
		}
		SCZO = cond(eax - 0x3FFFFFFF);
		if (Test(UGT,CZ))
			goto l080689DB;
	}
l080689F2:
	eax = ebx + 1 + ebx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080689FC: define caml_ml_pos_out
define caml_ml_pos_out
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_pos_out();
	ebx = eax;
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
l08068A22:
			eax = __errno_location();
			Mem0[eax + 0x00:word32] = 0x4B;
			Mem0[esp + 0x00:word32] = 0x01;
			caml_sys_error();
			goto l08068A39;
		}
		SCZO = cond(eax - 0x3FFFFFFF);
		if (Test(UGT,CZ))
			goto l08068A22;
	}
l08068A39:
	eax = ebx + 1 + ebx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068A43: define caml_channel_descriptor
define caml_channel_descriptor
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ~0x00);
	if (Test(EQ,Z))
	{
		eax = __errno_location();
		Mem0[eax + 0x00:word32] = 0x09;
		Mem0[esp + 0x00:word32] = 0x01;
		caml_sys_error();
	}
	eax = ebx + 1 + ebx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068A78: define caml_ml_close_channel
define caml_ml_close_channel
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	ebx = Mem0[eax + 0x00:word32];
	SCZO = cond(ebx - ~0x00);
	if (Test(NE,Z))
	{
		Mem0[eax + 0x00:word32] = ~0x00;
		edx = Mem0[eax + 0x0C:word32];
		Mem0[eax + 20:word32] = edx;
		Mem0[eax + 16:word32] = edx;
		caml_enter_blocking_section();
		Mem0[esp + 0x00:word32] = ebx;
		eax = close(Mem0[esp + 0x00:int32]);
		ebx = eax;
		caml_leave_blocking_section();
		SCZO = cond(ebx - ~0x00);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = 0x01;
			caml_sys_error();
		}
	}
	else
	{
		edx = Mem0[eax + 0x0C:word32];
		Mem0[eax + 20:word32] = edx;
		Mem0[eax + 16:word32] = edx;
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068AD6: define caml_alloc_channel
// Called from:
//      caml_ml_out_channels_list
//      caml_ml_open_descriptor_in
//      caml_ml_open_descriptor_out
define caml_alloc_channel
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	v7 = Mem0[ebx + 44:word32] + 0x01;
	Mem0[ebx + 44:word32] = v7;
	SCZO = cond(v7);
	Mem0[esp + 0x0C:word32] = 1000;
	Mem0[esp + 8:word32] = 0x01;
	Mem0[esp + 4:word32] = 0x04;
	Mem0[esp + 0x00:word32] = 0x0807D050;
	caml_alloc_custom();
	Mem0[eax + 4:word32] = ebx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068B11: define caml_ml_out_channels_list
define caml_ml_out_channels_list
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x40;
	esi = Mem0[0x0807D294<p32>:word32];
	eax = ebp - 52;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -0x0C:word32] = 0x01;
	ebx = Mem0[0x08081874<p32>:word32];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[ebp + -16:word32] = 0x00;
		Mem0[ebp + -20:word32] = 0x00;
		Mem0[ebp + -52:word32] = esi;
		Mem0[ebp + -44:word32] = 0x01;
		Mem0[ebp + -48:word32] = 0x03;
		eax = ebp - 0x0C;
		Mem0[ebp + -40:word32] = eax;
		eax = ebp - 16;
		Mem0[ebp + -36:word32] = eax;
		eax = ebp - 20;
		Mem0[ebp + -32:word32] = eax;
		do
		{
			SCZO = cond(Mem0[ebx + 20:word32] - 0x00);
			if (Test(EQ,Z))
			{
				Mem0[esp + 0x00:word32] = ebx;
				caml_alloc_channel();
				Mem0[ebp + -20:word32] = eax;
				eax = Mem0[ebp + -0x0C:word32];
				Mem0[ebp + -16:word32] = eax;
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = 0x02;
				caml_alloc_small();
				Mem0[ebp + -0x0C:word32] = eax;
				edx = Mem0[ebp + -20:word32];
				Mem0[eax + 0x00:word32] = edx;
				edx = Mem0[ebp + -16:word32];
				eax = Mem0[ebp + -0x0C:word32];
				Mem0[eax + 4:word32] = edx;
			}
			ebx = Mem0[ebx + 28:word32];
			SZP = cond(ebx & ebx);
			O = false;
			C = false;
		} while (Test(NE,Z));
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = Mem0[ebp + -0x0C:word32];
	esp += 0x40;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068BBC: define caml_finalize_channel
define caml_finalize_channel
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[ebx + 44:word32];
	--eax;
	Mem0[ebx + 44:word32] = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(LE,SZO))
	{
		eax = Mem0[0x08081864<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
			eax();
		}
		eax = ebx;
		unlink_channel();
		Mem0[esp + 0x00:word32] = ebx;
		caml_stat_free();
	}
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068BF9: define caml_close_channel
define caml_close_channel
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[ebx + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = close(Mem0[esp + 0x00:int32]);
	SCZO = cond(Mem0[ebx + 44:word32] - 0x00);
	if (Test(LE,SZO))
	{
		eax = Mem0[0x08081864<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
			eax();
		}
		eax = ebx;
		unlink_channel();
		Mem0[esp + 0x00:word32] = ebx;
		caml_stat_free();
	}
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068C36: define caml_seek_in
// Called from:
//      caml_ml_seek_in_64
//      caml_ml_seek_in
define caml_seek_in
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 8:word32];
	edi = Mem0[ebp + 0x0C:word32];
	esi = Mem0[ebp + 16:word32];
	eax = Mem0[ebx + 4:word32];
	edx = Mem0[ebx + 8:word32];
	Mem0[ebp + -48:word32] = eax;
	Mem0[ebp + -44:word32] = edx;
	edx = Mem0[ebx + 20:word32];
	Mem0[ebp + -36:word32] = edx;
	eax = ebx + 52;
	edx -= eax;
	Mem0[ebp + -32:word32] = edx;
	ecx = edx;
	ecx >>= 0x1F;
	Mem0[ebp + -28:word32] = ecx;
	eax = Mem0[ebp + -48:word32];
	edx = Mem0[ebp + -44:word32];
	eax -= Mem0[ebp + -32:word32];
	SCZO = cond(eax);
	edx = edx - Mem0[ebp + -28:word32] - C;
	Mem0[ebp + -32:word32] = eax;
	Mem0[ebp + -28:word32] = edx;
	SCZO = cond(edx - esi);
	if (Test(LE,SZO))
	{
		SCZO = cond(Mem0[ebp + -28:word32] - esi);
		if (Test(LT,SO))
		{
l08068C8F:
			SCZO = cond(Mem0[ebp + -44:word32] - esi);
			if (Test(GE,SO))
			{
				if (Test(GT,SZO))
				{
l08068C9B:
					eax = edi;
					eax -= Mem0[ebp + -48:word32];
					eax += Mem0[ebp + -36:word32];
					SCZO = cond(eax);
					Mem0[ebx + 16:word32] = eax;
					goto l08068CF4;
				}
				SCZO = cond(Mem0[ebp + -48:word32] - edi);
				if (Test(UGE,C))
					goto l08068C9B;
			}
			goto l08068CA8;
		}
		SCZO = cond(eax - edi);
		if (Test(ULE,CZ))
			goto l08068C8F;
	}
l08068CA8:
	caml_enter_blocking_section();
	Mem0[esp + 0x0C:word32] = 0x00;
	Mem0[esp + 4:word32] = edi;
	Mem0[esp + 8:word32] = esi;
	eax = Mem0[ebx + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	lseek64();
	edx = edx ^ esi;
	eax = eax ^ edi;
	edx |= eax;
	SZ = cond(edx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		caml_leave_blocking_section();
		Mem0[esp + 0x00:word32] = 0x01;
		caml_sys_error();
	}
	caml_leave_blocking_section();
	Mem0[ebx + 4:word32] = edi;
	Mem0[ebx + 8:word32] = esi;
	eax = ebx + 52;
	Mem0[ebx + 20:word32] = eax;
	Mem0[ebx + 16:word32] = eax;
l08068CF4:
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068D01: define caml_ml_seek_in_64
define caml_ml_seek_in_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x00:word32] = ebx;
	caml_seek_in();
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068D81: define caml_ml_seek_in
define caml_ml_seek_in
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	O = false;
	Mem0[esp + 4:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	SCZ = cond(edx);
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x00:word32] = ebx;
	caml_seek_in();
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068E02: define caml_channel_size
// Called from:
//      caml_ml_channel_size_64
//      caml_ml_channel_size
define caml_channel_size
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 0x00:word32];
	edx = Mem0[eax + 4:word32];
	Mem0[ebp + -28:word32] = edx;
	eax = Mem0[eax + 8:word32];
	Mem0[ebp + -32:word32] = eax;
	caml_enter_blocking_section();
	Mem0[esp + 0x0C:word32] = 0x02;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 0x00:word32] = ebx;
	lseek64();
	esi = eax;
	edi = edx;
	eax &= edx;
	SCZO = cond(eax - ~0x00);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x0C:word32] = 0x00;
		eax = Mem0[ebp + -28:word32];
		Mem0[esp + 4:word32] = eax;
		edx = Mem0[ebp + -32:word32];
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 0x00:word32] = ebx;
		lseek64();
		edx = edx ^ Mem0[ebp + -32:word32];
		eax = eax ^ Mem0[ebp + -28:word32];
		edx |= eax;
		SZ = cond(edx);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
l08068E8B:
			caml_leave_blocking_section();
			eax = esi;
			edx = edi;
			ebx = Mem0[ebp + -0x0C:word32];
			esi = Mem0[ebp + -8:word32];
			edi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	caml_leave_blocking_section();
	Mem0[esp + 0x00:word32] = 0x01;
	caml_sys_error();
	goto l08068E8B;
}

// 08068EA1: define caml_ml_channel_size_64
define caml_ml_channel_size_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_channel_size();
	Mem0[esp + 0x00:word32] = eax;
	Mem0[esp + 4:word32] = edx;
	caml_copy_int64();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068EC3: define caml_ml_channel_size
define caml_ml_channel_size
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_channel_size();
	ebx = eax;
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
l08068EE9:
			eax = __errno_location();
			Mem0[eax + 0x00:word32] = 0x4B;
			Mem0[esp + 0x00:word32] = 0x01;
			caml_sys_error();
			goto l08068F00;
		}
		SCZO = cond(eax - 0x3FFFFFFF);
		if (Test(UGT,CZ))
			goto l08068EE9;
	}
l08068F00:
	eax = ebx + 1 + ebx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068F0A: define caml_do_read
// Called from:
//      caml_ml_input
//      caml_input_scan_line
//      caml_getblock
//      caml_refill
define caml_do_read
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	SCZO = cond(esp);
	esi = Mem0[ebp + 8:word32];
	edi = Mem0[ebp + 0x0C:word32];
	do
	{
		caml_enter_blocking_section();
		eax = Mem0[ebp + 16:word32];
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = edi;
		Mem0[esp + 0x00:word32] = esi;
		eax = read(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		ebx = eax;
		caml_leave_blocking_section();
		SCZO = cond(ebx - ~0x00);
		if (Test(NE,Z))
			goto l08068F53;
		eax = __errno_location();
		SCZO = cond(Mem0[eax + 0x00:word32] - 0x04);
	} while (Test(EQ,Z));
	Mem0[esp + 0x00:word32] = 0x01;
	caml_sys_io_error();
l08068F53:
	eax = ebx;
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08068F5D: define caml_ml_input
define caml_ml_input
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	edi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = edi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x04;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = ebp + 16;
	Mem0[ebp + -36:word32] = eax;
	eax = ebp + 20;
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	Mem0[ebp + -64:word32] = eax;
	esi = Mem0[ebp + 20:word32];
	esi >>= 0x01;
	Mem0[ebp + -60:word32] = esi;
	eax = Mem0[ebx + 16:word32];
	esi = Mem0[ebx + 20:word32];
	esi -= eax;
	SCZO = cond(Mem0[ebp + -60:word32] - esi);
	if (Test(LE,SZO))
	{
		edx = Mem0[ebp + -60:word32];
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebp + -64:word32];
		eax += Mem0[ebp + 0x0C:word32];
		Mem0[esp + 0x00:word32] = eax;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		eax = Mem0[ebp + -60:word32];
		v17 = Mem0[ebx + 16:word32] + eax;
		Mem0[ebx + 16:word32] = v17;
		SCZO = cond(v17);
		esi = eax;
	}
	else
	{
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
			Mem0[esp + 8:word32] = esi;
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + -64:word32];
			eax += Mem0[ebp + 0x0C:word32];
			Mem0[esp + 0x00:word32] = eax;
			eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
			v18 = Mem0[ebx + 16:word32] + esi;
			Mem0[ebx + 16:word32] = v18;
			SCZO = cond(v18);
		}
		else
		{
			edx = ebx + 52;
			Mem0[ebp + -0x0044:word32] = edx;
			eax = Mem0[ebx + 0x0C:word32];
			eax -= edx;
			SCZO = cond(eax);
			Mem0[esp + 8:word32] = eax;
			Mem0[esp + 4:word32] = edx;
			eax = Mem0[ebx + 0x00:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_do_read();
			esi = eax;
			edx = esi;
			edx >>= 0x1F;
			v19 = Mem0[ebx + 4:word32] + eax;
			Mem0[ebx + 4:word32] = v19;
			SCZO = cond(v19);
			v20 = Mem0[ebx + 8:word32] + edx + C;
			Mem0[ebx + 8:word32] = v20;
			eax = ebx + 52 + esi;
			Mem0[ebx + 20:word32] = eax;
			SCZO = cond(esi - Mem0[ebp + -60:word32]);
			if (Test(GT,SZO))
				esi = Mem0[ebp + -60:word32];
			Mem0[esp + 8:word32] = esi;
			eax = Mem0[ebp + -0x0044:word32];
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + -64:word32];
			eax += Mem0[ebp + 0x0C:word32];
			SCZO = cond(eax);
			Mem0[esp + 0x00:word32] = eax;
			eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
			eax = ebx + 52 + esi;
			Mem0[ebx + 16:word32] = eax;
		}
	}
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = edi;
	eax = esi + 1 + esi;
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069088: define caml_input_scan_line
// Called from:
//      caml_ml_input_scan_line
define caml_input_scan_line
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	SCZO = cond(esp);
	ebx = Mem0[ebp + 8:word32];
	esi = Mem0[ebx + 16:word32];
	edi = ebx + 52;
	Mem0[ebp + -32:word32] = edi;
	Mem0[ebp + -28:word32] = edi;
	do
	{
		eax = Mem0[ebx + 20:word32];
		SCZO = cond(esi - eax);
		if (Test(UGE,C))
		{
			edx = Mem0[ebx + 16:word32];
			SCZO = cond(edx - edi);
			if (Test(UGT,CZ))
			{
				eax -= edx;
				Mem0[esp + 8:word32] = eax;
				Mem0[esp + 4:word32] = edx;
				eax = Mem0[ebp + -32:word32];
				Mem0[esp + 0x00:word32] = eax;
				eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
				eax = Mem0[ebp + -28:word32];
				eax -= Mem0[ebx + 16:word32];
				edx = Mem0[ebp + -28:word32];
				Mem0[ebx + 16:word32] = edx;
				v13 = Mem0[ebx + 20:word32] + eax;
				Mem0[ebx + 20:word32] = v13;
				esi += eax;
				SCZO = cond(esi);
			}
			edx = Mem0[ebx + 20:word32];
			eax = Mem0[ebx + 0x0C:word32];
			SCZO = cond(edx - eax);
			if (Test(UGE,C))
			{
				eax = Mem0[ebx + 16:word32];
				eax -= edx;
				SCZO = cond(eax);
				goto l08069122;
			}
			eax -= edx;
			SCZO = cond(eax);
			Mem0[esp + 8:word32] = eax;
			Mem0[esp + 4:word32] = edx;
			eax = Mem0[ebx + 0x00:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_do_read();
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[ebx + 16:word32];
				eax -= Mem0[ebx + 20:word32];
				SCZO = cond(eax);
				goto l08069122;
			}
			ecx = eax;
			ecx >>= 0x1F;
			v20 = Mem0[ebx + 4:word32] + eax;
			Mem0[ebx + 4:word32] = v20;
			SCZO = cond(v20);
			v21 = Mem0[ebx + 8:word32] + ecx + C;
			Mem0[ebx + 8:word32] = v21;
			v22 = Mem0[ebx + 20:word32] + eax;
			Mem0[ebx + 20:word32] = v22;
			SCZO = cond(v22);
		}
		eax = CONVERT(Mem0[esi + 0x00:byte], byte, word32);
		++esi;
		SCZO = cond(al - 0x0A);
	} while (Test(NE,Z));
	eax = esi;
	eax -= Mem0[ebx + 16:word32];
	SCZO = cond(eax);
l08069122:
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806912A: define caml_ml_input_scan_line
define caml_ml_input_scan_line
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = esi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[esp + 0x00:word32] = ebx;
	caml_input_scan_line();
	edi = eax;
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = edi + 1 + edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080691A1: define caml_getblock
// Called from:
//      caml_really_getblock
//      caml_md5_chan
define caml_getblock
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 8:word32];
	edi = Mem0[ebp + 16:word32];
	eax = Mem0[ebx + 16:word32];
	esi = Mem0[ebx + 20:word32];
	esi -= eax;
	SCZO = cond(edi - esi);
	if (Test(LE,SZO))
	{
		Mem0[esp + 8:word32] = edi;
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebp + 0x0C:word32];
		Mem0[esp + 0x00:word32] = eax;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		v11 = Mem0[ebx + 16:word32] + edi;
		Mem0[ebx + 16:word32] = v11;
		SCZO = cond(v11);
		esi = edi;
	}
	else
	{
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(GT,SZO))
		{
			Mem0[esp + 8:word32] = esi;
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + 0x0C:word32];
			Mem0[esp + 0x00:word32] = eax;
			eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
			v15 = Mem0[ebx + 16:word32] + esi;
			Mem0[ebx + 16:word32] = v15;
			SCZO = cond(v15);
		}
		else
		{
			eax = ebx + 52;
			Mem0[ebp + -28:word32] = eax;
			eax = Mem0[ebx + 0x0C:word32];
			eax -= Mem0[ebp + -28:word32];
			SCZO = cond(eax);
			Mem0[esp + 8:word32] = eax;
			eax = Mem0[ebp + -28:word32];
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebx + 0x00:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_do_read();
			ecx = eax;
			ecx >>= 0x1F;
			v18 = Mem0[ebx + 4:word32] + eax;
			Mem0[ebx + 4:word32] = v18;
			SCZO = cond(v18);
			v19 = Mem0[ebx + 8:word32] + ecx + C;
			Mem0[ebx + 8:word32] = v19;
			edx = ebx + 52 + eax;
			Mem0[ebx + 20:word32] = edx;
			SCZO = cond(eax - edi);
			esi = edi;
			if (Test(LE,SZO))
				esi = eax;
			Mem0[esp + 8:word32] = esi;
			eax = Mem0[ebp + -28:word32];
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + 0x0C:word32];
			Mem0[esp + 0x00:word32] = eax;
			eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
			eax = ebx + 52 + esi;
			Mem0[ebx + 16:word32] = eax;
		}
	}
	eax = esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806925E: define caml_really_getblock
// Called from:
//      caml_input_val
define caml_really_getblock
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	edi = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	ebx = Mem0[ebp + 16:word32];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		while (true)
		{
			Mem0[esp + 8:word32] = ebx;
			Mem0[esp + 4:word32] = esi;
			Mem0[esp + 0x00:word32] = edi;
			caml_getblock();
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				break;
			ebx -= eax;
			SZP = cond(ebx & ebx);
			O = false;
			C = false;
			if (Test(LE,SZO))
				break;
			esi += eax;
			SCZO = cond(esi);
		}
	}
	SZP = cond(ebx & ebx);
	al = CONVERT(Test(EQ,Z), bool, int8);
	eax = CONVERT(al, byte, word32);
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080692A2: define caml_refill
// Called from:
//      caml_ml_input_char
//      caml_getword
define caml_refill
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	eax = ebx + 52;
	edx = Mem0[ebx + 0x0C:word32];
	edx -= eax;
	SCZO = cond(edx);
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebx + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_do_read();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_end_of_file();
	ecx = eax;
	ecx >>= 0x1F;
	v15 = Mem0[ebx + 4:word32] + eax;
	Mem0[ebx + 4:word32] = v15;
	SCZO = cond(v15);
	v16 = Mem0[ebx + 8:word32] + ecx + C;
	Mem0[ebx + 8:word32] = v16;
	eax = ebx + 52 + eax;
	Mem0[ebx + 20:word32] = eax;
	eax = ebx + 53;
	Mem0[ebx + 16:word32] = eax;
	eax = CONVERT(Mem0[ebx + 52:byte], byte, word32);
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080692F1: define caml_ml_input_char
define caml_ml_input_char
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = esi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebx + 16:word32];
	SCZO = cond(eax - Mem0[ebx + 20:word32]);
	if (Test(UGE,C))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_refill();
		edi = eax;
	}
	else
	{
		edi = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
		++eax;
		SCZO = cond(eax);
		Mem0[ebx + 16:word32] = eax;
	}
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	edi &= 0xFF;
	SZ = cond(edi);
	O = false;
	C = false;
	eax = edi + 1 + edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069381: define caml_getword
// Called from:
//      caml_ml_input_int
//      caml_input_val
define caml_getword
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = ebx;
	caml_channel_binary_mode();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071BB0;
		caml_failwith();
	}
	edi = 0x00;
	esi = 0x00;
	do
	{
		edx = Mem0[ebx + 16:word32];
		SCZO = cond(edx - Mem0[ebx + 20:word32]);
		if (Test(UGE,C))
		{
			Mem0[esp + 0x00:word32] = ebx;
			caml_refill();
			eax = CONVERT(al, byte, word32);
		}
		else
		{
			eax = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
			++edx;
			SCZO = cond(edx);
			Mem0[ebx + 16:word32] = edx;
		}
		edi <<= 0x08;
		edi = eax + edi;
		++esi;
		SCZO = cond(esi - 0x04);
	} while (Test(NE,Z));
	eax = edi;
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080693E5: define caml_ml_input_int
define caml_ml_input_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = esi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[esp + 0x00:word32] = ebx;
	caml_getword();
	edi = eax;
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = edi + 1 + edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806945C: define do_write
// Called from:
//      caml_putblock
//      caml_flush_partial
define do_write
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	SCZO = cond(esp);
	edi = eax;
	Mem0[ebp + -28:word32] = edx;
	esi = ecx;
	while (true)
	{
		caml_enter_blocking_section();
		Mem0[esp + 8:word32] = esi;
		eax = Mem0[ebp + -28:word32];
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edi;
		eax = write(Mem0[esp + 0x00:int32], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		ebx = eax;
		caml_leave_blocking_section();
		SCZO = cond(ebx - ~0x00);
		if (Test(NE,Z))
			break;
		eax = __errno_location();
		eax = Mem0[eax + 0x00:word32];
		SCZO = cond(eax - 0x04);
		if (Test(EQ,Z))
			continue;
		SCZO = cond(eax - 11);
		if (Test(NE,Z))
		{
l080694AD:
			Mem0[esp + 0x00:word32] = 0x01;
			caml_sys_io_error();
			break;
		}
		SCZO = cond(esi - 0x01);
		if (Test(LE,SZO))
			goto l080694AD;
		esi = 0x01;
	}
	eax = ebx;
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080694C3: define caml_putblock
// Called from:
//      caml_ml_output
//      caml_ml_output_partial
//      caml_really_putblock
define caml_putblock
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	edi = Mem0[ebp + 16:word32];
	eax = Mem0[ebx + 16:word32];
	esi = Mem0[ebx + 0x0C:word32];
	esi -= eax;
	SCZO = cond(edi - esi);
	if (Test(LT,SO))
	{
		Mem0[esp + 8:word32] = edi;
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		v12 = Mem0[ebx + 16:word32] + edi;
		Mem0[ebx + 16:word32] = v12;
		SCZO = cond(v12);
		eax = edi;
	}
	else
	{
		Mem0[esp + 8:word32] = esi;
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		eax = ebx + 52;
		Mem0[ebp + -28:word32] = eax;
		eax = Mem0[ebx + 0x0C:word32];
		eax -= Mem0[ebp + -28:word32];
		SCZO = cond(eax);
		Mem0[ebp + -32:word32] = eax;
		ecx = eax;
		edx = Mem0[ebp + -28:word32];
		eax = Mem0[ebx + 0x00:word32];
		do_write();
		edi = eax;
		SCZO = cond(Mem0[ebp + -32:word32] - eax);
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp + -32:word32];
			eax -= edi;
			Mem0[esp + 8:word32] = eax;
			eax = Mem0[ebp + -28:word32];
			eax += edi;
			SCZO = cond(eax);
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + -28:word32];
			Mem0[esp + 0x00:word32] = eax;
			eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		}
		edx = edi;
		edx >>= 0x1F;
		v16 = Mem0[ebx + 4:word32] + edi;
		Mem0[ebx + 4:word32] = v16;
		SCZO = cond(v16);
		v18 = Mem0[ebx + 8:word32] + edx + C;
		Mem0[ebx + 8:word32] = v18;
		edi = -edi;
		edi += Mem0[ebx + 0x0C:word32];
		SCZO = cond(edi);
		Mem0[ebx + 16:word32] = edi;
		eax = esi;
	}
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806956F: define caml_ml_output
define caml_ml_output
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	eax = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -60:word32] = eax;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x04;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = ebp + 16;
	Mem0[ebp + -36:word32] = eax;
	eax = ebp + 20;
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	edi = Mem0[eax + 4:word32];
	esi = Mem0[ebp + 16:word32];
	ebx = Mem0[ebp + 20:word32];
	ebx >>= 0x01;
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = edi;
		eax();
	}
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		esi >>= 0x01;
		SCZ = cond(esi);
		O = false;
		do
		{
			Mem0[esp + 8:word32] = ebx;
			eax = esi;
			eax += Mem0[ebp + 0x0C:word32];
			SCZO = cond(eax);
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = edi;
			caml_putblock();
			esi += eax;
			ebx -= eax;
			SZP = cond(ebx & ebx);
			O = false;
			C = false;
		} while (Test(GT,SZO));
	}
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = edi;
		eax();
	}
	eax = Mem0[ebp + -60:word32];
	Mem0[0x0807D294<p32>:word32] = eax;
	eax = 0x01;
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069613: define caml_ml_output_partial
define caml_ml_output_partial
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = esi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x04;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = ebp + 16;
	Mem0[ebp + -36:word32] = eax;
	eax = ebp + 20;
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 20:word32];
	eax >>= 0x01;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 0x0C:word32];
	SCZO = cond(eax);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_putblock();
	edi = eax;
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = edi + 1 + edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080696B1: define caml_really_putblock
// Called from:
//      caml_output_val
define caml_really_putblock
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	edi = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	ebx = Mem0[ebp + 16:word32];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	while (Test(GT,SZO))
	{
		Mem0[esp + 8:word32] = ebx;
		Mem0[esp + 4:word32] = esi;
		Mem0[esp + 0x00:word32] = edi;
		caml_putblock();
		esi += eax;
		ebx -= eax;
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
	}
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080696E7: define caml_flush_partial
// Called from:
//      caml_ml_output_char
//      caml_ml_flush_partial
//      caml_putword
//      caml_flush
define caml_flush_partial
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 8:word32];
	eax = ebx + 52;
	Mem0[ebp + -28:word32] = eax;
	esi = Mem0[ebx + 16:word32];
	esi -= eax;
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		edx = eax;
		ecx = esi;
		eax = Mem0[ebx + 0x00:word32];
		do_write();
		edi = eax;
		edx = edi;
		edx >>= 0x1F;
		v17 = Mem0[ebx + 4:word32] + eax;
		Mem0[ebx + 4:word32] = v17;
		SCZO = cond(v17);
		v18 = Mem0[ebx + 8:word32] + edx + C;
		Mem0[ebx + 8:word32] = v18;
		SCZO = cond(esi - edi);
		if (Test(GT,SZO))
		{
			esi -= edi;
			Mem0[esp + 8:word32] = esi;
			eax = Mem0[ebp + -28:word32];
			eax += edi;
			SCZO = cond(eax);
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + -28:word32];
			Mem0[esp + 0x00:word32] = eax;
			eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		}
		v21 = Mem0[ebx + 16:word32] - edi;
		Mem0[ebx + 16:word32] = v21;
		SCZO = cond(v21);
	}
	eax = ebx + 52;
	SCZO = cond(Mem0[ebx + 16:word32] - eax);
	al = CONVERT(Test(EQ,Z), bool, int8);
	eax = CONVERT(al, byte, word32);
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806975A: define caml_ml_output_char
define caml_ml_output_char
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebx + 16:word32];
	SCZO = cond(eax - Mem0[ebx + 0x0C:word32]);
	if (Test(UGE,C))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush_partial();
	}
	eax = Mem0[ebx + 16:word32];
	edx = Mem0[ebp + 0x0C:word32];
	edx >>= 0x01;
	Mem0[eax + 0x00:byte] = dl;
	++eax;
	Mem0[ebx + 16:word32] = eax;
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080697E1: define caml_ml_flush_partial
define caml_ml_flush_partial
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = esi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	SCZO = cond(Mem0[ebx + 0x00:word32] - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[0x0807D294<p32>:word32] = esi;
		eax = 0x03;
	}
	else
	{
		eax = Mem0[0x08081868<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
			eax();
		}
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush_partial();
		edi = eax;
		eax = Mem0[0x0808186C<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
			eax();
		}
		SCZO = cond(edi - 0x01);
		eax = eax - eax - C;
		eax &= ~0x01;
		SZ = cond(eax);
		O = false;
		C = false;
		Mem0[0x0807D294<p32>:word32] = esi;
		eax += 3;
	}
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069871: define caml_putword
// Called from:
//      caml_ml_output_int
define caml_putword
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	SCZO = cond(esp);
	ebx = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = ebx;
	caml_channel_binary_mode();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071BD8;
		caml_failwith();
	}
	eax = Mem0[ebx + 16:word32];
	SCZO = cond(eax - Mem0[ebx + 0x0C:word32]);
	if (Test(UGE,C))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush_partial();
	}
	eax = Mem0[ebx + 16:word32];
	edx = esi;
	edx >>= 0x18;
	Mem0[eax + 0x00:byte] = dl;
	++eax;
	Mem0[ebx + 16:word32] = eax;
	SCZO = cond(eax - Mem0[ebx + 0x0C:word32]);
	if (Test(UGE,C))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush_partial();
	}
	eax = Mem0[ebx + 16:word32];
	edx = esi;
	edx >>= 0x10;
	Mem0[eax + 0x00:byte] = dl;
	++eax;
	Mem0[ebx + 16:word32] = eax;
	SCZO = cond(eax - Mem0[ebx + 0x0C:word32]);
	if (Test(UGE,C))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush_partial();
	}
	eax = Mem0[ebx + 16:word32];
	edx = esi;
	edx >>= 0x08;
	Mem0[eax + 0x00:byte] = dl;
	++eax;
	Mem0[ebx + 16:word32] = eax;
	SCZO = cond(eax - Mem0[ebx + 0x0C:word32]);
	if (Test(UGE,C))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush_partial();
	}
	eax = Mem0[ebx + 16:word32];
	edx = esi;
	Mem0[eax + 0x00:byte] = dl;
	++eax;
	Mem0[ebx + 16:word32] = eax;
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069912: define caml_ml_output_int
define caml_ml_output_int
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_putword();
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806998A: define caml_flush
// Called from:
//      caml_ml_flush
//      caml_seek_out
define caml_flush
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	ebx = Mem0[ebp + 8:word32];
	do
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush_partial();
		SZP = cond(eax & eax);
		O = false;
		C = false;
	} while (Test(EQ,Z));
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080699A6: define caml_ml_flush
define caml_ml_flush
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	SCZO = cond(Mem0[ebx + 0x00:word32] - ~0x00);
	if (Test(EQ,Z))
		Mem0[0x0807D294<p32>:word32] = esi;
	else
	{
		eax = Mem0[0x08081868<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
			eax();
		}
		Mem0[esp + 0x00:word32] = ebx;
		caml_flush();
		eax = Mem0[0x0808186C<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = ebx;
			eax();
		}
		Mem0[0x0807D294<p32>:word32] = esi;
	}
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069A1C: define caml_seek_out
// Called from:
//      caml_ml_seek_out_64
//      caml_ml_seek_out
define caml_seek_out
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	edi = Mem0[ebp + 16:word32];
	Mem0[esp + 0x00:word32] = ebx;
	caml_flush();
	caml_enter_blocking_section();
	Mem0[esp + 0x0C:word32] = 0x00;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 8:word32] = edi;
	eax = Mem0[ebx + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	lseek64();
	edx = edx ^ edi;
	eax = eax ^ esi;
	edx |= eax;
	SZ = cond(edx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		caml_leave_blocking_section();
		Mem0[esp + 0x00:word32] = 0x01;
		caml_sys_error();
	}
	caml_leave_blocking_section();
	Mem0[ebx + 4:word32] = esi;
	Mem0[ebx + 8:word32] = edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069A8C: define caml_ml_seek_out_64
define caml_ml_seek_out_64
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[eax + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x00:word32] = ebx;
	caml_seek_out();
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069B0C: define caml_ml_seek_out
define caml_ml_seek_out
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	O = false;
	Mem0[esp + 4:word32] = eax;
	edx = eax;
	edx >>= 0x1F;
	SCZ = cond(edx);
	Mem0[esp + 8:word32] = edx;
	Mem0[esp + 0x00:word32] = ebx;
	caml_seek_out();
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069B8D: define caml_open_descriptor_in
// Called from:
//      caml_ml_open_descriptor_in
//      caml_open_descriptor_out
define caml_open_descriptor_in
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	SCZO = cond(esp);
	esi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = 4148;
	caml_stat_alloc();
	ebx = eax;
	Mem0[eax + 0x00:word32] = esi;
	caml_enter_blocking_section();
	Mem0[esp + 0x0C:word32] = 0x01;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 0x00:word32] = esi;
	lseek64();
	Mem0[ebx + 4:word32] = eax;
	Mem0[ebx + 8:word32] = edx;
	caml_leave_blocking_section();
	eax = ebx + 52;
	Mem0[ebx + 20:word32] = eax;
	Mem0[ebx + 16:word32] = eax;
	eax = ebx + 4148;
	Mem0[ebx + 0x0C:word32] = eax;
	Mem0[ebx + 24:word32] = 0x00;
	Mem0[ebx + 36:word32] = 0x00;
	Mem0[ebx + 40:word32] = 0x00;
	Mem0[ebx + 44:word32] = 0x00;
	Mem0[ebx + 48:word32] = 0x00;
	eax = Mem0[0x08081874<p32>:word32];
	Mem0[ebx + 28:word32] = eax;
	Mem0[ebx + 32:word32] = 0x00;
	eax = Mem0[0x08081874<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
		Mem0[eax + 32:word32] = ebx;
	Mem0[0x08081874<p32>:word32] = ebx;
	eax = ebx;
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069C37: define caml_ml_open_descriptor_in
define caml_ml_open_descriptor_in
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_open_descriptor_in();
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_channel();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069C54: define caml_open_descriptor_out
// Called from:
//      caml_ml_open_descriptor_out
define caml_open_descriptor_out
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_open_descriptor_in();
	Mem0[eax + 20:word32] = 0x00;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069C6E: define caml_ml_open_descriptor_out
define caml_ml_open_descriptor_out
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_open_descriptor_out();
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_channel();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069C90: define extern_replay_trail
// Called from:
//      extern_out_of_memory
//      grow_extern_output
//      extern_invalid_argument
//      extern_value
define extern_replay_trail
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	SCZO = cond(esp);
	eax = Mem0[0x080838AC<p32>:word32];
	Mem0[ebp + -28:word32] = eax;
	edi = Mem0[0x080838B0<p32>:word32];
	while (true)
	{
		eax = Mem0[ebp + -28:word32];
		eax += 0x04;
		SCZO = cond(edi - eax);
		while (Test(UGT,CZ))
		{
			ebx = Mem0[eax + 0x00:word32];
			edx = ebx;
			edx &= ~0x03;
			ecx = edx - 4;
			esi = Mem0[ecx + 0x00:word32];
			esi &= ~0x0300;
			ebx &= 0x03;
			ebx <<= 0x08;
			ebx |= esi;
			Mem0[ecx + 0x00:word32] = ebx;
			ecx = Mem0[eax + 4:word32];
			Mem0[edx + 0x00:word32] = ecx;
			eax += 0x08;
			SCZO = cond(edi - eax);
		}
		SCZO = cond(Mem0[ebp + -28:word32] - 0x080818A0);
		if (Test(EQ,Z))
			break;
		eax = Mem0[ebp + -28:word32];
		ebx = Mem0[eax + 0x00:word32];
		Mem0[esp + 0x00:word32] = eax;
		free(Mem0[esp + 0x00:(ptr32 void)]);
		edi = ebx + 0x200C;
		Mem0[ebp + -28:word32] = ebx;
	}
	Mem0[0x080838AC<p32>:word32] = 0x080818A0;
	Mem0[0x080838B0<p32>:word32] = 0x080818A4;
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069D16: define free_extern_output
// Called from:
//      extern_out_of_memory
//      extern_invalid_argument
//      caml_output_value_to_malloc
define free_extern_output
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(Mem0[0x080838B8<p32>:word32] - 0x00);
	if (Test(EQ,Z))
	{
		eax = Mem0[0x080838C4<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			while (true)
			{
				ebx = Mem0[eax + 0x00:word32];
				Mem0[esp + 0x00:word32] = eax;
				free(Mem0[esp + 0x00:(ptr32 void)]);
				SZP = cond(ebx & ebx);
				O = false;
				C = false;
				if (Test(EQ,Z))
					break;
				eax = ebx;
			}
		}
		Mem0[0x080838C4<p32>:word32] = 0x00;
	}
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069D51: define extern_out_of_memory
// Called from:
//      grow_extern_output
//      extern_record_location
//      caml_output_value_to_malloc
define extern_out_of_memory
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	extern_replay_trail();
	free_extern_output();
	caml_raise_out_of_memory();
	grow_extern_output();
}

// 08069D66: define grow_extern_output
// Called from:
//      extern_out_of_memory
//      caml_serialize_block_float_8
//      caml_serialize_block_8
//      caml_serialize_block_4
//      caml_serialize_block_2
//      caml_serialize_block_1
//      caml_serialize_int_4
//      caml_serialize_int_2
//      caml_serialize_int_1
//      writecode16
//      writecode8
//      writecode32
//      writeblock
//      write32
//      extern_rec
define grow_extern_output
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	SCZO = cond(Mem0[0x080838B8<p32>:word32] - 0x00);
	if (Test(NE,Z))
	{
		extern_replay_trail();
		Mem0[esp + 0x00:word32] = 0x08071C08;
		caml_failwith();
	}
	ecx = Mem0[0x080838BC<p32>:word32];
	edx = Mem0[0x080838C8<p32>:word32];
	Mem0[edx + 4:word32] = ecx;
	SCZO = cond(eax - 0x0FD3);
	esi = 0x00;
	if (Test(GE,SO))
		esi = eax;
	eax = esi + 8108;
	Mem0[esp + 0x00:word32] = eax;
	eax = malloc(Mem0[esp + 0x00:size_t]);
	ebx = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		extern_out_of_memory();
	eax = Mem0[0x080838C8<p32>:word32];
	Mem0[eax + 0x00:word32] = ebx;
	Mem0[0x080838C8<p32>:word32] = ebx;
	Mem0[ebx + 0x00:word32] = 0x00;
	eax = ebx + 8;
	Mem0[0x080838BC<p32>:word32] = eax;
	eax = ebx + 8108 + esi;
	Mem0[0x080838C0<p32>:word32] = eax;
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069DEB: define caml_serialize_block_float_8
// Called from:
//      caml_serialize_float_8
define caml_serialize_block_float_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 0x0C:word32];
	eax <<= 0x03;
	ebx = eax;
	edx = eax;
	edx += Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - edx);
	if (Test(ULT,C))
		grow_extern_output();
	Mem0[esp + 8:word32] = ebx;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x080838BC<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	v10 = Mem0[0x080838BC<p32>:word32] + ebx;
	Mem0[0x080838BC<p32>:word32] = v10;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069E33: define caml_serialize_float_8
define caml_serialize_float_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	Mem0[ebp + -16:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[ebp + -0x0C:word32] = eax;
	Mem0[esp + 4:word32] = 0x01;
	eax = ebp - 16;
	Mem0[esp + 0x00:word32] = eax;
	caml_serialize_block_float_8();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069E5A: define caml_serialize_block_8
// Called from:
//      caml_serialize_int_8
define caml_serialize_block_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	eax = Mem0[ebp + 0x0C:word32];
	eax <<= 0x03;
	edx = eax;
	edx += Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - edx);
	if (Test(ULT,C))
		grow_extern_output();
	edi = Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[ebp + 0x0C:word32] - 0x00);
	if (Test(GT,SZO))
	{
		edx = Mem0[ebp + 8:word32];
		eax = edi;
		ecx = Mem0[ebp + 0x0C:word32];
		Mem0[ebp + -44:word32] = ecx;
		Mem0[ebp + -28:word32] = edi;
		do
		{
			esi = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
			ebx = CONVERT(Mem0[edx + 1:byte], byte, word32);
			edi = CONVERT(Mem0[edx + 7:byte], byte, word32);
			ecx = edi;
			Mem0[eax + 0x00:byte] = cl;
			edi = CONVERT(Mem0[edx + 6:byte], byte, word32);
			ecx = edi;
			Mem0[eax + 1:byte] = cl;
			ecx = esi;
			Mem0[eax + 7:byte] = cl;
			Mem0[eax + 6:byte] = bl;
			esi = CONVERT(Mem0[edx + 2:byte], byte, word32);
			ebx = CONVERT(Mem0[edx + 3:byte], byte, word32);
			edi = CONVERT(Mem0[edx + 5:byte], byte, word32);
			ecx = edi;
			Mem0[eax + 2:byte] = cl;
			edi = CONVERT(Mem0[edx + 4:byte], byte, word32);
			ecx = edi;
			Mem0[eax + 3:byte] = cl;
			ecx = esi;
			Mem0[eax + 5:byte] = cl;
			Mem0[eax + 4:byte] = bl;
			edx += 0x08;
			eax += 0x08;
			v16 = Mem0[ebp + -44:word32] - 0x01;
			Mem0[ebp + -44:word32] = v16;
			SCZO = cond(v16);
		} while (Test(NE,Z));
		edi = Mem0[ebp + -28:word32];
		eax = Mem0[ebp + 0x0C:word32];
		edi += eax * 0x08;
	}
	Mem0[0x080838BC<p32>:word32] = edi;
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069EFD: define caml_serialize_int_8
// Called from:
//      int64_serialize
define caml_serialize_int_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	Mem0[ebp + -16:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[ebp + -0x0C:word32] = eax;
	Mem0[esp + 4:word32] = 0x01;
	eax = ebp - 16;
	Mem0[esp + 0x00:word32] = eax;
	caml_serialize_block_8();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069F24: define caml_serialize_block_4
// Called from:
//      caml_serialize_float_4
define caml_serialize_block_4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax <<= 0x02;
	edx = eax;
	edx += Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - edx);
	if (Test(ULT,C))
		grow_extern_output();
	edx = Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[ebp + 0x0C:word32] - 0x00);
	if (Test(GT,SZO))
	{
		ecx = Mem0[ebp + 0x0C:word32];
		eax = 0x00;
		Mem0[ebp + -28:word32] = ecx;
		do
		{
			edi = CONVERT(Mem0[ebx + eax:byte], byte, word32);
			esi = CONVERT(Mem0[ebx + 1 + eax:byte], byte, word32);
			ecx = CONVERT(Mem0[ebx + 3 + eax:byte], byte, word32);
			Mem0[edx + eax:byte] = cl;
			ecx = CONVERT(Mem0[ebx + 2 + eax:byte], byte, word32);
			Mem0[edx + 1 + eax:byte] = cl;
			ecx = edi;
			Mem0[edx + 3 + eax:byte] = cl;
			ecx = esi;
			Mem0[edx + 2 + eax:byte] = cl;
			eax += 0x04;
			v15 = Mem0[ebp + -28:word32] - 0x01;
			Mem0[ebp + -28:word32] = v15;
			SCZO = cond(v15);
		} while (Test(NE,Z));
		eax = Mem0[ebp + 0x0C:word32];
		edx += eax * 0x04;
	}
	Mem0[0x080838BC<p32>:word32] = edx;
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069FA5: define caml_serialize_float_4
define caml_serialize_float_4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = 0x01;
	eax = ebp + 8;
	Mem0[esp + 0x00:word32] = eax;
	caml_serialize_block_4();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08069FC0: define caml_serialize_block_2
define caml_serialize_block_2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	ebx = Mem0[ebp + 8:word32];
	edi = Mem0[ebp + 0x0C:word32];
	eax = edi + edi;
	edx = eax;
	edx += Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - edx);
	if (Test(ULT,C))
		grow_extern_output();
	ecx = Mem0[0x080838BC<p32>:word32];
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		eax = 0x00;
		Mem0[ebp + -44:word32] = edi;
		Mem0[ebp + -28:word32] = edi;
		do
		{
			esi = CONVERT(Mem0[ebx + eax:byte], byte, word32);
			edi = CONVERT(Mem0[ebx + 1 + eax:byte], byte, word32);
			edx = edi;
			Mem0[ecx + eax:byte] = dl;
			edx = esi;
			Mem0[ecx + 1 + eax:byte] = dl;
			eax += 0x02;
			v17 = Mem0[ebp + -44:word32] - 0x01;
			Mem0[ebp + -44:word32] = v17;
			SCZO = cond(v17);
		} while (Test(NE,Z));
		edi = Mem0[ebp + -28:word32];
		ecx += edi * 0x02;
	}
	Mem0[0x080838BC<p32>:word32] = ecx;
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A02D: define caml_serialize_block_1
define caml_serialize_block_1
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 0x0C:word32];
	ebx = eax;
	edx = eax;
	edx += Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - edx);
	if (Test(ULT,C))
		grow_extern_output();
	Mem0[esp + 8:word32] = ebx;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[0x080838BC<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	v10 = Mem0[0x080838BC<p32>:word32] + ebx;
	Mem0[0x080838BC<p32>:word32] = v10;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A072: define caml_serialize_int_4
// Called from:
//      nativeint_serialize
//      int32_serialize
define caml_serialize_int_4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[0x080838BC<p32>:word32];
	eax += 0x04;
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = 0x04;
		grow_extern_output();
	}
	eax = Mem0[0x080838BC<p32>:word32];
	edx = ebx;
	edx >>= 0x18;
	Mem0[eax + 0x00:byte] = dl;
	edx = ebx;
	edx >>= 0x10;
	Mem0[eax + 1:byte] = dl;
	edx = ebx;
	edx >>= 0x08;
	Mem0[eax + 2:byte] = dl;
	Mem0[eax + 3:byte] = bl;
	eax += 0x04;
	Mem0[0x080838BC<p32>:word32] = eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A0C3: define caml_serialize_int_2
define caml_serialize_int_2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[0x080838BC<p32>:word32];
	eax += 0x02;
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = 0x02;
		grow_extern_output();
	}
	eax = Mem0[0x080838BC<p32>:word32];
	edx = ebx;
	edx >>= 0x08;
	Mem0[eax + 0x00:byte] = dl;
	Mem0[eax + 1:byte] = bl;
	eax += 0x02;
	Mem0[0x080838BC<p32>:word32] = eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A104: define caml_serialize_int_1
// Called from:
//      nativeint_serialize
define caml_serialize_int_1
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	eax = Mem0[0x080838BC<p32>:word32];
	++eax;
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = 0x01;
		grow_extern_output();
	}
	eax = Mem0[0x080838BC<p32>:word32];
	edx = Mem0[ebp + 8:word32];
	Mem0[eax + 0x00:byte] = dl;
	++eax;
	SCZO = cond(eax);
	Mem0[0x080838BC<p32>:word32] = eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A138: define writecode16
// Called from:
//      extern_rec
define writecode16
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = esi;
	esi = eax;
	ebx = edx;
	eax = Mem0[0x080838BC<p32>:word32];
	eax += 0x03;
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = 0x03;
		grow_extern_output();
	}
	eax = Mem0[0x080838BC<p32>:word32];
	edx = esi;
	Mem0[eax + 0x00:byte] = dl;
	edx = ebx;
	edx >>= 0x08;
	Mem0[eax + 1:byte] = dl;
	Mem0[eax + 2:byte] = bl;
	eax += 0x03;
	SCZO = cond(eax);
	Mem0[0x080838BC<p32>:word32] = eax;
	ebx = Mem0[esp + 0x00:word32];
	esi = Mem0[esp + 4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A18A: define writecode8
// Called from:
//      extern_rec
define writecode8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = esi;
	ebx = eax;
	esi = edx;
	eax = Mem0[0x080838BC<p32>:word32];
	eax += 0x02;
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = 0x02;
		grow_extern_output();
	}
	eax = Mem0[0x080838BC<p32>:word32];
	Mem0[eax + 0x00:byte] = bl;
	edx = esi;
	Mem0[eax + 1:byte] = dl;
	eax += 0x02;
	SCZO = cond(eax);
	Mem0[0x080838BC<p32>:word32] = eax;
	ebx = Mem0[esp + 0x00:word32];
	esi = Mem0[esp + 4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A1D4: define writecode32
// Called from:
//      extern_rec
define writecode32
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	Mem0[esp + 0x00:word32] = ebx;
	Mem0[esp + 4:word32] = esi;
	esi = eax;
	ebx = edx;
	eax = Mem0[0x080838BC<p32>:word32];
	eax += 0x05;
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = 0x05;
		grow_extern_output();
	}
	eax = Mem0[0x080838BC<p32>:word32];
	edx = esi;
	Mem0[eax + 0x00:byte] = dl;
	edx = ebx;
	edx >>= 0x18;
	Mem0[eax + 1:byte] = dl;
	edx = ebx;
	edx >>= 0x10;
	Mem0[eax + 2:byte] = dl;
	edx = ebx;
	edx >>= 0x08;
	Mem0[eax + 3:byte] = dl;
	Mem0[eax + 4:byte] = bl;
	eax += 0x05;
	SCZO = cond(eax);
	Mem0[0x080838BC<p32>:word32] = eax;
	ebx = Mem0[esp + 0x00:word32];
	esi = Mem0[esp + 4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A236: define writeblock
// Called from:
//      extern_rec
define writeblock
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	esi = eax;
	ebx = edx;
	eax = edx;
	eax += Mem0[0x080838BC<p32>:word32];
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = edx;
		grow_extern_output();
	}
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 4:word32] = esi;
	eax = Mem0[0x080838BC<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	v11 = Mem0[0x080838BC<p32>:word32] + ebx;
	Mem0[0x080838BC<p32>:word32] = v11;
	SCZO = cond(v11);
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A282: define write32
// Called from:
//      extern_value
define write32
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ebx = eax;
	eax = Mem0[0x080838BC<p32>:word32];
	eax += 0x04;
	SCZO = cond(Mem0[0x080838C0<p32>:word32] - eax);
	if (Test(ULT,C))
	{
		eax = 0x04;
		grow_extern_output();
	}
	eax = Mem0[0x080838BC<p32>:word32];
	edx = ebx;
	edx >>= 0x18;
	Mem0[eax + 0x00:byte] = dl;
	edx = ebx;
	edx >>= 0x10;
	Mem0[eax + 1:byte] = dl;
	edx = ebx;
	edx >>= 0x08;
	Mem0[eax + 2:byte] = dl;
	Mem0[eax + 3:byte] = bl;
	eax += 0x04;
	Mem0[0x080838BC<p32>:word32] = eax;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A2D2: define extern_record_location
// Called from:
//      extern_rec
define extern_record_location
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = eax;
	SCZO = cond(Mem0[0x0808188C<p32>:word32] - 0x00);
	if (Test(EQ,Z))
	{
		eax = Mem0[0x080838B0<p32>:word32];
		SCZO = cond(eax - Mem0[0x080838B4<p32>:word32]);
		if (Test(EQ,Z))
		{
			Mem0[esp + 0x00:word32] = 0x200C;
			eax = malloc(Mem0[esp + 0x00:size_t]);
			esi = eax;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				extern_out_of_memory();
			eax = Mem0[0x080838AC<p32>:word32];
			Mem0[esi + 0x00:word32] = eax;
			Mem0[0x080838AC<p32>:word32] = esi;
			eax = esi + 4;
			Mem0[0x080838B0<p32>:word32] = eax;
			esi += 0x200C;
			SCZO = cond(esi);
			Mem0[0x080838B4<p32>:word32] = esi;
		}
		edx = ebx - 4;
		ecx = Mem0[edx + 0x00:word32];
		eax = Mem0[0x080838B0<p32>:word32];
		esi = ecx;
		esi >>= 0x08;
		esi &= 0x03;
		esi |= ebx;
		Mem0[eax + 0x00:word32] = esi;
		esi = Mem0[ebx + 0x00:word32];
		Mem0[eax + 4:word32] = esi;
		eax += 0x08;
		Mem0[0x080838B0<p32>:word32] = eax;
		ch &= 252;
		ch |= 0x02;
		Mem0[edx + 0x00:word32] = ecx;
		eax = Mem0[0x08081880<p32>:word32];
		Mem0[ebx + 0x00:word32] = eax;
		++eax;
		SCZO = cond(eax);
		Mem0[0x08081880<p32>:word32] = eax;
	}
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A372: define init_extern_output
// Called from:
//      caml_output_value_to_malloc
//      caml_output_value_to_string
//      caml_output_val
define init_extern_output
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[0x080838B8<p32>:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 8108;
	eax = malloc(Mem0[esp + 0x00:size_t]);
	Mem0[0x080838C4<p32>:word32] = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_out_of_memory();
	Mem0[0x080838C8<p32>:word32] = eax;
	Mem0[eax + 0x00:word32] = 0x00;
	edx = eax + 8;
	Mem0[0x080838BC<p32>:word32] = edx;
	eax += 8108;
	SCZO = cond(eax);
	Mem0[0x080838C0<p32>:word32] = eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A3BC: define extern_invalid_argument
// Called from:
//      extern_rec
define extern_invalid_argument
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	ebx = eax;
	extern_replay_trail();
	free_extern_output();
	Mem0[esp + 0x00:word32] = ebx;
	caml_invalid_argument();
	extern_rec();
}

// 0806A3D7: define extern_rec
// Called from:
//      extern_invalid_argument
//      extern_rec
//      extern_value
define extern_rec
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x5C;
	SCZO = cond(esp);
	ebx = eax;
	while (true)
	{
		SZP = cond(bl & 0x01);
		O = false;
		C = false;
		if (Test(NE,Z))
			break;
		esi = ebx;
		edx = ebx;
		edx >>= 0x17;
		eax = ebx;
		eax >>= 0x0C;
		eax &= 0x07FF;
		edx = 0x08084000[edx * 0x04];
		SZP = cond(Mem0[edx + eax:byte] & 0x07);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			SCZO = cond(ebx - Mem0[0x080839E0<p32>:word32]);
			if (Test(UGE,C))
			{
				SCZO = cond(ebx - Mem0[0x08083A9C<p32>:word32]);
				if (Test(ULT,C))
				{
					SCZO = cond(Mem0[0x08081890<p32>:word32] - 0x00);
					if (Test(EQ,Z))
					{
						eax = 0x08071C7C;
						extern_invalid_argument();
					}
					edx = ebx;
					edx -= Mem0[0x080839E0<p32>:word32];
					SCZO = cond(edx);
					eax = 0x10;
					writecode32();
					caml_code_checksum();
					edx = 0x10;
					writeblock();
					goto l0806A8C5;
				}
			}
			eax = 0x08071C9C;
			extern_invalid_argument();
			goto l0806A8C5;
		}
		edx = Mem0[ebx + -4:word32];
		edi = CONVERT(dl, byte, word32);
		SCZO = cond(edi - 0xFA);
		if (Test(NE,Z))
		{
l0806A4EA:
			ecx = edx;
			ecx >>= 0x0A;
			Mem0[ebp + -44:word32] = ecx;
			SZP = cond(ecx & ecx);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				SCZO = cond(edi - 0x0F);
				if (Test(ULE,CZ))
				{
					eax = Mem0[0x080838BC<p32>:word32];
					SCZO = cond(eax - Mem0[0x080838C0<p32>:word32]);
					if (Test(UGE,C))
					{
						eax = 0x01;
						grow_extern_output();
					}
					eax = Mem0[0x080838BC<p32>:word32];
					edx = edi - 0x0080;
					Mem0[eax + 0x00:byte] = dl;
					++eax;
					SCZO = cond(eax);
					Mem0[0x080838BC<p32>:word32] = eax;
				}
				else
				{
					eax = 0x08;
					writecode32();
				}
				goto l0806A8C5;
			}
			eax = edx;
			eax &= 0x0300;
			SCZO = cond(eax - 0x0200);
			if (Test(EQ,Z))
			{
				edx = Mem0[0x08081880<p32>:word32];
				edx -= Mem0[ebx + 0x00:word32];
				SCZO = cond(edx - 0xFF);
				if (Test(ULE,CZ))
				{
					ax = 0x04;
					writecode8();
				}
				else
				{
					SCZO = cond(edx - 0xFFFF);
					if (Test(ULE,CZ))
					{
						eax = 0x05;
						writecode16();
					}
					else
					{
						eax = 0x06;
						writecode32();
					}
				}
				goto l0806A8C5;
			}
			eax = edi - 0xF9;
			v23 = eax;
			SCZO = cond(eax - 0x06);
			if (Test(ULE,CZ))
			{
				switch (v23)
				{
				case 0x00:
					ebx = Mem0[ebp + -44:word32];
					ebx <<= 0x02;
					SCZO = cond(ebx);
					edx = ebx;
					eax = 0x11;
					writecode32();
					eax = esi;
					eax -= ebx;
					SCZO = cond(eax);
					extern_rec();
					break;
				case 0x01:
					goto l0806A7C1;
				case 0x02:
					eax = 0x08071C2C;
					extern_invalid_argument();
					esi = esi;
					break;
				case 0x03:
					Mem0[esp + 0x00:word32] = ebx;
					caml_string_length();
					esi = eax;
					SCZO = cond(eax - 0x1F);
					if (Test(ULE,CZ))
					{
						eax = Mem0[0x080838BC<p32>:word32];
						SCZO = cond(eax - Mem0[0x080838C0<p32>:word32]);
						if (Test(UGE,C))
						{
							eax = 0x01;
							grow_extern_output();
						}
						eax = Mem0[0x080838BC<p32>:word32];
						edx = esi + 32;
						Mem0[eax + 0x00:byte] = dl;
						++eax;
						SCZO = cond(eax);
						Mem0[0x080838BC<p32>:word32] = eax;
					}
					else
					{
						SCZO = cond(eax - 0xFF);
						if (Test(ULE,CZ))
						{
							edx = eax;
							eax = 0x09;
							writecode8();
						}
						else
						{
							edx = eax;
							eax = 0x0A;
							writecode32();
						}
					}
					edx = esi;
					eax = ebx;
					writeblock();
					eax = esi + 4;
					eax >>= 0x02;
					edx = Mem0[0x08081884<p32>:word32];
					eax = edx + 1 + eax;
					Mem0[0x08081884<p32>:word32] = eax;
					esi += 0x08;
					esi >>= 0x03;
					SCZO = cond(esi);
					eax = Mem0[0x08081888<p32>:word32];
					eax = eax + 1 + esi;
					Mem0[0x08081888<p32>:word32] = eax;
					eax = ebx;
					extern_record_location();
					break;
				case 0x04:
					eax = Mem0[0x080838BC<p32>:word32];
					SCZO = cond(eax - Mem0[0x080838C0<p32>:word32]);
					if (Test(UGE,C))
					{
						eax = 0x01;
						grow_extern_output();
					}
					eax = Mem0[0x080838BC<p32>:word32];
					Mem0[eax + 0x00:byte] = 0x0C;
					++eax;
					SCZO = cond(eax);
					Mem0[0x080838BC<p32>:word32] = eax;
					edx = 0x08;
					eax = ebx;
					writeblock();
					v24 = Mem0[0x08081884<p32>:word32] + 0x03;
					Mem0[0x08081884<p32>:word32] = v24;
					v25 = Mem0[0x08081888<p32>:word32] + 0x02;
					Mem0[0x08081888<p32>:word32] = v25;
					SCZO = cond(v25);
					eax = ebx;
					extern_record_location();
					break;
				case 0x05:
					esi = Mem0[ebp + -44:word32];
					esi >>= 0x01;
					SCZO = cond(esi - 0xFF);
					if (Test(ULE,CZ))
					{
						edx = esi;
						eax = 0x0E;
						writecode8();
					}
					else
					{
						edx = esi;
						eax = 0x07;
						writecode32();
					}
					edx = 0x00 + esi * 0x08;
					eax = ebx;
					writeblock();
					eax = Mem0[0x08081884<p32>:word32];
					eax = eax + 1 + esi * 0x02;
					Mem0[0x08081884<p32>:word32] = eax;
					eax = Mem0[0x08081888<p32>:word32];
					eax = esi + 1 + eax;
					Mem0[0x08081888<p32>:word32] = eax;
					eax = ebx;
					extern_record_location();
					break;
				case 0x06:
					Mem0[ebp + -44:word32] = ebx;
					eax = Mem0[ebx + 0x00:word32];
					esi = Mem0[eax + 0x00:word32];
					SCZO = cond(Mem0[eax + 16:word32] - 0x00);
					if (Test(EQ,Z))
					{
						eax = 0x08071C54;
						extern_invalid_argument();
					}
					eax = Mem0[0x080838BC<p32>:word32];
					SCZO = cond(eax - Mem0[0x080838C0<p32>:word32]);
					if (Test(UGE,C))
					{
						eax = 0x01;
						grow_extern_output();
					}
					eax = Mem0[0x080838BC<p32>:word32];
					Mem0[eax + 0x00:byte] = 0x12;
					++eax;
					Mem0[0x080838BC<p32>:word32] = eax;
					edi = esi;
					ecx = ~0x00;
					size = strlen(edi) + 1;
					ecx -= size;
					edi += size;
					SCZO = cond(0x00);
					edx = ecx;
					edx = ~edx;
					eax = esi;
					writeblock();
					edx = Mem0[ebp + -44:word32];
					eax = Mem0[edx + 0x00:word32];
					edx = ebp - 32;
					Mem0[esp + 8:word32] = edx;
					edx = ebp - 28;
					Mem0[esp + 4:word32] = edx;
					Mem0[esp + 0x00:word32] = ebx;
					Mem0[eax + 16:word32]();
					eax = Mem0[ebp + -28:word32];
					eax += 0x03;
					eax >>= 0x02;
					edx = Mem0[0x08081884<p32>:word32];
					eax = edx + 2 + eax;
					Mem0[0x08081884<p32>:word32] = eax;
					eax = Mem0[ebp + -32:word32];
					eax += 0x07;
					eax >>= 0x03;
					SCZO = cond(eax);
					edx = Mem0[0x08081888<p32>:word32];
					eax = edx + 2 + eax;
					Mem0[0x08081888<p32>:word32] = eax;
					eax = ebx;
					extern_record_location();
					break;
				}
				goto l0806A8C5;
			}
l0806A7C1:
			SCZO = cond(edi - 0x0F);
			if (Test(ULE,CZ))
			{
				SCZO = cond(Mem0[ebp + -44:word32] - 0x07);
				if (Test(UGT,CZ))
					goto l0806A7FF;
				eax = Mem0[0x080838BC<p32>:word32];
				SCZO = cond(eax - Mem0[0x080838C0<p32>:word32]);
				if (Test(UGE,C))
				{
					eax = 0x01;
					grow_extern_output();
				}
				eax = Mem0[0x080838BC<p32>:word32];
				edx = CONVERT(Mem0[ebp + -44:byte], byte, word32);
				edx <<= 0x04;
				edx = edx - 0x0080 + edi;
				Mem0[eax + 0x00:byte] = dl;
				++eax;
				SCZO = cond(eax);
				Mem0[0x080838BC<p32>:word32] = eax;
			}
			else
			{
l0806A7FF:
				dh &= 252;
				SZ = cond(dh);
				O = false;
				C = false;
				eax = 0x08;
				writecode32();
			}
			eax = Mem0[0x08081884<p32>:word32];
			ecx = Mem0[ebp + -44:word32];
			eax = ecx + 1 + eax;
			Mem0[0x08081884<p32>:word32] = eax;
			eax = Mem0[0x08081888<p32>:word32];
			eax = ecx + 1 + eax;
			Mem0[0x08081888<p32>:word32] = eax;
			edi = Mem0[ebx + 0x00:word32];
			eax = ebx;
			extern_record_location();
			ebx = edi;
			SCZO = cond(Mem0[ebp + -44:word32] - 0x01);
			if (Test(NE,Z))
			{
				eax = edi;
				extern_rec();
				edi = Mem0[ebp + -44:word32];
				--edi;
				ebx = 0x01;
				SCZO = cond(edi - 0x01);
				if (Test(ULE,CZ))
					edi = 0x01;
				else
				{
					do
					{
						eax = esi[ebx * 0x04];
						extern_rec();
						++ebx;
						SCZO = cond(edi - ebx);
					} while (Test(UGT,CZ));
				}
				ebx = esi[edi * 0x04];
			}
			continue;
		}
		eax = Mem0[ebx + 0x00:word32];
		Mem0[ebp + -76:word32] = eax;
		SZP = cond(al & 0x01);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			Mem0[ebp + -48:word32] = eax;
			eax >>= 0x17;
			ecx = Mem0[ebp + -76:word32];
			ecx >>= 0x0C;
			ecx &= 0x07FF;
			eax = 0x08084000[eax * 0x04];
			SZP = cond(Mem0[eax + ecx:byte] & 0x07);
			O = false;
			C = false;
			if (Test(EQ,Z))
				goto l0806A4EA;
			eax = Mem0[ebp + -48:word32];
			eax = CONVERT(Mem0[eax + -4:byte], byte, word32);
			Mem0[ebp + -44:byte] = al;
			SCZO = cond(al - ~0x05);
			if (Test(EQ,Z))
				goto l0806A4EA;
			SCZO = cond(al - ~0x09);
			if (Test(EQ,Z))
				goto l0806A4EA;
			SCZO = cond(al - ~0x02);
			if (Test(EQ,Z))
				goto l0806A4EA;
		}
		ebx = Mem0[ebp + -76:word32];
	}
	ebx >>= 0x01;
	eax = ebx;
	SCZO = cond(ebx - 0x3F);
	if (Test(ULE,CZ))
	{
		eax = Mem0[0x080838BC<p32>:word32];
		SCZO = cond(eax - Mem0[0x080838C0<p32>:word32]);
		if (Test(UGE,C))
		{
			eax = 0x01;
			grow_extern_output();
		}
		eax = Mem0[0x080838BC<p32>:word32];
		ebx += 0x40;
		Mem0[eax + 0x00:byte] = bl;
		++eax;
		SCZO = cond(eax);
		Mem0[0x080838BC<p32>:word32] = eax;
	}
	else
	{
		edx = ebx + 0x80;
		SCZO = cond(edx - 0xFF);
		if (Test(ULE,CZ))
		{
			edx = ebx;
			eax = 0x00;
			writecode8();
		}
		else
		{
			eax += 0x8000;
			SCZO = cond(eax - 0xFFFF);
			if (Test(ULE,CZ))
			{
				edx = ebx;
				eax = 0x01;
				writecode16();
			}
			else
			{
				edx = ebx;
				eax = 0x02;
				writecode32();
			}
		}
	}
l0806A8C5:
	esp += 0x5C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806A8CD: define extern_value
// Called from:
//      caml_output_value_to_block
//      caml_output_value_to_malloc
//      caml_output_value_to_buffer
//      caml_output_value_to_string
//      caml_output_val
define extern_value
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	ebx = eax;
	Mem0[esp + 4:word32] = 0x0807D06C;
	Mem0[esp + 0x00:word32] = edx;
	caml_convert_flag_list();
	edx = eax;
	edx &= 0x01;
	Mem0[0x0808188C<p32>:word32] = edx;
	eax &= 0x02;
	SZ = cond(eax);
	O = false;
	C = false;
	Mem0[0x08081890<p32>:word32] = eax;
	Mem0[0x080838AC<p32>:word32] = 0x080818A0;
	Mem0[0x080838B0<p32>:word32] = 0x080818A4;
	Mem0[0x080838B4<p32>:word32] = 0x080838AC;
	Mem0[0x08081880<p32>:word32] = 0x00;
	Mem0[0x08081884<p32>:word32] = 0x00;
	Mem0[0x08081888<p32>:word32] = 0x00;
	eax = 2224400062;
	write32();
	v12 = Mem0[0x080838BC<p32>:word32] + 0x10;
	Mem0[0x080838BC<p32>:word32] = v12;
	SCZO = cond(v12);
	eax = ebx;
	extern_rec();
	SCZO = cond(Mem0[0x080838B8<p32>:word32] - 0x00);
	if (Test(EQ,Z))
	{
		edx = Mem0[0x080838BC<p32>:word32];
		eax = Mem0[0x080838C8<p32>:word32];
		Mem0[eax + 4:word32] = edx;
	}
	extern_replay_trail();
	eax = Mem0[0x080838B8<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		ebx = Mem0[0x080838BC<p32>:word32];
		ebx -= eax;
		eax += 0x04;
		SCZO = cond(eax);
		Mem0[0x080838BC<p32>:word32] = eax;
	}
	else
	{
		ecx = Mem0[0x080838C4<p32>:word32];
		ebx = 0x00;
		SZP = cond(ecx & ecx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			eax = ecx;
			do
			{
				edx = Mem0[eax + 4:word32];
				edx -= eax;
				ebx = edx - 8 + ebx;
				eax = Mem0[eax + 0x00:word32];
				SZP = cond(eax & eax);
				O = false;
				C = false;
			} while (Test(NE,Z));
		}
		eax = ecx + 0x0C;
		Mem0[0x080838BC<p32>:word32] = eax;
		ecx += 8108;
		SCZO = cond(ecx);
		Mem0[0x080838C0<p32>:word32] = ecx;
	}
	eax = ebx - 20;
	write32();
	eax = Mem0[0x08081880<p32>:word32];
	write32();
	eax = Mem0[0x08081884<p32>:word32];
	write32();
	eax = Mem0[0x08081888<p32>:word32];
	write32();
	eax = ebx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// subject_text_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0806A9EA: define caml_output_value_to_block
define caml_output_value_to_block
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	eax = Mem0[ebp + 16:word32];
	Mem0[0x080838B8<p32>:word32] = eax;
	Mem0[0x080838BC<p32>:word32] = eax;
	eax += Mem0[ebp + 20:word32];
	SCZO = cond(eax);
	Mem0[0x080838C0<p32>:word32] = eax;
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	extern_value();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AA12: define caml_output_value_to_malloc
define caml_output_value_to_malloc
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	SCZO = cond(esp);
	init_extern_output();
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	extern_value();
	ebx = eax;
	Mem0[esp + 0x00:word32] = eax;
	eax = malloc(Mem0[esp + 0x00:size_t]);
	esi = eax;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		extern_out_of_memory();
	eax = Mem0[ebp + 16:word32];
	Mem0[eax + 0x00:word32] = esi;
	eax = Mem0[ebp + 20:word32];
	Mem0[eax + 0x00:word32] = ebx;
	ebx = Mem0[0x080838C4<p32>:word32];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	while (Test(NE,Z))
	{
		eax = ebx + 8;
		edi = Mem0[ebx + 4:word32];
		edi -= eax;
		Mem0[esp + 8:word32] = edi;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = esi;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		esi += edi;
		ebx = Mem0[ebx + 0x00:word32];
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
	}
	free_extern_output();
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AA81: define caml_output_value_to_buffer
define caml_output_value_to_buffer
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 8:word32];
	Mem0[0x080838B8<p32>:word32] = eax;
	Mem0[0x080838BC<p32>:word32] = eax;
	edx = Mem0[ebp + 16:word32];
	edx >>= 0x01;
	eax += edx;
	SCZO = cond(eax);
	Mem0[0x080838C0<p32>:word32] = eax;
	edx = Mem0[ebp + 24:word32];
	eax = Mem0[ebp + 20:word32];
	extern_value();
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AAB6: define caml_output_value_to_string
define caml_output_value_to_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	SCZO = cond(esp);
	init_extern_output();
	edx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 8:word32];
	extern_value();
	ebx = Mem0[0x080838C4<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_string();
	Mem0[ebp + -28:word32] = eax;
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edi = 0x00;
		while (true)
		{
			eax = ebx + 8;
			esi = Mem0[ebx + 4:word32];
			esi -= eax;
			Mem0[esp + 8:word32] = esi;
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + -28:word32];
			eax = edi + eax;
			Mem0[esp + 0x00:word32] = eax;
			eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
			edi += esi;
			esi = Mem0[ebx + 0x00:word32];
			Mem0[esp + 0x00:word32] = ebx;
			free(Mem0[esp + 0x00:(ptr32 void)]);
			SZP = cond(esi & esi);
			O = false;
			C = false;
			if (Test(EQ,Z))
				break;
			ebx = esi;
		}
	}
	eax = Mem0[ebp + -28:word32];
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AB26: define caml_output_val
// Called from:
//      caml_output_value
define caml_output_val
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	SCZO = cond(esp);
	edi = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = edi;
	caml_channel_binary_mode();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071CC8;
		caml_failwith();
	}
	init_extern_output();
	edx = Mem0[ebp + 16:word32];
	eax = Mem0[ebp + 0x0C:word32];
	extern_value();
	ebx = Mem0[0x080838C4<p32>:word32];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		while (true)
		{
			eax = ebx + 8;
			edx = Mem0[ebx + 4:word32];
			edx -= eax;
			SCZO = cond(edx);
			Mem0[esp + 8:word32] = edx;
			Mem0[esp + 4:word32] = eax;
			Mem0[esp + 0x00:word32] = edi;
			caml_really_putblock();
			esi = Mem0[ebx + 0x00:word32];
			Mem0[esp + 0x00:word32] = ebx;
			free(Mem0[esp + 0x00:(ptr32 void)]);
			SZP = cond(esi & esi);
			O = false;
			C = false;
			if (Test(EQ,Z))
				break;
			ebx = esi;
		}
	}
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AB96: define caml_output_value
define caml_output_value
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x30;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x03;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = ebp + 16;
	Mem0[ebp + -20:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 4:word32];
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_output_val();
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = 0x01;
	esp += 0x30;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AC1C: define caml_deserialize_uint_1
// Called from:
//      nativeint_deserialize
define caml_deserialize_uint_1
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	edx = Mem0[0x080838E0<p32>:word32];
	eax = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
	++edx;
	SCZO = cond(edx);
	Mem0[0x080838E0<p32>:word32] = edx;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AC33: define caml_deserialize_sint_1
define caml_deserialize_sint_1
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	edx = Mem0[0x080838E0<p32>:word32];
	eax = CONVERT(Mem0[edx + 0x00:byte], byte, int32);
	++edx;
	SCZO = cond(edx);
	Mem0[0x080838E0<p32>:word32] = edx;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AC4A: define caml_deserialize_uint_2
define caml_deserialize_uint_2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	edx = Mem0[0x080838E0<p32>:word32];
	eax = edx + 2;
	Mem0[0x080838E0<p32>:word32] = eax;
	ecx = CONVERT(Mem0[eax + -1:byte], byte, word32);
	eax = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
	eax <<= 0x08;
	SCZO = cond(eax);
	eax = ecx + eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AC6A: define caml_deserialize_sint_2
define caml_deserialize_sint_2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	eax = Mem0[0x080838E0<p32>:word32];
	edx = eax + 2;
	Mem0[0x080838E0<p32>:word32] = edx;
	eax = CONVERT(Mem0[eax + 0x00:byte], byte, int32);
	eax <<= 0x08;
	edx = CONVERT(Mem0[edx + -1:byte], byte, word32);
	eax += edx;
	SCZO = cond(eax);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AC89: define caml_deserialize_uint_4
define caml_deserialize_uint_4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	ecx = Mem0[0x080838E0<p32>:word32];
	edx = ecx + 4;
	Mem0[0x080838E0<p32>:word32] = edx;
	ebx = CONVERT(Mem0[edx + -1:byte], byte, word32);
	eax = CONVERT(Mem0[ecx + 0x00:byte], byte, word32);
	eax <<= 0x18;
	eax = ebx + eax;
	ecx = CONVERT(Mem0[edx + -3:byte], byte, word32);
	ecx <<= 0x10;
	eax += ecx;
	edx = CONVERT(Mem0[edx + -2:byte], byte, word32);
	edx <<= 0x08;
	eax += edx;
	SCZO = cond(eax);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806ACBE: define caml_deserialize_sint_4
// Called from:
//      int32_deserialize
//      nativeint_deserialize
define caml_deserialize_sint_4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	ecx = Mem0[0x080838E0<p32>:word32];
	edx = ecx + 4;
	Mem0[0x080838E0<p32>:word32] = edx;
	ebx = CONVERT(Mem0[edx + -1:byte], byte, word32);
	eax = CONVERT(Mem0[ecx + 0x00:byte], byte, word32);
	eax <<= 0x18;
	eax = ebx + eax;
	ecx = CONVERT(Mem0[edx + -3:byte], byte, word32);
	ecx <<= 0x10;
	eax += ecx;
	edx = CONVERT(Mem0[edx + -2:byte], byte, word32);
	edx <<= 0x08;
	eax += edx;
	SCZO = cond(eax);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806ACF3: define caml_deserialize_block_2
define caml_deserialize_block_2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x08;
	ebx = Mem0[ebp + 8:word32];
	edi = Mem0[ebp + 0x0C:word32];
	ecx = Mem0[0x080838E0<p32>:word32];
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		eax = 0x00;
		Mem0[ebp + -20:word32] = edi;
		Mem0[ebp + -16:word32] = edi;
		do
		{
			esi = CONVERT(Mem0[ecx + eax:byte], byte, word32);
			edi = CONVERT(Mem0[ecx + 1 + eax:byte], byte, word32);
			edx = edi;
			Mem0[ebx + eax:byte] = dl;
			edx = esi;
			Mem0[ebx + 1 + eax:byte] = dl;
			eax += 0x02;
			v17 = Mem0[ebp + -20:word32] - 0x01;
			Mem0[ebp + -20:word32] = v17;
			SCZO = cond(v17);
		} while (Test(NE,Z));
		edi = Mem0[ebp + -16:word32];
		ecx += edi * 0x02;
	}
	Mem0[0x080838E0<p32>:word32] = ecx;
	esp += 0x08;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AD48: define caml_deserialize_block_4
// Called from:
//      caml_deserialize_float_4
define caml_deserialize_block_4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x04;
	ecx = Mem0[ebp + 8:word32];
	edx = Mem0[0x080838E0<p32>:word32];
	SCZO = cond(Mem0[ebp + 0x0C:word32] - 0x00);
	if (Test(GT,SZO))
	{
		ebx = Mem0[ebp + 0x0C:word32];
		eax = 0x00;
		Mem0[ebp + -16:word32] = ebx;
		do
		{
			edi = CONVERT(Mem0[edx + eax:byte], byte, word32);
			esi = CONVERT(Mem0[edx + 1 + eax:byte], byte, word32);
			ebx = CONVERT(Mem0[edx + 3 + eax:byte], byte, word32);
			Mem0[ecx + eax:byte] = bl;
			ebx = CONVERT(Mem0[edx + 2 + eax:byte], byte, word32);
			Mem0[ecx + 1 + eax:byte] = bl;
			ebx = edi;
			Mem0[ecx + 3 + eax:byte] = bl;
			ebx = esi;
			Mem0[ecx + 2 + eax:byte] = bl;
			eax += 0x04;
			v14 = Mem0[ebp + -16:word32] - 0x01;
			Mem0[ebp + -16:word32] = v14;
			SCZO = cond(v14);
		} while (Test(NE,Z));
		eax = Mem0[ebp + 0x0C:word32];
		edx += eax * 0x04;
	}
	Mem0[0x080838E0<p32>:word32] = edx;
	esp += 0x04;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806ADAE: define caml_deserialize_float_4
define caml_deserialize_float_4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = 0x01;
	eax = ebp - 4;
	Mem0[esp + 0x00:word32] = eax;
	caml_deserialize_block_4();
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -4:real32], real32, real64);
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806ADCC: define caml_deserialize_block_8
// Called from:
//      caml_deserialize_sint_8
//      caml_deserialize_uint_8
define caml_deserialize_block_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x08;
	edi = Mem0[0x080838E0<p32>:word32];
	SCZO = cond(Mem0[ebp + 0x0C:word32] - 0x00);
	if (Test(GT,SZO))
	{
		edx = Mem0[ebp + 8:word32];
		eax = edi;
		ecx = Mem0[ebp + 0x0C:word32];
		Mem0[ebp + -20:word32] = ecx;
		Mem0[ebp + -16:word32] = edi;
		do
		{
			esi = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
			ebx = CONVERT(Mem0[eax + 1:byte], byte, word32);
			edi = CONVERT(Mem0[eax + 7:byte], byte, word32);
			ecx = edi;
			Mem0[edx + 0x00:byte] = cl;
			edi = CONVERT(Mem0[eax + 6:byte], byte, word32);
			ecx = edi;
			Mem0[edx + 1:byte] = cl;
			ecx = esi;
			Mem0[edx + 7:byte] = cl;
			Mem0[edx + 6:byte] = bl;
			esi = CONVERT(Mem0[eax + 2:byte], byte, word32);
			ebx = CONVERT(Mem0[eax + 3:byte], byte, word32);
			edi = CONVERT(Mem0[eax + 5:byte], byte, word32);
			ecx = edi;
			Mem0[edx + 2:byte] = cl;
			edi = CONVERT(Mem0[eax + 4:byte], byte, word32);
			ecx = edi;
			Mem0[edx + 3:byte] = cl;
			ecx = esi;
			Mem0[edx + 5:byte] = cl;
			Mem0[edx + 4:byte] = bl;
			eax += 0x08;
			edx += 0x08;
			v15 = Mem0[ebp + -20:word32] - 0x01;
			Mem0[ebp + -20:word32] = v15;
			SCZO = cond(v15);
		} while (Test(NE,Z));
		edi = Mem0[ebp + -16:word32];
		eax = Mem0[ebp + 0x0C:word32];
		edi += eax * 0x08;
	}
	Mem0[0x080838E0<p32>:word32] = edi;
	esp += 0x08;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AE54: define caml_deserialize_sint_8
// Called from:
//      int64_deserialize
define caml_deserialize_sint_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = 0x01;
	eax = ebp - 8;
	Mem0[esp + 0x00:word32] = eax;
	caml_deserialize_block_8();
	eax = Mem0[ebp + -8:word32];
	edx = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AE75: define caml_deserialize_uint_8
define caml_deserialize_uint_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = 0x01;
	eax = ebp - 8;
	Mem0[esp + 0x00:word32] = eax;
	caml_deserialize_block_8();
	eax = Mem0[ebp + -8:word32];
	edx = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AE96: define caml_marshal_data_size
define caml_marshal_data_size
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	edx = Mem0[ebp + 0x0C:word32];
	edx >>= 0x01;
	edx += Mem0[ebp + 8:word32];
	Mem0[0x080838E8<p32>:word32] = 0x00;
	eax = edx + 4;
	Mem0[0x080838E0<p32>:word32] = eax;
	ecx = CONVERT(Mem0[eax + -1:byte], byte, word32);
	edx = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
	edx <<= 0x18;
	edx = ecx + edx;
	ecx = CONVERT(Mem0[eax + -3:byte], byte, word32);
	ecx <<= 0x10;
	edx += ecx;
	ecx = CONVERT(Mem0[eax + -2:byte], byte, word32);
	ecx <<= 0x08;
	edx += ecx;
	SCZO = cond(edx - 2224400062);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071D08;
		caml_failwith();
	}
	eax += 0x04;
	Mem0[0x080838E0<p32>:word32] = eax;
	ecx = CONVERT(Mem0[eax + -4:byte], byte, word32);
	ecx <<= 0x18;
	edx = CONVERT(Mem0[eax + -1:byte], byte, word32);
	ecx += edx;
	edx = CONVERT(Mem0[eax + -3:byte], byte, word32);
	edx <<= 0x10;
	ecx += edx;
	edx = CONVERT(Mem0[eax + -2:byte], byte, word32);
	edx <<= 0x08;
	SCZO = cond(edx);
	eax = ecx + edx;
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AF17: define intern_cleanup
// Called from:
//      caml_deserialize_error
//      intern_rec
define intern_cleanup
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(Mem0[0x080838E8<p32>:word32] - 0x00);
	if (Test(NE,Z))
	{
		eax = Mem0[0x080838E4<p32>:word32];
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_free();
	}
	eax = Mem0[0x080838F8<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_free();
	}
	eax = Mem0[0x080838F0<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_free_for_heap();
	}
	else
	{
		eax = Mem0[0x08083904<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			edx = Mem0[0x08083900<p32>:word32];
			Mem0[eax + -4:word32] = edx;
		}
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AF6B: define caml_deserialize_error
// Called from:
//      nativeint_deserialize
define caml_deserialize_error
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	intern_cleanup();
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_failwith();
	caml_deserialize_block_float_8();
}

// 0806AF81: define caml_deserialize_block_float_8
// Called from:
//      caml_deserialize_error
//      caml_deserialize_float_8
define caml_deserialize_block_float_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 0x0C:word32];
	ebx <<= 0x03;
	Mem0[esp + 8:word32] = ebx;
	eax = Mem0[0x080838E0<p32>:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	v8 = Mem0[0x080838E0<p32>:word32] + ebx;
	Mem0[0x080838E0<p32>:word32] = v8;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AFB2: define caml_deserialize_float_8
define caml_deserialize_float_8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	SCZO = cond(esp);
	Mem0[esp + 4:word32] = 0x01;
	eax = ebp - 16;
	Mem0[esp + 0x00:word32] = eax;
	caml_deserialize_block_float_8();
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -16:real64];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AFD0: define caml_deserialize_block_1
define caml_deserialize_block_1
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 8:word32] = ebx;
	eax = Mem0[0x080838E0<p32>:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	v8 = Mem0[0x080838E0<p32>:word32] + ebx;
	Mem0[0x080838E0<p32>:word32] = v8;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806AFFE: define caml_code_checksum
// Called from:
//      extern_rec
define caml_code_checksum
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 116;
	SCZO = cond(Mem0[0x080838CC<p32>:word32] - 0x00);
	if (Test(EQ,Z))
	{
		ebx = ebp - 96;
		Mem0[esp + 0x00:word32] = ebx;
		caml_MD5Init();
		eax = Mem0[0x080839E0<p32>:word32];
		edx = Mem0[0x08083A9C<p32>:word32];
		edx -= eax;
		SCZO = cond(edx);
		Mem0[esp + 8:word32] = edx;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = ebx;
		caml_MD5Update();
		Mem0[esp + 4:word32] = ebx;
		Mem0[esp + 0x00:word32] = 0x080838D0;
		caml_MD5Final();
		Mem0[0x080838CC<p32>:word32] = 0x01;
	}
	eax = 0x080838D0;
	esp += 116;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806B05B: define intern_alloc
// Called from:
//      input_val_from_block
//      caml_input_val_from_string
//      caml_input_val
define intern_alloc
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = edx;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[0x080838F8<p32>:word32] = 0x00;
		Mem0[0x080838F0<p32>:word32] = 0x00;
		Mem0[0x08083904<p32>:word32] = 0x00;
	}
	else
	{
		edx = eax - 1;
		SCZO = cond(edx - 0x003FFFFF);
		if (Test(UGT,CZ))
		{
			eax = 0x0FFF + eax * 0x04;
			eax &= ~0x0FFF;
			SZ = cond(eax);
			O = false;
			C = false;
			Mem0[esp + 0x00:word32] = eax;
			caml_alloc_for_heap();
			Mem0[0x080838F0<p32>:word32] = eax;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				caml_raise_out_of_memory();
			Mem0[esp + 0x00:word32] = eax;
			caml_allocation_color();
			Mem0[0x080838FC<p32>:word32] = eax;
			eax = Mem0[0x080838F0<p32>:word32];
			Mem0[0x080838EC<p32>:word32] = eax;
		}
		else
		{
			SZP = cond(edx & edx);
			O = false;
			C = false;
			if (Test(EQ,Z))
				Mem0[0x08083904<p32>:word32] = 0x08083E94;
			else
			{
				SCZO = cond(edx - 0x0100);
				if (Test(ULE,CZ))
				{
					Mem0[esp + 4:word32] = 252;
					Mem0[esp + 0x00:word32] = edx;
					caml_alloc_small();
					Mem0[0x08083904<p32>:word32] = eax;
				}
				else
				{
					Mem0[esp + 4:word32] = 252;
					Mem0[esp + 0x00:word32] = edx;
					caml_alloc_shr();
					Mem0[0x08083904<p32>:word32] = eax;
				}
			}
			eax = Mem0[0x08083904<p32>:word32];
			eax -= 0x04;
			edx = Mem0[eax + 0x00:word32];
			Mem0[0x08083900<p32>:word32] = edx;
			edx &= 0x0300;
			SZ = cond(edx);
			O = false;
			C = false;
			Mem0[0x080838FC<p32>:word32] = edx;
			Mem0[0x080838EC<p32>:word32] = eax;
			Mem0[0x080838F0<p32>:word32] = 0x00;
		}
		Mem0[0x080838F4<p32>:word32] = 0x00;
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			ebx <<= 0x02;
			SCZO = cond(ebx);
			Mem0[esp + 0x00:word32] = ebx;
			caml_stat_alloc();
			Mem0[0x080838F8<p32>:word32] = eax;
		}
		else
			Mem0[0x080838F8<p32>:word32] = 0x00;
	}
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806B170: define intern_rec
// Called from:
//      intern_rec
//      input_val_from_block
//      caml_input_val_from_string
//      caml_input_val
define intern_rec
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	SCZO = cond(esp);
	Mem0[ebp + -60:word32] = eax;
	esi = 134684324;
	while (true)
	{
		eax = Mem0[0x080838E0<p32>:word32];
		edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
		ebx = CONVERT(dl, byte, word32);
		++eax;
		Mem0[0x080838E0<p32>:word32] = eax;
		SCZO = cond(ebx - 0x3F);
		if (Test(ULE,CZ))
			break;
		SCZO = cond(ebx - 0x7F);
		if (Test(ULE,CZ))
		{
			ebx &= 0x3F;
			SZ = cond(ebx);
			O = false;
			C = false;
			esi = ebx + 1 + ebx;
			goto l0806B7C9;
		}
		edx = ebx;
		edx &= 0x0F;
		ebx >>= 0x04;
		ebx &= 0x07;
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			esi = 0x08083AA4 + edx * 0x04;
			goto l0806B7C9;
		}
		ecx = Mem0[0x080838EC<p32>:word32];
		ecx += 0x04;
		eax = Mem0[ebp + -60:word32];
		Mem0[eax + 0x00:word32] = ecx;
		eax = Mem0[0x080838F8<p32>:word32];
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			edi = Mem0[0x080838F4<p32>:word32];
			eax[edi * 0x04] = ecx;
			++edi;
			SCZO = cond(edi);
			Mem0[0x080838F4<p32>:word32] = edi;
		}
		eax = Mem0[0x080838EC<p32>:word32];
		ecx = eax + 4;
		Mem0[ebp + -60:word32] = ecx;
		edx += Mem0[0x080838FC<p32>:word32];
		ecx = ebx;
		ecx <<= 0x0A;
		edx += ecx;
		Mem0[eax + 0x00:word32] = edx;
		eax = 0x04 + ebx * 0x04;
		v22 = Mem0[0x080838EC<p32>:word32] + eax;
		Mem0[0x080838EC<p32>:word32] = v22;
		SCZO = cond(ebx - 0x01);
		if (Test(UGT,CZ))
		{
			edi = ebx;
			eax = Mem0[ebp + -60:word32];
			Mem0[ebp + -64:word32] = eax;
			do
			{
				eax = Mem0[ebp + -64:word32];
				intern_rec();
				--edi;
				v23 = Mem0[ebp + -64:word32] + 0x04;
				Mem0[ebp + -64:word32] = v23;
				SCZO = cond(edi - 0x01);
			} while (Test(UGT,CZ));
			edx = Mem0[ebp + -60:word32];
			edx = edx - 4 + ebx * 0x04;
			Mem0[ebp + -60:word32] = edx;
		}
	}
	SCZO = cond(ebx - 0x1F);
	if (Test(UGT,CZ))
	{
		ebx &= 0x1F;
		eax = ebx + 4;
		eax >>= 0x02;
		edi = Mem0[0x080838EC<p32>:word32];
		edi += 0x04;
		esi = edi;
		edx = Mem0[0x080838F8<p32>:word32];
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			ecx = Mem0[0x080838F4<p32>:word32];
			edx[ecx * 0x04] = edi;
			++ecx;
			SCZO = cond(ecx);
			Mem0[0x080838F4<p32>:word32] = ecx;
		}
		edx = eax;
		edx <<= 0x0A;
		ecx = Mem0[0x080838FC<p32>:word32];
		ecx = ecx + 252 + edx;
		edx = Mem0[0x080838EC<p32>:word32];
		Mem0[edx + 0x00:word32] = ecx;
		edx = 0x04 + eax * 0x04;
		v19 = Mem0[0x080838EC<p32>:word32] + edx;
		Mem0[0x080838EC<p32>:word32] = v19;
		eax <<= 0x02;
		Mem0[esi - 4 + eax:word32] = 0x00;
		--eax;
		edx = eax;
		dl -= bl;
		Mem0[eax + esi:byte] = dl;
		Mem0[esp + 8:word32] = ebx;
		eax = Mem0[0x080838E0<p32>:word32];
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = edi;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		v21 = Mem0[0x080838E0<p32>:word32] + ebx;
		Mem0[0x080838E0<p32>:word32] = v21;
		SCZO = cond(v21);
	}
	else
	{
		SCZO = cond(dl - 0x13);
		if (Test(ULE,CZ))
		{
			edx = CONVERT(dl, byte, word32);
			esi[edx * 0x04]();
			return;
		}
		intern_cleanup();
		Mem0[esp + 0x00:word32] = 134684140;
		caml_failwith();
	}
l0806B7C9:
	ecx = Mem0[ebp + -60:word32];
	Mem0[ecx + 0x00:word32] = esi;
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806B7D6: define intern_add_to_heap
// Called from:
//      input_val_from_block
//      caml_input_val_from_string
//      caml_input_val
define intern_add_to_heap
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	edx = Mem0[0x080838F0<p32>:word32];
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax = 0x0FFF + eax * 0x04;
		eax &= ~0x0FFF;
		edx += eax;
		eax = Mem0[0x080838EC<p32>:word32];
		SCZO = cond(edx - eax);
		if (Test(UGT,CZ))
		{
			Mem0[esp + 8:word32] = 0x00;
			edx -= eax;
			SCZO = cond(edx);
			edx >>= 0x02;
			SCZ = cond(edx);
			Mem0[esp + 4:word32] = edx;
			Mem0[esp + 0x00:word32] = eax;
			caml_make_free_blocks();
		}
		eax = Mem0[0x080838F0<p32>:word32];
		edx = Mem0[0x080838EC<p32>:word32];
		edx -= eax;
		edx >>= 0x02;
		v15 = Mem0[0x08083FE8<p32>:word32] + edx;
		Mem0[0x08083FE8<p32>:word32] = v15;
		SCZO = cond(v15);
		Mem0[esp + 0x00:word32] = eax;
		caml_add_to_heap();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806B836: define input_val_from_block
// Called from:
//      caml_input_value_from_block
//      caml_input_value_from_malloc
define input_val_from_block
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x20;
	eax = Mem0[0x080838E0<p32>:word32];
	ecx = eax + 4;
	ebx = CONVERT(Mem0[ecx + -1:byte], byte, word32);
	edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
	edx <<= 0x18;
	edx = ebx + edx;
	ebx = CONVERT(Mem0[ecx + -3:byte], byte, word32);
	ebx <<= 0x10;
	edx += ebx;
	ecx = CONVERT(Mem0[ecx + -2:byte], byte, word32);
	ecx <<= 0x08;
	edx += ecx;
	ecx = eax + 8;
	ebx = CONVERT(Mem0[ecx + -4:byte], byte, word32);
	ebx <<= 0x18;
	esi = CONVERT(Mem0[ecx + -1:byte], byte, word32);
	ebx += esi;
	esi = CONVERT(Mem0[ecx + -3:byte], byte, word32);
	esi <<= 0x10;
	ebx += esi;
	ecx = CONVERT(Mem0[ecx + -2:byte], byte, word32);
	ecx <<= 0x08;
	ebx += ecx;
	eax += 0x0C;
	SCZO = cond(eax);
	Mem0[0x080838E0<p32>:word32] = eax;
	eax = ebx;
	intern_alloc();
	eax = ebp - 0x0C;
	intern_rec();
	eax = ebx;
	intern_add_to_heap();
	eax = Mem0[0x080838F8<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_free();
	}
	eax = Mem0[ebp + -0x0C:word32];
	esp += 0x20;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806B8C0: define caml_input_value_from_block
define caml_input_value_from_block
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	edx = Mem0[ebp + 8:word32];
	Mem0[0x080838E4<p32>:word32] = edx;
	Mem0[0x080838E8<p32>:word32] = 0x00;
	eax = edx + 4;
	Mem0[0x080838E0<p32>:word32] = eax;
	ecx = CONVERT(Mem0[eax + -1:byte], byte, word32);
	edx = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
	edx <<= 0x18;
	edx = ecx + edx;
	ecx = CONVERT(Mem0[eax + -3:byte], byte, word32);
	ecx <<= 0x10;
	edx += ecx;
	ecx = CONVERT(Mem0[eax + -2:byte], byte, word32);
	ecx <<= 0x08;
	edx += ecx;
	SCZO = cond(edx - 2224400062);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071E0C;
		caml_failwith();
	}
	eax += 0x04;
	Mem0[0x080838E0<p32>:word32] = eax;
	ecx = CONVERT(Mem0[eax + -1:byte], byte, word32);
	edx = CONVERT(Mem0[eax + -4:byte], byte, word32);
	edx <<= 0x18;
	edx = ecx + 20 + edx;
	ecx = CONVERT(Mem0[eax + -3:byte], byte, word32);
	ecx <<= 0x10;
	ecx = edx + ecx;
	edx = CONVERT(Mem0[eax + -2:byte], byte, word32);
	edx <<= 0x08;
	eax = ecx + edx;
	SCZO = cond(eax - Mem0[ebp + 0x0C:word32]);
	if (Test(UGT,CZ))
	{
		Mem0[esp + 0x00:word32] = 0x08071E30;
		caml_failwith();
	}
	input_val_from_block();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806B957: define caml_input_value_from_malloc
define caml_input_value_from_malloc
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	edx = Mem0[ebp + 8:word32];
	Mem0[0x080838E4<p32>:word32] = edx;
	edx += Mem0[ebp + 0x0C:word32];
	Mem0[0x080838E8<p32>:word32] = 0x01;
	eax = edx + 4;
	Mem0[0x080838E0<p32>:word32] = eax;
	ecx = CONVERT(Mem0[eax + -1:byte], byte, word32);
	edx = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
	edx <<= 0x18;
	edx = ecx + edx;
	ecx = CONVERT(Mem0[eax + -3:byte], byte, word32);
	ecx <<= 0x10;
	edx += ecx;
	ecx = CONVERT(Mem0[eax + -2:byte], byte, word32);
	ecx <<= 0x08;
	edx += ecx;
	SCZO = cond(edx - 2224400062);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071E5C;
		caml_failwith();
	}
	eax += 0x04;
	SCZO = cond(eax);
	Mem0[0x080838E0<p32>:word32] = eax;
	input_val_from_block();
	ebx = eax;
	eax = Mem0[0x080838E4<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_free();
	eax = ebx;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806B9D3: define caml_input_val_from_string
// Called from:
//      caml_input_value_from_string
define caml_input_val_from_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = ebx;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	Mem0[ebp + -60:word32] = 0x00;
	eax = ebp - 56;
	Mem0[ebp + -92:word32] = eax;
	eax = ebp - 92;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -84:word32] = 0x01;
	Mem0[ebp + -88:word32] = 0x01;
	esi = ebp - 60;
	Mem0[ebp + -80:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	eax = edx + 8 + eax;
	Mem0[0x080838E8<p32>:word32] = 0x00;
	ecx = eax + 4;
	edi = CONVERT(Mem0[ecx + -1:byte], byte, word32);
	edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
	edx <<= 0x18;
	edx = edi + edx;
	edi = CONVERT(Mem0[ecx + -3:byte], byte, word32);
	edi <<= 0x10;
	edi = edx + edi;
	edx = CONVERT(Mem0[ecx + -2:byte], byte, word32);
	edx <<= 0x08;
	edx = edi + edx;
	ecx = eax + 8;
	edi = CONVERT(Mem0[ecx + -4:byte], byte, word32);
	edi <<= 0x18;
	Mem0[ebp + -0x006C:word32] = edi;
	edi = CONVERT(Mem0[ecx + -1:byte], byte, word32);
	edi += Mem0[ebp + -0x006C:word32];
	Mem0[ebp + -0x006C:word32] = edi;
	edi = CONVERT(Mem0[ecx + -3:byte], byte, word32);
	edi <<= 0x10;
	edi += Mem0[ebp + -0x006C:word32];
	ecx = CONVERT(Mem0[ecx + -2:byte], byte, word32);
	ecx <<= 0x08;
	edi += ecx;
	eax += 0x0C;
	SCZO = cond(eax);
	Mem0[0x080838E0<p32>:word32] = eax;
	eax = edi;
	intern_alloc();
	eax = Mem0[ebp + 8:word32];
	edx = Mem0[ebp + 0x0C:word32];
	eax = edx + 20 + eax;
	Mem0[0x080838E0<p32>:word32] = eax;
	eax = esi;
	intern_rec();
	eax = edi;
	intern_add_to_heap();
	eax = Mem0[0x080838F8<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_free();
	}
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -60:word32];
	esp += 0x7C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BAD2: define caml_input_value_from_string
define caml_input_value_from_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_input_val_from_string();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BAEE: define caml_input_val
// Called from:
//      caml_input_value
define caml_input_val
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x3C;
	SCZO = cond(esp);
	ebx = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = ebx;
	caml_channel_binary_mode();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071E80;
		caml_failwith();
	}
	Mem0[esp + 0x00:word32] = ebx;
	caml_getword();
	SCZO = cond(eax - 2224400062);
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = 0x08071D41;
		caml_failwith();
	}
	Mem0[esp + 0x00:word32] = ebx;
	caml_getword();
	edi = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_getword();
	Mem0[ebp + -48:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_getword();
	Mem0[ebp + -44:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_getword();
	Mem0[esp + 0x00:word32] = edi;
	caml_stat_alloc();
	esi = eax;
	Mem0[esp + 8:word32] = edi;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_really_getblock();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = esi;
		caml_stat_free();
		Mem0[esp + 0x00:word32] = 134683993;
		caml_failwith();
	}
	Mem0[0x080838E4<p32>:word32] = esi;
	Mem0[0x080838E8<p32>:word32] = 0x01;
	Mem0[0x080838E0<p32>:word32] = esi;
	edx = Mem0[ebp + -48:word32];
	eax = Mem0[ebp + -44:word32];
	intern_alloc();
	eax = ebp - 28;
	intern_rec();
	eax = Mem0[ebp + -44:word32];
	intern_add_to_heap();
	eax = Mem0[0x080838E4<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_free();
	eax = Mem0[0x080838F8<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_stat_free();
	}
	eax = Mem0[ebp + -28:word32];
	esp += 0x3C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BBE1: define caml_input_value
define caml_input_value
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x60;
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	eax = ebp - 40;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x01;
	edx = ebp + 8;
	Mem0[ebp + -28:word32] = edx;
	edx = Mem0[ebp + 8:word32];
	ebx = Mem0[edx + 4:word32];
	Mem0[ebp + -44:word32] = 0x00;
	Mem0[ebp + -76:word32] = eax;
	eax = ebp - 76;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -0x0044:word32] = 0x01;
	Mem0[ebp + -72:word32] = 0x01;
	eax = ebp - 44;
	Mem0[ebp + -64:word32] = eax;
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[esp + 0x00:word32] = ebx;
	caml_input_val();
	Mem0[ebp + -44:word32] = eax;
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		eax();
	}
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = Mem0[ebp + -44:word32];
	esp += 0x60;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BC80: define caml_hash_variant
define caml_hash_variant
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	edx = Mem0[ebp + 8:word32];
	eax = 0x01;
	SCZO = cond(Mem0[edx + 0x00:byte] - 0x00);
	while (Test(NE,Z))
	{
		eax >>= 0x01;
		eax *= 223;
		ecx = CONVERT(Mem0[edx + 0x00:byte], byte, word32);
		eax += ecx;
		eax = eax + 1 + eax;
		++edx;
		SCZO = cond(Mem0[edx + 0x00:byte] - 0x00);
	}
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BCAB: define hash_aux
// Called from:
//      hash_aux
//      caml_hash_univ_param
define hash_aux
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	esi = eax;
	edx = Mem0[0x0808390C<p32>:word32];
	--edx;
	Mem0[0x0808390C<p32>:word32] = edx;
	eax = Mem0[0x08083910<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NS,S))
	{
		SZP = cond(edx & edx);
		O = false;
		C = false;
		if (Test(NS,S))
		{
			SZP = cond(esi & 0x01);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				ebx = esi;
				ecx = esi;
				ecx >>= 0x17;
				edx = esi;
				edx >>= 0x0C;
				edx &= 0x07FF;
				ecx = 0x08084000[ecx * 0x04];
				SZP = cond(Mem0[ecx + edx:byte] & 0x07);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
l0806BED5:
					eax = Mem0[0x08083908<p32>:word32] *s 65599;
					ebx += eax;
					SCZO = cond(ebx);
					Mem0[0x08083908<p32>:word32] = ebx;
				}
				else
				{
l0806BD4A:
					ecx = ebx - 4;
					edx = CONVERT(Mem0[ecx + 0x00:byte], byte, word32);
					edi = CONVERT(dl, byte, word32);
					Mem0[ebp + -28:word32] = edi;
					edx += 0x08;
					v21 = dl;
					SCZO = cond(dl - 0x07);
					if (Test(ULE,CZ))
					{
						edx = CONVERT(dl, byte, word32);
						switch (v21)
						{
						case 0x00:
							--eax;
							Mem0[0x08083910<p32>:word32] = eax;
							eax = Mem0[ebx + 4:word32];
							eax >>= 0x01;
							edx = Mem0[0x08083908<p32>:word32] *s 65599;
							eax += edx;
							SCZO = cond(eax);
							Mem0[0x08083908<p32>:word32] = eax;
							break;
						case 0x01:
							eax = Mem0[ecx + 0x00:word32];
							eax >>= 0x0A;
							eax <<= 0x02;
							ebx -= eax;
							SCZO = cond(ebx);
							eax = ebx;
							hash_aux();
							break;
						case 0x02:
							esi = Mem0[esi + 0x00:word32];
							SZP = cond(esi & 0x01);
							O = false;
							C = false;
							if (Test(EQ,Z))
							{
								ebx = esi;
								ecx = esi;
								ecx >>= 0x17;
								edx = esi;
								edx >>= 0x0C;
								edx &= 0x07FF;
								ecx = 0x08084000[ecx * 0x04];
								SZP = cond(Mem0[ecx + edx:byte] & 0x07);
								O = false;
								C = false;
								if (Test(NE,Z))
									goto l0806BD4A;
								goto l0806BED5;
							}
							else
							{
								esi = esi;
								goto l0806BD06;
							}
						case 0x03:
							break;
						case 0x04:
							--eax;
							SCZO = cond(eax);
							Mem0[0x08083910<p32>:word32] = eax;
							Mem0[esp + 0x00:word32] = esi;
							caml_string_length();
							SZP = cond(eax & eax);
							O = false;
							C = false;
							if (Test(NE,Z))
							{
								edx = Mem0[0x08083908<p32>:word32];
								do
								{
									ecx = edx + edx * 0x08;
									ecx = edx + ecx * 0x02;
									edx = CONVERT(Mem0[esi + 0x00:byte], byte, word32);
									edx = ecx + edx;
									++esi;
									--eax;
									SCZO = cond(eax);
								} while (Test(NE,Z));
								Mem0[0x08083908<p32>:word32] = edx;
							}
							break;
						case 0x05:
							--eax;
							SCZO = cond(eax);
							Mem0[0x08083910<p32>:word32] = eax;
							eax = Mem0[0x08083908<p32>:word32];
							ecx = esi + 8;
							do
							{
								edx = eax + eax * 0x08;
								edx = eax + edx * 0x02;
								eax = CONVERT(Mem0[esi + 0x00:byte], byte, word32);
								eax = edx + eax;
								++esi;
								SCZO = cond(esi - ecx);
							} while (Test(NE,Z));
							Mem0[0x08083908<p32>:word32] = eax;
							break;
						case 0x06:
							--eax;
							Mem0[0x08083910<p32>:word32] = eax;
							eax = Mem0[ecx + 0x00:word32];
							eax >>= 0x0A;
							eax <<= 0x02;
							Mem0[ebp + -28:word32] = eax;
							SZP = cond(eax & eax);
							O = false;
							C = false;
							if (Test(NE,Z))
							{
								edx = Mem0[0x08083908<p32>:word32];
								esi = 0x00;
								do
								{
									eax = ebx;
									ebx += 0x08;
									SCZO = cond(ebx);
									ecx = ebx;
									do
									{
										edi = edx + edx * 0x08;
										edi = edx + edi * 0x02;
										edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
										edx = edi + edx;
										++eax;
										SCZO = cond(ecx - eax);
									} while (Test(NE,Z));
									esi += 0x08;
									SCZO = cond(esi - Mem0[ebp + -28:word32]);
								} while (Test(ULT,C));
								Mem0[0x08083908<p32>:word32] = edx;
							}
							break;
						case 0x07:
							edx = Mem0[esi + 0x00:word32];
							edx = Mem0[edx + 0x0C:word32];
							SZP = cond(edx & edx);
							O = false;
							C = false;
							if (Test(NE,Z))
							{
								--eax;
								Mem0[0x08083910<p32>:word32] = eax;
								ebx = Mem0[0x08083908<p32>:word32] *s 65599;
								SCZO = cond(ebx);
								Mem0[esp + 0x00:word32] = esi;
								edx();
								ebx = eax + ebx;
								Mem0[0x08083908<p32>:word32] = ebx;
							}
							break;
						}
					}
					else
					{
						--eax;
						Mem0[0x08083910<p32>:word32] = eax;
						eax = Mem0[0x08083908<p32>:word32];
						edx = eax + eax * 0x08;
						eax += edx * 0x02;
						eax += Mem0[ebp + -28:word32];
						Mem0[0x08083908<p32>:word32] = eax;
						esi = Mem0[ecx + 0x00:word32];
						esi >>= 0x0A;
						SZP = cond(esi & esi);
						O = false;
						C = false;
						while (Test(NE,Z))
						{
							--esi;
							SCZO = cond(esi);
							eax = ebx[esi * 0x04];
							hash_aux();
							SZP = cond(esi & esi);
							O = false;
							C = false;
						}
					}
				}
			}
			else
			{
l0806BD06:
				--eax;
				Mem0[0x08083910<p32>:word32] = eax;
				esi >>= 0x01;
				eax = Mem0[0x08083908<p32>:word32] *s 65599;
				SCZO = cond(eax);
				eax = esi + eax;
				Mem0[0x08083908<p32>:word32] = eax;
			}
		}
	}
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BEEF: define caml_hash_univ_param
// Called from:
//      camlHashtbl__hash_1031
//      camlHashtbl__add_1074
//      camlHashtbl__remove_1080
//      camlHashtbl__find_1093
//      camlHashtbl__find_all_1105
//      camlHashtbl__replace_1112
//      camlHashtbl__mem_1122
define caml_hash_univ_param
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[0x0808390C<p32>:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[0x08083910<p32>:word32] = eax;
	Mem0[0x08083908<p32>:word32] = 0x00;
	eax = Mem0[ebp + 16:word32];
	hash_aux();
	eax = Mem0[0x08083908<p32>:word32];
	eax &= 0x3FFFFFFF;
	SZ = cond(eax);
	O = false;
	C = false;
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BF30: define caml_sys_init
// Called from:
//      caml_main
define caml_sys_init
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	Mem0[0x08084804<p32>:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[0x08083914<p32>:word32] = eax;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BF45: define caml_sys_get_config
define caml_sys_get_config
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x44;
	SCZO = cond(esp);
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -0x0C:word32] = 0x00;
	Mem0[ebp + -16:word32] = 0x00;
	Mem0[ebp + -48:word32] = ebx;
	eax = ebp - 48;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -40:word32] = 0x01;
	Mem0[ebp + -44:word32] = 0x02;
	eax = ebp - 0x0C;
	Mem0[ebp + -36:word32] = eax;
	eax = ebp - 16;
	Mem0[ebp + -32:word32] = eax;
	Mem0[esp + 0x00:word32] = 134684436;
	caml_copy_string();
	Mem0[ebp + -16:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	Mem0[ebp + -0x0C:word32] = eax;
	edx = Mem0[ebp + -16:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = Mem0[ebp + -0x0C:word32];
	Mem0[eax + 4:word32] = 0x41;
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -0x0C:word32];
	esp += 0x44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806BFC9: define caml_sys_get_argv
define caml_sys_get_argv
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x44;
	SCZO = cond(esp);
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -0x0C:word32] = 0x00;
	Mem0[ebp + -16:word32] = 0x00;
	Mem0[ebp + -20:word32] = 0x00;
	Mem0[ebp + -52:word32] = ebx;
	eax = ebp - 52;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -44:word32] = 0x01;
	Mem0[ebp + -48:word32] = 0x03;
	eax = ebp - 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = ebp - 16;
	Mem0[ebp + -36:word32] = eax;
	eax = ebp - 20;
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[0x08084804<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	Mem0[ebp + -0x0C:word32] = eax;
	eax = Mem0[0x08083914<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string_array();
	Mem0[ebp + -16:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x02;
	caml_alloc_small();
	Mem0[ebp + -20:word32] = eax;
	edx = Mem0[ebp + -0x0C:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[ebp + -16:word32];
	eax = Mem0[ebp + -20:word32];
	Mem0[eax + 4:word32] = edx;
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -20:word32];
	esp += 0x44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C06A: define caml_sys_random_seed
define caml_sys_random_seed
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	Mem0[esp + 4:word32] = 0x00;
	eax = ebp - 32;
	Mem0[esp + 0x00:word32] = eax;
	eax = gettimeofday(Mem0[esp + 0x00:(ptr32 (struct "timeval"))], Mem0[esp + 4:(ptr32 (struct "timezone"))]);
	esi = Mem0[ebp + -32:word32];
	ebx = Mem0[ebp + -28:word32];
	getppid();
	edi = eax;
	eax = getpid();
	ebx = ebx ^ esi;
	ebx = ebx ^ eax;
	edx = edi;
	edx <<= 0x10;
	edi = ebx;
	edi = edi ^ edx;
	SZ = cond(edi);
	O = false;
	C = false;
	eax = edi + 1 + edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C0BC: define caml_sys_time
define caml_sys_time
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x68;
	SCZO = cond(esp);
	eax = ebp - 80;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x00;
	getrusage();
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -80:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -76:int32], int32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[0x08071188<p32>:real32], real32, real64);
	ST[Top + 1:real64] /= ST[Top + 0x00:real64];
	v8 = ST[Top + 0x00:real64];
	ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = v8;
	ST[Top + 2:real64] += ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -72:int32], int32, real64);
	ST[Top + 2:real64] += ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -0x0044:int32], int32, real64);
	ST[Top + 1:real64] = ST[Top + 0x00:real64] / ST[Top + 1:real64];
	++Top;
	ST[Top + 1:real64] += ST[Top + 0x00:real64];
	++Top;
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C0FD: define caml_sys_getenv
define caml_sys_getenv
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = getenv(Mem0[esp + 0x00:(ptr32 char)]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
		caml_raise_not_found();
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C121: define caml_sys_file_exists
define caml_sys_file_exists
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	SCZO = cond(esp);
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x03;
	__xstat64();
	SCZO = cond(eax - 0x01);
	eax = eax - eax - C;
	eax &= 0x02;
	++eax;
	SCZO = cond(eax);
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C14E: define caml_sys_close
define caml_sys_close
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	eax = close(Mem0[esp + 0x00:int32]);
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C168: define caml_sys_exit
// Called from:
//      main
define caml_sys_exit
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	exit(Mem0[esp + 0x00:int32]);
}

// 0806C17B: define caml_sys_error
// Called from:
//      caml_install_signal_handler
//      caml_ml_pos_in
//      caml_ml_pos_out
//      caml_channel_descriptor
//      caml_ml_close_channel
//      caml_seek_in
//      caml_channel_size
//      caml_ml_channel_size
//      caml_seek_out
//      caml_sys_read_directory
//      caml_sys_system_command
//      caml_sys_getcwd
//      caml_sys_chdir
//      caml_sys_rename
//      caml_sys_remove
//      caml_sys_is_directory
//      caml_sys_open
//      caml_sys_io_error
define caml_sys_error
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x6C;
	eax = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	Mem0[ebp + -60:word32] = 0x00;
	eax = ebp - 56;
	Mem0[ebp + -92:word32] = eax;
	eax = ebp - 92;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -84:word32] = 0x01;
	Mem0[ebp + -88:word32] = 0x01;
	eax = ebp - 60;
	Mem0[ebp + -80:word32] = eax;
	eax = __errno_location();
	eax = Mem0[eax + 0x00:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = strerror(Mem0[esp + 0x00:int32]);
	esi = eax;
	edx = Mem0[ebp + 8:word32];
	SCZO = cond(edx - 0x01);
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = eax;
		caml_copy_string();
		Mem0[ebp + -60:word32] = eax;
	}
	else
	{
		edi = eax;
		eax = 0x00;
		ecx = ~0x00;
		size = strlen(edi) + 1;
		ecx -= size;
		SCZO = cond(0x00);
		ecx = ~ecx;
		edi = ecx - 1;
		Mem0[esp + 0x00:word32] = edx;
		caml_string_length();
		ebx = eax;
		eax = eax + 2 + edi;
		Mem0[esp + 0x00:word32] = eax;
		caml_alloc_string();
		Mem0[ebp + -60:word32] = eax;
		Mem0[esp + 8:word32] = ebx;
		edx = Mem0[ebp + 8:word32];
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		eax = ebx;
		eax += Mem0[ebp + -60:word32];
		SCZO = cond(eax);
		Mem0[eax + 0x00:word16] = 0x203A;
		Mem0[esp + 8:word32] = edi;
		Mem0[esp + 4:word32] = esi;
		eax = Mem0[ebp + -60:word32];
		eax = ebx + 2 + eax;
		Mem0[esp + 0x00:word32] = eax;
		eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	}
	eax = Mem0[ebp + -60:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_raise_sys_error();
	caml_sys_read_directory();
}

// 0806C25A: define caml_sys_read_directory
// Called from:
//      caml_sys_error
define caml_sys_read_directory
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x60;
	SCZO = cond(esp);
	esi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = esi;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	Mem0[ebp + -44:word32] = 0x00;
	eax = ebp - 40;
	Mem0[ebp + -76:word32] = eax;
	eax = ebp - 76;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -0x0044:word32] = 0x01;
	Mem0[ebp + -72:word32] = 0x01;
	eax = ebp - 44;
	Mem0[ebp + -64:word32] = eax;
	Mem0[esp + 4:word32] = 0x32;
	ebx = ebp - 88;
	Mem0[esp + 0x00:word32] = ebx;
	caml_ext_table_init();
	Mem0[esp + 4:word32] = ebx;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_read_directory();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 4:word32] = 0x01;
		Mem0[esp + 0x00:word32] = ebx;
		caml_ext_table_free();
		eax = Mem0[ebp + 8:word32];
		Mem0[esp + 0x00:word32] = eax;
		caml_sys_error();
	}
	Mem0[esp + 4:word32] = 0x00;
	ebx = ebp - 88;
	Mem0[esp + 0x00:word32] = ebx;
	caml_ext_table_add();
	eax = Mem0[ebp + -80:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string_array();
	Mem0[ebp + -44:word32] = eax;
	Mem0[esp + 4:word32] = 0x01;
	Mem0[esp + 0x00:word32] = ebx;
	caml_ext_table_free();
	Mem0[0x0807D294<p32>:word32] = esi;
	eax = Mem0[ebp + -44:word32];
	esp += 0x60;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C32B: define caml_sys_system_command
define caml_sys_system_command
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x48;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	edi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = edi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x01;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	esi = eax + 1;
	Mem0[esp + 0x00:word32] = esi;
	caml_stat_alloc();
	ebx = eax;
	Mem0[esp + 8:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
	caml_enter_blocking_section();
	Mem0[esp + 0x00:word32] = ebx;
	eax = system(Mem0[esp + 0x00:(ptr32 char)]);
	esi = eax;
	caml_leave_blocking_section();
	Mem0[esp + 0x00:word32] = ebx;
	caml_stat_free();
	SCZO = cond(esi - ~0x00);
	if (Test(EQ,Z))
	{
		eax = Mem0[ebp + 8:word32];
		Mem0[esp + 0x00:word32] = eax;
		caml_sys_error();
		eax = 0xFF;
	}
	else
	{
		eax = 0xFF;
		SZP = cond(esi & 0x7F);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			edx = esi;
			eax = CONVERT(dh, byte, word32);
		}
	}
	Mem0[0x0807D294<p32>:word32] = edi;
	eax = eax + 1 + eax;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C3E6: define caml_sys_getcwd
define caml_sys_getcwd
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x1018;
	Mem0[esp + 4:word32] = 0x1000;
	eax = ebp + ~0x1007;
	Mem0[esp + 0x00:word32] = eax;
	eax = getcwd(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:size_t]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = 0x01;
		caml_sys_error();
	}
	eax = ebp + ~0x1007;
	Mem0[esp + 0x00:word32] = eax;
	caml_copy_string();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C425: define caml_sys_chdir
define caml_sys_chdir
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SCZO = cond(esp);
	ebx = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = ebx;
	chdir();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_sys_error();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C44E: define caml_sys_rename
define caml_sys_rename
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	rename();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = 0x01;
		caml_sys_error();
	}
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C47D: define caml_sys_remove
define caml_sys_remove
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	ebx = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = ebx;
	eax = unlink(Mem0[esp + 0x00:(ptr32 char)]);
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_sys_error();
	}
	eax = 0x01;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C4A6: define caml_sys_is_directory
define caml_sys_is_directory
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 116;
	SCZO = cond(esp);
	ebx = Mem0[ebp + 8:word32];
	eax = ebp - 0x0068;
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 0x00:word32] = 0x03;
	__xstat64();
	SCZO = cond(eax - ~0x00);
	if (Test(EQ,Z))
	{
		Mem0[esp + 0x00:word32] = ebx;
		caml_sys_error();
	}
	eax = Mem0[ebp + -88:word32];
	eax &= 0xF000;
	SCZO = cond(eax - 0x4000);
	al = CONVERT(Test(EQ,Z), bool, int8);
	eax = CONVERT(al, byte, word32);
	eax = eax + 1 + eax;
	esp += 116;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C4F1: define caml_sys_open
define caml_sys_open
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x4C;
	SCZO = cond(esp);
	edi = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = edi;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x03;
	eax = ebp + 8;
	Mem0[ebp + -44:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = ebp + 16;
	Mem0[ebp + -36:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_string_length();
	++eax;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_stat_alloc();
	ebx = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	Mem0[esp + 4:word32] = 0x0807D080;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_convert_flag_list();
	esi = eax;
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[ebp + -60:word32] = eax;
	caml_enter_blocking_section();
	eax = Mem0[ebp + -60:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = esi;
	Mem0[esp + 0x00:word32] = ebx;
	eax = open64(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:int32]);
	esi = eax;
	SCZO = cond(eax - ~0x00);
	if (Test(NE,Z))
	{
		Mem0[esp + 8:word32] = 0x01;
		Mem0[esp + 4:word32] = 0x02;
		Mem0[esp + 0x00:word32] = eax;
		eax = fcntl(Mem0[esp + 0x00:int32], Mem0[esp + 4:int32]);
		caml_leave_blocking_section();
		Mem0[esp + 0x00:word32] = ebx;
		caml_stat_free();
	}
	else
	{
		caml_leave_blocking_section();
		Mem0[esp + 0x00:word32] = ebx;
		esi = esi;
		caml_stat_free();
		eax = Mem0[ebp + 8:word32];
		Mem0[esp + 0x00:word32] = eax;
		caml_sys_error();
	}
	Mem0[0x0807D294<p32>:word32] = edi;
	eax = esi + 1 + esi;
	esp += 0x4C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C5E2: define caml_sys_io_error
// Called from:
//      caml_do_read
//      do_write
define caml_sys_io_error
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = __errno_location();
	SCZO = cond(Mem0[eax + 0x00:word32] - 11);
	if (Test(EQ,Z))
		caml_raise_sys_blocked_io();
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_sys_error();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C604: define caml_set_parser_trace
define caml_set_parser_trace
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x01);
	eax = eax - eax - C;
	eax &= ~0x01;
	eax += 0x03;
	edx = Mem0[ebp + 8:word32];
	edx >>= 0x01;
	SCZ = cond(edx);
	O = false;
	Mem0[0x08083918<p32>:word32] = edx;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C623: define token_name
// Called from:
//      caml_parse_engine
define token_name
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	ebx = eax;
	SZP = cond(edx & edx);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		esi = ~0x00;
		eax = 0x00;
		SCZO = cond(Mem0[ebx + 0x00:byte] - 0x00);
		while (Test(NE,Z))
		{
			edi = ebx;
			ecx = esi;
			size = strlen(edi) + 1;
			ecx -= size;
			edi += size;
			ecx = ~ecx;
			ebx += ecx;
			--edx;
			SZP = cond(edx & edx);
			O = false;
			C = false;
			if (Test(LE,SZO))
				goto l0806C65D;
			SCZO = cond(Mem0[ebx + 0x00:byte] - 0x00);
		}
		ebx = 134684441;
	}
l0806C65D:
	eax = ebx;
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806C664: define caml_parse_engine
define caml_parse_engine
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x3C;
	esi = Mem0[ebp + 8:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	v13 = eax;
	SCZO = cond(eax - 0x05);
	if (Test(ULE,CZ))
	{
		switch (v13)
		{
		case 0x00:
			edi = Mem0[ebx + 52:word32];
			edi >>= 0x01;
			SCZ = cond(edi);
			O = false;
			Mem0[ebp + -36:word32] = 0x00;
			Mem0[ebp + -32:word32] = 0x00;
			break;
		case 0x01:
			edi = Mem0[ebx + 52:word32];
			edi >>= 0x01;
			eax = Mem0[ebx + 56:word32];
			eax >>= 0x01;
			Mem0[ebp + -32:word32] = eax;
			eax = Mem0[ebx + 60:word32];
			eax >>= 0x01;
			Mem0[ebp + -36:word32] = eax;
			eax = Mem0[ebp + 20:word32];
			eax &= 0x01;
			SZ = cond(eax);
			O = false;
			C = false;
			Mem0[ebp + -40:word32] = eax;
			if (Test(EQ,Z))
			{
				ecx = Mem0[ebp + 20:word32];
				edx = CONVERT(Mem0[ecx + -4:byte], byte, word32);
				eax = Mem0[esi + 8:word32];
				eax = eax[edx * 0x04];
				Mem0[ebx + 24:word32] = eax;
				eax = Mem0[ecx + 0x00:word32];
				Mem0[esp + 4:word32] = eax;
				eax = ebx + 28;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
			}
			else
			{
				edx = Mem0[ebp + 20:word32];
				edx >>= 0x01;
				SCZ = cond(edx);
				O = false;
				eax = Mem0[esi + 4:word32];
				eax = eax[edx * 0x04];
				Mem0[ebx + 24:word32] = eax;
				Mem0[esp + 4:word32] = 0x01;
				eax = ebx + 28;
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
			}
			SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x00);
			if (Test(NE,Z))
			{
				SCZO = cond(Mem0[ebp + -40:word32] - 0x00);
				if (Test(NE,Z))
				{
					edx = Mem0[ebp + 20:word32];
					edx >>= 0x01;
					SCZ = cond(edx);
					O = false;
					eax = Mem0[esi + 56:word32];
					token_name();
					Mem0[esp + 0x0C:word32] = eax;
					eax = Mem0[ebp + -32:word32];
					Mem0[esp + 8:word32] = eax;
					Mem0[esp + 4:word32] = 0x08071F29;
					eax = Mem0[0x0807D100<p32>:word32];
					Mem0[esp + 0x00:word32] = eax;
					eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:int32], Mem0[esp + 0x0C:(ptr32 char)]);
				}
				else
				{
					ecx = Mem0[ebp + 20:word32];
					edx = CONVERT(Mem0[ecx + -4:byte], byte, word32);
					eax = Mem0[esi + 60:word32];
					token_name();
					Mem0[esp + 0x0C:word32] = eax;
					eax = Mem0[ebp + -32:word32];
					Mem0[esp + 8:word32] = eax;
					Mem0[esp + 4:word32] = 134684482;
					eax = Mem0[0x0807D100<p32>:word32];
					Mem0[esp + 0x00:word32] = eax;
					eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:int32], Mem0[esp + 0x0C:(ptr32 char)]);
					edx = Mem0[ebp + 20:word32];
					eax = Mem0[edx + 0x00:word32];
					SZP = cond(al & 0x01);
					O = false;
					C = false;
					if (Test(NE,Z))
					{
						eax >>= 0x01;
						SCZ = cond(eax);
						O = false;
						Mem0[esp + 8:word32] = eax;
						Mem0[esp + 4:word32] = 0x08071F5B;
						eax = Mem0[0x0807D100<p32>:word32];
						Mem0[esp + 0x00:word32] = eax;
						eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:int32]);
					}
					else
					{
						edx = CONVERT(Mem0[eax + -4:byte], byte, word32);
						SCZO = cond(dl - 252);
						if (Test(EQ,Z))
						{
							edx = Mem0[0x0807D100<p32>:word32];
							Mem0[esp + 4:word32] = edx;
							Mem0[esp + 0x00:word32] = eax;
							eax = fputs(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 FILE)]);
						}
						else
						{
							SCZO = cond(dl - ~0x02);
							if (Test(EQ,Z))
							{
								--Top;
								ST[Top + 0x00:real64] = Mem0[eax + 0x00:real64];
								Mem0[esp + 8:real64] = ST[Top + 0x00:real64];
								++Top;
								Mem0[esp + 4:word32] = 0x08071F5F;
								eax = Mem0[0x0807D100<p32>:word32];
								Mem0[esp + 0x00:word32] = eax;
								eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:real64]);
							}
							else
							{
								eax = Mem0[0x0807D100<p32>:word32];
								Mem0[esp + 4:word32] = eax;
								Mem0[esp + 0x00:word32] = 0x5F;
								eax = fputc(Mem0[esp + 0x00:int8], Mem0[esp + 4:(ptr32 FILE)]);
							}
						}
					}
					eax = Mem0[0x0807D100<p32>:word32];
					Mem0[esp + 0x0C:word32] = eax;
					Mem0[esp + 8:word32] = 0x02;
					Mem0[esp + 4:word32] = 0x01;
					Mem0[esp + 0x00:word32] = 134684514;
					eax = fwrite(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:size_t], Mem0[esp + 8:size_t], Mem0[esp + 0x0C:(ptr32 FILE)]);
				}
			}
			goto l0806C853;
		case 0x02:
			edi = Mem0[ebx + 52:word32];
			edi >>= 0x01;
			eax = Mem0[ebx + 56:word32];
			eax >>= 0x01;
			Mem0[ebp + -32:word32] = eax;
			eax = Mem0[ebx + 60:word32];
			eax >>= 0x01;
			SCZ = cond(eax);
			O = false;
			Mem0[ebp + -36:word32] = eax;
			goto l0806CACB;
		case 0x03:
			edi = Mem0[ebx + 52:word32];
			edi >>= 0x01;
			eax = Mem0[ebx + 56:word32];
			eax >>= 0x01;
			edx = Mem0[ebx + 60:word32];
			edx >>= 0x01;
			SCZ = cond(edx);
			O = false;
			Mem0[ebp + -36:word32] = edx;
			goto l0806CC04;
		case 0x04:
			edi = Mem0[ebx + 52:word32];
			edi >>= 0x01;
			eax = Mem0[ebx + 56:word32];
			eax >>= 0x01;
			Mem0[ebp + -32:word32] = eax;
			eax = Mem0[ebx + 60:word32];
			eax >>= 0x01;
			Mem0[ebp + -36:word32] = eax;
			ecx = 0x00 + edi * 0x04;
			Mem0[ebp + -40:word32] = ecx;
			edx = Mem0[ebx + 0x00:word32];
			ecx = Mem0[ebp + -32:word32];
			eax = ecx + 1 + ecx;
			ecx = Mem0[ebp + -40:word32];
			Mem0[ecx + edx:word32] = eax;
			eax = Mem0[ebp + 20:word32];
			Mem0[esp + 4:word32] = eax;
			eax = ecx;
			eax += Mem0[ebx + 4:word32];
			SCZO = cond(eax);
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			eax = Mem0[ebx + 40:word32];
			eax >>= 0x01;
			Mem0[ebp + -28:word32] = eax;
			eax <<= 0x02;
			Mem0[ebp + -44:word32] = eax;
			eax = Mem0[ebx + 0x0C:word32];
			ecx = Mem0[ebp + -44:word32];
			edx = Mem0[ecx + eax:word32];
			Mem0[esp + 4:word32] = edx;
			eax += Mem0[ebp + -40:word32];
			SCZO = cond(eax);
			Mem0[esp + 0x00:word32] = eax;
			caml_modify();
			SCZO = cond(edi - Mem0[ebp + -28:word32]);
			if (Test(UGT,CZ))
			{
				eax = Mem0[ebx + 0x0C:word32];
				edx = Mem0[ebp + -44:word32];
				eax = Mem0[edx + eax:word32];
				Mem0[esp + 4:word32] = eax;
				eax = Mem0[ebp + -40:word32];
				eax += Mem0[ebx + 8:word32];
				SCZO = cond(eax);
				Mem0[esp + 0x00:word32] = eax;
				caml_modify();
			}
			break;
		case 0x05:
			edi = Mem0[ebx + 52:word32];
			edi >>= 0x01;
			eax = Mem0[ebx + 56:word32];
			eax >>= 0x01;
			Mem0[ebp + -32:word32] = eax;
			eax = Mem0[ebx + 60:word32];
			eax >>= 0x01;
			SCZ = cond(eax);
			O = false;
			Mem0[ebp + -36:word32] = eax;
			goto l0806C907;
		}
		while (true)
		{
l0806C69B:
			eax = Mem0[esi + 20:word32];
			edx = Mem0[ebp + -32:word32];
			eax = CONVERT(eax[edx * 0x02], word16, int32);
			Mem0[ebp + -28:word32] = eax;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NE,Z))
				goto l0806CB27;
			SCZO = cond(Mem0[ebx + 24:word32] - 0x00);
			if (Test(SG,S))
			{
				eax = edi + 1 + edi;
				Mem0[ebx + 52:word32] = eax;
				eax = edx + 1 + edx;
				Mem0[ebx + 56:word32] = eax;
				ecx = Mem0[ebp + -36:word32];
				eax = ecx + 1 + ecx;
				Mem0[ebx + 60:word32] = eax;
				eax = 0x01;
				goto l0806CCBC;
			}
l0806C853:
			ecx = Mem0[ebp + -32:word32];
			ecx += ecx;
			Mem0[ebp + -40:word32] = ecx;
			eax = Mem0[esi + 28:word32];
			eax = CONVERT(Mem0[eax + ecx:word16], word16, int32);
			ecx = Mem0[ebx + 24:word32];
			ecx >>= 0x01;
			edx = eax + ecx;
			Mem0[ebp + -28:word32] = edx;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NE,Z))
			{
				SZP = cond(edx & edx);
				O = false;
				C = false;
				if (Test(NS,S))
				{
					eax = Mem0[esi + 40:word32];
					eax >>= 0x01;
					SCZO = cond(edx - eax);
					if (Test(LE,SZO))
					{
						eax = Mem0[esi + 48:word32];
						eax = CONVERT(eax[edx * 0x02], word16, int32);
						SCZO = cond(ecx - eax);
						if (Test(EQ,Z))
						{
							Mem0[ebx + 24:word32] = ~0x00;
							SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
							al = CONVERT(Test(GT,SZO), bool, int8);
							eax = CONVERT(al, byte, word32);
							v23 = Mem0[ebp + -36:word32] - eax;
							Mem0[ebp + -36:word32] = v23;
							SCZO = cond(v23);
							goto l0806CA45;
						}
					}
				}
			}
			eax = Mem0[esi + 32:word32];
			edx = Mem0[ebp + -40:word32];
			eax = CONVERT(Mem0[eax + edx:word16], word16, int32);
			edx = eax + ecx;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NE,Z))
			{
				SZP = cond(edx & edx);
				O = false;
				C = false;
				if (Test(NS,S))
				{
					eax = Mem0[esi + 40:word32];
					eax >>= 0x01;
					SCZO = cond(edx - eax);
					if (Test(LE,SZO))
					{
						edx += edx;
						eax = Mem0[esi + 48:word32];
						eax = CONVERT(Mem0[eax + edx:word16], word16, int32);
						SCZO = cond(ecx - eax);
						if (Test(EQ,Z))
						{
							eax = Mem0[esi + 44:word32];
							eax = CONVERT(Mem0[eax + edx:word16], word16, int32);
							Mem0[ebp + -28:word32] = eax;
l0806CB27:
							SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x00);
							if (Test(NE,Z))
							{
								eax = Mem0[ebp + -28:word32];
								Mem0[esp + 0x0C:word32] = eax;
								edx = Mem0[ebp + -32:word32];
								Mem0[esp + 8:word32] = edx;
								Mem0[esp + 4:word32] = 134684646;
								eax = Mem0[0x0807D100<p32>:word32];
								Mem0[esp + 0x00:word32] = eax;
								eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:int32], Mem0[esp + 0x0C:int32]);
							}
							eax = Mem0[ebp + -28:word32];
							eax += eax;
							edx = Mem0[esi + 16:word32];
							edx = CONVERT(Mem0[edx + eax:word16], word16, int32);
							ecx = edi + 1 + edi;
							Mem0[ebx + 40:word32] = ecx;
							ecx = eax + 1;
							Mem0[ebx + 48:word32] = ecx;
							ecx = edx + 1 + edx;
							Mem0[ebx + 44:word32] = ecx;
							++edi;
							edi -= edx;
							edx = Mem0[ebx + 0x00:word32];
							edx = (edx - 4)[edi * 0x04];
							edx >>= 0x01;
							Mem0[ebp + -32:word32] = edx;
							edx = Mem0[esi + 0x0C:word32];
							edx = CONVERT(Mem0[edx + eax:word16], word16, int32);
							edx += edx;
							eax = Mem0[esi + 36:word32];
							eax = CONVERT(Mem0[eax + edx:word16], word16, int32);
							ecx = Mem0[ebp + -32:word32];
							ecx += eax;
							SZP = cond(eax & eax);
							O = false;
							C = false;
							if (Test(NE,Z))
							{
								SZP = cond(ecx & ecx);
								O = false;
								C = false;
								if (Test(NS,S))
								{
									eax = Mem0[esi + 40:word32];
									eax >>= 0x01;
									SCZO = cond(ecx - eax);
									if (Test(LE,SZO))
									{
										ecx += ecx;
										eax = Mem0[esi + 48:word32];
										eax = CONVERT(Mem0[eax + ecx:word16], word16, int32);
										SCZO = cond(eax - Mem0[ebp + -32:word32]);
										if (Test(EQ,Z))
										{
											eax = Mem0[esi + 44:word32];
											eax = CONVERT(Mem0[eax + ecx:word16], word16, int32);
l0806CBC7:
											edx = Mem0[ebx + 16:word32];
											edx >>= 0x01;
											SCZO = cond(edi - edx);
											if (Test(UGE,C))
											{
												edx = edi + 1 + edi;
												Mem0[ebx + 52:word32] = edx;
												eax = eax + 1 + eax;
												Mem0[ebx + 56:word32] = eax;
												ecx = Mem0[ebp + -36:word32];
												eax = ecx + 1 + ecx;
												Mem0[ebx + 60:word32] = eax;
												eax = 0x07;
												goto l0806CCBC;
											}
l0806CC04:
											edx = edi + 1 + edi;
											Mem0[ebx + 52:word32] = edx;
											eax = eax + 1 + eax;
											Mem0[ebx + 56:word32] = eax;
											edx = Mem0[ebp + -36:word32];
											eax = edx + 1 + edx;
											Mem0[ebx + 60:word32] = eax;
											eax = 0x09;
											goto l0806CCBC;
										}
									}
								}
							}
							eax = Mem0[esi + 24:word32];
							eax = CONVERT(Mem0[eax + edx:word16], word16, int32);
							goto l0806CBC7;
						}
					}
				}
			}
			SCZO = cond(Mem0[ebp + -36:word32] - 0x00);
			if (Test(LE,SZO))
			{
				eax = edi + 1 + edi;
				Mem0[ebx + 52:word32] = eax;
				ecx = Mem0[ebp + -32:word32];
				eax = ecx + 1 + ecx;
				Mem0[ebx + 56:word32] = eax;
				edx = Mem0[ebp + -36:word32];
				eax = edx + 1 + edx;
				Mem0[ebx + 60:word32] = eax;
				eax = 11;
				goto l0806CCBC;
			}
l0806C907:
			SCZO = cond(Mem0[ebp + -36:word32] - 0x02);
			if (Test(LE,SZO))
				break;
			eax = Mem0[ebx + 24:word32];
			eax >>= 0x01;
			SCZO = cond(eax);
			if (Test(EQ,Z))
				goto l0806CCB7;
			SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x00);
			if (Test(NE,Z))
			{
				eax = Mem0[0x0807D100<p32>:word32];
				Mem0[esp + 0x0C:word32] = eax;
				Mem0[esp + 8:word32] = 0x1B;
				Mem0[esp + 4:word32] = 0x01;
				Mem0[esp + 0x00:word32] = 0x08071FAD;
				eax = fwrite(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:size_t], Mem0[esp + 8:size_t], Mem0[esp + 0x0C:(ptr32 FILE)]);
			}
			Mem0[ebx + 24:word32] = ~0x00;
		}
		while (true)
		{
			eax = Mem0[ebx + 0x00:word32];
			edx = eax[edi * 0x04];
			edx >>= 0x01;
			eax = Mem0[esi + 28:word32];
			eax = CONVERT(eax[edx * 0x02], word16, int32);
			ecx = eax + 0x0100;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(NE,Z))
			{
				SZP = cond(ecx & ecx);
				O = false;
				C = false;
				if (Test(NS,S))
				{
					eax = Mem0[esi + 40:word32];
					eax >>= 0x01;
					SCZO = cond(ecx - eax);
					if (Test(LE,SZO))
					{
						eax = Mem0[esi + 48:word32];
						SCZO = cond(eax[ecx * 0x02] - 0x0100);
						if (Test(EQ,Z))
						{
							Mem0[ebp + -28:word32] = ecx;
							Mem0[ebp + -36:word32] = 0x03;
							SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x00);
							if (Test(EQ,Z))
								goto l0806CA78;
							Mem0[esp + 8:word32] = edx;
							Mem0[esp + 4:word32] = 0x08071F65;
							eax = Mem0[0x0807D100<p32>:word32];
							Mem0[esp + 0x00:word32] = eax;
							eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:int32]);
							Mem0[ebp + -36:word32] = 0x03;
l0806CA45:
							SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x00);
							if (Test(NE,Z))
							{
								eax = Mem0[esi + 44:word32];
								ecx = Mem0[ebp + -28:word32];
								eax = CONVERT(eax[ecx * 0x02], word16, int32);
								Mem0[esp + 0x0C:word32] = eax;
								eax = Mem0[ebp + -32:word32];
								Mem0[esp + 8:word32] = eax;
								Mem0[esp + 4:word32] = 134684617;
								eax = Mem0[0x0807D100<p32>:word32];
								Mem0[esp + 0x00:word32] = eax;
								eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:int32], Mem0[esp + 0x0C:int32]);
							}
l0806CA78:
							eax = Mem0[esi + 44:word32];
							edx = Mem0[ebp + -28:word32];
							eax = CONVERT(eax[edx * 0x02], word16, int32);
							Mem0[ebp + -32:word32] = eax;
							++edi;
							eax = Mem0[ebx + 16:word32];
							eax >>= 0x01;
							SCZO = cond(edi - eax);
							if (Test(UGE,C))
							{
								eax = edi + 1 + edi;
								Mem0[ebx + 52:word32] = eax;
								ecx = Mem0[ebp + -32:word32];
								eax = ecx + 1 + ecx;
								Mem0[ebx + 56:word32] = eax;
								edx = Mem0[ebp + -36:word32];
								eax = edx + 1 + edx;
								Mem0[ebx + 60:word32] = eax;
								eax = 0x05;
								goto l0806CCBC;
							}
l0806CACB:
							ecx = 0x00 + edi * 0x04;
							Mem0[ebp + -28:word32] = ecx;
							edx = Mem0[ebx + 0x00:word32];
							ecx = Mem0[ebp + -32:word32];
							eax = ecx + 1 + ecx;
							ecx = Mem0[ebp + -28:word32];
							Mem0[ecx + edx:word32] = eax;
							eax = Mem0[ebx + 28:word32];
							Mem0[esp + 4:word32] = eax;
							eax = ecx;
							eax += Mem0[ebx + 4:word32];
							SCZO = cond(eax);
							Mem0[esp + 0x00:word32] = eax;
							caml_modify();
							eax = Mem0[ebx + 32:word32];
							Mem0[esp + 4:word32] = eax;
							eax = Mem0[ebp + -28:word32];
							eax += Mem0[ebx + 8:word32];
							SCZO = cond(eax);
							Mem0[esp + 0x00:word32] = eax;
							caml_modify();
							eax = Mem0[ebx + 36:word32];
							Mem0[esp + 4:word32] = eax;
							eax = Mem0[ebp + -28:word32];
							eax += Mem0[ebx + 0x0C:word32];
							SCZO = cond(eax);
							Mem0[esp + 0x00:word32] = eax;
							caml_modify();
							goto l0806C69B;
						}
					}
				}
			}
			SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x00);
			if (Test(NE,Z))
			{
				Mem0[esp + 8:word32] = edx;
				Mem0[esp + 4:word32] = 0x08071F7D;
				eax = Mem0[0x0807D100<p32>:word32];
				Mem0[esp + 0x00:word32] = eax;
				eax = fprintf(Mem0[esp + 0x00:(ptr32 FILE)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:int32]);
			}
			eax = Mem0[ebx + 20:word32];
			eax >>= 0x01;
			SCZO = cond(edi - eax);
			if (Test(ULE,CZ))
				break;
			--edi;
			SCZO = cond(edi);
		}
		SCZO = cond(Mem0[0x08083918<p32>:word32] - 0x00);
		if (Test(NE,Z))
		{
			eax = Mem0[0x0807D100<p32>:word32];
			Mem0[esp + 0x0C:word32] = eax;
			Mem0[esp + 8:word32] = 0x1A;
			Mem0[esp + 4:word32] = 0x01;
			Mem0[esp + 0x00:word32] = 0x08071F92;
			eax = fwrite(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:size_t], Mem0[esp + 8:size_t], Mem0[esp + 0x0C:(ptr32 FILE)]);
			eax = 0x03;
l0806CCBC:
			esp += 0x3C;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
l0806CCB7:
	eax = 0x03;
	goto l0806CCBC;
}

// 0806CCD0: define norm_pfree
// Called from:
//      caml_init_gc
//      caml_gc_set
define norm_pfree
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	edx = 0x01;
	if (Test(EQ,Z))
		eax = edx;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CCDF: define norm_pmax
// Called from:
//      caml_init_gc
//      caml_gc_set
define norm_pmax
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CCE4: define norm_heapincr
// Called from:
//      caml_init_gc
//      caml_gc_set
define norm_heapincr
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax += 0x03FF;
	eax &= ~0x03FF;
	SCZO = cond(eax - 0x07FF);
	edx = 0x0800;
	if (Test(ULE,CZ))
		eax = edx;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CD00: define norm_minsize
// Called from:
//      caml_init_gc
//      caml_gc_set
define norm_minsize
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	SCZO = cond(eax - 0x0FFF);
	edx = 0x1000;
	if (Test(LE,SZO))
		eax = edx;
	SCZO = cond(eax - 0x10000000);
	edx = 0x10000000;
	if (Test(GT,SZO))
		eax = edx;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CD1F: define caml_init_gc
// Called from:
//      caml_main
define caml_init_gc
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	SCZO = cond(esp);
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	norm_heapincr();
	ebx = 0x00 + eax * 0x04;
	eax = ebx + esi * 0x04;
	Mem0[esp + 0x00:word32] = eax;
	caml_page_table_initialize();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		Mem0[esp + 0x00:word32] = 0x0807201C;
		caml_fatal_error();
	}
	eax = esi;
	norm_minsize();
	eax <<= 0x02;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_set_minor_heap_size();
	eax = Mem0[ebp + 16:word32];
	norm_heapincr();
	eax <<= 0x02;
	SCZO = cond(eax);
	Mem0[0x08083FEC<p32>:word32] = eax;
	eax = Mem0[ebp + 20:word32];
	norm_pfree();
	Mem0[0x08083FD0<p32>:word32] = eax;
	eax = Mem0[ebp + 24:word32];
	norm_pmax();
	Mem0[0x08084808<p32>:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_init_major_heap();
	eax = Mem0[0x08083FF4<p32>:word32];
	eax >>= 0x0A;
	SCZO = cond(eax);
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = 0x08072050;
	Mem0[esp + 0x00:word32] = 0x20;
	caml_gc_message();
	ebx >>= 0x0A;
	SCZO = cond(ebx);
	Mem0[esp + 8:word32] = ebx;
	Mem0[esp + 4:word32] = 0x08072078;
	Mem0[esp + 0x00:word32] = 0x20;
	caml_gc_message();
	eax = Mem0[0x08083FD0<p32>:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = 0x080720A0;
	Mem0[esp + 0x00:word32] = 0x20;
	caml_gc_message();
	eax = Mem0[0x08084808<p32>:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = 0x080721BD;
	Mem0[esp + 0x00:word32] = 0x20;
	caml_gc_message();
	eax = Mem0[0x08083FEC<p32>:word32];
	eax >>= 0x0A;
	SCZO = cond(eax);
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = 0x080720C0;
	Mem0[esp + 0x00:word32] = 0x20;
	caml_gc_message();
	eax = Mem0[0x0807F424<p32>:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = 0x080720E4;
	Mem0[esp + 0x00:word32] = 0x20;
	caml_gc_message();
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CE51: define caml_gc_compaction
define caml_gc_compaction
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 134685146;
	Mem0[esp + 0x00:word32] = 0x10;
	caml_gc_message();
	caml_empty_minor_heap();
	caml_finish_major_cycle();
	esi = esi;
	caml_final_do_calls();
	caml_empty_minor_heap();
	caml_finish_major_cycle();
	caml_compact_heap();
	caml_final_do_calls();
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CEA1: define test_and_compact
// Called from:
//      caml_gc_full_major
//      caml_gc_major
define test_and_compact
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	eax = Mem0[0x0807F420<p32>:word32];
	ecx = 0x00;
	Mem0[ebp + -24:word32] = eax;
	Mem0[ebp + -20:word32] = ecx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -24:int64], int64, real64);
	ST[Top + 0x00:real64] *= CONVERT(Mem0[0x0807225C<p32>:real32], real32, real64);
	edx = Mem0[0x08083940<p32>:word32];
	edx >>= 0x02;
	edx -= eax;
	eax = edx;
	edx = 0x00;
	Mem0[ebp + -24:word32] = eax;
	Mem0[ebp + -20:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -24:int64], int64, real64);
	ST[Top + 1:real64] /= ST[Top + 0x00:real64];
	++Top;
	Mem0[ebp + -32:real32] = CONVERT(ST[Top + 0x00:real64], real64, real32);
	++Top;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[0x08072260<p32>:real32], real32, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -32:real32], real32, real64);
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	if (Test(GT,CZ))
		ST[Top + 0x00:real64] = ST[Top + 1:real64];
	ST[Top + 1:real64] = ST[Top + 0x00:real64];
	++Top;
	Mem0[ebp + -32:real32] = CONVERT(ST[Top + 0x00:real64], real64, real32);
	Mem0[ebp + -26:word16] = __fstcw();
	eax = CONVERT(Mem0[ebp + -26:word16], word16, word32);
	ah = 0x0C;
	Mem0[ebp + -28:word16] = ax;
	__fldcw(Mem0[ebp + -28:word16]);
	Mem0[ebp + -24:int64] = CONVERT(ST[Top + 0x00:real64], real64, int64);
	++Top;
	__fldcw(Mem0[ebp + -26:word16]);
	eax = Mem0[ebp + -24:word32];
	Mem0[esp + 8:word32] = eax;
	Mem0[esp + 4:word32] = 0x08072104;
	Mem0[esp + 0x00:word32] = 0x0200;
	caml_gc_message();
	eax = Mem0[0x08084808<p32>:word32];
	edx = 0x00;
	Mem0[ebp + -24:word32] = eax;
	Mem0[ebp + -20:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -24:int64], int64, real64);
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -32:real32], real32, real64);
	CZP = cond(ST[Top + 0x00:real64] - ST[Top + 1:real64]);
	O = false;
	S = false;
	++Top;
	ST[Top + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	if (Test(UGE,C))
	{
		SCZO = cond(Mem0[0x0808394C<p32>:word32] - 0x01);
		if (Test(GT,SZO))
		{
			Mem0[esp + 8:word32] = 0x00;
			Mem0[esp + 4:word32] = 0x08072130;
			Mem0[esp + 0x00:word32] = 0x0200;
			caml_gc_message();
			caml_compact_heap();
		}
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CF6B: define caml_gc_full_major
define caml_gc_full_major
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x08072154;
	Mem0[esp + 0x00:word32] = 0x01;
	caml_gc_message();
	caml_empty_minor_heap();
	caml_finish_major_cycle();
	caml_final_do_calls();
	esi = esi;
	caml_empty_minor_heap();
	caml_finish_major_cycle();
	test_and_compact();
	caml_final_do_calls();
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CFBC: define caml_gc_major
define caml_gc_major
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 8:word32] = 0x00;
	Mem0[esp + 4:word32] = 0x080721F5;
	Mem0[esp + 0x00:word32] = 0x01;
	caml_gc_message();
	caml_empty_minor_heap();
	caml_finish_major_cycle();
	test_and_compact();
	esi = esi;
	caml_final_do_calls();
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806CFFC: define caml_gc_major_slice
define caml_gc_major_slice
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	caml_empty_minor_heap();
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	Mem0[esp + 0x00:word32] = eax;
	caml_major_collection_slice();
	eax = eax + 1 + eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D01A: define caml_gc_minor
define caml_gc_minor
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	caml_minor_collection();
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D02C: define caml_gc_set
define caml_gc_set
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	esi = Mem0[ebp + 8:word32];
	ebx = esi;
	eax = Mem0[esi + 0x0C:word32];
	eax >>= 0x01;
	Mem0[0x0807F400<p32>:word32] = eax;
	eax = Mem0[esi + 8:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	norm_pfree();
	SCZO = cond(eax - Mem0[0x08083FD0<p32>:word32]);
	if (Test(NE,Z))
	{
		Mem0[0x08083FD0<p32>:word32] = eax;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x0807220F;
		Mem0[esp + 0x00:word32] = 0x20;
		caml_gc_message();
	}
	eax = Mem0[ebx + 16:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	norm_pmax();
	SCZO = cond(eax - Mem0[0x08084808<p32>:word32]);
	if (Test(NE,Z))
	{
		Mem0[0x08084808<p32>:word32] = eax;
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x08072229;
		Mem0[esp + 0x00:word32] = 0x20;
		caml_gc_message();
	}
	eax = Mem0[ebx + 4:word32];
	eax >>= 0x01;
	SCZ = cond(eax);
	O = false;
	norm_heapincr();
	eax <<= 0x02;
	SCZO = cond(eax - Mem0[0x08083FEC<p32>:word32]);
	if (Test(NE,Z))
	{
		Mem0[0x08083FEC<p32>:word32] = eax;
		eax >>= 0x0A;
		SCZO = cond(eax);
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x08072174;
		Mem0[esp + 0x00:word32] = 0x20;
		caml_gc_message();
	}
	ebx = Mem0[ebx + 24:word32];
	ebx >>= 0x01;
	SCZO = cond(ebx - 0x02);
	eax = 0x01;
	if (Test(UGE,C))
		ebx = eax;
	SCZO = cond(ebx - Mem0[0x0807F424<p32>:word32]);
	if (Test(NE,Z))
	{
		Mem0[esp + 8:word32] = ebx;
		Mem0[esp + 4:word32] = 0x08072241;
		Mem0[esp + 0x00:word32] = 0x20;
		caml_gc_message();
		Mem0[esp + 0x00:word32] = ebx;
		caml_set_allocation_policy();
	}
	eax = Mem0[esi + 0x00:word32];
	eax >>= 0x01;
	eax <<= 0x02;
	SCZO = cond(eax);
	norm_minsize();
	ebx = eax;
	SCZO = cond(eax - Mem0[0x08083FF4<p32>:word32]);
	if (Test(NE,Z))
	{
		eax >>= 0x0A;
		SCZO = cond(eax);
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x0807219C;
		Mem0[esp + 0x00:word32] = 0x20;
		caml_gc_message();
		Mem0[esp + 0x00:word32] = ebx;
		caml_set_minor_heap_size();
	}
	eax = 0x01;
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D153: define caml_gc_get
define caml_gc_get
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x44;
	SCZO = cond(esp);
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -0x0C:word32] = 0x00;
	Mem0[ebp + -44:word32] = ebx;
	eax = ebp - 44;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -36:word32] = 0x01;
	Mem0[ebp + -40:word32] = 0x01;
	eax = ebp - 0x0C;
	Mem0[ebp + -32:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x07;
	caml_alloc_tuple();
	Mem0[ebp + -0x0C:word32] = eax;
	edx = Mem0[0x08083FF4<p32>:word32];
	edx >>= 0x02;
	SCZO = cond(edx);
	edx = edx + 1 + edx;
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = Mem0[0x08083FEC<p32>:word32];
	eax >>= 0x02;
	eax = eax + 1 + eax;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x04;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = Mem0[0x08083FD0<p32>:word32];
	eax = eax + 1 + eax;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x08;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = Mem0[0x0807F400<p32>:word32];
	eax = eax + 1 + eax;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x0C;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = Mem0[0x08084808<p32>:word32];
	eax = eax + 1 + eax;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x10;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[esp + 4:word32] = 0x01;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x14;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = Mem0[0x0807F424<p32>:word32];
	eax = eax + 1 + eax;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x18;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -0x0C:word32];
	esp += 0x44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D25D: define caml_gc_counters
define caml_gc_counters
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 100;
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -0x0C:word32] = 0x00;
	Mem0[ebp + -44:word32] = ebx;
	eax = ebp - 44;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -36:word32] = 0x01;
	Mem0[ebp + -40:word32] = 0x01;
	eax = ebp - 0x0C;
	Mem0[ebp + -32:word32] = eax;
	eax = Mem0[0x08080410<p32>:word32];
	eax -= Mem0[0x08080414<p32>:word32];
	eax >>= 0x02;
	SCZO = cond(eax);
	edx = 0x00;
	Mem0[ebp + -64:word32] = eax;
	Mem0[ebp + -60:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -64:int64], int64, real64);
	ST[Top + 0x00:real64] += Mem0[0x08083920<p32>:real64];
	Mem0[ebp + -88:real64] = ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = Mem0[0x08083928<p32>:real64];
	Mem0[ebp + -80:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = Mem0[0x08083FE8<p32>:word32];
	edx = 0x00;
	Mem0[ebp + -64:word32] = eax;
	Mem0[ebp + -60:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -64:int64], int64, real64);
	ST[Top + 0x00:real64] += Mem0[0x08083930<p32>:real64];
	Mem0[ebp + -72:real64] = ST[Top + 0x00:real64];
	++Top;
	Mem0[esp + 0x00:word32] = 0x03;
	caml_alloc_tuple();
	Mem0[ebp + -0x0C:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -88:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -80:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x04;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -72:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -0x0C:word32];
	eax += 0x08;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -0x0C:word32];
	esp += 100;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D34C: define caml_gc_quick_stat
define caml_gc_quick_stat
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -28:word32] = 0x00;
	Mem0[ebp + -60:word32] = ebx;
	eax = ebp - 60;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -52:word32] = 0x01;
	Mem0[ebp + -56:word32] = 0x01;
	eax = ebp - 28;
	Mem0[ebp + -48:word32] = eax;
	eax = Mem0[0x08080410<p32>:word32];
	eax -= Mem0[0x08080414<p32>:word32];
	eax >>= 0x02;
	edx = 0x00;
	Mem0[ebp + -80:word32] = eax;
	Mem0[ebp + -76:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -80:int64], int64, real64);
	ST[Top + 0x00:real64] += Mem0[0x08083920<p32>:real64];
	Mem0[ebp + -0x0078:real64] = ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = Mem0[0x08083928<p32>:real64];
	Mem0[ebp + -112:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = Mem0[0x08083FE8<p32>:word32];
	edx = 0x00;
	Mem0[ebp + -80:word32] = eax;
	Mem0[ebp + -76:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -80:int64], int64, real64);
	ST[Top + 0x00:real64] += Mem0[0x08083930<p32>:real64];
	Mem0[ebp + -0x0068:real64] = ST[Top + 0x00:real64];
	++Top;
	esi = Mem0[0x08083938<p32>:word32];
	edi = Mem0[0x0808393C<p32>:word32];
	eax = Mem0[0x08083940<p32>:word32];
	eax >>= 0x02;
	Mem0[ebp + -96:word32] = eax;
	eax = Mem0[0x08083944<p32>:word32];
	eax >>= 0x02;
	SCZO = cond(eax);
	Mem0[ebp + -92:word32] = eax;
	eax = Mem0[0x08083948<p32>:word32];
	Mem0[ebp + -88:word32] = eax;
	edx = Mem0[0x0808394C<p32>:word32];
	Mem0[ebp + -84:word32] = edx;
	Mem0[esp + 0x00:word32] = 0x10;
	caml_alloc_tuple();
	Mem0[ebp + -28:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -0x0078:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -112:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x04;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -0x0068:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x08;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = esi + 1 + esi;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x0C;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = edi + 1 + edi;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x10;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edx = Mem0[ebp + -96:word32];
	eax = edx + 1 + edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x14;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edx = Mem0[ebp + -84:word32];
	eax = edx + 1 + edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x18;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[esp + 4:word32] = 0x01;
	eax = Mem0[ebp + -28:word32];
	eax += 0x1C;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[esp + 4:word32] = 0x01;
	eax = Mem0[ebp + -28:word32];
	eax += 0x20;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[esp + 4:word32] = 0x01;
	eax = Mem0[ebp + -28:word32];
	eax += 0x24;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[esp + 4:word32] = 0x01;
	eax = Mem0[ebp + -28:word32];
	eax += 0x28;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[esp + 4:word32] = 0x01;
	eax = Mem0[ebp + -28:word32];
	eax += 44;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[esp + 4:word32] = 0x01;
	eax = Mem0[ebp + -28:word32];
	eax += 0x30;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edx = Mem0[ebp + -88:word32];
	eax = edx + 1 + edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x34;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edx = Mem0[ebp + -92:word32];
	eax = edx + 1 + edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x38;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	caml_stack_usage();
	eax = eax + 1 + eax;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x3C;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	Mem0[0x0807D294<p32>:word32] = ebx;
	eax = Mem0[ebp + -28:word32];
	esp += 0x7C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D5A1: define caml_gc_stat
define caml_gc_stat
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x9C;
	eax = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -0x0084:word32] = eax;
	eax = Mem0[0x08083FD8<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		Mem0[ebp + -0x006C:word32] = 0x00;
		esi = 0x00;
		Mem0[ebp + -92:word32] = 0x00;
		Mem0[ebp + -88:word32] = 0x00;
		Mem0[ebp + -84:word32] = 0x00;
		ebx = 0x00;
		Mem0[ebp + -112:word32] = 0x00;
	}
	else
	{
		edx = Mem0[0x08083FDC<p32>:word32];
		Mem0[ebp + -0x0078:word32] = edx;
		ecx = Mem0[0x08083FCC<p32>:word32];
		Mem0[ebp + -0x0080:word32] = ecx;
		Mem0[ebp + -0x006C:word32] = 0x00;
		esi = 0x00;
		Mem0[ebp + -92:word32] = 0x00;
		Mem0[ebp + -88:word32] = 0x00;
		Mem0[ebp + -84:word32] = 0x00;
		ebx = 0x00;
		Mem0[ebp + -112:word32] = 0x00;
		do
		{
			v16 = Mem0[ebp + -112:word32] + 0x01;
			Mem0[ebp + -112:word32] = v16;
			edi = eax - 16;
			Mem0[ebp + -0x0068:word32] = edi;
			edi = eax;
			edx = Mem0[ebp + -0x0068:word32];
			edi += Mem0[edx + 8:word32];
			SCZO = cond(edi - eax);
			if (Test(UGT,CZ))
			{
				Mem0[ebp + -0x008C:word32] = edi;
				do
				{
					edx = Mem0[eax + 0x00:word32];
					ecx = edx;
					ecx &= 0x0300;
					SCZO = cond(ecx - 0x0100);
					if (Test(NE,Z))
					{
						SCZO = cond(ecx - 0x0100);
						if (Test(ULE,CZ))
						{
							SZP = cond(ecx & ecx);
							O = false;
							C = false;
							if (Test(NE,Z))
								goto l0806D701;
							ecx = edx;
							ecx >>= 0x0A;
							Mem0[ebp + -0x0088:word32] = ecx;
							SZP = cond(ecx & ecx);
							O = false;
							C = false;
							if (Test(EQ,Z))
							{
								v20 = Mem0[ebp + -0x006C:word32] + 0x01;
								Mem0[ebp + -0x006C:word32] = v20;
								SCZO = cond(v20);
								goto l0806D701;
							}
							SCZO = cond(Mem0[ebp + -0x0078:word32] - 0x01);
							if (Test(EQ,Z))
							{
								SCZO = cond(Mem0[ebp + -0x0080:word32] - eax);
								if (Test(UGT,CZ))
									goto l0806D6C5;
								v22 = Mem0[ebp + -92:word32] + 0x01;
								Mem0[ebp + -92:word32] = v22;
								ecx = Mem0[ebp + -0x0088:word32];
								edi = Mem0[ebp + -88:word32];
								edi = ecx + 1 + edi;
								Mem0[ebp + -88:word32] = edi;
								++ecx;
								SCZO = cond(ecx - esi);
								if (Test(UGT,CZ))
									esi = ecx;
							}
							else
							{
l0806D6C5:
								v24 = Mem0[ebp + -84:word32] + 0x01;
								Mem0[ebp + -84:word32] = v24;
								SCZO = cond(v24);
								ecx = Mem0[ebp + -0x0088:word32];
								ebx = ecx + 1 + ebx;
							}
							goto l0806D701;
						}
						SCZO = cond(ecx - 0x0200);
						if (Test(NE,Z))
						{
							SCZO = cond(ecx - 0x0300);
							if (Test(EQ,Z))
								goto l0806D6D5;
						}
						else
						{
							v21 = Mem0[ebp + -92:word32] + 0x01;
							Mem0[ebp + -92:word32] = v21;
							edi = edx;
							edi >>= 0x0A;
							ecx = Mem0[ebp + -88:word32];
							ecx = edi + 1 + ecx;
							Mem0[ebp + -88:word32] = ecx;
							ecx = edi;
							++ecx;
							SCZO = cond(ecx - esi);
							if (Test(UGT,CZ))
								esi = ecx;
						}
					}
					else
					{
l0806D6D5:
						v23 = Mem0[ebp + -84:word32] + 0x01;
						Mem0[ebp + -84:word32] = v23;
						ecx = edx;
						ecx >>= 0x0A;
						SCZO = cond(ecx);
						ebx = ebx + 1 + ecx;
					}
l0806D701:
					edx >>= 0x0A;
					eax = eax + 4 + edx * 0x04;
					SCZO = cond(Mem0[ebp + -0x008C:word32] - eax);
				} while (Test(UGT,CZ));
			}
			edi = Mem0[ebp + -0x0068:word32];
			eax = Mem0[edi + 0x0C:word32];
			SZP = cond(eax & eax);
			O = false;
			C = false;
		} while (Test(NE,Z));
	}
	Mem0[ebp + -28:word32] = 0x00;
	eax = Mem0[ebp + -0x0084:word32];
	Mem0[ebp + -60:word32] = eax;
	eax = ebp - 60;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -52:word32] = 0x01;
	Mem0[ebp + -56:word32] = 0x01;
	eax = ebp - 28;
	Mem0[ebp + -48:word32] = eax;
	eax = Mem0[0x08080410<p32>:word32];
	eax -= Mem0[0x08080414<p32>:word32];
	eax >>= 0x02;
	edx = 0x00;
	Mem0[ebp + -80:word32] = eax;
	Mem0[ebp + -76:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -80:int64], int64, real64);
	ST[Top + 0x00:real64] += Mem0[0x08083920<p32>:real64];
	Mem0[ebp + -0x0068:real64] = ST[Top + 0x00:real64];
	++Top;
	--Top;
	ST[Top + 0x00:real64] = Mem0[0x08083928<p32>:real64];
	Mem0[ebp + -0x0078:real64] = ST[Top + 0x00:real64];
	++Top;
	eax = Mem0[0x08083FE8<p32>:word32];
	edx = 0x00;
	Mem0[ebp + -80:word32] = eax;
	Mem0[ebp + -76:word32] = edx;
	--Top;
	ST[Top + 0x00:real64] = CONVERT(Mem0[ebp + -80:int64], int64, real64);
	ST[Top + 0x00:real64] += Mem0[0x08083930<p32>:real64];
	Mem0[ebp + -0x0080:real64] = ST[Top + 0x00:real64];
	++Top;
	edi = Mem0[0x08083938<p32>:word32];
	eax = Mem0[0x0808393C<p32>:word32];
	Mem0[ebp + -0x0088:word32] = eax;
	eax = Mem0[0x08083940<p32>:word32];
	eax >>= 0x02;
	Mem0[ebp + -0x008C:word32] = eax;
	edx = Mem0[0x08083948<p32>:word32];
	Mem0[ebp + -144:word32] = edx;
	eax = Mem0[0x08083944<p32>:word32];
	eax >>= 0x02;
	SCZO = cond(eax);
	Mem0[ebp + -0x0094:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x10;
	caml_alloc_tuple();
	Mem0[ebp + -28:word32] = eax;
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -0x0068:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -0x0078:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x04;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	--Top;
	ST[Top + 0x00:real64] = Mem0[ebp + -0x0080:real64];
	Mem0[esp + 0x00:real64] = ST[Top + 0x00:real64];
	++Top;
	caml_copy_double();
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x08;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = edi + 1 + edi;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x0C;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edx = Mem0[ebp + -0x0088:word32];
	eax = edx + 1 + edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x10;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	ecx = Mem0[ebp + -0x008C:word32];
	eax = ecx + 1 + ecx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x14;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edi = Mem0[ebp + -112:word32];
	eax = edi + 1 + edi;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x18;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = ebx + 1 + ebx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x1C;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edx = Mem0[ebp + -84:word32];
	eax = edx + 1 + edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x20;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	ecx = Mem0[ebp + -88:word32];
	eax = ecx + 1 + ecx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x24;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edi = Mem0[ebp + -92:word32];
	eax = edi + 1 + edi;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x28;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = esi + 1 + esi;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 44;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edx = Mem0[ebp + -0x006C:word32];
	eax = edx + 1 + edx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x30;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	ecx = Mem0[ebp + -144:word32];
	eax = ecx + 1 + ecx;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x34;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	edi = Mem0[ebp + -0x0094:word32];
	eax = edi + 1 + edi;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x38;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	caml_stack_usage();
	eax = eax + 1 + eax;
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	eax += 0x3C;
	SCZO = cond(eax);
	Mem0[esp + 0x00:word32] = eax;
	caml_modify();
	eax = Mem0[ebp + -0x0084:word32];
	Mem0[0x0807D294<p32>:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	esp += 0x9C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D998: define caml_MD5Init
// Called from:
//      caml_code_checksum
//      caml_md5_chan
//      caml_md5_string
define caml_MD5Init
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 8:word32];
	Mem0[eax + 0x00:word32] = 0x67452301;
	Mem0[eax + 4:word32] = 4023233417;
	Mem0[eax + 8:word32] = 2562383102;
	Mem0[eax + 0x0C:word32] = 271733878;
	Mem0[eax + 16:word32] = 0x00;
	Mem0[eax + 20:word32] = 0x00;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806D9C9: define caml_MD5Transform
// Called from:
//      caml_MD5Final
//      caml_MD5Update
define caml_MD5Transform
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 88;
	eax = Mem0[ebp + 0x0C:word32];
	edx = Mem0[ebp + 8:word32];
	edx = Mem0[edx + 0x00:word32];
	Mem0[ebp + -92:word32] = edx;
	ecx = Mem0[ebp + 8:word32];
	ecx += 0x04;
	Mem0[ebp + -84:word32] = ecx;
	esi = Mem0[ecx + 0x00:word32];
	ebx = Mem0[ebp + 8:word32];
	ebx += 0x08;
	Mem0[ebp + -80:word32] = ebx;
	ecx = Mem0[ebx + 0x00:word32];
	edi = Mem0[ebp + 8:word32];
	edi += 0x0C;
	Mem0[ebp + -76:word32] = edi;
	edx = Mem0[edi + 0x00:word32];
	ebx = Mem0[eax + 0x00:word32];
	Mem0[ebp + -72:word32] = ebx;
	edi = Mem0[ebp + -92:word32];
	edi = edi + 3614090360 + ebx;
	ebx = edx;
	ebx = ebx ^ ecx;
	ebx &= esi;
	ebx = ebx ^ edx;
	ebx += edi;
	v15 = (ebx & 0x01 << 0x19) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x19);
	ebx += esi;
	edi = Mem0[eax + 4:word32];
	Mem0[ebp + -0x0044:word32] = edi;
	edx = edx + 3905402710 + edi;
	Mem0[ebp + -16:word32] = edx;
	edx = ecx;
	edx = edx ^ esi;
	edx &= ebx;
	edx = edx ^ ecx;
	edx += Mem0[ebp + -16:word32];
	v16 = (edx & 0x01 << 0x14) != 0x00;
	edx = __ror<word32,byte>(edx, 0x14);
	edx += ebx;
	edi = Mem0[eax + 8:word32];
	Mem0[ebp + -64:word32] = edi;
	ecx = ecx + 0x242070DB + edi;
	Mem0[ebp + -16:word32] = ecx;
	ecx = ebx;
	ecx = ecx ^ esi;
	ecx &= edx;
	ecx = ecx ^ esi;
	ecx += Mem0[ebp + -16:word32];
	v17 = (ecx & 0x01 << 0x0F) != 0x00;
	ecx = __ror<word32,byte>(ecx, 0x0F);
	ecx += edx;
	edi = Mem0[eax + 0x0C:word32];
	Mem0[ebp + -60:word32] = edi;
	esi = esi + ~0x3E423111 + edi;
	Mem0[ebp + -16:word32] = esi;
	esi = edx;
	esi = esi ^ ebx;
	esi &= ecx;
	esi = esi ^ ebx;
	esi += Mem0[ebp + -16:word32];
	v18 = (esi & 0x01 << 0x0A) != 0x00;
	esi = __ror<word32,byte>(esi, 0x0A);
	esi += ecx;
	edi = Mem0[eax + 16:word32];
	Mem0[ebp + -56:word32] = edi;
	ebx = ebx + ~0x0A83F050 + edi;
	Mem0[ebp + -16:word32] = ebx;
	ebx = ecx;
	ebx = ebx ^ edx;
	ebx &= esi;
	ebx = ebx ^ edx;
	ebx += Mem0[ebp + -16:word32];
	v19 = (ebx & 0x01 << 0x19) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x19);
	ebx += esi;
	edi = Mem0[eax + 20:word32];
	Mem0[ebp + -52:word32] = edi;
	edx = edx + 1200080426 + edi;
	Mem0[ebp + -16:word32] = edx;
	edx = esi;
	edx = edx ^ ecx;
	edx &= ebx;
	edx = edx ^ ecx;
	edx += Mem0[ebp + -16:word32];
	v20 = (edx & 0x01 << 0x14) != 0x00;
	edx = __ror<word32,byte>(edx, 0x14);
	edx += ebx;
	edi = Mem0[eax + 24:word32];
	Mem0[ebp + -48:word32] = edi;
	ecx = ecx + 0xA8304613 + edi;
	Mem0[ebp + -16:word32] = ecx;
	ecx = ebx;
	ecx = ecx ^ esi;
	ecx &= edx;
	ecx = ecx ^ esi;
	ecx += Mem0[ebp + -16:word32];
	v21 = (ecx & 0x01 << 0x0F) != 0x00;
	ecx = __ror<word32,byte>(ecx, 0x0F);
	ecx += edx;
	edi = Mem0[eax + 28:word32];
	Mem0[ebp + -44:word32] = edi;
	esi = esi + 4249261313 + edi;
	Mem0[ebp + -16:word32] = esi;
	esi = edx;
	esi = esi ^ ebx;
	esi &= ecx;
	esi = esi ^ ebx;
	esi += Mem0[ebp + -16:word32];
	v22 = (esi & 0x01 << 0x0A) != 0x00;
	esi = __ror<word32,byte>(esi, 0x0A);
	esi += ecx;
	edi = Mem0[eax + 32:word32];
	Mem0[ebp + -40:word32] = edi;
	ebx = ebx + 0x698098D8 + edi;
	Mem0[ebp + -16:word32] = ebx;
	ebx = ecx;
	ebx = ebx ^ edx;
	ebx &= esi;
	ebx = ebx ^ edx;
	ebx += Mem0[ebp + -16:word32];
	v23 = (ebx & 0x01 << 0x19) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x19);
	ebx += esi;
	edi = Mem0[eax + 36:word32];
	Mem0[ebp + -36:word32] = edi;
	edx = edx + 2336552879 + edi;
	Mem0[ebp + -16:word32] = edx;
	edx = esi;
	edx = edx ^ ecx;
	edx &= ebx;
	edx = edx ^ ecx;
	edx += Mem0[ebp + -16:word32];
	v24 = (edx & 0x01 << 0x14) != 0x00;
	edx = __ror<word32,byte>(edx, 0x14);
	edx += ebx;
	edi = Mem0[eax + 40:word32];
	Mem0[ebp + -32:word32] = edi;
	ecx = ecx + ~0xA44E + edi;
	Mem0[ebp + -16:word32] = ecx;
	ecx = ebx;
	ecx = ecx ^ esi;
	ecx &= edx;
	ecx = ecx ^ esi;
	ecx += Mem0[ebp + -16:word32];
	v25 = (ecx & 0x01 << 0x0F) != 0x00;
	ecx = __ror<word32,byte>(ecx, 0x0F);
	ecx += edx;
	edi = Mem0[eax + 44:word32];
	Mem0[ebp + -28:word32] = edi;
	esi = esi + 2304563134 + edi;
	Mem0[ebp + -16:word32] = esi;
	esi = edx;
	esi = esi ^ ebx;
	esi &= ecx;
	esi = esi ^ ebx;
	esi += Mem0[ebp + -16:word32];
	v26 = (esi & 0x01 << 0x0A) != 0x00;
	esi = __ror<word32,byte>(esi, 0x0A);
	esi += ecx;
	edi = Mem0[eax + 48:word32];
	Mem0[ebp + -24:word32] = edi;
	ebx = ebx + 0x6B901122 + edi;
	edi = ecx;
	edi = edi ^ edx;
	edi &= esi;
	edi = edi ^ edx;
	edi = ebx + edi;
	v27 = (edi & 0x01 << 0x19) != 0x00;
	edi = __ror<word32,byte>(edi, 0x19);
	edi += esi;
	ebx = Mem0[eax + 52:word32];
	Mem0[ebp + -20:word32] = ebx;
	edx = edx + 4254626195 + ebx;
	Mem0[ebp + -16:word32] = edx;
	edx = esi;
	edx = edx ^ ecx;
	edx &= edi;
	edx = edx ^ ecx;
	edx += Mem0[ebp + -16:word32];
	v28 = (edx & 0x01 << 0x14) != 0x00;
	edx = __ror<word32,byte>(edx, 0x14);
	edx += edi;
	ebx = Mem0[eax + 56:word32];
	Mem0[ebp + -16:word32] = ebx;
	ecx = ecx + 2792965006 + ebx;
	ebx = edi;
	ebx = ebx ^ esi;
	ebx &= edx;
	ebx = ebx ^ esi;
	ebx = ecx + ebx;
	v29 = (ebx & 0x01 << 0x0F) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x0F);
	ebx += edx;
	ecx = Mem0[eax + 60:word32];
	eax = esi + 1236535329 + ecx;
	esi = edx;
	esi = esi ^ edi;
	esi &= ebx;
	esi = esi ^ edi;
	esi = eax + esi;
	v30 = (esi & 0x01 << 0x0A) != 0x00;
	esi = __ror<word32,byte>(esi, 0x0A);
	esi += ebx;
	eax = Mem0[ebp + -0x0044:word32];
	edi = edi + 0xF61E2562 + eax;
	eax = esi;
	eax = eax ^ ebx;
	eax &= edx;
	eax = eax ^ ebx;
	eax = edi + eax;
	v31 = (eax & 0x01 << 0x1B) != 0x00;
	eax = __ror<word32,byte>(eax, 0x1B);
	eax += esi;
	edi = Mem0[ebp + -48:word32];
	edx = edx + 0xC040B340 + edi;
	Mem0[ebp + -88:word32] = edx;
	edx = eax;
	edx = edx ^ esi;
	edx &= ebx;
	edx = edx ^ esi;
	edx += Mem0[ebp + -88:word32];
	v32 = (edx & 0x01 << 0x17) != 0x00;
	edx = __ror<word32,byte>(edx, 0x17);
	edx += eax;
	edi = Mem0[ebp + -28:word32];
	ebx = ebx + 643717713 + edi;
	Mem0[ebp + -88:word32] = ebx;
	ebx = edx;
	ebx = ebx ^ eax;
	ebx &= esi;
	ebx = ebx ^ eax;
	ebx += Mem0[ebp + -88:word32];
	v33 = (ebx & 0x01 << 0x12) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x12);
	ebx += edx;
	edi = Mem0[ebp + -72:word32];
	esi = esi + 3921069994 + edi;
	Mem0[ebp + -88:word32] = esi;
	esi = ebx;
	esi = esi ^ edx;
	esi &= eax;
	esi = esi ^ edx;
	esi += Mem0[ebp + -88:word32];
	v34 = (esi & 0x01 << 0x0C) != 0x00;
	esi = __ror<word32,byte>(esi, 0x0C);
	esi += ebx;
	edi = Mem0[ebp + -52:word32];
	eax = eax + 0xD62F105D + edi;
	Mem0[ebp + -88:word32] = eax;
	eax = esi;
	eax = eax ^ ebx;
	eax &= edx;
	eax = eax ^ ebx;
	eax += Mem0[ebp + -88:word32];
	v35 = (eax & 0x01 << 0x1B) != 0x00;
	eax = __ror<word32,byte>(eax, 0x1B);
	eax += esi;
	edi = Mem0[ebp + -32:word32];
	edx = edx + 38016083 + edi;
	Mem0[ebp + -88:word32] = edx;
	edx = eax;
	edx = edx ^ esi;
	edx &= ebx;
	edx = edx ^ esi;
	edx += Mem0[ebp + -88:word32];
	v36 = (edx & 0x01 << 0x17) != 0x00;
	edx = __ror<word32,byte>(edx, 0x17);
	edx += eax;
	edi = ebx + 3634488961 + ecx;
	ebx = edx;
	ebx = ebx ^ eax;
	ebx &= esi;
	ebx = ebx ^ eax;
	ebx = edi + ebx;
	v37 = (ebx & 0x01 << 0x12) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x12);
	ebx += edx;
	edi = Mem0[ebp + -56:word32];
	esi = esi + 3889429448 + edi;
	Mem0[ebp + -88:word32] = esi;
	esi = ebx;
	esi = esi ^ edx;
	esi &= eax;
	esi = esi ^ edx;
	esi += Mem0[ebp + -88:word32];
	v38 = (esi & 0x01 << 0x0C) != 0x00;
	esi = __ror<word32,byte>(esi, 0x0C);
	esi += ebx;
	edi = Mem0[ebp + -36:word32];
	eax = eax + 568446438 + edi;
	Mem0[ebp + -88:word32] = eax;
	eax = esi;
	eax = eax ^ ebx;
	eax &= edx;
	eax = eax ^ ebx;
	eax += Mem0[ebp + -88:word32];
	v39 = (eax & 0x01 << 0x1B) != 0x00;
	eax = __ror<word32,byte>(eax, 0x1B);
	eax += esi;
	edi = Mem0[ebp + -16:word32];
	edx = edx + ~0x3CC8F829 + edi;
	Mem0[ebp + -88:word32] = edx;
	edx = eax;
	edx = edx ^ esi;
	edx &= ebx;
	edx = edx ^ esi;
	edx += Mem0[ebp + -88:word32];
	v40 = (edx & 0x01 << 0x17) != 0x00;
	edx = __ror<word32,byte>(edx, 0x17);
	edx += eax;
	edi = Mem0[ebp + -60:word32];
	ebx = ebx + ~0x0B2AF278 + edi;
	Mem0[ebp + -88:word32] = ebx;
	ebx = edx;
	ebx = ebx ^ eax;
	ebx &= esi;
	ebx = ebx ^ eax;
	ebx += Mem0[ebp + -88:word32];
	v41 = (ebx & 0x01 << 0x12) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x12);
	ebx += edx;
	edi = Mem0[ebp + -40:word32];
	esi = esi + 1163531501 + edi;
	edi = ebx;
	edi = edi ^ edx;
	edi &= eax;
	edi = edi ^ edx;
	edi = esi + edi;
	v42 = (edi & 0x01 << 0x0C) != 0x00;
	edi = __ror<word32,byte>(edi, 0x0C);
	edi += ebx;
	Mem0[ebp + -88:word32] = edi;
	esi = Mem0[ebp + -20:word32];
	edi = eax + 2850285829 + esi;
	eax = Mem0[ebp + -88:word32];
	eax = eax ^ ebx;
	eax &= edx;
	eax = eax ^ ebx;
	eax = edi + eax;
	v43 = (eax & 0x01 << 0x1B) != 0x00;
	eax = __ror<word32,byte>(eax, 0x1B);
	eax += Mem0[ebp + -88:word32];
	Mem0[ebp + -96:word32] = eax;
	edi = Mem0[ebp + -64:word32];
	eax = edx + 4243563512 + edi;
	edx = Mem0[ebp + -96:word32];
	edx = edx ^ Mem0[ebp + -88:word32];
	edx &= ebx;
	edx = edx ^ Mem0[ebp + -88:word32];
	edx = eax + edx;
	v44 = (edx & 0x01 << 0x17) != 0x00;
	edx = __ror<word32,byte>(edx, 0x17);
	edx += Mem0[ebp + -96:word32];
	esi = Mem0[ebp + -44:word32];
	eax = ebx + 0x676F02D9 + esi;
	ebx = Mem0[ebp + -96:word32];
	ebx = ebx ^ edx;
	ebx &= Mem0[ebp + -88:word32];
	ebx = ebx ^ Mem0[ebp + -96:word32];
	ebx = eax + ebx;
	v45 = (ebx & 0x01 << 0x12) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x12);
	ebx += edx;
	edi = ebx;
	edi = edi ^ edx;
	Mem0[ebp + -100:word32] = edi;
	edi = Mem0[ebp + -88:word32];
	eax = Mem0[ebp + -24:word32];
	esi = edi + 2368359562 + eax;
	eax = Mem0[ebp + -96:word32];
	eax &= Mem0[ebp + -100:word32];
	eax = eax ^ edx;
	edi = esi + eax;
	v46 = (edi & 0x01 << 0x0C) != 0x00;
	edi = __ror<word32,byte>(edi, 0x0C);
	edi += ebx;
	eax = Mem0[ebp + -96:word32];
	esi = Mem0[ebp + -52:word32];
	esi = eax + ~0x0005C6BD + esi;
	Mem0[ebp + -88:word32] = esi;
	esi = Mem0[ebp + -100:word32];
	esi = esi ^ edi;
	esi += Mem0[ebp + -88:word32];
	v47 = (esi & 0x01 << 0x1C) != 0x00;
	esi = __ror<word32,byte>(esi, 0x1C);
	esi += edi;
	eax = Mem0[ebp + -40:word32];
	edx = edx + 2272392833 + eax;
	Mem0[ebp + -88:word32] = edx;
	edx = edi;
	edx = edx ^ ebx;
	edx = edx ^ esi;
	edx += Mem0[ebp + -88:word32];
	v48 = (edx & 0x01 << 0x15) != 0x00;
	edx = __ror<word32,byte>(edx, 0x15);
	edx += esi;
	eax = Mem0[ebp + -28:word32];
	ebx = ebx + 0x6D9D6122 + eax;
	Mem0[ebp + -88:word32] = ebx;
	ebx = esi;
	ebx = ebx ^ edi;
	ebx = ebx ^ edx;
	ebx += Mem0[ebp + -88:word32];
	v49 = (ebx & 0x01 << 0x10) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x10);
	ebx += edx;
	eax = Mem0[ebp + -16:word32];
	edi = edi + 4259657740 + eax;
	Mem0[ebp + -88:word32] = edi;
	edi = edx;
	edi = edi ^ esi;
	edi = edi ^ ebx;
	edi += Mem0[ebp + -88:word32];
	v50 = (edi & 0x01 << 0x09) != 0x00;
	edi = __ror<word32,byte>(edi, 0x09);
	edi += ebx;
	eax = Mem0[ebp + -0x0044:word32];
	esi = esi + 0xA4BEEA44 + eax;
	eax = ebx;
	eax = eax ^ edx;
	eax = eax ^ edi;
	eax = esi + eax;
	v51 = (eax & 0x01 << 0x1C) != 0x00;
	eax = __ror<word32,byte>(eax, 0x1C);
	eax += edi;
	esi = Mem0[ebp + -56:word32];
	edx = edx + 1272893353 + esi;
	esi = edi;
	esi = esi ^ ebx;
	esi = esi ^ eax;
	esi = edx + esi;
	v52 = (esi & 0x01 << 0x15) != 0x00;
	esi = __ror<word32,byte>(esi, 0x15);
	esi += eax;
	edx = Mem0[ebp + -44:word32];
	ebx = ebx + ~0x0944B49F + edx;
	Mem0[ebp + -88:word32] = ebx;
	ebx = eax;
	ebx = ebx ^ edi;
	ebx = ebx ^ esi;
	ebx += Mem0[ebp + -88:word32];
	v53 = (ebx & 0x01 << 0x10) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x10);
	ebx += esi;
	edx = Mem0[ebp + -32:word32];
	edi = edi + 3200236656 + edx;
	edx = esi;
	edx = edx ^ eax;
	edx = edx ^ ebx;
	edx = edi + edx;
	v54 = (edx & 0x01 << 0x09) != 0x00;
	edx = __ror<word32,byte>(edx, 0x09);
	edx += ebx;
	edi = Mem0[ebp + -20:word32];
	eax = eax + 681279174 + edi;
	edi = ebx;
	edi = edi ^ esi;
	edi = edi ^ edx;
	edi = eax + edi;
	v55 = (edi & 0x01 << 0x1C) != 0x00;
	edi = __ror<word32,byte>(edi, 0x1C);
	edi += edx;
	eax = Mem0[ebp + -72:word32];
	esi = esi + 3936430074 + eax;
	Mem0[ebp + -88:word32] = esi;
	esi = edx;
	esi = esi ^ ebx;
	esi = esi ^ edi;
	esi += Mem0[ebp + -88:word32];
	v56 = (esi & 0x01 << 0x15) != 0x00;
	esi = __ror<word32,byte>(esi, 0x15);
	esi += edi;
	eax = Mem0[ebp + -60:word32];
	ebx = ebx + 3572445317 + eax;
	eax = edi;
	eax = eax ^ edx;
	eax = eax ^ esi;
	eax = ebx + eax;
	v57 = (eax & 0x01 << 0x10) != 0x00;
	eax = __ror<word32,byte>(eax, 0x10);
	eax += esi;
	ebx = Mem0[ebp + -48:word32];
	edx = edx + 0x04881D05 + ebx;
	ebx = esi;
	ebx = ebx ^ edi;
	ebx = ebx ^ eax;
	ebx = edx + ebx;
	v58 = (ebx & 0x01 << 0x09) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x09);
	ebx += eax;
	edx = Mem0[ebp + -36:word32];
	edi = edi + 0xD9D4D039 + edx;
	Mem0[ebp + -88:word32] = edi;
	edi = eax;
	edi = edi ^ esi;
	edi = edi ^ ebx;
	edi += Mem0[ebp + -88:word32];
	v59 = (edi & 0x01 << 0x1C) != 0x00;
	edi = __ror<word32,byte>(edi, 0x1C);
	edi += ebx;
	edx = Mem0[ebp + -24:word32];
	esi = esi + 3873151461 + edx;
	edx = ebx;
	edx = edx ^ eax;
	edx = edx ^ edi;
	edx = esi + edx;
	v60 = (edx & 0x01 << 0x15) != 0x00;
	edx = __ror<word32,byte>(edx, 0x15);
	edx += edi;
	eax = eax + 530742520 + ecx;
	esi = edi;
	esi = esi ^ ebx;
	esi = esi ^ edx;
	esi = eax + esi;
	v61 = (esi & 0x01 << 0x10) != 0x00;
	esi = __ror<word32,byte>(esi, 0x10);
	esi += edx;
	eax = Mem0[ebp + -64:word32];
	ebx = ebx + 0xC4AC5665 + eax;
	Mem0[ebp + -88:word32] = ebx;
	ebx = edx;
	ebx = ebx ^ edi;
	ebx = ebx ^ esi;
	ebx += Mem0[ebp + -88:word32];
	v62 = (ebx & 0x01 << 0x09) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x09);
	ebx += esi;
	eax = Mem0[ebp + -72:word32];
	edi = edi + 0xF4292244 + eax;
	eax = edx;
	eax = ~eax;
	eax |= ebx;
	eax = eax ^ esi;
	eax = edi + eax;
	v63 = (eax & 0x01 << 0x1A) != 0x00;
	eax = __ror<word32,byte>(eax, 0x1A);
	eax += ebx;
	edi = Mem0[ebp + -44:word32];
	edx = edx + 1126891415 + edi;
	Mem0[ebp + -44:word32] = edx;
	edx = esi;
	edx = ~edx;
	edx |= eax;
	edx = edx ^ ebx;
	edx += Mem0[ebp + -44:word32];
	v64 = (edx & 0x01 << 22) != 0x00;
	edx = __ror<word32,byte>(edx, 22);
	edx += eax;
	edi = Mem0[ebp + -16:word32];
	esi = esi + 2878612391 + edi;
	Mem0[ebp + -16:word32] = esi;
	esi = ebx;
	esi = ~esi;
	esi |= edx;
	esi = esi ^ eax;
	esi += Mem0[ebp + -16:word32];
	v65 = (esi & 0x01 << 0x11) != 0x00;
	esi = __ror<word32,byte>(esi, 0x11);
	esi += edx;
	edi = Mem0[ebp + -52:word32];
	ebx = ebx + 0xFC93A039 + edi;
	Mem0[ebp + -16:word32] = ebx;
	ebx = eax;
	ebx = ~ebx;
	ebx |= esi;
	ebx = ebx ^ edx;
	ebx += Mem0[ebp + -16:word32];
	v66 = (ebx & 0x01 << 11) != 0x00;
	ebx = __ror<word32,byte>(ebx, 11);
	ebx += esi;
	edi = Mem0[ebp + -24:word32];
	eax = eax + 1700485571 + edi;
	edi = edx;
	edi = ~edi;
	edi |= ebx;
	edi = edi ^ esi;
	edi = eax + edi;
	v67 = (edi & 0x01 << 0x1A) != 0x00;
	edi = __ror<word32,byte>(edi, 0x1A);
	edi += ebx;
	eax = Mem0[ebp + -60:word32];
	edx = edx + 2399980690 + eax;
	Mem0[ebp + -16:word32] = edx;
	edx = esi;
	edx = ~edx;
	edx |= edi;
	edx = edx ^ ebx;
	edx += Mem0[ebp + -16:word32];
	v68 = (edx & 0x01 << 22) != 0x00;
	edx = __ror<word32,byte>(edx, 22);
	edx += edi;
	eax = Mem0[ebp + -32:word32];
	esi = esi + ~0x00100B82 + eax;
	Mem0[ebp + -16:word32] = esi;
	esi = ebx;
	esi = ~esi;
	esi |= edx;
	esi = esi ^ edi;
	esi += Mem0[ebp + -16:word32];
	v69 = (esi & 0x01 << 0x11) != 0x00;
	esi = __ror<word32,byte>(esi, 0x11);
	esi += edx;
	eax = Mem0[ebp + -0x0044:word32];
	ebx = ebx + 2240044497 + eax;
	eax = edi;
	eax = ~eax;
	eax |= esi;
	eax = eax ^ edx;
	eax = ebx + eax;
	v70 = (eax & 0x01 << 11) != 0x00;
	eax = __ror<word32,byte>(eax, 11);
	eax += esi;
	ebx = Mem0[ebp + -40:word32];
	edi = edi + 1873313359 + ebx;
	ebx = edx;
	ebx = ~ebx;
	ebx |= eax;
	ebx = ebx ^ esi;
	ebx = edi + ebx;
	v71 = (ebx & 0x01 << 0x1A) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x1A);
	ebx += eax;
	ecx = edx + 4264355552 + ecx;
	edx = esi;
	edx = ~edx;
	edx |= ebx;
	edx = edx ^ eax;
	edx = ecx + edx;
	v72 = (edx & 0x01 << 22) != 0x00;
	edx = __ror<word32,byte>(edx, 22);
	edx += ebx;
	edi = Mem0[ebp + -48:word32];
	esi = esi + 0xA3014314 + edi;
	ecx = eax;
	ecx = ~ecx;
	ecx |= edx;
	ecx = ecx ^ ebx;
	ecx = esi + ecx;
	v73 = (ecx & 0x01 << 0x11) != 0x00;
	ecx = __ror<word32,byte>(ecx, 0x11);
	ecx += edx;
	edi = Mem0[ebp + -20:word32];
	esi = eax + 0x4E0811A1 + edi;
	eax = ebx;
	eax = ~eax;
	eax |= ecx;
	eax = eax ^ edx;
	eax = esi + eax;
	v74 = (eax & 0x01 << 11) != 0x00;
	eax = __ror<word32,byte>(eax, 11);
	eax += ecx;
	edi = Mem0[ebp + -56:word32];
	esi = ebx + 4149444226 + edi;
	ebx = edx;
	ebx = ~ebx;
	ebx |= eax;
	ebx = ebx ^ ecx;
	ebx = esi + ebx;
	v75 = (ebx & 0x01 << 0x1A) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x1A);
	ebx += eax;
	edi = Mem0[ebp + -28:word32];
	esi = edx + 3174756917 + edi;
	edx = ecx;
	edx = ~edx;
	edx |= ebx;
	edx = edx ^ eax;
	edx = esi + edx;
	v76 = (edx & 0x01 << 22) != 0x00;
	edx = __ror<word32,byte>(edx, 22);
	edx += ebx;
	edi = Mem0[ebp + -64:word32];
	esi = ecx + 718787259 + edi;
	ecx = eax;
	ecx = ~ecx;
	ecx |= edx;
	ecx = ecx ^ ebx;
	ecx = esi + ecx;
	v77 = (ecx & 0x01 << 0x11) != 0x00;
	ecx = __ror<word32,byte>(ecx, 0x11);
	ecx += edx;
	edi = Mem0[ebp + -36:word32];
	esi = eax + 3951481745 + edi;
	eax = ebx;
	eax = ~eax;
	eax |= ecx;
	eax = eax ^ edx;
	eax = esi + eax;
	ebx += Mem0[ebp + -92:word32];
	esi = Mem0[ebp + 8:word32];
	Mem0[esi + 0x00:word32] = ebx;
	ebx = ecx;
	edi = Mem0[ebp + -84:word32];
	ebx += Mem0[edi + 0x00:word32];
	v78 = (eax & 0x01 << 11) != 0x00;
	eax = __ror<word32,byte>(eax, 11);
	eax = ebx + eax;
	Mem0[edi + 0x00:word32] = eax;
	eax = Mem0[ebp + -80:word32];
	v79 = Mem0[eax + 0x00:word32] + ecx;
	Mem0[eax + 0x00:word32] = v79;
	ecx = Mem0[ebp + -76:word32];
	v80 = Mem0[ecx + 0x00:word32] + edx;
	Mem0[ecx + 0x00:word32] = v80;
	esp += 88;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E128: define caml_MD5Final
// Called from:
//      caml_code_checksum
//      caml_md5_chan
//      caml_md5_string
define caml_MD5Final
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	esi = Mem0[ebp + 8:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	eax = Mem0[ebx + 16:word32];
	eax >>= 0x03;
	eax &= 0x3F;
	Mem0[ebx + 24 + eax:byte] = 0x80;
	edx = ebx + 25 + eax;
	ecx = 0x3F;
	ecx -= eax;
	eax = ecx;
	SCZO = cond(ecx - 0x07);
	if (Test(ULE,CZ))
	{
		Mem0[esp + 8:word32] = ecx;
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = edx;
		eax = memset(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:int32], Mem0[esp + 8:size_t]);
		edi = ebx + 24;
		Mem0[esp + 4:word32] = edi;
		Mem0[esp + 0x00:word32] = ebx;
		caml_MD5Transform();
		edx = 0x38;
		eax = 0x00;
		SZP = cond(edi & 0x01);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[edi + 0x00:byte] = al;
			++edi;
			--edx;
			SCZO = cond(edx);
		}
		SZP = cond(edi & 0x02);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[edi + 0x00:word16] = ax;
			edi += 0x02;
			edx -= 0x02;
			SCZO = cond(edx);
		}
		ecx = edx;
		ecx >>= 0x02;
		SCZO = cond(ecx);
		for (; ecx != 0x00; --ecx)
		{
			Mem0[edi + 0x00:word32] = eax;
			edi += 4;
		}
		SZP = cond(dl & 0x02);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[edi + 0x00:word16] = ax;
			edi += 0x02;
			SCZO = cond(edi);
		}
		SZP = cond(dl & 0x01);
		O = false;
		C = false;
		if (Test(NE,Z))
			Mem0[edi + 0x00:byte] = al;
	}
	else
	{
		eax -= 0x08;
		SCZO = cond(eax);
		Mem0[esp + 8:word32] = eax;
		Mem0[esp + 4:word32] = 0x00;
		Mem0[esp + 0x00:word32] = edx;
		eax = memset(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:int32], Mem0[esp + 8:size_t]);
	}
	eax = ebx + 24;
	edx = Mem0[ebx + 16:word32];
	Mem0[eax + 56:word32] = edx;
	edx = Mem0[ebx + 20:word32];
	Mem0[eax + 60:word32] = edx;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_MD5Transform();
	eax = Mem0[ebx + 0x00:word32];
	Mem0[esi + 0x00:word32] = eax;
	eax = Mem0[ebx + 4:word32];
	Mem0[esi + 4:word32] = eax;
	eax = Mem0[ebx + 8:word32];
	Mem0[esi + 8:word32] = eax;
	eax = Mem0[ebx + 0x0C:word32];
	Mem0[esi + 0x0C:word32] = eax;
	Mem0[ebx + 0x00:word32] = 0x00;
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E216: define caml_MD5Update
// Called from:
//      caml_code_checksum
//      caml_md5_chan
//      caml_md5_string
define caml_MD5Update
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	edi = Mem0[ebp + 16:word32];
	eax = Mem0[ebp + 8:word32];
	ebx = Mem0[eax + 16:word32];
	eax = ebx + edi * 0x08;
	edx = Mem0[ebp + 8:word32];
	Mem0[edx + 16:word32] = eax;
	SCZO = cond(ebx - eax);
	if (Test(UGT,CZ))
	{
		v12 = Mem0[edx + 20:word32] + 0x01;
		Mem0[edx + 20:word32] = v12;
		SCZO = cond(v12);
	}
	eax = edi;
	eax >>= 0x1D;
	edx = Mem0[ebp + 8:word32];
	v13 = Mem0[edx + 20:word32] + eax;
	Mem0[edx + 20:word32] = v13;
	ebx >>= 0x03;
	ebx &= 0x3F;
	SZ = cond(ebx);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		eax = edx + 24 + ebx;
		edx = 0x40;
		edx -= ebx;
		ebx = edx;
		SCZO = cond(edi - edx);
		if (Test(ULT,C))
		{
			Mem0[esp + 8:word32] = edi;
			edx = Mem0[ebp + 0x0C:word32];
			Mem0[esp + 4:word32] = edx;
			Mem0[esp + 0x00:word32] = eax;
			eax = memcpy(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
			goto l0806E372;
		}
		Mem0[esp + 8:word32] = edx;
		edx = Mem0[ebp + 0x0C:word32];
		Mem0[esp + 4:word32] = edx;
		Mem0[esp + 0x00:word32] = eax;
		eax = memcpy(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
		eax = Mem0[ebp + 8:word32];
		eax += 0x18;
		SCZO = cond(eax);
		Mem0[esp + 4:word32] = eax;
		eax = Mem0[ebp + 8:word32];
		Mem0[esp + 0x00:word32] = eax;
		caml_MD5Transform();
		v18 = Mem0[ebp + 0x0C:word32] + ebx;
		Mem0[ebp + 0x0C:word32] = v18;
		edi -= ebx;
		SCZO = cond(edi);
	}
	SCZO = cond(edi - 0x3F);
	if (Test(UGT,CZ))
	{
		ebx = Mem0[ebp + 8:word32];
		ebx += 0x18;
		SCZO = cond(ebx);
		Mem0[ebp + -32:word32] = ebx;
		edx = Mem0[ebp + 8:word32];
		Mem0[ebp + -28:word32] = edx;
		esi = 0x00;
		do
		{
			eax = Mem0[ebp + 0x0C:word32];
			eax += esi;
			SCZO = cond(eax);
			edx = Mem0[eax + 0x00:word32];
			Mem0[ebx + 0x00:word32] = edx;
			edx = Mem0[eax + 4:word32];
			Mem0[ebx + 4:word32] = edx;
			edx = Mem0[eax + 8:word32];
			Mem0[ebx + 8:word32] = edx;
			edx = Mem0[eax + 0x0C:word32];
			Mem0[ebx + 0x0C:word32] = edx;
			edx = Mem0[eax + 16:word32];
			Mem0[ebx + 16:word32] = edx;
			edx = Mem0[eax + 20:word32];
			Mem0[ebx + 20:word32] = edx;
			edx = Mem0[eax + 24:word32];
			Mem0[ebx + 24:word32] = edx;
			edx = Mem0[eax + 28:word32];
			Mem0[ebx + 28:word32] = edx;
			edx = Mem0[eax + 32:word32];
			Mem0[ebx + 32:word32] = edx;
			edx = Mem0[eax + 36:word32];
			Mem0[ebx + 36:word32] = edx;
			edx = Mem0[eax + 40:word32];
			Mem0[ebx + 40:word32] = edx;
			edx = Mem0[eax + 44:word32];
			Mem0[ebx + 44:word32] = edx;
			edx = Mem0[eax + 48:word32];
			Mem0[ebx + 48:word32] = edx;
			edx = Mem0[eax + 52:word32];
			Mem0[ebx + 52:word32] = edx;
			edx = Mem0[eax + 56:word32];
			Mem0[ebx + 56:word32] = edx;
			eax = Mem0[eax + 60:word32];
			Mem0[ebx + 60:word32] = eax;
			eax = Mem0[ebp + -32:word32];
			Mem0[esp + 4:word32] = eax;
			edx = Mem0[ebp + -28:word32];
			Mem0[esp + 0x00:word32] = edx;
			caml_MD5Transform();
			esi += 0x40;
			eax = edi;
			eax -= esi;
			SCZO = cond(eax - 0x3F);
		} while (Test(UGT,CZ));
		edi -= 0x40;
		eax = edi;
		eax &= ~0x3F;
		edx = Mem0[ebp + 0x0C:word32];
		edx = edx + 64 + eax;
		Mem0[ebp + 0x0C:word32] = edx;
		edi &= 0x3F;
		SZ = cond(edi);
		O = false;
		C = false;
	}
	eax = Mem0[ebp + 8:word32];
	eax += 0x18;
	SCZO = cond(eax);
	Mem0[esp + 8:word32] = edi;
	edx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = eax;
	eax = memcpy(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
l0806E372:
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E37A: define caml_md5_chan
define caml_md5_chan
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10AC;
	eax = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + ~0x109F:word32] = eax;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 56;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x02;
	edx = ebp + 8;
	Mem0[ebp + -44:word32] = edx;
	eax = ebp + 0x0C;
	Mem0[ebp + -40:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	eax = Mem0[eax + 4:word32];
	Mem0[ebp + ~0x109B:word32] = eax;
	eax = Mem0[0x08081868<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edx = Mem0[ebp + ~0x109B:word32];
		Mem0[esp + 0x00:word32] = edx;
		eax();
	}
	eax = ebp - 0x90;
	Mem0[esp + 0x00:word32] = eax;
	caml_MD5Init();
	ebx = Mem0[ebp + 0x0C:word32];
	ebx >>= 0x01;
	SCZ = cond(ebx);
	O = false;
	if (Test(NS,S))
	{
		edi = ebp + ~0x108F;
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
		while (Test(GT,SZO))
		{
			SCZO = cond(ebx - 0x1000);
			eax = 0x1000;
			if (Test(ULE,CZ))
				eax = ebx;
			Mem0[esp + 8:word32] = eax;
			Mem0[esp + 4:word32] = edi;
			edx = Mem0[ebp + ~0x109B:word32];
			Mem0[esp + 0x00:word32] = edx;
			caml_getblock();
			esi = eax;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				caml_raise_end_of_file();
			Mem0[esp + 8:word32] = eax;
			Mem0[esp + 4:word32] = edi;
			eax = ebp - 0x90;
			Mem0[esp + 0x00:word32] = eax;
			caml_MD5Update();
			ebx -= esi;
			SZP = cond(ebx & ebx);
			O = false;
			C = false;
		}
	}
	else
	{
		ebx = ebp + ~0x108F;
		esi = ebp - 0x90;
		while (true)
		{
			Mem0[esp + 8:word32] = 0x1000;
			Mem0[esp + 4:word32] = ebx;
			eax = Mem0[ebp + ~0x109B:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_getblock();
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				break;
			Mem0[esp + 8:word32] = eax;
			Mem0[esp + 4:word32] = ebx;
			Mem0[esp + 0x00:word32] = esi;
			caml_MD5Update();
		}
	}
	Mem0[esp + 0x00:word32] = 0x10;
	caml_alloc_string();
	ebx = eax;
	eax = ebp - 0x90;
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_MD5Final();
	eax = Mem0[0x0808186C<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		edx = Mem0[ebp + ~0x109B:word32];
		Mem0[esp + 0x00:word32] = edx;
		eax();
	}
	eax = Mem0[ebp + ~0x109F:word32];
	Mem0[0x0807D294<p32>:word32] = eax;
	eax = ebx;
	esp += 0x10AC;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E4CD: define caml_md5_string
define caml_md5_string
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	SCZO = cond(esp);
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = ebp - 96;
	Mem0[esp + 0x00:word32] = ebx;
	caml_MD5Init();
	eax = Mem0[ebp + 16:word32];
	eax >>= 0x01;
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	eax += Mem0[ebp + 8:word32];
	SCZO = cond(eax);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_MD5Update();
	Mem0[esp + 0x00:word32] = 0x10;
	caml_alloc_string();
	esi = eax;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 0x00:word32] = eax;
	caml_MD5Final();
	eax = esi;
	ebx = Mem0[ebp + -8:word32];
	esi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E528: define add_char
// Called from:
//      caml_format_exception
define add_char
{
	word32 eax;
	byte dl;
	Top_3 = 0;
	ecx_9 = Mem6[eax + 0x00:word32];
	SCZO_10 = cond(ecx_9 - Mem6[eax + 4:word32]);
	C_11 = SLICE(SCZO_10, bool, 1);
	O_27 = SLICE(SCZO_10, bool, 4);
	S_30 = SLICE(SCZO_10, bool, 0);
	Z_34 = SLICE(SCZO_10, bool, 2);
	if (ecx_9 <u Mem6[eax + 4:word32])
	{
		Mem13[ecx_9 + 0x00:byte] = dl;
		ecx_14 = ecx_9 + 0x01;
		SCZO_15 = cond(ecx_9 + 0x01);
		C_24 = SLICE(SCZO_15, bool, 1);
		O_28 = SLICE(SCZO_15, bool, 4);
		S_31 = SLICE(SCZO_15, bool, 0);
		Z_35 = SLICE(SCZO_15, bool, 2);
		Mem16[eax + 0x00:word32] = ecx_9 + 0x01;
	}
	Z_33 = ϕ(Z_34, Z_35);
	S_29 = ϕ(S_30, S_31);
	O_26 = ϕ(O_27, O_28);
	ecx_25 = ϕ(ecx_9, ecx_14);
	C_23 = ϕ(C_11, C_24);
}

// 0806E53B: define add_string
// Called from:
//      caml_format_exception
define add_string
{
	word32 eax;
	word32 edx;
	Top_3 = 0;
	size_20 = strlen(edx) + 1;
	ecx_21 = ~0x00 - size_20;
	ecx_22 = ~ecx_21;
	ebx_23 = ecx_22 - 1;
	eax_24 = Mem14[eax + 0x00:word32];
	ecx_25 = eax_24 + (ecx_22 - 1);
	edi_26 = Mem14[eax + 4:word32];
	edi_27 = edi_26 - eax_24;
	if (Mem14[eax + 4:word32] <u ecx_25)
		ebx_30 = edi_27;
	ebx_31 = ϕ(ebx_23, ebx_30);
	SZP_32 = cond(ebx_31);
	P_81 = SLICE(SZP_32, bool, 5);
	if (ebx_31 > 0x00)
		eax_43 = memmove(eax_24, edx, ebx_31);
	eax_76 = ϕ(eax_24, eax_43);
	Mem46 = ϕ(Mem14, Mem42);
	v17_49 = Mem46[eax + 0x00:word32] + ebx_31;
	Mem50[eax + 0x00:word32] = v17_49;
	SCZO_51 = cond(v17_49);
	C_75 = SLICE(SCZO_51, bool, 1);
	O_79 = SLICE(SCZO_51, bool, 4);
	S_82 = SLICE(SCZO_51, bool, 0);
	Z_85 = SLICE(SCZO_51, bool, 2);
}

// 0806E592: define caml_format_exception
// Called from:
//      caml_fatal_uncaught_exception
define caml_format_exception
{
	ptr32 fp;
	char bLoc0164;
	struct <anonymous> tLoc0124;
	word32 dwLoc011C;
	word32 dwArg04;
	Top_3 = 0;
	Mem22[&tLoc0124 + 0x00:word32] = &dwLoc011C;
	Mem24[&tLoc0124 + 4:word32] = fp - 29;
	edx_25 = Mem24[dwArg04 + 0x00:word32];
	edx_26 = Mem24[edx_25 + 0x00:word32];
	add_string();
	eax_34 = Mem24[dwArg04 + -4:word32];
	if (eax_34 >>u 0x0A <=u 0x01)
	{
l0806E6EE:
		ecx_256 = ϕ(ecx_28, ecx_158);
		Mem164 = ϕ(Mem24, Mem165);
		eax_166 = Mem164[&tLoc0124 + 0x00:word32];
		Mem167[eax_166 + 0x00:byte] = 0x00;
		eax_168 = Mem167[&tLoc0124 + 0x00:word32];
		edx_169 = fp - 28;
		eax_170 = eax_168 - (fp - 28);
		eax_178 = malloc(eax_170 + 0x0101);
		SZP_180 = cond(eax_178);
		P_260 = SLICE(SZP_180, bool, 5);
		if (eax_178 != 0x00)
		{
			dwLoc0188_223 = &dwLoc011C;
			memmove(eax_178, dwLoc0188_223, eax_170 + 0x0101);
		}
		eax_190 = eax_178;
		SCZO_193 = cond(fp - 0x10);
		C_254 = SLICE(SCZO_193, bool, 1);
		O_258 = SLICE(SCZO_193, bool, 4);
		S_261 = SLICE(SCZO_193, bool, 0);
		Z_269 = SLICE(SCZO_193, bool, 2);
		return;
	}
	if (eax_34 >>u 0x0A == 0x02)
	{
		esi_40 = Mem24[dwArg04 + 4:word32];
		if ((esi_40 & 0x01) == 0x00)
		{
			dwLoc0170_211 = 0x00;
			if (Mem45[esi_40 + -4:byte] == 0x00)
			{
l0806E600:
				dwLoc0170_214 = ϕ(dwLoc0170_211, dwLoc0170_212);
				esi_61 = ϕ(esi_40, esi_49);
				add_char();
				edi_64 = esi_61 - 0x04;
				eax_65 = Mem62[edi_64 + 0x00:word32];
				if (dwLoc0170_214 <u eax_65 >>u 0x0A)
				{
					esi_69 = dwLoc0170_214;
					while (true)
					{
						esi_73 = ϕ(esi_69, esi_134, esi_134);
						Mem71 = ϕ(Mem62, Mem137, Mem137);
						ebx_74 = esi_61[esi_73 * 0x04];
						bl_75 = SLICE(ebx_74, byte, 0);
						if ((bl_75 & 0x01) != 0x00)
						{
							dwLoc018C_218 = &bLoc0164;
							sprintf(dwLoc018C_218, 0x08071F5B, ebx_74 >> 0x01);
							add_string();
						}
						else if (Mem71[ebx_74 + -4:byte] == 252)
						{
							add_char();
							add_string();
							add_char();
						}
						else
							add_char();
						Mem137 = ϕ(Mem122, Mem71, Mem71);
						esi_134 = esi_73 + 0x01;
						eax_138 = Mem137[edi_64 + 0x00:word32];
						if (eax_138 >>u 0x0A <=u esi_134)
							break;
						if (dwLoc0170_214 <u esi_134)
							add_string();
					}
				}
				Mem165 = ϕ(Mem62, Mem137);
				add_char();
				goto l0806E6EE;
			}
		}
	}
	esi_49 = dwArg04;
	dwLoc0170_212 = 0x01;
	goto l0806E600;
}

// 0806E739: define caml_fatal_uncaught_exception
// Called from:
//      caml_main
//      caml_raise
define caml_fatal_uncaught_exception
{
	word32 dwArg04;
	caml_format_exception();
	esi_26 = Mem17[0x080839C4<p32>:word32];
	edi_27 = Mem17[0x080839C8<p32>:word32];
	Mem28[0x080839C4<p32>:word32] = 0x00;
	caml_named_value();
	if (eax_30 != 0x00)
	{
		eax_43 = Mem42[eax_30 + 0x00:word32];
		fn08070AC8();
	}
	Mem51[0x080839C4<p32>:word32] = esi_26;
	Mem53[0x080839C8<p32>:word32] = edi_27;
	eax_58 = Mem57[0x0807D100<p32>:word32];
	fprintf(eax_58, 0x0807227D, dwArg04);
	free(dwArg04);
	if (Mem61[0x080839C4<p32>:word32] != 0x00)
		caml_print_exception_backtrace();
	exit(0x02);
}

// 0806E7E0: define hash_value_name
// Called from:
//      caml_named_value
//      caml_register_named_value
define hash_value_name
{
	word32 eax;
	Top_3 = 0;
	edx_12 = CONVERT(Mem10[eax + 0x00:byte], byte, word32);
	dl_14 = SLICE(edx_12, byte, 0);
	ecx_13 = 0x00;
	SZP_15 = cond(dl_14);
	P_62 = SLICE(SZP_15, bool, 5);
	if (dl_14 != 0x00)
	{
		do
		{
			eax_25 = ϕ(eax, eax_26);
			dl_22 = ϕ(dl_14, dl_29);
			ecx_19 = ϕ(ecx_13, ecx_24);
			ebx_20 = ecx_19 * 0x09;
			ebx_21 = ecx_19 + ebx_20 * 0x02;
			ecx_23 = CONVERT(dl_22, byte, int32);
			ecx_24 = ecx_23 + ebx_21;
			eax_26 = eax_25 + 0x01;
			edx_28 = CONVERT(Mem10[eax_26 + 0x00:byte], byte, word32);
			dl_29 = SLICE(edx_28, byte, 0);
			SZP_30 = cond(dl_29);
			P_63 = SLICE(SZP_30, bool, 5);
		} while (dl_29 != 0x00);
	}
	P_61 = ϕ(P_62, P_63);
	ecx_35 = ϕ(ecx_13, ecx_24);
	edx_eax_37 = ecx_35 *u64 0x4EC4EC4F;
	edx_38 = SLICE(edx_eax_37, word32, 32);
	edx_41 = (edx_38 >>u 0x02) + (edx_38 >>u 0x02) * 0x02;
	eax_42 = (edx_38 >>u 0x02) + edx_41 * 0x04;
	ecx_43 = ecx_35 - eax_42;
	SCZO_44 = cond(ecx_43);
	C_59 = SLICE(SCZO_44, bool, 1);
	O_60 = SLICE(SCZO_44, bool, 4);
	S_64 = SLICE(SCZO_44, bool, 0);
	Z_67 = SLICE(SCZO_44, bool, 2);
	eax_45 = ecx_43;
}

// 0806E820: define caml_named_value
// Called from:
//      unix_error
//      caml_fatal_uncaught_exception
define caml_named_value
{
	ptr32 fp;
	word32 dwArg04;
	Top_3 = 0;
	hash_value_name();
	ebx_26 = 0x08083960[eax_18 * 0x04];
	SZP_27 = cond(ebx_26);
	P_88 = SLICE(SZP_27, bool, 5);
	if (ebx_26 != 0x00)
	{
		do
		{
			ebx_31 = ϕ(ebx_26, ebx_42);
			eax_32 = ebx_31 + 8;
			eax_37 = strcmp(dwArg04, eax_32);
			SZP_38 = cond(eax_37);
			P_86 = SLICE(SZP_38, bool, 5);
			if (eax_37 == 0x00)
			{
				eax_48 = ebx_31;
				goto l0806E860;
			}
			ebx_42 = Mem36[ebx_31 + 4:word32];
			SZP_43 = cond(ebx_42);
			P_89 = SLICE(SZP_43, bool, 5);
		} while (ebx_42 != 0x00);
	}
	P_87 = ϕ(P_88, P_89);
	eax_47 = 0x00;
l0806E860:
	P_85 = ϕ(P_86, P_87);
	eax_77 = ϕ(eax_48, eax_47);
	SCZO_52 = cond(fp - 0x0C);
	C_76 = SLICE(SCZO_52, bool, 1);
	O_84 = SLICE(SCZO_52, bool, 4);
	S_90 = SLICE(SCZO_52, bool, 0);
	Z_94 = SLICE(SCZO_52, bool, 2);
}

// 0806E867: define caml_register_named_value
define caml_register_named_value
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 44;
	SCZO = cond(esp);
	esi = Mem0[ebp + 8:word32];
	eax = esi;
	hash_value_name();
	Mem0[ebp + -28:word32] = eax;
	ebx = 0x08083960[eax * 0x04];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	while (Test(NE,Z))
	{
		eax = ebx + 8;
		Mem0[esp + 4:word32] = eax;
		Mem0[esp + 0x00:word32] = esi;
		eax = strcmp(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			eax = Mem0[ebp + 0x0C:word32];
			Mem0[ebx + 0x00:word32] = eax;
			goto l0806E8F3;
		}
		ebx = Mem0[ebx + 4:word32];
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
	}
	edi = esi;
	eax = 0x00;
	ecx = ~0x00;
	size = strlen(edi) + 1;
	ecx -= size;
	edi += size;
	ecx = ~ecx;
	ecx += 11;
	SCZO = cond(ecx);
	Mem0[esp + 0x00:word32] = ecx;
	caml_stat_alloc();
	ebx = eax;
	Mem0[esp + 4:word32] = esi;
	eax += 8;
	Mem0[esp + 0x00:word32] = eax;
	eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	edx = Mem0[ebp + 0x0C:word32];
	Mem0[ebx + 0x00:word32] = edx;
	eax = 0x08083960;
	ecx = Mem0[ebp + -28:word32];
	edx = eax[ecx * 0x04];
	Mem0[ebx + 4:word32] = edx;
	eax[ecx * 0x04] = ebx;
	Mem0[esp + 0x00:word32] = ebx;
	caml_register_global_root();
l0806E8F3:
	eax = 0x01;
	esp += 44;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E900: define caml_callback3
define caml_callback3
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 20:word32];
	Mem0[esp + 0x0C:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	fn08070AF8();
	edx = eax;
	edx &= 0x03;
	SCZO = cond(edx - 0x02);
	if (Test(EQ,Z))
	{
		eax &= ~0x03;
		SZ = cond(eax);
		O = false;
		C = false;
		Mem0[esp + 0x00:word32] = eax;
		caml_raise();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E93D: define caml_callback2
define caml_callback2
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	fn08070ADC();
	edx = eax;
	edx &= 0x03;
	SCZO = cond(edx - 0x02);
	if (Test(EQ,Z))
	{
		eax &= ~0x03;
		SZ = cond(eax);
		O = false;
		C = false;
		Mem0[esp + 0x00:word32] = eax;
		caml_raise();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E973: define caml_callback
define caml_callback
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	fn08070AC8();
	edx = eax;
	edx &= 0x03;
	SCZO = cond(edx - 0x02);
	if (Test(EQ,Z))
	{
		eax &= ~0x03;
		SZ = cond(eax);
		O = false;
		C = false;
		Mem0[esp + 0x00:word32] = eax;
		caml_raise();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806E9A2: define caml_callbackN_exn
// Called from:
//      caml_callbackN
define caml_callbackN_exn
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x9C;
	edi = Mem0[ebp + 0x0C:word32];
	esi = Mem0[ebp + 16:word32];
	eax = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -0x008C:word32] = eax;
	eax = ebp - 0x007C;
	Mem0[0x0807D294<p32>:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[ebp + -92:word32] = eax;
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(GT,SZO))
	{
		edx = Mem0[ebp + -0x008C:word32];
		Mem0[ebp + -56:word32] = edx;
		Mem0[ebp + -48:word32] = 0x01;
		Mem0[ebp + -52:word32] = 0x01;
		eax = ebp + 8;
		Mem0[ebp + -44:word32] = eax;
		eax = ebp - 56;
		Mem0[ebp + -88:word32] = eax;
		Mem0[ebp + -80:word32] = edi;
		Mem0[ebp + -84:word32] = 0x01;
		Mem0[ebp + -76:word32] = esi;
		eax = ebp - 88;
		Mem0[ebp + -0x007C:word32] = eax;
		Mem0[ebp + -116:word32] = 0x01;
		Mem0[ebp + -0x0078:word32] = 0x01;
		eax = ebp - 92;
		Mem0[ebp + -112:word32] = eax;
		ebx = 0x00;
		do
		{
			eax = edi;
			eax -= ebx;
			SCZO = cond(eax - 0x01);
			if (Test(NE,Z))
			{
				SCZO = cond(eax - 0x02);
				if (Test(EQ,Z))
				{
					eax = (esi + 4)[ebx * 0x04];
					Mem0[esp + 8:word32] = eax;
					eax = esi[ebx * 0x04];
					Mem0[esp + 4:word32] = eax;
					eax = Mem0[ebp + -92:word32];
					Mem0[esp + 0x00:word32] = eax;
					fn08070ADC();
					edx = eax;
					edx &= 0x03;
					SCZO = cond(edx - 0x02);
					if (Test(EQ,Z))
					{
						edx = Mem0[ebp + -0x008C:word32];
						Mem0[0x0807D294<p32>:word32] = edx;
						goto l0806EAF9;
					}
					Mem0[ebp + -92:word32] = eax;
					ebx += 0x02;
					SCZO = cond(ebx);
				}
				else
				{
					eax = (esi + 8)[ebx * 0x04];
					Mem0[esp + 0x0C:word32] = eax;
					eax = (esi + 4)[ebx * 0x04];
					Mem0[esp + 8:word32] = eax;
					eax = esi[ebx * 0x04];
					Mem0[esp + 4:word32] = eax;
					eax = Mem0[ebp + -92:word32];
					Mem0[esp + 0x00:word32] = eax;
					fn08070AF8();
					edx = eax;
					edx &= 0x03;
					SCZO = cond(edx - 0x02);
					if (Test(EQ,Z))
					{
						edx = Mem0[ebp + -0x008C:word32];
						Mem0[0x0807D294<p32>:word32] = edx;
						goto l0806EAF9;
					}
					Mem0[ebp + -92:word32] = eax;
					ebx += 0x03;
					SCZO = cond(ebx);
				}
			}
			else
			{
				eax = esi[ebx * 0x04];
				Mem0[esp + 4:word32] = eax;
				eax = Mem0[ebp + -92:word32];
				Mem0[esp + 0x00:word32] = eax;
				fn08070AC8();
				edx = eax;
				edx &= 0x03;
				SCZO = cond(edx - 0x02);
				if (Test(EQ,Z))
				{
					edx = Mem0[ebp + -0x008C:word32];
					Mem0[0x0807D294<p32>:word32] = edx;
					goto l0806EAF9;
				}
				Mem0[ebp + -92:word32] = eax;
				++ebx;
				SCZO = cond(ebx);
			}
			SCZO = cond(edi - ebx);
		} while (Test(GT,SZO));
	}
	eax = Mem0[ebp + -0x008C:word32];
	Mem0[0x0807D294<p32>:word32] = eax;
	eax = Mem0[ebp + -92:word32];
l0806EAF9:
	esp += 0x9C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806EB04: define caml_callbackN
define caml_callbackN
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 8:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_callbackN_exn();
	edx = eax;
	edx &= 0x03;
	SCZO = cond(edx - 0x02);
	if (Test(EQ,Z))
	{
		eax &= ~0x03;
		SZ = cond(eax);
		O = false;
		C = false;
		Mem0[esp + 0x00:word32] = eax;
		caml_raise();
	}
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806EB40: define caml_weak_check
define caml_weak_check
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	++eax;
	SCZO = cond(eax);
	if (Test(NE,Z))
	{
		edx = Mem0[ebp + 8:word32];
		ecx = Mem0[edx + -4:word32];
		ecx >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(ULT,C))
		{
l0806EB69:
			eax = edx[eax * 0x04];
			SCZO = cond(eax - Mem0[0x0807D0A4<p32>:word32]);
			al = CONVERT(Test(NE,Z), bool, int8);
			eax = CONVERT(al, byte, word32);
			eax = eax + 1 + eax;
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 0x00:word32] = 0x08072298;
	caml_invalid_argument();
	goto l0806EB69;
}

// 0806EB7E: define do_set
// Called from:
//      caml_weak_blit
//      caml_weak_set
define do_set
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	SZP = cond(cl & 0x01);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		SCZO = cond(ecx - Mem0[0x08080410<p32>:word32]);
		if (Test(ULT,C))
		{
			SCZO = cond(ecx - Mem0[0x0808040C<p32>:word32]);
			if (Test(UGT,CZ))
			{
				ebx = eax + edx * 0x04;
				eax = Mem0[ebx + 0x00:word32];
				Mem0[ebx + 0x00:word32] = ecx;
				SZP = cond(al & 0x01);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
					SCZO = cond(eax - Mem0[0x08080410<p32>:word32]);
					if (Test(ULT,C))
					{
						SCZO = cond(eax - Mem0[0x0808040C<p32>:word32]);
						if (Test(UGT,CZ))
							goto l0806EBE1;
					}
				}
				eax = Mem0[0x08080444<p32>:word32];
				SCZO = cond(eax - Mem0[0x08080448<p32>:word32]);
				if (Test(UGE,C))
				{
					Mem0[esp + 0x00:word32] = 0x08080438;
					caml_realloc_ref_table();
				}
				eax = 0x08080444;
				edx = Mem0[eax + 0x00:word32];
				Mem0[edx + 0x00:word32] = ebx;
				edx += 0x04;
				SCZO = cond(edx);
				Mem0[eax + 0x00:word32] = edx;
l0806EBE1:
				esp += 0x14;
				SCZO = cond(esp);
				ebx = Mem0[esp + 0x00:word32];
				esp += 4;
				ebp = Mem0[esp + 0x00:word32];
				esp += 4;
				return;
			}
		}
	}
	eax[edx * 0x04] = ecx;
	goto l0806EBE1;
}

// 0806EBE7: define caml_weak_blit
define caml_weak_blit
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x5C;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[ebp + -40:word32] = eax;
	esi = eax;
	++esi;
	SCZO = cond(esi);
	if (Test(NE,Z))
	{
		eax = Mem0[ebp + 24:word32];
		eax >>= 0x01;
		Mem0[ebp + -28:word32] = eax;
		edi = Mem0[ebp + 8:word32];
		edx = eax;
		edx += esi;
		eax = Mem0[edi + -4:word32];
		eax >>= 0x0A;
		SCZO = cond(edx - eax);
		if (Test(ULE,CZ))
		{
l0806EC24:
			eax = Mem0[ebp + 20:word32];
			eax >>= 0x01;
			Mem0[ebp + -36:word32] = eax;
			++eax;
			SCZO = cond(eax);
			Mem0[ebp + -32:word32] = eax;
			if (Test(NE,Z))
			{
				eax = Mem0[ebp + -28:word32];
				eax += Mem0[ebp + -32:word32];
				ecx = Mem0[ebp + 16:word32];
				edx = Mem0[ecx + -4:word32];
				edx >>= 0x0A;
				SCZO = cond(eax - edx);
				if (Test(ULE,CZ))
				{
l0806EC53:
					SCZO = cond(Mem0[0x08083FDC<p32>:word32] - 0x00);
					if (Test(EQ,Z))
					{
						SCZO = cond(Mem0[0x08083FC8<p32>:word32] - 11);
						if (Test(EQ,Z))
						{
							SCZO = cond(Mem0[ebp + -28:word32] - 0x00);
							if (Test(NE,Z))
							{
								edx = 0x00;
								eax = 0x00;
								Mem0[ebp + -76:word32] = esi;
								do
								{
									edx += Mem0[ebp + -76:word32];
									edx = edi + edx * 0x04;
									ebx = Mem0[edx + 0x00:word32];
									ecx = Mem0[0x0807D0A4<p32>:word32];
									SCZO = cond(ebx - ecx);
									if (Test(NE,Z))
									{
										SZP = cond(bl & 0x01);
										O = false;
										C = false;
										if (Test(EQ,Z))
										{
											Mem0[ebp + -48:word32] = ebx;
											esi = ebx;
											esi >>= 0x17;
											ebx >>= 0x0C;
											ebx &= 0x07FF;
											esi = 0x08084000[esi * 0x04];
											SZP = cond(Mem0[esi + ebx:byte] & 0x01);
											O = false;
											C = false;
											if (Test(NE,Z))
											{
												ebx = Mem0[ebp + -48:word32];
												SZP = cond(Mem0[ebx + -4:word32] & 0x0300);
												O = false;
												C = false;
												if (Test(EQ,Z))
													Mem0[edx + 0x00:word32] = ecx;
											}
										}
									}
									++eax;
									edx = eax;
									SCZO = cond(Mem0[ebp + -28:word32] - eax);
								} while (Test(UGT,CZ));
								esi = Mem0[ebp + -76:word32];
							}
						}
					}
					SCZO = cond(esi - Mem0[ebp + -32:word32]);
					if (Test(UGT,CZ))
					{
						SCZO = cond(Mem0[ebp + -28:word32] - 0x00);
						if (Test(NE,Z))
						{
							edx = 0x00;
							ebx = 0x00;
							do
							{
								eax = edx + esi;
								ecx = edi[eax * 0x04];
								edx += Mem0[ebp + -32:word32];
								SCZO = cond(edx);
								eax = Mem0[ebp + 16:word32];
								do_set();
								++ebx;
								edx = ebx;
								SCZO = cond(Mem0[ebp + -28:word32] - ebx);
							} while (Test(UGT,CZ));
						}
					}
					else
					{
						esi = Mem0[ebp + -28:word32];
						--esi;
						SCZO = cond(esi);
						Mem0[ebp + -32:word32] = esi;
						if (Test(NS,S))
						{
							eax = Mem0[ebp + -28:word32];
							eax += Mem0[ebp + -40:word32];
							ebx = edi + eax * 0x04;
							esi = Mem0[ebp + -28:word32];
							esi += Mem0[ebp + -36:word32];
							SCZO = cond(esi);
							edi = Mem0[ebp + -32:word32];
							do
							{
								ecx = Mem0[ebx + 0x00:word32];
								edx = esi;
								eax = Mem0[ebp + 16:word32];
								do_set();
								ebx -= 0x04;
								--esi;
								--edi;
								SCZO = cond(edi);
							} while (Test(NS,S));
						}
					}
					eax = 0x01;
					esp += 0x5C;
					SCZO = cond(esp);
					ebx = Mem0[esp + 0x00:word32];
					esp += 4;
					esi = Mem0[esp + 0x00:word32];
					esp += 4;
					edi = Mem0[esp + 0x00:word32];
					esp += 4;
					ebp = Mem0[esp + 0x00:word32];
					esp += 4;
					return;
				}
			}
			Mem0[esp + 0x00:word32] = 0x080722A1;
			caml_invalid_argument();
			goto l0806EC53;
		}
	}
	Mem0[esp + 0x00:word32] = 0x080722A1;
	caml_invalid_argument();
	goto l0806EC24;
}

// 0806ED3B: define caml_weak_set
define caml_weak_set
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	eax = Mem0[ebp + 8:word32];
	ecx = Mem0[ebp + 16:word32];
	edx = Mem0[ebp + 0x0C:word32];
	edx >>= 0x01;
	++edx;
	SCZO = cond(edx);
	if (Test(NE,Z))
	{
		esi = eax;
		ebx = Mem0[eax + -4:word32];
		ebx >>= 0x0A;
		SCZO = cond(edx - ebx);
		if (Test(ULT,C))
		{
l0806ED6F:
			SCZO = cond(ecx - 0x01);
			if (Test(NE,Z))
			{
				SZP = cond(cl & 0x01);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
					ecx = Mem0[ecx + 0x00:word32];
					do_set();
l0806ED8A:
					eax = 0x01;
					ebx = Mem0[ebp + -8:word32];
					esi = Mem0[ebp + -4:word32];
					esp = ebp;
					ebp = Mem0[esp + 0x00:word32];
					esp += 4;
					return;
				}
			}
			eax = Mem0[0x0807D0A4<p32>:word32];
			esi[edx * 0x04] = eax;
			goto l0806ED8A;
		}
	}
	Mem0[esp + 0x00:word32] = 134685355;
	caml_invalid_argument();
	goto l0806ED6F;
}

// 0806ED99: define caml_weak_get_copy
define caml_weak_get_copy
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -56:word32] = ebx;
	eax = ebp - 56;
	Mem0[ebp + -48:word32] = 0x01;
	Mem0[ebp + -52:word32] = 0x02;
	edx = ebp + 8;
	Mem0[ebp + -44:word32] = edx;
	edx = ebp + 0x0C;
	Mem0[ebp + -40:word32] = edx;
	esi = Mem0[ebp + 0x0C:word32];
	esi >>= 0x01;
	Mem0[ebp + -60:word32] = 0x00;
	Mem0[ebp + -64:word32] = 0x00;
	Mem0[ebp + -96:word32] = eax;
	eax = ebp - 96;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -88:word32] = 0x01;
	Mem0[ebp + -92:word32] = 0x02;
	eax = ebp - 60;
	Mem0[ebp + -84:word32] = eax;
	eax = ebp - 64;
	Mem0[ebp + -80:word32] = eax;
	++esi;
	SCZO = cond(esi);
	if (Test(NE,Z))
	{
		eax = Mem0[ebp + 8:word32];
		edx = Mem0[eax + -4:word32];
		edx >>= 0x0A;
		SCZO = cond(esi - edx);
		if (Test(ULT,C))
		{
l0806EE1E:
			esi <<= 0x02;
			eax = Mem0[esi + eax:word32];
			SCZO = cond(eax - Mem0[0x0807D0A4<p32>:word32]);
			if (Test(EQ,Z))
			{
				Mem0[0x0807D294<p32>:word32] = ebx;
				eax = 0x01;
				goto l0806F003;
			}
			SZP = cond(al & 0x01);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				edi = eax;
				ecx = eax;
				ecx >>= 0x17;
				edx = eax;
				edx >>= 0x0C;
				edx &= 0x07FF;
				ecx = 0x08084000[ecx * 0x04];
				SZP = cond(Mem0[ecx + edx:byte] & 0x03);
				O = false;
				C = false;
				if (Test(NE,Z))
				{
					edi -= 0x04;
					eax = CONVERT(Mem0[edi + 0x00:byte], byte, word32);
					Mem0[esp + 4:word32] = eax;
					eax = Mem0[edi + 0x00:word32];
					eax >>= 0x0A;
					SCZO = cond(eax);
					Mem0[esp + 0x00:word32] = eax;
					caml_alloc();
					Mem0[ebp + -64:word32] = eax;
					edx = Mem0[ebp + 8:word32];
					edx = Mem0[esi + edx:word32];
					SCZO = cond(edx - Mem0[0x0807D0A4<p32>:word32]);
					if (Test(EQ,Z))
					{
						Mem0[0x0807D294<p32>:word32] = ebx;
						eax = 0x01;
						goto l0806F003;
					}
					Mem0[ebp + -116:word32] = edx;
					ecx = edx - 4;
					SCZO = cond(Mem0[ecx + 0x00:byte] - ~0x05);
					if (Test(ULE,CZ))
					{
						Mem0[ebp + -112:word32] = ecx;
						eax = Mem0[ecx + 0x00:word32];
						eax >>= 0x0A;
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(NE,Z))
						{
							esi = 0x00;
							Mem0[ebp + -0x0078:word32] = ebx;
							do
							{
								edi = 0x00 + esi * 0x04;
								eax = Mem0[ebp + -116:word32];
								ebx = eax[esi * 0x04];
								SCZO = cond(Mem0[0x08083FDC<p32>:word32] - 0x00);
								if (Test(EQ,Z))
								{
									SZP = cond(bl & 0x01);
									O = false;
									C = false;
									if (Test(EQ,Z))
									{
										edx = ebx;
										edx >>= 0x17;
										eax = ebx;
										eax >>= 0x0C;
										eax &= 0x07FF;
										edx = 0x08084000[edx * 0x04];
										SZP = cond(Mem0[edx + eax:byte] & 0x01);
										O = false;
										C = false;
										if (Test(NE,Z))
										{
											Mem0[esp + 4:word32] = 0x00;
											Mem0[esp + 0x00:word32] = ebx;
											caml_darken();
										}
									}
								}
								eax = edi;
								eax += Mem0[ebp + -64:word32];
								edx = Mem0[eax + 0x00:word32];
								Mem0[ebp + -0x006C:word32] = edx;
								Mem0[eax + 0x00:word32] = ebx;
								eax = edi;
								eax += Mem0[ebp + -64:word32];
								edx = eax;
								edx >>= 0x17;
								eax >>= 0x0C;
								eax &= 0x07FF;
								edx = 0x08084000[edx * 0x04];
								SZP = cond(Mem0[edx + eax:byte] & 0x01);
								O = false;
								C = false;
								if (Test(NE,Z))
								{
									SCZO = cond(Mem0[0x08083FDC<p32>:word32] - 0x00);
									if (Test(EQ,Z))
									{
										Mem0[esp + 4:word32] = 0x00;
										eax = Mem0[ebp + -0x006C:word32];
										Mem0[esp + 0x00:word32] = eax;
										caml_darken();
									}
									SZP = cond(bl & 0x01);
									O = false;
									C = false;
									if (Test(NE,Z))
										goto l0806EFA9;
									eax = Mem0[0x08080410<p32>:word32];
									SCZO = cond(ebx - eax);
									if (Test(UGE,C))
										goto l0806EFA9;
									edx = Mem0[0x0808040C<p32>:word32];
									SCZO = cond(ebx - edx);
									if (Test(ULE,CZ))
										goto l0806EFA9;
									SZP = cond(Mem0[ebp + -0x006C:byte] & 0x01);
									O = false;
									C = false;
									if (Test(EQ,Z))
									{
										ecx = Mem0[ebp + -0x006C:word32];
										SCZO = cond(eax - ecx);
										if (Test(ULE,CZ))
											goto l0806EF7D;
										SCZO = cond(edx - ecx);
										if (Test(UGE,C))
											goto l0806EF7D;
									}
									else
									{
l0806EF7D:
										edx = 0x08080428;
										eax = Mem0[edx + 0x00:word32];
										SCZO = cond(eax - Mem0[0x0808042C<p32>:word32]);
										if (Test(UGE,C))
										{
											Mem0[esp + 0x00:word32] = 0x0808041C;
											caml_realloc_ref_table();
										}
										edx = 0x08080428;
										eax = Mem0[edx + 0x00:word32];
										edi += Mem0[ebp + -64:word32];
										Mem0[eax + 0x00:word32] = edi;
										eax += 0x04;
										SCZO = cond(eax);
										Mem0[edx + 0x00:word32] = eax;
									}
								}
l0806EFA9:
								++esi;
								edx = Mem0[ebp + -112:word32];
								eax = Mem0[edx + 0x00:word32];
								eax >>= 0x0A;
								SCZO = cond(eax - esi);
							} while (Test(UGT,CZ));
							ebx = Mem0[ebp + -0x0078:word32];
						}
					}
					else
					{
						ecx = Mem0[ecx + 0x00:word32];
						ecx >>= 0x0A;
						ecx <<= 0x02;
						SCZO = cond(ecx);
						Mem0[esp + 8:word32] = ecx;
						Mem0[esp + 4:word32] = edx;
						Mem0[esp + 0x00:word32] = eax;
						eax = memmove(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 void)], Mem0[esp + 8:size_t]);
					}
l0806EFDE:
					Mem0[esp + 4:word32] = 0x00;
					Mem0[esp + 0x00:word32] = 0x01;
					caml_alloc_small();
					Mem0[ebp + -60:word32] = eax;
					edx = Mem0[ebp + -64:word32];
					Mem0[eax + 0x00:word32] = edx;
					Mem0[0x0807D294<p32>:word32] = ebx;
					eax = Mem0[ebp + -60:word32];
l0806F003:
					esp += 0x7C;
					SCZO = cond(esp);
					ebx = Mem0[esp + 0x00:word32];
					esp += 4;
					esi = Mem0[esp + 0x00:word32];
					esp += 4;
					edi = Mem0[esp + 0x00:word32];
					esp += 4;
					ebp = Mem0[esp + 0x00:word32];
					esp += 4;
					return;
				}
			}
			Mem0[ebp + -64:word32] = eax;
			goto l0806EFDE;
		}
	}
	Mem0[esp + 0x00:word32] = 0x08072298;
	caml_invalid_argument();
	goto l0806EE1E;
}

// 0806F00B: define caml_weak_get
define caml_weak_get
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 100;
	ebx = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -40:word32] = ebx;
	Mem0[ebp + -32:word32] = 0x01;
	Mem0[ebp + -36:word32] = 0x02;
	eax = ebp + 8;
	Mem0[ebp + -28:word32] = eax;
	eax = ebp + 0x0C;
	Mem0[ebp + -24:word32] = eax;
	eax = Mem0[ebp + 0x0C:word32];
	eax >>= 0x01;
	Mem0[ebp + -44:word32] = 0x00;
	Mem0[ebp + -48:word32] = 0x00;
	edx = ebp - 40;
	Mem0[ebp + -80:word32] = edx;
	edx = ebp - 80;
	Mem0[0x0807D294<p32>:word32] = edx;
	Mem0[ebp + -72:word32] = 0x01;
	Mem0[ebp + -76:word32] = 0x02;
	edx = ebp - 44;
	Mem0[ebp + -0x0044:word32] = edx;
	edx = ebp - 48;
	Mem0[ebp + -64:word32] = edx;
	++eax;
	SCZO = cond(eax);
	if (Test(NE,Z))
	{
		edx = Mem0[ebp + 8:word32];
		ecx = Mem0[edx + -4:word32];
		ecx >>= 0x0A;
		SCZO = cond(eax - ecx);
		if (Test(ULT,C))
		{
l0806F08F:
			eax = edx[eax * 0x04];
			SCZO = cond(eax - Mem0[0x0807D0A4<p32>:word32]);
			if (Test(EQ,Z))
				Mem0[ebp + -44:word32] = 0x01;
			else
			{
				Mem0[ebp + -48:word32] = eax;
				SCZO = cond(Mem0[0x08083FDC<p32>:word32] - 0x00);
				if (Test(EQ,Z))
				{
					SZP = cond(al & 0x01);
					O = false;
					C = false;
					if (Test(EQ,Z))
					{
						ecx = eax;
						ecx >>= 0x17;
						edx = eax;
						edx >>= 0x0C;
						edx &= 0x07FF;
						ecx = 0x08084000[ecx * 0x04];
						SZP = cond(Mem0[ecx + edx:byte] & 0x01);
						O = false;
						C = false;
						if (Test(NE,Z))
						{
							Mem0[esp + 4:word32] = 0x00;
							Mem0[esp + 0x00:word32] = eax;
							caml_darken();
						}
					}
				}
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = 0x01;
				caml_alloc_small();
				Mem0[ebp + -44:word32] = eax;
				edx = Mem0[ebp + -48:word32];
				Mem0[eax + 0x00:word32] = edx;
			}
			Mem0[0x0807D294<p32>:word32] = ebx;
			eax = Mem0[ebp + -44:word32];
			esp += 100;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 0x00:word32] = 0x08072298;
	caml_invalid_argument();
	goto l0806F08F;
}

// 0806F10B: define caml_weak_create
define caml_weak_create
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x14;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	ebx = eax + 1;
	SCZO = cond(eax - 0x003FFFFE);
	if (Test(UGT,CZ))
	{
		Mem0[esp + 0x00:word32] = 0x080722B4;
		caml_invalid_argument();
	}
	Mem0[esp + 4:word32] = 0xFB;
	Mem0[esp + 0x00:word32] = ebx;
	caml_alloc_shr();
	SCZO = cond(ebx - 0x01);
	if (Test(UGT,CZ))
	{
		edx = 0x01;
		do
		{
			ecx = Mem0[0x0807D0A4<p32>:word32];
			eax[edx * 0x04] = ecx;
			++edx;
			SCZO = cond(ebx - edx);
		} while (Test(UGT,CZ));
	}
	edx = Mem0[0x08083994<p32>:word32];
	Mem0[eax + 0x00:word32] = edx;
	Mem0[0x08083994<p32>:word32] = eax;
	esp += 0x14;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806F170: define invert_pointer_at
// Called from:
//      invert_root
//      caml_compact_heap
define invert_pointer_at
{
	word32 eax;
	word32 edx;
	Top_3 = 0;
	ecx_16 = Mem14[eax + 0x00:word32];
	cl_17 = SLICE(ecx_16, byte, 0);
	SZP_18 = cond(cl_17 & 0x03);
	Z_21 = SLICE(SZP_18, bool, 2);
	P_169 = SLICE(SZP_18, bool, 5);
	S_176 = SLICE(SZP_18, bool, 0);
	O_19 = false;
	C_20 = false;
	if ((cl_17 & 0x03) == 0x00)
	{
		edx_26 = ecx_16 >>u 0x0C & 0x07FF;
		ebx_27 = 0x08084000[(ecx_16 >>u 0x17) * 0x04];
		SZP_28 = cond(Mem14[ebx_27 + edx_26:byte] & 0x01);
		Z_31 = SLICE(SZP_28, bool, 2);
		P_170 = SLICE(SZP_28, bool, 5);
		S_177 = SLICE(SZP_28, bool, 0);
		O_29 = false;
		C_30 = false;
		if ((Mem14[ebx_27 + edx_26:byte] & 0x01) == 0x00)
			goto l0806F252;
		edi_33 = Mem14[ecx_16 + -4:word32];
		edx_35 = edi_33 & 0x03;
		if ((edi_33 & 0x03) != 0x01)
		{
			SCZO_106 = cond((edi_33 & 0x03) - 0x01);
			C_107 = SLICE(SCZO_106, bool, 1);
			O_167 = SLICE(SCZO_106, bool, 4);
			S_180 = SLICE(SCZO_106, bool, 0);
			Z_190 = SLICE(SCZO_106, bool, 2);
			if ((edi_33 & 0x03) <u 0x01)
			{
l0806F1D1:
				Z_189 = ϕ(Z_190, Z_117);
				S_179 = ϕ(S_180, S_178);
				O_166 = ϕ(O_167, O_165);
				C_157 = ϕ(C_107, C_156);
				Mem120[eax + 0x00:word32] = edi_33;
				Mem122[ecx_16 + -4:word32] = eax;
				goto l0806F252;
			}
			if ((edi_33 & 0x03) != 0x02)
			{
				SCZO_116 = cond((edi_33 & 0x03) - 0x03);
				Z_117 = SLICE(SCZO_116, bool, 2);
				C_156 = SLICE(SCZO_116, bool, 1);
				O_165 = SLICE(SCZO_116, bool, 4);
				S_178 = SLICE(SCZO_116, bool, 0);
				if ((edi_33 & 0x03) == 0x03)
					goto l0806F1D1;
			}
			else
			{
				Mem110[eax + 0x00:word32] = edi_33;
				eax_111 = eax | 0x02;
				SZ_112 = cond(eax | 0x02);
				S_181 = SLICE(SZ_112, bool, 0);
				Z_191 = SLICE(SZ_112, bool, 2);
				O_113 = false;
				C_114 = false;
				Mem115[ecx_16 + -4:word32] = eax | 0x02;
			}
		}
		else
		{
			edi_39 = edi_33 >>u 0x0A << 0x02;
			edx_41 = ecx_16 - edi_39;
			dwLoc18_136 = edx_41 - 4;
			edx_45 = Mem44[edx_41 + -4:word32];
			dl_46 = SLICE(edx_45, byte, 0);
			SZP_47 = cond(dl_46 & 0x03);
			P_173 = SLICE(SZP_47, bool, 5);
			if ((dl_46 & 0x03) == 0x00)
			{
				do
				{
					edx_51 = ϕ(edx_45, edx_54);
					edx_54 = Mem44[edx_51 + 0x00:word32];
					dl_55 = SLICE(edx_54, byte, 0);
					SZP_56 = cond(dl_55 & 0x03);
					P_174 = SLICE(SZP_56, bool, 5);
				} while ((dl_55 & 0x03) == 0x00);
				dwLoc18_137 = edx_51;
			}
			P_172 = ϕ(P_173, P_174);
			dwLoc18_138 = ϕ(dwLoc18_136, dwLoc18_137);
			edx_62 = ϕ(edx_45, edx_54);
			ebx_64 = edx_62 >>u 0x02;
			bl_65 = SLICE(ebx_64, byte, 0);
			if (bl_65 == ~0x08)
			{
				Mem93[eax + 0x00:word32] = edx_62;
				Mem95[ecx_16 + -4:word32] = eax | 0x02;
				ecx_96 = ecx_16 - edx_41;
				ecx_97 = ecx_96 >>u 0x02;
				eax_98 = (ecx_96 >>u 0x02) - 1;
				eax_100 = eax_98 << 0x0A | 999;
				SZ_101 = cond(eax_100);
				S_182 = SLICE(SZ_101, bool, 0);
				Z_192 = SLICE(SZ_101, bool, 2);
				O_102 = false;
				C_103 = false;
				edx_104 = dwLoc18_138;
				Mem105[dwLoc18_138 + 0x00:word32] = eax_100;
			}
			else
			{
				edx_68 = edx_62 >>u 0x0A;
				edx_71 = edx_41 + edx_68 * 0x04;
				edx_72 = edx_71 | 0x01;
				Mem75[eax + 0x00:word32] = edx_71 | 0x01;
				Mem79[ecx_16 + -4:word32] = eax | 0x02;
				ecx_82 = ecx_16 - edx_41;
				ecx_83 = ecx_82 >>u 0x02;
				eax_84 = (ecx_82 >>u 0x02) - 1;
				eax_86 = eax_84 << 0x0A | 999;
				SZ_87 = cond(eax_86);
				S_183 = SLICE(SZ_87, bool, 0);
				Z_193 = SLICE(SZ_87, bool, 2);
				O_88 = false;
				C_89 = false;
				Mem92[dwLoc18_138 + 0x00:word32] = eax_86;
			}
		}
	}
l0806F252:
	Z_188 = ϕ(Z_21, Z_31, Z_117, Z_189, Z_191, Z_192, Z_193);
	S_175 = ϕ(S_176, S_177, S_178, S_179, S_181, S_182, S_183);
	P_168 = ϕ(P_169, P_170, P_170, P_170, P_170, P_172, P_172);
	O_164 = ϕ(O_19, O_29, O_165, O_166, O_113, O_102, O_88);
	edx_161 = ϕ(edx, edx_26, edx_35, edx_35, edx_35, edx_104, edx_72);
	ecx_159 = ϕ(ecx_16, ecx_16, ecx_16, ecx_16, ecx_16, ecx_97, ecx_83);
	eax_158 = ϕ(eax, eax, eax, eax, eax_111, eax_100, eax_86);
	C_155 = ϕ(C_20, C_30, C_156, C_157, C_114, C_103, C_89);
}

// 0806F25F: define invert_root
define invert_root
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	eax = Mem0[ebp + 0x0C:word32];
	invert_pointer_at();
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806F26C: define init_compact_allocate
// Called from:
//      caml_compact_heap
define init_compact_allocate
{
	Top_3 = 0;
	eax_8 = Mem6[0x08083FD8<p32>:word32];
	SZP_9 = cond(eax_8);
	Z_12 = SLICE(SZP_9, bool, 2);
	P_34 = SLICE(SZP_9, bool, 5);
	S_37 = SLICE(SZP_9, bool, 0);
	if (eax_8 != 0x00)
	{
		do
		{
			eax_13 = ϕ(eax_8, eax_16);
			eax_14 = eax_13 - 0x10;
			Mem15[eax_14 + 4:word32] = 0x00;
			eax_16 = Mem15[eax_14 + 0x0C:word32];
			SZP_17 = cond(eax_16);
			Z_20 = SLICE(SZP_17, bool, 2);
			P_35 = SLICE(SZP_17, bool, 5);
			S_38 = SLICE(SZP_17, bool, 0);
		} while (eax_16 != 0x00);
	}
	Z_41 = ϕ(Z_12, Z_20);
	S_36 = ϕ(S_37, S_38);
	P_33 = ϕ(P_34, P_35);
	O_32 = false;
	C_31 = false;
	Mem21 = ϕ(Mem6, Mem15);
	eax_22 = Mem21[0x08083FD8<p32>:word32];
	Mem23[0x0808399C<p32>:word32] = eax_22;
}

// 0806F295: define compact_allocate
// Called from:
//      caml_compact_heap
define compact_allocate
{
	word32 eax;
	Top_3 = 0;
	ecx_17 = Mem16[0x0808399C<p32>:word32];
	ebx_19 = Mem16[ecx_17 + -8:word32];
	ebx_20 = ebx_19 - Mem16[ecx_17 + -0x0C:word32];
	if (ebx_20 <=u 0x10)
	{
		esi_23 = Mem16[ecx_17 + -4:word32];
		edx_24 = esi_23 - 16;
		ebx_25 = Mem16[esi_23 + -8:word32];
		ebx_26 = ebx_25 - Mem16[esi_23 + -0x0C:word32];
		if (ebx_26 <=u 0x10)
		{
			ecx_29 = esi_23;
			while (true)
			{
				ecx_43 = ϕ(ecx_29, ecx_39);
				esi_40 = ϕ(esi_23, esi_38);
				edx_30 = ϕ(edx_24, edx_33);
				ebx_32 = Mem16[edx_30 + 0x0C:word32];
				edx_33 = ebx_32 - 16;
				edi_34 = Mem16[ebx_32 + -8:word32];
				edi_35 = edi_34 - Mem16[ebx_32 + -0x0C:word32];
				if (edi_35 >u 0x10)
					break;
				esi_38 = ebx_32;
				ecx_39 = ebx_32;
			}
			Mem41[0x0808399C<p32>:word32] = esi_40;
		}
	}
	Mem45 = ϕ(Mem16, Mem16, Mem41);
	ecx_42 = ϕ(ecx_17, ecx_17, ecx_43);
	edx_44 = ecx_42 - 16;
	ebx_46 = Mem45[edx_44 + 4:word32];
	esi_47 = Mem45[edx_44 + 8:word32];
	esi_48 = esi_47 - ebx_46;
	SCZO_52 = cond(eax - esi_48);
	C_104 = SLICE(SCZO_52, bool, 1);
	O_106 = SLICE(SCZO_52, bool, 4);
	S_109 = SLICE(SCZO_52, bool, 0);
	Z_116 = SLICE(SCZO_52, bool, 2);
	if (eax >u esi_48)
	{
		do
		{
			edx_54 = ϕ(edx_44, edx_57);
			ecx_56 = Mem45[edx_54 + 0x0C:word32];
			edx_57 = ecx_56 - 16;
			ebx_58 = Mem45[ecx_56 + -0x0C:word32];
			esi_59 = Mem45[ecx_56 + -8:word32];
			esi_60 = esi_59 - ebx_58;
			SCZO_62 = cond(esi_60 - eax);
			C_63 = SLICE(SCZO_62, bool, 1);
			O_107 = SLICE(SCZO_62, bool, 4);
			S_110 = SLICE(SCZO_62, bool, 0);
			Z_117 = SLICE(SCZO_62, bool, 2);
		} while (esi_60 <u eax);
	}
	Z_115 = ϕ(Z_116, Z_117);
	S_108 = ϕ(S_109, S_110);
	O_105 = ϕ(O_106, O_107);
	C_103 = ϕ(C_104, C_63);
	ecx_69 = ϕ(ecx_42, ecx_56);
	edx_67 = ϕ(edx_44, edx_57);
	ebx_64 = ϕ(ebx_46, ebx_58);
	eax_66 = ebx_64 + eax;
	Mem68[edx_67 + 4:word32] = eax_66;
	eax_70 = ecx_69 + ebx_64;
}

// 0806F310: define caml_compact_heap
// Called from:
//      caml_gc_compaction
//      test_and_compact
//      caml_compact_heap_maybe
define caml_compact_heap
{
	ptr32 fp;
	word32 edi;
	word32 esi;
	word32 ebx;
	Top_3 = 0;
	caml_gc_message();
	eax_28 = Mem21[0x08083FD8<p32>:word32];
	if (eax_28 != 0x00)
	{
		do
		{
			ebx_99 = ϕ(ebx, ebx_98);
			Mem36 = ϕ(Mem21, Mem76);
			eax_33 = ϕ(eax_28, eax_78);
			edi_34 = eax_33 - 16;
			esi_37 = eax_33 + Mem36[edi_34 + 8:word32];
			if (esi_37 >u eax_33)
			{
				do
				{
					Mem41 = ϕ(Mem36, Mem77);
					eax_40 = ϕ(eax_33, eax_68);
					edx_42 = Mem41[eax_40 + 0x00:word32];
					ebx_46 = edx_42 & 0x0300;
					if ((edx_42 & 0x0300) == 0x0200)
					{
						edx_60 = __align(edx_42, 0x0400);
						Mem65[eax_40 + 0x00:word32] = edx_60 | 1011;
					}
					else
					{
						ebx_50 = __align(edx_42, 0x0400);
						edx_52 = (edx_42 & 0xFF) << 0x02;
						edx_53 = edx_52 | ebx_50;
						Mem58[eax_40 + 0x00:word32] = edx_53 | 0x03;
					}
					ebx_100 = ϕ(ebx_46, ebx_50);
					Mem77 = ϕ(Mem65, Mem58);
					eax_68 = eax_40 + 4 + (edx_42 >>u 0x0A) * 0x04;
				} while (esi_37 >u eax_68);
			}
			ebx_98 = ϕ(ebx_99, ebx_100);
			Mem76 = ϕ(Mem36, Mem77);
			eax_78 = Mem76[edi_34 + 0x0C:word32];
		} while (eax_78 != 0x00);
	}
	ebx_97 = ϕ(ebx, ebx_98);
	esi_95 = ϕ(esi, esi_37);
	edi_94 = ϕ(edi, edi_34);
	caml_do_roots();
	caml_final_do_weak_roots();
	eax_117 = Mem110[0x08083FD8<p32>:word32];
	if (eax_117 != 0x00)
	{
		do
		{
			eax_122 = ϕ(eax_117, eax_228);
			dwLoc20_781 = eax_122;
			eax_125 = eax_122 - 0x10;
			edx_128 = eax_122 + Mem126[eax_125 + 8:word32];
			if (edx_128 >u eax_122)
			{
				do
				{
					dwLoc20_784 = ϕ(dwLoc20_781, dwLoc20_792);
					Mem134 = ϕ(Mem129, Mem222);
					eax_136 = Mem134[dwLoc20_784 + 0x00:word32];
					al_137 = SLICE(eax_136, byte, 0);
					if ((al_137 & 0x03) == 0x00)
					{
						do
						{
							eax_142 = ϕ(eax_136, eax_144);
							eax_144 = Mem134[eax_142 + 0x00:word32];
							al_145 = SLICE(eax_144, byte, 0);
						} while ((al_145 & 0x03) == 0x00);
					}
					eax_150 = ϕ(eax_136, eax_144);
					edi_152 = eax_150 >>u 0x0A;
					edi_153 = edi_152 + 0x01;
					eax_154 = eax_150 >>u 0x02;
					eax_155 = eax_154 & 0xFF;
					if ((eax_154 & 0xFF) == 0xF9)
					{
						eax_162 = dwLoc20_784[(edi_152 + 0x01) * 0x04];
						if ((eax_162 & 0x03) != 0x03)
						{
							do
							{
								eax_167 = ϕ(eax_162, eax_170);
								eax_168 = eax_167 & ~0x03;
								eax_170 = Mem134[eax_168 + 0x00:word32];
							} while ((eax_170 & 0x03) != 0x03);
						}
						eax_175 = ϕ(eax_162, eax_170);
						edi_177 = eax_175 >>u 0x0A;
						edi_178 = edi_177 + 0x01;
						eax_179 = eax_175 >>u 0x02;
						eax_180 = eax_179 & 0xFF;
					}
					edi_187 = ϕ(edi_153, edi_178);
					eax_184 = ϕ(eax_155, eax_180);
					if (eax_184 <=u 0xFA && edi_187 >u 0x01)
					{
						ebx_196 = dwLoc20_784 + 0x04;
						esi_198 = 0x01;
						do
						{
							esi_209 = ϕ(esi_198, esi_210);
							ebx_199 = ϕ(ebx_196, ebx_211);
							invert_pointer_at();
							esi_210 = esi_209 + 0x01;
							ebx_211 = ebx_199 + 0x04;
						} while (edi_187 >u esi_210);
					}
					eax_221 = dwLoc20_784 + edi_187 * 0x04;
					dwLoc20_792 = eax_221;
				} while (edx_128 >u eax_221);
			}
			Mem226 = ϕ(Mem129, Mem222);
			eax_228 = Mem226[eax_125 + 0x0C:word32];
		} while (eax_228 != 0x00);
	}
	Mem233 = ϕ(Mem110, Mem226);
	ecx_234 = Mem233[0x08083994<p32>:word32];
	dwLoc20_810 = ecx_234;
	if (ecx_234 != 0x00)
	{
		dwLoc24_811 = 0x08083994;
		do
		{
			dwLoc24_816 = ϕ(dwLoc24_811, dwLoc24_824);
			dwLoc20_812 = ϕ(dwLoc20_810, dwLoc20_825);
			Mem243 = ϕ(Mem241, Mem309);
			edi_245 = Mem243[dwLoc20_812 + -4:word32];
			if ((edi_245 & 0x03) == 0x00)
			{
				do
				{
					edi_250 = ϕ(edi_252, edi_245);
					edi_252 = Mem243[edi_250 + 0x00:word32];
				} while ((edi_252 & 0x03) == 0x00);
			}
			edi_257 = ϕ(edi_252, edi_245);
			edi_258 = edi_257 >>u 0x0A;
			if (edi_258 >u 0x01)
			{
				ebx_263 = dwLoc20_812 + 0x04;
				esi_265 = 0x01;
				do
				{
					esi_281 = ϕ(esi_265, esi_282);
					ebx_266 = ϕ(ebx_263, ebx_284);
					eax_268 = Mem243[ebx_266 + 0x00:word32];
					if (eax_268 != Mem243[0x0807D0A4<p32>:word32])
						invert_pointer_at();
					esi_282 = esi_281 + 0x01;
					ebx_284 = ebx_266 + 0x04;
				} while (edi_258 >u esi_282);
			}
			invert_pointer_at();
			dwLoc24_824 = dwLoc20_812;
			edx_308 = Mem307[dwLoc20_812 + 0x00:word32];
			dwLoc20_825 = edx_308;
		} while (edx_308 != 0x00);
	}
	ecx_1075 = ϕ(ecx_234, ecx_298);
	Mem320 = ϕ(Mem236, Mem309);
	init_compact_allocate();
	ebx_321 = Mem320[0x08083FD8<p32>:word32];
	if (ebx_321 != 0x00)
	{
		do
		{
			ebx_326 = ϕ(ebx_321, ebx_512);
			ecx_327 = ebx_326 - 16;
			eax_330 = Mem329[ecx_327 + 8:word32];
			eax_331 = eax_330 + ebx_326;
			while (true)
			{
				ecx_1076 = ϕ(ecx_327, ecx_369, ecx_1077);
				ebx_336 = ϕ(ebx_326, ebx_374, ebx_508);
				Mem335 = ϕ(Mem333, Mem371, Mem507);
				if (eax_331 <=u ebx_336)
					break;
				eax_339 = Mem335[ebx_336 + 0x00:word32];
				al_340 = SLICE(eax_339, byte, 0);
				if ((al_340 & 0x03) == 0x00)
				{
					do
					{
						eax_345 = ϕ(eax_339, eax_347);
						eax_347 = Mem335[eax_345 + 0x00:word32];
						al_348 = SLICE(eax_347, byte, 0);
					} while ((al_348 & 0x03) == 0x00);
					esi_355 = (eax_347 >>u 0x0A) + 0x01;
					eax_357 = eax_347 >>u 0x02 & 0xFF;
					dwLoc28_829 = eax_357;
					dwLoc24_830 = 0x00;
					if (eax_357 == 0xF9)
						goto l0806F550;
					goto l0806F584;
				}
				edx_365 = eax_339 >>u 0x02 & 0xFF;
				if (edx_365 == 0xF9)
				{
					esi_377 = (eax_339 >>u 0x0A) + 1;
l0806F550:
					esi_380 = ϕ(esi_377, esi_355);
					esi_381 = ebx_336 + esi_380 * 0x04;
					dwLoc24_831 = esi_381;
					eax_384 = Mem383[esi_381 + 0x00:word32];
					if ((eax_384 & 0x03) != 0x03)
					{
						do
						{
							eax_389 = ϕ(eax_384, eax_392);
							eax_390 = eax_389 & ~0x03;
							eax_392 = Mem383[eax_390 + 0x00:word32];
						} while ((eax_392 & 0x03) != 0x03);
					}
					eax_397 = ϕ(eax_384, eax_392);
					esi_399 = eax_397 >>u 0x0A;
					esi_400 = esi_399 + 0x01;
					eax_401 = eax_397 >>u 0x02;
					dwLoc28_832 = eax_401 & 0xFF;
l0806F584:
					dwLoc24_838 = ϕ(dwLoc24_830, dwLoc24_831);
					dwLoc28_835 = ϕ(dwLoc28_829, dwLoc28_832);
					esi_409 = ϕ(esi_355, esi_400);
					edx_410 = esi_409 * 0x04;
					compact_allocate();
					edx_424 = Mem412[ebx_336 + 0x00:word32];
					dl_425 = SLICE(edx_424, byte, 0);
					if ((dl_425 & 0x03) == 0x00)
					{
						while (true)
						{
							Mem432 = ϕ(Mem412, Mem435);
							edx_431 = ϕ(edx_424, edx_510);
							ecx_433 = Mem432[edx_431 + 0x00:word32];
							cl_436 = SLICE(ecx_433, byte, 0);
							Mem435[edx_431 + 0x00:word32] = eax_414 + 4;
							if ((cl_436 & 0x03) != 0x00)
								break;
							edx_510 = ecx_433;
						}
					}
					esi_443 = esi_409 << 0x0A;
					ecx_447 = dwLoc28_835;
					edx_448 = esi_443 - 0x0400 + dwLoc28_835;
					Mem451[ebx_336 + 0x00:word32] = edx_448;
					if (dwLoc24_838 != 0x00)
					{
						ecx_454 = dwLoc24_838;
						if ((dwLoc24_838 & 0x03) != 0x03)
						{
							do
							{
								Mem462 = ϕ(Mem451, Mem496);
								ecx_459 = ϕ(ecx_454, ecx_497);
								edi_461 = ecx_459 & ~0x03;
								ecx_463 = Mem462[edi_461 + 0x00:word32];
								if ((ecx_463 & 0x03) == 0x02)
								{
									edx_470 = edi_461 - ebx_336;
									esi_475 = eax_414 + 4 + (edx_470 >> 0x02) * 0x04;
									do
									{
										Mem479 = ϕ(Mem462, Mem482);
										ecx_476 = ϕ(ecx_463, ecx_480);
										edx_478 = ecx_476 & ~0x03;
										ecx_480 = Mem479[edx_478 + 0x00:word32];
										Mem482[edx_478 + 0x00:word32] = esi_475;
									} while ((ecx_480 & 0x03) == 0x02);
								}
								ecx_497 = ϕ(ecx_463, ecx_480);
								edx_492 = edi_461 - ebx_336;
								edx_494 = edx_492 >> 0x02 << 0x0A;
								Mem496[edi_461 + 0x00:word32] = edx_494 + 0xF9;
								edx_499 = ecx_497 & 0x03;
							} while (edx_499 != 0x03);
						}
					}
					ecx_1077 = ϕ(ecx_447, ecx_454, ecx_497);
					Mem507 = ϕ(Mem451, Mem451, Mem496);
					ebx_508 = ebx_336 + edx_410;
					continue;
				}
				ecx_369 = eax_339 & ~0x03FF;
				edx_370 = edx_365 + 0x0200 + (eax_339 & ~0x03FF);
				Mem371[ebx_336 + 0x00:word32] = edx_370;
				ebx_374 = ebx_336 + 4 + (eax_339 >>u 0x0A) * 0x04;
			}
			ebx_512 = Mem335[ecx_327 + 0x0C:word32];
		} while (ebx_512 != 0x00);
	}
	ecx_1074 = ϕ(ecx_1075, ecx_1076);
	Mem523 = ϕ(Mem320, Mem335);
	init_compact_allocate();
	ebx_524 = Mem523[0x08083FD8<p32>:word32];
	if (ebx_524 != 0x00)
	{
		do
		{
			ebx_529 = ϕ(ebx_524, ebx_570);
			edx_530 = ebx_529 - 16;
			esi_534 = ebx_529 + Mem532[edx_530 + 8:word32];
			while (true)
			{
				Mem540 = ϕ(Mem532, Mem564, Mem540);
				ebx_537 = ϕ(ebx_529, ebx_566, ebx_549);
				if (esi_534 <=u ebx_537)
					break;
				eax_541 = Mem540[ebx_537 + 0x00:word32];
				ah_542 = SLICE(eax_541, byte, 8);
				if ((ah_542 & 0x03) == 0x00)
				{
					edi_552 = (eax_541 >>u 0x0A) * 0x04 + 0x04;
					compact_allocate();
					memmove(eax_554, ebx_537, edi_552);
					ebx_566 = ebx_537 + edi_552;
				}
				else
					ebx_549 = ebx_537 + 4 + (eax_541 >>u 0x0A) * 0x04;
			}
			ebx_570 = Mem540[edx_530 + 0x0C:word32];
		} while (ebx_570 != 0x00);
		ecx_575 = Mem540[0x08083FD8<p32>:word32];
		if (ecx_575 != 0x00)
		{
			edx_587 = ecx_575;
			eax_588 = 0x00;
			do
			{
				ebx_605 = ϕ(ebx_570, ebx_765);
				eax_599 = ϕ(eax_588, eax_617);
				edx_589 = ϕ(edx_587, edx_610);
				edx_590 = edx_589 - 0x10;
				esi_592 = Mem540[edx_590 + 4:word32];
				if (esi_592 != 0x00)
				{
					eax_600 = eax_599 + (esi_592 >>u 0x02);
					edi_601 = Mem540[edx_590 + 8:word32];
					edi_602 = edi_601 - esi_592;
					ebx_606 = ebx_605 + (edi_602 >>u 0x02);
				}
				ebx_765 = ϕ(ebx_606, ebx_605);
				eax_617 = ϕ(eax_600, eax_599);
				edx_610 = Mem540[edx_590 + 0x0C:word32];
			} while (edx_610 != 0x00);
			edx_eax_618 = CONVERT(eax_617, word32, uint64);
			eax_621 = CONVERT(edx_eax_618 /u 100, word32, uint32);
			edi_624 = (eax_621 + 0x01) *s Mem540[0x08083FD0<p32>:word32];
			while (true)
			{
				ebx_633 = ϕ(ebx_765, ebx_769);
				Mem628 = ϕ(Mem540, Mem654);
				ecx_626 = ϕ(ecx_575, ecx_757);
				eax_627 = ecx_626 - 16;
				esi_629 = Mem628[eax_627 + 0x0C:word32];
				if (Mem628[eax_627 + 4:word32] == 0x00)
				{
					if (edi_624 >u ebx_633)
					{
						eax_645 = Mem628[eax_627 + 8:word32];
						ebx_647 = ebx_633 + (eax_645 >>u 0x02);
					}
					else
						caml_shrink_heap();
				}
				ecx_1078 = ϕ(ecx_626, ecx_639, ecx_626);
				ebx_769 = ϕ(ebx_647, ebx_633, ebx_633);
				Mem654 = ϕ(Mem628, Mem637, Mem628);
				if (esi_629 == 0x00)
					break;
				ecx_757 = esi_629;
			}
			ebx_655 = Mem654[0x08083FD8<p32>:word32];
			caml_fl_reset();
			if (ebx_655 != 0x00)
			{
				do
				{
					ecx_1080 = ϕ(ecx_1078, ecx_1079);
					Mem669 = ϕ(Mem654, Mem691);
					ebx_667 = ϕ(ebx_655, ebx_692);
					esi_668 = ebx_667 - 16;
					edx_670 = Mem669[esi_668 + 8:word32];
					eax_671 = Mem669[esi_668 + 4:word32];
					if (edx_670 >u eax_671)
					{
						edx_676 = edx_670 - eax_671;
						eax_680 = ebx_667 + eax_671;
						caml_make_free_blocks();
					}
					edx_1082 = ϕ(edx_670, edx_684);
					ecx_1079 = ϕ(ecx_1080, ecx_683);
					Mem691 = ϕ(Mem669, Mem681);
					ebx_692 = Mem691[esi_668 + 0x0C:word32];
				} while (ebx_692 != 0x00);
			}
l0806F768:
			edx_1081 = ϕ(edx_581, edx_657, edx_1082);
			ecx_1072 = ϕ(ecx_1073, ecx_1078, ecx_1079);
			Mem697 = ϕ(Mem698, Mem654, Mem691);
			v19_699 = Mem697[0x08083948<p32>:word32] + 0x01;
			Mem700[0x08083948<p32>:word32] = v19_699;
			caml_gc_message();
			SCZO_748 = cond(fp - 0x10);
			C_1071 = SLICE(SCZO_748, bool, 1);
			O_1083 = SLICE(SCZO_748, bool, 4);
			S_1084 = SLICE(SCZO_748, bool, 0);
			Z_1127 = SLICE(SCZO_748, bool, 2);
			return;
		}
	}
	ecx_1073 = ϕ(ecx_1074, ecx_575);
	Mem698 = ϕ(Mem523, Mem540);
	caml_fl_reset();
	goto l0806F768;
}

// 0806F7A5: define caml_compact_heap_maybe
// Called from:
//      caml_major_collection_slice
define caml_compact_heap_maybe
{
	ptr32 fp;
	word32 eax;
	word32 ecx;
	word32 edx;
	bool P;
	if (Mem10[0x08084808<p32>:word32] <=u 999999 && (Mem10[0x0808393C<p32>:word32] > 0x02 && Mem10[0x0808394C<p32>:word32] > 0x02))
	{
		edx_18 = Mem10[0x0807F420<p32>:word32];
		eax_19 = Mem10[0x080803E4<p32>:word32];
		qwLoc1C_234 = CONVERT(edx_18, word32, uint64);
		rLoc1_235 = CONVERT(qwLoc1C_234, int64, real64);
		rLoc1_236 = rLoc1_235 * CONVERT(Mem22[0x080718AC<p32>:real32], real32, real64);
		qwLoc1C_239 = CONVERT(eax_19, word32, uint64);
		rLoc2_240 = CONVERT(qwLoc1C_239, int64, real64);
		rLoc2_241 = rLoc2_240 * CONVERT(Mem28[0x08072334<p32>:real32], real32, real64);
		rLoc1_242 = rLoc1_236 + rLoc2_241;
		rLoc10_243 = CONVERT(rLoc1_242, real64, real32);
		rLoc1_244 = CONVERT(rLoc10_243, real32, real64);
		if (rLoc1_244 <u 0.0)
		{
			qwLoc1C_249 = CONVERT(edx_18, word32, uint64);
			rLoc1_250 = CONVERT(qwLoc1C_249, int64, real64);
		}
		rLoc1_255 = ϕ(rLoc1_244, rLoc1_250);
		Mem52 = ϕ(Mem34, Mem49);
		edx_53 = Mem52[0x08083940<p32>:word32];
		ecx_55 = 0x00;
		qwLoc1C_253 = CONVERT(edx_53 >>u 0x02, word32, uint64);
		rLoc2_254 = CONVERT(qwLoc1C_253, int64, real64);
		if (rLoc1_255 >=u rLoc2_254)
		{
			rLoc1_273 = CONVERT(Mem58[0x08071188<p32>:real32], real32, real64);
			rLoc24_274 = CONVERT(rLoc1_273, real64, real32);
		}
		else
		{
			rLoc3_259 = rLoc1_255 * CONVERT(Mem58[0x0807225C<p32>:real32], real32, real64);
			rLoc1_262 = rLoc2_254 - rLoc1_255;
			rLoc1_263 = rLoc3_259 / rLoc1_262;
			rLoc24_264 = CONVERT(rLoc1_263, real64, real32);
			rLoc1_265 = CONVERT(Mem80[0x08071188<p32>:real32], real32, real64);
			rLoc2_266 = CONVERT(rLoc24_264, real32, real64);
			if (rLoc2_266 > rLoc1_265)
				rLoc2_267 = rLoc1_265;
			rLoc2_268 = ϕ(rLoc2_266, rLoc2_267);
			rLoc24_270 = CONVERT(rLoc2_268, real64, real32);
		}
		rLoc24_280 = ϕ(rLoc24_274, rLoc24_270);
		caml_gc_message();
		wLoc1E_278 = __fstcw();
		eax_123 = CONVERT(wLoc1E_278, word16, word32);
		al_125 = SLICE(eax_123, byte, 0);
		ax_126 = SEQ(0x0C, al_125);
		__fldcw(ax_126);
		__fldcw(wLoc1E_278);
		caml_gc_message();
		eax_143 = Mem136[0x08084808<p32>:word32];
		edx_144 = 0x00;
		qwLoc1C_289 = CONVERT(eax_143, word32, uint64);
		rLoc1_290 = CONVERT(qwLoc1C_289, int64, real64);
		rLoc2_291 = CONVERT(rLoc24_280, real32, real64);
		CZP_151 = cond(rLoc2_291 - rLoc1_290);
		P_337 = SLICE(CZP_151, bool, 5);
		if (rLoc2_291 >=u rLoc1_290)
		{
			caml_gc_message();
			caml_finish_major_cycle();
			wLoc1E_310 = __fstcw();
			eax_201 = CONVERT(wLoc1E_310, word16, word32);
			al_203 = SLICE(eax_201, byte, 0);
			ax_204 = SEQ(0x0C, al_203);
			__fldcw(ax_204);
			__fldcw(wLoc1E_310);
			caml_gc_message();
			caml_compact_heap();
			P_338 = SLICE(SCZOP_221, bool, 5);
		}
	}
	Top_349 = 0;
	P_335 = ϕ(P, P, P, P_337, P_338);
	edx_332 = ϕ(edx, edx, edx, edx_144, edx_218);
	ecx_328 = ϕ(ecx, ecx, ecx, ecx_55, ecx_220);
	eax_326 = ϕ(eax, eax, eax, eax_143, eax_219);
	SCZO_224 = cond(fp - 0x08);
	C_325 = SLICE(SCZO_224, bool, 1);
	O_334 = SLICE(SCZO_224, bool, 4);
	S_348 = SLICE(SCZO_224, bool, 0);
	Z_350 = SLICE(SCZO_224, bool, 2);
}

// 0806F980: define caml_final_do_strong_roots
// Called from:
//      caml_do_roots
define caml_final_do_strong_roots
{
	ptr32 fp;
	word32 dwArg04;
	word32 edx;
	Top_3 = 0;
	if (Mem16[0x080839B0<p32>:word32] != 0x00)
	{
		ebx_20 = 0x00;
		esi_21 = 0x00;
		do
		{
			esi_34 = ϕ(esi_21, esi_39);
			Mem25 = ϕ(Mem16, Mem31);
			ebx_23 = ϕ(ebx_20, ebx_40);
			eax_26 = ebx_23 + Mem25[0x080839AC<p32>:word32];
			eax_30 = Mem29[eax_26 + 0x00:word32];
			dwArg04();
			esi_39 = esi_34 + 0x01;
			ebx_40 = ebx_23 + 0x0C;
		} while (Mem31[0x080839B0<p32>:word32] >u esi_39);
	}
	edx_163 = ϕ(edx, edx_37);
	Mem43 = ϕ(Mem16, Mem31);
	eax_44 = Mem43[0x080839B4<p32>:word32];
	dwLoc20_121 = eax_44;
	SZP_47 = cond(eax_44);
	P_167 = SLICE(SZP_47, bool, 5);
	if (eax_44 != 0x00)
	{
		do
		{
			eax_161 = ϕ(eax_44, eax_160);
			dwLoc20_122 = ϕ(dwLoc20_121, dwLoc20_130);
			Mem52 = ϕ(Mem46, Mem90);
			ebx_53 = dwLoc20_122;
			esi_54 = 0x00;
			if (Mem52[dwLoc20_122 + 4:word32] != 0x00)
			{
				do
				{
					ebx_66 = ϕ(ebx_53, ebx_82);
					esi_57 = ϕ(esi_54, esi_81);
					eax_58 = esi_57 * 0x03;
					edi_62 = dwLoc20_122 + eax_58 * 0x04;
					eax_67 = Mem65[ebx_66 + 8:word32];
					dwArg04();
					eax_76 = Mem75[ebx_66 + 0x0C:word32];
					dwArg04();
					esi_81 = esi_57 + 0x01;
					ebx_82 = ebx_66 + 0x0C;
					eax_83 = dwLoc20_122;
				} while (Mem77[dwLoc20_122 + 4:word32] >u esi_81);
			}
			eax_160 = ϕ(eax_161, eax_83);
			Mem87 = ϕ(Mem52, Mem77);
			edx_89 = Mem87[dwLoc20_122 + 0x00:word32];
			dwLoc20_130 = edx_89;
			SZP_91 = cond(edx_89);
			P_168 = SLICE(SZP_91, bool, 5);
		} while (edx_89 != 0x00);
	}
	P_166 = ϕ(P_167, P_168);
	edx_162 = ϕ(edx_163, edx_89);
	eax_159 = ϕ(eax_44, eax_160);
	SCZO_100 = cond(fp - 0x10);
	C_158 = SLICE(SCZO_100, bool, 1);
	O_165 = SLICE(SCZO_100, bool, 4);
	S_169 = SLICE(SCZO_100, bool, 0);
	Z_171 = SLICE(SCZO_100, bool, 2);
}

// 0806FA29: define caml_final_do_weak_roots
// Called from:
//      caml_compact_heap
define caml_final_do_weak_roots
{
	ptr32 fp;
	word32 dwArg04;
	word32 eax;
	word32 edx;
	Top_3 = 0;
	if (Mem16[0x080839B0<p32>:word32] != 0x00)
	{
		ebx_21 = 0x00;
		esi_22 = 0x00;
		do
		{
			esi_35 = ϕ(esi_22, esi_40);
			Mem25 = ϕ(Mem16, Mem32);
			ebx_23 = ϕ(ebx_21, ebx_41);
			eax_26 = ebx_23 + Mem25[0x080839AC<p32>:word32];
			eax_31 = Mem30[eax_26 + 4:word32];
			dwArg04();
			esi_40 = esi_35 + 0x01;
			ebx_41 = ebx_23 + 0x0C;
		} while (Mem32[0x080839B0<p32>:word32] >u esi_40);
	}
	edx_75 = ϕ(edx, edx_38);
	eax_73 = ϕ(eax, eax_37);
	SCZO_46 = cond(fp - 0x10);
	C_72 = SLICE(SCZO_46, bool, 1);
	O_77 = SLICE(SCZO_46, bool, 4);
	S_78 = SLICE(SCZO_46, bool, 0);
	Z_80 = SLICE(SCZO_46, bool, 2);
}

// 0806FA75: define caml_final_do_young_roots
// Called from:
//      caml_oldify_local_roots
define caml_final_do_young_roots
{
	ptr32 fp;
	word32 dwArg04;
	word32 eax;
	word32 edx;
	Top_3 = 0;
	esi_19 = Mem16[0x080839B0<p32>:word32];
	if (esi_19 <u Mem16[0x080839A4<p32>:word32])
	{
		ebx_23 = esi_19 * 0x0C;
		do
		{
			esi_36 = ϕ(esi_19, esi_51);
			Mem27 = ϕ(Mem16, Mem47);
			ebx_25 = ϕ(ebx_23, ebx_52);
			eax_28 = ebx_25 + Mem27[0x080839AC<p32>:word32];
			eax_32 = Mem31[eax_28 + 0x00:word32];
			dwArg04();
			eax_42 = ebx_25 + Mem33[0x080839AC<p32>:word32];
			eax_46 = Mem45[eax_42 + 4:word32];
			dwArg04();
			esi_51 = esi_36 + 0x01;
			ebx_52 = ebx_25 + 0x0C;
		} while (Mem47[0x080839A4<p32>:word32] >u esi_51);
	}
	edx_88 = ϕ(edx, edx_49);
	eax_86 = ϕ(eax, eax_48);
	SCZO_57 = cond(fp - 0x10);
	C_85 = SLICE(SCZO_57, bool, 1);
	O_90 = SLICE(SCZO_57, bool, 4);
	S_91 = SLICE(SCZO_57, bool, 0);
	Z_93 = SLICE(SCZO_57, bool, 2);
}

// 0806FAD5: define caml_final_empty_young
// Called from:
//      caml_empty_minor_heap
define caml_final_empty_young
{
	Top_3 = 0;
	eax_7 = Mem6[0x080839A4<p32>:word32];
	Mem8[0x080839B0<p32>:word32] = eax_7;
}

// 0806FAE4: define caml_final_release
define caml_final_release
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	Mem0[0x080839A0<p32>:word32] = 0x00;
	eax = 0x01;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806FAF8: define caml_final_register
define caml_final_register
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	ebx = Mem0[ebp + 0x0C:word32];
	SZP = cond(bl & 0x01);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		esi = ebx;
		edx = ebx;
		edx >>= 0x17;
		eax = ebx;
		eax >>= 0x0C;
		eax &= 0x07FF;
		edx = 0x08084000[edx * 0x04];
		SZP = cond(Mem0[edx + eax:byte] & 0x03);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
l0806FB39:
			eax = Mem0[0x080839A8<p32>:word32];
			SCZO = cond(Mem0[0x080839A4<p32>:word32] - eax);
			if (Test(UGE,C))
			{
				edx = Mem0[0x080839AC<p32>:word32];
				SZP = cond(edx & edx);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
					Mem0[esp + 0x00:word32] = 0x0168;
					caml_stat_alloc();
					Mem0[0x080839AC<p32>:word32] = eax;
					Mem0[0x080839A8<p32>:word32] = 0x1E;
				}
				else
				{
					edi = eax + eax;
					eax = edi + eax * 0x04;
					eax <<= 0x02;
					SCZO = cond(eax);
					Mem0[esp + 4:word32] = eax;
					Mem0[esp + 0x00:word32] = edx;
					caml_stat_resize();
					Mem0[0x080839AC<p32>:word32] = eax;
					Mem0[0x080839A8<p32>:word32] = edi;
				}
			}
			eax = Mem0[0x080839A4<p32>:word32];
			edx = eax + eax * 0x02;
			edx <<= 0x02;
			edx += Mem0[0x080839AC<p32>:word32];
			ecx = Mem0[ebp + 8:word32];
			Mem0[edx + 0x00:word32] = ecx;
			ecx = esi - 4;
			SCZO = cond(Mem0[ecx + 0x00:byte] - ~0x06);
			if (Test(EQ,Z))
			{
				ebx = Mem0[ecx + 0x00:word32];
				ebx >>= 0x0A;
				ebx <<= 0x02;
				Mem0[edx + 8:word32] = ebx;
				ecx = Mem0[ecx + 0x00:word32];
				ecx >>= 0x0A;
				ecx <<= 0x02;
				esi -= ecx;
				SCZO = cond(esi);
				Mem0[edx + 4:word32] = esi;
			}
			else
			{
				Mem0[edx + 8:word32] = 0x00;
				Mem0[edx + 4:word32] = ebx;
			}
			++eax;
			SCZO = cond(eax);
			Mem0[0x080839A4<p32>:word32] = eax;
			eax = 0x01;
			ebx = Mem0[ebp + -0x0C:word32];
			esi = Mem0[ebp + -8:word32];
			edi = Mem0[ebp + -4:word32];
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 0x00:word32] = 0x08072338;
	caml_invalid_argument();
	goto l0806FB39;
}

// 0806FBE9: define caml_final_do_calls
// Called from:
//      caml_minor_collection
//      caml_gc_compaction
//      caml_gc_full_major
//      caml_gc_major
define caml_final_do_calls
{
	ptr32 fp;
	word32 ebx;
	word32 eax;
	word32 ecx;
	word32 edx;
	bool P;
	Top_3 = 0;
	if (Mem10[0x080839A0<p32>:word32] == 0x00 && Mem10[0x080839B4<p32>:word32] != 0x00)
	{
		caml_gc_message();
		while (true)
		{
			edx_125 = ϕ(edx, edx_64, edx_31, edx_31);
			ecx_121 = ϕ(ecx, ecx_50, ecx_121, ecx_121);
			ebx_73 = ϕ(ebx, ebx_73, ebx_36, ebx_36);
			Mem25 = ϕ(Mem18, Mem62, Mem39, Mem44);
			eax_26 = Mem25[0x080839B4<p32>:word32];
			if (eax_26 == 0x00)
				break;
			edx_31 = Mem25[eax_26 + 4:word32];
			if (edx_31 != 0x00)
			{
				Mem46[eax_26 + 4:word32] = edx_31 - 0x01;
				edx_47 = edx_31 - 0x01 + (edx_31 - 0x01) * 0x02;
				eax_48 = eax_26 + edx_47 * 0x04;
				edx_49 = Mem46[eax_48 + 8:word32];
				ecx_50 = Mem46[eax_48 + 16:word32];
				eax_51 = Mem46[eax_48 + 0x0C:word32];
				Mem52[0x080839A0<p32>:word32] = 0x01;
				eax_53 = eax_51 + ecx_50;
				fn08070AC8();
				Mem62[0x080839A0<p32>:word32] = 0x00;
				edx_64 = eax_57 & 0x03;
				if ((eax_57 & 0x03) != 0x02)
					continue;
				caml_raise();
				break;
			}
			ebx_36 = Mem25[eax_26 + 0x00:word32];
			free(eax_26);
			Mem39[0x080839B4<p32>:word32] = ebx_36;
			if (ebx_36 == 0x00)
				Mem44[0x080839B8<p32>:word32] = 0x00;
		}
		edx_124 = ϕ(edx_125, edx_76);
		ecx_120 = ϕ(ecx_121, ecx_77);
		caml_gc_message();
	}
	P_127 = ϕ(P, P, P_88);
	edx_122 = ϕ(edx, edx, edx_124);
	ecx_118 = ϕ(ecx, ecx, ecx_120);
	eax_116 = ϕ(eax, eax, eax_83);
	SCZO_91 = cond(fp - 0x08);
	C_115 = SLICE(SCZO_91, bool, 1);
	O_126 = SLICE(SCZO_91, bool, 4);
	S_129 = SLICE(SCZO_91, bool, 0);
	Z_132 = SLICE(SCZO_91, bool, 2);
}

// 0806FCC4: define caml_final_update
// Called from:
//      mark_slice
define caml_final_update
{
	ptr32 fp;
	word32 eax;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	esi_18 = Mem16[0x080839B0<p32>:word32];
	SZP_19 = cond(esi_18);
	P_324 = SLICE(SZP_19, bool, 5);
	if (esi_18 != 0x00)
	{
		edx_23 = Mem16[0x080839AC<p32>:word32];
		ebx_24 = 0x00;
		eax_25 = 0x00;
		do
		{
			eax_35 = ϕ(eax_25, eax_36);
			ebx_32 = ϕ(ebx_24, ebx_34);
			edx_26 = ϕ(edx_23, edx_37);
			ecx_28 = Mem16[edx_26 + 4:word32];
			ecx_29 = Mem16[ecx_28 + -4:word32];
			ecx_30 = ecx_29 & 0x0300;
			ebx_34 = ebx_32 + CONVERT((ecx_29 & 0x0300) <u 0x01, bool, word32);
			eax_36 = eax_35 + 0x01;
			edx_37 = edx_26 + 0x0C;
		} while (eax_36 <u esi_18);
		SZP_41 = cond(ebx_34);
		P_325 = SLICE(SZP_41, bool, 5);
		if (ebx_34 != 0x00)
		{
			eax_46 = ebx_34 * 0x0C + 0x14;
			eax_49 = malloc(eax_46);
			if (eax_49 == 0x00)
				caml_fatal_error();
			Mem55[eax_49 + 0x00:word32] = 0x00;
			Mem56[eax_49 + 4:word32] = ebx_34;
			edx_57 = Mem56[0x080839B8<p32>:word32];
			if (edx_57 == 0x00)
			{
				Mem64[0x080839B4<p32>:word32] = eax_49;
				Mem65[0x080839B8<p32>:word32] = eax_49;
			}
			else
			{
				Mem62[edx_57 + 0x00:word32] = eax_49;
				Mem63[0x080839B8<p32>:word32] = eax_49;
			}
			Mem66 = ϕ(Mem65, Mem63);
			eax_67 = Mem66[0x080839B0<p32>:word32];
			SZP_71 = cond(eax_67);
			P_326 = SLICE(SZP_71, bool, 5);
			if (eax_67 != 0x00)
			{
				edx_79 = Mem70[0x080839AC<p32>:word32];
				ecx_81 = Mem80[0x080839B8<p32>:word32];
				dwLoc28_244 = 0x00;
				dwLoc38_245 = 0x00;
				dwLoc2C_246 = 0x00;
				do
				{
					dwLoc38_309 = ϕ(dwLoc38_245, dwLoc38_270);
					dwLoc2C_263 = ϕ(dwLoc2C_246, dwLoc2C_265);
					dwLoc28_256 = ϕ(dwLoc28_244, dwLoc28_272);
					edx_87 = ϕ(edx_79, edx_179);
					do
					{
						Mem91 = ϕ(Mem89, Mem148);
						ecx_92 = Mem91[edx_87 + 4:word32];
						if ((Mem91[ecx_92 + -4:word32] & 0x0300) != 0x00)
						{
							ecx_103 = Mem91[edx_87 + 0x00:word32];
							edx_79[dwLoc38_309 * 0x0C] = ecx_103;
							ecx_106 = Mem105[edx_87 + 4:word32];
							Mem107[dwLoc38_309 * 0x0C + 4 + edx_79:word32] = ecx_106;
							ecx_108 = Mem107[edx_87 + 8:word32];
							Mem109[dwLoc38_309 * 0x0C + 8 + edx_79:word32] = ecx_108;
							v19_110 = dwLoc38_309 + 0x01;
							dwLoc38_251 = v19_110;
							goto l0806FE54;
						}
						if (Mem91[ecx_92 + -4:byte] != ~0x05)
							break;
						eax_116 = Mem91[ecx_92 + 0x00:word32];
						al_117 = SLICE(eax_116, byte, 0);
						if ((al_117 & 0x01) != 0x00)
						{
							Mem123[edx_87 + 4:word32] = eax_116;
							break;
						}
						ecx_129 = eax_116 >>u 0x0C & 0x07FF;
						esi_132 = 0x08084000[(eax_116 >>u 0x17) * 0x04];
						if ((Mem130[esi_132 + ecx_129:byte] & 0x07) == 0x00)
							break;
						ecx_138 = CONVERT(Mem130[eax_116 + -4:byte], byte, word32);
						cl_139 = SLICE(ecx_138, byte, 0);
						if (cl_139 == ~0x05 || (cl_139 == ~0x09 || cl_139 == ~0x02))
							break;
						Mem148[edx_87 + 4:word32] = eax_116;
						eax_149 = 0x08084000[(eax_116 >>u 0x17) * 0x04];
					} while ((Mem148[eax_149 + ecx_129:byte] & 0x01) != 0x00);
					Mem158 = ϕ(Mem130, Mem123, Mem148, Mem130, Mem130, Mem130, Mem91);
					ecx_163 = Mem158[edx_87 + 0x00:word32];
					Mem165[dwLoc28_256 * 0x0C + 8 + ecx_81:word32] = ecx_163;
					ecx_166 = Mem165[edx_87 + 4:word32];
					Mem167[dwLoc28_256 * 0x0C + 0x0C + ecx_81:word32] = ecx_166;
					ecx_168 = Mem167[edx_87 + 8:word32];
					Mem169[dwLoc28_256 * 0x0C + 16 + ecx_81:word32] = ecx_168;
					v22_170 = dwLoc28_256 + 0x01;
					dwLoc28_260 = v22_170;
l0806FE54:
					dwLoc28_272 = ϕ(dwLoc28_256, dwLoc28_260);
					dwLoc38_270 = ϕ(dwLoc38_251, dwLoc38_309);
					v20_175 = dwLoc2C_263 + 0x01;
					dwLoc2C_265 = v20_175;
					edx_179 = edx_87 + 0x0C;
				} while (eax_67 >u v20_175);
				eax_183 = dwLoc38_270;
				Mem184[0x080839B0<p32>:word32] = dwLoc38_270;
				Mem185[0x080839A4<p32>:word32] = dwLoc38_270;
				ecx_186 = dwLoc28_272;
				edx_187 = ecx_81;
				Mem188[ecx_81 + 4:word32] = dwLoc28_272;
				SZP_189 = cond(dwLoc28_272);
				P_327 = SLICE(SZP_189, bool, 5);
				if (dwLoc28_272 != 0x00)
				{
					ebx_193 = 0x00;
					do
					{
						ebx_197 = ϕ(ebx_193, ebx_212);
						eax_198 = ebx_197 * 0x03;
						eax_200 = (eax_198 << 0x02) + Mem196[0x080839B8<p32>:word32];
						eax_202 = Mem196[eax_200 + 0x0C:word32];
						caml_darken();
						ebx_212 = ebx_197 + 0x01;
					} while (ebx_212 <u dwLoc28_272);
				}
			}
			else
			{
				Mem75[0x080839B0<p32>:word32] = 0x00;
				Mem76[0x080839A4<p32>:word32] = 0x00;
				eax_77 = Mem76[0x080839B8<p32>:word32];
				Mem78[eax_77 + 4:word32] = 0x00;
			}
		}
	}
	P_323 = ϕ(P_324, P_325, P_326, P_327, P_211);
	edx_319 = ϕ(edx, edx_37, edx_57, edx_187, edx_206);
	ecx_316 = ϕ(ecx, ecx_30, ecx_30, ecx_186, ecx_205);
	eax_314 = ϕ(eax, eax_36, eax_77, eax_183, eax_204);
	SCZO_223 = cond(fp - 0x10);
	C_313 = SLICE(SCZO_223, bool, 1);
	O_322 = SLICE(SCZO_223, bool, 4);
	S_328 = SLICE(SCZO_223, bool, 0);
	Z_337 = SLICE(SCZO_223, bool, 2);
}

// 0806FEF4: define caml_final_custom_operations
// Called from:
//      caml_alloc_final
define caml_final_custom_operations
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[0x080839BC<p32>:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		ebx = Mem0[eax + 0x00:word32];
		SCZO = cond(Mem0[ebx + 4:word32] - esi);
		while (Test(NE,Z))
		{
			eax = Mem0[eax + 4:word32];
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				goto l0806FF1F;
			ebx = Mem0[eax + 0x00:word32];
			SCZO = cond(Mem0[ebx + 4:word32] - esi);
		}
	}
	else
	{
l0806FF1F:
		Mem0[esp + 0x00:word32] = 0x1C;
		caml_stat_alloc();
		ebx = eax;
		Mem0[eax + 0x00:word32] = 0x0807239E;
		Mem0[eax + 4:word32] = esi;
		Mem0[eax + 8:word32] = 0x00;
		Mem0[eax + 0x0C:word32] = 0x00;
		Mem0[eax + 16:word32] = 0x00;
		Mem0[eax + 20:word32] = 0x00;
		Mem0[esp + 0x00:word32] = 0x08;
		caml_stat_alloc();
		Mem0[eax + 0x00:word32] = ebx;
		edx = Mem0[0x080839BC<p32>:word32];
		Mem0[eax + 4:word32] = edx;
		Mem0[0x080839BC<p32>:word32] = eax;
	}
	eax = ebx;
	esp += 0x10;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806FF77: define caml_register_custom_operations
// Called from:
//      caml_init_custom_operations
define caml_register_custom_operations
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = 0x08;
	caml_stat_alloc();
	edx = Mem0[ebp + 8:word32];
	Mem0[eax + 0x00:word32] = edx;
	edx = Mem0[0x080839C0<p32>:word32];
	Mem0[eax + 4:word32] = edx;
	Mem0[0x080839C0<p32>:word32] = eax;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806FF9E: define caml_init_custom_operations
// Called from:
//      caml_main
define caml_init_custom_operations
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	Mem0[esp + 0x00:word32] = 0x0807CFFC;
	caml_register_custom_operations();
	Mem0[esp + 0x00:word32] = 0x0807D034;
	caml_register_custom_operations();
	Mem0[esp + 0x00:word32] = 0x0807D018;
	caml_register_custom_operations();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0806FFCA: define caml_find_custom_operations
define caml_find_custom_operations
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	edi = Mem0[ebp + 8:word32];
	ebx = Mem0[0x080839C0<p32>:word32];
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	while (Test(NE,Z))
	{
		esi = Mem0[ebx + 0x00:word32];
		eax = Mem0[esi + 0x00:word32];
		Mem0[esp + 4:word32] = edi;
		Mem0[esp + 0x00:word32] = eax;
		eax = strcmp(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
			goto l08070000;
		ebx = Mem0[ebx + 4:word32];
		SZP = cond(ebx & ebx);
		O = false;
		C = false;
	}
	esi = 0x00;
l08070000:
	eax = esi;
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0807000A: define caml_alloc_custom
// Called from:
//      caml_alloc_final
//      caml_copy_nativeint
//      caml_copy_int64
//      caml_copy_int32
//      caml_alloc_channel
define caml_alloc_custom
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x10;
	ebx = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	eax += 0x03;
	eax >>= 0x02;
	++eax;
	SCZO = cond(Mem0[ebx + 4:word32] - 0x00);
	if (Test(EQ,Z))
	{
		SCZO = cond(eax - 0x0100);
		if (Test(ULE,CZ))
		{
			Mem0[esp + 4:word32] = 0xFF;
			Mem0[esp + 0x00:word32] = eax;
			caml_alloc_small();
			Mem0[eax + 0x00:word32] = ebx;
l08070070:
			esp += 0x10;
			SCZO = cond(esp);
			ebx = Mem0[esp + 0x00:word32];
			esp += 4;
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	Mem0[esp + 4:word32] = 0xFF;
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc_shr();
	esi = eax;
	Mem0[eax + 0x00:word32] = ebx;
	eax = Mem0[ebp + 20:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 16:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_adjust_gc_speed();
	Mem0[esp + 0x00:word32] = esi;
	caml_check_urgent_gc();
	goto l08070070;
}

// 08070080: define caml_executable_name
// Called from:
//      caml_main
define caml_executable_name
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x78;
	Mem0[ebp + -8:word32] = ebx;
	Mem0[ebp + -4:word32] = esi;
	ebx = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 8:word32] = esi;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 0x00:word32] = 0x080723A5;
	eax = readlink(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)], Mem0[esp + 8:size_t]);
	SCZO = cond(eax - ~0x00);
	if (Test(NE,Z))
	{
		SCZO = cond(esi - eax);
		if (Test(GT,SZO))
		{
			Mem0[ebx + eax:byte] = 0x00;
			eax = ebp - 0x0068;
			Mem0[esp + 8:word32] = eax;
			Mem0[esp + 4:word32] = ebx;
			Mem0[esp + 0x00:word32] = 0x03;
			__xstat64();
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				edx = Mem0[ebp + -88:word32];
				edx &= 0xF000;
				SCZO = cond(edx - 0x8000);
				if (Test(EQ,Z))
				{
l080700E4:
					ebx = Mem0[ebp + -8:word32];
					esi = Mem0[ebp + -4:word32];
					esp = ebp;
					ebp = Mem0[esp + 0x00:word32];
					esp += 4;
					return;
				}
			}
		}
	}
	eax = ~0x00;
	goto l080700E4;
}

// 080700EE: define caml_decompose_path
// Called from:
//      caml_search_exe_in_path
define caml_decompose_path
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x1C;
	esi = Mem0[ebp + 8:word32];
	ebx = Mem0[ebp + 0x0C:word32];
	edi = 0x00;
	SZP = cond(ebx & ebx);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
l0807016A:
		eax = edi;
		esp += 0x1C;
		SCZO = cond(esp);
		ebx = Mem0[esp + 0x00:word32];
		esp += 4;
		esi = Mem0[esp + 0x00:word32];
		esp += 4;
		edi = Mem0[esp + 0x00:word32];
		esp += 4;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
		return;
	}
	edi = ebx;
	eax = 0x00;
	ecx = ~0x00;
	size = strlen(edi) + 1;
	ecx -= size;
	edi += size;
	SCZO = cond(0x00);
	ecx = ~ecx;
	Mem0[esp + 0x00:word32] = ecx;
	caml_stat_alloc();
	edi = eax;
	Mem0[esp + 4:word32] = ebx;
	Mem0[esp + 0x00:word32] = eax;
	eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	ecx = edi;
l0807012E:
	eax = CONVERT(Mem0[ecx + 0x00:byte], byte, word32);
	SZP = cond(al & al);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(al - 0x3A);
		if (Test(NE,Z))
		{
			eax = ecx + 1;
			do
			{
				ebx = eax;
				edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
				++eax;
				SZP = cond(dl & dl);
				O = false;
				C = false;
				if (Test(EQ,Z))
					break;
				SCZO = cond(dl - 0x3A);
			} while (Test(NE,Z));
l08070151:
			Mem0[esp + 4:word32] = ecx;
			Mem0[esp + 0x00:word32] = esi;
			caml_ext_table_add();
			SCZO = cond(Mem0[ebx + 0x00:byte] - 0x00);
			if (Test(NE,Z))
			{
				Mem0[ebx + 0x00:byte] = 0x00;
				ecx = ebx + 1;
				goto l0807012E;
			}
			goto l0807016A;
		}
	}
	ebx = ecx;
	goto l08070151;
}

// 08070174: define caml_read_directory
// Called from:
//      caml_sys_read_directory
define caml_read_directory
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x3C;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = opendir(Mem0[esp + 0x00:(ptr32 char)]);
	Mem0[ebp + -28:word32] = eax;
	eax = ~0x00;
	SCZO = cond(Mem0[ebp + -28:word32] - 0x00);
	if (Test(NE,Z))
	{
		esi = 0x080723B5;
		while (true)
		{
			eax = Mem0[ebp + -28:word32];
			Mem0[esp + 0x00:word32] = eax;
			readdir64();
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				break;
			ebx = eax + 19;
			edi = ebx;
			edx = CONVERT(Mem0[ebx + 0x00:byte], byte, word32);
			ecx = CONVERT(Mem0[esi + 0x00:byte], byte, word32);
			SCZO = cond(edx - ecx);
			if (Test(EQ,Z))
			{
				ecx = CONVERT(Mem0[ebx + 1:byte], byte, word32);
				SCZO = cond(cl - Mem0[esi + 1:byte]);
				if (Test(EQ,Z))
					continue;
			}
			ecx = 0x080723B4;
			ecx = CONVERT(Mem0[ecx + 0x00:byte], byte, word32);
			SCZO = cond(edx - ecx);
			if (Test(EQ,Z))
			{
				edx = CONVERT(Mem0[edi + 1:byte], byte, word32);
				SCZO = cond(dl - Mem0[0x080723B5<p32>:byte]);
				if (Test(EQ,Z))
				{
					edx = CONVERT(Mem0[edi + 2:byte], byte, word32);
					SCZO = cond(dl - Mem0[0x080723B6<p32>:byte]);
					if (Test(EQ,Z))
						continue;
				}
			}
			edi = eax + 19;
			eax = 0x00;
			ecx = ~0x00;
			size = strlen(edi) + 1;
			ecx -= size;
			edi += size;
			SCZO = cond(0x00);
			ecx = ~ecx;
			Mem0[esp + 0x00:word32] = ecx;
			caml_stat_alloc();
			edi = eax;
			Mem0[esp + 4:word32] = ebx;
			Mem0[esp + 0x00:word32] = eax;
			eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
			Mem0[esp + 4:word32] = edi;
			eax = Mem0[ebp + 0x0C:word32];
			Mem0[esp + 0x00:word32] = eax;
			caml_ext_table_add();
		}
		ecx = Mem0[ebp + -28:word32];
		Mem0[esp + 0x00:word32] = ecx;
		eax = closedir(Mem0[esp + 0x00:(ptr32 DIR)]);
		eax = 0x00;
	}
	esp += 0x3C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0807023D: define caml_dlerror
define caml_dlerror
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x08;
	SCZO = cond(esp);
	eax = dlerror();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0807024A: define caml_dlsym
// Called from:
//      caml_globalsym
define caml_dlsym
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = dlsym(Mem0[esp + 0x00:(ptr32 void)], Mem0[esp + 4:(ptr32 char)]);
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070264: define caml_globalsym
define caml_globalsym
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = 0x00;
	caml_dlsym();
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0807027F: define caml_dlclose
define caml_dlclose
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	SCZO = cond(esp);
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = dlclose(Mem0[esp + 0x00:(ptr32 void)]);
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070292: define caml_dlopen
define caml_dlopen
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 16:word32];
	SCZO = cond(eax - 0x01);
	eax = eax - eax - C;
	al = 0x00;
	eax += 0x1102;
	SCZO = cond(eax);
	Mem0[esp + 4:word32] = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	eax = dlopen(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:int32]);
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080702B8: define caml_search_in_path
// Called from:
//      caml_search_dll_in_path
//      caml_search_exe_in_path
define caml_search_in_path
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x8C;
	esi = Mem0[ebp + 8:word32];
	eax = Mem0[ebp + 0x0C:word32];
	edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
	SZP = cond(dl & dl);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		SCZO = cond(dl - 0x2F);
		while (Test(NE,Z))
		{
			++eax;
			edx = CONVERT(Mem0[eax + 0x00:byte], byte, word32);
			SZP = cond(dl & dl);
			O = false;
			C = false;
			if (Test(EQ,Z))
				goto l080702F0;
			SCZO = cond(dl - 0x2F);
		}
	}
	else
	{
l080702F0:
		SCZO = cond(Mem0[esi + 0x00:word32] - 0x00);
		if (Test(GT,SZO))
		{
			Mem0[ebp + -0x007C:word32] = 0x00;
			do
			{
				edx = Mem0[ebp + -0x007C:word32];
				edx <<= 0x02;
				Mem0[ebp + -0x0080:word32] = edx;
				eax = Mem0[esi + 8:word32];
				edi = Mem0[eax + edx:word32];
				eax = 0x00;
				ecx = ~0x00;
				size = strlen(edi) + 1;
				ecx -= size;
				edx = ecx;
				edx = ~edx;
				edi = Mem0[ebp + 0x0C:word32];
				ecx = ~0x00;
				size = strlen(edi) + 1;
				ecx -= size;
				edi += size;
				ecx = ~ecx;
				edx += ecx;
				SCZO = cond(edx);
				Mem0[esp + 0x00:word32] = edx;
				caml_stat_alloc();
				ebx = eax;
				eax = Mem0[esi + 8:word32];
				edx = Mem0[ebp + -0x0080:word32];
				eax = Mem0[eax + edx:word32];
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = ebx;
				eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
				SCZO = cond(Mem0[ebx + 0x00:byte] - 0x00);
				if (Test(NE,Z))
				{
					edi = ebx;
					eax = 0x00;
					ecx = ~0x00;
					size = strlen(edi) + 1;
					ecx -= size;
					edi += size;
					SCZO = cond(0x00);
					ecx = ~ecx;
					Mem0[ebx - 1 + ecx:word16] = 0x2F;
				}
				eax = Mem0[ebp + 0x0C:word32];
				Mem0[esp + 4:word32] = eax;
				Mem0[esp + 0x00:word32] = ebx;
				eax = strcat(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
				edx = ebp - 0x0078;
				Mem0[esp + 8:word32] = edx;
				Mem0[esp + 4:word32] = ebx;
				Mem0[esp + 0x00:word32] = 0x03;
				__xstat64();
				SZP = cond(eax & eax);
				O = false;
				C = false;
				if (Test(EQ,Z))
				{
					eax = Mem0[ebp + -0x0068:word32];
					eax &= 0xF000;
					SCZO = cond(eax - 0x8000);
					if (Test(EQ,Z))
						goto l080703E2;
				}
				Mem0[esp + 0x00:word32] = ebx;
				caml_stat_free();
				v23 = Mem0[ebp + -0x007C:word32] + 0x01;
				Mem0[ebp + -0x007C:word32] = v23;
				eax = Mem0[ebp + -0x007C:word32];
				SCZO = cond(Mem0[esi + 0x00:word32] - eax);
			} while (Test(GT,SZO));
		}
	}
	edi = Mem0[ebp + 0x0C:word32];
	eax = 0x00;
	ecx = ~0x00;
	size = strlen(edi) + 1;
	ecx -= size;
	edi += size;
	SCZO = cond(0x00);
	ecx = ~ecx;
	Mem0[esp + 0x00:word32] = ecx;
	caml_stat_alloc();
	ebx = eax;
	edx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = edx;
	Mem0[esp + 0x00:word32] = eax;
	eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
l080703E2:
	eax = ebx;
	esp += 0x8C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080703EF: define caml_search_dll_in_path
define caml_search_dll_in_path
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x28;
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	esi = ~0x00;
	edi = Mem0[ebp + 0x0C:word32];
	ecx = esi;
	eax = 0x00;
	size = strlen(edi) + 1;
	ecx -= size;
	edi += size;
	ecx = ~ecx;
	ecx += 0x03;
	SCZO = cond(ecx);
	Mem0[esp + 0x00:word32] = ecx;
	caml_stat_alloc();
	ebx = eax;
	ecx = Mem0[ebp + 0x0C:word32];
	Mem0[esp + 4:word32] = ecx;
	Mem0[esp + 0x00:word32] = eax;
	eax = strcpy(Mem0[esp + 0x00:(ptr32 char)], Mem0[esp + 4:(ptr32 char)]);
	edi = ebx;
	ecx = esi;
	size = strlen(edi) + 1;
	ecx -= size;
	edi += size;
	SCZO = cond(0x00);
	esi = ecx;
	esi = ~esi;
	Mem0[ebx - 1 + esi:word32] = 7303982;
	Mem0[esp + 4:word32] = ebx;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_search_in_path();
	esi = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_stat_free();
	eax = esi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 0807046C: define caml_search_exe_in_path
// Called from:
//      caml_main
define caml_search_exe_in_path
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x38;
	SCZO = cond(esp);
	Mem0[ebp + -0x0C:word32] = ebx;
	Mem0[ebp + -8:word32] = esi;
	Mem0[ebp + -4:word32] = edi;
	Mem0[esp + 4:word32] = 0x08;
	ebx = ebp - 36;
	Mem0[esp + 0x00:word32] = ebx;
	caml_ext_table_init();
	Mem0[esp + 0x00:word32] = 0x080723B7;
	eax = getenv(Mem0[esp + 0x00:(ptr32 char)]);
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_decompose_path();
	esi = eax;
	eax = Mem0[ebp + 8:word32];
	Mem0[esp + 4:word32] = eax;
	Mem0[esp + 0x00:word32] = ebx;
	caml_search_in_path();
	edi = eax;
	Mem0[esp + 0x00:word32] = esi;
	caml_stat_free();
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = ebx;
	caml_ext_table_free();
	eax = edi;
	ebx = Mem0[ebp + -0x0C:word32];
	esi = Mem0[ebp + -8:word32];
	edi = Mem0[ebp + -4:word32];
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080704E0: define caml_backtrace_status
define caml_backtrace_status
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	SCZO = cond(Mem0[0x080839C4<p32>:word32] - 0x01);
	eax = eax - eax - C;
	eax &= ~0x01;
	eax += 0x03;
	SCZO = cond(eax);
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080704F4: define extract_location_info
// Called from:
//      caml_get_exception_backtrace
//      caml_print_exception_backtrace
define extract_location_info
{
	word32 eax;
	eax_24_8_30 = SLICE(eax, word24, 8);
	word32 edx;
	word32 ecx;
	Top_3 = 0;
	SZP_16 = cond(Mem14[eax + 4:byte] & 0x01);
	Z_19 = SLICE(SZP_16, bool, 2);
	P_80 = SLICE(SZP_16, bool, 5);
	S_83 = SLICE(SZP_16, bool, 0);
	if ((Mem14[eax + 4:byte] & 0x01) == 0x00)
	{
		Mem55[edx + 0x00:word32] = 0x00;
		Mem56[edx + 4:word32] = 0x01;
	}
	else
	{
		ecx_20 = CONVERT(Mem14[eax + 6:word16], word16, word32);
		ebx_21 = eax + 11 + ecx_20 * 0x02;
		edi_23 = Mem14[(ebx_21 & ~0x03) + 0x00:word32];
		ecx_24 = Mem14[(ebx_21 & ~0x03) + 4:word32];
		Mem26[edx + 0x00:word32] = 0x01;
		SZP_27 = cond(edi_23 & 0x03);
		P_81 = SLICE(SZP_27, bool, 5);
		al_29 = CONVERT((edi_23 & 0x03) != 0x00, bool, int8);
		eax_31 = SEQ(eax_24_8_30, al_29);
		Mem34[edx + 4:word32] = eax_31 & 0xFF;
		ebx_37 = (edi_23 & 0x03FFFFFC) + (ebx_21 & ~0x03);
		Mem38[edx + 8:word32] = ebx_37;
		Mem41[edx + 0x0C:word32] = ecx_24 >>u 0x0C;
		ebx_44 = ecx_24 >>u 0x04 & 0xFF;
		Mem45[edx + 16:word32] = ebx_44;
		ecx_47 = (ecx_24 & 0x0F) << 0x06;
		eax_50 = edi_23 >>u 0x1A | ecx_47;
		SZ_51 = cond(eax_50);
		S_84 = SLICE(SZ_51, bool, 0);
		Z_87 = SLICE(SZ_51, bool, 2);
		Mem54[edx + 20:word32] = eax_50;
	}
	Z_86 = ϕ(Z_19, Z_87);
	S_82 = ϕ(S_83, S_84);
	P_79 = ϕ(P_80, P_81);
	O_78 = false;
	ecx_76 = ϕ(ecx, ecx_47);
	eax_75 = ϕ(eax, eax_50);
	C_74 = false;
}

// 08070587: define caml_get_exception_backtrace
define caml_get_exception_backtrace
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 0x7C;
	SCZO = cond(esp);
	eax = Mem0[0x0807D294<p32>:word32];
	Mem0[ebp + -0x006C:word32] = eax;
	Mem0[ebp + -28:word32] = 0x00;
	Mem0[ebp + -32:word32] = 0x00;
	Mem0[ebp + -36:word32] = 0x00;
	Mem0[ebp + -40:word32] = 0x00;
	Mem0[ebp + -72:word32] = eax;
	eax = ebp - 72;
	Mem0[0x0807D294<p32>:word32] = eax;
	Mem0[ebp + -64:word32] = 0x01;
	Mem0[ebp + -0x0044:word32] = 0x04;
	eax = ebp - 28;
	Mem0[ebp + -60:word32] = eax;
	eax = ebp - 32;
	Mem0[ebp + -56:word32] = eax;
	eax = ebp - 36;
	Mem0[ebp + -52:word32] = eax;
	eax = ebp - 40;
	Mem0[ebp + -48:word32] = eax;
	Mem0[esp + 4:word32] = 0x00;
	eax = Mem0[0x080839C8<p32>:word32];
	Mem0[esp + 0x00:word32] = eax;
	caml_alloc();
	Mem0[ebp + -32:word32] = eax;
	SCZO = cond(Mem0[0x080839C8<p32>:word32] - 0x00);
	if (Test(GT,SZO))
	{
		ebx = 0x00;
		edi = ebp - 96;
		do
		{
			esi = 0x00 + ebx * 0x04;
			eax = Mem0[0x080839CC<p32>:word32];
			eax = Mem0[eax + esi:word32];
			edx = edi;
			extract_location_info();
			SCZO = cond(Mem0[ebp + -96:word32] - 0x00);
			if (Test(NE,Z))
			{
				eax = Mem0[ebp + -88:word32];
				Mem0[esp + 0x00:word32] = eax;
				caml_copy_string();
				Mem0[ebp + -40:word32] = eax;
				Mem0[esp + 4:word32] = 0x00;
				Mem0[esp + 0x00:word32] = 0x05;
				caml_alloc_small();
				SCZO = cond(Mem0[ebp + -92:word32] - 0x01);
				edx = edx - edx - C;
				edx &= ~0x01;
				edx += 0x03;
				SCZO = cond(edx);
				Mem0[ebp + -36:word32] = eax;
				Mem0[eax + 0x00:word32] = edx;
				edx = Mem0[ebp + -40:word32];
				eax = Mem0[ebp + -36:word32];
				Mem0[eax + 4:word32] = edx;
				eax = Mem0[ebp + -84:word32];
				edx = eax + 1 + eax;
				eax = Mem0[ebp + -36:word32];
				Mem0[eax + 8:word32] = edx;
				eax = Mem0[ebp + -80:word32];
				edx = eax + 1 + eax;
				eax = Mem0[ebp + -36:word32];
				Mem0[eax + 0x0C:word32] = edx;
				eax = Mem0[ebp + -76:word32];
				edx = eax + 1 + eax;
				eax = Mem0[ebp + -36:word32];
				Mem0[eax + 16:word32] = edx;
			}
			else
			{
				Mem0[esp + 4:word32] = 0x01;
				Mem0[esp + 0x00:word32] = 0x01;
				caml_alloc_small();
				SCZO = cond(Mem0[ebp + -92:word32] - 0x01);
				edx = edx - edx - C;
				edx &= ~0x01;
				edx += 0x03;
				SCZO = cond(edx);
				Mem0[ebp + -36:word32] = eax;
				Mem0[eax + 0x00:word32] = edx;
			}
			eax = Mem0[ebp + -36:word32];
			Mem0[esp + 4:word32] = eax;
			esi += Mem0[ebp + -32:word32];
			SCZO = cond(esi);
			Mem0[esp + 0x00:word32] = esi;
			caml_modify();
			++ebx;
			SCZO = cond(Mem0[0x080839C8<p32>:word32] - ebx);
		} while (Test(GT,SZO));
	}
	Mem0[esp + 4:word32] = 0x00;
	Mem0[esp + 0x00:word32] = 0x01;
	caml_alloc_small();
	Mem0[ebp + -28:word32] = eax;
	edx = Mem0[ebp + -32:word32];
	Mem0[eax + 0x00:word32] = edx;
	eax = Mem0[ebp + -0x006C:word32];
	Mem0[0x0807D294<p32>:word32] = eax;
	eax = Mem0[ebp + -28:word32];
	esp += 0x7C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070708: define caml_print_exception_backtrace
// Called from:
//      caml_fatal_uncaught_exception
define caml_print_exception_backtrace
{
	ptr32 fp;
	struct <anonymous> tLoc34;
	word32 eax;
	word32 ecx;
	word32 edx;
	bool P;
	Top_3 = 0;
	if (Mem16[0x080839C8<p32>:word32] > 0x00)
	{
		ebx_20 = 0x00;
		do
		{
			ebx_25 = ϕ(ebx_20, ebx_69);
			Mem23 = ϕ(Mem16, Mem70);
			eax_24 = Mem23[0x080839CC<p32>:word32];
			eax_26 = eax_24[ebx_25 * 0x04];
			edx_28 = &tLoc34;
			extract_location_info();
			if (Mem23[&tLoc34 + 0x00:word32] != 0x00)
			{
				eax_39 = 0x080723BC;
				SZP_40 = cond(ebx_25);
				P_135 = SLICE(SZP_40, bool, 5);
				if (ebx_25 != 0x00)
				{
					eax_45 = 134685638;
					if (Mem23[&tLoc34 + 4:word32] != 0x00)
						eax_48 = 0x080723D2;
				}
				eax_61 = ϕ(eax_39, eax_45, eax_48);
				edx_51 = Mem23[&tLoc34 + 20:word32];
				edx_55 = Mem54[&tLoc34 + 16:word32];
				edx_57 = Mem56[&tLoc34 + 0x0C:word32];
				edx_59 = Mem58[&tLoc34 + 8:word32];
				eax_64 = Mem63[0x0807D100<p32>:word32];
				eax_66 = fprintf(eax_64, 0x080723E0, eax_61, edx_59, edx_57, edx_55, edx_51);
			}
			P_133 = ϕ(P_135, P_35);
			edx_129 = ϕ(edx_59, edx_28);
			eax_122 = ϕ(eax_66, eax_29);
			Mem70 = ϕ(Mem65, Mem23);
			ebx_69 = ebx_25 + 0x01;
		} while (Mem70[0x080839C8<p32>:word32] > ebx_69);
	}
	P_131 = ϕ(P, P_133);
	edx_127 = ϕ(edx, edx_129);
	ecx_123 = ϕ(ecx, ecx_30);
	eax_120 = ϕ(eax, eax_122);
	SCZO_76 = cond(fp - 0x10);
	C_119 = SLICE(SCZO_76, bool, 1);
	O_130 = SLICE(SCZO_76, bool, 4);
	S_136 = SLICE(SCZO_76, bool, 0);
	Z_141 = SLICE(SCZO_76, bool, 2);
}

// 08070799: define caml_stash_backtrace
// Called from:
//      fn08070A44
//      fn08070A80
define caml_stash_backtrace
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	word32 dwArg0C;
	word32 dwArg10;
	word32 ecx;
	word32 edx;
	Top_3 = 0;
	ebx_19 = dwArg08;
	esi_20 = dwArg0C;
	if (dwArg04 != Mem16[0x0807D0A8<p32>:word32])
	{
		Mem23[0x080839C8<p32>:word32] = 0x00;
		Mem24[0x0807D0A8<p32>:word32] = dwArg04;
	}
	Mem25 = ϕ(Mem16, Mem24);
	if (Mem25[0x080839CC<p32>:word32] == 0x00)
	{
		eax_30 = malloc(0x1000);
		Mem31[0x080839CC<p32>:word32] = eax_30;
		SZP_32 = cond(eax_30);
		P_197 = SLICE(SZP_32, bool, 5);
		if (eax_30 == 0x00)
			goto l0807086C;
	}
	Mem36 = ϕ(Mem25, Mem31);
	if (Mem36[0x0807D29C<p32>:word32] == 0x00)
		caml_init_frame_descriptors();
	do
	{
		esi_87 = ϕ(esi_20, esi_20, esi_108);
		ebx_56 = ϕ(ebx_19, ebx_19, ebx_132);
		Mem54 = ϕ(Mem36, Mem36, Mem113);
		edi_55 = Mem54[0x08083EA0<p32>:word32];
		edx_58 = ebx_56 >>u 0x03;
		edx_59 = edx_58 & edi_55;
		ecx_60 = Mem54[0x0807D29C<p32>:word32];
		eax_61 = ecx_60[edx_59 * 0x04];
		SZP_62 = cond(eax_61);
		P_198 = SLICE(SZP_62, bool, 5);
		if (eax_61 == 0x00)
			break;
		if (Mem54[eax_61 + 0x00:word32] != ebx_56)
		{
			do
			{
				edx_68 = ϕ(edx_59, edx_71);
				edx_69 = edx_68 + 0x01;
				edx_71 = edx_69 & edi_55;
				eax_74 = ecx_60[edx_71 * 0x04];
				SZP_75 = cond(eax_74);
				P_200 = SLICE(SZP_75, bool, 5);
				if (eax_74 == 0x00)
					goto l0807086C;
			} while (Mem54[eax_74 + 0x00:word32] != ebx_56);
		}
		P_199 = ϕ(P_198, P_200);
		edx_193 = ϕ(edx_59, edx_71);
		eax_82 = ϕ(eax_61, eax_74);
		if (Mem54[eax_82 + 4:word16] != ~0x00)
		{
			edx_96 = Mem54[0x080839C8<p32>:word32];
			if (edx_96 > 0x03FF)
				break;
			ecx_99 = Mem54[0x080839CC<p32>:word32];
			ecx_99[edx_96 * 0x04] = eax_82;
			edx_101 = edx_96 + 0x01;
			Mem102[0x080839C8<p32>:word32] = edx_96 + 0x01;
			eax_103 = CONVERT(Mem102[eax_82 + 4:word16], word16, word32);
			eax_104 = eax_103 & 0xFFFC;
			esi_105 = esi_87 + (eax_103 & 0xFFFC);
			ebx_107 = Mem102[esi_105 + -4:word32];
		}
		else
		{
			eax_89 = esi_87 + 8;
			esi_90 = Mem54[eax_89 + 0x00:word32];
			ebx_91 = Mem54[eax_89 + 4:word32];
			SZP_92 = cond(esi_90);
			P_201 = SLICE(SZP_92, bool, 5);
			if (esi_90 == 0x00)
				break;
		}
		P_202 = ϕ(P_199, P_201);
		edx_194 = ϕ(edx_101, edx_193);
		ecx_189 = ϕ(ecx_99, ecx_60);
		eax_184 = ϕ(eax_104, eax_89);
		ebx_132 = ϕ(ebx_107, ebx_91);
		Mem113 = ϕ(Mem102, Mem54);
		esi_108 = ϕ(esi_105, esi_90);
	} while (esi_108 <=u dwArg10);
l0807086C:
	P_196 = ϕ(P_197, P_198, P_199, P_200, P_201, P_202);
	edx_190 = ϕ(edx, edx_59, edx_96, edx_71, edx_193, edx_194);
	ecx_185 = ϕ(ecx, ecx_60, ecx_60, ecx_60, ecx_60, ecx_189);
	eax_183 = ϕ(eax_30, eax_61, eax_82, eax_74, eax_89, eax_184);
	SCZO_122 = cond(fp - 0x10);
	C_182 = SLICE(SCZO_122, bool, 1);
	O_195 = SLICE(SCZO_122, bool, 4);
	S_203 = SLICE(SCZO_122, bool, 0);
	Z_209 = SLICE(SCZO_122, bool, 2);
}

// 08070874: define caml_record_backtrace
define caml_record_backtrace
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 0x18;
	eax = Mem0[ebp + 8:word32];
	eax >>= 0x01;
	SCZO = cond(eax - Mem0[0x080839C4<p32>:word32]);
	if (Test(NE,Z))
	{
		Mem0[0x080839C4<p32>:word32] = eax;
		Mem0[0x080839C8<p32>:word32] = 0x00;
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			Mem0[esp + 0x00:word32] = 0x0807D0A8;
			caml_register_global_root();
		}
		else
		{
			Mem0[esp + 0x00:word32] = 0x0807D0A8;
			caml_remove_global_root();
		}
	}
	eax = 0x01;
	esp = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080708BC: define caml_debugger_init
// Called from:
//      caml_main
define caml_debugger_init
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080708C1: define caml_debugger
define caml_debugger
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080708C6: define caml_debugger_cleanup_fork
// Called from:
//      unix_fork
define caml_debugger_cleanup_fork
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 080708CC: define fn080708CC
// Called from:
//      caml_curry9
//      caml_curry9_1
//      caml_curry9_2
//      caml_curry9_3
//      caml_curry9_4
//      caml_curry9_5
//      caml_curry9_6
//      caml_curry9_7
//      caml_curry7
//      caml_curry7_1
//      caml_curry7_2
//      caml_curry7_3
//      caml_curry7_4
//      caml_curry7_5
//      caml_curry6
//      caml_curry6_1
//      caml_curry6_2
//      caml_curry6_3
//      caml_curry6_4
//      caml_curry5
//      caml_curry5_1
//      caml_curry5_2
//      caml_curry5_3
//      caml_curry4
//      caml_curry4_1
//      caml_curry4_2
//      caml_curry3
//      caml_curry3_1
//      caml_curry2
//      camlSource__sortto_1060
//      camlSource__sort_floats_1031
//      camlUnix__fun_2842
//      camlUnix__fun_2828
//      camlUnix__get_port_1739
//      fn0804C080
//      fn0804C110
//      camlUnix__fun_2833
//      camlUnix__fun_2836
//      fn0804D330
//      fn0804D3C0
//      camlUnix__getaddrinfo_1751
//      fn0804D7A5
//      fn0804D7AC
//      fn0804D7B6
//      camlUnix__getnameinfo_1781
//      fn0804D8A0
//      fn0804DCC0
//      camlUnix__open_process_in_1957
//      camlUnix__open_process_out_1962
//      camlUnix__open_process_1967
//      fn0804E0B0
//      camlUnix__open_process_full_1985
//      camlUnix__find_proc_id_1997
//      camlUnix__close_process_in_2003
//      camlUnix__close_process_out_2006
//      camlUnix__close_process_2009
//      camlUnix__close_process_full_2013
//      fn0804E6B0
//      camlPervasives__string_of_float_1140
//      camlPervasives__$40_1143
//      camlPervasives__really_input_1235
//      camlPervasives__read_line_1288
//      camlPervasives__at_exit_1322
//      camlArray__fill_1070
//      camlArray__find_init_1077
//      camlArray__tolist_1123
//      camlArray__maxson_1155
//      camlArray__trickledown_1160
//      camlArray__bubbledown_1170
//      camlArray__trickleup_1178
//      camlArray__sortto_1217
//      camlArray__copy_1049
//      camlArray__append_1054
//      camlArray__sub_1081
//      camlArray__iter_1101
//      camlArray__map_1105
//      camlArray__iteri_1111
//      camlArray__mapi_1115
//      camlArray__to_list_1121
//      camlArray__of_list_1130
//      camlArray__fold_left_1139
//      camlArray__fold_right_1145
//      camlArray__sort_1152
//      camlArray__stable_sort_1188
//      camlList__find_1207
//      camlList__rev_sort_1272
//      camlList__sort_1271
//      camlList__rev_append_1051
//      camlList__map_1062
//      camlList__rev_map_1067
//      camlList__map2_1090
//      camlList__rev_map2_1099
//      camlList__assoc_1169
//      camlList__assq_1174
//      camlList__remove_assoc_1189
//      camlList__remove_assq_1195
//      camlList__find_1201
//      camlList__find_all_1205
//      camlList__partition_1212
//      camlList__split_1220
//      camlList__combine_1226
//      camlList__merge_1233
//      camlList__chop_1243
//      camlList__stable_sort_1248
//      camlString__concat_1066
//      camlString__escaped_1080
//      camlString__index_rec_1108
//      camlString__rindex_rec_1121
//      camlSys__fun_1093
//      camlSys__catch_break_1082
//      camlHashtbl__remove_bucket_1188
//      camlHashtbl__find_in_bucket_1213
//      camlHashtbl__replace_bucket_1221
//      camlHashtbl__insert_bucket_1068
//      camlHashtbl__remove_bucket_1083
//      camlHashtbl__find_in_bucket_1108
//      camlHashtbl__replace_bucket_1116
//      camlHashtbl__add_1179
//      camlHashtbl__remove_1185
//      camlHashtbl__find_1198
//      camlHashtbl__find_all_1210
//      camlHashtbl__replace_1217
//      camlHashtbl__mem_1227
//      camlHashtbl__create_1051
//      camlHashtbl__copy_1057
//      camlHashtbl__add_1074
//      camlHashtbl__remove_1080
//      camlHashtbl__find_rec_1088
//      camlHashtbl__find_1093
//      camlHashtbl__find_all_1105
//      camlHashtbl__replace_1112
//      camlHashtbl__mem_1122
//      camlHashtbl__iter_1129
//      camlHashtbl__fold_1138
//      camlHashtbl__Make_1251
//      camlBuffer__resize_1066
//      camlBuffer__closing_1097
//      camlBuffer__advance_to_closing_1098
//      camlBuffer__advance_to_non_alpha_1108
//      camlBuffer__find_ident_1114
//      camlBuffer__add_substitute_1122
//      camlPrintf__fun_1568
//      camlPrintf__got_spec_1304
//      camlPrintf__cont_m_1365
//      camlPrintf__parse_1069
//      camlPrintf__skip_positional_spec_1090
//      camlPrintf__fill_format_1096
//      camlPrintf__get_arg_1288
//      camlPrintf__pr_1354
//      camlPrintf__index_of_int_1037
//      camlPrintf__parse_string_conversion_1067
//      camlPrintf__extract_format_1085
//      camlPrintf__sub_format_1117
//      camlPrintf__iter_on_format_args_1137
//      camlPrintf__summarize_format_type_1162
//      camlPrintf__ac_of_format_1184
//      camlPrintf__list_iter_i_1201
//      camlPrintf__fun_1600
//      camlPrintf__scan_format_1278
//      camlPrintf__mkprintf_1345
//      camlPrintf__fprintf_1391
//      camlPrintf__bprintf_1400
//      camlPrintf__get_buff_1402
//      camlCallback__register_exception_1034
define fn080708CC
{
	ptr32 fp;
	word32 dwArg00;
	Top_3 = 0;
	Mem6[0x0807CFCC<p32>:word32] = dwArg00;
	Mem8[0x0807D2A0<p32>:word32] = fp + 4;
	Mem29[0x08083EA8<p32>:word32] = fp - 28;
	caml_garbage_collection();
	eax_39 = fp + 4;
}

// 080708DD: define fn080708DD
// Called from:
//      fn080708F8
//      fn0807092C
//      fn08070960
//      fn08070994
define fn080708DD
{
	ptr32 fp;
	Top_3 = 0;
	Mem25[0x08083EA8<p32>:word32] = fp - 28;
	caml_garbage_collection();
}

// 080708F8: define fn080708F8
// Called from:
//      camlSource__entry
//      camlPervasives__entry
//      camlArray__entry
define fn080708F8
{
	ptr32 fp;
	<unknown> Mem0;
	word32 dwArg00;
	bool P;
	Top_3 = 0;
	while (true)
	{
		P_24 = ϕ(P, P_19);
		Mem4 = ϕ(Mem0, Mem14);
		eax_5 = Mem4[0x08080414<p32>:word32];
		eax_6 = eax_5 - 0x08;
		Mem7[0x08080414<p32>:word32] = eax_5 - 0x08;
		SCZO_8 = cond(eax_5 - 0x08 - Mem7[0x08080418<p32>:word32]);
		C_9 = SLICE(SCZO_8, bool, 1);
		O_23 = SLICE(SCZO_8, bool, 4);
		S_26 = SLICE(SCZO_8, bool, 0);
		Z_28 = SLICE(SCZO_8, bool, 2);
		if (eax_5 - 0x08 >=u Mem7[0x08080418<p32>:word32])
			break;
		Mem12[0x0807CFCC<p32>:word32] = dwArg00;
		Mem14[0x0807D2A0<p32>:word32] = fp + 4;
		fn080708DD();
	}
}

// 0807092C: define fn0807092C
// Called from:
//      camlSource__entry
//      fn0804BE02
define fn0807092C
{
	ptr32 fp;
	<unknown> Mem0;
	word32 dwArg00;
	bool P;
	Top_3 = 0;
	while (true)
	{
		P_24 = ϕ(P, P_19);
		Mem4 = ϕ(Mem0, Mem14);
		eax_5 = Mem4[0x08080414<p32>:word32];
		eax_6 = eax_5 - 0x0C;
		Mem7[0x08080414<p32>:word32] = eax_5 - 0x0C;
		SCZO_8 = cond(eax_5 - 0x0C - Mem7[0x08080418<p32>:word32]);
		C_9 = SLICE(SCZO_8, bool, 1);
		O_23 = SLICE(SCZO_8, bool, 4);
		S_26 = SLICE(SCZO_8, bool, 0);
		Z_28 = SLICE(SCZO_8, bool, 2);
		if (eax_5 - 0x0C >=u Mem7[0x08080418<p32>:word32])
			break;
		Mem12[0x0807CFCC<p32>:word32] = dwArg00;
		Mem14[0x0807D2A0<p32>:word32] = fp + 4;
		fn080708DD();
	}
}

// 08070960: define fn08070960
// Called from:
//      camlSys__entry
define fn08070960
{
	ptr32 fp;
	<unknown> Mem0;
	word32 dwArg00;
	bool P;
	Top_3 = 0;
	while (true)
	{
		P_24 = ϕ(P, P_19);
		Mem4 = ϕ(Mem0, Mem14);
		eax_5 = Mem4[0x08080414<p32>:word32];
		eax_6 = eax_5 - 0x10;
		Mem7[0x08080414<p32>:word32] = eax_5 - 0x10;
		SCZO_8 = cond(eax_5 - 0x10 - Mem7[0x08080418<p32>:word32]);
		C_9 = SLICE(SCZO_8, bool, 1);
		O_23 = SLICE(SCZO_8, bool, 4);
		S_26 = SLICE(SCZO_8, bool, 0);
		Z_28 = SLICE(SCZO_8, bool, 2);
		if (eax_5 - 0x10 >=u Mem7[0x08080418<p32>:word32])
			break;
		Mem12[0x0807CFCC<p32>:word32] = dwArg00;
		Mem14[0x0807D2A0<p32>:word32] = fp + 4;
		fn080708DD();
	}
}

// 08070994: define fn08070994
// Called from:
//      camlSource__entry
//      camlUnix__entry
//      fn0804EEAA
//      fn0804EEF2
//      camlPervasives__entry
//      camlPrintf__entry
define fn08070994
{
	ptr32 fp;
	word32 eax;
	<unknown> Mem0;
	word32 dwArg00;
	bool P;
	Top_3 = 0;
	while (true)
	{
		P_36 = ϕ(P, P_26);
		Mem5 = ϕ(Mem0, Mem21);
		eax_4 = ϕ(eax, eax_27);
		eax_6 = eax_4 - Mem5[0x08080414<p32>:word32];
		eax_7 = -eax_6;
		SCZO_8 = cond(eax_7 - Mem5[0x08080418<p32>:word32]);
		C_9 = SLICE(SCZO_8, bool, 1);
		O_35 = SLICE(SCZO_8, bool, 4);
		S_38 = SLICE(SCZO_8, bool, 0);
		Z_40 = SLICE(SCZO_8, bool, 2);
		if (eax_7 >=u Mem5[0x08080418<p32>:word32])
			break;
		eax_10 = eax_7 - Mem5[0x08080414<p32>:word32];
		eax_11 = -eax_10;
		v8_15 = Mem14[0x08080414<p32>:word32] - eax_11;
		Mem16[0x08080414<p32>:word32] = v8_15;
		Mem19[0x0807CFCC<p32>:word32] = dwArg00;
		Mem21[0x0807D2A0<p32>:word32] = fp + 4;
		fn080708DD();
		eax_27 = eax_11;
	}
	Mem29[0x08080414<p32>:word32] = eax_7;
}

// 080709D8: define fn080709D8
// Called from:
//      camlSource__sort_floats_1031
//      camlSource__entry
//      fn0804BE02
//      fn0804C080
//      fn0804C110
//      camlUnix__fun_2857
//      camlUnix__fun_2863
//      camlUnix__fun_2562
//      camlUnix__fun_2564
//      camlUnix__fun_2566
//      camlUnix__fun_2568
//      camlUnix__fun_2570
//      camlUnix__fun_2572
//      camlUnix__fun_2574
//      camlUnix__fun_2576
//      camlUnix__fun_2578
//      camlUnix__fun_2580
//      camlUnix__fun_2582
//      camlUnix__fun_2584
//      camlUnix__fun_2586
//      camlUnix__fun_2588
//      camlUnix__fun_2590
//      camlUnix__fun_2592
//      camlUnix__fun_2594
//      camlUnix__fun_2596
//      camlUnix__fun_2598
//      camlUnix__fun_2600
//      camlUnix__fun_2602
//      camlUnix__fun_2604
//      camlUnix__fun_2606
//      camlUnix__fun_2608
//      camlUnix__fun_2610
//      camlUnix__fun_2612
//      camlUnix__fun_2614
//      camlUnix__fun_2616
//      camlUnix__fun_2618
//      camlUnix__fun_2620
//      camlUnix__fun_2622
//      camlUnix__fun_2624
//      camlUnix__fun_2626
//      camlUnix__fun_2628
//      camlUnix__fun_2630
//      camlUnix__fun_2632
//      camlUnix__fun_2634
//      camlUnix__fun_2636
//      camlUnix__fun_2638
//      camlUnix__fun_2640
//      camlUnix__fun_2642
//      camlUnix__fun_2644
//      camlUnix__fun_2646
//      camlUnix__fun_2648
//      camlUnix__fun_2650
//      camlUnix__fun_2652
//      camlUnix__fun_2654
//      camlUnix__fun_2656
//      camlUnix__fun_2658
//      camlUnix__fun_2660
//      camlUnix__fun_2662
//      camlUnix__fun_2664
//      camlUnix__fun_2666
//      camlUnix__fun_2668
//      camlUnix__fun_2670
//      camlUnix__fun_2672
//      camlUnix__fun_2674
//      camlUnix__fun_2676
//      camlUnix__fun_2678
//      camlUnix__fun_2680
//      camlUnix__fun_2682
//      camlUnix__fun_2684
//      camlUnix__fun_2686
//      camlUnix__fun_2688
//      camlUnix__fun_2690
//      camlUnix__fun_2692
//      camlUnix__fun_2694
//      camlUnix__fun_2696
//      camlUnix__fun_2698
//      camlUnix__fun_2700
//      camlUnix__fun_2702
//      camlUnix__fun_2704
//      camlUnix__fun_2706
//      camlUnix__fun_2708
//      camlUnix__fun_2710
//      camlUnix__fun_2712
//      camlUnix__fun_2714
//      camlUnix__fun_2716
//      camlUnix__fun_2718
//      camlUnix__fun_2720
//      camlUnix__fun_2722
//      camlUnix__fun_2724
//      camlUnix__fun_2726
//      camlUnix__fun_2728
//      camlUnix__fun_2730
//      camlUnix__fun_2732
//      camlUnix__fun_2734
//      camlUnix__fun_2736
//      camlUnix__fun_2738
//      camlUnix__fun_2740
//      camlUnix__fun_2742
//      camlUnix__fun_2744
//      camlUnix__fun_2746
//      camlUnix__fun_2748
//      camlUnix__fun_2750
//      camlUnix__fun_2752
//      camlUnix__fun_2754
//      camlUnix__fun_2756
//      camlUnix__fun_2758
//      camlUnix__fun_2760
//      camlUnix__fun_2762
//      camlUnix__fun_2764
//      camlUnix__fun_2766
//      camlUnix__fun_2768
//      camlUnix__fun_2770
//      camlUnix__fun_2772
//      camlUnix__fun_2774
//      camlUnix__fun_2776
//      camlUnix__fun_2778
//      camlUnix__fun_2780
//      camlUnix__fun_2782
//      camlUnix__handle_unix_error_1171
//      camlUnix__read_1237
//      camlUnix__write_1242
//      camlUnix__single_write_1247
//      camlUnix__fun_2804
//      camlUnix__fun_2802
//      camlUnix__fun_2800
//      camlUnix__fun_2798
//      camlUnix__fun_2796
//      camlUnix__fun_2794
//      fn0804CCD0
//      camlUnix__pause_1408
//      camlUnix__recv_1558
//      camlUnix__recvfrom_1564
//      camlUnix__send_1570
//      camlUnix__sendto_1576
//      camlUnix__fun_2816
//      camlUnix__fun_2814
//      camlUnix__getsockopt_1643
//      camlUnix__setsockopt_1646
//      camlUnix__getsockopt_int_1650
//      camlUnix__setsockopt_int_1653
//      camlUnix__getsockopt_optint_1657
//      camlUnix__setsockopt_optint_1660
//      camlUnix__getsockopt_float_1664
//      camlUnix__setsockopt_float_1667
//      camlUnix__getsockopt_error_1671
//      fn0804D330
//      fn0804D3C0
//      fn0804D510
//      fn0804D600
//      fn0804D6B0
//      camlUnix__getnameinfo_1781
//      fn0804D810
//      camlUnix__system_1891
//      fn0804D8A0
//      camlUnix__safe_dup_1894
//      fn0804D990
//      camlUnix__perform_redirections_1900
//      camlUnix__create_process_1907
//      fn0804DAE0
//      camlUnix__create_process_env_1914
//      fn0804DB90
//      camlUnix__open_proc_1949
//      fn0804DCC0
//      camlUnix__open_process_in_1957
//      camlUnix__open_process_out_1962
//      camlUnix__open_process_1967
//      camlUnix__open_proc_full_1975
//      fn0804E0B0
//      camlUnix__open_process_full_1985
//      fn0804E3E0
//      camlUnix__close_process_in_2003
//      camlUnix__close_process_2009
//      camlUnix__close_process_full_2013
//      fn0804E610
//      camlUnix__open_connection_2018
//      fn0804E6B0
//      camlUnix__shutdown_connection_2022
//      fn0804E7A0
//      camlUnix__establish_server_2026
//      camlUnix__entry
//      fn0804EEAA
//      fn0804EEF2
//      fn0804F8A0
//      camlPervasives__fun_1392
//      camlPervasives__fun_1394
//      camlPervasives__fun_1396
//      camlPervasives__fun_1398
//      camlPervasives__fun_1400
//      camlPervasives__fun_1402
//      camlPervasives__fun_1404
//      camlPervasives__fun_1406
//      camlPervasives__fun_1408
//      camlPervasives__fun_1410
//      camlPervasives__fun_1412
//      camlPervasives__fun_1414
//      camlPervasives__fun_1416
//      camlPervasives__fun_1418
//      camlPervasives__fun_1420
//      camlPervasives__fun_1422
//      camlPervasives__fun_1424
//      camlPervasives__min_1022
//      camlPervasives__max_1025
//      camlPervasives__$5e_1112
//      camlPervasives__string_of_int_1130
//      camlPervasives__string_of_float_1140
//      camlPervasives__open_out_bin_1181
//      camlPervasives__flush_all_1185
//      camlPervasives__output_string_1191
//      camlPervasives__output_value_1202
//      camlPervasives__close_out_1209
//      fn08050130
//      fn08050170
//      camlPervasives__open_in_bin_1220
//      camlPervasives__input_1224
//      camlPervasives__really_input_1235
//      fn080503A0
//      camlPervasives__print_char_1266
//      camlPervasives__print_endline_1274
//      camlPervasives__print_newline_1276
//      camlPervasives__prerr_char_1277
//      camlPervasives__prerr_endline_1285
//      camlPervasives__prerr_newline_1287
//      camlPervasives__read_line_1288
//      camlPervasives__read_int_1289
//      camlPervasives__read_float_1290
//      camlPervasives__fun_1495
//      camlPervasives__fun_1493
//      camlPervasives__fun_1491
//      camlPervasives__fun_1489
//      camlPervasives__fun_1487
//      camlPervasives__fun_1485
//      camlPervasives__string_of_format_1315
//      camlPervasives__exit_1326
//      camlPervasives__entry
//      camlArray__find_init_1077
//      camlArray__init_1037
//      camlArray__make_matrix_1042
//      camlArray__copy_1049
//      camlArray__append_1054
//      camlArray__sub_1081
//      camlArray__map_1105
//      camlArray__mapi_1115
//      camlArray__of_list_1130
//      camlArray__stable_sort_1188
//      camlList__mem_1161
//      camlList__assoc_1169
//      camlList__mem_assoc_1179
//      camlList__remove_assoc_1189
//      camlChar__escaped_1038
//      camlString__make_1038
//      camlString__copy_1042
//      camlString__sub_1046
//      camlString__concat_1066
//      camlString__escaped_1080
//      camlString__lowercase_1098
//      camlSys__catch_break_1082
//      camlSys__entry
//      camlHashtbl__remove_bucket_1083
//      camlHashtbl__find_in_bucket_1108
//      camlHashtbl__replace_bucket_1116
//      camlHashtbl__create_1051
//      camlHashtbl__find_rec_1088
//      camlHashtbl__find_1093
//      camlHashtbl__replace_1112
//      camlHashtbl__mem_1122
//      camlBuffer__sub_1046
//      camlBuffer__resize_1066
//      camlBuffer__output_buffer_1094
//      camlPrintf__parse_1069
//      camlPrintf__fun_1587
//      camlPrintf__fun_1584
//      camlPrintf__fun_1581
//      camlPrintf__fun_1578
//      camlPrintf__fun_1575
//      camlPrintf__fun_1572
//      camlPrintf__fun_1600
//      camlPrintf__mkprintf_1345
//      camlPrintf__get_buff_1402
//      camlCallback__register_1031
//      camlCallback__register_exception_1034
define fn080709D8
{
	ptr32 fp;
	word32 eax;
	word32 dwArg00;
	Top_3 = 0;
	Mem6[0x0807CFCC<p32>:word32] = dwArg00;
	Mem8[0x0807D2A0<p32>:word32] = fp + 4;
	eax();
}

// 080709F0: define fn080709F0
// Called from:
//      caml_main
define fn080709F0
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	esi = 134523344;
	v8 = Mem0[0x08083EA8<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v8;
	v9 = Mem0[0x0807CFCC<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v9;
	v10 = Mem0[0x0807D2A0<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v10;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x08070A3E;
	v11 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v11;
	Mem0[0x0807D280<p32>:word32] = esp;
	esi();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[0x0807D2A0<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	Mem0[0x0807CFCC<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	Mem0[0x08083EA8<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070A44: define fn08070A44
// Called from:
//      camlUnix__get_port_1739
//      camlUnix__handle_unix_error_1171
//      camlUnix__try_set_close_on_exec_1366
//      camlUnix__getaddrinfo_1751
//      fn0804D600
//      fn0804D6B0
//      camlUnix__getnameinfo_1781
//      camlUnix__safe_close_1898
//      camlUnix__find_proc_id_1997
//      camlUnix__waitpid_non_intr_2001
//      camlUnix__close_process_2009
//      camlUnix__close_process_full_2013
//      camlUnix__open_connection_2018
//      camlUnix__accept_non_intr_2024
//      camlUnix__entry
//      fn0804EEAA
//      camlPervasives__really_input_1235
//      camlPervasives__read_line_1288
//      camlArray__maxson_1155
//      camlArray__trickle_1165
//      camlArray__bubble_1174
//      camlArray__trickleup_1178
//      camlArray__sub_1081
//      camlList__assoc_1169
//      camlList__assq_1174
//      camlList__find_1201
//      camlList__chop_1243
//      camlString__index_rec_1108
//      camlString__rindex_rec_1121
//      camlString__contains_1137
//      camlString__rcontains_from_1140
//      camlSys__fun_1093
//      camlHashtbl__replace_bucket_1221
//      camlHashtbl__insert_bucket_1068
//      camlHashtbl__replace_bucket_1116
//      camlHashtbl__add_1179
//      camlHashtbl__remove_1185
//      camlHashtbl__find_1198
//      camlHashtbl__find_all_1210
//      camlHashtbl__replace_1217
//      camlHashtbl__mem_1227
//      camlHashtbl__add_1074
//      camlHashtbl__remove_1080
//      camlHashtbl__find_rec_1088
//      camlHashtbl__find_1093
//      camlHashtbl__find_all_1105
//      camlHashtbl__replace_1112
//      camlHashtbl__mem_1122
//      camlBuffer__closing_1097
//      camlBuffer__advance_to_closing_1098
//      camlBuffer__find_ident_1114
//      camlPrintf__fill_format_1096
//      camlPrintf__index_of_int_1037
//      camlPrintf__parse_string_conversion_1067
define fn08070A44
{
	ptr32 fp;
	<unknown> Mem0;
	word32 eax;
	word32 dwArg00;
	word32 ecx;
	word32 edi;
	word32 edx;
	word32 esi;
	Top_3 = 0;
	SZP_5 = cond(Mem0[0x080839C4<p32>:word32] & 0x01);
	Z_8 = SLICE(SZP_5, bool, 2);
	P_55 = SLICE(SZP_5, bool, 5);
	S_57 = SLICE(SZP_5, bool, 0);
	O_6 = false;
	C_7 = false;
	if ((Mem0[0x080839C4<p32>:word32] & 0x01) != 0x00)
	{
		esi_10 = eax;
		edi_11 = Mem0[0x0807D280<p32>:word32];
		caml_stash_backtrace();
		Mem32[0x0807D280<p32>:word32] = Mem21[edi_11 + 0x00:word32];
		esp_33 = edi_11 + 4;
	}
	else
	{
		esp_34 = Mem0[0x0807D280<p32>:word32];
		Mem35[0x0807D280<p32>:word32] = Mem0[esp_34 + 0x00:word32];
		esp_36 = fp;
	}
}

// 08070A80: define fn08070A80
// Called from:
//      caml_raise
define fn08070A80
{
	<unknown> Mem0;
	word32 dwArg04;
	word32 esi;
	Top_3 = 0;
	SZP_5 = cond(Mem0[0x080839C4<p32>:word32] & 0x01);
	Z_8 = SLICE(SZP_5, bool, 2);
	P_45 = SLICE(SZP_5, bool, 5);
	S_48 = SLICE(SZP_5, bool, 0);
	O_6 = false;
	C_7 = false;
	if ((Mem0[0x080839C4<p32>:word32] & 0x01) != 0x00)
	{
		esi_9 = dwArg04;
		v10_10 = Mem0[0x0807D280<p32>:word32];
		v11_13 = Mem12[0x0807D2A0<p32>:word32];
		v12_16 = Mem15[0x0807CFCC<p32>:word32];
		caml_stash_backtrace();
		C_37 = SLICE(SCZOP_22, bool, 1);
		O_43 = SLICE(SCZOP_22, bool, 4);
		P_46 = SLICE(SCZOP_22, bool, 5);
		S_49 = SLICE(SCZOP_22, bool, 0);
		Z_52 = SLICE(SCZOP_22, bool, 2);
		esp_24 = Mem20[0x0807D280<p32>:word32];
		Mem25[0x0807D280<p32>:word32] = Mem20[esp_24 + 0x00:word32];
	}
	else
	{
		esp_28 = Mem0[0x0807D280<p32>:word32];
		Mem29[0x0807D280<p32>:word32] = Mem0[esp_28 + 0x00:word32];
	}
}

// 08070AC8: define fn08070AC8
// Called from:
//      caml_execute_signal
//      caml_fatal_uncaught_exception
//      caml_callback
//      caml_callbackN_exn
//      caml_final_do_calls
define fn08070AC8
{
	ptr32 fp;
	word32 dwArg04;
	word32 dwArg08;
	Top_3 = 0;
	esi_18 = Mem15[dwArg04 + 0x00:word32];
	v9_19 = Mem15[0x08083EA8<p32>:word32];
	v10_22 = Mem21[0x0807CFCC<p32>:word32];
	v11_25 = Mem24[0x0807D2A0<p32>:word32];
	v12_30 = Mem29[0x0807D280<p32>:word32];
	Mem33[0x0807D280<p32>:word32] = fp - 36;
	esi_18();
	Mem36[0x0807D280<p32>:word32] = v12_30;
	SCZO_39 = cond(fp - 0x1C);
	C_65 = SLICE(SCZO_39, bool, 1);
	O_66 = SLICE(SCZO_39, bool, 4);
	S_67 = SLICE(SCZO_39, bool, 0);
	Z_68 = SLICE(SCZO_39, bool, 2);
	Mem40[0x0807D2A0<p32>:word32] = v11_25;
	Mem42[0x0807CFCC<p32>:word32] = v10_22;
	Mem44[0x08083EA8<p32>:word32] = v9_19;
}

// 08070ADC: define fn08070ADC
// Called from:
//      caml_callback2
//      caml_callbackN_exn
define fn08070ADC
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ecx = Mem0[esp + 20:word32];
	eax = Mem0[esp + 24:word32];
	ebx = Mem0[esp + 28:word32];
	esi = 0x0804B540;
	v10 = Mem0[0x08083EA8<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v10;
	v11 = Mem0[0x0807CFCC<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v11;
	v12 = Mem0[0x0807D2A0<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v12;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x08070A3E;
	v13 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v13;
	Mem0[0x0807D280<p32>:word32] = esp;
	esi();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[0x0807D2A0<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	Mem0[0x0807CFCC<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	Mem0[0x08083EA8<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070AF8: define fn08070AF8
// Called from:
//      caml_callback3
//      caml_callbackN_exn
define fn08070AF8
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	edx = Mem0[esp + 20:word32];
	eax = Mem0[esp + 24:word32];
	ebx = Mem0[esp + 28:word32];
	ecx = Mem0[esp + 32:word32];
	esi = 0x0804B4F0;
	v11 = Mem0[0x08083EA8<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v11;
	v12 = Mem0[0x0807CFCC<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v12;
	v13 = Mem0[0x0807D2A0<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v13;
	esp -= 4;
	Mem0[esp + 0x00:word32] = 0x08070A3E;
	v14 = Mem0[0x0807D280<p32>:word32];
	esp -= 4;
	Mem0[esp + 0x00:word32] = v14;
	Mem0[0x0807D280<p32>:word32] = esp;
	esi();
	Mem0[0x0807D280<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	esp += 0x04;
	SCZO = cond(esp);
	Mem0[0x0807D2A0<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	Mem0[0x0807CFCC<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	Mem0[0x08083EA8<p32>:word32] = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070B18: define fn08070B18
// Called from:
//      camlUnix__handle_unix_error_1171
//      camlPervasives__string_of_float_1140
//      camlArray__maxson_1155
//      camlArray__trickledown_1160
//      camlArray__trickle_1165
//      camlArray__bubbledown_1170
//      camlArray__trickleup_1178
//      camlArray__sortto_1217
//      camlArray__sort_1152
//      camlArray__stable_sort_1188
//      camlHashtbl__insert_bucket_1068
//      camlHashtbl__add_1179
//      camlHashtbl__remove_1185
//      camlHashtbl__find_1198
//      camlHashtbl__find_all_1210
//      fn080578D0
//      fn08057937
//      fn0805793C
//      camlHashtbl__mem_1227
//      camlHashtbl__clear_1054
//      camlHashtbl__add_1074
//      camlHashtbl__remove_1080
//      camlHashtbl__find_1093
//      camlHashtbl__find_all_1105
//      camlHashtbl__replace_1112
//      fn080582B0
//      fn08058317
//      fn0805831C
//      camlHashtbl__mem_1122
//      camlHashtbl__iter_1129
//      camlHashtbl__fold_1138
//      camlBuffer__nth_1057
//      camlBuffer__add_char_1072
//      camlBuffer__advance_to_closing_1098
//      camlBuffer__advance_to_non_alpha_1108
//      camlBuffer__find_ident_1114
//      camlBuffer__add_substitute_1122
//      camlPrintf__loop_1159
//      camlPrintf__fun_1565
//      camlPrintf__scan_fmt_1144
//      camlPrintf__fun_1587
//      camlPrintf__fun_1584
//      camlPrintf__fun_1581
//      camlPrintf__fun_1578
//      camlPrintf__fun_1575
//      camlPrintf__fun_1572
//      camlPrintf__get_arg_1288
//      camlPrintf__extract_format_int_1103
//      camlPrintf__extract_format_float_1110
//      camlPrintf__sub_format_1117
//      camlPrintf__fun_1600
define fn08070B18
{
	esp = fp;
	Top = 0;
	__ffree(ST[Top + 0x00:real64]);
	__ffree(ST[Top + 1:real64]);
	__ffree(ST[Top + 2:real64]);
	__ffree(ST[Top + 3:real64]);
	__ffree(ST[Top + 4:real64]);
	__ffree(ST[Top + 5:real64]);
	__ffree(ST[Top + 6:real64]);
	__ffree(ST[Top + 7:real64]);
	edx = Mem0[esp + 0x00:word32];
	Mem0[0x0807CFCC<p32>:word32] = edx;
	edx = esp + 4;
	Mem0[0x0807D2A0<p32>:word32] = edx;
	caml_array_bound_error();
	__divdi3();
}

// 08070B40: define __divdi3
// Called from:
//      caml_int64_div
//      fn08070B18
define __divdi3
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 0x20;
	ecx = Mem0[ebp + 0x0C:word32];
	esi = Mem0[ebp + 16:word32];
	edi = Mem0[ebp + 20:word32];
	edx = Mem0[ebp + 8:word32];
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	Mem0[ebp + -16:word32] = esi;
	Mem0[ebp + -0x0C:word32] = edi;
	Mem0[ebp + -20:word32] = 0x00;
	if (Test(NS,S))
	{
		esi = Mem0[ebp + -0x0C:word32];
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(NS,S))
			goto l08070B74;
	}
	else
	{
		esi = Mem0[ebp + -0x0C:word32];
		C = edx != 0x00;
		edx = -edx;
		ecx = ecx + 0x00 + C;
		ecx = -ecx;
		Mem0[ebp + -20:word32] = ~0x00;
		SZP = cond(esi & esi);
		O = false;
		C = false;
		if (Test(NS,S))
			goto l08070B74;
	}
	v21 = Mem0[ebp + -16:word32];
	C = v21 != 0x00;
	v22 = -v21;
	Mem0[ebp + -16:word32] = v22;
	v23 = Mem0[ebp + -0x0C:word32] + 0x00 + C;
	Mem0[ebp + -0x0C:word32] = v23;
	v24 = ~Mem0[ebp + -20:word32];
	Mem0[ebp + -20:word32] = v24;
	v25 = Mem0[ebp + -0x0C:word32];
	C = v25 != 0x00;
	v26 = -v25;
	Mem0[ebp + -0x0C:word32] = v26;
	SZO = cond(v26);
l08070B74:
	eax = Mem0[ebp + -0x0C:word32];
	edi = ecx;
	esi = Mem0[ebp + -16:word32];
	Mem0[ebp + -16:word32] = edx;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		SCZO = cond(esi - ecx);
		if (Test(UGT,CZ))
		{
			ecx = edx;
			edx = edi;
			eax = ecx;
			edi = edi ^ edi;
			v19 = edx_eax;
			edx = CONVERT(v19 %u esi, word64, uint32);
			eax = CONVERT(v19 /u esi, word32, uint32);
			SCZO = cond(eax);
			ecx = eax;
		}
		else
		{
			SZP = cond(esi & esi);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				eax = 0x01;
				edx = edx ^ edx;
				v27 = edx_eax;
				edx = CONVERT(v27 %u esi, word64, uint32);
				eax = CONVERT(v27 /u esi, word32, uint32);
				SCZO = cond(eax);
				esi = eax;
			}
			ecx = Mem0[ebp + -16:word32];
			eax = edi;
			edx = edx ^ edx;
			v28 = edx_eax;
			edx = CONVERT(v28 %u esi, word64, uint32);
			eax = CONVERT(v28 /u esi, word32, uint32);
			edi = eax;
			eax = ecx;
			v29 = edx_eax;
			edx = CONVERT(v29 %u esi, word64, uint32);
			eax = CONVERT(v29 /u esi, word32, uint32);
			SCZO = cond(eax);
			ecx = eax;
		}
l08070BA0:
		eax = ecx;
		ecx = Mem0[ebp + -20:word32];
		edx = edi;
		SZP = cond(ecx & ecx);
		O = false;
		C = false;
		if (Test(NE,Z))
		{
			C = eax != 0x00;
			eax = -eax;
			edx = edx + 0x00 + C;
			C = edx != 0x00;
			edx = -edx;
			SZO = cond(edx);
		}
		esp += 0x20;
		SCZO = cond(esp);
		esi = Mem0[esp + 0x00:word32];
		esp += 4;
		edi = Mem0[esp + 0x00:word32];
		esp += 4;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
		return;
	}
	SCZO = cond(eax - ecx);
	if (Test(UGT,CZ))
	{
l08070B9C:
		edi = edi ^ edi;
		ecx = ecx ^ ecx;
		SZ = cond(ecx);
		O = false;
		C = false;
		goto l08070BA0;
	}
	edx = __bsr<word32>(eax);
	edx = edx ^ 0x1F;
	SZ = cond(edx);
	O = false;
	C = false;
	Mem0[ebp + -24:word32] = edx;
	if (Test(EQ,Z))
	{
		SCZO = cond(esi - Mem0[ebp + -16:word32]);
		if (Test(UGT,CZ))
		{
			SCZO = cond(eax - ecx);
			if (Test(UGE,C))
				goto l08070B9C;
		}
		edi = edi ^ edi;
		SZ = cond(edi);
		O = false;
		C = false;
		ecx = 0x01;
		goto l08070BA0;
	}
	ecx = CONVERT(Mem0[ebp + -24:byte], byte, word32);
	edx = esi;
	eax <<= cl;
	Mem0[ebp + -28:word32] = eax;
	eax = 0x20;
	eax -= Mem0[ebp + -24:word32];
	ecx = eax;
	edx >>= cl;
	ecx = CONVERT(Mem0[ebp + -24:byte], byte, word32);
	edx |= Mem0[ebp + -28:word32];
	esi <<= cl;
	ecx = eax;
	Mem0[ebp + -32:word32] = esi;
	esi = edi;
	esi >>= cl;
	ecx = CONVERT(Mem0[ebp + -24:byte], byte, word32);
	Mem0[ebp + -28:word32] = edx;
	edx = Mem0[ebp + -16:word32];
	edi <<= cl;
	ecx = eax;
	edx >>= cl;
	edi |= edx;
	edx = esi;
	eax = edi;
	v31 = edx_eax;
	edx = CONVERT(v31 %u Mem0[ebp + -28:word32], word64, uint32);
	eax = CONVERT(v31 /u Mem0[ebp + -28:word32], word32, uint32);
	esi = edx;
	edi = eax;
	edx_eax = Mem0[ebp + -32:word32] *u64 eax;
	SCZO = cond(esi - edx);
	Mem0[ebp + -28:word32] = edx;
	if (Test(UGE,C))
	{
		edx = Mem0[ebp + -16:word32];
		ecx = CONVERT(Mem0[ebp + -24:byte], byte, word32);
		edx <<= cl;
		SCZO = cond(edx - eax);
		if (Test(UGE,C))
		{
l08070C9A:
			ecx = edi;
			edi = edi ^ edi;
			SZ = cond(edi);
			O = false;
			C = false;
			goto l08070BA0;
		}
		SCZO = cond(esi - Mem0[ebp + -28:word32]);
		if (Test(NE,Z))
			goto l08070C9A;
	}
	ecx = edi - 1;
	edi = edi ^ edi;
	SZ = cond(edi);
	O = false;
	C = false;
	goto l08070BA0;
}

// 08070CC0: define __moddi3
// Called from:
//      caml_int64_mod
define __moddi3
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 0x30;
	ecx = Mem0[ebp + 0x0C:word32];
	esi = Mem0[ebp + 16:word32];
	edi = Mem0[ebp + 20:word32];
	edx = Mem0[ebp + 8:word32];
	SZP = cond(ecx & ecx);
	O = false;
	C = false;
	Mem0[ebp + -32:word32] = esi;
	Mem0[ebp + -28:word32] = edi;
	Mem0[ebp + -44:word32] = 0x00;
	if (Test(SG,S))
	{
		C = edx != 0x00;
		edx = -edx;
		ecx = ecx + 0x00 + C;
		C = ecx != 0x00;
		ecx = -ecx;
		SZO = cond(ecx);
		Mem0[ebp + -44:word32] = ~0x00;
	}
	esi = Mem0[ebp + -28:word32];
	SZP = cond(esi & esi);
	O = false;
	C = false;
	if (Test(SG,S))
	{
		v26 = Mem0[ebp + -32:word32];
		C = v26 != 0x00;
		v27 = -v26;
		Mem0[ebp + -32:word32] = v27;
		v28 = Mem0[ebp + -28:word32] + 0x00 + C;
		Mem0[ebp + -28:word32] = v28;
		v29 = Mem0[ebp + -28:word32];
		C = v29 != 0x00;
		v30 = -v29;
		Mem0[ebp + -28:word32] = v30;
		SZO = cond(v30);
	}
	eax = Mem0[ebp + -28:word32];
	esi = ebp - 16;
	edi = Mem0[ebp + -32:word32];
	Mem0[ebp + -48:word32] = edx;
	Mem0[ebp + -40:word32] = edx;
	SZP = cond(eax & eax);
	O = false;
	C = false;
	Mem0[ebp + -36:word32] = edi;
	edi = ecx;
	if (Test(EQ,Z))
	{
		SCZO = cond(Mem0[ebp + -36:word32] - ecx);
		if (Test(UGT,CZ))
		{
			eax = edx;
			edx = ecx;
			v18 = edx_eax;
			edx = CONVERT(v18 %u Mem0[ebp + -36:word32], word64, uint32);
			eax = CONVERT(v18 /u Mem0[ebp + -36:word32], word32, uint32);
			SCZO = cond(eax);
		}
		else
		{
			edx = Mem0[ebp + -36:word32];
			SZP = cond(edx & edx);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				eax = 0x01;
				edx = edx ^ edx;
				v21 = edx_eax;
				edx = CONVERT(v21 %u Mem0[ebp + -36:word32], word64, uint32);
				eax = CONVERT(v21 /u Mem0[ebp + -36:word32], word32, uint32);
				SCZO = cond(eax);
				Mem0[ebp + -36:word32] = eax;
			}
			eax = edi;
			edx = edx ^ edx;
			v22 = edx_eax;
			edx = CONVERT(v22 %u Mem0[ebp + -36:word32], word64, uint32);
			eax = CONVERT(v22 /u Mem0[ebp + -36:word32], word32, uint32);
			eax = Mem0[ebp + -40:word32];
			v23 = edx_eax;
			edx = CONVERT(v23 %u Mem0[ebp + -36:word32], word64, uint32);
			eax = CONVERT(v23 /u Mem0[ebp + -36:word32], word32, uint32);
			SCZO = cond(eax);
		}
		eax = Mem0[ebp + -44:word32];
		Mem0[esi + 0x00:word32] = edx;
		Mem0[esi + 4:word32] = 0x00;
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
l08070D28:
			eax = Mem0[ebp + -16:word32];
			edx = Mem0[ebp + -0x0C:word32];
			esp += 0x30;
			SCZO = cond(esp);
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
l08070D48:
		eax = Mem0[ebp + -16:word32];
		edx = Mem0[ebp + -0x0C:word32];
		C = eax != 0x00;
		eax = -eax;
		edx = edx + 0x00 + C;
		edx = -edx;
		esp += 0x30;
		SCZO = cond(esp);
		esi = Mem0[esp + 0x00:word32];
		esp += 4;
		edi = Mem0[esp + 0x00:word32];
		esp += 4;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
		return;
	}
	SCZO = cond(eax - ecx);
	if (Test(UGT,CZ))
	{
		Mem0[esi + 0x00:word32] = edx;
		Mem0[esi + 4:word32] = ecx;
		goto l08070D41;
	}
	edx = __bsr<word32>(eax);
	edx = edx ^ 0x1F;
	SZ = cond(edx);
	O = false;
	C = false;
	Mem0[ebp + -32:word32] = edx;
	if (Test(EQ,Z))
	{
		ecx = Mem0[ebp + -40:word32];
		SCZO = cond(Mem0[ebp + -36:word32] - ecx);
		if (Test(UGT,CZ))
		{
			SCZO = cond(eax - edi);
			if (Test(UGE,C))
			{
l08070D7F:
				ecx = Mem0[ebp + -40:word32];
				Mem0[esi + 4:word32] = edi;
				Mem0[esi + 0x00:word32] = ecx;
				goto l08070D41;
			}
		}
		edx = Mem0[ebp + -40:word32];
		edx -= Mem0[ebp + -36:word32];
		SCZO = cond(edx);
		edi = edi - eax - C;
		SCZO = cond(edi);
		Mem0[ebp + -40:word32] = edx;
		goto l08070D7F;
	}
	ecx = CONVERT(Mem0[ebp + -32:byte], byte, word32);
	edx = eax;
	eax = 0x20;
	eax -= Mem0[ebp + -32:word32];
	edx <<= cl;
	Mem0[ebp + -40:word32] = eax;
	eax = Mem0[ebp + -36:word32];
	ecx = CONVERT(Mem0[ebp + -40:byte], byte, word32);
	eax >>= cl;
	ecx = CONVERT(Mem0[ebp + -32:byte], byte, word32);
	eax |= edx;
	edx = edi;
	Mem0[ebp + -56:word32] = eax;
	eax = Mem0[ebp + -36:word32];
	eax <<= cl;
	ecx = CONVERT(Mem0[ebp + -40:byte], byte, word32);
	Mem0[ebp + -52:word32] = eax;
	eax = Mem0[ebp + -48:word32];
	edx >>= cl;
	ecx = CONVERT(Mem0[ebp + -32:byte], byte, word32);
	edi <<= cl;
	ecx = CONVERT(Mem0[ebp + -40:byte], byte, word32);
	eax >>= cl;
	ecx = CONVERT(Mem0[ebp + -32:byte], byte, word32);
	eax |= edi;
	edi = Mem0[ebp + -48:word32];
	v25 = edx_eax;
	edx = CONVERT(v25 %u Mem0[ebp + -56:word32], word64, uint32);
	eax = CONVERT(v25 /u Mem0[ebp + -56:word32], word32, uint32);
	edi <<= cl;
	Mem0[ebp + -36:word32] = edi;
	edi = edx;
	edx_eax = Mem0[ebp + -52:word32] *u64 eax;
	SCZO = cond(edi - edx);
	if (Test(UGE,C))
	{
		SCZO = cond(Mem0[ebp + -36:word32] - eax);
		if (Test(UGE,C))
		{
l08070E43:
			ecx = Mem0[ebp + -36:word32];
			ecx -= eax;
			SCZO = cond(ecx);
			edi = edi - edx - C;
			edx = ecx;
			ecx = CONVERT(Mem0[ebp + -32:byte], byte, word32);
			eax = edi;
			edx >>= cl;
			ecx = CONVERT(Mem0[ebp + -40:byte], byte, word32);
			eax <<= cl;
			ecx = CONVERT(Mem0[ebp + -32:byte], byte, word32);
			eax |= edx;
			Mem0[esi + 0x00:word32] = eax;
			edi >>= cl;
			SCZO = cond(edi);
			Mem0[esi + 4:word32] = edi;
l08070D41:
			eax = Mem0[ebp + -44:word32];
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
				goto l08070D28;
			goto l08070D48;
		}
		SCZO = cond(edi - edx);
		if (Test(NE,Z))
			goto l08070E43;
	}
	eax -= Mem0[ebp + -52:word32];
	SCZO = cond(eax);
	edx = edx - Mem0[ebp + -56:word32] - C;
	SCZO = cond(edx);
	goto l08070E43;
}

// 08070E90: define __udivdi3
// Called from:
//      caml_int64_of_string
define __udivdi3
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 0x10;
	eax = Mem0[ebp + 20:word32];
	edx = Mem0[ebp + 8:word32];
	esi = Mem0[ebp + 16:word32];
	edi = Mem0[ebp + 0x0C:word32];
	SZP = cond(eax & eax);
	O = false;
	C = false;
	Mem0[ebp + -16:word32] = edx;
	if (Test(EQ,Z))
	{
		SCZO = cond(esi - edi);
		if (Test(UGT,CZ))
		{
			ecx = edx;
			edx = edi;
			eax = ecx;
			edi = edi ^ edi;
			v23 = edx_eax;
			eax = CONVERT(v23 /u esi, word32, uint32);
			ecx = eax;
			edx = edi;
			eax = ecx;
			esp += 0x10;
			SCZO = cond(esp);
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
		else
		{
			SZP = cond(esi & esi);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				eax = 0x01;
				edx = edx ^ edx;
				v17 = edx_eax;
				edx = CONVERT(v17 %u esi, word64, uint32);
				eax = CONVERT(v17 /u esi, word32, uint32);
				SCZO = cond(eax);
				esi = eax;
			}
			ecx = Mem0[ebp + -16:word32];
			edx = edx ^ edx;
			eax = edi;
			v21 = edx_eax;
			edx = CONVERT(v21 %u esi, word64, uint32);
			eax = CONVERT(v21 /u esi, word32, uint32);
			edi = eax;
			eax = ecx;
			v22 = edx_eax;
			eax = CONVERT(v22 /u esi, word32, uint32);
			ecx = eax;
			edx = edi;
			eax = ecx;
			esp += 0x10;
			SCZO = cond(esp);
			esi = Mem0[esp + 0x00:word32];
			esp += 4;
			edi = Mem0[esp + 0x00:word32];
			esp += 4;
			ebp = Mem0[esp + 0x00:word32];
			esp += 4;
			return;
		}
	}
	SCZO = cond(eax - edi);
	if (Test(UGT,CZ))
	{
l08070F00:
		edi = edi ^ edi;
		ecx = ecx ^ ecx;
		SZ = cond(ecx);
		O = false;
		C = false;
		goto l08070F04;
	}
	edx = __bsr<word32>(eax);
	edx = edx ^ 0x1F;
	SZ = cond(edx);
	O = false;
	C = false;
	Mem0[ebp + -0x0C:word32] = edx;
	if (Test(EQ,Z))
	{
		SCZO = cond(esi - Mem0[ebp + -16:word32]);
		if (Test(UGT,CZ))
		{
			SCZO = cond(eax - edi);
			if (Test(UGE,C))
				goto l08070F00;
		}
		edi = edi ^ edi;
		SZ = cond(edi);
		O = false;
		C = false;
		ecx = 0x01;
l08070F04:
		eax = ecx;
		edx = edi;
		esp += 0x10;
		SCZO = cond(esp);
		esi = Mem0[esp + 0x00:word32];
		esp += 4;
		edi = Mem0[esp + 0x00:word32];
		esp += 4;
		ebp = Mem0[esp + 0x00:word32];
		esp += 4;
		return;
	}
	ecx = CONVERT(Mem0[ebp + -0x0C:byte], byte, word32);
	edx = esi;
	eax <<= cl;
	Mem0[ebp + -20:word32] = eax;
	eax = 0x20;
	eax -= Mem0[ebp + -0x0C:word32];
	ecx = eax;
	edx >>= cl;
	ecx = CONVERT(Mem0[ebp + -0x0C:byte], byte, word32);
	edx |= Mem0[ebp + -20:word32];
	esi <<= cl;
	ecx = eax;
	Mem0[ebp + -24:word32] = esi;
	esi = edi;
	esi >>= cl;
	ecx = CONVERT(Mem0[ebp + -0x0C:byte], byte, word32);
	Mem0[ebp + -20:word32] = edx;
	edx = Mem0[ebp + -16:word32];
	edi <<= cl;
	ecx = eax;
	edx >>= cl;
	edi |= edx;
	edx = esi;
	eax = edi;
	v20 = edx_eax;
	edx = CONVERT(v20 %u Mem0[ebp + -20:word32], word64, uint32);
	eax = CONVERT(v20 /u Mem0[ebp + -20:word32], word32, uint32);
	esi = edx;
	edi = eax;
	edx_eax = Mem0[ebp + -24:word32] *u64 eax;
	SCZO = cond(esi - edx);
	Mem0[ebp + -20:word32] = edx;
	if (Test(UGE,C))
	{
		edx = Mem0[ebp + -16:word32];
		ecx = CONVERT(Mem0[ebp + -0x0C:byte], byte, word32);
		edx <<= cl;
		SCZO = cond(edx - eax);
		if (Test(UGE,C))
		{
l08070F8A:
			ecx = edi;
			edi = edi ^ edi;
			SZ = cond(edi);
			O = false;
			C = false;
			goto l08070F04;
		}
		SCZO = cond(esi - Mem0[ebp + -20:word32]);
		if (Test(NE,Z))
			goto l08070F8A;
	}
	ecx = edi - 1;
	edi = edi ^ edi;
	eax = ecx;
	edx = edi;
	esp += 0x10;
	SCZO = cond(esp);
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070FC0: define __libc_csu_fini
define __libc_csu_fini
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08070FD0: define __libc_csu_init
define __libc_csu_init
{
	esp = fp;
	Top = 0;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebp;
	ebp = esp;
	esp -= 4;
	Mem0[esp + 0x00:word32] = edi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = esi;
	esp -= 4;
	Mem0[esp + 0x00:word32] = ebx;
	ebx = 0x08070FDB<p32>;
	ebx += 9929;
	esp -= 0x1C;
	SCZO = cond(esp);
	_init();
	edi = ebx - 332;
	eax = ebx - 332;
	edi -= eax;
	edi >>= 0x02;
	SZP = cond(edi & edi);
	O = false;
	C = false;
	if (Test(NE,Z))
	{
		esi = esi ^ esi;
		SZ = cond(esi);
		O = false;
		C = false;
		do
		{
			eax = Mem0[ebp + 16:word32];
			Mem0[esp + 8:word32] = eax;
			eax = Mem0[ebp + 0x0C:word32];
			Mem0[esp + 4:word32] = eax;
			eax = Mem0[ebp + 8:word32];
			Mem0[esp + 0x00:word32] = eax;
			(ebx - 332)[esi * 0x04]();
			++esi;
			SCZO = cond(esi - edi);
		} while (Test(ULT,C));
	}
	esp += 0x1C;
	SCZO = cond(esp);
	ebx = Mem0[esp + 0x00:word32];
	esp += 4;
	esi = Mem0[esp + 0x00:word32];
	esp += 4;
	edi = Mem0[esp + 0x00:word32];
	esp += 4;
	ebp = Mem0[esp + 0x00:word32];
	esp += 4;
}

// 08071030: define __do_global_ctors_aux
// Called from:
//      _init
define __do_global_ctors_aux
{
	ptr32 fp;
	Top_3 = 0;
	eax_12 = Mem10[0x08073558<p32>:word32];
	if (eax_12 != ~0x00)
	{
		ebx_15 = 0x08073558;
		do
		{
			eax_19 = ϕ(eax_12, eax_26);
			ebx_16 = ϕ(ebx_15, ebx_17);
			ebx_17 = ebx_16 - 0x04;
			eax_19();
			eax_26 = Mem10[ebx_17 + 0x00:word32];
		} while (eax_26 != ~0x00);
	}
	eax_44 = ϕ(eax_12, eax_26);
	SCZO_31 = cond(fp - 0x08);
	C_43 = SLICE(SCZO_31, bool, 1);
	O_45 = SLICE(SCZO_31, bool, 4);
	S_46 = SLICE(SCZO_31, bool, 0);
	Z_48 = SLICE(SCZO_31, bool, 2);
}

