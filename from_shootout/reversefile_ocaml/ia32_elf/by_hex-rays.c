/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
int sub_8049DB4();
// double ldexp(double x, int exponent);
// int fputs(const char *s, FILE *stream);
// double fmod(double x, double y);
// int *__errno_location(void);
// int sigemptyset(sigset_t *set);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int sprintf(char *s, const char *format, ...);
// int tcflow(int fd, int action);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int setgroups(size_t n, const __gid_t *groups);
// __pid_t getpid(void);
// int mkdir(const char *path, __mode_t mode);
// char *strerror(int errnum);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int memcmp(const void *s1, const void *s2, size_t n);
// double log1p(double x);
// void freeaddrinfo(struct addrinfo *ai);
// double asin(double x);
// int shutdown(int fd, int how);
// int __cdecl open64(_DWORD, _DWORD, _DWORD); weak
// int sigismember(const sigset_t *set, int signo);
// int __gmon_start__(void); weak
// void *realloc(void *ptr, size_t size);
// double sinh(double x);
// int __isoc99_sscanf(_DWORD, const char *, ...); weak
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// struct tm *localtime(const time_t *timer);
// speed_t cfgetispeed(const struct termios *termios_p);
// struct group *getgrnam(const char *name);
// double strtod(const char *nptr, char **endptr);
// int socketpair(int domain, int type, int protocol, int fds[2]);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *getenv(const char *name);
// void *calloc(size_t nmemb, size_t size);
// int system(const char *command);
// int fchown(int fd, __uid_t owner, __gid_t group);
// ssize_t write(int fd, const void *buf, size_t n);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// double pow(double x, double y);
// int listen(int fd, int n);
// int dlclose(void *handle);
// int rename(const char *old, const char *new);
// char *getlogin(void);
// void *memset(void *s, int c, size_t n);
// int setitimer(__itimer_which_t which, const struct itimerval *new, struct itimerval *old);
// __pid_t setsid(void);
// struct protoent *getprotobyname(const char *name);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// __pid_t wait(void *stat_loc);
// double floor(double x);
// double modf(double x, double *iptr);
// int tcgetattr(int fd, struct termios *termios_p);
// int chmod(const char *file, __mode_t mode);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int tcdrain(int fd);
// int sigaltstack(const struct sigaltstack *ss, struct sigaltstack *oss);
// double exp(double x);
// int getrusage(__rusage_who_t who, struct rusage *usage);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// double expm1(double x);
// int strtol(const char *nptr, char **endptr, int base);
// struct servent *getservbyport(int port, const char *proto);
// void free(void *ptr);
// int inet_pton(int af, const char *cp, void *buf);
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// double atan(double x);
// int __cdecl __fpclassify(_DWORD, _DWORD); weak
// struct protoent *getprotobynumber(int proto);
// int access(const char *name, int type);
// void *dlsym(void *handle, const char *name);
// int __cdecl truncate64(_DWORD, _DWORD, _DWORD); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int fflush(FILE *stream);
// double sqrt(double x);
// DIR *opendir(const char *name);
// int gethostbyaddr_r(const void *addr, __socklen_t len, int type, struct hostent *result_buf, char *buf, size_t buflen, struct hostent **result, int *h_errnop);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int tcflush(int fd, int queue_selector);
// int symlink(const char *from, const char *to);
// int socket(int domain, int type, int protocol);
// int dup2(int fd, int fd2);
// const unsigned __int16 **__ctype_b_loc(void);
// int isatty(int fd);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// __mode_t umask(__mode_t mask);
// double tanh(double x);
// int setuid(__uid_t uid);
// int dup(int fd);
// time_t mktime(struct tm *tp);
// int __cdecl readdir64(_DWORD); weak
// double acos(double x);
// void *memcpy(void *dest, const void *src, size_t n);
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// int utime(const char *file, const struct utimbuf *file_times);
// int execv(const char *path, char *const argv[]);
// int execvp(const char *file, char *const argv[]);
// double cos(double x);
// unsigned int alarm(unsigned int seconds);
// int unlink(const char *name);
// struct passwd *getpwuid(__uid_t uid);
// int nice(int inc);
// __pid_t getppid(void);
// char *setlocale(int category, const char *locale);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int sigdelset(sigset_t *set, int signo);
// int *__h_errno_location(void);
// char *strcpy(char *dest, const char *src);
// int chroot(const char *path);
// __gid_t getegid(void);
// void *dlopen(const char *file, int mode);
// int mkfifo(const char *path, __mode_t mode);
// int chdir(const char *path);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __uid_t getuid(void);
// int putenv(char *string);
// int sigpending(sigset_t *set);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int closedir(DIR *dirp);
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// void rewinddir(DIR *dirp);
// double frexp(double x, int *exponent);
// int initgroups(const char *, __gid_t group);
// int fprintf(FILE *stream, const char *format, ...);
// time_t time(time_t *timer);
// double log10(double x);
// int execve(const char *path, char *const argv[], char *const envp[]);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// void *malloc(size_t size);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int chown(const char *file, __uid_t owner, __gid_t group);
// int gethostname(char *name, size_t len);
// double atan2(double y, double x);
// int fputc(int c, FILE *stream);
// int rmdir(const char *path);
// char *dlerror(void);
// struct group *getgrgid(__gid_t gid);
// unsigned int sleep(unsigned int seconds);
// int sigaddset(sigset_t *set, int signo);
// ssize_t readlink(const char *path, char *buf, size_t len);
// void *memmove(void *dest, const void *src, size_t n);
// speed_t cfgetospeed(const struct termios *termios_p);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// char *strcat(char *dest, const char *src);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// char *getcwd(char *buf, size_t size);
// double log(double x);
// int gethostbyname_r(const char *name, struct hostent *result_buf, char *buf, size_t buflen, struct hostent **result, int *h_errnop);
// __pid_t fork(void);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// int fcntl(int fd, int cmd, ...);
// int getrlimit64(void); weak
// struct tm *gmtime(const time_t *timer);
// int getgroups(int size, __gid_t list[]);
// int link(const char *from, const char *to);
// int pipe(int pipedes[2]);
// double tan(double x);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int setgid(__gid_t gid);
// double cosh(double x);
// int kill(__pid_t pid, int sig);
// double sin(double x);
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// int tcsendbreak(int fd, int duration);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// struct passwd *getpwnam(const char *name);
// __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int getitimer(__itimer_which_t which, struct itimerval *value);
// int strcmp(const char *s1, const char *s2);
// int __sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// struct servent *getservbyname(const char *name, const char *proto);
// void exit(int status);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
// int fchmod(int fd, __mode_t mode);
// int sigsuspend(const sigset_t *set);
// __gid_t getgid(void);
// double ceil(double x);
// __uid_t geteuid(void);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _do_global_dtors_aux();
int frame_dummy();
int caml_startup__code_begin();
_DWORD caml_curry7(); // weak
_DWORD caml_curry7_1(); // weak
_DWORD caml_curry7_2(); // weak
_DWORD caml_curry7_3(); // weak
_DWORD caml_curry7_4(); // weak
_DWORD caml_curry7_5(); // weak
// int __usercall caml_curry7_6@<eax>(int a1@<eax>, int a2@<ebx>);
_DWORD caml_curry6(); // weak
_DWORD caml_curry6_1(); // weak
_DWORD caml_curry6_2(); // weak
_DWORD caml_curry6_3(); // weak
_DWORD caml_curry6_4(); // weak
// int __usercall caml_curry6_5@<eax>(int a1@<ebx>);
_DWORD caml_curry5(); // weak
_DWORD caml_curry5_1(); // weak
_DWORD caml_curry5_2(); // weak
_DWORD caml_curry5_3(); // weak
// int __usercall caml_curry5_4@<eax>(int a1@<ebx>);
_DWORD caml_curry4(); // weak
_DWORD caml_curry4_1(); // weak
_DWORD caml_curry4_2(); // weak
// int __usercall caml_curry4_3@<eax>(int a1@<eax>, int a2@<ebx>);
_DWORD caml_curry3(); // weak
_DWORD caml_curry3_1(); // weak
// int __usercall caml_curry3_2@<eax>(int a1@<eax>, int a2@<ebx>);
_DWORD caml_curry2(); // weak
// int __usercall caml_curry2_1@<eax>(int a1@<ebx>);
// int __usercall caml_tuplify2@<eax>(int a1@<ebx>);
// int __usercall caml_tuplify3@<eax>(int a1@<eax>, int a2@<ebx>);
int __fastcall caml_apply3(int a1, int a2);
int __fastcall caml_apply2(int a1);
int camlStd_exit__code_begin();
// int **__usercall camlSource__code_begin@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlSource__output_buf_1037@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlSource__rev_write_1040@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int *a4@<ebx>, int a5@<esi>);
int camlSource__entry();
_DWORD camlUnix__code_begin(); // weak
_DWORD camlUnix__fun_2828(); // weak
// int __usercall camlUnix__get_port_1739@<eax>(int a1@<eax>, int a2@<ecx>);
_DWORD *sub_804B610();
// _DWORD *__usercall sub_804B6A0@<eax>(int a1@<edi>);
_DWORD camlUnix__fun_2833(); // weak
_DWORD camlUnix__fun_2836(); // weak
// int __usercall camlUnix__fun_2857@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2863@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2562@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2564@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2566@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2568@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2570@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2572@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2574@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2576@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2578@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2580@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2582@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2584@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2586@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2588@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2590@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2592@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2594@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2596@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2598@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2600@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2602@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2604@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2606@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2608@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2610@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2612@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2614@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2616@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2618@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2620@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2622@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2624@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2626@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2628@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2630@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2632@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2634@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2636@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2638@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2640@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2642@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2644@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2646@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2648@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2650@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2652@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2654@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2656@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2658@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2660@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2662@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2664@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2666@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2668@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2670@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2672@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2674@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2676@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2678@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2680@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2682@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2684@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2686@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2688@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2690@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2692@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2694@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2696@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2698@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2700@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2702@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2704@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2706@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2708@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2710@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2712@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2714@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2716@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2718@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2720@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2722@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2724@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2726@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2728@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2730@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2732@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2734@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2736@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2738@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2740@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2742@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2744@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2746@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2748@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2750@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2752@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2754@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2756@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2758@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2760@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2762@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2764@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2766@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2768@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2770@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2772@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2774@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2776@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2778@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2780@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2782@<eax>(char a1@<al>);
// int __usercall camlUnix__handle_unix_error_1171@<eax>(int (**a1)(void)@<eax>, int a2@<ecx>);
int __fastcall sub_804C0A0(int a1, int (**a2)(void));
// int __usercall camlUnix__read_1237@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlUnix__write_1242@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlUnix__single_write_1247@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlUnix__fun_2804@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2802@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2800@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2798@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2796@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2794@<eax>(char a1@<al>);
// int __usercall camlUnix__try_set_close_on_exec_1366@<eax>(char a1@<al>);
// int __usercall sub_804C260@<eax>(char a1@<al>);
int camlUnix__pause_1408();
// int __usercall camlUnix__is_inet6_addr_1500@<eax>(int a1@<eax>);
// int __usercall camlUnix__domain_of_sockaddr_1529@<eax>(_DWORD *a1@<eax>);
// int __usercall camlUnix__recv_1558@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlUnix__recvfrom_1564@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlUnix__send_1570@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlUnix__sendto_1576@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlUnix__fun_2816@<eax>(char a1@<al>);
// int __usercall camlUnix__fun_2814@<eax>(char a1@<al>);
int camlUnix__getsockopt_1643();
int camlUnix__setsockopt_1646();
int camlUnix__getsockopt_int_1650();
int camlUnix__setsockopt_int_1653();
int camlUnix__getsockopt_optint_1657();
int camlUnix__setsockopt_optint_1660();
int camlUnix__getsockopt_float_1664();
int camlUnix__setsockopt_float_1667();
int camlUnix__getsockopt_error_1671();
// void __usercall camlUnix__getaddrinfo_emulation_756(_DWORD *a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<ebx>, int a4, int a5, char a6);
void __cdecl sub_804C8C0(int a1, int a2, char a3);
// int __usercall sub_804C950@<eax>(char a1@<bl>);
// void __usercall camlUnix__getaddrinfo_1751(_DWORD *a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<ebx>, int a4, int a5, char a6);
// int __usercall sub_804CAA0@<eax>(char a1@<al>);
// void __usercall camlUnix__getnameinfo_emulation_1772(_DWORD *a1@<eax>, _DWORD *a2@<ebx>);
// _DWORD *__usercall sub_804CB90@<eax>(_DWORD *a1@<ebx>);
_DWORD *sub_804CC40();
// void __usercall camlUnix__getnameinfo_1781(_DWORD *a1@<eax>, _DWORD *a2@<ebx>);
// int __usercall sub_804CDA0@<eax>(char a1@<al>);
int camlUnix__system_1891();
int sub_804CE30();
// int __usercall camlUnix__safe_dup_1894@<eax>(char a1@<al>);
// int __usercall camlUnix__safe_close_1898@<eax>(char a1@<al>);
// int __usercall sub_804CF20@<eax>(char a1@<al>);
// int __usercall camlUnix__perform_redirections_1900@<eax>(char a1@<al>, char a2@<cl>, char a3@<bl>);
int camlUnix__create_process_1907();
int sub_804D070();
int camlUnix__create_process_env_1914();
int sub_804D120();
// int __usercall camlUnix__open_proc_1949@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3@<ebx>, int a4@<esi>);
int sub_804D250();
int camlUnix__open_process_in_1957();
int camlUnix__open_process_out_1962();
int *camlUnix__open_process_1967();
// int __usercall camlUnix__open_proc_full_1975@<eax>(char a1@<dl>, unsigned int a2@<ecx>, char a3@<dil>, char a4@<sil>);
int sub_804D640();
int *camlUnix__open_process_full_1985();
// int __usercall camlUnix__find_proc_id_1997@<eax>(int a1@<eax>, char a2@<bl>);
// int __usercall sub_804D8E0@<eax>(char a1@<bl>);
// int __usercall camlUnix__waitpid_non_intr_2001@<eax>(int a1@<eax>);
int sub_804D970();
// int __usercall camlUnix__close_process_in_2003@<eax>(int a1@<eax>);
// int __usercall camlUnix__close_process_out_2006@<eax>(int a1@<eax>);
// int __usercall camlUnix__close_process_2009@<eax>(int a1@<eax>, int a2@<ebx>);
int sub_804DAE0();
// int __usercall camlUnix__close_process_full_2013@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
int sub_804DBA0();
// int *__usercall camlUnix__open_connection_2018@<eax>(_DWORD *a1@<eax>);
// int *__usercall sub_804DC40@<eax>(char a1@<al>);
// int __usercall camlUnix__shutdown_connection_2022@<eax>(char a1@<al>);
// int __usercall camlUnix__accept_non_intr_2024@<eax>(int a1@<eax>);
// int __usercall sub_804DD30@<eax>(char a1@<al>);
// void __usercall __noreturn camlUnix__establish_server_2026(int a1@<eax>, _DWORD *a2@<ebx>);
int camlUnix__entry(void); // weak
int sub_804E43A();
_DWORD sub_804E482(); // weak
int camlUnixLabels__code_begin();
// int __usercall camlUnixLabels__code_end@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlPervasives__iter_1186@<eax>(_DWORD *a1@<eax>);
// void __usercall sub_804EE30(char a1@<al>, int a2);
// int __usercall camlPervasives__build_result_1243@<eax>(int result@<eax>, int *a2@<ecx>, int a3@<ebx>);
// int __usercall camlPervasives__scan_1249@<eax>(int *a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlPervasives__fun_1500@<eax>(int a1@<ebx>);
// int __usercall camlPervasives__fun_1392@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1394@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1396@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1398@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1400@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1402@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1404@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1406@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1408@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1410@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1412@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1414@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1416@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1418@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1420@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1422@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1424@<eax>(char a1@<al>);
int camlPervasives__failwith_1010(void); // weak
int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD); // weak
// int __usercall camlPervasives__min_1022@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlPervasives__max_1025@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlPervasives__abs_1044@<eax>(int result@<eax>);
// int __usercall camlPervasives__lnot_1049@<eax>(int a1@<eax>);
// int __usercall camlPervasives___5e_1112@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlPervasives__char_of_int_1120@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// char *__usercall camlPervasives__string_of_bool_1127@<eax>(int a1@<eax>);
// int __usercall camlPervasives__bool_of_string_1129@<eax>(_DWORD *a1@<eax>);
int camlPervasives__string_of_int_1130();
int camlPervasives__valid_float_lexem_1135(void); // weak
int camlPervasives__string_of_float_1140();
// _DWORD *__usercall camlPervasives___40_1143@<eax>(int *a1@<eax>, int a2@<ebx>);
int __fastcall camlPervasives__open_out_gen_1175(char a1);
// int __usercall camlPervasives__open_out_1179@<eax>(char a1@<al>);
// int __usercall camlPervasives__open_out_bin_1181@<eax>(char a1@<al>);
int camlPervasives__flush_all_1185();
// int __usercall camlPervasives__output_string_1191@<eax>(char a1@<al>);
// int __usercall camlPervasives__output_1194@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlPervasives__output_value_1202@<eax>(char a1@<al>);
// int __usercall camlPervasives__close_out_1209@<eax>(char a1@<al>);
// void __usercall camlPervasives__close_out_noerr_1211(char a1@<al>);
// int __usercall sub_804F6C0@<eax>(char a1@<al>);
int sub_804F700();
int __fastcall camlPervasives__open_in_gen_1214(char a1);
// int __usercall camlPervasives__open_in_1218@<eax>(char a1@<al>);
// int __usercall camlPervasives__open_in_bin_1220@<eax>(char a1@<al>);
// int __usercall camlPervasives__input_1224@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlPervasives__unsafe_really_input_1229@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall camlPervasives__really_input_1235@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
int camlPervasives__input_line_1241(void); // weak
// int __usercall camlPervasives__close_in_noerr_1263@<eax>(char a1@<al>);
// int __usercall sub_804F930@<eax>(char a1@<al>);
int camlPervasives__print_char_1266();
int camlPervasives__print_string_1268();
int camlPervasives__print_int_1270();
int camlPervasives__print_float_1272();
int camlPervasives__print_endline_1274();
int camlPervasives__print_newline_1276();
int camlPervasives__prerr_char_1277();
int camlPervasives__prerr_string_1279();
int camlPervasives__prerr_int_1281();
int camlPervasives__prerr_float_1283();
int camlPervasives__prerr_endline_1285();
int camlPervasives__prerr_newline_1287();
int camlPervasives__read_line_1288();
int camlPervasives__read_int_1289();
int camlPervasives__read_float_1290();
// int __usercall camlPervasives__fun_1495@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1493@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1491@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1489@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1487@<eax>(char a1@<al>);
// int __usercall camlPervasives__fun_1485@<eax>(char a1@<al>);
// int __usercall camlPervasives___5e_5e_1312@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlPervasives__string_of_format_1315@<eax>(int a1@<eax>);
_DWORD camlPervasives__at_exit_1322(); // weak
int camlPervasives__do_at_exit_1325();
// int __usercall camlPervasives__exit_1326@<eax>(char a1@<al>);
int camlPervasives__entry(void); // weak
// int __usercall camlArray__code_begin@<eax>(int a1@<eax>, double *a2@<edx>, unsigned int a3@<ecx>, double *a4@<ebx>, _DWORD *a5@<edi>, unsigned int a6@<esi>);
// int __usercall camlArray__size_1065@<eax>(int result@<eax>, _DWORD *a2@<ebx>);
// int __usercall camlArray__fill_1070@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>);
// int (__cdecl **__usercall camlArray__find_init_1077@<eax>(int *a1@<eax>))(int, int);
// _DWORD *__usercall camlArray__tolist_1123@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<ebx>);
// int __usercall camlArray__fill_1135@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// unsigned int __usercall camlArray__maxson_182@<eax>(signed int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlArray__trickledown_187@<eax>(signed int a1@<eax>, int a2@<edx>, double *a3@<ecx>, unsigned int a4@<ebx>);
// int __usercall camlArray__trickle_1165@<eax>(signed int a1@<eax>, int a2@<edx>, double *a3@<ecx>, unsigned int a4@<ebx>);
// int __usercall sub_8050D20@<eax>(signed int a1@<eax>, int a2@<edx>, double *a3@<ecx>, unsigned int a4@<ebx>);
// int __usercall camlArray__bubbledown_1170@<eax>(signed int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>);
// int __usercall camlArray__bubble_1174@<eax>(signed int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>);
// int __usercall sub_8050E80@<eax>(signed int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>);
// int __usercall camlArray__trickleup_205@<eax>(int a1@<eax>, int a2@<ecx>, double *a3@<ebx>);
// int __usercall camlArray__merge_1191@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<edi>, int a6@<esi>);
// int __usercall camlArray__isortto_236@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<esi>);
// int __usercall camlArray__sortto_1217@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<esi>);
// void *__usercall camlArray__init_1037@<eax>(int a1@<eax>, void (**a2)(void)@<ebx>);
// int __usercall camlArray__make_matrix_1042@<eax>(int a1@<eax>, char a2@<bl>);
// void *__usercall camlArray__copy_1049@<eax>(double *a1@<eax>);
// void *__usercall camlArray__append_82@<eax>(double *a1@<eax>, double *a2@<ebx>);
// int __usercall camlArray__concat_aux_1062@<eax>(int *a1@<ebx>);
// int (__cdecl **__usercall camlArray__concat_1075@<eax>(int *a1@<eax>))(int, int);
// void *__usercall camlArray__sub_1081@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlArray__fill_1087@<eax>(int a1@<eax>, double *a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlArray__blit_120@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, int a5@<esi>);
// int __usercall camlArray__iter_1101@<eax>(void (**a1)(void)@<eax>, int a2@<ebx>);
// void *__usercall camlArray__map_1105@<eax>(void (**a1)(void)@<eax>, double *a2@<ebx>);
// int __usercall camlArray__iteri_1111@<eax>(int a1@<eax>, int a2@<ebx>);
// void *__usercall camlArray__mapi_1115@<eax>(int a1@<eax>, double *a2@<ebx>);
_DWORD camlArray__to_list_1121(); // weak
// int __usercall camlArray__list_length_1126@<eax>(int result@<eax>, int a2@<ebx>);
// void *__usercall camlArray__of_list_1130@<eax>(int *a1@<eax>);
// unsigned int __usercall camlArray__fold_left_1139@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// unsigned int __usercall camlArray__fold_right_1145@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlArray__sort_179@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlArray__stable_sort_1188@<eax>(int a1@<eax>, double *a2@<ebx>);
int camlArray__entry(void); // weak
// int __usercall camlList__code_begin@<eax>(int *a1@<eax>, int a2@<ebx>);
// int *__usercall camlList__rmap_f_1070@<eax>(int *result@<eax>, int a2@<ecx>, int a3@<ebx>);
// int *__usercall camlList__rmap2_f_1103@<eax>(int *result@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlList__find_1207@<eax>(_DWORD *a1@<eax>, int a2@<ecx>, int *a3@<ebx>);
// int *__usercall camlList__part_1215@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int *a3@<ecx>, _DWORD *a4@<ebx>);
// int __usercall camlList__rev_merge_1251@<eax>(_DWORD *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int *a4@<ebx>);
// int __usercall camlList__rev_merge_rev_1261@<eax>(_DWORD *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int *a4@<ebx>);
// _DWORD *__usercall camlList__rev_sort_300@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>);
// _DWORD *__usercall camlList__sort_299@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>);
// int __usercall camlList__length_aux_1030@<eax>(int result@<eax>, int a2@<ebx>);
// int __usercall camlList__length_1034@<eax>(int a1@<eax>);
// int __usercall camlList__hd_1036@<eax>(int a1@<eax>);
// int __usercall camlList__tl_1039@<eax>(int a1@<eax>);
// int __usercall camlList__nth_1042@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
int camlList__rev_append_1051(void); // weak
int camlList__rev_1056();
// int __usercall camlList__flatten_1058@<eax>(int **a1@<eax>);
// int __usercall camlList__map_1062@<eax>(int (**a1)(void)@<eax>, int a2@<ebx>);
_DWORD camlList__rev_map_1067(); // weak
// int __usercall camlList__iter_1074@<eax>(void (**a1)(void)@<eax>, int a2@<ebx>);
// int __usercall camlList__fold_left_1078@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlList__fold_right_1084@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlList__map2_1090@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
_DWORD camlList__rev_map2_1099(); // weak
// int __usercall camlList__iter2_1111@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlList__fold_left2_1119@<eax>(int a1@<eax>, int *a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlList__fold_right2_1128@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlList__for_all_1137@<eax>(int (**a1)(void)@<eax>, int a2@<ebx>);
// int __usercall camlList__exists_1141@<eax>(int (**a1)(void)@<eax>, int a2@<ebx>);
// int __usercall camlList__for_all2_1145@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlList__exists2_1153@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlList__mem_1161@<eax>(int a1@<eax>, _DWORD *a2@<ebx>);
// int __usercall camlList__memq_1165@<eax>(int a1@<eax>, _DWORD *a2@<ebx>);
// int __usercall camlList__assoc_1169@<eax>(int a1@<eax>, _DWORD *a2@<ebx>);
_DWORD camlList__assq_1174(); // weak
// int __usercall camlList__mem_assoc_1179@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlList__mem_assq_1184@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlList__remove_assoc_1189@<eax>(char a1@<al>, _DWORD *a2@<ebx>);
// int __usercall camlList__remove_assq_1195@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlList__find_1201@<eax>(int (**a1)(void)@<eax>, int *a2@<ebx>);
_DWORD camlList__find_all_1205(); // weak
_DWORD camlList__partition_1212(); // weak
// _DWORD *__usercall camlList__split_1220@<eax>(int **a1@<eax>);
// int __usercall camlList__combine_1226@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int *a4@<ebx>);
// int *__usercall camlList__merge_1233@<eax>(int a1@<eax>, int *a2@<ecx>, int *a3@<ebx>);
int camlList__chop_1243(void); // weak
// _DWORD *__usercall camlList__stable_sort_1248@<eax>(int a1@<eax>, int *a2@<ebx>);
int camlList__entry();
void __noreturn camlSys__code_begin(); // weak
// int __usercall camlSys__set_signal_1057@<eax>(char a1@<al>);
_DWORD camlSys__catch_break_1082(); // weak
int camlSys__entry(void); // weak
// int __usercall camlHashtbl__code_begin@<eax>(int *a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__find_in_bucket_1213@<eax>(int a1@<eax>, int a2@<ebx>);
// _DWORD *__usercall camlHashtbl__replace_bucket_1221@<eax>(int *a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__mem_in_bucket_1230@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__insert_bucket_1068@<eax>(int *a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__remove_bucket_1083@<eax>(int *a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__find_in_bucket_1108@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall camlHashtbl__replace_bucket_1116@<eax>(int *a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__mem_in_bucket_1125@<eax>(_DWORD *a1@<eax>);
// int __usercall camlHashtbl__do_bucket_1132@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__do_bucket_1142@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlHashtbl__safehash_1177@<eax>(int a1@<ebx>);
// int __usercall camlHashtbl__add_1179@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall camlHashtbl__remove_1185@<eax>(int a1@<eax>, int a2@<ecx>, int (__usercall *a3)@<eax>(int *a1@<eax>, int a2@<ebx>)@<ebx>);
// int __usercall camlHashtbl__find_rec_1193@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlHashtbl__find_226@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int __usercall camlHashtbl__find_all_1210@<eax>(int a1@<eax>, int a2@<ecx>, int (__usercall *a3)@<eax>(int a1@<eax>, int a2@<ebx>)@<ebx>);
// int __usercall camlHashtbl__replace_1217@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall sub_8055F10@<eax>(int *a1@<eax>, unsigned int a2@<edx>, int a3@<ebx>);
// int __usercall camlHashtbl__mem_1227@<eax>(int a1@<eax>, int a2@<ecx>, int (__usercall *a3)@<eax>(int a1@<eax>, int a2@<ebx>)@<ebx>);
// int __usercall camlHashtbl__hash_1031@<eax>(unsigned int a1@<eax>);
_DWORD camlHashtbl__create_1051(); // weak
// int __usercall camlHashtbl__clear_1054@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall camlHashtbl__copy_1057@<eax>(int a1@<eax>);
// int __usercall camlHashtbl__length_1059@<eax>(int a1@<eax>);
// int __usercall camlHashtbl__resize_1061@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__add_1074@<eax>(_DWORD *a1@<eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>);
// int __usercall camlHashtbl__remove_1080@<eax>(int a1@<eax>, unsigned int a2@<ebx>);
// int __usercall camlHashtbl__find_rec_1088@<eax>(int a1@<eax>, int a2@<ebx>);
// int __usercall camlHashtbl__find_1093@<eax>(int a1@<eax>, char a2@<bl>);
int camlHashtbl__find_all_1105(void); // weak
// int __usercall camlHashtbl__replace_1112@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>);
// int __usercall sub_80568F0@<eax>(int *a1@<eax>, unsigned int a2@<edx>, int a3@<edi>);
_DWORD camlHashtbl__mem_1122(); // weak
// int __usercall camlHashtbl__iter_1129@<eax>(int a1@<eax>, int a2@<ebx>);
// int *__usercall camlHashtbl__fold_1138@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// int *__usercall camlHashtbl__Make_1251@<eax>(int (__usercall *a1)@<eax>(int a1@<ebx>)@<eax>);
int camlHashtbl__entry();
// int __usercall camlCallback__code_begin@<eax>(char a1@<al>);
// int __usercall camlCallback__register_exception_1034@<eax>(char a1@<al>, double *a2@<ebx>);
int camlCallback__entry();
_DWORD *__cdecl unix_accept(int a1);
int __cdecl unix_access(char *name, int); // idb
_DWORD *__cdecl unix_inet_addr_of_string(char *cp);
unsigned int __cdecl unix_alarm(int a1);
int __cdecl unix_bind(int a1, int *a2);
int __cdecl unix_chdir(char *path); // idb
int __cdecl unix_chmod(char *file, int); // idb
int __cdecl unix_chown(char *file, int, int); // idb
int __cdecl unix_chroot(char *path); // idb
int __cdecl unix_close(int a1);
int __cdecl unix_closedir(DIR **a1);
int __cdecl unix_connect(int a1, int *a2);
int __cdecl unix_dup(int a1);
int __cdecl unix_dup2(int a1, int a2);
char *unix_environment();
void *__cdecl unix_error_message(int a1);
int __cdecl unix_execv(char *path, int a2, int a3);
int __cdecl unix_execve(char *path, int, int); // idb
int __cdecl unix_execvpe(char *file, int, int); // idb
int __cdecl unix_execvp(char *file, int); // idb
int __cdecl unix_fchmod(int a1, int a2);
int __cdecl unix_fchown(int a1, int a2, int a3);
int __cdecl unix_clear_close_on_exec(int a1);
int __cdecl unix_set_close_on_exec(int a1);
int __cdecl unix_clear_nonblock(int a1);
int __cdecl unix_set_nonblock(int a1);
int unix_fork();
int __cdecl unix_ftruncate_64(int a1, int a2);
int __cdecl unix_ftruncate(int a1, int a2);
int __cdecl unix_getaddrinfo(char *src, char *, int); // idb
void *unix_getcwd();
__gid_t unix_getegid();
__uid_t unix_geteuid();
__gid_t unix_getgid();
// _DWORD *__usercall alloc_group_entry@<eax>(int a1@<eax>);
_DWORD *__cdecl unix_getgrgid(int a1);
_DWORD *__cdecl unix_getgrnam(char *name);
char *unix_getgroups();
// _DWORD *__usercall alloc_host_entry@<eax>(int a1@<eax>);
_DWORD *__cdecl unix_gethostbyname(char *src);
_DWORD *__cdecl alloc_one_addr(void *src);
_DWORD *__cdecl unix_gethostbyaddr(int *a1);
void *unix_gethostname();
void *unix_getlogin();
_DWORD *__cdecl unix_getnameinfo(int *a1, int *a2);
_DWORD *__cdecl unix_getpeername(int a1);
int unix_getpid();
int unix_getppid();
// _DWORD *__usercall alloc_proto_entry@<eax>(int a1@<eax>);
_DWORD *__cdecl unix_getprotobynumber(int a1);
_DWORD *__cdecl unix_getprotobyname(char *name);
// _DWORD *__usercall alloc_passwd_entry@<eax>(int a1@<eax>);
_DWORD *__cdecl unix_getpwuid(int a1);
_DWORD *__cdecl unix_getpwnam(char *name);
int unix_gettimeofday();
// _DWORD *__usercall alloc_service_entry@<eax>(int a1@<eax>);
_DWORD *__cdecl unix_getservbyport(int a1, char *proto);
_DWORD *__cdecl unix_getservbyname(char *name, char *proto);
_DWORD *__cdecl unix_getsockname(int a1);
__uid_t unix_getuid();
// _DWORD *__usercall alloc_tm@<eax>(_DWORD *a1@<eax>);
_DWORD *__cdecl unix_mktime(int *a1);
_DWORD *__cdecl unix_localtime(double *a1);
_DWORD *__cdecl unix_gmtime(double *a1);
int __cdecl unix_initgroups(char *, int); // idb
int __cdecl unix_isatty(int a1);
// double *__usercall unix_convert_itimer@<eax>(int *a1@<eax>);
double *__cdecl unix_getitimer(int a1);
// int __usercall unix_set_timeval@<eax>(int *a1@<eax>, double a2);
double *__cdecl unix_setitimer(int a1, double *a2);
int __cdecl unix_kill(int a1, int a2);
int __cdecl unix_link(char *from, char *to); // idb
int __cdecl unix_listen(int a1, int a2);
int __cdecl unix_lockf(int a1, int a2, int a3);
int *__cdecl unix_lseek_64(int a1, int a2, int a3);
int __cdecl unix_lseek(int a1, int a2, int a3);
int __cdecl unix_mkdir(char *path, int); // idb
int __cdecl unix_mkfifo(char *path, int); // idb
int __cdecl unix_nice(int a1);
int __cdecl unix_open(char *src, int, int); // idb
DIR **__cdecl unix_opendir(char *name);
_DWORD *unix_pipe();
int __cdecl unix_putenv(void *src, void *); // idb
int __cdecl unix_read(int a1, int a2, int a3, int a4);
void *__cdecl unix_readdir(int *a1);
void *__cdecl unix_readlink(char *path);
int __cdecl unix_rename(char *old, char *new); // idb
int __cdecl unix_rewinddir(DIR **a1);
int __cdecl unix_rmdir(char *path); // idb
// int __usercall fdlist_to_fdset@<eax>(int *a1@<eax>, void *a2@<edx>, int *a3);
// int __usercall fdset_to_fdlist@<eax>(int *a1@<eax>, int a2@<edx>);
int **__cdecl unix_select(int *a1, int *a2, int *a3, double *a4);
int __cdecl unix_sendto_native(int a1, int a2, int a3, int a4, int *a5, int *a6);
int __cdecl unix_sendto(int a1);
int __cdecl unix_send(int a1, int a2, int a3, int a4, int *a5);
_DWORD *__cdecl unix_recvfrom(int a1, int a2, int a3, int a4, int *a5);
int __cdecl unix_recv(int a1, int a2, int a3, int a4, int *a5);
int __cdecl unix_setgid(int a1);
int __cdecl unix_setgroups(int a1);
int unix_setsid();
int __cdecl unix_setuid(int a1);
int __cdecl unix_shutdown(int a1, int a2);
// int __usercall decode_sigset@<eax>(int *a1@<eax>, sigset_t *a2@<edx>);
int __cdecl unix_sigsuspend(int *a1);
// int __usercall encode_sigset@<eax>(const sigset_t *a1@<eax>);
int unix_sigpending();
int __cdecl unix_sigprocmask(int a1, int *a2);
int __cdecl unix_sleep(int a1);
int __cdecl unix_socket(int a1, int a2, int a3);
int *__cdecl get_sockaddr(int *a1, int a2, int *a3);
_DWORD *__cdecl alloc_inet6_addr(_DWORD *a1);
_DWORD *__cdecl alloc_inet_addr(_DWORD *a1);
_DWORD *__cdecl alloc_sockaddr(int a1, int a2, int fd);
_DWORD *__cdecl unix_socketpair(int a1, int a2, int a3);
int __cdecl unix_setsockopt_aux(int, int, int level, int optname, int, int); // idb
int __cdecl unix_setsockopt(int a1, int a2, int a3, int a4);
int __cdecl unix_getsockopt_aux(int, int, int level, int optname, int); // idb
int __cdecl unix_getsockopt(int a1, int a2, int a3);
// _DWORD *__usercall stat_aux@<eax>(int a1@<eax>, _DWORD *a2@<edx>);
_DWORD *__cdecl unix_fstat_64(int a1);
_DWORD *__cdecl unix_lstat_64(void *a1);
_DWORD *__cdecl unix_stat_64(void *a1);
_DWORD *__cdecl unix_fstat(int a1);
_DWORD *__cdecl unix_lstat(void *a1);
_DWORD *__cdecl unix_stat(void *a1);
void *__cdecl unix_string_of_inet_addr(void *cp);
int __cdecl unix_symlink(char *from, char *to); // idb
int __cdecl unix_tcflow(int a1, int a2);
int __cdecl unix_tcflush(int a1, int a2);
int __cdecl unix_tcdrain(int a1);
int __cdecl unix_tcsendbreak(int a1, int a2);
int __cdecl unix_tcsetattr(int a1, int a2, int *a3);
char *__cdecl unix_tcgetattr(int a1);
int unix_time();
double *unix_times();
int __cdecl unix_truncate_64(void *a1, int a2);
int __cdecl unix_truncate(void *a1, int a2);
__mode_t __cdecl unix_umask(int a1);
_DWORD *__cdecl unix_error_of_code(int a1);
int __cdecl unix_error(int a1, void *src, void *a3);
int __cdecl uerror(void *a1, void *a2);
int __cdecl unix_unlink(char *name); // idb
int __cdecl unix_utimes(char *file, int, int); // idb
// _DWORD *__usercall alloc_process_status@<eax>(int a1@<eax>, __int16 a2@<dx>);
_DWORD *__cdecl unix_waitpid(int *a1, int a2);
_DWORD *unix_wait();
int __cdecl unix_single_write(int a1, int a2, int a3, int a4);
int __cdecl unix_write(int a1, int a2, int a3, int a4);
int __cdecl cst_to_constr(int a1, _DWORD *a2, int a3, int a4);
_DWORD *__cdecl cstringvect(int a1);
// int __usercall scanmult@<eax>(int a1@<eax>, _DWORD *a2@<edx>);
int __cdecl caml_main(char **a1);
int __cdecl caml_startup(char **a1);
int __cdecl main(int argc, const char **argv, const char **envp);
int __cdecl caml_raise(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl caml_array_bound_error(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_stack_overflow(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_out_of_memory(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_with_args(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_with_arg(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_sys_error(int a1, void *a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_with_string(int a1, void *src, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_invalid_argument(void *a1, int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_failwith(void *a1, int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_constant(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_sys_blocked_io(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_not_found(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_zero_divide(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_raise_end_of_file(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl caml_do_local_roots(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5);
int caml_stack_usage();
// _DWORD *__usercall cons@<eax>(int a1@<eax>, int a2@<edx>);
_DWORD *__cdecl caml_register_dyn_global(int a1);
void __cdecl caml_register_frametable(int a1);
int caml_init_frame_descriptors();
int (__cdecl *__cdecl caml_do_roots(void (__cdecl *a1)(int, char *)))(_DWORD);
int (__cdecl *caml_darken_all_roots())(_DWORD);
int (__cdecl *caml_oldify_local_roots())(_DWORD);
// int __usercall caml_iterate_global_roots@<eax>(int result@<eax>, int a2@<edx>);
int __cdecl caml_scan_global_roots(int a1);
// _DWORD *__usercall caml_insert_global_root@<eax>(int a1@<eax>, unsigned int a2@<edx>);
unsigned int __cdecl caml_register_generational_global_root(unsigned int *a1);
_DWORD *__cdecl caml_register_global_root(unsigned int a1);
void __cdecl caml_scan_global_young_roots(int a1);
// int __usercall caml_delete_global_root@<eax>(int a1@<eax>, unsigned int a2@<edx>);
unsigned int __cdecl caml_modify_generational_global_root(unsigned int *a1, unsigned int a2);
unsigned int __cdecl caml_remove_generational_global_root(unsigned int *a1);
int __cdecl caml_remove_global_root(unsigned int a1);
int __cdecl caml_record_signal(int a1);
void caml_enter_blocking_section_default();
void caml_leave_blocking_section_default();
__int32 caml_try_leave_blocking_section_default();
int caml_urge_major_slice();
int __cdecl caml_convert_signal_number(int a1);
int __cdecl caml_rev_convert_signal_number(int a1);
int __cdecl caml_execute_signal(int signo, int); // idb
int caml_process_pending_signals();
int __cdecl caml_install_signal_handler(int a1, unsigned int *a2);
int caml_leave_blocking_section();
int caml_enter_blocking_section();
int caml_init_signals();
int __cdecl caml_set_signal_action(int sig, int); // idb
int __cdecl segv_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, unsigned int a23);
void __cdecl handle_signal(int signo);
int caml_garbage_collection();
void __cdecl caml_ext_table_free(int a1, int a2);
int __cdecl caml_ext_table_add(int *a1, int a2);
void *__cdecl caml_ext_table_init(_DWORD *a1, int a2);
int __cdecl caml_aligned_malloc(int a1, int a2, _DWORD *a3);
void __cdecl __noreturn caml_fatal_error_arg2(char *format, int, char *, int); // idb
void __cdecl __noreturn caml_fatal_error_arg(char *format, int); // idb
void __cdecl __noreturn caml_fatal_error(char *s); // idb
int __cdecl caml_gc_message(int, char *format, int); // idb
// int *__usercall allocate_block@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, int *a4);
void caml_fl_init_merge();
// int *__usercall truncate_flp@<eax>(int *result@<eax>);
void caml_fl_reset();
int *__cdecl caml_fl_merge_block(int *a1);
int *__cdecl caml_fl_add_blocks(unsigned int a1);
int *__cdecl caml_make_free_blocks(int **a1, unsigned int a2, int a3);
int __cdecl caml_set_allocation_policy(int a1);
int *__cdecl caml_fl_allocate(unsigned int a1);
// unsigned int __usercall clip_heap_chunk_size@<eax>(unsigned int a1@<eax>);
int __cdecl caml_init_major_heap(unsigned int a1);
unsigned int __cdecl caml_round_heap_chunk_size(unsigned int a1);
int (__cdecl *start_cycle())(_DWORD);
int realloc_gray_vals();
// void __usercall mark_slice(int a1@<eax>);
int __cdecl caml_darken(unsigned int a1);
// int __usercall sweep_slice@<eax>(int a1@<eax>);
int caml_finish_major_cycle();
int __cdecl caml_major_collection_slice(int a1);
// _DWORD *__usercall clear_table@<eax>(_DWORD *result@<eax>);
void __cdecl caml_oldify_one(unsigned int a1, _DWORD *a2);
void caml_oldify_mopup();
int caml_empty_minor_heap();
int caml_minor_collection();
int __cdecl caml_check_urgent_gc(int a1);
// void __usercall reset_table(int a1@<eax>);
void __cdecl caml_set_minor_heap_size(int a1);
char *__cdecl caml_alloc_table(int a1, int a2, int a3);
char *__cdecl caml_realloc_ref_table(int a1);
__int16 caml_page_table_initialize();
int __cdecl caml_allocation_color(unsigned int a1);
unsigned int __cdecl caml_alloc_dependent_memory(unsigned int a1);
unsigned int __cdecl caml_free_dependent_memory(unsigned int a1);
void *__cdecl caml_stat_resize(void *ptr, size_t size);
void __cdecl caml_stat_free(void *ptr);
void __cdecl caml_free_for_heap(int a1);
void *__cdecl caml_stat_alloc(size_t size);
int *__cdecl caml_modify(unsigned int *a1, unsigned int a2);
int *__cdecl caml_initialize(unsigned int *a1, unsigned int a2);
unsigned int __cdecl caml_adjust_gc_speed(unsigned int a1, unsigned int a2);
int __cdecl caml_alloc_for_heap(int a1);
// int __usercall caml_page_table_modify@<eax>(unsigned int a1@<eax>, char a2@<dl>, char a3@<cl>);
int __cdecl caml_page_table_remove(char a1, int a2, int a3);
void __cdecl caml_shrink_heap(_DWORD *a1);
int __cdecl caml_page_table_add(char a1, int a2, int a3);
int __cdecl caml_add_to_heap(unsigned int a1);
int *__cdecl caml_alloc_shr(unsigned int a1, int a2);
int __cdecl caml_convert_flag_list(int *a1, int a2);
int __cdecl caml_update_dummy(unsigned int *a1, int a2);
int *__cdecl caml_alloc_final(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl caml_alloc_small(int a1, int a2);
int __cdecl caml_alloc_string(int a1);
void *__cdecl caml_copy_string(void *src);
char *__cdecl caml_alloc(unsigned int a1, unsigned int a2);
char *__cdecl caml_alloc_dummy_float(int a1);
char *__cdecl caml_alloc_dummy(int a1);
char *__cdecl caml_alloc_array(int (__cdecl *a1)(_DWORD), _DWORD *a2);
char *__cdecl caml_copy_string_array(_DWORD *a1);
char *__cdecl caml_alloc_tuple(unsigned int a1);
void compare_free_stack();
int compare_stack_overflow();
// int __usercall compare_val@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
unsigned int __cdecl caml_greaterequal(int a1, int a2);
int __cdecl caml_greaterthan(int a1, int a2);
int __cdecl caml_lessequal(int a1, int a2);
int __cdecl caml_lessthan(int a1, int a2);
int __cdecl caml_notequal(int a1, int a2);
int __cdecl caml_equal(int a1, int a2);
int __cdecl caml_compare(int a1, int a2);
// _BYTE *__usercall parse_sign_and_base@<eax>(_BYTE *result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>);
// int __usercall parse_digit@<eax>(char a1@<al>);
int __cdecl caml_int_compare(int a1, int a2);
int __cdecl int32_cmp(int a1, int a2);
int __cdecl int32_hash(int a1);
int __cdecl caml_int32_to_int(int a1);
int __cdecl caml_int32_compare(int a1, int a2);
int __cdecl int64_cmp(int a1, int a2);
int __cdecl int64_hash(int a1);
int __cdecl caml_int64_to_int(int a1);
int __cdecl caml_int64_compare(int a1, int a2);
int __cdecl nativeint_cmp(int a1, int a2);
int __cdecl nativeint_hash(int a1);
int __cdecl caml_nativeint_to_int(int a1);
int __cdecl caml_nativeint_compare(int a1, int a2);
int __cdecl int32_deserialize(int *a1);
int __cdecl nativeint_deserialize(int *a1);
_DWORD *__cdecl nativeint_serialize(int a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl int32_serialize(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl int64_deserialize(__int64 *a1);
_DWORD *__cdecl int64_serialize(int a1, _DWORD *a2, _DWORD *a3);
// unsigned int __usercall parse_intnat@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>);
unsigned int __cdecl caml_int_of_string(_BYTE *a1);
// void *__usercall parse_format@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>, char *a3@<ecx>, void *a4, char *a5);
void *__cdecl caml_nativeint_format(_BYTE *a1, int a2);
void *__cdecl caml_int64_format(_BYTE *a1, int a2);
void *__cdecl caml_int32_format(_BYTE *a1, int a2);
void *__cdecl caml_format_int(_BYTE *a1, int a2);
int __cdecl caml_nativeint_to_float(int a1);
int __cdecl caml_int64_float_of_bits(int a1);
int __cdecl caml_int64_to_float(int a1);
int __cdecl caml_int32_float_of_bits(int a1);
int __cdecl caml_int32_to_float(int a1);
int *__cdecl caml_copy_nativeint(int a1);
int *__cdecl caml_nativeint_of_string(_BYTE *a1);
int *__cdecl caml_nativeint_of_int32(int a1);
int *__cdecl caml_nativeint_of_float(double *a1);
int *__cdecl caml_nativeint_of_int(int a1);
int *__cdecl caml_nativeint_shift_right_unsigned(int a1, int a2);
int *__cdecl caml_nativeint_shift_right(int a1, int a2);
int *__cdecl caml_nativeint_shift_left(int a1, int a2);
int *__cdecl caml_nativeint_xor(int a1, int a2);
int *__cdecl caml_nativeint_or(int a1, int a2);
int *__cdecl caml_nativeint_and(int a1, int a2);
int *__cdecl caml_nativeint_mod(int a1, int a2);
int *__cdecl caml_nativeint_div(int *a1, int a2);
int *__cdecl caml_nativeint_mul(int a1, int a2);
int *__cdecl caml_nativeint_sub(int a1, int a2);
int *__cdecl caml_nativeint_add(int a1, int a2);
int *__cdecl caml_nativeint_neg(int a1);
int *__cdecl caml_int64_to_nativeint(int a1);
int *__cdecl caml_copy_int64(int a1, int a2);
int *__cdecl caml_int64_bits_of_float(int *a1);
int *__cdecl caml_int64_of_string(_BYTE *a1);
int *__cdecl caml_int64_of_nativeint(int a1);
int *__cdecl caml_int64_of_int32(int a1);
int *__cdecl caml_int64_of_float(double *a1);
int *__cdecl caml_int64_of_int(int a1);
int *__cdecl caml_int64_shift_right_unsigned(int a1, int a2);
int *__cdecl caml_int64_shift_right(int a1, int a2);
int *__cdecl caml_int64_shift_left(int a1, int a2);
int *__cdecl caml_int64_xor(int a1, int a2);
int *__cdecl caml_int64_or(int a1, int a2);
int *__cdecl caml_int64_and(int a1, int a2);
int *__cdecl caml_int64_mod(int a1, int a2);
int *__cdecl caml_int64_div(int *a1, int a2);
int *__cdecl caml_int64_mul(int a1, int a2);
int *__cdecl caml_int64_sub(int a1, int a2);
int *__cdecl caml_int64_add(int a1, int a2);
int *__cdecl caml_int64_neg(int a1);
int *__cdecl caml_copy_int32(int a1);
int *__cdecl caml_nativeint_to_int32(int a1);
int *__cdecl caml_int64_to_int32(int a1);
int *__cdecl caml_int32_bits_of_float(double *a1);
int *__cdecl caml_int32_of_string(_BYTE *a1);
int *__cdecl caml_int32_of_float(double *a1);
int *__cdecl caml_int32_of_int(int a1);
int *__cdecl caml_int32_shift_right_unsigned(int a1, int a2);
int *__cdecl caml_int32_shift_right(int a1, int a2);
int *__cdecl caml_int32_shift_left(int a1, int a2);
int *__cdecl caml_int32_xor(int a1, int a2);
int *__cdecl caml_int32_or(int a1, int a2);
int *__cdecl caml_int32_and(int a1, int a2);
int *__cdecl caml_int32_mod(int a1, int a2);
int *__cdecl caml_int32_div(int *a1, int a2);
int *__cdecl caml_int32_mul(int a1, int a2);
int *__cdecl caml_int32_sub(int a1, int a2);
int *__cdecl caml_int32_add(int a1, int a2);
int *__cdecl caml_int32_neg(int a1);
int __cdecl caml_int_of_float(double *a1);
int __cdecl caml_eq_float(double *a1, double *a2);
int __cdecl caml_neq_float(double *a1, double *a2);
int __cdecl caml_le_float(double *a1, double *a2);
int __cdecl caml_lt_float(double *a1, double *a2);
int __cdecl caml_ge_float(double *a1, double *a2);
int __cdecl caml_gt_float(double *a1, double *a2);
int __cdecl caml_float_compare(double *a1, double *a2);
void caml_init_ieee_floats();
int __cdecl caml_classify_float(double *a1);
long double __cdecl caml_log1p(double a1);
long double __cdecl caml_expm1(double a1);
void *__cdecl caml_format_float(char *nptr, int a2);
int __cdecl caml_copy_double(double); // idb
int __cdecl caml_log1p_float(double *a1);
int __cdecl caml_expm1_float(double *a1);
int __cdecl caml_ceil_float(double *a1);
int __cdecl caml_atan2_float(double *a1, double *a2);
int __cdecl caml_atan_float(double *a1);
int __cdecl caml_acos_float(double *a1);
int __cdecl caml_asin_float(double *a1);
int __cdecl caml_tanh_float(double *a1);
int __cdecl caml_tan_float(double *a1);
int __cdecl caml_cosh_float(double *a1);
int __cdecl caml_cos_float(double *a1);
int __cdecl caml_sinh_float(double *a1);
int __cdecl caml_sin_float(double *a1);
int __cdecl caml_power_float(double *a1, double *a2);
int __cdecl caml_sqrt_float(double *a1);
char *__cdecl caml_modf_float(double *a1);
int __cdecl caml_log10_float(double *a1);
int __cdecl caml_log_float(double *a1);
int __cdecl caml_ldexp_float(double *a1, int a2);
char *__cdecl caml_frexp_float(double *a1);
int __cdecl caml_fmod_float(double *a1, double *a2);
int __cdecl caml_floor_float(double *a1);
int __cdecl caml_exp_float(double *a1);
int __cdecl caml_div_float(double *a1, double *a2);
int __cdecl caml_mul_float(double *a1, double *a2);
int __cdecl caml_sub_float(double *a1, double *a2);
int __cdecl caml_add_float(double *a1, double *a2);
int __cdecl caml_abs_float(double *a1);
int __cdecl caml_neg_float(double *a1);
int __cdecl caml_float_of_int(int a1);
int __cdecl caml_float_of_string(int a1, int a2, int a3);
int __cdecl caml_float_of_substring(int a1, int a2, int a3);
int __cdecl caml_string_length(int a1);
int __cdecl caml_ml_string_length(int a1);
int __cdecl caml_string_equal(_DWORD *a1, _DWORD *a2);
int __cdecl caml_string_notequal(_DWORD *a1, _DWORD *a2);
int __cdecl caml_bitvect_test(int a1, int a2);
int __cdecl caml_is_printable(int a1);
int __cdecl caml_fill_string(int a1, int a2, int a3, int a4);
int __cdecl caml_blit_string(int a1, int a2, int a3, int a4, int a5);
int __cdecl caml_string_compare(const void *a1, const void *a2);
int __cdecl caml_string_greaterequal(const void *a1, const void *a2);
int __cdecl caml_string_greaterthan(const void *a1, const void *a2);
int __cdecl caml_string_lessequal(const void *a1, const void *a2);
int __cdecl caml_string_lessthan(const void *a1, const void *a2);
// int __usercall caml_string_set@<eax>(_DWORD *a1@<ebx>, int a2, int a3, int a4);
// int __usercall caml_string_get@<eax>(_DWORD *a1@<ebx>, int a2, int a3);
int __cdecl caml_create_string(int a1);
int __cdecl caml_array_unsafe_set_float(int a1, int a2, double *a3);
int __cdecl caml_make_array(unsigned int *a1);
int __cdecl caml_array_unsafe_get_float(int a1, int a2);
int __cdecl caml_array_unsafe_get(int a1, int a2);
double *__cdecl caml_make_vect(int a1, unsigned int a2);
int __cdecl caml_array_unsafe_set_addr(int a1, int a2, unsigned int a3);
int __cdecl caml_array_unsafe_set(int a1, int a2, double *a3);
_DWORD __cdecl caml_array_set_float(_DWORD, _DWORD, _DWORD); // weak
int __cdecl caml_array_set_addr(int a1, int a2, unsigned int a3);
int __cdecl caml_array_set(int a1, int a2, unsigned int a3);
int __cdecl caml_array_get_float(int a1, int a2);
_DWORD __cdecl caml_array_get_addr(_DWORD, _DWORD); // weak
int __cdecl caml_array_get(int a1, int a2);
// int __usercall unlink_channel@<eax>(int result@<eax>);
int caml_channel_binary_mode();
__int64 __cdecl caml_pos_out(int a1);
__int64 __cdecl caml_pos_in(int a1);
int __cdecl compare_channel(int a1, int a2);
int caml_ml_set_binary_mode();
int *__cdecl caml_ml_pos_in_64(int a1);
int *__cdecl caml_ml_pos_out_64(int a1);
int __cdecl caml_ml_pos_in(int a1);
int __cdecl caml_ml_pos_out(int a1);
int __cdecl caml_channel_descriptor(int a1);
int __cdecl caml_ml_close_channel(int a1);
int *__cdecl caml_alloc_channel(int a1);
int caml_ml_out_channels_list();
void __cdecl caml_finalize_channel(int a1);
void __cdecl caml_close_channel(void *ptr);
int __cdecl caml_seek_in(int a1, __int64 a2);
int __cdecl caml_ml_seek_in_64(int a1, int a2);
int __cdecl caml_ml_seek_in(int a1, int a2);
int __cdecl caml_channel_size(int *a1);
int *__cdecl caml_ml_channel_size_64(int a1);
int __cdecl caml_ml_channel_size(int a1);
ssize_t __cdecl caml_do_read(int fd, void *buf, size_t nbytes);
int __cdecl caml_ml_input(int a1, int a2, int a3, int a4);
int __cdecl caml_input_scan_line(int a1);
int __cdecl caml_ml_input_scan_line(int a1);
int __cdecl caml_getblock(int, void *dest, size_t n); // idb
_BOOL4 __cdecl caml_really_getblock(int a1, void *dest, size_t n);
int __cdecl caml_refill(int a1);
int __cdecl caml_ml_input_char(int a1);
int __cdecl caml_getword(int a1);
int __cdecl caml_ml_input_int(int a1);
// ssize_t __usercall do_write@<eax>(size_t n@<ecx>, int a2@<eax>, const void *a3@<edx>);
size_t __cdecl caml_putblock(int a1, void *src, size_t n);
int __cdecl caml_ml_output(int a1, int a2, int a3, int a4);
int __cdecl caml_ml_output_partial(int a1, int a2, int a3, int a4);
void __cdecl caml_really_putblock(int a1, void *src, size_t n);
_BOOL4 __cdecl caml_flush_partial(int a1);
int __cdecl caml_ml_output_char(int a1, int a2);
int __cdecl caml_ml_flush_partial(int a1);
_BYTE *__cdecl caml_putword(int a1, int a2);
int __cdecl caml_ml_output_int(int a1, int a2);
_BOOL4 __cdecl caml_flush(int a1);
int __cdecl caml_ml_flush(int a1);
int __cdecl caml_seek_out(int a1, __int64 a2);
int __cdecl caml_ml_seek_out_64(int a1, int a2);
int __cdecl caml_ml_seek_out(int a1, int a2);
char *__cdecl caml_open_descriptor_in(int a1);
int *__cdecl caml_ml_open_descriptor_in(int a1);
char *__cdecl caml_open_descriptor_out(int a1);
int *__cdecl caml_ml_open_descriptor_out(int a1);
_DWORD *extern_replay_trail();
void free_extern_output();
int extern_out_of_memory();
// int __usercall grow_extern_output@<eax>(int a1@<eax>);
void *__cdecl caml_serialize_block_float_8(void *src, int a2);
void *__cdecl caml_serialize_float_8(int a1, int a2);
int __cdecl caml_serialize_block_8(char *a1, int a2);
int __cdecl caml_serialize_int_8(int a1, int a2);
int __cdecl caml_serialize_block_4(int a1, int a2);
int __cdecl caml_serialize_float_4(char a1);
int __cdecl caml_serialize_block_2(int a1, int a2);
void *__cdecl caml_serialize_block_1(void *src, size_t n);
void *__cdecl caml_serialize_int_4(int a1);
void *__cdecl caml_serialize_int_2(__int16 a1);
void *__cdecl caml_serialize_int_1(char a1);
// void *__usercall writecode16@<eax>(char a1@<al>, __int16 a2@<dx>);
// void *__usercall writecode8@<eax>(char a1@<al>, char a2@<dl>);
// void *__usercall writecode32@<eax>(char a1@<al>, int a2@<edx>);
// void *__usercall writeblock@<eax>(const void *a1@<eax>, size_t a2@<edx>);
// void *__usercall write32@<eax>(int a1@<eax>);
// int __usercall extern_record_location@<eax>(int result@<eax>);
_DWORD *init_extern_output();
// void *__usercall extern_invalid_argument@<eax>(void *a1@<eax>);
// void *__usercall extern_rec@<eax>(unsigned int a1@<eax>);
// char *__usercall extern_value@<eax>(unsigned int a1@<eax>, int *a2@<edx>);
char *__cdecl caml_output_value_to_block(unsigned int a1, int *a2, void *a3, int a4);
void __cdecl caml_output_value_to_malloc(unsigned int a1, int *a2, _DWORD *a3, char **a4);
int __cdecl caml_output_value_to_buffer(int a1, int a2, int a3, unsigned int a4, int *a5);
int __cdecl caml_output_value_to_string(unsigned int a1, int *a2);
void __cdecl caml_output_val(int a1, unsigned int a2, int *a3);
int __cdecl caml_output_value(int a1, unsigned int a2, int *a3);
int caml_deserialize_uint_1();
int caml_deserialize_sint_1();
int caml_deserialize_uint_2();
int caml_deserialize_sint_2();
int caml_deserialize_uint_4();
int caml_deserialize_sint_4();
void __cdecl caml_deserialize_block_2(int a1, int a2);
// int __usercall caml_deserialize_block_4@<eax>(int result@<eax>, int a2, int a3);
long double caml_deserialize_float_4();
void __cdecl caml_deserialize_block_8(_BYTE *a1, int a2);
__int64 caml_deserialize_sint_8();
__int64 caml_deserialize_uint_8();
int __cdecl caml_marshal_data_size(int a1, int a2);
void intern_cleanup();
void *__cdecl caml_deserialize_error(void *a1, int a2);
void *__cdecl caml_deserialize_block_float_8(void *dest, int a2);
long double caml_deserialize_float_8();
void *__cdecl caml_deserialize_block_1(void *dest, size_t n);
_DWORD *caml_code_checksum();
// int __usercall intern_alloc@<eax>(int result@<eax>, int a2@<edx>);
// char *__usercall intern_rec@<eax>(void ***a1@<eax>);
// int __usercall intern_add_to_heap@<eax>(int result@<eax>);
void **input_val_from_block();
void **__cdecl caml_input_value_from_block(unsigned __int8 *a1, unsigned int a2);
void **__cdecl caml_input_value_from_malloc(unsigned __int8 *a1, int a2);
void **__cdecl caml_input_val_from_string(int a1, int a2);
void **__cdecl caml_input_value_from_string(int a1, int a2);
void **__cdecl caml_input_val(int a1);
void **__cdecl caml_input_value(int a1);
int __cdecl caml_hash_variant(_BYTE *a1);
// int __usercall hash_aux@<eax>(unsigned int a1@<eax>);
int __cdecl caml_hash_univ_param(int a1, int a2, unsigned int a3);
int __cdecl caml_sys_init(void *a1, int a2);
_DWORD *caml_sys_get_config();
_DWORD *caml_sys_get_argv();
int caml_sys_random_seed();
int caml_sys_time();
void *__cdecl caml_sys_getenv(char *name);
int __cdecl caml_sys_file_exists(int a1);
int __cdecl caml_sys_close(int a1);
void __cdecl __noreturn caml_sys_exit(int a1);
char *__cdecl caml_sys_error(void *src);
char *__cdecl caml_sys_read_directory(void *src);
int __cdecl caml_sys_system_command(void *src); // idb
void *caml_sys_getcwd();
int __cdecl caml_sys_chdir(char *path); // idb
int __cdecl caml_sys_rename(char *old, char *new); // idb
int __cdecl caml_sys_remove(char *name); // idb
int __cdecl caml_sys_is_directory(void *src); // idb
int __cdecl caml_sys_open(char *src, int, int); // idb
char *__cdecl caml_sys_io_error(void *src);
int __cdecl caml_set_parser_trace(int a1);
// const char *__usercall token_name@<eax>(const char *a1@<eax>, int a2@<edx>);
int __cdecl caml_parse_engine(int a1, _DWORD *a2, int a3, signed int a4);
// int __usercall norm_pfree@<eax>(int result@<eax>);
void norm_pmax();
// unsigned int __usercall norm_heapincr@<eax>(int a1@<eax>);
// int __usercall norm_minsize@<eax>(int result@<eax>);
int __cdecl caml_init_gc(int a1, int a2, int a3, int a4);
int caml_gc_compaction();
int test_and_compact();
int caml_gc_full_major();
int caml_gc_major();
int __cdecl caml_gc_major_slice(int a1);
int caml_gc_minor();
int __cdecl caml_gc_set(int *a1);
unsigned int *caml_gc_get();
unsigned int *caml_gc_counters();
unsigned int *caml_gc_quick_stat();
unsigned int *caml_gc_stat();
_DWORD *__cdecl _Z8MD5_InitP12md5Context_t(_DWORD *a1);
_DWORD *__cdecl caml_MD5Transform(_DWORD *a1, _DWORD *a2);
int __cdecl caml_MD5Final(_DWORD *a1, _DWORD *a2);
void *__cdecl caml_MD5Update(int a1, void *src, size_t n);
_DWORD *__cdecl caml_md5_chan(int a1, int a2);
_DWORD *__cdecl caml_md5_string(int a1, int a2, int a3);
// int __usercall add_char@<eax>(int result@<eax>, char a2@<dl>);
// void *__usercall add_string@<eax>(int a1@<eax>, const char *a2@<edx>);
void *__cdecl caml_format_exception(int a1);
void __cdecl __noreturn caml_fatal_uncaught_exception(int a1);
// unsigned int __usercall hash_value_name@<eax>(char *a1@<eax>);
int __cdecl caml_named_value(char *s1); // idb
int __cdecl caml_register_named_value(char *s1, int); // idb
void __cdecl caml_callback3(int a1, int a2, int a3, int a4);
void __cdecl caml_callback2(int a1, int a2, int a3);
void __cdecl caml_callback(int a1, int a2);
void __cdecl caml_callbackN_exn(int a1, int a2, int a3);
void __cdecl caml_callbackN(int a1, int a2, int a3);
int __cdecl caml_weak_check(int a1, int a2);
// unsigned int __usercall do_set@<eax>(unsigned int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>);
// int __usercall caml_weak_blit@<eax>(int a1@<edi>, int a2, int a3, unsigned int a4, int a5, int a6);
// int __usercall caml_weak_set@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, int a3, int a4, unsigned int *a5);
int __cdecl caml_weak_get_copy(int a1, int a2);
int __cdecl caml_weak_get(int a1, int a2);
int *__cdecl caml_weak_create(int a1);
// unsigned int __usercall invert_pointer_at@<eax>(unsigned int result@<eax>);
unsigned int __cdecl invert_root(int a1, unsigned int a2);
void *init_compact_allocate();
// int __usercall compact_allocate@<eax>(unsigned int a1@<eax>);
int caml_compact_heap();
int caml_compact_heap_maybe();
void *__cdecl caml_final_do_strong_roots(void (__cdecl *a1)(_DWORD, char *));
int __cdecl caml_final_do_weak_roots(int (__cdecl *a1)(_DWORD, char *));
int __cdecl caml_final_do_young_roots(void (__cdecl *a1)(_DWORD, char *));
int caml_final_empty_young();
int caml_final_release();
// int __usercall caml_final_register@<eax>(unsigned int a1@<esi>, int a2, unsigned int a3);
void caml_final_do_calls();
void caml_final_update();
_DWORD *__cdecl caml_final_custom_operations(int a1);
_DWORD *__cdecl _ZN2Fl11add_handlerEPFiiE(Fl *this);
_DWORD *caml_init_custom_operations();
const char **__cdecl caml_find_custom_operations(char *s2);
int *__cdecl caml_alloc_custom(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl caml_executable_name(char *buf, size_t len); // idb
char *__cdecl caml_decompose_path(int a1, char *src);
int __cdecl caml_read_directory(char *name, int); // idb
char *caml_dlerror();
void *__cdecl caml_dlsym(void *handle, char *name);
void *__cdecl caml_globalsym(char *name);
int __cdecl caml_dlclose(void *handle); // idb
void *__cdecl caml_dlopen(char *file, int a2, int a3);
char *__cdecl caml_search_in_path(int a1, char *src);
char *__cdecl caml_search_dll_in_path(int a1, char *src);
char *__cdecl caml_search_exe_in_path(char *src);
int caml_backtrace_status();
// int __usercall extract_location_info@<eax>(int result@<eax>, _DWORD *a2@<edx>);
char **caml_get_exception_backtrace();
void caml_print_exception_backtrace();
int __cdecl caml_stash_backtrace(int a1, unsigned int a2, unsigned int a3, unsigned int a4);
int __cdecl caml_record_backtrace(int a1);
void caml_debugger_init();
void caml_debugger();
void caml_debugger_cleanup_fork();
char *__cdecl caml_call_gc(char a1);
void __fastcall __spoils<ecx> sub_806ABDD(int a1);
unsigned int __cdecl caml_alloc1(char a1);
unsigned int __cdecl caml_alloc3(char a1);
// unsigned int __usercall caml_allocN@<eax>(unsigned int a1@<eax>, int a2@<ecx>, char a3);
// int __usercall caml_c_call@<eax>(int (*a1)(void)@<eax>, char a2);
int caml_start_program();
void sub_806AD3E();
// int __usercall caml_raise_exn@<eax>(int result@<eax>);
int caml_raise_exception();
void caml_callback_exn();
void caml_callback2_exn();
void caml_callback3_exn();
_DWORD __cdecl caml_ml_array_bound_error();
// _DWORD __cdecl _divdi3(_DWORD, _DWORD, _DWORD, _DWORD); weak
void _libc_csu_fini(void); // idb
void _libc_csu_init(void); // idb
void (*_do_global_ctors_aux())(void);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_806B3F4; // weak
_UNKNOWN unk_806B3FB; // weak
int itimers[3] = { 0, 1, 2 }; // idb
int seek_command_table[3] = { 0, 1, 2 }; // idb
_UNKNOWN unk_806B538; // weak
int shutdown_command_table[3] = { 0, 1, 2 }; // idb
int sigprocmask_cmd[3] = { 2, 0, 1 }; // idb
int action_flag_table[4] = { 0, 1, 2, 3 }; // idb
int queue_flag_table[3] = { 0, 1, 2 }; // idb
int when_flag_table[9] = { 0, 1, 2, 0, 0, 0, 0, 0, 0 }; // idb
int speedtable[] = { 1 }; // weak
int dword_806B744[35] =
{
  50,
  2,
  75,
  3,
  110,
  4,
  134,
  5,
  150,
  7,
  300,
  8,
  600,
  9,
  1200,
  10,
  1800,
  11,
  2400,
  12,
  4800,
  13,
  9600,
  14,
  19200,
  15,
  38400,
  4097,
  57600,
  4098,
  115200,
  4099,
  230400,
  0,
  0
}; // idb
int posix_signals[20] = { 6, 14, 8, 1, 4, 2, 9, 13, 3, 11, 15, 10, 12, 17, 18, 19, 20, 21, 22, 26 }; // idb
int dword_806B9D0[] = { 27 }; // weak
int CSWTCH_118[4] = { 9, 7, 5, 3 }; // idb
void *off_806C1A4 = &loc_80655F5; // weak
_UNKNOWN unk_806C6B4; // weak
char byte_806C6B5 = '.'; // weak
int _CTOR_LIST__ = -1; // weak
int _DTOR_LIST__[] = { -1 }; // weak
int _DTOR_END__ = 0; // weak
int _JCR_LIST__ = 0; // weak
void *sockopt_table = &sockopt_bool; // weak
char *setsockopt_fun_name[10] =
{
  "setsockopt",
  "setsockopt_int",
  "setsockopt_optint",
  "setsockopt_float",
  "setsockopt_error",
  "getsockopt",
  "getsockopt_int",
  "getsockopt_optint",
  "getsockopt_float",
  "getsockopt_error"
}; // weak
char *getsockopt_fun_name[5] =
{
  "getsockopt",
  "getsockopt_int",
  "getsockopt_optint",
  "getsockopt_float",
  "getsockopt_error"
}; // weak
Elf32_Dyn *GLOBAL_OFFSET_TABLE_ = &DYNAMIC; // weak
int (*dword_806D9AC)(void) = NULL; // weak
char **caml_bucket_Out_of_memory = &caml_exn_Out_of_memory; // weak
char *caml_exn_Sys_error = "Sys_error"; // weak
char *caml_exn_Failure = "Failure"; // weak
char *caml_exn_Invalid_argument = "Invalid_argument"; // weak
char *caml_exn_End_of_file = "End_of_file"; // weak
char *caml_exn_Division_by_zero = "Division_by_zero"; // weak
char **caml_bucket_Division_by_zero = &caml_exn_Division_by_zero; // weak
char *caml_exn_Not_found = "Not_found"; // weak
char **caml_bucket_Stack_overflow = &caml_exn_Stack_overflow; // weak
char *caml_exn_Sys_blocked_io = "Sys_blocked_io"; // weak
char *caml_exn_Assert_failure = "Assert_failure"; // weak
int *caml_globals[9] =
{
  &camlPervasives,
  &camlArray,
  &camlList,
  &camlSys,
  &camlHashtbl,
  &camlCallback,
  &camlUnix,
  &camlUnixLabels,
  &camlSource
}; // weak
void *caml_data_segments = &caml_startup__data_begin; // weak
void *off_806E05C = &caml_startup__data_end; // weak
int (*caml_code_segments)() = &caml_startup__code_begin; // weak
char (*off_806E0B8)[11] = &caml_startup__code_end; // weak
int (*off_806E0BC)() = &camlUnixLabels__code_end; // weak
void *caml_frametable = &caml_startup__frametable; // weak
int camlSource = 0; // weak
int dword_806E2EC = 0; // weak
int dword_806E2F0 = 0; // weak
int dword_806E2F4 = 0; // weak
int dword_806E2F8 = 0; // weak
int dword_806E2FC = 0; // weak
int dword_806E300 = 0; // weak
int (*camlSource__1)() = &caml_curry5; // weak
int (*camlSource__2)() = &caml_tuplify2; // weak
int (*camlSource__3)() = &caml_curry4; // weak
int camlUnix = 0; // weak
int dword_806E588 = 0; // weak
int dword_806E58C = 0; // weak
int dword_806E590 = 0; // weak
int dword_806E640 = 0; // weak
int dword_806E660 = 0; // weak
int (*camlUnix__184)() = &camlUnix__fun_2863; // weak
int (*camlUnix__188)() = &camlUnix__fun_2857; // weak
_UNKNOWN camlUnix__44; // weak
char camlUnix__176[19] = "close_process_full"; // weak
char camlUnix__177[14] = "close_process"; // weak
char camlUnix__178[18] = "close_process_out"; // weak
char camlUnix__179[17] = "close_process_in"; // weak
_UNKNOWN camlUnix__180; // weak
char camlUnix__181[8] = "/bin/sh"; // weak
char camlUnix__182[8] = "/bin/sh"; // weak
_UNKNOWN camlUnix__183; // weak
char camlUnix__185[8] = "/bin/sh"; // weak
char camlUnix__186[8] = "/bin/sh"; // weak
_UNKNOWN camlUnix__187; // weak
char camlUnix__189[8] = "/bin/sh"; // weak
char camlUnix__190[8] = "/bin/sh"; // weak
_UNKNOWN camlUnix__191; // weak
char camlUnix__195[10] = "127.0.0.1"; // weak
char camlUnix__196[8] = "0.0.0.0"; // weak
_DWORD camlUnix__197[2] = { 50331648, 1276 }; // idb
_DWORD camlUnix__202[2] = { 50331648, 3324 }; // idb
_DWORD camlUnix__215[129] =
{
  50331648,
  134586688,
  134590880,
  134590965,
  134591050,
  134591119,
  134591197,
  134591761,
  134579104,
  134576592,
  134580567,
  134580635,
  134579802,
  134579853,
  134578815,
  134578531,
  134578968,
  134588875,
  134589400,
  134585360,
  134585673,
  134585865,
  134586231,
  134579432,
  134580692,
  134586796,
  134582220,
  134574848,
  134574244,
  134573724,
  134588468,
  134587528,
  134590648,
  134574068,
  134578032,
  134580172,
  134578083,
  134580223,
  134579032,
  134581464,
  134586548,
  134578132,
  134586476,
  134577720,
  134577792,
  134586724,
  134577756,
  134580812,
  134581913,
  134581677,
  134593124,
  134592256,
  134587476,
  134574200,
  134580989,
  134581262,
  134581363,
  134580272,
  134592204,
  134586973,
  134587252,
  134587334,
  134582052,
  134582300,
  134584884,
  134583152,
  134584248,
  134590788,
  134583656,
  134574756,
  134584440,
  134584156,
  134583560,
  134574612,
  134577628,
  134574364,
  134584516,
  134583068,
  134575788,
  134575910,
  134576032,
  134576154,
  134575044,
  134574976,
  134573968,
  134592600,
  134575700,
  134574520,
  134575620,
  134574436,
  134589907,
  134589999,
  134590094,
  134576404,
  134592420,
  134582744,
  134582140,
  134584360,
  134593052,
  134581540,
  134590189,
  134590347,
  134590497,
  134576490,
  134592509,
  134582886,
  134622531,
  134622531,
  134627182,
  134627127,
  134593736,
  134593965,
  134583940,
  134574684,
  134583332,
  134583236,
  134579588,
  134579552,
  134593519,
  134593641,
  134576288,
  134575416,
  134575538,
  134575308,
  134575228,
  134583760,
  134636541,
  134575124,
  134575164
}; // idb
int camlUnixLabels = 0; // weak
int dword_807094C = 0; // weak
int dword_8070950 = 0; // weak
int dword_8070954 = 0; // weak
int dword_8070958 = 0; // weak
int dword_807095C = 0; // weak
int dword_8070960 = 0; // weak
int dword_8070964 = 0; // weak
int dword_8070968 = 0; // weak
int dword_807096C = 0; // weak
int dword_8070970 = 0; // weak
int dword_8070974 = 0; // weak
int dword_8070978 = 0; // weak
int dword_807097C = 0; // weak
int dword_8070980 = 0; // weak
int dword_8070984 = 0; // weak
int dword_8070988 = 0; // weak
int dword_807098C = 0; // weak
int dword_8070990 = 0; // weak
int dword_8070994 = 0; // weak
int dword_8070998 = 0; // weak
int dword_807099C = 0; // weak
int dword_80709A0 = 0; // weak
int dword_80709A4 = 0; // weak
int dword_80709A8 = 0; // weak
int dword_80709AC = 0; // weak
int dword_80709B0 = 0; // weak
int dword_80709B4 = 0; // weak
int dword_80709B8 = 0; // weak
int dword_80709BC = 0; // weak
int dword_80709C0 = 0; // weak
int dword_80709C4 = 0; // weak
int dword_80709C8 = 0; // weak
int dword_80709CC = 0; // weak
int dword_80709D0 = 0; // weak
int dword_80709D4 = 0; // weak
int dword_80709D8 = 0; // weak
int dword_80709DC = 0; // weak
int dword_80709E0 = 0; // weak
int dword_80709E4 = 0; // weak
int dword_80709E8 = 0; // weak
int dword_80709EC = 0; // weak
int dword_80709F0 = 0; // weak
int dword_80709F4 = 0; // weak
int dword_80709F8 = 0; // weak
int dword_80709FC = 0; // weak
int dword_8070A00 = 0; // weak
int dword_8070A04 = 0; // weak
int dword_8070A08 = 0; // weak
int dword_8070A0C = 0; // weak
int dword_8070A10 = 0; // weak
int dword_8070A14 = 0; // weak
int dword_8070A18 = 0; // weak
int dword_8070A1C = 0; // weak
int dword_8070A20 = 0; // weak
int dword_8070A24 = 0; // weak
int dword_8070A28 = 0; // weak
int dword_8070A2C = 0; // weak
int dword_8070A30 = 0; // weak
int dword_8070A34 = 0; // weak
int dword_8070A38 = 0; // weak
int dword_8070A3C = 0; // weak
int dword_8070A40 = 0; // weak
int dword_8070A44 = 0; // weak
int dword_8070A48 = 0; // weak
int dword_8070A4C = 0; // weak
int dword_8070A50 = 0; // weak
int dword_8070A54 = 0; // weak
int dword_8070A58 = 0; // weak
int dword_8070A5C = 0; // weak
int dword_8070A60 = 0; // weak
int dword_8070A64 = 0; // weak
int dword_8070A68 = 0; // weak
int dword_8070A6C = 0; // weak
int dword_8070A70 = 0; // weak
int dword_8070A74 = 0; // weak
int dword_8070A78 = 0; // weak
int dword_8070A7C = 0; // weak
int dword_8070A80 = 0; // weak
int dword_8070A84 = 0; // weak
int dword_8070A88 = 0; // weak
int dword_8070A8C = 0; // weak
int dword_8070A90 = 0; // weak
int dword_8070A94 = 0; // weak
int dword_8070A98 = 0; // weak
int dword_8070A9C = 0; // weak
int dword_8070AA0 = 0; // weak
int dword_8070AA4 = 0; // weak
int dword_8070AA8 = 0; // weak
int dword_8070AAC = 0; // weak
int dword_8070AB0 = 0; // weak
int dword_8070AB4 = 0; // weak
int dword_8070AB8 = 0; // weak
int dword_8070ABC = 0; // weak
int dword_8070AC0 = 0; // weak
int dword_8070AC4 = 0; // weak
int dword_8070AC8 = 0; // weak
int dword_8070ACC = 0; // weak
int dword_8070AD0 = 0; // weak
int dword_8070AD4 = 0; // weak
int dword_8070AD8 = 0; // weak
int dword_8070ADC = 0; // weak
int dword_8070AE0 = 0; // weak
int dword_8070AE4 = 0; // weak
int dword_8070AE8 = 0; // weak
int dword_8070AEC = 0; // weak
int dword_8070AF0 = 0; // weak
int dword_8070AF4 = 0; // weak
int dword_8070AF8 = 0; // weak
int dword_8070AFC = 0; // weak
int dword_8070B00 = 0; // weak
int dword_8070B04 = 0; // weak
int dword_8070B08 = 0; // weak
int dword_8070B0C = 0; // weak
int dword_8070B10 = 0; // weak
int dword_8070B14 = 0; // weak
int dword_8070B18 = 0; // weak
int dword_8070B1C = 0; // weak
int dword_8070B20 = 0; // weak
int dword_8070B24 = 0; // weak
int dword_8070B28 = 0; // weak
int dword_8070B2C = 0; // weak
int dword_8070B30 = 0; // weak
int dword_8070B34 = 0; // weak
int dword_8070B38 = 0; // weak
int dword_8070B3C = 0; // weak
int dword_8070B40 = 0; // weak
int dword_8070B44 = 0; // weak
int dword_8070B48 = 0; // weak
int dword_8070B4C = 0; // weak
int dword_8070B50 = 0; // weak
int dword_8070B54 = 0; // weak
int dword_8070B58 = 0; // weak
int dword_8070B5C = 0; // weak
int dword_8070B60 = 0; // weak
int dword_8070B64 = 0; // weak
int dword_8070B68 = 0; // weak
int dword_8070B6C = 0; // weak
int dword_8070B70 = 0; // weak
int dword_8070B74 = 0; // weak
int dword_8070B78 = 0; // weak
int dword_8070B7C = 0; // weak
int dword_8070B80 = 0; // weak
int dword_8070B84 = 0; // weak
int dword_8070B88 = 0; // weak
int dword_8070B8C = 0; // weak
int dword_8070B90 = 0; // weak
int dword_8070B94 = 0; // weak
int dword_8070B98 = 0; // weak
int dword_8070B9C = 0; // weak
int dword_8070BA0 = 0; // weak
int dword_8070BA4 = 0; // weak
int dword_8070BA8 = 0; // weak
int dword_8070BAC = 0; // weak
int dword_8070BB0 = 0; // weak
int dword_8070C14 = 0; // weak
int dword_8070C18 = 0; // weak
int dword_8070C1C = 0; // weak
int dword_8070C20 = 0; // weak
int dword_8070D08 = 0; // weak
_UNKNOWN camlPervasives__85; // weak
char camlPervasives__95[6] = "%.12g"; // weak
_UNKNOWN camlPervasives__96; // weak
char camlPervasives__98[5] = "true"; // weak
char camlPervasives__99[6] = "false"; // weak
char camlPervasives__100[6] = "false"; // weak
char camlPervasives__101[5] = "true"; // weak
_UNKNOWN camlPervasives__103; // weak
int dword_8071A60 = 0; // weak
_UNKNOWN camlArray__22; // weak
_UNKNOWN camlArray__23; // weak
_UNKNOWN camlArray__24; // weak
_UNKNOWN camlArray__28; // weak
_UNKNOWN camlArray__31; // weak
_UNKNOWN camlArray__32; // weak
_UNKNOWN camlArray__34; // weak
char *camlArray__35 = "array.ml"; // weak
int (__cdecl *camlArray__36[2])(int, int) = { &caml_make_vect, &caml_make_vect }; // weak
int camlList = 0; // weak
int dword_80728C4 = 0; // weak
int dword_80728C8 = 0; // weak
int dword_80728CC = 0; // weak
int dword_80728D0 = 0; // weak
int dword_80728D4 = 0; // weak
int dword_80728D8 = 0; // weak
int dword_80728DC = 0; // weak
int dword_80728E0 = 0; // weak
int dword_80728E4 = 0; // weak
int dword_80728E8 = 0; // weak
int dword_80728EC = 0; // weak
int dword_80728F0 = 0; // weak
int dword_80728F4 = 0; // weak
int dword_80728F8 = 0; // weak
int dword_80728FC = 0; // weak
int dword_8072900 = 0; // weak
int dword_8072904 = 0; // weak
int dword_8072908 = 0; // weak
int dword_807290C = 0; // weak
int dword_8072910 = 0; // weak
int dword_8072914 = 0; // weak
int dword_8072918 = 0; // weak
int dword_807291C = 0; // weak
int dword_8072920 = 0; // weak
int dword_8072924 = 0; // weak
int dword_8072928 = 0; // weak
int dword_807292C = 0; // weak
int dword_8072930 = 0; // weak
int dword_8072934 = 0; // weak
int dword_8072938 = 0; // weak
int dword_807293C = 0; // weak
int dword_8072940 = 0; // weak
int dword_8072944 = 0; // weak
int dword_8072948 = 0; // weak
int dword_807294C = 0; // weak
int dword_8072950 = 0; // weak
int dword_8072954 = 0; // weak
int dword_8072958 = 0; // weak
int dword_807295C = 0; // weak
int dword_8072960 = 0; // weak
int dword_8072964 = 0; // weak
int dword_8072968 = 0; // weak
int (*camlList__1)() = &caml_curry2; // weak
int (*camlList__2)() = &caml_curry2; // weak
int (*camlList__3)() = &caml_curry3; // weak
int (*camlList__4)() = &caml_curry2; // weak
int (*camlList__5)() = &camlList__split_1220; // weak
int (*camlList__6)() = &caml_curry2; // weak
int (*camlList__7)() = &camlList__find_all_1205; // weak
int (*camlList__8)() = &caml_curry2; // weak
int (*camlList__9)() = &caml_curry2; // weak
int (*camlList__10)() = &caml_curry2; // weak
int (*camlList__11)() = &caml_curry2; // weak
int (*camlList__12)() = &caml_curry2; // weak
int (*camlList__13)() = &caml_curry2; // weak
int (*camlList__14)() = &caml_curry2; // weak
int (*camlList__15)() = &caml_curry2; // weak
int (*camlList__16)() = &caml_curry2; // weak
int (*camlList__17)() = &caml_curry3; // weak
int (*camlList__18)() = &caml_curry3; // weak
int (*camlList__19)() = &caml_curry2; // weak
int (*camlList__20)() = &caml_curry2; // weak
int (*camlList__21)() = &caml_curry4; // weak
int (*camlList__22)() = &caml_curry4; // weak
int (*camlList__23)() = &caml_curry3; // weak
int (*camlList__24)() = &caml_curry3; // weak
int (*camlList__25)() = &caml_curry3; // weak
int (*camlList__26)() = &caml_curry3; // weak
int (*camlList__27)() = &caml_curry3; // weak
int (*camlList__28)() = &caml_curry2; // weak
int (*camlList__29)() = &caml_curry2; // weak
int (*camlList__30)() = &caml_curry2; // weak
int (*camlList__31)() = &camlList__flatten_1058; // weak
int (*camlList__32)() = &camlList__rev_1056; // weak
int (*camlList__33)() = &caml_curry2; // weak
int (*camlList__34)() = &caml_curry2; // weak
int (*camlList__35)() = &camlList__tl_1039; // weak
int (*camlList__36)() = &camlList__hd_1036; // weak
int (*camlList__37)() = &camlList__length_1034; // weak
int (*camlList__38)() = &caml_curry2; // weak
_UNKNOWN camlList__41; // weak
int camlSys = 0; // weak
int dword_8073450 = 0; // weak
int camlHashtbl = 0; // weak
int dword_80735A0 = 0; // weak
int dword_80735A4 = 0; // weak
int dword_80735A8 = 0; // weak
int dword_80735AC = 0; // weak
int dword_80735B0 = 0; // weak
int dword_80735B4 = 0; // weak
int dword_80735B8 = 0; // weak
int dword_80735BC = 0; // weak
int dword_80735C0 = 0; // weak
int dword_80735C4 = 0; // weak
int dword_80735C8 = 0; // weak
int dword_80735CC = 0; // weak
int dword_80735D0 = 0; // weak
int dword_80735D4 = 0; // weak
int dword_80735D8 = 0; // weak
int (*camlHashtbl__1)() = &camlHashtbl__Make_1251; // weak
int (*camlHashtbl__2)() = &caml_curry3; // weak
int (*camlHashtbl__3)() = &caml_curry2; // weak
int (*camlHashtbl__4)() = &caml_curry2; // weak
int (*camlHashtbl__5)() = &caml_curry3; // weak
int (*camlHashtbl__6)() = &caml_curry2; // weak
int (*camlHashtbl__7)() = &caml_curry2; // weak
int (*camlHashtbl__8)() = &caml_curry2; // weak
int (*camlHashtbl__9)() = &caml_curry2; // weak
int (*camlHashtbl__10)() = &caml_curry3; // weak
int (*camlHashtbl__11)() = &caml_curry2; // weak
int (*camlHashtbl__12)() = &camlHashtbl__length_1059; // weak
int (*camlHashtbl__13)() = &camlHashtbl__copy_1057; // weak
int (*camlHashtbl__14)() = &camlHashtbl__clear_1054; // weak
int (*camlHashtbl__15)() = &camlHashtbl__create_1051; // weak
int (*camlHashtbl__16)() = &camlHashtbl__hash_1031; // weak
int camlCallback = 0; // weak
int dword_8073F80 = 0; // weak
int (*camlCallback__1)() = &caml_curry2; // weak
int (*camlCallback__2)() = &caml_curry2; // weak
_UNKNOWN access_permission_table; // weak
_UNKNOWN getnameinfo_flag_table; // weak
_UNKNOWN open_flag_table; // weak
_UNKNOWN msg_flag_table; // weak
_DWORD socket_domain_table[3] = { 1, 2, 10 }; // idb
_DWORD socket_type_table[6] = { 1, 2, 3, 5, 0, 0 }; // idb
_DWORD file_kind_table[12] = { 32768, 16384, 8192, 24576, 40960, 4096, 49152, 0, 0, 0, 0, 0 }; // idb
int terminal_io_descr = 0; // weak
_DWORD error_table[68] =
{
  7,
  13,
  11,
  9,
  16,
  10,
  35,
  33,
  17,
  14,
  27,
  4,
  22,
  5,
  21,
  24,
  31,
  36,
  23,
  19,
  2,
  8,
  37,
  12,
  28,
  38,
  20,
  39,
  25,
  6,
  1,
  32,
  34,
  30,
  29,
  3,
  18,
  11,
  115,
  114,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  40,
  75
}; // idb
_UNKNOWN wait_flag_table; // weak
int percent_free_init = 80; // weak
int heap_chunk_init = 126976; // weak
int heap_size_init = 126976; // weak
int minor_heap_init = 262144; // weak
int array_bound_error_msg = 0; // weak
_UNKNOWN unk_8074474; // weak
char byte_8074487 = '\0'; // weak
int caml_last_return_address = 1; // weak
int (*caml_enter_blocking_section_hook)(void) = &caml_enter_blocking_section_default; // weak
int (*caml_leave_blocking_section_hook)(void) = &caml_leave_blocking_section_default; // weak
int (*caml_try_leave_blocking_section_hook)(void) = &caml_try_leave_blocking_section_default; // weak
int *caml_fl_merge = &dword_80744A8; // weak
int dword_80744A8 = 0; // weak
int *fl_prev = &dword_80744A8; // weak
void *compare_stack = &compare_stack_init; // idb
int compare_stack_limit = 134712608; // weak
char *caml_int32_ops = "_i"; // weak
char *caml_int64_ops = "_j"; // weak
char *caml_nativeint_ops = "_n"; // weak
char *channel_operations = "_chan"; // weak
_UNKNOWN extern_flags; // weak
_UNKNOWN sys_open_flags; // weak
void *caml_weak_none = &weak_dummy; // weak
int caml_backtrace_last_exn = 1; // weak
_UNKNOWN caml_debugger_fork_mode; // weak
int caml_extra_params = 0; // weak
int dword_8074580 = 0; // weak
FILE *stderr; // idb
char completed_5978; // weak
int dtor_idx_5980; // weak
int entry_h_length; // weak
_UNKNOWN terminal_status; // weak
char byte_80745F1[43]; // idb
int unix_error_exn; // weak
int (__cdecl *caml_termination_hook)(_DWORD); // weak
char proc_self_exe_2949[256]; // idb
int caml_exception_pointer; // weak
int array_bound_error_bucket_inited; // weak
int array_bound_error_bucket; // weak
int dword_807474C; // weak
int dword_8074750; // weak
int caml_local_roots; // weak
int (__cdecl *caml_scan_roots_hook)(_DWORD); // weak
void *caml_frame_descriptors; // idb
int caml_bottom_of_stack; // weak
int caml_globals_inited; // weak
int (*caml_stack_usage_hook)(void); // weak
int caml_dyn_globals; // weak
int caml_globals_scanned; // weak
int frametables; // weak
int inited_3139; // weak
_UNKNOWN caml_global_roots; // weak
_UNKNOWN caml_global_roots_young; // weak
void *ptr; // idb
int dword_8074828; // weak
_UNKNOWN caml_global_roots_old; // weak
int random_seed; // weak
int caml_signals_are_pending; // weak
int caml_force_major_slice; // weak
int caml_async_signal_mode; // weak
int caml_signal_handlers; // weak
int system_stack_top; // weak
_UNKNOWN sig_alt_stack; // weak
int caml_verb_gc; // weak
int caml_fl_cur_size; // weak
int caml_allocation_policy; // idb
int flp_size; // weak
int beyond; // weak
int fl_last; // weak
int dword_80768FC[]; // weak
int flp[]; // weak
_UNKNOWN unk_8076904; // weak
int dword_807789C; // weak
int last_fragment; // weak
int caml_fl_size_at_phase_change; // idb
void *gray_vals; // idb
int gray_vals_cur; // weak
int gray_vals_end; // weak
int gray_vals_size; // weak
int heap_is_pure; // weak
int markhp; // weak
int chunk; // weak
int limit; // weak
int weak_prev; // weak
int caml_young_start; // weak
int caml_young_end; // weak
int caml_young_ptr; // weak
int caml_young_limit; // weak
int caml_ref_table[3]; // idb
int dword_80778E8; // weak
int dword_80778EC; // weak
int caml_weak_ref_table[3]; // idb
int dword_8077904; // weak
int dword_8077908; // weak
int caml_in_minor_collection; // weak
int oldify_todo_list; // weak
void *caml_young_base; // idb
_UNKNOWN caml_page_table_empty; // weak
_UNKNOWN compare_stack_init; // weak
int locale_is_set_2848; // weak
int (__cdecl *caml_channel_mutex_free)(_DWORD); // weak
int (__cdecl *caml_channel_mutex_lock)(_DWORD); // weak
int (__cdecl *caml_channel_mutex_unlock)(_DWORD); // weak
int (*caml_channel_mutex_unlock_exn)(void); // weak
int caml_all_opened_channels; // weak
int obj_counter; // weak
int size_32; // weak
int size_64; // weak
int extern_ignore_sharing; // weak
int extern_closures; // weak
_UNKNOWN extern_trail_first; // weak
_UNKNOWN unk_8078D64; // weak
int extern_trail_block; // weak
int extern_trail_cur; // weak
int extern_trail_limit; // weak
int extern_userprovided_output; // weak
void *extern_ptr; // idb
int extern_limit; // weak
void *extern_output_first; // idb
int extern_output_block; // weak
int checksum_computed_3405; // weak
_DWORD checksum_3404[4]; // idb
void *intern_src; // idb
void *intern_input; // idb
int intern_input_malloced; // weak
int intern_dest; // weak
int intern_extra_block; // weak
int obj_counter_0; // weak
void *intern_obj_table; // idb
int intern_color; // weak
int intern_header; // weak
int intern_block; // weak
int hash_accu; // weak
int hash_univ_limit; // weak
int hash_univ_count; // weak
int caml_main_argv; // weak
int caml_parser_trace; // weak
double caml_stat_minor_words; // weak
double caml_stat_promoted_words; // weak
double caml_stat_major_words; // weak
int caml_stat_minor_collections; // weak
int caml_stat_major_collections; // weak
int caml_stat_heap_size; // weak
int caml_stat_top_heap_size; // weak
int caml_stat_compactions; // weak
int caml_stat_heap_chunks; // weak
int named_value_table[13]; // idb
int caml_weak_list_head; // weak
int compact_fl; // weak
int running_finalisation_function; // weak
int young; // weak
int size; // weak
void *final_table; // idb
int old; // weak
void *to_do_hd; // idb
int to_do_tl; // weak
int custom_ops_final_table; // weak
int custom_ops_table; // weak
int caml_backtrace_active; // weak
int caml_backtrace_pos; // weak
int caml_backtrace_buffer; // weak
_UNKNOWN caml_debugger_in_use; // weak
void *caml_code_area_start; // idb
struct __jmp_buf_tag caml_termination_jmpbuf; // idb
int caml_code_area_end; // weak
_DWORD caml_atom_table[1]; // idb
_UNKNOWN unk_807AF64; // weak
_UNKNOWN unk_807B354; // weak
int caml_frame_descriptors_mask; // weak
int caml_top_of_stack; // weak
int caml_gc_regs; // weak
int caml_pending_signals[66]; // idb
int caml_gc_subphase; // idb
int caml_gc_sweep_hp; // weak
int caml_percent_free; // idb
int caml_dependent_size; // weak
void *caml_heap_start; // idb
int caml_gc_phase; // weak
double caml_extra_heap_resources; // weak
int caml_allocated_words; // idb
int caml_major_heap_increment; // weak
int caml_dependent_allocated; // weak
int caml_minor_heap_size; // weak
int caml_page_table[512]; // idb
int caml_compare_unordered; // weak
void *caml_exe_name; // idb
int caml_percent_max; // idb
// extern void *environ; idb
// extern _UNKNOWN _gmon_start__; weak


//----- (08049D84) --------------------------------------------------------
int init_proc()
{
  int v1; // [esp+0h] [ebp-8h]

  if ( &_gmon_start__ )
    __gmon_start__();
  frame_dummy();
  _do_global_ctors_aux();
  return v1;
}
// 8049DB0: variable 'v1' is possibly undefined
// 8049F14: using guessed type int __gmon_start__(void);

//----- (08049DB4) --------------------------------------------------------
int sub_8049DB4()
{
  return dword_806D9AC();
}
// 806D9AC: using guessed type int (*dword_806D9AC)(void);

//----- (0804A910) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
  __halt();
}
// 804A913: positive sp value 4 has been found

//----- (0804A940) --------------------------------------------------------
void _do_global_dtors_aux()
{
  int v0; // eax
  unsigned int i; // ebx

  if ( !completed_5978 )
  {
    v0 = dtor_idx_5980;
    for ( i = &_DTOR_END__ - _DTOR_LIST__ - 1; dtor_idx_5980 < i; v0 = dtor_idx_5980 )
    {
      dtor_idx_5980 = v0 + 1;
      ((void (*)(void))_DTOR_LIST__[v0 + 1])();
    }
    completed_5978 = 1;
  }
}
// 806D860: using guessed type int _DTOR_LIST__[];
// 806D864: using guessed type int _DTOR_END__;
// 80745C4: using guessed type char completed_5978;
// 80745C8: using guessed type int dtor_idx_5980;

//----- (0804A9A0) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 806D868: using guessed type int _JCR_LIST__;

//----- (0804A9D0) --------------------------------------------------------
int caml_startup__code_begin()
{
  camlPervasives__entry();
  ++caml_globals_inited;
  camlArray__entry();
  ++caml_globals_inited;
  camlList__entry();
  ++caml_globals_inited;
  camlSys__entry();
  ++caml_globals_inited;
  camlHashtbl__entry();
  ++caml_globals_inited;
  camlCallback__entry();
  ++caml_globals_inited;
  camlUnix__entry();
  ++caml_globals_inited;
  camlUnixLabels__code_begin();
  ++caml_globals_inited;
  camlSource__entry();
  ++caml_globals_inited;
  camlStd_exit__code_begin();
  ++caml_globals_inited;
  return 1;
}
// 804DEA0: using guessed type int camlUnix__entry(void);
// 804FCF0: using guessed type int camlPervasives__entry(void);
// 8052F40: using guessed type int camlArray__entry(void);
// 8054F60: using guessed type int camlSys__entry(void);
// 8074764: using guessed type int caml_globals_inited;

//----- (0804AA50) --------------------------------------------------------
#error "804AA85: call analysis failed (funcsize=15)"

//----- (0804AA90) --------------------------------------------------------
#error "804AAC5: call analysis failed (funcsize=15)"

//----- (0804AAD0) --------------------------------------------------------
#error "804AB05: call analysis failed (funcsize=15)"

//----- (0804AB10) --------------------------------------------------------
#error "804AB45: call analysis failed (funcsize=15)"

//----- (0804AB50) --------------------------------------------------------
#error "804AB85: call analysis failed (funcsize=15)"

//----- (0804AB90) --------------------------------------------------------
#error "804ABC5: call analysis failed (funcsize=15)"

//----- (0804ABD0) --------------------------------------------------------
int __usercall caml_curry7_6@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // ecx
  int v3; // edi
  int v4; // esi
  int v5; // ecx
  int v7; // [esp+8h] [ebp-Ch]
  int (__fastcall *v8)(int, int); // [esp+Ch] [ebp-8h]

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 12);
  v3 = *(_DWORD *)(v2 + 12);
  v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 12) + 12) + 12);
  v4 = *(_DWORD *)(v2 + 8);
  v5 = *(_DWORD *)(v3 + 8);
  v8 = *(int (__fastcall **)(int, int))(v7 + 8);
  caml_extra_params = a1;
  dword_8074580 = v7;
  return v8(v5, v4);
}
// 804ABD0: could not find valid save-restore pair for ebp
// 804ABD0: could not find valid save-restore pair for edi
// 807457C: using guessed type int caml_extra_params;
// 8074580: using guessed type int dword_8074580;

//----- (0804AC40) --------------------------------------------------------
#error "804AC75: call analysis failed (funcsize=15)"

//----- (0804AC80) --------------------------------------------------------
#error "804ACB5: call analysis failed (funcsize=15)"

//----- (0804ACC0) --------------------------------------------------------
#error "804ACF5: call analysis failed (funcsize=15)"

//----- (0804AD00) --------------------------------------------------------
#error "804AD35: call analysis failed (funcsize=15)"

//----- (0804AD40) --------------------------------------------------------
#error "804AD75: call analysis failed (funcsize=15)"

//----- (0804AD80) --------------------------------------------------------
int __usercall caml_curry6_5@<eax>(int a1@<ebx>)
{
  int v1; // eax
  int v2; // ecx
  int v3; // ecx
  int v4; // edx
  int v6; // [esp+4h] [ebp-Ch]
  int (__fastcall *v7)(int, int); // [esp+8h] [ebp-8h]

  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_DWORD *)(v1 + 12);
  v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 12) + 12) + 12);
  v3 = *(_DWORD *)(v2 + 8);
  v7 = *(int (__fastcall **)(int, int))(v6 + 8);
  v4 = *(_DWORD *)(v1 + 8);
  caml_extra_params = v6;
  return v7(v3, v4);
}
// 804AD80: could not find valid save-restore pair for ebp
// 804AD80: could not find valid save-restore pair for edi
// 804AD80: could not find valid save-restore pair for esi
// 807457C: using guessed type int caml_extra_params;

//----- (0804ADD0) --------------------------------------------------------
#error "804AE05: call analysis failed (funcsize=15)"

//----- (0804AE10) --------------------------------------------------------
#error "804AE45: call analysis failed (funcsize=15)"

//----- (0804AE50) --------------------------------------------------------
#error "804AE85: call analysis failed (funcsize=15)"

//----- (0804AE90) --------------------------------------------------------
#error "804AEC5: call analysis failed (funcsize=15)"

//----- (0804AED0) --------------------------------------------------------
int __usercall caml_curry5_4@<eax>(int a1@<ebx>)
{
  return (*(int (__fastcall **)(_DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 12) + 12)
                                                           + 12)
                                               + 8))(
           *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8),
           *(_DWORD *)(a1 + 8));
}

//----- (0804AEF0) --------------------------------------------------------
#error "804AF25: call analysis failed (funcsize=15)"

//----- (0804AF30) --------------------------------------------------------
#error "804AF65: call analysis failed (funcsize=15)"

//----- (0804AF70) --------------------------------------------------------
#error "804AFA5: call analysis failed (funcsize=15)"

//----- (0804AFB0) --------------------------------------------------------
int __usercall caml_curry4_3@<eax>(int a1@<eax>, int a2@<ebx>)
{
  return (*(int (__fastcall **)(_DWORD, int))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 12) + 12) + 8))(
           *(_DWORD *)(a2 + 8),
           a1);
}

//----- (0804AFD0) --------------------------------------------------------
#error "804B005: call analysis failed (funcsize=15)"

//----- (0804B010) --------------------------------------------------------
#error "804B045: call analysis failed (funcsize=15)"

//----- (0804B050) --------------------------------------------------------
int __usercall caml_curry3_2@<eax>(int a1@<eax>, int a2@<ebx>)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 12) + 8))(a1);
}

//----- (0804B070) --------------------------------------------------------
#error "804B0A5: call analysis failed (funcsize=15)"

//----- (0804B0B0) --------------------------------------------------------
int __usercall caml_curry2_1@<eax>(int a1@<ebx>)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 12) + 8))();
}

//----- (0804B0C0) --------------------------------------------------------
int __usercall caml_tuplify2@<eax>(int a1@<ebx>)
{
  return (*(int (**)(void))(a1 + 8))();
}

//----- (0804B0D0) --------------------------------------------------------
int __usercall caml_tuplify3@<eax>(int a1@<eax>, int a2@<ebx>)
{
  return (*(int (__fastcall **)(_DWORD))(a2 + 8))(*(_DWORD *)(a1 + 8));
}

//----- (0804B0E0) --------------------------------------------------------
int __fastcall caml_apply3(int a1, int a2)
{
  int (**v3)(void); // eax
  int (**v4)(void); // ebx

  if ( *(_DWORD *)(a2 + 4) == 7 )
    return (*(int (**)(void))(a2 + 8))();
  v3 = (int (**)(void))(*(int (**)(void))a2)();
  v4 = (int (**)(void))(*v3)();
  return (*v4)();
}

//----- (0804B130) --------------------------------------------------------
int __fastcall caml_apply2(int a1)
{
  int (**v2)(void); // ebx

  if ( *(_DWORD *)(a1 + 4) == 5 )
    return (*(int (**)(void))(a1 + 8))();
  v2 = (int (**)(void))(*(int (**)(void))a1)();
  return (*v2)();
}

//----- (0804B170) --------------------------------------------------------
int camlStd_exit__code_begin()
{
  (**(void (***)(void))dword_8070D08)();
  return 1;
}
// 8070D08: using guessed type int dword_8070D08;

//----- (0804B190) --------------------------------------------------------
int **__usercall camlSource__code_begin@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // eax
  unsigned int v5; // eax
  int **result; // eax
  unsigned int v7; // eax
  int v8; // [esp+0h] [ebp-10h]
  int *v9; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  int *v11; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v9 = a1;
    v10 = a4;
    v11 = (int *)a3;
    v8 = a2;
    v4 = camlPervasives__input_1224(dword_8070C18, a2, a3, a4);
    if ( v4 == 1 )
      break;
    if ( v4 == v8 )
    {
      a4 = caml_c_call((int (*)(void))caml_create_string, 33);
      while ( 1 )
      {
        v7 = caml_young_ptr - 12;
        caml_young_ptr = v7;
        if ( v7 >= caml_young_limit )
          break;
        caml_call_gc(v8);
      }
      a1 = (int *)(v7 + 4);
      *(a1 - 1) = 2048;
      *a1 = v10;
      a1[1] = (int)v9;
      a2 = 20001;
      a3 = 1;
    }
    else
    {
      a2 = v8 - v4 + 1;
      a3 = (int)v11 + v4 - 1;
      a1 = v9;
    }
  }
  while ( 1 )
  {
    v5 = caml_young_ptr - 16;
    caml_young_ptr = v5;
    if ( v5 >= caml_young_limit )
      break;
    caml_call_gc(v8);
  }
  result = (int **)(v5 + 4);
  *(result - 1) = (int *)3072;
  *result = v9;
  result[1] = (int *)a4;
  result[2] = v11;
  return result;
}
// 804B190: could not find valid save-restore pair for ebx
// 804B268: variable 'v8' is possibly undefined
// 8070C18: using guessed type int dword_8070C18;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804B280) --------------------------------------------------------
int __usercall camlSource__output_buf_1037@<eax>(int a1@<eax>, int a2@<ebx>)
{
  return camlPervasives__output_1194(dword_8070C1C, a2, 1, a1);
}
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804B2A0) --------------------------------------------------------
int __usercall camlSource__rev_write_1040@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int *a4@<ebx>, int a5@<esi>)
{
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // ebp
  int v10; // [esp+0h] [ebp-14h]
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+10h] [ebp-4h]
  int v13; // [esp+10h] [ebp-4h]

  while ( 1 )
  {
    while ( a5 != 1 )
    {
      if ( 2 * *(unsigned __int8 *)(a3 + ((a5 - 2) >> 1)) == 20 )
      {
        v11 = a3;
        v13 = a1;
        v10 = a2 - a5 + 1;
        camlPervasives__output_1194(dword_8070C1C, v10, a5, a3);
        camlList__iter_1074((void (**)(void))dword_806E2F0, v13);
        a2 = a5;
        a5 -= 2;
        a1 = 1;
        a3 = v11;
      }
      else
      {
        a5 -= 2;
      }
    }
    v12 = a1;
    if ( a4 == (int *)1 )
      break;
    v5 = *a4;
    v6 = 4 * (*(_DWORD *)(*a4 - 4) >> 10) - 1;
    a5 = 2 * (v6 - *(unsigned __int8 *)(*a4 + v6)) + 1;
    while ( 1 )
    {
      v7 = (_DWORD *)(caml_young_ptr - 24);
      caml_young_ptr = (int)v7;
      if ( (unsigned int)v7 >= caml_young_limit )
        break;
      caml_call_gc(v10);
    }
    v8 = v7 + 1;
    *v7 = 2048;
    v7[1] = a3;
    v7[2] = a2;
    a1 = (int)(v7 + 4);
    *(_DWORD *)(a1 - 4) = 2048;
    *(_DWORD *)a1 = v8;
    *(_DWORD *)(a1 + 4) = v12;
    a4 = (int *)a4[1];
    a3 = v5;
    a2 = a5;
  }
  camlPervasives__output_1194(dword_8070C1C, a2, 1, a3);
  return camlList__iter_1074((void (**)(void))dword_806E2F0, v12);
}
// 804B2F1: variable 'a3' is possibly undefined
// 804B2F4: variable 'a2' is possibly undefined
// 804B3C8: variable 'v10' is possibly undefined
// 806E2F0: using guessed type int dword_806E2F0;
// 8070C1C: using guessed type int dword_8070C1C;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804B3E0) --------------------------------------------------------
int camlSource__entry()
{
  int v0; // eax
  int *v1; // eax

  camlSource = 20001;
  dword_806E2EC = (int)&camlSource__3;
  dword_806E2F0 = (int)&camlSource__2;
  dword_806E2F4 = (int)&camlSource__1;
  v0 = caml_c_call((int (*)(void))caml_create_string, 33);
  v1 = (int *)camlSource__code_begin((int *)1, 20001, 1, v0);
  dword_806E2F8 = *v1;
  dword_806E2FC = v1[1];
  dword_806E300 = v1[2];
  camlSource__rev_write_1040(1, dword_806E300, dword_806E2FC, (int *)dword_806E2F8, dword_806E300);
  return 1;
}
// 806E2E8: using guessed type int camlSource;
// 806E2EC: using guessed type int dword_806E2EC;
// 806E2F0: using guessed type int dword_806E2F0;
// 806E2F4: using guessed type int dword_806E2F4;
// 806E2F8: using guessed type int dword_806E2F8;
// 806E2FC: using guessed type int dword_806E2FC;
// 806E300: using guessed type int dword_806E300;
// 806E308: using guessed type int (*camlSource__1)();
// 806E318: using guessed type int (*camlSource__2)();
// 806E328: using guessed type int (*camlSource__3)();

//----- (0804B480) --------------------------------------------------------
#error "804B4CE: call analysis failed (funcsize=24)"

//----- (0804B4E0) --------------------------------------------------------
#error "804B556: call analysis failed (funcsize=37)"

//----- (0804B560) --------------------------------------------------------
int __usercall camlUnix__get_port_1739@<eax>(int a1@<eax>, int a2@<ecx>)
{
  _DWORD *v4; // eax
  _DWORD *v5; // ebx
  int result; // eax
  char ***v7; // eax
  char ***v8; // eax
  char v9; // [esp+0h] [ebp-Ch]

  if ( caml_string_equal(*(_DWORD **)(a2 + 12), camlUnix__215) == 1 )
  {
    v7 = (char ***)sub_804B6A0(a2);
    if ( *v7 == &caml_exn_Failure )
    {
      v8 = (char ***)sub_804B610();
      if ( *v8 == &caml_exn_Not_found )
      {
        result = 1;
      }
      else
      {
        caml_raise_exn((int)v8);
        result = (int)sub_804B610();
      }
    }
    else
    {
      caml_raise_exn((int)v7);
      result = (int)sub_804B6A0(a2);
    }
  }
  else
  {
    while ( 1 )
    {
      v4 = (_DWORD *)(caml_young_ptr - 24);
      caml_young_ptr = (int)v4;
      if ( (unsigned int)v4 >= caml_young_limit )
        break;
      caml_call_gc(v9);
    }
    v5 = v4 + 1;
    *v4 = 2048;
    v4[1] = a1;
    v4[2] = 1;
    result = (int)(v4 + 4);
    *(_DWORD *)(result - 4) = 2048;
    *(_DWORD *)result = v5;
    *(_DWORD *)(result + 4) = 1;
  }
  return result;
}
// 804B717: variable 'v9' is possibly undefined
// 806DCCC: using guessed type char *caml_exn_Failure;
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804B610) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_DWORD *sub_804B610()
{
  int v0; // ecx
  _DWORD *v1; // eax
  _DWORD *v2; // ebx
  _DWORD *result; // eax
  _DWORD v4[5]; // [esp-14h] [ebp-14h] BYREF

  v4[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v4;
  v0 = *(_DWORD *)(caml_c_call((int (*)(void))unix_getservbyname, *(_DWORD *)(v4[3] + 12)) + 8);
  while ( 1 )
  {
    v1 = (_DWORD *)(caml_young_ptr - 24);
    caml_young_ptr = (int)v1;
    if ( (unsigned int)v1 >= caml_young_limit )
      break;
    caml_call_gc(v4[0]);
  }
  v2 = v1 + 1;
  *v1 = 2048;
  v1[1] = v4[4];
  v1[2] = v0;
  result = v1 + 4;
  *(result - 1) = 2048;
  *result = v2;
  result[1] = 1;
  caml_exception_pointer = v4[0];
  return result;
}
// 804B685: positive sp value 10 has been found
// 804B663: variable 'v0' is possibly undefined
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804B6A0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_DWORD *__usercall sub_804B6A0@<eax>(int a1@<edi>)
{
  int v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  _DWORD *result; // eax
  _DWORD v5[5]; // [esp-14h] [ebp-14h] BYREF

  v5[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v5;
  v1 = caml_c_call((int (*)(void))caml_int_of_string, *(_DWORD *)(a1 + 12));
  while ( 1 )
  {
    v2 = (_DWORD *)(caml_young_ptr - 24);
    caml_young_ptr = (int)v2;
    if ( (unsigned int)v2 >= caml_young_limit )
      break;
    caml_call_gc(v5[0]);
  }
  v3 = v2 + 1;
  *v2 = 2048;
  v2[1] = v5[4];
  v2[2] = v1;
  result = v2 + 4;
  *(result - 1) = 2048;
  *result = v3;
  result[1] = 1;
  caml_exception_pointer = v5[0];
  return result;
}
// 804B705: positive sp value 10 has been found
// 804B6E3: variable 'v1' is possibly undefined
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804B730) --------------------------------------------------------
#error "804B75C: call analysis failed (funcsize=15)"

//----- (0804B770) --------------------------------------------------------
#error "804B7B9: call analysis failed (funcsize=19)"

//----- (0804B7C0) --------------------------------------------------------
int __usercall camlUnix__fun_2857@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_close, a1);
}

//----- (0804B7D0) --------------------------------------------------------
int __usercall camlUnix__fun_2863@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_close, a1);
}

//----- (0804B7E0) --------------------------------------------------------
int __usercall camlUnix__fun_2562@<eax>(char a1@<al>)
{
  return caml_c_call(unix_setsid, a1);
}

//----- (0804B7F0) --------------------------------------------------------
int __usercall camlUnix__fun_2564@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_tcflow, a1);
}

//----- (0804B800) --------------------------------------------------------
int __usercall camlUnix__fun_2566@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_tcflush, a1);
}

//----- (0804B810) --------------------------------------------------------
int __usercall camlUnix__fun_2568@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_tcdrain, a1);
}

//----- (0804B820) --------------------------------------------------------
int __usercall camlUnix__fun_2570@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_tcsendbreak, a1);
}

//----- (0804B830) --------------------------------------------------------
int __usercall camlUnix__fun_2572@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_tcsetattr, a1);
}

//----- (0804B850) --------------------------------------------------------
int __usercall camlUnix__fun_2574@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_tcgetattr, a1);
}

//----- (0804B860) --------------------------------------------------------
int __usercall camlUnix__fun_2576@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getservbyport, a1);
}

//----- (0804B870) --------------------------------------------------------
int __usercall camlUnix__fun_2578@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getservbyname, a1);
}

//----- (0804B880) --------------------------------------------------------
int __usercall camlUnix__fun_2580@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getprotobynumber, a1);
}

//----- (0804B890) --------------------------------------------------------
int __usercall camlUnix__fun_2582@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getprotobyname, a1);
}

//----- (0804B8A0) --------------------------------------------------------
int __usercall camlUnix__fun_2584@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_gethostbyaddr, a1);
}

//----- (0804B8B0) --------------------------------------------------------
int __usercall camlUnix__fun_2586@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_gethostbyname, a1);
}

//----- (0804B8C0) --------------------------------------------------------
int __usercall camlUnix__fun_2588@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_gethostname, a1);
}

//----- (0804B8D0) --------------------------------------------------------
int __usercall camlUnix__fun_2590@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getpeername, a1);
}

//----- (0804B8E0) --------------------------------------------------------
int __usercall camlUnix__fun_2592@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getsockname, a1);
}

//----- (0804B8F0) --------------------------------------------------------
int __usercall camlUnix__fun_2594@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_shutdown, a1);
}

//----- (0804B900) --------------------------------------------------------
int __usercall camlUnix__fun_2596@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_listen, a1);
}

//----- (0804B910) --------------------------------------------------------
int __usercall camlUnix__fun_2598@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_connect, a1);
}

//----- (0804B920) --------------------------------------------------------
int __usercall camlUnix__fun_2600@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_bind, a1);
}

//----- (0804B930) --------------------------------------------------------
int __usercall camlUnix__fun_2602@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_accept, a1);
}

//----- (0804B940) --------------------------------------------------------
int __usercall camlUnix__fun_2604@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_socketpair, a1);
}

//----- (0804B960) --------------------------------------------------------
int __usercall camlUnix__fun_2606@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_socket, a1);
}

//----- (0804B980) --------------------------------------------------------
int __usercall camlUnix__fun_2608@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_string_of_inet_addr, a1);
}

//----- (0804B990) --------------------------------------------------------
int __usercall camlUnix__fun_2610@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_inet_addr_of_string, a1);
}

//----- (0804B9A0) --------------------------------------------------------
int __usercall camlUnix__fun_2612@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getgrgid, a1);
}

//----- (0804B9B0) --------------------------------------------------------
int __usercall camlUnix__fun_2614@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getpwuid, a1);
}

//----- (0804B9C0) --------------------------------------------------------
int __usercall camlUnix__fun_2616@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getgrnam, a1);
}

//----- (0804B9D0) --------------------------------------------------------
int __usercall camlUnix__fun_2618@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getpwnam, a1);
}

//----- (0804B9E0) --------------------------------------------------------
int __usercall camlUnix__fun_2620@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getlogin, a1);
}

//----- (0804B9F0) --------------------------------------------------------
int __usercall camlUnix__fun_2622@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_initgroups, a1);
}

//----- (0804BA00) --------------------------------------------------------
int __usercall camlUnix__fun_2624@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_setgroups, a1);
}

//----- (0804BA10) --------------------------------------------------------
int __usercall camlUnix__fun_2626@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getgroups, a1);
}

//----- (0804BA20) --------------------------------------------------------
int __usercall camlUnix__fun_2628@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_setgid, a1);
}

//----- (0804BA30) --------------------------------------------------------
int __usercall camlUnix__fun_2630@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getegid, a1);
}

//----- (0804BA40) --------------------------------------------------------
int __usercall camlUnix__fun_2632@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getgid, a1);
}

//----- (0804BA50) --------------------------------------------------------
int __usercall camlUnix__fun_2634@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_setuid, a1);
}

//----- (0804BA60) --------------------------------------------------------
int __usercall camlUnix__fun_2636@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_geteuid, a1);
}

//----- (0804BA70) --------------------------------------------------------
int __usercall camlUnix__fun_2638@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getuid, a1);
}

//----- (0804BA80) --------------------------------------------------------
int __usercall camlUnix__fun_2640@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_setitimer, a1);
}

//----- (0804BA90) --------------------------------------------------------
int __usercall camlUnix__fun_2642@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getitimer, a1);
}

//----- (0804BAA0) --------------------------------------------------------
int __usercall camlUnix__fun_2644@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_utimes, a1);
}

//----- (0804BAC0) --------------------------------------------------------
int __usercall camlUnix__fun_2646@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_times, a1);
}

//----- (0804BAD0) --------------------------------------------------------
int __usercall camlUnix__fun_2648@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_sleep, a1);
}

//----- (0804BAE0) --------------------------------------------------------
int __usercall camlUnix__fun_2650@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_alarm, a1);
}

//----- (0804BAF0) --------------------------------------------------------
int __usercall camlUnix__fun_2652@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_mktime, a1);
}

//----- (0804BB00) --------------------------------------------------------
int __usercall camlUnix__fun_2654@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_localtime, a1);
}

//----- (0804BB10) --------------------------------------------------------
int __usercall camlUnix__fun_2656@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_gmtime, a1);
}

//----- (0804BB20) --------------------------------------------------------
int __usercall camlUnix__fun_2658@<eax>(char a1@<al>)
{
  return caml_c_call(unix_gettimeofday, a1);
}

//----- (0804BB30) --------------------------------------------------------
int __usercall camlUnix__fun_2660@<eax>(char a1@<al>)
{
  return caml_c_call(unix_time, a1);
}

//----- (0804BB40) --------------------------------------------------------
int __usercall camlUnix__fun_2662@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_sigsuspend, a1);
}

//----- (0804BB50) --------------------------------------------------------
int __usercall camlUnix__fun_2664@<eax>(char a1@<al>)
{
  return caml_c_call(unix_sigpending, a1);
}

//----- (0804BB60) --------------------------------------------------------
int __usercall camlUnix__fun_2666@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_sigprocmask, a1);
}

//----- (0804BB70) --------------------------------------------------------
int __usercall camlUnix__fun_2668@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_kill, a1);
}

//----- (0804BB80) --------------------------------------------------------
int __usercall camlUnix__fun_2670@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_lockf, a1);
}

//----- (0804BBA0) --------------------------------------------------------
int __usercall camlUnix__fun_2672@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_select, a1);
}

//----- (0804BBC0) --------------------------------------------------------
int __usercall camlUnix__fun_2674@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_readlink, a1);
}

//----- (0804BBD0) --------------------------------------------------------
int __usercall camlUnix__fun_2676@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_symlink, a1);
}

//----- (0804BBE0) --------------------------------------------------------
int __usercall camlUnix__fun_2678@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_mkfifo, a1);
}

//----- (0804BBF0) --------------------------------------------------------
int __usercall camlUnix__fun_2680@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_pipe, a1);
}

//----- (0804BC00) --------------------------------------------------------
int __usercall camlUnix__fun_2682@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_closedir, a1);
}

//----- (0804BC10) --------------------------------------------------------
int __usercall camlUnix__fun_2684@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_rewinddir, a1);
}

//----- (0804BC20) --------------------------------------------------------
int __usercall camlUnix__fun_2686@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_readdir, a1);
}

//----- (0804BC30) --------------------------------------------------------
int __usercall camlUnix__fun_2688@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_opendir, a1);
}

//----- (0804BC40) --------------------------------------------------------
int __usercall camlUnix__fun_2690@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_chroot, a1);
}

//----- (0804BC50) --------------------------------------------------------
int __usercall camlUnix__fun_2692@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getcwd, a1);
}

//----- (0804BC60) --------------------------------------------------------
int __usercall camlUnix__fun_2694@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_chdir, a1);
}

//----- (0804BC70) --------------------------------------------------------
int __usercall camlUnix__fun_2696@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_rmdir, a1);
}

//----- (0804BC80) --------------------------------------------------------
int __usercall camlUnix__fun_2698@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_mkdir, a1);
}

//----- (0804BC90) --------------------------------------------------------
int __usercall camlUnix__fun_2700@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_clear_close_on_exec, a1);
}

//----- (0804BCA0) --------------------------------------------------------
int __usercall camlUnix__fun_2702@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_set_close_on_exec, a1);
}

//----- (0804BCB0) --------------------------------------------------------
int __usercall camlUnix__fun_2704@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_clear_nonblock, a1);
}

//----- (0804BCC0) --------------------------------------------------------
int __usercall camlUnix__fun_2706@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_set_nonblock, a1);
}

//----- (0804BCD0) --------------------------------------------------------
int __usercall camlUnix__fun_2708@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_dup2, a1);
}

//----- (0804BCE0) --------------------------------------------------------
int __usercall camlUnix__fun_2710@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_dup, a1);
}

//----- (0804BCF0) --------------------------------------------------------
int __usercall camlUnix__fun_2712@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_access, a1);
}

//----- (0804BD00) --------------------------------------------------------
int __usercall camlUnix__fun_2714@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_umask, a1);
}

//----- (0804BD10) --------------------------------------------------------
int __usercall camlUnix__fun_2716@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_fchown, a1);
}

//----- (0804BD30) --------------------------------------------------------
int __usercall camlUnix__fun_2718@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_chown, a1);
}

//----- (0804BD50) --------------------------------------------------------
int __usercall camlUnix__fun_2720@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_fchmod, a1);
}

//----- (0804BD60) --------------------------------------------------------
int __usercall camlUnix__fun_2722@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_chmod, a1);
}

//----- (0804BD70) --------------------------------------------------------
int __usercall camlUnix__fun_2724@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_link, a1);
}

//----- (0804BD80) --------------------------------------------------------
int __usercall camlUnix__fun_2726@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_rename, a1);
}

//----- (0804BD90) --------------------------------------------------------
int __usercall camlUnix__fun_2728@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_unlink, a1);
}

//----- (0804BDA0) --------------------------------------------------------
int __usercall camlUnix__fun_2730@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_isatty, a1);
}

//----- (0804BDB0) --------------------------------------------------------
int __usercall camlUnix__fun_2732@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_fstat, a1);
}

//----- (0804BDC0) --------------------------------------------------------
int __usercall camlUnix__fun_2734@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_lstat, a1);
}

//----- (0804BDD0) --------------------------------------------------------
int __usercall camlUnix__fun_2736@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_stat, a1);
}

//----- (0804BDE0) --------------------------------------------------------
int __usercall camlUnix__fun_2738@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_ftruncate, a1);
}

//----- (0804BDF0) --------------------------------------------------------
int __usercall camlUnix__fun_2740@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_truncate, a1);
}

//----- (0804BE00) --------------------------------------------------------
int __usercall camlUnix__fun_2742@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_lseek, a1);
}

//----- (0804BE20) --------------------------------------------------------
int __usercall camlUnix__fun_2744@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_channel_descriptor, a1);
}

//----- (0804BE30) --------------------------------------------------------
int __usercall camlUnix__fun_2746@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_channel_descriptor, a1);
}

//----- (0804BE40) --------------------------------------------------------
int __usercall camlUnix__fun_2748@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_open_descriptor_out, a1);
}

//----- (0804BE50) --------------------------------------------------------
int __usercall camlUnix__fun_2750@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_open_descriptor_in, a1);
}

//----- (0804BE60) --------------------------------------------------------
int __usercall camlUnix__fun_2752@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_close, a1);
}

//----- (0804BE70) --------------------------------------------------------
int __usercall camlUnix__fun_2754@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_open, a1);
}

//----- (0804BE90) --------------------------------------------------------
int __usercall camlUnix__fun_2756@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_nice, a1);
}

//----- (0804BEA0) --------------------------------------------------------
int __usercall camlUnix__fun_2758@<eax>(char a1@<al>)
{
  return caml_c_call(unix_getppid, a1);
}

//----- (0804BEB0) --------------------------------------------------------
int __usercall camlUnix__fun_2760@<eax>(char a1@<al>)
{
  return caml_c_call(unix_getpid, a1);
}

//----- (0804BEC0) --------------------------------------------------------
int __usercall camlUnix__fun_2762@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_waitpid, a1);
}

//----- (0804BED0) --------------------------------------------------------
int __usercall camlUnix__fun_2764@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_wait, a1);
}

//----- (0804BEE0) --------------------------------------------------------
int __usercall camlUnix__fun_2766@<eax>(char a1@<al>)
{
  return caml_c_call(unix_fork, a1);
}

//----- (0804BEF0) --------------------------------------------------------
int __usercall camlUnix__fun_2768@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_execvpe, a1);
}

//----- (0804BF10) --------------------------------------------------------
int __usercall camlUnix__fun_2770@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_execvp, a1);
}

//----- (0804BF20) --------------------------------------------------------
int __usercall camlUnix__fun_2772@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_execve, a1);
}

//----- (0804BF40) --------------------------------------------------------
int __usercall camlUnix__fun_2774@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_execv, a1);
}

//----- (0804BF50) --------------------------------------------------------
int __usercall camlUnix__fun_2776@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_putenv, a1);
}

//----- (0804BF60) --------------------------------------------------------
int __usercall camlUnix__fun_2778@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_sys_getenv, a1);
}

//----- (0804BF70) --------------------------------------------------------
int __usercall camlUnix__fun_2780@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_environment, a1);
}

//----- (0804BF80) --------------------------------------------------------
int __usercall camlUnix__fun_2782@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_error_message, a1);
}

//----- (0804BF90) --------------------------------------------------------
int __usercall camlUnix__handle_unix_error_1171@<eax>(int (**a1)(void)@<eax>, int a2@<ecx>)
{
  _DWORD *v2; // eax
  int v3; // ebx
  int v4; // ebx
  int result; // eax
  int (**v6)(void); // edx
  int v7; // ecx
  char v8; // al
  int v9; // edx
  int v10; // ecx
  int v11; // [esp+4h] [ebp-8h]
  int v12; // [esp+8h] [ebp-4h]

  v2 = (_DWORD *)sub_804C0A0(a2, a1);
  if ( *v2 == camlUnix )
  {
    v12 = v2[3];
    v11 = v2[1];
    v3 = camlSys;
    if ( *(_DWORD *)(camlSys - 4) >> 9 <= 1u )
    {
      v8 = caml_ml_array_bound_error();
      result = camlUnix__read_1237(v8, v9, v10, v3);
    }
    else
    {
      camlPervasives__output_string_1191(dword_8070C20);
      camlPervasives__output_string_1191(dword_8070C20);
      camlPervasives__output_string_1191(dword_8070C20);
      camlPervasives__output_string_1191(dword_8070C20);
      v4 = 4 * (*(_DWORD *)(v12 - 4) >> 10) - 1;
      if ( 2 * (v4 - *(unsigned __int8 *)(v12 + v4)) + 1 > 1 )
      {
        camlPervasives__output_string_1191(dword_8070C20);
        camlPervasives__output_string_1191(dword_8070C20);
        camlPervasives__output_string_1191(dword_8070C20);
      }
      camlPervasives__output_string_1191(dword_8070C20);
      caml_c_call((int (*)(void))unix_error_message, v11);
      camlPervasives__prerr_endline_1285();
      result = camlPervasives__exit_1326(5);
    }
  }
  else
  {
    caml_raise_exn((int)v2);
    result = sub_804C0A0(v7, v6);
  }
  return result;
}
// 804C09A: variable 'v7' is possibly undefined
// 804C09A: variable 'v6' is possibly undefined
// 804C0CB: variable 'v9' is possibly undefined
// 804C0CB: variable 'v10' is possibly undefined
// 806E3D4: using guessed type int camlUnix;
// 8070C20: using guessed type int dword_8070C20;
// 8073438: using guessed type int camlSys;

//----- (0804C0A0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall sub_804C0A0(int a1, int (**a2)(void))
{
  int result; // eax
  int v3; // [esp-14h] [ebp-14h] BYREF

  v3 = caml_exception_pointer;
  caml_exception_pointer = (int)&v3;
  result = (*a2)();
  caml_exception_pointer = v3;
  return result;
}
// 804C0BE: positive sp value 10 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804C0D0) --------------------------------------------------------
int __usercall camlUnix__read_1237@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // esi

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))unix_read, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804C120) --------------------------------------------------------
int __usercall camlUnix__write_1242@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // esi

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))unix_write, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804C170) --------------------------------------------------------
int __usercall camlUnix__single_write_1247@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // esi

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))unix_single_write, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804C1C0) --------------------------------------------------------
int __usercall camlUnix__fun_2804@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_fstat_64, a1);
}

//----- (0804C1D0) --------------------------------------------------------
int __usercall camlUnix__fun_2802@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_lstat_64, a1);
}

//----- (0804C1E0) --------------------------------------------------------
int __usercall camlUnix__fun_2800@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_stat_64, a1);
}

//----- (0804C1F0) --------------------------------------------------------
int __usercall camlUnix__fun_2798@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_ftruncate_64, a1);
}

//----- (0804C200) --------------------------------------------------------
int __usercall camlUnix__fun_2796@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_truncate_64, a1);
}

//----- (0804C210) --------------------------------------------------------
int __usercall camlUnix__fun_2794@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_lseek_64, a1);
}

//----- (0804C230) --------------------------------------------------------
int __usercall camlUnix__try_set_close_on_exec_1366@<eax>(char a1@<al>)
{
  char ***v1; // eax
  char v3; // al

  v1 = (char ***)sub_804C260(a1);
  if ( *v1 == &caml_exn_Invalid_argument )
    return 1;
  v3 = caml_raise_exn((int)v1);
  return sub_804C260(v3);
}
// 806DCE8: using guessed type char *caml_exn_Invalid_argument;

//----- (0804C260) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804C260@<eax>(char a1@<al>)
{
  int result; // eax
  int v2; // [esp-8h] [ebp-8h] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  caml_c_call((int (*)(void))unix_set_close_on_exec, a1);
  result = 3;
  caml_exception_pointer = v2;
  return result;
}
// 804C288: positive sp value 4 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804C290) --------------------------------------------------------
int camlUnix__pause_1408()
{
  char v0; // al

  v0 = caml_c_call((int (*)(void))unix_sigprocmask, 3);
  return caml_c_call((int (*)(void))unix_sigsuspend, v0);
}

//----- (0804C2B0) --------------------------------------------------------
int __usercall camlUnix__is_inet6_addr_1500@<eax>(int a1@<eax>)
{
  int v2; // eax

  v2 = 4 * (*(_DWORD *)(a1 - 4) >> 10) - 1;
  return 2 * (2 * (v2 - *(unsigned __int8 *)(a1 + v2)) == 32) + 1;
}

//----- (0804C2E0) --------------------------------------------------------
int __usercall camlUnix__domain_of_sockaddr_1529@<eax>(_DWORD *a1@<eax>)
{
  int v1; // ebx
  int v2; // eax
  int result; // eax

  if ( !*((_BYTE *)a1 - 4) )
    return 1;
  v1 = *a1;
  v2 = 4 * (*(_DWORD *)(*a1 - 4) >> 10) - 1;
  if ( 2 * (v2 - *(unsigned __int8 *)(v1 + v2)) == 32 )
    result = 5;
  else
    result = 3;
  return result;
}

//----- (0804C330) --------------------------------------------------------
int __usercall camlUnix__recv_1558@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // ebp

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))unix_recv, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804C380) --------------------------------------------------------
int __usercall camlUnix__recvfrom_1564@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // ebp

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))unix_recvfrom, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804C3D0) --------------------------------------------------------
int __usercall camlUnix__send_1570@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // ebp

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))unix_send, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804C420) --------------------------------------------------------
int __usercall camlUnix__sendto_1576@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // ebp

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))unix_sendto_native, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804C480) --------------------------------------------------------
int __usercall camlUnix__fun_2816@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_setsockopt, a1);
}

//----- (0804C4A0) --------------------------------------------------------
int __usercall camlUnix__fun_2814@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))unix_getsockopt, a1);
}

//----- (0804C4C0) --------------------------------------------------------
int camlUnix__getsockopt_1643()
{
  return caml_c_call((int (*)(void))unix_getsockopt, 1);
}

//----- (0804C4E0) --------------------------------------------------------
int camlUnix__setsockopt_1646()
{
  return caml_c_call((int (*)(void))unix_setsockopt, 1);
}

//----- (0804C500) --------------------------------------------------------
int camlUnix__getsockopt_int_1650()
{
  return caml_c_call((int (*)(void))unix_getsockopt, 3);
}

//----- (0804C520) --------------------------------------------------------
int camlUnix__setsockopt_int_1653()
{
  return caml_c_call((int (*)(void))unix_setsockopt, 3);
}

//----- (0804C540) --------------------------------------------------------
int camlUnix__getsockopt_optint_1657()
{
  return caml_c_call((int (*)(void))unix_getsockopt, 5);
}

//----- (0804C560) --------------------------------------------------------
int camlUnix__setsockopt_optint_1660()
{
  return caml_c_call((int (*)(void))unix_setsockopt, 5);
}

//----- (0804C580) --------------------------------------------------------
int camlUnix__getsockopt_float_1664()
{
  return caml_c_call((int (*)(void))unix_getsockopt, 7);
}

//----- (0804C5A0) --------------------------------------------------------
int camlUnix__setsockopt_float_1667()
{
  return caml_c_call((int (*)(void))unix_setsockopt, 7);
}

//----- (0804C5C0) --------------------------------------------------------
int camlUnix__getsockopt_error_1671()
{
  return caml_c_call((int (*)(void))unix_getsockopt, 9);
}

//----- (0804C5E0) --------------------------------------------------------
void __usercall camlUnix__getaddrinfo_emulation_756(_DWORD *a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<ebx>, int a4, int a5, char a6)
{
  int v6; // ebx
  _DWORD *v7; // eax
  void (*v8)(void); // edi
  void (*v9)(void); // esi
  void (*v10)(void); // edx
  void (**v11)(void); // eax
  _DWORD *v12; // eax
  int v13; // ecx
  int *v14; // eax
  int v15; // ebx
  _DWORD *v16; // eax
  int *v17; // eax
  _DWORD *v18; // eax
  _DWORD *v19; // eax
  char ***v20; // eax
  char **v21; // ebx
  char ***v22; // eax
  int v24; // [esp+0h] [ebp-14h]
  int v25; // [esp+0h] [ebp-14h]
  int **v26; // [esp+4h] [ebp-10h]
  char v27; // [esp+8h] [ebp-Ch]

  v6 = (int)a2;
  while ( 1 )
  {
    v7 = (_DWORD *)(caml_young_ptr - 48);
    caml_young_ptr = (int)v7;
    if ( (unsigned int)v7 >= caml_young_limit )
      break;
    caml_call_gc((char)a3);
  }
  v8 = (void (*)(void))(v7 + 1);
  v26 = (int **)(v7 + 1);
  *v7 = 1024;
  v7[1] = 1;
  v9 = (void (*)(void))(v7 + 3);
  v27 = (_BYTE)v7 + 12;
  v7[2] = 1024;
  v7[3] = 1;
  v10 = (void (*)(void))(v7 + 5);
  v7[4] = 1024;
  v7[5] = 1;
  v11 = (void (**)(void))(v7 + 7);
  *(v11 - 1) = (void (*)(void))5367;
  *v11 = (void (*)(void))camlUnix__fun_2828;
  v11[1] = (void (*)(void))3;
  v11[2] = v8;
  v11[3] = v9;
  v11[4] = v10;
  camlList__iter_1074(v11, v6);
  while ( 1 )
  {
    v12 = (_DWORD *)(caml_young_ptr - 20);
    caml_young_ptr = (int)v12;
    if ( (unsigned int)v12 >= caml_young_limit )
      break;
    caml_call_gc((char)a3);
  }
  v13 = (int)(v12 + 1);
  *v12 = 4343;
  v12[1] = caml_curry2;
  v12[2] = 5;
  v12[3] = camlUnix__get_port_1739;
  v12[4] = a3;
  v14 = *v26;
  if ( *v26 == (int *)1 )
  {
    v25 = v13;
    v26 = (int **)camlUnix__get_port_1739(3, v13);
    v17 = (int *)camlUnix__get_port_1739(1, v25);
    v24 = (int)camlPervasives___40_1143(v17, (int)v26);
  }
  else
  {
    v15 = *v14;
    if ( *v14 == 3 )
    {
      v24 = camlUnix__get_port_1739(3, v13);
    }
    else if ( v15 == 1 )
    {
      v24 = camlUnix__get_port_1739(1, v13);
    }
    else if ( caml_string_equal(a3, camlUnix__202) == 1 )
    {
      v24 = 1;
    }
    else
    {
      while ( 1 )
      {
        v16 = (_DWORD *)(caml_young_ptr - 24);
        caml_young_ptr = (int)v16;
        if ( (unsigned int)v16 >= caml_young_limit )
          break;
        caml_call_gc((char)a3);
      }
      *v16 = 2048;
      v16[1] = v15;
      v16[2] = 1;
      v24 = (int)(v16 + 4);
      v16[3] = 2048;
      v16[4] = v16 + 1;
      v16[5] = 1;
    }
  }
  if ( caml_string_equal(a1, camlUnix__197) != 1 )
  {
    if ( camlList__mem_1161(5, a2) == 1 )
    {
      while ( 1 )
      {
        v19 = (_DWORD *)(caml_young_ptr - 24);
        caml_young_ptr = (int)v19;
        if ( (unsigned int)v19 >= caml_young_limit )
          break;
        caml_call_gc(v24);
      }
      *v19 = 2048;
      v19[1] = dword_806E58C;
      v19[2] = camlUnix__195;
      v19[3] = 2048;
      v19[4] = v19 + 1;
      v19[5] = 1;
    }
    else
    {
      while ( 1 )
      {
        v18 = (_DWORD *)(caml_young_ptr - 24);
        caml_young_ptr = (int)v18;
        if ( (unsigned int)v18 >= caml_young_limit )
          break;
        caml_call_gc(v24);
      }
      *v18 = 2048;
      v18[1] = dword_806E588;
      v18[2] = camlUnix__196;
      v18[3] = 2048;
      v18[4] = v18 + 1;
      v18[5] = 1;
    }
LABEL_30:
    JUMPOUT(0x804C9B4);
  }
  v20 = (char ***)sub_804C950((char)a1);
  v21 = *v20;
  if ( *v20 == &caml_exn_Failure )
  {
    sub_804C8C0(v24, (int)v26, v27);
    if ( *v22 == &caml_exn_Not_found )
      goto LABEL_30;
    caml_raise_exn((int)v22);
    sub_804C8C0(a4, a5, a6);
  }
  else
  {
    caml_raise_exn((int)v20);
    sub_804C950((char)v21);
  }
}
// 804C816: control flows out of bounds to 804C9B4
// 804C6A0: variable 'a3' is possibly undefined
// 804C892: variable 'v22' is possibly undefined
// 804CA1C: variable 'v24' is possibly undefined
// 804B070: using guessed type _DWORD caml_curry2();
// 804B4E0: using guessed type _DWORD camlUnix__fun_2828();
// 806DCCC: using guessed type char *caml_exn_Failure;
// 806DD58: using guessed type char *caml_exn_Not_found;
// 806E588: using guessed type int dword_806E588;
// 806E58C: using guessed type int dword_806E58C;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804C8C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_804C8C0(int a1, int a2, char a3)
{
  int v3; // ebx
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // [esp-8h] [ebp-8h] BYREF
  int v7; // [esp+4h] [ebp+4h]

  v6 = caml_exception_pointer;
  caml_exception_pointer = (int)&v6;
  v7 = caml_c_call((int (*)(void))unix_gethostbyname, a3);
  v3 = camlArray__to_list_1121();
  while ( 1 )
  {
    v4 = caml_young_ptr - 16;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(v6);
  }
  v5 = v4 + 4;
  *(_DWORD *)(v5 - 4) = 3319;
  *(_DWORD *)v5 = camlUnix__fun_2833;
  *(_DWORD *)(v5 + 4) = 3;
  *(_DWORD *)(v5 + 8) = v7;
  camlList__map_1062((int (**)(void))v5, v3);
  caml_exception_pointer = v6;
  JUMPOUT(0x804C9B4);
}
// 804C933: positive sp value 4 has been found
// 804C933: control flows out of bounds to 804C9B4
// 804B730: using guessed type _DWORD camlUnix__fun_2833();
// 8052510: using guessed type _DWORD camlArray__to_list_1121();
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804C950) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804C950@<eax>(char a1@<bl>)
{
  int v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // eax
  int **v6; // eax
  int v8; // [esp-1Ch] [ebp-1Ch] BYREF
  int v9; // [esp-14h] [ebp-14h]
  int v10; // [esp-Ch] [ebp-Ch]
  int v11; // [esp-8h] [ebp-8h]

  v8 = caml_exception_pointer;
  caml_exception_pointer = (int)&v8;
  v1 = caml_c_call((int (*)(void))unix_inet_addr_of_string, a1);
  while ( 1 )
  {
    v2 = (_DWORD *)(caml_young_ptr - 24);
    caml_young_ptr = (int)v2;
    if ( (unsigned int)v2 >= caml_young_limit )
      break;
    caml_call_gc(v8);
  }
  *v2 = 2048;
  v2[1] = v1;
  v2[2] = v11;
  v3 = v2 + 4;
  v2[3] = 2048;
  v2[4] = v2 + 1;
  v2[5] = 1;
  caml_exception_pointer = v8;
  while ( 1 )
  {
    v4 = caml_young_ptr - 24;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(v9);
  }
  v5 = v4 + 4;
  *(_DWORD *)(v5 - 4) = 5367;
  *(_DWORD *)v5 = caml_tuplify2;
  *(_DWORD *)(v5 + 4) = -3;
  *(_DWORD *)(v5 + 8) = camlUnix__fun_2836;
  *(_DWORD *)(v5 + 12) = v10;
  *(_DWORD *)(v5 + 16) = v3;
  v6 = (int **)camlList__map_1062((int (**)(void))v5, v9);
  return camlList__flatten_1058(v6);
}
// 804C9FC: positive sp value 18 has been found
// 804C98F: variable 'v1' is possibly undefined
// 804C9EE: variable 'v3' is possibly undefined
// 804B770: using guessed type _DWORD camlUnix__fun_2836();
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804CA50) --------------------------------------------------------
void __usercall camlUnix__getaddrinfo_1751(_DWORD *a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<ebx>, int a4, int a5, char a6)
{
  char ***v6; // eax
  char v7; // al

  v6 = (char ***)sub_804CAA0((char)a1);
  if ( *v6 == &caml_exn_Invalid_argument )
  {
    camlUnix__getaddrinfo_emulation_756(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    v7 = caml_raise_exn((int)v6);
    sub_804CAA0(v7);
  }
}
// 806DCE8: using guessed type char *caml_exn_Invalid_argument;

//----- (0804CAA0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804CAA0@<eax>(char a1@<al>)
{
  int result; // eax
  int v2; // [esp-14h] [ebp-14h] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  caml_c_call((int (*)(void))unix_getaddrinfo, a1);
  result = camlList__rev_append_1051();
  caml_exception_pointer = v2;
  return result;
}
// 804CAD2: positive sp value 10 has been found
// 8053F50: using guessed type int camlList__rev_append_1051(void);
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804CAE0) --------------------------------------------------------
void __usercall camlUnix__getnameinfo_emulation_1772(_DWORD *a1@<eax>, _DWORD *a2@<ebx>)
{
  char ***v2; // eax
  unsigned int v3; // eax
  _DWORD *v4; // eax
  int v5; // [esp+0h] [ebp-Ch]

  if ( *((_BYTE *)a1 - 4) )
  {
    v5 = *a1;
    v2 = (char ***)sub_804CB90(a2);
    if ( *v2 == &caml_exn_Not_found )
    {
      if ( camlList__mem_1161(5, a2) != 1 )
      {
        while ( 1 )
        {
          v3 = caml_young_ptr - 8;
          caml_young_ptr = v3;
          if ( v3 >= caml_young_limit )
            break;
          caml_call_gc(v5);
        }
        v4 = (_DWORD *)(v3 + 4);
        *(v4 - 1) = 1024;
        *v4 = &caml_exn_Not_found;
        caml_raise_exn((int)v4);
      }
      caml_c_call((int (*)(void))unix_string_of_inet_addr, v5);
    }
    else
    {
      caml_raise_exn((int)v2);
    }
    JUMPOUT(0x804CC01);
  }
  JUMPOUT(0x804CD00);
}
// 804CB83: control flows out of bounds to 804CC01
// 804CAE9: control flows out of bounds to 804CD00
// 804CB59: variable 'v5' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804CB90) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_DWORD *__usercall sub_804CB90@<eax>(_DWORD *a1@<ebx>)
{
  unsigned int v1; // eax
  _DWORD *v2; // eax
  char ***v3; // eax
  int v5; // [esp-8h] [ebp-8h] BYREF
  void *retaddr; // [esp+0h] [ebp+0h]

  v5 = caml_exception_pointer;
  caml_exception_pointer = (int)&v5;
  if ( camlList__mem_1161(3, a1) != 1 )
  {
    while ( 1 )
    {
      v1 = caml_young_ptr - 8;
      caml_young_ptr = v1;
      if ( v1 >= caml_young_limit )
        break;
      caml_call_gc(v5);
    }
    v2 = (_DWORD *)(v1 + 4);
    *(v2 - 1) = 1024;
    *v2 = &caml_exn_Not_found;
    caml_raise_exn((int)v2);
  }
  retaddr = *(void **)caml_c_call((int (*)(void))unix_gethostbyaddr, (char)retaddr);
  caml_exception_pointer = v5;
  v3 = (char ***)sub_804CC40();
  if ( *v3 == &caml_exn_Not_found )
  {
    camlPervasives__string_of_int_1130();
    JUMPOUT(0x804CCD3);
  }
  caml_raise_exn((int)v3);
  return sub_804CC40();
}
// 804CC01: positive sp value 4 has been found
// 804CC1C: control flows out of bounds to 804CCD3
// 806DD58: using guessed type char *caml_exn_Not_found;
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804CC40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_DWORD *sub_804CC40()
{
  unsigned int v0; // eax
  _DWORD *v1; // eax
  int v2; // ecx
  unsigned int v3; // eax
  _DWORD *result; // eax
  int v5; // [esp-14h] [ebp-14h] BYREF
  int v6; // [esp-Ch] [ebp-Ch]
  char v7; // [esp-8h] [ebp-8h]
  _DWORD *v8; // [esp-4h] [ebp-4h]

  v5 = caml_exception_pointer;
  caml_exception_pointer = (int)&v5;
  if ( camlList__mem_1161(7, v8) != 1 )
  {
    while ( 1 )
    {
      v0 = caml_young_ptr - 8;
      caml_young_ptr = v0;
      if ( v0 >= caml_young_limit )
        break;
      caml_call_gc(v5);
    }
    v1 = (_DWORD *)(v0 + 4);
    *(v1 - 1) = 1024;
    *v1 = &caml_exn_Not_found;
    caml_raise_exn((int)v1);
  }
  camlList__mem_1161(9, v8);
  v2 = *(_DWORD *)caml_c_call((int (*)(void))unix_getservbyport, v7);
  caml_exception_pointer = v5;
  while ( 1 )
  {
    v3 = caml_young_ptr - 12;
    caml_young_ptr = v3;
    if ( v3 >= caml_young_limit )
      break;
    caml_call_gc(v6);
  }
  result = (_DWORD *)(v3 + 4);
  *(result - 1) = 2048;
  *result = v6;
  result[1] = v2;
  return result;
}
// 804CCFD: positive sp value 10 has been found
// 804CC40: could not find valid save-restore pair for ebx
// 804CCF7: variable 'v2' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804CD60) --------------------------------------------------------
void __usercall camlUnix__getnameinfo_1781(_DWORD *a1@<eax>, _DWORD *a2@<ebx>)
{
  char ***v2; // eax
  char v3; // al

  v2 = (char ***)sub_804CDA0((char)a1);
  if ( *v2 == &caml_exn_Invalid_argument )
  {
    camlUnix__getnameinfo_emulation_1772(a1, a2);
  }
  else
  {
    v3 = caml_raise_exn((int)v2);
    sub_804CDA0(v3);
  }
}
// 806DCE8: using guessed type char *caml_exn_Invalid_argument;

//----- (0804CDA0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804CDA0@<eax>(char a1@<al>)
{
  int result; // eax
  int v2; // [esp-10h] [ebp-10h] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  result = caml_c_call((int (*)(void))unix_getnameinfo, a1);
  caml_exception_pointer = v2;
  return result;
}
// 804CDC7: positive sp value C has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804CDD0) --------------------------------------------------------
int camlUnix__system_1891()
{
  if ( caml_c_call(unix_fork, 1) != 1 )
    return *(_DWORD *)(caml_c_call((int (*)(void))unix_waitpid, 1) + 4);
  sub_804CE30();
  return camlPervasives__exit_1326(255);
}

//----- (0804CE30) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804CE30()
{
  _DWORD *v0; // eax
  int result; // eax
  _DWORD v2[3]; // [esp-Ch] [ebp-Ch] BYREF

  v2[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v2;
  while ( 1 )
  {
    v0 = (_DWORD *)(caml_young_ptr - 16);
    caml_young_ptr = (int)v0;
    if ( (unsigned int)v0 >= caml_young_limit )
      break;
    caml_call_gc(v2[0]);
  }
  *v0 = 3072;
  v0[1] = camlUnix__190;
  v0[2] = &camlUnix__191;
  v0[3] = v2[2];
  result = caml_c_call((int (*)(void))unix_execv, (char)camlUnix__189);
  caml_exception_pointer = v2[0];
  return result;
}
// 804CE8E: positive sp value 8 has been found
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804CEA0) --------------------------------------------------------
int __usercall camlUnix__safe_dup_1894@<eax>(char a1@<al>)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-8h]
  char v3; // [esp+4h] [ebp-4h]

  result = caml_c_call((int (*)(void))unix_dup, a1);
  if ( result < 7 )
  {
    v3 = result;
    v2 = camlUnix__safe_dup_1894();
    caml_c_call((int (*)(void))unix_close, v3);
    result = v2;
  }
  return result;
}

//----- (0804CEF0) --------------------------------------------------------
int __usercall camlUnix__safe_close_1898@<eax>(char a1@<al>)
{
  _DWORD *v1; // eax
  char v3; // al

  v1 = (_DWORD *)sub_804CF20(a1);
  if ( *v1 == camlUnix )
    return 1;
  v3 = caml_raise_exn((int)v1);
  return sub_804CF20(v3);
}
// 806E3D4: using guessed type int camlUnix;

//----- (0804CF20) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804CF20@<eax>(char a1@<al>)
{
  int result; // eax
  int v2; // [esp-8h] [ebp-8h] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  result = caml_c_call((int (*)(void))unix_close, a1);
  caml_exception_pointer = v2;
  return result;
}
// 804CF43: positive sp value 4 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804CF50) --------------------------------------------------------
int __usercall camlUnix__perform_redirections_1900@<eax>(char a1@<al>, char a2@<cl>, char a3@<bl>)
{
  char v6; // [esp+Ch] [ebp-Ch]
  char v7; // [esp+10h] [ebp-8h]
  char v8; // [esp+14h] [ebp-4h]

  v6 = camlUnix__safe_dup_1894(a1);
  v7 = camlUnix__safe_dup_1894(a3);
  v8 = camlUnix__safe_dup_1894(a2);
  camlUnix__safe_close_1898(a1);
  camlUnix__safe_close_1898(a3);
  camlUnix__safe_close_1898(a2);
  caml_c_call((int (*)(void))unix_dup2, v6);
  caml_c_call((int (*)(void))unix_close, v6);
  caml_c_call((int (*)(void))unix_dup2, v7);
  caml_c_call((int (*)(void))unix_close, v7);
  caml_c_call((int (*)(void))unix_dup2, v8);
  return caml_c_call((int (*)(void))unix_close, v8);
}

//----- (0804D020) --------------------------------------------------------
int camlUnix__create_process_1907()
{
  int result; // eax

  result = caml_c_call(unix_fork, 1);
  if ( result == 1 )
  {
    sub_804D070();
    result = camlPervasives__exit_1326(255);
  }
  return result;
}

//----- (0804D070) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804D070()
{
  int result; // eax
  int v1; // [esp-1Ch] [ebp-1Ch] BYREF
  char v2; // [esp-14h] [ebp-14h]
  char v3; // [esp-10h] [ebp-10h]
  char v4; // [esp-Ch] [ebp-Ch]
  char v5; // [esp-4h] [ebp-4h]

  v1 = caml_exception_pointer;
  caml_exception_pointer = (int)&v1;
  camlUnix__perform_redirections_1900(v2, v4, v3);
  result = caml_c_call((int (*)(void))unix_execvp, v5);
  caml_exception_pointer = v1;
  return result;
}
// 804D0B0: positive sp value 18 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804D0C0) --------------------------------------------------------
int camlUnix__create_process_env_1914()
{
  int result; // eax

  result = caml_c_call(unix_fork, 1);
  if ( result == 1 )
  {
    sub_804D120();
    result = camlPervasives__exit_1326(255);
  }
  return result;
}

//----- (0804D120) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804D120()
{
  int result; // eax
  int v1; // [esp-20h] [ebp-20h] BYREF
  char v2; // [esp-18h] [ebp-18h]
  char v3; // [esp-14h] [ebp-14h]
  char v4; // [esp-10h] [ebp-10h]
  char v5; // [esp-4h] [ebp-4h]

  v1 = caml_exception_pointer;
  caml_exception_pointer = (int)&v1;
  camlUnix__perform_redirections_1900(v2, v4, v3);
  result = caml_c_call((int (*)(void))unix_execvpe, v5);
  caml_exception_pointer = v1;
  return result;
}
// 804D165: positive sp value 1C has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804D170) --------------------------------------------------------
int __usercall camlUnix__open_proc_1949@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3@<ebx>, int a4@<esi>)
{
  int v4; // ecx
  int v6; // [esp+0h] [ebp-18h]

  v6 = camlList__for_all_1137((int (**)(void))dword_806E640, a4);
  v4 = caml_c_call(unix_fork, 1);
  if ( v4 != 1 )
    return camlHashtbl__add_1074((_DWORD *)dword_806E660, v4, a3);
  if ( a2 != 1 )
  {
    caml_c_call((int (*)(void))unix_dup2, a2);
    caml_c_call((int (*)(void))unix_close, a2);
  }
  if ( a1 != 3 )
  {
    caml_c_call((int (*)(void))unix_dup2, a1);
    caml_c_call((int (*)(void))unix_close, a1);
  }
  if ( v6 == 1 )
    camlList__iter_1074((void (**)(void))&camlUnix__188, a4);
  sub_804D250();
  return camlPervasives__exit_1326(255);
}
// 806E640: using guessed type int dword_806E640;
// 806E660: using guessed type int dword_806E660;
// 806EF7C: using guessed type int (*camlUnix__188)();

//----- (0804D250) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804D250()
{
  _DWORD *v0; // eax
  int result; // eax
  _DWORD v2[8]; // [esp-20h] [ebp-20h] BYREF

  v2[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v2;
  while ( 1 )
  {
    v0 = (_DWORD *)(caml_young_ptr - 16);
    caml_young_ptr = (int)v0;
    if ( (unsigned int)v0 >= caml_young_limit )
      break;
    caml_call_gc(v2[0]);
  }
  *v0 = 3072;
  v0[1] = camlUnix__186;
  v0[2] = &camlUnix__187;
  v0[3] = v2[3];
  result = caml_c_call((int (*)(void))unix_execv, (char)camlUnix__185);
  caml_exception_pointer = v2[0];
  return result;
}
// 804D2AE: positive sp value 1C has been found
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804D2C0) --------------------------------------------------------
int camlUnix__open_process_in_1957()
{
  int *v0; // eax
  int v1; // ecx
  _DWORD *v2; // eax
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v0 = (int *)caml_c_call((int (*)(void))unix_pipe, 1);
  v5 = v0[1];
  v4 = *v0;
  v1 = caml_c_call((int (*)(void))caml_ml_open_descriptor_in, *v0);
  v6 = v1;
  while ( 1 )
  {
    v2 = (_DWORD *)(caml_young_ptr - 20);
    caml_young_ptr = (int)v2;
    if ( (unsigned int)v2 >= caml_young_limit )
      break;
    caml_call_gc(v4);
  }
  *v2 = 2048;
  v2[1] = v4;
  v2[2] = 1;
  v2[3] = 1025;
  v2[4] = v1;
  camlUnix__open_proc_1949(v5, 1, (unsigned int)(v2 + 4), (int)(v2 + 1));
  caml_c_call((int (*)(void))unix_close, v5);
  return v6;
}
// 804D318: variable 'v4' is possibly undefined
// 804D32B: variable 'v1' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804D360) --------------------------------------------------------
int camlUnix__open_process_out_1962()
{
  int *v0; // eax
  int v1; // ecx
  _DWORD *v2; // eax
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v0 = (int *)caml_c_call((int (*)(void))unix_pipe, 1);
  v4 = v0[1];
  v5 = *v0;
  v1 = caml_c_call((int (*)(void))caml_ml_open_descriptor_out, v4);
  v6 = v1;
  while ( 1 )
  {
    v2 = (_DWORD *)(caml_young_ptr - 20);
    caml_young_ptr = (int)v2;
    if ( (unsigned int)v2 >= caml_young_limit )
      break;
    caml_call_gc(v4);
  }
  *v2 = 2048;
  v2[1] = v4;
  v2[2] = 1;
  v2[3] = 1026;
  v2[4] = v1;
  camlUnix__open_proc_1949(3, v5, (unsigned int)(v2 + 4), (int)(v2 + 1));
  caml_c_call((int (*)(void))unix_close, v5);
  return v6;
}
// 804D3B8: variable 'v4' is possibly undefined
// 804D3CB: variable 'v1' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804D400) --------------------------------------------------------
int *camlUnix__open_process_1967()
{
  int *v0; // eax
  int *v1; // eax
  int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // eax
  int *result; // eax
  int v6; // [esp+0h] [ebp-1Ch]
  char v7; // [esp+0h] [ebp-1Ch]
  int v8; // [esp+4h] [ebp-18h]
  int v9; // [esp+Ch] [ebp-10h]
  int v10; // [esp+10h] [ebp-Ch]
  int v11; // [esp+14h] [ebp-8h]
  int v12; // [esp+18h] [ebp-4h]

  v0 = (int *)caml_c_call((int (*)(void))unix_pipe, 1);
  v10 = v0[1];
  v8 = *v0;
  v1 = (int *)caml_c_call((int (*)(void))unix_pipe, 1);
  v6 = v1[1];
  v9 = *v1;
  v11 = caml_c_call((int (*)(void))caml_ml_open_descriptor_in, v8);
  v2 = caml_c_call((int (*)(void))caml_ml_open_descriptor_out, v6);
  v12 = v2;
  while ( 1 )
  {
    v3 = (_DWORD *)(caml_young_ptr - 36);
    caml_young_ptr = (int)v3;
    if ( (unsigned int)v3 >= caml_young_limit )
      break;
    caml_call_gc(v6);
  }
  *v3 = 2048;
  v3[1] = v6;
  v3[2] = 1;
  v7 = (_BYTE)v3 + 16;
  v3[3] = 2048;
  v3[4] = v8;
  v3[5] = v3 + 1;
  v3[6] = 2048;
  v3[7] = v11;
  v3[8] = v2;
  camlUnix__open_proc_1949(v10, v9, (unsigned int)(v3 + 7), (int)(v3 + 4));
  caml_c_call((int (*)(void))unix_close, v9);
  caml_c_call((int (*)(void))unix_close, v10);
  while ( 1 )
  {
    v4 = caml_young_ptr - 12;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(v7);
  }
  result = (int *)(v4 + 4);
  *(result - 1) = 2048;
  *result = v11;
  result[1] = v12;
  return result;
}
// 804D400: could not find valid save-restore pair for ebx
// 804D491: variable 'v6' is possibly undefined
// 804D4C0: variable 'v2' is possibly undefined
// 804D52B: variable 'v7' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804D540) --------------------------------------------------------
int __usercall camlUnix__open_proc_full_1975@<eax>(char a1@<dl>, unsigned int a2@<ecx>, char a3@<dil>, char a4@<sil>)
{
  int v4; // ecx
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+18h] [ebp-8h]

  v8 = caml_extra_params;
  v7 = camlList__for_all_1137((int (**)(void))dword_806E640, caml_extra_params);
  v4 = caml_c_call(unix_fork, 1);
  if ( v4 != 1 )
    return camlHashtbl__add_1074((_DWORD *)dword_806E660, v4, a2);
  caml_c_call((int (*)(void))unix_dup2, a1);
  caml_c_call((int (*)(void))unix_close, a1);
  caml_c_call((int (*)(void))unix_dup2, a4);
  caml_c_call((int (*)(void))unix_close, a4);
  caml_c_call((int (*)(void))unix_dup2, a3);
  caml_c_call((int (*)(void))unix_close, a3);
  if ( v7 == 1 )
    camlList__iter_1074((void (**)(void))&camlUnix__184, v8);
  sub_804D640();
  return camlPervasives__exit_1326(255);
}
// 806E640: using guessed type int dword_806E640;
// 806E660: using guessed type int dword_806E660;
// 806EF70: using guessed type int (*camlUnix__184)();
// 807457C: using guessed type int caml_extra_params;

//----- (0804D640) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804D640()
{
  _DWORD *v0; // eax
  int result; // eax
  _DWORD v2[10]; // [esp-28h] [ebp-28h] BYREF

  v2[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v2;
  while ( 1 )
  {
    v0 = (_DWORD *)(caml_young_ptr - 16);
    caml_young_ptr = (int)v0;
    if ( (unsigned int)v0 >= caml_young_limit )
      break;
    caml_call_gc(v2[0]);
  }
  *v0 = 3072;
  v0[1] = camlUnix__182;
  v0[2] = &camlUnix__183;
  v0[3] = v2[6];
  result = caml_c_call((int (*)(void))unix_execve, (char)camlUnix__181);
  caml_exception_pointer = v2[0];
  return result;
}
// 804D6A3: positive sp value 24 has been found
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804D6B0) --------------------------------------------------------
int *camlUnix__open_process_full_1985()
{
  int *v0; // eax
  int *v1; // eax
  int *v2; // eax
  int v3; // ebx
  _DWORD *v4; // eax
  unsigned int v5; // eax
  int *result; // eax
  int v7; // [esp+0h] [ebp-2Ch]
  char v8; // [esp+0h] [ebp-2Ch]
  int v9; // [esp+4h] [ebp-28h]
  int v10; // [esp+8h] [ebp-24h]
  int v11; // [esp+14h] [ebp-18h]
  int v12; // [esp+18h] [ebp-14h]
  int v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+20h] [ebp-Ch]
  int v15; // [esp+24h] [ebp-8h]

  v0 = (int *)caml_c_call((int (*)(void))unix_pipe, 1);
  v12 = v0[1];
  v10 = *v0;
  v1 = (int *)caml_c_call((int (*)(void))unix_pipe, 1);
  v9 = v1[1];
  v11 = *v1;
  v2 = (int *)caml_c_call((int (*)(void))unix_pipe, 1);
  v13 = v2[1];
  v7 = *v2;
  v14 = caml_c_call((int (*)(void))caml_ml_open_descriptor_in, v10);
  v15 = caml_c_call((int (*)(void))caml_ml_open_descriptor_out, v9);
  v3 = caml_c_call((int (*)(void))caml_ml_open_descriptor_in, v7);
  while ( 1 )
  {
    v4 = (_DWORD *)(caml_young_ptr - 52);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
    caml_call_gc(v7);
  }
  *v4 = 2048;
  v4[1] = v7;
  v4[2] = 1;
  v4[3] = 2048;
  v4[4] = v9;
  v4[5] = v4 + 1;
  v8 = (_BYTE)v4 + 28;
  v4[6] = 2048;
  v4[7] = v10;
  v4[8] = v4 + 4;
  v4[9] = 3075;
  v4[10] = v14;
  v4[11] = v15;
  v4[12] = v3;
  caml_extra_params = (int)(v4 + 7);
  camlUnix__open_proc_full_1975(v11, (unsigned int)(v4 + 10), v13, v12);
  caml_c_call((int (*)(void))unix_close, v11);
  caml_c_call((int (*)(void))unix_close, v12);
  caml_c_call((int (*)(void))unix_close, v13);
  while ( 1 )
  {
    v5 = caml_young_ptr - 16;
    caml_young_ptr = v5;
    if ( v5 >= caml_young_limit )
      break;
    caml_call_gc(v8);
  }
  result = (int *)(v5 + 4);
  *(result - 1) = 3072;
  *result = v14;
  result[1] = v15;
  result[2] = v3;
  return result;
}
// 804D6B0: could not find valid save-restore pair for ebx
// 804D6B0: could not find valid save-restore pair for edi
// 804D6B0: could not find valid save-restore pair for esi
// 804D777: variable 'v7' is possibly undefined
// 804D852: variable 'v8' is possibly undefined
// 807457C: using guessed type int caml_extra_params;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804D870) --------------------------------------------------------
int __usercall camlUnix__find_proc_id_1997@<eax>(int a1@<eax>, char a2@<bl>)
{
  char ***v2; // eax
  char **v3; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // eax
  char v7; // [esp+0h] [ebp-Ch]

  v2 = (char ***)sub_804D8E0(a2);
  v3 = *v2;
  if ( *v2 == &caml_exn_Not_found )
  {
    while ( 1 )
    {
      v4 = caml_young_ptr - 20;
      caml_young_ptr = v4;
      if ( v4 >= caml_young_limit )
        break;
      caml_call_gc(v7);
    }
    v5 = (_DWORD *)(v4 + 4);
    *(v5 - 1) = 4096;
    *v5 = camlUnix;
    v5[1] = 7;
    LOBYTE(v3) = a1;
    v5[2] = a1;
    v5[3] = &camlUnix__180;
    v2 = (char ***)caml_raise_exn((int)v5);
  }
  caml_raise_exn((int)v2);
  return sub_804D8E0((char)v3);
}
// 804D918: variable 'v7' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 806E3D4: using guessed type int camlUnix;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804D8E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804D8E0@<eax>(char a1@<bl>)
{
  int v2; // [esp-14h] [ebp-14h] BYREF
  int v3; // [esp-Ch] [ebp-Ch]
  unsigned int v4; // [esp-4h] [ebp-4h]

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  v3 = camlHashtbl__find_1093(dword_806E660, a1);
  camlHashtbl__remove_1080(dword_806E660, v4);
  caml_exception_pointer = v2;
  return v3;
}
// 804D917: positive sp value 10 has been found
// 806E660: using guessed type int dword_806E660;
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804D930) --------------------------------------------------------
int __usercall camlUnix__waitpid_non_intr_2001@<eax>(int a1@<eax>)
{
  _DWORD *v1; // eax
  int v2; // ebx
  int v4; // [esp+0h] [ebp-4h]

  while ( 1 )
  {
    v4 = a1;
    v1 = (_DWORD *)sub_804D970();
    if ( *v1 != camlUnix )
      break;
    v2 = v1[1];
    if ( (v2 & 1) == 0 || v2 != 23 )
      break;
    a1 = v4;
  }
  caml_raise_exn((int)v1);
  return sub_804D970();
}
// 806E3D4: using guessed type int camlUnix;

//----- (0804D970) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804D970()
{
  int result; // eax
  int v1; // [esp-Ch] [ebp-Ch] BYREF

  v1 = caml_exception_pointer;
  caml_exception_pointer = (int)&v1;
  result = caml_c_call((int (*)(void))unix_waitpid, 1);
  caml_exception_pointer = v1;
  return result;
}
// 804D998: positive sp value 8 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804D9A0) --------------------------------------------------------
int __usercall camlUnix__close_process_in_2003@<eax>(int a1@<eax>)
{
  _DWORD *v2; // eax
  char i; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  for ( i = a1; ; caml_call_gc(i) )
  {
    v2 = (_DWORD *)(caml_young_ptr - 8);
    caml_young_ptr = (int)v2;
    if ( (unsigned int)v2 >= caml_young_limit )
      break;
  }
  *v2 = 1025;
  v2[1] = a1;
  v5 = camlUnix__find_proc_id_1997((int)camlUnix__179, (_BYTE)v2 + 4);
  caml_c_call((int (*)(void))caml_ml_close_channel, i);
  return *(_DWORD *)(camlUnix__waitpid_non_intr_2001(v5) + 4);
}
// 804D9C7: variable 'a1' is possibly undefined
// 804D9E0: variable 'i' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804DA10) --------------------------------------------------------
int __usercall camlUnix__close_process_out_2006@<eax>(int a1@<eax>)
{
  _DWORD *v2; // eax
  char i; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  for ( i = a1; ; caml_call_gc(i) )
  {
    v2 = (_DWORD *)(caml_young_ptr - 8);
    caml_young_ptr = (int)v2;
    if ( (unsigned int)v2 >= caml_young_limit )
      break;
  }
  *v2 = 1026;
  v2[1] = a1;
  v5 = camlUnix__find_proc_id_1997((int)camlUnix__178, (_BYTE)v2 + 4);
  camlPervasives__close_out_1209(i);
  return *(_DWORD *)(camlUnix__waitpid_non_intr_2001(v5) + 4);
}
// 804DA37: variable 'a1' is possibly undefined
// 804DA4A: variable 'i' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804DA70) --------------------------------------------------------
int __usercall camlUnix__close_process_2009@<eax>(int a1@<eax>, int a2@<ebx>)
{
  _DWORD *v4; // eax
  char ***v5; // eax
  char i; // [esp+0h] [ebp-Ch]

  for ( i = a1; ; caml_call_gc(i) )
  {
    v4 = (_DWORD *)(caml_young_ptr - 12);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
  }
  *v4 = 2048;
  v4[1] = a1;
  v4[2] = a2;
  camlUnix__find_proc_id_1997((int)camlUnix__177, (_BYTE)v4 + 4);
  caml_c_call((int (*)(void))caml_ml_close_channel, i);
  v5 = (char ***)sub_804DAE0();
  if ( *v5 == &caml_exn_Sys_error )
    JUMPOUT(0x804DAFE);
  caml_raise_exn((int)v5);
  return sub_804DAE0();
}
// 804DACF: control flows out of bounds to 804DAFE
// 804DA9D: variable 'a1' is possibly undefined
// 804DA9F: variable 'a2' is possibly undefined
// 804DAB9: variable 'i' is possibly undefined
// 806DCAC: using guessed type char *caml_exn_Sys_error;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804DAE0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804DAE0()
{
  _DWORD v1[4]; // [esp-14h] [ebp-14h] BYREF
  char v2; // [esp-4h] [ebp-4h]

  v1[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v1;
  camlPervasives__close_out_1209(v2);
  caml_exception_pointer = v1[0];
  return *(_DWORD *)(camlUnix__waitpid_non_intr_2001(v1[3]) + 4);
}
// 804DB0F: positive sp value 10 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804DB20) --------------------------------------------------------
int __usercall camlUnix__close_process_full_2013@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  _DWORD *v4; // eax
  char ***v5; // eax
  char i; // [esp+0h] [ebp-10h]

  for ( i = a1; ; caml_call_gc(i) )
  {
    v4 = (_DWORD *)(caml_young_ptr - 16);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
  }
  *v4 = 3075;
  v4[1] = a1;
  v4[2] = a3;
  v4[3] = a2;
  camlUnix__find_proc_id_1997((int)camlUnix__176, (_BYTE)v4 + 4);
  caml_c_call((int (*)(void))caml_ml_close_channel, i);
  v5 = (char ***)sub_804DBA0();
  if ( *v5 == &caml_exn_Sys_error )
    JUMPOUT(0x804DBBE);
  caml_raise_exn((int)v5);
  return sub_804DBA0();
}
// 804DB8A: control flows out of bounds to 804DBBE
// 804DB55: variable 'a1' is possibly undefined
// 804DB5A: variable 'a2' is possibly undefined
// 804DB74: variable 'i' is possibly undefined
// 806DCAC: using guessed type char *caml_exn_Sys_error;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804DBA0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804DBA0()
{
  int v1; // [esp-18h] [ebp-18h] BYREF
  char v2; // [esp-Ch] [ebp-Ch]
  int v3; // [esp-8h] [ebp-8h]
  char v4; // [esp-4h] [ebp-4h]

  v1 = caml_exception_pointer;
  caml_exception_pointer = (int)&v1;
  camlPervasives__close_out_1209(v4);
  caml_exception_pointer = v1;
  caml_c_call((int (*)(void))caml_ml_close_channel, v2);
  return *(_DWORD *)(camlUnix__waitpid_non_intr_2001(v3) + 4);
}
// 804DBE1: positive sp value 14 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804DBF0) --------------------------------------------------------
int *__usercall camlUnix__open_connection_2018@<eax>(_DWORD *a1@<eax>)
{
  char v1; // al
  char v2; // al
  int *v4; // [esp+0h] [ebp-8h]
  char v5; // [esp+4h] [ebp-4h]

  v1 = camlUnix__domain_of_sockaddr_1529(a1);
  v5 = caml_c_call((int (*)(void))unix_socket, v1);
  v4 = sub_804DC40(v5);
  caml_c_call((int (*)(void))unix_close, v5);
  v2 = caml_raise_exn((int)v4);
  return sub_804DC40(v2);
}

//----- (0804DC40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int *__usercall sub_804DC40@<eax>(char a1@<al>)
{
  int v1; // ebx
  unsigned int v2; // eax
  int *result; // eax
  int v4; // [esp-10h] [ebp-10h] BYREF
  int v5; // [esp-8h] [ebp-8h]
  char v6; // [esp-4h] [ebp-4h]

  v4 = caml_exception_pointer;
  caml_exception_pointer = (int)&v4;
  caml_c_call((int (*)(void))unix_connect, a1);
  camlUnix__try_set_close_on_exec_1366(v6);
  v5 = caml_c_call((int (*)(void))caml_ml_open_descriptor_out, v6);
  v1 = caml_c_call((int (*)(void))caml_ml_open_descriptor_in, v6);
  while ( 1 )
  {
    v2 = caml_young_ptr - 12;
    caml_young_ptr = v2;
    if ( v2 >= caml_young_limit )
      break;
    caml_call_gc(v4);
  }
  result = (int *)(v2 + 4);
  *(result - 1) = 2048;
  *result = v1;
  result[1] = v5;
  caml_exception_pointer = v4;
  return result;
}
// 804DCC6: positive sp value C has been found
// 804DC40: could not find valid save-restore pair for ebx
// 8074740: using guessed type int caml_exception_pointer;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804DCD0) --------------------------------------------------------
int __usercall camlUnix__shutdown_connection_2022@<eax>(char a1@<al>)
{
  char v1; // al

  v1 = caml_c_call((int (*)(void))caml_channel_descriptor, a1);
  return caml_c_call((int (*)(void))unix_shutdown, v1);
}

//----- (0804DCF0) --------------------------------------------------------
int __usercall camlUnix__accept_non_intr_2024@<eax>(int a1@<eax>)
{
  _DWORD *v1; // eax
  int v2; // ebx
  char v3; // al
  int v5; // [esp+0h] [ebp-4h]

  while ( 1 )
  {
    v5 = a1;
    v1 = (_DWORD *)sub_804DD30(a1);
    if ( *v1 != camlUnix )
      break;
    v2 = v1[1];
    if ( (v2 & 1) == 0 || v2 != 23 )
      break;
    a1 = v5;
  }
  v3 = caml_raise_exn((int)v1);
  return sub_804DD30(v3);
}
// 806E3D4: using guessed type int camlUnix;

//----- (0804DD30) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804DD30@<eax>(char a1@<al>)
{
  int result; // eax
  int v2; // [esp-Ch] [ebp-Ch] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  result = caml_c_call((int (*)(void))unix_accept, a1);
  caml_exception_pointer = v2;
  return result;
}
// 804DD56: positive sp value 8 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804DD60) --------------------------------------------------------
void __usercall __noreturn camlUnix__establish_server_2026(int a1@<eax>, _DWORD *a2@<ebx>)
{
  char v2; // al
  int v3; // [esp+0h] [ebp-10h]
  int v4; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  v2 = camlUnix__domain_of_sockaddr_1529(a2);
  v4 = caml_c_call((int (*)(void))unix_socket, v2);
  camlUnix__setsockopt_1646();
  caml_c_call((int (*)(void))unix_bind, v4);
  caml_c_call((int (*)(void))unix_listen, v4);
  while ( 1 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)camlUnix__accept_non_intr_2024(v4);
      v3 = caml_c_call(unix_fork, 1);
      if ( v3 == 1 )
        break;
      caml_c_call((int (*)(void))unix_close, v6);
      camlUnix__waitpid_non_intr_2001(v3);
    }
    if ( caml_c_call(unix_fork, 1) != 1 )
      camlPervasives__exit_1326(1);
    caml_c_call((int (*)(void))unix_close, v4);
    camlUnix__try_set_close_on_exec_1366(v6);
    caml_c_call((int (*)(void))caml_ml_open_descriptor_in, v6);
    caml_c_call((int (*)(void))caml_ml_open_descriptor_out, v6);
    caml_apply2(a1);
    camlPervasives__exit_1326(1);
  }
}

//----- (0804DEA0) --------------------------------------------------------
#error "804E2FB: call analysis failed (funcsize=173)"

//----- (0804E43A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804E43A()
{
  int v0; // eax
  char ***v1; // eax
  int v3; // [esp-8h] [ebp-8h] BYREF

  v3 = caml_exception_pointer;
  caml_exception_pointer = (int)&v3;
  v0 = caml_c_call((int (*)(void))unix_inet_addr_of_string, (char)&camlUnix__44);
  caml_exception_pointer = v3;
  dword_806E590 = v0;
  v1 = (char ***)sub_804E482();
  if ( *v1 == &caml_exn_Failure )
    JUMPOUT(0x804E4A9);
  caml_raise_exn((int)v1);
  return sub_804E482();
}
// 804E461: positive sp value 4 has been found
// 804E47B: control flows out of bounds to 804E4A9
// 804E482: using guessed type _DWORD sub_804E482();
// 806DCCC: using guessed type char *caml_exn_Failure;
// 806E590: using guessed type int dword_806E590;
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804E482) --------------------------------------------------------
#error "804E4E5: call analysis failed (funcsize=106)"

//----- (0804E6A0) --------------------------------------------------------
int camlUnixLabels__code_begin()
{
  camlUnixLabels = camlUnix;
  dword_807094C = *(&camlUnix + 1);
  dword_8070950 = *(&camlUnix + 2);
  dword_8070954 = *(&camlUnix + 3);
  dword_8070958 = *(&camlUnix + 4);
  dword_807095C = *(&camlUnix + 5);
  dword_8070960 = *(&camlUnix + 6);
  dword_8070964 = *(&camlUnix + 7);
  dword_8070968 = *(&camlUnix + 8);
  dword_807096C = *(&camlUnix + 9);
  dword_8070970 = *(&camlUnix + 10);
  dword_8070974 = *(&camlUnix + 11);
  dword_8070978 = *(&camlUnix + 12);
  dword_807097C = *(&camlUnix + 13);
  dword_8070980 = *(&camlUnix + 14);
  dword_8070984 = *(&camlUnix + 15);
  dword_8070988 = *(&camlUnix + 16);
  dword_807098C = 1;
  dword_8070990 = 3;
  dword_8070994 = 5;
  dword_8070998 = *(&camlUnix + 20);
  dword_807099C = *(&camlUnix + 21);
  dword_80709A0 = *(&camlUnix + 22);
  dword_80709A4 = *(&camlUnix + 23);
  dword_80709A8 = *(&camlUnix + 24);
  dword_80709AC = *(&camlUnix + 25);
  dword_80709B0 = *(&camlUnix + 26);
  dword_80709B4 = *(&camlUnix + 27);
  dword_80709B8 = *(&camlUnix + 28);
  dword_80709BC = *(&camlUnix + 29);
  dword_80709C0 = *(&camlUnix + 30);
  dword_80709C4 = *(&camlUnix + 31);
  dword_80709C8 = *(&camlUnix + 32);
  dword_80709CC = *(&camlUnix + 33);
  dword_80709D0 = *(&camlUnix + 34);
  dword_80709D4 = *(&camlUnix + 35);
  dword_80709D8 = *(&camlUnix + 36);
  dword_80709DC = *(&camlUnix + 37);
  dword_80709E0 = *(&camlUnix + 38);
  dword_80709E4 = *(&camlUnix + 39);
  dword_80709E8 = *(&camlUnix + 40);
  dword_80709EC = *(&camlUnix + 41);
  dword_80709F0 = *(&camlUnix + 42);
  dword_80709F4 = *(&camlUnix + 43);
  dword_80709F8 = *(&camlUnix + 44);
  dword_80709FC = *(&camlUnix + 45);
  dword_8070A00 = *(&camlUnix + 46);
  dword_8070A04 = *(&camlUnix + 47);
  dword_8070A08 = *(&camlUnix + 48);
  dword_8070A0C = *(&camlUnix + 49);
  dword_8070A10 = *(&camlUnix + 50);
  dword_8070A14 = *(&camlUnix + 51);
  dword_8070A18 = *(&camlUnix + 52);
  dword_8070A1C = *(&camlUnix + 53);
  dword_8070A20 = *(&camlUnix + 54);
  dword_8070A24 = *(&camlUnix + 55);
  dword_8070A28 = *(&camlUnix + 56);
  dword_8070A2C = *(&camlUnix + 57);
  dword_8070A30 = *(&camlUnix + 58);
  dword_8070A34 = *(&camlUnix + 59);
  dword_8070A38 = *(&camlUnix + 60);
  dword_8070A3C = *(&camlUnix + 61);
  dword_8070A40 = *(&camlUnix + 62);
  dword_8070A44 = *(&camlUnix + 63);
  dword_8070A48 = *(&camlUnix + 64);
  dword_8070A4C = *(&camlUnix + 65);
  dword_8070A50 = *(&camlUnix + 66);
  dword_8070A54 = *(&camlUnix + 67);
  dword_8070A58 = *(&camlUnix + 68);
  dword_8070A5C = *(&camlUnix + 69);
  dword_8070A60 = *(&camlUnix + 70);
  dword_8070A64 = *(&camlUnix + 71);
  dword_8070A68 = *(&camlUnix + 72);
  dword_8070A6C = *(&camlUnix + 73);
  dword_8070A70 = *(&camlUnix + 74);
  dword_8070A74 = *(&camlUnix + 75);
  dword_8070A78 = *(&camlUnix + 76);
  dword_8070A7C = *(&camlUnix + 77);
  dword_8070A80 = *(&camlUnix + 78);
  dword_8070A84 = *(&camlUnix + 79);
  dword_8070A88 = *(&camlUnix + 80);
  dword_8070A8C = *(&camlUnix + 81);
  dword_8070A90 = *(&camlUnix + 82);
  dword_8070A94 = *(&camlUnix + 83);
  dword_8070A98 = *(&camlUnix + 84);
  dword_8070A9C = *(&camlUnix + 85);
  dword_8070AA0 = *(&camlUnix + 86);
  dword_8070AA4 = *(&camlUnix + 87);
  dword_8070AA8 = *(&camlUnix + 88);
  dword_8070AAC = *(&camlUnix + 89);
  dword_8070AB0 = *(&camlUnix + 90);
  dword_8070AB4 = *(&camlUnix + 91);
  dword_8070AB8 = *(&camlUnix + 92);
  dword_8070ABC = *(&camlUnix + 93);
  dword_8070AC0 = *(&camlUnix + 94);
  dword_8070AC4 = *(&camlUnix + 95);
  dword_8070AC8 = *(&camlUnix + 96);
  dword_8070ACC = *(&camlUnix + 97);
  dword_8070AD0 = *(&camlUnix + 98);
  dword_8070AD4 = *(&camlUnix + 99);
  dword_8070AD8 = *(&camlUnix + 100);
  dword_8070ADC = *(&camlUnix + 101);
  dword_8070AE0 = *(&camlUnix + 102);
  dword_8070AE4 = *(&camlUnix + 103);
  dword_8070AE8 = *(&camlUnix + 104);
  dword_8070AEC = *(&camlUnix + 105);
  dword_8070AF0 = *(&camlUnix + 106);
  dword_8070AF4 = *(&camlUnix + 107);
  dword_8070AF8 = *(&camlUnix + 108);
  dword_8070AFC = *(&camlUnix + 109);
  dword_8070B00 = *(&camlUnix + 110);
  dword_8070B04 = *(&camlUnix + 111);
  dword_8070B08 = *(&camlUnix + 112);
  dword_8070B0C = *(&camlUnix + 113);
  dword_8070B10 = *(&camlUnix + 114);
  dword_8070B14 = *(&camlUnix + 115);
  dword_8070B18 = *(&camlUnix + 116);
  dword_8070B1C = *(&camlUnix + 117);
  dword_8070B20 = *(&camlUnix + 118);
  dword_8070B24 = *(&camlUnix + 119);
  dword_8070B28 = *(&camlUnix + 120);
  dword_8070B2C = *(&camlUnix + 121);
  dword_8070B30 = *(&camlUnix + 122);
  dword_8070B34 = *(&camlUnix + 123);
  dword_8070B38 = *(&camlUnix + 124);
  dword_8070B3C = *(&camlUnix + 125);
  dword_8070B40 = *(&camlUnix + 126);
  dword_8070B44 = *(&camlUnix + 127);
  dword_8070B48 = *(&camlUnix + 128);
  dword_8070B4C = *(&camlUnix + 129);
  dword_8070B50 = *(&camlUnix + 130);
  dword_8070B54 = *(&camlUnix + 131);
  dword_8070B58 = *(&camlUnix + 132);
  dword_8070B5C = *(&camlUnix + 133);
  dword_8070B60 = *(&camlUnix + 134);
  dword_8070B64 = *(&camlUnix + 135);
  dword_8070B68 = *(&camlUnix + 136);
  dword_8070B6C = *(&camlUnix + 137);
  dword_8070B70 = *(&camlUnix + 138);
  dword_8070B74 = *(&camlUnix + 139);
  dword_8070B78 = *(&camlUnix + 140);
  dword_8070B7C = *(&camlUnix + 141);
  dword_8070B80 = *(&camlUnix + 142);
  dword_8070B84 = *(&camlUnix + 143);
  dword_8070B88 = *(&camlUnix + 144);
  dword_8070B8C = *(&camlUnix + 145);
  dword_8070B90 = *(&camlUnix + 146);
  dword_8070B94 = *(&camlUnix + 147);
  dword_8070B98 = *(&camlUnix + 148);
  dword_8070B9C = *(&camlUnix + 149);
  dword_8070BA0 = *(&camlUnix + 150);
  dword_8070BA4 = *(&camlUnix + 151);
  dword_8070BA8 = *(&camlUnix + 152);
  dword_8070BAC = *(&camlUnix + 153);
  dword_8070BB0 = *(&camlUnix + 154);
  return 1;
}
// 806E3D4: using guessed type int camlUnix;
// 8070948: using guessed type int camlUnixLabels;
// 807094C: using guessed type int dword_807094C;
// 8070950: using guessed type int dword_8070950;
// 8070954: using guessed type int dword_8070954;
// 8070958: using guessed type int dword_8070958;
// 807095C: using guessed type int dword_807095C;
// 8070960: using guessed type int dword_8070960;
// 8070964: using guessed type int dword_8070964;
// 8070968: using guessed type int dword_8070968;
// 807096C: using guessed type int dword_807096C;
// 8070970: using guessed type int dword_8070970;
// 8070974: using guessed type int dword_8070974;
// 8070978: using guessed type int dword_8070978;
// 807097C: using guessed type int dword_807097C;
// 8070980: using guessed type int dword_8070980;
// 8070984: using guessed type int dword_8070984;
// 8070988: using guessed type int dword_8070988;
// 807098C: using guessed type int dword_807098C;
// 8070990: using guessed type int dword_8070990;
// 8070994: using guessed type int dword_8070994;
// 8070998: using guessed type int dword_8070998;
// 807099C: using guessed type int dword_807099C;
// 80709A0: using guessed type int dword_80709A0;
// 80709A4: using guessed type int dword_80709A4;
// 80709A8: using guessed type int dword_80709A8;
// 80709AC: using guessed type int dword_80709AC;
// 80709B0: using guessed type int dword_80709B0;
// 80709B4: using guessed type int dword_80709B4;
// 80709B8: using guessed type int dword_80709B8;
// 80709BC: using guessed type int dword_80709BC;
// 80709C0: using guessed type int dword_80709C0;
// 80709C4: using guessed type int dword_80709C4;
// 80709C8: using guessed type int dword_80709C8;
// 80709CC: using guessed type int dword_80709CC;
// 80709D0: using guessed type int dword_80709D0;
// 80709D4: using guessed type int dword_80709D4;
// 80709D8: using guessed type int dword_80709D8;
// 80709DC: using guessed type int dword_80709DC;
// 80709E0: using guessed type int dword_80709E0;
// 80709E4: using guessed type int dword_80709E4;
// 80709E8: using guessed type int dword_80709E8;
// 80709EC: using guessed type int dword_80709EC;
// 80709F0: using guessed type int dword_80709F0;
// 80709F4: using guessed type int dword_80709F4;
// 80709F8: using guessed type int dword_80709F8;
// 80709FC: using guessed type int dword_80709FC;
// 8070A00: using guessed type int dword_8070A00;
// 8070A04: using guessed type int dword_8070A04;
// 8070A08: using guessed type int dword_8070A08;
// 8070A0C: using guessed type int dword_8070A0C;
// 8070A10: using guessed type int dword_8070A10;
// 8070A14: using guessed type int dword_8070A14;
// 8070A18: using guessed type int dword_8070A18;
// 8070A1C: using guessed type int dword_8070A1C;
// 8070A20: using guessed type int dword_8070A20;
// 8070A24: using guessed type int dword_8070A24;
// 8070A28: using guessed type int dword_8070A28;
// 8070A2C: using guessed type int dword_8070A2C;
// 8070A30: using guessed type int dword_8070A30;
// 8070A34: using guessed type int dword_8070A34;
// 8070A38: using guessed type int dword_8070A38;
// 8070A3C: using guessed type int dword_8070A3C;
// 8070A40: using guessed type int dword_8070A40;
// 8070A44: using guessed type int dword_8070A44;
// 8070A48: using guessed type int dword_8070A48;
// 8070A4C: using guessed type int dword_8070A4C;
// 8070A50: using guessed type int dword_8070A50;
// 8070A54: using guessed type int dword_8070A54;
// 8070A58: using guessed type int dword_8070A58;
// 8070A5C: using guessed type int dword_8070A5C;
// 8070A60: using guessed type int dword_8070A60;
// 8070A64: using guessed type int dword_8070A64;
// 8070A68: using guessed type int dword_8070A68;
// 8070A6C: using guessed type int dword_8070A6C;
// 8070A70: using guessed type int dword_8070A70;
// 8070A74: using guessed type int dword_8070A74;
// 8070A78: using guessed type int dword_8070A78;
// 8070A7C: using guessed type int dword_8070A7C;
// 8070A80: using guessed type int dword_8070A80;
// 8070A84: using guessed type int dword_8070A84;
// 8070A88: using guessed type int dword_8070A88;
// 8070A8C: using guessed type int dword_8070A8C;
// 8070A90: using guessed type int dword_8070A90;
// 8070A94: using guessed type int dword_8070A94;
// 8070A98: using guessed type int dword_8070A98;
// 8070A9C: using guessed type int dword_8070A9C;
// 8070AA0: using guessed type int dword_8070AA0;
// 8070AA4: using guessed type int dword_8070AA4;
// 8070AA8: using guessed type int dword_8070AA8;
// 8070AAC: using guessed type int dword_8070AAC;
// 8070AB0: using guessed type int dword_8070AB0;
// 8070AB4: using guessed type int dword_8070AB4;
// 8070AB8: using guessed type int dword_8070AB8;
// 8070ABC: using guessed type int dword_8070ABC;
// 8070AC0: using guessed type int dword_8070AC0;
// 8070AC4: using guessed type int dword_8070AC4;
// 8070AC8: using guessed type int dword_8070AC8;
// 8070ACC: using guessed type int dword_8070ACC;
// 8070AD0: using guessed type int dword_8070AD0;
// 8070AD4: using guessed type int dword_8070AD4;
// 8070AD8: using guessed type int dword_8070AD8;
// 8070ADC: using guessed type int dword_8070ADC;
// 8070AE0: using guessed type int dword_8070AE0;
// 8070AE4: using guessed type int dword_8070AE4;
// 8070AE8: using guessed type int dword_8070AE8;
// 8070AEC: using guessed type int dword_8070AEC;
// 8070AF0: using guessed type int dword_8070AF0;
// 8070AF4: using guessed type int dword_8070AF4;
// 8070AF8: using guessed type int dword_8070AF8;
// 8070AFC: using guessed type int dword_8070AFC;
// 8070B00: using guessed type int dword_8070B00;
// 8070B04: using guessed type int dword_8070B04;
// 8070B08: using guessed type int dword_8070B08;
// 8070B0C: using guessed type int dword_8070B0C;
// 8070B10: using guessed type int dword_8070B10;
// 8070B14: using guessed type int dword_8070B14;
// 8070B18: using guessed type int dword_8070B18;
// 8070B1C: using guessed type int dword_8070B1C;
// 8070B20: using guessed type int dword_8070B20;
// 8070B24: using guessed type int dword_8070B24;
// 8070B28: using guessed type int dword_8070B28;
// 8070B2C: using guessed type int dword_8070B2C;
// 8070B30: using guessed type int dword_8070B30;
// 8070B34: using guessed type int dword_8070B34;
// 8070B38: using guessed type int dword_8070B38;
// 8070B3C: using guessed type int dword_8070B3C;
// 8070B40: using guessed type int dword_8070B40;
// 8070B44: using guessed type int dword_8070B44;
// 8070B48: using guessed type int dword_8070B48;
// 8070B4C: using guessed type int dword_8070B4C;
// 8070B50: using guessed type int dword_8070B50;
// 8070B54: using guessed type int dword_8070B54;
// 8070B58: using guessed type int dword_8070B58;
// 8070B5C: using guessed type int dword_8070B5C;
// 8070B60: using guessed type int dword_8070B60;
// 8070B64: using guessed type int dword_8070B64;
// 8070B68: using guessed type int dword_8070B68;
// 8070B6C: using guessed type int dword_8070B6C;
// 8070B70: using guessed type int dword_8070B70;
// 8070B74: using guessed type int dword_8070B74;
// 8070B78: using guessed type int dword_8070B78;
// 8070B7C: using guessed type int dword_8070B7C;
// 8070B80: using guessed type int dword_8070B80;
// 8070B84: using guessed type int dword_8070B84;
// 8070B88: using guessed type int dword_8070B88;
// 8070B8C: using guessed type int dword_8070B8C;
// 8070B90: using guessed type int dword_8070B90;
// 8070B94: using guessed type int dword_8070B94;
// 8070B98: using guessed type int dword_8070B98;
// 8070B9C: using guessed type int dword_8070B9C;
// 8070BA0: using guessed type int dword_8070BA0;
// 8070BA4: using guessed type int dword_8070BA4;
// 8070BA8: using guessed type int dword_8070BA8;
// 8070BAC: using guessed type int dword_8070BAC;
// 8070BB0: using guessed type int dword_8070BB0;

//----- (0804ED90) --------------------------------------------------------
int __usercall camlUnixLabels__code_end@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v3; // edx
  int v4; // esi
  int v5; // ecx
  _DWORD *v6; // eax

  while ( 1 )
  {
    if ( a1 >= *(_DWORD *)(a2 + 12) )
      return camlPervasives___5e_1112(*(_DWORD *)(a2 + 8), (int)&camlPervasives__103);
    v3 = *(_DWORD *)(a2 + 8);
    v4 = 4 * (*(_DWORD *)(v3 - 4) >> 10) - 1;
    if ( v4 - (unsigned int)*(unsigned __int8 *)(v3 + v4) <= a1 >> 1 )
      break;
    v5 = 2 * *(unsigned __int8 *)(v3 + (a1 >> 1)) + 1;
    if ( v5 < 97 )
    {
      if ( 2 * *(unsigned __int8 *)(v3 + (a1 >> 1)) != 90 )
        return *(_DWORD *)(a2 + 8);
    }
    else if ( v5 >= 117 )
    {
      return *(_DWORD *)(a2 + 8);
    }
    a1 += 2;
  }
  v6 = (_DWORD *)caml_ml_array_bound_error();
  return camlPervasives__iter_1186(v6);
}

//----- (0804EE10) --------------------------------------------------------
int __usercall camlPervasives__iter_1186@<eax>(_DWORD *a1@<eax>)
{
  if ( a1 != (_DWORD *)1 )
  {
    sub_804EE30(*a1, a1[1]);
    JUMPOUT(0x804EE53);
  }
  return 1;
}
// 804EE25: control flows out of bounds to 804EE53

//----- (0804EE30) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_804EE30(char a1@<al>, int a2)
{
  int v2; // [esp-8h] [ebp-8h] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  caml_c_call((int (*)(void))caml_ml_flush, a1);
  caml_exception_pointer = v2;
  JUMPOUT(0x804EE13);
}
// 804EE53: positive sp value 4 has been found
// 804EE56: control flows out of bounds to 804EE13
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804EE70) --------------------------------------------------------
int __usercall camlPervasives__build_result_1243@<eax>(int result@<eax>, int *a2@<ecx>, int a3@<ebx>)
{
  int v3; // edi
  int *v4; // ebp
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // esi

  while ( 1 )
  {
    v3 = result;
    if ( a2 == (int *)1 )
      break;
    v4 = (int *)a2[1];
    v5 = *a2;
    v6 = 4 * (*(_DWORD *)(*a2 - 4) >> 10) - 1;
    v7 = *(unsigned __int8 *)(v5 + v6);
    v8 = 2 * (v6 - v7) + 1;
    caml_blit_string(v5, 1, v3, a3 - 2 * (v6 - v7), v8);
    a3 = a3 - v8 + 1;
    result = v3;
    a2 = v4;
  }
  return result;
}

//----- (0804EEC0) --------------------------------------------------------
int __usercall camlPervasives__scan_1249@<eax>(int *a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // eax
  int v4; // eax
  unsigned int v6; // eax
  _DWORD *v7; // eax
  int *v8; // ecx
  char v9; // dl
  _DWORD *v10; // eax
  int v11; // eax
  unsigned int v12; // eax
  int v13; // [esp+0h] [ebp-14h]
  int v14; // [esp+0h] [ebp-14h]
  int v15; // [esp+4h] [ebp-10h]
  int v16; // [esp+4h] [ebp-10h]
  int v17; // [esp+8h] [ebp-Ch]
  int *v18; // [esp+8h] [ebp-Ch]
  int *v19; // [esp+10h] [ebp-4h]

  while ( 1 )
  {
    v19 = a1;
    v15 = a2;
    v3 = caml_c_call((int (*)(void))caml_ml_input_scan_line, *(_DWORD *)(a2 + 12));
    if ( v3 == 1 )
    {
      if ( v19 != (int *)1 )
      {
        v4 = caml_c_call((int (*)(void))caml_create_string, a3);
        return camlPervasives__build_result_1243(v4, v19, a3);
      }
      while ( 1 )
      {
        v6 = caml_young_ptr - 8;
        caml_young_ptr = v6;
        if ( v6 >= caml_young_limit )
          break;
        caml_call_gc(v13);
      }
      v7 = (_DWORD *)(v6 + 4);
      *(v7 - 1) = 1024;
      *v7 = &caml_exn_End_of_file;
      v3 = caml_raise_exn((int)v7);
    }
    v17 = v3;
    if ( v3 > 1 )
      break;
    v13 = caml_c_call((int (*)(void))caml_create_string, 2 - v3);
    caml_c_call((int (*)(void))caml_ml_input, *(_DWORD *)(v15 + 12));
    while ( 1 )
    {
      v12 = caml_young_ptr - 12;
      caml_young_ptr = v12;
      if ( v12 >= caml_young_limit )
        break;
      caml_call_gc(v13);
    }
    a1 = (int *)(v12 + 4);
    *(a1 - 1) = 2048;
    *a1 = v13;
    a1[1] = (int)v19;
    a3 = a3 - v17 + 1;
    a2 = v15;
  }
  v14 = caml_c_call((int (*)(void))caml_create_string, v3 - 2);
  caml_c_call((int (*)(void))caml_ml_input, *(_DWORD *)(v15 + 12));
  caml_c_call((int (*)(void))caml_ml_input_char, *(_DWORD *)(v15 + 12));
  v8 = v19;
  if ( v19 == (int *)1 )
    return v14;
  v9 = a3 + v17 - 3;
  v16 = a3 + v17 - 3;
  while ( 1 )
  {
    v10 = (_DWORD *)(caml_young_ptr - 12);
    caml_young_ptr = (int)v10;
    if ( (unsigned int)v10 >= caml_young_limit )
      break;
    caml_call_gc(v14);
  }
  v18 = v10 + 1;
  *v10 = 2048;
  v10[1] = v14;
  v10[2] = v8;
  v11 = caml_c_call((int (*)(void))caml_create_string, v9);
  return camlPervasives__build_result_1243(v11, v18, v16);
}
// 804EFE7: variable 'v14' is possibly undefined
// 804EFE9: variable 'v8' is possibly undefined
// 804EFF2: variable 'v9' is possibly undefined
// 804F07D: variable 'v13' is possibly undefined
// 806DD10: using guessed type char *caml_exn_End_of_file;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804F0C0) --------------------------------------------------------
int __usercall camlPervasives__fun_1500@<eax>(int a1@<ebx>)
{
  (**(void (***)(void))(a1 + 8))();
  return (**(int (***)(void))(a1 + 12))();
}

//----- (0804F0F0) --------------------------------------------------------
int __usercall camlPervasives__fun_1392@<eax>(char a1@<al>)
{
  return caml_c_call(caml_ml_set_binary_mode, a1);
}

//----- (0804F100) --------------------------------------------------------
int __usercall camlPervasives__fun_1394@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_close_channel, a1);
}

//----- (0804F110) --------------------------------------------------------
int __usercall camlPervasives__fun_1396@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_channel_size, a1);
}

//----- (0804F120) --------------------------------------------------------
int __usercall camlPervasives__fun_1398@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_pos_in, a1);
}

//----- (0804F130) --------------------------------------------------------
int __usercall camlPervasives__fun_1400@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_seek_in, a1);
}

//----- (0804F140) --------------------------------------------------------
int __usercall camlPervasives__fun_1402@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_input_value, a1);
}

//----- (0804F150) --------------------------------------------------------
int __usercall camlPervasives__fun_1404@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_input_int, a1);
}

//----- (0804F160) --------------------------------------------------------
int __usercall camlPervasives__fun_1406@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_input_char, a1);
}

//----- (0804F170) --------------------------------------------------------
int __usercall camlPervasives__fun_1408@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_input_char, a1);
}

//----- (0804F180) --------------------------------------------------------
int __usercall camlPervasives__fun_1410@<eax>(char a1@<al>)
{
  return caml_c_call(caml_ml_set_binary_mode, a1);
}

//----- (0804F190) --------------------------------------------------------
int __usercall camlPervasives__fun_1412@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_channel_size, a1);
}

//----- (0804F1A0) --------------------------------------------------------
int __usercall camlPervasives__fun_1414@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_pos_out, a1);
}

//----- (0804F1B0) --------------------------------------------------------
int __usercall camlPervasives__fun_1416@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_seek_out, a1);
}

//----- (0804F1C0) --------------------------------------------------------
int __usercall camlPervasives__fun_1418@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_output_int, a1);
}

//----- (0804F1D0) --------------------------------------------------------
int __usercall camlPervasives__fun_1420@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_output_char, a1);
}

//----- (0804F1E0) --------------------------------------------------------
int __usercall camlPervasives__fun_1422@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_output_char, a1);
}

//----- (0804F1F0) --------------------------------------------------------
int __usercall camlPervasives__fun_1424@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_flush, a1);
}

//----- (0804F200) --------------------------------------------------------
#error "804F22F: call analysis failed (funcsize=13)"

//----- (0804F240) --------------------------------------------------------
#error "804F26F: call analysis failed (funcsize=13)"

//----- (0804F280) --------------------------------------------------------
int __usercall camlPervasives__min_1022@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int result; // eax

  if ( caml_c_call((int (*)(void))caml_lessequal, a1) == 1 )
    result = a2;
  else
    result = a1;
  return result;
}

//----- (0804F2C0) --------------------------------------------------------
int __usercall camlPervasives__max_1025@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int result; // eax

  if ( caml_c_call((int (*)(void))caml_greaterequal, a1) == 1 )
    result = a2;
  else
    result = a1;
  return result;
}

//----- (0804F300) --------------------------------------------------------
int __usercall camlPervasives__abs_1044@<eax>(int result@<eax>)
{
  if ( result < 1 )
    result = 2 - result;
  return result;
}

//----- (0804F320) --------------------------------------------------------
int __usercall camlPervasives__lnot_1049@<eax>(int a1@<eax>)
{
  return ~a1 | 1;
}

//----- (0804F330) --------------------------------------------------------
int __usercall camlPervasives___5e_1112@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // eax
  int v3; // ecx
  int v4; // ecx
  int v5; // ebx
  int v7; // [esp+0h] [ebp-10h]
  int v9; // [esp+8h] [ebp-8h]

  v2 = 4 * (*(_DWORD *)(a1 - 4) >> 10) - 1;
  v7 = 2 * (v2 - *(unsigned __int8 *)(a1 + v2)) + 1;
  v3 = 4 * (*(_DWORD *)(a2 - 4) >> 10) - 1;
  v4 = v3 - *(unsigned __int8 *)(a2 + v3);
  v9 = 2 * v4 + 1;
  v5 = caml_c_call((int (*)(void))caml_create_string, v7 + 2 * v4);
  caml_blit_string(a1, 1, v5, 1, v7);
  caml_blit_string(a2, 1, v5, v7, v9);
  return v5;
}
// 804F330: could not find valid save-restore pair for esi

//----- (0804F3C0) --------------------------------------------------------
int __usercall camlPervasives__char_of_int_1120@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  if ( result < 1 || result > 511 )
    camlPervasives__invalid_arg_1012(a3, a2);
  return result;
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804F3E0) --------------------------------------------------------
char *__usercall camlPervasives__string_of_bool_1127@<eax>(int a1@<eax>)
{
  char *result; // eax

  if ( a1 == 1 )
    result = camlPervasives__100;
  else
    result = camlPervasives__101;
  return result;
}

//----- (0804F400) --------------------------------------------------------
int __usercall camlPervasives__bool_of_string_1129@<eax>(_DWORD *a1@<eax>)
{
  int v2; // edx
  int v3; // ecx

  if ( caml_string_notequal(a1, camlPervasives__99) == 1 )
    return 1;
  if ( caml_string_notequal(a1, camlPervasives__98) != 1 )
    camlPervasives__invalid_arg_1012(v3, v2);
  return 3;
}
// 804F42D: variable 'v3' is possibly undefined
// 804F42D: variable 'v2' is possibly undefined
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804F460) --------------------------------------------------------
int camlPervasives__string_of_int_1130()
{
  return caml_c_call((int (*)(void))caml_format_int, (char)&camlPervasives__96);
}

//----- (0804F480) --------------------------------------------------------
#error "804F4D5: call analysis failed (funcsize=22)"

//----- (0804F4E0) --------------------------------------------------------
int camlPervasives__string_of_float_1140()
{
  caml_c_call((int (*)(void))caml_format_float, (char)camlPervasives__95);
  return camlPervasives__valid_float_lexem_1135();
}
// 804F480: using guessed type int camlPervasives__valid_float_lexem_1135(void);

//----- (0804F500) --------------------------------------------------------
_DWORD *__usercall camlPervasives___40_1143@<eax>(int *a1@<eax>, int a2@<ebx>)
{
  int v2; // ecx
  unsigned int v3; // eax
  _DWORD *result; // eax
  int v5; // [esp+0h] [ebp-4h]

  if ( a1 == (int *)1 )
    return (_DWORD *)a2;
  v5 = *a1;
  v2 = camlPervasives___40_1143();
  while ( 1 )
  {
    v3 = caml_young_ptr - 12;
    caml_young_ptr = v3;
    if ( v3 >= caml_young_limit )
      break;
    caml_call_gc(v5);
  }
  result = (_DWORD *)(v3 + 4);
  *(result - 1) = 2048;
  *result = v5;
  result[1] = v2;
  return result;
}
// 804F53B: variable 'v5' is possibly undefined
// 804F53D: variable 'v2' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804F560) --------------------------------------------------------
int __fastcall camlPervasives__open_out_gen_1175(char a1)
{
  char v1; // al

  v1 = caml_c_call((int (*)(void))caml_sys_open, a1);
  return caml_c_call((int (*)(void))caml_ml_open_descriptor_out, v1);
}

//----- (0804F580) --------------------------------------------------------
int __usercall camlPervasives__open_out_1179@<eax>(char a1@<al>)
{
  return camlPervasives__open_out_gen_1175(a1);
}

//----- (0804F5A0) --------------------------------------------------------
int __usercall camlPervasives__open_out_bin_1181@<eax>(char a1@<al>)
{
  return camlPervasives__open_out_gen_1175(a1);
}

//----- (0804F5C0) --------------------------------------------------------
int camlPervasives__flush_all_1185()
{
  _DWORD *v0; // eax

  v0 = (_DWORD *)caml_c_call(caml_ml_out_channels_list, 1);
  return camlPervasives__iter_1186(v0);
}

//----- (0804F5E0) --------------------------------------------------------
int __usercall camlPervasives__output_string_1191@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_output, a1);
}

//----- (0804F610) --------------------------------------------------------
int __usercall camlPervasives__output_1194@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // esi

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))caml_ml_output, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804F660) --------------------------------------------------------
int __usercall camlPervasives__output_value_1202@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_output_value, a1);
}

//----- (0804F680) --------------------------------------------------------
int __usercall camlPervasives__close_out_1209@<eax>(char a1@<al>)
{
  caml_c_call((int (*)(void))caml_ml_flush, a1);
  return caml_c_call((int (*)(void))caml_ml_close_channel, a1);
}

//----- (0804F6B0) --------------------------------------------------------
void __usercall camlPervasives__close_out_noerr_1211(char a1@<al>)
{
  sub_804F6C0(a1);
  JUMPOUT(0x804F6E3);
}
// 804F6BB: control flows out of bounds to 804F6E3

//----- (0804F6C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804F6C0@<eax>(char a1@<al>)
{
  int v2; // [esp-Ch] [ebp-Ch] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  caml_c_call((int (*)(void))caml_ml_flush, a1);
  caml_exception_pointer = v2;
  sub_804F700();
  return 1;
}
// 804F6F0: positive sp value 8 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804F700) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_804F700()
{
  int result; // eax
  int v1; // [esp-Ch] [ebp-Ch] BYREF
  char v2; // [esp-4h] [ebp-4h]

  v1 = caml_exception_pointer;
  caml_exception_pointer = (int)&v1;
  result = caml_c_call((int (*)(void))caml_ml_close_channel, v2);
  caml_exception_pointer = v1;
  return result;
}
// 804F72A: positive sp value 8 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804F730) --------------------------------------------------------
int __fastcall camlPervasives__open_in_gen_1214(char a1)
{
  char v1; // al

  v1 = caml_c_call((int (*)(void))caml_sys_open, a1);
  return caml_c_call((int (*)(void))caml_ml_open_descriptor_in, v1);
}

//----- (0804F750) --------------------------------------------------------
int __usercall camlPervasives__open_in_1218@<eax>(char a1@<al>)
{
  return camlPervasives__open_in_gen_1214(a1);
}

//----- (0804F770) --------------------------------------------------------
int __usercall camlPervasives__open_in_bin_1220@<eax>(char a1@<al>)
{
  return camlPervasives__open_in_gen_1214(a1);
}

//----- (0804F790) --------------------------------------------------------
int __usercall camlPervasives__input_1224@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // esi

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return caml_c_call((int (*)(void))caml_ml_input, a1);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804F7E0) --------------------------------------------------------
int __usercall camlPervasives__unsafe_really_input_1229@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax
  unsigned int v5; // eax
  _DWORD *v6; // eax
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+4h] [ebp-Ch]
  int v9; // [esp+8h] [ebp-8h]

  while ( a2 > 1 )
  {
    v7 = a2;
    v8 = a3;
    v9 = a1;
    v4 = caml_c_call((int (*)(void))caml_ml_input, a1);
    if ( v4 == 1 )
    {
      while ( 1 )
      {
        v5 = caml_young_ptr - 8;
        caml_young_ptr = v5;
        if ( v5 >= caml_young_limit )
          break;
        caml_call_gc(v7);
      }
      v6 = (_DWORD *)(v5 + 4);
      *(v6 - 1) = 1024;
      *v6 = &caml_exn_End_of_file;
      v4 = caml_raise_exn((int)v6);
    }
    a2 = v7 - v4 + 1;
    a3 = v8 + v4 - 1;
    a1 = v9;
  }
  return 1;
}
// 804F853: variable 'v7' is possibly undefined
// 806DD10: using guessed type char *caml_exn_End_of_file;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0804F880) --------------------------------------------------------
int __usercall camlPervasives__really_input_1235@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // esi

  if ( a3 < 1
    || a2 < 1
    || (v4 = 4 * (*(_DWORD *)(a4 - 4) >> 10) - 1, a3 > 2 * (v4 - *(unsigned __int8 *)(a4 + v4)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  return camlPervasives__unsafe_really_input_1229(a1, a2, a3);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (0804F8C0) --------------------------------------------------------
#error "804F90F: call analysis failed (funcsize=19)"

//----- (0804F920) --------------------------------------------------------
int __usercall camlPervasives__close_in_noerr_1263@<eax>(char a1@<al>)
{
  sub_804F930(a1);
  return 1;
}

//----- (0804F930) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_804F930@<eax>(char a1@<al>)
{
  int result; // eax
  int v2; // [esp-8h] [ebp-8h] BYREF

  v2 = caml_exception_pointer;
  caml_exception_pointer = (int)&v2;
  result = caml_c_call((int (*)(void))caml_ml_close_channel, a1);
  caml_exception_pointer = v2;
  return result;
}
// 804F953: positive sp value 4 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (0804F960) --------------------------------------------------------
int camlPervasives__print_char_1266()
{
  return caml_c_call((int (*)(void))caml_ml_output_char, dword_8070C1C);
}
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804F980) --------------------------------------------------------
int camlPervasives__print_string_1268()
{
  return camlPervasives__output_string_1191(dword_8070C1C);
}
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804F990) --------------------------------------------------------
int camlPervasives__print_int_1270()
{
  camlPervasives__string_of_int_1130();
  return camlPervasives__output_string_1191(dword_8070C1C);
}
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804F9B0) --------------------------------------------------------
int camlPervasives__print_float_1272()
{
  camlPervasives__string_of_float_1140();
  return camlPervasives__output_string_1191(dword_8070C1C);
}
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804F9D0) --------------------------------------------------------
int camlPervasives__print_endline_1274()
{
  camlPervasives__output_string_1191(dword_8070C1C);
  caml_c_call((int (*)(void))caml_ml_output_char, dword_8070C1C);
  return caml_c_call((int (*)(void))caml_ml_flush, dword_8070C1C);
}
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804FA10) --------------------------------------------------------
int camlPervasives__print_newline_1276()
{
  caml_c_call((int (*)(void))caml_ml_output_char, dword_8070C1C);
  return caml_c_call((int (*)(void))caml_ml_flush, dword_8070C1C);
}
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804FA40) --------------------------------------------------------
int camlPervasives__prerr_char_1277()
{
  return caml_c_call((int (*)(void))caml_ml_output_char, dword_8070C20);
}
// 8070C20: using guessed type int dword_8070C20;

//----- (0804FA60) --------------------------------------------------------
int camlPervasives__prerr_string_1279()
{
  return camlPervasives__output_string_1191(dword_8070C20);
}
// 8070C20: using guessed type int dword_8070C20;

//----- (0804FA70) --------------------------------------------------------
int camlPervasives__prerr_int_1281()
{
  camlPervasives__string_of_int_1130();
  return camlPervasives__output_string_1191(dword_8070C20);
}
// 8070C20: using guessed type int dword_8070C20;

//----- (0804FA90) --------------------------------------------------------
int camlPervasives__prerr_float_1283()
{
  camlPervasives__string_of_float_1140();
  return camlPervasives__output_string_1191(dword_8070C20);
}
// 8070C20: using guessed type int dword_8070C20;

//----- (0804FAB0) --------------------------------------------------------
int camlPervasives__prerr_endline_1285()
{
  camlPervasives__output_string_1191(dword_8070C20);
  caml_c_call((int (*)(void))caml_ml_output_char, dword_8070C20);
  return caml_c_call((int (*)(void))caml_ml_flush, dword_8070C20);
}
// 8070C20: using guessed type int dword_8070C20;

//----- (0804FAF0) --------------------------------------------------------
int camlPervasives__prerr_newline_1287()
{
  caml_c_call((int (*)(void))caml_ml_output_char, dword_8070C20);
  return caml_c_call((int (*)(void))caml_ml_flush, dword_8070C20);
}
// 8070C20: using guessed type int dword_8070C20;

//----- (0804FB20) --------------------------------------------------------
int camlPervasives__read_line_1288()
{
  caml_c_call((int (*)(void))caml_ml_flush, dword_8070C1C);
  return camlPervasives__input_line_1241();
}
// 804F8C0: using guessed type int camlPervasives__input_line_1241(void);
// 8070C18: using guessed type int dword_8070C18;
// 8070C1C: using guessed type int dword_8070C1C;

//----- (0804FB40) --------------------------------------------------------
int camlPervasives__read_int_1289()
{
  char v0; // al

  v0 = camlPervasives__read_line_1288();
  return caml_c_call((int (*)(void))caml_int_of_string, v0);
}

//----- (0804FB60) --------------------------------------------------------
int camlPervasives__read_float_1290()
{
  char v0; // al

  v0 = camlPervasives__read_line_1288();
  return caml_c_call((int (*)(void))caml_float_of_string, v0);
}

//----- (0804FB80) --------------------------------------------------------
int __usercall camlPervasives__fun_1495@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_channel_size_64, a1);
}

//----- (0804FB90) --------------------------------------------------------
int __usercall camlPervasives__fun_1493@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_pos_in_64, a1);
}

//----- (0804FBA0) --------------------------------------------------------
int __usercall camlPervasives__fun_1491@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_seek_in_64, a1);
}

//----- (0804FBB0) --------------------------------------------------------
int __usercall camlPervasives__fun_1489@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_channel_size_64, a1);
}

//----- (0804FBC0) --------------------------------------------------------
int __usercall camlPervasives__fun_1487@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_pos_out_64, a1);
}

//----- (0804FBD0) --------------------------------------------------------
int __usercall camlPervasives__fun_1485@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_ml_seek_out_64, a1);
}

//----- (0804FBE0) --------------------------------------------------------
int __usercall camlPervasives___5e_5e_1312@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // ebx

  v2 = camlPervasives___5e_1112((int)&camlPervasives__85, a2);
  return camlPervasives___5e_1112(a1, v2);
}

//----- (0804FC00) --------------------------------------------------------
int __usercall camlPervasives__string_of_format_1315@<eax>(int a1@<eax>)
{
  int v1; // eax
  int v2; // eax
  int v3; // ebx
  int v5; // [esp+0h] [ebp-8h]

  v1 = 4 * (*(_DWORD *)(a1 - 4) >> 10) - 1;
  v2 = v1 - *(unsigned __int8 *)(a1 + v1);
  v5 = 2 * v2 + 1;
  v3 = caml_c_call((int (*)(void))caml_create_string, 2 * v2 + 1);
  caml_blit_string(a1, 1, v3, 1, v5);
  return v3;
}

//----- (0804FC50) --------------------------------------------------------
#error "804FCA0: call analysis failed (funcsize=22)"

//----- (0804FCB0) --------------------------------------------------------
int camlPervasives__do_at_exit_1325()
{
  return (**(int (***)(void))dword_8070D08)();
}
// 8070D08: using guessed type int dword_8070D08;

//----- (0804FCC0) --------------------------------------------------------
int __usercall camlPervasives__exit_1326@<eax>(char a1@<al>)
{
  (**(void (***)(void))dword_8070D08)();
  return caml_c_call((int (*)(void))caml_sys_exit, a1);
}
// 8070D08: using guessed type int dword_8070D08;

//----- (0804FCF0) --------------------------------------------------------
#error "804FDAE: call analysis failed (funcsize=198)"

//----- (08050120) --------------------------------------------------------
int __usercall camlArray__code_begin@<eax>(int a1@<eax>, double *a2@<edx>, unsigned int a3@<ecx>, double *a4@<ebx>, _DWORD *a5@<edi>, unsigned int a6@<esi>)
{
  int v6; // eax
  unsigned int v7; // ebx
  _DWORD *v8; // ebx
  unsigned int v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // eax
  int v13; // eax
  unsigned int v14; // ebx
  unsigned int v15; // edx
  unsigned int v16; // eax
  int v17; // eax
  char v18; // [esp+0h] [ebp-20h]
  int v19; // [esp+4h] [ebp-1Ch]
  int v20; // [esp+8h] [ebp-18h]
  double *v21; // [esp+Ch] [ebp-14h]
  double *v22; // [esp+14h] [ebp-Ch]

  while ( 1 )
  {
    while ( 1 )
    {
      v19 = a1;
      v22 = a4;
      v20 = a3;
      v21 = a2;
      v18 = (char)a5;
      if ( caml_apply2(a5[3]) > 1 )
        break;
      v6 = a5[6];
      v7 = *(_DWORD *)(v6 - 4);
      if ( (unsigned __int8)v7 == 254 )
      {
        v8 = (_DWORD *)(v7 >> 10);
        if ( (unsigned int)v8 <= a6 )
          goto LABEL_38;
        *(double *)(v6 + 4 * a6 - 4) = *v22;
      }
      else
      {
        v8 = (_DWORD *)(v7 >> 9);
        if ( (unsigned int)v8 <= a6 )
          goto LABEL_39;
        caml_modify((unsigned int *)(v6 + 2 * a6 - 2), (unsigned int)v22);
      }
      v9 = v19 + 2;
      if ( v19 + 2 >= a5[7] )
        return camlArray__blit_120(a5[5], a6 + 2, a5[6], v20, a5[8] - v20 + 1);
      v8 = (_DWORD *)a5[4];
      v10 = *(v8 - 1);
      if ( (unsigned __int8)v10 == 254 )
      {
        if ( v10 >> 10 <= v9 )
          goto LABEL_36;
        while ( 1 )
        {
          v11 = caml_young_ptr - 12;
          caml_young_ptr = v11;
          if ( v11 >= caml_young_limit )
            break;
          caml_call_gc(v18);
        }
        *(_DWORD *)v11 = 2301;
        *(double *)(v11 + 4) = *(double *)&v8[v9 - 1];
        a4 = (double *)(v11 + 4);
      }
      else
      {
        if ( v10 >> 9 <= v9 )
          goto LABEL_37;
        a4 = *(double **)((char *)v8 + 2 * v9 - 2);
      }
      a6 += 2;
      a1 = v9;
      a3 = v20;
      a2 = v21;
    }
    v13 = a5[6];
    v14 = *(_DWORD *)(v13 - 4);
    if ( (unsigned __int8)v14 == 254 )
    {
      v8 = (_DWORD *)(v14 >> 10);
      if ( (unsigned int)v8 <= a6 )
        goto LABEL_34;
      *(double *)(v13 + 4 * a6 - 4) = *v21;
    }
    else
    {
      v8 = (_DWORD *)(v14 >> 9);
      if ( (unsigned int)v8 <= a6 )
        goto LABEL_35;
      caml_modify((unsigned int *)(v13 + 2 * a6 - 2), (unsigned int)v21);
    }
    a3 = v20 + 2;
    if ( v20 + 2 >= a5[8] )
      return camlArray__blit_120(a5[4], a6 + 2, a5[6], v19, a5[7] - v19 + 1);
    v8 = (_DWORD *)a5[5];
    v15 = *(v8 - 1);
    if ( (unsigned __int8)v15 == 254 )
      break;
    if ( v15 >> 9 <= a3 )
      goto LABEL_33;
    a2 = *(double **)((char *)v8 + 2 * a3 - 2);
LABEL_28:
    a6 += 2;
    a1 = v19;
    a4 = v22;
  }
  if ( v15 >> 10 > a3 )
  {
    while ( 1 )
    {
      v16 = caml_young_ptr - 12;
      caml_young_ptr = v16;
      if ( v16 >= caml_young_limit )
        break;
      caml_call_gc(v18);
    }
    a2 = (double *)(v16 + 4);
    *(_DWORD *)v16 = 2301;
    *(double *)(v16 + 4) = *(double *)&v8[a3 - 1];
    goto LABEL_28;
  }
  caml_ml_array_bound_error();
LABEL_33:
  caml_ml_array_bound_error();
LABEL_34:
  caml_ml_array_bound_error();
LABEL_35:
  caml_ml_array_bound_error();
LABEL_36:
  caml_ml_array_bound_error();
LABEL_37:
  caml_ml_array_bound_error();
LABEL_38:
  caml_ml_array_bound_error();
LABEL_39:
  v17 = caml_ml_array_bound_error();
  return camlArray__size_1065(v17, v8);
}
// 8050120: could not find valid save-restore pair for edi
// 805012D: variable 'a3' is possibly undefined
// 8050210: variable 'v9' is possibly undefined
// 805033F: variable 'v18' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08050380) --------------------------------------------------------
int __usercall camlArray__size_1065@<eax>(int result@<eax>, _DWORD *a2@<ebx>)
{
  _DWORD *v2; // ecx
  unsigned int v3; // ebx
  unsigned int v4; // ebx

  while ( a2 != (_DWORD *)1 )
  {
    v2 = (_DWORD *)a2[1];
    v3 = *(_DWORD *)(*a2 - 4);
    if ( (unsigned __int8)v3 == 254 )
      v4 = v3 >> 10;
    else
      v4 = v3 >> 9;
    result = (v4 | 1) + result - 1;
    a2 = v2;
  }
  return result;
}

//----- (080503D0) --------------------------------------------------------
int __usercall camlArray__fill_1070@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>)
{
  int v3; // edi
  int v4; // ebx
  unsigned int v5; // esi
  unsigned int v6; // esi
  int v7; // esi
  int v8; // ecx
  double *v9; // eax
  unsigned int v10; // eax
  int v11; // ebp
  int v12; // edx
  int v13; // eax
  unsigned int v14; // ebx
  unsigned int v15; // ebx
  int *v17; // [esp+0h] [ebp-14h]
  int v18; // [esp+4h] [ebp-10h]
  int v19; // [esp+8h] [ebp-Ch]

  while ( 1 )
  {
    v3 = a2;
    if ( a3 == (int *)1 )
      break;
    v19 = a1;
    v17 = (int *)a3[1];
    v18 = *a3;
    v4 = 1;
    v5 = *(_DWORD *)(v18 - 4);
    if ( (unsigned __int8)v5 == 254 )
      v6 = v5 >> 10;
    else
      v6 = v5 >> 9;
    v7 = (v6 | 1) - 2;
    if ( v7 >= 1 )
    {
      do
      {
        v8 = v18;
        if ( *(unsigned __int8 *)(v18 - 4) == 254 )
        {
          while ( 1 )
          {
            v10 = caml_young_ptr - 12;
            caml_young_ptr = v10;
            if ( v10 >= caml_young_limit )
              break;
            caml_call_gc((char)v17);
          }
          v9 = (double *)(v10 + 4);
          *((_DWORD *)v9 - 1) = 2301;
          *v9 = *(double *)(v8 + 4 * v4 - 4);
        }
        else
        {
          v9 = *(double **)(v18 + 2 * v4 - 2);
        }
        v11 = v19 + v4 - 1;
        v12 = *(_DWORD *)(v3 + 12);
        if ( *(unsigned __int8 *)(v12 - 4) == 254 )
          *(double *)(v12 + 4 * v11 - 4) = *v9;
        else
          caml_modify((unsigned int *)(v12 + 2 * v11 - 2), (unsigned int)v9);
        v13 = v4;
        v4 += 2;
      }
      while ( v13 != v7 );
    }
    v14 = *(_DWORD *)(v18 - 4);
    if ( (unsigned __int8)v14 == 254 )
      v15 = v14 >> 10;
    else
      v15 = v14 >> 9;
    a1 = (v15 | 1) + v19 - 1;
    a3 = v17;
    a2 = v3;
  }
  return 1;
}
// 8050463: variable 'v8' is possibly undefined
// 80504CD: variable 'v17' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08050500) --------------------------------------------------------
int (__cdecl **__usercall camlArray__find_init_1077@<eax>(int *a1@<eax>))(int, int)
{
  int *v1; // ebx
  double *v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // edx
  unsigned int v5; // eax
  double *v6; // eax
  char v8; // [esp+0h] [ebp-8h]

  do
  {
    v1 = a1;
    if ( a1 == (int *)1 )
      return camlArray__36;
    a1 = (int *)a1[1];
    v2 = (double *)*v1;
    v3 = *(_DWORD *)(*v1 - 4);
    if ( (unsigned __int8)v3 == 254 )
      v4 = v3 >> 10;
    else
      v4 = v3 >> 9;
  }
  while ( (int)(v4 | 1) <= 1 );
  if ( *((unsigned __int8 *)v2 - 4) == 254 )
  {
    while ( 1 )
    {
      v5 = caml_young_ptr - 12;
      caml_young_ptr = v5;
      if ( v5 >= caml_young_limit )
        break;
      caml_call_gc(v8);
    }
    v6 = (double *)(v5 + 4);
    *((_DWORD *)v6 - 1) = 2301;
    *v6 = *v2;
  }
  return (int (__cdecl **)(int, int))camlArray__concat_aux_1062(v1);
}
// 805056F: variable 'v2' is possibly undefined
// 8050599: variable 'v8' is possibly undefined
// 8071C3C: using guessed type int (__cdecl *camlArray__36[2])(int, int);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080505A0) --------------------------------------------------------
_DWORD *__usercall camlArray__tolist_1123@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<ebx>)
{
  int v3; // edx
  int v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  char v10; // [esp+0h] [ebp-8h]

  while ( 1 )
  {
    v3 = a1;
    if ( a1 < 1 )
      break;
    v5 = *(_DWORD *)(a2 + 12);
    if ( *(unsigned __int8 *)(v5 - 4) == 254 )
    {
      while ( 1 )
      {
        v7 = caml_young_ptr - 12;
        caml_young_ptr = v7;
        if ( v7 >= caml_young_limit )
          break;
        caml_call_gc(v10);
      }
      v6 = v7 + 4;
      *(_DWORD *)v7 = 2301;
      *(double *)(v7 + 4) = *(double *)(v5 + 4 * v3 - 4);
    }
    else
    {
      v6 = *(_DWORD *)(v5 + 2 * a1 - 2);
    }
    while ( 1 )
    {
      v8 = (_DWORD *)(caml_young_ptr - 12);
      caml_young_ptr = (int)v8;
      if ( (unsigned int)v8 >= caml_young_limit )
        break;
      caml_call_gc(v10);
    }
    v9 = v8 + 1;
    *v8 = 2048;
    v8[1] = v6;
    v8[2] = a3;
    a1 = v3 - 2;
    a3 = v9;
  }
  return a3;
}
// 80505B0: variable 'a2' is possibly undefined
// 80505EF: variable 'v3' is possibly undefined
// 8050622: variable 'v10' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08050630) --------------------------------------------------------
int __usercall camlArray__fill_1135@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // edi
  int v4; // esi
  int v5; // ebp
  double *v6; // ecx
  int v7; // ebx

  while ( 1 )
  {
    v3 = a1;
    v4 = a2;
    if ( a3 == 1 )
      break;
    v5 = *(_DWORD *)(a3 + 4);
    v6 = *(double **)a3;
    v7 = *(_DWORD *)(v4 + 12);
    if ( *(unsigned __int8 *)(v7 - 4) == 254 )
      *(double *)(v7 + 4 * a1 - 4) = *v6;
    else
      caml_modify((unsigned int *)(v7 + 2 * a1 - 2), (unsigned int)v6);
    a1 = v3 + 2;
    a3 = v5;
    a2 = v4;
  }
  return *(_DWORD *)(a2 + 12);
}

//----- (08050690) --------------------------------------------------------
unsigned int __usercall camlArray__maxson_182@<eax>(signed int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  unsigned int v4; // esi
  _DWORD *v5; // eax
  unsigned int v6; // edx
  int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // eax
  double *v14; // eax
  unsigned int v15; // ecx
  int v16; // esi
  int v17; // edx
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // edx
  int v21; // ecx
  unsigned int v22; // eax
  unsigned int v23; // eax
  double *v24; // eax
  unsigned int result; // eax
  int v26; // edx
  unsigned int v27; // edi
  unsigned int v28; // eax
  double *v29; // eax
  int v30; // edx
  unsigned int v31; // edi
  unsigned int v32; // eax
  double *v33; // eax
  unsigned int v34; // eax
  _DWORD *v35; // eax
  signed int v36; // eax
  int v37; // edx
  double *v38; // ecx
  char v39; // [esp+0h] [ebp-14h]
  int v40; // [esp+0h] [ebp-14h]
  signed int v41; // [esp+0h] [ebp-14h]
  unsigned int *v42; // [esp+4h] [ebp-10h]
  int v44; // [esp+8h] [ebp-Ch]

  v4 = 3 * a3;
  v44 = 3 * a3;
  while ( 1 )
  {
    v5 = (_DWORD *)(caml_young_ptr - 8);
    caml_young_ptr = (int)v5;
    if ( (unsigned int)v5 >= caml_young_limit )
      break;
    caml_call_gc(v39);
  }
  *v5 = 1024;
  v5[1] = v4;
  if ( (int)(v4 + 4) < a1 )
  {
    v42 = v5 + 1;
    v40 = a2;
    v6 = v4 + 2;
    v7 = *(_DWORD *)(a2 + 16);
    v8 = *(_DWORD *)(v7 - 4);
    v9 = (unsigned __int8)v8;
    if ( (unsigned __int8)v8 == 254 )
    {
      if ( v8 >> 10 <= v6 )
      {
LABEL_69:
        caml_ml_array_bound_error();
        goto LABEL_70;
      }
      while ( 1 )
      {
        v10 = caml_young_ptr - 12;
        caml_young_ptr = v10;
        if ( v10 >= caml_young_limit )
          break;
        caml_call_gc(v40);
      }
      v9 = v10 + 4;
      *(_DWORD *)v10 = 2301;
      *(double *)(v10 + 4) = *(double *)(v7 + 4 * v6 - 4);
    }
    else
    {
      if ( v8 >> 9 <= v6 )
      {
LABEL_70:
        v36 = caml_ml_array_bound_error();
        return camlArray__trickledown_187(v36, v37, v38, v9);
      }
      v9 = *(_DWORD *)(v7 + 2 * v6 - 2);
    }
    v11 = *(_DWORD *)(a2 + 16);
    v12 = *(_DWORD *)(v11 - 4);
    if ( (unsigned __int8)v12 == 254 )
    {
      if ( v12 >> 10 <= v4 )
      {
LABEL_67:
        caml_ml_array_bound_error();
        goto LABEL_68;
      }
      while ( 1 )
      {
        v13 = caml_young_ptr - 12;
        caml_young_ptr = v13;
        if ( v13 >= caml_young_limit )
          break;
        caml_call_gc(v40);
      }
      v14 = (double *)(v13 + 4);
      *((_DWORD *)v14 - 1) = 2301;
      *v14 = *(double *)(v11 + 4 * v4 - 4);
    }
    else if ( v12 >> 9 <= v4 )
    {
LABEL_68:
      caml_ml_array_bound_error();
      goto LABEL_69;
    }
    if ( caml_apply2(*(_DWORD *)(a2 + 12)) < 1 )
      *v42 = v44 + 2;
    v15 = v44 + 4;
    v16 = v40;
    v17 = *(_DWORD *)(v40 + 16);
    v18 = *(_DWORD *)(v17 - 4);
    v9 = (unsigned __int8)v18;
    if ( (unsigned __int8)v18 == 254 )
    {
      if ( v18 >> 10 <= v15 )
      {
LABEL_65:
        caml_ml_array_bound_error();
        goto LABEL_66;
      }
      while ( 1 )
      {
        v19 = caml_young_ptr - 12;
        caml_young_ptr = v19;
        if ( v19 >= caml_young_limit )
          break;
        caml_call_gc(v40);
      }
      v9 = v19 + 4;
      *(_DWORD *)v19 = 2301;
      *(double *)(v19 + 4) = *(double *)(v17 + 4 * v15 - 4);
    }
    else
    {
      if ( v18 >> 9 <= v15 )
      {
LABEL_66:
        caml_ml_array_bound_error();
        goto LABEL_67;
      }
      v9 = *(_DWORD *)(v17 + 2 * v15 - 2);
    }
    v20 = *v42;
    v21 = *(_DWORD *)(v16 + 16);
    v22 = *(_DWORD *)(v21 - 4);
    if ( (unsigned __int8)v22 != 254 )
    {
      if ( v22 >> 9 > v20 )
      {
LABEL_30:
        if ( caml_apply2(*(_DWORD *)(v16 + 12)) < 1 )
          *v42 = v44 + 4;
        return *v42;
      }
      goto LABEL_64;
    }
    if ( v22 >> 10 > v20 )
    {
      while ( 1 )
      {
        v23 = caml_young_ptr - 12;
        caml_young_ptr = v23;
        if ( v23 >= caml_young_limit )
          break;
        caml_call_gc(v40);
      }
      v24 = (double *)(v23 + 4);
      *((_DWORD *)v24 - 1) = 2301;
      *v24 = *(double *)(v21 + 4 * v20 - 4);
      goto LABEL_30;
    }
LABEL_63:
    caml_ml_array_bound_error();
LABEL_64:
    caml_ml_array_bound_error();
    goto LABEL_65;
  }
  v41 = a1;
  if ( (int)(v4 + 2) < a1 )
  {
    v9 = v4 + 2;
    v26 = *(_DWORD *)(a2 + 16);
    v27 = *(_DWORD *)(v26 - 4);
    if ( (unsigned __int8)v27 == 254 )
    {
      if ( v27 >> 10 <= v9 )
      {
LABEL_61:
        caml_ml_array_bound_error();
        goto LABEL_62;
      }
      while ( 1 )
      {
        v28 = caml_young_ptr - 12;
        caml_young_ptr = v28;
        if ( v28 >= caml_young_limit )
          break;
        caml_call_gc(v41);
      }
      v29 = (double *)(v28 + 4);
      *((_DWORD *)v29 - 1) = 2301;
      *v29 = *(double *)(v26 + 4 * v9 - 4);
      v9 = (unsigned int)v29;
    }
    else
    {
      if ( v27 >> 9 <= v9 )
      {
LABEL_62:
        caml_ml_array_bound_error();
        goto LABEL_63;
      }
      v9 = *(_DWORD *)(v26 + 2 * v9 - 2);
    }
    v30 = *(_DWORD *)(a2 + 16);
    v31 = *(_DWORD *)(v30 - 4);
    if ( (unsigned __int8)v31 == 254 )
    {
      if ( v31 >> 10 > v4 )
      {
        while ( 1 )
        {
          v32 = caml_young_ptr - 12;
          caml_young_ptr = v32;
          if ( v32 >= caml_young_limit )
            break;
          caml_call_gc(v41);
        }
        v33 = (double *)(v32 + 4);
        *((_DWORD *)v33 - 1) = 2301;
        *v33 = *(double *)(v30 + 4 * v4 - 4);
LABEL_46:
        if ( caml_apply2(*(_DWORD *)(a2 + 12)) < 1 )
          return v44 + 2;
        goto LABEL_48;
      }
      caml_ml_array_bound_error();
    }
    else if ( v31 >> 9 > v4 )
    {
      goto LABEL_46;
    }
    caml_ml_array_bound_error();
    goto LABEL_61;
  }
LABEL_48:
  result = v44;
  if ( v44 >= v41 )
  {
    while ( 1 )
    {
      v34 = caml_young_ptr - 12;
      caml_young_ptr = v34;
      if ( v34 >= caml_young_limit )
      {
        v35 = (_DWORD *)(v34 + 4);
        *(v35 - 1) = 2048;
        *v35 = dword_8071A60;
        v35[1] = a3;
        caml_raise_exn((int)v35);
      }
      caml_call_gc(v41);
    }
  }
  return result;
}
// 80506D0: variable 'a1' is possibly undefined
// 80506DA: variable 'a2' is possibly undefined
// 805073E: variable 'v6' is possibly undefined
// 805079E: variable 'v11' is possibly undefined
// 80507C5: variable 'v40' is possibly undefined
// 805081E: variable 'v17' is possibly undefined
// 805081E: variable 'v15' is possibly undefined
// 805088E: variable 'v21' is possibly undefined
// 805088E: variable 'v20' is possibly undefined
// 8050930: variable 'v26' is possibly undefined
// 805098C: variable 'v30' is possibly undefined
// 80509B9: variable 'v41' is possibly undefined
// 8050A36: variable 'v39' is possibly undefined
// 8050A7D: variable 'v37' is possibly undefined
// 8050A7D: variable 'v38' is possibly undefined
// 8071A60: using guessed type int dword_8071A60;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08050A80) --------------------------------------------------------
int __usercall camlArray__trickledown_187@<eax>(signed int a1@<eax>, int a2@<edx>, double *a3@<ecx>, unsigned int a4@<ebx>)
{
  int v4; // edx
  int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // eax
  double *v8; // eax
  int v9; // esi
  int v10; // ecx
  unsigned int v11; // eax
  double *v12; // edx
  unsigned int v13; // eax
  int v14; // eax
  unsigned int v15; // edi
  int v16; // eax
  unsigned int v17; // ebx
  signed int v19; // eax
  int v20; // edx
  double *v21; // ecx
  int v22; // [esp+0h] [ebp-1Ch]
  signed int v23; // [esp+4h] [ebp-18h]
  double *v24; // [esp+8h] [ebp-14h]
  unsigned int v25; // [esp+Ch] [ebp-10h]

  while ( 1 )
  {
    v23 = a1;
    v25 = a4;
    v24 = a3;
    v22 = a2;
    a4 = camlArray__maxson_182(a1, *(_DWORD *)(a2 + 20), a4);
    v4 = v22;
    v5 = *(_DWORD *)(v22 + 16);
    v6 = *(_DWORD *)(v5 - 4);
    if ( (unsigned __int8)v6 == 254 )
    {
      if ( v6 >> 10 <= a4 )
        goto LABEL_34;
      while ( 1 )
      {
        v7 = caml_young_ptr - 12;
        caml_young_ptr = v7;
        if ( v7 >= caml_young_limit )
          break;
        caml_call_gc(v22);
      }
      v8 = (double *)(v7 + 4);
      *((_DWORD *)v8 - 1) = 2301;
      *v8 = *(double *)(v5 + 4 * a4 - 4);
    }
    else if ( v6 >> 9 <= a4 )
    {
      goto LABEL_35;
    }
    if ( caml_apply2(*(_DWORD *)(v4 + 12)) <= 1 )
      break;
    v9 = v22;
    v10 = *(_DWORD *)(v22 + 16);
    v11 = *(_DWORD *)(v10 - 4);
    if ( (unsigned __int8)v11 == 254 )
    {
      if ( v11 >> 10 <= a4 )
        goto LABEL_32;
      while ( 1 )
      {
        v13 = caml_young_ptr - 12;
        caml_young_ptr = v13;
        if ( v13 >= caml_young_limit )
          break;
        caml_call_gc(v22);
      }
      v12 = (double *)(v13 + 4);
      *(_DWORD *)v13 = 2301;
      *(double *)(v13 + 4) = *(double *)(v10 + 4 * a4 - 4);
    }
    else
    {
      if ( v11 >> 9 <= a4 )
        goto LABEL_33;
      v12 = *(double **)(v10 + 2 * a4 - 2);
    }
    v14 = *(_DWORD *)(v9 + 16);
    v15 = *(_DWORD *)(v14 - 4);
    if ( (unsigned __int8)v15 == 254 )
    {
      if ( v15 >> 10 <= v25 )
        goto LABEL_30;
      *(double *)(v14 + 4 * v25 - 4) = *v12;
    }
    else
    {
      if ( v15 >> 9 <= v25 )
        goto LABEL_31;
      caml_modify((unsigned int *)(v14 + 2 * v25 - 2), (unsigned int)v12);
    }
    a1 = v23;
    a3 = v24;
    a2 = v9;
  }
  v16 = *(_DWORD *)(v22 + 16);
  v17 = *(_DWORD *)(v16 - 4);
  if ( (unsigned __int8)v17 == 254 )
  {
    a4 = v17 >> 10;
    if ( a4 > v25 )
    {
      *(double *)(v16 + 4 * v25 - 4) = *v24;
      return 1;
    }
    caml_ml_array_bound_error();
  }
  else
  {
    a4 = v17 >> 9;
    if ( a4 > v25 )
    {
      caml_modify((unsigned int *)(v16 + 2 * v25 - 2), (unsigned int)v24);
      return 1;
    }
  }
  caml_ml_array_bound_error();
LABEL_30:
  caml_ml_array_bound_error();
LABEL_31:
  caml_ml_array_bound_error();
LABEL_32:
  caml_ml_array_bound_error();
LABEL_33:
  caml_ml_array_bound_error();
LABEL_34:
  caml_ml_array_bound_error();
LABEL_35:
  v19 = caml_ml_array_bound_error();
  return camlArray__trickle_1165(v19, v20, v21, a4);
}
// 8050AFE: variable 'v5' is possibly undefined
// 8050B04: variable 'v4' is possibly undefined
// 8050B19: variable 'v22' is possibly undefined
// 8050B82: variable 'v10' is possibly undefined
// 8050C8B: variable 'v20' is possibly undefined
// 8050C8B: variable 'v21' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08050C90) --------------------------------------------------------
int __usercall camlArray__trickle_1165@<eax>(signed int a1@<eax>, int a2@<edx>, double *a3@<ecx>, unsigned int a4@<ebx>)
{
  unsigned int *v4; // eax
  unsigned int v5; // ebx
  unsigned int v6; // ebx
  int v7; // eax
  unsigned int v8; // ecx
  int result; // eax
  int v10; // eax
  int v11; // edx
  double *v12; // ecx
  signed int v13; // eax
  int v14; // ecx

  v4 = (unsigned int *)sub_8050D20(a1, a2, a3, a4);
  v5 = *v4;
  if ( *v4 == dword_8071A60 )
  {
    v6 = v4[1];
    v7 = *(_DWORD *)(a2 + 12);
    v8 = *(_DWORD *)(v7 - 4);
    if ( (unsigned __int8)v8 == 254 )
    {
      if ( v8 >> 10 > v6 )
      {
        *(double *)(v7 + 4 * v6 - 4) = *a3;
        return 1;
      }
      caml_ml_array_bound_error();
    }
    else if ( v8 >> 9 > v6 )
    {
      caml_modify((unsigned int *)(v7 + 2 * v6 - 2), (unsigned int)a3);
      return 1;
    }
    v13 = caml_ml_array_bound_error();
    result = camlArray__bubbledown_1170(v13, v14, v6);
  }
  else
  {
    v10 = caml_raise_exn((int)v4);
    result = sub_8050D20(v10, v11, v12, v5);
  }
  return result;
}
// 8050D1A: variable 'v11' is possibly undefined
// 8050D1A: variable 'v12' is possibly undefined
// 8050D4D: variable 'v14' is possibly undefined
// 8071A60: using guessed type int dword_8071A60;

//----- (08050D20) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_8050D20@<eax>(signed int a1@<eax>, int a2@<edx>, double *a3@<ecx>, unsigned int a4@<ebx>)
{
  int result; // eax
  int v5; // [esp-18h] [ebp-18h] BYREF

  v5 = caml_exception_pointer;
  caml_exception_pointer = (int)&v5;
  result = camlArray__trickledown_187(a1, *(_DWORD *)(a2 + 16), a3, a4);
  caml_exception_pointer = v5;
  return result;
}
// 8050D40: positive sp value 14 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (08050D50) --------------------------------------------------------
int __usercall camlArray__bubbledown_1170@<eax>(signed int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>)
{
  int v3; // esi
  int v4; // ecx
  unsigned int v5; // eax
  double *v6; // edx
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // edi
  signed int v10; // eax
  int v11; // ecx
  int v13; // [esp+0h] [ebp-14h]
  signed int v14; // [esp+4h] [ebp-10h]
  unsigned int v15; // [esp+8h] [ebp-Ch]

  while ( 1 )
  {
    v14 = a1;
    v15 = a3;
    v13 = a2;
    a3 = camlArray__maxson_182(a1, *(_DWORD *)(a2 + 16), a3);
    v3 = v13;
    v4 = *(_DWORD *)(v13 + 12);
    v5 = *(_DWORD *)(v4 - 4);
    if ( (unsigned __int8)v5 == 254 )
    {
      if ( v5 >> 10 <= a3 )
        goto LABEL_16;
      while ( 1 )
      {
        v7 = caml_young_ptr - 12;
        caml_young_ptr = v7;
        if ( v7 >= caml_young_limit )
          break;
        caml_call_gc(v13);
      }
      v6 = (double *)(v7 + 4);
      *(_DWORD *)v7 = 2301;
      *(double *)(v7 + 4) = *(double *)(v4 + 4 * a3 - 4);
    }
    else
    {
      if ( v5 >> 9 <= a3 )
        goto LABEL_17;
      v6 = *(double **)(v4 + 2 * a3 - 2);
    }
    v8 = *(_DWORD *)(v3 + 12);
    v9 = *(_DWORD *)(v8 - 4);
    if ( (unsigned __int8)v9 == 254 )
      break;
    if ( v9 >> 9 <= v15 )
      goto LABEL_15;
    caml_modify((unsigned int *)(v8 + 2 * v15 - 2), (unsigned int)v6);
LABEL_12:
    a1 = v14;
    a2 = v3;
  }
  if ( v9 >> 10 > v15 )
  {
    *(double *)(v8 + 4 * v15 - 4) = *v6;
    goto LABEL_12;
  }
  caml_ml_array_bound_error();
LABEL_15:
  caml_ml_array_bound_error();
LABEL_16:
  caml_ml_array_bound_error();
LABEL_17:
  v10 = caml_ml_array_bound_error();
  return camlArray__bubble_1174(v10, v11, a3);
}
// 8050D50: could not find valid save-restore pair for esi
// 8050DCA: variable 'v4' is possibly undefined
// 8050E2C: variable 'v13' is possibly undefined
// 8050E4B: variable 'v11' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08050E50) --------------------------------------------------------
int __usercall camlArray__bubble_1174@<eax>(signed int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>)
{
  unsigned int *v3; // eax
  unsigned int v4; // ebx
  int v6; // eax
  int v7; // ecx

  v3 = (unsigned int *)sub_8050E80(a1, a2, a3);
  v4 = *v3;
  if ( *v3 == dword_8071A60 )
    return v3[1];
  v6 = caml_raise_exn((int)v3);
  return sub_8050E80(v6, v7, v4);
}
// 8050E7A: variable 'v7' is possibly undefined
// 8071A60: using guessed type int dword_8071A60;

//----- (08050E80) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_8050E80@<eax>(signed int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>)
{
  int result; // eax
  int v4; // [esp-8h] [ebp-8h] BYREF

  v4 = caml_exception_pointer;
  caml_exception_pointer = (int)&v4;
  result = camlArray__bubbledown_1170(a1, *(_DWORD *)(a2 + 12), a3);
  caml_exception_pointer = v4;
  return result;
}
// 8050E9D: positive sp value 4 has been found
// 8074740: using guessed type int caml_exception_pointer;

//----- (08050EA0) --------------------------------------------------------
int __usercall camlArray__trickleup_205@<eax>(int a1@<eax>, int a2@<ecx>, double *a3@<ebx>)
{
  int v3; // esi
  int v4; // edi
  int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // eax
  _DWORD *v8; // eax
  int v9; // edx
  unsigned int v10; // eax
  int v11; // esi
  unsigned int v12; // eax
  double *v13; // eax
  unsigned int v14; // eax
  double *v15; // ecx
  unsigned int v16; // eax
  int v17; // eax
  unsigned int v18; // edx
  unsigned int *v19; // ecx
  int v21; // eax
  unsigned int v22; // ebx
  unsigned int v23; // eax
  unsigned int v24; // edx
  int v25; // ecx
  int v26; // [esp+0h] [ebp-18h]
  double *v27; // [esp+4h] [ebp-14h]
  unsigned int v28; // [esp+8h] [ebp-10h]
  unsigned int v29; // [esp+Ch] [ebp-Ch]

  while ( 1 )
  {
    v3 = a1;
    v4 = a2;
    v5 = ((a1 - 2) >> 1) / 3;
    v6 = 2 * v5 + 1;
    if ( v3 == v6 )
    {
      while ( 1 )
      {
        v7 = caml_young_ptr - 12;
        caml_young_ptr = v7;
        if ( v7 >= caml_young_limit )
          break;
        caml_call_gc(v26);
      }
      v8 = (_DWORD *)(v7 + 4);
      *(v8 - 1) = 2048;
      *v8 = &caml_exn_Assert_failure;
      v8[1] = &camlArray__35;
      caml_raise_exn((int)v8);
    }
    else
    {
      v29 = 2 * v5 + 1;
      v26 = v4;
      v27 = a3;
      v28 = v3;
    }
    v9 = *(_DWORD *)(v4 + 16);
    v10 = *(_DWORD *)(v9 - 4);
    v11 = (unsigned __int8)v10;
    if ( (unsigned __int8)v10 == 254 )
    {
      if ( v10 >> 10 <= v6 )
        goto LABEL_48;
      while ( 1 )
      {
        v12 = caml_young_ptr - 12;
        caml_young_ptr = v12;
        if ( v12 >= caml_young_limit )
          break;
        caml_call_gc(v26);
      }
      v13 = (double *)(v12 + 4);
      *((_DWORD *)v13 - 1) = 2301;
      *v13 = *(double *)(v9 + 4 * v6 - 4);
    }
    else if ( v10 >> 9 <= v6 )
    {
      goto LABEL_49;
    }
    if ( caml_apply2(*(_DWORD *)(v4 + 12)) >= 1 )
    {
      v21 = *(_DWORD *)(v26 + 16);
      v22 = *(_DWORD *)(v21 - 4);
      if ( (unsigned __int8)v22 == 254 )
      {
        a3 = (double *)(v22 >> 10);
        if ( (unsigned int)a3 > v28 )
        {
          *(double *)(v21 + 4 * v28 - 4) = *v27;
          return 1;
        }
        caml_ml_array_bound_error();
      }
      else
      {
        a3 = (double *)(v22 >> 9);
        if ( (unsigned int)a3 > v28 )
        {
          caml_modify((unsigned int *)(v21 + 2 * v28 - 2), (unsigned int)v27);
          return 1;
        }
      }
      caml_ml_array_bound_error();
      goto LABEL_42;
    }
    v4 = v26;
    a3 = *(double **)(v26 + 16);
    v14 = *((_DWORD *)a3 - 1);
    if ( (unsigned __int8)v14 == 254 )
    {
      v11 = v29;
      if ( v14 >> 10 <= v29 )
        goto LABEL_46;
      while ( 1 )
      {
        v16 = caml_young_ptr - 12;
        caml_young_ptr = v16;
        if ( v16 >= caml_young_limit )
          break;
        caml_call_gc(v26);
      }
      v15 = (double *)(v16 + 4);
      *(_DWORD *)v16 = 2301;
      *(double *)(v16 + 4) = *(double *)((char *)a3 + 4 * v29 - 4);
    }
    else
    {
      v11 = v29;
      if ( v14 >> 9 <= v29 )
        goto LABEL_47;
      v15 = *(double **)((char *)a3 + 2 * v29 - 2);
    }
    v17 = *(_DWORD *)(v4 + 16);
    v18 = *(_DWORD *)(v17 - 4);
    if ( (unsigned __int8)v18 == 254 )
    {
      a3 = (double *)v28;
      if ( v18 >> 10 <= v28 )
        goto LABEL_44;
      *(double *)(v17 + 4 * v28 - 4) = *v15;
    }
    else
    {
      a3 = (double *)v28;
      if ( v18 >> 9 <= v28 )
        goto LABEL_45;
      caml_modify((unsigned int *)(v17 + 2 * v28 - 2), (unsigned int)v15);
    }
    if ( v11 <= 1 )
      break;
    a1 = v11;
    a3 = v27;
    a2 = v4;
  }
  v19 = *(unsigned int **)(v4 + 16);
  a3 = (double *)*(v19 - 1);
  if ( (unsigned __int8)a3 != 254 )
  {
    if ( (unsigned int)a3 >> 9 > 1 )
    {
      caml_modify(v19, (unsigned int)v27);
      return 1;
    }
    goto LABEL_43;
  }
  if ( (unsigned int)a3 >> 10 > 1 )
  {
    *(double *)v19 = *v27;
    return 1;
  }
LABEL_42:
  caml_ml_array_bound_error();
LABEL_43:
  caml_ml_array_bound_error();
LABEL_44:
  caml_ml_array_bound_error();
LABEL_45:
  caml_ml_array_bound_error();
LABEL_46:
  caml_ml_array_bound_error();
LABEL_47:
  caml_ml_array_bound_error();
LABEL_48:
  caml_ml_array_bound_error();
LABEL_49:
  v23 = caml_ml_array_bound_error();
  return camlArray__merge_1191(v23, v24, v25, (int)a3, v4, v11);
}
// 8050F2B: variable 'v6' is possibly undefined
// 8050F6E: variable 'v9' is possibly undefined
// 8050F85: variable 'v26' is possibly undefined
// 8050FA1: variable 'v29' is possibly undefined
// 8051011: variable 'v28' is possibly undefined
// 805104C: variable 'v27' is possibly undefined
// 805116F: variable 'v24' is possibly undefined
// 805116F: variable 'v25' is possibly undefined
// 806DDE4: using guessed type char *caml_exn_Assert_failure;
// 8071C1C: using guessed type char *camlArray__35;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08051170) --------------------------------------------------------
int __usercall camlArray__merge_1191@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<edi>, int a6@<esi>)
{
  int v6; // ebp
  unsigned int v8; // edx
  int v9; // esi
  _DWORD *v10; // eax
  _DWORD *v11; // edi
  int v12; // ebx
  unsigned int v13; // eax
  double *v14; // edx
  unsigned int v15; // eax
  unsigned int v16; // eax
  double *v17; // ebx
  unsigned int v18; // eax
  int v20; // eax
  int v21; // edx
  int v22; // ecx
  char v23; // [esp+0h] [ebp-1Ch]
  unsigned int v26; // [esp+Ch] [ebp-10h]

  v23 = a1;
  v26 = caml_extra_params;
  v6 = dword_8074580;
  v8 = a1 + a4 - 1;
  v9 = a2 + a6 - 1;
  while ( 1 )
  {
    v10 = (_DWORD *)(caml_young_ptr - 40);
    caml_young_ptr = (int)v10;
    if ( (unsigned int)v10 >= caml_young_limit )
      break;
    caml_call_gc(v23);
  }
  v11 = v10 + 1;
  *v10 = 9463;
  v10[1] = caml_curry5;
  v10[2] = 11;
  v10[3] = camlArray__code_begin;
  v10[4] = *(_DWORD *)(v6 + 12);
  v10[5] = *(_DWORD *)(v6 + 16);
  v12 = a3;
  v10[6] = a3;
  v10[7] = a5;
  v10[8] = v8;
  v10[9] = v9;
  v13 = *(_DWORD *)(a3 - 4);
  if ( (unsigned __int8)v13 == 254 )
  {
    if ( v13 >> 10 <= a2 )
    {
LABEL_21:
      caml_ml_array_bound_error();
      goto LABEL_22;
    }
    while ( 1 )
    {
      v15 = caml_young_ptr - 12;
      caml_young_ptr = v15;
      if ( v15 >= caml_young_limit )
        break;
      caml_call_gc(v23);
    }
    v14 = (double *)(v15 + 4);
    *(_DWORD *)v15 = 2301;
    *(double *)(v15 + 4) = *(double *)(a3 + 4 * a2 - 4);
LABEL_9:
    v9 = *(_DWORD *)(v6 + 16);
    v16 = *(_DWORD *)(v9 - 4);
    v12 = (unsigned __int8)v16;
    if ( (unsigned __int8)v16 == 254 )
    {
      if ( v16 >> 10 > a1 )
      {
        while ( 1 )
        {
          v18 = caml_young_ptr - 12;
          caml_young_ptr = v18;
          if ( v18 >= caml_young_limit )
            break;
          caml_call_gc(v23);
        }
        v17 = (double *)(v18 + 4);
        *(_DWORD *)v18 = 2301;
        *(double *)(v18 + 4) = *(double *)(v9 + 4 * a1 - 4);
        return camlArray__code_begin(a1, v14, a2, v17, v11, v26);
      }
      caml_ml_array_bound_error();
    }
    else if ( v16 >> 9 > a1 )
    {
      v17 = *(double **)(v9 + 2 * a1 - 2);
      return camlArray__code_begin(a1, v14, a2, v17, v11, v26);
    }
    caml_ml_array_bound_error();
    goto LABEL_21;
  }
  if ( v13 >> 9 > a2 )
  {
    v14 = *(double **)(a3 + 2 * a2 - 2);
    goto LABEL_9;
  }
LABEL_22:
  v20 = caml_ml_array_bound_error();
  return camlArray__isortto_236(v20, v21, v22, v12, v9);
}
// 80511F1: variable 'v8' is possibly undefined
// 8051285: variable 'a1' is possibly undefined
// 80512C9: variable 'v14' is possibly undefined
// 80512CE: variable 'v23' is possibly undefined
// 80512FE: variable 'v21' is possibly undefined
// 80512FE: variable 'v22' is possibly undefined
// 804ADD0: using guessed type _DWORD caml_curry5();
// 807457C: using guessed type int caml_extra_params;
// 8074580: using guessed type int dword_8074580;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08051300) --------------------------------------------------------
int __usercall camlArray__isortto_236@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<esi>)
{
  int v5; // edi
  int v6; // edx
  unsigned int v7; // eax
  int v8; // ecx
  unsigned int v9; // eax
  _DWORD *v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // eax
  double *v14; // eax
  unsigned int v15; // ecx
  unsigned int v16; // eax
  double *v17; // edx
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // ecx
  int v25; // eax
  int v26; // edx
  int v27; // ecx
  unsigned int v29; // [esp+4h] [ebp-24h]
  double *v30; // [esp+4h] [ebp-24h]
  unsigned int v31; // [esp+8h] [ebp-20h]
  unsigned int *v32; // [esp+8h] [ebp-20h]
  int v33; // [esp+Ch] [ebp-1Ch]
  int v34; // [esp+10h] [ebp-18h]
  int v36; // [esp+18h] [ebp-10h]
  int v37; // [esp+1Ch] [ebp-Ch]

  v5 = 1;
  v6 = a2 - 2;
  if ( v6 < 1 )
    return 1;
  v34 = v6;
  v33 = 1;
  v36 = a5;
  v37 = a4;
  while ( 2 )
  {
    v7 = a1 + v5 - 1;
    v29 = v7;
    v8 = *(_DWORD *)(v36 + 16);
    v31 = *(_DWORD *)(v8 - 4);
    if ( (unsigned __int8)v31 == 254 )
    {
      if ( v31 >> 10 > v7 )
      {
        while ( 1 )
        {
          v9 = caml_young_ptr - 12;
          caml_young_ptr = v9;
          if ( v9 >= caml_young_limit )
            break;
          caml_call_gc(a1);
        }
        *(_DWORD *)v9 = 2301;
        *(double *)(v9 + 4) = *(double *)(v8 + 4 * v29 - 4);
        v30 = (double *)(v9 + 4);
        goto LABEL_9;
      }
LABEL_50:
      caml_ml_array_bound_error();
    }
    else if ( v31 >> 9 > v7 )
    {
      v30 = *(double **)(v8 + 2 * v7 - 2);
LABEL_9:
      while ( 1 )
      {
        v10 = (_DWORD *)(caml_young_ptr - 8);
        caml_young_ptr = (int)v10;
        if ( (unsigned int)v10 >= caml_young_limit )
          break;
        caml_call_gc(a1);
      }
      a5 = (int)(v10 + 1);
      v32 = v10 + 1;
      *v10 = 1024;
      v10[1] = a3 + v5 - 3;
      while ( *(_DWORD *)a5 >= a3 )
      {
        v11 = *(_DWORD *)a5;
        v12 = *(_DWORD *)(a4 - 4);
        if ( (unsigned __int8)v12 == 254 )
        {
          if ( v12 >> 10 <= v11 )
            goto LABEL_48;
          while ( 1 )
          {
            v13 = caml_young_ptr - 12;
            caml_young_ptr = v13;
            if ( v13 >= caml_young_limit )
              break;
            caml_call_gc(a1);
          }
          v14 = (double *)(v13 + 4);
          *((_DWORD *)v14 - 1) = 2301;
          *v14 = *(double *)(a4 + 4 * v11 - 4);
        }
        else if ( v12 >> 9 <= v11 )
        {
          goto LABEL_49;
        }
        if ( caml_apply2(*(_DWORD *)(v36 + 12)) <= 1 )
          break;
        a5 = (int)v32;
        v15 = *v32;
        a4 = v37;
        v16 = *(_DWORD *)(v37 - 4);
        if ( (unsigned __int8)v16 == 254 )
        {
          if ( v16 >> 10 <= v15 )
            goto LABEL_46;
          while ( 1 )
          {
            v18 = caml_young_ptr - 12;
            caml_young_ptr = v18;
            if ( v18 >= caml_young_limit )
              break;
            caml_call_gc(a1);
          }
          v17 = (double *)(v18 + 4);
          *(_DWORD *)v18 = 2301;
          *(double *)(v18 + 4) = *(double *)(v37 + 4 * v15 - 4);
        }
        else
        {
          if ( v16 >> 9 <= v15 )
            goto LABEL_47;
          v17 = *(double **)(v37 + 2 * v15 - 2);
        }
        v19 = *v32 + 2;
        v20 = *(_DWORD *)(v37 - 4);
        if ( (unsigned __int8)v20 == 254 )
        {
          if ( v20 >> 10 <= v19 )
            goto LABEL_44;
          *(double *)(v37 + 4 * v19 - 4) = *v17;
        }
        else
        {
          if ( v20 >> 9 <= v19 )
            goto LABEL_45;
          caml_modify((unsigned int *)(v37 + 2 * v19 - 2), (unsigned int)v17);
        }
        *v32 -= 2;
      }
      v21 = *v32 + 2;
      a4 = v37;
      v22 = *(_DWORD *)(v37 - 4);
      if ( (unsigned __int8)v22 == 254 )
      {
        if ( v22 >> 10 > v21 )
        {
          *(double *)(v37 + 4 * v21 - 4) = *v30;
LABEL_36:
          v23 = v33;
          v5 = v33 + 2;
          v33 += 2;
          if ( v23 != v34 )
            continue;
          return 1;
        }
        caml_ml_array_bound_error();
      }
      else if ( v22 >> 9 > v21 )
      {
        caml_modify((unsigned int *)(v37 + 2 * v21 - 2), (unsigned int)v30);
        goto LABEL_36;
      }
      caml_ml_array_bound_error();
LABEL_44:
      caml_ml_array_bound_error();
LABEL_45:
      caml_ml_array_bound_error();
LABEL_46:
      caml_ml_array_bound_error();
LABEL_47:
      caml_ml_array_bound_error();
LABEL_48:
      caml_ml_array_bound_error();
LABEL_49:
      caml_ml_array_bound_error();
      goto LABEL_50;
    }
    break;
  }
  v25 = caml_ml_array_bound_error();
  return camlArray__sortto_1217(v25, v26, v27, a4, a5);
}
// 805132D: variable 'a1' is possibly undefined
// 80513A6: variable 'v8' is possibly undefined
// 805144E: variable 'v11' is possibly undefined
// 80514CE: variable 'v15' is possibly undefined
// 80515FE: variable 'v26' is possibly undefined
// 80515FE: variable 'v27' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08051600) --------------------------------------------------------
int __usercall camlArray__sortto_1217@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<esi>)
{
  int v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+4h] [ebp-14h]
  int v9; // [esp+Ch] [ebp-Ch]

  if ( a2 <= 11 )
    return camlArray__isortto_236(a1, a2, a3, a4, *(_DWORD *)(a5 + 20));
  v7 = 2 * ((a2 >> 1) / 2) + 1;
  v9 = a2 - 2 * ((a2 >> 1) / 2);
  camlArray__sortto_1217(a3 + 2 * ((a2 >> 1) / 2), v9);
  camlArray__sortto_1217(a1 + v9 - 1, v7);
  v6 = *(_DWORD *)(a5 + 16);
  caml_extra_params = a3;
  dword_8074580 = v6;
  return camlArray__merge_1191(a1 + v9 - 1, a3 + v7 - 1, a4, v7, a4, v9);
}
// 8051600: could not find valid save-restore pair for ebp
// 8051600: could not find valid save-restore pair for edi
// 807457C: using guessed type int caml_extra_params;
// 8074580: using guessed type int dword_8074580;

//----- (080516C0) --------------------------------------------------------
void *__usercall camlArray__init_1037@<eax>(int a1@<eax>, void (**a2)(void)@<ebx>)
{
  int v3; // eax
  int v4; // ebx
  double *v5; // eax
  int v6; // esi
  int v8; // [esp+0h] [ebp-18h]
  int v10; // [esp+8h] [ebp-10h]
  int v11; // [esp+Ch] [ebp-Ch]

  if ( a1 == 1 )
    return &camlArray__34;
  (*a2)();
  v3 = caml_c_call((int (*)(void))caml_make_vect, a1);
  v4 = v3;
  if ( a1 - 2 >= 3 )
  {
    v10 = a1 - 2;
    v11 = 3;
    v8 = v3;
    do
    {
      v5 = (double *)((int (*)(void))*a2)();
      v4 = v8;
      v6 = v11;
      if ( *(unsigned __int8 *)(v8 - 4) == 254 )
        *(double *)(v8 + 4 * v11 - 4) = *v5;
      else
        caml_modify((unsigned int *)(v8 + 2 * v11 - 2), (unsigned int)v5);
      v11 += 2;
    }
    while ( v6 != v10 );
  }
  return (void *)v4;
}

//----- (08051780) --------------------------------------------------------
int __usercall camlArray__make_matrix_1042@<eax>(int a1@<eax>, char a2@<bl>)
{
  int v2; // eax
  int v3; // ebx
  int v4; // eax
  int v5; // esi
  int v8; // [esp+0h] [ebp-14h]
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]

  v2 = caml_c_call((int (*)(void))caml_make_vect, a1);
  v3 = v2;
  if ( a1 - 2 >= 1 )
  {
    v11 = a1 - 2;
    v8 = 1;
    v10 = v2;
    do
    {
      v4 = caml_c_call((int (*)(void))caml_make_vect, a2);
      v5 = v8;
      v3 = v10;
      caml_modify((unsigned int *)(v10 + 2 * v8 - 2), v4);
      v8 += 2;
    }
    while ( v5 != v11 );
  }
  return v3;
}

//----- (08051800) --------------------------------------------------------
void *__usercall camlArray__copy_1049@<eax>(double *a1@<eax>)
{
  double *v1; // ebx
  unsigned int v2; // ecx
  unsigned int v3; // ecx
  int v4; // ecx
  unsigned int v6; // eax
  double *v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  double *v11; // ecx
  double *v12; // edx
  unsigned int v13; // eax
  int v14; // eax
  int v15; // [esp+0h] [ebp-10h]

  v1 = a1;
  v2 = *((_DWORD *)a1 - 1);
  if ( (unsigned __int8)v2 == 254 )
    v3 = v2 >> 10;
  else
    v3 = v2 >> 9;
  v4 = v3 | 1;
  if ( v4 == 1 )
    return &camlArray__32;
  v15 = v4;
  if ( *((unsigned __int8 *)a1 - 4) == 254 )
  {
    while ( 1 )
    {
      v6 = caml_young_ptr - 12;
      caml_young_ptr = v6;
      if ( v6 >= caml_young_limit )
        break;
      caml_call_gc(v15);
    }
    v7 = (double *)(v6 + 4);
    *((_DWORD *)v7 - 1) = 2301;
    *v7 = *v1;
  }
  v8 = caml_c_call((int (*)(void))caml_make_vect, v4);
  v9 = 3;
  v10 = v15 - 2;
  if ( v15 - 2 >= 3 )
  {
    do
    {
      v11 = a1;
      if ( *((unsigned __int8 *)a1 - 4) == 254 )
      {
        while ( 1 )
        {
          v13 = caml_young_ptr - 12;
          caml_young_ptr = v13;
          if ( v13 >= caml_young_limit )
            break;
          caml_call_gc(v15);
        }
        v12 = (double *)(v13 + 4);
        *(_DWORD *)v13 = 2301;
        *(double *)(v13 + 4) = *(double *)((char *)v11 + 4 * v9 - 4);
      }
      else
      {
        v12 = *(double **)((char *)a1 + 2 * v9 - 2);
      }
      if ( *(unsigned __int8 *)(v8 - 4) == 254 )
        *(double *)(v8 + 4 * v9 - 4) = *v12;
      else
        caml_modify((unsigned int *)(v8 + 2 * v9 - 2), (unsigned int)v12);
      v14 = v9;
      v9 += 2;
    }
    while ( v14 != v10 );
  }
  return (void *)v8;
}
// 805188E: variable 'v4' is possibly undefined
// 80518A0: variable 'v15' is possibly undefined
// 80518DF: variable 'v11' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08051930) --------------------------------------------------------
void *__usercall camlArray__append_82@<eax>(double *a1@<eax>, double *a2@<ebx>)
{
  unsigned int v2; // edx
  unsigned int v3; // edx
  int v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  int v7; // ecx
  unsigned int v9; // eax
  int v10; // esi
  int v11; // ebx
  double *v12; // ecx
  double *v13; // edx
  unsigned int v14; // eax
  int v15; // eax
  int v16; // ebx
  double *v17; // ecx
  double *v18; // edx
  unsigned int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // [esp+0h] [ebp-18h]
  int v23; // [esp+0h] [ebp-18h]
  double *v24; // [esp+4h] [ebp-14h]
  int v25; // [esp+8h] [ebp-10h]
  double *v26; // [esp+Ch] [ebp-Ch]

  v2 = *((_DWORD *)a1 - 1);
  if ( (unsigned __int8)v2 == 254 )
    v3 = v2 >> 10;
  else
    v3 = v2 >> 9;
  v4 = v3 | 1;
  v5 = *((_DWORD *)a2 - 1);
  if ( (unsigned __int8)v5 == 254 )
    v6 = v5 >> 10;
  else
    v6 = v5 >> 9;
  v7 = v6 | 1;
  if ( v4 == 1 )
  {
    if ( v7 == 1 )
      return &camlArray__31;
    v22 = v7;
    v25 = 1;
    v24 = a2;
    v26 = a1;
  }
  else
  {
    v22 = v7;
    v25 = v4;
    v24 = a2;
    v26 = a1;
  }
  if ( v4 > 1 )
    a2 = a1;
  if ( *((unsigned __int8 *)a2 - 4) == 254 )
  {
    while ( 1 )
    {
      v9 = caml_young_ptr - 12;
      caml_young_ptr = v9;
      if ( v9 >= caml_young_limit )
        break;
      caml_call_gc(v22);
    }
    *(_DWORD *)v9 = 2301;
    *(double *)(v9 + 4) = *a2;
  }
  v10 = caml_c_call((int (*)(void))caml_make_vect, v4 + v7 - 1);
  v11 = 1;
  if ( v25 - 2 >= 1 )
  {
    do
    {
      v12 = v26;
      if ( *((unsigned __int8 *)v26 - 4) == 254 )
      {
        while ( 1 )
        {
          v14 = caml_young_ptr - 12;
          caml_young_ptr = v14;
          if ( v14 >= caml_young_limit )
            break;
          caml_call_gc(v22);
        }
        v13 = (double *)(v14 + 4);
        *(_DWORD *)v14 = 2301;
        *(double *)(v14 + 4) = *(double *)((char *)v12 + 4 * v11 - 4);
      }
      else
      {
        v13 = *(double **)((char *)v26 + 2 * v11 - 2);
      }
      if ( *(unsigned __int8 *)(v10 - 4) == 254 )
        *(double *)(v10 + 4 * v11 - 4) = *v13;
      else
        caml_modify((unsigned int *)(v10 + 2 * v11 - 2), (unsigned int)v13);
      v15 = v11;
      v11 += 2;
    }
    while ( v15 != v25 - 2 );
  }
  v16 = 1;
  if ( v22 - 2 >= 1 )
  {
    v23 = v22 - 2;
    do
    {
      v17 = v24;
      if ( *((unsigned __int8 *)v24 - 4) == 254 )
      {
        while ( 1 )
        {
          v19 = caml_young_ptr - 12;
          caml_young_ptr = v19;
          if ( v19 >= caml_young_limit )
            break;
          caml_call_gc(v23);
        }
        v18 = (double *)(v19 + 4);
        *(_DWORD *)v19 = 2301;
        *(double *)(v19 + 4) = *(double *)((char *)v17 + 4 * v16 - 4);
      }
      else
      {
        v18 = *(double **)((char *)v24 + 2 * v16 - 2);
      }
      v20 = v16 + v25 - 1;
      if ( *(unsigned __int8 *)(v10 - 4) == 254 )
        *(double *)(v10 + 4 * v20 - 4) = *v18;
      else
        caml_modify((unsigned int *)(v10 + 2 * v20 - 2), (unsigned int)v18);
      v21 = v16;
      v16 += 2;
    }
    while ( v21 != v23 );
  }
  return (void *)v10;
}
// 8051A08: variable 'v4' is possibly undefined
// 8051A08: variable 'v7' is possibly undefined
// 8051A73: variable 'v12' is possibly undefined
// 8051ABB: variable 'v22' is possibly undefined
// 8051AFF: variable 'v17' is possibly undefined
// 8051B40: variable 'v23' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08051B70) --------------------------------------------------------
int __usercall camlArray__concat_aux_1062@<eax>(int *a1@<ebx>)
{
  char v1; // al
  int v2; // ebx
  _DWORD *v3; // eax
  int i; // [esp+0h] [ebp-8h]

  v1 = camlArray__size_1065(1, a1);
  v2 = caml_c_call((int (*)(void))caml_make_vect, v1);
  for ( i = v2; ; caml_call_gc(i) )
  {
    v3 = (_DWORD *)(caml_young_ptr - 20);
    caml_young_ptr = (int)v3;
    if ( (unsigned int)v3 >= caml_young_limit )
      break;
  }
  *v3 = 4343;
  v3[1] = caml_curry2;
  v3[2] = 5;
  v3[3] = camlArray__fill_1070;
  v3[4] = v2;
  camlArray__fill_1070(1, (int)(v3 + 1), a1);
  return i;
}
// 8051B70: could not find valid save-restore pair for ebx
// 8051BE4: variable 'i' is possibly undefined
// 804B070: using guessed type _DWORD caml_curry2();
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08051C00) --------------------------------------------------------
int (__cdecl **__usercall camlArray__concat_1075@<eax>(int *a1@<eax>))(int, int)
{
  return camlArray__find_init_1077(a1);
}

//----- (08051C10) --------------------------------------------------------
void *__usercall camlArray__sub_1081@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  unsigned int v4; // esi
  unsigned int v5; // eax
  unsigned int v7; // eax
  double *v8; // eax
  int v9; // eax
  int v10; // esi
  int v11; // ebx
  int v12; // edx
  int v13; // ecx
  double *v14; // ecx
  unsigned int v15; // eax
  double *v16; // eax
  int v17; // ecx
  int v19; // [esp+0h] [ebp-18h]
  int v21; // [esp+8h] [ebp-10h]
  int v22; // [esp+Ch] [ebp-Ch]

  if ( a3 < 1
    || a2 < 1
    || ((v4 = *(_DWORD *)(a1 - 4), (unsigned __int8)v4 == 254) ? (v5 = v4 >> 10) : (v5 = v4 >> 9),
        a3 > (int)((v5 | 1) - a2 + 1)) )
  {
    camlPervasives__invalid_arg_1012(a2, a1);
  }
  if ( a2 == 1 )
    return &camlArray__28;
  v21 = a1;
  if ( *(unsigned __int8 *)(a1 - 4) == 254 )
  {
    while ( 1 )
    {
      v7 = caml_young_ptr - 12;
      caml_young_ptr = v7;
      if ( v7 >= caml_young_limit )
        break;
      caml_call_gc(a2);
    }
    v8 = (double *)(v7 + 4);
    *((_DWORD *)v8 - 1) = 2301;
    *v8 = *(double *)(a1 + 4 * a3 - 4);
  }
  v9 = caml_c_call((int (*)(void))caml_make_vect, a2);
  v10 = v9;
  v11 = 3;
  if ( a2 - 2 >= 3 )
  {
    v22 = a2 - 2;
    v19 = v9;
    do
    {
      v12 = a3 + v11 - 1;
      v13 = v21;
      if ( *(unsigned __int8 *)(v21 - 4) == 254 )
      {
        while ( 1 )
        {
          v15 = caml_young_ptr - 12;
          caml_young_ptr = v15;
          if ( v15 >= caml_young_limit )
            break;
          caml_call_gc(v19);
        }
        v16 = (double *)(v15 + 4);
        *((_DWORD *)v16 - 1) = 2301;
        *v16 = *(double *)(v13 + 4 * v12 - 4);
        v14 = v16;
      }
      else
      {
        v14 = *(double **)(v21 + 2 * v12 - 2);
      }
      v10 = v19;
      if ( *(unsigned __int8 *)(v19 - 4) == 254 )
        *(double *)(v19 + 4 * v11 - 4) = *v14;
      else
        caml_modify((unsigned int *)(v19 + 2 * v11 - 2), (unsigned int)v14);
      v17 = v11;
      v11 += 2;
    }
    while ( v17 != v22 );
  }
  return (void *)v10;
}
// 8051CB3: variable 'a1' is possibly undefined
// 8051CC0: variable 'a2' is possibly undefined
// 8051D2F: variable 'v13' is possibly undefined
// 8051D2F: variable 'v12' is possibly undefined
// 8051D37: variable 'v19' is possibly undefined
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08051DC0) --------------------------------------------------------
int __usercall camlArray__fill_1087@<eax>(int a1@<eax>, double *a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  double *v5; // edi
  unsigned int v6; // eax
  int v7; // ebp
  int v8; // ebx
  int v9; // ecx

  v5 = a2;
  if ( a4 < 1
    || a3 < 1
    || ((a2 = *(double **)(a1 - 4), (unsigned __int8)a2 == 254) ? (v6 = (unsigned int)a2 >> 10) : (v6 = (unsigned int)a2 >> 9),
        a4 > (int)((v6 | 1) - a3 + 1)) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  v7 = a4;
  v8 = a4 + a3 - 3;
  if ( v7 <= v8 )
  {
    do
    {
      if ( *(unsigned __int8 *)(a1 - 4) == 254 )
        *(double *)(a1 + 4 * v7 - 4) = *v5;
      else
        caml_modify((unsigned int *)(a1 + 2 * v7 - 2), (unsigned int)v5);
      v9 = v7;
      v7 += 2;
    }
    while ( v9 != v8 );
  }
  return 1;
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (08051E60) --------------------------------------------------------
int __usercall camlArray__blit_120@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, int a5@<esi>)
{
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // esi
  int v10; // ebx
  double *v11; // ebx
  unsigned int v12; // eax
  double *v13; // eax
  int v14; // eax
  int v15; // ebx
  int result; // eax
  int v17; // esi
  int v18; // ebx
  double *v19; // ebx
  unsigned int v20; // eax
  int v21; // eax
  int v22; // ebx
  char v23; // [esp+0h] [ebp-18h]
  int v24; // [esp+0h] [ebp-18h]
  int v25; // [esp+4h] [ebp-14h]
  unsigned int v27; // [esp+8h] [ebp-10h]
  int v28; // [esp+Ch] [ebp-Ch]

  v27 = a3;
  if ( a5 < 1
    || a4 < 1
    || ((a3 = *(_DWORD *)(a1 - 4), (unsigned __int8)a3 == 254) ? (v7 = a3 >> 10) : (v7 = a3 >> 9),
        a4 > (int)((v7 | 1) - a5 + 1)
     || a2 < 1
     || ((a3 = *(_DWORD *)(v27 - 4), (unsigned __int8)a3 == 254) ? (v8 = a3 >> 10) : (v8 = a3 >> 9),
         a2 > (int)((v8 | 1) - a5 + 1))) )
  {
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  if ( a4 >= a2 )
  {
    v28 = 1;
    v17 = a5 - 2;
    if ( v17 >= 1 )
    {
      v24 = a1;
      do
      {
        v18 = a4 + v28 - 1;
        if ( *(unsigned __int8 *)(v24 - 4) == 254 )
        {
          while ( 1 )
          {
            v20 = caml_young_ptr - 12;
            caml_young_ptr = v20;
            if ( v20 >= caml_young_limit )
              break;
            caml_call_gc(v24);
          }
          *(_DWORD *)v20 = 2301;
          *(double *)(v20 + 4) = *(double *)(v24 + 4 * v18 - 4);
          v19 = (double *)(v20 + 4);
        }
        else
        {
          v19 = *(double **)(v24 + 2 * v18 - 2);
        }
        v21 = a2 + v28 - 1;
        if ( *(unsigned __int8 *)(v27 - 4) == 254 )
          *(double *)(v27 + 4 * v21 - 4) = *v19;
        else
          caml_modify((unsigned int *)(v27 + 2 * v21 - 2), (unsigned int)v19);
        v22 = v28;
        v28 += 2;
      }
      while ( v22 != v17 );
    }
    result = 1;
  }
  else
  {
    v9 = a5 - 2;
    if ( v9 >= 1 )
    {
      v25 = a4;
      do
      {
        v10 = v25 + v9 - 1;
        if ( *(unsigned __int8 *)(a1 - 4) == 254 )
        {
          while ( 1 )
          {
            v12 = caml_young_ptr - 12;
            caml_young_ptr = v12;
            if ( v12 >= caml_young_limit )
              break;
            caml_call_gc(v23);
          }
          v13 = (double *)(v12 + 4);
          *((_DWORD *)v13 - 1) = 2301;
          *v13 = *(double *)(a1 + 4 * v10 - 4);
          v11 = v13;
        }
        else
        {
          v11 = *(double **)(a1 + 2 * v10 - 2);
        }
        v14 = a2 + v9 - 1;
        if ( *(unsigned __int8 *)(v27 - 4) == 254 )
          *(double *)(v27 + 4 * v14 - 4) = *v11;
        else
          caml_modify((unsigned int *)(v27 + 2 * v14 - 2), (unsigned int)v11);
        v15 = v9;
        v9 -= 2;
      }
      while ( v15 != 1 );
    }
    result = 1;
  }
  return result;
}
// 8051FEC: variable 'v24' is possibly undefined
// 80520A7: variable 'v23' is possibly undefined
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080520C0) --------------------------------------------------------
int __usercall camlArray__iter_1101@<eax>(void (**a1)(void)@<eax>, int a2@<ebx>)
{
  int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // edx
  int v5; // edx
  int v6; // ebx
  unsigned int v7; // eax
  double *v8; // eax
  int v9; // ebx
  int v13; // [esp+8h] [ebp-10h]
  int v14; // [esp+Ch] [ebp-Ch]

  v2 = 1;
  v3 = *(_DWORD *)(a2 - 4);
  if ( (unsigned __int8)v3 == 254 )
    v4 = v3 >> 10;
  else
    v4 = v3 >> 9;
  v5 = (v4 | 1) - 2;
  if ( v5 >= 1 )
  {
    v14 = v5;
    v13 = 1;
    do
    {
      v6 = a2;
      if ( *(unsigned __int8 *)(a2 - 4) == 254 )
      {
        while ( 1 )
        {
          v7 = caml_young_ptr - 12;
          caml_young_ptr = v7;
          if ( v7 >= caml_young_limit )
            break;
          caml_call_gc(a2);
        }
        v8 = (double *)(v7 + 4);
        *((_DWORD *)v8 - 1) = 2301;
        *v8 = *(double *)(v6 + 4 * v2 - 4);
      }
      (*a1)();
      v9 = v13;
      v2 = v13 + 2;
      v13 += 2;
    }
    while ( v9 != v14 );
  }
  return 1;
}
// 80520FC: variable 'a2' is possibly undefined
// 805212F: variable 'v2' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052170) --------------------------------------------------------
void *__usercall camlArray__map_1105@<eax>(void (**a1)(void)@<eax>, double *a2@<ebx>)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  unsigned int v7; // eax
  double *v8; // eax
  int v9; // eax
  int v10; // esi
  int v11; // ebx
  double *v12; // ecx
  unsigned int v13; // eax
  double *v14; // eax
  double *v15; // eax
  int v16; // ecx
  int v17; // [esp+0h] [ebp-1Ch]
  int v18; // [esp+0h] [ebp-1Ch]
  int (**v20)(void); // [esp+8h] [ebp-14h]
  int v21; // [esp+Ch] [ebp-10h]
  int v22; // [esp+10h] [ebp-Ch]

  v3 = *((_DWORD *)a2 - 1);
  if ( (unsigned __int8)v3 == 254 )
    v4 = v3 >> 10;
  else
    v4 = v3 >> 9;
  v5 = v4 | 1;
  if ( v5 == 1 )
    return &camlArray__24;
  v17 = v5;
  v20 = (int (**)(void))a1;
  if ( *((unsigned __int8 *)a2 - 4) == 254 )
  {
    while ( 1 )
    {
      v7 = caml_young_ptr - 12;
      caml_young_ptr = v7;
      if ( v7 >= caml_young_limit )
        break;
      caml_call_gc(v17);
    }
    v8 = (double *)(v7 + 4);
    *((_DWORD *)v8 - 1) = 2301;
    *v8 = *a2;
  }
  (*a1)();
  v9 = caml_c_call((int (*)(void))caml_make_vect, v17);
  v10 = v9;
  v11 = 3;
  if ( v17 - 2 >= 3 )
  {
    v21 = v17 - 2;
    v22 = 3;
    v18 = v9;
    do
    {
      v12 = a2;
      if ( *((unsigned __int8 *)a2 - 4) == 254 )
      {
        while ( 1 )
        {
          v13 = caml_young_ptr - 12;
          caml_young_ptr = v13;
          if ( v13 >= caml_young_limit )
            break;
          caml_call_gc(v18);
        }
        v14 = (double *)(v13 + 4);
        *((_DWORD *)v14 - 1) = 2301;
        *v14 = *(double *)((char *)v12 + 4 * v11 - 4);
      }
      v15 = (double *)(*v20)();
      v10 = v18;
      if ( *(unsigned __int8 *)(v18 - 4) == 254 )
        *(double *)(v18 + 4 * v22 - 4) = *v15;
      else
        caml_modify((unsigned int *)(v18 + 2 * v22 - 2), (unsigned int)v15);
      v16 = v22;
      v11 = v22 + 2;
      v22 += 2;
    }
    while ( v16 != v21 );
  }
  return (void *)v10;
}
// 80521F7: variable 'a1' is possibly undefined
// 8052208: variable 'v17' is possibly undefined
// 805226F: variable 'v12' is possibly undefined
// 805227D: variable 'v18' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080522E0) --------------------------------------------------------
int __usercall camlArray__iteri_1111@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // edx
  int v5; // edx
  int v6; // edx
  unsigned int v7; // eax
  int v8; // ebx
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]

  v2 = 1;
  v3 = *(_DWORD *)(a2 - 4);
  if ( (unsigned __int8)v3 == 254 )
    v4 = v3 >> 10;
  else
    v4 = v3 >> 9;
  v5 = (v4 | 1) - 2;
  if ( v5 >= 1 )
  {
    v13 = v5;
    v12 = 1;
    do
    {
      v6 = a2;
      if ( *(unsigned __int8 *)(a2 - 4) == 254 )
      {
        while ( 1 )
        {
          v7 = caml_young_ptr - 12;
          caml_young_ptr = v7;
          if ( v7 >= caml_young_limit )
            break;
          caml_call_gc(a2);
        }
        *(_DWORD *)v7 = 2301;
        *(double *)(v7 + 4) = *(double *)(v6 + 4 * v2 - 4);
      }
      caml_apply2(a1);
      v8 = v12;
      v2 = v12 + 2;
      v12 += 2;
    }
    while ( v8 != v13 );
  }
  return 1;
}
// 805231C: variable 'a2' is possibly undefined
// 805234F: variable 'v6' is possibly undefined
// 805234F: variable 'v2' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052390) --------------------------------------------------------
void *__usercall camlArray__mapi_1115@<eax>(int a1@<eax>, double *a2@<ebx>)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  unsigned int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // esi
  double *v11; // ecx
  unsigned int v12; // eax
  double *v13; // eax
  int v14; // ecx
  int v15; // [esp+0h] [ebp-1Ch]
  int v16; // [esp+0h] [ebp-1Ch]
  int v18; // [esp+8h] [ebp-14h]
  int v19; // [esp+Ch] [ebp-10h]
  int v20; // [esp+10h] [ebp-Ch]

  v3 = *((_DWORD *)a2 - 1);
  if ( (unsigned __int8)v3 == 254 )
    v4 = v3 >> 10;
  else
    v4 = v3 >> 9;
  v5 = v4 | 1;
  if ( v5 == 1 )
    return &camlArray__23;
  v15 = v5;
  v18 = a1;
  if ( *((unsigned __int8 *)a2 - 4) == 254 )
  {
    while ( 1 )
    {
      v7 = caml_young_ptr - 12;
      caml_young_ptr = v7;
      if ( v7 >= caml_young_limit )
        break;
      caml_call_gc(v15);
    }
    *(_DWORD *)v7 = 2301;
    *(double *)(v7 + 4) = *a2;
  }
  caml_apply2(a1);
  v8 = caml_c_call((int (*)(void))caml_make_vect, v15);
  v9 = v8;
  v10 = 3;
  if ( v15 - 2 >= 3 )
  {
    v19 = v15 - 2;
    v20 = 3;
    v16 = v8;
    do
    {
      v11 = a2;
      if ( *((unsigned __int8 *)a2 - 4) == 254 )
      {
        while ( 1 )
        {
          v12 = caml_young_ptr - 12;
          caml_young_ptr = v12;
          if ( v12 >= caml_young_limit )
            break;
          caml_call_gc(v16);
        }
        *(_DWORD *)v12 = 2301;
        *(double *)(v12 + 4) = *(double *)((char *)v11 + 4 * v10 - 4);
      }
      v13 = (double *)caml_apply2(v18);
      v9 = v16;
      if ( *(unsigned __int8 *)(v16 - 4) == 254 )
        *(double *)(v16 + 4 * v20 - 4) = *v13;
      else
        caml_modify((unsigned int *)(v16 + 2 * v20 - 2), (unsigned int)v13);
      v14 = v20;
      v10 = v20 + 2;
      v20 += 2;
    }
    while ( v14 != v19 );
  }
  return (void *)v9;
}
// 805241E: variable 'a1' is possibly undefined
// 805242E: variable 'v15' is possibly undefined
// 805248F: variable 'v11' is possibly undefined
// 80524A0: variable 'v16' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052510) --------------------------------------------------------
#error "8052573: call analysis failed (funcsize=26)"

//----- (08052580) --------------------------------------------------------
int __usercall camlArray__list_length_1126@<eax>(int result@<eax>, int a2@<ebx>)
{
  while ( a2 != 1 )
  {
    a2 = *(_DWORD *)(a2 + 4);
    result += 2;
  }
  return result;
}

//----- (080525A0) --------------------------------------------------------
void *__usercall camlArray__of_list_1130@<eax>(int *a1@<eax>)
{
  char v1; // al
  int v2; // ebx
  _DWORD *v3; // eax
  int v5; // [esp+0h] [ebp-8h]
  int v6; // [esp+4h] [ebp-4h]

  if ( a1 == (int *)1 )
    return &camlArray__22;
  v6 = a1[1];
  v5 = *a1;
  v1 = camlArray__list_length_1126(1, (int)a1);
  v2 = caml_c_call((int (*)(void))caml_make_vect, v1);
  while ( 1 )
  {
    v3 = (_DWORD *)(caml_young_ptr - 20);
    caml_young_ptr = (int)v3;
    if ( (unsigned int)v3 >= caml_young_limit )
      break;
    caml_call_gc(v5);
  }
  *v3 = 4343;
  v3[1] = caml_curry2;
  v3[2] = 5;
  v3[3] = camlArray__fill_1135;
  v3[4] = v2;
  return (void *)camlArray__fill_1135(3, (int)(v3 + 1), v6);
}
// 8052629: variable 'v5' is possibly undefined
// 804B070: using guessed type _DWORD caml_curry2();
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052630) --------------------------------------------------------
unsigned int __usercall camlArray__fold_left_1139@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  _DWORD *v4; // eax
  unsigned int *v5; // esi
  int v6; // edx
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // eax
  int v10; // ecx
  unsigned int v11; // eax
  int v12; // eax
  int v13; // ebx
  char v15; // [esp+0h] [ebp-1Ch]
  int v16; // [esp+0h] [ebp-1Ch]
  unsigned int *v17; // [esp+8h] [ebp-14h]
  int v18; // [esp+Ch] [ebp-10h]
  int v19; // [esp+10h] [ebp-Ch]

  while ( 1 )
  {
    v4 = (_DWORD *)(caml_young_ptr - 8);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
    caml_call_gc(v15);
  }
  v5 = v4 + 1;
  *v4 = 1024;
  v4[1] = a3;
  v6 = 1;
  v7 = *(_DWORD *)(a2 - 4);
  if ( (unsigned __int8)v7 == 254 )
    v8 = v7 >> 10;
  else
    v8 = v7 >> 9;
  v9 = (v8 | 1) - 2;
  if ( v9 >= 1 )
  {
    v19 = v9;
    v18 = 1;
    v17 = v5;
    v16 = a2;
    do
    {
      v10 = v16;
      if ( *(unsigned __int8 *)(v16 - 4) == 254 )
      {
        while ( 1 )
        {
          v11 = caml_young_ptr - 12;
          caml_young_ptr = v11;
          if ( v11 >= caml_young_limit )
            break;
          caml_call_gc(v16);
        }
        *(_DWORD *)v11 = 2301;
        *(double *)(v11 + 4) = *(double *)(v10 + 4 * v6 - 4);
      }
      v12 = caml_apply2(a1);
      v5 = v17;
      caml_modify(v17, v12);
      v13 = v18;
      v6 = v18 + 2;
      v18 += 2;
    }
    while ( v13 != v19 );
  }
  return *v5;
}
// 805265F: variable 'a2' is possibly undefined
// 80526A4: variable 'v16' is possibly undefined
// 80526DF: variable 'v10' is possibly undefined
// 80526DF: variable 'v6' is possibly undefined
// 8052720: variable 'v15' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052730) --------------------------------------------------------
unsigned int __usercall camlArray__fold_right_1145@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  _DWORD *v4; // eax
  unsigned int *v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  int v8; // ecx
  int v9; // ebx
  unsigned int v10; // eax
  double *v11; // eax
  int v12; // eax
  int v13; // eax
  char v15; // [esp+0h] [ebp-18h]
  int v17; // [esp+4h] [ebp-14h]
  unsigned int *v18; // [esp+8h] [ebp-10h]
  int v19; // [esp+Ch] [ebp-Ch]

  while ( 1 )
  {
    v4 = (_DWORD *)(caml_young_ptr - 8);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
    caml_call_gc(v15);
  }
  v5 = v4 + 1;
  *v4 = 1024;
  v4[1] = a2;
  v6 = *(_DWORD *)(a3 - 4);
  if ( (unsigned __int8)v6 == 254 )
    v7 = v6 >> 10;
  else
    v7 = v6 >> 9;
  v8 = (v7 | 1) - 2;
  if ( v8 >= 1 )
  {
    v19 = v8;
    v18 = v4 + 1;
    v17 = a1;
    do
    {
      v9 = a3;
      if ( *(unsigned __int8 *)(a3 - 4) == 254 )
      {
        while ( 1 )
        {
          v10 = caml_young_ptr - 12;
          caml_young_ptr = v10;
          if ( v10 >= caml_young_limit )
            break;
          caml_call_gc(a3);
        }
        v11 = (double *)(v10 + 4);
        *((_DWORD *)v11 - 1) = 2301;
        *v11 = *(double *)(v9 + 4 * v8 - 4);
      }
      v12 = caml_apply2(v17);
      v5 = v18;
      caml_modify(v18, v12);
      v13 = v19;
      v8 = v19 - 2;
      v19 -= 2;
    }
    while ( v13 != 1 );
  }
  return *v5;
}
// 8052758: variable 'a2' is possibly undefined
// 805278D: variable 'a1' is possibly undefined
// 8052791: variable 'a3' is possibly undefined
// 80527CF: variable 'v8' is possibly undefined
// 805280D: variable 'v15' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052820) --------------------------------------------------------
int __usercall camlArray__sort_179@<eax>(int a1@<eax>, int a2@<ebx>)
{
  _DWORD *v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  int v7; // ebx
  int v8; // edx
  unsigned int v9; // eax
  double *v10; // ecx
  unsigned int v11; // eax
  int v12; // eax
  unsigned int v13; // esi
  unsigned int v14; // eax
  unsigned int v15; // eax
  double *v16; // eax
  unsigned int v17; // eax
  double *v18; // edx
  unsigned int v19; // eax
  unsigned int v20; // eax
  int v21; // eax
  int v22; // eax
  unsigned int v23; // eax
  double *v24; // esi
  unsigned int v25; // eax
  unsigned int v26; // eax
  double *v27; // edx
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  int v32; // eax
  char v33; // [esp+0h] [ebp-20h]
  int v34; // [esp+0h] [ebp-20h]
  int v35; // [esp+4h] [ebp-1Ch]
  double *v36; // [esp+4h] [ebp-1Ch]
  int v37; // [esp+8h] [ebp-18h]
  int v38; // [esp+Ch] [ebp-14h]
  int v39; // [esp+Ch] [ebp-14h]
  int v41; // [esp+14h] [ebp-Ch]

  while ( 1 )
  {
    v3 = (_DWORD *)(caml_young_ptr - 144);
    caml_young_ptr = (int)v3;
    if ( (unsigned int)v3 >= caml_young_limit )
      break;
    caml_call_gc(v33);
  }
  *v3 = 5367;
  v3[1] = caml_curry2;
  v3[2] = 5;
  v3[3] = camlArray__maxson_182;
  v3[4] = a1;
  v3[5] = a2;
  v3[6] = 6391;
  v3[7] = caml_curry3;
  v3[8] = 7;
  v3[9] = camlArray__trickledown_187;
  v3[10] = a1;
  v3[11] = a2;
  v3[12] = v3 + 1;
  v35 = (int)(v3 + 14);
  v3[13] = 5367;
  v3[14] = caml_curry3;
  v3[15] = 7;
  v3[16] = camlArray__trickle_1165;
  v3[17] = a2;
  v3[18] = v3 + 7;
  v3[19] = 5367;
  v3[20] = caml_curry2;
  v3[21] = 5;
  v3[22] = camlArray__bubbledown_1170;
  v3[23] = a2;
  v3[24] = v3 + 1;
  v34 = (int)(v3 + 26);
  v3[25] = 4343;
  v3[26] = caml_curry2;
  v3[27] = 5;
  v3[28] = camlArray__bubble_1174;
  v3[29] = v3 + 20;
  v37 = (int)(v3 + 31);
  v3[30] = 5367;
  v3[31] = caml_curry2;
  v3[32] = 5;
  v3[33] = camlArray__trickleup_205;
  v3[34] = a1;
  v3[35] = a2;
  v4 = *(_DWORD *)(a2 - 4);
  if ( (unsigned __int8)v4 == 254 )
    v5 = v4 >> 10;
  else
    v5 = v4 >> 9;
  v41 = v5 | 1;
  v6 = ((int)((v5 | 1) + 2) >> 1) / 3;
  v7 = 2 * v6 - 1;
  if ( v7 >= 1 )
  {
    v38 = 2 * v6 - 1;
    do
    {
      v8 = a2;
      v9 = *(_DWORD *)(a2 - 4);
      if ( (unsigned __int8)v9 == 254 )
      {
        if ( v9 >> 10 <= v7 )
          goto LABEL_79;
        while ( 1 )
        {
          v11 = caml_young_ptr - 12;
          caml_young_ptr = v11;
          if ( v11 >= caml_young_limit )
            break;
          caml_call_gc(v34);
        }
        v10 = (double *)(v11 + 4);
        *(_DWORD *)v11 = 2301;
        *(double *)(v11 + 4) = *(double *)(v8 + 4 * v7 - 4);
      }
      else
      {
        if ( v9 >> 9 <= v7 )
          goto LABEL_80;
        v10 = *(double **)(a2 + 2 * v7 - 2);
      }
      camlArray__trickle_1165(v41, v35, v10, v7);
      v12 = v38;
      v7 = v38 - 2;
      v38 -= 2;
    }
    while ( v12 != 1 );
  }
  v13 = v41 - 2;
  if ( v41 - 2 >= 5 )
  {
    v39 = v41 - 2;
    do
    {
      v7 = a2;
      v14 = *(_DWORD *)(a2 - 4);
      if ( (unsigned __int8)v14 == 254 )
      {
        if ( v14 >> 10 <= v13 )
          goto LABEL_77;
        while ( 1 )
        {
          v15 = caml_young_ptr - 12;
          caml_young_ptr = v15;
          if ( v15 >= caml_young_limit )
            break;
          caml_call_gc(v34);
        }
        v16 = (double *)(v15 + 4);
        *((_DWORD *)v16 - 1) = 2301;
        *v16 = *(double *)(a2 + 4 * v13 - 4);
        v36 = v16;
      }
      else
      {
        if ( v14 >> 9 <= v13 )
          goto LABEL_78;
        v36 = *(double **)(a2 + 2 * v13 - 2);
      }
      v17 = *(_DWORD *)(a2 - 4);
      if ( (unsigned __int8)v17 == 254 )
      {
        if ( v17 >> 10 <= 1 )
          goto LABEL_75;
        while ( 1 )
        {
          v19 = caml_young_ptr - 12;
          caml_young_ptr = v19;
          if ( v19 >= caml_young_limit )
            break;
          caml_call_gc(v34);
        }
        v18 = (double *)(v19 + 4);
        *(_DWORD *)v19 = 2301;
        *(double *)(v19 + 4) = *(double *)a2;
      }
      else
      {
        if ( v17 >> 9 <= 1 )
          goto LABEL_76;
        v18 = *(double **)a2;
      }
      v20 = *(_DWORD *)(a2 - 4);
      if ( (unsigned __int8)v20 == 254 )
      {
        if ( v20 >> 10 <= v13 )
          goto LABEL_73;
        *(double *)(a2 + 4 * v13 - 4) = *v18;
      }
      else
      {
        if ( v20 >> 9 <= v13 )
          goto LABEL_74;
        caml_modify((unsigned int *)(a2 + 2 * v13 - 2), (unsigned int)v18);
      }
      v21 = camlArray__bubble_1174(v13, v34, 1u);
      camlArray__trickleup_205(v21, v37, v36);
      v22 = v39;
      v13 = v39 - 2;
      v39 -= 2;
    }
    while ( v22 != 5 );
  }
  if ( v41 <= 3 )
    return 1;
  v7 = a2;
  v23 = *(_DWORD *)(a2 - 4);
  if ( (unsigned __int8)v23 == 254 )
  {
    if ( v23 >> 10 <= 3 )
    {
LABEL_71:
      caml_ml_array_bound_error();
      goto LABEL_72;
    }
    while ( 1 )
    {
      v25 = caml_young_ptr - 12;
      caml_young_ptr = v25;
      if ( v25 >= caml_young_limit )
        break;
      caml_call_gc(v34);
    }
    v24 = (double *)(v25 + 4);
    *(_DWORD *)v25 = 2301;
    *(double *)(v25 + 4) = *(double *)(a2 + 8);
LABEL_41:
    v26 = *(_DWORD *)(a2 - 4);
    if ( (unsigned __int8)v26 == 254 )
    {
      if ( v26 >> 10 <= 1 )
      {
LABEL_69:
        caml_ml_array_bound_error();
        goto LABEL_70;
      }
      while ( 1 )
      {
        v28 = caml_young_ptr - 12;
        caml_young_ptr = v28;
        if ( v28 >= caml_young_limit )
          break;
        caml_call_gc(v34);
      }
      v27 = (double *)(v28 + 4);
      *(_DWORD *)v28 = 2301;
      *(double *)(v28 + 4) = *(double *)a2;
    }
    else
    {
      if ( v26 >> 9 <= 1 )
      {
LABEL_70:
        caml_ml_array_bound_error();
        goto LABEL_71;
      }
      v27 = *(double **)a2;
    }
    v29 = *(_DWORD *)(a2 - 4);
    if ( (unsigned __int8)v29 == 254 )
    {
      if ( v29 >> 10 <= 3 )
      {
LABEL_67:
        caml_ml_array_bound_error();
        goto LABEL_68;
      }
      *(double *)(a2 + 8) = *v27;
    }
    else
    {
      if ( v29 >> 9 <= 3 )
      {
LABEL_68:
        caml_ml_array_bound_error();
        goto LABEL_69;
      }
      caml_modify((unsigned int *)(a2 + 4), (unsigned int)v27);
    }
    v30 = *(_DWORD *)(a2 - 4);
    if ( (unsigned __int8)v30 == 254 )
    {
      if ( v30 >> 10 > 1 )
      {
        *(double *)a2 = *v24;
        return 1;
      }
      caml_ml_array_bound_error();
    }
    else if ( v30 >> 9 > 1 )
    {
      caml_modify((unsigned int *)a2, (unsigned int)v24);
      return 1;
    }
    caml_ml_array_bound_error();
    goto LABEL_67;
  }
  if ( v23 >> 9 > 3 )
  {
    v24 = *(double **)(a2 + 4);
    goto LABEL_41;
  }
LABEL_72:
  caml_ml_array_bound_error();
LABEL_73:
  caml_ml_array_bound_error();
LABEL_74:
  caml_ml_array_bound_error();
LABEL_75:
  caml_ml_array_bound_error();
LABEL_76:
  caml_ml_array_bound_error();
LABEL_77:
  caml_ml_array_bound_error();
LABEL_78:
  caml_ml_array_bound_error();
LABEL_79:
  caml_ml_array_bound_error();
LABEL_80:
  v32 = caml_ml_array_bound_error();
  return camlArray__stable_sort_1188(v32, (double *)v7);
}
// 8052862: variable 'a1' is possibly undefined
// 80529BE: variable 'v8' is possibly undefined
// 8052B1B: variable 'v34' is possibly undefined
// 8052CEB: variable 'v33' is possibly undefined
// 804AFD0: using guessed type _DWORD caml_curry3();
// 804B070: using guessed type _DWORD caml_curry2();
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052D50) --------------------------------------------------------
int __usercall camlArray__stable_sort_1188@<eax>(int a1@<eax>, double *a2@<ebx>)
{
  unsigned int v3; // eax
  _DWORD *v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // edx
  int v7; // edx
  int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // eax
  double *v12; // eax
  char v13; // [esp+0h] [ebp-20h]
  int v14; // [esp+0h] [ebp-20h]
  unsigned int v15; // [esp+4h] [ebp-1Ch]
  int v16; // [esp+8h] [ebp-18h]
  int v17; // [esp+Ch] [ebp-14h]
  int v18; // [esp+14h] [ebp-Ch]

  while ( 1 )
  {
    v3 = caml_young_ptr - 76;
    caml_young_ptr = v3;
    if ( v3 >= caml_young_limit )
      break;
    caml_call_gc(v13);
  }
  v4 = (_DWORD *)(v3 + 4);
  *(v4 - 1) = 5367;
  *v4 = caml_curry7;
  v4[1] = 15;
  v4[2] = camlArray__merge_1191;
  v4[3] = a1;
  v4[4] = a2;
  v4[5] = 5367;
  v4[6] = caml_curry4;
  v4[7] = 9;
  v4[8] = camlArray__isortto_236;
  v4[9] = a1;
  v4[10] = a2;
  v4[11] = 6391;
  v4[12] = caml_curry4;
  v4[13] = 9;
  v4[14] = camlArray__sortto_1217;
  v4[15] = a2;
  v4[16] = v4;
  v4[17] = v4 + 6;
  v5 = *((_DWORD *)a2 - 1);
  if ( (unsigned __int8)v5 == 254 )
    v6 = v5 >> 10;
  else
    v6 = v5 >> 9;
  v7 = v6 | 1;
  if ( v7 <= 11 )
    return camlArray__isortto_236(1, v7, 1, (int)a2, (int)(v4 + 6));
  v14 = (int)(v4 + 12);
  v18 = (int)v4;
  v16 = 2 * ((v7 >> 1) / 2) + 1;
  v9 = v7 - 2 * ((v7 >> 1) / 2);
  v15 = v9;
  v10 = *((_DWORD *)a2 - 1);
  if ( (unsigned __int8)v10 == 254 )
  {
    if ( v10 >> 10 > 1 )
    {
      while ( 1 )
      {
        v11 = caml_young_ptr - 12;
        caml_young_ptr = v11;
        if ( v11 >= caml_young_limit )
          break;
        caml_call_gc(v14);
      }
      v12 = (double *)(v11 + 4);
      *((_DWORD *)v12 - 1) = 2301;
      *v12 = *a2;
      goto LABEL_13;
    }
    caml_ml_array_bound_error();
  }
  else if ( v10 >> 9 > 1 )
  {
LABEL_13:
    v17 = caml_c_call((int (*)(void))caml_make_vect, v9);
    camlArray__sortto_1217(v16, v15, 1, v17, v14);
    camlArray__sortto_1217(1, v16, v15, (int)a2, v14);
    caml_extra_params = 1;
    dword_8074580 = v18;
    return camlArray__merge_1191(v15, 1u, v17, v16, (int)a2, v15);
  }
  caml_ml_array_bound_error();
  return camlArray__entry();
}
// 8052D50: could not find valid save-restore pair for ebp
// 8052D8C: variable 'a1' is possibly undefined
// 8052EAA: variable 'v9' is possibly undefined
// 8052EC8: variable 'v14' is possibly undefined
// 8052F24: variable 'v13' is possibly undefined
// 804AA50: using guessed type _DWORD caml_curry7();
// 804AEF0: using guessed type _DWORD caml_curry4();
// 8052F40: using guessed type int camlArray__entry(void);
// 807457C: using guessed type int caml_extra_params;
// 8074580: using guessed type int dword_8074580;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08052F40) --------------------------------------------------------
#error "8052FFE: call analysis failed (funcsize=52)"

//----- (08053050) --------------------------------------------------------
int __usercall camlList__code_begin@<eax>(int *a1@<eax>, int a2@<ebx>)
{
  int *v2; // ecx
  int result; // eax

  while ( 1 )
  {
    if ( a1 == (int *)1 )
      camlPervasives__failwith_1010();
    v2 = (int *)a1[1];
    result = *a1;
    if ( a2 == 1 )
      break;
    a2 -= 2;
    a1 = v2;
  }
  return result;
}
// 804F200: using guessed type int camlPervasives__failwith_1010(void);

//----- (08053080) --------------------------------------------------------
int *__usercall camlList__rmap_f_1070@<eax>(int *result@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // ebx
  unsigned int v4; // eax
  int *v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  while ( a3 != 1 )
  {
    v7 = a2;
    v5 = result;
    v6 = *(_DWORD *)(a3 + 4);
    v3 = (**(int (***)(void))(a2 + 12))();
    while ( 1 )
    {
      v4 = caml_young_ptr - 12;
      caml_young_ptr = v4;
      if ( v4 >= caml_young_limit )
        break;
      caml_call_gc((char)v5);
    }
    result = (int *)(v4 + 4);
    *(result - 1) = 2048;
    *result = v3;
    result[1] = (int)v5;
    a3 = v6;
    a2 = v7;
  }
  return result;
}
// 80530C5: variable 'v5' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080530F0) --------------------------------------------------------
int *__usercall camlList__rmap2_f_1103@<eax>(int *result@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // ebx
  unsigned int v5; // eax
  int *v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  while ( a4 != 1 )
  {
    if ( a3 == 1 )
      goto LABEL_7;
    v9 = a2;
    v6 = result;
    v8 = *(_DWORD *)(a3 + 4);
    v7 = *(_DWORD *)(a4 + 4);
    v4 = caml_apply2(*(_DWORD *)(a2 + 12));
    while ( 1 )
    {
      v5 = caml_young_ptr - 12;
      caml_young_ptr = v5;
      if ( v5 >= caml_young_limit )
        break;
      caml_call_gc((char)v6);
    }
    result = (int *)(v5 + 4);
    *(result - 1) = 2048;
    *result = v4;
    result[1] = (int)v6;
    a4 = v7;
    a3 = v8;
    a2 = v9;
  }
  if ( a3 != 1 )
LABEL_7:
    camlPervasives__invalid_arg_1012(a3, a2);
  return result;
}
// 8053146: variable 'v6' is possibly undefined
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08053190) --------------------------------------------------------
int __usercall camlList__find_1207@<eax>(_DWORD *a1@<eax>, int a2@<ecx>, int *a3@<ebx>)
{
  unsigned int v3; // eax
  int v5; // [esp+0h] [ebp-10h]
  _DWORD *v6; // [esp+4h] [ebp-Ch]
  int *v7; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]

  while ( a3 != (int *)1 )
  {
    v8 = a2;
    v6 = a1;
    v7 = (int *)a3[1];
    v5 = *a3;
    if ( (**(int (***)(void))(a2 + 12))() == 1 )
    {
      a1 = v6;
      a3 = v7;
      a2 = v8;
    }
    else
    {
      while ( 1 )
      {
        v3 = caml_young_ptr - 12;
        caml_young_ptr = v3;
        if ( v3 >= caml_young_limit )
          break;
        caml_call_gc(v5);
      }
      a1 = (_DWORD *)(v3 + 4);
      *(a1 - 1) = 2048;
      *a1 = v5;
      a1[1] = v6;
      a3 = v7;
      a2 = v8;
    }
  }
  return camlList__rev_append_1051();
}
// 80531DA: variable 'v5' is possibly undefined
// 8053F50: using guessed type int camlList__rev_append_1051(void);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08053220) --------------------------------------------------------
int *__usercall camlList__part_1215@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int *a3@<ecx>, _DWORD *a4@<ebx>)
{
  unsigned int v4; // eax
  _DWORD *v5; // eax
  int v6; // ebx
  unsigned int v7; // eax
  int *result; // eax
  int v9; // [esp+0h] [ebp-14h]
  int v10; // [esp+0h] [ebp-14h]
  _DWORD *v11; // [esp+4h] [ebp-10h]
  _DWORD *v12; // [esp+8h] [ebp-Ch]
  int *v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  while ( 1 )
  {
    v11 = a1;
    if ( a3 == (int *)1 )
      break;
    v14 = a2;
    v12 = a4;
    v13 = (int *)a3[1];
    v9 = *a3;
    if ( (**(int (***)(void))(a2 + 12))() == 1 )
    {
      while ( 1 )
      {
        v5 = (_DWORD *)(caml_young_ptr - 12);
        caml_young_ptr = (int)v5;
        if ( (unsigned int)v5 >= caml_young_limit )
          break;
        caml_call_gc(v9);
      }
      a4 = v5 + 1;
      *v5 = 2048;
      v5[1] = v9;
      v5[2] = v12;
      a1 = v11;
      a3 = v13;
      a2 = v14;
    }
    else
    {
      while ( 1 )
      {
        v4 = caml_young_ptr - 12;
        caml_young_ptr = v4;
        if ( v4 >= caml_young_limit )
          break;
        caml_call_gc(v9);
      }
      a1 = (_DWORD *)(v4 + 4);
      *(a1 - 1) = 2048;
      *a1 = v9;
      a1[1] = v11;
      a3 = v13;
      a2 = v14;
    }
  }
  v10 = camlList__rev_append_1051();
  v6 = camlList__rev_append_1051();
  while ( 1 )
  {
    v7 = caml_young_ptr - 12;
    caml_young_ptr = v7;
    if ( v7 >= caml_young_limit )
      break;
    caml_call_gc(v10);
  }
  result = (int *)(v7 + 4);
  *(result - 1) = 2048;
  *result = v6;
  result[1] = v10;
  return result;
}
// 8053220: could not find valid save-restore pair for ebx
// 8053276: variable 'v9' is possibly undefined
// 8053315: variable 'v10' is possibly undefined
// 8053F50: using guessed type int camlList__rev_append_1051(void);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08053340) --------------------------------------------------------
int __usercall camlList__rev_merge_1251@<eax>(_DWORD *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int *a4@<ebx>)
{
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int v7; // [esp+0h] [ebp-20h]
  _DWORD *v8; // [esp+4h] [ebp-1Ch]
  int *v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  _DWORD *v11; // [esp+10h] [ebp-10h]
  _DWORD *v12; // [esp+14h] [ebp-Ch]
  int v13; // [esp+1Ch] [ebp-4h]

  while ( a1 != (_DWORD *)1 && a4 != (int *)1 )
  {
    v13 = a2;
    v11 = a3;
    v8 = a1;
    v9 = (int *)a4[1];
    v7 = *a4;
    v12 = (_DWORD *)a1[1];
    v10 = *a1;
    if ( caml_apply2(*(_DWORD *)(a2 + 12)) > 1 )
    {
      while ( 1 )
      {
        v5 = (_DWORD *)(caml_young_ptr - 12);
        caml_young_ptr = (int)v5;
        if ( (unsigned int)v5 >= caml_young_limit )
          break;
        caml_call_gc(v7);
      }
      a3 = v5 + 1;
      *v5 = 2048;
      v5[1] = v7;
      v5[2] = v11;
      a1 = v8;
      a4 = v9;
      a2 = v13;
    }
    else
    {
      while ( 1 )
      {
        v4 = (_DWORD *)(caml_young_ptr - 12);
        caml_young_ptr = (int)v4;
        if ( (unsigned int)v4 >= caml_young_limit )
          break;
        caml_call_gc(v7);
      }
      a3 = v4 + 1;
      *v4 = 2048;
      v4[1] = v10;
      v4[2] = v11;
      a1 = v12;
      a2 = v13;
    }
  }
  return camlList__rev_append_1051();
}
// 80533F2: variable 'v7' is possibly undefined
// 8053F50: using guessed type int camlList__rev_append_1051(void);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08053440) --------------------------------------------------------
int __usercall camlList__rev_merge_rev_1261@<eax>(_DWORD *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int *a4@<ebx>)
{
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int v7; // [esp+0h] [ebp-20h]
  _DWORD *v8; // [esp+4h] [ebp-1Ch]
  int *v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  _DWORD *v11; // [esp+10h] [ebp-10h]
  _DWORD *v12; // [esp+14h] [ebp-Ch]
  int v13; // [esp+1Ch] [ebp-4h]

  while ( a1 != (_DWORD *)1 && a4 != (int *)1 )
  {
    v13 = a2;
    v11 = a3;
    v8 = a1;
    v9 = (int *)a4[1];
    v7 = *a4;
    v12 = (_DWORD *)a1[1];
    v10 = *a1;
    if ( caml_apply2(*(_DWORD *)(a2 + 12)) <= 1 )
    {
      while ( 1 )
      {
        v5 = (_DWORD *)(caml_young_ptr - 12);
        caml_young_ptr = (int)v5;
        if ( (unsigned int)v5 >= caml_young_limit )
          break;
        caml_call_gc(v7);
      }
      a3 = v5 + 1;
      *v5 = 2048;
      v5[1] = v7;
      v5[2] = v11;
      a1 = v8;
      a4 = v9;
      a2 = v13;
    }
    else
    {
      while ( 1 )
      {
        v4 = (_DWORD *)(caml_young_ptr - 12);
        caml_young_ptr = (int)v4;
        if ( (unsigned int)v4 >= caml_young_limit )
          break;
        caml_call_gc(v7);
      }
      a3 = v4 + 1;
      *v4 = 2048;
      v4[1] = v10;
      v4[2] = v11;
      a1 = v12;
      a2 = v13;
    }
  }
  return camlList__rev_append_1051();
}
// 80534F2: variable 'v7' is possibly undefined
// 8053F50: using guessed type int camlList__rev_append_1051(void);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08053540) --------------------------------------------------------
_DWORD *__usercall camlList__rev_sort_300@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>)
{
  int *v3; // esi
  int *v4; // edx
  _DWORD *v5; // eax
  _DWORD *result; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int *v12; // edx
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  int *v15; // ebx
  int v16; // [esp+0h] [ebp-14h]
  int v17; // [esp+0h] [ebp-14h]
  int v18; // [esp+0h] [ebp-14h]
  _DWORD *v19; // [esp+0h] [ebp-14h]
  int v20; // [esp+4h] [ebp-10h]
  int v21; // [esp+4h] [ebp-10h]
  int v22; // [esp+8h] [ebp-Ch]
  int v23; // [esp+8h] [ebp-Ch]
  int *v24; // [esp+Ch] [ebp-8h]
  int v25; // [esp+10h] [ebp-4h]

  if ( a1 != 5 )
  {
    v25 = a2;
    if ( a1 == 7 && a3 != (int *)1 )
    {
      v3 = (int *)a3[1];
      if ( v3 != (int *)1 )
      {
        v4 = (int *)v3[1];
        if ( v4 != (int *)1 )
        {
          v16 = *v4;
          v20 = *v3;
          v22 = *a3;
          if ( caml_apply2(*(_DWORD *)(a2 + 12)) <= 1 )
          {
            if ( caml_apply2(*(_DWORD *)(v25 + 12)) <= 1 )
            {
              if ( caml_apply2(*(_DWORD *)(v25 + 12)) <= 1 )
              {
                while ( 1 )
                {
                  v11 = (_DWORD *)(caml_young_ptr - 36);
                  caml_young_ptr = (int)v11;
                  if ( (unsigned int)v11 >= caml_young_limit )
                    break;
                  caml_call_gc(v16);
                }
                *v11 = 2048;
                v11[1] = v22;
                v11[2] = 1;
                v11[3] = 2048;
                v11[4] = v20;
                v11[5] = v11 + 1;
                v11[6] = 2048;
                v11[7] = v16;
                v11[8] = v11 + 4;
                result = v11 + 7;
              }
              else
              {
                while ( 1 )
                {
                  v10 = (_DWORD *)(caml_young_ptr - 36);
                  caml_young_ptr = (int)v10;
                  if ( (unsigned int)v10 >= caml_young_limit )
                    break;
                  caml_call_gc(v16);
                }
                *v10 = 2048;
                v10[1] = v22;
                v10[2] = 1;
                v10[3] = 2048;
                v10[4] = v16;
                v10[5] = v10 + 1;
                v10[6] = 2048;
                v10[7] = v20;
                v10[8] = v10 + 4;
                result = v10 + 7;
              }
            }
            else
            {
              while ( 1 )
              {
                v9 = (_DWORD *)(caml_young_ptr - 36);
                caml_young_ptr = (int)v9;
                if ( (unsigned int)v9 >= caml_young_limit )
                  break;
                caml_call_gc(v16);
              }
              *v9 = 2048;
              v9[1] = v16;
              v9[2] = 1;
              v9[3] = 2048;
              v9[4] = v22;
              v9[5] = v9 + 1;
              v9[6] = 2048;
              v9[7] = v20;
              v9[8] = v9 + 4;
              result = v9 + 7;
            }
          }
          else if ( caml_apply2(*(_DWORD *)(v25 + 12)) <= 1 )
          {
            if ( caml_apply2(*(_DWORD *)(v25 + 12)) <= 1 )
            {
              while ( 1 )
              {
                v8 = (_DWORD *)(caml_young_ptr - 36);
                caml_young_ptr = (int)v8;
                if ( (unsigned int)v8 >= caml_young_limit )
                  break;
                caml_call_gc(v16);
              }
              *v8 = 2048;
              v8[1] = v20;
              v8[2] = 1;
              v8[3] = 2048;
              v8[4] = v22;
              v8[5] = v8 + 1;
              v8[6] = 2048;
              v8[7] = v16;
              v8[8] = v8 + 4;
              result = v8 + 7;
            }
            else
            {
              while ( 1 )
              {
                v7 = (_DWORD *)(caml_young_ptr - 36);
                caml_young_ptr = (int)v7;
                if ( (unsigned int)v7 >= caml_young_limit )
                  break;
                caml_call_gc(v16);
              }
              *v7 = 2048;
              v7[1] = v20;
              v7[2] = 1;
              v7[3] = 2048;
              v7[4] = v16;
              v7[5] = v7 + 1;
              v7[6] = 2048;
              v7[7] = v22;
              v7[8] = v7 + 4;
              result = v7 + 7;
            }
          }
          else
          {
            while ( 1 )
            {
              v5 = (_DWORD *)(caml_young_ptr - 36);
              caml_young_ptr = (int)v5;
              if ( (unsigned int)v5 >= caml_young_limit )
                break;
              caml_call_gc(v16);
            }
            *v5 = 2048;
            v5[1] = v16;
            v5[2] = 1;
            v5[3] = 2048;
            v5[4] = v20;
            v5[5] = v5 + 1;
            v5[6] = 2048;
            v5[7] = v22;
            v5[8] = v5 + 4;
            result = v5 + 7;
          }
          return result;
        }
      }
    }
LABEL_32:
    v18 = (a1 >> 1) | 1;
    v23 = a1 - v18 + 1;
    v24 = (int *)camlList__chop_1243();
    v19 = camlList__sort_299(v18, v25 - 16, a3);
    v15 = camlList__sort_299(v23, v25 - 16, v24);
    return (_DWORD *)camlList__rev_merge_1251(v19, *(_DWORD *)(v25 + 16), (_DWORD *)1, v15);
  }
  if ( a3 == (int *)1 )
  {
    v25 = a2;
    goto LABEL_32;
  }
  v12 = (int *)a3[1];
  if ( v12 == (int *)1 )
  {
    v25 = a2;
    goto LABEL_32;
  }
  v17 = *v12;
  v21 = *a3;
  if ( caml_apply2(*(_DWORD *)(a2 + 12)) <= 1 )
  {
    while ( 1 )
    {
      v14 = (_DWORD *)(caml_young_ptr - 24);
      caml_young_ptr = (int)v14;
      if ( (unsigned int)v14 >= caml_young_limit )
        break;
      caml_call_gc(v17);
    }
    *v14 = 2048;
    v14[1] = v21;
    v14[2] = 1;
    v14[3] = 2048;
    v14[4] = v17;
    v14[5] = v14 + 1;
    result = v14 + 4;
  }
  else
  {
    while ( 1 )
    {
      v13 = (_DWORD *)(caml_young_ptr - 24);
      caml_young_ptr = (int)v13;
      if ( (unsigned int)v13 >= caml_young_limit )
        break;
      caml_call_gc(v17);
    }
    *v13 = 2048;
    v13[1] = v17;
    v13[2] = 1;
    v13[3] = 2048;
    v13[4] = v21;
    v13[5] = v13 + 1;
    result = v13 + 4;
  }
  return result;
}
// 80535DC: variable 'v16' is possibly undefined
// 80538B5: variable 'v17' is possibly undefined
// 8054B90: using guessed type int camlList__chop_1243(void);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08053A00) --------------------------------------------------------
_DWORD *__usercall camlList__sort_299@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>)
{
  int *v3; // esi
  int *v4; // edx
  _DWORD *v5; // eax
  _DWORD *result; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int *v12; // edx
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  int *v15; // ebx
  int v16; // [esp+0h] [ebp-14h]
  int v17; // [esp+0h] [ebp-14h]
  int v18; // [esp+0h] [ebp-14h]
  _DWORD *v19; // [esp+0h] [ebp-14h]
  int v20; // [esp+4h] [ebp-10h]
  int v21; // [esp+4h] [ebp-10h]
  int v22; // [esp+8h] [ebp-Ch]
  int v23; // [esp+8h] [ebp-Ch]
  int *v24; // [esp+Ch] [ebp-8h]
  int v25; // [esp+10h] [ebp-4h]

  if ( a1 != 5 )
  {
    v25 = a2;
    if ( a1 == 7 && a3 != (int *)1 )
    {
      v3 = (int *)a3[1];
      if ( v3 != (int *)1 )
      {
        v4 = (int *)v3[1];
        if ( v4 != (int *)1 )
        {
          v16 = *v4;
          v20 = *v3;
          v22 = *a3;
          if ( caml_apply2(*(_DWORD *)(a2 + 28)) > 1 )
          {
            if ( caml_apply2(*(_DWORD *)(v25 + 28)) > 1 )
            {
              if ( caml_apply2(*(_DWORD *)(v25 + 28)) > 1 )
              {
                while ( 1 )
                {
                  v11 = (_DWORD *)(caml_young_ptr - 36);
                  caml_young_ptr = (int)v11;
                  if ( (unsigned int)v11 >= caml_young_limit )
                    break;
                  caml_call_gc(v16);
                }
                *v11 = 2048;
                v11[1] = v22;
                v11[2] = 1;
                v11[3] = 2048;
                v11[4] = v20;
                v11[5] = v11 + 1;
                v11[6] = 2048;
                v11[7] = v16;
                v11[8] = v11 + 4;
                result = v11 + 7;
              }
              else
              {
                while ( 1 )
                {
                  v10 = (_DWORD *)(caml_young_ptr - 36);
                  caml_young_ptr = (int)v10;
                  if ( (unsigned int)v10 >= caml_young_limit )
                    break;
                  caml_call_gc(v16);
                }
                *v10 = 2048;
                v10[1] = v22;
                v10[2] = 1;
                v10[3] = 2048;
                v10[4] = v16;
                v10[5] = v10 + 1;
                v10[6] = 2048;
                v10[7] = v20;
                v10[8] = v10 + 4;
                result = v10 + 7;
              }
            }
            else
            {
              while ( 1 )
              {
                v9 = (_DWORD *)(caml_young_ptr - 36);
                caml_young_ptr = (int)v9;
                if ( (unsigned int)v9 >= caml_young_limit )
                  break;
                caml_call_gc(v16);
              }
              *v9 = 2048;
              v9[1] = v16;
              v9[2] = 1;
              v9[3] = 2048;
              v9[4] = v22;
              v9[5] = v9 + 1;
              v9[6] = 2048;
              v9[7] = v20;
              v9[8] = v9 + 4;
              result = v9 + 7;
            }
          }
          else if ( caml_apply2(*(_DWORD *)(v25 + 28)) > 1 )
          {
            if ( caml_apply2(*(_DWORD *)(v25 + 28)) > 1 )
            {
              while ( 1 )
              {
                v8 = (_DWORD *)(caml_young_ptr - 36);
                caml_young_ptr = (int)v8;
                if ( (unsigned int)v8 >= caml_young_limit )
                  break;
                caml_call_gc(v16);
              }
              *v8 = 2048;
              v8[1] = v20;
              v8[2] = 1;
              v8[3] = 2048;
              v8[4] = v22;
              v8[5] = v8 + 1;
              v8[6] = 2048;
              v8[7] = v16;
              v8[8] = v8 + 4;
              result = v8 + 7;
            }
            else
            {
              while ( 1 )
              {
                v7 = (_DWORD *)(caml_young_ptr - 36);
                caml_young_ptr = (int)v7;
                if ( (unsigned int)v7 >= caml_young_limit )
                  break;
                caml_call_gc(v16);
              }
              *v7 = 2048;
              v7[1] = v20;
              v7[2] = 1;
              v7[3] = 2048;
              v7[4] = v16;
              v7[5] = v7 + 1;
              v7[6] = 2048;
              v7[7] = v22;
              v7[8] = v7 + 4;
              result = v7 + 7;
            }
          }
          else
          {
            while ( 1 )
            {
              v5 = (_DWORD *)(caml_young_ptr - 36);
              caml_young_ptr = (int)v5;
              if ( (unsigned int)v5 >= caml_young_limit )
                break;
              caml_call_gc(v16);
            }
            *v5 = 2048;
            v5[1] = v16;
            v5[2] = 1;
            v5[3] = 2048;
            v5[4] = v20;
            v5[5] = v5 + 1;
            v5[6] = 2048;
            v5[7] = v22;
            v5[8] = v5 + 4;
            result = v5 + 7;
          }
          return result;
        }
      }
    }
LABEL_32:
    v18 = (a1 >> 1) | 1;
    v23 = a1 - v18 + 1;
    v24 = (int *)camlList__chop_1243();
    v19 = camlList__rev_sort_300(v18, v25 + 16, a3);
    v15 = camlList__rev_sort_300(v23, v25 + 16, v24);
    return (_DWORD *)camlList__rev_merge_rev_1261(v19, *(_DWORD *)(v25 + 36), (_DWORD *)1, v15);
  }
  if ( a3 == (int *)1 )
  {
    v25 = a2;
    goto LABEL_32;
  }
  v12 = (int *)a3[1];
  if ( v12 == (int *)1 )
  {
    v25 = a2;
    goto LABEL_32;
  }
  v17 = *v12;
  v21 = *a3;
  if ( caml_apply2(*(_DWORD *)(a2 + 28)) > 1 )
  {
    while ( 1 )
    {
      v14 = (_DWORD *)(caml_young_ptr - 24);
      caml_young_ptr = (int)v14;
      if ( (unsigned int)v14 >= caml_young_limit )
        break;
      caml_call_gc(v17);
    }
    *v14 = 2048;
    v14[1] = v21;
    v14[2] = 1;
    v14[3] = 2048;
    v14[4] = v17;
    v14[5] = v14 + 1;
    result = v14 + 4;
  }
  else
  {
    while ( 1 )
    {
      v13 = (_DWORD *)(caml_young_ptr - 24);
      caml_young_ptr = (int)v13;
      if ( (unsigned int)v13 >= caml_young_limit )
        break;
      caml_call_gc(v17);
    }
    *v13 = 2048;
    v13[1] = v17;
    v13[2] = 1;
    v13[3] = 2048;
    v13[4] = v21;
    v13[5] = v13 + 1;
    result = v13 + 4;
  }
  return result;
}
// 8053A9C: variable 'v16' is possibly undefined
// 8053D75: variable 'v17' is possibly undefined
// 8054B90: using guessed type int camlList__chop_1243(void);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08053EC0) --------------------------------------------------------
int __usercall camlList__length_aux_1030@<eax>(int result@<eax>, int a2@<ebx>)
{
  while ( a2 != 1 )
  {
    a2 = *(_DWORD *)(a2 + 4);
    result += 2;
  }
  return result;
}

//----- (08053EE0) --------------------------------------------------------
int __usercall camlList__length_1034@<eax>(int a1@<eax>)
{
  return camlList__length_aux_1030(1, a1);
}

//----- (08053EF0) --------------------------------------------------------
int __usercall camlList__hd_1036@<eax>(int a1@<eax>)
{
  if ( a1 == 1 )
    camlPervasives__failwith_1010();
  return *(_DWORD *)a1;
}
// 804F200: using guessed type int camlPervasives__failwith_1010(void);

//----- (08053F10) --------------------------------------------------------
int __usercall camlList__tl_1039@<eax>(int a1@<eax>)
{
  if ( a1 == 1 )
    camlPervasives__failwith_1010();
  return *(_DWORD *)(a1 + 4);
}
// 804F200: using guessed type int camlPervasives__failwith_1010(void);

//----- (08053F30) --------------------------------------------------------
int __usercall camlList__nth_1042@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  if ( a4 < 1 )
    camlPervasives__invalid_arg_1012(a3, a2);
  return camlList__code_begin(a1, a4);
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (08053F50) --------------------------------------------------------
#error "8053F93: call analysis failed (funcsize=20)"

//----- (08053FA0) --------------------------------------------------------
int camlList__rev_1056()
{
  return camlList__rev_append_1051();
}
// 8053F50: using guessed type int camlList__rev_append_1051(void);

//----- (08053FB0) --------------------------------------------------------
int __usercall camlList__flatten_1058@<eax>(int **a1@<eax>)
{
  int v1; // ebx
  int *v3; // [esp+0h] [ebp-4h]

  if ( a1 == (int **)1 )
    return 1;
  v3 = *a1;
  v1 = camlList__flatten_1058();
  return (int)camlPervasives___40_1143(v3, v1);
}

//----- (08053FF0) --------------------------------------------------------
int __usercall camlList__map_1062@<eax>(int (**a1)(void)@<eax>, int a2@<ebx>)
{
  int v2; // ecx
  unsigned int v3; // eax
  int result; // eax
  char v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-4h]

  if ( a2 == 1 )
    return 1;
  v5 = (char)a1;
  v6 = (*a1)();
  v2 = camlList__map_1062();
  while ( 1 )
  {
    v3 = caml_young_ptr - 12;
    caml_young_ptr = v3;
    if ( v3 >= caml_young_limit )
      break;
    caml_call_gc(v5);
  }
  result = v3 + 4;
  *(_DWORD *)(result - 4) = 2048;
  *(_DWORD *)result = v6;
  *(_DWORD *)(result + 4) = v2;
  return result;
}
// 8054043: variable 'v2' is possibly undefined
// 8054059: variable 'v5' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08054060) --------------------------------------------------------
#error "80540A2: call analysis failed (funcsize=16)"

//----- (080540B0) --------------------------------------------------------
int __usercall camlList__iter_1074@<eax>(void (**a1)(void)@<eax>, int a2@<ebx>)
{
  void (**v3)(void); // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  while ( a2 != 1 )
  {
    v3 = a1;
    v4 = *(_DWORD *)(a2 + 4);
    (*a1)();
    a1 = v3;
    a2 = v4;
  }
  return 1;
}

//----- (080540F0) --------------------------------------------------------
int __usercall camlList__fold_left_1078@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // edx
  int result; // eax
  int v5; // [esp+0h] [ebp-8h]
  int v6; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    v3 = a1;
    result = a3;
    if ( a2 == 1 )
      break;
    v5 = v3;
    v6 = *(_DWORD *)(a2 + 4);
    a3 = caml_apply2(v3);
    a1 = v5;
    a2 = v6;
  }
  return result;
}

//----- (08054130) --------------------------------------------------------
int __usercall camlList__fold_right_1084@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  if ( a3 == 1 )
    return a2;
  camlList__fold_right_1084();
  return caml_apply2(a1);
}

//----- (08054170) --------------------------------------------------------
int __usercall camlList__map2_1090@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // ecx
  unsigned int v4; // eax
  int result; // eax
  char v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]

  if ( a3 == 1 )
  {
    if ( a2 == 1 )
      return 1;
LABEL_8:
    camlPervasives__invalid_arg_1012(a2, a1);
  }
  if ( a2 == 1 )
    goto LABEL_8;
  v6 = a1;
  v7 = *(_DWORD *)(a2 + 4);
  v8 = caml_apply2(a1);
  v3 = camlList__map2_1090(v7);
  while ( 1 )
  {
    v4 = caml_young_ptr - 12;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(v6);
  }
  result = v4 + 4;
  *(_DWORD *)(result - 4) = 2048;
  *(_DWORD *)result = v8;
  *(_DWORD *)(result + 4) = v3;
  return result;
}
// 80541D8: variable 'v3' is possibly undefined
// 80541FD: variable 'v6' is possibly undefined
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08054210) --------------------------------------------------------
#error "8054252: call analysis failed (funcsize=16)"

//----- (08054260) --------------------------------------------------------
int __usercall camlList__iter2_1111@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  while ( a3 != 1 )
  {
    if ( a2 == 1 )
      goto LABEL_6;
    v4 = a1;
    v6 = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)(a3 + 4);
    caml_apply2(a1);
    a1 = v4;
    a3 = v5;
    a2 = v6;
  }
  if ( a2 != 1 )
LABEL_6:
    camlPervasives__invalid_arg_1012(a2, a1);
  return 1;
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (080542C0) --------------------------------------------------------
int __usercall camlList__fold_left2_1119@<eax>(int a1@<eax>, int *a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]
  int *v7; // [esp+8h] [ebp-4h]

  while ( a3 != 1 )
  {
    if ( a2 == (int *)1 )
      goto LABEL_6;
    v5 = a1;
    v7 = (int *)a2[1];
    v6 = *(_DWORD *)(a3 + 4);
    a4 = caml_apply3(*a2, a1);
    a1 = v5;
    a3 = v6;
    a2 = v7;
  }
  if ( a2 != (int *)1 )
LABEL_6:
    camlPervasives__invalid_arg_1012(a3, a2);
  return a4;
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (08054320) --------------------------------------------------------
int __usercall camlList__fold_right2_1128@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // eax

  if ( a4 != 1 )
  {
    if ( a3 != 1 )
    {
      v4 = camlList__fold_right2_1128();
      return caml_apply3(v4, a1);
    }
LABEL_6:
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  if ( a3 != 1 )
    goto LABEL_6;
  return a2;
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (08054380) --------------------------------------------------------
int __usercall camlList__for_all_1137@<eax>(int (**a1)(void)@<eax>, int a2@<ebx>)
{
  int (**v3)(void); // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  while ( a2 != 1 )
  {
    v3 = a1;
    v4 = *(_DWORD *)(a2 + 4);
    if ( (*a1)() == 1 )
      return 1;
    a1 = v3;
    a2 = v4;
  }
  return 3;
}

//----- (080543D0) --------------------------------------------------------
int __usercall camlList__exists_1141@<eax>(int (**a1)(void)@<eax>, int a2@<ebx>)
{
  int (**v3)(void); // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  while ( a2 != 1 )
  {
    v3 = a1;
    v4 = *(_DWORD *)(a2 + 4);
    if ( (*a1)() != 1 )
      return 3;
    a1 = v3;
    a2 = v4;
  }
  return 1;
}

//----- (08054420) --------------------------------------------------------
int __usercall camlList__for_all2_1145@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  while ( a3 != 1 )
  {
    if ( a2 == 1 )
      goto LABEL_8;
    v4 = a1;
    v6 = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)(a3 + 4);
    if ( caml_apply2(a1) == 1 )
      return 1;
    a1 = v4;
    a3 = v5;
    a2 = v6;
  }
  if ( a2 != 1 )
LABEL_8:
    camlPervasives__invalid_arg_1012(a2, a1);
  return 3;
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (08054490) --------------------------------------------------------
int __usercall camlList__exists2_1153@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  while ( a3 != 1 )
  {
    if ( a2 == 1 )
      goto LABEL_8;
    v4 = a1;
    v6 = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)(a3 + 4);
    if ( caml_apply2(a1) != 1 )
      return 3;
    a1 = v4;
    a3 = v5;
    a2 = v6;
  }
  if ( a2 != 1 )
LABEL_8:
    camlPervasives__invalid_arg_1012(a2, a1);
  return 1;
}
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);

//----- (08054500) --------------------------------------------------------
int __usercall camlList__mem_1161@<eax>(int a1@<eax>, _DWORD *a2@<ebx>)
{
  int v3; // [esp+0h] [ebp-8h]
  _DWORD *v4; // [esp+4h] [ebp-4h]

  while ( a2 != (_DWORD *)1 )
  {
    v3 = a1;
    v4 = (_DWORD *)a2[1];
    if ( caml_c_call((int (*)(void))caml_compare, *a2) == 1 )
      return 3;
    a1 = v3;
    a2 = v4;
  }
  return 1;
}

//----- (08054560) --------------------------------------------------------
int __usercall camlList__memq_1165@<eax>(int a1@<eax>, _DWORD *a2@<ebx>)
{
  while ( a2 != (_DWORD *)1 )
  {
    if ( *a2 == a1 )
      return 3;
    a2 = (_DWORD *)a2[1];
  }
  return 1;
}

//----- (080545A0) --------------------------------------------------------
int __usercall camlList__assoc_1169@<eax>(int a1@<eax>, _DWORD *a2@<ebx>)
{
  unsigned int v3; // eax
  _DWORD *v4; // eax
  int v5; // [esp+0h] [ebp-Ch]
  _DWORD *v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    if ( a2 == (_DWORD *)1 )
    {
      while ( 1 )
      {
        v3 = caml_young_ptr - 8;
        caml_young_ptr = v3;
        if ( v3 >= caml_young_limit )
        {
          v4 = (_DWORD *)(v3 + 4);
          *(v4 - 1) = 1024;
          *v4 = &caml_exn_Not_found;
          caml_raise_exn((int)v4);
        }
        caml_call_gc(v5);
      }
    }
    v5 = a1;
    v6 = (_DWORD *)a2[1];
    v7 = *(_DWORD *)(*a2 + 4);
    if ( caml_c_call((int (*)(void))caml_compare, *(_DWORD *)*a2) == 1 )
      break;
    a1 = v5;
    a2 = v6;
  }
  return v7;
}
// 805461A: variable 'v5' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08054630) --------------------------------------------------------
#error "805468A: call analysis failed (funcsize=23)"

//----- (080546A0) --------------------------------------------------------
int __usercall camlList__mem_assoc_1179@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v3; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  while ( a2 != 1 )
  {
    v3 = a1;
    v4 = *(_DWORD *)(a2 + 4);
    if ( caml_c_call((int (*)(void))caml_compare, **(_DWORD **)a2) == 1 )
      return 3;
    a1 = v3;
    a2 = v4;
  }
  return 1;
}

//----- (08054700) --------------------------------------------------------
int __usercall camlList__mem_assq_1184@<eax>(int a1@<eax>, int a2@<ebx>)
{
  while ( a2 != 1 )
  {
    if ( **(_DWORD **)a2 == a1 )
      return 3;
    a2 = *(_DWORD *)(a2 + 4);
  }
  return 1;
}

//----- (08054740) --------------------------------------------------------
int __usercall camlList__remove_assoc_1189@<eax>(char a1@<al>, _DWORD *a2@<ebx>)
{
  int result; // eax
  int v3; // ecx
  unsigned int v4; // eax
  _DWORD *v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  if ( a2 == (_DWORD *)1 )
    return 1;
  v7 = a2[1];
  v6 = (_DWORD *)*a2;
  if ( caml_c_call((int (*)(void))caml_compare, *(_DWORD *)*a2) == 1 )
    return v7;
  v3 = camlList__remove_assoc_1189();
  while ( 1 )
  {
    v4 = caml_young_ptr - 12;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(a1);
  }
  result = v4 + 4;
  *(_DWORD *)(result - 4) = 2048;
  *(_DWORD *)result = v6;
  *(_DWORD *)(result + 4) = v3;
  return result;
}
// 80547B3: variable 'v3' is possibly undefined
// 80547C9: variable 'a1' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080547D0) --------------------------------------------------------
int __usercall camlList__remove_assq_1195@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int result; // eax
  int v3; // ecx
  unsigned int v4; // eax
  _DWORD *v5; // [esp+0h] [ebp-4h]

  if ( a2 == 1 )
    return 1;
  if ( **(_DWORD **)a2 == a1 )
    return *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD **)a2;
  v3 = camlList__remove_assq_1195();
  while ( 1 )
  {
    v4 = caml_young_ptr - 12;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc((char)v5);
  }
  result = v4 + 4;
  *(_DWORD *)(result - 4) = 2048;
  *(_DWORD *)result = v5;
  *(_DWORD *)(result + 4) = v3;
  return result;
}
// 805481E: variable 'v5' is possibly undefined
// 8054820: variable 'v3' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08054840) --------------------------------------------------------
int __usercall camlList__find_1201@<eax>(int (**a1)(void)@<eax>, int *a2@<ebx>)
{
  unsigned int v3; // eax
  _DWORD *v4; // eax
  int (**v5)(void); // [esp+0h] [ebp-Ch]
  int *v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    if ( a2 == (int *)1 )
    {
      while ( 1 )
      {
        v3 = caml_young_ptr - 8;
        caml_young_ptr = v3;
        if ( v3 >= caml_young_limit )
        {
          v4 = (_DWORD *)(v3 + 4);
          *(v4 - 1) = 1024;
          *v4 = &caml_exn_Not_found;
          caml_raise_exn((int)v4);
        }
        caml_call_gc((char)v5);
      }
    }
    v5 = a1;
    v6 = (int *)a2[1];
    v7 = *a2;
    if ( (*a1)() != 1 )
      break;
    a1 = v5;
    a2 = v6;
  }
  return v7;
}
// 80548AA: variable 'v5' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080548C0) --------------------------------------------------------
#error "8054901: call analysis failed (funcsize=17)"

//----- (08054910) --------------------------------------------------------
#error "8054959: call analysis failed (funcsize=18)"

//----- (08054960) --------------------------------------------------------
_DWORD *__usercall camlList__split_1220@<eax>(int **a1@<eax>)
{
  int *v1; // eax
  int v2; // ebx
  int v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // ebx
  _DWORD *result; // eax
  int v8; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]

  if ( a1 == (int **)1 )
    return &camlList__41;
  v8 = (*a1)[1];
  v9 = **a1;
  v1 = (int *)camlList__split_1220();
  v2 = v1[1];
  v3 = *v1;
  while ( 1 )
  {
    v4 = (_DWORD *)(caml_young_ptr - 36);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
    caml_call_gc(v8);
  }
  v5 = v4 + 1;
  *v4 = 2048;
  v4[1] = v8;
  v4[2] = v2;
  v6 = v4 + 4;
  v4[3] = 2048;
  v4[4] = v9;
  v4[5] = v3;
  result = v4 + 7;
  *(result - 1) = 2048;
  *result = v6;
  result[1] = v5;
  return result;
}
// 80549A7: variable 'v8' is possibly undefined
// 80549BC: variable 'v3' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080549F0) --------------------------------------------------------
int __usercall camlList__combine_1226@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int *a4@<ebx>)
{
  int v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  int result; // eax
  int v8; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]

  if ( a1 == (int *)1 )
  {
    if ( a4 == (int *)1 )
      return 1;
LABEL_8:
    camlPervasives__invalid_arg_1012(a3, a2);
  }
  if ( a4 == (int *)1 )
    goto LABEL_8;
  v9 = *a4;
  v8 = *a1;
  v4 = camlList__combine_1226();
  while ( 1 )
  {
    v5 = (_DWORD *)(caml_young_ptr - 24);
    caml_young_ptr = (int)v5;
    if ( (unsigned int)v5 >= caml_young_limit )
      break;
    caml_call_gc(v8);
  }
  v6 = v5 + 1;
  *v5 = 2048;
  v5[1] = v8;
  v5[2] = v9;
  result = (int)(v5 + 4);
  *(_DWORD *)(result - 4) = 2048;
  *(_DWORD *)result = v6;
  *(_DWORD *)(result + 4) = v4;
  return result;
}
// 8054A3B: variable 'v8' is possibly undefined
// 8054A50: variable 'v4' is possibly undefined
// 804F240: using guessed type int __fastcall camlPervasives__invalid_arg_1012(_DWORD, _DWORD);
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08054A90) --------------------------------------------------------
int *__usercall camlList__merge_1233@<eax>(int a1@<eax>, int *a2@<ecx>, int *a3@<ebx>)
{
  int v3; // ecx
  _DWORD *v4; // eax
  int *result; // eax
  int v6; // ecx
  _DWORD *v7; // eax
  char v8; // [esp+0h] [ebp-1Ch]
  int v9; // [esp+4h] [ebp-18h]
  int v10; // [esp+8h] [ebp-14h]
  int v12; // [esp+18h] [ebp-4h]

  if ( a3 == (int *)1 )
    return a2;
  if ( a2 == (int *)1 )
    return a3;
  v8 = (char)a3;
  v9 = a2[1];
  v10 = *a2;
  v12 = *a3;
  if ( caml_apply2(a1) > 1 )
  {
    v6 = camlList__merge_1233(v9);
    while ( 1 )
    {
      v7 = (_DWORD *)(caml_young_ptr - 12);
      caml_young_ptr = (int)v7;
      if ( (unsigned int)v7 >= caml_young_limit )
        break;
      caml_call_gc(v8);
    }
    *v7 = 2048;
    v7[1] = v10;
    v7[2] = v6;
    result = v7 + 1;
  }
  else
  {
    v3 = camlList__merge_1233(a2);
    while ( 1 )
    {
      v4 = (_DWORD *)(caml_young_ptr - 12);
      caml_young_ptr = (int)v4;
      if ( (unsigned int)v4 >= caml_young_limit )
        break;
      caml_call_gc(v8);
    }
    *v4 = 2048;
    v4[1] = v12;
    v4[2] = v3;
    result = v4 + 1;
  }
  return result;
}
// 8054B16: variable 'v3' is possibly undefined
// 8054B57: variable 'v6' is possibly undefined
// 8054B76: variable 'v8' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08054B90) --------------------------------------------------------
#error "8054BE1: call analysis failed (funcsize=21)"

//----- (08054BF0) --------------------------------------------------------
_DWORD *__usercall camlList__stable_sort_1248@<eax>(int a1@<eax>, int *a2@<ebx>)
{
  _DWORD *v3; // eax
  int v4; // eax
  _DWORD *result; // eax
  char v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+0h] [ebp-8h]

  while ( 1 )
  {
    v3 = (_DWORD *)(caml_young_ptr - 84);
    caml_young_ptr = (int)v3;
    if ( (unsigned int)v3 >= caml_young_limit )
      break;
    caml_call_gc(v6);
  }
  *v3 = 4343;
  v3[1] = caml_curry3;
  v3[2] = 7;
  v3[3] = camlList__rev_merge_1251;
  v3[4] = a1;
  v3[5] = 4343;
  v3[6] = caml_curry3;
  v3[7] = 7;
  v3[8] = camlList__rev_merge_rev_1261;
  v3[9] = a1;
  v7 = (int)(v3 + 11);
  v3[10] = 10487;
  v3[11] = caml_curry2;
  v3[12] = 5;
  v3[13] = camlList__sort_299;
  v3[14] = 4345;
  v3[15] = caml_curry2;
  v3[16] = 5;
  v3[17] = camlList__rev_sort_300;
  v3[18] = a1;
  v3[19] = v3 + 1;
  v3[20] = v3 + 6;
  v4 = camlList__length_aux_1030(1, (int)a2);
  if ( v4 >= 5 )
    result = camlList__sort_299(v4, v7, a2);
  else
    result = a2;
  return result;
}
// 8054BF0: could not find valid save-restore pair for ebx
// 8054CCF: variable 'v6' is possibly undefined
// 804AFD0: using guessed type _DWORD caml_curry3();
// 804B070: using guessed type _DWORD caml_curry2();
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08054CE0) --------------------------------------------------------
int camlList__entry()
{
  dword_8072964 = (int)&camlList__38;
  camlList = (int)&camlList__37;
  dword_80728C4 = (int)&camlList__36;
  dword_80728C8 = (int)&camlList__35;
  dword_80728CC = (int)&camlList__34;
  dword_80728D4 = dword_8070C14;
  dword_80728D8 = (int)&camlList__33;
  dword_80728D0 = (int)&camlList__32;
  dword_80728E0 = (int)&camlList__31;
  dword_80728DC = (int)&camlList__31;
  dword_80728E8 = (int)&camlList__30;
  dword_80728EC = (int)&camlList__29;
  dword_80728E4 = (int)&camlList__28;
  dword_80728F0 = (int)&camlList__27;
  dword_80728F4 = (int)&camlList__26;
  dword_80728FC = (int)&camlList__25;
  dword_8072900 = (int)&camlList__24;
  dword_80728F8 = (int)&camlList__23;
  dword_8072904 = (int)&camlList__22;
  dword_8072908 = (int)&camlList__21;
  dword_807290C = (int)&camlList__20;
  dword_8072910 = (int)&camlList__19;
  dword_8072914 = (int)&camlList__18;
  dword_8072918 = (int)&camlList__17;
  dword_807291C = (int)&camlList__16;
  dword_8072920 = (int)&camlList__15;
  dword_8072934 = (int)&camlList__14;
  dword_8072938 = (int)&camlList__13;
  dword_807293C = (int)&camlList__12;
  dword_8072940 = (int)&camlList__11;
  dword_8072944 = (int)&camlList__10;
  dword_8072948 = (int)&camlList__9;
  dword_8072924 = (int)&camlList__8;
  dword_807292C = (int)&camlList__7;
  dword_8072928 = (int)&camlList__7;
  dword_8072930 = (int)&camlList__6;
  dword_807294C = (int)&camlList__5;
  dword_8072950 = (int)&camlList__4;
  dword_8072960 = (int)&camlList__3;
  dword_8072968 = (int)&camlList__2;
  dword_8072958 = (int)&camlList__1;
  dword_8072954 = (int)&camlList__1;
  dword_807295C = (int)&camlList__1;
  return 1;
}
// 8070C14: using guessed type int dword_8070C14;
// 80728C0: using guessed type int camlList;
// 80728C4: using guessed type int dword_80728C4;
// 80728C8: using guessed type int dword_80728C8;
// 80728CC: using guessed type int dword_80728CC;
// 80728D0: using guessed type int dword_80728D0;
// 80728D4: using guessed type int dword_80728D4;
// 80728D8: using guessed type int dword_80728D8;
// 80728DC: using guessed type int dword_80728DC;
// 80728E0: using guessed type int dword_80728E0;
// 80728E4: using guessed type int dword_80728E4;
// 80728E8: using guessed type int dword_80728E8;
// 80728EC: using guessed type int dword_80728EC;
// 80728F0: using guessed type int dword_80728F0;
// 80728F4: using guessed type int dword_80728F4;
// 80728F8: using guessed type int dword_80728F8;
// 80728FC: using guessed type int dword_80728FC;
// 8072900: using guessed type int dword_8072900;
// 8072904: using guessed type int dword_8072904;
// 8072908: using guessed type int dword_8072908;
// 807290C: using guessed type int dword_807290C;
// 8072910: using guessed type int dword_8072910;
// 8072914: using guessed type int dword_8072914;
// 8072918: using guessed type int dword_8072918;
// 807291C: using guessed type int dword_807291C;
// 8072920: using guessed type int dword_8072920;
// 8072924: using guessed type int dword_8072924;
// 8072928: using guessed type int dword_8072928;
// 807292C: using guessed type int dword_807292C;
// 8072930: using guessed type int dword_8072930;
// 8072934: using guessed type int dword_8072934;
// 8072938: using guessed type int dword_8072938;
// 807293C: using guessed type int dword_807293C;
// 8072940: using guessed type int dword_8072940;
// 8072944: using guessed type int dword_8072944;
// 8072948: using guessed type int dword_8072948;
// 807294C: using guessed type int dword_807294C;
// 8072950: using guessed type int dword_8072950;
// 8072954: using guessed type int dword_8072954;
// 8072958: using guessed type int dword_8072958;
// 807295C: using guessed type int dword_807295C;
// 8072960: using guessed type int dword_8072960;
// 8072964: using guessed type int dword_8072964;
// 8072968: using guessed type int dword_8072968;
// 8072970: using guessed type int (*camlList__1)();
// 8072980: using guessed type int (*camlList__2)();
// 8072990: using guessed type int (*camlList__3)();
// 80729A0: using guessed type int (*camlList__4)();
// 80729B0: using guessed type int (*camlList__5)();
// 80729BC: using guessed type int (*camlList__6)();
// 80729CC: using guessed type int (*camlList__7)();
// 80729D8: using guessed type int (*camlList__8)();
// 80729E8: using guessed type int (*camlList__9)();
// 80729F8: using guessed type int (*camlList__10)();
// 8072A08: using guessed type int (*camlList__11)();
// 8072A18: using guessed type int (*camlList__12)();
// 8072A28: using guessed type int (*camlList__13)();
// 8072A38: using guessed type int (*camlList__14)();
// 8072A48: using guessed type int (*camlList__15)();
// 8072A58: using guessed type int (*camlList__16)();
// 8072A68: using guessed type int (*camlList__17)();
// 8072A78: using guessed type int (*camlList__18)();
// 8072A88: using guessed type int (*camlList__19)();
// 8072A98: using guessed type int (*camlList__20)();
// 8072AA8: using guessed type int (*camlList__21)();
// 8072AB8: using guessed type int (*camlList__22)();
// 8072AC8: using guessed type int (*camlList__23)();
// 8072AD8: using guessed type int (*camlList__24)();
// 8072AE8: using guessed type int (*camlList__25)();
// 8072AF8: using guessed type int (*camlList__26)();
// 8072B08: using guessed type int (*camlList__27)();
// 8072B18: using guessed type int (*camlList__28)();
// 8072B28: using guessed type int (*camlList__29)();
// 8072B38: using guessed type int (*camlList__30)();
// 8072B48: using guessed type int (*camlList__31)();
// 8072B54: using guessed type int (*camlList__32)();
// 8072B60: using guessed type int (*camlList__33)();
// 8072B70: using guessed type int (*camlList__34)();
// 8072B80: using guessed type int (*camlList__35)();
// 8072B8C: using guessed type int (*camlList__36)();
// 8072B98: using guessed type int (*camlList__37)();
// 8072BA4: using guessed type int (*camlList__38)();

//----- (08054EA0) --------------------------------------------------------
#error "8054ECC: call analysis failed (funcsize=12)"

//----- (08054EE0) --------------------------------------------------------
int __usercall camlSys__set_signal_1057@<eax>(char a1@<al>)
{
  caml_c_call((int (*)(void))caml_install_signal_handler, a1);
  return 1;
}

//----- (08054F00) --------------------------------------------------------
#error "8054F4F: call analysis failed (funcsize=17)"

//----- (08054F60) --------------------------------------------------------
#error "8054FE4: call analysis failed (funcsize=75)"

//----- (08055110) --------------------------------------------------------
int __usercall camlHashtbl__code_begin@<eax>(int *a1@<eax>, int a2@<ebx>)
{
  int result; // eax
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+4h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-4h]

  if ( a1 == (int *)1 )
    return 1;
  v7 = a1[2];
  v6 = a1[1];
  v5 = *a1;
  if ( caml_apply2(**(_DWORD **)(a2 + 8)) == 1 )
  {
    v3 = camlHashtbl__code_begin();
    while ( 1 )
    {
      v4 = caml_young_ptr - 16;
      caml_young_ptr = v4;
      if ( v4 >= caml_young_limit )
        break;
      caml_call_gc(v5);
    }
    result = v4 + 4;
    *(_DWORD *)(result - 4) = 3072;
    *(_DWORD *)result = v5;
    *(_DWORD *)(result + 4) = v6;
    *(_DWORD *)(result + 8) = v3;
  }
  else
  {
    **(_DWORD **)(a2 + 12) -= 2;
    result = v7;
  }
  return result;
}
// 8055191: variable 'v5' is possibly undefined
// 805519A: variable 'v3' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080551C0) --------------------------------------------------------
int __usercall camlHashtbl__find_in_bucket_1213@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // ecx
  unsigned int v3; // eax
  int result; // eax
  int v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    if ( a1 == 1 )
      return 1;
    v5 = *(_DWORD *)(a1 + 8);
    v6 = *(_DWORD *)(a1 + 4);
    if ( caml_apply2(**(_DWORD **)(a2 + 8)) != 1 )
      break;
    a1 = v5;
  }
  v2 = camlHashtbl__find_in_bucket_1213();
  while ( 1 )
  {
    v3 = caml_young_ptr - 12;
    caml_young_ptr = v3;
    if ( v3 >= caml_young_limit )
      break;
    caml_call_gc(v5);
  }
  result = v3 + 4;
  *(_DWORD *)(result - 4) = 2048;
  *(_DWORD *)result = v6;
  *(_DWORD *)(result + 4) = v2;
  return result;
}
// 8055220: variable 'v2' is possibly undefined
// 8055249: variable 'v5' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055250) --------------------------------------------------------
_DWORD *__usercall camlHashtbl__replace_bucket_1221@<eax>(int *a1@<eax>, int a2@<ebx>)
{
  unsigned int v2; // eax
  _DWORD *result; // eax
  int v4; // ecx
  unsigned int v5; // eax
  unsigned int v6; // eax
  _DWORD *v7; // eax
  char v8; // [esp+0h] [ebp-10h]
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  int v11; // [esp+Ch] [ebp-4h]

  if ( a1 == (int *)1 )
  {
    while ( 1 )
    {
      v6 = caml_young_ptr - 8;
      caml_young_ptr = v6;
      if ( v6 >= caml_young_limit )
      {
        v7 = (_DWORD *)(v6 + 4);
        *(v7 - 1) = 1024;
        *v7 = &caml_exn_Not_found;
        caml_raise_exn((int)v7);
      }
      caml_call_gc(v8);
    }
  }
  v11 = a1[2];
  v9 = a1[1];
  v10 = *a1;
  if ( caml_apply2(**(_DWORD **)(a2 + 8)) == 1 )
  {
    v4 = camlHashtbl__replace_bucket_1221();
    while ( 1 )
    {
      v5 = caml_young_ptr - 16;
      caml_young_ptr = v5;
      if ( v5 >= caml_young_limit )
        break;
      caml_call_gc(v9);
    }
    result = (_DWORD *)(v5 + 4);
    *(result - 1) = 3072;
    *result = v10;
    result[1] = v9;
    result[2] = v4;
  }
  else
  {
    while ( 1 )
    {
      v2 = caml_young_ptr - 16;
      caml_young_ptr = v2;
      if ( v2 >= caml_young_limit )
        break;
      caml_call_gc(v9);
    }
    result = (_DWORD *)(v2 + 4);
    *(result - 1) = 3072;
    *result = v10;
    result[1] = *(_DWORD *)(a2 + 16);
    result[2] = v11;
  }
  return result;
}
// 8055250: could not find valid save-restore pair for ebx
// 8055307: variable 'v9' is possibly undefined
// 805530A: variable 'v4' is possibly undefined
// 805534A: variable 'v8' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055370) --------------------------------------------------------
int __usercall camlHashtbl__mem_in_bucket_1230@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v3; // [esp+0h] [ebp-8h]

  while ( a1 != 1 )
  {
    v3 = *(_DWORD *)(a1 + 8);
    if ( caml_apply2(**(_DWORD **)(a2 + 8)) != 1 )
      return 3;
    a1 = v3;
  }
  return 1;
}

//----- (080553C0) --------------------------------------------------------
int __usercall camlHashtbl__insert_bucket_1068@<eax>(int *a1@<eax>, int a2@<ebx>)
{
  int v2; // edx
  unsigned int v3; // edx
  int v4; // ecx
  unsigned int v5; // eax
  int *v6; // eax
  int v7; // esi
  int *v9; // eax
  char v10; // [esp+0h] [ebp-10h]
  int v11; // [esp+4h] [ebp-Ch]
  int v12; // [esp+8h] [ebp-8h]
  int v13; // [esp+Ch] [ebp-4h]

  if ( a1 == (int *)1 )
    return 1;
  v10 = a2;
  v11 = a1[1];
  v12 = *a1;
  camlHashtbl__insert_bucket_1068((int *)a1[2], a2);
  if ( *(int *)(a2 + 12) >> 1 )
  {
    v13 = *(int *)(a2 + 12) >> 1;
    v2 = ((**(int (***)(void))(a2 + 8))() >> 1) % v13;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v3 = 2 * v2 + 1;
  v4 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(v4 - 4) >> 9 > v3 )
  {
    while ( 1 )
    {
      v5 = caml_young_ptr - 16;
      caml_young_ptr = v5;
      if ( v5 >= caml_young_limit )
        break;
      caml_call_gc(v10);
    }
    v6 = (int *)(v5 + 4);
    *(v6 - 1) = 3072;
    *v6 = v12;
    v6[1] = v11;
    v7 = *(_DWORD *)(a2 + 16);
    a2 = *(_DWORD *)(v7 - 4) >> 9;
    if ( a2 > v3 )
    {
      v6[2] = *(_DWORD *)(v7 + 2 * v3 - 2);
      caml_modify((unsigned int *)(v4 + 2 * v3 - 2), (unsigned int)v6);
      return 1;
    }
    caml_ml_array_bound_error();
  }
  v9 = (int *)caml_ml_array_bound_error();
  return camlHashtbl__remove_bucket_1083(v9, a2);
}
// 8055420: variable 'v2' is possibly undefined
// 805546A: variable 'v3' is possibly undefined
// 8055474: variable 'v4' is possibly undefined
// 8055499: variable 'v10' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080554B0) --------------------------------------------------------
int __usercall camlHashtbl__remove_bucket_1083@<eax>(int *a1@<eax>, int a2@<ebx>)
{
  int result; // eax
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+4h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-4h]

  if ( a1 == (int *)1 )
    return 1;
  v7 = a1[2];
  v6 = a1[1];
  v5 = *a1;
  if ( caml_c_call((int (*)(void))caml_compare, *a1) == 1 )
  {
    **(_DWORD **)(a2 + 8) -= 2;
    result = v7;
  }
  else
  {
    v3 = camlHashtbl__remove_bucket_1083();
    while ( 1 )
    {
      v4 = caml_young_ptr - 16;
      caml_young_ptr = v4;
      if ( v4 >= caml_young_limit )
        break;
      caml_call_gc(v5);
    }
    result = v4 + 4;
    *(_DWORD *)(result - 4) = 3072;
    *(_DWORD *)result = v5;
    *(_DWORD *)(result + 4) = v6;
    *(_DWORD *)(result + 8) = v3;
  }
  return result;
}
// 80554B0: could not find valid save-restore pair for ebx
// 8055531: variable 'v5' is possibly undefined
// 805553A: variable 'v3' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055560) --------------------------------------------------------
int __usercall camlHashtbl__find_in_bucket_1108@<eax>(_DWORD *a1@<eax>)
{
  int v1; // ecx
  unsigned int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    if ( a1 == (_DWORD *)1 )
      return 1;
    v4 = (_DWORD *)a1[2];
    v5 = a1[1];
    if ( caml_c_call((int (*)(void))caml_compare, *a1) == 1 )
      break;
    a1 = v4;
  }
  v1 = camlHashtbl__find_in_bucket_1108();
  while ( 1 )
  {
    v2 = caml_young_ptr - 12;
    caml_young_ptr = v2;
    if ( v2 >= caml_young_limit )
      break;
    caml_call_gc((char)v4);
  }
  result = v2 + 4;
  *(_DWORD *)(result - 4) = 2048;
  *(_DWORD *)result = v5;
  *(_DWORD *)(result + 4) = v1;
  return result;
}
// 80555C4: variable 'v1' is possibly undefined
// 80555E9: variable 'v4' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080555F0) --------------------------------------------------------
_DWORD *__usercall camlHashtbl__replace_bucket_1116@<eax>(int *a1@<eax>, int a2@<ebx>)
{
  unsigned int v2; // eax
  _DWORD *result; // eax
  int v4; // ecx
  unsigned int v5; // eax
  unsigned int v6; // eax
  _DWORD *v7; // eax
  char v8; // [esp+0h] [ebp-10h]
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  int v11; // [esp+Ch] [ebp-4h]

  if ( a1 == (int *)1 )
  {
    while ( 1 )
    {
      v6 = caml_young_ptr - 8;
      caml_young_ptr = v6;
      if ( v6 >= caml_young_limit )
      {
        v7 = (_DWORD *)(v6 + 4);
        *(v7 - 1) = 1024;
        *v7 = &caml_exn_Not_found;
        caml_raise_exn((int)v7);
      }
      caml_call_gc(v8);
    }
  }
  v11 = a1[2];
  v9 = a1[1];
  v10 = *a1;
  if ( caml_c_call((int (*)(void))caml_compare, *a1) == 1 )
  {
    while ( 1 )
    {
      v2 = caml_young_ptr - 16;
      caml_young_ptr = v2;
      if ( v2 >= caml_young_limit )
        break;
      caml_call_gc(v9);
    }
    result = (_DWORD *)(v2 + 4);
    *(result - 1) = 3072;
    *result = v10;
    result[1] = *(_DWORD *)(a2 + 12);
    result[2] = v11;
  }
  else
  {
    v4 = camlHashtbl__replace_bucket_1116();
    while ( 1 )
    {
      v5 = caml_young_ptr - 16;
      caml_young_ptr = v5;
      if ( v5 >= caml_young_limit )
        break;
      caml_call_gc(v9);
    }
    result = (_DWORD *)(v5 + 4);
    *(result - 1) = 3072;
    *result = v10;
    result[1] = v9;
    result[2] = v4;
  }
  return result;
}
// 80555F0: could not find valid save-restore pair for ebx
// 80556A7: variable 'v9' is possibly undefined
// 80556AA: variable 'v4' is possibly undefined
// 80556EA: variable 'v8' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055710) --------------------------------------------------------
int __usercall camlHashtbl__mem_in_bucket_1125@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v2; // [esp+0h] [ebp-8h]

  while ( a1 != (_DWORD *)1 )
  {
    v2 = (_DWORD *)a1[2];
    if ( caml_c_call((int (*)(void))caml_compare, *a1) == 1 )
      return 3;
    a1 = v2;
  }
  return 1;
}

//----- (08055770) --------------------------------------------------------
int __usercall camlHashtbl__do_bucket_1132@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v3; // [esp+0h] [ebp-8h]

  while ( a1 != 1 )
  {
    v3 = *(_DWORD *)(a1 + 8);
    caml_apply2(*(_DWORD *)(a2 + 8));
    a1 = v3;
  }
  return 1;
}

//----- (080557B0) --------------------------------------------------------
int __usercall camlHashtbl__do_bucket_1142@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v4; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  while ( a1 != 1 )
  {
    v5 = a2;
    v4 = *(_DWORD *)(a1 + 8);
    a3 = caml_apply3(a3, *(_DWORD *)(a2 + 12));
    a1 = v4;
    a2 = v5;
  }
  return a3;
}

//----- (080557F0) --------------------------------------------------------
int __usercall camlHashtbl__safehash_1177@<eax>(int a1@<ebx>)
{
  return (**(int (***)(void))(*(_DWORD *)(a1 + 8) + 4))() & 0x7FFFFFFF;
}

//----- (08055810) --------------------------------------------------------
int __usercall camlHashtbl__add_1179@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  int v4; // edx
  unsigned int v5; // edx
  unsigned int v6; // eax
  int *v7; // eax
  int v8; // esi
  int v9; // esi
  int result; // eax
  int v11; // eax
  int v12; // ecx
  int v17; // [esp+10h] [ebp-4h]

  if ( *(_DWORD *)(a1[1] - 4) >> 10 )
  {
    v17 = *(_DWORD *)(a1[1] - 4) >> 10;
    v4 = (((**(int (***)(void))(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 8) + 4))() & 0x7FFFFFFF) >> 1) % v17;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v5 = 2 * v4 + 1;
  while ( 1 )
  {
    v6 = caml_young_ptr - 16;
    caml_young_ptr = v6;
    if ( v6 >= caml_young_limit )
      break;
    caml_call_gc(a4);
  }
  v7 = (int *)(v6 + 4);
  *(v7 - 1) = 3072;
  *v7 = a4;
  v7[1] = a3;
  v8 = a1[1];
  if ( *(_DWORD *)(v8 - 4) >> 9 <= v5 )
    goto LABEL_13;
  v7[2] = *(_DWORD *)(v8 + 2 * v5 - 2);
  v9 = a1[1];
  if ( *(_DWORD *)(v9 - 4) >> 9 <= v5 )
  {
    caml_ml_array_bound_error();
LABEL_13:
    v11 = caml_ml_array_bound_error();
    return camlHashtbl__remove_1185(v11, v12, (int (__usercall *)@<eax>(int *@<eax>, int@<ebx>))a1);
  }
  caml_modify((unsigned int *)(v9 + 2 * v5 - 2), (unsigned int)v7);
  *a1 += 2;
  if ( *a1 <= 2 * ((*(_DWORD *)(a1[1] - 4) >> 9) | 1) - 1 )
    result = 1;
  else
    result = camlHashtbl__resize_1061(*(_DWORD *)(a2 + 12), (int)a1);
  return result;
}
// 8055810: could not find valid save-restore pair for ebx
// 8055870: variable 'v4' is possibly undefined
// 8055899: variable 'a4' is possibly undefined
// 805589F: variable 'a3' is possibly undefined
// 80558A6: variable 'a1' is possibly undefined
// 80558B1: variable 'v5' is possibly undefined
// 80558F2: variable 'a2' is possibly undefined
// 805591E: variable 'v12' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055920) --------------------------------------------------------
int __usercall camlHashtbl__remove_1185@<eax>(int a1@<eax>, int a2@<ecx>, int (__usercall *a3)@<eax>(int *a1@<eax>, int a2@<ebx>)@<ebx>)
{
  unsigned int v4; // eax
  int (__usercall **v5)@<eax>(int *@<eax>, int@<ebx>); // eax
  int v6; // edx
  unsigned int v7; // edx
  int v8; // eax
  unsigned int v9; // ebx
  int v10; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // [esp+0h] [ebp-Ch]
  int v15; // [esp+0h] [ebp-Ch]
  int v16; // [esp+4h] [ebp-8h]
  int v17; // [esp+8h] [ebp-4h]
  unsigned int v18; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    v4 = caml_young_ptr - 24;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(v14);
  }
  v5 = (int (__usercall **)@<eax>(int *@<eax>, int@<ebx>))(v4 + 4);
  *(v5 - 1) = (int (__usercall *)@<eax>(int *@<eax>, int@<ebx>))5367;
  *v5 = camlHashtbl__code_begin;
  v5[1] = (int (__usercall *)@<eax>(int *@<eax>, int@<ebx>))3;
  v5[2] = *(int (__usercall **)@<eax>(int *@<eax>, int@<ebx>))(a2 + 12);
  v5[3] = (int (__usercall *)@<eax>(int *@<eax>, int@<ebx>))a1;
  v5[4] = a3;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10 )
  {
    v17 = *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10;
    v16 = (int)v5;
    v14 = a1;
    v6 = (((**(int (***)(void))(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 8) + 4))() & 0x7FFFFFFF) >> 1) % v17;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v7 = 2 * v6 + 1;
  v18 = v7;
  v8 = v14;
  v15 = *(_DWORD *)(v14 + 4);
  v9 = *(_DWORD *)(v15 - 4) >> 9;
  if ( v9 > v7 )
  {
    v9 = *(_DWORD *)(v8 + 4);
    if ( *(_DWORD *)(v9 - 4) >> 9 > v7 )
    {
      v10 = camlHashtbl__code_begin(*(int **)(v9 + 2 * v7 - 2), v16);
      caml_modify((unsigned int *)(v15 + 2 * v18 - 2), v10);
      return 1;
    }
    caml_ml_array_bound_error();
  }
  v12 = caml_ml_array_bound_error();
  return camlHashtbl__find_rec_1193(v12, v13, v9);
}
// 8055955: variable 'a2' is possibly undefined
// 805595B: variable 'a1' is possibly undefined
// 80559B0: variable 'v6' is possibly undefined
// 80559B7: variable 'v14' is possibly undefined
// 80559DF: variable 'v16' is possibly undefined
// 8055A1A: variable 'v13' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055A20) --------------------------------------------------------
int __usercall camlHashtbl__find_rec_1193@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  unsigned int v4; // eax
  _DWORD *v5; // eax
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    if ( a3 == 1 )
    {
      while ( 1 )
      {
        v4 = caml_young_ptr - 8;
        caml_young_ptr = v4;
        if ( v4 >= caml_young_limit )
        {
          v5 = (_DWORD *)(v4 + 4);
          *(v5 - 1) = 1024;
          *v5 = &caml_exn_Not_found;
          caml_raise_exn((int)v5);
        }
        caml_call_gc(v6);
      }
    }
    v8 = a2;
    v6 = a1;
    v7 = *(_DWORD *)(a3 + 8);
    v9 = *(_DWORD *)(a3 + 4);
    if ( caml_apply2(**(_DWORD **)(a2 + 12)) != 1 )
      break;
    a1 = v6;
    a3 = v7;
    a2 = v8;
  }
  return v9;
}
// 8055A9A: variable 'v6' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055AB0) --------------------------------------------------------
int __usercall camlHashtbl__find_226@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // edx
  unsigned int v4; // edx
  int (__usercall *v5)@<eax>(int@<eax>, int@<ebx>); // ebx
  int v6; // ebx
  int result; // eax
  int v8; // eax
  int v9; // eax
  unsigned int v10; // eax
  _DWORD *v11; // eax
  unsigned int v12; // eax
  _DWORD *v13; // eax
  unsigned int v14; // eax
  _DWORD *v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // [esp+0h] [ebp-10h]
  int v19; // [esp+0h] [ebp-10h]
  int v22; // [esp+Ch] [ebp-4h]
  int v23; // [esp+Ch] [ebp-4h]
  int v24; // [esp+Ch] [ebp-4h]
  int v25; // [esp+Ch] [ebp-4h]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10 )
  {
    v22 = *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10;
    v18 = a1;
    v3 = (((**(int (***)(void))(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 8) + 4))() & 0x7FFFFFFF) >> 1) % v22;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v4 = 2 * v3 + 1;
  v5 = *(int (__usercall **)@<eax>(int@<eax>, int@<ebx>))(v18 + 4);
  if ( *((_DWORD *)v5 - 1) >> 9 <= v4 )
  {
    v16 = caml_ml_array_bound_error();
    return camlHashtbl__find_all_1210(v16, v17, v5);
  }
  v6 = *(_DWORD *)((char *)v5 + 2 * v4 - 2);
  if ( v6 == 1 )
  {
    while ( 1 )
    {
LABEL_19:
      v14 = caml_young_ptr - 8;
      caml_young_ptr = v14;
      if ( v14 >= caml_young_limit )
      {
        v15 = (_DWORD *)(v14 + 4);
        *(v15 - 1) = 1024;
        *v15 = &caml_exn_Not_found;
        caml_raise_exn((int)v15);
      }
      caml_call_gc(v18);
    }
  }
  v18 = *(_DWORD *)(v6 + 8);
  v23 = *(_DWORD *)(v6 + 4);
  if ( caml_apply2(**(_DWORD **)(a2 + 12)) != 1 )
    return v23;
  v8 = v18;
  if ( v18 == 1 )
  {
LABEL_17:
    while ( 1 )
    {
      v12 = caml_young_ptr - 8;
      caml_young_ptr = v12;
      if ( v12 >= caml_young_limit )
        break;
      caml_call_gc(v18);
    }
    v13 = (_DWORD *)(v12 + 4);
    *(v13 - 1) = 1024;
    *v13 = &caml_exn_Not_found;
    caml_raise_exn((int)v13);
    goto LABEL_19;
  }
  v18 = *(_DWORD *)(v18 + 8);
  v24 = *(_DWORD *)(v8 + 4);
  if ( caml_apply2(**(_DWORD **)(a2 + 12)) != 1 )
    return v24;
  v9 = v18;
  if ( v18 == 1 )
  {
    while ( 1 )
    {
      v10 = caml_young_ptr - 8;
      caml_young_ptr = v10;
      if ( v10 >= caml_young_limit )
        break;
      caml_call_gc(v18);
    }
    v11 = (_DWORD *)(v10 + 4);
    *(v11 - 1) = 1024;
    *v11 = &caml_exn_Not_found;
    caml_raise_exn((int)v11);
    goto LABEL_17;
  }
  v19 = *(_DWORD *)(v18 + 8);
  v25 = *(_DWORD *)(v9 + 4);
  if ( caml_apply2(**(_DWORD **)(a2 + 12)) == 1 )
    result = camlHashtbl__find_rec_1193(a3, *(_DWORD *)(a2 + 20), v19);
  else
    result = v25;
  return result;
}
// 8055B10: variable 'v3' is possibly undefined
// 8055B16: variable 'v18' is possibly undefined
// 8055B47: variable 'a2' is possibly undefined
// 8055C01: variable 'a3' is possibly undefined
// 8055CBA: variable 'v17' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055CC0) --------------------------------------------------------
int __usercall camlHashtbl__find_all_1210@<eax>(int a1@<eax>, int a2@<ecx>, int (__usercall *a3)@<eax>(int a1@<eax>, int a2@<ebx>)@<ebx>)
{
  unsigned int v4; // eax
  int (__usercall **v5)@<eax>(int@<eax>, int@<ebx>); // eax
  int v6; // edx
  unsigned int v7; // edx
  int v8; // ebx
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // [esp+0h] [ebp-Ch]
  int v14; // [esp+4h] [ebp-8h]
  int v15; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    v4 = caml_young_ptr - 20;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(v13);
  }
  v5 = (int (__usercall **)@<eax>(int@<eax>, int@<ebx>))(v4 + 4);
  *(v5 - 1) = (int (__usercall *)@<eax>(int@<eax>, int@<ebx>))4343;
  *v5 = camlHashtbl__find_in_bucket_1213;
  v5[1] = (int (__usercall *)@<eax>(int@<eax>, int@<ebx>))3;
  v5[2] = *(int (__usercall **)@<eax>(int@<eax>, int@<ebx>))(a2 + 12);
  v5[3] = a3;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10 )
  {
    v15 = *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10;
    v14 = (int)v5;
    v13 = a1;
    v6 = (((**(int (***)(void))(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 8) + 4))() & 0x7FFFFFFF) >> 1) % v15;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v7 = 2 * v6 + 1;
  v8 = *(_DWORD *)(v13 + 4);
  if ( *(_DWORD *)(v8 - 4) >> 9 > v7 )
    return camlHashtbl__find_in_bucket_1213(*(_DWORD *)(v8 + 2 * v7 - 2), v14);
  v10 = (_DWORD *)caml_ml_array_bound_error();
  return camlHashtbl__replace_1217(v10, v11, v12, v8);
}
// 8055CF5: variable 'a2' is possibly undefined
// 8055CFE: variable 'a1' is possibly undefined
// 8055D50: variable 'v6' is possibly undefined
// 8055D56: variable 'v13' is possibly undefined
// 8055D6E: variable 'v14' is possibly undefined
// 8055D8A: variable 'v11' is possibly undefined
// 8055D8A: variable 'v12' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055D90) --------------------------------------------------------
int __usercall camlHashtbl__replace_1217@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)
{
  unsigned int v5; // eax
  _DWORD *v6; // eax
  int v7; // edx
  unsigned int v8; // edx
  int v9; // ecx
  char ***v10; // eax
  char **v11; // ebx
  int v12; // edx
  _DWORD *v13; // eax
  int result; // eax
  int *v15; // eax
  unsigned int v16; // edx
  _DWORD *v17; // [esp+0h] [ebp-20h]
  int v19; // [esp+8h] [ebp-18h]
  int *v20; // [esp+8h] [ebp-18h]
  unsigned int v22; // [esp+18h] [ebp-8h]

  v5 = caml_young_ptr - 24;
  caml_young_ptr = v5;
  if ( v5 < caml_young_limit )
    JUMPOUT(0x8055F68);
  v6 = (_DWORD *)(v5 + 4);
  *(v6 - 1) = 5367;
  *v6 = camlHashtbl__replace_bucket_1221;
  v6[1] = 3;
  v6[2] = *(_DWORD *)(a2 + 12);
  v6[3] = a4;
  v6[4] = a3;
  if ( *(_DWORD *)(a1[1] - 4) >> 10 )
  {
    v19 = *(_DWORD *)(a1[1] - 4) >> 10;
    v17 = a1;
    v7 = (((**(int (***)(void))(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 8) + 4))() & 0x7FFFFFFF) >> 1) % v19;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v8 = 2 * v7 + 1;
  v22 = v8;
  v9 = v17[1];
  if ( *(_DWORD *)(v9 - 4) >> 9 <= v8 )
    JUMPOUT(0x8055F7C);
  v20 = *(int **)(v9 + 2 * v8 - 2);
  v10 = (char ***)sub_8055F10(v20, v8, (int)v17);
  v11 = *v10;
  if ( *v10 == &caml_exn_Not_found )
  {
    v12 = v17[1];
    if ( *(_DWORD *)(v12 - 4) >> 9 <= v22 )
      JUMPOUT(0x8055F77);
    v13 = (_DWORD *)(caml_young_ptr - 16);
    caml_young_ptr = (int)v13;
    if ( (unsigned int)v13 < caml_young_limit )
      JUMPOUT(0x8055F5E);
    *v13 = 3072;
    v13[1] = a4;
    v13[2] = a3;
    v13[3] = v20;
    caml_modify((unsigned int *)(v12 + 2 * v22 - 2), (unsigned int)(v13 + 1));
    *v17 += 2;
    if ( *v17 <= 2 * ((*(_DWORD *)(v17[1] - 4) >> 9) | 1) - 1 )
      result = 1;
    else
      result = camlHashtbl__resize_1061(*(_DWORD *)(a2 + 16), (int)v17);
  }
  else
  {
    v15 = (int *)caml_raise_exn((int)v10);
    result = sub_8055F10(v15, v16, (int)v11);
  }
  return result;
}
// 8055DA8: control flows out of bounds to 8055F68
// 8055E45: control flows out of bounds to 8055F7C
// 8055E79: control flows out of bounds to 8055F77
// 8055E92: control flows out of bounds to 8055F5E
// 8055E30: variable 'v7' is possibly undefined
// 8055E3A: variable 'v17' is possibly undefined
// 8055EA6: variable 'a4' is possibly undefined
// 8055EAC: variable 'a3' is possibly undefined
// 8055EE1: variable 'a2' is possibly undefined
// 8055F0A: variable 'v16' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08055F10) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_8055F10@<eax>(int *a1@<eax>, unsigned int a2@<edx>, int a3@<ebx>)
{
  int (__usercall *v3)@<eax>(int@<eax>, int@<ebx>); // ebx
  _DWORD *v4; // eax
  int result; // eax
  int v6; // eax
  int v7; // ecx
  _DWORD v8[7]; // [esp-28h] [ebp-28h] BYREF
  int v9; // [esp-Ch] [ebp-Ch]
  int v10; // [esp-8h] [ebp-8h]

  v8[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v8;
  v9 = *(_DWORD *)(a3 + 4);
  v3 = (int (__usercall *)@<eax>(int@<eax>, int@<ebx>))(*(_DWORD *)(v9 - 4) >> 9);
  if ( (unsigned int)v3 <= a2 )
  {
    caml_ml_array_bound_error();
    caml_ml_array_bound_error();
    v6 = caml_ml_array_bound_error();
    result = camlHashtbl__mem_1227(v6, v7, v3);
  }
  else
  {
    v4 = camlHashtbl__replace_bucket_1221(a1, v8[6]);
    caml_modify((unsigned int *)(v9 + 2 * v10 - 2), (unsigned int)v4);
    result = 1;
    caml_exception_pointer = v8[0];
  }
  return result;
}
// 8055F5D: positive sp value 24 has been found
// 8055F81: variable 'v7' is possibly undefined
// 8074740: using guessed type int caml_exception_pointer;

//----- (08055F90) --------------------------------------------------------
int __usercall camlHashtbl__mem_1227@<eax>(int a1@<eax>, int a2@<ecx>, int (__usercall *a3)@<eax>(int a1@<eax>, int a2@<ebx>)@<ebx>)
{
  unsigned int v4; // eax
  int (__usercall **v5)@<eax>(int@<eax>, int@<ebx>); // eax
  int v6; // edx
  unsigned int v7; // edx
  int v8; // ebx
  unsigned int v10; // eax
  int v11; // [esp+0h] [ebp-Ch]
  int v12; // [esp+4h] [ebp-8h]
  int v13; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    v4 = caml_young_ptr - 20;
    caml_young_ptr = v4;
    if ( v4 >= caml_young_limit )
      break;
    caml_call_gc(v11);
  }
  v5 = (int (__usercall **)@<eax>(int@<eax>, int@<ebx>))(v4 + 4);
  *(v5 - 1) = (int (__usercall *)@<eax>(int@<eax>, int@<ebx>))4343;
  *v5 = camlHashtbl__mem_in_bucket_1230;
  v5[1] = (int (__usercall *)@<eax>(int@<eax>, int@<ebx>))3;
  v5[2] = *(int (__usercall **)@<eax>(int@<eax>, int@<ebx>))(a2 + 12);
  v5[3] = a3;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10 )
  {
    v13 = *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10;
    v12 = (int)v5;
    v11 = a1;
    v6 = (((**(int (***)(void))(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 8) + 4))() & 0x7FFFFFFF) >> 1) % v13;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v7 = 2 * v6 + 1;
  v8 = *(_DWORD *)(v11 + 4);
  if ( *(_DWORD *)(v8 - 4) >> 9 > v7 )
    return camlHashtbl__mem_in_bucket_1230(*(_DWORD *)(v8 + 2 * v7 - 2), v12);
  v10 = caml_ml_array_bound_error();
  return camlHashtbl__hash_1031(v10);
}
// 8055FC5: variable 'a2' is possibly undefined
// 8055FCE: variable 'a1' is possibly undefined
// 8056020: variable 'v6' is possibly undefined
// 8056026: variable 'v11' is possibly undefined
// 805603E: variable 'v12' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056060) --------------------------------------------------------
int __usercall camlHashtbl__hash_1031@<eax>(unsigned int a1@<eax>)
{
  return caml_hash_univ_param(21, 201, a1);
}

//----- (08056080) --------------------------------------------------------
#error "80560D2: call analysis failed (funcsize=23)"

//----- (080560E0) --------------------------------------------------------
int __usercall camlHashtbl__clear_1054@<eax>(_DWORD *a1@<eax>)
{
  unsigned int v2; // ebx
  int v3; // esi
  int v4; // ecx
  unsigned int v5; // eax
  int result; // eax
  int v7; // eax

  v2 = 1;
  v3 = ((*(_DWORD *)(a1[1] - 4) >> 9) | 1) - 2;
  if ( v3 < 1 )
  {
LABEL_4:
    *a1 = 1;
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v4 = a1[1];
      if ( *(_DWORD *)(v4 - 4) >> 9 <= v2 )
        break;
      caml_modify((unsigned int *)(v4 + 2 * v2 - 2), 1u);
      v5 = v2;
      v2 += 2;
      if ( v5 == v3 )
        goto LABEL_4;
    }
    v7 = caml_ml_array_bound_error();
    result = (int)camlHashtbl__copy_1057(v7);
  }
  return result;
}

//----- (08056130) --------------------------------------------------------
_DWORD *__usercall camlHashtbl__copy_1057@<eax>(int a1@<eax>)
{
  void *v1; // ecx
  unsigned int v2; // eax
  _DWORD *result; // eax

  v1 = camlArray__copy_1049(*(double **)(a1 + 4));
  while ( 1 )
  {
    v2 = caml_young_ptr - 12;
    caml_young_ptr = v2;
    if ( v2 >= caml_young_limit )
      break;
    caml_call_gc(a1);
  }
  result = (_DWORD *)(v2 + 4);
  *(result - 1) = 2048;
  *result = *(_DWORD *)a1;
  result[1] = v1;
  return result;
}
// 8056162: variable 'a1' is possibly undefined
// 8056166: variable 'v1' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056180) --------------------------------------------------------
int __usercall camlHashtbl__length_1059@<eax>(int a1@<eax>)
{
  return *(_DWORD *)a1;
}

//----- (08056190) --------------------------------------------------------
int __usercall camlHashtbl__resize_1061@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // eax
  int v3; // ebx
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  unsigned int v6; // eax
  int v7; // ecx
  int result; // eax
  _DWORD *v9; // eax
  unsigned int v10; // ecx
  int v12; // [esp+0h] [ebp-18h]
  int v13; // [esp+4h] [ebp-14h]
  int v14; // [esp+4h] [ebp-14h]
  int v15; // [esp+8h] [ebp-10h]
  int v16; // [esp+8h] [ebp-10h]
  unsigned int v18; // [esp+14h] [ebp-4h]

  v18 = *(_DWORD *)(a2 + 4);
  v15 = (*(_DWORD *)(v18 - 4) >> 9) | 1;
  v2 = camlPervasives__min_1022(4 * (v15 >> 1) + 3, dword_8073450);
  if ( v2 == v15 )
    return 1;
  v13 = v2;
  v3 = caml_c_call((int (*)(void))caml_make_vect, v2);
  while ( 1 )
  {
    v4 = (_DWORD *)(caml_young_ptr - 24);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
    caml_call_gc(a1);
  }
  v5 = v4 + 1;
  *v4 = 5367;
  v4[1] = camlHashtbl__insert_bucket_1068;
  v4[2] = 3;
  v4[3] = a1;
  v4[4] = v13;
  v4[5] = v3;
  v6 = 1;
  if ( v15 - 2 < 1 )
  {
LABEL_8:
    caml_modify((unsigned int *)(a2 + 4), v3);
    result = 1;
  }
  else
  {
    v16 = v15 - 2;
    v14 = 1;
    v12 = (int)v5;
    while ( *(_DWORD *)(v18 - 4) >> 9 > v6 )
    {
      camlHashtbl__insert_bucket_1068(*(int **)(v18 + 2 * v6 - 2), v12);
      v7 = v14;
      v6 = v14 + 2;
      v14 += 2;
      if ( v7 == v16 )
        goto LABEL_8;
    }
    v9 = (_DWORD *)caml_ml_array_bound_error();
    result = camlHashtbl__add_1074(v9, v10, v18);
  }
  return result;
}
// 805621F: variable 'a1' is possibly undefined
// 80562BA: variable 'v10' is possibly undefined
// 8073450: using guessed type int dword_8073450;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080562C0) --------------------------------------------------------
int __usercall camlHashtbl__add_1074@<eax>(_DWORD *a1@<eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>)
{
  int v4; // esi
  int v5; // edx
  unsigned int v6; // edx
  unsigned int v7; // eax
  unsigned int *v8; // eax
  int v9; // ecx
  unsigned int v10; // ebx
  int v11; // ecx
  int result; // eax
  int v13; // eax

  v4 = *(_DWORD *)(a1[1] - 4) >> 10;
  if ( v4 )
    v5 = (caml_hash_univ_param(21, 201, a3) >> 1) % v4;
  else
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  v6 = 2 * v5 + 1;
  while ( 1 )
  {
    v7 = caml_young_ptr - 16;
    caml_young_ptr = v7;
    if ( v7 >= caml_young_limit )
      break;
    caml_call_gc(a2);
  }
  v8 = (unsigned int *)(v7 + 4);
  *(v8 - 1) = 3072;
  *v8 = a3;
  v8[1] = a2;
  v9 = a1[1];
  v10 = *(_DWORD *)(v9 - 4) >> 9;
  if ( v10 <= v6 )
    goto LABEL_13;
  v8[2] = *(_DWORD *)(v9 + 2 * v6 - 2);
  v11 = a1[1];
  v10 = *(_DWORD *)(v11 - 4) >> 9;
  if ( v10 <= v6 )
  {
    caml_ml_array_bound_error();
LABEL_13:
    v13 = caml_ml_array_bound_error();
    return camlHashtbl__remove_1080(v13, v10);
  }
  caml_modify((unsigned int *)(v11 + 2 * v6 - 2), (unsigned int)v8);
  *a1 += 2;
  if ( *a1 <= 2 * ((*(_DWORD *)(a1[1] - 4) >> 9) | 1) - 1 )
    result = 1;
  else
    result = camlHashtbl__resize_1061(dword_80735D0, (int)a1);
  return result;
}
// 8056300: variable 'v5' is possibly undefined
// 805632B: variable 'a2' is possibly undefined
// 8056339: variable 'v6' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 80735D0: using guessed type int dword_80735D0;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080563B0) --------------------------------------------------------
int __usercall camlHashtbl__remove_1080@<eax>(int a1@<eax>, unsigned int a2@<ebx>)
{
  _DWORD *v4; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // edx
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v12; // eax
  char v13; // [esp+0h] [ebp-8h]
  int v14; // [esp+0h] [ebp-8h]
  unsigned int v15; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    v4 = (_DWORD *)(caml_young_ptr - 20);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
    caml_call_gc(v13);
  }
  v5 = (int)(v4 + 1);
  *v4 = 4343;
  v4[1] = camlHashtbl__remove_bucket_1083;
  v4[2] = 3;
  v4[3] = a1;
  v4[4] = a2;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10;
  if ( v6 )
    v7 = (caml_hash_univ_param(21, 201, a2) >> 1) % v6;
  else
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  v8 = 2 * v7 + 1;
  v15 = v8;
  v14 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v14 - 4) >> 9 > v8 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)(v9 - 4) >> 9 > v8 )
    {
      v10 = camlHashtbl__remove_bucket_1083(*(int **)(v9 + 2 * v8 - 2), v5);
      caml_modify((unsigned int *)(v14 + 2 * v15 - 2), v10);
      return 1;
    }
    caml_ml_array_bound_error();
  }
  v12 = caml_ml_array_bound_error();
  return camlHashtbl__find_rec_1088(v12, v5);
}
// 80563EA: variable 'a2' is possibly undefined
// 8056430: variable 'v7' is possibly undefined
// 805647C: variable 'v13' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056490) --------------------------------------------------------
int __usercall camlHashtbl__find_rec_1088@<eax>(int a1@<eax>, int a2@<ebx>)
{
  unsigned int v3; // eax
  _DWORD *v4; // eax
  int v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  while ( 1 )
  {
    if ( a2 == 1 )
    {
      while ( 1 )
      {
        v3 = caml_young_ptr - 8;
        caml_young_ptr = v3;
        if ( v3 >= caml_young_limit )
        {
          v4 = (_DWORD *)(v3 + 4);
          *(v4 - 1) = 1024;
          *v4 = &caml_exn_Not_found;
          caml_raise_exn((int)v4);
        }
        caml_call_gc(v5);
      }
    }
    v5 = a1;
    v6 = *(_DWORD *)(a2 + 8);
    v7 = *(_DWORD *)(a2 + 4);
    if ( caml_c_call((int (*)(void))caml_compare, a1) == 1 )
      break;
    a1 = v5;
    a2 = v6;
  }
  return v7;
}
// 805650A: variable 'v5' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056520) --------------------------------------------------------
int __usercall camlHashtbl__find_1093@<eax>(int a1@<eax>, char a2@<bl>)
{
  int v3; // esi
  int v4; // edx
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // ecx
  int result; // eax
  int v9; // eax
  int v10; // eax
  unsigned int v11; // eax
  _DWORD *v12; // eax
  unsigned int v13; // eax
  _DWORD *v14; // eax
  unsigned int v15; // eax
  _DWORD *v16; // eax
  int v17; // [esp+0h] [ebp-Ch]
  int v18; // [esp+0h] [ebp-Ch]
  int v19; // [esp+8h] [ebp-4h]
  int v20; // [esp+8h] [ebp-4h]
  int v21; // [esp+8h] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10;
  if ( v3 )
    v4 = (caml_hash_univ_param(21, 201, a2) >> 1) % v3;
  else
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  v5 = 2 * v4 + 1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v6 - 4) >> 9 <= v5 )
  {
    caml_ml_array_bound_error();
    return camlHashtbl__find_all_1105();
  }
  v7 = *(_DWORD *)(v6 + 2 * v5 - 2);
  if ( v7 == 1 )
  {
    while ( 1 )
    {
LABEL_19:
      v15 = caml_young_ptr - 8;
      caml_young_ptr = v15;
      if ( v15 >= caml_young_limit )
      {
        v16 = (_DWORD *)(v15 + 4);
        *(v16 - 1) = 1024;
        *v16 = &caml_exn_Not_found;
        caml_raise_exn((int)v16);
      }
      caml_call_gc(v17);
    }
  }
  v17 = *(_DWORD *)(v7 + 8);
  v19 = *(_DWORD *)(v7 + 4);
  if ( caml_c_call((int (*)(void))caml_compare, a2) == 1 )
    return v19;
  v9 = v17;
  if ( v17 == 1 )
  {
LABEL_17:
    while ( 1 )
    {
      v13 = caml_young_ptr - 8;
      caml_young_ptr = v13;
      if ( v13 >= caml_young_limit )
        break;
      caml_call_gc(v17);
    }
    v14 = (_DWORD *)(v13 + 4);
    *(v14 - 1) = 1024;
    *v14 = &caml_exn_Not_found;
    caml_raise_exn((int)v14);
    goto LABEL_19;
  }
  v17 = *(_DWORD *)(v17 + 8);
  v20 = *(_DWORD *)(v9 + 4);
  if ( caml_c_call((int (*)(void))caml_compare, a2) == 1 )
    return v20;
  v10 = v17;
  if ( v17 == 1 )
  {
    while ( 1 )
    {
      v11 = caml_young_ptr - 8;
      caml_young_ptr = v11;
      if ( v11 >= caml_young_limit )
        break;
      caml_call_gc(v17);
    }
    v12 = (_DWORD *)(v11 + 4);
    *(v12 - 1) = 1024;
    *v12 = &caml_exn_Not_found;
    caml_raise_exn((int)v12);
    goto LABEL_17;
  }
  v18 = *(_DWORD *)(v17 + 8);
  v21 = *(_DWORD *)(v10 + 4);
  if ( caml_c_call((int (*)(void))caml_compare, a2) == 1 )
    result = v21;
  else
    result = camlHashtbl__find_rec_1088(a2, v18);
  return result;
}
// 8056560: variable 'v4' is possibly undefined
// 80566CA: variable 'v17' is possibly undefined
// 80566F0: using guessed type int camlHashtbl__find_all_1105(void);
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080566F0) --------------------------------------------------------
#error "8056779: call analysis failed (funcsize=44)"

//----- (08056790) --------------------------------------------------------
int __usercall camlHashtbl__replace_1112@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>)
{
  _DWORD *v4; // eax
  int v5; // esi
  int v6; // edx
  unsigned int v7; // edx
  int v8; // ebx
  char ***v9; // eax
  int v10; // edx
  _DWORD *v11; // eax
  int result; // eax
  int *v13; // eax
  unsigned int v14; // edx
  _DWORD *v15; // [esp+0h] [ebp-1Ch]
  int *v18; // [esp+Ch] [ebp-10h]
  unsigned int v19; // [esp+18h] [ebp-4h]

  v4 = (_DWORD *)(caml_young_ptr - 20);
  caml_young_ptr = (int)v4;
  if ( (unsigned int)v4 < caml_young_limit )
    JUMPOUT(0x8056948);
  *v4 = 4343;
  v4[1] = camlHashtbl__replace_bucket_1116;
  v4[2] = 3;
  v4[3] = a3;
  v4[4] = a2;
  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 4) - 4) >> 10;
  if ( v5 )
  {
    v15 = (_DWORD *)a1;
    v6 = (caml_hash_univ_param(21, 201, a3) >> 1) % v5;
  }
  else
  {
    caml_raise_exn((int)&caml_bucket_Division_by_zero);
  }
  v7 = 2 * v6 + 1;
  v19 = v7;
  v8 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v8 - 4) >> 9 <= v7 )
    JUMPOUT(0x805695C);
  v18 = *(int **)(v8 + 2 * v7 - 2);
  v9 = (char ***)sub_80568F0(v18, v7, a1);
  if ( *v9 == &caml_exn_Not_found )
  {
    v10 = v15[1];
    if ( *(_DWORD *)(v10 - 4) >> 9 <= v19 )
      JUMPOUT(0x8056957);
    v11 = (_DWORD *)(caml_young_ptr - 16);
    caml_young_ptr = (int)v11;
    if ( (unsigned int)v11 < caml_young_limit )
      JUMPOUT(0x805693E);
    *v11 = 3072;
    v11[1] = a3;
    v11[2] = a2;
    v11[3] = v18;
    caml_modify((unsigned int *)(v10 + 2 * v19 - 2), (unsigned int)(v11 + 1));
    *v15 += 2;
    if ( *v15 <= 2 * ((*(_DWORD *)(v15[1] - 4) >> 9) | 1) - 1 )
      result = 1;
    else
      result = camlHashtbl__resize_1061(dword_80735D0, (int)v15);
  }
  else
  {
    v13 = (int *)caml_raise_exn((int)v9);
    result = sub_80568F0(v13, v14, a1);
  }
  return result;
}
// 80567A8: control flows out of bounds to 8056948
// 8056822: control flows out of bounds to 805695C
// 8056856: control flows out of bounds to 8056957
// 805686F: control flows out of bounds to 805693E
// 8056810: variable 'v6' is possibly undefined
// 8056847: variable 'v15' is possibly undefined
// 8056883: variable 'a3' is possibly undefined
// 8056889: variable 'a2' is possibly undefined
// 80568EA: variable 'v14' is possibly undefined
// 806DD50: using guessed type char **caml_bucket_Division_by_zero;
// 806DD58: using guessed type char *caml_exn_Not_found;
// 80735D0: using guessed type int dword_80735D0;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080568F0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_80568F0@<eax>(int *a1@<eax>, unsigned int a2@<edx>, int a3@<edi>)
{
  _DWORD *v3; // eax
  int result; // eax
  _DWORD v5[7]; // [esp-24h] [ebp-24h] BYREF
  int v6; // [esp-8h] [ebp-8h]
  int v7; // [esp-4h] [ebp-4h]

  v5[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v5;
  v6 = *(_DWORD *)(a3 + 4);
  if ( *(_DWORD *)(v6 - 4) >> 9 <= a2 )
  {
    caml_ml_array_bound_error();
    caml_ml_array_bound_error();
    caml_ml_array_bound_error();
    result = camlHashtbl__mem_1122();
  }
  else
  {
    v3 = camlHashtbl__replace_bucket_1116(a1, v5[6]);
    caml_modify((unsigned int *)(v6 + 2 * v7 - 2), (unsigned int)v3);
    result = 1;
    caml_exception_pointer = v5[0];
  }
  return result;
}
// 805693D: positive sp value 20 has been found
// 8056970: using guessed type _DWORD camlHashtbl__mem_1122();
// 8074740: using guessed type int caml_exception_pointer;

//----- (08056970) --------------------------------------------------------
#error "80569F9: call analysis failed (funcsize=44)"

//----- (08056A10) --------------------------------------------------------
int __usercall camlHashtbl__iter_1129@<eax>(int a1@<eax>, int a2@<ebx>)
{
  _DWORD *v3; // eax
  _DWORD *v4; // ecx
  int v5; // edx
  unsigned int v6; // eax
  int v7; // ecx
  int v9; // eax
  int v10; // ecx
  char v11; // [esp+0h] [ebp-10h]
  int v12; // [esp+0h] [ebp-10h]
  int v13; // [esp+4h] [ebp-Ch]
  int v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v3 = (_DWORD *)(caml_young_ptr - 16);
    caml_young_ptr = (int)v3;
    if ( (unsigned int)v3 >= caml_young_limit )
      break;
    caml_call_gc(v11);
  }
  v4 = v3 + 1;
  *v3 = 3319;
  v3[1] = camlHashtbl__do_bucket_1132;
  v3[2] = 3;
  v3[3] = a1;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = 1;
  if ( ((*(_DWORD *)(v5 - 4) >> 9) | 1) - 2 < 1 )
    return 1;
  v15 = ((*(_DWORD *)(v5 - 4) >> 9) | 1) - 2;
  v14 = 1;
  v12 = *(_DWORD *)(a2 + 4);
  v13 = (int)v4;
  while ( *(_DWORD *)(v12 - 4) >> 9 > v6 )
  {
    camlHashtbl__do_bucket_1132(*(_DWORD *)(v12 + 2 * v6 - 2), v13);
    v7 = v14;
    v6 = v14 + 2;
    v14 += 2;
    if ( v7 == v15 )
      return 1;
  }
  v9 = caml_ml_array_bound_error();
  return (int)camlHashtbl__fold_1138(v9, v10, v12);
}
// 8056A41: variable 'a1' is possibly undefined
// 8056AA3: variable 'v11' is possibly undefined
// 8056ABA: variable 'v10' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056AC0) --------------------------------------------------------
int *__usercall camlHashtbl__fold_1138@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  _DWORD *v4; // eax
  _DWORD *v5; // edx
  int v6; // esi
  unsigned int *v7; // ebx
  unsigned int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  int (__usercall *v13)@<eax>(int@<ebx>); // eax
  char v14; // [esp+0h] [ebp-14h]
  int v15; // [esp+4h] [ebp-10h]
  unsigned int *v16; // [esp+8h] [ebp-Ch]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]

  while ( 1 )
  {
    v4 = (_DWORD *)(caml_young_ptr - 28);
    caml_young_ptr = (int)v4;
    if ( (unsigned int)v4 >= caml_young_limit )
      break;
    caml_call_gc(v14);
  }
  v5 = v4 + 1;
  *v4 = 4343;
  v4[1] = caml_curry2;
  v4[2] = 5;
  v4[3] = camlHashtbl__do_bucket_1142;
  v4[4] = a1;
  v6 = *(_DWORD *)(a3 + 4);
  v7 = v4 + 6;
  v4[5] = 1024;
  v4[6] = a2;
  v8 = 1;
  if ( ((*(_DWORD *)(v6 - 4) >> 9) | 1) - 2 < 1 )
    return (int *)*v7;
  v18 = ((*(_DWORD *)(v6 - 4) >> 9) | 1) - 2;
  v17 = 1;
  v16 = v7;
  v15 = (int)v5;
  while ( 1 )
  {
    v9 = *v7;
    if ( *(_DWORD *)(v6 - 4) >> 9 <= v8 )
      break;
    v10 = camlHashtbl__do_bucket_1142(*(_DWORD *)(v6 + 2 * v8 - 2), v15, v9);
    v7 = v16;
    caml_modify(v16, v10);
    v11 = v17;
    v8 = v17 + 2;
    v17 += 2;
    if ( v11 == v18 )
      return (int *)*v7;
  }
  v13 = (int (__usercall *)@<eax>(int@<ebx>))caml_ml_array_bound_error();
  return camlHashtbl__Make_1251(v13);
}
// 8056B0C: variable 'a2' is possibly undefined
// 8056B7B: variable 'v14' is possibly undefined
// 804B070: using guessed type _DWORD caml_curry2();
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056B90) --------------------------------------------------------
int *__usercall camlHashtbl__Make_1251@<eax>(int (__usercall *a1)@<eax>(int a1@<ebx>)@<eax>)
{
  unsigned int v2; // eax
  int (__usercall **v3)@<eax>(int@<ebx>); // eax
  _DWORD *v4; // esi
  _DWORD *v5; // edx
  _DWORD *v6; // ecx
  int v7; // ebp
  int v8; // edi
  int *result; // eax
  int v10; // [esp+0h] [ebp-1Ch]
  int v11; // [esp+4h] [ebp-18h]
  int v12; // [esp+8h] [ebp-14h]
  _DWORD *v13; // [esp+Ch] [ebp-10h]
  _DWORD *v14; // [esp+10h] [ebp-Ch]
  _DWORD *v15; // [esp+14h] [ebp-8h]
  int v16; // [esp+18h] [ebp-4h]

  v10 = camlHashtbl;
  v11 = dword_80735A0;
  v12 = dword_80735A8;
  while ( 1 )
  {
    v2 = caml_young_ptr - 232;
    caml_young_ptr = v2;
    if ( v2 >= caml_young_limit )
      break;
    caml_call_gc(v10);
  }
  v3 = (int (__usercall **)@<eax>(int@<ebx>))(v2 + 4);
  *(v3 - 1) = (int (__usercall *)@<eax>(int@<ebx>))3319;
  *v3 = camlHashtbl__safehash_1177;
  v3[1] = (int (__usercall *)@<eax>(int@<ebx>))3;
  v3[2] = a1;
  v13 = v3 + 4;
  v3[3] = (int (__usercall *)@<eax>(int@<ebx>))4343;
  v3[4] = (int (__usercall *)@<eax>(int@<ebx>))caml_curry3;
  v3[5] = (int (__usercall *)@<eax>(int@<ebx>))7;
  v3[6] = (int (__usercall *)@<eax>(int@<ebx>))camlHashtbl__add_1179;
  v3[7] = (int (__usercall *)@<eax>(int@<ebx>))v3;
  v14 = v3 + 9;
  v3[8] = (int (__usercall *)@<eax>(int@<ebx>))5367;
  v3[9] = (int (__usercall *)@<eax>(int@<ebx>))caml_curry2;
  v3[10] = (int (__usercall *)@<eax>(int@<ebx>))5;
  v3[11] = (int (__usercall *)@<eax>(int@<ebx>))camlHashtbl__remove_1185;
  v3[12] = a1;
  v3[13] = (int (__usercall *)@<eax>(int@<ebx>))v3;
  v3[14] = (int (__usercall *)@<eax>(int@<ebx>))4343;
  v3[15] = (int (__usercall *)@<eax>(int@<ebx>))caml_curry2;
  v3[16] = (int (__usercall *)@<eax>(int@<ebx>))5;
  v3[17] = (int (__usercall *)@<eax>(int@<ebx>))camlHashtbl__find_rec_1193;
  v3[18] = a1;
  v15 = v3 + 20;
  v3[19] = (int (__usercall *)@<eax>(int@<ebx>))6391;
  v3[20] = (int (__usercall *)@<eax>(int@<ebx>))caml_curry2;
  v3[21] = (int (__usercall *)@<eax>(int@<ebx>))5;
  v3[22] = (int (__usercall *)@<eax>(int@<ebx>))camlHashtbl__find_226;
  v3[23] = a1;
  v3[24] = (int (__usercall *)@<eax>(int@<ebx>))v3;
  v3[25] = (int (__usercall *)@<eax>(int@<ebx>))(v3 + 15);
  v4 = v3 + 27;
  v3[26] = (int (__usercall *)@<eax>(int@<ebx>))5367;
  v3[27] = (int (__usercall *)@<eax>(int@<ebx>))caml_curry2;
  v3[28] = (int (__usercall *)@<eax>(int@<ebx>))5;
  v3[29] = (int (__usercall *)@<eax>(int@<ebx>))camlHashtbl__find_all_1210;
  v3[30] = a1;
  v3[31] = (int (__usercall *)@<eax>(int@<ebx>))v3;
  v5 = v3 + 33;
  v3[32] = (int (__usercall *)@<eax>(int@<ebx>))5367;
  v3[33] = (int (__usercall *)@<eax>(int@<ebx>))caml_curry3;
  v3[34] = (int (__usercall *)@<eax>(int@<ebx>))7;
  v3[35] = (int (__usercall *)@<eax>(int@<ebx>))camlHashtbl__replace_1217;
  v3[36] = a1;
  v3[37] = (int (__usercall *)@<eax>(int@<ebx>))v3;
  v6 = v3 + 39;
  v3[38] = (int (__usercall *)@<eax>(int@<ebx>))5367;
  v3[39] = (int (__usercall *)@<eax>(int@<ebx>))caml_curry2;
  v3[40] = (int (__usercall *)@<eax>(int@<ebx>))5;
  v3[41] = (int (__usercall *)@<eax>(int@<ebx>))camlHashtbl__mem_1227;
  v3[42] = a1;
  v3[43] = (int (__usercall *)@<eax>(int@<ebx>))v3;
  v16 = dword_80735C0;
  v7 = dword_80735C4;
  v8 = dword_80735C8;
  result = (int *)(v3 + 45);
  *(result - 1) = 12288;
  *result = v10;
  result[1] = v11;
  result[2] = v12;
  result[3] = (int)v13;
  result[4] = (int)v14;
  result[5] = (int)v15;
  result[6] = (int)v4;
  result[7] = (int)v5;
  result[8] = (int)v6;
  result[9] = v16;
  result[10] = v7;
  result[11] = v8;
  return result;
}
// 8056B90: could not find valid save-restore pair for ebx
// 8056D14: variable 'v10' is possibly undefined
// 804AFD0: using guessed type _DWORD caml_curry3();
// 804B070: using guessed type _DWORD caml_curry2();
// 807359C: using guessed type int camlHashtbl;
// 80735A0: using guessed type int dword_80735A0;
// 80735A8: using guessed type int dword_80735A8;
// 80735C0: using guessed type int dword_80735C0;
// 80735C4: using guessed type int dword_80735C4;
// 80735C8: using guessed type int dword_80735C8;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056D60) --------------------------------------------------------
int camlHashtbl__entry()
{
  dword_80735D0 = (int)&camlHashtbl__16;
  camlHashtbl = (int)&camlHashtbl__15;
  dword_80735A0 = (int)&camlHashtbl__14;
  dword_80735A8 = (int)&camlHashtbl__13;
  dword_80735C8 = (int)&camlHashtbl__12;
  dword_80735D4 = (int)&camlHashtbl__11;
  dword_80735A4 = (int)&camlHashtbl__10;
  dword_80735B8 = (int)&camlHashtbl__9;
  dword_80735D8 = (int)&camlHashtbl__8;
  dword_80735AC = (int)&camlHashtbl__7;
  dword_80735B0 = (int)&camlHashtbl__6;
  dword_80735BC = (int)&camlHashtbl__5;
  dword_80735B4 = (int)&camlHashtbl__4;
  dword_80735C0 = (int)&camlHashtbl__3;
  dword_80735C4 = (int)&camlHashtbl__2;
  dword_80735CC = (int)&camlHashtbl__1;
  return 1;
}
// 807359C: using guessed type int camlHashtbl;
// 80735A0: using guessed type int dword_80735A0;
// 80735A4: using guessed type int dword_80735A4;
// 80735A8: using guessed type int dword_80735A8;
// 80735AC: using guessed type int dword_80735AC;
// 80735B0: using guessed type int dword_80735B0;
// 80735B4: using guessed type int dword_80735B4;
// 80735B8: using guessed type int dword_80735B8;
// 80735BC: using guessed type int dword_80735BC;
// 80735C0: using guessed type int dword_80735C0;
// 80735C4: using guessed type int dword_80735C4;
// 80735C8: using guessed type int dword_80735C8;
// 80735CC: using guessed type int dword_80735CC;
// 80735D0: using guessed type int dword_80735D0;
// 80735D4: using guessed type int dword_80735D4;
// 80735D8: using guessed type int dword_80735D8;
// 80735E0: using guessed type int (*camlHashtbl__1)();
// 80735EC: using guessed type int (*camlHashtbl__2)();
// 80735FC: using guessed type int (*camlHashtbl__3)();
// 807360C: using guessed type int (*camlHashtbl__4)();
// 807361C: using guessed type int (*camlHashtbl__5)();
// 807362C: using guessed type int (*camlHashtbl__6)();
// 807363C: using guessed type int (*camlHashtbl__7)();
// 807364C: using guessed type int (*camlHashtbl__8)();
// 807365C: using guessed type int (*camlHashtbl__9)();
// 807366C: using guessed type int (*camlHashtbl__10)();
// 807367C: using guessed type int (*camlHashtbl__11)();
// 807368C: using guessed type int (*camlHashtbl__12)();
// 8073698: using guessed type int (*camlHashtbl__13)();
// 80736A4: using guessed type int (*camlHashtbl__14)();
// 80736B0: using guessed type int (*camlHashtbl__15)();
// 80736BC: using guessed type int (*camlHashtbl__16)();

//----- (08056E10) --------------------------------------------------------
int __usercall camlCallback__code_begin@<eax>(char a1@<al>)
{
  return caml_c_call((int (*)(void))caml_register_named_value, a1);
}

//----- (08056E20) --------------------------------------------------------
int __usercall camlCallback__register_exception_1034@<eax>(char a1@<al>, double *a2@<ebx>)
{
  unsigned int v3; // eax
  double *v4; // eax
  char v6; // [esp+0h] [ebp-8h]

  if ( *((unsigned __int8 *)a2 - 4) == 254 )
  {
    while ( 1 )
    {
      v3 = caml_young_ptr - 12;
      caml_young_ptr = v3;
      if ( v3 >= caml_young_limit )
        break;
      caml_call_gc(v6);
    }
    v4 = (double *)(v3 + 4);
    *((_DWORD *)v4 - 1) = 2301;
    *v4 = *a2;
  }
  return caml_c_call((int (*)(void))caml_register_named_value, a1);
}
// 8056E6A: variable 'a1' is possibly undefined
// 8056E76: variable 'v6' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08056E80) --------------------------------------------------------
int camlCallback__entry()
{
  camlCallback = (int)&camlCallback__2;
  dword_8073F80 = (int)&camlCallback__1;
  return 1;
}
// 8073F7C: using guessed type int camlCallback;
// 8073F80: using guessed type int dword_8073F80;
// 8073F88: using guessed type int (*camlCallback__1)();
// 8073F98: using guessed type int (*camlCallback__2)();

//----- (08056E9C) --------------------------------------------------------
_DWORD *__cdecl unix_accept(int a1)
{
  int v1; // edi
  _DWORD *result; // eax
  int v3[8]; // [esp+18h] [ebp-B0h] BYREF
  socklen_t addr_len; // [esp+38h] [ebp-90h] BYREF
  struct sockaddr addr; // [esp+3Ch] [ebp-8Ch] BYREF
  _DWORD *v6; // [esp+ACh] [ebp-1Ch] BYREF

  addr_len = 112;
  caml_enter_blocking_section();
  v1 = accept(a1 >> 1, &addr, &addr_len);
  caml_leave_blocking_section();
  if ( v1 == -1 )
    uerror("accept", 0);
  v6 = alloc_sockaddr((int)&addr, addr_len, v1);
  v3[0] = caml_local_roots;
  caml_local_roots = (int)v3;
  v3[2] = 1;
  v3[1] = 1;
  v3[3] = (int)&v6;
  result = (_DWORD *)caml_alloc_small(2, 0);
  *result = 2 * v1 + 1;
  result[1] = v6;
  caml_local_roots = v3[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08056F90) --------------------------------------------------------
int __cdecl unix_access(char *name, int a2)
{
  int v2; // eax

  v2 = caml_convert_flag_list((int *)a2, (int)&access_permission_table);
  if ( access(name, v2) == -1 )
    uerror("access", name);
  return 1;
}

//----- (08056FF4) --------------------------------------------------------
_DWORD *__cdecl unix_inet_addr_of_string(char *cp)
{
  int v2; // [esp+4h] [ebp-34h]
  unsigned int v3; // [esp+8h] [ebp-30h]
  int v4; // [esp+Ch] [ebp-2Ch]
  _DWORD *v5; // [esp+10h] [ebp-28h]
  _DWORD v6[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  int buf; // [esp+2Ch] [ebp-Ch] BYREF

  if ( inet_pton(2, cp, &buf) > 0 )
    return alloc_inet_addr(&buf);
  if ( inet_pton(10, cp, v6) <= 0 )
    return (_DWORD *)caml_failwith("inet_addr_of_string", v2, v3, v4, v5);
  return alloc_inet6_addr(v6);
}
// 8057067: variable 'v2' is possibly undefined
// 8057067: variable 'v3' is possibly undefined
// 8057067: variable 'v4' is possibly undefined
// 8057067: variable 'v5' is possibly undefined

//----- (08057078) --------------------------------------------------------
unsigned int __cdecl unix_alarm(int a1)
{
  return 2 * alarm(a1 >> 1) + 1;
}

//----- (080570A4) --------------------------------------------------------
int __cdecl unix_bind(int a1, int *a2)
{
  socklen_t len; // [esp+1Ch] [ebp-7Ch] BYREF
  struct sockaddr addr; // [esp+20h] [ebp-78h] BYREF

  get_sockaddr(a2, (int)&addr, (int *)&len);
  if ( bind(a1 >> 1, &addr, len) == -1 )
    uerror("bind", 0);
  return 1;
}

//----- (0805711C) --------------------------------------------------------
int __cdecl unix_chdir(char *path)
{
  if ( chdir(path) == -1 )
    uerror("chdir", path);
  return 1;
}

//----- (08057164) --------------------------------------------------------
int __cdecl unix_chmod(char *file, int a2)
{
  if ( chmod(file, a2 >> 1) == -1 )
    uerror("chmod", file);
  return 1;
}

//----- (080571B8) --------------------------------------------------------
int __cdecl unix_chown(char *file, int a2, int a3)
{
  if ( chown(file, a2 >> 1, a3 >> 1) == -1 )
    uerror("chown", file);
  return 1;
}

//----- (08057214) --------------------------------------------------------
int __cdecl unix_chroot(char *path)
{
  if ( chroot(path) == -1 )
    uerror("chroot", path);
  return 1;
}

//----- (0805725C) --------------------------------------------------------
int __cdecl unix_close(int a1)
{
  if ( close(a1 >> 1) == -1 )
    uerror("close", 0);
  return 1;
}

//----- (080572A4) --------------------------------------------------------
int __cdecl unix_closedir(DIR **a1)
{
  DIR *v1; // eax

  v1 = *a1;
  if ( !*a1 )
    v1 = (DIR *)unix_error(9, "closedir", 0);
  closedir(v1);
  *a1 = 0;
  return 1;
}

//----- (08057300) --------------------------------------------------------
int __cdecl unix_connect(int a1, int *a2)
{
  int v2; // esi
  socklen_t len; // [esp+1Ch] [ebp-7Ch] BYREF
  struct sockaddr addr; // [esp+20h] [ebp-78h] BYREF

  get_sockaddr(a2, (int)&addr, (int *)&len);
  caml_enter_blocking_section();
  v2 = connect(a1 >> 1, &addr, len);
  caml_leave_blocking_section();
  if ( v2 == -1 )
    uerror("connect", 0);
  return 1;
}

//----- (08057380) --------------------------------------------------------
int __cdecl unix_dup(int a1)
{
  int v1; // eax

  v1 = dup(a1 >> 1);
  if ( v1 == -1 )
    v1 = uerror("dup", 0);
  return 2 * v1 + 1;
}

//----- (080573C4) --------------------------------------------------------
int __cdecl unix_dup2(int a1, int a2)
{
  if ( dup2(a1 >> 1, a2 >> 1) == -1 )
    uerror("dup2", 0);
  return 1;
}

//----- (08057414) --------------------------------------------------------
char *unix_environment()
{
  return caml_copy_string_array(environ);
}

//----- (0805743C) --------------------------------------------------------
void *__cdecl unix_error_message(int a1)
{
  int v1; // eax
  char *v2; // eax

  if ( (a1 & 1) != 0 )
    v1 = error_table[a1 >> 1];
  else
    v1 = *(int *)a1 >> 1;
  v2 = strerror(v1);
  return caml_copy_string(v2);
}

//----- (0805747C) --------------------------------------------------------
int __cdecl unix_execv(char *path, int a2, int a3)
{
  char **v3; // esi

  v3 = (char **)cstringvect(a2);
  execv(path, v3);
  caml_stat_free(v3);
  uerror("execv", path);
  return unix_execve(path, a2, a3);
}

//----- (080574CC) --------------------------------------------------------
int __cdecl unix_execve(char *path, int a2, int a3)
{
  char **v3; // esi
  char **v4; // edi

  v3 = (char **)cstringvect(a2);
  v4 = (char **)cstringvect(a3);
  execve(path, v3, v4);
  caml_stat_free(v3);
  caml_stat_free(v4);
  uerror("execve", path);
  return unix_execvpe(path, a2, a3);
}

//----- (08057538) --------------------------------------------------------
int __cdecl unix_execvpe(char *file, int a2, int a3)
{
  char **v3; // edi
  void *v5; // [esp+1Ch] [ebp-1Ch]

  v3 = (char **)cstringvect(a2);
  v5 = environ;
  environ = cstringvect(a3);
  execvp(file, v3);
  caml_stat_free(v3);
  caml_stat_free(environ);
  environ = v5;
  uerror("execvp", file);
  return unix_execvp(file, a2);
}

//----- (080575B2) --------------------------------------------------------
int __cdecl unix_execvp(char *file, int a2)
{
  char **v2; // esi

  v2 = (char **)cstringvect(a2);
  execvp(file, v2);
  caml_stat_free(v2);
  uerror("execvp", file);
  return unix_fchmod((int)file, a2);
}

//----- (08057604) --------------------------------------------------------
int __cdecl unix_fchmod(int a1, int a2)
{
  if ( fchmod(a1 >> 1, a2 >> 1) == -1 )
    uerror(&unk_806B3F4, 0);
  return 1;
}

//----- (08057654) --------------------------------------------------------
int __cdecl unix_fchown(int a1, int a2, int a3)
{
  if ( fchown(a1 >> 1, a2 >> 1, a3 >> 1) == -1 )
    uerror(&unk_806B3FB, 0);
  return 1;
}

//----- (080576AC) --------------------------------------------------------
int __cdecl unix_clear_close_on_exec(int a1)
{
  int v1; // eax

  v1 = fcntl(a1 >> 1, 1, 0);
  if ( v1 == -1 || fcntl(a1 >> 1, 2, v1 & 0xFFFFFFFE) == -1 )
    uerror("clear_close_on_exec", 0);
  return 1;
}

//----- (08057726) --------------------------------------------------------
int __cdecl unix_set_close_on_exec(int a1)
{
  int v1; // eax

  v1 = fcntl(a1 >> 1, 1, 0);
  if ( v1 == -1 || fcntl(a1 >> 1, 2, v1 | 1) == -1 )
    uerror("set_close_on_exec", 0);
  return 1;
}

//----- (080577A0) --------------------------------------------------------
int __cdecl unix_clear_nonblock(int a1)
{
  int v1; // eax

  v1 = fcntl(a1 >> 1, 3, 0);
  if ( v1 == -1 || (BYTE1(v1) &= 0xF7u, fcntl(a1 >> 1, 4, v1) == -1) )
    uerror("clear_nonblock", 0);
  return 1;
}

//----- (0805781A) --------------------------------------------------------
int __cdecl unix_set_nonblock(int a1)
{
  int v1; // eax

  v1 = fcntl(a1 >> 1, 3, 0);
  if ( v1 == -1 || (BYTE1(v1) |= 8u, fcntl(a1 >> 1, 4, v1) == -1) )
    uerror("set_nonblock", 0);
  return 1;
}

//----- (080578A0) --------------------------------------------------------
int unix_fork()
{
  __pid_t v0; // esi

  v0 = fork();
  if ( v0 == -1 )
    uerror("fork", 0);
  if ( caml_debugger_in_use && (caml_debugger_fork_mode && !v0 || !caml_debugger_fork_mode && v0) )
    caml_debugger_cleanup_fork();
  return 2 * v0 + 1;
}

//----- (08057914) --------------------------------------------------------
int __cdecl unix_ftruncate_64(int a1, int a2)
{
  if ( ftruncate64(a1 >> 1, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8)) == -1 )
    uerror("ftruncate", 0);
  return 1;
}
// 804A5B4: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);

//----- (0805796A) --------------------------------------------------------
int __cdecl unix_ftruncate(int a1, int a2)
{
  if ( ftruncate64(a1 >> 1, a2 >> 1, a2 >> 31) == -1 )
    uerror("ftruncate", 0);
  return 1;
}
// 804A5B4: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);

//----- (080579D0) --------------------------------------------------------
int __cdecl unix_getaddrinfo(char *src, char *a2, int a3)
{
  int v3; // eax
  char *v4; // esi
  int v5; // eax
  char *v6; // edi
  unsigned int i; // eax
  int j; // eax
  int v9; // eax
  char v10; // dl
  int v11; // eax
  struct addrinfo *k; // esi
  size_t v13; // edi
  char *v14; // eax
  int *v15; // edi
  int v17; // [esp+10h] [ebp-138h]
  int v18; // [esp+1Ch] [ebp-12Ch]
  int v19; // [esp+1Ch] [ebp-12Ch]
  char v20[112]; // [esp+24h] [ebp-124h] BYREF
  int v21[8]; // [esp+94h] [ebp-B4h] BYREF
  void *v22; // [esp+B4h] [ebp-94h] BYREF
  _DWORD *v23; // [esp+B8h] [ebp-90h] BYREF
  int *v24; // [esp+BCh] [ebp-8Ch] BYREF
  struct addrinfo *pai; // [esp+C0h] [ebp-88h] BYREF
  struct addrinfo req; // [esp+C4h] [ebp-84h] BYREF
  int v27[8]; // [esp+E4h] [ebp-64h] BYREF
  int *v28; // [esp+104h] [ebp-44h] BYREF
  int **v29; // [esp+108h] [ebp-40h] BYREF
  int v30; // [esp+10Ch] [ebp-3Ch] BYREF
  int v31[14]; // [esp+110h] [ebp-38h] BYREF

  v17 = caml_local_roots;
  v31[0] = caml_local_roots;
  v31[2] = 1;
  v31[1] = 3;
  v31[3] = (int)&src;
  v31[4] = (int)&a2;
  v31[5] = (int)&a3;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27[0] = (int)v31;
  caml_local_roots = (int)v27;
  v27[2] = 1;
  v27[1] = 3;
  v27[3] = (int)&v30;
  v27[4] = (int)&v29;
  v27[5] = (int)&v28;
  v3 = caml_string_length((int)src);
  v4 = 0;
  if ( v3 )
  {
    v4 = (char *)caml_stat_alloc(v3 + 1);
    strcpy(v4, src);
  }
  v5 = caml_string_length((int)a2);
  v6 = 0;
  if ( v5 )
  {
    v6 = (char *)caml_stat_alloc(v5 + 1);
    strcpy(v6, a2);
  }
  for ( i = 0; i < 0x20; i += 4 )
    *(int *)((char *)&req.ai_flags + i) = 0;
  req.ai_family = 0;
  for ( j = a3; (j & 1) == 0; a3 = j )
  {
    v9 = *(_DWORD *)j;
    v29 = (int **)v9;
    if ( (v9 & 1) != 0 )
    {
      v11 = v9 >> 1;
      switch ( v11 )
      {
        case 1:
          req.ai_flags |= 2u;
          break;
        case 2:
          req.ai_flags |= 1u;
          break;
        case 0:
          req.ai_flags |= 4u;
          break;
      }
    }
    else
    {
      v10 = *(_BYTE *)(v9 - 4);
      if ( v10 == 1 )
      {
        req.ai_socktype = socket_type_table[*(int *)v9 >> 1];
      }
      else if ( v10 )
      {
        if ( v10 == 2 )
          req.ai_protocol = *(int *)v9 >> 1;
      }
      else
      {
        req.ai_family = socket_domain_table[*(int *)v9 >> 1];
      }
    }
    j = *(_DWORD *)(a3 + 4);
  }
  caml_enter_blocking_section();
  v18 = getaddrinfo(v4, v6, &req, &pai);
  caml_leave_blocking_section();
  if ( v4 )
    caml_stat_free(v4);
  if ( v6 )
    caml_stat_free(v6);
  v30 = 1;
  if ( !v18 )
  {
    for ( k = pai; k; k = k->ai_next )
    {
      v19 = caml_local_roots;
      v24 = 0;
      v23 = 0;
      v22 = 0;
      v21[0] = caml_local_roots;
      caml_local_roots = (int)v21;
      v21[2] = 1;
      v21[1] = 3;
      v21[3] = (int)&v24;
      v21[4] = (int)&v23;
      v21[5] = (int)&v22;
      v13 = 112;
      if ( k->ai_addrlen <= 0x70 )
        v13 = k->ai_addrlen;
      memcpy(v20, k->ai_addr, v13);
      v23 = alloc_sockaddr((int)v20, v13, -1);
      v14 = k->ai_canonname;
      if ( !v14 )
        v14 = (char *)"";
      v22 = caml_copy_string(v14);
      v24 = (int *)caml_alloc_small(5, 0);
      *v24 = cst_to_constr(k->ai_family, socket_domain_table, 3, 0);
      v15 = v24 + 1;
      *v15 = cst_to_constr(k->ai_socktype, socket_type_table, 4, 0);
      v24[2] = 2 * k->ai_protocol + 1;
      v24[3] = (int)v23;
      v24[4] = (int)v22;
      caml_local_roots = v19;
      v28 = v24;
      v29 = (int **)caml_alloc_small(2, 0);
      *v29 = v28;
      v29[1] = (int *)v30;
      v30 = (int)v29;
    }
    freeaddrinfo(pai);
  }
  caml_local_roots = v17;
  return v30;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08057DDC) --------------------------------------------------------
void *unix_getcwd()
{
  char buf[4104]; // [esp+10h] [ebp-1008h] BYREF

  if ( !getcwd(buf, 0x1000u) )
    uerror("getcwd", 0);
  return caml_copy_string(buf);
}

//----- (08057E38) --------------------------------------------------------
__gid_t unix_getegid()
{
  return 2 * getegid() + 1;
}

//----- (08057E5C) --------------------------------------------------------
__uid_t unix_geteuid()
{
  return 2 * geteuid() + 1;
}

//----- (08057E80) --------------------------------------------------------
__gid_t unix_getgid()
{
  return 2 * getgid() + 1;
}

//----- (08057EB0) --------------------------------------------------------
_DWORD *__usercall alloc_group_entry@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax
  int v3[8]; // [esp+14h] [ebp-44h] BYREF
  int v4; // [esp+34h] [ebp-24h] BYREF
  int v5; // [esp+38h] [ebp-20h] BYREF
  int v6; // [esp+3Ch] [ebp-1Ch] BYREF

  v6 = 1;
  v5 = 1;
  v4 = 1;
  v3[0] = caml_local_roots;
  caml_local_roots = (int)v3;
  v3[2] = 1;
  v3[1] = 3;
  v3[3] = (int)&v6;
  v3[4] = (int)&v5;
  v3[5] = (int)&v4;
  v6 = (int)caml_copy_string(*(void **)a1);
  v5 = (int)caml_copy_string(*(void **)(a1 + 4));
  v4 = (int)caml_copy_string_array(*(_DWORD **)(a1 + 12));
  result = (_DWORD *)caml_alloc_small(4, 0);
  *result = v6;
  result[1] = v5;
  result[2] = 2 * *(_DWORD *)(a1 + 8) + 1;
  result[3] = v4;
  caml_local_roots = v3[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08057F70) --------------------------------------------------------
_DWORD *__cdecl unix_getgrgid(int a1)
{
  struct group *v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = getgrgid(a1 >> 1);
  if ( !v1 )
    v1 = (struct group *)caml_raise_not_found(v3, v4, v5, v6, v7);
  return alloc_group_entry((int)v1);
}
// 8057F93: variable 'v3' is possibly undefined
// 8057F93: variable 'v4' is possibly undefined
// 8057F93: variable 'v5' is possibly undefined
// 8057F93: variable 'v6' is possibly undefined
// 8057F93: variable 'v7' is possibly undefined

//----- (08057FA3) --------------------------------------------------------
_DWORD *__cdecl unix_getgrnam(char *name)
{
  struct group *v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = getgrnam(name);
  if ( !v1 )
    v1 = (struct group *)caml_raise_not_found(v3, v4, v5, v6, v7);
  return alloc_group_entry((int)v1);
}
// 8057FC4: variable 'v3' is possibly undefined
// 8057FC4: variable 'v4' is possibly undefined
// 8057FC4: variable 'v5' is possibly undefined
// 8057FC4: variable 'v6' is possibly undefined
// 8057FC4: variable 'v7' is possibly undefined

//----- (08057FD4) --------------------------------------------------------
char *unix_getgroups()
{
  int v0; // eax
  int v1; // esi
  char *result; // eax
  int i; // edx
  __gid_t v4[65542]; // [esp+10h] [ebp-40018h] BYREF

  v0 = getgroups(0x10000, v4);
  v1 = v0;
  if ( v0 == -1 )
    v0 = uerror("getgroups", 0);
  result = caml_alloc_tuple(v0);
  if ( v1 > 0 )
  {
    for ( i = 0; i != v1; ++i )
      *(_DWORD *)&result[4 * i] = 2 * v4[i] + 1;
  }
  return result;
}

//----- (08058054) --------------------------------------------------------
_DWORD *__usercall alloc_host_entry@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax
  int v3; // ecx
  int v4[8]; // [esp+10h] [ebp-38h] BYREF
  int v5; // [esp+30h] [ebp-18h] BYREF
  int v6; // [esp+34h] [ebp-14h] BYREF
  int v7; // [esp+38h] [ebp-10h] BYREF
  int v8; // [esp+3Ch] [ebp-Ch] BYREF

  v8 = 1;
  v7 = 1;
  v6 = 1;
  v5 = 1;
  v4[0] = caml_local_roots;
  caml_local_roots = (int)v4;
  v4[2] = 1;
  v4[1] = 4;
  v4[3] = (int)&v8;
  v4[4] = (int)&v7;
  v4[5] = (int)&v6;
  v4[6] = (int)&v5;
  v8 = (int)caml_copy_string(*(void **)a1);
  if ( *(_DWORD *)(a1 + 4) )
    v7 = (int)caml_copy_string_array(*(_DWORD **)(a1 + 4));
  else
    v7 = (int)&caml_atom_table[1];
  entry_h_length = *(_DWORD *)(a1 + 12);
  v6 = (int)caml_alloc_array((int (__cdecl *)(_DWORD))alloc_one_addr, *(_DWORD **)(a1 + 16));
  result = (_DWORD *)caml_alloc_small(4, 0);
  *result = v8;
  result[1] = v7;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 == 1 )
    result[2] = 1;
  else
    result[2] = 2 * (v3 != 2) + 3;
  result[3] = v6;
  caml_local_roots = v4[0];
  return result;
}
// 80745CC: using guessed type int entry_h_length;
// 8074754: using guessed type int caml_local_roots;

//----- (08058163) --------------------------------------------------------
_DWORD *__cdecl unix_gethostbyname(char *src)
{
  int v1; // eax
  char *v2; // esi
  int *v3; // eax
  int v4; // edi
  struct hostent *v5; // eax
  void (__cdecl *v7)(_DWORD, _DWORD *); // [esp+0h] [ebp-2768h]
  int v8; // [esp+4h] [ebp-2764h]
  unsigned int v9; // [esp+8h] [ebp-2760h]
  int v10; // [esp+Ch] [ebp-275Ch]
  _DWORD *v11; // [esp+10h] [ebp-2758h]
  char buf[10000]; // [esp+28h] [ebp-2740h] BYREF
  struct hostent result_buf; // [esp+2738h] [ebp-30h] BYREF
  struct hostent *result; // [esp+274Ch] [ebp-1Ch] BYREF

  v1 = caml_string_length((int)src);
  v2 = (char *)caml_stat_alloc(v1 + 1);
  strcpy(v2, src);
  caml_enter_blocking_section();
  v3 = __h_errno_location();
  v4 = gethostbyname_r(v2, &result_buf, buf, 0x2710u, &result, v3);
  caml_leave_blocking_section();
  if ( v4 )
    result = 0;
  caml_stat_free(v2);
  v5 = result;
  if ( !result )
    v5 = (struct hostent *)caml_raise_not_found(v7, v8, v9, v10, v11);
  return alloc_host_entry((int)v5);
}
// 80581FB: variable 'v7' is possibly undefined
// 80581FB: variable 'v8' is possibly undefined
// 80581FB: variable 'v9' is possibly undefined
// 80581FB: variable 'v10' is possibly undefined
// 80581FB: variable 'v11' is possibly undefined

//----- (08058212) --------------------------------------------------------
_DWORD *__cdecl alloc_one_addr(void *src)
{
  _DWORD *result; // eax
  _DWORD dest[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  int v3; // [esp+2Ch] [ebp-Ch] BYREF

  if ( entry_h_length == 16 )
  {
    memmove(dest, src, 0x10u);
    result = alloc_inet6_addr(dest);
  }
  else
  {
    memmove(&v3, src, 4u);
    result = alloc_inet_addr(&v3);
  }
  return result;
}
// 80745CC: using guessed type int entry_h_length;

//----- (0805827F) --------------------------------------------------------
_DWORD *__cdecl unix_gethostbyaddr(int *a1)
{
  int v1; // esi
  struct hostent *v2; // eax
  void (__cdecl *v4)(_DWORD, _DWORD *); // [esp+0h] [ebp-2758h]
  int v5; // [esp+4h] [ebp-2754h]
  unsigned int v6; // [esp+8h] [ebp-2750h]
  int v7; // [esp+Ch] [ebp-274Ch]
  _DWORD *v8; // [esp+10h] [ebp-2748h]
  int h_errnop; // [esp+20h] [ebp-2738h] BYREF
  char buf[10000]; // [esp+24h] [ebp-2734h] BYREF
  struct hostent result_buf; // [esp+2734h] [ebp-24h] BYREF
  struct hostent *result; // [esp+2748h] [ebp-10h] BYREF
  int addr[3]; // [esp+274Ch] [ebp-Ch] BYREF

  addr[0] = *a1;
  caml_enter_blocking_section();
  v1 = gethostbyaddr_r(addr, 4u, 2, &result_buf, buf, 0x2710u, &result, &h_errnop);
  caml_leave_blocking_section();
  if ( v1 )
  {
    result = 0;
LABEL_4:
    v2 = (struct hostent *)caml_raise_not_found(v4, v5, v6, v7, v8);
    return alloc_host_entry((int)v2);
  }
  v2 = result;
  if ( !result )
    goto LABEL_4;
  return alloc_host_entry((int)v2);
}
// 8058302: variable 'v4' is possibly undefined
// 8058302: variable 'v5' is possibly undefined
// 8058302: variable 'v6' is possibly undefined
// 8058302: variable 'v7' is possibly undefined
// 8058302: variable 'v8' is possibly undefined

//----- (08058318) --------------------------------------------------------
void *unix_gethostname()
{
  char name[64]; // [esp+10h] [ebp-48h] BYREF

  gethostname(name, 0x40u);
  name[63] = 0;
  return caml_copy_string(name);
}

//----- (08058358) --------------------------------------------------------
void *unix_getlogin()
{
  char *v0; // eax

  v0 = getlogin();
  if ( !v0 )
    v0 = (char *)unix_error(2, "getlogin", 0);
  return caml_copy_string(v0);
}

//----- (080583A0) --------------------------------------------------------
_DWORD *__cdecl unix_getnameinfo(int *a1, int *a2)
{
  int v2; // edi
  int v3; // esi
  void (__cdecl *v5)(_DWORD, _DWORD *); // [esp+0h] [ebp-14E8h]
  int v6; // [esp+4h] [ebp-14E4h]
  unsigned int v7; // [esp+8h] [ebp-14E0h]
  int v8; // [esp+Ch] [ebp-14DCh]
  _DWORD *v9; // [esp+10h] [ebp-14D8h]
  int flags; // [esp+2Ch] [ebp-14BCh]
  char serv[1024]; // [esp+30h] [ebp-14B8h] BYREF
  char host[4096]; // [esp+430h] [ebp-10B8h] BYREF
  socklen_t salen; // [esp+1430h] [ebp-B8h] BYREF
  struct sockaddr sa; // [esp+1434h] [ebp-B4h] BYREF
  int v15[8]; // [esp+14A4h] [ebp-44h] BYREF
  _DWORD *v16; // [esp+14C4h] [ebp-24h] BYREF
  void *v17; // [esp+14C8h] [ebp-20h] BYREF
  void *v18; // [esp+14CCh] [ebp-1Ch] BYREF

  v2 = caml_local_roots;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15[0] = caml_local_roots;
  caml_local_roots = (int)v15;
  v15[2] = 1;
  v15[1] = 3;
  v15[3] = (int)&v18;
  v15[4] = (int)&v17;
  v15[5] = (int)&v16;
  get_sockaddr(a1, (int)&sa, (int *)&salen);
  flags = caml_convert_flag_list(a2, (int)&getnameinfo_flag_table);
  caml_enter_blocking_section();
  v3 = getnameinfo(&sa, salen, host, 0x1000u, serv, 0x400u, flags);
  caml_leave_blocking_section();
  if ( v3 )
    caml_raise_not_found(v5, v6, v7, v8, v9);
  v18 = caml_copy_string(host);
  v17 = caml_copy_string(serv);
  v16 = (_DWORD *)caml_alloc_small(2, 0);
  *v16 = v18;
  v16[1] = v17;
  caml_local_roots = v2;
  return v16;
}
// 8058486: variable 'v5' is possibly undefined
// 8058486: variable 'v6' is possibly undefined
// 8058486: variable 'v7' is possibly undefined
// 8058486: variable 'v8' is possibly undefined
// 8058486: variable 'v9' is possibly undefined
// 8074754: using guessed type int caml_local_roots;

//----- (080584E8) --------------------------------------------------------
_DWORD *__cdecl unix_getpeername(int a1)
{
  socklen_t len; // [esp+1Ch] [ebp-7Ch] BYREF
  struct sockaddr addr; // [esp+20h] [ebp-78h] BYREF

  len = 112;
  if ( getpeername(a1 >> 1, &addr, &len) == -1 )
    uerror("getpeername", 0);
  return alloc_sockaddr((int)&addr, len, -1);
}

//----- (08058560) --------------------------------------------------------
int unix_getpid()
{
  return 2 * getpid() + 1;
}

//----- (08058584) --------------------------------------------------------
int unix_getppid()
{
  return 2 * getppid() + 1;
}

//----- (080585B0) --------------------------------------------------------
_DWORD *__usercall alloc_proto_entry@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax
  int v3[8]; // [esp+18h] [ebp-40h] BYREF
  int v4; // [esp+38h] [ebp-20h] BYREF
  int v5; // [esp+3Ch] [ebp-1Ch] BYREF

  v5 = 1;
  v4 = 1;
  v3[0] = caml_local_roots;
  caml_local_roots = (int)v3;
  v3[2] = 1;
  v3[1] = 2;
  v3[3] = (int)&v5;
  v3[4] = (int)&v4;
  v5 = (int)caml_copy_string(*(void **)a1);
  v4 = (int)caml_copy_string_array(*(_DWORD **)(a1 + 4));
  result = (_DWORD *)caml_alloc_small(3, 0);
  *result = v5;
  result[1] = v4;
  result[2] = 2 * *(_DWORD *)(a1 + 8) + 1;
  caml_local_roots = v3[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805865A) --------------------------------------------------------
_DWORD *__cdecl unix_getprotobynumber(int a1)
{
  struct protoent *v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = getprotobynumber(a1 >> 1);
  if ( !v1 )
    v1 = (struct protoent *)caml_raise_not_found(v3, v4, v5, v6, v7);
  return alloc_proto_entry((int)v1);
}
// 805867D: variable 'v3' is possibly undefined
// 805867D: variable 'v4' is possibly undefined
// 805867D: variable 'v5' is possibly undefined
// 805867D: variable 'v6' is possibly undefined
// 805867D: variable 'v7' is possibly undefined

//----- (0805868D) --------------------------------------------------------
_DWORD *__cdecl unix_getprotobyname(char *name)
{
  struct protoent *v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = getprotobyname(name);
  if ( !v1 )
    v1 = (struct protoent *)caml_raise_not_found(v3, v4, v5, v6, v7);
  return alloc_proto_entry((int)v1);
}
// 80586AE: variable 'v3' is possibly undefined
// 80586AE: variable 'v4' is possibly undefined
// 80586AE: variable 'v5' is possibly undefined
// 80586AE: variable 'v6' is possibly undefined
// 80586AE: variable 'v7' is possibly undefined

//----- (080586C0) --------------------------------------------------------
_DWORD *__usercall alloc_passwd_entry@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax
  int v3[8]; // [esp+1Ch] [ebp-4Ch] BYREF
  int v4; // [esp+3Ch] [ebp-2Ch] BYREF
  int v5; // [esp+40h] [ebp-28h] BYREF
  int v6; // [esp+44h] [ebp-24h] BYREF
  int v7; // [esp+48h] [ebp-20h] BYREF
  int v8; // [esp+4Ch] [ebp-1Ch] BYREF

  v8 = 1;
  v7 = 1;
  v6 = 1;
  v5 = 1;
  v4 = 1;
  v3[0] = caml_local_roots;
  caml_local_roots = (int)v3;
  v3[2] = 1;
  v3[1] = 5;
  v3[3] = (int)&v8;
  v3[4] = (int)&v7;
  v3[5] = (int)&v6;
  v3[6] = (int)&v5;
  v3[7] = (int)&v4;
  v8 = (int)caml_copy_string(*(void **)a1);
  v7 = (int)caml_copy_string(*(void **)(a1 + 4));
  v6 = (int)caml_copy_string(*(void **)(a1 + 16));
  v5 = (int)caml_copy_string(*(void **)(a1 + 20));
  v4 = (int)caml_copy_string(*(void **)(a1 + 24));
  result = (_DWORD *)caml_alloc_small(7, 0);
  *result = v8;
  result[1] = v7;
  result[2] = 2 * *(_DWORD *)(a1 + 8) + 1;
  result[3] = 2 * *(_DWORD *)(a1 + 12) + 1;
  result[4] = v6;
  result[5] = v5;
  result[6] = v4;
  caml_local_roots = v3[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (080587CC) --------------------------------------------------------
_DWORD *__cdecl unix_getpwuid(int a1)
{
  struct passwd *v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = getpwuid(a1 >> 1);
  if ( !v1 )
    v1 = (struct passwd *)caml_raise_not_found(v3, v4, v5, v6, v7);
  return alloc_passwd_entry((int)v1);
}
// 80587EF: variable 'v3' is possibly undefined
// 80587EF: variable 'v4' is possibly undefined
// 80587EF: variable 'v5' is possibly undefined
// 80587EF: variable 'v6' is possibly undefined
// 80587EF: variable 'v7' is possibly undefined

//----- (080587FF) --------------------------------------------------------
_DWORD *__cdecl unix_getpwnam(char *name)
{
  struct passwd *v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = getpwnam(name);
  if ( !v1 )
    v1 = (struct passwd *)caml_raise_not_found(v3, v4, v5, v6, v7);
  return alloc_passwd_entry((int)v1);
}
// 8058820: variable 'v3' is possibly undefined
// 8058820: variable 'v4' is possibly undefined
// 8058820: variable 'v5' is possibly undefined
// 8058820: variable 'v6' is possibly undefined
// 8058820: variable 'v7' is possibly undefined

//----- (08058830) --------------------------------------------------------
int unix_gettimeofday()
{
  struct timeval tv; // [esp+18h] [ebp-10h] BYREF

  if ( gettimeofday(&tv, 0) == -1 )
    uerror("gettimeofday", 0);
  return caml_copy_double((long double)tv.tv_sec + (long double)tv.tv_usec / 1000000.0);
}

//----- (08058890) --------------------------------------------------------
_DWORD *__usercall alloc_service_entry@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax
  int v3[8]; // [esp+14h] [ebp-44h] BYREF
  int v4; // [esp+34h] [ebp-24h] BYREF
  int v5; // [esp+38h] [ebp-20h] BYREF
  int v6; // [esp+3Ch] [ebp-1Ch] BYREF

  v6 = 1;
  v5 = 1;
  v4 = 1;
  v3[0] = caml_local_roots;
  caml_local_roots = (int)v3;
  v3[2] = 1;
  v3[1] = 3;
  v3[3] = (int)&v6;
  v3[4] = (int)&v5;
  v3[5] = (int)&v4;
  v6 = (int)caml_copy_string(*(void **)a1);
  v5 = (int)caml_copy_string_array(*(_DWORD **)(a1 + 4));
  v4 = (int)caml_copy_string(*(void **)(a1 + 12));
  result = (_DWORD *)caml_alloc_small(4, 0);
  *result = v6;
  result[1] = v5;
  result[2] = 2 * (unsigned __int16)__ROR2__(*(_DWORD *)(a1 + 8), 8) + 1;
  result[3] = v4;
  caml_local_roots = v3[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08058957) --------------------------------------------------------
_DWORD *__cdecl unix_getservbyport(int a1, char *proto)
{
  struct servent *v2; // eax
  void (__cdecl *v4)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  v2 = getservbyport((unsigned __int16)__ROR2__(a1 >> 1, 8), proto);
  if ( !v2 )
    v2 = (struct servent *)caml_raise_not_found(v4, v5, v6, v7, v8);
  return alloc_service_entry((int)v2);
}
// 8058988: variable 'v4' is possibly undefined
// 8058988: variable 'v5' is possibly undefined
// 8058988: variable 'v6' is possibly undefined
// 8058988: variable 'v7' is possibly undefined
// 8058988: variable 'v8' is possibly undefined

//----- (0805899B) --------------------------------------------------------
_DWORD *__cdecl unix_getservbyname(char *name, char *proto)
{
  struct servent *v2; // eax
  void (__cdecl *v4)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  v2 = getservbyname(name, proto);
  if ( !v2 )
    v2 = (struct servent *)caml_raise_not_found(v4, v5, v6, v7, v8);
  return alloc_service_entry((int)v2);
}
// 80589C3: variable 'v4' is possibly undefined
// 80589C3: variable 'v5' is possibly undefined
// 80589C3: variable 'v6' is possibly undefined
// 80589C3: variable 'v7' is possibly undefined
// 80589C3: variable 'v8' is possibly undefined

//----- (080589D4) --------------------------------------------------------
_DWORD *__cdecl unix_getsockname(int a1)
{
  socklen_t len; // [esp+1Ch] [ebp-7Ch] BYREF
  struct sockaddr addr; // [esp+20h] [ebp-78h] BYREF

  len = 112;
  if ( getsockname(a1 >> 1, &addr, &len) == -1 )
    uerror("getsockname", 0);
  return alloc_sockaddr((int)&addr, len, -1);
}

//----- (08058A4C) --------------------------------------------------------
__uid_t unix_getuid()
{
  return 2 * getuid() + 1;
}

//----- (08058A70) --------------------------------------------------------
_DWORD *__usercall alloc_tm@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *result; // eax

  result = (_DWORD *)caml_alloc_small(9, 0);
  *result = 2 * *a1 + 1;
  result[1] = 2 * a1[1] + 1;
  result[2] = 2 * a1[2] + 1;
  result[3] = 2 * a1[3] + 1;
  result[4] = 2 * a1[4] + 1;
  result[5] = 2 * a1[5] + 1;
  result[6] = 2 * a1[6] + 1;
  result[7] = 2 * a1[7] + 1;
  result[8] = a1[8] == 0 ? 1 : 3;
  return result;
}

//----- (08058AFD) --------------------------------------------------------
_DWORD *__cdecl unix_mktime(int *a1)
{
  time_t v1; // esi
  _DWORD *result; // eax
  int v3[8]; // [esp+2Ch] [ebp-5Ch] BYREF
  int v4; // [esp+4Ch] [ebp-3Ch] BYREF
  int v5; // [esp+50h] [ebp-38h] BYREF
  struct tm tp; // [esp+54h] [ebp-34h] BYREF

  v5 = 1;
  v4 = 1;
  v3[0] = caml_local_roots;
  caml_local_roots = (int)v3;
  v3[2] = 1;
  v3[1] = 2;
  v3[3] = (int)&v5;
  v3[4] = (int)&v4;
  tp.tm_sec = *a1 >> 1;
  tp.tm_min = a1[1] >> 1;
  tp.tm_hour = a1[2] >> 1;
  tp.tm_mday = a1[3] >> 1;
  tp.tm_mon = a1[4] >> 1;
  tp.tm_year = a1[5] >> 1;
  tp.tm_wday = a1[6] >> 1;
  tp.tm_yday = a1[7] >> 1;
  tp.tm_isdst = -1;
  v1 = mktime(&tp);
  if ( v1 == -1 )
    unix_error(34, "mktime", 0);
  v5 = (int)alloc_tm(&tp);
  v4 = caml_copy_double((double)v1);
  result = (_DWORD *)caml_alloc_small(2, 0);
  *result = v4;
  result[1] = v5;
  caml_local_roots = v3[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08058C0E) --------------------------------------------------------
_DWORD *__cdecl unix_localtime(double *a1)
{
  struct tm *v1; // eax
  time_t timer; // [esp+2Ch] [ebp-Ch] BYREF

  timer = (int)*a1;
  v1 = localtime(&timer);
  if ( !v1 )
    v1 = (struct tm *)unix_error(22, "localtime", 0);
  return alloc_tm(v1);
}

//----- (08058C73) --------------------------------------------------------
_DWORD *__cdecl unix_gmtime(double *a1)
{
  struct tm *v1; // eax
  time_t timer; // [esp+2Ch] [ebp-Ch] BYREF

  timer = (int)*a1;
  v1 = gmtime(&timer);
  if ( !v1 )
    v1 = (struct tm *)unix_error(22, "gmtime", 0);
  return alloc_tm(v1);
}

//----- (08058CD8) --------------------------------------------------------
int __cdecl unix_initgroups(char *a1, int a2)
{
  if ( initgroups(a1, a2 >> 1) == -1 )
    uerror("initgroups", 0);
  return 1;
}

//----- (08058D24) --------------------------------------------------------
int __cdecl unix_isatty(int a1)
{
  return isatty(a1 >> 1) == 0 ? 1 : 3;
}

//----- (08058D54) --------------------------------------------------------
double *__usercall unix_convert_itimer@<eax>(int *a1@<eax>)
{
  double *result; // eax

  result = (double *)caml_alloc_small(4, 254);
  *result = (long double)*a1 + (long double)a1[1] / 1000000.0;
  result[1] = (long double)a1[3] / 1000000.0 + (long double)a1[2];
  return result;
}

//----- (08058DAD) --------------------------------------------------------
double *__cdecl unix_getitimer(int a1)
{
  struct itimerval value; // [esp+10h] [ebp-18h] BYREF

  if ( getitimer(itimers[a1 >> 1], &value) == -1 )
    uerror("getitimer", 0);
  return unix_convert_itimer(&value.it_interval.tv_sec);
}

//----- (08058E03) --------------------------------------------------------
int __usercall unix_set_timeval@<eax>(int *a1@<eax>, double a2)
{
  long double v3; // fst7
  int v4; // edi
  int result; // eax
  double iptr[2]; // [esp+28h] [ebp-20h] BYREF

  v3 = modf(a2, iptr);
  v4 = (int)iptr[0];
  *a1 = v4;
  result = (int)ceil(v3 * 1000000.0);
  a1[1] = result;
  if ( result > 999999 )
  {
    *a1 = v4 + 1;
    a1[1] = 0;
  }
  return result;
}

//----- (08058E99) --------------------------------------------------------
double *__cdecl unix_setitimer(int a1, double *a2)
{
  struct itimerval old; // [esp+10h] [ebp-38h] BYREF
  struct itimerval newa; // [esp+20h] [ebp-28h] BYREF

  unix_set_timeval(&newa.it_interval.tv_sec, *a2);
  unix_set_timeval(&newa.it_value.tv_sec, a2[1]);
  if ( setitimer(itimers[a1 >> 1], &newa, &old) == -1 )
    uerror("setitimer", 0);
  return unix_convert_itimer(&old.it_interval.tv_sec);
}

//----- (08058F24) --------------------------------------------------------
int __cdecl unix_kill(int a1, int a2)
{
  int v2; // eax

  v2 = caml_convert_signal_number(a2 >> 1);
  if ( kill(a1 >> 1, v2) == -1 )
    uerror("kill", 0);
  return 1;
}

//----- (08058F7C) --------------------------------------------------------
int __cdecl unix_link(char *from, char *to)
{
  if ( link(from, to) == -1 )
    uerror("link", to);
  return 1;
}

//----- (08058FCC) --------------------------------------------------------
int __cdecl unix_listen(int a1, int a2)
{
  if ( listen(a1 >> 1, a2 >> 1) == -1 )
    uerror("listen", 0);
  return 1;
}

//----- (0805901C) --------------------------------------------------------
int __cdecl unix_lockf(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // esi
  __int16 v7[2]; // [esp+18h] [ebp-20h] BYREF
  __int64 v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]

  v3 = a1 >> 1;
  v7[1] = 1;
  v4 = a3 >> 1;
  if ( a3 >> 1 >= 0 )
  {
    v8 = 0LL;
  }
  else
  {
    v8 = a3 >> 1;
    v4 = -v4;
  }
  v9 = v4;
  v10 = v4 >> 31;
  switch ( a2 >> 1 )
  {
    case 0:
      v7[0] = 2;
      v5 = fcntl(a1 >> 1, 13, v7);
      goto LABEL_14;
    case 1:
      v7[0] = 1;
      caml_enter_blocking_section();
      v5 = fcntl(v3, 14, v7);
      caml_leave_blocking_section();
      goto LABEL_14;
    case 2:
      v7[0] = 1;
      v5 = fcntl(a1 >> 1, 13, v7);
      goto LABEL_14;
    case 3:
      v7[0] = 1;
      if ( fcntl(a1 >> 1, 12, v7) == -1 )
        goto LABEL_15;
      if ( v7[0] == 2 )
        return 1;
      *__errno_location() = 13;
LABEL_15:
      uerror("lockf", 0);
      return 1;
    case 4:
      v7[0] = 0;
      caml_enter_blocking_section();
      v5 = fcntl(v3, 14, v7);
      caml_leave_blocking_section();
      goto LABEL_14;
    case 5:
      v7[0] = 0;
      v5 = fcntl(a1 >> 1, 13, v7);
LABEL_14:
      if ( v5 == -1 )
        goto LABEL_15;
      return 1;
    default:
      *__errno_location() = 22;
      goto LABEL_15;
  }
}

//----- (080591D8) --------------------------------------------------------
int *__cdecl unix_lseek_64(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // edi
  __int64 v5; // kr00_8

  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(a2 + 8);
  caml_enter_blocking_section();
  v5 = lseek64(a1 >> 1, v3, v4, seek_command_table[a3 >> 1]);
  caml_leave_blocking_section();
  if ( (HIDWORD(v5) & (unsigned int)v5) == -1 )
    uerror("lseek", 0);
  return caml_copy_int64(v5, SHIDWORD(v5));
}
// 804A844: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08059266) --------------------------------------------------------
int __cdecl unix_lseek(int a1, int a2, int a3)
{
  __int64 v3; // rdi

  caml_enter_blocking_section();
  v3 = lseek64(a1 >> 1, a2 >> 1, a2 >> 31, seek_command_table[a3 >> 1]);
  caml_leave_blocking_section();
  if ( (HIDWORD(v3) & (unsigned int)v3) == -1 )
    uerror("lseek", 0);
  if ( v3 > 0x3FFFFFFF )
    unix_error(75, "lseek", 0);
  return 2 * v3 + 1;
}
// 804A844: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805931C) --------------------------------------------------------
int __cdecl unix_mkdir(char *path, int a2)
{
  if ( mkdir(path, a2 >> 1) == -1 )
    uerror("mkdir", path);
  return 1;
}

//----- (08059370) --------------------------------------------------------
int __cdecl unix_mkfifo(char *path, int a2)
{
  if ( mkfifo(path, a2 >> 1) == -1 )
    uerror("mkfifo", path);
  return 1;
}

//----- (080593C4) --------------------------------------------------------
int __cdecl unix_nice(int a1)
{
  int *v1; // esi
  int v2; // eax

  v1 = __errno_location();
  *v1 = 0;
  v2 = nice(a1 >> 1);
  if ( v2 == -1 && *v1 )
    v2 = uerror("nice", 0);
  return 2 * v2 + 1;
}

//----- (08059424) --------------------------------------------------------
int __cdecl unix_open(char *src, int a2, int a3)
{
  int v3; // edi
  int v4; // eax
  char *v5; // esi
  int v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+1Ch] [ebp-3Ch]
  int v9[14]; // [esp+20h] [ebp-38h] BYREF

  v3 = caml_local_roots;
  v9[0] = caml_local_roots;
  caml_local_roots = (int)v9;
  v9[2] = 1;
  v9[1] = 3;
  v9[3] = (int)&src;
  v9[4] = (int)&a2;
  v9[5] = (int)&a3;
  v7 = caml_convert_flag_list((int *)a2, (int)&open_flag_table);
  v4 = caml_string_length((int)src);
  v5 = (char *)caml_stat_alloc(v4 + 1);
  strcpy(v5, src);
  caml_enter_blocking_section();
  v8 = open64(v5, v7, a3 >> 1);
  caml_leave_blocking_section();
  caml_stat_free(v5);
  if ( v8 == -1 )
    uerror("open", src);
  caml_local_roots = v3;
  return 2 * v8 + 1;
}
// 8049EF4: using guessed type int __cdecl open64(_DWORD, _DWORD, _DWORD);
// 8074754: using guessed type int caml_local_roots;

//----- (08059508) --------------------------------------------------------
DIR **__cdecl unix_opendir(char *name)
{
  DIR *v1; // esi
  DIR **result; // eax

  v1 = opendir(name);
  if ( !v1 )
    uerror("opendir", name);
  result = (DIR **)caml_alloc_small(1, 251);
  *result = v1;
  return result;
}

//----- (08059568) --------------------------------------------------------
_DWORD *unix_pipe()
{
  _DWORD *result; // eax
  int pipedes[2]; // [esp+18h] [ebp-10h] BYREF

  if ( pipe(pipedes) == -1 )
    uerror("pipe", 0);
  result = (_DWORD *)caml_alloc_small(2, 0);
  *result = 2 * pipedes[0] + 1;
  result[1] = 2 * pipedes[1] + 1;
  return result;
}

//----- (080595D0) --------------------------------------------------------
int __cdecl unix_putenv(void *src, void *a2)
{
  int v2; // edi
  char *v3; // esi
  int n; // [esp+1Ch] [ebp-1Ch]

  v2 = caml_string_length((int)src);
  n = caml_string_length((int)a2);
  v3 = (char *)caml_stat_alloc(v2 + n + 2);
  memmove(v3, src, v2);
  v3[v2] = 61;
  memmove(&v3[v2 + 1], a2, n);
  v3[v2 + 1 + n] = 0;
  if ( putenv(v3) == -1 )
    uerror("putenv", src);
  return 1;
}

//----- (08059684) --------------------------------------------------------
int __cdecl unix_read(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  size_t v5; // esi
  int v7[8]; // [esp+10h] [ebp-4028h] BYREF
  char buf[16392]; // [esp+30h] [ebp-4008h] BYREF

  v7[0] = caml_local_roots;
  caml_local_roots = (int)v7;
  v7[2] = 1;
  v7[1] = 1;
  v7[3] = (int)&a2;
  v4 = a4 >> 1;
  caml_enter_blocking_section();
  if ( v4 > 0x4000 )
    v4 = 0x4000;
  v5 = read(a1 >> 1, buf, v4);
  caml_leave_blocking_section();
  if ( v5 == -1 )
    uerror("read", 0);
  memmove((void *)(a2 + (a3 >> 1)), buf, v5);
  caml_local_roots = v7[0];
  return 2 * v5 + 1;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805975C) --------------------------------------------------------
void *__cdecl unix_readdir(int *a1)
{
  int v1; // eax
  int v2; // eax
  void (__cdecl *v4)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  v1 = *a1;
  if ( !*a1 )
    v1 = unix_error(9, "readdir", 0);
  v2 = readdir64(v1);
  if ( !v2 )
    v2 = caml_raise_end_of_file(v4, v5, v6, v7, v8);
  return caml_copy_string((void *)(v2 + 19));
}
// 80597A1: variable 'v4' is possibly undefined
// 80597A1: variable 'v5' is possibly undefined
// 80597A1: variable 'v6' is possibly undefined
// 80597A1: variable 'v7' is possibly undefined
// 80597A1: variable 'v8' is possibly undefined
// 804A354: using guessed type int __cdecl readdir64(_DWORD);

//----- (080597B8) --------------------------------------------------------
void *__cdecl unix_readlink(char *path)
{
  ssize_t v1; // eax
  char buf[4096]; // [esp+10h] [ebp-1008h] BYREF

  v1 = readlink(path, buf, 0xFFFu);
  if ( v1 == -1 )
    v1 = uerror(&unk_806B538, path);
  buf[v1] = 0;
  return caml_copy_string(buf);
}

//----- (08059828) --------------------------------------------------------
int __cdecl unix_rename(char *old, char *newa)
{
  if ( rename(old, newa) == -1 )
    uerror("rename", old);
  return 1;
}

//----- (08059878) --------------------------------------------------------
int __cdecl unix_rewinddir(DIR **a1)
{
  DIR *v1; // eax

  v1 = *a1;
  if ( !*a1 )
    v1 = (DIR *)unix_error(9, "rewinddir", 0);
  rewinddir(v1);
  return 1;
}

//----- (080598C4) --------------------------------------------------------
int __cdecl unix_rmdir(char *path)
{
  if ( rmdir(path) == -1 )
    uerror("rmdir", path);
  return 1;
}

//----- (0805990C) --------------------------------------------------------
int __usercall fdlist_to_fdset@<eax>(int *a1@<eax>, void *a2@<edx>, int *a3)
{
  int result; // eax
  int *i; // edx
  int v6; // esi

  result = 0;
  memset(a2, 0, 0x80u);
  if ( a1 != (int *)1 )
  {
    for ( i = a1; i != (int *)1; i = (int *)i[1] )
    {
      result = *i >> 1;
      v6 = result + 31;
      if ( result >= 0 )
        v6 = *i >> 1;
      *((_DWORD *)a2 + (v6 >> 5)) |= 1 << (((result + ((unsigned int)(*i >> 31) >> 27)) & 0x1F)
                                         - ((unsigned int)(*i >> 31) >> 27));
      if ( result > *a3 )
        *a3 = result;
    }
  }
  return result;
}

//----- (08059975) --------------------------------------------------------
int __usercall fdset_to_fdlist@<eax>(int *a1@<eax>, int a2@<edx>)
{
  int v3; // eax
  int v4; // esi
  int v5; // edx
  int v6; // edx
  _DWORD *v7; // eax
  int v9[8]; // [esp+18h] [ebp-40h] BYREF
  int v10; // [esp+38h] [ebp-20h] BYREF
  int *i; // [esp+3Ch] [ebp-1Ch] BYREF

  v10 = 1;
  v9[0] = caml_local_roots;
  caml_local_roots = (int)v9;
  v9[2] = 1;
  v9[1] = 2;
  v9[3] = (int)&i;
  v9[4] = (int)&v10;
  if ( a1 != (int *)1 )
  {
    for ( i = a1; ; i = (int *)i[1] )
    {
      v3 = *a1;
      v4 = v3 >> 1;
      v5 = (v3 >> 1) + 31;
      if ( v3 >> 1 >= 0 )
        v5 = v3 >> 1;
      v6 = *(_DWORD *)(a2 + 4 * (v5 >> 5));
      if ( _bittest(&v6, (((_BYTE)v4 + ((unsigned int)(v3 >> 31) >> 27)) & 0x1F) - ((unsigned int)(v3 >> 31) >> 27)) )
      {
        v7 = (_DWORD *)caml_alloc_small(2, 0);
        *v7 = 2 * v4 + 1;
        v7[1] = v10;
        v10 = (int)v7;
      }
      a1 = (int *)i[1];
      if ( a1 == (int *)1 )
        break;
    }
  }
  caml_local_roots = v9[0];
  return v10;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08059A34) --------------------------------------------------------
int **__cdecl unix_select(int *a1, int *a2, int *a3, double *a4)
{
  long double v4; // fst7
  struct timeval *v5; // esi
  int v6; // esi
  int **result; // eax
  int v8[8]; // [esp+34h] [ebp-1B4h] BYREF
  struct timeval timeout; // [esp+54h] [ebp-194h] BYREF
  int v10; // [esp+5Ch] [ebp-18Ch] BYREF
  fd_set exceptfds; // [esp+60h] [ebp-188h] BYREF
  fd_set writefds; // [esp+E0h] [ebp-108h] BYREF
  fd_set readfds; // [esp+160h] [ebp-88h] BYREF

  v8[0] = caml_local_roots;
  caml_local_roots = (int)v8;
  v8[2] = 1;
  v8[1] = 3;
  v8[3] = (int)&a1;
  v8[4] = (int)&a2;
  v8[5] = (int)&a3;
  v10 = -1;
  fdlist_to_fdset(a1, &readfds, &v10);
  fdlist_to_fdset(a2, &writefds, &v10);
  fdlist_to_fdset(a3, &exceptfds, &v10);
  v4 = *a4;
  v5 = 0;
  if ( v4 >= 0.0 )
  {
    timeout.tv_sec = (int)v4;
    timeout.tv_usec = (int)((v4 - (long double)(int)v4) * 1000000.0);
    v5 = &timeout;
  }
  caml_enter_blocking_section();
  v6 = select(v10 + 1, &readfds, &writefds, &exceptfds, v5);
  caml_leave_blocking_section();
  if ( v6 == -1 )
    uerror("select", 0);
  a1 = (int *)fdset_to_fdlist(a1, (int)&readfds);
  a2 = (int *)fdset_to_fdlist(a2, (int)&writefds);
  a3 = (int *)fdset_to_fdlist(a3, (int)&exceptfds);
  result = (int **)caml_alloc_small(3, 0);
  *result = a1;
  result[1] = a2;
  result[2] = a3;
  caml_local_roots = v8[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08059C10) --------------------------------------------------------
int __cdecl unix_sendto_native(int a1, int a2, int a3, int a4, int *a5, int *a6)
{
  int v6; // edi
  ssize_t v7; // esi
  int flags; // [esp+28h] [ebp-40A0h]
  socklen_t addr_len; // [esp+3Ch] [ebp-408Ch] BYREF
  struct sockaddr addr; // [esp+40h] [ebp-4088h] BYREF
  char dest[16408]; // [esp+B0h] [ebp-4018h] BYREF

  flags = caml_convert_flag_list(a5, (int)&msg_flag_table);
  get_sockaddr(a6, (int)&addr, (int *)&addr_len);
  v6 = a4 >> 1;
  if ( a4 >> 1 > 0x4000 )
    v6 = 0x4000;
  memmove(dest, (const void *)(a2 + (a3 >> 1)), v6);
  caml_enter_blocking_section();
  v7 = sendto(a1 >> 1, dest, v6, flags, &addr, addr_len);
  caml_leave_blocking_section();
  if ( v7 == -1 )
    uerror("sendto", 0);
  return 2 * v7 + 1;
}

//----- (08059D01) --------------------------------------------------------
int __cdecl unix_sendto(int a1)
{
  return unix_sendto_native(
           *(_DWORD *)a1,
           *(_DWORD *)(a1 + 4),
           *(_DWORD *)(a1 + 8),
           *(_DWORD *)(a1 + 12),
           *(int **)(a1 + 16),
           *(int **)(a1 + 20));
}

//----- (08059D49) --------------------------------------------------------
int __cdecl unix_send(int a1, int a2, int a3, int a4, int *a5)
{
  int v5; // esi
  ssize_t v6; // esi
  int flags; // [esp+1Ch] [ebp-401Ch]
  char dest[16396]; // [esp+20h] [ebp-4018h] BYREF

  flags = caml_convert_flag_list(a5, (int)&msg_flag_table);
  v5 = a4 >> 1;
  if ( a4 >> 1 > 0x4000 )
    v5 = 0x4000;
  memmove(dest, (const void *)(a2 + (a3 >> 1)), v5);
  caml_enter_blocking_section();
  v6 = send(a1 >> 1, dest, v5, flags);
  caml_leave_blocking_section();
  if ( v6 == -1 )
    uerror("send", 0);
  return 2 * v6 + 1;
}

//----- (08059E09) --------------------------------------------------------
_DWORD *__cdecl unix_recvfrom(int a1, int a2, int a3, int a4, int *a5)
{
  int v5; // edi
  int v6; // esi
  size_t v7; // esi
  _DWORD *result; // eax
  int v9[8]; // [esp+28h] [ebp-40B0h] BYREF
  socklen_t addr_len; // [esp+48h] [ebp-4090h] BYREF
  struct sockaddr addr; // [esp+4Ch] [ebp-408Ch] BYREF
  int v12; // [esp+BCh] [ebp-401Ch] BYREF
  char buf[16408]; // [esp+C0h] [ebp-4018h] BYREF

  v12 = 1;
  v5 = caml_convert_flag_list(a5, (int)&msg_flag_table);
  v9[0] = caml_local_roots;
  caml_local_roots = (int)v9;
  v9[2] = 1;
  v9[1] = 2;
  v9[3] = (int)&a2;
  v9[4] = (int)&v12;
  v6 = a4 >> 1;
  addr_len = 112;
  caml_enter_blocking_section();
  if ( v6 > 0x4000 )
    v6 = 0x4000;
  v7 = recvfrom(a1 >> 1, buf, v6, v5, &addr, &addr_len);
  caml_leave_blocking_section();
  if ( v7 == -1 )
    uerror("recvfrom", 0);
  memmove((void *)(a2 + (a3 >> 1)), buf, v7);
  v12 = (int)alloc_sockaddr((int)&addr, addr_len, -1);
  result = (_DWORD *)caml_alloc_small(2, 0);
  *result = 2 * v7 + 1;
  result[1] = v12;
  caml_local_roots = v9[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08059F77) --------------------------------------------------------
int __cdecl unix_recv(int a1, int a2, int a3, int a4, int *a5)
{
  int v5; // edi
  int v6; // esi
  size_t v7; // esi
  int v9[8]; // [esp+10h] [ebp-4038h] BYREF
  char buf[16408]; // [esp+30h] [ebp-4018h] BYREF

  v5 = caml_convert_flag_list(a5, (int)&msg_flag_table);
  v9[0] = caml_local_roots;
  caml_local_roots = (int)v9;
  v9[2] = 1;
  v9[1] = 1;
  v9[3] = (int)&a2;
  v6 = a4 >> 1;
  caml_enter_blocking_section();
  if ( v6 > 0x4000 )
    v6 = 0x4000;
  v7 = recv(a1 >> 1, buf, v6, v5);
  caml_leave_blocking_section();
  if ( v7 == -1 )
    uerror("recv", 0);
  memmove((void *)(a2 + (a3 >> 1)), buf, v7);
  caml_local_roots = v9[0];
  return 2 * v7 + 1;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805A06C) --------------------------------------------------------
int __cdecl unix_setgid(int a1)
{
  if ( setgid(a1 >> 1) == -1 )
    uerror("setgid", 0);
  return 1;
}

//----- (0805A0B4) --------------------------------------------------------
int __cdecl unix_setgroups(int a1)
{
  size_t v1; // edi
  const __gid_t *v2; // eax
  size_t i; // edx
  int v4; // esi
  __gid_t *groups; // [esp+1Ch] [ebp-1Ch]

  v1 = *(_DWORD *)(a1 - 4) >> 10;
  v2 = (const __gid_t *)caml_stat_alloc(4 * v1);
  groups = (__gid_t *)v2;
  if ( v1 )
  {
    for ( i = 0; i < v1; ++i )
      v2[i] = *(int *)(a1 + 4 * i) >> 1;
  }
  v4 = setgroups(v1, v2);
  caml_stat_free(groups);
  if ( v4 == -1 )
    uerror("setgroups", 0);
  return 1;
}

//----- (0805A140) --------------------------------------------------------
int unix_setsid()
{
  return 2 * setsid() + 1;
}

//----- (0805A164) --------------------------------------------------------
int __cdecl unix_setuid(int a1)
{
  if ( setuid(a1 >> 1) == -1 )
    uerror("setuid", 0);
  return 1;
}

//----- (0805A1AC) --------------------------------------------------------
int __cdecl unix_shutdown(int a1, int a2)
{
  if ( shutdown(a1 >> 1, shutdown_command_table[a2 >> 1]) == -1 )
    uerror("shutdown", 0);
  return 1;
}

//----- (0805A210) --------------------------------------------------------
int __usercall decode_sigset@<eax>(int *a1@<eax>, sigset_t *a2@<edx>)
{
  int result; // eax
  int v5; // eax

  for ( result = sigemptyset(a2); a1 != (int *)1; a1 = (int *)a1[1] )
  {
    v5 = caml_convert_signal_number(*a1 >> 1);
    result = sigaddset(a2, v5);
  }
  return result;
}

//----- (0805A25D) --------------------------------------------------------
int __cdecl unix_sigsuspend(int *a1)
{
  int v1; // esi
  sigset_t set; // [esp+10h] [ebp-88h] BYREF

  decode_sigset(a1, &set);
  caml_enter_blocking_section();
  v1 = sigsuspend(&set);
  caml_leave_blocking_section();
  if ( v1 == -1 && *__errno_location() != 4 )
    uerror("sigsuspend", 0);
  return 1;
}

//----- (0805A2CF) --------------------------------------------------------
int __usercall encode_sigset@<eax>(const sigset_t *a1@<eax>)
{
  int i; // esi
  _DWORD *v2; // edi
  int v5[8]; // [esp+2Ch] [ebp-3Ch] BYREF
  int v6; // [esp+4Ch] [ebp-1Ch] BYREF

  v6 = 1;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 1;
  v5[3] = (int)&v6;
  for ( i = 1; i != 65; ++i )
  {
    if ( sigismember(a1, i) > 0 )
    {
      v2 = (_DWORD *)caml_alloc_small(2, 0);
      *v2 = 2 * caml_rev_convert_signal_number(i) + 1;
      v2[1] = v6;
      v6 = (int)v2;
    }
  }
  caml_local_roots = v5[0];
  return v6;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805A374) --------------------------------------------------------
int unix_sigpending()
{
  sigset_t set; // [esp+10h] [ebp-88h] BYREF

  if ( sigpending(&set) == -1 )
    uerror("sigpending", 0);
  return encode_sigset(&set);
}

//----- (0805A3C6) --------------------------------------------------------
int __cdecl unix_sigprocmask(int a1, int *a2)
{
  int v2; // edi
  int v3; // esi
  sigset_t oset; // [esp+10h] [ebp-118h] BYREF
  sigset_t set; // [esp+90h] [ebp-98h] BYREF

  v2 = sigprocmask_cmd[a1 >> 1];
  decode_sigset(a2, &set);
  caml_enter_blocking_section();
  v3 = sigprocmask(v2, &set, &oset);
  caml_leave_blocking_section();
  if ( v3 == -1 )
    uerror("sigprocmask", 0);
  return encode_sigset(&oset);
}

//----- (0805A454) --------------------------------------------------------
int __cdecl unix_sleep(int a1)
{
  caml_enter_blocking_section();
  sleep(a1 >> 1);
  caml_leave_blocking_section();
  return 1;
}

//----- (0805A488) --------------------------------------------------------
int __cdecl unix_socket(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = socket(socket_domain_table[a1 >> 1], socket_type_table[a2 >> 1], a3 >> 1);
  if ( v3 == -1 )
    v3 = uerror("socket", 0);
  return 2 * v3 + 1;
}

//----- (0805A4F0) --------------------------------------------------------
int *__cdecl get_sockaddr(int *a1, int a2, int *a3)
{
  int *result; // eax
  char v4; // dl
  unsigned int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // eax
  _DWORD *v8; // eax
  void *src; // [esp+1Ch] [ebp-1Ch]

  result = a1;
  v4 = *((_BYTE *)a1 - 4);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      v7 = caml_string_length(*a1);
      if ( v7 == 16 )
      {
        LOBYTE(v7) = 0;
        do
        {
          *(_DWORD *)(a2 + v7) = 0;
          v7 += 4;
        }
        while ( v7 < 0x1C );
        *(_WORD *)a2 = 10;
        v8 = (_DWORD *)*a1;
        *(_DWORD *)(a2 + 8) = *(_DWORD *)*a1;
        *(_DWORD *)(a2 + 12) = v8[1];
        *(_DWORD *)(a2 + 16) = v8[2];
        *(_DWORD *)(a2 + 20) = v8[3];
        *(_WORD *)(a2 + 2) = __ROR2__(a1[1] >> 1, 8);
        result = a3;
        *a3 = 28;
      }
      else
      {
        *(_DWORD *)a2 = 0;
        *(_DWORD *)(a2 + 4) = 0;
        *(_DWORD *)(a2 + 8) = 0;
        *(_DWORD *)(a2 + 12) = 0;
        *(_WORD *)a2 = 2;
        *(_DWORD *)(a2 + 4) = *(_DWORD *)*a1;
        *(_WORD *)(a2 + 2) = __ROR2__(a1[1] >> 1, 8);
        result = a3;
        *a3 = 16;
      }
    }
  }
  else
  {
    src = (void *)*a1;
    v5 = caml_string_length(*a1);
    v6 = v5;
    *(_WORD *)a2 = 1;
    if ( v5 > 0x6B )
      v5 = unix_error(36, (void *)"", src);
    memmove((void *)(a2 + 2), src, v5 + 1);
    result = a3;
    *a3 = v6 + 2;
  }
  return result;
}

//----- (0805A62D) --------------------------------------------------------
_DWORD *__cdecl alloc_inet6_addr(_DWORD *a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)caml_alloc_string(16);
  *result = *a1;
  result[1] = a1[1];
  result[2] = a1[2];
  result[3] = a1[3];
  return result;
}

//----- (0805A673) --------------------------------------------------------
_DWORD *__cdecl alloc_inet_addr(_DWORD *a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)caml_alloc_string(4);
  *result = *a1;
  return result;
}

//----- (0805A69E) --------------------------------------------------------
_DWORD *__cdecl alloc_sockaddr(int a1, int a2, int fd)
{
  __int16 v3; // ax
  _DWORD *result; // eax
  int v5; // [esp+1Ch] [ebp-3Ch] BYREF
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int *v8; // [esp+28h] [ebp-30h]
  int v9[4]; // [esp+3Ch] [ebp-1Ch] BYREF

  v3 = *(_WORD *)a1;
  if ( *(_WORD *)a1 == 2 )
  {
    v9[0] = (int)alloc_inet_addr((_DWORD *)(a1 + 4));
    v5 = caml_local_roots;
    caml_local_roots = (int)&v5;
    v7 = 1;
    v6 = 1;
    v8 = v9;
    result = (_DWORD *)caml_alloc_small(2, 1);
    *result = v9[0];
    result[1] = 2 * (unsigned __int16)__ROR2__(*(_WORD *)(a1 + 2), 8) + 1;
    caml_local_roots = v5;
  }
  else if ( v3 == 10 )
  {
    v9[0] = (int)alloc_inet6_addr((_DWORD *)(a1 + 8));
    v5 = caml_local_roots;
    caml_local_roots = (int)&v5;
    v7 = 1;
    v6 = 1;
    v8 = v9;
    result = (_DWORD *)caml_alloc_small(2, 1);
    *result = v9[0];
    result[1] = 2 * (unsigned __int16)__ROR2__(*(_WORD *)(a1 + 2), 8) + 1;
    caml_local_roots = v5;
  }
  else if ( v3 == 1 )
  {
    v9[0] = (int)caml_copy_string((void *)(a1 + 2));
    v5 = caml_local_roots;
    caml_local_roots = (int)&v5;
    v7 = 1;
    v6 = 1;
    v8 = v9;
    result = (_DWORD *)caml_alloc_small(1, 0);
    *result = v9[0];
    caml_local_roots = v5;
  }
  else
  {
    if ( fd != -1 )
      close(fd);
    result = (_DWORD *)unix_error(97, (void *)"", 0);
  }
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805A834) --------------------------------------------------------
_DWORD *__cdecl unix_socketpair(int a1, int a2, int a3)
{
  _DWORD *result; // eax
  int fds[2]; // [esp+18h] [ebp-10h] BYREF

  if ( socketpair(socket_domain_table[a1 >> 1], socket_type_table[a2 >> 1], a3 >> 1, fds) == -1 )
    uerror("socketpair", 0);
  result = (_DWORD *)caml_alloc_small(2, 0);
  *result = 2 * fds[0] + 1;
  result[1] = 2 * fds[1] + 1;
  return result;
}

//----- (0805A8D0) --------------------------------------------------------
int __cdecl unix_setsockopt_aux(int a1, int a2, int level, int optname, int a5, int a6)
{
  long double v6; // fst7
  int v7; // eax
  int optval; // [esp+38h] [ebp-10h] BYREF
  int v10; // [esp+3Ch] [ebp-Ch]

  if ( a2 == 2 )
  {
    optval = ((unsigned __int8)a6 ^ 1) & 1;
    v7 = 8;
    if ( (((unsigned __int8)a6 ^ 1) & 1) != 0 )
    {
      v10 = *(int *)a6 >> 1;
      v7 = 8;
    }
  }
  else if ( (unsigned int)a2 < 2 )
  {
    optval = a6 >> 1;
    v7 = 4;
  }
  else if ( a2 == 3 )
  {
    v6 = *(double *)a6;
    optval = (int)v6;
    v10 = (int)((v6 - (long double)(int)v6) * 1000000.0);
    v7 = 8;
  }
  else
  {
    v7 = unix_error(22, (void *)a1, 0);
  }
  if ( setsockopt(a5 >> 1, level, optname, &optval, v7) == -1 )
    uerror((void *)a1, 0);
  return 1;
}

//----- (0805A9CB) --------------------------------------------------------
int __cdecl unix_setsockopt(int a1, int a2, int a3, int a4)
{
  int *v4; // edx

  v4 = (int *)((char *)*(&sockopt_table + (a1 >> 1)) + 8 * (a3 >> 1));
  return unix_setsockopt_aux((int)setsockopt_fun_name[a1 >> 1], a1 >> 1, *v4, v4[1], a2, a4);
}
// 806D86C: using guessed type void *sockopt_table;
// 806D880: using guessed type char *setsockopt_fun_name[10];

//----- (0805AA25) --------------------------------------------------------
int __cdecl unix_getsockopt_aux(int a1, int a2, int level, int optname, int a5)
{
  int result; // eax
  int v6[8]; // [esp+20h] [ebp-48h] BYREF
  _DWORD *v7; // [esp+40h] [ebp-28h] BYREF
  socklen_t optlen; // [esp+44h] [ebp-24h] BYREF
  int optval; // [esp+48h] [ebp-20h] BYREF
  int v10; // [esp+4Ch] [ebp-1Ch]

  switch ( a2 )
  {
    case 0:
    case 1:
    case 4:
      optlen = 4;
      break;
    case 2:
      optlen = 8;
      break;
    case 3:
      optlen = 8;
      break;
    default:
      unix_error(22, (void *)a1, 0);
      break;
  }
  if ( getsockopt(a5 >> 1, level, optname, &optval, &optlen) == -1 )
    uerror((void *)a1, 0);
  switch ( a2 )
  {
    case 0:
    case 1:
      result = 2 * optval + 1;
      break;
    case 2:
      if ( !optval )
        goto LABEL_16;
      result = caml_alloc_small(1, 0);
      *(_DWORD *)result = 2 * v10 + 1;
      break;
    case 3:
      result = caml_copy_double((long double)optval + (long double)v10 / 1000000.0);
      break;
    case 4:
      if ( !optval )
        goto LABEL_16;
      v7 = unix_error_of_code(optval);
      v6[0] = caml_local_roots;
      caml_local_roots = (int)v6;
      v6[2] = 1;
      v6[1] = 1;
      v6[3] = (int)&v7;
      result = caml_alloc_small(1, 0);
      *(_DWORD *)result = v7;
      caml_local_roots = v6[0];
      break;
    default:
      unix_error(22, (void *)a1, 0);
LABEL_16:
      result = 1;
      break;
  }
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805ABD8) --------------------------------------------------------
int __cdecl unix_getsockopt(int a1, int a2, int a3)
{
  int *v3; // edx

  v3 = (int *)((char *)*(&sockopt_table + (a1 >> 1)) + 8 * (a3 >> 1));
  return unix_getsockopt_aux((int)getsockopt_fun_name[a1 >> 1], a1 >> 1, *v3, v3[1], a2);
}
// 806D86C: using guessed type void *sockopt_table;
// 806D894: using guessed type char *getsockopt_fun_name[5];

//----- (0805AC2C) --------------------------------------------------------
_DWORD *__usercall stat_aux@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  int v3; // edi
  int *v4; // eax
  int *v7; // [esp+1Ch] [ebp-5Ch]
  int v8[8]; // [esp+2Ch] [ebp-4Ch] BYREF
  _DWORD *v9; // [esp+4Ch] [ebp-2Ch] BYREF
  int *v10; // [esp+50h] [ebp-28h] BYREF
  int v11; // [esp+54h] [ebp-24h] BYREF
  int v12; // [esp+58h] [ebp-20h] BYREF
  int v13; // [esp+5Ch] [ebp-1Ch] BYREF

  v3 = caml_local_roots;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8[0] = caml_local_roots;
  caml_local_roots = (int)v8;
  v8[2] = 1;
  v8[1] = 5;
  v8[3] = (int)&v13;
  v8[4] = (int)&v12;
  v8[5] = (int)&v11;
  v8[6] = (int)&v10;
  v8[7] = (int)&v9;
  v13 = caml_copy_double((double)(int)a2[16]);
  v12 = caml_copy_double((double)(int)a2[18]);
  v11 = caml_copy_double((double)(int)a2[20]);
  if ( a1 )
    v4 = caml_copy_int64(a2[11], a2[12]);
  else
    v4 = (int *)(2 * a2[11] + 1);
  v10 = v4;
  v9 = (_DWORD *)caml_alloc_small(12, 0);
  *v9 = 2 * *a2 + 1;
  v9[1] = 2 * a2[22] + 1;
  v7 = v9 + 2;
  *v7 = cst_to_constr(a2[4] & 0xF000, file_kind_table, 7, 0);
  v9[3] = 2 * (a2[4] & 0xFFF) + 1;
  v9[4] = 2 * a2[5] + 1;
  v9[5] = 2 * a2[6] + 1;
  v9[6] = 2 * a2[7] + 1;
  v9[7] = 2 * a2[8] + 1;
  v9[8] = v10;
  v9[9] = v13;
  v9[10] = v12;
  v9[11] = v11;
  caml_local_roots = v3;
  return v9;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805ADD3) --------------------------------------------------------
_DWORD *__cdecl unix_fstat_64(int a1)
{
  _DWORD v2[26]; // [esp+10h] [ebp-68h] BYREF

  if ( __fxstat64(3, a1 >> 1, v2) == -1 )
    uerror("fstat", 0);
  return stat_aux(1, v2);
}
// 804A714: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805AE2F) --------------------------------------------------------
_DWORD *__cdecl unix_lstat_64(void *a1)
{
  _DWORD v2[24]; // [esp+10h] [ebp-68h] BYREF

  if ( __lxstat64(3, a1, v2) == -1 )
    uerror("lstat", a1);
  return stat_aux(1, v2);
}
// 804A1C4: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805AE8E) --------------------------------------------------------
_DWORD *__cdecl unix_stat_64(void *a1)
{
  _DWORD v2[24]; // [esp+10h] [ebp-68h] BYREF

  if ( __xstat64(3, a1, v2) == -1 )
    uerror("stat", a1);
  return stat_aux(1, v2);
}
// 8049F54: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0805AEED) --------------------------------------------------------
_DWORD *__cdecl unix_fstat(int a1)
{
  _DWORD v2[4]; // [esp+10h] [ebp-68h] BYREF
  int v3; // [esp+20h] [ebp-58h]
  __int64 v4; // [esp+3Ch] [ebp-3Ch]

  if ( __fxstat64(3, a1 >> 1, v2) == -1 )
    uerror("fstat", 0);
  if ( v4 > 0x3FFFFFFF && (v3 & 0xF000) == 0x8000 )
    unix_error(75, "fstat", 0);
  return stat_aux(0, v2);
}
// 804A714: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805AF8B) --------------------------------------------------------
_DWORD *__cdecl unix_lstat(void *a1)
{
  _DWORD v2[4]; // [esp+10h] [ebp-68h] BYREF
  int v3; // [esp+20h] [ebp-58h]
  __int64 v4; // [esp+3Ch] [ebp-3Ch]

  if ( __lxstat64(3, a1, v2) == -1 )
    uerror("lstat", a1);
  if ( v4 > 0x3FFFFFFF && (v3 & 0xF000) == 0x8000 )
    unix_error(75, "lstat", a1);
  return stat_aux(0, v2);
}
// 804A1C4: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805B021) --------------------------------------------------------
_DWORD *__cdecl unix_stat(void *a1)
{
  _DWORD v2[4]; // [esp+10h] [ebp-68h] BYREF
  int v3; // [esp+20h] [ebp-58h]
  __int64 v4; // [esp+3Ch] [ebp-3Ch]

  if ( __xstat64(3, a1, v2) == -1 )
    uerror("stat", a1);
  if ( v4 > 0x3FFFFFFF && (v3 & 0xF000) == 0x8000 )
    unix_error(75, "stat", a1);
  return stat_aux(0, v2);
}
// 8049F54: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0805B0B8) --------------------------------------------------------
void *__cdecl unix_string_of_inet_addr(void *cp)
{
  char *v1; // eax
  char buf[72]; // [esp+10h] [ebp-48h] BYREF

  if ( caml_string_length((int)cp) == 16 )
    v1 = (char *)inet_ntop(10, cp, buf, 0x40u);
  else
    v1 = (char *)inet_ntop(2, cp, buf, 0x40u);
  if ( !v1 )
    v1 = (char *)uerror("string_of_inet_addr", 0);
  return caml_copy_string(v1);
}

//----- (0805B144) --------------------------------------------------------
int __cdecl unix_symlink(char *from, char *to)
{
  if ( symlink(from, to) == -1 )
    uerror("symlink", to);
  return 1;
}

//----- (0805B1A0) --------------------------------------------------------
int __cdecl unix_tcflow(int a1, int a2)
{
  if ( tcflow(a1 >> 1, action_flag_table[a2 >> 1]) == -1 )
    uerror("tcflow", 0);
  return 1;
}

//----- (0805B1F5) --------------------------------------------------------
int __cdecl unix_tcflush(int a1, int a2)
{
  if ( tcflush(a1 >> 1, queue_flag_table[a2 >> 1]) == -1 )
    uerror("tcflush", 0);
  return 1;
}

//----- (0805B24A) --------------------------------------------------------
int __cdecl unix_tcdrain(int a1)
{
  if ( tcdrain(a1 >> 1) == -1 )
    uerror("tcdrain", 0);
  return 1;
}

//----- (0805B28F) --------------------------------------------------------
int __cdecl unix_tcsendbreak(int a1, int a2)
{
  if ( tcsendbreak(a1 >> 1, a2 >> 1) == -1 )
    uerror("tcsendbreak", 0);
  return 1;
}

//----- (0805B2DD) --------------------------------------------------------
int __cdecl unix_tcsetattr(int a1, int a2, int *a3)
{
  int v3; // eax
  int *v5; // esi
  _DWORD *v6; // eax
  int v7; // ecx
  int v8; // ecx
  _DWORD *v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // edx
  _DWORD *v13; // eax
  int *v15; // [esp+2Ch] [ebp-1Ch]

  if ( tcgetattr(a1 >> 1, (struct termios *)&terminal_status) == -1 )
    uerror("tcsetattr", 0);
  v3 = terminal_io_descr;
  if ( terminal_io_descr != 4 )
  {
    v5 = &terminal_io_descr;
    while ( 1 )
    {
      ++v5;
      if ( v3 == 1 )
      {
        v15 = (int *)v5[2];
        v8 = (*a3 >> 1) - v5[1];
        if ( v8 >= 0 && (int)v15 > v8 )
        {
          *(_DWORD *)*v5 = v5[v8 + 4] | *(_DWORD *)*v5 & ~v5[3];
          v5 += (_DWORD)v15 + 4;
          goto LABEL_34;
        }
        unix_error(22, "tcsetattr", 0);
      }
      else
      {
        if ( v3 <= 1 )
        {
          if ( !v3 )
          {
            v6 = (_DWORD *)*v5;
            v7 = v5[1];
            v5 += 2;
            if ( (unsigned int)*a3 >> 1 )
              *v6 |= v7;
            else
              *v6 &= ~v7;
          }
          goto LABEL_34;
        }
        if ( v3 != 2 )
        {
          if ( v3 != 3 )
            goto LABEL_34;
          goto LABEL_33;
        }
      }
      v9 = (_DWORD *)*v5;
      v10 = *a3 >> 1;
      v11 = 1;
      if ( v10 != 50 )
      {
        v15 = v5;
        v5 = speedtable;
        do
        {
          if ( v10 == v5[2 * v11 + 1] )
          {
            v5 = v15;
            goto LABEL_24;
          }
LABEL_31:
          ++v11;
        }
        while ( v11 != 18 );
        unix_error(22, "tcsetattr", 0);
LABEL_33:
        v13 = (_DWORD *)*v5++;
        byte_80745F1[(_DWORD)v13] = *a3 >> 1;
        goto LABEL_34;
      }
      LOBYTE(v11) = 0;
LABEL_24:
      if ( v9 )
      {
        v12 = 0;
        if ( v9 == (_DWORD *)1 )
          v12 = cfsetospeed((struct termios *)&terminal_status, speedtable[2 * v11]);
      }
      else
      {
        v12 = cfsetispeed((struct termios *)&terminal_status, speedtable[2 * v11]);
      }
      if ( v12 == -1 )
      {
        v11 = uerror("tcsetattr", 0);
        goto LABEL_31;
      }
      ++v5;
LABEL_34:
      v3 = *v5;
      if ( *v5 == 4 )
        break;
      ++a3;
    }
  }
  if ( tcsetattr(a1 >> 1, when_flag_table[a2 >> 1], (const struct termios *)&terminal_status) == -1 )
    uerror("tcsetattr", 0);
  return 1;
}
// 805B41A: variable 'v10' is possibly undefined
// 805B41C: variable 'v15' is possibly undefined
// 805B421: variable 'v9' is possibly undefined
// 806B740: using guessed type int speedtable[];
// 8074160: using guessed type int terminal_io_descr;

//----- (0805B511) --------------------------------------------------------
char *__cdecl unix_tcgetattr(int a1)
{
  int v1; // eax
  char *v2; // edi
  int *i; // edx
  int *v4; // esi
  int v5; // ecx
  int v6; // esi
  int v7; // eax
  _DWORD *v8; // edx
  Elf32_Dyn *v9; // eax
  int v10; // edx
  int v11; // eax
  char *v13; // [esp+30h] [ebp-28h]
  int v14; // [esp+38h] [ebp-20h]
  _DWORD *v15; // [esp+3Ch] [ebp-1Ch]

  if ( tcgetattr(a1 >> 1, (struct termios *)&terminal_status) == -1 )
    uerror("tcgetattr", 0);
  v13 = caml_alloc_tuple(0x26u);
  v1 = terminal_io_descr;
  if ( terminal_io_descr != 4 )
  {
    v2 = v13;
    for ( i = &terminal_io_descr; ; i = v4 )
    {
      v4 = i + 1;
      if ( v1 == 1 )
      {
        v5 = i[3];
        v15 = i + 5;
        if ( v5 > 0 )
        {
          v6 = *(_DWORD *)*v4 & i[4];
          v14 = 0;
          if ( v6 == *v15 )
          {
LABEL_18:
            *(_DWORD *)v2 = 2 * (i[2] + v14) + 1;
          }
          else
          {
            v7 = 0;
            while ( v5 > ++v7 )
            {
              if ( i[v7 + 5] == v6 )
              {
                v14 = v7;
                goto LABEL_18;
              }
            }
          }
        }
        v4 = &v15[v5];
      }
      else if ( v1 > 1 )
      {
        if ( v1 == 2 )
        {
          v8 = (_DWORD *)*v4++;
          *(_DWORD *)v2 = 19201;
          if ( v8 )
          {
            v9 = 0;
            if ( v8 == (_DWORD *)1 )
              v9 = (Elf32_Dyn *)cfgetospeed((const struct termios *)&terminal_status);
          }
          else
          {
            v9 = (Elf32_Dyn *)cfgetispeed((const struct termios *)&terminal_status);
          }
          v10 = 1;
          if ( *(&GLOBAL_OFFSET_TABLE_ - 2201) == v9 )
          {
            LOBYTE(v10) = 0;
          }
          else
          {
            while ( (Elf32_Dyn *)speedtable[2 * v10] != v9 )
            {
              if ( ++v10 == 18 )
                goto LABEL_31;
            }
          }
          *(_DWORD *)v2 = 2 * dword_806B744[2 * v10] + 1;
        }
        else if ( v1 == 3 )
        {
          v11 = *v4;
          v4 = i + 2;
          *(_DWORD *)v2 = 2 * (unsigned __int8)byte_80745F1[v11] + 1;
        }
      }
      else if ( !v1 )
      {
        v4 = i + 3;
        *(_DWORD *)v2 = (i[2] & *(_DWORD *)i[1]) == 0 ? 1 : 3;
      }
LABEL_31:
      v1 = *v4;
      if ( *v4 == 4 )
        break;
      v2 += 4;
    }
  }
  return v13;
}
// 806B740: using guessed type int speedtable[];
// 806D9A4: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// 8074160: using guessed type int terminal_io_descr;

//----- (0805B6CC) --------------------------------------------------------
int unix_time()
{
  time_t v1; // [esp+1Ch] [ebp-Ch]

  v1 = time(0);
  return caml_copy_double((double)v1);
}

//----- (0805B700) --------------------------------------------------------
double *unix_times()
{
  double *v0; // esi
  struct rusage usage; // [esp+18h] [ebp-60h] BYREF

  v0 = (double *)caml_alloc_small(8, 254);
  getrusage(0, &usage);
  *v0 = (long double)usage.ru_utime.tv_sec + (long double)usage.ru_utime.tv_usec / 1000000.0;
  v0[1] = (long double)usage.ru_stime.tv_sec + (long double)usage.ru_stime.tv_usec / 1000000.0;
  getrusage(-1, &usage);
  v0[2] = (long double)usage.ru_utime.tv_sec + (long double)usage.ru_utime.tv_usec / 1000000.0;
  v0[3] = (long double)usage.ru_stime.tv_sec + (long double)usage.ru_stime.tv_usec / 1000000.0;
  return v0;
}

//----- (0805B7A4) --------------------------------------------------------
int __cdecl unix_truncate_64(void *a1, int a2)
{
  if ( truncate64(a1, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8)) == -1 )
    uerror("truncate", a1);
  return 1;
}
// 804A224: using guessed type int __cdecl truncate64(_DWORD, _DWORD, _DWORD);

//----- (0805B7FD) --------------------------------------------------------
int __cdecl unix_truncate(void *a1, int a2)
{
  if ( truncate64(a1, a2 >> 1, a2 >> 31) == -1 )
    uerror("truncate", a1);
  return 1;
}
// 804A224: using guessed type int __cdecl truncate64(_DWORD, _DWORD, _DWORD);

//----- (0805B858) --------------------------------------------------------
__mode_t __cdecl unix_umask(int a1)
{
  return 2 * umask(a1 >> 1) + 1;
}

//----- (0805B884) --------------------------------------------------------
_DWORD *__cdecl unix_error_of_code(int a1)
{
  _DWORD *v1; // edx

  v1 = (_DWORD *)cst_to_constr(a1, error_table, 68, -1);
  if ( v1 == (_DWORD *)-1 )
  {
    v1 = (_DWORD *)caml_alloc_small(1, 0);
    *v1 = 2 * a1 + 1;
  }
  return v1;
}

//----- (0805B8EF) --------------------------------------------------------
int __cdecl unix_error(int a1, void *src, void *a3)
{
  void *v3; // eax
  _DWORD *v4; // eax
  int v6; // [esp+4h] [ebp-44h]
  int v7; // [esp+4h] [ebp-44h]
  unsigned int v8; // [esp+8h] [ebp-40h]
  int v9; // [esp+Ch] [ebp-3Ch]
  _DWORD *v10; // [esp+10h] [ebp-38h]
  int v11[8]; // [esp+14h] [ebp-34h] BYREF
  int v12; // [esp+34h] [ebp-14h] BYREF
  int v13; // [esp+38h] [ebp-10h] BYREF
  int v14; // [esp+3Ch] [ebp-Ch] BYREF

  v3 = a3;
  v14 = 1;
  v13 = 1;
  v12 = 1;
  v11[0] = caml_local_roots;
  caml_local_roots = (int)v11;
  v11[2] = 1;
  v11[1] = 3;
  v11[3] = (int)&v14;
  v11[4] = (int)&v13;
  v11[5] = (int)&v12;
  if ( !a3 )
    v3 = caml_copy_string((void *)"");
  v12 = (int)v3;
  v14 = (int)caml_copy_string(src);
  v13 = (int)unix_error_of_code(a1);
  if ( !unix_error_exn )
  {
    unix_error_exn = caml_named_value("Unix.Unix_error");
    if ( !unix_error_exn )
      caml_invalid_argument("Exception Unix.Unix_error not initialized, please link unix.cma", v6, v8, v9, v10);
  }
  v4 = (_DWORD *)caml_alloc_small(4, 0);
  *v4 = *(_DWORD *)unix_error_exn;
  v4[1] = v13;
  v4[2] = v14;
  v4[3] = v12;
  caml_local_roots = v11[0];
  caml_raise((int)v4, v7, v8, v9, v10);
  return uerror((void *)a1, src);
}
// 805B9A4: variable 'v6' is possibly undefined
// 805B9A4: variable 'v8' is possibly undefined
// 805B9A4: variable 'v9' is possibly undefined
// 805B9A4: variable 'v10' is possibly undefined
// 805B9E7: variable 'v7' is possibly undefined
// 807461C: using guessed type int unix_error_exn;
// 8074754: using guessed type int caml_local_roots;

//----- (0805B9EC) --------------------------------------------------------
int __cdecl uerror(void *a1, void *a2)
{
  int *v2; // eax

  v2 = __errno_location();
  unix_error(*v2, a1, a2);
  return unix_unlink((char *)a1);
}

//----- (0805BA1C) --------------------------------------------------------
int __cdecl unix_unlink(char *name)
{
  if ( unlink(name) == -1 )
    uerror("unlink", name);
  return 1;
}

//----- (0805BA64) --------------------------------------------------------
int __cdecl unix_utimes(char *file, int a2, int a3)
{
  const struct utimbuf *v3; // eax
  long double v4; // fst7
  int v6[4]; // [esp+28h] [ebp-10h] BYREF

  v3 = (const struct utimbuf *)(int)*(double *)a2;
  v6[0] = (int)v3;
  v4 = *(double *)a3;
  if ( v3 || (int)v4 )
    v3 = (const struct utimbuf *)v6;
  v6[1] = (int)v4;
  if ( utime(file, v3) == -1 )
    uerror("utimes", file);
  return 1;
}

//----- (0805BAEC) --------------------------------------------------------
_DWORD *__usercall alloc_process_status@<eax>(int a1@<eax>, __int16 a2@<dx>)
{
  unsigned __int8 v3; // si^1
  _DWORD *result; // eax
  int v5; // [esp+1Ch] [ebp-4Ch]
  int v6[8]; // [esp+2Ch] [ebp-3Ch] BYREF
  _DWORD *v7; // [esp+4Ch] [ebp-1Ch] BYREF

  v3 = HIBYTE(a2);
  v5 = a2 & 0x7F;
  if ( (a2 & 0x7F) != 0 )
  {
    if ( (_BYTE)a2 == 127 )
    {
      v7 = (_DWORD *)caml_alloc_small(1, 2);
      *v7 = 2 * caml_rev_convert_signal_number(v3) + 1;
    }
    else
    {
      v7 = (_DWORD *)caml_alloc_small(1, 1);
      *v7 = 2 * caml_rev_convert_signal_number(v5) + 1;
    }
  }
  else
  {
    v7 = (_DWORD *)caml_alloc_small(1, 0);
    *v7 = 2 * v3 + 1;
  }
  v6[0] = caml_local_roots;
  caml_local_roots = (int)v6;
  v6[2] = 1;
  v6[1] = 1;
  v6[3] = (int)&v7;
  result = (_DWORD *)caml_alloc_small(2, 0);
  *result = 2 * a1 + 1;
  result[1] = v7;
  caml_local_roots = v6[0];
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805BBEF) --------------------------------------------------------
_DWORD *__cdecl unix_waitpid(int *a1, int a2)
{
  int v2; // esi
  int v3; // esi
  int stat_loc[3]; // [esp+1Ch] [ebp-Ch] BYREF

  v2 = caml_convert_flag_list(a1, (int)&wait_flag_table);
  caml_enter_blocking_section();
  v3 = waitpid(a2 >> 1, stat_loc, v2);
  caml_leave_blocking_section();
  if ( v3 == -1 )
    uerror("waitpid", 0);
  return alloc_process_status(v3, stat_loc[0]);
}

//----- (0805BC69) --------------------------------------------------------
_DWORD *unix_wait()
{
  int v0; // esi
  int stat_loc; // [esp+1Ch] [ebp-Ch] BYREF

  caml_enter_blocking_section();
  v0 = wait(&stat_loc);
  caml_leave_blocking_section();
  if ( v0 == -1 )
    uerror("wait", 0);
  return alloc_process_status(v0, stat_loc);
}

//----- (0805BCC8) --------------------------------------------------------
int __cdecl unix_single_write(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  ssize_t v5; // esi
  int v7[8]; // [esp+10h] [ebp-4038h] BYREF
  char dest[16396]; // [esp+30h] [ebp-4018h] BYREF

  v7[0] = caml_local_roots;
  caml_local_roots = (int)v7;
  v7[2] = 1;
  v7[1] = 1;
  v7[3] = (int)&a2;
  v4 = a4 >> 1;
  if ( a4 >> 1 <= 0 )
    goto LABEL_6;
  if ( v4 > 0x4000 )
    v4 = 0x4000;
  memmove(dest, (const void *)(a2 + (a3 >> 1)), v4);
  caml_enter_blocking_section();
  v5 = write(a1 >> 1, dest, v4);
  caml_leave_blocking_section();
  if ( v5 == -1 )
  {
    uerror("single_write", 0);
LABEL_6:
    v5 = 0;
  }
  caml_local_roots = v7[0];
  return 2 * v5 + 1;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805BDAD) --------------------------------------------------------
int __cdecl unix_write(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  size_t v5; // edi
  ssize_t v6; // edi
  int v8; // [esp+18h] [ebp-4040h]
  int v9; // [esp+1Ch] [ebp-403Ch]
  int v10[8]; // [esp+20h] [ebp-4038h] BYREF
  char v11[16408]; // [esp+40h] [ebp-4018h] BYREF

  v10[0] = caml_local_roots;
  caml_local_roots = (int)v10;
  v10[2] = 1;
  v10[1] = 1;
  v10[3] = (int)&a2;
  v4 = a4 >> 1;
  if ( a4 >> 1 > 0 )
  {
    v9 = a3 >> 1;
    v8 = 0;
    while ( 1 )
    {
      v5 = 0x4000;
      if ( v4 <= 0x4000 )
        v5 = v4;
      memmove(v11, (const void *)(a2 + v9), v5);
      caml_enter_blocking_section();
      v6 = write(a1 >> 1, v11, v5);
      caml_leave_blocking_section();
      if ( v6 == -1 )
      {
        v4 = v8;
        if ( *__errno_location() == 11 && v8 > 0 )
          goto LABEL_12;
        uerror("write", 0);
      }
      v8 += v6;
      v4 -= v6;
      if ( v4 <= 0 )
        goto LABEL_12;
      v9 += v6;
    }
  }
  v8 = 0;
LABEL_12:
  caml_local_roots = v10[0];
  return 2 * v8 + 1;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805BF00) --------------------------------------------------------
int __cdecl cst_to_constr(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // eax

  if ( a3 > 0 )
  {
    v4 = 0;
    if ( *a2 == a1 )
      return 2 * v4 + 1;
    while ( a3 > ++v4 )
    {
      if ( a2[v4] == a1 )
        return 2 * v4 + 1;
    }
  }
  return 2 * a4 + 1;
}

//----- (0805BF38) --------------------------------------------------------
_DWORD *__cdecl cstringvect(int a1)
{
  unsigned int v1; // edi
  _DWORD *result; // eax
  unsigned int i; // edx

  v1 = *(_DWORD *)(a1 - 4) >> 10;
  result = caml_stat_alloc(4 * v1 + 4);
  if ( v1 )
  {
    for ( i = 0; i < v1; ++i )
      result[i] = *(_DWORD *)(a1 + 4 * i);
  }
  result[v1] = 0;
  return result;
}

//----- (0805BFA0) --------------------------------------------------------
int __usercall scanmult@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  int result; // eax
  int v5; // [esp+28h] [ebp-20h] BYREF
  char v6; // [esp+2Fh] [ebp-19h] BYREF

  v6 = 32;
  __isoc99_sscanf(a1, "=%u%c", &v5, &v6);
  __isoc99_sscanf(a1, "=0x%x%c", &v5, &v6);
  switch ( v6 )
  {
    case 'M':
      result = v5 << 20;
      *a2 = v5 << 20;
      break;
    case 'k':
      result = v5 << 10;
      *a2 = v5 << 10;
      break;
    case 'G':
      result = v5 << 30;
      *a2 = v5 << 30;
      break;
    default:
      result = v5;
      *a2 = v5;
      break;
  }
  return result;
}
// 8049F44: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (0805C03E) --------------------------------------------------------
int __cdecl caml_main(char **a1)
{
  char *v1; // ebx
  unsigned __int8 v2; // al
  char v3; // al
  int i; // eax
  void *v5; // eax
  int j; // ebx
  char (*v7)[11]; // ecx
  int (*v8)(); // eax
  int (*v9)(); // ebx
  int v10; // edx
  char *v11; // ebx
  int v12; // eax
  char *v13; // edx
  int result; // eax
  char v15; // [esp+2Fh] [ebp-19h] BYREF

  caml_init_ieee_floats();
  caml_init_custom_operations();
  caml_top_of_stack = (int)&v15;
  v1 = getenv("OCAMLRUNPARAM");
  if ( v1 || (v1 = getenv("CAMLRUNPARAM")) != 0 )
  {
    while ( 1 )
    {
      v3 = *v1;
      if ( !*v1 )
        break;
      ++v1;
      v2 = v3 - 79;
      if ( v2 <= 0x27u )
        __asm { jmp     dword ptr [esi+eax*4] }
    }
  }
  caml_init_gc(minor_heap_init, heap_size_init, heap_chunk_init, percent_free_init);
  for ( i = 0; i != 256; ++i )
    caml_atom_table[i] = i;
  if ( caml_page_table_add(4, (int)caml_atom_table, (int)&caml_frame_descriptors_mask) )
    caml_fatal_error("Fatal error: not enough memory for the initial page table");
  v5 = caml_data_segments;
  for ( j = 0; v5; v5 = *(&caml_data_segments + 2 * j) )
  {
    if ( caml_page_table_add(4, (int)v5, (int)*(&off_806E05C + 2 * j)) )
      caml_fatal_error("Fatal error: not enough memory for the initial page table");
    ++j;
  }
  caml_code_area_start = caml_code_segments;
  v7 = off_806E0B8;
  caml_code_area_end = (int)off_806E0B8;
  v8 = off_806E0BC;
  if ( off_806E0BC )
  {
    v9 = (int (*)())caml_code_area_start;
    v10 = 1;
    do
    {
      if ( (unsigned int)v9 > (unsigned int)v8 )
        v9 = v8;
      if ( v7 < *(&off_806E0B8 + 2 * v10) )
        v7 = *(&off_806E0B8 + 2 * v10);
      ++v10;
      v8 = *(&caml_code_segments + 2 * v10);
    }
    while ( v8 );
    caml_code_area_start = v9;
    caml_code_area_end = (int)v7;
  }
  caml_init_signals();
  caml_debugger_init();
  v11 = *a1;
  if ( !*a1 )
    v11 = (char *)"";
  v12 = caml_executable_name(proc_self_exe_2949, 0x100u);
  v13 = proc_self_exe_2949;
  if ( v12 )
    v13 = caml_search_exe_in_path(v11);
  caml_sys_init(v13, (int)a1);
  if ( __sigsetjmp(&caml_termination_jmpbuf, 0) )
  {
    result = (int)caml_termination_hook;
    if ( caml_termination_hook )
      result = caml_termination_hook(0);
  }
  else
  {
    result = caml_start_program();
    if ( (result & 3) == 2 )
      caml_fatal_uncaught_exception(result & 0xFFFFFFFC);
  }
  return result;
}
// 806E058: using guessed type void *caml_data_segments;
// 806E05C: using guessed type void *off_806E05C;
// 806E0B4: using guessed type int (*caml_code_segments)();
// 806E0B8: using guessed type char (*off_806E0B8)[11];
// 806E0BC: using guessed type int (*off_806E0BC)();
// 807445C: using guessed type int percent_free_init;
// 8074460: using guessed type int heap_chunk_init;
// 8074464: using guessed type int heap_size_init;
// 8074468: using guessed type int minor_heap_init;
// 8074620: using guessed type int (__cdecl *caml_termination_hook)(_DWORD);
// 807AF5C: using guessed type int caml_code_area_end;
// 807B360: using guessed type int caml_frame_descriptors_mask;
// 807B364: using guessed type int caml_top_of_stack;

//----- (0805C2F9) --------------------------------------------------------
int __cdecl caml_startup(char **a1)
{
  return caml_main(a1);
}

//----- (0805C30C) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  caml_main((char **)argv);
  caml_sys_exit(1);
}

//----- (0805C340) --------------------------------------------------------
int __cdecl caml_raise(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // eax

  if ( caml_channel_mutex_unlock_exn )
    caml_channel_mutex_unlock_exn();
  if ( !caml_exception_pointer )
    caml_fatal_uncaught_exception(a1);
  v5 = (_DWORD *)caml_local_roots;
  if ( caml_local_roots && caml_local_roots < (unsigned int)caml_exception_pointer )
  {
    do
    {
      v5 = (_DWORD *)*v5;
      caml_local_roots = (int)v5;
    }
    while ( v5 && caml_exception_pointer > (unsigned int)v5 );
  }
  caml_raise_exception();
  return caml_array_bound_error(a1, a2, a3, a4, a5);
}
// 8074740: using guessed type int caml_exception_pointer;
// 8074754: using guessed type int caml_local_roots;
// 8078D30: using guessed type int (*caml_channel_mutex_unlock_exn)(void);

//----- (0805C38D) --------------------------------------------------------
int __cdecl caml_array_bound_error(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  if ( !array_bound_error_bucket_inited )
  {
    array_bound_error_msg = 5372;
    byte_8074487 = 0;
    array_bound_error_bucket = 2048;
    dword_807474C = (int)&caml_exn_Invalid_argument;
    dword_8074750 = (int)&unk_8074474;
    array_bound_error_bucket_inited = 1;
    caml_page_table_add(4, (int)&array_bound_error_msg, (int)&caml_last_return_address);
    array_bound_error_bucket_inited = 1;
  }
  caml_raise((int)&dword_807474C, v6, v7, v8, v9);
  return caml_raise_stack_overflow(a1, a2, a3, a4, a5);
}
// 805C402: variable 'v6' is possibly undefined
// 805C402: variable 'v7' is possibly undefined
// 805C402: variable 'v8' is possibly undefined
// 805C402: variable 'v9' is possibly undefined
// 806DCE8: using guessed type char *caml_exn_Invalid_argument;
// 8074470: using guessed type int array_bound_error_msg;
// 8074487: using guessed type char byte_8074487;
// 807448C: using guessed type int caml_last_return_address;
// 8074744: using guessed type int array_bound_error_bucket_inited;
// 8074748: using guessed type int array_bound_error_bucket;
// 807474C: using guessed type int dword_807474C;
// 8074750: using guessed type int dword_8074750;

//----- (0805C407) --------------------------------------------------------
int __cdecl caml_raise_stack_overflow(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  caml_raise((int)&caml_bucket_Stack_overflow, v6, v7, v8, v9);
  return caml_raise_out_of_memory(a1, a2, a3, a4, a5);
}
// 805C414: variable 'v6' is possibly undefined
// 805C414: variable 'v7' is possibly undefined
// 805C414: variable 'v8' is possibly undefined
// 805C414: variable 'v9' is possibly undefined
// 806DDB8: using guessed type char **caml_bucket_Stack_overflow;

//----- (0805C419) --------------------------------------------------------
int __cdecl caml_raise_out_of_memory(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  caml_raise((int)&caml_bucket_Out_of_memory, v6, v7, v8, v9);
  return caml_raise_with_args(a1, a2, a3, a4, a5);
}
// 805C426: variable 'v6' is possibly undefined
// 805C426: variable 'v7' is possibly undefined
// 805C426: variable 'v8' is possibly undefined
// 805C426: variable 'v9' is possibly undefined
// 806DCA4: using guessed type char **caml_bucket_Out_of_memory;

//----- (0805C42B) --------------------------------------------------------
int __cdecl caml_raise_with_args(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v5; // esi
  int v6; // ebx
  int *v7; // eax
  int i; // edx
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  _DWORD *v13[8]; // [esp+10h] [ebp-48h] BYREF
  int v14[10]; // [esp+30h] [ebp-28h] BYREF

  v5 = a2;
  v6 = a3;
  v14[0] = caml_local_roots;
  v14[2] = 1;
  v14[1] = 1;
  v14[3] = (int)&a1;
  v13[0] = v14;
  caml_local_roots = (int)v13;
  v13[2] = (_DWORD *)a2;
  v13[1] = (_DWORD *)1;
  v13[3] = (_DWORD *)a3;
  v7 = (int *)caml_alloc_small(a2 + 1, 0);
  *v7 = a1;
  if ( v5 > 0 )
  {
    for ( i = 0; i != v5; ++i )
      v7[i + 1] = *(_DWORD *)(v6 + 4 * i);
  }
  caml_raise((int)v7, v10, v11, v12, v13[0]);
  return caml_raise_with_arg(a1, a2, a3, a4, a5);
}
// 805C4A2: variable 'v10' is possibly undefined
// 805C4A2: variable 'v11' is possibly undefined
// 805C4A2: variable 'v12' is possibly undefined
// 8074754: using guessed type int caml_local_roots;

//----- (0805C4A7) --------------------------------------------------------
int __cdecl caml_raise_with_arg(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-64h]
  int v7; // [esp+8h] [ebp-60h]
  int v8; // [esp+Ch] [ebp-5Ch]
  _DWORD *v9; // [esp+10h] [ebp-58h]
  int v10[8]; // [esp+1Ch] [ebp-4Ch] BYREF
  int *v11; // [esp+3Ch] [ebp-2Ch] BYREF
  int v12[10]; // [esp+40h] [ebp-28h] BYREF

  v12[0] = caml_local_roots;
  v12[2] = 1;
  v12[1] = 2;
  v12[3] = (int)&a1;
  v12[4] = (int)&a2;
  v11 = 0;
  v10[0] = (int)v12;
  caml_local_roots = (int)v10;
  v10[2] = 1;
  v10[1] = 1;
  v10[3] = (int)&v11;
  v11 = (int *)caml_alloc_small(2, 0);
  *v11 = a1;
  v11[1] = a2;
  caml_raise((int)v11, v6, v7, v8, v9);
  return caml_raise_sys_error(a1, (void *)a2, a3, a4, a5);
}
// 805C523: variable 'v6' is possibly undefined
// 805C523: variable 'v7' is possibly undefined
// 805C523: variable 'v8' is possibly undefined
// 805C523: variable 'v9' is possibly undefined
// 8074754: using guessed type int caml_local_roots;

//----- (0805C528) --------------------------------------------------------
int __cdecl caml_raise_sys_error(int a1, void *a2, unsigned int a3, int a4, _DWORD *a5)
{
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  caml_raise_with_arg((int)&caml_exn_Sys_error, a1, v6, v7, v8);
  return caml_raise_with_string(a1, a2, a3, a4, a5);
}
// 805C53C: variable 'v6' is possibly undefined
// 805C53C: variable 'v7' is possibly undefined
// 805C53C: variable 'v8' is possibly undefined
// 806DCAC: using guessed type char *caml_exn_Sys_error;

//----- (0805C541) --------------------------------------------------------
int __cdecl caml_raise_with_string(int a1, void *src, unsigned int a3, int a4, _DWORD *a5)
{
  void *v5; // eax
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  v5 = caml_copy_string(src);
  caml_raise_with_arg(a1, (int)v5, v7, v8, v9);
  return caml_invalid_argument((void *)a1, (int)src, a3, a4, a5);
}
// 805C55C: variable 'v7' is possibly undefined
// 805C55C: variable 'v8' is possibly undefined
// 805C55C: variable 'v9' is possibly undefined

//----- (0805C561) --------------------------------------------------------
int __cdecl caml_invalid_argument(void *a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  caml_raise_with_string((int)&caml_exn_Invalid_argument, a1, v6, v7, v8);
  return caml_failwith(a1, a2, a3, a4, a5);
}
// 805C575: variable 'v6' is possibly undefined
// 805C575: variable 'v7' is possibly undefined
// 805C575: variable 'v8' is possibly undefined
// 806DCE8: using guessed type char *caml_exn_Invalid_argument;

//----- (0805C57A) --------------------------------------------------------
int __cdecl caml_failwith(void *a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  caml_raise_with_string((int)&caml_exn_Failure, a1, v6, v7, v8);
  return caml_raise_constant((int)a1, a2, a3, a4, a5);
}
// 805C58E: variable 'v6' is possibly undefined
// 805C58E: variable 'v7' is possibly undefined
// 805C58E: variable 'v8' is possibly undefined
// 806DCCC: using guessed type char *caml_exn_Failure;

//----- (0805C593) --------------------------------------------------------
int __cdecl caml_raise_constant(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-64h]
  int v7; // [esp+8h] [ebp-60h]
  int v8; // [esp+Ch] [ebp-5Ch]
  _DWORD *v9; // [esp+10h] [ebp-58h]
  int v10[8]; // [esp+1Ch] [ebp-4Ch] BYREF
  int *v11; // [esp+3Ch] [ebp-2Ch] BYREF
  int v12[10]; // [esp+40h] [ebp-28h] BYREF

  v12[0] = caml_local_roots;
  v12[2] = 1;
  v12[1] = 1;
  v12[3] = (int)&a1;
  v11 = 0;
  v10[0] = (int)v12;
  caml_local_roots = (int)v10;
  v10[2] = 1;
  v10[1] = 1;
  v10[3] = (int)&v11;
  v11 = (int *)caml_alloc_small(1, 0);
  *v11 = a1;
  caml_raise((int)v11, v6, v7, v8, v9);
  return caml_raise_sys_blocked_io((void (__cdecl *)(_DWORD, _DWORD *))a1, a2, a3, a4, a5);
}
// 805C600: variable 'v6' is possibly undefined
// 805C600: variable 'v7' is possibly undefined
// 805C600: variable 'v8' is possibly undefined
// 805C600: variable 'v9' is possibly undefined
// 8074754: using guessed type int caml_local_roots;

//----- (0805C605) --------------------------------------------------------
int __cdecl caml_raise_sys_blocked_io(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  caml_raise_constant((int)&caml_exn_Sys_blocked_io, v6, v7, v8, v9);
  return caml_raise_not_found(a1, a2, a3, a4, a5);
}
// 805C612: variable 'v6' is possibly undefined
// 805C612: variable 'v7' is possibly undefined
// 805C612: variable 'v8' is possibly undefined
// 805C612: variable 'v9' is possibly undefined
// 806DDC0: using guessed type char *caml_exn_Sys_blocked_io;

//----- (0805C617) --------------------------------------------------------
int __cdecl caml_raise_not_found(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  caml_raise_constant((int)&caml_exn_Not_found, v6, v7, v8, v9);
  return caml_raise_zero_divide(a1, a2, a3, a4, a5);
}
// 805C624: variable 'v6' is possibly undefined
// 805C624: variable 'v7' is possibly undefined
// 805C624: variable 'v8' is possibly undefined
// 805C624: variable 'v9' is possibly undefined
// 806DD58: using guessed type char *caml_exn_Not_found;

//----- (0805C629) --------------------------------------------------------
int __cdecl caml_raise_zero_divide(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  caml_raise_constant((int)&caml_exn_Division_by_zero, v6, v7, v8, v9);
  return caml_raise_end_of_file(a1, a2, a3, a4, a5);
}
// 805C636: variable 'v6' is possibly undefined
// 805C636: variable 'v7' is possibly undefined
// 805C636: variable 'v8' is possibly undefined
// 805C636: variable 'v9' is possibly undefined
// 806DD30: using guessed type char *caml_exn_Division_by_zero;

//----- (0805C63B) --------------------------------------------------------
int __cdecl caml_raise_end_of_file(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  caml_raise_constant((int)&caml_exn_End_of_file, v6, v7, v8, v9);
  return caml_do_local_roots(a1, a2, a3, a4, a5);
}
// 805C648: variable 'v6' is possibly undefined
// 805C648: variable 'v7' is possibly undefined
// 805C648: variable 'v8' is possibly undefined
// 805C648: variable 'v9' is possibly undefined
// 806DD10: using guessed type char *caml_exn_End_of_file;

//----- (0805C650) --------------------------------------------------------
int __cdecl caml_do_local_roots(void (__cdecl *a1)(_DWORD, _DWORD *), int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int result; // eax
  _DWORD *v7; // esi
  int v8; // eax
  int i; // ebx
  int v10; // esi
  unsigned __int16 *j; // edi
  int v12; // eax
  _DWORD *v13; // eax
  int v14; // eax
  int l; // ebx
  int k; // edi
  _DWORD *v17; // [esp+4h] [ebp-34h]
  int v19; // [esp+1Ch] [ebp-1Ch]

  result = a2;
  if ( a2 )
  {
    v19 = a2;
    do
    {
      while ( 1 )
      {
        v8 = caml_frame_descriptors_mask & (a3 >> 3);
        for ( i = *((_DWORD *)caml_frame_descriptors + v8); *(_DWORD *)i != a3; i = *((_DWORD *)caml_frame_descriptors
                                                                                    + v8) )
          v8 = caml_frame_descriptors_mask & (v8 + 1);
        if ( *(_WORD *)(i + 4) == 0xFFFF )
          break;
        v10 = *(unsigned __int16 *)(i + 6);
        if ( *(_WORD *)(i + 6) )
        {
          for ( j = (unsigned __int16 *)(i + 8); ; ++j )
          {
            v12 = *j;
            v13 = (_DWORD *)((v12 & 1) != 0 ? a4 + 4 * (v12 >> 1) : v19 + v12);
            a1(*v13, v13);
            if ( --v10 <= 0 )
              break;
          }
        }
        v19 += *(_WORD *)(i + 4) & 0xFFFC;
        a3 = *(_DWORD *)(v19 - 4);
      }
      v14 = v19 + 8;
      v19 = *(_DWORD *)(v19 + 8);
      a3 = *(_DWORD *)(v14 + 4);
      result = *(_DWORD *)(v14 + 8);
      a4 = result;
    }
    while ( v19 );
  }
  if ( a5 )
  {
    v7 = a5;
    do
    {
      for ( k = 0; v7[1] > k; ++k )
      {
        for ( l = 0; v7[2] > l; ++l )
        {
          v17 = (_DWORD *)(v7[k + 3] + 4 * l);
          result = ((int (__cdecl *)(_DWORD, _DWORD *))a1)(*v17, v17);
        }
      }
      v7 = (_DWORD *)*v7;
    }
    while ( v7 );
  }
  return result;
}
// 807B360: using guessed type int caml_frame_descriptors_mask;

//----- (0805C777) --------------------------------------------------------
int caml_stack_usage()
{
  int v0; // ebx

  v0 = (caml_top_of_stack - caml_bottom_of_stack) >> 2;
  if ( caml_stack_usage_hook )
    v0 += caml_stack_usage_hook();
  return v0;
}
// 8074760: using guessed type int caml_bottom_of_stack;
// 8074768: using guessed type int (*caml_stack_usage_hook)(void);
// 807B364: using guessed type int caml_top_of_stack;

//----- (0805C7A2) --------------------------------------------------------
_DWORD *__usercall cons@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax

  result = caml_stat_alloc(8u);
  *result = a1;
  result[1] = a2;
  return result;
}

//----- (0805C7CD) --------------------------------------------------------
_DWORD *__cdecl caml_register_dyn_global(int a1)
{
  _DWORD *result; // eax

  result = cons(a1, caml_dyn_globals);
  caml_dyn_globals = (int)result;
  return result;
}
// 807476C: using guessed type int caml_dyn_globals;

//----- (0805C7E8) --------------------------------------------------------
void __cdecl caml_register_frametable(int a1)
{
  frametables = (int)cons(a1, frametables);
  if ( caml_frame_descriptors )
  {
    caml_stat_free(caml_frame_descriptors);
    caml_frame_descriptors = 0;
  }
}
// 8074774: using guessed type int frametables;

//----- (0805C81E) --------------------------------------------------------
int caml_init_frame_descriptors()
{
  void *v0; // eax
  int v1; // ebx
  int v2; // eax
  int v3; // edx
  int v4; // edx
  int j; // ebx
  int i; // eax
  int result; // eax
  int v8; // esi
  int v9; // edi
  int v10; // eax
  int *l; // edx
  unsigned int v12; // eax
  int k; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]

  if ( !inited_3139 )
  {
    v0 = caml_frametable;
    if ( caml_frametable )
    {
      v1 = 0;
      do
      {
        caml_register_frametable((int)v0);
        ++v1;
        v0 = *(&caml_frametable + v1);
      }
      while ( v0 );
    }
    inited_3139 = 1;
  }
  v2 = frametables;
  if ( !frametables )
    goto LABEL_26;
  v3 = 0;
  do
  {
    v3 += **(_DWORD **)v2;
    v2 = *(_DWORD *)(v2 + 4);
  }
  while ( v2 );
  v4 = 2 * v3;
  if ( v4 <= 4 )
  {
LABEL_26:
    caml_frame_descriptors = caml_stat_alloc(0x10u);
    j = 4;
LABEL_27:
    for ( i = 0; i < j; ++i )
      *((_DWORD *)caml_frame_descriptors + i) = 0;
    goto LABEL_15;
  }
  for ( j = 4; j < v4; j *= 2 )
    ;
  caml_frame_descriptors = caml_stat_alloc(4 * j);
  if ( j > 0 )
    goto LABEL_27;
LABEL_15:
  caml_frame_descriptors_mask = j - 1;
  result = frametables;
  for ( k = frametables; result; k = result )
  {
    v14 = **(_DWORD **)k;
    if ( v14 > 0 )
    {
      v8 = *(_DWORD *)k + 4;
      v9 = 0;
      while ( 1 )
      {
        v10 = caml_frame_descriptors_mask & (*(_DWORD *)v8 >> 3);
        for ( l = (int *)((char *)caml_frame_descriptors + 4 * v10);
              *l;
              l = (int *)((char *)caml_frame_descriptors + 4 * v10) )
        {
          v10 = caml_frame_descriptors_mask & (v10 + 1);
        }
        *l = v8;
        v12 = (v8 + 2 * *(unsigned __int16 *)(v8 + 6) + 11) & 0xFFFFFFFC;
        if ( (*(_BYTE *)(v8 + 4) & 1) != 0 )
          v12 += 8;
        if ( ++v9 == v14 )
          break;
        v8 = v12;
      }
    }
    result = *(_DWORD *)(k + 4);
  }
  return result;
}
// 806E110: using guessed type void *caml_frametable;
// 8074774: using guessed type int frametables;
// 8074778: using guessed type int inited_3139;
// 807B360: using guessed type int caml_frame_descriptors_mask;

//----- (0805C975) --------------------------------------------------------
int (__cdecl *__cdecl caml_do_roots(void (__cdecl *a1)(int, char *)))(_DWORD)
{
  int *v1; // edi
  unsigned int i; // ebx
  unsigned int v3; // eax
  int v4; // edi
  _DWORD *v5; // esi
  int v6; // eax
  unsigned int v7; // ebx
  int (__cdecl *result)(_DWORD); // eax
  int v9; // [esp+2Ch] [ebp-1Ch]
  int *v10; // [esp+2Ch] [ebp-1Ch]

  v1 = caml_globals[0];
  if ( caml_globals[0] )
  {
    v9 = 0;
    do
    {
      v3 = 0;
      for ( i = 0; i < (unsigned int)*(v1 - 1) >> 10; v3 = i )
      {
        a1(v1[v3], (char *)&v1[v3]);
        ++i;
      }
      v1 = caml_globals[++v9];
    }
    while ( v1 );
  }
  v10 = (int *)caml_dyn_globals;
  if ( caml_dyn_globals )
  {
    do
    {
      v4 = *v10;
      v5 = (_DWORD *)(*v10 - 4);
      if ( *v5 >> 10 )
      {
        v6 = 0;
        v7 = 0;
        do
        {
          a1(*(_DWORD *)(v4 + 4 * v6), (char *)(v4 + 4 * v6));
          v6 = ++v7;
        }
        while ( *v5 >> 10 > v7 );
      }
      v10 = (int *)v10[1];
    }
    while ( v10 );
  }
  if ( !caml_frame_descriptors )
    caml_init_frame_descriptors();
  caml_do_local_roots(
    (void (__cdecl *)(_DWORD, _DWORD *))a1,
    caml_bottom_of_stack,
    caml_last_return_address,
    caml_gc_regs,
    (_DWORD *)caml_local_roots);
  caml_scan_global_roots((int)a1);
  caml_final_do_strong_roots(a1);
  result = caml_scan_roots_hook;
  if ( caml_scan_roots_hook )
    result = (int (__cdecl *)(_DWORD))caml_scan_roots_hook(a1);
  return result;
}
// 806DE34: using guessed type int *caml_globals[9];
// 807448C: using guessed type int caml_last_return_address;
// 8074754: using guessed type int caml_local_roots;
// 8074758: using guessed type int (__cdecl *caml_scan_roots_hook)(_DWORD);
// 8074760: using guessed type int caml_bottom_of_stack;
// 807476C: using guessed type int caml_dyn_globals;
// 807B368: using guessed type int caml_gc_regs;

//----- (0805CA96) --------------------------------------------------------
int (__cdecl *caml_darken_all_roots())(_DWORD)
{
  return caml_do_roots((void (__cdecl *)(int, char *))caml_darken);
}

//----- (0805CAAA) --------------------------------------------------------
int (__cdecl *caml_oldify_local_roots())(_DWORD)
{
  int v0; // eax
  int *i; // edi
  unsigned int *v2; // edx
  unsigned int v3; // eax
  unsigned int j; // ebx
  unsigned int v5; // eax
  int v6; // edi
  _DWORD *v7; // esi
  int v8; // eax
  unsigned int v9; // ebx
  unsigned int *v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // edx
  int v13; // eax
  int l; // ebx
  int v15; // esi
  unsigned __int16 *m; // edi
  int v17; // edx
  unsigned int *v18; // edx
  unsigned int v19; // eax
  int v20; // eax
  _DWORD *v21; // esi
  unsigned int v22; // eax
  int ii; // ebx
  int n; // edi
  int (__cdecl *result)(_DWORD); // eax
  int k; // [esp+18h] [ebp-20h]
  int v27; // [esp+1Ch] [ebp-1Ch]
  int *v28; // [esp+1Ch] [ebp-1Ch]
  int v29; // [esp+1Ch] [ebp-1Ch]

  v27 = caml_globals_scanned;
  v0 = caml_globals_inited;
  if ( caml_globals_scanned <= caml_globals_inited )
  {
    for ( i = caml_globals[caml_globals_scanned]; i; i = caml_globals[v27] )
    {
      v5 = 0;
      for ( j = 0; j < (unsigned int)*(i - 1) >> 10; v5 = j )
      {
        v2 = (unsigned int *)&i[v5];
        v3 = *v2;
        if ( (*v2 & 1) == 0 && v3 < caml_young_end && v3 > caml_young_start )
          caml_oldify_one(v3, v2);
        ++j;
      }
      ++v27;
      v0 = caml_globals_inited;
      if ( caml_globals_inited < v27 )
        break;
    }
  }
  caml_globals_scanned = v0;
  v28 = (int *)caml_dyn_globals;
  if ( caml_dyn_globals )
  {
    do
    {
      v6 = *v28;
      v7 = (_DWORD *)(*v28 - 4);
      if ( *v7 >> 10 )
      {
        v8 = 0;
        v9 = 0;
        do
        {
          v10 = (unsigned int *)(v6 + 4 * v8);
          v11 = *v10;
          if ( (*v10 & 1) == 0 && v11 < caml_young_end && v11 > caml_young_start )
            caml_oldify_one(v11, v10);
          v8 = ++v9;
        }
        while ( v9 < *v7 >> 10 );
      }
      v28 = (int *)v28[1];
    }
    while ( v28 );
  }
  if ( !caml_frame_descriptors )
    caml_init_frame_descriptors();
  v29 = caml_bottom_of_stack;
  v12 = caml_last_return_address;
  for ( k = caml_gc_regs; v29; k = *(_DWORD *)(v20 + 8) )
  {
    while ( 1 )
    {
      v13 = caml_frame_descriptors_mask & (v12 >> 3);
      for ( l = *((_DWORD *)caml_frame_descriptors + v13);
            *(_DWORD *)l != v12;
            l = *((_DWORD *)caml_frame_descriptors + v13) )
      {
        v13 = caml_frame_descriptors_mask & (v13 + 1);
      }
      if ( *(_WORD *)(l + 4) == 0xFFFF )
        break;
      v15 = *(unsigned __int16 *)(l + 6);
      if ( *(_WORD *)(l + 6) )
      {
        for ( m = (unsigned __int16 *)(l + 8); ; ++m )
        {
          v17 = *m;
          v18 = (unsigned int *)((v17 & 1) != 0 ? k + 4 * (v17 >> 1) : v29 + v17);
          v19 = *v18;
          if ( (*v18 & 1) == 0 && v19 < caml_young_end && v19 > caml_young_start )
            caml_oldify_one(v19, v18);
          if ( --v15 <= 0 )
            break;
        }
      }
      v29 += *(_WORD *)(l + 4) & 0xFFFC;
      v12 = *(_DWORD *)(v29 - 4);
    }
    v20 = v29 + 8;
    v29 = *(_DWORD *)(v29 + 8);
    v12 = *(_DWORD *)(v20 + 4);
  }
  v21 = (_DWORD *)caml_local_roots;
  if ( caml_local_roots )
  {
    do
    {
      for ( n = 0; v21[1] > n; ++n )
      {
        for ( ii = 0; v21[2] > ii; ++ii )
        {
          v22 = *(_DWORD *)(v21[n + 3] + 4 * ii);
          if ( (v22 & 1) == 0 && v22 < caml_young_end && v22 > caml_young_start )
            caml_oldify_one(v22, (_DWORD *)(v21[n + 3] + 4 * ii));
        }
      }
      v21 = (_DWORD *)*v21;
    }
    while ( v21 );
  }
  caml_scan_global_young_roots((int)caml_oldify_one);
  caml_final_do_young_roots((void (__cdecl *)(_DWORD, char *))caml_oldify_one);
  result = caml_scan_roots_hook;
  if ( caml_scan_roots_hook )
    result = (int (__cdecl *)(_DWORD))caml_scan_roots_hook(caml_oldify_one);
  return result;
}
// 806DE34: using guessed type int *caml_globals[9];
// 807448C: using guessed type int caml_last_return_address;
// 8074754: using guessed type int caml_local_roots;
// 8074758: using guessed type int (__cdecl *caml_scan_roots_hook)(_DWORD);
// 8074760: using guessed type int caml_bottom_of_stack;
// 8074764: using guessed type int caml_globals_inited;
// 807476C: using guessed type int caml_dyn_globals;
// 8074770: using guessed type int caml_globals_scanned;
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 807B360: using guessed type int caml_frame_descriptors_mask;
// 807B368: using guessed type int caml_gc_regs;

//----- (0805CD30) --------------------------------------------------------
int __usercall caml_iterate_global_roots@<eax>(int result@<eax>, int a2@<edx>)
{
  int (__cdecl *v2)(_DWORD, _DWORD); // esi
  _DWORD *i; // ebx

  v2 = (int (__cdecl *)(_DWORD, _DWORD))result;
  for ( i = *(_DWORD **)(a2 + 4); i; i = (_DWORD *)i[1] )
    result = v2(*(_DWORD *)*i, *i);
  return result;
}

//----- (0805CD5C) --------------------------------------------------------
int __cdecl caml_scan_global_roots(int a1)
{
  caml_iterate_global_roots(a1, (int)&caml_global_roots);
  caml_iterate_global_roots(a1, (int)&caml_global_roots_young);
  return caml_iterate_global_roots(a1, (int)&caml_global_roots_old);
}

//----- (0805CD90) --------------------------------------------------------
_DWORD *__usercall caml_insert_global_root@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  int v3; // edi
  int v4; // ecx
  int v5; // edx
  unsigned int *v6; // eax
  _DWORD *result; // eax
  int v8; // eax
  int i; // esi
  int j; // eax
  int k; // edx
  int v12; // ecx
  int v13; // [esp+18h] [ebp-70h]
  int v14; // [esp+1Ch] [ebp-6Ch]
  _DWORD v15[23]; // [esp+2Ch] [ebp-5Ch]

  v13 = a1;
  v3 = a1;
  v14 = *(_DWORD *)(a1 + 72);
  v4 = v14;
  v5 = a1;
  if ( v14 >= 0 )
  {
    do
    {
      while ( 1 )
      {
        v6 = *(unsigned int **)(v5 + 4 * v4 + 4);
        if ( !v6 || *v6 >= a2 )
          break;
        v5 = *(_DWORD *)(v5 + 4 * v4 + 4);
      }
      v15[v4--] = v5;
    }
    while ( v4 != -1 );
  }
  result = *(_DWORD **)(v5 + 4);
  if ( !result || *result != a2 )
  {
    v8 = 69069 * random_seed + 25173;
    random_seed = v8;
    for ( i = 0; (v8 & 0xC0000000) == -1073741824; v8 *= 4 )
      ++i;
    if ( v14 < i )
    {
      for ( j = v14 + 1; j <= i; ++j )
        v15[j] = v3;
      *(_DWORD *)(v13 + 72) = i;
    }
    result = caml_stat_alloc(4 * i + 8);
    *result = a2;
    if ( i >= 0 )
    {
      for ( k = 0; k <= i; ++k )
      {
        v12 = v15[k];
        result[k + 1] = *(_DWORD *)(v12 + 4 * k + 4);
        *(_DWORD *)(v12 + 4 * k + 4) = result;
      }
    }
  }
  return result;
}
// 807488C: using guessed type int random_seed;

//----- (0805CE77) --------------------------------------------------------
unsigned int __cdecl caml_register_generational_global_root(unsigned int *a1)
{
  unsigned int result; // eax
  unsigned int v2; // ecx

  result = *a1;
  if ( (*a1 & 1) == 0 )
  {
    if ( result >= caml_young_end || result <= caml_young_start )
    {
      v2 = result >> 23;
      result = (result >> 12) & 0x7FF;
      if ( (*(_BYTE *)(caml_page_table[v2] + result) & 1) != 0 )
        result = (unsigned int)caml_insert_global_root((int)&caml_global_roots_old, (unsigned int)a1);
    }
    else
    {
      result = (unsigned int)caml_insert_global_root((int)&caml_global_roots_young, (unsigned int)a1);
    }
  }
  return result;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;

//----- (0805CECA) --------------------------------------------------------
_DWORD *__cdecl caml_register_global_root(unsigned int a1)
{
  return caml_insert_global_root((int)&caml_global_roots, a1);
}

//----- (0805CEDF) --------------------------------------------------------
void __cdecl caml_scan_global_young_roots(int a1)
{
  unsigned int *v1; // ebx
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  int v4; // edx
  int v5; // eax

  caml_iterate_global_roots(a1, (int)&caml_global_roots);
  caml_iterate_global_roots(a1, (int)&caml_global_roots_young);
  v1 = (unsigned int *)ptr;
  if ( ptr )
  {
    do
    {
      caml_insert_global_root((int)&caml_global_roots_old, *v1);
      v1 = (unsigned int *)v1[1];
    }
    while ( v1 );
    v2 = ptr;
    if ( ptr )
    {
      while ( 1 )
      {
        v3 = (_DWORD *)v2[1];
        caml_stat_free(v2);
        if ( !v3 )
          break;
        v2 = v3;
      }
    }
  }
  v4 = dword_8074828;
  if ( dword_8074828 >= 0 )
  {
    v5 = 0;
    do
      *(&ptr + v5++) = 0;
    while ( v5 <= v4 );
  }
  dword_8074828 = 0;
}
// 8074828: using guessed type int dword_8074828;

//----- (0805CF6C) --------------------------------------------------------
int __usercall caml_delete_global_root@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  int v2; // ebx
  int v3; // ecx
  int result; // eax
  int i; // esi
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // [esp+1Ch] [ebp-6Ch]
  _DWORD v10[23]; // [esp+2Ch] [ebp-5Ch]

  v2 = a1;
  v3 = a1;
  result = *(_DWORD *)(a1 + 72);
  v9 = result;
  if ( result >= 0 )
  {
    for ( i = result; i != -1; --i )
    {
      while ( 1 )
      {
        result = *(_DWORD *)(v3 + 4 * i + 4);
        if ( !result || *(_DWORD *)result >= a2 )
          break;
        v3 = *(_DWORD *)(v3 + 4 * i + 4);
      }
      v10[i] = v3;
    }
  }
  v6 = *(_DWORD **)(v3 + 4);
  if ( v6 && *v6 == a2 )
  {
    if ( v9 >= 0 )
    {
      v7 = 0;
      do
      {
        v8 = v10[v7];
        if ( *(_DWORD **)(v8 + 4 * v7 + 4) == v6 )
          *(_DWORD *)(v8 + 4 * v7 + 4) = v6[v7 + 1];
        ++v7;
      }
      while ( *(_DWORD *)(v2 + 72) >= v7 );
    }
    caml_stat_free(v6);
    result = *(_DWORD *)(v2 + 72);
    if ( result > 0 && !*(_DWORD *)(v2 + 4 * result + 4) )
    {
      while ( --result > 0 )
      {
        if ( *(_DWORD *)(v2 + 4 * result + 4) )
        {
          *(_DWORD *)(v2 + 72) = result;
          return result;
        }
      }
      *(_DWORD *)(v2 + 72) = result;
    }
  }
  return result;
}

//----- (0805D009) --------------------------------------------------------
unsigned int __cdecl caml_modify_generational_global_root(unsigned int *a1, unsigned int a2)
{
  unsigned int result; // eax
  unsigned int v3; // edx
  unsigned int v4; // edx

  result = *a1;
  if ( (a2 & 1) == 0 && a2 < caml_young_end && a2 > caml_young_start )
  {
    if ( (result & 1) == 0 )
    {
      v3 = result >> 23;
      result = (result >> 12) & 0x7FF;
      if ( (*(_BYTE *)(caml_page_table[v3] + result) & 1) != 0 )
      {
        caml_delete_global_root((int)&caml_global_roots_old, (unsigned int)a1);
        result = (unsigned int)caml_insert_global_root((int)&caml_global_roots_young, (unsigned int)a1);
      }
      goto LABEL_16;
    }
    goto LABEL_9;
  }
  if ( (result & 1) != 0 )
  {
    if ( (a2 & 1) != 0 )
      goto LABEL_16;
LABEL_9:
    if ( a2 >= caml_young_end || a2 <= caml_young_start )
    {
      result = (a2 >> 12) & 0x7FF;
      if ( (*(_BYTE *)(caml_page_table[a2 >> 23] + result) & 1) != 0 )
        result = (unsigned int)caml_insert_global_root((int)&caml_global_roots_old, (unsigned int)a1);
    }
    else
    {
      result = (unsigned int)caml_insert_global_root((int)&caml_global_roots_young, (unsigned int)a1);
    }
    goto LABEL_16;
  }
  if ( (a2 & 1) != 0 )
  {
    if ( result >= caml_young_end || result <= caml_young_start )
    {
      v4 = result >> 23;
      result = (result >> 12) & 0x7FF;
      if ( (*(_BYTE *)(caml_page_table[v4] + result) & 1) != 0 )
        result = caml_delete_global_root((int)&caml_global_roots_old, (unsigned int)a1);
    }
    else
    {
      result = caml_delete_global_root((int)&caml_global_roots_young, (unsigned int)a1);
    }
  }
LABEL_16:
  *a1 = a2;
  return result;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;

//----- (0805D116) --------------------------------------------------------
unsigned int __cdecl caml_remove_generational_global_root(unsigned int *a1)
{
  unsigned int result; // eax
  unsigned int v2; // ecx

  result = *a1;
  if ( (*a1 & 1) == 0 )
  {
    if ( result >= caml_young_end || result <= caml_young_start )
    {
      v2 = result >> 23;
      result = (result >> 12) & 0x7FF;
      if ( (*(_BYTE *)(caml_page_table[v2] + result) & 1) != 0 )
        result = caml_delete_global_root((int)&caml_global_roots_old, (unsigned int)a1);
    }
    else
    {
      result = caml_delete_global_root((int)&caml_global_roots_young, (unsigned int)a1);
    }
  }
  return result;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;

//----- (0805D169) --------------------------------------------------------
int __cdecl caml_remove_global_root(unsigned int a1)
{
  return caml_delete_global_root((int)&caml_global_roots, a1);
}

//----- (0805D180) --------------------------------------------------------
int __cdecl caml_record_signal(int a1)
{
  int result; // eax

  caml_pending_signals[a1] = 1;
  caml_signals_are_pending = 1;
  result = caml_young_end;
  caml_young_limit = caml_young_end;
  return result;
}
// 8074890: using guessed type int caml_signals_are_pending;
// 80778D0: using guessed type int caml_young_end;
// 80778D8: using guessed type int caml_young_limit;

//----- (0805D1A7) --------------------------------------------------------
void caml_enter_blocking_section_default()
{
  caml_async_signal_mode = 1;
}
// 8074898: using guessed type int caml_async_signal_mode;

//----- (0805D1B6) --------------------------------------------------------
void caml_leave_blocking_section_default()
{
  caml_async_signal_mode = 0;
}
// 8074898: using guessed type int caml_async_signal_mode;

//----- (0805D1C5) --------------------------------------------------------
__int32 caml_try_leave_blocking_section_default()
{
  return _InterlockedExchange(&caml_async_signal_mode, 0);
}
// 8074898: using guessed type int caml_async_signal_mode;

//----- (0805D1D2) --------------------------------------------------------
int caml_urge_major_slice()
{
  int result; // eax

  caml_force_major_slice = 1;
  result = caml_young_end;
  caml_young_limit = caml_young_end;
  return result;
}
// 8074894: using guessed type int caml_force_major_slice;
// 80778D0: using guessed type int caml_young_end;
// 80778D8: using guessed type int caml_young_limit;

//----- (0805D1EB) --------------------------------------------------------
int __cdecl caml_convert_signal_number(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 < 0 && (unsigned int)a1 > 0xFFFFFFEA )
    result = posix_signals[~a1];
  return result;
}

//----- (0805D205) --------------------------------------------------------
int __cdecl caml_rev_convert_signal_number(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = 1;
  if ( a1 == 6 )
  {
    LOBYTE(v2) = 0;
  }
  else
  {
    while ( posix_signals[v2] != a1 )
    {
      if ( ++v2 == 21 )
        return result;
    }
  }
  return ~v2;
}

//----- (0805D233) --------------------------------------------------------
int __cdecl caml_execute_signal(int signo, int a2)
{
  int v2; // eax
  int v3; // edi
  int result; // eax
  int v5; // [esp+4h] [ebp-A4h]
  int v6; // [esp+8h] [ebp-A0h]
  int v7; // [esp+Ch] [ebp-9Ch]
  sigset_t set; // [esp+10h] [ebp-98h] BYREF

  sigemptyset(&set);
  sigaddset(&set, signo);
  sigprocmask(0, &set, &set);
  caml_rev_convert_signal_number(signo);
  caml_callback_exn();
  v3 = v2;
  if ( a2 )
  {
    result = v2 & 3;
    if ( result != 2 )
      return result;
    sigdelset(&set, signo);
    sigprocmask(2, &set, 0);
  }
  else
  {
    sigprocmask(2, &set, 0);
    result = v3 & 3;
    if ( result != 2 )
      return result;
  }
  return caml_raise(v3 & 0xFFFFFFFC, v5, v6, v7, set.__val[0]);
}
// 805D296: variable 'v2' is possibly undefined
// 805D2FA: variable 'v5' is possibly undefined
// 805D2FA: variable 'v6' is possibly undefined
// 805D2FA: variable 'v7' is possibly undefined
// 807489C: using guessed type int caml_signal_handlers;

//----- (0805D30C) --------------------------------------------------------
int caml_process_pending_signals()
{
  int result; // eax
  int i; // ebx

  result = caml_signals_are_pending;
  if ( caml_signals_are_pending )
  {
    caml_signals_are_pending = 0;
    for ( i = 0; i != 65; ++i )
    {
      result = caml_pending_signals[i];
      if ( result )
      {
        caml_pending_signals[i] = 0;
        result = caml_execute_signal(i, 0);
      }
    }
  }
  return result;
}
// 8074890: using guessed type int caml_signals_are_pending;

//----- (0805D35E) --------------------------------------------------------
int __cdecl caml_install_signal_handler(int a1, unsigned int *a2)
{
  int v2; // ebx
  unsigned int v3; // eax
  unsigned int v4; // esi
  int v5; // edx
  int v6; // eax
  int v8; // [esp+4h] [ebp-74h]
  unsigned int v9; // [esp+8h] [ebp-70h]
  int v10; // [esp+Ch] [ebp-6Ch]
  _DWORD *v11; // [esp+10h] [ebp-68h]
  int v12[8]; // [esp+1Ch] [ebp-5Ch] BYREF
  int v13; // [esp+3Ch] [ebp-3Ch] BYREF
  int v14[14]; // [esp+40h] [ebp-38h] BYREF

  v2 = caml_local_roots;
  v14[0] = caml_local_roots;
  v14[2] = 1;
  v14[1] = 2;
  v14[3] = (int)&a1;
  v14[4] = (int)&a2;
  v13 = 0;
  v12[0] = (int)v14;
  caml_local_roots = (int)v12;
  v12[2] = 1;
  v12[1] = 1;
  v12[3] = (int)&v13;
  v3 = caml_convert_signal_number(a1 >> 1);
  v4 = v3;
  if ( v3 > 0x40 )
    v3 = caml_invalid_argument("Sys.signal: unavailable signal", v8, v9, v10, v11);
  v5 = 2;
  if ( (unsigned int)a2 - 1 <= 2 )
    v5 = dword_806B9D0[(_DWORD)a2];
  v6 = caml_set_signal_action(v3, v5);
  if ( v6 == 1 )
  {
    v13 = 3;
  }
  else if ( v6 == 2 )
  {
    v13 = caml_alloc_small(1, 0);
    *(_DWORD *)v13 = *(_DWORD *)(caml_signal_handlers + 4 * v4);
  }
  else if ( v6 )
  {
    caml_sys_error((void *)1);
  }
  else
  {
    v13 = 1;
  }
  if ( ((unsigned __int8)a2 & 1) == 0 )
  {
    if ( !caml_signal_handlers )
    {
      caml_signal_handlers = (int)caml_alloc(0x41u, 0);
      caml_register_global_root((unsigned int)&caml_signal_handlers);
    }
    caml_modify((unsigned int *)(caml_signal_handlers + 4 * v4), *a2);
  }
  caml_process_pending_signals();
  caml_local_roots = v2;
  return v13;
}
// 805D3CE: variable 'v8' is possibly undefined
// 805D3CE: variable 'v9' is possibly undefined
// 805D3CE: variable 'v10' is possibly undefined
// 805D3CE: variable 'v11' is possibly undefined
// 806B9D0: using guessed type int dword_806B9D0[];
// 8074754: using guessed type int caml_local_roots;
// 807489C: using guessed type int caml_signal_handlers;

//----- (0805D4AA) --------------------------------------------------------
int caml_leave_blocking_section()
{
  caml_leave_blocking_section_hook();
  return caml_process_pending_signals();
}
// 8074494: using guessed type int (*caml_leave_blocking_section_hook)(void);

//----- (0805D4BD) --------------------------------------------------------
int caml_enter_blocking_section()
{
  int result; // eax

  while ( 1 )
  {
    caml_process_pending_signals();
    caml_enter_blocking_section_hook();
    result = caml_signals_are_pending;
    if ( !caml_signals_are_pending )
      break;
    caml_leave_blocking_section_hook();
  }
  return result;
}
// 8074490: using guessed type int (*caml_enter_blocking_section_hook)(void);
// 8074494: using guessed type int (*caml_leave_blocking_section_hook)(void);
// 8074890: using guessed type int caml_signals_are_pending;

//----- (0805D4F0) --------------------------------------------------------
int caml_init_signals()
{
  int result; // eax
  struct sigaction v1; // [esp+18h] [ebp-A0h] BYREF
  struct sigaltstack v2; // [esp+A4h] [ebp-14h] BYREF

  v2.ss_sp = &sig_alt_stack;
  v2.ss_size = 0x2000;
  v2.ss_flags = 0;
  v1.sa_handler = (__sighandler_t)segv_handler;
  v1.sa_flags = 1207959552;
  sigemptyset(&v1.sa_mask);
  system_stack_top = (int)&v1;
  result = sigaltstack(&v2, 0);
  if ( !result )
    result = sigaction(11, &v1, 0);
  return result;
}
// 80748A0: using guessed type int system_stack_top;

//----- (0805D572) --------------------------------------------------------
int __cdecl caml_set_signal_action(int sig, int a2)
{
  int v2; // edx
  int result; // eax
  struct sigaction v4; // [esp+18h] [ebp-120h] BYREF
  struct sigaction v5; // [esp+A4h] [ebp-94h] BYREF

  if ( a2 )
  {
    if ( a2 == 1 )
      v5.sa_handler = (__sighandler_t)1;
    else
      v5.sa_handler = handle_signal;
    v5.sa_flags = 0;
  }
  else
  {
    v5.sa_handler = 0;
    v5.sa_flags = 0;
  }
  sigemptyset(&v5.sa_mask);
  v2 = sigaction(sig, &v5, &v4);
  result = -1;
  if ( v2 != -1 )
  {
    result = 2;
    if ( v4.sa_handler != handle_signal )
      result = v4.sa_handler == (__sighandler_t)1;
  }
  return result;
}

//----- (0805D61F) --------------------------------------------------------
int __cdecl segv_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, unsigned int a23)
{
  int v24; // [esp+8h] [ebp-B0h]
  int v25; // [esp+Ch] [ebp-ACh]
  _DWORD *v26; // [esp+10h] [ebp-A8h]
  struct sigaction v27; // [esp+14h] [ebp-A4h] BYREF
  int v28[6]; // [esp+A0h] [ebp-18h] BYREF

  if ( (a23 & 3) == 0 && !getrlimit64() && a23 < system_stack_top && a23 >= system_stack_top - v28[0] - 0x2000 )
    caml_raise_stack_overflow(3, (int)v28, v24, v25, v26);
  v27.sa_handler = 0;
  v27.sa_flags = 0;
  sigemptyset(&v27.sa_mask);
  return sigaction(11, &v27, 0);
}
// 805D65E: variable 'v24' is possibly undefined
// 805D65E: variable 'v25' is possibly undefined
// 805D65E: variable 'v26' is possibly undefined
// 804A754: using guessed type int getrlimit64(void);
// 80748A0: using guessed type int system_stack_top;

//----- (0805D6A9) --------------------------------------------------------
void __cdecl handle_signal(int signo)
{
  if ( (unsigned int)signo <= 0x40 )
  {
    if ( caml_try_leave_blocking_section_hook() )
    {
      caml_execute_signal(signo, 1);
      caml_enter_blocking_section_hook();
    }
    else
    {
      caml_record_signal(signo);
    }
  }
}
// 8074490: using guessed type int (*caml_enter_blocking_section_hook)(void);
// 8074498: using guessed type int (*caml_try_leave_blocking_section_hook)(void);

//----- (0805D6EB) --------------------------------------------------------
int caml_garbage_collection()
{
  caml_young_limit = caml_young_start;
  if ( caml_young_start > (unsigned int)caml_young_ptr || caml_force_major_slice )
    caml_minor_collection();
  return caml_process_pending_signals();
}
// 8074894: using guessed type int caml_force_major_slice;
// 80778CC: using guessed type int caml_young_start;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0805D718) --------------------------------------------------------
void __cdecl caml_ext_table_free(int a1, int a2)
{
  int v2; // ebx

  if ( a2 && *(int *)a1 > 0 )
  {
    v2 = 0;
    do
      caml_stat_free(*(void **)(*(_DWORD *)(a1 + 8) + 4 * v2++));
    while ( *(_DWORD *)a1 > v2 );
  }
  caml_stat_free(*(void **)(a1 + 8));
}

//----- (0805D75A) --------------------------------------------------------
int __cdecl caml_ext_table_add(int *a1, int a2)
{
  int v2; // eax
  int result; // eax

  v2 = a1[1];
  if ( *a1 >= v2 )
  {
    a1[1] = 2 * v2;
    a1[2] = (int)caml_stat_resize((void *)a1[2], 8 * v2);
  }
  result = *a1;
  *(_DWORD *)(a1[2] + 4 * (*a1)++) = a2;
  return result;
}

//----- (0805D79A) --------------------------------------------------------
void *__cdecl caml_ext_table_init(_DWORD *a1, int a2)
{
  void *result; // eax

  *a1 = 0;
  a1[1] = a2;
  result = caml_stat_alloc(4 * a2);
  a1[2] = result;
  return result;
}

//----- (0805D7C4) --------------------------------------------------------
int __cdecl caml_aligned_malloc(int a1, int a2, _DWORD *a3)
{
  void *v3; // edx
  int result; // eax

  v3 = malloc(a1 + 4096);
  result = 0;
  if ( v3 )
  {
    *a3 = v3;
    result = (((unsigned int)v3 + a2) & 0xFFFFF000) + 4096 - a2;
  }
  return result;
}

//----- (0805D804) --------------------------------------------------------
void __cdecl __noreturn caml_fatal_error_arg2(char *format, int a2, char *a3, int a4)
{
  fprintf(stderr, format, a2);
  fprintf(stderr, a3, a4);
  exit(2);
}

//----- (0805D84C) --------------------------------------------------------
void __cdecl __noreturn caml_fatal_error_arg(char *format, int a2)
{
  fprintf(stderr, format, a2);
  exit(2);
}

//----- (0805D879) --------------------------------------------------------
void __cdecl __noreturn caml_fatal_error(char *s)
{
  fputs(s, stderr);
  exit(2);
}

//----- (0805D89F) --------------------------------------------------------
int __cdecl caml_gc_message(int a1, char *format, int a3)
{
  int result; // eax

  result = a1;
  if ( a1 < 0 || (a1 & caml_verb_gc) != 0 )
  {
    fprintf(stderr, format, a3);
    result = fflush(stderr);
  }
  return result;
}
// 80768C0: using guessed type int caml_verb_gc;

//----- (0805D8E0) --------------------------------------------------------
int *__usercall allocate_block@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, int *a4)
{
  int *v4; // esi
  unsigned int v5; // ebx
  int *v6; // edi
  int v7; // edi

  v4 = a4 - 1;
  v5 = (unsigned int)*(a4 - 1) >> 10;
  if ( v5 >= a1 + 1 )
  {
    caml_fl_cur_size -= a1;
    *v4 = ((v5 - a1) << 10) + 512;
  }
  else
  {
    caml_fl_cur_size += ~v5;
    *a3 = *a4;
    v6 = caml_fl_merge;
    if ( caml_fl_merge == a4 )
      v6 = a3;
    caml_fl_merge = v6;
    *v4 = 0;
    if ( caml_allocation_policy == 1 )
    {
      v7 = a2 + 1;
      if ( a2 + 1 < flp_size && (int *)flp[v7] == a4 )
      {
        flp[v7] = (int)a3;
        return &a4[v5 - a1];
      }
      if ( flp_size - 1 == a2 )
      {
        if ( a3 == &dword_80744A8 )
          a3 = 0;
        beyond = (int)a3;
        --flp_size;
        return &a4[v5 - a1];
      }
    }
  }
  if ( !caml_allocation_policy )
    fl_prev = a3;
  return &a4[v5 - a1];
}
// 807449C: using guessed type int *caml_fl_merge;
// 80744A8: using guessed type int dword_80744A8;
// 80744B0: using guessed type int *fl_prev;
// 80768E0: using guessed type int caml_fl_cur_size;
// 80768E8: using guessed type int flp_size;
// 80768EC: using guessed type int beyond;
// 8076900: using guessed type int flp[];

//----- (0805D9B2) --------------------------------------------------------
void caml_fl_init_merge()
{
  last_fragment = 0;
  caml_fl_merge = &dword_80744A8;
}
// 807449C: using guessed type int *caml_fl_merge;
// 80744A8: using guessed type int dword_80744A8;
// 80778A0: using guessed type int last_fragment;

//----- (0805D9CB) --------------------------------------------------------
int *__usercall truncate_flp@<eax>(int *result@<eax>)
{
  int v1; // edx

  if ( result == &dword_80744A8 )
  {
    flp_size = 0;
    beyond = 0;
  }
  else
  {
    if ( flp_size > 0 )
    {
      v1 = flp_size - 1;
      if ( (unsigned int)result <= *(_DWORD *)flp[flp_size - 1] )
      {
        while ( v1 > 0 )
        {
          if ( (unsigned int)result > *(_DWORD *)flp[v1 - 1] )
          {
            flp_size = v1;
            goto LABEL_11;
          }
          --v1;
        }
        flp_size = v1;
      }
    }
LABEL_11:
    if ( (unsigned int)result <= beyond )
      beyond = 0;
  }
  return result;
}
// 80744A8: using guessed type int dword_80744A8;
// 80768E8: using guessed type int flp_size;
// 80768EC: using guessed type int beyond;
// 8076900: using guessed type int flp[];

//----- (0805DA40) --------------------------------------------------------
void caml_fl_reset()
{
  dword_80744A8 = 0;
  if ( caml_allocation_policy )
  {
    if ( caml_allocation_policy == 1 )
      truncate_flp(&dword_80744A8);
  }
  else
  {
    fl_prev = &dword_80744A8;
  }
  caml_fl_cur_size = 0;
  caml_fl_init_merge();
}
// 80744A8: using guessed type int dword_80744A8;
// 80744B0: using guessed type int *fl_prev;
// 80768E0: using guessed type int caml_fl_cur_size;

//----- (0805DA84) --------------------------------------------------------
int *__cdecl caml_fl_merge_block(int *a1)
{
  unsigned int v1; // esi
  int *v2; // ebx
  int *v3; // edx
  unsigned int v4; // eax
  int *result; // eax
  unsigned int v6; // ecx
  int *v7; // eax
  int *v8; // ecx
  unsigned int v9; // edi
  unsigned int v10; // ebx
  int *v11; // [esp+8h] [ebp-18h]
  int *v12; // [esp+Ch] [ebp-14h]
  int v13; // [esp+10h] [ebp-10h]

  v1 = *(a1 - 1);
  caml_fl_cur_size += (v1 >> 10) + 1;
  v2 = caml_fl_merge;
  v11 = caml_fl_merge;
  v12 = (int *)*caml_fl_merge;
  if ( caml_allocation_policy == 1 )
    truncate_flp(caml_fl_merge);
  v3 = a1 - 1;
  if ( a1 - 1 == (int *)last_fragment && (v4 = ((unsigned int)*(a1 - 1) >> 10) + 1, v4 <= 0x3FFFFF) )
  {
    v1 = v4 << 10;
    *(a1 - 2) = v4 << 10;
    ++caml_fl_cur_size;
  }
  else
  {
    v3 = a1;
  }
  result = v12 - 1;
  if ( v12 - 1 == &v3[v1 >> 10] )
  {
    v13 = *v12;
    v6 = (v1 >> 10) + ((unsigned int)*(v12 - 1) >> 10) + 1;
    if ( v6 <= 0x3FFFFF )
    {
      *v11 = v13;
      if ( !caml_allocation_policy )
      {
        v7 = fl_prev;
        if ( fl_prev == v12 )
          v7 = v2;
        fl_prev = v7;
      }
      v1 = (v6 << 10) + 512;
      *(v3 - 1) = v1;
      result = &v3[v1 >> 10];
      v12 = (int *)v13;
    }
  }
  else
  {
    result = &v3[v1 >> 10];
  }
  v8 = v2 - 1;
  v9 = (unsigned int)*(v2 - 1) >> 10;
  if ( &v2[v9] == v3 - 1 && (v10 = v9 + (v1 >> 10) + 1, v10 <= 0x3FFFFE) )
  {
    *v8 = (v10 << 10) + 512;
  }
  else if ( v1 >> 10 )
  {
    *(v3 - 1) = v1 & 0xFFFFFCFF | 0x200;
    *v3 = (int)v12;
    *v11 = (int)v3;
    caml_fl_merge = v3;
  }
  else
  {
    last_fragment = (int)v3;
    --caml_fl_cur_size;
  }
  return result;
}
// 807449C: using guessed type int *caml_fl_merge;
// 80744B0: using guessed type int *fl_prev;
// 80768E0: using guessed type int caml_fl_cur_size;
// 80778A0: using guessed type int last_fragment;

//----- (0805DBE9) --------------------------------------------------------
int *__cdecl caml_fl_add_blocks(unsigned int a1)
{
  int *result; // eax
  int *v2; // edx
  int *v3; // ecx
  int *v4; // ebx

  result = (int *)a1;
  caml_fl_cur_size += (*(_DWORD *)(a1 - 4) >> 10) + 1;
  v2 = (int *)fl_last;
  if ( a1 <= fl_last )
  {
    v3 = (int *)dword_80744A8;
    if ( dword_80744A8 && a1 > dword_80744A8 )
    {
      while ( *v3 && a1 > *v3 )
        v3 = (int *)*v3;
      v4 = v3;
      v3 = (int *)*v3;
    }
    else
    {
      v4 = &dword_80744A8;
    }
    **(_DWORD **)(a1 + 4) = v3;
    *v4 = a1;
    if ( v4 == caml_fl_merge && a1 < caml_gc_sweep_hp )
      caml_fl_merge = *(int **)(a1 + 4);
    if ( caml_allocation_policy == 1 )
      result = truncate_flp((int *)a1);
  }
  else
  {
    *(_DWORD *)fl_last = a1;
    if ( v2 == caml_fl_merge && a1 < caml_gc_sweep_hp )
    {
      result = *(int **)(a1 + 4);
      caml_fl_merge = result;
    }
    if ( caml_allocation_policy == 1 )
    {
      result = (int *)flp_size;
      if ( flp_size <= 999 )
      {
        flp[flp_size] = (int)v2;
        result = (int *)((char *)result + 1);
        flp_size = (int)result;
      }
    }
  }
  return result;
}
// 807449C: using guessed type int *caml_fl_merge;
// 80744A8: using guessed type int dword_80744A8;
// 80768E0: using guessed type int caml_fl_cur_size;
// 80768E8: using guessed type int flp_size;
// 80768F0: using guessed type int fl_last;
// 8076900: using guessed type int flp[];
// 807B48C: using guessed type int caml_gc_sweep_hp;

//----- (0805DCA9) --------------------------------------------------------
int *__cdecl caml_make_free_blocks(int **a1, unsigned int a2, int a3)
{
  unsigned int v4; // edi
  int v5; // ebx
  int *result; // eax

  v4 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = 0x400000;
      if ( v4 <= 0x400000 )
        v5 = v4;
      result = (int *)((v5 - 1) << 10);
      *a1 = result;
      if ( a3 )
        result = caml_fl_merge_block((int *)a1 + 1);
      v4 -= v5;
      if ( !v4 )
        break;
      a1 += v5;
    }
  }
  return result;
}

//----- (0805DCF4) --------------------------------------------------------
int __cdecl caml_set_allocation_policy(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      flp_size = 0;
      beyond = 0;
    }
  }
  else
  {
    fl_prev = &dword_80744A8;
  }
  caml_allocation_policy = a1;
  return result;
}
// 80744A8: using guessed type int dword_80744A8;
// 80744B0: using guessed type int *fl_prev;
// 80768E8: using guessed type int flp_size;
// 80768EC: using guessed type int beyond;

//----- (0805DD2C) --------------------------------------------------------
int *__cdecl caml_fl_allocate(unsigned int a1)
{
  int *v1; // ecx
  int *v2; // edx
  unsigned int v3; // esi
  int v4; // ebx
  int *v5; // ecx
  int *v6; // edx
  int *v7; // edi
  int *v8; // ecx
  unsigned int v9; // edi
  int *v10; // edx
  int *v11; // ecx
  unsigned int v12; // esi
  int *v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  _DWORD *v16; // eax
  int v17; // edx
  unsigned int v18; // esi
  int v19; // ebx
  _DWORD *v20; // edi
  _DWORD *v21; // edx
  unsigned int v22; // ecx
  int *v24; // [esp+10h] [ebp-FC8h]
  int v25; // [esp+14h] [ebp-FC4h]
  unsigned int v26; // [esp+1Ch] [ebp-FBCh]
  int src[1006]; // [esp+20h] [ebp-FB8h] BYREF

  if ( !caml_allocation_policy )
  {
    v5 = fl_prev;
    v6 = (int *)*fl_prev;
    if ( *fl_prev )
    {
      if ( a1 <= (unsigned int)*(v6 - 1) >> 10 )
        return allocate_block(a1 + 1, 0, v5, v6);
      while ( 1 )
      {
        v5 = v6;
        v6 = (int *)*v6;
        if ( !v6 )
          break;
        if ( (unsigned int)*(v6 - 1) >> 10 >= a1 )
          return allocate_block(a1 + 1, 0, v5, v6);
      }
    }
    fl_last = (int)v5;
    v5 = &dword_80744A8;
    v6 = (int *)dword_80744A8;
    if ( &dword_80744A8 == fl_prev )
      return 0;
    if ( a1 > *(_DWORD *)(dword_80744A8 - 4) >> 10 )
    {
      while ( 1 )
      {
        v5 = v6;
        v6 = (int *)*v6;
        if ( fl_prev == v5 )
          break;
        if ( a1 <= (unsigned int)*(v6 - 1) >> 10 )
          return allocate_block(a1 + 1, 0, v5, v6);
      }
      return 0;
    }
    return allocate_block(a1 + 1, 0, v5, v6);
  }
  if ( caml_allocation_policy != 1 )
    return 0;
  if ( flp_size > 0 )
  {
    v1 = (int *)flp[0];
    v2 = *(int **)flp[0];
    v3 = *(_DWORD *)(*(_DWORD *)flp[0] - 4) >> 10;
    v4 = 0;
    if ( a1 <= v3 )
    {
LABEL_19:
      v7 = allocate_block(a1 + 1, v4, v1, v2);
LABEL_48:
      if ( v4 < flp_size )
      {
        v15 = 0;
        if ( v4 > 0 )
          v15 = *(_DWORD *)(*(_DWORD *)dword_80768FC[v4] - 4) >> 10;
        if ( flp_size - 1 == v4 )
        {
          if ( v15 < *(_DWORD *)(*(_DWORD *)flp[flp_size - 1] - 4) >> 10 )
            beyond = 0;
          else
            beyond = *(_DWORD *)flp[--flp_size];
        }
        else
        {
          v16 = (_DWORD *)flp[v4];
          v17 = flp[v4 + 1];
          v26 = v3;
          v18 = v15;
          v25 = v4;
          v19 = 0;
          v24 = v7;
          v20 = (_DWORD *)v17;
          while ( v20 != v16 )
          {
            v21 = (_DWORD *)*v16;
            v22 = *(_DWORD *)(*v16 - 4) >> 10;
            if ( v18 < v22 )
            {
              src[v19++] = (int)v16;
              if ( v26 <= v22 )
                break;
              v18 = v22;
            }
            v16 = v21;
          }
          v7 = v24;
          if ( flp_size - 1 + v19 > 1000 )
          {
            if ( v25 + v19 > 999 )
            {
              if ( v25 != 1000 )
                memmove(&flp[v25], src, 4 * (1000 - v25));
            }
            else if ( v19 == 1
                   || (memmove(&flp[v25 + v19], (char *)&unk_8076904 + 4 * v25, 4 * (1000 - v25 - v19)), v19 > 0) )
            {
              memmove(&flp[v25], src, 4 * v19);
            }
            flp_size = 999;
            beyond = *(_DWORD *)dword_807789C;
          }
          else
          {
            if ( v19 == 1
              || (memmove(&flp[v25 + v19], (char *)&unk_8076904 + 4 * v25, 4 * (flp_size - 1 - v25)), v19 > 0) )
            {
              memmove(&flp[v25], src, 4 * v19);
            }
            flp_size = v19 + flp_size - 1;
          }
        }
      }
      return v7;
    }
    while ( ++v4 < flp_size )
    {
      v1 = (int *)flp[v4];
      v2 = (int *)*v1;
      v3 = *(_DWORD *)(*v1 - 4) >> 10;
      if ( a1 <= v3 )
        goto LABEL_19;
    }
  }
  if ( flp_size )
  {
    v8 = *(int **)dword_80768FC[flp_size];
    v9 = (unsigned int)*(v8 - 1) >> 10;
    if ( beyond )
      v8 = (int *)beyond;
  }
  else
  {
    v8 = &dword_80744A8;
    v9 = 0;
  }
  v10 = 0;
  while ( flp_size <= 999 )
  {
    v10 = (int *)*v8;
    if ( !*v8 )
    {
      fl_last = (int)v8;
      if ( v8 == &dword_80744A8 )
        v8 = 0;
      beyond = (int)v8;
      return 0;
    }
    v3 = (unsigned int)*(v10 - 1) >> 10;
    if ( v9 < v3 )
    {
      flp[flp_size] = (int)v8;
      v4 = flp_size++;
      if ( a1 <= v3 )
      {
        beyond = (int)v10;
        v7 = allocate_block(a1 + 1, v4, v8, v10);
        goto LABEL_48;
      }
      v9 = v3;
    }
    v8 = v10;
  }
  beyond = (int)v10;
  v11 = v10;
  if ( !v10 )
    v11 = (int *)dword_80768FC[flp_size];
  v12 = *(_DWORD *)(*(_DWORD *)dword_807789C - 4) >> 10;
  v13 = (int *)*v11;
  if ( *v11 )
  {
    while ( 1 )
    {
      v14 = (unsigned int)*(v13 - 1) >> 10;
      if ( v12 <= v14 )
      {
        if ( a1 <= v14 )
          return allocate_block(a1 + 1, flp_size, v11, v13);
      }
      else
      {
        beyond = (int)v13;
      }
      if ( !*v13 )
        break;
      v11 = v13;
      v13 = (int *)*v13;
    }
    v11 = v13;
  }
  fl_last = (int)v11;
  return 0;
}
// 80744A8: using guessed type int dword_80744A8;
// 80744B0: using guessed type int *fl_prev;
// 80768E8: using guessed type int flp_size;
// 80768EC: using guessed type int beyond;
// 80768F0: using guessed type int fl_last;
// 80768FC: using guessed type int dword_80768FC[];
// 8076900: using guessed type int flp[];
// 807789C: using guessed type int dword_807789C;

//----- (0805E1B0) --------------------------------------------------------
unsigned int __usercall clip_heap_chunk_size@<eax>(unsigned int a1@<eax>)
{
  if ( a1 <= 0x1FFF )
    a1 = 0x2000;
  return (a1 + 4095) & 0xFFFFF000;
}

//----- (0805E1CC) --------------------------------------------------------
int __cdecl caml_init_major_heap(unsigned int a1)
{
  void *v1; // eax
  void *v2; // eax
  int result; // eax

  caml_stat_heap_size = clip_heap_chunk_size(a1);
  caml_stat_top_heap_size = caml_stat_heap_size;
  v1 = (void *)caml_alloc_for_heap(caml_stat_heap_size);
  caml_heap_start = v1;
  if ( !v1 )
    caml_fatal_error("Fatal error: not enough memory for the initial heap.\n");
  *((_DWORD *)v1 - 1) = 0;
  caml_stat_heap_chunks = 1;
  if ( caml_page_table_add(1, (int)caml_heap_start, (int)caml_heap_start + caml_stat_heap_size) )
    caml_fatal_error("Fatal error: not enough memory for the initial page table.\n");
  caml_fl_init_merge();
  caml_make_free_blocks((int **)caml_heap_start, (unsigned int)caml_stat_heap_size >> 2, 1);
  caml_gc_phase = 2;
  gray_vals_size = 2048;
  v2 = malloc(0x2000u);
  gray_vals = v2;
  if ( !v2 )
    caml_fatal_error("Fatal error: not enough memory for the gray cache.\n");
  gray_vals_cur = (int)v2;
  result = (int)v2 + 4 * gray_vals_size;
  gray_vals_end = result;
  heap_is_pure = 1;
  caml_allocated_words = 0;
  caml_extra_heap_resources = 0.0;
  return result;
}
// 80778AC: using guessed type int gray_vals_cur;
// 80778B0: using guessed type int gray_vals_end;
// 80778B4: using guessed type int gray_vals_size;
// 80778B8: using guessed type int heap_is_pure;
// 807AE00: using guessed type int caml_stat_heap_size;
// 807AE04: using guessed type int caml_stat_top_heap_size;
// 807AE0C: using guessed type int caml_stat_heap_chunks;
// 807B49C: using guessed type int caml_gc_phase;
// 807B4A0: using guessed type double caml_extra_heap_resources;

//----- (0805E2CF) --------------------------------------------------------
#error "805E2EC: call analysis failed (funcsize=16)"

//----- (0805E2F7) --------------------------------------------------------
int (__cdecl *start_cycle())(_DWORD)
{
  int (__cdecl *result)(_DWORD); // eax

  caml_gc_message(1, "Starting new major GC cycle\n", 0);
  result = caml_darken_all_roots();
  caml_gc_phase = 0;
  caml_gc_subphase = 10;
  markhp = 0;
  return result;
}
// 80778BC: using guessed type int markhp;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0805E33E) --------------------------------------------------------
int realloc_gray_vals()
{
  int result; // eax
  void *v1; // eax
  int v2; // edx

  result = caml_stat_heap_size / 128;
  if ( caml_stat_heap_size / 128 <= (unsigned int)gray_vals_size )
  {
    gray_vals_cur = (int)gray_vals + 4 * ((unsigned int)gray_vals_size >> 1);
    heap_is_pure = 0;
  }
  else
  {
    caml_gc_message(8, "Growing gray_vals to %luk bytes\n", (unsigned int)(4 * gray_vals_size) >> 9);
    v1 = realloc(gray_vals, 8 * gray_vals_size);
    if ( v1 )
    {
      gray_vals = v1;
      v2 = gray_vals_size;
      gray_vals_cur = (int)v1 + 4 * gray_vals_size;
      gray_vals_size *= 2;
      result = (int)v1 + 8 * v2;
      gray_vals_end = result;
    }
    else
    {
      caml_gc_message(8, "No room for growing gray_vals\n", 0);
      result = (int)gray_vals;
      gray_vals_cur = (int)gray_vals;
      heap_is_pure = 0;
    }
  }
  return result;
}
// 80778AC: using guessed type int gray_vals_cur;
// 80778B0: using guessed type int gray_vals_end;
// 80778B4: using guessed type int gray_vals_size;
// 80778B8: using guessed type int heap_is_pure;
// 807AE00: using guessed type int caml_stat_heap_size;

//----- (0805E413) --------------------------------------------------------
void __usercall mark_slice(int a1@<eax>)
{
  unsigned int *v1; // esi
  int v2; // edi
  unsigned int *v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // edx
  unsigned int v9; // ecx
  char v10; // cl
  unsigned int v11; // edx
  int v12; // eax
  unsigned int v13; // eax
  void *v14; // edi
  _DWORD *v15; // edx
  unsigned int v16; // eax
  int v17; // ebx
  char v18; // cl
  _DWORD *v19; // eax
  unsigned int *v20; // [esp+14h] [ebp-34h]
  int v21; // [esp+14h] [ebp-34h]
  unsigned int v22; // [esp+18h] [ebp-30h]
  _DWORD *v23; // [esp+1Ch] [ebp-2Ch]
  int v24; // [esp+20h] [ebp-28h]
  int v25; // [esp+24h] [ebp-24h]
  int i; // [esp+28h] [ebp-20h]
  unsigned int v27; // [esp+2Ch] [ebp-1Ch]

  v25 = a1;
  caml_gc_message(64, "Marking %ld words\n", a1);
  caml_gc_message(64, "Subphase = %ld\n", caml_gc_subphase);
  v1 = (unsigned int *)gray_vals_cur;
  while ( v25 > 0 )
  {
    if ( gray_vals >= v1 )
    {
      if ( markhp )
      {
        if ( markhp == limit )
        {
          v12 = *(_DWORD *)(chunk - 4);
          chunk = v12;
          if ( v12 )
          {
            markhp = v12;
            limit = *(_DWORD *)(v12 - 8) + v12;
          }
          else
          {
            markhp = 0;
          }
        }
        else
        {
          if ( (*(_DWORD *)markhp & 0x300) == 256 )
            *v1++ = markhp + 4;
          markhp += 4 * (*(_DWORD *)markhp >> 10) + 4;
        }
      }
      else if ( heap_is_pure )
      {
        if ( caml_gc_subphase == 11 )
        {
          v21 = *(_DWORD *)weak_prev;
          if ( *(_DWORD *)weak_prev )
          {
            v24 = *(_DWORD *)weak_prev;
            v22 = *(_DWORD *)(*(_DWORD *)weak_prev - 4) >> 10;
            if ( v22 > 1 )
            {
              for ( i = 1; i != v22; ++i )
              {
                v13 = *(_DWORD *)(v24 + 4 * i);
                v14 = caml_weak_none;
                if ( (void *)v13 != caml_weak_none
                  && (v13 & 1) == 0
                  && (*(_BYTE *)(caml_page_table[v13 >> 23] + ((v13 >> 12) & 0x7FF)) & 1) != 0 )
                {
                  v15 = (_DWORD *)(v13 - 4);
                  if ( *(_BYTE *)(v13 - 4) == 0xFA )
                  {
                    v16 = *(_DWORD *)v13;
                    if ( (v16 & 1) == 0 )
                    {
                      while ( 1 )
                      {
                        v23 = v15;
                        v17 = (v16 >> 12) & 0x7FF;
                        if ( (*(_BYTE *)(caml_page_table[v16 >> 23] + v17) & 7) == 0 )
                          break;
                        v15 = (_DWORD *)(v16 - 4);
                        v18 = *(_BYTE *)(v16 - 4);
                        if ( v18 == -6 || v18 == -10 || v18 == -3 )
                          break;
                        *(_DWORD *)(v24 + 4 * i) = v16;
                        v14 = caml_weak_none;
                        if ( (void *)v16 == caml_weak_none
                          || (v16 & 1) != 0
                          || (*(_BYTE *)(caml_page_table[v16 >> 23] + v17) & 1) == 0 )
                        {
                          goto LABEL_62;
                        }
                        if ( *(_BYTE *)(v16 - 4) == 0xFA )
                        {
                          v16 = *(_DWORD *)v16;
                          if ( (v16 & 1) == 0 )
                            continue;
                        }
                        goto LABEL_60;
                      }
                      v15 = v23;
                    }
                  }
LABEL_60:
                  if ( (*v15 & 0x300) == 0 )
                    *(_DWORD *)(v24 + 4 * i) = v14;
                }
LABEL_62:
                ;
              }
            }
            weak_prev = v21;
            v25 += ~v22;
          }
          else
          {
            caml_gc_subphase = 12;
            weak_prev = (int)&caml_weak_list_head;
          }
        }
        else if ( caml_gc_subphase > 11 )
        {
          if ( caml_gc_subphase == 12 )
          {
            v19 = *(_DWORD **)weak_prev;
            if ( *(_DWORD *)weak_prev )
            {
              if ( (*(v19 - 1) & 0x300) != 0 )
                weak_prev = *(_DWORD *)weak_prev;
              else
                *(_DWORD *)weak_prev = *v19;
              --v25;
            }
            else
            {
              gray_vals_cur = (int)v1;
              caml_final_update();
              v1 = (unsigned int *)gray_vals_cur;
              caml_gc_subphase = 13;
            }
          }
          else if ( caml_gc_subphase == 13 )
          {
            gray_vals_cur = (int)v1;
            caml_gc_sweep_hp = (int)caml_heap_start;
            caml_fl_init_merge();
            caml_gc_phase = 1;
            chunk = (int)caml_heap_start;
            caml_gc_sweep_hp = (int)caml_heap_start;
            limit = *(_DWORD *)(chunk - 8) + chunk;
            caml_fl_size_at_phase_change = caml_fl_cur_size;
            break;
          }
        }
        else if ( caml_gc_subphase == 10 )
        {
          caml_gc_subphase = 11;
          weak_prev = (int)&caml_weak_list_head;
        }
      }
      else
      {
        heap_is_pure = 1;
        chunk = (int)caml_heap_start;
        markhp = (int)caml_heap_start;
        limit = *(_DWORD *)(chunk - 8) + chunk;
      }
    }
    else
    {
      v2 = *--v1;
      v3 = (unsigned int *)(*v1 - 4);
      v4 = *v3;
      v5 = *v3;
      BYTE1(v5) = BYTE1(*v3) | 3;
      *v3 = v5;
      v27 = v4 >> 10;
      if ( (unsigned __int8)v4 <= 0xFAu && v4 >> 10 )
      {
        v6 = 0;
        v20 = v1;
        do
        {
          v7 = *(_DWORD *)(v2 + 4 * v6);
          if ( (v7 & 1) == 0 && (*(_BYTE *)(caml_page_table[v7 >> 23] + ((v7 >> 12) & 0x7FF)) & 1) != 0 )
          {
            v8 = *(_DWORD *)(v7 - 4);
            if ( (unsigned __int8)v8 == 250 )
            {
              v9 = *(_DWORD *)v7;
              if ( (*(_DWORD *)v7 & 1) != 0
                || (*(_BYTE *)(caml_page_table[v9 >> 23] + ((v9 >> 12) & 0x7FF)) & 7) != 0
                && (v10 = *(_BYTE *)(v9 - 4), v10 != -6)
                && v10 != -10
                && v10 != -3 )
              {
                *(_DWORD *)(v2 + 4 * v6) = *(_DWORD *)v7;
              }
            }
            else if ( (unsigned __int8)v8 == 249 )
            {
              v7 = *(_DWORD *)(v2 + 4 * v6) - 4 * (v8 >> 10);
              v8 = *(_DWORD *)(v7 - 4);
            }
            if ( (v8 & 0x300) == 0 )
            {
              BYTE1(v8) = BYTE1(v8) & 0xFC | 1;
              *(_DWORD *)(v7 - 4) = v8;
              *v20 = v7;
              v11 = (unsigned int)(v20 + 1);
              v20 = (unsigned int *)v11;
              if ( v11 >= gray_vals_end )
              {
                gray_vals_cur = v11;
                realloc_gray_vals();
                v20 = (unsigned int *)gray_vals_cur;
              }
            }
          }
          ++v6;
        }
        while ( v27 > v6 );
        v1 = v20;
      }
      v25 += ~v27;
    }
  }
  gray_vals_cur = (int)v1;
}
// 8074564: using guessed type void *caml_weak_none;
// 80768E0: using guessed type int caml_fl_cur_size;
// 80778AC: using guessed type int gray_vals_cur;
// 80778B0: using guessed type int gray_vals_end;
// 80778B8: using guessed type int heap_is_pure;
// 80778BC: using guessed type int markhp;
// 80778C0: using guessed type int chunk;
// 80778C4: using guessed type int limit;
// 80778C8: using guessed type int weak_prev;
// 807AE54: using guessed type int caml_weak_list_head;
// 807B48C: using guessed type int caml_gc_sweep_hp;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0805E860) --------------------------------------------------------
int __cdecl caml_darken(unsigned int a1)
{
  int result; // eax
  unsigned int v2; // edx
  unsigned int v3; // ecx
  int v4; // edx

  result = a1;
  if ( (a1 & 1) == 0 && (*(_BYTE *)(caml_page_table[a1 >> 23] + ((a1 >> 12) & 0x7FF)) & 1) != 0 )
  {
    v2 = *(_DWORD *)(a1 - 4);
    v3 = (unsigned __int8)v2;
    if ( (unsigned __int8)v2 == 249 )
    {
      result = a1 - 4 * (v2 >> 10);
      v2 = *(_DWORD *)(result - 4);
      v3 = (unsigned __int8)v2;
    }
    if ( (v2 & 0x300) == 0 )
    {
      if ( v3 > 0xFA )
      {
        BYTE1(v2) |= 3u;
        *(_DWORD *)(result - 4) = v2;
      }
      else
      {
        BYTE1(v2) = BYTE1(v2) & 0xFC | 1;
        *(_DWORD *)(result - 4) = v2;
        v4 = gray_vals_cur;
        *(_DWORD *)gray_vals_cur = result;
        result = v4 + 4;
        gray_vals_cur = v4 + 4;
        if ( v4 + 4 >= (unsigned int)gray_vals_end )
          result = realloc_gray_vals();
      }
    }
  }
  return result;
}
// 80778AC: using guessed type int gray_vals_cur;
// 80778B0: using guessed type int gray_vals_end;

//----- (0805E8F0) --------------------------------------------------------
int __usercall sweep_slice@<eax>(int a1@<eax>)
{
  int v1; // esi
  int result; // eax
  int *v3; // ebx
  void (__cdecl *v4)(int *); // eax

  v1 = a1;
  result = caml_gc_message(64, "Sweeping %ld words\n", a1);
  while ( v1 > 0 )
  {
    v3 = (int *)caml_gc_sweep_hp;
    if ( caml_gc_sweep_hp >= (unsigned int)limit )
    {
      result = *(_DWORD *)(chunk - 4);
      chunk = result;
      if ( !result )
      {
        ++caml_stat_major_collections;
        caml_gc_phase = 2;
        return result;
      }
      caml_gc_sweep_hp = result;
      result += *(_DWORD *)(result - 8);
      limit = result;
    }
    else
    {
      result = *(_DWORD *)caml_gc_sweep_hp;
      v1 += ~(*(_DWORD *)caml_gc_sweep_hp >> 10);
      caml_gc_sweep_hp += 4 * (*(_DWORD *)caml_gc_sweep_hp >> 10) + 4;
      if ( (result & 0x300) != 0 )
      {
        if ( (result & 0x300) == 512 )
        {
          caml_fl_merge = v3 + 1;
        }
        else
        {
          BYTE1(result) &= 0xFCu;
          *v3 = result;
        }
      }
      else
      {
        if ( (_BYTE)result == 0xFF )
        {
          v4 = *(void (__cdecl **)(int *))(v3[1] + 4);
          if ( v4 )
            v4(v3 + 1);
        }
        result = (int)caml_fl_merge_block(v3 + 1);
        caml_gc_sweep_hp = result;
      }
    }
  }
  return result;
}
// 807449C: using guessed type int *caml_fl_merge;
// 80778C0: using guessed type int chunk;
// 80778C4: using guessed type int limit;
// 807ADFC: using guessed type int caml_stat_major_collections;
// 807B48C: using guessed type int caml_gc_sweep_hp;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0805E9D1) --------------------------------------------------------
int caml_finish_major_cycle()
{
  int result; // eax

  if ( caml_gc_phase == 2 )
    start_cycle();
  while ( !caml_gc_phase )
    mark_slice(0x7FFFFFFF);
  while ( caml_gc_phase == 1 )
    sweep_slice(0x7FFFFFFF);
  result = caml_allocated_words;
  caml_stat_major_words = (long double)(unsigned int)caml_allocated_words + caml_stat_major_words;
  caml_allocated_words = 0;
  return result;
}
// 807ADF0: using guessed type double caml_stat_major_words;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0805EA48) --------------------------------------------------------
int __cdecl caml_major_collection_slice(int a1)
{
  int v1; // ebx
  long double v2; // fst7
  long double v3; // fst6
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  long double v7; // fst6
  long double v8; // fst7
  double v10; // [esp+18h] [ebp-30h]
  double v11; // [esp+18h] [ebp-30h]

  v1 = a1;
  if ( caml_gc_phase == 2 )
    start_cycle();
  v2 = (long double)(unsigned int)(caml_percent_free + 100);
  v3 = (long double)(unsigned int)caml_percent_free;
  v10 = (long double)(unsigned int)caml_allocated_words
      * 3.0
      * v2
      / (long double)((unsigned int)caml_stat_heap_size >> 2)
      / v3
      * 0.5;
  if ( caml_dependent_size )
    v4 = v2 * (long double)(unsigned int)caml_dependent_allocated / (long double)(unsigned int)caml_dependent_size / v3;
  else
    v4 = 0.0;
  v5 = v4;
  if ( v4 <= v10 )
    v5 = v10;
  v6 = v5;
  v7 = caml_extra_heap_resources;
  if ( caml_extra_heap_resources <= v6 )
    v7 = v6;
  v11 = v7;
  caml_gc_message(64, "allocated_words = %lu\n", caml_allocated_words);
  caml_gc_message(64, "extra_heap_resources = %luu\n", (__int64)(1000000.0 * caml_extra_heap_resources));
  caml_gc_message(64, "amount of work to do = %luu\n", (__int64)(1000000.0 * (double)v7));
  if ( caml_gc_phase )
    v8 = (long double)((unsigned int)caml_stat_heap_size >> 2) * v11 * 5.0 / 3.0;
  else
    v8 = (long double)((unsigned int)caml_stat_heap_size >> 2)
       * v11
       * 250.0
       / (long double)(unsigned int)(caml_percent_free + 100);
  caml_gc_message(64, "ordered work = %ld words\n", a1);
  caml_gc_message(64, "computed work = %ld words\n", (int)v8);
  if ( !a1 )
    v1 = (int)v8;
  if ( caml_gc_phase )
  {
    sweep_slice(v1);
    caml_gc_message(2, "$", 0);
  }
  else
  {
    mark_slice(v1);
    caml_gc_message(2, "!", 0);
  }
  if ( caml_gc_phase == 2 )
    caml_compact_heap_maybe();
  caml_stat_major_words = (long double)(unsigned int)caml_allocated_words + caml_stat_major_words;
  caml_allocated_words = 0;
  caml_dependent_allocated = 0;
  caml_extra_heap_resources = 0.0;
  return (int)v8;
}
// 807ADF0: using guessed type double caml_stat_major_words;
// 807AE00: using guessed type int caml_stat_heap_size;
// 807B494: using guessed type int caml_dependent_size;
// 807B49C: using guessed type int caml_gc_phase;
// 807B4A0: using guessed type double caml_extra_heap_resources;
// 807B4B0: using guessed type int caml_dependent_allocated;

//----- (0805ED1C) --------------------------------------------------------
_DWORD *__usercall clear_table@<eax>(_DWORD *result@<eax>)
{
  result[3] = *result;
  result[4] = result[2];
  return result;
}

//----- (0805ED2C) --------------------------------------------------------
void __cdecl caml_oldify_one(unsigned int a1, _DWORD *a2)
{
  unsigned int v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // esi
  int *v7; // eax
  unsigned int v8; // edx
  int *v9; // eax
  unsigned int v10; // edx
  int v11; // ebx
  _DWORD *v12; // esi
  unsigned __int8 *v13; // eax
  int v14; // eax
  int *v15; // eax
  unsigned int v16; // [esp+18h] [ebp-20h]
  _DWORD *v17; // [esp+1Ch] [ebp-1Ch]

  while ( 1 )
  {
    while ( 1 )
    {
      if ( (a1 & 1) != 0 || a1 >= caml_young_end || a1 <= caml_young_start )
      {
        *a2 = a1;
        return;
      }
      v4 = a1;
      v17 = (_DWORD *)(a1 - 4);
      v5 = *(_DWORD *)(a1 - 4);
      if ( !v5 )
      {
        *a2 = *(_DWORD *)a1;
        return;
      }
      if ( (unsigned __int8)v5 > 0xF8u )
        break;
      v6 = v5 >> 10;
      v7 = caml_alloc_shr(v5 >> 10, (unsigned __int8)v5);
      *a2 = v7;
      v8 = *(_DWORD *)a1;
      *v17 = 0;
      *(_DWORD *)a1 = v7;
      if ( v6 > 1 )
      {
        *v7 = v8;
        v7[1] = oldify_todo_list;
        oldify_todo_list = a1;
        return;
      }
      a2 = v7;
      a1 = v8;
    }
    if ( (unsigned __int8)v5 > 0xFAu )
      break;
    if ( (unsigned __int8)v5 == 249 )
    {
      v11 = 4 * (v5 >> 10);
      caml_oldify_one(v4 - v11, a2);
      *a2 += v11;
      return;
    }
    v12 = (_DWORD *)a1;
    a1 = *(_DWORD *)a1;
    if ( (a1 & 1) == 0 )
    {
      if ( (*(_BYTE *)(caml_page_table[a1 >> 23] + ((a1 >> 12) & 0x7FF)) & 7) == 0 )
        goto LABEL_24;
      v13 = (unsigned __int8 *)(a1 - 4);
      if ( !*(_DWORD *)(a1 - 4) )
        v13 = (unsigned __int8 *)(*(_DWORD *)a1 - 4);
      v14 = *v13;
      if ( v14 == 250 || v14 == 246 || v14 == 253 )
      {
LABEL_24:
        v15 = caml_alloc_shr(1u, 250);
        *a2 = v15;
        *v17 = 0;
        *v12 = v15;
        a2 = v15;
      }
    }
  }
  v16 = v5 >> 10;
  v9 = caml_alloc_shr(v5 >> 10, (unsigned __int8)v5);
  if ( v16 )
  {
    v10 = 0;
    do
    {
      v9[v10] = *(_DWORD *)(a1 + 4 * v10);
      ++v10;
    }
    while ( v16 > v10 );
  }
  *v17 = 0;
  *(_DWORD *)a1 = v9;
  *a2 = v9;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 8077918: using guessed type int oldify_todo_list;

//----- (0805EEBB) --------------------------------------------------------
void caml_oldify_mopup()
{
  unsigned int *v0; // ebx
  unsigned int *v1; // esi
  unsigned int v2; // eax
  unsigned int *v3; // ebx
  unsigned int v4; // eax
  int v5; // edi
  unsigned int v6; // [esp+1Ch] [ebp-1Ch]

  while ( 1 )
  {
    v5 = oldify_todo_list;
    if ( !oldify_todo_list )
      break;
    v0 = *(unsigned int **)oldify_todo_list;
    v1 = (unsigned int *)(*(_DWORD *)oldify_todo_list + 4);
    oldify_todo_list = *v1;
    v2 = *v0;
    if ( (*v0 & 1) == 0 && v2 < caml_young_end && v2 > caml_young_start )
      caml_oldify_one(v2, v0);
    v3 = v0 - 1;
    if ( *v3 >> 10 > 1 )
    {
      v6 = 1;
      do
      {
        v4 = *(_DWORD *)(v5 + 4 * v6);
        if ( (v4 & 1) != 0 || v4 >= caml_young_end || v4 <= caml_young_start )
          *v1 = v4;
        else
          caml_oldify_one(v4, v1);
        ++v6;
        ++v1;
      }
      while ( *v3 >> 10 > v6 );
    }
  }
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 8077918: using guessed type int oldify_todo_list;

//----- (0805EF59) --------------------------------------------------------
int caml_empty_minor_heap()
{
  unsigned int **v0; // ebx
  unsigned int **v1; // eax
  unsigned int *v2; // ecx
  unsigned int v3; // edx
  int v4; // edx

  if ( caml_young_ptr != caml_young_end )
  {
    caml_in_minor_collection = 1;
    caml_gc_message(2, "<", 0);
    caml_oldify_local_roots();
    v0 = (unsigned int **)caml_ref_table[0];
    if ( caml_ref_table[0] < (unsigned int)dword_80778E8 )
    {
      do
      {
        caml_oldify_one(**v0, *v0);
        ++v0;
      }
      while ( dword_80778E8 > (unsigned int)v0 );
    }
    caml_oldify_mopup();
    v1 = (unsigned int **)caml_weak_ref_table[0];
    if ( caml_weak_ref_table[0] < (unsigned int)dword_8077904 )
    {
      do
      {
        v2 = *v1;
        v3 = **v1;
        if ( (v3 & 1) == 0 && v3 < caml_young_end && v3 > caml_young_start )
        {
          if ( *(_DWORD *)(v3 - 4) )
            *v2 = (unsigned int)caml_weak_none;
          else
            *v2 = *(_DWORD *)v3;
        }
        ++v1;
      }
      while ( dword_8077904 > (unsigned int)v1 );
    }
    v4 = caml_young_ptr;
    if ( caml_young_ptr < (unsigned int)caml_young_start )
      v4 = caml_young_start;
    caml_stat_minor_words = (long double)((unsigned int)(caml_young_end - v4) >> 2) + caml_stat_minor_words;
    caml_young_ptr = caml_young_end;
    caml_young_limit = caml_young_start;
    clear_table(caml_ref_table);
    clear_table(caml_weak_ref_table);
    caml_gc_message(2, ">", 0);
    caml_in_minor_collection = 0;
  }
  return caml_final_empty_young();
}
// 8074564: using guessed type void *caml_weak_none;
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;
// 80778E8: using guessed type int dword_80778E8;
// 8077904: using guessed type int dword_8077904;
// 8077914: using guessed type int caml_in_minor_collection;
// 807ADE0: using guessed type double caml_stat_minor_words;

//----- (0805F0A3) --------------------------------------------------------
int caml_minor_collection()
{
  int v0; // ebx

  v0 = caml_allocated_words;
  caml_empty_minor_heap();
  caml_stat_promoted_words = (long double)(unsigned int)(caml_allocated_words - v0) + caml_stat_promoted_words;
  ++caml_stat_minor_collections;
  caml_major_collection_slice(0);
  caml_force_major_slice = 0;
  caml_final_do_calls();
  return caml_empty_minor_heap();
}
// 8074894: using guessed type int caml_force_major_slice;
// 807ADE8: using guessed type double caml_stat_promoted_words;
// 807ADF8: using guessed type int caml_stat_minor_collections;

//----- (0805F10C) --------------------------------------------------------
int __cdecl caml_check_urgent_gc(int a1)
{
  int v1; // ebx
  int v3[10]; // [esp+0h] [ebp-28h] BYREF

  v1 = caml_local_roots;
  caml_local_roots = (int)v3;
  if ( caml_force_major_slice )
  {
    v3[0] = v1;
    v3[2] = 1;
    v3[1] = 1;
    v3[3] = (int)&a1;
    caml_minor_collection();
  }
  caml_local_roots = v1;
  return a1;
}
// 8074754: using guessed type int caml_local_roots;
// 8074894: using guessed type int caml_force_major_slice;

//----- (0805F155) --------------------------------------------------------
void __usercall reset_table(int a1@<eax>)
{
  void *v2; // eax

  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v2 = *(void **)a1;
  if ( v2 )
    caml_stat_free(v2);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (0805F1A2) --------------------------------------------------------
void __cdecl caml_set_minor_heap_size(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+8h] [ebp-30h]
  int v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  _DWORD *v11; // [esp+10h] [ebp-28h]
  void *v12; // [esp+1Ch] [ebp-1Ch] BYREF

  if ( caml_young_ptr != caml_young_end )
    caml_minor_collection();
  v1 = caml_aligned_malloc(a1, 0, &v12);
  v2 = v1;
  if ( !v1 )
    v1 = caml_raise_out_of_memory(v4, v6, v8, v10, v11);
  v3 = v1 + a1;
  if ( caml_page_table_add(2, v1, v1 + a1) )
    caml_raise_out_of_memory(v5, v7, v9, v10, v11);
  if ( caml_young_start )
  {
    caml_page_table_remove(2, caml_young_start, caml_young_end);
    free(caml_young_base);
  }
  caml_young_base = v12;
  caml_young_start = v2;
  caml_young_end = v3;
  caml_young_limit = v2;
  caml_young_ptr = v3;
  caml_minor_heap_size = a1;
  reset_table((int)caml_ref_table);
  reset_table((int)caml_weak_ref_table);
}
// 805F1DD: variable 'v4' is possibly undefined
// 805F1DD: variable 'v6' is possibly undefined
// 805F1DD: variable 'v8' is possibly undefined
// 805F1DD: variable 'v10' is possibly undefined
// 805F1DD: variable 'v11' is possibly undefined
// 805F1FD: variable 'v5' is possibly undefined
// 805F1FD: variable 'v7' is possibly undefined
// 805F1FD: variable 'v9' is possibly undefined
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;
// 807B4B4: using guessed type int caml_minor_heap_size;

//----- (0805F274) --------------------------------------------------------
char *__cdecl caml_alloc_table(int a1, int a2, int a3)
{
  char *v3; // esi
  int v4; // eax
  char *v5; // edx
  char *result; // eax

  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  v3 = (char *)caml_stat_alloc(4 * (a3 + a2));
  if ( *(_DWORD *)a1 )
    caml_stat_free(*(void **)a1);
  *(_DWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v3;
  v4 = *(_DWORD *)(a1 + 20);
  v5 = &v3[4 * v4];
  *(_DWORD *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 16) = v5;
  result = &v3[4 * *(_DWORD *)(a1 + 24) + 4 * v4];
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (0805F2CA) --------------------------------------------------------
char *__cdecl caml_realloc_ref_table(int a1)
{
  void *v1; // edi
  char *result; // eax
  int v3; // esi
  signed int v4; // esi
  char *v5; // eax
  int v6; // ecx
  char *v7; // edx
  int v8; // [esp+1Ch] [ebp-1Ch]

  v1 = *(void **)a1;
  if ( !*(_DWORD *)a1 )
    return caml_alloc_table(a1, (unsigned int)caml_minor_heap_size >> 5, 256);
  if ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 8) )
  {
    caml_gc_message(8, "ref_table threshold crossed\n", 0);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 4);
    result = (char *)caml_urge_major_slice();
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 12);
    v3 = 2 * *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v3;
    v4 = 4 * (*(_DWORD *)(a1 + 24) + v3);
    caml_gc_message(8, "Growing ref_table to %ldk bytes\n", v4 / 1024);
    v5 = (char *)realloc(*(void **)a1, v4);
    *(_DWORD *)a1 = v5;
    if ( !v5 )
      caml_fatal_error("Fatal error: ref_table overflow\n");
    v6 = *(_DWORD *)(a1 + 20);
    v7 = &v5[4 * v6 + 4 * *(_DWORD *)(a1 + 24)];
    *(_DWORD *)(a1 + 4) = v7;
    *(_DWORD *)(a1 + 8) = &v5[4 * v6];
    result = &v5[(v8 - (_DWORD)v1) & 0xFFFFFFFC];
    *(_DWORD *)(a1 + 12) = result;
    *(_DWORD *)(a1 + 16) = v7;
  }
  return result;
}
// 807B4B4: using guessed type int caml_minor_heap_size;

//----- (0805F3D0) --------------------------------------------------------
__int16 caml_page_table_initialize()
{
  int i; // eax

  for ( i = 0; i != 512; ++i )
    caml_page_table[i] = (int)&caml_page_table_empty;
  return 0;
}

//----- (0805F3F4) --------------------------------------------------------
int __cdecl caml_allocation_color(unsigned int a1)
{
  int result; // eax

  if ( caml_gc_phase && (caml_gc_phase != 1 || a1 < caml_gc_sweep_hp) )
    result = 0;
  else
    result = 768;
  return result;
}
// 807B48C: using guessed type int caml_gc_sweep_hp;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0805F41E) --------------------------------------------------------
unsigned int __cdecl caml_alloc_dependent_memory(unsigned int a1)
{
  unsigned int result; // eax

  result = a1 >> 2;
  caml_dependent_size += a1 >> 2;
  caml_dependent_allocated += a1 >> 2;
  return result;
}
// 807B494: using guessed type int caml_dependent_size;
// 807B4B0: using guessed type int caml_dependent_allocated;

//----- (0805F435) --------------------------------------------------------
unsigned int __cdecl caml_free_dependent_memory(unsigned int a1)
{
  unsigned int result; // eax

  result = a1 >> 2;
  if ( a1 >> 2 <= caml_dependent_size )
    caml_dependent_size -= result;
  else
    caml_dependent_size = 0;
  return result;
}
// 807B494: using guessed type int caml_dependent_size;

//----- (0805F45E) --------------------------------------------------------
void *__cdecl caml_stat_resize(void *ptr, size_t size)
{
  void *result; // eax
  int v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  result = realloc(ptr, size);
  if ( !result )
    result = (void *)caml_raise_out_of_memory(v3, v4, v5, v6, v7);
  return result;
}
// 805F47A: variable 'v3' is possibly undefined
// 805F47A: variable 'v4' is possibly undefined
// 805F47A: variable 'v5' is possibly undefined
// 805F47A: variable 'v6' is possibly undefined
// 805F47A: variable 'v7' is possibly undefined

//----- (0805F481) --------------------------------------------------------
void __cdecl caml_stat_free(void *ptr)
{
  free(ptr);
}

//----- (0805F494) --------------------------------------------------------
void __cdecl caml_free_for_heap(int a1)
{
  free(*(void **)(a1 - 16));
}

//----- (0805F4AA) --------------------------------------------------------
void *__cdecl caml_stat_alloc(size_t size)
{
  void *result; // eax
  int v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  result = malloc(size);
  if ( !result )
  {
    if ( size )
      result = (void *)caml_raise_out_of_memory(v2, v3, v4, v5, v6);
  }
  return result;
}
// 805F4C4: variable 'v2' is possibly undefined
// 805F4C4: variable 'v3' is possibly undefined
// 805F4C4: variable 'v4' is possibly undefined
// 805F4C4: variable 'v5' is possibly undefined
// 805F4C4: variable 'v6' is possibly undefined

//----- (0805F4CF) --------------------------------------------------------
int *__cdecl caml_modify(unsigned int *a1, unsigned int a2)
{
  unsigned int v2; // edi
  int *result; // eax
  int v4; // edx

  v2 = *a1;
  *a1 = a2;
  result = (int *)(((unsigned int)a1 >> 12) & 0x7FF);
  if ( (*((_BYTE *)result + caml_page_table[(unsigned int)a1 >> 23]) & 1) != 0 )
  {
    if ( !caml_gc_phase )
      result = (int *)caml_darken(v2);
    if ( (a2 & 1) == 0 )
    {
      result = (int *)caml_young_end;
      if ( a2 < caml_young_end
        && a2 > caml_young_start
        && ((v2 & 1) != 0 || caml_young_end <= v2 || caml_young_start >= v2) )
      {
        if ( dword_80778E8 >= (unsigned int)dword_80778EC )
          caml_realloc_ref_table((int)caml_ref_table);
        result = &dword_80778E8;
        v4 = dword_80778E8;
        *(_DWORD *)dword_80778E8 = a1;
        dword_80778E8 = v4 + 4;
      }
    }
  }
  return result;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 80778E8: using guessed type int dword_80778E8;
// 80778EC: using guessed type int dword_80778EC;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0805F57C) --------------------------------------------------------
int *__cdecl caml_initialize(unsigned int *a1, unsigned int a2)
{
  int *result; // eax
  int v3; // edx

  result = (int *)a2;
  *a1 = a2;
  if ( (a2 & 1) == 0 && a2 < caml_young_end && a2 > caml_young_start )
  {
    result = (int *)(((unsigned int)a1 >> 12) & 0x7FF);
    if ( (*((_BYTE *)result + caml_page_table[(unsigned int)a1 >> 23]) & 1) != 0 )
    {
      if ( dword_80778E8 >= (unsigned int)dword_80778EC )
        caml_realloc_ref_table((int)caml_ref_table);
      result = &dword_80778E8;
      v3 = dword_80778E8;
      *(_DWORD *)dword_80778E8 = a1;
      dword_80778E8 = v3 + 4;
    }
  }
  return result;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 80778E8: using guessed type int dword_80778E8;
// 80778EC: using guessed type int dword_80778EC;

//----- (0805F5E8) --------------------------------------------------------
unsigned int __cdecl caml_adjust_gc_speed(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  long double v4; // fst7
  unsigned int result; // eax

  v2 = a1;
  v3 = a2;
  if ( !a2 )
    v3 = 1;
  if ( v3 <= a1 )
    v2 = v3;
  v4 = (long double)v2 / (long double)v3 + caml_extra_heap_resources;
  caml_extra_heap_resources = v4;
  if ( v4 > 1.0 )
  {
    caml_extra_heap_resources = 1.0;
    caml_urge_major_slice();
  }
  result = (unsigned int)caml_stat_heap_size >> 2;
  if ( caml_extra_heap_resources > (long double)((unsigned int)caml_minor_heap_size >> 2)
                                 * 0.5
                                 / (long double)((unsigned int)caml_stat_heap_size >> 2) )
    result = caml_urge_major_slice();
  return result;
}
// 807AE00: using guessed type int caml_stat_heap_size;
// 807B4A0: using guessed type double caml_extra_heap_resources;
// 807B4B4: using guessed type int caml_minor_heap_size;

//----- (0805F68B) --------------------------------------------------------
int __cdecl caml_alloc_for_heap(int a1)
{
  int result; // eax
  _DWORD *v2; // edx
  int v3[3]; // [esp+1Ch] [ebp-Ch] BYREF

  result = caml_aligned_malloc(a1 + 16, 16, v3);
  if ( result )
  {
    result += 16;
    v2 = (_DWORD *)(result - 16);
    v2[2] = a1;
    *v2 = v3[0];
  }
  return result;
}

//----- (0805F6C7) --------------------------------------------------------
int __usercall caml_page_table_modify@<eax>(unsigned int a1@<eax>, char a2@<dl>, char a3@<cl>)
{
  unsigned int v5; // esi
  void *v6; // edx
  int result; // eax
  _BYTE *v8; // ebx

  v5 = a1 >> 23;
  if ( (_UNKNOWN *)caml_page_table[a1 >> 23] == &caml_page_table_empty )
  {
    v6 = calloc(0x800u, 1u);
    result = -1;
    if ( !v6 )
      return result;
    caml_page_table[v5] = (int)v6;
  }
  v8 = (_BYTE *)(caml_page_table[v5] + ((a1 >> 12) & 0x7FF));
  *v8 = a3 | *v8 & ~a2;
  return 0;
}

//----- (0805F742) --------------------------------------------------------
int __cdecl caml_page_table_remove(char a1, int a2, int a3)
{
  unsigned int v3; // ebx
  unsigned int v4; // esi

  v3 = a2 & 0xFFFFF000;
  v4 = (a3 - 1) & 0xFFFFF000;
  if ( (a2 & 0xFFFFF000) > v4 )
    return 0;
  while ( !caml_page_table_modify(v3, a1, 0) )
  {
    v3 += 4096;
    if ( v4 < v3 )
      return 0;
  }
  return -1;
}

//----- (0805F797) --------------------------------------------------------
void __cdecl caml_shrink_heap(_DWORD *a1)
{
  char *v1; // esi
  _DWORD *v2; // eax
  void **v3; // edx

  if ( a1 != caml_heap_start )
  {
    v1 = (char *)(a1 - 4);
    caml_stat_heap_size -= *(a1 - 2);
    caml_gc_message(4, "Shrinking heap to %luk bytes\n", (unsigned int)caml_stat_heap_size >> 10);
    --caml_stat_heap_chunks;
    v2 = caml_heap_start;
    v3 = &caml_heap_start;
    if ( a1 != caml_heap_start )
    {
      do
      {
        v3 = (void **)(v2 - 1);
        v2 = (_DWORD *)*(v2 - 1);
      }
      while ( a1 != v2 );
    }
    *v3 = (void *)*((_DWORD *)v1 + 3);
    caml_page_table_remove(1, (int)a1, (int)a1 + *((_DWORD *)v1 + 2));
    caml_free_for_heap((int)a1);
  }
}
// 807AE00: using guessed type int caml_stat_heap_size;
// 807AE0C: using guessed type int caml_stat_heap_chunks;

//----- (0805F821) --------------------------------------------------------
int __cdecl caml_page_table_add(char a1, int a2, int a3)
{
  unsigned int v3; // ebx
  unsigned int v4; // esi

  v3 = a2 & 0xFFFFF000;
  v4 = (a3 - 1) & 0xFFFFF000;
  if ( (a2 & 0xFFFFF000) > v4 )
    return 0;
  while ( !caml_page_table_modify(v3, 0, a1) )
  {
    v3 += 4096;
    if ( v4 < v3 )
      return 0;
  }
  return -1;
}

//----- (0805F876) --------------------------------------------------------
int __cdecl caml_add_to_heap(unsigned int a1)
{
  unsigned int v1; // esi
  int v2; // edx
  int result; // eax
  _DWORD *v4; // eax
  void **v5; // edx
  int v6; // edx

  v1 = a1 - 16;
  caml_gc_message(
    4,
    "Growing heap to %luk bytes\n",
    (unsigned int)(*(_DWORD *)(a1 - 16 + 8) + caml_stat_heap_size) >> 10);
  v2 = caml_page_table_add(1, a1, *(_DWORD *)(a1 - 16 + 8) + a1);
  result = -1;
  if ( !v2 )
  {
    v4 = caml_heap_start;
    if ( caml_heap_start && a1 > (unsigned int)caml_heap_start )
    {
      do
      {
        v5 = (void **)(v4 - 1);
        v4 = (_DWORD *)*(v4 - 1);
      }
      while ( v4 && a1 > (unsigned int)v4 );
    }
    else
    {
      v5 = &caml_heap_start;
    }
    *(_DWORD *)(v1 + 12) = v4;
    *v5 = (void *)a1;
    ++caml_stat_heap_chunks;
    v6 = *(_DWORD *)(v1 + 8) + caml_stat_heap_size;
    caml_stat_heap_size = v6;
    result = 0;
    if ( v6 > caml_stat_top_heap_size )
      caml_stat_top_heap_size = v6;
  }
  return result;
}
// 807AE00: using guessed type int caml_stat_heap_size;
// 807AE04: using guessed type int caml_stat_top_heap_size;
// 807AE0C: using guessed type int caml_stat_heap_chunks;

//----- (0805F922) --------------------------------------------------------
int *__cdecl caml_alloc_shr(unsigned int a1, int a2)
{
  int *v2; // ebx
  unsigned int v3; // ebx
  _DWORD *v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // edx
  _DWORD *v7; // ecx
  _DWORD *v8; // ecx
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+0h] [ebp-28h]
  int v12; // [esp+4h] [ebp-24h]
  int v13; // [esp+8h] [ebp-20h]
  int v14; // [esp+Ch] [ebp-1Ch]
  _DWORD *v15; // [esp+10h] [ebp-18h]

  if ( a1 > 0x3FFFFF )
    caml_raise_out_of_memory(v10, v12, v13, v14, v15);
  v2 = caml_fl_allocate(a1);
  if ( !v2 )
  {
    v3 = caml_round_heap_chunk_size(4 * (a1 + caml_percent_free * (a1 / 0x64) + 1));
    v4 = (_DWORD *)caml_alloc_for_heap(v3);
    v5 = (unsigned int)v4;
    if ( v4 )
    {
      v6 = (v3 >> 2) - 1;
      v7 = v4;
      if ( v6 > 0x3FFFFF )
      {
        while ( 1 )
        {
          *v4 = -512;
          v4 += 0x400000;
          v3 -= 0x1000000;
          v7[1] = v4 + 1;
          *(_DWORD *)(v5 + 8) = v4 + 1;
          v6 = (v3 >> 2) - 1;
          if ( v6 <= 0x3FFFFF )
            break;
          v7 = v4;
        }
        v7 = v4;
      }
      if ( v3 <= 1 )
      {
        v7[1] = 0;
        if ( v3 == 1 )
          *v4 = 0;
      }
      else
      {
        *v4 = (v6 << 10) + 512;
        v8 = v7 + 1;
        *(_DWORD *)(v5 + 8) = v8;
        *v8 = 0;
      }
      if ( caml_add_to_heap(v5) )
      {
        caml_free_for_heap(v5);
      }
      else
      {
        v5 += 4;
        if ( v5 )
        {
LABEL_21:
          caml_fl_add_blocks(v5);
          v2 = caml_fl_allocate(a1);
          goto LABEL_22;
        }
      }
    }
    else
    {
      caml_gc_message(4, "No room for growing heap\n", 0);
    }
    if ( caml_in_minor_collection )
      caml_fatal_error("Fatal error: out of memory.\n");
    caml_raise_out_of_memory(v11, v12, v13, v14, v15);
    goto LABEL_21;
  }
LABEL_22:
  if ( caml_gc_phase && (caml_gc_phase != 1 || (unsigned int)v2 < caml_gc_sweep_hp) )
    *v2 = a2 + (a1 << 10);
  else
    *v2 = a2 + (a1 << 10) + 768;
  caml_allocated_words += a1 + 1;
  if ( caml_allocated_words > (unsigned int)caml_minor_heap_size >> 2 )
    caml_urge_major_slice();
  return v2 + 1;
}
// 805F93C: variable 'v10' is possibly undefined
// 805F93C: variable 'v12' is possibly undefined
// 805F93C: variable 'v13' is possibly undefined
// 805F93C: variable 'v14' is possibly undefined
// 805F93C: variable 'v15' is possibly undefined
// 805FA47: variable 'v11' is possibly undefined
// 8077914: using guessed type int caml_in_minor_collection;
// 807B48C: using guessed type int caml_gc_sweep_hp;
// 807B49C: using guessed type int caml_gc_phase;
// 807B4B4: using guessed type int caml_minor_heap_size;

//----- (0805FAC4) --------------------------------------------------------
int __cdecl caml_convert_flag_list(int *a1, int a2)
{
  int *v2; // edx
  int result; // eax

  v2 = a1;
  for ( result = 0; v2 != (int *)1; v2 = (int *)v2[1] )
    result |= *(_DWORD *)(a2 + 4 * (*v2 >> 1));
  return result;
}

//----- (0805FAEA) --------------------------------------------------------
int __cdecl caml_update_dummy(unsigned int *a1, int a2)
{
  unsigned int v2; // ecx
  char v3; // dl
  unsigned int *v4; // esi
  unsigned int j; // ebx
  unsigned int v6; // edx
  unsigned int i; // eax
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]

  v2 = *(_DWORD *)(a2 - 4);
  v3 = *(_BYTE *)(a2 - 4);
  v4 = a1;
  *((_BYTE *)a1 - 4) = v3;
  if ( v3 == -2 )
  {
    v6 = *(_DWORD *)(a2 - 4) >> 11;
    if ( v6 )
    {
      for ( i = 0; i < v6; ++i )
        *(double *)&a1[2 * i] = *(double *)(a2 + 8 * i);
    }
  }
  else
  {
    v9 = v2 >> 10;
    for ( j = 0; v9 > j; ++v4 )
      caml_modify(v4, *(_DWORD *)(a2 + 4 * j++));
  }
  return 1;
}

//----- (0805FB5E) --------------------------------------------------------
int *__cdecl caml_alloc_final(int a1, int a2, unsigned int a3, unsigned int a4)
{
  _DWORD *v4; // eax

  v4 = caml_final_custom_operations(a2);
  return caml_alloc_custom((int)v4, 4 * a1, a3, a4);
}

//----- (0805FB91) --------------------------------------------------------
int __cdecl caml_alloc_small(int a1, int a2)
{
  unsigned int v2; // eax

  v2 = caml_young_ptr - (4 * a1 + 4);
  caml_young_ptr = v2;
  if ( v2 < caml_young_limit )
  {
    caml_young_ptr = 4 * a1 + 4 + v2;
    caml_minor_collection();
    caml_young_ptr -= 4 * a1 + 4;
  }
  *(_DWORD *)caml_young_ptr = a2 + (a1 << 10) + 768;
  return caml_young_ptr + 4;
}
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0805FBFA) --------------------------------------------------------
int __cdecl caml_alloc_string(int a1)
{
  unsigned int v1; // ebx
  unsigned int v2; // eax
  int result; // eax
  int *v4; // eax
  int v5; // ebx

  v1 = (unsigned int)(a1 + 4) >> 2;
  if ( v1 > 0x100 )
  {
    v4 = caml_alloc_shr((unsigned int)(a1 + 4) >> 2, 252);
    result = caml_check_urgent_gc((int)v4);
  }
  else
  {
    v2 = caml_young_ptr - (4 * v1 + 4);
    caml_young_ptr = v2;
    if ( v2 < caml_young_limit )
    {
      caml_young_ptr = 4 * v1 + 4 + v2;
      caml_minor_collection();
      caml_young_ptr -= 4 * v1 + 4;
    }
    *(_DWORD *)caml_young_ptr = (v1 << 10) + 1020;
    result = caml_young_ptr + 4;
  }
  v5 = 4 * v1;
  *(_DWORD *)(result + v5 - 4) = 0;
  *(_BYTE *)(result + v5 - 1) = v5 - 1 - a1;
  return result;
}
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0805FCA4) --------------------------------------------------------
void *__cdecl caml_copy_string(void *src)
{
  unsigned int v1; // kr04_4
  void *v2; // esi

  v1 = strlen((const char *)src) + 1;
  v2 = (void *)caml_alloc_string(v1 - 1);
  memmove(v2, src, v1 - 1);
  return v2;
}

//----- (0805FCF3) --------------------------------------------------------
char *__cdecl caml_alloc(unsigned int a1, unsigned int a2)
{
  char *result; // eax
  unsigned int v3; // eax
  int v4; // ecx
  int i; // edx
  int *v6; // eax
  int v7; // edi

  result = (char *)&unk_807AF64 + 4 * a2;
  if ( a1 )
  {
    if ( a1 > 0x100 )
    {
      v6 = caml_alloc_shr(a1, a2);
      v7 = (int)v6;
      if ( a2 <= 0xFA )
        memset(v6, 0, 4 * a1);
      result = (char *)caml_check_urgent_gc(v7);
    }
    else
    {
      v3 = caml_young_ptr - (4 * a1 + 4);
      caml_young_ptr = v3;
      if ( v3 < caml_young_limit )
      {
        caml_young_ptr = 4 * a1 + 4 + v3;
        caml_minor_collection();
        caml_young_ptr -= 4 * a1 + 4;
      }
      *(_DWORD *)caml_young_ptr = a2 + (a1 << 10) + 768;
      v4 = caml_young_ptr;
      result = (char *)(caml_young_ptr + 4);
      if ( a2 <= 0xFA )
      {
        for ( i = 0; i != a1; ++i )
          *(_DWORD *)(v4 + 4 * i + 4) = 0;
      }
    }
  }
  return result;
}
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0805FDCD) --------------------------------------------------------
char *__cdecl caml_alloc_dummy_float(int a1)
{
  char *result; // eax

  result = (char *)&unk_807AF64;
  if ( (a1 & 0xFFFFFFFE) != 0 )
    result = caml_alloc(a1 & 0xFFFFFFFE, 0);
  return result;
}

//----- (0805FDF2) --------------------------------------------------------
char *__cdecl caml_alloc_dummy(int a1)
{
  char *result; // eax

  result = (char *)&unk_807AF64;
  if ( a1 >> 1 )
    result = caml_alloc(a1 >> 1, 0);
  return result;
}

//----- (0805FE16) --------------------------------------------------------
char *__cdecl caml_alloc_array(int (__cdecl *a1)(_DWORD), _DWORD *a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // ebx
  char *result; // eax
  unsigned int i; // edi
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7[8]; // [esp+28h] [ebp-40h] BYREF
  char *v8; // [esp+48h] [ebp-20h] BYREF
  unsigned int v9; // [esp+4Ch] [ebp-1Ch] BYREF

  v2 = a2;
  v6 = caml_local_roots;
  v9 = 0;
  v8 = 0;
  v7[0] = caml_local_roots;
  caml_local_roots = (int)v7;
  v7[2] = 1;
  v7[1] = 2;
  v7[3] = (int)&v9;
  v7[4] = (int)&v8;
  if ( !*a2 )
    goto LABEL_5;
  v3 = 0;
  do
    ++v3;
  while ( a2[v3] );
  if ( v3 )
  {
    v8 = caml_alloc(v3, 0);
    for ( i = 0; i < v3; ++i )
    {
      v9 = a1(*v2);
      caml_modify((unsigned int *)&v8[4 * i], v9);
      ++v2;
    }
    caml_local_roots = v6;
    result = v8;
  }
  else
  {
LABEL_5:
    result = (char *)&unk_807AF64;
    caml_local_roots = v6;
  }
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0805FEDA) --------------------------------------------------------
char *__cdecl caml_copy_string_array(_DWORD *a1)
{
  return caml_alloc_array((int (__cdecl *)(_DWORD))caml_copy_string, a1);
}

//----- (0805FEF5) --------------------------------------------------------
char *__cdecl caml_alloc_tuple(unsigned int a1)
{
  return caml_alloc(a1, 0);
}

//----- (0805FF10) --------------------------------------------------------
void compare_free_stack()
{
  if ( compare_stack != &compare_stack_init )
  {
    free(compare_stack);
    compare_stack = &compare_stack_init;
    compare_stack_limit = (int)&locale_is_set_2848;
  }
}
// 80744B8: using guessed type int compare_stack_limit;
// 8078D20: using guessed type int locale_is_set_2848;

//----- (0805FF40) --------------------------------------------------------
int compare_stack_overflow()
{
  int v0; // eax
  int v1; // edx
  int v2; // ecx
  int v4; // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  caml_gc_message(4, "Stack overflow in structural comparison\n", 0);
  compare_free_stack();
  v0 = caml_raise_out_of_memory(v4, v5, v6, v7, v8);
  return compare_val(v0, v1, v2);
}
// 805FF67: variable 'v4' is possibly undefined
// 805FF67: variable 'v5' is possibly undefined
// 805FF67: variable 'v6' is possibly undefined
// 805FF67: variable 'v7' is possibly undefined
// 805FF67: variable 'v8' is possibly undefined
// 805FF68: variable 'v1' is possibly undefined
// 805FF68: variable 'v2' is possibly undefined

//----- (0805FF6C) --------------------------------------------------------
int __usercall compare_val@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  char *v3; // ebx
  int result; // eax
  char v5; // al
  int (__cdecl *v6)(int); // eax
  char v7; // al
  int (__cdecl *v8)(int); // eax
  _DWORD *v9; // edi
  int v10; // edx
  unsigned int v11; // esi
  unsigned int v12; // edi
  size_t v13; // eax
  int v14; // eax
  long double v15; // fst6
  long double v16; // fst7
  unsigned int v17; // edx
  int v18; // eax
  long double v19; // fst6
  long double v20; // fst7
  int v21; // eax
  int v22; // edx
  int v23; // eax
  int (__cdecl *v24)(int); // edx
  int v25; // eax
  int *v26; // eax
  int v27; // eax
  int v28; // [esp+4h] [ebp-54h]
  unsigned int v29; // [esp+8h] [ebp-50h]
  int v30; // [esp+Ch] [ebp-4Ch]
  _DWORD *v31; // [esp+10h] [ebp-48h]
  _BYTE *v32; // [esp+1Ch] [ebp-3Ch]
  unsigned int v33; // [esp+20h] [ebp-38h]
  unsigned __int8 v34; // [esp+24h] [ebp-34h]
  unsigned int v35; // [esp+24h] [ebp-34h]
  _DWORD *v36; // [esp+28h] [ebp-30h]
  char *v37; // [esp+28h] [ebp-30h]

  v3 = (char *)compare_stack;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
LABEL_2:
            if ( a1 == a2 && a3 )
              goto LABEL_94;
            if ( (a1 & 1) == 0 )
              break;
            if ( a1 == a2 )
              goto LABEL_94;
            if ( (a2 & 1) != 0 )
              return (a1 >> 1) - (a2 >> 1);
            if ( (*(_BYTE *)(caml_page_table[(unsigned int)a2 >> 23] + (((unsigned int)a2 >> 12) & 0x7FF)) & 7) == 0 )
              goto LABEL_100;
            v5 = *(_BYTE *)(a2 - 4);
            if ( v5 != -6 )
            {
              if ( v5 != -1 )
                goto LABEL_100;
              v6 = *(int (__cdecl **)(int))(*(_DWORD *)a2 + 24);
              if ( !v6 )
                goto LABEL_100;
              caml_compare_unordered = 0;
              v28 = a2;
              result = v6(a1);
              if ( caml_compare_unordered && !a3 )
                return 0x80000000;
              if ( result )
                return result;
              goto LABEL_94;
            }
            a2 = *(_DWORD *)a2;
          }
          if ( (a2 & 1) == 0 )
            break;
          if ( (*(_BYTE *)(caml_page_table[(unsigned int)a1 >> 23] + (((unsigned int)a1 >> 12) & 0x7FF)) & 7) == 0 )
            goto LABEL_101;
          v7 = *(_BYTE *)(a1 - 4);
          if ( v7 != -6 )
          {
            if ( v7 != -1 )
              goto LABEL_101;
            v8 = *(int (__cdecl **)(int))(*(_DWORD *)a1 + 24);
            if ( !v8 )
              goto LABEL_101;
            caml_compare_unordered = 0;
            v28 = a2;
            result = v8(a1);
            if ( caml_compare_unordered && !a3 )
              return 0x80000000;
            if ( result )
              return result;
            goto LABEL_94;
          }
          a1 = *(_DWORD *)a1;
        }
        if ( (*(_BYTE *)(caml_page_table[(unsigned int)a1 >> 23] + (((unsigned int)a1 >> 12) & 0x7FF)) & 7) != 0
          && (*(_BYTE *)(caml_page_table[(unsigned int)a2 >> 23] + (((unsigned int)a2 >> 12) & 0x7FF)) & 7) != 0 )
        {
          break;
        }
        if ( a1 != a2 )
          return (a1 >> 1) - (a2 >> 1);
LABEL_94:
        if ( v3 == compare_stack )
          return 0;
        a1 = **(_DWORD **)v3;
        *(_DWORD *)v3 += 4;
        v26 = (int *)*((_DWORD *)v3 + 1);
        a2 = *v26;
        *((_DWORD *)v3 + 1) = v26 + 1;
        v27 = *((_DWORD *)v3 + 2) - 1;
        *((_DWORD *)v3 + 2) = v27;
        if ( !v27 )
          v3 -= 12;
      }
      v9 = (_DWORD *)(a1 - 4);
      v10 = *(unsigned __int8 *)(a1 - 4);
      v36 = (_DWORD *)(a2 - 4);
      v34 = *(_BYTE *)(a2 - 4);
      if ( v10 != 250 )
        break;
      a1 = *(_DWORD *)a1;
    }
    if ( v34 != 250 )
      break;
    a2 = *(_DWORD *)a2;
  }
  if ( v10 != v34 )
    return v10 - v34;
  switch ( *(_BYTE *)(a1 - 4) )
  {
    case 0xF7:
    case 0xF9:
      goto LABEL_66;
    case 0xF8:
      goto LABEL_67;
    case 0xFB:
      compare_free_stack();
      caml_invalid_argument("equal: abstract value", v28, v29, v30, v31);
LABEL_66:
      compare_free_stack();
      caml_invalid_argument("equal: functional value", v28, v29, v30, v31);
LABEL_67:
      v22 = *(int *)(a1 + 4) >> 1;
      v23 = *(int *)(a2 + 4) >> 1;
      if ( v22 == v23 )
        goto LABEL_94;
      return v22 - v23;
    case 0xFC:
      if ( a1 == a2 )
        goto LABEL_94;
      v11 = caml_string_length(a1);
      v12 = caml_string_length(a2);
      v13 = v11;
      if ( v12 <= v11 )
        v13 = v12;
      v14 = memcmp((const void *)a1, (const void *)a2, v13);
      if ( v14 < 0 )
        goto LABEL_100;
      if ( v14 > 0 )
        goto LABEL_101;
      if ( v11 == v12 )
        goto LABEL_94;
      return v11 - v12;
    case 0xFD:
      if ( *(double *)a2 > (long double)*(double *)a1 )
        goto LABEL_100;
      v15 = *(double *)a1;
      v16 = *(double *)a2;
      if ( v15 > v16 )
        goto LABEL_101;
      if ( v15 == v16 )
        goto LABEL_94;
      if ( a3 )
        goto LABEL_101;
      return 0x80000000;
    case 0xFE:
      v17 = *v9 >> 11;
      v18 = *v36 >> 11;
      if ( v17 != v18 )
        return v17 - v18;
      if ( !v17 )
        goto LABEL_94;
      if ( *(double *)a2 > (long double)*(double *)a1 )
        goto LABEL_100;
      v19 = *(double *)a1;
      v20 = *(double *)a2;
      if ( v19 > v20 )
        goto LABEL_101;
      v21 = 0;
      while ( v19 == v20 )
      {
        if ( v17 <= ++v21 )
          goto LABEL_94;
        if ( *(double *)(a2 + 8 * v21) > (long double)*(double *)(a1 + 8 * v21) )
          goto LABEL_100;
        v19 = *(double *)(a1 + 8 * v21);
        v20 = *(double *)(a2 + 8 * v21);
        if ( v19 > v20 )
          goto LABEL_101;
      }
      if ( a3 )
        goto LABEL_101;
      return 0x80000000;
    case 0xFF:
      v24 = *(int (__cdecl **)(int))(*(_DWORD *)a2 + 8);
      if ( v24 == *(int (__cdecl **)(int))(*(_DWORD *)a1 + 8) )
      {
        if ( !v24 )
        {
          compare_free_stack();
          caml_invalid_argument("equal: abstract value", v28, v29, v30, v31);
        }
        caml_compare_unordered = 0;
        v28 = a2;
        result = v24(a1);
        if ( caml_compare_unordered && !a3 )
          return 0x80000000;
        if ( result )
          return result;
        goto LABEL_94;
      }
      if ( strcmp(**(const char ***)a1, **(const char ***)a2) >= 0 )
LABEL_101:
        result = 1;
      else
LABEL_100:
        result = -1;
      return result;
    default:
      v35 = *v9 >> 10;
      v25 = *v36 >> 10;
      if ( v35 != v25 )
        return v35 - v25;
      if ( !v35 )
        goto LABEL_94;
      if ( v35 > 1 )
      {
        v3 += 12;
        if ( (unsigned int)v3 >= compare_stack_limit )
        {
          v32 = compare_stack;
          v33 = 1431655766 * ((compare_stack_limit - (int)compare_stack) >> 2);
          if ( v33 > 0xFFFFF )
            compare_stack_overflow();
          if ( compare_stack == &compare_stack_init )
          {
            v37 = (char *)malloc(12 * v33);
            if ( !v37 )
              compare_stack_overflow();
            qmemcpy(v37, &compare_stack_init, 0xC00u);
          }
          else
          {
            v37 = (char *)realloc(compare_stack, 12 * v33);
            if ( !v37 )
              compare_stack_overflow();
          }
          compare_stack = v37;
          compare_stack_limit = (int)&v37[12 * v33];
          v3 = &v37[(v3 - v32) & 0xFFFFFFFC];
        }
        *(_DWORD *)v3 = a1 + 4;
        *((_DWORD *)v3 + 1) = a2 + 4;
        *((_DWORD *)v3 + 2) = v35 - 1;
      }
      a1 = *(_DWORD *)a1;
      a2 = *(_DWORD *)a2;
      goto LABEL_2;
  }
}
// 806030E: variable 'v28' is possibly undefined
// 806030E: variable 'v29' is possibly undefined
// 806030E: variable 'v30' is possibly undefined
// 806030E: variable 'v31' is possibly undefined
// 80603A8: variable 'v24' is possibly undefined
// 80744B8: using guessed type int compare_stack_limit;
// 807BCC0: using guessed type int caml_compare_unordered;

//----- (08060562) --------------------------------------------------------
unsigned int __cdecl caml_greaterequal(int a1, int a2)
{
  int v2; // ebx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return ((v2 >> 31) & 0xFFFFFFFE) + 3;
}

//----- (0806059D) --------------------------------------------------------
int __cdecl caml_greaterthan(int a1, int a2)
{
  int v2; // ebx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return 2 * (v2 > 0) + 1;
}

//----- (080605D9) --------------------------------------------------------
int __cdecl caml_lessequal(int a1, int a2)
{
  int v2; // ebx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return 2 * (v2 <= 0 && v2 != 0x80000000) + 1;
}

//----- (08060621) --------------------------------------------------------
int __cdecl caml_lessthan(int a1, int a2)
{
  unsigned int v2; // ebx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return v2 >= 0x80000001 ? 3 : 1;
}

//----- (08060665) --------------------------------------------------------
int __cdecl caml_notequal(int a1, int a2)
{
  int v2; // ebx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return v2 == 0 ? 1 : 3;
}

//----- (080606A0) --------------------------------------------------------
int __cdecl caml_equal(int a1, int a2)
{
  int v2; // ebx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return v2 == 0 ? 3 : 1;
}

//----- (080606DB) --------------------------------------------------------
int __cdecl caml_compare(int a1, int a2)
{
  int v2; // ebx
  int result; // eax

  v2 = compare_val(a1, a2, 1);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  result = -1;
  if ( v2 >= 0 )
    result = 2 * (v2 > 0) + 1;
  return result;
}

//----- (08060720) --------------------------------------------------------
_BYTE *__usercall parse_sign_and_base@<eax>(_BYTE *result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  *a3 = 1;
  if ( *result == 45 )
  {
    *a3 = -1;
    ++result;
  }
  *a2 = 10;
  if ( *result == 48 )
  {
    switch ( result[1] )
    {
      case 'B':
      case 'b':
        *a2 = 2;
        result += 2;
        break;
      case 'O':
      case 'o':
        *a2 = 8;
        result += 2;
        break;
      case 'X':
      case 'x':
        *a2 = 16;
        result += 2;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (08060779) --------------------------------------------------------
int __usercall parse_digit@<eax>(char a1@<al>)
{
  int result; // eax
  unsigned __int8 v3; // cl

  if ( (unsigned __int8)(a1 - 48) <= 9u )
    return a1 - 48;
  if ( (unsigned __int8)(a1 - 65) <= 5u )
    return a1 - 55;
  v3 = a1 - 97;
  result = -1;
  if ( v3 <= 5u )
    result = a1 - 87;
  return result;
}

//----- (080607B3) --------------------------------------------------------
int __cdecl caml_int_compare(int a1, int a2)
{
  return 2 * ((a1 > a2) - (a1 < a2)) + 1;
}

//----- (080607D6) --------------------------------------------------------
int __cdecl int32_cmp(int a1, int a2)
{
  return (*(_DWORD *)(a1 + 4) > *(_DWORD *)(a2 + 4)) - (*(_DWORD *)(a1 + 4) < *(_DWORD *)(a2 + 4));
}

//----- (080607F9) --------------------------------------------------------
int __cdecl int32_hash(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (08060804) --------------------------------------------------------
int __cdecl caml_int32_to_int(int a1)
{
  return 2 * *(_DWORD *)(a1 + 4) + 1;
}

//----- (08060813) --------------------------------------------------------
int __cdecl caml_int32_compare(int a1, int a2)
{
  return 2 * ((*(_DWORD *)(a1 + 4) > *(_DWORD *)(a2 + 4)) - (*(_DWORD *)(a1 + 4) < *(_DWORD *)(a2 + 4))) + 1;
}

//----- (0806083C) --------------------------------------------------------
int __cdecl int64_cmp(int a1, int a2)
{
  return (*(_QWORD *)(a1 + 4) > *(_QWORD *)(a2 + 4)) - (*(_QWORD *)(a1 + 4) < *(_QWORD *)(a2 + 4));
}

//----- (08060898) --------------------------------------------------------
int __cdecl int64_hash(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (080608A3) --------------------------------------------------------
int __cdecl caml_int64_to_int(int a1)
{
  return 2 * *(_DWORD *)(a1 + 4) + 1;
}

//----- (080608B2) --------------------------------------------------------
int __cdecl caml_int64_compare(int a1, int a2)
{
  return 2 * ((*(_QWORD *)(a1 + 4) > *(_QWORD *)(a2 + 4)) - (*(_QWORD *)(a1 + 4) < *(_QWORD *)(a2 + 4))) + 1;
}

//----- (08060912) --------------------------------------------------------
int __cdecl nativeint_cmp(int a1, int a2)
{
  return (*(_DWORD *)(a1 + 4) > *(_DWORD *)(a2 + 4)) - (*(_DWORD *)(a1 + 4) < *(_DWORD *)(a2 + 4));
}

//----- (08060935) --------------------------------------------------------
int __cdecl nativeint_hash(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (08060940) --------------------------------------------------------
int __cdecl caml_nativeint_to_int(int a1)
{
  return 2 * *(_DWORD *)(a1 + 4) + 1;
}

//----- (0806094F) --------------------------------------------------------
int __cdecl caml_nativeint_compare(int a1, int a2)
{
  return 2 * ((*(_DWORD *)(a1 + 4) > *(_DWORD *)(a2 + 4)) - (*(_DWORD *)(a1 + 4) < *(_DWORD *)(a2 + 4))) + 1;
}

//----- (08060978) --------------------------------------------------------
int __cdecl int32_deserialize(int *a1)
{
  *a1 = caml_deserialize_sint_4();
  return 4;
}

//----- (0806098F) --------------------------------------------------------
int __cdecl nativeint_deserialize(int *a1)
{
  int v1; // eax
  int v3; // [esp+4h] [ebp-14h]

  v1 = caml_deserialize_uint_1();
  if ( v1 == 1 )
  {
    *a1 = caml_deserialize_sint_4();
  }
  else if ( v1 == 2 )
  {
    caml_deserialize_error("input_value: native integer value too large", v3);
  }
  else
  {
    caml_deserialize_error("input_value: ill-formed native integer", v3);
  }
  return 4;
}
// 80609B9: variable 'v3' is possibly undefined

//----- (080609D3) --------------------------------------------------------
_DWORD *__cdecl nativeint_serialize(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // ebx
  _DWORD *result; // eax

  v3 = *(_DWORD *)(a1 + 4);
  caml_serialize_int_1(1);
  caml_serialize_int_4(v3);
  *a2 = 4;
  result = a3;
  *a3 = 8;
  return result;
}

//----- (08060A0C) --------------------------------------------------------
_DWORD *__cdecl int32_serialize(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  caml_serialize_int_4(*(_DWORD *)(a1 + 4));
  *a3 = 4;
  result = a2;
  *a2 = 4;
  return result;
}

//----- (08060A34) --------------------------------------------------------
int __cdecl int64_deserialize(__int64 *a1)
{
  *a1 = caml_deserialize_sint_8();
  return 8;
}

//----- (08060A57) --------------------------------------------------------
_DWORD *__cdecl int64_serialize(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  caml_serialize_int_8(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
  *a3 = 8;
  result = a2;
  *a2 = 8;
  return result;
}

//----- (08060A86) --------------------------------------------------------
unsigned int __usercall parse_intnat@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>)
{
  char *v2; // ebx
  signed int v3; // edi
  int v4; // eax
  char *v5; // ebx
  unsigned int v6; // esi
  int v7; // eax
  int v8; // esi
  bool v9; // cf
  int v11; // [esp+4h] [ebp-44h]
  unsigned int v12; // [esp+8h] [ebp-40h]
  int v13; // [esp+Ch] [ebp-3Ch]
  unsigned int v16; // [esp+18h] [ebp-30h]
  unsigned int v17; // [esp+1Ch] [ebp-2Ch]
  unsigned int v18; // [esp+28h] [ebp-20h] BYREF
  int v19[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  v2 = parse_sign_and_base(a1, &v18, v19);
  v3 = v18;
  v16 = v18;
  v17 = 0xFFFFFFFF / v18;
  v4 = parse_digit(*v2);
  if ( v4 < 0 || v3 <= v4 )
    v4 = caml_failwith("int_of_string", v11, v12, v13, (_DWORD *)a2);
  v5 = v2 + 1;
  v6 = v4;
  while ( 1 )
  {
    if ( *v5 == 95 )
      goto LABEL_12;
    v7 = parse_digit(*v5);
    if ( v7 < 0 || v3 <= v7 )
      break;
    if ( v6 > v17 )
      v7 = caml_failwith("int_of_string", v11, v12, v13, (_DWORD *)a2);
    v8 = v16 * v6;
    v9 = __CFADD__(v7, v8);
    v6 = v7 + v8;
    if ( v9 )
      caml_failwith("int_of_string", v11, v12, v13, (_DWORD *)a2);
LABEL_12:
    ++v5;
  }
  if ( v5 != &a1[caml_string_length((int)a1)] )
    caml_failwith("int_of_string", v11, v12, v13, (_DWORD *)a2);
  if ( v18 != 10 )
  {
LABEL_21:
    if ( a2 <= 0x1F && 1 << a2 <= v6 )
      caml_failwith("int_of_string", v11, v12, v13, (_DWORD *)a2);
    if ( v19[0] < 0 )
      return -v6;
    return v6;
  }
  if ( v19[0] < 0 )
    goto LABEL_19;
  if ( 1 << (a2 - 1) > v6 )
    return v6;
  caml_failwith("int_of_string", v11, v12, v13, (_DWORD *)a2);
LABEL_19:
  if ( 1 << (a2 - 1) < v6 )
  {
    caml_failwith("int_of_string", v11, v12, v13, (_DWORD *)a2);
    goto LABEL_21;
  }
  return -v6;
}
// 8060ACE: variable 'v11' is possibly undefined
// 8060ACE: variable 'v12' is possibly undefined
// 8060ACE: variable 'v13' is possibly undefined
// 8060AFB: variable 'a2' is possibly undefined

//----- (08060BB4) --------------------------------------------------------
unsigned int __cdecl caml_int_of_string(_BYTE *a1)
{
  return 2 * parse_intnat(a1, 0x1Fu) + 1;
}

//----- (08060BCD) --------------------------------------------------------
void *__usercall parse_format@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>, char *a3@<ecx>, void *a4, char *a5)
{
  int v5; // ebx
  unsigned int v6; // ecx
  size_t v7; // esi
  char *v8; // ebx
  char v9; // di
  char v10; // al
  char *v11; // ebx
  const char *v12; // eax
  int v13; // eax
  int v15; // [esp+4h] [ebp-34h]
  unsigned int v16; // [esp+8h] [ebp-30h]
  int v17; // [esp+Ch] [ebp-2Ch]
  _DWORD *v18; // [esp+10h] [ebp-28h]

  v5 = caml_string_length((int)a1);
  v6 = strlen(a2) + 1;
  v7 = v6 - 1;
  if ( v6 + v5 > 0x1F )
    caml_invalid_argument("format_int: format too long", v15, v16, v17, v18);
  memmove(a3, a1, v5);
  v8 = &a3[v5 - 1];
  v9 = *v8;
  v10 = *(v8 - 1);
  if ( v10 == 108 || v10 == 110 || v10 == 76 )
    --v8;
  memmove(v8, a2, v7);
  v11 = &v8[v7];
  *v11 = v9;
  v11[1] = 0;
  v12 = a1;
  if ( !*a1 )
  {
LABEL_17:
    *a5 = v9;
    return a4;
  }
  if ( (unsigned __int8)(*a1 - 48) > 9u )
  {
    while ( *++v12 )
    {
      if ( (unsigned __int8)(*v12 - 48) <= 9u )
        goto LABEL_11;
    }
    goto LABEL_17;
  }
LABEL_11:
  v13 = strtol(v12, 0, 10) + 5;
  *a5 = v9;
  if ( v13 > 31 )
    a4 = caml_stat_alloc(v13 + 1);
  return a4;
}
// 8060C0D: variable 'v15' is possibly undefined
// 8060C0D: variable 'v16' is possibly undefined
// 8060C0D: variable 'v17' is possibly undefined
// 8060C0D: variable 'v18' is possibly undefined

//----- (08060CD6) --------------------------------------------------------
void *__cdecl caml_nativeint_format(_BYTE *a1, int a2)
{
  char *v2; // ebx
  void *v3; // esi
  char v5; // [esp+1Fh] [ebp-59h] BYREF
  char v6[32]; // [esp+20h] [ebp-58h] BYREF
  char format[44]; // [esp+40h] [ebp-38h] BYREF

  v2 = (char *)parse_format(a1, "l", format, v6, &v5);
  sprintf(v2, format, *(_DWORD *)(a2 + 4));
  v3 = caml_copy_string(v2);
  if ( v2 != v6 )
    caml_stat_free(v2);
  return v3;
}

//----- (08060D41) --------------------------------------------------------
void *__cdecl caml_int64_format(_BYTE *a1, int a2)
{
  char *v2; // ebx
  void *v3; // esi
  char v5; // [esp+1Fh] [ebp-59h] BYREF
  char v6[32]; // [esp+20h] [ebp-58h] BYREF
  char format[44]; // [esp+40h] [ebp-38h] BYREF

  v2 = (char *)parse_format(a1, "ll", format, v6, &v5);
  sprintf(v2, format, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8));
  v3 = caml_copy_string(v2);
  if ( v2 != v6 )
    caml_stat_free(v2);
  return v3;
}

//----- (08060DB3) --------------------------------------------------------
void *__cdecl caml_int32_format(_BYTE *a1, int a2)
{
  char *v2; // ebx
  void *v3; // esi
  char v5; // [esp+1Fh] [ebp-59h] BYREF
  char v6[32]; // [esp+20h] [ebp-58h] BYREF
  char format[44]; // [esp+40h] [ebp-38h] BYREF

  v2 = (char *)parse_format(a1, "", format, v6, &v5);
  sprintf(v2, format, *(_DWORD *)(a2 + 4));
  v3 = caml_copy_string(v2);
  if ( v2 != v6 )
    caml_stat_free(v2);
  return v3;
}

//----- (08060E1E) --------------------------------------------------------
void *__cdecl caml_format_int(_BYTE *a1, int a2)
{
  char *v2; // ebx
  void *v3; // esi
  char v5; // [esp+1Fh] [ebp-49h] BYREF
  char v6[32]; // [esp+20h] [ebp-48h] BYREF
  char format[40]; // [esp+40h] [ebp-28h] BYREF

  v2 = (char *)parse_format(a1, "l", format, v6, &v5);
  if ( v5 == 111 )
    goto LABEL_7;
  if ( v5 > 111 )
  {
    if ( v5 == 117 || v5 == 120 )
      goto LABEL_7;
  }
  else if ( v5 == 88 )
  {
LABEL_7:
    sprintf(v2, format, (unsigned int)a2 >> 1);
    goto LABEL_9;
  }
  sprintf(v2, format, a2 >> 1);
LABEL_9:
  v3 = caml_copy_string(v2);
  if ( v2 != v6 )
    caml_stat_free(v2);
  return v3;
}

//----- (08060EB4) --------------------------------------------------------
int __cdecl caml_nativeint_to_float(int a1)
{
  return caml_copy_double((double)*(int *)(a1 + 4));
}

//----- (08060ECA) --------------------------------------------------------
int __cdecl caml_int64_float_of_bits(int a1)
{
  return caml_copy_double(*(double *)(a1 + 4));
}

//----- (08060EE0) --------------------------------------------------------
int __cdecl caml_int64_to_float(int a1)
{
  return caml_copy_double((double)*(__int64 *)(a1 + 4));
}

//----- (08060EF6) --------------------------------------------------------
int __cdecl caml_int32_float_of_bits(int a1)
{
  return caml_copy_double(*(float *)(a1 + 4));
}

//----- (08060F0C) --------------------------------------------------------
int __cdecl caml_int32_to_float(int a1)
{
  return caml_copy_double((double)*(int *)(a1 + 4));
}

//----- (08060F22) --------------------------------------------------------
int *__cdecl caml_copy_nativeint(int a1)
{
  int *result; // eax

  result = caml_alloc_custom((int)&caml_nativeint_ops, 4, 0, 1u);
  result[1] = a1;
  return result;
}
// 80744F4: using guessed type char *caml_nativeint_ops;

//----- (08060F54) --------------------------------------------------------
int *__cdecl caml_nativeint_of_string(_BYTE *a1)
{
  int v1; // eax

  v1 = parse_intnat(a1, 0x20u);
  return caml_copy_nativeint(v1);
}

//----- (08060F71) --------------------------------------------------------
int *__cdecl caml_nativeint_of_int32(int a1)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4));
}

//----- (08060F87) --------------------------------------------------------
int *__cdecl caml_nativeint_of_float(double *a1)
{
  return caml_copy_nativeint((int)*a1);
}

//----- (08060FAF) --------------------------------------------------------
int *__cdecl caml_nativeint_of_int(int a1)
{
  return caml_copy_nativeint(a1 >> 1);
}

//----- (08060FC4) --------------------------------------------------------
int *__cdecl caml_nativeint_shift_right_unsigned(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) >> (a2 >> 1));
}

//----- (08060FE1) --------------------------------------------------------
int *__cdecl caml_nativeint_shift_right(int a1, int a2)
{
  return caml_copy_nativeint(*(int *)(a1 + 4) >> (a2 >> 1));
}

//----- (08060FFE) --------------------------------------------------------
int *__cdecl caml_nativeint_shift_left(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) << (a2 >> 1));
}

//----- (0806101B) --------------------------------------------------------
int *__cdecl caml_nativeint_xor(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a2 + 4));
}

//----- (08061037) --------------------------------------------------------
int *__cdecl caml_nativeint_or(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) | *(_DWORD *)(a2 + 4));
}

//----- (08061053) --------------------------------------------------------
int *__cdecl caml_nativeint_and(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) & *(_DWORD *)(a2 + 4));
}

//----- (0806106F) --------------------------------------------------------
int *__cdecl caml_nativeint_mod(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int *result; // eax
  void (__cdecl *v5)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( !v3 )
    caml_raise_zero_divide(v5, v6, v7, v8, v9);
  if ( v2 == 0x80000000 && v3 == -1 )
    result = caml_copy_nativeint(0);
  else
    result = caml_copy_nativeint(v2 % v3);
  return result;
}
// 8061085: variable 'v5' is possibly undefined
// 8061085: variable 'v6' is possibly undefined
// 8061085: variable 'v7' is possibly undefined
// 8061085: variable 'v8' is possibly undefined
// 8061085: variable 'v9' is possibly undefined
// 806108A: variable 'v2' is possibly undefined
// 8061095: variable 'v3' is possibly undefined

//----- (080610B6) --------------------------------------------------------
int *__cdecl caml_nativeint_div(int *a1, int a2)
{
  int *result; // eax
  int v3; // edx
  int v4; // ecx
  void (__cdecl *v5)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  result = a1;
  v3 = a1[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( !v4 )
    result = (int *)caml_raise_zero_divide(v5, v6, v7, v8, v9);
  if ( v3 != 0x80000000 || v4 != -1 )
    result = caml_copy_nativeint(v3 / v4);
  return result;
}
// 80610CC: variable 'v5' is possibly undefined
// 80610CC: variable 'v6' is possibly undefined
// 80610CC: variable 'v7' is possibly undefined
// 80610CC: variable 'v8' is possibly undefined
// 80610CC: variable 'v9' is possibly undefined
// 80610D1: variable 'v3' is possibly undefined
// 80610DC: variable 'v4' is possibly undefined

//----- (080610EF) --------------------------------------------------------
int *__cdecl caml_nativeint_mul(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) * *(_DWORD *)(a2 + 4));
}

//----- (0806110C) --------------------------------------------------------
int *__cdecl caml_nativeint_sub(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4));
}

//----- (08061128) --------------------------------------------------------
int *__cdecl caml_nativeint_add(int a1, int a2)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a2 + 4));
}

//----- (08061144) --------------------------------------------------------
int *__cdecl caml_nativeint_neg(int a1)
{
  return caml_copy_nativeint(-*(_DWORD *)(a1 + 4));
}

//----- (0806115C) --------------------------------------------------------
int *__cdecl caml_int64_to_nativeint(int a1)
{
  return caml_copy_nativeint(*(_DWORD *)(a1 + 4));
}

//----- (08061172) --------------------------------------------------------
int *__cdecl caml_copy_int64(int a1, int a2)
{
  int *result; // eax

  result = caml_alloc_custom((int)&caml_int64_ops, 8, 0, 1u);
  result[1] = a1;
  result[2] = a2;
  return result;
}
// 80744D8: using guessed type char *caml_int64_ops;

//----- (080611B8) --------------------------------------------------------
int *__cdecl caml_int64_bits_of_float(int *a1)
{
  return caml_copy_int64(*a1, a1[1]);
}

//----- (080611D4) --------------------------------------------------------
int *__cdecl caml_int64_of_string(_BYTE *a1)
{
  char *v1; // edi
  unsigned __int64 v2; // kr00_8
  int v3; // eax
  int v4; // ebx
  unsigned int v5; // esi
  char *i; // edi
  int v7; // eax
  unsigned int v8; // kr08_4
  unsigned __int64 v9; // rax
  __int128 v11; // [esp+0h] [ebp-78h]
  _DWORD *v12; // [esp+10h] [ebp-68h]
  int v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+40h] [ebp-38h]
  __int64 v15; // [esp+48h] [ebp-30h]
  unsigned __int64 v16; // [esp+48h] [ebp-30h]
  int v17; // [esp+58h] [ebp-20h] BYREF
  int v18[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  v1 = parse_sign_and_base(a1, &v17, v18);
  v14 = v17;
  v15 = v17;
  v2 = 0xFFFFFFFFFFFFFFFFLL / v17;
  v3 = parse_digit(*v1);
  v4 = v3;
  if ( v3 < 0 || v14 <= v3 )
    v3 = caml_failwith("int_of_string", SDWORD1(v11), DWORD2(v11), SHIDWORD(v11), v12);
  v5 = v3 >> 31;
  for ( i = v1 + 1; ; ++i )
  {
    if ( *i == 95 )
      continue;
    v7 = parse_digit(*i);
    v13 = v7;
    if ( v7 < 0 || v14 <= v7 )
      break;
    if ( __PAIR64__(v5, v4) > v2 )
      caml_failwith("int_of_string", SDWORD1(v11), DWORD2(v11), SHIDWORD(v11), v12);
    v8 = v13 + v4 * v15;
    v5 = (v13 + __PAIR64__(v5, v4) * v15) >> 32;
    v4 = v8;
    if ( v13 >> 31 >= v5 && (v13 >> 31 > v5 || v13 > v8) )
      caml_failwith("int_of_string", SDWORD1(v11), DWORD2(v11), SHIDWORD(v11), v12);
  }
  v16 = __PAIR64__(v5, v4);
  if ( i != &a1[caml_string_length((int)a1)] )
    caml_failwith("int_of_string", SDWORD1(v11), DWORD2(v11), SHIDWORD(v11), v12);
  if ( v17 == 10 )
  {
    v9 = 0x7FFFFFFFFFFFFFFFLL;
    if ( v18[0] < 0 )
      v9 = 0x8000000000000000LL;
    if ( v9 < __PAIR64__(v5, v4) )
      caml_failwith("int_of_string", SDWORD1(v11), DWORD2(v11), SHIDWORD(v11), v12);
  }
  if ( v18[0] < 0 )
  {
    v4 = -v4;
    v5 = (unsigned __int64)-(__int64)v16 >> 32;
  }
  return caml_copy_int64(v4, v5);
}
// 806123A: variable 'v11' is possibly undefined
// 806123A: variable 'v12' is possibly undefined

//----- (08061351) --------------------------------------------------------
int *__cdecl caml_int64_of_nativeint(int a1)
{
  return caml_copy_int64(*(_DWORD *)(a1 + 4), *(int *)(a1 + 4) >> 31);
}

//----- (08061370) --------------------------------------------------------
int *__cdecl caml_int64_of_int32(int a1)
{
  return caml_copy_int64(*(_DWORD *)(a1 + 4), *(int *)(a1 + 4) >> 31);
}

//----- (0806138F) --------------------------------------------------------
int *__cdecl caml_int64_of_float(double *a1)
{
  return caml_copy_int64((__int64)*a1, (unsigned __int64)(__int64)*a1 >> 32);
}

//----- (080613B7) --------------------------------------------------------
int *__cdecl caml_int64_of_int(int a1)
{
  return caml_copy_int64(a1 >> 1, a1 >> 31);
}

//----- (080613D5) --------------------------------------------------------
int *__cdecl caml_int64_shift_right_unsigned(int a1, int a2)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(a1 + 4) >> (a2 >> 1);
  return caml_copy_int64(v2, SHIDWORD(v2));
}

//----- (08061405) --------------------------------------------------------
int *__cdecl caml_int64_shift_right(int a1, int a2)
{
  __int64 v2; // rax

  v2 = *(__int64 *)(a1 + 4) >> (a2 >> 1);
  return caml_copy_int64(v2, SHIDWORD(v2));
}

//----- (08061436) --------------------------------------------------------
int *__cdecl caml_int64_shift_left(int a1, int a2)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(a1 + 4) << (a2 >> 1);
  return caml_copy_int64(v2, SHIDWORD(v2));
}

//----- (08061466) --------------------------------------------------------
int *__cdecl caml_int64_xor(int a1, int a2)
{
  return caml_copy_int64(*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a2 + 4), *(_DWORD *)(a1 + 8) ^ *(_DWORD *)(a2 + 8));
}

//----- (0806148C) --------------------------------------------------------
int *__cdecl caml_int64_or(int a1, int a2)
{
  return caml_copy_int64(*(_DWORD *)(a1 + 4) | *(_DWORD *)(a2 + 4), *(_DWORD *)(a1 + 8) | *(_DWORD *)(a2 + 8));
}

//----- (080614B2) --------------------------------------------------------
int *__cdecl caml_int64_and(int a1, int a2)
{
  return caml_copy_int64(*(_DWORD *)(a1 + 4) & *(_DWORD *)(a2 + 4), *(_DWORD *)(a1 + 8) & *(_DWORD *)(a2 + 8));
}

//----- (080614D8) --------------------------------------------------------
int *__cdecl caml_int64_mod(int a1, int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // ecx
  unsigned int v4; // edx
  int v5; // eax
  int *result; // eax
  void (__cdecl *v7)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]
  unsigned int v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]
  _DWORD *v11; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8);
  if ( !*(_QWORD *)(a2 + 4) )
    v5 = caml_raise_zero_divide(v7, v8, v9, v10, v11);
  if ( v2 | (v3 + 0x80000000) || (v5 & v4) != -1 )
    result = caml_copy_int64(
               __SPAIR64__(v3, v2) % __SPAIR64__(v5, v4),
               (unsigned __int64)(__SPAIR64__(v3, v2) % __SPAIR64__(v5, v4)) >> 32);
  else
    result = caml_copy_int64(0, 0);
  return result;
}
// 80614F8: variable 'v7' is possibly undefined
// 80614F8: variable 'v8' is possibly undefined
// 80614F8: variable 'v9' is possibly undefined
// 80614F8: variable 'v10' is possibly undefined
// 80614F8: variable 'v11' is possibly undefined
// 80614FD: variable 'v3' is possibly undefined
// 8061509: variable 'v4' is possibly undefined

//----- (0806154D) --------------------------------------------------------
int *__cdecl caml_int64_div(int *a1, int a2)
{
  int *result; // eax
  int v3; // esi
  int v4; // ebx
  unsigned int v5; // ecx
  unsigned int v6; // edx
  void (__cdecl *v7)(_DWORD, _DWORD *); // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  unsigned int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  _DWORD *v11; // [esp+10h] [ebp-18h]

  result = a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  if ( !*(_QWORD *)(a2 + 4) )
    result = (int *)caml_raise_zero_divide(v7, v8, v9, v10, v11);
  if ( v3 | (v4 + 0x80000000) || (v6 & v5) != -1 )
    result = caml_copy_int64(
               __SPAIR64__(v4, v3) / __SPAIR64__(v6, v5),
               (unsigned __int64)(__SPAIR64__(v4, v3) / __SPAIR64__(v6, v5)) >> 32);
  return result;
}
// 8061574: variable 'v7' is possibly undefined
// 8061574: variable 'v8' is possibly undefined
// 8061574: variable 'v9' is possibly undefined
// 8061574: variable 'v10' is possibly undefined
// 8061574: variable 'v11' is possibly undefined
// 8061585: variable 'v6' is possibly undefined
// 8061585: variable 'v5' is possibly undefined

//----- (080615B9) --------------------------------------------------------
int *__cdecl caml_int64_mul(int a1, int a2)
{
  __int64 v3; // [esp+0h] [ebp-18h]

  v3 = *(_QWORD *)(a2 + 4) * *(_QWORD *)(a1 + 4);
  return caml_copy_int64(v3, SHIDWORD(v3));
}

//----- (080615F1) --------------------------------------------------------
int *__cdecl caml_int64_sub(int a1, int a2)
{
  __int64 v2; // kr00_8

  v2 = *(_QWORD *)(a1 + 4) - *(_QWORD *)(a2 + 4);
  return caml_copy_int64(v2, SHIDWORD(v2));
}

//----- (0806162F) --------------------------------------------------------
int *__cdecl caml_int64_add(int a1, int a2)
{
  __int64 v3; // [esp+0h] [ebp-18h]

  v3 = *(_QWORD *)(a2 + 4) + *(_QWORD *)(a1 + 4);
  return caml_copy_int64(v3, SHIDWORD(v3));
}

//----- (0806165E) --------------------------------------------------------
int *__cdecl caml_int64_neg(int a1)
{
  return caml_copy_int64(-*(_DWORD *)(a1 + 4), -*(_QWORD *)(a1 + 4) >> 32);
}

//----- (08061682) --------------------------------------------------------
int *__cdecl caml_copy_int32(int a1)
{
  int *result; // eax

  result = caml_alloc_custom((int)&caml_int32_ops, 4, 0, 1u);
  result[1] = a1;
  return result;
}
// 80744BC: using guessed type char *caml_int32_ops;

//----- (080616B4) --------------------------------------------------------
int *__cdecl caml_nativeint_to_int32(int a1)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4));
}

//----- (080616CA) --------------------------------------------------------
int *__cdecl caml_int64_to_int32(int a1)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4));
}

//----- (080616E0) --------------------------------------------------------
int *__cdecl caml_int32_bits_of_float(double *a1)
{
  int v2; // [esp+18h] [ebp-10h]

  *(float *)&v2 = *a1;
  return caml_copy_int32(v2);
}

//----- (080616FB) --------------------------------------------------------
int *__cdecl caml_int32_of_string(_BYTE *a1)
{
  int v1; // eax

  v1 = parse_intnat(a1, 0x20u);
  return caml_copy_int32(v1);
}

//----- (08061718) --------------------------------------------------------
int *__cdecl caml_int32_of_float(double *a1)
{
  return caml_copy_int32((int)*a1);
}

//----- (08061740) --------------------------------------------------------
int *__cdecl caml_int32_of_int(int a1)
{
  return caml_copy_int32(a1 >> 1);
}

//----- (08061755) --------------------------------------------------------
int *__cdecl caml_int32_shift_right_unsigned(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) >> (a2 >> 1));
}

//----- (08061772) --------------------------------------------------------
int *__cdecl caml_int32_shift_right(int a1, int a2)
{
  return caml_copy_int32(*(int *)(a1 + 4) >> (a2 >> 1));
}

//----- (0806178F) --------------------------------------------------------
int *__cdecl caml_int32_shift_left(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) << (a2 >> 1));
}

//----- (080617AC) --------------------------------------------------------
int *__cdecl caml_int32_xor(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a2 + 4));
}

//----- (080617C8) --------------------------------------------------------
int *__cdecl caml_int32_or(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) | *(_DWORD *)(a2 + 4));
}

//----- (080617E4) --------------------------------------------------------
int *__cdecl caml_int32_and(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) & *(_DWORD *)(a2 + 4));
}

//----- (08061800) --------------------------------------------------------
int *__cdecl caml_int32_mod(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int *result; // eax
  void (__cdecl *v5)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( !v3 )
    caml_raise_zero_divide(v5, v6, v7, v8, v9);
  if ( v2 == 0x80000000 && v3 == -1 )
    result = caml_copy_int32(0);
  else
    result = caml_copy_int32(v2 % v3);
  return result;
}
// 8061816: variable 'v5' is possibly undefined
// 8061816: variable 'v6' is possibly undefined
// 8061816: variable 'v7' is possibly undefined
// 8061816: variable 'v8' is possibly undefined
// 8061816: variable 'v9' is possibly undefined
// 806181B: variable 'v2' is possibly undefined
// 8061826: variable 'v3' is possibly undefined

//----- (08061847) --------------------------------------------------------
int *__cdecl caml_int32_div(int *a1, int a2)
{
  int *result; // eax
  int v3; // edx
  int v4; // ecx
  void (__cdecl *v5)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  unsigned int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  result = a1;
  v3 = a1[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( !v4 )
    result = (int *)caml_raise_zero_divide(v5, v6, v7, v8, v9);
  if ( v3 != 0x80000000 || v4 != -1 )
    result = caml_copy_int32(v3 / v4);
  return result;
}
// 806185D: variable 'v5' is possibly undefined
// 806185D: variable 'v6' is possibly undefined
// 806185D: variable 'v7' is possibly undefined
// 806185D: variable 'v8' is possibly undefined
// 806185D: variable 'v9' is possibly undefined
// 8061862: variable 'v3' is possibly undefined
// 806186D: variable 'v4' is possibly undefined

//----- (08061880) --------------------------------------------------------
int *__cdecl caml_int32_mul(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) * *(_DWORD *)(a2 + 4));
}

//----- (0806189D) --------------------------------------------------------
int *__cdecl caml_int32_sub(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4));
}

//----- (080618B9) --------------------------------------------------------
int *__cdecl caml_int32_add(int a1, int a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a2 + 4));
}

//----- (080618D5) --------------------------------------------------------
int *__cdecl caml_int32_neg(int a1)
{
  return caml_copy_int32(-*(_DWORD *)(a1 + 4));
}

//----- (080618F0) --------------------------------------------------------
int __cdecl caml_int_of_float(double *a1)
{
  return 2 * (int)*a1 + 1;
}

//----- (0806191A) --------------------------------------------------------
int __cdecl caml_eq_float(double *a1, double *a2)
{
  return 2 * (*a2 == *a1) + 1;
}

//----- (0806193C) --------------------------------------------------------
int __cdecl caml_neq_float(double *a1, double *a2)
{
  return 2 * (*a2 != *a1) + 1;
}

//----- (0806195E) --------------------------------------------------------
int __cdecl caml_le_float(double *a1, double *a2)
{
  return *a2 < (long double)*a1 ? 1 : 3;
}

//----- (08061979) --------------------------------------------------------
int __cdecl caml_lt_float(double *a1, double *a2)
{
  return 2 * (*a2 > (long double)*a1) + 1;
}

//----- (08061996) --------------------------------------------------------
int __cdecl caml_ge_float(double *a1, double *a2)
{
  return *a1 < (long double)*a2 ? 1 : 3;
}

//----- (080619B3) --------------------------------------------------------
int __cdecl caml_gt_float(double *a1, double *a2)
{
  return 2 * (*a1 > (long double)*a2) + 1;
}

//----- (080619D2) --------------------------------------------------------
int __cdecl caml_float_compare(double *a1, double *a2)
{
  if ( *a1 == *a2 )
    return 1;
  if ( *a2 > (long double)*a1 )
    return -1;
  return 3;
}

//----- (08061A37) --------------------------------------------------------
void caml_init_ieee_floats()
{
  ;
}

//----- (08061A3C) --------------------------------------------------------
int __cdecl caml_classify_float(double *a1)
{
  unsigned int v1; // edx
  int result; // eax

  v1 = __fpclassify(COERCE_UNSIGNED_INT64(*a1), HIDWORD(COERCE_UNSIGNED_INT64(*a1)));
  result = 1;
  if ( v1 <= 3 )
    result = CSWTCH_118[v1];
  return result;
}
// 804A1E4: using guessed type int __cdecl __fpclassify(_DWORD, _DWORD);

//----- (08061A64) --------------------------------------------------------
long double __cdecl caml_log1p(double a1)
{
  return log1p(a1);
}

//----- (08061A77) --------------------------------------------------------
long double __cdecl caml_expm1(double a1)
{
  return expm1(a1);
}

//----- (08061A8A) --------------------------------------------------------
void *__cdecl caml_format_float(char *nptr, int a2)
{
  char *v2; // ebx
  signed int v3; // esi
  int v4; // eax
  char *v5; // esi
  void *v6; // ebx
  char s[394]; // [esp+1Eh] [ebp-18Ah] BYREF

  v2 = nptr;
  if ( !*nptr )
    goto LABEL_21;
  if ( (unsigned __int8)(*nptr - 48) > 9u )
  {
    while ( *++v2 )
    {
      if ( (unsigned __int8)(*v2 - 48) <= 9u )
        goto LABEL_5;
    }
    goto LABEL_21;
  }
LABEL_5:
  v3 = strtol(v2, 0, 10) + 350;
  if ( v3 < 350 )
    v3 = 350;
  if ( *v2 )
  {
    if ( *v2 == 46 )
    {
LABEL_13:
      v4 = strtol(v2 + 1, 0, 10) + 350;
      if ( v3 < v4 )
        v3 = v4;
    }
    else
    {
      while ( *++v2 )
      {
        if ( *v2 == 46 )
          goto LABEL_13;
      }
    }
  }
  if ( (unsigned int)v3 <= 0x171 )
  {
LABEL_21:
    sprintf(s, nptr, *(double *)a2);
    return caml_copy_string(s);
  }
  v5 = (char *)caml_stat_alloc(v3);
  sprintf(v5, nptr, *(double *)a2);
  v6 = caml_copy_string(v5);
  if ( v5 != s )
    caml_stat_free(v5);
  return v6;
}

//----- (08061BAA) --------------------------------------------------------
int __cdecl caml_copy_double(double a1)
{
  int v1; // edx
  int result; // eax

  v1 = caml_young_ptr;
  caml_young_ptr -= 12;
  if ( caml_young_ptr < (unsigned int)caml_young_limit )
  {
    caml_young_ptr = v1;
    caml_minor_collection();
    caml_young_ptr -= 12;
  }
  *(_DWORD *)caml_young_ptr = 3069;
  result = caml_young_ptr + 4;
  *(double *)(caml_young_ptr + 4) = a1;
  return result;
}
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08061BF8) --------------------------------------------------------
int __cdecl caml_log1p_float(double *a1)
{
  long double v1; // fst7

  v1 = caml_log1p(*a1);
  return caml_copy_double(v1);
}

//----- (08061C15) --------------------------------------------------------
int __cdecl caml_expm1_float(double *a1)
{
  long double v1; // fst7

  v1 = caml_expm1(*a1);
  return caml_copy_double(v1);
}

//----- (08061C32) --------------------------------------------------------
int __cdecl caml_ceil_float(double *a1)
{
  long double v1; // fst7

  v1 = ceil(*a1);
  return caml_copy_double(v1);
}

//----- (08061C4F) --------------------------------------------------------
int __cdecl caml_atan2_float(double *a1, double *a2)
{
  long double v2; // fst7

  v2 = atan2(*a1, *a2);
  return caml_copy_double(v2);
}

//----- (08061C75) --------------------------------------------------------
int __cdecl caml_atan_float(double *a1)
{
  long double v1; // fst7

  v1 = atan(*a1);
  return caml_copy_double(v1);
}

//----- (08061C92) --------------------------------------------------------
int __cdecl caml_acos_float(double *a1)
{
  long double v1; // fst7

  v1 = acos(*a1);
  return caml_copy_double(v1);
}

//----- (08061CAF) --------------------------------------------------------
int __cdecl caml_asin_float(double *a1)
{
  long double v1; // fst7

  v1 = asin(*a1);
  return caml_copy_double(v1);
}

//----- (08061CCC) --------------------------------------------------------
int __cdecl caml_tanh_float(double *a1)
{
  long double v1; // fst7

  v1 = tanh(*a1);
  return caml_copy_double(v1);
}

//----- (08061CE9) --------------------------------------------------------
int __cdecl caml_tan_float(double *a1)
{
  long double v1; // fst7

  v1 = tan(*a1);
  return caml_copy_double(v1);
}

//----- (08061D06) --------------------------------------------------------
int __cdecl caml_cosh_float(double *a1)
{
  long double v1; // fst7

  v1 = cosh(*a1);
  return caml_copy_double(v1);
}

//----- (08061D23) --------------------------------------------------------
int __cdecl caml_cos_float(double *a1)
{
  long double v1; // fst7

  v1 = cos(*a1);
  return caml_copy_double(v1);
}

//----- (08061D40) --------------------------------------------------------
int __cdecl caml_sinh_float(double *a1)
{
  long double v1; // fst7

  v1 = sinh(*a1);
  return caml_copy_double(v1);
}

//----- (08061D5D) --------------------------------------------------------
int __cdecl caml_sin_float(double *a1)
{
  long double v1; // fst7

  v1 = sin(*a1);
  return caml_copy_double(v1);
}

//----- (08061D7A) --------------------------------------------------------
int __cdecl caml_power_float(double *a1, double *a2)
{
  long double v2; // fst7

  v2 = pow(*a1, *a2);
  return caml_copy_double(v2);
}

//----- (08061DA0) --------------------------------------------------------
int __cdecl caml_sqrt_float(double *a1)
{
  return caml_copy_double(sqrt(*a1));
}

//----- (08061DD1) --------------------------------------------------------
char *__cdecl caml_modf_float(double *a1)
{
  int v1; // ebx
  long double v2; // fst7
  int v4[8]; // [esp+1Ch] [ebp-5Ch] BYREF
  int v5; // [esp+3Ch] [ebp-3Ch] BYREF
  int v6; // [esp+40h] [ebp-38h] BYREF
  char *v7; // [esp+44h] [ebp-34h] BYREF
  int v8[8]; // [esp+48h] [ebp-30h] BYREF
  double iptr[2]; // [esp+68h] [ebp-10h] BYREF

  v1 = caml_local_roots;
  v8[0] = caml_local_roots;
  v8[2] = 1;
  v8[1] = 1;
  v8[3] = (int)&a1;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  v4[0] = (int)v8;
  caml_local_roots = (int)v4;
  v4[2] = 1;
  v4[1] = 3;
  v4[3] = (int)&v7;
  v4[4] = (int)&v6;
  v4[5] = (int)&v5;
  v2 = modf(*a1, iptr);
  v6 = caml_copy_double(v2);
  v5 = caml_copy_double(iptr[0]);
  v7 = caml_alloc_tuple(2u);
  *(_DWORD *)v7 = v6;
  *((_DWORD *)v7 + 1) = v5;
  caml_local_roots = v1;
  return v7;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08061E91) --------------------------------------------------------
int __cdecl caml_log10_float(double *a1)
{
  long double v1; // fst7

  v1 = log10(*a1);
  return caml_copy_double(v1);
}

//----- (08061EAE) --------------------------------------------------------
int __cdecl caml_log_float(double *a1)
{
  long double v1; // fst7

  v1 = log(*a1);
  return caml_copy_double(v1);
}

//----- (08061ECB) --------------------------------------------------------
int __cdecl caml_ldexp_float(double *a1, int a2)
{
  long double v2; // fst7

  v2 = ldexp(*a1, a2 >> 1);
  return caml_copy_double(v2);
}

//----- (08061EF1) --------------------------------------------------------
char *__cdecl caml_frexp_float(double *a1)
{
  int v1; // ebx
  long double v2; // fst7
  int exponent; // [esp+14h] [ebp-54h] BYREF
  int v5[8]; // [esp+18h] [ebp-50h] BYREF
  int v6; // [esp+38h] [ebp-30h] BYREF
  char *v7; // [esp+3Ch] [ebp-2Ch] BYREF
  int v8[10]; // [esp+40h] [ebp-28h] BYREF

  v1 = caml_local_roots;
  v8[0] = caml_local_roots;
  v8[2] = 1;
  v8[1] = 1;
  v8[3] = (int)&a1;
  v7 = 0;
  v6 = 0;
  v5[0] = (int)v8;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 2;
  v5[3] = (int)&v7;
  v5[4] = (int)&v6;
  v2 = frexp(*a1, &exponent);
  v6 = caml_copy_double(v2);
  v7 = caml_alloc_tuple(2u);
  *(_DWORD *)v7 = v6;
  *((_DWORD *)v7 + 1) = 2 * exponent + 1;
  caml_local_roots = v1;
  return v7;
}
// 8074754: using guessed type int caml_local_roots;

//----- (08061F9A) --------------------------------------------------------
int __cdecl caml_fmod_float(double *a1, double *a2)
{
  long double v2; // fst4
  char v4; // c2

  v2 = *a1;
  do
    v2 = __FPREM__(v2, *a2);
  while ( v4 );
  return caml_copy_double(v2);
}
// 8061FB3: variable 'v4' is possibly undefined

//----- (08061FE0) --------------------------------------------------------
int __cdecl caml_floor_float(double *a1)
{
  long double v1; // fst7

  v1 = floor(*a1);
  return caml_copy_double(v1);
}

//----- (08061FFD) --------------------------------------------------------
int __cdecl caml_exp_float(double *a1)
{
  long double v1; // fst7

  v1 = exp(*a1);
  return caml_copy_double(v1);
}

//----- (0806201A) --------------------------------------------------------
int __cdecl caml_div_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 / *a2);
}

//----- (08062034) --------------------------------------------------------
int __cdecl caml_mul_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 * *a2);
}

//----- (0806204E) --------------------------------------------------------
int __cdecl caml_sub_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 - *a2);
}

//----- (08062068) --------------------------------------------------------
int __cdecl caml_add_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 + *a2);
}

//----- (08062082) --------------------------------------------------------
int __cdecl caml_abs_float(double *a1)
{
  return caml_copy_double(fabs(*a1));
}

//----- (08062099) --------------------------------------------------------
int __cdecl caml_neg_float(double *a1)
{
  return caml_copy_double(-*a1);
}

//----- (080620B0) --------------------------------------------------------
int __cdecl caml_float_of_int(int a1)
{
  return caml_copy_double((double)(a1 >> 1));
}

//----- (080620CB) --------------------------------------------------------
int __cdecl caml_float_of_string(int a1, int a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // ebx
  char *v5; // edi
  char *v6; // eax
  char *v7; // esi
  int result; // eax
  int v9; // [esp+4h] [ebp-84h]
  unsigned int v10; // [esp+8h] [ebp-80h]
  int v11; // [esp+Ch] [ebp-7Ch]
  _DWORD *v12; // [esp+10h] [ebp-78h]
  double v13; // [esp+18h] [ebp-70h]
  char *endptr; // [esp+2Ch] [ebp-5Ch] BYREF
  char nptr[88]; // [esp+30h] [ebp-58h] BYREF

  v3 = caml_string_length(a1);
  v4 = v3;
  v5 = nptr;
  if ( v3 > 0x3F )
    v5 = (char *)caml_stat_alloc(v3 + 1);
  v6 = (char *)a1;
  v7 = v5;
  while ( v4 )
  {
    if ( *v6 != 95 )
      *v7++ = *v6;
    ++v6;
    --v4;
  }
  *v7 = 0;
  if ( v7 == v5 || (v13 = strtod(v5, &endptr), endptr != v7) )
  {
    if ( v5 != nptr )
      caml_stat_free(v5);
    caml_failwith("float_of_string", v9, v10, v11, v12);
    result = caml_float_of_substring(a1, a2, a3);
  }
  else
  {
    if ( v5 != nptr )
      caml_stat_free(v5);
    result = caml_copy_double(v13);
  }
  return result;
}
// 8062169: variable 'v9' is possibly undefined
// 8062169: variable 'v10' is possibly undefined
// 8062169: variable 'v11' is possibly undefined
// 8062169: variable 'v12' is possibly undefined

//----- (0806216E) --------------------------------------------------------
int __cdecl caml_float_of_substring(int a1, int a2, int a3)
{
  unsigned int v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // ebx
  char *v6; // edi
  char *v7; // eax
  char *v8; // esi
  int result; // eax
  int v10; // [esp+4h] [ebp-84h]
  unsigned int v11; // [esp+8h] [ebp-80h]
  int v12; // [esp+Ch] [ebp-7Ch]
  _DWORD *v13; // [esp+10h] [ebp-78h]
  double v14; // [esp+18h] [ebp-70h]
  char *endptr; // [esp+2Ch] [ebp-5Ch] BYREF
  char nptr[88]; // [esp+30h] [ebp-58h] BYREF

  v3 = a2 >> 1;
  v4 = caml_string_length(a1);
  if ( a2 >> 1 < 0 || v4 <= v3 || (v5 = a3 >> 1, a3 >> 1 <= 0) || v5 > v4 - v3 )
  {
    v5 = 0;
    v6 = nptr;
  }
  else if ( v5 > 0x3F )
  {
    v6 = (char *)caml_stat_alloc(v5 + 1);
  }
  else
  {
    v6 = nptr;
  }
  v7 = (char *)(v3 + a1);
  v8 = v6;
  while ( v5 )
  {
    if ( *v7 != 95 )
      *v8++ = *v7;
    ++v7;
    --v5;
  }
  *v8 = 0;
  if ( v8 == v6 || (v14 = strtod(v6, &endptr), endptr != v8) )
  {
    if ( v6 != nptr )
      caml_stat_free(v6);
    caml_failwith("float_of_string", v10, v11, v12, v13);
    result = caml_string_length(a1);
  }
  else
  {
    if ( v6 != nptr )
      caml_stat_free(v6);
    result = caml_copy_double(v14);
  }
  return result;
}
// 8062236: variable 'v10' is possibly undefined
// 8062236: variable 'v11' is possibly undefined
// 8062236: variable 'v12' is possibly undefined
// 8062236: variable 'v13' is possibly undefined

//----- (08062240) --------------------------------------------------------
int __cdecl caml_string_length(int a1)
{
  int v1; // eax

  v1 = 4 * (*(_DWORD *)(a1 - 4) >> 10) - 1;
  return v1 - *(char *)(v1 + a1);
}

//----- (0806225B) --------------------------------------------------------
int __cdecl caml_ml_string_length(int a1)
{
  int v1; // eax

  v1 = 4 * (*(_DWORD *)(a1 - 4) >> 10) - 1;
  return 2 * (v1 - *(char *)(v1 + a1)) + 1;
}

//----- (0806227A) --------------------------------------------------------
int __cdecl caml_string_equal(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // edx
  int v4; // eax

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 3;
  v4 = *(a1 - 1) >> 10;
  if ( v4 == *(a2 - 1) >> 10 )
  {
    if ( v4 )
    {
      if ( *a1 != *a2 )
        return 1;
      while ( --v4 )
      {
        if ( *++v2 != *++v3 )
          return 1;
      }
    }
    return 3;
  }
  return 1;
}

//----- (080622C4) --------------------------------------------------------
int __cdecl caml_string_notequal(_DWORD *a1, _DWORD *a2)
{
  return 4 - caml_string_equal(a1, a2);
}

//----- (080622E7) --------------------------------------------------------
int __cdecl caml_bitvect_test(int a1, int a2)
{
  return 2 * ((1 << ((a2 >> 1) & 7)) & *(unsigned __int8 *)((a2 >> 4) + a1)) + 1;
}

//----- (0806230D) --------------------------------------------------------
int __cdecl caml_is_printable(int a1)
{
  if ( !locale_is_set_2848 )
  {
    setlocale(0, "");
    locale_is_set_2848 = 1;
  }
  return ((*__ctype_b_loc())[a1 >> 1] & 0x4000) == 0 ? 1 : 3;
}
// 8078D20: using guessed type int locale_is_set_2848;

//----- (0806235C) --------------------------------------------------------
int __cdecl caml_fill_string(int a1, int a2, int a3, int a4)
{
  memset((void *)(a1 + (a2 >> 1)), a4 >> 1, a3 >> 1);
  return 1;
}

//----- (0806238B) --------------------------------------------------------
int __cdecl caml_blit_string(int a1, int a2, int a3, int a4, int a5)
{
  memmove((void *)(a3 + (a4 >> 1)), (const void *)(a1 + (a2 >> 1)), a5 >> 1);
  return 1;
}

//----- (080623BD) --------------------------------------------------------
int __cdecl caml_string_compare(const void *a1, const void *a2)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  _BOOL4 v4; // eax
  unsigned int v6; // [esp+4h] [ebp-10h]

  if ( a1 == a2 )
    return 1;
  v6 = caml_string_length((int)a1);
  v2 = caml_string_length((int)a2);
  v3 = v6;
  if ( v2 <= v6 )
    v3 = v2;
  v4 = memcmp(a1, a2, v3) != 0;
  if ( v4 < 0 )
    return -1;
  if ( v4 <= 0 )
  {
    if ( v6 >= v2 )
    {
      if ( v6 <= v2 )
        return 1;
      return 3;
    }
    return -1;
  }
  return 3;
}

//----- (08062436) --------------------------------------------------------
int __cdecl caml_string_greaterequal(const void *a1, const void *a2)
{
  return 2 * (caml_string_compare(a1, a2) > 0) + 1;
}

//----- (0806245C) --------------------------------------------------------
int __cdecl caml_string_greaterthan(const void *a1, const void *a2)
{
  return 2 * (caml_string_compare(a1, a2) > 1) + 1;
}

//----- (08062483) --------------------------------------------------------
int __cdecl caml_string_lessequal(const void *a1, const void *a2)
{
  return 2 * (caml_string_compare(a1, a2) < 2) + 1;
}

//----- (080624AA) --------------------------------------------------------
int __cdecl caml_string_lessthan(const void *a1, const void *a2)
{
  return 2 * (caml_string_compare(a1, a2) <= 0) + 1;
}

//----- (080624D0) --------------------------------------------------------
int __usercall caml_string_set@<eax>(_DWORD *a1@<ebx>, int a2, int a3, int a4)
{
  unsigned int v4; // ebx
  int v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-10h]
  int v9; // [esp+Ch] [ebp-Ch]

  v4 = a3 >> 1;
  if ( a3 >> 1 < 0 || v4 >= caml_string_length(a2) )
    caml_array_bound_error(v6, v7, v8, v9, a1);
  *(_BYTE *)(v4 + a2) = a4 >> 1;
  return 1;
}
// 80624D0: could not find valid save-restore pair for ebx
// 80624F2: variable 'v6' is possibly undefined
// 80624F2: variable 'v7' is possibly undefined
// 80624F2: variable 'v8' is possibly undefined
// 80624F2: variable 'v9' is possibly undefined

//----- (0806250E) --------------------------------------------------------
int __usercall caml_string_get@<eax>(_DWORD *a1@<ebx>, int a2, int a3)
{
  unsigned int v3; // ebx
  int v5; // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]

  v3 = a3 >> 1;
  if ( a3 >> 1 < 0 || v3 >= caml_string_length(a2) )
    caml_array_bound_error(v5, v6, v7, v8, a1);
  return 2 * *(unsigned __int8 *)(v3 + a2) + 1;
}
// 806250E: could not find valid save-restore pair for ebx
// 8062530: variable 'v5' is possibly undefined
// 8062530: variable 'v6' is possibly undefined
// 8062530: variable 'v7' is possibly undefined
// 8062530: variable 'v8' is possibly undefined

//----- (08062547) --------------------------------------------------------
int __cdecl caml_create_string(int a1)
{
  int v1; // eax
  int v3; // [esp+4h] [ebp-14h]
  unsigned int v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v1 = a1 >> 1;
  if ( (unsigned int)(a1 >> 1) > 0xFFFFFB )
    v1 = caml_invalid_argument("String.create", v3, v4, v5, v6);
  return caml_alloc_string(v1);
}
// 8062560: variable 'v3' is possibly undefined
// 8062560: variable 'v4' is possibly undefined
// 8062560: variable 'v5' is possibly undefined
// 8062560: variable 'v6' is possibly undefined

//----- (08062570) --------------------------------------------------------
int __cdecl caml_array_unsafe_set_float(int a1, int a2, double *a3)
{
  *(double *)(a1 + 8 * (a2 >> 1)) = *a3;
  return 1;
}

//----- (0806258A) --------------------------------------------------------
int __cdecl caml_make_array(unsigned int *a1)
{
  int v1; // ebx
  int result; // eax
  unsigned int v3; // esi
  unsigned int v4; // edx
  unsigned int i; // eax
  int v6[8]; // [esp+18h] [ebp-60h] BYREF
  int v7; // [esp+38h] [ebp-40h] BYREF
  unsigned int v8; // [esp+3Ch] [ebp-3Ch] BYREF
  int v9[11]; // [esp+40h] [ebp-38h] BYREF

  v1 = caml_local_roots;
  v9[0] = caml_local_roots;
  v9[2] = 1;
  v9[1] = 1;
  v9[3] = (int)&a1;
  v8 = 0;
  v7 = 0;
  v6[0] = (int)v9;
  caml_local_roots = (int)v6;
  v6[2] = 1;
  v6[1] = 2;
  v6[3] = (int)&v8;
  v6[4] = (int)&v7;
  result = (int)a1;
  v3 = *(a1 - 1) >> 10;
  if ( v3 )
  {
    v4 = *a1;
    if ( (*a1 & 1) == 0
      && (v8 = *a1, (*(_BYTE *)(caml_page_table[v4 >> 23] + ((v4 >> 12) & 0x7FF)) & 7) != 0)
      && *(_BYTE *)(v4 - 4) == 0xFD )
    {
      v7 = caml_alloc_small(2 * v3, 254);
      for ( i = 0; i < v3; ++i )
        *(double *)(v7 + 8 * i) = *(double *)a1[i];
      caml_local_roots = v1;
      result = v7;
    }
    else
    {
      caml_local_roots = v1;
    }
  }
  else
  {
    caml_local_roots = v1;
  }
  return result;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0806267C) --------------------------------------------------------
int __cdecl caml_array_unsafe_get_float(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  double v4; // [esp+8h] [ebp-10h]

  v4 = *(double *)(a1 + 8 * (a2 >> 1));
  v2 = caml_young_ptr;
  caml_young_ptr -= 12;
  if ( caml_young_ptr < (unsigned int)caml_young_limit )
  {
    caml_young_ptr = v2;
    caml_minor_collection();
    caml_young_ptr -= 12;
  }
  *(_DWORD *)caml_young_ptr = 3069;
  result = caml_young_ptr + 4;
  *(double *)(caml_young_ptr + 4) = v4;
  return result;
}
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (080626D2) --------------------------------------------------------
int __cdecl caml_array_unsafe_get(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 - 4) == 0xFE )
    result = caml_array_unsafe_get_float(a1, a2);
  else
    result = *(_DWORD *)(a1 + 4 * (a2 >> 1));
  return result;
}

//----- (080626F9) --------------------------------------------------------
double *__cdecl caml_make_vect(int a1, unsigned int a2)
{
  int v2; // edi
  unsigned int v3; // esi
  unsigned __int64 v4; // rax
  int v5; // eax
  unsigned int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // esi
  int v10; // eax
  unsigned int i; // ebx
  int v13; // [esp+4h] [ebp-84h]
  unsigned int v14; // [esp+8h] [ebp-80h]
  int v15; // [esp+Ch] [ebp-7Ch]
  _DWORD *v16; // [esp+10h] [ebp-78h]
  double v17; // [esp+18h] [ebp-70h]
  int v18[8]; // [esp+2Ch] [ebp-5Ch] BYREF
  double *v19; // [esp+4Ch] [ebp-3Ch] BYREF
  int v20[14]; // [esp+50h] [ebp-38h] BYREF

  v2 = caml_local_roots;
  v19 = 0;
  v18[0] = (int)v20;
  caml_local_roots = (int)v18;
  v18[2] = 1;
  v18[1] = 1;
  v18[3] = (int)&v19;
  v3 = a1 >> 1;
  if ( a1 >> 1 )
  {
    v20[0] = v2;
    v20[2] = 1;
    v20[1] = 2;
    v20[3] = (int)&a1;
    v20[4] = (int)&a2;
    LODWORD(v4) = a2;
    HIDWORD(v4) = a2 & 1;
    if ( (a2 & 1) == 0
      && (*(_BYTE *)(caml_page_table[a2 >> 23] + ((a2 >> 12) & 0x7FF)) & 7) != 0
      && *(_BYTE *)(a2 - 4) == 0xFD )
    {
      v17 = *(double *)a2;
      v5 = 2 * v3;
      if ( 2 * v3 > 0x3FFFFF )
        v5 = caml_invalid_argument("Array.make", v13, v14, v15, v16);
      v19 = (double *)caml_alloc(v5, 0xFEu);
      v6 = 0;
      do
        v19[v6++] = v17;
      while ( v3 > v6 );
    }
    else
    {
      if ( v3 > 0x3FFFFF )
        LODWORD(v4) = caml_invalid_argument("Array.make", v13, v14, v15, v16);
      if ( v3 > 0xFF )
      {
        if ( v4 >= (unsigned int)caml_young_end || (unsigned int)v4 <= caml_young_start )
        {
          v19 = (double *)caml_alloc_shr(v3, 0);
          for ( i = 0; i < v3; ++i )
            caml_initialize((unsigned int *)v19 + i, a2);
        }
        else
        {
          caml_minor_collection();
          v19 = (double *)caml_alloc_shr(v3, 0);
          v9 = 4 * v3;
          v10 = 0;
          do
          {
            *(_DWORD *)((char *)v19 + v10) = a2;
            v10 += 4;
          }
          while ( v10 != v9 );
        }
        v19 = (double *)caml_check_urgent_gc((int)v19);
      }
      else
      {
        v19 = (double *)caml_alloc_small(v3, 0);
        v7 = 4 * v3;
        v8 = 0;
        do
        {
          *(_DWORD *)((char *)v19 + v8) = a2;
          v8 += 4;
        }
        while ( v8 != v7 );
      }
    }
  }
  else
  {
    v19 = (double *)&unk_807AF64;
  }
  caml_local_roots = v2;
  return v19;
}
// 80627A7: variable 'v13' is possibly undefined
// 80627A7: variable 'v14' is possibly undefined
// 80627A7: variable 'v15' is possibly undefined
// 80627A7: variable 'v16' is possibly undefined
// 8062830: variable 'v4' is possibly undefined
// 8074754: using guessed type int caml_local_roots;
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;

//----- (080628D1) --------------------------------------------------------
int __cdecl caml_array_unsafe_set_addr(int a1, int a2, unsigned int a3)
{
  unsigned int *v3; // ebx
  unsigned int v4; // edi
  int v5; // edx

  v3 = (unsigned int *)(a1 + 4 * (a2 >> 1));
  v4 = *v3;
  *v3 = a3;
  if ( (*(_BYTE *)(caml_page_table[(unsigned int)v3 >> 23] + (((unsigned int)v3 >> 12) & 0x7FF)) & 1) != 0 )
  {
    if ( !caml_gc_phase )
      caml_darken(v4);
    if ( (a3 & 1) == 0
      && a3 < caml_young_end
      && a3 > caml_young_start
      && ((v4 & 1) != 0 || caml_young_end <= v4 || caml_young_start >= v4) )
    {
      if ( dword_80778E8 >= (unsigned int)dword_80778EC )
        caml_realloc_ref_table((int)caml_ref_table);
      v5 = dword_80778E8;
      *(_DWORD *)dword_80778E8 = v3;
      dword_80778E8 = v5 + 4;
    }
  }
  return 1;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 80778E8: using guessed type int dword_80778E8;
// 80778EC: using guessed type int dword_80778EC;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0806298B) --------------------------------------------------------
int __cdecl caml_array_unsafe_set(int a1, int a2, double *a3)
{
  int result; // eax

  if ( *(_BYTE *)(a1 - 4) == 0xFE )
    result = caml_array_unsafe_set_float(a1, a2, a3);
  else
    result = caml_array_unsafe_set_addr(a1, a2, (unsigned int)a3);
  return result;
}

//----- (080629C4) --------------------------------------------------------
#error "80629DE: call analysis failed (funcsize=18)"

//----- (080629F2) --------------------------------------------------------
int __cdecl caml_array_set_addr(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // eax
  unsigned int *v5; // ebx
  unsigned int v6; // edi
  int v7; // edx
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-1Ch]
  _DWORD *v13; // [esp+10h] [ebp-18h]

  v3 = a2 >> 1;
  if ( a2 >> 1 < 0 || v3 >= *(_DWORD *)(a1 - 4) >> 10 )
    v3 = caml_array_bound_error(v9, v10, v11, v12, v13);
  v5 = (unsigned int *)(a1 + 4 * v3);
  v6 = *v5;
  *v5 = a3;
  if ( (*(_BYTE *)(caml_page_table[(unsigned int)v5 >> 23] + (((unsigned int)v5 >> 12) & 0x7FF)) & 1) != 0 )
  {
    if ( !caml_gc_phase )
      caml_darken(v6);
    if ( (a3 & 1) == 0
      && a3 < caml_young_end
      && a3 > caml_young_start
      && ((v6 & 1) != 0 || caml_young_end <= v6 || caml_young_start >= v6) )
    {
      if ( dword_80778E8 >= (unsigned int)dword_80778EC )
        caml_realloc_ref_table((int)caml_ref_table);
      v7 = dword_80778E8;
      *(_DWORD *)dword_80778E8 = v5;
      dword_80778E8 = v7 + 4;
    }
  }
  return 1;
}
// 8062A18: variable 'v9' is possibly undefined
// 8062A18: variable 'v10' is possibly undefined
// 8062A18: variable 'v11' is possibly undefined
// 8062A18: variable 'v12' is possibly undefined
// 8062A18: variable 'v13' is possibly undefined
// 8062A1D: variable 'a1' is possibly undefined
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 80778E8: using guessed type int dword_80778E8;
// 80778EC: using guessed type int dword_80778EC;
// 807B49C: using guessed type int caml_gc_phase;

//----- (08062ABD) --------------------------------------------------------
int __cdecl caml_array_set(int a1, int a2, unsigned int a3)
{
  int result; // eax

  if ( *(_BYTE *)(a1 - 4) == 0xFE )
    result = caml_array_set_float(a1, a2, a3);
  else
    result = caml_array_set_addr(a1, a2, a3);
  return result;
}
// 80629C4: using guessed type _DWORD __cdecl caml_array_set_float(_DWORD, _DWORD, _DWORD);

//----- (08062AF6) --------------------------------------------------------
int __cdecl caml_array_get_float(int a1, int a2)
{
  unsigned int v2; // eax
  int v4; // edx
  int result; // eax
  int v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-10h]
  double v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]
  _DWORD *v11; // [esp+10h] [ebp-8h]

  v2 = a2 >> 1;
  if ( a2 >> 1 < 0 || v2 >= *(_DWORD *)(a1 - 4) >> 11 )
    v2 = caml_array_bound_error(v6, v7, v8, v10, v11);
  v9 = *(double *)(a1 + 8 * v2);
  v4 = caml_young_ptr;
  caml_young_ptr -= 12;
  if ( caml_young_ptr < (unsigned int)caml_young_limit )
  {
    caml_young_ptr = v4;
    caml_minor_collection();
    caml_young_ptr -= 12;
  }
  *(_DWORD *)caml_young_ptr = 3069;
  result = caml_young_ptr + 4;
  *(double *)(caml_young_ptr + 4) = v9;
  return result;
}
// 8062B10: variable 'v6' is possibly undefined
// 8062B10: variable 'v7' is possibly undefined
// 8062B10: variable 'v8' is possibly undefined
// 8062B10: variable 'v10' is possibly undefined
// 8062B10: variable 'v11' is possibly undefined
// 8062B15: variable 'a1' is possibly undefined
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (08062B5D) --------------------------------------------------------
#error "8062B77: call analysis failed (funcsize=15)"

//----- (08062B81) --------------------------------------------------------
int __cdecl caml_array_get(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 - 4) == 0xFE )
    result = caml_array_get_float(a1, a2);
  else
    result = caml_array_get_addr(a1, a2);
  return result;
}
// 8062B5D: using guessed type _DWORD __cdecl caml_array_get_addr(_DWORD, _DWORD);

//----- (08062BB0) --------------------------------------------------------
int __usercall unlink_channel@<eax>(int result@<eax>)
{
  int v1; // edx
  int v2; // edx

  v1 = *(_DWORD *)(result + 32);
  if ( v1 )
  {
    *(_DWORD *)(v1 + 28) = *(_DWORD *)(result + 28);
    v2 = *(_DWORD *)(result + 28);
    if ( v2 )
    {
      result = *(_DWORD *)(result + 32);
      *(_DWORD *)(v2 + 32) = result;
    }
  }
  else
  {
    result = *(_DWORD *)(caml_all_opened_channels + 28);
    caml_all_opened_channels = result;
    if ( result )
      *(_DWORD *)(result + 32) = 0;
  }
  return result;
}
// 8078D34: using guessed type int caml_all_opened_channels;

//----- (08062BE9) --------------------------------------------------------
int caml_channel_binary_mode()
{
  return 1;
}

//----- (08062BF3) --------------------------------------------------------
__int64 __cdecl caml_pos_out(int a1)
{
  return *(_DWORD *)(a1 + 16) - (a1 + 52) + *(_QWORD *)(a1 + 4);
}

//----- (08062C14) --------------------------------------------------------
__int64 __cdecl caml_pos_in(int a1)
{
  return *(_QWORD *)(a1 + 4) - (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
}

//----- (08062C46) --------------------------------------------------------
int __cdecl compare_channel(int a1, int a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  int result; // eax

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  result = 0;
  if ( v2 != v3 )
    result = v2 < v3 ? -1 : 1;
  return result;
}

//----- (08062C67) --------------------------------------------------------
int caml_ml_set_binary_mode()
{
  return 1;
}

//----- (08062C71) --------------------------------------------------------
int *__cdecl caml_ml_pos_in_64(int a1)
{
  __int64 v1; // rax

  v1 = caml_pos_in(*(_DWORD *)(a1 + 4));
  return caml_copy_int64(v1, SHIDWORD(v1));
}

//----- (08062C93) --------------------------------------------------------
int *__cdecl caml_ml_pos_out_64(int a1)
{
  __int64 v1; // rax

  v1 = caml_pos_out(*(_DWORD *)(a1 + 4));
  return caml_copy_int64(v1, SHIDWORD(v1));
}

//----- (08062CB5) --------------------------------------------------------
int __cdecl caml_ml_pos_in(int a1)
{
  __int64 v1; // rax
  int v2; // ebx

  v1 = caml_pos_in(*(_DWORD *)(a1 + 4));
  v2 = v1;
  if ( v1 > 0x3FFFFFFF )
  {
    *__errno_location() = 75;
    caml_sys_error((void *)1);
  }
  return 2 * v2 + 1;
}

//----- (08062CFC) --------------------------------------------------------
int __cdecl caml_ml_pos_out(int a1)
{
  __int64 v1; // rax
  int v2; // ebx

  v1 = caml_pos_out(*(_DWORD *)(a1 + 4));
  v2 = v1;
  if ( v1 > 0x3FFFFFFF )
  {
    *__errno_location() = 75;
    caml_sys_error((void *)1);
  }
  return 2 * v2 + 1;
}

//----- (08062D43) --------------------------------------------------------
int __cdecl caml_channel_descriptor(int a1)
{
  int v1; // ebx

  v1 = **(_DWORD **)(a1 + 4);
  if ( v1 == -1 )
  {
    *__errno_location() = 9;
    caml_sys_error((void *)1);
  }
  return 2 * v1 + 1;
}

//----- (08062D78) --------------------------------------------------------
int __cdecl caml_ml_close_channel(int a1)
{
  int *v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // ebx
  int v6; // edx

  v1 = *(int **)(a1 + 4);
  v2 = *v1;
  if ( *v1 == -1 )
  {
    v6 = v1[3];
    v1[5] = v6;
    v1[4] = v6;
  }
  else
  {
    *v1 = -1;
    v3 = v1[3];
    v1[5] = v3;
    v1[4] = v3;
    caml_enter_blocking_section();
    v4 = close(v2);
    caml_leave_blocking_section();
    if ( v4 == -1 )
      caml_sys_error((void *)1);
  }
  return 1;
}

//----- (08062DD6) --------------------------------------------------------
int *__cdecl caml_alloc_channel(int a1)
{
  int *result; // eax

  ++*(_DWORD *)(a1 + 44);
  result = caml_alloc_custom((int)&channel_operations, 4, 1u, 0x3E8u);
  result[1] = a1;
  return result;
}
// 8074510: using guessed type char *channel_operations;

//----- (08062E11) --------------------------------------------------------
int caml_ml_out_channels_list()
{
  int v0; // esi
  int v1; // ebx
  int v3[8]; // [esp+14h] [ebp-34h] BYREF
  int *v4; // [esp+34h] [ebp-14h] BYREF
  int v5; // [esp+38h] [ebp-10h] BYREF
  int v6; // [esp+3Ch] [ebp-Ch] BYREF

  v0 = caml_local_roots;
  caml_local_roots = (int)v3;
  v6 = 1;
  v1 = caml_all_opened_channels;
  if ( caml_all_opened_channels )
  {
    v5 = 0;
    v4 = 0;
    v3[0] = v0;
    v3[2] = 1;
    v3[1] = 3;
    v3[3] = (int)&v6;
    v3[4] = (int)&v5;
    v3[5] = (int)&v4;
    do
    {
      if ( !*(_DWORD *)(v1 + 20) )
      {
        v4 = caml_alloc_channel(v1);
        v5 = v6;
        v6 = caml_alloc_small(2, 0);
        *(_DWORD *)v6 = v4;
        *(_DWORD *)(v6 + 4) = v5;
      }
      v1 = *(_DWORD *)(v1 + 28);
    }
    while ( v1 );
  }
  caml_local_roots = v0;
  return v6;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D34: using guessed type int caml_all_opened_channels;

//----- (08062EBC) --------------------------------------------------------
void __cdecl caml_finalize_channel(int a1)
{
  _DWORD *v1; // ebx
  int v2; // eax

  v1 = *(_DWORD **)(a1 + 4);
  v2 = v1[11] - 1;
  v1[11] = v2;
  if ( v2 <= 0 )
  {
    if ( caml_channel_mutex_free )
      caml_channel_mutex_free(v1);
    unlink_channel((int)v1);
    caml_stat_free(v1);
  }
}
// 8078D24: using guessed type int (__cdecl *caml_channel_mutex_free)(_DWORD);

//----- (08062EF9) --------------------------------------------------------
void __cdecl caml_close_channel(void *ptr)
{
  close(*(_DWORD *)ptr);
  if ( *((int *)ptr + 11) <= 0 )
  {
    if ( caml_channel_mutex_free )
      caml_channel_mutex_free(ptr);
    unlink_channel((int)ptr);
    caml_stat_free(ptr);
  }
}
// 8078D24: using guessed type int (__cdecl *caml_channel_mutex_free)(_DWORD);

//----- (08062F36) --------------------------------------------------------
int __cdecl caml_seek_in(int a1, __int64 a2)
{
  int result; // eax
  __int64 v3; // [esp+18h] [ebp-30h]
  int v4; // [esp+24h] [ebp-24h]

  v3 = *(_QWORD *)(a1 + 4);
  v4 = *(_DWORD *)(a1 + 20);
  if ( v3 - (v4 - (a1 + 52)) > a2 || v3 < a2 )
  {
    caml_enter_blocking_section();
    if ( a2 != lseek64(*(_DWORD *)a1, a2, HIDWORD(a2), 0) )
    {
      caml_leave_blocking_section();
      caml_sys_error((void *)1);
    }
    caml_leave_blocking_section();
    *(_QWORD *)(a1 + 4) = a2;
    result = a1 + 52;
    *(_DWORD *)(a1 + 20) = a1 + 52;
    *(_DWORD *)(a1 + 16) = a1 + 52;
  }
  else
  {
    result = v4 + a2 - v3;
    *(_DWORD *)(a1 + 16) = result;
  }
  return result;
}
// 804A844: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08063001) --------------------------------------------------------
int __cdecl caml_ml_seek_in_64(int a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v5[10]; // [esp+10h] [ebp-28h] BYREF

  v2 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 2;
  v5[3] = (int)&a1;
  v5[4] = (int)&a2;
  v3 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  caml_seek_in(v3, *(_QWORD *)(a2 + 4));
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063081) --------------------------------------------------------
int __cdecl caml_ml_seek_in(int a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v5[10]; // [esp+10h] [ebp-28h] BYREF

  v2 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 2;
  v5[3] = (int)&a1;
  v5[4] = (int)&a2;
  v3 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  caml_seek_in(v3, a2 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063102) --------------------------------------------------------
int __cdecl caml_channel_size(int *a1)
{
  int v1; // ebx
  __int64 v2; // kr00_8
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]

  v1 = *a1;
  v5 = a1[1];
  v4 = a1[2];
  caml_enter_blocking_section();
  v2 = lseek64(v1, 0, 0, 2);
  if ( (HIDWORD(v2) & (unsigned int)v2) == -1 || lseek64(v1, v5, v4, 0) != __PAIR64__(v4, v5) )
  {
    caml_leave_blocking_section();
    caml_sys_error((void *)1);
  }
  caml_leave_blocking_section();
  return v2;
}
// 804A844: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080631A1) --------------------------------------------------------
int *__cdecl caml_ml_channel_size_64(int a1)
{
  int v1; // eax
  int v2; // edx

  v1 = caml_channel_size(*(int **)(a1 + 4));
  return caml_copy_int64(v1, v2);
}
// 80631BC: variable 'v2' is possibly undefined

//----- (080631C3) --------------------------------------------------------
int __cdecl caml_ml_channel_size(int a1)
{
  __int64 v1; // rax
  int v2; // ebx

  LODWORD(v1) = caml_channel_size(*(int **)(a1 + 4));
  v2 = v1;
  if ( v1 > 0x3FFFFFFF )
  {
    *__errno_location() = 75;
    caml_sys_error((void *)1);
  }
  return 2 * v2 + 1;
}
// 80631E7: variable 'v1' is possibly undefined

//----- (0806320A) --------------------------------------------------------
ssize_t __cdecl caml_do_read(int fd, void *buf, size_t nbytes)
{
  ssize_t v3; // ebx

  while ( 1 )
  {
    caml_enter_blocking_section();
    v3 = read(fd, buf, nbytes);
    caml_leave_blocking_section();
    if ( v3 != -1 )
      break;
    if ( *__errno_location() != 4 )
    {
      caml_sys_io_error((void *)1);
      return v3;
    }
  }
  return v3;
}

//----- (0806325D) --------------------------------------------------------
int __cdecl caml_ml_input(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  int v5; // ebx
  const void *v6; // eax
  int v7; // esi
  int v9; // [esp+18h] [ebp-40h]
  int n; // [esp+1Ch] [ebp-3Ch]
  int v11[14]; // [esp+20h] [ebp-38h] BYREF

  v4 = caml_local_roots;
  v11[0] = caml_local_roots;
  caml_local_roots = (int)v11;
  v11[2] = 1;
  v11[1] = 4;
  v11[3] = (int)&a1;
  v11[4] = (int)&a2;
  v11[5] = (int)&a3;
  v11[6] = (int)&a4;
  v5 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  v9 = a3 >> 1;
  n = a4 >> 1;
  v6 = *(const void **)(v5 + 16);
  v7 = *(_DWORD *)(v5 + 20) - (_DWORD)v6;
  if ( a4 >> 1 > v7 )
  {
    if ( v7 <= 0 )
    {
      v7 = caml_do_read(*(_DWORD *)v5, (void *)(v5 + 52), *(_DWORD *)(v5 + 12) - (v5 + 52));
      *(_QWORD *)(v5 + 4) += v7;
      *(_DWORD *)(v5 + 20) = v5 + v7 + 52;
      if ( v7 > n )
        v7 = n;
      memmove((void *)(a2 + v9), (const void *)(v5 + 52), v7);
      *(_DWORD *)(v5 + 16) = v5 + v7 + 52;
    }
    else
    {
      memmove((void *)(a2 + v9), v6, *(_DWORD *)(v5 + 20) - (_DWORD)v6);
      *(_DWORD *)(v5 + 16) += v7;
    }
  }
  else
  {
    memmove((void *)(a2 + v9), v6, n);
    *(_DWORD *)(v5 + 16) += n;
    v7 = n;
  }
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v5);
  caml_local_roots = v4;
  return 2 * v7 + 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063388) --------------------------------------------------------
int __cdecl caml_input_scan_line(int a1)
{
  char *v1; // esi
  unsigned int v2; // eax
  const void *v3; // edx
  int v4; // eax
  void *v5; // edx
  unsigned int v6; // eax
  ssize_t v8; // eax
  char v9; // al
  int v10; // [esp+1Ch] [ebp-1Ch]

  v1 = *(char **)(a1 + 16);
  v10 = a1 + 52;
  do
  {
    v2 = *(_DWORD *)(a1 + 20);
    if ( (unsigned int)v1 >= v2 )
    {
      v3 = *(const void **)(a1 + 16);
      if ( (unsigned int)v3 > a1 + 52 )
      {
        memmove((void *)(a1 + 52), v3, v2 - (_DWORD)v3);
        v4 = v10 - *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v10;
        *(_DWORD *)(a1 + 20) += v4;
        v1 += v4;
      }
      v5 = *(void **)(a1 + 20);
      v6 = *(_DWORD *)(a1 + 12);
      if ( (unsigned int)v5 >= v6 )
        return *(_DWORD *)(a1 + 16) - (_DWORD)v5;
      v8 = caml_do_read(*(_DWORD *)a1, v5, v6 - (_DWORD)v5);
      if ( !v8 )
        return *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 20);
      *(_QWORD *)(a1 + 4) += v8;
      *(_DWORD *)(a1 + 20) += v8;
    }
    v9 = *v1++;
  }
  while ( v9 != 10 );
  return (int)&v1[-*(_DWORD *)(a1 + 16)];
}

//----- (0806342A) --------------------------------------------------------
int __cdecl caml_ml_input_scan_line(int a1)
{
  int v1; // esi
  int v2; // ebx
  int v3; // edi
  int v5[11]; // [esp+10h] [ebp-38h] BYREF

  v1 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 1;
  v5[3] = (int)&a1;
  v2 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  v3 = caml_input_scan_line(v2);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v1;
  return 2 * v3 + 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (080634A1) --------------------------------------------------------
int __cdecl caml_getblock(int a1, void *dest, size_t n)
{
  const void *v3; // eax
  int v4; // esi
  ssize_t v5; // eax

  v3 = *(const void **)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 20) - (_DWORD)v3;
  if ( (int)n > v4 )
  {
    if ( v4 <= 0 )
    {
      v5 = caml_do_read(*(_DWORD *)a1, (void *)(a1 + 52), *(_DWORD *)(a1 + 12) - (a1 + 52));
      *(_QWORD *)(a1 + 4) += v5;
      *(_DWORD *)(a1 + 20) = a1 + v5 + 52;
      v4 = n;
      if ( v5 <= (int)n )
        v4 = v5;
      memmove(dest, (const void *)(a1 + 52), v4);
      *(_DWORD *)(a1 + 16) = a1 + v4 + 52;
    }
    else
    {
      memmove(dest, v3, *(_DWORD *)(a1 + 20) - (_DWORD)v3);
      *(_DWORD *)(a1 + 16) += v4;
    }
  }
  else
  {
    memmove(dest, v3, n);
    *(_DWORD *)(a1 + 16) += n;
    v4 = n;
  }
  return v4;
}

//----- (0806355E) --------------------------------------------------------
_BOOL4 __cdecl caml_really_getblock(int a1, void *dest, size_t n)
{
  int v4; // ebx
  int v5; // eax

  v4 = n;
  if ( (int)n > 0 )
  {
    while ( 1 )
    {
      v5 = caml_getblock(a1, dest, v4);
      if ( !v5 )
        break;
      v4 -= v5;
      if ( v4 <= 0 )
        break;
      dest = (char *)dest + v5;
    }
  }
  return v4 == 0;
}

//----- (080635A2) --------------------------------------------------------
int __cdecl caml_refill(int a1)
{
  ssize_t v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = caml_do_read(*(_DWORD *)a1, (void *)(a1 + 52), *(_DWORD *)(a1 + 12) - (a1 + 52));
  if ( !v1 )
    v1 = caml_raise_end_of_file(v3, v4, v5, v6, v7);
  *(_QWORD *)(a1 + 4) += v1;
  *(_DWORD *)(a1 + 20) = a1 + v1 + 52;
  *(_DWORD *)(a1 + 16) = a1 + 53;
  return *(unsigned __int8 *)(a1 + 52);
}
// 80635CA: variable 'v3' is possibly undefined
// 80635CA: variable 'v4' is possibly undefined
// 80635CA: variable 'v5' is possibly undefined
// 80635CA: variable 'v6' is possibly undefined
// 80635CA: variable 'v7' is possibly undefined

//----- (080635F1) --------------------------------------------------------
int __cdecl caml_ml_input_char(int a1)
{
  int v1; // esi
  int v2; // ebx
  unsigned __int8 *v3; // eax
  unsigned __int8 v4; // di
  int v6[11]; // [esp+10h] [ebp-38h] BYREF

  v1 = caml_local_roots;
  v6[0] = caml_local_roots;
  caml_local_roots = (int)v6;
  v6[2] = 1;
  v6[1] = 1;
  v6[3] = (int)&a1;
  v2 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  v3 = *(unsigned __int8 **)(v2 + 16);
  if ( (unsigned int)v3 < *(_DWORD *)(v2 + 20) )
  {
    v4 = *v3;
    *(_DWORD *)(v2 + 16) = v3 + 1;
  }
  else
  {
    v4 = caml_refill(v2);
  }
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v1;
  return 2 * v4 + 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063681) --------------------------------------------------------
int __cdecl caml_getword(int a1)
{
  int v1; // edi
  int i; // esi
  unsigned __int8 *v3; // edx
  int v4; // eax
  int v6; // [esp+4h] [ebp-24h]
  unsigned int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  _DWORD *v9; // [esp+10h] [ebp-18h]

  if ( !caml_channel_binary_mode() )
    caml_failwith("input_binary_int: not a binary channel", v6, v7, v8, v9);
  v1 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v3 = *(unsigned __int8 **)(a1 + 16);
    if ( (unsigned int)v3 < *(_DWORD *)(a1 + 20) )
    {
      v4 = *v3;
      *(_DWORD *)(a1 + 16) = v3 + 1;
    }
    else
    {
      v4 = (unsigned __int8)caml_refill(a1);
    }
    v1 = v4 + (v1 << 8);
  }
  return v1;
}
// 80636A0: variable 'v6' is possibly undefined
// 80636A0: variable 'v7' is possibly undefined
// 80636A0: variable 'v8' is possibly undefined
// 80636A0: variable 'v9' is possibly undefined

//----- (080636E5) --------------------------------------------------------
int __cdecl caml_ml_input_int(int a1)
{
  int v1; // esi
  int v2; // ebx
  int v3; // edi
  int v5[11]; // [esp+10h] [ebp-38h] BYREF

  v1 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 1;
  v5[3] = (int)&a1;
  v2 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  v3 = caml_getword(v2);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v1;
  return 2 * v3 + 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (0806375C) --------------------------------------------------------
ssize_t __usercall do_write@<eax>(size_t n@<ecx>, int a2@<eax>, const void *a3@<edx>)
{
  ssize_t v5; // ebx
  int v6; // eax

  while ( 1 )
  {
    caml_enter_blocking_section();
    v5 = write(a2, a3, n);
    caml_leave_blocking_section();
    if ( v5 != -1 )
      break;
    v6 = *__errno_location();
    if ( v6 != 4 )
    {
      if ( v6 != 11 || (int)n <= 1 )
      {
        caml_sys_io_error((void *)1);
        return v5;
      }
      n = 1;
    }
  }
  return v5;
}

//----- (080637C3) --------------------------------------------------------
size_t __cdecl caml_putblock(int a1, void *src, size_t n)
{
  void *v3; // eax
  signed int v4; // esi
  size_t result; // eax
  ssize_t v6; // eax
  ssize_t v7; // edi
  signed int v8; // [esp+18h] [ebp-20h]

  v3 = *(void **)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 12) - (_DWORD)v3;
  if ( (int)n >= v4 )
  {
    memmove(v3, src, *(_DWORD *)(a1 + 12) - (_DWORD)v3);
    v8 = *(_DWORD *)(a1 + 12) - (a1 + 52);
    v6 = do_write(v8, *(_DWORD *)a1, (const void *)(a1 + 52));
    v7 = v6;
    if ( v8 > v6 )
      memmove((void *)(a1 + 52), (const void *)(v6 + a1 + 52), v8 - v6);
    *(_QWORD *)(a1 + 4) += v7;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 12) - v7;
    result = v4;
  }
  else
  {
    memmove(v3, src, n);
    *(_DWORD *)(a1 + 16) += n;
    result = n;
  }
  return result;
}

//----- (0806386F) --------------------------------------------------------
int __cdecl caml_ml_output(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  int v5; // esi
  int v6; // ebx
  int v7; // esi
  size_t v8; // eax
  int v10; // [esp+1Ch] [ebp-3Ch]
  int v11[14]; // [esp+20h] [ebp-38h] BYREF

  v10 = caml_local_roots;
  v11[0] = caml_local_roots;
  caml_local_roots = (int)v11;
  v11[2] = 1;
  v11[1] = 4;
  v11[3] = (int)&a1;
  v11[4] = (int)&a2;
  v11[5] = (int)&a3;
  v11[6] = (int)&a4;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = a3;
  v6 = a4 >> 1;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v4);
  if ( v6 > 0 )
  {
    v7 = v5 >> 1;
    do
    {
      v8 = caml_putblock(v4, (void *)(a2 + v7), v6);
      v7 += v8;
      v6 -= v8;
    }
    while ( v6 > 0 );
  }
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v4);
  caml_local_roots = v10;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063913) --------------------------------------------------------
int __cdecl caml_ml_output_partial(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // ebx
  size_t v6; // edi
  int v8[11]; // [esp+10h] [ebp-38h] BYREF

  v4 = caml_local_roots;
  v8[0] = caml_local_roots;
  caml_local_roots = (int)v8;
  v8[2] = 1;
  v8[1] = 4;
  v8[3] = (int)&a1;
  v8[4] = (int)&a2;
  v8[5] = (int)&a3;
  v8[6] = (int)&a4;
  v5 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  v6 = caml_putblock(v5, (void *)(a2 + (a3 >> 1)), a4 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v5);
  caml_local_roots = v4;
  return 2 * v6 + 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (080639B1) --------------------------------------------------------
void __cdecl caml_really_putblock(int a1, void *src, size_t n)
{
  int i; // ebx
  size_t v5; // eax

  for ( i = n; i > 0; i -= v5 )
  {
    v5 = caml_putblock(a1, src, i);
    src = (char *)src + v5;
  }
}

//----- (080639E7) --------------------------------------------------------
_BOOL4 __cdecl caml_flush_partial(int a1)
{
  int v1; // esi
  ssize_t v2; // edi

  v1 = *(_DWORD *)(a1 + 16) - (a1 + 52);
  if ( v1 > 0 )
  {
    v2 = do_write(*(_DWORD *)(a1 + 16) - (a1 + 52), *(_DWORD *)a1, (const void *)(a1 + 52));
    *(_QWORD *)(a1 + 4) += v2;
    if ( v1 > v2 )
      memmove((void *)(a1 + 52), (const void *)(v2 + a1 + 52), v1 - v2);
    *(_DWORD *)(a1 + 16) -= v2;
  }
  return *(_DWORD *)(a1 + 16) == a1 + 52;
}

//----- (08063A5A) --------------------------------------------------------
int __cdecl caml_ml_output_char(int a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  _BYTE *v4; // eax
  int v6[10]; // [esp+10h] [ebp-28h] BYREF

  v2 = caml_local_roots;
  v6[0] = caml_local_roots;
  caml_local_roots = (int)v6;
  v6[2] = 1;
  v6[1] = 2;
  v6[3] = (int)&a1;
  v6[4] = (int)&a2;
  v3 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  if ( *(_DWORD *)(v3 + 16) >= *(_DWORD *)(v3 + 12) )
    caml_flush_partial(v3);
  v4 = *(_BYTE **)(v3 + 16);
  *v4 = a2 >> 1;
  *(_DWORD *)(v3 + 16) = v4 + 1;
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063AE1) --------------------------------------------------------
int __cdecl caml_ml_flush_partial(int a1)
{
  int v1; // esi
  _DWORD *v2; // ebx
  int result; // eax
  _BOOL4 v4; // edi
  int v5[11]; // [esp+10h] [ebp-38h] BYREF

  v1 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 1;
  v5[3] = (int)&a1;
  v2 = *(_DWORD **)(a1 + 4);
  if ( *v2 == -1 )
  {
    caml_local_roots = v1;
    result = 3;
  }
  else
  {
    if ( caml_channel_mutex_lock )
      caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
    v4 = caml_flush_partial((int)v2);
    if ( caml_channel_mutex_unlock )
      caml_channel_mutex_unlock(v2);
    caml_local_roots = v1;
    result = !v4 ? 1 : 3;
  }
  return result;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063B71) --------------------------------------------------------
_BYTE *__cdecl caml_putword(int a1, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *result; // eax
  int v7; // [esp+4h] [ebp-14h]
  unsigned int v8; // [esp+8h] [ebp-10h]
  int v9; // [esp+Ch] [ebp-Ch]
  _DWORD *v10; // [esp+10h] [ebp-8h]

  if ( !caml_channel_binary_mode() )
    caml_failwith("output_binary_int: not a binary channel", v7, v8, v9, v10);
  if ( *(_DWORD *)(a1 + 16) >= *(_DWORD *)(a1 + 12) )
    caml_flush_partial(a1);
  v2 = *(_BYTE **)(a1 + 16);
  *v2++ = HIBYTE(a2);
  *(_DWORD *)(a1 + 16) = v2;
  if ( (unsigned int)v2 >= *(_DWORD *)(a1 + 12) )
    caml_flush_partial(a1);
  v3 = *(_BYTE **)(a1 + 16);
  *v3++ = BYTE2(a2);
  *(_DWORD *)(a1 + 16) = v3;
  if ( (unsigned int)v3 >= *(_DWORD *)(a1 + 12) )
    caml_flush_partial(a1);
  v4 = *(_BYTE **)(a1 + 16);
  *v4++ = BYTE1(a2);
  *(_DWORD *)(a1 + 16) = v4;
  if ( (unsigned int)v4 >= *(_DWORD *)(a1 + 12) )
    caml_flush_partial(a1);
  v5 = *(_BYTE **)(a1 + 16);
  *v5 = a2;
  result = v5 + 1;
  *(_DWORD *)(a1 + 16) = result;
  return result;
}
// 8063B92: variable 'v7' is possibly undefined
// 8063B92: variable 'v8' is possibly undefined
// 8063B92: variable 'v9' is possibly undefined
// 8063B92: variable 'v10' is possibly undefined

//----- (08063C12) --------------------------------------------------------
int __cdecl caml_ml_output_int(int a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v5[10]; // [esp+10h] [ebp-28h] BYREF

  v2 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 2;
  v5[3] = (int)&a1;
  v5[4] = (int)&a2;
  v3 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  caml_putword(v3, a2 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063C8A) --------------------------------------------------------
_BOOL4 __cdecl caml_flush(int a1)
{
  _BOOL4 result; // eax

  do
    result = caml_flush_partial(a1);
  while ( !result );
  return result;
}

//----- (08063CA6) --------------------------------------------------------
int __cdecl caml_ml_flush(int a1)
{
  int v1; // esi
  _DWORD *v2; // ebx
  int v4[10]; // [esp+10h] [ebp-28h] BYREF

  v1 = caml_local_roots;
  v4[0] = caml_local_roots;
  caml_local_roots = (int)v4;
  v4[2] = 1;
  v4[1] = 1;
  v4[3] = (int)&a1;
  v2 = *(_DWORD **)(a1 + 4);
  if ( *v2 == -1 )
  {
    caml_local_roots = v1;
  }
  else
  {
    if ( caml_channel_mutex_lock )
      caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
    caml_flush((int)v2);
    if ( caml_channel_mutex_unlock )
      caml_channel_mutex_unlock(v2);
    caml_local_roots = v1;
  }
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063D1C) --------------------------------------------------------
int __cdecl caml_seek_out(int a1, __int64 a2)
{
  int result; // eax

  caml_flush(a1);
  caml_enter_blocking_section();
  if ( a2 != lseek64(*(_DWORD *)a1, a2, HIDWORD(a2), 0) )
  {
    caml_leave_blocking_section();
    caml_sys_error((void *)1);
  }
  result = caml_leave_blocking_section();
  *(_QWORD *)(a1 + 4) = a2;
  return result;
}
// 804A844: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08063D8C) --------------------------------------------------------
int __cdecl caml_ml_seek_out_64(int a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v5[10]; // [esp+10h] [ebp-28h] BYREF

  v2 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 2;
  v5[3] = (int)&a1;
  v5[4] = (int)&a2;
  v3 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  caml_seek_out(v3, *(_QWORD *)(a2 + 4));
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063E0C) --------------------------------------------------------
int __cdecl caml_ml_seek_out(int a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v5[10]; // [esp+10h] [ebp-28h] BYREF

  v2 = caml_local_roots;
  v5[0] = caml_local_roots;
  caml_local_roots = (int)v5;
  v5[2] = 1;
  v5[1] = 2;
  v5[3] = (int)&a1;
  v5[4] = (int)&a2;
  v3 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  caml_seek_out(v3, a2 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08063E8D) --------------------------------------------------------
char *__cdecl caml_open_descriptor_in(int a1)
{
  char *v1; // ebx

  v1 = (char *)caml_stat_alloc(0x1034u);
  *(_DWORD *)v1 = a1;
  caml_enter_blocking_section();
  *(_QWORD *)(v1 + 4) = lseek64(a1, 0, 0, 1);
  caml_leave_blocking_section();
  *((_DWORD *)v1 + 5) = v1 + 52;
  *((_DWORD *)v1 + 4) = v1 + 52;
  *((_DWORD *)v1 + 3) = v1 + 4148;
  *((_DWORD *)v1 + 6) = 0;
  *((_DWORD *)v1 + 9) = 0;
  *((_DWORD *)v1 + 10) = 0;
  *((_DWORD *)v1 + 11) = 0;
  *((_DWORD *)v1 + 12) = 0;
  *((_DWORD *)v1 + 7) = caml_all_opened_channels;
  *((_DWORD *)v1 + 8) = 0;
  if ( caml_all_opened_channels )
    *(_DWORD *)(caml_all_opened_channels + 32) = v1;
  caml_all_opened_channels = (int)v1;
  return v1;
}
// 804A844: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8078D34: using guessed type int caml_all_opened_channels;

//----- (08063F37) --------------------------------------------------------
int *__cdecl caml_ml_open_descriptor_in(int a1)
{
  char *v1; // eax

  v1 = caml_open_descriptor_in(a1 >> 1);
  return caml_alloc_channel((int)v1);
}

//----- (08063F54) --------------------------------------------------------
char *__cdecl caml_open_descriptor_out(int a1)
{
  char *result; // eax

  result = caml_open_descriptor_in(a1);
  *((_DWORD *)result + 5) = 0;
  return result;
}

//----- (08063F6E) --------------------------------------------------------
int *__cdecl caml_ml_open_descriptor_out(int a1)
{
  char *v1; // eax

  v1 = caml_open_descriptor_out(a1 >> 1);
  return caml_alloc_channel((int)v1);
}

//----- (08063F90) --------------------------------------------------------
_DWORD *extern_replay_trail()
{
  unsigned int v0; // edi
  _DWORD *result; // eax
  _DWORD *v2; // edx
  char *v3; // ebx
  char *ptr; // [esp+1Ch] [ebp-1Ch]

  ptr = (char *)extern_trail_block;
  v0 = extern_trail_cur;
  while ( 1 )
  {
    result = ptr + 4;
    if ( v0 > (unsigned int)(ptr + 4) )
    {
      do
      {
        v2 = (_DWORD *)(*result & 0xFFFFFFFC);
        *(v2 - 1) = *(v2 - 1) & 0xFFFFFCFF | ((*result & 3) << 8);
        *v2 = result[1];
        result += 2;
      }
      while ( v0 > (unsigned int)result );
    }
    if ( ptr == (char *)&extern_trail_first )
      break;
    v3 = *(char **)ptr;
    free(ptr);
    v0 = (unsigned int)(v3 + 8204);
    ptr = v3;
  }
  extern_trail_block = (int)&extern_trail_first;
  extern_trail_cur = (int)&unk_8078D64;
  return result;
}
// 807AD6C: using guessed type int extern_trail_block;
// 807AD70: using guessed type int extern_trail_cur;

//----- (08064016) --------------------------------------------------------
void free_extern_output()
{
  _DWORD *v0; // eax
  _DWORD *v1; // ebx

  if ( !extern_userprovided_output )
  {
    v0 = extern_output_first;
    if ( extern_output_first )
    {
      while ( 1 )
      {
        v1 = (_DWORD *)*v0;
        free(v0);
        if ( !v1 )
          break;
        v0 = v1;
      }
    }
    extern_output_first = 0;
  }
}
// 807AD78: using guessed type int extern_userprovided_output;

//----- (08064051) --------------------------------------------------------
#error "8064061: call analysis failed (funcsize=6)"

//----- (08064066) --------------------------------------------------------
int __usercall grow_extern_output@<eax>(int a1@<eax>)
{
  int v1; // esi
  _DWORD *v2; // ebx
  int result; // eax
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  if ( extern_userprovided_output )
  {
    extern_replay_trail();
    a1 = caml_failwith("Marshal.to_buffer: buffer overflow", v4, v5, v6, v7);
  }
  *(_DWORD *)(extern_output_block + 4) = extern_ptr;
  v1 = 0;
  if ( a1 >= 4051 )
    v1 = a1;
  v2 = malloc(v1 + 8108);
  if ( !v2 )
    extern_out_of_memory();
  *(_DWORD *)extern_output_block = v2;
  extern_output_block = (int)v2;
  *v2 = 0;
  extern_ptr = v2 + 2;
  result = (int)v2 + v1 + 8108;
  extern_limit = result;
  return result;
}
// 8064083: variable 'v4' is possibly undefined
// 8064083: variable 'v5' is possibly undefined
// 8064083: variable 'v6' is possibly undefined
// 8064083: variable 'v7' is possibly undefined
// 807AD78: using guessed type int extern_userprovided_output;
// 807AD80: using guessed type int extern_limit;
// 807AD88: using guessed type int extern_output_block;

//----- (080640EB) --------------------------------------------------------
void *__cdecl caml_serialize_block_float_8(void *src, int a2)
{
  size_t v2; // ebx
  void *result; // eax

  v2 = 8 * a2;
  if ( extern_limit < (unsigned int)extern_ptr + 8 * a2 )
    grow_extern_output(8 * a2);
  result = memmove(extern_ptr, src, v2);
  extern_ptr = (char *)extern_ptr + v2;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (08064133) --------------------------------------------------------
void *__cdecl caml_serialize_float_8(int a1, int a2)
{
  int src[4]; // [esp+18h] [ebp-10h] BYREF

  src[0] = a1;
  src[1] = a2;
  return caml_serialize_block_float_8(src, 1);
}

//----- (0806415A) --------------------------------------------------------
int __cdecl caml_serialize_block_8(char *a1, int a2)
{
  int result; // eax
  char *v3; // edi
  _BYTE *v5; // eax
  char v6; // si
  char v7; // bl
  char v8; // si
  char v9; // bl
  int v10; // [esp+Ch] [ebp-2Ch]
  char *v11; // [esp+1Ch] [ebp-1Ch]

  result = 8 * a2;
  if ( extern_limit < (unsigned int)extern_ptr + 8 * a2 )
    result = grow_extern_output(result);
  v3 = (char *)extern_ptr;
  if ( a2 > 0 )
  {
    v5 = extern_ptr;
    v10 = a2;
    v11 = (char *)extern_ptr;
    do
    {
      v6 = *a1;
      v7 = a1[1];
      *v5 = a1[7];
      v5[1] = a1[6];
      v5[7] = v6;
      v5[6] = v7;
      v8 = a1[2];
      v9 = a1[3];
      v5[2] = a1[5];
      v5[3] = a1[4];
      v5[5] = v8;
      v5[4] = v9;
      a1 += 8;
      v5 += 8;
      --v10;
    }
    while ( v10 );
    result = a2;
    v3 = &v11[8 * a2];
  }
  extern_ptr = v3;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (080641FD) --------------------------------------------------------
int __cdecl caml_serialize_int_8(int a1, int a2)
{
  int v3[4]; // [esp+18h] [ebp-10h] BYREF

  v3[0] = a1;
  v3[1] = a2;
  return caml_serialize_block_8((char *)v3, 1);
}

//----- (08064224) --------------------------------------------------------
int __cdecl caml_serialize_block_4(int a1, int a2)
{
  int result; // eax
  _BYTE *v3; // edx
  int v4; // eax
  char v5; // di
  char v6; // si
  int v7; // [esp+Ch] [ebp-1Ch]

  result = 4 * a2;
  if ( extern_limit < (unsigned int)extern_ptr + 4 * a2 )
    result = grow_extern_output(result);
  v3 = extern_ptr;
  if ( a2 > 0 )
  {
    v4 = 0;
    v7 = a2;
    do
    {
      v5 = *(_BYTE *)(a1 + v4);
      v6 = *(_BYTE *)(a1 + v4 + 1);
      v3[v4] = *(_BYTE *)(a1 + v4 + 3);
      v3[v4 + 1] = *(_BYTE *)(a1 + v4 + 2);
      v3[v4 + 3] = v5;
      v3[v4 + 2] = v6;
      v4 += 4;
      --v7;
    }
    while ( v7 );
    result = a2;
    v3 += 4 * a2;
  }
  extern_ptr = v3;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (080642A5) --------------------------------------------------------
int __cdecl caml_serialize_float_4(char a1)
{
  return caml_serialize_block_4((int)&a1, 1);
}

//----- (080642C0) --------------------------------------------------------
int __cdecl caml_serialize_block_2(int a1, int a2)
{
  int result; // eax
  _BYTE *v3; // ecx
  char v4; // si
  int v5; // [esp+Ch] [ebp-2Ch]

  result = 2 * a2;
  if ( extern_limit < (unsigned int)extern_ptr + 2 * a2 )
    result = grow_extern_output(result);
  v3 = extern_ptr;
  if ( a2 > 0 )
  {
    result = 0;
    v5 = a2;
    do
    {
      v4 = *(_BYTE *)(a1 + result);
      v3[result] = *(_BYTE *)(a1 + result + 1);
      v3[result + 1] = v4;
      result += 2;
      --v5;
    }
    while ( v5 );
    v3 += 2 * a2;
  }
  extern_ptr = v3;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (0806432D) --------------------------------------------------------
void *__cdecl caml_serialize_block_1(void *src, size_t n)
{
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + n )
    grow_extern_output(n);
  result = memmove(extern_ptr, src, n);
  extern_ptr = (char *)extern_ptr + n;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (08064372) --------------------------------------------------------
void *__cdecl caml_serialize_int_4(int a1)
{
  _BYTE *v1; // eax
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + 4 )
    grow_extern_output(4);
  v1 = extern_ptr;
  *(_BYTE *)extern_ptr = HIBYTE(a1);
  v1[1] = BYTE2(a1);
  v1[2] = BYTE1(a1);
  v1[3] = a1;
  result = v1 + 4;
  extern_ptr = result;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (080643C3) --------------------------------------------------------
void *__cdecl caml_serialize_int_2(__int16 a1)
{
  char *v1; // eax
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + 2 )
    grow_extern_output(2);
  v1 = (char *)extern_ptr;
  *(_BYTE *)extern_ptr = HIBYTE(a1);
  v1[1] = a1;
  result = v1 + 2;
  extern_ptr = result;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (08064404) --------------------------------------------------------
void *__cdecl caml_serialize_int_1(char a1)
{
  char *v1; // eax
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + 1 )
    grow_extern_output(1);
  v1 = (char *)extern_ptr;
  *(_BYTE *)extern_ptr = a1;
  result = v1 + 1;
  extern_ptr = result;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (08064438) --------------------------------------------------------
void *__usercall writecode16@<eax>(char a1@<al>, __int16 a2@<dx>)
{
  char *v4; // eax
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + 3 )
    grow_extern_output(3);
  v4 = (char *)extern_ptr;
  *(_BYTE *)extern_ptr = a1;
  v4[1] = HIBYTE(a2);
  v4[2] = a2;
  result = v4 + 3;
  extern_ptr = result;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (0806448A) --------------------------------------------------------
void *__usercall writecode8@<eax>(char a1@<al>, char a2@<dl>)
{
  char *v4; // eax
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + 2 )
    grow_extern_output(2);
  v4 = (char *)extern_ptr;
  *(_BYTE *)extern_ptr = a1;
  v4[1] = a2;
  result = v4 + 2;
  extern_ptr = result;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (080644D4) --------------------------------------------------------
void *__usercall writecode32@<eax>(char a1@<al>, int a2@<edx>)
{
  _BYTE *v4; // eax
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + 5 )
    grow_extern_output(5);
  v4 = extern_ptr;
  *(_BYTE *)extern_ptr = a1;
  v4[1] = HIBYTE(a2);
  v4[2] = BYTE2(a2);
  v4[3] = BYTE1(a2);
  v4[4] = a2;
  result = v4 + 5;
  extern_ptr = result;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (08064536) --------------------------------------------------------
void *__usercall writeblock@<eax>(const void *a1@<eax>, size_t a2@<edx>)
{
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + a2 )
    grow_extern_output(a2);
  result = memmove(extern_ptr, a1, a2);
  extern_ptr = (char *)extern_ptr + a2;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (08064582) --------------------------------------------------------
void *__usercall write32@<eax>(int a1@<eax>)
{
  _BYTE *v2; // eax
  void *result; // eax

  if ( extern_limit < (unsigned int)extern_ptr + 4 )
    grow_extern_output(4);
  v2 = extern_ptr;
  *(_BYTE *)extern_ptr = HIBYTE(a1);
  v2[1] = BYTE2(a1);
  v2[2] = BYTE1(a1);
  v2[3] = a1;
  result = v2 + 4;
  extern_ptr = result;
  return result;
}
// 807AD80: using guessed type int extern_limit;

//----- (080645D2) --------------------------------------------------------
int __usercall extern_record_location@<eax>(int result@<eax>)
{
  int v1; // ebx
  _DWORD *v2; // esi
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax

  v1 = result;
  if ( !extern_ignore_sharing )
  {
    if ( extern_trail_cur == extern_trail_limit )
    {
      v2 = malloc(0x200Cu);
      if ( !v2 )
        extern_out_of_memory();
      *v2 = extern_trail_block;
      extern_trail_block = (int)v2;
      extern_trail_cur = (int)(v2 + 1);
      extern_trail_limit = (int)(v2 + 2051);
    }
    v3 = *(_DWORD *)(v1 - 4);
    v4 = extern_trail_cur;
    *(_DWORD *)extern_trail_cur = v1 | (v3 >> 8) & 3;
    *(_DWORD *)(v4 + 4) = *(_DWORD *)v1;
    extern_trail_cur = v4 + 8;
    BYTE1(v3) = BYTE1(v3) & 0xFC | 2;
    *(_DWORD *)(v1 - 4) = v3;
    v5 = obj_counter;
    *(_DWORD *)v1 = obj_counter;
    result = v5 + 1;
    obj_counter = result;
  }
  return result;
}
// 8078D40: using guessed type int obj_counter;
// 8078D4C: using guessed type int extern_ignore_sharing;
// 807AD6C: using guessed type int extern_trail_block;
// 807AD70: using guessed type int extern_trail_cur;
// 807AD74: using guessed type int extern_trail_limit;

//----- (08064672) --------------------------------------------------------
_DWORD *init_extern_output()
{
  _DWORD *v0; // eax
  _DWORD *result; // eax
  int v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  extern_userprovided_output = 0;
  v0 = malloc(0x1FACu);
  extern_output_first = v0;
  if ( !v0 )
    v0 = (_DWORD *)caml_raise_out_of_memory(v2, v3, v4, v5, v6);
  extern_output_block = (int)v0;
  *v0 = 0;
  extern_ptr = v0 + 2;
  result = v0 + 2027;
  extern_limit = (int)result;
  return result;
}
// 8064697: variable 'v2' is possibly undefined
// 8064697: variable 'v3' is possibly undefined
// 8064697: variable 'v4' is possibly undefined
// 8064697: variable 'v5' is possibly undefined
// 8064697: variable 'v6' is possibly undefined
// 807AD78: using guessed type int extern_userprovided_output;
// 807AD80: using guessed type int extern_limit;
// 807AD88: using guessed type int extern_output_block;

//----- (080646BC) --------------------------------------------------------
void *__usercall extern_invalid_argument@<eax>(void *a1@<eax>)
{
  int v2; // eax
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  extern_replay_trail();
  free_extern_output();
  v2 = caml_invalid_argument(a1, v4, v5, v6, v7);
  return extern_rec(v2);
}
// 80646D2: variable 'v4' is possibly undefined
// 80646D2: variable 'v5' is possibly undefined
// 80646D2: variable 'v6' is possibly undefined
// 80646D2: variable 'v7' is possibly undefined

//----- (080646D7) --------------------------------------------------------
void *__usercall extern_rec@<eax>(unsigned int a1@<eax>)
{
  unsigned int v2; // ebx
  char *v3; // eax
  void *result; // eax
  unsigned int v5; // esi
  unsigned int v6; // edx
  char v7; // di
  const void **v8; // eax
  char v9; // al
  char *v10; // eax
  unsigned int v11; // edx
  unsigned int v12; // eax
  size_t v13; // esi
  char *v14; // eax
  char *v15; // eax
  unsigned int v16; // esi
  const void *v17; // esi
  char *v18; // eax
  char *v19; // eax
  const void **v20; // edi
  unsigned int v21; // edi
  unsigned int v22; // ebx
  _DWORD *v23; // eax
  unsigned int v24; // [esp+3Ch] [ebp-2Ch]
  int v25; // [esp+48h] [ebp-20h] BYREF
  int v26[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  while ( 1 )
  {
    if ( (a1 & 1) != 0 )
    {
      v2 = (int)a1 >> 1;
      if ( v2 > 0x3F )
      {
        if ( v2 + 128 > 0xFF )
        {
          if ( v2 + 0x8000 > 0xFFFF )
            result = writecode32(2, v2);
          else
            result = writecode16(1, v2);
        }
        else
        {
          result = writecode8(0, v2);
        }
      }
      else
      {
        if ( (unsigned int)extern_ptr >= extern_limit )
          grow_extern_output(1);
        v3 = (char *)extern_ptr;
        *(_BYTE *)extern_ptr = v2 + 64;
        result = v3 + 1;
        extern_ptr = result;
      }
      return result;
    }
    v5 = a1;
    if ( (*(_BYTE *)(caml_page_table[a1 >> 23] + ((a1 >> 12) & 0x7FF)) & 7) == 0 )
      break;
    v6 = *(_DWORD *)(a1 - 4);
    v7 = v6;
    if ( (unsigned __int8)v6 != 250
      || (v8 = *(const void ***)a1, (*(_DWORD *)a1 & 1) == 0)
      && ((*(_BYTE *)(caml_page_table[(unsigned int)v8 >> 23] + ((*(_DWORD *)a1 >> 12) & 0x7FF)) & 7) == 0
       || (v9 = *((_BYTE *)v8 - 4), v9 == -6)
       || v9 == -10
       || v9 == -3) )
    {
      v24 = v6 >> 10;
      if ( v6 >> 10 )
      {
        if ( (*(_DWORD *)(a1 - 4) & 0x300) == 512 )
        {
          v11 = obj_counter - *(_DWORD *)a1;
          if ( v11 > 0xFF )
          {
            if ( v11 > 0xFFFF )
              result = writecode32(6, v11);
            else
              result = writecode16(5, v11);
          }
          else
          {
            result = writecode8(4, v11);
          }
        }
        else
        {
          switch ( (char)v6 )
          {
            case -7:
              writecode32(17, 4 * v24);
              result = extern_rec(a1 - 4 * v24);
              break;
            case -5:
              result = extern_invalid_argument("output_value: abstract value (Abstract)");
              break;
            case -4:
              v12 = caml_string_length(a1);
              v13 = v12;
              if ( v12 > 0x1F )
              {
                if ( v12 > 0xFF )
                  writecode32(10, v12);
                else
                  writecode8(9, v12);
              }
              else
              {
                if ( (unsigned int)extern_ptr >= extern_limit )
                  grow_extern_output(1);
                v14 = (char *)extern_ptr;
                *(_BYTE *)extern_ptr = v13 + 32;
                extern_ptr = v14 + 1;
              }
              writeblock((const void *)a1, v13);
              size_32 += ((v13 + 4) >> 2) + 1;
              size_64 += ((v13 + 8) >> 3) + 1;
              result = (void *)extern_record_location(a1);
              break;
            case -3:
              if ( (unsigned int)extern_ptr >= extern_limit )
                grow_extern_output(1);
              v15 = (char *)extern_ptr;
              *(_BYTE *)extern_ptr = 12;
              extern_ptr = v15 + 1;
              writeblock((const void *)a1, 8u);
              size_32 += 3;
              size_64 += 2;
              result = (void *)extern_record_location(a1);
              break;
            case -2:
              v16 = v6 >> 11;
              if ( v6 >> 11 > 0xFF )
                writecode32(7, v6 >> 11);
              else
                writecode8(14, v6 >> 11);
              writeblock((const void *)a1, 8 * v16);
              size_32 += 2 * v16 + 1;
              size_64 += v16 + 1;
              result = (void *)extern_record_location(a1);
              break;
            case -1:
              v17 = **(const void ***)a1;
              if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
                extern_invalid_argument("output_value: abstract value (Custom)");
              if ( (unsigned int)extern_ptr >= extern_limit )
                grow_extern_output(1);
              v18 = (char *)extern_ptr;
              *(_BYTE *)extern_ptr = 18;
              extern_ptr = v18 + 1;
              writeblock(v17, strlen((const char *)v17) + 1);
              (*(void (__cdecl **)(unsigned int, int *, int *))(*(_DWORD *)a1 + 16))(a1, v26, &v25);
              size_32 += ((unsigned int)(v26[0] + 3) >> 2) + 2;
              size_64 += ((unsigned int)(v25 + 7) >> 3) + 2;
              result = (void *)extern_record_location(a1);
              break;
            default:
              if ( (unsigned __int8)v6 > 0xFu || v24 > 7 )
              {
                BYTE1(v6) &= 0xFCu;
                writecode32(8, v6);
              }
              else
              {
                if ( (unsigned int)extern_ptr >= extern_limit )
                  grow_extern_output(1);
                v19 = (char *)extern_ptr;
                *(_BYTE *)extern_ptr = 16 * v24 + v7 + 0x80;
                extern_ptr = v19 + 1;
              }
              size_32 += v24 + 1;
              size_64 += v24 + 1;
              v20 = *(const void ***)a1;
              extern_record_location(a1);
              a1 = (unsigned int)v20;
              if ( v24 != 1 )
              {
                extern_rec((unsigned int)v20);
                v21 = v24 - 1;
                v22 = 1;
                if ( v24 - 1 > 1 )
                {
                  do
                    extern_rec(*(_DWORD *)(v5 + 4 * v22++));
                  while ( v21 > v22 );
                }
                else
                {
                  v21 = 1;
                }
                a1 = *(_DWORD *)(v5 + 4 * v21);
              }
              continue;
          }
        }
      }
      else if ( (unsigned __int8)v6 > 0xFu )
      {
        result = writecode32(8, v6);
      }
      else
      {
        if ( (unsigned int)extern_ptr >= extern_limit )
          grow_extern_output(1);
        v10 = (char *)extern_ptr;
        *(_BYTE *)extern_ptr = v7 + 0x80;
        result = v10 + 1;
        extern_ptr = result;
      }
      return result;
    }
    a1 = *(_DWORD *)a1;
  }
  if ( a1 < (unsigned int)caml_code_area_start || a1 >= caml_code_area_end )
    return extern_invalid_argument("output_value: abstract value (outside heap)");
  if ( !extern_closures )
    extern_invalid_argument("output_value: functional value");
  writecode32(16, a1 - (_DWORD)caml_code_area_start);
  v23 = caml_code_checksum();
  return writeblock(v23, 0x10u);
}
// 8078D40: using guessed type int obj_counter;
// 8078D44: using guessed type int size_32;
// 8078D48: using guessed type int size_64;
// 8078D50: using guessed type int extern_closures;
// 807AD80: using guessed type int extern_limit;
// 807AF5C: using guessed type int caml_code_area_end;

//----- (08064BCD) --------------------------------------------------------
char *__usercall extern_value@<eax>(unsigned int a1@<eax>, int *a2@<edx>)
{
  char v3; // al
  char *v4; // ebx
  _DWORD *v5; // eax

  v3 = caml_convert_flag_list(a2, (int)&extern_flags);
  extern_ignore_sharing = v3 & 1;
  extern_closures = v3 & 2;
  extern_trail_block = (int)&extern_trail_first;
  extern_trail_cur = (int)&unk_8078D64;
  extern_trail_limit = (int)&extern_trail_block;
  obj_counter = 0;
  size_32 = 0;
  size_64 = 0;
  write32(-2070567234);
  extern_ptr = (char *)extern_ptr + 16;
  extern_rec(a1);
  if ( !extern_userprovided_output )
    *(_DWORD *)(extern_output_block + 4) = extern_ptr;
  extern_replay_trail();
  if ( extern_userprovided_output )
  {
    v4 = (char *)extern_ptr - extern_userprovided_output;
    extern_ptr = (void *)(extern_userprovided_output + 4);
  }
  else
  {
    v4 = 0;
    if ( extern_output_first )
    {
      v5 = extern_output_first;
      do
      {
        v4 = &v4[v5[1] - (_DWORD)v5 - 8];
        v5 = (_DWORD *)*v5;
      }
      while ( v5 );
    }
    extern_ptr = (char *)extern_output_first + 12;
    extern_limit = (int)extern_output_first + 8108;
  }
  write32((int)(v4 - 20));
  write32(obj_counter);
  write32(size_32);
  write32(size_64);
  return v4;
}
// 8078D40: using guessed type int obj_counter;
// 8078D44: using guessed type int size_32;
// 8078D48: using guessed type int size_64;
// 8078D4C: using guessed type int extern_ignore_sharing;
// 8078D50: using guessed type int extern_closures;
// 807AD6C: using guessed type int extern_trail_block;
// 807AD70: using guessed type int extern_trail_cur;
// 807AD74: using guessed type int extern_trail_limit;
// 807AD78: using guessed type int extern_userprovided_output;
// 807AD80: using guessed type int extern_limit;
// 807AD88: using guessed type int extern_output_block;

//----- (08064CEA) --------------------------------------------------------
char *__cdecl caml_output_value_to_block(unsigned int a1, int *a2, void *a3, int a4)
{
  extern_userprovided_output = (int)a3;
  extern_ptr = a3;
  extern_limit = (int)a3 + a4;
  return extern_value(a1, a2);
}
// 807AD78: using guessed type int extern_userprovided_output;
// 807AD80: using guessed type int extern_limit;

//----- (08064D12) --------------------------------------------------------
void __cdecl caml_output_value_to_malloc(unsigned int a1, int *a2, _DWORD *a3, char **a4)
{
  char *v4; // ebx
  char *v5; // esi
  _DWORD *v6; // ebx
  size_t v7; // edi

  init_extern_output();
  v4 = extern_value(a1, a2);
  v5 = (char *)malloc((size_t)v4);
  if ( !v5 )
    extern_out_of_memory();
  *a3 = v5;
  *a4 = v4;
  v6 = extern_output_first;
  if ( extern_output_first )
  {
    do
    {
      v7 = v6[1] - (_DWORD)(v6 + 2);
      memmove(v5, v6 + 2, v7);
      v5 += v7;
      v6 = (_DWORD *)*v6;
    }
    while ( v6 );
  }
  free_extern_output();
}

//----- (08064D81) --------------------------------------------------------
int __cdecl caml_output_value_to_buffer(int a1, int a2, int a3, unsigned int a4, int *a5)
{
  extern_userprovided_output = a1 + (a2 >> 1);
  extern_ptr = (void *)(a1 + (a2 >> 1));
  extern_limit = (a3 >> 1) + extern_userprovided_output;
  return 2 * (_DWORD)extern_value(a4, a5) + 1;
}
// 807AD78: using guessed type int extern_userprovided_output;
// 807AD80: using guessed type int extern_limit;

//----- (08064DB6) --------------------------------------------------------
int __cdecl caml_output_value_to_string(unsigned int a1, int *a2)
{
  char *v2; // eax
  _DWORD *v3; // ebx
  int v4; // edi
  size_t v5; // esi
  _DWORD *v6; // esi
  int v8; // [esp+1Ch] [ebp-1Ch]

  init_extern_output();
  v2 = extern_value(a1, a2);
  v3 = extern_output_first;
  v8 = caml_alloc_string((int)v2);
  if ( v3 )
  {
    v4 = 0;
    while ( 1 )
    {
      v5 = v3[1] - (_DWORD)(v3 + 2);
      memmove((void *)(v4 + v8), v3 + 2, v5);
      v4 += v5;
      v6 = (_DWORD *)*v3;
      free(v3);
      if ( !v6 )
        break;
      v3 = v6;
    }
  }
  return v8;
}

//----- (08064E26) --------------------------------------------------------
void __cdecl caml_output_val(int a1, unsigned int a2, int *a3)
{
  _DWORD *v3; // ebx
  _DWORD *v4; // esi
  int v5; // [esp+4h] [ebp-24h]
  unsigned int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  _DWORD *v8; // [esp+10h] [ebp-18h]

  if ( !caml_channel_binary_mode() )
    caml_failwith("output_value: not a binary channel", v5, v6, v7, v8);
  init_extern_output();
  extern_value(a2, a3);
  v3 = extern_output_first;
  if ( extern_output_first )
  {
    while ( 1 )
    {
      caml_really_putblock(a1, v3 + 2, v3[1] - (_DWORD)(v3 + 2));
      v4 = (_DWORD *)*v3;
      free(v3);
      if ( !v4 )
        break;
      v3 = v4;
    }
  }
}
// 8064E45: variable 'v5' is possibly undefined
// 8064E45: variable 'v6' is possibly undefined
// 8064E45: variable 'v7' is possibly undefined
// 8064E45: variable 'v8' is possibly undefined

//----- (08064E96) --------------------------------------------------------
int __cdecl caml_output_value(int a1, unsigned int a2, int *a3)
{
  int v3; // esi
  int v4; // ebx
  int v6[10]; // [esp+10h] [ebp-28h] BYREF

  v3 = caml_local_roots;
  v6[0] = caml_local_roots;
  caml_local_roots = (int)v6;
  v6[2] = 1;
  v6[1] = 3;
  v6[3] = (int)&a1;
  v6[4] = (int)&a2;
  v6[5] = (int)&a3;
  v4 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_DWORD *)(a1 + 4));
  caml_output_val(v4, a2, a3);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v4);
  caml_local_roots = v3;
  return 1;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08064F1C) --------------------------------------------------------
int caml_deserialize_uint_1()
{
  int result; // eax

  result = *(unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 1;
  return result;
}

//----- (08064F33) --------------------------------------------------------
int caml_deserialize_sint_1()
{
  int result; // eax

  result = *(char *)intern_src;
  intern_src = (char *)intern_src + 1;
  return result;
}

//----- (08064F4A) --------------------------------------------------------
int caml_deserialize_uint_2()
{
  unsigned __int8 *v0; // edx

  v0 = (unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 2;
  return (unsigned __int8)*((char *)intern_src - 1) + (*v0 << 8);
}

//----- (08064F6A) --------------------------------------------------------
int caml_deserialize_sint_2()
{
  char *v0; // eax

  v0 = (char *)intern_src;
  intern_src = (char *)intern_src + 2;
  return (unsigned __int8)*((char *)intern_src - 1) + (*v0 << 8);
}

//----- (08064F89) --------------------------------------------------------
int caml_deserialize_uint_4()
{
  unsigned __int8 *v0; // ecx

  v0 = (unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 4;
  return ((unsigned __int8)*((char *)intern_src - 2) << 8)
       + ((unsigned __int8)*((char *)intern_src - 3) << 16)
       + (unsigned __int8)*((char *)intern_src - 1)
       + (*v0 << 24);
}

//----- (08064FBE) --------------------------------------------------------
int caml_deserialize_sint_4()
{
  unsigned __int8 *v0; // ecx

  v0 = (unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 4;
  return ((unsigned __int8)*((char *)intern_src - 2) << 8)
       + ((unsigned __int8)*((char *)intern_src - 3) << 16)
       + (unsigned __int8)*((char *)intern_src - 1)
       + (*v0 << 24);
}

//----- (08064FF3) --------------------------------------------------------
void __cdecl caml_deserialize_block_2(int a1, int a2)
{
  _BYTE *v2; // ecx
  int v3; // eax
  char v4; // si
  int v5; // [esp+0h] [ebp-14h]

  v2 = intern_src;
  if ( a2 > 0 )
  {
    v3 = 0;
    v5 = a2;
    do
    {
      v4 = v2[v3];
      *(_BYTE *)(a1 + v3) = v2[v3 + 1];
      *(_BYTE *)(a1 + v3 + 1) = v4;
      v3 += 2;
      --v5;
    }
    while ( v5 );
    v2 += 2 * a2;
  }
  intern_src = v2;
}

//----- (08065048) --------------------------------------------------------
int __usercall caml_deserialize_block_4@<eax>(int result@<eax>, int a2, int a3)
{
  _BYTE *v3; // edx
  int v4; // eax
  char v5; // di
  char v6; // si
  int v7; // [esp+0h] [ebp-10h]

  v3 = intern_src;
  if ( a3 > 0 )
  {
    v4 = 0;
    v7 = a3;
    do
    {
      v5 = v3[v4];
      v6 = v3[v4 + 1];
      *(_BYTE *)(a2 + v4) = v3[v4 + 3];
      *(_BYTE *)(a2 + v4 + 1) = v3[v4 + 2];
      *(_BYTE *)(a2 + v4 + 3) = v5;
      *(_BYTE *)(a2 + v4 + 2) = v6;
      v4 += 4;
      --v7;
    }
    while ( v7 );
    result = a3;
    v3 += 4 * a3;
  }
  intern_src = v3;
  return result;
}

//----- (080650AE) --------------------------------------------------------
long double caml_deserialize_float_4()
{
  float v1; // [esp+14h] [ebp-4h] BYREF

  caml_deserialize_block_4((int)&v1, (int)&v1, 1);
  return v1;
}

//----- (080650CC) --------------------------------------------------------
void __cdecl caml_deserialize_block_8(_BYTE *a1, int a2)
{
  char *v2; // edi
  char *v4; // eax
  char v5; // si
  char v6; // bl
  char v7; // si
  char v8; // bl
  int v9; // [esp+0h] [ebp-14h]
  char *v10; // [esp+4h] [ebp-10h]

  v2 = (char *)intern_src;
  if ( a2 > 0 )
  {
    v4 = (char *)intern_src;
    v9 = a2;
    v10 = (char *)intern_src;
    do
    {
      v5 = *v4;
      v6 = v4[1];
      *a1 = v4[7];
      a1[1] = v4[6];
      a1[7] = v5;
      a1[6] = v6;
      v7 = v4[2];
      v8 = v4[3];
      a1[2] = v4[5];
      a1[3] = v4[4];
      a1[5] = v7;
      a1[4] = v8;
      v4 += 8;
      a1 += 8;
      --v9;
    }
    while ( v9 );
    v2 = &v10[8 * a2];
  }
  intern_src = v2;
}

//----- (08065154) --------------------------------------------------------
__int64 caml_deserialize_sint_8()
{
  __int64 v1; // [esp+10h] [ebp-8h] BYREF

  caml_deserialize_block_8(&v1, 1);
  return v1;
}

//----- (08065175) --------------------------------------------------------
__int64 caml_deserialize_uint_8()
{
  __int64 v1; // [esp+10h] [ebp-8h] BYREF

  caml_deserialize_block_8(&v1, 1);
  return v1;
}

//----- (08065196) --------------------------------------------------------
int __cdecl caml_marshal_data_size(int a1, int a2)
{
  unsigned __int8 *v2; // edx
  unsigned __int8 *v3; // eax
  int v5; // [esp+4h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  v2 = (unsigned __int8 *)(a1 + (a2 >> 1));
  intern_input_malloced = 0;
  v3 = v2 + 4;
  intern_src = v2 + 4;
  if ( (v2[2] << 8) + (v2[1] << 16) + v2[3] + (*v2 << 24) != -2070567234 )
    v3 = (unsigned __int8 *)caml_failwith("Marshal.data_size: bad object", v5, v6, v7, v8);
  intern_src = v3 + 4;
  return 2 * ((v3[1] << 16) + v3[3] + (*v3 << 24) + (v3[2] << 8)) + 1;
}
// 80651E4: variable 'v5' is possibly undefined
// 80651E4: variable 'v6' is possibly undefined
// 80651E4: variable 'v7' is possibly undefined
// 80651E4: variable 'v8' is possibly undefined
// 807ADA8: using guessed type int intern_input_malloced;

//----- (08065217) --------------------------------------------------------
void intern_cleanup()
{
  if ( intern_input_malloced )
    caml_stat_free(intern_input);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  if ( intern_extra_block )
  {
    caml_free_for_heap(intern_extra_block);
  }
  else if ( intern_block )
  {
    *(_DWORD *)(intern_block - 4) = intern_header;
  }
}
// 807ADA8: using guessed type int intern_input_malloced;
// 807ADB0: using guessed type int intern_extra_block;
// 807ADC0: using guessed type int intern_header;
// 807ADC4: using guessed type int intern_block;

//----- (0806526B) --------------------------------------------------------
void *__cdecl caml_deserialize_error(void *a1, int a2)
{
  int v3; // [esp+4h] [ebp-14h]
  unsigned int v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  intern_cleanup();
  caml_failwith(a1, v3, v4, v5, v6);
  return caml_deserialize_block_float_8(a1, a2);
}
// 806527C: variable 'v3' is possibly undefined
// 806527C: variable 'v4' is possibly undefined
// 806527C: variable 'v5' is possibly undefined
// 806527C: variable 'v6' is possibly undefined

//----- (08065281) --------------------------------------------------------
void *__cdecl caml_deserialize_block_float_8(void *dest, int a2)
{
  void *result; // eax

  result = memmove(dest, intern_src, 8 * a2);
  intern_src = (char *)intern_src + 8 * a2;
  return result;
}

//----- (080652B2) --------------------------------------------------------
long double caml_deserialize_float_8()
{
  double dest[2]; // [esp+18h] [ebp-10h] BYREF

  caml_deserialize_block_float_8(dest, 1);
  return dest[0];
}

//----- (080652D0) --------------------------------------------------------
void *__cdecl caml_deserialize_block_1(void *dest, size_t n)
{
  void *result; // eax

  result = memmove(dest, intern_src, n);
  intern_src = (char *)intern_src + n;
  return result;
}

//----- (080652FE) --------------------------------------------------------
_DWORD *caml_code_checksum()
{
  int v1[24]; // [esp+18h] [ebp-60h] BYREF

  if ( !checksum_computed_3405 )
  {
    _Z8MD5_InitP12md5Context_t(v1);
    caml_MD5Update((int)v1, caml_code_area_start, caml_code_area_end - (_DWORD)caml_code_area_start);
    caml_MD5Final(checksum_3404, v1);
    checksum_computed_3405 = 1;
  }
  return checksum_3404;
}
// 807AD8C: using guessed type int checksum_computed_3405;
// 807AF5C: using guessed type int caml_code_area_end;

//----- (0806535B) --------------------------------------------------------
int __usercall intern_alloc@<eax>(int result@<eax>, int a2@<edx>)
{
  int v3; // eax
  int v4; // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  if ( result )
  {
    if ( (unsigned int)(result - 1) <= 0x3FFFFF )
    {
      if ( result == 1 )
      {
        intern_block = (int)&unk_807B354;
      }
      else if ( (unsigned int)(result - 1) > 0x100 )
      {
        intern_block = (int)caml_alloc_shr(result - 1, 252);
      }
      else
      {
        intern_block = caml_alloc_small(result - 1, 252);
      }
      result = intern_block - 4;
      intern_header = *(_DWORD *)(intern_block - 4);
      intern_color = intern_header & 0x300;
      intern_dest = intern_block - 4;
      intern_extra_block = 0;
    }
    else
    {
      v3 = caml_alloc_for_heap((4 * result + 4095) & 0xFFFFF000);
      intern_extra_block = v3;
      if ( !v3 )
        v3 = caml_raise_out_of_memory(v4, v5, v6, v7, v8);
      intern_color = caml_allocation_color(v3);
      result = intern_extra_block;
      intern_dest = intern_extra_block;
    }
    obj_counter_0 = 0;
    if ( a2 )
    {
      result = (int)caml_stat_alloc(4 * a2);
      intern_obj_table = (void *)result;
    }
    else
    {
      intern_obj_table = 0;
    }
  }
  else
  {
    intern_obj_table = 0;
    intern_extra_block = 0;
    intern_block = 0;
  }
  return result;
}
// 80653B3: variable 'v4' is possibly undefined
// 80653B3: variable 'v5' is possibly undefined
// 80653B3: variable 'v6' is possibly undefined
// 80653B3: variable 'v7' is possibly undefined
// 80653B3: variable 'v8' is possibly undefined
// 807ADAC: using guessed type int intern_dest;
// 807ADB0: using guessed type int intern_extra_block;
// 807ADB4: using guessed type int obj_counter_0;
// 807ADBC: using guessed type int intern_color;
// 807ADC0: using guessed type int intern_header;
// 807ADC4: using guessed type int intern_block;

//----- (08065470) --------------------------------------------------------
char *__usercall intern_rec@<eax>(void ***a1@<eax>)
{
  void **v1; // esi
  unsigned __int8 v2; // dl
  unsigned int v3; // ebx
  char *result; // eax
  int v5; // edx
  unsigned int v6; // ebx
  int v7; // ecx
  int v8; // edi
  unsigned int v9; // edi
  int v10; // ebx
  unsigned int v11; // eax
  void *v12; // edi
  int v13; // ecx
  int v14; // eax
  int v15; // [esp+4h] [ebp-54h]
  unsigned int v16; // [esp+8h] [ebp-50h]
  int v17; // [esp+Ch] [ebp-4Ch]
  _DWORD *v18; // [esp+10h] [ebp-48h]
  void ***v19; // [esp+18h] [ebp-40h]

  v1 = &off_806C1A4;
  while ( 1 )
  {
    v2 = *(_BYTE *)intern_src;
    v3 = v2;
    result = (char *)intern_src + 1;
    intern_src = (char *)intern_src + 1;
    if ( v2 <= 0x3Fu )
      break;
    if ( v2 <= 0x7Fu )
    {
      v1 = (void **)(2 * (v2 & 0x3F) + 1);
      goto LABEL_20;
    }
    v5 = v2 & 0xF;
    v6 = (v3 >> 4) & 7;
    if ( !v6 )
    {
      v1 = (void **)((char *)&unk_807AF64 + 4 * v5);
      goto LABEL_20;
    }
    v7 = intern_dest + 4;
    *a1 = (void **)(intern_dest + 4);
    if ( intern_obj_table )
    {
      v8 = obj_counter_0;
      *((_DWORD *)intern_obj_table + obj_counter_0) = v7;
      obj_counter_0 = v8 + 1;
    }
    a1 = (void ***)(intern_dest + 4);
    *(_DWORD *)intern_dest = (v6 << 10) + intern_color + v5;
    intern_dest += 4 * v6 + 4;
    if ( v6 > 1 )
    {
      v9 = v6;
      v19 = a1;
      do
      {
        intern_rec(v19);
        --v9;
        ++v19;
      }
      while ( v9 > 1 );
      a1 = &a1[v6 - 1];
    }
  }
  if ( v2 <= 0x1Fu )
  {
    if ( v2 <= 0x13u )
      __asm { jmp     dword ptr [esi+edx*4] }
    intern_cleanup();
    result = (char *)caml_failwith("input_value: ill-formed message", v15, v16, v17, v18);
  }
  else
  {
    v10 = v2 & 0x1F;
    v11 = (unsigned int)(v10 + 4) >> 2;
    v12 = (void *)(intern_dest + 4);
    v1 = (void **)(intern_dest + 4);
    if ( intern_obj_table )
    {
      v13 = obj_counter_0;
      *((_DWORD *)intern_obj_table + obj_counter_0) = v12;
      obj_counter_0 = v13 + 1;
    }
    *(_DWORD *)intern_dest = intern_color + (v11 << 10) + 252;
    intern_dest += 4 * v11 + 4;
    v14 = v11;
    v1[v14 - 1] = 0;
    HIBYTE(v1[v14 - 1]) = v14 * 4 - 1 - v10;
    result = (char *)memmove(v12, intern_src, v10);
    intern_src = (char *)intern_src + v10;
  }
LABEL_20:
  *a1 = v1;
  return result;
}
// 8065AC4: variable 'v15' is possibly undefined
// 8065AC4: variable 'v16' is possibly undefined
// 8065AC4: variable 'v17' is possibly undefined
// 8065AC4: variable 'v18' is possibly undefined
// 806C1A4: using guessed type void *off_806C1A4;
// 807ADAC: using guessed type int intern_dest;
// 807ADB4: using guessed type int obj_counter_0;
// 807ADBC: using guessed type int intern_color;

//----- (08065AD6) --------------------------------------------------------
int __usercall intern_add_to_heap@<eax>(int result@<eax>)
{
  unsigned int v1; // edx

  if ( intern_extra_block )
  {
    v1 = ((4 * result + 4095) & 0xFFFFF000) + intern_extra_block;
    if ( v1 > intern_dest )
      caml_make_free_blocks((int **)intern_dest, (int)(v1 - intern_dest) >> 2, 0);
    caml_allocated_words += (unsigned int)(intern_dest - intern_extra_block) >> 2;
    result = caml_add_to_heap(intern_extra_block);
  }
  return result;
}
// 807ADAC: using guessed type int intern_dest;
// 807ADB0: using guessed type int intern_extra_block;

//----- (08065B36) --------------------------------------------------------
void **input_val_from_block()
{
  int v0; // edx
  int v1; // ebx
  void **v3; // [esp+1Ch] [ebp-Ch] BYREF

  v0 = (*((unsigned __int8 *)intern_src + 2) << 8)
     + (*((unsigned __int8 *)intern_src + 1) << 16)
     + *((unsigned __int8 *)intern_src + 3)
     + (*(unsigned __int8 *)intern_src << 24);
  v1 = (*((unsigned __int8 *)intern_src + 6) << 8)
     + (*((unsigned __int8 *)intern_src + 5) << 16)
     + *((unsigned __int8 *)intern_src + 7)
     + (*((unsigned __int8 *)intern_src + 4) << 24);
  intern_src = (char *)intern_src + 12;
  intern_alloc(v1, v0);
  intern_rec(&v3);
  intern_add_to_heap(v1);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  return v3;
}

//----- (08065BC0) --------------------------------------------------------
void **__cdecl caml_input_value_from_block(unsigned __int8 *a1, unsigned int a2)
{
  unsigned __int8 *v2; // eax
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  intern_input = a1;
  intern_input_malloced = 0;
  v2 = a1 + 4;
  intern_src = a1 + 4;
  if ( (a1[2] << 8) + (a1[1] << 16) + a1[3] + (*a1 << 24) != -2070567234 )
    v2 = (unsigned __int8 *)caml_failwith("input_value_from_block: bad object", v4, v5, v6, v7);
  intern_src = v2 + 4;
  if ( v2[3] + (*v2 << 24) + 20 + (v2[1] << 16) + (v2[2] << 8) > a2 )
    caml_failwith("input_value_from_block: bad block length", v4, v5, v6, v7);
  return input_val_from_block();
}
// 8065C0F: variable 'v4' is possibly undefined
// 8065C0F: variable 'v5' is possibly undefined
// 8065C0F: variable 'v6' is possibly undefined
// 8065C0F: variable 'v7' is possibly undefined
// 807ADA8: using guessed type int intern_input_malloced;

//----- (08065C57) --------------------------------------------------------
void **__cdecl caml_input_value_from_malloc(unsigned __int8 *a1, int a2)
{
  int v2; // eax
  void **v3; // ebx
  int v5; // [esp+4h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  intern_input = a1;
  intern_input_malloced = 1;
  v2 = (int)&a1[a2 + 4];
  intern_src = (void *)v2;
  if ( (a1[a2 + 2] << 8) + (a1[a2 + 1] << 16) + a1[a2 + 3] + (a1[a2] << 24) != -2070567234 )
    v2 = caml_failwith("input_value_from_malloc: bad object", v5, v6, v7, v8);
  intern_src = (void *)(v2 + 4);
  v3 = input_val_from_block();
  caml_stat_free(intern_input);
  return v3;
}
// 8065CAA: variable 'v5' is possibly undefined
// 8065CAA: variable 'v6' is possibly undefined
// 8065CAA: variable 'v7' is possibly undefined
// 8065CAA: variable 'v8' is possibly undefined
// 807ADA8: using guessed type int intern_input_malloced;

//----- (08065CD3) --------------------------------------------------------
void **__cdecl caml_input_val_from_string(int a1, int a2)
{
  int v2; // ebx
  int v3; // edx
  int v4; // edi
  int v6[8]; // [esp+2Ch] [ebp-5Ch] BYREF
  void **v7; // [esp+4Ch] [ebp-3Ch] BYREF
  int v8[14]; // [esp+50h] [ebp-38h] BYREF

  v2 = caml_local_roots;
  v8[0] = caml_local_roots;
  v8[2] = 1;
  v8[1] = 1;
  v8[3] = (int)&a1;
  v7 = 0;
  v6[0] = (int)v8;
  caml_local_roots = (int)v6;
  v6[2] = 1;
  v6[1] = 1;
  v6[3] = (int)&v7;
  intern_input_malloced = 0;
  v3 = *(unsigned __int8 *)(a2 + a1 + 11)
     + (*(unsigned __int8 *)(a2 + a1 + 8) << 24)
     + (*(unsigned __int8 *)(a2 + a1 + 9) << 16)
     + (*(unsigned __int8 *)(a2 + a1 + 10) << 8);
  v4 = (*(unsigned __int8 *)(a2 + a1 + 14) << 8)
     + (*(unsigned __int8 *)(a2 + a1 + 12) << 24)
     + *(unsigned __int8 *)(a2 + a1 + 15)
     + (*(unsigned __int8 *)(a2 + a1 + 13) << 16);
  intern_src = (void *)(a2 + a1 + 20);
  intern_alloc(v4, v3);
  intern_src = (void *)(a2 + a1 + 20);
  intern_rec(&v7);
  intern_add_to_heap(v4);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  caml_local_roots = v2;
  return v7;
}
// 8074754: using guessed type int caml_local_roots;
// 807ADA8: using guessed type int intern_input_malloced;

//----- (08065DD2) --------------------------------------------------------
void **__cdecl caml_input_value_from_string(int a1, int a2)
{
  return caml_input_val_from_string(a1, a2 >> 1);
}

//----- (08065DEE) --------------------------------------------------------
void **__cdecl caml_input_val(int a1)
{
  int v1; // edi
  void *v2; // esi
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+4h] [ebp-44h]
  unsigned int v6; // [esp+8h] [ebp-40h]
  unsigned int v7; // [esp+8h] [ebp-40h]
  int v8; // [esp+Ch] [ebp-3Ch]
  _DWORD *v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+18h] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-2Ch]
  void **v12; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( !caml_channel_binary_mode() )
    caml_failwith("input_value: not a binary channel", v4, v6, v8, v9);
  if ( caml_getword(a1) != -2070567234 )
    caml_failwith("input_value: bad object", v4, v6, v8, v9);
  v1 = caml_getword(a1);
  v10 = caml_getword(a1);
  v11 = caml_getword(a1);
  caml_getword(a1);
  v2 = caml_stat_alloc(v1);
  if ( !caml_really_getblock(a1, v2, v1) )
  {
    caml_stat_free(v2);
    caml_failwith("input_value: truncated object", v5, v7, v8, v9);
  }
  intern_input = v2;
  intern_input_malloced = 1;
  intern_src = v2;
  intern_alloc(v11, v10);
  intern_rec(&v12);
  intern_add_to_heap(v11);
  caml_stat_free(intern_input);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  return v12;
}
// 8065E0D: variable 'v4' is possibly undefined
// 8065E0D: variable 'v6' is possibly undefined
// 8065E0D: variable 'v8' is possibly undefined
// 8065E0D: variable 'v9' is possibly undefined
// 8065E82: variable 'v5' is possibly undefined
// 8065E82: variable 'v7' is possibly undefined
// 807ADA8: using guessed type int intern_input_malloced;

//----- (08065EE1) --------------------------------------------------------
void **__cdecl caml_input_value(int a1)
{
  int v1; // esi
  int v2; // ebx
  int v4[8]; // [esp+1Ch] [ebp-4Ch] BYREF
  void **v5; // [esp+3Ch] [ebp-2Ch] BYREF
  int v6[10]; // [esp+40h] [ebp-28h] BYREF

  v1 = caml_local_roots;
  v6[0] = caml_local_roots;
  caml_local_roots = (int)v6;
  v6[2] = 1;
  v6[1] = 1;
  v6[3] = (int)&a1;
  v2 = *(_DWORD *)(a1 + 4);
  v5 = 0;
  v4[0] = (int)v6;
  caml_local_roots = (int)v4;
  v4[2] = 1;
  v4[1] = 1;
  v4[3] = (int)&v5;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v2);
  v5 = caml_input_val(v2);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v1;
  return v5;
}
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (08065F80) --------------------------------------------------------
int __cdecl caml_hash_variant(_BYTE *a1)
{
  _BYTE *v1; // edx
  int result; // eax

  v1 = a1;
  for ( result = 1; *v1; ++v1 )
    result = 2 * ((unsigned __int8)*v1 + 223 * (result >> 1)) + 1;
  return result;
}

//----- (08065FAB) --------------------------------------------------------
int __usercall hash_aux@<eax>(unsigned int a1@<eax>)
{
  int v2; // edx
  int result; // eax
  int v4; // ebx
  _DWORD *v5; // ecx
  unsigned __int8 v6; // dl
  int v7; // edx
  unsigned int v8; // ecx
  int v9; // edx
  unsigned int v10; // esi
  int (__cdecl *v11)(unsigned int); // edx
  int v12; // ebx
  int i; // esi
  unsigned int v14; // [esp+1Ch] [ebp-1Ch]

  v2 = --hash_univ_limit;
  result = hash_univ_count;
  if ( hash_univ_count >= 0 && v2 >= 0 )
  {
    if ( (a1 & 1) != 0 )
    {
LABEL_6:
      --hash_univ_count;
      result = ((int)a1 >> 1) + 65599 * hash_accu;
      hash_accu = result;
    }
    else
    {
      v4 = a1;
      if ( (*(_BYTE *)(caml_page_table[a1 >> 23] + ((a1 >> 12) & 0x7FF)) & 7) != 0 )
      {
        while ( 2 )
        {
          v5 = (_DWORD *)(v4 - 4);
          v6 = *(_BYTE *)(v4 - 4);
          switch ( v6 )
          {
            case 0xF8:
              --hash_univ_count;
              result = 65599 * hash_accu + (*(int *)(v4 + 4) >> 1);
              hash_accu = result;
              break;
            case 0xF9:
              result = hash_aux();
              break;
            case 0xFA:
              a1 = *(_DWORD *)a1;
              if ( (a1 & 1) != 0 )
                goto LABEL_6;
              v4 = a1;
              if ( (*(_BYTE *)(caml_page_table[a1 >> 23] + ((a1 >> 12) & 0x7FF)) & 7) != 0 )
                continue;
              goto LABEL_31;
            case 0xFB:
              return result;
            case 0xFC:
              --hash_univ_count;
              result = caml_string_length(a1);
              if ( result )
              {
                v7 = hash_accu;
                do
                {
                  v7 = 19 * v7 + *(unsigned __int8 *)a1++;
                  --result;
                }
                while ( result );
                hash_accu = v7;
              }
              break;
            case 0xFD:
              --hash_univ_count;
              result = hash_accu;
              v8 = a1 + 8;
              do
                result = 19 * result + *(unsigned __int8 *)a1++;
              while ( a1 != v8 );
              hash_accu = result;
              break;
            case 0xFE:
              --hash_univ_count;
              result = 4 * (*v5 >> 10);
              v14 = result;
              if ( result )
              {
                v9 = hash_accu;
                v10 = 0;
                do
                {
                  result = v4;
                  v4 += 8;
                  do
                    v9 = 19 * v9 + *(unsigned __int8 *)result++;
                  while ( v4 != result );
                  v10 += 8;
                }
                while ( v10 < v14 );
                hash_accu = v9;
              }
              break;
            case 0xFF:
              v11 = *(int (__cdecl **)(unsigned int))(*(_DWORD *)a1 + 12);
              if ( v11 )
              {
                --hash_univ_count;
                v12 = 65599 * hash_accu;
                result = v11(a1);
                hash_accu = result + v12;
              }
              break;
            default:
              --hash_univ_count;
              result = v6 + 19 * hash_accu;
              hash_accu = result;
              for ( i = *v5 >> 10; i; result = hash_aux() )
                --i;
              break;
          }
          break;
        }
      }
      else
      {
LABEL_31:
        result = 65599 * hash_accu;
        hash_accu = 65599 * hash_accu + v4;
      }
    }
  }
  return result;
}
// 807ADC8: using guessed type int hash_accu;
// 807ADCC: using guessed type int hash_univ_limit;
// 807ADD0: using guessed type int hash_univ_count;

//----- (080661EF) --------------------------------------------------------
int __cdecl caml_hash_univ_param(int a1, int a2, unsigned int a3)
{
  hash_univ_limit = a2 >> 1;
  hash_univ_count = a1 >> 1;
  hash_accu = 0;
  hash_aux(a3);
  return 2 * (hash_accu & 0x3FFFFFFF) + 1;
}
// 807ADC8: using guessed type int hash_accu;
// 807ADCC: using guessed type int hash_univ_limit;
// 807ADD0: using guessed type int hash_univ_count;

//----- (08066230) --------------------------------------------------------
int __cdecl caml_sys_init(void *a1, int a2)
{
  int result; // eax

  caml_exe_name = a1;
  result = a2;
  caml_main_argv = a2;
  return result;
}
// 807ADD4: using guessed type int caml_main_argv;

//----- (08066245) --------------------------------------------------------
_DWORD *caml_sys_get_config()
{
  int v0; // ebx
  int v2[8]; // [esp+18h] [ebp-30h] BYREF
  void *v3; // [esp+38h] [ebp-10h] BYREF
  _DWORD *v4; // [esp+3Ch] [ebp-Ch] BYREF

  v0 = caml_local_roots;
  v4 = 0;
  v3 = 0;
  v2[0] = caml_local_roots;
  caml_local_roots = (int)v2;
  v2[2] = 1;
  v2[1] = 2;
  v2[3] = (int)&v4;
  v2[4] = (int)&v3;
  v3 = caml_copy_string("Unix");
  v4 = (_DWORD *)caml_alloc_small(2, 0);
  *v4 = v3;
  v4[1] = 65;
  caml_local_roots = v0;
  return v4;
}
// 8074754: using guessed type int caml_local_roots;

//----- (080662C9) --------------------------------------------------------
_DWORD *caml_sys_get_argv()
{
  int v0; // ebx
  int v2[8]; // [esp+14h] [ebp-34h] BYREF
  _DWORD *v3; // [esp+34h] [ebp-14h] BYREF
  char *v4; // [esp+38h] [ebp-10h] BYREF
  void *v5; // [esp+3Ch] [ebp-Ch] BYREF

  v0 = caml_local_roots;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  v2[0] = caml_local_roots;
  caml_local_roots = (int)v2;
  v2[2] = 1;
  v2[1] = 3;
  v2[3] = (int)&v5;
  v2[4] = (int)&v4;
  v2[5] = (int)&v3;
  v5 = caml_copy_string(caml_exe_name);
  v4 = caml_copy_string_array((_DWORD *)caml_main_argv);
  v3 = (_DWORD *)caml_alloc_small(2, 0);
  *v3 = v5;
  v3[1] = v4;
  caml_local_roots = v0;
  return v3;
}
// 8074754: using guessed type int caml_local_roots;
// 807ADD4: using guessed type int caml_main_argv;

//----- (0806636A) --------------------------------------------------------
int caml_sys_random_seed()
{
  __time_t v0; // esi
  __suseconds_t v1; // ebx
  __pid_t v2; // edi
  struct timeval tv; // [esp+18h] [ebp-20h] BYREF

  gettimeofday(&tv, 0);
  v0 = tv.tv_sec;
  v1 = tv.tv_usec;
  v2 = getppid();
  return 2 * ((v2 << 16) ^ getpid() ^ v0 ^ v1) + 1;
}

//----- (080663BC) --------------------------------------------------------
int caml_sys_time()
{
  struct rusage usage; // [esp+18h] [ebp-50h] BYREF

  getrusage(0, &usage);
  return caml_copy_double(
           (long double)usage.ru_utime.tv_sec
         + (long double)usage.ru_utime.tv_usec / 1000000.0
         + (long double)usage.ru_stime.tv_sec
         + (long double)usage.ru_stime.tv_usec / 1000000.0);
}

//----- (080663FD) --------------------------------------------------------
void *__cdecl caml_sys_getenv(char *name)
{
  char *v1; // eax
  void (__cdecl *v3)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = getenv(name);
  if ( !v1 )
    v1 = (char *)caml_raise_not_found(v3, v4, v5, v6, v7);
  return caml_copy_string(v1);
}
// 8066412: variable 'v3' is possibly undefined
// 8066412: variable 'v4' is possibly undefined
// 8066412: variable 'v5' is possibly undefined
// 8066412: variable 'v6' is possibly undefined
// 8066412: variable 'v7' is possibly undefined

//----- (08066421) --------------------------------------------------------
int __cdecl caml_sys_file_exists(int a1)
{
  char v2[104]; // [esp+10h] [ebp-68h] BYREF

  return __xstat64(3, a1, v2) == 0 ? 3 : 1;
}
// 8049F54: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806644E) --------------------------------------------------------
int __cdecl caml_sys_close(int a1)
{
  close(a1 >> 1);
  return 1;
}

//----- (08066468) --------------------------------------------------------
void __cdecl __noreturn caml_sys_exit(int a1)
{
  exit(a1 >> 1);
}

//----- (0806647B) --------------------------------------------------------
char *__cdecl caml_sys_error(void *src)
{
  int *v1; // eax
  char *v2; // eax
  char *v3; // esi
  unsigned int v4; // kr04_4
  int v5; // ebx
  void *v7; // [esp+4h] [ebp-74h]
  unsigned int v8; // [esp+8h] [ebp-70h]
  int v9; // [esp+Ch] [ebp-6Ch]
  _DWORD *v10; // [esp+10h] [ebp-68h]
  int v11[8]; // [esp+1Ch] [ebp-5Ch] BYREF
  char *v12; // [esp+3Ch] [ebp-3Ch] BYREF
  int v13[14]; // [esp+40h] [ebp-38h] BYREF

  v13[0] = caml_local_roots;
  v13[2] = 1;
  v13[1] = 1;
  v13[3] = (int)&src;
  v12 = 0;
  v11[0] = (int)v13;
  caml_local_roots = (int)v11;
  v11[2] = 1;
  v11[1] = 1;
  v11[3] = (int)&v12;
  v1 = __errno_location();
  v2 = strerror(*v1);
  v3 = v2;
  if ( src == (void *)1 )
  {
    v12 = (char *)caml_copy_string(v2);
  }
  else
  {
    v4 = strlen(v2) + 1;
    v5 = caml_string_length((int)src);
    v12 = (char *)caml_alloc_string(v5 + v4 - 1 + 2);
    memmove(v12, src, v5);
    *(_WORD *)&v12[v5] = 8250;
    memmove(&v12[v5 + 2], v3, v4 - 1);
  }
  caml_raise_sys_error((int)v12, v7, v8, v9, v10);
  return caml_sys_read_directory(src);
}
// 8066555: variable 'v7' is possibly undefined
// 8066555: variable 'v8' is possibly undefined
// 8066555: variable 'v9' is possibly undefined
// 8066555: variable 'v10' is possibly undefined
// 8074754: using guessed type int caml_local_roots;

//----- (0806655A) --------------------------------------------------------
char *__cdecl caml_sys_read_directory(void *src)
{
  int v1; // esi
  int v3[3]; // [esp+10h] [ebp-58h] BYREF
  int v4[8]; // [esp+1Ch] [ebp-4Ch] BYREF
  char *v5; // [esp+3Ch] [ebp-2Ch] BYREF
  int v6[10]; // [esp+40h] [ebp-28h] BYREF

  v1 = caml_local_roots;
  v6[0] = caml_local_roots;
  v6[2] = 1;
  v6[1] = 1;
  v6[3] = (int)&src;
  v5 = 0;
  v4[0] = (int)v6;
  caml_local_roots = (int)v4;
  v4[2] = 1;
  v4[1] = 1;
  v4[3] = (int)&v5;
  caml_ext_table_init(v3, 50);
  if ( caml_read_directory((char *)src, (int)v3) == -1 )
  {
    caml_ext_table_free((int)v3, 1);
    caml_sys_error(src);
  }
  caml_ext_table_add(v3, 0);
  v5 = caml_copy_string_array((_DWORD *)v3[2]);
  caml_ext_table_free((int)v3, 1);
  caml_local_roots = v1;
  return v5;
}
// 8074754: using guessed type int caml_local_roots;

//----- (0806662B) --------------------------------------------------------
int __cdecl caml_sys_system_command(void *src)
{
  int v1; // edi
  size_t v2; // esi
  void *v3; // ebx
  int v4; // esi
  int v5; // eax
  int v7[11]; // [esp+10h] [ebp-38h] BYREF

  v1 = caml_local_roots;
  v7[0] = caml_local_roots;
  caml_local_roots = (int)v7;
  v7[2] = 1;
  v7[1] = 1;
  v7[3] = (int)&src;
  v2 = caml_string_length((int)src) + 1;
  v3 = caml_stat_alloc(v2);
  memmove(v3, src, v2);
  caml_enter_blocking_section();
  v4 = system((const char *)v3);
  caml_leave_blocking_section();
  caml_stat_free(v3);
  if ( v4 == -1 )
  {
    caml_sys_error(src);
    v5 = 255;
  }
  else
  {
    v5 = 255;
    if ( (v4 & 0x7F) == 0 )
      v5 = BYTE1(v4);
  }
  caml_local_roots = v1;
  return 2 * v5 + 1;
}
// 8074754: using guessed type int caml_local_roots;

//----- (080666E6) --------------------------------------------------------
void *caml_sys_getcwd()
{
  char buf[4104]; // [esp+10h] [ebp-1008h] BYREF

  if ( !getcwd(buf, 0x1000u) )
    caml_sys_error((void *)1);
  return caml_copy_string(buf);
}

//----- (08066725) --------------------------------------------------------
int __cdecl caml_sys_chdir(char *path)
{
  if ( chdir(path) )
    caml_sys_error(path);
  return 1;
}

//----- (0806674E) --------------------------------------------------------
int __cdecl caml_sys_rename(char *old, char *newa)
{
  if ( rename(old, newa) )
    caml_sys_error((void *)1);
  return 1;
}

//----- (0806677D) --------------------------------------------------------
int __cdecl caml_sys_remove(char *name)
{
  if ( unlink(name) )
    caml_sys_error(name);
  return 1;
}

//----- (080667A6) --------------------------------------------------------
int __cdecl caml_sys_is_directory(void *src)
{
  char v2[16]; // [esp+10h] [ebp-68h] BYREF
  int v3; // [esp+20h] [ebp-58h]

  if ( __xstat64(3, src, v2) == -1 )
    caml_sys_error(src);
  return 2 * ((v3 & 0xF000) == 0x4000) + 1;
}
// 8049F54: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (080667F1) --------------------------------------------------------
int __cdecl caml_sys_open(char *src, int a2, int a3)
{
  int v3; // edi
  int v4; // eax
  char *v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // esi
  int v10; // [esp+1Ch] [ebp-3Ch]
  int v11[14]; // [esp+20h] [ebp-38h] BYREF

  v3 = caml_local_roots;
  v11[0] = caml_local_roots;
  caml_local_roots = (int)v11;
  v11[2] = 1;
  v11[1] = 3;
  v11[3] = (int)&src;
  v11[4] = (int)&a2;
  v11[5] = (int)&a3;
  v4 = caml_string_length((int)src);
  v5 = (char *)caml_stat_alloc(v4 + 1);
  strcpy(v5, src);
  v6 = caml_convert_flag_list((int *)a2, (int)&sys_open_flags);
  v10 = a3 >> 1;
  caml_enter_blocking_section();
  v7 = open64(v5, v6, v10);
  v8 = v7;
  if ( v7 == -1 )
  {
    caml_leave_blocking_section();
    caml_stat_free(v5);
    caml_sys_error(src);
  }
  else
  {
    fcntl(v7, 2, 1);
    caml_leave_blocking_section();
    caml_stat_free(v5);
  }
  caml_local_roots = v3;
  return 2 * v8 + 1;
}
// 8049EF4: using guessed type int __cdecl open64(_DWORD, _DWORD, _DWORD);
// 8074754: using guessed type int caml_local_roots;

//----- (080668E2) --------------------------------------------------------
char *__cdecl caml_sys_io_error(void *src)
{
  void (__cdecl *v2)(_DWORD, _DWORD *); // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  unsigned int v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  if ( *__errno_location() == 11 )
    caml_raise_sys_blocked_io(v2, v3, v4, v5, v6);
  return caml_sys_error(src);
}
// 80668F2: variable 'v2' is possibly undefined
// 80668F2: variable 'v3' is possibly undefined
// 80668F2: variable 'v4' is possibly undefined
// 80668F2: variable 'v5' is possibly undefined
// 80668F2: variable 'v6' is possibly undefined

//----- (08066904) --------------------------------------------------------
int __cdecl caml_set_parser_trace(int a1)
{
  int result; // eax

  result = caml_parser_trace == 0 ? 1 : 3;
  caml_parser_trace = a1 >> 1;
  return result;
}
// 807ADD8: using guessed type int caml_parser_trace;

//----- (08066923) --------------------------------------------------------
const char *__usercall token_name@<eax>(const char *a1@<eax>, int a2@<edx>)
{
  const char *v2; // ebx

  v2 = a1;
  if ( a2 > 0 )
  {
    if ( *a1 )
    {
      while ( 1 )
      {
        v2 += strlen(v2) + 1;
        if ( --a2 <= 0 )
          break;
        if ( !*v2 )
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      v2 = "<unknown token>";
    }
  }
  return v2;
}

//----- (08066964) --------------------------------------------------------
int __cdecl caml_parse_engine(int a1, _DWORD *a2, int a3, signed int a4)
{
  unsigned int v4; // edi
  int result; // eax
  const char *v6; // eax
  const char *v7; // eax
  int v8; // eax
  char v9; // dl
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  unsigned int v17; // edi
  int v18; // edx
  int v19; // ecx
  int v20; // ecx
  int v21; // eax
  int v22; // [esp+24h] [ebp-24h]
  int v23; // [esp+28h] [ebp-20h]
  int v24; // [esp+28h] [ebp-20h]
  int v25; // [esp+2Ch] [ebp-1Ch]
  int v26; // [esp+2Ch] [ebp-1Ch]
  unsigned int v27; // [esp+2Ch] [ebp-1Ch]

  switch ( a3 >> 1 )
  {
    case 0:
      v4 = (int)a2[13] >> 1;
      v22 = 0;
      v23 = 0;
      goto LABEL_3;
    case 1:
      v4 = (int)a2[13] >> 1;
      v23 = (int)a2[14] >> 1;
      v22 = (int)a2[15] >> 1;
      if ( (a4 & 1) != 0 )
      {
        a2[6] = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * (a4 >> 1));
        caml_modify(a2 + 7, 1u);
      }
      else
      {
        a2[6] = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * *(unsigned __int8 *)(a4 - 4));
        caml_modify(a2 + 7, *(_DWORD *)a4);
      }
      if ( caml_parser_trace )
      {
        if ( (a4 & 1) != 0 )
        {
          v6 = token_name(*(const char **)(a1 + 56), a4 >> 1);
          fprintf(stderr, "State %d: read token %s\n", v23, v6);
        }
        else
        {
          v7 = token_name(*(const char **)(a1 + 60), *(unsigned __int8 *)(a4 - 4));
          fprintf(stderr, "State %d: read token %s(", v23, v7);
          v8 = *(_DWORD *)a4;
          if ( (*(_DWORD *)a4 & 1) != 0 )
          {
            fprintf(stderr, "%ld", v8 >> 1);
          }
          else
          {
            v9 = *(_BYTE *)(v8 - 4);
            if ( v9 == -4 )
            {
              fputs((const char *)v8, stderr);
            }
            else if ( v9 == -3 )
            {
              fprintf(stderr, "%g", *(double *)v8);
            }
            else
            {
              fputc(95, stderr);
            }
          }
          fwrite(")\n", 1u, 2u, stderr);
        }
      }
      goto LABEL_20;
    case 2:
      v4 = (int)a2[13] >> 1;
      v23 = (int)a2[14] >> 1;
      v22 = (int)a2[15] >> 1;
      goto LABEL_55;
    case 3:
      v17 = (int)a2[13] >> 1;
      v21 = (int)a2[14] >> 1;
      v22 = (int)a2[15] >> 1;
      goto LABEL_67;
    case 4:
      v4 = (int)a2[13] >> 1;
      v23 = (int)a2[14] >> 1;
      v22 = (int)a2[15] >> 1;
      *(_DWORD *)(4 * v4 + *a2) = 2 * v23 + 1;
      caml_modify((unsigned int *)(a2[1] + 4 * v4), a4);
      v27 = (int)a2[10] >> 1;
      caml_modify((unsigned int *)(4 * v4 + a2[3]), *(_DWORD *)(4 * v27 + a2[3]));
      if ( v4 > v27 )
        caml_modify((unsigned int *)(a2[2] + 4 * v4), *(_DWORD *)(4 * v27 + a2[3]));
      goto LABEL_3;
    case 5:
      v4 = (int)a2[13] >> 1;
      v23 = (int)a2[14] >> 1;
      v22 = (int)a2[15] >> 1;
      break;
    default:
      return 3;
  }
  while ( 2 )
  {
    if ( v22 <= 2 )
    {
      while ( 1 )
      {
        v14 = *(int *)(*a2 + 4 * v4) >> 1;
        v15 = *(__int16 *)(*(_DWORD *)(a1 + 28) + 2 * v14) + 256;
        if ( *(_WORD *)(*(_DWORD *)(a1 + 28) + 2 * v14)
          && v15 >= 0
          && v15 <= *(int *)(a1 + 40) >> 1
          && *(_WORD *)(*(_DWORD *)(a1 + 48) + 2 * v15) == 256 )
        {
          v26 = *(__int16 *)(*(_DWORD *)(a1 + 28) + 2 * v14) + 256;
          v22 = 3;
          if ( caml_parser_trace )
          {
            fprintf(stderr, "Recovering in state %d\n", v14);
            v22 = 3;
            goto LABEL_50;
          }
          goto LABEL_52;
        }
        if ( caml_parser_trace )
          fprintf(stderr, "Discarding state %d\n", *(int *)(*a2 + 4 * v4) >> 1);
        if ( v4 <= (int)a2[5] >> 1 )
          break;
        --v4;
      }
      if ( caml_parser_trace )
      {
        fwrite("No more states to discard\n", 1u, 0x1Au, stderr);
        return 3;
      }
      return 3;
    }
    if ( !(a2[6] >> 1) )
      return 3;
    if ( caml_parser_trace )
      fwrite("Discarding last token read\n", 1u, 0x1Bu, stderr);
    a2[6] = -1;
    while ( 1 )
    {
LABEL_3:
      v25 = *(__int16 *)(*(_DWORD *)(a1 + 20) + 2 * v23);
      if ( *(_WORD *)(*(_DWORD *)(a1 + 20) + 2 * v23) )
        goto LABEL_56;
      if ( (int)a2[6] < 0 )
      {
        a2[13] = 2 * v4 + 1;
        a2[14] = 2 * v23 + 1;
        a2[15] = 2 * v22 + 1;
        return 1;
      }
LABEL_20:
      v10 = (int)a2[6] >> 1;
      v11 = *(__int16 *)(*(_DWORD *)(a1 + 28) + 2 * v23) + v10;
      v26 = v11;
      if ( !*(_WORD *)(*(_DWORD *)(a1 + 28) + 2 * v23)
        || v11 < 0
        || v11 > *(int *)(a1 + 40) >> 1
        || v10 != *(__int16 *)(*(_DWORD *)(a1 + 48) + 2 * v11) )
      {
        break;
      }
      a2[6] = -1;
      v22 -= v22 > 0;
LABEL_50:
      if ( caml_parser_trace )
        fprintf(stderr, "State %d: shift to state %d\n", v23, *(__int16 *)(*(_DWORD *)(a1 + 44) + 2 * v26));
LABEL_52:
      v23 = *(__int16 *)(*(_DWORD *)(a1 + 44) + 2 * v26);
      if ( ++v4 >= (int)a2[4] >> 1 )
      {
        a2[13] = 2 * v4 + 1;
        a2[14] = 2 * v23 + 1;
        a2[15] = 2 * v22 + 1;
        return 5;
      }
LABEL_55:
      *(_DWORD *)(4 * v4 + *a2) = 2 * v23 + 1;
      caml_modify((unsigned int *)(a2[1] + 4 * v4), a2[7]);
      caml_modify((unsigned int *)(a2[2] + 4 * v4), a2[8]);
      caml_modify((unsigned int *)(a2[3] + 4 * v4), a2[9]);
    }
    v12 = *(__int16 *)(*(_DWORD *)(a1 + 32) + 2 * v23) + v10;
    if ( *(_WORD *)(*(_DWORD *)(a1 + 32) + 2 * v23) )
    {
      if ( v12 >= 0 && v12 <= *(int *)(a1 + 40) >> 1 )
      {
        v13 = 2 * v12;
        if ( v10 == *(__int16 *)(*(_DWORD *)(a1 + 48) + v13) )
        {
          v25 = *(__int16 *)(*(_DWORD *)(a1 + 44) + v13);
LABEL_56:
          if ( caml_parser_trace )
            fprintf(stderr, "State %d: reduce by rule %d\n", v23, v25);
          v16 = *(__int16 *)(*(_DWORD *)(a1 + 16) + 2 * v25);
          a2[10] = 2 * v4 + 1;
          a2[12] = 2 * v25 + 1;
          a2[11] = 2 * v16 + 1;
          v17 = v4 + 1 - v16;
          v24 = *(int *)(*a2 + 4 * v17 - 4) >> 1;
          v18 = 2 * *(__int16 *)(*(_DWORD *)(a1 + 12) + 2 * v25);
          v19 = *(__int16 *)(*(_DWORD *)(a1 + 36) + v18) + v24;
          if ( *(_WORD *)(*(_DWORD *)(a1 + 36) + v18)
            && v19 >= 0
            && v19 <= *(int *)(a1 + 40) >> 1
            && (v20 = 2 * v19, *(__int16 *)(*(_DWORD *)(a1 + 48) + v20) == v24) )
          {
            v21 = *(__int16 *)(*(_DWORD *)(a1 + 44) + v20);
          }
          else
          {
            v21 = *(__int16 *)(*(_DWORD *)(a1 + 24) + 2 * *(__int16 *)(*(_DWORD *)(a1 + 12) + 2 * v25));
          }
          if ( v17 < (int)a2[4] >> 1 )
          {
LABEL_67:
            a2[13] = 2 * v17 + 1;
            a2[14] = 2 * v21 + 1;
            a2[15] = 2 * v22 + 1;
            result = 9;
          }
          else
          {
            a2[13] = 2 * v17 + 1;
            a2[14] = 2 * v21 + 1;
            a2[15] = 2 * v22 + 1;
            result = 7;
          }
          return result;
        }
      }
    }
    if ( v22 > 0 )
      continue;
    break;
  }
  a2[13] = 2 * v4 + 1;
  a2[14] = 2 * v23 + 1;
  a2[15] = 2 * v22 + 1;
  return 11;
}
// 807ADD8: using guessed type int caml_parser_trace;

//----- (08066FD0) --------------------------------------------------------
int __usercall norm_pfree@<eax>(int result@<eax>)
{
  if ( !result )
    result = 1;
  return result;
}

//----- (08066FDF) --------------------------------------------------------
void norm_pmax()
{
  ;
}

//----- (08066FE4) --------------------------------------------------------
unsigned int __usercall norm_heapincr@<eax>(int a1@<eax>)
{
  unsigned int result; // eax

  result = (a1 + 1023) & 0xFFFFFC00;
  if ( result <= 0x7FF )
    result = 2048;
  return result;
}

//----- (08067000) --------------------------------------------------------
int __usercall norm_minsize@<eax>(int result@<eax>)
{
  if ( result <= 4095 )
    result = 4096;
  if ( result > 0x10000000 )
    result = 0x10000000;
  return result;
}

//----- (0806701F) --------------------------------------------------------
int __cdecl caml_init_gc(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax

  v4 = 4 * norm_heapincr(a2);
  LOWORD(v5) = caml_page_table_initialize();
  if ( v5 )
    caml_fatal_error("OCaml runtime error: cannot initialize page table\n");
  v6 = norm_minsize(a1);
  caml_set_minor_heap_size(4 * v6);
  caml_major_heap_increment = 4 * norm_heapincr(a3);
  caml_percent_free = norm_pfree(a4);
  norm_pmax();
  caml_percent_max = v7;
  caml_init_major_heap(v4);
  caml_gc_message(32, "Initial minor heap size: %luk bytes\n", (unsigned int)caml_minor_heap_size >> 10);
  caml_gc_message(32, "Initial major heap size: %luk bytes\n", v4 >> 10);
  caml_gc_message(32, "Initial space overhead: %lu%%\n", caml_percent_free);
  caml_gc_message(32, "Initial max overhead: %lu%%\n", caml_percent_max);
  caml_gc_message(32, "Initial heap increment: %luk bytes\n", (unsigned int)caml_major_heap_increment >> 10);
  return caml_gc_message(32, "Initial allocation policy: %d\n", caml_allocation_policy);
}
// 8067046: variable 'v5' is possibly undefined
// 806708B: variable 'v7' is possibly undefined
// 807B4AC: using guessed type int caml_major_heap_increment;
// 807B4B4: using guessed type int caml_minor_heap_size;

//----- (08067151) --------------------------------------------------------
int caml_gc_compaction()
{
  caml_gc_message(16, "Heap compaction requested\n", 0);
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  caml_final_do_calls();
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  caml_compact_heap();
  caml_final_do_calls();
  return 1;
}

//----- (080671A1) --------------------------------------------------------
int test_and_compact()
{
  long double v0; // fst6
  int result; // eax
  float v2; // [esp+18h] [ebp-20h]
  float v3; // [esp+18h] [ebp-20h]

  v2 = (long double)(unsigned int)caml_fl_cur_size
     * 100.0
     / (long double)(((unsigned int)caml_stat_heap_size >> 2) - caml_fl_cur_size);
  v0 = v2;
  if ( v2 > 999999.0 )
    v0 = 999999.0;
  v3 = v0;
  caml_gc_message(512, "Estimated overhead (lower bound) = %lu%%\n", (__int64)v0);
  result = caml_percent_max;
  if ( v3 >= (long double)(unsigned int)caml_percent_max && caml_stat_heap_chunks > 1 )
  {
    caml_gc_message(512, "Automatic compaction triggered.\n", 0);
    result = caml_compact_heap();
  }
  return result;
}
// 80768E0: using guessed type int caml_fl_cur_size;
// 807AE00: using guessed type int caml_stat_heap_size;
// 807AE0C: using guessed type int caml_stat_heap_chunks;

//----- (0806726B) --------------------------------------------------------
int caml_gc_full_major()
{
  caml_gc_message(1, "Full major GC cycle requested\n", 0);
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  caml_final_do_calls();
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  test_and_compact();
  caml_final_do_calls();
  return 1;
}

//----- (080672BC) --------------------------------------------------------
int caml_gc_major()
{
  caml_gc_message(1, "Major GC cycle requested\n", 0);
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  test_and_compact();
  caml_final_do_calls();
  return 1;
}

//----- (080672FC) --------------------------------------------------------
int __cdecl caml_gc_major_slice(int a1)
{
  caml_empty_minor_heap();
  return 2 * caml_major_collection_slice(a1 >> 1) + 1;
}

//----- (0806731A) --------------------------------------------------------
int caml_gc_minor()
{
  caml_minor_collection();
  return 1;
}

//----- (0806732C) --------------------------------------------------------
int __cdecl caml_gc_set(int *a1)
{
  int v1; // eax
  int v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // ebx
  unsigned int v5; // eax
  int v6; // ebx

  caml_verb_gc = a1[3] >> 1;
  v1 = norm_pfree(a1[2] >> 1);
  if ( v1 != caml_percent_free )
  {
    caml_percent_free = v1;
    caml_gc_message(32, "New space overhead: %d%%\n", v1);
  }
  norm_pmax();
  if ( v2 != caml_percent_max )
  {
    caml_percent_max = v2;
    caml_gc_message(32, "New max overhead: %d%%\n", v2);
  }
  v3 = 4 * norm_heapincr(a1[1] >> 1);
  if ( v3 != caml_major_heap_increment )
  {
    caml_major_heap_increment = v3;
    caml_gc_message(32, "New heap increment size: %luk bytes\n", v3 >> 10);
  }
  v4 = a1[6] >> 1;
  if ( v4 >= 2 )
    v4 = 1;
  if ( v4 != caml_allocation_policy )
  {
    caml_gc_message(32, "New allocation policy: %d\n", v4);
    caml_set_allocation_policy(v4);
  }
  v5 = norm_minsize(4 * (*a1 >> 1));
  v6 = v5;
  if ( v5 != caml_minor_heap_size )
  {
    caml_gc_message(32, "New minor heap size: %luk bytes\n", v5 >> 10);
    caml_set_minor_heap_size(v6);
  }
  return 1;
}
// 8067382: variable 'v2' is possibly undefined
// 80768C0: using guessed type int caml_verb_gc;
// 807B4AC: using guessed type int caml_major_heap_increment;
// 807B4B4: using guessed type int caml_minor_heap_size;

//----- (08067453) --------------------------------------------------------
unsigned int *caml_gc_get()
{
  int v0; // ebx
  int v2[8]; // [esp+1Ch] [ebp-2Ch] BYREF
  unsigned int *v3; // [esp+3Ch] [ebp-Ch] BYREF

  v0 = caml_local_roots;
  v3 = 0;
  v2[0] = caml_local_roots;
  caml_local_roots = (int)v2;
  v2[2] = 1;
  v2[1] = 1;
  v2[3] = (int)&v3;
  v3 = (unsigned int *)caml_alloc_tuple(7u);
  caml_modify(v3, 2 * ((unsigned int)caml_minor_heap_size >> 2) + 1);
  caml_modify(v3 + 1, 2 * ((unsigned int)caml_major_heap_increment >> 2) + 1);
  caml_modify(v3 + 2, 2 * caml_percent_free + 1);
  caml_modify(v3 + 3, 2 * caml_verb_gc + 1);
  caml_modify(v3 + 4, 2 * caml_percent_max + 1);
  caml_modify(v3 + 5, 1u);
  caml_modify(v3 + 6, 2 * caml_allocation_policy + 1);
  caml_local_roots = v0;
  return v3;
}
// 8074754: using guessed type int caml_local_roots;
// 80768C0: using guessed type int caml_verb_gc;
// 807B4AC: using guessed type int caml_major_heap_increment;
// 807B4B4: using guessed type int caml_minor_heap_size;

//----- (0806755D) --------------------------------------------------------
unsigned int *caml_gc_counters()
{
  int v0; // ebx
  unsigned int v1; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  double v5; // [esp+10h] [ebp-58h]
  double v6; // [esp+18h] [ebp-50h]
  double v7; // [esp+20h] [ebp-48h]
  int v8[8]; // [esp+3Ch] [ebp-2Ch] BYREF
  unsigned int *v9; // [esp+5Ch] [ebp-Ch] BYREF

  v0 = caml_local_roots;
  v9 = 0;
  v8[0] = caml_local_roots;
  caml_local_roots = (int)v8;
  v8[2] = 1;
  v8[1] = 1;
  v8[3] = (int)&v9;
  v5 = (long double)((unsigned int)(caml_young_end - caml_young_ptr) >> 2) + caml_stat_minor_words;
  v6 = caml_stat_promoted_words;
  v7 = (long double)(unsigned int)caml_allocated_words + caml_stat_major_words;
  v9 = (unsigned int *)caml_alloc_tuple(3u);
  v1 = caml_copy_double(v5);
  caml_modify(v9, v1);
  v2 = caml_copy_double(v6);
  caml_modify(v9 + 1, v2);
  v3 = caml_copy_double(v7);
  caml_modify(v9 + 2, v3);
  caml_local_roots = v0;
  return v9;
}
// 8074754: using guessed type int caml_local_roots;
// 80778D0: using guessed type int caml_young_end;
// 80778D4: using guessed type int caml_young_ptr;
// 807ADE0: using guessed type double caml_stat_minor_words;
// 807ADE8: using guessed type double caml_stat_promoted_words;
// 807ADF0: using guessed type double caml_stat_major_words;

//----- (0806764C) --------------------------------------------------------
unsigned int *caml_gc_quick_stat()
{
  int v0; // ebx
  int v1; // esi
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  double v8; // [esp+10h] [ebp-78h]
  double v9; // [esp+18h] [ebp-70h]
  double v10; // [esp+20h] [ebp-68h]
  unsigned int v11; // [esp+28h] [ebp-60h]
  unsigned int v12; // [esp+2Ch] [ebp-5Ch]
  int v13; // [esp+30h] [ebp-58h]
  int v14; // [esp+34h] [ebp-54h]
  int v15[8]; // [esp+4Ch] [ebp-3Ch] BYREF
  unsigned int *v16; // [esp+6Ch] [ebp-1Ch] BYREF

  v0 = caml_local_roots;
  v16 = 0;
  v15[0] = caml_local_roots;
  caml_local_roots = (int)v15;
  v15[2] = 1;
  v15[1] = 1;
  v15[3] = (int)&v16;
  v8 = (long double)((unsigned int)(caml_young_end - caml_young_ptr) >> 2) + caml_stat_minor_words;
  v9 = caml_stat_promoted_words;
  v10 = (long double)(unsigned int)caml_allocated_words + caml_stat_major_words;
  v1 = caml_stat_minor_collections;
  v2 = caml_stat_major_collections;
  v11 = (unsigned int)caml_stat_heap_size >> 2;
  v12 = (unsigned int)caml_stat_top_heap_size >> 2;
  v13 = caml_stat_compactions;
  v14 = caml_stat_heap_chunks;
  v16 = (unsigned int *)caml_alloc_tuple(0x10u);
  v3 = caml_copy_double(v8);
  caml_modify(v16, v3);
  v4 = caml_copy_double(v9);
  caml_modify(v16 + 1, v4);
  v5 = caml_copy_double(v10);
  caml_modify(v16 + 2, v5);
  caml_modify(v16 + 3, 2 * v1 + 1);
  caml_modify(v16 + 4, 2 * v2 + 1);
  caml_modify(v16 + 5, 2 * v11 + 1);
  caml_modify(v16 + 6, 2 * v14 + 1);
  caml_modify(v16 + 7, 1u);
  caml_modify(v16 + 8, 1u);
  caml_modify(v16 + 9, 1u);
  caml_modify(v16 + 10, 1u);
  caml_modify(v16 + 11, 1u);
  caml_modify(v16 + 12, 1u);
  caml_modify(v16 + 13, 2 * v13 + 1);
  caml_modify(v16 + 14, 2 * v12 + 1);
  v6 = caml_stack_usage();
  caml_modify(v16 + 15, 2 * v6 + 1);
  caml_local_roots = v0;
  return v16;
}
// 8074754: using guessed type int caml_local_roots;
// 80778D0: using guessed type int caml_young_end;
// 80778D4: using guessed type int caml_young_ptr;
// 807ADE0: using guessed type double caml_stat_minor_words;
// 807ADE8: using guessed type double caml_stat_promoted_words;
// 807ADF0: using guessed type double caml_stat_major_words;
// 807ADF8: using guessed type int caml_stat_minor_collections;
// 807ADFC: using guessed type int caml_stat_major_collections;
// 807AE00: using guessed type int caml_stat_heap_size;
// 807AE04: using guessed type int caml_stat_top_heap_size;
// 807AE08: using guessed type int caml_stat_compactions;
// 807AE0C: using guessed type int caml_stat_heap_chunks;

//----- (080678A1) --------------------------------------------------------
unsigned int *caml_gc_stat()
{
  char *v0; // eax
  unsigned int v1; // esi
  int v2; // ebx
  unsigned int v3; // edx
  unsigned int v4; // ecx
  int v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // eax
  unsigned int v11; // [esp+14h] [ebp-94h]
  int v12; // [esp+18h] [ebp-90h]
  char *v13; // [esp+1Ch] [ebp-8Ch]
  unsigned int v14; // [esp+1Ch] [ebp-8Ch]
  unsigned int v15; // [esp+20h] [ebp-88h]
  int v16; // [esp+20h] [ebp-88h]
  int v17; // [esp+24h] [ebp-84h]
  double v18; // [esp+28h] [ebp-80h]
  double v19; // [esp+30h] [ebp-78h]
  int v20; // [esp+38h] [ebp-70h]
  int v21; // [esp+3Ch] [ebp-6Ch]
  char *v22; // [esp+40h] [ebp-68h]
  double v23; // [esp+40h] [ebp-68h]
  int v24; // [esp+4Ch] [ebp-5Ch]
  int v25; // [esp+50h] [ebp-58h]
  int v26; // [esp+54h] [ebp-54h]
  int v27[8]; // [esp+6Ch] [ebp-3Ch] BYREF
  unsigned int *v28; // [esp+8Ch] [ebp-1Ch] BYREF

  v17 = caml_local_roots;
  v0 = (char *)caml_heap_start;
  if ( caml_heap_start )
  {
    v21 = 0;
    v1 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v2 = 0;
    v20 = 0;
    while ( 1 )
    {
      ++v20;
      v22 = v0 - 16;
      if ( &v0[*((_DWORD *)v0 - 2)] > v0 )
        break;
LABEL_25:
      v0 = (char *)*((_DWORD *)v22 + 3);
      if ( !v0 )
        goto LABEL_26;
    }
    v13 = &v0[*((_DWORD *)v0 - 2)];
    while ( 1 )
    {
      v3 = *(_DWORD *)v0;
      v4 = *(_DWORD *)v0 & 0x300;
      if ( v4 == 256 )
        goto LABEL_21;
      if ( v4 <= 0x100 )
      {
        if ( !v4 )
        {
          v15 = v3 >> 10;
          if ( v3 >> 10 )
          {
            if ( caml_gc_phase == 1 && caml_gc_sweep_hp <= (unsigned int)v0 )
            {
              ++v24;
              v25 += v15 + 1;
              if ( v15 + 1 > v1 )
                v1 = v15 + 1;
            }
            else
            {
              ++v26;
              v2 += v15 + 1;
            }
          }
          else
          {
            ++v21;
          }
        }
        goto LABEL_24;
      }
      if ( v4 == 512 )
      {
        ++v24;
        v25 += (v3 >> 10) + 1;
        if ( (v3 >> 10) + 1 > v1 )
          v1 = (v3 >> 10) + 1;
        goto LABEL_24;
      }
      if ( v4 == 768 )
      {
LABEL_21:
        ++v26;
        v2 += (v3 >> 10) + 1;
      }
LABEL_24:
      v0 += 4 * (v3 >> 10) + 4;
      if ( v13 <= v0 )
        goto LABEL_25;
    }
  }
  v21 = 0;
  v1 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v2 = 0;
  v20 = 0;
LABEL_26:
  v28 = 0;
  v27[0] = caml_local_roots;
  caml_local_roots = (int)v27;
  v27[2] = 1;
  v27[1] = 1;
  v27[3] = (int)&v28;
  v23 = (long double)((unsigned int)(caml_young_end - caml_young_ptr) >> 2) + caml_stat_minor_words;
  v19 = caml_stat_promoted_words;
  v18 = (long double)(unsigned int)caml_allocated_words + caml_stat_major_words;
  v5 = caml_stat_minor_collections;
  v16 = caml_stat_major_collections;
  v14 = (unsigned int)caml_stat_heap_size >> 2;
  v12 = caml_stat_compactions;
  v11 = (unsigned int)caml_stat_top_heap_size >> 2;
  v28 = (unsigned int *)caml_alloc_tuple(0x10u);
  v6 = caml_copy_double(v23);
  caml_modify(v28, v6);
  v7 = caml_copy_double(v19);
  caml_modify(v28 + 1, v7);
  v8 = caml_copy_double(v18);
  caml_modify(v28 + 2, v8);
  caml_modify(v28 + 3, 2 * v5 + 1);
  caml_modify(v28 + 4, 2 * v16 + 1);
  caml_modify(v28 + 5, 2 * v14 + 1);
  caml_modify(v28 + 6, 2 * v20 + 1);
  caml_modify(v28 + 7, 2 * v2 + 1);
  caml_modify(v28 + 8, 2 * v26 + 1);
  caml_modify(v28 + 9, 2 * v25 + 1);
  caml_modify(v28 + 10, 2 * v24 + 1);
  caml_modify(v28 + 11, 2 * v1 + 1);
  caml_modify(v28 + 12, 2 * v21 + 1);
  caml_modify(v28 + 13, 2 * v12 + 1);
  caml_modify(v28 + 14, 2 * v11 + 1);
  v9 = caml_stack_usage();
  caml_modify(v28 + 15, 2 * v9 + 1);
  caml_local_roots = v17;
  return v28;
}
// 8074754: using guessed type int caml_local_roots;
// 80778D0: using guessed type int caml_young_end;
// 80778D4: using guessed type int caml_young_ptr;
// 807ADE0: using guessed type double caml_stat_minor_words;
// 807ADE8: using guessed type double caml_stat_promoted_words;
// 807ADF0: using guessed type double caml_stat_major_words;
// 807ADF8: using guessed type int caml_stat_minor_collections;
// 807ADFC: using guessed type int caml_stat_major_collections;
// 807AE00: using guessed type int caml_stat_heap_size;
// 807AE04: using guessed type int caml_stat_top_heap_size;
// 807AE08: using guessed type int caml_stat_compactions;
// 807B48C: using guessed type int caml_gc_sweep_hp;
// 807B49C: using guessed type int caml_gc_phase;

//----- (08067C98) --------------------------------------------------------
_DWORD *__cdecl _Z8MD5_InitP12md5Context_t(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = 0;
  a1[5] = 0;
  return result;
}

//----- (08067CC9) --------------------------------------------------------
_DWORD *__cdecl caml_MD5Transform(_DWORD *a1, _DWORD *a2)
{
  int v2; // esi
  int v3; // ecx
  int v4; // edx
  int v5; // ebx
  int v6; // edx
  int v7; // ecx
  int v8; // esi
  int v9; // ebx
  int v10; // edx
  int v11; // ecx
  int v12; // esi
  int v13; // ebx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  int v17; // edi
  int v18; // edx
  int v19; // ebx
  int v20; // ecx
  int v21; // esi
  int v22; // eax
  int v23; // edx
  int v24; // ebx
  int v25; // esi
  int v26; // eax
  int v27; // edx
  int v28; // ebx
  int v29; // esi
  int v30; // eax
  int v31; // edx
  int v32; // ebx
  int v33; // edi
  int v34; // edx
  int v35; // ebx
  int v36; // edi
  int v37; // esi
  int v38; // edx
  int v39; // ebx
  int v40; // edi
  int v41; // eax
  int v42; // esi
  int v43; // ebx
  int v44; // edx
  int v45; // edi
  int v46; // esi
  int v47; // eax
  int v48; // ebx
  int v49; // edi
  int v50; // edx
  int v51; // esi
  int v52; // ebx
  int v53; // eax
  int v54; // edx
  int v55; // esi
  int v56; // ebx
  int v57; // edi
  int v58; // edx
  int v59; // esi
  int v60; // eax
  int v61; // ebx
  int v62; // edx
  int v63; // ecx
  int v64; // eax
  int v65; // ebx
  int v66; // edx
  int v67; // ecx
  _DWORD *result; // eax
  int v69; // [esp+4h] [ebp-60h]
  int v70; // [esp+Ch] [ebp-58h]
  int v71; // [esp+20h] [ebp-44h]
  int v72; // [esp+24h] [ebp-40h]
  int v73; // [esp+28h] [ebp-3Ch]
  int v74; // [esp+2Ch] [ebp-38h]
  int v75; // [esp+30h] [ebp-34h]
  int v76; // [esp+34h] [ebp-30h]
  int v77; // [esp+38h] [ebp-2Ch]
  int v78; // [esp+3Ch] [ebp-28h]
  int v79; // [esp+40h] [ebp-24h]
  int v80; // [esp+44h] [ebp-20h]
  int v81; // [esp+48h] [ebp-1Ch]
  int v82; // [esp+4Ch] [ebp-18h]
  int v83; // [esp+50h] [ebp-14h]
  int v84; // [esp+54h] [ebp-10h]

  v2 = a1[1];
  v3 = a1[2];
  v4 = a1[3];
  v5 = v2 + __ROR4__(*a1 + *a2 - 680876936 + (v4 ^ v2 & (v3 ^ v4)), 25);
  v71 = a2[1];
  v6 = v5 + __ROR4__(v4 + v71 - 389564586 + (v3 ^ v5 & (v2 ^ v3)), 20);
  v72 = a2[2];
  v7 = v6 + __ROR4__(v3 + v72 + 606105819 + (v2 ^ v6 & (v2 ^ v5)), 15);
  v73 = a2[3];
  v8 = v7 + __ROR4__(v2 + v73 - 1044525330 + (v5 ^ v7 & (v5 ^ v6)), 10);
  v74 = a2[4];
  v9 = v8 + __ROR4__(v5 + v74 - 176418897 + (v6 ^ v8 & (v6 ^ v7)), 25);
  v75 = a2[5];
  v10 = v9 + __ROR4__(v6 + v75 + 1200080426 + (v7 ^ v9 & (v7 ^ v8)), 20);
  v76 = a2[6];
  v11 = v10 + __ROR4__(v7 + v76 - 1473231341 + (v8 ^ v10 & (v8 ^ v9)), 15);
  v77 = a2[7];
  v12 = v11 + __ROR4__(v8 + v77 - 45705983 + (v9 ^ v11 & (v9 ^ v10)), 10);
  v78 = a2[8];
  v13 = v12 + __ROR4__(v9 + v78 + 1770035416 + (v10 ^ v12 & (v10 ^ v11)), 25);
  v79 = a2[9];
  v14 = v13 + __ROR4__(v10 + v79 - 1958414417 + (v11 ^ v13 & (v11 ^ v12)), 20);
  v80 = a2[10];
  v15 = v14 + __ROR4__(v11 + v80 - 42063 + (v12 ^ v14 & (v12 ^ v13)), 15);
  v81 = a2[11];
  v16 = v15 + __ROR4__(v12 + v81 - 1990404162 + (v13 ^ v15 & (v13 ^ v14)), 10);
  v82 = a2[12];
  v17 = v16 + __ROR4__(v13 + v82 + 1804603682 + (v14 ^ v16 & (v14 ^ v15)), 25);
  v83 = a2[13];
  v18 = v17 + __ROR4__(v14 + v83 - 40341101 + (v15 ^ v17 & (v15 ^ v16)), 20);
  v84 = a2[14];
  v19 = v18 + __ROR4__(v15 + v84 - 1502002290 + (v16 ^ v18 & (v16 ^ v17)), 15);
  v20 = a2[15];
  v21 = v19 + __ROR4__(v16 + v20 + 1236535329 + (v17 ^ v19 & (v17 ^ v18)), 10);
  v22 = v21 + __ROR4__(v17 + v71 - 165796510 + (v19 ^ v18 & (v19 ^ v21)), 27);
  v23 = v22 + __ROR4__(v18 + v76 - 1069501632 + (v21 ^ v19 & (v21 ^ v22)), 23);
  v24 = v23 + __ROR4__(v19 + v81 + 643717713 + (v22 ^ v21 & (v22 ^ v23)), 18);
  v25 = v24 + __ROR4__(v21 + *a2 - 373897302 + (v23 ^ v22 & (v23 ^ v24)), 12);
  v26 = v25 + __ROR4__(v22 + v75 - 701558691 + (v24 ^ v23 & (v24 ^ v25)), 27);
  v27 = v26 + __ROR4__(v23 + v80 + 38016083 + (v25 ^ v24 & (v25 ^ v26)), 23);
  v28 = v27 + __ROR4__(v24 + v20 - 660478335 + (v26 ^ v25 & (v26 ^ v27)), 18);
  v29 = v28 + __ROR4__(v25 + v74 - 405537848 + (v27 ^ v26 & (v27 ^ v28)), 12);
  v30 = v29 + __ROR4__(v26 + v79 + 568446438 + (v28 ^ v27 & (v28 ^ v29)), 27);
  v31 = v30 + __ROR4__(v27 + v84 - 1019803690 + (v29 ^ v28 & (v29 ^ v30)), 23);
  v32 = v31 + __ROR4__(v28 + v73 - 187363961 + (v30 ^ v29 & (v30 ^ v31)), 18);
  v33 = __ROR4__(v29 + v78 + 1163531501 + (v31 ^ v30 & (v31 ^ v32)), 12);
  v70 = v32 + v33;
  v69 = v32 + v33 + __ROR4__(v30 + v83 - 1444681467 + (v32 ^ v31 & (v32 ^ (v32 + v33))), 27);
  v34 = v69 + __ROR4__(v31 + v72 - 51403784 + ((v32 + v33) ^ v32 & ((v32 + v33) ^ v69)), 23);
  v35 = v34 + __ROR4__(v32 + v77 + 1735328473 + (v69 ^ (v32 + v33) & (v34 ^ v69)), 18);
  v36 = v35 + __ROR4__(v70 + v82 - 1926607734 + (v34 ^ (v34 ^ v35) & v69), 12);
  v37 = v36 + __ROR4__(v69 + v75 - 378558 + (v36 ^ v34 ^ v35), 28);
  v38 = v37 + __ROR4__(v34 + v78 - 2022574463 + (v37 ^ v35 ^ v36), 21);
  v39 = v38 + __ROR4__(v35 + v81 + 1839030562 + (v38 ^ v36 ^ v37), 16);
  v40 = v39 + __ROR4__(v36 + v84 - 35309556 + (v39 ^ v37 ^ v38), 9);
  v41 = v40 + __ROR4__(v37 + v71 - 1530992060 + (v40 ^ v38 ^ v39), 28);
  v42 = v41 + __ROR4__(v38 + v74 + 1272893353 + (v41 ^ v39 ^ v40), 21);
  v43 = v42 + __ROR4__(v39 + v77 - 155497632 + (v42 ^ v40 ^ v41), 16);
  v44 = v43 + __ROR4__(v40 + v80 - 1094730640 + (v43 ^ v41 ^ v42), 9);
  v45 = v44 + __ROR4__(v41 + v83 + 681279174 + (v44 ^ v42 ^ v43), 28);
  v46 = v45 + __ROR4__(v42 + *a2 - 358537222 + (v45 ^ v43 ^ v44), 21);
  v47 = v46 + __ROR4__(v43 + v73 - 722521979 + (v46 ^ v44 ^ v45), 16);
  v48 = v47 + __ROR4__(v44 + v76 + 76029189 + (v47 ^ v45 ^ v46), 9);
  v49 = v48 + __ROR4__(v45 + v79 - 640364487 + (v48 ^ v46 ^ v47), 28);
  v50 = v49 + __ROR4__(v46 + v82 - 421815835 + (v49 ^ v47 ^ v48), 21);
  v51 = v50 + __ROR4__(v47 + v20 + 530742520 + (v50 ^ v48 ^ v49), 16);
  v52 = v51 + __ROR4__(v48 + v72 - 995338651 + (v51 ^ v49 ^ v50), 9);
  v53 = v52 + __ROR4__(v49 + *a2 - 198630844 + (v51 ^ (v52 | ~v50)), 26);
  v54 = v53 + __ROR4__(v50 + v77 + 1126891415 + (v52 ^ (v53 | ~v51)), 22);
  v55 = v54 + __ROR4__(v51 + v84 - 1416354905 + (v53 ^ (v54 | ~v52)), 17);
  v56 = v55 + __ROR4__(v52 + v75 - 57434055 + (v54 ^ (v55 | ~v53)), 11);
  v57 = v56 + __ROR4__(v53 + v82 + 1700485571 + (v55 ^ (v56 | ~v54)), 26);
  v58 = v57 + __ROR4__(v54 + v73 - 1894986606 + (v56 ^ (v57 | ~v55)), 22);
  v59 = v58 + __ROR4__(v55 + v80 - 1051523 + (v57 ^ (v58 | ~v56)), 17);
  v60 = v59 + __ROR4__(v56 + v71 - 2054922799 + (v58 ^ (v59 | ~v57)), 11);
  v61 = v60 + __ROR4__(v57 + v78 + 1873313359 + (v59 ^ (v60 | ~v58)), 26);
  v62 = v61 + __ROR4__(v58 + v20 - 30611744 + (v60 ^ (v61 | ~v59)), 22);
  v63 = v62 + __ROR4__(v59 + v76 - 1560198380 + (v61 ^ (v62 | ~v60)), 17);
  v64 = v63 + __ROR4__(v60 + v83 + 1309151649 + (v62 ^ (v63 | ~v61)), 11);
  v65 = v64 + __ROR4__(v61 + v74 - 145523070 + (v63 ^ (v64 | ~v62)), 26);
  v66 = v65 + __ROR4__(v62 + v81 - 1120210379 + (v64 ^ (v65 | ~v63)), 22);
  v67 = v66 + __ROR4__(v63 + v72 + 718787259 + (v65 ^ (v66 | ~v64)), 17);
  *a1 += v65;
  a1[1] += v67 + __ROR4__(v64 + v79 - 343485551 + (v66 ^ (v67 | ~v65)), 11);
  result = a1 + 2;
  a1[2] += v67;
  a1[3] += v66;
  return result;
}

//----- (08068428) --------------------------------------------------------
int __cdecl caml_MD5Final(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  char *v3; // edx
  size_t v4; // ecx
  _BYTE *v5; // edi
  unsigned int v6; // edx
  _WORD *v7; // edi
  int result; // eax

  v2 = (a2[4] >> 3) & 0x3F;
  *((_BYTE *)a2 + v2 + 24) = 0x80;
  v3 = (char *)a2 + v2 + 25;
  v4 = 63 - v2;
  if ( (unsigned int)(63 - v2) > 7 )
  {
    memset(v3, 0, v4 - 8);
  }
  else
  {
    memset(v3, 0, v4);
    v5 = a2 + 6;
    caml_MD5Transform(a2, a2 + 6);
    v6 = 56;
    if ( ((unsigned int)(a2 + 6) & 1) != 0 )
    {
      *v5 = 0;
      v5 = (char *)a2 + 25;
      v6 = 55;
    }
    if ( ((unsigned __int8)v5 & 2) != 0 )
    {
      *(_WORD *)v5 = 0;
      v5 += 2;
      v6 -= 2;
    }
    memset(v5, 0, 4 * (v6 >> 2));
    v7 = &v5[4 * (v6 >> 2)];
    if ( (v6 & 2) != 0 )
      *v7++ = 0;
    if ( (v6 & 1) != 0 )
      *(_BYTE *)v7 = 0;
  }
  a2[20] = a2[4];
  a2[21] = a2[5];
  caml_MD5Transform(a2, a2 + 6);
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  result = a2[3];
  a1[3] = result;
  *a2 = 0;
  return result;
}

//----- (08068516) --------------------------------------------------------
void *__cdecl caml_MD5Update(int a1, void *src, size_t n)
{
  size_t v3; // edi
  size_t v4; // ebx
  size_t v5; // eax
  int v6; // ebx
  void *v7; // eax
  size_t v8; // edx
  size_t v9; // ebx
  int v11; // esi
  size_t v12; // edi

  v3 = n;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = v4 + 8 * n;
  *(_DWORD *)(a1 + 16) = v5;
  if ( v4 > v5 )
    ++*(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 20) += n >> 29;
  v6 = (v4 >> 3) & 0x3F;
  if ( v6 )
  {
    v7 = (void *)(a1 + v6 + 24);
    v8 = 64 - v6;
    v9 = v8;
    if ( n < v8 )
      return memcpy(v7, src, n);
    memcpy(v7, src, v8);
    caml_MD5Transform((_DWORD *)a1, (_DWORD *)(a1 + 24));
    src = (char *)src + v9;
    v3 = n - v9;
  }
  if ( v3 > 0x3F )
  {
    v11 = 0;
    do
    {
      *(_DWORD *)(a1 + 24) = *(_DWORD *)((char *)src + v11);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)src + v11 + 4);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)((char *)src + v11 + 8);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)((char *)src + v11 + 12);
      *(_DWORD *)(a1 + 40) = *(_DWORD *)((char *)src + v11 + 16);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)((char *)src + v11 + 20);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)((char *)src + v11 + 24);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)((char *)src + v11 + 28);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)((char *)src + v11 + 32);
      *(_DWORD *)(a1 + 60) = *(_DWORD *)((char *)src + v11 + 36);
      *(_DWORD *)(a1 + 64) = *(_DWORD *)((char *)src + v11 + 40);
      *(_DWORD *)(a1 + 68) = *(_DWORD *)((char *)src + v11 + 44);
      *(_DWORD *)(a1 + 72) = *(_DWORD *)((char *)src + v11 + 48);
      *(_DWORD *)(a1 + 76) = *(_DWORD *)((char *)src + v11 + 52);
      *(_DWORD *)(a1 + 80) = *(_DWORD *)((char *)src + v11 + 56);
      *(_DWORD *)(a1 + 84) = *(_DWORD *)((char *)src + v11 + 60);
      caml_MD5Transform((_DWORD *)a1, (_DWORD *)(a1 + 24));
      v11 += 64;
    }
    while ( v3 - v11 > 0x3F );
    v12 = v3 - 64;
    src = (char *)src + (v12 & 0xFFFFFFC0) + 64;
    v3 = v12 & 0x3F;
  }
  return memcpy((void *)(a1 + 24), src, v3);
}

//----- (0806867A) --------------------------------------------------------
_DWORD *__cdecl caml_md5_chan(int a1, int a2)
{
  int v2; // ebx
  size_t v3; // eax
  size_t v4; // eax
  int v5; // eax
  int v6; // esi
  _DWORD *v7; // ebx
  void (__cdecl *v9)(_DWORD, _DWORD *); // [esp+0h] [ebp-10B8h]
  int v10; // [esp+4h] [ebp-10B4h]
  unsigned int v11; // [esp+8h] [ebp-10B0h]
  int v12; // [esp+Ch] [ebp-10ACh]
  _DWORD *v13; // [esp+10h] [ebp-10A8h]
  int v14; // [esp+18h] [ebp-10A0h]
  int v15; // [esp+1Ch] [ebp-109Ch]
  char src[4096]; // [esp+28h] [ebp-1090h] BYREF
  int v17[22]; // [esp+1028h] [ebp-90h] BYREF
  int v18[14]; // [esp+1080h] [ebp-38h] BYREF

  v14 = caml_local_roots;
  v18[0] = caml_local_roots;
  caml_local_roots = (int)v18;
  v18[2] = 1;
  v18[1] = 2;
  v18[3] = (int)&a1;
  v18[4] = (int)&a2;
  v15 = *(_DWORD *)(a1 + 4);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v15);
  _Z8MD5_InitP12md5Context_t(v17);
  v2 = a2 >> 1;
  if ( a2 >> 1 < 0 )
  {
    while ( 1 )
    {
      v3 = caml_getblock(v15, src, 0x1000u);
      if ( !v3 )
        break;
      caml_MD5Update((int)v17, src, v3);
    }
  }
  else
  {
    for ( ; v2 > 0; v2 -= v6 )
    {
      v4 = 4096;
      if ( (unsigned int)v2 <= 0x1000 )
        v4 = v2;
      v5 = caml_getblock(v15, src, v4);
      v6 = v5;
      if ( !v5 )
        v5 = caml_raise_end_of_file(v9, v10, v11, v12, v13);
      caml_MD5Update((int)v17, src, v5);
    }
  }
  v7 = (_DWORD *)caml_alloc_string(16);
  caml_MD5Final(v7, v17);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v15);
  caml_local_roots = v14;
  return v7;
}
// 8068760: variable 'v9' is possibly undefined
// 8068760: variable 'v10' is possibly undefined
// 8068760: variable 'v11' is possibly undefined
// 8068760: variable 'v12' is possibly undefined
// 8068760: variable 'v13' is possibly undefined
// 8074754: using guessed type int caml_local_roots;
// 8078D28: using guessed type int (__cdecl *caml_channel_mutex_lock)(_DWORD);
// 8078D2C: using guessed type int (__cdecl *caml_channel_mutex_unlock)(_DWORD);

//----- (080687CD) --------------------------------------------------------
_DWORD *__cdecl caml_md5_string(int a1, int a2, int a3)
{
  _DWORD *v3; // esi
  int v5[22]; // [esp+18h] [ebp-60h] BYREF

  _Z8MD5_InitP12md5Context_t(v5);
  caml_MD5Update((int)v5, (void *)(a1 + (a2 >> 1)), a3 >> 1);
  v3 = (_DWORD *)caml_alloc_string(16);
  caml_MD5Final(v3, v5);
  return v3;
}

//----- (08068828) --------------------------------------------------------
int __usercall add_char@<eax>(int result@<eax>, char a2@<dl>)
{
  _BYTE *v2; // ecx

  v2 = *(_BYTE **)result;
  if ( *(_DWORD *)result < *(_DWORD *)(result + 4) )
  {
    *v2 = a2;
    *(_DWORD *)result = v2 + 1;
  }
  return result;
}

//----- (0806883B) --------------------------------------------------------
void *__usercall add_string@<eax>(int a1@<eax>, const char *a2@<edx>)
{
  signed int v3; // ebx
  void *result; // eax

  v3 = strlen(a2);
  result = *(void **)a1;
  if ( *(_DWORD *)(a1 + 4) < (unsigned int)(*(_DWORD *)a1 + v3) )
    v3 = *(_DWORD *)(a1 + 4) - *(_DWORD *)a1;
  if ( v3 > 0 )
    result = memmove(result, a2, v3);
  *(_DWORD *)a1 += v3;
  return result;
}

//----- (08068892) --------------------------------------------------------
void *__cdecl caml_format_exception(int a1)
{
  unsigned int v1; // eax
  int v2; // esi
  _DWORD *v3; // edi
  unsigned int v4; // esi
  const char *v5; // ebx
  size_t v6; // esi
  void *v7; // ebx
  int v9; // [esp+18h] [ebp-170h]
  unsigned int v10; // [esp+1Ch] [ebp-16Ch]
  char s[64]; // [esp+28h] [ebp-160h] BYREF
  int v12[2]; // [esp+68h] [ebp-120h] BYREF
  char src[255]; // [esp+70h] [ebp-118h] BYREF
  char v14; // [esp+16Fh] [ebp-19h] BYREF
  char v15; // [esp+170h] [ebp-18h] BYREF

  v12[0] = (int)src;
  v12[1] = (int)&v14;
  add_string((int)v12, **(const char ***)a1);
  v1 = *(_DWORD *)(a1 - 4) >> 10;
  if ( v1 > 1 )
  {
    if ( v1 != 2 || (v2 = *(_DWORD *)(a1 + 4), (v2 & 1) != 0) || (v10 = 0, *(_BYTE *)(v2 - 4)) )
    {
      v2 = a1;
      v10 = 1;
    }
    add_char((int)v12, 40);
    v9 = v2;
    v3 = (_DWORD *)(v2 - 4);
    if ( v10 < *(_DWORD *)(v2 - 4) >> 10 )
    {
      v4 = v10;
      while ( 1 )
      {
        v5 = *(const char **)(v9 + 4 * v4);
        if ( ((unsigned __int8)v5 & 1) != 0 )
        {
          sprintf(s, "%ld", (int)v5 >> 1);
          add_string((int)v12, s);
        }
        else if ( *(v5 - 4) == -4 )
        {
          add_char((int)v12, 34);
          add_string((int)v12, v5);
          add_char((int)v12, 34);
        }
        else
        {
          add_char((int)v12, 95);
        }
        if ( *v3 >> 10 <= ++v4 )
          break;
        if ( v10 < v4 )
          add_string((int)v12, ", ");
      }
    }
    add_char((int)v12, 41);
  }
  *(_BYTE *)v12[0] = 0;
  v6 = v12[0] - (_DWORD)&v15 + 257;
  v7 = malloc(v6);
  if ( v7 )
    memmove(v7, src, v6);
  return v7;
}

//----- (08068A39) --------------------------------------------------------
void __cdecl __noreturn caml_fatal_uncaught_exception(int a1)
{
  char *v1; // ebx
  int v2; // esi
  int v3; // edi

  v1 = (char *)caml_format_exception(a1);
  v2 = caml_backtrace_active;
  v3 = caml_backtrace_pos;
  caml_backtrace_active = 0;
  if ( caml_named_value("Pervasives.do_at_exit") )
    caml_callback_exn();
  caml_backtrace_active = v2;
  caml_backtrace_pos = v3;
  fprintf(stderr, "Fatal error: exception %s\n", v1);
  free(v1);
  if ( caml_backtrace_active )
    caml_print_exception_backtrace();
  exit(2);
}
// 807AE84: using guessed type int caml_backtrace_active;
// 807AE88: using guessed type int caml_backtrace_pos;

//----- (08068AE0) --------------------------------------------------------
unsigned int __usercall hash_value_name@<eax>(char *a1@<eax>)
{
  char v1; // dl
  unsigned int i; // ecx

  v1 = *a1;
  for ( i = 0; *a1; v1 = *a1 )
  {
    i = 19 * i + v1;
    ++a1;
  }
  return i % 0xD;
}

//----- (08068B20) --------------------------------------------------------
int __cdecl caml_named_value(char *s1)
{
  int v1; // ebx

  v1 = named_value_table[hash_value_name(s1)];
  if ( !v1 )
    return 0;
  while ( strcmp(s1, (const char *)(v1 + 8)) )
  {
    v1 = *(_DWORD *)(v1 + 4);
    if ( !v1 )
      return 0;
  }
  return v1;
}

//----- (08068B67) --------------------------------------------------------
int __cdecl caml_register_named_value(char *s1, int a2)
{
  int v2; // ebx
  char *v3; // ebx
  unsigned int v5; // [esp+1Ch] [ebp-1Ch]

  v5 = hash_value_name(s1);
  v2 = named_value_table[v5];
  if ( v2 )
  {
    while ( strcmp(s1, (const char *)(v2 + 8)) )
    {
      v2 = *(_DWORD *)(v2 + 4);
      if ( !v2 )
        goto LABEL_5;
    }
    *(_DWORD *)v2 = a2;
  }
  else
  {
LABEL_5:
    v3 = (char *)caml_stat_alloc(strlen(s1) + 12);
    strcpy(v3 + 8, s1);
    *(_DWORD *)v3 = a2;
    *((_DWORD *)v3 + 1) = named_value_table[v5];
    named_value_table[v5] = (int)v3;
    caml_register_global_root((unsigned int)v3);
  }
  return 1;
}

//----- (08068C00) --------------------------------------------------------
void __cdecl caml_callback3(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  _DWORD *v5; // [esp+10h] [ebp-8h]

  caml_callback3_exn();
  if ( (v4 & 3) == 2 )
    caml_raise(v4 & 0xFFFFFFFC, a2, a3, a4, v5);
}
// 8068C28: variable 'v4' is possibly undefined
// 8068C36: variable 'v5' is possibly undefined

//----- (08068C3D) --------------------------------------------------------
void __cdecl caml_callback2(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  caml_callback2_exn();
  if ( (v3 & 3) == 2 )
    caml_raise(v3 & 0xFFFFFFFC, a2, a3, v4, v5);
}
// 8068C5E: variable 'v3' is possibly undefined
// 8068C6C: variable 'v4' is possibly undefined
// 8068C6C: variable 'v5' is possibly undefined

//----- (08068C73) --------------------------------------------------------
void __cdecl caml_callback(int a1, int a2)
{
  int v2; // eax
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  caml_callback_exn();
  if ( (v2 & 3) == 2 )
    caml_raise(v2 & 0xFFFFFFFC, a2, v3, v4, v5);
}
// 8068C8D: variable 'v2' is possibly undefined
// 8068C9B: variable 'v3' is possibly undefined
// 8068C9B: variable 'v4' is possibly undefined
// 8068C9B: variable 'v5' is possibly undefined

//----- (08068CA2) --------------------------------------------------------
void __cdecl caml_callbackN_exn(int a1, int a2, int a3)
{
  int v3; // edi
  int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // [esp+1Ch] [ebp-8Ch]
  int v9[8]; // [esp+2Ch] [ebp-7Ch] BYREF
  int v10; // [esp+4Ch] [ebp-5Ch] BYREF
  int v11[8]; // [esp+50h] [ebp-58h] BYREF
  int v12[14]; // [esp+70h] [ebp-38h] BYREF

  v3 = a2;
  v8 = caml_local_roots;
  caml_local_roots = (int)v9;
  v10 = a1;
  if ( a2 > 0 )
  {
    v12[0] = v8;
    v12[2] = 1;
    v12[1] = 1;
    v12[3] = (int)&a1;
    v11[0] = (int)v12;
    v11[2] = a2;
    v11[1] = 1;
    v11[3] = a3;
    v9[0] = (int)v11;
    v9[2] = 1;
    v9[1] = 1;
    v9[3] = (int)&v10;
    v4 = 0;
    do
    {
      if ( v3 - v4 == 1 )
      {
        caml_callback_exn();
        if ( (v5 & 3) == 2 )
        {
          caml_local_roots = v8;
          return;
        }
        v10 = v5;
        ++v4;
      }
      else if ( v3 - v4 == 2 )
      {
        caml_callback2_exn();
        if ( (v6 & 3) == 2 )
        {
          caml_local_roots = v8;
          return;
        }
        v10 = v6;
        v4 += 2;
      }
      else
      {
        caml_callback3_exn();
        if ( (v7 & 3) == 2 )
        {
          caml_local_roots = v8;
          return;
        }
        v10 = v7;
        v4 += 3;
      }
    }
    while ( v3 > v4 );
  }
  caml_local_roots = v8;
}
// 8068D48: variable 'v5' is possibly undefined
// 8068D85: variable 'v6' is possibly undefined
// 8068DC7: variable 'v7' is possibly undefined
// 8074754: using guessed type int caml_local_roots;

//----- (08068E04) --------------------------------------------------------
void __cdecl caml_callbackN(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  caml_callbackN_exn(a1, a2, a3);
  if ( (v3 & 3) == 2 )
    caml_raise(v3 & 0xFFFFFFFC, v4, v5, v6, v7);
}
// 8068E25: variable 'v3' is possibly undefined
// 8068E33: variable 'v4' is possibly undefined
// 8068E33: variable 'v5' is possibly undefined
// 8068E33: variable 'v6' is possibly undefined
// 8068E33: variable 'v7' is possibly undefined

//----- (08068E40) --------------------------------------------------------
int __cdecl caml_weak_check(int a1, int a2)
{
  unsigned int v2; // eax
  int v5; // [esp+4h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  _DWORD *v8; // [esp+10h] [ebp-8h]

  v2 = (a2 >> 1) + 1;
  if ( a2 >> 1 == -1 || v2 >= *(_DWORD *)(a1 - 4) >> 10 )
    v2 = caml_invalid_argument("Weak.get", v5, v6, v7, v8);
  return 2 * (*(_DWORD *)(a1 + 4 * v2) != (_DWORD)caml_weak_none) + 1;
}
// 8068E64: variable 'v5' is possibly undefined
// 8068E64: variable 'v6' is possibly undefined
// 8068E64: variable 'v7' is possibly undefined
// 8068E64: variable 'v8' is possibly undefined
// 8068E69: variable 'a1' is possibly undefined
// 8074564: using guessed type void *caml_weak_none;

//----- (08068E7E) --------------------------------------------------------
unsigned int __usercall do_set@<eax>(unsigned int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int *v3; // ebx
  int v4; // edx

  if ( (a3 & 1) != 0 || a3 >= caml_young_end || a3 <= caml_young_start )
  {
    *(_DWORD *)(result + 4 * a2) = a3;
  }
  else
  {
    v3 = (unsigned int *)(result + 4 * a2);
    result = *v3;
    *v3 = a3;
    if ( (result & 1) != 0 || result >= caml_young_end || result <= caml_young_start )
    {
      if ( dword_8077904 >= (unsigned int)dword_8077908 )
        caml_realloc_ref_table((int)caml_weak_ref_table);
      result = (unsigned int)&dword_8077904;
      v4 = dword_8077904;
      *(_DWORD *)dword_8077904 = v3;
      dword_8077904 = v4 + 4;
    }
  }
  return result;
}
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 8077904: using guessed type int dword_8077904;
// 8077908: using guessed type int dword_8077908;

//----- (08068EE7) --------------------------------------------------------
int __usercall caml_weak_blit@<eax>(int a1@<edi>, int a2, int a3, unsigned int a4, int a5, int a6)
{
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned int i; // eax
  void **v9; // edx
  unsigned int v10; // ebx
  unsigned int v11; // edx
  unsigned int j; // ebx
  unsigned int *v13; // ebx
  int v14; // esi
  int v15; // edi
  int v17; // [esp+4h] [ebp-64h]
  unsigned int v18; // [esp+8h] [ebp-60h]
  int v19; // [esp+Ch] [ebp-5Ch]
  _DWORD *v20; // [esp+10h] [ebp-58h]
  unsigned int v21; // [esp+48h] [ebp-20h]
  unsigned int v22; // [esp+4Ch] [ebp-1Ch]

  v6 = (a3 >> 1) + 1;
  if ( a3 >> 1 == -1 || (v22 = a6 >> 1, a1 = a2, v6 + (a6 >> 1) > *(_DWORD *)(a2 - 4) >> 10) )
    caml_invalid_argument("Weak.blit", v17, v18, v19, v20);
  v21 = (a5 >> 1) + 1;
  if ( a5 >> 1 == -1 || v21 + v22 > *(_DWORD *)(a4 - 4) >> 10 )
    caml_invalid_argument("Weak.blit", v17, v18, v19, v20);
  if ( !caml_gc_phase && caml_gc_subphase == 11 && v22 )
  {
    v7 = 0;
    for ( i = 0; i < v22; v7 = i )
    {
      v9 = (void **)(a1 + 4 * (v6 + v7));
      v10 = (unsigned int)*v9;
      if ( *v9 != caml_weak_none
        && (v10 & 1) == 0
        && (*(_BYTE *)(caml_page_table[v10 >> 23] + ((v10 >> 12) & 0x7FF)) & 1) != 0
        && (*((_DWORD *)*v9 - 1) & 0x300) == 0 )
      {
        *v9 = caml_weak_none;
      }
      ++i;
    }
  }
  if ( v6 <= v21 )
  {
    if ( (int)(v22 - 1) >= 0 )
    {
      v13 = (unsigned int *)(a1 + 4 * ((a3 >> 1) + v22));
      v14 = (a5 >> 1) + v22;
      v15 = v22 - 1;
      do
      {
        do_set(a4, v14--, *v13--);
        --v15;
      }
      while ( v15 >= 0 );
    }
  }
  else if ( v22 )
  {
    v11 = 0;
    for ( j = 0; j < v22; v11 = j )
    {
      do_set(a4, v21 + v11, *(_DWORD *)(a1 + 4 * (v11 + v6)));
      ++j;
    }
  }
  return 1;
}
// 8068F1F: variable 'v17' is possibly undefined
// 8068F1F: variable 'v18' is possibly undefined
// 8068F1F: variable 'v19' is possibly undefined
// 8068F1F: variable 'v20' is possibly undefined
// 8068F37: variable 'v22' is possibly undefined
// 8074564: using guessed type void *caml_weak_none;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0806903B) --------------------------------------------------------
int __usercall caml_weak_set@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, int a3, int a4, unsigned int *a5)
{
  int v5; // eax
  unsigned int v7; // edx
  int v9; // [esp+4h] [ebp-14h]
  unsigned int v10; // [esp+8h] [ebp-10h]
  int v11; // [esp+Ch] [ebp-Ch]

  v5 = a3;
  v7 = (a4 >> 1) + 1;
  if ( a4 >> 1 == -1 || (a2 = a3, v7 >= *(_DWORD *)(a3 - 4) >> 10) )
    v5 = caml_invalid_argument("Weak.set", v9, v10, v11, a1);
  if ( a5 == (unsigned int *)1 || ((unsigned __int8)a5 & 1) != 0 )
    *(_DWORD *)(a2 + 4 * v7) = caml_weak_none;
  else
    do_set(v5, v7, *a5);
  return 1;
}
// 806903B: could not find valid save-restore pair for ebx
// 806906A: variable 'v9' is possibly undefined
// 806906A: variable 'v10' is possibly undefined
// 806906A: variable 'v11' is possibly undefined
// 8069072: variable 'a5' is possibly undefined
// 806907B: variable 'v7' is possibly undefined
// 8074564: using guessed type void *caml_weak_none;

//----- (08069099) --------------------------------------------------------
int __cdecl caml_weak_get_copy(int a1, int a2)
{
  int v2; // ebx
  unsigned int v3; // esi
  int v4; // eax
  int v5; // esi
  unsigned int v6; // eax
  char *v8; // eax
  char *v9; // edx
  char *v10; // ecx
  unsigned int v11; // esi
  int v12; // edi
  unsigned int v13; // ebx
  int v14; // eax
  int v15; // [esp+4h] [ebp-84h]
  unsigned int v16; // [esp+8h] [ebp-80h]
  int v17; // [esp+Ch] [ebp-7Ch]
  _DWORD *v18; // [esp+10h] [ebp-78h]
  int v19; // [esp+10h] [ebp-78h]
  int v20; // [esp+14h] [ebp-74h]
  char *v21; // [esp+18h] [ebp-70h]
  unsigned int v22; // [esp+1Ch] [ebp-6Ch]
  int v23[8]; // [esp+28h] [ebp-60h] BYREF
  unsigned int v24; // [esp+48h] [ebp-40h] BYREF
  unsigned int *v25; // [esp+4Ch] [ebp-3Ch] BYREF
  int v26[14]; // [esp+50h] [ebp-38h] BYREF

  v2 = caml_local_roots;
  v26[0] = caml_local_roots;
  v26[2] = 1;
  v26[1] = 2;
  v26[3] = (int)&a1;
  v26[4] = (int)&a2;
  v25 = 0;
  v24 = 0;
  v23[0] = (int)v26;
  caml_local_roots = (int)v23;
  v23[2] = 1;
  v23[1] = 2;
  v23[3] = (int)&v25;
  v23[4] = (int)&v24;
  v3 = (a2 >> 1) + 1;
  if ( a2 >> 1 == -1 || (v4 = a1, v3 >= *(_DWORD *)(a1 - 4) >> 10) )
    v4 = caml_invalid_argument("Weak.get", v15, v16, v17, v18);
  v5 = 4 * v3;
  v6 = *(_DWORD *)(v5 + v4);
  if ( (void *)v6 == caml_weak_none )
  {
    caml_local_roots = v2;
    return 1;
  }
  if ( (v6 & 1) != 0 || (*(_BYTE *)(caml_page_table[v6 >> 23] + ((v6 >> 12) & 0x7FF)) & 3) == 0 )
  {
    v24 = v6;
  }
  else
  {
    v8 = caml_alloc(*(_DWORD *)(v6 - 4) >> 10, *(unsigned __int8 *)(v6 - 4));
    v24 = (unsigned int)v8;
    v9 = *(char **)(v5 + a1);
    if ( v9 == caml_weak_none )
    {
      caml_local_roots = v2;
      return 1;
    }
    v20 = *(_DWORD *)(v5 + a1);
    v10 = v9 - 4;
    if ( (unsigned __int8)*(v9 - 4) > 0xFAu )
    {
      memmove(v8, v9, 4 * (*(_DWORD *)v10 >> 10));
    }
    else
    {
      v21 = v9 - 4;
      if ( *(_DWORD *)v10 >> 10 )
      {
        v11 = 0;
        v19 = v2;
        do
        {
          v12 = 4 * v11;
          v13 = *(_DWORD *)(v20 + 4 * v11);
          if ( !caml_gc_phase
            && (v13 & 1) == 0
            && (*(_BYTE *)(caml_page_table[v13 >> 23] + ((v13 >> 12) & 0x7FF)) & 1) != 0 )
          {
            caml_darken(v13);
          }
          v22 = *(_DWORD *)(v24 + 4 * v11);
          *(_DWORD *)(v24 + 4 * v11) = v13;
          if ( (*(_BYTE *)(caml_page_table[(v24 + v12) >> 23] + (((v24 + v12) >> 12) & 0x7FF)) & 1) != 0 )
          {
            if ( !caml_gc_phase )
              caml_darken(v22);
            if ( (v13 & 1) == 0
              && v13 < caml_young_end
              && v13 > caml_young_start
              && ((v22 & 1) != 0 || caml_young_end <= v22 || caml_young_start >= v22) )
            {
              if ( dword_80778E8 >= (unsigned int)dword_80778EC )
                caml_realloc_ref_table((int)caml_ref_table);
              v14 = dword_80778E8;
              *(_DWORD *)dword_80778E8 = v24 + v12;
              dword_80778E8 = v14 + 4;
            }
          }
          ++v11;
        }
        while ( *(_DWORD *)v21 >> 10 > v11 );
        v2 = v19;
      }
    }
  }
  v25 = (unsigned int *)caml_alloc_small(1, 0);
  *v25 = v24;
  caml_local_roots = v2;
  return (int)v25;
}
// 8069119: variable 'v15' is possibly undefined
// 8069119: variable 'v16' is possibly undefined
// 8069119: variable 'v17' is possibly undefined
// 8069119: variable 'v18' is possibly undefined
// 8074564: using guessed type void *caml_weak_none;
// 8074754: using guessed type int caml_local_roots;
// 80778CC: using guessed type int caml_young_start;
// 80778D0: using guessed type int caml_young_end;
// 80778E8: using guessed type int dword_80778E8;
// 80778EC: using guessed type int dword_80778EC;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0806930B) --------------------------------------------------------
int __cdecl caml_weak_get(int a1, int a2)
{
  int v2; // ebx
  unsigned int v3; // eax
  int v4; // edx
  unsigned int v5; // eax
  int v7; // [esp+4h] [ebp-64h]
  unsigned int v8; // [esp+8h] [ebp-60h]
  int v9; // [esp+Ch] [ebp-5Ch]
  _DWORD *v10; // [esp+10h] [ebp-58h]
  int v11[8]; // [esp+18h] [ebp-50h] BYREF
  unsigned int v12; // [esp+38h] [ebp-30h] BYREF
  int v13; // [esp+3Ch] [ebp-2Ch] BYREF
  int v14[10]; // [esp+40h] [ebp-28h] BYREF

  v2 = caml_local_roots;
  v14[0] = caml_local_roots;
  v14[2] = 1;
  v14[1] = 2;
  v14[3] = (int)&a1;
  v14[4] = (int)&a2;
  v13 = 0;
  v12 = 0;
  v11[0] = (int)v14;
  caml_local_roots = (int)v11;
  v11[2] = 1;
  v11[1] = 2;
  v11[3] = (int)&v13;
  v11[4] = (int)&v12;
  v3 = (a2 >> 1) + 1;
  if ( a2 >> 1 == -1 || (v4 = a1, v3 >= *(_DWORD *)(a1 - 4) >> 10) )
    v3 = caml_invalid_argument("Weak.get", v7, v8, v9, v10);
  v5 = *(_DWORD *)(v4 + 4 * v3);
  if ( (void *)v5 == caml_weak_none )
  {
    v13 = 1;
  }
  else
  {
    v12 = v5;
    if ( !caml_gc_phase && (v5 & 1) == 0 && (*(_BYTE *)(caml_page_table[v5 >> 23] + ((v5 >> 12) & 0x7FF)) & 1) != 0 )
      caml_darken(v5);
    v13 = caml_alloc_small(1, 0);
    *(_DWORD *)v13 = v12;
  }
  caml_local_roots = v2;
  return v13;
}
// 806938A: variable 'v7' is possibly undefined
// 806938A: variable 'v8' is possibly undefined
// 806938A: variable 'v9' is possibly undefined
// 806938A: variable 'v10' is possibly undefined
// 806938F: variable 'v4' is possibly undefined
// 8074564: using guessed type void *caml_weak_none;
// 8074754: using guessed type int caml_local_roots;
// 807B49C: using guessed type int caml_gc_phase;

//----- (0806940B) --------------------------------------------------------
int *__cdecl caml_weak_create(int a1)
{
  unsigned int v1; // ebx
  int *result; // eax
  unsigned int i; // edx
  int v4; // [esp+4h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+10h] [ebp-8h]

  v1 = (a1 >> 1) + 1;
  if ( (unsigned int)(a1 >> 1) > 0x3FFFFE )
    caml_invalid_argument("Weak.create", v4, v5, v6, v7);
  result = caml_alloc_shr(v1, 251);
  if ( v1 > 1 )
  {
    for ( i = 1; i < v1; ++i )
      result[i] = (int)caml_weak_none;
  }
  *result = caml_weak_list_head;
  caml_weak_list_head = (int)result;
  return result;
}
// 8069428: variable 'v4' is possibly undefined
// 8069428: variable 'v5' is possibly undefined
// 8069428: variable 'v6' is possibly undefined
// 8069428: variable 'v7' is possibly undefined
// 8074564: using guessed type void *caml_weak_none;
// 807AE54: using guessed type int caml_weak_list_head;

//----- (08069470) --------------------------------------------------------
unsigned int __usercall invert_pointer_at@<eax>(unsigned int result@<eax>)
{
  unsigned int v1; // ecx
  unsigned int *v2; // esi
  unsigned int v3; // edi
  unsigned int v4; // edi
  unsigned int v5; // edx
  unsigned int *v6; // ebx
  unsigned int *v7; // [esp+0h] [ebp-14h]

  v1 = *(_DWORD *)result;
  if ( (*(_DWORD *)result & 3) == 0 && (*(_BYTE *)(caml_page_table[v1 >> 23] + ((v1 >> 12) & 0x7FF)) & 1) != 0 )
  {
    v2 = (unsigned int *)(v1 - 4);
    v3 = *(_DWORD *)(v1 - 4);
    if ( (v3 & 3) == 1 )
    {
      v4 = v1 - 4 * (v3 >> 10);
      v7 = (unsigned int *)(v4 - 4);
      v5 = *(_DWORD *)(v4 - 4);
      if ( (v5 & 3) == 0 )
      {
        do
        {
          v6 = (unsigned int *)v5;
          v5 = *(_DWORD *)v5;
        }
        while ( (v5 & 3) == 0 );
        v7 = v6;
      }
      if ( (unsigned __int8)(v5 >> 2) == 0xF7 )
        *(_DWORD *)result = v5;
      else
        *(_DWORD *)result = (v4 + 4 * (v5 >> 10)) | 1;
      *v2 = result | 2;
      result = ((((v1 - v4) >> 2) - 1) << 10) | 0x3E7;
      *v7 = result;
    }
    else if ( (v3 & 3) != 0 && (v3 & 3) == 2 )
    {
      *(_DWORD *)result = v3;
      result |= 2u;
      *v2 = result;
    }
    else
    {
      *(_DWORD *)result = v3;
      *v2 = result;
    }
  }
  return result;
}
// 80694CB: conditional instruction was optimized away because of 'edx.4==3'

//----- (0806955F) --------------------------------------------------------
unsigned int __cdecl invert_root(int a1, unsigned int a2)
{
  return invert_pointer_at(a2);
}

//----- (0806956C) --------------------------------------------------------
void *init_compact_allocate()
{
  char *v0; // eax
  char *v1; // eax
  void *result; // eax

  v0 = (char *)caml_heap_start;
  if ( caml_heap_start )
  {
    do
    {
      v1 = v0 - 16;
      *((_DWORD *)v1 + 1) = 0;
      v0 = (char *)*((_DWORD *)v1 + 3);
    }
    while ( v0 );
  }
  result = caml_heap_start;
  compact_fl = (int)caml_heap_start;
  return result;
}
// 807AE5C: using guessed type int compact_fl;

//----- (08069595) --------------------------------------------------------
int __usercall compact_allocate@<eax>(unsigned int a1@<eax>)
{
  int i; // ecx
  int v2; // esi
  int v3; // edx
  int v4; // ebx
  int v5; // edx
  int j; // ebx

  i = compact_fl;
  if ( (unsigned int)(*(_DWORD *)(compact_fl - 16 + 8) - *(_DWORD *)(compact_fl - 16 + 4)) <= 0x10 )
  {
    v2 = *(_DWORD *)(compact_fl - 16 + 12);
    v3 = v2 - 16;
    if ( (unsigned int)(*(_DWORD *)(v2 - 16 + 8) - *(_DWORD *)(v2 - 16 + 4)) <= 0x10 )
    {
      for ( i = *(_DWORD *)(compact_fl - 16 + 12); ; i = v4 )
      {
        v4 = *(_DWORD *)(v3 + 12);
        v3 = v4 - 16;
        if ( (unsigned int)(*(_DWORD *)(v4 - 16 + 8) - *(_DWORD *)(v4 - 16 + 4)) > 0x10 )
          break;
        v2 = v4;
      }
      compact_fl = v2;
    }
  }
  v5 = i - 16;
  for ( j = *(_DWORD *)(i - 16 + 4); *(_DWORD *)(i - 16 + 8) - j < a1; j = *(_DWORD *)(i - 16 + 4) )
  {
    i = *(_DWORD *)(v5 + 12);
    v5 = i - 16;
  }
  *(_DWORD *)(v5 + 4) = j + a1;
  return i + j;
}
// 807AE5C: using guessed type int compact_fl;

//----- (08069610) --------------------------------------------------------
int caml_compact_heap()
{
  int *v0; // eax
  int *v1; // edi
  char *i; // esi
  unsigned int v3; // ecx
  int v4; // edx
  unsigned int *v5; // eax
  unsigned int j; // eax
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int k; // eax
  unsigned int v10; // ebx
  unsigned int l; // esi
  unsigned int m; // edi
  unsigned int v13; // edi
  void **v14; // ebx
  unsigned int n; // esi
  unsigned int *v16; // ebx
  unsigned int v17; // eax
  int v18; // edx
  unsigned int ii; // eax
  int v20; // eax
  _DWORD *v21; // edx
  _DWORD *v22; // ecx
  unsigned int jj; // ecx
  _DWORD *v24; // edi
  _DWORD *v25; // edx
  unsigned int *v26; // ebx
  char *v27; // esi
  unsigned int v28; // eax
  unsigned int v29; // edi
  void *v30; // eax
  _DWORD *v31; // ecx
  char *v32; // edx
  unsigned int v33; // eax
  char *v34; // edx
  unsigned int v35; // esi
  unsigned int v36; // edi
  _DWORD *v37; // esi
  _DWORD *v38; // ebx
  unsigned int v39; // edx
  unsigned int v40; // eax
  int v42; // esi
  unsigned int *v43; // [esp+1Ch] [ebp-2Ch]
  char *v44; // [esp+20h] [ebp-28h]
  char *v45; // [esp+24h] [ebp-24h]
  int v46; // [esp+24h] [ebp-24h]
  char *v47; // [esp+28h] [ebp-20h]
  int *v48; // [esp+28h] [ebp-20h]
  unsigned int *v49; // [esp+28h] [ebp-20h]
  unsigned int *v50; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v51; // [esp+2Ch] [ebp-1Ch]
  unsigned int *v52; // [esp+2Ch] [ebp-1Ch]

  caml_gc_message(16, "Compacting heap...\n", 0);
  v0 = (int *)caml_heap_start;
  if ( caml_heap_start )
  {
    do
    {
      v1 = v0 - 4;
      for ( i = (char *)v0 + *(v0 - 2); i > (char *)v0; v0 += v3 + 1 )
      {
        v3 = (unsigned int)*v0 >> 10;
        if ( (*v0 & 0x300) == 512 )
          v4 = (v3 << 10) | 0x3F3;
        else
          v4 = (v3 << 10) | (4 * (unsigned __int8)*v0) | 3;
        *v0 = v4;
      }
      v0 = (int *)v1[3];
    }
    while ( v0 );
  }
  caml_do_roots((void (__cdecl *)(int, char *))invert_root);
  caml_final_do_weak_roots((int (__cdecl *)(_DWORD, char *))invert_root);
  v5 = (unsigned int *)caml_heap_start;
  if ( caml_heap_start )
  {
    do
    {
      v50 = v5;
      v45 = (char *)(v5 - 4);
      v47 = (char *)v5 + *(v5 - 2);
      if ( v47 > (char *)v5 )
      {
        do
        {
          for ( j = *v50; (j & 3) == 0; j = *(_DWORD *)j )
            ;
          v7 = (j >> 10) + 1;
          v8 = (unsigned __int8)(j >> 2);
          if ( v8 == 249 )
          {
            for ( k = v50[v7]; (k & 3) != 3; k = *(_DWORD *)(k & 0xFFFFFFFC) )
              ;
            v7 = (k >> 10) + 1;
            v8 = (unsigned __int8)(k >> 2);
          }
          if ( v8 <= 0xFA && v7 > 1 )
          {
            v10 = (unsigned int)(v50 + 1);
            for ( l = 1; l < v7; ++l )
            {
              invert_pointer_at(v10);
              v10 += 4;
            }
          }
          v50 += v7;
        }
        while ( v47 > (char *)v50 );
      }
      v5 = (unsigned int *)*((_DWORD *)v45 + 3);
    }
    while ( v5 );
  }
  v51 = (_DWORD *)caml_weak_list_head;
  if ( caml_weak_list_head )
  {
    v48 = &caml_weak_list_head;
    do
    {
      for ( m = *(v51 - 1); (m & 3) == 0; m = *(_DWORD *)m )
        ;
      v13 = m >> 10;
      if ( v13 > 1 )
      {
        v14 = (void **)(v51 + 1);
        for ( n = 1; n < v13; ++n )
        {
          if ( *v14 != caml_weak_none )
            invert_pointer_at((unsigned int)v14);
          ++v14;
        }
      }
      invert_pointer_at((unsigned int)v48);
      v48 = v51;
      v51 = (_DWORD *)*v51;
    }
    while ( v51 );
  }
  init_compact_allocate();
  v16 = (unsigned int *)caml_heap_start;
  if ( caml_heap_start )
  {
    do
    {
      v43 = v16 - 4;
      v44 = (char *)v16 + *(v16 - 2);
      while ( v44 > (char *)v16 )
      {
        v17 = *v16;
        if ( (*v16 & 3) == 0 )
        {
          do
            v17 = *(_DWORD *)v17;
          while ( (v17 & 3) == 0 );
          v42 = (v17 >> 10) + 1;
          v46 = (unsigned __int8)(v17 >> 2);
          v49 = 0;
          if ( v46 != 249 )
            goto LABEL_42;
          goto LABEL_39;
        }
        v18 = (unsigned __int8)(v17 >> 2);
        if ( v18 == 249 )
        {
          v42 = (v17 >> 10) + 1;
LABEL_39:
          v49 = &v16[v42];
          for ( ii = *v49; (ii & 3) != 3; ii = *(_DWORD *)(ii & 0xFFFFFFFC) )
            ;
          v42 = (ii >> 10) + 1;
          v46 = (unsigned __int8)(ii >> 2);
LABEL_42:
          v20 = compact_allocate(4 * v42);
          v21 = (_DWORD *)*v16;
          if ( (*v16 & 3) == 0 )
          {
            while ( 1 )
            {
              v22 = (_DWORD *)*v21;
              *v21 = v20 + 4;
              if ( ((unsigned __int8)v22 & 3) != 0 )
                break;
              v21 = v22;
            }
          }
          *v16 = (v42 << 10) + v46 - 1024;
          if ( v49 )
          {
            for ( jj = (unsigned int)v49; (jj & 3) != 3; *v24 = ((v24 - v16) << 10) + 249 )
            {
              v24 = (_DWORD *)(jj & 0xFFFFFFFC);
              for ( jj = *(_DWORD *)(jj & 0xFFFFFFFC); (jj & 3) == 2; *v25 = v20 + 4 * (v24 - v16) + 4 )
              {
                v25 = (_DWORD *)(jj & 0xFFFFFFFC);
                jj = *(_DWORD *)(jj & 0xFFFFFFFC);
              }
            }
          }
          v16 += v42;
        }
        else
        {
          *v16 = v18 + (v17 & 0xFFFFFC00) + 512;
          v16 += (v17 >> 10) + 1;
        }
      }
      v16 = (unsigned int *)v43[3];
    }
    while ( v16 );
  }
  init_compact_allocate();
  v26 = (unsigned int *)caml_heap_start;
  if ( !caml_heap_start )
    goto LABEL_78;
  do
  {
    v52 = v26 - 4;
    v27 = (char *)v26 + *(v26 - 2);
    while ( v27 > (char *)v26 )
    {
      v28 = *v26;
      if ( (*v26 & 0x300) != 0 )
      {
        v26 += (v28 >> 10) + 1;
      }
      else
      {
        v29 = 4 * (v28 >> 10) + 4;
        v30 = (void *)compact_allocate(v29);
        memmove(v30, v26, v29);
        v26 = (unsigned int *)((char *)v26 + v29);
      }
    }
    v26 = (unsigned int *)v52[3];
  }
  while ( v26 );
  v31 = caml_heap_start;
  if ( caml_heap_start )
  {
    v32 = (char *)caml_heap_start;
    v33 = 0;
    do
    {
      v34 = v32 - 16;
      v35 = *((_DWORD *)v34 + 1);
      if ( v35 )
      {
        v33 += v35 >> 2;
        v26 = (unsigned int *)((char *)v26 + ((*((_DWORD *)v34 + 2) - v35) >> 2));
      }
      v32 = (char *)*((_DWORD *)v34 + 3);
    }
    while ( v32 );
    v36 = caml_percent_free * (v33 / 0x64 + 1);
    while ( 1 )
    {
      v37 = (_DWORD *)*(v31 - 1);
      if ( !*(v31 - 3) )
      {
        if ( v36 <= (unsigned int)v26 )
          caml_shrink_heap(v31);
        else
          v26 = (unsigned int *)((char *)v26 + (*(v31 - 2) >> 2));
      }
      if ( !v37 )
        break;
      v31 = v37;
    }
    v38 = caml_heap_start;
    caml_fl_reset();
    for ( ; v38; v38 = (_DWORD *)*(v38 - 1) )
    {
      v39 = *(v38 - 2);
      v40 = *(v38 - 3);
      if ( v39 > v40 )
        caml_make_free_blocks((int **)((char *)v38 + v40), (v39 - v40) >> 2, 1);
    }
  }
  else
  {
LABEL_78:
    caml_fl_reset();
  }
  ++caml_stat_compactions;
  return caml_gc_message(16, "done.\n", 0);
}
// 8074564: using guessed type void *caml_weak_none;
// 807AE08: using guessed type int caml_stat_compactions;
// 807AE54: using guessed type int caml_weak_list_head;

//----- (08069AA5) --------------------------------------------------------
int caml_compact_heap_maybe()
{
  long double v0; // fst7
  long double v1; // fst6
  long double v2; // fst7
  long double v3; // fst6
  int result; // eax
  float v5; // [esp+18h] [ebp-20h]
  float v6; // [esp+18h] [ebp-20h]
  float v7; // [esp+2Ch] [ebp-Ch]
  float v8; // [esp+2Ch] [ebp-Ch]

  if ( (unsigned int)caml_percent_max <= 0xF423F && caml_stat_major_collections > 2 && caml_stat_heap_chunks > 2 )
  {
    v7 = (long double)(unsigned int)caml_fl_cur_size * 3.0
       + (long double)(unsigned int)caml_fl_size_at_phase_change * -2.0;
    v0 = v7;
    if ( v7 < 0.0 )
      v0 = (long double)(unsigned int)caml_fl_cur_size;
    v1 = v0;
    v2 = (long double)((unsigned int)caml_stat_heap_size >> 2);
    if ( v1 < v2 )
    {
      v6 = v1 * 100.0 / (v2 - v1);
      v3 = v6;
      if ( v6 > 1000000.0 )
        v3 = 1000000.0;
      v5 = v3;
    }
    else
    {
      v5 = 1000000.0;
    }
    caml_gc_message(512, "FL size at phase change = %lu\n", caml_fl_size_at_phase_change);
    caml_gc_message(512, "Estimated overhead = %lu%%\n", (__int64)v5);
    result = caml_percent_max;
    if ( v5 >= (long double)(unsigned int)caml_percent_max )
    {
      caml_gc_message(512, "Automatic compaction triggered.\n", 0);
      caml_finish_major_cycle();
      v8 = (long double)(unsigned int)caml_fl_cur_size
         * 100.0
         / ((long double)((unsigned int)caml_stat_heap_size >> 2) - (long double)(unsigned int)caml_fl_cur_size);
      caml_gc_message(512, "Measured overhead: %lu%%\n", (__int64)v8);
      result = caml_compact_heap();
    }
  }
  return result;
}
// 80768E0: using guessed type int caml_fl_cur_size;
// 807ADFC: using guessed type int caml_stat_major_collections;
// 807AE00: using guessed type int caml_stat_heap_size;
// 807AE0C: using guessed type int caml_stat_heap_chunks;

//----- (08069C80) --------------------------------------------------------
void *__cdecl caml_final_do_strong_roots(void (__cdecl *a1)(_DWORD, char *))
{
  int v1; // ebx
  unsigned int v2; // esi
  void *result; // eax
  char *v4; // edi
  unsigned int i; // esi
  _DWORD *v6; // ebx
  _DWORD *v7; // [esp+1Ch] [ebp-1Ch]

  if ( old )
  {
    v1 = 0;
    v2 = 0;
    do
    {
      a1(*(_DWORD *)((char *)final_table + v1), (char *)final_table + v1);
      ++v2;
      v1 += 12;
    }
    while ( old > v2 );
  }
  result = to_do_hd;
  v7 = to_do_hd;
  if ( to_do_hd )
  {
    do
    {
      v6 = v7;
      for ( i = 0; v7[1] > i; result = v7 )
      {
        v4 = (char *)&v7[3 * i];
        a1(v6[2], v4 + 8);
        a1(v6[3], v4 + 12);
        ++i;
        v6 += 3;
      }
      v7 = (_DWORD *)*v7;
    }
    while ( v7 );
  }
  return result;
}
// 807AE70: using guessed type int old;

//----- (08069D29) --------------------------------------------------------
int __cdecl caml_final_do_weak_roots(int (__cdecl *a1)(_DWORD, char *))
{
  int v1; // ebx
  unsigned int v2; // esi
  int result; // eax

  if ( old )
  {
    v1 = 0;
    v2 = 0;
    do
    {
      result = a1(*(_DWORD *)((char *)final_table + v1 + 4), (char *)final_table + v1 + 4);
      ++v2;
      v1 += 12;
    }
    while ( old > v2 );
  }
  return result;
}
// 807AE70: using guessed type int old;

//----- (08069D75) --------------------------------------------------------
int __cdecl caml_final_do_young_roots(void (__cdecl *a1)(_DWORD, char *))
{
  unsigned int v1; // esi
  int v2; // ebx
  int result; // eax

  v1 = old;
  if ( old < (unsigned int)young )
  {
    v2 = 12 * old;
    do
    {
      a1(*(_DWORD *)((char *)final_table + v2), (char *)final_table + v2);
      result = ((int (__cdecl *)(_DWORD, char *))a1)(
                 *(_DWORD *)((char *)final_table + v2 + 4),
                 (char *)final_table + v2 + 4);
      ++v1;
      v2 += 12;
    }
    while ( young > v1 );
  }
  return result;
}
// 807AE64: using guessed type int young;
// 807AE70: using guessed type int old;

//----- (08069DD5) --------------------------------------------------------
int caml_final_empty_young()
{
  int result; // eax

  result = young;
  old = young;
  return result;
}
// 807AE64: using guessed type int young;
// 807AE70: using guessed type int old;

//----- (08069DE4) --------------------------------------------------------
int caml_final_release()
{
  running_finalisation_function = 0;
  return 1;
}
// 807AE60: using guessed type int running_finalisation_function;

//----- (08069DF8) --------------------------------------------------------
int __usercall caml_final_register@<eax>(unsigned int a1@<esi>, int a2, unsigned int a3)
{
  int v3; // edi
  int v4; // eax
  _DWORD *v5; // edx
  _DWORD *v6; // ecx
  int v8; // [esp+4h] [ebp-24h]
  unsigned int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  _DWORD *v11; // [esp+10h] [ebp-18h]

  if ( (a3 & 1) != 0 || (a1 = a3, (*(_BYTE *)(caml_page_table[a3 >> 23] + ((a3 >> 12) & 0x7FF)) & 3) == 0) )
    caml_invalid_argument("Gc.finalise", v8, v9, v10, v11);
  if ( young >= (unsigned int)size )
  {
    if ( final_table )
    {
      v3 = 2 * size;
      final_table = caml_stat_resize(final_table, 24 * size);
      size = v3;
    }
    else
    {
      final_table = caml_stat_alloc(0x168u);
      size = 30;
    }
  }
  v4 = young;
  v5 = (char *)final_table + 12 * young;
  *v5 = a2;
  v6 = (_DWORD *)(a1 - 4);
  if ( *(_BYTE *)(a1 - 4) == 0xF9 )
  {
    v5[2] = 4 * (*v6 >> 10);
    v5[1] = a1 - 4 * (*v6 >> 10);
  }
  else
  {
    v5[2] = 0;
    v5[1] = a3;
  }
  young = v4 + 1;
  return 1;
}
// 8069E34: variable 'v8' is possibly undefined
// 8069E34: variable 'v9' is possibly undefined
// 8069E34: variable 'v10' is possibly undefined
// 8069E34: variable 'v11' is possibly undefined
// 807AE64: using guessed type int young;
// 807AE68: using guessed type int size;

//----- (08069EE9) --------------------------------------------------------
void caml_final_do_calls()
{
  void *v0; // ebx
  char *v1; // eax
  int v2; // edx
  int v3; // edx
  char *v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // [esp+4h] [ebp-14h]
  int v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]
  _DWORD *v11; // [esp+10h] [ebp-8h]

  if ( !running_finalisation_function && to_do_hd )
  {
    caml_gc_message(128, "Calling finalisation functions.\n", 0);
    while ( 1 )
    {
      v1 = (char *)to_do_hd;
      if ( !to_do_hd )
        break;
      v2 = *((_DWORD *)to_do_hd + 1);
      if ( v2 )
      {
        v3 = v2 - 1;
        *((_DWORD *)to_do_hd + 1) = v3;
        v4 = &v1[12 * v3];
        v5 = *((_DWORD *)v4 + 4);
        v6 = *((_DWORD *)v4 + 3);
        running_finalisation_function = 1;
        v8 = v5 + v6;
        caml_callback_exn();
        running_finalisation_function = 0;
        if ( (v7 & 3) == 2 )
        {
          caml_raise(v7 & 0xFFFFFFFC, v8, v9, v10, v11);
          break;
        }
      }
      else
      {
        v0 = *(void **)to_do_hd;
        free(to_do_hd);
        to_do_hd = v0;
        if ( !v0 )
          to_do_tl = 0;
      }
    }
    caml_gc_message(128, "Done calling finalisation functions.\n", 0);
  }
}
// 8069F8F: variable 'v7' is possibly undefined
// 8069F9D: variable 'v9' is possibly undefined
// 8069F9D: variable 'v10' is possibly undefined
// 8069F9D: variable 'v11' is possibly undefined
// 807AE60: using guessed type int running_finalisation_function;
// 807AE78: using guessed type int to_do_tl;

//----- (08069FC4) --------------------------------------------------------
void caml_final_update()
{
  _DWORD *v0; // edx
  int v1; // ebx
  unsigned int v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // eax
  char v7; // cl
  _DWORD *v8; // esi
  int v9; // eax
  int v10; // eax
  unsigned int i; // ebx
  char *v12; // [esp+20h] [ebp-38h]
  int v13; // [esp+24h] [ebp-34h]
  unsigned int v14; // [esp+28h] [ebp-30h]
  int v15; // [esp+2Ch] [ebp-2Ch]
  unsigned int v16; // [esp+30h] [ebp-28h]
  unsigned int v17; // [esp+34h] [ebp-24h]
  int v18; // [esp+3Ch] [ebp-1Ch]

  if ( !old )
    return;
  v0 = final_table;
  v1 = 0;
  v2 = 0;
  do
  {
    v1 += (*(_DWORD *)(v0[1] - 4) & 0x300) == 0;
    ++v2;
    v0 += 3;
  }
  while ( v2 < old );
  if ( !v1 )
    return;
  v3 = malloc(12 * v1 + 20);
  if ( !v3 )
    caml_fatal_error("out of memory");
  *v3 = 0;
  v3[1] = v1;
  if ( to_do_tl )
    *(_DWORD *)to_do_tl = v3;
  else
    to_do_hd = v3;
  to_do_tl = (int)v3;
  v14 = old;
  if ( !old )
  {
    old = 0;
    young = 0;
    *(_DWORD *)(to_do_tl + 4) = 0;
    return;
  }
  v4 = final_table;
  v12 = (char *)final_table;
  v15 = to_do_tl;
  v17 = 0;
  v13 = 0;
  v16 = 0;
  do
  {
    while ( 1 )
    {
      v5 = (_DWORD *)v4[1];
      if ( (*(v5 - 1) & 0x300) != 0 )
        break;
      if ( *((_BYTE *)v5 - 4) != 0xFA )
      {
        v8 = v4;
        goto LABEL_25;
      }
      v6 = *v5;
      if ( (*v5 & 1) != 0 )
      {
        v8 = v4;
        v4[1] = v6;
        goto LABEL_25;
      }
      v18 = (v6 >> 12) & 0x7FF;
      if ( (*(_BYTE *)(caml_page_table[v6 >> 23] + v18) & 7) == 0 )
      {
        v8 = v4;
        goto LABEL_25;
      }
      v7 = *(_BYTE *)(v6 - 4);
      switch ( v7 )
      {
        case -6:
          v8 = v4;
          goto LABEL_25;
        case -10:
          v8 = v4;
          goto LABEL_25;
        case -3:
          v8 = v4;
LABEL_25:
          v9 = 12 * v17;
          *(_DWORD *)(v9 + v15 + 8) = *v8;
          *(_DWORD *)(v9 + v15 + 12) = v8[1];
          *(_DWORD *)(v9 + v15 + 16) = v8[2];
          ++v17;
          goto LABEL_27;
      }
      v4[1] = v6;
      if ( (*(_BYTE *)(caml_page_table[v6 >> 23] + v18) & 1) == 0 )
      {
        v8 = v4;
        goto LABEL_25;
      }
    }
    v10 = 12 * v13;
    *(_DWORD *)&v12[v10] = *v4;
    *(_DWORD *)&v12[v10 + 4] = v4[1];
    *(_DWORD *)&v12[v10 + 8] = v4[2];
    ++v13;
LABEL_27:
    ++v16;
    v4 += 3;
  }
  while ( v14 > v16 );
  old = v13;
  young = v13;
  *(_DWORD *)(v15 + 4) = v17;
  if ( v17 )
  {
    for ( i = 0; i < v17; ++i )
      caml_darken(*(_DWORD *)(to_do_tl + 12 * i + 12));
  }
}
// 807AE64: using guessed type int young;
// 807AE70: using guessed type int old;
// 807AE78: using guessed type int to_do_tl;

//----- (0806A1F4) --------------------------------------------------------
_DWORD *__cdecl caml_final_custom_operations(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ebx
  _DWORD *v3; // eax

  v1 = (_DWORD *)custom_ops_final_table;
  if ( custom_ops_final_table )
  {
    v2 = *(_DWORD **)custom_ops_final_table;
    if ( *(_DWORD *)(*(_DWORD *)custom_ops_final_table + 4) == a1 )
      return v2;
    while ( 1 )
    {
      v1 = (_DWORD *)v1[1];
      if ( !v1 )
        break;
      v2 = (_DWORD *)*v1;
      if ( *(_DWORD *)(*v1 + 4) == a1 )
        return v2;
    }
  }
  v2 = caml_stat_alloc(0x1Cu);
  *v2 = "_final";
  v2[1] = a1;
  v2[2] = 0;
  v2[3] = 0;
  v2[4] = 0;
  v2[5] = 0;
  v3 = caml_stat_alloc(8u);
  *v3 = v2;
  v3[1] = custom_ops_final_table;
  custom_ops_final_table = (int)v3;
  return v2;
}
// 807AE7C: using guessed type int custom_ops_final_table;

//----- (0806A277) --------------------------------------------------------
_DWORD *__cdecl _ZN2Fl11add_handlerEPFiiE(Fl *this)
{
  _DWORD *result; // eax

  result = caml_stat_alloc(8u);
  *result = this;
  result[1] = custom_ops_table;
  custom_ops_table = (int)result;
  return result;
}
// 807AE80: using guessed type int custom_ops_table;

//----- (0806A29E) --------------------------------------------------------
_DWORD *caml_init_custom_operations()
{
  _ZN2Fl11add_handlerEPFiiE((Fl *)&caml_int32_ops);
  _ZN2Fl11add_handlerEPFiiE((Fl *)&caml_nativeint_ops);
  return _ZN2Fl11add_handlerEPFiiE((Fl *)&caml_int64_ops);
}
// 80744BC: using guessed type char *caml_int32_ops;
// 80744D8: using guessed type char *caml_int64_ops;
// 80744F4: using guessed type char *caml_nativeint_ops;

//----- (0806A2CA) --------------------------------------------------------
const char **__cdecl caml_find_custom_operations(char *s2)
{
  int v1; // ebx
  const char **v2; // esi

  v1 = custom_ops_table;
  if ( !custom_ops_table )
    return 0;
  while ( 1 )
  {
    v2 = *(const char ***)v1;
    if ( !strcmp(**(const char ***)v1, s2) )
      break;
    v1 = *(_DWORD *)(v1 + 4);
    if ( !v1 )
      return 0;
  }
  return v2;
}
// 807AE80: using guessed type int custom_ops_table;

//----- (0806A30A) --------------------------------------------------------
int *__cdecl caml_alloc_custom(int a1, int a2, unsigned int a3, unsigned int a4)
{
  int *result; // eax
  int *v5; // esi

  if ( *(_DWORD *)(a1 + 4) || ((unsigned int)(a2 + 3) >> 2) + 1 > 0x100 )
  {
    v5 = caml_alloc_shr(((unsigned int)(a2 + 3) >> 2) + 1, 255);
    *v5 = a1;
    caml_adjust_gc_speed(a3, a4);
    result = (int *)caml_check_urgent_gc((int)v5);
  }
  else
  {
    result = (int *)caml_alloc_small(((unsigned int)(a2 + 3) >> 2) + 1, 255);
    *result = a1;
  }
  return result;
}

//----- (0806A380) --------------------------------------------------------
int __cdecl caml_executable_name(char *buf, size_t len)
{
  ssize_t v2; // eax
  int result; // eax
  char v4[16]; // [esp+10h] [ebp-68h] BYREF
  int v5; // [esp+20h] [ebp-58h]

  v2 = readlink("/proc/self/exe", buf, len);
  if ( v2 == -1 || (int)len <= v2 || (buf[v2] = 0, (result = __xstat64(3, buf, v4)) != 0) || (v5 & 0xF000) != 0x8000 )
    result = -1;
  return result;
}
// 8049F54: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806A3EE) --------------------------------------------------------
char *__cdecl caml_decompose_path(int a1, char *src)
{
  char *v2; // edi
  char *i; // ecx
  char *v4; // ebx
  char *v5; // eax
  char v6; // dl

  v2 = 0;
  if ( src )
  {
    v2 = (char *)caml_stat_alloc(strlen(src) + 1);
    strcpy(v2, src);
    for ( i = v2; ; i = v4 + 1 )
    {
      if ( *i && *i != 58 )
      {
        v5 = i + 1;
        do
        {
          v4 = v5;
          v6 = *v5++;
        }
        while ( v6 && v6 != 58 );
      }
      else
      {
        v4 = i;
      }
      caml_ext_table_add((int *)a1, (int)i);
      if ( !*v4 )
        break;
      *v4 = 0;
    }
  }
  return v2;
}

//----- (0806A474) --------------------------------------------------------
int __cdecl caml_read_directory(char *name, int a2)
{
  int result; // eax
  int v3; // eax
  const char *v4; // ebx
  int v5; // edx
  char *v6; // edi
  DIR *dirp; // [esp+2Ch] [ebp-1Ch]

  dirp = opendir(name);
  result = -1;
  if ( dirp )
  {
    while ( 1 )
    {
      v3 = readdir64(dirp);
      if ( !v3 )
        break;
      v4 = (const char *)(v3 + 19);
      v5 = *(unsigned __int8 *)(v3 + 19);
      if ( (v5 != 46 || *(_BYTE *)(v3 + 20) != *(&byte_806C6B5 + 1))
        && (v5 != unk_806C6B4 || *(_BYTE *)(v3 + 20) != 46 || *(_BYTE *)(v3 + 21)) )
      {
        v6 = (char *)caml_stat_alloc(strlen((const char *)(v3 + 19)) + 1);
        strcpy(v6, v4);
        caml_ext_table_add((int *)a2, (int)v6);
      }
    }
    closedir(dirp);
    result = 0;
  }
  return result;
}
// 804A354: using guessed type int __cdecl readdir64(_DWORD);
// 806C6B5: using guessed type char byte_806C6B5;

//----- (0806A53D) --------------------------------------------------------
char *caml_dlerror()
{
  return dlerror();
}

//----- (0806A54A) --------------------------------------------------------
void *__cdecl caml_dlsym(void *handle, char *name)
{
  return dlsym(handle, name);
}

//----- (0806A564) --------------------------------------------------------
void *__cdecl caml_globalsym(char *name)
{
  return caml_dlsym(0, name);
}

//----- (0806A57F) --------------------------------------------------------
int __cdecl caml_dlclose(void *handle)
{
  return dlclose(handle);
}

//----- (0806A592) --------------------------------------------------------
void *__cdecl caml_dlopen(char *file, int a2, int a3)
{
  int v3; // eax

  v3 = -(a3 == 0);
  LOBYTE(v3) = 0;
  return dlopen(file, v3 + 4354);
}

//----- (0806A5B8) --------------------------------------------------------
char *__cdecl caml_search_in_path(int a1, char *src)
{
  char *v2; // eax
  char *v3; // ebx
  int v5; // [esp+1Ch] [ebp-7Ch]
  char v6[16]; // [esp+20h] [ebp-78h] BYREF
  int v7; // [esp+30h] [ebp-68h]

  v2 = src;
  if ( *src )
  {
    if ( *src == 47 )
      goto LABEL_13;
    while ( *++v2 )
    {
      if ( *v2 == 47 )
        goto LABEL_13;
    }
  }
  if ( *(int *)a1 <= 0 )
  {
LABEL_13:
    v3 = (char *)caml_stat_alloc(strlen(src) + 1);
    strcpy(v3, src);
    return v3;
  }
  v5 = 0;
  while ( 1 )
  {
    v3 = (char *)caml_stat_alloc(strlen(src) + 1 + strlen(*(const char **)(*(_DWORD *)(a1 + 8) + 4 * v5)) + 1);
    strcpy(v3, *(const char **)(*(_DWORD *)(a1 + 8) + 4 * v5));
    if ( *v3 )
      *(_WORD *)&v3[strlen(v3)] = 47;
    strcat(v3, src);
    if ( !__xstat64(3, v3, v6) && (v7 & 0xF000) == 0x8000 )
      return v3;
    caml_stat_free(v3);
    if ( *(_DWORD *)a1 <= ++v5 )
      goto LABEL_13;
  }
}
// 8049F54: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806A6EF) --------------------------------------------------------
char *__cdecl caml_search_dll_in_path(int a1, char *src)
{
  char *v2; // ebx
  char *v3; // esi

  v2 = (char *)caml_stat_alloc(strlen(src) + 4);
  strcpy(v2, src);
  *(_DWORD *)&v2[strlen(v2)] = 7303982;
  v3 = caml_search_in_path(a1, v2);
  caml_stat_free(v2);
  return v3;
}

//----- (0806A76C) --------------------------------------------------------
char *__cdecl caml_search_exe_in_path(char *src)
{
  char *v1; // eax
  char *v2; // esi
  char *v3; // edi
  int v5[6]; // [esp+14h] [ebp-24h] BYREF

  caml_ext_table_init(v5, 8);
  v1 = getenv("PATH");
  v2 = caml_decompose_path((int)v5, v1);
  v3 = caml_search_in_path((int)v5, src);
  caml_stat_free(v2);
  caml_ext_table_free((int)v5, 0);
  return v3;
}

//----- (0806A7E0) --------------------------------------------------------
int caml_backtrace_status()
{
  return caml_backtrace_active == 0 ? 1 : 3;
}
// 807AE84: using guessed type int caml_backtrace_active;

//----- (0806A7F4) --------------------------------------------------------
int __usercall extract_location_info@<eax>(int result@<eax>, _DWORD *a2@<edx>)
{
  unsigned int *v2; // ebx
  unsigned int v3; // edi
  unsigned int v4; // ecx

  if ( (*(_BYTE *)(result + 4) & 1) != 0 )
  {
    v2 = (unsigned int *)((result + 2 * *(unsigned __int16 *)(result + 6) + 11) & 0xFFFFFFFC);
    v3 = *v2;
    v4 = v2[1];
    *a2 = 1;
    a2[1] = (v3 & 3) != 0;
    a2[2] = (char *)v2 + (v3 & 0x3FFFFFC);
    a2[3] = v4 >> 12;
    a2[4] = (unsigned __int8)(v4 >> 4);
    result = ((v4 & 0xF) << 6) | (v3 >> 26);
    a2[5] = result;
  }
  else
  {
    *a2 = 0;
    a2[1] = 1;
  }
  return result;
}

//----- (0806A887) --------------------------------------------------------
char **caml_get_exception_backtrace()
{
  int v0; // ebx
  int v2; // [esp+1Ch] [ebp-6Ch]
  int v3; // [esp+28h] [ebp-60h] BYREF
  int v4; // [esp+2Ch] [ebp-5Ch]
  void *src; // [esp+30h] [ebp-58h]
  int v6; // [esp+34h] [ebp-54h]
  int v7; // [esp+38h] [ebp-50h]
  int v8; // [esp+3Ch] [ebp-4Ch]
  int v9[8]; // [esp+40h] [ebp-48h] BYREF
  void *v10; // [esp+60h] [ebp-28h] BYREF
  _DWORD *v11; // [esp+64h] [ebp-24h] BYREF
  char *v12; // [esp+68h] [ebp-20h] BYREF
  char **v13; // [esp+6Ch] [ebp-1Ch] BYREF

  v2 = caml_local_roots;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9[0] = caml_local_roots;
  caml_local_roots = (int)v9;
  v9[2] = 1;
  v9[1] = 4;
  v9[3] = (int)&v13;
  v9[4] = (int)&v12;
  v9[5] = (int)&v11;
  v9[6] = (int)&v10;
  v12 = caml_alloc(caml_backtrace_pos, 0);
  if ( caml_backtrace_pos > 0 )
  {
    v0 = 0;
    do
    {
      extract_location_info(*(_DWORD *)(caml_backtrace_buffer + 4 * v0), &v3);
      if ( v3 )
      {
        v10 = caml_copy_string(src);
        v11 = (_DWORD *)caml_alloc_small(5, 0);
        *v11 = v4 == 0 ? 1 : 3;
        v11[1] = v10;
        v11[2] = 2 * v6 + 1;
        v11[3] = 2 * v7 + 1;
        v11[4] = 2 * v8 + 1;
      }
      else
      {
        v11 = (_DWORD *)caml_alloc_small(1, 1);
        *v11 = v4 == 0 ? 1 : 3;
      }
      caml_modify((unsigned int *)&v12[4 * v0++], (unsigned int)v11);
    }
    while ( caml_backtrace_pos > v0 );
  }
  v13 = (char **)caml_alloc_small(1, 0);
  *v13 = v12;
  caml_local_roots = v2;
  return v13;
}
// 8074754: using guessed type int caml_local_roots;
// 807AE88: using guessed type int caml_backtrace_pos;
// 807AE8C: using guessed type int caml_backtrace_buffer;

//----- (0806AA08) --------------------------------------------------------
void caml_print_exception_backtrace()
{
  int v0; // ebx
  const char *v1; // eax
  int v2[12]; // [esp+28h] [ebp-30h] BYREF

  if ( caml_backtrace_pos > 0 )
  {
    v0 = 0;
    do
    {
      extract_location_info(*(_DWORD *)(caml_backtrace_buffer + 4 * v0), v2);
      if ( v2[0] )
      {
        v1 = "Raised at";
        if ( v0 )
        {
          v1 = "Called from";
          if ( v2[1] )
            v1 = "Re-raised at";
        }
        fprintf(stderr, "%s file \"%s\", line %d, characters %d-%d\n", v1, (const char *)v2[2], v2[3], v2[4], v2[5]);
      }
      ++v0;
    }
    while ( caml_backtrace_pos > v0 );
  }
}
// 807AE88: using guessed type int caml_backtrace_pos;
// 807AE8C: using guessed type int caml_backtrace_buffer;

//----- (0806AA99) --------------------------------------------------------
int __cdecl caml_stash_backtrace(int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int result; // eax
  int v7; // edx
  int v8; // edx

  if ( a1 != caml_backtrace_last_exn )
  {
    caml_backtrace_pos = 0;
    caml_backtrace_last_exn = a1;
  }
  if ( caml_backtrace_buffer || (result = (int)malloc(0x1000u), (caml_backtrace_buffer = result) != 0) )
  {
    if ( !caml_frame_descriptors )
      caml_init_frame_descriptors();
    do
    {
      v7 = caml_frame_descriptors_mask & (a2 >> 3);
      result = *((_DWORD *)caml_frame_descriptors + v7);
      if ( !result )
        break;
      while ( *(_DWORD *)result != a2 )
      {
        v7 = caml_frame_descriptors_mask & (v7 + 1);
        result = *((_DWORD *)caml_frame_descriptors + v7);
        if ( !result )
          return result;
      }
      if ( *(_WORD *)(result + 4) == 0xFFFF )
      {
        result = a3 + 8;
        a3 = *(_DWORD *)(a3 + 8);
        a2 = *(_DWORD *)(result + 4);
        if ( !a3 )
          return result;
      }
      else
      {
        v8 = caml_backtrace_pos;
        if ( caml_backtrace_pos > 1023 )
          return result;
        *(_DWORD *)(caml_backtrace_buffer + 4 * caml_backtrace_pos) = result;
        caml_backtrace_pos = v8 + 1;
        result = *(_WORD *)(result + 4) & 0xFFFC;
        a3 += result;
        a2 = *(_DWORD *)(a3 - 4);
      }
    }
    while ( a3 <= a4 );
  }
  return result;
}
// 8074568: using guessed type int caml_backtrace_last_exn;
// 807AE88: using guessed type int caml_backtrace_pos;
// 807AE8C: using guessed type int caml_backtrace_buffer;
// 807B360: using guessed type int caml_frame_descriptors_mask;

//----- (0806AB74) --------------------------------------------------------
int __cdecl caml_record_backtrace(int a1)
{
  if ( a1 >> 1 != caml_backtrace_active )
  {
    caml_backtrace_active = a1 >> 1;
    caml_backtrace_pos = 0;
    if ( a1 >> 1 )
      caml_register_global_root((unsigned int)&caml_backtrace_last_exn);
    else
      caml_remove_global_root((unsigned int)&caml_backtrace_last_exn);
  }
  return 1;
}
// 8074568: using guessed type int caml_backtrace_last_exn;
// 807AE84: using guessed type int caml_backtrace_active;
// 807AE88: using guessed type int caml_backtrace_pos;

//----- (0806ABBC) --------------------------------------------------------
void caml_debugger_init()
{
  ;
}

//----- (0806ABC1) --------------------------------------------------------
void caml_debugger()
{
  ;
}

//----- (0806ABC6) --------------------------------------------------------
void caml_debugger_cleanup_fork()
{
  ;
}

//----- (0806ABCC) --------------------------------------------------------
char *__cdecl caml_call_gc(char a1)
{
  int v1; // ecx
  char *result; // eax
  int retaddr; // [esp+0h] [ebp+0h]

  caml_last_return_address = retaddr;
  result = &a1;
  caml_bottom_of_stack = (int)&a1;
  sub_806ABDD(v1);
  return result;
}
// 806ABD4: returning address of temporary local variable '%arg_0'
// 806ABD9: variable 'v1' is possibly undefined
// 807448C: using guessed type int caml_last_return_address;
// 8074760: using guessed type int caml_bottom_of_stack;

//----- (0806ABDD) --------------------------------------------------------
void __fastcall __spoils<ecx> sub_806ABDD(int a1)
{
  _DWORD v1[7]; // [esp-10h] [ebp-1Ch] BYREF

  v1[2] = a1;
  caml_gc_regs = (int)v1;
  caml_garbage_collection();
}
// 807B368: using guessed type int caml_gc_regs;

//----- (0806ABF8) --------------------------------------------------------
unsigned int __cdecl caml_alloc1(char a1)
{
  int v1; // ecx
  unsigned int result; // eax
  int retaddr; // [esp+0h] [ebp+0h]

  while ( 1 )
  {
    result = caml_young_ptr - 8;
    caml_young_ptr = result;
    if ( result >= caml_young_limit )
      break;
    caml_last_return_address = retaddr;
    caml_bottom_of_stack = (int)&a1;
    sub_806ABDD(v1);
  }
  return result;
}
// 806AC1F: variable 'v1' is possibly undefined
// 807448C: using guessed type int caml_last_return_address;
// 8074760: using guessed type int caml_bottom_of_stack;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0806AC60) --------------------------------------------------------
unsigned int __cdecl caml_alloc3(char a1)
{
  int v1; // ecx
  unsigned int result; // eax
  int retaddr; // [esp+0h] [ebp+0h]

  while ( 1 )
  {
    result = caml_young_ptr - 16;
    caml_young_ptr = result;
    if ( result >= caml_young_limit )
      break;
    caml_last_return_address = retaddr;
    caml_bottom_of_stack = (int)&a1;
    sub_806ABDD(v1);
  }
  return result;
}
// 806AC87: variable 'v1' is possibly undefined
// 807448C: using guessed type int caml_last_return_address;
// 8074760: using guessed type int caml_bottom_of_stack;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0806AC94) --------------------------------------------------------
unsigned int __usercall caml_allocN@<eax>(unsigned int a1@<eax>, int a2@<ecx>, char a3)
{
  unsigned int result; // eax
  unsigned int v4; // [esp-4h] [ebp-4h]
  int retaddr; // [esp+0h] [ebp+0h]

  while ( 1 )
  {
    result = caml_young_ptr - a1;
    if ( result >= caml_young_limit )
      break;
    v4 = caml_young_ptr - result;
    caml_young_ptr -= caml_young_ptr - result;
    caml_last_return_address = retaddr;
    caml_bottom_of_stack = (int)&a3;
    sub_806ABDD(a2);
    a1 = v4;
  }
  caml_young_ptr = result;
  return result;
}
// 806ACCB: variable 'a2' is possibly undefined
// 807448C: using guessed type int caml_last_return_address;
// 8074760: using guessed type int caml_bottom_of_stack;
// 80778D4: using guessed type int caml_young_ptr;
// 80778D8: using guessed type int caml_young_limit;

//----- (0806ACD8) --------------------------------------------------------
int __usercall caml_c_call@<eax>(int (*a1)(void)@<eax>, char a2)
{
  int retaddr; // [esp+0h] [ebp+0h]

  caml_last_return_address = retaddr;
  caml_bottom_of_stack = (int)&a2;
  return a1();
}
// 807448C: using guessed type int caml_last_return_address;
// 8074760: using guessed type int caml_bottom_of_stack;

//----- (0806ACF0) --------------------------------------------------------
int caml_start_program()
{
  int result; // eax
  _DWORD v1[2]; // [esp-14h] [ebp-24h] BYREF
  int v2; // [esp-Ch] [ebp-1Ch]
  int v3; // [esp-8h] [ebp-18h]
  int v4; // [esp-4h] [ebp-14h]

  v4 = caml_gc_regs;
  v3 = caml_last_return_address;
  v2 = caml_bottom_of_stack;
  v1[1] = sub_806AD3E;
  v1[0] = caml_exception_pointer;
  caml_exception_pointer = (int)v1;
  result = caml_startup__code_begin();
  caml_exception_pointer = v1[0];
  caml_bottom_of_stack = v2;
  caml_last_return_address = v3;
  caml_gc_regs = v4;
  return result;
}
// 807448C: using guessed type int caml_last_return_address;
// 8074740: using guessed type int caml_exception_pointer;
// 8074760: using guessed type int caml_bottom_of_stack;
// 807B368: using guessed type int caml_gc_regs;

//----- (0806AD3E) --------------------------------------------------------
void sub_806AD3E()
{
  JUMPOUT(0x806AD27);
}
// 806AD41: control flows out of bounds to 806AD27

//----- (0806AD44) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall caml_raise_exn@<eax>(int result@<eax>)
{
  int v1; // esi
  int v2; // [esp-14h] [ebp-14h]
  unsigned int v3; // [esp-4h] [ebp-4h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  if ( (caml_backtrace_active & 1) != 0 )
  {
    v1 = result;
    caml_stash_backtrace(result, v3, (unsigned int)&retaddr, caml_exception_pointer);
    result = v1;
    caml_exception_pointer = v2;
  }
  else
  {
    caml_exception_pointer = v3;
  }
  return result;
}
// 806AD5C: positive sp value 4 has been found
// 806AD56: variable 'v3' is possibly undefined
// 806AD79: variable 'v2' is possibly undefined
// 8074740: using guessed type int caml_exception_pointer;
// 807AE84: using guessed type int caml_backtrace_active;

//----- (0806AD80) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int caml_raise_exception()
{
  int result; // eax
  int v1; // [esp-14h] [ebp-14h]
  int v2; // [esp-4h] [ebp-4h]
  int retaddr; // [esp+0h] [ebp+0h]

  if ( (caml_backtrace_active & 1) != 0 )
  {
    caml_stash_backtrace(retaddr, caml_last_return_address, caml_bottom_of_stack, caml_exception_pointer);
    result = retaddr;
    caml_exception_pointer = v1;
  }
  else
  {
    result = retaddr;
    caml_exception_pointer = v2;
  }
  return result;
}
// 806AD9C: positive sp value 4 has been found
// 806AD80: could not find valid save-restore pair for esi
// 806AD96: variable 'v2' is possibly undefined
// 806ADC1: variable 'v1' is possibly undefined
// 807448C: using guessed type int caml_last_return_address;
// 8074740: using guessed type int caml_exception_pointer;
// 8074760: using guessed type int caml_bottom_of_stack;
// 807AE84: using guessed type int caml_backtrace_active;

//----- (0806ADC8) --------------------------------------------------------
void caml_callback_exn()
{
  JUMPOUT(0x806ACF9);
}
// 806ADD6: control flows out of bounds to 806ACF9

//----- (0806ADDC) --------------------------------------------------------
void caml_callback2_exn()
{
  JUMPOUT(0x806ACF9);
}
// 806ADF1: control flows out of bounds to 806ACF9

//----- (0806ADF8) --------------------------------------------------------
void caml_callback3_exn()
{
  JUMPOUT(0x806ACF9);
}
// 806AE11: control flows out of bounds to 806ACF9

//----- (0806AE18) --------------------------------------------------------
#error "806AE3B: call analysis failed (funcsize=13)"

//----- (0806B2C0) --------------------------------------------------------
void _libc_csu_fini(void)
{
  ;
}

//----- (0806B2D0) --------------------------------------------------------
void _libc_csu_init(void)
{
  init_proc();
}

//----- (0806B330) --------------------------------------------------------
void (*_do_global_ctors_aux())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    v1 = (void (**)(void))&_CTOR_LIST__;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 806D858: using guessed type int _CTOR_LIST__;

//----- (0806B35C) --------------------------------------------------------
void term_proc()
{
  _do_global_dtors_aux();
}

// nfuncs=1500 queued=1136 decompiled=1136 lumina nreq=0 worse=0 better=0
#error "There were 53 decompilation failure(s) on 1136 function(s)"
