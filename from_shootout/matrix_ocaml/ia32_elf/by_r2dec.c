/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a910 */
#include <stdint.h>
 
void entry0 (void) {
    /* [13] -r-x section size 155836 named .text */
    ebp = 0;
    ecx = esp;
    return libc_start_main (main, esi, ecx, sym.__libc_csu_init, sym.__libc_csu_fini, edx, esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a0b4 */
#include <stdint.h>
 
void libc_start_main (void) {
    libc_start_main ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a940 */
#include <stdint.h>
 
int32_t do_global_dtors_aux (void) {
    if (*(obj.completed.5978) != 0) {
        goto label_0;
    }
    eax = *(obj.dtor_idx.5980);
    ebx = obj.__DTOR_END__;
    ebx -= obj.__DTOR_LIST__;
    ebx >>= 2;
    ebx--;
    if (eax >= ebx) {
        goto label_1;
    }
    do {
        eax++;
        *(obj.dtor_idx.5980) = eax;
        uint32_t (*eax*4 + obj.__DTOR_LIST__)() ();
        eax = *(obj.dtor_idx.5980);
    } while (eax < ebx);
label_1:
    *(obj.completed.5978) = 1;
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a9a0 */
#include <stdint.h>
 
int32_t frame_dummy (void) {
    eax = *(obj.__JCR_LIST__);
    if (eax != 0) {
        eax = 0;
        if (eax == 0) {
            goto label_0;
        }
        void (*eax)(uint32_t) (obj.__JCR_LIST__);
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80709a0 */
#include <stdint.h>
 
int32_t do_global_ctors_aux (void) {
    eax = .ctors;
    if (eax == -1) {
        goto label_0;
    }
    ebx = .ctors;
    do {
        ebx -= 4;
        void (*eax)() ();
        eax = *(ebx);
    } while (eax != -1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d520 */
#include <stdint.h>
 
uint32_t alloc_group_entry (void) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x14c1e;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x44;
    *(edi) = eax;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0xc));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x24)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x44));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c5fa */
#include <stdint.h>
 
void i686_get_pc_thunk_bx (void) {
    ebx = *(esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065314 */
#include <stdint.h>
 
int32_t caml_copy_string (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ebx = ecx - 1;
    eax = caml_alloc_string (ebx);
    esi = eax;
    eax = *((ebp + 8));
    memmove (esi, eax, ebx);
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806526a */
#include <stdint.h>
 
int32_t caml_alloc_string (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    ebx = esi + 4;
    ebx >>= 2;
    if (ebx <= 0x100) {
        edx = ebx*4 + 4;
        edi = edx;
        edi = -edi;
        eax = edi;
        eax += *(obj.caml_young_ptr);
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            eax += edx;
            *(obj.caml_young_ptr) = eax;
            caml_minor_collection ();
            *(obj.caml_young_ptr) += edi;
        }
        edx = ebx;
        edx <<= 0xa;
        edx += 0x3fc;
        eax = caml_young_ptr;
        *(eax) = edx;
        eax = caml_young_ptr;
        eax += 4;
    } else {
        eax = caml_alloc_shr (ebx, 0xfc);
        caml_check_urgent_gc (eax);
    }
    ebx <<= 2;
    *((eax + ebx - 4)) = 0;
    ebx--;
    edx = ebx;
    ecx = esi;
    dl -= cl;
    *((eax + ebx)) = dl;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a684 */
#include <stdint.h>
 
void memmove (void) {
    memmove ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806554a */
#include <stdint.h>
 
int32_t caml_copy_string_array (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_alloc_array (sym.caml_copy_string, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065486 */
#include <stdint.h>
 
int32_t caml_alloc_array (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4ch;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    esi = *((ebp + 0xc));
    eax = caml_local_roots;
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x40;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    eax = ebp - 0x1c;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x30)) = eax;
    if (*(esi) == 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        ebx++;
    } while (*((esi + ebx*4)) != 0);
    if (ebx == 0) {
label_0:
        eax = 0x8082244;
        edx = *((ebp - 0x4c));
        *(obj.caml_local_roots) = edx;
        goto label_1;
    }
    eax = caml_alloc (ebx, 0);
    *((ebp - 0x20)) = eax;
    edi = 0;
    do {
        eax = *(esi);
        eax = uint32_t (*ebp + 8)(uint32_t) (eax);
        *((ebp - 0x1c)) = eax;
        eax = edi*4;
        eax += *((ebp - 0x20));
        caml_modify (eax, eax);
        edi++;
        esi += 4;
    } while (edi < ebx);
    eax = *((ebp - 0x4c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x20));
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065201 */
#include <stdint.h>
 
int32_t caml_alloc_small (int32_t arg_8h, fd_set * arg_ch) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = *((ebp + 8));
    edx = esi*4 + 4;
    ebx = edx;
    ebx = -ebx;
    eax = ebx;
    eax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        eax += edx;
        *(obj.caml_young_ptr) = eax;
        caml_minor_collection ();
        *(obj.caml_young_ptr) += ebx;
    }
    esi <<= 0xa;
    eax = *((ebp + 0xc));
    edx = eax + esi + 0x300;
    eax = caml_young_ptr;
    *(eax) = edx;
    eax = caml_young_ptr;
    eax += 4;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064713 */
#include <stdint.h>
 
int32_t caml_minor_collection (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = caml_allocated_words;
    caml_empty_minor_heap ();
    eax = caml_allocated_words;
    eax -= ebx;
    esi = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = esi;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_promoted_words);
    *(obj.caml_stat_promoted_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_stat_minor_collections)++;
    caml_major_collection_slice (0);
    *(obj.caml_force_major_slice) = 0;
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80645c9 */
#include <stdint.h>
 
int32_t caml_empty_minor_heap (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_young_ptr;
    if (eax == *(obj.caml_young_end)) {
        goto label_0;
    }
    *(obj.caml_in_minor_collection) = 1;
    caml_gc_message (2, 0x807123c, 0);
    caml_oldify_local_roots ();
    ebx = caml_ref_table;
    if (ebx >= *(0x807ebc8)) {
        goto label_1;
    }
    esi = 0x807ebc8;
    do {
        eax = *(ebx);
        eax = *(eax);
        caml_oldify_one (eax, eax);
        ebx += 4;
    } while (*(esi) > ebx);
label_1:
    caml_oldify_mopup ();
    eax = caml_weak_ref_table;
    if (eax >= *(0x807ebe4)) {
        goto label_2;
    }
    ebx = 0x807ebe4;
    do {
        ecx = *(eax);
        edx = *(ecx);
        if ((dl & 1) == 0) {
            if (edx >= *(obj.caml_young_end)) {
                goto label_3;
            }
            if (edx <= *(obj.caml_young_start)) {
                goto label_3;
            }
            if (*((edx - 4)) == 0) {
                edx = *(edx);
                *(ecx) = edx;
            } else {
                edx = "8!\b\b";
                *(ecx) = edx;
            }
        }
label_3:
        eax += 4;
    } while (*(ebx) > eax);
label_2:
    eax = caml_young_start;
    edx = caml_young_ptr;
    if (*(obj.caml_young_ptr) < eax) {
        edx = eax;
    }
    eax = caml_young_end;
    ecx = caml_young_end;
    ecx -= edx;
    edx = ecx;
    edx >>= 2;
    ecx = 0;
    *((ebp - 0x10)) = edx;
    *((ebp - 0xc)) = ecx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *(obj.caml_stat_minor_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_young_ptr) = eax;
    eax = caml_young_start;
    *(obj.caml_young_limit) = eax;
    eax = caml_ref_table;
    clear_table ();
    eax = caml_weak_ref_table;
    clear_table ();
    caml_gc_message (2, 0x80718a7, 0);
    *(obj.caml_in_minor_collection) = 0;
label_0:
    caml_final_empty_young ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80640b8 */
#include <stdint.h>
 
int32_t caml_major_collection_slice (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_22h;
    int32_t var_20h;
    int32_t var_1ch;
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    if (*(obj.caml_gc_phase) == 2) {
        start_cycle ();
    }
    eax = caml_allocated_words;
    edx = caml_percent_free;
    esi = edx + 0x64;
    edi = 0;
    *((ebp - 0x20)) = esi;
    *((ebp - 0x1c)) = edi;
    *(fp_stack--) = *((ebp - 0x20));
    ecx = 0;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    ecx = 0;
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] *= *(0x807122c);
    fp_stack[0] *= fp_stack[2];
    edx = caml_stat_heap_size;
    edx >>= 2;
    ecx = 0;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    fp_stack[0] /= fp_stack[1];
    fp_stack[0] *= *(0x8071230);
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    edx = caml_dependent_size;
    if (edx == 0) {
        fp_stack++;
        fp_stack++;
        *(fp_stack--) = 0.0;
    } else {
        esi = caml_dependent_allocated;
        edi = 0;
        *((ebp - 0x20)) = esi;
        *((ebp - 0x1c)) = edi;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= fp_stack[2];
        fp_stack++;
        ecx = 0;
        *((ebp - 0x20)) = edx;
        *((ebp - 0x1c)) = ecx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] /= fp_stack[2];
        fp_stack++;
        fp_stack[0] /= fp_stack[1];
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x30));
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    __asm ("fcmovbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_extra_heap_resources);
    __asm ("fcmovbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    caml_gc_message (0x40, "allocated_words = %lu\n", eax);
    *(fp_stack--) = *(0x8070e50);
    fp_stack[0] *= *(obj.caml_extra_heap_resources);
    eax = *((ebp - 0x22));
    ah = 0xc;
    *((ebp - 0x24)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    caml_gc_message (0x40, "extra_heap_resources = %luu\n", eax);
    *(fp_stack--) = *(0x8070e50);
    fp_stack[0] *= *((ebp - 0x30));
    eax = *((ebp - 0x22));
    ah = 0xc;
    *((ebp - 0x24)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    caml_gc_message (0x40, "amount of work to do = %luu\n", eax);
    if (*(obj.caml_gc_phase) == 0) {
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= *((ebp - 0x30));
        fp_stack[0] *= *(0x8071234);
        eax = caml_percent_free;
        eax += 0x64;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] /= fp_stack[1];
        fp_stack++;
        eax = *((ebp - 0x22));
        ah = 0xc;
        *((ebp - 0x24)) = ax;
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        esi = *((ebp - 0x28));
    } else {
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= *((ebp - 0x30));
        fp_stack[0] *= *(0x8071238);
        fp_stack[0] /= *(0x807122c);
        eax = *((ebp - 0x22));
        ah = 0xc;
        *((ebp - 0x24)) = ax;
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        esi = *((ebp - 0x28));
    }
    caml_gc_message (0x40, "ordered work = %ld words\n", ebx);
    caml_gc_message (0x40, "computed work = %ld words\n", esi);
    if (ebx == 0) {
        ebx = esi;
    }
    if (*(obj.caml_gc_phase) == 0) {
        eax = ebx;
        mark_slice ();
        caml_gc_message (2, 0x8071225, 0);
    } else {
        eax = ebx;
        sweep_slice ();
        caml_gc_message (2, 0x8071227, 0);
    }
    if (*(obj.caml_gc_phase) == 2) {
        caml_compact_heap_maybe ();
    }
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = edx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *(obj.caml_stat_major_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_allocated_words) = 0;
    *(obj.caml_dependent_allocated) = 0;
    *(fp_stack--) = 0.0;
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    fp_stack--;
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f559 */
#include <stdint.h>
 
uint32_t caml_final_do_calls (void) {
    char * var_4h;
    int32_t var_8h;
    if (*(obj.running_finalisation_function) != 0) {
        goto label_1;
    }
    if (*(obj.to_do_hd) == 0) {
        goto label_1;
    }
    eax = caml_gc_message (0x80, "Calling finalisation functions.\n", 0);
    while (edx == 0) {
        ebx = *(eax);
        free (eax);
        *(obj.to_do_hd) = ebx;
        if (ebx == 0) {
            *(obj.to_do_tl) = 0;
        }
label_0:
        eax = to_do_hd;
        if (eax == 0) {
            goto label_2;
        }
        edx = *((eax + 4));
    }
    edx--;
    *((eax + 4)) = edx;
    edx *= 3;
    eax = eax + edx*4;
    edx = *((eax + 8));
    ecx = *((eax + 0x10));
    eax = *((eax + 0xc));
    *(obj.running_finalisation_function) = 1;
    eax += ecx;
    eax = caml_callback_exn (edx, eax);
    *(obj.running_finalisation_function) = 0;
    edx = eax;
    edx &= 3;
    if (edx != 2) {
        goto label_0;
    }
    eax &= 0xfffffffc;
    caml_raise (eax);
label_2:
    caml_gc_message (0x80, "Done calling finalisation functions.\n", 0);
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062f0f */
#include <stdint.h>
 
int32_t caml_gc_message (int32_t arg_8h, char * arg_ch, size_t arg_10h) {
    char * format;
    size_t var_8h;
    eax = *((ebp + 8));
    if (eax >= 0) {
        if ((*(obj.caml_verb_gc) & eax) == 0) {
            goto label_0;
        }
    }
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax = stderr;
    fprintf (eax, eax);
    eax = stderr;
    fflush (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a1a4 */
#include <stdint.h>
 
void free (void) {
    free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070438 */
#include <stdint.h>
 
int32_t loc_caml_callback_exn (int32_t arg_14h, int32_t arg_18h) {
    do {
        *(obj.caml_exception_pointer) = esp;
        void (*esi)(uint32_t*, uint32_t, uint32_t*, uint32_t*, uint32_t*) (*(obj.caml_exception_pointer), 0x80703ae, *(obj.caml_bottom_of_stack), *(obj.caml_last_return_address), *(obj.caml_gc_regs));
        return;
        ebx = *((esp + 0x14));
        eax = *((esp + 0x18));
        esi = *(ebx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80619b0 */
#include <stdint.h>
 
int32_t caml_raise (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_channel_mutex_unlock_exn;
    if (eax != 0) {
        void (*eax)() ();
    }
    edx = caml_exception_pointer;
    if (edx != 0) {
        eax = caml_local_roots;
        if (eax == 0) {
            goto label_0;
        }
        if (eax < edx) {
            goto label_1;
        }
        goto label_0;
    }
    eax = caml_fatal_uncaught_exception (ebx);
    do {
label_1:
        eax = *(eax);
        *(obj.caml_local_roots) = eax;
        if (eax == 0) {
            goto label_0;
        }
    } while (edx > eax);
label_0:
    return caml_raise_exception (ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d6c4 */
#include <stdint.h>
 
uint32_t alloc_host_entry (void) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x14a7b;
    esi = eax;
    *((ebp - 0xc)) = 1;
    *((ebp - 0x10)) = 1;
    *((ebp - 0x14)) = 1;
    *((ebp - 0x18)) = 1;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x38)) = edx;
    edx = ebp - 0x38;
    *(eax) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp - 0xc;
    *((ebp - 0x2c)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x18;
    *((ebp - 0x20)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0xc)) = eax;
    eax = *((esi + 4));
    if (eax != 0) {
        eax = caml_copy_string_array (eax);
        *((ebp - 0x10)) = eax;
    } else {
        eax = *((ebx - 4));
        eax = eax + 4;
        *((ebp - 0x10)) = eax;
    }
    eax = *((esi + 0xc));
    *((ebx + 0x9760)) = eax;
    eax = *((esi + 0x10));
    eax = ebx - 0x148ca;
    eax = caml_alloc_array (eax, eax);
    *((ebp - 0x14)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0xc));
    *(eax) = edx;
    edx = eax;
    ecx = *((ebp - 0x10));
    *((eax + 4)) = ecx;
    ecx = *((esi + 8));
    if (ecx != 1) {
        cl = (ecx != 2) ? 1 : 0;
        ecx = (int32_t) cl;
        ecx = ecx + ecx + 3;
        *((eax + 8)) = ecx;
    } else {
        *((eax + 8)) = 1;
    }
    ecx = *((ebp - 0x14));
    *((edx + 0xc)) = ecx;
    ecx = *((ebp - 0x38));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d882 */
#include <stdint.h>
 
int32_t alloc_one_addr (int32_t arg_8h) {
    void * s1;
    void * var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x148b9;
    eax = *((ebp + 8));
    if (*((ebx + 0x9760)) == 0x10) {
        esi = ebp - 0x1c;
        memmove (esi, eax, 0x10);
        eax = alloc_inet6_addr (esi);
    } else {
        esi = ebp - 0xc;
        memmove (esi, eax, 4);
        alloc_inet_addr (esi);
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dc20 */
#include <stdint.h>
 
uint32_t alloc_proto_entry (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x14518;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x40;
    *(edi) = eax;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    eax = ebp - 0x1c;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x20)) = eax;
    caml_alloc_small (3, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x40));
    *(edi) = edx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dd30 */
#include <stdint.h>
 
uint32_t alloc_passwd_entry (void) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x1440e;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(edi) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 5;
    eax = ebp - 0x1c;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x2c;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0x10));
    eax = caml_copy_string (eax);
    *((ebp - 0x24)) = eax;
    eax = *((esi + 0x14));
    eax = caml_copy_string (eax);
    *((ebp - 0x28)) = eax;
    eax = *((esi + 0x18));
    eax = caml_copy_string (eax);
    *((ebp - 0x2c)) = eax;
    caml_alloc_small (7, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    edx = edx + edx + 1;
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0x10)) = edx;
    edx = *((ebp - 0x28));
    *((eax + 0x14)) = edx;
    edx = *((ebp - 0x2c));
    *((eax + 0x18)) = edx;
    edx = *((ebp - 0x4c));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805df00 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint32_t alloc_service_entry (void) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x1423e;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x44;
    *(edi) = eax;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0xc));
    eax = caml_copy_string (eax);
    *((ebp - 0x24)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    dx = rotate_right16 (dx, 8);
    edx = (int32_t) dx;
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x44));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e0e0 */
#include <stdint.h>
 
uint32_t alloc_tm (void) {
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x1405f;
    esi = eax;
    caml_alloc_small (9, 0);
    edx = *(esi);
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((esi + 4));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    edx = edx + edx + 1;
    *((eax + 0xc)) = edx;
    edx = *((esi + 0x10));
    edx = edx + edx + 1;
    *((eax + 0x10)) = edx;
    edx = *((esi + 0x14));
    edx = edx + edx + 1;
    *((eax + 0x14)) = edx;
    edx = *((esi + 0x18));
    edx = edx + edx + 1;
    *((eax + 0x18)) = edx;
    edx = *((esi + 0x1c));
    edx = edx + edx + 1;
    *((eax + 0x1c)) = edx;
    edx -= edx;
    edx &= 0xfffffffe;
    edx += 3;
    *((eax + 0x20)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e3c4 */
#include <stdint.h>
 
uint32_t unix_convert_itimer (void) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x13d77;
    esi = eax;
    eax = caml_alloc_small (4, 0xfe);
    *(fp_stack--) = *(esi);
    *(fp_stack--) = *((esi + 4));
    *(fp_stack--) = *((ebx - 0x1644));
    fp_stack[1] /= fp_stack[0];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    *(eax) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((esi + 8));
    *(fp_stack--) = *((esi + 0xc));
    fp_stack[2] /= fp_stack[0];
    fp_stack++;
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e473 */
#include <stdint.h>
 
uint32_t unix_set_timeval (void) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_2ah;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x13cc5;
    esi = eax;
    eax = ebp - 0x20;
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (eax);
    eax = *((ebp - 0x2a));
    ah = 0xc;
    *((ebp - 0x2c)) = ax;
    *(fp_stack--) = *((ebp - 0x20));
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    edi = *((ebp - 0x30));
    *(esi) = edi;
    fp_stack[0] *= *((ebx - 0x1644));
    *(esp) = fp_stack[0];
    fp_stack--;
    ceil ();
    eax = *((ebp - 0x2a));
    ah = 0xc;
    *((ebp - 0x2c)) = ax;
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x30));
    *((esi + 4)) = eax;
    if (eax > 0xf423f) {
        edi++;
        *(esi) = edi;
        *((esi + 4)) = 0;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a0e4 */
#include <stdint.h>
 
void modf (void) {
    modf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a8e4 */
#include <stdint.h>
 
void ceil (void) {
    ceil ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ef7c */
#include <stdint.h>
 
int32_t fdlist_to_fdset (int32_t arg_8h) {
    int32_t var_ch;
    esi = eax;
    *((ebp - 0xc)) = edx;
    ecx = 0x20;
    edi = edx;
    eax = 0;
    memset (edi, eax, ecx);
    if (esi == 1) {
        goto label_0;
    }
    edx = esi;
    do {
        edi = *(edx);
        eax = *(edx);
        eax >>= 1;
        esi = eax + 0x1f;
        __asm ("cmovns esi, eax");
        esi >>= 5;
        edi >>= 0x1f;
        edi >>= 0x1b;
        ecx = eax + edi;
        ecx &= 0x1f;
        ecx -= edi;
        edi = 1;
        edi <<= cl;
        ecx = edi;
        edi = *((ebp - 0xc));
        *((edi + esi*4)) |= ecx;
        ecx = *((ebp + 8));
        if (eax > *(ecx)) {
            *(ecx) = eax;
        }
        edx = *((edx + 4));
    } while (edx != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805efe5 */
#include <stdint.h>
 
uint32_t fdset_to_fdlist (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13159;
    edi = edx;
    *((ebp - 0x20)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x40)) = ecx;
    ecx = ebp - 0x40;
    *(edx) = ecx;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    edx = ebp - 0x1c;
    *((ebp - 0x34)) = edx;
    edx = ebp - 0x20;
    *((ebp - 0x30)) = edx;
    if (eax == 1) {
        goto label_0;
    }
    *((ebp - 0x1c)) = eax;
    do {
        eax = *(eax);
        esi = *(eax);
        esi >>= 1;
        edx = esi + 0x1f;
        __asm ("cmovns edx, esi");
        edx >>= 5;
        eax >>= 0x1f;
        eax >>= 0x1b;
        ecx = esi + eax;
        ecx &= 0x1f;
        ecx -= eax;
        edx = *((edi + edx*4));
        if (((edx >> ecx) & 1) < 0) {
            caml_alloc_small (2, 0);
            edx = esi + esi + 1;
            *(eax) = edx;
            edx = *((ebp - 0x20));
            *((eax + 4)) = edx;
            *((ebp - 0x20)) = eax;
        }
        eax = *((ebp - 0x1c));
        eax = *((eax + 4));
        if (eax == 1) {
            goto label_0;
        }
        *((ebp - 0x1c)) = eax;
    } while (1);
label_0:
    edx = *((ebp - 0x40));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = *((ebp - 0x20));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f880 */
#include <stdint.h>
 
uint32_t decode_sigset (void) {
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x128be;
    esi = eax;
    edi = edx;
    *(esp) = edx;
    sigemptyset ();
    if (esi == 1) {
        goto label_0;
    }
    do {
        eax = *(esi);
        eax >>= 1;
        eax = caml_convert_signal_number (eax);
        *((esp + 4)) = eax;
        *(esp) = edi;
        sigaddset ();
        esi = *((esi + 4));
    } while (esi != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f93f */
#include <stdint.h>
 
uint32_t encode_sigset (void) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x127ff;
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x1c)) = 1;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x3c)) = edx;
    edx = ebp - 0x3c;
    *(eax) = edx;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    esi = 1;
    do {
        *((esp + 4)) = esi;
        eax = *((ebp - 0x4c));
        *(esp) = eax;
        eax = sigismember ();
        if (eax > 0) {
            eax = caml_alloc_small (2, 0);
            edi = eax;
            caml_rev_convert_signal_number (esi);
            eax = eax + eax + 1;
            *(edi) = eax;
            eax = *((ebp - 0x1c));
            *((edi + 4)) = eax;
            *((ebp - 0x1c)) = edi;
        }
        esi++;
    } while (esi != 0x41);
    edx = *((ebp - 0x3c));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806029c */
#include <stdint.h>
 
uint32_t stat_aux (void) {
    uint32_t var_5ch;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x11ea2;
    *((ebp - 0x5c)) = eax;
    esi = edx;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 0;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x4c)) = edi;
    edx = ebp - 0x4c;
    *(eax) = edx;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 5;
    eax = ebp - 0x1c;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x2c;
    *((ebp - 0x30)) = eax;
    *(fp_stack--) = *((esi + 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((esi + 0x48));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x20)) = eax;
    *(fp_stack--) = *((esi + 0x50));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x24)) = eax;
    if (*((ebp - 0x5c)) != 0) {
        eax = *((esi + 0x2c));
        edx = *((esi + 0x30));
        caml_copy_int64 (eax, edx);
    } else {
        eax = *((esi + 0x2c));
        eax = eax + eax + 1;
    }
    *((ebp - 0x28)) = eax;
    eax = caml_alloc_small (0xc, 0);
    *((ebp - 0x2c)) = eax;
    edx = *(esi);
    edx = edx + edx + 1;
    *(eax) = edx;
    eax = *((esi + 0x58));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    eax = *((ebp - 0x2c));
    eax += 8;
    *((ebp - 0x5c)) = eax;
    eax = ebx + 0x92c4;
    eax = *((esi + 0x10));
    eax &= 0xf000;
    eax = cst_to_constr (0, eax, 7);
    edx = *((ebp - 0x5c));
    *(edx) = eax;
    eax = *((esi + 0x10));
    eax &= 0xfff;
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0xc)) = edx;
    eax = *((esi + 0x14));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x10)) = edx;
    eax = *((esi + 0x18));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x14)) = edx;
    eax = *((esi + 0x1c));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x18)) = edx;
    eax = *((esi + 0x20));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x1c)) = edx;
    edx = *((ebp - 0x28));
    eax = *((ebp - 0x2c));
    *((eax + 0x20)) = edx;
    edx = *((ebp - 0x1c));
    eax = *((ebp - 0x2c));
    *((eax + 0x24)) = edx;
    edx = *((ebp - 0x20));
    eax = *((ebp - 0x2c));
    *((eax + 0x28)) = edx;
    edx = *((ebp - 0x24));
    eax = *((ebp - 0x2c));
    *((eax + 0x2c)) = edx;
    eax = *((ebx - 0x18));
    *(eax) = edi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806115c */
#include <stdint.h>
 
uint32_t alloc_process_status (void) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x10fdc;
    edi = eax;
    esi = edx;
    eax = edx;
    eax &= 0x7f;
    *((ebp - 0x4c)) = eax;
    if (eax == 0) {
        eax = caml_alloc_small (1, 0);
        *((ebp - 0x1c)) = eax;
        edx = esi;
        esi = (int32_t) dh;
        edx = esi + esi + 1;
        *(eax) = edx;
    } else {
        if (dl == 0x7f) {
            eax = caml_alloc_small (1, 2);
            *((ebp - 0x4c)) = eax;
            *((ebp - 0x1c)) = eax;
            edx = esi;
            esi = (int32_t) dh;
            caml_rev_convert_signal_number (esi);
            eax = eax + eax + 1;
            edx = *((ebp - 0x4c));
            *(edx) = eax;
        } else {
            eax = caml_alloc_small (1, 1);
            esi = eax;
            *((ebp - 0x1c)) = eax;
            eax = *((ebp - 0x4c));
            caml_rev_convert_signal_number (eax);
            eax = eax + eax + 1;
            *(esi) = eax;
        }
    }
    esi = *((ebx - 0x18));
    eax = *(esi);
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x3c;
    *(esi) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    caml_alloc_small (2, 0);
    edx = edi + edi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x1c));
    *((eax + 4)) = edx;
    edx = *((ebp - 0x3c));
    *(esi) = edx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061610 */
#include <stdint.h>
 
uint32_t scanmult (void) {
    int32_t var_2ch;
    int32_t var_20h;
    int32_t var_19h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * format;
    uint32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = eax;
    *((ebp - 0x2c)) = edx;
    *((ebp - 0x19)) = 0x20;
    ebx = ebp - 0x19;
    esi = ebp - 0x20;
    isoc99_sscanf (ebx, "=%u%c", esi);
    isoc99_sscanf (ebx, "=0x%x%c", esi);
    eax = *((ebp - 0x19));
    if (al != 0x4d) {
        if (al != 0x6b) {
            if (al != 0x47) {
                goto label_0;
            }
            eax = *((ebp - 0x20));
            eax <<= 0xa;
            edx = *((ebp - 0x2c));
            *(edx) = eax;
        } else {
        } else {
            eax = *((ebp - 0x20));
            eax <<= 0x14;
            edx = *((ebp - 0x2c));
            *(edx) = eax;
            goto label_1;
        }
        eax = *((ebp - 0x20));
        eax <<= 0x1e;
        edx = *((ebp - 0x2c));
        *(edx) = eax;
        goto label_1;
label_0:
        eax = *((ebp - 0x20));
        edx = *((ebp - 0x2c));
        *(edx) = eax;
    }
label_1:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061e12 */
#include <stdint.h>
 
int32_t cons (void) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = eax;
    esi = edx;
    caml_stat_alloc (8);
    *(eax) = ebx;
    *((eax + 4)) = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064b1a */
#include <stdint.h>
 
uint32_t caml_stat_alloc (size_t size) {
    ebx = *((ebp + 8));
    eax = malloc (ebx);
    if (eax == 0) {
        if (ebx == 0) {
            goto label_0;
        }
        caml_raise_out_of_memory ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a5c4 */
#include <stdint.h>
 
void malloc (void) {
    malloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061a89 */
#include <stdint.h>
 
void caml_raise_out_of_memory (void) {
    return caml_raise ("H$\a\b");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80623a0 */
#include <stdint.h>
 
int32_t caml_iterate_global_roots (void) {
    int32_t var_4h;
    esi = eax;
    ebx = *((edx + 4));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = *(ebx);
        eax = *(eax);
        void (*esi)(uint32_t, uint32_t) (eax, eax);
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062400 */
#include <stdint.h>
 
int32_t caml_insert_global_root (void) {
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_5ch;
    *((ebp - 0x70)) = eax;
    ebx = edx;
    edi = eax;
    eax = *((eax + 0x48));
    *((ebp - 0x6c)) = eax;
    ecx = eax;
    edx = edi;
    if (eax < 0) {
        goto label_1;
    }
    esi = ebp - 0x5c;
    do {
label_0:
        eax = *((edx + ecx*4 + 4));
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) >= ebx) {
            goto label_2;
        }
        edx = eax;
    } while (1);
label_2:
    *((esi + ecx*4)) = edx;
    ecx--;
    if (ecx != -1) {
        goto label_0;
    }
label_1:
    eax = *((edx + 4));
    if (eax != 0) {
        if (*(eax) == ebx) {
            goto label_3;
        }
    }
    eax = *(obj.random_seed) * 0x10dcd;
    eax += 0x6255;
    *(obj.random_seed) = eax;
    edx = eax;
    edx &= 0xc0000000;
    esi = 0;
    if (edx != 0xc0000000) {
        goto label_4;
    }
    do {
        esi++;
        eax <<= 2;
        edx = eax;
        edx &= 0xc0000000;
    } while (edx == 0xc0000000);
label_4:
    if (*((ebp - 0x6c)) >= esi) {
        goto label_5;
    }
    eax = *((ebp - 0x6c));
    eax++;
    if (eax > esi) {
        goto label_6;
    }
    edx = ebp - 0x5c;
    do {
        *((edx + eax*4)) = edi;
        eax++;
    } while (eax <= esi);
label_6:
    eax = *((ebp - 0x70));
    *((eax + 0x48)) = esi;
label_5:
    eax = esi*4 + 8;
    caml_stat_alloc (eax);
    *(eax) = ebx;
    if (esi < 0) {
        goto label_3;
    }
    edx = 0;
    edi = ebp - 0x5c;
    do {
        ecx = *((edi + edx*4));
        ebx = *((ecx + edx*4 + 4));
        *((eax + edx*4 + 4)) = ebx;
        *((ecx + edx*4 + 4)) = eax;
        edx++;
    } while (edx <= esi);
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80625dc */
#include <stdint.h>
 
int32_t caml_delete_global_root (void) {
    int32_t var_6ch;
    int32_t var_5ch;
    ebx = eax;
    ecx = eax;
    eax = *((eax + 0x48));
    *((ebp - 0x6c)) = eax;
    if (eax < 0) {
        goto label_1;
    }
    esi = eax;
    edi = ebp - 0x5c;
    do {
label_0:
        eax = *((ecx + esi*4 + 4));
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) >= edx) {
            goto label_2;
        }
        ecx = eax;
    } while (1);
label_2:
    *((edi + esi*4)) = ecx;
    esi--;
    if (esi != -1) {
        goto label_0;
    }
label_1:
    ecx = *((ecx + 4));
    if (ecx == 0) {
        goto label_3;
    }
    if (*(ecx) != edx) {
        goto label_3;
    }
    if (*((ebp - 0x6c)) < 0) {
        goto label_4;
    }
    eax = 0;
    edi = ebp - 0x5c;
    do {
        edx = *((edi + eax*4));
        if (*((edx + eax*4 + 4)) == ecx) {
            esi = *((ecx + eax*4 + 4));
            *((edx + eax*4 + 4)) = esi;
        }
        eax++;
    } while (*((ebx + 0x48)) >= eax);
label_4:
    caml_stat_free (ecx);
    eax = *((ebx + 0x48));
    if (eax <= 0) {
        goto label_3;
    }
    if (*((ebx + eax*4 + 4)) != 0) {
        goto label_3;
    }
    do {
        eax--;
        if (eax <= 0) {
            goto label_5;
        }
    } while (*((ebx + eax*4 + 4)) == 0);
    *((ebx + 0x48)) = eax;
    goto label_3;
label_5:
    *((ebx + 0x48)) = eax;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062817 */
#include <stdint.h>
 
void caml_enter_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062826 */
#include <stdint.h>
 
void caml_leave_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062835 */
#include <stdint.h>
 
int32_t caml_try_leave_blocking_section_default (void) {
    eax = 0;
    tmp_0 = obj.caml_async_signal_mode;
    obj.caml_async_signal_mode = eax;
    eax = tmp_0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062c8f */
#include <stdint.h>
 
uint32_t segv_handler (int32_t arg_60h) {
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t var_20h;
    int32_t var_18h;
    struct sigaction * act;
    struct sigaction * oldact;
    ebx = *((ebp + 0x60));
    if ((bl & 3) == 0) {
        eax = ebp - 0x18;
        *((esp + 4)) = eax;
        *(esp) = 3;
        eax = getrlimit64 ();
        if (eax != 0) {
            goto label_0;
        }
        eax = system_stack_top;
        if (ebx >= eax) {
            goto label_0;
        }
        eax -= *((ebp - 0x18));
        eax = eax - 0x2000;
        if (ebx < eax) {
            goto label_0;
        }
        caml_raise_stack_overflow ();
    }
label_0:
    *((ebp - 0xa4)) = 0;
    *((ebp - 0x20)) = 0;
    ebx = ebp - 0xa4;
    eax = ebp - 0xa0;
    *(esp) = eax;
    sigemptyset ();
    sigaction (0xb, ebx, 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a754 */
#include <stdint.h>
 
void getrlimit64 (void) {
    getrlimit64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061a77 */
#include <stdint.h>
 
void caml_raise_stack_overflow (void) {
    return caml_raise ("\\%\a\b");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e04 */
#include <stdint.h>
 
void sigemptyset (void) {
    sigemptyset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a234 */
#include <stdint.h>
 
void sigaction (void) {
    sigaction ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062d19 */
#include <stdint.h>
 
uint32_t handle_signal (int32_t arg_8h) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    if (ebx <= 0x40) {
        eax = uint32_t (*caml_try_leave_blocking_section_hook)() ();
        if (eax != 0) {
            caml_execute_signal (ebx, 1);
            uint32_t (*caml_enter_blocking_section_hook)() ();
        } else {
            caml_record_signal (ebx);
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062f50 */
#include <stdint.h>
 
uint32_t allocate_block (int32_t arg_8h) {
    uint32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    *((ebp - 0x10)) = edx;
    edx = *((ebp + 8));
    esi = edx - 4;
    ebx = *(esi);
    ebx >>= 0xa;
    edi = eax + 1;
    if (ebx < edi) {
        edi = ebx;
        edi = ~edi;
        *(obj.caml_fl_cur_size) += edi;
        edi = *(edx);
        *(ecx) = edi;
        edi = caml_fl_merge;
        if (*(obj.caml_fl_merge) == edx) {
            edi = ecx;
        }
        *(obj.caml_fl_merge) = edi;
        *(esi) = 0;
        if (*(obj.caml_allocation_policy) == 1) {
            edi = *((ebp - 0x10));
            edi++;
            esi = flp_size;
            if (edi < esi) {
                if (*((edi*4 + obj.flp)) != edx) {
                    goto label_0;
                }
                *((edi*4 + obj.flp)) = ecx;
                goto label_1;
            }
label_0:
            esi--;
            if (esi != *((ebp - 0x10))) {
                goto label_2;
            }
            edi = 0;
            if (ecx == 0x807b788) {
                ecx = edi;
            }
            *(obj.beyond) = ecx;
            *(obj.flp_size) = esi;
        } else {
            *(obj.caml_fl_cur_size) -= eax;
            edi = ebx;
            edi -= eax;
            edi <<= 0xa;
            edi += 0x200;
            *(esi) = edi;
        }
label_2:
        if (*(obj.caml_allocation_policy) != 0) {
            goto label_1;
        }
        *(obj.fl_prev) = ecx;
    }
label_1:
    ebx -= eax;
    eax = edx + ebx*4;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806303b */
#include <stdint.h>
 
void truncate_flp (void) {
    if (eax != 0x807b788) {
        edx = flp_size;
        if (edx <= 0) {
            goto label_0;
        }
        edx--;
        ecx = *((edx*4 + obj.flp));
        esi = flp;
        if (eax <= *(ecx)) {
            goto label_1;
        }
        goto label_0;
    }
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
    goto label_2;
    do {
        edx = ecx;
label_1:
        if (edx <= 0) {
            goto label_3;
        }
        ecx = edx - 1;
        ebx = *((esi + ecx*4));
    } while (eax <= *(ebx));
    *(obj.flp_size) = edx;
    goto label_0;
label_3:
    *(obj.flp_size) = edx;
label_0:
    if (eax <= *(obj.beyond)) {
        *(obj.beyond) = 0;
    }
label_2:
    esi = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063820 */
#include <stdint.h>
 
int32_t clip_heap_chunk_size (void) {
    edx = 0x2000;
    if (eax <= 0x1fff) {
        eax = edx;
    }
    eax += 0xfff;
    eax &= 0xfffff000;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063967 */
#include <stdint.h>
 
void start_cycle (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Starting new major GC cycle\n", 0);
    caml_darken_all_roots ();
    *(obj.caml_gc_phase) = 0;
    *(obj.caml_gc_subphase) = 0xa;
    *(obj.markhp) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062106 */
#include <stdint.h>
 
void caml_darken_all_roots (void) {
    caml_do_roots (sym.caml_darken);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061fe5 */
#include <stdint.h>
 
uint32_t caml_do_roots (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    edi = caml_globals;
    if (edi == 0) {
        goto label_3;
    }
    *((ebp - 0x1c)) = 0;
    goto label_4;
    do {
label_0:
        eax = edi + eax*4;
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_1:
    *((ebp - 0x1c))++;
    eax = *((ebp - 0x1c));
    edx = caml_globals;
    edi = *((edx + eax*4));
    if (edi == 0) {
        goto label_3;
    }
label_4:
    esi = edi - 4;
    edx = *(esi);
    edx >>= 0xa;
    eax = 0;
    ebx = 0;
    if (edx != 0) {
        goto label_0;
    }
    goto label_1;
label_3:
    eax = caml_dyn_globals;
    *((ebp - 0x1c)) = eax;
    if (eax == 0) {
        goto label_5;
    }
label_2:
    edx = *((ebp - 0x1c));
    edi = *(edx);
    esi = edi - 4;
    eax = *(esi);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_6;
    }
    eax = 0;
    ebx = 0;
    do {
        eax = edi + eax*4;
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (edx > ebx);
label_6:
    eax = *((ebp - 0x1c));
    eax = *((eax + 4));
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_2;
    }
label_5:
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
    eax = caml_local_roots;
    eax = caml_gc_regs;
    eax = caml_last_return_address;
    eax = caml_bottom_of_stack;
    edx = *((ebp + 8));
    caml_do_local_roots (eax, eax, eax);
    eax = *((ebp + 8));
    caml_scan_global_roots (eax);
    edx = *((ebp + 8));
    caml_final_do_strong_roots (edx);
    eax = caml_scan_roots_hook;
    if (eax != 0) {
        edx = *((ebp + 8));
        void (*eax)(uint32_t) (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80639ae */
#include <stdint.h>
 
int32_t realloc_gray_vals (void) {
    char * size;
    int32_t var_8h;
    edx = gray_vals_size;
    eax = caml_stat_heap_size;
    ecx = eax + 0x7f;
    __asm ("cmovs eax, ecx");
    eax >>= 7;
    if (eax > edx) {
        edx <<= 2;
        edx >>= 9;
        caml_gc_message (8, "Growing gray_vals to %luk bytes\n", edx);
        eax = gray_vals_size;
        eax <<= 3;
        eax = gray_vals;
        eax = realloc (eax, eax);
        if (eax == 0) {
            caml_gc_message (8, "No room for growing gray_vals\n", 0);
            eax = gray_vals;
            *(obj.gray_vals_cur) = eax;
            *(obj.heap_is_pure) = 0;
        } else {
            *(obj.gray_vals) = eax;
        }
        edx = gray_vals_size;
        ecx = eax + edx*4;
        *(obj.gray_vals_cur) = ecx;
        ecx = edx + edx;
        *(obj.gray_vals_size) = ecx;
        eax = eax + edx*8;
        *(obj.gray_vals_end) = eax;
    } else {
        edx >>= 1;
        edx <<= 2;
        edx += *(obj.gray_vals);
        *(obj.gray_vals_cur) = edx;
        *(obj.heap_is_pure) = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063a83 */
#include <stdint.h>
 
int32_t mark_slice (void) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    char * var_4h;
    int32_t var_8h;
    *((ebp - 0x24)) = eax;
    caml_gc_message (ebx, esi, edi);
    eax = caml_gc_subphase;
    caml_gc_message (0x40, "Subphase = %ld\n", eax);
    esi = gray_vals_cur;
    if (*((ebp - 0x24)) <= 0) {
        goto label_2;
    }
label_1:
    if (*(obj.gray_vals) >= esi) {
        goto label_3;
    }
    esi -= 4;
    edi = *(esi);
    edx = edi - 4;
    eax = *(edx);
    ecx = *(edx);
    ch |= 3;
    *(edx) = ecx;
    edx = eax;
    edx >>= 0xa;
    *((ebp - 0x1c)) = edx;
    if (al > 0xfa) {
        goto label_4;
    }
    if (edx == 0) {
        goto label_4;
    }
    ebx = 0;
    *((ebp - 0x34)) = esi;
    do {
        eax = *((edi + ebx*4));
        if ((al & 1) == 0) {
            esi = eax;
            ecx = eax;
            ecx >>= 0x17;
            edx = eax;
            edx >>= 0xc;
            edx &= 0x7ff;
            ecx = *((ecx*4 + obj.caml_page_table));
            if ((*((ecx + edx)) & 1) == 0) {
                goto label_5;
            }
            edx = *((eax - 4));
            ecx = (int32_t) dl;
            if (ecx == 0xfa) {
                ecx = *(eax);
                *((ebp - 0x20)) = ecx;
                if ((cl & 1) == 0) {
                    *((ebp - 0x2c)) = ecx;
                    esi = ecx;
                    esi >>= 0x17;
                    ecx >>= 0xc;
                    ecx &= 0x7ff;
                    esi = *((esi*4 + obj.caml_page_table));
                    if ((*((esi + ecx)) & 7) == 0) {
                        goto label_6;
                    }
                    ecx = *((ebp - 0x2c));
                    esi = *((ecx - 4));
                    ecx = esi;
                    if (cl == 0xfa) {
                        goto label_6;
                    }
                    if (cl == 0xf6) {
                        goto label_6;
                    }
                    if (cl == 0xfd) {
                        goto label_6;
                    }
                }
                esi = *((ebp - 0x20));
                *((edi + ebx*4)) = esi;
            } else {
                if (ecx != 0xf9) {
                    goto label_6;
                }
                edx >>= 0xa;
                eax = edx*4;
                esi -= eax;
                eax = esi;
                edx = *((esi - 4));
            }
label_6:
            if ((dh & 3) != 0) {
                goto label_5;
            }
            dh &= 0xfc;
            dh |= 1;
            *((eax - 4)) = edx;
            edx = *((ebp - 0x34));
            *(edx) = eax;
            edx += 4;
            *((ebp - 0x34)) = edx;
            if (edx < *(obj.gray_vals_end)) {
                goto label_5;
            }
            *(obj.gray_vals_cur) = edx;
            realloc_gray_vals ();
            ecx = gray_vals_cur;
            *((ebp - 0x34)) = ecx;
        }
label_5:
        ebx++;
    } while (*((ebp - 0x1c)) > ebx);
    esi = *((ebp - 0x34));
label_4:
    eax = *((ebp - 0x1c));
    eax = ~eax;
    *((ebp - 0x24)) += eax;
    goto label_7;
label_3:
    eax = markhp;
    if (eax != 0) {
        if (eax == *(obj.limit)) {
            eax = chunk;
            eax = *((eax - 4));
            *(obj.chunk) = eax;
            if (eax == 0) {
                *(obj.markhp) = 0;
                goto label_7;
            }
            *(obj.markhp) = eax;
            eax += *((eax - 8));
            *(obj.limit) = eax;
            goto label_7;
        }
        edx = *(eax);
        edx &= 0x300;
        if (edx == 0x100) {
            eax += 4;
            *(esi) = eax;
            esi += 4;
        }
        eax = markhp;
        edx = *(eax);
        edx >>= 0xa;
        eax = eax + edx*4 + 4;
        *(obj.markhp) = eax;
        goto label_7;
    }
    if (*(obj.heap_is_pure) == 0) {
        *(obj.heap_is_pure) = 1;
        eax = caml_heap_start;
        *(obj.chunk) = eax;
        *(obj.markhp) = eax;
        eax += *((eax - 8));
        *(obj.limit) = eax;
        goto label_7;
    }
    eax = caml_gc_subphase;
    if (eax != 0xb) {
        if (eax <= 0xb) {
            if (eax != 0xa) {
                goto label_7;
            }
        } else {
            if (eax == 0xc) {
                goto label_8;
            }
            if (eax != 0xd) {
                goto label_7;
            }
            goto label_9;
        }
        *(obj.caml_gc_subphase) = 0xb;
        *(obj.weak_prev) = 0x8082134;
        goto label_7;
    }
    eax = weak_prev;
    eax = *(eax);
    *((ebp - 0x34)) = eax;
    if (eax == 0) {
        goto label_10;
    }
    *((ebp - 0x28)) = eax;
    eax = *((eax - 4));
    eax >>= 0xa;
    *((ebp - 0x30)) = eax;
    if (eax <= 1) {
        goto label_11;
    }
    *((ebp - 0x20)) = 1;
    *((ebp - 0x38)) = esi;
label_0:
    edx = *((ebp - 0x20));
    ecx = *((ebp - 0x28));
    eax = *((ecx + edx*4));
    edi = "8!\b\b";
    if (eax == edi) {
        goto label_12;
    }
    if ((al & 1) != 0) {
        goto label_12;
    }
    ecx = eax;
    ecx >>= 0x17;
    edx = eax;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 1) == 0) {
        goto label_12;
    }
    edx = eax - 4;
    if (*(edx) != 0xfa) {
        goto label_13;
    }
    eax = *(eax);
    if ((al & 1) == 0) {
        goto label_14;
    }
    goto label_13;
    do {
        if ((al & 1) != 0) {
            goto label_12;
        }
        ecx = *((esi*4 + obj.caml_page_table));
        if ((*((ecx + ebx)) & 1) == 0) {
            goto label_12;
        }
        esi = *((ebp - 0x1c));
        if (*(esi) != 0xfa) {
            goto label_13;
        }
        eax = *(eax);
        if ((al & 1) != 0) {
            goto label_13;
        }
label_14:
        *((ebp - 0x2c)) = edx;
        edx = eax;
        esi = eax;
        esi >>= 0x17;
        ebx = eax;
        ebx >>= 0xc;
        ebx &= 0x7ff;
        ecx = *((esi*4 + obj.caml_page_table));
        if ((*((ecx + ebx)) & 7) == 0) {
            goto label_15;
        }
        edx -= 4;
        *((ebp - 0x1c)) = edx;
        ecx = *(edx);
        if (cl == 0xfa) {
            goto label_15;
        }
        if (cl == 0xf6) {
            goto label_15;
        }
        if (cl == 0xfd) {
            goto label_15;
        }
        edi = *((ebp - 0x20));
        ecx = *((ebp - 0x28));
        *((ecx + edi*4)) = eax;
        edi = "8!\b\b";
    } while (eax != edi);
    goto label_12;
label_15:
    edx = *((ebp - 0x2c));
label_13:
    if ((*(edx) & 0x300) == 0) {
        esi = *((ebp - 0x20));
        eax = *((ebp - 0x28));
        *((eax + esi*4)) = edi;
    }
label_12:
    *((ebp - 0x20))++;
    edx = *((ebp - 0x30));
    if (*((ebp - 0x20)) != edx) {
        goto label_0;
    }
    esi = *((ebp - 0x38));
label_11:
    ecx = *((ebp - 0x34));
    *(obj.weak_prev) = ecx;
    eax = *((ebp - 0x30));
    eax = ~eax;
    *((ebp - 0x24)) += eax;
    goto label_7;
label_10:
    *(obj.caml_gc_subphase) = 0xc;
    *(obj.weak_prev) = 0x8082134;
    goto label_7;
label_8:
    edx = weak_prev;
    eax = *(edx);
    if (eax != 0) {
        if ((*((eax - 4)) & 0x300) == 0) {
            eax = *(eax);
            *(edx) = eax;
        } else {
            *(obj.weak_prev) = eax;
        }
        *((ebp - 0x24))--;
    } else {
        *(obj.gray_vals_cur) = esi;
        caml_final_update ();
        esi = gray_vals_cur;
        *(obj.caml_gc_subphase) = 0xd;
        goto label_7;
label_9:
        *(obj.gray_vals_cur) = esi;
        eax = caml_heap_start;
        *(obj.caml_gc_sweep_hp) = eax;
        caml_fl_init_merge ();
        *(obj.caml_gc_phase) = 1;
        eax = caml_heap_start;
        *(obj.chunk) = eax;
        *(obj.caml_gc_sweep_hp) = eax;
        eax += *((eax - 8));
        *(obj.limit) = eax;
        eax = caml_fl_cur_size;
        *(obj.caml_fl_size_at_phase_change) = eax;
        goto label_2;
    }
label_7:
    if (*((ebp - 0x24)) > 0) {
        goto label_1;
    }
label_2:
    *(obj.gray_vals_cur) = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063f60 */
#include <stdint.h>
 
int32_t sweep_slice (void) {
    char * var_4h;
    int32_t var_8h;
    esi = eax;
    caml_gc_message (ebx, esi, edi);
    if (esi <= 0) {
        goto label_0;
    }
    do {
        ebx = caml_gc_sweep_hp;
        if (ebx < *(obj.limit)) {
            ecx = ebx;
            eax = *(ebx);
            edx = *(ebx);
            edx >>= 0xa;
            edi = edx;
            edi = ~edi;
            esi += edi;
            edx = ebx + edx*4 + 4;
            *(obj.caml_gc_sweep_hp) = edx;
            edx = eax;
            edx &= 0x300;
            if (edx != 0) {
                if (edx != 0x200) {
                    goto label_1;
                }
            } else {
                if (al == 0xff) {
                    eax = *((ebx + 4));
                    eax = *((eax + 4));
                    if (eax == 0) {
                        goto label_2;
                    }
                    ecx += 4;
                    void (*eax)(uint32_t) (ecx);
                }
label_2:
                ebx += 4;
                eax = caml_fl_merge_block (ebx);
                *(obj.caml_gc_sweep_hp) = eax;
                goto label_3;
            }
            ebx += 4;
            *(obj.caml_fl_merge) = ebx;
            goto label_3;
label_1:
            ah &= 0xfc;
            *(ebx) = eax;
        } else {
            eax = chunk;
            eax = *((eax - 4));
            *(obj.chunk) = eax;
            if (eax == 0) {
                *(obj.caml_stat_major_collections)++;
                *(obj.caml_gc_phase) = 2;
                goto label_0;
            }
            *(obj.caml_gc_sweep_hp) = eax;
            eax += *((eax - 8));
            *(obj.limit) = eax;
        }
label_3:
    } while (esi > 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806438c */
#include <stdint.h>
 
void clear_table (void) {
    edx = *(eax);
    *((eax + 0xc)) = edx;
    edx = *((eax + 8));
    *((eax + 0x10)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80647c5 */
#include <stdint.h>
 
int32_t reset_table (void) {
    ebx = eax;
    *((eax + 0x14)) = 0;
    *((eax + 0x18)) = 0;
    eax = *(eax);
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *((ebx + 4)) = 0;
    *((ebx + 0x10)) = 0;
    *((ebx + 8)) = 0;
    *((ebx + 0xc)) = 0;
    *(ebx) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064af1 */
#include <stdint.h>
 
int32_t caml_stat_free (void * ptr) {
    eax = *((ebp + 8));
    free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064d37 */
#include <stdint.h>
 
uint32_t caml_page_table_modify (void) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    size_t size;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = eax;
    edi = edx;
    *((ebp - 0x1c)) = ecx;
    esi = eax;
    esi >>= 0x17;
    if (*((esi*4 + obj.caml_page_table)) == 0x807ec00) {
        eax = calloc (0x800, 1);
        edx = eax;
        eax = 0xffffffff;
        if (edx == 0) {
            goto label_0;
        }
        *((esi*4 + obj.caml_page_table)) = edx;
    }
    ebx >>= 0xc;
    ebx &= 0x7ff;
    ebx += *((esi*4 + obj.caml_page_table));
    eax = edi;
    eax = ~eax;
    al &= *(ebx);
    al |= *((ebp - 0x1c));
    *(ebx) = al;
    eax = 0;
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049fd4 */
#include <stdint.h>
 
void calloc (void) {
    calloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065580 */
#include <stdint.h>
 
int32_t compare_free_stack (void) {
    eax = compare_stack;
    if (eax != obj.compare_stack_init) {
        free (eax);
        *(obj.compare_stack) = 0x807f400;
        *(obj.compare_stack_limit) = 0x8080000;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80655b0 */
#include <stdint.h>
 
void compare_stack_overflow (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (4, "Stack overflow in structural comparison\n", 0);
    compare_free_stack ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80655dc */
#include <stdint.h>
 
int32_t compare_val (void) {
    int32_t var_3ch;
    size_t size;
    uint32_t var_34h;
    void * var_30h;
    int32_t var_2ch;
    uint32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    void * s1;
    char * s2;
    size_t n;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x24)) = ecx;
    ebx = compare_stack;
    do {
label_0:
        eax = *((ebp - 0x20));
        al = (*((ebp - 0x1c)) == eax) ? 1 : 0;
        if (*((ebp - 0x1c)) == eax) {
            if (*((ebp - 0x24)) != 0) {
                goto label_1;
            }
        }
        if ((*((ebp - 0x1c)) & 1) == 0) {
            goto label_2;
        }
        if (al != 0) {
            goto label_1;
        }
        if ((*((ebp - 0x20)) & 1) != 0) {
            eax = *((ebp - 0x1c));
            eax >>= 1;
            ecx = *((ebp - 0x20));
            ecx >>= 1;
            eax -= ecx;
            goto label_3;
        }
        ecx = *((ebp - 0x20));
        edx = *((ebp - 0x20));
        edx >>= 0x17;
        eax = ecx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_4;
        }
        eax = *((ecx - 4));
        if (al != 0xfa) {
            if (al != 0xff) {
                goto label_4;
            }
        } else {
            edx = *((ebp - 0x20));
            edx = *(edx);
            *((ebp - 0x20)) = edx;
        }
    } while (1);
    ecx = *((ebp - 0x20));
    eax = *(ecx);
    eax = *((eax + 0x18));
    if (eax == 0) {
        goto label_4;
    }
    *(obj.caml_compare_unordered) = 0;
    edx = *((ebp - 0x1c));
    eax = void (*eax)(uint32_t, uint32_t) (edx, ecx);
    if (*(obj.caml_compare_unordered) != 0) {
        if (*((ebp - 0x24)) == 0) {
            goto label_5;
        }
    }
    if (eax == 0) {
        goto label_1;
    }
    goto label_3;
label_2:
    if ((*((ebp - 0x20)) & 1) != 0) {
        ecx = *((ebp - 0x1c));
        edx = *((ebp - 0x1c));
        edx >>= 0x17;
        eax = ecx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_6;
        }
        eax = *((ecx - 4));
        if (al != 0xfa) {
            if (al != 0xff) {
                goto label_6;
            }
        } else {
            ecx = *((ebp - 0x1c));
            ecx = *(ecx);
            *((ebp - 0x1c)) = ecx;
            goto label_0;
        }
        edx = *((ebp - 0x1c));
        eax = *(edx);
        eax = *((eax + 0x18));
        if (eax == 0) {
            goto label_6;
        }
        *(obj.caml_compare_unordered) = 0;
        ecx = *((ebp - 0x20));
        eax = void (*eax)(uint32_t, uint32_t) (edx, ecx);
        if (*(obj.caml_compare_unordered) != 0) {
            if (*((ebp - 0x24)) == 0) {
                goto label_5;
            }
        }
        if (eax == 0) {
            goto label_1;
        }
        goto label_3;
    }
    edx = *((ebp - 0x1c));
    *((ebp - 0x28)) = edx;
    ecx = edx;
    ecx >>= 0x17;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 7) != 0) {
        ecx = *((ebp - 0x20));
        *((ebp - 0x2c)) = ecx;
        ecx >>= 0x17;
        edx = *((ebp - 0x20));
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 7) != 0) {
            goto label_7;
        }
    }
    if (al != 0) {
        goto label_1;
    }
    edx = *((ebp - 0x1c));
    edx >>= 1;
    eax = *((ebp - 0x20));
    eax >>= 1;
    edx -= eax;
    eax = edx;
    goto label_3;
label_7:
    edi = *((ebp - 0x28));
    edi -= 4;
    esi = *(edi);
    ecx = esi;
    edx = (int32_t) cl;
    ecx = *((ebp - 0x2c));
    ecx -= 4;
    *((ebp - 0x30)) = ecx;
    ecx = *(ecx);
    *((ebp - 0x34)) = cl;
    if (edx == 0xfa) {
        eax = *((ebp - 0x1c));
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        goto label_0;
    }
    ecx = *((ebp - 0x34));
    if (ecx == 0xfa) {
        edx = *((ebp - 0x20));
        edx = *(edx);
        *((ebp - 0x20)) = edx;
        goto label_0;
    }
    if (edx != ecx) {
        edx -= ecx;
        eax = edx;
        goto label_3;
    }
    edx = esi + 9;
    if (dl > 8) {
        goto label_8;
    }
    edx = (int32_t) dl;
    /* switch table (9 cases) at 0x807136c */
    if (al != 0) {
        goto label_1;
    }
    ecx = *((ebp - 0x1c));
    eax = caml_string_length (ecx);
    esi = eax;
    eax = *((ebp - 0x20));
    eax = caml_string_length (eax);
    edi = eax;
    eax = esi;
    if (eax <= esi) {
        eax = edi;
    }
    edx = *((ebp - 0x20));
    ecx = *((ebp - 0x1c));
    eax = memcmp (ecx, edx, eax);
    if (eax < 0) {
        goto label_4;
    }
    if (eax > 0) {
        goto label_6;
    }
    if (esi == edi) {
        goto label_1;
    }
    eax = esi;
    eax -= edi;
    goto label_3;
    eax = *((ebp - 0x1c));
    *(fp_stack--) = *(eax);
    edx = *((ebp - 0x20));
    *(fp_stack--) = *(edx);
    if (fp_stack[0] > fp_stack[1]) {
        goto label_9;
    }
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_10;
    }
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
    if (*((ebp - 0x24)) == 0) {
        goto label_12;
    }
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_13;
        }
    }
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        goto label_1;
    }
    if (fp_stack[0] != fp_stack[0]) {
        goto label_4;
    }
    goto label_1;
    edx = *(edi);
    edx >>= 0xb;
    ecx = *((ebp - 0x30));
    eax = *(ecx);
    eax >>= 0xb;
    if (edx == eax) {
        if (edx == 0) {
            goto label_1;
        }
        eax = *((ebp - 0x28));
        *(fp_stack--) = *(eax);
        ecx = *((ebp - 0x2c));
        *(fp_stack--) = *(ecx);
        if (fp_stack[0] > fp_stack[1]) {
            goto label_14;
        }
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_15;
        }
        eax = 0;
        esi = *((ebp - 0x28));
        goto label_16;
    }
    edx -= eax;
    eax = edx;
    goto label_3;
    do {
        *(fp_stack--) = *((esi + eax*8));
        *(fp_stack--) = *((ecx + eax*8));
        if (fp_stack[0] > fp_stack[1]) {
            goto label_17;
        }
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_18;
        }
label_16:
        if (fp_stack[0] != fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_19;
            }
        }
        if (*((ebp - 0x24)) == 0) {
            goto label_20;
        }
        fp_stack--;
        if (fp_stack[0] != fp_stack[0]) {
            if (fp_stack[0] == fp_stack[0]) {
                goto label_21;
            }
        }
        fp_stack--;
        if (fp_stack[0] != fp_stack[0]) {
            if (fp_stack[0] == fp_stack[0]) {
                goto label_4;
            }
            goto label_22;
label_19:
            fp_stack++;
            fp_stack++;
        }
label_22:
        eax++;
    } while (edx > eax);
    goto label_1;
    compare_free_stack ();
    caml_invalid_argument ("equal: abstract value");
    compare_free_stack ();
    caml_invalid_argument ("equal: functional value");
    eax = *((ebp - 0x28));
    edx = *((eax + 4));
    edx >>= 1;
    ecx = *((ebp - 0x2c));
    eax = *((ecx + 4));
    eax >>= 1;
    if (edx != eax) {
        edx -= eax;
        eax = edx;
        goto label_3;
        eax = *((ebp - 0x1c));
        ecx = *(eax);
        edx = *((ebp - 0x20));
        eax = *(edx);
        edx = *((eax + 8));
        if (edx != *((ecx + 8))) {
            edx = *(ecx);
            eax = *(eax);
            eax = strcmp (edx, eax);
            if (eax >= 0) {
                goto label_6;
            }
            goto label_4;
        }
        if (edx == 0) {
            compare_free_stack ();
            caml_invalid_argument ("equal: abstract value");
        }
        *(obj.caml_compare_unordered) = 0;
        ecx = *((ebp - 0x20));
        eax = *((ebp - 0x1c));
        eax = void (*edx)(uint32_t, uint32_t) (eax, ecx);
        if (*(obj.caml_compare_unordered) != 0) {
            if (*((ebp - 0x24)) == 0) {
                goto label_5;
            }
        }
        if (eax == 0) {
            goto label_1;
        }
        goto label_3;
label_8:
        eax = *(edi);
        eax >>= 0xa;
        *((ebp - 0x34)) = eax;
        edx = *((ebp - 0x30));
        eax = *(edx);
        eax >>= 0xa;
        if (*((ebp - 0x34)) != eax) {
            ecx = *((ebp - 0x34));
            ecx -= eax;
            eax = ecx;
            goto label_3;
        }
        if (*((ebp - 0x34)) == 0) {
            goto label_1;
        }
        if (*((ebp - 0x34)) > 1) {
            ebx += 0xc;
            eax = compare_stack_limit;
            if (ebx >= eax) {
                edx = compare_stack;
                *((ebp - 0x3c)) = edx;
                eax -= edx;
                eax >>= 2;
                eax *= 0xaaaaaaab;
                eax += eax;
                *((ebp - 0x38)) = eax;
                if (eax > 0xfffff) {
                    eax = compare_stack_overflow ();
                }
                edx = compare_stack;
                if (edx == obj.compare_stack_init) {
                    eax = *((ebp - 0x38)) * 0xc;
                    eax = malloc (eax);
                    *((ebp - 0x30)) = eax;
                    if (eax == 0) {
                        eax = compare_stack_overflow ();
                    }
                    ecx = 0x300;
                    edi = *((ebp - 0x30));
                    esi = compare_stack_init;
                    *(es:edi) = *(esi);
                    ecx--;
                    esi += 4;
                    es:edi += 4;
                } else {
                    eax = *((ebp - 0x38)) * 0xc;
                    eax = realloc (edx, eax);
                    *((ebp - 0x30)) = eax;
                    if (eax != 0) {
                        goto label_23;
                    }
                    eax = compare_stack_overflow ();
                }
label_23:
                ecx = *((ebp - 0x30));
                *(obj.compare_stack) = ecx;
                eax = *((ebp - 0x38)) * 0xc;
                eax += ecx;
                *(obj.compare_stack_limit) = eax;
                ebx -= *((ebp - 0x3c));
                ebx &= 0xfffffffc;
                ebx += ecx;
            }
            eax = *((ebp - 0x28));
            eax += 4;
            *(ebx) = eax;
            eax = *((ebp - 0x2c));
            eax += 4;
            *((ebx + 4)) = eax;
            eax = *((ebp - 0x34));
            eax--;
            *((ebx + 8)) = eax;
        }
        eax = *((ebp - 0x1c));
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        edx = *((ebp - 0x20));
        edx = *(edx);
        *((ebp - 0x20)) = edx;
        goto label_0;
label_11:
        fp_stack++;
        fp_stack++;
    }
label_1:
    if (ebx == *(obj.compare_stack)) {
        eax = 0;
    } else {
        eax = *(ebx);
        ecx = *(eax);
        *((ebp - 0x1c)) = ecx;
        eax += 4;
        *(ebx) = eax;
        eax = *((ebx + 4));
        edx = *(eax);
        *((ebp - 0x20)) = edx;
        eax += 4;
        *((ebx + 4)) = eax;
        eax = *((ebx + 8));
        eax--;
        *((ebx + 8)) = eax;
        edx = ebx - 0xc;
        if (eax == 0) {
            ebx = edx;
        }
        goto label_0;
label_12:
        fp_stack++;
        fp_stack++;
        goto label_5;
label_20:
        fp_stack++;
        fp_stack++;
label_5:
        eax = 0x80000000;
        goto label_3;
label_9:
        fp_stack++;
        fp_stack++;
        goto label_4;
label_14:
        fp_stack++;
        fp_stack++;
        goto label_4;
label_17:
        fp_stack++;
        fp_stack++;
label_4:
        eax = 0xffffffff;
        goto label_3;
label_10:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_13:
        fp_stack++;
        goto label_6;
label_15:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_18:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_21:
        fp_stack++;
label_6:
        eax = 1;
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065d90 */
#include <stdint.h>
 
int32_t parse_sign_and_base (void) {
    *(ecx) = 1;
    if (*(eax) == 0x2d) {
        *(ecx) = 0xffffffff;
        eax++;
    }
    *(edx) = 0xa;
    if (*(eax) == 0x30) {
        ecx = *((eax + 1));
        ecx -= 0x42;
        if (cl > 0x36) {
            goto label_0;
        }
        ecx = (int32_t) cl;
        /* switch table (55 cases) at 0x8071390 */
        *(edx) = 0x10;
        eax += 2;
        goto label_0;
        *(edx) = 8;
        eax += 2;
        goto label_0;
        *(edx) = 2;
        eax += 2;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065de9 */
#include <stdint.h>
 
uint32_t parse_digit (void) {
    edx = eax;
    ecx = edx - 0x30;
    if (cl <= 9) {
        edx = (int32_t) al;
        eax = edx - 0x30;
    } else {
        ecx = eax - 0x41;
        if (cl <= 5) {
            edx = (int32_t) al;
            eax = edx - 0x37;
        } else {
            ecx = eax - 0x61;
            eax = 0xffffffff;
            if (cl > 5) {
                goto label_0;
            }
            eax = (int32_t) dl;
            eax -= 0x57;
        }
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065e46 */
#include <stdint.h>
 
int32_t int32_cmp (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    al = (ecx > edx) ? 1 : 0;
    eax = (int32_t) al;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065e69 */
#include <stdint.h>
 
int32_t int32_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065eac */
#include <stdint.h>
 
int32_t int64_cmp (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    esi = *((edx + 4));
    ecx = *((edx + 8));
    edi = *((eax + 4));
    edx = *((eax + 8));
    eax = 1;
    if (ecx <= edx) {
        if (ecx >= edx) {
            if (esi > edi) {
                goto label_0;
            }
        }
        eax = 0;
    }
label_0:
    ebx = 1;
    if (ecx >= edx) {
        if (ecx <= edx) {
            if (esi < edi) {
                goto label_1;
            }
        }
        ebx = 0;
    }
label_1:
    eax -= ebx;
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065f08 */
#include <stdint.h>
 
int32_t int64_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065f82 */
#include <stdint.h>
 
int32_t nativeint_cmp (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    al = (ecx > edx) ? 1 : 0;
    eax = (int32_t) al;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065fa5 */
#include <stdint.h>
 
int32_t nativeint_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065fe8 */
#include <stdint.h>
 
uint32_t int32_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_sint_4 ();
    edx = *((ebp + 8));
    *(edx) = eax;
    eax = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a62e */
#include <stdint.h>
 
uint32_t caml_deserialize_sint_4 (void) {
    ecx = intern_src;
    edx = ecx + 4;
    *(obj.intern_src) = edx;
    ebx = *((edx - 1));
    eax = *(ecx);
    eax <<= 0x18;
    eax = ebx + eax;
    ecx = *((edx - 3));
    ecx <<= 0x10;
    eax += ecx;
    edx = *((edx - 2));
    edx <<= 8;
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065fff */
#include <stdint.h>
 
uint32_t nativeint_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_uint_1 ();
    if (eax != 1) {
        if (eax != 2) {
            goto label_0;
        }
    } else {
        eax = caml_deserialize_sint_4 ();
        edx = *((ebp + 8));
        *(edx) = eax;
        goto label_1;
    }
    caml_deserialize_error (0x807146c);
label_0:
    caml_deserialize_error ("input_value: ill-formed native integer");
label_1:
    eax = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066043 */
#include <stdint.h>
 
int32_t nativeint_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    caml_serialize_int_1 (ebx);
    caml_serialize_int_4 (ebx);
    eax = *((ebp + 0xc));
    *(eax) = 4;
    eax = *((ebp + 0x10));
    *(eax) = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069a74 */
#include <stdint.h>
 
int32_t caml_serialize_int_1 (int32_t arg_8h) {
    eax = extern_ptr;
    eax++;
    if (*(obj.extern_limit) < eax) {
        eax = 1;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = *((ebp + 8));
    *(eax) = dl;
    eax++;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80696d6 */
#include <stdint.h>
 
uint32_t grow_extern_output (void) {
    if (*(obj.extern_userprovided_output) != 0) {
        extern_replay_trail ();
        eax = caml_failwith ("Marshal.to_buffer: buffer overflow");
    }
    ecx = extern_ptr;
    edx = extern_output_block;
    *((edx + 4)) = ecx;
    esi = 0;
    if (eax >= 0xfd3) {
        esi = eax;
    }
    eax = esi + 0x1fac;
    eax = malloc (eax);
    ebx = eax;
    if (eax == 0) {
        extern_out_of_memory ();
    }
    eax = extern_output_block;
    *(eax) = ebx;
    *(obj.extern_output_block) = ebx;
    *(ebx) = 0;
    eax = ebx + 8;
    *(obj.extern_ptr) = eax;
    eax = ebx + esi + 0x1fac;
    *(obj.extern_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80699e2 */
#include <stdint.h>
 
int32_t caml_serialize_int_4 (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = extern_ptr;
    eax += 4;
    if (*(obj.extern_limit) < eax) {
        eax = 4;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 0x18;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 2)) = dl;
    *((eax + 3)) = bl;
    eax += 4;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806607c */
#include <stdint.h>
 
int32_t int32_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_serialize_int_4 (eax);
    eax = *((ebp + 0x10));
    *(eax) = 4;
    eax = *((ebp + 0xc));
    *(eax) = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80660a4 */
#include <stdint.h>
 
uint32_t int64_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_sint_8 (ebx);
    ecx = eax;
    ebx = edx;
    edx = *((ebp + 8));
    *(edx) = ecx;
    *((edx + 4)) = ebx;
    eax = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a7c4 */
#include <stdint.h>
 
uint32_t caml_deserialize_sint_8 (void) {
    int32_t var_8h;
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 8;
    caml_deserialize_block_8 (eax, 1);
    eax = *((ebp - 8));
    edx = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a73c */
#include <stdint.h>
 
int32_t caml_deserialize_block_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14h;
    int32_t var_10h;
    edi = intern_src;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    edx = *((ebp + 8));
    eax = edi;
    ecx = *((ebp + 0xc));
    *((ebp - 0x14)) = ecx;
    *((ebp - 0x10)) = edi;
    do {
        esi = *(eax);
        ebx = *((eax + 1));
        edi = *((eax + 7));
        ecx = edi;
        *(edx) = cl;
        edi = *((eax + 6));
        ecx = edi;
        *((edx + 1)) = cl;
        ecx = esi;
        *((edx + 7)) = cl;
        *((edx + 6)) = bl;
        esi = *((eax + 2));
        ebx = *((eax + 3));
        edi = *((eax + 5));
        ecx = edi;
        *((edx + 2)) = cl;
        edi = *((eax + 4));
        ecx = edi;
        *((edx + 3)) = cl;
        ecx = esi;
        *((edx + 5)) = cl;
        *((edx + 4)) = bl;
        eax += 8;
        edx += 8;
        *((ebp - 0x14))--;
    } while (*((ebp - 0x14)) != 0);
    edi = *((ebp - 0x10));
    eax = *((ebp + 0xc));
    edi = edi + eax*8;
label_0:
    *(obj.intern_src) = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80660c7 */
#include <stdint.h>
 
int32_t int64_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_serialize_int_8 (eax, edx);
    eax = *((ebp + 0x10));
    *(eax) = 8;
    eax = *((ebp + 0xc));
    *(eax) = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806986d */
#include <stdint.h>
 
int32_t caml_serialize_int_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = *((ebp + 8));
    *((ebp - 0x10)) = eax;
    eax = *((ebp + 0xc));
    *((ebp - 0xc)) = eax;
    eax = ebp - 0x10;
    caml_serialize_block_8 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80697ca */
#include <stdint.h>
 
int32_t caml_serialize_block_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_2ch;
    int32_t var_1ch;
    eax = *((ebp + 0xc));
    eax <<= 3;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    edi = extern_ptr;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    edx = *((ebp + 8));
    eax = edi;
    ecx = *((ebp + 0xc));
    *((ebp - 0x2c)) = ecx;
    *((ebp - 0x1c)) = edi;
    do {
        esi = *(edx);
        ebx = *((edx + 1));
        edi = *((edx + 7));
        ecx = edi;
        *(eax) = cl;
        edi = *((edx + 6));
        ecx = edi;
        *((eax + 1)) = cl;
        ecx = esi;
        *((eax + 7)) = cl;
        *((eax + 6)) = bl;
        esi = *((edx + 2));
        ebx = *((edx + 3));
        edi = *((edx + 5));
        ecx = edi;
        *((eax + 2)) = cl;
        edi = *((edx + 4));
        ecx = edi;
        *((eax + 3)) = cl;
        ecx = esi;
        *((eax + 5)) = cl;
        *((eax + 4)) = bl;
        edx += 8;
        eax += 8;
        *((ebp - 0x2c))--;
    } while (*((ebp - 0x2c)) != 0);
    edi = *((ebp - 0x1c));
    eax = *((ebp + 0xc));
    edi = edi + eax*8;
label_0:
    *(obj.extern_ptr) = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80660f6 */
#include <stdint.h>
 
uint32_t parse_intnat (void) {
    uint32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    uint32_t var_2ch;
    uint32_t var_20h;
    int32_t var_1ch;
    *((ebp - 0x34)) = eax;
    *((ebp - 0x38)) = edx;
    ecx = ebp - 0x1c;
    edx = ebp - 0x20;
    eax = parse_sign_and_base (ebx, esi, edi);
    ebx = eax;
    edi = *((ebp - 0x20));
    *((ebp - 0x30)) = edi;
    eax = 0xffffffff;
    edx = 0;
    eax = edx:eax / edi;
    edx = edx:eax % edi;
    *((ebp - 0x2c)) = eax;
    eax = *(ebx);
    eax = parse_digit ();
    if (eax >= 0) {
        if (edi > eax) {
            goto label_0;
        }
    }
    eax = caml_failwith ("int_of_string");
label_0:
    ebx++;
    esi = eax;
    do {
        eax = *(ebx);
        if (al != 0x5f) {
            eax = (int32_t) al;
            eax = parse_digit ();
            if (eax < 0) {
                goto label_1;
            }
            if (edi <= eax) {
                goto label_1;
            }
            if (esi > *((ebp - 0x2c))) {
                caml_failwith ("int_of_string");
            }
            esi *= *((ebp - 0x30));
            esi += eax;
            if (esi >= 0) {
                goto label_2;
            }
            caml_failwith ("int_of_string");
        }
label_2:
        ebx++;
    } while (1);
label_1:
    eax = *((ebp - 0x34));
    eax = caml_string_length (eax);
    eax += *((ebp - 0x34));
    if (ebx != eax) {
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x20)) == 0xa) {
        if (*((ebp - 0x1c)) >= 0) {
            ecx = *((ebp - 0x38));
            ecx--;
            eax = 1;
            eax <<= cl;
            if (eax > esi) {
                goto label_3;
            }
            caml_failwith ("int_of_string");
        }
        ecx = *((ebp - 0x38));
        ecx--;
        eax = 1;
        eax <<= cl;
        if (eax >= esi) {
            goto label_4;
        }
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x38)) <= 0x1f) {
        eax = 1;
        ecx = *((ebp - 0x38));
        eax <<= cl;
        if (eax > esi) {
            goto label_5;
        }
        caml_failwith ("int_of_string");
    }
label_5:
    if (*((ebp - 0x1c)) < 0) {
label_4:
        eax = esi;
        eax = -eax;
    } else {
label_3:
        eax = esi;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806623d */
#include <stdint.h>
 
uint32_t parse_format (int32_t arg_8h, int32_t arg_ch) {
    void * s1;
    int32_t var_20h;
    int32_t var_1ch;
    char * * endptr;
    size_t base;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x24)) = ecx;
    eax = caml_string_length (ebx, esi, edi);
    ebx = eax;
    edi = *((ebp - 0x20));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    esi = ecx - 1;
    eax = esi + ebx + 1;
    if (eax > 0x1f) {
        caml_invalid_argument ("format_int: format too long");
    }
    eax = *((ebp - 0x1c));
    edx = *((ebp - 0x24));
    memmove (edx, eax, ebx);
    ecx = *((ebp - 0x24));
    ebx = ecx + ebx - 1;
    edi = *(ebx);
    edx = ebx - 1;
    eax = *(edx);
    if (al != 0x6c) {
        if (al == 0x6e) {
            goto label_0;
        }
        if (al != 0x4c) {
            goto label_1;
        }
    }
label_0:
    ebx = edx;
label_1:
    eax = *((ebp - 0x20));
    memmove (ebx, eax, esi);
    ebx += esi;
    edx = edi;
    *(ebx) = dl;
    *((ebx + 1)) = 0;
    eax = *((ebp - 0x1c));
    edx = *(eax);
    if (dl == 0) {
        goto label_2;
    }
    edx -= 0x30;
    if (dl > 9) {
        goto label_3;
    }
    while (dl != 0) {
        edx -= 0x30;
        if (dl <= 9) {
            eax = strtol (eax, 0, 0xa);
            eax += 5;
            ecx = edi;
            edx = *((ebp + 0xc));
            *(edx) = cl;
            if (eax > 0x1f) {
                goto label_4;
            }
            goto label_5;
        }
label_3:
        eax++;
        edx = *(eax);
    }
    goto label_2;
label_4:
    eax++;
    eax = caml_stat_alloc (eax);
    *((ebp + 8)) = eax;
    do {
label_5:
        eax = *((ebp + 8));
        return eax;
label_2:
        ecx = edi;
        eax = *((ebp + 0xc));
        *(eax) = cl;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068220 */
#include <stdint.h>
 
int32_t unlink_channel (void) {
    edx = *((eax + 0x20));
    if (edx == 0) {
        eax = caml_all_opened_channels;
        eax = *((eax + 0x1c));
        *(obj.caml_all_opened_channels) = eax;
        if (eax == 0) {
            goto label_0;
        }
        *((eax + 0x20)) = 0;
    } else {
        ecx = *((eax + 0x1c));
        *((edx + 0x1c)) = ecx;
        edx = *((eax + 0x1c));
        if (edx == 0) {
            goto label_0;
        }
        eax = *((eax + 0x20));
        *((edx + 0x20)) = eax;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80682b6 */
#include <stdint.h>
 
int32_t compare_channel (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    eax = 0;
    if (ecx != edx) {
        eax -= eax;
        eax |= 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068dcc */
#include <stdint.h>
 
int32_t do_write (void) {
    int32_t var_1ch;
    char * ptr;
    size_t nbytes;
    edi = eax;
    *((ebp - 0x1c)) = edx;
    esi = ecx;
    do {
label_0:
        caml_enter_blocking_section (ebx, esi, edi);
        eax = *((ebp - 0x1c));
        eax = write (edi, eax, esi);
        ebx = eax;
        caml_leave_blocking_section ();
        if (ebx != -1) {
            goto label_1;
        }
        eax = errno_location ();
        eax = *(eax);
    } while (eax == 4);
    if (eax == 0xb) {
        if (esi <= 1) {
            goto label_2;
        }
        esi = 1;
        goto label_0;
    }
label_2:
    caml_sys_io_error (1);
label_1:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069600 */
#include <stdint.h>
 
int32_t extern_replay_trail (void) {
    void ** ptr;
    eax = extern_trail_block;
    *((ebp - 0x1c)) = eax;
    edi = extern_trail_cur;
label_0:
    eax = *((ebp - 0x1c));
    eax += 4;
    if (edi <= eax) {
        goto label_1;
    }
    do {
        ebx = *(eax);
        edx = *(eax);
        edx &= 0xfffffffc;
        ecx = edx - 4;
        esi = *(ecx);
        esi &= 0xfffffcff;
        ebx &= 3;
        ebx <<= 8;
        ebx |= esi;
        *(ecx) = ebx;
        ecx = *((eax + 4));
        *(edx) = ecx;
        eax += 8;
    } while (edi > eax);
label_1:
    if (*((ebp - 0x1c)) != obj.extern_trail_first) {
        eax = *((ebp - 0x1c));
        ebx = *(eax);
        free (eax);
        edi = ebx + 0x200c;
        *((ebp - 0x1c)) = ebx;
        goto label_0;
    }
    *(obj.extern_trail_block) = 0x8080040;
    *(obj.extern_trail_cur) = 0x8080044;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069686 */
#include <stdint.h>
 
int32_t free_extern_output (void) {
    if (*(obj.extern_userprovided_output) != 0) {
        goto label_0;
    }
    eax = extern_output_first;
    if (eax == 0) {
        goto label_1;
    }
    do {
        ebx = *(eax);
        free (eax);
        if (ebx == 0) {
            goto label_1;
        }
        eax = ebx;
    } while (1);
label_1:
    *(obj.extern_output_first) = 0;
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80696c1 */
#include <stdint.h>
 
void extern_out_of_memory (void) {
    extern_replay_trail ();
    free_extern_output ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069aa8 */
#include <stdint.h>
 
int32_t writecode16 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = extern_ptr;
    eax += 3;
    if (*(obj.extern_limit) < eax) {
        eax = 3;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = esi;
    *(eax) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 1)) = dl;
    *((eax + 2)) = bl;
    eax += 3;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069afa */
#include <stdint.h>
 
int32_t writecode8 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    ebx = eax;
    esi = edx;
    eax = extern_ptr;
    eax += 2;
    if (*(obj.extern_limit) < eax) {
        eax = 2;
        grow_extern_output ();
    }
    eax = extern_ptr;
    *(eax) = bl;
    edx = esi;
    *((eax + 1)) = dl;
    eax += 2;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069b44 */
#include <stdint.h>
 
int32_t writecode32 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = extern_ptr;
    eax += 5;
    if (*(obj.extern_limit) < eax) {
        eax = 5;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = esi;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x18;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 2)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 3)) = dl;
    *((eax + 4)) = bl;
    eax += 5;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069ba6 */
#include <stdint.h>
 
int32_t writeblock (void) {
    int32_t var_8h;
    int32_t var_4h;
    void ** s2;
    size_t * n;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = edx;
    eax += *(obj.extern_ptr);
    if (*(obj.extern_limit) < eax) {
        eax = edx;
        grow_extern_output ();
    }
    eax = extern_ptr;
    memmove (eax, esi, ebx);
    *(obj.extern_ptr) += ebx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069bf2 */
#include <stdint.h>
 
int32_t write32 (void) {
    ebx = eax;
    eax = extern_ptr;
    eax += 4;
    if (*(obj.extern_limit) < eax) {
        eax = 4;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 0x18;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 2)) = dl;
    *((eax + 3)) = bl;
    eax += 4;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069c42 */
#include <stdint.h>
 
int32_t extern_record_location (void) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = eax;
    if (*(obj.extern_ignore_sharing) == 0) {
        eax = extern_trail_cur;
        if (eax == *(obj.extern_trail_limit)) {
            eax = malloc (0x200c);
            esi = eax;
            if (eax == 0) {
                extern_out_of_memory ();
            }
            eax = extern_trail_block;
            *(esi) = eax;
            *(obj.extern_trail_block) = esi;
            eax = esi + 4;
            *(obj.extern_trail_cur) = eax;
            esi += 0x200c;
            *(obj.extern_trail_limit) = esi;
        }
        edx = ebx - 4;
        ecx = *(edx);
        eax = extern_trail_cur;
        esi = ecx;
        esi >>= 8;
        esi &= 3;
        esi |= ebx;
        *(eax) = esi;
        esi = *(ebx);
        *((eax + 4)) = esi;
        eax += 8;
        *(obj.extern_trail_cur) = eax;
        ch &= 0xfc;
        ch |= 2;
        *(edx) = ecx;
        eax = obj_counter;
        *(ebx) = eax;
        eax++;
        *(obj.obj_counter) = eax;
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069ce2 */
#include <stdint.h>
 
uint32_t init_extern_output (void) {
    *(obj.extern_userprovided_output) = 0;
    eax = malloc (0x1fac);
    *(obj.extern_output_first) = eax;
    if (eax == 0) {
        eax = caml_raise_out_of_memory ();
    }
    *(obj.extern_output_block) = eax;
    *(eax) = 0;
    edx = eax + 8;
    *(obj.extern_ptr) = edx;
    eax += 0x1fac;
    *(obj.extern_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069d2c */
#include <stdint.h>
 
void extern_invalid_argument (void) {
    ebx = eax;
    extern_replay_trail (ebx);
    free_extern_output ();
    return caml_invalid_argument (ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069d47 */
#include <stdint.h>
 
int32_t extern_rec (void) {
    int32_t var_4ch;
    int32_t var_30h;
    uint32_t var_2ch;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
label_1:
    ebx = eax;
    while ((al & 1) != 0) {
label_0:
        ebx = *((ebp - 0x4c));
label_2:
        if ((bl & 1) != 0) {
            ebx >>= 1;
            eax = ebx;
            if (ebx <= 0x3f) {
                eax = extern_ptr;
                if (eax >= *(obj.extern_limit)) {
                    eax = 1;
                    grow_extern_output ();
                }
                eax = extern_ptr;
                ebx += 0x40;
                *(eax) = bl;
                eax++;
                *(obj.extern_ptr) = eax;
                goto label_3;
            }
            edx = ebx + 0x80;
            if (edx <= 0xff) {
                edx = ebx;
                eax = 0;
                eax = writecode8 ();
                goto label_3;
            }
            eax += 0x8000;
            if (eax <= 0xffff) {
                edx = ebx;
                eax = 1;
                writecode16 ();
                goto label_3;
            }
            edx = ebx;
            eax = 2;
            writecode32 ();
            goto label_3;
        }
        esi = ebx;
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_4;
        }
        edx = *((ebx - 4));
        edi = (int32_t) dl;
        if (edi != 0xfa) {
            goto label_5;
        }
        eax = *(ebx);
        *((ebp - 0x4c)) = eax;
    }
    *((ebp - 0x30)) = eax;
    eax >>= 0x17;
    ecx = *((ebp - 0x4c));
    ecx >>= 0xc;
    ecx &= 0x7ff;
    eax = *((eax*4 + obj.caml_page_table));
    if ((*((eax + ecx)) & 7) == 0) {
        goto label_5;
    }
    eax = *((ebp - 0x30));
    eax = *((eax - 4));
    *((ebp - 0x2c)) = al;
    if (al == 0xfa) {
        goto label_5;
    }
    if (al == 0xf6) {
        goto label_5;
    }
    if (al != 0xfd) {
        goto label_0;
    }
label_5:
    ecx = edx;
    ecx >>= 0xa;
    *((ebp - 0x2c)) = ecx;
    if (ecx == 0) {
        if (edi <= 0xf) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = edi - 0x80;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
            goto label_3;
        }
        eax = 8;
        writecode32 ();
        goto label_3;
    }
    eax = edx;
    eax &= 0x300;
    if (eax == 0x200) {
        edx = obj_counter;
        edx -= *(ebx);
        if (edx <= 0xff) {
            ax = 4;
            writecode8 ();
            goto label_3;
        }
        if (edx <= 0xffff) {
            eax = 5;
            writecode16 ();
            goto label_3;
        }
        eax = 6;
        writecode32 ();
        goto label_3;
    }
    eax = edi - 0xf9;
    if (eax <= 6) {
        /* switch table (7 cases) at 0x807166c */
        eax = caml_string_length (ebx);
        esi = eax;
        if (eax <= 0x1f) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = esi + 0x20;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
        } else {
            if (eax <= 0xff) {
                edx = eax;
                eax = 9;
                eax = writecode8 ();
            } else {
                edx = eax;
                eax = 0xa;
                writecode32 ();
            }
        }
        edx = esi;
        eax = ebx;
        writeblock ();
        eax = esi + 4;
        eax >>= 2;
        edx = size_32;
        eax = edx + eax + 1;
        *(obj.size_32) = eax;
        esi += 8;
        esi >>= 3;
        eax = size_64;
        eax = eax + esi + 1;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        eax = extern_ptr;
        if (eax >= *(obj.extern_limit)) {
            eax = 1;
            grow_extern_output ();
        }
        eax = extern_ptr;
        *(eax) = 0xc;
        eax++;
        *(obj.extern_ptr) = eax;
        edx = 8;
        eax = ebx;
        writeblock ();
        *(obj.size_32) += 3;
        *(obj.size_64) += 2;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        esi = *((ebp - 0x2c));
        esi >>= 1;
        if (esi <= 0xff) {
            edx = esi;
            eax = 0xe;
            writecode8 ();
        } else {
            edx = esi;
            eax = 7;
            writecode32 ();
        }
        edx = esi*8;
        eax = ebx;
        writeblock ();
        eax = size_32;
        eax = eax + esi*2 + 1;
        *(obj.size_32) = eax;
        eax = size_64;
        eax = esi + eax + 1;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        eax = "output_value: abstract value (Abstract)";
        extern_invalid_argument ();
        ebx = *((ebp - 0x2c));
        ebx <<= 2;
        edx = ebx;
        eax = 0x11;
        writecode32 ();
        eax = esi;
        eax -= ebx;
        extern_rec ();
        goto label_1;
        goto label_3;
        *((ebp - 0x2c)) = ebx;
        eax = *(ebx);
        esi = *(eax);
        if (*((eax + 0x10)) == 0) {
            eax = "output_value: abstract value (Custom)";
            extern_invalid_argument ();
        }
        eax = extern_ptr;
        if (eax >= *(obj.extern_limit)) {
            eax = 1;
            grow_extern_output ();
        }
        eax = extern_ptr;
        *(eax) = 0x12;
        eax++;
        *(obj.extern_ptr) = eax;
        edi = esi;
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        edx = ecx;
        edx = ~edx;
        eax = esi;
        writeblock ();
        edx = *((ebp - 0x2c));
        eax = *(edx);
        edx = ebp - 0x20;
        edx = ebp - 0x1c;
        uint32_t (*eax + 0x10)(uint32_t, uint32_t, uint32_t) (ebx, edx, edx);
        eax = *((ebp - 0x1c));
        eax += 3;
        eax >>= 2;
        edx = size_32;
        eax = edx + eax + 2;
        *(obj.size_32) = eax;
        eax = *((ebp - 0x20));
        eax += 7;
        eax >>= 3;
        edx = size_64;
        eax = edx + eax + 2;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
    }
    if (edi <= 0xf) {
        if (*((ebp - 0x2c)) <= 7) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = *((ebp - 0x2c));
            edx <<= 4;
            edx = edx + edi - 0x80;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
        }
    } else {
        dh &= 0xfc;
        eax = 8;
        writecode32 ();
    }
    eax = size_32;
    ecx = *((ebp - 0x2c));
    eax = ecx + eax + 1;
    *(obj.size_32) = eax;
    eax = size_64;
    eax = ecx + eax + 1;
    *(obj.size_64) = eax;
    edi = *(ebx);
    eax = ebx;
    extern_record_location ();
    ebx = edi;
    if (*((ebp - 0x2c)) == 1) {
        goto label_2;
    }
    eax = edi;
    extern_rec ();
    goto label_1;
    edi = *((ebp - 0x2c));
    edi--;
    ebx = 1;
    if (edi > 1) {
        goto label_6;
    }
    edi = 1;
    goto label_7;
    do {
label_6:
        eax = *((esi + ebx*4));
        extern_rec ();
        goto label_1;
        ebx++;
    } while (edi > ebx);
label_7:
    ebx = *((esi + edi*4));
    goto label_2;
label_4:
    if (ebx >= *(obj.caml_code_area_start)) {
        if (ebx < *(obj.caml_code_area_end)) {
            if (*(obj.extern_closures) == 0) {
                eax = "output_value: functional value";
                extern_invalid_argument ();
            }
            edx = ebx;
            edx -= *(obj.caml_code_area_start);
            eax = 0x10;
            writecode32 ();
            caml_code_checksum ();
            edx = 0x10;
            writeblock ();
        }
    } else {
        eax = "output_value: abstract value (outside heap)";
        extern_invalid_argument ();
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a23d */
#include <stdint.h>
 
uint32_t extern_value (void) {
    int32_t var_4h;
    ebx = eax;
    eax = caml_convert_flag_list (ebx, 0x807b80c);
    edx = eax;
    edx &= 1;
    *(obj.extern_ignore_sharing) = edx;
    eax &= 2;
    *(obj.extern_closures) = eax;
    *(obj.extern_trail_block) = 0x8080040;
    *(obj.extern_trail_cur) = 0x8080044;
    *(obj.extern_trail_limit) = 0x808204c;
    *(obj.obj_counter) = 0;
    *(obj.size_32) = 0;
    *(obj.size_64) = 0;
    eax = 0x8495a6be;
    write32 ();
    *(obj.extern_ptr) += 0x10;
    eax = ebx;
    extern_rec ();
    if (*(obj.extern_userprovided_output) == 0) {
        edx = extern_ptr;
        eax = extern_output_block;
        *((eax + 4)) = edx;
    }
    extern_replay_trail ();
    eax = extern_userprovided_output;
    if (eax != 0) {
        ebx = extern_ptr;
        ebx -= eax;
        eax += 4;
        *(obj.extern_ptr) = eax;
        goto label_0;
    }
    ecx = extern_output_first;
    ebx = 0;
    if (ecx == 0) {
        goto label_1;
    }
    eax = ecx;
    do {
        edx = *((eax + 4));
        edx -= eax;
        ebx = edx + ebx - 8;
        eax = *(eax);
    } while (eax != 0);
    while (1) {
label_0:
        eax = ebx - 0x14;
        write32 ();
        eax = obj_counter;
        write32 ();
        eax = size_32;
        write32 ();
        eax = size_64;
        write32 ();
        eax = ebx;
        return eax;
label_1:
        eax = ecx + 0xc;
        *(obj.extern_ptr) = eax;
        ecx += 0x1fac;
        *(obj.extern_limit) = ecx;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a887 */
#include <stdint.h>
 
int32_t intern_cleanup (void) {
    if (*(obj.intern_input_malloced) != 0) {
        eax = intern_input;
        caml_stat_free (eax);
    }
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = intern_extra_block;
    if (eax != 0) {
        caml_free_for_heap (eax);
    } else {
        eax = intern_block;
        if (eax == 0) {
            goto label_0;
        }
        edx = intern_header;
        *((eax - 4)) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a9cb */
#include <stdint.h>
 
uint32_t intern_alloc (void) {
    int32_t var_4h;
    ebx = edx;
    if (eax == 0) {
        *(obj.intern_obj_table) = 0;
        *(obj.intern_extra_block) = 0;
        *(obj.intern_block) = 0;
    } else {
        edx = eax - 1;
        if (edx > 0x3fffff) {
            eax = eax*4 + 0xfff;
            eax &= 0xfffff000;
            eax = caml_alloc_for_heap (eax);
            *(obj.intern_extra_block) = eax;
            if (eax == 0) {
                eax = caml_raise_out_of_memory ();
            }
            eax = caml_allocation_color (eax);
            *(obj.intern_color) = eax;
            eax = intern_extra_block;
            *(obj.intern_dest) = eax;
        } else {
            if (edx == 0) {
                *(obj.intern_block) = 0x8082634;
            } else {
                if (edx <= 0x100) {
                    eax = caml_alloc_small (edx, 0xfc);
                    *(obj.intern_block) = eax;
                } else {
                    eax = caml_alloc_shr (edx, 0xfc);
                    *(obj.intern_block) = eax;
                }
            }
            eax = intern_block;
            eax -= 4;
            edx = *(eax);
            *(obj.intern_header) = edx;
            edx &= 0x300;
            *(obj.intern_color) = edx;
            *(obj.intern_dest) = eax;
            *(obj.intern_extra_block) = 0;
        }
        *(obj.obj_counter_1) = 0;
        if (ebx != 0) {
            ebx <<= 2;
            eax = caml_stat_alloc (ebx);
            *(obj.intern_obj_table) = eax;
        } else {
            *(obj.intern_obj_table) = 0;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806aae0 */
#include <stdint.h>
 
int32_t intern_rec (void) {
    int32_t var_40h;
    int32_t var_3ch;
    void * s2;
    size_t * n;
label_0:
    *((ebp - 0x3c)) = eax;
    esi = 0x8071824;
    do {
label_1:
        eax = intern_src;
        edx = *(eax);
        ebx = (int32_t) dl;
        eax++;
        *(obj.intern_src) = eax;
        if (ebx <= 0x3f) {
            goto label_2;
        }
        if (ebx <= 0x7f) {
            goto label_3;
        }
        edx = ebx;
        edx &= 0xf;
        ebx >>= 4;
        ebx &= 7;
        if (ebx == 0) {
            esi = edx*4 + 0x8082244;
            goto label_4;
        }
        ecx = intern_dest;
        ecx += 4;
        eax = *((ebp - 0x3c));
        *(eax) = ecx;
        eax = intern_obj_table;
        if (eax != 0) {
            edi = obj_counter;
            *((eax + edi*4)) = ecx;
            edi++;
            *(obj.obj_counter_1) = edi;
        }
        eax = intern_dest;
        ecx = eax + 4;
        *((ebp - 0x3c)) = ecx;
        edx += *(obj.intern_color);
        ecx = ebx;
        ecx <<= 0xa;
        edx += ecx;
        *(eax) = edx;
        eax = ebx*4 + 4;
        *(obj.intern_dest) += eax;
    } while (ebx <= 1);
    edi = ebx;
    eax = *((ebp - 0x3c));
    *((ebp - 0x40)) = eax;
    do {
        eax = *((ebp - 0x40));
        intern_rec ();
        goto label_0;
        edi--;
        *((ebp - 0x40)) += 4;
    } while (edi > 1);
    edx = *((ebp - 0x3c));
    edx = edx + ebx*4 - 4;
    *((ebp - 0x3c)) = edx;
    goto label_1;
label_3:
    ebx &= 0x3f;
    esi = ebx + ebx + 1;
    goto label_4;
label_2:
    if (ebx > 0x1f) {
        ebx &= 0x1f;
        eax = ebx + 4;
        eax >>= 2;
        edi = intern_dest;
        edi += 4;
        esi = edi;
        edx = intern_obj_table;
        if (edx != 0) {
            ecx = obj_counter;
            *((edx + ecx*4)) = edi;
            ecx++;
            *(obj.obj_counter_1) = ecx;
        }
        edx = eax;
        edx <<= 0xa;
        ecx = intern_color;
        ecx = ecx + edx + 0xfc;
        edx = intern_dest;
        *(edx) = ecx;
        edx = eax*4 + 4;
        *(obj.intern_dest) += edx;
        eax <<= 2;
        *((esi + eax - 4)) = 0;
        eax--;
        edx = eax;
        dl -= bl;
        *((eax + esi)) = dl;
        eax = intern_src;
        memmove (edi, eax, ebx);
        *(obj.intern_src) += ebx;
    } else {
        if (dl <= 0x13) {
            edx = (int32_t) dl;
            uint32_t (*esi + edx*4)() ();
        }
        intern_cleanup ();
        caml_failwith ("input_value: ill-formed message");
    }
label_4:
    ecx = *((ebp - 0x3c));
    *(ecx) = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b146 */
#include <stdint.h>
 
uint32_t intern_add_to_heap (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = intern_extra_block;
    if (edx != 0) {
        eax = eax*4 + 0xfff;
        eax &= 0xfffff000;
        edx += eax;
        eax = intern_dest;
        if (edx > eax) {
            edx -= eax;
            edx >>= 2;
            caml_make_free_blocks (eax, edx, 0);
        }
        eax = intern_extra_block;
        edx = intern_dest;
        edx -= eax;
        edx >>= 2;
        *(obj.caml_allocated_words) += edx;
        caml_add_to_heap (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063319 */
#include <stdint.h>
 
uint32_t caml_make_free_blocks (int32_t arg_8h, char * arg_ch, size_t arg_10h) {
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    if (edi == 0) {
        goto label_0;
    }
    do {
        ebx = 0x400000;
        if (edi <= 0x400000) {
            ebx = edi;
        }
        eax = ebx - 1;
        eax <<= 0xa;
        *(esi) = eax;
        if (*((ebp + 0x10)) != 0) {
            eax = esi + 4;
            caml_fl_merge_block (eax);
        }
        edi -= ebx;
        if (edi == 0) {
            goto label_0;
        }
        esi = esi + ebx*4;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064ee6 */
#include <stdint.h>
 
int32_t caml_add_to_heap (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    esi = ebx - 0x10;
    eax = caml_stat_heap_size;
    eax += *((esi + 8));
    eax >>= 0xa;
    caml_gc_message (ebx, esi, eax);
    eax = ebx;
    eax += *((esi + 8));
    eax = caml_page_table_add (1, ebx, eax);
    edx = eax;
    eax = 0xffffffff;
    if (edx != 0) {
        goto label_0;
    }
    eax = caml_heap_start;
    if (eax != 0) {
        if (ebx > eax) {
            goto label_1;
        }
    }
    edx = caml_heap_start;
    goto label_2;
    do {
label_1:
        edx = eax - 4;
        eax = *((eax - 4));
        if (eax == 0) {
            goto label_2;
        }
    } while (ebx > eax);
label_2:
    *((esi + 0xc)) = eax;
    *(edx) = ebx;
    *(obj.caml_stat_heap_chunks)++;
    edx = caml_stat_heap_size;
    edx += *((esi + 8));
    *(obj.caml_stat_heap_size) = edx;
    eax = 0;
    if (edx > *(obj.caml_stat_top_heap_size)) {
        *(obj.caml_stat_top_heap_size) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b1a6 */
#include <stdint.h>
 
int32_t input_val_from_block (void) {
    int32_t var_ch;
    eax = intern_src;
    ecx = eax + 4;
    ebx = *((ecx - 1));
    edx = *(eax);
    edx <<= 0x18;
    edx = ebx + edx;
    ebx = *((ecx - 3));
    ebx <<= 0x10;
    edx += ebx;
    ecx = *((ecx - 2));
    ecx <<= 8;
    edx += ecx;
    ecx = eax + 8;
    ebx = *((ecx - 4));
    ebx <<= 0x18;
    esi = *((ecx - 1));
    ebx += esi;
    esi = *((ecx - 3));
    esi <<= 0x10;
    ebx += esi;
    ecx = *((ecx - 2));
    ecx <<= 8;
    ebx += ecx;
    eax += 0xc;
    *(obj.intern_src) = eax;
    eax = ebx;
    intern_alloc (ebx, esi);
    eax = ebp - 0xc;
    intern_rec ();
    eax = ebx;
    intern_add_to_heap ();
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b61b */
#include <stdint.h>
 
int32_t hash_aux (void) {
    uint32_t var_1ch;
label_1:
    esi = eax;
    edx = hash_univ_limit;
    edx--;
    *(obj.hash_univ_limit) = edx;
    eax = hash_univ_count;
    if (eax < 0) {
        goto label_4;
    }
    if (edx < 0) {
        goto label_4;
    }
    if ((esi & 1) == 0) {
        ebx = esi;
        ecx = esi;
        ecx >>= 0x17;
        edx = esi;
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 7) != 0) {
            goto label_5;
        }
        goto label_6;
    }
label_3:
    eax--;
    *(obj.hash_univ_count) = eax;
    esi >>= 1;
    eax = *(obj.hash_accu) * 0x1003f;
    eax = esi + eax;
    *(obj.hash_accu) = eax;
    goto label_4;
label_2:
    ebx = esi;
    ecx = esi;
    ecx >>= 0x17;
    edx = esi;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 7) == 0) {
        goto label_6;
    }
label_5:
    ecx = ebx - 4;
    edx = *(ecx);
    edi = (int32_t) dl;
    *((ebp - 0x1c)) = edi;
    edx += 8;
    if (dl > 7) {
        goto label_7;
    }
    edx = (int32_t) dl;
    /* switch table (8 cases) at 0x8071874 */
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = caml_string_length (esi);
    if (eax == 0) {
        goto label_4;
    }
    edx = hash_accu;
    do {
        ecx = edx * 9;
        ecx = edx + ecx*2;
        edx = *(esi);
        edx = ecx + edx;
        esi++;
        eax--;
    } while (eax != 0);
    *(obj.hash_accu) = edx;
    goto label_4;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = hash_accu;
    ecx = esi + 8;
    do {
        edx = eax * 9;
        edx = eax + edx*2;
        eax = *(esi);
        eax = edx + eax;
        esi++;
    } while (esi != ecx);
    *(obj.hash_accu) = eax;
    goto label_4;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = *(ecx);
    eax >>= 0xa;
    eax <<= 2;
    *((ebp - 0x1c)) = eax;
    if (eax == 0) {
        goto label_4;
    }
    edx = hash_accu;
    esi = 0;
label_0:
    eax = ebx;
    ebx += 8;
    ecx = ebx;
    do {
        edi = edx * 9;
        edi = edx + edi*2;
        edx = *(eax);
        edx = edi + edx;
        eax++;
    } while (ecx != eax);
    esi += 8;
    if (esi < *((ebp - 0x1c))) {
        goto label_0;
    }
    *(obj.hash_accu) = edx;
    goto label_4;
    eax = *(ecx);
    eax >>= 0xa;
    eax <<= 2;
    ebx -= eax;
    eax = ebx;
    eax = hash_aux ();
    goto label_1;
    goto label_4;
    esi = *(esi);
    if ((esi & 1) == 0) {
        goto label_2;
    }
    goto label_3;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = *((ebx + 4));
    eax >>= 1;
    edx = *(obj.hash_accu) * 0x1003f;
    eax += edx;
    *(obj.hash_accu) = eax;
    goto label_4;
    edx = *(esi);
    edx = *((edx + 0xc));
    if (edx == 0) {
        goto label_4;
    }
    eax--;
    *(obj.hash_univ_count) = eax;
    ebx = *(obj.hash_accu) * 0x1003f;
    eax = void (*edx)(uint32_t) (esi);
    ebx = eax + ebx;
    *(obj.hash_accu) = ebx;
    goto label_4;
label_7:
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = hash_accu;
    edx = eax * 9;
    eax = eax + edx*2;
    eax += *((ebp - 0x1c));
    *(obj.hash_accu) = eax;
    esi = *(ecx);
    esi >>= 0xa;
    if (esi == 0) {
        goto label_4;
    }
    do {
        esi--;
        eax = *((ebx + esi*4));
        eax = hash_aux ();
        goto label_1;
    } while (esi != 0);
    goto label_4;
label_6:
    eax = *(obj.hash_accu) * 0x1003f;
    ebx += eax;
    *(obj.hash_accu) = ebx;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bf93 */
#include <stdint.h>
 
int32_t token_name (void) {
    ebx = eax;
    if (edx <= 0) {
        goto label_0;
    }
    esi = 0xffffffff;
    eax = 0;
    if (*(ebx) != 0) {
        goto label_1;
    }
    goto label_2;
    do {
        if (*(ebx) == 0) {
            goto label_2;
        }
label_1:
        edi = ebx;
        ecx = esi;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        ebx += ecx;
        edx--;
    } while (edx > 0);
    goto label_0;
label_2:
    ebx = "<unknown token>";
label_0:
    eax = "<unknown token>";
    esi = ebx;
    edi = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c640 */
#include <stdint.h>
 
int32_t norm_pfree (void) {
    edx = 1;
    if (eax == 0) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c64f */
#include <stdint.h>
 
void norm_pmax (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c654 */
#include <stdint.h>
 
int32_t norm_heapincr (void) {
    eax += 0x3ff;
    eax &= 0xfffffc00;
    edx = 0x800;
    if (eax <= 0x7ff) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c670 */
#include <stdint.h>
 
int32_t norm_minsize (void) {
    edx = 0x1000;
    if (eax <= 0xfff) {
        eax = edx;
    }
    edx = 0x10000000;
    if (eax > 0x10000000) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c811 */
#include <stdint.h>
 
int32_t test_and_compact (void) {
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_18h;
    int32_t var_14h;
    char * var_4h;
    int32_t var_8h;
    eax = caml_fl_cur_size;
    ecx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = ecx;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] *= *(0x8071bdc);
    edx = caml_stat_heap_size;
    edx >>= 2;
    edx -= eax;
    eax = edx;
    edx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = edx;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(0x8071be0);
    *(fp_stack--) = *((ebp - 0x20));
    __asm ("fcmovnbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x20)) = fp_stack[0];
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x18));
    caml_gc_message (0x200, "Estimated overhead (lower bound) = %lu%%\n", eax);
    eax = caml_percent_max;
    edx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = edx;
    *(fp_stack--) = *((ebp - 0x18));
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        if (*(obj.caml_stat_heap_chunks) <= 1) {
            goto label_0;
        }
        caml_gc_message (0x200, "Automatic compaction triggered.\n", 0);
        caml_compact_heap ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ec80 */
#include <stdint.h>
 
int32_t caml_compact_heap (void) {
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    int32_t var_1ch;
    char * s2;
    size_t n;
    caml_gc_message (ebx, esi, edi);
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_9;
    }
label_0:
    edi = eax - 0x10;
    esi = eax;
    esi += *((edi + 8));
    if (esi <= eax) {
        goto label_10;
    }
    do {
        edx = *(eax);
        ecx = *(eax);
        ecx >>= 0xa;
        ebx = edx;
        ebx &= 0x300;
        if (ebx == 0x200) {
            edx = ecx;
            edx <<= 0xa;
            edx |= 0x3f3;
            *(eax) = edx;
        } else {
            ebx = ecx;
            ebx <<= 0xa;
            edx &= 0xff;
            edx <<= 2;
            edx |= ebx;
            edx |= 3;
            *(eax) = edx;
        }
        eax = eax + ecx*4 + 4;
    } while (esi > eax);
label_10:
    eax = *((edi + 0xc));
    if (eax != 0) {
        goto label_0;
    }
label_9:
    caml_do_roots (sym.invert_root);
    caml_final_do_weak_roots (sym.invert_root);
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_11;
    }
label_2:
    *((ebp - 0x1c)) = eax;
    eax -= 0x10;
    *((ebp - 0x24)) = eax;
    edx = *((ebp - 0x1c));
    edx += *((eax + 8));
    *((ebp - 0x20)) = edx;
    ecx = *((ebp - 0x1c));
    if (edx <= ecx) {
        goto label_12;
    }
label_1:
    edx = *((ebp - 0x1c));
    eax = *(edx);
    if ((al & 3) != 0) {
        goto label_13;
    }
    do {
        eax = *(eax);
    } while ((al & 3) == 0);
label_13:
    edi = eax;
    edi >>= 0xa;
    edi++;
    eax >>= 2;
    eax &= 0xff;
    if (eax != 0xf9) {
        goto label_14;
    }
    ecx = *((ebp - 0x1c));
    eax = *((ecx + edi*4));
    edx = *((ecx + edi*4));
    edx &= 3;
    if (edx == 3) {
        goto label_15;
    }
    do {
        eax &= 0xfffffffc;
        eax = *(eax);
        edx = *(eax);
        edx &= 3;
    } while (edx != 3);
label_15:
    edi = eax;
    edi >>= 0xa;
    edi++;
    eax >>= 2;
    eax &= 0xff;
label_14:
    if (eax > 0xfa) {
        goto label_16;
    }
    if (edi <= 1) {
        goto label_16;
    }
    ebx = *((ebp - 0x1c));
    ebx += 4;
    esi = 1;
    do {
        eax = ebx;
        invert_pointer_at ();
        esi++;
        ebx += 4;
    } while (edi > esi);
label_16:
    eax = *((ebp - 0x1c));
    eax = eax + edi*4;
    *((ebp - 0x1c)) = eax;
    if (*((ebp - 0x20)) > eax) {
        goto label_1;
    }
label_12:
    edx = *((ebp - 0x24));
    eax = *((edx + 0xc));
    if (eax != 0) {
        goto label_2;
    }
label_11:
    ecx = caml_weak_list_head;
    *((ebp - 0x1c)) = ecx;
    if (ecx == 0) {
        goto label_17;
    }
    *((ebp - 0x20)) = obj.caml_weak_list_head;
label_3:
    ebx = *((ebp - 0x1c));
    edi = *((ebx - 4));
    if ((edi & 3) != 0) {
        goto label_18;
    }
    do {
        edi = *(edi);
    } while ((edi & 3) == 0);
label_18:
    edi >>= 0xa;
    if (edi <= 1) {
        goto label_19;
    }
    ebx += 4;
    esi = 1;
    do {
        eax = *(ebx);
        if (eax != *(obj.caml_weak_none)) {
            eax = ebx;
            invert_pointer_at ();
        }
        esi++;
        ebx += 4;
    } while (edi > esi);
label_19:
    eax = *((ebp - 0x20));
    invert_pointer_at ();
    eax = *((ebp - 0x1c));
    *((ebp - 0x20)) = eax;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    if (edx != 0) {
        goto label_3;
    }
label_17:
    init_compact_allocate ();
    ebx = caml_heap_start;
    if (ebx == 0) {
        goto label_20;
    }
label_6:
    ecx = ebx - 0x10;
    *((ebp - 0x2c)) = ecx;
    eax = *((ecx + 8));
    eax += ebx;
    *((ebp - 0x28)) = eax;
    goto label_21;
label_5:
    eax = *(ebx);
    if ((al & 3) == 0) {
        goto label_22;
    }
    edx = eax;
    edx >>= 2;
    edx &= 0xff;
    if (edx != 0xf9) {
        goto label_23;
    }
    goto label_24;
    do {
label_22:
        eax = *(eax);
    } while ((al & 3) == 0);
    esi = eax;
    esi >>= 0xa;
    esi++;
    eax >>= 2;
    eax &= 0xff;
    *((ebp - 0x24)) = eax;
    *((ebp - 0x20)) = 0;
    if (eax != 0xf9) {
        goto label_25;
    }
label_8:
    esi = ebx + esi*4;
    *((ebp - 0x20)) = esi;
    eax = *(esi);
    edx = *(esi);
    edx &= 3;
    if (edx == 3) {
        goto label_26;
    }
    do {
        eax &= 0xfffffffc;
        eax = *(eax);
        edx = *(eax);
        edx &= 3;
    } while (edx != 3);
label_26:
    esi = eax;
    esi >>= 0xa;
    esi++;
    eax >>= 2;
    eax &= 0xff;
    *((ebp - 0x24)) = eax;
label_25:
    edx = esi*4;
    *((ebp - 0x1c)) = edx;
    eax = edx;
    eax = compact_allocate ();
    edx = *(ebx);
    if ((dl & 3) != 0) {
        goto label_27;
    }
    edi = eax + 4;
    do {
        ecx = *(edx);
        *(edx) = edi;
        if ((cl & 3) != 0) {
            goto label_27;
        }
        edx = ecx;
    } while (1);
label_27:
    esi <<= 0xa;
    ecx = *((ebp - 0x24));
    edx = esi + ecx - 0x400;
    *(ebx) = edx;
    if (*((ebp - 0x20)) == 0) {
        goto label_28;
    }
    ecx = *((ebp - 0x20));
    edx = *((ebp - 0x20));
    edx &= 3;
    if (edx == 3) {
        goto label_28;
    }
label_4:
    edi = ecx;
    edi &= 0xfffffffc;
    ecx = *(edi);
    edx = *(edi);
    edx &= 3;
    if (edx != 2) {
        goto label_29;
    }
    edx = edi;
    edx -= ebx;
    edx >>= 2;
    esi = eax + edx*4 + 4;
    do {
        edx = ecx;
        edx &= 0xfffffffc;
        ecx = *(edx);
        *(edx) = esi;
        edx = ecx;
        edx &= 3;
    } while (edx == 2);
label_29:
    edx = edi;
    edx -= ebx;
    edx >>= 2;
    edx <<= 0xa;
    edx += 0xf9;
    *(edi) = edx;
    edx = ecx;
    edx &= 3;
    if (edx != 3) {
        goto label_4;
    }
label_28:
    ebx += *((ebp - 0x1c));
    goto label_21;
label_23:
    ecx = eax;
    ecx &= 0xfffffc00;
    edx = edx + ecx + 0x200;
    *(ebx) = edx;
    eax >>= 0xa;
    ebx = ebx + eax*4 + 4;
label_21:
    if (*((ebp - 0x28)) > ebx) {
        goto label_5;
    }
    eax = *((ebp - 0x2c));
    ebx = *((eax + 0xc));
    if (ebx != 0) {
        goto label_6;
    }
label_20:
    init_compact_allocate ();
    ebx = caml_heap_start;
    if (ebx == 0) {
        goto label_30;
    }
label_7:
    edx = ebx - 0x10;
    *((ebp - 0x1c)) = edx;
    esi = ebx;
    esi += *((edx + 8));
    while (esi > ebx) {
        eax = *(ebx);
        if ((ah & 3) == 0) {
            eax >>= 0xa;
            edi = eax*4 + 4;
            eax = edi;
            eax = compact_allocate ();
            eax = memmove (eax, ebx, edi);
            ebx += edi;
        } else {
            eax >>= 0xa;
            ebx = ebx + eax*4 + 4;
        }
    }
    ecx = *((ebp - 0x1c));
    ebx = *((ecx + 0xc));
    if (ebx != 0) {
        goto label_7;
    }
    ecx = caml_heap_start;
    if (ecx == 0) {
        goto label_30;
    }
    edx = ecx;
    eax = 0;
    do {
        edx -= 0x10;
        esi = *((edx + 4));
        if (esi != 0) {
            edi = esi;
            edi >>= 2;
            eax += edi;
            edi = *((edx + 8));
            edi -= esi;
            esi = edi;
            esi >>= 2;
            ebx += esi;
        }
        edx = *((edx + 0xc));
    } while (edx != 0);
    esi = 0x64;
    edx = 0;
    eax = edx:eax / esi;
    edx = edx:eax % esi;
    eax++;
    edi = eax;
    edi *= *(obj.caml_percent_free);
    do {
        eax = ecx - 0x10;
        esi = *((eax + 0xc));
        if (*((eax + 4)) == 0) {
            if (edi > ebx) {
                eax = *((eax + 8));
                eax >>= 2;
                ebx += eax;
            } else {
                caml_shrink_heap (ecx);
            }
        }
        if (esi == 0) {
            goto label_31;
        }
        ecx = esi;
    } while (1);
label_31:
    ebx = caml_heap_start;
    caml_fl_reset ();
    if (ebx == 0) {
        goto label_32;
    }
    do {
        esi = ebx - 0x10;
        edx = *((esi + 8));
        eax = *((esi + 4));
        if (edx > eax) {
            edx -= eax;
            edx >>= 2;
            eax = ebx + eax;
            caml_make_free_blocks (eax, edx, 1);
        }
        ebx = *((esi + 0xc));
    } while (ebx != 0);
    do {
label_32:
        *(obj.caml_stat_compactions)++;
        caml_gc_message (0x10, "done.\n", 0);
        return eax;
label_30:
        eax = caml_fl_reset ();
    } while (1);
label_24:
    eax >>= 0xa;
    esi = eax + 1;
    goto label_8;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806de98 */
#include <stdint.h>
 
int32_t add_char (void) {
    ecx = *(eax);
    if (ecx < *((eax + 4))) {
        *(ecx) = dl;
        ecx++;
        *(eax) = ecx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806deab */
#include <stdint.h>
 
int32_t add_string (void) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = eax;
    edi = edx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ebx = ecx - 1;
    eax = *(esi);
    ecx = eax + ebx;
    edi = *((esi + 4));
    edi -= eax;
    if (*((esi + 4)) < ecx) {
        ebx = edi;
    }
    if (ebx > 0) {
        memmove (eax, edx, ebx);
    }
    *(esi) += ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e150 */
#include <stdint.h>
 
int32_t hash_value_name (void) {
    edx = *(eax);
    ecx = 0;
    if (dl == 0) {
        goto label_0;
    }
    do {
        ebx = ecx * 9;
        ebx = ecx + ebx*2;
        ecx = (int32_t) dl;
        ecx += ebx;
        eax++;
        edx = *(eax);
    } while (dl != 0);
label_0:
    edx = 0x4ec4ec4f;
    eax = ecx;
    edx:eax = eax * edx;
    eax = edx;
    eax >>= 2;
    edx = eax * 3;
    eax = eax + edx*4;
    ecx -= eax;
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e4ee */
#include <stdint.h>
 
int32_t do_set (void) {
    if ((cl & 1) == 0) {
        if (ecx < *(obj.caml_young_end)) {
            if (ecx <= *(obj.caml_young_start)) {
                goto label_0;
            }
            ebx = eax + edx*4;
            eax = *(ebx);
            *(ebx) = ecx;
            if ((al & 1) == 0) {
                if (eax >= *(obj.caml_young_end)) {
                    goto label_1;
                }
                if (eax > *(obj.caml_young_start)) {
                    goto label_2;
                }
            }
label_1:
            eax = .comment;
            if (eax >= *(0x807ebe8)) {
                caml_realloc_ref_table (obj.caml_weak_ref_table);
            }
            eax = 0x807ebe4;
            edx = *(eax);
            *(edx) = ebx;
            edx += 4;
            *(eax) = edx;
        }
    } else {
label_0:
        *((eax + edx*4)) = ecx;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806eae0 */
#include <stdint.h>
 
int32_t invert_pointer_at (void) {
    int32_t var_14h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ecx = *(eax);
    if ((cl & 3) != 0) {
        goto label_0;
    }
    ebx = ecx;
    ebx >>= 0x17;
    edx = ecx;
    edx >>= 0xc;
    edx &= 0x7ff;
    ebx = *((ebx*4 + obj.caml_page_table));
    if ((*((ebx + edx)) & 1) == 0) {
        goto label_0;
    }
    esi = ecx - 4;
    edi = *(esi);
    edx = *(esi);
    edx &= 3;
    if (edx != 1) {
        if (edx >= 1) {
            if (edx == 2) {
                goto label_1;
            }
            if (edx != 3) {
                goto label_0;
            }
        }
        *(eax) = edi;
        *(esi) = eax;
        goto label_0;
    }
    edi >>= 0xa;
    edi <<= 2;
    edx = ecx;
    edx -= edi;
    edi = edx;
    ebx = edx - 4;
    *((ebp - 0x14)) = ebx;
    edx = *(ebx);
    if ((dl & 3) != 0) {
        goto label_2;
    }
    do {
        ebx = edx;
        edx = *(edx);
    } while ((dl & 3) == 0);
    *((ebp - 0x14)) = ebx;
label_2:
    ebx = edx;
    ebx >>= 2;
    if (bl == 0xf7) {
        *(eax) = edx;
        eax |= 2;
        *(esi) = eax;
        ecx -= edi;
        ecx >>= 2;
        eax = ecx - 1;
        eax <<= 0xa;
        eax |= 0x3e7;
        edx = *((ebp - 0x14));
        *(edx) = eax;
    } else {
        edx >>= 0xa;
        edx = edi + edx*4;
        edx |= 1;
        *(eax) = edx;
        eax |= 2;
        *(esi) = eax;
        ecx -= edi;
        ecx >>= 2;
        eax = ecx - 1;
        eax <<= 0xa;
        eax |= 0x3e7;
        ebx = *((ebp - 0x14));
        *(ebx) = eax;
        goto label_0;
label_1:
        *(eax) = edi;
        eax |= 2;
        *(esi) = eax;
    }
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ebcf */
#include <stdint.h>
 
int32_t invert_root (int32_t arg_ch) {
    eax = *((ebp + 0xc));
    invert_pointer_at ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ebdc */
#include <stdint.h>
 
int32_t init_compact_allocate (void) {
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_0;
    }
    do {
        eax -= 0x10;
        *((eax + 4)) = 0;
        eax = *((eax + 0xc));
    } while (eax != 0);
label_0:
    eax = caml_heap_start;
    *(obj.compact_fl) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ec05 */
#include <stdint.h>
 
uint32_t compact_allocate (void) {
    ecx = compact_fl;
    edx = ecx - 0x10;
    ebx = *((edx + 8));
    ebx -= *((edx + 4));
    if (ebx > 0x10) {
        goto label_1;
    }
    esi = *((edx + 0xc));
    edx = esi - 0x10;
    ebx = *((edx + 8));
    ebx -= *((edx + 4));
    if (ebx <= 0x10) {
        goto label_2;
    }
    goto label_1;
    do {
        esi = ebx;
        ecx = ebx;
label_0:
        ebx = *((edx + 0xc));
        edx = ebx - 0x10;
        edi = *((edx + 8));
        edi -= *((edx + 4));
    } while (edi <= 0x10);
    *(obj.compact_fl) = esi;
label_1:
    edx = ecx - 0x10;
    ebx = *((edx + 4));
    esi = *((edx + 8));
    esi -= ebx;
    if (eax <= esi) {
        goto label_3;
    }
    do {
        ecx = *((edx + 0xc));
        edx = ecx - 0x10;
        ebx = *((edx + 4));
        esi = *((edx + 8));
        esi -= ebx;
    } while (esi < eax);
label_3:
    eax = ebx + eax;
    *((edx + 4)) = eax;
    eax = ecx + ebx;
    esi = ebx;
    edi = ebx;
    return eax;
label_2:
    ecx = esi;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fe64 */
#include <stdint.h>
 
int32_t extract_location_info (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    if ((*((eax + 4)) & 1) == 0) {
        *(edx) = 0;
        *((edx + 4)) = 1;
    } else {
        ecx = *((eax + 6));
        ebx = eax + ecx*2 + 0xb;
        ebx &= 0xfffffffc;
        edi = *(ebx);
        ecx = *((ebx + 4));
        *(edx) = 1;
        al = ((edi & 3) != 0) ? 1 : 0;
        esi = eax;
        esi &= 0xff;
        *((edx + 4)) = esi;
        esi = edi;
        esi &= 0x3fffffc;
        ebx = esi + ebx;
        *((edx + 8)) = ebx;
        ebx = ecx;
        ebx >>= 0xc;
        *((edx + 0xc)) = ebx;
        ebx = ecx;
        ebx >>= 4;
        ebx &= 0xff;
        *((edx + 0x10)) = ebx;
        ecx &= 0xf;
        ecx <<= 6;
        eax = edi;
        eax >>= 0x1a;
        eax |= ecx;
        *((edx + 0x14)) = eax;
    }
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068259 */
#include <stdint.h>
 
int32_t caml_channel_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c360 */
#include <stdint.h>
 
int32_t camlUnix_fun_2782 (void) {
    eax = unix_error_message;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070348 */
#include <stdint.h>
 
void loc_caml_c_call (int32_t arg_4h) {
    edx = *(esp);
    *(obj.caml_last_return_address) = edx;
    edx = esp + 4;
    *(obj.caml_bottom_of_stack) = edx;
    return void (*eax)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806938c */
#include <stdint.h>
 
int32_t caml_seek_out (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    caml_flush (ebx);
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 0;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = *(ebx);
    *(esp) = eax;
    eax = lseek64 ();
    edx ^= edi;
    eax ^= esi;
    edx |= eax;
    if (edx != 0) {
        caml_leave_blocking_section ();
        caml_sys_error (1);
    }
    caml_leave_blocking_section ();
    *((ebx + 4)) = esi;
    *((ebx + 8)) = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80692fa */
#include <stdint.h>
 
uint32_t caml_flush (int32_t arg_8h) {
    ebx = *((ebp + 8));
    do {
        eax = caml_flush_partial (ebx);
    } while (eax == 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069057 */
#include <stdint.h>
 
uint32_t caml_flush_partial (int32_t arg_8h) {
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    eax = ebx + 0x34;
    *((ebp - 0x1c)) = eax;
    esi = *((ebx + 0x10));
    esi -= eax;
    if (esi > 0) {
        edx = eax;
        ecx = esi;
        eax = *(ebx);
        eax = do_write ();
        edi = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebx + 4)) += eax;
        *((ebx + 8)) += edx;
        if (esi > edi) {
            esi -= edi;
            eax = *((ebp - 0x1c));
            eax += edi;
            eax = *((ebp - 0x1c));
            memmove (eax, eax, esi);
        }
        *((ebx + 0x10)) -= edi;
    }
    eax = ebx + 0x34;
    al = (*((ebx + 0x10)) == eax) ? 1 : 0;
    eax = (int32_t) al;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062b2d */
#include <stdint.h>
 
int32_t caml_enter_blocking_section (void) {
    do {
        caml_process_pending_signals ();
        uint32_t (*caml_enter_blocking_section_hook)() ();
        eax = caml_signals_are_pending;
        if (eax == 0) {
            goto label_0;
        }
        uint32_t (*caml_leave_blocking_section_hook)() ();
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a844 */
#include <stdint.h>
 
void lseek64 (void) {
    lseek64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062b1a */
#include <stdint.h>
 
void caml_leave_blocking_section (void) {
    uint32_t (*caml_leave_blocking_section_hook)() ();
    caml_process_pending_signals ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806297c */
#include <stdint.h>
 
int32_t caml_process_pending_signals (void) {
    int32_t var_4h;
    eax = caml_signals_are_pending;
    if (eax == 0) {
        goto label_0;
    }
    *(obj.caml_signals_are_pending) = 0;
    ebx = 0;
    esi = caml_pending_signals;
    do {
        eax = *((esi + ebx*4));
        if (eax != 0) {
            *((esi + ebx*4)) = 0;
            caml_execute_signal (ebx, 0);
        }
        ebx++;
    } while (ebx != 0x41);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806baeb */
#include <stdint.h>
 
int32_t caml_sys_error (int32_t arg_8h) {
    int32_t var_3ch_2;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    void * s2;
    size_t n;
    eax = caml_local_roots;
    *((ebp - 0x38)) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    eax = errno_location ();
    eax = *(eax);
    eax = strerror (eax);
    esi = eax;
    edx = *((ebp + 8));
    if (edx == 1) {
        eax = caml_copy_string (eax);
        *((ebp - 0x3c)) = eax;
    } else {
        edi = eax;
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        edi = ecx - 1;
        eax = caml_string_length (edx);
        ebx = eax;
        eax = eax + edi + 2;
        eax = caml_alloc_string (eax);
        *((ebp - 0x3c)) = eax;
        edx = *((ebp + 8));
        memmove (eax, edx, ebx);
        eax = ebx;
        eax += *((ebp - 0x3c));
        *(eax) = 0x203a;
        eax = *((ebp - 0x3c));
        eax = ebx + eax + 2;
        memmove (eax, esi, edi);
    }
    eax = *((ebp - 0x3c));
    return caml_raise_sys_error (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80508e0 */
#include <stdint.h>
 
int32_t camlArray_find_init_1077 (void) {
    do {
        ebx = eax;
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 4));
        ecx = *(ebx);
        edx = *((ecx - 4));
        esi = *((ecx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            edx >>= 9;
        } else {
            edx >>= 0xa;
        }
        edx |= 1;
        if (edx > 1) {
            eax = *((ecx - 4));
            if (eax != 0xfe) {
                eax = *(ecx);
            } else {
label_0:
                eax = caml_young_ptr;
                eax -= 0xc;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_2;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x8fd;
                *(fp_stack--) = *(ecx);
                *(eax) = fp_stack[0];
                fp_stack--;
            }
            void (*0x8051f50)() ();
        }
    } while (1);
label_1:
    eax = camlArray__36;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be10 */
#include <stdint.h>
 
int32_t camlUnix_fun_2630 (void) {
    eax = unix_getegid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065e74 */
#include <stdint.h>
 
int32_t caml_int32_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066c29 */
#include <stdint.h>
 
int32_t caml_int64_mul (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 8));
    ecx *= *((eax + 4));
    ebx = *((eax + 8));
    ebx *= *((edx + 4));
    ecx += ebx;
    eax = *((eax + 4));
    edx:eax = eax * *((edx + 4));
    edx = ecx + edx;
    caml_copy_int64 (ebx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80667e2 */
#include <stdint.h>
 
void caml_copy_int64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_ch;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    caml_alloc_custom (1, 8, 0);
    *((eax + 4)) = ebx;
    *((eax + 8)) = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f97a */
#include <stdint.h>
 
int32_t caml_alloc_custom (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax += 3;
    eax >>= 2;
    eax++;
    if (*((ebx + 4)) == 0) {
        if (eax <= 0x100) {
            caml_alloc_small (eax, 0xff);
            *(eax) = ebx;
        }
    } else {
        eax = caml_alloc_shr (eax, 0xff);
        esi = eax;
        *(eax) = ebx;
        eax = *((ebp + 0x14));
        eax = *((ebp + 0x10));
        caml_adjust_gc_speed (eax, eax);
        caml_check_urgent_gc (esi);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a3f1 */
#include <stdint.h>
 
int32_t caml_output_value_to_buffer (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    *(obj.extern_userprovided_output) = eax;
    *(obj.extern_ptr) = eax;
    edx = *((ebp + 0x10));
    edx >>= 1;
    eax += edx;
    *(obj.extern_limit) = eax;
    edx = *((ebp + 0x18));
    eax = *((ebp + 0x14));
    extern_value ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062b60 */
#include <stdint.h>
 
uint32_t caml_init_signals (void) {
    int32_t var_a0h;
    int32_t var_9ch;
    int32_t var_1ch;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    struct sigaction * act;
    struct sigaction * oldact;
    *((ebp - 0x14)) = 0x807bba0;
    *((ebp - 0xc)) = 0x2000;
    *((ebp - 0x10)) = 0;
    *((ebp - 0xa0)) = 0x8062c8f;
    *((ebp - 0x1c)) = 0x48000000;
    ebx = ebp - 0xa0;
    eax = ebp - 0x9c;
    *(esp) = eax;
    sigemptyset ();
    *(obj.system_stack_top) = ebx;
    *((esp + 4)) = 0;
    eax = ebp - 0x14;
    *(esp) = eax;
    eax = sigaltstack ();
    if (eax == 0) {
        sigaction (0xb, ebx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a134 */
#include <stdint.h>
 
void sigaltstack (void) {
    sigaltstack ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80694fd */
#include <stdint.h>
 
uint32_t caml_open_descriptor_in (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    esi = *((ebp + 8));
    eax = caml_stat_alloc (ebx, esi);
    ebx = eax;
    *(eax) = esi;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 1;
    *((esp + 4)) = 0;
    *((esp + 8)) = 0;
    *(esp) = esi;
    eax = lseek64 ();
    *((ebx + 4)) = eax;
    *((ebx + 8)) = edx;
    caml_leave_blocking_section ();
    eax = ebx + 0x34;
    *((ebx + 0x14)) = eax;
    *((ebx + 0x10)) = eax;
    eax = ebx + 0x1034;
    *((ebx + 0xc)) = eax;
    *((ebx + 0x18)) = 0;
    *((ebx + 0x24)) = 0;
    *((ebx + 0x28)) = 0;
    *((ebx + 0x2c)) = 0;
    *((ebx + 0x30)) = 0;
    eax = caml_all_opened_channels;
    *((ebx + 0x1c)) = eax;
    *((ebx + 0x20)) = 0;
    eax = caml_all_opened_channels;
    if (eax != 0) {
        *((eax + 0x20)) = ebx;
    }
    *(obj.caml_all_opened_channels) = ebx;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fe50 */
#include <stdint.h>
 
uint32_t camlPervasives_prerr_int_1281 (void) {
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f840 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_int_1130 (void) {
    eax = caml_format_int;
    caml_c_call (loc.camlPervasives__96);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b150 */
#include <stdint.h>
 
int32_t camlPrintf_index_of_literal_position_1044 (void) {
    eax += 0xfffffffe;
    return camlPrintf_index_of_int_1037 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80703b4 */
#include <stdint.h>
 
int32_t loc_caml_raise_exn (int32_t arg_4h) {
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        esp = caml_exception_pointer;
        return;
    }
    esi = eax;
    edi = caml_exception_pointer;
    eax = *(esp);
    edx = esp + 4;
    caml_stash_backtrace (esi, eax, edx, edi);
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070109 */
#include <stdint.h>
 
int32_t caml_stash_backtrace (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h) {
    eax = *((ebp + 8));
    ebx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    if (eax != *(obj.caml_backtrace_last_exn)) {
        *(obj.caml_backtrace_pos) = 0;
        *(obj.caml_backtrace_last_exn) = eax;
    }
    if (*(obj.caml_backtrace_buffer) == 0) {
        eax = malloc (0x1000);
        *(obj.caml_backtrace_buffer) = eax;
        if (eax == 0) {
            goto label_1;
        }
    }
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
label_0:
    edi = caml_frame_descriptors_mask;
    edx = ebx;
    edx >>= 3;
    edx &= edi;
    ecx = caml_frame_descriptors;
    eax = *((ecx + edx*4));
    if (eax == 0) {
        goto label_1;
    }
    if (*(eax) != ebx) {
        goto label_2;
    }
    goto label_3;
    do {
        if (*(eax) == ebx) {
            goto label_3;
        }
label_2:
        edx++;
        edx &= edi;
        eax = *((ecx + edx*4));
    } while (eax != 0);
    goto label_1;
label_3:
    if (*((eax + 4)) != 0xffff) {
        edx = caml_backtrace_pos;
        if (edx > 0x3ff) {
            goto label_1;
        }
        ecx = caml_backtrace_buffer;
        *((ecx + edx*4)) = eax;
        edx++;
        *(obj.caml_backtrace_pos) = edx;
        eax = *((eax + 4));
        eax &= 0xfffc;
        esi += eax;
        ebx = *((esi - 4));
    } else {
        eax = esi + 8;
        esi = *(eax);
        ebx = *((eax + 4));
        if (esi == 0) {
            goto label_1;
        }
    }
    if (esi <= *((ebp + 0x14))) {
        goto label_0;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x807023c */
#include <stdint.h>
 
int32_t loc_caml_call_gc (int32_t arg_4h) {
    eax = *(esp);
    *(obj.caml_last_return_address) = eax;
    eax = esp + 4;
    *(obj.caml_bottom_of_stack) = eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062d5b */
#include <stdint.h>
 
int32_t caml_garbage_collection (void) {
    eax = caml_young_start;
    *(obj.caml_young_limit) = eax;
    if (eax <= *(obj.caml_young_ptr)) {
        eax = caml_force_major_slice;
        if (eax == 0) {
            goto label_0;
        }
    }
    caml_minor_collection ();
label_0:
    caml_process_pending_signals ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f710 */
#include <stdint.h>
 
uint32_t camlPervasives_5e_1112 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
    *((esp + 4)) = edx;
    *((esp + 0xc)) = ebx;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    eax = ecx*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    eax = eax + eax + 1;
    *(esp) = eax;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    ebx = *((ebx + ecx));
    ecx -= ebx;
    ebx = ecx + ecx + 1;
    *((esp + 8)) = ebx;
    eax = caml_create_string;
    eax = caml_c_call (eax + ebx - 1);
    ebx = eax;
    esi = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, esi);
    eax = *((esp + 8));
    eax = *((esp + 0x1c));
    caml_blit_string (eax, 1, ebx, esi, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80679fb */
#include <stdint.h>
 
int32_t caml_blit_string (int32_t arg_8h, int32_t arg_ch, void * s1, int32_t arg_14h, int32_t arg_18h) {
    void * s2;
    size_t n;
    eax = *((ebp + 0x18));
    eax >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    eax = *((ebp + 0x14));
    eax >>= 1;
    eax += *((ebp + 0x10));
    memmove (eax, eax, eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805de6f */
#include <stdint.h>
 
int32_t unix_getpwnam (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x142d1;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getpwnam ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_passwd_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a834 */
#include <stdint.h>
 
void getpwnam (void) {
    getpwnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061c87 */
#include <stdint.h>
 
void caml_raise_not_found (void) {
    return caml_raise_constant (" %\a\b");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070236 */
#include <stdint.h>
 
void caml_debugger_cleanup_fork (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065fb0 */
#include <stdint.h>
 
int32_t caml_nativeint_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806797d */
#include <stdint.h>
 
uint32_t caml_is_printable (int32_t arg_8h) {
    char * locale;
    if (*(obj.locale_is_set.2848) == 0) {
        setlocale (0, 0x8071ba8);
        *(obj.locale_is_set.2848) = 1;
    }
    eax = ctype_b_loc ();
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *(eax);
    eax = *((eax + edx*2));
    eax &= 0x4000;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a424 */
#include <stdint.h>
 
void setlocale (void) {
    setlocale ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a2d4 */
#include <stdint.h>
 
void ctype_b_loc (void) {
    ctype_b_loc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80547b0 */
#include <stdint.h>
 
int32_t camlList_exists_1141 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2638 (void) {
    eax = unix_getuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80690ca */
#include <stdint.h>
 
uint32_t caml_ml_output_char (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = *((ebp + 0xc));
    edx >>= 1;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804cec0 */
#include <stdint.h>
 
int32_t camlUnix_getnameinfo_emulation_1772 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((eax - 4));
    if (ecx != 0) {
        *((esp + 8)) = ebx;
        ecx = *((eax + 4));
        *((esp + 4)) = ecx;
        eax = *(eax);
        eax = fcn_0804cf70 (eax);
        ecx = " %\a\b";
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 5;
            ebx = *((esp + 8));
            eax = camlList_mem_1161 ();
            if (eax != 1) {
label_2:
                eax = caml_young_ptr;
                eax -= 8;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_3;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x400;
                *(eax) = " %\a\b";
                caml_raise_exn ();
            }
            eax = *(esp);
            eax = unix_string_of_inet_addr;
            caml_c_call (eax);
        } else {
            eax = caml_raise_exn ();
        }
        *(esp) = eax;
        eax = void (*0x804d020)() ();
        ecx = " %\a\b";
        ebx = *(eax);
        if (ebx == ecx) {
            eax = *((esp + 4));
            eax = camlPervasives_string_of_int_1130 ();
            ecx = eax;
        } else {
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            eax = 7;
            ebx = *((esp + 0x10));
            eax = camlList_mem_1161 (*(obj.caml_exception_pointer));
            if (eax != 1) {
label_1:
                eax = caml_young_ptr;
                eax -= 8;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_4;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x400;
                *(eax) = " %\a\b";
                caml_raise_exn ();
            }
            eax = 9;
            ebx = *((esp + 0x10));
            eax = camlList_mem_1161 ();
            if (eax != 1) {
                eax = loc.camlUnix__194;
            } else {
                eax = loc.camlUnix__193;
            }
            eax = *((esp + 0x10));
            eax = unix_getservbyport;
            eax = caml_c_call (eax);
            ecx = *(eax);
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        *((eax + 4)) = ecx;
        return eax;
    }
    ebx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.camlUnix__192;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804add0 */
#include <stdint.h>
 
int32_t caml_curry7_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b350 */
#include <stdint.h>
 
int32_t caml_curry3_2 (void) {
    ecx = eax;
    eax = *((ebx + 0xc));
    edx = *((eax + 0xc));
    ebx = *((ebx + 8));
    eax = *((eax + 8));
    esi = *((edx + 8));
    return void (*esi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b4f0 */
#include <stdint.h>
 
uint32_t caml_apply3 (void) {
    int32_t var_4h;
    esi = *((edx + 4));
    if (esi == 7) {
        esi = *((edx + 8));
        void (*esi)() ();
    }
    ecx = *(edx);
    ebx = edx;
    eax = void (*ecx)(uint32_t, uint32_t) (ebx, ecx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 4));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ccc4 */
#include <stdint.h>
 
int32_t unix_fchown (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1547c;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = fchown ();
    if (eax == -1) {
        eax = ebx - 0x16d1;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049ff4 */
#include <stdint.h>
 
void fchown (void) {
    fchown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806105c */
#include <stdint.h>
 
uint32_t uerror (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x110e4;
    eax = errno_location ();
    edx = *((ebp + 0xc));
    edx = *((ebp + 8));
    eax = *(eax);
    return unix_error (eax, edx, edx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049df4 */
#include <stdint.h>
 
void errno_location (void) {
    errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060f5f */
#include <stdint.h>
 
int32_t unix_error (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_34h_2;
    int32_t var_14h_2;
    int32_t var_10h_2;
    int32_t var_ch_3;
    int32_t var_bp_8h;
    int32_t var_bp_4h;
    int32_t var_ch_2;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h_2;
    int32_t var_8h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x111e1;
    eax = *((ebp + 0x10));
    *((ebp - 0xc)) = 1;
    *((ebp - 0x10)) = 1;
    *((ebp - 0x14)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x34)) = ecx;
    ecx = ebp - 0x34;
    *(edx) = ecx;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    edx = ebp - 0xc;
    *((ebp - 0x28)) = edx;
    edx = ebp - 0x10;
    *((ebp - 0x24)) = edx;
    edx = ebp - 0x14;
    *((ebp - 0x20)) = edx;
    if (eax == 0) {
        eax = ebx - 0x5a4;
        eax = caml_copy_string (eax);
    }
    *((ebp - 0x14)) = eax;
    eax = *((ebp + 0xc));
    eax = caml_copy_string (eax);
    *((ebp - 0xc)) = eax;
    eax = *((ebp + 8));
    eax = unix_error_of_code (eax);
    *((ebp - 0x10)) = eax;
    if (*((ebx + 0x97b0)) == 0) {
        eax = ebx - 0x12f4;
        eax = caml_named_value (eax);
        *((ebx + 0x97b0)) = eax;
        if (eax != 0) {
            goto label_0;
        }
        eax = ebx - 0x12e4;
        caml_invalid_argument (eax);
    }
label_0:
    caml_alloc_small (4, 0);
    edx = *((ebx + 0x97b0));
    edx = *(edx);
    *(eax) = edx;
    edx = *((ebp - 0x10));
    *((eax + 4)) = edx;
    edx = *((ebp - 0xc));
    *((eax + 8)) = edx;
    edx = *((ebp - 0x14));
    *((eax + 0xc)) = edx;
    ecx = *((ebp - 0x34));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a3e4 */
#include <stdint.h>
 
void unlink (void) {
    unlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060691 */
#include <stdint.h>
 
uint32_t unix_stat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x11aae;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        eax = ebx - 0x1445;
        uerror (eax, esi);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x1445;
        unix_error (0x4b, eax, esi);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f8e0 */
#include <stdint.h>
 
int32_t camlPervasives_40_1143 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        eax = camlPervasives_$40_1143 (ecx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c0c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2710 (void) {
    eax = unix_dup;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804df00 */
#include <stdint.h>
 
int32_t camlUnix_close_process_full_2013 (int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = ecx;
    esi = ebx;
    *((esp + 0xc)) = esi;
    edx = eax;
    *(esp) = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc03;
            *(ebx) = edx;
            *((ebx + 4)) = esi;
            *((ebx + 8)) = ecx;
            eax = "close_process_full";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 8)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = void (*0x804df80)() ();
            ecx = "t$\a\b";
            ebx = *(eax);
            if (ebx != ecx) {
                caml_raise_exn ();
                *(obj.caml_exception_pointer) = esp;
                eax = *((esp + 0x14));
                camlPervasives_close_out_1209 (*(obj.caml_exception_pointer));
            }
            eax = *((esp + 4));
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = *((esp + 8));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804dc50 */
#include <stdint.h>
 
uint32_t camlUnix_find_proc_id_1997 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = void (*0x804dcc0)(uint32_t, uint32_t) (eax, ebx);
    ecx = " %\a\b";
    ebx = *(eax);
    while (1) {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1000;
            ebx = camlUnix;
            *(eax) = ebx;
            *((eax + 4)) = 7;
            ebx = *((esp + 4));
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = 0x8073a04;
            caml_raise_exn ();
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            eax = .comment;
            eax = camlHashtbl_find_1093 (*(obj.caml_exception_pointer));
            eax = .comment;
            ebx = *((esp + 0x10));
            camlHashtbl_remove_1080 (eax);
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057850 */
#include <stdint.h>
 
int32_t camlHashtbl_find_1093 (void) {
    int32_t var_4h_6;
    int32_t var_8h_5;
    edi = eax;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (0x15, 0xc9, ebx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    ecx = *((edi + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    ecx = *((ecx + edx*2 - 2));
    if (ecx == 1) {
        goto label_3;
    }
    *((esp + 4)) = ebx;
    eax = *((ecx + 8));
    *(esp) = eax;
    eax = *((ecx + 4));
    *((esp + 8)) = eax;
    eax = *(ecx);
    eax = caml_compare;
    eax = caml_c_call (ebx);
    if (eax == 1) {
        eax = *((esp + 8));
        return eax;
    }
    eax = *(esp);
    if (eax != 1) {
        ebx = *((eax + 8));
        *(esp) = ebx;
        ebx = *((eax + 4));
        *((esp + 8)) = ebx;
        eax = *(eax);
        eax = *((esp + 8));
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        if (eax != 1) {
            ebx = *((eax + 8));
            *(esp) = ebx;
            ebx = *((eax + 4));
            *((esp + 8)) = ebx;
            eax = *(eax);
            eax = *((esp + 8));
            eax = caml_compare;
            eax = caml_c_call (eax);
            if (eax == 1) {
                eax = *((esp + 8));
                return eax;
            }
            eax = *((esp + 4));
            ebx = *(esp);
            void (*0x80577c0)() ();
        }
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = " %\a\b";
        caml_raise_exn ();
    }
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = " %\a\b";
    caml_raise_exn ();
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80576e0 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_1080 (void) {
    int32_t var_8h;
    int32_t var_ch;
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.camlHashtbl__remove_bucket_1083;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = edi;
            *((ebx + 0xc)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            *((esp + 4)) = edx;
            eax = *((edi + 4));
            *(esp) = eax;
            eax = *((eax - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_1;
            }
            eax = *((ecx + edx*2 - 2));
            eax = camlHashtbl_remove_bucket_1083 ();
            ebx = *((esp + 4));
            eax = *((esp + 8));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fa60 */
#include <stdint.h>
 
int32_t camlPervasives_close_out_1209 (void) {
    *(esp) = eax;
    eax = caml_ml_flush;
    caml_c_call (eax);
    eax = *(esp);
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804dd10 */
#include <stdint.h>
 
uint32_t camlUnix_waitpid_non_intr_2001 (void) {
    do {
        eax = void (*0x804dd50)(uint32_t) (eax);
        ecx = camlUnix;
        ebx = *(eax);
        if (ebx != ecx) {
            goto label_0;
        }
        ebx = *((eax + 4));
        if ((ebx & 1) == 0) {
            goto label_0;
        }
        if (ebx != 0x17) {
            goto label_0;
        }
        eax = *(esp);
    } while (1);
label_0:
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_waitpid;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d550 */
#include <stdint.h>
 
int32_t camlUnix_open_proc_1949 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = esi;
    eax = .comment;
    eax = camlList_for_all_1137 (ebx, eax, ebx);
    *(esp) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    ecx = eax;
    if (ecx != 1) {
        eax = .comment;
        ebx = *((esp + 0x14));
        void (*0x80575f0)() ();
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        *((esp + 0x10)) = eax;
        eax = unix_dup2;
        caml_c_call (eax);
        eax = *((esp + 0x10));
        eax = unix_close;
        caml_c_call (eax);
    }
    eax = *((esp + 0xc));
    if (eax != 3) {
        *((esp + 0xc)) = eax;
        eax = unix_dup2;
        caml_c_call (eax);
        eax = *((esp + 0xc));
        eax = unix_close;
        caml_c_call (eax);
    }
    eax = *(esp);
    if (eax == 1) {
        eax = loc.camlUnix__188;
        ebx = *((esp + 8));
        camlList_iter_1074 ();
    }
    fcn_0804d630 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be30 */
#include <stdint.h>
 
int32_t camlUnix_fun_2634 (void) {
    eax = unix_setuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063259 */
#include <stdint.h>
 
int32_t caml_fl_add_blocks (int32_t arg_8h) {
    eax = *((ebp + 8));
    edx = *((eax - 4));
    edx >>= 0xa;
    ecx = caml_fl_cur_size;
    edx = ecx + edx + 1;
    *(obj.caml_fl_cur_size) = edx;
    edx = fl_last;
    if (eax > edx) {
        *(edx) = eax;
        if (edx == *(obj.caml_fl_merge)) {
            if (eax >= *(obj.caml_gc_sweep_hp)) {
                goto label_0;
            }
            eax = *((eax + 4));
            *(obj.caml_fl_merge) = eax;
        }
label_0:
        if (*(obj.caml_allocation_policy) != 1) {
            goto label_1;
        }
        eax = flp_size;
        if (eax > 0x3e7) {
            goto label_1;
        }
        *((eax*4 + obj.flp)) = edx;
        eax++;
        *(obj.flp_size) = eax;
        goto label_1;
    }
    ecx = .comment;
    if (ecx != 0) {
        if (eax > ecx) {
            goto label_2;
        }
    }
    ebx = 0x807b788;
    goto label_3;
    do {
        ecx = edx;
label_2:
        edx = *(ecx);
        if (edx == 0) {
            goto label_4;
        }
    } while (eax > edx);
label_4:
    ebx = ecx;
    ecx = edx;
label_3:
    edx = eax + 4;
    esi = *(edx);
    *(esi) = ecx;
    *(ebx) = eax;
    if (ebx == *(obj.caml_fl_merge)) {
        if (eax >= *(obj.caml_gc_sweep_hp)) {
            goto label_5;
        }
        edx = *(edx);
        *(obj.caml_fl_merge) = edx;
    }
label_5:
    if (*(obj.caml_allocation_policy) == 1) {
        truncate_flp ();
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806d339 */
#include <stdint.h>
 
uint32_t rotate_right32 (uint32_t value, uint32_t count) {
    const uint32_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t caml_MD5Transform (void * arg_8h, void * arg_ch) {
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    edx = *(edx);
    *((ebp - 0x5c)) = edx;
    ecx = *((ebp + 8));
    ecx += 4;
    *((ebp - 0x54)) = ecx;
    esi = *(ecx);
    ebx = *((ebp + 8));
    ebx += 8;
    *((ebp - 0x50)) = ebx;
    ecx = *(ebx);
    edi = *((ebp + 8));
    edi += 0xc;
    *((ebp - 0x4c)) = edi;
    edx = *(edi);
    ebx = *(eax);
    *((ebp - 0x48)) = ebx;
    edi = *((ebp - 0x5c));
    edi = edi + ebx - 0x28955b88;
    ebx = edx;
    ebx ^= ecx;
    ebx &= esi;
    ebx ^= edx;
    ebx += edi;
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 4));
    *((ebp - 0x44)) = edi;
    edx = edx + edi - 0x173848aa;
    *((ebp - 0x10)) = edx;
    edx = ecx;
    edx ^= esi;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 8));
    *((ebp - 0x40)) = edi;
    ecx = ecx + edi + 0x242070db;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0xc));
    *((ebp - 0x3c)) = edi;
    esi = esi + edi - 0x3e423112;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x10));
    *((ebp - 0x38)) = edi;
    ebx = ebx + edi - 0xa83f051;
    *((ebp - 0x10)) = ebx;
    ebx = ecx;
    ebx ^= edx;
    ebx &= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 0x14));
    *((ebp - 0x34)) = edi;
    edx = edx + edi + 0x4787c62a;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 0x18));
    *((ebp - 0x30)) = edi;
    ecx = ecx + edi - 0x57cfb9ed;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0x1c));
    *((ebp - 0x2c)) = edi;
    esi = esi + edi - 0x2b96aff;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x20));
    *((ebp - 0x28)) = edi;
    ebx = ebx + edi + 0x698098d8;
    *((ebp - 0x10)) = ebx;
    ebx = ecx;
    ebx ^= edx;
    ebx &= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 0x24));
    *((ebp - 0x24)) = edi;
    edx = edx + edi - 0x74bb0851;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 0x28));
    *((ebp - 0x20)) = edi;
    ecx = ecx + edi - 0xa44f;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0x2c));
    *((ebp - 0x1c)) = edi;
    esi = esi + edi - 0x76a32842;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x30));
    *((ebp - 0x18)) = edi;
    ebx = ebx + edi + 0x6b901122;
    edi = ecx;
    edi ^= edx;
    edi &= esi;
    edi ^= edx;
    edi = ebx + edi;
    edi = rotate_right32 (edi, 0x19);
    edi += esi;
    ebx = *((eax + 0x34));
    *((ebp - 0x14)) = ebx;
    edx = edx + ebx - 0x2678e6d;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= edi;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += edi;
    ebx = *((eax + 0x38));
    *((ebp - 0x10)) = ebx;
    ecx = ecx + ebx - 0x5986bc72;
    ebx = edi;
    ebx ^= esi;
    ebx &= edx;
    ebx ^= esi;
    ebx = ecx + ebx;
    ebx = rotate_right32 (ebx, 0xf);
    ebx += edx;
    ecx = *((eax + 0x3c));
    eax = esi + ecx + 0x49b40821;
    esi = edx;
    esi ^= edi;
    esi &= ebx;
    esi ^= edi;
    esi = eax + esi;
    esi = rotate_right32 (esi, 0xa);
    esi += ebx;
    eax = *((ebp - 0x44));
    edi = edi + eax - 0x9e1da9e;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x30));
    edx = edx + edi - 0x3fbf4cc0;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = *((ebp - 0x1c));
    ebx = ebx + edi + 0x265e5a51;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x48));
    esi = esi + edi - 0x16493856;
    *((ebp - 0x58)) = esi;
    esi = ebx;
    esi ^= edx;
    esi &= eax;
    esi ^= edx;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0xc);
    esi += ebx;
    edi = *((ebp - 0x34));
    eax = eax + edi - 0x29d0efa3;
    *((ebp - 0x58)) = eax;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax += *((ebp - 0x58));
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x20));
    edx = edx + edi + 0x2441453;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = ebx + ecx - 0x275e197f;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx = edi + ebx;
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x38));
    esi = esi + edi - 0x182c0438;
    *((ebp - 0x58)) = esi;
    esi = ebx;
    esi ^= edx;
    esi &= eax;
    esi ^= edx;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0xc);
    esi += ebx;
    edi = *((ebp - 0x24));
    eax = eax + edi + 0x21e1cde6;
    *((ebp - 0x58)) = eax;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax += *((ebp - 0x58));
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x10));
    edx = edx + edi - 0x3cc8f82a;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = *((ebp - 0x3c));
    ebx = ebx + edi - 0xb2af279;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x28));
    esi = esi + edi + 0x455a14ed;
    edi = ebx;
    edi ^= edx;
    edi &= eax;
    edi ^= edx;
    edi = esi + edi;
    edi = rotate_right32 (edi, 0xc);
    edi += ebx;
    *((ebp - 0x58)) = edi;
    esi = *((ebp - 0x14));
    edi = eax + esi - 0x561c16fb;
    eax = *((ebp - 0x58));
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1b);
    eax += *((ebp - 0x58));
    *((ebp - 0x60)) = eax;
    edi = *((ebp - 0x40));
    eax = edx + edi - 0x3105c08;
    edx = *((ebp - 0x60));
    edx ^= *((ebp - 0x58));
    edx &= ebx;
    edx ^= *((ebp - 0x58));
    edx = eax + edx;
    edx = rotate_right32 (edx, 0x17);
    edx += *((ebp - 0x60));
    esi = *((ebp - 0x2c));
    eax = ebx + esi + 0x676f02d9;
    ebx = *((ebp - 0x60));
    ebx ^= edx;
    ebx &= *((ebp - 0x58));
    ebx ^= *((ebp - 0x60));
    ebx = eax + ebx;
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = ebx;
    edi ^= edx;
    *((ebp - 0x64)) = edi;
    edi = *((ebp - 0x58));
    eax = *((ebp - 0x18));
    esi = edi + eax - 0x72d5b376;
    eax = *((ebp - 0x60));
    eax &= *((ebp - 0x64));
    eax ^= edx;
    edi = esi + eax;
    edi = rotate_right32 (edi, 0xc);
    edi += ebx;
    eax = *((ebp - 0x60));
    esi = *((ebp - 0x34));
    esi = eax + esi - 0x5c6be;
    *((ebp - 0x58)) = esi;
    esi = *((ebp - 0x64));
    esi ^= edi;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0x1c);
    esi += edi;
    eax = *((ebp - 0x28));
    edx = edx + eax - 0x788e097f;
    *((ebp - 0x58)) = edx;
    edx = edi;
    edx ^= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x15);
    edx += esi;
    eax = *((ebp - 0x1c));
    ebx = ebx + eax + 0x6d9d6122;
    *((ebp - 0x58)) = ebx;
    ebx = esi;
    ebx ^= edi;
    ebx ^= edx;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x10);
    ebx += edx;
    eax = *((ebp - 0x10));
    edi = edi + eax - 0x21ac7f4;
    *((ebp - 0x58)) = edi;
    edi = edx;
    edi ^= esi;
    edi ^= ebx;
    edi += *((ebp - 0x58));
    edi = rotate_right32 (edi, 9);
    edi += ebx;
    eax = *((ebp - 0x44));
    esi = esi + eax - 0x5b4115bc;
    eax = ebx;
    eax ^= edx;
    eax ^= edi;
    eax = esi + eax;
    eax = rotate_right32 (eax, 0x1c);
    eax += edi;
    esi = *((ebp - 0x38));
    edx = edx + esi + 0x4bdecfa9;
    esi = edi;
    esi ^= ebx;
    esi ^= eax;
    esi = edx + esi;
    esi = rotate_right32 (esi, 0x15);
    esi += eax;
    edx = *((ebp - 0x2c));
    ebx = ebx + edx - 0x944b4a0;
    *((ebp - 0x58)) = ebx;
    ebx = eax;
    ebx ^= edi;
    ebx ^= esi;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x10);
    ebx += esi;
    edx = *((ebp - 0x20));
    edi = edi + edx - 0x41404390;
    edx = esi;
    edx ^= eax;
    edx ^= ebx;
    edx = edi + edx;
    edx = rotate_right32 (edx, 9);
    edx += ebx;
    edi = *((ebp - 0x14));
    eax = eax + edi + 0x289b7ec6;
    edi = ebx;
    edi ^= esi;
    edi ^= edx;
    edi = eax + edi;
    edi = rotate_right32 (edi, 0x1c);
    edi += edx;
    eax = *((ebp - 0x48));
    esi = esi + eax - 0x155ed806;
    *((ebp - 0x58)) = esi;
    esi = edx;
    esi ^= ebx;
    esi ^= edi;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0x15);
    esi += edi;
    eax = *((ebp - 0x3c));
    ebx = ebx + eax - 0x2b10cf7b;
    eax = edi;
    eax ^= edx;
    eax ^= esi;
    eax = ebx + eax;
    eax = rotate_right32 (eax, 0x10);
    eax += esi;
    ebx = *((ebp - 0x30));
    edx = edx + ebx + 0x4881d05;
    ebx = esi;
    ebx ^= edi;
    ebx ^= eax;
    ebx = edx + ebx;
    ebx = rotate_right32 (ebx, 9);
    ebx += eax;
    edx = *((ebp - 0x24));
    edi = edi + edx - 0x262b2fc7;
    *((ebp - 0x58)) = edi;
    edi = eax;
    edi ^= esi;
    edi ^= ebx;
    edi += *((ebp - 0x58));
    edi = rotate_right32 (edi, 0x1c);
    edi += ebx;
    edx = *((ebp - 0x18));
    esi = esi + edx - 0x1924661b;
    edx = ebx;
    edx ^= eax;
    edx ^= edi;
    edx = esi + edx;
    edx = rotate_right32 (edx, 0x15);
    edx += edi;
    eax = eax + ecx + 0x1fa27cf8;
    esi = edi;
    esi ^= ebx;
    esi ^= edx;
    esi = eax + esi;
    esi = rotate_right32 (esi, 0x10);
    esi += edx;
    eax = *((ebp - 0x40));
    ebx = ebx + eax - 0x3b53a99b;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= edi;
    ebx ^= esi;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 9);
    ebx += esi;
    eax = *((ebp - 0x48));
    edi = edi + eax - 0xbd6ddbc;
    eax = edx;
    eax = ~eax;
    eax |= ebx;
    eax ^= esi;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1a);
    eax += ebx;
    edi = *((ebp - 0x2c));
    edx = edx + edi + 0x432aff97;
    *((ebp - 0x2c)) = edx;
    edx = esi;
    edx = ~edx;
    edx |= eax;
    edx ^= ebx;
    edx += *((ebp - 0x2c));
    edx = rotate_right32 (edx, 0x16);
    edx += eax;
    edi = *((ebp - 0x10));
    esi = esi + edi - 0x546bdc59;
    *((ebp - 0x10)) = esi;
    esi = ebx;
    esi = ~esi;
    esi |= edx;
    esi ^= eax;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0x11);
    esi += edx;
    edi = *((ebp - 0x34));
    ebx = ebx + edi - 0x36c5fc7;
    *((ebp - 0x10)) = ebx;
    ebx = eax;
    ebx = ~ebx;
    ebx |= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0xb);
    ebx += esi;
    edi = *((ebp - 0x18));
    eax = eax + edi + 0x655b59c3;
    edi = edx;
    edi = ~edi;
    edi |= ebx;
    edi ^= esi;
    edi = eax + edi;
    edi = rotate_right32 (edi, 0x1a);
    edi += ebx;
    eax = *((ebp - 0x3c));
    edx = edx + eax - 0x70f3336e;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx = ~edx;
    edx |= edi;
    edx ^= ebx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x16);
    edx += edi;
    eax = *((ebp - 0x20));
    esi = esi + eax - 0x100b83;
    *((ebp - 0x10)) = esi;
    esi = ebx;
    esi = ~esi;
    esi |= edx;
    esi ^= edi;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0x11);
    esi += edx;
    eax = *((ebp - 0x44));
    ebx = ebx + eax - 0x7a7ba22f;
    eax = edi;
    eax = ~eax;
    eax |= esi;
    eax ^= edx;
    eax = ebx + eax;
    eax = rotate_right32 (eax, 0xb);
    eax += esi;
    ebx = *((ebp - 0x28));
    edi = edi + ebx + 0x6fa87e4f;
    ebx = edx;
    ebx = ~ebx;
    ebx |= eax;
    ebx ^= esi;
    ebx = edi + ebx;
    ebx = rotate_right32 (ebx, 0x1a);
    ebx += eax;
    ecx = edx + ecx - 0x1d31920;
    edx = esi;
    edx = ~edx;
    edx |= ebx;
    edx ^= eax;
    edx = ecx + edx;
    edx = rotate_right32 (edx, 0x16);
    edx += ebx;
    edi = *((ebp - 0x30));
    esi = esi + edi - 0x5cfebcec;
    ecx = eax;
    ecx = ~ecx;
    ecx |= edx;
    ecx ^= ebx;
    ecx = esi + ecx;
    ecx = rotate_right32 (ecx, 0x11);
    ecx += edx;
    edi = *((ebp - 0x14));
    esi = eax + edi + 0x4e0811a1;
    eax = ebx;
    eax = ~eax;
    eax |= ecx;
    eax ^= edx;
    eax = esi + eax;
    eax = rotate_right32 (eax, 0xb);
    eax += ecx;
    edi = *((ebp - 0x38));
    esi = ebx + edi - 0x8ac817e;
    ebx = edx;
    ebx = ~ebx;
    ebx |= eax;
    ebx ^= ecx;
    ebx = esi + ebx;
    ebx = rotate_right32 (ebx, 0x1a);
    ebx += eax;
    edi = *((ebp - 0x1c));
    esi = edx + edi - 0x42c50dcb;
    edx = ecx;
    edx = ~edx;
    edx |= ebx;
    edx ^= eax;
    edx = esi + edx;
    edx = rotate_right32 (edx, 0x16);
    edx += ebx;
    edi = *((ebp - 0x40));
    esi = ecx + edi + 0x2ad7d2bb;
    ecx = eax;
    ecx = ~ecx;
    ecx |= edx;
    ecx ^= ebx;
    ecx = esi + ecx;
    ecx = rotate_right32 (ecx, 0x11);
    ecx += edx;
    edi = *((ebp - 0x24));
    esi = eax + edi - 0x14792c6f;
    eax = ebx;
    eax = ~eax;
    eax |= ecx;
    eax ^= edx;
    eax = esi + eax;
    ebx += *((ebp - 0x5c));
    esi = *((ebp + 8));
    *(esi) = ebx;
    ebx = ecx;
    edi = *((ebp - 0x54));
    ebx += *(edi);
    eax = rotate_right32 (eax, 0xb);
    eax = ebx + eax;
    *(edi) = eax;
    eax = *((ebp - 0x50));
    *(eax) += ecx;
    ecx = *((ebp - 0x4c));
    *(ecx) += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066fce */
#include <stdint.h>
 
int32_t caml_le_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055e00 */
#include <stdint.h>
 
int32_t camlString_uncapitalize_1106 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_apply1_1100 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80555c0 */
#include <stdint.h>
 
uint32_t camlString_copy_1042 (void) {
    int32_t var_4h;
    ecx = eax;
    *((esp + 4)) = ecx;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055e70 */
#include <stdint.h>
 
void camlString_index_1113 (void) {
    edx = ebx;
    ecx = 1;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    esi = *((eax + ebx));
    ebx -= esi;
    ebx = ebx + ebx + 1;
    return camlString_index_rec_1108 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c600 */
#include <stdint.h>
 
uint32_t unix_access (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t mode;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15b3b;
    esi = *((ebp + 8));
    eax = ebx + 0x9174;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    eax = access (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x1739;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065134 */
#include <stdint.h>
 
int32_t caml_convert_flag_list (int32_t arg_8h, char * arg_ch) {
    edx = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = 0;
    if (edx == 1) {
        goto label_0;
    }
    do {
        ecx = *(edx);
        ecx >>= 1;
        eax |= *((ebx + ecx*4));
        edx = *((edx + 4));
    } while (edx != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a204 */
#include <stdint.h>
 
void access (void) {
    access ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b939 */
#include <stdint.h>
 
uint32_t caml_sys_get_argv (void) {
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x10)) = 0;
    *((ebp - 0x14)) = 0;
    *((ebp - 0x34)) = ebx;
    eax = ebp - 0x34;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    eax = ebp - 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x20)) = eax;
    eax = caml_exe_name;
    eax = caml_copy_string (ebx);
    *((ebp - 0xc)) = eax;
    eax = caml_main_argv;
    eax = caml_copy_string_array (eax);
    *((ebp - 0x10)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x14)) = eax;
    edx = *((ebp - 0xc));
    *(eax) = edx;
    edx = *((ebp - 0x10));
    eax = *((ebp - 0x14));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x14));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f9a0 */
#include <stdint.h>
 
int32_t camlPervasives_flush_all_1185 (void) {
    eax = loc.camlPervasives__92;
    eax = caml_ml_out_channels_list;
    caml_c_call (1);
    return camlPervasives_iter_1186 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c030 */
#include <stdint.h>
 
int32_t camlPrintf_kbprintf_1397 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlPrintf__fun_1694;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            ebp = .comment;
            esi = loc.camlPrintf__42;
            edx = .comment;
            ecx = .comment;
            eax = 1;
            *(loc.caml_extra_params) = ebp;
            void (*0x804b3e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80567e0 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_bucket_1083 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        *((esp + 8)) = ebx;
        ecx = *((eax + 8));
        *((esp + 0xc)) = ecx;
        ecx = *((eax + 4));
        *((esp + 4)) = ecx;
        eax = *(eax);
        *(esp) = eax;
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            eax = *((eax + 8));
            *(eax) += 0xfffffffe;
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_remove_bucket_1083 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b8b5 */
#include <stdint.h>
 
uint32_t caml_sys_get_config (void) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x10)) = 0;
    *((ebp - 0x30)) = ebx;
    eax = ebp - 0x30;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 2;
    eax = ebp - 0xc;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x20)) = eax;
    eax = caml_copy_string (ebx);
    *((ebp - 0x10)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0xc)) = eax;
    edx = *((ebp - 0x10));
    *(eax) = edx;
    eax = *((ebp - 0xc));
    *((eax + 4)) = 0x41;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c7c1 */
#include <stdint.h>
 
int32_t caml_gc_compaction (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (0x10, "Heap compaction requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_compact_heap ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064041 */
#include <stdint.h>
 
int32_t caml_finish_major_cycle (void) {
    int32_t var_10h;
    int32_t var_ch;
    if (*(obj.caml_gc_phase) == 2) {
        start_cycle ();
    }
    if (*(obj.caml_gc_phase) != 0) {
        goto label_0;
    }
    do {
        eax = 0x7fffffff;
        mark_slice ();
    } while (*(obj.caml_gc_phase) == 0);
label_0:
    if (*(obj.caml_gc_phase) != 1) {
        goto label_1;
    }
    do {
        eax = 0x7fffffff;
        sweep_slice ();
    } while (*(obj.caml_gc_phase) == 1);
label_1:
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *(obj.caml_stat_major_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_allocated_words) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fe90 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_endline_1285 (void) {
    ebx = eax;
    eax = .comment;
    camlPervasives_output_string_1191 ();
    eax = caml_ml_output_char;
    caml_c_call (*(0x80755d8));
    eax = caml_ml_flush;
    caml_c_call (*(0x80755d8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f9c0 */
#include <stdint.h>
 
int32_t camlPervasives_output_string_1191 (void) {
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    eax = caml_ml_output;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f7c0 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_bool_1127 (void) {
    if (eax != 1) {
        eax = "true";
        return eax;
    }
    eax = "false";
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c110 */
#include <stdint.h>
 
int32_t camlUnix_fun_2718 (void) {
    eax = unix_chown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061e8e */
#include <stdint.h>
 
int32_t caml_init_frame_descriptors (void) {
    int32_t var_20h;
    uint32_t var_1ch;
    if (*(obj.inited.3139) != 0) {
        goto label_3;
    }
    eax = " *\a\bP";
    if (eax == 0) {
        goto label_4;
    }
    ebx = 0;
    esi = " *\a\bP";
    do {
        caml_register_frametable (eax);
        ebx++;
        eax = *((esi + ebx*4));
    } while (eax != 0);
label_4:
    *(obj.inited.3139) = 1;
label_3:
    eax = frametables;
    if (eax == 0) {
        goto label_5;
    }
    edx = 0;
    do {
        ecx = *(eax);
        edx += *(ecx);
        eax = *((eax + 4));
    } while (eax != 0);
    edx += edx;
    if (edx <= 4) {
        goto label_5;
    }
    ebx = 4;
    do {
        ebx += ebx;
    } while (ebx < edx);
    eax = ebx*4;
    eax = caml_stat_alloc (eax);
    *(obj.caml_frame_descriptors) = eax;
    if (ebx > 0) {
        goto label_6;
    }
    goto label_7;
    do {
label_2:
        edx = caml_frame_descriptors;
        *((edx + eax*4)) = 0;
        eax++;
    } while (eax < ebx);
label_7:
    ebx--;
    *(obj.caml_frame_descriptors_mask) = ebx;
    eax = frametables;
    *((ebp - 0x20)) = eax;
    if (eax == 0) {
        goto label_8;
    }
label_1:
    eax = *((ebp - 0x20));
    esi = *(eax);
    eax = *(esi);
    *((ebp - 0x1c)) = eax;
    if (eax <= 0) {
        goto label_9;
    }
    esi += 4;
    edi = 0;
label_0:
    ebx = caml_frame_descriptors_mask;
    eax = *(esi);
    eax >>= 3;
    eax &= ebx;
    ecx = caml_frame_descriptors;
    edx = ecx + eax*4;
    if (*(edx) == 0) {
        goto label_10;
    }
    do {
        eax++;
        eax &= ebx;
        edx = ecx + eax*4;
    } while (*(edx) != 0);
label_10:
    *(edx) = esi;
    eax = *((esi + 6));
    eax = esi + eax*2 + 0xb;
    eax &= 0xfffffffc;
    edx = eax + 8;
    if ((*((esi + 4)) & 1) != 0) {
        eax = edx;
    }
    edi++;
    if (edi != *((ebp - 0x1c))) {
        esi = eax;
        goto label_0;
    }
label_9:
    eax = *((ebp - 0x20));
    eax = *((eax + 4));
    *((ebp - 0x20)) = eax;
    if (eax != 0) {
        goto label_1;
    }
    goto label_8;
label_5:
    eax = caml_stat_alloc (0x10);
    *(obj.caml_frame_descriptors) = eax;
    ebx = 4;
label_6:
    eax = 0;
    goto label_2;
label_8:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f3b9 */
#include <stdint.h>
 
uint32_t unix_send (int32_t flags, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, void * buffer, size_t length) {
    int32_t var_401ch;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12d7c;
    eax = ebx + 0x91e4;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x401c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    edi = ebp - 0x4018;
    memmove (edi, eax, esi);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x401c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = send (eax, edi, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x1566;
        uerror (eax, 0);
    }
    eax = esi + esi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a6c4 */
#include <stdint.h>
 
void send (void) {
    send ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804e140 */
#include <stdint.h>
 
int32_t camlUnix_establish_server_2026 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = ebx;
    eax = camlUnix_domain_of_sockaddr_1529 (eax, eax);
    eax = unix_socket;
    eax = caml_c_call (eax);
    ecx = 3;
    ebx = 5;
    camlUnix_setsockopt_1646 (eax);
    eax = *(esp);
    eax = *((esp + 8));
    eax = unix_bind;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_listen;
    caml_c_call (eax);
    do {
label_0:
        eax = *((esp + 4));
        eax = camlUnix_accept_non_intr_2024 ();
        eax = *(eax);
        *((esp + 0xc)) = eax;
        eax = unix_fork;
        eax = caml_c_call (1);
        *(esp) = eax;
        if (eax == 1) {
            goto label_1;
        }
        eax = *((esp + 0xc));
        eax = unix_close;
        caml_c_call (eax);
        eax = *(esp);
        camlUnix_waitpid_non_intr_2001 ();
    } while (1);
label_1:
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        eax = 1;
        camlPervasives_exit_1326 ();
    }
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    camlUnix_try_set_close_on_exec_1366 ();
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    ecx = *((esp + 8));
    caml_apply2 ();
    eax = 1;
    camlPervasives_exit_1326 ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068481 */
#include <stdint.h>
 
uint32_t caml_ml_out_channels_list (void) {
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    esi = caml_local_roots;
    eax = ebp - 0x34;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0xc)) = 1;
    ebx = caml_all_opened_channels;
    if (ebx == 0) {
        goto label_0;
    }
    *((ebp - 0x10)) = 0;
    *((ebp - 0x14)) = 0;
    *((ebp - 0x34)) = esi;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    eax = ebp - 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x20)) = eax;
    do {
        if (*((ebx + 0x14)) == 0) {
            eax = caml_alloc_channel (ebx);
            *((ebp - 0x14)) = eax;
            eax = *((ebp - 0xc));
            *((ebp - 0x10)) = eax;
            eax = caml_alloc_small (2, 0);
            *((ebp - 0xc)) = eax;
            edx = *((ebp - 0x14));
            *(eax) = edx;
            edx = *((ebp - 0x10));
            eax = *((ebp - 0xc));
            *((eax + 4)) = edx;
        }
        ebx = *((ebx + 0x1c));
    } while (ebx != 0);
label_0:
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fddc */
#include <stdint.h>
 
uint32_t caml_search_exe_in_path (int32_t arg_8h) {
    int32_t var_24h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = ebp - 0x24;
    caml_ext_table_init (ebx, 8);
    eax = getenv ("PATH");
    eax = caml_decompose_path (ebx, eax);
    esi = eax;
    eax = *((ebp + 8));
    eax = caml_search_in_path (ebx, eax);
    edi = eax;
    caml_stat_free (esi);
    caml_ext_table_free (ebx, 0);
    eax = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062e0a */
#include <stdint.h>
 
int32_t caml_ext_table_init (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(ebx) = 0;
    *((ebx + 4)) = eax;
    eax <<= 2;
    eax = caml_stat_alloc (ebx);
    *((ebx + 8)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049fc4 */
#include <stdint.h>
 
void getenv (void) {
    getenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fa5e */
#include <stdint.h>
 
int32_t caml_decompose_path (int32_t arg_8h, char * arg_ch) {
    char * src;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    edi = 0;
    if (ebx == 0) {
        goto label_1;
    }
    edi = ebx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    edi = eax;
    strcpy (eax, ebx);
    ecx = edi;
label_0:
    eax = *(ecx);
    if (al != 0) {
        if (al != 0x3a) {
            goto label_2;
        }
    }
    ebx = ecx;
    goto label_3;
label_2:
    eax = ecx + 1;
    do {
        ebx = eax;
        edx = *(eax);
        eax++;
        if (dl == 0) {
            goto label_3;
        }
    } while (dl != 0x3a);
label_3:
    caml_ext_table_add (esi, ecx);
    if (*(ebx) != 0) {
        *(ebx) = 0;
        ecx = ebx + 1;
        goto label_0;
    }
label_1:
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fc28 */
#include <stdint.h>
 
int32_t caml_search_in_path (int32_t arg_8h, char * arg_ch) {
    int32_t var_80h;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_68h;
    char * src;
    int32_t var_8h;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *(eax);
    if (dl == 0) {
        goto label_0;
    }
    if (dl != 0x2f) {
        goto label_1;
    }
    goto label_2;
    do {
        if (dl == 0x2f) {
            goto label_2;
        }
label_1:
        eax++;
        edx = *(eax);
    } while (dl != 0);
label_0:
    if (*(esi) <= 0) {
        goto label_2;
    }
    *((ebp - 0x7c)) = 0;
    do {
        edx = *((ebp - 0x7c));
        edx <<= 2;
        *((ebp - 0x80)) = edx;
        eax = *((esi + 8));
        edi = *((eax + edx));
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        edx = ecx;
        edx = ~edx;
        edi = *((ebp + 0xc));
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        edx += ecx;
        eax = caml_stat_alloc (edx);
        ebx = eax;
        eax = *((esi + 8));
        edx = *((ebp - 0x80));
        eax = *((eax + edx));
        strcpy (ebx, eax);
        if (*(ebx) != 0) {
            edi = ebx;
            eax = 0;
            ecx = 0xffffffff;
            __asm ("repne scasb al, byte es:[edi]");
            ecx = ~ecx;
            *((ebx + ecx - 1)) = 0x2f;
        }
        eax = *((ebp + 0xc));
        strcat (ebx, eax);
        edx = ebp - 0x78;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *(esp) = 3;
        eax = xstat64 ();
        if (eax == 0) {
            eax = *((ebp - 0x68));
            eax &= 0xf000;
            if (eax == 0x8000) {
                goto label_3;
            }
        }
        caml_stat_free (ebx);
        *((ebp - 0x7c))++;
        eax = *((ebp - 0x7c));
    } while (*(esi) > eax);
label_2:
    edi = *((ebp + 0xc));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    edx = *((ebp + 0xc));
    strcpy (eax, edx);
label_3:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062d88 */
#include <stdint.h>
 
int32_t caml_ext_table_free (int32_t arg_8h, char * arg_ch) {
    esi = *((ebp + 8));
    if (*((ebp + 0xc)) == 0) {
        goto label_0;
    }
    if (*(esi) <= 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        eax = *((esi + 8));
        eax = *((eax + ebx*4));
        caml_stat_free (eax);
        ebx++;
    } while (*(esi) > ebx);
label_0:
    eax = *((esi + 8));
    caml_stat_free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051130 */
#include <stdint.h>
 
uint32_t camlArray_bubbledown_1170 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        ecx = *((ecx + 0x10));
        eax = camlArray_maxson_1155 (ecx, eax, ebx);
        ebx = eax;
        esi = *(esp);
        ecx = *((esi + 0xc));
        eax = *((ecx - 4));
        edx = *((ecx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_1;
            }
            edx = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_2;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi + 0xc));
        edi = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            edi >>= 9;
            ecx = *((esp + 8));
            if (edi <= ecx) {
                goto label_4;
            }
            caml_modify (eax + ecx*2 - 2, edx);
        } else {
            edi >>= 0xa;
            ecx = *((esp + 8));
            if (edi <= ecx) {
                goto label_5;
            }
            *(fp_stack--) = *(edx);
            *((eax + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        ecx = esi;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c0e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2714 (void) {
    eax = unix_umask;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061e58 */
#include <stdint.h>
 
int32_t caml_register_frametable (int32_t arg_8h) {
    edx = frametables;
    eax = *((ebp + 8));
    eax = cons ();
    *(obj.frametables) = eax;
    eax = caml_frame_descriptors;
    if (eax != 0) {
        caml_stat_free (eax);
        *(obj.caml_frame_descriptors) = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f700 */
#include <stdint.h>
 
int32_t camlPervasives_lnot_1049 (void) {
    eax ^= 0xffffffff;
    eax |= 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806be16 */
#include <stdint.h>
 
uint32_t caml_sys_is_directory (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        caml_sys_error (ebx);
    }
    eax = *((ebp - 0x58));
    eax &= 0xf000;
    al = (eax == 0x4000) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f54 */
#include <stdint.h>
 
void xstat64 (void) {
    xstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f115 */
#include <stdint.h>
 
int32_t caml_compact_heap_maybe (void) {
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_18h;
    int32_t var_14h;
    char * var_4h;
    int32_t var_8h;
    if (*(obj.caml_percent_max) <= 0xf423f) {
        if (*(obj.caml_stat_major_collections) <= 2) {
            goto label_0;
        }
        if (*(obj.caml_stat_heap_chunks) <= 2) {
            goto label_0;
        }
        edx = caml_fl_cur_size;
        eax = caml_fl_size_at_phase_change;
        ebx = 0;
        *((ebp - 0x18)) = edx;
        *((ebp - 0x14)) = ebx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[0] *= *(0x807122c);
        ebx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = ebx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[0] *= *(0x8071cb4);
        fp_stack[0] += fp_stack[1];
        fp_stack++;
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0xc));
        *(fp_stack--) = 0.0;
        fp_stack--;
        if (fp_stack[0] > fp_stack[1]) {
            fp_stack++;
            ecx = 0;
            *((ebp - 0x18)) = edx;
            *((ebp - 0x14)) = ecx;
            *(fp_stack--) = *((ebp - 0x18));
        }
        edx = caml_stat_heap_size;
        edx >>= 2;
        ecx = 0;
        *((ebp - 0x18)) = edx;
        *((ebp - 0x14)) = ecx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        if (fp_stack[0] >= fp_stack[1]) {
            fp_stack++;
            fp_stack++;
            *(fp_stack--) = *(0x8070b08);
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
        } else {
            *(fp_stack--) = fp_stack[0];
            fp_stack[0] *= *(0x8071bdc);
            fp_tmp_1 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_1;
            fp_stack[0] -= fp_stack[2];
            fp_stack++;
            fp_stack[1] /= fp_stack[0];
            fp_stack++;
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
            *(fp_stack--) = *(0x8070b08);
            *(fp_stack--) = *((ebp - 0x20));
            __asm ("fcmovnbe st(0), st(1)");
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
        }
        caml_gc_message (0x200, "FL size at phase change = %lu\n", eax);
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *(fp_stack--) = *((ebp - 0x20));
        *((ebp - 0x18)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x18));
        caml_gc_message (0x200, "Estimated overhead = %lu%%\n", eax);
        eax = caml_percent_max;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] < fp_stack[1]) {
            goto label_0;
        }
        caml_gc_message (0x200, "Automatic compaction triggered.\n", 0);
        caml_finish_major_cycle ();
        eax = caml_fl_cur_size;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        *(fp_stack--) = fp_stack[0];
        fp_stack[0] *= *(0x8071bdc);
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[2] -= fp_stack[0];
        fp_stack++;
        fp_stack[1] /= fp_stack[0];
        fp_stack++;
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0xc));
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *((ebp - 0x18)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x18));
        caml_gc_message (0x200, "Measured overhead: %lu%%\n", eax);
        caml_compact_heap ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806751e */
#include <stdint.h>
 
int32_t caml_log_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    log (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a6e4 */
#include <stdint.h>
 
void log (void) {
    log ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806721a */
#include <stdint.h>
 
uint32_t caml_copy_double (void) {
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068c61 */
#include <stdint.h>
 
uint32_t caml_ml_input_char (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0x14))) {
        eax = caml_refill (ebx);
        edi = eax;
    } else {
        edi = *(eax);
        eax++;
        *((ebx + 0x10)) = eax;
    }
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    edi &= 0xff;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80507b0 */
#include <stdint.h>
 
int32_t camlArray_fill_1070 (void) {
    int32_t var_4h;
    int32_t var_8h;
label_0:
    edi = ecx;
    if (ebx == 1) {
        goto label_2;
    }
    *((esp + 8)) = eax;
    eax = *((ebx + 4));
    *(esp) = eax;
    eax = *(ebx);
    *((esp + 4)) = eax;
    ebx = 1;
    esi = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        esi >>= 9;
    } else {
        esi >>= 0xa;
    }
    esi |= 1;
    esi += 0xfffffffe;
    if (ebx > esi) {
        goto label_3;
    }
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            eax = *((ecx + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esp + 8));
        ebp = ecx + ebx - 1;
        edx = *((edi + 0xc));
        ecx = *((edx - 4));
        if (ecx != 0xfe) {
            eax = caml_modify (edx + ebp*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            *((edx + ebp*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != esi);
label_3:
    eax = *((esp + 4));
    ebx = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ebx >>= 9;
    } else {
        ebx >>= 0xa;
    }
    ebx |= 1;
    eax = *((esp + 8));
    eax += ebx;
    eax--;
    ebx = *(esp);
    ecx = edi;
    goto label_0;
label_2:
    eax = 1;
    return eax;
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d280 */
#include <stdint.h>
 
int32_t camlUnix_safe_dup_1894 (void) {
    int32_t var_4h;
    do {
        *(esp) = eax;
        eax = unix_dup;
        eax = caml_c_call (eax);
        if (eax >= 7) {
            return eax;
        }
        eax = *(esp);
        eax = camlUnix_safe_dup_1894 (eax);
    } while (1);
    *(esp) = eax;
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b8a0 */
#include <stdint.h>
 
int32_t caml_sys_init (int32_t arg_8h, char ** arg_ch) {
    eax = *((ebp + 8));
    *(obj.caml_exe_name) = eax;
    eax = *((ebp + 0xc));
    *(obj.caml_main_argv) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066d24 */
#include <stdint.h>
 
int32_t caml_nativeint_to_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066cf2 */
#include <stdint.h>
 
void caml_copy_int32 (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    caml_alloc_custom (1, 4, 0);
    edx = *((ebp + 8));
    *((eax + 4)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80678b0 */
#include <stdint.h>
 
int32_t caml_string_length (uint32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    edx = *((eax + edx));
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066fe9 */
#include <stdint.h>
 
int32_t caml_lt_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] > fp_stack[1]) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054a10 */
#include <stdint.h>
 
int32_t camlList_assq_1174 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        ecx = *(ebx);
        edx = *((ecx + 4));
        ecx = *(ecx);
        if (ecx == eax) {
            eax = edx;
            return eax;
        }
        ebx = esi;
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065d4b */
#include <stdint.h>
 
int32_t caml_compare (int32_t arg_8h, int32_t arg_ch) {
    ecx = 1;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x807f400) {
        compare_free_stack ();
    }
    eax = 0xffffffff;
    if (ebx >= 0) {
        al = (ebx > 0) ? 1 : 0;
        eax = (int32_t) al;
        eax = eax + eax + 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054c20 */
#include <stdint.h>
 
int32_t camlList_find_1201 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, eax);
        if (eax != 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056a40 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_in_bucket_1125 (void) {
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        *((esp + 4)) = ebx;
        ecx = *((eax + 8));
        *(esp) = ecx;
        eax = *(eax);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068325 */
#include <stdint.h>
 
int32_t caml_ml_pos_in (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_in (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a426 */
#include <stdint.h>
 
int32_t caml_output_value_to_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    void * s2;
    size_t n;
    init_extern_output (ebx, esi, edi);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = extern_value ();
    ebx = extern_output_first;
    eax = caml_alloc_string (eax);
    *((ebp - 0x1c)) = eax;
    if (ebx == 0) {
        goto label_0;
    }
    edi = 0;
    do {
        eax = ebx + 8;
        esi = *((ebx + 4));
        esi -= eax;
        eax = *((ebp - 0x1c));
        eax = edi + eax;
        memmove (eax, eax, esi);
        edi += esi;
        esi = *(ebx);
        free (ebx);
        if (esi == 0) {
            goto label_0;
        }
        ebx = esi;
    } while (1);
label_0:
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc30 */
#include <stdint.h>
 
int32_t camlUnix_fun_2574 (void) {
    eax = unix_tcgetattr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80589e0 */
#include <stdint.h>
 
int32_t camlBuffer_advance_to_closing_1098 (void) {
    edi = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x18f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x8058140;
            *((edx + 0xc)) = ebp;
            *((edx + 0x10)) = ebx;
            *((edx + 0x14)) = edi;
            eax = *((edi - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            ebx = *((edi + eax));
            eax -= ebx;
            edi = eax + eax + 1;
            eax = ecx;
            ebx = esi;
            ecx = edi;
            void (*0x8058140)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067957 */
#include <stdint.h>
 
int32_t caml_bitvect_test (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax >>= 4;
    edx = *((ebp + 8));
    eax = *((eax + edx));
    ecx &= 7;
    edx = 1;
    edx <<= cl;
    eax &= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804aac0 */
#include <stdint.h>
 
int32_t caml_curry9_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059a50 */
#include <stdint.h>
 
int32_t camlPrintf_incr_ac_1187 (void) {
    if (ebx == 0xc3) {
        edx = 5;
    } else {
        edx = 3;
    }
    if (ebx == 0xe5) {
        ebx = *((ecx + 0xc));
        *((ebx + 8)) += 2;
    }
    if (eax != 1) {
        ebx = *((ecx + 0xc));
        eax = *((ecx + 0xc));
        eax = *((eax + 4));
        eax = eax + edx - 1;
        *((ebx + 4)) = eax;
        eax = 1;
        return eax;
    }
    ebx = *((ecx + 0xc));
    eax = *((ecx + 0xc));
    eax = *(eax);
    eax = eax + edx - 1;
    *(ebx) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058980 */
#include <stdint.h>
 
int32_t camlBuffer_closing_1097 (void) {
    if (eax == 0x51) {
        goto label_0;
    }
    while (1) {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x807905c;
            caml_raise_exn ();
            eax = 0xfb;
            return eax;
label_0:
            eax = 0x53;
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ca34 */
#include <stdint.h>
 
int32_t unix_dup2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1570c;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = dup2 ();
    if (eax == -1) {
        eax = ebx - 0x16f1;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a2c4 */
#include <stdint.h>
 
void dup2 (void) {
    dup2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a922 */
#include <stdint.h>
 
uint32_t caml_deserialize_float_8 (void) {
    int32_t var_10h;
    int32_t var_4h;
    eax = ebp - 0x10;
    caml_deserialize_block_float_8 (eax, 1);
    *(fp_stack--) = *((ebp - 0x10));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a8f1 */
#include <stdint.h>
 
int32_t caml_deserialize_block_float_8 (void * s1, int32_t arg_ch) {
    void * s2;
    size_t * n;
    ebx = *((ebp + 0xc));
    ebx <<= 3;
    eax = intern_src;
    eax = *((ebp + 8));
    memmove (eax, eax, ebx);
    *(obj.intern_src) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2578 (void) {
    eax = unix_getservbyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806cac3 */
#include <stdint.h>
 
uint32_t caml_gc_get (void) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x2c)) = ebx;
    eax = ebp - 0x2c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    eax = ebp - 0xc;
    *((ebp - 0x20)) = eax;
    eax = caml_alloc_tuple (ebx);
    *((ebp - 0xc)) = eax;
    edx = caml_minor_heap_size;
    edx >>= 2;
    edx = edx + edx + 1;
    caml_modify (eax, edx);
    eax = caml_major_heap_increment;
    eax >>= 2;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 4;
    caml_modify (eax, eax);
    eax = caml_percent_free;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 8;
    caml_modify (eax, eax);
    eax = caml_verb_gc;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0xc;
    caml_modify (eax, eax);
    eax = caml_percent_max;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0x10;
    caml_modify (eax, eax);
    eax = *((ebp - 0xc));
    eax += 0x14;
    caml_modify (eax, 1);
    eax = caml_allocation_policy;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0x18;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065565 */
#include <stdint.h>
 
int32_t caml_alloc_tuple (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_alloc (eax, 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065363 */
#include <stdint.h>
 
uint32_t caml_alloc (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t c;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = esi*4 + 0x8082244;
    if (ebx == 0) {
        goto label_0;
    }
    if (ebx > 0x100) {
        goto label_1;
    }
    edx = ebx*4 + 4;
    edi = edx;
    edi = -edi;
    eax = edi;
    eax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        eax += edx;
        *(obj.caml_young_ptr) = eax;
        caml_minor_collection ();
        *(obj.caml_young_ptr) += edi;
    }
    eax = ebx;
    eax <<= 0xa;
    edx = esi + eax + 0x300;
    eax = caml_young_ptr;
    *(eax) = edx;
    ecx = caml_young_ptr;
    eax = ecx + 4;
    if (esi > 0xfa) {
        goto label_0;
    }
    edx = 0;
    do {
        *((ecx + edx*4 + 4)) = 0;
        edx++;
    } while (edx != ebx);
    goto label_0;
label_1:
    eax = caml_alloc_shr (ebx, esi);
    edi = eax;
    if (esi <= 0xfa) {
        ebx <<= 2;
        memset (eax, 0, ebx);
    }
    caml_check_urgent_gc (edi);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064b3f */
#include <stdint.h>
 
int32_t caml_modify (uint32_t arg_8h, char * arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_0;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_0;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_0;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_1;
            }
            if (edx < edi) {
                goto label_0;
            }
        }
label_1:
        eax = .comment;
        if (eax >= *(0x807ebcc)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807ebc8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804afc0 */
#include <stdint.h>
 
int32_t caml_curry6_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80607b4 */
#include <stdint.h>
 
int32_t unix_symlink (char * path1, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    char * path2;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11987;
    esi = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = symlink (eax, esi);
    if (eax == -1) {
        eax = ebx - 0x1426;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a2a4 */
#include <stdint.h>
 
void symlink (void) {
    symlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070930 */
#include <stdint.h>
 
void libc_csu_fini (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a5da */
#include <stdint.h>
 
int32_t caml_deserialize_sint_2 (void) {
    eax = intern_src;
    edx = eax + 2;
    *(obj.intern_src) = edx;
    eax = *(eax);
    eax <<= 8;
    edx = *((edx - 1));
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056030 */
#include <stdint.h>
 
void camlString_contains_1137 (void) {
    ecx = ebx;
    ebx = 1;
    return camlString_contains_from_1132 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055e10 */
#include <stdint.h>
 
int32_t camlString_index_rec_1108 (void) {
    do {
        if (ecx >= ebx) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        esi = ecx;
        esi >>= 1;
        esi = *((eax + esi));
        esi = esi + esi + 1;
        if (esi == edx) {
            eax = ecx;
            return eax;
        }
        ecx += 2;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805aef0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_positional_1291 (void) {
    esi = eax;
    edi = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x18f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8059090;
            eax = edx;
            eax += 0x10;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = esi;
            *((ebx + 0x14)) = edi;
            eax = *((edx + 0x2c));
            ecx = esi;
            edx = ebp;
            void (*0x805bc20)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc00 */
#include <stdint.h>
 
int32_t camlUnix_fun_2570 (void) {
    eax = unix_tcsendbreak;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c8a0 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_1643 (void) {
    eax = unix_getsockopt;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf30 */
#include <stdint.h>
 
int32_t camlUnix_fun_2664 (void) {
    eax = unix_sigpending;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2606 (void) {
    eax = unix_socket;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805caec */
#include <stdint.h>
 
int32_t unix_execv (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1564c;
    edi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    *((esp + 4)) = eax;
    *(esp) = edi;
    execv ();
    caml_stat_free (esi);
    eax = ebx - 0x16ec;
    return uerror (eax, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80615a8 */
#include <stdint.h>
 
uint32_t cstringvect (int32_t arg_8h) {
    int32_t var_1ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x10b96;
    esi = *((ebp + 8));
    edi = *((esi - 4));
    edi >>= 0xa;
    eax = edi*4 + 4;
    eax = caml_stat_alloc (eax);
    *((ebp - 0x1c)) = eax;
    if (edi == 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((esi + edx*4));
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edi > edx);
label_0:
    eax = *((ebp - 0x1c));
    *((eax + edi*4)) = 0;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a3a4 */
#include <stdint.h>
 
void execv (void) {
    execv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a5a4 */
#include <stdint.h>
 
void execve (void) {
    execve ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a3b4 */
#include <stdint.h>
 
void execvp (void) {
    execvp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a8b4 */
#include <stdint.h>
 
void fchmod (void) {
    fchmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b270 */
#include <stdint.h>
 
int32_t caml_curry4_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b370 */
#include <stdint.h>
 
int32_t caml_curry2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068303 */
#include <stdint.h>
 
int32_t caml_ml_pos_out_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_out (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068263 */
#include <stdint.h>
 
int32_t caml_pos_out (int32_t arg_8h) {
    edx = *((ebp + 8));
    ebx = edx + 0x34;
    ecx = *((edx + 0x10));
    ecx -= ebx;
    ebx = ecx;
    ebx >>= 0x1f;
    eax = *((edx + 4));
    edx = *((edx + 8));
    eax += ecx;
    edx += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80665c4 */
#include <stdint.h>
 
int32_t caml_nativeint_of_string (int32_t arg_8h) {
    edx = 0x20;
    eax = *((ebp + 8));
    eax = parse_intnat ();
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066592 */
#include <stdint.h>
 
void caml_copy_nativeint (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    caml_alloc_custom (1, 4, 0);
    edx = *((ebp + 8));
    *((eax + 4)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e394 */
#include <stdint.h>
 
int32_t unix_isatty (int32_t fd) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13dac;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = isatty (eax);
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a2e4 */
#include <stdint.h>
 
void isatty (void) {
    isatty ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804e0d0 */
#include <stdint.h>
 
uint32_t camlUnix_accept_non_intr_2024 (void) {
    do {
        eax = void (*0x804e110)(uint32_t) (eax);
        ecx = camlUnix;
        ebx = *(eax);
        if (ebx != ecx) {
            goto label_0;
        }
        ebx = *((eax + 4));
        if ((ebx & 1) == 0) {
            goto label_0;
        }
        if (ebx != 0x17) {
            goto label_0;
        }
        eax = *(esp);
    } while (1);
label_0:
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = sym.unix_accept;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066f29 */
#include <stdint.h>
 
int32_t caml_int32_add (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax += *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bff0 */
#include <stdint.h>
 
int32_t camlPrintf_printf_1393 (void) {
    eax = .comment;
    eax = camlPrintf_fprintf_1391 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80670e7 */
#include <stdint.h>
 
void caml_expm1 (void) {
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    expm1 (ebp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a174 */
#include <stdint.h>
 
void expm1 (void) {
    expm1 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064e91 */
#include <stdint.h>
 
int32_t caml_page_table_add (int32_t arg_8h, char * arg_ch, int32_t arg_10h) {
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx &= 0xfffff000;
    esi = *((ebp + 0x10));
    esi--;
    esi &= 0xfffff000;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = edi;
        edx = 0;
        eax = ebx;
        eax = caml_page_table_modify ();
        if (eax != 0) {
            eax = 0xffffffff;
            goto label_1;
        }
        ebx += 0x1000;
    } while (esi >= ebx);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c2b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2764 (void) {
    eax = unix_wait;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80554a0 */
#include <stdint.h>
 
uint32_t camlString_fun_1160 (void) {
    ecx = *((ebx + 8));
    *(ecx) += 2;
    ecx = *((ebx + 0xc));
    edx = *((eax - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    eax = *((eax + edx));
    edx -= eax;
    eax = *((ebx + 0xc));
    eax = *(eax);
    eax = eax + edx*2;
    *(ecx) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d2d0 */
#include <stdint.h>
 
uint32_t camlUnix_safe_close_1898 (void) {
    eax = void (*0x804d300)() ();
    ecx = camlUnix;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = 1;
        return eax;
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804af40 */
#include <stdint.h>
 
int32_t caml_curry6 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ce30 */
#include <stdint.h>
 
uint32_t camlUnix_getaddrinfo_1751 (void) {
    int32_t var_4h;
    int32_t var_8h;
    eax = void (*0x804ce80)(uint32_t, uint32_t, uint32_t) (eax, ebx, ecx);
    ecx = loc.caml_exn_Invalid_argument;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        void (*0x804c9c0)() ();
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_getaddrinfo;
    caml_c_call (eax);
    ebx = 1;
    camlList_rev_append_1051 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804aa80 */
#include <stdint.h>
 
int32_t caml_curry9 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c0a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2706 (void) {
    eax = unix_set_nonblock;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2668 (void) {
    eax = unix_kill;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805fac4 */
#include <stdint.h>
 
int32_t unix_sleep (int32_t s) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1267c;
    caml_enter_blocking_section ();
    eax = *((ebp + 8));
    eax >>= 1;
    sleep (eax);
    caml_leave_blocking_section ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a654 */
#include <stdint.h>
 
void sleep (void) {
    sleep ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054510 */
#include <stdint.h>
 
uint32_t camlList_fold_right_1084 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        edx = *(ebx);
        ebx = esi;
        eax = camlList_fold_right_1084 (edx, eax);
    } while (1);
    ebx = eax;
    eax = *(esp);
    ecx = *((esp + 4));
    void (*0x804b540)() ();
label_0:
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806339c */
#include <stdint.h>
 
int32_t caml_fl_allocate (int32_t arg_8h) {
    int32_t var_fc8h;
    int32_t var_fc4h;
    int32_t var_fc0h;
    int32_t var_fbch;
    int32_t var_fb8h;
    void * s2;
    size_t n;
    eax = *((ebp + 8));
    edx = caml_allocation_policy;
    if (edx != 0) {
        if (edx != 1) {
            goto label_0;
        }
        edx = flp_size;
        *((ebp - 0xfbc)) = edx;
        if (edx <= 0) {
            goto label_1;
        }
        ecx = flp;
        edx = *(ecx);
        esi = *((edx - 4));
        esi >>= 0xa;
        ebx = 0;
        edi = flp;
        if (eax > esi) {
            goto label_2;
        }
        goto label_3;
    }
    ecx = fl_prev;
    edx = *(ecx);
    if (edx == 0) {
        goto label_4;
    }
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax > ebx) {
        goto label_5;
    }
    while (edx != 0) {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (ebx >= eax) {
            eax++;
            edx = 0;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_5:
        ecx = edx;
        edx = *(edx);
    }
label_4:
    *(obj.fl_last) = ecx;
    ecx = 0x807b788;
    edx = *(ecx);
    esi = fl_prev;
    if (ecx == esi) {
        goto label_0;
    }
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax > ebx) {
        goto label_7;
    }
    while (esi != ecx) {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (eax <= ebx) {
            eax++;
            edx = 0;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_7:
        ecx = edx;
        edx = *(edx);
    }
    goto label_0;
    do {
        ecx = *((edi + ebx*4));
        edx = *(ecx);
        esi = *((edx - 4));
        esi >>= 0xa;
        if (eax <= esi) {
label_3:
            eax++;
            edx = ebx;
            eax = allocate_block (edx);
            edi = eax;
            goto label_8;
        }
label_2:
        ebx++;
    } while (ebx < *((ebp - 0xfbc)));
label_1:
    if (*((ebp - 0xfbc)) != 0) {
        goto label_9;
    }
    ecx = 0x807b788;
    edi = 0;
    do {
        edx = 0;
        goto label_10;
label_9:
        ecx = *((ebp - 0xfbc));
        edx = *((ecx*4 + 0x807dbdc));
        ecx = *(edx);
        edi = *((ecx - 4));
        edi >>= 0xa;
        edx = beyond;
        if (edx != 0) {
            ecx = edx;
        }
    } while (1);
    do {
        edx = *(ecx);
        if (edx == 0) {
            *(obj.fl_last) = ecx;
            eax = 0;
            if (ecx == 0x807b788) {
                ecx = eax;
            }
            *(obj.beyond) = ecx;
            edi = 0;
            goto label_6;
        }
        esi = *((edx - 4));
        esi >>= 0xa;
        if (edi < esi) {
            *((ebx*4 + obj.flp)) = ecx;
            ebx = flp_size;
            edi = ebx + 1;
            *(obj.flp_size) = edi;
            if (eax <= esi) {
                *(obj.beyond) = edx;
                eax++;
                edx = ebx;
                eax = allocate_block (edx);
                edi = eax;
                goto label_8;
            }
            edi = esi;
        }
        ecx = edx;
label_10:
        ebx = flp_size;
    } while (ebx <= 0x3e7);
    *(obj.beyond) = edx;
    ecx = edx;
    if (edx == 0) {
        ecx = *((ebx*4 + 0x807dbdc));
    }
    edx = .comment;
    edx = *(edx);
    esi = *((edx - 4));
    esi >>= 0xa;
    edx = *(ecx);
    if (edx == 0) {
        goto label_11;
    }
    do {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (esi > ebx) {
            *(obj.beyond) = edx;
        } else {
            if (eax > ebx) {
                goto label_12;
            }
            eax++;
            edx = flp_size;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_12:
        ebx = *(edx);
        if (ebx == 0) {
            goto label_13;
        }
        ecx = edx;
        edx = ebx;
    } while (1);
label_13:
    ecx = edx;
label_11:
    *(obj.fl_last) = ecx;
    edi = 0;
    goto label_6;
label_8:
    eax = flp_size;
    if (ebx >= eax) {
        goto label_6;
    }
    ecx = 0;
    if (ebx > 0) {
        edx = *((ebx*4 + 0x807dbdc));
        edx = *(edx);
        edx = *((edx - 4));
        ecx = *((edx - 4));
        ecx >>= 0xa;
    }
    eax--;
    if (eax == ebx) {
        eax = *((eax*4 + obj.flp));
        eax = *(eax);
        edx = *((eax - 4));
        edx >>= 0xa;
        if (ecx >= edx) {
            *(obj.beyond) = eax;
            *(obj.flp_size)--;
            goto label_6;
        }
        *(obj.beyond) = 0;
        goto label_6;
    }
    edx = flp;
    eax = *((edx + ebx*4));
    edx = *((edx + ebx*4 + 4));
    *((ebp - 0xfc0)) = 0;
    *((ebp - 0xfbc)) = esi;
    esi = ecx;
    *((ebp - 0xfc4)) = ebx;
    ebx = 0;
    *((ebp - 0xfc8)) = edi;
    edi = edx;
    while (edi != eax) {
        edx = *(eax);
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (esi < ecx) {
            *((ebp + ebx*4 - 0xfb8)) = eax;
            ebx++;
            if (*((ebp - 0xfbc)) <= ecx) {
                goto label_14;
            }
            esi = ecx;
        }
        eax = edx;
    }
label_14:
    *((ebp - 0xfc0)) = ebx;
    ebx = *((ebp - 0xfc4));
    edi = *((ebp - 0xfc8));
    eax = flp_size;
    eax--;
    edx = *((ebp - 0xfc0));
    edx = eax + edx;
    if (edx <= 0x3e8) {
        if (*((ebp - 0xfc0)) != 1) {
            eax -= ebx;
            eax <<= 2;
            eax = ebx*4 + 0x807dbe4;
            eax = *((ebp - 0xfc0));
            eax += ebx;
            eax = eax*4 + obj_flp;
            memmove (eax, eax, eax);
            if (*((ebp - 0xfc0)) <= 0) {
                goto label_15;
            }
        }
        eax = *((ebp - 0xfc0));
        eax <<= 2;
        eax = ebp - 0xfb8;
        eax = ebx*4 + obj_flp;
        memmove (eax, eax, eax);
label_15:
        eax = flp_size;
        edx = *((ebp - 0xfc0));
        eax = edx + eax - 1;
        *(obj.flp_size) = eax;
    } else {
        eax = *((ebp - 0xfc0));
        eax += ebx;
        if (eax <= 0x3e7) {
            if (*((ebp - 0xfc0)) != 1) {
                edx = 0x3e8;
                edx -= ebx;
                edx -= *((ebp - 0xfc0));
                edx <<= 2;
                edx = ebx*4 + 0x807dbe4;
                eax = eax*4 + obj_flp;
                memmove (eax, edx, edx);
                if (*((ebp - 0xfc0)) <= 0) {
                    goto label_16;
                }
            }
            eax = *((ebp - 0xfc0));
            eax <<= 2;
            eax = ebp - 0xfb8;
            eax = ebx*4 + obj_flp;
            memmove (eax, eax, eax);
        } else {
            if (ebx == 0x3e8) {
                goto label_16;
            }
            eax = 0x3e8;
            eax -= ebx;
            eax <<= 2;
            eax = ebp - 0xfb8;
            eax = ebx*4 + obj_flp;
            memmove (eax, eax, eax);
        }
label_16:
        *(obj.flp_size) = 0x3e7;
        eax = .comment;
        eax = *(eax);
        *(obj.beyond) = eax;
        goto label_6;
label_0:
        edi = 0;
    }
label_6:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80519e0 */
#include <stdint.h>
 
uint32_t camlArray_sortto_1217 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    do {
label_0:
        if (edx <= 0xb) {
            esi = *((esi + 0x14));
            void (*0x80516e0)() ();
        }
        *(esp) = esi;
        *((esp + 8)) = ecx;
        *((esp + 0x14)) = ebx;
        *((esp + 0x10)) = eax;
        esi = edx;
        esi >>= 1;
        if (esi < 0) {
            esi++;
        }
        esi >>= 1;
        esi = esi + esi + 1;
        edx -= esi;
        edx++;
        ecx = ecx + esi - 1;
        eax = eax + esi - 1;
        edx = *((esp + 0xc));
        esi = *(esp);
        camlArray_sortto_1217 (edx, esi);
    } while (1);
    ebx = *((esp + 0xc));
    eax = *((esp + 0x10));
    ecx = eax + ebx - 1;
    esi = *(esp);
    ebx = *((esi + 0xc));
    edx = *((esp + 4));
    camlArray_sortto_1217 ();
    goto label_0;
    eax = *(esp);
    eax = *((eax + 0x10));
    *(esp) = eax;
    ebx = *((esp + 4));
    ebp = *((esp + 8));
    edx = ebp + ebx - 1;
    esi = *((esp + 0xc));
    eax = *((esp + 0x10));
    eax = eax + esi - 1;
    ecx = *((esp + 0x14));
    edi = *((esp + 0x14));
    *(loc.caml_extra_params) = ebp;
    ebp = *(esp);
    *(0x807b860) = ebp;
    return camlArray_merge_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b940 */
#include <stdint.h>
 
uint32_t camlUnix_get_port_1739 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    esi = eax;
    edi = ecx;
    eax = caml_string_equal (*((edi + 0xc)), loc.camlUnix__215);
    if (eax != 1) {
label_1:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        *(ebx) = esi;
        *((ebx + 4)) = 1;
        eax = ebx + 0xc;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        *((eax + 4)) = 1;
        return eax;
    }
    eax = void (*0x804ba80)(uint32_t, uint32_t, uint32_t) (ebx, edi, esi);
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = void (*0x804b9f0)() ();
        ecx = " %\a\b";
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = *((esp + 8));
        eax = *((esp + 0x10));
        eax = unix_getservbyname;
        eax = caml_c_call (*((eax + 0xc)));
        eax += 8;
        ecx = *(eax);
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 0x10));
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx + 0xc;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        *((eax + 4)) = 1;
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = caml_int_of_string;
    eax = caml_c_call (*((edi + 0xc)));
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 0x10));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx + 0xc;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80678ea */
#include <stdint.h>
 
int32_t caml_string_equal (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (ecx == edx) {
        goto label_0;
    }
    eax = *((ecx - 4));
    eax >>= 0xa;
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax != ebx) {
        goto label_1;
    }
    if (eax == 0) {
        goto label_0;
    }
    ebx = *(ecx);
    if (ebx == *(edx)) {
        goto label_2;
    }
    goto label_1;
    do {
        ecx += 4;
        edx += 4;
        ebx = *(ecx);
        if (ebx != *(edx)) {
            goto label_1;
        }
label_2:
        eax--;
    } while (eax != 0);
label_0:
    eax = 3;
    goto label_3;
label_1:
    eax = 1;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069915 */
#include <stdint.h>
 
uint32_t caml_serialize_float_4 (int32_t arg_8h) {
    int32_t var_4h;
    eax = ebp + 8;
    caml_serialize_block_4 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069894 */
#include <stdint.h>
 
int32_t caml_serialize_block_4 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax <<= 2;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    edx = extern_ptr;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    ecx = *((ebp + 0xc));
    eax = 0;
    *((ebp - 0x1c)) = ecx;
    do {
        edi = *((ebx + eax));
        esi = *((ebx + eax + 1));
        ecx = *((ebx + eax + 3));
        *((edx + eax)) = cl;
        ecx = *((ebx + eax + 2));
        *((edx + eax + 1)) = cl;
        ecx = edi;
        *((edx + eax + 3)) = cl;
        ecx = esi;
        *((edx + eax + 2)) = cl;
        eax += 4;
        *((ebp - 0x1c))--;
    } while (*((ebp - 0x1c)) != 0);
    eax = *((ebp + 0xc));
    edx = edx + eax*4;
label_0:
    *(obj.extern_ptr) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059910 */
#include <stdint.h>
 
void camlPrintf_scan_flags_1142 (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c92c */
#include <stdint.h>
 
int32_t caml_gc_major (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Major GC cycle requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059af0 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1204 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ebx = *(ebx);
        if (edx == 1) {
            goto label_1;
        }
        ecx = *((ecx + 0xc));
        caml_apply2 (eax, edx, ecx);
        eax = *(esp);
        eax += 2;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_1:
    ecx = *((ecx + 0xc));
    void (*0x804b540)() ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80526c0 */
#include <stdint.h>
 
uint32_t camlArray_iteri_1111 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    edx += 0xfffffffe;
    if (ecx > edx) {
        goto label_1;
    }
    *((esp + 0xc)) = edx;
    *((esp + 8)) = ecx;
    *(esp) = ebx;
    *((esp + 4)) = eax;
    do {
        edx = *(esp);
        eax = *((edx - 4));
        if (eax != 0xfe) {
            ebx = *((edx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = ecx;
        ecx = *((esp + 4));
        caml_apply2 ();
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80590b0 */
#include <stdint.h>
 
int32_t camlPrintf_cont_m_1365 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = ebx;
    eax = camlPrintf_ac_of_format_1184 (eax, ecx, eax);
    ebx = *(eax);
    eax = *((esp + 8));
    eax = ebx + eax - 1;
    eax = camlPrintf_index_of_int_1037 ();
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = loc.camlPrintf__code_begin;
            *((eax + 4)) = 3;
            ecx = *(esp);
            ebx = *(esp);
            ebx += 0xffffffb0;
            *((eax + 8)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = edx;
            esi = *((ecx + 0x20));
            edx = *((ecx + 0x2c));
            ebx = *((esp + 8));
            ecx = *((esp + 0xc));
            void (*0x805af50)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070078 */
#include <stdint.h>
 
int32_t caml_print_exception_backtrace (void) {
    uint32_t var_30h;
    uint32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    char * format;
    char ** var_8h;
    char ** var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    if (*(obj.caml_backtrace_pos) <= 0) {
        goto label_0;
    }
    ebx = 0;
    esi = ebp - 0x30;
    edi = "Re-raised at";
    do {
        eax = caml_backtrace_buffer;
        eax = *((eax + ebx*4));
        edx = esi;
        extract_location_info ();
        if (*((ebp - 0x30)) != 0) {
            eax = "Raised at";
            if (ebx != 0) {
                eax = "Called from";
                if (*((ebp - 0x2c)) == 0) {
                    eax = edi;
                    goto label_1;
                }
            }
label_1:
            edx = *((ebp - 0x1c));
            *((esp + 0x18)) = edx;
            edx = *((ebp - 0x20));
            *((esp + 0x14)) = edx;
            edx = *((ebp - 0x24));
            *((esp + 0x10)) = edx;
            edx = *((ebp - 0x28));
            *((esp + 0xc)) = edx;
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "%s file \"%s\", line %d, characters %d-%d\n");
        }
        ebx++;
    } while (*(obj.caml_backtrace_pos) > ebx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c2d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2768 (void) {
    eax = unix_execvpe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80521a0 */
#include <stdint.h>
 
int32_t camlArray_fill_1087 (void) {
    esi = eax;
    edi = edx;
    if (ebx < 1) {
        goto label_0;
    }
    if (ecx < 1) {
        goto label_0;
    }
    edx = *((esi - 4));
    eax = *((esi - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = edx;
        eax >>= 9;
    } else {
        eax = edx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= ecx;
    eax++;
    if (ebx > eax) {
        goto label_0;
    }
    ebx = ebx + ecx - 3;
    if (ebp > ebx) {
        goto label_1;
    }
    do {
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebp*2 - 2, edi);
        } else {
            *(fp_stack--) = *(edi);
            *((esi + ebp*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebp;
        eax = ebp;
        eax += 2;
    } while (ecx != ebx);
label_1:
    eax = 1;
    return eax;
label_0:
    eax = "Array.fill";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f550 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1408 (void) {
    eax = caml_ml_input_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80697a3 */
#include <stdint.h>
 
int32_t caml_serialize_float_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = *((ebp + 8));
    *((ebp - 0x10)) = eax;
    eax = *((ebp + 0xc));
    *((ebp - 0xc)) = eax;
    eax = ebp - 0x10;
    caml_serialize_block_float_8 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806975b */
#include <stdint.h>
 
int32_t caml_serialize_block_float_8 (int32_t arg_8h, int32_t arg_ch) {
    void ** s2;
    size_t * n;
    eax = *((ebp + 0xc));
    eax <<= 3;
    ebx = eax;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    eax = *((ebp + 8));
    eax = extern_ptr;
    memmove (eax, eax, ebx);
    *(obj.extern_ptr) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fb70 */
#include <stdint.h>
 
int32_t camlPervasives_input_1224 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = caml_ml_input;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "input";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f620 */
#include <stdint.h>
 
int32_t camlPervasives_invalid_arg_1012 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Invalid_argument;
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e27e */
#include <stdint.h>
 
int32_t unix_localtime (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_1ah;
    time_t * timer;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13ec2;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0xc)) = fp_stack[0];
    fp_stack--;
    eax = ebp - 0xc;
    eax = localtime (eax);
    if (eax == 0) {
        eax = ebx - 0x162d;
        unix_error (0x16, eax, 0);
    }
    alloc_tm ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f64 */
#include <stdint.h>
 
void localtime (void) {
    localtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f864 */
#include <stdint.h>
 
int32_t caml_final_custom_operations (int32_t arg_8h) {
    esi = *((ebp + 8));
    eax = custom_ops_final_table;
    if (eax == 0) {
        goto label_0;
    }
    ebx = *(eax);
    if (*((ebx + 4)) != esi) {
        goto label_1;
    }
    goto label_2;
    do {
        ebx = *(eax);
        if (*((ebx + 4)) == esi) {
            goto label_2;
        }
label_1:
        eax = *((eax + 4));
    } while (eax != 0);
label_0:
    eax = caml_stat_alloc (0x1c);
    ebx = eax;
    *(eax) = "_final";
    *((eax + 4)) = esi;
    *((eax + 8)) = 0;
    *((eax + 0xc)) = 0;
    *((eax + 0x10)) = 0;
    *((eax + 0x14)) = 0;
    caml_stat_alloc (8);
    *(eax) = ebx;
    edx = custom_ops_final_table;
    *((eax + 4)) = edx;
    *(obj.custom_ops_final_table) = eax;
label_2:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d44c */
#include <stdint.h>
 
uint32_t unix_getcwd (void) {
    int32_t var_1008h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14cf1;
    *((esp + 4)) = 0x1000;
    eax = ebp - 0x1008;
    *(esp) = eax;
    eax = getcwd ();
    if (eax == 0) {
        eax = ebx - 0x1679;
        uerror (eax, 0);
    }
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a6d4 */
#include <stdint.h>
 
void getcwd (void) {
    getcwd ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068b11 */
#include <stdint.h>
 
int32_t caml_getblock (int32_t arg_8h, void * s1, int32_t arg_10h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0x10));
    eax = *((ebx + 0x10));
    esi = *((ebx + 0x14));
    esi -= eax;
    if (edi <= esi) {
        eax = *((ebp + 0xc));
        eax = memmove (eax, eax, edi);
        *((ebx + 0x10)) += edi;
        esi = edi;
    } else {
        if (esi > 0) {
            eax = *((ebp + 0xc));
            memmove (eax, eax, esi);
            *((ebx + 0x10)) += esi;
        } else {
            eax = ebx + 0x34;
            *((ebp - 0x1c)) = eax;
            eax = *((ebx + 0xc));
            eax -= *((ebp - 0x1c));
            eax = *((ebp - 0x1c));
            eax = *(ebx);
            eax = caml_do_read (eax, eax, eax);
            ecx = eax;
            ecx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += ecx;
            edx = ebx + eax + 0x34;
            *((ebx + 0x14)) = edx;
            esi = edi;
            if (eax <= edi) {
                esi = eax;
            }
            eax = *((ebp - 0x1c));
            eax = *((ebp + 0xc));
            memmove (eax, eax, esi);
            eax = ebx + esi + 0x34;
            *((ebx + 0x10)) = eax;
        }
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066f45 */
#include <stdint.h>
 
int32_t caml_int32_neg (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = -eax;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806477c */
#include <stdint.h>
 
uint32_t caml_check_urgent_gc (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    ebx = caml_local_roots;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    eax = caml_force_major_slice;
    if (eax != 0) {
        *((ebp - 0x28)) = ebx;
        *((ebp - 0x20)) = 1;
        *((ebp - 0x24)) = 1;
        eax = ebp + 8;
        *((ebp - 0x1c)) = eax;
        caml_minor_collection ();
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b650 */
#include <stdint.h>
 
int32_t camlPrintf_sub_format_1117 (void) {
    *(esp) = eax;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    edi = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x1cf7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80595c0;
            eax = *(esp);
            *((ecx + 0xc)) = eax;
            *((ecx + 0x10)) = ebx;
            *((ecx + 0x14)) = edx;
            *((ecx + 0x18)) = edi;
            eax = ebp;
            ebx = esi;
            void (*0x80595c0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070231 */
#include <stdint.h>
 
void caml_debugger (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066dc5 */
#include <stdint.h>
 
int32_t caml_int32_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fbc0 */
#include <stdint.h>
 
int32_t camlPervasives_unsafe_really_input_1229 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (edx <= 1) {
            eax = 1;
            return eax;
        }
        *(esp) = edx;
        *((esp + 4)) = ecx;
        *((esp + 0xc)) = ebx;
        *((esp + 8)) = eax;
        eax = caml_ml_input;
        eax = caml_c_call (eax);
        if (eax == 1) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_End_of_file;
            eax = caml_raise_exn ();
        }
        edx = *(esp);
        edx -= eax;
        edx++;
        ebx = *((esp + 4));
        ecx = ebx + eax - 1;
        eax = *((esp + 8));
        ebx = *((esp + 0xc));
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e0bc */
#include <stdint.h>
 
uint32_t unix_getuid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14084;
    getuid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a4d4 */
#include <stdint.h>
 
void getuid (void) {
    getuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f530 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1404 (void) {
    eax = caml_ml_input_int;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068cf1 */
#include <stdint.h>
 
uint32_t caml_getword (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("input_binary_int: not a binary channel");
    }
    edi = 0;
    esi = 0;
    do {
        edx = *((ebx + 0x10));
        if (edx >= *((ebx + 0x14))) {
            al = caml_refill (ebx);
            eax = (int32_t) al;
        } else {
            eax = *(edx);
            edx++;
            *((ebx + 0x10)) = edx;
        }
        edi <<= 8;
        edi = eax + edi;
        esi++;
    } while (esi != 4);
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c880 */
#include <stdint.h>
 
int32_t camlUnix_fun_2814 (void) {
    eax = unix_getsockopt;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051aa0 */
#include <stdint.h>
 
int32_t camlArray_init_1037 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (eax == 1) {
        eax = loc.camlArray__34;
        return eax;
    }
    eax = 1;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t, uint32_t) (eax, ebx);
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    esi = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (esi > eax) {
        goto label_0;
    }
    do {
        ebx = *((esp + 4));
        ecx = *(ebx);
        eax = esi;
        eax = void (*ecx)(uint32_t, uint32_t) (esi, eax);
        ebx = *(esp);
        ecx = *((ebx - 4));
        if (ecx != 0xfe) {
            esi = *((esp + 0x10));
            eax = caml_modify (ebx + esi*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            esi = *((esp + 0xc));
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = esi;
        esi += 2;
        *((esp + 0xc)) = esi;
        eax = *((esp + 8));
    } while (ecx != eax);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b3c0 */
#include <stdint.h>
 
int32_t caml_tuplify2 (void) {
    ecx = ebx;
    ebx = *((eax + 4));
    eax = *(eax);
    edx = *((ecx + 8));
    return void (*edx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b110 */
#include <stdint.h>
 
uint32_t camlPrintf_index_of_int_1037 (void) {
    if (eax >= 1) {
        return;
    }
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = "Sformat.index_of_int: negative argument ";
    camlPervasives_$5e_1112 ();
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e270 */
#include <stdint.h>
 
int32_t caml_callback3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = *((ebp + 0x14));
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = loc_caml_callback3_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070468 */
#include <stdint.h>
 
int32_t loc_caml_callback3_exn (int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, int32_t arg_20h) {
    edx = *((esp + 0x14));
    eax = *((esp + 0x18));
    ebx = *((esp + 0x1c));
    ecx = *((esp + 0x20));
    esi = caml_apply3;
    return void (*0x8070369)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056c50 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_1185 (void) {
    int32_t var_4h_3;
    int32_t var_4h_2;
    int32_t var_8h;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = loc.camlHashtbl__code_begin;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            *((esp + 8)) = edx;
            eax = *(esp);
            ebx = *((eax + 4));
            *(esp) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_0;
            }
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_1;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            eax = camlHashtbl_code_begin ();
            ebx = *((esp + 4));
            eax = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf10 */
#include <stdint.h>
 
int32_t camlUnix_fun_2660 (void) {
    eax = unix_time;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057390 */
#include <stdint.h>
 
void camlHashtbl_hash_1031 (void) {
    caml_hash_univ_param (0x15, 0xc9, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b85f */
#include <stdint.h>
 
int32_t caml_hash_univ_param (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    *(obj.hash_univ_limit) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(obj.hash_univ_count) = eax;
    *(obj.hash_accu) = 0;
    eax = *((ebp + 0x10));
    hash_aux ();
    eax = hash_accu;
    eax &= 0x3fffffff;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a6b8 */
#include <stdint.h>
 
int32_t caml_deserialize_block_4 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    ecx = *((ebp + 8));
    edx = intern_src;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    ebx = *((ebp + 0xc));
    eax = 0;
    *((ebp - 0x10)) = ebx;
    do {
        edi = *((edx + eax));
        esi = *((edx + eax + 1));
        ebx = *((edx + eax + 3));
        *((ecx + eax)) = bl;
        ebx = *((edx + eax + 2));
        *((ecx + eax + 1)) = bl;
        ebx = edi;
        *((ecx + eax + 3)) = bl;
        ebx = esi;
        *((ecx + eax + 2)) = bl;
        eax += 4;
        *((ebp - 0x10))--;
    } while (*((ebp - 0x10)) != 0);
    eax = *((ebp + 0xc));
    edx = edx + eax*4;
label_0:
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055410 */
#include <stdint.h>
 
int32_t camlChar_uppercase_1045 (void) {
    if (eax >= 0xc3) {
        if (eax <= 0xf5) {
            goto label_0;
        }
    }
    if (eax >= 0x1c1) {
        if (eax <= 0x1ed) {
            goto label_0;
        }
    }
    if (eax >= 0x1f1) {
        if (eax <= 0x1fd) {
            goto label_0;
        }
    }
    return;
label_0:
    eax += 0xffffffc0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c290 */
#include <stdint.h>
 
int32_t camlUnix_fun_2760 (void) {
    eax = unix_getpid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059260 */
#include <stdint.h>
 
int32_t camlPrintf_doprn_1360 (void) {
    int32_t var_8h;
    int32_t var_ch;
    do {
        edx = ebx;
        eax = *((ecx + 0x80));
        if (edx >= eax) {
            ebx = *((ecx + 0x74));
            eax = *((ecx + 0x6c));
            ecx = *(ebx);
            void (*ecx)() ();
        }
        ebx = edx;
        ebx >>= 1;
        eax = *((ecx + 0x78));
        eax = *((eax + ebx));
        ebx = eax + eax + 1;
        if (ebx == 0x4b) {
            goto label_0;
        }
        edx = *((ecx + 0x60));
        eax = *((ecx + 0x6c));
        ecx = edx;
        caml_apply2 (edx, ebp, ecx);
        ebx = *(esp);
        ebx += 2;
        eax = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    eax = ecx;
    eax += 0x50;
    *((esp + 4)) = eax;
    eax = ecx;
    eax += 0x40;
    *(esp) = eax;
    *((esp + 8)) = ecx;
    edi = ecx;
    edi += 0x20;
    esi = ecx;
    esi += 0x10;
    ebx = *((ecx + 0x7c));
    eax = *((ecx + 0x78));
    ecx = ebp;
    ebp = *((esp + 8));
    *(loc.caml_extra_params) = ebp;
    ebp = *(esp);
    *(0x807b860) = ebp;
    ebp = *((esp + 4));
    *(0x807b864) = ebp;
    return camlPrintf_scan_format_1278 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c050 */
#include <stdint.h>
 
int32_t camlUnix_fun_2696 (void) {
    eax = unix_rmdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065f22 */
#include <stdint.h>
 
int32_t caml_int64_compare (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ebx = *((edx + 4));
    edx = *((edx + 8));
    esi = *((eax + 4));
    eax = *((eax + 8));
    edi = 1;
    if (edx <= eax) {
        if (edx >= eax) {
            if (ebx > esi) {
                goto label_0;
            }
        }
        edi = 0;
    }
label_0:
    ecx = 1;
    if (edx >= eax) {
        if (edx <= eax) {
            if (ebx < esi) {
                goto label_1;
            }
        }
        ecx = 0;
    }
label_1:
    edi -= ecx;
    eax = edi + edi + 1;
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f510 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1400 (void) {
    eax = caml_ml_seek_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056210 */
#include <stdint.h>
 
int32_t camlSys_set_signal_1057 (void) {
    eax = caml_install_signal_handler;
    caml_c_call (eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066634 */
#include <stdint.h>
 
int32_t caml_nativeint_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066524 */
#include <stdint.h>
 
int32_t caml_nativeint_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e312 */
#include <stdint.h>
 
int32_t caml_callbackN_exn (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8ch;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_74h;
    int32_t var_70h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edi = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax = caml_local_roots;
    *((ebp - 0x8c)) = eax;
    eax = ebp - 0x7c;
    *(obj.caml_local_roots) = eax;
    eax = *((ebp + 8));
    *((ebp - 0x5c)) = eax;
    if (edi <= 0) {
        goto label_0;
    }
    edx = *((ebp - 0x8c));
    *((ebp - 0x38)) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp - 0x38;
    *((ebp - 0x58)) = eax;
    *((ebp - 0x50)) = edi;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x4c)) = esi;
    eax = ebp - 0x58;
    *((ebp - 0x7c)) = eax;
    *((ebp - 0x74)) = 1;
    *((ebp - 0x78)) = 1;
    eax = ebp - 0x5c;
    *((ebp - 0x70)) = eax;
    ebx = 0;
    do {
        eax = edi;
        eax -= ebx;
        if (eax != 1) {
            if (eax != 2) {
                goto label_1;
            }
        } else {
            eax = *((esi + ebx*4));
            eax = *((ebp - 0x5c));
            eax = caml_callback_exn (eax, eax);
            edx = eax;
            edx &= 3;
            if (edx == 2) {
                edx = *((ebp - 0x8c));
                *(obj.caml_local_roots) = edx;
                goto label_2;
            }
            *((ebp - 0x5c)) = eax;
            ebx++;
            goto label_3;
        }
        eax = *((esi + ebx*4 + 4));
        eax = *((esi + ebx*4));
        eax = *((ebp - 0x5c));
        eax = caml_callback2_exn (eax, eax, eax);
        edx = eax;
        edx &= 3;
        if (edx == 2) {
            edx = *((ebp - 0x8c));
            *(obj.caml_local_roots) = edx;
            goto label_2;
        }
        *((ebp - 0x5c)) = eax;
        ebx += 2;
        goto label_3;
label_1:
        eax = *((esi + ebx*4 + 8));
        eax = *((esi + ebx*4 + 4));
        eax = *((esi + ebx*4));
        eax = *((ebp - 0x5c));
        eax = loc_caml_callback3_exn (eax, eax, eax);
        edx = eax;
        edx &= 3;
        if (edx == 2) {
            edx = *((ebp - 0x8c));
            *(obj.caml_local_roots) = edx;
            goto label_2;
        }
        *((ebp - 0x5c)) = eax;
        ebx += 3;
label_3:
    } while (edi > ebx);
label_0:
    eax = *((ebp - 0x8c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x5c));
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80695a7 */
#include <stdint.h>
 
int32_t caml_ml_open_descriptor_in (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_open_descriptor_in (eax);
    caml_alloc_channel (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068446 */
#include <stdint.h>
 
void caml_alloc_channel (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ebx = *((ebp + 8));
    *((ebx + 0x2c))++;
    caml_alloc_custom (ebx, 4, 1);
    *((eax + 4)) = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a96e */
#include <stdint.h>
 
int32_t caml_code_checksum (void) {
    int32_t var_60h;
    int32_t var_4h;
    int32_t var_8h;
    if (*(obj.checksum_computed.3405) == 0) {
        ebx = ebp - 0x60;
        caml_MD5Init (ebx);
        eax = caml_code_area_start;
        edx = caml_code_area_end;
        edx -= eax;
        caml_MD5Update (ebx, eax, edx);
        caml_MD5Final (obj.checksum.3404, ebx);
        *(obj.checksum_computed.3405) = 1;
    }
    eax = checksum.3404;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806d308 */
#include <stdint.h>
 
int32_t caml_MD5Init (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(eax) = 0x67452301;
    *((eax + 4)) = 0xefcdab89;
    *((eax + 8)) = 0x98badcfe;
    *((eax + 0xc)) = 0x10325476;
    *((eax + 0x10)) = 0;
    *((eax + 0x14)) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806db86 */
#include <stdint.h>
 
int32_t caml_MD5Update (void * s1, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    int32_t var_1ch;
    void * s2;
    size_t n;
    edi = *((ebp + 0x10));
    eax = *((ebp + 8));
    ebx = *((eax + 0x10));
    eax = ebx + edi*8;
    edx = *((ebp + 8));
    *((edx + 0x10)) = eax;
    if (ebx > eax) {
        *((edx + 0x14))++;
    }
    eax = edi;
    eax >>= 0x1d;
    edx = *((ebp + 8));
    *((edx + 0x14)) += eax;
    ebx >>= 3;
    ebx &= 0x3f;
    if (ebx != 0) {
        eax = edx + ebx + 0x18;
        edx = 0x40;
        edx -= ebx;
        ebx = edx;
        if (edi < edx) {
            edx = *((ebp + 0xc));
            eax = memcpy (eax, edx, edi);
            goto label_0;
        }
        edx = *((ebp + 0xc));
        memcpy (eax, edx, edx);
        eax = *((ebp + 8));
        eax += 0x18;
        eax = *((ebp + 8));
        caml_MD5Transform (eax, eax);
        *((ebp + 0xc)) += ebx;
        edi -= ebx;
    }
    if (edi <= 0x3f) {
        goto label_1;
    }
    ebx = *((ebp + 8));
    ebx += 0x18;
    *((ebp - 0x20)) = ebx;
    edx = *((ebp + 8));
    *((ebp - 0x1c)) = edx;
    esi = 0;
    do {
        eax = *((ebp + 0xc));
        eax += esi;
        edx = *(eax);
        *(ebx) = edx;
        edx = *((eax + 4));
        *((ebx + 4)) = edx;
        edx = *((eax + 8));
        *((ebx + 8)) = edx;
        edx = *((eax + 0xc));
        *((ebx + 0xc)) = edx;
        edx = *((eax + 0x10));
        *((ebx + 0x10)) = edx;
        edx = *((eax + 0x14));
        *((ebx + 0x14)) = edx;
        edx = *((eax + 0x18));
        *((ebx + 0x18)) = edx;
        edx = *((eax + 0x1c));
        *((ebx + 0x1c)) = edx;
        edx = *((eax + 0x20));
        *((ebx + 0x20)) = edx;
        edx = *((eax + 0x24));
        *((ebx + 0x24)) = edx;
        edx = *((eax + 0x28));
        *((ebx + 0x28)) = edx;
        edx = *((eax + 0x2c));
        *((ebx + 0x2c)) = edx;
        edx = *((eax + 0x30));
        *((ebx + 0x30)) = edx;
        edx = *((eax + 0x34));
        *((ebx + 0x34)) = edx;
        edx = *((eax + 0x38));
        *((ebx + 0x38)) = edx;
        eax = *((eax + 0x3c));
        *((ebx + 0x3c)) = eax;
        eax = *((ebp - 0x20));
        edx = *((ebp - 0x1c));
        caml_MD5Transform (edx, eax);
        esi += 0x40;
        eax = edi;
        eax -= esi;
    } while (eax > 0x3f);
    edi -= 0x40;
    eax = edi;
    eax &= 0xffffffc0;
    edx = *((ebp + 0xc));
    edx = edx + eax + 0x40;
    *((ebp + 0xc)) = edx;
    edi &= 0x3f;
label_1:
    eax = *((ebp + 8));
    eax += 0x18;
    edx = *((ebp + 0xc));
    memcpy (eax, edx, edi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806da98 */
#include <stdint.h>
 
int32_t caml_MD5Final (int32_t arg_8h, int32_t arg_ch) {
    int32_t c;
    size_t n;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *((ebx + 0x10));
    eax >>= 3;
    eax &= 0x3f;
    *((ebx + eax + 0x18)) = 0x80;
    edx = ebx + eax + 0x19;
    ecx = 0x3f;
    ecx -= eax;
    eax = ecx;
    if (ecx <= 7) {
        memset (edx, 0, ecx);
        edi = ebx + 0x18;
        caml_MD5Transform (ebx, edi);
        edx = 0x38;
        eax = 0;
        if ((edi & 1) != 0) {
            *(edi) = al;
            edi++;
            edx--;
        }
        if ((edi & 2) != 0) {
            *(edi) = ax;
            edi += 2;
            edx -= 2;
        }
        ecx = edx;
        ecx >>= 2;
        memset (edi, eax, ecx);
        if ((dl & 2) != 0) {
            *(edi) = ax;
            edi += 2;
        }
        if ((dl & 1) == 0) {
            goto label_0;
        }
        *(edi) = al;
    } else {
        eax -= 8;
        memset (edx, 0, eax);
    }
label_0:
    eax = ebx + 0x18;
    edx = *((ebx + 0x10));
    *((eax + 0x38)) = edx;
    edx = *((ebx + 0x14));
    *((eax + 0x3c)) = edx;
    caml_MD5Transform (ebx, eax);
    eax = *(ebx);
    *(esi) = eax;
    eax = *((ebx + 4));
    *((esi + 4)) = eax;
    eax = *((ebx + 8));
    *((esi + 8)) = eax;
    eax = *((ebx + 0xc));
    *((esi + 0xc)) = eax;
    *(ebx) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dbd0 */
#include <stdint.h>
 
uint32_t unix_getpid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14570;
    getpid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e64 */
#include <stdint.h>
 
void getpid (void) {
    getpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060810 */
#include <stdint.h>
 
int32_t unix_tcflow (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11930;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x13cc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcflow ();
    if (eax == -1) {
        eax = ebx - 0x141e;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e34 */
#include <stdint.h>
 
void tcflow (void) {
    tcflow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ae30 */
#include <stdint.h>
 
int32_t camlPrintf_scan_flags_1292 (void) {
    edi = eax;
    ebx = edx;
    ebx >>= 1;
    eax = *((esi + 0x1c));
    eax = *((eax + ebx));
    eax = eax + eax + 1;
    eax += 0xffffffc0;
    if (eax > 0x33) {
        void (*0x805aec0)() ();
    }
    eax >>= 1;
    /* switch table (38 cases) at 0x8079f2c */
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a6e0 */
#include <stdint.h>
 
int32_t case_0x8059717_217 (void) {
    ecx = *((esi + 0x20));
    edx += 2;
    eax = ebx;
    ebx = edx;
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a700 */
#include <stdint.h>
 
int32_t case_0x8059717_221 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__59;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a720 */
#include <stdint.h>
 
int32_t case_0x8059717_225 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__60;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a740 */
#include <stdint.h>
 
int32_t case_0x8059717_228 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__61;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a8e0 */
#include <stdint.h>
 
int32_t case_0x80598aa_235 (void) {
    eax = *((esi + 0xc));
    ebx = edx;
    return camlPrintf_bad_conversion_format_1061 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a9b0 */
#include <stdint.h>
 
uint32_t case_0x8059717_251 (int32_t arg_ch_5, int32_t arg_10h_2, int32_t arg_14h_2, int32_t arg_18h_2) {
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    ebx = eax;
    eax = *(esp);
    if (eax == 0xc7) {
        eax = 3;
        eax = camlString_make_1038 ();
        *(esp) = eax;
    } else {
        eax = ebx;
        camlChar_escaped_1038 ();
        ebx = loc.camlPrintf__56;
        eax = camlPervasives_$5e_1112 ();
        ebx = eax;
        eax = camlPrintf__55;
        eax = camlPervasives_$5e_1112 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ab40 */
#include <stdint.h>
 
uint32_t case_0x8059717_250 (int32_t arg_ch_5, int32_t arg_10h_2, int32_t arg_14h_2, int32_t arg_18h_2) {
    ecx = *((esi + 0x28));
    camlPrintf_get_arg_1288 ();
    eax = camlPervasives_string_of_bool_1127 ();
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ad60 */
#include <stdint.h>
 
uint32_t case_0x8059717_224 (int32_t arg_4h_3, int32_t arg_8h_2, int32_t arg_ch_4, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    eax = *((esp + 0xc));
    eax += 2;
    eax = *((esp + 4));
    eax = camlPrintf_sub_format_for_printf_1135 (eax, eax);
    ecx = eax;
    eax = *((esp + 0x18));
    eax = *((eax + 0xc));
    ebx = *(esp);
    eax = caml_apply2 ();
    *((esp + 0xc)) = eax;
    eax = *((esp + 4));
    if (eax == 0xf7) {
        eax = *((esp + 8));
        eax = camlPrintf_summarize_format_type_1162 ();
        *(esp) = eax;
        eax = *((esp + 0x10));
        if (eax != 1) {
            eax = *((esp + 0x14));
        } else {
            eax = .comment;
            ebx = *((eax + 8));
            ecx = *(ebx);
            eax = *((esp + 0x14));
            void (*ecx)() ();
        }
        ebx = *((esp + 0x18));
        edx = *((ebx + 0x14));
        ebx = *(esp);
        ecx = *((esp + 0xc));
        void (*0x804b4f0)() ();
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x24));
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a610 */
#include <stdint.h>
 
int32_t camlPrintf_get_arg_1288 (void) {
    if (eax != 1) {
        ebx = *(eax);
    }
    ecx = *((ecx + 0xc));
    eax = *((ecx - 4));
    edx = *((ecx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
        if (eax <= ebx) {
            goto label_0;
        }
        eax = *((ecx + ebx*2 - 2));
        return eax;
    }
    eax >>= 0xa;
    if (eax <= ebx) {
        goto label_1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f8c0 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_float_1140 (void) {
    eax = caml_format_float;
    caml_c_call ("%.12g");
    return camlPervasives_valid_float_lexem_1135 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b5d0 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_float_1110 (void) {
    eax = ebx;
    ebx = ecx;
    ecx = edx;
    edx = esi;
    camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    if (ebx != 0x8d) {
        return eax;
    }
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx - 1;
    ebx >>= 1;
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    if (ecx > ebx) {
        edx = 0x67;
        *((eax + ebx)) = dl;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b440 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_1085 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    esi = eax;
    *(esp) = esi;
    *((esp + 4)) = ecx;
    *((esp + 0xc)) = edx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlPrintf__skip_positional_spec_1090;
    *((ecx + 4)) = 3;
    *((ecx + 8)) = esi;
    eax = ebx;
    eax += 2;
    ebx = ecx;
    eax = camlPrintf_skip_positional_spec_1090 (ecx);
    ebx = eax;
    eax = *((esp + 4));
    eax -= ebx;
    eax += 0x15;
    eax = camlBuffer_create_1039 (ebx);
    ebx = 0x4b;
    camlBuffer_add_char_1072 (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x1cf7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x80594d0;
            eax = *(esp);
            *((ebx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ebx + 0x10)) = eax;
            eax = *((esp + 8));
            *((ebx + 0x14)) = eax;
            eax = *((esp + 0x18));
            *((ebx + 0x18)) = eax;
            ebx = 1;
            eax = *((esp + 0xc));
            eax = camlList_rev_append_1051 (ebx);
            ebx = eax;
            eax = *((esp + 0x10));
            ecx = *((esp + 0x14));
            camlPrintf_fill_format_1096 ();
            eax = *((esp + 0x18));
            ecx = *((eax + 4));
            ebx = 1;
            eax = *(eax);
            void (*0x8055610)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059460 */
#include <stdint.h>
 
int32_t camlPrintf_skip_positional_spec_1090 (void) {
    ecx = eax;
    edx = eax;
    edx >>= 1;
    eax = *((ebx + 8));
    eax = *((eax + edx));
    eax = eax + eax + 1;
    eax += 0xffffffa0;
    if (eax <= 0x13) {
        goto label_0;
    }
    eax = ecx;
    return eax;
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.camlPrintf__skip_int_literal_1092;
            *((edx + 4)) = 3;
            eax = *((ebx + 8));
            *((edx + 8)) = eax;
            *((edx + 0xc)) = ecx;
            eax = ecx;
            eax += 2;
            ebx = edx;
            void (*0x8058d80)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058480 */
#include <stdint.h>
 
int32_t camlBuffer_create_1039 (void) {
    if (eax < 3) {
        eax = 3;
    }
    ebx = .comment;
    if (eax > ebx) {
        eax = .comment;
        *(esp) = eax;
    } else {
        *(esp) = eax;
    }
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1000;
            *(eax) = ecx;
            *((eax + 4)) = 1;
            ebx = *(esp);
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058770 */
#include <stdint.h>
 
int32_t camlBuffer_add_char_1072 (void) {
    int32_t var_4h_2;
    int32_t var_8h;
    *(esp) = eax;
    *((esp + 8)) = ebx;
    ecx = *((eax + 4));
    *((esp + 4)) = ecx;
    ebx = *((eax + 8));
    if (ecx >= ebx) {
        ebx = 3;
        camlBuffer_resize_1066 ();
    }
    esi = *(esp);
    ebx = *(esi);
    ecx = *((esp + 4));
    eax = *((esp + 4));
    eax >>= 1;
    edx = *((ebx - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    edi = *((ebx + edx));
    edx -= edi;
    if (edx > eax) {
        edx = *((esp + 8));
        edx >>= 1;
        *((ebx + eax)) = dl;
        ecx += 2;
        *((esi + 4)) = ecx;
        eax = 1;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054330 */
#include <stdint.h>
 
int32_t camlList_rev_append_1051 (void) {
    do {
        if (eax == 1) {
            goto label_1;
        }
        esi = *((eax + 4));
        edx = *(eax);
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        *(ecx) = edx;
        *((ecx + 4)) = ebx;
        eax = esi;
        ebx = ecx;
    } while (1);
label_1:
    eax = ebx;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80594d0 */
#include <stdint.h>
 
int32_t camlPrintf_fill_format_1096 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
label_0:
        edx = *((ecx + 0x10));
        if (eax > edx) {
            goto label_1;
        }
        esi = eax;
        esi >>= 1;
        edx = *((ecx + 0xc));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx == 0x55) {
            goto label_2;
        }
        eax = *((ecx + 0x18));
        ebx = edx;
        camlBuffer_add_char_1072 (ebx, eax, ecx);
        eax = *((esp + 4));
        eax += 2;
        ebx = *(esp);
        ecx = *((esp + 8));
    } while (1);
label_2:
    if (ebx == 1) {
        goto label_3;
    }
    eax = *((ebx + 4));
    eax = *(ebx);
    eax = camlPervasives_string_of_int_1130 (eax, eax, ecx);
    ebx = eax;
    eax = *((esp + 8));
    eax = *((eax + 0x18));
    camlBuffer_add_string_1082 ();
    eax = *((esp + 8));
    ebx = *((eax + 0x14));
    eax = *((esp + 4));
    eax += 2;
    camlPrintf_skip_positional_spec_1090 ();
    ebx = *(esp);
    ecx = *((esp + 8));
    goto label_0;
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = "\xc8\x99\a\b!";
            caml_raise_exn ();
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070488 */
#include <stdint.h>
 
void loc_caml_ml_array_bound_error (int32_t arg_4h) {
    edx = *(esp);
    *(obj.caml_last_return_address) = edx;
    edx = esp + 4;
    *(obj.caml_bottom_of_stack) = edx;
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bd50 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1600 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    eax = caml_format_float;
    eax = caml_c_call (eax);
    *((esp + 4)) = eax;
    eax = *(esp);
    eax = caml_classify_float;
    eax = caml_c_call (eax);
    if (eax >= 7) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *((esp + 4));
    return camlPrintf_make_valid_float_lexeme_1270 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055940 */
#include <stdint.h>
 
int32_t camlString_escaped_1080 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    edx = eax;
    *((esp + 0x10)) = edx;
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    eax = 1;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((edx + ecx));
    ecx -= edx;
    ecx = ecx + ecx - 1;
    if (eax > ecx) {
        goto label_2;
    }
    *((esp + 4)) = ecx;
    *(esp) = eax;
    *((esp + 0x14)) = ebx;
    do {
        eax >>= 1;
        ebx = *((esp + 0x10));
        eax = *((ebx + eax));
        eax = eax + eax + 1;
        if (eax >= 0x1d) {
            if (eax == 0x45) {
                goto label_3;
            }
            if (eax == 0xb9) {
                goto label_3;
            }
        } else {
            if (eax >= 0x17) {
                if (eax >= 0x1b) {
                    goto label_3;
                }
            } else {
                if (eax >= 0x11) {
                    goto label_3;
                }
            }
        }
        eax = caml_is_printable;
        eax = caml_c_call (eax);
        if (eax != 1) {
            ecx = 3;
        } else {
            ecx = 9;
            goto label_4;
label_3:
            ecx = 5;
        }
label_4:
        ebx = *((esp + 0x14));
        eax = *(ebx);
        eax += ecx;
        eax--;
        *(ebx) = eax;
        eax = *(esp);
        edx = *(esp);
        eax += 2;
        *(esp) = eax;
        ecx = *((esp + 4));
    } while (edx != ecx);
label_2:
    eax = *((esp + 0x10));
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    edx = ecx + ecx + 1;
    ecx = *(ebx);
    if (ecx == edx) {
        return eax;
    }
    *((esp + 0x14)) = ebx;
    *((esp + 0x10)) = eax;
    eax = caml_create_string;
    eax = caml_c_call (*(ebx));
    esi = *((esp + 0x14));
    *(esi) = 1;
    eax = 1;
    ebx = *((esp + 0x10));
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx - 1;
    if (eax > ecx) {
        goto label_5;
    }
    *((esp + 8)) = ecx;
    *((esp + 4)) = eax;
    *((esp + 0xc)) = ebp;
    *((esp + 0x14)) = esi;
    *((esp + 0x10)) = ebx;
    do {
        eax >>= 1;
        ebx = *((esp + 0x10));
        eax = *((ebx + eax));
        eax = eax + eax + 1;
        ebx = eax;
        ebx += 0xffffffbc;
        if (ebx > 0x75) {
            if (ebx >= 0xffffffd9) {
                goto label_6;
            }
            ebx += 0x44;
            ebx >>= 1;
        }
        ebx += 0xfffffffe;
        if (ebx > 0x71) {
            ebx = *(esi);
            ebx >>= 1;
            edx = 0x5c;
            *((ebp + ebx)) = dl;
            *(esi) += 2;
            ebx = *(esi);
            ebx >>= 1;
            eax >>= 1;
            edx = eax;
            *((ebp + ebx)) = dl;
        } else {
label_6:
            *(esp) = eax;
            eax = caml_is_printable;
            eax = caml_c_call (eax);
            if (eax != 1) {
                esi = *((esp + 0x14));
                eax = *(esi);
                eax >>= 1;
                edx = *(esp);
                edx >>= 1;
                ebp = *((esp + 0xc));
                *((ebp + eax)) = dl;
            } else {
                edi = *(esp);
                esi = *((esp + 0x14));
                eax = *(esi);
                eax >>= 1;
                edx = 0x5c;
                ebp = *((esp + 0xc));
                *((ebp + eax)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                ecx = 0x64;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = eax + eax + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                eax = 0xa;
                *(esp) = eax;
                ecx = 0xa;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                ecx = *(esp);
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = edx + edx + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                ecx = 0xa;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = edx + edx + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
            }
        }
        *(esi) += 2;
        eax = *((esp + 4));
        ecx = *((esp + 4));
        eax += 2;
        *((esp + 4)) = eax;
        ebx = *((esp + 8));
    } while (ecx != ebx);
label_5:
    eax = ebp;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b400 */
#include <stdint.h>
 
uint32_t camlPrintf_format_string_1080 (void) {
    eax = camlPrintf_parse_string_conversion_1067 (ebx);
    ecx = *((eax + 4));
    ebx = *(eax);
    edx = *(esp);
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    esi = *((edx + eax));
    eax -= esi;
    edi = eax + eax + 1;
    esi = 1;
    eax = 0x41;
    return camlPrintf_pad_string_1072 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055610 */
#include <stdint.h>
 
int32_t camlString_sub_1046 (void) {
    int32_t var_14h;
    int32_t var_18h;
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx <<= 1;
        edx -= ecx;
        edx += 2;
        if (ebx > edx) {
            goto label_0;
        }
        *(esp) = ecx;
        *((esp + 4)) = ebx;
        *((esp + 8)) = eax;
        eax = caml_create_string;
        eax = caml_c_call (ecx);
        ebx = eax;
        eax = *(esp);
        eax = *((esp + 0x10));
        eax = *((esp + 0x18));
        caml_blit_string (eax, eax, ebx, 1, eax);
        eax = ebx;
        return eax;
    }
label_0:
    eax = "String.sub";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055580 */
#include <stdint.h>
 
int32_t camlString_make_1038 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 8));
    caml_fill_string (ebx, 1, eax, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80679cc */
#include <stdint.h>
 
int32_t caml_fill_string (void * s, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t c;
    size_t n;
    ecx = *((ebp + 0x10));
    ecx >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    edx = *((ebp + 0x14));
    edx >>= 1;
    memset (eax, edx, ecx);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a074 */
#include <stdint.h>
 
void memset (void) {
    memset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80556e0 */
#include <stdint.h>
 
int32_t camlString_blit_1056 (void) {
    if (esi >= 1) {
        if (ebx < 1) {
            goto label_0;
        }
        edi = *((eax - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((eax + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= esi;
        ebp += 2;
        if (ebx > ebp) {
            goto label_0;
        }
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ecx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ecx + ebp));
        ebp -= edi;
        edi = ebp;
        edi <<= 1;
        edi -= esi;
        edi += 2;
        if (edx > edi) {
            goto label_0;
        }
        caml_blit_string (eax, ebx, ecx, edx, esi);
        return;
    }
label_0:
    eax = "String.blit";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b290 */
#include <stdint.h>
 
int32_t camlPrintf_parse_string_conversion_1067 (void) {
    ebx = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059330;
            *((ecx + 0xc)) = ebx;
            eax = void (*0x805b310)() ();
            ecx = caml_exn_Failure;
            ebx = *(eax);
            if (ebx == ecx) {
                ecx = 0xe7;
                ebx = 1;
                eax = *(esp);
                void (*0x805b1a0)() ();
            }
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = 3;
            eax = 1;
            camlPrintf_parse_1069 (*(obj.caml_exception_pointer));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b550 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_int_1103 (void) {
    eax = ebx;
    ebx = ecx;
    ecx = edx;
    edx = esi;
    camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    if (ebx != 0x9d) {
        if (ebx == 0xdd) {
            goto label_0;
        }
        return eax;
    }
label_0:
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx - 1;
    ebx >>= 1;
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    if (ecx > ebx) {
        edx = 0x75;
        *((eax + ebx)) = dl;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bc20 */
#include <stdint.h>
 
int32_t camlPrintf_scan_positional_spec_1252 (void) {
    esi = eax;
    edi = ebx;
    ebx = edx;
    eax = edx;
    eax >>= 1;
    eax = *((esi + eax));
    edx = eax + eax + 1;
    eax = edx;
    eax += 0xffffffa0;
    if (eax <= 0x13) {
        goto label_0;
    }
    eax = 1;
    ecx = edi;
    void (*0x804b540)() ();
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805a4d0;
            *((ecx + 0xc)) = esi;
            *((ecx + 0x10)) = edi;
            *((ecx + 0x14)) = ebx;
            ebx += 2;
            eax = edx;
            eax += 0xffffffa0;
            void (*0x805a4d0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b540 */
#include <stdint.h>
 
uint32_t caml_apply2 (void) {
    edx = *((ecx + 4));
    if (edx == 5) {
        edx = *((ecx + 8));
        void (*edx)() ();
    }
    edx = *(ecx);
    ebx = ecx;
    eax = void (*edx)(uint32_t) (ebx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e24 */
#include <stdint.h>
 
void sprintf (void) {
    sprintf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a184 */
#include <stdint.h>
 
void strtol (void) {
    strtol ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80500a0 */
#include <stdint.h>
 
int32_t camlPervasives_exit_1326 (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (eax);
    eax = *(esp);
    eax = caml_sys_exit;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055280 */
#include <stdint.h>
 
int32_t camlChar_chr_1032 (void) {
    if (eax >= 1) {
        if (eax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    eax = "Char.chr";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd90 */
#include <stdint.h>
 
int32_t camlUnix_fun_2614 (void) {
    eax = unix_getpwuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a0a0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1581 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = ebx;
    *((esp + 8)) = ecx;
    *((esp + 4)) = edx;
    *(esp) = esi;
    eax = caml_make_vect;
    eax = caml_c_call (9);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x10));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c330 */
#include <stdint.h>
 
int32_t camlUnix_fun_2776 (void) {
    eax = unix_putenv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053320 */
#include <stdint.h>
 
int32_t camlArray_entry (void) {
    eax = loc.camlArray__21;
    *(loc.camlArray) = eax;
    eax = loc.camlArray__20;
    *(0x80763c4) = eax;
    eax = .comment;
    *(0x80763c8) = eax;
    eax = loc.camlArray__19;
    *(0x80763d8) = eax;
    eax = loc.camlArray__18;
    *(0x80763cc) = eax;
    eax = loc.camlArray__17;
    *(0x8076410) = eax;
    eax = loc.camlArray__16;
    *(0x80763d0) = eax;
    eax = loc.camlArray__15;
    *(0x80763d4) = eax;
    eax = loc.camlArray__14;
    *(0x80763dc) = eax;
    eax = loc.camlArray__13;
    *(0x80763e0) = eax;
    eax = loc.camlArray__12;
    *(0x80763ec) = eax;
    eax = loc.camlArray__11;
    *(0x80763f0) = eax;
    eax = loc.camlArray__10;
    *(0x80763f4) = eax;
    eax = loc.camlArray__9;
    *(0x80763f8) = eax;
    eax = loc.camlArray__8;
    *(0x80763e4) = eax;
    eax = loc.camlArray__7;
    *(0x8076414) = eax;
    eax = loc.camlArray__6;
    *(0x80763e8) = eax;
    eax = loc.camlArray__5;
    *(0x80763fc) = eax;
    eax = loc.camlArray__4;
    *(0x8076400) = eax;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Array.Bottom";
    *(0x8076418) = eax;
    eax = loc.camlArray__2;
    *(0x8076404) = eax;
    *(0x807641c) = 0xb;
    eax = camlArray__1;
    *(0x8076408) = eax;
    eax = .comment;
    *(0x807640c) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070268 */
#include <stdint.h>
 
int32_t loc_caml_alloc1 (int32_t arg_4h) {
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            return eax;
        }
        eax = *(esp);
        *(obj.caml_last_return_address) = eax;
        eax = esp + 4;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_0807024d ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x807024d */
#include <stdint.h>
 
void fcn_0807024d (void) {
    *(obj.caml_gc_regs) = esp;
    caml_garbage_collection (eax, ebx, ecx, edx, esi, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067650 */
#include <stdint.h>
 
int32_t caml_floor_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    floor (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a0d4 */
#include <stdint.h>
 
void floor (void) {
    floor ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f4a0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1500 (void) {
    ebx = *((ebx + 8));
    eax = 1;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (ebx);
    eax = *(esp);
    ebx = *((eax + 0xc));
    eax = 1;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064cfb */
#include <stdint.h>
 
uint32_t caml_alloc_for_heap (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebp - 0xc;
    eax = ebx + 0x10;
    eax = caml_aligned_malloc (ebx, 0x10, eax);
    if (eax != 0) {
        eax += 0x10;
        edx = eax - 0x10;
        *((edx + 8)) = ebx;
        ecx = *((ebp - 0xc));
        *(edx) = ecx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062e34 */
#include <stdint.h>
 
int32_t caml_aligned_malloc (size_t size, int32_t arg_ch, void ** arg_10h) {
    ebx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax += 0x1000;
    eax = malloc (eax);
    edx = eax;
    eax = 0;
    if (edx != 0) {
        eax = *((ebp + 0x10));
        *(eax) = edx;
        edx += ebx;
        edx &= 0xfffff000;
        eax = edx + 0x1000;
        eax -= ebx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068772 */
#include <stdint.h>
 
int32_t caml_channel_size (int32_t arg_8h) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    ebx = *(eax);
    edx = *((eax + 4));
    *((ebp - 0x1c)) = edx;
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 2;
    *((esp + 4)) = 0;
    *((esp + 8)) = 0;
    *(esp) = ebx;
    eax = lseek64 ();
    esi = eax;
    edi = edx;
    eax &= edx;
    if (eax != -1) {
        *((esp + 0xc)) = 0;
        eax = *((ebp - 0x1c));
        *((esp + 4)) = eax;
        edx = *((ebp - 0x20));
        *((esp + 8)) = edx;
        *(esp) = ebx;
        eax = lseek64 ();
        edx ^= *((ebp - 0x20));
        eax ^= *((ebp - 0x1c));
        edx |= eax;
        if (edx == 0) {
            goto label_0;
        }
    }
    caml_leave_blocking_section ();
    caml_sys_error (1);
label_0:
    caml_leave_blocking_section ();
    eax = esi;
    edx = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cfda */
#include <stdint.h>
 
int32_t unix_ftruncate (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15166;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = ftruncate64 ();
    if (eax == -1) {
        eax = ebx - 0x1683;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a5b4 */
#include <stdint.h>
 
void ftruncate64 (void) {
    ftruncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ff80 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1491 (void) {
    eax = caml_ml_seek_in_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd70 */
#include <stdint.h>
 
int32_t camlUnix_fun_2610 (void) {
    eax = unix_inet_addr_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ca84 */
#include <stdint.h>
 
int32_t unix_environment (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x156bc;
    eax = *((ebx - 0x14));
    eax = *(eax);
    caml_copy_string_array (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b860 */
#include <stdint.h>
 
int32_t loc_camlUnix_code_begin (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x801;
            *(edx) = esi;
            eax = *((ecx + 0x14));
            *((edx + 4)) = eax;
            eax = edx + 0xc;
            *((eax - 4)) = 0x1400;
            *(eax) = 3;
            esi = *((ecx + 0x10));
            *((eax + 4)) = esi;
            ecx = *((ecx + 0xc));
            ecx = *(ecx);
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066550 */
#include <stdint.h>
 
int32_t caml_int64_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064db2 */
#include <stdint.h>
 
int32_t caml_page_table_remove (int32_t arg_8h, char * arg_ch, int32_t arg_10h) {
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx &= 0xfffff000;
    esi = *((ebp + 0x10));
    esi--;
    esi &= 0xfffff000;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = 0;
        edx = edi;
        eax = ebx;
        eax = caml_page_table_modify ();
        if (eax != 0) {
            eax = 0xffffffff;
            goto label_1;
        }
        ebx += 0x1000;
    } while (esi >= ebx);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c4f0 */
#include <stdint.h>
 
int32_t camlCallback_entry (void) {
    eax = loc.camlCallback__2;
    *(loc.camlCallback) = eax;
    eax = camlCallback__1;
    *(0x807b258) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806285b */
#include <stdint.h>
 
int32_t caml_convert_signal_number (int32_t arg_8h) {
    eax = *((ebp + 8));
    if (eax < 0) {
        if (eax <= 0xffffffea) {
            goto label_0;
        }
        eax = ~eax;
        eax = *((eax*4 + obj.posix_signals));
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f454 */
#include <stdint.h>
 
int32_t caml_final_release (void) {
    *(obj.running_finalisation_function) = 0;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e190 */
#include <stdint.h>
 
int32_t caml_named_value (int32_t arg_8h) {
    char * s2;
    esi = *((ebp + 8));
    eax = *((ebp + 8));
    hash_value_name (ebx, esi);
    ebx = *((eax*4 + obj.named_value_table));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        eax = strcmp (esi, eax);
        if (eax == 0) {
            eax = ebx;
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ea7b */
#include <stdint.h>
 
int32_t caml_weak_create (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax >>= 1;
    ebx = eax + 1;
    if (eax > 0x3ffffe) {
        caml_invalid_argument ("Weak.create");
    }
    caml_alloc_shr (ebx, 0xfb);
    if (ebx <= 1) {
        goto label_0;
    }
    edx = 1;
    do {
        ecx = "8!\b\b";
        *((eax + edx*4)) = ecx;
        edx++;
    } while (ebx > edx);
label_0:
    edx = caml_weak_list_head;
    *(eax) = edx;
    *(obj.caml_weak_list_head) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066b48 */
#include <stdint.h>
 
int32_t caml_int64_mod (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ebx = *((edx + 4));
    ecx = *((edx + 8));
    edx = *((eax + 4));
    eax = *((eax + 8));
    esi = *((eax + 8));
    esi |= edx;
    if (esi == 0) {
        eax = caml_raise_zero_divide ();
    }
    esi = ecx - 0x80000000;
    esi |= ebx;
    if (esi == 0) {
        esi = edx;
        esi &= eax;
        if (esi == -1) {
            eax = caml_copy_int64 (0, 0);
        }
    } else {
        eax = _moddi3 (eax, ecx, edx);
        caml_copy_int64 (eax, edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060b81 */
#include <stdint.h>
 
uint32_t unix_tcgetattr (int32_t arg_8h) {
    int32_t var_3ch;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x115bd;
    eax = ebx + 0x9774;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcgetattr ();
    if (eax == -1) {
        eax = ebx - 0x13f1;
        uerror (eax, 0);
    }
    eax = caml_alloc_tuple (0x26);
    *((ebp - 0x28)) = eax;
    eax = *((ebx + 0x92f4));
    if (eax == 4) {
        goto label_1;
    }
    edi = *((ebp - 0x28));
    edx = ebx + 0x92f4;
    ecx = 0xffffec74;
    *((ebp - 0x2c)) = ecx;
    ecx = ebx + 0x9774;
    *((ebp - 0x30)) = ecx;
label_0:
    esi = edx + 4;
    if (eax != 1) {
        if (eax <= 1) {
            if (eax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (eax == 2) {
            goto label_4;
        }
        if (eax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        edx = esi + 4;
        eax = *(esi);
        eax = *(eax);
        eax &= *(edx);
        eax -= eax;
        eax &= 0xfffffffe;
        eax += 3;
        esi = edx + 4;
        *(edi) = eax;
        goto label_3;
    }
    eax = *(esi);
    *((ebp - 0x20)) = eax;
    ecx = *((esi + 4));
    *((ebp - 0x24)) = ecx;
    ecx = *((esi + 8));
    eax = *((esi + 0xc));
    *((ebp - 0x3c)) = eax;
    esi += 0x10;
    *((ebp - 0x1c)) = esi;
    if (ecx <= 0) {
        goto label_6;
    }
    esi = eax;
    eax = *((ebp - 0x20));
    esi &= *(eax);
    *((ebp - 0x20)) = 0;
    eax = *((ebp - 0x1c));
    if (esi != *(eax)) {
        goto label_7;
    }
    while (ecx > eax) {
        if (*((edx + eax*4 + 0x14)) == esi) {
            *((ebp - 0x20)) = eax;
            eax = *((ebp - 0x20));
            eax += *((ebp - 0x24));
            eax = eax + eax + 1;
            *(edi) = eax;
            goto label_6;
label_7:
            eax = *((ebp - 0x20));
        }
        eax++;
    }
label_6:
    eax = *((ebp - 0x1c));
    esi = eax + ecx*4;
    goto label_3;
label_4:
    edx = *(esi);
    esi += 4;
    *(edi) = 0x4b01;
    if (edx != 0) {
        eax = 0;
        if (edx != 1) {
            goto label_8;
        }
        ecx = *((ebp - 0x30));
        *(esp) = ecx;
        cfgetospeed ();
    } else {
        eax = *((ebp - 0x30));
        *(esp) = eax;
        eax = cfgetispeed ();
    }
label_8:
    edx = 1;
    ecx = *((ebp - 0x2c));
    if (*((ebx + ecx)) != eax) {
        goto label_9;
    }
    dl = 0;
    while (edx != 0x12) {
label_9:
        if (*((ebx + edx*8 - 0x138c)) == eax) {
            eax = *((ebx + edx*8 - 0x1388));
            eax = eax + eax + 1;
            *(edi) = eax;
            goto label_3;
        }
        edx++;
    }
    goto label_3;
label_5:
    eax = *(esi);
    esi += 4;
    eax = *((ebx + eax + 0x9785));
    eax = eax + eax + 1;
    *(edi) = eax;
label_3:
    eax = *(esi);
    if (eax != 4) {
        edi += 4;
        edx = esi;
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x28));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a496 */
#include <stdint.h>
 
uint32_t caml_output_val (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("output_value: not a binary channel");
    }
    init_extern_output ();
    edx = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    extern_value ();
    ebx = extern_output_first;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        edx = *((ebx + 4));
        edx -= eax;
        caml_really_putblock (edi, eax, edx);
        esi = *(ebx);
        free (ebx);
        if (esi == 0) {
            goto label_0;
        }
        ebx = esi;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f940 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_gen_1175 (void) {
    eax = caml_sys_open;
    eax = caml_c_call (ecx);
    eax = caml_ml_open_descriptor_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058d80 */
#include <stdint.h>
 
int32_t camlPrintf_skip_int_literal_1092 (void) {
    do {
        edx = eax;
        edx >>= 1;
        ecx = *((ebx + 8));
        ecx = *((ecx + edx));
        ecx = ecx + ecx + 1;
        if (ecx < 0x61) {
            goto label_0;
        }
        if (ecx >= 0x75) {
            goto label_1;
        }
        eax += 2;
    } while (1);
label_0:
    if (ecx == 0x49) {
        eax += 2;
        return eax;
    }
label_1:
    eax = *((ebx + 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070630 */
#include <stdint.h>
 
int32_t moddi3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    uint32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_10h;
    int32_t var_ch;
    ecx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0x14));
    edx = *((ebp + 8));
    *((ebp - 0x20)) = esi;
    *((ebp - 0x1c)) = edi;
    *((ebp - 0x2c)) = 0;
    if (ecx < 0) {
        goto label_5;
    }
label_3:
    esi = *((ebp - 0x1c));
    if (esi < 0) {
        goto label_6;
    }
label_2:
    eax = *((ebp - 0x1c));
    esi = ebp - 0x10;
    edi = *((ebp - 0x20));
    *((ebp - 0x30)) = edx;
    *((ebp - 0x28)) = edx;
    *((ebp - 0x24)) = edi;
    edi = ecx;
    if (eax != 0) {
        goto label_7;
    }
    if (*((ebp - 0x24)) <= ecx) {
        goto label_8;
    }
    eax = edx;
    edx = ecx;
    eax = *(edx:eax) / ebp - 0x24;
    edx = *(edx:eax) % ebp - 0x24;
label_1:
    eax = *((ebp - 0x2c));
    *(esi) = edx;
    *((esi + 4)) = 0;
    if (eax != 0) {
        goto label_9;
    }
    do {
        eax = *((ebp - 0x10));
        edx = *((ebp - 0xc));
        return eax;
label_7:
        if (eax <= ecx) {
            goto label_10;
        }
        *(esi) = edx;
        *((esi + 4)) = ecx;
label_0:
        eax = *((ebp - 0x2c));
    } while (eax == 0);
label_9:
    eax = *((ebp - 0x10));
    edx = *((ebp - 0xc));
    eax = -eax;
    edx += 0;
    edx = -edx;
    return eax;
label_10:
    __asm ("bsr edx, eax");
    edx ^= 0x1f;
    *((ebp - 0x20)) = edx;
    if (edx != 0) {
        goto label_11;
    }
    ecx = *((ebp - 0x28));
    if (*((ebp - 0x24)) <= ecx) {
        goto label_12;
    }
    while (1) {
        ecx = *((ebp - 0x28));
        *((esi + 4)) = edi;
        *(esi) = ecx;
        goto label_0;
label_8:
        edx = *((ebp - 0x24));
        if (edx == 0) {
            eax = 1;
            edx = 0;
            eax = *(edx:eax) / ebp - 0x24;
            edx = *(edx:eax) % ebp - 0x24;
            *((ebp - 0x24)) = eax;
        }
        eax = edi;
        edx = 0;
        eax = *(edx:eax) / ebp - 0x24;
        edx = *(edx:eax) % ebp - 0x24;
        eax = *((ebp - 0x28));
        eax = *(edx:eax) / ebp - 0x24;
        edx = *(edx:eax) % ebp - 0x24;
        goto label_1;
label_6:
        ebp - 0x20 = -ebp - 0x20;
        *((ebp - 0x1c)) += 0;
        ebp - 0x1c = -ebp - 0x1c;
        goto label_2;
label_5:
        edx = -edx;
        ecx += 0;
        ecx = -ecx;
        *((ebp - 0x2c)) = 0xffffffff;
        goto label_3;
label_11:
        ecx = *((ebp - 0x20));
        edx = eax;
        eax = 0x20;
        eax -= *((ebp - 0x20));
        edx <<= cl;
        *((ebp - 0x28)) = eax;
        eax = *((ebp - 0x24));
        ecx = *((ebp - 0x28));
        eax >>= cl;
        ecx = *((ebp - 0x20));
        eax |= edx;
        edx = edi;
        *((ebp - 0x38)) = eax;
        eax = *((ebp - 0x24));
        eax <<= cl;
        ecx = *((ebp - 0x28));
        *((ebp - 0x34)) = eax;
        eax = *((ebp - 0x30));
        edx >>= cl;
        ecx = *((ebp - 0x20));
        edi <<= cl;
        ecx = *((ebp - 0x28));
        eax >>= cl;
        ecx = *((ebp - 0x20));
        eax |= edi;
        edi = *((ebp - 0x30));
        eax = *(edx:eax) / ebp - 0x38;
        edx = *(edx:eax) % ebp - 0x38;
        edi <<= cl;
        *((ebp - 0x24)) = edi;
        edi = edx;
        edx:eax = eax * *((ebp - 0x34));
        if (edi < edx) {
            goto label_13;
        }
        if (*((ebp - 0x24)) < eax) {
            goto label_14;
        }
label_4:
        ecx = *((ebp - 0x24));
        ecx -= eax;
        edi -= edx;
        edx = ecx;
        ecx = *((ebp - 0x20));
        eax = edi;
        edx >>= cl;
        ecx = *((ebp - 0x28));
        eax <<= cl;
        ecx = *((ebp - 0x20));
        eax |= edx;
        *(esi) = eax;
        edi >>= cl;
        *((esi + 4)) = edi;
        goto label_0;
label_12:
        edx = *((ebp - 0x28));
        edx -= *((ebp - 0x24));
        edi -= eax;
        *((ebp - 0x28)) = edx;
    }
label_14:
    if (edi != edx) {
        goto label_4;
    }
label_13:
    eax -= *((ebp - 0x34));
    edx -= *((ebp - 0x38));
    goto label_4;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056040 */
#include <stdint.h>
 
uint32_t camlString_rcontains_from_1140 (void) {
    if (ebx >= 1) {
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx = edx + edx + 1;
        if (ebx >= edx) {
            goto label_0;
        }
        eax = void (*0x8056090)() ();
        ecx = " %\a\b";
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        camlString_rindex_rec_1121 (*(obj.caml_exception_pointer));
        eax = 3;
        return eax;
    }
label_0:
    eax = "String.rcontains_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055ee0 */
#include <stdint.h>
 
int32_t camlString_rindex_rec_1121 (void) {
    do {
        if (ebx < 1) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        edx = ebx;
        edx >>= 1;
        edx = *((eax + edx));
        edx = edx + edx + 1;
        if (edx == ecx) {
            eax = ebx;
            return eax;
        }
        ebx += 0xfffffffe;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804abc0 */
#include <stdint.h>
 
int32_t caml_curry9_5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_6;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b8c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2828 (void) {
    if ((eax & 1) != 0) {
        eax >>= 1;
        if (eax < 2) {
            goto label_0;
        }
        eax = *((ebx + 0x10));
        *(eax) = 3;
        eax = 1;
        return eax;
    }
    ecx = *((eax - 4));
    if (ecx < 1) {
        goto label_0;
    }
    if (ecx > 1) {
        goto label_1;
    }
    ecx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = ecx;
            caml_modify (*((ebx + 8)), eax);
            eax = 1;
            return eax;
label_1:
            ecx = *(eax);
            eax = *((ebx + 0xc));
            *(eax) = ecx;
            eax = 1;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805faf8 */
#include <stdint.h>
 
int32_t unix_socket (int32_t domain, int32_t arg_ch, int32_t arg_10h) {
    int32_t type;
    int32_t protocol;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12648;
    eax = *((ebp + 0x10));
    eax >>= 1;
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebx - 0x1c));
    eax = *((eax + edx*4));
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *((ebx - 0x20));
    eax = *((eax + edx*4));
    eax = socket (eax, eax, eax);
    if (eax == -1) {
        eax = ebx - 0x14f4;
        uerror (eax, 0);
    }
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a2b4 */
#include <stdint.h>
 
void socket (void) {
    socket ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b0d0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1694 (void) {
    eax = *((ebx + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051be0 */
#include <stdint.h>
 
int32_t camlArray_copy_1049 (void) {
    int32_t var_4h;
    ebx = eax;
    ecx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    if (ecx == 1) {
        eax = loc.camlArray__32;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        eax = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (ecx);
    esi = eax;
    ebx = 3;
    edi = *(esp);
    edi += 0xfffffffe;
    if (ebx > edi) {
        goto label_3;
    }
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != edi);
label_3:
    eax = esi;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80682e1 */
#include <stdint.h>
 
int32_t caml_ml_pos_in_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_in (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068284 */
#include <stdint.h>
 
int32_t caml_pos_in (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = *((ebp + 8));
    edx = *((eax + 0x14));
    edx -= *((eax + 0x10));
    ecx = edx;
    ecx >>= 0x1f;
    ebx = *((eax + 4));
    esi = *((eax + 8));
    ebx -= edx;
    esi -= ecx;
    eax = ebx;
    edx = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c970 */
#include <stdint.h>
 
uint32_t unix_connect (int32_t socket, int32_t arg_ch) {
    int32_t var_7ch;
    int32_t var_78h;
    void * addr;
    size_t addrlen;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x157cc;
    eax = ebp - 0x7c;
    esi = ebp - 0x78;
    eax = *((ebp + 0xc));
    get_sockaddr (eax, esi, eax);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x7c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = connect (eax, esi, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x16fd;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805fb60 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t get_sockaddr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x125d8;
    eax = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = eax;
    edx = *((eax - 4));
    if (dl != 0) {
        if (dl != 1) {
            goto label_0;
        }
    } else {
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        eax = caml_string_length (eax);
        edi = eax;
        *(esi) = 1;
        if (eax > 0x6b) {
            eax = *((ebp - 0x1c));
            eax = ebx - 0x5a4;
            unix_error (0x24, eax, eax);
        }
        eax = eax + 1;
        edx = *((ebp - 0x1c));
        esi += 2;
        memmove (esi, edx, eax);
        edi += 2;
        eax = *((ebp + 0x10));
        *(eax) = edi;
        goto label_0;
    }
    *((ebp - 0x1c)) = eax;
    eax = *(eax);
    eax = caml_string_length (eax);
    if (eax != 0x10) {
        goto label_1;
    }
    edx = esi;
    ecx = 0;
    al = 0;
    do {
        *((edx + eax)) = ecx;
        eax += 4;
    } while (eax < 0x1c);
    *(esi) = 0xa;
    edx = *((ebp - 0x1c));
    eax = *(edx);
    edx = *(eax);
    *((esi + 8)) = edx;
    edx = *((eax + 4));
    *((esi + 0xc)) = edx;
    edx = *((eax + 8));
    *((esi + 0x10)) = edx;
    eax = *((eax + 0xc));
    *((esi + 0x14)) = eax;
    eax = *((edi + 4));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    *((esi + 2)) = ax;
    eax = *((ebp + 0x10));
    *(eax) = 0x1c;
    goto label_0;
label_1:
    *(esi) = 0;
    *((esi + 4)) = 0;
    *((esi + 8)) = 0;
    *((esi + 0xc)) = 0;
    *(esi) = 2;
    edx = *((ebp - 0x1c));
    eax = *(edx);
    eax = *(eax);
    *((esi + 4)) = eax;
    eax = *((edi + 4));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    *((esi + 2)) = ax;
    eax = *((ebp + 0x10));
    *(eax) = 0x10;
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e44 */
#include <stdint.h>
 
void connect (void) {
    connect ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80688cd */
#include <stdint.h>
 
uint32_t caml_ml_input (int32_t arg_8h, void * s1, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    void * s2;
    size_t n;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x40)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    *((ebp - 0x3c)) = esi;
    eax = *((ebx + 0x10));
    esi = *((ebx + 0x14));
    esi -= eax;
    if (*((ebp - 0x3c)) <= esi) {
        edx = *((ebp - 0x3c));
        eax = *((ebp - 0x40));
        eax += *((ebp + 0xc));
        memmove (eax, eax, edx);
        eax = *((ebp - 0x3c));
        *((ebx + 0x10)) += eax;
        esi = eax;
    } else {
        if (esi > 0) {
            eax = *((ebp - 0x40));
            eax += *((ebp + 0xc));
            memmove (eax, eax, esi);
            *((ebx + 0x10)) += esi;
        } else {
            edx = ebx + 0x34;
            *((ebp - 0x44)) = edx;
            eax = *((ebx + 0xc));
            eax -= edx;
            eax = *(ebx);
            eax = caml_do_read (eax, edx, eax);
            esi = eax;
            edx = eax;
            edx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += edx;
            eax = ebx + esi + 0x34;
            *((ebx + 0x14)) = eax;
            if (esi > *((ebp - 0x3c))) {
                esi = *((ebp - 0x3c));
            }
            eax = *((ebp - 0x44));
            eax = *((ebp - 0x40));
            eax += *((ebp + 0xc));
            memmove (eax, eax, esi);
            eax = ebx + esi + 0x34;
            *((ebx + 0x10)) = eax;
        }
    }
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = edi;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054700 */
#include <stdint.h>
 
uint32_t camlList_fold_right2_1128 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        esi = *((ecx + 4));
        ecx = *(ecx);
        edi = *((ebx + 4));
        ecx = *(ebx);
        ebx = edi;
        ecx = esi;
        eax = camlList_fold_right2_1128 (ecx, ecx, eax);
    } while (1);
    ecx = eax;
    eax = *(esp);
    ebx = *((esp + 4));
    edx = *((esp + 8));
    void (*0x804b4f0)() ();
label_0:
    if (ecx == 1) {
        eax = edx;
        return eax;
    }
label_1:
    eax = "List.fold_right2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054760 */
#include <stdint.h>
 
int32_t camlList_for_all_1137 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        if (eax == 1) {
            goto label_1;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_1:
    eax = 1;
    return eax;
label_0:
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068034 */
#include <stdint.h>
 
int32_t caml_array_set_float (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xb;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    ecx = *((ebp + 0x10));
    *(fp_stack--) = *(ecx);
    *((edx + eax*8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b950 */
#include <stdint.h>
 
int32_t camlPrintf_kapr_1209 (void) {
    int32_t var_4h;
    eax = ebx;
    eax = camlPrintf_ac_of_format_1184 (eax, eax);
    ebx = *(eax);
    while (1) {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059b50;
            eax = *(esp);
            *((ecx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ecx + 0x10)) = eax;
            *((ecx + 0x14)) = ebx;
            ebx = 1;
            eax = 1;
            void (*0x8059b50)() ();
            ebx >>= 1;
            /* switch table (12 cases) at 0x8079f94 */
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d400 */
#include <stdint.h>
 
int32_t camlUnix_create_process_1907 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = ebx;
    *(esp) = ecx;
    *((esp + 4)) = edx;
    *((esp + 8)) = esi;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        return eax;
    }
    fcn_0804d450 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d450 */
#include <stdint.h>
 
int32_t fcn_0804d450 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_1ch) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    camlUnix_perform_redirections_1900 (*(obj.caml_exception_pointer));
    eax = *((esp + 0x14));
    eax = *((esp + 0x1c));
    eax = unix_execvp;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d330 */
#include <stdint.h>
 
uint32_t camlUnix_perform_redirections_1900 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    eax = camlUnix_safe_dup_1894 (eax, ebx, ecx);
    eax = *((esp + 4));
    eax = camlUnix_safe_dup_1894 (eax);
    eax = *((esp + 8));
    eax = camlUnix_safe_dup_1894 (eax);
    eax = *(esp);
    camlUnix_safe_close_1898 (eax);
    eax = *((esp + 4));
    camlUnix_safe_close_1898 ();
    eax = *((esp + 8));
    camlUnix_safe_close_1898 ();
    eax = *((esp + 0x10));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x14));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0x10));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x18));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0x14));
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bcc0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2592 (void) {
    eax = unix_getsockname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a240 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1578 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    *(esp) = edx;
    eax = caml_make_vect;
    eax = caml_c_call (7);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0xc));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067376 */
#include <stdint.h>
 
int32_t caml_cosh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    cosh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a7d4 */
#include <stdint.h>
 
void cosh (void) {
    cosh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80548e0 */
#include <stdint.h>
 
int32_t camlList_mem_1161 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80678cb */
#include <stdint.h>
 
int32_t caml_ml_string_length (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    edx = *((eax + edx));
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b0f0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1707 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bf74 */
#include <stdint.h>
 
int32_t caml_set_parser_trace (int32_t arg_8h) {
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    edx = *((ebp + 8));
    edx >>= 1;
    *(obj.caml_parser_trace) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80608ff */
#include <stdint.h>
 
int32_t unix_tcsendbreak (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11841;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcsendbreak ();
    if (eax == -1) {
        eax = ebx - 0x1407;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a814 */
#include <stdint.h>
 
void tcsendbreak (void) {
    tcsendbreak ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80630f4 */
#include <stdint.h>
 
uint32_t caml_fl_merge_block (int32_t arg_8h) {
    int32_t var_20h;
    uint32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    edi = *((ebp + 8));
    eax = edi - 4;
    *((ebp - 0x10)) = eax;
    esi = *(eax);
    eax = *(eax);
    eax >>= 0xa;
    edx = caml_fl_cur_size;
    eax = edx + eax + 1;
    *(obj.caml_fl_cur_size) = eax;
    ebx = caml_fl_merge;
    *((ebp - 0x18)) = ebx;
    ecx = *(ebx);
    *((ebp - 0x14)) = ecx;
    if (*(obj.caml_allocation_policy) == 1) {
        eax = ebx;
        truncate_flp ();
    }
    edx = edi - 4;
    if (edx == *(obj.last_fragment)) {
        ecx = *((ebp - 0x10));
        eax = *(ecx);
        eax >>= 0xa;
        eax++;
        if (eax <= 0x3fffff) {
            esi = eax;
            esi <<= 0xa;
            *((edx - 4)) = esi;
            *(obj.caml_fl_cur_size)++;
        }
    } else {
        edx = edi;
    }
    edi = esi;
    edi >>= 0xa;
    ecx = edx + edi*4;
    eax = *((ebp - 0x14));
    eax -= 4;
    if (eax != ecx) {
        eax = ecx;
    } else {
        ecx = *((ebp - 0x14));
        ecx = *(ecx);
        *((ebp - 0x10)) = ecx;
        ecx = *((ebp - 0x14));
        ecx = *((ecx - 4));
        *((ebp - 0x20)) = ecx;
        ecx >>= 0xa;
        ecx = edi + ecx + 1;
        if (ecx > 0x3fffff) {
            goto label_0;
        }
        edi = *((ebp - 0x10));
        esi = *((ebp - 0x18));
        *(esi) = edi;
        if (*(obj.caml_allocation_policy) == 0) {
            eax = *((ebp - 0x14));
            eax = fl_prev;
            if (*(obj.fl_prev) == eax) {
                eax = ebx;
            }
            *(obj.fl_prev) = eax;
        }
        esi = ecx;
        esi <<= 0xa;
        esi += 0x200;
        *((edx - 4)) = esi;
        eax = esi;
        eax >>= 0xa;
        eax = edx + eax*4;
        ecx = *((ebp - 0x10));
        *((ebp - 0x14)) = ecx;
    }
label_0:
    ecx = ebx - 4;
    edi = *(ecx);
    edi >>= 0xa;
    *((ebp - 0x10)) = edi;
    ebx = ebx + edi*4;
    *((ebp - 0x1c)) = ebx;
    ebx = edx - 4;
    if (*((ebp - 0x1c)) == ebx) {
        ebx = esi;
        ebx >>= 0xa;
        ebx = edi + ebx + 1;
        if (ebx <= 0x3ffffe) {
            ebx <<= 0xa;
            ebx += 0x200;
            *(ecx) = ebx;
        }
    } else {
        ecx = esi;
        ecx >>= 0xa;
        if (ecx != 0) {
            esi &= 0xfffffcff;
            esi |= 0x200;
            *((edx - 4)) = esi;
            esi = *((ebp - 0x14));
            *(edx) = esi;
            edi = *((ebp - 0x18));
            *(edi) = edx;
            *(obj.caml_fl_merge) = edx;
        } else {
            *(obj.last_fragment) = edx;
            *(obj.caml_fl_cur_size)--;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80709cc */
#include <stdint.h>
 
void fini (void) {
    /* [14] -r-x section size 28 named .fini */
    void (*0x80709d8)(uint32_t) (ebx);
    ebx += 0x1774;
    _do_global_dtors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c030 */
#include <stdint.h>
 
int32_t camlUnix_fun_2692 (void) {
    eax = unix_getcwd;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055d70 */
#include <stdint.h>
 
int32_t camlString_lowercase_1098 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_map_1090 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80582f0 */
#include <stdint.h>
 
int32_t camlBuffer_subst_1127 (void) {
    int32_t var_4h_2;
    int32_t var_8h;
    do {
label_0:
        edi = eax;
        eax = *((ecx + 0x18));
        if (ebx >= eax) {
            goto label_1;
        }
        edx = *((ecx + 0x14));
        eax = ebx;
        eax >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        ebp = esi*4 - 1;
        esi = *((edx + ebp));
        ebp -= esi;
        if (ebp <= eax) {
            goto label_2;
        }
        eax = *((edx + eax));
        edx = eax + eax + 1;
        if (edx == 0x49) {
            goto label_3;
        }
        if (edi != 0xb9) {
            goto label_4;
        }
        ebx = 0xb9;
        eax = *((ecx + 0xc));
        camlBuffer_add_char_1072 (edx, ebx, ecx);
        eax = *((esp + 8));
        eax = *((eax + 0xc));
        ebx = *(esp);
        camlBuffer_add_char_1072 ();
        ebx = *((esp + 4));
        ebx += 2;
        eax = 0x41;
        ecx = *((esp + 8));
    } while (1);
label_4:
    if (edx != 0xb9) {
        ebx = edx;
        eax = *((ecx + 0xc));
        camlBuffer_add_char_1072 (ebx, ebx, ecx);
        eax = *((esp + 4));
        ebx = *((esp + 4));
        ebx += 2;
        eax = *(esp);
        ecx = *((esp + 8));
        goto label_0;
    }
    eax = edx;
    ebx += 2;
    goto label_0;
label_3:
    *((esp + 8)) = ecx;
    if (edi == 0xb9) {
        eax = *((ecx + 0xc));
        ebx = edx;
        camlBuffer_add_char_1072 (ebx);
        ebx = *((esp + 4));
        ebx += 2;
        eax = 0x41;
        ecx = *((esp + 8));
        goto label_0;
    }
    ebx += 2;
    edx = *((ecx + 0x18));
    eax = *((ecx + 0x14));
    ecx = edx;
    eax = camlBuffer_find_ident_1114 ();
    ebx = eax;
    eax = *((ebx + 4));
    edx = *(ebx);
    eax = *((esp + 8));
    ebx = *((eax + 0x10));
    ecx = *(ebx);
    eax = edx;
    eax = void (*ecx)(uint32_t) (eax);
    ebx = eax;
    eax = *((esp + 8));
    eax = *((eax + 0xc));
    camlBuffer_add_string_1082 ();
    eax = 0x41;
    ebx = *(esp);
    ecx = *((esp + 8));
    goto label_0;
label_1:
    if (edi == 0xb9) {
        eax = *((ecx + 0xc));
        ebx = edi;
        void (*0x8058770)() ();
    }
    eax = 1;
    return eax;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b5a0 */
#include <stdint.h>
 
uint32_t camlSource_mkmatrix_1030 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 3;
    ecx = ebx;
    ecx += 0xfffffffe;
    ecx = 1;
    eax = camlArray_make_matrix_1042 (eax, ecx);
    *((esp + 4)) = eax;
    edx = 1;
    esi = *(esp);
    esi += 0xfffffffe;
    if (edx > esi) {
        goto label_1;
    }
label_0:
    eax = *((esp + 4));
    ecx = *((eax + edx*2 - 2));
    eax = 1;
    ebx = *((esp + 8));
    if (eax > ebx) {
        goto label_2;
    }
    do {
        edi = *((esp + 0xc));
        *((ecx + eax*2 - 2)) = edi;
        edi += 2;
        *((esp + 0xc)) = edi;
        edi = eax;
        eax += 2;
    } while (edi != ebx);
label_2:
    eax = edx;
    edx += 2;
    if (eax != esi) {
        goto label_0;
    }
label_1:
    eax = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bce0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2596 (void) {
    eax = unix_listen;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c710 */
#include <stdint.h>
 
int32_t camlUnix_recv_1558 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_recv;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.recv";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805db58 */
#include <stdint.h>
 
uint32_t unix_getpeername (int32_t arg_8h) {
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x145e5;
    *((ebp - 0x7c)) = 0x70;
    eax = ebp - 0x7c;
    *((esp + 8)) = eax;
    eax = ebp - 0x78;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getpeername ();
    if (eax == -1) {
        eax = ebx - 0x165f;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x7c));
    eax = ebp - 0x78;
    alloc_sockaddr (eax, eax, 0xffffffff);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a804 */
#include <stdint.h>
 
void getpeername (void) {
    getpeername ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805fd0e */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint32_t alloc_sockaddr (void * arg_8h, void * arg_10h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1242a;
    esi = *((ebp + 8));
    edx = *((ebp + 0x10));
    eax = *(esi);
    if (ax != 2) {
        if (ax != 0xa) {
            if (ax == 1) {
                esi += 2;
                eax = caml_copy_string (esi);
                *((ebp - 0x1c)) = eax;
                esi = *((ebx - 0x18));
                eax = *(esi);
                *((ebp - 0x3c)) = eax;
                eax = ebp - 0x3c;
                *(esi) = eax;
                *((ebp - 0x34)) = 1;
                *((ebp - 0x38)) = 1;
                eax = ebp - 0x1c;
                *((ebp - 0x30)) = eax;
                caml_alloc_small (1, 0);
                edx = *((ebp - 0x1c));
                *(eax) = edx;
                edx = *((ebp - 0x3c));
                *(esi) = edx;
            } else {
                eax = esi + 4;
                eax = alloc_inet_addr (eax);
                *((ebp - 0x1c)) = eax;
                edi = *((ebx - 0x18));
                eax = *(edi);
                *((ebp - 0x3c)) = eax;
                eax = ebp - 0x3c;
                *(edi) = eax;
                *((ebp - 0x34)) = 1;
                *((ebp - 0x38)) = 1;
                eax = ebp - 0x1c;
                *((ebp - 0x30)) = eax;
                caml_alloc_small (2, 1);
                edx = *((ebp - 0x1c));
                *(eax) = edx;
                edx = *((esi + 2));
                dx = rotate_right16 (dx, 8);
                edx = (int32_t) dx;
                edx = edx + edx + 1;
                *((eax + 4)) = edx;
                edx = *((ebp - 0x3c));
                *(edi) = edx;
            } else {
                eax = esi + 8;
            }
            eax = alloc_inet6_addr (eax);
            *((ebp - 0x1c)) = eax;
            edi = *((ebx - 0x18));
            eax = *(edi);
            *((ebp - 0x3c)) = eax;
            eax = ebp - 0x3c;
            *(edi) = eax;
            *((ebp - 0x34)) = 1;
            *((ebp - 0x38)) = 1;
            eax = ebp - 0x1c;
            *((ebp - 0x30)) = eax;
            caml_alloc_small (2, 1);
            edx = *((ebp - 0x1c));
            *(eax) = edx;
            edx = *((esi + 2));
            dx = rotate_right16 (dx, 8);
            edx = (int32_t) dx;
            edx = edx + edx + 1;
            *((eax + 4)) = edx;
            edx = *((ebp - 0x3c));
            *(edi) = edx;
        } else {
        }
        if (edx != -1) {
            close (edx);
        }
        eax = ebx - 0x5a4;
        unix_error (0x61, eax, 0);
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e557 */
#include <stdint.h>
 
int32_t caml_weak_blit (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    int32_t var_4ch;
    int32_t var_30h;
    int32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((ebp - 0x28)) = eax;
    esi = eax;
    esi++;
    if (esi != 0) {
        eax = *((ebp + 0x18));
        eax >>= 1;
        *((ebp - 0x1c)) = eax;
        edi = *((ebp + 8));
        edx = eax;
        edx += esi;
        eax = *((edi - 4));
        eax >>= 0xa;
        if (edx <= eax) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.blit");
label_0:
    eax = *((ebp + 0x14));
    eax >>= 1;
    *((ebp - 0x24)) = eax;
    eax++;
    *((ebp - 0x20)) = eax;
    if (eax != 0) {
        eax = *((ebp - 0x1c));
        eax += *((ebp - 0x20));
        ecx = *((ebp + 0x10));
        edx = *((ecx - 4));
        edx >>= 0xa;
        if (eax <= edx) {
            goto label_1;
        }
    }
    caml_invalid_argument ("Weak.blit");
label_1:
    if (*(obj.caml_gc_phase) != 0) {
        goto label_2;
    }
    if (*(obj.caml_gc_subphase) != 0xb) {
        goto label_2;
    }
    if (*((ebp - 0x1c)) == 0) {
        goto label_2;
    }
    edx = 0;
    eax = 0;
    *((ebp - 0x4c)) = esi;
    do {
        edx += *((ebp - 0x4c));
        edx = edi + edx*4;
        ebx = *(edx);
        ecx = "8!\b\b";
        if (ebx != ecx) {
            if ((bl & 1) != 0) {
                goto label_3;
            }
            *((ebp - 0x30)) = ebx;
            esi = ebx;
            esi >>= 0x17;
            ebx >>= 0xc;
            ebx &= 0x7ff;
            esi = *((esi*4 + obj.caml_page_table));
            if ((*((esi + ebx)) & 1) == 0) {
                goto label_3;
            }
            ebx = *((ebp - 0x30));
            if ((*((ebx - 4)) & 0x300) != 0) {
                goto label_3;
            }
            *(edx) = ecx;
        }
label_3:
        eax++;
        edx = eax;
    } while (*((ebp - 0x1c)) > eax);
    esi = *((ebp - 0x4c));
label_2:
    if (esi <= *((ebp - 0x20))) {
        goto label_4;
    }
    if (*((ebp - 0x1c)) == 0) {
        goto label_5;
    }
    edx = 0;
    ebx = 0;
    do {
        eax = edx + esi;
        ecx = *((edi + eax*4));
        edx += *((ebp - 0x20));
        eax = *((ebp + 0x10));
        do_set ();
        ebx++;
        edx = ebx;
    } while (*((ebp - 0x1c)) > ebx);
    goto label_5;
label_4:
    esi = *((ebp - 0x1c));
    esi--;
    *((ebp - 0x20)) = esi;
    if (esi < 0) {
        goto label_5;
    }
    eax = *((ebp - 0x1c));
    eax += *((ebp - 0x28));
    ebx = edi + eax*4;
    esi = *((ebp - 0x1c));
    esi += *((ebp - 0x24));
    edi = *((ebp - 0x20));
    do {
        ecx = *(ebx);
        edx = esi;
        eax = *((ebp + 0x10));
        do_set ();
        ebx -= 4;
        esi--;
        edi--;
    } while (edi >= 0);
label_5:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066a45 */
#include <stdint.h>
 
int32_t caml_int64_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shrd eax, edx, cl");
    edx >>= cl;
    if ((cl & 0x20) != 0) {
        eax = edx;
        edx = 0;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ff60 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1495 (void) {
    eax = caml_ml_channel_size_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067d42 */
#include <stdint.h>
 
int32_t caml_array_unsafe_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (*((eax - 4)) == 0xfe) {
        caml_array_unsafe_get_float (eax, edx);
    } else {
        edx >>= 1;
        eax = *((eax + edx*4));
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d4a0 */
#include <stdint.h>
 
int32_t camlUnix_create_process_env_1914 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    *((esp + 0xc)) = ecx;
    *(esp) = edx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        return eax;
    }
    fcn_0804d500 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d500 */
#include <stdint.h>
 
int32_t fcn_0804d500 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_1ch, int32_t arg_24h) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    camlUnix_perform_redirections_1900 (*(obj.caml_exception_pointer));
    eax = *((esp + 0x14));
    eax = *((esp + 0x1c));
    eax = *((esp + 0x24));
    eax = unix_execvpe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805beb0 */
#include <stdint.h>
 
int32_t camlPrintf_mkprintf_1345 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    eax = caml_extra_params;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, ecx, edx);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x20f7;
            *(ebx) = sym.caml_curry4;
            *((ebx + 4)) = 9;
            *((ebx + 8)) = 0x805af50;
            eax = *(esp);
            *((ebx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ebx + 0x10)) = eax;
            eax = *((esp + 8));
            *((ebx + 0x14)) = eax;
            eax = *((esp + 0xc));
            *((ebx + 0x18)) = eax;
            *((ebx + 0x1c)) = ecx;
            eax = 1;
            eax = camlPrintf_index_of_int_1037 (ebx);
            ebx = eax;
            eax = *((esp + 0x10));
            ecx = *((esp + 0x14));
            caml_apply2 ();
            ebx = *((esp + 0x18));
            void (*0x805b950)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ce8a */
#include <stdint.h>
 
uint32_t unix_set_nonblock (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x152b1;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 3;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        ah |= 8;
        *((esp + 8)) = eax;
        *((esp + 4)) = 4;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x1695;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80516e0 */
#include <stdint.h>
 
int32_t camlArray_isortto_1209 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h_2;
    int32_t var_18h;
    int32_t var_1ch;
    edi = 1;
    edx += 0xfffffffe;
    if (edi > edx) {
        goto label_5;
    }
    *((esp + 0x10)) = edx;
    *((esp + 0xc)) = edi;
    *((esp + 0x18)) = esi;
    *((esp + 0x14)) = ecx;
    *((esp + 0x1c)) = ebx;
    *(esp) = eax;
label_0:
    eax = *(esp);
    eax = eax + edi - 1;
    *((esp + 4)) = eax;
    ecx = *((esp + 0x18));
    ecx = *((ecx + 0x10));
    edx = *((ecx - 4));
    *((esp + 8)) = edx;
    edx = *((esp + 8));
    edx &= 0xff;
    if (edx != 0xfe) {
        edx = *((esp + 8));
        edx >>= 9;
        if (edx <= eax) {
            goto label_6;
        }
        edx = *((ecx + eax*2 - 2));
        *((esp + 4)) = edx;
    } else {
        edx = *((esp + 8));
        edx >>= 0xa;
        if (edx <= eax) {
            goto label_7;
        }
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_8;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        eax = *((esp + 4));
        *(fp_stack--) = *((ecx + eax*4 - 4));
        *(edx) = fp_stack[0];
        fp_stack--;
        *((esp + 4)) = edx;
    }
label_3:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_9;
    }
    esi = eax + 4;
    *((esp + 8)) = esi;
    *((esi - 4)) = 0x400;
    eax = *((esp + 0x14));
    eax = eax + edi - 3;
    *(esi) = eax;
    do {
        ecx = *(esi);
        eax = *((esp + 0x14));
        if (ecx < eax) {
            goto label_10;
        }
        ecx = *(esi);
        eax = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_11;
            }
            eax = *((ebx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_12;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 0x18));
        ecx = *((ebx + 0xc));
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        if (eax <= 1) {
            goto label_10;
        }
        esi = *((esp + 8));
        ecx = *(esi);
        ebx = *((esp + 0x1c));
        eax = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_14;
            }
            edx = *((ebx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_15;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *(esi);
        eax += 2;
        ecx = *((ebx - 4));
        edi = *((ebx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            ecx >>= 9;
            if (ecx <= eax) {
                goto label_17;
            }
            eax = caml_modify (ebx + eax*2 - 2, edx);
        } else {
            ecx >>= 0xa;
            if (ecx <= eax) {
                goto label_18;
            }
            *(fp_stack--) = *(edx);
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        *(esi) += 0xfffffffe;
    } while (1);
label_10:
    eax = *((esp + 8));
    eax = *(eax);
    eax += 2;
    ebx = *((esp + 0x1c));
    ecx = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_19;
        }
        ecx = *((esp + 4));
        eax = caml_modify (ebx + eax*2 - 2, ecx);
    } else {
        ecx >>= 0xa;
        if (ecx <= eax) {
            goto label_20;
        }
        ecx = *((esp + 4));
        *(fp_stack--) = *(ecx);
        *((ebx + eax*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    edi = *((esp + 0xc));
    ecx = *((esp + 0xc));
    edi += 2;
    *((esp + 0xc)) = edi;
    eax = *((esp + 0x10));
    if (ecx != eax) {
        goto label_0;
    }
label_5:
    eax = 1;
    return eax;
label_16:
    caml_call_gc ();
    goto label_1;
label_13:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_8:
    caml_call_gc ();
    goto label_4;
label_20:
    caml_ml_array_bound_error ();
label_19:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060728 */
#include <stdint.h>
 
uint32_t unix_string_of_inet_addr (int32_t arg_8h) {
    int32_t var_48h;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x11a17;
    esi = *((ebp + 8));
    eax = caml_string_length (esi);
    if (eax == 0x10) {
        *((esp + 0xc)) = 0x40;
        eax = ebp - 0x48;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 0xa;
        inet_ntop ();
    } else {
        *((esp + 0xc)) = 0x40;
        eax = ebp - 0x48;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 2;
        eax = inet_ntop ();
    }
    if (eax == 0) {
        eax = ebx - 0x143a;
        eax = uerror (eax, 0);
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068d55 */
#include <stdint.h>
 
uint32_t caml_ml_input_int (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_getword (ebx);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066e70 */
#include <stdint.h>
 
int32_t caml_int32_mod (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            caml_copy_int32 (0);
        }
    } else {
        eax = edx;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        caml_copy_int32 (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be70 */
#include <stdint.h>
 
int32_t camlUnix_fun_2642 (void) {
    eax = unix_getitimer;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b1d0 */
#include <stdint.h>
 
int32_t caml_curry5_4 (void) {
    esi = eax;
    ecx = *((ebx + 0xc));
    eax = *((ecx + 0xc));
    ebp = *((eax + 0xc));
    edi = *((ebp + 0xc));
    edx = *((ebx + 8));
    ecx = *((ecx + 8));
    ebx = *((eax + 8));
    eax = *((ebp + 8));
    ebp = *((edi + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c98a */
#include <stdint.h>
 
int32_t caml_gc_minor (void) {
    caml_minor_collection ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066fac */
#include <stdint.h>
 
int32_t caml_neq_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] != fp_stack[1]) ? 1 : 0;
    __asm ("setp dl");
    eax |= edx;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c300 */
#include <stdint.h>
 
int32_t camlUnix_fun_2772 (void) {
    eax = unix_execve;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c760 */
#include <stdint.h>
 
int32_t camlUnix_recvfrom_1564 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_recvfrom;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.recvfrom";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80667b4 */
#include <stdint.h>
 
int32_t caml_nativeint_neg (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = -eax;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053430 */
#include <stdint.h>
 
int32_t camlList_nth_aux_1045 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 4));
        eax = *(eax);
        if (ebx == 1) {
            return eax;
        }
        ebx += 0xfffffffe;
        eax = ecx;
    } while (1);
label_0:
    eax = loc.camlList__53;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f5e0 */
#include <stdint.h>
 
int32_t camlPervasives_failwith_1010 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Failure;
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d988 */
#include <stdint.h>
 
void unix_gethostname (void) {
    int32_t var_48h;
    int32_t var_9h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x147b3;
    *((esp + 4)) = 0x40;
    esi = ebp - 0x48;
    *(esp) = esi;
    gethostname ();
    *((ebp - 9)) = 0;
    caml_copy_string (esi);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a5f4 */
#include <stdint.h>
 
void gethostname (void) {
    gethostname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80627f0 */
#include <stdint.h>
 
int32_t caml_record_signal (int32_t arg_8h) {
    eax = *((ebp + 8));
    *((eax*4 + obj.caml_pending_signals)) = 1;
    *(obj.caml_signals_are_pending) = 1;
    eax = caml_young_end;
    *(obj.caml_young_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80573b0 */
#include <stdint.h>
 
int32_t camlHashtbl_create_1051 (void) {
    ebx = eax;
    eax = 3;
    camlPervasives_max_1025 ();
    ebx = .comment;
    eax = camlPervasives_min_1022 ();
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = 1;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f6a0 */
#include <stdint.h>
 
int32_t camlPervasives_max_1025 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_greaterequal;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f660 */
#include <stdint.h>
 
int32_t camlPervasives_min_1022 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_lessequal;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066566 */
#include <stdint.h>
 
int32_t caml_int32_float_of_bits (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c670 */
#include <stdint.h>
 
int32_t camlUnix_pause_1408 (void) {
    eax = unix_sigprocmask;
    eax = caml_c_call (3);
    eax = unix_sigsuspend;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067bb7 */
#include <stdint.h>
 
int32_t caml_create_string (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    if (eax > 0xfffffb) {
        eax = caml_invalid_argument ("String.create");
    }
    caml_alloc_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061bd1 */
#include <stdint.h>
 
int32_t caml_invalid_argument (void) {
    int32_t var_4h_5;
    int32_t var_4h_4;
    eax = *((ebp + 8));
    return caml_raise_with_string (loc.caml_exn_Invalid_argument, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bf52 */
#include <stdint.h>
 
uint32_t caml_sys_io_error (int32_t arg_8h) {
    eax = errno_location ();
    if (*(eax) == 0xb) {
        caml_raise_sys_blocked_io ();
    }
    eax = *((ebp + 8));
    return caml_sys_error (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061c75 */
#include <stdint.h>
 
void caml_raise_sys_blocked_io (void) {
    return caml_raise_constant (loc.caml_exn_Sys_blocked_io);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c010 */
#include <stdint.h>
 
int32_t camlPrintf_eprintf_1395 (void) {
    eax = .comment;
    eax = camlPrintf_fprintf_1391 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067302 */
#include <stdint.h>
 
int32_t caml_acos_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    acos (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a364 */
#include <stdint.h>
 
void acos (void) {
    acos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c4b0 */
#include <stdint.h>
 
int32_t camlUnix_read_1237 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_read;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.read";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dea0 */
#include <stdint.h>
 
uint32_t unix_gettimeofday (void) {
    int32_t var_10h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x142a0;
    *((esp + 4)) = 0;
    eax = ebp - 0x10;
    *(esp) = eax;
    eax = gettimeofday ();
    if (eax == -1) {
        eax = ebx - 0x1653;
        uerror (eax, 0);
    }
    *(fp_stack--) = *((ebp - 0x10));
    *(fp_stack--) = *((ebp - 0xc));
    fp_stack[0] /= *((ebx - 0x1644));
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a164 */
#include <stdint.h>
 
void gettimeofday (void) {
    gettimeofday ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058ca0 */
#include <stdint.h>
 
int32_t camlBuffer_entry (void) {
    eax = loc.camlBuffer__20;
    *(loc.camlBuffer) = eax;
    eax = loc.camlBuffer__19;
    *(0x8078ee4) = eax;
    eax = loc.camlBuffer__18;
    *(0x8078ee8) = eax;
    eax = loc.camlBuffer__17;
    *(0x8078eec) = eax;
    eax = loc.camlBuffer__16;
    *(0x8078ef0) = eax;
    eax = loc.camlBuffer__15;
    *(0x8078ef4) = eax;
    eax = loc.camlBuffer__14;
    *(0x8078ef8) = eax;
    eax = loc.camlBuffer__13;
    *(0x8078efc) = eax;
    eax = loc.camlBuffer__12;
    *(0x8078f1c) = eax;
    eax = loc.camlBuffer__11;
    *(0x8078f00) = eax;
    eax = loc.camlBuffer__10;
    *(0x8078f08) = eax;
    eax = loc.camlBuffer__9;
    *(0x8078f04) = eax;
    eax = loc.camlBuffer__8;
    *(0x8078f10) = eax;
    eax = loc.camlBuffer__7;
    *(0x8078f14) = eax;
    eax = loc.camlBuffer__6;
    *(0x8078f18) = eax;
    eax = loc.camlBuffer__5;
    *(0x8078f20) = eax;
    eax = loc.camlBuffer__4;
    *(0x8078f24) = eax;
    eax = loc.camlBuffer__3;
    *(0x8078f28) = eax;
    eax = loc.camlBuffer__2;
    *(0x8078f2c) = eax;
    eax = camlBuffer__1;
    *(0x8078f0c) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066f0d */
#include <stdint.h>
 
int32_t caml_int32_sub (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = *((ebp + 0xc));
    eax -= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c1e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2742 (void) {
    eax = unix_lseek;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067ffb */
#include <stdint.h>
 
int32_t caml_array_unsafe_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((ebp + 0x10));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_unsafe_set_float (eax, edx, ecx);
    } else {
        caml_array_unsafe_set_addr (eax, edx, ecx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bea0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2646 (void) {
    eax = unix_times;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f371 */
#include <stdint.h>
 
int32_t unix_sendto (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12dcf;
    eax = *((ebp + 8));
    edx = *((eax + 0x14));
    edx = *((eax + 0x10));
    edx = *((eax + 0xc));
    edx = *((eax + 8));
    edx = *((eax + 4));
    eax = *(eax);
    unix_sendto_native (edx, edx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f280 */
#include <stdint.h>
 
uint32_t unix_sendto_native (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, int32_t arg_sp_10h, int32_t arg_sp_14h) {
    int32_t var_40a0h;
    int32_t var_409ch;
    int32_t var_408ch;
    int32_t var_4088h;
    void * s1;
    void * s2;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x12ebb;
    eax = ebx + 0x91e4;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x40a0)) = eax;
    eax = ebp - 0x408c;
    esi = ebp - 0x4088;
    eax = *((ebp + 0x1c));
    get_sockaddr (eax, esi, eax);
    edi = *((ebp + 0x14));
    edi >>= 1;
    eax = 0x4000;
    if (edi > 0x4000) {
        edi = eax;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    eax = ebp - 0x4018;
    *((ebp - 0x409c)) = eax;
    memmove (eax, eax, edi);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x408c));
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = esi;
    eax = *((ebp - 0x40a0));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = edi;
    eax = *((ebp - 0x409c));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = sendto ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x156d;
        uerror (eax, 0);
    }
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a014 */
#include <stdint.h>
 
void sendto (void) {
    sendto ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057460 */
#include <stdint.h>
 
int32_t camlHashtbl_copy_1057 (void) {
    eax = *((eax + 4));
    eax = camlArray_copy_1049 (eax);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            ebx = *(ebx);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067934 */
#include <stdint.h>
 
int32_t caml_string_notequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_equal (eax, eax);
    edx = 4;
    edx -= eax;
    eax = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058610 */
#include <stdint.h>
 
int32_t camlBuffer_length_1060 (void) {
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80542d0 */
#include <stdint.h>
 
int32_t camlList_hd_1036 (void) {
    if (eax != 1) {
        eax = *(eax);
        return eax;
    }
    eax = loc.camlList__51;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d5e0 */
#include <stdint.h>
 
int32_t unix_getgrgid (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14b60;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getgrgid ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_group_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a644 */
#include <stdint.h>
 
void getgrgid (void) {
    getgrgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f399 */
#include <stdint.h>
 
int32_t caml_final_do_weak_roots (int32_t arg_8h) {
    int32_t var_4h;
    edi = *((ebp + 8));
    if (*(obj.old) == 0) {
        goto label_0;
    }
    ebx = 0;
    esi = 0;
    do {
        eax = ebx;
        eax += *(obj.final_table);
        edx = eax + 4;
        eax = *((eax + 4));
        void (*edi)(uint32_t, uint32_t) (eax, edx);
        esi++;
        ebx += 0xc;
    } while (*(obj.old) > esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80534d0 */
#include <stdint.h>
 
int32_t camlList_rmap2_f_1103 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (ebx == 1) {
            goto label_1;
        }
        if (ecx == 1) {
            goto label_2;
        }
        eax = *((ecx + 4));
        esi = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *((edx + 0xc));
        ebx = esi;
        eax = caml_apply2 (edx, eax, eax);
        ebx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        ebx = *(esp);
        *((eax + 4)) = ebx;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        edx = *((esp + 0xc));
    } while (1);
label_1:
    if (ecx == 1) {
        return eax;
    }
label_2:
    eax = "List.rev_map2";
    void (*0x804f620)() ();
label_3:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c210 */
#include <stdint.h>
 
int32_t camlUnix_fun_2746 (void) {
    eax = caml_channel_descriptor;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e9e0 */
#include <stdint.h>
 
int32_t unix_mkfifo (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1375b;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = mkfifo ();
    if (eax == -1) {
        eax = ebx - 0x15c6;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a4a4 */
#include <stdint.h>
 
void mkfifo (void) {
    mkfifo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c9f0 */
#include <stdint.h>
 
int32_t unix_dup (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15750;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = dup ();
    if (eax == -1) {
        eax = ebx - 0x16f5;
        uerror (eax, 0);
    }
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a334 */
#include <stdint.h>
 
void dup (void) {
    dup ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061cc0 */
#include <stdint.h>
 
int32_t caml_do_local_roots (void) {
    int32_t var_24h_4;
    int32_t var_20h_4;
    uint32_t var_1ch_4;
    int32_t var_8h_2;
    int32_t var_ch_4;
    int32_t var_10h_2;
    int32_t var_14h;
    uint32_t var_18h_2;
    int32_t var_4h_8;
    eax = *((ebp + 0xc));
    if (eax != 0) {
        edx = *((ebp + 0x14));
        *((ebp - 0x20)) = edx;
        edx = *((ebp + 0x10));
        *((ebp - 0x1c)) = eax;
    } else {
label_1:
        if (*((ebp + 0x18)) == 0) {
            goto label_6;
        }
        esi = *((ebp + 0x18));
        *((ebp - 0x1c)) = 0;
        goto label_7;
    }
label_0:
    esi = caml_frame_descriptors_mask;
    eax = edx;
    eax >>= 3;
    eax &= esi;
    ecx = caml_frame_descriptors;
    ebx = *((ecx + eax*4));
    if (*(ebx) == edx) {
        goto label_8;
    }
    do {
        eax++;
        eax &= esi;
        ebx = *((ecx + eax*4));
    } while (*(ebx) != edx);
label_8:
    if (*((ebx + 4)) == 0xffff) {
        goto label_9;
    }
    esi = *((ebx + 6));
    if (esi <= 0) {
        goto label_10;
    }
    edi = ebx + 8;
    *((ebp - 0x24)) = ebx;
    ebx = *((ebp + 8));
    do {
        eax = *(edi);
        if ((al & 1) != 0) {
            eax >>= 1;
            edx = *((ebp - 0x20));
            eax = edx + eax*4;
        } else {
            eax += *((ebp - 0x1c));
        }
        eax = *(eax);
        void (*ebx)(uint32_t, uint32_t) (eax, eax);
        esi--;
        if (esi <= 0) {
            goto label_11;
        }
        edi += 2;
    } while (1);
label_11:
    ebx = *((ebp - 0x24));
label_10:
    eax = *((ebx + 4));
    eax &= 0xfffc;
    *((ebp - 0x1c)) += eax;
    eax = *((ebp - 0x1c));
    edx = *((eax - 4));
    goto label_0;
label_9:
    eax = *((ebp - 0x1c));
    eax += 8;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    edx = *((eax + 4));
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    if (*((ebp - 0x1c)) != 0) {
        goto label_0;
    }
    goto label_1;
    do {
label_2:
        eax = ebx*4;
        eax += *((esi + edi*4 + 0xc));
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
    } while (*((esi + 8)) > ebx);
label_3:
    edi++;
    if (*((esi + 4)) <= edi) {
        goto label_5;
    }
label_4:
    ebx = *((ebp - 0x1c));
    if (*((esi + 8)) > 0) {
        goto label_2;
    }
    goto label_3;
label_5:
    esi = *(esi);
    if (esi == 0) {
        goto label_6;
    }
label_7:
    edi = 0;
    if (*((esi + 4)) > 0) {
        goto label_4;
    }
    goto label_5;
label_6:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806773b */
#include <stdint.h>
 
uint32_t caml_float_of_string (int32_t arg_8h) {
    int32_t var_8h_2;
    uint32_t var_5ch_2;
    int32_t var_58h_2;
    char * * endptr;
    int32_t var_58h;
    esi = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    ebx = eax;
    edi = ebp - 0x58;
    if (eax > 0x3f) {
        eax = eax + 1;
        eax = caml_stat_alloc (eax);
        edi = eax;
    }
    eax = esi;
    esi = edi;
    while (ebx != 0) {
        edx = *(eax);
        if (dl != 0x5f) {
            *(esi) = dl;
            esi++;
        }
        eax++;
        ebx--;
    }
    *(esi) = 0;
    if (esi != edi) {
        eax = ebp - 0x5c;
        strtod (edi, eax);
        *((ebp - 0x70)) = fp_stack[0];
        fp_stack--;
        if (*((ebp - 0x5c)) != esi) {
            goto label_0;
        }
        eax = ebp - 0x58;
        if (edi != eax) {
            caml_stat_free (edi);
        }
        *(fp_stack--) = *((ebp - 0x70));
        *(esp) = fp_stack[0];
        fp_stack--;
        caml_copy_double ();
        return eax;
    }
label_0:
    eax = ebp - 0x58;
    if (edi != eax) {
        caml_stat_free (edi);
    }
    return caml_failwith ("float_of_string");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056230 */
#include <stdint.h>
 
int32_t camlSys_catch_break_1082 (void) {
    while (1) {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x400;
            *(ebx) = loc.camlSys__5;
            eax = 0xfffffff5;
            void (*0x8056210)() ();
            ebx = 1;
            eax = 0xfffffff5;
            void (*0x8056210)() ();
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f2a0 */
#include <stdint.h>
 
int32_t camlPervasives_scan_1249 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
        *((esp + 0x10)) = eax;
        *((esp + 0xc)) = ebx;
        *((esp + 4)) = ecx;
        eax = caml_ml_input_scan_line;
        eax = caml_c_call (*((ecx + 0xc)));
        if (eax == 1) {
            eax = *((esp + 0x10));
            if (eax != 1) {
                *((esp + 0x10)) = eax;
                eax = *((esp + 0xc));
                eax = caml_create_string;
                caml_c_call (eax);
                ebx = *((esp + 0xc));
                ecx = *((esp + 0x10));
                void (*0x804f250)() ();
            }
label_2:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_End_of_file;
            eax = caml_raise_exn ();
        }
        *((esp + 8)) = eax;
        if (eax > 1) {
            eax += 0xfffffffe;
            eax = caml_create_string;
            eax = caml_c_call (eax);
            *(esp) = eax;
            ebx = *((esp + 8));
            ebx += 0xfffffffe;
            eax = *((esp + 0x10));
            eax = caml_ml_input;
            caml_c_call (*((eax + 0xc)));
            eax = *((esp + 4));
            eax = caml_ml_input_char;
            caml_c_call (*((eax + 0xc)));
            ecx = *((esp + 0x10));
            if (ecx != 1) {
                ebx = *((esp + 8));
                eax = *((esp + 0xc));
                edx = eax + ebx - 3;
                *((esp + 4)) = edx;
label_1:
                eax = caml_young_ptr;
                eax -= 0xc;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_4;
                }
                ebx = eax + 4;
                *((esp + 8)) = ebx;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = caml_create_string;
                caml_c_call (edx);
                ebx = *((esp + 4));
                ecx = *((esp + 8));
                void (*0x804f250)() ();
            }
            eax = *(esp);
            return eax;
        }
        ebx = 2;
        ebx -= eax;
        eax = caml_create_string;
        eax = caml_c_call (ebx);
        *(esp) = eax;
        ecx = 2;
        ebx = *((esp + 8));
        ecx -= ebx;
        eax = *((esp + 0x10));
        eax = caml_ml_input;
        caml_c_call (*((eax + 0xc)));
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 0x10));
        *((eax + 4)) = ebx;
        ebx = *((esp + 0xc));
        ecx = *((esp + 8));
        ebx -= ecx;
        ebx++;
        ecx = *((esp + 4));
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cb3c */
#include <stdint.h>
 
int32_t unix_execve (void) {
    int32_t var_ch_2;
    int32_t var_8h_2;
    int32_t var_4h_2;
    int32_t var_ch_3;
    int32_t var_10h;
    int32_t var_sp_8h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x155fc;
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    eax = *((ebp + 0x10));
    eax = cstringvect (eax);
    edi = eax;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    eax = *((ebp + 8));
    *(esp) = eax;
    execve ();
    caml_stat_free (esi);
    caml_stat_free (edi);
    eax = *((ebp + 8));
    eax = ebx - 0x16e6;
    return uerror (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064a64 */
#include <stdint.h>
 
int32_t caml_allocation_color (int32_t arg_8h) {
    eax = caml_gc_phase;
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
        eax = *((ebp + 8));
        if (eax < *(obj.caml_gc_sweep_hp)) {
            goto label_0;
        }
    }
    eax = 0x300;
    goto label_1;
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c0b0 */
#include <stdint.h>
 
uint32_t camlPrintf_get_buff_1402 (void) {
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax*4 + 1;
    return camlBuffer_create_1039 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066c61 */
#include <stdint.h>
 
int32_t caml_int64_sub (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    ebx = *((eax + 8));
    edx = *((ebp + 0xc));
    esi = ecx;
    edi = ebx;
    esi -= *((edx + 4));
    edi -= *((edx + 8));
    caml_copy_int64 (esi, edi);
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bca0 */
#include <stdint.h>
 
int32_t camlPrintf_next_index_1262 (void) {
    if (eax != 1) {
        eax = ebx;
        return eax;
    }
    edx = *((ecx + 8));
    ecx = *(edx);
    eax = ebx;
    ebx = edx;
    return void (*0x8079590)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bbc0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2562 (void) {
    eax = unix_setsid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c8db */
#include <stdint.h>
 
int32_t caml_gc_full_major (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Full major GC cycle requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f250 */
#include <stdint.h>
 
int32_t camlPervasives_build_result_1243 (void) {
    do {
        edi = eax;
        if (ecx == 1) {
            goto label_0;
        }
        ebp = *((ecx + 4));
        eax = *(ecx);
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        ecx = ebx;
        ecx -= esi;
        ecx++;
        caml_blit_string (eax, 1, edi, ecx, ecx + ecx + 1);
        ebx -= esi;
        ebx++;
        eax = edi;
        ecx = ebp;
    } while (1);
label_0:
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070800 */
#include <stdint.h>
 
int32_t udivdi3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_18h;
    uint32_t var_14h;
    uint32_t var_10h;
    uint32_t var_ch;
    eax = *((ebp + 0x14));
    edx = *((ebp + 8));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0xc));
    *((ebp - 0x10)) = edx;
    if (eax == 0) {
        if (esi > edi) {
            goto label_1;
        }
        if (esi == 0) {
            eax = 1;
            edx = 0;
            eax = edx:eax / esi;
            edx = edx:eax % esi;
            esi = eax;
        }
        ecx = *((ebp - 0x10));
        edx = 0;
        eax = edi;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        edi = eax;
        eax = ecx;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
        edx = edi;
        eax = ecx;
        return eax;
    }
    if (eax <= edi) {
        __asm ("bsr edx, eax");
        edx ^= 0x1f;
        *((ebp - 0xc)) = edx;
        if (eax != edi) {
            goto label_2;
        }
        if (esi <= *((ebp - 0x10))) {
            goto label_3;
        }
        if (eax < edi) {
            goto label_3;
        }
    }
    edi = 0;
    ecx = 0;
    do {
label_0:
        eax = ecx;
        edx = edi;
        return eax;
label_1:
        ecx = edx;
        edx = edi;
        eax = ecx;
        edi = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
        edx = edi;
        eax = ecx;
        return eax;
label_2:
        ecx = *((ebp - 0xc));
        edx = esi;
        eax <<= cl;
        *((ebp - 0x14)) = eax;
        eax = 0x20;
        eax -= *((ebp - 0xc));
        ecx = eax;
        edx >>= cl;
        ecx = *((ebp - 0xc));
        edx |= *((ebp - 0x14));
        esi <<= cl;
        ecx = eax;
        *((ebp - 0x18)) = esi;
        esi = edi;
        esi >>= cl;
        ecx = *((ebp - 0xc));
        *((ebp - 0x14)) = edx;
        edx = *((ebp - 0x10));
        edi <<= cl;
        ecx = eax;
        edx >>= cl;
        edi |= edx;
        edx = esi;
        eax = edi;
        eax = *(edx:eax) / ebp - 0x14;
        edx = *(edx:eax) % ebp - 0x14;
        esi = edx;
        edi = eax;
        edx:eax = eax * *((ebp - 0x18));
        *((ebp - 0x14)) = edx;
        if (esi < edx) {
            goto label_4;
        }
        edx = *((ebp - 0x10));
        ecx = *((ebp - 0xc));
        edx <<= cl;
        if (edx < eax) {
            if (esi == *((ebp - 0x14))) {
                goto label_4;
            }
        }
        ecx = edi;
        edi = 0;
    } while (1);
label_3:
    edi = 0;
    ecx = 1;
    goto label_0;
label_4:
    ecx = edi - 1;
    edi = 0;
    eax = ecx;
    edx = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806439c */
#include <stdint.h>
 
uint32_t caml_oldify_one (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_24h;
    uint32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
label_0:
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    do {
label_1:
        if ((bl & 1) != 0) {
            goto label_2;
        }
        if (ebx >= *(obj.caml_young_end)) {
            goto label_2;
        }
        if (ebx <= *(obj.caml_young_start)) {
            goto label_2;
        }
        esi = ebx;
        eax = ebx - 4;
        *((ebp - 0x1c)) = eax;
        edx = *(eax);
        if (edx == 0) {
            eax = *(ebx);
            *(edi) = eax;
            goto label_3;
        }
        eax = (int32_t) dl;
        if (eax > 0xf8) {
            goto label_4;
        }
        esi = edx;
        esi >>= 0xa;
        eax = caml_alloc_shr (esi, eax);
        *(edi) = eax;
        edx = *(ebx);
        ecx = *((ebp - 0x1c));
        *(ecx) = 0;
        *(ebx) = eax;
        if (esi > 1) {
            *(eax) = edx;
            edx = oldify_todo_list;
            *((eax + 4)) = edx;
            *(obj.oldify_todo_list) = ebx;
            goto label_3;
        }
        edi = eax;
        ebx = edx;
    } while (1);
label_4:
    if (eax <= 0xfa) {
        goto label_5;
    }
    edx >>= 0xa;
    *((ebp - 0x20)) = edx;
    eax = caml_alloc_shr (edx, eax);
    if (*((ebp - 0x20)) == 0) {
        goto label_6;
    }
    edx = 0;
    *((ebp - 0x24)) = ebx;
    ebx = *((ebp - 0x20));
    do {
        ecx = *((esi + edx*4));
        *((eax + edx*4)) = ecx;
        edx++;
    } while (ebx > edx);
    ebx = *((ebp - 0x24));
label_6:
    edx = *((ebp - 0x1c));
    *(edx) = 0;
    *(ebx) = eax;
    *(edi) = eax;
    goto label_3;
label_5:
    if (eax == 0xf9) {
        edx >>= 0xa;
        ebx = edx*4;
        esi -= ebx;
        caml_oldify_one (esi, edi);
        goto label_0;
        *(edi) += ebx;
        goto label_3;
    }
    esi = ebx;
    ebx = *(ebx);
    if ((bl & 1) != 0) {
        goto label_1;
    }
    ecx = ebx;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 7) == 0) {
        goto label_7;
    }
    ecx -= 4;
    eax = ecx;
    if (*(ecx) == 0) {
        eax = *(ebx);
        eax -= 4;
    }
    eax = *(eax);
    if (eax == 0xfa) {
        goto label_7;
    }
    if (eax == 0xf6) {
        goto label_7;
    }
    if (eax != 0xfd) {
        goto label_1;
    }
label_7:
    eax = caml_alloc_shr (1, 0xfa);
    *(edi) = eax;
    ecx = *((ebp - 0x1c));
    *(ecx) = 0;
    *(esi) = eax;
    edi = eax;
    goto label_1;
label_2:
    *(edi) = ebx;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051f50 */
#include <stdint.h>
 
int32_t camlArray_concat_aux_1062 (void) {
    int32_t var_4h;
    eax = loc.camlArray__30;
    eax = 1;
    eax = camlArray_size_1065 (eax, ebx);
    ebx = *(esp);
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80507b0;
            *((ecx + 0xc)) = ebx;
            eax = 1;
            ebx = *((esp + 4));
            camlArray_fill_1070 ();
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068edf */
#include <stdint.h>
 
int32_t caml_ml_output (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_local_roots;
    *((ebp - 0x3c)) = eax;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    edi = *((eax + 4));
    esi = *((ebp + 0x10));
    ebx = *((ebp + 0x14));
    ebx >>= 1;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (edi);
    }
    if (ebx <= 0) {
        goto label_0;
    }
    esi >>= 1;
    do {
        eax = esi;
        eax += *((ebp + 0xc));
        eax = caml_putblock (edi, eax, ebx);
        esi += eax;
        ebx -= eax;
    } while (ebx > 0);
label_0:
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (edi);
    }
    eax = *((ebp - 0x3c));
    *(obj.caml_local_roots) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062842 */
#include <stdint.h>
 
int32_t caml_urge_major_slice (void) {
    *(obj.caml_force_major_slice) = 1;
    eax = caml_young_end;
    *(obj.caml_young_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806141d */
#include <stdint.h>
 
int32_t unix_write (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t fd;
    void * s1;
    int32_t var_4040h;
    int32_t var_403ch;
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    int32_t var_4018h;
    char * ptr;
    size_t nbytes;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x10d1e;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    if (esi <= 0) {
        goto label_0;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x403c)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0x4048)) = eax;
    *((ebp - 0x4040)) = 0;
    eax = ebp - 0x4018;
    *((ebp - 0x4044)) = eax;
    do {
        edi = 0x4000;
        if (esi <= 0x4000) {
            edi = esi;
        }
        eax = *((ebp - 0x403c));
        eax += *((ebp + 0xc));
        edx = *((ebp - 0x4044));
        memmove (edx, eax, edi);
        caml_enter_blocking_section ();
        eax = *((ebp - 0x4044));
        edx = *((ebp - 0x4048));
        eax = write (edx, eax, edi);
        edi = eax;
        caml_leave_blocking_section ();
        if (edi == -1) {
            esi = *((ebp - 0x4040));
            eax = errno_location ();
            if (*(eax) == 0xb) {
                if (esi > 0) {
                    goto label_1;
                }
            }
            eax = ebx - 0x1282;
            uerror (eax, 0);
        }
        *((ebp - 0x4040)) += edi;
        esi -= edi;
        if (esi <= 0) {
            goto label_1;
        }
        *((ebp - 0x403c)) += edi;
    } while (1);
label_0:
    *((ebp - 0x4040)) = 0;
label_1:
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    edx = *((ebp - 0x4040));
    eax = edx + edx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c550 */
#include <stdint.h>
 
int32_t camlUnix_single_write_1247 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_single_write;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.single_write";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054bb0 */
#include <stdint.h>
 
int32_t camlList_remove_assq_1195 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        edx = *(ebx);
        ecx = *(edx);
        if (ecx == eax) {
            eax = esi;
            return eax;
        }
        ebx = esi;
        eax = camlList_remove_assq_1195 (edx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f5b0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1420 (void) {
    eax = caml_ml_output_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80542a0 */
#include <stdint.h>
 
int32_t camlList_length_aux_1030 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 2;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806493a */
#include <stdint.h>
 
int32_t caml_realloc_ref_table (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * size;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *(ebx);
    if (edi == 0) {
        eax = caml_minor_heap_size;
        eax >>= 5;
        caml_alloc_table (ebx, eax, 0x100);
    } else {
        eax = *((ebx + 0x10));
        if (eax == *((ebx + 8))) {
            caml_gc_message (8, "ref_table threshold crossed\n", 0);
            eax = *((ebx + 4));
            *((ebx + 0x10)) = eax;
            caml_urge_major_slice ();
        } else {
            eax = *((ebx + 0xc));
            *((ebp - 0x1c)) = eax;
            esi = *((ebx + 0x14));
            esi += esi;
            *((ebx + 0x14)) = esi;
            esi += *((ebx + 0x18));
            esi <<= 2;
            eax = esi + 0x3ff;
            __asm ("cmovns eax, esi");
            eax >>= 0xa;
            caml_gc_message (8, "Growing ref_table to %ldk bytes\n", eax);
            eax = *(ebx);
            eax = realloc (eax, esi);
            *(ebx) = eax;
            if (eax == 0) {
                eax = caml_fatal_error ("Fatal error: ref_table overflow\n");
            }
            ecx = *((ebx + 0x14));
            edx = *((ebx + 0x18));
            edx += ecx;
            edx = eax + edx*4;
            *((ebx + 4)) = edx;
            ecx = eax + ecx*4;
            *((ebx + 8)) = ecx;
            ecx = *((ebp - 0x1c));
            ecx -= edi;
            edi = ecx;
            edi &= 0xfffffffc;
            eax += edi;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = edx;
        }
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e0a9 */
#include <stdint.h>
 
int32_t caml_fatal_uncaught_exception (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * format;
    char ** var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    eax = caml_format_exception (eax);
    ebx = eax;
    esi = caml_backtrace_active;
    edi = caml_backtrace_pos;
    *(obj.caml_backtrace_active) = 0;
    eax = caml_named_value ("Pervasives.do_at_exit");
    if (eax != 0) {
        eax = *(eax);
        caml_callback_exn (eax, 1);
    }
    *(obj.caml_backtrace_active) = esi;
    *(obj.caml_backtrace_pos) = edi;
    *((esp + 8)) = ebx;
    eax = stderr;
    fprintf (eax, "Fatal error: exception %s\n");
    free (ebx);
    if (*(obj.caml_backtrace_active) != 0) {
        caml_print_exception_backtrace ();
    }
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055450 */
#include <stdint.h>
 
int32_t camlChar_compare_1048 (void) {
    eax -= ebx;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056de0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_1198 (void) {
    int32_t var_4h_5;
    int32_t var_8h_3;
    int32_t var_ch_2;
    edx = *((eax + 4));
    edx = *((edx - 4));
    edx >>= 0xa;
    if (edx != 0) {
        eax = *((ecx + 0x10));
        eax = *((eax + 8));
        edx = *((eax + 4));
        ecx = *(edx);
        eax = ebx;
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, ecx, ebx);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 0xc));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    eax = *(esp);
    ebx = *((eax + 4));
    eax = *((ebx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    ebx = *((ebx + edx*2 - 2));
    if (ebx == 1) {
        goto label_3;
    }
    eax = *((ebx + 8));
    eax = *((ebx + 4));
    ebx = *(ebx);
    eax = *((esp + 4));
    eax = *((eax + 0xc));
    ecx = *(eax);
    eax = *((esp + 8));
    eax = caml_apply2 (eax);
    if (eax != 1) {
        eax = *((esp + 0xc));
        return eax;
    }
    eax = *(esp);
    if (eax != 1) {
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        ebx = *(eax);
        eax = *((esp + 4));
        eax = *((eax + 0xc));
        ecx = *(eax);
        eax = *((esp + 8));
        eax = caml_apply2 (ebx);
        if (eax != 1) {
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *(esp);
        if (eax != 1) {
            ebx = *((eax + 8));
            ebx = *((eax + 4));
            ebx = *(eax);
            eax = *((esp + 4));
            eax = *((eax + 0xc));
            ecx = *(eax);
            eax = *((esp + 8));
            eax = caml_apply2 (ebx);
            if (eax != 1) {
                eax = *((esp + 0xc));
                return eax;
            }
            eax = *((esp + 4));
            ecx = *((eax + 0x14));
            eax = *((esp + 8));
            ebx = *(esp);
            void (*0x8056d50)() ();
        }
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = " %\a\b";
        caml_raise_exn ();
    }
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = " %\a\b";
    caml_raise_exn ();
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80575f0 */
#include <stdint.h>
 
int32_t camlHashtbl_add_1074 (void) {
    edi = eax;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (ecx, 0xc9, ebx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            ecx = *((edi + 4));
            ebx = *((ecx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_0;
            }
            ebx = *((ecx + edx*2 - 2));
            *((eax + 8)) = ebx;
            ecx = *((edi + 4));
            ebx = *((ecx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_1;
            }
            caml_modify (ecx + edx*2 - 2, eax);
            *(edi) += 2;
            eax = *((edi + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ebx = eax + eax - 1;
            eax = *(edi);
            if (eax > ebx) {
                eax = .comment;
                ebx = edi;
                void (*0x80574c0)() ();
            }
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80561d0 */
#include <stdint.h>
 
int32_t loc_camlSys_code_begin (void) {
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            ebx = .comment;
            *(eax) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e848 */
#include <stdint.h>
 
int32_t unix_lseek_64 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x138f0;
    eax = *((ebp + 0xc));
    esi = *((eax + 4));
    edi = *((eax + 8));
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x15d8));
    *((esp + 0xc)) = eax;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = lseek64 ();
    esi = eax;
    edi = edx;
    caml_leave_blocking_section ();
    eax = esi;
    eax &= edi;
    if (eax == -1) {
        eax = ebx - 0x15de;
        uerror (eax, 0);
    }
    caml_copy_int64 (esi, edi);
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fbad */
#include <stdint.h>
 
void caml_dlerror (void) {
    dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a634 */
#include <stdint.h>
 
void dlerror (void) {
    dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067042 */
#include <stdint.h>
 
int32_t caml_float_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_0;
        }
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
    } else {
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
    }
    if (fp_stack[0] <= fp_stack[1]) {
        fp_tmp_3 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_3;
        if (fp_stack[0] <= fp_stack[1]) {
            fp_stack--;
            if (fp_stack[0] != fp_stack[0]) {
                if (fp_stack[0] == fp_stack[0]) {
                    goto label_1;
                }
            }
            fp_stack--;
            if (fp_stack[0] != fp_stack[0]) {
                if (fp_stack[0] == fp_stack[0]) {
                    goto label_2;
                }
                goto label_3;
label_0:
                fp_stack++;
                fp_stack++;
            }
label_3:
            eax = 1;
            fp_stack++;
            fp_stack++;
label_2:
            eax = 0xffffffff;
        } else {
        } else {
            fp_stack++;
            fp_stack++;
            goto label_4;
label_1:
            fp_stack++;
label_4:
            eax = 3;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bda0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2616 (void) {
    eax = unix_getgrnam;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bfa0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2674 (void) {
    eax = unix_readlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c0e0 */
#include <stdint.h>
 
int32_t camlPrintf_get_contents_1405 (void) {
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    camlString_sub_1046 (eax);
    ebx = *(esp);
    *((ebx + 4)) = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057df0 */
#include <stdint.h>
 
int32_t camlHashtbl_fold_1138 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h;
    esi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x1c;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x10f7;
    *(edx) = sym.caml_curry2;
    *((edx + 4)) = 5;
    *((edx + 8)) = 0x8056ae0;
    *((edx + 0xc)) = esi;
    esi = *((ebx + 4));
    ebx = edx + 0x14;
    *((ebx - 4)) = 0x400;
    *(ebx) = ecx;
    eax = 1;
    ecx = *((esi - 4));
    ecx >>= 9;
    ecx |= 1;
    ecx += 0xfffffffe;
    if (eax > ecx) {
        goto label_2;
    }
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = ebx;
    *(esp) = esi;
    *((esp + 4)) = edx;
    do {
        ebx = *(ebx);
        ecx = *(esp);
        edx = *((ecx - 4));
        edx >>= 9;
        if (edx <= eax) {
            goto label_3;
        }
        eax = *((ecx + eax*2 - 2));
        ecx = *((esp + 4));
        eax = camlHashtbl_do_bucket_1142 ();
        ebx = *((esp + 0xc));
        caml_modify (ebx, eax);
        eax = *((esp + 0xc));
        edx = *((esp + 0xc));
        eax += 2;
        *((esp + 0xc)) = eax;
        ecx = *((esp + 0x10));
    } while (edx != ecx);
label_2:
    eax = *(ebx);
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066828 */
#include <stdint.h>
 
int32_t caml_int64_bits_of_float (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *(eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060248 */
#include <stdint.h>
 
int32_t unix_getsockopt (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11ef8;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = *((ebp + 0x10));
    edx >>= 1;
    edx <<= 3;
    edx += *((ebx + eax*4 - 0x138));
    ecx = *((ebp + 0xc));
    ecx = *((edx + 4));
    edx = *(edx);
    eax = *((ebx + eax*4 - 0x110));
    return unix_getsockopt_aux (ecx, eax, edx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060095 */
#include <stdint.h>
 
int32_t unix_getsockopt_aux (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t sockfd) {
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t level;
    int32_t optname;
    void * optval;
    socklen_t * optlen;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x120a3;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    if (esi <= 4) {
        eax = ebx;
        eax -= *((ebx + esi*4 - 0x12084));
        void (*eax)() ();
    }
    return unix_error (0x16, edi, 0);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ef34 */
#include <stdint.h>
 
uint32_t unix_rmdir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13207;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = rmdir ();
    if (eax == -1) {
        eax = ebx - 0x157a;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a624 */
#include <stdint.h>
 
void rmdir (void) {
    rmdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f5d0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1424 (void) {
    eax = caml_ml_flush;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806812d */
#include <stdint.h>
 
int32_t caml_array_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((ebp + 0x10));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_set_float (eax, edx, ecx);
    } else {
        caml_array_set_addr (eax, edx, ecx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bbe0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2566 (void) {
    eax = unix_tcflush;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804da90 */
#include <stdint.h>
 
int32_t camlUnix_open_process_full_1985 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = ebx;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x18)) = ebx;
    eax = *(eax);
    *((esp + 8)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 4)) = ebx;
    eax = *(eax);
    *((esp + 0x14)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x1c)) = ebx;
    eax = *(eax);
    *(esp) = eax;
    eax = *((esp + 8));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *((esp + 0x20)) = eax;
    eax = *((esp + 4));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    *((esp + 0x24)) = eax;
    eax = *(esp);
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ebx = eax;
    *((esp + 0x28)) = ebx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x34;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x800;
    eax = *(esp);
    *(esi) = eax;
    *((esi + 4)) = 1;
    edx = esi + 0xc;
    *((edx - 4)) = 0x800;
    eax = *((esp + 4));
    *(edx) = eax;
    *((edx + 4)) = esi;
    ecx = esi + 0x18;
    *((ecx - 4)) = 0x800;
    eax = *((esp + 8));
    *(ecx) = eax;
    *((ecx + 4)) = edx;
    ecx = esi + 0x24;
    *((ecx - 4)) = 0xc03;
    eax = *((esp + 0x20));
    *(ecx) = eax;
    eax = *((esp + 0x24));
    *((ecx + 4)) = eax;
    *((ecx + 8)) = ebx;
    eax = *((esp + 0xc));
    ebx = *((esp + 0x10));
    edx = *((esp + 0x14));
    esi = *((esp + 0x18));
    edi = *((esp + 0x1c));
    ebp = *(esp);
    *(loc.caml_extra_params) = ebp;
    camlUnix_open_proc_full_1975 (ecx);
    eax = *((esp + 0x14));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x18));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x1c));
    eax = unix_close;
    caml_c_call (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 0x20));
            *(eax) = ebx;
            ebx = *((esp + 0x24));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0x28));
            *((eax + 8)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d920 */
#include <stdint.h>
 
int32_t camlUnix_open_proc_full_1975 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = caml_extra_params;
    eax = .comment;
    eax = camlList_for_all_1137 (eax, esi, edi);
    *((esp + 0xc)) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    ecx = eax;
    if (ecx != 1) {
        eax = .comment;
        ebx = *((esp + 0x1c));
        void (*0x80575f0)() ();
    }
    eax = *((esp + 4));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *(esp);
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    if (eax == 1) {
        eax = loc.camlUnix__184;
        ebx = *((esp + 0x18));
        camlList_iter_1074 ();
    }
    fcn_0804da20 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ae10 */
#include <stdint.h>
 
int32_t caml_curry7_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058f60 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1565 (void) {
    edx = eax;
    eax = *((ecx + 0xc));
    eax -= edx;
    eax -= 3;
    eax += 2;
    esi = *((ecx + 0x10));
    ecx = *((esi - 4));
    edx = *((esi - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_0;
        }
        eax = caml_modify (esi + eax*2 - 2, ebx);
    } else {
        ecx >>= 0xa;
        if (ecx <= eax) {
            goto label_1;
        }
        *(fp_stack--) = *(ebx);
        *((esi + eax*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066423 */
#include <stdint.h>
 
uint32_t caml_int32_format (void) {
    char * format;
    int32_t var_8h_4;
    int32_t var_4h_3;
    int32_t var_8h_3;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x8071ba8;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    sprintf (ebx, esi, eax);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b620 */
#include <stdint.h>
 
int32_t camlSource_inner_loop_1039 (void) {
    do {
        if (eax < 1) {
            eax = ebx;
            return eax;
        }
        edi = *((edx + eax*2 - 2));
        ebp = *((edi + esi*2 - 2));
        ebp >>= 1;
        edi = *((ecx + eax*2 - 2));
        edi--;
        edi *= ebp;
        ebx += edi;
        eax += 0xfffffffe;
        camlSource_inner_loop_1039 ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b490 */
#include <stdint.h>
 
uint32_t caml_apply4 (void) {
    int32_t var_14h;
    int32_t var_18h;
    edi = *((esi + 4));
    if (edi == 9) {
        edi = *((esi + 8));
        void (*edi)() ();
    }
    ecx = *(esi);
    ebx = esi;
    eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (ebx, ecx, edx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 4));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 8));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e474 */
#include <stdint.h>
 
int32_t caml_callbackN (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callbackN_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80500d0 */
#include <stdint.h>
 
int32_t camlPervasives_entry (void) {
    *(0x8075698) = loc.camlPervasives__84;
    *(0x8075690) = 0x8075a7c;
    *(0x807568c) = 0x8075a70;
    *(0x8075688) = 0x8075a64;
    *(0x8075684) = 0x8075a54;
    *(0x8075680) = 0x8075a48;
    *(0x807567c) = 0x8075a3c;
    *(0x8075678) = 0x8075a30;
    *(0x8075668) = 0x8075a24;
    *(0x8075658) = 0x8075a14;
    *(0x807564c) = 0x8075a08;
    *(0x8075648) = 0x80759fc;
    *(0x8075644) = 0x80759ec;
    *(0x807563c) = 0x80759dc;
    *(0x8075638) = 0x80759cc;
    *(0x807562c) = 0x80759bc;
    *(0x8075624) = 0x80759b0;
    eax = loc.camlPervasives__67;
    *(0x807557c) = eax;
    eax = loc.camlPervasives__66;
    *(loc.camlPervasives) = eax;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Pervasives.Exit";
    *(0x8075580) = eax;
    eax = loc.camlPervasives__64;
    *(0x8075584) = eax;
    eax = loc.camlPervasives__63;
    *(0x8075588) = eax;
    eax = loc.camlPervasives__62;
    *(0x807558c) = eax;
    eax = loc.camlPervasives__61;
    *(0x8075598) = eax;
    eax = 0x80000001;
    *(0x8075594) = 0x80000001;
    *(0x8075590) = 0x7fffffff;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__60);
    *(0x807559c) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__59);
    *(0x80755a0) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__58);
    *(0x80755a4) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__57);
    *(0x80755a8) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__56);
    *(0x80755ac) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__55);
    *(0x80755b0) = eax;
    eax = loc.camlPervasives__54;
    *(0x80755b4) = eax;
    eax = loc.camlPervasives__53;
    *(0x80755b8) = eax;
    eax = loc.camlPervasives__52;
    *(0x80755bc) = eax;
    eax = loc.camlPervasives__51;
    *(0x80755c0) = eax;
    eax = loc.camlPervasives__50;
    *(0x80755c4) = eax;
    eax = loc.camlPervasives__49;
    *(0x80756bc) = eax;
    eax = loc.camlPervasives__48;
    *(0x80756b0) = eax;
    eax = loc.camlPervasives__47;
    *(0x80755c8) = eax;
    eax = loc.camlPervasives__46;
    *(0x80755cc) = eax;
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (1);
    *(0x80755d0) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (3);
    *(0x80755d4) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (5);
    *(0x80755d8) = eax;
    eax = loc.camlPervasives__45;
    *(0x8075620) = eax;
    eax = loc.camlPervasives__44;
    *(0x8075618) = eax;
    eax = loc.camlPervasives__43;
    *(0x807561c) = eax;
    eax = loc.camlPervasives__42;
    *(0x8075628) = eax;
    eax = loc.camlPervasives__41;
    *(0x8075630) = eax;
    eax = loc.camlPervasives__40;
    *(0x8075634) = eax;
    eax = loc.camlPervasives__39;
    *(0x8075640) = eax;
    eax = loc.camlPervasives__38;
    *(0x8075650) = eax;
    eax = loc.camlPervasives__37;
    *(0x8075654) = eax;
    eax = loc.camlPervasives__36;
    *(0x8075664) = eax;
    eax = loc.camlPervasives__35;
    *(0x807565c) = eax;
    eax = loc.camlPervasives__34;
    *(0x8075660) = eax;
    eax = loc.camlPervasives__33;
    *(0x8075670) = eax;
    eax = loc.camlPervasives__32;
    *(0x80756b4) = eax;
    eax = loc.camlPervasives__31;
    *(0x8075674) = eax;
    eax = loc.camlPervasives__30;
    *(0x807566c) = eax;
    eax = loc.camlPervasives__29;
    *(0x8075694) = eax;
    eax = loc.camlPervasives__28;
    *(0x80755dc) = eax;
    eax = loc.camlPervasives__27;
    *(0x80755e0) = eax;
    eax = loc.camlPervasives__26;
    *(0x80755e4) = eax;
    eax = loc.camlPervasives__25;
    *(0x80755e8) = eax;
    eax = loc.camlPervasives__24;
    *(0x80755ec) = eax;
    eax = loc.camlPervasives__23;
    *(0x80755f0) = eax;
    eax = loc.camlPervasives__22;
    *(0x80755f4) = eax;
    eax = loc.camlPervasives__21;
    *(0x80755f8) = eax;
    eax = loc.camlPervasives__20;
    *(0x80755fc) = eax;
    eax = loc.camlPervasives__19;
    *(0x8075600) = eax;
    eax = loc.camlPervasives__18;
    *(0x8075604) = eax;
    eax = loc.camlPervasives__17;
    *(0x8075608) = eax;
    eax = loc.camlPervasives__16;
    *(0x807560c) = eax;
    eax = loc.camlPervasives__15;
    *(0x8075610) = eax;
    eax = loc.camlPervasives__14;
    *(0x8075614) = eax;
    eax = loc.camlPervasives__13;
    eax = 0x24;
    caml_allocN ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x1800;
    *(ebx) = loc.camlPervasives__7;
    *((ebx + 4)) = 0x8075718;
    *((ebx + 8)) = 0x8075724;
    *((ebx + 0xc)) = 0x8075730;
    *((ebx + 0x10)) = 0x8075740;
    *((ebx + 0x14)) = 0x807574c;
    *(0x807569c) = ebx;
    eax = loc.camlPervasives__6;
    *(0x80756a4) = eax;
    eax = loc.camlPervasives__5;
    *(0x80756a0) = eax;
    ebx += 0x1c;
    *((ebx - 4)) = 0x400;
    eax = .comment;
    *(ebx) = eax;
    *(0x80756c0) = ebx;
    eax = loc.camlPervasives__4;
    *(0x80756ac) = eax;
    eax = loc.camlPervasives__3;
    *(0x80756b8) = eax;
    eax = camlPervasives__2;
    *(0x80756a8) = eax;
    eax = caml_register_named_value;
    caml_c_call ("Pervasives.do_at_exit");
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070304 */
#include <stdint.h>
 
void loc_caml_allocN (int32_t arg_4h, int32_t arg_8h) {
    do {
        eax -= *(obj.caml_young_ptr);
        eax = -eax;
        if (eax >= *(obj.caml_young_limit)) {
            *(obj.caml_young_ptr) = eax;
            return eax;
        }
        eax -= *(obj.caml_young_ptr);
        eax = -eax;
        *(obj.caml_young_ptr) -= eax;
        eax = *((esp + 4));
        *(obj.caml_last_return_address) = eax;
        eax = esp + 8;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_0807024d ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ce10 */
#include <stdint.h>
 
uint32_t unix_clear_nonblock (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1532b;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 3;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        ah &= 0xf7;
        *((esp + 8)) = eax;
        *((esp + 4)) = 4;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x16a4;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80564f0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_in_bucket_1213 (void) {
    int32_t var_4h_4;
    int32_t var_8h_2;
    do {
label_0:
        if (eax == 1) {
            goto label_1;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, ebx, ecx);
        if (eax == 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlHashtbl_find_in_bucket_1213 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_2:
            eax = *(esp);
            ebx = *((esp + 4));
            goto label_0;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067359 */
#include <stdint.h>
 
int32_t caml_tan_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    tan (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a7a4 */
#include <stdint.h>
 
void tan (void) {
    tan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80676d8 */
#include <stdint.h>
 
int32_t caml_add_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] += *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c250 */
#include <stdint.h>
 
int32_t camlUnix_fun_2754 (void) {
    eax = unix_open;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805edcc */
#include <stdint.h>
 
int32_t unix_readdir (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13374;
    eax = *((ebp + 8));
    eax = *(eax);
    if (eax == 0) {
        eax = ebx - 0x159c;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    eax = readdir64 ();
    if (eax == 0) {
        eax = caml_raise_end_of_file ();
    }
    eax += 0x13;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056890 */
#include <stdint.h>
 
int32_t camlHashtbl_find_in_bucket_1108 (void) {
    int32_t var_18h_3;
    int32_t var_18h;
    do {
label_0:
        if (eax == 1) {
            goto label_1;
        }
        *((esp + 4)) = ebx;
        ecx = *((eax + 8));
        *(esp) = ecx;
        ecx = *((eax + 4));
        *((esp + 8)) = ecx;
        eax = *(eax);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax != 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlHashtbl_find_in_bucket_1108 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_2:
            eax = *(esp);
            ebx = *((esp + 4));
            goto label_0;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80693fc */
#include <stdint.h>
 
uint32_t caml_ml_seek_out_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_seek_out (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058510 */
#include <stdint.h>
 
int32_t camlBuffer_sub_1046 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        edx -= ecx;
        edx++;
        if (ebx > edx) {
            goto label_0;
        }
        *((esp + 8)) = ecx;
        *((esp + 4)) = ebx;
        *(esp) = eax;
        eax = caml_create_string;
        eax = caml_c_call (ecx);
        ecx = eax;
        edx = 1;
        eax = *(esp);
        eax = *(eax);
        ebx = *((esp + 4));
        esi = *((esp + 8));
        camlString_blit_1056 (ecx);
        eax = *((esp + 0xc));
        return eax;
    }
label_0:
    eax = "Buffer.sub";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e709 */
#include <stdint.h>
 
uint32_t caml_weak_get_copy (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_78h;
    int32_t var_74h;
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    void * var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    void * s2;
    size_t n;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    eax = ebp - 0x38;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    edx = ebp + 8;
    *((ebp - 0x2c)) = edx;
    edx = ebp + 0xc;
    *((ebp - 0x28)) = edx;
    esi = *((ebp + 0xc));
    esi >>= 1;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    *((ebp - 0x60)) = eax;
    eax = ebp - 0x60;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x58)) = 1;
    *((ebp - 0x5c)) = 2;
    eax = ebp - 0x3c;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x50)) = eax;
    esi++;
    if (esi != 0) {
        eax = *((ebp + 8));
        edx = *((eax - 4));
        edx >>= 0xa;
        if (esi < edx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    esi <<= 2;
    eax = *((esi + eax));
    if (eax == *(obj.caml_weak_none)) {
        *(obj.caml_local_roots) = ebx;
        eax = 1;
        goto label_1;
    }
    if ((al & 1) != 0) {
        goto label_2;
    }
    edi = eax;
    ecx = eax;
    ecx >>= 0x17;
    edx = eax;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 3) == 0) {
        goto label_2;
    }
    edi -= 4;
    eax = *(edi);
    eax = *(edi);
    eax >>= 0xa;
    eax = caml_alloc (eax, eax);
    *((ebp - 0x40)) = eax;
    edx = *((ebp + 8));
    edx = *((esi + edx));
    if (edx == *(obj.caml_weak_none)) {
        *(obj.caml_local_roots) = ebx;
        eax = 1;
        goto label_1;
    }
    *((ebp - 0x74)) = edx;
    ecx = edx - 4;
    if (*(ecx) > 0xfa) {
        goto label_3;
    }
    *((ebp - 0x70)) = ecx;
    eax = *(ecx);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_4;
    }
    esi = 0;
    *((ebp - 0x78)) = ebx;
    do {
        edi = esi*4;
        eax = *((ebp - 0x74));
        ebx = *((eax + esi*4));
        if (*(obj.caml_gc_phase) == 0) {
            if ((bl & 1) != 0) {
                goto label_5;
            }
            edx = ebx;
            edx >>= 0x17;
            eax = ebx;
            eax >>= 0xc;
            eax &= 0x7ff;
            edx = *((edx*4 + obj.caml_page_table));
            if ((*((edx + eax)) & 1) == 0) {
                goto label_5;
            }
            caml_darken (ebx, 0);
        }
label_5:
        eax = edi;
        eax += *((ebp - 0x40));
        edx = *(eax);
        *((ebp - 0x6c)) = edx;
        *(eax) = ebx;
        eax = edi;
        eax += *((ebp - 0x40));
        edx = eax;
        edx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 1) != 0) {
            if (*(obj.caml_gc_phase) == 0) {
                eax = *((ebp - 0x6c));
                caml_darken (eax, 0);
            }
            if ((bl & 1) != 0) {
                goto label_6;
            }
            eax = caml_young_end;
            if (ebx >= eax) {
                goto label_6;
            }
            edx = caml_young_start;
            if (ebx <= edx) {
                goto label_6;
            }
            if ((*((ebp - 0x6c)) & 1) == 0) {
                ecx = *((ebp - 0x6c));
                if (eax <= ecx) {
                    goto label_7;
                }
                if (edx < ecx) {
                    goto label_6;
                }
            }
label_7:
            edx = 0x807ebc8;
            eax = *(edx);
            if (eax >= *(0x807ebcc)) {
                caml_realloc_ref_table (obj.caml_ref_table);
            }
            edx = 0x807ebc8;
            eax = *(edx);
            edi += *((ebp - 0x40));
            *(eax) = edi;
            eax += 4;
            *(edx) = eax;
        }
label_6:
        esi++;
        edx = *((ebp - 0x70));
        eax = *(edx);
        eax >>= 0xa;
    } while (eax > esi);
    ebx = *((ebp - 0x78));
    goto label_4;
label_3:
    ecx = *(ecx);
    ecx >>= 0xa;
    ecx <<= 2;
    eax = memmove (eax, edx, ecx);
    goto label_4;
label_2:
    *((ebp - 0x40)) = eax;
label_4:
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x3c)) = eax;
    edx = *((ebp - 0x40));
    *(eax) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062be2 */
#include <stdint.h>
 
int32_t caml_set_signal_action (int32_t signum, int32_t arg_ch) {
    int32_t var_120h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_10h;
    struct sigaction * act;
    struct sigaction * oldact;
    eax = *((ebp + 0xc));
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *((ebp - 0x94)) = 0;
        *((ebp - 0x10)) = 0;
        goto label_1;
    }
    *((ebp - 0x94)) = 1;
    *((ebp - 0x10)) = 0;
    goto label_1;
label_0:
    *((ebp - 0x94)) = sym.handle_signal;
    *((ebp - 0x10)) = 0;
label_1:
    ebx = ebp - 0x94;
    eax = ebp - 0x90;
    *(esp) = eax;
    sigemptyset ();
    eax = ebp - 0x120;
    eax = *((ebp + 8));
    eax = sigaction (eax, ebx, eax);
    edx = eax;
    eax = 0xffffffff;
    if (edx != -1) {
        edx = *((ebp - 0x120));
        eax = 2;
        if (edx == sym.handle_signal) {
            goto label_2;
        }
        al = (edx == 1) ? 1 : 0;
        eax = (int32_t) al;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bfc0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2678 (void) {
    eax = unix_mkfifo;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806de3d */
#include <stdint.h>
 
int32_t caml_md5_string (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_60h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = ebp - 0x60;
    caml_MD5Init (ebx);
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    caml_MD5Update (ebx, eax, eax);
    eax = caml_alloc_string (0x10);
    esi = eax;
    caml_MD5Final (eax, ebx);
    eax = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051550 */
#include <stdint.h>
 
int32_t camlArray_merge_1191 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    uint32_t var_8h;
    uint32_t var_ch;
    int32_t var_10h;
    *(esp) = eax;
    *((esp + 4)) = ecx;
    *((esp + 0x10)) = edx;
    *((esp + 8)) = edi;
    eax = caml_extra_params;
    *((esp + 0xc)) = eax;
    ebp = .comment;
    ecx = *(esp);
    edx = ecx + ebx - 1;
    eax = *((esp + 0x10));
    esi = eax + esi - 1;
label_1:
    eax = caml_young_ptr;
    eax -= 0x28;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x24f7;
    *(edi) = sym.caml_curry5;
    *((edi + 4)) = 0xb;
    *((edi + 8)) = 0x8050500;
    eax = *((ebp + 0xc));
    *((edi + 0xc)) = eax;
    eax = *((ebp + 0x10));
    *((edi + 0x10)) = eax;
    ebx = *((esp + 4));
    *((edi + 0x14)) = ebx;
    eax = *((esp + 8));
    *((edi + 0x18)) = eax;
    *((edi + 0x1c)) = edx;
    *((edi + 0x20)) = esi;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
        if (eax <= *((esp + 0x10))) {
            goto label_3;
        }
        eax = *((esp + 0x10));
        edx = *((ebx + eax*2 - 2));
    } else {
        eax >>= 0xa;
        if (eax <= *((esp + 0x10))) {
            goto label_4;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        eax = *((esp + 0x10));
        *(fp_stack--) = *((ebx + eax*4 - 4));
        *(edx) = fp_stack[0];
        fp_stack--;
    }
    esi = *((ebp + 0x10));
    eax = *((esi - 4));
    ebx = *((esi - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
        if (eax <= ecx) {
            goto label_6;
        }
        ebx = *((esi + ecx*2 - 2));
        goto label_7;
    }
    eax >>= 0xa;
    if (eax <= ecx) {
        goto label_8;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((esi + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
label_7:
            eax = ecx;
            ecx = *((esp + 0x10));
            esi = *((esp + 0xc));
            void (*0x8050500)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_8:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068f83 */
#include <stdint.h>
 
uint32_t caml_ml_output_partial (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x14));
    eax >>= 1;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    eax = caml_putblock (ebx, eax, eax);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062875 */
#include <stdint.h>
 
int32_t caml_rev_convert_signal_number (int32_t arg_8h) {
    eax = *((ebp + 8));
    edx = 1;
    ecx = posix_signals;
    if (eax != 6) {
        goto label_0;
    }
    dl = 0;
    while (edx != 0x15) {
label_0:
        if (*((ecx + edx*4)) == eax) {
            eax = edx;
            eax = ~eax;
        } else {
            edx++;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f170 */
#include <stdint.h>
 
int32_t loc_camlPervasives_code_begin (void) {
    do {
        ecx = *((ebx + 0xc));
        if (eax >= ecx) {
            ecx = loc.camlPervasives__103;
            eax = *((ebx + 8));
            ebx = ecx;
            void (*0x804f710)() ();
        }
        edx = *((ebx + 8));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        if (ecx >= 0x61) {
            if (ecx < 0x75) {
                goto label_1;
            }
        } else {
            if (ecx == 0x5b) {
                goto label_1;
            }
        }
        eax = *((ebx + 8));
        return eax;
label_1:
        eax += 2;
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b580 */
#include <stdint.h>
 
int32_t camlStd_exit_entry (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    void (*ecx)() ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061de7 */
#include <stdint.h>
 
int32_t caml_stack_usage (void) {
    ebx = caml_top_of_stack;
    ebx -= *(obj.caml_bottom_of_stack);
    ebx >>= 2;
    eax = caml_stack_usage_hook;
    if (eax != 0) {
        eax = void (*eax)() ();
        ebx += eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bd95 */
#include <stdint.h>
 
uint32_t caml_sys_chdir (int32_t arg_8h) {
    ebx = *((ebp + 8));
    *(esp) = ebx;
    eax = chdir ();
    if (eax != 0) {
        caml_sys_error (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a4b4 */
#include <stdint.h>
 
void chdir (void) {
    chdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80599f0 */
#include <stdint.h>
 
int32_t camlPrintf_add_conv_1169 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    *(esp) = edx;
    if (eax != 1) {
        ebx = camlPrintf__64;
        eax = *((edx + 0xc));
        camlBuffer_add_string_1082 ();
    } else {
        ebx = 0x4b;
        eax = *((edx + 0xc));
        camlBuffer_add_char_1072 ();
    }
    eax = *(esp);
    eax = *((eax + 0x10));
    eax = *((eax + 0xc));
    ebx = *((esp + 4));
    camlBuffer_add_char_1072 ();
    eax = *((esp + 8));
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f7e0 */
#include <stdint.h>
 
uint32_t camlPervasives_bool_of_string_1129 (void) {
    ebx = eax;
    eax = caml_string_notequal (ebx, "false");
    if (eax != 1) {
        eax = caml_string_notequal (ebx, "true");
        if (eax != 1) {
            eax = "bool_of_string";
            void (*0x804f620)() ();
        }
        eax = 3;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806753b */
#include <stdint.h>
 
int32_t caml_ldexp_float (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    ldexp (ebp, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049dc4 */
#include <stdint.h>
 
void ldexp (void) {
    ldexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fd40 */
#include <stdint.h>
 
int32_t camlPervasives_print_char_1266 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x80755d4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804e280 */
#include <stdint.h>
 
int32_t camlUnix_entry (void) {
    *(0x8072ff4) = loc.camlUnix__175;
    *(0x8072ff0) = 0x807390c;
    *(0x8072fec) = 0x80738fc;
    *(0x8072fe8) = 0x80738f0;
    *(0x8072fe4) = 0x80738e0;
    *(0x8072fe0) = 0x80738d0;
    *(0x8072fdc) = 0x80738c4;
    *(0x8072fd0) = 0x80738b4;
    *(0x8072fcc) = 0x80738a4;
    *(0x8072fc8) = 0x8073898;
    *(0x8072fc4) = 0x807388c;
    *(0x8072fc0) = 0x8073880;
    *(0x8072fbc) = 0x8073874;
    *(0x8072fb8) = 0x8073868;
    *(0x8072f74) = 0x807385c;
    *(0x8072f70) = 0x8073850;
    *(0x8072f6c) = 0x8073840;
    *(0x8072f68) = 0x8073830;
    *(0x8072f64) = 0x8073820;
    *(0x8072f60) = 0x8073810;
    *(0x8072f5c) = 0x8073804;
    *(0x8072f58) = 0x80737f4;
    *(0x8072f50) = 0x80737e4;
    *(0x8072f3c) = 0x80737d8;
    *(0x8072f38) = 0x80737cc;
    *(0x8072f34) = 0x80737c0;
    *(0x8072f30) = 0x80737b4;
    *(0x8072f2c) = 0x80737a8;
    *(0x8072f28) = 0x807379c;
    *(0x8072f24) = 0x8073790;
    *(0x8072f20) = 0x8073780;
    *(0x8072f1c) = 0x8073774;
    *(0x8072f18) = 0x8073768;
    *(0x8072f14) = 0x807375c;
    *(0x8072f10) = 0x8073750;
    *(0x8072f0c) = 0x8073744;
    *(0x8072f08) = 0x8073738;
    *(0x8072f04) = 0x807372c;
    *(0x8072f00) = 0x8073720;
    *(0x8072efc) = 0x8073710;
    *(0x8072ef8) = 0x8073704;
    *(0x8072ef4) = 0x80736f4;
    *(0x8072ef0) = 0x80736e8;
    *(0x8072eec) = 0x80736dc;
    *(0x8072ee8) = 0x80736d0;
    *(0x8072ee4) = 0x80736c4;
    *(0x8072ee0) = 0x80736b8;
    *(0x8072edc) = 0x80736ac;
    *(0x8072ed8) = 0x80736a0;
    *(0x8072ed4) = 0x8073694;
    *(0x8072ecc) = 0x8073688;
    *(0x8072ec8) = 0x807367c;
    *(0x8072ec4) = 0x807366c;
    *(0x8072ec0) = 0x807365c;
    *(0x8072ebc) = 0x807364c;
    *(0x8072eb8) = 0x807363c;
    *(0x8072eb4) = 0x8073630;
    *(0x8072eb0) = 0x8073620;
    *(0x8072e84) = 0x8073610;
    *(0x8072e80) = 0x8073604;
    *(0x8072e7c) = 0x80735f8;
    *(0x8072e78) = 0x80735ec;
    *(0x8072e74) = 0x80735e0;
    *(0x8072e70) = 0x80735d4;
    *(0x8072e6c) = 0x80735c8;
    *(0x8072e68) = 0x80735bc;
    *(0x8072e64) = 0x80735b0;
    *(0x8072e60) = 0x80735a4;
    *(0x8072e5c) = 0x8073594;
    *(0x8072e58) = 0x8073588;
    *(0x8072e54) = 0x807357c;
    *(0x8072e50) = 0x8073570;
    *(0x8072e4c) = 0x8073564;
    *(0x8072e48) = 0x8073554;
    *(0x8072e44) = 0x8073548;
    *(0x8072e40) = 0x8073538;
    *(0x8072e3c) = 0x807352c;
    *(0x8072e38) = 0x807351c;
    *(0x8072e34) = 0x807350c;
    *(0x8072e30) = 0x80734fc;
    *(0x8072e2c) = 0x80734ec;
    *(0x8072e28) = 0x80734dc;
    *(0x8072e24) = 0x80734cc;
    *(0x8072e20) = 0x80734c0;
    *(0x8072e18) = 0x80734b4;
    *(0x8072e14) = 0x80734a8;
    *(0x8072e10) = 0x807349c;
    *(0x8072e0c) = 0x8073490;
    *(0x8072e08) = 0x8073480;
    *(0x8072e04) = 0x8073470;
    *(0x8072e00) = 0x8073460;
    *(0x8072dfc) = 0x8073454;
    *(0x8072df8) = 0x8073448;
    *(0x8072df4) = 0x807343c;
    *(0x8072df0) = 0x8073430;
    *(0x8072de0) = 0x8073424;
    *(0x8072ddc) = 0x8073414;
    *(0x8072dcc) = 0x8073408;
    *(0x8072dc8) = 0x80733fc;
    *(0x8072dc4) = 0x80733f0;
    *(0x8072dbc) = 0x80733e0;
    *(0x8072db8) = 0x80733d4;
    *(0x8072db4) = 0x80733c8;
    *(0x8072db0) = 0x80733b8;
    *(0x8072dac) = 0x80733a8;
    *(0x8072da8) = 0x8073398;
    *(0x8072da4) = 0x8073388;
    *(0x8072da0) = 0x8073378;
    *(0x8072d9c) = 0x807336c;
    *(0x8072d98) = 0x8073360;
    *(0x8072d90) = 0x8073354;
    eax = 0x1c;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Unix.Unix_error";
    *(loc.camlUnix) = eax;
    ebx = eax + 8;
    *((ebx - 4)) = 0x1000;
    eax = camlUnix;
    *(ebx) = eax;
    *((ebx + 4)) = 1;
    *((ebx + 8)) = 0x8073984;
    *((ebx + 0xc)) = 0x807398c;
    eax = "Unix.Unix_error";
    camlCallback_register_exception_1034 ();
    eax = loc.camlUnix__60;
    *(0x8072d94) = eax;
    *(0x8072dd0) = 1;
    *(0x8072dd4) = 3;
    *(0x8072dd8) = 5;
    eax = loc.camlUnix__59;
    *(0x8072de4) = eax;
    eax = loc.camlUnix__58;
    *(0x8072de8) = eax;
    eax = loc.camlUnix__57;
    *(0x8072dec) = eax;
    eax = loc.camlUnix__56;
    eax = 0x1c;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x1800;
    *(eax) = loc.camlUnix__50;
    *((eax + 4)) = 0x80732d0;
    *((eax + 8)) = 0x80732e0;
    *((eax + 0xc)) = 0x80732f0;
    *((eax + 0x10)) = 0x80732fc;
    *((eax + 0x14)) = 0x8073308;
    *(0x8072e1c) = eax;
    eax = loc.camlUnix__49;
    *(0x8072ff8) = eax;
    eax = loc.camlUnix__48;
    *(0x8072ed0) = eax;
    eax = loc.camlUnix__47;
    *(0x8072ffc) = eax;
    eax = unix_inet_addr_of_string;
    eax = caml_c_call ("0.0.0.0");
    *(0x8072f40) = eax;
    eax = unix_inet_addr_of_string;
    eax = caml_c_call ("127.0.0.1");
    *(0x8072f44) = eax;
    eax = void (*0x804e81a)() ();
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = .comment;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (loc.camlUnix__44);
    }
    *(0x8072f48) = eax;
    eax = void (*0x804e862)() ();
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = .comment;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (loc.camlUnix__43);
    }
    *(0x8072f4c) = eax;
    eax = loc.camlUnix__42;
    *(0x8072f54) = eax;
    eax = loc.camlUnix__41;
    *(0x8072f78) = eax;
    eax = loc.camlUnix__40;
    *(0x8072f7c) = eax;
    eax = loc.camlUnix__39;
    *(0x8072f80) = eax;
    eax = loc.camlUnix__38;
    *(0x8072f84) = eax;
    eax = 0x20;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x1c00;
    *(eax) = 1;
    *((eax + 4)) = 3;
    *((eax + 8)) = 5;
    *((eax + 0xc)) = 7;
    *((eax + 0x10)) = 9;
    *((eax + 0x14)) = 0x8073230;
    *((eax + 0x18)) = 0x8073240;
    *(0x8073000) = eax;
    eax = loc.camlUnix__35;
    *(0x8072f88) = eax;
    eax = loc.camlUnix__34;
    *(0x8072f8c) = eax;
    eax = loc.camlUnix__33;
    *(0x8072f90) = eax;
    eax = loc.camlUnix__32;
    *(0x8072f94) = eax;
    eax = loc.camlUnix__31;
    *(0x8072f98) = eax;
    eax = loc.camlUnix__30;
    *(0x8072f9c) = eax;
    eax = loc.camlUnix__29;
    *(0x8072fa0) = eax;
    eax = loc.camlUnix__28;
    *(0x8072fa4) = eax;
    eax = loc.camlUnix__27;
    *(0x8072fa8) = eax;
    eax = loc.camlUnix__26;
    *(0x8073004) = eax;
    eax = loc.camlUnix__25;
    *(0x8072fd4) = eax;
    eax = loc.camlUnix__24;
    *(0x8073008) = eax;
    eax = loc.camlUnix__23;
    *(0x8072fd8) = eax;
    eax = loc.camlUnix__22;
    *(0x8072dc0) = eax;
    eax = loc.camlUnix__21;
    *(0x807300c) = eax;
    eax = loc.camlUnix__20;
    *(0x8073010) = eax;
    eax = loc.camlUnix__19;
    *(0x8073014) = eax;
    eax = loc.camlUnix__18;
    *(0x8072e88) = eax;
    eax = loc.camlUnix__17;
    *(0x8072e8c) = eax;
    eax = 0xf;
    eax = camlHashtbl_create_1051 ();
    *(0x8073018) = eax;
    eax = loc.camlUnix__16;
    *(0x807301c) = eax;
    eax = loc.camlUnix__15;
    *(0x8072e90) = eax;
    eax = loc.camlUnix__14;
    *(0x8072e94) = eax;
    eax = loc.camlUnix__13;
    *(0x8072e98) = eax;
    eax = loc.camlUnix__12;
    *(0x8073020) = eax;
    eax = loc.camlUnix__11;
    *(0x8072e9c) = eax;
    eax = loc.camlUnix__10;
    *(0x8073024) = eax;
    eax = loc.camlUnix__9;
    *(0x8073028) = eax;
    eax = loc.camlUnix__8;
    *(0x8072ea0) = eax;
    eax = loc.camlUnix__7;
    *(0x8072ea4) = eax;
    eax = loc.camlUnix__6;
    *(0x8072ea8) = eax;
    eax = loc.camlUnix__5;
    *(0x8072eac) = eax;
    eax = loc.camlUnix__4;
    *(0x8072fac) = eax;
    eax = loc.camlUnix__3;
    *(0x8072fb0) = eax;
    eax = loc.camlUnix__2;
    *(0x807302c) = eax;
    eax = camlUnix__1;
    *(0x8072fb4) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b230 */
#include <stdint.h>
 
int32_t caml_curry4_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c9a0 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_error_1671 (void) {
    eax = unix_getsockopt;
    caml_c_call (9);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80588f0 */
#include <stdint.h>
 
int32_t camlBuffer_add_channel_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    *((esp + 8)) = ecx;
    if (ecx >= 1) {
        eax = .comment;
        if (ecx <= eax) {
            goto label_0;
        }
    }
    eax = "Buffer.add_channel";
    camlPervasives_invalid_arg_1012 ();
label_0:
    eax = *((esp + 4));
    edx = *((eax + 8));
    ecx = *((eax + 4));
    ebx = *((esp + 8));
    ecx = ecx + ebx - 1;
    if (ecx > edx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 4));
    ecx = *((eax + 4));
    ebx = *(eax);
    eax = *(esp);
    edx = *((esp + 8));
    camlPervasives_really_input_1235 ();
    ebx = *((esp + 4));
    ecx = *((ebx + 4));
    eax = *((esp + 8));
    eax = ecx + eax - 1;
    *((ebx + 4)) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c280 */
#include <stdint.h>
 
int32_t camlUnix_fun_2758 (void) {
    eax = unix_getppid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a5a3 */
#include <stdint.h>
 
int32_t caml_deserialize_sint_1 (void) {
    edx = intern_src;
    eax = *(edx);
    edx++;
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054dd0 */
#include <stdint.h>
 
int32_t camlList_combine_1226 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        if (ebx == 1) {
            goto label_1;
        }
        esi = *((ebx + 4));
        ecx = *(ebx);
        edx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        ebx = esi;
        eax = camlList_combine_1226 (ecx, ecx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            eax = *((esp + 4));
            *((ebx + 4)) = eax;
            eax = ebx + 0xc;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            if (ebx == 1) {
                eax = 1;
                return eax;
            }
label_1:
            eax = "List.combine";
            void (*0x804f620)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f81c */
#include <stdint.h>
 
int32_t unix_shutdown (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12924;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x1530));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = shutdown ();
    if (eax == -1) {
        eax = ebx - 0x153b;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049ee4 */
#include <stdint.h>
 
void shutdown (void) {
    shutdown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ebd8 */
#include <stdint.h>
 
uint32_t unix_pipe (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13568;
    eax = ebp - 0x10;
    *(esp) = eax;
    eax = pipe ();
    if (eax == -1) {
        eax = ebx - 0x15ad;
        uerror (eax, 0);
    }
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x10));
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((ebp - 0xc));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a794 */
#include <stdint.h>
 
void pipe (void) {
    pipe ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ecf4 */
#include <stdint.h>
 
int32_t unix_read (int32_t fildes, void * s1, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4028h;
    int32_t var_4024h;
    int32_t var_4020h;
    int32_t var_401ch;
    int32_t var_4008h;
    void * buf;
    size_t nbyte;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x13448;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4028)) = edx;
    edx = ebp - 0x4028;
    *(eax) = edx;
    *((ebp - 0x4020)) = 1;
    *((ebp - 0x4024)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x401c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    caml_enter_blocking_section ();
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = ebp - 0x4008;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = read (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x15a1;
        uerror (eax, 0);
    }
    eax = ebp - 0x4008;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    edx = *((ebp - 0x4028));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a114 */
#include <stdint.h>
 
void read (void) {
    read ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a35a */
#include <stdint.h>
 
int32_t caml_output_value_to_block (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    eax = *((ebp + 0x10));
    *(obj.extern_userprovided_output) = eax;
    *(obj.extern_ptr) = eax;
    eax += *((ebp + 0x14));
    *(obj.extern_limit) = eax;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    extern_value ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053460 */
#include <stdint.h>
 
int32_t camlList_rmap_f_1070 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, eax, ecx);
        ebx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        ebx = *(esp);
        *((eax + 4)) = ebx;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_1:
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068e33 */
#include <stdint.h>
 
int32_t caml_putblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edx = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    eax = *((ebx + 0x10));
    esi = *((ebx + 0xc));
    esi -= eax;
    if (edi < esi) {
        memmove (eax, edx, edi);
        *((ebx + 0x10)) += edi;
        eax = edi;
    } else {
        memmove (eax, edx, esi);
        eax = ebx + 0x34;
        *((ebp - 0x1c)) = eax;
        eax = *((ebx + 0xc));
        eax -= *((ebp - 0x1c));
        *((ebp - 0x20)) = eax;
        ecx = eax;
        edx = *((ebp - 0x1c));
        eax = *(ebx);
        eax = do_write ();
        edi = eax;
        if (*((ebp - 0x20)) > eax) {
            eax = *((ebp - 0x20));
            eax -= edi;
            eax = *((ebp - 0x1c));
            eax += edi;
            eax = *((ebp - 0x1c));
            memmove (eax, eax, eax);
        }
        edx = edi;
        edx >>= 0x1f;
        *((ebx + 4)) += edi;
        *((ebx + 8)) += edx;
        edi = -edi;
        edi += *((ebx + 0xc));
        *((ebx + 0x10)) = edi;
        eax = esi;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80667cc */
#include <stdint.h>
 
int32_t caml_int64_to_nativeint (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c490 */
#include <stdint.h>
 
uint32_t camlCallback_register_exception_1034 (void) {
    ecx = eax;
    eax = *((ebx - 4));
    if (eax == 0xfe) {
        goto label_0;
    }
    eax = *(ebx);
    while (1) {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(eax) = fp_stack[0];
            fp_stack--;
            eax = caml_register_named_value;
            caml_c_call (ecx);
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068a9a */
#include <stdint.h>
 
uint32_t caml_ml_input_scan_line (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_input_scan_line (ebx);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806768a */
#include <stdint.h>
 
int32_t caml_div_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] /= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2670 (void) {
    eax = unix_lockf;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ab00 */
#include <stdint.h>
 
int32_t caml_curry9_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805fa36 */
#include <stdint.h>
 
int32_t unix_sigprocmask (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_118h;
    int32_t var_98h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x126ff;
    eax = *((ebp + 8));
    eax >>= 1;
    edi = *((ebx + eax*4 - 0x1500));
    esi = ebp - 0x98;
    edx = esi;
    eax = *((ebp + 0xc));
    decode_sigset ();
    caml_enter_blocking_section ();
    eax = ebp - 0x118;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = sigprocmask ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x150e;
        uerror (eax, 0);
    }
    eax = ebp - 0x118;
    encode_sigset ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a5d4 */
#include <stdint.h>
 
void sigprocmask (void) {
    sigprocmask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806003b */
#include <stdint.h>
 
int32_t unix_setsockopt (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12105;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = *((ebp + 0x10));
    edx >>= 1;
    edx <<= 3;
    edx += *((ebx + eax*4 - 0x138));
    ecx = *((ebp + 0x14));
    ecx = *((ebp + 0xc));
    ecx = *((edx + 4));
    edx = *(edx);
    eax = *((ebx + eax*4 - 0x124));
    unix_setsockopt_aux (ecx, eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ff40 */
#include <stdint.h>
 
int32_t unix_setsockopt_aux (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t sockfd, int32_t arg_1ch) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_10h;
    int32_t var_bp_ch;
    int32_t level;
    int32_t optname;
    void * optval;
    socklen_t optlen;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x121ff;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((ebp + 0x1c));
    if (eax != 2) {
        if (eax >= 2) {
            if (eax != 3) {
                goto label_0;
            }
            edx >>= 1;
            *((ebp - 0x10)) = edx;
            eax = 4;
        } else {
        } else {
            ecx = edx;
            ecx ^= 1;
            ecx &= 1;
            *((ebp - 0x10)) = ecx;
            eax = 8;
            if (ecx == 0) {
                goto label_1;
            }
            eax = *(edx);
            eax >>= 1;
            *((ebp - 0xc)) = eax;
            eax = 8;
            goto label_1;
        }
        *(fp_stack--) = *(edx);
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *((ebp - 0x20)) = fp_stack[0];
        eax = *((ebp - 0x20));
        *((ebp - 0x10)) = eax;
        *((ebp - 0x20)) = eax;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] -= fp_stack[1];
        fp_stack++;
        fp_stack[0] *= *((ebx - 0x1644));
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        eax = 8;
        goto label_1;
label_0:
        eax = unix_error (0x16, esi, 0);
    }
label_1:
    eax = ebp - 0x10;
    eax = *((ebp + 0x14));
    eax = *((ebp + 0x10));
    eax = *((ebp + 0x18));
    eax >>= 1;
    eax = setsockopt (eax, eax, eax);
    if (eax == -1) {
        uerror (esi, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056440 */
#include <stdint.h>
 
int32_t loc_camlHashtbl_code_begin (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0x10));
        eax = caml_apply2 (ecx, ecx, ebx);
        if (eax != 1) {
            eax = *((esp + 8));
            eax = *((eax + 0xc));
            *(eax) += 0xfffffffe;
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_code_begin ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063364 */
#include <stdint.h>
 
int32_t caml_set_allocation_policy (int32_t arg_8h) {
    eax = *((ebp + 8));
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *(obj.fl_prev) = 0x807b788;
        goto label_0;
    }
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
label_0:
    *(obj.caml_allocation_policy) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c7b0 */
#include <stdint.h>
 
int32_t camlUnix_send_1570 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_send;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.send";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066ef0 */
#include <stdint.h>
 
int32_t caml_int32_mul (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax *= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058870 */
#include <stdint.h>
 
int32_t camlBuffer_add_string_1082 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 0xc)) = eax;
    edx = ebx;
    *(esp) = edx;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    ebx = ecx*4 - 1;
    ecx = *((edx + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    *((esp + 4)) = ebx;
    ecx = *((eax + 4));
    edx = ecx + ebx - 1;
    *((esp + 8)) = edx;
    ecx = *((eax + 8));
    if (edx > ecx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 0xc));
    edx = *((eax + 4));
    ecx = *(eax);
    ebx = 1;
    eax = *(esp);
    esi = *((esp + 4));
    camlString_blit_1056 ();
    ebx = *((esp + 8));
    eax = *((esp + 0xc));
    *((eax + 4)) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058670 */
#include <stdint.h>
 
int32_t camlBuffer_resize_1066 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = eax;
    *((esp + 4)) = ecx;
    edx = *((ecx + 8));
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((esp + 8)) = eax;
    *((eax - 4)) = 0x400;
    *(eax) = edx;
    do {
        esi = *(eax);
        edx = *((ecx + 4));
        edx = edx + ebx - 1;
        if (edx <= esi) {
            goto label_2;
        }
        edx = *(eax);
        edx >>= 1;
        edx = edx*4 + 1;
        *(eax) = edx;
    } while (1);
label_2:
    esi = .comment;
    edx = *(eax);
    if (edx > esi) {
        edx = .comment;
        ecx = *((ecx + 4));
        ebx = ecx + ebx - 1;
        if (ebx <= edx) {
            ebx = .comment;
            *(eax) = ebx;
        } else {
            eax = "Buffer.add: cannot grow buffer";
            camlPervasives_failwith_1010 ();
        }
    }
    eax = *((esp + 8));
    eax = caml_create_string;
    eax = caml_c_call (*(eax));
    ecx = eax;
    eax = *((esp + 4));
    esi = *((eax + 4));
    edx = 1;
    ebx = 1;
    eax = *(eax);
    camlString_blit_1056 (ecx);
    eax = *(esp);
    ebx = *((esp + 8));
    caml_modify (ebx, eax);
    eax = *((esp + 8));
    eax = *(eax);
    *((ebx + 8)) = eax;
    eax = 1;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80669c1 */
#include <stdint.h>
 
int32_t caml_int64_of_nativeint (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80608ba */
#include <stdint.h>
 
int32_t unix_tcdrain (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11886;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcdrain ();
    if (eax == -1) {
        eax = ebx - 0x140f;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a124 */
#include <stdint.h>
 
void tcdrain (void) {
    tcdrain ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064b04 */
#include <stdint.h>
 
int32_t caml_free_for_heap (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax - 0x10));
    free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060d70 */
#include <stdint.h>
 
uint32_t unix_times (void) {
    int32_t var_60h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x113c8;
    eax = caml_alloc_small (8, 0xfe);
    esi = eax;
    edi = ebp - 0x60;
    *((esp + 4)) = edi;
    *(esp) = 0;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x60));
    *(fp_stack--) = *((ebp - 0x5c));
    eax = ebx - 0x12fc;
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esi) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x58));
    *(fp_stack--) = *((ebp - 0x54));
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 8)) = fp_stack[0];
    fp_stack--;
    *((esp + 4)) = edi;
    *(esp) = 0xffffffff;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x60));
    *(fp_stack--) = *((ebp - 0x5c));
    eax = ebx - 0x12fc;
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 0x10)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x58));
    *(fp_stack--) = *((ebp - 0x54));
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 0x18)) = fp_stack[0];
    fp_stack--;
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a154 */
#include <stdint.h>
 
void getrusage (void) {
    getrusage ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d040 */
#include <stdint.h>
 
int32_t unix_getaddrinfo (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_138h;
    int32_t var_134h;
    void * s1;
    uint32_t var_12ch;
    int32_t var_124h;
    int32_t var_b4h;
    int32_t var_b0h;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_88h;
    int32_t var_84h;
    int32_t var_80h;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x150fb;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x138)) = edx;
    *((ebp - 0x38)) = edx;
    edx = ebp - 0x38;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    ecx = ebp + 8;
    *((ebp - 0x2c)) = ecx;
    ecx = ebp + 0xc;
    *((ebp - 0x28)) = ecx;
    ecx = ebp + 0x10;
    *((ebp - 0x24)) = ecx;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    *((ebp - 0x44)) = 0;
    *((ebp - 0x64)) = edx;
    edx = ebp - 0x64;
    *(eax) = edx;
    *((ebp - 0x5c)) = 1;
    *((ebp - 0x60)) = 3;
    eax = ebp - 0x3c;
    *((ebp - 0x58)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x44;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    esi = 0;
    if (eax != 0) {
        eax++;
        eax = caml_stat_alloc (eax);
        esi = eax;
        eax = *((ebp + 8));
        strcpy (esi, eax);
    }
    eax = *((ebp + 0xc));
    eax = caml_string_length (eax);
    edi = 0;
    if (eax != 0) {
        eax++;
        eax = caml_stat_alloc (eax);
        edi = eax;
        eax = *((ebp + 0xc));
        strcpy (edi, eax);
    }
    ecx = ebp - 0x84;
    edx = 0;
    eax = 0;
    do {
        *((ecx + eax)) = edx;
        eax += 4;
    } while (eax < 0x20);
    *((ebp - 0x80)) = 0;
    eax = *((ebp + 0x10));
    if ((al & 1) != 0) {
        goto label_0;
    }
    ecx = *((ebx - 0x1c));
    do {
        eax = *(eax);
        *((ebp - 0x40)) = eax;
        if ((al & 1) == 0) {
            edx = *((eax - 4));
            if (dl != 1) {
                if (dl >= 1) {
                    if (dl != 2) {
                        goto label_1;
                    }
                    eax = *(eax);
                    eax >>= 1;
                    edx = *((ebx - 0x20));
                    eax = *((edx + eax*4));
                    *((ebp - 0x80)) = eax;
                } else {
                } else {
                    eax = *(eax);
                    eax >>= 1;
                    eax = *((ecx + eax*4));
                    *((ebp - 0x7c)) = eax;
                    goto label_1;
                }
            }
            eax = *(eax);
            eax >>= 1;
            *((ebp - 0x78)) = eax;
        } else {
            eax >>= 1;
            if (eax != 1) {
                if (eax != 2) {
                    if (eax != 0) {
                        goto label_1;
                    }
                    *((ebp - 0x84)) |= 4;
                    *((ebp - 0x84)) |= 2;
                } else {
                } else {
                    *((ebp - 0x84)) |= 1;
                }
            }
        }
label_1:
        eax = *((ebp + 0x10));
        eax = *((eax + 4));
        *((ebp + 0x10)) = eax;
    } while ((al & 1) == 0);
label_0:
    caml_enter_blocking_section ();
    eax = ebp - 0x88;
    *((esp + 0xc)) = eax;
    eax = ebp - 0x84;
    *((esp + 8)) = eax;
    *((esp + 4)) = edi;
    *(esp) = esi;
    eax = getaddrinfo ();
    *((ebp - 0x12c)) = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        caml_stat_free (esi);
    }
    if (edi != 0) {
        caml_stat_free (edi);
    }
    *((ebp - 0x3c)) = 1;
    if (*((ebp - 0x12c)) != 0) {
        goto label_2;
    }
    esi = *((ebp - 0x88));
    if (esi == 0) {
        goto label_3;
    }
    ecx = ebp - 0xb4;
    *((ebp - 0x134)) = ecx;
    do {
        eax = *((ebx - 0x18));
        eax = *(eax);
        *((ebp - 0x12c)) = eax;
        *((ebp - 0x8c)) = 0;
        *((ebp - 0x90)) = 0;
        *((ebp - 0x94)) = 0;
        *((ebp - 0xb4)) = eax;
        ecx = *((ebp - 0x134));
        edx = *((ebx - 0x18));
        *(edx) = ecx;
        *((ebp - 0xac)) = 1;
        *((ebp - 0xb0)) = 3;
        eax = ebp - 0x8c;
        *((ebp - 0xa8)) = eax;
        eax = ebp - 0x90;
        *((ebp - 0xa4)) = eax;
        eax = ebp - 0x94;
        *((ebp - 0xa0)) = eax;
        eax = *((esi + 0x10));
        edi = 0x70;
        if (eax <= 0x70) {
            edi = eax;
        }
        eax = ebp - 0x124;
        *((ebp - 0x130)) = eax;
        eax = *((esi + 0x14));
        edx = *((ebp - 0x130));
        memcpy (edx, eax, edi);
        ecx = *((ebp - 0x130));
        eax = alloc_sockaddr (ecx, edi, 0xffffffff);
        *((ebp - 0x90)) = eax;
        eax = *((esi + 0x18));
        edx = ebx - 0x5a4;
        if (eax == 0) {
            eax = edx;
        }
        eax = caml_copy_string (eax);
        *((ebp - 0x94)) = eax;
        eax = caml_alloc_small (5, 0);
        edi = eax;
        *((ebp - 0x8c)) = eax;
        eax = *((ebx - 0x20));
        eax = *((esi + 4));
        eax = cst_to_constr (0, eax, 3);
        *(edi) = eax;
        edi = *((ebp - 0x8c));
        edi += 4;
        edx = *((ebx - 0x1c));
        eax = *((esi + 8));
        eax = cst_to_constr (0, edx, 4);
        *(edi) = eax;
        eax = *((esi + 0xc));
        edx = eax + eax + 1;
        eax = *((ebp - 0x8c));
        *((eax + 8)) = edx;
        edx = *((ebp - 0x90));
        eax = *((ebp - 0x8c));
        *((eax + 0xc)) = edx;
        edx = *((ebp - 0x94));
        eax = *((ebp - 0x8c));
        *((eax + 0x10)) = edx;
        eax = *((ebx - 0x18));
        ecx = *((ebp - 0x12c));
        *(eax) = ecx;
        eax = *((ebp - 0x8c));
        *((ebp - 0x44)) = eax;
        eax = caml_alloc_small (2, 0);
        *((ebp - 0x40)) = eax;
        edx = *((ebp - 0x44));
        *(eax) = edx;
        edx = *((ebp - 0x3c));
        eax = *((ebp - 0x40));
        *((eax + 4)) = edx;
        eax = *((ebp - 0x40));
        *((ebp - 0x3c)) = eax;
        esi = *((esi + 0x1c));
    } while (esi != 0);
label_3:
    eax = *((ebp - 0x88));
    *(esp) = eax;
    freeaddrinfo ();
label_2:
    eax = *((ebx - 0x18));
    edx = *((ebp - 0x138));
    *(eax) = edx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c7d4 */
#include <stdint.h>
 
int32_t unix_chmod (char * path, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t mode;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15967;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = chmod (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x16d7;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a104 */
#include <stdint.h>
 
void chmod (void) {
    chmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062dca */
#include <stdint.h>
 
int32_t caml_ext_table_add (int32_t arg_8h, char * arg_ch) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    eax = *((ebx + 4));
    if (*(ebx) >= eax) {
        edx = eax + eax;
        *((ebx + 4)) = edx;
        eax <<= 3;
        eax = *((ebx + 8));
        eax = caml_stat_resize (eax, eax);
        *((ebx + 8)) = eax;
    }
    eax = *(ebx);
    edx = *((ebx + 8));
    ecx = *((ebp + 0xc));
    *((edx + eax*4)) = ecx;
    *(ebx)++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064ace */
#include <stdint.h>
 
int32_t caml_stat_resize (void * ptr, int32_t arg_ch) {
    size_t size;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = realloc (eax, eax);
    if (eax == 0) {
        caml_raise_out_of_memory ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f24 */
#include <stdint.h>
 
void realloc (void) {
    realloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80665f7 */
#include <stdint.h>
 
int32_t caml_nativeint_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_nativeint ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059170 */
#include <stdint.h>
 
int32_t camlPrintf_cont_t_1363 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = eax;
    *((esp + 4)) = ecx;
    *((esp + 8)) = edx;
    eax = *((edx + 0x2c));
    if (eax != 1) {
        eax = 1;
        ecx = *(ebx);
        eax = void (*ecx)() ();
        ebx = eax;
        eax = *((esp + 8));
        ecx = *((eax + 0x34));
        eax = *((eax + 0x3c));
        caml_apply2 ();
    } else {
        eax = *((edx + 0x3c));
        ecx = *(ebx);
        void (*ecx)() ();
    }
    ecx = *((esp + 8));
    ecx += 0xffffffd0;
    eax = *(esp);
    ebx = *((esp + 4));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bdc0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2620 (void) {
    eax = unix_getlogin;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061a9b */
#include <stdint.h>
 
int32_t caml_raise_with_args (void) {
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x48;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x40)) = esi;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x3c)) = ebx;
    eax = esi + 1;
    caml_alloc_small (ebx, esi);
    edx = *((ebp + 8));
    *(eax) = edx;
    if (esi <= 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((ebx + edx*4));
        *((eax + edx*4 + 4)) = ecx;
        edx++;
    } while (edx != esi);
label_0:
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e2e3 */
#include <stdint.h>
 
int32_t unix_gmtime (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_1ah;
    time_t * timer;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13e5d;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0xc)) = fp_stack[0];
    fp_stack--;
    eax = ebp - 0xc;
    eax = gmtime (eax);
    if (eax == 0) {
        eax = ebx - 0x1623;
        unix_error (0x16, eax, 0);
    }
    alloc_tm ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a764 */
#include <stdint.h>
 
void gmtime (void) {
    gmtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806be61 */
#include <stdint.h>
 
uint32_t caml_sys_open (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    int32_t var_8h;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    eax++;
    eax = caml_stat_alloc (eax);
    ebx = eax;
    eax = *((ebp + 8));
    strcpy (ebx, eax);
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, 0x807b820);
    esi = eax;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x3c)) = eax;
    caml_enter_blocking_section ();
    eax = *((ebp - 0x3c));
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = open64 ();
    esi = eax;
    if (eax != -1) {
        *((esp + 8)) = 1;
        *((esp + 4)) = 2;
        *(esp) = eax;
        fcntl ();
        caml_leave_blocking_section ();
        caml_stat_free (ebx);
    } else {
        caml_leave_blocking_section ();
        caml_stat_free (ebx);
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    *(obj.caml_local_roots) = edi;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80566f0 */
#include <stdint.h>
 
int32_t camlHashtbl_insert_bucket_1068 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 8));
        ecx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        camlHashtbl_insert_bucket_1068 (ebx, ecx, ecx);
    } while (1);
    eax = *(esp);
    ebx = *((eax + 0xc));
    ebx >>= 1;
    if (ebx != 0) {
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 8));
        eax = void (*ecx)(uint32_t) (ebx);
        eax >>= 1;
        ecx = *((esp + 0xc));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    ebx = *(esp);
    ecx = *((ebx + 0x10));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            esi = *((esp + 8));
            *(eax) = esi;
            esi = *((esp + 4));
            *((eax + 4)) = esi;
            esi = *((ebx + 0x10));
            ebx = *((esi - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_2;
            }
            ebx = *((esi + edx*2 - 2));
            *((eax + 8)) = ebx;
            caml_modify (ecx + edx*2 - 2, eax);
            eax = 1;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054cf0 */
#include <stdint.h>
 
int32_t camlList_partition_1212 (void) {
    esi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x8053600;
            *((edx + 0xc)) = esi;
            ebx = 1;
            eax = 1;
            void (*0x8053600)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804af80 */
#include <stdint.h>
 
int32_t caml_curry6_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c230 */
#include <stdint.h>
 
int32_t camlUnix_fun_2750 (void) {
    eax = caml_ml_open_descriptor_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806653a */
#include <stdint.h>
 
int32_t caml_int64_float_of_bits (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052550 */
#include <stdint.h>
 
int32_t camlArray_map_1105 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = eax;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    if (eax == 1) {
        eax = loc.camlArray__24;
        return eax;
    }
    *(esp) = eax;
    *((esp + 4)) = ebx;
    *((esp + 8)) = ecx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        eax = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    edx = *(ecx);
    ebx = ecx;
    eax = void (*edx)() ();
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    esi = eax;
    ebx = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_3;
    }
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = ebx;
    *(esp) = esi;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            eax = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 8));
        ecx = *(ebx);
        eax = void (*ecx)() ();
        esi = *(esp);
        ebx = *((esi - 4));
        if (ebx != 0xfe) {
            ebx = *((esp + 0x14));
            eax = caml_modify (esi + ebx*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            ebx = *((esp + 0x10));
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        ebx += 2;
        *((esp + 0x10)) = ebx;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_3:
    eax = esi;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fca0 */
#include <stdint.h>
 
int32_t camlPervasives_input_line_1241 (void) {
    edx = eax;
    ebx = loc.camlPervasives__86;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x804f2a0;
            *((ecx + 0xc)) = edx;
            *((ecx + 0x10)) = ebx;
            ebx = 1;
            eax = 1;
            void (*0x804f2a0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b0d0 */
#include <stdint.h>
 
int32_t caml_curry5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064a40 */
#include <stdint.h>
 
int32_t caml_page_table_initialize (void) {
    eax = 0;
    edx = caml_page_table;
    do {
        *((edx + eax*4)) = obj.caml_page_table_empty;
        eax++;
    } while (eax != 0x200);
    ax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be00 */
#include <stdint.h>
 
int32_t camlUnix_fun_2628 (void) {
    eax = unix_setgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80629ce */
#include <stdint.h>
 
uint32_t caml_install_signal_handler (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_convert_signal_number (ebx, esi, edi);
    esi = eax;
    if (eax > 0x40) {
        eax = caml_invalid_argument (0x8070fc8);
    }
    ecx = *((ebp + 0xc));
    edi = ecx - 1;
    edx = 2;
    if (edi <= 2) {
        edx = *((ecx*4 + 0x8071050));
    }
    eax = caml_set_signal_action (eax, edx);
    if (eax != 1) {
        if (eax != 2) {
            if (eax == 0) {
                *((ebp - 0x3c)) = 1;
            } else {
                *((ebp - 0x3c)) = 3;
            } else {
            }
            eax = caml_alloc_small (1, 0);
            *((ebp - 0x3c)) = eax;
            edx = caml_signal_handlers;
            edx = *((edx + esi*4));
            *(eax) = edx;
        } else {
        }
        caml_sys_error (1);
    }
    if ((*((ebp + 0xc)) & 1) == 0) {
        if (*(obj.caml_signal_handlers) == 0) {
            eax = caml_alloc (0x41, 0);
            *(obj.caml_signal_handlers) = eax;
            caml_register_global_root (obj.caml_signal_handlers);
        }
        eax = *((ebp + 0xc));
        eax = *(eax);
        esi <<= 2;
        esi += *(obj.caml_signal_handlers);
        caml_modify (esi, eax);
    }
    caml_process_pending_signals ();
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065d10 */
#include <stdint.h>
 
int32_t caml_equal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x807f400) {
        eax = compare_free_stack ();
    }
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065bd2 */
#include <stdint.h>
 
int32_t caml_greaterequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x807f400) {
        compare_free_stack ();
    }
    eax = ebx;
    eax >>= 0x1f;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b080 */
#include <stdint.h>
 
int32_t caml_curry6_5 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *(esp) = eax;
    eax = *((ebx + 0xc));
    ecx = *((eax + 0xc));
    edi = *((ecx + 0xc));
    ebp = *((edi + 0xc));
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    ebx = *((ebx + 8));
    *((esp + 0xc)) = ebx;
    esi = *((eax + 8));
    ecx = *((ecx + 8));
    ebx = *((edi + 8));
    eax = *((ebp + 8));
    edx = *((edx + 8));
    *((esp + 8)) = edx;
    edx = esi;
    esi = *((esp + 0xc));
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c800 */
#include <stdint.h>
 
int32_t camlUnix_sendto_1576 (void) {
    int32_t var_14h;
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        *(esp) = eax;
        eax = *((ebx - 4));
        eax >>= 0xa;
        ebp = eax*4 - 1;
        eax = *((ebx + ebp));
        ebp -= eax;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = *((esp + 0x14));
        eax = unix_sendto_native;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.sendto";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c130 */
#include <stdint.h>
 
int32_t camlUnix_fun_2720 (void) {
    eax = unix_fchmod;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066844 */
#include <stdint.h>
 
int32_t caml_int64_of_string (int32_t arg_8h) {
    int32_t var_60h;
    uint32_t var_5ch;
    int32_t var_50h;
    int32_t var_4ch;
    uint32_t var_3ch;
    int32_t var_38h;
    uint32_t var_34h;
    uint32_t var_30h;
    uint32_t var_2ch;
    uint32_t var_20h;
    uint32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = ebp - 0x1c;
    edx = ebp - 0x20;
    eax = *((ebp + 8));
    eax = parse_sign_and_base (ebx, esi, edi);
    edi = eax;
    eax = *((ebp - 0x20));
    *((ebp - 0x38)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((ebp - 0x30)) = eax;
    *((ebp - 0x2c)) = edx;
    eax = _udivdi3 (edx, 0xffffffff, eax);
    *((ebp - 0x3c)) = eax;
    *((ebp - 0x34)) = edx;
    eax = *(edi);
    eax = parse_digit ();
    ebx = eax;
    if (eax >= 0) {
        if (*((ebp - 0x38)) > eax) {
            goto label_0;
        }
    }
    eax = caml_failwith ("int_of_string");
label_0:
    esi = eax;
    esi >>= 0x1f;
    edi++;
    do {
        eax = *(edi);
        if (al != 0x5f) {
            eax = (int32_t) al;
            eax = parse_digit ();
            *((ebp - 0x4c)) = eax;
            if (eax < 0) {
                goto label_1;
            }
            if (*((ebp - 0x38)) <= eax) {
                goto label_1;
            }
            if (esi >= *((ebp - 0x34))) {
                if (esi <= *((ebp - 0x34))) {
                    if (ebx <= *((ebp - 0x3c))) {
                        goto label_2;
                    }
                }
                caml_failwith ("int_of_string");
            }
label_2:
            edx = *((ebp - 0x30));
            edx *= esi;
            ecx = *((ebp - 0x2c));
            ecx *= ebx;
            edx += ecx;
            *((ebp - 0x50)) = edx;
            eax = *((ebp - 0x30));
            edx:eax = eax * ebx;
            ebx = eax;
            esi = edx;
            esi += *((ebp - 0x50));
            eax = *((ebp - 0x4c));
            edx = *((ebp - 0x4c));
            edx >>= 0x1f;
            *((ebp - 0x60)) = eax;
            *((ebp - 0x5c)) = edx;
            ebx += eax;
            esi += edx;
            if (edx < esi) {
                goto label_3;
            }
            if (*((ebp - 0x5c)) <= esi) {
                if (eax <= ebx) {
                    goto label_3;
                }
            }
            caml_failwith ("int_of_string");
        }
label_3:
        edi++;
    } while (1);
label_1:
    *((ebp - 0x30)) = ebx;
    *((ebp - 0x2c)) = esi;
    edx = *((ebp + 8));
    eax = caml_string_length (edx);
    eax += *((ebp + 8));
    if (edi != eax) {
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x20)) == 0xa) {
        eax = 0xffffffff;
        edx = 0x7fffffff;
        if (*((ebp - 0x1c)) < 0) {
            eax = 0;
            edx = 0x80000000;
        }
        if (edx > *((ebp - 0x2c))) {
            goto label_4;
        }
        if (edx >= *((ebp - 0x2c))) {
            if (eax >= *((ebp - 0x30))) {
                goto label_4;
            }
        }
        caml_failwith ("int_of_string");
    }
label_4:
    if (*((ebp - 0x1c)) < 0) {
        ebx = *((ebp - 0x30));
        esi = *((ebp - 0x2c));
        ebx = -ebx;
        esi += 0;
        esi = -esi;
    }
    caml_copy_int64 (ebx, esi);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c0a0 */
#include <stdint.h>
 
int32_t camlPrintf_bprintf_1400 (void) {
    ebx = eax;
    eax = loc.camlPrintf__41;
    return camlPrintf_kbprintf_1397 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bde0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2624 (void) {
    eax = unix_setgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e16d */
#include <stdint.h>
 
int32_t unix_mktime (int32_t arg_8h) {
    int32_t var_6ch;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    tm * timeptr;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13fd2;
    eax = *((ebp + 8));
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x5c)) = ecx;
    ecx = ebp - 0x5c;
    *(edx) = ecx;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 2;
    edx = ebp - 0x38;
    *((ebp - 0x50)) = edx;
    edx = ebp - 0x3c;
    *((ebp - 0x4c)) = edx;
    edx = *(eax);
    edx >>= 1;
    *((ebp - 0x34)) = edx;
    edx = *((eax + 4));
    edx >>= 1;
    *((ebp - 0x30)) = edx;
    edx = *((eax + 8));
    edx >>= 1;
    *((ebp - 0x2c)) = edx;
    edx = *((eax + 0xc));
    edx >>= 1;
    *((ebp - 0x28)) = edx;
    edx = *((eax + 0x10));
    edx >>= 1;
    *((ebp - 0x24)) = edx;
    edx = *((eax + 0x14));
    edx >>= 1;
    *((ebp - 0x20)) = edx;
    edx = *((eax + 0x18));
    edx >>= 1;
    *((ebp - 0x1c)) = edx;
    eax = *((eax + 0x1c));
    eax >>= 1;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = 0xffffffff;
    eax = ebp - 0x34;
    eax = mktime (eax);
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x1634;
        unix_error (0x22, eax, 0);
    }
    eax = ebp - 0x34;
    eax = alloc_tm ();
    *((ebp - 0x38)) = eax;
    *((ebp - 0x6c)) = esi;
    *(fp_stack--) = *((ebp - 0x6c));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x3c)) = eax;
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x3c));
    *(eax) = edx;
    edx = *((ebp - 0x38));
    *((eax + 4)) = edx;
    ecx = *((ebp - 0x5c));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a344 */
#include <stdint.h>
 
void mktime (void) {
    mktime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c828 */
#include <stdint.h>
 
int32_t unix_chown (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15913;
    esi = *((ebp + 8));
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = chown ();
    if (eax == -1) {
        eax = ebx - 0x16d0;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a5e4 */
#include <stdint.h>
 
void chown (void) {
    chown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059ea0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1584 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = edx;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = caml_make_vect;
    eax = caml_c_call (0xb);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x14));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x14));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0x10));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 9) {
            goto label_8;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0x10;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 9) {
            goto label_9;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x20)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d9c8 */
#include <stdint.h>
 
uint32_t unix_getlogin (void) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14778;
    eax = getlogin ();
    if (eax == 0) {
        eax = ebx - 0x1668;
        eax = unix_error (2, eax, 0);
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a064 */
#include <stdint.h>
 
void getlogin (void) {
    getlogin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054b20 */
#include <stdint.h>
 
int32_t camlList_remove_assoc_1189 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 8)) = ecx;
        ebx = *(ebx);
        *((esp + 4)) = ebx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 8));
        eax = camlList_remove_assoc_1189 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 4));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068811 */
#include <stdint.h>
 
int32_t caml_ml_channel_size_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_channel_size (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c170 */
#include <stdint.h>
 
int32_t camlUnix_fun_2728 (void) {
    eax = unix_unlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806452b */
#include <stdint.h>
 
int32_t caml_oldify_mopup (void) {
    uint32_t var_1ch;
    int32_t var_4h;
    goto label_1;
label_0:
    ebx = *(edi);
    esi = ebx + 4;
    eax = *(esi);
    *(obj.oldify_todo_list) = eax;
    eax = *(ebx);
    if ((al & 1) == 0) {
        if (eax >= *(obj.caml_young_end)) {
            goto label_2;
        }
        if (eax <= *(obj.caml_young_start)) {
            goto label_2;
        }
        caml_oldify_one (eax, ebx);
    }
label_2:
    ebx -= 4;
    eax = *(ebx);
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_1;
    }
    *((ebp - 0x1c)) = 1;
    do {
        edx = *((ebp - 0x1c));
        eax = *((edi + edx*4));
        if ((al & 1) == 0) {
            if (eax < *(obj.caml_young_end)) {
                if (eax <= *(obj.caml_young_start)) {
                    goto label_3;
                }
                eax = caml_oldify_one (eax, esi);
            }
        } else {
label_3:
            *(esi) = eax;
        }
        *((ebp - 0x1c))++;
        esi += 4;
        eax = *(ebx);
        eax >>= 0xa;
    } while (eax > *((ebp - 0x1c)));
label_1:
    edi = oldify_todo_list;
    if (edi != 0) {
        goto label_0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fa40 */
#include <stdint.h>
 
int32_t camlPervasives_output_value_1202 (void) {
    eax = caml_output_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055fa0 */
#include <stdint.h>
 
uint32_t camlString_contains_from_1132 (void) {
    esi = ebx;
    edx = ecx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    if (esi >= 1) {
        if (esi > ebx) {
            goto label_0;
        }
        eax = void (*0x8055ff0)() ();
        ecx = " %\a\b";
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        ecx = esi;
        camlString_index_rec_1108 (*(obj.caml_exception_pointer));
        eax = 3;
        return eax;
    }
label_0:
    eax = "String.contains_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bded */
#include <stdint.h>
 
uint32_t caml_sys_remove (char * path) {
    ebx = *((ebp + 8));
    eax = unlink (ebx);
    if (eax != 0) {
        caml_sys_error (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80545f0 */
#include <stdint.h>
 
int32_t camlList_rev_map2_1099 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80534d0;
            *((edx + 0xc)) = esi;
            eax = 1;
            void (*0x80534d0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067720 */
#include <stdint.h>
 
int32_t caml_float_of_int (int32_t arg_8h) {
    int32_t var_ch;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0xc));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055f40 */
#include <stdint.h>
 
void camlString_rindex_1125 (void) {
    ecx = ebx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    edx = *((eax + ebx));
    ebx -= edx;
    ebx = ebx + ebx - 1;
    return camlString_rindex_rec_1121 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067501 */
#include <stdint.h>
 
int32_t caml_log10_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    log10 (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a594 */
#include <stdint.h>
 
void log10 (void) {
    log10 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060ec8 */
#include <stdint.h>
 
int32_t unix_umask (int32_t m) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11278;
    eax = *((ebp + 8));
    eax >>= 1;
    umask (eax);
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a304 */
#include <stdint.h>
 
void umask (void) {
    umask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fae4 */
#include <stdint.h>
 
int32_t caml_read_directory (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_1ch;
    char * src;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = opendir ();
    *((ebp - 0x1c)) = eax;
    eax = 0xffffffff;
    if (*((ebp - 0x1c)) == 0) {
        goto label_1;
    }
    esi = 0x8071d35;
    do {
label_0:
        eax = *((ebp - 0x1c));
        *(esp) = eax;
        eax = readdir64 ();
        if (eax == 0) {
            goto label_2;
        }
        ebx = eax + 0x13;
        edi = ebx;
        edx = *(ebx);
        ecx = *(esi);
        if (edx != ecx) {
            goto label_3;
        }
        ecx = *((ebx + 1));
    } while (cl == *((esi + 1)));
label_3:
    ecx = 0x8071d34;
    ecx = *(ecx);
    if (edx != ecx) {
        goto label_4;
    }
    edx = *((edi + 1));
    if (dl != *(0x8071d35)) {
        goto label_4;
    }
    edx = *((edi + 2));
    if (dl == *(0x8071d36)) {
        goto label_0;
    }
label_4:
    edi = eax + 0x13;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    edi = eax;
    strcpy (eax, ebx);
    eax = *((ebp + 0xc));
    caml_ext_table_add (eax, edi);
    goto label_0;
label_2:
    ecx = *((ebp - 0x1c));
    *(esp) = ecx;
    closedir ();
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058a50 */
#include <stdint.h>
 
int32_t camlBuffer_advance_to_non_alpha_1108 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8058250;
            *((ecx + 0xc)) = edx;
            eax = *((edx - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            edx = *((edx + eax));
            eax -= edx;
            edx = eax + eax + 1;
            eax = ebx;
            ebx = edx;
            void (*0x8058250)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c150 */
#include <stdint.h>
 
int32_t camlUnix_fun_2724 (void) {
    eax = unix_link;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b0a0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1684 (void) {
    eax = loc.camlPrintf__54;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e8d6 */
#include <stdint.h>
 
int32_t unix_lseek (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13862;
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x15d8));
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = lseek64 ();
    edi = eax;
    esi = edx;
    caml_leave_blocking_section ();
    eax = edi;
    eax &= esi;
    if (eax == -1) {
        eax = ebx - 0x15de;
        uerror (eax, 0);
    }
    if (esi >= 0) {
        if (esi <= 0) {
            if (edi <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = ebx - 0x15de;
        unix_error (0x4b, eax, 0);
    }
label_0:
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80681cd */
#include <stdint.h>
 
int32_t caml_array_get_addr (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((edx + eax*4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b3d0 */
#include <stdint.h>
 
int32_t caml_tuplify3 (void) {
    edx = ebx;
    ecx = *((eax + 8));
    ebx = *((eax + 4));
    eax = *(eax);
    esi = *((edx + 8));
    return void (*esi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805af50 */
#include <stdint.h>
 
int32_t camlPrintf_pr_1354 (void) {
    *(esp) = eax;
    edi = ecx;
    eax = *((edi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edi + eax));
    eax -= ecx;
    ebp = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x88;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x84f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059260;
            *((ecx + 0xc)) = 0x10f9;
            *((ecx + 0x10)) = 0x804b2d0;
            *((ecx + 0x14)) = 7;
            *((ecx + 0x18)) = 0x8059230;
            *((ecx + 0x1c)) = 0x20f9;
            *((ecx + 0x20)) = 0x804b1f0;
            *((ecx + 0x24)) = 9;
            *((ecx + 0x28)) = 0x80591d0;
            *((ecx + 0x2c)) = 0x30f9;
            *((ecx + 0x30)) = 0x804b2d0;
            *((ecx + 0x34)) = 7;
            *((ecx + 0x38)) = 0x8059170;
            *((ecx + 0x3c)) = 0x40f9;
            *((ecx + 0x40)) = 0x804b370;
            *((ecx + 0x44)) = 5;
            *((ecx + 0x48)) = 0x8059140;
            *((ecx + 0x4c)) = 0x50f9;
            *((ecx + 0x50)) = 0x804b2d0;
            *((ecx + 0x54)) = 7;
            *((ecx + 0x58)) = 0x80590b0;
            eax = *((esi + 0xc));
            *((ecx + 0x5c)) = eax;
            eax = *((esi + 0x10));
            *((ecx + 0x60)) = eax;
            eax = *((esi + 0x14));
            *((ecx + 0x64)) = eax;
            eax = *((esi + 0x18));
            *((ecx + 0x68)) = eax;
            eax = *((esi + 0x1c));
            *((ecx + 0x6c)) = eax;
            *((ecx + 0x70)) = esi;
            eax = *(esp);
            *((ecx + 0x74)) = eax;
            *((ecx + 0x78)) = edi;
            *((ecx + 0x7c)) = edx;
            *((ecx + 0x80)) = ebp;
            edx = 1;
            eax = ebx;
            ebx = edx;
            void (*0x8059260)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f4e0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1394 (void) {
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054310 */
#include <stdint.h>
 
int32_t camlList_nth_1042 (void) {
    if (ebx < 1) {
        eax = "List.nth";
        void (*0x804f620)() ();
    }
    ecx = loc.camlList__48;
    return camlList_nth_aux_1045 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058090 */
#include <stdint.h>
 
int32_t camlHashtbl_entry (void) {
    eax = loc.camlHashtbl__16;
    *(0x8078534) = eax;
    eax = loc.camlHashtbl__15;
    *(loc.camlHashtbl) = eax;
    eax = loc.camlHashtbl__14;
    *(0x8078504) = eax;
    eax = loc.camlHashtbl__13;
    *(0x807850c) = eax;
    eax = loc.camlHashtbl__12;
    *(0x807852c) = eax;
    eax = loc.camlHashtbl__11;
    *(0x8078538) = eax;
    eax = loc.camlHashtbl__10;
    *(0x8078508) = eax;
    eax = loc.camlHashtbl__9;
    *(0x807851c) = eax;
    eax = loc.camlHashtbl__8;
    *(0x807853c) = eax;
    eax = loc.camlHashtbl__7;
    *(0x8078510) = eax;
    eax = loc.camlHashtbl__6;
    *(0x8078514) = eax;
    eax = loc.camlHashtbl__5;
    *(0x8078520) = eax;
    eax = loc.camlHashtbl__4;
    *(0x8078518) = eax;
    eax = loc.camlHashtbl__3;
    *(0x8078524) = eax;
    eax = loc.camlHashtbl__2;
    *(0x8078528) = eax;
    eax = camlHashtbl__1;
    *(0x8078530) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b6f0 */
#include <stdint.h>
 
int32_t camlPrintf_iter_on_format_args_1137 (void) {
    edx = eax;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    esi = *((edx + eax));
    eax -= esi;
    esi = eax + eax - 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x3c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x38f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x8059910;
            *((eax + 0xc)) = 0x10f9;
            *((eax + 0x10)) = 0x804b370;
            *((eax + 0x14)) = 5;
            *((eax + 0x18)) = 0x80596d0;
            *((eax + 0x1c)) = 0x20f9;
            *((eax + 0x20)) = 0x8059650;
            *((eax + 0x24)) = 3;
            *((eax + 0x28)) = edx;
            *((eax + 0x2c)) = ebx;
            *((eax + 0x30)) = ecx;
            *((eax + 0x34)) = esi;
            ebx = eax;
            ebx += 0x20;
            eax = 1;
            camlPrintf_scan_fmt_1144 ();
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059650 */
#include <stdint.h>
 
int32_t camlPrintf_scan_fmt_1144 (void) {
    do {
label_0:
        ecx = *((ebx + 0x14));
        if (eax >= ecx) {
            goto label_1;
        }
        esi = *((ebx + 8));
        edx = eax;
        edx >>= 1;
        ecx = *((esi - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edi = *((esi + ecx));
        ecx -= edi;
        if (ecx <= edx) {
            goto label_2;
        }
        ecx = *((esi + edx));
        ecx = ecx + ecx + 1;
        if (ecx != 0x4b) {
            goto label_3;
        }
        ecx = ebx;
        ecx += 0xffffffe0;
        ebx = eax;
        ebx += 2;
        eax = 1;
        eax = camlPrintf_scan_flags_1142 (ebx);
        ebx = *(esp);
    } while (1);
label_3:
    eax += 2;
    goto label_0;
label_1:
    return eax;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057410 */
#include <stdint.h>
 
int32_t camlHashtbl_clear_1054 (void) {
    edi = eax;
    ebx = 1;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 9;
    esi |= 1;
    esi += 0xfffffffe;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = *((edi + 4));
        eax = *((ecx - 4));
        eax >>= 9;
        if (eax <= ebx) {
            goto label_1;
        }
        caml_modify (ecx + ebx*2 - 2, 1);
        eax = ebx;
        ebx += 2;
    } while (eax != esi);
label_0:
    *(edi) = 1;
    eax = 1;
    return eax;
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054390 */
#include <stdint.h>
 
int32_t camlList_flatten_1058 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 4));
        ebx = *(eax);
        eax = ecx;
        eax = camlList_flatten_1058 (ebx);
    } while (1);
    ebx = eax;
    eax = *(esp);
    void (*0x804f8e0)() ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2580 (void) {
    eax = unix_getprotobynumber;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c8cc */
#include <stdint.h>
 
int32_t unix_close (int32_t fildes) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15874;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = close (eax);
    if (eax == -1) {
        eax = ebx - 0x170c;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a524 */
#include <stdint.h>
 
void close (void) {
    close ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067f41 */
#include <stdint.h>
 
int32_t caml_array_unsafe_set_addr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 0x10));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    ebx <<= 2;
    ebx += *((ebp + 8));
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_0;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_0;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_0;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_1;
            }
            if (edx < edi) {
                goto label_0;
            }
        }
label_1:
        eax = .comment;
        if (eax >= *(0x807ebcc)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807ebc8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80689f8 */
#include <stdint.h>
 
int32_t caml_input_scan_line (int32_t arg_8h) {
    void * s1;
    int32_t var_1ch;
    void * s2;
    size_t n;
    ebx = *((ebp + 8));
    esi = *((ebx + 0x10));
    edi = ebx + 0x34;
    *((ebp - 0x20)) = edi;
    *((ebp - 0x1c)) = edi;
    do {
        eax = *((ebx + 0x14));
        if (esi >= eax) {
            edx = *((ebx + 0x10));
            if (edx > edi) {
                eax -= edx;
                eax = *((ebp - 0x20));
                memmove (eax, edx, eax);
                eax = *((ebp - 0x1c));
                eax -= *((ebx + 0x10));
                edx = *((ebp - 0x1c));
                *((ebx + 0x10)) = edx;
                *((ebx + 0x14)) += eax;
                esi += eax;
            }
            edx = *((ebx + 0x14));
            eax = *((ebx + 0xc));
            if (edx >= eax) {
                eax = *((ebx + 0x10));
                eax -= edx;
                goto label_0;
            }
            eax -= edx;
            eax = *(ebx);
            eax = caml_do_read (eax, edx, eax);
            if (eax == 0) {
                eax = *((ebx + 0x10));
                eax -= *((ebx + 0x14));
                goto label_0;
            }
            ecx = eax;
            ecx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += ecx;
            *((ebx + 0x14)) += eax;
        }
        eax = *(esi);
        esi++;
    } while (al != 0xa);
    eax = esi;
    eax -= *((ebx + 0x10));
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f500 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1398 (void) {
    eax = caml_ml_pos_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bec0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2650 (void) {
    eax = unix_alarm;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059ab0 */
#include <stdint.h>
 
int32_t camlPrintf_add_conv_1191 (void) {
    *(esp) = ebx;
    if (ecx != 0x53) {
        if (ecx == 0xfb) {
            goto label_0;
        }
        edx = *((edx + 0xc));
        ebx = ecx;
        ecx = edx;
        camlPrintf_incr_ac_1187 ();
    }
label_0:
    eax = *(esp);
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bc9b */
#include <stdint.h>
 
uint32_t caml_sys_system_command (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    caml_string_length (eax);
    esi = eax + 1;
    eax = caml_stat_alloc (esi);
    ebx = eax;
    eax = *((ebp + 8));
    memmove (ebx, eax, esi);
    caml_enter_blocking_section ();
    eax = system (ebx);
    esi = eax;
    caml_leave_blocking_section ();
    caml_stat_free (ebx);
    if (esi == -1) {
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    eax = 0xff;
    if ((esi & 0x7f) == 0) {
        edx = esi;
        eax = (int32_t) dh;
    }
    *(obj.caml_local_roots) = edi;
    eax = eax + eax + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ee98 */
#include <stdint.h>
 
int32_t unix_rename (char * oldpath, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    char * newpath;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x132a3;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = rename (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x158b;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a054 */
#include <stdint.h>
 
void rename (void) {
    rename ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bee0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2654 (void) {
    eax = unix_localtime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059140 */
#include <stdint.h>
 
int32_t camlPrintf_cont_f_1364 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ecx + 0x28));
    eax = *((ecx + 0x2c));
    ecx = *(ebx);
    void (*ecx)(uint32_t, uint32_t, uint32_t) (ecx, eax, ebx);
    ecx = *(esp);
    ecx += 0xffffffc0;
    eax = *((esp + 4));
    ebx = *((esp + 8));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055df0 */
#include <stdint.h>
 
int32_t camlString_capitalize_1104 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_apply1_1100 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806125f */
#include <stdint.h>
 
uint32_t unix_waitpid (int32_t arg_8h, pid_t pid) {
    int32_t var_ch;
    int32_t wstatus;
    int32_t options;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x10ee0;
    eax = ebx + 0x95e4;
    eax = *((ebp + 8));
    eax = caml_convert_flag_list (eax, eax);
    esi = eax;
    caml_enter_blocking_section ();
    eax = ebp - 0xc;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = waitpid (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x1296;
        uerror (eax, 0);
    }
    edx = *((ebp - 0xc));
    eax = esi;
    alloc_process_status ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a434 */
#include <stdint.h>
 
void waitpid (void) {
    waitpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fb10 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_gen_1214 (void) {
    eax = caml_sys_open;
    eax = caml_c_call (ecx);
    eax = caml_ml_open_descriptor_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054440 */
#include <stdint.h>
 
int32_t camlList_rev_map_1067 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8053460;
            *((ecx + 0xc)) = edx;
            eax = 1;
            void (*0x8053460)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b170 */
#include <stdint.h>
 
void camlPrintf_to_string_1054 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    return camlString_sub_1046 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054f70 */
#include <stdint.h>
 
int32_t camlList_chop_1243 (void) {
    do {
        if (eax == 1) {
            eax = ebx;
            return eax;
        }
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 0xfffffffe;
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x807757c;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a382 */
#include <stdint.h>
 
int32_t caml_output_value_to_malloc (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    void * s2;
    size_t n;
    init_extern_output (ebx, esi, edi);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = extern_value ();
    ebx = eax;
    eax = malloc (eax);
    esi = eax;
    if (eax == 0) {
        extern_out_of_memory ();
    }
    eax = *((ebp + 0x10));
    *(eax) = esi;
    eax = *((ebp + 0x14));
    *(eax) = ebx;
    ebx = extern_output_first;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        edi = *((ebx + 4));
        edi -= eax;
        memmove (esi, eax, edi);
        esi += edi;
        ebx = *(ebx);
    } while (ebx != 0);
label_0:
    free_extern_output ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a5ba */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_2 (void) {
    edx = intern_src;
    eax = edx + 2;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    eax = *(edx);
    eax <<= 8;
    eax = ecx + eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053920 */
#include <stdint.h>
 
int32_t camlList_rev_sort_1272 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (eax != 5) {
        *((esp + 0x10)) = ecx;
        if (eax != 7) {
            goto label_7;
        }
        if (ebx == 1) {
            goto label_7;
        }
        esi = *((ebx + 4));
        if (esi == 1) {
            goto label_7;
        }
        edx = *((esi + 4));
        if (edx == 1) {
            goto label_7;
        }
        eax = *(edx);
        edx = *(esi);
        eax = *(ebx);
        ecx = *((ecx + 0xc));
        ebx = edx;
        eax = caml_apply2 (eax, edx, eax);
        if (eax > 1) {
            eax = *((esp + 0x10));
            ecx = *((eax + 0xc));
            eax = *((esp + 4));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax > 1) {
label_6:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_8;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
            eax = *((esp + 0x10));
            ecx = *((eax + 0xc));
            eax = *((esp + 8));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax > 1) {
label_5:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_9;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *(esp);
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0xc));
        eax = *((esp + 8));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax > 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_11;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0xc));
        eax = *((esp + 4));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax > 1) {
label_2:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_12;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 8));
        *(ebx) = eax;
        *((ebx + 4)) = 1;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 4));
        *(ecx) = eax;
        *((ecx + 4)) = ebx;
        ebx += 0x18;
        *((ebx - 4)) = 0x800;
        eax = *(esp);
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx;
        return eax;
    }
    if (ebx == 1) {
        goto label_14;
    }
    edx = *((ebx + 4));
    if (edx == 1) {
        goto label_15;
    }
    edx = *(edx);
    eax = *(ebx);
    ecx = *((ecx + 0xc));
    ebx = edx;
    eax = caml_apply2 (edx, eax);
    if (eax <= 1) {
        goto label_16;
    }
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_17;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x800;
    eax = *(esp);
    *(ecx) = eax;
    *((ecx + 4)) = 1;
    ebx = ecx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
    do {
label_16:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ecx) = eax;
            *((ecx + 4)) = 1;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_15:
            *((esp + 0x10)) = ecx;
            goto label_7;
label_14:
label_7:
            ecx = eax;
            ecx >>= 1;
            ecx |= 1;
            eax -= ecx;
            eax++;
            eax = ecx;
            eax = camlList_chop_1243 (ecx, ebx, eax);
            ecx = *((esp + 0x10));
            ecx += 0xfffffff0;
            eax = *(esp);
            ebx = *((esp + 4));
            eax = camlList_sort_1271 (eax);
            ecx = *((esp + 0x10));
            ecx += 0xfffffff0;
            eax = *((esp + 8));
            ebx = *((esp + 0xc));
            eax = camlList_sort_1271 (eax);
            ebx = eax;
            eax = *((esp + 0x10));
            edx = *((eax + 0x10));
            ecx = 1;
            eax = *(esp);
            void (*0x8053720)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053de0 */
#include <stdint.h>
 
int32_t camlList_sort_1271 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (eax != 5) {
        *((esp + 0x10)) = ecx;
        if (eax != 7) {
            goto label_7;
        }
        if (ebx == 1) {
            goto label_7;
        }
        esi = *((ebx + 4));
        if (esi == 1) {
            goto label_7;
        }
        edx = *((esi + 4));
        if (edx == 1) {
            goto label_7;
        }
        eax = *(edx);
        edx = *(esi);
        eax = *(ebx);
        ecx = *((ecx + 0x1c));
        ebx = edx;
        eax = caml_apply2 (eax, edx, eax);
        if (eax <= 1) {
            eax = *((esp + 0x10));
            ecx = *((eax + 0x1c));
            eax = *((esp + 4));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax <= 1) {
label_6:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_8;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
            eax = *((esp + 0x10));
            ecx = *((eax + 0x1c));
            eax = *((esp + 8));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax <= 1) {
label_5:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_9;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *(esp);
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0x1c));
        eax = *((esp + 8));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax <= 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_11;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0x1c));
        eax = *((esp + 4));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax <= 1) {
label_2:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_12;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 8));
        *(ebx) = eax;
        *((ebx + 4)) = 1;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 4));
        *(ecx) = eax;
        *((ecx + 4)) = ebx;
        ebx += 0x18;
        *((ebx - 4)) = 0x800;
        eax = *(esp);
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx;
        return eax;
    }
    if (ebx == 1) {
        goto label_14;
    }
    edx = *((ebx + 4));
    if (edx == 1) {
        goto label_15;
    }
    edx = *(edx);
    eax = *(ebx);
    ecx = *((ecx + 0x1c));
    ebx = edx;
    eax = caml_apply2 (edx, eax);
    if (eax > 1) {
        goto label_16;
    }
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_17;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x800;
    eax = *(esp);
    *(ecx) = eax;
    *((ecx + 4)) = 1;
    ebx = ecx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
    do {
label_16:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ecx) = eax;
            *((ecx + 4)) = 1;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_15:
            *((esp + 0x10)) = ecx;
            goto label_7;
label_14:
label_7:
            ecx = eax;
            ecx >>= 1;
            ecx |= 1;
            eax -= ecx;
            eax++;
            eax = ecx;
            eax = camlList_chop_1243 (ecx, ebx, eax);
            ecx = *((esp + 0x10));
            ecx += 0x10;
            eax = *(esp);
            ebx = *((esp + 4));
            eax = camlList_rev_sort_1272 (eax);
            ecx = *((esp + 0x10));
            ecx += 0x10;
            eax = *((esp + 8));
            ebx = *((esp + 0xc));
            eax = camlList_rev_sort_1272 (eax);
            ebx = eax;
            eax = *((esp + 0x10));
            edx = *((eax + 0x24));
            ecx = 1;
            eax = *(esp);
            void (*0x8053820)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c6e8 */
#include <stdint.h>
 
int32_t unix_alarm (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15a58;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    alarm ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a3d4 */
#include <stdint.h>
 
void alarm (void) {
    alarm ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061bea */
#include <stdint.h>
 
int32_t caml_failwith (void) {
    int32_t var_4h_6;
    int32_t var_4h_5;
    eax = *((ebp + 8));
    return caml_raise_with_string (loc.caml_exn_Failure, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2584 (void) {
    eax = unix_gethostbyaddr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058dc0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_sub_1129 (void) {
    ecx = *((ebx + 0x14));
    if (eax >= ecx) {
        edx = *((ebx + 8));
        eax = *((ebx + 0x10));
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)() ();
    }
    edx = *((ebx + 0x10));
    ecx = eax;
    ecx >>= 1;
    esi = *((edx - 4));
    esi >>= 0xa;
    esi = esi*4 - 1;
    edi = *((edx + esi));
    esi -= edi;
    if (esi > ecx) {
        ecx = *((edx + ecx));
        edx = ecx + ecx + 1;
        ecx = edx;
        ecx += 0xffffffb0;
        if (ecx > 3) {
            ecx += 0xffffff5a;
            if (ecx > 5) {
                goto label_0;
            }
            *(esp) = ebx;
            ecx >>= 1;
            if (ecx < 1) {
                goto label_1;
            }
            if (ecx == 1) {
                goto label_0;
            }
            if (ecx > 1) {
                goto label_2;
            }
        }
        if (ecx == 1) {
            *(esp) = ebx;
            goto label_1;
label_0:
            ebx += 0xfffffff4;
            eax += 2;
            void (*0x8058ea0)() ();
label_1:
            ecx = *((ebx + 0x18));
            ebx = eax;
            ebx += 2;
            eax = edx;
            eax = camlPrintf_sub_fmt_1124 ();
            ebx = *(esp);
            ebx += 0xfffffff4;
            eax += 2;
            void (*0x8058ea0)() ();
        }
label_2:
        ecx = *((ebx + 0x20));
        if (edx == ecx) {
            eax += 2;
            return eax;
        }
        esi = *((ebx + 0xc));
        ecx = *((ebx + 0x1c));
        eax = *((ebx + 0x10));
        ebx = ecx;
        ecx = edx;
        edx = esi;
        void (*0x804b4f0)() ();
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ba6d */
#include <stdint.h>
 
int32_t caml_sys_getenv (char * name) {
    eax = *((ebp + 8));
    eax = getenv (eax);
    if (eax == 0) {
        eax = caml_raise_not_found ();
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ffa0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1487 (void) {
    eax = caml_ml_pos_out_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c180 */
#include <stdint.h>
 
int32_t camlUnix_fun_2730 (void) {
    eax = unix_isatty;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c1a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2734 (void) {
    eax = unix_lstat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063022 */
#include <stdint.h>
 
void caml_fl_init_merge (void) {
    *(obj.last_fragment) = 0;
    *(obj.caml_fl_merge) = 0x807b788;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805fc9d */
#include <stdint.h>
 
int32_t alloc_inet6_addr (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1249e;
    esi = *((ebp + 8));
    caml_alloc_string (0x10);
    edx = *(esi);
    *(eax) = edx;
    edx = *((esi + 4));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    *((eax + 0xc)) = edx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b850 */
#include <stdint.h>
 
int32_t camlPrintf_ac_of_format_1184 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x38;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = 1;
            *((ebx + 4)) = 1;
            *((ebx + 8)) = 1;
            eax = ebx + 0x10;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x8059a50;
            *((eax + 0xc)) = ebx;
            ebx += 0x24;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x8059ab0;
            *((ebx + 0xc)) = eax;
            ecx = loc.camlPrintf__46;
            eax = edx;
            camlPrintf_iter_on_format_args_1137 (ebx);
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cd96 */
#include <stdint.h>
 
uint32_t unix_set_close_on_exec (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x153a5;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 1;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        eax |= 1;
        *((esp + 8)) = eax;
        *((esp + 4)) = 2;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x16b6;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806668b */
#include <stdint.h>
 
int32_t caml_nativeint_xor (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax ^= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056ae0 */
#include <stdint.h>
 
int32_t camlHashtbl_do_bucket_1142 (void) {
    int32_t var_4h;
    do {
        esi = ebx;
        if (eax == 1) {
            goto label_0;
        }
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        eax = *(eax);
        edx = *((ecx + 0xc));
        ecx = esi;
        eax = caml_apply3 (ebx, ecx);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
label_0:
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066f8a */
#include <stdint.h>
 
int32_t caml_eq_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] == fp_stack[1]) ? 1 : 0;
    __asm ("setnp dl");
    eax &= edx;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055690 */
#include <stdint.h>
 
int32_t camlString_fill_1051 (void) {
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        esi = *((eax - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((eax + esi));
        esi -= edi;
        esi <<= 1;
        esi -= ecx;
        esi += 2;
        if (ebx > esi) {
            goto label_0;
        }
        caml_fill_string (eax, ebx, ecx, edx);
        return;
    }
label_0:
    eax = "String.fill";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f6e0 */
#include <stdint.h>
 
int32_t camlPervasives_abs_1044 (void) {
    if (eax >= 1) {
        return;
    }
    ebx = 2;
    ebx -= eax;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf00 */
#include <stdint.h>
 
int32_t camlUnix_fun_2658 (void) {
    eax = unix_gettimeofday;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c5f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2794 (void) {
    eax = unix_lseek_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d613 */
#include <stdint.h>
 
int32_t unix_getgrnam (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14b2d;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getgrnam ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_group_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f84 */
#include <stdint.h>
 
void getgrnam (void) {
    getgrnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c5d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2798 (void) {
    eax = unix_ftruncate_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061b98 */
#include <stdint.h>
 
int32_t caml_raise_sys_error (void) {
    int32_t var_4h_3;
    int32_t var_4h_2;
    eax = *((ebp + 8));
    return caml_raise_with_arg ("t$\a\b", eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80595c0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_fmt_1124 (void) {
    edx = ebx;
    if (eax == 0x51) {
        esi = 0x53;
    } else {
        esi = 0xfb;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x34;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x30f7;
            *(ebx) = sym.camlPrintf__sub_1128;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = 0xcf9;
            *((ebx + 0xc)) = 0x8058dc0;
            *((ebx + 0x10)) = 3;
            eax = *((ecx + 0xc));
            *((ebx + 0x14)) = eax;
            eax = *((ecx + 0x10));
            *((ebx + 0x18)) = eax;
            eax = *((ecx + 0x14));
            *((ebx + 0x1c)) = eax;
            eax = *((ecx + 0x18));
            *((ebx + 0x20)) = eax;
            *((ebx + 0x24)) = ecx;
            *((ebx + 0x28)) = edx;
            *((ebx + 0x2c)) = esi;
            eax = edx;
            void (*0x8058ea0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bca0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2588 (void) {
    eax = unix_gethostname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80670a7 */
#include <stdint.h>
 
void caml_init_ieee_floats (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065c0d */
#include <stdint.h>
 
int32_t caml_greaterthan (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x807f400) {
        compare_free_stack ();
    }
    al = (ebx > 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068c12 */
#include <stdint.h>
 
uint32_t caml_refill (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebx + 0x34;
    edx = *((ebx + 0xc));
    edx -= eax;
    eax = *(ebx);
    eax = caml_do_read (ebx, eax, edx);
    if (eax == 0) {
        eax = caml_raise_end_of_file ();
    }
    ecx = eax;
    ecx >>= 0x1f;
    *((ebx + 4)) += eax;
    *((ebx + 8)) += ecx;
    eax = ebx + eax + 0x34;
    *((ebx + 0x14)) = eax;
    eax = ebx + 0x35;
    *((ebx + 0x10)) = eax;
    eax = *((ebx + 0x34));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806887a */
#include <stdint.h>
 
int32_t caml_do_read (int32_t arg_8h, void * arg_ch, size_t arg_10h) {
    void * buf;
    size_t nbyte;
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    do {
        caml_enter_blocking_section (ebx, esi, edi);
        eax = *((ebp + 0x10));
        eax = read (esi, edi, eax);
        ebx = eax;
        caml_leave_blocking_section ();
        if (ebx != -1) {
            goto label_0;
        }
        eax = errno_location ();
    } while (*(eax) == 4);
    caml_sys_io_error (1);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061cab */
#include <stdint.h>
 
void caml_raise_end_of_file (void) {
    return caml_raise_constant (loc.caml_exn_End_of_file);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c960 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_float_1664 (void) {
    eax = unix_getsockopt;
    caml_c_call (7);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c140 */
#include <stdint.h>
 
uint32_t camlPrintf_ksprintf_1411 (void) {
    ebx = .comment;
    ecx = *(ebx);
    eax = void (*ecx)() ();
    edi = eax;
    ebp = .comment;
    esi = loc.camlPrintf__40;
    edx = .comment;
    ecx = .comment;
    ebx = .comment;
    eax = 3;
    *(loc.caml_extra_params) = ebp;
    return caml_apply6 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b090 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1680 (void) {
    eax = *((ebx + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c1c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2738 (void) {
    eax = unix_ftruncate;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e044 */
#include <stdint.h>
 
uint32_t unix_getsockname (int32_t sockfd) {
    int32_t var_7ch;
    int32_t var_78h;
    struct sockaddr * addr;
    socklen_t * addrlen;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x140f9;
    *((ebp - 0x7c)) = 0x70;
    eax = ebp - 0x7c;
    eax = ebp - 0x78;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = getsockname (eax, eax, eax);
    if (eax == -1) {
        eax = ebx - 0x1640;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x7c));
    eax = ebp - 0x78;
    alloc_sockaddr (eax, eax, 0xffffffff);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e94 */
#include <stdint.h>
 
void getsockname (void) {
    getsockname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053720 */
#include <stdint.h>
 
int32_t camlList_rev_merge_1251 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        if (eax == 1) {
            goto label_2;
        }
        if (ebx == 1) {
            goto label_3;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((edx + 0xc));
        eax = caml_apply2 (edx, eax, ecx);
        if (eax > 1) {
            goto label_4;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 0xc));
        *(ecx) = eax;
        eax = *((esp + 0x10));
        *((ecx + 4)) = eax;
        eax = *((esp + 0x14));
        ebx = *((esp + 0x18));
        edx = *((esp + 0x1c));
    } while (1);
    do {
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            eax = *((esp + 0x10));
            *((ecx + 4)) = eax;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            edx = *((esp + 0x1c));
            goto label_0;
label_3:
            ebx = ecx;
            void (*0x8054330)() ();
label_2:
            eax = ebx;
            ebx = ecx;
            void (*0x8054330)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066ad6 */
#include <stdint.h>
 
int32_t caml_int64_xor (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx ^= *((eax + 4));
    edx = *((edx + 8));
    edx ^= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055d60 */
#include <stdint.h>
 
int32_t camlString_uppercase_1096 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_map_1090 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056b40 */
#include <stdint.h>
 
int32_t camlHashtbl_add_1179 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    esi = *((eax + 4));
    esi = *((esi - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = *((edx + 0xc));
        eax = *((eax + 8));
        edx = *((eax + 4));
        ecx = *(edx);
        eax = ebx;
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (esi, ecx, eax);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 0x10));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            ebx = *((esp + 8));
            esi = *((ebx + 4));
            ecx = *((esi - 4));
            ecx >>= 9;
            if (ecx <= edx) {
                goto label_0;
            }
            ecx = *((esi + edx*2 - 2));
            *((eax + 8)) = ecx;
            esi = *((ebx + 4));
            ecx = *((esi - 4));
            ecx >>= 9;
            if (ecx <= edx) {
                goto label_1;
            }
            caml_modify (esi + edx*2 - 2, eax);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = *((esp + 0xc));
                eax = *((eax + 0xc));
                void (*0x80574c0)() ();
            }
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fed0 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_newline_1287 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x80755d8));
    eax = caml_ml_flush;
    caml_c_call (*(0x80755d8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f7d4 */
#include <stdint.h>
 
int32_t unix_setuid (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1296c;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = setuid ();
    if (eax == -1) {
        eax = ebx - 0x1542;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a324 */
#include <stdint.h>
 
void setuid (void) {
    setuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067268 */
#include <stdint.h>
 
int32_t caml_log1p_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_log1p ();
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80670d4 */
#include <stdint.h>
 
void caml_log1p (void) {
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    log1p (ebp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049eb4 */
#include <stdint.h>
 
void log1p (void) {
    log1p ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c980 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_float_1667 (void) {
    eax = unix_setsockopt;
    caml_c_call (7);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ac00 */
#include <stdint.h>
 
int32_t caml_curry9_6 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_7;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806836c */
#include <stdint.h>
 
int32_t caml_ml_pos_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_out (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f980 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_bin_1181 (void) {
    ecx = eax;
    ebx = 0x36d;
    eax = loc.camlPervasives__93;
    return camlPervasives_open_out_gen_1175 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f634 */
#include <stdint.h>
 
int32_t caml_final_update (void) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    esi = old;
    if (esi == 0) {
        goto label_2;
    }
    edx = final_table;
    ebx = 0;
    eax = 0;
    do {
        ecx = *((edx + 4));
        ecx = *((ecx - 4));
        ecx &= 0x300;
        ebx += 0;
        eax++;
        edx += 0xc;
    } while (eax < esi);
    if (ebx == 0) {
        goto label_2;
    }
    eax = ebx * 3;
    eax = eax*4 + 0x14;
    eax = malloc (eax);
    if (eax == 0) {
        caml_fatal_error ("out of memory");
    }
    *(eax) = 0;
    *((eax + 4)) = ebx;
    edx = to_do_tl;
    if (edx == 0) {
        *(obj.to_do_hd) = eax;
        *(obj.to_do_tl) = eax;
    } else {
        *(edx) = eax;
        *(obj.to_do_tl) = eax;
    }
    eax = old;
    *((ebp - 0x30)) = eax;
    if (eax == 0) {
        goto label_3;
    }
    edx = final_table;
    *((ebp - 0x38)) = edx;
    ecx = to_do_tl;
    *((ebp - 0x2c)) = ecx;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x34)) = 0;
    *((ebp - 0x28)) = 0;
    edi = caml_page_table;
    do {
        *((ebp - 0x3c)) = edx;
label_0:
        ecx = *((edx + 4));
        eax = ecx - 4;
        if ((*(eax) & 0x300) == 0) {
            if (*(eax) == 0xfa) {
                eax = *(ecx);
                if ((al & 1) == 0) {
                    *((ebp - 0x20)) = eax;
                    ebx = eax;
                    ebx >>= 0x17;
                    ecx = eax;
                    ecx >>= 0xc;
                    ecx &= 0x7ff;
                    *((ebp - 0x1c)) = ecx;
                    esi = *((edi + ebx*4));
                    if ((*((esi + ecx)) & 7) != 0) {
                        ecx = *((eax - 4));
                        if (cl != 0xfa) {
                            if (cl != 0xf6) {
                                if (cl != 0xfd) {
                                    goto label_4;
                                }
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                                *((esi + 4)) = eax;
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                            } else {
                            } else {
                            } else {
                            } else {
                            } else {
                                esi = *((ebp - 0x3c));
                            }
                        }
                    }
                }
            }
label_1:
            ebx = *((ebp - 0x24));
            eax = ebx * 3;
            eax <<= 2;
            ecx = *(esi);
            ebx = *((ebp - 0x2c));
            *((eax + ebx + 8)) = ecx;
            ecx = *((esi + 4));
            *((eax + ebx + 0xc)) = ecx;
            ecx = *((esi + 8));
            *((eax + ebx + 0x10)) = ecx;
            *((ebp - 0x24))++;
        } else {
            esi = *((ebp - 0x3c));
            ecx = *((ebp - 0x34));
            eax = ecx * 3;
            eax <<= 2;
            ecx = *(esi);
            ebx = *((ebp - 0x38));
            *((eax + ebx)) = ecx;
            ecx = *((esi + 4));
            *((eax + ebx + 4)) = ecx;
            ecx = *((esi + 8));
            *((eax + ebx + 8)) = ecx;
            *((ebp - 0x34))++;
        }
        *((ebp - 0x28))++;
        edx += 0xc;
        esi = *((ebp - 0x28));
    } while (*((ebp - 0x30)) > esi);
    eax = *((ebp - 0x34));
    *(obj.old) = eax;
    *(obj.young) = eax;
    ecx = *((ebp - 0x24));
    edx = *((ebp - 0x2c));
    *((edx + 4)) = ecx;
    if (ecx == 0) {
        goto label_2;
    }
    ebx = 0;
    esi = ecx;
    do {
        eax = ebx * 3;
        eax <<= 2;
        eax += *(obj.to_do_tl);
        eax = *((eax + 0xc));
        eax = caml_darken (eax, 0);
        ebx++;
    } while (ebx < esi);
    goto label_2;
label_4:
    *((edx + 4)) = eax;
    eax = *((edi + ebx*4));
    ebx = *((ebp - 0x1c));
    if ((*((eax + ebx)) & 1) != 0) {
        goto label_0;
    }
    esi = *((ebp - 0x3c));
    goto label_1;
label_3:
    *(obj.old) = 0;
    *(obj.young) = 0;
    eax = to_do_tl;
    *((eax + 4)) = 0;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fa90 */
#include <stdint.h>
 
void camlPervasives_close_out_noerr_1211 (void) {
    *(esp) = eax;
    fcn_0804faa0 ();
    return void (*0x804fac3)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804faa0 */
#include <stdint.h>
 
int32_t fcn_0804faa0 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_flush;
    caml_c_call (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fae0 */
#include <stdint.h>
 
int32_t fcn_0804fae0 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fac3 */
#include <stdint.h>
 
int32_t fcn_0804fac3 (void) {
    fcn_0804fae0 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b230 */
#include <stdint.h>
 
uint32_t caml_input_value_from_block (int32_t arg_8h, uint32_t arg_ch) {
    edx = *((ebp + 8));
    *(obj.intern_input) = edx;
    *(obj.intern_input_malloced) = 0;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith ("input_value_from_block: bad object");
    }
    eax += 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *((eax - 4));
    edx <<= 0x18;
    edx = ecx + edx + 0x14;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    ecx = edx + ecx;
    edx = *((eax - 2));
    edx <<= 8;
    eax = ecx + edx;
    if (eax > *((ebp + 0xc))) {
        caml_failwith ("input_value_from_block: bad block length");
    }
    input_val_from_block ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fdb0 */
#include <stdint.h>
 
int32_t camlPervasives_print_endline_1274 (void) {
    ebx = eax;
    eax = .comment;
    camlPervasives_output_string_1191 ();
    eax = caml_ml_output_char;
    caml_c_call (*(0x80755d4));
    eax = caml_ml_flush;
    caml_c_call (*(0x80755d4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b110 */
#include <stdint.h>
 
int32_t caml_curry5_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067cec */
#include <stdint.h>
 
int32_t caml_array_unsafe_get_float (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + edx*8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806253a */
#include <stdint.h>
 
int32_t caml_register_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = caml_global_roots;
    caml_insert_global_root ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f5a0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1418 (void) {
    eax = caml_ml_output_int;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bff0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2684 (void) {
    eax = unix_rewinddir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062786 */
#include <stdint.h>
 
int32_t caml_remove_generational_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *(edx);
    if ((al & 1) != 0) {
        goto label_0;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_1;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_1;
    }
    eax = caml_global_roots_young;
    caml_delete_global_root ();
    goto label_0;
    do {
        eax = caml_global_roots_old;
        eax = caml_delete_global_root ();
        goto label_0;
label_1:
        ecx = eax;
        ecx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
    } while ((*((ecx + eax)) & 1) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c5b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2802 (void) {
    eax = unix_lstat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054550 */
#include <stdint.h>
 
int32_t camlList_map2_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        eax = camlList_map2_1090 (eax);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 0xc));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            if (ecx == 1) {
                eax = 1;
                return eax;
            }
label_1:
            eax = "List.map2";
            void (*0x804f620)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cc74 */
#include <stdint.h>
 
int32_t unix_fchmod (void) {
    int32_t fd;
    int32_t mode;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x154cc;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = fchmod (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x16d8;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066c9f */
#include <stdint.h>
 
int32_t caml_int64_add (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    ebx = *((eax + 8));
    edx = *((ebp + 8));
    eax = *((edx + 4));
    edx = *((edx + 8));
    eax += ecx;
    edx += ebx;
    caml_copy_int64 (ebx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c010 */
#include <stdint.h>
 
int32_t camlUnix_fun_2688 (void) {
    eax = unix_opendir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058140 */
#include <stdint.h>
 
int32_t camlBuffer_advance_1104 (void) {
    int32_t var_4h;
    do {
label_0:
        if (ebx >= ecx) {
label_1:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            eax = caml_raise_exn ();
        }
        *((esp + 4)) = ecx;
        *(esp) = eax;
        edi = *((edx + 0xc));
        ecx = *((edx + 0x14));
        eax = ebx;
        eax >>= 1;
        esi = *((ecx - 4));
        esi >>= 0xa;
        ebp = esi*4 - 1;
        esi = *((ecx + ebp));
        ebp -= esi;
        if (ebp <= eax) {
            goto label_3;
        }
        eax = *((ecx + eax));
        eax = eax + eax + 1;
        if (eax != edi) {
            goto label_4;
        }
        ebx += 2;
        eax = *(esp);
        eax += 2;
        ecx = *((esp + 4));
    } while (1);
label_4:
    edi = *((edx + 0x10));
    ecx = *((edx + 0x14));
    eax = ebx;
    eax >>= 1;
    esi = *((ecx - 4));
    esi >>= 0xa;
    ebp = esi*4 - 1;
    esi = *((ecx + ebp));
    ebp -= esi;
    if (ebp > eax) {
        eax = *((ecx + eax));
        eax = eax + eax + 1;
        if (eax == edi) {
            eax = *(esp);
            if (eax == 1) {
                eax = ebx;
                return eax;
            }
            ebx += 2;
            eax += 0xfffffffe;
            ecx = *((esp + 4));
            goto label_0;
        }
        ebx += 2;
        eax = *(esp);
        ecx = *((esp + 4));
        goto label_0;
label_2:
        caml_call_gc ();
        goto label_1;
    }
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fd60 */
#include <stdint.h>
 
int32_t camlPervasives_print_string_1268 (void) {
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bad8 */
#include <stdint.h>
 
int32_t caml_sys_exit (int32_t status) {
    eax = *((ebp + 8));
    eax >>= 1;
    return exit (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a894 */
#include <stdint.h>
 
void exit (void) {
    exit ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bfd0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2680 (void) {
    eax = unix_pipe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f560 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1410 (void) {
    eax = caml_ml_set_binary_mode;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055f60 */
#include <stdint.h>
 
int32_t camlString_rindex_from_1128 (void) {
    if (ebx >= -1) {
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx = edx + edx + 1;
        if (ebx >= edx) {
            goto label_0;
        }
        void (*0x8055ee0)() ();
    }
label_0:
    eax = "String.rindex_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b160 */
#include <stdint.h>
 
void camlPrintf_sub_1050 (void) {
    return camlString_sub_1046 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80588e0 */
#include <stdint.h>
 
void camlBuffer_add_buffer_1087 (void) {
    edx = *((ebx + 4));
    ecx = 1;
    ebx = *(ebx);
    return camlBuffer_add_substring_1076 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052b10 */
#include <stdint.h>
 
int32_t camlArray_fold_right_1145 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x400;
    *(esi) = ecx;
    ecx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    ecx += 0xfffffffe;
    if (ecx < 1) {
        goto label_3;
    }
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = esi;
    *(esp) = ebx;
    *((esp + 4)) = edx;
    do {
        ebx = *(esp);
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            eax = *((ebx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *(esi);
        ecx = *((esp + 4));
        eax = caml_apply2 ();
        esi = *((esp + 0xc));
        caml_modify (esi, eax);
        ecx = *((esp + 0xc));
        eax = *((esp + 0xc));
        ecx -= 2;
        *((esp + 0xc)) = ecx;
    } while (eax != 1);
label_3:
    eax = *(esi);
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dfc7 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t unix_getservbyport (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14179;
    eax = *((ebp + 8));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = (int32_t) ax;
    *(esp) = eax;
    eax = getservbyport ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_service_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a194 */
#include <stdint.h>
 
void getservbyport (void) {
    getservbyport ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050e60 */
#include <stdint.h>
 
uint32_t camlArray_trickledown_1160 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
        ecx = *((edx + 0x14));
        eax = camlArray_maxson_1155 (ebx, eax, ecx);
        ebx = eax;
        *((esp + 0x10)) = ebx;
        edx = *(esp);
        ecx = *((edx + 0x10));
        eax = *((ecx - 4));
        esi = *((ecx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_2;
            }
            eax = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_3;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((edx + 0xc));
        ebx = *((esp + 8));
        eax = caml_apply2 ();
        if (eax <= 1) {
            goto label_5;
        }
        esi = *(esp);
        ecx = *((esi + 0x10));
        eax = *((ecx - 4));
        ebx = *((ecx - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            ebx = *((esp + 0x10));
            if (eax <= ebx) {
                goto label_6;
            }
            edx = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            ebx = *((esp + 0x10));
            if (eax <= ebx) {
                goto label_7;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_8;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi + 0x10));
        edi = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            edi >>= 9;
            ecx = *((esp + 0xc));
            if (edi <= ecx) {
                goto label_9;
            }
            caml_modify (eax + ecx*2 - 2, edx);
        } else {
            edi >>= 0xa;
            ecx = *((esp + 0xc));
            if (edi <= ecx) {
                goto label_10;
            }
            *(fp_stack--) = *(edx);
            *((eax + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        ecx = *((esp + 8));
        edx = esi;
    } while (1);
label_5:
    eax = *(esp);
    eax = *((eax + 0x10));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        ecx = *((esp + 0xc));
        if (ebx <= ecx) {
            goto label_11;
        }
        ebx = *((esp + 8));
        caml_modify (eax + ecx*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        ecx = *((esp + 0xc));
        if (ebx <= ecx) {
            goto label_12;
        }
        ebx = *((esp + 8));
        *(fp_stack--) = *(ebx);
        *((eax + ecx*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_8:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066dff */
#include <stdint.h>
 
int32_t caml_int32_shift_left (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax <<= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f580 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1414 (void) {
    eax = caml_ml_pos_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a9d0 */
#include <stdint.h>
 
int32_t loc_caml_startup_code_begin (void) {
    camlPervasives_entry ();
    *(obj.caml_globals_inited)++;
    camlArray_entry ();
    *(obj.caml_globals_inited)++;
    camlList_entry ();
    *(obj.caml_globals_inited)++;
    camlChar_entry ();
    *(obj.caml_globals_inited)++;
    camlString_entry ();
    *(obj.caml_globals_inited)++;
    camlSys_entry ();
    *(obj.caml_globals_inited)++;
    camlHashtbl_entry ();
    *(obj.caml_globals_inited)++;
    camlBuffer_entry ();
    *(obj.caml_globals_inited)++;
    camlPrintf_entry ();
    *(obj.caml_globals_inited)++;
    camlCallback_entry ();
    *(obj.caml_globals_inited)++;
    camlUnix_entry ();
    *(obj.caml_globals_inited)++;
    camlUnixLabels_code_begin ();
    *(obj.caml_globals_inited)++;
    camlSource_entry ();
    *(obj.caml_globals_inited)++;
    camlStd_exit_entry ();
    *(obj.caml_globals_inited)++;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80550c0 */
#include <stdint.h>
 
int32_t camlList_entry (void) {
    eax = loc.camlList__38;
    *(0x807731c) = eax;
    eax = loc.camlList__37;
    *(loc.camlList) = eax;
    eax = loc.camlList__36;
    *(0x807727c) = eax;
    eax = loc.camlList__35;
    *(0x8077280) = eax;
    eax = loc.camlList__34;
    *(0x8077284) = eax;
    eax = .comment;
    *(0x807728c) = eax;
    eax = loc.camlList__33;
    *(0x8077290) = eax;
    eax = loc.camlList__32;
    *(0x8077288) = eax;
    eax = loc.camlList__31;
    *(0x8077298) = eax;
    eax = .comment;
    *(0x8077294) = eax;
    eax = loc.camlList__30;
    *(0x80772a0) = eax;
    eax = loc.camlList__29;
    *(0x80772a4) = eax;
    eax = loc.camlList__28;
    *(0x807729c) = eax;
    eax = loc.camlList__27;
    *(0x80772a8) = eax;
    eax = loc.camlList__26;
    *(0x80772ac) = eax;
    eax = loc.camlList__25;
    *(0x80772b4) = eax;
    eax = loc.camlList__24;
    *(0x80772b8) = eax;
    eax = loc.camlList__23;
    *(0x80772b0) = eax;
    eax = loc.camlList__22;
    *(0x80772bc) = eax;
    eax = loc.camlList__21;
    *(0x80772c0) = eax;
    eax = loc.camlList__20;
    *(0x80772c4) = eax;
    eax = loc.camlList__19;
    *(0x80772c8) = eax;
    eax = loc.camlList__18;
    *(0x80772cc) = eax;
    eax = loc.camlList__17;
    *(0x80772d0) = eax;
    eax = loc.camlList__16;
    *(0x80772d4) = eax;
    eax = loc.camlList__15;
    *(0x80772d8) = eax;
    eax = loc.camlList__14;
    *(0x80772ec) = eax;
    eax = loc.camlList__13;
    *(0x80772f0) = eax;
    eax = loc.camlList__12;
    *(0x80772f4) = eax;
    eax = loc.camlList__11;
    *(0x80772f8) = eax;
    eax = loc.camlList__10;
    *(0x80772fc) = eax;
    eax = loc.camlList__9;
    *(0x8077300) = eax;
    eax = loc.camlList__8;
    *(0x80772dc) = eax;
    eax = loc.camlList__7;
    *(0x80772e4) = eax;
    eax = .comment;
    *(0x80772e0) = eax;
    eax = loc.camlList__6;
    *(0x80772e8) = eax;
    eax = loc.camlList__5;
    *(0x8077304) = eax;
    eax = loc.camlList__4;
    *(0x8077308) = eax;
    eax = loc.camlList__3;
    *(0x8077318) = eax;
    eax = loc.camlList__2;
    *(0x8077320) = eax;
    eax = camlList__1;
    *(0x8077310) = eax;
    eax = .comment;
    *(0x807730c) = eax;
    eax = .comment;
    *(0x8077314) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055460 */
#include <stdint.h>
 
int32_t camlChar_entry (void) {
    eax = loc.camlChar__5;
    *(loc.camlChar) = eax;
    eax = loc.camlChar__4;
    *(0x8077df4) = eax;
    eax = loc.camlChar__3;
    *(0x8077df8) = eax;
    eax = loc.camlChar__2;
    *(0x8077dfc) = eax;
    eax = camlChar__1;
    *(0x8077e00) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80560d0 */
#include <stdint.h>
 
int32_t camlString_entry (void) {
    eax = loc.camlString__24;
    *(loc.camlString) = eax;
    eax = loc.camlString__23;
    *(0x8077f18) = eax;
    eax = loc.camlString__22;
    *(0x8077f1c) = eax;
    eax = loc.camlString__21;
    *(0x8077f20) = eax;
    eax = loc.camlString__20;
    *(0x8077f24) = eax;
    eax = loc.camlString__19;
    *(0x8077f2c) = eax;
    eax = loc.camlString__18;
    *(0x8077f28) = eax;
    eax = loc.camlString__17;
    *(0x8077f30) = eax;
    eax = loc.camlString__16;
    *(0x8077f64) = eax;
    eax = loc.camlString__15;
    *(0x8077f50) = eax;
    eax = loc.camlString__14;
    *(0x8077f54) = eax;
    eax = loc.camlString__13;
    *(0x8077f68) = eax;
    eax = loc.camlString__12;
    *(0x8077f58) = eax;
    eax = loc.camlString__11;
    *(0x8077f5c) = eax;
    eax = loc.camlString__10;
    *(0x8077f6c) = eax;
    eax = loc.camlString__9;
    *(0x8077f34) = eax;
    eax = loc.camlString__8;
    *(0x8077f3c) = eax;
    eax = loc.camlString__7;
    *(0x8077f70) = eax;
    eax = loc.camlString__6;
    *(0x8077f38) = eax;
    eax = loc.camlString__5;
    *(0x8077f40) = eax;
    eax = loc.camlString__4;
    *(0x8077f48) = eax;
    eax = loc.camlString__3;
    *(0x8077f44) = eax;
    eax = loc.camlString__2;
    *(0x8077f4c) = eax;
    eax = camlString__1;
    *(0x8077f60) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056290 */
#include <stdint.h>
 
int32_t camlSys_entry (void) {
    eax = caml_sys_get_argv;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    eax = *(eax);
    *(0x80783a0) = eax;
    *(loc.camlSys) = ebx;
    eax = caml_sys_get_config;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    eax = *(eax);
    *(0x80783a8) = eax;
    *(0x80783ac) = ebx;
    ecx = .comment;
    ecx += 0xffffffec;
    ecx >>= 1;
    eax = 2;
    eax <<= cl;
    eax -= 3;
    eax += 2;
    *(0x80783b4) = eax;
    ebx = .comment;
    ebx >>= 1;
    eax = .comment;
    eax >>= 1;
    if (eax < 0) {
        eax += 7;
    }
    eax >>= 3;
    eax <<= 1;
    eax *= ebx;
    eax -= 3;
    eax += 2;
    *(0x80783b0) = eax;
    caml_alloc3 ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    *(0x80783a4) = ebx;
    eax = loc.camlSys__4;
    *(0x80783b8) = eax;
    *(0x80783bc) = 0xffffffff;
    *(0x80783c0) = 0xfffffffd;
    *(0x80783c4) = 0xfffffffb;
    *(0x80783c8) = 0xfffffff9;
    *(0x80783cc) = 0xfffffff7;
    *(0x80783d0) = 0xfffffff5;
    *(0x80783d4) = 0xfffffff3;
    *(0x80783d8) = 0xfffffff1;
    *(0x80783dc) = 0xffffffef;
    *(0x80783e0) = 0xffffffed;
    *(0x80783e4) = 0xffffffeb;
    *(0x80783e8) = 0xffffffe9;
    *(0x80783ec) = 0xffffffe7;
    *(0x80783f0) = 0xffffffe5;
    *(0x80783f4) = 0xffffffe3;
    *(0x80783f8) = 0xffffffe1;
    *(0x80783fc) = 0xffffffdf;
    *(0x8078400) = 0xffffffdd;
    *(0x8078404) = 0xffffffdb;
    *(0x8078408) = 0xffffffd9;
    *(0x807840c) = 0xffffffd7;
    eax = ebx + 8;
    *((eax - 4)) = 0x400;
    *(eax) = "Sys.Break";
    *(0x8078410) = eax;
    eax = camlSys__2;
    *(0x8078414) = eax;
    eax = "3.12.1";
    *(0x8078418) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80702d0 */
#include <stdint.h>
 
int32_t loc_caml_alloc3 (int32_t arg_4h) {
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            return eax;
        }
        eax = *(esp);
        *(obj.caml_last_return_address) = eax;
        eax = esp + 4;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_0807024d ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c1a0 */
#include <stdint.h>
 
int32_t camlPrintf_entry (void) {
    int32_t var_4h;
    ecx = loc.camlPrintf__38;
    eax = 0x14;
    caml_allocN (ecx);
    ebx = eax + 4;
    *((ebx - 4)) = 0x10f7;
    *(ebx) = sym.caml_curry2;
    *((ebx + 4)) = 5;
    *((ebx + 8)) = 0x805b140;
    *((ebx + 0xc)) = ecx;
    eax = 3;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (ebx);
    ebx = eax;
    eax = 0x94;
    caml_allocN ();
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlPrintf__index_of_literal_position_1044;
    *((ecx + 4)) = 3;
    eax = *(esp);
    *((ecx + 8)) = eax;
    edi = loc.camlPrintf__37;
    esi = ecx + 0x10;
    *((esi - 4)) = 0xcf7;
    *(esi) = sym.camlPrintf__to_string_1054;
    *((esi + 4)) = 3;
    *((esi + 8)) = edi;
    edx = ecx + 0x20;
    *((edx - 4)) = 0x1800;
    *(edx) = eax;
    eax = *((esp + 4));
    *((edx + 4)) = eax;
    *((edx + 8)) = ebx;
    *((edx + 0xc)) = ecx;
    *((edx + 0x10)) = edi;
    *((edx + 0x14)) = esi;
    *(0x8079590) = edx;
    eax = loc.camlPrintf__36;
    *(0x8079594) = eax;
    eax = loc.camlPrintf__35;
    *(0x8079598) = eax;
    eax = loc.camlPrintf__34;
    *(0x807959c) = eax;
    eax = loc.camlPrintf__33;
    *(0x80795a0) = eax;
    eax = loc.camlPrintf__32;
    *(0x80795a4) = eax;
    eax = loc.camlPrintf__31;
    *(0x80795a8) = eax;
    eax = loc.camlPrintf__30;
    *(0x80795ac) = eax;
    eax = loc.camlPrintf__29;
    *(0x80795b0) = eax;
    eax = loc.camlPrintf__28;
    *(0x80795b4) = eax;
    eax = loc.camlPrintf__27;
    *(0x80795b8) = eax;
    eax = loc.camlPrintf__26;
    *(0x80795bc) = eax;
    eax = loc.camlPrintf__25;
    *(0x80795c0) = eax;
    eax = loc.camlPrintf__24;
    *(0x80795c4) = eax;
    eax = loc.camlPrintf__23;
    *(0x80795c8) = eax;
    eax = loc.camlPrintf__22;
    *(0x80795cc) = eax;
    eax = loc.camlPrintf__21;
    *(0x80795d0) = eax;
    eax = loc.camlPrintf__20;
    *(0x80795d4) = eax;
    eax = loc.camlPrintf__19;
    *(0x80795d8) = eax;
    eax = loc.camlPrintf__18;
    *(0x80795dc) = eax;
    eax = loc.camlPrintf__17;
    *(0x80795e0) = eax;
    eax = loc.camlPrintf__16;
    *(0x80795e4) = eax;
    ebx = loc.camlPrintf__15;
    eax = ecx + 0x3c;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805bd50;
    *((eax + 0xc)) = ebx;
    *(0x80795e8) = eax;
    eax = loc.camlPrintf__14;
    *(0x80795ec) = eax;
    eax = loc.camlPrintf__13;
    *(0x80795f0) = eax;
    eax = loc.camlPrintf__12;
    *(0x807957c) = eax;
    eax = loc.camlPrintf__11;
    *(0x8079570) = eax;
    eax = loc.camlPrintf__10;
    *(loc.camlPrintf) = eax;
    eax = loc.camlPrintf__9;
    *(0x8079568) = eax;
    eax = loc.camlPrintf__8;
    *(0x807956c) = eax;
    eax = loc.camlPrintf__7;
    *(0x8079584) = eax;
    eax = loc.camlPrintf__6;
    *(0x8079578) = eax;
    eax = loc.camlPrintf__5;
    *(0x80795f4) = eax;
    eax = loc.camlPrintf__4;
    *(0x80795f8) = eax;
    eax = loc.camlPrintf__3;
    *(0x80795fc) = eax;
    eax = loc.camlPrintf__2;
    *(0x8079580) = eax;
    eax = camlPrintf__1;
    *(0x8079574) = eax;
    eax = .comment;
    *(0x8079588) = eax;
    eax = .comment;
    *(esp) = eax;
    ebp = .comment;
    edi = .comment;
    esi = .comment;
    edx = .comment;
    ebx = .comment;
    eax = ecx + 0x50;
    *((eax - 4)) = 0x1400;
    *(eax) = ebp;
    *((eax + 4)) = edi;
    *((eax + 8)) = esi;
    *((eax + 0xc)) = edx;
    *((eax + 0x10)) = ebx;
    ebx = ecx + 0x68;
    *((ebx - 4)) = 0x800;
    edx = *(esp);
    *(ebx) = edx;
    *((ebx + 4)) = eax;
    esi = *(ebx);
    eax = ecx + 0x74;
    *((eax - 4)) = 0x1000;
    edx = *(esi);
    *(eax) = edx;
    edx = *((esi + 8));
    *((eax + 4)) = edx;
    edx = *((esi + 0x10));
    *((eax + 8)) = edx;
    edx = *((esi + 0x14));
    *((eax + 0xc)) = edx;
    ecx += 0x88;
    *((ecx - 4)) = 0x800;
    *(ecx) = eax;
    eax = *((ebx + 4));
    *((ecx + 4)) = eax;
    *(0x807958c) = ecx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ea80 */
#include <stdint.h>
 
int32_t loc_camlUnixLabels_code_begin (void) {
    eax = camlUnix;
    ebx = *(eax);
    *(loc.camlUnixLabels) = ebx;
    ebx = *((eax + 4));
    *(0x8075304) = ebx;
    ebx = *((eax + 8));
    *(0x8075308) = ebx;
    ebx = *((eax + 0xc));
    *(0x807530c) = ebx;
    ebx = *((eax + 0x10));
    *(0x8075310) = ebx;
    ebx = *((eax + 0x14));
    *(0x8075314) = ebx;
    ebx = *((eax + 0x18));
    *(0x8075318) = ebx;
    ebx = *((eax + 0x1c));
    *(0x807531c) = ebx;
    ebx = *((eax + 0x20));
    *(0x8075320) = ebx;
    ebx = *((eax + 0x24));
    *(0x8075324) = ebx;
    ebx = *((eax + 0x28));
    *(0x8075328) = ebx;
    ebx = *((eax + 0x2c));
    *(0x807532c) = ebx;
    ebx = *((eax + 0x30));
    *(0x8075330) = ebx;
    ebx = *((eax + 0x34));
    *(0x8075334) = ebx;
    ebx = *((eax + 0x38));
    *(0x8075338) = ebx;
    ebx = *((eax + 0x3c));
    *(0x807533c) = ebx;
    ebx = *((eax + 0x40));
    *(0x8075340) = ebx;
    *(0x8075344) = 1;
    *(0x8075348) = 3;
    *(0x807534c) = 5;
    ebx = *((eax + 0x50));
    *(0x8075350) = ebx;
    ebx = *((eax + 0x54));
    *(0x8075354) = ebx;
    ebx = *((eax + 0x58));
    *(0x8075358) = ebx;
    ebx = *((eax + 0x5c));
    *(0x807535c) = ebx;
    ebx = *((eax + 0x60));
    *(0x8075360) = ebx;
    ebx = *((eax + 0x64));
    *(0x8075364) = ebx;
    ebx = *((eax + 0x68));
    *(0x8075368) = ebx;
    ebx = *((eax + 0x6c));
    *(0x807536c) = ebx;
    ebx = *((eax + 0x70));
    *(0x8075370) = ebx;
    ebx = *((eax + 0x74));
    *(0x8075374) = ebx;
    ebx = *((eax + 0x78));
    *(0x8075378) = ebx;
    ebx = *((eax + 0x7c));
    *(0x807537c) = ebx;
    ebx = *((eax + 0x80));
    *(0x8075380) = ebx;
    ebx = *((eax + 0x84));
    *(0x8075384) = ebx;
    ebx = *((eax + 0x88));
    *(0x8075388) = ebx;
    ebx = *((eax + 0x8c));
    *(0x807538c) = ebx;
    ebx = *((eax + 0x90));
    *(0x8075390) = ebx;
    ebx = *((eax + 0x94));
    *(0x8075394) = ebx;
    ebx = *((eax + 0x98));
    *(0x8075398) = ebx;
    ebx = *((eax + 0x9c));
    *(0x807539c) = ebx;
    ebx = *((eax + 0xa0));
    *(0x80753a0) = ebx;
    ebx = *((eax + 0xa4));
    *(0x80753a4) = ebx;
    ebx = *((eax + 0xa8));
    *(0x80753a8) = ebx;
    ebx = *((eax + 0xac));
    *(0x80753ac) = ebx;
    ebx = *((eax + 0xb0));
    *(0x80753b0) = ebx;
    ebx = *((eax + 0xb4));
    *(0x80753b4) = ebx;
    ebx = *((eax + 0xb8));
    *(0x80753b8) = ebx;
    ebx = *((eax + 0xbc));
    *(0x80753bc) = ebx;
    ebx = *((eax + 0xc0));
    *(0x80753c0) = ebx;
    ebx = *((eax + 0xc4));
    *(0x80753c4) = ebx;
    ebx = *((eax + 0xc8));
    *(0x80753c8) = ebx;
    ebx = *((eax + 0xcc));
    *(0x80753cc) = ebx;
    ebx = *((eax + 0xd0));
    *(0x80753d0) = ebx;
    ebx = *((eax + 0xd4));
    *(0x80753d4) = ebx;
    ebx = *((eax + 0xd8));
    *(0x80753d8) = ebx;
    ebx = *((eax + 0xdc));
    *(0x80753dc) = ebx;
    ebx = *((eax + 0xe0));
    *(0x80753e0) = ebx;
    ebx = *((eax + 0xe4));
    *(0x80753e4) = ebx;
    ebx = *((eax + 0xe8));
    *(0x80753e8) = ebx;
    ebx = *((eax + 0xec));
    *(0x80753ec) = ebx;
    ebx = *((eax + 0xf0));
    *(0x80753f0) = ebx;
    ebx = *((eax + 0xf4));
    *(0x80753f4) = ebx;
    ebx = *((eax + 0xf8));
    *(0x80753f8) = ebx;
    ebx = *((eax + 0xfc));
    *(0x80753fc) = ebx;
    ebx = *((eax + 0x100));
    *(0x8075400) = ebx;
    ebx = *((eax + 0x104));
    *(0x8075404) = ebx;
    ebx = *((eax + 0x108));
    *(0x8075408) = ebx;
    ebx = *((eax + 0x10c));
    *(0x807540c) = ebx;
    ebx = *((eax + 0x110));
    *(0x8075410) = ebx;
    ebx = *((eax + 0x114));
    *(0x8075414) = ebx;
    ebx = *((eax + 0x118));
    *(0x8075418) = ebx;
    ebx = *((eax + 0x11c));
    *(0x807541c) = ebx;
    ebx = *((eax + 0x120));
    *(0x8075420) = ebx;
    ebx = *((eax + 0x124));
    *(0x8075424) = ebx;
    ebx = *((eax + 0x128));
    *(0x8075428) = ebx;
    ebx = *((eax + 0x12c));
    *(0x807542c) = ebx;
    ebx = *((eax + 0x130));
    *(0x8075430) = ebx;
    ebx = *((eax + 0x134));
    *(0x8075434) = ebx;
    ebx = *((eax + 0x138));
    *(0x8075438) = ebx;
    ebx = *((eax + 0x13c));
    *(0x807543c) = ebx;
    ebx = *((eax + 0x140));
    *(0x8075440) = ebx;
    ebx = *((eax + 0x144));
    *(0x8075444) = ebx;
    ebx = *((eax + 0x148));
    *(0x8075448) = ebx;
    ebx = *((eax + 0x14c));
    *(0x807544c) = ebx;
    ebx = *((eax + 0x150));
    *(0x8075450) = ebx;
    ebx = *((eax + 0x154));
    *(0x8075454) = ebx;
    ebx = *((eax + 0x158));
    *(0x8075458) = ebx;
    ebx = *((eax + 0x15c));
    *(0x807545c) = ebx;
    ebx = *((eax + 0x160));
    *(0x8075460) = ebx;
    ebx = *((eax + 0x164));
    *(0x8075464) = ebx;
    ebx = *((eax + 0x168));
    *(0x8075468) = ebx;
    ebx = *((eax + 0x16c));
    *(0x807546c) = ebx;
    ebx = *((eax + 0x170));
    *(0x8075470) = ebx;
    ebx = *((eax + 0x174));
    *(0x8075474) = ebx;
    ebx = *((eax + 0x178));
    *(0x8075478) = ebx;
    ebx = *((eax + 0x17c));
    *(0x807547c) = ebx;
    ebx = *((eax + 0x180));
    *(0x8075480) = ebx;
    ebx = *((eax + 0x184));
    *(0x8075484) = ebx;
    ebx = *((eax + 0x188));
    *(0x8075488) = ebx;
    ebx = *((eax + 0x18c));
    *(0x807548c) = ebx;
    ebx = *((eax + 0x190));
    *(0x8075490) = ebx;
    ebx = *((eax + 0x194));
    *(0x8075494) = ebx;
    ebx = *((eax + 0x198));
    *(0x8075498) = ebx;
    ebx = *((eax + 0x19c));
    *(0x807549c) = ebx;
    ebx = *((eax + 0x1a0));
    *(0x80754a0) = ebx;
    ebx = *((eax + 0x1a4));
    *(0x80754a4) = ebx;
    ebx = *((eax + 0x1a8));
    *(0x80754a8) = ebx;
    ebx = *((eax + 0x1ac));
    *(0x80754ac) = ebx;
    ebx = *((eax + 0x1b0));
    *(0x80754b0) = ebx;
    ebx = *((eax + 0x1b4));
    *(0x80754b4) = ebx;
    ebx = *((eax + 0x1b8));
    *(0x80754b8) = ebx;
    ebx = *((eax + 0x1bc));
    *(0x80754bc) = ebx;
    ebx = *((eax + 0x1c0));
    *(0x80754c0) = ebx;
    ebx = *((eax + 0x1c4));
    *(0x80754c4) = ebx;
    ebx = *((eax + 0x1c8));
    *(0x80754c8) = ebx;
    ebx = *((eax + 0x1cc));
    *(0x80754cc) = ebx;
    ebx = *((eax + 0x1d0));
    *(0x80754d0) = ebx;
    ebx = *((eax + 0x1d4));
    *(0x80754d4) = ebx;
    ebx = *((eax + 0x1d8));
    *(0x80754d8) = ebx;
    ebx = *((eax + 0x1dc));
    *(0x80754dc) = ebx;
    ebx = *((eax + 0x1e0));
    *(0x80754e0) = ebx;
    ebx = *((eax + 0x1e4));
    *(0x80754e4) = ebx;
    ebx = *((eax + 0x1e8));
    *(0x80754e8) = ebx;
    ebx = *((eax + 0x1ec));
    *(0x80754ec) = ebx;
    ebx = *((eax + 0x1f0));
    *(0x80754f0) = ebx;
    ebx = *((eax + 0x1f4));
    *(0x80754f4) = ebx;
    ebx = *((eax + 0x1f8));
    *(0x80754f8) = ebx;
    ebx = *((eax + 0x1fc));
    *(0x80754fc) = ebx;
    ebx = *((eax + 0x200));
    *(0x8075500) = ebx;
    ebx = *((eax + 0x204));
    *(0x8075504) = ebx;
    ebx = *((eax + 0x208));
    *(0x8075508) = ebx;
    ebx = *((eax + 0x20c));
    *(0x807550c) = ebx;
    ebx = *((eax + 0x210));
    *(0x8075510) = ebx;
    ebx = *((eax + 0x214));
    *(0x8075514) = ebx;
    ebx = *((eax + 0x218));
    *(0x8075518) = ebx;
    ebx = *((eax + 0x21c));
    *(0x807551c) = ebx;
    ebx = *((eax + 0x220));
    *(0x8075520) = ebx;
    ebx = *((eax + 0x224));
    *(0x8075524) = ebx;
    ebx = *((eax + 0x228));
    *(0x8075528) = ebx;
    ebx = *((eax + 0x22c));
    *(0x807552c) = ebx;
    ebx = *((eax + 0x230));
    *(0x8075530) = ebx;
    ebx = *((eax + 0x234));
    *(0x8075534) = ebx;
    ebx = *((eax + 0x238));
    *(0x8075538) = ebx;
    ebx = *((eax + 0x23c));
    *(0x807553c) = ebx;
    ebx = *((eax + 0x240));
    *(0x8075540) = ebx;
    ebx = *((eax + 0x244));
    *(0x8075544) = ebx;
    ebx = *((eax + 0x248));
    *(0x8075548) = ebx;
    ebx = *((eax + 0x24c));
    *(0x807554c) = ebx;
    ebx = *((eax + 0x250));
    *(0x8075550) = ebx;
    ebx = *((eax + 0x254));
    *(0x8075554) = ebx;
    ebx = *((eax + 0x258));
    *(0x8075558) = ebx;
    ebx = *((eax + 0x25c));
    *(0x807555c) = ebx;
    ebx = *((eax + 0x260));
    *(0x8075560) = ebx;
    ebx = *((eax + 0x264));
    *(0x8075564) = ebx;
    eax = *((eax + 0x268));
    *(0x8075568) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b700 */
#include <stdint.h>
 
int32_t camlSource_entry (void) {
    int32_t var_4h;
    eax = loc.camlSource__4;
    *(loc.camlSource) = eax;
    eax = loc.camlSource__3;
    *(0x8072cb8) = eax;
    eax = camlSource__2;
    *(0x8072cbc) = eax;
    *(0x8072cc0) = 0x3d;
    eax = *(loc.camlSys);
    eax = *((eax - 4));
    eax >>= 9;
    eax |= 1;
    if (eax > 3) {
        eax = *(loc.camlSys);
        eax = caml_int_of_string;
        caml_c_call (*((eax + 4)));
    } else {
        eax = 3;
    }
    *(0x8072cc4) = eax;
    ebx = 0x3d;
    eax = 0x3d;
    eax = camlSource_mkmatrix_1030 ();
    ebx = 0x3d;
    eax = 0x3d;
    eax = camlSource_mkmatrix_1030 (eax);
    ebx = *(esp);
    *(0x8072cc8) = ebx;
    *(0x8072ccc) = eax;
    ecx = 1;
    ebx = 0x3d;
    eax = 0x3d;
    eax = camlArray_make_matrix_1042 ();
    *(0x8072cd0) = eax;
    ebx = 5;
    eax = .comment;
    if (ebx > eax) {
        goto label_0;
    }
    do {
        esi = .comment;
        edx = .comment;
        ecx = .comment;
        ebx = 0x3d;
        eax = 0x3d;
        camlSource_mmult_1045 (ebx, eax);
        eax = *(esp);
        ebx = *(esp);
        eax += 2;
        *(esp) = eax;
        eax = *((esp + 4));
    } while (ebx != eax);
label_0:
    esi = .comment;
    edx = .comment;
    ecx = .comment;
    ebx = 0x3d;
    eax = 0x3d;
    camlSource_mmult_1045 ();
    eax = "%d %d %d %d\n";
    eax = camlPrintf_printf_1393 ();
    esi = eax;
    eax = .comment;
    eax = *((eax + 0x10));
    edx = *((eax + 0x10));
    eax = .comment;
    eax = *((eax + 0xc));
    ecx = *((eax + 8));
    eax = .comment;
    eax = *((eax + 8));
    ebx = *((eax + 0xc));
    eax = .comment;
    eax = *(eax);
    eax = *(eax);
    caml_apply4 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c350 */
#include <stdint.h>
 
int32_t camlUnix_fun_2780 (void) {
    eax = unix_environment;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ba2c */
#include <stdint.h>
 
uint32_t caml_sys_time (void) {
    int32_t var_50h;
    int32_t var_4h;
    eax = ebp - 0x50;
    *((esp + 4)) = eax;
    *(esp) = 0;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x50));
    *(fp_stack--) = *((ebp - 0x4c));
    *(fp_stack--) = *(0x8070b08);
    fp_stack[1] /= fp_stack[0];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    *(fp_stack--) = *((ebp - 0x44));
    fp_stack[1] /= fp_stack[0];
    fp_stack++;
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062679 */
#include <stdint.h>
 
int32_t caml_modify_generational_global_root (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *(esi);
    edx = ebx;
    edx &= 1;
    if (edx == 0) {
        if (ebx < *(obj.caml_young_end)) {
            if (ebx <= *(obj.caml_young_start)) {
                goto label_3;
            }
            if ((al & 1) != 0) {
                goto label_4;
            }
            edx = eax;
            edx >>= 0x17;
            eax >>= 0xc;
            eax &= 0x7ff;
            edx = *((edx*4 + obj.caml_page_table));
            if ((*((edx + eax)) & 1) == 0) {
                goto label_1;
            }
            edx = esi;
            eax = caml_global_roots_old;
            caml_delete_global_root ();
            edx = esi;
            eax = caml_global_roots_young;
            al = caml_insert_global_root ();
        }
    } else {
label_3:
        if ((al & 1) != 0) {
            if (edx != 0) {
                goto label_1;
            }
label_4:
            if (ebx >= *(obj.caml_young_end)) {
                goto label_5;
            }
            if (ebx <= *(obj.caml_young_start)) {
                goto label_5;
            }
            edx = esi;
            eax = caml_global_roots_young;
            caml_insert_global_root ();
            goto label_1;
label_0:
            edx = esi;
            eax = caml_global_roots_old;
            eax = caml_insert_global_root ();
        } else {
            if (edx == 0) {
                goto label_1;
            }
            if (eax >= *(obj.caml_young_end)) {
                goto label_6;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_6;
            }
            edx = esi;
            eax = caml_global_roots_young;
            caml_delete_global_root ();
            goto label_1;
label_2:
            edx = esi;
            eax = caml_global_roots_old;
            caml_delete_global_root ();
        }
    }
    do {
label_1:
        *(esi) = ebx;
        ebx = *(esp);
        esi = *((esp + 4));
        return eax;
label_5:
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
    } while ((*((edx + eax)) & 1) == 0);
    goto label_0;
label_6:
    edx = eax;
    edx >>= 0x17;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) == 0) {
        goto label_1;
    }
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c884 */
#include <stdint.h>
 
uint32_t unix_chroot (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x158b7;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = chroot ();
    if (eax == -1) {
        eax = ebx - 0x1713;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a474 */
#include <stdint.h>
 
void chroot (void) {
    chroot ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80616ae */
#include <stdint.h>
 
uint32_t caml_main (char ** arg_8h) {
    int32_t var_20h;
    int32_t var_19h;
    char ** var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    caml_init_ieee_floats (ebx, esi, edi);
    caml_init_custom_operations ();
    eax = ebp - 0x19;
    *(obj.caml_top_of_stack) = eax;
    eax = getenv ("OCAMLRUNPARAM");
    ebx = eax;
    if (eax != 0) {
        goto label_0;
    }
    eax = getenv (0x8070edf);
    ebx = eax;
    if (eax == 0) {
        goto label_1;
    }
    while (al != 0) {
        ebx++;
        eax -= 0x4f;
        if (al <= 0x27) {
            eax = (int32_t) al;
            uint32_t (*esi + eax*4)() ();
label_0:
            esi = 0x8070f28;
            edi = ebp - 0x20;
        }
        eax = *(ebx);
    }
label_1:
    eax = max_percent_free_init;
    eax = percent_free_init;
    eax = heap_chunk_init;
    eax = heap_size_init;
    eax = minor_heap_init;
    caml_init_gc (eax, eax, eax);
    eax = 0;
    edx = caml_atom_table;
    do {
        *((edx + eax*4)) = eax;
        eax++;
    } while (eax != 0x100);
    eax = caml_page_table_add (4, 0x8082240, obj.caml_frame_descriptors_mask);
    if (eax == 0) {
        eax = "D$\a\b";
        ebx = 0;
        esi = 0x80728e4;
        edi = "D$\a\b";
        if (eax != 0) {
            goto label_2;
        }
        goto label_3;
    }
    eax = caml_fatal_error ("Fatal error: not enough memory for the initial page table");
    do {
label_2:
        edx = *((esi + ebx*8));
        eax = caml_page_table_add (4, eax, edx);
        if (eax != 0) {
            caml_fatal_error ("Fatal error: not enough memory for the initial page table");
        }
        ebx++;
        eax = *((edi + ebx*8));
    } while (eax != 0);
label_3:
    eax = caml_code_segments;
    *(obj.caml_code_area_start) = eax;
    ecx = *(loc.caml_startup__code_end);
    *(obj.caml_code_area_end) = ecx;
    eax = *(loc.camlPervasives__code_begin);
    if (eax == 0) {
        goto label_4;
    }
    ebx = caml_code_area_start;
    edx = 1;
    edi = 0x8072960;
    esi = caml_code_segments;
    do {
        if (ebx > eax) {
            ebx = eax;
        }
        eax = *((edi + edx*8));
        if (ecx < eax) {
            ecx = eax;
        }
        edx++;
        eax = *((esi + edx*8));
    } while (eax != 0);
    *(obj.caml_code_area_start) = ebx;
    *(obj.caml_code_area_end) = ecx;
label_4:
    caml_init_signals ();
    caml_debugger_init ();
    eax = *((ebp + 8));
    ebx = *(eax);
    eax = 0x8071ba8;
    if (ebx == 0) {
        ebx = eax;
    }
    eax = caml_executable_name (obj.proc_self_exe.2949, 0x100);
    edx = proc_self_exe.2949;
    if (eax != 0) {
        eax = caml_search_exe_in_path (ebx);
        edx = eax;
    }
    eax = *((ebp + 8));
    caml_sys_init (edx, eax);
    *((esp + 4)) = 0;
    *(esp) = obj.caml_termination_jmpbuf;
    eax = sigsetjmp ();
    if (eax != 0) {
        eax = caml_termination_hook;
        if (eax == 0) {
            goto label_5;
        }
        void (*eax)(uint32_t) (0);
    } else {
        eax = loc_caml_start_program ();
        edx = eax;
        edx &= 3;
        if (edx != 2) {
            goto label_5;
        }
        eax &= 0xfffffffc;
        caml_fatal_uncaught_exception (eax);
    }
label_5:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd10 */
#include <stdint.h>
 
int32_t camlUnix_fun_2602 (void) {
    eax = sym.unix_accept;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80648e4 */
#include <stdint.h>
 
int32_t caml_alloc_table (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((ebp + 0x10));
    *((ebx + 0x14)) = eax;
    *((ebx + 0x18)) = edx;
    eax = edx + eax;
    eax <<= 2;
    eax = caml_stat_alloc (ebx, esi);
    esi = eax;
    eax = *(ebx);
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *(ebx) = esi;
    *((ebx + 0xc)) = esi;
    eax = *((ebx + 0x14));
    edx = esi + eax*4;
    *((ebx + 8)) = edx;
    *((ebx + 0x10)) = edx;
    eax += *((ebx + 0x18));
    eax = esi + eax*4;
    *((ebx + 4)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806049f */
#include <stdint.h>
 
uint32_t unix_lstat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11c9c;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = lxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x1440;
        uerror (eax, esi);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a1c4 */
#include <stdint.h>
 
void lxstat64 (void) {
    lxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80681f1 */
#include <stdint.h>
 
int32_t caml_array_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_get_float (eax, edx);
    } else {
        caml_array_get_addr (eax, edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b6d0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_format_for_printf_1135 (void) {
    ecx = eax;
    edx = .comment;
    ebx = .comment;
    eax = .comment;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e97b */
#include <stdint.h>
 
uint32_t caml_weak_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x28)) = ebx;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x30)) = 0;
    edx = ebp - 0x28;
    *((ebp - 0x50)) = edx;
    edx = ebp - 0x50;
    *(obj.caml_local_roots) = edx;
    *((ebp - 0x48)) = 1;
    *((ebp - 0x4c)) = 2;
    edx = ebp - 0x2c;
    *((ebp - 0x44)) = edx;
    edx = ebp - 0x30;
    *((ebp - 0x40)) = edx;
    eax++;
    if (eax != 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    eax = *((edx + eax*4));
    if (eax == *(obj.caml_weak_none)) {
        *((ebp - 0x2c)) = 1;
    } else {
        *((ebp - 0x30)) = eax;
        if (*(obj.caml_gc_phase) == 0) {
            if ((al & 1) != 0) {
                goto label_1;
            }
            ecx = eax;
            ecx >>= 0x17;
            edx = eax;
            edx >>= 0xc;
            edx &= 0x7ff;
            ecx = *((ecx*4 + obj.caml_page_table));
            if ((*((ecx + edx)) & 1) == 0) {
                goto label_1;
            }
            caml_darken (eax, 0);
        }
label_1:
        eax = caml_alloc_small (1, 0);
        *((ebp - 0x2c)) = eax;
        edx = *((ebp - 0x30));
        *(eax) = edx;
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f2f0 */
#include <stdint.h>
 
int32_t caml_final_do_strong_roots (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    if (*(obj.old) == 0) {
        goto label_2;
    }
    ebx = 0;
    esi = 0;
    edi = *((ebp + 8));
    do {
        eax = ebx;
        eax += *(obj.final_table);
        eax = *(eax);
        void (*edi)(uint32_t, uint32_t) (eax, eax);
        esi++;
        ebx += 0xc;
    } while (*(obj.old) > esi);
label_2:
    eax = to_do_hd;
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_3;
    }
    goto label_4;
    do {
label_0:
        eax = esi * 3;
        edx = *((ebp - 0x1c));
        edi = edx + eax*4;
        eax = edi + 8;
        eax = *((ebx + 8));
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        edi += 0xc;
        eax = *((ebx + 0xc));
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, edi);
        esi++;
        ebx += 0xc;
        eax = *((ebp - 0x1c));
    } while (*((eax + 4)) > esi);
label_1:
    edx = *((ebp - 0x1c));
    edx = *(edx);
    *((ebp - 0x1c)) = edx;
    if (edx == 0) {
        goto label_4;
    }
label_3:
    ebx = *((ebp - 0x1c));
    esi = 0;
    if (*((ebx + 4)) != 0) {
        goto label_0;
    }
    goto label_1;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80612d9 */
#include <stdint.h>
 
uint32_t unix_wait (void) {
    int32_t wstatus;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x10e62;
    caml_enter_blocking_section ();
    eax = ebp - 0xc;
    eax = wait (eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x128e;
        uerror (eax, 0);
    }
    edx = *((ebp - 0xc));
    eax = esi;
    alloc_process_status ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a0c4 */
#include <stdint.h>
 
void wait (void) {
    wait ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806393f */
#include <stdint.h>
 
int32_t caml_round_heap_chunk_size (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_major_heap_increment;
    if (ebx >= eax) {
        eax = ebx;
    }
    eax = clip_heap_chunk_size ();
    if (ebx > eax) {
        caml_raise_out_of_memory ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ae50 */
#include <stdint.h>
 
int32_t caml_curry7_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80585d0 */
#include <stdint.h>
 
int32_t camlBuffer_nth_1057 (void) {
    if (ebx >= 1) {
        ecx = *((eax + 4));
        if (ebx >= ecx) {
            goto label_0;
        }
        eax = *(eax);
        ebx >>= 1;
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        if (ecx <= ebx) {
            goto label_1;
        }
        eax = *((eax + ebx));
        eax = eax + eax + 1;
        return eax;
    }
label_0:
    eax = "Buffer.nth";
    void (*0x804f620)() ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ffe0 */
#include <stdint.h>
 
uint32_t camlPervasives_string_of_format_1315 (void) {
    int32_t var_4h;
    ecx = eax;
    *((esp + 4)) = ecx;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067023 */
#include <stdint.h>
 
int32_t caml_gt_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] > fp_stack[1]) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c96c */
#include <stdint.h>
 
int32_t caml_gc_major_slice (int32_t arg_8h) {
    caml_empty_minor_heap ();
    eax = *((ebp + 8));
    eax >>= 1;
    caml_major_collection_slice (eax);
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b900 */
#include <stdint.h>
 
int32_t camlPrintf_list_iter_i_1201 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059af0;
            *((ecx + 0xc)) = edx;
            eax = 1;
            void (*0x8059af0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c080 */
#include <stdint.h>
 
int32_t camlUnix_fun_2702 (void) {
    eax = unix_set_close_on_exec;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b5f0 */
#include <stdint.h>
 
int32_t caml_hash_variant (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = 1;
    if (*(edx) == 0) {
        goto label_0;
    }
    do {
        eax >>= 1;
        eax *= 0xdf;
        ecx = *(edx);
        eax += ecx;
        eax = eax + eax + 1;
        edx++;
    } while (*(edx) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c8e0 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_int_1650 (void) {
    eax = unix_getsockopt;
    caml_c_call (3);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bda0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_format_1278 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = edx;
    *((esp + 0x14)) = edi;
    eax = caml_extra_params;
    *((esp + 0x10)) = eax;
    edi = .comment;
    ebp = .comment;
    do {
        eax = caml_young_ptr;
        eax -= 0x64;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805a610;
            ebx = *(esp);
            *((eax + 0xc)) = ebx;
            edx = eax + 0x14;
            *((edx - 4)) = 0x4cf7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x805aef0;
            *((edx + 0xc)) = 0x10f9;
            *((edx + 0x10)) = 0x804b1f0;
            *((edx + 0x14)) = 9;
            *((edx + 0x18)) = 0x805ae30;
            *((edx + 0x1c)) = 0x20f9;
            *((edx + 0x20)) = 0x804b1f0;
            *((edx + 0x24)) = 9;
            *((edx + 0x28)) = 0x805a690;
            ebx = *((esp + 4));
            *((edx + 0x2c)) = ebx;
            ecx = *((esp + 8));
            *((edx + 0x30)) = ecx;
            *((edx + 0x34)) = esi;
            ebx = *((esp + 0x14));
            *((edx + 0x38)) = ebx;
            ebx = *((esp + 0x10));
            *((edx + 0x3c)) = ebx;
            *((edx + 0x40)) = edi;
            *((edx + 0x44)) = ebp;
            *((edx + 0x48)) = eax;
            ecx += 2;
            ebx = 1;
            eax = *((esp + 0xc));
            void (*0x805aef0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80623cc */
#include <stdint.h>
 
int32_t caml_scan_global_roots (int32_t arg_8h) {
    ebx = *((ebp + 8));
    edx = caml_global_roots;
    eax = ebx;
    caml_iterate_global_roots (ebx);
    edx = caml_global_roots_young;
    eax = ebx;
    caml_iterate_global_roots ();
    edx = caml_global_roots_old;
    eax = ebx;
    caml_iterate_global_roots ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051230 */
#include <stdint.h>
 
uint32_t camlArray_bubble_1174 (void) {
    eax = void (*0x8051260)() ();
    ecx = .comment;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *((eax + 4));
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = *((ecx + 0xc));
    return camlArray_bubbledown_1170 (*(obj.caml_exception_pointer));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052240 */
#include <stdint.h>
 
int32_t camlArray_blit_1093 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edi = eax;
    *((esp + 8)) = ecx;
    if (esi < 1) {
        goto label_2;
    }
    if (ebx < 1) {
        goto label_2;
    }
    ecx = *((edi - 4));
    eax = *((edi - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ecx;
        eax >>= 9;
    } else {
        eax = ecx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= esi;
    eax++;
    if (ebx > eax) {
        goto label_2;
    }
    if (ebp < 1) {
        goto label_2;
    }
    eax = *((esp + 8));
    ecx = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ecx;
        eax >>= 9;
    } else {
        eax = ecx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= esi;
    eax++;
    if (ebp > eax) {
        goto label_2;
    }
    if (ebx >= ebp) {
        goto label_3;
    }
    esi += 0xfffffffe;
    if (esi < 1) {
        goto label_4;
    }
    *((esp + 4)) = ebx;
    do {
        eax = *((esp + 4));
        ebx = eax + esi - 1;
        eax = *((edi - 4));
        if (eax != 0xfe) {
            ebx = *((edi + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edi + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ebx = eax;
        }
        eax = ebp;
        eax = eax + esi - 1;
        ecx = *((esp + 8));
        ecx = *((ecx - 4));
        if (ecx != 0xfe) {
            ebx = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, ebx);
        } else {
            *(fp_stack--) = *(ebx);
            ebx = *((esp + 8));
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = esi;
        eax = esi;
        eax -= 2;
        esi = eax;
    } while (ebx != 1);
label_4:
    eax = 1;
    return eax;
label_3:
    eax = 1;
    *((esp + 0xc)) = eax;
    esi += 0xfffffffe;
    if (*((esp + 0xc)) > esi) {
        goto label_6;
    }
    *((esp + 4)) = ebx;
    *(esp) = edi;
    do {
        ebx = *((esp + 4));
        eax = *((esp + 0xc));
        ebx = ebx + eax - 1;
        eax = *(esp);
        ecx = *((eax - 4));
        if (ecx != 0xfe) {
            ebx = *((eax + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_7;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            eax = *(esp);
            *(fp_stack--) = *((eax + ebx*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
            ebx = ecx;
        }
        ecx = *((esp + 0xc));
        eax = ebp;
        eax = eax + ecx - 1;
        ecx = *((esp + 8));
        ecx = *((ecx - 4));
        if (ecx != 0xfe) {
            ebx = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, ebx);
        } else {
            *(fp_stack--) = *(ebx);
            ebx = *((esp + 8));
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 0xc));
        eax = *((esp + 0xc));
        eax += 2;
        *((esp + 0xc)) = eax;
    } while (ebx != esi);
label_6:
    eax = 1;
    return eax;
label_2:
    eax = "Array.blit";
    void (*0x804f620)() ();
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058500 */
#include <stdint.h>
 
int32_t camlBuffer_contents_1044 (void) {
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    return camlString_sub_1046 ();
}


r2dec has crashed (info: SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80574b0).
Please report the bug at https://github.com/radareorg/r2dec-js/issues
Use the option '--issue' or the command 'pddi' to generate 
the needed data for the issue.
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fdf0 */
#include <stdint.h>
 
int32_t camlPervasives_print_newline_1276 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x80755d4));
    eax = caml_ml_flush;
    caml_c_call (*(0x80755d4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804dd80 */
#include <stdint.h>
 
int32_t camlUnix_close_process_in_2003 (void) {
    int32_t var_4h;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x401;
            *(ebx) = ecx;
            eax = "close_process_in";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 4)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054870 */
#include <stdint.h>
 
int32_t camlList_exists2_1153 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    if (ecx == 1) {
        eax = 1;
        return eax;
    }
label_1:
    eax = "List.exists2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80651ce */
#include <stdint.h>
 
int32_t caml_alloc_final (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = *((ebp + 0xc));
    eax = caml_final_custom_operations (eax);
    edx = *((ebp + 0x14));
    edx = *((ebp + 0x10));
    edx = *((ebp + 8));
    edx <<= 2;
    caml_alloc_custom (edx, edx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067b40 */
#include <stdint.h>
 
uint32_t caml_string_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        eax = caml_string_length (esi);
        if (ebx < eax) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebx + esi)) = al;
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061b17 */
#include <stdint.h>
 
int32_t caml_raise_with_arg (void) {
    int32_t var_4ch;
    int32_t var_48h_2;
    int32_t var_44h_2;
    int32_t var_40h_2;
    int32_t var_2ch;
    int32_t var_28h_2;
    int32_t var_24h_2;
    int32_t var_20h_2;
    int32_t var_1ch_2;
    int32_t var_18h;
    int32_t var_ch_2;
    int32_t var_4h_2;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = *((ebp + 0xc));
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    eax = *((ebp - 0x2c));
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054ca0 */
#include <stdint.h>
 
int32_t camlList_find_all_1205 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8053570;
            *((ebx + 0xc)) = ecx;
            eax = 1;
            ecx = *(ebx);
            void (*ecx)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f9f0 */
#include <stdint.h>
 
uint32_t caml_executable_name (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_68h;
    int32_t var_58h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    *((esp + 8)) = esi;
    *((esp + 4)) = ebx;
    *(esp) = "/proc/self/exe";
    eax = readlink ();
    if (eax != -1) {
        if (esi <= eax) {
            goto label_0;
        }
        *((ebx + eax)) = 0;
        eax = ebp - 0x68;
        *((esp + 8)) = eax;
        *((esp + 4)) = ebx;
        *(esp) = 3;
        eax = xstat64 ();
        if (eax != 0) {
            goto label_0;
        }
        edx = *((ebp - 0x58));
        edx &= 0xf000;
        if (edx == 0x8000) {
            goto label_1;
        }
    }
label_0:
    eax = 0xffffffff;
label_1:
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b343 */
#include <stdint.h>
 
uint32_t caml_input_val_from_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_6ch;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    esi = ebp - 0x3c;
    *((ebp - 0x50)) = esi;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = edx + eax + 8;
    *(obj.intern_input_malloced) = 0;
    ecx = eax + 4;
    edi = *((ecx - 1));
    edx = *(eax);
    edx <<= 0x18;
    edx = edi + edx;
    edi = *((ecx - 3));
    edi <<= 0x10;
    edi = edx + edi;
    edx = *((ecx - 2));
    edx <<= 8;
    edx = edi + edx;
    ecx = eax + 8;
    edi = *((ecx - 4));
    edi <<= 0x18;
    *((ebp - 0x6c)) = edi;
    edi = *((ecx - 1));
    edi += *((ebp - 0x6c));
    *((ebp - 0x6c)) = edi;
    edi = *((ecx - 3));
    edi <<= 0x10;
    edi += *((ebp - 0x6c));
    ecx = *((ecx - 2));
    ecx <<= 8;
    edi += ecx;
    eax += 0xc;
    *(obj.intern_src) = eax;
    eax = edi;
    intern_alloc (ebx, esi, edi);
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = edx + eax + 0x14;
    *(obj.intern_src) = eax;
    eax = esi;
    intern_rec ();
    eax = edi;
    intern_add_to_heap ();
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050030 */
#include <stdint.h>
 
int32_t camlPervasives_at_exit_1322 (void) {
    ecx = eax;
    eax = .comment;
    ebx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlPervasives__fun_1500;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            caml_modify (*(0x80756c0), eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065cd5 */
#include <stdint.h>
 
int32_t caml_notequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x807f400) {
        eax = compare_free_stack ();
    }
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066a27 */
#include <stdint.h>
 
int32_t caml_int64_of_int (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054490 */
#include <stdint.h>
 
int32_t camlList_iter_1074 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        void (*ecx)(uint32_t, uint32_t) (edx, eax);
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066d50 */
#include <stdint.h>
 
int32_t caml_int32_bits_of_float (int32_t arg_8h) {
    int32_t var_10h;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x10));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80542c0 */
#include <stdint.h>
 
int32_t camlList_length_1034 (void) {
    ebx = eax;
    eax = 1;
    return camlList_length_aux_1030 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c99c */
#include <stdint.h>
 
int32_t caml_gc_set (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    esi = *((ebp + 8));
    ebx = *((ebp + 8));
    eax = *((esi + 0xc));
    eax >>= 1;
    *(obj.caml_verb_gc) = eax;
    eax = *((esi + 8));
    eax >>= 1;
    eax = norm_pfree (ebx, esi);
    if (eax != *(obj.caml_percent_free)) {
        *(obj.caml_percent_free) = eax;
        caml_gc_message (0x20, "New space overhead: %d%%\n", eax);
    }
    eax = *((ebx + 0x10));
    eax >>= 1;
    eax = norm_pmax ();
    if (eax != *(obj.caml_percent_max)) {
        *(obj.caml_percent_max) = eax;
        caml_gc_message (0x20, "New max overhead: %d%%\n", eax);
    }
    eax = *((ebx + 4));
    eax >>= 1;
    eax = norm_heapincr ();
    eax <<= 2;
    if (eax != *(obj.caml_major_heap_increment)) {
        *(obj.caml_major_heap_increment) = eax;
        eax >>= 0xa;
        caml_gc_message (0x20, "New heap increment size: %luk bytes\n", eax);
    }
    ebx = *((ebx + 0x18));
    ebx >>= 1;
    eax = 1;
    if (ebx >= 2) {
        ebx = eax;
    }
    if (ebx != *(obj.caml_allocation_policy)) {
        caml_gc_message (0x20, "New allocation policy: %d\n", ebx);
        caml_set_allocation_policy (ebx);
    }
    eax = *(esi);
    eax >>= 1;
    eax <<= 2;
    eax = norm_minsize ();
    ebx = eax;
    if (eax != *(obj.caml_minor_heap_size)) {
        eax >>= 0xa;
        caml_gc_message (0x20, "New minor heap size: %luk bytes\n", eax);
        caml_set_minor_heap_size (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806254f */
#include <stdint.h>
 
int32_t caml_scan_global_young_roots (int32_t arg_8h) {
    ebx = *((ebp + 8));
    edx = caml_global_roots;
    eax = ebx;
    caml_iterate_global_roots (ebx);
    edx = caml_global_roots_young;
    eax = ebx;
    caml_iterate_global_roots ();
    ebx = .comment;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        edx = *(ebx);
        eax = caml_global_roots_old;
        caml_insert_global_root ();
        ebx = *((ebx + 4));
    } while (ebx != 0);
    eax = .comment;
    if (eax == 0) {
        goto label_0;
    }
    do {
        ebx = *((eax + 4));
        caml_stat_free (eax);
        if (ebx == 0) {
            goto label_0;
        }
        eax = ebx;
    } while (1);
label_0:
    edx = .comment;
    if (edx < 0) {
        goto label_1;
    }
    eax = 0;
    ecx = 0x807bac4;
    do {
        *((ecx + eax*4)) = 0;
        eax++;
    } while (eax <= edx);
label_1:
    *(0x807bb08) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056aa0 */
#include <stdint.h>
 
int32_t camlHashtbl_do_bucket_1132 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        edx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ebx = edx;
        caml_apply2 (ecx, ebx);
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067a2d */
#include <stdint.h>
 
uint32_t caml_string_compare (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    if (ebx != edi) {
        eax = caml_string_length (ebx);
        *((ebp - 0x10)) = eax;
        eax = caml_string_length (edi);
        edx = eax;
        eax = *((ebp - 0x10));
        if (eax <= *((ebp - 0x10))) {
            eax = edx;
        }
        esi = ebx;
        ecx = eax;
        __asm ("repe cmpsb byte [esi], byte ptr es:[edi]");
        al = (eax > eax) ? 1 : 0;
        cl = (eax < eax) ? 1 : 0;
        al -= cl;
        eax = (int32_t) al;
        if (eax < 0) {
            goto label_0;
        }
        if (eax > 0) {
            goto label_1;
        }
        if (*((ebp - 0x10)) < edx) {
            goto label_0;
        }
        if (*((ebp - 0x10)) > edx) {
            goto label_1;
        }
    }
    eax = 1;
    goto label_2;
label_0:
    eax = 0xffffffff;
    goto label_2;
label_1:
    eax = 3;
label_2:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be20 */
#include <stdint.h>
 
int32_t camlUnix_fun_2632 (void) {
    eax = unix_getgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806648e */
#include <stdint.h>
 
uint32_t caml_format_int (void) {
    char * format;
    int32_t var_8h_5;
    int32_t var_4h_4;
    int32_t var_8h_4;
    esi = *((ebp + 0xc));
    ecx = ebp - 0x28;
    eax = ebp - 0x49;
    eax = ebp - 0x48;
    edx = 0x8071d23;
    eax = *((ebp + 8));
    eax = parse_format (ebx, esi);
    ebx = eax;
    eax = *((ebp - 0x49));
    if (al != 0x6f) {
        if (al <= 0x6f) {
            if (al != 0x58) {
                goto label_0;
            }
        } else {
            if (al == 0x75) {
                goto label_1;
            }
            if (al != 0x78) {
                goto label_0;
            }
        }
    }
label_1:
    esi >>= 1;
    eax = ebp - 0x28;
    sprintf (ebx, eax, esi);
    goto label_2;
label_0:
    esi >>= 1;
    eax = ebp - 0x28;
    sprintf (ebx, eax, esi);
label_2:
    eax = caml_copy_string (ebx);
    esi = eax;
    eax = ebp - 0x48;
    if (ebx != eax) {
        caml_stat_free (ebx);
    }
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806675f */
#include <stdint.h>
 
int32_t caml_nativeint_mul (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax *= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057a20 */
#include <stdint.h>
 
int32_t camlHashtbl_find_all_1105 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlHashtbl__find_in_bucket_1108;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ecx + edx*2 - 2));
            void (*0x8056890)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066e38 */
#include <stdint.h>
 
int32_t caml_int32_or (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax |= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e68c */
#include <stdint.h>
 
int32_t unix_lockf (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_1eh;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x13ab3;
    eax = *((ebp + 0x10));
    esi = *((ebp + 8));
    esi >>= 1;
    *((ebp - 0x1e)) = 1;
    eax >>= 1;
    if (eax < 0) {
        *((ebp - 0x1c)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x18)) = edx;
        eax = -eax;
        *((ebp - 0x14)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x10)) = edx;
    } else {
        *((ebp - 0x1c)) = 0;
        *((ebp - 0x18)) = 0;
        *((ebp - 0x14)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x10)) = edx;
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax <= 5) {
        edx = ebx;
        edx -= *((ebx + eax*4 - 0x13a4c));
        void (*edx)() ();
    }
    errno_location ();
    *(eax) = 0x16;
    eax = ebx - 0x15e4;
    return uerror (eax, 0);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806543d */
#include <stdint.h>
 
int32_t caml_alloc_dummy_float (int32_t arg_8h) {
    int32_t var_4h;
    edx = *((ebp + 8));
    eax = 0x8082244;
    edx &= 0xfffffffe;
    if (edx != 0) {
        caml_alloc (edx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066cce */
#include <stdint.h>
 
int32_t caml_int64_neg (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    eax = -eax;
    edx += 0;
    edx = -edx;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fc60 */
#include <stdint.h>
 
int32_t camlPervasives_really_input_1235 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        void (*0x804fbc0)() ();
    }
label_0:
    eax = "really_input";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ee28 */
#include <stdint.h>
 
uint32_t unix_readlink (int32_t arg_8h) {
    int32_t var_1008h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13310;
    esi = *((ebp + 8));
    *((esp + 8)) = 0xfff;
    eax = ebp - 0x1008;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = readlink ();
    if (eax == -1) {
        eax = ebx - 0x1594;
        uerror (eax, esi);
    }
    *((ebp + eax - 0x1008)) = 0;
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a674 */
#include <stdint.h>
 
void readlink (void) {
    readlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066e1c */
#include <stdint.h>
 
int32_t caml_int32_xor (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax ^= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806661f */
#include <stdint.h>
 
int32_t caml_nativeint_of_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050090 */
#include <stdint.h>
 
int32_t camlPervasives_do_at_exit_1325 (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066de2 */
#include <stdint.h>
 
int32_t caml_int32_shift_right (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c0d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2712 (void) {
    eax = unix_access;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cba8 */
#include <stdint.h>
 
int32_t unix_execvpe (void) {
    int32_t var_1ch;
    int32_t var_ch_4;
    int32_t var_8h_3;
    int32_t var_4h_3;
    int32_t var_8h_4;
    int32_t var_10h_2;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15590;
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    edi = eax;
    esi = *((ebx - 0x14));
    eax = *(esi);
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 0x10));
    eax = cstringvect (eax);
    *(esi) = eax;
    *((esp + 4)) = edi;
    eax = *((ebp + 8));
    *(esp) = eax;
    execvp ();
    caml_stat_free (edi);
    eax = *(esi);
    caml_stat_free (eax);
    eax = *((ebp - 0x1c));
    *(esi) = eax;
    eax = *((ebp + 8));
    eax = ebx - 0x16df;
    return uerror (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066224 */
#include <stdint.h>
 
int32_t caml_int_of_string (int32_t arg_8h) {
    edx = 0x1f;
    eax = *((ebp + 8));
    parse_intnat ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052a10 */
#include <stdint.h>
 
int32_t camlArray_fold_left_1139 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    edi = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x400;
    *(esi) = ebx;
    edx = 1;
    eax = *((ecx - 4));
    ebx = *((ecx - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    eax += 0xfffffffe;
    if (edx > eax) {
        goto label_3;
    }
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    *(esp) = ecx;
    *((esp + 4)) = edi;
    do {
        ecx = *(esp);
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ebx = *((ecx + edx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = *(esi);
        ecx = *((esp + 4));
        eax = caml_apply2 ();
        esi = *((esp + 0xc));
        caml_modify (esi, eax);
        edx = *((esp + 0xc));
        ebx = *((esp + 0xc));
        edx += 2;
        *((esp + 0xc)) = edx;
        eax = *((esp + 0x10));
    } while (ebx != eax);
label_3:
    eax = *(esi);
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058fc0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1568 (void) {
    ecx = eax;
    edx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *((edx + 0x10));
            *((ebx + 4)) = eax;
            ecx = *((edx + 8));
            eax = *((edx + 0xc));
            eax += 2;
            void (*0x8059b50)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062ee9 */
#include <stdint.h>
 
int32_t caml_fatal_error (char * s) {
    FILE * stream;
    eax = stderr;
    eax = *((ebp + 8));
    fputs (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049dd4 */
#include <stdint.h>
 
void fputs (void) {
    fputs ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c664 */
#include <stdint.h>
 
uint32_t unix_inet_addr_of_string (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15ad7;
    esi = *((ebp + 8));
    eax = ebp - 0xc;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 2;
    eax = inet_pton ();
    if (eax > 0) {
        eax = ebp - 0xc;
        alloc_inet_addr (eax);
    } else {
        eax = ebp - 0x1c;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 0xa;
        eax = inet_pton ();
        if (eax > 0) {
            eax = ebp - 0x1c;
            alloc_inet6_addr (eax);
        } else {
            eax = ebx - 0x1732;
            caml_failwith (eax);
        }
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80666c3 */
#include <stdint.h>
 
int32_t caml_nativeint_and (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax &= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054640 */
#include <stdint.h>
 
int32_t camlList_iter2_1111 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        caml_apply2 (edx, eax, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    if (ecx == 1) {
        eax = 1;
        return eax;
    }
label_1:
    eax = "List.iter2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2636 (void) {
    eax = unix_geteuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bfe0 */
#include <stdint.h>
 
int32_t camlPrintf_fprintf_1391 (void) {
    ebx = eax;
    eax = loc.camlPrintf__43;
    return camlPrintf_kfprintf_1386 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056ff0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_all_1210 (void) {
    int32_t var_4h_4;
    int32_t var_8h_2;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlHashtbl__find_in_bucket_1213;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            eax = *(esp);
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            void (*0x80564f0)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053600 */
#include <stdint.h>
 
int32_t camlList_part_1215 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        *((esp + 4)) = eax;
        if (ecx == 1) {
            goto label_3;
        }
        eax = *((ecx + 4));
        eax = *(ecx);
        ebx = *((edx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t) (edx, ebx);
        if (eax == 1) {
            goto label_1;
        }
label_2:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 4));
        *((eax + 4)) = ebx;
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
        edx = *((esp + 0x10));
    } while (1);
label_1:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = *(esp);
    *(ebx) = eax;
    eax = *((esp + 8));
    *((ebx + 4)) = eax;
    eax = *((esp + 4));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x10));
    goto label_0;
label_3:
    ecx = 1;
    eax = ebx;
    ebx = ecx;
    eax = camlList_rev_append_1051 ();
    ebx = 1;
    eax = *((esp + 4));
    eax = camlList_rev_append_1051 (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
label_4:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804dfd0 */
#include <stdint.h>
 
uint32_t camlUnix_open_connection_2018 (int32_t arg_ch) {
    int32_t var_4h;
    eax = camlUnix_domain_of_sockaddr_1529 (eax);
    eax = unix_socket;
    eax = caml_c_call (eax);
    eax = void (*0x804e020)(uint32_t) (eax);
    *(esp) = eax;
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *(esp);
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ebx = *((esp + 8));
    eax = unix_connect;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    camlUnix_try_set_close_on_exec_1366 ();
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    *((esp + 8)) = eax;
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *((esp + 8));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c6c0 */
#include <stdint.h>
 
int32_t camlUnix_domain_of_sockaddr_1529 (void) {
    ebx = *((eax - 4));
    if (ebx != 0) {
        ebx = *(eax);
        eax = *((ebx - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        ebx = *((ebx + eax));
        eax -= ebx;
        eax = eax + eax + 1;
        if (eax == 0x21) {
            eax = 5;
            return eax;
        }
        eax = 3;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c610 */
#include <stdint.h>
 
uint32_t camlUnix_try_set_close_on_exec_1366 (void) {
    eax = void (*0x804c640)() ();
    ecx = loc.caml_exn_Invalid_argument;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = 1;
        return eax;
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_set_close_on_exec;
    caml_c_call (eax);
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806999d */
#include <stdint.h>
 
int32_t caml_serialize_block_1 (int32_t arg_8h, int32_t arg_ch) {
    void ** s2;
    size_t * n;
    eax = *((ebp + 0xc));
    ebx = *((ebp + 0xc));
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    eax = *((ebp + 8));
    eax = extern_ptr;
    memmove (eax, eax, ebx);
    *(obj.extern_ptr) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806677c */
#include <stdint.h>
 
int32_t caml_nativeint_sub (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = *((ebp + 0xc));
    eax -= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bbb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2863 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060443 */
#include <stdint.h>
 
uint32_t unix_fstat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11cfd;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = fxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x1446;
        uerror (eax, 0);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a714 */
#include <stdint.h>
 
void fxstat64 (void) {
    fxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c0f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2716 (void) {
    eax = unix_fchown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fc02 */
#include <stdint.h>
 
int32_t caml_dlopen (int32_t arg_8h, int32_t arg_10h) {
    int32_t var_4h;
    eax = *((ebp + 0x10));
    eax -= eax;
    al = 0;
    eax += 0x1102;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    dlopen ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a494 */
#include <stdint.h>
 
void dlopen (void) {
    dlopen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054fd0 */
#include <stdint.h>
 
int32_t camlList_stable_sort_1248 (void) {
    int32_t var_4h;
    esi = eax;
    *((esp + 4)) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x54;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x8053720;
            *((edx + 0xc)) = esi;
            ecx = edx + 0x14;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry3;
            *((ecx + 4)) = 7;
            *((ecx + 8)) = 0x8053820;
            *((ecx + 0xc)) = esi;
            eax = edx + 0x28;
            *((eax - 4)) = 0x28f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x8053de0;
            *((eax + 0xc)) = 0x10f9;
            *((eax + 0x10)) = 0x804b370;
            *((eax + 0x14)) = 5;
            *((eax + 0x18)) = 0x8053920;
            *((eax + 0x1c)) = esi;
            *((eax + 0x20)) = edx;
            *((eax + 0x24)) = ecx;
            eax = 1;
            eax = camlList_length_aux_1030 (eax);
            if (eax < 5) {
                eax = *((esp + 4));
                return eax;
            }
            ebx = *((esp + 4));
            ecx = *(esp);
            void (*0x8053de0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805eee8 */
#include <stdint.h>
 
int32_t unix_rewinddir (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13258;
    eax = *((ebp + 8));
    eax = *(eax);
    if (eax == 0) {
        eax = ebx - 0x1584;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    rewinddir ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a544 */
#include <stdint.h>
 
void rewinddir (void) {
    rewinddir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ba91 */
#include <stdint.h>
 
uint32_t caml_sys_file_exists (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_4h;
    int32_t var_8h;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = xstat64 ();
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066d6b */
#include <stdint.h>
 
int32_t caml_int32_of_string (int32_t arg_8h) {
    edx = 0x20;
    eax = *((ebp + 8));
    eax = parse_intnat ();
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e63c */
#include <stdint.h>
 
int32_t unix_listen (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13b04;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = listen (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x15eb;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a034 */
#include <stdint.h>
 
void listen (void) {
    listen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070940 */
#include <stdint.h>
 
uint32_t libc_csu_init (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x1801;
    _init ();
    edi = ebx - 0x14c;
    eax = ebx - 0x14c;
    edi -= eax;
    edi >>= 2;
    if (edi == 0) {
        goto label_0;
    }
    esi = 0;
    do {
        eax = *((ebp + 0x10));
        eax = *((ebp + 0xc));
        eax = *((ebp + 8));
        uint32_t (*ebx + esi*4 - 0x14c)(uint32_t, uint32_t, uint32_t) (eax, eax, eax);
        esi++;
    } while (esi < edi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055750 */
#include <stdint.h>
 
int32_t camlString_iter_1062 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    esi = *((ebx + edx));
    edx -= esi;
    edx = edx + edx - 1;
    if (ecx > edx) {
        goto label_0;
    }
    do {
        ecx >>= 1;
        eax = *(esp);
        eax = *((eax + ecx));
        eax = eax + eax + 1;
        ebx = *((esp + 4));
        ecx = *(ebx);
        void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, ecx);
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805da10 */
#include <stdint.h>
 
int32_t unix_getnameinfo (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14bch;
    int32_t var_14b8h;
    int32_t var_10b8h;
    int32_t var_b8h;
    int32_t var_b4h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x1472b;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x44)) = edi;
    edx = ebp - 0x44;
    *(eax) = edx;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = ebp - 0xb8;
    esi = ebp - 0xb4;
    eax = *((ebp + 8));
    get_sockaddr (eax, esi, eax);
    eax = ebx + 0x9184;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x14bc)) = eax;
    caml_enter_blocking_section ();
    eax = *((ebp - 0x14bc));
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = 0x400;
    eax = ebp - 0x14b8;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = 0x1000;
    eax = ebp - 0x10b8;
    *((esp + 8)) = eax;
    eax = *((ebp - 0xb8));
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = getnameinfo ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        caml_raise_not_found ();
    }
    eax = ebp - 0x10b8;
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = ebp - 0x14b8;
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x24)) = eax;
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    eax = *((ebp - 0x24));
    *((eax + 4)) = edx;
    eax = *((ebx - 0x18));
    *(eax) = edi;
    eax = *((ebp - 0x24));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a6a4 */
#include <stdint.h>
 
void getnameinfo (void) {
    getnameinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc10 */
#include <stdint.h>
 
int32_t camlUnix_fun_2572 (void) {
    eax = unix_tcsetattr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fd90 */
#include <stdint.h>
 
uint32_t camlPervasives_print_float_1272 (void) {
    eax = camlPervasives_string_of_float_1140 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e1d7 */
#include <stdint.h>
 
int32_t caml_register_named_value (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    char * src;
    esi = *((ebp + 8));
    eax = *((ebp + 8));
    eax = hash_value_name (ebx, esi, edi);
    *((ebp - 0x1c)) = eax;
    ebx = *((eax*4 + obj.named_value_table));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        eax = strcmp (esi, eax);
        if (eax == 0) {
            eax = *((ebp + 0xc));
            *(ebx) = eax;
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    edi = esi;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx += 0xb;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    eax = eax + 8;
    strcpy (eax, esi);
    edx = *((ebp + 0xc));
    *(ebx) = edx;
    eax = named_value_table;
    ecx = *((ebp - 0x1c));
    edx = *((eax + ecx*4));
    *((ebx + 4)) = edx;
    *((eax + ecx*4)) = ebx;
    caml_register_global_root (ebx);
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf20 */
#include <stdint.h>
 
int32_t camlUnix_fun_2662 (void) {
    eax = unix_sigsuspend;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066726 */
#include <stdint.h>
 
int32_t caml_nativeint_div (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    ecx = *((ebp + 0xc));
    ecx = *((ecx + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            goto label_0;
        }
    }
    eax = edx;
    edx >>= 0x1f;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    caml_copy_nativeint (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050a70 */
#include <stdint.h>
 
int32_t camlArray_maxson_1155 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax += ebx;
    esi = eax + ebx + 3;
    esi += 0xfffffffd;
    *((esp + 8)) = esi;
label_6:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x400;
    *(edi) = esi;
    eax = esi;
    eax += 4;
    if (eax < edx) {
        *((esp + 4)) = edi;
        *(esp) = ecx;
        edx = esi;
        edx += 2;
        edi = *((ecx + 0x10));
        eax = *((edi - 4));
        ebx = *((edi - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            if (eax <= edx) {
                goto label_8;
            }
            ebx = *((edi + edx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= edx) {
                goto label_9;
            }
label_5:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edi + edx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        edx = *((ecx + 0x10));
        eax = *((edx - 4));
        edi = *((edx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_11;
            }
            eax = *((edx + esi*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_12;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((ecx + 0xc));
        eax = caml_apply2 ();
        if (eax < 1) {
            ebx = *((esp + 8));
            ebx += 2;
            eax = *((esp + 4));
            *(eax) = ebx;
        }
        ecx = *((esp + 8));
        ecx += 4;
        esi = *(esp);
        edx = *((esi + 0x10));
        eax = *((edx - 4));
        ebx = *((edx - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_14;
            }
            ebx = *((edx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_15;
            }
label_3:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        edx = *(eax);
        ecx = *((esi + 0x10));
        eax = *((ecx - 4));
        edi = *((ecx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            eax >>= 9;
            if (eax <= edx) {
                goto label_17;
            }
            eax = *((ecx + edx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= edx) {
                goto label_18;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_19;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esi + 0xc));
        eax = caml_apply2 ();
        if (eax < 1) {
            ebx = *((esp + 8));
            ebx += 4;
            eax = *((esp + 4));
            *(eax) = ebx;
        }
        eax = *((esp + 4));
        eax = *(eax);
        return eax;
    }
    *((esp + 4)) = ebx;
    *(esp) = edx;
    eax = esi;
    eax += 2;
    if (eax < edx) {
        ebx = esi;
        ebx += 2;
        edx = *((ecx + 0x10));
        edi = *((edx - 4));
        eax = *((edx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edi;
            eax >>= 9;
            if (eax <= ebx) {
                goto label_20;
            }
            ebx = *((edx + ebx*2 - 2));
        } else {
            eax = edi;
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_21;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_22;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ebx = eax;
        }
        edx = *((ecx + 0x10));
        edi = *((edx - 4));
        eax = *((edx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edi;
            eax >>= 9;
            if (eax <= esi) {
                goto label_23;
            }
            eax = *((edx + esi*2 - 2));
        } else {
            eax = edi;
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_24;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_25;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((ecx + 0xc));
        eax = caml_apply2 ();
        if (eax >= 1) {
            goto label_26;
        }
        eax = *((esp + 8));
        eax += 2;
        return eax;
    }
label_26:
    eax = *((esp + 8));
    ebx = *(esp);
    if (eax >= ebx) {
        goto label_27;
    }
    return eax;
    do {
label_27:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = .comment;
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_25:
    caml_call_gc ();
    goto label_0;
label_22:
    caml_call_gc ();
    goto label_1;
label_19:
    caml_call_gc ();
    goto label_2;
label_16:
    caml_call_gc ();
    goto label_3;
label_13:
    caml_call_gc ();
    goto label_4;
label_10:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
label_24:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_21:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f5e7 */
#include <stdint.h>
 
uint32_t unix_recv (int32_t socket, void * s1, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    int32_t var_4018h;
    void * buffer;
    size_t length;
    int32_t flags;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x12b54;
    eax = ebx + 0x91e4;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    edi = eax;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = edi;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    *((esp + 8)) = esi;
    eax = ebp - 0x4018;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = recv (eax, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x1558;
        uerror (eax, 0);
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049fb4 */
#include <stdint.h>
 
void recv (void) {
    recv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806515a */
#include <stdint.h>
 
uint32_t caml_update_dummy (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_1ch;
    int32_t var_4h;
    edi = *((ebp + 0xc));
    eax = edi - 4;
    ecx = *(eax);
    edx = *(eax);
    esi = *((ebp + 8));
    *((esi - 4)) = dl;
    if (dl != 0xfe) {
        ecx >>= 0xa;
        *((ebp - 0x1c)) = ecx;
        ebx = 0;
        if (ecx != 0) {
            goto label_0;
        }
        goto label_1;
    }
    edx = *(eax);
    edx >>= 0xb;
    if (edx == 0) {
        goto label_1;
    }
    eax = 0;
    do {
        *(fp_stack--) = *((edi + eax*8));
        *((esi + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (edx > eax);
    goto label_1;
    do {
label_0:
        eax = *((edi + ebx*4));
        caml_modify (esi, eax);
        ebx++;
        esi += 4;
    } while (*((ebp - 0x1c)) > ebx);
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ec40 */
#include <stdint.h>
 
int32_t unix_putenv (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x134f8;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    edi = eax;
    eax = *((ebp + 0xc));
    eax = caml_string_length (eax);
    *((ebp - 0x1c)) = eax;
    eax += edi;
    *((ebp - 0x20)) = eax;
    eax += 2;
    eax = caml_stat_alloc (eax);
    esi = eax;
    eax = *((ebp + 8));
    memmove (esi, eax, edi);
    *((esi + edi)) = 0x3d;
    eax = *((ebp - 0x1c));
    eax = *((ebp + 0xc));
    eax = esi + edi + 1;
    memmove (eax, eax, eax);
    eax = *((ebp - 0x20));
    *((esi + eax + 1)) = 0;
    *(esp) = esi;
    eax = putenv ();
    if (eax == -1) {
        eax = *((ebp + 8));
        eax = ebx - 0x15a8;
        uerror (eax, eax);
    }
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a4e4 */
#include <stdint.h>
 
void putenv (void) {
    putenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065462 */
#include <stdint.h>
 
int32_t caml_alloc_dummy (int32_t arg_8h) {
    int32_t var_4h;
    edx = *((ebp + 8));
    eax = 0x8082244;
    edx >>= 1;
    if (edx != 0) {
        caml_alloc (edx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059c40 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1587 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = ebx;
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    *((esp + 4)) = edi;
    eax = caml_extra_params;
    *(esp) = eax;
    eax = caml_make_vect;
    eax = caml_c_call (0xd);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x18));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x18));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0x14));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0x14));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 0x10));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 9) {
            goto label_8;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 0x10;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 9) {
            goto label_9;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x20)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 0xb) {
            goto label_10;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0x14;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 0xb) {
            goto label_11;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x28)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050760 */
#include <stdint.h>
 
int32_t camlArray_size_1065 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ebx = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            ebx >>= 9;
        } else {
            ebx >>= 0xa;
        }
        ebx |= 1;
        eax += ebx;
        eax--;
        ebx = ecx;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064a8e */
#include <stdint.h>
 
int32_t caml_alloc_dependent_memory (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 2;
    *(obj.caml_dependent_size) += eax;
    *(obj.caml_dependent_allocated) += eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064c58 */
#include <stdint.h>
 
int32_t caml_adjust_gc_speed (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ecx = 1;
    if (eax == 0) {
        eax = ecx;
    }
    if (eax <= edx) {
        edx = eax;
    }
    ecx = 0;
    *((ebp - 0x10)) = edx;
    *((ebp - 0xc)) = ecx;
    *(fp_stack--) = *((ebp - 0x10));
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    fp_stack[0] += *(obj.caml_extra_heap_resources);
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    *(fp_stack--) = 1.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = 1.0;
        *(obj.caml_extra_heap_resources) = fp_stack[0];
        fp_stack--;
        caml_urge_major_slice ();
    }
    eax = caml_minor_heap_size;
    eax >>= 2;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] *= *(0x8071230);
    eax = caml_stat_heap_size;
    eax >>= 2;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    *(fp_stack--) = *(obj.caml_extra_heap_resources);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        caml_urge_major_slice ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2666 (void) {
    eax = unix_sigprocmask;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cf84 */
#include <stdint.h>
 
int32_t unix_ftruncate_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x151bc;
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 4)) = eax;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = ftruncate64 ();
    if (eax == -1) {
        eax = ebx - 0x1683;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ab40 */
#include <stdint.h>
 
int32_t caml_curry9_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b1a0 */
#include <stdint.h>
 
uint32_t camlPrintf_bad_conversion_1057 (void) {
    ebx = loc.camlPrintf__52;
    eax = camlPervasives_$5e_1112 (ebx, ecx);
    ebx = eax;
    eax = " in format string ``";
    eax = camlPervasives_$5e_1112 ();
    eax = *(esp);
    camlPervasives_string_of_int_1130 (eax);
    ebx = *((esp + 4));
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = ", at char number ";
    eax = camlPervasives_$5e_1112 ();
    eax = 3;
    ebx = *((esp + 8));
    camlString_make_1038 (eax);
    ebx = *(esp);
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = "Printf: bad conversion %";
    camlPervasives_$5e_1112 ();
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c2a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2762 (void) {
    eax = unix_waitpid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80624e7 */
#include <stdint.h>
 
int32_t caml_register_generational_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *(edx);
    if ((al & 1) != 0) {
        goto label_0;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_1;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_1;
    }
    eax = caml_global_roots_young;
    caml_insert_global_root ();
    goto label_0;
    do {
        eax = caml_global_roots_old;
        eax = caml_insert_global_root ();
        goto label_0;
label_1:
        ecx = eax;
        ecx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
    } while ((*((ecx + eax)) & 1) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c2c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2766 (void) {
    eax = unix_fork;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066b22 */
#include <stdint.h>
 
int32_t caml_int64_and (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx &= *((eax + 4));
    edx = *((edx + 8));
    edx &= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061e3d */
#include <stdint.h>
 
int32_t caml_register_dyn_global (int32_t arg_8h) {
    edx = caml_dyn_globals;
    eax = *((ebp + 8));
    eax = cons ();
    *(obj.caml_dyn_globals) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2608 (void) {
    eax = unix_string_of_inet_addr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80554d0 */
#include <stdint.h>
 
int32_t camlString_fun_1163 (void) {
    esi = eax;
    ecx = *((ebx + 8));
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((ecx + eax));
    eax -= ecx;
    eax = *((ebx + 0x10));
    caml_blit_string (*((ebx + 8)), 1, *((ebx + 0xc)), *(eax), eax + eax + 1);
    eax = *((ebx + 0x10));
    edi = *((ebx + 8));
    ecx = *((edi - 4));
    ecx >>= 0xa;
    edx = ecx*4 - 1;
    ecx = *((edi + edx));
    edx -= ecx;
    ecx = *((ebx + 0x10));
    ecx = *(ecx);
    ecx = ecx + edx*2;
    *(eax) = ecx;
    eax = *((esi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((esi + eax));
    eax -= ecx;
    eax = *((ebx + 0x10));
    caml_blit_string (esi, 1, *((ebx + 0xc)), *(eax), eax + eax + 1);
    eax = *((ebx + 0x10));
    ecx = *((esi - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((esi + ecx));
    ecx -= edx;
    ebx = *((ebx + 0x10));
    ebx = *(ebx);
    ebx = ebx + ecx*2;
    *(eax) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2576 (void) {
    eax = unix_getservbyport;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053570 */
#include <stdint.h>
 
int32_t camlList_find_1207 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        if (ebx == 1) {
            goto label_2;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (ecx, eax, eax);
        if (eax == 1) {
            goto label_3;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 4));
        *((eax + 4)) = ebx;
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
    } while (1);
label_3:
    eax = *((esp + 4));
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    goto label_0;
label_2:
    ebx = 1;
    void (*0x8054330)() ();
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067be0 */
#include <stdint.h>
 
int32_t caml_array_unsafe_set_float (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebp + 0x10));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 8));
    *((eax + edx*8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b1f0 */
#include <stdint.h>
 
int32_t caml_curry4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ffc0 */
#include <stdint.h>
 
int32_t camlPervasives_5e_5e_1312 (void) {
    eax = loc.camlPervasives__85;
    eax = camlPervasives_$5e_1112 (eax);
    ebx = eax;
    eax = *(esp);
    return camlPervasives_5e_1112 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066d3a */
#include <stdint.h>
 
int32_t caml_int64_to_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806852c */
#include <stdint.h>
 
int32_t caml_finalize_channel (int32_t arg_8h) {
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = *((ebx + 0x2c));
    eax--;
    *((ebx + 0x2c)) = eax;
    if (eax <= 0) {
        eax = caml_channel_mutex_free;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = ebx;
        unlink_channel ();
        caml_stat_free (ebx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052770 */
#include <stdint.h>
 
int32_t camlArray_mapi_1115 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = eax;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    if (eax == 1) {
        eax = loc.camlArray__23;
        return eax;
    }
    *(esp) = eax;
    *((esp + 4)) = ebx;
    *((esp + 8)) = ecx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        ebx = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(edx) = fp_stack[0];
        fp_stack--;
        ebx = edx;
    }
    eax = 1;
    eax = caml_apply2 ();
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    esi = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (esi > eax) {
        goto label_3;
    }
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = esi;
    *(esp) = ebx;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ebx = *((ecx + esi*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + esi*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = esi;
        ecx = *((esp + 8));
        eax = caml_apply2 ();
        ebx = *(esp);
        ecx = *((ebx - 4));
        if (ecx != 0xfe) {
            esi = *((esp + 0x14));
            eax = caml_modify (ebx + esi*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            esi = *((esp + 0x10));
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = esi;
        esi += 2;
        *((esp + 0x10)) = esi;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_3:
    eax = ebx;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055cc0 */
#include <stdint.h>
 
int32_t camlString_map_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    if (ecx == 1) {
        eax = ebx;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    *((esp + 8)) = eax;
    eax = caml_create_string;
    eax = caml_c_call (ecx);
    ebx = 1;
    ecx = *(esp);
    ecx += 0xfffffffe;
    if (ebx > ecx) {
        goto label_0;
    }
    do {
        ebx >>= 1;
        eax = *((esp + 4));
        eax = *((eax + ebx));
        eax = eax + eax + 1;
        ebx = *((esp + 8));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t) (ecx);
        eax >>= 1;
        ebx = *(esp);
        ecx = *(esp);
        ecx >>= 1;
        edx = eax;
        eax = *((esp + 0xc));
        *((eax + ecx)) = dl;
        edx = ebx;
        ebx += 2;
        *(esp) = ebx;
        ecx = *((esp + 0x10));
    } while (edx != ecx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80596d0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_conv_1143 (int32_t arg_ch, int32_t arg_ch_2, int32_t arg_4h, int32_t arg_4h_2, int32_t arg_8h, int32_t arg_ch_3) {
    int32_t var_4h_2;
    int32_t var_4h;
label_2:
    do {
        edx = ecx;
        ecx = *((edx + 0x24));
        if (ebx > ecx) {
            eax = *((edx + 0x18));
            void (*0x805b250)() ();
        }
        esi = ebx;
        esi >>= 1;
        ecx = *((edx + 0x18));
        ecx = *((ecx + esi));
        ecx = ecx + ecx + 1;
        if (ecx >= 0xfd) {
            goto label_3;
        }
        esi = ecx;
        esi >>= 1;
        /* switch table (254 cases) at 0x80799d4 */
        edx = *((edx + 0x1c));
        caml_apply3 (edx, eax);
        ebx = *((esp + 0xc));
        ebx += 0x10;
        void (*0x8059650)() ();
        edx = *((edx + 0x1c));
        eax = caml_apply3 (ecx);
        eax = *(esp);
        eax = camlPrintf_sub_format_for_printf_1135 (eax);
        ecx = eax;
        eax = *((esp + 0xc));
        eax = *((eax + 0x18));
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        edx = eax;
        *(esp) = edx;
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x14f7;
        *(ecx) = sym.camlPrintf__loop_1159;
        *((ecx + 4)) = 3;
        eax = *((esp + 0xc));
        ebx = *((eax + 0x18));
        *((ecx + 8)) = ebx;
        eax = *((eax + 0x20));
        *((ecx + 0xc)) = eax;
        *((ecx + 0x10)) = edx;
        eax = *((esp + 4));
        ebx = ecx;
        camlPrintf_loop_1159 ();
        ebx = *(esp);
        ebx += 0xfffffffe;
        eax = *((esp + 8));
        ecx = *((esp + 0xc));
    } while (1);
label_3:
    eax = *((edx + 0x18));
    void (*0x805b210)() ();
    eax = ebx;
    eax += 2;
    return eax;
    edx = *((edx + 0x1c));
    ecx = 0xe7;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0xc7;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0xd3;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0xcd;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0x85;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    void (*0x804b4f0)() ();
    edi = ebx;
    edi += 2;
    esi = *((edx + 0x24));
    if (edi > esi) {
        edx = *((edx + 0x1c));
        ecx = 0xd3;
        void (*0x804b4f0)() ();
    }
    *(esp) = ecx;
    esi = *((edx + 0x18));
    ecx = edi;
    ecx >>= 1;
    edi = *((esi - 4));
    edi >>= 0xa;
    ebp = edi*4 - 1;
    edi = *((esi + ebp));
    ebp -= edi;
    if (ebp > ecx) {
        ecx = *((esi + ecx));
        ecx = ecx + ecx + 1;
        ecx += 0xffffff50;
        if (ecx <= 0x41) {
            *((esp + 0xc)) = edx;
            ecx >>= 1;
            /* switch table (66 cases) at 0x8079bcc */
        }
        edx = *((edx + 0x1c));
        ecx = 0xd3;
        void (*0x804b4f0)() ();
        edx = *((edx + 0x1c));
        ecx = *(esp);
        caml_apply3 ();
        ebx = *((esp + 0xc));
        ecx = *((ebx + 0x20));
        ebx = 0xd3;
        void (*0x804b540)() ();
        edx = *((edx + 0x1c));
        void (*0x804b4f0)() ();
label_4:
        caml_call_gc ();
        goto label_0;
    }
    caml_ml_array_bound_error ();
    do {
label_1:
        edx = *((ecx + 0x34));
        if (ebx > edx) {
            eax = *((ecx + 0x28));
            void (*0x805b250)() ();
        }
        esi = ebx;
        esi >>= 1;
        edx = *((ecx + 0x28));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx < 0x75) {
            goto label_5;
        }
        if (edx != 0xbf) {
            goto label_6;
        }
        ebx += 2;
        eax = 3;
    } while (1);
label_5:
    if (edx >= 0x41) {
        edx += 0xffffffc0;
        edx >>= 1;
        /* switch table (66 cases) at 0x8079c50 */
        edx = *((ecx + 0x2c));
        ecx = 0xd3;
        eax = caml_apply3 (eax, ecx);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
        goto label_1;
    }
label_6:
    ecx += 0x10;
    goto label_2;
    ebx += 2;
    goto label_1;
    ebx += 2;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806cf11 */
#include <stdint.h>
 
int32_t caml_gc_stat (void) {
    int32_t var_94h;
    int32_t var_90h;
    uint32_t var_8ch;
    int32_t var_88h;
    int32_t var_84h;
    uint32_t var_80h;
    uint32_t var_78h;
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_68h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x84)) = eax;
    eax = caml_heap_start;
    if (eax == 0) {
        *((ebp - 0x6c)) = 0;
        esi = 0;
        *((ebp - 0x5c)) = 0;
        *((ebp - 0x58)) = 0;
        *((ebp - 0x54)) = 0;
        ebx = 0;
        *((ebp - 0x70)) = 0;
        goto label_1;
    }
    edx = caml_gc_phase;
    *((ebp - 0x78)) = edx;
    ecx = caml_gc_sweep_hp;
    *((ebp - 0x80)) = ecx;
    *((ebp - 0x6c)) = 0;
    esi = 0;
    *((ebp - 0x5c)) = 0;
    *((ebp - 0x58)) = 0;
    *((ebp - 0x54)) = 0;
    ebx = 0;
    *((ebp - 0x70)) = 0;
label_0:
    *((ebp - 0x70))++;
    edi = eax - 0x10;
    *((ebp - 0x68)) = edi;
    edi = eax;
    edx = *((ebp - 0x68));
    edi += *((edx + 8));
    if (edi <= eax) {
        goto label_2;
    }
    *((ebp - 0x8c)) = edi;
    do {
        edx = *(eax);
        ecx = *(eax);
        ecx &= 0x300;
        if (ecx != 0x100) {
            if (ecx <= 0x100) {
                if (ecx != 0) {
                } else {
                }
                if (ecx == 0x200) {
                    goto label_3;
                }
                if (ecx != 0x300) {
                    goto label_4;
                }
            } else {
                ecx = edx;
                ecx >>= 0xa;
                *((ebp - 0x88)) = ecx;
                if (ecx == 0) {
                    *((ebp - 0x6c))++;
                    goto label_4;
                }
                if (*((ebp - 0x78)) == 1) {
                    if (*((ebp - 0x80)) > eax) {
                        goto label_5;
                    }
                    *((ebp - 0x5c))++;
                    ecx = *((ebp - 0x88));
                    edi = *((ebp - 0x58));
                    edi = ecx + edi + 1;
                    *((ebp - 0x58)) = edi;
                    ecx++;
                    if (ecx > esi) {
                        esi = ecx;
                    }
                    goto label_4;
                }
label_5:
                *((ebp - 0x54))++;
                ecx = *((ebp - 0x88));
                ebx = ecx + ebx + 1;
            }
        } else {
            *((ebp - 0x54))++;
            ecx = edx;
            ecx >>= 0xa;
            ebx = ebx + ecx + 1;
            goto label_4;
label_3:
            *((ebp - 0x5c))++;
            edi = edx;
            edi >>= 0xa;
            ecx = *((ebp - 0x58));
            ecx = edi + ecx + 1;
            *((ebp - 0x58)) = ecx;
            ecx = edi;
            ecx++;
            if (ecx <= esi) {
                esi = ecx;
                goto label_4;
            }
        }
label_4:
        edx >>= 0xa;
        eax = eax + edx*4 + 4;
    } while (*((ebp - 0x8c)) > eax);
label_2:
    edi = *((ebp - 0x68));
    eax = *((edi + 0xc));
    if (eax != 0) {
        goto label_0;
    }
label_1:
    *((ebp - 0x1c)) = 0;
    eax = *((ebp - 0x84));
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x3c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x68)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x78)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x80)) = fp_stack[0];
    fp_stack--;
    edi = caml_stat_minor_collections;
    eax = caml_stat_major_collections;
    *((ebp - 0x88)) = eax;
    eax = caml_stat_heap_size;
    eax >>= 2;
    *((ebp - 0x8c)) = eax;
    edx = caml_stat_compactions;
    *((ebp - 0x90)) = edx;
    eax = caml_stat_top_heap_size;
    eax >>= 2;
    *((ebp - 0x94)) = eax;
    eax = caml_alloc_tuple (0x10);
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((ebp - 0x68));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x78));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x80));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 8;
    caml_modify (eax, eax);
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0xc;
    caml_modify (eax, eax);
    edx = *((ebp - 0x88));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x10;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x8c));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x14;
    caml_modify (eax, eax);
    edi = *((ebp - 0x70));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
    eax = ebx + ebx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x1c;
    caml_modify (eax, eax);
    edx = *((ebp - 0x54));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x20;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x58));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x24;
    caml_modify (eax, eax);
    edi = *((ebp - 0x5c));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x28;
    caml_modify (eax, eax);
    eax = esi + esi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x2c;
    caml_modify (eax, eax);
    edx = *((ebp - 0x6c));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x30;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x90));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x34;
    caml_modify (eax, eax);
    edi = *((ebp - 0x94));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x38;
    caml_modify (eax, eax);
    caml_stack_usage ();
    eax = eax + eax + 1;
    eax = *((ebp - 0x1c));
    eax += 0x3c;
    caml_modify (eax, eax);
    eax = *((ebp - 0x84));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066798 */
#include <stdint.h>
 
int32_t caml_nativeint_add (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax += *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051d10 */
#include <stdint.h>
 
int32_t camlArray_append_1054 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    ecx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    if (edx == 1) {
        if (ecx == 1) {
            eax = loc.camlArray__31;
            return eax;
        }
        *(esp) = ecx;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0xc)) = eax;
    } else {
        *(esp) = ecx;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0xc)) = eax;
    }
    if (edx > 1) {
        ebx = eax;
    }
    esi = *((ebx - 4));
    if (esi != 0xfe) {
        esi = *(ebx);
    } else {
label_2:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (edx + ecx - 1);
    esi = eax;
    ebx = 1;
    edi = *((esp + 8));
    edi += 0xfffffffe;
    if (ebx > edi) {
        goto label_4;
    }
    do {
        ecx = *((esp + 0xc));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != edi);
label_4:
    ebx = 1;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_6;
    }
    *(esp) = eax;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_7;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 8));
        ecx = ebx + eax - 1;
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ecx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        ebx += 2;
        eax = *(esp);
    } while (ecx != eax);
label_6:
    eax = esi;
    return eax;
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066d88 */
#include <stdint.h>
 
int32_t caml_int32_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_int32 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d7e0 */
#include <stdint.h>
 
int32_t camlUnix_open_process_1967 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    *((esp + 8)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x10)) = ebx;
    eax = *(eax);
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *(esp) = ebx;
    eax = *(eax);
    *((esp + 0xc)) = eax;
    eax = *((esp + 4));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *((esp + 0x14)) = eax;
    eax = *(esp);
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    ecx = eax;
    *((esp + 0x18)) = ecx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x24;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x800;
    eax = *(esp);
    *(edx) = eax;
    *((edx + 4)) = 1;
    ebx = edx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = edx;
    ebx = edx + 0x18;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 0x14));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = *((esp + 8));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x10));
    esi = *(esp);
    camlUnix_open_proc_1949 (ebx);
    eax = *((esp + 0xc));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x10));
    eax = unix_close;
    caml_c_call (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 0x14));
            *(eax) = ebx;
            ebx = *((esp + 0x18));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80673b0 */
#include <stdint.h>
 
int32_t caml_sinh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    sinh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f34 */
#include <stdint.h>
 
void sinh (void) {
    sinh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c940 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_optint_1660 (void) {
    eax = unix_setsockopt;
    caml_c_call (5);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fbd4 */
#include <stdint.h>
 
int32_t caml_globalsym (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_dlsym (0, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fbba */
#include <stdint.h>
 
int32_t caml_dlsym (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    dlsym ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a214 */
#include <stdint.h>
 
void dlsym (void) {
    dlsym ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c0b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2708 (void) {
    eax = unix_dup2;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fbef */
#include <stdint.h>
 
int32_t caml_dlclose (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(esp) = eax;
    dlclose ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a044 */
#include <stdint.h>
 
void dlclose (void) {
    dlclose ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80673cd */
#include <stdint.h>
 
int32_t caml_sin_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    sin (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a7f4 */
#include <stdint.h>
 
void sin (void) {
    sin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065e83 */
#include <stdint.h>
 
int32_t caml_int32_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80701e4 */
#include <stdint.h>
 
int32_t caml_record_backtrace (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    if (eax != *(obj.caml_backtrace_active)) {
        *(obj.caml_backtrace_active) = eax;
        *(obj.caml_backtrace_pos) = 0;
        if (eax != 0) {
            caml_register_global_root (obj.caml_backtrace_last_exn);
        } else {
            caml_remove_global_root (obj.caml_backtrace_last_exn);
        }
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067d69 */
#include <stdint.h>
 
uint32_t caml_make_vect (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_70h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    edi = caml_local_roots;
    eax = ebp - 0x38;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    esi = *((ebp + 8));
    esi >>= 1;
    if (esi == 0) {
        *((ebp - 0x3c)) = 0x8082244;
        goto label_0;
    }
    *((ebp - 0x38)) = edi;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = *((ebp + 0xc));
    edx = *((ebp + 0xc));
    edx &= 1;
    if (edx != 0) {
        goto label_1;
    }
    *((ebp - 0x70)) = eax;
    ebx = eax;
    ebx >>= 0x17;
    ecx = eax;
    ecx >>= 0xc;
    ecx &= 0x7ff;
    ebx = *((ebx*4 + obj.caml_page_table));
    if ((*((ebx + ecx)) & 7) == 0) {
        goto label_1;
    }
    if (*((eax - 4)) != 0xfd) {
        goto label_1;
    }
    *(fp_stack--) = *(eax);
    *((ebp - 0x70)) = fp_stack[0];
    fp_stack--;
    eax = esi + esi;
    if (eax > 0x3fffff) {
        eax = caml_invalid_argument ("Array.make");
    }
    eax = caml_alloc (eax, 0xfe);
    *((ebp - 0x3c)) = eax;
    eax = 0;
    do {
        edx = *((ebp - 0x3c));
        *(fp_stack--) = *((ebp - 0x70));
        *((edx + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (esi > eax);
    goto label_0;
label_1:
    if (esi > 0x3fffff) {
        caml_invalid_argument ("Array.make");
    }
    if (esi > 0xff) {
        goto label_2;
    }
    eax = caml_alloc_small (esi, 0);
    *((ebp - 0x3c)) = eax;
    esi <<= 2;
    eax = 0;
    do {
        ecx = *((ebp + 0xc));
        edx = *((ebp - 0x3c));
        *((eax + edx)) = ecx;
        eax += 4;
    } while (eax != esi);
    goto label_0;
label_2:
    if (edx != 0) {
        goto label_3;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_3;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_3;
    }
    caml_minor_collection ();
    eax = caml_alloc_shr (esi, 0);
    *((ebp - 0x3c)) = eax;
    esi <<= 2;
    eax = 0;
    do {
        ecx = *((ebp + 0xc));
        edx = *((ebp - 0x3c));
        *((edx + eax)) = ecx;
        eax += 4;
    } while (eax != esi);
    eax = *((ebp - 0x3c));
    eax = caml_check_urgent_gc (eax);
    *((ebp - 0x3c)) = eax;
    goto label_0;
label_3:
    eax = caml_alloc_shr (esi, 0);
    *((ebp - 0x3c)) = eax;
    ebx = 0;
    do {
        eax = *((ebp + 0xc));
        eax = ebx*4;
        eax += *((ebp - 0x3c));
        caml_initialize (eax, eax);
        ebx++;
    } while (esi > ebx);
    eax = *((ebp - 0x3c));
    eax = caml_check_urgent_gc (eax);
    *((ebp - 0x3c)) = eax;
label_0:
    *(obj.caml_local_roots) = edi;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064e07 */
#include <stdint.h>
 
int32_t caml_shrink_heap (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    if (ebx == *(obj.caml_heap_start)) {
        goto label_0;
    }
    esi = ebx - 0x10;
    eax = caml_stat_heap_size;
    eax -= *((esi + 8));
    *(obj.caml_stat_heap_size) = eax;
    eax >>= 0xa;
    caml_gc_message (4, "Shrinking heap to %luk bytes\n", eax);
    *(obj.caml_stat_heap_chunks)--;
    eax = caml_heap_start;
    edx = caml_heap_start;
    if (ebx == eax) {
        goto label_1;
    }
    do {
        edx = eax - 4;
        eax = *((eax - 4));
    } while (ebx != eax);
label_1:
    eax = *((esi + 0xc));
    *(edx) = eax;
    eax = ebx;
    eax += *((esi + 8));
    caml_page_table_remove (1, ebx, eax);
    caml_free_for_heap (ebx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058d70 */
#include <stdint.h>
 
int32_t loc_camlPrintf_code_begin (void) {
    eax = ebx;
    ecx = *((eax + 8));
    ebx = *((eax + 0xc));
    eax = *((eax + 0x10));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064bec */
#include <stdint.h>
 
int32_t caml_initialize (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(ebx) = eax;
    if ((al & 1) == 0) {
        if (eax >= *(obj.caml_young_end)) {
            goto label_0;
        }
        if (eax <= *(obj.caml_young_start)) {
            goto label_0;
        }
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 1) == 0) {
            goto label_0;
        }
        eax = .comment;
        if (eax >= *(0x807ebcc)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807ebc8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c920 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_optint_1657 (void) {
    eax = unix_getsockopt;
    caml_c_call (5);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067acc */
#include <stdint.h>
 
int32_t caml_string_greaterthan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax > 1) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b2d0 */
#include <stdint.h>
 
int32_t caml_curry3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry3_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806094d */
#include <stdint.h>
 
int32_t unix_tcsetattr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x117f1;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0x28)) = eax;
    eax = ebx + 0x9774;
    *((esp + 4)) = eax;
    eax = *((ebp - 0x28));
    *(esp) = eax;
    eax = tcgetattr ();
    if (eax == -1) {
        eax = ebx - 0x13fb;
        uerror (eax, 0);
    }
    eax = *((ebx + 0x92f4));
    if (eax == 4) {
        goto label_1;
    }
    edi = *((ebp + 0x10));
    esi = ebx + 0x92f4;
    edx = ebx - 0x138c;
    *((ebp - 0x24)) = edx;
    ecx = ebx + 0x9774;
    *((ebp - 0x2c)) = ecx;
label_0:
    esi += 4;
    if (eax != 1) {
        if (eax <= 1) {
            if (eax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (eax == 2) {
            goto label_4;
        }
        if (eax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        eax = *(esi);
        ecx = *((esi + 4));
        esi += 8;
        edx = *(edi);
        edx >>= 1;
        if (edx != 0) {
            *(eax) |= ecx;
            goto label_3;
        }
        ecx = ~ecx;
        *(eax) &= ecx;
        goto label_3;
    }
    eax = *(esi);
    edx = *((esi + 8));
    *((ebp - 0x1c)) = edx;
    edx = esi + 0xc;
    ecx = *(edx);
    *((ebp - 0x20)) = ecx;
    ecx = *(edi);
    ecx >>= 1;
    ecx -= *((esi + 4));
    if (ecx >= 0) {
        if (*((ebp - 0x1c)) <= ecx) {
            goto label_6;
        }
        edx += 4;
        esi = *((ebp - 0x20));
        esi = ~esi;
        esi &= *(eax);
        esi |= *((edx + ecx*4));
        *(eax) = esi;
        eax = *((ebp - 0x1c));
        esi = edx + eax*4;
        goto label_3;
    }
label_6:
    eax = ebx - 0x13fb;
    unix_error (0x16, eax, 0);
label_4:
    ecx = *(esi);
    edx = *(edi);
    edx >>= 1;
    eax = 1;
    if (edx == *((ebx - 0x1388))) {
        al = 0;
        goto label_7;
    }
    *((ebp - 0x1c)) = esi;
    esi = *((ebp - 0x24));
    do {
        if (edx == *((esi + eax*8 + 4))) {
            esi = *((ebp - 0x1c));
label_7:
            if (ecx != 0) {
                edx = 0;
                if (ecx != 1) {
                    goto label_8;
                }
                eax = *((ebx + eax*8 - 0x138c));
                *((esp + 4)) = eax;
                edx = *((ebp - 0x2c));
                *(esp) = edx;
                eax = cfsetospeed ();
                edx = eax;
            } else {
                eax = *((ebx + eax*8 - 0x138c));
                *((esp + 4)) = eax;
                ecx = *((ebp - 0x2c));
                *(esp) = ecx;
                eax = cfsetispeed ();
                edx = eax;
            }
label_8:
            if (edx != -1) {
                esi += 4;
                goto label_3;
            }
            eax = ebx - 0x13fb;
            eax = uerror (eax, 0);
        }
        eax++;
    } while (eax != 0x12);
    eax = ebx - 0x13fb;
    unix_error (0x16, eax, 0);
label_5:
    eax = *(esi);
    esi += 4;
    edx = *(edi);
    edx >>= 1;
    *((ebx + eax + 0x9785)) = dl;
label_3:
    eax = *(esi);
    if (eax != 4) {
        edi += 4;
        goto label_0;
    }
label_1:
    eax = ebx + 0x9774;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x13b0));
    *((esp + 4)) = eax;
    eax = *((ebp - 0x28));
    *(esp) = eax;
    eax = tcsetattr ();
    if (eax == -1) {
        eax = ebx - 0x13fb;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b040 */
#include <stdint.h>
 
int32_t caml_curry6_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062e74 */
#include <stdint.h>
 
int32_t caml_fatal_error_arg2 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    char ** format;
    int32_t var_8h;
    eax = *((ebp + 0xc));
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax = stderr;
    fprintf (eax, eax);
    eax = *((ebp + 0x14));
    *((esp + 8)) = eax;
    eax = *((ebp + 0x10));
    eax = stderr;
    fprintf (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a574 */
#include <stdint.h>
 
void fprintf (void) {
    fprintf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061969 */
#include <stdint.h>
 
int32_t caml_startup (int32_t arg_8h) {
    eax = *((ebp + 8));
    caml_main (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bba0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2857 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f540 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1406 (void) {
    eax = caml_ml_input_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064f92 */
#include <stdint.h>
 
uint32_t caml_alloc_shr (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    if (esi > 0x3fffff) {
        caml_raise_out_of_memory ();
    }
    eax = caml_fl_allocate (esi);
    ebx = eax;
    if (eax != 0) {
        goto label_0;
    }
    edx = 0x51eb851f;
    eax = esi;
    edx:eax = eax * edx;
    edx >>= 5;
    edx *= *(obj.caml_percent_free);
    eax = esi + edx + 1;
    eax <<= 2;
    eax = caml_round_heap_chunk_size (eax);
    ebx = eax;
    eax = caml_alloc_for_heap (eax);
    edi = eax;
    if (eax != 0) {
        edx = ebx;
        edx >>= 2;
        edx--;
        ecx = eax;
        if (edx > 0x3fffff) {
            goto label_1;
        }
        goto label_2;
    }
    eax = caml_gc_message (4, "No room for growing heap\n", 0);
    goto label_3;
    do {
        ecx = eax;
label_1:
        *(eax) = 0xfffffe00;
        eax += 0x1000000;
        ebx -= 0x1000000;
        edx = eax + 4;
        *((ecx + 4)) = edx;
        *((edi + 8)) = edx;
        edx = ebx;
        edx >>= 2;
        edx--;
    } while (edx > 0x3fffff);
    ecx = eax;
label_2:
    if (ebx > 1) {
        edx <<= 0xa;
        edx += 0x200;
        *(eax) = edx;
        ecx += 4;
        *((edi + 8)) = ecx;
        *(ecx) = 0;
    } else {
        *((ecx + 4)) = 0;
        if (ebx != 1) {
            goto label_4;
        }
        *(eax) = 0;
    }
label_4:
    eax = caml_add_to_heap (edi);
    if (eax != 0) {
        caml_free_for_heap (edi);
    } else {
        edi += 4;
        if (edi != 0) {
            goto label_5;
        }
    }
label_3:
    if (*(obj.caml_in_minor_collection) != 0) {
        caml_fatal_error ("Fatal error: out of memory.\n");
    }
    caml_raise_out_of_memory ();
label_5:
    caml_fl_add_blocks (edi);
    eax = caml_fl_allocate (esi);
    ebx = eax;
label_0:
    eax = caml_gc_phase;
    if (eax != 0) {
        if (eax != 1) {
            goto label_6;
        }
        if (ebx < *(obj.caml_gc_sweep_hp)) {
            goto label_6;
        }
    }
    eax = esi;
    eax <<= 0xa;
    edx = *((ebp + 0xc));
    eax = edx + eax + 0x300;
    *(ebx) = eax;
    goto label_7;
label_6:
    eax = esi;
    eax <<= 0xa;
    eax += *((ebp + 0xc));
    *(ebx) = eax;
label_7:
    eax = caml_allocated_words;
    eax = esi + eax + 1;
    *(obj.caml_allocated_words) = eax;
    edx = caml_minor_heap_size;
    edx >>= 2;
    if (eax > edx) {
        caml_urge_major_slice ();
    }
    eax = ebx + 4;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050a10 */
#include <stdint.h>
 
uint32_t camlArray_fill_1135 (void) {
    do {
        edi = eax;
        esi = ecx;
        if (ebx == 1) {
            goto label_0;
        }
        ebp = *((ebx + 4));
        ecx = *(ebx);
        ebx = *((esi + 0xc));
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            caml_modify (ebx + edi*2 - 2, ecx);
        } else {
            *(fp_stack--) = *(ecx);
            *((ebx + edi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = edi;
        eax += 2;
        ebx = ebp;
        ecx = esi;
    } while (1);
label_0:
    eax = *((esi + 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060d3c */
#include <stdint.h>
 
uint32_t unix_time (void) {
    time_t var_ch;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11404;
    eax = time (0);
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0xc));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a584 */
#include <stdint.h>
 
void time (void) {
    time ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fe20 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_char_1277 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x80755d8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c860 */
#include <stdint.h>
 
int32_t camlUnix_fun_2816 (void) {
    eax = unix_setsockopt;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b0b0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1689 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d7d3 */
#include <stdint.h>
 
uint32_t unix_gethostbyname (int32_t arg_8h, char * src, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_2740h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14962;
    edi = *((ebp + 8));
    eax = caml_string_length (edi);
    eax++;
    eax = caml_stat_alloc (eax);
    esi = eax;
    strcpy (eax, edi);
    caml_enter_blocking_section ();
    eax = h_errno_location ();
    *((esp + 0x14)) = eax;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = 0x2710;
    eax = ebp - 0x2740;
    *((esp + 8)) = eax;
    eax = ebp - 0x30;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = gethostbyname_r ();
    edi = eax;
    caml_leave_blocking_section ();
    if (edi != 0) {
        *((ebp - 0x1c)) = 0;
    }
    caml_stat_free (esi);
    eax = *((ebp - 0x1c));
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_host_entry ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057d40 */
#include <stdint.h>
 
int32_t camlHashtbl_iter_1129 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlHashtbl__do_bucket_1132;
    *((ecx + 4)) = 3;
    *((ecx + 8)) = edx;
    edx = *((ebx + 4));
    eax = 1;
    ebx = *((edx - 4));
    ebx >>= 9;
    ebx |= 1;
    ebx += 0xfffffffe;
    if (eax > ebx) {
        goto label_2;
    }
    *((esp + 0xc)) = ebx;
    *((esp + 8)) = eax;
    *(esp) = edx;
    *((esp + 4)) = ecx;
    do {
        ebx = *(esp);
        ecx = *((ebx - 4));
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_3;
        }
        eax = *((ebx + eax*2 - 2));
        ebx = *((esp + 4));
        camlHashtbl_do_bucket_1132 ();
        eax = *((esp + 8));
        ecx = *((esp + 8));
        eax += 2;
        *((esp + 8)) = eax;
        ebx = *((esp + 0xc));
    } while (ecx != ebx);
label_2:
    eax = 1;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805eb78 */
#include <stdint.h>
 
uint32_t unix_opendir (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x135c0;
    edi = *((ebp + 8));
    *(esp) = edi;
    eax = opendir ();
    esi = eax;
    if (eax == 0) {
        eax = ebx - 0x15b5;
        uerror (eax, edi);
    }
    caml_alloc_small (1, 0xfb);
    *(eax) = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a264 */
#include <stdint.h>
 
void opendir (void) {
    opendir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f520 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1402 (void) {
    eax = caml_input_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80577c0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_rec_1088 (void) {
    int32_t var_4h_5;
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 8));
        *((esp + 4)) = ecx;
        ecx = *((ebx + 4));
        *((esp + 8)) = ecx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053820 */
#include <stdint.h>
 
int32_t camlList_rev_merge_rev_1261 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        if (eax == 1) {
            goto label_2;
        }
        if (ebx == 1) {
            goto label_3;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((edx + 0xc));
        eax = caml_apply2 (edx, eax, ecx);
        if (eax <= 1) {
            goto label_4;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 0xc));
        *(ecx) = eax;
        eax = *((esp + 0x10));
        *((ecx + 4)) = eax;
        eax = *((esp + 0x14));
        ebx = *((esp + 0x18));
        edx = *((esp + 0x1c));
    } while (1);
    do {
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            eax = *((esp + 0x10));
            *((ecx + 4)) = eax;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            edx = *((esp + 0x1c));
            goto label_0;
label_3:
            ebx = ecx;
            void (*0x8054330)() ();
label_2:
            eax = ebx;
            ebx = ecx;
            void (*0x8054330)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066346 */
#include <stdint.h>
 
uint32_t caml_nativeint_format (void) {
    char * format;
    int32_t var_8h_3;
    int32_t var_4h_2;
    int32_t var_8h_2;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x8071d23;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    sprintf (ebx, esi, eax);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c040 */
#include <stdint.h>
 
int32_t camlUnix_fun_2694 (void) {
    eax = unix_chdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b350 */
#include <stdint.h>
 
int32_t camlPrintf_pad_string_1072 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    if (ebx == edi) {
        if (esi != 1) {
            goto label_0;
        }
        eax = edx;
        return eax;
    }
label_0:
    if (ebx <= edi) {
        eax = edx;
        ebx = esi;
        ecx = edi;
        void (*0x8055610)() ();
    }
    eax = ebx;
    ebx = ebp;
    eax = camlString_make_1038 (edi, ebx);
    ecx = eax;
    *((esp + 4)) = ecx;
    eax = *(esp);
    if (eax != 1) {
        edx = 1;
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        esi = *((esp + 0x14));
        camlString_blit_1056 ();
    } else {
        edx = *((esp + 8));
        esi = *((esp + 0x14));
        edx -= esi;
        edx++;
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        camlString_blit_1056 ();
    }
    eax = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806211a */
#include <stdint.h>
 
int32_t caml_oldify_local_roots (void) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_globals_scanned;
    *((ebp - 0x1c)) = eax;
    eax = caml_globals_inited;
    if (*((ebp - 0x1c)) > eax) {
        goto label_8;
    }
    edx = *((ebp - 0x1c));
    edi = *((edx*4 + loc.caml_globals));
    if (edi != 0) {
        goto label_9;
    }
    goto label_8;
    do {
label_0:
        edx = edi + eax*4;
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_10;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_10;
            }
            caml_oldify_one (eax, edx);
        }
label_10:
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_1:
    *((ebp - 0x1c))++;
    eax = caml_globals_inited;
    if (eax < *((ebp - 0x1c))) {
        goto label_8;
    }
    ecx = *((ebp - 0x1c));
    edx = caml_globals;
    edi = *((edx + ecx*4));
    if (edi == 0) {
        goto label_8;
    }
label_9:
    esi = edi - 4;
    edx = *(esi);
    edx >>= 0xa;
    eax = 0;
    ebx = 0;
    if (edx != 0) {
        goto label_0;
    }
    goto label_1;
label_8:
    *(obj.caml_globals_scanned) = eax;
    ecx = caml_dyn_globals;
    *((ebp - 0x1c)) = ecx;
    if (ecx == 0) {
        goto label_11;
    }
label_2:
    eax = *((ebp - 0x1c));
    edi = *(eax);
    esi = edi - 4;
    eax = *(esi);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_12;
    }
    eax = 0;
    ebx = 0;
    do {
        edx = edi + eax*4;
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_13;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_13;
            }
            caml_oldify_one (eax, edx);
        }
label_13:
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_12:
    edx = *((ebp - 0x1c));
    edx = *((edx + 4));
    *((ebp - 0x1c)) = edx;
    if (edx != 0) {
        goto label_2;
    }
label_11:
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
    ecx = caml_bottom_of_stack;
    *((ebp - 0x1c)) = ecx;
    edx = caml_last_return_address;
    eax = caml_gc_regs;
    *((ebp - 0x20)) = eax;
    if (ecx == 0) {
        goto label_14;
    }
label_3:
    esi = caml_frame_descriptors_mask;
    eax = edx;
    eax >>= 3;
    eax &= esi;
    ecx = caml_frame_descriptors;
    ebx = *((ecx + eax*4));
    if (*(ebx) == edx) {
        goto label_15;
    }
    do {
        eax++;
        eax &= esi;
        ebx = *((ecx + eax*4));
    } while (*(ebx) != edx);
label_15:
    if (*((ebx + 4)) == 0xffff) {
        goto label_16;
    }
    esi = *((ebx + 6));
    if (esi <= 0) {
        goto label_17;
    }
    edi = ebx + 8;
    do {
        edx = *(edi);
        if ((dl & 1) != 0) {
            edx >>= 1;
            ecx = *((ebp - 0x20));
            edx = ecx + edx*4;
        } else {
            edx += *((ebp - 0x1c));
        }
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_18;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_18;
            }
            caml_oldify_one (eax, edx);
        }
label_18:
        esi--;
        if (esi <= 0) {
            goto label_17;
        }
        edi += 2;
    } while (1);
label_17:
    eax = *((ebx + 4));
    eax &= 0xfffc;
    *((ebp - 0x1c)) += eax;
    eax = *((ebp - 0x1c));
    edx = *((eax - 4));
    goto label_3;
label_16:
    eax = *((ebp - 0x1c));
    eax += 8;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    edx = *((eax + 4));
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    if (*((ebp - 0x1c)) != 0) {
        goto label_3;
    }
label_14:
    esi = caml_local_roots;
    *((ebp - 0x1c)) = 0;
    if (esi != 0) {
        goto label_19;
    }
    goto label_20;
    do {
label_4:
        edx = ebx*4;
        edx += *((esi + edi*4 + 0xc));
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_21;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_21;
            }
            caml_oldify_one (eax, edx);
        }
label_21:
        ebx++;
    } while (*((esi + 8)) > ebx);
label_5:
    edi++;
    if (*((esi + 4)) <= edi) {
        goto label_7;
    }
label_6:
    ebx = *((ebp - 0x1c));
    if (*((esi + 8)) > 0) {
        goto label_4;
    }
    goto label_5;
label_7:
    esi = *(esi);
    if (esi == 0) {
        goto label_20;
    }
label_19:
    edi = 0;
    if (*((esi + 4)) > 0) {
        goto label_6;
    }
    goto label_7;
label_20:
    caml_scan_global_young_roots (sym.caml_oldify_one);
    caml_final_do_young_roots (sym.caml_oldify_one);
    eax = caml_scan_roots_hook;
    if (eax != 0) {
        void (*eax)(uint32_t) (sym.caml_oldify_one);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c060 */
#include <stdint.h>
 
int32_t camlUnix_fun_2698 (void) {
    eax = unix_mkdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80543d0 */
#include <stdint.h>
 
int32_t camlList_map_1062 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlList_map_1062 (eax);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80691e1 */
#include <stdint.h>
 
uint32_t caml_putword (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = caml_channel_binary_mode (ebx, esi);
    if (eax == 0) {
        caml_failwith ("output_binary_int: not a binary channel");
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 0x18;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 0x10;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 8;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e4b0 */
#include <stdint.h>
 
int32_t caml_weak_check (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax++;
    if (eax != 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    eax = *((edx + eax*4));
    al = (eax != *(obj.caml_weak_none)) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061c99 */
#include <stdint.h>
 
void caml_raise_zero_divide (void) {
    return caml_raise_constant (loc.caml_exn_Division_by_zero);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80666df */
#include <stdint.h>
 
int32_t caml_nativeint_mod (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            caml_copy_nativeint (0);
        }
    } else {
        eax = edx;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        caml_copy_nativeint (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067441 */
#include <stdint.h>
 
uint32_t caml_modf_float (int32_t arg_8h) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_10h;
    int32_t var_8h;
    ebx = caml_local_roots;
    *((ebp - 0x30)) = ebx;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 1;
    eax = ebp + 8;
    *((ebp - 0x24)) = eax;
    *((ebp - 0x34)) = 0;
    *((ebp - 0x38)) = 0;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x30;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 3;
    eax = ebp - 0x34;
    *((ebp - 0x50)) = eax;
    eax = ebp - 0x38;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x3c;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x10;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (ebx, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x38)) = eax;
    *(fp_stack--) = *((ebp - 0x10));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x3c)) = eax;
    eax = caml_alloc_tuple (2);
    *((ebp - 0x34)) = eax;
    edx = *((ebp - 0x38));
    *(eax) = edx;
    edx = *((ebp - 0x3c));
    eax = *((ebp - 0x34));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x34));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c320 */
#include <stdint.h>
 
int32_t camlUnix_fun_2774 (void) {
    eax = unix_execv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057ec0 */
#include <stdint.h>
 
int32_t camlHashtbl_Make_1251 (void) {
    int32_t var_4h_3;
    int32_t var_8h_3;
    int32_t var_ch_3;
    int32_t var_10h_2;
    int32_t var_14h;
    int32_t var_18h_2;
    ebx = eax;
    eax = camlHashtbl;
    *(esp) = eax;
    eax = .comment;
    *((esp + 4)) = eax;
    eax = .comment;
    *((esp + 8)) = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xe8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xcf7;
            *(eax) = sym.camlHashtbl__safehash_1177;
            *((eax + 4)) = 3;
            *((eax + 8)) = ebx;
            ecx = eax + 0x10;
            *((esp + 0xc)) = ecx;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry3;
            *((ecx + 4)) = 7;
            *((ecx + 8)) = 0x8056b40;
            *((ecx + 0xc)) = eax;
            ecx = eax + 0x24;
            *((esp + 0x10)) = ecx;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8056c50;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            edx = eax + 0x3c;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry2;
            *((edx + 4)) = 5;
            *((edx + 8)) = 0x8056d50;
            *((edx + 0xc)) = ebx;
            ecx = eax + 0x50;
            *((esp + 0x14)) = ecx;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8056de0;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            *((ecx + 0x14)) = edx;
            esi = eax + 0x6c;
            *((esi - 4)) = 0x14f7;
            *(esi) = sym.caml_curry2;
            *((esi + 4)) = 5;
            *((esi + 8)) = 0x8056ff0;
            *((esi + 0xc)) = ebx;
            *((esi + 0x10)) = eax;
            edx = eax + 0x84;
            *((edx - 4)) = 0x14f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80570c0;
            *((edx + 0xc)) = ebx;
            *((edx + 0x10)) = eax;
            ecx = eax + 0x9c;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80572c0;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            ebx = .comment;
            ebp = .comment;
            edi = .comment;
            eax += 0xb4;
            *((eax - 4)) = 0x3000;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            ebx = *((esp + 8));
            *((eax + 8)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 0x10));
            *((eax + 0x10)) = ebx;
            ebx = *((esp + 0x14));
            *((eax + 0x14)) = ebx;
            *((eax + 0x18)) = esi;
            *((eax + 0x1c)) = edx;
            *((eax + 0x20)) = ecx;
            ebx = *((esp + 0x18));
            *((eax + 0x24)) = ebx;
            *((eax + 0x28)) = ebp;
            *((eax + 0x2c)) = edi;
            return eax;
        }
        caml_call_gc (ebx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c020 */
#include <stdint.h>
 
int32_t camlUnix_fun_2690 (void) {
    eax = unix_chroot;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a663 */
#include <stdint.h>
 
int32_t caml_deserialize_block_2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14h;
    int32_t var_10h;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    ecx = intern_src;
    if (edi <= 0) {
        goto label_0;
    }
    eax = 0;
    *((ebp - 0x14)) = edi;
    *((ebp - 0x10)) = edi;
    do {
        esi = *((ecx + eax));
        edi = *((ecx + eax + 1));
        edx = edi;
        *((ebx + eax)) = dl;
        edx = esi;
        *((ebx + eax + 1)) = dl;
        eax += 2;
        *((ebp - 0x14))--;
    } while (*((ebp - 0x14)) != 0);
    edi = *((ebp - 0x10));
    ecx = ecx + edi*2;
label_0:
    *(obj.intern_src) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ea34 */
#include <stdint.h>
 
uint32_t unix_nice (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13707;
    eax = errno_location ();
    esi = eax;
    *(eax) = 0;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = nice ();
    if (eax == -1) {
        if (*(esi) == 0) {
            goto label_0;
        }
        eax = ebx - 0x15bf;
        uerror (eax, 0);
    }
label_0:
    eax = eax + eax + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a404 */
#include <stdint.h>
 
void nice (void) {
    nice ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a58c */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_1 (void) {
    edx = intern_src;
    eax = *(edx);
    edx++;
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c340 */
#include <stdint.h>
 
int32_t camlUnix_fun_2778 (void) {
    eax = caml_sys_getenv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069316 */
#include <stdint.h>
 
uint32_t caml_ml_flush (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    if (*(ebx) == -1) {
        *(obj.caml_local_roots) = esi;
    } else {
        eax = caml_channel_mutex_lock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        caml_flush (ebx);
        eax = caml_channel_mutex_unlock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        *(obj.caml_local_roots) = esi;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dcfd */
#include <stdint.h>
 
int32_t unix_getprotobyname (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14443;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getprotobyname ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_proto_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a0a4 */
#include <stdint.h>
 
void getprotobyname (void) {
    getprotobyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806108c */
#include <stdint.h>
 
uint32_t unix_unlink (void) {
    int32_t var_bp_8h;
    int32_t var_bp_4h;
    int32_t var_4h_2;
    char * path;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x110af;
    esi = *((ebp + 8));
    eax = unlink (esi);
    if (eax == -1) {
        eax = ebx - 0x12a4;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b650 */
#include <stdint.h>
 
int32_t camlSource_mmult_1045 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    ebx += 0xfffffffe;
    eax += 0xfffffffe;
    edi = 1;
    if (edi > eax) {
        goto label_1;
    }
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edi;
    *((esp + 0x14)) = eax;
    *((esp + 8)) = ebx;
    *((esp + 4)) = esi;
    *((esp + 0x1c)) = edx;
    *(esp) = ecx;
label_0:
    eax = *(esp);
    eax = *((eax + edi*2 - 2));
    *((esp + 0x18)) = eax;
    eax = *((esp + 4));
    eax = *((eax + edi*2 - 2));
    *((esp + 0x24)) = eax;
    esi = 1;
    *((esp + 0x20)) = esi;
    eax = *((esp + 8));
    *((esp + 0x28)) = eax;
    if (esi > eax) {
        goto label_2;
    }
    do {
        ebx = 1;
        eax = *((esp + 0x14));
        ecx = *((esp + 0x18));
        edx = *((esp + 0x1c));
        eax = camlSource_inner_loop_1039 ();
        esi = *((esp + 0x20));
        ebx = *((esp + 0x24));
        *((ebx + esi*2 - 2)) = eax;
        ebx = esi;
        esi += 2;
        *((esp + 0x20)) = esi;
        eax = *((esp + 0x28));
    } while (ebx != eax);
label_2:
    edi = *((esp + 0xc));
    ebx = *((esp + 0xc));
    edi += 2;
    *((esp + 0xc)) = edi;
    eax = *((esp + 0x10));
    if (ebx != eax) {
        goto label_0;
    }
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c2f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2770 (void) {
    eax = unix_execvp;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80605fb */
#include <stdint.h>
 
uint32_t unix_lstat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x11b44;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = lxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x1440;
        uerror (eax, esi);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x1440;
        unix_error (0x4b, eax, esi);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055ea0 */
#include <stdint.h>
 
int32_t camlString_index_from_1116 (void) {
    esi = ebx;
    edx = ecx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    if (esi >= 1) {
        if (esi > ebx) {
            goto label_0;
        }
        ecx = esi;
        void (*0x8055e10)() ();
    }
label_0:
    eax = "String.index_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f8cd */
#include <stdint.h>
 
int32_t unix_sigsuspend (int32_t arg_8h) {
    int32_t var_88h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1286b;
    esi = ebp - 0x88;
    edx = esi;
    eax = *((ebp + 8));
    decode_sigset ();
    caml_enter_blocking_section ();
    *(esp) = esi;
    eax = sigsuspend ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = errno_location ();
        if (*(eax) == 4) {
            goto label_0;
        }
        eax = ebx - 0x1524;
        uerror (eax, 0);
    }
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a8c4 */
#include <stdint.h>
 
void sigsuspend (void) {
    sigsuspend ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2612 (void) {
    eax = unix_getgrgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ff70 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1493 (void) {
    eax = caml_ml_pos_in_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a450 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1572 (void) {
    int32_t var_4h_4;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (3);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 4));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 8));
    eax = *((eax + 0xc));
    void (*0x804b540)() ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d1b0 */
#include <stdint.h>
 
int32_t camlUnix_system_1891 (void) {
    *(esp) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        eax = unix_waitpid;
        eax = caml_c_call (1);
        eax += 4;
        eax = *(eax);
        return eax;
    }
    fcn_0804d210 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d210 */
#include <stdint.h>
 
int32_t fcn_0804d210 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x8073a64;
            eax = *((esp + 8));
            *((ebx + 8)) = eax;
            eax = unix_execv;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8055d80 */
#include <stdint.h>
 
int32_t camlString_apply1_1100 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    if (ecx == 1) {
        eax = ebx;
        return eax;
    }
    eax = ebx;
    eax = camlString_copy_1042 (ebx, eax);
    eax = *(esp);
    eax = *(eax);
    eax = eax + eax + 1;
    ebx = *((esp + 4));
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (eax);
    eax >>= 1;
    edx = eax;
    eax = *((esp + 8));
    *(eax) = dl;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c180 */
#include <stdint.h>
 
int32_t camlPrintf_sprintf_1413 (void) {
    eax = loc.camlPrintf__39;
    eax = camlPrintf_ksprintf_1411 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068bce */
#include <stdint.h>
 
uint32_t caml_really_getblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (ebx <= 0) {
        goto label_0;
    }
    do {
        eax = caml_getblock (edi, esi, ebx);
        if (eax == 0) {
            goto label_0;
        }
        ebx -= eax;
        if (ebx <= 0) {
            goto label_0;
        }
        esi += eax;
    } while (1);
label_0:
    al = (ebx == 0) ? 1 : 0;
    eax = (int32_t) al;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80542f0 */
#include <stdint.h>
 
int32_t camlList_tl_1039 (void) {
    if (eax != 1) {
        eax = *((eax + 4));
        return eax;
    }
    eax = loc.camlList__50;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806dcea */
#include <stdint.h>
 
int32_t caml_md5_chan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10a0h;
    int32_t var_109ch;
    int32_t var_1090h;
    int32_t var_90h;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_local_roots;
    *((ebp - 0x10a0)) = eax;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    edx = ebp + 8;
    *((ebp - 0x2c)) = edx;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    *((ebp - 0x109c)) = eax;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        edx = *((ebp - 0x109c));
        void (*eax)(uint32_t) (edx);
    }
    eax = ebp - 0x90;
    caml_MD5Init (eax);
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        edi = ebp - 0x1090;
        if (ebx > 0) {
            goto label_0;
        }
        goto label_1;
    }
    ebx = ebp - 0x1090;
    esi = ebp - 0x90;
    do {
        eax = *((ebp - 0x109c));
        eax = caml_getblock (eax, ebx, 0x1000);
        if (eax == 0) {
            goto label_1;
        }
        caml_MD5Update (esi, ebx, eax);
    } while (1);
    do {
label_0:
        eax = 0x1000;
        if (ebx <= 0x1000) {
            eax = ebx;
        }
        edx = *((ebp - 0x109c));
        eax = caml_getblock (edx, edi, eax);
        esi = eax;
        if (eax == 0) {
            eax = caml_raise_end_of_file ();
        }
        eax = ebp - 0x90;
        caml_MD5Update (eax, edi, eax);
        ebx -= esi;
    } while (ebx > 0);
label_1:
    eax = caml_alloc_string (0x10);
    ebx = eax;
    eax = ebp - 0x90;
    caml_MD5Final (ebx, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        edx = *((ebp - 0x109c));
        void (*eax)(uint32_t) (edx);
    }
    eax = *((ebp - 0x10a0));
    *(obj.caml_local_roots) = eax;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80574c0 */
#include <stdint.h>
 
int32_t camlHashtbl_resize_1061 (void) {
    int32_t var_18h_3;
    eax = *((ebx + 4));
    eax = *((eax - 4));
    eax >>= 9;
    eax |= 1;
    ebx = .comment;
    eax >>= 1;
    eax = eax*4 + 3;
    eax = camlPervasives_min_1022 (eax, eax);
    ebx = *((esp + 8));
    if (eax == ebx) {
        goto label_1;
    }
    *((esp + 4)) = eax;
    *((esp + 8)) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    *((esp + 0xc)) = ebx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x14f7;
    *(ecx) = sym.camlHashtbl__insert_bucket_1068;
    *((ecx + 4)) = 3;
    eax = *(esp);
    *((ecx + 8)) = eax;
    eax = *((esp + 4));
    *((ecx + 0xc)) = eax;
    *((ecx + 0x10)) = ebx;
    eax = 1;
    ebx = *((esp + 8));
    ebx += 0xfffffffe;
    if (eax > ebx) {
        goto label_3;
    }
    *((esp + 8)) = ebx;
    *((esp + 4)) = eax;
    *(esp) = ecx;
    do {
        ebx = *((esp + 0x14));
        ecx = *((ebx - 4));
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_4;
        }
        eax = *((ebx + eax*2 - 2));
        ebx = *(esp);
        camlHashtbl_insert_bucket_1068 ();
        eax = *((esp + 4));
        ecx = *((esp + 4));
        eax += 2;
        *((esp + 4)) = eax;
        ebx = *((esp + 8));
    } while (ecx != ebx);
label_3:
    eax = *((esp + 0xc));
    eax = *((esp + 0x14));
    eax += 4;
    caml_modify (eax, eax);
    eax = 1;
    return eax;
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
label_4:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fb30 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_1218 (void) {
    ecx = eax;
    ebx = 1;
    eax = loc.camlPervasives__90;
    return camlPervasives_open_in_gen_1214 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068166 */
#include <stdint.h>
 
int32_t caml_array_get_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xb;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    *(fp_stack--) = *((edx + eax*8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b3b0 */
#include <stdint.h>
 
int32_t caml_curry2_1 (void) {
    esi = eax;
    ecx = *((ebx + 0xc));
    eax = *((ebx + 8));
    edx = *((ecx + 8));
    ebx = esi;
    return void (*edx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80546a0 */
#include <stdint.h>
 
int32_t camlList_fold_left2_1119 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        esi = eax;
        if (ecx == 1) {
            goto label_0;
        }
        if (edx == 1) {
            goto label_1;
        }
        eax = *((edx + 4));
        edx = *(edx);
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = ebx;
        ebx = ecx;
        ecx = edx;
        edx = esi;
        eax = caml_apply3 (esi, eax, eax);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
        edx = *((esp + 8));
    } while (1);
label_0:
    if (edx == 1) {
        eax = ebx;
        return eax;
    }
label_1:
    eax = "List.fold_left2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067b1a */
#include <stdint.h>
 
int32_t caml_string_lessthan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax <= 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80669e0 */
#include <stdint.h>
 
int32_t caml_int64_of_int32 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f7b0 */
#include <stdint.h>
 
uint32_t unix_setsid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12990;
    setsid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a094 */
#include <stdint.h>
 
void setsid (void) {
    setsid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060e14 */
#include <stdint.h>
 
int32_t unix_truncate_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11327;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 4)) = eax;
    *((esp + 8)) = edx;
    *(esp) = esi;
    eax = truncate64 ();
    if (eax == -1) {
        eax = ebx - 0x1682;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a224 */
#include <stdint.h>
 
void truncate64 (void) {
    truncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806733c */
#include <stdint.h>
 
int32_t caml_tanh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    tanh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a314 */
#include <stdint.h>
 
void tanh (void) {
    tanh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bcb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2590 (void) {
    eax = unix_getpeername;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f960 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_1179 (void) {
    ecx = eax;
    ebx = 0x36d;
    eax = camlPervasives__94;
    return camlPervasives_open_out_gen_1175 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dbf4 */
#include <stdint.h>
 
uint32_t unix_getppid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1454c;
    getppid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a414 */
#include <stdint.h>
 
void getppid (void) {
    getppid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c900 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_int_1653 (void) {
    eax = unix_setsockopt;
    caml_c_call (3);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ac40 */
#include <stdint.h>
 
int32_t caml_curry9_7 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_8;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e2e3 */
#include <stdint.h>
 
int32_t caml_callback (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callback_exn (eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b150 */
#include <stdint.h>
 
int32_t caml_curry5_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057ca0 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_1122 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlHashtbl__mem_in_bucket_1125;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ecx + edx*2 - 2));
            void (*0x8056a40)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051ff0 */
#include <stdint.h>
 
int32_t camlArray_sub_1081 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
    if (ebx < 1) {
        goto label_2;
    }
    if (ecx < 1) {
        goto label_2;
    }
    esi = *((edx - 4));
    eax = *((edx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = esi;
        eax >>= 9;
    } else {
        eax = esi;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= ecx;
    eax++;
    if (ebx > eax) {
        goto label_2;
    }
    if (ecx == 1) {
        eax = loc.camlArray__28;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    *((esp + 8)) = edx;
    eax = *((edx - 4));
    if (eax != 0xfe) {
        eax = *((edx + ebx*2 - 2));
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *((edx + ebx*4 - 4));
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (ecx);
    esi = eax;
    ebx = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_4;
    }
    *((esp + 0xc)) = eax;
    *(esp) = esi;
    do {
        eax = *((esp + 4));
        edx = eax + ebx - 1;
        ecx = *((esp + 8));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ecx = *((ecx + edx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ecx = eax;
        }
        esi = *(esp);
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, ecx);
        } else {
            *(fp_stack--) = *(ecx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        eax = ebx;
        eax += 2;
        ebx = eax;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_4:
    eax = esi;
    return eax;
label_2:
    eax = "Array.sub";
    void (*0x804f620)() ();
label_5:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80610d4 */
#include <stdint.h>
 
int32_t unix_utimes (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x1106b;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    *((ebp - 0x10)) = eax;
    edx = *((ebp + 0x10));
    *(fp_stack--) = *(edx);
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp - 0x20));
    if (eax == 0) {
        if (edx == 0) {
            goto label_0;
        }
    }
    eax = ebp - 0x10;
label_0:
    *((ebp - 0xc)) = edx;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = utime ();
    if (eax == -1) {
        eax = ebx - 0x129d;
        uerror (eax, esi);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b442 */
#include <stdint.h>
 
int32_t caml_input_value_from_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    caml_input_val_from_string (eax, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059090 */
#include <stdint.h>
 
void camlPrintf_got_spec_1297 (void) {
    edx = ebx;
    ebx = ecx;
    esi = *((ebx + 0xc));
    ecx = *((ebx + 0x14));
    ebx = *((ebx + 0x10));
    return camlPrintf_scan_flags_1292 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2640 (void) {
    eax = unix_setitimer;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805ea94 */
#include <stdint.h>
 
int32_t unix_open (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x136aa;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x38)) = edi;
    edx = ebp - 0x38;
    *(eax) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebx + 0x91b4;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x3c)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    eax++;
    eax = caml_stat_alloc (eax);
    esi = eax;
    eax = *((ebp + 8));
    strcpy (esi, eax);
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    edx = *((ebp - 0x3c));
    *((esp + 4)) = edx;
    *(esp) = esi;
    eax = open64 ();
    *((ebp - 0x3c)) = eax;
    caml_leave_blocking_section ();
    caml_stat_free (esi);
    if (*((ebp - 0x3c)) == -1) {
        eax = *((ebp + 8));
        eax = ebx - 0x15ba;
        uerror (eax, eax);
    }
    eax = *((ebx - 0x18));
    *(eax) = edi;
    edx = *((ebp - 0x3c));
    eax = edx + edx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a464 */
#include <stdint.h>
 
void strcpy (void) {
    strcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049ef4 */
#include <stdint.h>
 
void open64 (void) {
    open64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804be80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2644 (void) {
    eax = unix_utimes;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a8db */
#include <stdint.h>
 
int32_t caml_deserialize_error (int32_t arg_8h) {
    int32_t var_bp_8h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    intern_cleanup ();
    eax = *((ebp + 8));
    return caml_failwith (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80676a4 */
#include <stdint.h>
 
int32_t caml_mul_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] *= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a506 */
#include <stdint.h>
 
uint32_t caml_output_value (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 3;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x14)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    caml_output_val (ebx, eax, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e41d */
#include <stdint.h>
 
uint32_t unix_getitimer (int32_t arg_8h) {
    int32_t var_18h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13d23;
    eax = ebp - 0x18;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x15fc));
    *(esp) = eax;
    eax = getitimer ();
    if (eax == -1) {
        eax = ebx - 0x1611;
        uerror (eax, 0);
    }
    eax = ebp - 0x18;
    unix_convert_itimer ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a854 */
#include <stdint.h>
 
void getitimer (void) {
    getitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cf10 */
#include <stdint.h>
 
uint32_t unix_fork (void) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1522b;
    eax = fork ();
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x1688;
        uerror (eax, 0);
    }
    eax = *((ebx - 0x10));
    if (*(eax) != 0) {
        eax = *((ebx - 0xc));
        eax = *(eax);
        if (eax != 0) {
            if (esi == 0) {
                goto label_0;
            }
        }
        if (eax != 0) {
            goto label_1;
        }
        if (esi == 0) {
            goto label_1;
        }
label_0:
        caml_debugger_cleanup_fork ();
    }
label_1:
    eax = esi + esi + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d644 */
#include <stdint.h>
 
uint32_t unix_getgroups (void) {
    int32_t var_40018h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x14af7;
    eax = ebp - 0x40018;
    *((esp + 4)) = eax;
    *(esp) = 0x10000;
    eax = getgroups ();
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x1672;
        eax = uerror (eax, 0);
    }
    caml_alloc_tuple (eax);
    if (esi <= 0) {
        goto label_0;
    }
    edx = 0;
    edi = ebp - 0x40018;
    do {
        ecx = *((edi + edx*4));
        ecx = ecx + ecx + 1;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edx != esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806947c */
#include <stdint.h>
 
uint32_t caml_ml_seek_out (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_seek_out (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a4d0 */
#include <stdint.h>
 
int32_t camlPrintf_get_int_literal_1258 (void) {
    int32_t var_4h;
    do {
        esi = ebx;
        esi >>= 1;
        edx = *((ecx + 0xc));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx < 0x61) {
            goto label_0;
        }
        if (edx >= 0x75) {
            goto label_1;
        }
        ebx += 2;
        eax >>= 1;
        eax *= 0x14;
        eax = eax + edx - 0x60;
    } while (1);
label_0:
    if (edx != 0x49) {
        goto label_1;
    }
    if (eax == 1) {
        eax = "printf: bad positional specification (0).";
        void (*0x804f5e0)() ();
    }
    eax += 0xfffffffe;
    eax = camlPrintf_index_of_int_1037 (ecx, ebx);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x400;
            *(edx) = ebx;
            eax = *(esp);
            ecx = *((eax + 0x10));
            ebx = *((esp + 4));
            ebx += 2;
            eax = edx;
            void (*0x804b540)() ();
label_1:
            edx = *((ecx + 0x10));
            ebx = *((ecx + 0x14));
            eax = 1;
            ecx = edx;
            void (*0x804b540)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bcd0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2594 (void) {
    eax = unix_shutdown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f8e7 */
#include <stdint.h>
 
int32_t caml_register_custom_operations (int32_t arg_8h) {
    caml_stat_alloc (8);
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = custom_ops_table;
    *((eax + 4)) = edx;
    *(obj.custom_ops_table) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80544d0 */
#include <stdint.h>
 
int32_t camlList_fold_left_1078 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        eax = ebx;
        if (ecx == 1) {
            goto label_0;
        }
        esi = *((ecx + 4));
        ecx = *(ecx);
        ebx = *(ecx);
        ecx = edx;
        eax = caml_apply2 (edx, esi);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c1d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2740 (void) {
    eax = unix_truncate;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f468 */
#include <stdint.h>
 
int32_t caml_final_register (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 0xc));
    if ((bl & 1) == 0) {
        esi = ebx;
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 3) != 0) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Gc.finalise");
label_0:
    eax = size;
    if (*(obj.young) >= eax) {
        edx = final_table;
        if (edx == 0) {
            eax = caml_stat_alloc (0x168);
            *(obj.final_table) = eax;
            *(obj.size) = 0x1e;
        } else {
            edi = eax + eax;
            eax = edi + eax*4;
            eax <<= 2;
            eax = caml_stat_resize (edx, eax);
            *(obj.final_table) = eax;
            *(obj.size) = edi;
        }
    }
    eax = young;
    edx = eax * 3;
    edx <<= 2;
    edx += *(obj.final_table);
    ecx = *((ebp + 8));
    *(edx) = ecx;
    ecx = esi - 4;
    if (*(ecx) == 0xf9) {
        ebx = *(ecx);
        ebx >>= 0xa;
        ebx <<= 2;
        *((edx + 8)) = ebx;
        ecx = *(ecx);
        ecx >>= 0xa;
        ecx <<= 2;
        esi -= ecx;
        *((edx + 4)) = esi;
    } else {
        *((edx + 8)) = 0;
        *((edx + 4)) = ebx;
    }
    eax++;
    *(obj.young) = eax;
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059230 */
#include <stdint.h>
 
int32_t camlPrintf_cont_s_1361 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((edx + 0x54));
    eax = *((edx + 0x5c));
    caml_apply2 (edx, eax, ecx);
    ecx = *(esp);
    ecx += 0xfffffff0;
    eax = *((esp + 4));
    ebx = *((esp + 8));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c200 */
#include <stdint.h>
 
int32_t camlUnix_fun_2744 (void) {
    eax = caml_channel_descriptor;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bcf0 */
#include <stdint.h>
 
int32_t camlPrintf_make_valid_float_lexeme_1270 (void) {
    ecx = eax;
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    edx = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.camlPrintf__valid_float_loop_1273;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            *((ebx + 0xc)) = edx;
            eax = 1;
            void (*0x805a590)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e6ab */
#include <stdint.h>
 
int32_t caml_weak_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = *((ebp + 8));
    ecx = *((ebp + 0x10));
    edx = *((ebp + 0xc));
    edx >>= 1;
    edx++;
    if (edx != 0) {
        esi = eax;
        ebx = *((eax - 4));
        ebx >>= 0xa;
        if (edx < ebx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.set");
label_0:
    if (ecx != 1) {
        if ((cl & 1) == 0) {
            ecx = *(ecx);
            do_set ();
        }
    } else {
        eax = "8!\b\b";
        *((esi + edx*4)) = eax;
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8063ed0 */
#include <stdint.h>
 
int32_t caml_darken (int32_t arg_8h) {
    eax = *((ebp + 8));
    if ((al & 1) == 0) {
        ebx = eax;
        ecx = eax;
        ecx >>= 0x17;
        edx = eax;
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 1) == 0) {
            goto label_0;
        }
        edx = *((eax - 4));
        ecx = (int32_t) dl;
        if (ecx == 0xf9) {
            edx >>= 0xa;
            eax = edx*4;
            ebx -= eax;
            eax = ebx;
            edx = *((ebx - 4));
            ecx = (int32_t) dl;
        }
        if ((dh & 3) != 0) {
            goto label_0;
        }
        if (ecx <= 0xfa) {
            dh &= 0xfc;
            dh |= 1;
            *((eax - 4)) = edx;
            edx = gray_vals_cur;
            *(edx) = eax;
            eax = edx + 4;
            *(obj.gray_vals_cur) = eax;
            if (eax < *(obj.gray_vals_end)) {
                goto label_0;
            }
            realloc_gray_vals ();
        } else {
            dh |= 3;
            *((eax - 4)) = edx;
        }
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ff20 */
#include <stdint.h>
 
int32_t camlPervasives_read_int_1289 (void) {
    eax = 1;
    eax = camlPervasives_read_line_1288 ();
    eax = caml_int_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ff00 */
#include <stdint.h>
 
int32_t camlPervasives_read_line_1288 (void) {
    eax = caml_ml_flush;
    caml_c_call (*(0x80755d4));
    eax = .comment;
    return camlPervasives_input_line_1241 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056d50 */
#include <stdint.h>
 
uint32_t camlHashtbl_find_rec_1193 (void) {
    int32_t var_4h;
    int32_t var_8h_2;
    int32_t var_ch;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 8));
        edx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((ecx + 0xc));
        ecx = *(ecx);
        eax = caml_apply2 (eax, edx, ecx);
        if (eax != 1) {
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804beb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2648 (void) {
    eax = unix_sleep;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806df02 */
#include <stdint.h>
 
uint32_t caml_format_exception (int32_t arg_8h) {
    int32_t var_170h;
    uint32_t var_16ch;
    char * s;
    int32_t var_120h;
    int32_t var_11ch;
    int32_t var_118h;
    int32_t var_19h;
    int32_t var_18h;
    char * format;
    size_t n;
    ebx = *((ebp + 8));
    eax = ebp - 0x120;
    edx = ebp - 0x118;
    *((ebp - 0x120)) = edx;
    edx = ebp - 0x19;
    *((ebp - 0x11c)) = edx;
    edx = *(ebx);
    edx = *(edx);
    add_string (ebx, esi, edi);
    eax = *((ebx - 4));
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_0;
    }
    if (eax == 2) {
        esi = *((ebx + 4));
        if ((esi & 1) != 0) {
            goto label_1;
        }
        *((ebp - 0x16c)) = 0;
        if (*((esi - 4)) == 0) {
            goto label_2;
        }
    }
label_1:
    esi = ebx;
    *((ebp - 0x16c)) = 1;
label_2:
    eax = ebp - 0x120;
    edx = 0x28;
    add_char ();
    *((ebp - 0x170)) = esi;
    edi = esi;
    edi -= 4;
    eax = *(edi);
    eax >>= 0xa;
    if (*((ebp - 0x16c)) >= eax) {
        goto label_3;
    }
    esi = *((ebp - 0x16c));
    while (eax > esi) {
        if (*((ebp - 0x16c)) < esi) {
            edx = 0x8071be4;
            eax = ebp - 0x120;
            add_string ();
        }
        eax = *((ebp - 0x170));
        ebx = *((eax + esi*4));
        if ((bl & 1) != 0) {
            ebx >>= 1;
            edx = ebp - 0x160;
            sprintf (edx, 0x80718db, ebx);
            edx = ebp - 0x160;
            eax = ebp - 0x120;
            add_string ();
        } else {
            if (*((ebx - 4)) == 0xfc) {
                edx = 0x22;
                eax = ebp - 0x120;
                add_char ();
                edx = ebx;
                eax = ebp - 0x120;
                add_string ();
                edx = 0x22;
                eax = ebp - 0x120;
                add_char ();
            } else {
                edx = 0x5f;
                eax = ebp - 0x120;
                add_char ();
            }
        }
        esi++;
        eax = *(edi);
        eax >>= 0xa;
    }
label_3:
    eax = ebp - 0x120;
    edx = 0x29;
    add_char ();
label_0:
    eax = *((ebp - 0x120));
    *(eax) = 0;
    eax = *((ebp - 0x120));
    edx = ebp - 0x18;
    eax -= edx;
    esi = eax + 0x101;
    eax = malloc (esi);
    ebx = eax;
    if (eax != 0) {
        eax = ebp - 0x118;
        memmove (ebx, eax, esi);
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fb50 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_bin_1220 (void) {
    ecx = eax;
    ebx = 1;
    eax = loc.camlPervasives__89;
    return camlPervasives_open_in_gen_1214 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f7a0 */
#include <stdint.h>
 
int32_t camlPervasives_char_of_int_1120 (void) {
    if (eax >= 1) {
        if (eax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    eax = "char_of_int";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bcf0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2598 (void) {
    eax = unix_connect;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065e23 */
#include <stdint.h>
 
int32_t caml_int_compare (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bdbe */
#include <stdint.h>
 
int32_t caml_sys_rename (char * oldpath, int32_t arg_ch) {
    char * newpath;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = rename (eax, eax);
    if (eax != 0) {
        caml_sys_error (1);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d8ef */
#include <stdint.h>
 
int32_t unix_gethostbyaddr (int32_t arg_8h, int32_t arg_ch, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch) {
    int32_t var_2738h;
    int32_t var_2734h;
    int32_t var_24h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x1484d;
    eax = *((ebp + 8));
    eax = *(eax);
    *((ebp - 0xc)) = eax;
    caml_enter_blocking_section ();
    eax = ebp - 0x2738;
    *((esp + 0x1c)) = eax;
    eax = ebp - 0x10;
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = 0x2710;
    eax = ebp - 0x2734;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x24;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 2;
    *((esp + 4)) = 4;
    eax = ebp - 0xc;
    *(esp) = eax;
    eax = gethostbyaddr_r ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        *((ebp - 0x10)) = 0;
    } else {
        eax = *((ebp - 0x10));
        if (eax != 0) {
            goto label_0;
        }
    }
    caml_raise_not_found ();
label_0:
    alloc_host_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065f13 */
#include <stdint.h>
 
int32_t caml_int64_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80587e0 */
#include <stdint.h>
 
int32_t camlBuffer_add_substring_1076 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *(esp) = ebx;
    *((esp + 4)) = ecx;
    *((esp + 8)) = edx;
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        eax = *((ebx - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        ebx = *((ebx + eax));
        eax -= ebx;
        eax <<= 1;
        eax -= edx;
        eax += 2;
        if (ecx <= eax) {
            goto label_1;
        }
    }
label_0:
    eax = "Buffer.add_substring";
    camlPervasives_invalid_arg_1012 ();
label_1:
    eax = *((esp + 0x10));
    ecx = *((eax + 4));
    ebx = *((esp + 8));
    edx = ecx + ebx - 1;
    *((esp + 0xc)) = edx;
    ecx = *((eax + 8));
    if (edx > ecx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 0x10));
    edx = *((eax + 4));
    ecx = *(eax);
    eax = *(esp);
    ebx = *((esp + 4));
    esi = *((esp + 8));
    camlString_blit_1056 ();
    ebx = *((esp + 0xc));
    eax = *((esp + 0x10));
    *((eax + 4)) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061bb1 */
#include <stdint.h>
 
int32_t caml_raise_with_string (void) {
    int32_t var_ch_3;
    int32_t var_4h_4;
    int32_t var_4h_3;
    eax = *((ebp + 0xc));
    eax = caml_copy_string (eax);
    eax = *((ebp + 8));
    return caml_raise_with_arg (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80557c0 */
#include <stdint.h>
 
int32_t camlString_concat_1066 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (ebx == 1) {
        goto label_1;
    }
    *((esp + 0xc)) = eax;
    eax = *((ebx + 4));
    *((esp + 0x10)) = eax;
    eax = *(ebx);
    *((esp + 8)) = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x24;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x400;
    *(edx) = 1;
    ecx = edx + 8;
    *((ecx - 4)) = 0x400;
    *(ecx) = 1;
    eax = edx + 0x10;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.camlString__fun_1160;
    *((eax + 4)) = 3;
    *((eax + 8)) = edx;
    *((eax + 0xc)) = ecx;
    camlList_iter_1074 (edx, ecx);
    eax = *(esp);
    eax = *(eax);
    eax += 0xfffffffe;
    eax >>= 1;
    ebx = *((esp + 0xc));
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    ebx = *((ebx + ecx));
    ecx -= ebx;
    ecx <<= 1;
    ecx *= eax;
    eax = *((esp + 4));
    eax = *(eax);
    eax += ecx;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    edi = eax;
    esi = *((esp + 8));
    eax = *((esi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((esi + eax));
    eax -= ebx;
    caml_blit_string (edi, 1, edi, 1, eax + eax + 1);
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x400;
            eax = *((esi - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            ecx = *((esi + eax));
            eax -= ecx;
            eax = eax + eax + 1;
            *(ebx) = eax;
            eax = ebx + 8;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlString__fun_1163;
            *((eax + 4)) = 3;
            ecx = *((esp + 0xc));
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edi;
            *((eax + 0x10)) = ebx;
            ebx = *((esp + 0x10));
            camlList_iter_1074 ();
            eax = *(esp);
            return eax;
label_1:
            eax = loc.camlString__29;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ae90 */
#include <stdint.h>
 
int32_t caml_curry7_5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_6;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c220 */
#include <stdint.h>
 
int32_t camlUnix_fun_2748 (void) {
    eax = caml_ml_open_descriptor_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050980 */
#include <stdint.h>
 
int32_t camlArray_tolist_1123 (void) {
    do {
        edx = eax;
        if (edx < 1) {
            eax = ebx;
            return eax;
        }
        esi = *((ecx + 0xc));
        eax = *((esi - 4));
        if (eax != 0xfe) {
            edi = *((esi + edx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            edi = eax + 4;
            *((edi - 4)) = 0x8fd;
            *(fp_stack--) = *((esi + edx*4 - 4));
            *(edi) = fp_stack[0];
            fp_stack--;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x800;
        *(esi) = edi;
        *((esi + 4)) = ebx;
        eax = edx;
        eax += 0xfffffffe;
        ebx = esi;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f479 */
#include <stdint.h>
 
uint32_t unix_recvfrom (void * s1, int32_t arg_bp_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_10h, int32_t arg_sp_14h) {
    int32_t var_40b0h;
    int32_t var_40ach;
    int32_t var_40a8h;
    int32_t var_40a4h;
    int32_t var_40a0h;
    int32_t var_4090h;
    int32_t var_408ch;
    int32_t var_401ch;
    int32_t var_4018h;
    void * s2;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x12cc2;
    *((ebp - 0x401c)) = 1;
    eax = ebx + 0x91e4;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    edi = eax;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x40b0)) = edx;
    edx = ebp - 0x40b0;
    *(eax) = edx;
    *((ebp - 0x40a8)) = 1;
    *((ebp - 0x40ac)) = 2;
    eax = ebp + 0xc;
    *((ebp - 0x40a4)) = eax;
    eax = ebp - 0x401c;
    *((ebp - 0x40a0)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    *((ebp - 0x4090)) = 0x70;
    caml_enter_blocking_section ();
    eax = ebp - 0x4090;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x408c;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edi;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = recvfrom (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x1561;
        uerror (eax, 0);
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    eax = *((ebp - 0x4090));
    eax = ebp - 0x408c;
    eax = alloc_sockaddr (eax, eax, 0xffffffff);
    *((ebp - 0x401c)) = eax;
    caml_alloc_small (2, 0);
    edx = esi + esi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x401c));
    *((eax + 4)) = edx;
    ecx = *((ebp - 0x40b0));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a824 */
#include <stdint.h>
 
void recvfrom (void) {
    recvfrom ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056920 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_bucket_1116 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_2;
        }
        *((esp + 8)) = ebx;
        ecx = *((eax + 8));
        *((esp + 0xc)) = ecx;
        ecx = *((eax + 4));
        *(esp) = ecx;
        eax = *(eax);
        *((esp + 4)) = eax;
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
label_1:
            eax = caml_young_ptr;
            eax -= 0x10;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 4));
            *(eax) = ebx;
            ebx = *((esp + 8));
            ebx = *((ebx + 0xc));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 8)) = ebx;
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_replace_bucket_1116 ();
    } while (1);
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xc00;
    ebx = *((esp + 4));
    *(eax) = ebx;
    ebx = *(esp);
    *((eax + 4)) = ebx;
    *((eax + 8)) = ecx;
    return eax;
    do {
label_2:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e594 */
#include <stdint.h>
 
int32_t unix_kill (pid_t pid, int32_t arg_ch) {
    int32_t sig;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13bac;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = caml_convert_signal_number (eax);
    eax = *((ebp + 8));
    eax >>= 1;
    eax = kill (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x15f0;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a7e4 */
#include <stdint.h>
 
void kill (void) {
    kill ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80630b0 */
#include <stdint.h>
 
int32_t caml_fl_reset (void) {
    *(0x807b788) = 0;
    eax = caml_allocation_policy;
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *(obj.fl_prev) = 0x807b788;
        goto label_0;
    }
    eax = 0x807b788;
    truncate_flp ();
label_0:
    *(obj.caml_fl_cur_size) = 0;
    caml_fl_init_merge ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069282 */
#include <stdint.h>
 
uint32_t caml_ml_output_int (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    caml_putword (ebx, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c370 */
#include <stdint.h>
 
int32_t camlUnix_handle_unix_error_1171 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax = void (*0x804c480)() ();
    ecx = camlUnix;
    ebx = *(eax);
    if (ebx == ecx) {
        ebx = *((eax + 0xc));
        *((esp + 8)) = ebx;
        ebx = *((eax + 8));
        *(esp) = ebx;
        eax = *((eax + 4));
        *((esp + 4)) = eax;
        ebx = *(loc.camlSys);
        eax = *((ebx - 4));
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        ebx = *(ebx);
        eax = .comment;
        camlPervasives_output_string_1191 ();
        ebx = loc.camlUnix__214;
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = .comment;
        ebx = *(esp);
        camlPervasives_output_string_1191 ();
        ebx = "\" failed";
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = *((esp + 8));
        ebx = *((eax - 4));
        ebx >>= 0xa;
        ebx = ebx*4 - 1;
        ecx = *((eax + ebx));
        ebx -= ecx;
        ebx = ebx + ebx + 1;
        if (ebx > 1) {
            ebx = " on \";
            eax = .comment;
            camlPervasives_output_string_1191 (eax);
            eax = .comment;
            ebx = *((esp + 8));
            camlPervasives_output_string_1191 ();
            ebx = loc.camlUnix__211;
            eax = .comment;
            camlPervasives_output_string_1191 ();
        }
        ebx = loc.camlUnix__210;
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = *((esp + 4));
        eax = unix_error_message;
        caml_c_call (eax);
        camlPervasives_prerr_endline_1285 ();
        eax = 5;
        void (*0x80500a0)() ();
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = *(edx);
    ebx = edx;
    void (*ecx)(uint32_t*) (*(obj.caml_exception_pointer));
    return eax;
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b9da */
#include <stdint.h>
 
uint32_t caml_sys_random_seed (void) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    *((esp + 4)) = 0;
    eax = ebp - 0x20;
    *(esp) = eax;
    gettimeofday ();
    esi = *((ebp - 0x20));
    ebx = *((ebp - 0x1c));
    eax = getppid ();
    edi = eax;
    eax = getpid ();
    ebx ^= esi;
    ebx ^= eax;
    edx = edi;
    edx <<= 0x10;
    edi = ebx;
    edi ^= edx;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b140 */
#include <stdint.h>
 
uint32_t camlPrintf_add_int_index_1040 (void) {
    eax = eax + ebx - 1;
    return camlPrintf_index_of_int_1037 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8062ebc */
#include <stdint.h>
 
int32_t caml_fatal_error_arg (int32_t arg_8h, int32_t arg_ch) {
    char ** format;
    int32_t var_8h;
    eax = *((ebp + 0xc));
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax = stderr;
    fprintf (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806666e */
#include <stdint.h>
 
int32_t caml_nativeint_shift_left (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax <<= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c690 */
#include <stdint.h>
 
uint32_t camlUnix_is_inet6_addr_1500 (void) {
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    al = (eax == 0x21) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060865 */
#include <stdint.h>
 
int32_t unix_tcflush (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x118db;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x13bc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcflush ();
    if (eax == -1) {
        eax = ebx - 0x1417;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a294 */
#include <stdint.h>
 
void tcflush (void) {
    tcflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fe70 */
#include <stdint.h>
 
uint32_t camlPervasives_prerr_float_1283 (void) {
    eax = camlPervasives_string_of_float_1140 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c9c0 */
#include <stdint.h>
 
int32_t camlUnix_getaddrinfo_emulation_1730 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 0xc)) = eax;
    *(esp) = ebx;
    ebx = ecx;
    *((esp + 0x10)) = ebx;
label_6:
    eax = caml_young_ptr;
    eax -= 0x30;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x400;
    *(edi) = 1;
    esi = edi + 8;
    *((esi - 4)) = 0x400;
    *(esi) = 1;
    edx = edi + 0x10;
    *((edx - 4)) = 0x400;
    *(edx) = 1;
    eax = edi + 0x18;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.camlUnix__fun_2828;
    *((eax + 4)) = 3;
    *((eax + 8)) = edi;
    *((eax + 0xc)) = esi;
    *((eax + 0x10)) = edx;
    camlList_iter_1074 (edi, esi);
label_5:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_8;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x10f7;
    *(ecx) = sym.caml_curry2;
    *((ecx + 4)) = 5;
    *((ecx + 8)) = 0x804b940;
    edx = *(esp);
    *((ecx + 0xc)) = edx;
    eax = *((esp + 4));
    eax = *(eax);
    if (eax != 1) {
        ebx = *(eax);
        if (ebx != 3) {
            if (ebx != 1) {
                eax = caml_string_equal (edx, loc.camlUnix__202);
                if (eax != 1) {
label_4:
                    eax = caml_young_ptr;
                    eax -= 0x18;
                    *(obj.caml_young_ptr) = eax;
                    if (eax < *(obj.caml_young_limit)) {
                        goto label_9;
                    }
                    ecx = eax + 4;
                    *((ecx - 4)) = 0x800;
                    *(ecx) = ebx;
                    *((ecx + 4)) = 1;
                    eax = ecx + 0xc;
                    *(esp) = eax;
                    *((eax - 4)) = 0x800;
                    *(eax) = ecx;
                    *((eax + 4)) = 1;
                    eax = 1;
                    *(esp) = eax;
                    ebx = loc.camlUnix__201;
                    eax = 1;
                    eax = camlUnix_get_port_1739 ();
                    *(esp) = eax;
                    ebx = loc.camlUnix__200;
                    eax = 3;
                    eax = camlUnix_get_port_1739 ();
                    *(esp) = eax;
                } else {
                } else {
                } else {
                } else {
                    ebx = loc.camlUnix__199;
                    eax = 3;
                    eax = camlUnix_get_port_1739 (ecx);
                    ebx = loc.camlUnix__198;
                    eax = 1;
                    ecx = *(esp);
                    camlUnix_get_port_1739 (eax);
                    ebx = *((esp + 4));
                    eax = camlPervasives_$40_1143 ();
                }
            }
        }
    }
    ebx = *((esp + 0x10));
    eax = caml_string_equal (eax, loc.camlUnix__197);
    if (eax != 1) {
        eax = 5;
        ebx = *((esp + 0x10));
        eax = camlList_mem_1161 ();
        if (eax != 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = .comment;
            *(ebx) = eax;
            *((ebx + 4)) = "0.0.0.0";
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            *(ecx) = ebx;
            *((ecx + 4)) = 1;
label_2:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
        } else {
        } else {
        }
    }
    if (eax < *(obj.caml_young_limit)) {
        goto label_11;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = .comment;
    *(ebx) = eax;
    *((ebx + 4)) = "127.0.0.1";
    ecx = ebx + 0xc;
    *((ecx - 4)) = 0x800;
    *(ecx) = ebx;
    *((ecx + 4)) = 1;
    eax = void (*0x804cd30)(uint32_t) (ebx);
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = void (*0x804cca0)() ();
        ecx = " %\a\b";
        ebx = *(eax);
        if (ebx == ecx) {
            ecx = 1;
        } else {
            caml_raise_exn ();
        }
        *(obj.caml_exception_pointer) = esp;
        eax = *((esp + 0x14));
        eax = unix_gethostbyname;
        eax = caml_c_call (eax);
        eax = *((eax + 0xc));
        eax = camlArray_to_list_1121 (eax);
        ebx = eax;
label_1:
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_12;
        }
        eax = eax + 4;
        *((eax - 4)) = 0xcf7;
        *(eax) = sym.camlUnix__fun_2833;
        *((eax + 4)) = 3;
        ecx = *((esp + 0xc));
        *((eax + 8)) = ecx;
        eax = camlList_map_1062 ();
        ecx = eax;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (ebx);
        ecx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        *(ebx) = ecx;
        eax = *((esp + 0x14));
        *((ebx + 4)) = eax;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        *(ecx) = ebx;
        *((ecx + 4)) = 1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.caml_tuplify2;
            *((eax + 4)) = 0xfffffffd;
            *((eax + 8)) = 0x804bb50;
            ebx = *((esp + 8));
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            ebx = *(esp);
            camlList_map_1062 ();
            void (*0x8054390)() ();
        }
        caml_call_gc ();
    } while (1);
label_13:
    caml_call_gc ();
    goto label_0;
label_12:
    caml_call_gc ();
    goto label_1;
label_11:
    caml_call_gc ();
    goto label_2;
label_10:
    caml_call_gc ();
    goto label_3;
label_9:
    caml_call_gc ();
    goto label_4;
label_8:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068833 */
#include <stdint.h>
 
int32_t caml_ml_channel_size (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_channel_size (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80670ac */
#include <stdint.h>
 
int32_t caml_classify_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = fpclassify ();
    edx = eax;
    eax = 1;
    if (edx <= 3) {
        eax = *((edx*4 + obj.CSWTCH.118));
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a1e4 */
#include <stdint.h>
 
void fpclassify (void) {
    fpclassify ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bf80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2672 (void) {
    eax = unix_select;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f5c0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1422 (void) {
    eax = caml_ml_output_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068569 */
#include <stdint.h>
 
int32_t caml_close_channel (int32_t fildes) {
    ebx = *((ebp + 8));
    eax = *(ebx);
    close (eax);
    if (*((ebx + 0x2c)) <= 0) {
        eax = caml_channel_mutex_free;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = ebx;
        unlink_channel ();
        caml_stat_free (ebx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bfb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2676 (void) {
    eax = unix_symlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806731f */
#include <stdint.h>
 
int32_t caml_asin_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    asin (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049ed4 */
#include <stdint.h>
 
void asin (void) {
    asin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bbd0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2564 (void) {
    eax = unix_tcflow;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bbf0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2568 (void) {
    eax = unix_tcdrain;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058ab0 */
#include <stdint.h>
 
int32_t camlBuffer_find_ident_1114 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (ebx >= ecx) {
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = " %\a\b";
        eax = caml_raise_exn ();
    }
    *((esp + 8)) = ebx;
    *((esp + 0xc)) = eax;
    ecx = ebx;
    ecx >>= 1;
    edx = *((eax - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    esi = *((eax + edx));
    edx -= esi;
    if (edx <= ecx) {
        goto label_3;
    }
    ecx = *((eax + ecx));
    ecx = ecx + ecx + 1;
    if (ecx != 0x51) {
        if (ecx != 0xf7) {
            ebx += 2;
            eax = camlBuffer_advance_to_non_alpha_1108 ();
            ebx = *((esp + 8));
            eax -= ebx;
            ecx = eax;
            ecx++;
            eax = *((esp + 0xc));
            eax = camlString_sub_1046 (eax);
            ecx = eax;
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *(esp);
            *((ebx + 4)) = eax;
            eax = ebx;
            return eax;
        }
        *(esp) = ecx;
    } else {
    }
    ebx += 2;
    eax = ecx;
    eax = camlBuffer_closing_1097 (ecx, ebx);
    ebx = eax;
    ecx = 1;
    eax = *(esp);
    edx = *((esp + 0xc));
    esi = *((esp + 4));
    eax = camlBuffer_advance_to_closing_1098 ();
    ebx = *((esp + 8));
    eax -= ebx;
    eax -= 3;
    ecx = eax;
    ecx += 2;
    eax = *((esp + 0xc));
    ebx = *((esp + 4));
    eax = camlString_sub_1046 (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            ebx += 2;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067bfa */
#include <stdint.h>
 
uint32_t caml_make_array (int32_t arg_8h) {
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x60)) = eax;
    eax = ebp - 0x60;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x58)) = 1;
    *((ebp - 0x5c)) = 2;
    eax = ebp - 0x3c;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi == 0) {
        *(obj.caml_local_roots) = ebx;
        goto label_0;
    }
    edx = *(eax);
    if ((dl & 1) == 0) {
        *((ebp - 0x3c)) = edx;
        edi = edx;
        edi >>= 0x17;
        ecx = edx;
        ecx >>= 0xc;
        ecx &= 0x7ff;
        edi = *((edi*4 + obj.caml_page_table));
        if ((*((edi + ecx)) & 7) == 0) {
            goto label_1;
        }
        if (*((edx - 4)) == 0xfd) {
            goto label_2;
        }
    }
label_1:
    *(obj.caml_local_roots) = ebx;
    goto label_0;
label_2:
    eax = esi + esi;
    eax = caml_alloc_small (eax, 0xfe);
    *((ebp - 0x40)) = eax;
    eax = 0;
    do {
        edx = *((ebp + 8));
        edx = *((edx + eax*4));
        *(fp_stack--) = *(edx);
        edx = *((ebp - 0x40));
        *((edx + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (esi > eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x40));
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c240 */
#include <stdint.h>
 
int32_t camlUnix_fun_2752 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80695de */
#include <stdint.h>
 
int32_t caml_ml_open_descriptor_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_open_descriptor_out (eax);
    caml_alloc_channel (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80695c4 */
#include <stdint.h>
 
int32_t caml_open_descriptor_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    caml_open_descriptor_in (eax);
    *((eax + 0x14)) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bf60 */
#include <stdint.h>
 
int32_t camlPrintf_kfprintf_1386 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlPrintf__fun_1680;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            ebp = .comment;
            esi = .comment;
            edx = .comment;
            ecx = .comment;
            eax = 1;
            *(loc.caml_extra_params) = ebp;
            void (*0x804b3e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bdb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2618 (void) {
    eax = unix_getpwnam;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805de3c */
#include <stdint.h>
 
int32_t unix_getpwuid (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14304;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getpwuid ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_passwd_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a3f4 */
#include <stdint.h>
 
void getpwuid (void) {
    getpwuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f0a4 */
#include <stdint.h>
 
int32_t unix_select (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_1c0h;
    int32_t var_1bch;
    int32_t var_1bah;
    int32_t var_1b4h;
    int32_t var_1b0h;
    int32_t var_1ach;
    int32_t var_1a8h;
    int32_t var_1a4h;
    int32_t var_1a0h;
    int32_t var_194h;
    int32_t nfds;
    int32_t var_188h;
    int32_t var_108h;
    int32_t var_88h;
    fd_set * readfds;
    fd_set * writefds;
    fd_set * exceptfds;
    struct timeval * timeout;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x13098;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x1b4)) = edx;
    edx = ebp - 0x1b4;
    *(eax) = edx;
    *((ebp - 0x1ac)) = 1;
    *((ebp - 0x1b0)) = 3;
    eax = ebp + 8;
    *((ebp - 0x1a8)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x1a4)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x1a0)) = eax;
    *((ebp - 0x18c)) = 0xffffffff;
    edx = ebp - 0x88;
    esi = ebp - 0x18c;
    eax = *((ebp + 8));
    fdlist_to_fdset (esi);
    edx = ebp - 0x108;
    eax = *((ebp + 0xc));
    fdlist_to_fdset (esi);
    edx = ebp - 0x188;
    eax = *((ebp + 0x10));
    fdlist_to_fdset (esi);
    eax = *((ebp + 0x14));
    *(fp_stack--) = *(eax);
    esi = 0;
    *(fp_stack--) = 0.0;
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        eax = *((ebp - 0x1ba));
        ah = 0xc;
        *((ebp - 0x1bc)) = ax;
        *((ebp - 0x1c0)) = fp_stack[0];
        eax = *((ebp - 0x1c0));
        *((ebp - 0x194)) = eax;
        *((ebp - 0x1c0)) = eax;
        *(fp_stack--) = *((ebp - 0x1c0));
        fp_stack[0] -= fp_stack[1];
        fp_stack++;
        fp_stack[0] *= *((ebx - 0x1644));
        *((ebp - 0x190)) = fp_stack[0];
        fp_stack--;
        esi = ebp - 0x194;
    } else {
        fp_stack++;
    }
    caml_enter_blocking_section ();
    eax = ebp - 0x188;
    eax = ebp - 0x108;
    eax = ebp - 0x88;
    eax = *((ebp - 0x18c));
    eax++;
    eax = select (esi, eax, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x1574;
        uerror (eax, 0);
    }
    edx = ebp - 0x88;
    eax = *((ebp + 8));
    eax = fdset_to_fdlist ();
    *((ebp + 8)) = eax;
    edx = ebp - 0x108;
    eax = *((ebp + 0xc));
    eax = fdset_to_fdlist ();
    *((ebp + 0xc)) = eax;
    edx = ebp - 0x188;
    eax = *((ebp + 0x10));
    eax = fdset_to_fdlist ();
    *((ebp + 0x10)) = eax;
    caml_alloc_small (3, 0);
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = *((ebp + 0xc));
    *((eax + 4)) = edx;
    edx = *((ebp + 0x10));
    *((eax + 8)) = edx;
    ecx = *((ebp - 0x1b4));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b3e0 */
#include <stdint.h>
 
int32_t caml_apply6 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    *((esp + 4)) = eax;
    *((esp + 8)) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 0x10)) = edx;
    *((esp + 0x14)) = esi;
    *((esp + 0x18)) = edi;
    ebx = caml_extra_params;
    eax = *((ebx + 4));
    if (eax == 0xd) {
        *(esp) = ebx;
        eax = *((ebx + 8));
        *((esp + 0x1c)) = eax;
        eax = *((esp + 4));
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
        edx = *((esp + 0x10));
        esi = *((esp + 0x14));
        edi = *((esp + 0x18));
        ebp = *(esp);
        *(loc.caml_extra_params) = ebp;
        ebp = *((esp + 0x1c));
        void (*ebp)() ();
    }
    eax = *(ebx);
    eax = *((esp + 4));
    ecx = *(esp);
    eax = void (*ecx)(uint32_t) (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 8));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0xc));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x10));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x14));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x18));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c270 */
#include <stdint.h>
 
int32_t camlUnix_fun_2756 (void) {
    eax = unix_nice;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80682d7 */
#include <stdint.h>
 
int32_t caml_ml_set_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067410 */
#include <stdint.h>
 
int32_t caml_sqrt_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] = sqrt(fp_stack[0]);
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_0;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(esp) = fp_stack[0];
    fp_stack--;
    sqrt ();
    goto label_1;
label_0:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_1:
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ad90 */
#include <stdint.h>
 
int32_t caml_curry7_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d4f0 */
#include <stdint.h>
 
uint32_t unix_getgid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14c50;
    getgid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a8d4 */
#include <stdint.h>
 
void getgid (void) {
    getgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806c68f */
#include <stdint.h>
 
int32_t caml_init_gc (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    char * var_4h;
    int32_t var_8h;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    norm_heapincr (ebx, esi);
    ebx = eax*4;
    eax = ebx + esi*4;
    eax = caml_page_table_initialize (eax);
    if (eax != 0) {
        caml_fatal_error (0x807199c);
    }
    eax = esi;
    eax = norm_minsize ();
    eax <<= 2;
    caml_set_minor_heap_size (eax);
    eax = *((ebp + 0x10));
    eax = norm_heapincr ();
    eax <<= 2;
    *(obj.caml_major_heap_increment) = eax;
    eax = *((ebp + 0x14));
    eax = norm_pfree ();
    *(obj.caml_percent_free) = eax;
    eax = *((ebp + 0x18));
    eax = norm_pmax ();
    *(obj.caml_percent_max) = eax;
    caml_init_major_heap (ebx);
    eax = caml_minor_heap_size;
    eax >>= 0xa;
    caml_gc_message (0x20, "Initial minor heap size: %luk bytes\n", eax);
    ebx >>= 0xa;
    caml_gc_message (0x20, "Initial major heap size: %luk bytes\n", ebx);
    eax = caml_percent_free;
    caml_gc_message (0x20, "Initial space overhead: %lu%%\n", eax);
    eax = caml_percent_max;
    caml_gc_message (0x20, "Initial max overhead: %lu%%\n", eax);
    eax = caml_major_heap_increment;
    eax >>= 0xa;
    caml_gc_message (0x20, "Initial heap increment: %luk bytes\n", eax);
    eax = caml_allocation_policy;
    caml_gc_message (0x20, "Initial allocation policy: %d\n", eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064812 */
#include <stdint.h>
 
int32_t caml_set_minor_heap_size (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    eax = caml_young_ptr;
    if (eax != *(obj.caml_young_end)) {
        caml_minor_collection ();
    }
    eax = ebp - 0x1c;
    eax = caml_aligned_malloc (edi, 0, eax);
    ebx = eax;
    if (eax == 0) {
        eax = caml_raise_out_of_memory ();
    }
    esi = eax + edi;
    eax = caml_page_table_add (2, eax, esi);
    if (eax != 0) {
        caml_raise_out_of_memory ();
    }
    eax = caml_young_start;
    if (eax != 0) {
        edx = caml_young_end;
        caml_page_table_remove (2, eax, edx);
        eax = caml_young_base;
        free (eax);
    }
    eax = *((ebp - 0x1c));
    *(obj.caml_young_base) = eax;
    *(obj.caml_young_start) = ebx;
    *(obj.caml_young_end) = esi;
    *(obj.caml_young_limit) = ebx;
    *(obj.caml_young_ptr) = esi;
    *(obj.caml_minor_heap_size) = edi;
    eax = caml_ref_table;
    reset_table ();
    eax = caml_weak_ref_table;
    reset_table ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806383c */
#include <stdint.h>
 
int32_t caml_init_major_heap (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    eax = clip_heap_chunk_size ();
    *(obj.caml_stat_heap_size) = eax;
    *(obj.caml_stat_top_heap_size) = eax;
    eax = caml_alloc_for_heap (eax);
    *(obj.caml_heap_start) = eax;
    if (eax == 0) {
        caml_fatal_error ("Fatal error: not enough memory for the initial heap.\n");
    }
    *((eax - 4)) = 0;
    *(obj.caml_stat_heap_chunks) = 1;
    eax = caml_heap_start;
    edx = caml_heap_start;
    edx += *(obj.caml_stat_heap_size);
    eax = caml_page_table_add (1, eax, edx);
    if (eax != 0) {
        caml_fatal_error ("Fatal error: not enough memory for the initial page table.\n");
    }
    caml_fl_init_merge ();
    eax = caml_stat_heap_size;
    eax >>= 2;
    eax = caml_heap_start;
    caml_make_free_blocks (eax, eax, 1);
    *(obj.caml_gc_phase) = 2;
    *(obj.gray_vals_size) = 0x800;
    eax = malloc (0x2000);
    *(obj.gray_vals) = eax;
    if (eax == 0) {
        eax = caml_fatal_error ("Fatal error: not enough memory for the gray cache.\n");
    }
    *(obj.gray_vals_cur) = eax;
    edx = gray_vals_size;
    eax = eax + edx*4;
    *(obj.gray_vals_end) = eax;
    *(obj.heap_is_pure) = 1;
    *(obj.caml_allocated_words) = 0;
    *(fp_stack--) = 0.0;
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80572c0 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_1227 (void) {
    int32_t var_4h;
    int32_t var_4h_2;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlHashtbl__mem_in_bucket_1230;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            eax = *(esp);
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            void (*0x80566a0)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f90e */
#include <stdint.h>
 
void caml_init_custom_operations (void) {
    caml_register_custom_operations (obj.caml_int32_ops);
    caml_register_custom_operations (obj.caml_nativeint_ops);
    caml_register_custom_operations (obj.caml_int64_ops);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052980 */
#include <stdint.h>
 
int32_t camlArray_of_list_1130 (void) {
    int32_t var_4h;
    ebx = eax;
    if (ebx == 1) {
        goto label_0;
    }
    eax = *((ebx + 4));
    eax = *(ebx);
    eax = 1;
    eax = camlArray_list_length_1126 (eax, eax);
    ebx = *(esp);
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8050a10;
            *((ecx + 0xc)) = ebx;
            eax = 3;
            ebx = *((esp + 4));
            void (*0x8050a10)() ();
label_0:
            eax = loc.camlArray__22;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c110 */
#include <stdint.h>
 
int32_t camlPrintf_get_cont_1408 (void) {
    int32_t var_4h;
    eax = ebx;
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    camlString_sub_1046 (eax, eax);
    ebx = *(esp);
    *((ebx + 4)) = 1;
    ebx = *((esp + 4));
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b310 */
#include <stdint.h>
 
int32_t caml_curry3_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry3_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80670fa */
#include <stdint.h>
 
uint32_t caml_format_float (void) {
    char * * format;
    int32_t base;
    int32_t var_4h_5;
    int32_t var_8h_5;
    edi = *((ebp + 8));
    ebx = *((ebp + 8));
    eax = *(edi);
    if (al == 0) {
        goto label_0;
    }
    eax -= 0x30;
    if (al > 9) {
        goto label_1;
    }
    while (al != 0) {
        eax -= 0x30;
        if (al <= 9) {
            strtol (ebx, 0, 0xa);
            esi = eax + 0x15e;
            eax = 0x15e;
            if (esi < 0x15e) {
                esi = eax;
            }
            eax = *(ebx);
            if (al == 0) {
                goto label_2;
            }
            if (al != 0x2e) {
                goto label_3;
            }
            goto label_4;
        }
label_1:
        ebx++;
        eax = *(ebx);
    }
    goto label_0;
    do {
        if (al == 0x2e) {
label_4:
            ebx++;
            eax = strtol (ebx, 0, 0xa);
            eax += 0x15e;
            if (esi < eax) {
                esi = eax;
            }
        } else {
label_3:
            ebx++;
            eax = *(ebx);
        } while (al != 0);
    }
label_2:
    if (esi <= 0x171) {
        goto label_0;
    }
    eax = caml_stat_alloc (esi);
    esi = eax;
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    sprintf (esi, edi);
    eax = caml_copy_string (esi);
    ebx = eax;
    eax = ebp - 0x18a;
    if (esi == eax) {
        goto label_5;
    }
    caml_stat_free (esi);
    do {
label_5:
        eax = ebx;
        return eax;
label_0:
        eax = *((ebp + 0xc));
        *(fp_stack--) = *(eax);
        *((esp + 8)) = fp_stack[0];
        fp_stack--;
        ebx = ebp - 0x18a;
        sprintf (ebx, edi);
        eax = caml_copy_string (ebx);
        ebx = eax;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058ea0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_1128 (void) {
    do {
        ecx = *((ebx + 0x20));
        if (eax >= ecx) {
            edx = *((ebx + 0x14));
            eax = *((ebx + 0x1c));
            ecx = *(edx);
            ebx = edx;
            eax = void (*ecx)() ();
        }
        edx = *((ebx + 0x1c));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        if (ecx == 0x4b) {
            goto label_1;
        }
        eax += 2;
    } while (1);
label_1:
    ebx += 0xc;
    eax += 2;
    void (*0x8058dc0)() ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80686f1 */
#include <stdint.h>
 
uint32_t caml_ml_seek_in (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_seek_in (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80552a0 */
#include <stdint.h>
 
int32_t camlChar_escaped_1038 (void) {
    if (eax != 0x4f) {
        if (eax != 0xb9) {
            *(esp) = eax;
            if (eax >= 0x1d) {
                goto label_0;
            }
            ebx = eax;
            ebx >>= 1;
            /* switch table (16 cases) at 0x8077e84 */
            eax = loc.camlChar__8;
            return eax;
            eax = loc.camlChar__9;
            return eax;
            eax = loc.camlChar__10;
            return eax;
            eax = loc.camlChar__11;
            return eax;
        }
        eax = loc.camlChar__7;
        return eax;
    }
    eax = loc.camlChar__6;
    return eax;
label_0:
    eax = caml_is_printable;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = caml_create_string;
        caml_c_call (3);
        edx = *(esp);
        edx >>= 1;
        *(eax) = dl;
        return eax;
    }
    eax = *(esp);
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (9);
    ebx = eax;
    edx = 0x5c;
    *(ebx) = dl;
    ecx = 0x64;
    edi = *(esp);
    eax = *(esp);
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = eax + eax + 0x61;
    edx >>= 1;
    *((ebx + 1)) = dl;
    esi = 0xa;
    ecx = 0xa;
    eax = edi;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    ecx = esi;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = edx + edx + 0x61;
    edx >>= 1;
    *((ebx + 2)) = dl;
    ecx = 0xa;
    eax = edi;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = edx + edx + 0x61;
    edx >>= 1;
    *((ebx + 3)) = dl;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80524a0 */
#include <stdint.h>
 
uint32_t camlArray_iter_1101 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    edx += 0xfffffffe;
    if (ecx > edx) {
        goto label_1;
    }
    *((esp + 0xc)) = edx;
    *((esp + 8)) = ecx;
    *(esp) = ebx;
    *((esp + 4)) = eax;
    do {
        ebx = *(esp);
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            eax = *((ebx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 4));
        ecx = *(ebx);
        void (*ecx)() ();
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054d40 */
#include <stdint.h>
 
int32_t camlList_split_1220 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        ecx = *(eax);
        ebx = *((ecx + 4));
        ebx = *(ecx);
        eax = edx;
        eax = camlList_split_1220 (ebx, ebx);
    } while (1);
    ebx = *((eax + 4));
    edx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = edx;
            eax = ecx + 0x18;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = loc.camlList__41;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80704b0 */
#include <stdint.h>
 
int32_t divdi3 (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_4h) {
    int32_t var_20h;
    uint32_t var_1ch;
    uint32_t var_18h;
    int32_t var_14h;
    uint32_t var_10h;
    int32_t var_ch;
    ecx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0x14));
    edx = *((ebp + 8));
    *((ebp - 0x10)) = esi;
    *((ebp - 0xc)) = edi;
    *((ebp - 0x14)) = 0;
    if (ecx < 0) {
        goto label_3;
    }
    esi = *((ebp - 0xc));
    if (esi < 0) {
        goto label_4;
    }
label_2:
    eax = *((ebp - 0xc));
    edi = ecx;
    esi = *((ebp - 0x10));
    *((ebp - 0x10)) = edx;
    if (eax == 0) {
        if (esi <= ecx) {
            goto label_5;
        }
        ecx = edx;
        edx = edi;
        eax = ecx;
        edi = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
    } else {
        if (eax <= ecx) {
            goto label_6;
        }
label_0:
        edi = 0;
        ecx = 0;
    }
    do {
label_1:
        eax = ecx;
        ecx = *((ebp - 0x14));
        edx = edi;
        if (ecx != 0) {
            eax = -eax;
            edx += 0;
            edx = -edx;
        }
        return eax;
label_5:
        if (esi == 0) {
            eax = 1;
            edx = 0;
            eax = edx:eax / esi;
            edx = edx:eax % esi;
            esi = eax;
        }
        ecx = *((ebp - 0x10));
        eax = edi;
        edx = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        edi = eax;
        eax = ecx;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
    } while (1);
label_6:
    __asm ("bsr edx, eax");
    edx ^= 0x1f;
    *((ebp - 0x18)) = edx;
    if (esi != 0) {
        goto label_7;
    }
    if (esi <= *((ebp - 0x10))) {
        goto label_8;
    }
    if (eax >= ecx) {
        goto label_0;
    }
label_8:
    edi = 0;
    ecx = 1;
    goto label_1;
label_3:
    esi = *((ebp - 0xc));
    edx = -edx;
    ecx += 0;
    ecx = -ecx;
    *((ebp - 0x14)) = 0xffffffff;
    if (esi >= 0) {
        goto label_2;
    }
label_4:
    ebp - 0x10 = -ebp - 0x10;
    *((ebp - 0xc)) += 0;
    ebp - 0x14 = ~ebp - 0x14;
    ebp - 0xc = -ebp - 0xc;
    goto label_2;
label_7:
    ecx = *((ebp - 0x18));
    edx = esi;
    eax <<= cl;
    *((ebp - 0x1c)) = eax;
    eax = 0x20;
    eax -= *((ebp - 0x18));
    ecx = eax;
    edx >>= cl;
    ecx = *((ebp - 0x18));
    edx |= *((ebp - 0x1c));
    esi <<= cl;
    ecx = eax;
    *((ebp - 0x20)) = esi;
    esi = edi;
    esi >>= cl;
    ecx = *((ebp - 0x18));
    *((ebp - 0x1c)) = edx;
    edx = *((ebp - 0x10));
    edi <<= cl;
    ecx = eax;
    edx >>= cl;
    edi |= edx;
    edx = esi;
    eax = edi;
    eax = *(edx:eax) / ebp - 0x1c;
    edx = *(edx:eax) % ebp - 0x1c;
    esi = edx;
    edi = eax;
    edx:eax = eax * *((ebp - 0x20));
    *((ebp - 0x1c)) = edx;
    if (esi >= edx) {
        edx = *((ebp - 0x10));
        ecx = *((ebp - 0x18));
        edx <<= cl;
        if (edx < eax) {
            if (esi == *((ebp - 0x1c))) {
                goto label_9;
            }
        }
        ecx = edi;
        edi = 0;
        goto label_1;
    }
label_9:
    ecx = edi - 1;
    edi = 0;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f3e5 */
#include <stdint.h>
 
int32_t caml_final_do_young_roots (int32_t arg_8h) {
    int32_t var_4h;
    edi = *((ebp + 8));
    esi = old;
    if (esi >= *(obj.young)) {
        goto label_0;
    }
    ebx = esi * 3;
    ebx <<= 2;
    do {
        eax = ebx;
        eax += *(obj.final_table);
        eax = *(eax);
        void (*edi)(uint32_t, uint32_t) (eax, eax);
        eax = ebx;
        eax += *(obj.final_table);
        edx = eax + 4;
        eax = *((eax + 4));
        void (*edi)(uint32_t, uint32_t) (eax, edx);
        esi++;
        ebx += 0xc;
    } while (*(obj.young) > esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80676f2 */
#include <stdint.h>
 
int32_t caml_abs_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    fp_stack[0] = abs(fp_stack[0]);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a806 */
#include <stdint.h>
 
uint32_t caml_marshal_data_size (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    edx += *((ebp + 8));
    *(obj.intern_input_malloced) = 0;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith (0x8071688);
    }
    eax += 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 4));
    ecx <<= 0x18;
    edx = *((eax - 1));
    ecx += edx;
    edx = *((eax - 3));
    edx <<= 0x10;
    ecx += edx;
    edx = *((eax - 2));
    edx <<= 8;
    eax = ecx + edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804de50 */
#include <stdint.h>
 
int32_t camlUnix_close_process_2009 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edx = ebx;
    *((esp + 8)) = edx;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            *((ebx + 4)) = edx;
            eax = "close_process";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 4)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = void (*0x804dec0)() ();
            ecx = "t$\a\b";
            ebx = *(eax);
            if (ebx != ecx) {
                caml_raise_exn ();
                *(obj.caml_exception_pointer) = esp;
                eax = *((esp + 0x10));
                camlPervasives_close_out_1209 (*(obj.caml_exception_pointer));
            }
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069a33 */
#include <stdint.h>
 
int32_t caml_serialize_int_2 (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = extern_ptr;
    eax += 2;
    if (*(obj.extern_limit) < eax) {
        eax = 2;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 8;
    *(eax) = dl;
    *((eax + 1)) = bl;
    eax += 2;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054e70 */
#include <stdint.h>
 
int32_t camlList_merge_1233 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    do {
label_0:
        if (ebx == 1) {
            goto label_2;
        }
        if (ecx == 1) {
            goto label_3;
        }
        edx = *((ecx + 4));
        edx = *(ecx);
        ecx = *((ebx + 4));
        eax = *(ebx);
        ebx = edx;
        ecx = *((esp + 0xc));
        eax = caml_apply2 (ecx, edx, edx);
        if (eax > 1) {
            goto label_4;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        ecx = *((esp + 0x14));
        eax = camlList_merge_1233 ();
    } while (1);
    ecx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 0x18));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
label_4:
    eax = *((esp + 0xc));
    ebx = *(esp);
    ecx = *((esp + 4));
    eax = camlList_merge_1233 ();
    goto label_0;
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_3:
            eax = ebx;
            return eax;
label_2:
            eax = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ac80 */
#include <stdint.h>
 
int32_t caml_curry9_8 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    *((esp + 0x24)) = eax;
    *(esp) = ebx;
    eax = *((ebx + 0xc));
    *((esp + 4)) = eax;
    eax = *((eax + 0xc));
    *((esp + 8)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0xc)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x10)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x14)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x18)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x1c)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x28)) = eax;
    eax = *(esp);
    eax = *((eax + 8));
    *((esp + 0x20)) = eax;
    eax = *((esp + 4));
    eax = *((eax + 8));
    *((esp + 4)) = eax;
    eax = *((esp + 8));
    eax = *((eax + 8));
    *(esp) = eax;
    eax = *((esp + 0xc));
    esi = *((eax + 8));
    eax = *((esp + 0x10));
    edx = *((eax + 8));
    eax = *((esp + 0x14));
    ecx = *((eax + 8));
    eax = *((esp + 0x18));
    ebx = *((eax + 8));
    eax = *((esp + 0x1c));
    eax = *((eax + 8));
    edi = *((esp + 0x28));
    edi = *((edi + 8));
    *((esp + 8)) = edi;
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 0x20));
    *(0x807b860) = ebp;
    ebp = *((esp + 0x24));
    *(0x807b864) = ebp;
    ebp = *((esp + 0x28));
    *(0x807b868) = ebp;
    ebp = *((esp + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80676be */
#include <stdint.h>
 
int32_t caml_sub_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] -= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d140 */
#include <stdint.h>
 
uint32_t camlUnix_getnameinfo_1781 (void) {
    int32_t var_4h;
    eax = void (*0x804d180)(uint32_t, uint32_t) (eax, ebx);
    ecx = loc.caml_exn_Invalid_argument;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *(esp);
        ebx = *((esp + 4));
        void (*0x804cec0)() ();
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_getnameinfo;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b2b0 */
#include <stdint.h>
 
int32_t caml_curry4_3 (void) {
    edx = eax;
    edi = *((ebx + 0xc));
    eax = *((edi + 0xc));
    esi = *((eax + 0xc));
    ecx = *((ebx + 8));
    ebx = *((edi + 8));
    eax = *((eax + 8));
    edi = *((esi + 8));
    return void (*edi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806657c */
#include <stdint.h>
 
int32_t caml_int32_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069930 */
#include <stdint.h>
 
uint32_t caml_serialize_block_2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_2ch;
    int32_t var_1ch;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    eax = edi + edi;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    ecx = extern_ptr;
    if (edi <= 0) {
        goto label_0;
    }
    eax = 0;
    *((ebp - 0x2c)) = edi;
    *((ebp - 0x1c)) = edi;
    do {
        esi = *((ebx + eax));
        edi = *((ebx + eax + 1));
        edx = edi;
        *((ecx + eax)) = dl;
        edx = esi;
        *((ecx + eax + 1)) = dl;
        eax += 2;
        *((ebp - 0x2c))--;
    } while (*((ebp - 0x2c)) != 0);
    edi = *((ebp - 0x1c));
    ecx = ecx + edi*2;
label_0:
    *(obj.extern_ptr) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80685a6 */
#include <stdint.h>
 
int32_t caml_seek_in (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax = *((ebx + 4));
    edx = *((ebx + 8));
    *((ebp - 0x30)) = eax;
    *((ebp - 0x2c)) = edx;
    edx = *((ebx + 0x14));
    *((ebp - 0x24)) = edx;
    eax = ebx + 0x34;
    edx -= eax;
    *((ebp - 0x20)) = edx;
    ecx = edx;
    ecx >>= 0x1f;
    *((ebp - 0x1c)) = ecx;
    eax = *((ebp - 0x30));
    edx = *((ebp - 0x2c));
    eax -= *((ebp - 0x20));
    edx -= *((ebp - 0x1c));
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = edx;
    if (edx <= esi) {
        if (*((ebp - 0x1c)) >= esi) {
            if (eax > edi) {
                goto label_0;
            }
        }
        if (*((ebp - 0x2c)) >= esi) {
            if (*((ebp - 0x2c)) <= esi) {
                if (*((ebp - 0x30)) < edi) {
                    goto label_0;
                }
            }
            eax = edi;
            eax -= *((ebp - 0x30));
            eax += *((ebp - 0x24));
            *((ebx + 0x10)) = eax;
        }
    } else {
label_0:
        caml_enter_blocking_section ();
        *((esp + 0xc)) = 0;
        *((esp + 4)) = edi;
        *((esp + 8)) = esi;
        eax = *(ebx);
        *(esp) = eax;
        eax = lseek64 ();
        edx ^= esi;
        eax ^= edi;
        edx |= eax;
        if (edx != 0) {
            caml_leave_blocking_section ();
            caml_sys_error (1);
        }
        caml_leave_blocking_section ();
        *((ebx + 4)) = edi;
        *((ebx + 8)) = esi;
        eax = ebx + 0x34;
        *((ebx + 0x14)) = eax;
        *((ebx + 0x10)) = eax;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060e6d */
#include <stdint.h>
 
int32_t unix_truncate (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x112ce;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    *(esp) = esi;
    eax = truncate64 ();
    if (eax == -1) {
        eax = ebx - 0x1682;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fd5f */
#include <stdint.h>
 
int32_t caml_search_dll_in_path (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * src;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = 0xffffffff;
    edi = *((ebp + 0xc));
    ecx = esi;
    eax = 0;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx += 3;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    ecx = *((ebp + 0xc));
    strcpy (eax, ecx);
    edi = ebx;
    ecx = esi;
    eax = 0;
    __asm ("repne scasb al, byte es:[edi]");
    esi = ecx;
    esi = ~esi;
    *((ebx + esi - 1)) = 0x6f732e;
    eax = *((ebp + 8));
    eax = caml_search_in_path (eax, ebx);
    esi = eax;
    caml_stat_free (ebx);
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bdd0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2622 (void) {
    eax = unix_initgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c714 */
#include <stdint.h>
 
uint32_t unix_bind (int32_t socket, int32_t arg_ch) {
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_8h;
    int32_t var_4h;
    struct sockaddr* address;
    socklen_t address_len;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15a24;
    eax = ebp - 0x7c;
    esi = ebp - 0x78;
    eax = *((ebp + 0xc));
    get_sockaddr (eax, esi, eax);
    eax = *((ebp - 0x7c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = bind (eax, esi, eax);
    if (eax == -1) {
        eax = ebx - 0x171e;
        uerror (eax, 0);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a4c4 */
#include <stdint.h>
 
void bind (void) {
    bind ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c8c0 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_1646 (void) {
    eax = unix_setsockopt;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cd1c */
#include <stdint.h>
 
uint32_t unix_clear_close_on_exec (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1541f;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 1;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        eax &= 0xfffffffe;
        *((esp + 8)) = eax;
        *((esp + 4)) = 2;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x16ca;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80683e8 */
#include <stdint.h>
 
int32_t caml_ml_close_channel (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    ebx = *(eax);
    if (ebx == -1) {
        goto label_0;
    }
    *(eax) = 0xffffffff;
    edx = *((eax + 0xc));
    *((eax + 0x14)) = edx;
    *((eax + 0x10)) = edx;
    caml_enter_blocking_section ();
    eax = close (ebx);
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx != -1) {
        goto label_1;
    }
    caml_sys_error (1);
    do {
label_1:
        eax = 1;
        return eax;
label_0:
        edx = *((eax + 0xc));
        *((eax + 0x14)) = edx;
        *((eax + 0x10)) = edx;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f9e4 */
#include <stdint.h>
 
uint32_t unix_sigpending (void) {
    int32_t var_88h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12759;
    eax = ebp - 0x88;
    *(esp) = eax;
    eax = sigpending ();
    if (eax == -1) {
        eax = ebx - 0x1519;
        uerror (eax, 0);
    }
    eax = ebp - 0x88;
    encode_sigset ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a4f4 */
#include <stdint.h>
 
void sigpending (void) {
    sigpending ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056b20 */
#include <stdint.h>
 
uint32_t camlHashtbl_safehash_1177 (void) {
    ebx = *((ebx + 8));
    ebx = *((ebx + 4));
    ecx = *(ebx);
    eax = void (*ecx)() ();
    ebx = 0x7fffffff;
    eax &= ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b000 */
#include <stdint.h>
 
int32_t caml_curry6_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066afc */
#include <stdint.h>
 
int32_t caml_int64_or (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx |= *((eax + 4));
    edx = *((edx + 8));
    edx |= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d4a8 */
#include <stdint.h>
 
uint32_t unix_getegid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14c98;
    getegid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a484 */
#include <stdint.h>
 
void getegid (void) {
    getegid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8064aa5 */
#include <stdint.h>
 
int32_t caml_free_dependent_memory (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 2;
    edx = caml_dependent_size;
    if (eax > edx) {
        *(obj.caml_dependent_size) = 0;
    } else {
        edx -= eax;
        *(obj.caml_dependent_size) = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054380 */
#include <stdint.h>
 
void camlList_rev_1056 (void) {
    ebx = 1;
    return camlList_rev_append_1051 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058970 */
#include <stdint.h>
 
void camlBuffer_output_buffer_1094 (void) {
    edx = *((ebx + 4));
    ecx = 1;
    ebx = *(ebx);
    return camlPervasives_output_1194 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059320 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1686 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x807022c */
#include <stdint.h>
 
void caml_debugger_init (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058c30 */
#include <stdint.h>
 
int32_t camlBuffer_add_substitute_1122 (void) {
    esi = eax;
    edx = ecx;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    edi = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x1cf7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80582f0;
            *((ecx + 0xc)) = esi;
            *((ecx + 0x10)) = ebx;
            *((ecx + 0x14)) = edx;
            *((ecx + 0x18)) = edi;
            ebx = 1;
            eax = 0x41;
            void (*0x80582f0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c140 */
#include <stdint.h>
 
int32_t camlUnix_fun_2722 (void) {
    eax = unix_chmod;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ad50 */
#include <stdint.h>
 
int32_t caml_curry7 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051fe0 */
#include <stdint.h>
 
void camlArray_concat_1075 (void) {
    ebx = loc.camlArray__29;
    return camlArray_find_init_1077 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bdf0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2626 (void) {
    eax = unix_getgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c500 */
#include <stdint.h>
 
int32_t camlUnix_write_1242 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_write;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.write";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c50c */
#include <stdint.h>
 
uint32_t unix_accept (int32_t arg_8h) {
    int32_t var_b0h;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x15c2f;
    *((ebp - 0x90)) = 0x70;
    caml_enter_blocking_section ();
    eax = ebp - 0x90;
    eax = ebp - 0x8c;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = accept (eax, eax, eax);
    edi = eax;
    caml_leave_blocking_section ();
    if (edi == -1) {
        eax = ebx - 0x1740;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x90));
    eax = ebp - 0x8c;
    eax = alloc_sockaddr (eax, eax, edi);
    *((ebp - 0x1c)) = eax;
    esi = *((ebx - 0x18));
    eax = *(esi);
    *((ebp - 0xb0)) = eax;
    eax = ebp - 0xb0;
    *(esi) = eax;
    *((ebp - 0xa8)) = 1;
    *((ebp - 0xac)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0xa4)) = eax;
    caml_alloc_small (2, 0);
    edx = edi + edi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x1c));
    *((eax + 4)) = edx;
    edx = *((ebp - 0xb0));
    *(esi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a284 */
#include <stdint.h>
 
void accept (void) {
    accept ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f445 */
#include <stdint.h>
 
int32_t caml_final_empty_young (void) {
    eax = young;
    *(obj.old) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059b50 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1240 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = *((ecx + 0x14));
    if (edx < eax) {
        goto label_1;
    }
    *((esp + 4)) = ecx;
    *(esp) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (*((ecx + 0x14)));
    ecx = eax;
    *((esp + 8)) = ecx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8058f60;
    ebx = *((esp + 4));
    ebx = *((ebx + 0x14));
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = ecx;
    ebx = *(esp);
    camlPrintf_list_iter_i_1201 ();
    eax = *((esp + 4));
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    ebx = *((esp + 8));
    void (*0x804b540)() ();
    do {
label_1:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlPrintf__fun_1568;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80553d0 */
#include <stdint.h>
 
int32_t camlChar_lowercase_1043 (void) {
    if (eax >= 0x83) {
        if (eax <= 0xb5) {
            goto label_0;
        }
    }
    if (eax >= 0x181) {
        if (eax <= 0x1ad) {
            goto label_0;
        }
    }
    if (eax >= 0x1b1) {
        if (eax <= 0x1bd) {
            goto label_0;
        }
    }
    return;
label_0:
    eax += 0x40;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8060ef4 */
#include <stdint.h>
 
int32_t unix_error_of_code (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_ch;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11247;
    esi = *((ebp + 8));
    eax = *((ebx - 8));
    eax = cst_to_constr (0xffffffff, eax, 0x44);
    edx = eax;
    if (eax == -1) {
        eax = caml_alloc_small (1, 0);
        edx = eax;
        eax = esi + esi + 1;
        *(edx) = eax;
    }
    eax = edx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061570 */
#include <stdint.h>
 
int32_t cst_to_constr (int32_t arg_8h, char * arg_ch, size_t arg_10h, int32_t arg_14h) {
    ecx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edx = *((ebp + 0x10));
    if (edx <= 0) {
        goto label_0;
    }
    eax = 0;
    if (*(esi) != ecx) {
        goto label_1;
    }
    while (edx > eax) {
        if (*((esi + eax*4)) == ecx) {
            eax = eax + eax + 1;
            goto label_2;
        }
label_1:
        eax++;
    }
label_0:
    eax = *((ebp + 0x14));
    eax = eax + eax + 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80627d9 */
#include <stdint.h>
 
int32_t caml_remove_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = caml_global_roots;
    caml_delete_global_root ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068671 */
#include <stdint.h>
 
uint32_t caml_ml_seek_in_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_seek_in (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058620 */
#include <stdint.h>
 
int32_t camlBuffer_clear_1062 (void) {
    *((eax + 4)) = 1;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b7a0 */
#include <stdint.h>
 
uint32_t camlPrintf_summarize_format_type_1162 (void) {
    int32_t var_4h;
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    eax = camlBuffer_create_1039 (ecx);
    edx = eax;
    *((esp + 4)) = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x2c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80599d0;
            *((ecx + 0xc)) = edx;
            ebx = ecx + 0x14;
            *((ebx - 4)) = 0x14f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x80599f0;
            *((ebx + 0xc)) = edx;
            *((ebx + 0x10)) = ecx;
            eax = *(esp);
            camlPrintf_iter_on_format_args_1137 ();
            eax = *((esp + 4));
            ecx = *((eax + 4));
            ebx = 1;
            eax = *(eax);
            void (*0x8055610)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8056580 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_bucket_1221 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_2;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, eax, ebx);
        if (eax != 1) {
label_1:
            eax = caml_young_ptr;
            eax -= 0x10;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 4));
            *(eax) = ebx;
            ebx = *((esp + 8));
            ebx = *((ebx + 0x10));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 8)) = ebx;
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_replace_bucket_1221 ();
    } while (1);
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xc00;
    ebx = *((esp + 4));
    *(eax) = ebx;
    ebx = *(esp);
    *((eax + 4)) = ebx;
    *((eax + 8)) = ecx;
    return eax;
    do {
label_2:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805fce3 */
#include <stdint.h>
 
int32_t alloc_inet_addr (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1245d;
    caml_alloc_string (4);
    edx = *((ebp + 8));
    edx = *(edx);
    *(eax) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8068062 */
#include <stdint.h>
 
int32_t caml_array_set_addr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    ebx = edx + eax*4;
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_1;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_1;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_1;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_2;
            }
            if (edx < edi) {
                goto label_1;
            }
        }
label_2:
        eax = .comment;
        if (eax >= *(0x807ebcc)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807ebc8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_1:
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bcd0 */
#include <stdint.h>
 
int32_t camlPrintf_get_index_1265 (void) {
    if (eax != 1) {
        eax = *(eax);
        return eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066bbd */
#include <stdint.h>
 
int32_t caml_int64_div (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    esi = *((eax + 4));
    ebx = *((eax + 8));
    ecx = *((edx + 4));
    edx = *((edx + 8));
    edi = *((edx + 8));
    edi |= ecx;
    if (edi == 0) {
        caml_raise_zero_divide ();
    }
    edi = ebx - 0x80000000;
    edi |= esi;
    if (edi == 0) {
        edi = ecx;
        edi &= edx;
        if (edi == -1) {
            goto label_0;
        }
    }
    eax = _divdi3 (edx, ebx, ecx);
    caml_copy_int64 (eax, edx);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a71e */
#include <stdint.h>
 
uint32_t caml_deserialize_float_4 (void) {
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 4;
    caml_deserialize_block_4 (eax, 1);
    *(fp_stack--) = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bb50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2836 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x18f7;
            *(eax) = sym.caml_tuplify2;
            *((eax + 4)) = 0xfffffffd;
            *((eax + 8)) = 0x804b860;
            edx = *((ecx + 0xc));
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = esi;
            *((eax + 0x14)) = ebx;
            ebx = *((ecx + 0x10));
            void (*0x80543d0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c914 */
#include <stdint.h>
 
int32_t unix_closedir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15827;
    esi = *((ebp + 8));
    eax = *(esi);
    if (eax == 0) {
        eax = ebx - 0x1706;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    closedir ();
    *(esi) = 0;
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a514 */
#include <stdint.h>
 
void closedir (void) {
    closedir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c160 */
#include <stdint.h>
 
int32_t camlUnix_fun_2726 (void) {
    eax = unix_rename;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059000 */
#include <stdint.h>
 
uint32_t camlPrintf_got_spec_1304 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ebx = ecx;
    ecx = *((ebx + 0xc));
    ebx = *((ebx + 0x18));
    eax = camlPrintf_get_arg_1288 (eax, ebx);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((esp + 8)) = ecx;
            *((ecx - 4)) = 0x800;
            *(ecx) = ebx;
            eax = *((esp + 4));
            ebx = *((eax + 0x1c));
            *((ecx + 4)) = ebx;
            eax = *((eax + 0x18));
            ecx = *(esp);
            if (ecx != 1) {
                ebx = eax;
            } else {
                ebx = *((ecx + 8));
                ecx = *(ebx);
                eax = void (*0x8079590)() ();
                ebx = eax;
            }
            ecx = *((esp + 4));
            esi = *((ecx + 0x10));
            eax = *((ecx + 0x14));
            ecx = *((esp + 8));
            edx = *((esp + 0xc));
            void (*0x805ae30)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806e2ad */
#include <stdint.h>
 
int32_t caml_callback2 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callback2_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x807044c */
#include <stdint.h>
 
int32_t loc_caml_callback2_exn (int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch) {
    ecx = *((esp + 0x14));
    eax = *((esp + 0x18));
    ebx = *((esp + 0x1c));
    esi = caml_apply2;
    return void (*0x8070369)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067b7e */
#include <stdint.h>
 
uint32_t caml_string_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        eax = caml_string_length (esi);
        if (ebx < eax) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((ebx + esi));
    eax = eax + eax + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b551 */
#include <stdint.h>
 
uint32_t caml_input_value (int32_t arg_8h) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edx = ebp + 8;
    *((ebp - 0x1c)) = edx;
    edx = *((ebp + 8));
    ebx = *((edx + 4));
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_input_val (ebx);
    *((ebp - 0x2c)) = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067af3 */
#include <stdint.h>
 
int32_t caml_string_lessequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax < 2) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066eb7 */
#include <stdint.h>
 
int32_t caml_int32_div (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    ecx = *((ebp + 0xc));
    ecx = *((ecx + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            goto label_0;
        }
    }
    eax = edx;
    edx >>= 0x1f;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    caml_copy_int32 (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b45e */
#include <stdint.h>
 
uint32_t caml_input_val (int32_t arg_8h) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("input_value: not a binary channel");
    }
    eax = caml_getword (ebx);
    if (eax != 0x8495a6be) {
        caml_failwith ("input_value: bad object");
    }
    eax = caml_getword (ebx);
    edi = eax;
    eax = caml_getword (ebx);
    *((ebp - 0x30)) = eax;
    eax = caml_getword (ebx);
    *((ebp - 0x2c)) = eax;
    caml_getword (ebx);
    eax = caml_stat_alloc (edi);
    esi = eax;
    eax = caml_really_getblock (ebx, eax, edi);
    if (eax == 0) {
        caml_stat_free (esi);
        caml_failwith ("input_value: truncated object");
    }
    *(obj.intern_input) = esi;
    *(obj.intern_input_malloced) = 1;
    *(obj.intern_src) = esi;
    edx = *((ebp - 0x30));
    eax = *((ebp - 0x2c));
    intern_alloc ();
    eax = ebp - 0x1c;
    intern_rec ();
    eax = *((ebp - 0x2c));
    intern_add_to_heap ();
    eax = intern_input;
    caml_stat_free (eax);
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058250 */
#include <stdint.h>
 
int32_t camlBuffer_advance_1111 (void) {
    do {
        if (eax >= ebx) {
            eax = ebx;
            return eax;
        }
        esi = *((ecx + 0xc));
        edx = eax;
        edx >>= 1;
        edi = *((esi - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((esi + ebp));
        ebp -= edi;
        if (ebp <= edx) {
            goto label_0;
        }
        edx = *((esi + edx));
        edx = edx + edx + 1;
        if (edx < 0xbf) {
            if (edx >= 0x75) {
                edx += 0xffffff7e;
                if (edx <= 0x33) {
                    goto label_1;
                }
            } else {
            } else {
            }
        }
        if (edx >= 0x61) {
            goto label_1;
        }
        if (edx >= 0xf7) {
            if (edx < 0x181) {
                goto label_2;
            }
            edx += 0xfffffe80;
            edx >>= 1;
            /* switch table (64 cases) at 0x8079100 */
        }
        if (edx != 0xc1) {
            goto label_1;
        }
label_2:
        return eax;
label_1:
        eax += 2;
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f4d0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1392 (void) {
    eax = caml_ml_set_binary_mode;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bfd4 */
#include <stdint.h>
 
int32_t caml_parse_engine (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    char * format;
    size_t nitems;
    char ** stream;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *((ebp + 0x10));
    eax >>= 1;
    if (eax > 5) {
        goto label_1;
    }
    /* switch table (6 cases) at 0x8071984 */
    edi = *((ebx + 0x34));
    edi >>= 1;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x20)) = 0;
label_0:
    eax = *((esi + 0x14));
    edx = *((ebp - 0x20));
    eax = *((eax + edx*2));
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_2;
    }
    if (*((ebx + 0x18)) < 0) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        eax = edx + edx + 1;
        *((ebx + 0x38)) = eax;
        ecx = *((ebp - 0x24));
        eax = ecx + ecx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 1;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
        eax = *((ebp + 0x14));
        eax &= 1;
        *((ebp - 0x28)) = eax;
        if (eax == 0) {
            ecx = *((ebp + 0x14));
            edx = *((ecx - 4));
            eax = *((esi + 8));
            eax = *((eax + edx*4));
            *((ebx + 0x18)) = eax;
            eax = *(ecx);
            eax = ebx + 0x1c;
            caml_modify (eax, eax);
        } else {
            edx = *((ebp + 0x14));
            edx >>= 1;
            eax = *((esi + 4));
            eax = *((eax + edx*4));
            *((ebx + 0x18)) = eax;
            eax = ebx + 0x1c;
            caml_modify (eax, 1);
        }
        if (*(obj.caml_parser_trace) == 0) {
            goto label_4;
        }
        if (*((ebp - 0x28)) != 0) {
            edx = *((ebp + 0x14));
            edx >>= 1;
            eax = *((esi + 0x38));
            eax = token_name ();
            *((esp + 0xc)) = eax;
            eax = *((ebp - 0x20));
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "State %d: read token %s\n");
        } else {
            ecx = *((ebp + 0x14));
            edx = *((ecx - 4));
            eax = *((esi + 0x3c));
            eax = token_name ();
            *((esp + 0xc)) = eax;
            eax = *((ebp - 0x20));
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "State %d: read token %s(");
            edx = *((ebp + 0x14));
            eax = *(edx);
            if ((al & 1) != 0) {
                eax >>= 1;
                *((esp + 8)) = eax;
                eax = stderr;
                eax = fprintf (eax, 0x80718db);
            } else {
                edx = *((eax - 4));
                if (dl == 0xfc) {
                    edx = stderr;
                    eax = fputs (eax, edx);
                } else {
                    if (dl == 0xfd) {
                        *(fp_stack--) = *(eax);
                        *((esp + 8)) = fp_stack[0];
                        fp_stack--;
                        eax = stderr;
                        fprintf (eax, 0x80718df);
                    } else {
                        eax = stderr;
                        fputc (0x5f, eax);
                    }
                }
            }
            eax = stderr;
            fwrite (eax, 1, 2);
        }
    }
label_4:
    ecx = *((ebp - 0x20));
    ecx += ecx;
    *((ebp - 0x28)) = ecx;
    eax = *((esi + 0x1c));
    eax = *((eax + ecx));
    ecx = *((ebx + 0x18));
    ecx >>= 1;
    edx = eax + ecx;
    *((ebp - 0x1c)) = edx;
    if (eax != 0) {
        if (edx < 0) {
            goto label_5;
        }
        eax = *((esi + 0x28));
        eax >>= 1;
        if (edx > eax) {
            goto label_5;
        }
        eax = *((esi + 0x30));
        eax = *((eax + edx*2));
        if (ecx == eax) {
            goto label_6;
        }
    }
label_5:
    eax = *((esi + 0x20));
    edx = *((ebp - 0x28));
    eax = *((eax + edx));
    edx = eax + ecx;
    if (eax != 0) {
        if (edx < 0) {
            goto label_7;
        }
        eax = *((esi + 0x28));
        eax >>= 1;
        if (edx > eax) {
            goto label_7;
        }
        edx += edx;
        eax = *((esi + 0x30));
        eax = *((eax + edx));
        if (ecx != eax) {
            goto label_7;
        }
        eax = *((esi + 0x2c));
        eax = *((eax + edx));
        *((ebp - 0x1c)) = eax;
        goto label_2;
    }
label_7:
    if (*((ebp - 0x24)) <= 0) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        ecx = *((ebp - 0x20));
        eax = ecx + ecx + 1;
        *((ebx + 0x38)) = eax;
        edx = *((ebp - 0x24));
        eax = edx + edx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 0xb;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
    }
    if (*((ebp - 0x24)) > 2) {
        goto label_8;
    }
    do {
        eax = *(ebx);
        edx = *((eax + edi*4));
        edx >>= 1;
        eax = *((esi + 0x1c));
        eax = *((eax + edx*2));
        ecx = eax + 0x100;
        if (eax != 0) {
            if (ecx < 0) {
                goto label_9;
            }
            eax = *((esi + 0x28));
            eax >>= 1;
            if (ecx > eax) {
                goto label_9;
            }
            eax = *((esi + 0x30));
            if (*((eax + ecx*2)) != 0x100) {
                goto label_9;
            }
            *((ebp - 0x1c)) = ecx;
            *((ebp - 0x24)) = 3;
            if (*(obj.caml_parser_trace) == 0) {
                goto label_10;
            }
            *((esp + 8)) = edx;
            eax = stderr;
            fprintf (eax, "Recovering in state %d\n");
            *((ebp - 0x24)) = 3;
            goto label_11;
        }
label_9:
        if (*(obj.caml_parser_trace) != 0) {
            *((esp + 8)) = edx;
            eax = stderr;
            fprintf (eax, "Discarding state %d\n");
        }
        eax = *((ebx + 0x14));
        eax >>= 1;
        if (edi <= eax) {
            if (*(obj.caml_parser_trace) == 0) {
                goto label_1;
            }
            eax = stderr;
            fwrite (eax, 1, 0x1a);
            eax = 3;
            goto label_3;
        }
        edi--;
    } while (1);
label_8:
    eax = *((ebx + 0x18));
    eax >>= 1;
    if (eax == 0) {
        goto label_1;
    }
    if (*(obj.caml_parser_trace) != 0) {
        eax = stderr;
        fwrite (eax, 1, 0x1b);
    }
    *((ebx + 0x18)) = 0xffffffff;
    goto label_0;
label_6:
    *((ebx + 0x18)) = 0xffffffff;
    al = (*((ebp - 0x24)) > 0) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x24)) -= eax;
label_11:
    if (*(obj.caml_parser_trace) != 0) {
        eax = *((esi + 0x2c));
        ecx = *((ebp - 0x1c));
        eax = *((eax + ecx*2));
        *((esp + 0xc)) = eax;
        eax = *((ebp - 0x20));
        *((esp + 8)) = eax;
        eax = stderr;
        fprintf (eax, "State %d: shift to state %d\n");
    }
label_10:
    eax = *((esi + 0x2c));
    edx = *((ebp - 0x1c));
    eax = *((eax + edx*2));
    *((ebp - 0x20)) = eax;
    edi++;
    eax = *((ebx + 0x10));
    eax >>= 1;
    if (edi >= eax) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        ecx = *((ebp - 0x20));
        eax = ecx + ecx + 1;
        *((ebx + 0x38)) = eax;
        edx = *((ebp - 0x24));
        eax = edx + edx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 5;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
    }
    ecx = edi*4;
    *((ebp - 0x1c)) = ecx;
    edx = *(ebx);
    ecx = *((ebp - 0x20));
    eax = ecx + ecx + 1;
    ecx = *((ebp - 0x1c));
    *((ecx + edx)) = eax;
    eax = *((ebx + 0x1c));
    eax = ecx;
    eax += *((ebx + 4));
    caml_modify (eax, eax);
    eax = *((ebx + 0x20));
    eax = *((ebp - 0x1c));
    eax += *((ebx + 8));
    caml_modify (eax, eax);
    eax = *((ebx + 0x24));
    eax = *((ebp - 0x1c));
    eax += *((ebx + 0xc));
    caml_modify (eax, eax);
    goto label_0;
label_2:
    if (*(obj.caml_parser_trace) != 0) {
        eax = *((ebp - 0x1c));
        *((esp + 0xc)) = eax;
        edx = *((ebp - 0x20));
        *((esp + 8)) = edx;
        eax = stderr;
        fprintf (eax, "State %d: reduce by rule %d\n");
    }
    eax = *((ebp - 0x1c));
    eax += eax;
    edx = *((esi + 0x10));
    edx = *((edx + eax));
    ecx = edi + edi + 1;
    *((ebx + 0x28)) = ecx;
    ecx = eax + 1;
    *((ebx + 0x30)) = ecx;
    ecx = edx + edx + 1;
    *((ebx + 0x2c)) = ecx;
    edi++;
    edi -= edx;
    edx = *(ebx);
    edx = *((edx + edi*4 - 4));
    edx >>= 1;
    *((ebp - 0x20)) = edx;
    edx = *((esi + 0xc));
    edx = *((edx + eax));
    edx += edx;
    eax = *((esi + 0x24));
    eax = *((eax + edx));
    ecx = *((ebp - 0x20));
    ecx += eax;
    if (eax != 0) {
        if (ecx >= 0) {
            eax = *((esi + 0x28));
            eax >>= 1;
            if (ecx > eax) {
                goto label_12;
            }
            ecx += ecx;
            eax = *((esi + 0x30));
            eax = *((eax + ecx));
            if (eax != *((ebp - 0x20))) {
                goto label_12;
            }
            eax = *((esi + 0x2c));
            eax = *((eax + ecx));
        }
    } else {
label_12:
        eax = *((esi + 0x18));
        eax = *((eax + edx));
    }
    edx = *((ebx + 0x10));
    edx >>= 1;
    if (edi >= edx) {
        edx = edi + edi + 1;
        *((ebx + 0x34)) = edx;
        eax = eax + eax + 1;
        *((ebx + 0x38)) = eax;
        ecx = *((ebp - 0x24));
        eax = ecx + ecx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 7;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        edx = *((ebx + 0x3c));
        edx >>= 1;
        *((ebp - 0x24)) = edx;
    }
    edx = edi + edi + 1;
    *((ebx + 0x34)) = edx;
    eax = eax + eax + 1;
    *((ebx + 0x38)) = eax;
    edx = *((ebp - 0x24));
    eax = edx + edx + 1;
    *((ebx + 0x3c)) = eax;
    eax = 9;
    goto label_3;
    edi = *((ebx + 0x34));
    edi >>= 1;
    eax = *((ebx + 0x38));
    eax >>= 1;
    *((ebp - 0x20)) = eax;
    eax = *((ebx + 0x3c));
    eax >>= 1;
    *((ebp - 0x24)) = eax;
    ecx = edi*4;
    *((ebp - 0x28)) = ecx;
    edx = *(ebx);
    ecx = *((ebp - 0x20));
    eax = ecx + ecx + 1;
    ecx = *((ebp - 0x28));
    *((ecx + edx)) = eax;
    eax = *((ebp + 0x14));
    eax = ecx;
    eax += *((ebx + 4));
    caml_modify (eax, eax);
    eax = *((ebx + 0x28));
    eax >>= 1;
    *((ebp - 0x1c)) = eax;
    eax <<= 2;
    *((ebp - 0x2c)) = eax;
    eax = *((ebx + 0xc));
    ecx = *((ebp - 0x2c));
    edx = *((ecx + eax));
    eax += *((ebp - 0x28));
    caml_modify (eax, edx);
    if (edi <= *((ebp - 0x1c))) {
        goto label_0;
    }
    eax = *((ebx + 0xc));
    edx = *((ebp - 0x2c));
    eax = *((edx + eax));
    eax = *((ebp - 0x28));
    eax += *((ebx + 8));
    caml_modify (eax, eax);
    goto label_0;
label_1:
    eax = 3;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a614 */
#include <stdint.h>
 
void fputc (void) {
    fputc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a534 */
#include <stdint.h>
 
void fwrite (void) {
    fwrite ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a7e5 */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_8 (void) {
    int32_t var_8h;
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 8;
    caml_deserialize_block_8 (eax, 1);
    eax = *((ebp - 8));
    edx = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80669ff */
#include <stdint.h>
 
int32_t caml_int64_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_int64 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066651 */
#include <stdint.h>
 
int32_t caml_nativeint_shift_right (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067aa6 */
#include <stdint.h>
 
int32_t caml_string_greaterequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax > 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e00b */
#include <stdint.h>
 
int32_t unix_getservbyname (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14135;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getservbyname ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_service_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a884 */
#include <stdint.h>
 
void getservbyname (void) {
    getservbyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ffb0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1485 (void) {
    eax = caml_ml_seek_out_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f4f0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1396 (void) {
    eax = caml_ml_channel_size;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80683b3 */
#include <stdint.h>
 
int32_t caml_channel_descriptor (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    ebx = *(eax);
    if (ebx == -1) {
        errno_location ();
        *(eax) = 9;
        caml_sys_error (1);
    }
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc70 */
#include <stdint.h>
 
int32_t camlUnix_fun_2582 (void) {
    eax = unix_getprotobyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061c03 */
#include <stdint.h>
 
int32_t caml_raise_constant (void) {
    int32_t var_4ch_2;
    int32_t var_48h_3;
    int32_t var_44h_3;
    int32_t var_40h_3;
    int32_t var_2ch_2;
    int32_t var_28h_3;
    int32_t var_24h_3;
    int32_t var_20h_3;
    int32_t var_1ch_3;
    int32_t var_4h_7;
    int32_t var_4h_6;
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp + 8));
    *(eax) = edx;
    eax = *((ebp - 0x2c));
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b100 */
#include <stdint.h>
 
void camlPrintf_fun_1710 (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bc90 */
#include <stdint.h>
 
int32_t camlUnix_fun_2586 (void) {
    eax = unix_gethostbyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a380 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1575 (void) {
    int32_t var_4h_3;
    int32_t var_8h_3;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = ecx;
    eax = caml_make_vect;
    eax = caml_c_call (5);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 8));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a940 */
#include <stdint.h>
 
int32_t caml_deserialize_block_1 (void * s1, int32_t arg_ch) {
    void * s2;
    size_t * n;
    ebx = *((ebp + 0xc));
    eax = intern_src;
    eax = *((ebp + 8));
    memmove (eax, eax, ebx);
    *(obj.intern_src) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ff90 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1489 (void) {
    eax = caml_ml_channel_size_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bed0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2652 (void) {
    eax = unix_mktime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066e54 */
#include <stdint.h>
 
int32_t caml_int32_and (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax &= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80666a7 */
#include <stdint.h>
 
int32_t caml_nativeint_or (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax |= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80619fd */
#include <stdint.h>
 
void caml_array_bound_error (void) {
    int32_t var_4h_9;
    int32_t var_sp_8h;
    if (*(obj.array_bound_error_bucket_inited) == 0) {
        *(obj.array_bound_error_msg) = 0x14fc;
        *(0x807b767) = 0;
        *(obj.array_bound_error_bucket) = 0x800;
        *(0x807ba2c) = 0x80724a8;
        *(0x807ba30) = 0x807b754;
        *(obj.array_bound_error_bucket_inited) = 1;
        caml_page_table_add (4, 0x807b750, 0x807b76c);
        *(obj.array_bound_error_bucket_inited) = 1;
    }
    return caml_raise (0x807ba2c);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806a5f9 */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_4 (void) {
    ecx = intern_src;
    edx = ecx + 4;
    *(obj.intern_src) = edx;
    ebx = *((edx - 1));
    eax = *(ecx);
    eax <<= 0x18;
    eax = ebx + eax;
    ecx = *((edx - 3));
    ecx <<= 0x10;
    eax += ecx;
    edx = *((edx - 2));
    edx <<= 8;
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fd70 */
#include <stdint.h>
 
uint32_t camlPervasives_print_int_1270 (void) {
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80604fe */
#include <stdint.h>
 
uint32_t unix_stat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11c3d;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        eax = ebx - 0x1445;
        uerror (eax, esi);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b0c0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1697 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f724 */
#include <stdint.h>
 
uint32_t unix_setgroups (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x12a1a;
    esi = *((ebp + 8));
    edi = *((esi - 4));
    edi >>= 0xa;
    eax = edi*4;
    eax = caml_stat_alloc (eax);
    *((ebp - 0x1c)) = eax;
    if (edi == 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((esi + edx*4));
        ecx >>= 1;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edi > edx);
label_0:
    eax = *((ebp - 0x1c));
    *((esp + 4)) = eax;
    *(esp) = edi;
    eax = setgroups ();
    esi = eax;
    eax = *((ebp - 0x1c));
    caml_stat_free (eax);
    if (esi == -1) {
        eax = ebx - 0x154c;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067709 */
#include <stdint.h>
 
int32_t caml_neg_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    fp_stack[0] = -fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069151 */
#include <stdint.h>
 
uint32_t caml_ml_flush_partial (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    if (*(ebx) == -1) {
        *(obj.caml_local_roots) = esi;
        eax = 3;
    } else {
        eax = caml_channel_mutex_lock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = caml_flush_partial (ebx);
        edi = eax;
        eax = caml_channel_mutex_unlock;
        if (eax != 0) {
            eax = void (*eax)(uint32_t) (ebx);
        }
        eax -= eax;
        eax &= 0xfffffffe;
        *(obj.caml_local_roots) = esi;
        eax = eax + 3;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b210 */
#include <stdint.h>
 
void camlPrintf_bad_conversion_format_1061 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    camlString_sub_1046 (ebx, ecx);
    ebx = *(esp);
    ecx = *((esp + 4));
    return camlPrintf_bad_conversion_1057 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b8f0 */
#include <stdint.h>
 
uint32_t camlPrintf_count_arguments_of_format_1198 (void) {
    eax = camlPrintf_ac_of_format_1184 ();
    eax = *(eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805cc22 */
#include <stdint.h>
 
int32_t unix_execvp (void) {
    int32_t var_ch_5;
    int32_t var_8h_5;
    int32_t var_4h_4;
    int32_t var_8h_6;
    int32_t var_ch_6;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15516;
    edi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    *((esp + 4)) = eax;
    *(esp) = edi;
    execvp ();
    caml_stat_free (esi);
    eax = ebx - 0x16df;
    return uerror (eax, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c190 */
#include <stdint.h>
 
int32_t camlUnix_fun_2732 (void) {
    eax = unix_fstat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066db0 */
#include <stdint.h>
 
int32_t caml_int32_of_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bd56 */
#include <stdint.h>
 
uint32_t caml_sys_getcwd (void) {
    int32_t var_1008h;
    int32_t var_4h;
    *((esp + 4)) = 0x1000;
    eax = ebp - 0x1008;
    *(esp) = eax;
    eax = getcwd ();
    if (eax == 0) {
        caml_sys_error (1);
    }
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bef0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2656 (void) {
    eax = unix_gmtime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80663b1 */
#include <stdint.h>
 
uint32_t caml_int64_format (void) {
    char * format;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x8070b5e;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 8)) = eax;
    sprintf (edx, esi);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054940 */
#include <stdint.h>
 
int32_t camlList_memq_1165 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ecx = *(ebx);
        if (ecx == eax) {
            eax = 3;
            return eax;
        }
        ebx = edx;
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058f00 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1159 (void) {
    do {
        ecx = *((ebx + 0x10));
        ecx += 0xfffffffc;
        if (eax >= ecx) {
            goto label_0;
        }
        *(esp) = ebx;
        ecx = *((ebx + 0xc));
        edx = *((ebx + 8));
        ebx = eax;
        ebx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ebx) {
            goto label_1;
        }
        ebx = *((edx + ebx));
        ebx = ebx + ebx + 1;
        caml_apply2 ();
        ebx = *(esp);
    } while (1);
label_0:
    eax = 1;
    return eax;
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c5c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2800 (void) {
    eax = unix_stat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066aa6 */
#include <stdint.h>
 
int32_t caml_int64_shift_left (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shld edx, eax, cl");
    eax <<= cl;
    if ((cl & 0x20) != 0) {
        edx = eax;
        eax = 0;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805bfd0 */
#include <stdint.h>
 
int32_t camlPrintf_ifprintf_1389 (void) {
    ebx = .comment;
    eax = loc.camlPrintf__44;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804e0b0 */
#include <stdint.h>
 
int32_t camlUnix_shutdown_connection_2022 (void) {
    eax = caml_channel_descriptor;
    eax = caml_c_call (eax);
    eax = unix_shutdown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80673ea */
#include <stdint.h>
 
int32_t caml_power_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    pow (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a024 */
#include <stdint.h>
 
void pow (void) {
    pow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c5e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2796 (void) {
    eax = unix_truncate_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8050500 */
#include <stdint.h>
 
int32_t loc_camlArray_code_begin (void) {
    int32_t var_4h_4;
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        eax = ebx;
        ecx = *((edi + 0xc));
        ebx = edx;
        eax = caml_apply2 (eax, eax, ecx);
        if (eax > 1) {
            goto label_2;
        }
        edi = *(esp);
        eax = *((edi + 0x18));
        ebx = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            ebx >>= 9;
            esi = *((esp + 0x10));
            if (ebx <= esi) {
                goto label_3;
            }
            ebx = *((esp + 0x14));
            caml_modify (eax + esi*2 - 2, ebx);
        } else {
            ebx >>= 0xa;
            esi = *((esp + 0x10));
            if (ebx <= esi) {
                goto label_4;
            }
            ebx = *((esp + 0x14));
            *(fp_stack--) = *(ebx);
            *((eax + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esp + 4));
        ecx += 2;
        eax = *((edi + 0x1c));
        if (ecx >= eax) {
            goto label_5;
        }
        ebx = *((edi + 0x10));
        edx = *((ebx - 4));
        eax = *((ebx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edx;
            eax >>= 9;
            if (eax <= ecx) {
                goto label_6;
            }
            ebx = *((ebx + ecx*2 - 2));
        } else {
            eax = edx;
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_7;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_8;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
            ebx = edx;
        }
        esi += 2;
        eax = ecx;
        ecx = *((esp + 8));
        edx = *((esp + 0xc));
    } while (1);
label_5:
    ebp = *((edi + 0x20));
    ebx = *((esp + 8));
    ebp -= ebx;
    ebp++;
    esi += 2;
    ecx = *((edi + 0x18));
    eax = *((edi + 0x14));
    edx = esi;
    esi = ebp;
    void (*0x8052240)() ();
label_2:
    edi = *(esp);
    eax = *((edi + 0x18));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        esi = *((esp + 0x10));
        if (ebx <= esi) {
            goto label_9;
        }
        ebx = *((esp + 0xc));
        caml_modify (eax + esi*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        esi = *((esp + 0x10));
        if (ebx <= esi) {
            goto label_10;
        }
        ebx = *((esp + 0xc));
        *(fp_stack--) = *(ebx);
        *((eax + esi*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    ecx = *((esp + 8));
    ecx += 2;
    eax = *((edi + 0x20));
    if (ecx >= eax) {
        goto label_11;
    }
    ebx = *((edi + 0x14));
    edx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = edx;
        eax >>= 9;
        if (eax <= ecx) {
            goto label_12;
        }
        edx = *((ebx + ecx*2 - 2));
        goto label_13;
    }
    eax = edx;
    eax >>= 0xa;
    if (eax <= ecx) {
        goto label_14;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
label_13:
            esi += 2;
            eax = *((esp + 4));
            ebx = *((esp + 0x14));
            goto label_0;
label_11:
            ebp = *((edi + 0x1c));
            ebx = *((esp + 4));
            ebp -= ebx;
            ebp++;
            esi += 2;
            ecx = *((edi + 0x18));
            eax = *((edi + 0x10));
            edx = esi;
            esi = ebp;
            void (*0x8052240)() ();
        }
        caml_call_gc ();
    } while (1);
label_8:
    caml_call_gc ();
    goto label_1;
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054980 */
#include <stdint.h>
 
int32_t camlList_assoc_1169 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ecx = *(ebx);
        ebx = *((ecx + 4));
        *((esp + 8)) = ebx;
        ebx = *(ecx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806766d */
#include <stdint.h>
 
int32_t caml_exp_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    exp (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a144 */
#include <stdint.h>
 
void exp (void) {
    exp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066f60 */
#include <stdint.h>
 
int32_t caml_int_of_float (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_2h;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 2));
    ah = 0xc;
    *((ebp - 4)) = ax;
    *((ebp - 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 8));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ab80 */
#include <stdint.h>
 
int32_t caml_curry9_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a690 */
#include <stdint.h>
 
uint32_t camlPrintf_scan_conv_1293 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
label_0:
    edi = ecx;
    ebp >>= 1;
    ecx = *((esi + 0xc));
    ecx = *((ecx + ebp));
    ecx = ecx + ecx + 1;
    if (ecx >= 0xf9) {
        void (*0x805a8e0)() ();
    }
    edi = ecx;
    edi >>= 1;
    /* switch table (195 cases) at 0x8079cb8 */
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx, edi);
    *((esp + 4)) = eax;
    esi = *((esp + 8));
    if (esi == 1) {
        eax = camlPervasives_string_of_float_1140 ();
        *(esp) = eax;
    } else {
        eax = *((esp + 0x18));
        ecx = *((eax + 0x10));
        ebx = *((eax + 0xc));
        eax = *(esp);
        edx = *((esp + 0xc));
        camlPrintf_extract_format_float_1110 ();
        ebx = *((esp + 4));
        eax = camlPrintf_fun_1600 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    *(esp) = eax;
    eax = .comment;
    ebx = *((eax + 8));
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *(eax);
    } else {
        eax = *((esp + 0x14));
    }
    ecx = *(ebx);
    eax = void (*ecx)() ();
    ebx = eax;
    eax = *((esp + 0x18));
    ecx = *((eax + 0x28));
    eax = 1;
    eax = camlPrintf_get_arg_1288 (ebx);
    *((esp + 4)) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 8));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 8));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    esi = *((ebx + 0x18));
    edx = *((esp + 0xc));
    edx += 2;
    ebx = *(esp);
    ecx = *((esp + 4));
    void (*0x804b490)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x1c));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    camlPrintf_get_arg_1288 ();
    ebx = *(esp);
    if (ebx == 0xe7) {
    } else {
        camlString_escaped_1080 ();
        ebx = loc.camlPrintf__58;
        eax = camlPervasives_$5e_1112 ();
        ebx = eax;
        eax = loc.camlPrintf__57;
        eax = camlPervasives_$5e_1112 ();
    }
    edx = *((esp + 0x18));
    ebx = *((edx + 0x10));
    ebx += 2;
    ecx = *((esp + 0xc));
    if (ecx == ebx) {
        *(esp) = eax;
    } else {
        ebx = *((edx + 0x10));
        eax = *((edx + 0xc));
        edx = *((esp + 8));
        camlPrintf_extract_format_1085 (eax);
        ebx = *(esp);
        eax = camlPrintf_format_string_1080 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    eax = *((esp + 0x18));
    ecx = *((eax + 0x10));
    ebx = *((eax + 0xc));
    eax = *(esp);
    edx = *((esp + 0xc));
    esi = *((esp + 8));
    eax = camlPrintf_extract_format_int_1103 (eax);
    ebx = *((esp + 4));
    eax = caml_format_int;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    eax = *((esp + 0x18));
    ebx = *((eax + 0x10));
    eax = *((eax + 0xc));
    ecx = *((esp + 0xc));
    edx = *((esp + 8));
    eax = camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    eax = caml_format_float;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ebp += 2;
    ebp >>= 1;
    edi = *((esi + 0xc));
    edi = *((edi + ebp));
    edi = edi + edi + 1;
    edi += 0xffffff50;
    if (edi <= 0x41) {
        edi >>= 1;
        /* switch table (66 cases) at 0x8079ea8 */
    }
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    eax = *((esp + 0x18));
    ecx = *((eax + 0x10));
    ebx = *((eax + 0xc));
    eax = 0xdd;
    edx = *((esp + 0xc));
    esi = *((esp + 8));
    eax = camlPrintf_extract_format_int_1103 (eax);
    ebx = *(esp);
    eax = caml_format_int;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    edx += 2;
    *((esp + 4)) = edx;
    ecx += 0xffffff28;
    if (ecx <= 5) {
        ecx >>= 1;
        if (ecx != 1) {
            if (ecx <= 1) {
                ecx = *((esi + 0x28));
                eax = camlPrintf_get_arg_1288 ();
                eax = *((esp + 0x18));
                ebx = *((eax + 0x10));
                eax = *((eax + 0xc));
                ecx = *((esp + 4));
                edx = *((esp + 8));
                eax = camlPrintf_extract_format_1085 (eax);
                ebx = *(esp);
                eax = caml_int32_format;
                eax = caml_c_call (eax);
                *(esp) = eax;
                goto label_6;
            }
            ecx = *((esi + 0x28));
            eax = camlPrintf_get_arg_1288 ();
            eax = *((esp + 0x18));
            ebx = *((eax + 0x10));
            eax = *((eax + 0xc));
            ecx = *((esp + 4));
            edx = *((esp + 8));
            eax = camlPrintf_extract_format_1085 (eax);
            ebx = *(esp);
            eax = caml_nativeint_format;
            eax = caml_c_call (eax);
            *(esp) = eax;
        }
    } else {
        ecx = *((esi + 0x28));
        eax = camlPrintf_get_arg_1288 ();
        eax = *((esp + 0x18));
        ebx = *((eax + 0x10));
        eax = *((eax + 0xc));
        ecx = *((esp + 4));
        edx = *((esp + 8));
        eax = camlPrintf_extract_format_1085 (eax);
        ebx = *(esp);
        eax = caml_int64_format;
        eax = caml_c_call (eax);
        *(esp) = eax;
    }
label_6:
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 4));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x20f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8059000;
            eax = *((esi + 0x38));
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = esi;
            *((ebx + 0x14)) = edi;
            *((ebx + 0x18)) = ebp;
            *((ebx + 0x1c)) = ecx;
            edx += 2;
            eax = *((esi + 0x1c));
            ecx = ebp;
            void (*0x805bc20)() ();
            esi += 0x10;
            eax = edi;
            ebx = ebp;
            goto label_0;
            edx += 2;
            eax = edi;
            ebx = ebp;
            void (*0x805ae30)() ();
        }
        caml_call_gc ();
    } while (1);
    ebx = loc.camlPrintf__45;
    eax = *((esp + 4));
    ecx = *(esp);
    void (*0x804b540)() ();
label_5:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.camlPrintf__fun_1572;
    *((eax + 4)) = 3;
    ebx = *(esp);
    *((eax + 8)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0xc)) = ebx;
    return eax;
label_4:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_8;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805a380;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_3:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_9;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry3;
    *((eax + 4)) = 7;
    *((eax + 8)) = 0x805a240;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_2:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_10;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry4;
    *((eax + 4)) = 9;
    *((eax + 8)) = 0x805a0a0;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_11;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry5;
    *((eax + 4)) = 0xb;
    *((eax + 8)) = 0x8059ea0;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.caml_curry6;
            *((eax + 4)) = 0xd;
            *((eax + 8)) = 0x8059c40;
            ebx = *(esp);
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_11:
    caml_call_gc ();
    goto label_1;
label_10:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_8:
    caml_call_gc ();
    goto label_4;
label_7:
    caml_call_gc ();
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067561 */
#include <stdint.h>
 
uint32_t caml_frexp_float (int32_t arg_8h) {
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_8h;
    ebx = caml_local_roots;
    *((ebp - 0x28)) = ebx;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x30)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x50)) = eax;
    eax = ebp - 0x50;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x48)) = 1;
    *((ebp - 0x4c)) = 2;
    eax = ebp - 0x2c;
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x30;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x54;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    frexp (ebx, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x30)) = eax;
    eax = caml_alloc_tuple (2);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp - 0x30));
    *(eax) = edx;
    eax = *((ebp - 0x54));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a554 */
#include <stdint.h>
 
void frexp (void) {
    frexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80560c0 */
#include <stdint.h>
 
void camlString_compare_1145 (void) {
    caml_string_compare (eax, ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c1b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2736 (void) {
    eax = unix_stat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067285 */
#include <stdint.h>
 
int32_t caml_expm1_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_expm1 ();
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065fbf */
#include <stdint.h>
 
int32_t caml_nativeint_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80570c0 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_1217 (void) {
    int32_t var_4h_3;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_18h_2;
    int32_t var_18h;
    int32_t var_24h;
    esi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.camlHashtbl__replace_bucket_1221;
    *((eax + 4)) = 3;
    edi = *((edx + 0xc));
    *((eax + 8)) = edi;
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = ecx;
    edi = *((esi + 4));
    edi = *((edi - 4));
    edi >>= 0xa;
    if (edi != 0) {
        eax = *((edx + 0x10));
        eax = *((eax + 8));
        ebx = *((eax + 4));
        ecx = *(ebx);
        eax = *((esp + 0x1c));
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, ecx, edi);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 8));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    *((esp + 0x18)) = edx;
    ebx = *(esp);
    ecx = *((ebx + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    eax = *((ecx + edx*2 - 2));
    eax = void (*0x8057240)(uint32_t) (eax);
    ecx = " %\a\b";
    ebx = *(eax);
    if (ebx != ecx) {
        goto label_3;
    }
    ebx = *(esp);
    edx = *((ebx + 4));
    eax = *((edx - 4));
    eax >>= 9;
    ecx = *((esp + 0x18));
    if (eax <= ecx) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0xc00;
            eax = *((esp + 0x1c));
            *(esi) = eax;
            eax = *((esp + 4));
            *((esi + 4)) = eax;
            eax = *((esp + 8));
            *((esi + 8)) = eax;
            caml_modify (edx + ecx*2 - 2, esi);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = *((esp + 0xc));
                eax = *((eax + 0x10));
                void (*0x80574c0)() ();
            }
            eax = 1;
            return eax;
label_3:
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = *((ebx + 4));
            *((esp + 0x1c)) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_5;
            }
            ebx = *((esp + 0x18));
            eax = camlHashtbl_replace_bucket_1221 ();
            ebx = *((esp + 0x20));
            eax = *((esp + 0x24));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fd00 */
#include <stdint.h>
 
int32_t camlPervasives_close_in_noerr_1263 (void) {
    fcn_0804fd10 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fd10 */
#include <stdint.h>
 
int32_t fcn_0804fd10 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054ae0 */
#include <stdint.h>
 
int32_t camlList_mem_assq_1184 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ecx = *(ebx);
        ecx = *(ecx);
        if (ecx == eax) {
            eax = 3;
            return eax;
        }
        ebx = edx;
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805caac */
#include <stdint.h>
 
int32_t unix_error_message (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15694;
    eax = *((ebp + 8));
    if ((al & 1) == 0) {
        eax = *(eax);
        eax >>= 1;
    } else {
        eax >>= 1;
        edx = *((ebx - 8));
        eax = *((edx + eax*4));
    }
    eax = strerror (eax);
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80665e1 */
#include <stdint.h>
 
int32_t caml_nativeint_of_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80528f0 */
#include <stdint.h>
 
int32_t camlArray_to_list_1121 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8050980;
            *((ecx + 0xc)) = ebx;
            eax = *((ebx - 4));
            ebx = *((ebx - 4));
            ebx &= 0xff;
            if (ebx != 0xfe) {
                eax >>= 9;
            } else {
                eax >>= 0xa;
            }
            eax |= 1;
            eax += 0xfffffffe;
            ebx = 1;
            void (*0x8050980)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052c00 */
#include <stdint.h>
 
int32_t camlArray_sort_1152 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch_2;
    int32_t var_10h;
    int32_t var_14h;
    ecx = eax;
    *((esp + 0x10)) = ebx;
label_4:
    eax = caml_young_ptr;
    eax -= 0x90;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x14f7;
    *(esi) = sym.caml_curry2;
    *((esi + 4)) = 5;
    *((esi + 8)) = 0x8050a70;
    *((esi + 0xc)) = ecx;
    *((esi + 0x10)) = ebx;
    edx = esi + 0x18;
    *((edx - 4)) = 0x18f7;
    *(edx) = sym.caml_curry3;
    *((edx + 4)) = 7;
    *((edx + 8)) = 0x8050e60;
    *((edx + 0xc)) = ecx;
    *((edx + 0x10)) = ebx;
    *((edx + 0x14)) = esi;
    eax = esi + 0x34;
    *((esp + 4)) = eax;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry3;
    *((eax + 4)) = 7;
    *((eax + 8)) = 0x8051070;
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = edx;
    edx = esi + 0x4c;
    *((edx - 4)) = 0x14f7;
    *(edx) = sym.caml_curry2;
    *((edx + 4)) = 5;
    *((edx + 8)) = 0x8051130;
    *((edx + 0xc)) = ebx;
    *((edx + 0x10)) = esi;
    eax = esi + 0x64;
    *(esp) = eax;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8051230;
    *((eax + 0xc)) = edx;
    eax = esi + 0x78;
    *((esp + 8)) = eax;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8051280;
    *((eax + 0xc)) = ecx;
    *((eax + 0x10)) = ebx;
    eax = *((ebx - 4));
    ebx = *((ebx - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    *((esp + 0x14)) = eax;
    ecx = 3;
    eax += 2;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    ebx = eax + eax - 1;
    if (ebx < 1) {
        goto label_6;
    }
    *((esp + 0xc)) = ebx;
    do {
        edx = *((esp + 0x10));
        eax = *((edx - 4));
        ecx = *((edx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_7;
            }
            ecx = *((edx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_8;
            }
label_3:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_9;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ebx*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 0x14));
        edx = *((esp + 4));
        camlArray_trickle_1165 ();
        ebx = *((esp + 0xc));
        eax = *((esp + 0xc));
        ebx -= 2;
        *((esp + 0xc)) = ebx;
    } while (eax != 1);
label_6:
    esi = *((esp + 0x14));
    esi += 0xfffffffe;
    if (esi < 5) {
        goto label_10;
    }
    *((esp + 0xc)) = esi;
    do {
        ebx = *((esp + 0x10));
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_11;
            }
            eax = *((ebx + esi*2 - 2));
            *((esp + 4)) = eax;
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_12;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            *((esp + 4)) = eax;
        }
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= 1) {
                goto label_14;
            }
            edx = *(ebx);
        } else {
            eax >>= 0xa;
            if (eax <= 1) {
                goto label_15;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_17;
            }
            eax = caml_modify (ebx + esi*2 - 2, edx);
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_18;
            }
            *(fp_stack--) = *(edx);
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = 1;
        eax = esi;
        ecx = *(esp);
        camlArray_bubble_1174 ();
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        camlArray_trickleup_1178 ();
        esi = *((esp + 0xc));
        eax = *((esp + 0xc));
        esi -= 2;
        *((esp + 0xc)) = esi;
    } while (eax != 5);
label_10:
    eax = *((esp + 0x14));
    if (eax <= 3) {
        goto label_19;
    }
    ebx = *((esp + 0x10));
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_20;
        }
        esi = *((ebx + 4));
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_21;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_22;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x8fd;
        *(fp_stack--) = *((ebx + 8));
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_23;
        }
        edx = *(ebx);
        goto label_24;
    }
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_25;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(edx) = fp_stack[0];
            fp_stack--;
label_24:
            eax = *((ebx - 4));
            ecx = *((ebx - 4));
            ecx &= 0xff;
            if (ecx != 0xfe) {
                eax >>= 9;
                if (eax <= 3) {
                    goto label_26;
                }
                eax = ebx;
                eax += 4;
                eax = caml_modify (eax, edx);
            } else {
                eax >>= 0xa;
                if (eax <= 3) {
                    goto label_27;
                }
                *(fp_stack--) = *(edx);
                *((ebx + 8)) = fp_stack[0];
                fp_stack--;
            }
            eax = *((ebx - 4));
            ecx = *((ebx - 4));
            ecx &= 0xff;
            if (ecx != 0xfe) {
                eax >>= 9;
                if (eax <= 1) {
                    goto label_28;
                }
                eax = caml_modify (ebx, esi);
            } else {
                eax >>= 0xa;
                if (eax <= 1) {
                    goto label_29;
                }
                *(fp_stack--) = *(esi);
                *(ebx) = fp_stack[0];
                fp_stack--;
            }
            eax = 1;
            return eax;
label_19:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_22:
    caml_call_gc ();
    goto label_0;
label_16:
    caml_call_gc ();
    goto label_1;
label_13:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_5:
    caml_call_gc ();
    goto label_4;
label_29:
    caml_ml_array_bound_error ();
label_28:
    caml_ml_array_bound_error ();
label_27:
    caml_ml_array_bound_error ();
label_26:
    caml_ml_array_bound_error ();
label_25:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_21:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c5a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2804 (void) {
    eax = unix_fstat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804fe40 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_string_1279 (void) {
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059ae0 */
#include <stdint.h>
 
int32_t camlPrintf_add_char_1192 (void) {
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8052960 */
#include <stdint.h>
 
int32_t camlArray_list_length_1126 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 2;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e509 */
#include <stdint.h>
 
int32_t unix_setitimer (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_38h;
    int32_t var_28h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13c2f;
    esi = *((ebp + 0xc));
    edi = ebp - 0x28;
    *(fp_stack--) = *(esi);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = edi;
    unix_set_timeval ();
    eax = ebp - 0x20;
    *(fp_stack--) = *((esi + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    unix_set_timeval ();
    eax = ebp - 0x38;
    *((esp + 8)) = eax;
    *((esp + 4)) = edi;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x15fc));
    *(esp) = eax;
    eax = setitimer ();
    if (eax == -1) {
        eax = ebx - 0x1607;
        uerror (eax, 0);
    }
    eax = ebp - 0x38;
    unix_convert_itimer ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a084 */
#include <stdint.h>
 
void setitimer (void) {
    setitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80566a0 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_in_bucket_1230 (void) {
    int32_t var_4h_2;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, ebx);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f570 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1412 (void) {
    eax = caml_ml_channel_size;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806bbca */
#include <stdint.h>
 
uint32_t caml_sys_read_directory (void) {
    int32_t var_58h_2;
    int32_t var_50h_2;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_2ch_2;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h_2;
    int32_t var_4h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    ebx = ebp - 0x58;
    caml_ext_table_init (ebx, esi);
    eax = *((ebp + 8));
    eax = caml_read_directory (eax, ebx);
    if (eax == -1) {
        caml_ext_table_free (ebx, 1);
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    ebx = ebp - 0x58;
    caml_ext_table_add (ebx, 0);
    eax = *((ebp - 0x50));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x2c)) = eax;
    caml_ext_table_free (ebx, 1);
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054a80 */
#include <stdint.h>
 
int32_t camlList_mem_assoc_1179 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ebx = *(ebx);
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805a590 */
#include <stdint.h>
 
int32_t camlPrintf_valid_float_loop_1273 (void) {
    do {
        ecx = *((ebx + 0xc));
        if (eax >= ecx) {
            ecx = loc.camlPrintf__62;
            eax = *((ebx + 8));
            ebx = ecx;
            void (*0x804f710)() ();
        }
        edx = *((ebx + 8));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        ecx += 0xffffffa4;
        if (ecx > 0x2f) {
            if (ecx == 0x6f) {
                goto label_1;
            }
        } else {
            ecx += 0xfffffffe;
            if (ecx > 0x2b) {
                goto label_1;
            }
        }
        eax += 2;
    } while (1);
label_1:
    eax = *((ebx + 8));
    return eax;
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b0e0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1700 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8066a75 */
#include <stdint.h>
 
int32_t caml_int64_shift_right (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shrd eax, edx, cl");
    edx >>= cl;
    if ((cl & 0x20) != 0) {
        eax = edx;
        edx >>= 0x1f;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f1f0 */
#include <stdint.h>
 
int32_t camlPervasives_iter_1186 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ebx = *((eax + 4));
        *(esp) = ebx;
        eax = *(eax);
        fcn_0804f210 ();
        eax = *(esp);
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f590 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1416 (void) {
    eax = caml_ml_seek_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ddf0 */
#include <stdint.h>
 
int32_t camlUnix_close_process_out_2006 (void) {
    int32_t var_4h;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x402;
            *(ebx) = ecx;
            eax = "close_process_out";
            eax = camlUnix_find_proc_id_1997 ();
            eax = *(esp);
            camlPervasives_close_out_1209 (eax);
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8057ac0 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_1112 (void) {
    int32_t var_4h_4;
    int32_t var_8h_4;
    int32_t var_ch_4;
    int32_t var_ch_5;
    int32_t var_18h;
    int32_t var_24h;
    edi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x10f7;
    *(edx) = sym.camlHashtbl__replace_bucket_1116;
    *((edx + 4)) = 3;
    *((edx + 8)) = ebx;
    *((edx + 0xc)) = ecx;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (edx, ebx, ecx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    *((esp + 0x18)) = edx;
    ebx = *((edi + 4));
    eax = *((ebx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    eax = *((ebx + edx*2 - 2));
    eax = void (*0x8057c20)(uint32_t) (eax);
    ecx = " %\a\b";
    ebx = *(eax);
    if (ebx != ecx) {
        goto label_3;
    }
    ebx = *(esp);
    edx = *((ebx + 4));
    eax = *((edx - 4));
    eax >>= 9;
    ecx = *((esp + 0x18));
    if (eax <= ecx) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0xc00;
            eax = *((esp + 4));
            *(esi) = eax;
            eax = *((esp + 8));
            *((esi + 4)) = eax;
            eax = *((esp + 0xc));
            *((esi + 8)) = eax;
            caml_modify (edx + ecx*2 - 2, esi);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = .comment;
                void (*0x80574c0)() ();
            }
            eax = 1;
            return eax;
label_3:
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = *((edi + 4));
            *((esp + 0x1c)) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_5;
            }
            ebx = *((esp + 0x18));
            eax = camlHashtbl_replace_bucket_1116 ();
            ebx = *((esp + 0x20));
            eax = *((esp + 0x24));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80677de */
#include <stdint.h>
 
int32_t caml_float_of_substring (void) {
    uint32_t var_5ch;
    int32_t var_58h_3;
    char * * endptr;
    int32_t var_10h;
    int32_t var_58h_2;
    int32_t var_8h;
    int32_t var_ch;
    esi = *((ebp + 0xc));
    esi >>= 1;
    eax = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    if (esi >= 0) {
        if (eax > esi) {
            ebx = *((ebp + 0x10));
            ebx >>= 1;
            if (ebx <= 0) {
                goto label_0;
            }
            eax -= esi;
            if (ebx > eax) {
                goto label_0;
            }
            if (ebx <= 0x3f) {
                edi = ebp - 0x58;
                goto label_1;
            }
            eax = ebx + 1;
            eax = caml_stat_alloc (eax);
            edi = eax;
        }
    } else {
label_0:
        ebx = 0;
        edi = ebp - 0x58;
    }
label_1:
    eax = *((ebp + 8));
    eax = esi + eax;
    esi = edi;
    while (ebx != 0) {
        edx = *(eax);
        if (dl != 0x5f) {
            *(esi) = dl;
            esi++;
        }
        eax++;
        ebx--;
    }
    *(esi) = 0;
    if (esi != edi) {
        eax = ebp - 0x5c;
        strtod (edi, eax);
        *((ebp - 0x70)) = fp_stack[0];
        fp_stack--;
        if (*((ebp - 0x5c)) != esi) {
            goto label_2;
        }
        eax = ebp - 0x58;
        if (edi != eax) {
            caml_stat_free (edi);
        }
        *(fp_stack--) = *((ebp - 0x70));
        *(esp) = fp_stack[0];
        fp_stack--;
        caml_copy_double ();
        return eax;
    }
label_2:
    eax = ebp - 0x58;
    if (edi != eax) {
        caml_stat_free (edi);
    }
    return caml_failwith ("float_of_string");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80672bf */
#include <stdint.h>
 
int32_t caml_atan2_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    atan2 (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a604 */
#include <stdint.h>
 
void atan2 (void) {
    atan2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c000 */
#include <stdint.h>
 
int32_t camlUnix_fun_2686 (void) {
    eax = unix_readdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8059330 */
#include <stdint.h>
 
int32_t camlPrintf_parse_1069 (void) {
    do {
label_0:
        edx = eax;
        esi = *((ecx + 0xc));
        eax = *((esi - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        esi = *((esi + eax));
        eax -= esi;
        eax = eax + eax + 1;
        if (ebx >= eax) {
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = 1;
            *((eax + 4)) = edx;
            return eax;
        }
        esi = ebx;
        esi >>= 1;
        eax = *((ecx + 0xc));
        eax = *((eax + esi));
        eax = eax + eax + 1;
        if (eax >= 0x63) {
            if (eax >= 0x75) {
                goto label_4;
            }
            esi = *((ecx + 0xc));
            eax = *((esi - 4));
            eax >>= 0xa;
            edx = eax*4 - 1;
            eax = *((esi + edx));
            edx -= eax;
            edx <<= 1;
            edx -= ebx;
            edx -= 3;
            edx += 3;
            eax = *((ecx + 0xc));
            ecx = edx;
            eax = camlString_sub_1046 (edx);
            eax = caml_int_of_string;
            eax = caml_c_call (eax);
            ecx = eax;
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *(esp);
            *((ebx + 4)) = eax;
            eax = ebx;
            return eax;
        }
        if (eax != 0x5b) {
            goto label_4;
        }
        ebx += 2;
        eax = 3;
    } while (1);
label_4:
    ebx += 2;
    eax = edx;
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c78c */
#include <stdint.h>
 
uint32_t unix_chdir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x159af;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = chdir ();
    if (eax == -1) {
        eax = ebx - 0x1719;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065c49 */
#include <stdint.h>
 
int32_t caml_lessequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x807f400) {
        compare_free_stack ();
    }
    dl = (ebx <= 0) ? 1 : 0;
    al = (ebx != 0x80000000) ? 1 : 0;
    eax = (int32_t) al;
    eax &= edx;
    eax += eax;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806babe */
#include <stdint.h>
 
int32_t caml_sys_close (int32_t fildes) {
    eax = *((ebp + 8));
    eax >>= 1;
    close (eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd20 */
#include <stdint.h>
 
int32_t camlUnix_fun_2604 (void) {
    eax = unix_socketpair;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8054800 */
#include <stdint.h>
 
int32_t camlList_for_all2_1145 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        if (eax == 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_2:
    eax = 1;
    return eax;
label_0:
    if (ecx == 1) {
        eax = 3;
        return eax;
    }
label_1:
    eax = "List.for_all2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e5ec */
#include <stdint.h>
 
int32_t unix_link (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13b4f;
    esi = *((ebp + 0xc));
    *((esp + 4)) = esi;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = link ();
    if (eax == -1) {
        eax = ebx - 0x1590;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a784 */
#include <stdint.h>
 
void link (void) {
    link ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8061338 */
#include <stdint.h>
 
int32_t unix_single_write (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, char * ptr, size_t nbytes) {
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x10dfd;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    if (esi > 0) {
        eax = 0x4000;
        if (esi > 0x4000) {
            esi = eax;
        }
        eax = *((ebp + 0x10));
        eax >>= 1;
        eax += *((ebp + 0xc));
        edi = ebp - 0x4018;
        memmove (edi, eax, esi);
        caml_enter_blocking_section ();
        eax = *((ebp + 8));
        eax >>= 1;
        eax = write (eax, edi, esi);
        esi = eax;
        caml_leave_blocking_section ();
        if (esi != -1) {
            goto label_0;
        }
        eax = ebx - 0x1289;
        uerror (eax, 0);
    }
    esi = 0;
label_0:
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a004 */
#include <stdint.h>
 
void write (void) {
    write ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805fea4 */
#include <stdint.h>
 
uint32_t unix_socketpair (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_10h;
    int32_t var_bp_ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1229c;
    eax = ebp - 0x10;
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebx - 0x1c));
    eax = *((eax + edx*4));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *((ebx - 0x20));
    eax = *((eax + edx*4));
    *(esp) = eax;
    eax = socketpair ();
    if (eax == -1) {
        eax = ebx - 0x14ed;
        uerror (eax, 0);
    }
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x10));
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((ebp - 0xc));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049fa4 */
#include <stdint.h>
 
void socketpair (void) {
    socketpair ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e98c */
#include <stdint.h>
 
int32_t unix_mkdir (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x137af;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = mkdir ();
    if (eax == -1) {
        eax = ebx - 0x15cc;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e74 */
#include <stdint.h>
 
void mkdir (void) {
    mkdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806cbcd */
#include <stdint.h>
 
uint32_t caml_gc_counters (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x2c)) = ebx;
    eax = ebp - 0x2c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    eax = ebp - 0xc;
    *((ebp - 0x20)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x40)) = eax;
    *((ebp - 0x3c)) = edx;
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x58)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x50)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x40)) = eax;
    *((ebp - 0x3c)) = edx;
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x48)) = fp_stack[0];
    fp_stack--;
    eax = caml_alloc_tuple (ebx);
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0x58));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x50));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x48));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    eax += 8;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058630 */
#include <stdint.h>
 
int32_t camlBuffer_reset_1064 (void) {
    ebx = eax;
    *((ebx + 4)) = 1;
    caml_modify (ebx, *((ebx + 0xc)));
    ecx = *(ebx);
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((ecx + eax));
    eax -= ecx;
    eax = eax + eax + 1;
    *((ebx + 8)) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805e348 */
#include <stdint.h>
 
int32_t unix_initgroups (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13df8;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = initgroups ();
    if (eax == -1) {
        eax = ebx - 0x161c;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a564 */
#include <stdint.h>
 
void initgroups (void) {
    initgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805c480 */
#include <stdint.h>
 
int32_t loc_camlCallback_code_begin (void) {
    eax = caml_register_named_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051070 */
#include <stdint.h>
 
uint32_t camlArray_trickle_1165 (void) {
    int32_t var_4h_2;
    eax = void (*0x8051100)(uint32_t, uint32_t) (edx, ecx);
    ecx = .comment;
    ebx = *(eax);
    if (ebx == ecx) {
        ebx = *((eax + 4));
        eax = *(esp);
        eax = *((eax + 0xc));
        ecx = *((eax - 4));
        edx = *((eax - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            ecx >>= 9;
            if (ecx <= ebx) {
                goto label_0;
            }
            ecx = *((esp + 4));
            caml_modify (eax + ebx*2 - 2, ecx);
        } else {
            ecx >>= 0xa;
            if (ecx <= ebx) {
                goto label_1;
            }
            ecx = *((esp + 4));
            *(fp_stack--) = *(ecx);
            *((eax + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = 1;
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    edx = *((edx + 0x10));
    camlArray_trickledown_1160 (*(obj.caml_exception_pointer));
    return eax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bd00 */
#include <stdint.h>
 
int32_t camlUnix_fun_2600 (void) {
    eax = unix_bind;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d740 */
#include <stdint.h>
 
int32_t camlUnix_open_process_out_1962 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *(esp) = ebx;
    eax = *(eax);
    *((esp + 8)) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (ebx);
    ecx = eax;
    *((esp + 0xc)) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0x800;
            eax = *(esp);
            *(esi) = eax;
            *((esi + 4)) = 1;
            ebx = esi + 0xc;
            *((ebx - 4)) = 0x402;
            *(ebx) = ecx;
            edx = 3;
            eax = *((esp + 4));
            ecx = *((esp + 8));
            camlUnix_open_proc_1949 ();
            eax = *((esp + 8));
            eax = unix_close;
            caml_c_call (eax);
            eax = *((esp + 0xc));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80672e5 */
#include <stdint.h>
 
int32_t caml_atan_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    atan (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a1d4 */
#include <stdint.h>
 
void atan (void) {
    atan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806ccbc */
#include <stdint.h>
 
uint32_t caml_gc_quick_stat (void) {
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x3c)) = ebx;
    eax = ebp - 0x3c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x78)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x70)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x68)) = fp_stack[0];
    fp_stack--;
    esi = caml_stat_minor_collections;
    edi = caml_stat_major_collections;
    eax = caml_stat_heap_size;
    eax >>= 2;
    *((ebp - 0x60)) = eax;
    eax = caml_stat_top_heap_size;
    eax >>= 2;
    *((ebp - 0x5c)) = eax;
    eax = caml_stat_compactions;
    *((ebp - 0x58)) = eax;
    edx = caml_stat_heap_chunks;
    *((ebp - 0x54)) = edx;
    eax = caml_alloc_tuple (ebx, esi, edi);
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((ebp - 0x78));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x70));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x68));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 8;
    caml_modify (eax, eax);
    eax = esi + esi + 1;
    eax = *((ebp - 0x1c));
    eax += 0xc;
    caml_modify (eax, eax);
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x10;
    caml_modify (eax, eax);
    edx = *((ebp - 0x60));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x14;
    caml_modify (eax, eax);
    edx = *((ebp - 0x54));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
    eax = *((ebp - 0x1c));
    eax += 0x1c;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x20;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x24;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x28;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x2c;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x30;
    caml_modify (eax, 1);
    edx = *((ebp - 0x58));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x34;
    caml_modify (eax, eax);
    edx = *((ebp - 0x5c));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x38;
    caml_modify (eax, eax);
    caml_stack_usage ();
    eax = eax + eax + 1;
    eax = *((ebp - 0x1c));
    eax += 0x3c;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804b190 */
#include <stdint.h>
 
int32_t caml_curry5_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d6a0 */
#include <stdint.h>
 
int32_t camlUnix_open_process_in_1957 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 8)) = ebx;
    eax = *(eax);
    *(esp) = eax;
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ecx = eax;
    *((esp + 0xc)) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0x800;
            eax = *(esp);
            *(esi) = eax;
            *((esi + 4)) = 1;
            ebx = esi + 0xc;
            *((ebx - 4)) = 0x401;
            *(ebx) = ecx;
            ecx = 1;
            eax = *((esp + 4));
            edx = *((esp + 8));
            camlUnix_open_proc_1949 ();
            eax = *((esp + 8));
            eax = unix_close;
            caml_c_call (eax);
            eax = *((esp + 0xc));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804ff40 */
#include <stdint.h>
 
int32_t camlPervasives_read_float_1290 (void) {
    eax = 1;
    eax = camlPervasives_read_line_1288 ();
    eax = caml_float_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80672a2 */
#include <stdint.h>
 
int32_t caml_ceil_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    ceil (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051280 */
#include <stdint.h>
 
int32_t camlArray_trickleup_1178 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    do {
        esi = eax;
        edi = ecx;
        ecx = 3;
        eax = esi;
        eax += 0xfffffffe;
        eax >>= 1;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        ecx = eax + eax + 1;
        if (esi != ecx) {
            *((esp + 0xc)) = ecx;
            *(esp) = edi;
            *((esp + 4)) = ebx;
            *((esp + 8)) = esi;
        } else {
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x80765d4;
            caml_raise_exn ();
        }
        edx = *((edi + 0x10));
        eax = *((edx - 4));
        esi = *((edx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_4;
            }
            eax = *((edx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_5;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_6;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((edi + 0xc));
        eax = caml_apply2 ();
        if (eax >= 1) {
            goto label_7;
        }
        edi = *(esp);
        ebx = *((edi + 0x10));
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            esi = *((esp + 0xc));
            if (eax <= esi) {
                goto label_8;
            }
            ecx = *((ebx + esi*2 - 2));
        } else {
            eax >>= 0xa;
            esi = *((esp + 0xc));
            if (eax <= esi) {
                goto label_9;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + esi*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((edi + 0x10));
        edx = *((eax - 4));
        ebx = *((eax - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            edx >>= 9;
            ebx = *((esp + 8));
            if (edx <= ebx) {
                goto label_11;
            }
            caml_modify (eax + ebx*2 - 2, ecx);
        } else {
            edx >>= 0xa;
            ebx = *((esp + 8));
            if (edx <= ebx) {
                goto label_12;
            }
            *(fp_stack--) = *(ecx);
            *((eax + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        if (esi <= 1) {
            goto label_13;
        }
        eax = esi;
        ebx = *((esp + 4));
        ecx = edi;
    } while (1);
label_13:
    ecx = *((edi + 0x10));
    ebx = *((ecx - 4));
    eax = *((ecx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ebx;
        eax >>= 9;
        if (eax <= 1) {
            goto label_14;
        }
        eax = *((esp + 4));
        caml_modify (ecx, eax);
    } else {
        eax = ebx;
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_15;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *(ecx) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_7:
    eax = *(esp);
    eax = *((eax + 0x10));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        ecx = *((esp + 8));
        if (ebx <= ecx) {
            goto label_16;
        }
        ebx = *((esp + 4));
        caml_modify (eax + ecx*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        ecx = *((esp + 8));
        if (ebx <= ecx) {
            goto label_17;
        }
        ebx = *((esp + 4));
        *(fp_stack--) = *(ebx);
        *((eax + ecx*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_10:
    caml_call_gc ();
    goto label_0;
label_6:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
label_17:
    caml_ml_array_bound_error ();
label_16:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80628a3 */
#include <stdint.h>
 
uint32_t caml_execute_signal (int32_t arg_8h, uint32_t arg_ch) {
    int32_t var_98h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = ebp - 0x98;
    *(esp) = esi;
    sigemptyset ();
    *((esp + 4)) = ebx;
    *(esp) = esi;
    sigaddset ();
    *((esp + 8)) = esi;
    *((esp + 4)) = esi;
    *(esp) = 0;
    sigprocmask ();
    caml_rev_convert_signal_number (ebx);
    eax = eax + eax + 1;
    eax = caml_signal_handlers;
    eax = *((eax + ebx*4));
    eax = caml_callback_exn (eax, eax);
    edi = eax;
    if (*((ebp + 0xc)) == 0) {
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        *(esp) = 2;
        sigprocmask ();
        eax = edi;
        eax &= 3;
        if (eax != 2) {
            goto label_0;
        }
    } else {
        eax &= 3;
        if (eax != 2) {
            goto label_0;
        }
        *((esp + 4)) = ebx;
        eax = ebp - 0x98;
        *(esp) = eax;
        sigdelset ();
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        *(esp) = 2;
        sigprocmask ();
    }
    edi &= 0xfffffffc;
    caml_raise (edi);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c090 */
#include <stdint.h>
 
int32_t camlUnix_fun_2704 (void) {
    eax = unix_clear_nonblock;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804aed0 */
#include <stdint.h>
 
int32_t caml_curry7_6 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 4)) = eax;
    esi = ebx;
    eax = *((esi + 0xc));
    ecx = *((eax + 0xc));
    edi = *((ecx + 0xc));
    ebp = *((edi + 0xc));
    ebx = *((ebp + 0xc));
    edx = *((ebx + 0xc));
    *((esp + 8)) = edx;
    esi = *((esi + 8));
    *(esp) = esi;
    eax = *((eax + 8));
    *((esp + 0x10)) = eax;
    esi = *((ecx + 8));
    ecx = *((edi + 8));
    edi = *((ebp + 8));
    eax = *((ebx + 8));
    ebx = *((edx + 8));
    *((esp + 0xc)) = ebx;
    ebx = edi;
    edx = esi;
    esi = *((esp + 0x10));
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 8));
    *(0x807b860) = ebp;
    ebp = *((esp + 0xc));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8069021 */
#include <stdint.h>
 
uint32_t caml_really_putblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (ebx <= 0) {
        goto label_0;
    }
    do {
        eax = caml_putblock (edi, esi, ebx);
        esi += eax;
        ebx -= eax;
    } while (ebx > 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805d4cc */
#include <stdint.h>
 
uint32_t unix_geteuid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14c74;
    geteuid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a8f4 */
#include <stdint.h>
 
void geteuid (void) {
    geteuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067006 */
#include <stdint.h>
 
int32_t caml_ge_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806b2c7 */
#include <stdint.h>
 
uint32_t caml_input_value_from_malloc (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 8));
    *(obj.intern_input) = edx;
    edx += *((ebp + 0xc));
    *(obj.intern_input_malloced) = 1;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith ("input_value_from_malloc: bad object");
    }
    eax += 4;
    *(obj.intern_src) = eax;
    eax = input_val_from_block ();
    ebx = eax;
    eax = intern_input;
    caml_stat_free (eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f860 */
#include <stdint.h>
 
int32_t camlPervasives_valid_float_lexem_1135 (void) {
    ecx = eax;
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    edx = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = loc.camlPervasives__code_begin;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            *((ebx + 0xc)) = edx;
            eax = 1;
            void (*0x804f170)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804c070 */
#include <stdint.h>
 
int32_t camlUnix_fun_2700 (void) {
    eax = unix_clear_close_on_exec;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8058580 */
#include <stdint.h>
 
int32_t camlBuffer_blit_1051 (void) {
    if (esi >= 1) {
        if (ebx < 1) {
            goto label_0;
        }
        edi = *((eax + 4));
        edi -= esi;
        edi++;
        if (ebx > edi) {
            goto label_0;
        }
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ecx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ecx + ebp));
        ebp -= edi;
        edi = ebp;
        edi <<= 1;
        edi -= esi;
        edi += 2;
        if (edx > edi) {
            goto label_0;
        }
        eax = *(eax);
        void (*0x80556e0)() ();
    }
label_0:
    eax = "Buffer.blit";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805b250 */
#include <stdint.h>
 
uint32_t camlPrintf_incomplete_format_1065 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    camlString_sub_1046 ();
    ebx = camlPrintf__48;
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = "Printf: premature end of format string ``";
    camlPervasives_$5e_1112 ();
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806f93a */
#include <stdint.h>
 
int32_t caml_find_custom_operations (int32_t arg_8h) {
    char * s2;
    edi = *((ebp + 8));
    ebx = custom_ops_table;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        esi = *(ebx);
        eax = *(esi);
        eax = strcmp (eax, edi);
        if (eax == 0) {
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    esi = 0;
label_1:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806197c */
#include <stdint.h>
 
int32_t main (char ** envp) {
    eax = *((ebp + 0xc));
    caml_main (eax);
    return caml_sys_exit (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806055d */
#include <stdint.h>
 
uint32_t unix_fstat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11be3;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = fxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x1446;
        uerror (eax, 0);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x1446;
        unix_error (0x4b, eax, 0);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049d84 */
#include <stdint.h>
 
void init (void) {
    /* [11] -r-x section size 48 named .init */
    void (*0x8049d90)(uint32_t) (ebx);
    ebx += 0x283bc;
    edx = *((ebx - 0x24));
    if (edx != 0) {
        gmon_start_ ();
    }
    frame_dummy ();
    _do_global_ctors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f14 */
#include <stdint.h>
 
void loc_imp_gmon_start_ (void) {
    gmon_start_ ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8067393 */
#include <stdint.h>
 
int32_t caml_cos_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    cos (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a3c4 */
#include <stdint.h>
 
void cos (void) {
    cos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bb10 */
#include <stdint.h>
 
int32_t camlUnix_fun_2833 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ecx;
            ebx = *((ebx + 8));
            ebx = *(ebx);
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8051b60 */
#include <stdint.h>
 
int32_t camlArray_make_matrix_1042 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *(esp) = eax;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    ecx = 1;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ecx > eax) {
        goto label_0;
    }
    *((esp + 0x10)) = eax;
    *(esp) = ecx;
    *((esp + 0xc)) = ebx;
    do {
        eax = *((esp + 4));
        eax = *((esp + 0xc));
        eax = caml_make_vect;
        eax = caml_c_call (eax);
        esi = *((esp + 4));
        ebx = *((esp + 0x10));
        caml_modify (ebx + esi*2 - 2, eax);
        ecx = esi;
        esi += 2;
        *(esp) = esi;
        eax = *((esp + 0x10));
    } while (ecx != eax);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fef7 */
#include <stdint.h>
 
int32_t caml_get_exception_backtrace (void) {
    int32_t var_6ch;
    uint32_t var_60h;
    uint32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x6c)) = eax;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 0;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x48;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x40)) = 1;
    *((ebp - 0x44)) = 4;
    eax = ebp - 0x1c;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x30)) = eax;
    eax = caml_backtrace_pos;
    eax = caml_alloc (ebx, esi, edi);
    *((ebp - 0x20)) = eax;
    if (*(obj.caml_backtrace_pos) <= 0) {
        goto label_0;
    }
    ebx = 0;
    edi = ebp - 0x60;
    do {
        esi = ebx*4;
        eax = caml_backtrace_buffer;
        eax = *((eax + esi));
        edx = edi;
        extract_location_info ();
        if (*((ebp - 0x60)) != 0) {
            eax = *((ebp - 0x58));
            eax = caml_copy_string (eax);
            *((ebp - 0x28)) = eax;
            eax = caml_alloc_small (5, 0);
            edx -= edx;
            edx &= 0xfffffffe;
            edx += 3;
            *((ebp - 0x24)) = eax;
            *(eax) = edx;
            edx = *((ebp - 0x28));
            eax = *((ebp - 0x24));
            *((eax + 4)) = edx;
            eax = *((ebp - 0x54));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 8)) = edx;
            eax = *((ebp - 0x50));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 0xc)) = edx;
            eax = *((ebp - 0x4c));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 0x10)) = edx;
        } else {
            eax = caml_alloc_small (1, 1);
            edx -= edx;
            edx &= 0xfffffffe;
            edx += 3;
            *((ebp - 0x24)) = eax;
            *(eax) = edx;
        }
        eax = *((ebp - 0x24));
        esi += *((ebp - 0x20));
        caml_modify (esi, eax);
        ebx++;
    } while (*(obj.caml_backtrace_pos) > ebx);
label_0:
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x1c)) = eax;
    edx = *((ebp - 0x20));
    *(eax) = edx;
    eax = *((ebp - 0x6c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80599d0 */
#include <stdint.h>
 
int32_t camlPrintf_add_char_1166 (void) {
    eax = *((ecx + 0xc));
    camlBuffer_add_char_1072 (eax);
    eax = *(esp);
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80591d0 */
#include <stdint.h>
 
int32_t camlPrintf_cont_a_1362 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = eax;
    edi = ebx;
    ebx = ecx;
    *((esp + 4)) = edx;
    *((esp + 8)) = esi;
    eax = *((esi + 0x3c));
    if (eax != 1) {
        eax = 1;
        ecx = edi;
        eax = caml_apply2 ();
        ebx = eax;
        eax = *((esp + 8));
        ecx = *((eax + 0x44));
        eax = *((eax + 0x4c));
        caml_apply2 ();
    } else {
        eax = *((esi + 0x4c));
        ecx = edi;
        caml_apply2 ();
    }
    ecx = *((esp + 8));
    ecx += 0xffffffe0;
    eax = *(esp);
    ebx = *((esp + 4));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f9f0 */
#include <stdint.h>
 
int32_t camlPervasives_output_1194 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = caml_ml_output;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "output";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806fe50 */
#include <stdint.h>
 
int32_t caml_backtrace_status (void) {
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804bfe0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2682 (void) {
    eax = unix_closedir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805dcca */
#include <stdint.h>
 
int32_t unix_getprotobynumber (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14476;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getprotobynumber ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_proto_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a1f4 */
#include <stdint.h>
 
void getprotobynumber (void) {
    getprotobynumber ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x805f6dc */
#include <stdint.h>
 
int32_t unix_setgid (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12a64;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = setgid ();
    if (eax == -1) {
        eax = ebx - 0x1553;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a7c4 */
#include <stdint.h>
 
void setgid (void) {
    setgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8053130 */
#include <stdint.h>
 
int32_t camlArray_stable_sort_1188 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h_2;
    int32_t var_14h_2;
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x4c;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry7;
    *((eax + 4)) = 0xf;
    *((eax + 8)) = 0x8051550;
    *((eax + 0xc)) = ecx;
    *((eax + 0x10)) = ebx;
    esi = eax + 0x18;
    *((esi - 4)) = 0x14f7;
    *(esi) = sym.caml_curry4;
    *((esi + 4)) = 9;
    *((esi + 8)) = 0x80516e0;
    *((esi + 0xc)) = ecx;
    *((esi + 0x10)) = ebx;
    ecx = eax + 0x30;
    *((ecx - 4)) = 0x18f7;
    *(ecx) = sym.caml_curry4;
    *((ecx + 4)) = 9;
    *((ecx + 8)) = 0x80519e0;
    *((ecx + 0xc)) = ebx;
    *((ecx + 0x10)) = eax;
    *((ecx + 0x14)) = esi;
    edx = *((ebx - 4));
    edi = *((ebx - 4));
    edi &= 0xff;
    if (edi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    if (edx <= 0xb) {
        ecx = 1;
        eax = 1;
        void (*0x80516e0)() ();
    }
    *(esp) = ecx;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    eax = edx;
    eax >>= 1;
    if (eax < 0) {
        eax++;
    }
    eax >>= 1;
    eax = eax + eax + 1;
    *((esp + 8)) = eax;
    edx -= eax;
    edx++;
    *((esp + 4)) = edx;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_2;
        }
        eax = *(ebx);
        goto label_3;
    }
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(eax) = fp_stack[0];
            fp_stack--;
label_3:
            eax = caml_make_vect;
            eax = caml_c_call (edx);
            ebx = eax;
            ecx = 1;
            eax = *((esp + 8));
            edx = *((esp + 4));
            esi = *(esp);
            camlArray_sortto_1217 (ebx);
            eax = 1;
            ebx = *((esp + 0x10));
            ecx = *((esp + 4));
            edx = *((esp + 8));
            esi = *(esp);
            camlArray_sortto_1217 ();
            edx = 1;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            ecx = *((esp + 0xc));
            esi = eax;
            edi = *((esp + 0x10));
            *(loc.caml_extra_params) = ebp;
            ebp = *((esp + 0x14));
            *(0x807b860) = ebp;
            void (*0x8051550)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8065c91 */
#include <stdint.h>
 
int32_t caml_lessthan (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x807f400) {
        eax = compare_free_stack ();
    }
    ebx += 0x7fffffff;
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x806760a */
#include <stdint.h>
 
int32_t caml_fmod_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *(fp_stack--) = fp_stack[0];
    *(fp_stack--) = fp_stack[2];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (? == ?);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_0;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_1;
label_0:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_1:
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e14 */
#include <stdint.h>
 
void inet_ntop (void) {
    inet_ntop ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e54 */
#include <stdint.h>
 
void setgroups (void) {
    setgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049e84 */
#include <stdint.h>
 
void strerror (void) {
    strerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049ea4 */
#include <stdint.h>
 
void memcmp (void) {
    memcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049ec4 */
#include <stdint.h>
 
void freeaddrinfo (void) {
    freeaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f04 */
#include <stdint.h>
 
void sigismember (void) {
    sigismember ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f44 */
#include <stdint.h>
 
void isoc99_sscanf (void) {
    isoc99_sscanf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f74 */
#include <stdint.h>
 
void cfgetispeed (void) {
    cfgetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049f94 */
#include <stdint.h>
 
void strtod (void) {
    strtod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049fe4 */
#include <stdint.h>
 
void system (void) {
    system ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a0f4 */
#include <stdint.h>
 
void tcgetattr (void) {
    tcgetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a1b4 */
#include <stdint.h>
 
void inet_pton (void) {
    inet_pton ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a244 */
#include <stdint.h>
 
void fflush (void) {
    fflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a274 */
#include <stdint.h>
 
void gethostbyaddr_r (void) {
    gethostbyaddr_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a2f4 */
#include <stdint.h>
 
void getaddrinfo (void) {
    getaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a354 */
#include <stdint.h>
 
void readdir64 (void) {
    readdir64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a374 */
#include <stdint.h>
 
void memcpy (void) {
    memcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a384 */
#include <stdint.h>
 
void cfsetospeed (void) {
    cfsetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a394 */
#include <stdint.h>
 
void utime (void) {
    utime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a444 */
#include <stdint.h>
 
void sigdelset (void) {
    sigdelset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a454 */
#include <stdint.h>
 
void h_errno_location (void) {
    h_errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a504 */
#include <stdint.h>
 
void select (void) {
    select ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a664 */
#include <stdint.h>
 
void sigaddset (void) {
    sigaddset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a694 */
#include <stdint.h>
 
void cfgetospeed (void) {
    cfgetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a6b4 */
#include <stdint.h>
 
void strcat (void) {
    strcat ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a6f4 */
#include <stdint.h>
 
void gethostbyname_r (void) {
    gethostbyname_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a704 */
#include <stdint.h>
 
void fork (void) {
    fork ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a724 */
#include <stdint.h>
 
void setsockopt (void) {
    setsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a734 */
#include <stdint.h>
 
void tcsetattr (void) {
    tcsetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a744 */
#include <stdint.h>
 
void fcntl (void) {
    fcntl ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a774 */
#include <stdint.h>
 
void getgroups (void) {
    getgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a7b4 */
#include <stdint.h>
 
void getsockopt (void) {
    getsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a864 */
#include <stdint.h>
 
void strcmp (void) {
    strcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a874 */
#include <stdint.h>
 
void sigsetjmp (void) {
    sigsetjmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a8a4 */
#include <stdint.h>
 
void cfsetispeed (void) {
    cfsetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8049de4 */
#include <stdint.h>
 
void fmod (void) {
    fmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804a254 */
#include <stdint.h>
 
void sqrt (void) {
    sqrt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80487c5 */
#include <stdint.h>
 
void fcn_080487c5 (int32_t arg_2h) {
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += bl;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    al -= 4;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edx = 1;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + eax)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dh += ch;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(ecx) -= al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edx = 4;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += dl;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((esi + 5)) += dh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    bh += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(es:edi) = al;
    es:edi++;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((esi + 5)) += ch;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    ah += cl;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebp + 2)) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 4)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("in al, dx");
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax -= 5;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    al += cl;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 1)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(ecx) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 4)) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(fp_stack--) = *(ecx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax = *(ecx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("aam 4");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 4)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(gs:eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebx + eax)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("scasb al, byte es:[edi]");
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 3)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebx + 3)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    bh = 2;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edi = 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    bl += ch;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) &= eax;
    *(eax) += al;
    tmp_0 = eax;
    eax = esi;
    esi = tmp_0;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edi) += dl;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax += *(es:eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax = (int32_t) ax;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    es = *(edx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("in eax, 2");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    tmp_1 = eax;
    eax = ebx;
    ebx = tmp_1;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    if (*(eax) >= 0) {
        *(eax) += al;
        *(eax) += al;
    }
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += dl;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 3)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dl += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebp + eax)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 5)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("lar eax, word [eax]");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(esi) += dh;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dl += ch;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += eax;
    *(eax) += al;
    ebx--;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edi) += dh;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    cl += dh;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 5)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    cl += bh;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 3)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 2)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    ch += ah;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("int3");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804cf70 */
#include <stdint.h>
 
int32_t fcn_0804cf70 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    eax = 3;
    eax = camlList_mem_1161 (*(obj.caml_exception_pointer));
    while (1) {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = " %\a\b";
            caml_raise_exn ();
            eax = *((esp + 8));
            eax = unix_gethostbyaddr;
            eax = caml_c_call (eax);
            eax = *(eax);
        }
        caml_call_gc (eax);
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804d630 */
#include <stdint.h>
 
int32_t fcn_0804d630 (int32_t arg_ch) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x8073a44;
            eax = *((esp + 0xc));
            *((ebx + 8)) = eax;
            eax = unix_execv;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804da20 */
#include <stdint.h>
 
int32_t fcn_0804da20 (int32_t arg_18h, int32_t arg_1ch) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x8073a24;
            eax = *((esp + 0x18));
            *((ebx + 8)) = eax;
            eax = *((esp + 0x1c));
            eax = unix_execve;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x804f210 */
#include <stdint.h>
 
int32_t fcn_0804f210 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_flush;
    caml_c_call (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x8070360 */
#include <stdint.h>
 
void loc_caml_start_program (void) {
    esi = caml_startup__code_begin;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/matrix_ocaml/ia32_elf/subject.exe @ 0x80703f0 */
#include <stdint.h>
 
int32_t loc_caml_raise_exception (int32_t arg_4h) {
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        eax = *((esp + 4));
        esp = caml_exception_pointer;
        return eax;
    }
    esi = *((esp + 4));
    caml_stash_backtrace (esi, *(obj.caml_last_return_address), *(obj.caml_bottom_of_stack), *(obj.caml_exception_pointer));
    eax = esi;
    esp = caml_exception_pointer;
    return eax;
}
